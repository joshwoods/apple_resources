WEBVTT

00:00:13.539 --> 00:00:17.809
>> Welcome to the perfecting your
iPhone Table Views Session.

00:00:17.809 --> 00:00:18.699
My name is Jason Beaver.

00:00:18.699 --> 00:00:23.899
I'm an engineer on the iPhone Frameworks Team.

00:00:23.899 --> 00:00:27.979
This session assumes you have a basic
working knowledge of the Table View.

00:00:27.980 --> 00:00:30.379
We are going to cover-- do a quick overview.

00:00:30.379 --> 00:00:34.859
But for the most part, I'm going to expect the people
here to know how to get some content into a Table View

00:00:34.859 --> 00:00:37.689
and really going to move into some
of the more advanced content.

00:00:37.689 --> 00:00:41.820
So here's what we're going to cover today.

00:00:41.820 --> 00:00:45.350
We're going to start with a quick overview,
just so everyone's sort of on the same page

00:00:45.350 --> 00:00:49.000
about what a Table View is and what it can
do, and then we're going to start talking

00:00:49.000 --> 00:00:51.619
about some of the new stuff in iPhone OS 3.0.

00:00:51.619 --> 00:00:56.039
Then we're gonna delve rather deeply into cell structure.

00:00:56.039 --> 00:01:00.129
This is an area that I think there are some
misunderstandings about and I really want people

00:01:00.130 --> 00:01:03.870
to understand what happens inside a
cell, how the cells are put together.

00:01:03.869 --> 00:01:10.649
And then we're going to talk about cell design for some
rather complex cells, several approaches you can take

00:01:10.650 --> 00:01:12.290
and advantages and disadvantages of each.

00:01:12.290 --> 00:01:17.719
And then we'll go into a fairly in-depth
demo covering several basic approaches.

00:01:17.719 --> 00:01:22.870
And then we're going to cover some Gotchas, some
areas that we've seen other people have problems with

00:01:22.870 --> 00:01:28.040
and hopefully you guys could avoid some
of these issues after this session.

00:01:28.040 --> 00:01:31.620
So let's start with the overview.

00:01:33.439 --> 00:01:38.719
Table Views are obviously designed
to display lists of content.

00:01:38.719 --> 00:01:45.799
On iPhone OS, these are single column Table
Views but support an arbitrary number of rows.

00:01:45.799 --> 00:01:53.289
They only support vertical scrolling, no horizontal
scrolling, and they're designed for very large data sets.

00:01:53.290 --> 00:02:00.250
And as you'll see, these are very powerful objects
and unlike Table Views on typical desktop platforms,

00:02:00.250 --> 00:02:04.159
these are used in virtually every iPhone application.

00:02:04.159 --> 00:02:11.949
So here are a few examples of Table
Views that appear in iPhone OS 3.0.

00:02:11.949 --> 00:02:16.549
And as you can see, Table View supports
a very wide variety of display styles,

00:02:16.550 --> 00:02:20.710
even a few things that you wouldn't expect
for Table Views like the SMS conversation

00:02:20.710 --> 00:02:23.849
on the left, or the Hawaii photos there on the right.

00:02:23.849 --> 00:02:29.549
Those are just Table Views with custom
cells to render the content as appropriate.

00:02:29.550 --> 00:02:38.010
Table View supports two basic display styles; the Plain
style, where cell content extends from edge to edge

00:02:38.009 --> 00:02:43.750
of the Table View, and the Grouped style where
sections are surrounded by rounded rectangles

00:02:43.750 --> 00:02:48.080
and the content is inset inside these rounded rectangles.

00:02:50.569 --> 00:02:53.229
There are a few basic components of a Table View.

00:02:53.229 --> 00:02:59.899
There's an optional Table Header at the top of the content,
and an optional Table Footer at the bottom of the content.

00:02:59.900 --> 00:03:04.129
And the content is separated into separate sections.

00:03:04.129 --> 00:03:08.569
And Sections have optional Section
Headers and Section Footers,

00:03:08.569 --> 00:03:15.469
and then all of the data inside the Table View are
separated into rows that are drawn by table cells.

00:03:15.469 --> 00:03:20.609
So these are what the components look like in a Plain style
Table View, this is what they look like in a Grouped style,

00:03:20.610 --> 00:03:23.740
exact same components, just a different visual appearance.

00:03:23.740 --> 00:03:28.120
So that's a quick overview, and let's move in to what's new.

00:03:28.120 --> 00:03:31.189
And we're going to start with your Table View itself.

00:03:32.509 --> 00:03:38.759
Prior to 3.0, we have the ability to insert
and delete sections in an animated fashion.

00:03:38.759 --> 00:03:44.419
To this, we've added the ability to
reload sections in an animated fashion.

00:03:44.419 --> 00:03:50.000
Similarly, we have the ability to insert and delete
rows within a section in an animated fashion.

00:03:50.000 --> 00:03:53.569
We've added the ability to reload rows within a section.

00:03:53.569 --> 00:04:02.169
Prior to 3.0, if you-- if your delegate
received a message that the selection changed

00:04:02.169 --> 00:04:05.649
in the Table View, you were required to deselect the row.

00:04:05.650 --> 00:04:07.480
We've lifted that restriction in 3.0.

00:04:07.479 --> 00:04:12.199
Table View now does support persistent
selections allowing you to build user interfaces

00:04:12.199 --> 00:04:15.879
like the voice mail, and the new voice memos in 3.0.

00:04:18.490 --> 00:04:25.920
There's a new support class that sort of works
alongside UITableView called UILocalizedIndexCollation.

00:04:25.920 --> 00:04:32.330
And this is designed to allow you to take your
content and collate it or sort of bucketize it

00:04:32.329 --> 00:04:38.459
in a way that's appropriate for the user's current locale
and then sort all of the objects within each bucket in a way

00:04:38.459 --> 00:04:40.879
that makes sense again for the user's current locale.

00:04:40.879 --> 00:04:43.790
So let's look at what this might look like for English.

00:04:43.790 --> 00:04:48.020
Here are the objects that are in your model.

00:04:48.019 --> 00:04:53.829
Now if you ask UILocalizedIndexCollation for a set of
the Sections that will be displayed in the Table View,

00:04:53.829 --> 00:04:57.709
in English, you'll get back the standard
A through Z list, and a # at the bottom

00:04:57.709 --> 00:05:01.389
and you'll get back something else that's
appropriate for the user's current locale.

00:05:01.389 --> 00:05:04.149
But what's in that list really isn't important.

00:05:04.149 --> 00:05:12.599
Then for each object in your model, you can ask the
LocalizedIndexCollation which section should this appear in.

00:05:12.600 --> 00:05:16.360
So for example, in English, Daniel
Higgins would appear in the H section.

00:05:16.360 --> 00:05:19.949
And you'll do this for each object in your model until all

00:05:19.949 --> 00:05:24.209
of the objects have been placed
within one of those sections.

00:05:24.209 --> 00:05:30.439
Then for each section, you're going to take all of the
objects in that section and ask the LocalizedIndexCollation

00:05:30.439 --> 00:05:33.079
to sort those in a way that's appropriate
for the current locale.

00:05:33.079 --> 00:05:38.649
In this example, we only have one section that
has more than one object, but when we sort that,

00:05:38.649 --> 00:05:43.399
it will appear in a way that's
sorted appropriately for English.

00:05:43.399 --> 00:05:46.939
Once you've done this, you now have the data in a
format that's suitable for display in the Table View,

00:05:46.939 --> 00:05:51.550
so you can load the Table View and
the contents will appear there.

00:05:51.550 --> 00:06:00.530
So your Table View itself doesn't have a whole lot new, most
of the meat of what's new in 3.0 is in UITableView cell.

00:06:01.600 --> 00:06:04.510
The first is a new Designated Initializer.

00:06:04.509 --> 00:06:10.939
Prior to 3.0, when you created a cell, you used
the initWithFrame, reuseIdentifier Initializer.

00:06:10.939 --> 00:06:16.740
The frame argument was always ignored, the position
and size of the cell was defined by which row it was in

00:06:16.740 --> 00:06:19.740
and what the delegate specified as the height for that row.

00:06:19.740 --> 00:06:24.920
This has been replaced with the
new initWithStyle reuseIdentifier.

00:06:24.920 --> 00:06:27.230
And let's jump in to those cell styles.

00:06:27.230 --> 00:06:30.780
There are four of them supported in 3.0.

00:06:30.779 --> 00:06:32.809
The first is the Default Style.

00:06:32.810 --> 00:06:41.689
This gives you a stock Table View cell with the exact
same display characteristics we had prior in 2.0.

00:06:41.689 --> 00:06:43.480
The next is the Subtitle Style.

00:06:43.480 --> 00:06:47.450
This is the style we use in the iPod App
for music and albums and things like that.

00:06:47.449 --> 00:06:54.979
And this supports a title at the top and a subtitle
below and an optional image on the left hand side.

00:06:54.980 --> 00:06:59.569
There are two new Value Styles,
the Value1 and Value2 Styles.

00:06:59.569 --> 00:07:05.259
These are intended only to use
currently in Grouped style Table Views.

00:07:05.259 --> 00:07:10.149
And the Value1 is the same cell style
we use in the settings application

00:07:10.149 --> 00:07:16.009
and the Value2 Style is the same style we
use in the phone and contacts application.

00:07:16.009 --> 00:07:22.789
[ Pause ]

00:07:22.790 --> 00:07:23.939
>> Excuse me.

00:07:23.939 --> 00:07:33.719
If you want to set the image or
selected image on a cell prior to 3.0,

00:07:33.720 --> 00:07:36.480
you use the Image in Selected Image Properties.

00:07:36.480 --> 00:07:43.460
These have been deprecated in 3.0
and replaced with direct access

00:07:43.459 --> 00:07:46.739
to the Image View that's used to display those images.

00:07:46.740 --> 00:07:50.170
So if you had code that just set the image
on the cell, this would be replaced with code

00:07:50.170 --> 00:07:55.220
that set the image on the Image View in the Table Cell.

00:07:55.220 --> 00:07:57.470
Similarly, if you had set the selected Image 4,

00:07:57.470 --> 00:08:02.200
this would be replaced by setting the Image View's
Highlighted Image Property, and we'll talk a little bit

00:08:02.199 --> 00:08:06.819
about why this is Highlighted Image
and not Selected Image in a moment.

00:08:08.180 --> 00:08:12.689
Similarly, if you wanted to set the text
and appropriate associated text attributes

00:08:12.689 --> 00:08:14.600
in a cell, we have a whole bunch of properties.

00:08:14.600 --> 00:08:16.629
These were largely just mirrored from the label.

00:08:16.629 --> 00:08:20.800
So in 3.0, we've deprecated these
and just expose the label directly.

00:08:20.800 --> 00:08:24.930
This gives you not only access to these but
the other attributes that are on the label.

00:08:24.930 --> 00:08:32.769
So code that set the text on a cell replaced
by code that sets the text on the text label,

00:08:32.769 --> 00:08:38.269
code to set the font would replaced by code that sets
the font on the text label, similarly for all the ones.

00:08:38.269 --> 00:08:44.100
Again, with the exception of Selected Text Color which has
been replaced with the text label's Highlighted Text Color.

00:08:44.100 --> 00:08:47.070
So these are the four styles.

00:08:47.070 --> 00:08:50.730
Let's talk about how you get access
to the various pieces inside there.

00:08:50.730 --> 00:08:52.600
First is the Image View.

00:08:52.600 --> 00:08:58.450
The Image View obviously gives you access to Image View
that's used to display the image along the left hand side

00:08:58.450 --> 00:09:04.750
of the cell, both the Default and Subtitle styles
support an image view if you ask for the Image View.

00:09:04.750 --> 00:09:10.070
For the Value1 and Value2 Styles, you'll get
back nil because those styles don't support that.

00:09:10.070 --> 00:09:16.250
If you ask for the text label, you get the Primary Text
Label, that's the obviously, only one in the default case,

00:09:16.250 --> 00:09:21.019
the top title and subtitle in the
left label in both the value cases.

00:09:21.019 --> 00:09:26.220
And we've added a new property called
"detailTextLabel" that's used by the new styles,

00:09:26.220 --> 00:09:30.730
to support either the subtitle or the
values on the right of the value styles.

00:09:30.730 --> 00:09:36.200
The Default style doesn't support detail
as well, if you ask for the detailTextLabel

00:09:36.200 --> 00:09:40.080
for a Default style cell you'll also get nil back.

00:09:41.309 --> 00:09:50.009
Prior to 3.0, we had a property called
"hidesAccessoryWhenEditing" if you wanted the accessory

00:09:50.009 --> 00:09:54.080
to only appear when you're not in
editing and move out of the way.

00:09:54.080 --> 00:09:56.490
When you went into editing, you could set this property.

00:09:56.490 --> 00:10:00.350
We've deprecated that as well in 3.0
and replaced it with 2 new properties;

00:10:00.350 --> 00:10:04.450
the editingAccessoryType and the editingAccessoryView.

00:10:04.450 --> 00:10:07.890
So now, if you want to have the exact
same accessory type when you're in editing

00:10:07.889 --> 00:10:10.259
and not in editing, you can just set them to the same type.

00:10:10.259 --> 00:10:12.669
If you want them to be different,
you can set them to different types

00:10:12.669 --> 00:10:15.899
and we'll automatically animate and crossfade between them.

00:10:15.899 --> 00:10:20.679
>> Or if you want it to appear in only one case and not
in the other, you can set the case you want it to appear

00:10:20.679 --> 00:10:25.539
to the AccessoryType you want and the other one to
None and we'll animate it in and out as appropriate.

00:10:25.539 --> 00:10:33.879
Prior to 3.0, we had a Selected property on the cell.

00:10:33.879 --> 00:10:35.960
To this, we've added the Highlighted property.

00:10:35.960 --> 00:10:40.670
And let's look at what happens when
we have a cell and selection happens.

00:10:40.669 --> 00:10:51.339
So the cell is the Multi-select Cell in Mail and
normally, when the cell exists and it hasn't been touched,

00:10:51.340 --> 00:10:53.730
drawn in white and it's neither Highlighted nor Selected.

00:10:53.730 --> 00:10:58.810
When the user's finger comes down on the cell, we mark
the cell as Highlighted and the cell gets a chance

00:10:58.809 --> 00:11:02.869
to redisplay itself, but it's not yet Selected.

00:11:02.870 --> 00:11:07.259
When the user then lifts their finger, we
will send a delegate method to select the row,

00:11:07.259 --> 00:11:13.259
and then the cell will move to the Selected state but
it's no longer Highlighted because the finger isn't on it.

00:11:13.259 --> 00:11:18.189
The user then puts their finger back down on the cell, we'll
go back to the Highlighted state but notice we're still

00:11:18.190 --> 00:11:22.740
in the Selected state, and then once
they lift, will go back to the top state.

00:11:22.740 --> 00:11:26.629
Notice the cell can choose to draw itself slightly
differently when it's Highlighted or Selected.

00:11:26.629 --> 00:11:37.169
In 3.0, we've finally fixed Background Color for
Grouped Style Table View Cells [applause] [laughs].

00:11:40.320 --> 00:11:44.840
While technically correct before it was
not what people sort of expected to happen,

00:11:44.840 --> 00:11:47.899
the cell is actually the area outside
that rounded rectangle.

00:11:47.899 --> 00:11:54.569
And that rounded rectangle is drawn by the background view,
but this is not what most people expected to have happen.

00:11:54.570 --> 00:11:59.650
And so, we've changed the sort of default
behavior to now color the area inside that.

00:11:59.649 --> 00:12:04.299
Alright, so that's Table View Cell.

00:12:04.299 --> 00:12:05.759
Let's move on to Table View Controller.

00:12:05.759 --> 00:12:16.409
In 3.0, when the Table View Controller gets
a notification that the keyboard will appear,

00:12:16.409 --> 00:12:21.689
if the first responder is inside one of the cells, so if
you have a text that's editing in the text field inside one

00:12:21.690 --> 00:12:25.620
of the cells, we'll automatically
scroll that cell to be visible.

00:12:25.620 --> 00:12:29.440
So if that text [applause]-- excellent [laughs].

00:12:29.440 --> 00:12:31.220
So there, you had to manage before.

00:12:31.220 --> 00:12:35.810
So if that text field was in the region of the
screen where the keyboard was going to appear,

00:12:35.809 --> 00:12:38.529
you had to sort of recognize that and move things around.

00:12:38.529 --> 00:12:46.179
There's a new Subclass of UITableViewController called
"NSFetchedResultsController," and this is designed to work

00:12:46.179 --> 00:12:50.679
with Core Data to automatically get content
from your Core Data database into a Table View.

00:12:50.679 --> 00:12:55.750
And there'll be a session I believe, this
afternoon at 5 o'clock discussing this.

00:12:55.750 --> 00:13:00.759
There's also the Core Data Programming Guide as well as
the Core Data Book Sample that you can take a look at.

00:13:00.759 --> 00:13:03.009
We're not going to have really time to cover that today.

00:13:03.009 --> 00:13:07.750
[ Pause ]

00:13:07.750 --> 00:13:10.360
>> So let's jump into Cell Structure.

00:13:10.360 --> 00:13:18.240
What we're going to show here is some sort of exploded
diagrams of the various pieces in a cell, sort of--

00:13:18.240 --> 00:13:19.919
as if they're sort of spread out in a Z order.

00:13:19.919 --> 00:13:24.579
We're not looking at the subview relationship
as much as sort of the visual stacking

00:13:24.580 --> 00:13:27.320
of the various pieces and what sort of covers what.

00:13:27.320 --> 00:13:33.600
So at the back of all this is the cell itself,
that's the thing that's added to the Table View.

00:13:33.600 --> 00:13:39.029
And in front of that, if it exists, is the Background View.

00:13:39.029 --> 00:13:42.429
So if you want to have a custom background on any
of your cells, you can just set a Background View

00:13:42.429 --> 00:13:48.939
and it'll be placed there in size to the size of your cells.

00:13:48.940 --> 00:13:51.580
In front of that is the Content View.

00:13:51.580 --> 00:13:54.800
This is the place that you add all of your own Custom Views.

00:13:54.799 --> 00:13:56.889
I've drawn it here, sort of with a dotted line to indicate

00:13:56.889 --> 00:14:00.939
that it really doesn't contribute anything
visually to the display of the cell.

00:14:00.940 --> 00:14:03.600
It's simply sort of a container for your own views.

00:14:03.600 --> 00:14:07.000
And then inside that are the various
views that make up your cell.

00:14:07.000 --> 00:14:08.799
This is just a Default style cell.

00:14:08.799 --> 00:14:10.909
So we have just an image view and a label.

00:14:10.909 --> 00:14:17.589
And when you go into Editing Mode, you can get optional
editing controls on the left and reorder controls

00:14:17.590 --> 00:14:21.759
over on the right and we have accessories
and things like that.

00:14:21.759 --> 00:14:23.870
Those also sit in front of the Background View.

00:14:23.870 --> 00:14:26.289
In this case, we have an Edit Control and an Accessory.

00:14:26.289 --> 00:14:33.399
And the content is just inset to take up the remaining
space and then all the controls inside are adjusted to fit

00:14:33.399 --> 00:14:36.259
in what space is left by the Content View.

00:14:36.259 --> 00:14:39.629
So now, what happens when we select the cell?

00:14:39.629 --> 00:14:43.340
Well, everything up to the Background
View is exactly the same,

00:14:43.340 --> 00:14:47.360
but we insert a Selected Background View in front of that.

00:14:47.360 --> 00:14:50.810
That's also a property on the cell, just
like Background View that you can set.

00:14:50.809 --> 00:14:54.989
So if you wanted just to have a custom Selection style,

00:14:54.990 --> 00:15:00.049
you can just create your own custom Selected
Background View and we'll use that instead of our own.

00:15:00.049 --> 00:15:04.589
If you don't specify one, you'll get the default
blue gradient that we see and that's adjusted

00:15:04.590 --> 00:15:06.750
as appropriate for a Grouped or Plain style.

00:15:06.750 --> 00:15:12.360
And then in front of that is all the
same views we saw before whether it's--

00:15:12.360 --> 00:15:17.450
whether you're not in editing mode like here or you go
into editing mode and you have some sort of edit control.

00:15:17.450 --> 00:15:24.990
Now, all of the samples and all of the code that
we've talked about up to this point in prior sessions,

00:15:24.990 --> 00:15:28.360
we talked about how important it is
for all of those views that you put

00:15:28.360 --> 00:15:32.279
in your Table View Cells, to be
opaque for performance reasons.

00:15:32.279 --> 00:15:38.649
This sort of presents a problem here, we've got this nice
blue gradient, but all these opaque views sitting in front.

00:15:38.649 --> 00:15:43.379
Table View Cell actually handles all this
automatically, but you sort of have to understand how

00:15:43.379 --> 00:15:46.610
to write your custom Views so that
they work nicely in this system.

00:15:46.610 --> 00:15:53.269
So let's talk about what happens to these
views in front when selection happens.

00:15:53.269 --> 00:16:04.079
So at the point we're told to select a cell, we're going to
save off three bits of state about every one of those views,

00:16:04.080 --> 00:16:06.690
regardless of how deep that view hierarchy is.

00:16:06.690 --> 00:16:10.260
The first is we're going to try to
save off of that view is Highlighted.

00:16:10.259 --> 00:16:12.639
Now, not all views have a Highlighted property.

00:16:12.639 --> 00:16:17.879
So we're going to check to see if your view implements
both the Set Highlighted method, and Is Highlighted method.

00:16:17.879 --> 00:16:21.970
And if it implements both of those, we
assume it understands how to do highlighting,

00:16:21.970 --> 00:16:26.070
and we will call Is Highlighted and store off that state.

00:16:26.070 --> 00:16:30.970
We'll then get the Opaque Flag, that's a
property on UIView, and the Background Color,

00:16:30.970 --> 00:16:33.410
it's also a property on UIView, and we'll save those off.

00:16:33.409 --> 00:16:38.159
And then we're going to reset each
of these three properties.

00:16:38.159 --> 00:16:43.309
Again, if you implement Set Highlighted, we're
going to call Set Highlighted with a value of YES.

00:16:43.309 --> 00:16:47.059
We're going to set Opaque to NO, and we're
going to set the backgroundColor to clear.

00:16:47.059 --> 00:16:51.149
This allows us to see through to that selected background.

00:16:51.149 --> 00:16:56.370
On deselection, we're first going to start
fading out that selectedBackgroundView.

00:16:56.370 --> 00:17:01.610
We're going to start an animation
and take the alpha from 1 down to 0.

00:17:01.610 --> 00:17:08.019
And at the midway point of that animation, we're
automatically going to crawl back through all

00:17:08.019 --> 00:17:10.980
of those views and reset the Highlighted state.

00:17:10.980 --> 00:17:15.860
So whatever value we saved off
before, we're going to put it back.

00:17:15.859 --> 00:17:19.979
And then at the end of the animation, we're going
to again crawl back through all of those views,

00:17:19.980 --> 00:17:23.539
and we're going to reset the opaque
flag, and the backgroundColor

00:17:23.539 --> 00:17:26.609
to what you had before the selection started.

00:17:26.609 --> 00:17:28.569
So let's visually look at what this looks like.

00:17:28.569 --> 00:17:33.849
This is just a simple cell that has an added
control on the left, an icon text and an accessory.

00:17:33.849 --> 00:17:38.869
And at the point we do the selection, we insert

00:17:38.869 --> 00:17:42.219
that Selected Background View, and
sits behind all those other views.

00:17:42.220 --> 00:17:46.890
But at this point, the views are all still
opaque; still have their same background colors.

00:17:46.890 --> 00:17:51.009
So we're going to go through and remember all that state.

00:17:51.009 --> 00:17:55.129
And then we're going to set the backgroundColors
to clear and set them to not be opaque,

00:17:55.130 --> 00:17:58.910
and then we're going to go back through
and set them all to be highlighted.

00:17:58.910 --> 00:18:03.519
Obviously, you don't see all these intermediate states,
we do this all in a single turn of the run loop.

00:18:03.519 --> 00:18:08.410
So visually, we go from this directly to the selected state.

00:18:09.519 --> 00:18:13.609
Now when the deselection happens, we're going
to start fading out that Background View.

00:18:13.609 --> 00:18:18.659
And here we've gotten to the midpoint, and we're
going to go through and change the Highlighted state

00:18:18.660 --> 00:18:21.850
for all those views, this is how
we toggle right at that midpoint,

00:18:21.849 --> 00:18:24.539
and then we'll continue fading out that Background View.

00:18:24.539 --> 00:18:28.569
So this is a really common area we've seen some mistakes.

00:18:28.569 --> 00:18:33.639
People that-- instead of implementing Set
Highlighted on their Views, look at the cell state.

00:18:33.640 --> 00:18:38.500
Well, the cell's Highlighted and Selected states change
at a slightly different time than the views inside.

00:18:38.500 --> 00:18:40.230
And they won't change in the midpoint of this animation.

00:18:40.230 --> 00:18:46.940
So this is really the right way to get the
same look that we get in all our cells.

00:18:46.940 --> 00:18:50.009
So let's look at a few options for cell design.

00:18:50.009 --> 00:18:55.819
[ Pause ]

00:18:55.819 --> 00:19:02.230
>> Last year, in the Advance Table View Session, we covered
sort of two different approaches when you have a cell.

00:19:02.230 --> 00:19:08.029
You can just create an instance if you like Table View
Cell and just start adding subviews to the Content View,

00:19:08.029 --> 00:19:11.180
or you can subclass your UITableViewCell
and sort of manage things in there.

00:19:11.180 --> 00:19:17.720
Really, in either case, you're adding subviews to the
Content View, but it's really sort of who is responsible.

00:19:17.720 --> 00:19:20.710
This year, we're going to look at
it from sort of a different access.

00:19:20.710 --> 00:19:27.660
We're going to talk about adding Individual Subviews,
things like Buttons and Labels and Image Views

00:19:27.660 --> 00:19:31.830
versus adding a Composite Subview, a view
that draws all the individual pieces.

00:19:31.829 --> 00:19:36.359
Then hopefully, by looking at last year's session and
this year's session, you can see sort of which one

00:19:36.359 --> 00:19:39.740
of these boxes sort of make sense
for you and your application.

00:19:39.740 --> 00:19:42.849
So let's start with Individual Subviews.

00:19:42.849 --> 00:19:47.349
Here, we have the YouTube cell.

00:19:47.349 --> 00:19:49.049
And YouTube cells are fairly complex cell.

00:19:49.049 --> 00:19:53.169
It has a big Image View, several
Labels, a Rating View, and Accessory.

00:19:53.170 --> 00:19:59.039
And if we were to decompose this as Individual
Subviews, we'd have something that looks like this.

00:19:59.039 --> 00:20:02.079
Various, you know, look what, four
different Labels, a Rating View,

00:20:02.079 --> 00:20:05.589
and an Image View, all the subviews of the Content View.

00:20:05.589 --> 00:20:09.970
Now, this is really nice because
it's first of all, easy to develop.

00:20:09.970 --> 00:20:13.549
You can mark this all up in Interface Builder.

00:20:13.549 --> 00:20:17.180
>> And it's easy to change if you decide
you want to adjust your layout a little bit.

00:20:17.180 --> 00:20:20.090
You can go right in Interface Builder
and move the pieces around.

00:20:20.089 --> 00:20:26.069
And it's also nice because as the cell changes size,
for example, if you rotate the device to Landscape,

00:20:26.069 --> 00:20:28.649
you can set up appropriate autoresizing masks for all

00:20:28.650 --> 00:20:33.370
of these pieces they all change size
and position, sort of automatically.

00:20:33.369 --> 00:20:39.109
Of course, the disadvantage is there's a lot of views here
and it's pretty expensive to composite all these views,

00:20:39.109 --> 00:20:42.179
and you really notice this in scrolling performance.

00:20:42.180 --> 00:20:50.810
[Clears throat] Now one of the ways to
address that is to just have a single view.

00:20:50.809 --> 00:20:58.589
Here, if we were to redesign this to just have a single
view that draws all the pieces, might look a little bit

00:20:58.589 --> 00:21:00.500
like this, you'd have the same Content View.

00:21:00.500 --> 00:21:06.779
And then inside that's a single view within its draw
rack, just draws all of the various pieces that you see.

00:21:06.779 --> 00:21:12.379
Now this is a little harder to develop.

00:21:12.380 --> 00:21:17.550
You have to spend a little time fine-tuning
the code to position everything appropriately.

00:21:17.549 --> 00:21:20.099
It's a little harder to maintain because it's all in code.

00:21:20.099 --> 00:21:22.990
You can't just go into Interface Builder and adjust things.

00:21:22.990 --> 00:21:24.289
But it's really fast.

00:21:24.289 --> 00:21:30.889
In fact, almost regardless of the complexity of the
cell, this is about constant speed scrolling because most

00:21:30.890 --> 00:21:34.800
of the cost of scrolling is recompositing
as things move up the screen,

00:21:34.799 --> 00:21:42.859
not the cost of doing the first
draw as the cell enters the screen.

00:21:42.859 --> 00:21:48.789
But this is, you know, very complex to handle
things like cell size changes when you rotate,

00:21:48.789 --> 00:21:52.869
you have to redraw to handle that new width.

00:21:52.869 --> 00:21:58.939
And having everything move in a nice animated
fashion is really not easy to achieve.

00:21:58.940 --> 00:22:02.220
So they're sort of a hybrid approach.

00:22:02.220 --> 00:22:07.420
This works sometimes when you only have one or two pieces
that need to move differently from the rest of the content.

00:22:07.420 --> 00:22:15.710
Again, if we look back to the Mail Cell in 3.0, we look
at the animation that happens as we go into editing mode,

00:22:15.710 --> 00:22:20.299
pay attention to the main three Labels that
are on the left versus the date on the right.

00:22:20.299 --> 00:22:24.629
You notice they move at slightly different rates.

00:22:24.630 --> 00:22:28.870
If we look at this again, sort of in slow motion,
you can see that the main three Labels have

00:22:28.869 --> 00:22:31.559
to move quite a bit more than the date does.

00:22:31.559 --> 00:22:35.829
So this is sort of a good candidate for drawing
those three Labels on the left in a separate view,

00:22:35.829 --> 00:22:41.019
but then using a UILabel for that other piece
that has to move a little bit differently.

00:22:41.019 --> 00:22:45.859
So we're going to jump into a demo now.

00:22:45.859 --> 00:22:50.069
And we're going to look at 3 different
ways to render the same content.

00:22:50.069 --> 00:22:54.629
Now, this is a content that's supposed
to look just like the application store.

00:22:54.630 --> 00:22:59.170
We have alternating row colors
with-- if you can see it there,

00:22:59.170 --> 00:23:07.220
little grooves between the cells,
some nice images with shadows I think.

00:23:07.220 --> 00:23:09.240
Labels, Rating View, things like that.

00:23:09.240 --> 00:23:14.769
And we obviously want the price that's, you know,

00:23:14.769 --> 00:23:19.279
over on the right to stay right aligned
as we go in and out of Landscape.

00:23:19.279 --> 00:23:23.299
Let's take a quick look at this project.

00:23:23.299 --> 00:23:28.909
We have a Root View Controller and this thing
is going to manage the Table View that we see.

00:23:28.910 --> 00:23:33.009
And we have three-- well, first of
all we have an Application Cell.

00:23:33.009 --> 00:23:37.440
This Application Cell is just an abstract
superclass for the three subclasses

00:23:37.440 --> 00:23:41.750
that are going to use the different styles to display.

00:23:41.750 --> 00:23:47.630
This has a Boolean as whether this particular row
should have a dark background or a light background.

00:23:47.630 --> 00:23:53.450
And then, properties for the various
- Icon, Publisher things like that.

00:23:53.450 --> 00:23:55.720
I'm sorry.

00:23:55.720 --> 00:24:01.009
- I thought that was already set.

00:24:01.009 --> 00:24:19.680
[ Pause ]

00:24:19.680 --> 00:24:21.450
>> How's that?

00:24:21.450 --> 00:24:28.660
Good? [Applause] Alright, sorry about that.

00:24:28.660 --> 00:24:34.720
OK, and then like I said, we have
three different subclasses.

00:24:34.720 --> 00:24:42.100
We have an individual Subview Based Application Cell and
this uses a nib to have-- to display all the various pieces,

00:24:42.099 --> 00:24:47.279
and you see we've got IB Outlets for all the various
views we're going to use to display the components.

00:24:47.279 --> 00:24:54.720
We have a composite Subview Based which has a
single Content View, we use to display everything,

00:24:54.720 --> 00:25:01.190
and then we have the Hybrid Subview Case which
breaks out that Price Label as a separate view.

00:25:01.190 --> 00:25:05.009
So let's start filling out the View Controller.

00:25:05.009 --> 00:25:11.960
So we're going to start by setting the Background Color of
the Table View to this dark background that we've defined.

00:25:11.960 --> 00:25:13.670
This is the area that's outside any cells.

00:25:13.670 --> 00:25:18.490
So if you pull the cells down, the area you see above
that, or if you pull the cells up, the area below that,

00:25:18.490 --> 00:25:21.910
then we're going to set the separator style to none.

00:25:21.910 --> 00:25:25.900
We're actually going to draw that groove
using the Background Views of the cell.

00:25:25.900 --> 00:25:29.630
And then finally, we're going to load the data.

00:25:29.630 --> 00:25:33.930
In this case, I'm just pulling the data from a plist
that specifies all the various components for each row.

00:25:33.930 --> 00:25:42.660
And now we need to implement the methods
to get the data into the Table View.

00:25:42.660 --> 00:25:45.340
So the first is the number of sections in Table View.

00:25:45.339 --> 00:25:48.079
In this case, we just have one.

00:25:48.079 --> 00:25:53.409
The number of rows in this section will be the number
of objects in the data that we loaded from the plist.

00:25:53.410 --> 00:25:58.890
And then the real meat of it is in
tableView:cellForRowAtIndexPath.

00:25:58.890 --> 00:26:02.640
Well, like good citizens, we're going to use cell reuse.

00:26:02.640 --> 00:26:04.770
So we'll create a Cell Identifier.

00:26:04.769 --> 00:26:10.639
We're going to attempt to dequeue one of those cells and
if we don't get one, then we're going to load our nib.

00:26:10.640 --> 00:26:17.070
Now, we're going to be the owner of this nib and we have an
instance variable called _cell that will point to the cell

00:26:17.069 --> 00:26:20.179
that gets loaded as a result of loading this nib.

00:26:20.180 --> 00:26:27.640
We'll assign that to the Local Cell variable and then just
nil out our instance variable so we don't hang on to it.

00:26:27.640 --> 00:26:30.090
Now, we need to set up the various attributes of this cell.

00:26:30.089 --> 00:26:33.139
The first is whether or not the
cell needs to use a dark background.

00:26:33.140 --> 00:26:36.330
We'll just obviously, alternate this here.

00:26:36.329 --> 00:26:40.399
And then we'll get the appropriate data
item from that data that we loaded.

00:26:40.400 --> 00:26:44.360
And we're going to set all of the various
properties, Icon, Publisher Name, et cetera,

00:26:44.359 --> 00:26:48.009
just pulling those out of that dictionary.

00:26:48.009 --> 00:26:53.230
[ Pause ]

00:26:53.230 --> 00:26:56.120
>> We're also going to set the Accessory
Type to the Disclosure Indicator,

00:26:56.119 --> 00:27:01.709
and then we'll go ahead and return the cell.

00:27:01.710 --> 00:27:05.029
There are a few more things we're going to do.

00:27:05.029 --> 00:27:09.990
In the willDisplayCell, we're going to set the
cells' background color to either the dark background

00:27:09.990 --> 00:27:14.549
or light background depending on whether the
cells use dark background property with set.

00:27:14.549 --> 00:27:18.419
It's another area of confusion that
we've seen some people encounter.

00:27:18.420 --> 00:27:22.330
They try to set the cells' background
color when they create the cell.

00:27:22.329 --> 00:27:29.949
And unfortunately, that doesn't work because after that cell
is returned to us, we need to set some additional parameters

00:27:29.950 --> 00:27:33.970
on the cell to make it fit nicely into the
Table View, things like background color.

00:27:33.970 --> 00:27:36.809
So if you want to override some
of these additional properties,

00:27:36.809 --> 00:27:40.839
you need to do it in the willDisplayCell:forRowAtIndexPath
method.

00:27:40.839 --> 00:27:45.579
This is called just before we put the cell on the screen
and Table View will not touch the cell after this.

00:27:45.579 --> 00:27:53.759
So any changes you'd like to make will
persist all the way to the screen.

00:27:53.759 --> 00:27:57.089
We'll implement the Did Select Row
forRowAtIndexPath and simply deselect in this case.

00:27:57.089 --> 00:28:00.379
Normally, you would perform some
action but we won't really care here.

00:28:00.380 --> 00:28:07.000
And finally, we're going to implement the Should Autorotate
to Interface Orientation View Controller Delegate method

00:28:07.000 --> 00:28:12.069
and indicate that we support portrait
in both of the landscape orientations.

00:28:13.259 --> 00:28:21.009
Let me quickly jump over and show you this nib.

00:28:21.009 --> 00:28:27.170
[ Pause ]

00:28:27.170 --> 00:28:33.230
>> Again, the file's owner is our View Controller
and we have a cell property that points to this cell.

00:28:33.230 --> 00:28:37.940
And as you can see, it has all the various
components that you would expect to see there,

00:28:37.940 --> 00:28:41.920
and appropriate autoresizing masks so
that things move around as appropriate.

00:28:41.920 --> 00:28:47.150
So now, let's go ahead and define this
individual Subview Base Application Cell.

00:28:47.150 --> 00:28:56.670
We need to overwrite Set Background Color because
we want all of these views inside to look seamless

00:28:56.670 --> 00:29:00.150
and transparent against the background that's there.

00:29:00.150 --> 00:29:05.440
And we're going to set the Background Color in the
willDisplayCell to either the dark or light color.

00:29:05.440 --> 00:29:10.090
And so we need to sort of forward that
on to all the views inside the cell.

00:29:10.089 --> 00:29:19.720
We next need to override each of the setters the
Application Cell defines for things like Icon, Publisher,

00:29:19.720 --> 00:29:28.360
et cetera to forward those on to the views
that we're using to display that content.

00:29:31.809 --> 00:29:38.559
And then, let me show one last thing, which is
how we're doing the actual background itself.

00:29:39.869 --> 00:29:46.769
On application cell itself, when you call Set
Use Dark Background, we're going to go through

00:29:46.769 --> 00:29:53.430
and create a UIImageView to display an image
that's either that dark or light background

00:29:53.430 --> 00:29:56.310
with the little grooves at the top and bottom.

00:29:56.309 --> 00:30:02.039
And we're going to that by loading an image, and
then we're going to create a stretchable image,

00:30:02.039 --> 00:30:07.149
and I'll show you the image in just a second here, and then
we're going to put that image in an Image View and specify

00:30:07.150 --> 00:30:13.670
that that has flexible width and height,
and then set that as the Background View.

00:30:13.670 --> 00:30:18.009
>> So let me show you the light and dark background.

00:30:18.009 --> 00:30:22.720
[ Pause ]

00:30:22.720 --> 00:30:24.089
>> So this is the dark background.

00:30:24.089 --> 00:30:26.559
Let me zoom way in so you can see this here.

00:30:26.559 --> 00:30:29.700
It's actually only a 3 pixel tall image.

00:30:29.700 --> 00:30:38.490
We use the stretchable image property of UIImage to
create an image that causes the entire width of this image

00:30:38.490 --> 00:30:46.930
to stretch across the cell, but just the middle pixel
to stretch vertically to fill any area that it needs to.

00:30:46.930 --> 00:30:51.100
And we have a similar light background
with some lighter colors.

00:30:51.099 --> 00:31:03.109
So with just these changes, let
me wash this with instruments.

00:31:03.109 --> 00:31:07.349
So we can take a look at the frame
rate we get while scrolling this.

00:31:07.349 --> 00:31:15.909
Alright, before I jump over and actually show you visually
how it feels, I'm just going to play around with this here

00:31:15.910 --> 00:31:17.840
and just take a look at the frame rate we get.

00:31:17.839 --> 00:31:21.000
Not a real great frame rate.

00:31:21.000 --> 00:31:23.420
Not horrible, but not great.

00:31:25.069 --> 00:31:31.009
Visually, if we look at it, it's not
too bad, but it's a little jumpy.

00:31:31.009 --> 00:31:36.539
[ Pause ]

00:31:36.539 --> 00:31:40.089
>> Just let me show one other thing here.

00:31:40.089 --> 00:31:44.879
All of these views, because we're using stock
Views like Labels and Image Views and things

00:31:44.880 --> 00:31:47.300
like that, already implement Set Highlighted.

00:31:47.299 --> 00:31:51.940
So when I select one of these, let me
do it over here so you can see this,

00:31:51.940 --> 00:31:56.600
you see that all of the labels automatically switch
to white, the Accessory View switches to white.

00:31:56.599 --> 00:32:00.279
And then as it fades out, they all
toggle back at the intermediate point.

00:32:00.279 --> 00:32:04.980
So just because those views already implement
Set Highlighted, we move to some of the more--

00:32:04.980 --> 00:32:08.009
the views that we do ourselves will
show how we can get that same effect.

00:32:08.009 --> 00:32:13.670
[ Pause ]

00:32:13.670 --> 00:32:18.009
>> So let's next look at the Composites Subview case.

00:32:18.009 --> 00:32:22.829
[ Pause ]

00:32:22.829 --> 00:32:29.259
>> So we'll override the designated
initializer here, call super on that.

00:32:29.259 --> 00:32:31.450
And we'll create our own content view.

00:32:31.450 --> 00:32:33.930
This is going to be a Custom Subclass of UIView.

00:32:33.930 --> 00:32:37.740
We'll set a couple of properties
on that, an autoresizing mask

00:32:37.740 --> 00:32:40.839
so that it fills whatever area in the content view it can.

00:32:40.839 --> 00:32:47.099
And we'll set the Content Mode to redraw, so that if it
does change size, we're asked to redraw at that new size.

00:32:47.099 --> 00:32:53.419
And then we'll add that in to the
content view and return the cell.

00:32:53.420 --> 00:32:58.470
Just like in the individual Subview Based Application
Cell, we need to override Set Background Color to forward

00:32:58.470 --> 00:33:01.490
that background color on to our Custom View.

00:33:01.490 --> 00:33:06.099
And then let's go on and define that Custom View now.

00:33:06.099 --> 00:33:16.459
So we'll subclass UIView, create our very long named
custom subclass and we'll have a back pointer to the cell

00:33:16.460 --> 00:33:21.340
so that we can get those attributes
out, Icon Name, things like that.

00:33:21.339 --> 00:33:27.480
And we'll also have that highlighted property since we
want to participate in highlighting the way other views do.

00:33:27.480 --> 00:33:31.589
We'll define our designated initializer
and then move on to the implementation.

00:33:31.589 --> 00:33:36.689
In this initializer, we'll obviously call
super, and we'll hang on to that cell.

00:33:36.690 --> 00:33:40.110
We'll mark ourselves as opaque and
set our background color to the same

00:33:40.109 --> 00:33:45.469
as the cell's background color, and then return our view.

00:33:45.470 --> 00:33:52.100
We need to implement Set Highlighted and Is Highlighted
to participate in this highlighting mechanism,

00:33:52.099 --> 00:33:54.639
and we'll store that in our own Local Instance variable.

00:33:54.640 --> 00:34:00.090
And notice under Set Highlighted, we'll mark ourselves as
needing display because this view is drawn with a draw rack

00:34:00.089 --> 00:34:03.449
and when this state changes, we need to redisplay ourselves.

00:34:03.450 --> 00:34:08.329
And finally, we'll actually implement the draw rack.

00:34:08.329 --> 00:34:12.719
And this just contains a series of
lines that draw the appropriate pieces.

00:34:12.719 --> 00:34:16.619
Here, we're drawing the icon at some particular point.

00:34:16.619 --> 00:34:21.670
Depending on the state of our own highlighted
property, we're going to set either the white color

00:34:21.670 --> 00:34:25.000
or black color and draw, in this case, the cell's name.

00:34:25.000 --> 00:34:34.099
And similarly, either set the white or a grayish color
to draw the remaining publisher and number of ratings.

00:34:34.099 --> 00:34:41.389
We want the price to stay right aligned, so we need
to actually figure out how wide that is and then back

00:34:41.389 --> 00:34:45.000
up an appropriate amount from the right edge of this view.

00:34:45.000 --> 00:34:49.110
So I'll use the Size with Font Method
to figure out how wide the price is,

00:34:49.110 --> 00:34:51.990
and then back up an appropriate
amount and draw that string there.

00:34:51.989 --> 00:34:55.759
And then the last little bit, we're
not going to jump into too much detail.

00:34:55.760 --> 00:35:01.170
But basically, this draws the stars'
background, those white stars that appear,

00:35:01.170 --> 00:35:04.320
and then some portion of the foreground of those stars.

00:35:04.320 --> 00:35:09.100
The sample will be made available later and
you can look at exactly how we're doing this.

00:35:09.099 --> 00:35:16.949
So now, let's go over and tell our Root View Controller
that we need to use this new subclass of cell,

00:35:16.949 --> 00:35:20.009
so let's comment out this old code -- oops.

00:35:20.010 --> 00:35:28.770
[ Pause ]

00:35:28.769 --> 00:35:31.009
>> Let's again - oops, I'm sorry.

00:35:31.010 --> 00:35:37.770
[ Pause ]

00:35:37.769 --> 00:35:42.420
>> Let's again launch with Core Animation so
we can see what the frame rate of this is.

00:35:45.210 --> 00:35:53.090
OK. So I'll leave it here for just a second and sort of play
with this and you can see what sort of frame rates we get.

00:35:53.090 --> 00:35:54.160
Much better.

00:35:54.159 --> 00:36:02.449
In fact, it's capped at 60 and we're very
much approaching 65, going a little bit over.

00:36:02.449 --> 00:36:05.109
And while we're here, let's go
ahead and look at the selection.

00:36:05.110 --> 00:36:08.610
If I select this, notice that the
exact same-- I moved, sorry.

00:36:08.610 --> 00:36:10.660
Notice the exact same visual appearance.

00:36:10.659 --> 00:36:11.859
[ Inaudible Remark ]

00:36:11.860 --> 00:36:12.570
>> I'm sorry.

00:36:12.570 --> 00:36:12.630
[ Inaudible Remark ]

00:36:12.630 --> 00:36:14.760
>> Yes, there you go.

00:36:14.760 --> 00:36:18.680
Notice the exact same visual appearance.

00:36:18.679 --> 00:36:24.500
Everything highlights, notice that it
toggles at the midpoint appropriately.

00:36:24.500 --> 00:36:27.000
And notice that when I play with this, it's very fluid.

00:36:27.000 --> 00:36:32.530
[ Pause ]

00:36:32.530 --> 00:36:34.230
>> So there's one other thing that I'll show.

00:36:34.230 --> 00:36:36.150
And I'm actually-- I'm just going
to move over to the simulator

00:36:36.150 --> 00:36:41.460
to show this 'cause we really want to slow this down.

00:36:41.460 --> 00:36:44.429
'Cause we have a problem here,
we're just drawing everything.

00:36:44.429 --> 00:36:46.969
What happens when we rotate the device?

00:36:46.969 --> 00:36:52.799
This content can't smoothly adapt
to the new width of the cell.

00:36:52.800 --> 00:36:58.840
So let's-- I'm sorry, let's switch
this over to the simulator.

00:36:58.840 --> 00:37:11.000
We'll build, and then actually let's-- we
don't need to run it in instruments here.

00:37:11.000 --> 00:37:29.550
[ Pause ]

00:37:29.550 --> 00:37:34.730
>> OK. Let me slow this down and watch what
happens now when we rotate this content.

00:37:34.730 --> 00:37:38.510
Notice the content is all squished and then
sort of stretches out to the right size.

00:37:38.510 --> 00:37:39.590
We go back the other way.

00:37:39.590 --> 00:37:43.690
It starts all stretched out, ends up at the right size.

00:37:43.690 --> 00:37:45.280
What's going on here?

00:37:45.280 --> 00:37:51.690
Well, by default, there's a content stretch property that
defines sort of what region of a cell can be stretched

00:37:51.690 --> 00:37:58.530
if you try to display the cell in a different
size than the actual underlying backing store.

00:37:58.530 --> 00:38:03.880
So in this case, when we go to rotate, the
cells are all asked to redraw at their new size,

00:38:03.880 --> 00:38:08.480
but then the frame animates from
the old size to the new size.

00:38:08.480 --> 00:38:14.360
So the content that's now drawn at that new smaller
size, gets stretched out to fill the old size,

00:38:14.360 --> 00:38:16.660
and then gets animated back into position.

00:38:16.659 --> 00:38:18.869
So what can we do about this?

00:38:18.869 --> 00:38:21.909
Well, that content stretch property
is something you can set yourself.

00:38:21.909 --> 00:38:26.029
You can define what region of a view is allowed to stretch.

00:38:26.030 --> 00:38:32.810
We'll notice that we have this area here
between the ratings and the price that's empty.

00:38:32.809 --> 00:38:35.909
We can stretch that region in and
out and we're just fine with that.

00:38:35.909 --> 00:38:39.000
So let's see how we'd do that.

00:38:39.000 --> 00:38:44.530
[ Pause ]

00:38:44.530 --> 00:38:48.530
>> So let's come down here and we're going to override
Set Frame, because whenever the frame changes,

00:38:48.530 --> 00:38:51.910
we need to redefine what region of that is stretchable.

00:38:51.909 --> 00:38:53.289
We'll call super.

00:38:53.289 --> 00:38:58.989
And then an important bit here is we're going
to set the content stretch to some rectangle,

00:38:58.989 --> 00:39:03.129
ignore the math for a little bit about how we
define what part of that is but that's the area

00:39:03.130 --> 00:39:06.809
over there where we're not drawing any content.

00:39:06.809 --> 00:39:14.179
Notice we've wrapped this in calls to set animation
Enabled because Content Stretch is also animatable.

00:39:14.179 --> 00:39:19.859
And so if you-- the Content Stretch starts out as
sort of a full thing where as it's changing size,

00:39:19.860 --> 00:39:22.620
you're defining this region that's stretchable.

00:39:22.619 --> 00:39:27.009
We'll try to animate the stretchable region
and you'll get sort of ugly parts animated.

00:39:27.010 --> 00:39:29.450
If you really want it to be fixed, turn off animation

00:39:29.449 --> 00:39:33.500
so Content Stretch will snap to the
new position that you care about.

00:39:33.500 --> 00:39:42.769
So we'll build this [inaudible], oops,
I put this in Root View Controller,

00:39:42.769 --> 00:39:47.949
I meant to put this over in the
Composite Subview Based Application Cell.

00:39:47.949 --> 00:39:50.049
There we go.

00:39:51.400 --> 00:39:54.730
So let's now take a look at this.

00:39:54.730 --> 00:39:58.690
Let me slow this down again.

00:39:58.690 --> 00:40:02.559
And notice now, we get nice stretching,
the way we really wanted to see it.

00:40:02.559 --> 00:40:05.059
We'll go back again to Portrait.

00:40:05.059 --> 00:40:11.059
OK, so that's with the composite
Subview Based Application Cell.

00:40:12.659 --> 00:40:14.639
>> Let's now look under the Hybrid case.

00:40:14.639 --> 00:40:19.549
If for some reason that you didn't-- some reason you
didn't have some region like that that's stretchable.

00:40:19.550 --> 00:40:24.850
I mean, we got lucky sort of in this case because
we have this area here between the Ratings

00:40:24.849 --> 00:40:27.589
and the Price that we don't care if it is stretched.

00:40:27.590 --> 00:40:33.490
But suppose you didn't have this, more like in the
Mail case where that date overlaps some of the content.

00:40:33.489 --> 00:40:38.000
Well, in that case, the Hybrid
approach is a great way to go here.

00:40:38.000 --> 00:40:44.099
[ Pause ]

00:40:44.099 --> 00:40:49.779
>> So we'll start just like we did in the Composite
Case by overwriting the Designated Initializer.

00:40:49.780 --> 00:40:54.120
And we'll create a content view that in
this case, draws everything but the price.

00:40:54.119 --> 00:40:57.279
This is basically exactly the same code we saw before.

00:40:57.280 --> 00:41:02.550
And now, we'll create a Price Label
as a separate view in our cell.

00:41:02.550 --> 00:41:07.360
We'll set this to be Right Aligned, set the
Font, Text Color, and Highlighted Text Color

00:41:07.360 --> 00:41:09.990
so that we participate in this highlighting nicely.

00:41:09.989 --> 00:41:16.419
And Autoresizing Masks so that it
stays pinned to the right side.

00:41:16.420 --> 00:41:21.990
And we'll add that to our content
view as well, and return the cell.

00:41:21.989 --> 00:41:25.729
We also need to override Set Background Color
just we like we did in the other cases to forward

00:41:25.730 --> 00:41:28.079
that Background Color on to the Subviews.

00:41:28.079 --> 00:41:34.509
And just like in the Individual Subview Based case, now when
we receive the Set Price, that's stored in a separate view.

00:41:34.510 --> 00:41:40.850
So we need to override Set Price and call on to
the Price Label to set that so that it appears.

00:41:40.849 --> 00:41:47.779
Just like in the Composite Subview Based Application
Cell, we also need to define that Custom View we're using

00:41:47.780 --> 00:41:53.950
and this is really almost exactly like the
other one with the exception of the draw rack

00:41:53.949 --> 00:41:57.929
which doesn't draw-- which does not draw the price.

00:41:57.929 --> 00:42:07.000
Now let's go tell our Root View
Controller to use this Custom Cell.

00:42:07.000 --> 00:42:15.530
[ Pause ]

00:42:15.530 --> 00:42:21.760
>> And let's go back over to the device
and run this again in instruments

00:42:21.760 --> 00:42:26.000
so that we can see what the performance impact of that was.

00:42:26.000 --> 00:42:35.889
[ Pause ]

00:42:35.889 --> 00:42:37.000
>> Lovely.

00:42:37.000 --> 00:42:43.900
[ Pause ]

00:42:43.900 --> 00:42:53.220
>> OK. And notice if I play with this here, reading pretty
good scrolling performance, definitely not quite as high

00:42:53.219 --> 00:42:57.419
as just drawing everything directly, but we
have an extra view we're compositing each time.

00:42:57.420 --> 00:43:02.889
So it's definitely not bad scrolling performance, and
this might be acceptable for the case that you have.

00:43:04.889 --> 00:43:06.909
Let's look at it over here.

00:43:06.909 --> 00:43:10.690
And I don't know if you're going to
be able to see this here if I rotate.

00:43:10.690 --> 00:43:15.000
No, we'll have to go to the simulator.

00:43:15.000 --> 00:43:32.829
[ Pause ]

00:43:32.829 --> 00:43:34.869
>> Notice the price still stays
right aligned just like it did

00:43:34.869 --> 00:43:37.730
in the Composite Case after we adjusted the Content Stretch.

00:43:37.730 --> 00:43:44.280
A little easier to do this and again, it would work
automatically even if the contents were overlapped.

00:43:44.280 --> 00:43:46.400
And that's it for the demo.

00:43:46.400 --> 00:43:49.000
So let's conclude with some Gotchas.

00:43:49.000 --> 00:43:56.570
[ Pause ]

00:43:56.570 --> 00:43:59.340
>> There's a thing we've seen a few times.

00:43:59.340 --> 00:44:06.760
Begin and End Updates are methods that Table View implements
that allow you to animate multiple things simultaneously.

00:44:06.760 --> 00:44:13.340
So for example, if you're inserting a cell and deleting
a cell at the same time, or you want to both insert

00:44:13.340 --> 00:44:18.350
and delete some cells while you're
transitioning into or out of editing mode.

00:44:18.349 --> 00:44:23.199
You would wrap all of those calls in a Begin
and End Updates call and that causes us all to--

00:44:23.199 --> 00:44:26.089
because this causes the Table View
to animate all of those together.

00:44:26.090 --> 00:44:31.250
We've seen a few cases were these
were separated wildly in the code

00:44:31.250 --> 00:44:36.480
and were not called almost immediately
back to back which is their intended use.

00:44:36.480 --> 00:44:41.230
If you called Begin Updates and don't call End Updates,
the Table View is just going to sit there sort of waiting

00:44:41.230 --> 00:44:43.579
for you to tell us that you're done updating the Table View.

00:44:43.579 --> 00:44:48.980
So if the user tries to scroll or you try to reload the
Table View during that time, nothing is going to happen.

00:44:48.980 --> 00:44:54.929
So these need to be matched and typically are
called around a fairly small block of code.

00:44:56.019 --> 00:45:02.340
This is another one I've-- that I see pretty
commonly when I look at apps in the apps store.

00:45:02.340 --> 00:45:06.850
When you-- if you ever select a cell, the set-

00:45:06.849 --> 00:45:12.319
the text all goes nicely white but the moment
you lift, it all goes back to black instantly.

00:45:12.320 --> 00:45:17.370
It's usually because somebody's made this mistake and
they're using the cell's Highlighted or Selected state

00:45:17.369 --> 00:45:22.039
to trigger whether to draw a black or
white text, and not the view itself.

00:45:22.039 --> 00:45:27.590
Because remember, we toggled that at the halfway point
of the animation, while the cell itself goes back

00:45:27.590 --> 00:45:33.559
to non-Selected immediately after we deselect the cell.

00:45:33.559 --> 00:45:43.179
This is another one that hurt a number
of applications in the move to 3.0.

00:45:43.179 --> 00:45:50.339
While in general, UIKit does support putting views
outside your super views bounds, within Table View,

00:45:50.340 --> 00:45:57.019
things like cells and Header Views and things like
that are all sort of butted up adjacent to each other.

00:45:57.019 --> 00:46:02.639
And if you draw outside any of those components,
you're going to overhang some adjacent component.

00:46:02.639 --> 00:46:07.719
And we don't make any guarantees of
the Z-ordering of any of these things.

00:46:07.719 --> 00:46:12.429
And so, there are cases where we found where people
were drawing outside their Header View, for example.

00:46:12.429 --> 00:46:17.769
And that was obscuring a row, and now we
change the order and it doesn't anymore.

00:46:17.769 --> 00:46:21.800
In that case, the right answer would have
just been to make Header View taller.

00:46:21.800 --> 00:46:25.880
So with inside Table View, keep the
views inside their super views bounds

00:46:25.880 --> 00:46:30.039
and you won't have issues as we change things going forward.

00:46:30.039 --> 00:46:40.250
We go to a great deal of trouble, not only in
Table View, but really all over the iPhone OS,

00:46:40.250 --> 00:46:47.460
to give the appearance of this nice translucent
interface where there are shadows everywhere

00:46:47.460 --> 00:46:50.429
and you can see through the different things.

00:46:50.429 --> 00:46:52.799
And in some sense this is largely an illusion.

00:46:52.800 --> 00:46:58.160
We go to a great deal of trouble to sort
of give the appearance of transparency,

00:46:58.159 --> 00:47:03.190
but transparency is very expensive to composite
and these devices, although they look really fast,

00:47:03.190 --> 00:47:06.349
under the covers, aren't, as you probably know.

00:47:06.349 --> 00:47:09.980
So there are a lot of cases where people look
at how something works and think "oh, well,

00:47:09.980 --> 00:47:12.610
the only way to make this work is
to use some transparency there."

00:47:12.610 --> 00:47:15.150
Selection was an example of this.

00:47:15.150 --> 00:47:20.660
Early on, before we put out some samples that showed the
right way to do this, people saw that nice blue gradient

00:47:20.659 --> 00:47:24.369
and said, if I want that to appear behind my
Labels, I've got to create transparent Labels

00:47:24.369 --> 00:47:29.859
and they would just create transparent
Labels, and scrolling was abysmally slow.

00:47:29.860 --> 00:47:34.890
Hopefully, some of the stuff we covered today that shows
you some of the machinery inside the cell that takes care

00:47:34.889 --> 00:47:41.099
of some of this for you, will make it possible for
you guys to write cells that are very high performance

00:47:41.099 --> 00:47:44.569
but still can participate and look
really nice when you do selection.

00:47:44.570 --> 00:47:52.519
So another one I alluded to earlier, there are certain
cell properties that can't be set when you create the cell

00:47:52.519 --> 00:47:57.840
because after you return your cell
from cellForRowAtIndexPath,

00:47:57.840 --> 00:48:02.280
we're going to set additional properties
on it, things like the background color.

00:48:02.280 --> 00:48:08.130
So if you want to adjust those things, do that in the
willDisplaycell:forRowAtIndexPath, and like I said,

00:48:08.130 --> 00:48:13.430
we won't touch it again before it makes it to the screen.

00:48:13.429 --> 00:48:16.919
Surprisingly, we still see people not reusing cells.

00:48:16.920 --> 00:48:22.150
This is so trivial to do-- you OK?

00:48:22.150 --> 00:48:23.440
[Laughter] Sorry.

00:48:23.440 --> 00:48:28.650
Distracted by somebody falling.

00:48:28.650 --> 00:48:28.710
[ Inaudible Remark ]

00:48:28.710 --> 00:48:33.349
>> Yeah, I am not the person maybe
to help with that, but [laughter].

00:48:33.349 --> 00:48:38.769
You OK, sir?

00:48:43.050 --> 00:48:45.080
Alright. [Laughter] [Applause]
So, as hopefully you've seen here

00:48:45.079 --> 00:48:48.750
and in countless other demos, cell reuse is just trivial.

00:48:48.750 --> 00:48:50.079
Please reuse cells.

00:48:50.079 --> 00:48:54.989
You really can not get good scrolling
performance without doing so.

00:48:54.989 --> 00:48:59.639
[ Pause ]

00:48:59.639 --> 00:49:04.920
>> I think this comes from people who are used to
NSTableView on the desktop where cells are sort

00:49:04.920 --> 00:49:11.360
of these transient things that are only used to
render, but don't really exist after the fact.

00:49:11.360 --> 00:49:15.660
On-- in UIKits, cells are really first class views.

00:49:15.659 --> 00:49:20.460
And so, if you want to change something on the screen,

00:49:20.460 --> 00:49:23.929
on NSTableView on the desktop, you
are required to reload that row.

00:49:23.929 --> 00:49:30.029
And we'll go back and ask your Data Source
for new cells and we'll draw the pieces.

00:49:30.030 --> 00:49:33.900
In UIKit, those cells still exist on the screen.

00:49:33.900 --> 00:49:39.300
If it's on the screen, there is a cell and
memory for that row and you can ask for it.

00:49:39.300 --> 00:49:45.680
So if you just need to change some value,
like a Label that's currently on the screen,

00:49:45.679 --> 00:49:51.379
you can just ask the Table View for the cell for
that row, reach in, get the Text Label, set the text,

00:49:51.380 --> 00:49:55.550
that will automatically trigger a
redraw and will update the screen.

00:49:55.550 --> 00:50:01.980
We do support things like reloading individual rows or all
of the data, and this is really used not when you just want

00:50:01.980 --> 00:50:08.070
to change one thing, but when all of the content needs to
change, or you want to animate something in some way like--

00:50:08.070 --> 00:50:11.630
when if you want to reload a row and have the old ones
sort of push out to the right while the new one slides

00:50:11.630 --> 00:50:16.550
in from the left, that's an appropriate
use of the reload API.

00:50:18.659 --> 00:50:24.079
>> If you want more information, Matt Drance
is the Application Frameworks Evangelist

00:50:24.079 --> 00:50:27.409
and there's some great documentation
up the site, this is a pretty long URL,

00:50:27.409 --> 00:50:29.230
but you can pull it from the slides afterwards.
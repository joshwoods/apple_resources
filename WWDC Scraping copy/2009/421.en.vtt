WEBVTT

00:00:12.740 --> 00:00:14.050
>>My name is Miguel Sanchez.

00:00:14.050 --> 00:00:16.410
I'm an engineer on the Core Data team.

00:00:16.410 --> 00:00:21.160
I just want to tell you, this morning when I walked
out of the house my 4 year old son saw me all dressed

00:00:21.160 --> 00:00:27.370
up for the presentation he said, dad is today
the day when you get to talk to your people?

00:00:27.370 --> 00:00:32.120
[laughter] So my people, I'm here
to talk to you about Core Data.

00:00:37.729 --> 00:00:42.469
[applause and laughter] So as you saw in the trans
keynote yesterday, Core Data is an abstraction layer

00:00:42.469 --> 00:00:46.909
for the management and persistence of your data.

00:00:46.909 --> 00:00:50.039
It's making its first appearance in iPhone OS 3.0.

00:00:50.039 --> 00:00:54.990
But the technology itself has been around
on the desktop since 10.4 so we're actually

00:00:54.990 --> 00:00:58.630
on our 3rd release of the Core Data technology

00:00:59.750 --> 00:01:07.060
So let me start off by telling you what is the
problem set that we're trying to help you with.

00:01:07.060 --> 00:01:14.090
So you have a typical Core Data application, I'm sorry, a
typical iPhone application that is displaying your data.

00:01:14.090 --> 00:01:19.120
The data happens to be -- it has a need of
being persistent on the file, on the device.

00:01:19.120 --> 00:01:24.160
As a developer you don't want to care about that so much.

00:01:24.159 --> 00:01:29.019
You want to focus on your data as the objects
in memory that you're interacting with.

00:01:29.019 --> 00:01:34.879
You also have probably already learned that in
the iPhone land you have to put a lot of effort

00:01:34.879 --> 00:01:42.049
in polishing the UI you have so that you can win those
Apple design awards that we're going to give out next hour.

00:01:42.049 --> 00:01:46.319
But invariably you have to think about
the backhand side of your application.

00:01:46.319 --> 00:01:47.289
What's going on there?

00:01:47.290 --> 00:01:51.610
How are you going to get from your file into objects?

00:01:51.609 --> 00:01:54.480
How are you going to maintain your object graph in memory?

00:01:54.480 --> 00:01:57.130
And most importantly, especially on the iPhone,

00:01:57.129 --> 00:02:02.109
how are you going to do this very
efficiently, both speed wise and memory wise?

00:02:02.109 --> 00:02:06.180
So this is the problem area where
Core Data lends you a hand.

00:02:06.180 --> 00:02:10.280
This is an introductory session to Core Data.

00:02:10.280 --> 00:02:17.800
The audience is expected to not have a lot of experience
with Core Data so if that's you you're in the right spot.

00:02:17.800 --> 00:02:24.360
I'm going to be walking you through how to model your
data, working with objects, and displaying results.

00:02:24.360 --> 00:02:30.400
We have a follow up session in the Core Data
session track tomorrow morning at 10:30.

00:02:30.400 --> 00:02:36.490
This is more of the intermediate to advance Core Data
session where we tell you what's new between version 2

00:02:36.490 --> 00:02:40.409
and version 3 of the technology
on the desktop and on the phone.

00:02:40.409 --> 00:02:46.919
So if you have experience with Core Data that's
probably where you want to go to tomorrow.

00:02:46.919 --> 00:02:50.979
So let's start out with a quick overview of the framework.

00:02:50.979 --> 00:02:57.099
So the whole point of you using Core Data
is for us to allow you to think in terms

00:02:57.099 --> 00:03:00.900
of objects and avoid all the database grunt work.

00:03:00.900 --> 00:03:06.020
So please let us do all of the
efficient fetching and saving for you.

00:03:06.020 --> 00:03:14.350
Let us keep track of all your changes,
maintain an undo stack, validate your objects,

00:03:14.349 --> 00:03:18.750
help you with relationship maintenance
and let us do all of this efficiently.

00:03:18.750 --> 00:03:22.729
So this is what we're trying to do for you.

00:03:22.729 --> 00:03:24.199
Now how do we achieve this?

00:03:24.199 --> 00:03:26.780
What's the contract that we need to sign with you?

00:03:26.780 --> 00:03:27.890
We need a model.

00:03:27.889 --> 00:03:30.279
We need a description of your data.

00:03:30.280 --> 00:03:33.629
So ultimately we want to present
your data to you as objects.

00:03:33.629 --> 00:03:37.680
You don't have to worry about how it gets
to the file or how it got to the file.

00:03:37.680 --> 00:03:39.700
You want to see them as objects.

00:03:39.699 --> 00:03:46.929
But we want you to describe to us what those objects
look like and that is the model description of your data.

00:03:46.930 --> 00:03:50.800
So as long as you give us a model,
we're able to manage the data for you.

00:03:50.800 --> 00:03:56.570
We both create the store file and manage that file for you.

00:03:56.569 --> 00:04:04.000
Now some of you probably have experience with similar
relational to object mapping technologies so I'm just going

00:04:04.000 --> 00:04:11.629
to introduce our vocabulary so that you can map it to this
world if you have prior experience with this technology.

00:04:11.629 --> 00:04:20.379
In Core Data land, the data file itself is referred to as
the store so if you hear me say store, that's the data file.

00:04:20.379 --> 00:04:25.529
The data scheme or the data description, I'm
going to be referring to that as the model,

00:04:25.529 --> 00:04:28.250
the actual objects that you're interacting with at run time,

00:04:28.250 --> 00:04:32.470
Objective-C objects, for us those
are called managed objects.

00:04:32.470 --> 00:04:34.720
Those are just data objects.

00:04:34.720 --> 00:04:41.890
And the managed objects exist as part of an object
graph which we call the ManagedObjectContext.

00:04:41.889 --> 00:04:47.149
So these are the high level terms that you'll see
me throwing around, stores, models, ManagedObjects.

00:04:47.149 --> 00:04:55.250
Let's go one step deeper, I'm going to walk you through a
workflow of how you actually interact with the framework

00:04:55.250 --> 00:04:59.329
so that you can see that it's not very
difficult to get it up and running.

00:04:59.329 --> 00:05:03.349
So the first step is to give us a model.

00:05:03.350 --> 00:05:08.310
So you're going to use Xcode to create the model
file but then at run time we load the model

00:05:08.310 --> 00:05:12.250
or actually you load the model and then you give it to us.

00:05:12.250 --> 00:05:15.560
The first Core Data class you give
that model to is an instance

00:05:15.560 --> 00:05:18.829
of something called the NSPersistantStoreCoordinator.

00:05:18.829 --> 00:05:20.819
This is one of the central classes in Core Data.

00:05:20.819 --> 00:05:23.860
So if you tell the coordinator, you know
I'm going to start working with Core Data.

00:05:23.860 --> 00:05:25.350
Here's the model.

00:05:25.350 --> 00:05:31.140
The second thing the coordinator needs to know is, this is
the URL to the file that I want you to open with this model.

00:05:31.139 --> 00:05:36.289
So those are the two things that the coordinator
needs and we set up the database connection for you.

00:05:36.290 --> 00:05:40.450
And then you kind of forget about this because
as I said you don't really want to think in terms

00:05:40.449 --> 00:05:44.050
of what's going on behind the scenes with the file.

00:05:44.050 --> 00:05:48.930
You're focus should be at the Managed Object Context Level.

00:05:48.930 --> 00:05:51.379
So you want to interact with your graph of objects.

00:05:51.379 --> 00:05:56.079
So the next thing you do is create an
instance of a ManagedObjectContext class

00:05:56.079 --> 00:05:58.419
and associate it with the coordinator and that's it.

00:05:58.420 --> 00:06:02.180
At this point you have what we call the Core Data Stack.

00:06:02.180 --> 00:06:03.230
It's all up and running.

00:06:03.230 --> 00:06:05.259
It's ready for you to start using.

00:06:05.259 --> 00:06:12.099
You're going to be creating your objects, inserting them
into the context, probably you'll also be fetching objects

00:06:12.100 --> 00:06:19.980
from the database indicating the query that you want in
an instance of an NSFetchRequest, another Core Data class,

00:06:19.980 --> 00:06:25.710
and we're going to be pulling in data
from your rows into managed objects.

00:06:25.709 --> 00:06:30.560
So this is a typical workflow, what
it means to work with Core Data.

00:06:30.560 --> 00:06:35.810
If you're more familiar, if you're more
comfortable thinking in terms of database terms,

00:06:35.810 --> 00:06:41.660
the store coordinator is the part of Core Data that
is going to be managing your database connection.

00:06:41.660 --> 00:06:47.110
As I said before, the model represents
your data base keynote.

00:06:47.110 --> 00:06:51.060
The managed objects are nothing
more than the row of data, right?

00:06:51.060 --> 00:06:56.829
All of your rows in the database are going to be
represented as separate instances of managed objects.

00:06:56.829 --> 00:07:02.229
And the FetchRequest is, if you're familiar with
CPOL, this is where you're indicating the select

00:07:02.230 --> 00:07:06.730
from where, order by parts of your query.

00:07:06.730 --> 00:07:15.100
You're not necessarily using that syntax but
conceptually that's what's going on there.

00:07:15.100 --> 00:07:18.129
So once again, it's very easy to get started with Core Data.

00:07:18.129 --> 00:07:22.459
You need to follow just four quick
steps to bring up the stack.

00:07:22.459 --> 00:07:26.750
Let's review, one, you need to load the model.

00:07:26.750 --> 00:07:31.540
Two, you create a coordinator and
you set the model on coordinator,

00:07:31.540 --> 00:07:35.410
you say I'm going to be managing data of this kind.

00:07:35.410 --> 00:07:42.320
Then you point the store, I'm sorry, you add a store to
the coordinator and the last step is you create a context

00:07:42.319 --> 00:07:46.839
which is going to be your main point of interaction and
you associate it with the coordinator and then that's it.

00:07:46.839 --> 00:07:50.469
At this point you're interacting
with your objects and the context.

00:07:50.470 --> 00:07:57.400
So let me show you how easy this
is by walking you through a demo.

00:07:57.399 --> 00:08:02.269
This demo is going to do nothing fancy.

00:08:02.269 --> 00:08:08.039
I'm going to simply do something that all
of you can do with your bits out there.

00:08:08.040 --> 00:08:18.890
I'm simply going to create a new project in Xcode and
show you that we now have this little checkbox here

00:08:18.889 --> 00:08:20.909
for certain types of iPhone applications.

00:08:20.910 --> 00:08:25.060
So here I'm going to create a navigation
based application and I'm just going to say

00:08:25.060 --> 00:08:27.259
that we want to use Core Data for storage, alright?

00:08:27.259 --> 00:08:31.139
That's how you include it in your sources.

00:08:31.139 --> 00:08:33.620
So I'm going to call this demo 1.

00:08:33.620 --> 00:08:42.450
So I'm just going to walk you through the files that
are created in this Xcode template so that you know

00:08:42.450 --> 00:08:45.060
where to look for the Core Data parts of the application.

00:08:45.059 --> 00:08:51.419
But first let me launch the application so that you
know what you get from simply creating the project.

00:08:51.419 --> 00:09:00.659
So this is an Xcode template project so it doesn't
do much but it does enough to show Core Data.

00:09:00.659 --> 00:09:07.199
We display a UI table view and we have this
little flash button that allows you to add records

00:09:07.200 --> 00:09:09.520
and the records are very simplistic in this case.

00:09:09.519 --> 00:09:17.120
They're just time stamps of events representing the
time when you clicked on this plus button, right?

00:09:17.120 --> 00:09:20.970
And then we have basic delete logic.

00:09:20.970 --> 00:09:24.470
A lot of these has nothing to do with Core Data.

00:09:24.470 --> 00:09:26.170
This is simple UI kit code.

00:09:26.169 --> 00:09:28.949
So this is what the project does.

00:09:28.950 --> 00:09:30.350
Now I just quit the app.

00:09:30.350 --> 00:09:33.200
It's Core Data so it has to be persisted on a file.

00:09:33.200 --> 00:09:37.890
If I launch the app again, its Core Data
so it's bringing the data back up, right.

00:09:37.889 --> 00:09:42.759
So this is, again it's a very simple
template but it's already using Core Data.

00:09:42.759 --> 00:09:44.600
So what do we give you?

00:09:44.600 --> 00:09:51.769
Let's start by showing you where the stack is created.

00:09:51.769 --> 00:09:59.569
I said it was very easy so let me collapse the methods here.

00:09:59.570 --> 00:10:05.900
So here we have, remember I said the first step is
to load a model, so there we have an accessor method

00:10:05.899 --> 00:10:12.620
where we message the merge model from
bundle method or ManagedObjectModel.

00:10:12.620 --> 00:10:18.509
There's other methods to load the model based on a URL but
this particular method says go into my research directory,

00:10:18.509 --> 00:10:23.409
find all the Core Data models you can find, merge them into
1 model and that's where you're loading them into memory.

00:10:23.409 --> 00:10:26.709
So that was step 1, 1 line we covered.

00:10:26.710 --> 00:10:30.190
Step 2 I said was create an instance

00:10:30.190 --> 00:10:35.240
of PersistantStoreCoordinator, here
it is and set the model, right?

00:10:35.240 --> 00:10:39.919
So this is what we call the ManagedObjectModel
accessor, that's step 2.

00:10:39.919 --> 00:10:49.629
Step 3 is to add the store to the coordinator so here
we're telling it, add the store with the type SQL like

00:10:49.629 --> 00:10:57.049
and the URL is here, here's the URL which I just
built beforehand so that's the end of step 3.

00:10:57.049 --> 00:11:01.129
And step 4 is to create a ManagedObjectContext.

00:11:01.129 --> 00:11:04.679
So here we have the ManagedObjectContext, I'll look it in it

00:11:04.679 --> 00:11:08.049
and here we set the coordinator
on the context and that's it.

00:11:08.049 --> 00:11:13.629
At this point you have the Core Data stack up
and running and what do you do with that stack?

00:11:13.629 --> 00:11:19.100
Well this particular application I'm not going into
the details of what the application is actually doing

00:11:19.100 --> 00:11:25.639
from a UI point of view but basically it creates a
view controller which is going to handle all of the UI

00:11:25.639 --> 00:11:30.259
that has very little to do with Core Data and
we pass it to context because that's going

00:11:30.259 --> 00:11:32.480
to be our main point of interaction with Core Data.

00:11:32.480 --> 00:11:36.060
And later on in the presentation I'll be showing
you how you're interacting with the context

00:11:36.059 --> 00:11:40.139
but this is an Xcode template,
that's how you set it up, right?

00:11:40.139 --> 00:11:48.689
The second important file that you want to look at
from Core Data's point of view is your model file.

00:11:48.690 --> 00:11:50.590
So here we have the Core Data model.

00:11:50.590 --> 00:11:53.180
It's a very simple 1 entity model.

00:11:53.179 --> 00:11:57.539
You'll be editing it as you expand
your data, this definition.

00:11:57.539 --> 00:12:05.029
We have an editor inside of Xcode that allows you
to do basically a relationship editing tool here.

00:12:05.029 --> 00:12:08.009
This is where you'll be creating future entities.

00:12:08.009 --> 00:12:09.970
Let's say that you want an event.

00:12:09.970 --> 00:12:16.840
In addition to the event entity you want to have a
location entity and you want these 2 things to be related

00:12:16.840 --> 00:12:26.670
so the event points to a location
and the location has many events.

00:12:26.669 --> 00:12:28.069
This is the To-Many relationship.

00:12:28.070 --> 00:12:31.340
I'll be talking about these concepts
in the presentation but I just want

00:12:31.340 --> 00:12:36.090
to show you how you would build your
data description in a graphical way.

00:12:36.090 --> 00:12:46.009
Another thing I want to point out here is when you do have
your model from Xcode you're also able to generate the files

00:12:46.009 --> 00:12:51.439
for these classes, for these entities,
by going to the new file menu item.

00:12:51.440 --> 00:12:56.110
Here you have a file type, I'm
sorry, in NSManagedObjectClass.

00:12:56.110 --> 00:13:06.090
I'm going to create the files for the two entities
that I have in my model and here they are.

00:13:06.090 --> 00:13:08.129
Here's the event entity.

00:13:08.129 --> 00:13:11.539
I just want to highlight here that
we're not generating a lot of code.

00:13:11.539 --> 00:13:15.480
All of the implementation is coming
from this class NSManagedObject

00:13:15.480 --> 00:13:19.490
which I'll be talking about in the presentation.

00:13:19.490 --> 00:13:23.680
We're simply declaring your accessor so
that you can message them at run time.

00:13:23.679 --> 00:13:31.709
If I go to the location 1, the location clause,
really all I'm doing is declaring the accessor methods

00:13:31.710 --> 00:13:35.509
to add objects to that To-many relationship I declared.

00:13:35.509 --> 00:13:40.600
And look at the dot M, there's really nothing much there.

00:13:40.600 --> 00:13:45.040
This is where you would be introducing
all of your specific business logic code

00:13:45.039 --> 00:13:48.959
but not really Core Data code that you need to implement.

00:13:48.960 --> 00:13:55.840
So we're not just dumping a whole
bunch of code for you to work with.

00:13:55.840 --> 00:14:04.450
So that's a quick overview of the Core
Data template that we have in Xcode.

00:14:04.450 --> 00:14:10.330
Now let's start going deeper into each one of
those elements that I brought up in the demo.

00:14:10.330 --> 00:14:14.530
So let's talk about modeling your data.

00:14:14.529 --> 00:14:18.240
The model, as I showed you in that file, has two purposes.

00:14:18.240 --> 00:14:24.889
The first is to describe the structure of your data, that's
where you're defining your entities and how they're related

00:14:24.889 --> 00:14:30.629
and this is what we're using to create the store
file for you and to manage it subsequently.

00:14:30.629 --> 00:14:36.269
But as you're defining the model, you're
also giving us hints within the model

00:14:36.269 --> 00:14:39.460
as to what are the semantics of that data?

00:14:39.460 --> 00:14:42.009
You can add simple validation rules.

00:14:42.009 --> 00:14:47.620
You can tell us what happens when a master
object is deleted from a relationship,

00:14:47.620 --> 00:14:49.669
so there's a little bit more to the structure in your data.

00:14:49.669 --> 00:14:54.149
There's also a little bit of rules as to
how you want us to help you manage it.

00:14:54.149 --> 00:15:00.230
It's important that you spend time thinking
about your model because this is going to be one

00:15:00.230 --> 00:15:03.170
of the central elements that Core Data uses to help you out.

00:15:03.169 --> 00:15:07.769
So the better model you have designed,
the more we will be able to help you.

00:15:07.769 --> 00:15:13.710
And try to design your model with the usage pattern in
mind that you're going to give it in your application.

00:15:15.059 --> 00:15:16.500
This is what a model looks like.

00:15:16.500 --> 00:15:20.399
Visually you saw it in the editor I just showed in the demo.

00:15:20.399 --> 00:15:29.429
At a very high level, this is by the way a model of a
music domain where you have songs that are part of albums

00:15:29.429 --> 00:15:35.699
and albums are produced by artists, so just some vocabulary.

00:15:35.700 --> 00:15:39.870
The big boxes, we refer to those as entities.

00:15:39.870 --> 00:15:43.179
Entities are made up of property, you have properties.

00:15:43.179 --> 00:15:50.089
They can either be attributes or relationships and
there's something I'm not showing here in this diagram

00:15:50.090 --> 00:15:55.700
but there's also rules about the model encoded.

00:15:55.700 --> 00:15:59.040
So let's look at each one of those elements of the model.

00:15:59.039 --> 00:16:02.579
So entities are represented in
run time by NSEntity descriptions

00:16:02.580 --> 00:16:05.350
but you probably don't have to worry too much about that.

00:16:05.350 --> 00:16:12.639
The entities are the blueprints that we'll be
using to create the instances of your data.

00:16:12.639 --> 00:16:16.519
They're made up of properties, attributes and relationships.

00:16:16.519 --> 00:16:21.480
So most of the time you'll be modeling all of the
simple fields that you want us to store on your file

00:16:21.480 --> 00:16:27.810
but you should also know that some of the properties that
you define in your model won't necessarily be persistent.

00:16:27.809 --> 00:16:32.049
They will be important to you at run time
because you're dealing with that data

00:16:32.049 --> 00:16:35.729
but that data might not be persistent
in that shape and form.

00:16:35.730 --> 00:16:41.100
It might be a computed value from two other
persistent properties so you can also model properties

00:16:41.100 --> 00:16:44.210
that aren't persistent and we call those transients.

00:16:44.210 --> 00:16:55.210
To make a database analogy, these are equivalent to
table definitions with one important distinction.

00:16:55.210 --> 00:16:59.740
Even though there's a database behind the
scenes you don't worry about primary keys

00:16:59.740 --> 00:17:01.919
because we're dealing with all of that for you, right?

00:17:01.919 --> 00:17:07.339
So don't try to model properties that
represent primary keys in your data.

00:17:07.339 --> 00:17:09.269
Simply model what your data is.

00:17:09.269 --> 00:17:17.680
Don't worry about the underlying database
constructs that you're not going to see.

00:17:17.680 --> 00:17:19.420
Entities are made up of attributes.

00:17:19.420 --> 00:17:22.120
These are the simple fields that indicate the value type.

00:17:22.119 --> 00:17:25.289
You can see the types that we support,
numeric, strings, dates,

00:17:25.289 --> 00:17:30.879
binaries but we also have this
special type called transformable

00:17:30.880 --> 00:17:37.870
which can basically transform any other type that's not
one of the basics type that we support, a color or a sound,

00:17:37.869 --> 00:17:43.559
and we can package it, as long as you give us a value
transformer, we can package it into 1 of our basic types

00:17:43.559 --> 00:17:48.619
so if you don't see the type you want to
have up there, you can still work with it.

00:17:48.619 --> 00:17:51.279
It just has to be wrapped up.

00:17:51.279 --> 00:17:56.379
As I said before the attributes also is where
you start adding simple validation rules.

00:17:56.380 --> 00:18:02.440
Say for example you're modeling the age of a person,
within the model you can declare the range of values

00:18:02.440 --> 00:18:07.430
that makes a valid age, whether it can be null or not.

00:18:07.430 --> 00:18:12.970
The analogy here in the database
world, these are column definitions.

00:18:12.970 --> 00:18:18.700
Finally, relationships are the
properties that reference other entities.

00:18:18.700 --> 00:18:21.319
They can either be To-One or To-Many.

00:18:21.319 --> 00:18:26.119
This is something that confuses initial uses of Core Data.

00:18:26.119 --> 00:18:32.789
In Core Data, relationships or To-Many
relationships are modeled as unordered sets.

00:18:32.789 --> 00:18:40.049
So you're responsible for adding order
To-Many relationships and it's possible

00:18:40.049 --> 00:18:46.139
but by default Core Data simply
represents them to you as unordered sets.

00:18:46.140 --> 00:18:50.130
We want you to model the relationships
in bidirectional ways to have inverses

00:18:50.130 --> 00:18:53.380
so that we can better maintain the integrity of your data.

00:18:53.380 --> 00:19:00.260
And in terms of semantics at the relationship level is
where you can tell us, you can give us hints as to what

00:19:00.259 --> 00:19:02.960
to do when deletion happens within your data.

00:19:02.960 --> 00:19:11.029
So the master object goes away so what happens to all
of the detail objects that are associated with it?

00:19:11.029 --> 00:19:15.930
These are equivalent to joint tables and foreign
keys, except that they're not from your point of view

00:19:15.930 --> 00:19:17.160
because you don't worry about this, right?

00:19:17.160 --> 00:19:23.720
From your point of view they're just the concept that an
entity is related to the other entity and you let us worry

00:19:23.720 --> 00:19:27.049
about how we're actually maintaining
that relationship behind the scenes.

00:19:27.049 --> 00:19:30.849
Don't model the joint table.

00:19:30.849 --> 00:19:40.519
So revisiting the model now that we're familiar with the
terms, we have a basic music model that has a songs entity.

00:19:40.519 --> 00:19:43.039
The songs entity has four attributes.

00:19:43.039 --> 00:19:45.849
It has one relationship, the album.

00:19:45.849 --> 00:19:47.719
So a song has one album.

00:19:47.720 --> 00:19:51.029
It's a To-Many relationship to the album entity.

00:19:51.029 --> 00:19:57.069
That relationship has an inverse which happens
to be the songs relationship from album to songs.

00:19:57.069 --> 00:20:01.559
It's a To-Many because an album
can have many songs and so forth.

00:20:01.559 --> 00:20:07.690
There's many To-Many relationship between album and artist

00:20:07.690 --> 00:20:16.299
and its model is many To-Many with
an inverse of each other there.

00:20:16.299 --> 00:20:20.099
So we're done talking about the model.

00:20:20.099 --> 00:20:23.879
Now let's talk about how you work with the Managed Objects.

00:20:23.880 --> 00:20:27.640
So here's the stack again that I
introduced in the first section.

00:20:27.640 --> 00:20:33.980
In this part of the talk I'll be focusing
on the context and the Managed Objects

00:20:33.980 --> 00:20:35.660
which is what you're really, that's your data.

00:20:35.660 --> 00:20:37.420
That's what you want to manipulate.

00:20:37.420 --> 00:20:44.420
So your data will be represented
as instances of NSManagedObjects.

00:20:44.420 --> 00:20:48.820
Each one of these represents a row of your
data and this is really the workhorse.

00:20:48.819 --> 00:20:51.659
This is what you'll always be interacting with.

00:20:51.660 --> 00:20:56.300
They have to be associated with a single entity
of course because they represent a row in each 1

00:20:56.299 --> 00:20:59.619
of your tables and you also have a unique identifier.

00:20:59.619 --> 00:21:07.159
I said before that you don't worry about the primary
key and you don't but if you need to ask it's object

00:21:07.160 --> 00:21:12.550
for a unique idea, we do wrap that private key behind
the scenes into an object wrapper so that there is a way

00:21:12.549 --> 00:21:16.970
of referring to the object with a unique ID.

00:21:16.970 --> 00:21:23.329
How do you interact, this is where it starts to get very
interesting, how do you interact with your managed objects?

00:21:23.329 --> 00:21:26.129
You interact with them as any other Objective-C objects.

00:21:26.130 --> 00:21:28.200
Simply call their accessors, right?

00:21:28.200 --> 00:21:31.200
We're doing all the hard work behind the scenes.

00:21:31.200 --> 00:21:33.400
You just start calling their accessors.

00:21:33.400 --> 00:21:38.060
The accessors are most likely going to be
represented as Objective-C properties and remember

00:21:38.059 --> 00:21:45.609
that To-Many relationships are sets so you set mutator
methods that you're interacting with To-Many relationships.

00:21:45.609 --> 00:21:48.429
But most likely you're probably just
going to be using the accessor methods

00:21:48.430 --> 00:21:54.400
that are generated for you, like I showed you in the demo.

00:21:54.400 --> 00:22:00.140
Now in the demo I showed you how to generate the code
for your objects but that's not really necessary.

00:22:00.140 --> 00:22:04.880
I just wanted to show you with an Xcode
where you go to generate the code.

00:22:04.880 --> 00:22:10.220
But by default unless you're doing your own
custom logic in your objects, you don't need that.

00:22:10.220 --> 00:22:13.710
You don't even need to have executed that step

00:22:13.710 --> 00:22:20.309
The default implementation of Managed Object
already gives you support for key value coding,

00:22:20.309 --> 00:22:26.450
key value of serving so if all you're doing with your
objects is setting their state and getting their state,

00:22:26.450 --> 00:22:31.549
you're not doing computed values or anything like
that, you don't even need code for your objects.

00:22:31.549 --> 00:22:34.700
You already get that from the default implementation.

00:22:34.700 --> 00:22:40.769
You would usually generate the code and extend their
behavior if you want to compute the right values or you want

00:22:40.769 --> 00:22:48.690
to add multi-property validation and as I showed you in the
demo, it's the new file menu, NSManagedObjects Subclass,

00:22:48.690 --> 00:22:54.740
where you actually go to generate the code if you need it.

00:22:54.740 --> 00:23:00.740
So the objects, you create them
but they don't exist in a vacuum.

00:23:00.740 --> 00:23:04.890
As I keep bringing up, you're always
dealing with an object graph

00:23:04.890 --> 00:23:09.390
so objects always have to be associated with a context.

00:23:09.390 --> 00:23:12.550
It is the context, that's why they're called ManagedObjects.

00:23:12.549 --> 00:23:13.539
Who's managing them?

00:23:13.539 --> 00:23:16.039
The context is managing them.

00:23:16.039 --> 00:23:21.879
The context is the one that's keeping track of all the
changes that you're performing on your objects so that

00:23:21.880 --> 00:23:26.320
when you tell us to save we know what to update in the file.

00:23:26.319 --> 00:23:29.750
So objects must always be associated with the context.

00:23:29.750 --> 00:23:32.529
This is a weak reference between the two.

00:23:32.529 --> 00:23:35.200
Neither retains each other so you're responsible

00:23:35.200 --> 00:23:39.210
for retaining your own ManagedObjects
if you want them to keep around.

00:23:39.210 --> 00:23:44.960
And the contexts are serving all the changes
that you're performing in your objects.

00:23:44.960 --> 00:23:50.120
Think of the context as a workbench or as a
scratch pad where you bring in all of your objects

00:23:50.119 --> 00:23:54.419
and you start interacting with them and Core Data
is monitoring them and then you tell us to save

00:23:54.420 --> 00:23:59.740
and then we know what happened to maintain
your object graph in a correct state.

00:24:00.970 --> 00:24:07.880
Another way of thinking about this is if the objects
represents the noun, the context defines the verbs

00:24:07.880 --> 00:24:09.760
that you want, you can execute on these subjects.

00:24:09.759 --> 00:24:15.519
So the context is what you'll be doing,
things like fetching, inserting, deleting,

00:24:15.519 --> 00:24:20.819
saving and while you're doing all
this, and updating to, your objects,

00:24:20.819 --> 00:24:23.839
the context will be keeping track of what's going on.

00:24:23.839 --> 00:24:30.500
So this is better explained in diagram form.

00:24:30.500 --> 00:24:37.920
I'm going to walk you through a series of diagrams that
show you how you interact with a ManagedObject context

00:24:37.920 --> 00:24:43.480
in your Managed Objects and what's going
on behind the scenes with Core Data.

00:24:43.480 --> 00:24:49.059
So let's say that you already have a context
set up that has an album and two songs

00:24:49.059 --> 00:24:54.710
and what you want to do is insert a new song on the album.

00:24:54.710 --> 00:25:00.440
So from your point of view, one line of code to
create and instance of an object and I'll look

00:25:00.440 --> 00:25:04.220
in it, you create your instance of your object.

00:25:04.220 --> 00:25:07.559
You always have to associate it with
a context so part of the initializer

00:25:07.559 --> 00:25:12.579
for your managed objects requires a context
so that's still in that 1 line of code.

00:25:12.579 --> 00:25:18.309
Now it's associated to the context
and you want to add it to the album.

00:25:18.309 --> 00:25:22.960
As I said at the very beginning of this
talk, you're simply interacting with objects

00:25:22.960 --> 00:25:26.920
and all that you're doing is calling their accessor methods.

00:25:26.920 --> 00:25:33.870
So you can either, remember that we have a bidirectional
relationship, so you can either set the album on the song

00:25:33.869 --> 00:25:38.449
by calling the set album accessor method
or you can add the song to the album

00:25:38.450 --> 00:25:41.950
by calling the add song accessor method on the album.

00:25:41.950 --> 00:25:44.059
You can just do it on 1 side of the relationship.

00:25:44.059 --> 00:25:46.909
Core Data takes care of maintaining the integrity.

00:25:46.910 --> 00:25:49.160
So that was 2 calls for you, right?

00:25:49.160 --> 00:25:55.250
You create the object and the second call is you give
it an album and Core Data maintains that graph for you.

00:25:55.250 --> 00:26:04.450
Now you want to delete 1 method call for
you, at the ManagedObjectContext level,

00:26:04.450 --> 00:26:07.950
delete and you pass it the instance of the album.

00:26:07.950 --> 00:26:09.880
That's it, 1 method call.

00:26:09.880 --> 00:26:14.270
But this is where we start taking advantage of
the information that you gave us in the model.

00:26:14.269 --> 00:26:21.609
If you told us to cascade your deletes, Core Data is also
taking care of getting rid of all those songs for you.

00:26:21.609 --> 00:26:24.969
Oops, that's not what I wanted to do.

00:26:24.970 --> 00:26:32.289
I changed my mind, undo, use the undo manager
associated with the Context and we bring it back.

00:26:32.289 --> 00:26:34.869
We have, we're doing all this work for you, right?

00:26:34.869 --> 00:26:40.689
I know for you it's only 1 line of code for whatever
you're trying to do with your objects and so forth.

00:26:40.690 --> 00:26:49.370
As you continue to work with your objects to associate
them, all you're doing is calling accessors on them.

00:26:49.369 --> 00:26:56.549
Let's say that you want to move song Q from
album to album 2, all you do is call set album

00:26:56.549 --> 00:27:01.470
and pass the argument album 2 on
your song instance and that's it.

00:27:01.470 --> 00:27:06.009
Core Data knows that the song has
to be moved to the other album.

00:27:06.009 --> 00:27:11.650
It has to be removed from the previous add and the
To-Many relationship and album 2 has to be all set up.

00:27:11.650 --> 00:27:15.080
So this is where the power of the model comes in to play.

00:27:15.079 --> 00:27:18.809
You are only worrying about calling your access of methods

00:27:18.809 --> 00:27:23.639
as if these were a regular Objective-C
object, which they are.

00:27:23.640 --> 00:27:30.950
So that was a quick example or a series of examples of how
you are interacting with objects as you're inserting them

00:27:30.950 --> 00:27:35.490
into the context or associating them with the context.

00:27:35.490 --> 00:27:41.589
Now most of the time, especially in the iPhone, the
iPhone doesn't really lend itself to a lot of data entry,

00:27:41.589 --> 00:27:48.250
although you could do that, you'll probably be doing a lot
of data fetching from data that you already have in a store.

00:27:48.250 --> 00:27:55.190
So in this part of the talk I'm going
to explain to you how you get your data

00:27:55.190 --> 00:27:59.990
which exists in the database, into the context.

00:27:59.990 --> 00:28:06.390
To accomplish this you will be creating an instance
of a Core Data class called NSFetchRequest.

00:28:06.390 --> 00:28:08.370
This is really the query description.

00:28:08.369 --> 00:28:10.279
You're going to create your query description.

00:28:10.279 --> 00:28:15.639
You're going to execute that query on the
ManagedObjectContext and Core Data is going to take care

00:28:15.640 --> 00:28:20.690
of going down to your database, fetching the
corresponding data, wrapping it as objects

00:28:20.690 --> 00:28:24.279
and presenting it to you as part of your object crash.

00:28:24.279 --> 00:28:29.240
And then from this point on it's exactly the
same thing we just finished talking about.

00:28:29.240 --> 00:28:35.779
These are objects and you interact with them by simply
calling their access of methods or you execute methods

00:28:35.779 --> 00:28:42.279
on the context if you want to do more
fetching or deleting or things like that.

00:28:42.279 --> 00:28:46.119
So let's look at the fetch request in more detail.

00:28:46.119 --> 00:28:52.109
The fetch request hasthree main elements that
you have to set when you want to specify a query.

00:28:52.109 --> 00:28:58.490
We need to know the entity that you're querying on, we
need to know how you want to filter that information

00:28:58.490 --> 00:29:06.640
with a filter predicate and a sort descriptor, how you
want us to sort that information when we bring it back.

00:29:06.640 --> 00:29:13.230
In database terms, the entity part of the fetch request
is where you're indicating the select from clause

00:29:13.230 --> 00:29:17.519
of your query, but you're simply giving it the entity name.

00:29:17.519 --> 00:29:24.440
The predicate is equivalent to the where clause in SQL land

00:29:24.440 --> 00:29:28.840
and the sorting descriptors are the
order by part of the clause, right?

00:29:28.839 --> 00:29:38.009
So it's very similar to how you're doing the queries on
the database except that it's got an object wrapper to it.

00:29:38.009 --> 00:29:43.140
Here are two quick examples of
two very common fetch requests.

00:29:43.140 --> 00:29:47.690
The first one I just, it's so simple but it
confuses some people the first time they try this,

00:29:47.690 --> 00:29:50.740
what if you want to fetch all the artists?

00:29:50.740 --> 00:29:56.980
You simply create a fetch request saying the entity
I want to work with are my artists, that's my artist

00:29:56.980 --> 00:30:00.630
and you don't give any predicate
because you want all of them.

00:30:00.630 --> 00:30:04.850
And then you specify how you want to sort them
and at that point you execute on your context

00:30:04.849 --> 00:30:07.389
and Core Data gets all of the artists in your database.

00:30:07.390 --> 00:30:11.720
So this is probably 1 of the first things that
your application will do as it wants to bring

00:30:11.720 --> 00:30:15.170
up its table view or whatever, initial display of data.

00:30:15.170 --> 00:30:19.070
Predicates can get very sophisticated.

00:30:19.069 --> 00:30:26.500
In this second example we're creating a fetch
request that goes out and fetches all of the albums

00:30:26.500 --> 00:30:30.529
that have at least ten songs associated with them.

00:30:30.529 --> 00:30:33.289
So again what we want to work with are albums.

00:30:33.289 --> 00:30:40.829
Our entity is an album, the predicate, we're walking
the relationship songs on each one of those albums

00:30:40.829 --> 00:30:46.529
and we're taking a count of how many songs each
album has and we're only returning the ones

00:30:46.529 --> 00:30:49.859
that have more than ten songs and then we sort.

00:30:49.859 --> 00:30:55.319
I'd like to highlight here, if you're thinking in SQL
terms, this is where you would start thinking in terms

00:30:55.319 --> 00:30:59.980
of joint tables and putting two things together.

00:30:59.980 --> 00:31:06.779
I'd like to highlight here that you're telling Core Data to
fetch albums for you and you're specifying in the predicate

00:31:06.779 --> 00:31:10.700
that you want us to analyze your relationships
and count how many objects are at the end

00:31:10.700 --> 00:31:12.710
of that relationship and give you back your results.

00:31:12.710 --> 00:31:17.299
So sure behind the scenes there are joints
happening and Core Data is doing all of that

00:31:17.299 --> 00:31:19.869
for you but you don't have to worry about that.

00:31:19.869 --> 00:31:26.279
You're simply specifying your query
in sort of more object level terms.

00:31:28.019 --> 00:31:32.940
Now how much data are we actually
bringing in each time you fetch?

00:31:32.940 --> 00:31:41.070
If you indicate a fetch to get albums or a
subset of albums, we give you the albums.

00:31:41.069 --> 00:31:44.329
They're brought into the context.

00:31:44.329 --> 00:31:47.740
You might wonder well but you keep saying
that we always have an object graph, right?

00:31:47.740 --> 00:31:51.289
So what happened to the songs that are part of this album?

00:31:51.289 --> 00:31:54.339
Well they're there in your database
and Core Data knows about them.

00:31:54.339 --> 00:31:57.519
There's a little bit of bookkeeping
information but we don't bring them

00:31:57.519 --> 00:32:00.150
into memory because you did not ask for the albums.

00:32:00.150 --> 00:32:03.690
We simply brought albums in because
that's what you asked for.

00:32:03.690 --> 00:32:08.019
So how do you get to the, I'm sorry,
how do you get to the songs?

00:32:08.019 --> 00:32:11.269
Once again you simply message your accessor method.

00:32:11.269 --> 00:32:19.539
Let's say that you want to get to the songs in album
2, you have your album 2 instance and you call songs.

00:32:19.539 --> 00:32:26.960
And Core Data behind the scenes, goes out,
fetches the corresponding data and presents

00:32:26.960 --> 00:32:29.529
to you the result of the accessor method.

00:32:29.529 --> 00:32:34.950
So you don't have to create a secondary query and
figure out which songs are related to this album.

00:32:34.950 --> 00:32:37.120
Core Data is taking care of this for you.

00:32:37.119 --> 00:32:41.229
So this is how you interact with
traversing your Object Graph.

00:32:41.230 --> 00:32:46.880
You start out with an initial object and
depending on what your user is requesting from you,

00:32:46.880 --> 00:32:50.760
you simply call accessor methods on
those objects and Core Data starts

00:32:50.759 --> 00:32:53.789
to populate the Object Graph behind the scenes for you.

00:32:53.789 --> 00:32:58.490
So as you can see this is where memory
efficiency starts to come into play

00:32:58.490 --> 00:33:04.259
because you're only getting what you're
touching as your walking object graph.

00:33:04.259 --> 00:33:12.029
We're also taking care of uniqueing so if you access the
artist for album 3 and later on you access the artist

00:33:12.029 --> 00:33:18.930
from album 2 and it happens to be the same artist, Core
Data is returning you a single instance of the artist.

00:33:18.930 --> 00:33:21.769
So we're taking care of all of these things for you.

00:33:21.769 --> 00:33:25.059
If you're tried to do this in SQL
by hand you probably are starting

00:33:25.059 --> 00:33:33.329
to realize now how much work there is behind
the scenes when we're giving this to you.

00:33:33.329 --> 00:33:40.319
Now since you'll be doing so much fetching, potentially
in your applications, you might want to think a little bit

00:33:40.319 --> 00:33:45.619
about how you are actually using the
results that you're asking us to fetch,

00:33:45.619 --> 00:33:49.639
when you want to improve the performance
of your application even more.

00:33:49.640 --> 00:33:53.030
Are you actually using those objects
that you got, you asked us to fetch?

00:33:53.029 --> 00:33:59.500
Are you just counting them to update a little
field on your UI or do you even need full objects?

00:33:59.500 --> 00:34:05.630
Do you always happen to require all of the
related objects once you fetch a MasterObject?

00:34:05.630 --> 00:34:11.550
And Core Data gives you simple ways
of improving your fetch performance.

00:34:11.550 --> 00:34:17.580
This is a simple fetch, we're fetching
a subset of albums like I just described

00:34:17.579 --> 00:34:20.989
in the previous slides, as I said,
you asked us to fetch albums.

00:34:20.989 --> 00:34:22.559
We only fetch albums.

00:34:22.559 --> 00:34:28.599
And we have a little bit of bookkeeping information
to get the songs but they're not brought into memory.

00:34:28.599 --> 00:34:33.219
But let's say that the reason that you're fetching
these albums into memory is just to count them.

00:34:33.219 --> 00:34:36.189
You're not even going to display them in the UI.

00:34:36.190 --> 00:34:43.720
In that case, be aware that there's a method on
ManageObjectContext where you pass it a fetch request

00:34:43.719 --> 00:34:47.599
and we do all of the counting for you in
the database and we don't even bring objects

00:34:47.599 --> 00:34:50.549
into memory if you don't want to take that hit.

00:34:50.550 --> 00:34:58.350
So countForFetchRequest is a method that you can call on
ManageObjectContext to go and get accounts for an object.

00:34:58.349 --> 00:35:07.639
So 1 little tip, for this particular
use case you can avoid a lot of memory.

00:35:07.639 --> 00:35:12.549
Moving on in the same theme, let's
say you have a part of your UI

00:35:12.550 --> 00:35:16.150
that only displays a subset of
the properties in your entity.

00:35:16.150 --> 00:35:22.700
You happen to define an entity with twenty properties and
that's useful for other parts of the UI of your application

00:35:22.699 --> 00:35:28.969
but you have this little table view where you're
only displaying one or two properties for that album

00:35:28.969 --> 00:35:35.819
so you don't really want to fetch the
whole object if that's your primary fetch.

00:35:35.820 --> 00:35:41.720
There's a method on NSfetchRequest setPropertiesToFetch
where you indicate an array of the property that you want us

00:35:41.719 --> 00:35:48.429
to go get and when we populate your objects we only
bring in the subset of properties that you're after.

00:35:48.429 --> 00:35:50.079
So again you're saving memory.

00:35:50.079 --> 00:35:55.670
If you later on need to message all the other
property that you didn't fetch, no problem.

00:35:55.670 --> 00:35:57.130
You simply call your accessors.

00:35:57.130 --> 00:35:58.450
You don't worry about this.

00:35:58.449 --> 00:36:03.960
Core Data goes and fetches the full
object for you once you actually need it.

00:36:06.550 --> 00:36:17.060
This is now the opposite extreme of this case, this is
an instance where you're fetching albums and you know

00:36:17.059 --> 00:36:23.150
that anytime you're fetching an album you will right
away be dealing with the songs inside those albums.

00:36:23.150 --> 00:36:29.889
So you want to avoid the double trip to the database to
first fetch the albums and then to go fetch the songs.

00:36:29.889 --> 00:36:39.460
So there's a method on NSfetchRequest where you can set
the relationships keypass to prefetch so that we can go

00:36:39.460 --> 00:36:45.119
into 1 database strip, get your songs
and your albums and save trips to disc.

00:36:45.119 --> 00:36:54.739
Fetching in batches, let's say that you ask us to fetch a
list of albums but then your user starts clicking in the UI

00:36:54.739 --> 00:37:01.589
to access them and they're kind of at random order so they
first click in that upper set of albums and then they go

00:37:01.590 --> 00:37:04.460
to the bottom and then they go to the middle.

00:37:04.460 --> 00:37:10.199
But you asked us to fetch all the albums, right,
so you're keeping all of those albums in memory.

00:37:10.199 --> 00:37:16.799
There's another way of indicating, of optimizing
your fetch request by setting their batch size.

00:37:16.800 --> 00:37:21.690
So in this particular use case you would say, you know what?

00:37:21.690 --> 00:37:27.900
I want you to fetch the albums based on this
query but set a batch size of three for example.

00:37:27.900 --> 00:37:34.710
So we go and fetch, even though we know the list of albums
that you asked us to get, we don't bring all of them in.

00:37:34.710 --> 00:37:38.220
We only bring in the first batch of three albums.

00:37:38.219 --> 00:37:38.879
It's an array.

00:37:38.880 --> 00:37:49.070
And then you access objects farther down in the array
and Core Data realizes that they're not in memory yet.

00:37:49.070 --> 00:37:53.230
We go and get the next batch, right?

00:37:53.230 --> 00:37:59.710
You move back up in the array, Core Data says those
objects aren't in memory yet, we go and get the next batch.

00:37:59.710 --> 00:38:02.050
But here's where it gets very interesting.

00:38:02.050 --> 00:38:08.710
We keep a limited set of batches and we order
them by least recently used so as we see

00:38:08.710 --> 00:38:14.010
that you're no longer using certain
batches, they go away behind the scenes.

00:38:14.010 --> 00:38:16.520
We're getting rid of that memory.

00:38:16.519 --> 00:38:19.539
You don't have to worry about this.

00:38:19.539 --> 00:38:27.710
So there's a lot of these kinds of things that you can learn
by reviewing the NSFetchRequest header and documentation.

00:38:27.710 --> 00:38:32.970
What I'd like to point out right now is that
all of those examples I just walked through,

00:38:32.969 --> 00:38:36.679
each one of those cases are simply one line of code for you.

00:38:36.679 --> 00:38:41.159
It's one setting or one flag that you're setting
on the FetchRequest and you're getting a lot

00:38:41.159 --> 00:38:45.089
of performance behind the scenes with Core Data.

00:38:46.869 --> 00:38:58.809
Moving on to working with UIKit, now Core Data deals
primarily with the backend part of your application.

00:38:58.809 --> 00:39:04.299
We're helping you manage your data
and persist it into a file.

00:39:04.300 --> 00:39:09.830
So what do you do when you want to
display those objects in your UI?

00:39:09.829 --> 00:39:19.349
Core Data does not provide to you any UI classes that
belong to the UIKit but since these are regular objects,

00:39:19.349 --> 00:39:24.139
regular Objective-C objects, you can use any
standard UIKit class to display your objects.

00:39:24.139 --> 00:39:28.139
So don't think of Core Data objects as any different
than whatever objects you're already dealing

00:39:28.139 --> 00:39:30.920
with when you're displaying your data on the iPhone.

00:39:30.920 --> 00:39:34.389
They're simply compatible with only the UIKit classes.

00:39:34.389 --> 00:39:39.089
There are two things to keep in mind here to your advantage.

00:39:39.090 --> 00:39:45.720
ManagedObjects implement key value of
serving and ManagedObjectContexts send

00:39:45.719 --> 00:39:52.919
out notifications each time certain events happen so
your application could register to listen to these things

00:39:52.920 --> 00:39:59.110
as they happen so that you know
when your UI has to be updated.

00:39:59.110 --> 00:40:04.849
So you begin to observe an object or you register
for notifications on the ManagedObjectContext

00:40:04.849 --> 00:40:11.269
and if something happens that updates your data and you
want to be notified that your UI has to be refreshed,

00:40:11.269 --> 00:40:18.900
you will get that notification and that could
be the trigger point for the updating of the UI.

00:40:18.900 --> 00:40:25.639
There is one UIKit class that we do give you a little
bit more help with and this is the UITableView,

00:40:25.639 --> 00:40:32.609
which is good because UITableView is probably
the most used UIKit class in iPhone development.

00:40:32.610 --> 00:40:40.720
UITableView displays a list of data broken up into sections.

00:40:40.719 --> 00:40:51.459
And if you have used this object before you'll know
that the main thing the UITableView keeps asking you

00:40:51.460 --> 00:40:55.829
to provide is it keeps asking you, how
many sections do you have in your data

00:40:55.829 --> 00:40:58.909
and how many objects are in each one of those sections?

00:40:58.909 --> 00:41:05.889
Well we already know how to get a list of data
for you because that is a fetch request, right?

00:41:05.889 --> 00:41:07.359
You can indicate a fetch request.

00:41:07.360 --> 00:41:08.960
We get a list of data.

00:41:08.960 --> 00:41:16.449
So we added this new helper class in
iPhone OS, it's not present on the desktop,

00:41:16.449 --> 00:41:23.689
it's called NSFetchedResultsController and it's
meant to be a helper instance for your UITableView

00:41:23.690 --> 00:41:25.720
and data source methods so that we can quickly

00:41:25.719 --> 00:41:32.489
and efficiently help you answer those
questions that the UITableView is requesting.

00:41:32.489 --> 00:41:36.939
We talked about fetch request, fetch request
indicate a predicate and a sort descriptor.

00:41:36.940 --> 00:41:41.179
When you execute a fetch request you're
basically getting back a list of data

00:41:41.179 --> 00:41:44.500
so that's already half of what UITableView is asking for.

00:41:44.500 --> 00:41:53.500
There's your data, the only one extra piece of information
we need from you is you need to tell us what the keypath is.

00:41:53.500 --> 00:41:58.550
Basically what is the name of the
property on your objects that we can query

00:41:58.550 --> 00:42:02.610
so that we know what section that object belongs to?

00:42:02.610 --> 00:42:08.240
If we have this simple piece of information
we are able to traverse your data

00:42:08.239 --> 00:42:10.250
and collect all the section information for you.

00:42:10.250 --> 00:42:15.190
Basically count all of your objects and break
them up into sections and then once we have

00:42:15.190 --> 00:42:23.059
that information you can provide it to UITableView but more
importantly we not only compute this information we cache it

00:42:23.059 --> 00:42:29.340
in a little private file so that the next time your
application launches you can quickly answer the questions

00:42:29.340 --> 00:42:36.110
of how many objects are in your TableView, how
many sections, by using a fetchResultsController.

00:42:37.869 --> 00:42:43.230
So FetchResultsController is meant to be used
when you want to cache section information.

00:42:43.230 --> 00:42:47.909
When the description and the definition of what
your sections are isn't changing very often.

00:42:47.909 --> 00:42:54.159
So we assume that your FetchRequest and your
predicate from this point of view are immutable things.

00:42:54.159 --> 00:43:02.259
If you're constantly changing the predicate that you're
using to filter your information through or the elements,

00:43:02.260 --> 00:43:09.920
the entity that you're fetching on, you're
probably not going to be getting the cache results

00:43:09.920 --> 00:43:14.180
of FetchResultsController because we
still have to walk your data once,

00:43:14.179 --> 00:43:16.960
the first time around to calculate the section information.

00:43:16.960 --> 00:43:21.599
So as long as you want to keep working
with that data, we're able to help you out.

00:43:21.599 --> 00:43:24.519
Oh and by the way, we do register for notification.

00:43:24.519 --> 00:43:33.599
So as you modify your data set, we do update your session
and information so that it's ready to use later on.

00:43:33.599 --> 00:43:43.610
Let me go to the second demo so that you get a
better idea of how a FetchResultsController is used.

00:43:43.610 --> 00:43:47.090
So here's a pre-built application.

00:43:47.090 --> 00:43:54.850
Let me first show you what it does, let me hide this.

00:43:54.849 --> 00:44:05.860
This is a simple application that goes out, connects to
the Internet and parses the iTunes RSS feed of top songs.

00:44:05.860 --> 00:44:12.980
So Core Data does not parse feed RSS feeds out on the
Internet so that part of the application is not Core Data

00:44:12.980 --> 00:44:20.519
but when it does the parsing, it imports all of that data
into a local store file so that you can access those objects

00:44:20.519 --> 00:44:22.869
when you don't have an Internet connection.

00:44:22.869 --> 00:44:24.089
That part is Core Data.

00:44:24.090 --> 00:44:30.300
So we basically create a Core Data store
and then we used that do display the UI.

00:44:30.300 --> 00:44:34.650
Once we displayed the UI we can
display the songs in two ways.

00:44:34.650 --> 00:44:43.190
Here we sort them simply by rank so here are the top 3
songs, the top 300 songs sorted by rank in a TableView

00:44:43.190 --> 00:44:51.990
with one single section or we can break them up into
sections by the name of the category that the song belongs

00:44:51.989 --> 00:45:00.029
to so Jazz, Holiday and whatever
other categories we have, Hip Hop.

00:45:00.030 --> 00:45:05.930
So in these two cases we're using two
FetchResultsControllers to help us out,

00:45:05.929 --> 00:45:12.319
one of them is configured in a single section mode and the
other is configured in a multi-section mode and I'm going

00:45:12.320 --> 00:45:15.100
to show you the code of how that is done.

00:45:15.099 --> 00:45:21.360
Let me just run this here again.

00:45:21.360 --> 00:45:26.750
So again I'd like to highlight here that
this is an application that uses Core Data.

00:45:26.750 --> 00:45:32.130
Parts of the application, like in many
applications, have nothing to do with Core Data.

00:45:32.130 --> 00:45:37.800
They have to do with parsing fees and displaying data
on the UI but in parts of the application you're relying

00:45:37.800 --> 00:45:41.490
on Core Data to help you out with a data persistency part.

00:45:41.489 --> 00:45:46.659
So if it's an application that
uses Core Data, let's just review.

00:45:46.659 --> 00:45:49.170
We probably have methods to set up the stack.

00:45:49.170 --> 00:45:52.420
So here we have the method to create
the ManagedObjectsContext

00:45:52.420 --> 00:45:54.750
and to set up the PersistantStoreCoordinator.

00:45:54.750 --> 00:45:55.920
I'm not going to go into those.

00:45:55.920 --> 00:45:59.269
I showed them in the first example but
they have to set up the stack, right?

00:45:59.269 --> 00:46:04.329
If this is an application that uses Core
Data then you'll probably have a model.

00:46:04.329 --> 00:46:08.650
Here is your model, songs and categories.

00:46:11.769 --> 00:46:19.190
When your application sets up the Core
Data stack, the first thing it does is

00:46:19.190 --> 00:46:24.809
that it creates this secondary
class here, iTunes RSS importer.

00:46:24.809 --> 00:46:34.289
This is the code path that takes care of parsing the
RSS feeds and creating a Core Data store for that data.

00:46:34.289 --> 00:46:45.710
So within that class, let's just quickly jump into that
class, most of this code has nothing to do with Core Data.

00:46:45.710 --> 00:46:51.510
I just want to highlight there's a little part
in that code where you are creating instances

00:46:51.510 --> 00:46:53.930
of songs as you're parsing them from the feed.

00:46:53.929 --> 00:47:00.299
So this is kind of the Core Data part where you're creating
a song, your associating it with an entity and a context.

00:47:00.300 --> 00:47:06.500
There's other methods in this class where
you're actually setting state on the song.

00:47:06.500 --> 00:47:15.539
And finally this is the part of the
application that is displaying the UITableView.

00:47:15.539 --> 00:47:18.340
Again, most of this has nothing to do with Core Data.

00:47:18.340 --> 00:47:20.510
It's simply UIKit code.

00:47:20.510 --> 00:47:26.060
It implements the delegate and the
data source method for TableViews.

00:47:26.059 --> 00:47:33.920
But in these methods when you're trying to answer
the questions, how many sections are in your data,

00:47:33.920 --> 00:47:42.360
in your TableView, you are using this helper instance
FetchResultsController, you're asking it to give it to you

00:47:42.360 --> 00:47:45.420
in sections and then you're giving
the count of that section.

00:47:45.420 --> 00:47:50.789
So you are quickly able to answer the
question, how many sections are in my data set

00:47:50.789 --> 00:47:57.789
by asking the FetchResultsController and likewise
you're able to figure out how many objects are in each 1

00:47:57.789 --> 00:48:01.679
of those sections by also using the FetchResultsController.

00:48:01.679 --> 00:48:05.029
So let's see how we can figure that FetchResultsController.

00:48:05.030 --> 00:48:11.060
We said that a FetchResultsController
required a FetchRequest.

00:48:11.059 --> 00:48:11.929
Here we are.

00:48:11.929 --> 00:48:13.879
We create a FetchRequest.

00:48:13.880 --> 00:48:18.720
A FetchRequest requires an entity, we give it a song.

00:48:18.719 --> 00:48:24.469
In both cases, in both kinds of sorting, we're
always displaying songs and the only thing

00:48:24.469 --> 00:48:33.969
that differentiates these two instances is in this
case I'm sorting by rank and I don't have any sections

00:48:33.969 --> 00:48:39.149
and in this case I'm sorting by categories and the
sections are broken up by the name of the category.

00:48:39.150 --> 00:48:46.309
So here we initialize instant nil and we have an IF
statement depending on which case we're configuring.

00:48:46.309 --> 00:48:51.389
Here we're configuring the case where we're
sorting by category so we create sort descriptors

00:48:51.389 --> 00:48:55.440
where the primary sort is on category
name, the secondary sort is on rank

00:48:55.440 --> 00:49:00.150
and the section named keypath is the category dot name.

00:49:00.150 --> 00:49:05.910
So basically for each song that we get back from the
database, we ask its category and then we ask the name

00:49:05.909 --> 00:49:10.069
of that category and that's how we
can tell what section they belong to.

00:49:10.070 --> 00:49:16.080
In the other case where we're simply sorting by
rank, the sort descriptor is a rank, is by rank.

00:49:16.079 --> 00:49:20.750
Once we have that set up, we create the
instance of the FetchResultsController,

00:49:20.750 --> 00:49:26.460
we pass it the FetchRequest we configured,
the context and the section named keypath.

00:49:26.460 --> 00:49:34.150
So this is all you have to do to set up the fetch and
there's a method where you tell us to do the fetching

00:49:34.150 --> 00:49:40.880
but then from that point on all of your data has been
fetched and broken up into sections and you can use

00:49:40.880 --> 00:49:45.200
that helper method to quickly help
you populate your UITableView.

00:49:45.199 --> 00:49:55.659
So that was an example of how you get the
benefits of using a FetchResultsController.

00:49:55.659 --> 00:50:03.199
Now you might be asking yourselves, ok this is great
technology but what's the catch, where's the cost?

00:50:03.199 --> 00:50:08.869
You're doing all this stuff for us
behind the scenes, what's the penalty?

00:50:08.869 --> 00:50:15.289
Well we wondered that ourselves when we were doing the
port to iPhone so one of the first things we did was

00:50:15.289 --> 00:50:25.349
to create a sample application that managed generic record
data and we measured the launch time of this application

00:50:25.349 --> 00:50:28.219
when it has 10,000 records in its database.

00:50:28.219 --> 00:50:31.569
And we created multiple versions of the application.

00:50:31.570 --> 00:50:39.080
The first version of the application we created
was very general SQL code, not Core Data.

00:50:39.079 --> 00:50:45.429
This is how you would be writing the application
in iPhone OS 2.0, before Core Data existed.

00:50:45.429 --> 00:50:49.259
And we measured that it launched in five seconds.

00:50:49.260 --> 00:50:57.720
So then we ported the application to Core Data on the iPhone
to see how that would compare and we launched 30 % faster

00:50:57.719 --> 00:51:04.909
in 3.5 seconds because we now start taking advantage of
Core Data faulting and partial fetching of your data.

00:51:04.909 --> 00:51:06.529
Not only that, we kept going.

00:51:06.530 --> 00:51:13.830
We added one line of code to do batch
fetching and we're now launching 80% faster.

00:51:13.829 --> 00:51:18.679
So I can tell you that when it
comes to speed there is no penalty

00:51:18.679 --> 00:51:26.889
when we're using Core Data compared
to a very generic SQL solution.

00:51:26.889 --> 00:51:32.960
Memory, what happens with the same
application with its active heap size?

00:51:32.960 --> 00:51:39.309
The SQL application has 1800 kilobytes.

00:51:39.309 --> 00:51:43.840
Core Data did not grow more than the SQL
application even though we're dealing with objects

00:51:43.840 --> 00:51:46.690
where we're wrapping all of your rows in your objects.

00:51:46.690 --> 00:51:47.639
We have the context.

00:51:47.639 --> 00:51:52.000
You're not taking a hit on your memory.

00:51:52.000 --> 00:51:55.920
And when we enable the fetching, remember that slide

00:51:55.920 --> 00:51:59.820
where I show you how batches were disappearing
behind the scenes when you weren't using them?

00:51:59.820 --> 00:52:06.240
We got a 50% improvement in memory use with 1 line of code.

00:52:06.239 --> 00:52:13.689
Speaking of lines with code, we do a
lot less database guard work right?

00:52:13.690 --> 00:52:18.070
So you have a lot of code in your SQL
application in addition to your UI display code,

00:52:18.070 --> 00:52:23.180
simply dealing with pulling in that data
and wrapping it into objects or dictionaries

00:52:23.179 --> 00:52:27.989
or however you want to deal with them in memory.

00:52:27.989 --> 00:52:33.250
With Core Data we cut our code in
half because we do all that for you.

00:52:33.250 --> 00:52:35.190
The framework takes care of that.

00:52:35.190 --> 00:52:41.400
You saw how we were able to set up the Core Data stack with
four or five lines of code and you're using simple accesses

00:52:41.400 --> 00:52:49.300
on your objects to message your data so we got rid of
a lot of code that was dealing with the backend part.

00:52:50.360 --> 00:53:00.390
When we enable fetching [laughter] our code size grew by
one line so yes we did take a hit of 1 line but you saw

00:53:00.389 --> 00:53:07.529
in the previous slides the huge performance impact
that you get by enabling all of the flags that we have

00:53:07.530 --> 00:53:13.220
in your FetchRequest as you start adopting
to your data set and how you're using it.

00:53:14.369 --> 00:53:21.710
So there's a lot more to talk about Core Data and I
encourage you to go to tomorrows session to learn more

00:53:21.710 --> 00:53:30.150
about the technology and what's new in 3.0 but I do want
to highlight a couple of points here before leaving you.

00:53:30.150 --> 00:53:33.829
One is, well what do you do with your preexisting data?

00:53:33.829 --> 00:53:40.019
You already have your database in
some format, a PLIST or SQL database.

00:53:40.019 --> 00:53:44.679
Remember that Core Data owns the store
file both for creation and maintenance.

00:53:44.679 --> 00:53:53.719
So we, even though behind the scenes the file might
be SQL, the implementation is private to you guys

00:53:53.719 --> 00:54:00.259
so we don't want you to go behind the
scenes and update the SQL yourself, ok?

00:54:00.260 --> 00:54:03.200
So please don't touch the Core Data file.

00:54:03.199 --> 00:54:06.819
Always use it from Core Data's APIs downward.

00:54:06.820 --> 00:54:15.280
So what we ask that you do if you have a
preexisting data set, is that you add an import step

00:54:15.280 --> 00:54:21.420
so that you can parse your data and create a Core Data
store and save the context and then from that point

00:54:21.420 --> 00:54:29.159
on you have your data in Core Data format and
then we can help you better interact with it.

00:54:29.159 --> 00:54:35.159
There's a good part of the documentation, the
Core Data programming guide explains to you how

00:54:35.159 --> 00:54:43.799
to do efficient importing, especially if you have
large datasets and we actually have a lab on Thursday

00:54:43.800 --> 00:54:49.260
that walks you through how to do importing
from a generic SQL database into Core Data.

00:54:49.260 --> 00:54:55.530
So Tuesday at noon if you want to look at that
we have sample projects set up on a little thing

00:54:55.530 --> 00:54:58.920
that you can spend time experimenting with.

00:55:00.179 --> 00:55:07.149
The second thing that I want to highlight because
you're going to run into this very quickly,

00:55:07.150 --> 00:55:10.000
you saw how in that first demo
how I launched the application?

00:55:10.000 --> 00:55:15.809
I created a little bit of time stamps and then I quit
the app and there was already data in the database,

00:55:15.809 --> 00:55:22.279
in the store file and then the next thing
I did was I started modifying the model.

00:55:22.280 --> 00:55:30.940
If you try to follow at home, after you modify the model and
you launch the application again you will get a launch error

00:55:30.940 --> 00:55:37.829
and what's going on there is that you have preexisting
data in your database and you change the model.

00:55:37.829 --> 00:55:40.009
So you break the contract.

00:55:40.010 --> 00:55:43.640
We're not allowed to open your database because
we don't really know the structure of that data

00:55:43.639 --> 00:55:47.170
when you have given us an updated version of your model.

00:55:47.170 --> 00:55:53.659
So just be aware that if you open a store with
an incompatible model, you will get an error.

00:55:53.659 --> 00:55:55.859
How do you know you're getting an error?

00:55:55.860 --> 00:56:02.309
In step 3 of setting up the Core Data stack where
you're adding the persistent store to your coordinator,

00:56:02.309 --> 00:56:10.750
that call can return false or no and when you print
out the error and you see something like this,

00:56:10.750 --> 00:56:13.400
the model used to open the store
is incompatible with the one used

00:56:13.400 --> 00:56:16.480
to create it, you know that you're in this situation.

00:56:16.480 --> 00:56:22.199
You're basically pointing us to a model, you're giving
us a model that is not the same one that you use

00:56:22.199 --> 00:56:28.629
to create the store that you have on your file but
don't despair, there's ways of working around this.

00:56:28.630 --> 00:56:36.119
I just want you to know that this is what's happening
if your application is not launching the second time.

00:56:36.119 --> 00:56:39.739
So what do you do once you're in contact this error?

00:56:39.739 --> 00:56:43.519
First be aware that if you're working with
throw away code you're simply experimenting.

00:56:43.519 --> 00:56:48.639
The easiest way for you to work around this error is to
simply get rid of that store and relaunch the application.

00:56:48.639 --> 00:56:50.129
You don't care about that data

00:56:50.130 --> 00:56:51.590
How do you get rid of the store?

00:56:51.590 --> 00:56:54.650
In the iPhone you can just delete the whole application

00:56:54.650 --> 00:56:59.550
and then the next time you launch it,
it will create the store from scratch.

00:56:59.550 --> 00:57:07.670
Or you can go into your iPhone simulator preferences
or documents directory and delete the store there.

00:57:07.670 --> 00:57:12.849
So the throw away data, just get rid of it and
launch again as you experiment with Core Data

00:57:12.849 --> 00:57:15.429
but of course this is not a scalable solution.

00:57:15.429 --> 00:57:21.919
At some point you're going to have data that
you care about, we again help you there.

00:57:21.920 --> 00:57:25.789
We have ways of migrating your data, we have two ways.

00:57:25.789 --> 00:57:31.440
We have another kind of model file
that you also edit in Xcode.

00:57:31.440 --> 00:57:37.240
It's a Core Data mapping model where you tell us
how to get from version A to version B of your data

00:57:37.239 --> 00:57:42.029
and then we have a very sophisticated migration
infrastructure that basically opens up your store

00:57:42.030 --> 00:57:45.570
and moves all of your data over
and saves it in the new format.

00:57:45.570 --> 00:57:52.610
And in Snow Leopard and also available on the phone, we have
a new kind of migration which we call lightweight migration

00:57:52.610 --> 00:57:57.380
where we try to be smart about figuring out
that your data changed for certain kinds

00:57:57.380 --> 00:57:59.920
of changes and we do the migration for you.

00:57:59.920 --> 00:58:03.599
So there is help there.

00:58:04.670 --> 00:58:12.730
Please check the Core Data migration
guide to learn more about that.

00:58:12.730 --> 00:58:20.619
Another thing is I've been showing you this Core Data
stack, we have a store and a coordinator and a context.

00:58:20.619 --> 00:58:23.519
It's not the only way that you can set up the stack.

00:58:23.519 --> 00:58:26.090
Core Data's are very flexible technology.

00:58:26.090 --> 00:58:28.630
You could have multiple stores behind the scenes.

00:58:28.630 --> 00:58:30.559
You could be pointing to multiple files.

00:58:30.559 --> 00:58:33.650
Some of your files could be read only, look up tables.

00:58:33.650 --> 00:58:38.519
The other 1 could be the 1 where you're actually doing
your edit so that's why it's called a coordinator

00:58:38.519 --> 00:58:42.849
because it's coordinating how ever many
connections you have behind the scenes.

00:58:42.849 --> 00:58:48.710
You can also be doing multiple edits
like a master edit and a detail edit

00:58:48.710 --> 00:58:51.480
so you can have potentially multiple ManagedObjectsContexts

00:58:51.480 --> 00:58:55.719
that you're interacting with and
those 2 things are not related.

00:58:55.719 --> 00:59:00.969
You don't need to have multiple stores to have multiple
contexts so look into the programming guide of Core Data.

00:59:00.969 --> 00:59:06.250
I just want to highlight here that there's many
ways of setting up your Core Data stack depending

00:59:06.250 --> 00:59:11.309
on how sophisticated your application is.

00:59:11.309 --> 00:59:16.869
Finally remember that we are on
our third release of Core Data.

00:59:16.869 --> 00:59:21.369
This is a very mature and stable codebase.

00:59:21.369 --> 00:59:24.420
With regards to the desktop, the
store file formats are the same.

00:59:24.420 --> 00:59:27.409
You can move them from the phone to the desktop.

00:59:27.409 --> 00:59:31.489
On the desktop you have 1 additional
type, you have the XML store type

00:59:31.489 --> 00:59:35.339
which doesn't appear on the iPhone, just be aware of that.

00:59:35.340 --> 00:59:42.430
And on the desktop you also have
another technology, non Core Data,

00:59:42.429 --> 00:59:51.009
called Cocoa Bindings which helps you create the more
sophisticated Cocoa UI's that you require in a desktop stack

00:59:51.010 --> 00:59:57.250
with multi-window and a lot more which is for Windows so
there's Cocoa Bindings and there's an additional store type

00:59:57.250 --> 01:00:01.929
on the desktop but otherwise it's the same technology.

01:00:01.929 --> 01:00:04.519
This is not Core Data lite on the phone or anything.

01:00:04.519 --> 01:00:06.219
This is Core Data.

01:00:06.219 --> 01:00:11.799
So if you have anymore questions
please contact our evangelist,

01:00:11.800 --> 01:00:15.110
Michael Jurewitz and please check out our documentation.

01:00:15.110 --> 01:00:17.370
We have a ton of documentation.

01:00:17.369 --> 01:00:20.539
We have programming guides, examples, tutorials.

01:00:20.539 --> 01:00:27.489
We just posted a whole bunch of new
examples in the developer forums yesterday.

01:00:27.489 --> 01:00:32.769
There's so much in fact that we need a starting
point overview document so if you start out,

01:00:32.769 --> 01:00:38.769
look for the Core Data overview document and it's
a little one or two page document that points you

01:00:38.769 --> 01:00:44.469
to the right direction based on what you want to learn
about Core Data because there's a lot of documentation.
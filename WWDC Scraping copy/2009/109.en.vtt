WEBVTT

00:00:12.810 --> 00:00:17.990
>> Welcome to Pasteboards, Services,
and Interoperability on Mac.

00:00:17.989 --> 00:00:21.949
My name is James Dempsey, I'm an
engineer on the Cocoa Frameworks Team,

00:00:21.949 --> 00:00:25.050
and Application Interoperability on Mac OS X.

00:00:25.050 --> 00:00:30.670
Two of the heavy hitters of Application
Interoperability are Pasteboards and Services.

00:00:30.670 --> 00:00:34.200
So that's what we're going to be
focusing our attention this afternoon.

00:00:34.200 --> 00:00:37.650
So, Pasteboards and Services.

00:00:37.649 --> 00:00:43.909
Pasteboards really provide the foundation for
transferring data between applications on Mac OS X,

00:00:43.909 --> 00:00:51.309
and then Services build upon this foundation to
allow an application to provide functionality

00:00:51.310 --> 00:00:57.090
that can be taken advantage of by any
of the other applications on the system.

00:00:57.090 --> 00:01:00.380
Now, Pasteboards and Services aren't new.

00:01:00.380 --> 00:01:07.620
They've been around since 10.0, and
earlier, and some of you remember--

00:01:07.620 --> 00:01:13.060
and, but another thing they have
in common is that both Pasteboards

00:01:13.060 --> 00:01:18.530
and Services have had significant
enhancements made in Snow Leopard.

00:01:18.530 --> 00:01:21.210
And that's what we're going to be talking about today.

00:01:21.209 --> 00:01:24.539
What's new with NSPasteboard and Services in Snow Leopard?

00:01:24.540 --> 00:01:29.530
We'll first start out by going through the
new NSPasteboard APIs and how to use them,

00:01:29.530 --> 00:01:35.750
and then my colleague Peter Ammon will talk about
how to provide and consume Services in Snow Leopard.

00:01:35.750 --> 00:01:37.489
All right.

00:01:37.489 --> 00:01:41.030
Now this is marked as an expert talk.

00:01:41.030 --> 00:01:46.060
We're expecting that you have some familiarity
with those topics, but even if you don't,

00:01:46.060 --> 00:01:52.269
I think that through the context of the presentation, you
should be able to pick up a lot if you just stay seated.

00:01:52.269 --> 00:01:58.319
And with that, let's jump in and
start talking about NSPasteboard item.

00:01:58.319 --> 00:02:05.649
So the Pasteboard really is the foundation for a lot of
just fundamental user experience features on the Mac.

00:02:05.650 --> 00:02:09.420
So fundamental that we forget we're
even using the feature anymore.

00:02:09.419 --> 00:02:11.809
Things like copy and paste and drag and drop.

00:02:11.810 --> 00:02:17.219
And of course, System Services also rely on the Pasteboard.

00:02:17.219 --> 00:02:24.810
And really the purpose of NSPasteboard is to allow for a
very simple way, pretty straightforward way of sharing data

00:02:24.810 --> 00:02:29.460
between applications or within an application.

00:02:29.460 --> 00:02:36.810
Now, before we jump in to the new Snow Leopard stuff,
let's just do a very brief review of NSPasteboard

00:02:36.810 --> 00:02:44.219
and how it has behaved since 10.0 and since
as far as we can tell the beginning of time.

00:02:44.219 --> 00:02:51.099
So, NSPasteboard is kind of a cross-process
dictionary-like structure.

00:02:51.099 --> 00:02:58.549
I kind of whimsically like to think of it as a magical
dictionary that you get a hold of it in one process,

00:02:58.550 --> 00:03:05.700
you instantiate it by name, and then you can set data
for various types and add different data representations.

00:03:05.699 --> 00:03:09.549
So it's dictionary-like because
the data is keyed by its type.

00:03:09.550 --> 00:03:15.370
And then in another process, you can ask for that same
Pasteboard name, you get an NSPasteboard instance,

00:03:15.370 --> 00:03:22.030
and then the data representations put on over here are
available in another process, and you retrieve them again

00:03:22.030 --> 00:03:26.340
by type, by getting the data for particular types.

00:03:26.340 --> 00:03:32.140
Now, one way that it's not dictionary-like
is that the order of those types,

00:03:32.139 --> 00:03:36.679
those data representations is actually has some meaning.

00:03:36.680 --> 00:03:41.750
In our example up here, we might have some rich
text, some formatted text on the Pasteboard,

00:03:41.750 --> 00:03:47.250
and we're using the RTF format so
that the richest representation

00:03:47.250 --> 00:03:50.960
of the data we're putting on the Pasteboard is always first.

00:03:50.960 --> 00:03:57.090
And then we might provide additional types, in this
case, we're also providing some plain string data

00:03:57.090 --> 00:04:00.360
for an app link maybe terminal
that doesn't deal in rich text.

00:04:00.360 --> 00:04:06.780
So the first type is always the richest and
then the following types are either less rich

00:04:06.780 --> 00:04:09.740
or perhaps a translation of the original type.

00:04:09.740 --> 00:04:17.430
So that's kind of the NSPasteboard in the nutshell
as we've known and loved it for many years now.

00:04:17.430 --> 00:04:19.280
So what have we done in Snow Leopard?

00:04:19.279 --> 00:04:26.479
Well, probably the largest thing that we've done is
we've added support for multiple Pasteboard items.

00:04:26.480 --> 00:04:35.720
So as before in my whimsical mind, it was a magical
dictionary, we now have a magical array of dictionaries.

00:04:35.720 --> 00:04:44.430
So each of those items is conceptually very similar to
what we have thought off for years as the Pasteboard.

00:04:44.430 --> 00:04:51.750
So multiple items, each item can contain multiple data
representations, and again, the order is still important.

00:04:51.750 --> 00:04:58.069
The second thing we've done is even though we've added new
functionality to the Pasteboard, but also we've been looking

00:04:58.069 --> 00:05:02.219
at ways to make it easier to do
common Pasteboard operations.

00:05:02.220 --> 00:05:09.730
And so, we've shifted the focus from always dealing
nitty-gritty of each individual type to be able to work more

00:05:09.730 --> 00:05:17.870
at the class level, and perhaps read and write things
like NSColors and NSURLs directly on the Pasteboard.

00:05:17.870 --> 00:05:25.920
And then finally, we're taking the opportunity of these
other changes to also move away from the pboard types

00:05:25.920 --> 00:05:35.930
and move to uniform type identifiers, which is a
very rich typing system in Mac OS X, and actually,

00:05:35.930 --> 00:05:39.720
that will change those pboard types
to UTIs on the Pasteboard.

00:05:39.720 --> 00:05:47.410
So that's kind of a summary of the high level
changes we've made to the Pasteboard in Snow Leopard.

00:05:47.410 --> 00:05:53.810
So-- but there's a lot of stuff in NSPasteboard
that we really like, things we wanted to preserve.

00:05:53.810 --> 00:06:01.280
So briefly to mention those, although we can work at this
class level, we still want to preserve this ability to get

00:06:01.279 --> 00:06:07.439
in there to the nitty-gritty and get and
set every piece of data on every item.

00:06:07.439 --> 00:06:13.089
NSPasteboard has always had these great convenience
methods where instead of just setting and getting data

00:06:13.089 --> 00:06:17.629
for a particular type, you could get
and set strings and property lists.

00:06:17.629 --> 00:06:22.120
And the Pasteboard would automatically
serialize and deserialize for you.

00:06:22.120 --> 00:06:25.250
We've wanted to preserve those as well.

00:06:25.250 --> 00:06:31.740
And finally, the ability to provide data lazily,
to promise to provide data at a later time

00:06:31.740 --> 00:06:37.300
and not necessarily do every expensive
translation of types right upfront.

00:06:37.300 --> 00:06:42.329
So those things to preserve will be
common threads as we look at the new API.

00:06:42.329 --> 00:06:48.389
OK, that all said, let's look at the
new way of doing things in NSPasteboard.

00:06:48.389 --> 00:06:50.000
Let's look at writing.

00:06:50.000 --> 00:06:55.819
So, in our example here, we have
not 1, but 3 NSURLs and what we'd

00:06:55.819 --> 00:07:01.099
like to do is have 1 item show up
on the Pasteboard for every NSURL.

00:07:01.100 --> 00:07:07.550
In Snow Leopard, we do something like this, we get a hold
of a Pasteboard, of course it has what was previously

00:07:07.550 --> 00:07:14.500
on the Pasteboard, so clear the contents from what was
previously there, and then we take that array of URLs

00:07:14.500 --> 00:07:18.529
and we simply tell the Pasteboard to write these objects.

00:07:18.529 --> 00:07:25.059
And when we do that, the Pasteboard will end
up with 1 item per object that we handed it,

00:07:25.060 --> 00:07:29.620
and that item will have the appropriate
types and data on it.

00:07:29.620 --> 00:07:34.920
Now, how does the Pasteboard know what types of
data are appropriate for a particular object?

00:07:34.920 --> 00:07:41.790
Well, NSURL implements a brand new protocol
in Snow Leopard called NSPasteboardWriting.

00:07:41.790 --> 00:07:50.340
And this protocol is implemented by NSURL as well as
many common Cocoa classes, and we'll see in a little bit,

00:07:50.339 --> 00:07:54.899
it's a public protocol so your
objects can play along as well.

00:07:54.899 --> 00:07:58.239
So what does this operation look like in code?

00:07:58.240 --> 00:07:59.590
Something like this.

00:07:59.589 --> 00:08:07.669
So we have an array of URLs, and we get ahold of a
Pasteboard that hasn't changed at all in Snow Leopard.

00:08:07.670 --> 00:08:11.360
We clear the contents and then we write the objects.

00:08:11.360 --> 00:08:16.259
We hand in that array of objects
that implement NSPasteboardWriting.

00:08:16.259 --> 00:08:22.019
And I don't know if we could have
shortened it anymore than that.

00:08:22.019 --> 00:08:29.079
Now, I mentioned other Cocoa classes implement this
as well, so we can write URLs to the Pasteboard,

00:08:29.079 --> 00:08:33.809
but if you now do the same with
attributed strings for rich text data.

00:08:33.809 --> 00:08:36.619
Here, we're just putting one item on, so we're throwing it

00:08:36.620 --> 00:08:47.649
into an array before we write the objects,
NSImage, NSColor, NSString, and NSSound.

00:08:47.649 --> 00:08:53.029
So for all of the common Cocoa classes that
you're typically putting on the Pasteboard

00:08:53.029 --> 00:08:57.559
or reading off the Pasteboard,
writing is very straightforward.

00:08:58.570 --> 00:09:01.440
Now, how do your objects play along?

00:09:01.440 --> 00:09:08.500
Well, that's the NSPasterboardWriting protocol, 3
methods to implement, writable types for Pasteboard.

00:09:08.500 --> 00:09:15.600
In that method, you return an array of UTIs of the types
your object is willing to provide to the Pasteboard.

00:09:15.600 --> 00:09:19.850
And again the order of that array is
important, the richest type should be first.

00:09:19.850 --> 00:09:26.970
Pasteboard property list for type is where you can ask
for a type and you return the appropriate information

00:09:26.970 --> 00:09:33.410
that should be on the Pasteboard, but you'll notice
its property list for type, not data for type.

00:09:33.409 --> 00:09:35.299
What's up with that?

00:09:35.299 --> 00:09:41.359
Well, if you give us back an NSData, if you return
an NSData that's certainly a property list type

00:09:41.360 --> 00:09:44.810
of object, we're going to use that data as is.

00:09:44.809 --> 00:09:52.049
However, if you return an NSString or any other property
list object, it says if you had called setDataForType,

00:09:52.049 --> 00:10:00.750
or setPropertyListForType in the old API, and we'll
automatically do the appropriate serialization to an NSData.

00:10:00.750 --> 00:10:06.200
And those are the only 2 methods that you have
to implement, the only 2 that are required.

00:10:06.200 --> 00:10:10.140
You can also specify some writing options for each type.

00:10:10.139 --> 00:10:17.519
And in Snow Leopard, there's only one writing option
and it has to do with promising to provide a type.

00:10:17.519 --> 00:10:24.350
>> So by default, that array of types that you
hand back, we'll write the first type immediately,

00:10:24.350 --> 00:10:27.620
and we'll just promise to write the additional types.

00:10:27.620 --> 00:10:34.139
If you want to change that default behavior,
implement writingOptionsForTypePasteboard

00:10:34.139 --> 00:10:40.669
and return the NSPasteboardWritingPromised option,
which means in this type, we're not going to,

00:10:40.669 --> 00:10:47.289
the Pasteboard shouldn't grab it right away, it should
promise to provide it later or no option at all, just zero.

00:10:47.289 --> 00:10:53.490
Note that an object that is promising types and
written to the Pasteboard is retained by the Pasteboard

00:10:53.490 --> 00:10:57.549
because the Pasteboard needs to
fulfill that promise later potentially.

00:10:57.549 --> 00:11:05.099
So if you're passing an immutable object, you may
want to copy it before writing it to the Pasteboard.

00:11:05.100 --> 00:11:07.870
And that sums up writing.

00:11:07.870 --> 00:11:09.799
Let's talk about reading.

00:11:09.799 --> 00:11:15.029
So let's say we get a hold of this
Pasteboard that we wrote to earlier.

00:11:15.029 --> 00:11:17.629
Now we want to get some NSURLs off of it.

00:11:17.629 --> 00:11:22.330
Well, we ask the Pasteboard, "Do you have any URLs?"

00:11:22.330 --> 00:11:28.270
We'll run through each item if it can construct the URL
out of the types on that item, it will make one for you.

00:11:28.269 --> 00:11:32.600
So in this case, the Pasteboard will
give us back an array of 3 NSURLs.

00:11:32.600 --> 00:11:35.620
So what does that look like?

00:11:35.620 --> 00:11:41.730
Oh, and of course, we had NSPasteboardWriting,
how does the Pasteboard know how to do this?

00:11:41.730 --> 00:11:50.590
NSPasteboardReading, of course, which is implemented by
the same Cocoa classes that implement the writing protocol.

00:11:50.590 --> 00:11:52.480
So in code, how does this work?

00:11:52.480 --> 00:11:59.220
Get hold of the Pasteboard, we create an
array of classes that we're looking for,

00:11:59.220 --> 00:12:05.389
notice it can be more than one, and
then we read objects for classes.

00:12:05.389 --> 00:12:08.500
There's some options we'll talk about in just a bit.

00:12:08.500 --> 00:12:14.419
And so, it's in a fairly straightforward
way you can read multiple items at once.

00:12:14.419 --> 00:12:21.939
And in fact even if there are mixed types on the Pasteboard,
you can read URLs, strings, images, attributed strings,

00:12:21.940 --> 00:12:28.500
all in one method call, if you just hand in
a long enough list of classes as the array.

00:12:28.500 --> 00:12:31.799
So that's writing, and that's reading.

00:12:31.799 --> 00:12:39.519
There's one other very common Pasteboard operation,
which is validating the contents of the Pasteboard.

00:12:39.519 --> 00:12:46.689
So you may have a view and a drag comes in and you need
to know is there anything interesting on the Pasteboard

00:12:46.690 --> 00:12:52.030
that my view is interested in, therefore
I should validate and accept this drop.

00:12:52.029 --> 00:12:58.189
Or is there anything interesting on the Pasteboard,
and therefore I should enable my Paste menu item.

00:12:58.190 --> 00:13:06.600
So we also wanted to make validating,
straightforward and easy, so there's one little change.

00:13:06.600 --> 00:13:12.259
Instead of reading the objects, we just
ask if we can read object for classes.

00:13:12.259 --> 00:13:21.649
Again, get the Pasteboard, first 2 lines are exactly the
same, specify some classes, and then ask if we can read.

00:13:21.649 --> 00:13:28.279
And again, with these 3 lines of code, you can potentially
look for everything that your application is interested

00:13:28.279 --> 00:13:36.350
in without necessarily iterating through all the
Pasteboard items to check in that sort of thing.

00:13:36.350 --> 00:13:44.440
Now, we've had options arguments for the last 2 methods,
it's the same set of options we can pass in for reading

00:13:44.440 --> 00:13:48.300
or validating whether we can read,
let's talk about those now.

00:13:48.299 --> 00:13:54.019
It's an Options Dictionary, and they both
deal with reading NSURLs from the Pasteboard.

00:13:54.019 --> 00:13:56.710
Now it's very common applications.

00:13:56.710 --> 00:14:02.360
Very often you may not be interested in
WebURLs, they may only want local file URLs.

00:14:02.360 --> 00:14:09.060
So in this Options Dictionary, you can say I'm looking
for file URLs only, have an NSNumberBoolean and say, Yes.

00:14:09.059 --> 00:14:16.979
And in this example here, using this Options Dictionary
to read URLs out of those 5 items with URL data,

00:14:16.980 --> 00:14:22.580
we end up with only the 3 NSURLs created that are file URLs.

00:14:22.580 --> 00:14:29.540
And then in addition to just looking for file
URLs, another very common operation is to only want

00:14:29.539 --> 00:14:33.509
to accept, say, image files or text files.

00:14:33.509 --> 00:14:39.990
You're not only interested if there's a URL, but
you want to know about the contents of that URL.

00:14:39.990 --> 00:14:47.490
And so the second key is ContentsConformsToTypes--
is the key.

00:14:47.490 --> 00:14:51.669
The value you provide in the dictionary is an array of UTIs.

00:14:51.669 --> 00:14:57.539
In this case, we're looking for
anything, any UTIs that NSImage supports.

00:14:57.539 --> 00:15:04.899
And in this case, when we do our read, out of
those 5 items, only those that are file URLs

00:15:04.899 --> 00:15:08.939
that are also image files will be returned to us in NSURL.

00:15:08.940 --> 00:15:17.070
Now I've done 2 reading examples, but this works
equally as well with the canRead validation methods.

00:15:17.070 --> 00:15:21.540
And that sums up interacting with
the Pasteboard for reading.

00:15:21.539 --> 00:15:27.069
But again, now, let's look at that
NSPasteboardReading protocol that you can implement

00:15:27.070 --> 00:15:30.490
in your own custom classes and play along.

00:15:30.490 --> 00:15:38.990
Three methods: readableTypesForPasteboard, which is where
you return the array of types that your applicator--

00:15:38.990 --> 00:15:42.100
that that class is able to be created from.

00:15:42.100 --> 00:15:46.149
That type-- that list is usually shorter
than those that you're willing to provide.

00:15:46.149 --> 00:15:52.799
And then initWithPasteboardPropertyListType,
again with the property list, not data,

00:15:52.799 --> 00:15:58.240
because you are able to specify how you
want the data read off of the Pasteboard,

00:15:58.240 --> 00:16:02.950
and you do that by implementing the
readingOptionsForTypePasteboard method.

00:16:02.950 --> 00:16:06.420
And there are 4 reading options in Snow Leopard.

00:16:06.419 --> 00:16:08.599
The first is ReadingAsData.

00:16:08.600 --> 00:16:13.070
This is the default if you don't implement
the optional reading options method,

00:16:13.070 --> 00:16:18.560
and the NSData on the Pasteboard gets
handed into that init method as is.

00:16:18.559 --> 00:16:26.849
Then there's ReadingAsString where we will take the data and
deserialize it to an NSString, and ReadingAsPropertyList,

00:16:26.850 --> 00:16:29.200
where we do the same with the property list.

00:16:29.200 --> 00:16:35.950
And so, this is similar to the property list for type or
string for type methods in the existing NSPasteboard API.

00:16:35.950 --> 00:16:43.879
And there's one more reading option in Snow Leopard,
because it's fairly common in custom model objects

00:16:43.879 --> 00:16:48.279
to implement the NSCoding so you can archive those objects.

00:16:48.279 --> 00:16:52.289
And when folks do this, very often,
they'll take that and they'll also use

00:16:52.289 --> 00:16:57.419
that keyed archive of their object as the Pasteboard type.

00:16:57.419 --> 00:17:05.009
And in this case, well, you already have written
a perfectly good init method initWithCoder,

00:17:05.009 --> 00:17:10.450
so if you specify readingAsKeyedArchive,
you don't even necessarily need

00:17:10.450 --> 00:17:15.600
to implement initWithPasteboardPropertyListType.

00:17:15.599 --> 00:17:19.199
You could just specify that what
you're looking for is a keyed archive

00:17:19.200 --> 00:17:22.410
and we'll call initWithCoder instead automatically.

00:17:22.410 --> 00:17:32.210
We'll just unarchive it from the Pasteboard for you.

00:17:32.210 --> 00:17:35.460
[Applause] I'll say it again.

00:17:35.460 --> 00:17:36.210
[Laughter] OK, excellent.

00:17:36.210 --> 00:17:44.680
So that really sums up, well, that really
does sum up all of the reading and writing API

00:17:44.680 --> 00:17:48.430
in Snow Leopard pertaining to this class level operation.

00:17:48.430 --> 00:17:56.920
So that was 1, 2, 3, 4 methods for writing,
reading, and validating, and then 3--

00:17:56.920 --> 00:18:01.019
and 3 for reading and writing tips
for your own classes to play along,

00:18:01.019 --> 00:18:05.700
so not a lot of new API, but a
heck of a lot new functionality.

00:18:05.700 --> 00:18:09.450
But there is 1, this is going to hose me with that.

00:18:09.450 --> 00:18:16.960
There is one piece that we did not talk about which is I
said we wanted to preserve being able to access things type

00:18:16.960 --> 00:18:20.600
by type, item by item, how do we do that?

00:18:20.599 --> 00:18:23.250
It's not represented in the API we saw already.

00:18:23.250 --> 00:18:29.539
To do this, we've introduced a new class
in Snow Leopard called NSPasteboardItem,

00:18:29.539 --> 00:18:36.819
and its interface is extraordinarily similar
to the existing NSPasteboard single item API.

00:18:36.819 --> 00:18:42.759
And it gives you very fine-grain control over
exactly what types are provided or promised,

00:18:42.759 --> 00:18:50.599
exactly what types you're reading, and it really serves as
this generic wrapper object that could represent any item,

00:18:50.599 --> 00:18:53.169
any things that could be on the Pasteboard.

00:18:53.170 --> 00:18:55.300
So what does that look like?

00:18:55.299 --> 00:19:03.740
If you're NSPasteboard aficionado like I am, I
subscribe to "Pasteboard Aficionado Magazine,"

00:19:03.740 --> 00:19:07.059
it looks exactly the same with one difference.

00:19:07.059 --> 00:19:12.119
We have set data provider for types
instead of setting an owner for types.

00:19:12.119 --> 00:19:18.719
We're getting away from that owner technology or that
owner terminology because data provider, I think,

00:19:18.720 --> 00:19:23.079
better specifies what's going on in this situation.

00:19:23.079 --> 00:19:28.319
Now, when will I use one of these as
opposed to the API we saw previously?

00:19:28.319 --> 00:19:36.649
Well, sometimes, this mapping of a class to a list
of types just isn't what you need in the application.

00:19:36.650 --> 00:19:42.070
Your app may perhaps be dealing with
CGImages which are not Objective-C objects,

00:19:42.069 --> 00:19:50.569
but you still want to pull tiff off the Pasteboard and
create a CGImage or a pull PNG out of a CGImage and put it

00:19:50.569 --> 00:19:54.720
on to the Pasteboard, possibly multiple items worth.

00:19:54.720 --> 00:19:57.730
PasteboardItems are awesome for this sort of thing.

00:19:57.730 --> 00:20:05.410
Another case is you might be a delegate or you might be
subclassing a method where the object you're the delegate

00:20:05.410 --> 00:20:09.130
of are the superclasses that already
done a bunch of work in the Pasteboard,

00:20:09.130 --> 00:20:12.540
and they hand you a Pasteboard
that's already filled out with stuff.

00:20:12.539 --> 00:20:17.039
>> In that case, you very often want to
iterate through each item in the Pasteboard,

00:20:17.039 --> 00:20:22.710
look precisely at what types are there, and
perhaps replace the data for particular types

00:20:22.710 --> 00:20:26.480
or a provider promise data for types of your own.

00:20:26.480 --> 00:20:30.370
NSPasteboard item is extraordinarily
handling that case as well.

00:20:30.369 --> 00:20:35.779
Let's look at a couple of code
samples, they're a little longer.

00:20:35.779 --> 00:20:37.490
We get the Pasteboard.

00:20:37.490 --> 00:20:40.349
In this case, we're going to write
some stuff to the Pasteboard,

00:20:40.349 --> 00:20:44.269
we create an NSPasteboardItem,
and then we fill it full of stuff.

00:20:44.269 --> 00:20:48.980
In this case, we'll set some TIFF
data, we'll promise some PDF data,

00:20:48.980 --> 00:20:54.299
we could actually put as many as we want into an array.

00:20:54.299 --> 00:20:59.579
Once we have that array of Pasteboard items, we do
what we've done many times already in this session,

00:20:59.579 --> 00:21:05.250
clear the contents and write the objects, and
everything we filled out in those Pasteboard items,

00:21:05.250 --> 00:21:09.720
we get one item on the Pasteboard that's an exact match.

00:21:09.720 --> 00:21:15.410
Now the other case where we might be reading stuff from the
Pasteboard, we get hold of a Pasteboard or maybe we get it

00:21:15.410 --> 00:21:18.930
from a delegate method that is called on us.

00:21:18.930 --> 00:21:24.269
We use a convenience method on NSPasteboard that's
new in Snow Leopard to get the Pasteboard items.

00:21:24.269 --> 00:21:27.420
We iterate through them, and in this
case, we're checking if the types

00:21:27.420 --> 00:21:32.930
on a particular item contain the
TIFF Pasteboard type, TIFF data.

00:21:32.930 --> 00:21:36.890
And if so, we're going to promise a PDF translation.

00:21:36.890 --> 00:21:44.850
Again, if you're familiar with NSPasteboards
API, this is almost exactly the same.

00:21:44.849 --> 00:21:50.750
Now just a couple of notes about Pasteboard
items, they're designed to be temporary objects.

00:21:50.750 --> 00:21:56.950
So don't hang on to it because once you write it
to a Pasteboard, or you get one from a Pasteboard,

00:21:56.950 --> 00:21:59.580
that item is now bound to that Pasteboard.

00:21:59.579 --> 00:22:03.990
And in fact, it's also bound to
that particular change count.

00:22:03.990 --> 00:22:09.339
So once somebody else clears the contents, you won't
be reading anything out of that Pasteboard item.

00:22:09.339 --> 00:22:17.619
So holding on to it won't do you much good,
just use it in that method and let them go.

00:22:17.619 --> 00:22:19.289
Excellent.

00:22:19.289 --> 00:22:28.109
And then finally, the final big change in Snow Leopard
is this transition to uniform type identifiers.

00:22:28.109 --> 00:22:36.500
Now, one thing to note is that the new
Pasteboard APIs we've seen are UTI only

00:22:36.500 --> 00:22:41.579
So the existing APIs of NSPasteboard
continue to work with pboard types

00:22:41.579 --> 00:22:45.589
and they also work with UTIs, so they accept both.

00:22:45.589 --> 00:22:51.500
But the new ones, if you handed a pboard type,
you'll get a little log and nothing will happen.

00:22:51.500 --> 00:22:55.059
But it would be pretty obvious something's gone awry.

00:22:55.059 --> 00:22:57.519
We've made moving the UTIs pretty straightforward.

00:22:57.519 --> 00:23:02.129
In most cases, it's a string for
string replacement of constants.

00:23:02.130 --> 00:23:07.290
And another note is that we may be
deprecating pboard types in a future release.

00:23:07.289 --> 00:23:10.930
So it's good to get a jumpstart on moving over.

00:23:10.930 --> 00:23:13.759
Now let's talk about moving over this transition.

00:23:13.759 --> 00:23:19.099
So, all of the commonly used Pasteboard
types have new constants

00:23:19.099 --> 00:23:24.039
in NSPasteboard.h, so string, RTF, TIFF, and the like.

00:23:24.039 --> 00:23:30.509
And then for maybe less commonly used Pasteboard
types, we already have perfectly good constants defined

00:23:30.509 --> 00:23:37.599
in UTCoreTypes.h, the constant that defines
that UTI type, and you would use those.

00:23:37.599 --> 00:23:45.279
And really, the only exception to this switching one
string constant for another is the filename's pboard type.

00:23:45.279 --> 00:23:52.019
In this case, it makes more sense since we've
always been kind of putting multiple filenames

00:23:52.019 --> 00:23:58.900
into a single Pasteboard item, makes more sense
to use the extra room to put one file per item.

00:23:58.900 --> 00:24:07.140
And also, since we're moving away from using string
pads for files to using file references in URLs,

00:24:07.140 --> 00:24:12.340
it makes sense to write file URLs to the
Pasteboard and read them from the Pasteboard.

00:24:12.339 --> 00:24:17.189
Finally, well, if you take a look in NSPasteboard.h,

00:24:17.190 --> 00:24:22.130
details for each type are there, you
just do a string for string mapping.

00:24:22.130 --> 00:24:24.780
Just a couple-- custom types.

00:24:24.779 --> 00:24:31.339
For your own types, if you don't share your type with
anyone else, you just need to declare a new string

00:24:31.339 --> 00:24:37.169
that follows the UTI naming convention,
kind of reverse DNS naming scheme.

00:24:37.170 --> 00:24:43.880
And you don't need to formally declare
the UTI in your Info.plist file.

00:24:43.880 --> 00:24:52.420
However, if you have a pboard type, an existing pboard
type that third parties, some other applications depend on,

00:24:52.420 --> 00:24:59.779
or perhaps even a previous version of your application
depends on, then you will want to declare a new UTI

00:24:59.779 --> 00:25:06.700
and formally declare it in your Info.plist and
then associate it with your old pboard type.

00:25:06.700 --> 00:25:16.410
Now, the AppKit 10.6 release notes have examples of
this, so does the new Pasteboard for 10.6 documentation.

00:25:16.410 --> 00:25:21.990
Two short types about the Pasteboard,
more types are now available.

00:25:21.990 --> 00:25:23.650
The example here is TIFF.

00:25:23.650 --> 00:25:28.630
Used to be the only the bitmap
type that the system would define.

00:25:28.630 --> 00:25:31.030
Now there are dozens of UTIs.

00:25:31.029 --> 00:25:36.990
So if you're only looking for TIFF and somebody
puts PNG on the Pasteboard, you're going to miss it.

00:25:36.990 --> 00:25:42.400
You should be asking for the broadest
set of types that you can deal with.

00:25:42.400 --> 00:25:47.690
NSImage can help you with this, but again,
the new API will take care of this eventually.

00:25:47.690 --> 00:25:50.640
And finally, say this with me 3 times fast.

00:25:50.640 --> 00:25:52.470
Peter put a PICT upon the Pasteboard.

00:25:52.470 --> 00:25:55.690
Deprecated PICTS's a poor Pasteboard type to pick.

00:26:01.380 --> 00:26:05.790
[Laughter] [Applause] I'm only going to say it
once because you know, we're time limited today.

00:26:05.789 --> 00:26:16.250
But the idea of this is, Please
stop putting PICT on the Pasteboard.

00:26:16.250 --> 00:26:17.380
[Applause] It's deprecated.

00:26:17.380 --> 00:26:24.080
It was deprecated in Tiger along with QuickDraw, and it's
completely unavailable, well, it relies on QuickDraw,

00:26:24.079 --> 00:26:27.000
and it's completely unavailable in 64 bit.

00:26:27.000 --> 00:26:33.329
Now, Cocoa and Carbon do a lot to make sure that
older apps that are reading and writing PICT,

00:26:33.329 --> 00:26:41.889
usually 32-bit Carbon apps, are able to get
translated PICT and that we're able to translate

00:26:41.890 --> 00:26:45.230
to a more modern type in your application.

00:26:45.230 --> 00:26:51.230
We've deprecated NSPICTPBoardType in Snow Leopard.

00:26:51.230 --> 00:26:56.309
Hopefully, none of your apps actually will hit that
deprecation, because you've been off of it for a while,

00:26:56.309 --> 00:27:02.289
but if you find some reason why you absolutely have
to put PICT on to the Pasteboard or look for PICT,

00:27:02.289 --> 00:27:05.259
please file a bug, because I think we have all the cases.

00:27:05.259 --> 00:27:08.450
We really want to know why you still need PICT.

00:27:08.450 --> 00:27:11.360
And with that, I will turn it over.

00:27:11.359 --> 00:27:13.649
No? Call to action.

00:27:13.650 --> 00:27:15.820
Of course, we did all these.

00:27:15.819 --> 00:27:17.339
What should you do?

00:27:17.339 --> 00:27:19.480
First, move to UTIs.

00:27:19.480 --> 00:27:25.210
In most cases again, string to string
replacement, move away from file names

00:27:25.210 --> 00:27:29.500
in the FilenamesPboardType using multiple file URLs.

00:27:29.500 --> 00:27:33.309
The only thing is now, we can have
multiple items on the Pasteboard,

00:27:33.309 --> 00:27:39.720
so people are going to start putting multiple items
on the Pasteboard, which means that you should think

00:27:39.720 --> 00:27:44.809
about how your views and how your
application should deal with multiple items.

00:27:44.809 --> 00:27:50.980
Now in some cases, like maybe in NSImageView, which
shows one image, still just finding the first image

00:27:50.980 --> 00:27:54.329
and putting it on to-- using it might be appropriate.

00:27:54.329 --> 00:27:58.039
But maybe in a drawing program if
there are 3 images on the Pasteboard,

00:27:58.039 --> 00:28:03.059
you probably want to paste 3 discrete
images into your drawing document.

00:28:03.059 --> 00:28:04.299
It's different for every app.

00:28:04.299 --> 00:28:06.309
So please give that some thought.

00:28:06.309 --> 00:28:09.779
And finally, just in general, adopt a new API.

00:28:09.779 --> 00:28:14.879
And with that, I will turn it over to my
colleague, Peter Ammon, to talk about Services.

00:28:14.880 --> 00:28:15.300
[ Applause ]

00:28:15.299 --> 00:28:17.960
>> Thank you, James.

00:28:17.960 --> 00:28:19.430
So, the Services menu.

00:28:19.430 --> 00:28:24.100
We'll be doing an overview of what
the Services menu is about.

00:28:24.099 --> 00:28:28.679
I'll tell you what's new about Services in Snow
leopard, and then we'll do a sort of review

00:28:28.680 --> 00:28:30.580
of how you go about advertising this Service.

00:28:30.579 --> 00:28:36.679
So you get into the Services menu, how you provide a
Service, so when the user chooses their Services item,

00:28:36.680 --> 00:28:38.789
how do you actually provide that Service.

00:28:38.789 --> 00:28:44.460
How do you consume a Service so other
Service providers can use-- I'm sorry.

00:28:44.460 --> 00:28:48.130
[Laughter] So that other Service providers can use the--

00:28:48.130 --> 00:28:51.150
you can use Services from other
applications, still what I meant to say.

00:28:51.150 --> 00:28:56.220
And finally, how do you go about debugging Services which
isn't something we've had a good story for in the past,

00:28:56.220 --> 00:28:58.640
but at Snow Leopard there are some ways to debug them.

00:28:58.640 --> 00:29:05.980
And lastly, I'll show you really briefly, a new feature
in Snow Leopard about making a Service for the workflow.

00:29:05.980 --> 00:29:07.230
So, an overview.

00:29:07.230 --> 00:29:10.039
Now, I'm guessing most of you know what I'm talking about.

00:29:10.039 --> 00:29:15.809
But in case you don't, the Services menu is this menu
right here, which is available in every application,

00:29:15.809 --> 00:29:19.190
and has been there since Mac OS X first shipped.

00:29:19.190 --> 00:29:21.920
So why do we have it?

00:29:21.920 --> 00:29:27.360
Well, if you have an application-like image
capture that can take images from a camera,

00:29:27.359 --> 00:29:32.019
you don't want to make the user have to go to your
application every time they want to have an image.

00:29:32.019 --> 00:29:36.210
You wanted to allow them to put the
images in Mail for example or text edit,

00:29:36.210 --> 00:29:39.110
or pages or any application that can accept an image.

00:29:39.109 --> 00:29:41.879
So image capture is a Service provider.

00:29:41.880 --> 00:29:44.710
It provides Services to, for example Mail.

00:29:44.710 --> 00:29:49.019
When that happens, we say Mail is a Service consumer.

00:29:49.019 --> 00:29:55.440
So even though this feature is provided by image capture, it
appears in Mail, and the way this works is by passing data

00:29:55.440 --> 00:30:00.670
between Mail and image capture on a Pasteboard.

00:30:00.670 --> 00:30:05.470
So the result is that any application can
extend the functionality of many others.

00:30:05.470 --> 00:30:07.420
And this isn't my saying.

00:30:07.420 --> 00:30:13.370
This is in fact a line from the NeXTSTEP
Developer documentation 14 years ago.

00:30:14.500 --> 00:30:20.079
[appleause] So something has changed
since then, what's new in Snow Leopard?

00:30:20.079 --> 00:30:25.779
Well, there's no new methods and there's no new classes, but
there are some changes in the way the Services menu looks

00:30:25.779 --> 00:30:30.160
and how you'd go about declaring the
Service in your app's Info.plist.

00:30:30.160 --> 00:30:32.009
And I'd love to show you some of the changes.

00:30:32.009 --> 00:30:39.650
[ Pause ]

00:30:39.650 --> 00:30:43.100
>> My computer went to sleep.

00:30:43.099 --> 00:30:51.429
OK, so here I am in TextEdit, and I'm in a plain text view,
not rich text, and by default, the Services menu is empty.

00:30:51.430 --> 00:30:57.850
[Applause] And that's it, we're done.

00:30:57.849 --> 00:31:02.159
No. [Laughter] In Leopard of course, there'll be a
lot of Services there, but they would all be disabled.

00:31:02.160 --> 00:31:08.320
And in Snow Leopard, we now hide Services
that would otherwise be disabled in Leopard.

00:31:08.319 --> 00:31:10.669
So, well it's not entirely empty, right?

00:31:10.670 --> 00:31:11.950
There's also, there's one menu item.

00:31:11.950 --> 00:31:17.009
There are Services preferences, which are available
all the time, and this will allow users to enable

00:31:17.009 --> 00:31:22.160
or disable Services that they want or don't want,
and also to assign key equivalents to remove them.

00:31:22.160 --> 00:31:33.920
[Applause] All right, so I'm going to switch
to rich text, and I'll make this bigger.

00:31:33.920 --> 00:31:38.440
So now, again, there's nothing selected, but
there's now, there's 2 items in the Services menu.

00:31:38.440 --> 00:31:43.740
There's Capture selection from screen,
which is a grab Service, and Import image.

00:31:43.740 --> 00:31:46.029
And you'll notice that there's no menus.

00:31:46.029 --> 00:31:52.430
In Leopard, this would have all been within submenus, but
in Snow Leopard, the Services menu is completely flat.

00:31:52.430 --> 00:31:53.950
You'll also, all right.

00:31:53.950 --> 00:32:03.259
[Applause] Now if I select some text,
we have 6 or 7 items now, 8 items,

00:32:03.259 --> 00:32:06.049
and you'll see that there's categorizations on the left.

00:32:06.049 --> 00:32:13.849
So you can have text and pictures, various categories,
and of course, there's also icons that appear,

00:32:13.849 --> 00:32:19.000
but there's still some Services missing,
for example, OpenURL or Reveal and Finder.

00:32:19.000 --> 00:32:25.619
So I'm going to select the URL down
here, and we see that OpenURL appears.

00:32:25.619 --> 00:32:29.789
So Services menu knows what URLs
look like and can enable the Services

00:32:29.789 --> 00:32:32.990
that handle URLs to only appear when URL is selected.

00:32:32.990 --> 00:32:34.390
And it's not just web URLs.

00:32:34.390 --> 00:32:41.370
Here's an ancient gopher URL and it
appears for that as well, so any URL type.

00:32:41.369 --> 00:32:43.669
Another example is email addresses.

00:32:43.670 --> 00:32:52.620
So the Services send to will now know what email address
look like and will appear there, and file paths as well.

00:32:52.619 --> 00:32:56.369
So Open, Reveal, Show Info only appears
when there's a file path selected.

00:32:56.369 --> 00:33:01.649
And we also can recognize texts or scripts and languages.

00:33:01.650 --> 00:33:05.970
So the Chinese text converted Services
would appear all the time in Leopard.

00:33:05.970 --> 00:33:12.079
In Snow Leopard, they're still enabled by default, but
they only show up if the text is written in Chinese.

00:33:12.079 --> 00:33:16.980
So here, this is simplified Chinese, and I can
select it, and it will convert it to traditional.

00:33:16.980 --> 00:33:21.880
So the last thing of note....

00:33:21.880 --> 00:33:27.120
[applause] ...all right, the last important fact is
that Services can also appear in the Context menu.

00:33:27.119 --> 00:33:34.839
We show a subset of Services, not all of them, but the
ones that we think are most contextual, most relevant.

00:33:34.839 --> 00:33:41.269
So in this case, the Convert Selected Traditional Chinese
Text will appear in the Context menu down at the bottom, so.

00:33:41.269 --> 00:33:51.470
[Applause] And all these features, all these contextuality
is fully available to any application and in fact,

00:33:51.470 --> 00:33:56.850
I'm writing an application, and I'll be showing,
using this application to demo how you go

00:33:56.849 --> 00:33:59.309
about integrating Services programatically.

00:33:59.309 --> 00:34:02.789
So this is an application which maybe shows some pictures.

00:34:02.789 --> 00:34:07.470
It's got-- each picture has a name
and the date it was taken.

00:34:07.470 --> 00:34:10.809
To represent that, we have a single class photo.

00:34:10.809 --> 00:34:16.779
Photo has the image, the URL to the image, and
the name and date that the image was taken,

00:34:16.780 --> 00:34:19.710
and it implements the NSPasteboard writing protocol.

00:34:19.710 --> 00:34:29.349
So the photo will write itself to the Pasteboard
in a way that other applications can understand.

00:34:29.349 --> 00:34:34.650
So it would be nice if our application
could provide Services to other apps.

00:34:34.650 --> 00:34:39.389
For example, if you could just select a
date in Mail and say insert the photos taken

00:34:39.389 --> 00:34:42.059
on this date, and that photo would appear.

00:34:42.059 --> 00:34:48.279
So the first step to this is getting our menu items
into the Services menu, and we call that advertising.

00:34:48.280 --> 00:34:52.040
So how do you advertise a Service?

00:34:52.039 --> 00:34:55.309
Well, you declare your Services in the app's Info.plist.

00:34:55.309 --> 00:34:59.590
So here's an example of an application to provide a Service.

00:34:59.590 --> 00:35:04.190
A tool called pbs will scan and
cache the Service declarations.

00:35:04.190 --> 00:35:07.079
A pbs existed in Leopard but it was totally private.

00:35:07.079 --> 00:35:11.739
In Snow Leopard, there are some developer
features for pbs that I'll be showing you later.

00:35:11.739 --> 00:35:19.519
And at runtime, AppKit will read the data cache by
pbs and use that to construct the Services menu.

00:35:19.519 --> 00:35:27.480
So here's an example of a Service, one of TextEdit
Services that is declared in the app's Info.plist.

00:35:27.480 --> 00:35:33.789
It starts of course with the NSServices declaration in the
root level of the Info.plist, and below that is an array,

00:35:33.789 --> 00:35:36.699
so an app can provide more than one Service.

00:35:36.699 --> 00:35:39.039
It's an array of dictionaries.

00:35:39.039 --> 00:35:42.759
Most important key, or one of the most
important keys is the NSMenuItem dictionary,

00:35:42.760 --> 00:35:45.210
and that's just the title of the menu item.

00:35:45.210 --> 00:35:52.949
It has to be within a subdictionary with the key by default
because of the historical way we issue the localization.

00:35:52.949 --> 00:35:56.819
So here, the title is Open Selected File.

00:35:56.820 --> 00:36:03.809
Another important key is NSMessage which is the name of the
Objective-C method that your Service provider implements.

00:36:03.809 --> 00:36:09.739
So this is what connects the programatic
Service providing to the app's Info.plist.

00:36:09.739 --> 00:36:17.879
And lastly, our NSSendTypes and NSReturnTypes, and these
are Pasteboard types that are yet in Leopard and later UTIs,

00:36:17.880 --> 00:36:20.780
which are the types that your Service provides or receives.

00:36:20.780 --> 00:36:24.650
So Open Selected File will open a text file by--

00:36:24.650 --> 00:36:31.110
if you select the path, and in this
case it receives text, right, text.

00:36:31.110 --> 00:36:35.940
But there's another key in Snow
Leopard which is responsible for much

00:36:35.940 --> 00:36:40.010
of the contextuality, and this is the NSRequiredContext key.

00:36:40.010 --> 00:36:43.560
The Service only appears if the
required context is satisfied.

00:36:43.559 --> 00:36:50.509
So in text edit, the Service should only appear
if the text content contains a file path.

00:36:50.510 --> 00:36:57.450
And this is the key to deciding whether the third party
Services appear in the Services menu by default or not.

00:36:57.449 --> 00:37:03.789
You notice that the Services menu was devoid of all third
party Services, and we made a decision to disable them all

00:37:03.789 --> 00:37:08.420
by default, but give you this other way
to get back in as away of declaring, "Yes,

00:37:08.420 --> 00:37:10.930
I've updated my Service for Snow Leopard.

00:37:10.929 --> 00:37:14.899
It has a nice longer title to work with
the not having-- the hierarchical menus.

00:37:14.900 --> 00:37:16.389
It's got a nice icon.

00:37:16.389 --> 00:37:17.639
I'm ready for Snow Leopard."

00:37:17.639 --> 00:37:21.139
And even putting this key in your
Info.plist, even if it's totally empty,

00:37:21.139 --> 00:37:24.759
will enable your Service to be available by default.

00:37:24.760 --> 00:37:27.480
Of course, if it's disabled by default because it's--

00:37:27.480 --> 00:37:32.789
you wrote it for Leopard, the user
can still enable it in preferences.

00:37:32.789 --> 00:37:41.070
So we saw that by default, Services that haven't
replied to context generally won't appear.

00:37:41.070 --> 00:37:48.170
But if you want to have, receive a file path, you
can use the NSRequiredContext key, where was that,

00:37:48.170 --> 00:37:53.659
and we support not just file path, but you can
also ask for URLs, addresses, date and email,

00:37:53.659 --> 00:37:55.859
and this is something in the list we'll be adding to later.

00:37:55.860 --> 00:38:02.820
We also saw that the Chinese text converter
Services appear only when Chinese text is converted.

00:38:02.820 --> 00:38:05.000
You can request a specific script.

00:38:05.000 --> 00:38:08.570
Here we're requesting simplified Chinese.

00:38:08.570 --> 00:38:13.130
For Services that appear in the finder, you can also request

00:38:13.130 --> 00:38:17.820
that my Service should only appear
when a specific file type is selected.

00:38:17.820 --> 00:38:23.710
For example, the folder action setup Service would appear
all the time in Leopard, even for text files or images.

00:38:23.710 --> 00:38:27.389
But in Snow Leopard, it appears only when a
folder is selected, and the way this works is

00:38:27.389 --> 00:38:31.619
through requesting an NSSendFileTypes of public.folder.

00:38:31.619 --> 00:38:38.349
Now you'll still receive URLs on the Pasteboard, though
you won't try to receive folders on the Pasteboard

00:38:38.349 --> 00:38:41.559
but all the URLs will of course
point to items that have these UTIs.

00:38:41.559 --> 00:38:48.019
You can also request that your Service
only should appear in certain applications,

00:38:48.019 --> 00:38:51.840
in this case Xcode, or for certain word limit.

00:38:51.840 --> 00:38:57.780
For example, a stock ticker application might only
provide a Service if exactly one word, you know,

00:38:57.780 --> 00:39:00.700
a 4-character stock ticker symbol is selected.

00:39:00.699 --> 00:39:05.009
So let's look at how we declare
our Services on our Info.plist.

00:39:05.010 --> 00:39:12.830
[ Pause ]

00:39:12.829 --> 00:39:14.670
>> This one, yes.

00:39:14.670 --> 00:39:22.300
So our Services for our Photoviewer application
have an NSMenuItem named getPhotosWithName.

00:39:22.300 --> 00:39:26.320
This corresponds to the Objective-C method get namedImages.

00:39:26.320 --> 00:39:32.240
It's going to accept Plain Text and will return
an image, public.tiff, and is only going to appear

00:39:32.239 --> 00:39:38.549
if there is one word selected, because it will
save, image can only be tagged by one word tags.

00:39:38.550 --> 00:39:41.680
And likewise, we'll get photos taken on date.

00:39:41.679 --> 00:39:46.589
This corresponds to the get datedImages method,
and it will only appear if a date is selected.

00:39:46.590 --> 00:39:50.539
So let's see if this works.

00:39:50.539 --> 00:39:52.380
[Murmuring] Here it is.

00:39:52.380 --> 00:40:05.809
So I'll select some text here and indeed
getPhotosWithName appears like we expect it to.

00:40:06.860 --> 00:40:08.430
OK, well, great.

00:40:08.429 --> 00:40:12.219
You've got into the menu, and congratulations,
the user selected your Service.

00:40:12.219 --> 00:40:14.639
What happens next?

00:40:14.639 --> 00:40:17.529
>> So the TextEdit here is acting as a Service consumer.

00:40:17.530 --> 00:40:23.230
And if your application isn't already running,
it's going to go ahead and launch your application.

00:40:23.230 --> 00:40:29.039
And it's going to look at the Send and
ReceiveTypes of the Service that it's consuming.

00:40:29.039 --> 00:40:31.269
In this case, it's consuming text.

00:40:31.269 --> 00:40:36.090
So it's gong to take the selected text,
put it on a Pasteboard, there it goes,

00:40:36.090 --> 00:40:41.620
and it's going to move the Pasteboard all the way over
to the Service provider, which will read off the text.

00:40:41.619 --> 00:40:46.190
Service provider will look for images or perform
an operation on the text that it wants to.

00:40:46.190 --> 00:40:52.269
And if there is a ReturnType, in this case public.tiff,
it will take that image, put it on the Pasteboard

00:40:52.269 --> 00:40:54.460
and send it back to the Service consumer.

00:40:54.460 --> 00:40:58.679
So your app will be launched if necessary.

00:40:58.679 --> 00:41:00.369
You don't have to ensure that it's already running.

00:41:00.369 --> 00:41:03.259
And the way it receives the Service request is

00:41:03.260 --> 00:41:07.490
by registering its Service provider
via the setServiceProvider method.

00:41:07.489 --> 00:41:10.259
And the provider receives a message
depending on the Service.

00:41:10.260 --> 00:41:14.200
This is at NSMessage key and the
Info.plist that I showed you earlier.

00:41:14.199 --> 00:41:21.009
So let's look at how we provide
a Service in our Photoviewer app.

00:41:21.010 --> 00:41:25.660
[ Pause ]

00:41:25.659 --> 00:41:26.839
>> Get rid of that.

00:41:26.840 --> 00:41:32.019
So I'm moved them to the Info Category Service Provider.

00:41:32.019 --> 00:41:36.380
The first step is to register the
Service provider saying, "NSApplication,

00:41:36.380 --> 00:41:39.059
I am the object that will receive the Service request."

00:41:39.059 --> 00:41:40.639
And this, you only have to do once.

00:41:40.639 --> 00:41:45.289
In this is, this happens at NSApplicationDidFinishLaunching.

00:41:45.289 --> 00:41:52.559
So now, we implement the methods that we said we
would implement in our Info.plist, getNamedImages.

00:41:52.559 --> 00:41:58.150
We'll start by pulling out any string that was
selected, NSPasteboardType String which is the UTI.

00:41:58.150 --> 00:42:06.380
And as a courtesy to the user, we'll trim off any white
space, and if we're able to find pullSelectedTextOut,

00:42:06.380 --> 00:42:08.940
we're going to find all the photos matching that text.

00:42:08.940 --> 00:42:16.159
So for every photo, if its name is equal to the name that
we got on the Pasteboard, then we'll add it to an array.

00:42:16.159 --> 00:42:23.440
And if we were able to find any photos, then
we'll call clearContents and then writeObject.

00:42:23.440 --> 00:42:28.909
So we write the photos, and because we implement the
NSPasteboardWriting protocol, this is all we have to do.

00:42:28.909 --> 00:42:34.500
And if we didn't find any photos, well,
there is an NSError parameter here,

00:42:34.500 --> 00:42:40.860
and we can return a string saying, "No photo has that tag."

00:42:40.860 --> 00:42:47.460
Now, to getDatedImages, getting images all on-- that were
taken on a specific date, it's almost exactly the same,

00:42:47.460 --> 00:42:50.429
except that we want to pull a date out of the Pasteboard.

00:42:50.429 --> 00:42:53.869
Now, even though we're looking for
a date, we're getting an NSString

00:42:53.869 --> 00:42:56.210
on the Pasteboard because that's the type we requested.

00:42:56.210 --> 00:43:06.619
But in Snow Leopard, there's a new API, the NSTextChecking
API, which we can use to convert the string to a date.

00:43:06.619 --> 00:43:09.359
So we can use that to find the-- to
scan the string and pull out any dates.

00:43:09.360 --> 00:43:13.420
So even though we requested a date,
we still receive a string

00:43:13.420 --> 00:43:16.420
and it's our responsibility to
find the dates within that string.

00:43:16.420 --> 00:43:18.300
So let's give these Services a try.

00:43:18.300 --> 00:43:30.269
I am in Mail and I'll say, take out this photo and I'll
pick a photo-- I'll pick a photo and we can right-click,

00:43:30.269 --> 00:43:32.869
and I'll take out photos with name, and it works.

00:43:32.869 --> 00:43:34.319
There is the photo.

00:43:34.320 --> 00:43:35.010
So--

00:43:35.010 --> 00:43:38.460
[ Applause ]

00:43:38.460 --> 00:43:41.909
[ Pause ]

00:43:41.909 --> 00:43:46.019
>> OK, so now we've gone ahead
and we've implemented a Service.

00:43:46.019 --> 00:43:48.159
Oh, three things to keep in mind.

00:43:48.159 --> 00:43:51.339
If your Service doesn't have a
ReturnType the process is asynchronous.

00:43:51.340 --> 00:43:53.559
So for example, OpenURL.

00:43:53.559 --> 00:43:56.400
If you select that from TextEdit, it's
just going to pass the URL to Safari

00:43:56.400 --> 00:43:59.480
or your default web browser, and forget about it.

00:43:59.480 --> 00:44:04.610
But if it does have a return type, the calling app will
actually sit and wait until your Service gets back to it.

00:44:04.610 --> 00:44:10.800
Now, in Snow Leopard, users can actually cancel
this process by hitting Escape or Command-period.

00:44:10.800 --> 00:44:15.289
But still, it's a good idea to show some feedback,
a progress indicator or a dialogue indicating

00:44:15.289 --> 00:44:21.769
that you're performing the Service, if
that Service might take some time to do.

00:44:21.769 --> 00:44:29.159
OK, consuming a Service, how do you use
Services from other applications in your app?

00:44:29.159 --> 00:44:33.239
Well, now with Snow Leopard, Services
are more useful than they've ever been.

00:44:33.239 --> 00:44:37.969
So users are going to start to expect them to
work in places where they didn't previously work.

00:44:37.969 --> 00:44:42.759
Anytime I can select text or select an image
or select a file, I'm going to want to be able

00:44:42.760 --> 00:44:47.630
to use the Services corresponding to those types.

00:44:47.630 --> 00:44:52.890
Now your views can implement an API to
support these Services, consume Services.

00:44:52.889 --> 00:44:54.210
And this isn't a new API.

00:44:54.210 --> 00:44:56.429
This is the same API we've had since 10.0.

00:44:56.429 --> 00:45:04.480
But if you can use a standard control, either
NSTextView or WebView, these implement the API for you.

00:45:04.480 --> 00:45:07.599
So then, in that case, you're already done.

00:45:07.599 --> 00:45:14.569
But if you have a custom control, for example, our
photo app has a custom control that displayed photo.

00:45:14.570 --> 00:45:17.300
There are three steps you have
to follow to implement the API.

00:45:17.300 --> 00:45:22.039
You have to register the types you support,
indicate when you support those types,

00:45:22.039 --> 00:45:26.070
and then actually do the PasteboardWriting and Reading.

00:45:26.070 --> 00:45:34.230
So I'll show you how we implemented this API in my app.

00:45:36.300 --> 00:45:42.750
So let's start by defining a
convenient method, supported SendTypes.

00:45:42.750 --> 00:45:48.099
So these are the types that we can send to apps that
provide Services, and we can send all imageTypes

00:45:48.099 --> 00:45:53.360
and we can also send FileURL and this old deprecated,
all right, I don't know if it's deprecated,

00:45:53.360 --> 00:45:58.920
but this older NSFilenamesPboardType as well.

00:45:58.920 --> 00:46:03.550
So the first step is indicating a
type we support, and we call that--

00:46:03.550 --> 00:46:07.890
we call the registered Services
menu SendTypes, ReturnTypes method.

00:46:07.889 --> 00:46:12.369
And we pass the SendTypes we support, and we don't
support any ReturnTypes, so we pass No for that.

00:46:12.369 --> 00:46:14.409
And this only has to be done once.

00:46:14.409 --> 00:46:16.519
This is just a way of saying to AppKit,.

00:46:16.519 --> 00:46:21.539
"There's some sort of control in this application that
can handle Services with these Send and ReturnTypes."

00:46:21.539 --> 00:46:28.090
So now, when the Services menu was actually shown,
it's going to go through and say, "All right,

00:46:28.090 --> 00:46:32.260
is there a control right now that can handle
the type for each of theses Services?"

00:46:32.260 --> 00:46:37.610
And will pass this to SendType and ReturnType
corresponding to the types for these Services.

00:46:37.610 --> 00:46:46.269
Now, if a Service doesn't have a Send or
ReturnType, it's going to pass nil for that case.

00:46:46.269 --> 00:46:51.380
So because we don't support any return types,
all we can do is send images and send FileURLs.

00:46:51.380 --> 00:46:55.970
If the return type is not nil, the Service
expects to provide data back to us.

00:46:55.969 --> 00:46:58.389
And in that case, we'll just call through to Super.

00:46:58.389 --> 00:47:02.549
But if the ReturnType is nil, we
may be able to handle this Service.

00:47:02.550 --> 00:47:07.600
Now, if the SendType is nil, the Service
doesn't want any input or output.

00:47:07.599 --> 00:47:09.579
So of course we could always handle it.

00:47:09.579 --> 00:47:16.099
But if the SendType is not nil, we need to make it one
of the types we support, so we say supported SendTypes.

00:47:16.099 --> 00:47:20.130
If it contains this SendType, then we can support that.

00:47:20.130 --> 00:47:25.630
But we're still not done because it
may be that there's no file selected.

00:47:25.630 --> 00:47:30.050
All right, if Service operates an image, it should
only work if there's an image actually selected.

00:47:30.050 --> 00:47:36.000
So if we have selected objects, at least one, well,
then we can actually provide the Service ReturnSelf.

00:47:36.000 --> 00:47:40.860
Otherwise, we fall through to the Super
implementation which is on NSResponder.

00:47:40.860 --> 00:47:49.030
And the last step is when the user actually chooses
a Service that needs to interact with our control.

00:47:49.030 --> 00:47:52.460
It calls write selection to Pasteboard.

00:47:52.460 --> 00:47:55.030
And this is a really easy method to implement for us.

00:47:55.030 --> 00:48:01.150
All we do is call clearContents and then write all of the
selected objects, which are those photos, to the Pasteboard.

00:48:01.150 --> 00:48:05.480
And if we had the receiver data back
again, we would implement read selection

00:48:05.480 --> 00:48:08.150
from Pasteboard to do essentially the same thing.

00:48:08.150 --> 00:48:10.829
Just clear the-- I'm sorry, to read
the objects off the Pasteboard.

00:48:10.829 --> 00:48:16.460
So let me show you how that-- how this looks.

00:48:16.460 --> 00:48:24.280
So I can select an image and in
the Services menu we have SendFile.

00:48:24.280 --> 00:48:31.210
You can see it not only shows the Services that apply the
files, but also Services that apply specifically to images.

00:48:31.210 --> 00:48:36.039
Because it knows that the URLs we're giving
it back are images-- or point to images.

00:48:36.039 --> 00:48:41.539
And likewise, I can select via the context
menu, we'll see that the most specific Services,

00:48:41.539 --> 00:48:47.409
here are the ones that apply specifically-- the
image files also appear, set desktop picture.

00:48:50.219 --> 00:48:54.909
So that's all we have to do to consume a Service.

00:48:54.909 --> 00:48:57.519
That wasn't very bad.

00:48:57.519 --> 00:49:00.869
The last step is debugging Services.

00:49:00.869 --> 00:49:03.750
It's just something I'm really glad we have.

00:49:03.750 --> 00:49:09.539
Because in Leopard, you would often write a Service and
it just wouldn't show in the menu, and you don't know why.

00:49:09.539 --> 00:49:12.570
Maybe your app isn't registered
with the Services architecture

00:49:12.570 --> 00:49:18.809
You have to log out and log back in, or maybe there's
typo pull under Info.plist and it's not going to tell you.

00:49:18.809 --> 00:49:19.949
It's just not going to show up.

00:49:19.949 --> 00:49:25.649
Or maybe, there's another application with the same bundle
identifier, an earlier version, and it's preferring that.

00:49:25.650 --> 00:49:30.420
So how do you go about figuring
out why your Service doesn't work?

00:49:30.420 --> 00:49:33.380
Well the answer to that is the pbs
tool, which I mentioned earlier.

00:49:33.380 --> 00:49:37.150
The pbs is your window into the Services registration.

00:49:37.150 --> 00:49:43.180
And if you just run it with no argument, it will look
for any changes to any Service anywhere on the system

00:49:43.179 --> 00:49:49.699
and it will immediately update the Services menu to show
all the new Services or remove any that have gone away.

00:49:49.699 --> 00:49:51.009
You don't even have to re-launch the apps.

00:49:51.010 --> 00:49:53.150
It will just do this for any apps that are running.

00:49:53.150 --> 00:49:57.260
But it will also typecheck your Info.plist.

00:49:57.260 --> 00:50:01.290
So if there's a typo somewhere, you have a
dictionary instead of an array for example,

00:50:01.289 --> 00:50:05.730
it will tell you that and tell you exactly what went wrong.

00:50:05.730 --> 00:50:10.530
And lastly, you can pass it the dumpPboard option,
and it will list all the Services that are registered.

00:50:10.530 --> 00:50:17.330
>> So if you don't even know if it's found your app yet, you
can call this and it will tell you the apps that are found.

00:50:17.329 --> 00:50:20.259
And an important note is that pbs is just for debugging.

00:50:20.260 --> 00:50:26.290
It may go away or change names later in the future so
you shouldn't write any applications that depend on it

00:50:26.289 --> 00:50:27.789
or write on the installers to talk to pbs.

00:50:27.789 --> 00:50:31.769
Make sure only use it for debugging your app.

00:50:31.769 --> 00:50:40.050
Now, with this, we can figure out if the
Services architecture has found our application.

00:50:40.050 --> 00:50:42.600
But what happens at runtime if your Service doesn't appear?

00:50:42.599 --> 00:50:45.460
We saw all these crazy ways to make a Service contextual.

00:50:45.460 --> 00:50:51.320
How do we figure out why the Service
is showing up or not showing up?

00:50:51.320 --> 00:50:56.620
Well, the NSDebugServices user default
is your window into Services at runtime.

00:50:56.619 --> 00:51:01.509
So for example, if I launch TextEdit with the
NSDebugServices and I'm going to pass it the bundle ID

00:51:01.510 --> 00:51:07.340
of the application that I want to find out about the Service
provider, it will output incredibly detailed information

00:51:07.340 --> 00:51:12.210
about why the Service is appearing or not appearing.

00:51:12.210 --> 00:51:16.740
So let me show you how I'd go about
debugging Services with this application.

00:51:19.880 --> 00:51:29.680
So I have a second application called the next
version, this Buggy Picture Viewer, because it's buggy.

00:51:29.679 --> 00:51:36.919
The Info.plist here has Services called
getPhotosTakenOnDateBuggy and getPhotosWithNameBuggy.

00:51:36.920 --> 00:51:43.920
So we can figure out whether we're looking
at the new version or the old version.

00:51:43.920 --> 00:51:51.079
So if I open up TextEdit and I type some text
and I go to the Services menu, it doesn't appear.

00:51:51.079 --> 00:51:53.039
All I see is the nonbuggy version.

00:51:53.039 --> 00:51:57.110
So how do I figure out why is my Service not appearing?

00:51:57.110 --> 00:52:00.800
Well the first question is, has
it even found the Service at all?

00:52:00.800 --> 00:52:06.010
So I'm going to call system-- I'm going
to call pbs with the dumpPboard option,

00:52:06.010 --> 00:52:09.780
and it will tell me everything,
every application that it's found.

00:52:09.780 --> 00:52:11.300
So I'll search for buggy.

00:52:11.300 --> 00:52:13.700
It's saying not found.

00:52:13.699 --> 00:52:15.639
It hasn't registered my Service.

00:52:15.639 --> 00:52:22.089
OK, let's call pbs without any options and have
it just register all the Services it can find.

00:52:22.090 --> 00:52:28.840
So I do that, and it's telling me, "Uh-oh,
there's malformed Services entry in the Info.plist

00:52:28.840 --> 00:52:32.800
for the Service at this URL and that's my buggy app."

00:52:32.800 --> 00:52:33.600
So what could be wrong?

00:52:33.599 --> 00:52:34.719
Well, it tells me that as well.

00:52:34.719 --> 00:52:40.059
The value for key and NSWordLimit was supposed
to of type NSNumber, but it was a string.

00:52:40.059 --> 00:52:43.900
So let's see if that's true.

00:52:43.900 --> 00:52:45.780
Here is that NSWordLimit, oh it is a string.

00:52:45.780 --> 00:52:46.760
This should be integer.

00:52:46.760 --> 00:52:54.400
Let's change that into integer, and
I'll rebuild, and I run pbs again.

00:52:54.400 --> 00:52:56.430
Oh, it didn't report any errors.

00:52:56.429 --> 00:53:00.109
Let's see if it actually registers our app.

00:53:00.110 --> 00:53:04.640
We'll dumpPboard, there it is, Buggy Picture Viewer.

00:53:04.639 --> 00:53:09.500
OK, let's actually try running the app.

00:53:09.500 --> 00:53:13.119
Let's try using it at-- from TextEdit here.

00:53:13.119 --> 00:53:17.099
So I'll say Bridezilla, and [inaudible].

00:53:17.099 --> 00:53:20.730
So I show this, and it's still not showing the Service.

00:53:20.730 --> 00:53:23.440
How do we figure out why not?

00:53:23.440 --> 00:53:28.869
I'll launch TextEdit again, but
I'll specify NSDebugServices,

00:53:28.869 --> 00:53:32.199
and I'll give it the bundle ID of our buggy Service.

00:53:32.199 --> 00:53:36.659
And it's telling me, first off, that the
buggy picture of your Service is enabled

00:53:36.659 --> 00:53:39.409
in the Services menu and the Contexts menu.

00:53:39.409 --> 00:53:47.639
So now I'll type some text again, and I'll show it.

00:53:47.639 --> 00:53:55.179
And it says that my Service was disqualified because it
has a word limit of 3 of 1, but there were three words.

00:53:55.179 --> 00:53:56.419
So that's pretty detailed.

00:53:56.420 --> 00:53:58.289
Let's get rid of two of these words.

00:53:58.289 --> 00:54:01.960
Oh, and there's the buggy Service.

00:54:01.960 --> 00:54:07.090
So we're able to use pbs and the
NSDebugServices user default to figure

00:54:07.090 --> 00:54:10.670
out why our Service wasn't appearing and debug it.

00:54:10.670 --> 00:54:14.309
[Applause] We're really happy there's
now a way to debug these Services.

00:54:14.309 --> 00:54:18.960
And there's one more feature I'd love to show you,
which is using an automated workflow as a Service.

00:54:18.960 --> 00:54:22.280
And this is really cool.

00:54:22.280 --> 00:54:29.180
So all I've done is launched Automator,
and there's a new starting point Service.

00:54:29.179 --> 00:54:31.309
Thank you.

00:54:31.309 --> 00:54:36.590
OK, I've launched Automator, there's now a starting
point called Service, and I'll choose that.

00:54:36.590 --> 00:54:38.850
And let's say I'm just a huge Python junky.

00:54:38.849 --> 00:54:45.349
I have to be able to run Python code from TextEdit
and pages and everywhere that I can input text.

00:54:45.349 --> 00:54:48.389
Well, I can make a Service to do
this with Automator really easily.

00:54:48.389 --> 00:54:56.619
So let's start by making run shell script command, and I'll
just pass the selected text straight to Python and I'll say

00:54:56.619 --> 00:55:07.639
that it replaces the selected text, and this should appear
in any application, and I'll save it as runTextAsPython.

00:55:10.190 --> 00:55:17.369
OK, well, I'll type some-- this is a Python
Easter Egg for those of you who know Python.

00:55:17.369 --> 00:55:26.329
And in the Services menu, well it appears right away,
runTextAsPython and I select that, there it goes.

00:55:26.329 --> 00:55:28.340
And this is what happens when you
run-- import this as Python.

00:55:28.340 --> 00:55:29.000
So it--

00:55:29.000 --> 00:55:34.659
[ Applause ]

00:55:34.659 --> 00:55:40.309
>> So it's really easy to make-- that only took, you know,
a couple seconds just to make a workflow into a Service.

00:55:40.309 --> 00:55:47.659
And if this is something which seems interesting to you,
[laughter] and I hope it does, now that we did this demo,

00:55:47.659 --> 00:55:54.190
I encourage you to go to the workflows as-- the Using
Automator and Services to Integrate with Mac OS X session

00:55:54.190 --> 00:56:02.000
which is tomorrow, and also, you'll learn about how
to provide your application as Automator actions.

00:56:02.000 --> 00:56:07.760
So users can create their own Services
that are involved in your application.

00:56:07.760 --> 00:56:09.420
So, what have we seen?

00:56:09.420 --> 00:56:14.389
Well, we see the NSPasteboard has all
sorts of new APIs in Snow Leopard.

00:56:14.389 --> 00:56:18.519
Common operations like reading and writing from
the Pasteboard usually require a lot less code.

00:56:18.519 --> 00:56:19.449
It's much simpler.

00:56:19.449 --> 00:56:25.799
And this is because we've shifted the focus away from
pboard types to classes, and where we still use types,

00:56:25.800 --> 00:56:31.720
we move them from types, the old pboard types to UTIs.

00:56:31.719 --> 00:56:35.329
We've also seen that Services have
been rejuvenated in Snow Leopard.

00:56:35.329 --> 00:56:38.159
And the bar for a Service has been raised.

00:56:38.159 --> 00:56:45.730
So it's important that all Mac OS X apps that are relevant
to Services integrate with Services as much as possible.

00:56:45.730 --> 00:56:51.820
Some ways to do that are to provide contextual Services from
your application, via Service provider allowing Services

00:56:51.820 --> 00:56:53.990
from other apps to be consumed within your app.

00:56:53.989 --> 00:57:01.399
And lastly, to expose your app as Automator action
so that users can construct Services from your app.

00:57:01.400 --> 00:57:05.990
So for more information, you can
contact our Evangelist, Matt Drance,

00:57:05.989 --> 00:57:10.149
and the Services Implementation Guide
has been updated for Snow Leopard.

00:57:10.150 --> 00:57:14.809
If you search in Xcode documentation for the Services
Implementation Guide, you'll see all those keys

00:57:14.809 --> 00:57:19.009
that I showed you before as well
as the pbs debugging tricks.

00:57:19.010 --> 00:57:26.560
And the Pasteboard Programming Guide also is
updated to show you some of the new Pasteboard APIs.

00:57:26.559 --> 00:57:29.000
I think with that, we have a song.

00:57:29.000 --> 00:57:31.670
[ Laughter ]

00:57:31.670 --> 00:57:34.340
[ Applause ]

00:57:34.340 --> 00:57:37.010
[ Cheers ]

00:57:37.010 --> 00:57:40.120
>> Thank you.

00:57:40.119 --> 00:57:42.139
>> Thank you.

00:57:42.139 --> 00:57:43.879
>> Thank you, Peter.

00:57:43.880 --> 00:57:48.059
Actually, I just have been really
impressed with all the new Services stuff.

00:57:48.059 --> 00:57:50.000
Just [applause] put it together, that's awesome.

00:57:50.000 --> 00:57:55.639
[ Applause ]

00:57:55.639 --> 00:58:06.150
>> So, for the last number of years, some session has a
little guitar icon and a little song shows up at the end.

00:58:06.150 --> 00:58:12.809
And well, this year, well first, let me
introduce who else is on stage with me.

00:58:12.809 --> 00:58:15.929
You may notice that Gordie Freedman

00:58:15.929 --> 00:58:20.769
who is the original Breakpoint guitarist
wasn't able to make it this year.

00:58:20.769 --> 00:58:27.829
But we have John Skello [phonetic], our newest Breakpoints,
and he plays guitar well enough for the both of us...

00:58:27.829 --> 00:58:29.509
[applause] ...and joining us.

00:58:31.289 --> 00:58:39.449
And then as always, on keyboard, the best slide
advanced man in the business, Mr. Victor Alexander.

00:58:43.260 --> 00:58:50.490
[Applause] And so this year, as you've seen, we've made a
lot of changes to Pasteboards, lot of changes to Services,

00:58:50.489 --> 00:58:54.489
and kind of talked through a lot of new Pasteboard APIs.

00:58:54.489 --> 00:59:01.419
So I thought this would be a good opportunity to do a
little song that did some review of what we've just heard.

00:59:01.420 --> 00:59:09.010
And also, since the Pasteboard is all about getting
from point A to point B, I thought what better way to--

00:59:09.010 --> 00:59:14.130
what better style for a song than a
little Rock-a-Billy traveling music.

00:59:14.130 --> 00:59:19.000
So without any further ado, "Going To Need A Pasteboard".

00:59:19.000 --> 00:59:28.500
[ Music ]

00:59:28.500 --> 00:59:28.860
[ Singing ]

00:59:28.860 --> 00:59:35.210
>> Well, you got an application, has some
things to share with them other applications.

00:59:35.210 --> 00:59:37.269
Well you got to stick that stuff somewhere.

00:59:37.269 --> 00:59:43.570
You're going to need a Pasteboard,
baby, yeah, to move that stuff around.

00:59:43.570 --> 00:59:53.120
Oh, yeah. Treat the Pasteboard right then
well it will not let you down, Oh, no.

00:59:53.119 --> 00:59:57.309
Well, Pasteboard's quite inviting
with the classes you invent.

00:59:57.309 --> 01:00:00.750
NSPasteboardWriting is the protocol you implement.

01:00:00.750 --> 01:00:06.570
So you can write them on the Pasteboard,
baby, common Cocoa classes too.

01:00:06.570 --> 01:00:12.940
You just toss them on the Pasteboard,
and that data will shine through.

01:00:12.940 --> 01:00:17.829
Let's do some writing.

01:00:17.829 --> 01:00:24.569
Let's get a Pasteboard, then clear them contents,
and write them up, yes, it's literally 1, 2,

01:00:24.570 --> 01:00:32.250
3 to write them on a Pasteboard, baby,
easy as falling off a log, oh yeah.

01:00:32.250 --> 01:00:38.949
But don't do the Pasteboard wrong,
no or it might diss you in its blog.

01:00:38.949 --> 01:00:40.449
[Laughter] Oh, yeah.

01:00:40.449 --> 01:00:44.629
We'll now you're dragging and you're
dropping, just the way you like to do,

01:00:44.630 --> 01:00:48.390
but that joyride will be stopping
if you can't get the data through.

01:00:48.389 --> 01:00:55.739
You're going to need a Pasteboard,
baby, the contents of the drag, oh yeah.

01:00:55.739 --> 01:01:04.109
So treat the Pasteboard nice, yeah, and
you won't hit a bump or snag, oh no.

01:01:04.110 --> 01:01:07.980
I say NSPasteboardReading has the power to create.

01:01:07.980 --> 01:01:14.469
It's what the Pasteboard's needing so it can
instantiate what you're reading off the Pasteboard, baby,

01:01:14.469 --> 01:01:19.119
all that its contents will allow, oh yeah.

01:01:19.119 --> 01:01:25.250
It just answer what you're needing, you'll
receive without much sweat upon your brow.

01:01:25.250 --> 01:01:26.150
Let's read.

01:01:26.150 --> 01:01:34.650
First get a Pasteboard, specify some classes,
and then read them objects oh, so literally 1,

01:01:34.650 --> 01:01:38.510
2, 3 to read them off a Pasteboard, baby.

01:01:38.510 --> 01:01:43.040
Yeah, you can't read all night.

01:01:43.039 --> 01:01:48.840
But don't leave the Pasteboard lonely,
no, no, 2 reads don't make a write.

01:01:50.599 --> 01:01:59.739
[Laughter] And then sometimes you just might find
that you require more specificity to determine type

01:01:59.739 --> 01:02:05.419
by type exactly what you read and write is supposed to be.

01:02:05.420 --> 01:02:13.450
So then you use a Pasteboard item, you can read
them, you can write them just as you desire.

01:02:13.449 --> 01:02:21.989
Use them to achieve your goal or if you're just into
control, that should surely set your soul on fire.

01:02:21.989 --> 01:02:25.889
Well, you might want to write a
Service to make any text or tweak.

01:02:25.889 --> 01:02:29.699
Then you might get nervous how that transfer was complete.

01:02:29.699 --> 01:02:36.569
Well you're going to need a Pasteboard,
baby, for the Service you provide, oh yeah.

01:02:36.570 --> 01:02:42.860
Well, just stick your data on there,
Pasteboard takes it for a ride.

01:02:42.860 --> 01:02:49.430
Well, the Pasteboard ain't too flashy,
no, but that don't make me sweat.

01:02:49.429 --> 01:02:52.969
It you ship an app without copy
and paste, just see how far you get.

01:02:52.969 --> 01:02:56.619
[Laughter] You're going to need that Pasteboard, baby.

01:02:56.619 --> 01:03:00.949
It surely would be missed, oh yeah.

01:03:00.949 --> 01:03:08.719
Oh, treat the Pasteboard right, now, I
think your users will insist, oh yeah.

01:03:08.719 --> 01:03:16.219
Oh, treat the Pasteboard nice now, I
think by now you get the gist, oh yeah.

01:03:16.219 --> 01:03:31.000
I say use the Pasteboard wisely, and
build an app we can't resist, oh yeah.

01:03:31.000 --> 01:03:36.710
[ Applause ]

01:03:36.710 --> 01:03:36.800
1
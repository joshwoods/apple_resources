WEBVTT

00:00:13.300 --> 00:00:19.260
>> Welcome to Session 503, Creating
Secure iPhone and Mac OS X Applications.

00:00:20.600 --> 00:00:22.320
I'm Geoff Keating.

00:00:22.320 --> 00:00:27.940
I'll be initially talking about security hardening features,
new features that we've implemented in Snow Leopard

00:00:27.940 --> 00:00:33.399
and all features that we've made
better from Leopard and before.

00:00:33.399 --> 00:00:36.199
So, in this part of the presentation, I'll be talking

00:00:36.200 --> 00:00:40.550
about new hardening features we've
enabled by default in Snow Leopard.

00:00:40.549 --> 00:00:45.409
I'll be talking about what they mean for you as
developers, and I'll be telling you about some features

00:00:45.409 --> 00:00:49.819
that we didn't turn on, features that you
probably might want to consider turning on,

00:00:49.820 --> 00:00:52.710
maybe something you actually should turn on.

00:00:52.710 --> 00:00:59.850
Later on, my colleague, Drew will be talking about what
happens after you've turned them on and you're still trying

00:00:59.850 --> 00:01:02.359
to find remaining security issues in your program.

00:01:02.359 --> 00:01:06.219
You'll be talking about determining the
exploitability of crashes that you've found

00:01:06.219 --> 00:01:13.700
through testing both automatically and by hand.

00:01:13.700 --> 00:01:18.680
So, I was talking about features
that we've turned on by default.

00:01:18.680 --> 00:01:21.710
What does that mean, on by default?

00:01:21.709 --> 00:01:26.129
Well, even though they're on by
default, you still need to do some--

00:01:26.129 --> 00:01:29.159
there are still some situations
under which they can't be on.

00:01:29.159 --> 00:01:35.039
In particular, for most of the features I'm talking
about, you need to be targeting, 10.5, or higher,

00:01:35.040 --> 00:01:40.020
and building 64-bit, that will get you the
best combination of hardening features.

00:01:40.019 --> 00:01:46.439
It doesn't matter what language you use,
C, C++, Objective-C, and Objective-C++,

00:01:46.439 --> 00:01:51.659
all of these that's fully supported
by the-- for these hardening features.

00:01:51.659 --> 00:01:59.179
So, something you're probably thinking
about already is, wait, stuff on by default,

00:01:59.180 --> 00:02:02.290
new, won't that cause trouble in my program?

00:02:02.290 --> 00:02:08.990
Well, so far as we can tell, these hardening
features have very small performance impact.

00:02:08.990 --> 00:02:13.040
When we tried to measure we found that
they were too small to reliably measure.

00:02:13.039 --> 00:02:22.899
So not faster but not slower either and all of the
features together gave only a very small code size impact

00:02:22.900 --> 00:02:26.000
as we've turned them on.

00:02:26.000 --> 00:02:30.620
Also, I guess I should put in a disclaimer,
these are just hardening features.

00:02:30.620 --> 00:02:31.969
They will help.

00:02:31.969 --> 00:02:42.259
They will not save you if you managed to introduce a
truly bizarre security vulnerability, but they will help.

00:02:42.259 --> 00:02:47.569
So let's start with a simple example of a security
vulnerability, and then I'll tell you about some

00:02:47.569 --> 00:02:55.289
of the hardening features we've introduced which
will greatly improve the ability of developers to--

00:02:55.289 --> 00:03:02.900
greatly reduce the ability of the attackers
to exploit this, well you know, program.

00:03:02.900 --> 00:03:05.810
So here's a simple example.

00:03:07.419 --> 00:03:09.699
This example has a bug.

00:03:09.699 --> 00:03:17.119
You can see that it's taking some untrusted data
from the network and then it's doing some processing,

00:03:17.120 --> 00:03:21.310
very simple processing, it's upper-casing
it and printing it out.

00:03:21.310 --> 00:03:26.300
The problem is that the data that's taken from the
network appears to have an arbitrary size link,

00:03:26.300 --> 00:03:32.450
it's taking a size T, but the buffer
that you can see here is a fixed size.

00:03:32.449 --> 00:03:41.349
Thus, when it copies the data from the network to the
buffer, the buffer might not be large enough to hold all

00:03:41.349 --> 00:03:44.049
of the data so we would have a buffer overflow.

00:03:44.050 --> 00:03:47.800
In this case, the buffer's on the
stack so it's the stack overflow.

00:03:47.800 --> 00:03:50.580
So what happens when the stack overflows?

00:03:50.580 --> 00:03:54.560
Well, the local variables are stored on the stack.

00:03:54.560 --> 00:04:01.460
Below, the other information like the saved
registers, the return address for this function,

00:04:01.460 --> 00:04:06.170
the arguments to the function, and so on.

00:04:06.169 --> 00:04:09.849
So, if a string is passed to this routine that's too long,

00:04:09.849 --> 00:04:16.069
it will start by filling up the
buffer, then it will keep going.

00:04:16.069 --> 00:04:21.769
It'll overwrite other local variables, it'll overwrite
saved registers, it'll overwrite the return address.

00:04:21.769 --> 00:04:29.310
An attacker can insert their own data into
the return address and point it at some place

00:04:29.310 --> 00:04:34.360
to do what the attacker wants,
which probably is not what you want.

00:04:36.910 --> 00:04:46.430
So, in-- since Leopard and now on by default
in the compiler in Snow Leopard, we used--

00:04:46.430 --> 00:04:49.490
we've added an additional form of protection.

00:04:49.490 --> 00:04:55.980
We called it stack canaries and you can
see we have the canary there on screen.

00:04:55.980 --> 00:05:00.710
The way this works is that the canary
is a word which is randomly chosen

00:05:00.709 --> 00:05:04.449
as your program starts up so the attacker can't predict it.

00:05:04.449 --> 00:05:09.949
So when the attacker attempts to
use a buffer overflow, like this,

00:05:09.949 --> 00:05:16.750
the attacker can't reliably overwrite
the canary with the correct value.

00:05:16.750 --> 00:05:21.269
The canary will-- and the routine when it returned,

00:05:21.269 --> 00:05:28.310
will then be able to check it whether this canary is the
correct value and if and unfortunately it's not, the--

00:05:28.310 --> 00:05:33.620
your program will be stopped so that the
attacker can't continue to exploit it,

00:05:33.620 --> 00:05:36.160
in particular the return address doesn't get used.

00:05:36.160 --> 00:05:44.290
So what does this look like when this
has happened to you and your program?

00:05:44.290 --> 00:05:49.640
Possibly you've got a test case which has
actually triggered a bug of this nature.

00:05:49.639 --> 00:05:51.589
Well, you'll see a crash report.

00:05:51.589 --> 00:05:59.239
Your program will call abort and hopefully you'll
be watching for crash reports in your test week.

00:05:59.240 --> 00:06:06.050
You'll notice that the crash report does not appear to be
very distinctive other than noticing that it calls abort.

00:06:06.050 --> 00:06:10.610
The reason for this is that, actually
it turns out the routine

00:06:10.610 --> 00:06:14.620
that stops your program calls abort
as the very last thing it does.

00:06:14.620 --> 00:06:19.360
So you can see here on screen we have
some symbol plus 0 in a crash report.

00:06:19.360 --> 00:06:26.660
Invariably what this means is that your crash
occurred at the last instruction of a routine

00:06:26.660 --> 00:06:30.520
and that really means it's the first
instruction of the next routine.

00:06:30.519 --> 00:06:39.599
So to diagnose such a case, what you want
to do is find the shared library that was--

00:06:39.600 --> 00:06:46.330
that contains the symbol involved and look
to see what symbol was immediately before it,

00:06:46.329 --> 00:06:49.879
which you can do with a command like this one on the screen.

00:06:49.879 --> 00:06:54.519
You can see that in this case we have
release_file_streams_for_task which doesn't appear

00:06:54.519 --> 00:06:59.310
to have anything to do with anything but
immediately before it is stack_chk_fail

00:06:59.310 --> 00:07:05.329
and that immediately tells you what
went wrong, the stack check failed.

00:07:05.329 --> 00:07:11.859
You can see which routine contained the buffer that
had the overflow simply by looking one down the stack.

00:07:11.860 --> 00:07:16.930
You'll see in this case it's print off
of the routine from the previous slide.

00:07:16.930 --> 00:07:22.389
The compiler doesn't automatically test for every--

00:07:22.389 --> 00:07:25.279
it doesn't automatically add stack
protection to every single routine.

00:07:25.279 --> 00:07:30.789
If it did that, we would no longer be
able to say that it had very low overhead,

00:07:30.790 --> 00:07:38.850
but this does mean that occasionally you might discover you
have a routine with an overflow that doesn't contain the--

00:07:38.850 --> 00:07:48.060
You might occasionally find that you have a routine with
an overflow but it didn't get a stack canary added to it.

00:07:48.060 --> 00:07:52.720
If you want to-- if you have a piece of
code that might be particularly dangerous,

00:07:52.720 --> 00:08:00.090
you might want to add more stack overflow checking and you
can do that with this flag, this stack protector or flag.

00:08:00.089 --> 00:08:04.919
That will ensure that every single routine
in your program will get a stack canary,

00:08:04.920 --> 00:08:07.699
whether it appears to need one or not.

00:08:07.699 --> 00:08:14.269
The disadvantages, this has an increased performance
impact, but the advantage is, you get much greater security.

00:08:14.269 --> 00:08:18.579
So that was stack projector.

00:08:18.579 --> 00:08:21.839
But, so where does the attacker go from there?

00:08:21.839 --> 00:08:25.959
Well, so the attackers have overwritten the stack
and I said that the return address was going

00:08:25.959 --> 00:08:30.509
to be redirected somewhere to do
something bad but where exactly?

00:08:30.509 --> 00:08:35.439
I mean, chances are there isn't already code in your
program to do whatever it is the attacker wants to do.

00:08:35.440 --> 00:08:38.900
Usually the attacker wants to execute their own code.

00:08:38.899 --> 00:08:44.519
Well, in many of these cases, the attacker has an
easy way to get code into your program already.

00:08:44.519 --> 00:08:49.899
In this case, it's especially simple, the attacker
is already overwriting a large area of the stack

00:08:49.899 --> 00:08:57.049
so the attacker can simply redirect the return address
to the stack and place their executable code there and,

00:08:57.049 --> 00:09:00.919
or pass the return address if there wasn't room.

00:09:00.919 --> 00:09:08.120
So, we have added the feature to
Leopard and later that prevents this

00:09:08.120 --> 00:09:13.080
under certain circumstances and it's very simple.

00:09:13.080 --> 00:09:20.960
On the stack, code is not executable,
likewise on the heap and so on.

00:09:20.960 --> 00:09:27.590
But this feature is only available in its
full form if you compile your programs 64-bit.

00:09:27.590 --> 00:09:34.019
So on Mac OS X, the stack, the static data and the heap,

00:09:34.019 --> 00:09:42.919
so that's everywhere that you would normally have writeable
data, are all protected on 64-bit PowerPC and 64-bit Intel.

00:09:42.919 --> 00:09:50.360
On 32-bit Intel, the only protection is on the stack
so if the attacker can force the code into the heap,

00:09:50.360 --> 00:09:58.460
then they can still execute that code and on 32-bit Intel,
there's no way for you to explicitly protect the heap.

00:09:58.460 --> 00:10:02.680
So we recommend that you make sure you
build a 64-bit version dof your program.

00:10:02.679 --> 00:10:06.799
Not only do you get these benefits, you get a whole
pile of other really nice benefits like it runs faster,

00:10:06.799 --> 00:10:11.779
it can use more memory, but also it's more secure.

00:10:11.779 --> 00:10:16.230
>> And if you have a situation where
you actually wish to generate code,

00:10:16.230 --> 00:10:23.159
so maybe you're writing adjusting time compiler, maybe
you're writing something that does conveniently--

00:10:23.159 --> 00:10:26.219
that does graphics processing, generating code for that.

00:10:26.220 --> 00:10:32.149
So you can use the mprotect system call
to make data executable when necessary.

00:10:32.149 --> 00:10:35.529
On iPhone, the situation is even better.

00:10:35.529 --> 00:10:41.069
On iPhone, no data can ever be made executable.

00:10:41.070 --> 00:10:46.870
All code must also be signed so that the
attacker would have to download sign code

00:10:46.870 --> 00:10:53.879
and even then they still can't make it
executable without calling into the system.

00:10:53.879 --> 00:11:00.259
And in addition, on iPhone, contractually, no
interpreters are allowed except for the system JavaScript.

00:11:00.259 --> 00:11:06.610
So the attacker can't even get around it by using an
interpreter you might already have in your program

00:11:06.610 --> 00:11:11.610
to interpret some form of byte code, for example.

00:11:11.610 --> 00:11:18.100
So all these together make it very hard to exploit a system.

00:11:18.100 --> 00:11:24.670
So-- but we still want to eliminate all these
buffer overflows, and another common case,

00:11:24.669 --> 00:11:30.079
if you didn't write a routine yourself that
contained the loop, is to misuse a library function.

00:11:30.080 --> 00:11:31.920
Take this example here.

00:11:31.919 --> 00:11:35.789
We have some untrusted data, we're
copying it into a fixed sized buffer.

00:11:35.789 --> 00:11:38.539
This does just the same thing as the previous routine.

00:11:38.539 --> 00:11:44.379
So what we'll want to do-- so you
shouldn't write code like this if possible.

00:11:44.379 --> 00:11:51.240
A better routine to use is the strlcpy function that
takes the size of the buffer you're copying it into

00:11:51.240 --> 00:11:55.529
and there are similar equivalents for
every routine in the C standard library.

00:11:55.529 --> 00:12:00.250
For example instead of sprintf, you should use snprintf.

00:12:00.250 --> 00:12:07.720
A disadvantage of this particular case here
is that strlcpy will truncate the buffer.

00:12:07.720 --> 00:12:15.509
So, you have in particular-- so if the string is
very long, strlcpy will just cut it off at the end.

00:12:15.509 --> 00:12:17.340
The problem with this is that there might be important data.

00:12:17.340 --> 00:12:23.530
For example, if you are logging this
information, the information vital to tracking

00:12:23.529 --> 00:12:26.929
down where this attacker is coming
from might be past the end.

00:12:26.929 --> 00:12:33.359
So a better alternative is to, you still
use strlcpy but check its return value.

00:12:33.360 --> 00:12:38.519
A strlcpy returns the size that it wished to copy.

00:12:38.519 --> 00:12:45.449
So, if it asks to copy-- if it wanted to copy more data than
is available in the buffer, it will return such a value.

00:12:45.450 --> 00:12:51.490
You can check for this and handle the error and that's
our recommended approach towards string functions.

00:12:51.490 --> 00:12:57.269
But what if you have a large program
already and the program--

00:12:57.269 --> 00:13:02.470
you don't really have time to check everything in
the program, all of these with the string functions,

00:13:02.470 --> 00:13:06.910
and even if you did check everything, you
definitely wouldn't have time to fix it.

00:13:06.909 --> 00:13:12.539
Well, in Snow Leopard, we've turned on a
feature by default that helps with this.

00:13:12.539 --> 00:13:20.799
The compiler will attempt to determine the size of an array,
so in the previous slide we had an array called buffer.

00:13:20.799 --> 00:13:26.240
If it can work out what size the array is,
it will replace the standard library function

00:13:26.240 --> 00:13:28.669
with a new version with _chk at the end of the name.

00:13:28.669 --> 00:13:35.789
It will pass to that routine the size of
the buffer and the routine will determine--

00:13:35.789 --> 00:13:38.899
will ensure that it never writes past the end of the buffer.

00:13:38.899 --> 00:13:45.649
If it appears it needs to, the routine would stop your
program rather than allow it to be possibly exploited

00:13:45.649 --> 00:13:48.689
by an attacker and you'll get a crash report.

00:13:48.690 --> 00:13:50.780
Again, it will call abort.

00:13:50.779 --> 00:13:54.889
In this case it will call a chk_fail from
the routine named with _chk at the end.

00:13:54.889 --> 00:14:00.460
So it's a very distinctive crash report
pack and you'll see which routine

00:14:00.460 --> 00:14:04.930
in your program called the offending string function.

00:14:04.929 --> 00:14:16.049
You can see here, strcpy_chk was the routine
that-- was the routine that would have overflowed.

00:14:16.049 --> 00:14:26.240
So that helps with stack and heap issues but it's still
possible to write your own, but we don't have canaries

00:14:26.240 --> 00:14:30.159
in the heap of the same kind that we have on the stack.

00:14:30.159 --> 00:14:32.589
So we've managed to do something similar.

00:14:32.590 --> 00:14:37.639
For-- here's an example of an attacker
overwriting a buffer in the heap.

00:14:37.639 --> 00:14:42.350
You can see there's a buffer and
then some critical data after that.

00:14:42.350 --> 00:14:49.060
The attacker, because of heap execute protection,
can't simply insert their own code into the heap,

00:14:49.059 --> 00:14:58.199
but if you have critical data in the heap that controls
access controls, permissions whether the data is trusted

00:14:58.200 --> 00:15:06.110
or untrusted, then the attacker can still attempt
to overwrite that, make their data which is coming

00:15:06.110 --> 00:15:09.690
from the network or untrusted place appear to be trusted.

00:15:11.299 --> 00:15:16.209
So the attacker has a buffer, overwrites
past that, past other stuff on the heap

00:15:16.210 --> 00:15:20.450
and overwrites the beginning of your critical data.

00:15:20.450 --> 00:15:25.280
To do this, the attacker might have to overwrite
several blocks on the heap because it's often difficult

00:15:25.279 --> 00:15:30.659
for an attacker to precisely control the heap layout.

00:15:30.659 --> 00:15:33.350
Some of these will be free blocks.

00:15:33.350 --> 00:15:38.070
All, on Mac OS X, all free blocks
contain a small 4-bit checksum

00:15:38.070 --> 00:15:43.250
that prevents-- that attempts to detect heap corruption.

00:15:44.559 --> 00:15:49.479
So, and in addition, the attacker is going
to want the program to continue running.

00:15:49.480 --> 00:15:56.610
He has overwritten your critical data but he still can't
actually exploit your program until you've managed--

00:15:56.610 --> 00:16:02.440
until he is-- until the critical data is actually used
and that might be quite a bit later in the program.

00:16:02.440 --> 00:16:08.500
So the attacker wants to make sure that
memory allocation continues to work.

00:16:08.500 --> 00:16:12.919
In previous versions of the operating
system, this was somewhat easy.

00:16:12.919 --> 00:16:18.309
The attacker could simply ensure
that the checksum was preserved.

00:16:18.309 --> 00:16:23.750
But in Mac OS X Snow Leopard, we
have improved the heap checksum.

00:16:23.750 --> 00:16:25.750
It's now slightly randomized.

00:16:25.750 --> 00:16:30.509
So now, the attacker has to manage to
guess the correct value of the checksum

00:16:30.509 --> 00:16:34.000
and if the attacker fails, again,
your program is terminated.

00:16:34.000 --> 00:16:37.279
This is an especially visible-- helpful in a web browser.

00:16:37.279 --> 00:16:41.639
It's highly unlikely a user is going to sit
there and wait for an attacker to attempt

00:16:41.639 --> 00:16:46.069
to guess the right value restarting
the web browser every time it crashes.

00:16:46.070 --> 00:16:49.890
Eventually the user will realize that this
side is doing something wrong, hopefully,

00:16:49.889 --> 00:16:55.659
and will go and will stop trying to access it.

00:16:55.659 --> 00:16:59.699
This works on 64-bit Snow Leopdard by default.

00:16:59.700 --> 00:17:06.000
On 32-bit Snow Leopard, you-- the heap checksum is
still randomized but your program is not stopped

00:17:06.000 --> 00:17:10.069
so the attacker can still possibly exploit it.

00:17:10.069 --> 00:17:15.429
You can turn on the program termination on
a memory error within environment variable.

00:17:15.430 --> 00:17:21.880
OK. So another feature we've added in
Snow Leopard is administrator versus root.

00:17:21.880 --> 00:17:28.200
The first account created by default, when you
install Snow Leopard for the first time or a Leopard,

00:17:28.200 --> 00:17:32.220
is an administrator account, that is
the account that can control the system.

00:17:32.220 --> 00:17:37.350
And on many systems, only one account is
ever created this and will use the systems.

00:17:37.349 --> 00:17:42.669
The problem with this is that it means,
well, every account is an administrator.

00:17:42.670 --> 00:17:47.730
The design goal for administrator accounts and the
reason we have this administrator-root separation is

00:17:47.730 --> 00:17:53.779
that what we would like to have happen is that
administrators have no extra privileges except

00:17:53.779 --> 00:17:57.500
that they can use their password to become root.

00:17:57.500 --> 00:18:04.200
This adds significant protection against malware because
malware doesn't know the user's password and a prompt

00:18:04.200 --> 00:18:08.450
in the middle coming from nowhere that you
need to enter your administrator password

00:18:08.450 --> 00:18:14.799
to perform this action is a sign
that something is possibly wrong.

00:18:14.799 --> 00:18:20.389
Unfortunately, because of backwards compatibility,
historically many system directories are writable

00:18:20.390 --> 00:18:25.030
by administrators, the root directory and so on.

00:18:25.029 --> 00:18:28.339
On Snow Leopard, we've tightened this up a bit

00:18:28.339 --> 00:18:33.309
In particular, directories inside system
applications, so for example the plug-in directory

00:18:33.309 --> 00:18:38.210
in Safari is no longer writable by administrators.

00:18:38.210 --> 00:18:43.480
We also managed to change the ScriptingAdditions
directory inside /Library.

00:18:43.480 --> 00:18:49.099
In future versions of the operating system,
we do intend to tighten this up more.

00:18:49.099 --> 00:18:51.279
In the long run we would really like the previous--

00:18:51.279 --> 00:18:55.619
the goal stated on the previous slide that
administrator has no extra privileges.

00:18:56.630 --> 00:19:02.870
Unfortunately, we couldn't do all of this at the
Snow Leopard and the principal reason was installers.

00:19:02.869 --> 00:19:09.349
A number of installers-- what an
installer should really do if it has

00:19:09.349 --> 00:19:17.209
to install stuff inside system directories is
authenticate as root using authorization services.

00:19:17.210 --> 00:19:20.509
Unfortunately, some legacy installers didn't do this.

00:19:20.509 --> 00:19:26.269
They relied on being run by an administrator, which
is also something that you don't really want to do,

00:19:26.269 --> 00:19:29.889
and just copied files directly into
this-- into the root directories.

00:19:29.890 --> 00:19:39.009
So it's particularly important that installers
be written to properly authenticate this root

00:19:39.009 --> 00:19:44.450
and that will have the advantage that it means non-root,
non-administrator users can install your program

00:19:44.450 --> 00:19:53.319
by finding an administrator, dragging them over to
the machine and having them type their password.

00:19:53.319 --> 00:19:57.129
OK. So, now let's talk about setuid programs.

00:19:57.130 --> 00:20:06.870
So set-user-ID programs are a UNIX concept
back from the dawn of time or the '60sstyl`Q

00:20:06.869 --> 00:20:16.889
in which a program can be given additional
privileges simply by being executed.

00:20:16.890 --> 00:20:23.750
>> This sets up a trust boundary
between the user and the setuid program.

00:20:23.750 --> 00:20:29.990
But there's a problem with setuid programs
that makes them difficult to write.

00:20:29.990 --> 00:20:41.130
The user has a user which is not as trusted as the setuid
tool, has a lot of access, and if that is an attacker,

00:20:41.130 --> 00:20:43.840
the attacker can get to the setuid tool in a number of ways.

00:20:43.839 --> 00:20:49.449
For example, through usual I/O, right,
standard input standard output files,

00:20:49.450 --> 00:20:54.910
through the command-line arguments passed
to the tool, through environment variables,

00:20:54.910 --> 00:21:02.790
through the working directory, through file descriptors,
through the file mode mask, through interval timers,

00:21:02.789 --> 00:21:06.329
they can set them up and have them
go off after the program is running,

00:21:06.329 --> 00:21:11.859
through the signal masks signals can be
blocked, through Mach ports and so on.

00:21:11.859 --> 00:21:14.250
That's a lot.

00:21:14.250 --> 00:21:22.009
And it turns out, it's really hard to write a program that
defends against every single one of these attack factors.

00:21:22.009 --> 00:21:29.930
[ Pause ]

00:21:29.930 --> 00:21:32.360
>> So, what to do?

00:21:32.359 --> 00:21:39.319
Well, the solution that we found that works
pretty well is, don't use set-user-ID.

00:21:39.319 --> 00:21:43.569
In Snow Leopard, a number of system
applications are no longer using setuid.

00:21:43.569 --> 00:21:54.019
In particular, some frameworks that cannot
safely be used as a setuid program, like AppKit,

00:21:54.019 --> 00:21:57.119
will refuse to start up a program setuid.

00:21:57.119 --> 00:22:03.609
If you have a legacy program that is marked
setuid and uses AppKit, AppKit will prompt--

00:22:03.609 --> 00:22:08.379
will drop all privileges on start and
then prompt for an administrator password.

00:22:08.380 --> 00:22:15.190
If the user successfully authenticates, the program
will then continue to run as the setuid user.

00:22:15.190 --> 00:22:22.269
So this preserves backwards compatibility in an
inconvenient kind of way but ensures security.

00:22:24.579 --> 00:22:33.210
Your executables generally should not be setuid, especially
if they're using AppKitt or any high-level system library.

00:22:33.210 --> 00:22:37.600
Running a setuid program is incredibly
hard and there are better alternatives.

00:22:37.599 --> 00:22:45.369
For example, one alternative that we found works really
well is to split your application up into the application

00:22:45.369 --> 00:22:48.979
which can be untrusted, use the GUI, and a daemon,

00:22:48.980 --> 00:22:59.940
which can be written using only a constrained
set of interfaces and carefully audited.

00:22:59.940 --> 00:23:02.850
So, but how to solve the problem?

00:23:02.849 --> 00:23:07.490
You don't really want to make the daemon
set-user-ID that just repeats the same problem.

00:23:07.490 --> 00:23:12.750
So, the way, the technique that we found
that works really well is to use launchd.

00:23:12.750 --> 00:23:20.549
Launchd is a system service that, when your
application opens a socket or tries to use Mach service,

00:23:20.549 --> 00:23:26.289
can start your daemon in a controlled environment
with environment variables, file descriptors,

00:23:26.289 --> 00:23:34.129
and all the other things that are listed on the previous
limited to just-- limited to a standard configuration.

00:23:34.130 --> 00:23:38.700
Then your application can communicate with
the daemon through the socket or Mach service.

00:23:38.700 --> 00:23:44.039
So there's only one vector into your daemon, stream I/O.

00:23:44.039 --> 00:23:49.170
If you're interested in learning more
about launchd, there's a talk tomorrow.

00:23:49.170 --> 00:23:56.350
And it turns out, it's perfectly possible
to do just about everything this way.

00:23:56.349 --> 00:24:01.139
In fact, on iPhone, there are no setuid programs.

00:24:01.140 --> 00:24:10.509
Everything that needs privileges is started up through
launchd or uses authorization services or another mechanism.

00:24:10.509 --> 00:24:19.690
OK. So, now let's talk about another smaller
hardening feature that we've done in Snow Leopard

00:24:19.690 --> 00:24:24.680
that was prompted by a particular high-profile attack.

00:24:24.680 --> 00:24:32.000
So, there's a network protocol called DNS, the
Domain Name System, whose purpose is to look

00:24:32.000 --> 00:24:35.670
up names-- look up IP addresses given names.

00:24:35.670 --> 00:24:40.789
The actual details of the protocol aren't terribly
important, other than to know that it contains data

00:24:40.789 --> 00:24:46.539
which sometimes is trusted or probably
shouldn't be but sometimes is.

00:24:46.539 --> 00:24:52.460
The key thing about the attack is the way
the Domain Name System protocol works.

00:24:52.460 --> 00:24:56.829
It operates using a UDP, the datagram protocol.

00:24:56.829 --> 00:25:05.980
The application creates a query, sends it off to the server,
the server adds its answer into the query and sends it back,

00:25:05.980 --> 00:25:10.120
so not very unusual for any kind of datagram protocol.

00:25:10.119 --> 00:25:16.599
The problem is that when the application needs
to verify that this was the correct response,

00:25:16.599 --> 00:25:20.059
all it can really check is that it
was sent to and from the right place.

00:25:20.059 --> 00:25:22.710
It has the right host and port, source and destination.

00:25:22.710 --> 00:25:29.350
It can check that it was the answer to the question that's
sent, and it also checks that there is a small query ID,

00:25:29.349 --> 00:25:35.159
a 16-bit query ID and it can check that that
query ID reflects to the right question.

00:25:35.160 --> 00:25:45.180
The problem is, an attacker who wishes to substitute their
own answer can simply create an answer while the remote

00:25:45.180 --> 00:25:55.750
server is creating it, send it back, hopefully faster
than the remote server, and if it gets there first

00:25:55.750 --> 00:26:02.730
and contains all the right values, then the
application will take it as the correct answer.

00:26:02.730 --> 00:26:05.059
The attacker knows many of the values.

00:26:05.059 --> 00:26:10.720
I mean it knows what-- the attacker knows what host
is being attacked and what the correct DNS server is

00:26:10.720 --> 00:26:15.519
and what question was asked because the answer to
that question is what they're trying to substitute.

00:26:15.519 --> 00:26:22.329
So the only remaining parts of the packet that the
attacker might have difficulty creating are the query ID

00:26:22.329 --> 00:26:27.599
which as I said is 16 bits so the attacker might
have to send about 60,000 packets to be sure

00:26:27.599 --> 00:26:37.159
of getting the right query ID, but that's not hard,
60,000 packets isn't a lot of data, and the source port.

00:26:37.160 --> 00:26:43.370
This attack really only works, really only works
sufficiently if the attacker can predict the source port.

00:26:43.369 --> 00:26:46.589
Historically, the source port was
simply created sequentially.

00:26:46.589 --> 00:26:53.250
So if the previous source port was
10,000, the next one would be 10,001.

00:26:53.250 --> 00:27:03.680
To fix this attack in Mac OS X 10.5.7 and Security
Update 2008-09, we simply randomized the source port.

00:27:03.680 --> 00:27:07.789
That doesn't completely prevent it but it means
the attacker has to send about a billion packets

00:27:07.789 --> 00:27:11.730
and that is a substantial amount of data.

00:27:11.730 --> 00:27:17.120
Eventually, of course, the solution is to use
a cryptographic authentication like DNSSEC

00:27:17.119 --> 00:27:21.569
and that will completely prevent the
attack because the attacker cannot,

00:27:21.569 --> 00:27:24.859
hopefully, write the cryptographic protection.

00:27:24.859 --> 00:27:28.969
So, that fixed DNS.

00:27:28.970 --> 00:27:31.110
We we're concerned that there would be other protocols

00:27:31.109 --> 00:27:36.649
that used a very similar query response framework
sending out packets, something like that.

00:27:36.650 --> 00:27:43.140
So on Snow Leopard, UDP ports, the UDP port
number is now randomized for all protocols.

00:27:43.140 --> 00:27:51.720
There is a potential gotcha here, which is that previously
ports were allocated sequentially, now they're random

00:27:51.720 --> 00:27:56.370
and so you might get a port reused
faster than you would previously.

00:27:56.369 --> 00:28:04.049
So if you do have a protocol like this, you
might want to watch for that particular issue.

00:28:05.720 --> 00:28:12.559
So, earlier I talked about some
features that were on by default.

00:28:12.559 --> 00:28:18.319
One feature we've had on by default since
Leopard is system library randomization.

00:28:18.319 --> 00:28:26.939
The idea here is that you have a-- is that even if the
attacker can't inject code directly into your program,

00:28:26.940 --> 00:28:31.160
knowing the layout of the program, the attacker
might be able to chain together a sequence

00:28:31.160 --> 00:28:35.170
of operations that nonetheless does what he wants.

00:28:35.170 --> 00:28:41.420
So, code layout randomization protects
against this to some degree.

00:28:41.420 --> 00:28:51.210
Code layout randomization is not on by default, not
even in Snow Leopard, not even 64-bit but you can--

00:28:51.210 --> 00:28:57.100
But system library randomization is on by
default and you can arrange for your executable

00:28:57.099 --> 00:28:59.679
to be protected using code layout randomization.

00:28:59.680 --> 00:29:06.259
Some system executables are also adopting code layout
randomization in Snow Leopard and you can turn it

00:29:06.259 --> 00:29:08.920
on in Xcode by setting these three settings.

00:29:08.920 --> 00:29:15.519
You need to specify -fpie for both linking
and compiling and you need to make sure

00:29:15.519 --> 00:29:23.309
that your code is not explicitly
generated-position dependent.

00:29:23.309 --> 00:29:31.409
OK. So, all of these as I said help
and-- but they're not perfect protection.

00:29:32.720 --> 00:29:37.569
So suppose that you still have a library
in your application, an old library,

00:29:37.569 --> 00:29:42.289
maybe it came from a third party, maybe
you've had it around for a long time.

00:29:42.289 --> 00:29:48.000
It's performance-critical possibly,
you can't really rewrite it, it's got--

00:29:48.000 --> 00:29:55.579
it has the possibility of having a
security vulnerability and worse than that,

00:29:55.579 --> 00:30:00.569
it also processes untrusted data
that comes from the network perhaps.

00:30:00.569 --> 00:30:10.220
So, if an attacker can attack this library, the attacker can
obviously control its behavior but since your application is

00:30:10.220 --> 00:30:13.640
in the same address space, the
attacker can't control your application.

00:30:13.640 --> 00:30:17.120
>> And because your application is running as the user,

00:30:17.119 --> 00:30:24.859
the attacker can also expand his control
to take over the entire user account.

00:30:24.859 --> 00:30:30.319
So to prevent this we have since
Leopard a sandboxing feature.

00:30:30.319 --> 00:30:35.319
And by-- And the sandbox feature is
by the way on by default on iPhone.

00:30:35.319 --> 00:30:41.319
You as a developer can turn this on in
your program using the sandbox_init API.

00:30:41.319 --> 00:30:48.329
There are five sandboxes available but
four of those are less recommended.

00:30:48.329 --> 00:30:54.679
The one that you really want to be using is the pure
computation only sandbox which prevents all access

00:30:54.680 --> 00:30:59.549
to system functionality except for reading
and writing to files that are already open.

00:30:59.549 --> 00:31:04.159
This is ideal for, for example, a file format converter.

00:31:04.160 --> 00:31:10.610
You might have a legacy file format and the code to
interpret it that was written a long time ago by people who,

00:31:10.609 --> 00:31:14.750
you know, are no longer willing to maintain
it and don't have the time if they did.

00:31:16.349 --> 00:31:21.689
And their format might still be
accepted from, for example, the network.

00:31:21.690 --> 00:31:26.120
So you can put your converter into a sandbox.

00:31:26.119 --> 00:31:35.119
A separate process that doesn't-- that is limited to pure
computation only, your application can communicate with that

00:31:35.119 --> 00:31:43.529
through a pipe or a limited communication method and
you can carefully audit what your application does--

00:31:43.529 --> 00:31:46.629
what your application will accept from that pipe.

00:31:46.630 --> 00:31:53.330
That way if an attacker attempts to control the behavior
of the library because it has a security vulnerability,

00:31:53.329 --> 00:32:01.539
well they can do that but they can't escape the sandbox to
control your application or take over the user's account.

00:32:01.539 --> 00:32:09.319
In the future we may be able to add custom sandboxes
but they are not yet available in Snow Leopard.

00:32:09.319 --> 00:32:18.409
Anything that you might see in Leopard is-- in Leopard or
Snow Leopard, along that line, is not a documented API yet.

00:32:18.410 --> 00:32:26.740
One example where we've used this functionality
is the H.264 Decoder library that takes in a movie

00:32:26.740 --> 00:32:29.680
from the internet possibly or some other untrusted source.

00:32:29.680 --> 00:32:32.650
It's got to be very high performance.

00:32:32.650 --> 00:32:38.410
The code is, and as a result the
code is now very complicated

00:32:38.410 --> 00:32:41.550
and we've fixed a lot of security vulnerabilities in it.

00:32:41.549 --> 00:32:46.940
Hopefully, we've got them all but
there might still be one or more.

00:32:46.940 --> 00:32:51.950
And, but we now have it inside a
sandbox so all an attacker can do

00:32:51.950 --> 00:32:57.759
who can supply a movie is control what the movie
looks like, which they could have done before.

00:32:57.759 --> 00:33:05.589
And so, now I'll be handing you over
to Drew to talk about crash reports.

00:33:05.589 --> 00:33:06.899
>> Thanks Jeff.

00:33:06.900 --> 00:33:11.980
Hi I'm Drew Yao and I'm going to be
talking about crash exploitability triage.

00:33:11.980 --> 00:33:15.599
What that means is being able to
quickly and accurately determine whether

00:33:15.599 --> 00:33:22.199
or not a given crash represents a security issue, or
I mean exploitable security issue or just a crash.

00:33:22.200 --> 00:33:29.009
This is important because we need to be able to
determine whether or not it's exploitable because we need

00:33:29.009 --> 00:33:33.839
to prioritize the exploitable ones to be fixed much quicker.

00:33:33.839 --> 00:33:39.089
So I'm going to be talking about
doing it using both automated tools.

00:33:39.089 --> 00:33:44.500
There's a tool named CrashWrangler which
we've developed that I'll be describing.

00:33:44.500 --> 00:33:49.480
And also using manual means either
crash logs, looking at crash logs,

00:33:49.480 --> 00:33:54.200
or by looking at the processor--
the processor and the debugger.

00:33:54.200 --> 00:33:58.580
Before I talk about the how of how the crash triage works.

00:33:58.579 --> 00:34:05.490
I want to talk about the why, at least the original
motivation for developing CrashWrangler and that's fuzzing.

00:34:05.490 --> 00:34:16.179
Fuzzing is a technique in which we use automation to feed
malformed input to the program and try to get it to crash.

00:34:16.179 --> 00:34:19.599
Fuzzing is a primary tool for hackers
because it's a black box technique.

00:34:19.599 --> 00:34:21.699
It doesn't require any source code.

00:34:21.699 --> 00:34:28.679
It doesn't require any debugging symbols and
it's fairly easy to create and to run fuzzers.

00:34:28.679 --> 00:34:31.579
Attackers are actively fuzzing many commercial products.

00:34:31.579 --> 00:34:40.219
We know that many of the reports that we get that are
external that are security issues were found by fuzzing.

00:34:40.219 --> 00:34:48.439
By using fuzzing, we can find the same or similar bugs
and fix them, often even before the product is released.

00:34:48.440 --> 00:34:54.679
So to give you a more concrete example of
how fuzzing might work, at least an example,

00:34:54.679 --> 00:34:57.909
is let's say we want to find bugs in QuickTime.

00:34:57.909 --> 00:35:07.149
What we can do is download a movie file and for each of
the files, we apply some noise to some field in the file

00:35:07.150 --> 00:35:13.369
by which I mean we'll write some random bytes over
an area in the file leaving most of the file valid.

00:35:13.369 --> 00:35:15.900
So there's just a little bit that's malformed.

00:35:15.900 --> 00:35:22.400
And it's bad enough that it might break stuff but
good enough that it can get by many validation checks.

00:35:22.400 --> 00:35:27.030
So for each of these files, what we can do is send
it to QuickTime by playing it in QuickTime Player

00:35:27.030 --> 00:35:33.230
and then it will either crash like
this one or it won't crash.

00:35:33.230 --> 00:35:37.210
Some crash, some don't.

00:35:37.210 --> 00:35:40.550
Once we have these three crashes, we have some challenges.

00:35:40.550 --> 00:35:44.830
One is we need to figure out which
of these crashes are duplicates,

00:35:44.829 --> 00:35:48.759
that is we only care about the number
of unique bugs that we have found.

00:35:48.760 --> 00:35:55.510
It's quite possible that many of the test cases
that we generate actually all trigger the same bug.

00:35:55.510 --> 00:36:01.920
So by figuring out which ones of these crashes are
duplicates, we know how many unique bugs we have.

00:36:01.920 --> 00:36:05.639
We also need to know which ones are
exploitable because we need to prioritize them.

00:36:05.639 --> 00:36:08.159
The exploitable ones need to be fixed much sooner.

00:36:08.159 --> 00:36:14.549
When we just had those three bugs it was not that
big of deal, but if we have these many, many,

00:36:14.550 --> 00:36:19.769
many cases or many crashes like
if we have say a thousand crashes,

00:36:19.769 --> 00:36:28.190
we might generate using a hundred thousand test cases then
it becomes much more difficult to handle those challenges

00:36:28.190 --> 00:36:32.769
that I mentioned earlier, determining
duplicates and determining exploitability.

00:36:32.769 --> 00:36:35.110
So some kind of automation was necessary.

00:36:35.110 --> 00:36:37.780
So this is the problem.

00:36:37.780 --> 00:36:40.650
CrashWrangler is the solution.

00:36:40.650 --> 00:36:45.650
CrashWrangler is a tool which runs
on Mac OS X 10.5 and 10.6.

00:36:45.650 --> 00:36:51.889
It doesn't currently run on iPhone but I will be
describing some manual techniques that you can use later

00:36:51.889 --> 00:36:55.529
in the talk and these do apply to iPhone.

00:36:55.530 --> 00:36:59.490
CrashWrangler automatically handles
those challenges I mentioned earlier.

00:36:59.489 --> 00:37:02.979
It determines exploitability and
whether or not it's a duplicate.

00:37:02.980 --> 00:37:09.159
It uses heuristics which is a fancy word for
guessing, so it's not 100 percent accurate.

00:37:09.159 --> 00:37:12.819
It may think something is exploitable
when it's not or vice versa.

00:37:12.820 --> 00:37:15.990
But overall I found it to be about 99 percent accurate.

00:37:15.989 --> 00:37:19.379
And it will be made generally available
at some point in the near future.

00:37:19.380 --> 00:37:22.059
That is to anyone with an ADC account.

00:37:22.059 --> 00:37:28.750
It should be on the attendee site for the session
now or at least sometime in the very near future.

00:37:28.750 --> 00:37:38.809
How it works is it's a Mach exception handler which
forks and execs a process and if the process--

00:37:38.809 --> 00:37:44.820
the child process crashes it will examine the state of
the process at the time of the crash and output a log file

00:37:44.820 --> 00:37:49.100
which contains some diagnosis of
the exploitability of the crash.

00:37:49.099 --> 00:37:53.259
Once we have a few of these log files, then there's a script

00:37:53.260 --> 00:37:57.430
which can analyze logs to determine
which ones are duplicates.

00:37:57.429 --> 00:38:05.779
As I mentioned earlier, it's useful for fuzzing but it's
also useful for simply screening like a one-off crash.

00:38:05.780 --> 00:38:11.450
Let's say you get a report of a crash and it is
reproducible, what you can do is just use the tool

00:38:11.449 --> 00:38:15.230
to automatically quickly determine
whether or not it's exploitable.

00:38:15.230 --> 00:38:20.019
The benefit of this is that it
doesn't require any lengthy debugging.

00:38:20.019 --> 00:38:23.860
It doesn't require the person who wrote
the code to actually figure this out.

00:38:23.860 --> 00:38:27.579
So it can be done by a screener or a QA person.

00:38:27.579 --> 00:38:35.519
So now I'd like to do a demo.

00:38:35.519 --> 00:38:38.320
OK. The first thing I would like to show you is just--

00:38:38.320 --> 00:38:46.710
I'm going to configure it using an environment variable
called CW current case and we'll just call this foo

00:38:46.710 --> 00:38:51.159
and I'm running an exception handler
named Exception Handler.

00:38:51.159 --> 00:38:59.679
And I'm passing it the argument of a program name that's
called DIV 0 and DIV 0 is just a very simple sample program

00:38:59.679 --> 00:39:04.609
that causes a crash by a divided by 0 exception.

00:39:04.610 --> 00:39:11.280
So when I run that, it prints out
the-- that trace of the crashing thread

00:39:11.280 --> 00:39:14.570
and it prints out some diagnosis information.

00:39:14.570 --> 00:39:21.160
One thing we note here is that the name of the
crash log is foo.crashlog.txt which came from here.

00:39:21.159 --> 00:39:26.599
And we see here that it's marked is exploitable=no.

00:39:26.599 --> 00:39:30.889
I'll do the same thing but I'll call it foo2.

00:39:30.889 --> 00:39:36.750
And just the name of the crash log is different.

00:39:36.750 --> 00:39:41.010
And then I'll do one more.

00:39:41.010 --> 00:39:50.000
[ Pause ]

00:39:50.000 --> 00:39:58.300
>> This one is considered to be exploitable
because of the fact that it aborted in free

00:39:58.300 --> 00:40:04.010
which indicates maybe some heap corruption
was detected and now that I have these,

00:40:04.010 --> 00:40:08.880
I can run a script which detects
whether or not they're duplicates.

00:40:08.880 --> 00:40:10.829
So, this one stands by itself.

00:40:10.829 --> 00:40:17.090
These two, foo and foo2 are marked
as duplicates of each other.

00:40:17.090 --> 00:40:23.870
>> When we have a tool like this it's no
fun to just run it on a sample test program.

00:40:23.869 --> 00:40:31.859
So I also have a real test case.

00:40:31.860 --> 00:40:41.309
It's running a movie file in QuickTime
Player, oops, which causes a crash.

00:40:41.309 --> 00:40:46.630
It's not considered exploitable.

00:40:46.630 --> 00:40:55.680
And each of these crash logs that come out
is basically it has this header at the top

00:40:55.679 --> 00:41:05.000
which includes the is exploitable field and then following
that is just simply a normal crash reporter crash log.

00:41:05.000 --> 00:41:13.949
So, how that script that I just ran
works is it has some magic in it

00:41:13.949 --> 00:41:16.009
but basically we'll be doing something like this.

00:41:16.010 --> 00:41:30.560
[ Pause ]

00:41:30.559 --> 00:41:35.130
>> Setting the log name to be a certain-- the name of
the file running exception handler and passing the name

00:41:35.130 --> 00:41:36.700
of the program and passing an argument to the program.

00:41:36.699 --> 00:41:39.009
Or actually you can see that it's
just running the program normally.

00:41:39.010 --> 00:41:54.060
[ Pause ]

00:41:54.059 --> 00:41:59.460
>> As soon as it crashes-- ah,
I have to remember to play it.

00:41:59.460 --> 00:42:06.530
As soon as it crashes it prints out
the same-- the stuff, the information.

00:42:06.530 --> 00:42:12.350
So it's pretty simple to run and it can be used for
fuzzing very simply or just for one-off crashes.

00:42:12.349 --> 00:42:20.150
OK. Back to the slides.

00:42:20.150 --> 00:42:25.269
Once we have this tool, we also-- it's still
useful to know how to do the same things manually.

00:42:25.269 --> 00:42:33.759
Both because manually there's different things that you
can do that an automated tool can't do and also because,

00:42:33.760 --> 00:42:37.860
for example, you can use manual
techniques to examine an iPhone crash.

00:42:37.860 --> 00:42:44.110
When I talk about exploitability up here, I'm
only talking about arbitrary code execution.

00:42:44.110 --> 00:42:49.140
I'm not talking about any other bugs like
denial of service or information disclosure.

00:42:49.139 --> 00:42:53.210
The reason is that arbitrary code
execution is one of the easiest ones

00:42:53.210 --> 00:42:56.079
to detect simply and without access to source code.

00:42:56.079 --> 00:43:01.590
But what we're looking for is just
a very limited number of things.

00:43:01.590 --> 00:43:06.900
And I also should mention that if the crash is triggered
by trusted input, it's not considered exploitable.

00:43:06.900 --> 00:43:12.639
That is, let's say for example we have a buffer
overflow that can only be triggered by the root user.

00:43:12.639 --> 00:43:17.650
Even though it can be used for arbitrary code execution,
it's not considered to be an exploitable security issue

00:43:17.650 --> 00:43:21.809
because the root user can already
do whatever he wants anyways.

00:43:21.809 --> 00:43:23.820
So that's just something to keep in mind.

00:43:23.820 --> 00:43:30.870
When we're talking about exploitable crashes, we're
pretty much always talking about memory corruption.

00:43:30.869 --> 00:43:38.170
There are other security bugs like some shell injection,
for example, that don't involve memory corruption,

00:43:38.170 --> 00:43:44.220
but when we're looking at crashes, it's almost always
memory corruption, which I'm going to define as writing

00:43:44.219 --> 00:43:46.459
where you aren't supposed to be able to write.

00:43:46.460 --> 00:43:54.000
This includes be-- or writing past the end of the buffer
with a buffer overflow or writing to an arbitrary pointer,

00:43:54.000 --> 00:43:59.019
maybe you control it, maybe you don't,
or including writing to freed memory.

00:43:59.019 --> 00:44:04.929
Because if the memory is freed, then maybe another thread
will allocate it and will be using it for something

00:44:04.929 --> 00:44:09.619
and you'll be modifying the behavior
of the program in unexpected ways.

00:44:09.619 --> 00:44:14.150
Memory corruption often allows the attacker
to alter the control flow of the program.

00:44:14.150 --> 00:44:19.840
If the attacker can overwrite a function
pointer or the return address on the stack,

00:44:19.840 --> 00:44:26.450
the attacker can get arbitrary code execution and even
just by overwriting a variable in memory, for example,

00:44:26.449 --> 00:44:31.509
if we have a server that has a variable
in memory that determines whether

00:44:31.510 --> 00:44:36.960
or not a given connection is authenticated, then if
the attacker can overwrite that variable in memory,

00:44:36.960 --> 00:44:45.970
he can cause the program to think that his session
is authenticated and thus gain privileges that way.

00:44:45.969 --> 00:44:50.609
It's important to note that any memory
corruption is considered to be exploitable,

00:44:50.610 --> 00:44:54.420
not just controlled buffer overflows
where you control exactly the amount

00:44:54.420 --> 00:44:57.079
that gets written and the values that get written.

00:44:57.079 --> 00:45:03.819
So, for example, also very large buffer overflows where
you don't control the number of bytes that get written

00:45:03.820 --> 00:45:10.460
or byte swapping after the end of a buffer where you don't
control the values that are getting written or bzeroing,

00:45:10.460 --> 00:45:13.670
writing no bytes, same thing, or using after free.

00:45:13.670 --> 00:45:21.840
Even though maybe you don't control who else is writing to
this buffer that has been freed, it's still maybe possible

00:45:21.840 --> 00:45:28.570
in some instances and we found that attackers are very
resourceful in exploiting any kind of memory corruption

00:45:28.570 --> 00:45:35.440
and a lot of times there were bugs that people
thought were not exploitable and they turn out to be.

00:45:35.440 --> 00:45:40.300
Once we understand that we're looking for memory
corruption, we need to know how to determine

00:45:40.300 --> 00:45:42.400
if a crash was caused by memory corruption.

00:45:42.400 --> 00:45:46.110
We're going to divide the crashes or
the types of crashes into three classes.

00:45:46.110 --> 00:45:51.130
The first one is crashes where it's very likely
that they were caused by memory corruption.

00:45:51.130 --> 00:45:55.140
The first is stack corruption.

00:45:55.139 --> 00:46:00.690
In the case that the return address has been overwritten,
we're looking for executing an invalid address.

00:46:00.690 --> 00:46:06.460
So first we're looking for the question marks on
the left indicating that the module that the--

00:46:06.460 --> 00:46:10.840
of the instruction that crashed was not known.

00:46:10.840 --> 00:46:14.079
It's not any known library or executable name.

00:46:14.079 --> 00:46:17.389
On the right, we see that there's a
zero plus some number which indicates

00:46:17.389 --> 00:46:23.019
that symbolication could not figure
out what function the crash was in.

00:46:23.019 --> 00:46:29.289
And we also see here that the access address
at the top, that is the crash that caused the--

00:46:29.289 --> 00:46:35.380
or the address that caused the crash, is the
same as the executing address here at the bottom.

00:46:35.380 --> 00:46:40.119
They're both 41414141.

00:46:40.119 --> 00:46:43.069
And thus we see that we're executing an invalid address.

00:46:43.070 --> 00:46:48.920
Specific to stack corruptions, we also are looking
for a stack trace in which there's only one entry.

00:46:48.920 --> 00:46:57.159
And the reason is that if the stack has been corrupted,
it's going to be impossible to get a proper back trace.

00:46:57.159 --> 00:47:03.239
If we overwrite a function pointer then it's
possible to jump to some code that's invalid

00:47:03.239 --> 00:47:07.009
and this will result in an illegal instruction exception.

00:47:08.440 --> 00:47:11.389
Geoff mentioned the -fstack-protector flag earlier.

00:47:11.389 --> 00:47:17.609
In the case where you have a very, very large
stack buffer overflow, what it looks like is this.

00:47:17.610 --> 00:47:22.220
There is an abort-- there's a stack_chk_fail
and a crash in strlen.

00:47:22.219 --> 00:47:29.779
And what is happening there is that because stack_chk_fail
calls this log and eventually the strlen is being used

00:47:29.780 --> 00:47:32.890
on some corrupted memory causes the crash.

00:47:32.889 --> 00:47:37.759
But if there's a relatively small overflow
then what happens is you'll see an abort

00:47:37.760 --> 00:47:42.070
in release_file_streams_for_task in Snow Leopard anyways.

00:47:42.070 --> 00:47:45.900
As Geoff mentioned, there's a bug in
the symbolication and so it happens

00:47:45.900 --> 00:47:49.630
that release_file_streams_for_task
is immediately after stack_chk_fail.

00:47:49.630 --> 00:47:56.970
On Leopard, they function immediately after its
append_int, so that's another one to look out for.

00:47:56.969 --> 00:48:05.309
Geoff also talked about the _FORTIFY_SOURCE where the
standard C Library functions will be replaced by one

00:48:05.309 --> 00:48:11.170
with the _chk suffix and it will abort
if a buffer overflow would have happened.

00:48:11.170 --> 00:48:15.579
So what we're looking for here is an
abort with some standard C Library

00:48:15.579 --> 00:48:21.150
and then our standard C Library function and then _chk.

00:48:21.150 --> 00:48:24.869
There's also a MallocCorruptionAbort
which is new in Snow Leopard.

00:48:24.869 --> 00:48:32.130
It's on by default in 64-bit and it can be turned on on
32-bit with an environment variable, MallocCorruptionAbort.

00:48:32.130 --> 00:48:38.260
And it aborts if heap corruption is detected and
that would indicate that the heap has been smashed

00:48:38.260 --> 00:48:40.150
by some kind of buffer overflow or something.

00:48:40.150 --> 00:48:47.119
What we're looking for here is an abort in szone_error and
we also see looking at the application-specific information

00:48:47.119 --> 00:48:52.009
that it indicates the some freed
object may have been overwritten.

00:48:52.010 --> 00:48:59.240
In general, any crash in malloc/free
or the Objective-C runtime indicates

00:48:59.239 --> 00:49:01.719
that some kind of heap corruption has happened.

00:49:01.719 --> 00:49:05.669
If we assume that these functions don't
have any crash bugs in themselves,

00:49:05.670 --> 00:49:09.420
the only possibility is that heap was corrupted.

00:49:09.420 --> 00:49:16.559
Specifically, with objc_msgSend one common
cause of crashes is, well, heap corruption

00:49:16.559 --> 00:49:25.170
but also if the object was released and then sent
a message and some new stuff happened to be there.

00:49:25.170 --> 00:49:30.260
This is considered exploitable if the
input-- if it's triggered by untrusted input.

00:49:30.260 --> 00:49:36.750
And the reason is that having-- a method called
an Objective-C is basically through a few layers

00:49:36.750 --> 00:49:39.650
of indirection, it's a call through a function pointer.

00:49:39.650 --> 00:49:45.980
So if the attacker can control the object that message get
sent to, the attacker can get arbitrary code execution.

00:49:45.980 --> 00:49:52.570
A write to an invalid address would indicate
that if the attacker could control the address

00:49:52.570 --> 00:49:55.200
that gets written to, number corruption would be possible.

00:49:55.199 --> 00:50:01.109
It's not possible to tell if the crash was
on the write by looking at the crash log.

00:50:01.110 --> 00:50:05.950
What we can do is in a debugger you can look
at the disassembling of the program in GDB.

00:50:05.949 --> 00:50:13.089
You can do x/i $pc, which means examine
one instruction at the program counter.

00:50:13.090 --> 00:50:16.410
>> And you kind of have to know assembly
language to know whether it's not--

00:50:16.409 --> 00:50:23.420
it's a read or a write, but a simple mnemonic
for Intel is we're looking for the parenthesis

00:50:23.420 --> 00:50:26.050
around the right operand, the operand on the right.

00:50:26.050 --> 00:50:34.340
So if the right operand has parentheses,
then it's a write access, W-R-I-T-E, write.

00:50:34.340 --> 00:50:38.829
Executing in a valid address would also indicate that some
kind of function point or something has been overwritten.

00:50:38.829 --> 00:50:43.509
It's very similar to what I mentioned
earlier with the stack corruption.

00:50:43.510 --> 00:50:49.300
We're looking for symbolication failing and
accessing the same address that's executing.

00:50:49.300 --> 00:50:56.539
But unlike the stack corruption we have a valid stack trace.

00:50:56.539 --> 00:51:01.159
Calling invalid address is very
similar but you can't, again,

00:51:01.159 --> 00:51:05.409
you can't tell that this was happening
just by looking at the crash log.

00:51:05.409 --> 00:51:06.859
So you need to do a disassembly.

00:51:06.860 --> 00:51:11.660
And what we're looking for here is a call
instruction where we're calling an invalid register

00:51:11.659 --> 00:51:16.069
or a register pointing to invalid memory.

00:51:16.070 --> 00:51:21.269
Another very common indicator of heap corruption or
memory corruption is when you get a different crash

00:51:21.269 --> 00:51:24.269
for the same test case, a different crash each time you run.

00:51:24.269 --> 00:51:27.019
And this is because each time you run the test case,

00:51:27.019 --> 00:51:31.840
it's overwriting something different
because of different timing or whatever.

00:51:31.840 --> 00:51:36.510
So each time you run it, something else has been
overwritten and it doesn't crash immediately.

00:51:36.510 --> 00:51:41.750
It crashes some point later when that
thing that was overwritten gets used.

00:51:41.750 --> 00:51:45.650
To help find out where the real
bug is, it's very useful to run

00:51:45.650 --> 00:51:50.650
with libgmalloc a.k.a. Guard Malloc
which I'll be talking about more later.

00:51:50.650 --> 00:52:00.450
There's another class of crashes where they're
very unlikely to be caused by memory corruption.

00:52:00.449 --> 00:52:02.750
One would be divide by zero.

00:52:02.750 --> 00:52:06.980
Very simple, you're looking for the arithmetic exception.

00:52:06.980 --> 00:52:10.099
Another would be recursion.

00:52:10.099 --> 00:52:17.670
When every time you call a function it pushes a little
bit more data onto the stack which grows down in memory,

00:52:17.670 --> 00:52:21.300
eventually, if it grows too large
it will hit a guard page and crash.

00:52:21.300 --> 00:52:26.030
Since there is a guard page protecting
the rest of the address space,

00:52:26.030 --> 00:52:33.280
it's not considered to be a memory corruption crash because
it's guarded with all those crash, at least in most cases.

00:52:33.280 --> 00:52:38.050
So what we're looking for here is a
very long stack trace with repetition.

00:52:38.050 --> 00:52:42.519
That is, we see here foo is repeated many times.

00:52:42.519 --> 00:52:49.449
One thing to look out for with the recursion stack overflow
is that if you do a disassembly of the crashing instruction,

00:52:49.449 --> 00:52:54.519
it's common that you'll see a crash on a call
instruction and you might be tempted to think

00:52:54.519 --> 00:53:01.969
that it's calling an invalid address
and it's an exploitable issue.

00:53:01.969 --> 00:53:07.250
But what you'll notice in this case is that we see
here it's calling foo which is a valid function.

00:53:07.250 --> 00:53:11.710
So what you need to understand about the call
instruction on Intel is that it has two parts.

00:53:11.710 --> 00:53:17.720
The first part is it pushes the return address onto
the stack and the second part is it calls or it jumps

00:53:17.719 --> 00:53:20.449
to the function that it's trying to call.

00:53:20.449 --> 00:53:22.460
If it's crashing on the first half, they're pushing

00:53:22.460 --> 00:53:28.900
onto the stack then it's not an
exploitable issue, it's just recursion.

00:53:28.900 --> 00:53:35.329
So the way that you tell again is at the top, the
non-exploitable one is calling a valid function.

00:53:35.329 --> 00:53:41.940
At the bottom you see the-- it's calling
with a register, that's EAX here.

00:53:41.940 --> 00:53:44.860
In general, aborts are not exploitable.

00:53:44.860 --> 00:53:50.240
Aside from the ones that I've mentioned earlier,
the -fstack-protector, the _FORTIFY_SOURCE,

00:53:50.239 --> 00:53:57.779
and MallocCorruptionAbort, so yeah, just any
other one would generally not be exploitable.

00:53:57.780 --> 00:54:06.010
There's also another class where they are considered to
be improbable but more investigation may be warranted.

00:54:06.010 --> 00:54:13.550
One would be a null dereference, we're
looking for an access near zero or at zero.

00:54:13.550 --> 00:54:21.440
One thing you have to look out for is that you-- if there's
accessing an offset of a null pointer you need to make sure

00:54:21.440 --> 00:54:24.909
that the offset can't reach outside
the bounds of the null page.

00:54:24.909 --> 00:54:28.569
That is on 32-bit, there is a page
defined at the zero address

00:54:28.570 --> 00:54:32.059
that has a protection such that
you can't read or write to it.

00:54:32.059 --> 00:54:40.759
On 64-bit, there's a whole 4-gigabyte area near the
null address where you can't read or write to it.

00:54:40.760 --> 00:54:47.680
If we have a null pointer here called buff and we're
accessing the offset of it that is attacker controlled,

00:54:47.679 --> 00:54:54.119
it may be possible to write to any
address, zero plus some crazy number.

00:54:54.119 --> 00:54:56.969
So this one could be exploitable.

00:54:56.969 --> 00:55:04.529
The second one is-- would not be considered exploitable
because it's accessing the offset zero of the null pointer.

00:55:04.530 --> 00:55:09.320
And the third one, accessing the member of
a struct usually would not be exploitable

00:55:09.320 --> 00:55:15.850
because a struct would not be big enough to reach
outside of the null page or the null area on 64-bit,

00:55:15.849 --> 00:55:18.110
but it may be possible with a sufficiently large struct.

00:55:18.110 --> 00:55:25.329
A read out of bounds is again usually
not a memory corruption issue.

00:55:25.329 --> 00:55:33.130
For Intel we're looking at the left
operand having parentheses around it.

00:55:33.130 --> 00:55:39.599
They are potentially exploitable though, for example if we
had some kind of memory corruption that overrode a pointer

00:55:39.599 --> 00:55:44.539
and then we read from the pointer, well
the crash was caused by memory corruption.

00:55:44.539 --> 00:55:48.559
So a good way to quickly check if it might
be memory corruption is to run it again

00:55:48.559 --> 00:55:51.940
with libgmalloc which again I'll talk about later.

00:55:51.940 --> 00:55:56.650
There is also a potential information disclosure
bug with the reading out of bounds which is

00:55:56.650 --> 00:56:01.410
if you're reading some memory that you shouldn't have
access to and then you send that buffer to the attacker,

00:56:01.409 --> 00:56:05.500
then the attacker has some information
he shouldn't have access to.

00:56:05.500 --> 00:56:10.969
This is generally difficult to diagnose
very quickly, so enough said about that.

00:56:10.969 --> 00:56:16.269
I should also note that overread, overreading
followed by overwriting is possible

00:56:16.269 --> 00:56:18.869
and that it should be considered exploitable.

00:56:18.869 --> 00:56:23.960
For example in this code sample here, we
have a buffer that's allocated a certain size

00:56:23.960 --> 00:56:26.260
and we're byte swapping past the end of it.

00:56:26.260 --> 00:56:34.230
What a byte swap is, is it's reading from a certain
address in memory, flipping that data in the register

00:56:34.230 --> 00:56:36.949
and then writing it back out to the same address.

00:56:36.949 --> 00:56:39.389
So because there is writing happening,

00:56:39.389 --> 00:56:43.940
this would be considered memory corruption
and this is something to look out for.

00:56:43.940 --> 00:56:48.240
There is an option for libgmalloc called
MALLOC_ALLOW_READS which I'll be talking

00:56:48.239 --> 00:56:50.759
about later which helps deal with this issue.

00:56:50.760 --> 00:56:57.930
When looking at CrashWrangler versus
Manual Assessment, there are--

00:56:57.929 --> 00:57:02.059
CrashWrangler can pretty much do everything that
Manual Assessment can do in terms of determining

00:57:02.059 --> 00:57:05.630
if the bug is a memory corruption bug or not.

00:57:05.630 --> 00:57:13.280
What it can't do is to determine the trust level of the
input which is just something that the user should be able

00:57:13.280 --> 00:57:19.240
to tell and it also can't diagnose other kinds
of security issues other than memory corruption.

00:57:19.239 --> 00:57:29.729
There are also some memory tools which are useful in doing
crash triage and these are listed in the malloc main page.

00:57:29.730 --> 00:57:37.300
One is MallocScribble which writes-- when you allocate
a new buffer on the heap, it will fill the buffer

00:57:37.300 --> 00:57:45.280
up with OXAA bytes and when you free a buffer, it
will overwrite the whole buffer with OX55 bytes.

00:57:45.280 --> 00:57:54.430
So if you get a crash accessing OXAAAA or OX55555,
then you kind of understand the cause to some degree.

00:57:54.429 --> 00:58:01.059
There is also MallocGuardEdges which puts a guard page
after every large buffer and so if you write past the end

00:58:01.059 --> 00:58:05.739
of the large buffer, it will crash immediately
and you'll know what's going on there.

00:58:05.739 --> 00:58:11.989
And MallocCorruptionAbort which I mentioned earlier
which crashes if a heap corruption is detected.

00:58:11.989 --> 00:58:20.169
Now all of these are fairly lightweight, so when doing
testing, it's possible to just leave them on all the time.

00:58:20.170 --> 00:58:28.650
libgmalloc is a much more heavyweight tool which you could
check out the main page for, it's a.k.a. Guard Malloc

00:58:28.650 --> 00:58:32.110
and what it does is it puts a guard
page after each allocation

00:58:32.110 --> 00:58:36.210
and it also unmaps each allocation when you free it.

00:58:36.210 --> 00:58:44.220
So when you access either after at the end of the buffer
or if you access freed memory, it will crash immediately.

00:58:44.219 --> 00:58:51.369
This is as opposed to the cases where memory
corruption happens but it didn't crash until much later.

00:58:51.369 --> 00:58:57.989
The downside is that it's extremely slow,
approximately 20 times slower than running normally

00:58:57.989 --> 00:59:02.339
so you wouldn't want it all the time on all the time and
you also probably wouldn't ever want it on all the time

00:59:02.340 --> 00:59:07.360
when doing testing but you can use it when there's a
question, when you're unsure about the exploitability

00:59:07.360 --> 00:59:12.160
of an issue and this will usually be
in the cases that I described last

00:59:12.159 --> 00:59:16.099
which were the probably not exploitable but maybe.

00:59:16.099 --> 00:59:20.809
I also should mention the MALLOC_ALLOW_READS
environment variable.

00:59:20.809 --> 00:59:28.159
What that is is it sets the page, the guard page,
after each allocation to be readable but not writable.

00:59:28.159 --> 00:59:34.629
So in the case of the byte swapping for example, if you read
past the end of the buffer, it won't crash but then as soon

00:59:34.630 --> 00:59:38.599
as you write pass the end of the buffer it will
crash and since you see the crash on the right,

00:59:38.599 --> 00:59:42.299
you'll know that it is a memory corruption
issue that's potentially exploitable.

00:59:42.300 --> 00:59:49.050
To summarize the whole process for working
through the exploitability, if it's

00:59:49.050 --> 00:59:53.280
if the crash was caused by stack
corruption, illegal instruction,

00:59:53.280 --> 00:59:57.980
or crash on execute or write, we'll call it exploitable.

00:59:57.980 --> 01:00:03.110
If it was caused by divide by zero or recursion,
we'll call it not exploitable, probably.

01:00:03.110 --> 01:00:12.280
If it was caused by a crash on read, null dereference, or
abort, the first thing we'll do is look in the stack trace

01:00:12.280 --> 01:00:17.260
and try to see if there are any of those magic
functions in the back trace of the crashed thread,

01:00:17.260 --> 01:00:24.620
for example malloc/free or stack_chk_fail, and these
would indicate that it is potentially exploitable.

01:00:24.619 --> 01:00:31.670
>> And I should note that with regards to the hardening
features like stack_chk_fail or _FORTIFY_SOURCE,

01:00:31.670 --> 01:00:37.050
even though the overflow was detected in this
case, it should still be considered exploitable

01:00:37.050 --> 01:00:42.070
because there may be some way to work around
the hardening feature or something like that.

01:00:42.070 --> 01:00:48.309
It's still a very dangerous thing to leave in your
code so it still would be high priority to fix.

01:00:48.309 --> 01:00:54.409
If the crash did not have any of those functions in the
stack trace, then we can run it again with libgmalloc.

01:00:54.409 --> 01:00:59.589
If it crashes with the same crash that
is crash on read, null dereference

01:00:59.590 --> 01:01:03.160
or abort, then we'll just call not exploitable.

01:01:03.159 --> 01:01:07.339
But if it crashes with the different crash,
then we'll run through the whole process again.

01:01:07.340 --> 01:01:16.690
So overall, this is not that complicated of a procedure but
I found it to be pretty accurate, about 99 percent accurate.

01:01:16.690 --> 01:01:22.950
So in summary, what we're looking when we're
looking for exploitability is memory corruption

01:01:22.949 --> 01:01:26.029
and all memory corruption bugs
should be considered exploitable.

01:01:26.030 --> 01:01:30.519
It's very difficult to prove that a given
memory corruption bug is not exploitable.

01:01:30.519 --> 01:01:37.820
For any given program, just the fact that we're writing
to stuff that we're not expected to be writing to,

01:01:37.820 --> 01:01:42.090
to really ensure that this can never be
exploited for anything is quite difficult.

01:01:42.090 --> 01:01:48.030
Memory corruption can be detected by inspecting
a crash log, by inspecting the process

01:01:48.030 --> 01:01:51.190
in the debugger or by using CrashWrangler.

01:01:51.190 --> 01:01:58.039
CrashWrangler is a new tool that will be released soon
generally for general availability and it's useful

01:01:58.039 --> 01:02:02.730
for fuzzing and useful for triaging one-off crashes.

01:02:02.730 --> 01:02:09.599
It's-- when you're doing this crash triage stuff,
it's useful for to use the malloc tools, libgmalloc,

01:02:09.599 --> 01:02:15.230
and the hardening built flags like
-fstack-protector and __FORTIFY_SOURCE.

01:02:15.230 --> 01:02:23.280
CrashWrangler is now or should be soon available
at the page for the session and as always,

01:02:23.280 --> 01:02:27.060
product security can be contacted
at product-security@apple.com.
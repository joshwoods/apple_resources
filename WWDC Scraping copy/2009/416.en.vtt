WEBVTT

00:00:13.769 --> 00:00:17.370
>> Welcome to the Understanding
Memory Management on iPhone session.

00:00:17.370 --> 00:00:20.929
I'm David Myszewski, and I'm here
with Charles Srisuwananukorn.

00:00:20.929 --> 00:00:23.519
We both work on iPhone performance.

00:00:23.519 --> 00:00:26.350
I've been working on performance for about three years.

00:00:26.350 --> 00:00:30.500
So we have a lot of great memories
-- memory topics to cover today.

00:00:30.500 --> 00:00:36.079
It's very, very important on the iPhone to
keep the memory management very, very good,

00:00:36.079 --> 00:00:38.390
because we have a limited amount of memory.

00:00:38.390 --> 00:00:43.539
And so to talk about iPhone memory we
divided this talk into six different topics.

00:00:43.539 --> 00:00:49.219
Memory -- first of all, we'll go over the memory
architecture on iPhone to give you a really good foundation

00:00:49.219 --> 00:00:54.810
about how memory management works on iPhone
and everything that's going on in the system.

00:00:54.810 --> 00:01:00.350
Then we'll talk a little bit about memory tools to show
you how you can diagnose some of your memory problems.

00:01:00.350 --> 00:01:06.030
We'll talk some about image and layer memory, which
are some of the issues that are most difficult

00:01:06.030 --> 00:01:09.030
to deal with on the memory management side.

00:01:09.030 --> 00:01:14.790
We'll talk in great detail and show a lot of code
examples for how you respond to low memory warnings.

00:01:14.790 --> 00:01:18.490
Then we'll talk a little bit about
autorelease pools, and then finally,

00:01:18.489 --> 00:01:22.509
the low memory logs that you get
if your application is terminated.

00:01:22.510 --> 00:01:26.990
So let's begin by talking a little bit
about the memory architecture on iPhone

00:01:26.989 --> 00:01:32.589
IPhone has limited memory, it's not like
a desktop that has gobs and gobs of RAM,

00:01:32.590 --> 00:01:36.409
and a swap file that gives you effectively infinite memory.

00:01:36.409 --> 00:01:42.579
The iPhone OS, the original iPhones are limited
to 128 megs of RAM, and once you run out of

00:01:42.579 --> 00:01:48.109
that memory then the operating system
has to terminate an application.

00:01:48.109 --> 00:01:53.640
We do have virtual memory so you can use APIs
like mmap to handle very, very large files,

00:01:53.640 --> 00:01:58.049
and the OS can swap that data in and out as it needs to.

00:01:58.049 --> 00:02:05.039
And to deal with the fact that once we run out of
memory the OS is done, we have low memory notifications.

00:02:05.040 --> 00:02:10.560
And low memory notifications give applications that
are running on iPhone, including your applications,

00:02:10.560 --> 00:02:18.020
the chance to free up memory so that the OS can continue
to run and so the user experience is not effected.

00:02:18.020 --> 00:02:21.100
So what does memory look like on iPhone.

00:02:21.099 --> 00:02:24.759
Well, your application isn't the
only thing running on the device.

00:02:24.759 --> 00:02:30.099
The iPhone is the same sort of preemptive
multitasking operating system that we have in Mac OS X.

00:02:30.099 --> 00:02:33.739
And there's a lot going on at the same time.

00:02:33.740 --> 00:02:40.120
So to start out with, we have some amount of memory
that's used for graphics, all the rich images that you see

00:02:40.120 --> 00:02:44.020
on the screen, video playback, and all
the graphic sort of work that we have.

00:02:44.020 --> 00:02:46.830
So we use some memory for that.

00:02:46.830 --> 00:02:51.320
Then we have some amount of memory
that we called wired memory.

00:02:51.319 --> 00:02:53.310
Which can grow and shrink over time.

00:02:53.310 --> 00:02:57.250
So this may be about how much you
have in a typical application.

00:02:57.250 --> 00:03:02.539
Wired memory is all -- the entire code
size of the kernel and all the kext.

00:03:02.539 --> 00:03:05.500
It's memory that's allocated by the drivers.

00:03:05.500 --> 00:03:09.960
And where you see wired memory vary the most
is where you're doing a lot of layer usage,

00:03:09.960 --> 00:03:14.530
because we wire down some memory before
we send it to the graphics hardware.

00:03:14.530 --> 00:03:21.280
So there's a chunk of wired memory that the OS
needs in order to function that can't be reclaimed.

00:03:21.280 --> 00:03:29.189
Then there are a number of system daemons that are running
to give you some core functionality like media playback,

00:03:29.189 --> 00:03:33.669
handling communication between the accessories and so on.

00:03:33.669 --> 00:03:39.669
Then we have the SpringBoard app, which as many of you
know handles the launching of the apps and the coordination

00:03:39.669 --> 00:03:46.679
of various apps, and it's responsible for a lot of
the user experience of the device, and in particular,

00:03:46.680 --> 00:03:51.939
SpringBoard has the Core Animation server, which means
that any communication that your app does with SpringBoard

00:03:51.939 --> 00:03:56.270
because you have UIView that's you're drawing
into, or animations that are running at the time.

00:03:56.270 --> 00:03:58.580
All of that is done in SpringBoard.

00:03:58.580 --> 00:04:01.790
So SpringBoard has the Core Animation server.

00:04:01.789 --> 00:04:04.349
And then of course on iPhone, it is a phone.

00:04:04.349 --> 00:04:08.219
So we do have a phone that's running in the background
so that we can service your calls really quickly,

00:04:08.219 --> 00:04:13.039
bring that phone app up to the front so
that calls are really, really responsive.

00:04:13.039 --> 00:04:17.670
And the rest is all available to your app.

00:04:17.670 --> 00:04:23.100
So on the iPhone, we'll start out with some base
amount of memory, and then as your app grows

00:04:23.100 --> 00:04:28.180
over time, has less and less memory to deal with.

00:04:28.180 --> 00:04:32.370
As you're allocating memory on the heap,
as you're creating all sorts of images

00:04:32.370 --> 00:04:35.490
and UIViews, the total system memory will go up.

00:04:35.490 --> 00:04:38.389
And we don't want it to go all the way up to the top,

00:04:38.389 --> 00:04:41.419
because if it goes all the way
to the top the OS can't function.

00:04:41.420 --> 00:04:44.920
So we deal with this by low memory warnings.

00:04:44.920 --> 00:04:48.910
And we have today three different
levels of low memory warnings.

00:04:48.910 --> 00:04:54.680
The first one is mainly a notification to
help free up a little bit of memory, say,

00:04:54.680 --> 00:05:01.970
background apps that we've written, like mail, can free
some memory and for your application to free up a little bit

00:05:01.970 --> 00:05:07.400
of memory as much as it can early on, so that
the device will continue to perform really well.

00:05:07.399 --> 00:05:13.859
And then you may get a second memory notification
later on if you continue to use more memory.

00:05:13.860 --> 00:05:18.840
And at that level, this is where we're
the most aggressive about getting rid

00:05:18.839 --> 00:05:23.029
of all the memory on the system that we can free up.

00:05:23.029 --> 00:05:29.229
You may notice as you're running your iPhone and looking at
various Instruments and Activity Monitor that in addition

00:05:29.230 --> 00:05:35.620
to your app and some of the daemons, a couple of our apps
stick around, such as mail, so that they can do things

00:05:35.620 --> 00:05:39.590
like check e-mail in the background without
a lot of overhead and things like that.

00:05:39.589 --> 00:05:46.859
And at that -- this memory level, all of those background
apps exit so that they can free up memory for your app.

00:05:46.860 --> 00:05:52.360
So after that's happened, if you continue to use
more and more memory then we have to issue the last

00:05:52.360 --> 00:05:55.230
and final -- the final low memory notification.

00:05:55.230 --> 00:05:59.319
And at that point the frontmost app is terminated.

00:06:00.610 --> 00:06:08.280
Now notice that the difference between the previous
chart and this chart from the frontmost app perspective,

00:06:08.279 --> 00:06:12.299
if the frontmost app keeps using up
memory there, basically indistinguishable.

00:06:12.300 --> 00:06:15.850
You need to do two things as you're
looking at memory usage on iPhone.

00:06:15.850 --> 00:06:20.010
The first is try not to gradually increase memory over time.

00:06:20.009 --> 00:06:23.269
So if you're constantly downloading
a bunch of images, displaying them,

00:06:23.269 --> 00:06:29.649
and every time you do that you use a little more memory
until the app finally gets terminated -- that's bad.

00:06:29.649 --> 00:06:33.899
But if you have a memory spike, say if
you're sitting down and maybe using 20 megs,

00:06:33.899 --> 00:06:39.199
and then all of a sudden you use 40 megabytes of memory
right away, even though it's just a little spike,

00:06:39.199 --> 00:06:42.599
as soon as you hit that top level memory warning level,

00:06:42.600 --> 00:06:46.400
which is right now at 5%, the application
will be terminated.

00:06:46.399 --> 00:06:51.409
So as an app developer you want to minimize
memory growth over time and you want to ensure

00:06:51.410 --> 00:06:55.680
that you don't have any major memory spikes
that will lead to your app's termination.

00:06:55.680 --> 00:07:06.139
Now of course on iPhone OS X we have all the standard Cocoa
memory management model, we have Objective-C and alloc/init

00:07:06.139 --> 00:07:13.689
to create objects, and of course the reference counting
retain/release/autorelease, to manage your reference counts.

00:07:13.689 --> 00:07:18.459
We don't have Garbage Collection, but we do have all
your standard C and C++ memory management mechanisms,

00:07:18.459 --> 00:07:21.569
new for -- new and delete, and malloc free.

00:07:21.569 --> 00:07:25.620
So all the standard things that
you're used to as an app developer.

00:07:25.620 --> 00:07:32.170
And as an app developer you need to make sure that you
cache all of the right objects as you're writing your apps

00:07:32.170 --> 00:07:36.100
so that means that you don't keep
caching things and not clear the cache.

00:07:36.100 --> 00:07:38.360
You do need to free the cache periodically.

00:07:38.360 --> 00:07:43.970
And -- but feel free to cache frequently
used object because you may need them again.

00:07:43.970 --> 00:07:48.210
But always design your application architecture
to be able to release them if needed,

00:07:48.209 --> 00:07:51.659
and we'll show you some code examples
of this a little bit later on.

00:07:51.660 --> 00:07:57.520
And we have all sorts of tools that will help
you see how your memory utilization is overtime.

00:07:57.519 --> 00:08:03.859
And so to start out we have Charles to demo
an application that doesn't behave very well.

00:08:03.860 --> 00:08:04.509
>> Hi everyone.

00:08:04.509 --> 00:08:08.420
My name is Charles Srisuwananukorn, and
I work with Dave on iPhone performance.

00:08:08.420 --> 00:08:12.860
And I'd like to show you a simple little
application we wrote called Breadcrumbs.

00:08:12.860 --> 00:08:22.270
And Breadcrumbs is a simple travel journal application that
allows you to create a journal entry and take a photo right

00:08:22.269 --> 00:08:27.259
from your phone and it will automatically look up
your current location using Core Location and MapKit,

00:08:27.259 --> 00:08:32.319
and remember that with your entries so that
you can go back later and look up your entries

00:08:32.320 --> 00:08:36.320
by location, maybe put them on a map or something.

00:08:36.320 --> 00:08:42.330
And so here's Breadcrumbs, and I can go ahead and create
a new entry by tapping on this plus button up here.

00:08:42.330 --> 00:08:46.580
And it brings up this compose view
that let's me create an entry.

00:08:46.580 --> 00:08:49.660
So I'll go ahead and type an entry.

00:08:49.659 --> 00:08:57.289
And as you can see while I type the entry, it parses out
the title for the entry from the first line of the text

00:08:57.289 --> 00:09:01.429
and it automatically figured out that I'm
in San Francisco, California right now.

00:09:01.429 --> 00:09:04.849
And then I can also attach a photo to that entry.

00:09:04.850 --> 00:09:06.740
And I'm going to choose a photo that I've already taken.

00:09:06.740 --> 00:09:11.570
And I'll just pick that one over there.

00:09:11.570 --> 00:09:15.340
And it's -- as you can see, the photo is
actually associated now with this entry.

00:09:15.340 --> 00:09:21.940
And I can go back to the Table view and see all of the
entries that I have created so far, along with the latitude

00:09:21.940 --> 00:09:27.730
and longitude for each of those entries, and a thumbnail
for all of the images associated with those entries.

00:09:27.730 --> 00:09:32.470
Now as Dave said, of course, this application
is not without its problems, and in particular,

00:09:32.470 --> 00:09:39.279
if I tap this slide show button right here it will start a
slide show of all of the images associated with my entries.

00:09:39.279 --> 00:09:44.339
But it will only get a handful of
images in before it actually crashes.

00:09:44.340 --> 00:09:47.820
And there it goes.

00:09:47.820 --> 00:09:53.410
So let me switch now to Xcode and
take a look at the crash log.

00:09:53.409 --> 00:09:56.250
So as most of you guys probably
know, every time an application

00:09:56.250 --> 00:10:01.080
on the phone crashes the iPhone OS will
actually write a crash log to the disc.

00:10:01.080 --> 00:10:07.170
And then Xcode will then copy those crash logs back to the
computer and make them available to you in the organizer.

00:10:07.169 --> 00:10:09.919
So I'm going to go ahead and open up
the organizer from the window menu.

00:10:09.919 --> 00:10:13.199
And then here I see my device is on the left.

00:10:13.200 --> 00:10:20.930
And if I click on the device and I go to the crash logs
tab, it will list all of the crash logs for this device.

00:10:20.929 --> 00:10:27.609
And if I zoom in over here, we can see that the crash,
the latest crash, was actually a low memory crash.

00:10:27.610 --> 00:10:31.509
Which isn't too much of a surprise,
since this is the low memory session.

00:10:33.429 --> 00:10:40.699
So before we actually -- and if you actually click on the
log you can actually see a lot more details about the crash,

00:10:40.700 --> 00:10:44.350
and we'll actually go into more detail
about what each of these things means later.

00:10:44.350 --> 00:10:47.060
But now let's go back to Dave and he's
going to tell us a little bit more

00:10:47.059 --> 00:10:49.669
about some tools we could use to diagnose this issue.

00:10:49.669 --> 00:10:57.849
>> OK, so we have plenty of memory management
tools to help you debug these kinds of problems,

00:10:57.850 --> 00:11:03.889
so when you see that low memory log there are a number
of ways to look at how your app is utilizing memory

00:11:03.889 --> 00:11:09.120
so that you can eventually avoid all
of these -- avoid being terminated.

00:11:09.120 --> 00:11:15.360
So we have three main Instruments that we
use a lot for memory management on iPhone.

00:11:15.360 --> 00:11:19.800
Instruments provides an activity monitoring
instrument, which will give you an overview

00:11:19.799 --> 00:11:23.379
of how much memory each process on the system is using.

00:11:23.379 --> 00:11:26.029
A Leaks instrument, which will
tell you all about memory leaks.

00:11:26.029 --> 00:11:30.709
Because if you have memory that is still
around but have no references to it,

00:11:30.710 --> 00:11:33.360
then that's memory that your app can no longer use.

00:11:33.360 --> 00:11:38.970
So you want to eliminate any sort of large leaks,
and in fact, leaks are fairly easy to track

00:11:38.970 --> 00:11:43.490
down because the Instruments tool gives you
back traces to where the object was allocated.

00:11:43.490 --> 00:11:50.009
Then you can figure out where a reference count went wrong
or you misdealloced something, and you missed the leak.

00:11:50.009 --> 00:11:52.220
So that's typically one of the first things you look at,

00:11:52.220 --> 00:11:55.370
because they're usually pretty
straight forward to track down.

00:11:55.370 --> 00:12:00.940
Then there's an Object Alloc instrument which will
tell you how your application is growing over time.

00:12:00.940 --> 00:12:03.270
So Object Alloc tracks mallocs memory.

00:12:03.269 --> 00:12:09.250
So if you create a whole lot of objects it will show
you a chart of how your memory growth goes over time,

00:12:09.250 --> 00:12:14.000
and it will tell you which objects were
used and again, give you some back traces,

00:12:14.000 --> 00:12:19.940
and it has some good filtering abilities so that you can
track down specific problems that you're looking for.

00:12:19.940 --> 00:12:24.630
And of course, the Leaks instrument is very, very powerful.

00:12:24.629 --> 00:12:29.250
But also, it's usually the first thing you
want to do, even before going into object alk.

00:12:29.250 --> 00:12:33.460
Just make sure that you don't have any large
leaks because if you have a giant leak of 200 K,

00:12:33.460 --> 00:12:36.389
that may be the first thing you want to fix.

00:12:36.389 --> 00:12:40.799
And of course now in Snow Leopard
we have the Xcode Static Analyzer.

00:12:40.799 --> 00:12:44.109
Now the Static Analyzer is a very powerful tool

00:12:44.110 --> 00:12:48.669
that at build time will analyze your
source code before you even run it.

00:12:48.669 --> 00:12:55.329
So it does static analysis at build time to find memory
bugs and all sorts of other bugs, such as security issues,

00:12:55.330 --> 00:13:00.610
no point of view references, et cetera, that can cause
crashes, without actually running the application.

00:13:00.610 --> 00:13:04.680
And one of the critical aspects of this tool
that Charles will show you in a moment is

00:13:04.679 --> 00:13:10.359
that it enforces the Cocoa memory management
policy, and so it knows about new --

00:13:10.360 --> 00:13:15.050
about copy and alloc and how reference
counts are supposed to work.

00:13:15.049 --> 00:13:18.370
And it can look up portions of your
code to determine when, perhaps,

00:13:18.370 --> 00:13:23.500
a reference count was incremented
in one function and not decremented.

00:13:23.500 --> 00:13:27.500
So it has very sophisticated tools to analyze that.

00:13:27.500 --> 00:13:30.809
And so Charles will show you a
little bit about the memory tools.

00:13:30.809 --> 00:13:36.529
>> Great. So now that we heard about all of these great
memory tools that we have, let's try and use it here,

00:13:36.529 --> 00:13:38.949
just try and get an idea of what's going on here.

00:13:38.950 --> 00:13:44.530
So we're going to start off using the Xcode Static
Analyzer that Dave mentioned earlier, and I can go ahead

00:13:44.529 --> 00:13:51.750
and run the analyzer from the build menu in
Xcode, and do build and analyze in Snow Leopard.

00:13:51.750 --> 00:13:58.330
Now as its name suggests, the Xcode Static Analyzer is
a static analysis tool, and what it does is it will try

00:13:58.330 --> 00:14:04.020
to follow all the code paths in your code,
follow all the branchs looking for bugs.

00:14:04.019 --> 00:14:07.970
But it does so without actually running your code.

00:14:07.970 --> 00:14:11.910
So what that means is you can actually
get a few false positives,

00:14:11.909 --> 00:14:14.939
it can identify bugs that may not actually be bugs.

00:14:14.940 --> 00:14:22.100
But it has a better chance of finding more bugs than
something like -- some runtime tool like Leaks, for example,

00:14:22.100 --> 00:14:26.180
where Leaks will just analyze your code at runtime.

00:14:26.179 --> 00:14:32.029
So I go ahead and analyze the code here with the Xcode
Static Analyzer, and it says that it found a potential leak

00:14:32.029 --> 00:14:36.360
on an object allocated on line
141, sorting into subtitle text.

00:14:36.360 --> 00:14:41.370
And if you look carefully, and sure enough,
allocate init, a subtitle text, NS string here.

00:14:41.370 --> 00:14:45.389
And then I set it on the detailed text
label, but I don't actually release it.

00:14:45.389 --> 00:14:50.659
One of the cool things about the Xcode Static
Analyzer is that I can actually click over here

00:14:50.659 --> 00:14:55.269
and it will actually annotate my code
with the actual code path that leaked.

00:14:55.269 --> 00:15:00.240
So that if I had leaked a block of memory somewhere
deep in a nested if statement or something,

00:15:00.240 --> 00:15:04.039
I can actually see it right there and find it easily.

00:15:04.039 --> 00:15:09.459
So like I said, the Xcode Static Analyzer
could actually give me some false positives.

00:15:09.460 --> 00:15:16.230
So I'm going to switch over to the Leaks instrument
now to verify that this is actually a leak

00:15:16.230 --> 00:15:22.490
And I'm going switch to the simulator because my memory
allocation patterns are almost certainly the same

00:15:22.490 --> 00:15:25.820
on the simulator as they are on the device here.

00:15:25.820 --> 00:15:30.550
And I'm going to run it with the Leaks tool
from the run menu, run a performance tool,

00:15:30.549 --> 00:15:32.169
and then I can select the Leaks right here.

00:15:32.169 --> 00:15:37.439
I'm actually going to select Leaks demo, the same
thing, just easier to read on the big screen here.

00:15:37.440 --> 00:15:44.840
So there it starts on the simulator, and I'm
going to use the application a little bit.

00:15:44.840 --> 00:15:47.700
And then I'm going to go back into here to Instruments.

00:15:47.700 --> 00:15:56.710
And the way Leaks work is it will analyze my application
periodically looking through my heap for all of my objects

00:15:56.710 --> 00:16:01.590
and all of my -- anything that might look like a pointer.

00:16:01.590 --> 00:16:07.190
And then it will report to me all
of the blocks that actually leaked.

00:16:07.190 --> 00:16:11.840
So in this case, it actually didn't seem to find that.

00:16:11.840 --> 00:16:16.879
Let me just quickly rebuild that, and then deploy it again.

00:16:16.879 --> 00:16:24.059
And by default the Leaks instrument will actually
search the heap every ten second for a leak.

00:16:24.059 --> 00:16:30.579
Sorry, let me actually run the
performance tool and the Leaks demo.

00:16:30.580 --> 00:16:33.100
And because it's actually searching
my heap looking for anything

00:16:33.100 --> 00:16:37.210
that might be a pointer, it's actually
a very conservative tool.

00:16:37.210 --> 00:16:41.580
And so it will not report any false positives here.

00:16:41.580 --> 00:16:49.490
OK, I actually did this before, so I'm going to go
ahead an open up this trace over here and Instruments.

00:16:50.799 --> 00:16:56.490
So let's actually zoom in on the Leaks track up here.

00:16:56.490 --> 00:17:01.950
And this -- this top red bar here shows
me the number of leaks that Leaks found.

00:17:01.950 --> 00:17:06.779
And the become blue bar over here will show me
the total number of bytes that I actually leaked.

00:17:06.779 --> 00:17:10.319
And if I move the inspection head,
the track inspection head over here,

00:17:10.319 --> 00:17:15.109
it tells me it actually discovered
three leaks for a total of 144 bytes.

00:17:15.109 --> 00:17:24.359
And if I go down here into the Detail pane, we can
see that actually leaked a couple of NS CS strings,

00:17:24.359 --> 00:17:29.949
and if I drop this down and selected
one of these NS CS strings in the --

00:17:29.950 --> 00:17:35.640
in the Extended Detail Pane over here is shows me
the stack trace for the allocation of those strings.

00:17:35.640 --> 00:17:39.140
So I can look at this and see exactly
where I had allocated that string.

00:17:39.140 --> 00:17:44.700
And if I double click over here, it will actually
bring up the source code for my particular leak.

00:17:44.700 --> 00:17:47.670
And in this case, it will bring
up the source code for right here.

00:17:47.670 --> 00:17:53.050
So let me go ahead and fix that leak and see if it helps.

00:17:53.049 --> 00:18:00.589
And I'm going to again rebuild this,
and send it over to the device.

00:18:00.589 --> 00:18:03.329
And actually, I did this before,
and it turns out it doesn't help.

00:18:03.329 --> 00:18:04.230
It will still crash.

00:18:04.230 --> 00:18:08.039
144 bytes that I leaked over there
was actually not that much.

00:18:08.039 --> 00:18:13.029
So what I'm going to do now is actually run the
application with the Object Alloc instrument.

00:18:13.029 --> 00:18:16.859
And the Object Alloc instrument
will track all of my allocation.

00:18:16.859 --> 00:18:20.769
So any time I do an alloc/init, any
time a do a malloc, it will record it

00:18:20.769 --> 00:18:23.529
and puts it into this nice little timeline up here.

00:18:23.529 --> 00:18:27.490
And I've also added this Activity
Monitor instrument over here and set it

00:18:27.490 --> 00:18:29.980
to show me only the free physical memory on the device.

00:18:29.980 --> 00:18:35.980
So I'm going to go ahead and click the slide
show, or tap the slide show button over here,

00:18:35.980 --> 00:18:40.460
and it starts the slide show images that we saw earlier.

00:18:40.460 --> 00:18:44.970
Now as you can see, Object Alloc is
reporting that I'm allocating lots

00:18:44.970 --> 00:18:49.860
and lots of memory every time I change that image.

00:18:49.859 --> 00:18:53.849
And subsequently at the same time,
the amount of physical free memory

00:18:53.849 --> 00:18:59.349
on the device drops quite a bit right
when I actually start that slide show.

00:18:59.349 --> 00:19:07.639
So let's actually take a look at this particular section
and see if we can figure out what exactly is going on.

00:19:08.690 --> 00:19:11.789
So to get a kind of general idea
about what might be going on I'm going

00:19:11.789 --> 00:19:15.000
to sort the detail pane down here by the live bytes.

00:19:15.000 --> 00:19:18.980
Now the live bytes is the total number of bytes for each

00:19:18.980 --> 00:19:22.400
of these single categories that
are alive at the end of the run.

00:19:22.400 --> 00:19:26.610
And every block of memory that's allocated
is assigned to a certain category.

00:19:26.609 --> 00:19:35.889
So in this example, I have a malloc 5.5 megabyte
category over here which is all memory blocks of --

00:19:35.890 --> 00:19:39.560
of the size 5.5 megabytes that were allocated by malloc.

00:19:39.559 --> 00:19:44.399
And I have NS -- a CF string down
here, which are all of the CF strings.

00:19:44.400 --> 00:19:53.160
So what this is saying is that I have 27.48
megabytes alive of this malloc 5.5 megabyte category.

00:19:53.160 --> 00:19:55.240
So that's kind of interesting.

00:19:55.240 --> 00:20:00.940
So let's actually zoom out and then go
down to the Object List View over here.

00:20:00.940 --> 00:20:07.330
And this Object List View will list all of the objects that
have been allocated in the order that they were allocated.

00:20:07.329 --> 00:20:12.009
And as I move the inspection up here in
the tracks it will change the selection

00:20:12.009 --> 00:20:15.220
down here and to track the inspection head.

00:20:15.220 --> 00:20:22.789
So I'm going to move this over to one of these steps
over here, and I find that every time I have one

00:20:22.789 --> 00:20:29.430
of those big jumps in memory up here, I also
find one of these malloc 5.5 kilobyte blocks.

00:20:29.430 --> 00:20:31.519
Megabyte blocks, sorry.

00:20:31.519 --> 00:20:37.039
And so I can be pretty certain that these malloc 5.5
megabyte blocks are what's causing these big steps

00:20:37.039 --> 00:20:37.789
in the allocations.

00:20:37.789 --> 00:20:45.149
So I'm going to bring up the Extended Detail
Pane again and I notice that this time

00:20:45.150 --> 00:20:50.780
in my stack trace it's mostly Core Graphics and
QuartzCore, and not really anything of my code.

00:20:50.779 --> 00:20:56.349
So it probably has something to do with those
big images that the slide show is showing.

00:20:56.349 --> 00:21:04.609
And so one other thing I wanted to take a look at here is if
I click on the Activity Monitor instrument and then I sort

00:21:04.609 --> 00:21:09.869
by the amount of real memory used by each of these
processes, so Activity Monitor is very similar

00:21:09.869 --> 00:21:16.189
to the top command line tool, it will just sample each of
the processes that are running on the device and figure

00:21:16.190 --> 00:21:20.570
out how much memory they're using at any given
point in time, how much CPU they're using.

00:21:20.569 --> 00:21:24.679
And in this case, I'm going to sort by the
amount of real memory, which is the actual amount

00:21:24.680 --> 00:21:28.390
of physical memory that that process is using.

00:21:28.390 --> 00:21:37.160
And I'm going to -- I find that Breadcrumbs is actually
using about 60 megabytes of real physical memory,

00:21:37.160 --> 00:21:41.160
even though if I go up to the Object Alloc track,

00:21:41.160 --> 00:21:46.210
Object Alloc believes that it's only
using about 28.4 megs of memory.

00:21:46.210 --> 00:21:52.779
Now the reason for this is that Object Alloc doesn't
track the backing layers for each of the images

00:21:52.779 --> 00:21:56.720
that I generated to display in the slide show.

00:21:56.720 --> 00:22:00.180
And so before we go any further let's
switch back to the slides and Dave's going

00:22:00.180 --> 00:22:02.690
to tell us a little bit more about image memory.

00:22:05.710 --> 00:22:13.100
>> All right, so what makes up for that discrepancy
that we saw in Object Alloc and Activity Monitor?

00:22:13.099 --> 00:22:19.230
Well, it turns out that we have a lot of objects
that -- their malloc size is very, very small,

00:22:19.230 --> 00:22:22.860
but the overall backing store is very, very large.

00:22:22.859 --> 00:22:25.919
Images and layers both fall into these categories.

00:22:25.920 --> 00:22:32.100
So Core Graphics -- Core Graphics images are
pretty small if you look at them in Object Alloc,

00:22:32.099 --> 00:22:36.539
but they can allocate a lot of memory
because if you decompress your image,

00:22:36.539 --> 00:22:46.240
the actual uncompressed image size is quite large, and every
layer which every UIView has, has a shared region of memory

00:22:46.240 --> 00:22:48.750
between your application and SpringBoard.

00:22:48.750 --> 00:22:52.220
And that region of memory isn't
memory allocated isn't malloced --

00:22:52.220 --> 00:22:55.089
because it has to be shared between two processes.

00:22:55.089 --> 00:23:00.529
So every time you have a lot of views that are
sticking around you may run into one of these instances

00:23:00.529 --> 00:23:05.299
where Object Alloc and Activity Monitor show
a little bit different amounts of memory.

00:23:05.299 --> 00:23:09.879
And that's because every UIView has a
layer and the backing store is shared.

00:23:09.880 --> 00:23:17.640
So to look at this a little bit more illustrated fashion, we
have a couple of very, very tiny UIViews in your application

00:23:17.640 --> 00:23:23.820
which all have a reference to layers, and both of those
have references to very large backing stores that are shared

00:23:23.819 --> 00:23:26.769
between your application and SpringBoard.

00:23:26.769 --> 00:23:29.690
So if you run into any of those
situations where Object Alloc

00:23:29.690 --> 00:23:33.170
and Activity Monitor are a bit
different, look at your layer memory.

00:23:33.170 --> 00:23:40.440
You can search for UIViews in Object Alloc
or TA layers to see how many you have around.

00:23:40.440 --> 00:23:45.910
And one thing to note as you're dealing with images,
and I actually had a question about this today,

00:23:45.910 --> 00:23:50.190
that images have to be decompressed
in memory to display them.

00:23:50.190 --> 00:23:58.570
So if you have a JPEG that's the full screen size, but
the JPEG is say 50 or 60 or 70 K, when we decompress --

00:23:58.569 --> 00:24:03.649
we have to decompress the image to display
them, and the decompressed memory size is going

00:24:03.650 --> 00:24:09.030
to be width times height times 4
bits per pixel, or about 600 K.

00:24:09.029 --> 00:24:14.490
So your image that was very, very small
on disc is fairly large in memory.

00:24:14.490 --> 00:24:21.170
And if we go up in larger and larger screen resolutions,
the typical camera size may be about 7 megs of memory.

00:24:21.170 --> 00:24:26.940
So you really want to manage every bit of image
that you get from the camera very, very carefully.

00:24:26.940 --> 00:24:31.039
And if you have a giant image from some camera
that maybe you downloaded from a web site,

00:24:31.039 --> 00:24:33.399
it can use most of the memory that
you have available to them.

00:24:33.400 --> 00:24:36.290
So whenever you're dealing with
large images you need to be very,

00:24:36.289 --> 00:24:41.180
very careful about your memory
management techniques that you use.

00:24:41.180 --> 00:24:43.360
So how do you deal with all the images.

00:24:43.359 --> 00:24:48.559
Well, we have several different UIImage
APIs that we provide through UIKit.

00:24:48.559 --> 00:24:52.299
And we'll talk about -- we'll talk about three of them here.

00:24:52.299 --> 00:24:55.049
The first is UIImage imageNamed.

00:24:55.049 --> 00:25:00.440
UIImage imageNamed caches the uncompressed
images in memory and will free them

00:25:00.440 --> 00:25:04.660
on low memory notifications if there
are no more references to them.

00:25:04.660 --> 00:25:12.660
So if you use this API and still have a -- and still keep
that UIImage around, that image memory will not go away.

00:25:12.660 --> 00:25:15.269
One note that this is used by initWithNibName.

00:25:15.269 --> 00:25:17.450
So if you have large images in NIBs you may want

00:25:17.450 --> 00:25:24.370
to consider loading them using some other UIImage
initializers in the viewDidLoad method instead.

00:25:24.369 --> 00:25:28.019
And it does clear the cache on memory
warnings, but really this is an API

00:25:28.019 --> 00:25:31.549
that you should be using for small, frequently used images.

00:25:31.549 --> 00:25:35.389
So if you have an image that you use all the time
as you scroll through lists and really want it

00:25:35.390 --> 00:25:40.470
to be always available in memory and
decompressed and very highly available,

00:25:40.470 --> 00:25:44.210
then that's the type of situation where
you should use UIImage imageNamed.

00:25:44.210 --> 00:25:50.470
The second API that you have is UIImage initWithData.

00:25:50.470 --> 00:25:53.900
UIImage initWithData retains the NSData that you give to it.

00:25:53.900 --> 00:25:59.000
So you should transfer ownership whenever
you create a UIImage using this methodology.

00:25:59.000 --> 00:26:04.609
And on a low memory warning, or preferably before
that, when you hand off the data to the image,

00:26:04.609 --> 00:26:10.379
release the NSData if you can recreate
is or if you just don't need it any more.

00:26:10.380 --> 00:26:18.610
And one little technique here is that NSData has an API,
initWithContentsofMappedFile, which will use memory mapping

00:26:18.609 --> 00:26:23.459
so that the memory that NSData
uses can be reclaimed by the OS.

00:26:23.460 --> 00:26:29.720
So if you have some sort of large file, if the OS
needs that memory later on it can reclaim some of that.

00:26:29.720 --> 00:26:34.620
Whereas using the NSData initWithContentsofFile,
brings the entire file into memory

00:26:34.619 --> 00:26:38.509
and the OS can't reclaim that until you free the memory.

00:26:38.509 --> 00:26:44.519
And the third API is UIImage initWithContentsofFile.

00:26:44.519 --> 00:26:47.740
Now UIImage initWithContentsofFile only retains the path.

00:26:47.740 --> 00:26:51.170
So we don't -- we try not to store a
whole lot of uncompressed image data

00:26:51.170 --> 00:26:55.150
in memory, well, whenever we can avoid it.

00:26:55.150 --> 00:27:01.340
But all of these APIs are often used to
display images on screen in a UIImage view,

00:27:01.339 --> 00:27:04.709
or perhaps you draw some images yourself.

00:27:04.710 --> 00:27:10.670
So for all of these APIs on low memory warnings
you should release any references you have to them.

00:27:10.670 --> 00:27:14.730
Because there may be situations where
you may have to cache some data.

00:27:14.730 --> 00:27:21.410
So to summarize those three different UIImage APIs,
UIImage imageNamed caches all the uncompressed images,

00:27:21.410 --> 00:27:24.509
and on low memory you should release
any references that you have.

00:27:24.509 --> 00:27:34.869
And of course the note to load any large images using other
initializers if you have a bunch of images in a init file.

00:27:34.869 --> 00:27:40.579
UIImage initWithData caches the uncompressed data,
and you should definitely release the NSData.

00:27:40.579 --> 00:27:46.049
And UIImage initWithContentsofFile tries not to
cache anything in the image that it doesn't need to.

00:27:46.049 --> 00:27:50.629
And so you -- but for all of these three
APIs if you encounter low memory warnings

00:27:50.630 --> 00:27:55.040
and you don't need the image any more, you should
try to throw it away, to get rid of as much memory

00:27:55.039 --> 00:27:58.430
as you can, so that the OS can continue to run.

00:27:58.430 --> 00:28:02.150
And now Charles has a demo for releasing large images.

00:28:02.150 --> 00:28:03.580
>> OK, great.

00:28:03.579 --> 00:28:08.710
So now that we know all about images and the memory
that they use, here we are again at Instruments.

00:28:08.710 --> 00:28:14.069
And this is that strange malloc 5.5
megabyte block that we saw earlier.

00:28:14.069 --> 00:28:19.929
Since this roughly correlates with every time a new image
is displayed on the screen you can be pretty certain

00:28:19.930 --> 00:28:26.289
that this large block of memory here is probably the
backing store for that image that we are displaying.

00:28:26.289 --> 00:28:35.599
So in the Object List View over here, if I scroll up
until I find UIImage, this is probably the UIImage

00:28:35.599 --> 00:28:38.599
that is associated with that backing store.

00:28:38.599 --> 00:28:47.259
And so I see that sure enough this image was created in
the next image function in the slide show View Controller.

00:28:47.259 --> 00:28:52.450
So this is the method that's called back
every second or so to display the next image.

00:28:52.450 --> 00:28:58.779
And as you can see here, I actually don't release
the current image before I set the next image

00:28:58.779 --> 00:29:00.430
and display the next image.

00:29:00.430 --> 00:29:07.539
And so what happens is UIKit will keep the backing store
for that image around just in case it's displayed soon.

00:29:07.539 --> 00:29:13.960
So let's actually open this up in Xcode using
the Xcode button over here in Instruments.

00:29:13.960 --> 00:29:23.960
And I am going to fix that, build it,
and then run it again under Object Alloc

00:29:23.960 --> 00:29:27.130
and Activity Monitor to see if anything changed.

00:29:27.130 --> 00:29:36.190
And let's let Instruments start up a little bit there.

00:29:36.190 --> 00:29:43.539
OK. And so again I'm going to tap
on the slide show button there,

00:29:43.539 --> 00:29:48.490
and you can see that as I display the images
the memory usage actually grows again.

00:29:48.490 --> 00:29:53.910
But instead of continuing to grow, every time I display
a new image, now, it actually releases the memory

00:29:53.910 --> 00:29:56.550
for the old image before going on to the next one.

00:29:56.549 --> 00:29:59.279
So it never actually grows as high as it used to.

00:29:59.279 --> 00:30:03.369
And you see that the free memory here
never dips down as long as it did before.

00:30:03.369 --> 00:30:06.279
And so the slide show can actually go on forever, now.

00:30:06.279 --> 00:30:08.849
Really. Now.

00:30:08.849 --> 00:30:12.589
But -- so that fixed the crash.

00:30:12.589 --> 00:30:17.789
But the application actually has allocated a
lot of memory that the kernel would not be able

00:30:17.789 --> 00:30:21.480
to reclaim if free memory is scarce on the device.

00:30:21.480 --> 00:30:25.220
So that brings us to our next topic,
which is low memory warnings.

00:30:25.220 --> 00:30:29.519
Let me switch to the slides now and talk
a little bit about low memory warnings.

00:30:29.519 --> 00:30:35.549
So before I get too deep into the low
memory warnings I want to talk a little bit

00:30:35.549 --> 00:30:40.059
about the execution environment in
which applications run on the device.

00:30:40.059 --> 00:30:43.639
Even though there can be one foreground
app at any given time there can be many,

00:30:43.640 --> 00:30:45.440
many background apps running on the phone.

00:30:45.440 --> 00:30:48.690
And each of these processes consume some amount of memory.

00:30:48.690 --> 00:30:54.080
In addition to the memory that they allocate, [Inaudible]
needs to be brought in before they can be executed,

00:30:54.079 --> 00:30:59.119
and all the pages for the files that they mmapped in
need to be brought into memory before they can be used.

00:30:59.119 --> 00:31:02.369
So to show you how many processes
can be running in the background,

00:31:02.369 --> 00:31:06.189
here's a screen shot from Activity
Monitor running Breadcrumbs.

00:31:06.190 --> 00:31:11.820
There's actually about 20 applications running
in the background along with Breadcrumbs.

00:31:11.819 --> 00:31:18.009
Now if we take a look at the physical memory used,
this is roughly how it broke down in that situation.

00:31:18.009 --> 00:31:23.259
Starting with the blue wedge, which is free
memory, there's about 28 megabytes free.

00:31:23.259 --> 00:31:28.609
And then there are about 30 megabytes reclaimable,
which are those code pages that were brought in,

00:31:28.609 --> 00:31:31.349
and read-only pages from memory map files.

00:31:31.349 --> 00:31:36.480
Now these are reclaimable because the operating system
can always page out those pages and then read them back

00:31:36.480 --> 00:31:41.509
in from disc from the file itself, or from the executable.

00:31:41.509 --> 00:31:43.480
32 megabytes was wired memory.

00:31:43.480 --> 00:31:47.099
As Dave mentioned earlier, this is
kernel memory that cannot be reclaimed.

00:31:47.099 --> 00:31:51.189
12 megabytes are reserved for the
graphics memory -- the graphics hardware.

00:31:51.190 --> 00:31:55.680
And 26 megabytes were allocated by
all the processes on the device.

00:31:55.680 --> 00:31:57.600
And since we don't have a swap file on the device,

00:31:57.599 --> 00:32:02.459
that 26 megabytes can't actually be
reclaimed to service new allocations.

00:32:02.460 --> 00:32:09.579
So any time an application calls malloc or NSObject alloc,
the operating system actually needs to find a free page

00:32:09.579 --> 00:32:14.429
or a page that it can evict in
order to allocate that memory.

00:32:14.430 --> 00:32:21.049
So to look at it another way, 55% of
memory inU that case was not available

00:32:21.049 --> 00:32:23.129
to the kernel to service any of those requests.

00:32:23.130 --> 00:32:26.790
So it has to pull pages out of either
the free memory or the purple memory.

00:32:26.789 --> 00:32:31.920
So as Breadcrumbs allocated more memory it would use
up some more of that blue wedge, the free memory,

00:32:31.920 --> 00:32:36.840
and then it would eventually have to start using out
some of the purple wedge and start kicking out code pages

00:32:36.839 --> 00:32:41.919
that were executing in order to
allocate more memory for Breadcrumbs.

00:32:41.920 --> 00:32:49.970
And if left unchecked, eventually free memory would
become so scarce that none of the allocation requests

00:32:49.970 --> 00:32:55.970
from applications or the kernel itself could be serviced,
and no forward progress on the device could be made.

00:32:55.970 --> 00:33:03.390
So before that happens, the iPhone OS will actually issue a
memory warning to all the processes running on the device.

00:33:03.390 --> 00:33:07.300
And it will ask them to release as much of
the memory that they allocated as they can

00:33:07.299 --> 00:33:09.720
in order to free up some of this memory pressure.

00:33:09.720 --> 00:33:15.350
If it can't recover -- reclaim enough
memory then it will start killing --

00:33:15.349 --> 00:33:17.929
terminating background processes one by one.

00:33:17.930 --> 00:33:24.500
And then if it still can't reclaim enough
memory, it will terminate the foreground process.

00:33:24.500 --> 00:33:31.599
So a few key take-aways from this are that any
application on the device may cause low memory conditions,

00:33:31.599 --> 00:33:35.859
but it's probably that foreground application
that's actually doing work at the time.

00:33:35.859 --> 00:33:40.839
And you should expect memory warnings, because they are
a normal part of the system, they are one of the few ways

00:33:40.839 --> 00:33:47.669
that the kernel can reclaim the allocated memory, that red
wedge up there, and you must respond to low memory warnings.

00:33:47.670 --> 00:33:53.180
Because if you don't respond to low memory
warnings then that can cause app termination.

00:33:53.180 --> 00:33:56.390
So what should you do in response to memory warnings.

00:33:56.390 --> 00:34:02.070
Well, it all boils down to releasing any kind of objects
that you can reconstruct, anything you can read back

00:34:02.069 --> 00:34:04.980
from the disc, from a database, from
the network, anything like that.

00:34:04.980 --> 00:34:10.650
And also releasing any cached objects in any
cached resource files that you may have in memory.

00:34:10.650 --> 00:34:15.260
What you shouldn't do, though is ask the
user to do anything, because they can't.

00:34:15.260 --> 00:34:20.880
Rebooting the device may temporarily alleviate memory
pressure, but the root cause, the real problem is something

00:34:20.880 --> 00:34:25.789
on the device, probably that foreground
app, is using too much memory.

00:34:25.789 --> 00:34:32.769
So when UIKit receives the memory warning it
actually tries to release a lot of memory for you.

00:34:32.769 --> 00:34:36.539
And among that memory it will try to release the views --

00:34:36.539 --> 00:34:41.210
the view objects themselves that have gone
off of the screen and are no longer visible.

00:34:41.210 --> 00:34:47.750
But it actually needs some help releasing
the outlets associated with those views.

00:34:47.750 --> 00:34:52.769
So let's take a look at the Breadcrumbs application again.

00:34:52.769 --> 00:34:58.090
So here we have the Compose view in the Breadcrumbs
application, and this is the view that allows you

00:34:58.090 --> 00:35:01.470
to create a new note and also display exiting notes.

00:35:01.469 --> 00:35:05.889
If the user taps on the thumbnail
on the upper left over there,

00:35:05.889 --> 00:35:10.069
then the image viewer appears on top of the Compose view.

00:35:10.070 --> 00:35:18.100
If UIKit receives a memory warning at this point it
will actually release the view behind the Compose view,

00:35:18.099 --> 00:35:20.710
or behind the image view there, the Compose view.

00:35:20.710 --> 00:35:23.880
And then kick it out of memory.

00:35:23.880 --> 00:35:28.059
So the ComposeViewController, the controller for
that composed view, looks something like this.

00:35:28.059 --> 00:35:35.460
It actually has a reference to the UIView and has
several outlets to subviews on the composed view.

00:35:35.460 --> 00:35:40.500
It can read in the data from the model and
then update the subviews as appropriate.

00:35:40.500 --> 00:35:46.300
Now when UIKit decides to unload that view
and release it from memory, as you can see,

00:35:46.300 --> 00:35:50.200
all those outlets in the compose will
actually keep those subviews in memory,

00:35:50.199 --> 00:35:55.009
even though they can never be displayed
again, and waste quite a bit of memory.

00:35:55.010 --> 00:36:02.810
So what we would like to do instead is detect when
UIKit will unload this view so that we can release all

00:36:02.809 --> 00:36:04.509
of those outlets and set them all to nil.

00:36:04.510 --> 00:36:10.080
Now in iPhone OS 3.0 you can do this
by overriding the viewDidUnload method.

00:36:10.079 --> 00:36:17.400
When UIKit decides to unload the view, it will actually
call the viewDidUnload of the associated UIViewController.

00:36:17.400 --> 00:36:20.269
Letting it do some kind of -- any
kind of clean up that it would like.

00:36:20.269 --> 00:36:24.070
So in this case, we overrided viewDidUnload
in ComposeViewController.

00:36:24.070 --> 00:36:32.090
Released all of the outlets by setting the properties
to nil, and then we call our superclass's viewDidUnload.

00:36:32.090 --> 00:36:37.720
So now when UIKit receives that memory warning and
it unloads that view, it will call the viewDidUnload,

00:36:37.719 --> 00:36:40.269
and the Compose View Controller can set up of these to nil

00:36:40.269 --> 00:36:43.210
and it can release them, and we
no longer have any wasted memory.

00:36:43.210 --> 00:36:50.110
Just a quick note, we've made this much easier in iPhone 3.0
with that viewDidUnload method, and if you want to see how

00:36:50.110 --> 00:36:53.650
to do this prior to 3.0 you can
see the memory warning section

00:36:53.650 --> 00:36:55.559
in the memory management programming guide for Cocoa.

00:36:55.559 --> 00:37:01.670
So we talked a little bit about what
UIKit will do for you automatically.

00:37:01.670 --> 00:37:06.720
But UIKit will also notify your
application code about memory warnings

00:37:06.719 --> 00:37:09.779
so you can respond and release other memory as well.

00:37:09.780 --> 00:37:11.370
And it does this in three ways.

00:37:11.369 --> 00:37:15.380
It will call the applicationDidReceiveMemoryWarning
method on the app delegate,

00:37:15.380 --> 00:37:20.050
it will call the DidReceiveWarning method
on all the all of the UIView controllers,

00:37:20.050 --> 00:37:25.490
and it will raise the UI applicationDidReceiveMemoryWarning
notification.

00:37:25.489 --> 00:37:29.859
So let's go into the Breadcrumbs app again and
take a look at how it implements each of these

00:37:29.860 --> 00:37:32.210
or how it uses each of these notifications.

00:37:32.210 --> 00:37:33.349
And let's start with the app delegate.

00:37:33.349 --> 00:37:38.159
So this is the Table view for the
Breadcrumbs application, again.

00:37:38.159 --> 00:37:43.210
And this Table view -- the data for this Table
view is actually stored in model objects.

00:37:43.210 --> 00:37:46.449
And all the model objects are stored
in array in the app delegate.

00:37:46.449 --> 00:37:51.359
So here it is, the app delegate with a
reference to that array of model objects.

00:37:51.360 --> 00:37:57.059
And what's more, these model objects are
actually read in lazily from a database.

00:37:57.059 --> 00:38:01.099
So here we have the property for the entries there,

00:38:01.099 --> 00:38:05.219
and it says that if the backing instance
variable M [phonetic] entries is null,

00:38:05.219 --> 00:38:08.809
then it will go to the Breadcrumb store,
which is our interface to our database,

00:38:08.809 --> 00:38:13.070
and read in all of the entries again, and then return back.

00:38:13.070 --> 00:38:18.630
So what the application delegate can then do is
implement the applicationDidReceiveMemoryWarning method

00:38:18.630 --> 00:38:21.750
and just release those entries and set that to nil.

00:38:21.750 --> 00:38:26.730
And then the next time the user tries to look at
the Table view or do anything with the Table view,

00:38:26.730 --> 00:38:33.079
it will try to access that property, read them all
back in from the database, and then go on its way.

00:38:33.079 --> 00:38:34.610
And so here it is again.

00:38:34.610 --> 00:38:40.110
And when we receive the memory warning,
all that memory will just go away.

00:38:41.449 --> 00:38:45.439
So now let's take a look at one of
the UIViewController subclasses.

00:38:45.440 --> 00:38:48.360
And again, let's take a look at that Compose view.

00:38:48.360 --> 00:38:53.870
Like I said before, the Compose view retains
several outlets to subviews on that view.

00:38:53.869 --> 00:38:57.719
Like the title label, the location
label, the text view, and so on.

00:38:57.719 --> 00:39:01.809
But it also retains a reference to the model
object that contains the data for that view.

00:39:01.809 --> 00:39:04.309
And in this case, it's called a Breadcrumb entry.

00:39:04.309 --> 00:39:11.849
So of course the ComposeViewController could
release the Breadcrumb entry and set that to nil,

00:39:11.849 --> 00:39:14.940
if it could reread the entire Breadcrumb
entry from the database.

00:39:14.940 --> 00:39:17.639
But it's a little bit more complicated
than that in this instance.

00:39:17.639 --> 00:39:20.949
The Breadcrumb entry actually contains data that can be --

00:39:20.949 --> 00:39:24.929
that both can be reconstructed from
the database and only exist in memory.

00:39:24.929 --> 00:39:31.169
So for example, the text for the entry and the image
associated with the entry are both things that are stored

00:39:31.170 --> 00:39:33.869
in the database and on the file system, too, respectively.

00:39:33.869 --> 00:39:38.259
But it also has some state that only exists in memory.

00:39:38.260 --> 00:39:45.240
So what it does is it exposes this received memory
warning method that will do exactly what we would want.

00:39:45.239 --> 00:39:48.969
It will release everything that
it could reread from the database

00:39:48.969 --> 00:39:52.289
or reread from the File System, but
leave everything else in memory.

00:39:52.289 --> 00:39:56.380
So in the ComposeViewController, I can then
override the DidReceiveMemoryWarning method,

00:39:56.380 --> 00:40:00.070
and then just call the receive
memory warning method on that entry,

00:40:00.070 --> 00:40:02.370
and then call my superclass's DidReceiveMemoryWarning.

00:40:02.369 --> 00:40:10.759
So let's take a look at one of the instances
where the app uses the direct notification API.

00:40:10.760 --> 00:40:16.240
So as I said before, we have this Breadcrumbs
store class which is our interface of the database.

00:40:16.239 --> 00:40:18.339
And it's actually a singleton instance.

00:40:18.340 --> 00:40:22.079
And the singleton instance keeps
a handle open to the database.

00:40:22.079 --> 00:40:26.869
And this handle will keep a lot of memory
resident just in case it will be used again.

00:40:26.869 --> 00:40:31.119
So it keeps this cache of memory
that can grow to be pretty large.

00:40:31.119 --> 00:40:37.059
And so what I do here is in the shared instance
method -- class method for the Breadcrumbs store,

00:40:37.059 --> 00:40:41.049
if the shared store is nil I will create a new store,

00:40:41.050 --> 00:40:46.580
and then register for that UI
applicationDidReceiveMemoryWarning notification.

00:40:46.579 --> 00:40:52.590
So that when that notification is posted it will
call me back in this received memory warning method,

00:40:52.590 --> 00:40:55.260
and I can release that store and set that to nil,

00:40:55.260 --> 00:40:58.280
and reclaim a lot of that memory
that the database handle was holing.

00:40:58.280 --> 00:41:03.670
And then I can unregister from the default center
so I no longer receive those notifications.

00:41:03.670 --> 00:41:12.150
So let's take a look at how -- what effect these --
responding to these memory warnings have in the memory app.

00:41:12.150 --> 00:41:15.630
And I'm going to switch back to Xcode now.

00:41:15.630 --> 00:41:22.400
And I'm going to switch to the simulator, because
the simulator actually has this really cool feature

00:41:22.400 --> 00:41:25.910
that let's me simulate the memory warning on the device.

00:41:25.909 --> 00:41:31.359
And I'm going to run this again under Object Alloc.

00:41:40.449 --> 00:41:43.909
And my target failed to launch

00:41:43.909 --> 00:41:47.389
So I actually ran this earlier as well.

00:41:47.389 --> 00:41:52.569
So why don't I go ahead and open up this trace here.

00:41:55.489 --> 00:42:00.429
And so let me zoom in on this track over here.

00:42:00.429 --> 00:42:06.389
And so as you can see, when -- as the application
launches it actually allocates a whole bunch of memory.

00:42:06.389 --> 00:42:13.859
And then at some point I can go into the simulator under
the hardware menu and click on Simulate Memory Warning.

00:42:13.860 --> 00:42:15.940
Right over here.

00:42:15.940 --> 00:42:18.440
Hardware Simulate Memory Warning.

00:42:18.440 --> 00:42:24.010
And then right when I do that, the memory
usage actually drops to almost nothing.

00:42:24.010 --> 00:42:30.390
So I can actually move this -- this inspection head
over here and see that it goes from 3.34 megabytes

00:42:30.389 --> 00:42:34.239
and then I issue the memory warning, and
because I respond to the memory warnings

00:42:34.239 --> 00:42:41.279
in all the different ways I showed you, it just drops
all the way down to 700 megs -- or 700 K, excuse me.

00:42:41.280 --> 00:42:45.530
But also notice that there's this
kind of funny spike over here

00:42:45.530 --> 00:42:48.960
at the very beginning of the application when we're loading.

00:42:48.960 --> 00:42:56.710
And again, if I actually switched into the Object List View
and tried to figure out what exactly was going on over here,

00:42:56.710 --> 00:43:01.500
I would find that it's actually allocating
a whole bunch of CF strings here.

00:43:01.500 --> 00:43:08.369
And if I had selected record reference counts
when I started the Object Alloc instrument,

00:43:08.369 --> 00:43:13.949
and I click on one of these addresses I find
that they're all actually Autorelease strings.

00:43:13.949 --> 00:43:19.210
So the spike probably has something
to do with Autoreleasing objects.

00:43:19.210 --> 00:43:28.000
So why don't we switch now back to the slides and Dave's
going to tell us a little bit more about Autorelease.

00:43:28.000 --> 00:43:35.949
>> So Autorelease pools are a really nice feature of
Cocoa, where you manage reference counts and you may want

00:43:35.949 --> 00:43:42.889
to decrement some reference count at some time in the
future as you transfer ownership from one object to another.

00:43:42.889 --> 00:43:49.940
And in UIKit when you handle any sort of event we
create an Autorelease pool for you that will stay

00:43:49.940 --> 00:43:53.570
around until you're done handling the event.

00:43:53.570 --> 00:43:58.400
So we have one giant Autorelease pool,
and every bit of memory that you --

00:43:58.400 --> 00:44:04.039
every object that you call autorelease on, or is
Autoreleased and returned by the system is called,

00:44:04.039 --> 00:44:13.150
such as Foundation -- some NSString parses methods,
all of that will go into this overall Autorelease pool.

00:44:13.150 --> 00:44:18.980
And if you accumulate too many Autorelease objects
then you'll result in the situation that Charles saw

00:44:18.980 --> 00:44:23.250
in the Instruments demo where you have this memory spike.

00:44:23.250 --> 00:44:29.010
So one example of this might be this little code
snippet where we have a little loop that's iterating

00:44:29.010 --> 00:44:36.870
through every entry in a database, and we're calling
a couple of methods that return Autoreleased objects.

00:44:36.869 --> 00:44:39.509
And potentially, a lot of them.

00:44:39.510 --> 00:44:46.780
So we have an array of lines, and to get that array we
take a string and we call componentsSeparatedByString.

00:44:46.780 --> 00:44:54.650
Now that's an NSString method that -- that takes a string
and basically splits it apart into an array of strings.

00:44:54.650 --> 00:44:57.860
Very useful for parsing, but it
returns a lot of Autoreleased objects.

00:44:57.860 --> 00:45:05.099
And then for each one of those lines we take another
character set and we try to trim it a little bit.

00:45:05.099 --> 00:45:13.860
So as we're going through this nested for loop,
we start increasing memory and increasing memory,

00:45:13.860 --> 00:45:18.400
until eventually we have a spike and if you use
too much memory you could actually have some sort

00:45:18.400 --> 00:45:21.070
of memory warning and your app could be terminated.

00:45:21.070 --> 00:45:27.940
So if you're ever using a lot of these methods that
return Autoreleased objects as you're parsing something--

00:45:27.940 --> 00:45:33.260
XML is a popular one, XML file that
could be arbitrarily large from a server,

00:45:33.260 --> 00:45:36.640
you may want to look at how you're
using Autoreleased objects.

00:45:36.639 --> 00:45:43.460
So what we can do here is as we process each
entry we can create our own Autorelease pool

00:45:43.460 --> 00:45:49.630
so that all the Autorelease objects that happen in those
two key methods that returned a lot of Autoreleased objects,

00:45:49.630 --> 00:45:54.550
all that will go away for each entry in the database.

00:45:54.550 --> 00:46:02.730
So we create a nested Autorelease pool, and then as
we iterate through that entry, our memory may grow.

00:46:02.730 --> 00:46:06.920
But as soon as we hit the Autorelease
pool drain, that memory will go away.

00:46:06.920 --> 00:46:12.619
So then we constantly grow and shrink and grow and
shrink, rather than constantly growing until we hit

00:46:12.619 --> 00:46:17.109
that large Autorelease pool in our event handling.

00:46:17.110 --> 00:46:23.800
And when we're using Autorelease there is times
when it may be tempting to use Autorelease

00:46:23.800 --> 00:46:26.230
in situations where you don't really need it.

00:46:26.230 --> 00:46:30.210
So one area where you don't really need
it is in a code block such as this.

00:46:30.210 --> 00:46:32.750
People often will try to create strings.

00:46:32.750 --> 00:46:37.750
It's very, very convenient to create some
formatted string using NSString string with format,

00:46:37.750 --> 00:46:40.170
and then maybe put it into a data structure.

00:46:40.170 --> 00:46:42.590
Could put it into some object, or in this case a dictionary.

00:46:42.590 --> 00:46:44.940
But that will create an autoreleased object.

00:46:44.940 --> 00:46:49.650
But you didn't really need one to do
this -- to do this small little snippet.

00:46:49.650 --> 00:46:54.650
So what we remember that instead of
this, use alloc init with format,

00:46:54.650 --> 00:46:59.720
which will return something that's not Autoreleased,
and then once you've transferred ownership by putting it

00:46:59.719 --> 00:47:03.539
into your dictionary or putting it into
your other object, then you can release it.

00:47:03.539 --> 00:47:07.369
So if at any point in time the
dictionary goes away, so will that string.

00:47:07.369 --> 00:47:11.989
Whereas if it's an Autorelease method it will
stick around, that string will stick around even

00:47:11.989 --> 00:47:15.489
if the dictionary goes away until
the Autorelease pool is drained.

00:47:15.489 --> 00:47:19.239
So keep in mind how you're using Autorelease pools.

00:47:19.239 --> 00:47:24.309
Now Charles is going to show you how to use
Autorelease pools better in the Breadcrumbs app.

00:47:24.309 --> 00:47:27.489
>> So here we are again in Instruments.

00:47:27.489 --> 00:47:32.069
We'd like to figure out exactly why
there's this big spike over here

00:47:32.070 --> 00:47:35.280
at the very beginning, when we're
starting up the application.

00:47:35.280 --> 00:47:41.170
So I've actually moved the inspection head over to
the spike and down here I found one of the strings

00:47:41.170 --> 00:47:43.650
that we actually created and Autoreleased.

00:47:43.650 --> 00:47:47.579
And I see over here in the Extended
Detail Pane that it was created

00:47:47.579 --> 00:47:51.440
in the parse title [phonetic] from
text method in my Breadcrumb entry.

00:47:51.440 --> 00:47:55.909
So if I double click this and take a look at
the code, you'll see code that's very similar

00:47:55.909 --> 00:47:58.889
to the code that Dave just showed you on the slides.

00:47:58.889 --> 00:48:04.619
It parses out the first line of text by calling
NSString components separated by characters in set,

00:48:04.619 --> 00:48:08.819
and calling NSString, string by trimming characters in set.

00:48:08.820 --> 00:48:11.000
Both of which return Autorelease memory.

00:48:11.000 --> 00:48:17.119
In fact, components separated by characters in set will
return an Autoreleased array of Autoreleased strings.

00:48:17.119 --> 00:48:22.250
And then this function is called from
a method called List Breadcrumbs.

00:48:22.250 --> 00:48:27.829
And List Breadcrumbs will go and fetch all of
the entries for Breadcrumbs from the database,

00:48:27.829 --> 00:48:32.630
and then step through them one by one, parsing
out the titles for each of the entries.

00:48:32.630 --> 00:48:38.619
And you see here that we have this Y [phonetic] loop that
steps through each of the rows, and then it comes down here,

00:48:38.619 --> 00:48:43.299
parses out the text, the full text of the notes from the
database using string with UTF-8 string [Assumed spelling]

00:48:43.300 --> 00:48:46.240
which also returns an Autorelease string.

00:48:46.239 --> 00:48:47.759
Then call parse title [phonetic] from text.

00:48:47.760 --> 00:48:54.850
And then because there's no other autorelease
pool around here, all of that memory will go

00:48:54.849 --> 00:49:00.559
into the Autorelease pool that's created
for this run through the event loop.

00:49:00.559 --> 00:49:04.989
Since this doesn't return yet, just goes
back around and goes onto the next entry,

00:49:04.989 --> 00:49:07.889
we will parse out the full text again, and
parse out the title [phonetic] from the text,

00:49:07.889 --> 00:49:12.879
and now all of this memory is in
the Autorelease pool as well.

00:49:12.880 --> 00:49:18.180
And so as you can imagine, since it goes and reads in
all of the entries from the database before returning

00:49:18.179 --> 00:49:21.899
to this function, that Autorelease pool
can actually grow to be pretty big.

00:49:21.900 --> 00:49:25.860
And none of that memory will be released
or reclaimed until the very end of the --

00:49:25.860 --> 00:49:28.880
of the event loop, the run through the event loop.

00:49:28.880 --> 00:49:32.180
And so that's why we had that really big spike over there.

00:49:32.179 --> 00:49:38.029
So I can -- I can -- of course I can actually change all
of these string with UTF-8 string, and components separated

00:49:38.030 --> 00:49:43.050
by string calls into the associated init call.

00:49:43.050 --> 00:49:47.100
But maybe this is an API boundary,
and I can't actually do that.

00:49:47.099 --> 00:49:53.219
So one of the things I could do here is take --
actually create an Autorelease pool for this loop.

00:49:53.219 --> 00:49:58.039
Let me open this up in Xcode.

00:49:58.039 --> 00:50:10.269
Sorry. And then at the very end of the
iteration through the loop I drain the pool.

00:50:10.269 --> 00:50:16.840
So now if I do this, we get into the Y [phonetic]
loop over here, we create a new Autorelease pool,

00:50:16.840 --> 00:50:22.500
we parse out the string from the database, and we parse the
title from the database, but all of this memory over here

00:50:22.500 --> 00:50:27.340
for the title, all that Autorelease memory
will go into this Autorelease pool over here,

00:50:27.340 --> 00:50:30.230
because this is the closest --
scope, scoped Autorelease pool.

00:50:30.230 --> 00:50:36.740
And then at the very end of processing this particular
entry I will drain the pool and release all of that memory.

00:50:36.739 --> 00:50:41.379
And then go back around to the next entry,
create a new pool, and repeat the whole process.

00:50:41.380 --> 00:50:47.079
So now let's run this in Object
Alloc, and see what it looks like.

00:50:53.730 --> 00:50:55.579
So again, it fails to launch.

00:50:55.579 --> 00:51:00.409
Let me try that one more time.

00:51:00.409 --> 00:51:04.909
Sorry, I actually selected the device
one that time and not the simulator.

00:51:06.320 --> 00:51:09.600
And so now you see in Object Alloc that instead

00:51:09.599 --> 00:51:14.269
of that really big spike we had before,
we have this really tiny spike now.

00:51:14.269 --> 00:51:17.880
Which is great, because as Dave said
earlier in the presentation any spikes

00:51:17.880 --> 00:51:22.730
in memory allocations could potentially cause the frontmost
app to be terminated, if it's getting really close

00:51:22.730 --> 00:51:27.690
to -- to that, to lots of memory pressure.

00:51:27.690 --> 00:51:30.619
So let's switch back to the slides now, and
Dave's going to tell us a little bit more

00:51:30.619 --> 00:51:34.869
about those low memory logs we saw earlier.

00:51:34.869 --> 00:51:41.409
>> So now you've done the work, you've done the
development process, and you're iterating on your app.

00:51:41.409 --> 00:51:46.309
And you may see one of these low memory logs at
certain times during the development process.

00:51:46.309 --> 00:51:50.929
So what does this low memory log that you saw in Xcode mean?

00:51:50.929 --> 00:51:55.169
Well, so in the Xcode organizer there's a little
crash logs tab, and you'll see all the crashes

00:51:55.170 --> 00:52:00.659
and all the low memory logs and as Charles pointed out,
they actually do say low memory as part of the type.

00:52:00.659 --> 00:52:05.329
And when you have identified that your
crash was in fact a low memory log,

00:52:05.329 --> 00:52:08.559
then you'll want to know, well, what was wrong.

00:52:08.559 --> 00:52:13.799
So the first -- the main question you want
to answer was, well, how big was my app.

00:52:13.800 --> 00:52:20.840
So if you zoom in to some of the content of this
-- of the low memory log we list a few things.

00:52:20.840 --> 00:52:25.050
We list the number of free pages, which is always
going to be small because we terminated an app.

00:52:25.050 --> 00:52:29.900
The number of wired pages, which is a
little over 30 megabytes in this case.

00:52:29.900 --> 00:52:37.329
And of course we list the largest process, which
is almost always going to be the frontmost app.

00:52:37.329 --> 00:52:44.299
Here we tell you how many pages that that frontmost --
that that process that was terminated was actually using.

00:52:44.300 --> 00:52:48.840
So here Breadcrumbs is using 16,000
pages or about 64 megabytes.

00:52:48.840 --> 00:52:52.630
And that's going to be a little
bit too much memory on iPhone.

00:52:52.630 --> 00:52:55.480
And we note that on the right it tells you

00:52:55.480 --> 00:52:59.530
which applications were jettisoned,
or terminated because of low memory.

00:52:59.530 --> 00:53:02.950
And on the far right is shows you
which applications were active.

00:53:02.949 --> 00:53:10.519
So SpringBoard is always active, and your
app, the frontmost app is an active app.

00:53:10.519 --> 00:53:17.269
And also note that as you're looking through these logs,
if SpringBoard's memory is fairly high, then that's when --

00:53:17.269 --> 00:53:21.070
that's a call for you to go and look
and see how many layers you have.

00:53:21.070 --> 00:53:27.010
If SpringBoard memory is 20 megs, 30 megs, then
that could be a sign that you have a lot of layers

00:53:27.010 --> 00:53:30.900
that you have sticking around that perhaps you can free up.

00:53:30.900 --> 00:53:36.860
And as you're looking at the logs you'll see other processes
that are running on iPhone and there are some common --

00:53:36.860 --> 00:53:41.170
some common processes that are going to be
running in the background for most users.

00:53:41.170 --> 00:53:47.269
Mail, phone, Safari, our media server
for all of your audio and video playback.

00:53:47.269 --> 00:53:52.320
And if you run into a situation in which it's
not your frontmost app but some other app

00:53:52.320 --> 00:53:58.769
on the system is taking a lot of memory, then
definitely file a radar [phonetic] and file a bug report

00:53:58.769 --> 00:54:03.659
with the low memory log and we'll
definitely take a look at it.

00:54:03.659 --> 00:54:08.119
So what happens when you debugged
everything, you looked at the low memory logs,

00:54:08.119 --> 00:54:14.279
you used the tools to eliminate all the problems that you
know of, and you're ready to post your app to an App Store.

00:54:14.280 --> 00:54:21.830
Well the App Store has a great way of reporting all
of your crashes and low memory issues after the fact.

00:54:21.829 --> 00:54:27.239
So iTunes -- if you log into iTunes Connect it will
show you the crash reports as of the current date,

00:54:27.239 --> 00:54:30.509
and it will show you the last weeks of logs.

00:54:30.510 --> 00:54:39.540
And the logs are break -- broken down by crashes, time outs,
if for instance your application fails to launch in time

00:54:39.539 --> 00:54:42.400
because it took more than 20 seconds to launch

00:54:42.400 --> 00:54:46.789
And it will tell you how many of your
crashes were due to exhausted memory.

00:54:46.789 --> 00:54:50.250
And this should give you a sense
of how to priorities problems.

00:54:50.250 --> 00:54:55.289
Some apps will crash a lot, and so
then your priority is just the crashes.

00:54:55.289 --> 00:54:56.929
Fixing those bugs.

00:54:56.929 --> 00:55:00.769
Other apps, maybe more than half of
the issues are low memory issues.

00:55:00.769 --> 00:55:03.619
In which case, you need to look at
low memory issues that you have.

00:55:03.619 --> 00:55:09.619
And when you get into iTunes Connect you can
see some representative logs for each of these.

00:55:09.619 --> 00:55:14.859
And that will give you an idea about what problems you
need to solve so that your users have the best experience

00:55:14.860 --> 00:55:19.539
that they can, and so that your app
is always going to be -- remain alive.

00:55:19.539 --> 00:55:25.849
So you can use iTunes Connect to figure out how you --
whether or not your application is crashing after the fact,

00:55:25.849 --> 00:55:28.420
and that is a really, really powerful tool.

00:55:28.420 --> 00:55:34.170
And you'll also notice that as part of the
iTunes Connect UI we tell you the average amount

00:55:34.170 --> 00:55:36.400
of resident memory that you're using.

00:55:36.400 --> 00:55:38.349
20 megs would probably be a little bit small.

00:55:38.349 --> 00:55:46.440
Most apps you'll see somewhere between 45 and
65 megabytes fore the average resident memory.

00:55:46.440 --> 00:55:51.510
So in summary, we have a bunch of great memory tools
to help you track down all of your memory problems.

00:55:51.510 --> 00:55:57.300
We have Object Alloc for all of your malloc allocations,
we have Leaks to make sure that you don't have references

00:55:57.300 --> 00:56:04.039
to objects that you no longer care about, the Xcode
Static Analyzer to find problems before you run the code,

00:56:04.039 --> 00:56:09.190
and Activity Monitor to give you a sense of
just how much memory your process is using.

00:56:09.190 --> 00:56:13.760
If you follow the Cocoa memory guidelines
and use Autorelease pools effectively,

00:56:13.760 --> 00:56:19.740
then you will eliminate the memory spikes and ensure
that your application will stick around as long

00:56:19.739 --> 00:56:21.899
as possible -- as long as a user wants it around.

00:56:21.900 --> 00:56:25.500
And then always release images
when they're no longer needed.

00:56:25.500 --> 00:56:28.230
That includes responding to low memory warnings.

00:56:28.230 --> 00:56:32.079
If you ever don't need a large piece of -- a large --

00:56:32.079 --> 00:56:36.880
an object that uses a lot of memory then
definitely get rid of it when you don't need it.

00:56:36.880 --> 00:56:42.710
And always, always respond to low memory warnings and
architect your app in such a way that it can respond

00:56:42.710 --> 00:56:47.990
to low memory warnings and free up the large chunks
of memory so that your app can continue to function

00:56:47.989 --> 00:56:50.059
and users will have a really great experience.
WEBVTT

00:00:12.660 --> 00:00:13.339
>> Good morning.

00:00:13.339 --> 00:00:16.350
My name is Joshua Graessley, I'm a
Senior Software Engineer at Apple.

00:00:16.350 --> 00:00:21.410
I work in Core OS and I'm going to be
talking about iPhone OS Networking.

00:00:21.410 --> 00:00:25.670
We'll go over a few things today.

00:00:25.670 --> 00:00:30.340
We'll start with the networking APIs that are available
to you as a third party application on the phone;

00:00:30.339 --> 00:00:35.780
we'll cover some of the major differences from Mac OS X
and we'll also go over some new features such as device

00:00:35.780 --> 00:00:40.289
to device communication; we'll cover
some techniques for dealing with mobility

00:00:40.289 --> 00:00:44.070
and we'll finish up with some performance tips.

00:00:45.189 --> 00:00:50.989
The iPhone OS has a full networking
stack that comes straight from Mac OS X.

00:00:50.990 --> 00:00:57.270
There are a few changes mostly to address things
like power, cover cases of mobility for transitioning

00:00:57.270 --> 00:01:00.800
from different networks all the
time and to improve performance.

00:01:00.799 --> 00:01:03.539
And again the performance thing
is really about improving power--

00:01:03.539 --> 00:01:08.329
the fewer cycles we use, the less memory
we use, the less power we end up using.

00:01:08.329 --> 00:01:14.370
The iPhone environment is a little bit
different from the desktop environment.

00:01:14.370 --> 00:01:20.219
The desktop we can have multiple interfaces, additional
interfaces that didn't come standard with the machine.

00:01:20.219 --> 00:01:23.620
On the iPhone and the iPod Touch
there's a standard set of interfaces.

00:01:23.620 --> 00:01:29.450
You have the WiFi interface; and in the case
of the iPhone you have the cellular interface.

00:01:29.450 --> 00:01:35.070
There's also a Bluetooth PAN interfaces that will come
and go now for the device to device communication;

00:01:35.069 --> 00:01:37.299
and we have VPN interfaces that can be set up.

00:01:37.299 --> 00:01:42.789
In iPhone OS 3.0 we've got VPN on demand is a new feature.

00:01:42.790 --> 00:01:48.190
Finally, we only have iPv4; there is no iPv6,
and that isn't because we don't like iPv6,

00:01:48.189 --> 00:01:50.409
we were just concerned about the resources that would take.

00:01:50.409 --> 00:01:53.920
In the future we will be adding iPv6 but we won't say when.

00:01:53.920 --> 00:01:59.890
We also have Bonjour in there;
we've had Bonjour from the start.

00:01:59.890 --> 00:02:06.920
It's a fantastic technology that works really well over WiFi
and we've done some cool stuff with it in iPhone OS 3.0.

00:02:06.920 --> 00:02:11.430
So this is just a diagram of a lot of the
networking APIs that are available to you.

00:02:11.430 --> 00:02:14.900
We have APIs at three different
layers; there's the BSD Socket Layer

00:02:14.900 --> 00:02:19.599
down at Darwin, we've got Core Foundation and Cocoa.

00:02:19.599 --> 00:02:24.239
If you're really comfortable with Objective-C,
the best place to start is the Cocoa Layer.

00:02:24.240 --> 00:02:30.510
If you're a little bit more comfortable with just
regular C you can start with the Core Foundation Layer;

00:02:30.509 --> 00:02:35.060
and if one of these layers doesn't provide what
you need you can always drop down to the BSD Layer.

00:02:35.060 --> 00:02:39.490
So focus on sockets.

00:02:39.490 --> 00:02:42.710
We have Socket Layer APIs at the
Darwin and Core Foundation Layers.

00:02:42.710 --> 00:02:45.320
Darwin is just straight BSD sockets.

00:02:45.319 --> 00:02:52.500
We have the standard name resolution APIs; getaddrinfo;
getnameinfo, and then there's things like kqueue and select

00:02:52.500 --> 00:02:56.289
to watch for events on multiple file descriptors.

00:02:56.289 --> 00:03:02.310
At the Core Foundation Layer for dealing with sockets, most
of what we have is all about integrating with the Run loop.

00:03:02.310 --> 00:03:08.420
CFSocket is a fantastic API that gives you a way to
receive event notification, so when something occurs

00:03:08.419 --> 00:03:12.589
on a socket you'll get notified through
a callback on your actual Run loop.

00:03:12.590 --> 00:03:17.729
And CFHost is a good API for doing name
resolution in an asynchronous manner

00:03:17.729 --> 00:03:19.519
so you don't have to block your Run loop.

00:03:19.520 --> 00:03:26.689
Moving up a little bit we have a Stream
Abstraction Layer to stream APIs.

00:03:26.689 --> 00:03:31.329
These are not to be confused with the old Mentat streams.

00:03:31.330 --> 00:03:34.990
The Stream Abstraction Layer provides
a way that you can interact

00:03:34.990 --> 00:03:38.159
with the PCP stream without actually touching the socket.

00:03:38.159 --> 00:03:40.889
The frameworks cover that.

00:03:40.889 --> 00:03:47.809
It also adds support for SSL and TLS and it includes
support for proxies to make that a little simpler.

00:03:47.810 --> 00:03:53.870
It won't automatically get the proxy settings out of
the dynamic store or the system configuration framework.

00:03:53.870 --> 00:03:57.060
You'll be responsible for pushing
proxy settings into these APIs

00:03:57.060 --> 00:04:01.780
and there's a CF proxy support
API to get the proxy settings.

00:04:01.780 --> 00:04:08.840
At the Cocoa Layer there's an NSStream class
and at the Core Foundation Layer the CFStream.

00:04:10.849 --> 00:04:14.699
In addition to the stream abstraction we have
support for a lot of the common protocols.

00:04:14.699 --> 00:04:21.610
At the Cocoa Layer there's the URL loading system, and
at the Core Foundation Layer there's more CFNetwork.

00:04:23.079 --> 00:04:27.039
The Common Protocol support is FTP, HTTP, and HTTPS.

00:04:27.040 --> 00:04:32.740
At the Cocoa Layer we have NSURLConnection;
NSURLResponse and NSURLRequest.

00:04:32.740 --> 00:04:37.870
And at the Core Foundation layer we
have CFStream and CFHTTP Message.

00:04:37.870 --> 00:04:42.370
These make it really simple to interact with these
protocols and the documentation is really good.

00:04:42.370 --> 00:04:45.240
Actually I spent a lot of time using
these APIs working on a new feature,

00:04:45.240 --> 00:04:48.250
and I found everything I needed in the documentation.

00:04:48.250 --> 00:04:53.720
Finally, we have Service Discovery.

00:04:53.720 --> 00:04:56.790
Service Discovery is available at all three layers.

00:04:56.790 --> 00:05:04.189
At the BSD Layer there's the Bonjour API; and the
Bonjour API actually has REM loop support built into it

00:05:04.189 --> 00:05:08.180
so you can use it directly from Core Foundation very easily.

00:05:08.180 --> 00:05:15.509
There's also a CFNetServices wrapper that simplifies the API
a fair amount, but it also eliminates some of the options

00:05:15.509 --> 00:05:18.349
and flexibility of the lower level Bonjour API.

00:05:18.350 --> 00:05:22.350
So if CFNetServices does what you like and
you prefer that, it's fine to use that.

00:05:22.350 --> 00:05:27.879
If you need the flexibility that the lower level
API gives you then that will work just as well.

00:05:27.879 --> 00:05:32.829
And finally at Cocoa, there's a
NSNetService that's just like CFNetService.

00:05:32.829 --> 00:05:37.019
There's a few other miscellaneous APIs.

00:05:37.019 --> 00:05:40.969
We'll go over Game Kit right now and
cover reachability in a little bit.

00:05:40.970 --> 00:05:45.480
Game Kit is a new feature of iPhone OS 3.0.

00:05:45.480 --> 00:05:47.700
It provides a few really neat things.

00:05:47.699 --> 00:05:52.039
There's a user interface for setting
up device to device communication;

00:05:52.040 --> 00:05:56.689
you can do voice chat as well as data sessions for games.

00:05:56.689 --> 00:05:59.469
The data sessions will only work over Bluetooth.

00:05:59.470 --> 00:06:01.730
Voice chat will work over Bluetooth and WiFi.

00:06:01.730 --> 00:06:05.790
One of the important things to remember is
with the new device to device communication,

00:06:05.790 --> 00:06:08.910
Game Kit runs on top of Bonjour and the sockets.

00:06:08.910 --> 00:06:14.670
If you want to use data sessions over Bluetooth and
WiFi, you can just drop down to Bonjour and sockets

00:06:14.670 --> 00:06:18.090
and use that stuff directly and you'll
get the Bluetooth and WiFi support.

00:06:18.089 --> 00:06:23.239
If you want to use the user interface, then you do
have to use Game Kit but you will have this restriction

00:06:23.240 --> 00:06:27.620
that you won't be able to use game sessions over WiFi.

00:06:27.620 --> 00:06:30.009
It's Bluetooth only.

00:06:30.009 --> 00:06:34.469
There are some things about the
iPhone environment that are unique.

00:06:34.470 --> 00:06:40.370
When you're running as a third party application, you
don't have any access; you don't get to run this root.

00:06:40.370 --> 00:06:45.250
So you can't do anything that you
wouldn't be able to do running as root.

00:06:45.250 --> 00:06:49.050
For example, you can't open a routing
socket and change the routing tables.

00:06:49.050 --> 00:06:52.980
You get read only access to those routing sockets.

00:06:52.980 --> 00:06:59.740
There's also no access to setting up security policies
or security associations through a PF_KEY socket;

00:06:59.740 --> 00:07:07.769
there's no access to BPF or Berkeley Packet Filter, so you
can't write a network diagnostic tool that relies on that.

00:07:07.769 --> 00:07:16.060
There's also limited access to Raw IP; you can use an
ICMP echo socket so you can do PNG but that's about it.

00:07:16.060 --> 00:07:19.589
And there's no access to low numbered
ports; there was no access.

00:07:19.589 --> 00:07:24.339
In iPhone OS 3.0 we actually removed the restrictions
so any application combined to a low numbered port.

00:07:24.339 --> 00:07:31.219
There is a subset of system configuration
framework available, the whole thing isn't there;

00:07:31.220 --> 00:07:35.700
primarily the reachability APIs, and the
reachability APIs are really important.

00:07:35.699 --> 00:07:37.479
We'll cover that in a little bit.

00:07:37.480 --> 00:07:39.100
And there's a new CFProxySupport API.

00:07:39.100 --> 00:07:48.970
In the past you would use the system configuration framework
to get the proxy settings to push into CFStream or NSStream;

00:07:48.970 --> 00:07:53.700
but now that you don't have access to system
configuration, we provided a new API-- CFProxySupport.

00:07:53.699 --> 00:07:54.789
It makes it a lot simpler.

00:07:54.790 --> 00:07:57.830
It provides notification when the proxies change.

00:08:00.019 --> 00:08:04.049
There are a number of new features in
iPhone OS-- there's captive network support;

00:08:04.050 --> 00:08:08.129
scoped routing and Bluetooth device to device.

00:08:08.129 --> 00:08:14.689
Captive Network Support is an interesting new feature to
handle the case where you're on one of these WiFi networks

00:08:14.689 --> 00:08:17.449
that requires some form of authentication.

00:08:17.449 --> 00:08:23.519
When the iPhone gets onto one of these networks,
performs a DHCP request and it gets back a DHCP response

00:08:23.519 --> 00:08:26.500
and it has an IP address, it has
Gateway, it's got a DNS server--

00:08:26.500 --> 00:08:28.860
it thinks, this is great, I've got Internet connectivity.

00:08:28.860 --> 00:08:34.789
But when it sends packets to the Gateway, the Gateway
is going to drop those packets unless they're HTTP,

00:08:34.789 --> 00:08:36.829
in which case it's going to redirect them.

00:08:36.830 --> 00:08:40.160
So if mail is running mail can't
make any connections anymore.

00:08:40.159 --> 00:08:47.069
If something like the stocks App is running, stocks App
can't get to any of its data because it doesn't know how

00:08:47.070 --> 00:08:50.129
to parse the response that it's getting back.

00:08:50.129 --> 00:08:53.789
This is really bad and we wanted to work
really hard to try and avoid having a phone

00:08:53.789 --> 00:08:57.709
in this state any longer than absolutely necessary.

00:08:57.710 --> 00:09:02.139
So with Captive Network Support when the phone
joins a WiFi network it's going to perform a probe.

00:09:02.139 --> 00:09:08.139
And this probe is just a simple HTTP GET, and in
the case of most captive networks that GET is going

00:09:08.139 --> 00:09:10.899
to be redirected and will detect if it was redirected.

00:09:10.899 --> 00:09:15.889
And we'll look at that redirect and we'll see whether there
was a little bit of information in there that indicates

00:09:15.889 --> 00:09:20.110
that that hotspot supports WISPr-- Wireless ISP Roaming.

00:09:20.110 --> 00:09:23.680
It's a protocol that lets you authenticate automatically.

00:09:23.679 --> 00:09:26.809
In the event that the hotspot does
support WISPr, we'll look in the key chain

00:09:26.809 --> 00:09:29.569
and see if we have credentials for this network.

00:09:29.570 --> 00:09:33.160
If we have credentials, we'll go ahead and try and
authenticate without even getting the user involved.

00:09:33.159 --> 00:09:33.809
It's really nice.

00:09:33.809 --> 00:09:35.019
It just works.

00:09:35.019 --> 00:09:43.720
In the event that the authentication fails or we have
no credentials or the hotspot didn't support WISPr,

00:09:43.720 --> 00:09:45.700
then we'll fall back to something called the web sheet.

00:09:45.700 --> 00:09:48.820
And the web sheet is this little
sheet, it's actually on the slide here,

00:09:48.820 --> 00:09:53.830
and it pops up over whatever application you've currently
got; and it's got a web view in it, there's a cancel button,

00:09:53.830 --> 00:09:56.850
and you can go and do whatever you need to do to get online.

00:09:56.850 --> 00:10:00.250
As soon as you manage to get online,
the web sheet will detect that

00:10:00.250 --> 00:10:02.909
and it will slide away leaving you in
the application you were in before.

00:10:02.909 --> 00:10:09.779
If you enter credentials like you use a name and a password,
the web sheet will try and scrape those credentials

00:10:09.779 --> 00:10:14.809
and push them into the key chain so we can authenticate
automatically the next time we associate with this hotspot.

00:10:14.809 --> 00:10:24.719
In the event that we don't have a networking application
in the foreground, then we don't want to show the web sheet

00:10:24.720 --> 00:10:26.080
because we don't want to bother the user.

00:10:26.080 --> 00:10:31.590
So we'll actually flip back to the cellular network
and wait until a networking application runs;

00:10:31.590 --> 00:10:34.290
and then when that networking application
comes up we'll show the web sheet.

00:10:34.289 --> 00:10:39.549
If the user cancels out of the web sheet or hits
the home or lock buttons, the web sheet will go away

00:10:39.549 --> 00:10:42.299
and will disassociate from that WiFi network.

00:10:42.299 --> 00:10:46.229
This does two things-- this gives WiFi
another chance to associate with a network

00:10:46.230 --> 00:10:52.019
that will provide us Internet connectivity, and in the event
there are no other WiFi networks that are known networks,

00:10:52.019 --> 00:10:54.149
we'll fall back to using the cellular network.

00:10:54.149 --> 00:10:58.269
So by the time the web sheet's gone the
device is going to be back on the Internet.

00:10:58.269 --> 00:11:06.600
Scoped routing is another new feature of iPhone OS 3.0.

00:11:06.600 --> 00:11:12.750
In the past the routing was fairly simplistic,
it was based only on the destination address;

00:11:12.750 --> 00:11:18.379
and we've made a lot of changes to add
intelligence to the routing algorithms.

00:11:18.379 --> 00:11:23.480
This will change the routing algorithm to look not just
at the destination address but the source address as well;

00:11:23.480 --> 00:11:29.500
so we look at it and which interface did this come
from, we'll send the packet out the same interface.

00:11:29.500 --> 00:11:35.490
This gives us a lot of flexibility now and there are a lot
of services on the phone itself that take advantage of this.

00:11:35.490 --> 00:11:38.570
Visual voicemail, for example,
makes sure that traffic only goes

00:11:38.570 --> 00:11:42.660
out the cellular interface and it
uses scoped routing to do this.

00:11:42.659 --> 00:11:47.949
With visual voicemail, the voicemail servers are only
available on the cellular network in a lot of cases;

00:11:47.950 --> 00:11:51.370
since we can't get those over WiFi we need
some way to be able to force the traffic

00:11:51.370 --> 00:11:55.000
over the cellular network even
when WiFi is the primary interface.

00:11:55.000 --> 00:12:02.700
With the push notifications, we use push
notifications over cellular for power reasons;

00:12:02.700 --> 00:12:08.750
and because we never really know what kind of network we're
on so we're never sure that we can get notifications back.

00:12:08.750 --> 00:12:14.320
With the cellular network we may behind in NAT but we know a
lot about the NAT so we can make some intelligent decisions

00:12:14.320 --> 00:12:18.080
about how often we have to send keep-alives and whatnot.

00:12:18.080 --> 00:12:20.560
Exchange support does the same thing for push notifications.

00:12:20.559 --> 00:12:25.989
They force these things over the cellular network;
and Internet tethering will also use scoped routing

00:12:25.990 --> 00:12:32.639
to cause the traffic to go over the cellular Internet, so
if your phone is on WiFi that you've got your Mac tethered,

00:12:32.639 --> 00:12:38.629
the tethering will actually go through the cell phone
network while your iPhone is using the WiFi network.

00:12:38.629 --> 00:12:41.269
And finally, Game Kit takes advantage of this.

00:12:41.269 --> 00:12:46.319
With Game Kit and device to device, the device to device
interface will come up and Game Kit will bind the socket

00:12:46.320 --> 00:12:50.020
to the right interface to force the
traffic out that Bluetooth Pen interface.

00:12:50.019 --> 00:12:56.319
This is the feature that was developed for the
phone but is actually new in SnowLeopard as well,

00:12:56.320 --> 00:12:59.530
and it has a number of benefits on the desktop OS.

00:12:59.529 --> 00:13:02.990
For servers you can do load balancing
across multiple interfaces a lot better

00:13:02.990 --> 00:13:05.480
because the traffic will go out the right interface.

00:13:05.480 --> 00:13:11.450
So this is a little diagram to kind
of help explain how this stuff works.

00:13:11.450 --> 00:13:17.820
If you've got an application running on the iPhone and were
connected to the cellular network, when the application goes

00:13:17.820 --> 00:13:22.550
to perform a connect, the networking stack will
give it a socket that's bound to the IP address

00:13:22.549 --> 00:13:26.969
from the cellular network-- in this case we've got 10.1.2.3.

00:13:28.129 --> 00:13:30.269
Traffic's working fine, everything's great.

00:13:30.269 --> 00:13:36.490
When the WiFi interface comes up, the default route is
going to switch to WiFi and that's going to be a problem.

00:13:36.490 --> 00:13:41.730
When the networking stack looks at the destination,
it will see, oh, the server's on the Internet.

00:13:41.730 --> 00:13:48.170
My primary route to the Internet is over the WiFi interface,
so it will send the packet over the WiFi interface.

00:13:48.169 --> 00:13:51.329
The problem is the packet's going to have
the source address from the cellular network.

00:13:51.330 --> 00:13:57.540
And when that packet goes out on the WiFi
network, the WiFi network is going to drop it.

00:13:57.539 --> 00:14:00.789
The application won't get notified and the
networking stack doesn't get notified either.

00:14:00.789 --> 00:14:04.919
At some point in time your connection's going to
time out, but your user is going to be sitting

00:14:04.919 --> 00:14:09.949
around waiting, going, "What the heck is going on?"

00:14:09.950 --> 00:14:15.629
With iPhone OS 3.0 we've made the
routing a lot more intelligent.

00:14:15.629 --> 00:14:20.129
New connections will go over the WiFi interface and
follow the default route, but existing connections,

00:14:20.129 --> 00:14:24.009
when they send a packet, the networking
stack will look at the source address and go,

00:14:24.009 --> 00:14:25.649
oh, that's a source on the cellular network.

00:14:25.649 --> 00:14:28.779
I need to make sure that packet
goes out the cellular interface

00:14:28.779 --> 00:14:33.159
and the connection will remain over the cellular interface.

00:14:33.159 --> 00:14:36.409
You won't gain any advantages of the fact
that there's a WiFi interface available,

00:14:36.409 --> 00:14:38.879
and you can actually run into some problems here.

00:14:38.879 --> 00:14:43.700
So your connection is going to be slower because cellular
is usually slower; in some cases it might be faster

00:14:43.700 --> 00:14:48.570
but it's safe to assume that if WiFi
is up you should try and use that.

00:14:48.570 --> 00:14:52.440
With the WiFi interface up and the cellular interface
up at the same time you're draining power faster

00:14:52.440 --> 00:14:54.820
than if you were just making use of the WiFi interface.

00:14:54.820 --> 00:15:01.670
So if you can that's really good
to try and switch over to WiFi.

00:15:01.669 --> 00:15:05.449
Coping with routing is fairly hard.

00:15:05.450 --> 00:15:07.520
It's a challenge to get right.

00:15:07.519 --> 00:15:09.620
Reachability API will save you.

00:15:09.620 --> 00:15:13.250
It has the information that you need
to write your application properly.

00:15:13.250 --> 00:15:19.870
It's not simple to use, but if you
get this right it really shows.

00:15:19.870 --> 00:15:21.879
Reachability will let you know when there's a change.

00:15:21.879 --> 00:15:26.059
When you see one of these changes from reachability you
need to look at the networking environment and decide

00:15:26.059 --> 00:15:30.399
if it makes more sense to reconnect or stay
with the current connection that you have.

00:15:30.399 --> 00:15:34.090
Scoped routing will actually cover up some of the
mistakes that you might have caught in the past.

00:15:34.090 --> 00:15:39.360
For example, when WiFi comes up the network connection
in the past would have just timed out after a while;

00:15:39.360 --> 00:15:42.370
and in testing you probably would
have seen that and caught that.

00:15:42.370 --> 00:15:44.600
Now it will just keep working but it will work slower

00:15:44.600 --> 00:15:47.899
and will be draining power faster
because we're using both interfaces.

00:15:47.899 --> 00:15:51.759
So how do we fix this?

00:15:51.759 --> 00:15:57.779
With reachability you'll get a lot of information about
when there are changes to the networking environment.

00:15:57.779 --> 00:16:02.230
Networking is really easy to write code that
kind of works when you're sitting in your office

00:16:02.230 --> 00:16:05.129
and you have a great Internet connection.

00:16:05.129 --> 00:16:09.669
DNS is always responding; the server is
always responding; everything is great.

00:16:09.669 --> 00:16:13.939
When you go out into the real world and you're switching
back and forth between WiFi and cellular or you're going

00:16:13.940 --> 00:16:21.820
through a tunnel on the train and you lose all of your
connectivity, it's a lot harder to cope with these changes.

00:16:21.820 --> 00:16:25.400
Reachability gives you information
about when these events occur.

00:16:25.399 --> 00:16:29.209
It's not something you should use as a
pre-flight check; this is a common mistake.

00:16:29.210 --> 00:16:36.580
What you want to do is you want to go ahead and perform your
connection first, and at the same time start up reachability

00:16:36.580 --> 00:16:39.450
to watch the host that you're interested in connecting to.

00:16:39.450 --> 00:16:40.920
Your connection will succeed or fail.

00:16:40.919 --> 00:16:45.519
If it fails you'll get a reachability
notification when it might be reachable

00:16:45.519 --> 00:16:47.870
so you can try and connect again at that time.

00:16:47.870 --> 00:16:53.289
If it succeeds, you'll get a reachability notification when
there might be a different way that you can connect to it.

00:16:53.289 --> 00:16:57.549
So having that reachability there is really useful,
but it's also important to remember to connect first.

00:16:57.549 --> 00:17:01.049
If you do your reachability first and then connect later,

00:17:01.049 --> 00:17:05.829
you're just adding time before your
connection's going to complete.

00:17:05.829 --> 00:17:09.669
The other really important thing to note is
that reachability lets you avoid polling.

00:17:09.670 --> 00:17:13.710
If you didn't have a reachability API available
to you and your connect failed the first time,

00:17:13.710 --> 00:17:18.880
you'd have to pick some interval that you would
retry after, so you could go with 30 seconds.

00:17:18.880 --> 00:17:23.400
That's going to take a fair amount of power, you might
back off to a minute, but then if there's a change,

00:17:23.400 --> 00:17:25.280
it's going to take a whole minute for you to notice.

00:17:25.279 --> 00:17:32.899
If you use reachability, you'll get those
notifications immediately and you can respond to them.

00:17:32.900 --> 00:17:35.950
The reachability API is fairly straightforward.

00:17:35.950 --> 00:17:39.170
There's a NetworkReachabilityRef that
you'll need to make use of the API.

00:17:39.170 --> 00:17:44.200
You can create one of these ReachabilityRefs
using two different functions.

00:17:44.200 --> 00:17:50.809
There's a SCNetworkReachabilityCreateWithName
and SCNetworkReachabilityCreateWithAddressPair.

00:17:50.809 --> 00:17:55.139
The CreateWithName version is really good for
watching the remote host that you're interested in.

00:17:55.140 --> 00:17:59.580
Once you have established a connection, you can
get the remote address and the local address

00:17:59.579 --> 00:18:02.379
and use ReachabilityCreateWithAddressPair.

00:18:02.380 --> 00:18:07.070
And that will let you know when the connection
you currently have is no longer viable.

00:18:07.069 --> 00:18:16.429
So for example, if we changed from WiFi back to cellular,
the connection that you had over WiFi is no longer viable.

00:18:16.430 --> 00:18:20.340
Your SCNetworkReachabilityCreateWithAddress Pair
would indicate that the reachability is gone;

00:18:20.339 --> 00:18:25.809
but your SCNetworkReachabilityCreateWithName would
indicate that the reachability is still available.

00:18:25.809 --> 00:18:28.220
It would indicate to you that you need
to tear down your current connection

00:18:28.220 --> 00:18:32.730
and connect again in order to have connectivity.

00:18:32.730 --> 00:18:37.460
Once you have one of these ReachabilityRefs it's
really important to use the asynchronous API.

00:18:38.650 --> 00:18:40.800
The first step is to set a callback function;

00:18:40.799 --> 00:18:48.899
and this callback function will get called anytime
there's a change of environment or reachability.

00:18:48.900 --> 00:18:52.230
The flags may not always change but
there may have been an underlying change.

00:18:52.230 --> 00:18:58.809
For example, if the reachability is still there, but we're
over a different interface like the VPN interface came up,

00:19:00.359 --> 00:19:03.259
you would get a callback but the
flags won't be any different.

00:19:03.259 --> 00:19:09.440
Once you've set your callback you'll need to schedule
the ReachabilityRef with a RunLoop so you can specify

00:19:09.440 --> 00:19:12.910
which run loop the callbacks will occur on.

00:19:12.910 --> 00:19:17.000
And once you've done that you can call ReachabilityGetFlags
and that will tell you what the initial state is.

00:19:17.000 --> 00:19:21.420
A lot of times if you're using this with
SCNetworkReachabilityCreateWith Name,

00:19:21.420 --> 00:19:26.039
the Flags will come back 0 because we
haven't finished doing the host name lookup

00:19:26.039 --> 00:19:29.730
so we don't really know what the reachability
state is yet and that's perfectly fine.

00:19:29.730 --> 00:19:33.549
Just wait for the callback to let
you know when that changes.

00:19:33.549 --> 00:19:39.589
When you do receive one of these notifications
it's really important to evaluate what's going on

00:19:39.589 --> 00:19:43.079
and decide whether you need to reconnect
or stick with your current connection.

00:19:43.079 --> 00:19:50.839
This is a little cheat sheet of the most
interesting flags that you'll get with reachability.

00:19:50.839 --> 00:19:54.539
When reachability notifies you of a change,
it will set a bunch of different flags

00:19:54.539 --> 00:19:58.349
to let you know a little bit about the current state.

00:19:58.349 --> 00:20:03.619
The kSCNetworkReachabilityFlagsReachable
indicates whether or not the working stack thinks

00:20:03.619 --> 00:20:08.509
that we might be able to connect to this remote host.

00:20:08.509 --> 00:20:12.809
It's really important to remember this doesn't mean
that you're absolutely going to be able to connect.

00:20:12.809 --> 00:20:21.450
This doesn't take into account anything about firewalls or
Internet problems between your device and the actual host.

00:20:21.450 --> 00:20:22.980
It's just the local network.

00:20:22.980 --> 00:20:27.640
This indicates we have a route to get to the Internet;
we think we can get to it, we don't know for sure.

00:20:27.640 --> 00:20:31.800
The only way to know for sure is to actually connect.

00:20:31.799 --> 00:20:38.879
kSCNetworkReachabilityFlagsConnectionRequired indicates that
the cellular interface may not be up right now or the VPN

00:20:38.880 --> 00:20:42.690
on demand interface is not up right now,
so we're going to have to do some sort

00:20:42.690 --> 00:20:45.160
of connection before we can get to the host.

00:20:45.160 --> 00:20:48.350
But you should go ahead and try and
connect using one of the CoreFoundation

00:20:48.349 --> 00:20:53.049
or Cocoa APIs to trigger that connection to come up.

00:20:53.049 --> 00:20:59.859
In the case of CoreFoundation, you can use the
CFSteam and the higher level protocol APIs.

00:20:59.859 --> 00:21:02.299
In the case of Cocoa you should
be able to use all of the APIs.

00:21:02.299 --> 00:21:08.730
The CFSocket APIs will not trigger cellular to dial
or VPN on demand so you need to find some other API.

00:21:08.730 --> 00:21:13.319
If you really want to use the CFSocket API,
you can do that but you're going to have

00:21:13.319 --> 00:21:17.139
to open some other connection first using the CFStream API.

00:21:17.140 --> 00:21:24.170
And finally, there's the kSCNetworkReachabilityFlagsIsWWAN
and this will indicate whether

00:21:24.170 --> 00:21:27.400
or not your traffic is going to
go over the cellular network.

00:21:27.400 --> 00:21:39.530
Even if we have a VPN connection, we'll still indicate this
Flag if that VPN connection is over the cellular network.

00:21:39.529 --> 00:21:48.319
There's a UIRequiresPersistentWiFi-- it's a key that
you can set in the Info.plist for your application.

00:21:48.319 --> 00:21:51.429
This has cause a bit of confusion among developers.

00:21:51.430 --> 00:21:54.480
This really means, "I'm a network application."

00:21:54.480 --> 00:21:59.059
And by setting this in your Info.plist it's going to
tell the phone that when your application is running

00:21:59.059 --> 00:22:02.539
and in the foreground, it's OK to do
whatever we can to get you onto the network.

00:22:02.539 --> 00:22:05.720
If you have an application that doesn't
really have anything to do with networking,

00:22:05.720 --> 00:22:09.350
we don't want to be popping up
dialogues or bothering the user.

00:22:09.349 --> 00:22:13.259
So setting this will let us do a
lot more to try and get you online.

00:22:13.259 --> 00:22:16.470
This will disable the WiFi disassociation timer.

00:22:16.470 --> 00:22:20.170
Normally WiFi will disassociate
after I believe about 30 minutes.

00:22:21.220 --> 00:22:27.170
This will also allow us to show various WiFi UI so we can
show the password dialog in the event that we associate

00:22:27.170 --> 00:22:32.769
with a WiFi network where we don't have the password; the
ask to join dialog in the event that the user hasn't turned

00:22:32.769 --> 00:22:43.750
that off yet and they happen to be in range of the
WiFi network; and also the new captive web sheets.

00:22:43.750 --> 00:22:48.170
Bluetooth Device to Device is a really
cool new feature of iPhone OS 3.0.

00:22:48.170 --> 00:22:50.560
It's pretty amazing.

00:22:50.559 --> 00:22:57.069
It will actually work with existing Bonjour applications
on the phone; and it's all done using Bonjour

00:22:57.069 --> 00:23:03.399
over Bluetooth device discovery so the Bluetooth packets
that are used to discover other Bluetooth devices out there,

00:23:03.400 --> 00:23:08.980
we've kind of put a little bit of extra information in
them to indicate that we support this Bonjour discovery.

00:23:08.980 --> 00:23:13.900
And it allows Bluetooth devices to talk to each
other and actually ask the other Bluetooth device,

00:23:13.900 --> 00:23:16.680
"What advertised Bonjour services do you have available?"

00:23:16.680 --> 00:23:19.779
At the point that we're advertising these services,

00:23:19.779 --> 00:23:23.690
we don't even have an interface up,
there's no IP address or anything.

00:23:23.690 --> 00:23:27.039
We don't actually bring up an interface
until you go to resolve the service;

00:23:27.039 --> 00:23:33.609
and that will bring up a Bluetooth PAN connection and we'll
get an IP address and the process takes a lot of time.

00:23:33.609 --> 00:23:36.979
So resolving a service is a very expensive operation.

00:23:36.980 --> 00:23:44.509
Even doing browses for services is fairly expensive
because we have to generate this Bluetooth traffic.

00:23:44.509 --> 00:23:48.759
So all of this is implemented using
Bluetooth device discovery

00:23:48.759 --> 00:23:51.230
and then Bluetooth PAN for the actual communication.

00:23:51.230 --> 00:23:54.180
There are some limitations on these
Bluetooth PAN connections.

00:23:54.180 --> 00:23:56.380
We can only have a few connections.

00:23:56.380 --> 00:24:02.600
There's a maximum of one outgoing PAN connection,
and a maximum of three incoming PAN connections.

00:24:02.599 --> 00:24:07.569
And in order to get rid of these connections so we can
start new connections, we have an idle disconnect set up.

00:24:07.569 --> 00:24:11.200
The idea behind this was that we were trying to
target somebody that might be playing a game,

00:24:11.200 --> 00:24:13.289
and they're either hosting a game or joining a game.

00:24:13.289 --> 00:24:17.990
And if they're hosting a game they can host
and allow up to three incoming connections.

00:24:17.990 --> 00:24:22.940
And if they're joining a game they really
only need a single outgoing PAN connection.

00:24:22.940 --> 00:24:30.450
These connections are bidirectional; it's just a
question of how you actually initiate the connection.

00:24:31.779 --> 00:24:34.470
There are issues with Bluetooth and WiFi coexistence.

00:24:34.470 --> 00:24:41.549
Both Bluetooth and WiFi run at 2.4 gigahertz; there's a
single antenna in that phone, there's not a lot of space

00:24:41.549 --> 00:24:45.349
so when Bluetooth is using the antenna, WiFi can't.

00:24:45.349 --> 00:24:51.319
This means that when you're doing your browsing
or resolving of a service over Bluetooth,

00:24:51.319 --> 00:24:54.279
there's going to be a performance hit to WiFi.

00:24:54.279 --> 00:25:01.160
And the other thing, Bluetooth Device to Device
isn't supported on some of the older devices.

00:25:01.160 --> 00:25:10.970
There's a session tomorrow that we'll go over
some of that and the Game Kit device to device.

00:25:12.319 --> 00:25:14.669
Let's switch gears and cover some performance things.

00:25:14.670 --> 00:25:19.560
We'll go over some of the issues with the Simulator;
we'll go over latency; we'll cover some non-blocking IO

00:25:19.559 --> 00:25:24.399
and some issues with multiple threads and finally CFSocket.

00:25:25.430 --> 00:25:29.000
The Simulator is a great place to
do rapid application development.

00:25:29.000 --> 00:25:33.319
It lets you compile some code, run it, see how it behaves;

00:25:33.319 --> 00:25:37.569
stop it in the debugger; make some
changes; rerun it, very easy.

00:25:37.569 --> 00:25:40.919
You don't have to actually have
an iPhone to do any development.

00:25:40.920 --> 00:25:45.630
But this does nothing to simulate the network
environment you're going to run on the phone.

00:25:45.630 --> 00:25:48.430
You really need to be testing your
applications on the phone itself.

00:25:48.430 --> 00:25:53.789
On the iPhone you have a WiFi connection but
it may not be as fast as your desktop's WiFi.

00:25:53.789 --> 00:25:59.029
You've got the cellular connection, 3G and EDGE,
which is definitely not as fast as your WiFi;

00:25:59.029 --> 00:26:02.769
and you've got VPN connections that
can come and go with VPN on demand.

00:26:02.769 --> 00:26:06.779
If you can get VPN on demand set up, I
highly encourage that because it may--

00:26:06.779 --> 00:26:11.440
it's really good to see if your
application works well in that environment.

00:26:11.440 --> 00:26:16.370
And check to see what happens when
you're roaming between WiFi and cellular.

00:26:16.369 --> 00:26:18.289
You can catch a lot of interesting bugs there.

00:26:18.289 --> 00:26:22.589
And your customers will really appreciate that
you put the polish in to handle that case well.

00:26:22.589 --> 00:26:26.639
The other big differences you run into are the CPU.

00:26:26.640 --> 00:26:29.990
CPU on the desktop of course is a lot faster.

00:26:29.990 --> 00:26:33.650
There's a lot more memory which means we
set a lot more aside for network buffers;

00:26:33.650 --> 00:26:37.190
so you can run into some differences there.

00:26:37.190 --> 00:26:45.690
And finally, the latency and the bandwidth of the
networking on the iPhone is very different from the desktop.

00:26:45.690 --> 00:26:53.250
So latency is something that will kill your performance
if you're not paying attention and you don't work with it.

00:26:53.250 --> 00:26:55.410
The cellular round trip times are very long.

00:26:55.410 --> 00:27:01.540
It's a little bit better than 1/3 of a second on EDGE,
and a little bit better than 1/6 of a second on 3G.

00:27:01.539 --> 00:27:03.339
Latency really will kill your performance.

00:27:03.339 --> 00:27:08.079
If you want to go and open a TCP connection and
send a request to get some sort of data back,

00:27:08.079 --> 00:27:12.269
first you have to do your DNS lookup--
that's 1/3 of a second gone right there.

00:27:12.269 --> 00:27:16.309
You've got you TCP three-way handshake that's going
to be another 1/3 of a second that's just gone;

00:27:16.309 --> 00:27:20.950
and finally you send your request which is going to take
another 1/3 of a second before the response can come back.

00:27:20.950 --> 00:27:25.630
That's a whole second that you've
just blown on a simple connect.

00:27:27.339 --> 00:27:30.079
Latency will kill you.

00:27:30.079 --> 00:27:31.309
HTTP is latency bound.

00:27:31.309 --> 00:27:35.809
Safari over 3G was originally only
about 2 times faster than EDGE.

00:27:35.809 --> 00:27:41.809
They actually spent a lot of time optimizing
this and they did a great job of improving it.

00:27:41.809 --> 00:27:45.169
We'll go over some of the things that they managed to do.

00:27:45.170 --> 00:27:51.980
This is a simple diagram showing how latency can affect
your connection; and we have an example HTTP connection

00:27:51.980 --> 00:27:58.650
on the left hand side without pipelining; and
on the right side we have HTTP with pipelining.

00:27:58.650 --> 00:28:02.790
So without pipelining we do our DNS
request, that's 1/3 of a second,

00:28:02.789 --> 00:28:05.389
and we've got our TCP connect with another 1/3 of a second.

00:28:05.390 --> 00:28:10.340
We do an HTTP GET for the route document; that's
another 1/3 of a second; we price that document

00:28:10.339 --> 00:28:15.459
and we see what resources we need to do, and then we
do a fetch for another document for another resource,

00:28:15.460 --> 00:28:20.500
we do a GET for x, and when that
comes back we do a GET for y.

00:28:20.500 --> 00:28:25.400
We've blown quite a bit of time here and these
gaps between the GETs are wasted bandwidth.

00:28:25.400 --> 00:28:27.720
We could have been using the pipe but we left it empty.

00:28:27.720 --> 00:28:34.100
It's kind of like bubbles in the processor; you're looking
at getting the best performance out of a processor.

00:28:35.890 --> 00:28:40.060
On the right hand side we have HTTP with pipelining
and from the beginning it's pretty much the same.

00:28:40.059 --> 00:28:43.869
We still have to pay the cost of doing the DNS; we
still have to pay the cost of doing a TCP connect

00:28:43.869 --> 00:28:49.929
and we still have to pay the cost of the HTTP GET for the
route document, but now when we do a GET we can specify more

00:28:49.930 --> 00:28:52.610
than one resource; so in this case we say GET x and y.

00:28:52.609 --> 00:28:57.779
And as you can see there's no gap between x and y
coming back so we've got a performance win there.

00:28:57.779 --> 00:29:04.250
For 2, this isn't really a huge win but when you're
talking 10 or 20 resources it really adds up.

00:29:04.250 --> 00:29:10.700
And to demonstrate that we have a kind of
gross chart but if you focus on the timeline

00:29:10.700 --> 00:29:14.140
at the bottom, this is an HTTP GET with the NY Times.

00:29:14.140 --> 00:29:17.590
It took about 20 seconds to pe rform this GET.

00:29:17.589 --> 00:29:19.289
This is using Safari.

00:29:19.289 --> 00:29:28.569
If we do the same GET using pipelining it drops down to
a little over 6 seconds; and another interesting thing

00:29:28.569 --> 00:29:35.309
about this is that we don't actually get
the send back for the first 2 seconds.

00:29:35.309 --> 00:29:41.269
And the cellular interface was actually
asleep when I ran this to capture the packets.

00:29:41.269 --> 00:29:46.190
So it takes the cellular interface sometimes up
to 2 seconds to come out of the low power mode.

00:29:48.130 --> 00:29:50.080
So pipelining is a huge win here.

00:29:50.079 --> 00:29:55.179
We went from 20 seconds to less than 5 seconds.

00:29:55.180 --> 00:29:57.360
This is looking at the TCP connection.

00:29:57.359 --> 00:30:00.589
Each of these little blips is a packet as it comes in.

00:30:00.589 --> 00:30:03.259
This is the HTTP Receive without pipelining.

00:30:03.259 --> 00:30:07.879
You can see in the first 5 seconds we
managed to send about 40 kilobytes.

00:30:07.880 --> 00:30:12.540
And if we zoom in we really don't see
all that much out of this connection.

00:30:12.539 --> 00:30:13.269
It's pretty slow.

00:30:13.269 --> 00:30:19.549
When we use pipelining, we have a
significantly faster connection.

00:30:19.549 --> 00:30:27.710
In the 5 to 6 seconds that we had initially, we were
able to get all 128 kilobits, so pipelining is huge.

00:30:27.710 --> 00:30:29.519
If you can take advantage of it you really should.

00:30:29.519 --> 00:30:35.950
If you're designing a new protocol you need to take
into account the affects that latency is going to have.

00:30:35.950 --> 00:30:40.279
If you're designing a protocol, allow
multiple requests to be outstanding.

00:30:40.279 --> 00:30:46.180
It's really bad to have request A then wait until you get
A back, then request B and then wait until it comes back.

00:30:46.180 --> 00:30:50.920
It's much better to have a protocol where you can
request A, then request B, then request C and request D

00:30:50.920 --> 00:30:55.370
because the server can start sending
all that data back to back.

00:30:55.369 --> 00:30:58.649
HTTP pipelining unfortunately is a little bit busted.

00:30:58.650 --> 00:31:03.460
Safari doesn't actually take advantage of it because
there are proxies out there that will break it,

00:31:03.460 --> 00:31:07.730
and there are some Apache plug-ins
that can also cause problems with this.

00:31:07.730 --> 00:31:11.890
If you're running your own server, you can make
sure that you don't have the plug-ins that are going

00:31:11.890 --> 00:31:15.320
to cause the problems, and you can be
aware of when there are proxies being used.

00:31:15.319 --> 00:31:20.049
Although there are some proxies you can't detect but
for the most part you should be able to detect them.

00:31:20.049 --> 00:31:26.750
If you can take advantage of HTTP
pipelining you're going to get a huge win.

00:31:26.750 --> 00:31:29.960
Sometimes you work around latency
problems by opening multiple connections

00:31:29.960 --> 00:31:32.620
and that's actually the approach that Safari takes.

00:31:32.619 --> 00:31:37.259
Multiple connections aren't ideal
because you have this problem with TCP.

00:31:37.259 --> 00:31:41.269
TCP really works well when you can
cram as much data as possible into it.

00:31:41.269 --> 00:31:46.829
It lets the congestion window open up quickly and it
keeps data streaming at the maximum speed it possible can.

00:31:46.829 --> 00:31:50.619
If you have a bunch of little connections and on each
connection you get a little bit of data every here

00:31:50.619 --> 00:31:55.659
and there, the congestion window never really
opens up, TCP never really performs as well

00:31:55.660 --> 00:31:58.920
as it can so you end up losing bandwidth.

00:31:58.920 --> 00:32:02.900
The other thing is with multiple
connections it's really hard to tune.

00:32:02.900 --> 00:32:07.830
You have to figure out exactly how many connections you
want to make and then figure out where the ideal place is.

00:32:07.829 --> 00:32:11.250
It's not good.

00:32:11.250 --> 00:32:16.839
The other thing to note is investigate why
you are getting the performance that you are.

00:32:16.839 --> 00:32:21.919
In the case of Safari with the original iPhone, it was good.

00:32:21.920 --> 00:32:26.090
When iPhone 3G came out we saw that it was
only 2 times faster and we're like, "Well,

00:32:26.089 --> 00:32:29.869
3G should be significantly more
than 2 times faster than EDGE."

00:32:29.869 --> 00:32:33.719
And we spent some time investigating and realized
that we were running into this latency problem;

00:32:33.720 --> 00:32:38.000
and the Safari guys did a lot of great work and
managed to improve that performance quite a bit;

00:32:38.000 --> 00:32:42.220
although they weren't able to get the pipelining
in because of the concerns for compatibility.

00:32:42.220 --> 00:32:51.890
Another thing to keep in mind, don't ever use
blocking IO, especially on your main thread.

00:32:51.890 --> 00:32:57.009
If you block the main thread doing a DNS request for
example, that can take up to 30 seconds to time out,

00:32:57.009 --> 00:33:04.150
and there's a watchdog timer to make sure your application
is responding, and that will wait for about 20 seconds.

00:33:04.150 --> 00:33:08.900
So if you do the math you're not going to make it.

00:33:08.900 --> 00:33:15.170
The socket read/write and connect calls that
block can also take a very long period of time;

00:33:15.170 --> 00:33:18.700
so don't do any blocking IO on your main thread.

00:33:18.700 --> 00:33:25.559
If you need to do blocking IO, spin it off to another
thread, or even better, just use non-blocking IO.

00:33:25.559 --> 00:33:29.839
The other thing to keep in mind is it's really
good to avoid these modal connecting dialogs.

00:33:29.839 --> 00:33:33.470
If somebody's network connection is not working,
they're going to be a little bit frustrated;

00:33:33.470 --> 00:33:38.190
and if your application has this dialog up that says
oh I'm connecting, well yes, the network's down,

00:33:38.190 --> 00:33:40.789
I'm really frustrated, I can't
interact with your application.

00:33:40.789 --> 00:33:45.579
Don't put up a modal connecting dialog; let people
interact with your application but do put some indication

00:33:45.579 --> 00:33:48.000
that it's trying to perform a connection.

00:33:48.000 --> 00:33:50.400
Safari is actually a great example of this.

00:33:50.400 --> 00:33:55.780
When you go into Safari and you put something in the URL
bar and start loading, Safari still remains responsive.

00:33:55.779 --> 00:34:00.899
You can go into the bookmarks, you can bring up one of
the other tabs or windows, you can go into the Google bar

00:34:00.900 --> 00:34:06.600
and put something in to change it; you can cancel; it
remains very responsive no matter what the network is doing.

00:34:06.599 --> 00:34:11.469
If you can model your application
after that, people will appreciate it.

00:34:11.469 --> 00:34:19.629
And this can be a little more contentious
subject but when you're working with threads,

00:34:19.630 --> 00:34:26.240
threads can make it a little bit
easier to work around synchronous APIs.

00:34:26.239 --> 00:34:28.989
Threads can be very resource intensive though.

00:34:28.989 --> 00:34:34.719
When you create a thread, it's creating some place to store
a bunch of state and it does this by allocating a stack;

00:34:34.719 --> 00:34:39.599
and the stack is going to be pretty big because
the OS doesn't know how much state you're going

00:34:39.599 --> 00:34:41.099
to be using in that thread.

00:34:41.099 --> 00:34:44.960
So it conservatively sets aside a lot of memory.

00:34:44.960 --> 00:34:48.889
There's also overhead when you're trying
to synchronize between different threads;

00:34:48.889 --> 00:34:56.139
and while this can be a little bit easier to write, the
threaded model is really better for CPU bound workloads,

00:34:56.139 --> 00:35:02.789
so if you're stuck cramming numbers on the CPU, then threads
are fantastic because it lets the operating system offload

00:35:02.789 --> 00:35:06.889
that work on the multiple cores at the same time.

00:35:06.889 --> 00:35:10.869
When it comes to stuff that's I/O bound
it's a lot easier or a lot more efficient

00:35:10.869 --> 00:35:13.349
to use something like an asynchronous state machine.

00:35:13.349 --> 00:35:16.529
You can allocate the minimal amount of resources possible

00:35:16.530 --> 00:35:19.019
because you already know how much
state you're going to need.

00:35:19.019 --> 00:35:20.460
This will give you better scalability.

00:35:20.460 --> 00:35:23.720
If you wanted to write an asynchronous
DNS server that was going to handle--

00:35:23.719 --> 00:35:29.379
or a DNS resolver that was going to
handle, say, 1,000 simultaneous requests,

00:35:29.380 --> 00:35:32.410
you can't just go and spin off 1,000 threads.

00:35:32.409 --> 00:35:33.949
That would not work.

00:35:33.949 --> 00:35:40.939
But if you're allocating just a tiny amount of space, a
little bit of state for each request that you're doing,

00:35:40.940 --> 00:35:46.970
you can easily allocate 1,000 of those and you can
have all of these operations going on at the same time.

00:35:46.969 --> 00:35:49.529
It is a little bit more complicated to
write because you have to keep track

00:35:49.530 --> 00:35:54.640
of the state yourself, but it does scale better.

00:35:54.639 --> 00:35:59.159
One other thing to keep in mind the iPhone
and the iPod Touch only have a single core;

00:35:59.159 --> 00:36:03.710
so putting something on multiple threads doesn't really
mean that you're going to get a big performance win.

00:36:03.710 --> 00:36:05.849
There's not another core to go offload this work onto.

00:36:05.849 --> 00:36:12.509
You're just going to give the scheduler a lot more to do.

00:36:12.510 --> 00:36:15.590
CFSocket is a wonderful API.

00:36:15.590 --> 00:36:21.440
It does this very complicated thing of
letting you work with sockets on a Run loop.

00:36:21.440 --> 00:36:26.490
Run loops are all based on mach ports and
sockets of course are file descriptor based.

00:36:26.489 --> 00:36:30.549
And there's no primitive on the operating
system that lets you wait for an event

00:36:30.550 --> 00:36:34.710
on both a mach port and a file descriptor.

00:36:34.710 --> 00:36:39.230
So CFSocket goes and spins up another thread
for you and in that thread it will wait

00:36:39.230 --> 00:36:41.679
for all the file descriptors that you're interested in.

00:36:41.679 --> 00:36:47.869
And when it gets notification that an event has occurred
on one of those sockets, it will actually use a mach port

00:36:47.869 --> 00:36:54.289
to signal the run loop thread to let the run loop
thread know hey there's data available on this socket.

00:36:54.289 --> 00:37:00.610
It's really solid, it's been hammered
on for years, it's a great API to use.

00:37:00.610 --> 00:37:01.840
There is a catch though.

00:37:01.840 --> 00:37:07.700
When you're using this API you need to keep in mind
that there is some overhead for that back and forth;

00:37:07.699 --> 00:37:13.449
so when you get one of these callbacks that
lets you know hey there's some data available,

00:37:13.449 --> 00:37:18.480
make sure that you use a non-blocking socket and make
sure that you read everything you can out of the socket.

00:37:18.480 --> 00:37:24.800
If you read 10 bytes and there's 1,000 bytes on a
socket, then as soon as you return from your callback,

00:37:24.800 --> 00:37:29.450
the callback's going to signal the CFSocket thread
and say hey you can go ahead and put this back

00:37:29.449 --> 00:37:32.689
on the file descriptor list; I'm interested
in knowing when there's an event ready.

00:37:32.690 --> 00:37:39.659
The file descriptor thread will signal immediately
because there's already data waiting on that socket,

00:37:39.659 --> 00:37:43.039
and then it's going to send a mach port message
back and it's going to call your callback.

00:37:43.039 --> 00:37:46.840
So you're right back where you were but you've just
blown a whole bunch of cycles and a bunch of power.

00:37:46.840 --> 00:37:52.440
So try and read everything you can
until you get the EWOULDBLOCK error.

00:37:52.440 --> 00:37:54.300
This isn't applicable to CFStream.

00:37:54.300 --> 00:37:58.970
CFStream does some things under the covers
to be a little bit more intelligent.

00:37:58.969 --> 00:38:06.099
On SnowLeopard with lid dispatch and Grand Central
dispatch, GCD, this is actually a lot better for CFSocket.

00:38:06.099 --> 00:38:08.199
CFSocket doesn't use this extra thread anymore.

00:38:08.199 --> 00:38:11.159
It's all implemented using lid dispatch.

00:38:11.159 --> 00:38:16.809
Some day in the future the iPhone OS is going to make
that migration and CFSocket will get that same win.

00:38:16.809 --> 00:38:22.299
So if you write your code for CFSocket today, you're going
to get that performance win automatically in the future.

00:38:22.300 --> 00:38:28.150
So I'd really encourage you to use CFSocket.

00:38:28.150 --> 00:38:30.530
Finally we have some miscellaneous tips.

00:38:30.530 --> 00:38:32.260
Don't assume a performance advantage.

00:38:32.260 --> 00:38:36.690
WiFi is not always faster than 3G and
3G is not always faster than EDGE.

00:38:36.690 --> 00:38:42.210
You may have noticed in some of the conferences
that 3G can sometimes perform slower than EDGE has

00:38:42.210 --> 00:38:45.809
when you don't have thousands of
developers with the same phone.

00:38:47.320 --> 00:38:51.150
And then WiFi networks of course you never
know what's on the other side of the WiFi.

00:38:51.150 --> 00:38:56.460
You've got Apple shuttles that have WiFi on them
which are fantastic except there are 30 or 40 people

00:38:56.460 --> 00:39:00.820
that are using the same WiFi connection, and on the other
side of that WiFi connection is a cellular connection.

00:39:00.820 --> 00:39:05.440
So sometimes it's faster to just pull out your
phone and get onto the cellular network yourself.

00:39:06.519 --> 00:39:14.269
Please remember that WiFi will power off unless you
set that UIRequiresPersistentWiFi, the 30 minute timer.

00:39:14.269 --> 00:39:18.739
Will also power off WiFi as soon as you lock the screen.

00:39:18.739 --> 00:39:24.419
Remember that in order to trigger
cellular to Dial or the VPN on demand,

00:39:24.420 --> 00:39:27.740
you need to using one of the Core
Foundation APIs; not CFSocket,

00:39:27.739 --> 00:39:33.609
but CFStream or a higher level
API; or one of the Cocoa APIs.

00:39:33.610 --> 00:39:38.750
And one other thing, if we could get you to
connect your UDP sockets we'd really appreciate it.

00:39:38.750 --> 00:39:43.690
With a UDP socket you can open it up and you can
use send to and specify the destination address.

00:39:43.690 --> 00:39:47.840
If you, on the other hand, connect the socket,
then we know what the destination address is.

00:39:47.840 --> 00:39:50.690
And when we're dealing with these Bluetooth PAN connections,

00:39:50.690 --> 00:39:55.530
we can know that that socket wants
to use that Bluetooth PAN interface.

00:39:55.530 --> 00:40:01.830
And in the future when we have all these connected
sockets, when you go and remove your socket,

00:40:01.829 --> 00:40:04.929
we can keep sort of a reference count on
how many sockets you use in that interface.

00:40:04.929 --> 00:40:10.039
And when it reaches 0 we can disconnect the PAN
Bluetooth device to device connection really fast.

00:40:10.039 --> 00:40:13.019
We won't have to wait on some idle time out.

00:40:13.019 --> 00:40:16.880
So we'll get better performance and we'll save power.

00:40:16.880 --> 00:40:19.970
So in summary, please use reachability.

00:40:19.969 --> 00:40:21.319
Reachability is really important.

00:40:21.320 --> 00:40:23.350
Your users will really appreciate it if you get it right.

00:40:23.349 --> 00:40:26.940
It is really hard to get it right but it's worth it.

00:40:26.940 --> 00:40:29.929
Always use non-blocking IO.

00:40:29.929 --> 00:40:34.799
You don't want to block your main thread and get
killed by the watchdog; it's kind of embarrassing.

00:40:34.800 --> 00:40:35.910
Be aware of latency.

00:40:35.909 --> 00:40:42.859
Latency has a huge performance impact; probably the biggest
performance impact you'll run into on the cellular network.

00:40:42.860 --> 00:40:44.349
Don't expect it to be slow.

00:40:44.349 --> 00:40:45.860
Cellular networks are not slow.

00:40:45.860 --> 00:40:49.829
They have high latency but they're actually pretty fast.

00:40:49.829 --> 00:40:52.360
Please test on the iPhone itself.

00:40:52.360 --> 00:40:54.650
The iPhone is an environment unlike the desktop.

00:40:54.650 --> 00:40:57.190
The simulator is great for simulating
what the UI is going to be like.

00:40:57.190 --> 00:40:59.929
It's not great for simulating what
the network is going to be like;

00:40:59.929 --> 00:41:04.489
and see what happens when you unplug your WiFi
router and the phone falls back to cellular.

00:41:04.489 --> 00:41:06.719
It is your application, handle it properly.

00:41:06.719 --> 00:41:09.819
See what happens when you've got VPN on demand.

00:41:09.820 --> 00:41:16.030
Assume that your network environment's going to be dynamic;
even if you don't get a reachability change notification,

00:41:16.030 --> 00:41:19.230
your bandwidth can change as the congestion changes.

00:41:19.230 --> 00:41:23.010
If you're sitting in here, you're the first
one in here, nobody else has been let in yet,

00:41:23.010 --> 00:41:27.160
you've probably got fairly good WiFi or cellular or
whatever, and as everybody comes in there's going

00:41:27.159 --> 00:41:30.059
to be more congestion and your connection
is going to slow down as a result.

00:41:30.059 --> 00:41:31.789
That's just inevitable.

00:41:31.789 --> 00:41:36.449
Your application needs to be able to handle this and
deal with the fact that your connection is slowing down.

00:41:36.449 --> 00:41:45.480
Please connect those UDP sockets so we can do something
smarter in the future with those Bluetooth PAN connections,

00:41:45.480 --> 00:41:50.990
and be sure and read all of your data out of CFSockets
when you get your callback so we can avoid spinning.
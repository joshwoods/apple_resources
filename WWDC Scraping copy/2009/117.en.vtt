WEBVTT

00:00:12.839 --> 00:00:18.609
>> Welcome to User Events in Cocoa, my name is
Raleigh Ledet I'm a Cocoa Software Engineer.

00:00:21.589 --> 00:00:26.480
We've got a lot to talk about today and it's
going to run the gamut of some beginner stuff

00:00:26.480 --> 00:00:28.449
and some intermediate stuff and some more advanced stuff.

00:00:28.449 --> 00:00:32.380
We're going to talk about Event Routing in a
Cocoa application which means we're also going

00:00:32.380 --> 00:00:35.940
to spend a fair amount of time
talking about the Responder Chain.

00:00:35.939 --> 00:00:39.079
And we're going to talk about the
new Gesture API that we have along

00:00:39.079 --> 00:00:42.039
with the new Multi-Touch API that
we're introducing in Snow Leopard.

00:00:42.039 --> 00:00:48.210
And we're going to finish this up by talking about how
you can get into the Event Queue and watch what's going

00:00:48.210 --> 00:00:52.359
on with monitoring for events that are coming to
your application and events that aren't even coming

00:00:52.359 --> 00:00:55.079
to your application that are actually
going to other applications.

00:00:55.079 --> 00:01:02.320
Everything I'm going to be talking about here
today is specific to the Desktop Mac OS X.

00:01:02.320 --> 00:01:08.400
If you're more interested in Multi-Touch Events on
iPhone please check out the Processing Multi-Touch Events

00:01:08.400 --> 00:01:14.270
on iPhone session on Thursday at Pacific Heights at 9 AM.

00:01:14.269 --> 00:01:16.929
You'll see during the talk this badge on occasion.

00:01:16.930 --> 00:01:23.080
At various points in the talk we're going to talk
about areas where you can get into the Event Routing

00:01:23.079 --> 00:01:29.480
and change how things flow in Cocoa and you can modify
where events go, so this is a badge to let you know

00:01:29.480 --> 00:01:33.280
about some more advanced topics that you
might want to really pay attention to.

00:01:33.280 --> 00:01:37.810
So let's get started; Event Routing.

00:01:37.810 --> 00:01:46.290
When an event comes into your Cocoa application,
let's say a Swipe Event, it comes into NSApplication

00:01:46.290 --> 00:01:51.420
and NSApplication looks at the event and tries to
figure out which window should this event go to.

00:01:51.420 --> 00:01:56.390
That event will get sent to the NSWindow class and
that class looks at the event and figures out, oh,

00:01:56.390 --> 00:02:01.469
this is a Swipe Event so which view should
I send this event to and it figures that out

00:02:01.469 --> 00:02:04.870
and it calls the swipeWithEvent method on that view.

00:02:04.870 --> 00:02:09.259
Let's take a look a little bit at this.

00:02:09.259 --> 00:02:14.679
NSView inherits from NSResponder and it's
NSResponder that actually has the definition

00:02:14.680 --> 00:02:17.830
for swipeWithEvent and the default implementation.

00:02:17.830 --> 00:02:25.760
NSView inherits from NSResponder and NSControl inherits
from NSView which, of course, inherits from NSResponder.

00:02:25.759 --> 00:02:30.909
So your classes generally are NSView
subclasses or NSControl subclasses

00:02:30.909 --> 00:02:35.930
and you will automatically inherit
all the defined implementations --

00:02:35.930 --> 00:02:41.520
the default implementations of
NSResponder's various event methods.

00:02:41.520 --> 00:02:45.170
Here's an example of some of the event
methods that we have on NSResponder.

00:02:45.169 --> 00:02:50.879
For Pointer Events, Touchpad Events, Keyboard Events,
you know, mouseDown, mouseDragged and for our example

00:02:50.879 --> 00:02:54.689
that we're following right now swipeWithEvent.

00:02:54.689 --> 00:03:02.020
You'll notice here that the pattern we follow
is it's the Event Type and, for instance,

00:03:02.020 --> 00:03:05.330
the method name along with an event
so we pass in the event for you

00:03:05.330 --> 00:03:08.620
so you can get further information in your method override.

00:03:08.620 --> 00:03:15.129
Another thing that NSResponder
does for you, which is really nice,

00:03:15.129 --> 00:03:21.729
is that it hangs on to something we called an nextResponder
which is just another NSResponder class of subclass,

00:03:21.729 --> 00:03:25.229
and this allows us to quite literally chain these together

00:03:25.229 --> 00:03:30.349
and we would call this by the obvious
name the Responder Chain.

00:03:30.349 --> 00:03:37.659
So what happens once we have this all set up in a Responder
Chain is your swipeWithEvent comes in and NSWindow is going

00:03:37.659 --> 00:03:42.669
to figure out which view to send this to first
and your view is a subclass of NSResponder

00:03:42.669 --> 00:03:46.799
and if you don't override swipeWithEvent or
if you do and you call super swipeWithEvent

00:03:46.800 --> 00:03:50.740
to let the default implementation handle
it the default implementation is just going

00:03:50.740 --> 00:03:52.390
to pass this to the next responder for you.

00:03:52.389 --> 00:03:57.529
And this continues up the Responder
Chain until there's no responders left

00:03:57.530 --> 00:04:02.189
and the swipe just falls off the stack;
this is what happens for most events.

00:04:02.189 --> 00:04:04.900
keyDown is one of the special events
where we do something slightly different.

00:04:04.900 --> 00:04:11.390
When we get to the end if there's nobody else to
respond to the keyDown we'll issue a System Beep.

00:04:11.389 --> 00:04:17.159
So if we put some subclasses on our Responder
Chain it might look something like this.

00:04:17.160 --> 00:04:20.300
You got a button and a text field sitting
on top of a view inside of a window

00:04:20.300 --> 00:04:24.680
and that looks a lot like the View Hierarchy.

00:04:24.680 --> 00:04:29.730
Well that's not quite right as it turns
out because a window isn't a view.

00:04:29.730 --> 00:04:34.920
A window contains a content view and in
our example the content view is going

00:04:34.920 --> 00:04:37.530
to contain our view with our button in our text field.

00:04:37.529 --> 00:04:42.469
Now the window here is a different color because
while it doesn't inherit from NSView it does inherit

00:04:42.470 --> 00:04:50.690
from NSResponder, so when our Swipe Event comes
in if none of the views in the Responder Chain

00:04:50.689 --> 00:04:55.160
down to the Content View handle it it'll
get forwarded automatically to NSWindow.

00:04:55.160 --> 00:05:00.560
If you have an NSWindow subclass you can override
swipeWithEvent there and you can handle it.

00:05:00.560 --> 00:05:07.069
NSWindow's default implementation just lets NSResponder's
default implementation do the work and that will forward it

00:05:07.069 --> 00:05:12.790
to the next responder which is the NSWindow Controller, and
the NSWindow Controller is the last responder in this chain.

00:05:12.790 --> 00:05:16.900
If you have a Window Controller attached
and if you have your own subclass you can --

00:05:16.899 --> 00:05:19.810
this is the last point you can
decide to override swipeWithEvent

00:05:19.810 --> 00:05:23.879
and handle it yourself if none of the other views have.

00:05:25.829 --> 00:05:29.120
The great thing about Cocoa is this is all automatic.

00:05:29.120 --> 00:05:33.939
You go into Interface Builder and you set up your
View Hierarchy Layout, you add your Window Controller,

00:05:33.939 --> 00:05:39.129
assign it to the window and the Responder
Chain is set up for you automatically;

00:05:39.129 --> 00:05:42.370
this even works if you add views programmatically.

00:05:42.370 --> 00:05:46.660
So you just add subview to a view and the Responder
Chain is going to be set up for you automatically,

00:05:46.660 --> 00:05:50.320
so there's nothing you have to
do to set it up it just works.

00:05:50.319 --> 00:05:54.810
So that's the basics of the Responder Chain.

00:05:54.810 --> 00:05:59.819
It's the key thing that's used in
Event Routing in a Cocoa application.

00:05:59.819 --> 00:06:05.199
It's also used for a number of other places in
Cocoa applications, for example, Action Routing.

00:06:05.199 --> 00:06:12.610
When you go in Interface Builder and you drag an
action normally from like a menu to FirstResponder

00:06:12.610 --> 00:06:20.280
that action does Action Routing to figure out the
correct object in your View Hierarchy to send it to.

00:06:20.279 --> 00:06:27.069
And actually with Action Routing it's a little bit different
in how they look at the Responder Chain because they'll pull

00:06:27.069 --> 00:06:31.069
in things like the document class if
you're document based and they'll also look

00:06:31.069 --> 00:06:33.579
at your window delegate and your document delegate.

00:06:33.579 --> 00:06:37.449
And so the same thing goes with Automatic
Menu Enabling and Error Presentation.

00:06:37.449 --> 00:06:42.870
They all use the Responder Chain slightly different
but they're heavily relying on the Responder Chain.

00:06:42.870 --> 00:06:47.639
We're not going to have time to go into the other uses of
the Responder Chain we're going to focus on events today.

00:06:47.639 --> 00:06:53.569
If you want more information you can just do
some Web searches here, these phrases will get --

00:06:53.569 --> 00:07:00.439
the top link will get you to Apple's Documentation and I'll
also provide links at the end of the presentation directly

00:07:00.439 --> 00:07:04.009
to the documentation if you want the full path links.

00:07:04.009 --> 00:07:09.009
[ Background noise ]

00:07:09.009 --> 00:07:14.569
>> Raleigh: We're going to talk about 2 types of
Event Types, Keyboard Events and Pointer Events

00:07:14.569 --> 00:07:19.209
and we're going to start off with Keyboard Events.

00:07:20.569 --> 00:07:28.319
Keyboard Events are probably one of the most
complex event types that Cocoa application routes.

00:07:28.319 --> 00:07:32.849
There's a lot that goes on here before
the event even hits the Responder Chain.

00:07:32.850 --> 00:07:40.840
The first thing that happens when a Keyboard Event
comes in is Cocoa's going to send it to the right window

00:07:40.839 --> 00:07:43.229
and the NSWindow class is going to look at it.

00:07:43.230 --> 00:07:45.580
Before that even we ask if it's a Key Equivalent.

00:07:45.579 --> 00:07:51.609
If it's a Key Equivalent we're going to
perform the right Key Equivalent method for you

00:07:51.610 --> 00:07:57.840
so with the Hit Command-A we're going to call Select
All or send that down the Action Routing System.

00:07:57.839 --> 00:08:02.109
If they do a Command-N to open a new
document these are your Key Equivalents.

00:08:02.110 --> 00:08:07.470
If it's not a Key Equivalent we ask
Is this a Key Interface Control?

00:08:07.470 --> 00:08:12.090
A Key Interface Control is something like Control-F5 which
will actually move your keyboard focus up to the toolbar

00:08:12.089 --> 00:08:17.560
for you, or Control-F2 which will actually move
your keyboard focus all the way up to the menu.

00:08:17.560 --> 00:08:20.009
So if it's one of these Key Interface Controls we're going

00:08:20.009 --> 00:08:22.240
to modify the key focus and it's
going to be handled for you.

00:08:22.240 --> 00:08:27.400
And just to point out Tab isn't one of the special Key
Interface Controls that will actually go down further.

00:08:27.399 --> 00:08:36.590
If it's not a Key Interface Control we then finally
figure out which view to send it to in the Responder Chain

00:08:36.590 --> 00:08:42.040
to start the Event Routing through the
Responder Chain, and this is the FirstResponder.

00:08:42.039 --> 00:08:50.899
The FirstResponder is the designated responder in
the Responder Chain when there's no other context

00:08:50.899 --> 00:08:57.569
in the event we send it to this
designated responder as the FirstResponder.

00:08:57.570 --> 00:09:02.010
The FirstResponder generally has the
blue circle around it, so, for example,

00:09:02.009 --> 00:09:08.350
we have up here the buttons highlighted there for Add Rule.

00:09:08.350 --> 00:09:11.870
On the other side we have the List
View's got the blue circle around it.

00:09:11.870 --> 00:09:15.639
On the bottom we have the blue circle
around an item in the toolbar it's the one

00:09:15.639 --> 00:09:19.159
that has key focus and is the FirstResponder in this case.

00:09:19.159 --> 00:09:21.909
And on the other one we have a Text Code,
you see it has the blue ring around it.

00:09:21.909 --> 00:09:26.659
So normally the key focus for the user they can easily
specify this by looking at what area has the blue focus

00:09:26.659 --> 00:09:28.799
around it, that's going to be the FirstResponder.

00:09:28.799 --> 00:09:32.799
You don't always -- not every control that's
FirstResponder has the blue focus around it, for example,

00:09:32.799 --> 00:09:37.379
in Text Edit when you're typing away in the Content Area
we don't put a blue focus around the whole Content Area.

00:09:37.379 --> 00:09:42.240
It's kind of obvious where the
FirstResponder is in that case.

00:09:42.240 --> 00:09:47.549
So your view is the FirstResponder and keyDown
gets called in your view and you override keyDown

00:09:47.549 --> 00:09:51.089
and you can now do your custom
implementation for the keyDown method

00:09:51.090 --> 00:09:56.660
but what we suggest you do is simply call
interpretKeyEvents and pass in an array

00:09:56.659 --> 00:10:00.299
with the event, and this will go to Key Bindings.

00:10:00.299 --> 00:10:04.979
And the reason you want to let it go through
Key Bindings and let Cocoa interpret the event

00:10:04.980 --> 00:10:10.789
for you is we will call back a whole bunch of
other methods depending on what the key is.

00:10:10.789 --> 00:10:14.639
For example, if they use a Press Command-Right
Arrow we want to move to the beginning of the line,

00:10:14.639 --> 00:10:19.840
Command-Left Arrow to the end of the line, move up or move
down in the document, all these different ways of moving.

00:10:19.840 --> 00:10:27.290
We'll even recognize eMac commands so if you press
Command-Control-F we'll move forward for you.

00:10:27.289 --> 00:10:35.370
So let Key Bindings do the hard work of looking at the
Keyboard Event, figuring out what the user intended to do

00:10:35.370 --> 00:10:44.179
and you'll get consistent look and feel and user
interaction across applications on the system.

00:10:44.179 --> 00:10:51.029
If it's one of these Key Binding events we will send
the appropriate action message and the event is handled.

00:10:51.029 --> 00:10:56.009
If it's not a Key Binding event Key
Binding will then call back onto your view,

00:10:56.009 --> 00:11:00.450
insert text and give you back the string so you
don't have to worry about the virtual key codes,

00:11:00.450 --> 00:11:05.470
you don't have to deal with any of that, you don't have
to deal with the Unicode stuff you have an NSString

00:11:05.470 --> 00:11:09.790
so you can easily enter NSString
wherever you need to do that.

00:11:09.789 --> 00:11:16.889
So this also goes through the various input methods and
this deals with all the proper things it's doing, perhaps,

00:11:16.889 --> 00:11:22.799
a Chinese character keyboard or various things
where there are multiple key codes coming in.

00:11:22.799 --> 00:11:25.959
Let Cocoa do the hard work for
you, let Cocoa do the heavy lifting

00:11:25.960 --> 00:11:31.740
and let Key Bindings do the work for
you with Interpret Keyboard Events.

00:11:31.740 --> 00:11:39.450
Like I said, Keyboard Events' one of the
more complicated ones there was a lot there

00:11:39.450 --> 00:11:43.100
so let's just do a quick brief
example to go over it real quick.

00:11:43.100 --> 00:11:46.250
Let's say the user presses A on your keyboard.

00:11:46.250 --> 00:11:53.350
First thing that happens is Cocoa asks is this a
Key Equivalent and it's not it's just the letter A

00:11:53.350 --> 00:11:59.930
so then we ask is this a Key Interface Control and no it's
not so we figure out who's the FirstResponder in the window

00:11:59.929 --> 00:12:04.709
and we call keyDown and this continues to go up
the Responder Chain but the FirstResponder happens

00:12:04.710 --> 00:12:07.470
to be your view and you do the appropriate thing

00:12:07.470 --> 00:12:11.639
and you just call interpretKeyEvents
so you let Key Bindings take over.

00:12:11.639 --> 00:12:20.080
Key Bindings looks at the key and it says Is this one of
our Key Binding actions, no it's not it's just the letter A.

00:12:20.080 --> 00:12:23.240
So we finally call back on [inaudible] view, Insert Text.

00:12:23.240 --> 00:12:26.320
You get back a string and all you
have to do is the appropriate thing

00:12:26.320 --> 00:12:29.230
and the letter A is put into your Text Field.

00:12:29.230 --> 00:12:34.659
So there's a lot that goes on for something that seems
really simple but this handles all your Key Equivalents,

00:12:34.659 --> 00:12:39.009
your Key Interface Control and all these Key Binding
actions, so let Cocoa do the heavy lifting for you.

00:12:39.009 --> 00:12:47.580
[ Background noise ]

00:12:47.580 --> 00:12:50.580
>> Raleigh: So, Pointer Events.

00:12:50.580 --> 00:12:57.550
Pointer Events are all these events associated with the
cursor and we use the cursor as the context to decide

00:12:57.549 --> 00:13:00.779
where in the View Hierarchy that
we're going to send the event

00:13:00.779 --> 00:13:03.709
to in the Responder Chain to start
it off in the Responder Chain.

00:13:03.710 --> 00:13:09.009
So this will take care of your mouseDowns and your
mouseDraggeds and this actually includes the new Gestures

00:13:09.009 --> 00:13:15.879
and the new Multi-Touch Events, so these are
all dependent upon where the cursor location is.

00:13:17.789 --> 00:13:24.509
So let's look at a quick demo of Pointer Events.

00:13:24.509 --> 00:13:25.539
[ Background noise ]

00:13:25.539 --> 00:13:29.730
>> Raleigh: So I have a little TargetGallery
application here and you can click in the targets

00:13:29.730 --> 00:13:36.930
and they get a nice little green dot and if you miss we get
a system beep and we will go ahead and switch into Edit mode

00:13:36.929 --> 00:13:41.839
and I can make this easier by just grabbing one of
these and, you know, making it move really slowly

00:13:41.840 --> 00:13:45.310
or I can make it more difficult
by making it go way too fast.

00:13:45.309 --> 00:13:51.819
Now we'll go back into Shooting mode and,
you know, I can try and hit the fast one.

00:13:51.820 --> 00:13:56.540
I'm not that good I'll stick with the slow
one right there that works a lot better.

00:13:56.539 --> 00:14:03.009
So, a fair number of interesting things has happened
right there and we're going to go over some of that.

00:14:03.009 --> 00:14:06.950
[ Background noise ]

00:14:06.950 --> 00:14:14.070
>> Raleigh: So, we have mouseDowns
occurring and if we look back at our example

00:14:14.070 --> 00:14:18.000
in this example the mouseDown is occurring over a button.

00:14:18.000 --> 00:14:24.700
So the window is going to get the event and the window's
going to try and route it to the appropriate view,

00:14:24.700 --> 00:14:32.960
and the way it does that is it looks at the View
Hierarchy and we turn that around and we do Hit Testing.

00:14:32.960 --> 00:14:41.440
So NSWindow will ask its Content View do hitTest
and by default NSView looks at all of its subviews

00:14:41.440 --> 00:14:45.190
and it does the appropriate Hit Testing on each one of
those subviews and those subviews ask their subviews

00:14:45.190 --> 00:14:50.310
and this continues on down until finally we get to NSButton.

00:14:50.309 --> 00:14:57.609
NSButton doesn't have any subviews and NSButton wants to
be the appropriate view for this event so it returns Self.

00:14:57.610 --> 00:15:05.620
So NSWindow will then send the mouseDown Event to that
button and it will go down the Responder Chain from there.

00:15:05.620 --> 00:15:08.960
Sorry -- will go up the Responder Chain from there.

00:15:08.960 --> 00:15:14.000
But one of the great things about this is this is one
of those detour points I was talking about earlier.

00:15:14.000 --> 00:15:19.559
In your class custom NSView you
can override hitTest and change

00:15:19.559 --> 00:15:25.879
where in the Responder Chain Cocoa
is going to send the event.

00:15:25.879 --> 00:15:29.730
So this is a great place for you to
interject yourself and we actually do

00:15:29.730 --> 00:15:33.850
that in the sample, so we're going to show you that.

00:15:33.850 --> 00:15:41.590
So here's that TargetGallery demo and what we have is a
custom Target View that contains all of our little targets.

00:15:41.590 --> 00:15:46.810
And each target is actually another little subview and all
they do is draw a little target but they're a custom view

00:15:46.809 --> 00:15:51.199
and they override the mouseDown Event so that
when you click in them they draw a little circle

00:15:51.200 --> 00:15:53.509
in their view where you did the mouseDown.

00:15:53.509 --> 00:16:04.840
But in the Target View overrides hitTest and if it's in the
Editing mode it returns Self and that stops the Hit Testing

00:16:04.840 --> 00:16:10.190
from ever getting to any one of those Target Views and
the mouseDown and all the mouseDraggeds will then go

00:16:10.190 --> 00:16:15.040
to the Target View, and this is how we're
able to actually move things around.

00:16:15.039 --> 00:16:23.360
And if you notice in this example when we look at the
mouseDown if we're not editing we do the System Beep.

00:16:23.360 --> 00:16:29.610
If we are editing we just let the mouse continue up the
Responder Chain as normal by calling super mouseDown Event

00:16:29.610 --> 00:16:33.600
to get to the default implementation from NSResponder.

00:16:33.600 --> 00:16:39.899
And what ends up happening in the sample code, I suggest
you check it out, is the controller implements mouseDown

00:16:39.899 --> 00:16:43.590
and it is responsible for doing all
of the dragging of the subviews.

00:16:43.590 --> 00:16:49.009
And I did this in the sample code to illustrate
how events flow through the Responder Chain

00:16:49.009 --> 00:16:52.080
and where they end up, so you should really check that out.

00:16:52.080 --> 00:16:57.190
Let's talk a little bit specifically
about Mouse Events in particular.

00:16:57.190 --> 00:17:00.760
We're going to talk about a field called subtype.

00:17:00.759 --> 00:17:05.029
We're going to talk about some best
practices and we're going to talk about when

00:17:05.029 --> 00:17:09.119
to use the delta XY Values versus the locationInWindow.

00:17:09.119 --> 00:17:17.000
So it turns out that there are more than 1
type of device that can generate Mouse Events.

00:17:17.000 --> 00:17:23.660
Mice, obviously, Tablets and trackpads and you can
easily determine from your various Mouse Event,

00:17:23.660 --> 00:17:27.370
mouseDown or mouseDragged, if you just
ask for the subtype from the event.

00:17:27.369 --> 00:17:34.829
In the Mouse Event if it's from a mouse, you know it's
from a mouse, there's no other additional information

00:17:34.829 --> 00:17:42.099
in the event other than what you normally think of with your
location in window and your deltaX and your deltaY values.

00:17:42.099 --> 00:17:46.490
But if it's from a Tablet there
might be additional information.

00:17:46.490 --> 00:17:51.900
Tablets, for example, can tell what the pressure is
applied to the tip of the device or what the tilt is

00:17:51.900 --> 00:17:53.910
of the device on the Tablet, or its rotation.

00:17:53.910 --> 00:17:58.460
And if your application can take advantage
of this extra information you can find

00:17:58.460 --> 00:18:01.299
out if it's there by looking at the subtype.

00:18:01.299 --> 00:18:08.069
I also suggest if you can take advantage of this information
that you look at tabletProximity and tabletPoint.

00:18:08.069 --> 00:18:14.259
And tabletProximity is an event that will tell you more
information about exactly what that device supports.

00:18:14.259 --> 00:18:17.650
Some devices support Tilt some don't so
you can get more information on what type

00:18:17.650 --> 00:18:19.960
of device is being used and what it supports.

00:18:19.960 --> 00:18:24.400
I'm not going to go into everything about Tablets but
you can do a search for a Cocoa Event-Handling Guide:

00:18:24.400 --> 00:18:27.530
Handling Tablet Events and you
can get more information there.

00:18:27.529 --> 00:18:35.289
You could also find out if the Mouse Event
is coming from a Touch device or a Trackpad.

00:18:35.289 --> 00:18:41.079
There's no additional information in the event to get but
sometimes it's nice to know that it's coming from a Touch

00:18:41.079 --> 00:18:43.009
so you can use this to make some decisions.

00:18:43.009 --> 00:18:48.069
[ Background noise ]

00:18:48.069 --> 00:18:53.579
>> Raleigh: So, some Mouse Best Practices.

00:18:53.579 --> 00:19:01.809
Tracking areas; tracking areas are the way that
you should go about doing roll-overs or try to find

00:19:01.809 --> 00:19:07.169
out when the mouse enters in exit areas,
the different areas of your application.

00:19:07.170 --> 00:19:09.000
You could try and look at all the Mouse Moves.

00:19:09.000 --> 00:19:15.869
We generally don't issue the Mouse Moves for performance
but if you want the Mouse Moves you can go into NSWindow

00:19:15.869 --> 00:19:25.299
and turn them on but they won't work exactly like you might
think so it's, particularly if it moves out of your view,

00:19:25.299 --> 00:19:30.859
you -- the Mouse Moves are actually
sent to the FirstResponder, actually,

00:19:30.859 --> 00:19:37.469
so you might not get the way you would think and your
roll-overs wouldn't work and it's harder to implement.

00:19:37.470 --> 00:19:42.250
And it actually uses more of a performance problem
because you're looking at every single mouse move.

00:19:42.250 --> 00:19:45.960
With Tracking Areas it's nice and easy
you set them up and you will be notified

00:19:45.960 --> 00:19:49.059
when the mouse enters your tracking area and when it leaves.

00:19:49.059 --> 00:19:55.929
If you want more information about Tracking Areas
you can search for Using the Tracking Area Objects.

00:19:55.930 --> 00:19:58.640
Please use the three-method tracking approach.

00:19:58.640 --> 00:20:00.350
What's the three-method tracking approach?

00:20:00.349 --> 00:20:06.189
It's when you implement mouseDown,
mouseDragged and mouseUp in your view.

00:20:06.190 --> 00:20:13.220
The other way of doing this is in the mouseDown is to do
NSNextEventMatchingMask and look for the events yourself

00:20:13.220 --> 00:20:20.279
and do your own Tracking Loop, that will actually cause
problems and it will be one of the reoccurring mantras later

00:20:20.279 --> 00:20:25.579
on during the talk where I say that Tracking Loops -- if
something goes into a Tracking Loop you can't do something.

00:20:25.579 --> 00:20:28.089
So if you use the three-method approach
you don't run into that problem.

00:20:28.089 --> 00:20:31.279
And Cocoa does something really nice for you here.

00:20:31.279 --> 00:20:37.379
When the mouseDown occurs and it does its Hit Testing it
locks on to whatever view was returned from Hit Testing,

00:20:37.380 --> 00:20:41.090
so all your mouseDraggeds until the
mouseUp occurs will continue to be sent

00:20:41.089 --> 00:20:44.230
to that view even if the mouse is not in that view.

00:20:44.230 --> 00:20:49.860
So if you're in a button and your mouseDown occurs in your
button you will continue to get mouseDraggedged events.

00:20:49.859 --> 00:20:54.849
If your cursor moves out of your bounds you'll get
a mouseDraggedged event but you can easily test

00:20:54.849 --> 00:20:57.549
that against your bounds and you
can un-highlight, for example.

00:20:57.549 --> 00:21:03.359
When the mouseUp occurs you can test that against your
bounds and decide if it's appropriate to send the action.

00:21:05.509 --> 00:21:10.629
But while you're doing your Mouse Tracking you
might want to consider looking at Drag Thresholds.

00:21:10.630 --> 00:21:11.840
A lot of people don't do this.

00:21:11.839 --> 00:21:18.049
But what Drag Threshold is is when a mouseDragged event
comes in don't start your dragging action right away wait

00:21:18.049 --> 00:21:22.960
to find out if the user has moved the mouse a few pixels.

00:21:22.960 --> 00:21:28.600
And the reason for this is my elderly next-door neighbors,
they got their computer and they constantly called me

00:21:28.599 --> 00:21:32.829
over because they were having trouble
clicking on some different things.

00:21:32.829 --> 00:21:35.559
And when they would go and they'd click with
the mouse they were using their whole hand

00:21:35.559 --> 00:21:43.089
and their mouse would move a few pixels and sometimes this
would cause a drag or it wasn't an actual just a click

00:21:43.089 --> 00:21:47.689
and so nothing would happen at all in various
applications and this was frustrating for them.

00:21:47.690 --> 00:21:52.680
So you might want to look at Drag Thresholds as a
way of making sure that you do what the user intends

00:21:52.680 --> 00:21:56.320
to do and not what they accidentally did.

00:21:58.210 --> 00:22:03.430
Finally, deltaX and Y versus locationInWindow.

00:22:03.430 --> 00:22:05.490
Why would you want to use one over the other?

00:22:05.490 --> 00:22:09.450
Well, let's take a look at what
happens when you get it wrong.

00:22:09.450 --> 00:22:15.069
We're going to drag this object with the mouse and
the object is no longer lining up with our cursor.

00:22:15.069 --> 00:22:20.009
Now that doesn't make for a very good user experience.

00:22:20.009 --> 00:22:24.349
Generally you'll want to use locationInWindow; this
is the default thing that you should be looking at.

00:22:24.349 --> 00:22:31.869
When your mouseDragged Event occurs or your mouseDown Event
you get the locationInWindow from the event and you convert

00:22:31.869 --> 00:22:38.069
in your view, you convert that location fromView nil
and this will convert from the Window Coordinate System

00:22:38.069 --> 00:22:41.939
to your Views Coordinate System so now you
have a point in your Local Coordinate Space.

00:22:41.940 --> 00:22:47.070
It's real easy for you to do things like test
if this point is within your view's bounds.

00:22:48.160 --> 00:22:52.560
And you really want to use locationInWindow when
you need to align something with the cursor;

00:22:52.559 --> 00:22:58.629
this is the best way to make sure that the cursor and
whatever you're dragging or you're doing stays in sync.

00:22:58.630 --> 00:23:05.720
And it's also the best way and the easiest way to get
the Coordinate System to be localized into your view.

00:23:05.720 --> 00:23:13.980
Because deltaX, deltaY, on the other hand, is actually
in screen pixels not in the points of the view

00:23:13.980 --> 00:23:20.150
so it's a little bit harder to get that with Device
Resolution Independence it'll be harder to get

00:23:20.150 --> 00:23:23.890
that into the localized location of the cursor.

00:23:23.890 --> 00:23:28.800
deltaX and deltaY, what that actually is, for those
of you that don't know, is we will tell you the amount

00:23:28.799 --> 00:23:32.759
of screen pixels that changed since the last mouse event.

00:23:32.759 --> 00:23:38.440
And it's not actually screen pixels, because what can
happen is the mouse as the user drags it can get pinned

00:23:38.440 --> 00:23:43.090
up against the screen but the user continues
to move the mouse in the same direction.

00:23:43.089 --> 00:23:50.279
The deltaX and deltaY will change but the locationInWindow
will be the same because it's pinned against the screen;

00:23:50.279 --> 00:23:54.680
this turns out to be really useful if you're
doing something like panning, or, for example,

00:23:54.680 --> 00:24:00.350
you might have a modeling application and you want
to rotate the model so the user clicks on the model

00:24:00.349 --> 00:24:03.189
and they start dragging the mouse
and you're rotating the object.

00:24:03.190 --> 00:24:07.340
Well, even though the cursor hits up against the edge
of the screen the user might still want to continue

00:24:07.339 --> 00:24:09.230
to rotate that object in the same direction.

00:24:09.230 --> 00:24:16.059
They can continue to move their mouse and you can
look at deltaX and deltaY and continue your rotation.

00:24:16.059 --> 00:24:21.909
So this is best used in a situation like that in
panning or, you know, through your model rotation

00:24:21.910 --> 00:24:24.000
where the cursor location is really irrelevant

00:24:24.000 --> 00:24:30.230
Other than, perhaps, starting the action.

00:24:30.230 --> 00:24:35.299
Alright, let's move on to Gestures some of the new stuff.

00:24:35.299 --> 00:24:39.389
So Gestures are another Pointer Event.

00:24:39.390 --> 00:24:45.860
And it turns out that these Magnify, Rotate
and Swipe Gestures are there from 10.5.2.

00:24:45.859 --> 00:24:48.229
We're publishing them for the first time in Snow Leopard

00:24:48.230 --> 00:24:53.910
but these will work backwards compatible
back to 10.5.2, so that's kind of nice.

00:24:53.910 --> 00:24:56.690
We use the cursor location to determine
where in the Responder Chain

00:24:56.690 --> 00:25:01.750
to start sending the Magnified, the Rotate or a Swipe event.

00:25:01.750 --> 00:25:07.109
So these are some textures in the Track Pad; this is
what a Magnify Event looks like, something like that.

00:25:07.109 --> 00:25:13.629
And this is the NSResponder Method that you need to
override if you want to handle the Magnify Event.

00:25:13.630 --> 00:25:19.390
magnifyWithEvent and you ask the event for the
magnification and you can get the change in magnification.

00:25:19.390 --> 00:25:27.009
A Rotate looks something kind of like this, these are
the touch points on the Track Pad, these are Rotates

00:25:27.009 --> 00:25:31.809
and you can get a rotateWithEvent if you ask the event for
the rotation and you'll actually get the delta Rotation

00:25:31.809 --> 00:25:38.750
between the last Rotate Event, so you might need to
wait for the whole Rotate to complete if you want

00:25:38.750 --> 00:25:46.259
to know what the complete rotation is for the whole Gesture
you'll need to combine all of the different deltas together.

00:25:46.259 --> 00:25:50.710
And then you have Swipe where the user
can use 3 fingers and they can Swipe.

00:25:50.710 --> 00:25:53.640
Looks something kind of like this.

00:25:53.640 --> 00:25:57.320
There's 2 methods on Event you
need to look at, deltaX and deltaY.

00:25:57.319 --> 00:26:03.349
You can use this to determine if they're
swiping up, down or left or right.

00:26:03.349 --> 00:26:08.819
The left deltaX is 1 and if you swipe
right the deltaX will be negative 1.

00:26:08.819 --> 00:26:13.819
Your deltaY will be 0 in that case
and you have the up being 1 for deltaY

00:26:13.819 --> 00:26:17.639
and your deltaX will be 0 then your down being negative 1.

00:26:17.640 --> 00:26:20.390
So that's Gestures really quick.

00:26:20.390 --> 00:26:26.060
And then we have the new Multi-Touch API; this is going
to be brand new for Snow Leopard but we now allow you

00:26:26.059 --> 00:26:34.899
to get the individual touches and not just the higher-level
Gesture, so this will be really great in some applications.

00:26:34.900 --> 00:26:45.000
But the thing I need to get across here is a Track Pad
on the desktop is not a touch-screen on the iPhone.

00:26:45.000 --> 00:26:49.369
There's going to be some fundamental differences here.

00:26:49.369 --> 00:26:55.239
Namely that you have an indirect input method with the
Track Pad versus a direct input method with the phone.

00:26:55.240 --> 00:26:58.509
With the phone you have a touch-screen and you want to --

00:26:58.509 --> 00:27:02.170
the user wants to directly manipulate
what's underneath their finger.

00:27:02.170 --> 00:27:08.430
Well, since you're not touching the screen on the desktop
we need some other kind of way of determining indirectly

00:27:08.430 --> 00:27:15.140
where the user is trying to do their Multi-Touch and
what object on the screen are they trying to manipulate,

00:27:15.140 --> 00:27:20.300
and the way we do that, again, is with the cursor.

00:27:20.299 --> 00:27:24.809
So Multi-Touch Events are another Pointer Event.

00:27:24.809 --> 00:27:28.289
So we use the cursor location to determine
where to send the Multi-Touch Event.

00:27:28.289 --> 00:27:31.049
We do similar Hit Testing that we did for the mouse.

00:27:31.049 --> 00:27:36.009
The difference is once Hit Testing is complete
we go up the View Hierarchy until we find a view

00:27:36.009 --> 00:27:42.029
that is accepting touches and then we use that
view as the FirstResponder in the Responder Chain.

00:27:42.029 --> 00:27:49.960
And similar, as I discussed with the 3-method approach
for dragging, once a touch has come down on the Track Pad

00:27:49.960 --> 00:27:55.569
and we do Hit Testing all touches will continue to
go to that view even as the user adds more touches,

00:27:55.569 --> 00:27:59.029
even if the cursor has moved until
all the touches have been released.

00:27:59.029 --> 00:28:02.629
Once all the touches have been released
from the Track Pad and a new touch comes

00:28:02.630 --> 00:28:06.490
in we will do Hit Testing again and
we will lock on to another view.

00:28:06.490 --> 00:28:10.009
So let's give a quick demo of that.

00:28:10.009 --> 00:28:18.629
[ Background noise ]

00:28:18.630 --> 00:28:25.930
>> Raleigh: So this is my hello,
world of Multi-Touch applications.

00:28:25.930 --> 00:28:29.240
From what I've gathered the hello, world of
Multi-Touch applications the very first thing you need

00:28:29.240 --> 00:28:32.200
to write is a LightTable, so there's my LightTable.

00:28:32.200 --> 00:28:40.529
So I've drawn some images on here and you can do the normal
thing of grabbing a Drag Handle with the mouse and moving

00:28:40.529 --> 00:28:49.809
that around and changing your sizes and we can
double-click and we can change the size inside the mask and,

00:28:49.809 --> 00:28:54.119
well I can't grab my Drag Handle anymore
without repositioning everything.

00:28:54.119 --> 00:28:57.509
Well, this is one of the great places
that Multi-Touch comes in handy.

00:28:57.509 --> 00:29:02.289
So this LightTable's also Multi-Touch aware so I'm
going to start using 2 fingers on the Track Pad

00:29:02.289 --> 00:29:06.849
without grabbing a Drag Handle I can
just resize this exactly how I want

00:29:06.849 --> 00:29:09.429
and we can double-click to get out of Editing.

00:29:09.430 --> 00:29:13.870
We can move the whole thing around and it's great because
I can pin one side and stretch it or move just the top

00:29:13.869 --> 00:29:19.679
or just the bottom whatever I need to do there,
and we'll bring that around, say, right there.

00:29:19.680 --> 00:29:25.720
And this application also looks at Gestures so
I can use 3 fingers and I can Swipe in the tools

00:29:25.720 --> 00:29:32.579
and I can adjust the frame thickness, perhaps, and
we'll crank up the corner radius and make this more

00:29:32.579 --> 00:29:36.449
like a circle there, that's kind of nice.

00:29:36.450 --> 00:29:41.990
And so, again, I'm using Multi-Touch so I don't have to
worry about grabbing the little bitty Drag Handles as long

00:29:41.990 --> 00:29:45.990
as my cursor's over the image for this
particular application I know what I'm going

00:29:45.990 --> 00:29:47.829
to be adjusting so I can adjust this one over here.

00:29:47.829 --> 00:29:52.009
And so this is an example of using Multi-Touch.

00:29:52.009 --> 00:30:12.539
[ Background noise ]

00:30:12.539 --> 00:30:17.629
>> Raleigh: So Multi-Touch on the desktop is
very similar to Multi-Touch on the iPhone as far

00:30:17.630 --> 00:30:20.650
as the API but there are some subtle differences.

00:30:20.650 --> 00:30:26.150
We now have an NSTouch Object similar to
a UITouch and we have Phases on the Touch

00:30:26.150 --> 00:30:29.180
which are also similar to the Phases on UITouch.

00:30:29.180 --> 00:30:37.320
For example, when a Touch first comes down on to the
Trackpad you see a little dot that's a Touch coming down.

00:30:37.319 --> 00:30:40.769
The Touch moves into the NSTouch
Phase Began that's this phase.

00:30:40.769 --> 00:30:46.779
As the user starts moving the Touch on the Track
Pad the Touch moves into the NSTouch Phase Moved.

00:30:46.779 --> 00:30:51.730
Perhaps they leave it stationary and they have another
Touch coming in and out so while the Touch is stationary

00:30:51.730 --> 00:30:56.700
and there are other Touch things going on the Touch
is moved into the Stationary Phase and it'll move --

00:30:56.700 --> 00:31:01.400
the Touch might move back and forth between Stationary
and Moved and eventually your Touch is going to get

00:31:01.400 --> 00:31:05.860
down to Ended when the user finally
lifts their finger off of the Track Pad.

00:31:05.859 --> 00:31:10.169
And at any point in time the Touches might have actually
been cancelled, the system might have cancelled the Touches,

00:31:10.170 --> 00:31:16.789
for example, because you've clicked out of the
application even though you were tracking Touches

00:31:16.789 --> 00:31:24.190
in one window you've clicked out of the application your
application's lost focus we will cancel the Touches.

00:31:24.190 --> 00:31:25.610
We also have an Identity.

00:31:25.609 --> 00:31:33.569
For those of you who are familiar with the iPhone you'll
notice that this is something we don't have on the iPhone.

00:31:33.569 --> 00:31:42.000
On the iPhone Touches are mutated in place but the way
Events work on the desktop is they're an immutable event

00:31:42.000 --> 00:31:45.180
so all the Touches inside the event
must be immutable as well.

00:31:45.180 --> 00:31:49.380
So Identity is a way that you can
track a Touch as it moves over time.

00:31:49.380 --> 00:31:54.880
For example, a Touch A comes down and it starts moving and
then Touch B comes in you need to know which one is Touch A

00:31:54.880 --> 00:31:59.490
and which one is Touch B and Identity
is how you determine that.

00:31:59.490 --> 00:32:04.819
You need to be sure to use isEqual.

00:32:04.819 --> 00:32:08.359
It's an object that supports the Coppering Protocols
so that you can stick these in a dictionary,

00:32:08.359 --> 00:32:15.009
so you can use your Touch 1 as your key in a dictionary and
when future events come in you can compare that against --

00:32:15.009 --> 00:32:20.140
you can take the Identity out of your set of Touches
from the event and use that as a key in your dictionary

00:32:20.140 --> 00:32:30.009
or if you want to do it yourself just use the isEqual to
compare 2 Touches to find out which 2 they are over time.

00:32:30.009 --> 00:32:35.950
We also have an isResting property;
this is different than Stationary.

00:32:35.950 --> 00:32:45.370
On the new trackpads they don't have a button so like on
the image up there there's no external physical button

00:32:45.369 --> 00:32:50.399
on the trackpad and what we allow you to do is you can rest
your thumb on the trackpad as you move the cursor around

00:32:50.400 --> 00:32:55.090
and then, perhaps, use your thumb to click,
and it might look something like this.

00:32:55.089 --> 00:32:59.669
You touch and you're moving around and you bring your thumb
down and you click and you do a drag somewhere in there

00:32:59.670 --> 00:33:03.460
and you notice the little gray
Touch was wiggling a little bit.

00:33:03.460 --> 00:33:12.680
Resting doesn't mean stationary it generally means that it
can be ignored, and so it might move around a little bit.

00:33:12.680 --> 00:33:17.240
It might be the thumb that we're ignoring
and it could be in this resting phase.

00:33:17.240 --> 00:33:22.319
If it moves too far or it moves higher
into the right location it might turn

00:33:22.319 --> 00:33:25.329
into an Active Touch and then isResting will return No.

00:33:25.329 --> 00:33:33.159
So since this isn't a touch-screen we can't
give you locations in your view or on the screen

00:33:33.160 --> 00:33:36.410
where the Touch is occurring so we give
you a normalized position between 0

00:33:36.410 --> 00:33:40.410
and 1 so you can find out where
the Touch is on the trackpad.

00:33:40.410 --> 00:33:43.160
And so you have to, again, indirectly manipulate things.

00:33:43.160 --> 00:33:47.610
Well we also give you the device
size of the trackpad in case you want

00:33:47.609 --> 00:33:50.579
to know the actual physical dimensions
of how far they moved.

00:33:50.579 --> 00:33:56.039
The device sizes and points, 72 points per inch.

00:33:56.039 --> 00:34:00.690
And so if you take the normalized position and you
just simply multiply that times the device size

00:34:00.690 --> 00:34:04.900
and that will get you the physical
distance from the lower-left-hand corner

00:34:04.900 --> 00:34:07.550
of the trackpad over to where the Touch is.

00:34:07.549 --> 00:34:15.929
There's also a Device Property and this is mainly used for
in case there are multiple Touch devices on your computer.

00:34:15.929 --> 00:34:21.569
In an Event the collection of Touches will only be
associated with one device at a time so if the user is

00:34:21.570 --> 00:34:26.370
on multiple devices entering touches you'll get separate
events with their own collection of touches just

00:34:26.369 --> 00:34:28.859
for that device; this is one way
to determine the difference.

00:34:28.860 --> 00:34:32.130
An interesting thing about this is if touches are coming

00:34:32.130 --> 00:34:36.340
from multiple devices the Identity
will actually be unique across devices.

00:34:36.340 --> 00:34:42.070
Multi-Touch is completely opted in on the desktop.

00:34:42.070 --> 00:34:46.660
On NSView you have to call setAcceptsTouchEvents Yes.

00:34:46.659 --> 00:34:54.309
If there are not any views in the window that
accepts touches, Touches won't even be routed

00:34:54.309 --> 00:34:58.440
to that window it won't even come in
and that's a performance optimization,

00:34:58.440 --> 00:35:01.159
so you must opt-in to Touches if you want them.

00:35:01.159 --> 00:35:08.909
Once one view accepts touches,
touches will be sent to that window.

00:35:08.909 --> 00:35:11.429
You can also decide if you want resting touches.

00:35:11.429 --> 00:35:13.239
By default we don't send you resting touches.

00:35:13.239 --> 00:35:18.599
Generally resting touches can be ignored and when
they're ignored we don't even include them in the set.

00:35:18.599 --> 00:35:22.179
If you're not accepting resting touches they're
not even included in the set of touches.

00:35:22.179 --> 00:35:29.419
If a touch does move from a resting stage to an active stage
and you're ignoring resting touches we will fake that out

00:35:29.420 --> 00:35:32.789
to be a Touch Began at the point they become active.

00:35:32.789 --> 00:35:37.900
If they transition from Active to
Inactive we'll actually go ahead

00:35:37.900 --> 00:35:42.130
and issue a Touches Ended if you're
ignoring Resting Touches.

00:35:42.130 --> 00:35:45.820
Generally leave setWantRestingTouches at its default value.

00:35:45.820 --> 00:35:51.690
No the user's not intending to anything with that
touch but if you have some special application

00:35:51.690 --> 00:35:56.630
and you want resting touches you can look at
the isResting phase and make up your own mind.

00:35:56.630 --> 00:36:02.960
Another quick point with Resting Touches, when they are
ignored they are not included in the Hit Testing either.

00:36:02.960 --> 00:36:07.670
So earlier when I described the first touch that
comes down and we do the Hit Testing when we lock on.

00:36:07.670 --> 00:36:13.460
If you're ignoring Resting Touches they're not
included in that Hit Testing until they become active.

00:36:15.250 --> 00:36:19.739
These are the Responder Methods you need
to implement if you want to accept touches,

00:36:19.739 --> 00:36:25.709
and when you implement them please be sure to implement
them all, touchesBeganWithEvent, touchesMovedWithEvent,

00:36:25.710 --> 00:36:28.550
touchesEndedWithEvent and touchesCancelledWithEvent.

00:36:28.550 --> 00:36:35.960
For those of you familiar with the iPhone you'll notice
this looks slightly different; this is to keep in consistent

00:36:35.960 --> 00:36:45.490
with the other event methods that we have on NSResponder
it's the Event Type and followed by an Event Parameter.

00:36:45.489 --> 00:36:50.879
So I mentioned earlier to implement
them all and the reason you do that is,

00:36:50.880 --> 00:36:56.250
perhaps you are implementing just
touchesBeganWithEvent and there's another view higher

00:36:56.250 --> 00:36:59.670
up in the Responder Chain that's also touch-aware.

00:36:59.670 --> 00:37:04.039
If you're eating up all the touchesBegan and
you don't implement touchesEnded, for example,

00:37:04.039 --> 00:37:08.449
and they all of a sudden get some touchesEnded they might
get confused because they never got the touchesBegan,

00:37:08.449 --> 00:37:15.949
so if you implement touchesBegan please implement all
of these methods especially the touchesCancelled in case

00:37:15.949 --> 00:37:20.039
that happens you need to be able to back out your state.

00:37:21.090 --> 00:37:30.400
So the iPhone says touchesBegan and they pass you in a set
with Event and we don't provide you that set because we want

00:37:30.400 --> 00:37:34.579
to keep consistent with all of
our method names on the desktop.

00:37:34.579 --> 00:37:39.539
But on NSEvent the way you get this set of
Touches is you ask touchesMatchingPhaseinView

00:37:39.539 --> 00:37:42.529
and you pass your own view as your view.

00:37:42.530 --> 00:37:49.720
So in touchesBegan if you wanted to begin Touches you can
just say NSTouchPhaseBegan and you will get all the Touches

00:37:49.719 --> 00:37:57.809
that began in the touchesBeganWithEvent, though you
might want to ask for the Moved and the Stationery's.

00:37:57.809 --> 00:38:03.449
Well, this turns out to be a bit field so you can ask in the
MatchingPhase you can say Give Me the NSTouch Phase Moved

00:38:03.449 --> 00:38:07.049
or with the NSTouch Phase Stationary and
you will get all the stationary touches

00:38:07.050 --> 00:38:09.430
and all the moved touches, so that might come in handy.

00:38:09.429 --> 00:38:15.980
But what we think you're going to want most of the time
is all the touches that are touching give me the touches

00:38:15.980 --> 00:38:18.460
that are just began, the moved and the stationary.

00:38:18.460 --> 00:38:19.809
If they've ended I don't care.

00:38:19.809 --> 00:38:22.349
If they've been canceled I don't care about those.

00:38:22.349 --> 00:38:30.489
And we have predefined values for you you can just
say NSTouchPhaseTouching and that is equivalent

00:38:30.489 --> 00:38:35.979
to saying NSTouchPhaseBegan or'ed with
NSTouchPhaseMoved or'ed with NSTouchPhaseStationary.

00:38:35.980 --> 00:38:40.449
And another one that might come in handy that
we predefined for you is NSTouchPhaseAny.

00:38:40.449 --> 00:38:45.169
If you just want all of the Touches and you want
to inspect the properties, inspect the phase,

00:38:45.170 --> 00:38:50.099
inspect the isResting states and make up your
own mind you can just ask for NSTouchPhaseAny.

00:38:53.110 --> 00:39:00.269
So in the sample code we were tracking touches and
this is what the touchesBeganWithEvent looks like.

00:39:00.269 --> 00:39:05.329
The first thing we do is I want to know what
touches are currently touching the device.

00:39:05.329 --> 00:39:11.069
I know at least 1 touch began, perhaps, 2 began,
perhaps this is the second or third or fourth touch,

00:39:11.070 --> 00:39:14.210
so we get the set of touches that
are currently touching and we find

00:39:14.210 --> 00:39:16.809
out how many touches are currently touching the Trackpad.

00:39:16.809 --> 00:39:24.150
If it's 2 we want to go ahead and set up for 2-Touch
tracking and then we'll do our 2-Touch tracking

00:39:24.150 --> 00:39:28.760
after a threshold in the touchesMovedWithEvent.

00:39:28.760 --> 00:39:34.300
If it's more than 2 touches it's a third touch or a
fourth touch then I'm just going to get out of Dodge

00:39:34.300 --> 00:39:37.720
and cancel tracking because I only want to track 2 touches.

00:39:37.719 --> 00:39:41.179
And if it's less than 2 touches because
it's only 1 touch that just came

00:39:41.179 --> 00:39:44.059
down the very first touch I'm just
going to ignore it and not do anything.

00:39:44.059 --> 00:39:50.269
Of course I don't want to set up any tracking I
don't want to track 1 touch, which brings up a couple

00:39:50.269 --> 00:39:54.400
of interesting points some best practices for Multi-Touch.

00:39:54.400 --> 00:40:02.820
Another interesting difference between the iPhone and the
desktop is the touches can also be issuing Mouse Events

00:40:02.820 --> 00:40:06.690
and Touch Events at the same time
because you're moving the mouse cursor.

00:40:06.690 --> 00:40:09.480
So you'll need to take that into
consideration on when you're looking

00:40:09.480 --> 00:40:13.119
at each individual touch and when you want to track touches.

00:40:13.119 --> 00:40:18.509
At the same time at a higher level we might have interpreted
a Gesture so while we're sending out Touch Events we'll send

00:40:18.510 --> 00:40:23.570
out a Gesture or we might just be
sending out individual Touch Events.

00:40:23.570 --> 00:40:27.750
So you might need to selectively decide when you want to
ignore the mouse, when you want to ignore certain Gestures

00:40:27.750 --> 00:40:32.780
or when you want to ignore the Touches; this is where
it comes in real handy earlier looking at the subtype

00:40:32.780 --> 00:40:37.870
of a Mouse Event and seeing that the
Mouse Event is coming from a touch device.

00:40:37.869 --> 00:40:43.079
If you know you want to selectively ignore Mouse Events
while you're tracking something else that's a great way

00:40:43.079 --> 00:40:44.009
of doing that.

00:40:44.010 --> 00:40:49.950
[ Background noise ]

00:40:49.949 --> 00:40:53.319
>> Raleigh: Another thing we have
is to consider Tracking Thresholds.

00:40:53.320 --> 00:40:58.880
So even though the user has 1 finger and they're doing
something with 1 finger and they bring a second finger

00:40:58.880 --> 00:41:01.700
down they might have accidentally brushed the trackpad.

00:41:01.699 --> 00:41:07.159
Well, you don't necessarily want to go into 2
tracking and all of a sudden magnify something

00:41:07.159 --> 00:41:10.369
when that's not what the user wanted or intended.

00:41:10.369 --> 00:41:16.909
So just like Mouse Events you should consider using
Tracking Thresholds in your Multi-Touch tracking.

00:41:16.909 --> 00:41:24.329
Since we have Gesture Events going on and they're captured
at a higher level you'll want to consider forwarding these

00:41:24.329 --> 00:41:27.460
to the next responder when you're
not specifically ignoring them.

00:41:27.460 --> 00:41:31.079
Let these flow through the Responder Chain because
often what'll end up happening, for example,

00:41:31.079 --> 00:41:37.599
Safari it's more like the Window Controller
that is going to handle the Swipe Gesture

00:41:37.599 --> 00:41:41.319
or some of these higher level gestures
you go backwards and forward in the view.

00:41:41.320 --> 00:41:47.190
In the LightTable example when I pulled up the tools
that was actually done at the controller level,

00:41:47.190 --> 00:41:48.720
at the Window Controller and not in the View.

00:41:48.719 --> 00:41:51.269
The View had no concept that these tools existed.

00:41:51.269 --> 00:41:57.849
So I went ahead and forward the Gesture Events
when I wasn't ignoring them up the Responder Chain,

00:41:57.849 --> 00:42:01.380
got to the Window Controller and
I appropriately showed the tools

00:42:01.380 --> 00:42:05.539
or hid the tools depending on what
type of Swipe Event it was.

00:42:05.539 --> 00:42:09.440
So you need to take that into consideration as well.

00:42:09.440 --> 00:42:17.570
So we have these Multi-Touches, individual Multi-Touches
and we have these Gestures, the higher level thing.

00:42:17.570 --> 00:42:22.789
When do you use Gestures and when
do you use the Multi-Touch Events?

00:42:22.789 --> 00:42:26.670
Well, it comes down to a question
of what are you really trying to do?

00:42:26.670 --> 00:42:35.000
If possible let Apple do the hard work for you
and let it recognize the event at a higher level.

00:42:36.329 --> 00:42:43.599
So if you're doing a Magnify and that's all you're really
doing because you don't care about the exact position.

00:42:43.599 --> 00:42:48.690
For example on the LightTable application I
could pin one side and just expand one side out,

00:42:48.690 --> 00:42:52.039
so I need to look at the individual
touches to determine that.

00:42:52.039 --> 00:42:58.610
But if it was some other kind of control or the image
was fixed and you just wanted to Magnify it in place

00:42:58.610 --> 00:43:06.550
or it's like your whole view you're magnifying the whole
view then let Apple do the high-level magnify recognition

00:43:06.550 --> 00:43:10.010
for you, and the same thing with Rotate and Swipe.

00:43:10.010 --> 00:43:16.070
And as it turns out if you were to actually look at the
individual touches associated with the Gesture and try

00:43:16.070 --> 00:43:21.070
and do your own magnify because of
resting and when touches might be canceled

00:43:21.070 --> 00:43:25.610
and some various other little aspects
you might not get a magnify

00:43:25.610 --> 00:43:31.510
with 2 touches you might only actually
see 1 touch in various things like this.

00:43:31.510 --> 00:43:37.250
And so don't worry about the complication that's
going on there let Apple do the hard work for you

00:43:37.250 --> 00:43:42.269
when it's appropriate, when there are occasions
where you need to know the exact individual touch

00:43:42.269 --> 00:43:47.159
because it makes sense to pin something
on one side versus the other then go ahead

00:43:47.159 --> 00:43:50.460
and use touchesBegan, Moved, Ended and Canceled.

00:43:50.460 --> 00:43:55.809
So that's Multi-Touch.

00:43:55.809 --> 00:43:57.789
It's rather a small API there's not that much there.

00:43:57.789 --> 00:43:59.210
It's really fun to play around with.

00:43:59.210 --> 00:44:05.240
I suggest that you download the LightTable
application and play with it yourself.

00:44:05.239 --> 00:44:08.159
And also make your own LightTable application.

00:44:08.159 --> 00:44:11.230
I want to see a flurry of them out there
on the Web that would be really awesome.

00:44:11.230 --> 00:44:16.750
Now let's talk a little bit about Event Big Brother.

00:44:16.750 --> 00:44:22.670
So we're going to start monitoring events that are
going on on your app and elsewhere in the system.

00:44:22.670 --> 00:44:29.349
And the first thing you need to
know is a couple of funnel points.

00:44:29.349 --> 00:44:35.269
We talked earlier that when an external event comes in
such as a keyboard or mouse event it goes to NSApplication.

00:44:35.269 --> 00:44:40.000
Where it actually goes is through
NSApplication Send Event Method.

00:44:40.000 --> 00:44:46.559
So you can have your own custom NSApplication Class,
you can override Send Event, you can get the event,

00:44:46.559 --> 00:44:52.420
you can look at it, you can determine what type it is, you
can route it to a different window, you can just let it fall

00:44:52.420 --> 00:44:59.889
on the floor or you can call super sendWithEvent and let
NSApplication continue processing the event as normal,

00:44:59.889 --> 00:45:03.489
or you can let application route that event down to NSWindow

00:45:03.489 --> 00:45:07.919
and you can have your own custom
NSWindow that overrides SendEvent.

00:45:07.920 --> 00:45:14.280
NSWindow uses the same method and you can look at the
window level once you know it's going to the right window

00:45:14.280 --> 00:45:20.300
and you can now route an event by inspection to the right
view to the right place or let it fall on the floor,

00:45:20.300 --> 00:45:23.970
or call super and let it continue on its merry way.

00:45:23.969 --> 00:45:33.399
And that's fine and dandy but it's kind of a pain sometimes
to create your own NSApplication subclass and then go

00:45:33.400 --> 00:45:37.360
into Interface Builder and set the
primary class and deal with all that.

00:45:37.360 --> 00:45:40.809
We have some new things in Snow Leopard
which are really nice called Event Monitor.

00:45:40.809 --> 00:45:45.170
We have Local monitors and Global monitors.

00:45:45.170 --> 00:45:50.820
Local monitors are a way that you could easily monitor
an event that is already targeted to your application

00:45:50.820 --> 00:45:55.019
so you won't need to override SendofEnded
NSApplication you can install an Event Monitor

00:45:55.019 --> 00:46:00.130
at the appropriate place inside your
class and it works out really nicely.

00:46:00.130 --> 00:46:04.829
And then we have Global Event Monitors which
is a way of monitoring vents that are going

00:46:04.829 --> 00:46:07.670
on that aren't specifically targeted to your application.

00:46:07.670 --> 00:46:12.820
If that event is targeted to another application
you'll be able to see that event on the Global monitor.

00:46:12.820 --> 00:46:19.260
So at no time if you have both a Local and a Global
monitor you won't get the same event coming through both

00:46:19.260 --> 00:46:23.430
at the exact same time because it's either targeted
to your app or it's not, and that's how you decide

00:46:23.429 --> 00:46:27.039
if you need a Local monitor or a Global monitor.

00:46:27.039 --> 00:46:30.250
So let's look at this at a little bit more detail.

00:46:30.250 --> 00:46:36.579
I want to point out, again, that the Local monitor
and the Global monitor are a new API in Snow Leopard

00:46:36.579 --> 00:46:41.909
and this is what the API looks like for a Local monitor.

00:46:41.909 --> 00:46:50.469
It's a Class Event on NSEvent so you just
call AddLocalMonitorForEventMatchingMask

00:46:50.469 --> 00:46:55.419
and you pass it a block as a handler.

00:46:55.420 --> 00:47:00.180
And you'll also happen to notice
that this block returns an NSEvent.

00:47:00.179 --> 00:47:04.639
So with the Local Event Monitoring you can not only
monitor the events that's coming through the system

00:47:04.639 --> 00:47:11.960
but before the NSApplication routes them you can change
the event, put in a different event or just return NIL

00:47:11.960 --> 00:47:19.199
and end processing from there,
so this comes in really handy.

00:47:19.199 --> 00:47:23.369
You might want to be careful if you have
multiple Event Monitors all watching

00:47:23.369 --> 00:47:25.589
for the same event in your application.

00:47:25.590 --> 00:47:34.050
If one of the Event Monitors returns NIL it won't get past
to the other event handlers -- Event Monitors I should say.

00:47:34.050 --> 00:47:39.980
And here's one of those places where you
don't get events that are in a tracking loop

00:47:39.980 --> 00:47:47.829
so if there's a mouse tracking loop going on in
NSEventMatchingMask that bypasses the normal flow of events

00:47:47.829 --> 00:47:51.409
through Cocoa and you won't get
them, you can't monitor them.

00:47:51.409 --> 00:48:01.149
And finally, the Local monitor for Mask when
you add a new one you get back a Monitor Object.

00:48:01.150 --> 00:48:05.599
You need to hold on to this object because you'll need
to remove it using the Remove API but you don't need

00:48:05.599 --> 00:48:07.940
to retain it, Cocoa is going to handle the memory for you.

00:48:07.940 --> 00:48:17.970
This is the Global monitor it is also a Class
Event, AddGlobalMontiorForEventsMatchingMask.

00:48:17.969 --> 00:48:22.469
So events that are not targeted to your application
already will come in on your Global monitor.

00:48:22.469 --> 00:48:28.439
For those of you familiar with the Monitor Target
on the Carbon API when you can add a handle

00:48:28.440 --> 00:48:31.480
for a Monitor Target; this is our Cocoa equivalent.

00:48:31.480 --> 00:48:40.599
And it has the same limitations in that you
can observe only, you can't modify the events

00:48:40.599 --> 00:48:47.349
and you generally don't get Keyboard Events this
way unless you have User Assistive Devices turned on

00:48:47.349 --> 00:48:51.900
and Accessibility Preferences or you're
a Trusted Accessibility Application.

00:48:51.900 --> 00:48:57.050
And I want to point out that in both the Global monitor
and the Local monitor's you can't get Keyboard Events

00:48:57.050 --> 00:49:01.510
in Secure Fields so you can't sniff passwords this way.

00:49:03.280 --> 00:49:09.140
And as we pointed out you can't modify
the event so there is nothing to return.

00:49:09.139 --> 00:49:14.909
And similar to the Local Event Monitor you get back
an Event Monitor Object and just hold on to it.

00:49:14.909 --> 00:49:16.789
You don't need to retain it but you will need to remove it.

00:49:16.789 --> 00:49:20.210
And this is how we remove the Event Monitors.

00:49:20.210 --> 00:49:22.720
So Cocoa is going to manage the memory for you.

00:49:22.719 --> 00:49:28.980
We are going to take care of the Run Loop,
take care of all the appropriate things

00:49:28.980 --> 00:49:30.510
that need to be done with your Event Monitor.

00:49:30.510 --> 00:49:33.940
You just need to tell us when to get
rid of it, so you need to pass it back

00:49:33.940 --> 00:49:36.950
to us and tell us to remove the Event Monitor.

00:49:36.949 --> 00:49:41.919
And you must explicitly do this none of this is going to get
done for your automatically not even for Garbage Collection.

00:49:41.920 --> 00:49:49.010
So let's take a quick demo of Event Monitoring.

00:49:49.010 --> 00:50:04.610
[ Background noise ]

00:50:04.610 --> 00:50:09.610
>> Raleigh: So I have an application here
that looks at the Tablet and it can tell

00:50:09.610 --> 00:50:14.480
when you bring the device near the Tablet; this
is a Proximity Event I was talking about earlier.

00:50:14.480 --> 00:50:15.920
And, you know, Tablet's kind of neat.

00:50:15.920 --> 00:50:21.289
You can find out when you're using the opposite end of
the pen and know that the user actually intends to erase.

00:50:21.289 --> 00:50:27.800
That's one of the kind of really neat things but
generally Proximity Events are something you want to send

00:50:27.800 --> 00:50:36.360
to all the Tablet-aware objects in your
application and this view over here -- if I come --

00:50:36.360 --> 00:50:40.950
now I can get things there but the other
one's not getting it; this isn't what we want.

00:50:40.949 --> 00:50:44.480
So what we're going to do is we're going
to use Event Monitors to track this.

00:50:44.480 --> 00:50:49.289
So we're going to quit that and
we're going to come into Xcode here.

00:50:49.289 --> 00:50:59.199
Here's our Tablet Proximity Event Method Override and we
look at -- we only care if it's an Entering Proximity.

00:50:59.199 --> 00:51:01.889
If the device is leaving we set the image to No.

00:51:01.889 --> 00:51:09.429
If we look at the pointing device type on entry and we
decide if it's a pointing device we'll show the pen.

00:51:09.429 --> 00:51:14.039
If it's an eraser pointing device,
we have pen pointing device

00:51:14.039 --> 00:51:17.090
and eraser pointing device; we'll show the eraser image.

00:51:17.090 --> 00:51:23.130
And Tablet's actually have a cursor
pointing device or a puck or a mouse,

00:51:23.130 --> 00:51:26.980
other definitions you might hear
and we'll show the mouse image here.

00:51:26.980 --> 00:51:36.469
So we've already set up in this application a couple
of menus to toggle adding a Local monitor on and off

00:51:36.469 --> 00:51:41.539
and to add a Global monitor on and off, so
we'll go ahead and fill in the definitions here.

00:51:41.539 --> 00:51:45.380
Since it's a toggle we have an
IVAR for a Local Event Monitor.

00:51:45.380 --> 00:51:52.670
If we already have one then we want to turn it off and
we will remove the monitor and set our Local IVAR to NIL.

00:51:52.670 --> 00:52:00.139
Otherwise we need to go ahead and add one so we'll
do that real quick for NSEvent and add Local monitor

00:52:00.139 --> 00:52:09.549
for Matching Mask NSTablet Proximity Mask
and so this is the way we do a handler.

00:52:09.550 --> 00:52:18.430
You've probably have been to some of
these sessions -- NSEvent -- Start Event.

00:52:18.429 --> 00:52:25.739
So we'll open up our block and we'll go ahead and close
our block and then close the method and add our semi-colon.

00:52:25.739 --> 00:52:34.109
And so when our block gets called we already have a Tablet
Proximity Method that's going to do all the right thing

00:52:34.110 --> 00:52:45.860
with the images for us so all we need to do is on self
call Tablet Proximity then pass in the event and that --

00:52:45.860 --> 00:52:49.680
so now we need to return because
this is a Local Event Monitor.

00:52:49.679 --> 00:52:54.779
We don't need to modify the event we're going to let
the event go through the normal processing and let it go

00:52:54.780 --> 00:53:00.950
through all the Local monitors and we'll now go ahead and
set up our Global Event Monitor because we want to know

00:53:00.949 --> 00:53:04.469
when we're in the background we also
want to know what the current state

00:53:04.469 --> 00:53:08.009
of the device is on the Tablet so we're always in sync.

00:53:08.010 --> 00:53:12.220
So it does the exact same thing about
removing the monitor if it already exists,

00:53:12.219 --> 00:53:19.109
but if we need to create a new one we just
do NSEvent@GlobalEventMonitor this time

00:53:19.110 --> 00:53:23.650
and we need to look for the Proximity Event.

00:53:23.650 --> 00:53:34.119
Proximity Mask and we will go ahead and set up our handler.

00:53:34.119 --> 00:53:38.099
Open our block, close the whole thing.

00:53:38.099 --> 00:53:42.360
And, again, we'll just do the same thing
here when the background it's going

00:53:42.360 --> 00:53:48.039
to be real simple we'll just pass the event on to
our handler as it already exists and we don't need

00:53:48.039 --> 00:53:52.639
to return anything this time it's just a Global
Event Monitor we can't modify the event in any way.

00:53:52.639 --> 00:53:58.650
So we'll go ahead and make sure that builds, it
does, great, so here's our application again.

00:53:58.650 --> 00:54:05.829
And this time when we come in with the Tablet it's still
doing the same thing because we have it set on a Menu Toggle

00:54:05.829 --> 00:54:08.650
so we will go ahead and turn on the Local Event Monitoring.

00:54:08.650 --> 00:54:15.809
Now that we have the Local Event Monitoring
you see that both windows are getting updated.

00:54:15.809 --> 00:54:23.429
So inside of each window they have that same view that
we just modified so each view adds a Local Event Monitor

00:54:23.429 --> 00:54:26.259
so they both get their call back
and they're both doing the same code

00:54:26.260 --> 00:54:31.330
so they'll just display the appropriate brush or eraser.

00:54:31.329 --> 00:54:36.110
Now, if we're in the background say we come into
the Finder you notice it doesn't get any changes.

00:54:36.110 --> 00:54:38.070
So let's go ahead and turn on our Background Toggle.

00:54:38.070 --> 00:54:44.420
We'll go ahead and turn on the
Global Event Monitoring, there we go.

00:54:44.420 --> 00:54:48.610
So we have our Local Event Monitoring and now that --

00:54:48.610 --> 00:54:51.870
if we bring Finder to the foreground
we're not the target application anymore

00:54:51.869 --> 00:54:55.889
and the Global Event Monitor is
getting called for us and we can --

00:54:55.889 --> 00:54:59.420
this application can maintain the appropriate
state even though it's in the background.

00:54:59.420 --> 00:55:04.250
So that's one of my favorite uses of Event Monitors.

00:55:14.329 --> 00:55:16.539
[Applause] Thank you.

00:55:16.539 --> 00:55:20.230
>> Raleigh: So a word of caution about Event Monitors.

00:55:20.230 --> 00:55:22.909
There can be a potential performance impact here.

00:55:22.909 --> 00:55:29.210
If you actually install a Global Event Monitor for
all the mouse moves we'll send you all the mouse moves

00:55:29.210 --> 00:55:33.250
and that could potentially be a
lot of information coming through.

00:55:33.250 --> 00:55:40.809
If you set a Global Event Monitor and put a
matchEventMask you'll get all sorts of stuff and, you know,

00:55:40.809 --> 00:55:43.829
this can have an impact on the system
so you really need to be careful.

00:55:43.829 --> 00:55:47.480
When you use a Global Event Monitor make sure
it's the appropriate thing for what you want to do

00:55:47.480 --> 00:55:50.449
that there isn't a better way to
do what you're trying to do.

00:55:50.449 --> 00:55:53.809
While the Tablet is a great example I
want to give you one more example briefly.

00:55:53.809 --> 00:56:01.980
Say you want to do your own custom cell tracking which, in
a list, which actually brings up another window and you want

00:56:01.980 --> 00:56:07.329
to know when the user clicks out of this window
because you just want to have that window go away.

00:56:07.329 --> 00:56:14.489
That works great normally unless the mouseDown occurs
outside your window if you're not doing a tracking loop.

00:56:14.489 --> 00:56:19.119
But if the mouseDown occurs outside of
your application's windows it's going to go

00:56:19.119 --> 00:56:22.289
to some other application even though that application's
in the background the mouseDown's going to go

00:56:22.289 --> 00:56:25.529
to that application and bring that
application to the foreground.

00:56:25.530 --> 00:56:31.190
Well, if you install a Global Event Monitor and
you look for just the mouseDown you'll be notified

00:56:31.190 --> 00:56:38.599
when that occurs outside of your application you can
close your window, you can let your application go

00:56:38.599 --> 00:56:45.480
into background, turn off your Event Monitor and it's a
nice way of solving the problem without too much overhead.

00:56:45.480 --> 00:56:50.500
And you have the completion block, the handler block in
the Event Monitor so it's nice and localized right there

00:56:50.500 --> 00:56:56.030
where you need it and you don't have some
custom subclass of NSApplication just

00:56:56.030 --> 00:56:59.010
to do this little thing, so it'll
keep your code nice and clean.

00:56:59.010 --> 00:57:03.540
[ Background noise ]

00:57:03.539 --> 00:57:05.219
>> Raleigh: So we've looked at a
whole bunch of different stuff.

00:57:05.219 --> 00:57:06.169
We've looked at Event Routing.

00:57:06.170 --> 00:57:10.659
We've looked at how you can come in and you can change
the way that events are routed through the system

00:57:10.659 --> 00:57:13.509
and we've looked at Multi-Touch and Gestures.

00:57:13.510 --> 00:57:17.520
We have the TargetGallery and the
LightTable demos that I've done.

00:57:17.519 --> 00:57:21.130
Their code is out there you can go and
get them from the Attendee website,

00:57:21.130 --> 00:57:22.950
download them, play with them, check them out.

00:57:22.949 --> 00:57:29.759
And here are the links that I promised earlier for all
the different search fields that I had shown earlier.

00:57:29.760 --> 00:57:33.940
I'll keep this slide up for a few seconds
for anybody that wants to attempt to try

00:57:33.940 --> 00:57:39.090
and copy down that long link, and here's some more.

00:57:39.090 --> 00:57:44.760
And as always please go ahead and take
a look at the Cocoa Release Notes.

00:57:44.760 --> 00:57:51.770
You can get to those from the documentation
right out of Xcode you can go and look at them.

00:57:51.769 --> 00:57:52.960
Lots of good information in there.
WEBVTT

00:00:15.490 --> 00:00:19.899
>> Good afternoon, my name is James Dempsey.

00:00:19.899 --> 00:00:26.329
I am an engineer in the Cocoa Frameworks Team
and I focus on application accessibility.

00:00:26.329 --> 00:00:30.699
So wow, what a week, I have had a tremendous week.

00:00:30.699 --> 00:00:35.759
Just by show of applause, what kind
of week have you had here at WWC 2009?

00:00:35.759 --> 00:00:38.009
[ Applause ]

00:00:38.009 --> 00:00:43.789
And just 5 days of tons and tons of
information and it is 2 o'clock on Friday

00:00:43.789 --> 00:00:49.179
and you are all here, tell me more
things, fill my brain more.

00:00:49.179 --> 00:00:53.189
That is a long plane ride home, I need more to think about.

00:00:53.189 --> 00:00:58.030
So excellent, thank you for coming
out to Advanced Accessibility.

00:00:58.030 --> 00:01:07.819
So what are we going to do today, first this is marked
as an expert or an advanced session, so as I am talking,

00:01:07.819 --> 00:01:14.409
I am assuming that you have some familiarity
with application accessibility on Mac OS X,

00:01:14.409 --> 00:01:18.390
things like the accessibility hierarchy and UI elements,

00:01:18.390 --> 00:01:25.469
tools like accessibility inspector
and the Voiceover feature on Mac OS X.

00:01:25.469 --> 00:01:28.640
Let's talk about what we are going to talk about.

00:01:28.640 --> 00:01:35.799
So first, we are going to walk through some of the larger
things that are new in Snow Leopard, things we have added.

00:01:35.799 --> 00:01:42.759
Then we are going to do a very brief, technical review
of application accessibility, because it is hard to talk

00:01:42.760 --> 00:01:47.980
about advanced things if the conceptual model that
we have in our head doesn't quite match reality,

00:01:47.980 --> 00:01:56.120
and then we are going to spend the bulk of this session
on making or talking about making custom views accessible.

00:01:56.120 --> 00:02:04.469
And for our example, we are going to take the venerable
Cocoa sample application Sketch and we are going

00:02:04.469 --> 00:02:11.379
to make the graphics view in Sketch
accessible using some new accessibility roles

00:02:11.379 --> 00:02:14.259
and attributes that we have added in Snow Leopard.

00:02:14.259 --> 00:02:21.280
It is a very nice example in that it lets us focus on some
design issues, some of which I don't think we have covered

00:02:21.280 --> 00:02:29.009
in previous WWDC sessions, and walk through a
recommended process, kind of step by step how do we tend

00:02:29.009 --> 00:02:35.349
to make views accessible at Apple, and finally we
will talk a little bit about some trouble shooting.

00:02:36.580 --> 00:02:39.700
So what is new in Snow Leopard?

00:02:39.699 --> 00:02:49.699
One of the things we have added in Snow Leopard are new
sets or kind of a couple suites of new accessibility roles

00:02:49.699 --> 00:02:58.729
and sub-roles, very much focused on the things that you
might find, well one particularly on the web or office style

00:02:58.729 --> 00:03:08.399
or applications, like spreadsheets or presentations
or even the page layout portions of a word processor.

00:03:08.400 --> 00:03:14.159
And so we have added support for cell
based tables, there is a new AXCell role,

00:03:14.159 --> 00:03:18.710
and it is able to convey information
about things like column and row spans.

00:03:18.710 --> 00:03:25.670
We have added some additional parameterized attributes to
make it very simple for an assistive application to move

00:03:25.669 --> 00:03:31.030
through tables that are cell based without
necessarily having to read in everything to figure

00:03:31.030 --> 00:03:34.460
out the column and row spans and how to navigate.

00:03:34.460 --> 00:03:37.370
And some new cell related notifications and attributes,

00:03:37.370 --> 00:03:43.409
so you can find out when the selected
cells change and the like.

00:03:43.409 --> 00:03:49.319
These are in use, actually, you
can see them in action in iWork 09.

00:03:49.319 --> 00:03:56.189
They are also present in the latest
version of Safari and WebKit.

00:03:56.189 --> 00:04:06.590
And then layout areas, these attributes and roles are
designed for use in any case where you have a canvas

00:04:06.590 --> 00:04:10.659
like area, a page layout area,
anytime you have those rectangles

00:04:10.659 --> 00:04:15.780
with the resizing handles, and you
can change the layout of things.

00:04:15.780 --> 00:04:20.470
That is where this set of roles and
attributes is designed to be used.

00:04:20.470 --> 00:04:26.460
Now that is exactly what we are going to be using
to make Sketch accessible, so I won't dwell on that,

00:04:26.459 --> 00:04:29.339
you will see more details when we get to Sketch.

00:04:29.339 --> 00:04:37.739
And then we have also added some roles for level indicators
and the various types of level indicators and content lists.

00:04:37.740 --> 00:04:43.970
And those are roles for opposed to user
interface that you might interact with as a list,

00:04:43.970 --> 00:04:50.750
like maybe a single column table, a content list
is more if you had a bulleted list on a webpage.

00:04:50.750 --> 00:04:56.639
It is not something that is a control that the user can
necessarily interact with, but we still want to call

00:04:56.639 --> 00:04:59.889
out that additional structure in the content.

00:04:59.889 --> 00:05:03.879
We have also added some new functionality in Snow Leopard.

00:05:03.879 --> 00:05:13.310
The first is NSImage accessibility descriptions,
where you can very easily take an NSImage

00:05:13.310 --> 00:05:17.730
and just set the accessibility
description string on the image itself.

00:05:17.730 --> 00:05:27.100
When that image gets used in a button cell or
an image cell or a segmented control segment,

00:05:27.100 --> 00:05:31.650
Cocoa will automatically pick up that
accessibility description and report it for you.

00:05:31.649 --> 00:05:36.000
This was talked about in greater detail
in the session earlier this week.

00:05:36.000 --> 00:05:43.620
We have added support to NSMenu items can
now support-overridden string attributes,

00:05:43.620 --> 00:05:52.189
so if your menus happen to be just a graphic with no
text, it is very simple now to add a description to those.

00:05:52.189 --> 00:05:59.810
We have added-- or I should say we have exposed three
methods in Snow Leopard that are optional methods

00:05:59.810 --> 00:06:10.300
in the accessibility protocol, and these all deal
with attributes of an object that are array attributes

00:06:10.300 --> 00:06:13.000
that are array attributes that return many items.

00:06:13.000 --> 00:06:18.449
Of course in our accessibility hierarchy,
the most important of those is AXChildren.

00:06:18.449 --> 00:06:32.089
And by default when an accessibility client asks us for
the count of one of these attributes or for a sub-set

00:06:32.089 --> 00:06:38.589
of these attributes or sub-range of these attributes,
by default, AppKit will get the list of all of them

00:06:38.589 --> 00:06:41.739
and then perform an array operation on them.

00:06:41.740 --> 00:06:47.670
Now sometimes, especially when you have many
children, you may have a better way of doing that,

00:06:47.670 --> 00:06:54.270
where you don't have to necessarily create every
single accessibility object to return the right answer.

00:06:54.269 --> 00:07:00.279
If that is the case in your code, then
this is when you would use these methods.

00:07:00.279 --> 00:07:08.979
The other nice thing is that these methods actually will
work all the way back to, no not even Panther, Jaguar.

00:07:08.980 --> 00:07:13.680
So implementing them today for
Snow Leopard, you will still get

00:07:13.680 --> 00:07:18.000
that performance benefit even back
on previous versions of Mac OS X.

00:07:18.000 --> 00:07:25.189
And there are many more kinds of smaller changes
or improvements that we have made in Snow Leopard

00:07:25.189 --> 00:07:29.649
and they are noted in the AppKit release notes for 10-6.

00:07:29.649 --> 00:07:38.819
OK that said, let's do a brief talk about review, the
architecture of application accessibility on the Mac.

00:07:38.819 --> 00:07:48.120
It is a client server architecture essentially, now we
have three applications running, an application or process

00:07:48.120 --> 00:07:57.280
like Voiceover launches and it uses accessibility
client APIs, public APIs on Mac OS X called AX APIs

00:07:57.279 --> 00:08:03.619
that is the prefix that they use, and it begins
sending accessibility request to your process.

00:08:03.620 --> 00:08:10.699
And your process responds to them, and is
basically a nice little client server set up.

00:08:10.699 --> 00:08:14.599
But what is every application on the system vending?

00:08:14.600 --> 00:08:24.810
Well apps vend a hierarchy of UI elements and
so each node in the tree represents some piece

00:08:24.810 --> 00:08:27.379
of the user interface in your application.

00:08:27.379 --> 00:08:33.539
Note that the root of the tree is the application
itself, and that is the exception to the rule.

00:08:33.539 --> 00:08:38.240
It is not a visual thing, you can't see
the application except for that root,

00:08:38.240 --> 00:08:43.720
every other node in the tree represents
some visual element in your applications,

00:08:43.720 --> 00:08:47.920
something that is taking up some
degree of screen real estate.

00:08:47.919 --> 00:08:58.069
Now each of these nodes is very powerful in that an
accessibility client can ask for information about each

00:08:58.070 --> 00:09:04.980
of these UI elements through attributes,
and in this case, one very important

00:09:04.980 --> 00:09:08.539
and useful attribute is the role attribute.

00:09:08.539 --> 00:09:13.919
And underneath each of these element reps, which is
the lightweight representation on the client side,

00:09:13.919 --> 00:09:19.199
you will note something like AXApplication,
AXWindow, the role is how you can tell

00:09:19.200 --> 00:09:23.290
or how an accessibility client can
tell one UI element from another.

00:09:23.289 --> 00:09:29.829
And that is an example of an attribute that
can be requested by a client about an element.

00:09:29.830 --> 00:09:37.290
There are also actions, so for instance in accessibility
client could tell that AXButton element to press,

00:09:37.289 --> 00:09:41.839
and that request would come in and the button
would actually press in the application itself.

00:09:41.840 --> 00:09:50.230
And then finally, an accessibility client can register to
receive notifications about any particular node in that tree

00:09:50.230 --> 00:09:56.350
to find out things like when the value of a text
field changes, or when a window moves or resizes.

00:09:56.350 --> 00:10:05.379
Now how does that information get
handed back to the accessibility client?

00:10:05.379 --> 00:10:11.939
Every node in the tree that was reported to an
accessibility client has a one-to-one mapping

00:10:11.940 --> 00:10:15.880
to some object in a Cocoa application.

00:10:15.879 --> 00:10:21.450
These are all kind of possibly
self-evident the NSApplication.

00:10:21.450 --> 00:10:25.259
There is that NSApplication singleton instance in your app.

00:10:25.259 --> 00:10:28.529
Every AXWindow is backed by an NSWindow.

00:10:28.529 --> 00:10:37.399
And when a request comes in about that node in the tree that
request gets routed to an object in your Cocoa application,

00:10:37.399 --> 00:10:41.500
and a method is called to ask that object for information.

00:10:41.500 --> 00:10:48.000
And we have batched all those methods up into
a protocol called the NSAccessibility protocol.

00:10:48.000 --> 00:10:56.860
So again, very client-servery, the client makes a request,
but the request gets routed to the right Cocoa object,

00:10:56.860 --> 00:11:02.340
which implements a set of methods and returns from
that method the right answer for that request.

00:11:02.340 --> 00:11:07.399
Now let's just take a brief look at that
protocol, we will be seeing it in code much later,

00:11:07.399 --> 00:11:13.019
but there is a set of methods for
getting and setting attributed values.

00:11:13.019 --> 00:11:22.899
We also have some fancier attributes, which take a parameter
for things like text cell based tables and lay out areas.

00:11:22.899 --> 00:11:26.409
Sometimes you want to have the
client provide some information

00:11:26.409 --> 00:11:31.779
to get a more specific answer for performing actions.

00:11:31.779 --> 00:11:37.909
And then in addition, although it is not part
of the protocol, the convenience function

00:11:37.909 --> 00:11:45.309
for posting a notification, so your custom Cocoa
class can post an accessibility notification.

00:11:45.309 --> 00:11:51.289
Now how does the client get a hold
of this information in your app?

00:11:51.289 --> 00:11:58.649
Well it can do so top down, the client can just
say, Hey for this process, give me the root element.

00:11:58.649 --> 00:12:05.819
And that NSApplication will get sent back, well a
representation of that application object will get set back

00:12:05.820 --> 00:12:14.220
as a UI element ref and then from there a very
useful attribute is the AXChildren's attribute.

00:12:14.220 --> 00:12:22.259
And so when that accessibility client ask for the
children, a request will come into NSApplication,

00:12:22.259 --> 00:12:29.480
call the right method and NSApplication will send back an
array of Cocoa objects, in this case probably an NSMenu

00:12:29.480 --> 00:12:36.670
that is the top level menu and a bunch of
NSWindows that are the children of the application.

00:12:36.669 --> 00:12:43.309
And calling this recursively then, an
accessibility client is able to create a whole tree

00:12:43.309 --> 00:12:46.929
that maps to your application's user interface.

00:12:46.929 --> 00:12:54.549
Now in addition to top down, a client can also
go bottom up, and they can do so by hit testing,

00:12:54.549 --> 00:12:59.370
handing in a point on the screen and asking
the app, Tell me what UI element is there.

00:12:59.370 --> 00:13:08.320
And Cocoa will do the hit test, identify the
object and return a UI element ref for that object

00:13:08.320 --> 00:13:16.350
and then using the AXParent attribute, the accessibility
client is able to navigate back up the tree.

00:13:16.350 --> 00:13:24.190
Now the reason I am spending so much time on this hierarchy
is that those two attributes, AXChildren and AXParent

00:13:24.190 --> 00:13:32.530
in getting that hierarchy correct is really one of the
central tasks in making your custom view accessible.

00:13:32.529 --> 00:13:42.679
Now to assist in that hit testing, there is another
method accessibility hit test in the protocol,

00:13:42.679 --> 00:13:46.929
we also can tell in the assistive
app what is the focused UI element,

00:13:46.929 --> 00:13:50.819
who has the keyboard focus, so a method to help with that.

00:13:50.820 --> 00:13:57.020
And then a method to talk about whether an
object is ignored by accessibility or not.

00:13:57.019 --> 00:13:59.490
And that bears mentioning for a moment.

00:13:59.490 --> 00:14:08.930
So you may notice that in Cocoa, we actually have a much
more complicated view hierarchy, even in the simple window

00:14:08.929 --> 00:14:15.669
with one button in it example, than we are reporting
to accessibility that window has a private frame view

00:14:15.669 --> 00:14:21.289
and a public content view and an NSButton
view or control which has a button cell,

00:14:21.289 --> 00:14:24.949
and yet we are only reporting three things to accessibility.

00:14:24.950 --> 00:14:32.629
And that is mainly because just as a user looking at the
screen would say there is a window with a button in it.

00:14:32.629 --> 00:14:36.779
That is pretty much the structure we
would want to report to accessibility.

00:14:36.779 --> 00:14:45.970
And so to allow for this reduction of complexity,
any piece of that hierarchy, that view hierarchy,

00:14:45.970 --> 00:14:51.160
actually that piece of any Cocoa object
could be ignored by accessibility.

00:14:51.159 --> 00:14:58.360
Ignored is not the same as hidden, when you hide
something, it and all its sub-views disappear from view.

00:14:58.360 --> 00:15:03.210
When you ignore something that
is telling accessibility to pass

00:15:03.210 --> 00:15:09.129
through to the first un-ignored
child or set of un-ignored children.

00:15:09.129 --> 00:15:15.629
And ignored is very important, it is the first topic
thing we are going to look at in Sketch, because NSView,

00:15:15.629 --> 00:15:22.200
the class itself, if you put one into a window,
it is not terribly interesting to a user.

00:15:22.200 --> 00:15:26.870
It draws its little grey background and that is about it.

00:15:26.870 --> 00:15:35.840
And so by default NSViews, the NSView class is ignored
by accessibility, when you create a custom view,

00:15:35.840 --> 00:15:39.710
you need to make it un-ignored by accessibility.

00:15:39.710 --> 00:15:50.820
And so if we take a look at Sketch as it existed for a long
time now, if we look at it from an accessibility standpoint,

00:15:50.820 --> 00:15:53.890
there is an application, Sketch app, has a window.

00:15:53.889 --> 00:15:58.189
There is actually a scroll view that
reports itself to accessibility.

00:15:58.190 --> 00:16:03.650
It is un-ignored by default, but then
inside that scroll view, there is nothing.

00:16:03.649 --> 00:16:09.819
It is blank, because that custom
SKT graphics view is ignored.

00:16:09.820 --> 00:16:13.129
So let's jump off the bat and let's address that,

00:16:13.129 --> 00:16:18.759
so the first step is making our
custom view show up in accessibility.

00:16:18.759 --> 00:16:24.019
So let's head over to the demo.

00:16:24.019 --> 00:16:31.019
All right, and first let's just build and run.

00:16:36.039 --> 00:16:49.360
And I will open up a sample document here, and looking at
this with accessibility in Inspector, you will notice that--

00:16:49.360 --> 00:16:56.060
OK we see this window is reporting
itself, but if we move the mouse in here,

00:16:56.059 --> 00:17:00.739
it reports there is a scroll area, but nothing inside of it.

00:17:00.740 --> 00:17:07.140
None of the graphics area shows
up, none of these shapes show up,

00:17:07.140 --> 00:17:11.420
it's pretty much from an accessibility
standpoint, just a dead area.

00:17:11.420 --> 00:17:13.360
We don't know what is going on in there.

00:17:13.359 --> 00:17:21.889
The first step is, to first make it
un-ignored, so let's quit and do that.

00:17:23.200 --> 00:17:30.000
Again it is the SKT graphic view, which is
the view that is drawing that graphic view

00:17:30.000 --> 00:17:36.349
and you will notice it is just a straight
sub-class of NSView, so it inherits the ignoredness.

00:17:36.349 --> 00:17:43.259
What I have done is added a category
on SKT graphic view for accessibility,

00:17:43.259 --> 00:17:50.640
and very commonly when you are doing accessibility, you
will put all of the accessibility methods and overrides

00:17:50.640 --> 00:17:55.690
in a category just so you have them all in one spot.

00:17:55.690 --> 00:18:03.049
And all I am going to do very simply is
override accessibilityIsIgnored to return No.

00:18:03.049 --> 00:18:04.230
We will build and run.

00:18:04.230 --> 00:18:09.210
I hit the wrong thing there.

00:18:09.210 --> 00:18:18.259
And I do that, now when I mouse over, there
is something inside of that scroll area.

00:18:18.259 --> 00:18:23.029
It is unknown, but there is something there.

00:18:23.029 --> 00:18:23.990
That is progress.

00:18:23.990 --> 00:18:26.620
Why is it unknown?

00:18:26.619 --> 00:18:29.529
Well NSView has no idea what.

00:18:29.529 --> 00:18:36.740
It is going to be sub-classed to be turned into-- so
all it knows at this point is I am a view, here I am,

00:18:36.740 --> 00:18:38.609
but I don't know what I am supposed to be doing.

00:18:38.609 --> 00:18:45.719
We are going to set the proper role
next, because it is pretty darn easy.

00:18:45.720 --> 00:18:51.140
So let's quit, I will hide that.

00:18:51.140 --> 00:18:58.259
So again, we are already getting some information
from NSView, we are already getting some role,

00:18:58.259 --> 00:19:01.960
we just want to override the existing information.

00:19:01.960 --> 00:19:07.309
And so we are going to override the method,
accessibilityAttributeValue, which is actually--

00:19:07.309 --> 00:19:14.240
where a great deal of your accessibility customization
happens in overrides or in implementations of this method.

00:19:14.240 --> 00:19:23.559
And if we are asked for our role attributes, we are
going to return the layout area role that is the new role

00:19:23.559 --> 00:19:26.589
that covers these areas where people do layouts.

00:19:26.589 --> 00:19:32.349
And if they are asking about some other
value or some other attribute value,

00:19:32.349 --> 00:19:36.449
we will just let the super-class NSView handle that.

00:19:36.450 --> 00:19:38.529
So let's give that a run.

00:19:38.529 --> 00:19:55.180
I will get rid of that, and now you notice our role
is reporting itself correctly, and in addition,

00:19:55.180 --> 00:19:59.690
the role description has changed
from unknown to layout area.

00:19:59.690 --> 00:20:07.600
That is because NWViews implementation is dynamic
and is going to ask itself for its own role

00:20:07.599 --> 00:20:13.669
and then provide the correct system-provided
localized string for the role description.

00:20:13.670 --> 00:20:19.330
I would like to point out that one other thing is that,
we wrote what one line of code, two lines of code,

00:20:19.329 --> 00:20:24.139
yet we are getting a lot of accessibility
information that is already implemented in NSView.

00:20:24.140 --> 00:20:27.790
You will notice that it already knows who our parent is.

00:20:27.789 --> 00:20:30.829
It already knows our window top-level element.

00:20:30.829 --> 00:20:39.069
If we focus on it, it is giving us back the correct
highlighted rectangle for its size and position.

00:20:39.069 --> 00:20:44.909
So we get a lot free from NSView, we
just have to tweak a little in this case.

00:20:44.910 --> 00:20:52.090
So that is a start, let's jump back to slides
and talk about making this more accessible.

00:20:52.089 --> 00:21:04.309
Let's go. So making custom views accessible--
that really is the meat and potatoes

00:21:04.309 --> 00:21:08.029
of doing accessibility in your applications.

00:21:08.029 --> 00:21:21.109
In the talk earlier this week, there are a lot of
relatively easy things to do to improve the accessibility

00:21:21.109 --> 00:21:27.339
that have a giant effect in your application,
like adding descriptions to images and making sure

00:21:27.339 --> 00:21:33.449
that text fields are linked up to say their
title UI element to give a lot of context

00:21:33.450 --> 00:21:35.920
to what is going on in the user interface.

00:21:35.920 --> 00:21:38.840
And those are relatively simple and have a great affect.

00:21:38.839 --> 00:21:44.720
But almost every application has some meat and
potatoes view, some reason why you wrote the app

00:21:44.720 --> 00:21:49.329
in the first place and very often, those are custom views.

00:21:49.329 --> 00:21:52.970
Sketch is a good example, the reason
we wrote the app was to have this place

00:21:52.970 --> 00:21:56.819
where we could create and manipulate graphics.

00:21:56.819 --> 00:22:01.849
Although these views across many
applications are very different,

00:22:01.849 --> 00:22:08.230
the process that we go through to make a view
accessible is actually very similar every single time.

00:22:08.230 --> 00:22:11.009
It really breaks down to three different phases.

00:22:11.009 --> 00:22:15.470
There is a design phase, where we
figure out the basic structure.

00:22:15.470 --> 00:22:20.140
Before we start doing things, we have to figure
out, well, What do we actually want this to look

00:22:20.140 --> 00:22:25.740
like to accessibility? What hierarchy
do we want to be reporting?

00:22:25.740 --> 00:22:27.759
What nodes should be in the tree?

00:22:27.759 --> 00:22:30.849
and then, What should the roles be of those nodes?

00:22:30.849 --> 00:22:37.419
And then once we figure out what we are actually trying to
provide to accessibility, the next step is taking a look

00:22:37.420 --> 00:22:44.000
at how we want to provide, take a look at the
objects and the object hierarchy that we are using

00:22:44.000 --> 00:22:47.960
in our application, and mapping between the two.

00:22:47.960 --> 00:22:49.610
What views need to be ignored?

00:22:49.609 --> 00:22:53.419
What views do we need to do a little work in?

00:22:53.420 --> 00:23:02.330
Once we get that basic structure and designs,
we should build it out and phase 2 for me is,

00:23:02.329 --> 00:23:08.609
get this all able to be inspected and
working in accessibility Inspector.

00:23:08.609 --> 00:23:13.490
We want to have the parent and child
relationship of that tree working correctly.

00:23:13.490 --> 00:23:19.650
We want to be able to hit test with the mouse,
and we also want the size and position working.

00:23:19.650 --> 00:23:27.110
Now to me this second phase is really
the-- I don't even know what the word is,

00:23:27.109 --> 00:23:30.750
it is the crux of making your app accessible.

00:23:30.750 --> 00:23:33.710
It is the crest of the hill, if you will.

00:23:33.710 --> 00:23:39.610
And then the last phase, once you
have that basic structure in place,

00:23:39.609 --> 00:23:42.919
it really is a matter of filling in the remaining pieces.

00:23:42.920 --> 00:23:51.710
We have gotten the fundamental things like the role and
the hierarchy and the geometry of each element done.

00:23:51.710 --> 00:23:58.900
Now we need to report whether it is enabled or
not, or we need to report a description on it.

00:23:58.900 --> 00:24:05.440
We need to implement actions, focus testing and
any notifications that might need to be sent.

00:24:05.440 --> 00:24:10.400
Now this afternoon, we are going to
be focusing on phase 1 and phase 2,

00:24:10.400 --> 00:24:14.810
but the Sketch plus accessibility sample code associated

00:24:14.809 --> 00:24:19.929
with this session will give you sample
code that does all three phases.

00:24:22.519 --> 00:24:29.339
So part of determining what you want in that
hierarchy is determining roles and sub-roles

00:24:29.339 --> 00:24:33.839
and as we saw just a moment ago, it is
programmatically simple to change a role,

00:24:33.839 --> 00:24:37.869
you just return a different string constant.

00:24:37.869 --> 00:24:42.179
The difficulty sometimes or the thing
that takes more time is figuring

00:24:42.180 --> 00:24:46.259
out what is the appropriate role for this situation.

00:24:46.259 --> 00:24:54.109
Note that what role you picked very much drives all the
other attributes, actions and notifications that are needed

00:24:54.109 --> 00:24:59.019
for that element, because all of
those are very role specific.

00:24:59.019 --> 00:25:02.160
Now sometimes picking roles is pretty straightforward.

00:25:02.160 --> 00:25:09.660
There is a very obvious mapping between roles
and sub roles-- or to roles and your UI elements.

00:25:09.660 --> 00:25:16.670
In this case, we have an image, we have some static text,
we have a button and we have very straightforward mappings

00:25:16.670 --> 00:25:21.320
to existing roles, but sometimes
it is not quite so straightforward,

00:25:21.319 --> 00:25:25.240
so here is a control, a custom back ball control.

00:25:25.240 --> 00:25:29.480
This is a little movie, we will see it in action.

00:25:29.480 --> 00:25:39.099
This is a piece of sample code you can download as
well, and this track ball has three degrees of freedom,

00:25:39.099 --> 00:25:51.609
and we don't have an AXMarble cool track ball
role, and in fact very often as people innovate

00:25:51.609 --> 00:25:59.669
with their user interfaces and come up with cool new
little widgets, there isn't an exact role that matches.

00:25:59.670 --> 00:26:03.180
So what do we do in that case?

00:26:03.180 --> 00:26:10.560
Well if there is not a clear mapping, we would like you very
much to take a look at the existing roles and find some way

00:26:10.559 --> 00:26:15.440
to expose the functionality of
that widget through accessibility.

00:26:15.440 --> 00:26:22.019
So in this case, we have three degrees of freedom, we
might make that whole thing a group with three sliders,

00:26:22.019 --> 00:26:28.440
with each slider maybe going through the
range of values for the X, Y and Z axes.

00:26:28.440 --> 00:26:34.240
Again it doesn't map exactly to what
it looks like, but we wouldn't be able

00:26:34.240 --> 00:26:37.720
to provide that with the set of roles anyway.

00:26:37.720 --> 00:26:46.289
But at least a Voiceover user is able to get to that control
and manipulate it, and get through the same functionality

00:26:46.289 --> 00:26:50.409
or get the same functionality that
a sighted user would have.

00:26:50.410 --> 00:26:56.540
And in general as we talk about roles,
what do you do when there is an exact fit?

00:26:56.539 --> 00:27:02.889
Well again, don't let a perfect fit be
the enemy of implementing accessibility.

00:27:02.890 --> 00:27:09.290
The first thing is, Yes, you should try to
map the visual parts as best as possible.

00:27:09.289 --> 00:27:17.339
The reason for this is that very often a Voiceover
user is working in collaboration with a sighted user,

00:27:17.339 --> 00:27:22.750
and they are going to talk about this button
or that scroll area, or what have you,

00:27:22.750 --> 00:27:27.279
and having it all mapped visually
helps a lot in that collaboration.

00:27:27.279 --> 00:27:32.029
But when that is not possible, expose the functionality.

00:27:32.029 --> 00:27:40.119
The second thing is to ask, if you are making your
application accessible, I highly recommend that you sign

00:27:40.119 --> 00:27:47.189
up for the accessibility-gov mailing
list and if you hit one of these issues

00:27:47.190 --> 00:27:50.580
where you are not sure how it should
be made accessible, ask,

00:27:50.579 --> 00:27:56.789
because often it is the first time
you are making something accessible.

00:27:56.789 --> 00:28:01.950
But the folks on the list have done this numerous times
and might be able to help you avoid some pitfalls.

00:28:01.950 --> 00:28:08.360
And then finally, especially if you feel this is a common
UI element, there really should be a role for this,

00:28:08.359 --> 00:28:13.779
file an enhancement request in bugreporter
and please include a screen shot,

00:28:13.779 --> 00:28:19.609
because occasionally we will get a request and we just have
no idea what kind of UI element you are trying to describe.

00:28:19.609 --> 00:28:29.219
There is one other thing to note about roles,
and that is using an alternate role description.

00:28:29.220 --> 00:28:38.059
So the role is how an app, an assisted app like Voiceover
finds out programmatically what kind of element this is,

00:28:38.059 --> 00:28:47.490
but the role description is a localized string that
is read by Voiceover to the user, and so occasionally,

00:28:47.490 --> 00:28:53.390
very sparingly, you might want to use an
alternate role description on an element.

00:28:53.390 --> 00:28:59.730
Now the kind of canonical example here is tabs
in a tab view behave a lot like radio buttons.

00:28:59.730 --> 00:29:05.769
You select one, you can only have one selected at
a time and you select one, another one de-selects.

00:29:05.769 --> 00:29:11.519
And so for accessibility, these are
all reported as AXRadioButton Elements.

00:29:11.519 --> 00:29:18.900
That is their role; however, in a collaborative environment,
you have a Voiceover user talking about radio buttons,

00:29:18.900 --> 00:29:25.050
and you have a sighted user collaborating talking
about tabs and it gets a little confusing.

00:29:25.049 --> 00:29:35.710
In that case and in Snow Leopard, tabs report
their role description as tabs, not radio buttons.

00:29:35.710 --> 00:29:43.660
But why should we do it sparingly, well every single
time a Voiceover user encounters a new role description.

00:29:43.660 --> 00:29:50.630
They need to work out and figure out how do they
interact with this new user interface element,

00:29:50.630 --> 00:29:57.540
and certainly if there are thousands upon thousands of role
descriptions ,and every time you move that Voiceover cursor,

00:29:57.539 --> 00:30:01.500
it is something you have never heard of before,
and you have no idea how to use this thing

00:30:01.500 --> 00:30:05.039
that is going to be a very frustrating experience.

00:30:05.039 --> 00:30:13.149
So the smaller the number of roles that are
described, the easier it is to learn the system.

00:30:13.150 --> 00:30:17.540
But again there are these cases like this
tab case, where it makes a lot of sense

00:30:17.539 --> 00:30:20.329
to provide an alternate role description.

00:30:20.329 --> 00:30:23.759
OK that said, what are we going to do in Sketch?

00:30:23.759 --> 00:30:30.039
Well Sketch works out really nicely with the
new roles we have defined in Snow Leopard.

00:30:30.039 --> 00:30:38.240
The main view area will be an AXLayoutArea, each
shape is an AXLayoutItem, an item in that area

00:30:38.240 --> 00:30:46.269
and then even the handles will be represented,
because they are visual elements, as AXHandle,

00:30:46.269 --> 00:30:51.639
the third new role that we have
added in this layout area suite.

00:30:51.640 --> 00:30:57.820
So we know how we want that hierarchy to
appear, now, How do we get that to happen?

00:30:57.819 --> 00:31:05.919
Well again, we need to do this mapping between our object
hierarchy or the objects that are actually in our Cocoa app

00:31:05.920 --> 00:31:13.120
and which ones of those are going to be the backing
in essence for the nodes in the accessibility tree

00:31:13.119 --> 00:31:16.589
that we are reporting to an accessibility client.

00:31:16.589 --> 00:31:21.259
So take a look at your object hierarchy,
some objects may be ignored.

00:31:21.259 --> 00:31:29.799
Sometimes like in this view case, it already implements an
accessibility, so we just may need to override some methods.

00:31:29.799 --> 00:31:34.289
And in some cases, we might have objects
that are just inherent from NSObject

00:31:34.289 --> 00:31:37.170
and need to implement the entire protocol.

00:31:37.170 --> 00:31:43.750
It is maybe 10, 12 methods, not that much, and
sometimes we even have elements that we want to report

00:31:43.750 --> 00:31:50.410
that we currently don't even have an analogous object
in our Cocoa application, and we are going to look

00:31:50.410 --> 00:31:58.920
at two different cases of this, using a faux UI element,
where we just make up an element out of thin air to respond

00:31:58.920 --> 00:32:05.550
to these requests and a proxy element where
we have an object that kind of does the job.

00:32:05.549 --> 00:32:12.809
But for one reason or another, we can't use it so we will
create a little proxy that has a reference to that object

00:32:12.809 --> 00:32:18.740
that exists already in our app
to pull some information from it.

00:32:18.740 --> 00:32:23.299
So if we look at Sketch's hierarchy,
there is an SKT graphic view

00:32:23.299 --> 00:32:28.089
and then that graphic view has a
bunch of graphics, graphic objects.

00:32:28.089 --> 00:32:30.089
They each know how to draw themselves.

00:32:30.089 --> 00:32:33.159
They each know their own bounds, so OK, great.

00:32:33.160 --> 00:32:39.650
We will have that view report all of those graphics as
their children, those graphics will be a great place

00:32:39.650 --> 00:32:47.960
to implement an NSAccessibility or so I thought,
when I first sat down to make Sketch accessible,

00:32:47.960 --> 00:32:53.930
but we do have a bit of an interesting design challenge.

00:32:53.930 --> 00:33:04.670
It would be a good word for it, so as is often the
case in drawing applications, what is the word,

00:33:04.670 --> 00:33:12.509
usually or very often in drawing applications that we don't
necessarily see in a lot of apps is that the graphic object

00:33:12.509 --> 00:33:17.640
in this case, it is the model object
that gets written out to the document,

00:33:17.640 --> 00:33:21.050
but it also happens to know how to draw itself in a view.

00:33:21.049 --> 00:33:26.389
In a drawing application, very often
the model is also used in the view,

00:33:26.390 --> 00:33:30.570
because it honestly makes a lot of sense to do so.

00:33:30.569 --> 00:33:40.069
But that gives us an accessibility wrinkle, because
as Sketch exists today, it is a document-based app,

00:33:40.069 --> 00:33:46.409
the document holds on to the model objects, the graphics,
it also has a window controller that has its window,

00:33:46.410 --> 00:33:53.740
in the window lives in a graphic view and the graphic view
through bindings has a reference back to the graphics.

00:33:53.740 --> 00:34:02.190
That is all well and good, and so we could potentially--
that graphic needs to report its accessibility parent--

00:34:02.190 --> 00:34:06.090
can only have one accessibility
parent, and so that graphic--

00:34:06.089 --> 00:34:10.279
OK, it will report that graphic view as its parent.

00:34:10.280 --> 00:34:17.550
Everything seems just perfectly fine, until I looked
at the little to-do list on the Sketch that we may want

00:34:17.550 --> 00:34:21.850
to add additional views in another window on the model.

00:34:21.849 --> 00:34:27.259
And you have certainly seen this in other drawing
applications where you have a document window open.

00:34:27.260 --> 00:34:30.360
Then you open a second window on the same document.

00:34:30.360 --> 00:34:35.180
Maybe zoom into 800 percent so you can
do some fine tune work in one window,

00:34:35.179 --> 00:34:38.809
while the other window is showing
the results at 100 percent.

00:34:38.809 --> 00:34:43.079
And certainly that would be fairly
straightforward to do in Sketch, in which case,

00:34:43.079 --> 00:34:48.909
we would end up with a second window controller
with a second window with a second graphic view,

00:34:48.909 --> 00:34:56.679
but also using the same underlying graphic objects, the
same model, and when we would report it to accessibility

00:34:56.679 --> 00:35:02.469
that one graphic object now has two accessibility parents.

00:35:02.469 --> 00:35:10.109
Well that doesn't quite work in a tree where you only
have one parent, so were we to go down this path,

00:35:10.110 --> 00:35:15.050
where we would extend Sketch, we would
hit a bit of a bump, a bit of a bump.

00:35:15.050 --> 00:35:16.220
So what to do?

00:35:16.219 --> 00:35:21.250
We are going to introduce a little
accessibility proxy object.

00:35:21.250 --> 00:35:26.900
The idea here is that whenever we need
to return the children of a graphic view,

00:35:26.900 --> 00:35:34.340
we will make these little temporary objects, we will set
the graphic view as the parent, we will set the graphic

00:35:34.340 --> 00:35:38.510
so now this little proxy has a
reference to its accessibility parent.

00:35:38.510 --> 00:35:44.930
And it has a reference to the actual graphic that
it represents, so we can ask it for all sorts

00:35:44.929 --> 00:35:48.730
of interesting information like its bounds for instance.

00:35:48.730 --> 00:35:55.750
Each of these proxies has a separate parent, even though
it refers back to the same underlying model object.

00:35:55.750 --> 00:36:02.369
We are good to go, so from our original
design decision we now have a slight change.

00:36:02.369 --> 00:36:11.569
We are going to use a graphic proxy object, it
also will inherit from NSObject and so we will need

00:36:11.570 --> 00:36:16.620
to implement the 12 methods of the accessibility protocol.

00:36:16.619 --> 00:36:18.940
Let's take a look at doing that now.

00:36:18.940 --> 00:36:27.490
So in this demo, we are going to get those
shapes reporting themselves and we are going

00:36:27.489 --> 00:36:34.599
to do essentially the phase 2 portion, getting the
hierarchy working, hit testing working and geometry working,

00:36:34.599 --> 00:36:40.909
size and position for all of the shapes of the layout area.

00:36:40.909 --> 00:36:49.299
Let's take a look at this in progress, so first let's
look at this proxy object, it is very straightforward.

00:36:49.300 --> 00:36:55.660
We have an object that holds onto the
accessibility parent and the backing graphic.

00:36:55.659 --> 00:37:03.230
We have some properties to get and set-- to read those
values and initF?, method, or actually a factory method

00:37:03.230 --> 00:37:10.900
that will take the graphic in the parent and give us back
one of these little temporary objects already auto-released.

00:37:10.900 --> 00:37:17.840
Let's take a look at the code behind that, again we are just
going to take the parent and the graphic and hold onto it,

00:37:17.840 --> 00:37:33.050
when dealloc, we will release them,
nothing to groundbreaking there and we want

00:37:33.050 --> 00:37:36.210
to make sure that accessibility is ignored as No.

00:37:36.210 --> 00:37:42.869
Here are the attributes that at least
for this portion, we are going to return.

00:37:42.869 --> 00:37:49.539
We are going to talk about the role parent,
the window and the geometry information,

00:37:49.539 --> 00:37:52.949
the rest we will get to in a future demo.

00:37:52.949 --> 00:38:01.269
And if we look at the attribute values as they are asked by
accessibility, we are a layout item, so we will return that.

00:38:01.269 --> 00:38:06.670
We use a convenience function, or it isn't
even a convenience-- you should use it--

00:38:06.670 --> 00:38:12.430
an accessibility role description, which
will take a role and an optional sub-role

00:38:12.429 --> 00:38:19.460
and return a localized string that
will be presented to the user.

00:38:19.460 --> 00:38:25.710
If they ask for our parent, we
return the parent object that we set.

00:38:25.710 --> 00:38:27.490
If they ask for What is our window?

00:38:27.489 --> 00:38:29.699
or What is our top level UI element?

00:38:29.699 --> 00:38:35.329
well we just ask our parent for that because it should
have the information or it will have the information.

00:38:35.329 --> 00:38:46.179
For our position, well that graphic that we are
holding onto knows its own bounds, but we also need,

00:38:46.179 --> 00:38:52.710
because when we report information to accessibility,
we don't report it in our own view coordinates,

00:38:52.710 --> 00:38:58.980
we have to do it in screen coordinates, so we
need whatever view is containing us in order

00:38:58.980 --> 00:39:03.010
to do the appropriate translation of coordinate spaces.

00:39:03.010 --> 00:39:10.730
So we get hold of our containing graphic view, and that
is simply a method that I have written above that goes

00:39:10.730 --> 00:39:14.800
up the hierarchy until it finds its first un-ignored view.

00:39:14.800 --> 00:39:21.769
We get our bounds, get our origin,
we check if we are flipped,

00:39:21.769 --> 00:39:25.550
and if so we need to adjust what corner we are sending back.

00:39:25.550 --> 00:39:31.289
But then essentially we are moving from local
to window coordinates and then from window

00:39:31.289 --> 00:39:37.710
to screen coordinates just using standard
Cocoa APIs for doing so, and then we return

00:39:37.710 --> 00:39:42.949
and NS value containing the point of our position.

00:39:42.949 --> 00:39:51.879
For size, it is even a little easier, we get
our containing graphic view, get our local size

00:39:51.880 --> 00:39:57.510
and then we move from our local size to the window size.

00:39:57.510 --> 00:40:03.460
The window coordinate space in terms of
size is always the same as the screen's,

00:40:03.460 --> 00:40:08.380
so we can take that size, wrap it in NSValue and return it.

00:40:08.380 --> 00:40:14.400
So again, the bounds information and the graphic is
already there in Sketch, we are just pulling it out,

00:40:14.400 --> 00:40:18.970
translating it to the right coordinate
space and sending it back for accessibility,

00:40:18.969 --> 00:40:23.449
and if somebody asks us for something
else, we just return nil.

00:40:23.449 --> 00:40:27.019
We don't have a super-class that
has implemented this method,

00:40:27.019 --> 00:40:34.679
if somebody wants to hit test, they will hand us in a point.

00:40:34.679 --> 00:40:37.399
Now hit testing with accessibility.

00:40:37.400 --> 00:40:43.740
If this method is called on your object, it has
been determined by one of your parents that Yes,

00:40:43.739 --> 00:40:50.649
this point is either within you or within one of your
descendents, so therefore at the very least at this case,

00:40:50.650 --> 00:40:55.519
if this method has been called, at
present, we don't have any children,

00:40:55.519 --> 00:40:59.170
we don't have any descendents, so it must be us.

00:40:59.170 --> 00:41:02.579
We would return self, but you have
noticed that I have wrapped it

00:41:02.579 --> 00:41:07.190
in this function NSAccessibility, un-ignored ancestor.

00:41:07.190 --> 00:41:13.320
If for some reason, somebody sub-classed
this class and made it accessibility ignored,

00:41:13.320 --> 00:41:16.390
we wouldn't want to return that to accessibility.

00:41:16.389 --> 00:41:22.629
What this function will do is, it will take-- it will return
yourself if you are un-ignored, but if you are ignored,

00:41:22.630 --> 00:41:29.780
it will walk up the hierarchy to find the first
un-ignored ancestor and return that instead.

00:41:29.780 --> 00:41:37.700
And then finally, we have put in stub methods
for the rest of the NSAccessibility protocol,

00:41:37.699 --> 00:41:41.529
in case those questions are asked
by an accessibility client.

00:41:41.530 --> 00:41:49.050
And the last thing I would like to point out is, whenever
we are making these temporary objects in accessibility,

00:41:49.050 --> 00:41:55.600
we will make them, we will use them and then let them
be auto-released, and then when a question comes in for

00:41:55.599 --> 00:41:58.719
that element again, we will make another object.

00:41:58.719 --> 00:42:05.369
However, to get back to the right spot,
we need to be sure that two objects

00:42:05.369 --> 00:42:14.139
that represent the same element respond
Yes to isEqual and hash the same.

00:42:14.139 --> 00:42:23.309
And so all I am doing here is ensuring
that we return Yes to isEqual in the case

00:42:23.309 --> 00:42:29.170
that we are the same object and that our hash is correct.

00:42:29.170 --> 00:42:37.920
OK? And finally, we have got that child object all set up,

00:42:37.920 --> 00:42:42.349
let's take a look at what we are doing
in the parent to return those children.

00:42:42.349 --> 00:42:50.659
So if we are asked for our children as the graphic
view, we will get ahold of all of our graphics,

00:42:50.659 --> 00:42:56.599
we will make an immutable array that we are going to stick
these proxies in, then we will run through all of them.

00:42:56.599 --> 00:43:01.389
I am going in reverse because I would
like to send them out in Z order rather

00:43:01.389 --> 00:43:05.170
than reverse Z order, which is how they are stored.

00:43:05.170 --> 00:43:09.740
And for each child, we will make one of these
little proxy objects, stuff in the graphics,

00:43:09.739 --> 00:43:13.959
stuff in ourselves as the parent,
return the array, return the array,

00:43:13.960 --> 00:43:18.309
and we have just reported all of
these little objects as our children.

00:43:18.309 --> 00:43:27.110
For hit testing, we want to hit test a shape.

00:43:27.110 --> 00:43:32.660
And so the point that comes in again is a screen
point, so we will convert it to the window,

00:43:32.659 --> 00:43:39.899
convert it down to the view itself and then we are going to
use a method that Sketch is already using for hit testing

00:43:39.900 --> 00:43:43.950
to shapes to find the graphic under that point.

00:43:43.949 --> 00:43:50.589
If we find that hit graphic, we are going to make one
of our little proxy objects, these temporary objects,

00:43:50.590 --> 00:43:55.930
stick the hit graphic in there, put the
reference to ourself in and return it.

00:43:55.929 --> 00:44:03.690
And then finally, if we didn't hit a graphic, we just
return ourself or more accurately our un-ignored ancestor.

00:44:06.940 --> 00:44:19.269
And with that, we should have phase 2 done for the first
chunk of our hierarchy, the layout area and its items

00:44:19.269 --> 00:44:29.309
Let me hide Xcode, go to our sample
document here and bring up the Inspector.

00:44:29.309 --> 00:44:35.809
And as I go around, indeed the layout
items report themselves, let's see,

00:44:35.809 --> 00:44:39.699
let's focus on one of them and turn on the highlight to see.

00:44:39.699 --> 00:44:43.929
Yes, it is reporting its bounds
correctly, it is sizing its position.

00:44:43.929 --> 00:44:49.909
Let's test to make sure we can go up the hierarchy
and then come back down using accessibility inspector.

00:44:49.909 --> 00:44:55.460
We will navigate to the parent element and indeed,
it is the layout area with the correct bounds.

00:44:55.460 --> 00:44:59.920
Let's go back down to the children, maybe the
first layout item, which should be that square.

00:44:59.920 --> 00:45:02.809
It is hard to see the highlight there.

00:45:02.809 --> 00:45:06.799
Let me go back up and we will take a peek at the line.

00:45:06.800 --> 00:45:16.470
And notice that it is the bounds of that line,
all values and accessibility are a rectangle.

00:45:16.469 --> 00:45:25.989
And so indeed with what we just did, we now have enabled
half of the hierarchy we are trying to do, excellent.

00:45:25.989 --> 00:45:31.369
Let's go back to slides.

00:45:34.320 --> 00:45:41.670
So a few things to note about what we just
saw, every element requires a reference

00:45:41.670 --> 00:45:46.010
to its parent, because it needs to report its AXParent.

00:45:46.010 --> 00:45:54.860
And every element needs some way to have access to
the view that contains it, because every element needs

00:45:54.860 --> 00:46:01.210
to report its size and position, so
that containing view is the go-to object

00:46:01.210 --> 00:46:03.970
for doing all of the coordinate transformations.

00:46:03.969 --> 00:46:07.159
We saw that in this case.

00:46:07.159 --> 00:46:12.149
We will see that in this other case as
well, as we talk about these handles.

00:46:12.150 --> 00:46:20.139
Oh, one other point about this geometry,
NSAccessibility uses Cocoa screen coordinates.

00:46:20.139 --> 00:46:27.349
In Cocoa the bottom left is the origin, bottom left
of the main screen and so all of the coordinates

00:46:27.349 --> 00:46:34.619
that you will ever receive, all of the points that you
ever send back will be in Cocoa screen coordinates.

00:46:34.619 --> 00:46:45.539
The accessibility APIs, the client APIs take a more
Carbon look at screen coordinates, where the upper,

00:46:45.539 --> 00:46:53.360
is that left or right, I can't even tell anymore,
upper right of the main screen is the origin.

00:46:53.360 --> 00:47:01.280
And so you will pass a value back in Cocoa screen
coordinates, when you look at it in accessibility Inspector,

00:47:01.280 --> 00:47:08.130
which is using the client's screen coordinates, the
value for that point is going to look different.

00:47:08.130 --> 00:47:13.789
You didn't do anything wrong, just the transfer,
the translation is happening automatically for you.

00:47:13.789 --> 00:47:21.119
The best way to check however is to just turn on
that highlight in accessibility Inspector to ensure

00:47:21.119 --> 00:47:24.429
that the right rectangle is being reported on the screen.

00:47:24.429 --> 00:47:30.789
There is also that issue of IsFlip that I kind
of went over a little quickly in the code.

00:47:30.789 --> 00:47:32.739
Let's talk about that in a little more detail.

00:47:32.739 --> 00:47:42.389
So we do have to translate from the view to the window to
the screen for the position, the point that is the position.

00:47:42.389 --> 00:47:55.900
If we have a flipped view, then it is going to be the
upper left corner that is what is reported as the origin

00:47:55.900 --> 00:48:00.180
of that rectangle in the flipped coordinate space.

00:48:00.179 --> 00:48:07.029
But if we just take that point and translate
it to the screen point, that is the wrong spot,

00:48:07.030 --> 00:48:13.340
because we really want to report that point
to accessibility, the lower left point,

00:48:13.340 --> 00:48:21.230
because that is the point in Cocoa screen coordinates
that maps to the origin that we are looking for.

00:48:21.230 --> 00:48:28.730
So if we are flipped, we need to report the
correct corner, so the code that we saw does that.

00:48:28.730 --> 00:48:35.900
OK that said, let's get back to mapping
our hierarchy for these handles,

00:48:35.900 --> 00:48:39.700
where we don't actually have a handle object in Sketch.

00:48:39.699 --> 00:48:51.730
In fact, the way Sketch deals with handles is the graphic
itself just has this e-numb, 1 through 8 for each e-numb.

00:48:51.730 --> 00:48:59.480
It is just upper left, middle left, upper
right, and that e-numb value is used a lot

00:48:59.480 --> 00:49:02.710
of places in Sketch to represent each handle.

00:49:02.710 --> 00:49:07.750
And then the graphic itself does all of the
drawing of the handles, all of the hit testing,

00:49:07.750 --> 00:49:11.920
whether a handle was hit, so it can resize and the like.

00:49:11.920 --> 00:49:20.599
But we need an object, so when we report an AX handle,
there is some object that those requests can go to.

00:49:20.599 --> 00:49:27.519
So we are going to use a fake UI
element, we call it a faux UI element.

00:49:27.519 --> 00:49:38.750
This is a very prevalent and useful pattern in making your
applications accessible, so much so that faux UI element,

00:49:38.750 --> 00:49:44.070
we ship it in an example, sample code,
so you have the full source to it

00:49:44.070 --> 00:49:49.190
and we are reusing that example code as is in Sketch.

00:49:49.190 --> 00:49:57.750
I highly recommend any time you hit this case that you
grab the faux UI element sample code and use it as is

00:49:57.750 --> 00:50:02.920
and we are going to sub-class it
for the SKT handle element class.

00:50:02.920 --> 00:50:10.840
Now that faux UI element, you can search for the
image map example that is where it first appeared.

00:50:10.840 --> 00:50:21.210
It is truly the easiest way to provide one of these
elements that appears only for the sake of accessibility.

00:50:21.210 --> 00:50:25.070
Let's take a look at doing that.

00:50:25.070 --> 00:50:34.900
So we are going to do phase 2, getting the hit testing,
the geometry and the hierarchy correct for handles.

00:50:42.590 --> 00:50:57.190
OK, so first let's take a look at SKTGraphic, I needed to
add some additional functionality on the graphic itself.

00:50:57.190 --> 00:51:01.470
I needed each graphic to be able
to tell me the handle codes.

00:51:01.469 --> 00:51:07.569
Since we are using an e-numb, I just chose to
use an index set so I have an easy way to pass

00:51:07.570 --> 00:51:11.670
around a bunch of integers, typically 1 through 8.

00:51:11.670 --> 00:51:18.460
Also, since the graphic is the one that knows where
to draw its own handles, I have implemented a method

00:51:18.460 --> 00:51:24.990
where I can hand it a handle code and the
graphic will hand me back the correct rect.

00:51:28.000 --> 00:51:32.650
I have-- OK, let's take a look at faux UI element.

00:51:32.650 --> 00:51:37.450
This is the reusable class and
again it itself, it is very simple.

00:51:37.449 --> 00:51:41.710
It is designed to be reusable so
it doesn't have a hard coded role.

00:51:41.710 --> 00:51:48.150
When you create one, you set the role, you set the parent.

00:51:48.150 --> 00:51:55.190
These little reusable objects, typically the reason
why you need them is because all of the smarts

00:51:55.190 --> 00:51:59.250
about that particular thing on
the screen lives somewhere else.

00:51:59.250 --> 00:52:07.420
That is why there is no object to represent it, and
that is typically the parent and so faux UI element

00:52:07.420 --> 00:52:11.130
that class doesn't know a heck of a lot about anything.

00:52:11.130 --> 00:52:20.410
It asks its parent for all of the relevant information, so
it defines this child support protocol to be able to call

00:52:20.409 --> 00:52:23.099
to the parent and ask for things like, What is my size?

00:52:23.099 --> 00:52:24.440
What is my position?

00:52:24.440 --> 00:52:28.200
Am I focused or not?

00:52:28.199 --> 00:52:31.739
We won't walk through all of faux UI element, but I did want

00:52:31.739 --> 00:52:37.229
to show you first the importance
of isEqual and the hash function.

00:52:37.230 --> 00:52:43.380
Again these temporary objects need to compare
as equal if they represent the same element,

00:52:43.380 --> 00:52:50.599
and second to show that this faux UI element, if you use
this as your super class, it is already providing a lot

00:52:50.599 --> 00:52:56.949
of stuff, the code is already written to handle the role,
role description, whether it is focused, the parent,

00:52:56.949 --> 00:53:01.669
window, top level UI element, size and position.

00:53:01.670 --> 00:53:08.940
Now our own little sub-class of the handle, we are going
to hold on to the handle code, because that e-numb value.

00:53:08.940 --> 00:53:14.809
That single integer value is really what sets one
handle apart from another, lets us identify them.

00:53:14.809 --> 00:53:21.099
We have an init method and a convenient factory
method and a method to get the handle code out,

00:53:21.099 --> 00:53:27.239
so we are really just a little
wrapper around this single identifier.

00:53:27.239 --> 00:53:37.519
The init method, not much to see there, the key thing to
see here is in our sub-class, we have overridden isEqual

00:53:37.519 --> 00:53:45.400
and hash to throw the handle code into the mix,
because once we have a parent shape and a handle code,

00:53:45.400 --> 00:53:48.829
we are uniquely identified as the correct element.

00:53:48.829 --> 00:53:56.139
That is all that is going on in the
handle itself, what we just looked at.

00:53:56.139 --> 00:54:06.529
It is all really going on in that graphic
accessibility proxy where the handle

00:54:06.530 --> 00:54:13.920
through faux UI element is already correctly reporting its
parents, now we need that shape to report its children.

00:54:13.920 --> 00:54:23.030
And really the children are also the handles and the layout
area or layout item reports an attribute of its handles.

00:54:23.030 --> 00:54:28.660
So for the children, when we are asked for those,
we will just get our handles and return those.

00:54:28.659 --> 00:54:33.199
When we are asked for our handles, if we
are selected, so our handles are showing,

00:54:33.199 --> 00:54:37.869
we are going to return an array
of handles, UI element objects.

00:54:37.869 --> 00:54:41.989
Otherwise, we will return an empty
array, because we have got nothing.

00:54:45.360 --> 00:54:51.059
Let's go take a look at this handle
UIElementsWithHandleCodes,

00:54:51.059 --> 00:54:55.250
so we take-- oh let me go back just a moment.

00:54:58.800 --> 00:55:06.289
Note that what we are doing to get that set of handle
objects is we ask the graphic that we are a proxy for,

00:55:06.289 --> 00:55:14.029
Hey give me your index set of handle codes, then we-- I
have factored out a method that will take that index set

00:55:14.030 --> 00:55:17.830
and build the little faux UI elements that we want.

00:55:17.829 --> 00:55:25.259
And all it does is it takes that index set of handle
codes, gives me a mutable array that I can stick stuff in

00:55:25.260 --> 00:55:33.450
and then I am using a new block enumeration API
on an NSIndex set to run through every index.

00:55:33.449 --> 00:55:41.000
For every index, I just create one of my handy
little fake handle objects, stick it in the array,

00:55:41.000 --> 00:55:46.380
release it and at the end I have got the
array of children and the array of handles.

00:55:46.380 --> 00:55:51.010
That is all it takes to return the children.

00:55:51.010 --> 00:55:57.050
For hit testing, again now I have children
that I have to worry about hit testing.

00:55:57.050 --> 00:55:58.130
I do exactly what?

00:55:58.130 --> 00:56:01.320
Well it is very similar to what I did in the view itself.

00:56:01.320 --> 00:56:09.460
I convert the point down to be a local point, I
ask the graphic for the handle under the poin.

00:56:09.460 --> 00:56:13.980
And again most applications already
have hit testing implemented.

00:56:13.980 --> 00:56:18.920
And then if I have a hit handle, I make
up one of my little faux UI elements

00:56:18.920 --> 00:56:23.789
and return it, otherwise, it is my un-ignored ancestor.

00:56:23.789 --> 00:56:31.590
And then finally, support for children elements,
well these handles when they are asked for their size

00:56:31.590 --> 00:56:35.519
or position are going to ask me, their parent.

00:56:35.519 --> 00:56:44.530
So I will take that faux element, grab the handle
code out of it, I will ask that graphic I am the proxy

00:56:44.530 --> 00:56:52.100
for the handle-- for the rectangle, then I will
do the appropriate coordinate transformation

00:56:52.099 --> 00:56:54.289
and return the screen point.

00:56:54.289 --> 00:57:02.969
The same exact thing for size, once I get that bounds
for the handle code, it is easy for me to take the size

00:57:02.969 --> 00:57:09.439
and make it into the screen coordinate
space and return that.

00:57:09.440 --> 00:57:13.409
And with that we have handles.

00:57:13.409 --> 00:57:23.139
So let's take a look at that.

00:57:23.139 --> 00:57:30.179
OK, let me not do that, oh dear.

00:57:35.679 --> 00:57:43.399
That is the app and if I bring
up the Inspector, let's select,

00:57:43.400 --> 00:57:49.710
and if I hit a handle it is reporting that I have a handle.

00:57:49.710 --> 00:57:53.130
Actually, these handles are extremely
small, so we can also check

00:57:53.130 --> 00:57:57.000
to make sure we actually are doing
correct coordinate transformations.

00:57:57.000 --> 00:58:07.500
Let's zoom into 800 percent here, so we can get a good look
at a handle and as we mouse over, indeed we have a handle.

00:58:07.500 --> 00:58:15.110
As we lock focus on it, we are getting the geometry right,
let's make sure we can navigate up the tree to a parent.

00:58:15.110 --> 00:58:17.820
We can navigate back down the tree to a handle.

00:58:17.820 --> 00:58:27.530
And indeed now, we are reporting the layout area, the
layout item and children, the children of the layout item,

00:58:27.530 --> 00:58:29.980
which would be its handles when selected.

00:58:29.980 --> 00:58:37.070
Let's deselect and we will lock Focus on that item
to make sure that, notice it is a giant shape now

00:58:37.070 --> 00:58:41.100
that the children are size 0 because there is no selection.

00:58:41.099 --> 00:58:53.739
All right, great, we have just achieved a
giant milestone in the accessibility of Sketch.

00:58:53.739 --> 00:58:58.729
Are you as excited as I am?

00:58:58.730 --> 00:59:02.199
OK, all right back to slides.

00:59:02.199 --> 00:59:08.309
That seriously is a major milestone in
the accessibility of Sketch, so yes.

00:59:08.309 --> 00:59:12.449
[ Applause ]

00:59:12.449 --> 00:59:17.409
When you have your accessibility
hierarchy for your custom view showing

00:59:17.409 --> 00:59:21.289
up in accessibility inspector, you
can navigate up and down the tree.

00:59:21.289 --> 00:59:26.320
You are sure that all of the geometry is correct.

00:59:26.320 --> 00:59:35.840
You are far and away, well on your way to having
that custom view be very nicely accessorized.

00:59:35.840 --> 00:59:40.130
Next comes phase 3, which is working
through the remaining items.

00:59:40.130 --> 00:59:47.720
Now again, we have implemented a lot of
the very core attributes, but every--

00:59:47.719 --> 00:59:56.259
for instance, the layout area has an attribute of
being able to determine its selected layout items.

00:59:56.260 --> 01:00:01.640
We haven't implemented that yet, and in
fact the roles that we chose in step one,

01:00:01.639 --> 01:00:04.940
very much determine what we need to do now.

01:00:04.940 --> 01:00:07.429
What are the remaining attributes?

01:00:07.429 --> 01:00:10.409
What are the remaining actions that we need to implement?

01:00:10.409 --> 01:00:14.759
What attributes can the client
not only get information about.

01:00:14.760 --> 01:00:17.430
but also set information about?

01:00:17.429 --> 01:00:23.719
And in the layout area, we can set the size and
position of a layout item through accessibility.

01:00:23.719 --> 01:00:32.359
We can also set the position of each handle, so an
accessibility client should be able to get a hold

01:00:32.360 --> 01:00:37.000
of a layout item and move it around
or resize it through accessibility.

01:00:37.000 --> 01:00:41.440
Or drill down to an individual handle and move it around.

01:00:41.440 --> 01:00:48.360
And whatever that handle does, in most cases
resizing should take that affect in the application.

01:00:48.360 --> 01:00:53.660
Or say in Keynote or applications where you have
that little, maybe it is a little rounded rect,

01:00:53.659 --> 01:01:01.049
and it has that extra handle that you can adjust
the corner radius that should also be moveable,

01:01:01.050 --> 01:01:09.000
so that is an assisted app like
Voiceover could move that handle around.

01:01:09.000 --> 01:01:18.769
And tests and a very, very handy, actually
the user default or argument to pass

01:01:18.769 --> 01:01:24.409
in when you run an app is NSAccessibility DebugLogLevel 1.

01:01:24.409 --> 01:01:33.609
NSAccessibility DebugLogLevel is going to log any time
the accessibility infrastructure and AppKit hits something

01:01:33.610 --> 01:01:37.610
that it just doesn't like, something is awry and amiss.

01:01:37.610 --> 01:01:45.800
And sometimes you are done with accessibility, but then you
run with this log level, and you realize there are a couple

01:01:45.800 --> 01:01:49.630
of rough edges that you realize you have to iron out.

01:01:49.630 --> 01:01:53.070
Actually, that helps bring us to trouble shooting.

01:01:53.070 --> 01:01:58.470
The first thing that happens when you
are trying to troubleshoot is ensuring

01:01:58.469 --> 01:02:02.609
that the parent and the child reporting is correct.

01:02:02.610 --> 01:02:09.820
For instance, you could imagine very easily on the one
hand, you have a proxy object reporting its parent,

01:02:09.820 --> 01:02:15.080
but in the parent, you accidentally have the
actual graphics being reported as the children.

01:02:15.079 --> 01:02:16.389
That is not going to work.

01:02:16.389 --> 01:02:21.239
You are not going to see the right
results in accessibility inspector.

01:02:21.239 --> 01:02:29.629
The most common thing or reasons that phase two
might go awry is when you have these objects

01:02:29.630 --> 01:02:40.890
that are temporary isEqual and hash for the same
element must return Yes that those are indeed equal.

01:02:40.889 --> 01:02:44.369
Sometimes you may be returning ignored elements,

01:02:44.369 --> 01:02:49.819
because you have not been using those
un-ignored element helper functions.

01:02:49.820 --> 01:02:57.510
And again if you have an issue setting
NSAccessibilityDebugLog Level 1 as your best way

01:02:57.510 --> 01:03:03.940
of getting a lot of diagnostic information
about what is awry with your app.

01:03:03.940 --> 01:03:10.179
Now the last thing I would like to do is take a
look at Sketch, once I have completed phase 3.

01:03:10.179 --> 01:03:17.980
And associated with this session should be the sketch, plus
accessibility sample code, which is the completed version

01:03:17.980 --> 01:03:22.019
of Sketch and let's take a look at it with Voiceover.

01:03:22.019 --> 01:03:26.530
So we will launch this completed version.

01:03:28.679 --> 01:03:29.960
Turn on Voiceover.

01:03:29.960 --> 01:03:31.429
[ Computer talking ]

01:03:31.429 --> 01:03:36.799
Voiceover on, Sketch window, sample sketch
document, layout area, has keyboard focus.

01:03:36.800 --> 01:03:44.070
>> [Presenter] OK for those of you who may have been, how
many folks were in the introductory accessibility, anybody?

01:03:44.070 --> 01:03:45.050
OK, so a few of you.

01:03:45.050 --> 01:03:52.620
In that case, you knew that, or you know, the rest of you
can just imagine, when we turned on Voiceover and pointed

01:03:52.619 --> 01:03:57.250
at the sketch document, it was like ahhh.

01:03:57.250 --> 01:04:01.329
Didn't know there was nothing there,
it was just a big empty space.

01:04:01.329 --> 01:04:03.340
Now we are getting some information.

01:04:03.340 --> 01:04:05.160
We are in a layout area.

01:04:05.159 --> 01:04:08.129
Let's drill down and see if we
can take a look at those things.

01:04:08.130 --> 01:04:10.340
So Voiceover user then says, What is in this?

01:04:10.340 --> 01:04:10.400
>> [ Computer talking ]

01:04:10.400 --> 01:04:14.690
Interact with area, four items, rectangle, layout item.

01:04:14.690 --> 01:04:21.970
>> [Presenter] Oh as part of phase 3, I have added
scriptions, so this now says it is a rectangle.

01:04:21.969 --> 01:04:22.029
>> [ Computer talking ]

01:04:22.030 --> 01:04:23.360
Line layout item.

01:04:23.360 --> 01:04:24.430
>> [Presenter] Line layout item.

01:04:24.429 --> 01:04:24.489
>> [ Computer talking ]

01:04:24.489 --> 01:04:25.319
Text layout item.

01:04:25.320 --> 01:04:26.400
>> [Presenter] Text layout item.

01:04:26.400 --> 01:04:26.460
>> [ Computer talking ]

01:04:26.460 --> 01:04:27.869
Circle layout item.

01:04:27.869 --> 01:04:29.089
>> [Presenter] Circle layout item.

01:04:29.090 --> 01:04:29.150
>> [ Computer talking ]

01:04:29.150 --> 01:04:30.349
Rectangle layout item.

01:04:30.349 --> 01:04:30.989
>> [Presenter] Excellent.

01:04:30.989 --> 01:04:39.309
And I don't know if everybody saw the announcement in Snow
Leopard, there is this amazing new feature in Voiceover,

01:04:39.309 --> 01:04:44.199
the screen reader on Mac OS X where
a user for the first time is able

01:04:44.199 --> 01:04:49.269
to use the multi-touch track pad
as a way of navigating in a window.

01:04:49.269 --> 01:04:51.500
And let me show that to you very briefly.

01:04:51.500 --> 01:04:58.090
It is especially handy in those views that have a very
graphical layout, so let me turn it on very quickly.

01:04:58.090 --> 01:04:59.910
And I use it just here to turn it on.

01:04:59.909 --> 01:05:00.279
>>[ Computer talking ]

01:05:00.280 --> 01:05:01.960
Track pad commander is already on.

01:05:01.960 --> 01:05:06.320
>>[Presenter] And then I am just going to use
one finger and move it around the track pad.

01:05:06.320 --> 01:05:11.940
You are going to see a little dot on the screen, a little
circle on the screen that we have here for demo purposes

01:05:11.940 --> 01:05:15.289
that will show my finger moving on the track pad.

01:05:15.289 --> 01:05:22.630
You will also see Voiceover detailing exactly what
is happening on the screen-- or as I move around.

01:05:22.630 --> 01:05:24.829
So there is my finger.

01:05:24.829 --> 01:05:25.289
>>[ Computer beeping ]

01:05:25.289 --> 01:05:25.750
[ Computer talking ]

01:05:25.750 --> 01:05:35.019
Rectangle layout item, line layout item, text
layout item, circle upper left, layout item.

01:05:35.019 --> 01:05:37.000
>> [Presenter] So, this is a drawing program?

01:05:37.000 --> 01:05:37.059
>> [ Computer talking ]

01:05:37.059 --> 01:05:37.500
Layout item.

01:05:37.500 --> 01:05:42.820
>> [Presenter] And yet with this track pad
navigator, I am able to as a Voiceover user.

01:05:42.820 --> 01:05:43.110
>> [ Computer talking ]

01:05:43.110 --> 01:05:44.240
Line layout item.

01:05:44.239 --> 01:05:48.829
>> [Presenter] Get a pretty good idea of
where things are in relation to each other?

01:05:48.829 --> 01:05:52.069
How large things are in relation to each other?

01:05:52.070 --> 01:05:52.350
[ Computer talking in background ]

01:05:52.349 --> 01:05:54.210
>> [Presenter] That is pretty cool.

01:05:54.210 --> 01:05:54.269
[ Applause ]

01:05:54.269 --> 01:05:59.860
That is extraordinarily cool.

01:05:59.860 --> 01:06:02.570
OK, we will turn off the track pad navigator.

01:06:02.570 --> 01:06:02.769
>> [ Computer talking ]

01:06:02.769 --> 01:06:04.519
Track pad off.

01:06:04.519 --> 01:06:08.349
>> [Presenter] OK, the next thing I would like to do is,

01:06:08.349 --> 01:06:13.069
we can also set values through accessibility,
so let's move this circle around a bit.

01:06:13.070 --> 01:06:14.110
>> [ Computer talking ]

01:06:14.110 --> 01:06:15.920
Start moving layout item, 190?.

01:06:15.920 --> 01:06:17.070
>> [Presenter] Start moving layout item.

01:06:17.070 --> 01:06:17.130
>> [ Computer talking ]

01:06:17.130 --> 01:06:18.450
140.000

01:06:18.449 --> 01:06:22.049
>> [Presenter] So using the arrow
keys through accessibility.

01:06:22.050 --> 01:06:22.110
>>[ Computer talking ]

01:06:22.110 --> 01:06:25.140
Left, left, up, up, down, down

01:06:25.139 --> 01:06:30.210
>> [Presenter] This is not using scripting,
this is not using Sketch's own event handling.

01:06:30.210 --> 01:06:32.170
This is through accessibility's API.

01:06:32.170 --> 01:06:32.230
>> [ Computer talking ]

01:06:32.230 --> 01:06:36.110
Up, right, down, left, right, right 40 points, up 20 points.

01:06:36.110 --> 01:06:37.280
>> [Presenter] You can pretend you are marching.

01:06:37.280 --> 01:06:37.710
>>[ Computer talking ]

01:06:37.710 --> 01:06:41.320
Left, right, left, right, left, right.

01:06:41.320 --> 01:06:41.450
[ Laughter ]

01:06:41.449 --> 01:06:42.829
>> [Presenter] That is kind of fun.

01:06:42.829 --> 01:06:43.460
>> [ Computer talking ]

01:06:43.460 --> 01:06:47.449
Stop moving the layout item.

01:06:47.449 --> 01:06:47.769
>> [Presenter] Oh sure.

01:06:47.769 --> 01:06:48.460
[ Applause ]

01:06:48.460 --> 01:06:51.099
Feel free.

01:06:51.099 --> 01:06:58.710
And then finally, we have exposed handles with the size
and position, but every assisted application may choose

01:06:58.710 --> 01:07:03.019
to do whatever it wishes with the
information your application provides.

01:07:03.019 --> 01:07:09.079
And rather than make a really little rectangle on
the screen, when you hit a layout item in voiceover,

01:07:09.079 --> 01:07:15.699
it chooses to allow you to access them
through a menu and resize using that handle.

01:07:15.699 --> 01:07:18.889
So let's get to that little menu.

01:07:18.889 --> 01:07:19.119
>> [ Computer talking ]

01:07:19.119 --> 01:07:21.339
Layout item resize options menu, 8 options.

01:07:21.340 --> 01:07:25.700
>> [Presenter] Now, I have added in the final
product some descriptions for each of these handles,

01:07:25.699 --> 01:07:28.329
so we can tell the different places around.

01:07:28.329 --> 01:07:31.269
Let's move around the lower left handle.

01:07:31.269 --> 01:07:31.349
>> [ Computer talking ]

01:07:31.349 --> 01:07:35.179
Upper middle, right, lower left, resize lower left.

01:07:35.179 --> 01:07:40.579
>> [Presenter] And then again, by changing the
position of that handle through the accessibility API,

01:07:40.579 --> 01:07:43.840
some other process voiceover is able to do this in sketch.

01:07:43.840 --> 01:07:43.900
>> [ Computer talking ]

01:07:43.900 --> 01:07:46.750
20.0, 20.0, 20.0 points.

01:07:46.750 --> 01:07:48.170
>> [Presenter] We are moving that handle.

01:07:48.170 --> 01:07:51.960
There is a little bug in Voiceover
that is not redrawing the cursor.

01:07:51.960 --> 01:07:52.170
>> [ Computer talking ]

01:07:52.170 --> 01:07:54.570
20.0 points, 20.0 points.

01:07:54.570 --> 01:07:57.500
>> [Presenter] But you are the server of information.

01:07:57.500 --> 01:08:01.840
That is a client bug, so Sketch is
doing the correct thing in this.

01:08:01.840 --> 01:08:01.900
>> [ Computer talking ]

01:08:01.900 --> 01:08:06.349
20, 20, 20, 20.0 points.

01:08:06.349 --> 01:08:07.839
>> [Presenter] And let's turn off Voiceover.

01:08:07.840 --> 01:08:07.960
>> [ Computer talking ]

01:08:07.960 --> 01:08:08.670
Voiceover off.

01:08:08.670 --> 01:08:14.769
>> [Presenter] And again over the course of this session
and over the course of this week, Sketch which had this kind

01:08:14.769 --> 01:08:21.750
of big area that was not accessible at all, now a
Voiceover user can do actually a great deal of stuff

01:08:21.750 --> 01:08:25.560
within Sketch through the accessibility APIs.

01:08:25.560 --> 01:08:37.390
And we would of course encourage you to
do the same thing with your custom views.

01:08:37.390 --> 01:08:37.530
[ Applause ]

01:08:37.529 --> 01:08:46.219
So for more information, Eric Hope, our Technologies
Evangelist, again that accessibility mailing list,

01:08:46.220 --> 01:08:52.110
when you are doing accessibility for you app,
I highly recommend subscribing to that list.

01:08:52.109 --> 01:09:02.250
We have a bunch of documentation, and we also
have an accessibility webpage on apple.com.

01:09:02.250 --> 01:09:05.579
This has been recently redone.

01:09:05.579 --> 01:09:13.829
It has a lot of great information, both about Voiceover,
about all of the things Apple is doing with accessibility.

01:09:13.829 --> 01:09:20.659
It also has a little section where
accessible applications are highlighted.

01:09:20.659 --> 01:09:27.359
We love to see accessible applications, and we love to
tell everybody about what applications are accessible,

01:09:27.359 --> 01:09:32.609
because there are a lot of people very curious that
are wanting to use your apps through Voiceover.

01:09:32.609 --> 01:09:32.979
19
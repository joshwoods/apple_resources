WEBVTT

00:00:12.849 --> 00:00:17.800
>> Good morning ladies and gentlemen, it's good
to see such a packed house here for Bonjour today.

00:00:17.800 --> 00:00:25.589
As always, my name's Stewart Cheshire and I'm here to tell
you all the exciting things that are going on with Bonjour.

00:00:25.589 --> 00:00:31.600
I'm going to start with a recap of what Bonjour is about.

00:00:31.600 --> 00:00:38.390
Many of you in this audience know exactly what Bonjour
is about, but more than half of the developers here

00:00:38.390 --> 00:00:42.679
at WWDC this year are brand new to WWDC, first time.

00:00:42.679 --> 00:00:48.960
So for your benefit I'm going to give a
brief background on what Bonjour is about.

00:00:48.960 --> 00:00:54.859
Then we're going to talk about the big news this year, which
is the Bonjour Sleep Proxy, which is new in Snow Leopard.

00:00:54.859 --> 00:01:02.929
And I'm going to talk about Bonjour over unpaired
Bluetooth as used by the iPhone game connection kit.

00:01:02.929 --> 00:01:08.269
We have some other news to tell you, we
have tips and reminders for developers.

00:01:08.269 --> 00:01:19.619
I'm going to finish up with a couple of really cool demos
to show you of new hardware, and new iPhone interface.

00:01:19.620 --> 00:01:22.850
What is Bonjour about?

00:01:22.849 --> 00:01:28.979
Bonjour is about making IP networking as easy to use as USB.

00:01:28.980 --> 00:01:33.620
And when I say that today, that's less
heretical than it was a few years ago.

00:01:33.620 --> 00:01:42.260
But when we started this eight years ago, suggesting that
IP, suggesting that plugging in an Ethernet cable could be

00:01:42.260 --> 00:01:46.230
as easy to use as USB, seemed very strange to people.

00:01:46.230 --> 00:01:52.880
You have to type in IP addresses and subnet masks, and
gateway addresses and DNS server addresses and things.

00:01:52.879 --> 00:01:57.949
And there was no technical reason
that IP needed all of that,

00:01:57.950 --> 00:02:02.370
so if we could solve those problems we
could make Ethernet as easy to use as USB.

00:02:02.370 --> 00:02:08.319
And now that you can have power over Ethernet,
we also can share that benefit with USB as well,

00:02:08.319 --> 00:02:12.229
that you can make devices that
are powered over the USB cable.

00:02:12.229 --> 00:02:16.699
AppleTalk did this, so clearly it was
possible to make easy-to-use networking.

00:02:16.699 --> 00:02:19.449
We want to do the same thing with IP.

00:02:20.520 --> 00:02:22.430
How do we make this work?

00:02:22.430 --> 00:02:26.860
There are three simple technologies that make this work.

00:02:26.860 --> 00:02:32.950
In previous years I've give a whole hour long talk
about this, now it's condensed down to one slide.

00:02:32.949 --> 00:02:40.069
So I'll give you the overview, if you want to find out
more information you can read documentation on the web,

00:02:40.069 --> 00:02:45.699
you can take a look at my O'Reilly
Zero Configuration Networking book.

00:02:45.699 --> 00:02:53.089
So the overview: first layer you're not going
to do much IP networking without an IP address.

00:02:53.090 --> 00:02:57.060
Now DHCP is great, we have nothing against DHCP.

00:02:57.060 --> 00:03:06.409
But if you don't have a DHCP server we need devices to still
work, and we do this very similar to the way AppleTalk did.

00:03:06.409 --> 00:03:11.629
The device picks a random address in a
special range, it sends an ARP request,

00:03:11.629 --> 00:03:16.069
if nobody answers that address is yours; very simple.

00:03:16.069 --> 00:03:18.479
That gives us addressing.

00:03:18.479 --> 00:03:20.219
The next level is naming.

00:03:20.219 --> 00:03:25.849
Now DNS is great and if you run your own DNS
server that's great, but many people don't.

00:03:25.849 --> 00:03:30.819
So what we want is something that gives us
DNS-like semantics, but without the overhead

00:03:30.819 --> 00:03:34.049
of running a server; and that's multicast DNS.

00:03:34.050 --> 00:03:40.600
Every device on the network runs a little responder,
when it sees a query for its name, it answers that query.

00:03:40.599 --> 00:03:45.180
Applications get DNS-like behavior
but in a distributed fashion,

00:03:45.180 --> 00:03:48.420
not using a single central server that you have to run.

00:03:48.419 --> 00:03:51.489
The third layer is service discovery.

00:03:51.490 --> 00:03:56.890
Typing in host names and resolving them to
addresses is great, but we want more than that.

00:03:56.889 --> 00:04:02.899
We want the user to be able to browse and discover what's
on the network and not have to know what to type in.

00:04:02.900 --> 00:04:05.330
That's DNS service discovery.

00:04:06.900 --> 00:04:14.430
At a software API layer, you use the Bonjour
technology through three basic operations.

00:04:14.430 --> 00:04:17.620
The first one is advertising a service.

00:04:17.620 --> 00:04:23.939
If you have a socket that you bind to a port so you have
a listening socket waiting for incoming TCP connections

00:04:23.939 --> 00:04:27.899
or incoming UDP packets, then don't keep that a secret.

00:04:27.899 --> 00:04:33.429
Register that service with Bonjour
so that other clients know about it.

00:04:33.430 --> 00:04:37.240
When you register the service, the machine
announces its presence on the network,

00:04:37.240 --> 00:04:39.079
so any clients that are looking for it know.

00:04:39.079 --> 00:04:45.149
But it doesn't continuously announce
like some discovery protocols.

00:04:45.149 --> 00:04:53.739
It sits there quietly and only answers if it's asked,
because we do a lot of work to make the protocol not chatty.

00:04:53.740 --> 00:05:00.699
On the client side, you may have clients
today where the user types in an IP address

00:05:00.699 --> 00:05:03.779
or a host name, and if you do that that's fine.

00:05:03.779 --> 00:05:05.369
You can carry on doing that.

00:05:05.370 --> 00:05:13.459
But you can also offer them the option of browsing using
Bonjour to discover what's available without typing it in.

00:05:13.459 --> 00:05:22.919
Your client browses for services of the type that
it can use, and Bonjour sends out a multicast query,

00:05:22.920 --> 00:05:25.879
and the service that implemented that service responds.

00:05:25.879 --> 00:05:31.569
And this gives your user a list
of name services on the screen.

00:05:31.569 --> 00:05:39.139
Just names, not addresses, because in a world of
DHCP and link local addressing, addresses can change.

00:05:39.139 --> 00:05:42.500
When it's time to use the service,
of course a name is not enough.

00:05:42.500 --> 00:05:45.430
You need an actual address and port to connect to,

00:05:45.430 --> 00:05:51.379
and to get that you resolve the named
Bonjour service to its address and port.

00:05:51.379 --> 00:05:57.980
In typical usage, browsing is an occasional
operation and I'll give you an example.

00:05:57.980 --> 00:06:01.650
The user may browse occasionally to look for printers.

00:06:01.649 --> 00:06:05.009
They pick one, they set it up as their default printer.

00:06:05.009 --> 00:06:09.810
They don't do that very often, but many
times a day they may print a document.

00:06:09.810 --> 00:06:13.480
So browsing is something that you
do occasionally at setup time,

00:06:13.480 --> 00:06:17.620
resolving is something you do every
time you print a document.

00:06:17.620 --> 00:06:23.540
And what this means is in the world of dynamic
addresses, DHCP and link local addressing,

00:06:23.540 --> 00:06:29.150
it doesn't matter if your printer changes it's address
because your computer hasn't stored the address

00:06:29.149 --> 00:06:36.569
of your default printer, it stored the name; and it resolves
that name to its address on demand every time you print.

00:06:36.569 --> 00:06:41.680
So these are the three basic operations of
Bonjour that you will use in your applications,

00:06:41.680 --> 00:06:46.550
regardless of which programming
language or which API you use.

00:06:46.550 --> 00:06:50.819
What do you do if the machines
are not on the same home network?

00:06:50.819 --> 00:06:53.560
What do you do if they're separated across the Internet?

00:06:53.560 --> 00:06:57.490
What do you do if one of them is behind a NAT gateway?

00:06:57.490 --> 00:07:05.550
The answer: it's the same thing, just use the Bonjour
APIs and we will handle the details for you automatically.

00:07:05.550 --> 00:07:14.790
Wide-area Bonjour and with MobileMe, Back to My
Mac, will negotiate the NAT gateway, port mappings,

00:07:14.790 --> 00:07:22.000
will advertise the public address in DNS, handle
all of this for you, and your same code will work.

00:07:23.750 --> 00:07:26.660
This is what the software architecture looks like.

00:07:26.660 --> 00:07:30.720
The kernel provides the IP multicast capabilities we use,

00:07:30.720 --> 00:07:37.730
and on top of that the MDNS responder daemon is a
background process that runs on every Mac and iPhone

00:07:37.730 --> 00:07:41.730
to manage the Bonjour services that you need.

00:07:41.730 --> 00:07:46.250
You can access those services in three different ways.

00:07:46.250 --> 00:07:51.629
If you're writing low level C code and this is the
same if you're writing Windows code, or Linux code,

00:07:51.629 --> 00:07:59.659
the dns_sd.h API is our low level
C API and it's cross platform.

00:07:59.660 --> 00:08:06.150
If you're writing Mac specific code using CFRunLoop
and CFSocket and the Core Foundation abstractions,

00:08:06.149 --> 00:08:10.439
then the CFNetServices API will be a
better fit for your programming model.

00:08:10.439 --> 00:08:16.279
And if you're writing iPhone applications
you'll be using the Cocoa programming idiom

00:08:16.279 --> 00:08:21.429
and you'll want to use the NSNetServices API.

00:08:21.430 --> 00:08:26.189
So now onto the big news, the Bonjour Sleep Proxy.

00:08:26.189 --> 00:08:31.469
You will have heard about this at Simon
Patience's Core OS State of the Union presentation.

00:08:31.470 --> 00:08:40.070
And I say here, saving the world half a billion
dollars, there are 25 million OS X machines in use today

00:08:40.070 --> 00:08:46.590
and let's say one in five of those,
20%, are left turned on all the time

00:08:46.590 --> 00:08:50.200
so that people can access services over the network.

00:08:50.200 --> 00:08:55.640
And let's say that costs about $8 a
month, say $100 a year in electricity.

00:08:55.639 --> 00:08:58.970
Depending on the model of Mac you have and
depending on how much you pay for electricity,

00:08:58.970 --> 00:09:01.420
it might be a lot more than that, it might be less.

00:09:01.419 --> 00:09:02.649
But let's say $100.

00:09:02.649 --> 00:09:09.490
That adds up to half a billion dollars a year in
electricity that we save with the Sleep Proxy service.

00:09:09.490 --> 00:09:14.379
So let's give some examples.

00:09:14.379 --> 00:09:19.899
I have an iMac at home with a printer
attached, running printer sharing.

00:09:19.899 --> 00:09:25.509
My daughter has an iMac, and she wants to print a document.

00:09:25.509 --> 00:09:32.610
But my Mac is asleep so the printer manager will
not be there, and the document doesn't print.

00:09:32.610 --> 00:09:34.399
I'll give you another example.

00:09:34.399 --> 00:09:41.230
My iMac at home is running iTunes, and I have
an Apple TV connected to my television...

00:09:41.230 --> 00:09:47.850
but my Mac is asleep so my Apple TV can't
get access to my music, and my photos,

00:09:47.850 --> 00:09:51.500
and my movies that are sitting on my iMac.

00:09:51.500 --> 00:09:57.830
Another example: I have an iMac at
home, and I have a Mac at work...

00:09:57.830 --> 00:09:59.000
that's Simon's office.

00:09:59.000 --> 00:10:07.190
I have a Mac in my office at work, and fortunately
I have MobileMe so I can get to my Mac at home but,

00:10:07.190 --> 00:10:11.060
and you know this by now, not if it's asleep.

00:10:11.059 --> 00:10:17.899
So we're rolling out more and more services
that let you do useful things over the network -

00:10:17.899 --> 00:10:22.319
printer sharing, media sharing, screen sharing.

00:10:22.320 --> 00:10:29.580
But at the same time, the world is sending
the message about environmental consciousness

00:10:29.580 --> 00:10:34.300
and saving energy, and these two things are in conflict.

00:10:34.299 --> 00:10:38.620
How do people solve the problem of not
being able to get to the sleeping machine?

00:10:38.620 --> 00:10:42.210
Right now they have very a powerful
solution, they just burn a lot of power.

00:10:42.210 --> 00:10:44.780
And that's not what we want.

00:10:44.779 --> 00:10:53.199
We want to enable people to use these services remotely
over the network without burning a lot of power.

00:10:53.200 --> 00:10:59.950
We want a power saving solution, and that's what I'm
going to tell you about now with the Bonjour Sleep Proxy.

00:10:59.950 --> 00:11:04.270
So let's look at this same situation of
my iMac at home with printer sharing,

00:11:04.269 --> 00:11:08.460
but I also have an Apple AirPort Base Station.

00:11:08.460 --> 00:11:14.490
And now when the Mac wants to go to sleep,
it transfers its Bonjour service records

00:11:14.490 --> 00:11:17.629
to the AirPort Base Station before it goes to sleep.

00:11:17.629 --> 00:11:24.029
And after my Mac has gone to sleep, the AirPort
Base Station broadcasts our pronouncement packets,

00:11:24.029 --> 00:11:27.539
claiming ownership of that IP address.

00:11:27.539 --> 00:11:35.349
Now when I have a document that I want to print,
the printing client opens the TCP connection,

00:11:35.350 --> 00:11:42.259
and because the AirPort Base Station now claims
ownership of that address, it gets the TCP SIM packet;

00:11:42.259 --> 00:11:48.419
and it examines that packet and deems that
this is something worth waking my computer for.

00:11:48.419 --> 00:11:57.089
So it sends the wake up packet, my computer wakes up, my
computer reclaims its IP address, and in the normal course

00:11:57.090 --> 00:12:03.120
of operation without the user or the application
doing anything special, TCP will retransmit to cope

00:12:03.120 --> 00:12:10.340
with packet loss, the next packet goes to my iMac,
the connection completes, and the document prints -

00:12:10.340 --> 00:12:14.769
all without the client knowing
that anything special went on here.

00:12:14.769 --> 00:12:17.129
Let's look at a similar scenario.

00:12:17.129 --> 00:12:20.500
My Mac goes to sleep and a friend comes to visit.

00:12:20.500 --> 00:12:23.519
Now this friend has never been to my house before.

00:12:23.519 --> 00:12:29.019
He brings his laptop, he doesn't know I have
a printer, but he needs to print a document.

00:12:29.019 --> 00:12:37.779
So he browses with Bonjour, sends out his multicast
query, the Base Station because it knows all the services

00:12:37.779 --> 00:12:40.720
that my Mac offers, it answers that query.

00:12:40.720 --> 00:12:47.450
Bonjour is the key to making this work,
because when the machine goes to sleep it needs

00:12:47.450 --> 00:12:53.730
to transfer a compact description of its
role on the network to the Sleep Proxy.

00:12:53.730 --> 00:12:58.970
It needs to say what its name is, what services
it offers, what ports it's listening on,

00:12:58.970 --> 00:13:05.540
and the Bonjour records provide us
a perfect compact representation

00:13:05.539 --> 00:13:08.029
of what that machine's role is on the network.

00:13:08.029 --> 00:13:15.600
And we ship those across in a DNS update packet to
the Sleep Proxy so it can announce on our behalf.

00:13:15.600 --> 00:13:21.570
And here it answers my friend's laptop,
and he discovers that I have a printer.

00:13:21.570 --> 00:13:24.010
And from that point on, he can print just like I did.

00:13:24.009 --> 00:13:30.340
There are other people working on paramanagement
solutions that require you to set up the client

00:13:30.340 --> 00:13:36.519
in advance while the machine's awake, and store information
on the client so it knows how to wake up the server.

00:13:36.519 --> 00:13:43.230
But Bonjour is supposed to be easier than that,
it's not supposed to be about knowing special rules

00:13:43.230 --> 00:13:45.870
that you have to follow to make things work.

00:13:45.870 --> 00:13:48.210
So that's why we made it work this way.

00:13:48.210 --> 00:13:53.160
You show up, you do the normal operations, and
it doesn't matter what's asleep or what's awake.

00:13:53.159 --> 00:13:56.669
Everything just works the way you'd expect it to.

00:13:56.669 --> 00:13:58.439
So let me recap.

00:13:58.440 --> 00:14:03.920
When your machine is ready to go to sleep, it
finds a Bonjour Sleep Proxy on the network.

00:14:03.919 --> 00:14:08.729
Using Bonjour of course to discover
it, it registers its records

00:14:08.730 --> 00:14:14.149
with that Sleep Proxy using a DNS update
packet, and then it goes to sleep.

00:14:14.149 --> 00:14:20.129
Next the Bonjour Sleep Proxy will
answer multicast DNS queries on behalf

00:14:20.129 --> 00:14:23.360
of that sleeping machine, without waking it.

00:14:23.360 --> 00:14:28.700
It will also answer ARP requests on behalf
of that sleeping machine, without waking it.

00:14:28.700 --> 00:14:35.100
And because it answers those ARP requests, it gets
possession of all the network traffic destined

00:14:35.100 --> 00:14:40.240
for that sleeping machine, so it can inspect
those packets and when it sees one worthy

00:14:40.240 --> 00:14:44.549
of waking the machine, it sends
a magic packet to wake it up.

00:14:44.549 --> 00:14:52.459
It can the machine a few seconds to wake from sleep, so
your TCP connection may take a little longer than usual;

00:14:52.460 --> 00:15:00.519
and this is another reason for the advice that we always
give developers, which is don't hard code network timeouts

00:15:00.519 --> 00:15:04.559
because it may be true that normally
your connection completes

00:15:04.559 --> 00:15:07.629
within two seconds, but now it might take four or five.

00:15:07.629 --> 00:15:11.419
And if you've hard coded a two
second timeout in your application,

00:15:11.419 --> 00:15:14.709
that's the one thing that will make it fail now.

00:15:14.710 --> 00:15:24.430
So the advice we always give is don't have programmatic
timeouts, put up UI that tells the user you're connecting,

00:15:24.429 --> 00:15:31.559
have a Cancel button so the user has the option of
canceling when they decide that something isn't working,

00:15:31.559 --> 00:15:34.769
and let the user wait as long as
they think is necessary to wait.

00:15:34.769 --> 00:15:40.240
Put the decision in the user's
hands, not in the developer's hands.

00:15:40.240 --> 00:15:41.570
Why do we do this?

00:15:41.570 --> 00:15:47.260
I've shown you examples of printer
sharing, media sharing, screen sharing...

00:15:47.259 --> 00:15:52.649
one that I think a lot of the developers
in this room will like is command line SSH.

00:15:52.649 --> 00:15:57.129
You can now SSH to a machine and it will wake up on demand.

00:15:57.129 --> 00:16:03.669
And of course, of interest to all of you in this
room, is all of your services that are advertised

00:16:03.669 --> 00:16:08.769
with Bonjour get this functionality for free.

00:16:08.769 --> 00:16:10.769
How do we make this work?

00:16:10.769 --> 00:16:15.889
We build upon an old technology
called Wake on LAN, or Magic Packet.

00:16:15.889 --> 00:16:20.679
This has been around for 10 or 15
years, it's very stable, very mature.

00:16:20.679 --> 00:16:29.000
I'm sure many of the people in this
room know how Magic Packet works,

00:16:29.000 --> 00:16:31.360
they could probably even draw the packet format.

00:16:31.360 --> 00:16:38.000
But I'll bet that almost nobody in this room
has actually woken a machine using Magic Packet.

00:16:38.000 --> 00:16:45.879
We all know how to do it in theory, but in practice
the hassle of making it work just isn't worth it.

00:16:45.879 --> 00:16:51.909
So what Bonjour Sleep Proxy does is it takes
that underlying tool that everybody has,

00:16:51.909 --> 00:16:58.289
and it automates it so that everybody gets to
use it; without configuration, without effort,

00:16:58.289 --> 00:17:01.529
without any thought, it's just automatic.

00:17:01.529 --> 00:17:06.829
So I've talked about Wake on LAN, there's another
underlying technology which is Wake on Wireless,

00:17:06.829 --> 00:17:08.829
and that is a lot newer than Wake on LAN.

00:17:08.829 --> 00:17:13.519
Wake on LAN has been around for many
years, it's very mature and reliable.

00:17:13.519 --> 00:17:17.819
Wake on Wireless is brand new with Snow Leopard,

00:17:17.819 --> 00:17:23.109
it only works on our currently
shipping Mac models, not on older ones.

00:17:23.109 --> 00:17:29.639
So that is a brand new technology, and is less
mature, less well tested than Wake on LAN.

00:17:29.640 --> 00:17:34.900
Now I'm going to talk about the
participants in this process.

00:17:34.900 --> 00:17:40.380
The first participant is the server
that's going to go to sleep.

00:17:40.380 --> 00:17:47.280
There are two requirements there: it has to be running
Snow Leopard because this is a new feature in Snow Leopard,

00:17:47.279 --> 00:17:50.869
and it has to have some Bonjour advertised services.

00:17:52.460 --> 00:17:57.710
One thing in particular that this means is that
pinging a sleeping machine will not wake it,

00:17:57.710 --> 00:18:00.470
because ping is not a Bonjour advertised service.

00:18:00.470 --> 00:18:07.019
And this is something that we do by design because a
common test that people do to see if a machine is asleep is

00:18:07.019 --> 00:18:10.589
to ping it and see if it responds, and
if we wake it up every time you ping it,

00:18:10.589 --> 00:18:14.230
it kind of invalidates that test
to see if the machine's asleep.

00:18:14.230 --> 00:18:18.309
So we don't want to interfere with
people's expected behavior,

00:18:18.309 --> 00:18:25.079
so ping for a sleeping machine will still do
what it does today, and not get a response.

00:18:25.079 --> 00:18:30.509
But for Bonjour advertised services, will wake the machine.

00:18:30.509 --> 00:18:38.170
The Bonjour Sleep Proxy has to be on the
same physical link as the sleeping server.

00:18:38.170 --> 00:18:45.789
You may read on the web that you can do wake up packets
remotely, but it actually doesn't work reliably.

00:18:45.789 --> 00:18:47.289
There's no way to make that work reliably.

00:18:47.289 --> 00:18:55.359
The only way to do it reliably is to have a machine on
the same physical link, or subnet, sending the packet.

00:18:55.359 --> 00:19:00.399
Any low power device that's always
on is a good candidate for this.

00:19:00.400 --> 00:19:07.590
So that makes the AirPort Base Station a
natural place to put the Sleep Proxy capability.

00:19:07.589 --> 00:19:15.169
Any device on the network could do it, but the AirPort
Base Station is a low power device, it's always on,

00:19:15.170 --> 00:19:19.130
and generally speaking the user is
unlikely to unplug it and walk away with it.

00:19:19.130 --> 00:19:21.410
So that makes it an ideal candidate for this.

00:19:21.410 --> 00:19:24.230
If you don't use an AirPort Base Station,

00:19:24.230 --> 00:19:29.960
then a Snow Leopard machine running internet
sharing will also offer Sleep Proxy service

00:19:29.960 --> 00:19:32.140
on all of its advertised interfaces.

00:19:32.140 --> 00:19:36.360
This is code is open source, so we hope and expect

00:19:36.359 --> 00:19:41.379
that other developers will make this
available in their products too.

00:19:41.380 --> 00:19:46.480
The third participant is the client, and
there's nothing special about the client.

00:19:46.480 --> 00:19:50.700
The client doesn't need to be Snow Leopard,
it doesn't need to know about Sleep Proxy,

00:19:50.700 --> 00:19:56.900
it's any machine that does TCP/IP -
Mac, Windows, Linux, iPhone, whatever.

00:19:56.900 --> 00:20:04.450
And that machine can be anywhere; it can be on the
local network, it can connect to services using Bonjour,

00:20:04.450 --> 00:20:08.410
or it can connect to them by typing in an IP address.

00:20:08.410 --> 00:20:15.300
To wake a machine, its services have to be advertised
with Bonjour so that the Sleep Proxy knows what they are.

00:20:15.299 --> 00:20:17.859
But the client doesn't need to connect using Bonjour,

00:20:17.859 --> 00:20:21.769
once the Sleep Proxy knows the
services the clients can connect anyway.

00:20:21.769 --> 00:20:25.730
So by name, by address, by Bonjour browsing.

00:20:25.730 --> 00:20:31.519
The client kernels will wake it from anywhere
on the internet, not just on the local network.

00:20:31.519 --> 00:20:36.629
As long as the machine is reachable today, when it's awake,

00:20:36.630 --> 00:20:41.000
then with Bonjour Sleep Proxy it's
reachable and wakeable when it's asleep.

00:20:41.000 --> 00:20:42.589
And what do I mean by reachable?

00:20:42.589 --> 00:20:47.189
If you have a Global routable IP address,
which not many people do these days,

00:20:47.190 --> 00:20:52.210
but if you have one of those the machine
is reachable and wakeable remotely.

00:20:52.210 --> 00:20:58.660
If you have a NAT gateway, a lot of people
configure a default DMZ host to be their server.

00:20:58.660 --> 00:21:01.680
If you do that, then the server is wakeable.

00:21:01.680 --> 00:21:05.360
You can make manual NAT port mappings,

00:21:05.359 --> 00:21:11.089
you can make automatic Map port mappings
using NAT-PMP and wide area Bonjour.

00:21:11.089 --> 00:21:16.419
And of course if you're using MobileMe,
Back to my Mac, we automate all this for you

00:21:16.420 --> 00:21:22.830
and make the automatic port mapping and
register your address records for you.

00:21:22.829 --> 00:21:25.129
However your machine is reachable today when it's awake,

00:21:25.130 --> 00:21:33.360
with Bonjour Sleep Proxy it'll
be reachable when it's asleep.

00:21:33.359 --> 00:21:38.169
Let me focus on the precise details
about what will wake a machine.

00:21:38.170 --> 00:21:44.730
A unicast UDP packet to an advertised
service will wake the machine.

00:21:44.730 --> 00:21:51.509
A random port scan to some port that's not open on the
machine, doesn't wake it because there's nothing listening

00:21:51.509 --> 00:21:54.549
for that packet, so what's the point of waking it?

00:21:54.549 --> 00:22:00.899
We don't wake for multicasts and broadcasts,
because multicasts and broadcasts are typically used

00:22:00.900 --> 00:22:06.150
for service discovery applications, and if you send
a broadcast and wake every machine on the network,

00:22:06.150 --> 00:22:11.060
that's kind of inefficient and well Bonjour
does service discovery for you anyway.

00:22:11.059 --> 00:22:16.639
So you really don't need to be having
different ad hoc service discovery mechanisms.

00:22:16.640 --> 00:22:22.790
For TCP we wake clients for new connection requests.

00:22:22.789 --> 00:22:30.920
Right now we made a conscious decision not to wake
sleeping servers for data packets on existing connections,

00:22:30.920 --> 00:22:35.620
and the reason we do that is a lot of
applications today, when you put the server

00:22:35.619 --> 00:22:38.099
to sleep, they don't close their connections.

00:22:38.099 --> 00:22:41.179
And they just expect the connections to timeout.

00:22:41.180 --> 00:22:46.860
Well if the device at the other end is sending packets
saying "are you there", if the server keeps waking up to say

00:22:46.859 --> 00:22:51.649
"yes I am" then it kind of defeats the
assumption that those connections would timeout.

00:22:51.650 --> 00:22:58.680
So we want to be conservative and not be waking up
machines furiously all the time, so we wake them up only

00:22:58.680 --> 00:23:03.750
for new connections with one exception - which
again is for the developers in this room -

00:23:03.750 --> 00:23:09.980
for SSH connections we will wake up the machine for
any data packet, and that's just because it's so cool

00:23:09.980 --> 00:23:13.009
to be able to SSH to your machine at home.

00:23:13.009 --> 00:23:18.700
[ Laughter and applause ]

00:23:18.700 --> 00:23:22.090
When you've finished what you're doing,
you don't have to wait for the timeout,

00:23:22.089 --> 00:23:24.859
put it to sleep right now, with
pmset sleepnow it goes to sleep.

00:23:24.859 --> 00:23:27.079
You can leave that window open.

00:23:27.079 --> 00:23:28.000
You want to do something else?

00:23:28.000 --> 00:23:31.420
You type LS, you hit return after a few
seconds, it wakes up and you get the listing.

00:23:31.420 --> 00:23:34.310
You do what you want, sleepnow, put it back to sleep again.

00:23:34.309 --> 00:23:41.859
So you can have an SSH window open for days or
weeks at a time to a machine that goes to sleep

00:23:41.859 --> 00:23:45.369
when you're not using it, without losing the TCP connection.

00:23:48.180 --> 00:23:52.650
One of the things you need to know about
Bonjour Sleep Proxy is maintenance wake.

00:23:54.160 --> 00:24:02.170
Every couple of hours or so a sleeping server will
wake to do routine maintenance of its network state.

00:24:02.170 --> 00:24:09.360
It doesn't light the screen, it doesn't power the
audio, but disks and fan spinning up maybe audible.

00:24:09.359 --> 00:24:14.559
If this is a Mac in a school classroom
where a teacher is accessing it

00:24:14.559 --> 00:24:17.500
over the weekend remotely, I'm sure nobody cares.

00:24:17.500 --> 00:24:23.759
If this is a Mac on your bedside table when you're
trying to sleep, depending on how sensitive you are,

00:24:23.759 --> 00:24:25.940
the noise of the fans and the disks might bother you.

00:24:25.940 --> 00:24:32.490
So if it does bother you, you can go into Energy Saver
preferences and turn off wake for network access.

00:24:32.490 --> 00:24:35.990
There were some USB mice that were
covered with lights to make them pretty,

00:24:35.990 --> 00:24:40.069
well when we power the bus the mice
lights up for 10 seconds every two hours.

00:24:40.069 --> 00:24:44.119
This can be a bit disconcerting if
you don't know why it's happening.

00:24:44.119 --> 00:24:48.919
The reason we do this, people ask why doesn't
the machine just go to sleep and stay asleep?

00:24:48.920 --> 00:24:51.789
What's this maintenance wake business?

00:24:51.789 --> 00:25:00.539
Well the reason is because on the global scale, if
you expect 100% reliability out to the internet,

00:25:00.539 --> 00:25:04.599
you're going to have a fragile, brittle
application that doesn't work reliably.

00:25:04.599 --> 00:25:12.059
On the global scale it's not a question of if failures
will happen, it's a question of when and how often.

00:25:12.059 --> 00:25:13.730
Let me give you an example.

00:25:13.730 --> 00:25:20.289
Say I put my machine to sleep and it registered
with the Proxy, and then there's a power outage

00:25:20.289 --> 00:25:25.759
or my Base Station crashes, or I update the firmware
of my Base Station, if you've rebooted it...

00:25:25.759 --> 00:25:29.589
it's forgotten about all of its
clients that it's proxying for.

00:25:29.589 --> 00:25:35.759
If the sleeping server stays asleep forever,
expecting the world to remain perfect all around it,

00:25:35.759 --> 00:25:39.349
it's now off the network for good
and nothing is going to wake it again

00:25:39.349 --> 00:25:42.089
because nothing knows that it's there to be woken.

00:25:42.089 --> 00:25:48.839
If this server is up at your vacation house
in the woods that's eight hours drive away,

00:25:48.839 --> 00:25:52.899
having to drive there to manually wake
it up to fix it is a big inconvenience.

00:25:52.900 --> 00:25:57.509
So we need network devices to be self-healing.

00:25:57.509 --> 00:26:03.079
Outages can cause some destruction for a
time, but we need things eventually to heal.

00:26:03.079 --> 00:26:09.129
We could debate whether it's five minutes or five
hours or 50 hours, but it does have to self-heal

00:26:09.130 --> 00:26:12.610
at some time if we want this to be a useful service.

00:26:12.609 --> 00:26:15.240
Failures can happen the other way as well.

00:26:15.240 --> 00:26:21.180
Say my laptop registers with your Sleep Proxy, and then
I yank the Ethernet and walk away and leave your house.

00:26:21.180 --> 00:26:24.900
You don't want your Sleep Proxy
advertising a phantom service

00:26:24.900 --> 00:26:29.400
on your network indefinitely, forever after it's gone.

00:26:29.400 --> 00:26:34.740
So the Sleep Proxy works a bit like a DHCP server.

00:26:34.740 --> 00:26:42.079
A DHCP server doesn't give you an IP address forever, it
gives you a lease and says here's your address for 4 hours,

00:26:42.079 --> 00:26:44.519
if you don't renew it after 4 hours I'm claiming it back.

00:26:44.519 --> 00:26:49.629
And the Sleep Proxy does the same thing, it says
I will proxy for you for a certain length of time,

00:26:49.630 --> 00:26:52.490
but if I don't hear from you again
I'm going to assume you're gone.

00:26:52.490 --> 00:27:00.099
So in both directions does this periodic just checking
in, yes I'm still here, everything is still fine.

00:27:00.099 --> 00:27:09.599
If this seems a bit odd to you, I think it would
be helpful if I explain how this is the first step

00:27:09.599 --> 00:27:13.129
on a path to more fine-grained power managements.

00:27:13.130 --> 00:27:18.390
What we're looking at doing long term is getting away

00:27:18.390 --> 00:27:23.380
from the current monolithic view that
your Mac is asleep, or it's awake.

00:27:23.380 --> 00:27:26.600
Historically before we had laptops, computers are always on.

00:27:26.599 --> 00:27:31.409
And then we had laptops and we had these mechanisms to
put them sleep, and it was kind of a forcible thing.

00:27:31.410 --> 00:27:36.540
The idle time expires and you whack the thing on the
head and knock it unconscious and you hope it stays down.

00:27:36.539 --> 00:27:44.129
Well as time evolves and we're all much
more savvy about power management on laptops

00:27:44.130 --> 00:27:47.870
and phones and even desktop computers saving power.

00:27:47.869 --> 00:27:50.009
It's time to reverse that model.

00:27:50.009 --> 00:27:54.460
The machine is not awake unless
there's a reason to go to asleep.

00:27:54.460 --> 00:28:00.759
The default state is asleep unless there's a
reason to be awake, and we have a set of reasons.

00:28:00.759 --> 00:28:05.339
The user has moved the mouse in the last
five minutes might be a reason to be awake.

00:28:05.339 --> 00:28:09.119
I'm currently printing a document with
printer sharing, is a reason to be awake.

00:28:09.119 --> 00:28:13.379
I'm serving iTunes music to Apple
TV is a reason to be awake.

00:28:13.380 --> 00:28:19.460
You take the set of reasons to be awake, when that set
becomes empty there's no reason to be awake anymore.

00:28:19.460 --> 00:28:23.840
So you go to sleep immediately, there's
no need to wait for an idle timeout.

00:28:23.839 --> 00:28:29.069
We're not there yet, but I'm just showing you a
view of where we're trying to go in the future,

00:28:29.069 --> 00:28:33.599
and the maintenance wake is just
the first step along that journey.

00:28:33.599 --> 00:28:39.789
And I talked about having a set of reasons
to be awake, we want to do that not just

00:28:39.789 --> 00:28:42.990
on a systemwide basis, but on a per component basis.

00:28:42.990 --> 00:28:47.700
We have a set of reasons for the disk to be
awake, a set of reasons for the screen to be lit.

00:28:47.700 --> 00:28:52.049
Printer sharing or iTune sharings are
not reason for the screen to be lit.

00:28:52.049 --> 00:28:56.200
So this fine grained power management
becomes on a per component basis.

00:28:56.200 --> 00:28:59.600
On an 8-core machine maybe you
only need one core powered on.

00:28:59.599 --> 00:29:08.319
So if we succeed at this the question "is my machine
asleep or awake" will no longer be a well defined term,

00:29:08.319 --> 00:29:14.689
because each component in the system will always be in
the lowest power state it can be to meet the user's needs,

00:29:14.690 --> 00:29:22.180
and maintenance wake is the first
glimmer of that future plan.

00:29:22.180 --> 00:29:25.049
I need to tell you about some limitations.

00:29:25.049 --> 00:29:26.480
We don't support USBs in that...

00:29:26.480 --> 00:29:29.769
on the MacBook Air right now.

00:29:29.769 --> 00:29:36.289
Wake on Wireless is only on currently shipping machines,
and because it's so new it requires an Apple Base Station,

00:29:36.289 --> 00:29:40.579
none of the third party base stations
support Wake on Wireless yet.

00:29:40.579 --> 00:29:45.029
The sleeping server must be on AC power, you
can use a laptop but not if it's on battery

00:29:45.029 --> 00:29:48.099
because we don't want remote access
to run your battery down.

00:29:48.099 --> 00:29:54.669
And similarly laptops need to have a screen
available, and this is a requirement enforced deep

00:29:54.670 --> 00:29:59.650
in the power management code, that we assume for you to wake

00:29:59.650 --> 00:30:04.440
up a laptop you must either have the screen
open or you must have an external display.

00:30:04.440 --> 00:30:09.559
And in the future we may remove that limitation,
but for now in Snow Leopard that's a limitation.

00:30:09.559 --> 00:30:16.059
So if you want to access your iTunes collection on
your laptop when you get home, put it on your desk,

00:30:16.059 --> 00:30:18.329
connect the power, open the lid, and then you can walk away.

00:30:18.329 --> 00:30:21.679
But if you leave the lid closed, it's not wakeable.

00:30:21.680 --> 00:30:28.789
And our last limitation, which we hope to fix but we didn't
quite get to it in time for the Snow Leopard seed you have,

00:30:28.789 --> 00:30:33.299
is the proxy does not capture IPv6 traffic.

00:30:33.299 --> 00:30:40.700
So if you want to do the SSH trick, use SSH-4 to make
a v4 connection because if you make a v6 connection,

00:30:40.700 --> 00:30:43.330
which it will by default on the local network,

00:30:43.329 --> 00:30:49.470
then the proxy won't capture those packets
and won't wake the sleeping server.

00:30:49.470 --> 00:30:54.920
So what do you need to do as developers to
get the benefits of this great technology?

00:30:54.920 --> 00:31:02.590
I think you know the answer - just carry on using
the Bonjour APIs and you get all of this for free.

00:31:02.589 --> 00:31:10.009
So with that, I'd like to ask Rory to come up and tell
you about Bonjour over Bluetooth as used by the Game Kit.

00:31:10.009 --> 00:31:16.089
[ Applause ]

00:31:16.089 --> 00:31:16.589
>> Thank you Stewart.

00:31:16.589 --> 00:31:19.379
Thank you all for being here this morning.

00:31:19.380 --> 00:31:25.860
Peer-to-peer, I'm sure all of you have heard about this.

00:31:25.859 --> 00:31:31.189
In the Keynote you may have even been at
the Game Kit session just before this one.

00:31:31.190 --> 00:31:33.150
What is it?

00:31:33.150 --> 00:31:34.960
How does it work?

00:31:34.960 --> 00:31:38.829
You probably already know that we use Bluetooth now.

00:31:38.829 --> 00:31:43.869
Peer-to-peer on iPhone OS 3.0 is
implemented using Bluetooth.

00:31:43.869 --> 00:31:46.469
But do you need to know about the Bluetooth APIs?

00:31:46.470 --> 00:31:53.839
Do you need to know how to tell the Bluetooth radio to
send your packets to advertiser services to do any of that?

00:31:53.839 --> 00:31:56.000
No, you just use Bonjour.

00:31:56.000 --> 00:31:58.789
But let's take a step back.

00:31:58.789 --> 00:32:02.809
What did Stewart say at the beginning of the presentation?

00:32:02.809 --> 00:32:14.429
Bonjour is to make IP networking over things
like Ethernet and Wi-Fi, as easy as USB.

00:32:14.430 --> 00:32:18.049
Bluetooth typically you have to do things like pairing.

00:32:18.049 --> 00:32:23.819
On Wi-Fi networks you have to know
which Wi-Fi network to be attached to.

00:32:23.819 --> 00:32:30.359
If I want to play my Wi-Fi game, or my Bonjour
enabled game on the iPhone OS right now with you,

00:32:30.359 --> 00:32:33.799
we both have to be attached to the same Wi-Fi network.

00:32:33.799 --> 00:32:35.419
But which one do I choose?

00:32:35.420 --> 00:32:43.420
There are so many to choose, we have to make sure we
choose the right one, it's a difficult problem to solve.

00:32:43.420 --> 00:32:46.360
So Bonjour is now going to take this a step further.

00:32:46.359 --> 00:32:52.829
We're going to use unpaired Bluetooth so that
you're users don't have to worry about pairing.

00:32:52.829 --> 00:32:59.869
The normal Bonjour APIs are what make this
possible, because of the things that Steward said

00:32:59.869 --> 00:33:03.539
about separating, browsing from resolving.

00:33:03.539 --> 00:33:06.349
We'll get into that in just a second.

00:33:06.349 --> 00:33:08.449
How is it the same?

00:33:08.450 --> 00:33:10.370
We use the same APIs.

00:33:10.369 --> 00:33:17.349
NSNetServices, if you're using Cocoa Touch,
CFNetServices if you're in the Core Foundation layer,

00:33:17.349 --> 00:33:24.279
and you can use a dns_sd.h APIs if you want
to get all the way down to the C layer.

00:33:24.279 --> 00:33:26.639
Your code will just work.

00:33:26.640 --> 00:33:30.680
If you have Bonjour code right now, it will just work.

00:33:30.680 --> 00:33:37.779
In fact when we were developing this, we used the
WYTAP sample to make sure that it worked.

00:33:37.779 --> 00:33:42.740
How is it different?

00:33:42.740 --> 00:33:46.329
Resolves might take a little bit longer now.

00:33:46.329 --> 00:33:52.649
Bonjour actually automatically brings up a Bluetooth PAN
connection, that's Bluetooth personal area networking.

00:33:52.650 --> 00:33:56.990
It's an IP connection over Bluetooth.

00:33:56.990 --> 00:34:06.089
Bonjour is designed to make IP over Ethernet as easy to
use as USB, and now we've extended that to Bluetooth.

00:34:06.089 --> 00:34:12.299
Your existing IP services can now
use Bluetooth on iPhone OS 3.0.

00:34:12.300 --> 00:34:16.500
But the PAN connection takes a
little bit of time to bring up.

00:34:16.500 --> 00:34:19.909
The Bluetooth layer has to negotiate,
has to bring these things up,

00:34:19.909 --> 00:34:23.670
so you might have to wait for the
resolve to take a little while.

00:34:23.670 --> 00:34:29.059
So back to something Stewart said earlier,
let the user decide when they're done waiting.

00:34:29.059 --> 00:34:32.059
Use ResolveWithTimeout:0.0.

00:34:32.059 --> 00:34:35.070
This is the NSNetServices API.

00:34:35.070 --> 00:34:38.650
This will allow your user to decide
when they've waited long enough,

00:34:38.650 --> 00:34:44.789
tell them that something's going on
but let them decide; and that's it.

00:34:47.530 --> 00:34:51.160
Let's talk about browse versus resolve again.

00:34:52.329 --> 00:34:57.900
Bonjour is designed specifically
to separate browse versus resolve.

00:34:57.900 --> 00:35:03.930
When you browse you get a little bit
of information about a lot of services.

00:35:03.929 --> 00:35:07.190
You get the name of all the services.

00:35:07.190 --> 00:35:10.889
With Bonjour over Bluetooth, this is
done before the PAN connection comes up.

00:35:10.889 --> 00:35:14.480
We get you the names of the services
and potentially the text records,

00:35:14.480 --> 00:35:20.260
if you want that extra information,
before the IP connection comes up.

00:35:20.260 --> 00:35:26.270
Once you resolve, Bonjour gets you a
lot of information about one service;

00:35:26.269 --> 00:35:29.090
the host name, the IP address, the port number.

00:35:29.090 --> 00:35:36.500
And it also brings up the Bluetooth PAN connection, the
act of resolving brings up the Bluetooth PAN connection.

00:35:36.500 --> 00:35:42.420
But it's a little bit heavyweight to
bring up the Bluetooth PAN connection,

00:35:42.420 --> 00:35:47.059
so you don't want to resolve everything
you get back when you browse.

00:35:47.059 --> 00:35:52.059
Over normal Bonjour, that's inefficient.

00:35:52.059 --> 00:35:58.279
Bonjour over Bluetooth, it's even more inefficient because
you have to bring up the PAN connections to all the devices

00:35:58.280 --> 00:36:02.710
that are around you that have the services
potentially that you're looking for.

00:36:05.289 --> 00:36:08.860
In general, do the right thing.

00:36:08.860 --> 00:36:11.090
Browse is distinct from resolve.

00:36:11.090 --> 00:36:17.400
Don't resolve each service, don't connect to each
service, let you user decide which service they want

00:36:17.400 --> 00:36:19.829
to connect to, and connect them to that service.

00:36:19.829 --> 00:36:23.539
Resolve that service, it'll automatically
bring up the Bluetooth PAN connection,

00:36:23.539 --> 00:36:28.099
it'll automatically get you the IP address for that
Bluetooth PAN connection, and you can just use it.

00:36:28.099 --> 00:36:38.029
In fact the NS APIs, if you look at the WYTAP
sample, it uses the Get InputStream OutputStream method

00:36:38.030 --> 00:36:41.330
to get you the input stream and the output
stream, that will automatically bring

00:36:41.329 --> 00:36:44.420
up everything for you after you've resolved.

00:36:44.420 --> 00:36:52.960
So some of you might be wandering whether
to use the Game Kit, or the Bonjour APIs?

00:36:52.960 --> 00:36:56.139
So the Game Kit does provide a nice UI.

00:36:56.139 --> 00:37:05.369
The Peer Picker UI in the Game Kit is a UI that's standard
from Apple that you can use to do Bonjour over Bluetooth.

00:37:05.369 --> 00:37:11.859
It will also ask your users if they want to
enable Bluetooth, and it'll warn your users

00:37:11.860 --> 00:37:16.890
if they're using a device that doesn't have the
capability to do peer to peer over Bluetooth.

00:37:16.889 --> 00:37:20.789
Game Kit cons - it's Bluetooth only, no Wi-Fi.

00:37:20.789 --> 00:37:27.179
The Bonjour APIs, especially the CF layer and
the NS layer, don't care whether it's Bluetooth

00:37:27.179 --> 00:37:30.460
or Wi-Fi, it'll find you services on both.

00:37:30.460 --> 00:37:34.159
Bluetooth is also not available in the
simulator, you have to use two devices

00:37:34.159 --> 00:37:37.769
for testing the actual Bluetooth connectivity.

00:37:40.150 --> 00:37:43.900
So which devices are actually supported?

00:37:43.900 --> 00:37:47.980
So Bonjour over Wi-Fi works on
all the iPhone OS 3.0 devices.

00:37:47.980 --> 00:37:54.380
Bluetooth is not supported on the iPod touch
first generation, or the iPhone first generation.

00:37:54.380 --> 00:37:58.130
But it's supported on the other three.

00:37:58.130 --> 00:38:01.059
Now there are some coexistence issues.

00:38:01.059 --> 00:38:05.190
There's only room in the device for one antenna.

00:38:05.190 --> 00:38:10.789
So the Bluetooth and the Wi-Fi hardware use the same
antenna, and there's a bit of a coexistence issue.

00:38:10.789 --> 00:38:15.389
If Bluetooth wants to use the antenna and Wi-Fi wants to use
the antenna at the same time, you might have some issues.

00:38:15.389 --> 00:38:19.049
The general advice on this...

00:38:19.050 --> 00:38:25.050
you don't have to do a browse or an advertise,
unless your user actually wants to do that.

00:38:25.050 --> 00:38:28.900
If you're running a game or something and
you're actually active in the game play,

00:38:28.900 --> 00:38:35.180
we suggest that you don't leave your advertise running,
and don't leave your browsers running in the background.

00:38:35.179 --> 00:38:43.210
You don't have enough UI to show them what you found over
the browsers anyway, you don't have enough real estate to do

00:38:43.210 --> 00:38:47.210
that typically, you want to use the whole screen
for your game, for your application, whatever it is.

00:38:47.210 --> 00:38:53.389
So we suggest that you do not browse and
advertise while you're actually in your game play,

00:38:53.389 --> 00:38:57.509
or while your app is doing things, specifically
because of some of these coexistence issues.

00:38:57.510 --> 00:39:01.540
Now we are working to make these coexistence issues better,
but we wanted to make sure that you guys know about it

00:39:01.539 --> 00:39:03.480
when you're developing your cool applications right now.

00:39:03.480 --> 00:39:08.010
With that, back to Stewart.

00:39:08.010 --> 00:39:16.650
[ Applause ]

00:39:16.650 --> 00:39:17.519
>> Thank you Rory.

00:39:17.519 --> 00:39:23.340
We have a couple of little tidbits for you.

00:39:23.340 --> 00:39:24.920
One is negative answers.

00:39:24.920 --> 00:39:31.079
In the original design of multicast DNS 10 years ago,
we had this model that there are no negative answers

00:39:31.079 --> 00:39:34.159
in multicast DNS, there are only positive answers.

00:39:34.159 --> 00:39:39.049
When you multicast a query on the network
saying "are there any printers out there?"

00:39:39.050 --> 00:39:44.470
the things that are printers can
say positively "yes I'm a printer".

00:39:44.469 --> 00:39:49.909
But there's no entity out there that can say
authoritatively "no there are no printers."

00:39:49.909 --> 00:39:59.409
That logic seemed to make sense, and it does make sense
except for one little detail and that's IPv6 addresses.

00:39:59.409 --> 00:40:06.299
If a device has claimed ownership of a host name,
it has that host name, it has address records,

00:40:06.300 --> 00:40:15.960
but it has no IPv6 address records because it doesn't have
IPv6, then it is in a position to know authoritatively

00:40:15.960 --> 00:40:23.429
that if somebody queries for that host name, for
the IPv6 records, it can say "no this is my name

00:40:23.429 --> 00:40:28.069
and I know I don't have v6", so don't
retransmit, don't keep asking, don't timeout,

00:40:28.070 --> 00:40:32.710
I'm telling you now - there are
no answers for that question.

00:40:32.710 --> 00:40:39.920
So in Snow Leopard we now have a way of encoding
that on the wire, we use DNS NSEC records,

00:40:39.920 --> 00:40:48.250
so you can now get negative answers without timing out,
you can get an immediate authoritative negative answer.

00:40:48.250 --> 00:40:53.719
And if you want to get those new
results, pass the ReturnIntermediates flag

00:40:53.719 --> 00:40:55.899
to tell the API that you want the new results.

00:40:55.900 --> 00:40:59.920
If you don't pass that flag, you
only get positive results as before,

00:40:59.920 --> 00:41:03.230
but if you pass that flag you'll also
get informed of negative results.

00:41:03.230 --> 00:41:07.780
The other bit of news is...

00:41:07.780 --> 00:41:14.090
mDNS responder, the Bonjour daemon, is now the
systemwide DNS resolver for the whole system.

00:41:14.090 --> 00:41:19.269
And the reason we did this is because
in older versions of Mac OS,

00:41:19.269 --> 00:41:24.039
there were different bits of code
on the system doing DNS lookups.

00:41:24.039 --> 00:41:26.739
There was lib.resolve, there was directory services,

00:41:26.739 --> 00:41:34.689
there was Bonjour doing its own wide area Bonjour
unicast DNS queries, and there were different caches.

00:41:34.690 --> 00:41:37.200
And the caches could potentially get out of sync.

00:41:37.199 --> 00:41:42.269
One way they could get out of sync is if
the IP address of your machine changes,

00:41:42.269 --> 00:41:46.880
then Bonjour will multicast announcements to
all your peers saying this is my new address.

00:41:46.880 --> 00:41:51.410
And Bonjour on those peers will see
those announcements and update its cache

00:41:51.409 --> 00:41:55.210
with the new data, but directory services won't.

00:41:55.210 --> 00:41:59.320
So depending on which API you use,
you could get inconsistent results.

00:41:59.320 --> 00:42:01.760
Well in Snow Leopard we've fixed that.

00:42:01.760 --> 00:42:08.500
One resolve of the system, one cache,
consistent results, no matter which API you use.

00:42:08.500 --> 00:42:13.750
What this means is if you disable mDNS
Responder, you don't just lose Bonjour now,

00:42:13.750 --> 00:42:18.829
you lose systemwide DNS as well; so don't do that.

00:42:18.829 --> 00:42:25.779
Tips and reminders for developers, these
are things I'm going to talk about.

00:42:25.780 --> 00:42:28.040
Use asynchrony.

00:42:28.039 --> 00:42:30.159
Don't do blocking calls.

00:42:30.159 --> 00:42:32.449
Networking is frequently unreliable.

00:42:32.449 --> 00:42:35.879
In your lab on Ethernet it may be
perfect, but in the real world,

00:42:35.880 --> 00:42:39.670
especially with wireless devices,
it's frequently not perfect.

00:42:39.670 --> 00:42:45.740
And the user just staring at a
nonresponsive app is very frustrating.

00:42:45.739 --> 00:42:50.039
And because of that, on the iPhone
if your main thread doesn't respond

00:42:50.039 --> 00:42:53.239
to events for 20 seconds, your  app is killed.

00:42:53.239 --> 00:42:57.009
Interesting bit of trivia here,
the DNS timeout is 30 seconds.

00:42:57.010 --> 00:42:59.810
[ Laughter ]

00:42:59.809 --> 00:43:07.519
So if you do a blocking DNS call on your main thread, and
your user is in a place with spotty network connectivity,

00:43:07.519 --> 00:43:10.849
which they all will be at some point, your app dies.

00:43:10.849 --> 00:43:12.369
You don't want that.

00:43:12.369 --> 00:43:17.449
Use some of the asynchronous models, use
CFHost and schedule it on your run loop.

00:43:17.449 --> 00:43:23.829
Use DNSServiceGetAddrInfo header info if you're using
the low level APIs and put that on your select loop,

00:43:23.829 --> 00:43:26.610
your kqueue loop, use Grand Central Dispatch.

00:43:26.610 --> 00:43:28.950
We have many asynchronous mechanisms.

00:43:28.949 --> 00:43:34.029
You can even schedule a separate thread and do a
block and call on that, although we don't recommend

00:43:34.030 --> 00:43:36.769
that because threads are expensive to have big stacks.

00:43:36.769 --> 00:43:42.329
Our other asynchronous call mechanisms are much more
efficient and lightweight than making a whole thread stack,

00:43:42.329 --> 00:43:47.269
and especially on a device like the iPhone,
you want to be lightweight and efficient.

00:43:47.269 --> 00:43:52.070
Creating lots and lots of threads on the iPhone
is not a way to make your application work well.

00:43:54.289 --> 00:44:00.279
A lot of other browsing UI's with other
technologies have a refresh button.

00:44:00.280 --> 00:44:01.940
Don't do that with Bonjour.

00:44:01.940 --> 00:44:06.550
The Bonjour user interface paradigm,
the list is always fresh.

00:44:06.550 --> 00:44:11.460
The user doesn't have to refresh it, and think
about the Apple apps Safari, iChat, iTunes.

00:44:11.460 --> 00:44:12.940
There's no refresh button.

00:44:12.940 --> 00:44:14.309
The list is just always live.

00:44:14.309 --> 00:44:16.219
You unplug the Ethernet, the list gets empty.

00:44:16.219 --> 00:44:18.599
You plug it back in, the list repopulates.

00:44:18.599 --> 00:44:20.630
The list is always up to date.

00:44:20.630 --> 00:44:24.190
Just do your browse and handle the add/remove events.

00:44:24.190 --> 00:44:27.860
We've seen apps that do a browse for
10 seconds, cancel it, show the list.

00:44:27.860 --> 00:44:29.740
There's no reason to do that.

00:44:29.739 --> 00:44:33.750
As long as the user is looking at
the list, keep updating it live.

00:44:33.750 --> 00:44:42.679
In the same vein, we prefer lists
in windows than pull-down menus.

00:44:42.679 --> 00:44:47.309
There are APIs for modifying menus in
place, but it's confusing to the user.

00:44:47.309 --> 00:44:51.420
They don't expect to be pulling down through
a menu and having items jumping around.

00:44:51.420 --> 00:44:57.570
And of course don't do the worst thing, which
is display the menu and don't update it,

00:44:57.570 --> 00:45:01.900
because that way if the user doesn't find what they're
looking for the first time, they have to dismiss the menu,

00:45:01.900 --> 00:45:04.269
look again, dismiss the menu, look again.

00:45:04.269 --> 00:45:09.789
That's like having a refresh button, but even worse because
there isn't even a button to click, it's even more clumsy.

00:45:09.789 --> 00:45:15.769
Every service on the network needs
a unique service identified.

00:45:15.769 --> 00:45:20.659
This is the language, this is the vocabulary
that we use to identify what we're looking for.

00:45:20.659 --> 00:45:27.009
If two applications use the same service type, the clients
might think they found things that aren't what they think.

00:45:27.010 --> 00:45:35.410
So doesn't cost anything to go to dns-sd.org/ServiceTypes
and just register your 14 character unique identifier.

00:45:35.409 --> 00:45:41.819
Originally Bonjour, when we first
shipped it, was local only.

00:45:41.820 --> 00:45:48.519
But we had plans for wide area right from the start, which
is why the browse call returns to a domain parameter.

00:45:48.519 --> 00:45:53.300
We saw some applications ignore that parameter,
and then when they resolve they pass local

00:45:53.300 --> 00:45:56.150
because they assume local is all there is.

00:45:56.150 --> 00:46:01.440
If you do that, your application won't
automatically work with Back to My Mac.

00:46:01.440 --> 00:46:03.130
Think this is not hard?

00:46:03.130 --> 00:46:06.039
When you get the browser result, you get Name, Type, Domain.

00:46:06.039 --> 00:46:13.480
Store all three and pass all three
unchanged to the resolve call.

00:46:13.480 --> 00:46:16.940
Similarly don't assume well-known port numbers.

00:46:16.940 --> 00:46:24.900
In the original Bonjour APIs the resolve call gives you
a port number, and there's a couple of reasons for that.

00:46:24.900 --> 00:46:31.200
With fast user switching, if you've got three copies of
your application running, they can't all have the same port.

00:46:31.199 --> 00:46:38.989
If you are behind a NAT gateway using NAT port mapping,
then all the machines, they can't all have port 80 so some

00:46:38.989 --> 00:46:40.959
of them are going to have to have different ports.

00:46:40.960 --> 00:46:44.800
The Bonjour resolve core handles this
for you; it tells you the port to use.

00:46:44.800 --> 00:46:50.250
We saw some applications that ignored the port and just
used the well known port, and those applications don't work

00:46:50.250 --> 00:46:56.719
with fast user switching and with wide-area Bonjour.

00:46:56.719 --> 00:46:58.049
Those are programming tips.

00:46:58.050 --> 00:47:02.289
Some business tips - License the
Bonjour logo, it doesn't cost anything.

00:47:02.289 --> 00:47:07.769
Put it on your packaging, on your documentation,
on your website, on your literature,

00:47:07.769 --> 00:47:14.139
it advertises that your product
is easy to use to your customers.

00:47:14.139 --> 00:47:20.779
If you're building a hardware product, then if you run
the conformance test and pass it, you get to put the logo

00:47:20.780 --> 00:47:28.320
on your packaging for your hardware product;
and it is the sign of an easy user experience,

00:47:28.320 --> 00:47:32.140
not a frustrating Saturday afternoon
trying to get something to work.

00:47:32.139 --> 00:47:36.599
And even regardless of the logo, the
conformance test is a useful thing

00:47:36.599 --> 00:47:42.549
because it helps you find common programming mistakes
that we've seen in addressing, naming, discovery.

00:47:42.550 --> 00:47:50.320
If you're selling a hardware product that you sell
to Windows customers as well, you can include Bonjour

00:47:50.320 --> 00:47:56.670
for Windows which will install the Bonjour system service
and the libraries, and of course you all know Safari

00:47:56.670 --> 00:48:01.079
for Windows has the same Bonjour
browsing as Safari on the Mac.

00:48:01.079 --> 00:48:08.840
So if you have a hardware device with an embedded web server
in it, like pretty much any network printer does today,

00:48:08.840 --> 00:48:14.840
Windows users can use Safari to discover that and
configure it without having to type in IP addresses;

00:48:14.840 --> 00:48:20.400
and there's a plug-in for Explorer as well
for the Windows users who like Explorer.

00:48:20.400 --> 00:48:25.570
So now I'm going to show you a couple of demos here.

00:48:27.179 --> 00:48:34.219
This is a new piece of hardware I got just last
week, from a company called ZeroG Wireless.

00:48:34.219 --> 00:48:39.459
They make very low cost, low power, Wi-Fi chipsets.

00:48:39.460 --> 00:48:47.269
And this is a microchip development board, and
this little daughter card here is a ZeroG module.

00:48:47.269 --> 00:48:52.880
This is built so, in something like a $50 children's toy,

00:48:52.880 --> 00:48:59.430
you can put a Wi-Fi Bonjour advertised web
server into it and control it from your iPhone.

00:48:59.429 --> 00:49:02.569
There are other companies making low cost, low power Wi-Fi.

00:49:02.570 --> 00:49:08.670
It's becoming a big area, but this is the first company to
actually include Bonjour support in their developer kit.

00:49:08.670 --> 00:49:14.510
And this is brand new hardware, I got this last
week, and there's a lot of wireless around here.

00:49:14.510 --> 00:49:18.220
But let's see what happens with this.

00:49:18.219 --> 00:49:26.609
So... I'm running an application here
called Zeroconf Spy, which is actually more

00:49:26.610 --> 00:49:30.990
or less just Apple's Bonjour web
sample code which you can download.

00:49:30.989 --> 00:49:37.489
But to save you having to build it yourself, if you search
on the App Store for ZeroConf Spy then you can just...

00:49:37.489 --> 00:49:46.009
right now you can download it and install it, and this
uses Bonjour to discover Bonjour advertised web service.

00:49:46.010 --> 00:49:55.570
[ Silence ]

00:49:55.570 --> 00:50:04.470
So this is not an example UI I want to show, but if
you're building hardware, this chip has a bunch of inputs

00:50:04.469 --> 00:50:09.919
and outputs, so these are the LEDs and if I click one

00:50:09.920 --> 00:50:15.010
of these LEDs you can see back on
the device it's lit up that LED.

00:50:15.010 --> 00:50:22.420
[ Applause ]

00:50:22.420 --> 00:50:27.210
So for the hardware developers in the room,
you're saying "I want to make a device".

00:50:27.210 --> 00:50:31.880
Like can you imagine a home thermostat where you're
feeling a bit chilly, you pull out your iPhone

00:50:31.880 --> 00:50:37.210
and you hit Zeroconf Spy, thermostat UI, up a
couple of degrees without even getting off the sofa?

00:50:37.210 --> 00:50:43.150
Your iPhone becomes the universal remote
control to every device in our house.

00:50:43.150 --> 00:50:53.110
And this is not a good example UI, so I want to
show you something that I think is a nicer UI.

00:50:53.110 --> 00:50:56.910
Let's go back to Zeroconf Spy, and...

00:50:56.909 --> 00:51:06.989
this is a bit of software called Indigo,
which is home automation software.

00:51:06.989 --> 00:51:15.349
This runs on a Mac, it advertises with Bonjour,
but it advertises an iPhone friendly UI.

00:51:15.349 --> 00:51:23.759
So when you connect to this, you get
something that doesn't look like a webpage,

00:51:23.760 --> 00:51:30.010
it looks like an iPhone app with shaded buttons and

00:51:30.010 --> 00:51:46.800
[ Silence ]

00:51:46.800 --> 00:51:49.680
I'm going to wait for this to go away and we'll try again.

00:51:49.679 --> 00:51:51.989
So let me reconnect that wire.

00:51:51.989 --> 00:51:55.649
See what I mean about no refresh button?

00:51:55.650 --> 00:51:57.809
You disconnect the wire, it goes away.

00:51:57.809 --> 00:52:03.009
You plug it in, and in a few seconds
we should see that appear.

00:52:03.010 --> 00:52:19.970
[ Silence ]

00:52:19.969 --> 00:52:27.199
Alright well it looks like we're going to have to move on
there, but they have a nice UI and the thing that's nice

00:52:27.199 --> 00:52:32.099
about this is writing iPhone apps is great,
and if you want to write an iPhone app

00:52:32.099 --> 00:52:34.319
to control your device I encourage you to do that.

00:52:34.320 --> 00:52:40.870
There's lots of things you can do with a native app,
but if a customer's got a house full of devices,

00:52:40.869 --> 00:52:46.000
installing a different app for
each one may be a bit cumbersome.

00:52:46.000 --> 00:52:53.019
And the nice thing about this is you can make a
pretty slick UI using just Ajax and a webpage,

00:52:53.019 --> 00:52:55.900
and it looks like an iPhone app
except there's nothing to install.

00:52:55.900 --> 00:52:59.010
The user can just discover it and connect to it.

00:52:59.010 --> 00:53:04.120
[ Silence ]

00:53:04.119 --> 00:53:05.989
So I want to tell you, I just want to show you the things.

00:53:05.989 --> 00:53:10.529
So ZeroG Wireless is the hardware board.

00:53:10.530 --> 00:53:14.100
Perceptive Automation is the company
that makes the Indigo software,

00:53:14.099 --> 00:53:23.000
and the Zeroconf Spy iPhone app you can just search
the Zeroconf from the app store and download that.

00:53:23.000 --> 00:53:26.260
For more information, Craig Keithley is our evangelist.

00:53:26.260 --> 00:53:28.380
You can email him with questions.

00:53:28.380 --> 00:53:36.220
We have documentation on the web, both Apple
documentation at developer.apple.com/Bonjour.

00:53:36.219 --> 00:53:41.659
And the external IETF or enter information at ZeroConf.org.
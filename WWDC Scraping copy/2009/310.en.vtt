WEBVTT

00:00:13.339 --> 00:00:20.089
>> Hello. So I'm Chris Niederauer, I'm on the OpenGL
team, actually we're the GPU software team now.

00:00:20.089 --> 00:00:26.579
I'm a senior engineer there, so I was going to talk
to you today about OpenGL and what you need to do

00:00:26.579 --> 00:00:30.609
to support our platform and in particular Snow Leopard.

00:00:30.609 --> 00:00:33.979
So first I want to get into what OpenGL is.

00:00:33.979 --> 00:00:38.019
I'm sure everybody who's here is
already familiar with OpenGL,

00:00:38.020 --> 00:00:42.000
but it's basically just an API that
allows us to interact with the GPU.

00:00:42.000 --> 00:00:48.560
So these GPUs are the Graphics Processors that
accelerate 3D graphics, 2D graphics, that sort of stuff.

00:00:48.560 --> 00:00:54.530
So here we have an example: Doom 3
where it's a 3D cinematic e=xperience.

00:00:54.530 --> 00:00:56.200
And you can do...

00:00:56.200 --> 00:01:05.100
here's Google Earth, and then a lot of the user
interface elements are done as well in OpenGL.

00:01:05.099 --> 00:01:08.519
So here we have iChat, AV, and some medical imaging.

00:01:08.519 --> 00:01:15.099
And then in the bottom left the Expose and the
Window Effects, all that stuff is using OpenGL.

00:01:15.099 --> 00:01:19.669
And Core Image in the middle with the
Image Effects; all these things make it

00:01:19.670 --> 00:01:24.200
so that your user interfaces stand out from other things.

00:01:24.200 --> 00:01:33.310
So I'm not going to be getting into the OpenGL
APIs in specific, I'm going to be getting

00:01:33.310 --> 00:01:35.850
into our platform specific OpenGL stuff today.

00:01:35.849 --> 00:01:41.339
But for the actual APIs and actually
doing the drawing and all of that,

00:01:41.340 --> 00:01:47.950
there's a few books that I recommend you guys check
out; pretty common knowledge but it's the Red Book

00:01:47.950 --> 00:01:52.790
and the Orange Book - so the OpenGL Programming
Guide and the OpenGL Shading Language book.

00:01:52.790 --> 00:02:00.880
Those are good references for if you've just now learning
OpenGL, good starting material, and the 7th edition

00:02:00.879 --> 00:02:05.000
and 3rd edition, respectively, those are
going to be coming out I think in July.

00:02:05.000 --> 00:02:08.639
So if you can wait a month, check those out.

00:02:08.639 --> 00:02:12.459
And then obviously a wealth of knowledge on the internet,

00:02:12.460 --> 00:02:17.050
so you can Google anything you want
and pretty much helps you there.

00:02:17.050 --> 00:02:25.930
And then in particular we have on the ADC site we
have an OpenGL reference for Apple OpenGL stuff.

00:02:25.930 --> 00:02:30.349
And that's at developer.apple.com/opengl.

00:02:30.349 --> 00:02:37.099
So whenever you see this little book here in the
bottom right, I've got that book with the ADC on it,

00:02:37.099 --> 00:02:43.049
that means that there's some document on our
ADC site specifically about that subject.

00:02:43.050 --> 00:02:47.150
So let's get into what we are going over today.

00:02:47.150 --> 00:02:53.469
So if you read the overview, it's a lot about multiples.

00:02:53.469 --> 00:02:57.550
It's about dealing with multiple
GPUs, there's a lot of systems that...

00:02:57.550 --> 00:03:03.320
Mac Pros where you can have multiple GPUs,
being able to deal with multiple screens

00:03:03.319 --> 00:03:07.000
and for instance I'm going to go
over full screen applications

00:03:07.000 --> 00:03:13.159
There's also multithreading, going to go over that a
little bit, multiple contexts - how to share them -

00:03:13.159 --> 00:03:16.389
and finally sharing between OpenCL and OpenGL.

00:03:16.389 --> 00:03:21.059
I'm going to get into that a little bit.

00:03:21.060 --> 00:03:25.439
So first let's go over some of the new
stuff that we have in Snow Leopard.

00:03:25.439 --> 00:03:28.500
So some of the new extensions in particular here.

00:03:28.500 --> 00:03:36.379
We've got APPLE rgb 422, so this is a simple extension
which allows you to sample from a YUV texture.

00:03:36.379 --> 00:03:43.030
But unlike the YUV 422 extension that previously
existed, this one does not do the 601 color conversion.

00:03:43.030 --> 00:03:46.840
So you can do your own custom conversions for that.

00:03:46.840 --> 00:03:54.409
There's ARB color buffer float, and what that allows you to
do is it allows you to explicitly set, if clamping a float,

00:03:54.409 --> 00:03:59.699
between 0 and 1, occurs at specific stages
in the pipeline so the vertex stage,

00:03:59.699 --> 00:04:03.089
the fragment stage, and then at read pixels, at read back.

00:04:03.090 --> 00:04:14.430
ARB half float vertex, simple extension, adds the ability
to pass in an OpenGL half float type for your vertices.

00:04:14.430 --> 00:04:20.680
And then the next 2 - ARB texture
rg and ARB texture compression rgtc,

00:04:20.680 --> 00:04:27.230
are an extension for basically
single and double component textures.

00:04:27.230 --> 00:04:35.790
So RG stands for Red Green, and so it adds GL red
and GL RG, which is for Red Green component textures.

00:04:35.790 --> 00:04:40.340
So if you have like floating point
texture data that only has 2 components,

00:04:40.339 --> 00:04:44.560
you can save memory by using the RG
instead of the RGB or RGBA types here,

00:04:44.560 --> 00:04:49.970
and the texture compression just has compression for that.

00:04:49.970 --> 00:05:02.330
And then finally, texture srgb is a texturing format
that allows you to basically take advantage of precision

00:05:02.329 --> 00:05:06.019
where the gamma has the most differences
in it, so you can see...

00:05:06.019 --> 00:05:10.750
you can get a better texture precision
for the visible spectrum.

00:05:10.750 --> 00:05:18.060
And then the last 2 I noted here are
actually available already in Leopard,

00:05:18.060 --> 00:05:21.329
but they're relatively new so I wanted to just mention them.

00:05:21.329 --> 00:05:26.599
So there is EXT framebuffer blit,
and EXT framebuffer multisample.

00:05:26.600 --> 00:05:33.560
They simply allow you to be able to do
multisamples with your frame buffer objects.

00:05:33.560 --> 00:05:39.990
So let's dive into working with multiple GPUs.

00:05:39.990 --> 00:05:44.420
So recently we've been shipping a lot of
computers that have multiple GPUs in them,

00:05:44.420 --> 00:05:51.360
and in fact as of recently the MacBook Pros
have shipped standard with 2 GPUs in them,

00:05:51.360 --> 00:05:55.790
and the built-to-order Mac Pros even have an option.

00:05:55.790 --> 00:06:04.020
It's where you can actually select 4 GPUs in your system,
and it gets sent to you straight from us just like that.

00:06:04.019 --> 00:06:07.879
So it's becoming increasingly important
that you are able to deal with these types

00:06:07.879 --> 00:06:11.060
of environments, where there's not just 1 GPU...

00:06:11.060 --> 00:06:17.019
potentially multiple displays, and so I'm
going to go over how to work with that

00:06:17.019 --> 00:06:22.389
because your app should be able
to support these environments.

00:06:22.389 --> 00:06:26.149
It's not just everyone on the MacBook.

00:06:26.149 --> 00:06:32.439
So here I want to just go over a quick example of sort of
what the idea is, what you're supposed to be doing in order

00:06:32.439 --> 00:06:38.310
to have your applications support these multiple
monitors, multiple GPUs, these sort of situations.

00:06:38.310 --> 00:06:47.199
And so here we have an example of the GLSL show piece
example, and we're running, I think that's the Gooch Shader.

00:06:47.199 --> 00:06:53.750
And so it's running on the left display in this
example, so we have a computer with 2 displays, 2 GPUs,

00:06:53.750 --> 00:07:00.240
ATI on the left here, and video on the right; not the
same vendor, but we still support this type of system.

00:07:00.240 --> 00:07:09.629
And so on the left we're rendering the teapot here on the
ATI card, but then the user can move that application,

00:07:09.629 --> 00:07:16.019
just drags it over to the other display, and at this point
basically what you want your application to be able to do,

00:07:16.019 --> 00:07:22.569
is to be able to switch this rendering from that ATI card to
the NVIDIA card because the display's faster in NVIDIA card.

00:07:22.569 --> 00:07:29.740
So as a result if you weren't to be doing the
rendering on the video card at this point,

00:07:29.740 --> 00:07:34.460
what would have to happen is the ATI card
would do the rendering, it would read back,

00:07:34.459 --> 00:07:37.909
copy it over to the NVIDIA card at
which point it could draw it there.

00:07:37.910 --> 00:07:46.250
So this saves a lot of bandwidth, it's very
efficient, and makes a very Mac-friendly application.

00:07:46.250 --> 00:07:50.410
So before I get into the details of
how you're supposed to support this,

00:07:50.410 --> 00:07:53.830
I wanted to go over the concept of virtual screens.

00:07:53.829 --> 00:08:04.620
Virtual screens is basically an index into
an OpenGL render list, so render plug-in.

00:08:04.620 --> 00:08:13.480
For instance, each hardware device is a virtual screen,
and then also the software render is a virtual screen.

00:08:13.480 --> 00:08:17.640
And so here if we have like a system with 2 GPUs,

00:08:17.639 --> 00:08:22.639
and then also we have the soft render,
we would have 3 virtual screens here.

00:08:22.639 --> 00:08:25.669
So the first 2 virtual screens point to the video cards.

00:08:25.670 --> 00:08:33.680
It doesn't matter if the same video card or the same
type of video card, or different types of video cards,

00:08:33.679 --> 00:08:37.239
it's still 1 virtual screen per device...

00:08:37.240 --> 00:08:41.720
and it has nothing to do with the number
of displays that are hooked up to it too.

00:08:41.720 --> 00:08:49.240
So here we have 3 virtual screens, and then finally
the software render is always the last virtual screen

00:08:49.240 --> 00:08:54.450
when you have a software render in your virtual screen list.

00:08:54.450 --> 00:09:00.420
And so this list is chosen by the
function call CGL choose pixel format.

00:09:00.419 --> 00:09:06.979
So when you pass in your pixel format attributes, you're
able to ensure that you get the GPUs and the software render

00:09:06.980 --> 00:09:12.210
as you're expecting, and it gives you
this list of virtual screens as a result

00:09:12.210 --> 00:09:16.300
And the setting of that virtual screen is set by...

00:09:16.299 --> 00:09:25.879
we've got functions here like CGL update context and context
update, which will implicitly update a view that's onscreen.

00:09:25.879 --> 00:09:29.600
It will implicitly update the context
with where that view is onscreen.

00:09:29.600 --> 00:09:34.750
So if you call update context after you've moved
the view from 1 display to another display,

00:09:34.750 --> 00:09:39.940
it will automatically switch your virtual
screen to the correct one at that point

00:09:39.940 --> 00:09:43.070
to render on the GPU that will be most efficient.

00:09:43.070 --> 00:09:46.879
And then also you can manually set the virtual screen

00:09:46.879 --> 00:09:52.129
by calling your CGL set virtual
screen or set current virtual screen.

00:09:52.129 --> 00:09:56.600
And then also for P buffers, although
we recommend frame buffer objects,

00:09:56.600 --> 00:10:02.600
but for P buffers you can call CGL set P
buffer, which will then attach the P buffer

00:10:02.600 --> 00:10:07.560
and attach it with a specific virtual screen.

00:10:07.559 --> 00:10:15.489
So what do you need to be doing to actually make sure
that your virtual screens are up to date basically,

00:10:15.490 --> 00:10:18.590
when you have these multiple GPUs and multiple displays?

00:10:18.590 --> 00:10:24.149
So basically what you need to be doing is maintain
your virtual screen, make sure you're on the right one.

00:10:24.149 --> 00:10:31.569
So that means both initializing the virtual screen to start
up, so if you have a context that isn't just shown onscreen

00:10:31.570 --> 00:10:39.010
for instance, you may need to associate a context
virtual screen with the correct one at that point.

00:10:39.009 --> 00:10:43.509
And then also at all the CoreGraphics
display change notifications,

00:10:43.509 --> 00:10:45.950
those are points where your virtual
screen may have changed as well.

00:10:45.950 --> 00:10:51.280
So you need to ensure that you're
tracking those notifications.

00:10:51.279 --> 00:10:56.309
And then, as I was saying earlier, surfaces
unrelated to a display need to be manually managed.

00:10:56.309 --> 00:11:02.639
So for instance if you have a P buffer and you try and
use a P buffer with a context that's shown onscreen,

00:11:02.639 --> 00:11:07.960
then you need to make sure that your P buffer's virtual
screen is matching your context's virtual screen.

00:11:07.960 --> 00:11:16.070
So here's the code for NS OpenGL view for
a subclass, it's pretty straightforward,

00:11:16.070 --> 00:11:19.740
all you have to do is overload your update function.

00:11:19.740 --> 00:11:29.080
So here, after we call super update we just get the current
virtual screen, and so the trick here is we're checking

00:11:29.080 --> 00:11:34.759
when the virtual screens change, and so its new
virtual screen does not equal old virtual screen here.

00:11:34.759 --> 00:11:39.939
We basically need to put in a little bit of
logic in our application to ensure that all...

00:11:39.940 --> 00:11:46.010
if you're switching from say NVIDIA to ATI, to make
sure you're not using NVIDIA extensions on the ATI

00:11:46.009 --> 00:11:48.759
or ATI extensions on the NVIDIA for instance.

00:11:48.759 --> 00:11:53.189
So you need to ensure that all of your
GL support that you're currently relying

00:11:53.190 --> 00:11:56.250
on is still supported on your new virtual screen.

00:11:56.250 --> 00:11:59.019
And then so...

00:11:59.019 --> 00:12:03.579
and then if you have a P buffer for instance,
this is also related to that context.

00:12:03.580 --> 00:12:09.509
So after the virtual screen changes with the onscreen
context, you want to change your P buffers to follow that.

00:12:09.509 --> 00:12:14.399
Some notes I wanted to mention,
that the P buffers and the front

00:12:14.399 --> 00:12:18.289
and back buffers are not preserved
on a virtual screen switch.

00:12:18.289 --> 00:12:24.000
So if you called update context or update,
and see that your virtual screen has changed,

00:12:24.000 --> 00:12:28.309
you may have to redraw into what you already have.

00:12:28.309 --> 00:12:32.789
Although this event should be called in your
event loop, in between your drawing anyway,

00:12:32.789 --> 00:12:38.069
so in general, in practice this isn't really an issue.

00:12:38.070 --> 00:12:43.230
And then also if you're not subclassing an NS
OpenGL view, I was saying you need to register

00:12:43.230 --> 00:12:52.090
for the display change notifications from Core Graphics,
and this update call, if you're subclassing NSOpenGLView,

00:12:52.090 --> 00:12:54.670
is already being automatically called at those

00:12:54.669 --> 00:13:01.349
So you don't need to do that if you're
just subclassing, it's pretty easy.

00:13:01.350 --> 00:13:10.330
So I also wanted to go a little bit over sharing contexts,
so here we have 3 contexts and we can see that each

00:13:10.330 --> 00:13:14.700
of them we have a system, a Mac Pro again,
it's got an ATI card, an NVIDIA card,

00:13:14.700 --> 00:13:20.950
and then also a software renderer are the
available list of virtual screens that we have.

00:13:20.950 --> 00:13:26.370
And so what we have here, if you look at the
dotted line on the right, we've got that connection

00:13:26.370 --> 00:13:33.990
to the software renderer as a virtual screen, but if we pass
into our pixel format attributes to CGL choose pixel format,

00:13:33.990 --> 00:13:40.940
we pass in KCGL PFA accelerated, and KCGL PFA no recovery.

00:13:40.940 --> 00:13:45.930
So by explicitly setting those, what that
says is that we don't want the soft renderer.

00:13:45.929 --> 00:13:53.159
So as a result that connection, that virtual screen to the
soft renderer is lost, and so the context that you create

00:13:53.159 --> 00:13:57.899
with that pixel format are only going to have
those 2 virtual screens in this situation.

00:13:57.899 --> 00:14:05.189
So as a result, you see the context on the right,
context C, because it only has 2 virtual screens

00:14:05.190 --> 00:14:10.450
and those virtual screens are not explicitly the
same as the other 2 contexts, context A and B,

00:14:10.450 --> 00:14:13.330
only context A and context B can share with each other.

00:14:13.330 --> 00:14:16.330
But context C cannot share with those 2 contexts.

00:14:16.330 --> 00:14:21.310
It could share with something similar to
it, but in general we recommend that you try

00:14:21.309 --> 00:14:25.689
and always have all virtual screens
available to you with all your contexts,

00:14:25.690 --> 00:14:27.990
because it tends to make things pretty straightforward

00:14:27.990 --> 00:14:32.649
and there's not really a reason to
not have a virtual screen supported.

00:14:32.649 --> 00:14:39.649
So sort of an opposite sort of look
at this, is with offline renderers...

00:14:39.649 --> 00:14:44.659
so we've got the same system with 2 GPUs but
note that we only have 1 display attached.

00:14:44.659 --> 00:14:50.769
So the ATI's attached to this display here, but
the NVIDIA is actually not attached to a display.

00:14:50.769 --> 00:15:00.819
So for instance, they may have a OpenCL context that
they're trying to do some computations on their second GPU.

00:15:00.820 --> 00:15:05.470
So even though they have GPUs they're not
necessarily attaching displays to them.

00:15:05.470 --> 00:15:11.320
And so by default CGL's choose pixel
format only includes the online render.

00:15:11.320 --> 00:15:17.210
It's basically virtual screens that point to
renders that are capable of rendering to the screen.

00:15:17.210 --> 00:15:20.610
So because the NVIDIA is not physically
connected to that screen,

00:15:20.610 --> 00:15:23.259
it would have to do the read back to show up on the screen.

00:15:23.259 --> 00:15:31.929
As a result it's not included in this list,
so the simple fix to this is you add KCGL PFA

00:15:31.929 --> 00:15:35.939
or NS OpenGL PFA allow offline renderers.

00:15:35.940 --> 00:15:41.870
And what this does is it tells it that you care to
include offline renderers in your virtual screen list.

00:15:41.870 --> 00:15:45.639
And this is very important, especially if
you're going to be wanting to share with OpenCL,

00:15:45.639 --> 00:15:50.039
that you have those offline renderers because
you might be doing some computations there.

00:15:50.039 --> 00:15:55.360
Or you might even want to be doing
multiple OpenGL things on each card too.

00:15:55.360 --> 00:16:01.659
So when we add allow offline renderers, we get that virtual
screen added, so here we notice we had virtual screen 0

00:16:01.659 --> 00:16:06.240
and virtual screen 1 with the ATI and the soft renderer.

00:16:06.240 --> 00:16:09.310
Since we have this new virtual screen added, the way...

00:16:09.309 --> 00:16:16.869
since it's an index into that list, we actually, the
virtual screens may actually not be the same order.

00:16:16.870 --> 00:16:23.129
So for instance we see that the ATI's actually
virtual screen index 1 now, whereas it was 0 before.

00:16:23.129 --> 00:16:26.850
So note that if you don't have
the same list of virtual screens,

00:16:26.850 --> 00:16:31.129
the indices do not necessarily
exactly correlate to each other.

00:16:31.129 --> 00:16:36.740
And also again, the last virtual screen,
virtual screen 2 here, is always a soft render.

00:16:36.740 --> 00:16:44.919
So by doing this you can also, if you were to
unplug your computer, your computer's monitor,

00:16:44.919 --> 00:16:49.959
plug it into the other GPU, you'd automatically
be able to take advantage of that second GPU

00:16:49.960 --> 00:16:53.070
because you included allow offline renderers.

00:16:53.070 --> 00:17:01.270
So our recommendation for you guys testing this stuff,
is to get a system that has 2 GPUs and 2 displays,

00:17:01.269 --> 00:17:07.839
and basically try and ensure that when you move
your application over from 1 GPU to another GPU

00:17:07.839 --> 00:17:13.849
with 2 displays hooked up, that it properly is moving
your OpenGL rendering to the other display GPU.

00:17:13.849 --> 00:17:19.639
And then also it's another thing that we do
support, and something that's very Mac-friendly,

00:17:19.640 --> 00:17:25.900
is to be able to actually unplug video card, plug-in
another video card, and so to a single display;

00:17:25.900 --> 00:17:31.660
and when that happens you want to ensure that your virtual
screens and all your rendering is still moving GPUs

00:17:31.660 --> 00:17:35.630
to the correct virtual screen at that point.

00:17:35.630 --> 00:17:45.180
So for a little bit more in depth sample code and
information on this we've got a Tech Note that just went

00:17:45.180 --> 00:17:50.740
up about couple days ago, and it's
Supporting Multiple GPUs on Mac OS X,

00:17:50.740 --> 00:17:55.150
and it should be related to the session as well.

00:17:55.150 --> 00:18:02.160
Now that I've gone over sort of how to make sure you
have multiple virtual screen title, make sure you have...

00:18:02.160 --> 00:18:04.710
you understand the concept of it.

00:18:04.710 --> 00:18:07.680
I wanted to go into full screen rendering.

00:18:07.680 --> 00:18:12.759
So full screen rendering in Snow
Leopard is actually being deprecated.

00:18:12.759 --> 00:18:16.150
What do I mean the full screen
rendering is being deprecated?

00:18:16.150 --> 00:18:23.070
What I'm saying is we have special contexts
that used to be specifically for full screen.

00:18:23.069 --> 00:18:27.779
So if you passed in a pixel format
attribute that said full screen,

00:18:27.779 --> 00:18:32.680
it would make a special context that's
only able to access a single display.

00:18:32.680 --> 00:18:37.700
And so that's bad because for the virtual
screen list, like we were talking about earlier,

00:18:37.700 --> 00:18:43.170
that virtual screen list is going to be dedicated
to that single display and only have 1 thing,

00:18:43.170 --> 00:18:45.720
which is not necessarily going to
be able to share with anything.

00:18:45.720 --> 00:18:49.460
So it doesn't interact well with multiple GPUs,

00:18:49.460 --> 00:18:55.420
and so you can't share with other contexts
necessarily when you have full screen passed in.

00:18:55.420 --> 00:18:58.970
And also those contexts, whenever
you want to switch display,

00:18:58.970 --> 00:19:01.890
you need to create those contexts again from scratch.

00:19:01.890 --> 00:19:09.580
And then also another drawback to the full
screen context, is that they cover up some

00:19:09.579 --> 00:19:12.149
of the critical dialogs that exist in the system.

00:19:12.150 --> 00:19:19.070
So now that you're hopefully not yet, but
thinking about crying that full screen's gone --

00:19:19.069 --> 00:19:22.769
let me make sure that you guys know
everything's going to be alright.

00:19:22.769 --> 00:19:28.289
So now full screen rendering, there used to be
advantages to full screen rendering basically

00:19:28.289 --> 00:19:33.759
where you'd get cache enhancements for instance,
or it would be tiling on certain video cards,

00:19:33.759 --> 00:19:37.230
or page flipping where the pointer to what's being displayed

00:19:37.230 --> 00:19:42.329
on the screen actually literally just changes
the pointer as opposed to copying data over.

00:19:42.329 --> 00:19:47.230
And so now in Snow Leopard when you create
a context that covers the full screen,

00:19:47.230 --> 00:19:50.069
it just automatically gets those benefits.

00:19:50.069 --> 00:19:56.509
It automatically goes faster, and so you get to
have a screen that's not literally full screen

00:19:56.509 --> 00:20:01.529
but just because it's covering the entire
screen you get all of these benefits for free,

00:20:01.529 --> 00:20:07.440
and you're still able to do things like
show some of those critical dialogs.

00:20:07.440 --> 00:20:14.650
So just want to go over quickly, it's pretty
straightforward, how to make a full screen covering window.

00:20:14.650 --> 00:20:26.980
And so you just make a NSWindow here for instance, that has
the main screen frame, and set the window to be that size,

00:20:26.980 --> 00:20:31.049
to be the size of the screen that you want to place it on.

00:20:31.049 --> 00:20:35.210
And then you just simply place that
window right above the menu bar.

00:20:35.210 --> 00:20:41.100
So here we're setting it to NS main menu level plus
1, and so that sets it right above the menu bar,

00:20:41.099 --> 00:20:45.809
and so we're ensuring that we're covering the entire
screen at this point; but it's still low enough

00:20:45.809 --> 00:20:49.720
that the critical dialogs are still able to appear.

00:20:49.720 --> 00:20:54.490
So I want to go over an example
of this, so got a system here...

00:20:54.490 --> 00:20:57.660
and hopefully it's showing up.

00:20:57.660 --> 00:21:02.090
Open up a program we have here
called FullScreenNSOpenGLView.

00:21:02.089 --> 00:21:07.819
So it's a subclass of NSOpenGLView
that we've hooked up to work with this.

00:21:07.819 --> 00:21:14.009
And so here we see a window that's almost full
screen, you can still see there's a menu bar here,

00:21:14.009 --> 00:21:18.599
and so we see on our card that we're
getting around 3100 frames per second.

00:21:18.599 --> 00:21:22.669
So what would you expect if I make the view slightly bigger?

00:21:22.670 --> 00:21:29.150
Usually you'd expect the framerate to go down, but as
a result of switching it to completely full screen,

00:21:29.150 --> 00:21:34.110
we've gone from around 3100 to 46, 4700 framesF per second.

00:21:34.109 --> 00:21:36.490
So why does this happen?

00:21:36.490 --> 00:21:43.160
It's because we're able to take advantage automatically
of the fact that your view is covering the full screen.

00:21:43.160 --> 00:21:50.790
And so in your normal everyday applications you're not
going to see a 3000 to 5000 frame per sPecond increase.

00:21:50.789 --> 00:21:57.740
Hopefully you're only running at 60 frames per second,
but this is a really simple straightforward application;

00:21:57.740 --> 00:22:04.500
simply doing a single draw here of that
frame rate, and so because the overhead is

00:22:04.500 --> 00:22:09.339
so low we're able to take a look at how that...

00:22:09.339 --> 00:22:12.409
is actually affected, it's slightly faster as a result.

00:22:12.410 --> 00:22:15.580
And so I was saying earlier...

00:22:15.579 --> 00:22:24.009
even though it's full screen I can still, while it's in full
screen, all those critical dialogs still show up over it.

00:22:24.009 --> 00:22:29.509
[ Silence ]

00:22:29.509 --> 00:22:32.680
[ Applause ]

00:22:32.680 --> 00:22:35.130
So full screen's hopefully a lot easier now.

00:22:35.130 --> 00:22:41.940
You don't have to be dealing with, I mean it makes it a lot
easier especially when you're working with multiple GPUs.

00:22:41.940 --> 00:22:45.440
So as I was saying, there's some deprecated API.

00:22:45.440 --> 00:22:51.600
And so as opposed to what we used to
do before, we used to have to require

00:22:51.599 --> 00:22:56.069
that you have the pixel format attribute
full screen, KCGL PFA full screen.

00:22:56.069 --> 00:23:01.200
And also you'd call the function CGL set
full screen, and those are deprecated

00:23:01.200 --> 00:23:05.850
and instead you just literally make your
window covering the full screen size.

00:23:05.849 --> 00:23:10.250
And then also I wanted to make a
note about when you are going into...

00:23:10.250 --> 00:23:17.089
when you do have a screen, when you do have a full screen
context, I was mentioning there could be page flipping

00:23:17.089 --> 00:23:24.549
and this page flipping means when you call
flush drawable, or CGL flush drawable,

00:23:24.549 --> 00:23:30.740
your back buffer contents are not guaranteed to be preserved
after flush drawable; because if you're moving the pointer

00:23:30.740 --> 00:23:34.660
that means you may have, for instance,
the last frame's data instead

00:23:34.660 --> 00:23:37.670
of what you just drew in your back buffer at that point.

00:23:37.670 --> 00:23:46.570
And so there is this pix format attribute called
backing store that preserves your backing store after,

00:23:46.569 --> 00:23:53.819
it basically guarantees you have a copy of your data, and
then you can also for instance change the backing size.

00:23:53.819 --> 00:23:56.960
So when you have things like that
that cause a copy of the data,

00:23:56.960 --> 00:23:59.420
those will actually prevent the
page flipping performance gain.

00:23:59.420 --> 00:24:03.070
And so it's recommended that you don't
depend on the back buffer contents.

00:24:03.069 --> 00:24:11.919
But you can still take advantage of it if your
application really does do that, or you could use an FBO,

00:24:11.920 --> 00:24:18.289
render to an FBO, and of course the FBO
contents will be maintained all the time.

00:24:18.289 --> 00:24:22.839
So let's go into a little bit of multithreading.

00:24:22.839 --> 00:24:30.659
So this is kind of a tricky subject, no one likes to
debug an multithreaded application, it's always...

00:24:30.660 --> 00:24:37.750
always very latent bugs that show up, happen at
different times, really hard to find out what's going on.

00:24:37.750 --> 00:24:43.920
So I want to try and go over a little bit what our
recommendations are for your applications in multithreading.

00:24:43.920 --> 00:24:52.910
So as you are all hopefully aware of already,
I wanted to just note it again though

00:24:52.910 --> 00:25:00.019
that OpenGL is not a thread safe API, at least per context.

00:25:00.019 --> 00:25:06.849
So what this means is that any context can
only have 1 thread talking to it at a time.

00:25:06.849 --> 00:25:15.359
However if you do want to be using 2 threads,
what you can do is you can have 2 contexts

00:25:15.359 --> 00:25:18.500
with 1 thread talking to each context separately.

00:25:18.500 --> 00:25:26.279
And so as a result, you could have those 2 contexts
share and for instance if you have 1 context

00:25:26.279 --> 00:25:32.509
on the main thread doing all the drawing, you could
have a second context which is sharing with it,

00:25:32.509 --> 00:25:40.029
and upload textures on the secondary
thread, upload other objects...

00:25:40.029 --> 00:25:47.349
while still maintaining thread safety by having
those 2 different contexts, 1 for each thread.

00:25:47.349 --> 00:25:53.429
And we also have some convenience
functions in OpenGL on Mac OS X,

00:25:53.430 --> 00:25:58.590
so we've got in particular here CGL
lock context and CGL unlock context...

00:25:58.589 --> 00:26:03.039
and these take the CGL context
object, and these are necessary

00:26:03.039 --> 00:26:09.170
for NS OpenGL views whenever you're doing multiple...

00:26:09.170 --> 00:26:16.890
whenever you're either using multiple threads or doing any
of your OpenGL work on a thread other than the main thread.

00:26:16.890 --> 00:26:22.710
And they're basically recursive functions that
lock your context that you're working on...

00:26:22.710 --> 00:26:28.170
and you can use them outside of NS OpenGL
as well, but they are required for NS OpenGL

00:26:28.170 --> 00:26:30.920
when you are doing the multithreaded things.

00:26:30.920 --> 00:26:38.400
And then also as of Leopard, we added
a simple ability to call CGL enable

00:26:38.400 --> 00:26:42.440
with the KCGL context enable of the MP engine.

00:26:42.440 --> 00:26:52.700
And what this does is it offloads all of your OpenGL
processing work onto a second thread, so it's automatic.

00:26:52.700 --> 00:26:59.299
So when you do that, what happens is that you're setting
up your OpenGL, all your OpenGL calls on the main thread,

00:26:59.299 --> 00:27:04.710
but they immediately return and meanwhile
OpenGL, we take care of it behind your back.

00:27:04.710 --> 00:27:09.730
We put all the computation that has to occur
onto a second thread for you automatically.

00:27:09.730 --> 00:27:15.000
You can see performance gains of 100 percent pretty easily

00:27:15.000 --> 00:27:22.140
if your application is well behaved
in terms of any synchronicity.

00:27:22.140 --> 00:27:26.730
And what I mean by this is if you have
functions that require getting things back,

00:27:26.730 --> 00:27:33.960
so like GL get there which you should never use because
we've got nice tools that allow you to break on errors.

00:27:33.960 --> 00:27:41.860
Or if you've got GL read pixels without PVO's, anything
that basically gets something back from the GPU...

00:27:41.859 --> 00:27:47.259
that's not supposed to return until
the data is valid in the return value.

00:27:47.259 --> 00:27:51.579
Anything like that will stall the multithreaded
engine, but if you avoid those types

00:27:51.579 --> 00:27:59.649
of things your application can get enormous speed
increases by using this, if you happen to be CPU bound.

00:27:59.650 --> 00:28:06.790
And then also I wanted to finally mention if you do have
OpenGL, physics, AI, those sort of things occurring,

00:28:06.789 --> 00:28:11.799
the other alternative to multithreading
OpenGL is to multithread everything else.

00:28:11.799 --> 00:28:20.980
So move the AI, move the physics, move all those to separate
threads and that way you don't have as much trouble with...

00:28:20.980 --> 00:28:25.630
that way you can maintain all of
that multithreading yourself.

00:28:25.630 --> 00:28:31.580
And finally, there's some documentation on this
that's pretty good, on the ADC documentation site.

00:28:31.579 --> 00:28:43.309
So the OpenGL Programming Guide for Mac OS X has a chapter
dedicated to multithreading in OpenGL on our platform.

00:28:43.309 --> 00:28:46.950
So now I wanted to go into OpenCL.

00:28:46.950 --> 00:28:50.759
So OpenCL is one of the new features of Snow Leopard

00:28:50.759 --> 00:28:55.129
that you guys are all probably
familiar with; pretty neat technology.

00:28:55.130 --> 00:29:02.480
What this technology does is it is also allowing us to
take advantage of the GPU in order to do computations

00:29:02.480 --> 00:29:09.390
that may not be graphically, in
particular, graphically related.

00:29:09.390 --> 00:29:18.440
But it's still important to be able to sometimes
visualize that data on the GPU using OpenGL.

00:29:18.440 --> 00:29:27.250
Working with OpenGL and OpenCL, the idea
is when OpenCL will create some data,

00:29:27.250 --> 00:29:31.650
that data's created on the CPU, and
then OpenGL you want to display it.

00:29:31.650 --> 00:29:34.620
So in OpenGL you're going to be drawing data on the GPU.

00:29:34.619 --> 00:29:42.989
So here we've got OpenCL, just a normal program that
could be using OpenCL, that creates this data on the GPU.

00:29:42.990 --> 00:29:50.289
And what we're doing here is we're reading it back to
the CPU in order to call OpenGL, to send it to OpenGL,

00:29:50.289 --> 00:29:55.909
at which point it copies it back up to the
GPU and then OpenGL's able to render from it.

00:29:55.910 --> 00:30:06.970
But this is pretty inefficient, so we've created some
methods in our version of our OpenCL implementation

00:30:06.970 --> 00:30:15.460
that allow you to easily pass this data directly
from OpenCL and use it in OpenGL, and vice versa.

00:30:15.460 --> 00:30:22.650
So meanwhile your bandwidth is not being
saturated between the CPU and the GPU.

00:30:22.650 --> 00:30:30.810
And then also the CPUs idle so it can do a
lot more things as a result of these APIs.

00:30:30.809 --> 00:30:38.319
So as you saw earlier, we had an example for those of you
that were at the Graphicss and Imaging State of the Union,

00:30:38.319 --> 00:30:46.569
we had a pretty cool example called Molecule, which would
generate a heat map for a whole bunch of molecules -

00:30:46.569 --> 00:30:49.589
basically create a texture, just
a little cube you see around it.

00:30:49.589 --> 00:30:57.939
And this was created in OpenCL, and what this application
would then do is have that data and pass it into OpenGL

00:30:57.940 --> 00:31:03.140
as a texture, and then we drew it here so
that's a pretty straightforward example,

00:31:03.140 --> 00:31:09.930
pretty simple example of how you can use
that data from OpenCL and put in OpenGL.

00:31:09.930 --> 00:31:18.940
So the basic OpenGL OpenCL interactions that we have
in order to pass this data between OpenCL and OpenGL,

00:31:18.940 --> 00:31:25.690
we've got the ability to create your CL context
from a GL context, there's also you need to be able

00:31:25.690 --> 00:31:30.940
to create buffers potentially, CL
buffers from your GL buffer objects.

00:31:30.940 --> 00:31:36.440
CL images can be created from GL textures, OpenGL textures.

00:31:36.440 --> 00:31:41.950
And then I'm going to go into how you can share
those buffers and textures between OpenGL and OpenCL,

00:31:41.950 --> 00:31:45.460
because there needs to be some synchronization there.

00:31:45.460 --> 00:31:53.600
And then finally I'm going to go over just again, how to
support multiple GPUs, how to be pretty friendly with OpenCL

00:31:53.599 --> 00:31:58.519
on multiple GPUs along with your OpenGL
app that's already hopefully being friendly

00:31:58.519 --> 00:32:02.059
with those multiple systems, multiple GPUs.

00:32:02.059 --> 00:32:06.669
So here I've got some sample code of how
you create a CL context from a GL context.

00:32:06.670 --> 00:32:09.840
And so we do all the includes for the extensions,

00:32:09.839 --> 00:32:18.399
and then the cl_gl.h header is basically all the
functionality that allows to do the CL and GL sharing.

00:32:18.400 --> 00:32:23.670
And so what an application would do next is test for that...

00:32:23.670 --> 00:32:28.050
the Apple sharing, Apple GL sharing extension in OpenCL.

00:32:28.049 --> 00:32:34.450
And although this will always be true on Mac
OS X, if you want to be multiplatform specific,

00:32:34.450 --> 00:32:37.490
your code will be basically testing for this extension.

00:32:37.490 --> 00:32:42.089
And then they would be able to
get function pointers and things

00:32:42.089 --> 00:32:47.129
like that using the normal APIs OpenCL has for extensions.

00:32:47.130 --> 00:32:53.920
So now that we've set that up, we actually are
going to create the context from the OpenGL context,

00:32:53.920 --> 00:33:03.039
and what we have added for Snow Leopard is the ability
to get basically a share group obj, a share group object,

00:33:03.039 --> 00:33:12.299
and by getting back this share group calling CGL get share
group, we're able to easily then pass this share group

00:33:12.299 --> 00:33:20.690
into the CL context to generate a CL context
which shares basically all the virtual screens

00:33:20.690 --> 00:33:24.970
with the OpenGL context that you are creating this from.

00:33:24.970 --> 00:33:30.890
And there is 1 slight exception to this which
is that there's a software path for OpenCL,

00:33:30.890 --> 00:33:38.100
so the software renderer doesn't by
default get a software path in OpenCL.

00:33:38.099 --> 00:33:45.629
So in the CL create context function call at
the bottom of this blue box, you simply add...

00:33:45.630 --> 00:33:55.410
you still pass in the property USE CGL share group, but then
you can also add in the CL software path to your context

00:33:55.410 --> 00:34:00.320
in CL create context in the context
list, or in the device ID list,

00:34:00.319 --> 00:34:04.179
in case you do actually want to
be running OpenCL on the CPU.

00:34:04.180 --> 00:34:10.710
And then finally, we can check what virtual screen...

00:34:10.710 --> 00:34:16.480
what the device ID is, the OpenCL device ID is, that
relates to the current virtual screen that you're on.

00:34:16.480 --> 00:34:26.070
So here we get CL get GL context info Apple, we call that,
and we're able to get back here - what the CL device ID is

00:34:26.070 --> 00:34:29.150
for the virtual screen that we're currently running on.

00:34:29.150 --> 00:34:33.730
So how do you share the objects between OpenGL and OpenCL?

00:34:33.730 --> 00:34:40.349
So here it's pretty straightforward, we just create here
for instance, we're creating a VBO, Vertex Buffer Object.

00:34:40.349 --> 00:34:48.269
And we just use a normal OpenGL code, Gen buffers,
Bind buffer, and passing the buffer data with a size.

00:34:48.269 --> 00:34:55.780
Then we're able to get back a CL mem
object by calling CL create from GL buffer,

00:34:55.780 --> 00:34:57.720
and because you created your context from that CL...

00:34:57.719 --> 00:35:02.929
your CL context from that GL share
group, it automatically knows

00:35:02.929 --> 00:35:05.799
which share group it's going to
be getting it's objects from.

00:35:05.800 --> 00:35:12.890
So you're just passing the vertex buffer object name
in this case, and that gets you back the CL mem object.

00:35:12.889 --> 00:35:18.639
Same sort of thing for images and textures,
you create your texture as you normally would.

00:35:18.639 --> 00:35:29.489
Then you call CL create from GL texture 2D, and so you
pass in the target, the texture level, and the texture name

00:35:29.489 --> 00:35:34.739
and that creates the CL mem object again
from that texture that you create in OpenGL.

00:35:34.739 --> 00:35:43.299
And then there's similar mechanisms in place for
GL textures 3D's, so create from GL texture 3D.

00:35:43.300 --> 00:35:50.300
Then CL create from GL render buffer, so you can
also work with render buffers; same exact idea.

00:35:50.300 --> 00:35:57.470
So then synchronizing that data between the 2, if you're
going to be creating data in OpenCL and trying to show it

00:35:57.469 --> 00:36:00.789
in OpenGL, there needs to be a
little bit of synchronization.

00:36:00.789 --> 00:36:03.449
So basically if...

00:36:03.449 --> 00:36:08.609
what you need to do is with your OpenGL context you
need to ensure that you've flushed all of your data

00:36:08.610 --> 00:36:15.269
that OpenGL has done to the GPU, all the work that
it's supposed to do to the GPU in the OpenGL context.

00:36:15.269 --> 00:36:22.159
And then what you can do is you call CL enqueue
acquire GL objects, and what this allows...

00:36:22.159 --> 00:36:30.819
what this then does is CL is able to, at this point,
render into any of those GL objects that you've created.

00:36:30.820 --> 00:36:35.150
And then when you're done with that,
you call CL enqueue release GL objects

00:36:35.150 --> 00:36:42.480
and at that point CL will automatically flush your data
and then you continue on with OpenGL with that data

00:36:42.480 --> 00:36:46.730
up to date, and it basically works both ways.

00:36:46.730 --> 00:36:49.119
You can pass data back into...

00:36:49.119 --> 00:36:55.029
from CL to GL or GL to CL by going
through this sort of pattern here.

00:36:57.619 --> 00:37:03.500
So then working with multiple GPUs,
just wanted to quickly go over this.

00:37:03.500 --> 00:37:07.380
There's also that CL get GL context
info Apple in addition to be able

00:37:07.380 --> 00:37:11.530
to giving you back the current
virtual screen's CL device ID.

00:37:11.530 --> 00:37:17.200
We're also able to get back a list of the device
ID's for each virtual screen in the system.

00:37:17.199 --> 00:37:25.009
so here we call it with CL CGL devices for supported
virtual screens, and this gives us back the array

00:37:25.010 --> 00:37:28.680
of the CL device IDs associated with those virtual screens.

00:37:28.679 --> 00:37:35.779
So in our update function that we created earlier, when
we see that that current virtual screen is changed,

00:37:35.780 --> 00:37:42.140
you see that I've added a small part where I changed the
cur device ID, so I changed my CL device ID that I'm using

00:37:42.139 --> 00:37:44.239
to be the device for that virtual screen.

00:37:44.239 --> 00:37:47.809
I've already just pre-computed
the lookup, and so I can have it

00:37:47.809 --> 00:37:52.829
for instance either match the GPU
it's going to be rendering on...

00:37:52.829 --> 00:37:59.269
which you usually have it so it matches the GPU you're
on, but you can also do things like have it render,

00:37:59.269 --> 00:38:03.789
have it do your CL computations on the
GPU that's not being used to render.

00:38:03.789 --> 00:38:11.449
So if you wanted to offload work, if you're doing a
really heavy GL view and a really heavy CL computation,

00:38:11.449 --> 00:38:16.089
you can just switch the GPUs around like
that and this API makes it pretty easy

00:38:16.090 --> 00:38:21.050
to set it up exactly how you want it to be.

00:38:21.050 --> 00:38:25.400
So then I want to go over the tools a little bit.

00:38:25.400 --> 00:38:32.690
So the tools are great on our platform for basically
helping you tweak the performance out of your applications,

00:38:32.690 --> 00:38:38.860
debugging them, so I was going to go over the
application we have which are Profiler, OpenGL Profiler,

00:38:38.860 --> 00:38:43.000
OpenGL Driver Monitor, OpenGL Shader Builder,

00:38:43.000 --> 00:38:49.690
and then also we've got some non-GL-specific
tools which are Shark and Instruments.

00:38:49.690 --> 00:38:53.619
So let's get into those a little bit.

00:38:53.619 --> 00:39:01.809
So we've got OpenGL profiler and what this is, is an
application that basically allows you to debug performance

00:39:01.809 --> 00:39:05.380
and correctness in your OpenGL applications.

00:39:05.380 --> 00:39:14.420
It's pretty useful, it's very useful because it's
specific to GL and so you're able to do things like...

00:39:14.420 --> 00:39:20.030
obviously you could set up breakpoints
on things like all the GL entrypoints.

00:39:20.030 --> 00:39:24.620
But in addition to the GL entrypoints, you can
do things like set breakpoints on GL errors,

00:39:24.619 --> 00:39:28.380
so if you ever create a GL error
there's a simple check box for that.

00:39:28.380 --> 00:39:31.220
Thread conflicts - again if you're
trying to do multithreading,

00:39:31.219 --> 00:39:34.509
you just check a check box, you can break on thread errors.

00:39:34.510 --> 00:39:41.940
Then renderer changes, and then more specifically
software fallback, like if you ever do something

00:39:41.940 --> 00:39:47.460
that the GPU is not capable of, you can
see that you're hitting software fallback,

00:39:47.460 --> 00:39:51.510
at that point look at what may have
caused you to go into that mode.

00:39:51.510 --> 00:39:56.040
And so it's useful for checking that,
like when you're moving between displays

00:39:56.039 --> 00:40:00.070
that your renderer is changing for instance.

00:40:00.070 --> 00:40:06.320
And then also it lists here, trace GL call so you
can look at all the OpenGL calls that you've made -

00:40:06.320 --> 00:40:15.289
how long they've taken, each call takes in
the application time, backtraces for that.

00:40:15.289 --> 00:40:20.090
You can look at all the GL objects,
so you can look at the textures...

00:40:20.090 --> 00:40:24.970
GLSL shaders, those sort of things;
even modify them, some of them.

00:40:24.969 --> 00:40:29.629
And then finally one of the most useful
things, you can look at the draw buffers.

00:40:29.630 --> 00:40:32.760
So you can look at the current draw
buffers - color buffer, the depth.

00:40:32.760 --> 00:40:40.420
So you can actually set breakpoints, for instance, after
all your draw calls and see as each draw does some drawing,

00:40:40.420 --> 00:40:48.539
see exactly where something may go wrong and
make some corrective actions based on that.

00:40:48.539 --> 00:40:53.230
And then Driver Monitor, let's get into that.

00:40:53.230 --> 00:41:00.349
So Driver Monitor is a little bit more
advanced of a tool, it's very easy to use

00:41:00.349 --> 00:41:04.380
but at the same time it's got a lot
of parameters that are very useful.

00:41:04.380 --> 00:41:14.789
So what it's able to do is show you things like CPU
stalls or if you're leaking memory, those sort of things.

00:41:14.789 --> 00:41:21.679
I just wanted to go over quickly some of the
driver statistics that we tend to always stick

00:41:21.679 --> 00:41:24.210
in when we're looking at an OpenGL Driver Monitor.

00:41:24.210 --> 00:41:29.860
So some of the basic ones that we recommend
everyone has when they're looking at these.

00:41:29.860 --> 00:41:33.510
So for the first one, CPU wait for GPU.

00:41:33.510 --> 00:41:39.550
If you enable this parameter you basically can
see how long the CPU is waiting for the GPU.

00:41:39.550 --> 00:41:40.789
It's pretty straightforward.

00:41:40.789 --> 00:41:47.130
So you can see if some operations, if you're fragment
bound you'll probably see your CPU wait for GPU go way up.

00:41:47.130 --> 00:41:51.710
Or if you're trying to draw faster than 60 frames per
second, which you shouldn't do because the display...

00:41:51.710 --> 00:41:53.980
well faster than the display refresh rate.

00:41:53.980 --> 00:41:56.110
You shouldn't be drawing faster than that.

00:41:56.110 --> 00:42:03.390
But if you were to be drawing faster than that,
you might see this also pop up for instance.

00:42:03.389 --> 00:42:08.509
Then there's current free video memory, so
you can look, make sure that you're not going

00:42:08.510 --> 00:42:12.220
over your limits of the memory that your system has.

00:42:12.219 --> 00:42:17.849
So if you have 128 megabyte video card and
you're trying to load lots of textures,

00:42:17.849 --> 00:42:19.710
you'll be able to watch that the memory's going...

00:42:19.710 --> 00:42:21.470
see what your memory's at.

00:42:21.469 --> 00:42:25.699
Hopefully it doesn't fluctuate, but it stays
steady after you've loaded all your textures.

00:42:25.699 --> 00:42:30.989
And then finally we've got surface page
off data, and texture page off data.

00:42:30.989 --> 00:42:34.219
And so if you're over saturating,
trying to over saturate your VRAM,

00:42:34.219 --> 00:42:37.739
you may see that surfaces, or textures are being paged off.

00:42:37.739 --> 00:42:42.589
So you want to try and avoid those from ever getting high.

00:42:43.909 --> 00:42:48.170
So OpenGL Shader Builder, pretty straightforward tool.

00:42:48.170 --> 00:42:53.220
It allows you to create ARB for vertex
programs, ARB fragment programs,

00:42:53.219 --> 00:42:58.089
and then GLSL vertex, geometry, and fragment shaders.

00:42:58.090 --> 00:43:05.750
So you can look at all your, what your programs
generate, tweak the parameters on the fly,

00:43:05.750 --> 00:43:11.750
and then also you can even benchmark what your performance
is going to be like right in these applications.

00:43:11.750 --> 00:43:14.920
A pretty useful app.

00:43:14.920 --> 00:43:22.139
And then outside of the GL-specific tools, again
I was mentioning Shark's a pretty useful tool.

00:43:22.139 --> 00:43:27.500
What Shark allows you to do is profile
your code, it automatically profiles code

00:43:27.500 --> 00:43:32.030
without ever having to add specific hooks into Shark.

00:43:32.030 --> 00:43:37.220
It just automatically looks straight
into what your application is doing,

00:43:37.219 --> 00:43:41.989
and gives you like where you're spending most of your time.

00:43:41.989 --> 00:43:48.759
There's some symbols in particular however, that are
useful to be looking out for in your OpenGL applications.

00:43:48.760 --> 00:43:51.880
So the first symbol here we've got, was actually a library.

00:43:51.880 --> 00:43:57.599
The software render, if you see
GL render a float as a library...

00:43:57.599 --> 00:44:02.139
this means that you're probably falling back to software
render so it might be a fallback for some reason.

00:44:02.139 --> 00:44:05.679
So if you were to ever see that, what
we'd want to do is OpenGL Profiler,

00:44:05.679 --> 00:44:14.460
break on that software fallback break button, and you
can then from there figure out what you're trying to do

00:44:14.460 --> 00:44:20.760
that the GPU doesn't support, and get rid
of that software fallback as a result.

00:44:20.760 --> 00:44:24.950
Second thing here, RTC symbols;
so Run Time Compiled symbols.

00:44:24.949 --> 00:44:29.529
OpenGL has some Run Time Complied
code that it creates on the fly.

00:44:29.530 --> 00:44:36.470
For instance if you're trying to upload a texture
in RGB and it's converting its RGBA for OpenGL,

00:44:36.469 --> 00:44:39.939
that will cause some code to be
generated that will do that conversion.

00:44:39.940 --> 00:44:49.110
Even if you have RGBA versus BGRA, like the endianness
swapping is going to cause some RTC symbols to be made

00:44:49.110 --> 00:44:54.380
by our use of the LVM compiler that we use in OpenGL.

00:44:54.380 --> 00:44:58.869
And so these are going to show up as
just an address that's basically unknown.

00:44:58.869 --> 00:45:04.190
And so I have actually, in this particular trace,
I don't know if you can see it pretty easily.

00:45:04.190 --> 00:45:07.929
I have a library right here, the gl renderer float.

00:45:07.929 --> 00:45:12.899
And then the RTC, we've got the
unknown library coming from OpenGL.

00:45:12.900 --> 00:45:19.760
So those symbols can be pretty much eliminated
once you figure out where they're coming from.

00:45:19.760 --> 00:45:24.230
And then finally another, if you're
using the multithreaded engine,

00:45:24.230 --> 00:45:27.449
there is a function called gle finish command buffer.

00:45:27.449 --> 00:45:32.980
What this function does, what this is doing
is it means that your multithreaded engine,

00:45:32.980 --> 00:45:37.300
you're calling some function that's
causing it to stall the command buffer.

00:45:37.300 --> 00:45:45.940
So for instance, any of the read back, like gl get error for
instance will cause a synchronization finish command buffer

00:45:45.940 --> 00:45:50.539
to be called, because it has to make sure
it computes everything that happened to see

00:45:50.539 --> 00:45:54.130
if you've actually sent an OpenGL error or not.

00:45:54.130 --> 00:45:59.800
Again, use OpenGL Profiler to just break on an error, and
then you don't need to have anything like that in there.

00:45:59.800 --> 00:46:03.130
And then 1 note - driver symbols.

00:46:03.130 --> 00:46:10.110
If you ever see driver symbols in Shark, usually they'll
show up as something like GLD get texture level plus 1, 2,

00:46:10.110 --> 00:46:14.880
3, 4, 5 you know; sort of a random thing.

00:46:14.880 --> 00:46:20.110
Even though it's not necessarily giving back
texture levels, so you might be confused by this

00:46:20.110 --> 00:46:29.120
but really we don't ship any of the symbols in the
system, and so you'll get back offsets from symbols

00:46:29.119 --> 00:46:32.529
that it does know about, which are not
necessarily actually what's happening.

00:46:32.530 --> 00:46:39.190
So just take into account that you are in the
driver, but it's not necessarily doing what

00:46:39.190 --> 00:46:43.210
that function says it's doing when
you see those driver symbols.

00:46:43.210 --> 00:46:47.139
So if you're new to Shark, I recommend
you go see the sessions.

00:46:47.139 --> 00:46:56.239
I'll tell you about the sessions very quickly, when
I go over the sessions, so they're in the future.

00:46:57.679 --> 00:47:05.519
And then also Instruments is a
final tool I'll show you guys.

00:47:05.519 --> 00:47:12.449
Instruments is basically an application visualizer,
let's you visualize what's happening in your application,

00:47:12.449 --> 00:47:16.559
and we have the OpenGL driver monitor's
statistics I was mentioning earlier,

00:47:16.559 --> 00:47:20.480
in an OpenGL Driver Monitor, are
available in Instruments as well.

00:47:20.480 --> 00:47:25.840
So you can actually put those statistics
side by side with other things like your...

00:47:25.840 --> 00:47:31.769
here we have it with a CPU monitor, so we
can see where the CPU and the GPU sort of...

00:47:31.769 --> 00:47:36.190
how the interaction occurs between
those in this application.

00:47:36.190 --> 00:47:46.559
And I just wanted to note that with the driver statistics,
the statistics that you're seeing are actually per GPU.

00:47:46.559 --> 00:47:47.759
They're not per application.

00:47:47.760 --> 00:47:55.090
So for instance if you have 2 applications running that are
both using OpenGL, the driver monitor statistics are going

00:47:55.090 --> 00:48:00.300
to be the cumulative effect of both of those applications.

00:48:00.300 --> 00:48:05.430
It's not just your 1 application
that it's able to be looking at.

00:48:05.429 --> 00:48:12.730
So with that I wanted to do a little
demo, probably everyone already saw the...

00:48:12.730 --> 00:48:20.170
the Molecules demo, at the Graphics and Media State of
the Union, or Graphics and Imaging, Graphics and Media.

00:48:20.170 --> 00:48:27.000
But in case you didn't, and I'm just going to
go over it a little bit more here too in depth.

00:48:27.000 --> 00:48:32.500
So here we've got this neat whole bunch
of molecules that are being computed,

00:48:32.500 --> 00:48:41.320
and so what we have here is actually pretty tricky
OpenGL visualization and I'm not going to get

00:48:41.320 --> 00:48:46.550
into the OpenCL parts we were showing, but
I'm going to get into the OpenGL parts.

00:48:46.550 --> 00:48:50.810
And so what we have here is actually a whole bunch of...

00:48:50.809 --> 00:48:57.299
we have a whole bunch of spheres that we're rendering here.

00:48:57.300 --> 00:49:03.900
We're doing some tricks like for instance, we have a
ambient occlusion is actually computing the light here.

00:49:03.900 --> 00:49:11.780
So you notice that we have lighting is
based on if the molecules are visible.

00:49:11.780 --> 00:49:18.769
And then also these spheres are actually being ray traced
with imposters, so there's basically a billboard for each

00:49:18.769 --> 00:49:22.389
of these spheres; a single billboard
for each of these spheres.

00:49:22.389 --> 00:49:25.969
And what's happening is there's a
GLSL fragment program that runs,

00:49:25.969 --> 00:49:30.000
that just shoots out a ray for each one of those pixels.

00:49:30.000 --> 00:49:34.849
We basically create imposters from that,
and by using this ray tracing technique

00:49:34.849 --> 00:49:39.299
in this particular application, we're able to easily do...

00:49:39.300 --> 00:49:46.130
we're able to get basically perspective
correct imposters, and also do things like look

00:49:46.130 --> 00:49:50.329
into the ambient occlusion map pretty
easily in order to do this texturing.

00:49:50.329 --> 00:49:56.559
And then also it lets us do some pretty
neat effects like here we've got...

00:49:56.559 --> 00:49:59.539
we're able to actually go into the objects...

00:49:59.539 --> 00:50:04.579
so pretty neat effect.

00:50:04.579 --> 00:50:10.840
And then also we've got a depth of field,
so we'll switch to a little simpler one.

00:50:10.840 --> 00:50:16.789
It's a sort of a depth of field effect, so it's a
little blurrier with the things that are closer,

00:50:16.789 --> 00:50:24.929
and then gets a little sharper as we put it more into focus.

00:50:24.929 --> 00:50:29.779
The way that we do some of these effects,
so with the ambient occlusion for instance,

00:50:29.780 --> 00:50:35.030
what's happening is that we're
actually computing shadow maps.

00:50:35.030 --> 00:50:39.860
But we're doing a little bit more complicated a thing
than a shadow map, we're doing a lot of shadow maps.

00:50:39.860 --> 00:50:45.519
So instead of the normal idea where you have a shadow map,
where you aim the light at the scene and you see what's

00:50:45.519 --> 00:50:51.780
in shadow, we're actually aiming lights at the scene
from a whole bunch of samples around the scene.

00:50:51.780 --> 00:51:01.720
And so by shooting these lights into there, we're able
to then take sort of the addition of all those shadows

00:51:01.719 --> 00:51:09.149
and we add them together and we create this ambient
occlusion map from that, that maps onto these spheres.

00:51:09.150 --> 00:51:10.019
It looks pretty cool.

00:51:10.019 --> 00:51:15.519
And then with the depth of field it's
pretty straightforward how that works.

00:51:15.519 --> 00:51:21.500
What the depth of field is, is we have just
2 textures that we're working with here.

00:51:21.500 --> 00:51:29.519
So we first render the scene into an FBO, so that FBO has
this back buffer, and then we take that FBO and we run it

00:51:29.519 --> 00:51:35.509
through a 2 pass shader that will do a
Gaussian blur basically, will have it 1 way

00:51:35.510 --> 00:51:38.560
and then have it the other way, applying Gaussian blur.

00:51:38.559 --> 00:51:45.480
And so we get a quarter sized texture with a bit of
blur in it, and then we look into the depth map...

00:51:45.480 --> 00:51:51.869
the depth values, at each pixel and when we do the
final render we interpolate between those 2 images

00:51:51.869 --> 00:51:55.730
to basically pick which parts of
the scenes should be in focus,

00:51:55.730 --> 00:52:00.490
and which parts of the scenes should be
out of focus for that second texture.

00:52:00.489 --> 00:52:04.489
So I'm actually going to...

00:52:04.489 --> 00:52:09.059
try and use OpenGL profiler here

00:52:10.139 --> 00:52:13.900
... and show you how to use this app, and
let's take a look at that Molecules demo.

00:52:13.900 --> 00:52:17.480
I can hear it, it might be actually launching.

00:52:17.480 --> 00:52:20.760
There we go, wow.

00:52:20.760 --> 00:52:25.560
So here this warning dialog, I wanted to note this to
everybody, this warning dialog is saying that we're going

00:52:25.559 --> 00:52:30.250
to be unable to attach to our applications...

00:52:30.250 --> 00:52:34.170
until we log out and log back in, and I'm
not going to log out and log back in here,

00:52:34.170 --> 00:52:37.730
but instead what I'm going to be doing...

00:52:37.730 --> 00:52:43.320
is enable it, but instead what I'm
going to be doing is launching...

00:52:43.320 --> 00:52:47.610
the application instead of attaching to it.

00:52:47.610 --> 00:52:53.210
So normally you can attach to your application after the
fact, and there's a list of all the applications running.

00:52:53.210 --> 00:52:56.470
But here, so you can add your application in by...

00:52:56.469 --> 00:53:05.649
you can add it through the open dialog,
or just dragging it straight in here.

00:53:05.650 --> 00:53:08.030
So let's launch this application.

00:53:09.800 --> 00:53:16.010
And I'm going to take this out of full screen
so we can debug this, make it a little smaller.

00:53:16.010 --> 00:53:22.160
[ Silence ]

00:53:22.159 --> 00:53:26.469
So we have here in the views, basically have a
list of the things that we can take a look at.

00:53:26.469 --> 00:53:33.119
So we've got trace statistics, resources, the
pixel formats that we've created, the breakpoints,

00:53:33.119 --> 00:53:41.420
you can have scripts to those breakpoints, buffers so you
can look at the current draw, current read, system buffers,

00:53:41.420 --> 00:53:45.760
and then messages to any logs that you might be logging.

00:53:45.760 --> 00:53:52.740
So here let's sort of animate that, and in
here I'm going to open up the breakpoints.

00:53:52.739 --> 00:53:56.099
So here, let's break after CGL flush drawable.

00:53:56.099 --> 00:54:00.059
So we can see here, let's zoom in a little bit

00:54:00.059 --> 00:54:04.570
so you guys can see a little bit
better, so we've got here the backtrace.

00:54:04.570 --> 00:54:11.890
We have CGL flush drawable and we see the backtraces, so
we can see if your application were to have full symbols

00:54:11.889 --> 00:54:20.819
in your source lines in here, you'd for instance see exactly
the line of code that we're calling GLUTSwapBuffers from,

00:54:20.820 --> 00:54:24.320
this happens to be a GLUT app,
but we recommend NS OpenGL View.

00:54:24.320 --> 00:54:30.210
It's just a quick demo, just happened to be written in GLUT.

00:54:30.210 --> 00:54:37.090
And so also what you can look at here, so you see we're
running on the ATI, virtual screen 0 in this case.

00:54:37.090 --> 00:54:43.010
And then here we've got the fact that we
know we're not falling back to software,

00:54:43.010 --> 00:54:46.770
we're running both the fragment and
the vertex processing on the GPU.

00:54:46.769 --> 00:54:50.380
So here I'm going to click on the state, and
then there's this handy little button here

00:54:50.380 --> 00:54:52.750
from default state, which will highlight...

00:54:52.750 --> 00:54:55.000
it'll show the changes from the default state.

00:54:55.000 --> 00:55:01.000
So here we have highlighted all the differences,
so for instance we can see that we have texture 0

00:55:01.000 --> 00:55:07.500
and texture 1 are bound, we have texture
0 bound to texture 2D with a name of 8;

00:55:07.500 --> 00:55:10.690
can look at the width and height of those textures.

00:55:13.030 --> 00:55:17.760
Color buffer, we see those draw and
reader both happening on the back buffer.

00:55:17.760 --> 00:55:24.550
Our blend mode is set to source over,
or additive, looks like additive, yeah.

00:55:26.050 --> 00:55:31.460
So... let's continue from here.

00:55:31.460 --> 00:55:36.250
So then they'll show the resources, so
I'm going to look at some resources.

00:55:36.250 --> 00:55:40.789
While we're in the break point we can look at
the textures, shaders, those sort of things.

00:55:40.789 --> 00:55:43.630
So here we can actually look at
the programs that are being run.

00:55:43.630 --> 00:55:48.820
So this looks like it might be one of the ray tracers...

00:55:48.820 --> 00:55:51.230
actually running in the program.

00:55:51.230 --> 00:55:57.539
And then the textures, we can take a look at that.

00:55:57.539 --> 00:55:59.400
And so you can see...

00:55:59.400 --> 00:56:08.460
we've got the normal texture, the FBO that we were rendering
into, we've got the first pass of that Gaussian blur,

00:56:08.460 --> 00:56:13.300
second pass of the Gaussian blur, and so we see
we have a blurrier texture as a result here.

00:56:13.300 --> 00:56:15.090
It's just a lower resolution but blurry.

00:56:15.090 --> 00:56:24.070
Also you can take a look at for instance, your depth,
so all the depth maps for instance that we're using.

00:56:24.070 --> 00:56:28.900
And then this is pretty neat, this is
actually texture atlas for all of those...

00:56:28.900 --> 00:56:33.410
each of those molecules has a texture atlas for
the ambient occlusion for the amount of light

00:56:33.409 --> 00:56:37.089
that was touching each part of those spheres.

00:56:37.090 --> 00:56:47.930
OK, so here I'm going to continue this again for a second
with the breakpoints turned off, and then there's also...

00:56:47.929 --> 00:56:49.069
statistics.

00:56:49.070 --> 00:56:52.220
So we can look at how many calls we're making.

00:56:52.219 --> 00:56:57.259
You should be using draw rays instead
of these, we just tap into again.

00:56:57.260 --> 00:57:00.090
Don't use GLUT, don't use GL vertex...

00:57:00.090 --> 00:57:02.610
this is an example of a bad application.

00:57:02.610 --> 00:57:04.620
[ Laughter ]

00:57:04.619 --> 00:57:12.960
So you can see the time, the average time per call or
even, or not per call but per different type of call.

00:57:12.960 --> 00:57:17.820
And then I wanted to show you,
let's do a break after GL end.

00:57:17.820 --> 00:57:26.000
And so we can again look at the current draw color
buffer, I'll even bring it up, let's bring up everything.

00:57:26.000 --> 00:57:29.739
That might not be useful actually, we might use the Alpha.

00:57:29.739 --> 00:57:42.479
So you can see here, when I continue I can see it changing,
and you can see what it's doing in each draw call.

00:57:42.480 --> 00:57:48.440
This first draw here is just drawing the background,
we've got a little vignette going for the background,

00:57:48.440 --> 00:57:55.700
then we draw in all the spheres with
the ray tracing, and then we actually...

00:57:55.699 --> 00:58:02.960
draw in, we sort of see it, we drew in some
cylinders to attach the spheres to each other.

00:58:02.960 --> 00:58:07.579
And then of course just doing the Gaussian
blur, and then doing the final composite.

00:58:07.579 --> 00:58:09.989
So it's pretty neat what it can do.

00:58:09.989 --> 00:58:17.029
And then of course the break on error, break on thread
conflict, software fallback renderer changes are all there,

00:58:17.030 --> 00:58:19.519
and so hopefully if you turn this on, good.

00:58:19.519 --> 00:58:24.280
We're not hitting any of those problems,
so that's just a quick look at Profiler

00:58:24.280 --> 00:58:28.430
and I think that we've got some time for Q and A.

00:58:28.429 --> 00:58:31.739
But first, some more information...

00:58:31.739 --> 00:58:37.750
Allan Schaffer is our Graphics Evangelist, so you
can contact him if you have any questions related

00:58:37.750 --> 00:58:41.269
to our platform in OpenGL - aschaffer@apple.com.

00:58:41.269 --> 00:58:46.349
The documentation of course at developer.apple.com/opengl.

00:58:46.349 --> 00:58:49.849
So you can get a lot of the things
that I was talking about earlier there.
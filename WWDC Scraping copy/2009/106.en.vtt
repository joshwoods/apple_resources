WEBVTT

00:00:13.880 --> 00:00:15.440
>> Hello everybody.

00:00:15.439 --> 00:00:17.280
Lee Collins.

00:00:17.280 --> 00:00:22.630
I'm here to talk to you today about Building
Localized Applications for the Mac and iPhone.

00:00:22.629 --> 00:00:28.009
It's really great to see such a large turns out early
on Friday morning after the big beer bash last night.

00:00:28.010 --> 00:00:32.840
[ Pause ]

00:00:32.840 --> 00:00:41.790
>> So, the first question I suppose everybody is wondering
is, why do you care about building localized applications?

00:00:41.789 --> 00:00:45.689
Well the answer for me and I assume
for most of you is more customers.

00:00:45.689 --> 00:00:48.579
Apple certainly takes this very seriously.

00:00:48.579 --> 00:00:54.670
We continue to expand our global reach with the
iPhone shipping now in more than 80 countries.

00:00:54.670 --> 00:00:59.020
Our App Stores available in more than 77 countries.

00:00:59.020 --> 00:01:04.520
And the iPhone itself is localized in
30 languages and the Mac also in 18.

00:01:04.519 --> 00:01:11.349
And our platforms also support a lot more content
in terms of being able to create documents,

00:01:11.349 --> 00:01:13.799
browse websites et cetera on other languages.

00:01:13.799 --> 00:01:22.200
So here's what it looks like for the
Mac in terms of our global coverage.

00:01:22.200 --> 00:01:32.020
So we cover Spanish, South America, Spain, Chinese,
Russian, English, French, a number of languages of to 18.

00:01:32.019 --> 00:01:36.379
And for the iPhone, it's even more.

00:01:36.379 --> 00:01:38.989
And will continue to grow over the years.

00:01:42.890 --> 00:01:49.689
And in addition to the localized languages, we support
a lot more text content browsing, searching, et cetera.

00:01:49.689 --> 00:01:54.939
For example on the iPhone you can
also do a lot in Icelandic et cetera.

00:01:54.939 --> 00:01:58.899
On the Mac even more, languages like Armenian, Cherokee,

00:01:58.900 --> 00:02:03.359
Native American language, Persian,
Tamil, Tibet and et cetera.

00:02:03.359 --> 00:02:08.719
So I'd also like to impart today our design philosophy

00:02:08.719 --> 00:02:13.539
which is basically write your application
once and make sure that it runs everywhere.

00:02:13.539 --> 00:02:16.629
This is the basis for the iPhone and Mac design.

00:02:16.629 --> 00:02:19.340
This is the philosophy that we follow.

00:02:19.340 --> 00:02:26.069
You should be able to write a single binary that
supports many localizations and any language content,

00:02:26.069 --> 00:02:29.109
and also it just run right out of the box.

00:02:29.110 --> 00:02:34.540
Of course I'm speaking metaphorically because now very
few applications are going to be shipped in boxes.

00:02:34.539 --> 00:02:44.329
Most of your applications will probably be shipped from
the App Store, purely software, but you get the idea.

00:02:44.330 --> 00:02:49.950
So let me talk about internalization and
localization which are two aspects of the process

00:02:49.949 --> 00:02:53.709
of getting your application ready for international markets.

00:02:53.710 --> 00:02:59.200
We begin with internalization which is basically
getting your code ready to be localized.

00:02:59.199 --> 00:03:04.619
And then you continue with localization
which is the data you need.

00:03:04.620 --> 00:03:13.610
Translations of user visible strings, et cetera,
that you show at runtime for local users.

00:03:13.610 --> 00:03:15.660
You need to do both.

00:03:15.659 --> 00:03:17.139
They're separate processes.

00:03:17.139 --> 00:03:20.039
But if you could only do one, start
with internationalization;

00:03:20.039 --> 00:03:25.769
get a firm foundation for localizing your application.

00:03:25.770 --> 00:03:32.280
Localization itself once you're set up with a good
internalization design, you're using all of our--

00:03:32.280 --> 00:03:38.680
the APIs we provide to help you do localization,
it could be easily outsourced to experts

00:03:38.680 --> 00:03:42.680
who know how to localize for different languages.

00:03:42.680 --> 00:03:48.819
So today I'll be talking about the interna--
internalization aspect, and my fellow employee J.

00:03:48.819 --> 00:03:48.989
J.

00:03:48.990 --> 00:03:55.460
Enser will continue talking about
the nuts and bolts of localization.

00:03:55.460 --> 00:04:03.070
So some key ideas you should be
able to take away from today's talk.

00:04:03.069 --> 00:04:06.019
Internationalization can be difficult, sure.

00:04:06.020 --> 00:04:07.110
It's a very complex thing.

00:04:07.110 --> 00:04:10.590
It's you're doing many more languages than English.

00:04:10.590 --> 00:04:12.650
Language itself is very complex.

00:04:12.650 --> 00:04:24.560
We make it a lot easier using the API that we've worked
so many years to refine and make it easy for you to adopt.

00:04:24.560 --> 00:04:30.420
Also localization and internationalization should just
be considered part of good software engineering design.

00:04:30.420 --> 00:04:32.900
It's not-- not anything special.

00:04:32.899 --> 00:04:35.599
It's just obstructing like you do with other things.

00:04:35.600 --> 00:04:42.840
You obstruct the language from your code, so you
can adapt to different language environments.

00:04:42.839 --> 00:04:50.459
So one thing you should remember is there's
a lot of code you shouldn't have to write.

00:04:50.459 --> 00:04:57.709
For example, don't write code and
let the user select a language.

00:04:57.709 --> 00:04:59.259
We already provide that for you.

00:04:59.259 --> 00:05:03.589
We provide a nice UI for that on the iPhone and the Mac.

00:05:03.589 --> 00:05:07.179
Don't write mechanisms-- mechanisms
to get localized strings.

00:05:07.180 --> 00:05:08.629
That's already built in.

00:05:08.629 --> 00:05:17.319
Don't do code for writing date-time, number
formats, that's part both the Mac OS and the iPhone.

00:05:17.319 --> 00:05:22.420
And finally, don't do separate
binaries for each localization.

00:05:22.420 --> 00:05:26.410
You should be able to follow in the
design principles I talked about today.

00:05:26.410 --> 00:05:30.560
We should be able to write a single
binary that runs for each language.

00:05:30.560 --> 00:05:41.160
So let's take a look at what you see when a user wants
to actually select a language or a region format.

00:05:41.160 --> 00:05:43.830
This is the way it looks on the iPhone.

00:05:43.829 --> 00:05:47.519
Notice that you can select the
language, in this case English,

00:05:47.519 --> 00:05:52.560
independently from the region format,
in this case Egyptian Arabic.

00:05:52.560 --> 00:05:59.189
And you could also see the kinds of things that the
user will actually get when they select a region format.

00:05:59.189 --> 00:06:05.000
For example, different day-time formats,
on the iPhone, a telephone number format.

00:06:05.000 --> 00:06:11.899
This is the way the same functionality looks on the Mac OS.

00:06:11.899 --> 00:06:16.060
Notice that on both the iPhone and the Mac
OS, when you select the language, you select--

00:06:16.060 --> 00:06:18.800
actually select a list of ordered languages.

00:06:18.800 --> 00:06:24.000
Now this is important because maybe we--
you don't provide all of the localizations

00:06:24.000 --> 00:06:29.199
that match the users' preferences,
in that case, we'll fall back.

00:06:29.199 --> 00:06:33.110
So if English is your first-- first preference,
you know, but you don't have English,

00:06:33.110 --> 00:06:37.810
what would be a very unusual situation
will fall back, so in this case Arabic.

00:06:37.810 --> 00:06:39.560
I'll talk more about that later.

00:06:39.560 --> 00:06:45.920
So there are three steps to good internationalization.

00:06:45.920 --> 00:06:49.189
You want to start out using Unicode.

00:06:49.189 --> 00:06:53.279
Use the bundle mechanism that we
built-in to package your application.

00:06:53.279 --> 00:06:57.949
And then at least be aware of locales and how they work.

00:06:57.949 --> 00:07:00.430
So let me talk first about Unicode.

00:07:00.430 --> 00:07:05.800
I'll be surprise if no one in this
room has ever heard of Unicode.

00:07:05.800 --> 00:07:13.230
It's now basically the standard for representing
international text on all major platforms.

00:07:13.230 --> 00:07:17.970
Apple has been using it for many years
and we use it for several good reasons.

00:07:17.970 --> 00:07:19.810
First of all is coverage.

00:07:19.810 --> 00:07:27.579
Unicode covers virtually every language
that is now currently spoken on the planet.

00:07:27.579 --> 00:07:31.680
Also because if its widespread use and its growing use.

00:07:31.680 --> 00:07:36.639
Unicode is now the standard for
representing text on the worldwide web.

00:07:36.639 --> 00:07:39.889
Google stands some great numbers showing that.

00:07:39.889 --> 00:07:42.009
So we think it's a good idea to use Unicode.

00:07:42.009 --> 00:07:46.639
And in fact, we don't really give you any other
choice 'cause Unicode is the native encoding

00:07:46.639 --> 00:07:50.459
for Mac OS and the iPhone.

00:07:52.449 --> 00:07:59.149
So Unicode sets out to solve a very complex
problem much more complex than the kind of problems

00:07:59.149 --> 00:08:03.500
that were solved by older encodings such as ASCII or JIS.

00:08:03.500 --> 00:08:08.790
ASCII I mean for US English is
pretty, pretty simple encoding.

00:08:08.790 --> 00:08:13.330
You can make a lot of assumptions that
you cannot make about Unicode text.

00:08:13.329 --> 00:08:18.370
Unicode comes in lot of interesting
features that you have to deal with.

00:08:18.370 --> 00:08:24.970
For example, there are 3 encoding
forms, UTF-8, UTF-16, and UTF-32.

00:08:24.970 --> 00:08:33.279
These all have different purposes, but the upshot is they
have-- the resulting text has very different byte patterns.

00:08:33.279 --> 00:08:35.639
You have to be able to deal with that.

00:08:35.639 --> 00:08:38.519
The byte-order mark, the bomb.

00:08:38.519 --> 00:08:47.269
This is a Unicode character that appears at the beginning of
a plain text file to identify the endianness of that file.

00:08:47.269 --> 00:08:49.840
Normalization forms.

00:08:49.840 --> 00:08:57.680
Normalization includes things like whether Unicode
characters are represented as separate base letters

00:08:57.679 --> 00:09:01.329
with combining diacritics or a single character.

00:09:01.330 --> 00:09:06.750
The Mac OS file system prefers
the fully decomposed form of this.

00:09:06.750 --> 00:09:13.460
And there are times when if you're going to get file
system text, you have to convert it to a different form.

00:09:13.460 --> 00:09:16.639
Grapheme clusters.

00:09:16.639 --> 00:09:23.669
These are several Unicode characters that
represent a single semantic unit and many more.

00:09:23.669 --> 00:09:28.049
These are all that-- and that some details
of Unicode that you'd have to deal with.

00:09:28.049 --> 00:09:35.569
Our advice basically is don't deal with them on your
own but use the preexisting API that we provide.

00:09:37.980 --> 00:09:43.620
Another thing you have to keep aware of
especially now as we have added Arabic and Hebrew

00:09:43.620 --> 00:09:47.009
to the iPhone, text direction can be-- can vary.

00:09:47.009 --> 00:09:55.080
It can be English order, left-to-right, Arabic
order right-to-left or combination Arabic

00:09:55.080 --> 00:10:01.080
and Hebrew both contain text that has to be run both ways.

00:10:01.080 --> 00:10:05.810
And unless you really want to get into the
details of the Unicode by the algorithm,

00:10:05.809 --> 00:10:13.359
I suggest that you just use our text routines for
this and don't assume that your text is going to flow

00:10:13.360 --> 00:10:17.840
in any one of these directions but all of them.

00:10:19.149 --> 00:10:24.090
>> Another thing to think about is the
characters in your backing store are different

00:10:24.090 --> 00:10:28.889
from the actual glyphs that a user will see on the screen.

00:10:28.889 --> 00:10:35.799
For example, you may have multiple characters that
form a single glyph which you call a ligature.

00:10:35.799 --> 00:10:44.490
Similarly, I mentioned the graphemes, several Unicode
characters that compose a single logical element.

00:10:44.490 --> 00:10:48.200
You don't want to, when you're dealing
with editing operations on those elements.

00:10:48.200 --> 00:10:50.370
You don't want do things like breaking them apart.

00:10:50.370 --> 00:10:56.039
You want to treat them as a single logical character
even though there are three Unicode characters.

00:10:56.039 --> 00:10:58.389
And then surrogates.

00:10:58.389 --> 00:11:04.309
Surrogates are mechanism that Unicode
has to extend the 16-bit range

00:11:04.309 --> 00:11:09.109
of the original Unicode UTF-16 into a much larger space.

00:11:09.110 --> 00:11:16.029
Surrogates represent a single character
but they come as two Unicode UniChars.

00:11:16.029 --> 00:11:24.459
So the upshot is when you're dealing with
Unicode, don't assume that you can do it simply.

00:11:24.460 --> 00:11:28.100
For example you cannot break between arbitrary UniChars.

00:11:28.100 --> 00:11:33.290
And you cannot assume that just by adding
up the single Unicode character widths,

00:11:33.289 --> 00:11:40.319
you're going to get the actual width of the
character that the user sees on the screen.

00:11:40.320 --> 00:11:49.110
So okay, Unicode is-- Unicode is hard, we don't deny that,

00:11:49.110 --> 00:11:53.610
but we provided way to isolate
you from the details of Unicode.

00:11:53.610 --> 00:11:57.060
And that is the string class we
provide, we provide NSString.

00:11:57.059 --> 00:12:03.569
This is the class that most of our APIs or
castings, it was very easy to use once you get

00:12:03.570 --> 00:12:08.140
into Cocoa on either the iPhone or Mac OS.

00:12:08.139 --> 00:12:11.939
Now it's toll-free bridge with the
CFString, so you can use it if you're using--

00:12:11.940 --> 00:12:15.840
if your code is based on-- in a
Core Foundation rule-- world.

00:12:15.840 --> 00:12:27.280
But basically you want to use it because it will isolate you
from all of the complexities of dealing with Unicode text.

00:12:27.279 --> 00:12:32.039
Now you might say well, I have all
this old data that's not in Unicode

00:12:32.039 --> 00:12:37.699
or I have arrays of UniChars, how will I deal with those?

00:12:37.700 --> 00:12:45.850
Well, NSString supports conversion to in and
from virtually any encoding you can imagine.

00:12:45.850 --> 00:12:56.639
So it's very easy to generate an NSString from legacy
encodings such as JIS, GB2312, ISOlat1, whatever you have.

00:12:56.639 --> 00:13:04.000
So in working with the NSStrings, there are a
number of subclasses you can also work with.

00:13:04.000 --> 00:13:12.519
NSMutableStrings for changing strings in place,
NSAttributedString which is a rich text form of NSString,

00:13:12.519 --> 00:13:18.829
and finally, NSMutableAttributedString
which handles both editing and rich text.

00:13:22.409 --> 00:13:26.539
So there are a number of ways to create NSStrings.

00:13:26.539 --> 00:13:30.159
You can create NSString constants.

00:13:30.159 --> 00:13:34.610
Now, don't do this for localized
strings because you can't localize them,

00:13:34.610 --> 00:13:39.230
but they're very appropriate to do for identifiers.

00:13:39.230 --> 00:13:48.740
For example the keys that you use to get to localized
strings can be created this way as a string constant.

00:13:48.740 --> 00:13:55.299
If you have an array of UniChars, just create an
NSString calling stringWithCharacters, provide the length

00:13:55.299 --> 00:13:58.859
and the buffer, that's all you need to do.

00:13:58.860 --> 00:14:06.389
If you have legacy characters, a cString and
another encoding, call stringWithCString.

00:14:06.389 --> 00:14:13.120
And finally, there are many ways to get NSStrings
from other NSStrings for example getting a range.

00:14:13.120 --> 00:14:17.960
It's very easy to work with, although
the names are somewhat long.

00:14:17.960 --> 00:14:25.610
Now, a very common operation that you do for
localization when you want to present much longer

00:14:25.610 --> 00:14:29.480
or complex strings to the user is formatting strings.

00:14:29.480 --> 00:14:32.340
NSString has a method called stringWithFormat.

00:14:32.340 --> 00:14:39.730
Now this is, basically it works the same way
as sprintf using that same kind of syntax.

00:14:39.730 --> 00:14:46.600
We've added one refinement which is
the &@ syntax and this lets you pass

00:14:46.600 --> 00:14:54.159
in any Objective-C object to be
formatted in with your string.

00:14:54.159 --> 00:14:59.579
You can also index the parameters in your string format.

00:14:59.580 --> 00:15:06.410
This is very useful for the localizers, so they just
have to change the order when they're localizing.

00:15:06.409 --> 00:15:06.620
J.

00:15:06.620 --> 00:15:06.750
J.

00:15:06.750 --> 00:15:08.919
will talk a little bit more about that later.

00:15:08.919 --> 00:15:20.509
So I said don't store localized strings as hard-coded
strings in your Objective-C code or C code or whatever.

00:15:20.509 --> 00:15:23.610
And where do you store those?

00:15:23.610 --> 00:15:28.580
Well, they're stored in separate strings
files called "Localizable.strings" files.

00:15:28.580 --> 00:15:33.960
Now these are UTF-8-- UTF-16 encoded files.

00:15:33.960 --> 00:15:40.170
Each line contains a key value
pair separated by an equal sign.

00:15:40.169 --> 00:15:46.029
So the key is how you access the string and
the value is the actual localizable content

00:15:46.029 --> 00:15:48.870
that will change for localization.

00:15:48.870 --> 00:15:56.659
You can pass these files out to localizers and they
will localize the value part of the key value pair.

00:15:56.659 --> 00:16:02.969
At runtime the way you access your localized
strings is through NSLocalizedString.

00:16:02.970 --> 00:16:11.279
And that takes a key, just going to match the key in the
localizable.strings file and a hint, the localization hint.

00:16:11.279 --> 00:16:18.039
And these are very important actually because the localizer
will not see what's happening inside of your code,

00:16:18.039 --> 00:16:24.000
but they will see the hint if you add the
hint in your call to NSLocalizedString

00:16:24.000 --> 00:16:29.059
and hint will tell them exactly how this
string is meant to be used at runtime.

00:16:29.059 --> 00:16:33.569
And that's to give them a better idea of
what-- what they should be translating to.

00:16:33.570 --> 00:16:38.150
It's not always easy to translate from one
language to another if you don't know the context

00:16:38.149 --> 00:16:41.019
in which that translation is taking place.

00:16:41.019 --> 00:16:45.750
So we encourage you to use the localizer, localization hint.

00:16:45.750 --> 00:16:50.559
And as I said these strings will come
from the localizable.strings file

00:16:50.559 --> 00:16:53.699
that will be packaged as part of your application.

00:16:53.700 --> 00:16:58.050
I'll get to that later.

00:16:58.049 --> 00:17:02.859
Now when formatting strings, of course
there's a wrong way and a right way.

00:17:02.860 --> 00:17:05.670
Let's look at the wrong way.

00:17:05.670 --> 00:17:13.380
So this code tries to take several
localized objects which are indeed obtained

00:17:13.380 --> 00:17:18.170
in a correctly localizable way into a single string.

00:17:18.170 --> 00:17:24.680
Now the problem with this, so you've got a date and you've
got a number representing the height of the mountain,

00:17:24.680 --> 00:17:29.700
you've got the name of the mountain et cetera, and then
you've got some text that tries to format around that

00:17:29.700 --> 00:17:34.819
to put it together into a coherent human readable string.

00:17:34.819 --> 00:17:37.879
Now what's the problem with this the way this is done?

00:17:37.880 --> 00:17:49.310
Well if you look at the format itself, the format
itself, the four &@s there in that string is hard coded.

00:17:49.309 --> 00:17:53.129
So localizers can't get to that
unless they go into the code.

00:17:53.130 --> 00:18:00.770
It's not localizable because obviously the order of words
is one of things that varies highly between languages,

00:18:02.349 --> 00:18:09.819
so your format needs to also taken into
account the different syntax between languages.

00:18:09.819 --> 00:18:12.879
So what's the right way to do that?

00:18:12.880 --> 00:18:16.860
Well first of all, break your format
out into separate localizable string.

00:18:16.859 --> 00:18:24.639
So here you see imagine two localizable string
files one for French and one for English.

00:18:24.640 --> 00:18:32.370
We have the localize format as the key and then you have the
content, the format itself for English and then the French.

00:18:32.369 --> 00:18:37.849
So then at runtime the first thing you want to
do is grab your localized format and then use

00:18:37.849 --> 00:18:41.750
that format itself to create your formatted string.

00:18:41.750 --> 00:18:47.049
Calling stringWithFormat passing that in as
the first parameter of the stringWithFormat,

00:18:47.049 --> 00:18:50.460
and then you can add in your other localizable objects.

00:18:51.589 --> 00:18:55.389
That's pretty simple straightforward out.

00:18:55.390 --> 00:19:00.720
So if you're here-- if you were here
for Session 112, the session previous,

00:19:00.720 --> 00:19:06.089
you probably saw a lot of detailed discussion
of Cocoa text and the string et cetera.

00:19:06.089 --> 00:19:11.250
I'll go through some of the things that are
available in case you missed that session.

00:19:11.250 --> 00:19:21.390
So NSString itself common operations like getting the
case, changing case of strings, comparing strings,

00:19:21.390 --> 00:19:25.390
getting substrings of strings are also-- are all available.

00:19:25.390 --> 00:19:31.300
If you want to do with graphemes,
you can detect the graphemes NSString

00:19:31.299 --> 00:19:35.139
to determine how to say cursor around them for example.

00:19:35.140 --> 00:19:45.620
Now if you want to convert an NSString to another encoding,
you can call getCharacters which will extract the UniChars

00:19:45.619 --> 00:19:51.629
or getCString which will extract
that same text as an array of bytes.

00:19:51.630 --> 00:19:55.980
Find and replace and then editing.

00:19:55.980 --> 00:20:00.410
Editing, of course, would be done
on a mutable flavor of NSString.

00:20:00.410 --> 00:20:10.960
Now if you're here for 112 or you want to review that
later, you saw a lot of detailed discussion of other classes

00:20:10.960 --> 00:20:15.519
that help you with deal with your Unicode and NSStrings.

00:20:15.519 --> 00:20:21.150
>> These include tokenization,
you can use CFStringTokenizer.

00:20:21.150 --> 00:20:28.120
CFStringTokenizer is so powerful it would even tokenize
Japanese and Chinese text which are not separated by--

00:20:28.119 --> 00:20:32.759
which words are not separated by byte space.

00:20:32.759 --> 00:20:36.410
Number formatting, date, time formatting,
pretty standard stuff.

00:20:36.410 --> 00:20:44.300
Protecting character properties such as a character
whitespace is a punctuation, use NSCharacterSet for that.

00:20:44.299 --> 00:20:48.919
And you can also define your own
arbitrary sets of characters.

00:20:48.920 --> 00:20:55.360
Use NSCharacterSet to detect if a string contains those.

00:20:55.359 --> 00:20:57.309
Language context-- content.

00:20:57.309 --> 00:21:04.339
If you want to determine whether your string contains
English, Chinese, different scripts, whatever,

00:21:04.339 --> 00:21:14.149
we now have NSOrthography which will do the
work of that kind of language analysis for you.

00:21:14.150 --> 00:21:16.000
Transliterating between scripts.

00:21:16.000 --> 00:21:24.670
For example say you have a file of Chinese using Chinese
characters and you want to convert that to pinyin,

00:21:24.670 --> 00:21:30.269
the Romanized orthography, you can use
CFStringTransform to do that operation.

00:21:30.269 --> 00:21:34.859
And finally, normalization between the
various forms of Unicode text, for example,

00:21:34.859 --> 00:21:42.149
I mentioned the Mac OS file system
uses fully decomposed Unicode.

00:21:42.150 --> 00:21:49.720
Well typically, other systems don't really support
that well so you probably want to convert text as file,

00:21:49.720 --> 00:21:57.740
filenames from the Mac OS into fully composed
using NSStringNormalize or CFStringNormalize.

00:21:57.740 --> 00:22:07.819
Now we provide a very useful tool to help you
bootstrap your localization process called genstrings.

00:22:07.819 --> 00:22:16.049
Genstrings will take your source code run through it,
look for all the places where you call NSLocalizedString

00:22:16.049 --> 00:22:21.549
and then produce an appropriate template
file for each of those instances.

00:22:21.549 --> 00:22:29.470
So we have one line-- one line for each invocation of
NSLocalizedString that house the key and the value.

00:22:29.470 --> 00:22:35.210
So basically it takes, it takes the key and
copies it as the value also with the idea

00:22:35.210 --> 00:22:41.279
that the localizer will then sit
down and translate the values.

00:22:41.279 --> 00:22:47.129
Now it would also look for the localization
enhancing and provide and insert those

00:22:47.130 --> 00:22:49.410
as comments into your .strings file template.

00:22:49.410 --> 00:22:54.670
So it's pretty easy to use, just run it over your .m files.

00:22:54.670 --> 00:22:57.340
The defaults are the best settings.

00:22:57.339 --> 00:22:58.939
I'm not going to go into those right now, but J.

00:22:58.940 --> 00:22:59.150
J.

00:22:59.150 --> 00:23:00.660
can talk about that more.

00:23:00.660 --> 00:23:01.870
We can answer questions later.

00:23:01.869 --> 00:23:06.989
So what does it look like when you use genstrings?

00:23:06.990 --> 00:23:13.390
So first of all you start out with
your Objective-C source file.

00:23:13.390 --> 00:23:16.640
Here we see a call to NSLocalizedString.

00:23:16.640 --> 00:23:20.130
The key is tallMountain and then
there's the localization hint.

00:23:20.130 --> 00:23:29.790
This string is meant to represent the name of the tallest
mountain, and fire up the terminal go into the directory

00:23:29.789 --> 00:23:38.089
where you have your resource file, run genstrings on that
source file which in this case is Mountains.m which is one

00:23:38.089 --> 00:23:44.750
of the sample code files that we'll
provide in a separate package.

00:23:44.750 --> 00:23:47.160
After running genstrings, you get this output.

00:23:47.160 --> 00:23:50.650
You see you have a new localizable.strings file.

00:23:55.480 --> 00:24:02.240
Now if you look inside of that localizable.strings file you
see that it's copied the comment or the hint to localizer

00:24:02.240 --> 00:24:12.549
and then provided the key value pair, and the localizer will
then proceed to translate that value on the right-hand side.

00:24:12.549 --> 00:24:17.180
It's pretty easy.

00:24:17.180 --> 00:24:20.920
So the next piece of the puzzle
in doing, preparing your code

00:24:20.920 --> 00:24:24.600
for internationalization and localization is using bundles.

00:24:24.599 --> 00:24:26.119
And what's a bundle?

00:24:26.119 --> 00:24:33.919
A bundle is basically just a collection of the code
and data that you want that your application needs.

00:24:33.920 --> 00:24:37.519
They're basically special folders.

00:24:37.519 --> 00:24:41.170
Users will see them as a single
item although you can actually go

00:24:41.170 --> 00:24:44.980
and see the contents if you need to at least on the map.

00:24:44.980 --> 00:24:49.349
They have an identifier for easy and efficient access.

00:24:49.349 --> 00:25:00.319
And as a flexible but well-known structure that lets
us get it all of the resources you need at runtime.

00:25:00.319 --> 00:25:08.990
In particular, bundles contain subfolders
called with the extension .lproj.

00:25:08.990 --> 00:25:14.549
The .lproj files are how you store your localized data.

00:25:14.549 --> 00:25:17.269
So basically anything can be a bundle.

00:25:17.269 --> 00:25:22.940
Applications on the Mac and iPhone are
packaged as bundles, frameworks and bundles.

00:25:22.940 --> 00:25:31.970
Nibs which are the collection of UI
elements, for example, menus, tables, buttons,

00:25:31.970 --> 00:25:38.850
et cetera are also bundles especially
beginning with Leopard.

00:25:38.849 --> 00:25:46.629
So basically the bundle lets you-- the architecture lets
you combine all of the elements you need, code and data,

00:25:46.630 --> 00:25:54.200
UI of localization inside a single package, and this
is how you should be delivering your applications.

00:25:54.200 --> 00:26:01.259
So we talked about the localizations
that actually reside within your bundle.

00:26:01.259 --> 00:26:04.640
So I said that within the bundle you'll find multiple.

00:26:04.640 --> 00:26:06.759
lproj folders.

00:26:06.759 --> 00:26:11.299
This will contain nibs with your localized UI elements.

00:26:11.299 --> 00:26:14.009
Now you can fire up Interface Builder.

00:26:14.009 --> 00:26:20.549
Localizers can go through and change the menu in place and
they can actually see how the localized string should fit

00:26:20.549 --> 00:26:30.029
in the menu so they can adjust the size of the items in
the menu to get the best appearance for the localization

00:26:30.029 --> 00:26:33.470
and the strings files, the localizable.strings files.

00:26:34.539 --> 00:26:38.409
Now functions especially NSBundle
which we'll talk about in a second.

00:26:38.410 --> 00:26:47.990
You know how to go through the bundle and look to get
the right localization for the user's preferences.

00:26:47.990 --> 00:26:55.960
Now remember I said that users can choose
a list of preferences in language order.

00:26:55.960 --> 00:27:03.000
But you may not have all of those
localizations in your application.

00:27:03.000 --> 00:27:10.670
So NSBundle knows how to look for the-- compare the
users' preferences with the available localization.

00:27:10.670 --> 00:27:20.090
So for example, if the user has choose-- chosen
Albanian, Bulgarian, Catalan as their preferred languages

00:27:20.089 --> 00:27:25.139
but you only localize Bulgarian,
the answer is going to be Bulgarian.

00:27:25.140 --> 00:27:33.530
Now, that for the names of the lproj
folders, we use the convention BCP 47

00:27:33.529 --> 00:27:37.690
which is a standard internet convention
for naming languages.

00:27:37.690 --> 00:27:42.779
So if you look inside the lproj-- inside of your
bundle and you've done some localizations say,

00:27:42.779 --> 00:27:50.420
you might see files like en.lproj, fr.lproj
for French, zh.lproj for Chinese, et cetera,

00:27:50.420 --> 00:27:54.930
depending on which localizations you've added.

00:27:54.930 --> 00:28:00.930
Now also you don't really need to set
these things up yourself because inter--

00:28:00.930 --> 00:28:10.019
excuse me, Xcode will add in all of the
correct lproj names as you edit a new lproj

00:28:10.019 --> 00:28:12.619
as well as you add new localized resources.

00:28:12.619 --> 00:28:19.199
It'll handle the structure of the
lprojs within your bundle for you.

00:28:19.200 --> 00:28:19.559
And J.

00:28:19.559 --> 00:28:19.659
J.

00:28:19.660 --> 00:28:23.150
is going to show that a little bit later.

00:28:23.150 --> 00:28:26.540
So let's look at the NSBundle class.

00:28:26.539 --> 00:28:29.069
This is how you deal with bundles.

00:28:29.069 --> 00:28:34.569
Now one thing to keep in mind about NSBundle
is it's not toll-free bridge with CFBundleRef.

00:28:34.569 --> 00:28:38.879
So you can't just patent, you can just interchange them.

00:28:38.880 --> 00:28:44.910
So typically, to do something with the
bundle, you'll first get your bundle.

00:28:44.910 --> 00:28:48.820
If you're an application you call mainBundle
which will return your bundle for you.

00:28:48.819 --> 00:28:50.939
You don't need to do anything else.

00:28:50.940 --> 00:28:54.370
And then you ask the bundle for things within it.

00:28:54.369 --> 00:29:02.799
For example, you want to get a particular
resource, call pathForResource and then the name

00:29:02.799 --> 00:29:07.659
of the resource and the type which is the extension.

00:29:07.660 --> 00:29:15.920
Typically it's going to be something like plist if it's a,
you know, some kind of NSObject say an array for example.

00:29:15.920 --> 00:29:21.910
Now, there are numerous ways to get different
resources but this is one good example.

00:29:21.910 --> 00:29:26.350
Now note that you don't have to provide
a language when you make this call

00:29:26.349 --> 00:29:32.569
because at runtime NSBundles will actually figure
out, looking at the users' preferences and matching

00:29:32.569 --> 00:29:36.950
up your localizations to get the best--
the best path to a localized resource.

00:29:36.950 --> 00:29:40.680
One is appropriate for user settings.

00:29:40.680 --> 00:29:48.830
Let's talk a little bit about using locales.

00:29:48.829 --> 00:29:50.129
So what is locale?

00:29:50.130 --> 00:29:59.340
It's basically a collection of objects-- of objects that
correspond to customs, settings, use in a particular region,

00:29:59.339 --> 00:30:07.250
for example calendars, date-time formats, currency.

00:30:07.250 --> 00:30:10.630
On the iPhone how you format a telephone number.

00:30:10.630 --> 00:30:17.100
These are all the kinds of things
associated with locale, measurements.

00:30:17.099 --> 00:30:21.939
Probably the US is the only country in the world
where measurements are separate from the rest--

00:30:21.940 --> 00:30:25.759
rest of the planet but it's a kind of thing you can get.

00:30:25.759 --> 00:30:29.200
>> Now all of our locale data actually comes

00:30:29.200 --> 00:30:35.200
from the Open Source project called the
Common Locale Data Repository, CLDR.

00:30:35.200 --> 00:30:44.870
I mentioned that because if you find that locale is missing
or you find that locale data is incorrect especially

00:30:44.869 --> 00:30:51.229
if you're, you know, you know a lot about that
locale and you know that it's something's wrong,

00:30:51.230 --> 00:30:55.849
well you can actually work directly
with a the CLDR and get that changed.

00:30:55.849 --> 00:31:04.240
The next time we release the OS and it matches
one of our, you know, something that's changed

00:31:04.240 --> 00:31:07.490
in CLDR we'll just pick that up
and get a new version of CLDR.

00:31:07.490 --> 00:31:15.269
Let's look at the NSLocale class.

00:31:15.269 --> 00:31:22.359
NSLocale represents both all locales as
a class and individual locale objects.

00:31:22.359 --> 00:31:25.829
So for example if you want to find
all of the locales available

00:31:25.829 --> 00:31:31.509
on the system, you've used a class method on NSLocale.

00:31:31.509 --> 00:31:36.339
It's toll-free bridged with CFLocaleRef.

00:31:36.339 --> 00:31:43.359
Now often when you're doing something like formatting
a date or time, the locale is actually assumed.

00:31:43.359 --> 00:31:45.709
You don't have to worry about it.

00:31:45.710 --> 00:31:54.539
But if you need to change the locale for example where you
want to create a number format and use a specific locale,

00:31:54.539 --> 00:31:59.519
you can actually set the locale on particular objects.

00:31:59.519 --> 00:32:02.910
For example here we see a call to setLocale.

00:32:04.099 --> 00:32:07.869
So how did you get a locale?

00:32:07.869 --> 00:32:11.469
Well, you can start by calling currentLocale which--

00:32:11.470 --> 00:32:17.410
this is actually a misnomer because it's only in the
current local when your application was launched.

00:32:17.410 --> 00:32:22.460
As I showed you earlier, the user can
actually go in and change the locale.

00:32:22.460 --> 00:32:28.210
They could change the locale using the settings
on the iPhone while your application is running.

00:32:28.210 --> 00:32:30.640
So what do you do?

00:32:30.640 --> 00:32:33.290
How do you get the really current locale?

00:32:33.289 --> 00:32:37.899
Well you can pull-- you can call
another method autoupdatingCurrentLocale

00:32:37.900 --> 00:32:44.110
which will actually give you the current
locale or you can register for notifications.

00:32:44.109 --> 00:32:47.199
That way say you have some data that
you've been cashing and you need--

00:32:47.200 --> 00:32:51.759
you need to refresh it, just do it
whenever you get the notification.

00:32:51.759 --> 00:33:00.900
And finally, you can create any locale you want using
standard formatting pattern identifiers, typically like name

00:33:00.900 --> 00:33:05.680
and country, using identifiers defined by ISO.

00:33:05.680 --> 00:33:14.370
So there are a lot of ways to create locales.

00:33:14.369 --> 00:33:16.500
Typically, you probably won't use this.

00:33:16.500 --> 00:33:20.190
Just assume the current locale is the one that's best.

00:33:20.190 --> 00:33:22.740
Given the users' preferences, let the user be in control.

00:33:22.740 --> 00:33:29.309
Now what are the kinds of things
you can get for locale objects?

00:33:29.309 --> 00:33:36.049
As I mentioned, locale objects are
basically collection of things.

00:33:36.049 --> 00:33:40.919
In fact if you look at the name of some
of the objects on a locale object for key,

00:33:40.920 --> 00:33:46.840
you can imagine what the implantation
is, it's some kind of NSCollection.

00:33:46.839 --> 00:33:51.549
Currency, measurement, location, we define all these.

00:33:51.549 --> 00:33:58.619
And if you want to find a particular
locale item for example the currency,

00:33:58.619 --> 00:34:07.709
you just use the predefined name and
call objectForKey on that locale.

00:34:07.710 --> 00:34:15.329
Here are some examples: NSLocaleCurrencyCode,
NSLocaleUsesMetricSystem, it's just true for every place

00:34:15.329 --> 00:34:23.869
in the world but US and maybe Burma, the last time I was
there, but they are probably more progressive than we are.

00:34:23.869 --> 00:34:33.699
So one thing I'd like to point out though is that the
locales can be different from your current language.

00:34:33.699 --> 00:34:38.289
So, for example, you can get the
country name for the locale.

00:34:38.289 --> 00:34:46.139
So if your country is the US locale, you should
expect some-- hence your language is English,

00:34:46.139 --> 00:34:49.440
you'll expect something like the United States.

00:34:49.440 --> 00:34:59.579
But if you have a US locale and your language-- your UI
language selected is French, it would be [foreign language]

00:34:59.579 --> 00:35:04.719
or Japanese, [foreign language] Cocoa whatever.

00:35:04.719 --> 00:35:14.559
Let me talk a little bit more about the
differences between locale and language.

00:35:14.559 --> 00:35:24.610
So as I said the current locale gives you the current
settings at least when your application was launched

00:35:24.610 --> 00:35:30.650
for the region formats, date, time,
number, currency, et cetera.

00:35:30.650 --> 00:35:34.490
Now those can be dependent-- independent of language.

00:35:34.489 --> 00:35:40.809
If you want to find out what the users'
preferred languages are, call preferredLanguages.

00:35:40.809 --> 00:35:46.119
That's also an NSLocale class method.

00:35:46.119 --> 00:35:54.119
This will return an array of languages using BCP 47
language IDs, and the order will be the preference

00:35:54.119 --> 00:35:58.900
that the user put them in using
the UI that I showed earlier.

00:35:58.900 --> 00:36:09.210
So just remember that language and locale are independent of
each other, that's why you can get, you can have a US locale

00:36:09.210 --> 00:36:15.630
with French language, because maybe a French
user here wants to use a US date time formats

00:36:15.630 --> 00:36:20.940
but they want see all the strings in
French, it's a very common scenario.

00:36:20.940 --> 00:36:26.789
Now finally, let's put it all together.

00:36:26.789 --> 00:36:35.190
I'm going to show you three common operations
you'll be doing to support localization.

00:36:35.190 --> 00:36:45.679
First of all, getting a data file, then a localized
string, and finally a very simple formatting a number.

00:36:45.679 --> 00:36:54.509
So imagine that your application contains some data,
it's basically an array of localized mountain names.

00:36:54.510 --> 00:37:01.640
You'll have a different, different set of strings for
each localization you support, and you want to get those

00:37:01.639 --> 00:37:06.319
at runtime, then you call pathForResource on your bundle.

00:37:06.320 --> 00:37:09.440
Start by getting your bundle.

00:37:09.440 --> 00:37:16.480
Call pathForResource with the resource
name which in this is mountains in plist.

00:37:16.480 --> 00:37:20.789
Once you've gotten the path, which will be the
path that's correct for the current localization,

00:37:20.789 --> 00:37:30.719
just instantiate those objects as an NSArray
using NSArray method, arrayWithContentsOfFile,

00:37:30.719 --> 00:37:36.369
and you've got your array do something interesting with it.

00:37:36.369 --> 00:37:38.960
Pretty simple.

00:37:40.369 --> 00:37:42.889
Something slightly more complex.

00:37:42.889 --> 00:37:48.759
Here's the right way to do to get a localized string.

00:37:48.760 --> 00:37:54.850
Start out by getting the format.

00:37:54.849 --> 00:37:57.369
As I mentioned earlier you want to separate the format

00:37:57.369 --> 00:38:03.920
from the actual runtime string, so
the format itself can be localized.

00:38:05.050 --> 00:38:13.880
In this case you call NSLocalizedString with the
key the sentence format which should be match a key

00:38:13.880 --> 00:38:22.700
in your localized.strings file which I
showed you earlier and then the hint.

00:38:24.150 --> 00:38:39.269
Oops, okay, and you get the name, so you have the mountain
names and some canonical mountain name format and you want

00:38:39.269 --> 00:38:46.480
to get the localized version of that using a key.

00:38:46.480 --> 00:38:56.019
Now since your intent is to display a string something like,
you know, "On such as such a date, this mountain having,

00:38:56.019 --> 00:39:01.559
an altitude of so many feet or meters was climbed".

00:39:01.559 --> 00:39:08.400
You need to get a correctly localized
number representing the height.

00:39:08.400 --> 00:39:11.990
So create a number formatter.

00:39:11.989 --> 00:39:19.750
Set the format you want, in this case, decimal style that
will make sure that you get the right decimal separator

00:39:19.750 --> 00:39:28.369
for example for the locale that you're
going to be representing the string in.

00:39:28.369 --> 00:39:43.549
And then, you know, pass in that number which is NSNumber,
the value mount.height and then format the string.

00:39:43.550 --> 00:39:47.750
Next you go on to do the same thing with the date.

00:39:47.750 --> 00:39:53.159
In this case get the date which is represented as NSDate.

00:39:53.159 --> 00:40:00.219
You format it using a medium style and
then you get the string formatted string.

00:40:00.219 --> 00:40:08.699
And finally you put all of those things together
using stringWithFormat and the output if it's English,

00:40:08.699 --> 00:40:16.539
for example, would be 8,848 meters tall, Mt.
Everest was first climbed on 26th of May 1953.

00:40:16.539 --> 00:40:24.389
>> Finally this was what it would
look like to format just a number.

00:40:24.389 --> 00:40:30.579
Now in Snow Leopard, there's a much easier way which
was discussed in Session 112, but that's not available

00:40:30.579 --> 00:40:38.139
on both platforms so this is the way you do it for
the phone and the Mac if you want the same code.

00:40:38.139 --> 00:40:47.529
Again create your number formatter, set the style for the
formatter, and finally just generate the formatted string.

00:40:47.530 --> 00:40:49.610
Pretty easy.

00:40:49.610 --> 00:40:57.530
So with all of these tools, I think you can go on
and start building your application making it local--

00:40:57.530 --> 00:41:02.600
making it localizable and have a great product.

00:41:02.599 --> 00:41:05.500
Now let's talk about the details of actually localizing.

00:41:05.500 --> 00:41:07.760
I'm going to turn over this session to J.

00:41:07.760 --> 00:41:08.000
J.

00:41:08.000 --> 00:41:12.449
Enser. He will talk about localization.

00:41:12.449 --> 00:41:12.809
Thank you J.

00:41:12.809 --> 00:41:14.009
J.

00:41:14.010 --> 00:41:19.860
[ Applause ]

00:41:19.860 --> 00:41:20.140
>> Thank you.

00:41:20.139 --> 00:41:21.609
Thank you, Lee.

00:41:21.610 --> 00:41:22.809
Hi, I'm J.

00:41:22.809 --> 00:41:22.920
J.

00:41:22.920 --> 00:41:28.230
Enser and I'd like to do a quick run
of the localization process itself.

00:41:28.230 --> 00:41:36.889
So after you've done all the cool stuff that Lee talked
about and you're code is ready, has been internationalized,

00:41:36.889 --> 00:41:42.420
you can start considering localization in itself.

00:41:42.420 --> 00:41:51.000
And localization can really be summarized in three step
process: Preparing your project, translating your strings,

00:41:51.000 --> 00:41:56.260
and applying any UI layout adjustment
as needed for you languages.

00:41:56.260 --> 00:42:04.610
So the first thing you want to do is tell Xcode
which files in your projects need to be localized.

00:42:04.610 --> 00:42:13.430
And that's done very simply by selecting the files
that you're interested in under your resources view,

00:42:13.429 --> 00:42:23.109
you bring out the inspector and
click "Make File Localizable."

00:42:23.110 --> 00:42:31.620
That puts all the files that you selected into the English
lproj that Lee talked about and put them in one place

00:42:31.619 --> 00:42:41.589
that allows you then to add additional languages
following the same structure, just click Add Localization,

00:42:41.590 --> 00:42:53.970
name your lproj, and as it was mentioned, Apple recommends
that to use standard identifier for locales defining BCP 47

00:42:53.969 --> 00:43:02.129
and Xcode will create the corresponding
lproj folder for you in your project.

00:43:05.170 --> 00:43:15.750
From that point you can go ahead and edit the files in
their respective lproj using Xcode for or any text editor

00:43:15.750 --> 00:43:21.170
for strings files or using Interface
Builder for your nib files.

00:43:21.170 --> 00:43:25.869
Now that would work for small size project.

00:43:25.869 --> 00:43:33.789
If you want to deal with a larger
project with a lot more UI complex files

00:43:33.789 --> 00:43:39.690
and also reuse previous translation, you can use AppleGlot.

00:43:39.690 --> 00:43:46.400
AppleGlot is an extraction leveraging
and integration tool for localization.

00:43:46.400 --> 00:43:53.110
It supports multiple file types
such as strings, nib files, XMLs.

00:43:53.110 --> 00:44:01.970
It extracts all the-- your localizable content from
those files and put them into one single document

00:44:01.969 --> 00:44:06.059
that can easily be shared with your localizers.

00:44:06.059 --> 00:44:17.369
This document is actually using an XML-based format for
localization interchange called XLIFF and supported by most

00:44:17.369 --> 00:44:22.059
of the standard or modern translation tools.

00:44:22.059 --> 00:44:30.829
AppleGlot also has the ability to apply standardized
glossary of translation to your application

00:44:30.829 --> 00:44:34.110
so that you don't have to translate everything from scratch.

00:44:34.110 --> 00:44:38.829
Apple supplies such glossaries based on Mac OS X.

00:44:38.829 --> 00:44:47.099
And you can put them in the right place in AppleGlot
so that those translation are there for you.

00:44:47.099 --> 00:44:56.190
And finally, AppleGlot has the ability to carry over
any translation work or UI work that you've done

00:44:56.190 --> 00:45:01.519
in previous translation or previous
localization of your app.

00:45:03.309 --> 00:45:07.179
Thus this-- applies this to strings as much as UI.

00:45:07.179 --> 00:45:14.319
So let me give you a quick overview of AppleGlot itself.

00:45:14.320 --> 00:45:23.690
So for those of you who might be familiar with these
tools that have been around for maybe fifteen years or so,

00:45:23.690 --> 00:45:30.909
this might come as a surprise as AppleGlot is no
longer GUI application but a common line tool.

00:45:30.909 --> 00:45:42.619
You can get the full usage by typing appleglot -h, I'll
just go over here are the comments available for you.

00:45:42.619 --> 00:45:52.559
Create will simply create on your disc or an environment
that setup subfolder to contain all your localized data,

00:45:52.559 --> 00:45:57.809
glossaries, produced translation, and results.

00:45:57.809 --> 00:46:05.849
Setlangs would-- well setlangs, I'm sorry, will
simply define the source and target languages.

00:46:05.849 --> 00:46:11.909
Populate will effectively extract all
the strings from your localizable files

00:46:11.909 --> 00:46:15.449
and generate that XLIFF document I talked about.

00:46:15.449 --> 00:46:21.909
It would also apply glossaries if you supplied
any and carryover previous translation.

00:46:21.909 --> 00:46:29.230
Once that XLIFF document has been translated
by your localizer and you get them back,

00:46:29.230 --> 00:46:36.210
you use update command to integrate those
translation back into your software.

00:46:36.210 --> 00:46:42.789
And finalize just cleans up the
environment, removing temporary files.

00:46:42.789 --> 00:46:46.820
So once this is done, all your
translation has been carried over

00:46:46.820 --> 00:46:52.039
but your UI hasn't changed in terms of geometry or layout.

00:46:52.039 --> 00:47:03.099
So you, at this point, need to probably do
some work to address the UI for each language.

00:47:03.099 --> 00:47:06.130
These can easily be done directly in Interface Builder.

00:47:06.130 --> 00:47:17.390
You can identify and address those UI layout issues by
doing some resizing and getting to something like this.

00:47:17.389 --> 00:47:24.559
In this example, you know, you can-- might notice
in the second box that the text overflows on top

00:47:24.559 --> 00:47:33.650
of another UI object and that the button label was
clipped in initially 'cause it kept the English size,

00:47:33.650 --> 00:47:40.769
and after very easy manipulation,
you can address your UI this way.

00:47:40.769 --> 00:47:42.860
Now this works fine for MAC OS applications.

00:47:42.860 --> 00:47:46.780
You have, you know, a lot of room.

00:47:46.780 --> 00:47:52.400
For those of you who develop iPhone applications,
you might need to address things slightly differently

00:47:52.400 --> 00:47:57.380
because as you can imagine, you don't
have the same realistic data to work with.

00:47:57.380 --> 00:48:12.519
Here's an example of what's been done on the iPhone OS with
the familiar slide to unlock button on the locked screen.

00:48:12.519 --> 00:48:23.579
Internally, we translated-- we decided to translate
this as unlock, just unlock, not slide to--

00:48:23.579 --> 00:48:31.230
and that's possible thanks to genuine and
very intuitive UI that was designed for that.

00:48:31.230 --> 00:48:38.039
The text is shining and, you know, there's
an animation that shows that the text can--

00:48:38.039 --> 00:48:45.869
that your fingers should slide across and you
have of course the arrow button that also slides.

00:48:45.869 --> 00:48:52.299
So that's a hint also to think really deeply about
how you design your UI so that you can keep the text

00:48:52.300 --> 00:49:01.400
to a minimum especially on a device like the iPhone
where the font needs to be a decent size, you know,

00:49:01.400 --> 00:49:07.760
for example reducing the font size
in order to translate, you know,

00:49:07.760 --> 00:49:13.630
slide to unlock would not be a recommended
solution for usability reasons and consistency.

00:49:13.630 --> 00:49:20.750
So let me show you how this works in practice.

00:49:20.750 --> 00:49:31.550
So I have an Xcode project right here that's the same as
was used in the previous examples, international mountains,

00:49:31.550 --> 00:49:38.130
that's part of the simple codes
that you have in the iPhone SDK.

00:49:38.130 --> 00:49:41.050
Currently, this application is not localizable.

00:49:41.050 --> 00:49:48.289
I'm going to run it just as it
is just to show you what it does.

00:49:48.289 --> 00:49:59.420
Simple navigation-based application with the table view, a
list of a mountains, you know they have very original names.

00:49:59.420 --> 00:50:07.980
And each roll leads to a detailed view that shows when
the mountain was first climbed and how high it is.

00:50:07.980 --> 00:50:15.789
That's directly the result of what you've seen
in the previous internationalization slides.

00:50:15.789 --> 00:50:17.489
>> That's it for the application.

00:50:17.489 --> 00:50:24.129
It also has Settings Bundle that you can see here.

00:50:24.130 --> 00:50:29.829
And that Settings Bundle has a
simple switch to sort the table.

00:50:32.670 --> 00:50:36.860
So what happens if I change language right now?

00:50:36.860 --> 00:50:43.750
I'm going to do this at the OS
level again, switch to French.

00:50:43.750 --> 00:50:52.219
I can see that my settings application
is-- has a localized name,

00:50:52.219 --> 00:50:55.980
but apparently you know, my Mountains
application hasn't changed.

00:50:55.980 --> 00:51:00.099
It's still in English, it hasn't been
localized yet, but it defaults to English

00:51:00.099 --> 00:51:03.389
because there's no French localization available.

00:51:03.389 --> 00:51:06.250
So let's fix that.

00:51:06.250 --> 00:51:11.070
So as I showed you, I'm going to do
this with one file here as an example.

00:51:11.070 --> 00:51:16.809
We have a localizable.strings with all our key value pairs.

00:51:16.809 --> 00:51:23.889
I'm going to simply add French localization to this file.

00:51:23.889 --> 00:51:26.230
Here's fr.

00:51:26.230 --> 00:51:38.769
And you can see that I now have two copies of my file
that are identical but Xcode explicitly shows that as well

00:51:38.769 --> 00:51:45.880
as in the resources hierarchical view
where you see both localizations here.

00:51:45.880 --> 00:51:51.390
From here I could directly, you know, of course
edit those strings in Xcode and translate them,

00:51:51.389 --> 00:51:57.789
but let me show you how this is
done in AppleGlot, using AppleGlot.

00:51:57.789 --> 00:52:04.199
So here's what an AppleGlot environment
looks like after you run the Create command.

00:52:04.199 --> 00:52:10.759
There's number of subfolders here for your glossaries,
for your English software, for your localize software,

00:52:10.760 --> 00:52:13.810
for your previous software if you have any.

00:52:13.809 --> 00:52:23.509
And also, this is where the centralized XLIFF
document leaves where translation is going to happen.

00:52:23.510 --> 00:52:26.480
Let me quickly show it to you.

00:52:26.480 --> 00:52:36.230
This is the XML content where you can see strings have
been extracted from all of your files and positioned

00:52:36.230 --> 00:52:41.570
under source and target tags within the XML.

00:52:41.570 --> 00:52:50.640
You can also see the comments that Lee mentioned, the
localization hints that you put in your code that ends

00:52:50.639 --> 00:52:56.429
up also in the XLIFF so that localizers can find
it and see it when they-- when they translate.

00:52:56.429 --> 00:53:04.250
And you can see that there are file tags that
that show that all the strings have been combined

00:53:04.250 --> 00:53:08.090
into one document for multiple source files.

00:53:08.090 --> 00:53:15.090
So you send that to your translator,
you get a translated file back,

00:53:15.090 --> 00:53:20.030
you put it back directly in your AppleGlot environment.

00:53:20.030 --> 00:53:27.840
And from here, I'm going to run AppleGlot to show
you how to integrate that back in the software.

00:53:27.840 --> 00:53:34.039
So I'm going to point it to my AppleGlot environment.

00:53:34.039 --> 00:53:37.670
And I'm going to type update.

00:53:37.670 --> 00:53:39.579
That's it.

00:53:39.579 --> 00:53:47.400
It processed the nib files, plist files, and
strings files that were in my English lproj.

00:53:47.400 --> 00:53:59.160
And if I look-- take a quick look at the new lock folder, I
now see a French lproj, and hopefully those are localized.

00:53:59.159 --> 00:54:04.210
I find all the pairs here have been updated.

00:54:04.210 --> 00:54:13.010
All I need to do now is to copy this
French lproj back into my Xcode project.

00:54:13.010 --> 00:54:21.500
[ Pause ]

00:54:21.500 --> 00:54:30.630
>> And now I should have here the two flavors of this
file, for example, showing the French translation.

00:54:30.630 --> 00:54:38.660
So let me go ahead and try and see
the result directly in the simulator.

00:54:38.659 --> 00:54:42.420
Here we go.

00:54:42.420 --> 00:54:53.329
Application is now localized including
the Navigation bar and the Detail View.

00:54:53.329 --> 00:54:57.650
Let's check the Settings Bundle.

00:54:57.650 --> 00:55:03.050
Here it's localized as well and here it's localized as well.

00:55:03.050 --> 00:55:05.780
Oops, there's a bit of problem here.

00:55:05.780 --> 00:55:11.210
My translation is slightly too long,
it no longer fits in the UI label.

00:55:11.210 --> 00:55:16.510
So I can go ahead and edit that directly over here.

00:55:16.510 --> 00:55:21.030
I go to my Settings Bundle in Xcode
to find my .strings file.

00:55:21.030 --> 00:55:33.090
I can shorten the translation and
also improve it at the same time.

00:55:33.090 --> 00:55:37.850
And if I build that again, this should show, localized.

00:55:41.590 --> 00:55:48.990
Let me go back here.

00:55:48.989 --> 00:55:54.199
Okay, so yeah, it works.

00:55:54.199 --> 00:55:54.389
[ Applause ]

00:55:54.389 --> 00:56:06.920
>> Okay, the last thing I want to show you
here is if I go back to the table view,

00:56:06.920 --> 00:56:12.269
I notice here that this is almost localized or is it?

00:56:12.269 --> 00:56:15.250
Data is still in English and the unit showed--

00:56:15.250 --> 00:56:25.480
shown here although translated still means
foot which is not the unit used typically

00:56:25.480 --> 00:56:29.289
in French, but that's not a localization issue

00:56:29.289 --> 00:56:33.690
As Lee mentioned, we use the proper
APIs here NSNumberFormatter

00:56:33.690 --> 00:56:39.750
and NSDateFormatter to rely on the locale settings.

00:56:39.750 --> 00:56:45.389
And if I check here, sure enough I'm
still using United States settings.

00:56:45.389 --> 00:56:49.009
If I change that to French--

00:56:49.010 --> 00:56:57.190
[ Pause ]

00:56:57.190 --> 00:57:00.860
>> This is now properly localized for French.

00:57:00.860 --> 00:57:09.510
The translated date, unit that is French.

00:57:09.510 --> 00:57:09.570
[ Applause ]

00:57:09.570 --> 00:57:16.269
>> And by the way, the number here is of
course addressed to-- it's recalculated.

00:57:16.269 --> 00:57:22.940
Okay. So back to the slide.

00:57:22.940 --> 00:57:35.389
So before we conclude let me give you a few design tips
that will allow you to make your app a good world citizen.

00:57:35.389 --> 00:57:45.389
If you design your app in English you need to know that most
languages or many languages let's say use longer strings,

00:57:45.389 --> 00:57:56.179
longer words, to say the same thing and it's a good
practice to allow for 25 to 30 % of growth of your UI.

00:57:56.179 --> 00:58:03.519
So try and keep leave some room around your text
objects so that localizers can increase them

00:58:03.519 --> 00:58:10.230
if the need without making your UI too busy.

00:58:10.230 --> 00:58:17.400
If you use a string with format and placeholder in
your string, those %@ that's were mentioned before,

00:58:17.400 --> 00:58:30.000
it's a good idea to index them using the $1 in the middle
or $2 or $3 and so on so that when you switch to Chinese

00:58:30.000 --> 00:58:39.070
or German, you have the ability, the localizers have
the ability to easily swap those variables around

00:58:39.070 --> 00:58:45.010
and keep just a good structure for
the sentence in their language.

00:58:46.179 --> 00:58:54.190
Also if you can afford it, try and use graphical
representation rather than textual for your button labels.

00:58:54.190 --> 00:59:01.869
That's the two examples shown here on Mac OS
and the iPhone where it's obviously easier

00:59:01.869 --> 00:59:09.819
to localize 'cause you don't have any text to translate
and it makes your UI more lightweight as well.

00:59:09.820 --> 00:59:18.440
And finally, those couple-- there are couple command
line tools like xmllint and plutil that can be used

00:59:18.440 --> 00:59:28.500
to verify the integrity of your localized .strings
files and make sure that they're structurally valid.

00:59:28.500 --> 00:59:41.320
Things to avoid are the following: the number one is
of course using string concatenation in your code.

00:59:41.320 --> 00:59:51.150
Putting pieces of a sentence together at runtime will
practically make that string impossible to localize.

00:59:51.150 --> 00:59:59.349
If you want to said you want-- you really want to save, you
really want to quit, then by all means, create two strings.

00:59:59.349 --> 01:00:05.380
There's no point in trying and optimized that by
having one string and the verb being a variable

01:00:05.380 --> 01:00:09.099
because that will break in some language structures.

01:00:09.099 --> 01:00:19.389
So instead, it's much better to use the
NSLocalizedString in combination with stringWIthFormat

01:00:19.389 --> 01:00:27.599
where you would have the full sentence in one
piece that localizers will do a better job with.

01:00:27.599 --> 01:00:36.389
>> Also don't assume gender and number in your strings.

01:00:36.389 --> 01:00:41.219
Those are two notions that vary a lot across languages.

01:00:41.219 --> 01:00:48.269
And if you want to say, "Your preferences will be
saved" or maybe "Your investments will be saved"

01:00:48.269 --> 01:00:54.139
or "Your children will be saved", it's much more
important to create three strings, same thing.

01:00:54.139 --> 01:00:59.940
"Your" and "saved" will likely be
translated very differently based

01:00:59.940 --> 01:01:04.990
on what the placeholder will be substituted with.

01:01:08.869 --> 01:01:17.579
And also, general, you know, guideline tip here which is
to keep text and graphics separate using text embedded

01:01:17.579 --> 01:01:22.909
within bitmaps will obviously make
that bitmap much harder to localize.

01:01:22.909 --> 01:01:30.980
It can be recreated but you setup in a word than having
them on separate layers or use 2 objects, distinct object,

01:01:30.980 --> 01:01:35.980
one for the text, one for the graphic behind it.

01:01:35.980 --> 01:01:47.639
And to finish, I'd like to a say word for iPhone
developers who intend to publish their app on the App Store.

01:01:47.639 --> 01:01:53.799
Apple's single binary multiple localization model allows you

01:01:53.800 --> 01:01:58.310
to ship one single application
with all your localizations in it.

01:01:58.309 --> 01:02:06.360
That simplifies in itself the submission process 'cause you
don't have to submit multiple times multiple applications

01:02:06.360 --> 01:02:15.530
and then wait just as long for each of them, instead you do
a single submission and if you support multiple languages,

01:02:15.530 --> 01:02:24.080
you can set your primary language at submission time
and you add additional languages in iTunes Connect.

01:02:24.079 --> 01:02:35.110
At the same time, you can also, and that's really
recommended, to provide localized product description

01:02:35.110 --> 01:02:40.200
and screenshots for each of those
localizations so that your customers

01:02:40.199 --> 01:02:44.689
on the App Store will see this
information in their language.

01:02:44.690 --> 01:02:52.119
So Apple's localization model is
really simple and really efficient.

01:02:52.119 --> 01:02:59.759
And by adopting it, your application will fit right in
on your customer's desktop and device around the world.

01:02:59.760 --> 01:03:01.000
Thank you.

01:03:01.000 --> 01:03:07.590
[ Applause ]

01:03:07.590 --> 01:03:08.090
>> Thank you J.

01:03:08.090 --> 01:03:09.230
J.

01:03:11.760 --> 01:03:18.750
So we talked about a very big topic today, a
lot of different aspects, internationalization,

01:03:18.750 --> 01:03:24.429
localization, there's just a lot to absorb.

01:03:24.429 --> 01:03:28.239
But in summary I like to just focus on a few things.

01:03:28.239 --> 01:03:29.029
Remember Unicode.

01:03:29.030 --> 01:03:31.910
It does everything you need.

01:03:31.909 --> 01:03:33.480
You don't need to worry about other encodings.

01:03:33.480 --> 01:03:35.949
In fact, you don't even think about
the encoding most of the time.

01:03:35.949 --> 01:03:37.699
Just use NSStrings.

01:03:37.699 --> 01:03:44.969
When you're dealing with Unicode, don't assume that
you can just deal with it character by character

01:03:44.969 --> 01:03:49.899
because as we found, you might be
breaking things up the wrong way.

01:03:49.900 --> 01:03:52.590
You might be trying to add things
together that don't add correctly.

01:03:52.590 --> 01:03:59.190
Do use the API we provide for doing this kind
of operations like measuring string length,

01:03:59.190 --> 01:04:05.139
for example, breaking words and characters.

01:04:05.139 --> 01:04:13.940
Don't try to write your own internationalization
support, there's a lot already built in.

01:04:13.940 --> 01:04:20.480
If you find something that's really missing or that's
broken, let us know, use radar, power plugs [phonetic].

01:04:20.480 --> 01:04:24.760
But I think everything you really need,
99 % of the time is already there.

01:04:24.760 --> 01:04:35.200
Just take the time to learn it and I think you'll
be well on your way to a good localized product.

01:04:35.199 --> 01:04:41.989
Above all, don't hard code strings in your
code, strings that are meant to be shown

01:04:41.989 --> 01:04:45.019
to users, because they're simply not localizable.

01:04:45.019 --> 01:04:47.900
There's no way to farm out your code.

01:04:47.900 --> 01:04:49.880
You don't want to farm out your code to a localizer.

01:04:49.880 --> 01:04:57.019
You want to have a separate .strings file that the localizer
could translate so they don't have to touch your code.

01:04:57.019 --> 01:05:04.269
And finally, avoid assumptions about the visual
layout of UI elements and menus of text on the screen;

01:05:04.269 --> 01:05:06.889
it could change depending on the language.

01:05:06.889 --> 01:05:10.259
Similarly, don't assume the order of words.

01:05:10.260 --> 01:05:13.900
Syntax and language are highly flexible.

01:05:13.900 --> 01:05:20.230
Your code and your data should be
similarly flexible to handle that.

01:05:20.230 --> 01:05:23.230
Okay, here are some more information.

01:05:23.230 --> 01:05:29.740
After the session you want to find, talk to
an evangelist, some useful documentation.
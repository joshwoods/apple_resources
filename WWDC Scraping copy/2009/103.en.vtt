WEBVTT

00:00:12.929 --> 00:00:18.600
>> My name is Josh and I'll be joined shortly by Jason,
and we're engineers on the iPhone Frameworks Team,

00:00:18.600 --> 00:00:23.109
and we're going to spend some time talking
this morning about some new ideas we've had

00:00:23.109 --> 00:00:27.149
about handling Multi-Touch events and
gestures over the course of the last year.

00:00:27.149 --> 00:00:32.269
We've all had some time now to play around with UITouch
and UIEvent and we've got some new things to talk about

00:00:32.270 --> 00:00:36.710
and some different ways that you might be
interested in handling events and gestures.

00:00:36.710 --> 00:00:38.859
And so, we'll get into that in a little bit.

00:00:38.859 --> 00:00:41.500
We're going to start out with a
bit of a review from last year.

00:00:41.500 --> 00:00:44.369
For those of you that were here
the first little bit is going

00:00:44.369 --> 00:00:46.729
to cover basically the same thing
that we talked about last year.

00:00:46.729 --> 00:00:51.219
For those of you that are new, this will be new
information obviously, but not quite as in-depth.

00:00:51.219 --> 00:00:54.640
So feel free to go back and check
out the session from last year.

00:00:54.640 --> 00:00:59.759
As soon as we're done with that, we'll start talking
about what's new in iPhone OS 3.0 in UIEvent,

00:00:59.759 --> 00:01:06.530
and talk about the new EventTypes and Subtypes, and
Jason will get into more depth about that later on.

00:01:06.530 --> 00:01:10.450
And then, we're going to start talking about
this new stuff that I've been referencing here.

00:01:10.450 --> 00:01:18.430
And we're going to talk about encapsulating your touch
handling, sort of taking multiple touches and handling them

00:01:18.430 --> 00:01:23.760
in separate objects as sort of discrete
gestures, and kind of trying to get away

00:01:23.760 --> 00:01:28.240
from the really large complex state machines you might
have to have been building over the last year in order

00:01:28.239 --> 00:01:31.899
to handle differentiating between a pinch and a rotation.

00:01:31.900 --> 00:01:33.500
We'll talk about ways that you can handle that

00:01:33.500 --> 00:01:38.450
And finally, Jason will come up and talk
about some best practices and some Gotchas,

00:01:38.450 --> 00:01:40.680
some issues that we've seen people
having over the last year,

00:01:40.680 --> 00:01:43.610
and some things that maybe we can
do better in the coming year.

00:01:43.609 --> 00:01:46.679
So, start out with a little bit of a review.

00:01:46.680 --> 00:01:48.230
What is a Touch Sequence?

00:01:48.230 --> 00:01:54.010
So touch starts when a finger comes down on the screen,
continues while the finger is moving and finally ends

00:01:54.010 --> 00:01:56.820
when the finger lifts, that's pretty basic.

00:01:56.819 --> 00:02:01.679
So what's happening in your application
and what do you get from UKit during this.

00:02:01.680 --> 00:02:06.910
Well, when the finger comes down on the
screen, we create a new UITouch object.

00:02:06.909 --> 00:02:13.150
And this UITouch object, this same instance, is going to be
used to represent this finger for the entire touch sequence.

00:02:13.150 --> 00:02:18.330
So as your finger moves on the screen, we're going to
update this one instance and continue to deliver messages

00:02:18.330 --> 00:02:21.820
about that touch using the same touch instance.

00:02:21.819 --> 00:02:28.159
The implication there is that you can use the address
of this touch as a unique key to associate data with it.

00:02:28.159 --> 00:02:32.379
So if you needed to associate, for
instance, the point at which our touch began,

00:02:32.379 --> 00:02:36.769
at the beginning of its touch sequence, the touch
doesn't remember that on its own, but you could associate

00:02:36.770 --> 00:02:41.980
that with a particular touch pointer
that you get back in touchesBegan.

00:02:41.979 --> 00:02:44.049
So, we've created this new UITouch.

00:02:44.050 --> 00:02:47.990
Its phase is Began, and we're going to
update the phase as the finger moves.

00:02:47.990 --> 00:02:49.650
And it has a location.

00:02:49.650 --> 00:02:52.409
So now user has put their finger down.

00:02:52.409 --> 00:02:53.969
We've created this touch.

00:02:53.969 --> 00:02:59.689
We'll talk about where this gets delivered in a little
bit, but what happens is we call touchesBegan withEvent

00:02:59.689 --> 00:03:05.300
on the target view, and we'll pass in--
this thing will take two parameters.

00:03:05.300 --> 00:03:11.290
It will take an NSSet, which is the set of touches that
have began since the last time we told you about touches,

00:03:11.289 --> 00:03:17.699
and an event which contains more information about all the
other touches, and we'll talk about that in a minute too.

00:03:17.699 --> 00:03:23.169
So as the user moves their finger, we're going to update
the touches phase to Moved, it might have a new location.

00:03:23.169 --> 00:03:25.039
Well, obviously if it's moved, it will.

00:03:25.039 --> 00:03:28.489
And we'll deliver it with touchesMoved withEvent.

00:03:28.490 --> 00:03:34.280
And all of these touch delivery methods are going to
have the same basic parameters they will have an NSSet

00:03:34.280 --> 00:03:37.960
of touches, these are just the touches that
have moved, even if there's other touches,

00:03:37.960 --> 00:03:41.800
they won't be included in the set
unless they're moving, and the event.

00:03:41.800 --> 00:03:47.310
So as the user continues to move their finger,
we'll continue to update the same touch instance,

00:03:47.310 --> 00:03:52.310
it will still have the touches moved, UITouch
phase moved in a new location, and again,

00:03:52.310 --> 00:03:55.259
we'll call touchesMoved, same things as it happens again.

00:03:55.259 --> 00:03:58.359
And finally, when the finger lifts,
we'll update the phase to Ended,

00:03:58.360 --> 00:04:02.570
change its location, and call touchesEnded withEvent.

00:04:02.569 --> 00:04:06.349
Now that's the basic normal series
of things that happens on a touch.

00:04:06.349 --> 00:04:13.159
And one thing that we've seen over the last
year is the feeling that maybe touchesCancelled

00:04:13.159 --> 00:04:15.699
which is the fourth member of this set, is optional.

00:04:15.699 --> 00:04:19.920
And we'd really like to stress that
actually touchesCancelled is not optional.

00:04:19.920 --> 00:04:21.780
If you're implementing touch handling
and you're trying to look

00:04:21.779 --> 00:04:25.399
for the entire sequence of a touch, it may not actually end.

00:04:25.399 --> 00:04:27.109
It may instead be cancelled at some point.

00:04:27.110 --> 00:04:28.800
And there are a few reasons for that.

00:04:28.800 --> 00:04:33.590
It can happen if a phone call comes in, if the user
turns off the device while touches are on the screen,

00:04:33.589 --> 00:04:35.829
if the user puts down more than five fingers,

00:04:35.829 --> 00:04:39.550
we actually end up cancelling all the
touches 'cause we can't track more than that.

00:04:39.550 --> 00:04:44.020
So there are actually quite a few
reasons and if you're using scroll views,

00:04:44.019 --> 00:04:46.899
you'll have touches being cancelled
inside the scroll view as well.

00:04:46.899 --> 00:04:49.919
So if you're implementing touch handling
and not getting touchesEnded called,

00:04:49.920 --> 00:04:51.710
make sure that you're checking for touchesCancelled as well.

00:04:51.709 --> 00:04:53.819
So we got a little sample of that too.

00:04:53.819 --> 00:04:59.490
User's finger comes down, and we create a new
UITouch, its phase is Began, it has a location.

00:04:59.490 --> 00:05:04.569
As the user moves their finger, we update
the phase to moved, and the location changes,

00:05:04.569 --> 00:05:07.040
but now, we got a call from John Appleseed.

00:05:07.040 --> 00:05:12.910
And so we're going to cancel that touch at that
point, we'll set the touches phase to Cancelled

00:05:12.910 --> 00:05:17.130
and we'll call touchesCancelled withEvent,
and there are two LLs in that not one.

00:05:17.129 --> 00:05:21.439
So make sure you type that one right.

00:05:21.439 --> 00:05:25.089
Alright, so UITouch, that's the basic thing
that represents a finger on the screen.

00:05:25.089 --> 00:05:30.329
But this is a Multi-Touch device, and there may
be multiple fingers on the screen at any one time.

00:05:30.329 --> 00:05:34.919
So we actually have this other object, UIEvent, which
knows about all the touches that are on the screen,

00:05:34.920 --> 00:05:37.090
regardless of where they are or what phase they're in.

00:05:37.089 --> 00:05:41.079
And that's as we saw just a minute ago
also delivered with all the touches.

00:05:41.079 --> 00:05:48.669
So the UIEvent, as I said, knows about all these touches,
and every touch is associated with a particular window,

00:05:48.670 --> 00:05:52.370
and the event knows what window
each touch is associated with.

00:05:52.370 --> 00:05:56.879
Each touch is also associated with a particular
view, and the event knows that mapping as well.

00:05:56.879 --> 00:06:00.670
So you can ask the event for information
about these touches.

00:06:00.670 --> 00:06:03.860
You can ask it for all the touches, and it
will give you back the set of all the touches

00:06:03.860 --> 00:06:07.889
that are currently active anywhere on the screen,
regardless of what window or view they're in.

00:06:07.889 --> 00:06:10.689
You can ask it for all the touches for a particular window,

00:06:10.689 --> 00:06:14.319
so all the touches in window A will return
the set of touches that are in Window A.

00:06:14.319 --> 00:06:21.009
And finally, you can ask for the touches in a particular
view, which will return for instance, the touches in View A.

00:06:21.009 --> 00:06:25.899
[ Pause ]

00:06:25.899 --> 00:06:30.879
>> Alright, so with UITouch and UIEvent,
those are the most basic building blocks

00:06:30.879 --> 00:06:33.209
on which all other Multi-Touch processing is built.

00:06:33.209 --> 00:06:37.549
There is one other class in UIKit that provides
a bit of a higher level view on these things.

00:06:37.550 --> 00:06:42.939
If you don't want to deal with UITouch and UIEvent directly,
and all you're looking for is some of the basic types

00:06:42.939 --> 00:06:45.600
of information that UIControl might be interested in,

00:06:45.600 --> 00:06:49.340
you might be able to use UIControl instead
of having to subclass UIView directly.

00:06:49.339 --> 00:06:52.419
UIControl is a subclass of UIView, and it just--

00:06:52.420 --> 00:06:56.600
it implements the touch processing methods
and provides this higher level view of events.

00:06:56.600 --> 00:07:00.810
So we're not going to cover this too much, but we'll quickly
talk about some of the things that you can ask the control

00:07:00.810 --> 00:07:04.459
for information about and you just
register a target action so any object

00:07:04.459 --> 00:07:08.379
in your application could be notified
of these particular events.

00:07:08.379 --> 00:07:13.420
So you can find out when a touch comes down in that
control, you can find out when it comes down repeatedly,

00:07:13.420 --> 00:07:16.069
which is the same as the tap count property on UITouch.

00:07:16.069 --> 00:07:18.209
If the user is tapping, you'll get touch down repeat.

00:07:18.209 --> 00:07:26.709
You can ask it for information about the user dragging
their finger within and outside of the control.

00:07:26.709 --> 00:07:32.189
You can find out when the user is dragging and
they enter or leave the bound of the control,

00:07:32.189 --> 00:07:36.219
and you can find out when the finger is
lifted either inside or outside the control.

00:07:36.220 --> 00:07:41.560
And finally, you can also find out if touches are cancelled,
because touchesCancelled is actually quite important.

00:07:41.560 --> 00:07:49.120
Alright, so those are the basic building
blocks and that's pretty much the full review

00:07:49.120 --> 00:07:52.500
of what we covered last year in a
bit of a condensed format there.

00:07:52.500 --> 00:07:54.500
So I'm going to do a quick Multi-Touch demo.

00:07:54.500 --> 00:07:59.939
For those of you that have checked out the Multi-Touch
sample code on developer.apple.com, this is basically that.

00:07:59.939 --> 00:08:01.399
So we're going to go through it pretty quickly.

00:08:01.399 --> 00:08:08.009
You can check it out after the show as well, and if you were
here last year, you've probably already seen most of this.

00:08:08.009 --> 00:08:09.349
So let's see what we got.

00:08:09.350 --> 00:08:13.430
We basically have the Xcode project
template for a new application.

00:08:13.430 --> 00:08:17.199
So I've got my Multi-Touch demo application
delegate that you get just right out of the box.

00:08:17.199 --> 00:08:18.969
There's really nothing custom in here.

00:08:18.970 --> 00:08:22.430
I've got a ViewController that you get,
there's really nothing new here yet either.

00:08:22.430 --> 00:08:25.879
And we've just implemented View
DidLoad to call superview DidLoad

00:08:25.879 --> 00:08:29.399
and then set the background color of our view to white.

00:08:29.399 --> 00:08:30.279
So let's get started.

00:08:30.279 --> 00:08:35.970
The first thing that we're going to do is add a little
helper method up here which is going to create our images.

00:08:35.970 --> 00:08:40.389
If you saw in that video that we had up there, there
was basically-- we're going to have three images,

00:08:40.389 --> 00:08:44.899
and we're going to let the user drag them around
and rotate them and pinch them and zoom them.

00:08:44.899 --> 00:08:50.789
So I've got this helper method that's just going to take
an image name which is going to be the name of an image

00:08:50.789 --> 00:08:54.610
that we have in our bundle, and a center point
where we want to place that image on the screen.

00:08:54.610 --> 00:08:59.980
So we're just going to calculate the rectangle that we want
to end up showing that image in, and create a new instance

00:08:59.980 --> 00:09:02.720
of a Touch Image View which we're
going to write in just a minute.

00:09:02.720 --> 00:09:07.420
This is a subclass of UIImageView that we're going
to add touch handling to so that it knows how

00:09:07.419 --> 00:09:11.579
to rotate itself and translate itself and scale itself.

00:09:11.580 --> 00:09:16.490
So we'll set our Image View's image, set its
center point so that we position it on the screen,

00:09:16.490 --> 00:09:22.519
add it as a subview of our ViewController's view and release
it because we don't actually need a reference to it anymore.

00:09:22.519 --> 00:09:24.149
So now we've got that helper method written.

00:09:24.149 --> 00:09:27.759
We're just going to call it three times with three
different images and three different center points.

00:09:27.759 --> 00:09:30.220
So let me get a stack of three images down the screen.

00:09:30.220 --> 00:09:34.740
So that's all we really have to do on our ViewController.

00:09:34.740 --> 00:09:35.700
We've created our views.

00:09:35.700 --> 00:09:38.360
And so now, let's go implement touch Image View.

00:09:38.360 --> 00:09:41.250
I've already defined two instance variables in the header.

00:09:41.250 --> 00:09:45.240
The first is this original transform
which is a CGAffineTransform.

00:09:45.240 --> 00:09:48.210
If you're not familiar with this, it's
just a Core Graphics data structure

00:09:48.210 --> 00:09:51.430
that can represent a rotation, a scale, and a translation.

00:09:51.429 --> 00:09:57.909
So we'll use that to store basically the baseline
transform that we're going to modify as we get touches.

00:09:57.909 --> 00:10:02.539
And then we'll also need to store the touch
begin points, 'cause as I mentioned earlier,

00:10:02.539 --> 00:10:06.500
UITouch doesn't remember what position
it originally began at.

00:10:06.500 --> 00:10:11.830
So if we need that information, which we do here, we're
going to save it off in a mutable dictionary that we'll use

00:10:11.830 --> 00:10:15.190
to map the touch instance to the point at which it began.

00:10:16.830 --> 00:10:19.430
>> Alright, so in our implementation, not much here yet.

00:10:19.429 --> 00:10:26.359
We just have an initializer that's called super
and dalloc to release our touch begin points.

00:10:26.360 --> 00:10:30.639
So let's start out by initializing these data members here.

00:10:30.639 --> 00:10:33.740
We're going to set our original
transform to the identity transform

00:10:33.740 --> 00:10:36.889
which means no scale, no rotation, and no translation.

00:10:36.889 --> 00:10:42.009
And we're going to initialize our begin points with the new
CF mutable dictionary that we use to store this mapping.

00:10:42.009 --> 00:10:51.319
One other thing that we have to turn on here is the
Multi-Touch and user interaction enabled properties.

00:10:51.320 --> 00:10:57.390
So user interaction enabled is by default
YES for UIView but for UIImageView,

00:10:57.389 --> 00:10:59.590
it's actually default-- its default value is NO.

00:10:59.590 --> 00:11:04.750
So if we don't turn it back on, we'll actually never get
any of the touch delivery methods called on our image view,

00:11:04.750 --> 00:11:06.870
so we wouldn't see anything, any touches at all.

00:11:06.870 --> 00:11:08.850
And we'll also going to turn on Multiple Touch.

00:11:08.850 --> 00:11:12.080
And the default value of Multiple Touch is NO for all views.

00:11:12.080 --> 00:11:15.860
So if you need to be able to process multiple
touches, you'll have to turn this back ON

00:11:15.860 --> 00:11:22.110
or your touch methods will only ever get one at a time.

00:11:22.110 --> 00:11:23.830
Alright, so we've got those two things turned on.

00:11:23.830 --> 00:11:27.639
Now we can start to implement the actual
touch handling methods themselves.

00:11:27.639 --> 00:11:30.220
So we're going to start out with touchesBegan.

00:11:30.220 --> 00:11:33.649
The first thing we want to do is get
the set of touches that were already

00:11:33.649 --> 00:11:36.579
in existence before the touches that are beginning now.

00:11:36.580 --> 00:11:42.180
So as I mentioned the touch set here that we're getting
and touchesBegan is the set of touches that are beginning

00:11:42.179 --> 00:11:44.989
but there may be other touches active in our view right now.

00:11:44.990 --> 00:11:50.919
So we can find out about that from the event by asking the
event for all the touches that are currently in our view.

00:11:50.919 --> 00:11:54.259
And from that we can subtract out
the ones that are currently beginning

00:11:54.259 --> 00:11:56.519
and that leaves us with the ones that were there before.

00:11:56.519 --> 00:12:02.139
Now the reason we want to do this is because we're keeping
that original transform which is basically the transform

00:12:02.139 --> 00:12:07.080
that we're going to apply an incremental
transform to as we detect new movement.

00:12:07.080 --> 00:12:11.690
And every time that we get a new touch starting
or a touch ending, we're going to re-baseline this

00:12:11.690 --> 00:12:16.520
so that we have a new original transform to start from
and our incremental transform will be from that point

00:12:16.519 --> 00:12:20.939
up until whatever the current movement, set of movement is.

00:12:20.940 --> 00:12:23.880
So we've got the touches that were already in existence.

00:12:23.879 --> 00:12:29.340
So we'll calculate a new baseline transform from
that and I've got a helper method that does that.

00:12:29.340 --> 00:12:32.590
There's a bunch of math here, you can
check it out in the sample code after.

00:12:32.590 --> 00:12:37.310
It's basically solving a system of equations,
the calculator rotation and a transform and--

00:12:37.309 --> 00:12:42.479
I'm sorry, a rotation, a scale, and
a translation from the touch points.

00:12:42.480 --> 00:12:44.769
But we're going to kind of gloss over that at the moment.

00:12:44.769 --> 00:12:48.329
So we've re-baselined our transform, we also
want to re-cache the touch begin points.

00:12:48.330 --> 00:12:52.540
'Cause now that we've calculated a new baseline
transform, all of our touches are going to be--

00:12:52.539 --> 00:12:56.439
sorry, our incremental transform will
be calculated from this new baseline.

00:12:56.440 --> 00:12:59.500
So we want new began points for all
of the touches that already existed.

00:12:59.500 --> 00:13:05.289
And we're going also cache begin points
for touches that are just starting now.

00:13:05.289 --> 00:13:06.559
Alright, so that's touchesBegan.

00:13:06.559 --> 00:13:09.299
Now we can do touchesMoved which
is where we're actually going

00:13:09.299 --> 00:13:13.259
to calculate any new transforms and apply it to the view.

00:13:13.259 --> 00:13:18.269
So we'll start implementing touchesMoved and calculate
this incremental transform I was talking about.

00:13:18.269 --> 00:13:22.860
So I've got a helper method that does this as well and
it basically takes the touch begin points that we've got

00:13:22.860 --> 00:13:27.560
in our touch begin points dictionary and the current
point of all the touches that we're going to get back

00:13:27.559 --> 00:13:32.129
from the event by asking the event for all the touches
in our view, and it'll calculate the rotation, the scale,

00:13:32.129 --> 00:13:38.139
and the translation based on the difference between
those points and return that as a new CGAffineTransform

00:13:38.139 --> 00:13:41.679
which is the incremental transform
from what we cached as our baseline.

00:13:41.679 --> 00:13:46.269
So we can then set our views transform to the concatenation

00:13:46.269 --> 00:13:49.620
of our baseline transform plus
this new incremental transform.

00:13:49.620 --> 00:13:53.600
So that's began and moved.

00:13:53.600 --> 00:13:57.240
Now we'll implement touchesEnded to clean up a touch list.

00:13:57.240 --> 00:14:03.000
So we-- as I mentioned we're going to re-baseline
our touches now since the number of touches

00:14:03.000 --> 00:14:07.820
in our view is changing and we're going to re-baseline it
based on all the touches that are currently in the view.

00:14:07.820 --> 00:14:14.300
And then we're going to remove from the cache any
touches that are ending because we're not going

00:14:14.299 --> 00:14:15.870
to be notified about these touches anymore.

00:14:15.870 --> 00:14:20.310
They're done and we don't want to end up leaving them in
our touch cache or we'll have some stale data and we'll end

00:14:20.309 --> 00:14:22.809
up leaking memory and all matter of bad things.

00:14:22.809 --> 00:14:28.959
So we want to clean up our cache by removing those
touches and re-cache any of the remaining touches.

00:14:28.960 --> 00:14:33.269
So we're going to do basically the same thing we did in
touchesBegan ask the event for all the touches in our view

00:14:33.269 --> 00:14:36.340
and subtract out the ones that are ending
and what we're left with are the ones

00:14:36.340 --> 00:14:38.240
that are still going to be active in the view.

00:14:38.240 --> 00:14:42.529
So we're going to re-cache any begin points
for those since we've now re-baselined things.

00:14:42.529 --> 00:14:46.549
And additionally-- and then we're done
with that touchesEnded, I think [phonetic].

00:14:46.549 --> 00:14:51.389
Now as I mentioned touchesCancelled is also a very
important member of this four-member family here.

00:14:51.389 --> 00:14:53.210
So we also want to implement that.

00:14:53.210 --> 00:14:57.980
Now generally speaking, when you get touchesCancelled,
the idea is that you don't want to perform some action

00:14:57.980 --> 00:15:02.340
as a result of receiving touchesCancelled because
some event has happened that has caused the user

00:15:02.340 --> 00:15:05.200
to not perform whatever action
they were starting to perform.

00:15:05.200 --> 00:15:08.009
In our case, we're just dragging
things around on the screen.

00:15:08.009 --> 00:15:11.350
So it's pretty reasonable to just
drop them in place where they were.

00:15:11.350 --> 00:15:14.300
So we're actually just going to call
touchesEnded on ourselves to do that.

00:15:14.299 --> 00:15:19.479
Now this is fine in this case because we don't
end up calling super touchesEnded up here.

00:15:19.480 --> 00:15:24.110
If our touchesEnded implementation actually called
super, this could potentially be a pretty big problem

00:15:24.110 --> 00:15:31.730
because our superclass or potentially superview would end up
getting touchesEnded for a touch that's actually cancelled

00:15:31.730 --> 00:15:36.039
and then it could get out of sync, it would
not actually know that touch was cancelled.

00:15:36.039 --> 00:15:37.289
We wouldn't really want that.

00:15:37.289 --> 00:15:39.709
But since we don't call super,
all this code is self-contained.

00:15:39.710 --> 00:15:48.060
We're just going to call touchesEnded and
kind of take the cheap way out right now.

00:15:48.059 --> 00:15:56.179
Alright, so with all that done, we're just going to build
and run and now we've got a bit of a crash [laughter].

00:15:56.179 --> 00:15:57.519
Let's check out what's up there.

00:15:57.519 --> 00:15:57.799
[ Audience Remark ]

00:15:57.799 --> 00:15:59.229
>> What's that?

00:15:59.230 --> 00:16:00.990
>> We get to learn about debugging.

00:16:00.990 --> 00:16:04.210
>> Yeah that's,-- yeah, oh hey
we're building against the 2.0 SDK.

00:16:04.210 --> 00:16:07.000
That's probably not what I meant.

00:16:07.000 --> 00:16:10.049
Oops, I lost the window.

00:16:10.049 --> 00:16:15.609
We'll look at this real quick and if it's not obvious we're
going to move on but -- did you look image name center.

00:16:15.610 --> 00:16:17.759
It does not exist, eh.

00:16:17.759 --> 00:16:23.439
I think it was the SDK that was our problem.

00:16:23.440 --> 00:16:26.940
Yeah. Alright, so this time for sure.

00:16:26.940 --> 00:16:32.140
We've got this image that we can drag around and we enabled
Multi-Touch support and we're calculating the rotations

00:16:32.139 --> 00:16:35.559
and scales so we can put two fingers in one
and we can rotate them around and scale them.

00:16:35.559 --> 00:16:40.469
And we can also put two fingers in
different ones and move those around.

00:16:40.470 --> 00:16:41.509
[ Pause ]

00:16:41.509 --> 00:16:47.730
[ Applause ]

00:16:47.730 --> 00:16:51.269
>> Alright, oops, what did I do with my remote?

00:16:51.269 --> 00:16:53.439
There you go.

00:16:53.440 --> 00:16:55.670
Oh hey, this is the example of what you're going to see.

00:16:55.669 --> 00:16:58.049
I hope I didn't ruin it.

00:16:58.049 --> 00:17:02.259
Alright, oh and we're going to see a demo.

00:17:02.259 --> 00:17:08.839
Alright, so [laughter], now let's talk about
what's new in iPhone OS 3.0 regarding UIEvent.

00:17:08.839 --> 00:17:10.529
So we've got a couple of new things here.

00:17:10.529 --> 00:17:13.180
We've got a new EventType property.

00:17:13.180 --> 00:17:16.310
So there are actually two EventTypes that are possible now.

00:17:16.309 --> 00:17:19.990
Everything we talked about so far,
the UIEvent is a touches Event.

00:17:19.990 --> 00:17:24.009
It knows about the touches that are
happening on screen and it's being sent to you

00:17:24.009 --> 00:17:28.059
to report touches beginning, moving,
ending, or being cancelled.

00:17:28.059 --> 00:17:31.149
So that's type UIEventTypeTouches.

00:17:31.150 --> 00:17:33.830
But now there's also a new type, UIEventTypeMotion.

00:17:33.829 --> 00:17:40.059
And UIEventTypeMotion is used to deliver information
about physical movement of the device to your application.

00:17:40.059 --> 00:17:44.609
Jason is going to talk a little bit
more about the specifics of this later.

00:17:44.609 --> 00:17:46.500
So we're going to gloss over it at the moment.

00:17:46.500 --> 00:17:50.200
There's also this new UIEventSubtype property.

00:17:50.200 --> 00:17:56.140
And the subtype is currently either UIEventSubtypeNone
which all UIEventType touches are subtype none

00:17:56.140 --> 00:18:02.050
or UIEventSubtypeMotionShake and currently
all motion events are subtype motion shake.

00:18:02.049 --> 00:18:05.740
So, you know, pretty easy to know what's going to
happen but do check it out when you're using it

00:18:05.740 --> 00:18:08.250
because things could change in the future.

00:18:09.650 --> 00:18:11.500
Alright, so we've talked about touches.

00:18:11.500 --> 00:18:17.460
We've talked about events and we know what they are and we
kind of saw that, we're getting events delivered to our view

00:18:17.460 --> 00:18:21.029
but we didn't really talk about how
we decide what view gets the events.

00:18:21.029 --> 00:18:25.129
And things are a little different when
we start talking about motion events.

00:18:25.130 --> 00:18:27.480
So let's look at that.

00:18:27.480 --> 00:18:30.559
For those of that have been working on
this, you're familiar with UIResponder.

00:18:30.559 --> 00:18:34.429
A lot of objects on our system
are sub classes of UIResponder.

00:18:34.430 --> 00:18:36.820
UIView is a subclass of UIResponder.

00:18:36.819 --> 00:18:39.139
UIViewController is a subclass of UIResponder.

00:18:39.140 --> 00:18:46.509
And anything that's a subclass of UIResponder can
implement and receive any of these touchesEvents--

00:18:46.509 --> 00:18:49.619
sorry, touch delivery methods that
we were just talking about.

00:18:49.619 --> 00:18:54.699
But how do we figure out which object in
your application is the one that gets it?

00:18:54.700 --> 00:19:03.630
Well for UIEventType touchesEvents the UIWindow will call
hitTest withEvent on all of its subviews trying to figure

00:19:03.630 --> 00:19:06.630
out which one is the one that needs to handle this event.

00:19:06.630 --> 00:19:14.040
So the default implementation of this makes sure that
the touch is actually within the frame of the view

00:19:14.039 --> 00:19:20.690
and that the view is not hidden that it has an alpha
that doesn't make it fully transparent and if all

00:19:20.690 --> 00:19:23.940
of those conditions are met, it
will return itself or possibly one

00:19:23.940 --> 00:19:28.320
of its subviews if some subview is also the hit view.

00:19:28.319 --> 00:19:33.210
So yeah, sorry, this is recursively called through the view
hierarchy to figure out the deepest view that gets hit.

00:19:33.210 --> 00:19:38.799
And the view that gets returned from this, the deepest view
on the view hierarchy, is the one that the touch gets bound

00:19:38.799 --> 00:19:43.990
to and all further events for that
touch will be delivered to that view.

00:19:43.990 --> 00:19:46.430
But things are slightly different with motion events.

00:19:46.430 --> 00:19:49.160
Your finger may not even be on
the screen for a motion event.

00:19:49.160 --> 00:19:52.150
If the user is shaking the phone, they
probably don't have a finger down.

00:19:52.150 --> 00:19:55.480
We can't just hitTesting to figure
out where we need to deliver that.

00:19:55.480 --> 00:19:59.049
So for motion events, we actually
send the event to the first responder.

00:19:59.049 --> 00:20:00.519
I'm not really going to talk about this right now.

00:20:00.519 --> 00:20:03.660
Jason will cover that later on when he comes up.

00:20:03.660 --> 00:20:07.390
But the important thing to remember is that for
touches events, we'll send it to the hitTest view,

00:20:07.390 --> 00:20:11.090
and for motion events we'll send it to the first responder.

00:20:11.089 --> 00:20:16.389
So what happens after we've delivered it
to the first responder or the hitTest view?

00:20:16.390 --> 00:20:19.430
>> Well, we're going to assume for the purposes
of what we're going to talk about right now

00:20:19.430 --> 00:20:22.970
that this view here is both our
hitTest View and our FirstResponder.

00:20:22.970 --> 00:20:28.799
So it's going to get all motion events and also
the touches events that we're talking about now.

00:20:28.799 --> 00:20:32.700
So, we call touchesBegan, Moved,
Ended, and Cancelled on this view.

00:20:32.700 --> 00:20:37.569
If this view doesn't handle them, then it will get passed
up the responder chain to that view's ViewController.

00:20:37.569 --> 00:20:41.789
And that view's ViewController will have
a chance to look at these touch events.

00:20:41.789 --> 00:20:47.230
If the view did handle them, it would not get passed
up the responder chain unless you had called super.

00:20:47.230 --> 00:20:53.490
If the ViewController doesn't handle them, it
will get passed up to the view's superview.

00:20:53.490 --> 00:20:56.599
If that view doesn't handle it,
its ViewController gets a chance.

00:20:56.599 --> 00:21:03.109
If the-- and again, up the view hierarchy-- sorry, up the
responder chain which is equivalent of the view hierarchy

00:21:03.109 --> 00:21:06.959
in this case, then over to the, that view's ViewController.

00:21:06.960 --> 00:21:10.350
If that ViewController doesn't handle
it, it will go up to the window.

00:21:10.349 --> 00:21:15.289
And if the window doesn't handle it, then
the UIApplication object will have a chance.

00:21:15.289 --> 00:21:19.730
Now, generally speaking, your application won't
have quite so many ViewControllers imbedded.

00:21:19.730 --> 00:21:22.299
So it'll usually look a bit more like this.

00:21:22.299 --> 00:21:26.940
But the important part is view to superview
to superview, any view's ViewController

00:21:26.940 --> 00:21:30.620
in there will get a chance to get it, window, application.

00:21:30.619 --> 00:21:34.309
Alright, so that's the event delivery thing.

00:21:34.309 --> 00:21:40.269
Now, you might be thinking here, there's one
view that actually gets to handle these events.

00:21:40.269 --> 00:21:46.470
But what if I want to handle something like a
pinch, and the two touches start in different views,

00:21:46.470 --> 00:21:50.680
but-and so they're hitTested to different views,
where do I want to put my logic to handle this?

00:21:50.680 --> 00:21:55.250
It becomes a little bit tricky and you have to
start trying to coordinate between these views,

00:21:55.250 --> 00:22:00.329
and you might end up with some pretty complicated
state machines to track whether you mean move one view,

00:22:00.329 --> 00:22:03.220
or a pinch means, you know, scale the whole thing.

00:22:03.220 --> 00:22:07.640
It starts to get a little bit tricky and so
let's talk about ways that you can solve that.

00:22:07.640 --> 00:22:11.980
By grouping these touches together, and
starting to treat them as more of a gesture

00:22:11.980 --> 00:22:15.610
than individual touches in separate views.

00:22:15.609 --> 00:22:19.059
So, we've got the basic case.

00:22:19.059 --> 00:22:20.240
This is the really easy one, alright?

00:22:20.240 --> 00:22:22.750
You've got a single touch and it's happening in one view.

00:22:22.750 --> 00:22:23.809
That view has been hitTested.

00:22:23.809 --> 00:22:26.740
You put your logic in there to handle
touches and everything's great.

00:22:26.740 --> 00:22:27.240
No problem.

00:22:27.240 --> 00:22:32.299
We can put that one touch there, drag
around this one view, everything is easy.

00:22:32.299 --> 00:22:34.899
It's not even that much harder when we
start talking about Multiple Touches

00:22:34.900 --> 00:22:37.360
if those Multiple Touches are in that one view.

00:22:37.359 --> 00:22:42.339
We just saw doing this, we can put all that
logic in one view, and it's all pretty easy.

00:22:42.339 --> 00:22:47.279
And the same thing with Multiple Touches in
separate views, if what we mean is what we just saw

00:22:47.279 --> 00:22:51.889
with those two touches meaning, move those two views around.

00:22:51.890 --> 00:22:56.740
But things start to get a little more complicated if
we start wanting those two touches to work together.

00:22:56.740 --> 00:23:01.740
And instead of moving those two views, we
want them to actually scale everything.

00:23:01.740 --> 00:23:04.370
So, where do we want to put this logic?

00:23:04.369 --> 00:23:09.709
Because we still want each individual view to track
one touch in it as an attempt to move that view.

00:23:09.710 --> 00:23:14.900
It's just that when two touches come down in
different views, we want to start scaling everything.

00:23:14.900 --> 00:23:16.960
So we've talked about these Event Delivery Methods.

00:23:16.960 --> 00:23:19.069
We've got touchesBegan, Moved, Ended and Cancelled,

00:23:19.069 --> 00:23:23.559
and those are sent to the FirstResponder,
sorry, the hitTest view.

00:23:23.559 --> 00:23:27.159
But what we didn't talk about is
where these things get called from.

00:23:27.160 --> 00:23:30.660
So UIWindow actually has a method called sendEvent.

00:23:30.660 --> 00:23:36.860
And sendEvent is basically the funnel point through which
all of these UIEvents get passed, and sendEvent breaks them

00:23:36.859 --> 00:23:41.839
down into their individual touches, it looks and sorts
them by phase and by view and calls the touchesBegan,

00:23:41.839 --> 00:23:44.769
Moved and Ended methods on each of the individual views.

00:23:44.769 --> 00:23:52.619
And that is in turn, called by UIApplication sendEvent which
passes the event up to whatever window needs to see it.

00:23:52.619 --> 00:23:57.879
So we can take advantage of knowing that sendEvent is
this funnel point, and override that to take a look

00:23:57.880 --> 00:24:01.770
at all the touches before they're
even delivered to any of the views.

00:24:01.769 --> 00:24:03.599
You want to be careful if you're doing this though.

00:24:03.599 --> 00:24:09.669
You subclass UIWindow and overwrite sendEvent, it's a great
place to observe touches and watch them as they're going by.

00:24:09.670 --> 00:24:12.289
Not a good place to try and control delivery.

00:24:12.289 --> 00:24:18.240
The touches are delivered in one event and there may be
touches bound for multiple views and different phases.

00:24:18.240 --> 00:24:23.529
If you implemented sendEvent and didn't call super in
certain cases, some views in your application might end

00:24:23.529 --> 00:24:27.379
up seeing only a partial touch sequence
and ending up getting out of sequence.

00:24:27.380 --> 00:24:31.520
So if you override this, always do call super sendEvent.

00:24:31.519 --> 00:24:34.730
Alright, so let's take a look at what we've got now.

00:24:34.730 --> 00:24:37.059
This is our current application that we just built, right.

00:24:37.059 --> 00:24:41.500
We're going to sketch it out a little bit, got
our UIApplication object and our UIWindow object.

00:24:41.500 --> 00:24:45.710
We've got our ViewController's View which is
containing these three separate image views.

00:24:45.710 --> 00:24:48.029
So as things are working right now, in what we just wrote,

00:24:48.029 --> 00:24:52.730
the UIApplication sendEvent is the
first thing that gets to see this event.

00:24:52.730 --> 00:24:56.259
That in turn calls sendEvent on UIWindow.

00:24:56.259 --> 00:25:00.849
So sendEvent on UIWindow then breaks these
things out, and calls touchesBegan, Moved,

00:25:00.849 --> 00:25:05.309
Ended and Cancelled on all the appropriate
views after filtering the touches

00:25:05.309 --> 00:25:09.279
out for what view they're actually bound
to and sends them to the appropriate view.

00:25:09.279 --> 00:25:11.690
And that's great for what we were trying to do.

00:25:11.690 --> 00:25:15.740
But that doesn't really work so well
for what we're trying to accomplish now.

00:25:15.740 --> 00:25:19.210
So, come on.

00:25:20.269 --> 00:25:21.470
Yeah, yeah, OK.

00:25:21.470 --> 00:25:25.740
You know what, that might be a different game.

00:25:25.740 --> 00:25:28.730
Let's skip that for now.

00:25:28.730 --> 00:25:36.009
OK, so let's shrink this down now and add another
object next to our touch-- our Image View.

00:25:36.009 --> 00:25:40.799
We're going to sort of attach this helper object on the
side, and we're going to call it a transform gesture.

00:25:40.799 --> 00:25:45.419
We're actually going to implement all of our
touch handling logic in this separate view.

00:25:45.420 --> 00:25:48.710
And now, we can also take the same
object that we're going to define

00:25:48.710 --> 00:25:54.970
and also attach one alongside our
ViewController Container View.

00:25:54.970 --> 00:25:59.930
But UIApplication and UIWindow isn't going to
know about these separate objects that we have.

00:25:59.930 --> 00:26:02.090
You can't hitTest something that's not a view.

00:26:02.089 --> 00:26:04.289
So it doesn't know to send any touches to these things.

00:26:04.289 --> 00:26:08.460
So we're actually going to subclass
UIWindow and overwrite sendEvent.

00:26:08.460 --> 00:26:15.430
So what will happen now is UIApplication sendEvent
will end up calling sendEvent on our UIWindow subclass.

00:26:15.430 --> 00:26:19.539
And from there, we can do some filtering ourselves,
and figure out what touches we're interested

00:26:19.539 --> 00:26:23.099
in for what location, and pass them to our helper objects.

00:26:23.099 --> 00:26:28.259
So our subclass of UIWindow sendEvent is going
to end up calling touchesBegan, Moved, Ended,

00:26:28.259 --> 00:26:33.359
and Cancelled on all of our transform gesture objects,
and then all those things will have a chance to look

00:26:33.359 --> 00:26:34.869
at whatever touches they're interested in.

00:26:34.869 --> 00:26:40.349
Then we're going to call super which will
pass the event back up to UIWindow sendEvent,

00:26:40.349 --> 00:26:45.399
and UIWindow sendEvent will just continue to do
the default behavior and call touchesBegan, Moved,

00:26:45.400 --> 00:26:49.130
and Ended on the appropriate view
that all the touches are bound to.

00:26:49.130 --> 00:26:52.400
So we can look at all the touches before
they even get delivered to the views,

00:26:52.400 --> 00:26:55.700
and decide if we want to do something that's going
to be more global than we would have been doing

00:26:55.700 --> 00:26:58.380
in the actual touch handling method of the view itself.

00:26:58.380 --> 00:27:05.770
Alright, so let's take a look at how we're actually
going to implement this and what it's going to look like.

00:27:05.769 --> 00:27:10.900
Alright, so I've got basically the same class
that we had here before, sorry, the same project.

00:27:10.900 --> 00:27:13.070
I've made a few small changes already.

00:27:13.069 --> 00:27:15.329
We still have the same app delegate, nothing new there.

00:27:15.329 --> 00:27:20.279
But now, I've already created this transform
gesture class, and I've added a few things.

00:27:20.279 --> 00:27:25.279
So I moved over the same two instance variables
that we had in our Touch Image View before.

00:27:25.279 --> 00:27:28.910
So we've still got the original transform
and the touchBegin Points instance variables

00:27:28.910 --> 00:27:30.720
but I've added a couple more things.

00:27:30.720 --> 00:27:34.009
So we've got another transform
which is the current transform.

00:27:34.009 --> 00:27:39.140
So if you remember from a little while ago, in
touchesMoved, we would set the current transform on the view

00:27:39.140 --> 00:27:42.790
to the concatenation of the original
transform and the incremental transform.

00:27:42.789 --> 00:27:46.920
And basically, the view is storing that
and changing its bounds based on it,

00:27:46.920 --> 00:27:50.009
I'm sorry, changing its frame based on it.

00:27:50.009 --> 00:27:54.579
But now, we're no longer a subclass of UIView,
this thing is just a subclass of UIResponder,

00:27:54.579 --> 00:27:57.849
and UIResponder is a subclass of
NSObject, so we're not a view.

00:27:57.849 --> 00:27:59.579
So we don't have a transform property.

00:27:59.579 --> 00:28:01.349
So we're going to have to have some place to store this.

00:28:01.349 --> 00:28:06.379
So we'll create this new transform instance
variable and define a transform property

00:28:06.380 --> 00:28:09.920
so that we can store the actual current transform.

00:28:09.920 --> 00:28:13.460
And then, we've got two new things,
we're going to define a target action.

00:28:13.460 --> 00:28:20.180
So our transform gesture object that we're about to
write is going to-- every time it updates its transform,

00:28:20.180 --> 00:28:25.930
call some action method on a target object
to tell it that this transform has changed.

00:28:25.930 --> 00:28:30.509
Additionally, we want to associate this transform
gesture with a particular view so that we can sort

00:28:30.509 --> 00:28:33.900
through the touches in the event and
figure out which ones we want to look at.

00:28:33.900 --> 00:28:34.910
So we've got that.

00:28:34.910 --> 00:28:38.330
We're defining just a couple of accessors
for those things, and additionally,

00:28:38.329 --> 00:28:42.000
a new initializer that will set
up our target action and view.

00:28:42.000 --> 00:28:50.910
In the actual implementation itself, I've basically just
copied over what we had from the Touch Image View before.

00:28:50.910 --> 00:28:55.580
The only other thing I've added is this set
of initializers in initWithTarget to set

00:28:55.579 --> 00:28:59.220
up these variables based on what we've passed in.

00:28:59.220 --> 00:29:02.150
But still, initializing the original
transform and touch begin points,

00:29:02.150 --> 00:29:05.090
the same way we were before, and dealloc still the same.

00:29:05.089 --> 00:29:09.990
I defined a few accessors but they just pretty much
returned the instance variables we just created

00:29:09.990 --> 00:29:14.680
and I still have the touch handling code,
totally unmodified from what we had in the view.

00:29:14.680 --> 00:29:19.500
So we do have to make just a few
changes, but actually nothing too big.

00:29:19.500 --> 00:29:26.039
The first one is our touch handling code was before asking
the event for all the touches that were in the view itself,

00:29:26.039 --> 00:29:29.680
but we're no longer a subclass of
UIView, so we're no longer a view.

00:29:29.680 --> 00:29:32.730
The event doesn't know that there
are any touches bound to us.

00:29:32.730 --> 00:29:37.920
So instead, we're going to look
for all of the observed touches.

00:29:37.920 --> 00:29:43.110
Now, I have implemented a method on this transform
gesture recognizer already and we're not going to look

00:29:43.109 --> 00:29:46.149
at it too much because your logic
for what touches you're interested in

00:29:46.150 --> 00:29:48.930
and any particular gesture will
probably be different than mine.

00:29:48.930 --> 00:29:54.360
All mine really does is look through all touches
in the event, and find any touches that are bound

00:29:54.359 --> 00:29:56.659
to this view or any of this view's subviews.

00:29:56.660 --> 00:30:05.269
So that is going to return all of those and we're
just going to replace that in the three other places

00:30:05.269 --> 00:30:08.150
where we were calling touches for views self.

00:30:08.150 --> 00:30:14.630
So we're always going to get all the
touches in our view or any of our subviews.

00:30:14.630 --> 00:30:17.320
>> Oops, this is not cooperating here.

00:30:17.319 --> 00:30:21.079
Alright, so, with that done, now
we've got one last change to make.

00:30:21.079 --> 00:30:26.259
As I mentioned, every time that our transform is updated,
we're going to call that action method on our target

00:30:26.259 --> 00:30:30.779
to let it know that we've updated our transform
so it can perform some action based on that.

00:30:30.779 --> 00:30:35.609
So, in our touchesMoved, we're just going to tell our
target to perform the selector action which we saved off

00:30:35.609 --> 00:30:39.159
at the beginning with our self being
the object so that it can get back

00:30:39.160 --> 00:30:42.360
and find out what the current transform
is that we're saving off here.

00:30:42.359 --> 00:30:45.449
We've defined a new transform property
that we're saving in our instance variable

00:30:45.450 --> 00:30:49.180
so we don't even have to change
that, we're still good to go.

00:30:49.180 --> 00:30:52.730
That's actually the only changes we
have to make to the touch handling code.

00:30:52.730 --> 00:30:57.700
Other than that, it can remain exactly the same as what
we had when it was in the touch image view subclass.

00:30:57.700 --> 00:31:01.890
So, let's move over to our UI window
subclass, our EventObserverWindow.

00:31:01.890 --> 00:31:06.990
I've defined a new instance variable
that is an array of transform gestures.

00:31:06.990 --> 00:31:11.450
So, we're going to allocate all of these transform
gestures and associate them with particular views,

00:31:11.450 --> 00:31:16.430
but we want to tell the window about them so that it knows
that it needs to send events to all of these objects.

00:31:16.430 --> 00:31:22.269
And to do that, we're also going to add two-- sorry, two
methods, the add transform gesture method to add something

00:31:22.269 --> 00:31:26.609
to this array and another one to get all the gestures back.

00:31:26.609 --> 00:31:31.069
So, our implementation of our subclass view
window right now, I'm loading it from a NIB

00:31:31.069 --> 00:31:33.889
so I've implemented a wait from
NIB to allocate our mutable array.

00:31:33.890 --> 00:31:36.750
You might also have to implement, excuse me,

00:31:36.750 --> 00:31:44.890
initWithFrame if you create your window
programmatically and in dealloc we'll just release that.

00:31:44.890 --> 00:31:49.250
So now, we're going to implement those
two methods, the add transform gesture.

00:31:49.250 --> 00:31:53.579
It's just going to add the transform gesture passed
in to the array that we have as our instance variable.

00:31:53.579 --> 00:31:58.329
And the accessor that returns all of the gestures, we're
just going to create an auto-released copy of that.

00:31:58.329 --> 00:32:00.889
So that-- since it's mutable, we
don't want to return the object itself

00:32:00.890 --> 00:32:03.780
in case it's mutated and someone
that gets it holds on to it.

00:32:03.779 --> 00:32:10.799
And now, we're going to implement our
sendEvent override here in our subclass.

00:32:10.799 --> 00:32:13.690
We'll call super but we're not going to do that yet.

00:32:13.690 --> 00:32:19.059
We're going to look at all of the touches
before we let our subviews take a look at them.

00:32:19.059 --> 00:32:24.409
So, the first thing we're going to do is iterate all of
our transform gestures that we have saved in that array.

00:32:24.410 --> 00:32:26.680
So we're going to look at all of those.

00:32:26.680 --> 00:32:30.190
And for each gesture, we're going to find out
what touches that gesture is interested in

00:32:30.190 --> 00:32:32.690
and we've already defined a method
that knows how to do that.

00:32:32.690 --> 00:32:35.779
So, we're going to ask the gesture
for the observed touches for event.

00:32:35.779 --> 00:32:40.769
That's the exact same method that we were calling
from within the touch methods on the gesture itself,

00:32:40.769 --> 00:32:46.579
and it'll return again, all the touches on that
gesture's view or on that gesture's views subviews.

00:32:46.579 --> 00:32:49.500
Alright, so, we've got that.

00:32:49.500 --> 00:32:55.069
Now, UIWindow sendEvent normally
handles all of the dispatch for us.

00:32:55.069 --> 00:32:58.750
It calls touches Began, Moved, and
Ended after sorting all of the touches.

00:32:58.750 --> 00:33:01.369
But since, we're going to be doing this
dispatch to our own objects that aren't

00:33:01.369 --> 00:33:03.459
in views, we have to do that sorting our self.

00:33:03.460 --> 00:33:09.970
So, we are going to create these four sets to store
off our Began, Moved, and Ended, and Cancelled touches

00:33:09.970 --> 00:33:12.870
and then we'll just start sorting all
the touches that we're interested in.

00:33:12.869 --> 00:33:16.750
So, we're going to iterate all over the touches
that the gesture told us it wanted to know about.

00:33:16.750 --> 00:33:20.849
We are going to switch on their phase and
start putting them into these buckets.

00:33:20.849 --> 00:33:25.469
So, for the began touches that are in phase began, if
we haven't yet found one, we're going to create a set

00:33:25.470 --> 00:33:29.269
to store them and we'll add that object
to it, and we'll do the same thing

00:33:29.269 --> 00:33:31.599
for any touches that are Moved, Ended, or Cancelled.

00:33:31.599 --> 00:33:36.959
Now I've got a default here because there is one phase we
didn't really talk about, and that's UITouchPhaseStationary.

00:33:36.960 --> 00:33:43.519
So any touch that we've already been telling you about
but that didn't move during the last event cycle,

00:33:43.519 --> 00:33:45.650
is going to get put into the stationary phase.

00:33:45.650 --> 00:33:51.240
So, it'll still be in the event, and the event will know
about it, but it won't be in any of these four states,

00:33:51.240 --> 00:33:57.130
and there's no corresponding touch stationary
UIResponder method to tell you about it with.

00:33:57.130 --> 00:33:59.590
So, we're just going to basically drop those on the floor.

00:33:59.589 --> 00:34:07.569
The view will be able to find out about them
or the gesture object by checking the event.

00:34:07.569 --> 00:34:13.469
And finally, now that we've got these all bucketed
and sorted, we can tell the gesture to run its code.

00:34:13.469 --> 00:34:18.339
So we'll call touchesBegan, Moved, Entered
or Cancelled on each of the gestures.

00:34:18.340 --> 00:34:20.809
So we're now, iterating over all
the gestures, sorting the touches,

00:34:20.809 --> 00:34:24.070
and calling the UIResponder methods
on those things ourselves.

00:34:24.070 --> 00:34:30.510
Since they're not actually in the responder chain, they're
just a subclass of UIResponder but have no next responder,

00:34:30.510 --> 00:34:37.300
once we deliver them to the gesture, they're pretty
much-- the gesture will either handle them or be done.

00:34:37.300 --> 00:34:44.130
So now that we've done that, we can call super sendEvent,
and that will let UIWindow do its default behavior

00:34:44.130 --> 00:34:49.380
of sorting the touches as it normally would and sent calling
touchesBegan, Moved, Ended, and Cancelled on all the views

00:34:49.380 --> 00:34:51.670
that actually these touches are bound to.

00:34:51.670 --> 00:34:57.000
Alight, so now let's go into our ViewController.

00:34:57.000 --> 00:35:00.489
This is the exact same ViewController
that we had in the last demo.

00:35:00.489 --> 00:35:02.109
It hasn't been changed at all yet.

00:35:02.110 --> 00:35:06.240
We're still creating our touch image view and
setting its center in our little helper method here.

00:35:06.239 --> 00:35:10.759
Now, the one additional thing we want to do now is start
to allocate one of these transform gestures for each

00:35:10.760 --> 00:35:13.100
of the touch image views that we're creating.

00:35:13.099 --> 00:35:18.449
So we're going to allocate a new transform gesture
with target self where self is the ViewController.

00:35:18.449 --> 00:35:23.719
This is our main-- we only have one ViewController
in these apps so this is the one ViewController.

00:35:23.719 --> 00:35:29.250
We're going to set an action method for this gesture that
will get called every time the gesture updates its transform

00:35:29.250 --> 00:35:34.019
and we'll call that the handle subview
transform which we'll implement in just a second.

00:35:34.019 --> 00:35:37.039
And we're going to say that the view that
we want this gesture to be associated

00:35:37.039 --> 00:35:40.289
with is the touch image view that we just allocated.

00:35:40.289 --> 00:35:45.929
So with that gesture created, we can then tell the Window--
and I did add one thing, I forgot about that, sorry.

00:35:45.929 --> 00:35:53.539
There's a new IB outlet in our ViewController here in the
header which basically just points back to this window.

00:35:53.539 --> 00:35:57.070
So we have a pointer in here so that we can
call add transfer in gesture on the window.

00:35:57.070 --> 00:36:00.800
And then we'll release the gesture because we don't
need a pointer to it in the ViewController anymore.

00:36:00.800 --> 00:36:07.030
The window knows about it and it's going to call things
on it and the gesture will call back on us when necessary.

00:36:07.030 --> 00:36:11.300
Alright, so now we've got these gestures
back on each of the subviews so each

00:36:11.300 --> 00:36:13.789
of the subviews on that will be able to transforms.

00:36:13.789 --> 00:36:19.029
But we also want a global one, one that's
going to be tracking touches on anything

00:36:19.030 --> 00:36:22.100
on the ViewController's view or any of the subviews.

00:36:22.099 --> 00:36:28.619
So one last thing we're going to do viewDidLoad
[phonetic] is allocate one more transform gesture,

00:36:28.619 --> 00:36:29.900
same target our ViewController.

00:36:29.900 --> 00:36:31.889
We're going to have a different action method for this one.

00:36:31.889 --> 00:36:37.819
It will be handle superview transform and its view
is going to be self.view, the ViewController's view.

00:36:37.820 --> 00:36:42.930
So this one is going to see any touches that are bound
to the ViewController's view or any of its subviews.

00:36:42.929 --> 00:36:45.419
And again, we're just going to tell the
window to add that transform gesture,

00:36:45.420 --> 00:36:50.510
I've auto-released it so it doesn't get leaked,
just kind of put that code on one line there.

00:36:50.510 --> 00:36:55.060
Alright, so now we've got the gestures allocated
and we've told them that they have action methods

00:36:55.059 --> 00:36:57.559
on our ViewController, but we haven't implemented those yet.

00:36:57.559 --> 00:36:59.340
So let's implement these two action methods.

00:36:59.340 --> 00:37:02.820
We've got the handle subview transform
and handle superview transform.

00:37:02.820 --> 00:37:05.720
So subview is the one that's going to get
called for touches in any of the subviews

00:37:05.719 --> 00:37:08.869
and superview for the ViewController's view.

00:37:08.869 --> 00:37:14.679
So the first thing we want to do is figure out whether
we should apply the transform as a result of finding

00:37:14.679 --> 00:37:20.409
out about it, because the subview is going to
get-- the subview transform is going to get--

00:37:20.409 --> 00:37:24.509
we're going to have this action method called even
if there are touches in two different subviews

00:37:24.510 --> 00:37:26.440
that we want to actually treat as a global thing.

00:37:26.440 --> 00:37:31.780
So I have a helper method I've written that I'm not
going to go into again here because as with the--

00:37:31.780 --> 00:37:36.050
some of the other things we've talked about, the
logic in your application may be a bit different.

00:37:36.050 --> 00:37:38.810
This is basically where you have
to do your own disambiguation.

00:37:38.809 --> 00:37:42.710
You have to decide whether this gesture
is the thing that actually you want to do

00:37:42.710 --> 00:37:47.500
or if there's some other gesture object somewhere
that's-- that that is the thing that you--

00:37:47.500 --> 00:37:50.099
that you'd rather have handle this particular touch.

00:37:50.099 --> 00:37:56.219
So the logic in this is basically, if
there are two touches in different views,

00:37:56.219 --> 00:37:58.980
then don't apply the transform for the subview.

00:37:58.980 --> 00:38:01.300
Otherwise, we will apply the transform.

00:38:01.300 --> 00:38:05.840
So we're going to get the gesture's view and
set its transform to the gesture's transform.

00:38:05.840 --> 00:38:10.800
If we've decided not to do that, then we want to
make sure to tell the gesture to re-baseline itself

00:38:10.800 --> 00:38:15.560
because we haven't applied the transform to the view but
the gesture still knows about the new incremental transform.

00:38:15.559 --> 00:38:19.880
So the touches that moved you want to re-baseline
for where it is now if we haven't applied it.

00:38:19.880 --> 00:38:22.250
And we're going to do basically the same thing

00:38:22.250 --> 00:38:26.349
in the handle superview transform except there's
a different disambiguation function that I wrote,

00:38:26.349 --> 00:38:29.259
that should apply superview transform for gesture.

00:38:29.260 --> 00:38:32.220
And this one basically just says, if
there are two touches and if they're

00:38:32.219 --> 00:38:34.939
in different views, then do apply the transform.

00:38:34.940 --> 00:38:36.559
Otherwise, don't.

00:38:36.559 --> 00:38:38.509
And if we've decided that we want to apply that,

00:38:38.510 --> 00:38:43.100
we're going to set the ViewController's
views transform to the gesture transform.

00:38:43.099 --> 00:38:48.900
And if not, again, we're going to re-baseline the
transform so we'll just tell it to reset itself.

00:38:48.900 --> 00:38:52.690
So let's build and run that and I do this every time.

00:38:52.690 --> 00:38:57.590
I told Jason before that there's going
to be one error and I forgot it again.

00:38:57.590 --> 00:39:01.809
[Laughs] So I forgot-- there was one other
thing that we didn't really talk about.

00:39:01.809 --> 00:39:05.699
I didn't write this in the first
demo but it's in the sample code.

00:39:05.699 --> 00:39:09.750
And I was going to talk about taking it out and putting
it in the other place and I forget to do it every time.

00:39:09.750 --> 00:39:11.650
So let's talk about it now.

00:39:11.650 --> 00:39:18.289
touchesEnded on our transform gesture has this leftover
code that we used to have in the transform view itself,

00:39:18.289 --> 00:39:21.539
the transform image view, and this
was trying to look for double taps.

00:39:21.539 --> 00:39:25.639
And if there were double-- if there was a double tap
in the view, we were going to have that view come

00:39:25.639 --> 00:39:27.900
to the foreground so that you could control Z-ordering.

00:39:27.900 --> 00:39:31.070
If something was behind another, you could
double tap in it, it would come forward.

00:39:31.070 --> 00:39:33.610
But this is no longer a view so it doesn't have a superview.

00:39:33.610 --> 00:39:36.400
So we need to actually delete that.

00:39:36.400 --> 00:39:40.019
And in fact, I've left that one thing in the
touch image view and it's the only reason

00:39:40.019 --> 00:39:42.039
that we still have a UIImageView subclass.

00:39:42.039 --> 00:39:45.889
All of the code in our touch image view is gone
and it's over in the transform gesture now.

00:39:45.889 --> 00:39:51.400
So touchesBegan, Moved, and Cancelled are empty but we still
do have this one bit in touchesEnded that's going to look

00:39:51.400 --> 00:39:58.599
to see if the tap count is greater than
2, and if it is, move itself to the front.

00:39:58.599 --> 00:40:00.759
Alright, so this time it's really going to work.

00:40:00.760 --> 00:40:04.160
Now, we can take individual views and move them around.

00:40:04.159 --> 00:40:09.369
We can put two touches in one view and still
move that around or rotate and scale it.

00:40:09.369 --> 00:40:13.679
But now, if we put two touches in different
views, we're going to end up moving all of them.

00:40:13.679 --> 00:40:14.509
[ Pause ]

00:40:14.510 --> 00:40:20.360
[ Applause]

00:40:20.360 --> 00:40:25.370
>> So it's a little bit more interesting over here
because we can put more than two fingers down.

00:40:25.369 --> 00:40:28.829
So you can still put two fingers in
an individual view and move it around.

00:40:28.829 --> 00:40:30.969
You can put another one down here and move that around.

00:40:30.969 --> 00:40:35.819
You can even scale two at the same time.

00:40:35.820 --> 00:40:38.010
And two in here still moves everything.

00:40:38.010 --> 00:40:45.860
[ Applause]

00:40:45.860 --> 00:40:47.039
>> Alright, thanks.

00:40:47.039 --> 00:40:51.610
With that I'd like to ask Jason to come up and
talk about some best practices and other things

00:40:51.610 --> 00:40:53.610
that he's going to discuss with motion events.

00:40:53.610 --> 00:40:59.250
[ Applause]

00:40:59.250 --> 00:41:00.800
>> Thanks a lot, Josh.

00:41:00.800 --> 00:41:02.880
OK, let's jump in to some best practices.

00:41:02.880 --> 00:41:08.099
So Josh talked a little bit about hitTest.

00:41:08.099 --> 00:41:11.789
And it's really important that the view that's returned

00:41:11.789 --> 00:41:17.509
by hitTest actually handle all of
these touch processing methods.

00:41:17.510 --> 00:41:23.230
Now, that doesn't mean that the class that's returned
has to provide implementations for these but somewhere

00:41:23.230 --> 00:41:28.269
in the view hierarchy or the class hierarchy for
that view, there needs to be implementations.

00:41:28.269 --> 00:41:31.659
So let's look at a couple of examples of this.

00:41:31.659 --> 00:41:40.239
Suppose you just subclass from UIView, you've
got a MyView that's a subclass of UIView,

00:41:40.239 --> 00:41:43.549
and UIView does not provide implementations
for any of these things.

00:41:43.550 --> 00:41:47.160
It inherits UIResponder's implementation of these methods.

00:41:47.159 --> 00:41:54.750
And UIResponder's implementation goes up the responder
chain looking for some view that can handle these touches.

00:41:54.750 --> 00:42:04.050
So what happens if in your view you-- let's
say you didn't implement touchesEnded,

00:42:04.050 --> 00:42:09.190
let's say, you put this in a table view.

00:42:09.190 --> 00:42:13.700
Well, we'll start calling touches methods
on that and then when the finger is lifted,

00:42:13.699 --> 00:42:17.569
we'll call touchesEnded on your
view but you don't implement it.

00:42:17.570 --> 00:42:20.280
It will go up to the responder's
implementation, that will go up the hierarchy

00:42:20.280 --> 00:42:24.820
and table view will see this touchesEnded
it never saw before.

00:42:24.820 --> 00:42:27.769
And you actually have no idea what
that's going to do with that.

00:42:27.769 --> 00:42:31.980
And if it were in the begin you didn't implement,
for example, that would actually cause highlighting

00:42:31.980 --> 00:42:36.900
in the table view and then you'd never send
the end and the highlight would get stuck.

00:42:36.900 --> 00:42:39.920
So the rule is if you're-- oops.

00:42:41.949 --> 00:42:51.109
The rule is if you're doing this, you need
to implement all those touch handling methods

00:42:51.110 --> 00:42:54.840
and you should never call super doing that
because that means you don't handle it,

00:42:54.840 --> 00:42:57.559
you need to find somebody else that does.

00:42:59.139 --> 00:43:01.250
What happens if you subclass some other UI tip thing.

00:43:01.250 --> 00:43:04.260
Let's say you subclass UIButton.

00:43:04.260 --> 00:43:08.420
Well, UIButton actually already provides
implementations for all of these methods.

00:43:08.420 --> 00:43:15.000
So you can safely just implement a subset of
those so you just want it to care about the end.

00:43:15.000 --> 00:43:20.909
You can just overwrite touchesEnded and do
whatever additional processing you need to do.

00:43:20.909 --> 00:43:24.509
But in this case, you absolutely have to call super.

00:43:24.510 --> 00:43:27.890
Otherwise, UIButton wouldn't see the full touch sequence.

00:43:27.889 --> 00:43:31.629
And you may leave the button in some inconsistent state.

00:43:31.630 --> 00:43:36.820
So let's talk a little bit about touch forwarding.

00:43:36.820 --> 00:43:44.930
What happens if you have some big view
and you've got several subviews of that,

00:43:44.929 --> 00:43:47.969
and its big view returns itself from hitTest.

00:43:47.969 --> 00:43:53.949
Josh talked a little bit about hitTest, and
normally, we find the deepest view and return

00:43:53.949 --> 00:43:56.839
that from hitTest, but you can overwrite this, of course.

00:43:56.840 --> 00:44:02.280
Your parent view there can overwrite hitTest and always
return itself and that means it gets a chance to process all

00:44:02.280 --> 00:44:04.970
of the touches for itself or any of its subviews.

00:44:04.969 --> 00:44:09.879
So let's say you've done this and you want to
conditionally forward some of those touches

00:44:09.880 --> 00:44:13.570
on to these various subviews based
on some state in your application.

00:44:13.570 --> 00:44:19.440
That's all fine to do but you need
to own all of these views.

00:44:19.440 --> 00:44:23.179
If you put some UIKit class in there, let's
say, one of these subviews was a button

00:44:23.179 --> 00:44:28.059
and you conditionally set some partial touch
string to that, it actually can't handle that.

00:44:28.059 --> 00:44:32.289
In fact, no UIKit classes can handle
touches that were not bound to them.

00:44:32.289 --> 00:44:39.269
So if the touches view is not the receiving view, you
cannot expect any of the UIKit classes to handle that.

00:44:42.110 --> 00:44:45.450
Alright, so let's look at some Gotchas.

00:44:45.449 --> 00:44:52.189
As Josh mentioned, this is actually a fairly common error.

00:44:52.190 --> 00:44:54.889
We've seen this in a lot of cases.

00:44:54.889 --> 00:45:00.029
People who handle touchesBegan, Moved, and Ended but
don't provide an implementation for touchesCancelled

00:45:00.030 --> 00:45:06.010
and what happens here is when the touch gets cancelled,
not only does your view not get a chance to process

00:45:06.010 --> 00:45:12.260
that potentially leaving your view in some inconsistent
state, but that touchesCancelled is going to go

00:45:12.260 --> 00:45:15.500
up the responder chain looking for
some object that can handle it.

00:45:15.500 --> 00:45:17.550
Some random view is going to get touchesCancelled

00:45:17.550 --> 00:45:24.510
for touch it's never seen before
potentially doing something bad in that view.

00:45:24.510 --> 00:45:31.810
So I sort of alluded to this in the previous slide UIKit
classes cannot participate in sort of touch forwarding.

00:45:31.809 --> 00:45:37.460
You can't catch a view or catch a touch sequence
in your own view and then just forward it

00:45:37.460 --> 00:45:42.010
on to any UIKit class and expect that class to handle that.

00:45:42.010 --> 00:45:46.540
[ Pause ]

00:45:46.539 --> 00:45:55.190
>> So, if you subclass a various UIKit class
let's say you call, you subclass UIButton

00:45:55.190 --> 00:45:58.130
and you conditionally call super for some of the methods.

00:45:58.130 --> 00:46:00.900
That means that UIButton won't see the full touch sequence.

00:46:00.900 --> 00:46:06.519
Say for example in touchesEnded sometimes you call
super sometime you don't depending on some state.

00:46:06.519 --> 00:46:11.489
That means UIButton itself might in some
circumstances never see that touchesEvent

00:46:11.489 --> 00:46:13.349
and you can leave that button in some inconsistent state.

00:46:13.349 --> 00:46:20.199
So, if you override any of these where the superclass
provides an implementation you absolutely need

00:46:20.199 --> 00:46:20.939
to call super.

00:46:20.940 --> 00:46:25.450
This is sort of related.

00:46:25.449 --> 00:46:34.549
Suppose that in your touchesMoved you decided, well I really
want to cancel this touch so you call super touchesEnded

00:46:34.550 --> 00:46:39.150
or touchesCancelled or something like that, even though
you're in a move and the phase of the touchesMoved.

00:46:39.150 --> 00:46:45.940
You can't expect that the parent class is going to do the
right thing of that-- with that because it's going to get,

00:46:45.940 --> 00:46:51.130
you know, touchesEnded or touchesMoved for a touch
that's in the wrong phase, so you really only need

00:46:51.130 --> 00:46:55.809
to call super with the same method that you received.

00:46:55.809 --> 00:47:00.019
[Pause] Alright, so let's move on to Motion Events.

00:47:00.019 --> 00:47:07.880
We've added this new in 3.0, the new motion
EventType and we've added a new shake Subtype.

00:47:07.880 --> 00:47:10.880
So what do you need to do to receive this?

00:47:10.880 --> 00:47:16.519
Well, Josh mentioned that you need to
be the FirstResponder to receive those--

00:47:16.519 --> 00:47:19.909
I'm sorry, let's set back and talk about
what you-- the methods you have to implement.

00:47:19.909 --> 00:47:23.279
There're three methods that you have to implement.

00:47:23.280 --> 00:47:28.769
They sort of mirror, the touch methods, there's
a motionBegan, motionEnded and motionCancelled.

00:47:28.769 --> 00:47:32.809
And just like the touch methods
you need to implement all of these

00:47:32.809 --> 00:47:36.960
and you should not call super from any of these methods.

00:47:36.960 --> 00:47:41.269
Calling super does the same thing it does in touch
process and it goes up to responder chain looking

00:47:41.269 --> 00:47:44.570
for some object that can process that motion event.

00:47:44.570 --> 00:47:48.289
And by default UIApplication actually
provides an implementation

00:47:48.289 --> 00:47:51.889
of the motionEnded method to do the undo action.

00:47:51.889 --> 00:48:01.239
So, if you called super from this you might do your
action and then also trigger the Undo dialogue to pop up.

00:48:01.239 --> 00:48:03.359
Let's also talk about when you get these.

00:48:03.360 --> 00:48:09.590
So for shake, when you first start shaking device, sort of
the first moment that the device starts moving we're going

00:48:09.590 --> 00:48:12.850
to send the motionBegan to the FirstResponder.

00:48:12.849 --> 00:48:22.519
If it's what we detect as a shake so sort of a short series
of rapid movements, we'll send motionEnded and you can,

00:48:22.519 --> 00:48:26.829
and we'll say that the subtype of that is shake
and you can do whatever process you need to do.

00:48:26.829 --> 00:48:34.219
But if it-- for some reason doesn't look like a shake and
we have some fairly complex logic to analyze that series

00:48:34.219 --> 00:48:37.429
of sort of accelerometer movements just,
you know, to determine what a shake is.

00:48:37.429 --> 00:48:42.139
Say for example, the thing goes on too
long you, you shake it for quite a while

00:48:42.139 --> 00:48:47.549
or for some other reason the pattern that's
emitted looks-- doesn't look like a shake.

00:48:47.550 --> 00:48:50.019
We're going to send motionCancelled there.

00:48:50.019 --> 00:48:55.030
So, for example the device is in your pocket, you run down a
flight of stairs, the first part of that might actually look

00:48:55.030 --> 00:48:58.630
like a shake but if it's gone on too long, so
we will go ahead and sent a cancel in that case.

00:48:58.630 --> 00:49:01.579
So if you get the ended that means, we
definitely detected that there's a shake

00:49:01.579 --> 00:49:04.599
and you can do whatever process you needed to do.

00:49:04.599 --> 00:49:08.119
OK, so now let's talk about FirstResponder.

00:49:08.119 --> 00:49:15.539
So, you need to become FirstResponder to receive these
things, and to do that you just send whatever responder

00:49:15.539 --> 00:49:20.039
that you want to process the motion
events the becomeFirstResponder message.

00:49:20.039 --> 00:49:26.239
And becomeFirstResponder calls another
method called canBecomeFirstResponder to see

00:49:26.239 --> 00:49:29.629
if that responder is allowed to
be FirstResponder at that time

00:49:29.630 --> 00:49:34.740
So, by default, normal responders return
NO from this method so if you need

00:49:34.739 --> 00:49:38.509
to receive motion events you need
to overwrite this and return YES.

00:49:38.510 --> 00:49:44.620
Of course, you can do this conditionally if under some
circumstances it's appropriate to become FirstReponder,

00:49:44.619 --> 00:49:50.069
in another circumstance it's not, but we'll
just show sort of a simple implementation here.

00:49:50.070 --> 00:49:57.539
So, let's modify the demo that Josh built so that we
recognize a shake gesture and when we recognize it,

00:49:57.539 --> 00:50:02.009
all the views will sort of animate
back into their original position.

00:50:02.010 --> 00:50:09.800
[ Pause ]

00:50:09.800 --> 00:50:15.360
>> OK, so there's a few places we could do this.

00:50:15.360 --> 00:50:20.610
As we said, you know, views and ViewControllers are all
responders, there are a few places we could put this logic.

00:50:20.610 --> 00:50:25.160
We could put it in the individual subviews that
we saw but that doesn't make a lot of sense

00:50:25.159 --> 00:50:28.789
because we really want this to
affect all of views on the screen.

00:50:28.789 --> 00:50:34.940
And we could put it in that containing view but in this
particular example that's just an instance of UIView.

00:50:34.940 --> 00:50:41.510
So to do that, we would have to subclass UIView and change
the NIB which is all fine, that would work just fine,

00:50:41.510 --> 00:50:46.860
but remember the ViewController is
also a responder in the responder chain

00:50:46.860 --> 00:50:49.579
and that's a fine place to handle these things.

00:50:49.579 --> 00:50:55.279
So, that parent view's ViewController
is this Multi Touch demo ViewController.

00:50:55.280 --> 00:50:58.420
So, we'll just have this view handle these touches.

00:50:58.420 --> 00:51:03.010
So, the first thing we need to do-- Oops, apparently--

00:51:03.010 --> 00:51:09.010
[ Pause ]

00:51:09.010 --> 00:51:11.010
>> -- pardon me just a second.

00:51:11.010 --> 00:51:25.020
[ Pause ]

00:51:25.019 --> 00:51:28.340
>> OK. I have just reopened it.

00:51:28.340 --> 00:51:32.620
OK, so the first thing we need to
do is implement View Did Appear.

00:51:32.619 --> 00:51:36.829
We know that the View is there and on screen now.

00:51:36.829 --> 00:51:40.360
And so now, we can make our ViewController
the FirstResponder.

00:51:40.360 --> 00:51:43.160
So we'll call becomeFirstResponder on that.

00:51:43.159 --> 00:51:46.579
And then we'll implement the canBecomeFirstResponder method

00:51:46.579 --> 00:51:50.750
so that we actually we'll be allowed
to become the FirstResponder.

00:51:50.750 --> 00:51:53.690
And now we just need to provide those motion methods.

00:51:53.690 --> 00:51:59.309
So, the first is motionBegan withEvent because
we actually are going to be processing these.

00:51:59.309 --> 00:52:02.119
We do need to overwrite that and
provide an empty implementation.

00:52:02.119 --> 00:52:09.799
If we didn't implement it, it would go up the
responder chain looking for some object to handle that.

00:52:09.800 --> 00:52:17.019
Next in motionEnded, this is when we actually
detect the shake, we're going to reset the transform

00:52:17.019 --> 00:52:21.409
of the outer view back to the identity transform and
then we're going to go through each of our subviews

00:52:21.409 --> 00:52:24.250
and reset their transforms back to the identity transform.

00:52:24.250 --> 00:52:33.300
And then we now need to tell the transform
gestures to re-baseline from that point.

00:52:33.300 --> 00:52:35.010
So, let's run that.

00:52:35.010 --> 00:52:39.680
[ Pause ]

00:52:39.679 --> 00:52:40.759
>> Oops. Did the same thing.

00:52:40.760 --> 00:52:43.010
We're not on 3.0.

00:52:43.010 --> 00:52:48.430
[ Pause ]

00:52:48.429 --> 00:52:54.000
>> Alright, we'll move a few things
around and then we'll send a shake event.

00:52:54.000 --> 00:52:55.489
Notice everything snaps back.

00:52:55.489 --> 00:52:57.439
We didn't put any of the animation code.

00:52:57.440 --> 00:53:02.670
Fortunately, we're built on top of Core Animation,
so that's very trivial to add animation code.

00:53:02.670 --> 00:53:08.360
We'll just-- oops, I'm sorry, I didn't
implement motionCancelled, look at that

00:53:08.360 --> 00:53:12.740
Very important to implement motionCancelled [laughter].

00:53:12.739 --> 00:53:21.159
OK, so we will wrap this block of code that
adjusts these transforms in an animation block.

00:53:21.159 --> 00:53:23.489
So first, just say began animations.

00:53:23.489 --> 00:53:27.839
We can set a duration here, I played with it a
little bit, half a second seems like a nice duration.

00:53:27.840 --> 00:53:32.789
And then after we're done with
that, commit those animations.

00:53:32.789 --> 00:53:38.009
And that's actually all we need
to do to animate these views back.

00:53:38.010 --> 00:53:42.950
[ Pause ]

00:53:42.949 --> 00:53:49.009
>> So we move some things around again, new
shake gesture, they animate nicely back.

00:53:49.010 --> 00:53:54.870
[ Applause ]

00:53:54.869 --> 00:53:59.599
>> If you want any more information, Matt
Drance is the Application Frameworks Evangelist,

00:53:59.599 --> 00:54:02.989
and there's some great documentation that
describes all of this stuff up on the site.
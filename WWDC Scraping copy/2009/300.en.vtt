WEBVTT

00:00:12.779 --> 00:00:21.009
>> Ladies and Gentlemen, please welcome John Stauffer,
Senior Director Graphics and Media Engineering.

00:00:21.010 --> 00:00:28.600
[ Applause ]

00:00:28.600 --> 00:00:38.969
>> Welcome, and thank you for coming to
the Graphics and Media State of the Union.

00:00:38.969 --> 00:00:47.200
So you've been hearing a lot today about
Mac OS X Snow Leopard and iPhone OS 3.0.

00:00:47.200 --> 00:00:51.109
Two great platforms for you to develop your applications on.

00:00:55.649 --> 00:00:58.089
But a platform is more than just software.

00:00:58.090 --> 00:01:04.540
A platform is about the hardware and the software,
and all the unique features that the hardware

00:01:04.540 --> 00:01:08.960
and the software bring together for
you to use to build an innovative

00:01:08.959 --> 00:01:16.699
and a great application that we see you making today.

00:01:16.700 --> 00:01:27.210
So when we were building iPhone OS, we were able to take
all the years of experience that we've been building

00:01:27.209 --> 00:01:33.379
into Mac OS X and bring a lot of those technologies
and bring a lot of that experience over to the iPhone.

00:01:33.379 --> 00:01:44.599
And what enabled us to do is to leverage all that shared
code, all that software, all that years of experience

00:01:44.599 --> 00:01:49.609
that we've been building in making
the iPhone a great platform.

00:01:49.609 --> 00:01:53.260
And when we brought these technologies to the
iPhone, we took them there, we optimized them,

00:01:53.260 --> 00:01:56.480
and then we tuned them to work great with the iPhone.

00:01:56.480 --> 00:02:03.150
And in doing so, we were able to learn quite a
bit about how to make our technologies better.

00:02:03.150 --> 00:02:08.599
And when we learned on the iPhone all the things we learned
about building that platform, we took that technology

00:02:08.599 --> 00:02:11.169
and we started bringing it back to Mac OS X.

00:02:11.169 --> 00:02:15.769
So these two platforms share a lot of
technologies, a lot of learning has gone on,

00:02:15.770 --> 00:02:18.280
on both sides., which is making both platforms better.

00:02:18.280 --> 00:02:27.069
So today we're going to be talking about
the graphics and media technologies

00:02:27.069 --> 00:02:38.509
and how we have built these technologies
for the iPhone OS and Mac OS X.

00:02:38.509 --> 00:02:45.349
So whether it be that you're using OpenGL on Mac OS X
to access all of the graphics capabilities of the GPU

00:02:45.349 --> 00:02:52.569
or OpenAL to leverage all of the audio
processing capabilities on an iPhone,

00:02:52.569 --> 00:02:56.909
the graphics and media technologies, our goal when
we're building the graphics and media technologies is

00:02:56.909 --> 00:03:01.430
to provide you with technologies
that's been optimized for the platform

00:03:01.430 --> 00:03:08.159
and to access all the unique hardware
capabilities available on that platform.

00:03:08.159 --> 00:03:11.449
When we built these technologies
we're trying to plan for the future.

00:03:11.449 --> 00:03:17.719
So when you're looking at our technology
this week, when you're hearing about them,

00:03:17.719 --> 00:03:23.030
we are always asking ourselves what can we do to make
those better for you, to give you a solid platform

00:03:23.030 --> 00:03:25.509
that you can rely on and that you can keep building on.

00:03:25.509 --> 00:03:34.989
It's this process that allows us to build a stable base
that allows you to build the innovations that we're seeing

00:03:34.990 --> 00:03:38.750
in the kinds of applications that you're making.

00:03:38.750 --> 00:03:45.030
It's also what's enabled us from the first day when we
launched the iPhone SDK to provide you with a stable set

00:03:45.030 --> 00:03:50.349
of technologies that we've seen you use
over the last year and bring you all

00:03:50.349 --> 00:03:54.810
of the great applications onto the iPhone App Store.

00:03:54.810 --> 00:03:56.849
We've seen some incredible applications.

00:03:56.849 --> 00:04:00.549
An example of this is Brushes.

00:04:00.550 --> 00:04:05.030
Brushes is an iPhone application
where you use your finger to paint.

00:04:05.030 --> 00:04:10.990
It's based on Quartz, Quartz was a Mac OS
X technology that we brought to the iPhone.

00:04:10.990 --> 00:04:14.790
We optimized it on the iPhone.

00:04:14.789 --> 00:04:27.110
And combined with the touch screen of an iPod touch or
iPhone, this innovative application was able to be made

00:04:27.110 --> 00:04:34.020
And with that, just last week Jorge Columbo
took that application and on his iPhone,

00:04:34.019 --> 00:04:38.060
he painted the cover of last week's New Yorker

00:04:38.060 --> 00:04:45.660
We find that pretty incredible, that the picture,
the cover of the New Yorker was painted on an iPhone.

00:04:45.660 --> 00:04:52.470
So this is an example of using the software features
of the platform and the hardware features together

00:04:52.470 --> 00:05:01.320
to build an innovative application -- we think this is
a great example and we really like seeing these kinds

00:05:01.319 --> 00:05:04.420
of combinations of technology brought together.

00:05:04.420 --> 00:05:13.600
So there's 20 categories of applications
on the iPhone Store.

00:05:13.600 --> 00:05:19.000
And games, by far, represents the
largest category of applications.

00:05:19.000 --> 00:05:21.399
Games is interesting for us.

00:05:21.399 --> 00:05:29.219
Being a graphics and media person, because they stress
the graphics and media technologies to the limits.

00:05:29.220 --> 00:05:35.230
And that helps us learn how to make
those technologies better for the future.

00:05:35.230 --> 00:05:48.140
It helps us learn how to optimize those technologies so that
we can provide you with better, more optimal technologies.

00:05:48.139 --> 00:05:57.310
So today we're going to talk about graphics
and media on the iPhone and Mac OS X.

00:05:57.310 --> 00:06:00.540
And talk about some of the shared
technologies on those platforms.

00:06:00.540 --> 00:06:08.260
But also point out some of the unique
technologies on the iPhone and Mac OS X platforms.

00:06:08.259 --> 00:06:15.439
And then we're going to talk about the iPhone,
and the unique capabilities of iPhone OS 3.0

00:06:15.439 --> 00:06:20.029
and try to give you some insight into the technology,
the capabilities that we're bringing to that platform.

00:06:20.029 --> 00:06:22.729
And we're also going to pay special attention to games,

00:06:22.730 --> 00:06:27.600
because we think games are a big
part of what make the iPhone.

00:06:27.600 --> 00:06:29.890
So with that, I'm going to invite up Geoff Stahl.

00:06:29.889 --> 00:06:35.009
Geoff is going to start the next section of
the presentation, to talk about graphics.

00:06:35.009 --> 00:06:41.310
[ Applause ]

00:06:41.310 --> 00:06:42.670
>> Thanks John.

00:06:42.670 --> 00:06:50.550
I'm going to talk about three key technologies that allow
you to access the power of the graphics processing unit.

00:06:50.550 --> 00:06:54.210
And we'll start at the foundation with OpenGL.

00:06:54.209 --> 00:07:01.930
OpenGL is a hardware abstraction layer built on top
of the GPU that has evolved over a number of years

00:07:01.930 --> 00:07:11.340
from a configurable fixed function graphics pipeline for
2D and 3D graphics to= today's fully programmable pipeline

00:07:11.339 --> 00:07:17.729
that unlocks the power of the most
modern GPUs providing dynamic lighting,

00:07:17.730 --> 00:07:23.970
real-time depth of field immersive environments like
this example of the latest game from id software.

00:07:23.970 --> 00:07:29.720
All possible because of the power of OpenGL
as a foundational technology for graphics.

00:07:29.720 --> 00:07:35.200
In Mac OS X we recognize that, and we built
a number of technologies on top of that.

00:07:35.199 --> 00:07:41.819
So we have Core Image or Core Animation, Core
Video, even our Windows server in Quartz,

00:07:41.819 --> 00:07:47.469
accelerated by the graphic processing unit using OpenGL.

00:07:47.470 --> 00:07:53.750
These allow you to program either to OpenGL as a foundation
technology or pick one of these higher level abstractions

00:07:53.750 --> 00:07:56.829
to optimize your interface to our software.

00:07:56.829 --> 00:08:02.279
And of course all these technologies from
the kernel graphics drivers all the way

00:08:02.279 --> 00:08:07.349
through these high level APIs are
native 64-bit for Snow Leopard.

00:08:07.350 --> 00:08:14.410
It made sense when we looked at iPhone and iPhone
OS and we needed a foundational graphics technology,

00:08:14.410 --> 00:08:18.300
it made absolute sense that we look at OpenGL ES.

00:08:18.300 --> 00:08:26.540
OpenGL for embedded systems, it's based on GL, providing
again, a configurable fixed function graphics pipeline

00:08:26.540 --> 00:08:30.680
for 2D and 3D graphics that allows
you to do some amazing things.

00:08:30.680 --> 00:08:32.730
And you guys picked these up too.

00:08:32.730 --> 00:08:33.740
We've seen some amazing things.

00:08:33.740 --> 00:08:36.009
And these are just a few of them.

00:08:36.009 --> 00:08:41.590
We've seen the projected shadows in
Motion X Poker, or the real-time --

00:08:41.590 --> 00:08:48.509
the realistic textures and real-time lighting in Zen Bound,
taking a very simple concept and making it immersive.

00:08:48.509 --> 00:08:55.480
Or the almost infinitely scalable
world that Google Earth provides.

00:08:55.480 --> 00:09:00.740
These are all powered by OpenGL ES 1.1 on the iPhone.

00:09:00.740 --> 00:09:08.269
But there's one thing we heard from the time we
released SDK a year ago that you guys all wanted.

00:09:08.269 --> 00:09:13.539
You wanted access to fully programmable hardware
and a fully programmable graphics pipeline.

00:09:13.539 --> 00:09:17.969
Well today we're providing that with OpenGL ES 2.0.

00:09:19.009 --> 00:09:23.059
[ Applause ]

00:09:23.059 --> 00:09:28.059
>> So what is OpenGL ES 2.0, and why
is it different than OpenGL ES 1.1?

00:09:28.059 --> 00:09:32.709
Well, it is based on desktop OpenGL 2.0 for mobile devices.

00:09:32.710 --> 00:09:38.019
It provides that access to the programmable
hardware through GLSL shading language,

00:09:38.019 --> 00:09:40.949
allowing you to write vertex shaders and fragment shaders.

00:09:40.950 --> 00:09:46.120
Those are very small pieces of code that run
directly on the GPU, that give you really full access

00:09:46.120 --> 00:09:48.580
to the power of the graphics processing unit.

00:09:48.580 --> 00:09:52.770
And of course it allows very efficient
GPU access for your mobile device.

00:09:52.769 --> 00:09:55.909
Here's an example.

00:09:55.909 --> 00:10:03.139
Instead of writing these multiple lines of OpenGL
API calls and a multipass algorithm to do some kind

00:10:03.139 --> 00:10:09.529
of color correction, what we can do is collapse
that down into a single line of a fragment shader.

00:10:09.529 --> 00:10:11.120
This is really powerful, again.

00:10:11.120 --> 00:10:13.919
Giving you more direct access to that GPU.

00:10:13.919 --> 00:10:19.129
So instead of worrying about state and how to configure the
graphics pipeline, you're worried about exactly what kind

00:10:19.129 --> 00:10:23.009
of code and commands you want to execute on the GPU.

00:10:23.009 --> 00:10:29.399
And as an example of this I want to bring Alex Eddie up
on stage, and look at a demo we worked with our partners

00:10:29.399 --> 00:10:34.840
at Imagination Technologies on, which shows
the power of the fragment shaders on the GPU.

00:10:34.840 --> 00:10:42.810
So what this demo is, is a sky box, basically.

00:10:42.809 --> 00:10:46.799
So it's a kind of an immersive environment
you're in, and we have these windows.

00:10:46.799 --> 00:10:51.849
And each window contains a fragment
shader or a program that's running

00:10:51.850 --> 00:10:55.259
on the GPU that's directly operating
on the fragments in the scene.

00:10:55.259 --> 00:11:00.370
And what you can do is, you can see how some of these
fragments with this distortion, you can write the pieces

00:11:00.370 --> 00:11:03.080
of code to directly manipulate the pixels on the screen.

00:11:03.080 --> 00:11:05.889
Remember, all of this is on the GPU.

00:11:05.889 --> 00:11:09.769
No CPU work involved in actually
manipulating the pixels on the screen.

00:11:09.769 --> 00:11:13.049
You can do things like, here, this is a great edge filter.

00:11:13.049 --> 00:11:18.959
So you know, we've seen some color effects,
but this is actually using the color

00:11:18.960 --> 00:11:21.370
of the pixels to check the edges in this scene.

00:11:21.370 --> 00:11:25.139
You can imagine what you can do with this kind of power.

00:11:25.139 --> 00:11:27.259
Here's more artistic looking shader.

00:11:27.259 --> 00:11:33.319
So it's not limited to just, you know, adjusting saturation,
or making a black and white image or doing edge detection,

00:11:33.320 --> 00:11:35.810
you can do many kinds of artistic effects.

00:11:35.809 --> 00:11:42.359
And let's take a look at some of the things
that we can do with fragment shaders on the GPU.

00:11:42.360 --> 00:11:47.370
Again, interacting with a 3D scene, it's
not just limited to a 2D background.

00:11:47.370 --> 00:11:53.379
Fully interacting with that geometry, with
the shader here, the glass distortion.

00:11:53.379 --> 00:12:00.830
So this is running on the iPhone 3G
S, fully on the GPU fragment shading.

00:12:00.830 --> 00:12:03.009
Thank you, Alex.

00:12:03.009 --> 00:12:08.840
[ Applause ]

00:12:08.840 --> 00:12:19.269
>> So iPhone 3G S, the most powerful and fastest
iPhone we ever built, we provide OpenGL ES 2.0

00:12:19.269 --> 00:12:24.100
to allow you full access to the
programmable hardware in that device.

00:12:24.100 --> 00:12:28.050
We also provide, of course, OpenGL ES 1.1.

00:12:28.049 --> 00:12:33.029
This allows you as app designers to determine
how you want to target your next application,

00:12:33.029 --> 00:12:39.079
and combine this with the power of
the smart App Store, which allows --

00:12:39.080 --> 00:12:47.100
combined with the device capabilities in your application
bundle ensures that your users get the correct application,

00:12:47.100 --> 00:12:50.409
correct version of your application
for whatever device they're on.

00:12:50.409 --> 00:12:53.639
Really powerful technology and integration there.

00:12:53.639 --> 00:12:57.830
So that's OpenGL, and OpenGL ES.

00:12:57.830 --> 00:13:07.120
Providing the graphics foundation technologies, unlocking
the power of the GPU for both iPhone OS and Mac OS X.

00:13:07.120 --> 00:13:12.120
But it's not always that you want to be at that
low level, dealing with points, lines, vertices,

00:13:12.120 --> 00:13:16.509
sometimes you want higher level abstraction.

00:13:16.509 --> 00:13:20.159
You want to look at that user experience.

00:13:20.159 --> 00:13:21.689
We have Core Animation.

00:13:21.690 --> 00:13:23.670
One of the things I mentioned at the very beginning.

00:13:23.669 --> 00:13:30.929
This is a higher level abstraction on Mac
OS X and iPhone OS, and what it does is --

00:13:30.929 --> 00:13:34.609
it is the automatic animation of 2D planes in space.

00:13:34.610 --> 00:13:36.029
It's accelerated by the GPU.

00:13:36.029 --> 00:13:42.049
You can move to this higher level abstraction, optimize your
software interface without giving up that power of the GPU.

00:13:42.049 --> 00:13:50.689
In fact, Core Animation is so powerful that it
is the basis for the user experience on iPhone.

00:13:50.690 --> 00:13:54.810
From cover flow to the iTunes video player.

00:13:54.809 --> 00:14:00.349
All of this user experience is driven through
Core Animation utilizing the GPU on the iPhone.

00:14:00.350 --> 00:14:03.889
And of course, you recognize this.

00:14:03.889 --> 00:14:06.899
Whether it is Aki Mahjong with its tiled,

00:14:06.899 --> 00:14:11.949
scalable user experience making it very
easy to navigate a complicated game.

00:14:11.950 --> 00:14:16.950
Or RoamBi, which allows you to create custom
business charts with your critical data,

00:14:16.950 --> 00:14:19.560
and take it with you, keeping it in your pocket.

00:14:19.559 --> 00:14:23.399
Both of these user interfaces, outstanding
examples of using Core Animation

00:14:23.399 --> 00:14:29.069
as a higher level abstraction and
creating great applications.

00:14:29.070 --> 00:14:32.800
So it was only natural, created on the iPhone,
that we would look at this for Mac OS X.

00:14:32.799 --> 00:14:40.809
And we brought it to Mac OS X, we've talked in the past
about Time Machine, and the use of Core Animation there,

00:14:40.809 --> 00:14:45.819
but top sites, we showed it this morning, talked
about it as a great technology in Safari 4.

00:14:45.820 --> 00:14:47.860
Again, built on Core Animation.

00:14:47.860 --> 00:14:56.009
The designers, the engineers, can now concentrate on that
user experience rather than having to worry about whether --

00:14:56.009 --> 00:15:02.899
what mipmap level they have, or how big the textures
are relative to what the hardware capabilities are.

00:15:02.899 --> 00:15:05.850
Core Animation extracts that for you.

00:15:05.850 --> 00:15:08.500
This morning we showed Dock Expose.

00:15:08.500 --> 00:15:16.370
So it takes your cluttered desktop and allows you easily
to highlight the application that you're interested in,

00:15:16.370 --> 00:15:21.070
show those windows, and pick your window of interest
that you're actually looking for that content.

00:15:21.070 --> 00:15:23.370
Again, powered by Core Animation.

00:15:23.370 --> 00:15:28.720
So instead of rewriting an entire animation system,
they rewrote the way they use Core Animation,

00:15:28.720 --> 00:15:32.080
rely on those optimized fundamentals there.

00:15:32.080 --> 00:15:37.600
Concentrating on a great user experience,
allowing the designers and graphic artists

00:15:37.600 --> 00:15:41.470
to not worry about those low-level details.

00:15:41.470 --> 00:15:44.029
And we haven't sat still with Core Animation.

00:15:44.029 --> 00:15:52.829
Core Animation, for Snow Leopard and for iPhone OS 3.0
has a number of new features, including particle systems

00:15:52.830 --> 00:15:57.400
and Bezier paths, improved efficiency to the GPU.

00:15:57.399 --> 00:16:02.490
And we brought those APIs even closer
together, making them nearly identical.

00:16:02.490 --> 00:16:04.960
So the technology you learn in one
place you can use in another place.

00:16:04.960 --> 00:16:08.490
The synergy there is fantastic.

00:16:08.490 --> 00:16:16.019
Core Animation, created for the iPhone, brought to
Mac OS X, allow us to do the heavy lifting for you

00:16:16.019 --> 00:16:18.740
so you can concentrate on user experience.

00:16:18.740 --> 00:16:27.870
So I want to take a little change of direction here.

00:16:27.870 --> 00:16:36.539
We introduced OpenCL, open compute language last year.

00:16:36.539 --> 00:16:46.629
And the last two areas of technology that I talked
about are unlocking graphics technologies for the GPU.

00:16:46.629 --> 00:16:50.230
OpenCL is about compute technology.

00:16:50.230 --> 00:16:53.940
It's about taking the GPU beyond graphics.

00:16:53.940 --> 00:16:55.210
That's key.

00:16:55.210 --> 00:17:02.540
The idea here is that the GPU in that -- extreme
power is not just for graphics processing.

00:17:02.539 --> 00:17:04.569
So what is OpenCL.

00:17:04.569 --> 00:17:12.980
OpenCL is a very thin runtime layer that allows you to build
kernels written in OpenCL C, a C-like language based on C99

00:17:12.980 --> 00:17:17.930
with some vector intrinsics, that's layered on
top of the industrial strength runtime compiler

00:17:17.930 --> 00:17:22.410
that provides automatic optimization
for whatever platform you're on.

00:17:22.410 --> 00:17:25.360
We also have IEEE 754 base math.

00:17:25.359 --> 00:17:28.479
And this is critical.

00:17:28.480 --> 00:17:34.960
With some previous GPGPU implementations what we saw
was you move from device to device or vendor to vendor,

00:17:34.960 --> 00:17:38.569
you may have differences in your calculations.

00:17:38.569 --> 00:17:44.139
OpenCL is one of the primary design tenets wants accurate,
repeatable math, allowing you to really concentrate

00:17:44.140 --> 00:17:47.770
on your algorithm, rather than what device you're on.

00:17:47.769 --> 00:17:49.619
So OpenCL.

00:17:49.619 --> 00:17:53.549
Obviously, it runs on the GPU, it's designed for that.

00:17:53.549 --> 00:17:57.019
It also runs on the CPU.

00:17:57.019 --> 00:18:04.549
Putting that together, most importantly, you
can run your algorithms on the GPU and the CPU,

00:18:04.549 --> 00:18:07.490
unlocking the full power of that desktop system.

00:18:07.490 --> 00:18:10.880
So what are we talking about.

00:18:10.880 --> 00:18:12.860
Last year we did the Galaxies demo.

00:18:12.859 --> 00:18:17.819
The Galaxies demo is very interesting, because it's
both a demonstration and it's a real world application.

00:18:17.819 --> 00:18:22.289
We have processing that's done on the GPU or on the CPU.

00:18:22.289 --> 00:18:29.769
We combine those results for display, updating the data set
and continuing that through every frame of the simulation.

00:18:29.769 --> 00:18:33.849
So it's a real world task, and we used this
to show some real world performance last year.

00:18:33.849 --> 00:18:35.319
Let's see where we were.

00:18:35.319 --> 00:18:43.339
A core CPU, about 70 gigaflops, 70 billion
floating-point operations per second.

00:18:43.339 --> 00:18:48.329
Bringing that to the CPU last year, about 200 gigaflops.

00:18:48.329 --> 00:18:51.339
200 floating point operations per second.

00:18:51.339 --> 00:18:59.769
And like I said, even more importantly, combining that
together the full system almost a quarter of a terraflop.

00:18:59.769 --> 00:19:02.129
A quarter of a trillion floating-point
operations per second.

00:19:02.130 --> 00:19:03.860
So that's pretty darn good.

00:19:03.859 --> 00:19:05.769
We got great power out of the system.

00:19:05.769 --> 00:19:09.940
What I want to do is take a demo and I want
to show you where we've come in the year --

00:19:09.940 --> 00:19:13.330
in the last year, working with
software and working with the hardware.

00:19:17.609 --> 00:19:19.459
So this is the Galaxies demo.

00:19:19.460 --> 00:19:20.789
Same algorithms as last year.

00:19:20.789 --> 00:19:24.430
And right now we're running on a multicore CPU.

00:19:24.430 --> 00:19:26.570
We're running a CPU on this Mac Pro.

00:19:26.569 --> 00:19:28.960
And now we're seeing about 100 gigaflops.

00:19:28.960 --> 00:19:33.490
So it's improved since last year,
unlocking for potential of the CPU.

00:19:33.490 --> 00:19:37.490
Let's move this to the GPU and see where we end up.

00:19:37.490 --> 00:19:41.049
So now with the GPU, we surpassed a quarter of a terraflop.

00:19:41.049 --> 00:19:47.839
We're at 360 gigaflops, billions --
floating-point operations per second.

00:19:47.839 --> 00:19:54.289
But what's more interesting, what's more important
is to be able to take that GPU, a couple GPUs,

00:19:54.289 --> 00:20:03.240
combine it with a CPU, and see what we get.

00:20:03.240 --> 00:20:05.980
CPU, two GPUs, over a terraflop.

00:20:05.980 --> 00:20:12.589
Over a trillion floating-point operations per
second, real world application measured performance.

00:20:12.589 --> 00:20:13.849
This is truly amazing.

00:20:13.849 --> 00:20:19.009
A terraflop of processing power underneath your desk.

00:20:19.009 --> 00:20:29.420
[ Applause ]

00:20:29.420 --> 00:20:33.930
>> So let's look at where we -- let's put
those new results on our little graph here.

00:20:33.930 --> 00:20:37.810
8 Core GPU, CPU, and full system.

00:20:37.809 --> 00:20:46.809
Now we're seeing -- CPU got better, the GPUs even
moving farther up, almost toward 400 giga flops,

00:20:46.809 --> 00:20:54.000
and that full system combining CPU and GPU, same
algorithm hosted on the CPU and the GPU using OpenCL,

00:20:54.000 --> 00:20:57.319
a terraflop of processing power under your desktop.

00:20:57.319 --> 00:21:01.079
So what do you use that power for?

00:21:01.079 --> 00:21:06.299
Well, I want to invite of David Gohara from
Washington University School of Medicine to talk

00:21:06.299 --> 00:21:11.669
about his experience using OpenCL and -- David.

00:21:11.670 --> 00:21:12.920
>> Thank you.

00:21:15.009 --> 00:21:17.589
[ Applause ]

00:21:17.589 --> 00:21:19.349
>> It's a pleasure to be here this afternoon.

00:21:19.349 --> 00:21:26.719
I'd like to start off with an example of a
calculation we've been able to accelerate using OpenCL.

00:21:26.720 --> 00:21:31.160
What you're looking at is a typical biological
molecule that we might be interested in studying.

00:21:31.160 --> 00:21:35.360
For this demo, the specifics of the calculation
aren't important, but what we typically need

00:21:35.359 --> 00:21:39.299
to evaluate are the electrostatic and
chemical properties of these molecules.

00:21:39.299 --> 00:21:41.710
And how those properties are important
for molecular interactions,

00:21:41.710 --> 00:21:43.910
and that's what we're visualizing on screen right here.

00:21:43.910 --> 00:21:47.910
It's important also to consider
that when we do these calculations,

00:21:47.910 --> 00:21:51.380
we typically have to perform them tens
of hundreds of thousands of times.

00:21:51.380 --> 00:21:52.930
So speed is important.

00:21:52.930 --> 00:21:58.410
However, we can parallelize this calculation,
and when we do this on 16 threads we get

00:21:58.410 --> 00:22:01.779
about an 11 X speedup, which is really quite good.

00:22:01.779 --> 00:22:05.619
But it also begs the question can we get
more out of this by running this on the GPU.

00:22:05.619 --> 00:22:06.839
And it turns out we can.

00:22:06.839 --> 00:22:08.529
So can we see that?

00:22:08.529 --> 00:22:10.500
And maybe one more time.

00:22:12.450 --> 00:22:13.509
Pretty awesome, huh?

00:22:13.509 --> 00:22:14.210
So --

00:22:14.210 --> 00:22:18.700
[ Applause ]

00:22:18.700 --> 00:22:21.730
>> So what you can see is that by
moving the calculation over to the GPU,

00:22:21.730 --> 00:22:25.870
certainly over 16 threads we're getting a dramatic
performance increase, but when you compare this

00:22:25.869 --> 00:22:34.389
to the performance of the code on the single CPU we're
talking about 175 X speedup, which is phenomenal.

00:22:34.390 --> 00:22:36.880
There's two things that I'd like to
point out though about this calculation.

00:22:36.880 --> 00:22:43.340
The first is that this code that we're running on the GPU
is identical to the code that we're running on the CPU.

00:22:43.339 --> 00:22:45.559
It's quite literally a copy and paste.

00:22:45.559 --> 00:22:49.079
The second thing, which is more
important, is that the code that --

00:22:49.079 --> 00:22:54.250
the results that I'm showing you here on the GPU
are numerically identical to what we get on the CPU.

00:22:54.250 --> 00:22:59.700
Which for us is far more important, because while
speed is nice, accuracy is the ultimate goal.

00:22:59.700 --> 00:23:04.259
And with openly CL we seem to be able to
actually achieve both of those kinds of things.

00:23:04.259 --> 00:23:09.859
However, when we do this calculation it's
typically a part of a larger set of computations.

00:23:09.859 --> 00:23:14.199
An example of that is shown here, where
we might be looking at the interactions

00:23:14.200 --> 00:23:16.610
between hundreds or thousands of molecules.

00:23:16.609 --> 00:23:19.289
And how those interactions are important, for example,

00:23:19.289 --> 00:23:23.409
in the development of drug delivery
systems, which is what we're seeing here.

00:23:23.410 --> 00:23:28.519
So in this animation what you're looking at are
the results of a series of molecular dynamics

00:23:28.519 --> 00:23:35.079
and electrostatics calculations of a
drug loading into a drug delivery system.

00:23:35.079 --> 00:23:39.710
This represents about 150 nanoseconds
of atomic motion -- so it's fast.

00:23:39.710 --> 00:23:47.090
But in order for us to calculate, it required about
one month of wall clock time on a 16 CPU cluster.

00:23:47.089 --> 00:23:52.199
Now it's important for me to point out that behind
all the pretty picture that you're seeing here,

00:23:52.200 --> 00:23:56.130
there's real science, there's real
data going on, this is the real deal.

00:23:56.130 --> 00:23:59.760
And so that's important to keep in mind.

00:23:59.759 --> 00:24:05.299
The last thing I'd like to point out with regards
to OpenCL is that OpenCL really makes programming

00:24:05.299 --> 00:24:10.009
for the GPU far more accessible to people like myself.

00:24:10.009 --> 00:24:14.809
Prior to about January of this year I
never programmed anything to run on a GPU.

00:24:14.809 --> 00:24:21.559
And within about a month and a half had significant portions
of our electrostatics code running on the GPU efficiently.

00:24:21.559 --> 00:24:26.519
And I think this speaks very highly of the
underlying technology and its implementation.

00:24:26.519 --> 00:24:30.279
So with that, I'd like to turn the presentation back
over to Geoff, and I thank you all for your time.

00:24:30.279 --> 00:24:32.259
[ Applause ]

00:24:32.259 --> 00:24:33.799
>> Thank you David.

00:24:37.539 --> 00:24:40.559
Absolutely amazing work.

00:24:40.559 --> 00:24:43.539
But the two examples we've shown are
kind of the hard science examples.

00:24:43.539 --> 00:24:49.740
We have a gravitational calculation where we're
having multiple bodies, tens of thousands of bodies,

00:24:49.740 --> 00:24:52.480
all each interacting with each other
in an end square kind of problem,

00:24:52.480 --> 00:24:57.660
then we have our electrostatics of the medical research.

00:24:57.660 --> 00:25:00.650
Is that all that we can use OpenCL for?

00:25:00.650 --> 00:25:02.120
You have to have a hard science problem?

00:25:02.119 --> 00:25:04.229
Absolutely not.

00:25:04.230 --> 00:25:06.890
OpenCL can be used for any application.

00:25:06.890 --> 00:25:15.780
Identity your data intensive, your computationally
intensive parts of your application, host them in OpenCL C,

00:25:15.779 --> 00:25:19.819
write a kernel that executes on the
GPU, the CPU, or the entire system,

00:25:19.819 --> 00:25:27.059
and you can really unlock the power of
your platform, your desktop machine.

00:25:27.059 --> 00:25:31.950
So that's OpenCL.

00:25:31.950 --> 00:25:36.490
Last year at WWDC we introduced OpenCL.

00:25:36.490 --> 00:25:41.359
And we stated our intentions of bring
this to the Khronos Standards Body.

00:25:41.359 --> 00:25:44.909
Well, I have good news.

00:25:44.910 --> 00:25:48.910
December 2008, working with our industry partners,

00:25:48.910 --> 00:25:58.060
OpenCL was ratified as the open industry
standard for parallel computing on the GPU.

00:25:58.059 --> 00:26:05.089
And even better, in your developer preview you have
the first conformant OpenCL implementation available

00:26:05.089 --> 00:26:06.470
to you today.

00:26:06.470 --> 00:26:10.339
So we can't wait to see what you guys can do with it.

00:26:12.009 --> 00:26:15.920
[ Applause ]

00:26:15.920 --> 00:26:18.509
>> So I've talked to you about a number of technologies.

00:26:18.509 --> 00:26:20.950
OpenGL and OpenGL ES.

00:26:20.950 --> 00:26:22.890
iPhone OS, Mac OS X.

00:26:22.890 --> 00:26:30.040
Foundational graphics technologies allowing you to
unlock the power of the graphics processing unit.

00:26:30.039 --> 00:26:31.509
Core Animation.

00:26:31.509 --> 00:26:35.930
iPhone OS, Mac OS X, lowing you
that higher level abstraction.

00:26:35.930 --> 00:26:39.200
Concentrate on the user experience,
let us do the heavy lifting.

00:26:39.200 --> 00:26:42.000
And finally, OpenCL.

00:26:42.000 --> 00:26:50.910
New technology allowing you to unlock the computing power
of your entire system to take the GPU beyond graphics.

00:26:50.910 --> 00:26:55.009
Thanks very much, and I'll turn the presentation
over to Tim Bienz to talk about media.

00:26:55.009 --> 00:27:02.299
[ Applause ]

00:27:02.299 --> 00:27:04.599
>> Thanks, Geoff.

00:27:04.599 --> 00:27:08.389
QuickTime is a very successful technology.

00:27:08.390 --> 00:27:11.850
It pioneered video and media on the desktop.

00:27:11.849 --> 00:27:16.639
Throughout its history it has repeatedly
pushed forward the state of the art.

00:27:16.640 --> 00:27:22.050
You use it in many of your applications, and
it is central to Apple's consumer applications,

00:27:22.049 --> 00:27:25.879
professional applications, and to iTunes.

00:27:25.880 --> 00:27:32.360
One of the really amazing things about QuickTime is
that its architecture has lasted almost 20 years now.

00:27:32.359 --> 00:27:36.329
And if you think about the dramatic changes in
platforms that have occurred during that time,

00:27:36.329 --> 00:27:41.500
hardware and software changes, that's almost unbelievable.

00:27:41.500 --> 00:27:46.970
We're undergoing another dramatic revolution in platforms
as you've seen, with the emergence of mobile platforms,

00:27:46.970 --> 00:27:53.410
the iPhone, and as Phil mentioned this morning,
the increased predominance of notebook computers.

00:27:53.410 --> 00:27:59.170
And with that transition that's going on we see
that the needs for a media system are changing.

00:27:59.170 --> 00:28:05.570
In particular, to be successful in the future
we believe a media system needs to be portable.

00:28:05.569 --> 00:28:14.250
It needs to be able to be implemented on small handheld
machines, as well as large multicore multi-CPU machines.

00:28:14.250 --> 00:28:16.019
It needs to be modular.

00:28:16.019 --> 00:28:20.990
It needs to be able to implement a small, simple
playback solution, perhaps for a hand held device,

00:28:20.990 --> 00:28:28.059
as well as a full blown professional
level video support for large machines.

00:28:28.059 --> 00:28:30.750
And finally, it needs to be efficient.

00:28:30.750 --> 00:28:34.259
That means the media system needs to
take advantage of whatever hardware is

00:28:34.259 --> 00:28:36.869
on the machine it is running on at that time.

00:28:36.869 --> 00:28:41.269
Fortunately, we have experience
implementing just such a media technology,

00:28:41.269 --> 00:28:45.960
that's the video playback stack we've implemented
for the iPhone over the past couple years.

00:28:45.960 --> 00:28:53.299
And so what we are doing in Snow Leopard is taking all
that we learned from the iPhone and bringing that back

00:28:53.299 --> 00:28:57.109
to the desktop as the beginnings of QuickTime X.

00:28:57.109 --> 00:29:02.709
QuickTime X is a modern framework for media on Mac OS X.

00:29:02.710 --> 00:29:07.650
In Snow Leopard, QuickTime will
support playback of modern media.

00:29:07.650 --> 00:29:16.530
In addition, QuickTime will support capture, export to Apple
devices, that means iPhone, iPod, an Apple TV, and finally,

00:29:16.529 --> 00:29:20.940
QuickTime X in Snow Leopard will support
an entirely new streaming technology.

00:29:20.940 --> 00:29:24.789
Of course if we're building a world class
media system for the future we need to build it

00:29:24.789 --> 00:29:27.659
on the best technologies we have on the platform.

00:29:27.660 --> 00:29:35.040
And so we're building QuickTime X on top of
Core Audio for professional low latency audio.

00:29:35.039 --> 00:29:39.190
On top of Core Video, for hardware accelerated video.

00:29:39.190 --> 00:29:47.000
And on top of Core Animation, which you heard Geoff
talk about, to provide GPU accelerated compositing.

00:29:47.000 --> 00:29:50.390
Everything we're doing in QuickTime X, 64-bit native.

00:29:50.390 --> 00:29:54.840
So you get the performance advantages
and the large address space from that.

00:29:54.839 --> 00:29:59.269
We are also using ColorSync throughout
QuickTime 10 to provide consistent

00:29:59.269 --> 00:30:04.629
and correct color for playback, capture, and export.

00:30:04.630 --> 00:30:12.250
You access QuickTime X using the same QT Kit Cocoa APIs
that you've been using to access QuickTime for years now.

00:30:12.250 --> 00:30:19.059
In terms of formats, we're focusing QuickTime
X on modern technologies, modern formats,

00:30:19.059 --> 00:30:23.329
such as H.264 for video, and AAC for audio.

00:30:23.329 --> 00:30:26.359
Let's take a minute and look at each of these.

00:30:26.359 --> 00:30:29.719
For Snow Leopard we're implementing HE-AAC audio.

00:30:29.720 --> 00:30:33.259
This provides very high quality audio at low data rates.

00:30:33.259 --> 00:30:36.140
Data rates below 64 kilobytes per sec, for example.

00:30:36.140 --> 00:30:39.560
And this is really important for
applications such as internet radio that need

00:30:39.559 --> 00:30:42.829
to provide the best quality audio at very low data rates.

00:30:42.829 --> 00:30:48.549
It does this through a technology called spectral band
replication, which encodes the low and middle frequencies

00:30:48.549 --> 00:30:52.149
of the data, but does not directly
encode the high frequencies.

00:30:52.150 --> 00:30:56.990
Instead, the high frequencies are reconstructed
at playback time from the low and mid frequencies,

00:30:56.990 --> 00:31:01.120
plus a small amount of control
data that's embedded in the file.

00:31:01.119 --> 00:31:07.839
HE-AAC support is available both on
iPhone OS 3.0 and on Snow Leopard.

00:31:07.839 --> 00:31:10.909
Let's turn our attention to video and H.264.

00:31:10.910 --> 00:31:17.019
What's new in Snow Leopard is that your application can
access the hardware accelerated H.264 decoders present

00:31:17.019 --> 00:31:20.109
on most of the machines that we're currently shipping.

00:31:20.109 --> 00:31:27.549
What this means for applications is that they can support
high quality HD playback of rich, immersive HD content,

00:31:27.549 --> 00:31:30.519
regardless of the CPU they're running on.

00:31:30.519 --> 00:31:35.779
In addition, it allows your code and your
applications to be more efficient because the work

00:31:35.779 --> 00:31:42.369
of decoding the video is offloading from the CPU
to the GPU, leaving the CPU free to do other work.

00:31:42.369 --> 00:31:47.469
In Snow Leopard, we're doing not only framework level work,

00:31:47.470 --> 00:31:54.029
but we're also happy to introduce a completely
new QuickTime Player, streamline QuickTime Player.

00:31:54.029 --> 00:31:59.319
This new QuickTime Player leverages all of the
technologies we're introducing for QuickTime X.

00:31:59.319 --> 00:32:04.019
Playback, capture, export, and streaming.

00:32:04.019 --> 00:32:09.629
Now the new QuickTime Player you've seen a little bit this
morning provides a very streamlined playback experience.

00:32:09.630 --> 00:32:15.670
In addition, it allows you to record
audio, video, and to record your screen.

00:32:15.670 --> 00:32:20.890
It provides simple trim level editing to allow
you to trim in and out points on your clips.

00:32:20.890 --> 00:32:27.480
It allows you to convert your content for
Apple devices, iPhone, iPod, Apple TV.

00:32:27.480 --> 00:32:31.170
It allows you to convert it for formats
and bitrates suitable for the web.

00:32:31.170 --> 00:32:37.700
And finally it allows you to convert your data
to formats for HD, such as 780P and 1080P.

00:32:37.700 --> 00:32:46.250
Finally, you can directly share your content from the new
QuickTime player to iTunes MobileMe Gallery and YouTube.

00:32:46.250 --> 00:32:48.799
Let's take a quick look at the QuickTime Player.

00:32:48.799 --> 00:32:55.700
So I'm going to go through much of the same
things that you saw this morning with Craig,

00:32:55.700 --> 00:32:59.160
and I'm going to take a little more time to do this.

00:32:59.160 --> 00:33:02.660
And so we'll open up a piece of
content and start it playing.

00:33:02.660 --> 00:33:07.660
Now this is playing using the hardware
H.264 decoder provided by QuickTime X.

00:33:07.660 --> 00:33:09.350
You've seen the HUD already this morning.

00:33:09.349 --> 00:33:12.959
And the HUD is implemented using Core Animation.

00:33:12.960 --> 00:33:18.759
Once we're done sort of setting up playback
here, when we move the mouse out of the window,

00:33:18.759 --> 00:33:22.490
all the controls in the HUD fade away,
leaving your content front and center

00:33:22.490 --> 00:33:25.690
so you can concentrate purely on the content.

00:33:25.690 --> 00:33:31.200
In addition to supporting a windowed
mode, we support full screen.

00:33:31.200 --> 00:33:38.900
And in full screen, we support both original aspect ratio
as well as you can zoom in and display in fullscreen

00:33:38.900 --> 00:33:42.040
if you prefer, using the entire area of your display.

00:33:42.039 --> 00:33:45.690
I happened to prefer original aspect
ratio, so let's go back to that.

00:33:45.690 --> 00:33:48.980
Let's just stop for a couple of seconds and watch this.

00:33:51.009 --> 00:33:56.839
[ Music ]

00:33:56.839 --> 00:33:59.379
>> That really looks fantastic.

00:33:59.380 --> 00:34:03.250
So you saw a little about the trim,
let's talk about that again.

00:34:03.250 --> 00:34:09.280
And I should also mention the scaling in full-screen is done
using the GPU, so the CPU is off loaded from doing that.

00:34:09.280 --> 00:34:11.840
Let's go ahead and get ready to trim this content.

00:34:11.840 --> 00:34:13.990
We'll select trim here.

00:34:13.989 --> 00:34:16.239
And I know there's a clip in here I want.

00:34:16.239 --> 00:34:21.199
Now I can either select the clip or get in the area
visually, as you can see here with the thumbnails.

00:34:21.199 --> 00:34:22.399
I'll show you a little trick here.

00:34:22.400 --> 00:34:26.720
If you hold down the option key, instead of seeing
the thumbnails you actually see the audio waveforms.

00:34:26.719 --> 00:34:30.289
And depending on what your content is,
that can sometimes be useful as a cue.

00:34:30.289 --> 00:34:32.110
Here the video frames happen to work better.

00:34:32.110 --> 00:34:34.260
So I'll go back to use those.

00:34:36.050 --> 00:34:40.970
So I know there's a segment right about
here someplace -- yeah, right about there.

00:34:40.969 --> 00:34:46.409
What I want to do is I want to put over on my Apple
TV in the living room and show it to my friends.

00:34:46.409 --> 00:34:50.299
So for demo purposes I'll pick a very short segment here.

00:34:50.300 --> 00:34:53.769
That looks about right.

00:34:53.769 --> 00:34:56.469
And we'll click the trim button to trim it.

00:34:56.469 --> 00:34:57.739
And now we'll just preview that.

00:34:57.739 --> 00:34:58.979
It's only a few seconds long.

00:34:58.980 --> 00:35:03.889
In fact, I selected a little too
short, it's only 2 seconds long.

00:35:03.889 --> 00:35:04.519
There you go.

00:35:04.519 --> 00:35:09.230
And now what I can do is I can take
this and select share to iTunes.

00:35:09.230 --> 00:35:15.929
What will happen when I do this is the new QuickTime
Player will use QuickTime Xs new export capabilities

00:35:15.929 --> 00:35:21.469
to convert this into a format for iTunes and
directly share it into my iTunes library.

00:35:21.469 --> 00:35:24.309
Let's go ahead and do that.

00:35:24.309 --> 00:35:27.250
It asks what kind of device capabilities
or compatibility I'd like.

00:35:27.250 --> 00:35:30.679
Well, I want to show this on my Apple
TV, so I'm going to click on that one.

00:35:30.679 --> 00:35:31.739
Now let me go ahead and share.

00:35:31.739 --> 00:35:35.439
Now it's only a couple of seconds,
it should convert really quickly.

00:35:35.440 --> 00:35:39.019
And it's going -- now it's moving into my iTunes library.

00:35:39.019 --> 00:35:41.300
And there it actually is.

00:35:41.300 --> 00:35:44.550
Along with telling me I need a new version of iTunes.

00:35:45.780 --> 00:35:49.080
We'll just play this back and make
sure it's the clip we picked.

00:35:51.690 --> 00:35:54.130
Sure enough, that's exactly the one I wanted.

00:35:54.130 --> 00:35:55.769
Couldn't be easier.

00:35:55.769 --> 00:35:59.009
That's the new QuickTime player.

00:35:59.010 --> 00:36:05.660
[ Applause ]

00:36:05.659 --> 00:36:08.670
>> So all of the things that you've
seen, all of the features we've shown you

00:36:08.670 --> 00:36:13.110
in QuickTime Player are available as part of Snow Leopard.

00:36:13.110 --> 00:36:16.890
Let's change topics and talk a
little bit about HTTP live streaming.

00:36:16.889 --> 00:36:21.650
We believe it is very important to support
playback of not only preauthored or stored content,

00:36:21.650 --> 00:36:23.789
but to support the playback of live content.

00:36:23.789 --> 00:36:25.380
But we want to do it right.

00:36:25.380 --> 00:36:31.240
And that places a bunch of constraints on the
solution that helps drive the technology we've chosen.

00:36:31.239 --> 00:36:36.229
In particular, we want a solution
that's built on web standards.

00:36:36.230 --> 00:36:40.530
Because we want you to be able to post your
content very easily to existing servers,

00:36:40.530 --> 00:36:44.630
or deploy it easily on commercial
content delivery networks such as Akamai.

00:36:44.630 --> 00:36:45.500
So we selected HTTP.

00:36:45.500 --> 00:36:52.650
We want to format this firewall-friendly so that your
end users don't have to worry about trying to configure

00:36:52.650 --> 00:36:56.630
to get the streaming video through their
firewalls, NATs, whatever they may have.

00:36:56.630 --> 00:37:01.099
Again, HTTP works really well for this.

00:37:01.099 --> 00:37:05.569
We definitely want a technology that's
suitable for use by commercial broadcasters.

00:37:05.570 --> 00:37:09.490
We'd like a whole range of clients to be able to
use this and developers to be able to use this,

00:37:09.489 --> 00:37:13.099
and certainly commercial broadcast is
one of the places that's important.

00:37:13.099 --> 00:37:15.059
And so this does two things for us.

00:37:15.059 --> 00:37:19.449
This means we want a format that's directly
compatible with commercial hardware and encoders

00:37:19.449 --> 00:37:22.389
such as those from Envivio or Inlet Technologies.

00:37:22.389 --> 00:37:26.629
And secondly, we want to support
encryption, and we support AES encryption.

00:37:26.630 --> 00:37:32.140
So the content providers for whom protection
is an issue can protect their content.

00:37:32.139 --> 00:37:37.659
Finally, we want a technology that
dynamically adapts to network conditions.

00:37:37.659 --> 00:37:40.639
This is particularly important
on mobile devices such as iPhone

00:37:40.639 --> 00:37:44.769
where the network conditions can change
dramatically during the course of playback.

00:37:44.769 --> 00:37:51.280
And so we provided a solution that allows you to post
multiple versions of your content at different bitrates,

00:37:51.280 --> 00:37:58.269
and dynamically during playback on the client side,
the client selects the best one at any given time.

00:37:58.269 --> 00:38:02.539
This allows your customers to always see
best quality video at any given time,

00:38:02.539 --> 00:38:04.610
regardless what the network conditions are.

00:38:04.610 --> 00:38:12.039
So of course we're focusing on modern
codex, H.264 for video, and AC for audio.

00:38:12.039 --> 00:38:16.509
And they're wrapped up in a broadcast-friendly
stream format.

00:38:16.510 --> 00:38:20.660
We've taken everything that we're doing here
and we're publishing it as an IETF draft.

00:38:20.659 --> 00:38:25.549
This allows you to either use our implementation
or for some reason you need or want to do your own,

00:38:25.550 --> 00:38:28.600
you have all the information you need to do that.

00:38:28.599 --> 00:38:31.920
Let's see how a solution would
work for a commercial broadcaster.

00:38:31.920 --> 00:38:37.579
First as I said, need a commercial hardware encoder,
such as those from Envivio, or Inlet Technologies.

00:38:37.579 --> 00:38:41.889
The output from that can be fed directly
into a small segmenter application

00:38:41.889 --> 00:38:44.170
that we're shipping as part of Snow Leopard.

00:38:44.170 --> 00:38:49.750
The purpose of this application is to take the stream coming
out of the encoder and chop it up into short, perhaps 10,

00:38:49.750 --> 00:38:55.659
20 second fragments, segments, store those
as files that can then be directly up loaded

00:38:55.659 --> 00:38:59.989
to your HTTP server, or to a content delivery network.

00:38:59.989 --> 00:39:01.979
That's all you have to do.

00:39:01.980 --> 00:39:07.780
From there, soft run the client, either on a
Snow Leopard machine or an iPhone OS 3.0 machine.

00:39:07.780 --> 00:39:11.730
Can directly access it and view
it on either of those platforms.

00:39:11.730 --> 00:39:17.329
So that really sounds great in principle, and it looks
really simple, but how well does it work in practice.

00:39:17.329 --> 00:39:21.269
Well to talk about that I have two
developers that I will bring up on stage.

00:39:21.269 --> 00:39:26.090
First I'd like to bring up KC Estenson
from CNN to talk about their experience

00:39:26.090 --> 00:39:28.510
in using this technology for live news broadcast.

00:39:28.510 --> 00:39:28.880
KC?

00:39:28.880 --> 00:39:29.180
>> [ Applause ]

00:39:29.179 --> 00:39:32.049
>> Thanks, Ken.

00:39:34.400 --> 00:39:38.710
CNN reaches over 2 billion people world wide every day.

00:39:38.710 --> 00:39:45.070
And I am pleased to announce today
CNN is coming to the iPhone.

00:39:45.070 --> 00:39:53.090
We are really excited about the app as you all know
the iPhone is an incredible, incredible device.

00:39:53.090 --> 00:40:03.030
And what we set out to do as sort of a core design principle
behind our app is to bring order to the chaos of hundreds

00:40:03.030 --> 00:40:07.390
if not thousands of events that happen
around the world every single day.

00:40:07.389 --> 00:40:14.179
As Tim mentioned, we are a commercial
broadcaster, and we serve on CNN.com alone

00:40:14.179 --> 00:40:18.659
over 100 million videos every single month.

00:40:18.659 --> 00:40:22.139
So we need something that can scale.

00:40:22.139 --> 00:40:31.489
So with our application we are going to bring live,
streaming video to the iPhone, which our head

00:40:31.489 --> 00:40:42.769
of product development has up here -- what's great
about this is how easy Apple made it for us to do.

00:40:42.769 --> 00:40:45.739
We spent, you know, I think [Inaudible]
will show you the app in a second.

00:40:45.739 --> 00:40:50.889
But we spent months working on the user
interface of the application itself.

00:40:50.889 --> 00:40:54.460
But really when we went in to build
the app it took us two weeks

00:40:54.460 --> 00:40:58.519
to actually build the application, as you can see here.

00:40:58.519 --> 00:41:05.909
And when we actually went to set up the HTTP streaming
protocol it literally stood up in a matter of hours.

00:41:05.909 --> 00:41:15.299
So you can see the clean design in being able to organize
all these videos and photos and news of the day is something

00:41:15.300 --> 00:41:18.440
that we just feel we're really, really excited about.

00:41:18.440 --> 00:41:26.220
Also with the HTTP streaming protocol and the 3.0 SDK, we're
able to push the live video directly from inside of the app.

00:41:26.219 --> 00:41:28.739
Just something we're so thrilled about.

00:41:28.739 --> 00:41:34.789
So with this application in the next
couple of months, coming to an iPhone

00:41:34.789 --> 00:41:40.519
or an iPod touch near you will be the global
power of CNN in the palm of your hand.

00:41:40.519 --> 00:41:42.009
Thank you very much.

00:41:42.010 --> 00:41:48.480
[ Applause ]

00:41:48.480 --> 00:41:49.260
>> Thanks Casey.

00:41:49.260 --> 00:41:54.050
It's fantastic to see what you've been able to
do so quickly and hear how easy it was to set up.

00:41:54.050 --> 00:41:58.530
Very much look forward to being able
to download the app from the App Store.

00:41:58.530 --> 00:42:05.160
Next, I'd like to invite up Tracy Pesin from MLB Advanced
Media to talk about what MLB is doing with this technology

00:42:05.159 --> 00:42:07.659
in the area of sports broadcasting, particularly baseball.

00:42:07.659 --> 00:42:08.759
Tracy?

00:42:08.760 --> 00:42:19.150
>> Hi, I'm here with developer Jeremy Shaner to demonstrate
new functionality we're incorporating into MLB.com

00:42:19.150 --> 00:42:23.099
At Bat 2009, leveraging new features in iPhone OS 3.0.

00:42:23.099 --> 00:42:28.920
The iPhone platform had already enabled
us to create an unmatched experience

00:42:28.920 --> 00:42:32.329
of following a live baseball game on a mobile device.

00:42:32.329 --> 00:42:36.079
We can quickly check the state of any game in progress.

00:42:36.079 --> 00:42:39.029
We can listen to a live audio broadcast.

00:42:39.030 --> 00:42:46.610
We can follow real-time pitch by pitch
data, and we can watch video highlights.

00:42:46.610 --> 00:42:53.099
Now ever since mlb.com started streaming full length
live baseball games over the Internet in 2002.

00:42:53.099 --> 00:42:58.670
We really wanted to bring the same experience it a
mobile device, and iPhone OS is helping us do that.

00:42:58.670 --> 00:43:05.920
As we select a feed, the first thing the application does
is use Core Location and the new MapKit API to determine

00:43:05.920 --> 00:43:11.700
and display our location, and let us know if
we're in an area where we can access the content.

00:43:11.699 --> 00:43:13.319
And here you see a live game in progress.

00:43:13.320 --> 00:43:24.559
And as you know, the player uses adaptive bitrate streaming
which means MLB could just provide several versions

00:43:24.559 --> 00:43:28.960
of the content at varying bitrates, and the player
automatically choses the best one for our connection.

00:43:28.960 --> 00:43:36.559
And the data is served over HTTP, which really simplified
set up at our CDN and across the whole delivery platform.

00:43:36.559 --> 00:43:41.400
And the player also makes it easy
to encrypt the data if needed.

00:43:41.400 --> 00:43:45.389
So we are very excited to be bringing
this new experience to baseball fans

00:43:45.389 --> 00:43:49.190
and happy that iPhone OS 3.0 is helping us to do so.

00:43:49.190 --> 00:43:50.559
Thank you.

00:43:53.010 --> 00:43:57.420
[ Applause ]

00:43:57.420 --> 00:43:58.240
>> Thanks, Tracy.

00:43:58.239 --> 00:44:01.959
It's great to see that addition to your app,
I look forward to being able to download it,

00:44:01.960 --> 00:44:08.329
and very happy to hear that the encryption and the
dynamic bitrate switching is working well for you.

00:44:08.329 --> 00:44:12.559
So with the HTTP live streaming, we
think we have a great technology here.

00:44:12.559 --> 00:44:18.110
I hope that the couple of demos you've see today give you
an idea of the kinds of things that are possible with this.

00:44:18.110 --> 00:44:22.650
We're really excited to see what you're able to do with
this over the next year and think it will bring a wide range

00:44:22.650 --> 00:44:26.500
of content both to Snow Leopard and to the iPhone.

00:44:26.500 --> 00:44:29.710
And finally, QuickTime X.

00:44:29.710 --> 00:44:34.900
We are thrilled to be able to ship the first
version of QuickTime X in Snow Leopard.

00:44:34.900 --> 00:44:42.420
QuickTime X provides a solid modern framework for media
on which both we and you can innovate in Snow Leopard

00:44:42.420 --> 00:44:45.139
and beyond, and I very much look forward to that.

00:44:45.139 --> 00:44:52.839
Thank you, and with that I'd like to turn it
over to Meriko Borogove to talk about the iPhone.

00:44:52.840 --> 00:44:55.170
[ Applause ]

00:44:55.170 --> 00:44:56.869
>> Thank you Tim.

00:44:56.869 --> 00:45:02.509
I am so excited to be here talking to
you about iPod touch and iPhone today.

00:45:02.510 --> 00:45:08.140
You've been hearing all day about the run away success
that this operating system and platform has been for us,

00:45:08.139 --> 00:45:14.670
and I think this is in large part due to you,
your applications, and the application store.

00:45:14.670 --> 00:45:17.280
We've been throwing around crazy numbers.

00:45:17.280 --> 00:45:25.660
40 million iPod touch and iPhone users in the
market, a million applications downloaded to date.

00:45:25.659 --> 00:45:30.000
50,000 applications in the application store.

00:45:30.000 --> 00:45:31.329
These numbers are crazy.

00:45:31.329 --> 00:45:34.210
They're kind of hard for me to
comprehend on a day to day basis.

00:45:34.210 --> 00:45:37.769
So I like to think about what kinds
of applications you're putting out.

00:45:37.769 --> 00:45:40.519
John touched on this earlier when
he told you that games is far

00:45:40.519 --> 00:45:45.289
and away the most populace category in the App Store today.

00:45:45.289 --> 00:45:52.599
But when you start looking at the other categories,
education, music, photography, sports, social networking,

00:45:52.599 --> 00:45:58.880
you guys are taking a ton of applications that rely
on graphics and media technology at their heart.

00:45:58.880 --> 00:46:04.519
When you think about that, most of the applications
are looking at our technologies in graphics and media.

00:46:04.519 --> 00:46:06.239
This is really exciting to me.

00:46:06.239 --> 00:46:09.449
Geoff talked to you about our graphics
stack in iPhone OS 3.0.

00:46:09.449 --> 00:46:12.079
And on the iPhone 3G S.

00:46:12.079 --> 00:46:16.809
Tim Bienz did a great job telling you
about our HTTP live streaming technologies.

00:46:16.809 --> 00:46:20.000
I'd like to talk a little bit about the camera in imaging.

00:46:20.000 --> 00:46:23.639
I'd like to talk about our audio
stack on iPhone and iPod touch.

00:46:23.639 --> 00:46:27.099
And I'm really excited to be talking about gaming.

00:46:27.099 --> 00:46:29.110
So if we can start with the camera.

00:46:29.110 --> 00:46:32.539
John told you that you guys are
making great drawing applications.

00:46:32.539 --> 00:46:38.400
The photographs and drawings that your users
are making are all over main stream print media.

00:46:38.400 --> 00:46:41.470
They're on the cover of the New
Yorker, they're in newspapers,

00:46:41.469 --> 00:46:45.589
I've even seen museum exhibits of iPhone photographs.

00:46:45.590 --> 00:46:50.350
You guys are making some great photography
applications that process images.

00:46:50.349 --> 00:46:52.920
This is an application called Camera Kit.

00:46:52.920 --> 00:46:58.059
It emulates classic film and film
processing techniques right on your iPhone.

00:46:58.059 --> 00:47:04.360
So you can use cross processing, you can
look at vignetting and push pull processing,

00:47:04.360 --> 00:47:07.789
you can even emulate sepia tone film right on your iPhone.

00:47:07.789 --> 00:47:10.179
This is pretty cool.

00:47:10.179 --> 00:47:11.549
Another application.

00:47:11.550 --> 00:47:12.720
Color splash.

00:47:12.719 --> 00:47:13.779
This is really fun.

00:47:13.780 --> 00:47:17.430
You can use the touch interface to
grow your photo incredibly large

00:47:17.429 --> 00:47:24.309
so that your finger becomes nearly infinitely precise
pointing device for out lining and coloring your photos.

00:47:24.309 --> 00:47:26.210
You wind up with things that really pop.

00:47:26.210 --> 00:47:32.019
This took me three, four minutes to
create a couple of days ago on my iPhone.

00:47:32.019 --> 00:47:35.360
Finally, we have the iPhone 3G S and the new camera.

00:47:35.360 --> 00:47:39.349
We are so proud of this camera and
the software that is driving it.

00:47:39.349 --> 00:47:45.809
As you heard this morning from Philip taking
beautiful 3 mega pixel images with automatic focus.

00:47:45.809 --> 00:47:49.170
We have touch to focus with automatic exposure to make sure

00:47:49.170 --> 00:47:52.340
that you're getting the correct exposure
for the object you're focusing on.

00:47:52.340 --> 00:47:56.829
Whether that be the house or the flowers in front.

00:47:56.829 --> 00:48:03.759
We have great low light performance, and my favorite,
beautiful automatic macro, up to about 10 centimeters.

00:48:03.760 --> 00:48:09.400
The good news for you as Phil mentioned, if you're
a still image or a camera developer on the iPhone,

00:48:09.400 --> 00:48:12.079
you get the advantages of this new camera for free.

00:48:12.079 --> 00:48:14.920
You don't have to change your application at all.

00:48:14.920 --> 00:48:20.599
Your users are going to have bigger, more beautiful
photographs to work with right inside your application.

00:48:21.619 --> 00:48:25.179
As an old QuickTime person, I'm thrilled
to be up here talking about video.

00:48:25.179 --> 00:48:28.049
We've been waiting a long time for this.

00:48:28.050 --> 00:48:31.190
Much like our camera applications,
we are looking forward incredibly

00:48:31.190 --> 00:48:35.400
to you guys making great video applications on iPhone.

00:48:35.400 --> 00:48:39.820
So what we've done is we've opened up
that API, much like our still image API.

00:48:39.820 --> 00:48:42.990
You have access to our recording user interface.

00:48:42.989 --> 00:48:47.419
Your user is going to get the same experience
that they do in our camera application.

00:48:47.420 --> 00:48:50.909
They can use automatic focus and touch
to focus to the point where they record,

00:48:50.909 --> 00:48:54.549
at which point we lock focus for
the duration of the recording.

00:48:54.550 --> 00:49:00.840
You'll get beautiful 30 frame per second
h.264 video, and high quality AAC audio.

00:49:00.840 --> 00:49:05.590
When your user is done recording you're given
a pointer to a file that you can process,

00:49:05.590 --> 00:49:09.519
store off in your application or
up load to the net as you like.

00:49:10.760 --> 00:49:14.590
We've also updated our image picker
controllers to include video.

00:49:14.590 --> 00:49:20.690
If you make no changes, you'll still have your plain still
images in your camera roll when you expose it to your users.

00:49:20.690 --> 00:49:26.840
If you opt into video, you can get your videos mixed in
with your still images, as we do in our camera application,

00:49:26.840 --> 00:49:31.309
or if you're a video focused application,
you can get just videos.

00:49:31.309 --> 00:49:32.869
We think this is pretty cool.

00:49:32.869 --> 00:49:38.730
We've also given you access to our new trim user interface,
so your users can edit video right on their phones,

00:49:38.730 --> 00:49:46.230
just like they can chose to use your -- you guys can
choose to use our crop interface with still images today.

00:49:46.230 --> 00:49:48.710
And that's cameras and imaging.

00:49:48.710 --> 00:49:54.309
I can't wait to see what kind of videos your users are going
to be posting to the Internet over the next year or so.

00:49:54.309 --> 00:50:05.099
So if we can turn an ear to audio, sound is at
the center of the user experience on iPhone.

00:50:05.099 --> 00:50:08.900
The behavior is so intuitive it feels completely natural.

00:50:08.900 --> 00:50:14.019
And that's because the user always gets to choose
where they hear their video -- their audio.

00:50:14.019 --> 00:50:21.869
I'm kind of hung up on video today -- where they hear their
audio, when they hear their audio, and how loud it might be.

00:50:21.869 --> 00:50:26.460
Now we don't ever ask them about that,
so the system can get fairly complicated.

00:50:26.460 --> 00:50:30.490
We have four discreet inputs, we have
six outputs, including one that's new

00:50:30.489 --> 00:50:33.819
in iPhone OS 3.0, which is HTTP streaming music.

00:50:33.820 --> 00:50:40.330
You're going to be able to stream music wirelessly
to your favorite A2D2 head phones, head sets,

00:50:40.329 --> 00:50:43.029
speakers, car kits, those sorts of things.

00:50:45.000 --> 00:50:48.039
[ Applause ]

00:50:48.039 --> 00:50:51.679
>> So on top of that you throw
on your ringer switch behavior,

00:50:51.679 --> 00:50:56.869
and contextual per volume, per
application, per route volumes.

00:50:56.869 --> 00:51:00.279
And things can get pretty complicated.

00:51:00.280 --> 00:51:03.250
The good news is that we've solved the problem.

00:51:03.250 --> 00:51:04.239
And you can too.

00:51:04.239 --> 00:51:09.199
And the key to solving that problem
is something we call audio session.

00:51:09.199 --> 00:51:11.289
Audio session is absolutely your friend.

00:51:11.289 --> 00:51:14.829
It's going to shelter your application
from the environment around it,

00:51:14.829 --> 00:51:19.309
the users whim, and new features like A2D2 streaming.

00:51:19.309 --> 00:51:22.820
So what do you do, how do you take
advantage of audio system.

00:51:22.820 --> 00:51:28.460
The point of audio system is for you to tell us
the purpose of your audio, which allows us in turn

00:51:28.460 --> 00:51:32.490
to give the correct behavior given the environment at hand.

00:51:32.489 --> 00:51:34.419
So how do you do that?

00:51:34.420 --> 00:51:39.110
Any time you want to play some audio or record
some audio, simply open up an audio session

00:51:39.110 --> 00:51:42.030
and tell us what kind of audio you're playing.

00:51:42.030 --> 00:51:50.630
Are you a streaming music application, are you an immersive
game, are you a recording application like Shazam,

00:51:50.630 --> 00:51:56.510
are you a voice over IP application that
requires low latency full duplex audio recording.

00:51:56.510 --> 00:52:00.780
No problem, tell us what you're doing,
we'll take care of the behavior.

00:52:00.780 --> 00:52:04.240
Last year you told us that you wanted a
little bit more flexibility in audio session.

00:52:04.239 --> 00:52:10.559
That you would like to choose whether your audio interrupts
music when you play it, just like a ring tone does,

00:52:10.559 --> 00:52:13.509
or mixes in like a key click or an SMS sound.

00:52:13.510 --> 00:52:17.320
In OS 3.0 we opened up those options
inside of your friendly audio session.

00:52:17.320 --> 00:52:19.050
So we encourage you to call them.

00:52:19.050 --> 00:52:24.010
If you take nothing else away from my audio part
today, call audio session, it's your friend.

00:52:24.010 --> 00:52:25.000
It will help you.

00:52:25.000 --> 00:52:26.849
I promise.

00:52:26.849 --> 00:52:30.710
So I'd like to take you on a quick
tour through our Audio API.

00:52:30.710 --> 00:52:32.809
We have four families of Audio API.

00:52:32.809 --> 00:52:34.590
We'll run through them pretty quickly.

00:52:34.590 --> 00:52:38.610
The first is Core Audio's Audio ToolBox and Audio Units.

00:52:38.610 --> 00:52:42.320
This is a technology that we have on Mac OS X.

00:52:42.320 --> 00:52:47.039
Our developers know and love it -- most of the time.

00:52:47.039 --> 00:52:54.009
We use it for low latency professional direct
access to the audio hardware in the audio stack.

00:52:54.010 --> 00:52:56.100
Our friends at Smule have used this to great effect.

00:52:56.099 --> 00:53:02.589
They made a great audio engine where they turn your
iPhone into a wind instrument, like the Ocarina.

00:53:02.590 --> 00:53:08.370
Most recently, they put out Leaf Trombone, which not only
is a wind instrument, but it's an educational instrument.

00:53:08.369 --> 00:53:10.889
And collaborative music instrument.

00:53:10.889 --> 00:53:16.679
They're sort of crazy at Smule, they've actually
formed an iPhone only band called MoPhO -- with a Ph --

00:53:16.679 --> 00:53:21.639
they have their debut performance
on Wednesday in the lunch session.

00:53:21.639 --> 00:53:23.039
I encourage you to check them out.

00:53:23.039 --> 00:53:25.889
I'll certainly be there.

00:53:25.889 --> 00:53:29.199
Now most of the time you love the Audio ToolBox.

00:53:29.199 --> 00:53:31.809
But some of you really like Cocoa Touch.

00:53:31.809 --> 00:53:36.769
And you asked very loudly for some Cocoa
Touch interfaces to our Audio ToolBox.

00:53:36.769 --> 00:53:38.210
We've given those to you.

00:53:38.210 --> 00:53:43.659
We have the AV foundation classes, they've given you
playback, recording, and even a Cocoa Touch interface

00:53:43.659 --> 00:53:47.690
to audio session, lest you forget to tell
us what kind of audio you're playing.

00:53:47.690 --> 00:53:54.050
Applications like Ruben & Lullaby love the low
configuration point and go experience of this.

00:53:54.050 --> 00:54:00.039
They're using AV foundation to make sure that you get an
immersive experience with this beautiful story telling --

00:54:00.039 --> 00:54:03.250
and it -- all of the interaction is
driven entirely by music and touch.

00:54:03.250 --> 00:54:05.849
It's pretty cool.

00:54:05.849 --> 00:54:07.230
We have OpenAL.

00:54:07.230 --> 00:54:10.090
OpenAL is our 3D positional au=dio system.

00:54:10.090 --> 00:54:13.789
It's an open standard, we have it on Mac
OS X, there are implementations on Windows

00:54:13.789 --> 00:54:18.719
and it's been on iPhone OS since day one.

00:54:18.719 --> 00:54:22.129
OpenAL is a great companion to OpenGL.

00:54:22.130 --> 00:54:23.970
It's great for games.

00:54:23.969 --> 00:54:30.230
Uses localized source positioning and distance
filtering to give you a 3-dimensional ROL experience.

00:54:30.230 --> 00:54:34.360
The next time you play Zen Bound or Super Monkey
Ball I encourage you to plug some head phones in.

00:54:34.360 --> 00:54:38.000
You'll find that you're in the middle of the
game surrounded by all of the game audio.

00:54:38.000 --> 00:54:40.550
I think it's pretty cool.

00:54:40.550 --> 00:54:46.640
Finally, you want your users to have access to
their music from directly inside your application.

00:54:46.639 --> 00:54:51.670
We've enabled this in iPhone OS 3.0, you
have two ways to access your user's music.

00:54:51.670 --> 00:54:58.240
One is through a standard user interface that's based
on our iPod music, our iPod application on iPod touch.

00:54:58.239 --> 00:55:01.579
And the other is direct programmatic access to your music.

00:55:01.579 --> 00:55:06.219
You can access things by album, artist, playlist,
track, you can even get the album art work if you

00:55:06.219 --> 00:55:08.899
like to display that from inside your application.

00:55:08.900 --> 00:55:11.970
So iPod library access.

00:55:11.969 --> 00:55:16.829
To tie up the audio portion there's this great
application called Bloom, and I'd like Graeme Divine

00:55:16.829 --> 00:55:22.130
from our iPhone Game Technologies team to
come and play us a little bit of music.

00:55:22.130 --> 00:55:29.000
Last year -- Graeme has some fans, huh?

00:55:29.000 --> 00:55:29.139
[ Applause ]

00:55:29.139 --> 00:55:35.349
>> So last fall -- last fall Brian Eno, the father
of ambient music got together with Peter Childers

00:55:35.349 --> 00:55:39.759
and put out this application that's based
entirely on OpenAL with a full 3D mixer.

00:55:39.760 --> 00:55:45.000
It's using OpenGL to draw these dots, and
I'm just going to let us listen for a moment.

00:55:45.000 --> 00:55:54.070
[ Music ]

00:55:54.070 --> 00:55:59.640
>> What this application is doing is letting any of you
have an interactive generative ambient music experience.

00:55:59.639 --> 00:56:02.389
It's turning all of us into musicians,
and we think it's just lovely.

00:56:02.389 --> 00:56:06.000
Thanks Graeme.

00:56:06.000 --> 00:56:10.829
[ Applause ]

00:56:10.829 --> 00:56:15.059
>> So that's audio.

00:56:16.139 --> 00:56:20.279
So I am over the moon to be talking
to you about gaming today.

00:56:20.280 --> 00:56:22.240
This is really close to my heart.

00:56:22.239 --> 00:56:26.199
A year ago we gave you an SDK full of awesome goodies.

00:56:26.199 --> 00:56:32.369
3D audio, 3D graphics, innovative input
methods, gorgeous full-screen video.

00:56:32.369 --> 00:56:41.019
On world class hardware that at its heart is portable,
always connected with full time access to your applications.

00:56:41.019 --> 00:56:44.489
We think this is a great story for game developers.

00:56:44.489 --> 00:56:45.179
You guys do too.

00:56:45.179 --> 00:56:48.250
Neal Young who you saw this morning
during the Keynote tells us that one

00:56:48.250 --> 00:56:51.960
of the great things iPhone is doing
is changing the relationship

00:56:51.960 --> 00:56:55.730
between the people making games and the people buying them.

00:56:55.730 --> 00:56:58.159
And if you forgive me, I just want to
sit and talk about this for a minute

00:56:58.159 --> 00:57:01.940
because we're an inflection point
where it comes to the game industry.

00:57:01.940 --> 00:57:03.599
And I think this is really interesting.

00:57:03.599 --> 00:57:06.809
And it's all about the audience.

00:57:06.809 --> 00:57:12.889
There's an untapped audience that you, our
developers, have found, and you've absolutely nailed.

00:57:12.889 --> 00:57:17.920
And the game industry has been chasing after
them, in my opinion unsuccessfully, for some time.

00:57:17.920 --> 00:57:19.510
I think this is really cool.

00:57:19.510 --> 00:57:23.100
The question is how did we do it.

00:57:23.099 --> 00:57:25.769
Well, I think it starts with the application store.

00:57:25.769 --> 00:57:28.960
And how it starts with the application
store is you make a great game,

00:57:28.960 --> 00:57:31.820
you send it to the application store, and it gets posted.

00:57:31.820 --> 00:57:32.840
It goes up in the new games.

00:57:32.840 --> 00:57:35.050
I see the game, I go pick it up, it's fun.

00:57:35.050 --> 00:57:36.600
I show it to Graeme at lunch.

00:57:36.599 --> 00:57:40.670
He thinks it's a great game too, so he buys it on
the spot without getting up from the lunch table.

00:57:40.670 --> 00:57:44.519
He takes it home, he shows his daughter, his
daughter buys it on the spot and takes it to school.

00:57:44.519 --> 00:57:47.070
Meanwhile, I've gone home -- you're getting the idea.

00:57:47.070 --> 00:57:48.920
This is kind of a chain reaction.

00:57:48.920 --> 00:57:52.889
Enough people start buying your application
and it makes it to the popular list.

00:57:52.889 --> 00:57:55.480
Gets to the popular list, and even more people.

00:57:55.480 --> 00:57:57.539
The velocity of this just takes off.

00:57:57.539 --> 00:57:58.630
It's pretty cool.

00:57:58.630 --> 00:58:00.940
If you want another view on this,
you should hit the second floor.

00:58:00.940 --> 00:58:04.050
Have you seen the application wall that's down there?

00:58:04.050 --> 00:58:08.170
Yeah? There are 20,000 applica tions arranged by color.

00:58:08.170 --> 00:58:12.619
And every time an application is bought, it
comes to the front, lights up, and wiggles.

00:58:12.619 --> 00:58:17.089
If you stand in front of it for a few minutes, it's
a little bit blade runner, but it's pretty amazing.

00:58:17.090 --> 00:58:20.440
Things are being bought a whole lot faster than you think.

00:58:20.440 --> 00:58:22.550
So this is all great.

00:58:22.550 --> 00:58:24.880
But you guys took it one step further.

00:58:24.880 --> 00:58:29.750
As soon as you started releasing games, you started
putting up leader boards, you implemented email systems

00:58:29.750 --> 00:58:34.019
so I can taunt my family and my friends and tell them
what I'm playing and that they should try to beat me.

00:58:34.019 --> 00:58:35.909
You implemented Facebook Connect.

00:58:35.909 --> 00:58:39.739
You're posting your scores directly
from within your game to Facebook.

00:58:39.739 --> 00:58:41.209
This is kind of cool.

00:58:41.210 --> 00:58:45.900
I read the other day that every posting to a
Facebook wall of one of these scores with a link back

00:58:45.900 --> 00:58:51.700
to the application store gets about 140 views within a day.

00:58:51.699 --> 00:58:52.639
Pretty cool.

00:58:52.639 --> 00:58:55.129
You're also posting Twitter notification systems.

00:58:55.130 --> 00:58:56.019
So this is -- this is great.

00:58:56.019 --> 00:58:58.869
You've got a whole bunch of social
interactions so that your games are spreading.

00:58:58.869 --> 00:59:02.130
There were a bunch of announcements
last week by some big companies.

00:59:02.130 --> 00:59:05.039
They're really excited about social
networking aspect of gaming,

00:59:05.039 --> 00:59:09.579
and they've been implementing Facebook
access, Twitter access.

00:59:09.579 --> 00:59:10.869
And I think this is profound.

00:59:10.869 --> 00:59:13.849
Because you guys, the big guys in
the industry, they're chasing you.

00:59:13.849 --> 00:59:16.049
It's pretty cool.

00:59:16.050 --> 00:59:21.660
So we say that there's an app for that, but
I put forth that there's a game for everyone.

00:59:21.659 --> 00:59:22.809
We just have to make them.

00:59:22.809 --> 00:59:28.860
It doesn't matter if you'd like
to play a 2D game or a 3D game.

00:59:30.070 --> 00:59:36.309
If you like cute twitch games, or
fast and intense car racing games.

00:59:36.309 --> 00:59:40.360
If you prefer playing with words
to blocks and ropes and physics.

00:59:40.360 --> 00:59:47.870
Whether you like to master the beat
or be the master of your own universe.

00:59:48.929 --> 00:59:56.009
If you're a big guy or a little guy, there's
a game for you, or there's a game to be made.

00:59:56.010 --> 01:00:00.120
John Carmack at id Software tells us that
right now the iPhone is the best platform

01:00:00.119 --> 01:00:03.150
in the world for a small team to make an impact with.

01:00:03.150 --> 01:00:05.090
I absolutely agree with him.

01:00:05.090 --> 01:00:08.150
Graeme, if used like to come back up for a moment.

01:00:08.150 --> 01:00:12.090
So to this end, a small development company
in Barcelona called Digital Legends.

01:00:12.090 --> 01:00:15.490
You might remember them from the Keynote last
year, they brought us a game called Krull,

01:00:15.489 --> 01:00:17.409
have been working on a fantastic new game.

01:00:17.409 --> 01:00:23.759
They brought a demo by last week, and
I'd like Graeme to show it to you.

01:00:25.730 --> 01:00:33.750
So what you're seeing here is an OpenGL
1.1 game with OpenAL 3D positional audio.

01:00:35.460 --> 01:00:37.139
It's visually just stunning.

01:00:37.139 --> 01:00:40.409
What you're seeing here is a bunch of particle effects.

01:00:40.409 --> 01:00:46.469
If you pay attention to the smoke and the destruction
these are all particle effects written in OpenGL ES 1.1.

01:00:46.469 --> 01:00:50.759
As the cars come by, pay attention
to the reflections on the cars.

01:00:50.760 --> 01:00:52.860
Those are all done with environment texture mapping.

01:00:52.860 --> 01:00:55.130
You can see that the cars are reflecting on each other.

01:00:55.130 --> 01:01:00.710
If you pay attention underneath the cars, the shadows are
being generated in real-time and reflecting the environment

01:01:00.710 --> 01:01:02.769
as they come under the bridge, watch the shadows.

01:01:02.769 --> 01:01:04.250
It's pretty neat.

01:01:04.250 --> 01:01:07.420
They've been playing with iPhone
OS 3.0 features as well, Graeme.

01:01:07.420 --> 01:01:13.000
If you'd play us a tune.

01:01:13.000 --> 01:01:16.739
[ Music ]

01:01:16.739 --> 01:01:21.959
>> Fast cars, fast cars, man, pick something else.

01:01:21.960 --> 01:01:23.309
[ Music ]

01:01:23.309 --> 01:01:23.799
>> Much better.

01:01:23.800 --> 01:01:24.789
[ Music ]

01:01:24.789 --> 01:01:38.809
>> So finally to wrap this up, I just want to talk
about the speedometer you're seeing in the HUD.

01:01:38.809 --> 01:01:45.509
What that's showing you is that on current hardware
today Digital Legends is utilizing it in a great way.

01:01:45.510 --> 01:01:51.340
We're taking about 400,000 to 500,000 polys
per second, which is absolutely achievable.

01:01:51.340 --> 01:01:55.800
You can get great effects with
today's hardware in OpenGL ES 1.1.

01:01:55.800 --> 01:01:58.660
Thanks Graeme.

01:02:00.000 --> 01:02:05.099
[ Applause ]

01:02:05.099 --> 01:02:08.960
>> The guys at Digital Legends are
really excited about iPhone OS 3.0.

01:02:08.960 --> 01:02:15.139
They found me just before this session, and
were looking at me going oh my God, GL ES 2.0.

01:02:15.139 --> 01:02:16.400
We have to use it.

01:02:16.400 --> 01:02:22.369
So I look forward to seeing this game in
both its 1.1 and its 2.0 incarnations.

01:02:22.369 --> 01:02:29.130
So focusing on 3.0 for just a moment, we have a
bunch of great features in 3.0 for game developers.

01:02:29.130 --> 01:02:31.860
The first one is the smart application store.

01:02:31.860 --> 01:02:36.579
Geoff told you a little bit about that, and really the
key here is as long as you declare the capabilities

01:02:36.579 --> 01:02:41.960
that your application needs, we will always
download the correct copy for your user's hardware.

01:02:41.960 --> 01:02:47.039
So please, feel free to use the new features, and
the new hardware will take care of your users.

01:02:47.039 --> 01:02:47.929
Parental controls.

01:02:47.929 --> 01:02:49.639
Scott talked about that this morning.

01:02:49.639 --> 01:02:53.309
Some of your games are not really
appropriate for my six year old niece.

01:02:53.309 --> 01:02:55.449
Parental controls can take care of that.

01:02:55.449 --> 01:02:56.919
We have the Push Notification system.

01:02:56.920 --> 01:03:02.409
This is going to be a great service to inviting someone
to a game, for telling them that it's their move,

01:03:02.409 --> 01:03:07.639
for notifying them of something happening within
the game world when they're out in real life.

01:03:07.639 --> 01:03:09.299
We have in app purchase.

01:03:09.300 --> 01:03:16.920
As Scott was thinking, you might use this for level --
levels and asset downloads directly in your application.

01:03:16.920 --> 01:03:19.909
I'm sure you'll find some clever uses for it as well.

01:03:19.909 --> 01:03:24.259
We talked about the iPod music library
access, and we talked about OpenGL ES 2.0.

01:03:24.260 --> 01:03:28.010
So I'd like to talk for just a moment about Game Kit.

01:03:28.010 --> 01:03:30.480
We're pretty excited about Game Kit.

01:03:30.480 --> 01:03:32.630
Game Kit has three parts.

01:03:32.630 --> 01:03:38.450
The first is an automatic discovery
service for peer to peer connections.

01:03:38.449 --> 01:03:41.819
This is implemented using our desktop technology,

01:03:41.820 --> 01:03:46.930
our zero-configuration Bonjour networking
technology that we brought over from Mac OS X.

01:03:46.929 --> 01:03:51.699
This is implemented now on top of
Bluetooth for iPhone and iPod touch.

01:03:51.699 --> 01:03:55.239
The great thing about this is that your users
will never see a Bluetooth pairing dialogue.

01:03:55.239 --> 01:03:57.429
Ever seen one of those, when you hook up a head set?

01:03:57.429 --> 01:04:02.919
Yeah, you're not going to have to see that when you
want to play a game, which we think is pretty cool.

01:04:02.920 --> 01:04:08.159
So we also wanted to give you some standard user
interface for when you were inviting someone to a game.

01:04:08.159 --> 01:04:10.559
So we set that up, we call that the Peer Picker.

01:04:10.559 --> 01:04:13.849
There's a standard UI for inviting someone.

01:04:13.849 --> 01:04:16.250
And for accepting or declining.

01:04:16.250 --> 01:04:18.409
Maybe they're a friend, maybe they're a foe, who knows.

01:04:18.409 --> 01:04:20.049
You might want to play a game.

01:04:20.050 --> 01:04:23.039
Finally, we built in a voice chat engine into Game Kit.

01:04:23.039 --> 01:04:30.029
We've taken what we learned making iChat AV for
Mac OS X, and we applied it to our iPhone OS.

01:04:30.030 --> 01:04:36.730
What this is, is a connection set up, we'll
pass voice data over Bluetooth or the Internet.

01:04:36.730 --> 01:04:39.420
We'll use standard servers like Jabber servers.

01:04:39.420 --> 01:04:41.920
We interoperate well there.

01:04:41.920 --> 01:04:48.220
Finally, there's a world class echo cancellation
and mixing service inside of the voice chat engine

01:04:48.219 --> 01:04:52.559
so that the voice chat audio will
seamlessly integrate with your game's audio.

01:04:52.559 --> 01:04:56.029
We think this will make it really easy
to implement voice chat in your games.

01:04:56.030 --> 01:05:01.550
We look forward to trash talking with you the
next time we want to play a nice game of Chess.

01:05:01.550 --> 01:05:05.410
So Geoff kind of challenged us a
little bit with his OpenGL ES demos.

01:05:05.409 --> 01:05:10.139
They were awfully pretty and they showed you to great
effect what you can do with a programmable shader.

01:05:10.139 --> 01:05:15.719
So we challenged Graeme, we gave him a team
of about five people and just a few days,

01:05:15.719 --> 01:05:19.250
and they put together this game that we like to call Shock.

01:05:19.250 --> 01:05:32.179
So the first thing to notice about this game is that
everything you're seeing on screen is being computed,

01:05:32.179 --> 01:05:35.210
generated, and rendered entirely on the GPU.

01:05:35.210 --> 01:05:38.900
Leaving your CPU free for AI, for
voice chat, for networking,

01:05:38.900 --> 01:05:41.610
for anything else you might want to use it for in your game.

01:05:41.610 --> 01:05:45.930
The audio is full 3D OpenAL audio.

01:05:45.929 --> 01:05:53.139
We have Blocks on the ends that are being attenuated on
a per pixel basis, depending on the state of the ball.

01:05:53.139 --> 01:05:59.150
The smoke that you're seeing is a fluid dynamic
simulation that's being affected by velocity

01:05:59.150 --> 01:06:01.809
and density, injected by the paddles and the ball.

01:06:01.809 --> 01:06:04.960
Again, being computed and rendered entirely on the GPU.

01:06:04.960 --> 01:06:10.150
One of the great things about a shader is once you have one
that you like, you can go ahead and change the appearance

01:06:10.150 --> 01:06:11.920
of it pretty easily by changing parameters.

01:06:11.920 --> 01:06:14.659
I particularly like the fire effect.

01:06:15.789 --> 01:06:19.429
Can make all kinds of cool lighting
effects as well, using shaders.

01:06:19.429 --> 01:06:21.789
The thing to notice in the next two screens is

01:06:21.789 --> 01:06:25.210
that there are no geometries being
drawn in the background in this game.

01:06:25.210 --> 01:06:26.650
That's entirely lightly effects.

01:06:26.650 --> 01:06:31.539
It takes about 10 lines of GLSL code to implement them.

01:06:33.079 --> 01:06:34.679
Pretty neat, huh?

01:06:34.679 --> 01:06:36.699
Mostly, I think the game is a lot of fun.

01:06:36.699 --> 01:06:42.449
[ Applause ]

01:06:42.449 --> 01:06:43.929
>> Thanks, Graeme.

01:06:45.369 --> 01:06:50.969
So to wrap up, it's our first birthday with the SDK.

01:06:50.969 --> 01:06:54.959
I can't think of a better present than all
of the applications that I have in my pocket,

01:06:54.960 --> 01:06:57.780
if I were allowed to have my phone
in here while I'm up on stage.

01:06:57.780 --> 01:07:02.200
I hope that you guys like the birthday
present that we've given you, the iPhone 3G S.

01:07:02.199 --> 01:07:06.119
It's the fastest, most powerful iPhone
yet, and I can't wait to see what kind

01:07:06.119 --> 01:07:08.699
of applications and games you make in the next year.

01:07:08.699 --> 01:07:10.000
That, and back to John.

01:07:10.000 --> 01:07:17.590
[ Applause ]

01:07:17.590 --> 01:07:21.640
>> Well, we talked about some of
the new and important graphics

01:07:21.639 --> 01:07:25.219
and media technologies available on
iPhone and Mac OS X Snow Leopard.

01:07:25.219 --> 01:07:30.579
And so hopefully this has given you some
ideas that you can then use to plan your week

01:07:30.579 --> 01:07:33.670
and decide what technologies you
want to go and learn more about.

01:07:33.670 --> 01:07:38.130
I think these are two really great platforms,
we're really excited about the technologies.

01:07:38.130 --> 01:07:39.480
I hope you are too.

01:07:39.480 --> 01:07:41.230
So thank you for joining us, and have a great week.
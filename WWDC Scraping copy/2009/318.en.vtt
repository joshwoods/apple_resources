WEBVTT

00:00:12.839 --> 00:00:18.670
>> So welcome to our WWDC Session,
Peer-to-Peer Networking with Game Kit.

00:00:18.670 --> 00:00:23.070
My name is Joe and I'll be the first of
three presenters who will talk to you

00:00:23.070 --> 00:00:29.039
about this brand new technology in iPhone 3.0.

00:00:29.039 --> 00:00:33.409
Some of you may be new to the iPhone and we welcome you.

00:00:33.409 --> 00:00:37.449
And others of you are veteran developers on iPhone
and you may have one or more apps on the App Store.

00:00:37.450 --> 00:00:47.520
Of course you're all welcome and in either case what
you'll find in Game Kit is an amazingly easy API to use

00:00:47.520 --> 00:00:52.290
to connect your application across multiple devices.

00:00:52.289 --> 00:01:01.600
If you already have an application that connects
multiple users and works over the internet,

00:01:01.600 --> 00:01:10.090
what you'll find in Game Kit is a very simple API
that you can use to add voice chat functionality.

00:01:10.090 --> 00:01:14.710
To show you how you're going to learn about
all this today, let's go over the agenda.

00:01:14.709 --> 00:01:26.059
We'll go over a brief overview of the capabilities of
Game Kit, following this we're going to go into the APIs.

00:01:26.060 --> 00:01:34.969
There are three classes in Game Kit, the GKSession which
we'll refer to as the Session, the GKPeerPickerController

00:01:34.969 --> 00:01:42.459
which we'll call the Peer Picker, and then there's
the GKVoiceChatService which we'll call Voice Chat.

00:01:42.459 --> 00:01:47.500
Now as we talk to you about the APIs in these
classes, you're going to see some code samples

00:01:47.500 --> 00:01:52.010
and at the same time we hope that you hear
some tips and best practices to using them.

00:01:52.010 --> 00:01:56.170
Now let me talk about what you're going to learn.

00:01:56.170 --> 00:02:01.870
You're going to essentially learn
two main things this morning.

00:02:01.870 --> 00:02:06.650
The first of course is how to use Game
Kit to connect to your application.

00:02:06.650 --> 00:02:11.640
In Game Kit, we have two classes for this purpose.

00:02:11.639 --> 00:02:18.449
There is the GKSession, the session object
which will handle all the networking for you,

00:02:18.449 --> 00:02:26.019
and then there is the Peer Picker object which
will give you an instant UI that you can use

00:02:26.020 --> 00:02:30.510
to quickly connect two users of your application.

00:02:31.810 --> 00:02:40.469
The network that Game Kit creates is a peer-to-peer
network composed of devices running your application.

00:02:40.469 --> 00:02:45.780
Your application doesn't need to
be online for this to happen,

00:02:45.780 --> 00:02:50.979
so this means of course you don't need a WiFi router,
you don't need a cell data network connection.

00:02:50.979 --> 00:02:56.519
What you do need is Bluetooth, and the hardware

00:02:56.520 --> 00:03:02.159
that supports this new Bluetooth
functionality are the iPhone 3G including

00:03:02.159 --> 00:03:08.909
of course their brand new 3GS and
the second generation iPod touch.

00:03:08.909 --> 00:03:20.280
The second thing that you're going to learn this morning
will be to how to use Game Kit to integrate voice chat.

00:03:20.280 --> 00:03:27.150
We essentially have voice chat in the box
where you just need to provide the network.

00:03:27.150 --> 00:03:33.180
So the API is designed to integrate
with your existing network code.

00:03:33.180 --> 00:03:40.030
Now as well as handling some obvious things
for you such as audio encoding and decoding,

00:03:40.030 --> 00:03:44.750
it includes usage of that voice processing
unit that Eric Allamanche spoke

00:03:44.750 --> 00:03:48.250
about in a previous CoreAudio session yesterday.

00:03:48.250 --> 00:03:52.490
So it includes echo cancellation.

00:03:52.490 --> 00:03:56.370
Now let's see how Game Kit may fit into your application.

00:03:56.370 --> 00:04:01.370
Here is the application at the top.

00:04:01.370 --> 00:04:09.900
Your application has access to one or more of the Game
Kit objects, the session, Peer Picker and voice chat.

00:04:09.900 --> 00:04:17.280
Game Kit itself to handle all of its
networking, is built on Bonjour and sockets.

00:04:17.279 --> 00:04:24.799
Game Kit uses Bonjour Service Discovery to find
your application running on different devices.

00:04:24.800 --> 00:04:32.500
And then Game Kit is using socket APIs to
establish network connections between the devices,

00:04:32.500 --> 00:04:37.110
between your applications running on
these devices, and to deliver your data.

00:04:37.110 --> 00:04:44.090
There are a couple of things I
want to mention about Bonjour.

00:04:44.089 --> 00:04:55.909
The first is that in iPhone 3.0, peer-to-peer connectivity
over Bluetooth is integrated at the Bonjour layer.

00:04:55.910 --> 00:05:02.600
What this means for you is that if you already
have an application that works over Bonjour,

00:05:02.600 --> 00:05:08.230
then if your users are an iPhone 3.0
and they're on the supported hardware,

00:05:08.230 --> 00:05:12.060
your application will automatically
just work over Bluetooth.

00:05:12.060 --> 00:05:17.089
You don't have to make any code
changes for this functionality.

00:05:17.089 --> 00:05:22.859
Now I do want to point that if this is the first time you've
heard about Bonjour or if you know every little about it,

00:05:22.860 --> 00:05:29.290
or if you don't know much about socket APIs, you don't
have to know these things in order to use Game Kit.

00:05:29.290 --> 00:05:37.460
Game Kit interfaces with these APIs
directly and can handle all this for you.

00:05:37.459 --> 00:05:41.620
Now I'm going to go and talk about the session API.

00:05:41.620 --> 00:05:48.569
Before I get into the details of the
API, let's talk about some terminology.

00:05:48.569 --> 00:05:58.800
In Game Kit we use the term peer to
refer to an instance of a GKSession.

00:05:58.800 --> 00:06:05.980
Now since your application will typically just use one
instance of GKSession, what this essentially means is

00:06:05.980 --> 00:06:10.319
that a peer is your application running on a device.

00:06:10.319 --> 00:06:21.829
Now to differentiate between the different devices running
your application, Game Kit has what we call a peer ID.

00:06:21.829 --> 00:06:26.279
This is some string that's a unique identifier for peer.

00:06:26.279 --> 00:06:32.679
Note that even though this is a string,
you should not display this to your user.

00:06:32.680 --> 00:06:41.990
If you wanted a public name for the peer ID or display
name, we have a method called displayNameForPeerID

00:06:41.990 --> 00:06:45.939
which will give you this name, and when I talk about how

00:06:45.939 --> 00:06:52.000
to create the GKSession you'll see how you can set
this display name to whatever value you'd like.

00:06:56.310 --> 00:07:02.810
Now there are only three stages to
using GKSession in your application.

00:07:02.810 --> 00:07:07.360
You first need to initialize the GKSession.

00:07:07.360 --> 00:07:14.530
Once you've done that you can proceed to connect to
other users, and once you've connected at least two users

00:07:14.529 --> 00:07:20.349
or two instances of your application, you
can then begin to send and receive data.

00:07:20.350 --> 00:07:24.300
Now I'm going to go through each of these stages in turn.

00:07:24.300 --> 00:07:29.000
Stage 1, initialize the GKSession.

00:07:29.000 --> 00:07:32.589
You first of course need to create a GKSession object.

00:07:32.589 --> 00:07:39.250
So what you see up here is code
that alloc inits a GKSession.

00:07:39.250 --> 00:07:41.220
You'll note that it takes three parameters.

00:07:41.220 --> 00:07:48.510
The first parameter is what we call a session ID.

00:07:48.509 --> 00:07:53.139
This is an ID that uniquely identifies your application.

00:07:53.139 --> 00:08:00.689
Game Kit will use your session ID to
differentiate it from the session IDs

00:08:00.689 --> 00:08:05.389
of other applications written by
other developers such as yourself.

00:08:05.389 --> 00:08:13.279
To help insure that your session ID is indeed unique to you,

00:08:13.279 --> 00:08:20.859
we recommend that you register your
session ID as a Bonjour service type.

00:08:22.649 --> 00:08:27.459
Now in my case I have my session ID and that
could certainly be a registered service type

00:08:27.459 --> 00:08:32.069
or it could just be some string that I've come up with.

00:08:32.070 --> 00:08:37.910
Now if you're wondering what string to use or if you
haven't had the chance to go and register a service type,

00:08:37.909 --> 00:08:41.549
you could certainly pass a nil as a first parameter.

00:08:41.549 --> 00:08:48.120
If you do this, what Game Kit will do is
generate a session ID for you that is based

00:08:48.120 --> 00:08:51.580
on the bundle identifier in your application.

00:08:51.580 --> 00:08:58.090
So you can do this to quickly get started with
GKSession but we really recommend that you register it

00:08:58.090 --> 00:09:03.060
as a Bonjour service type, and I believe in Allan
Schaffer's talk yesterday he showed you a website

00:09:03.059 --> 00:09:05.000
where you can go do that.

00:09:05.000 --> 00:09:06.960
So check that out.

00:09:06.960 --> 00:09:14.320
It's easy, you send an email, it's
free, and your service type as well

00:09:14.320 --> 00:09:16.940
as your company's name will actually be posted on a webpage.

00:09:16.940 --> 00:09:19.540
So we'll have a free advertising for you.

00:09:19.539 --> 00:09:24.039
Now let's go to the second parameter, the display name.

00:09:24.039 --> 00:09:33.689
This is how you set that public name that is returned
when you call the display name for peer method.

00:09:33.690 --> 00:09:42.650
In my example on passing a nil, if you pass a nil here,
Game Kit will just use your device name as the display name.

00:09:42.649 --> 00:09:53.829
If you're not satisfied with the device name, if you want
to pass in your own name like a real name like Andy or Bob,

00:09:53.830 --> 00:09:58.730
or you want to use a gamer handle,
pass it in as a second parameter.

00:09:58.730 --> 00:10:04.629
The third parameter is a session mode.

00:10:06.529 --> 00:10:14.169
The session mode affects how Game
Kit will find and connect peers.

00:10:14.169 --> 00:10:22.169
>> There are three modes in Game
Kit, server, client, and peer.

00:10:22.169 --> 00:10:27.699
In server mode the peer is just advertising your session ID.

00:10:27.700 --> 00:10:32.440
It's doing this because it's expecting to be
found by other peers searching for your session ID

00:10:32.440 --> 00:10:37.610
so that it can then receive connection requests.

00:10:37.610 --> 00:10:44.399
Client mode is a mode where the peer
will search for your session ID.

00:10:44.399 --> 00:10:52.029
So a peer in client mode will find a peer in
server mode assuming their session IDs match.

00:10:52.029 --> 00:10:53.919
The third mode is peer mode.

00:10:53.919 --> 00:10:56.339
It's a combination of client and server.

00:10:56.340 --> 00:11:04.480
A peer in peer mode will both advertise
your session ID and search for it.

00:11:04.480 --> 00:11:11.289
Now you'll note in the diagram here, you could see that we
have four devices connected using server and client mode.

00:11:11.289 --> 00:11:17.620
And what we recommend is that if you want, you know,
if your application requires the need to connect more

00:11:17.620 --> 00:11:24.269
than two instances together, we recommend that
you use client mode and server mode to do this.

00:11:24.269 --> 00:11:27.470
It's the most efficient way for
you to get more than two devices

00:11:27.470 --> 00:11:29.810
or more than two instances of your
application connected together.

00:11:29.809 --> 00:11:37.869
Now I've finished talking about how to create the
object, there are two remaining things you need to do.

00:11:37.870 --> 00:11:39.899
You need to set the delegate.

00:11:39.899 --> 00:11:45.340
GKSession has a delegate protocol
called the GKSession Delegate Protocol

00:11:45.340 --> 00:11:50.730
and it is through this delegate where
you can get events from Game Kit.

00:11:50.730 --> 00:11:57.990
The last thing you need to do in stage
1 is to set the session as available.

00:11:57.990 --> 00:12:07.100
Setting the session as available starts this process of
either advertising your session ID, searching for it,

00:12:07.100 --> 00:12:14.940
or the combination of the two depending on the
mode that you have selected for the session.

00:12:14.940 --> 00:12:19.610
We're now at stage 2, connecting to other users.

00:12:19.610 --> 00:12:27.070
To establish a connection to another peer,
Game Kit has a method called connectToPeer

00:12:27.070 --> 00:12:33.010
and this just takes the peer ID of
the peer that you want to connect to.

00:12:33.009 --> 00:12:41.350
This peer in order to handle this connection
invitation will need to watch for incoming connections.

00:12:41.350 --> 00:12:48.909
And to do this the delegate must implement the
session didReceiveConnectionRequestFromPeer method.

00:12:48.909 --> 00:12:56.169
It is through this method that the session will tell you
the delegate that hey, here is an incoming connection.

00:12:56.169 --> 00:13:03.569
And what you'll get is the peer ID of
the peer that wants to connect to you.

00:13:03.570 --> 00:13:10.879
So you're expected to respond to this
invitation and you could accept or deny it.

00:13:10.879 --> 00:13:19.730
In my example here you could see us accepting the connection
and to do so we call acceptConnectionFromPeer and we pass

00:13:19.730 --> 00:13:23.420
in the peer ID of that peer that
sent us the connection request.

00:13:23.419 --> 00:13:33.709
Now you might be wondering, how do I know the
peer ID of the peer that I want to connect to?

00:13:33.710 --> 00:13:41.110
Or if I was able to send a connection request and
it was accepted, how do I know that it succeeded?

00:13:41.110 --> 00:13:44.639
How do I know that I'm now connected to this other peer?

00:13:44.639 --> 00:13:52.069
Well the key thing here to handle this or to
find out is to watch for peer state changes.

00:13:52.070 --> 00:14:00.210
To do this, your delegate must implement
the session peer didChangeState method.

00:14:00.210 --> 00:14:11.670
It is through this method that the session will tell
the delegate the new state for a particular peer.

00:14:11.669 --> 00:14:16.669
One example state is the available state.

00:14:16.669 --> 00:14:24.509
A peer that comes in with the available states is
a peer that was found that matches your session ID

00:14:24.509 --> 00:14:27.230
and it's a peer that can accept connection requests.

00:14:27.230 --> 00:14:34.250
So if your application has a UI and
you want to present a UI to your user,

00:14:34.250 --> 00:14:38.629
of the available users around who
are also running your application,

00:14:38.629 --> 00:14:44.409
if you get this callback you can update
your UI with the name of that user.

00:14:44.409 --> 00:14:48.789
And you can get the name by calling
the displayNameForPeerID method.

00:14:51.950 --> 00:14:58.660
And then if they click that name, you can then
call that connect to peer method that I showed you

00:14:58.659 --> 00:15:05.819
on the previous slide, connect
to peer and pass in that peer ID.

00:15:05.820 --> 00:15:12.180
Now if you've sent the connection request and it's been
accepted, each peer will know that it's now connected

00:15:12.179 --> 00:15:17.399
to the other peer by callback where the state is connected.

00:15:17.399 --> 00:15:22.220
A peer that comes in to this callback
to this didChangeState callback

00:15:22.220 --> 00:15:26.990
with the connected state is now connected to your session.

00:15:26.990 --> 00:15:33.639
So now your peer can send and receive data with this peer.

00:15:33.639 --> 00:15:36.330
Now these are just two states that I mentioned.

00:15:36.330 --> 00:15:39.410
If you look at the API documentation there is actually more.

00:15:39.409 --> 00:15:46.069
One state here that's missing which you may have seen
in Allan's slides yesterday is the disconnected state.

00:15:46.070 --> 00:15:49.120
So you'll also know that you're no
longer connected to a particular peer

00:15:49.120 --> 00:15:56.990
if you get this callback and the state is disconnected.

00:15:56.990 --> 00:16:02.430
We're now at stage 3, send and receive data.

00:16:02.429 --> 00:16:06.039
In Game Kit we have two methods to send data.

00:16:06.039 --> 00:16:13.189
The method that you see up here is one that allows you
to send data to all the peers that are connected to you.

00:16:13.190 --> 00:16:21.080
The other method which you can see in the documentation
is one that allows you to send data to a subset of peers,

00:16:21.080 --> 00:16:25.410
just one peer or two out of four if you
have a team based type of application.

00:16:25.409 --> 00:16:33.159
In both cases, the data that you want to
send needs to be wrapped in an NSData,

00:16:33.159 --> 00:16:42.209
so you simply take your application data, wrap it in an
NSData and then pass it as a first parameter in this method.

00:16:42.210 --> 00:16:46.350
Game Kit supports two modes of data delivery.

00:16:46.350 --> 00:16:50.850
There is a reliable mode and an unreliable mode.

00:16:50.850 --> 00:16:56.769
You'll want to use reliable mode for data
that is critical to your application,

00:16:56.769 --> 00:16:59.079
data that needs to arrive at all the peers.

00:16:59.080 --> 00:17:06.940
In reliable mode, Game Kit will take care of retransmitting
this data for you as well as delivering this data in order

00:17:06.940 --> 00:17:12.289
if you've called send data with
reliable mode multiple times in a row.

00:17:12.289 --> 00:17:16.379
Now there is some overhead because of the retransmissions.

00:17:16.380 --> 00:17:24.250
So if you have app data that updates
frequently such as real-time data for example,

00:17:24.250 --> 00:17:32.309
or more obviously a positional data, you
should use the unreliable mode for send data.

00:17:32.309 --> 00:17:39.649
The last parameter is an error parameter, and
note that if there is invalid error returned here,

00:17:39.650 --> 00:17:43.420
it's more an error about data transmission.

00:17:43.420 --> 00:17:49.210
Send data as well as many other
methods in Game Kit is non-blocking.

00:17:49.210 --> 00:17:52.759
So when you call send data it's going to return right away.

00:17:52.759 --> 00:17:59.970
If there is an error, you should check that and one error
that you may encounter especially if you're first playing

00:17:59.970 --> 00:18:04.839
with this and using a reliable mode all
the time is a buffer full type of error.

00:18:04.839 --> 00:18:12.269
Now if you're sending data you're
going to want a way to receive it,

00:18:12.269 --> 00:18:17.180
so to do this you need to set what
we call a data receive handler.

00:18:17.180 --> 00:18:27.890
This is an object that implements the receive
data from peer in session context method.

00:18:27.890 --> 00:18:35.060
You'll note that the data that you receive
will come to you as an NSData object.

00:18:35.059 --> 00:18:42.309
So you could simply access the bytes
there and parse your data as you see fit.

00:18:42.309 --> 00:18:47.559
You'll also note that you get the peer
ID of the peer who sent you that data.

00:18:47.559 --> 00:18:50.419
So, you know, that comes in as a second parameter here.

00:18:50.420 --> 00:18:57.370
Now I'm done with stage 3 and that's pretty much it.

00:18:57.369 --> 00:19:00.239
Those are the three stages that you
would need to follow if you want

00:19:00.240 --> 00:19:03.759
to integrate GKSession directly in your application.

00:19:03.759 --> 00:19:10.299
So a slide for review, Game Kit creates a
peer-to-peer network and delivers your data.

00:19:10.299 --> 00:19:16.430
In iPhone 3.0 this support is over Bluetooth.

00:19:16.430 --> 00:19:23.230
Game Kit uses the notion of peers and peer IDs to
refer to devices that are running your application

00:19:23.230 --> 00:19:25.650
or your application instances on different devices.

00:19:25.650 --> 00:19:32.110
And then there are just three stages
to using GKSession in your application.

00:19:32.109 --> 00:19:38.799
You initialize the GKSession passing it important
information such as the session ID and then choosing a mode.

00:19:38.799 --> 00:19:44.809
You could then proceed to connect to your peers.

00:19:44.809 --> 00:19:48.710
Implement that didChangeState callback and know
when a peer is available so that you could then call

00:19:48.710 --> 00:19:51.559
that connect to peer method to connect to them.

00:19:51.559 --> 00:19:56.659
And then once you're connected to at least
one other peer, you can deliver your data

00:19:56.660 --> 00:19:59.660
and call the send data receive
methods and make sure you have it set,

00:19:59.660 --> 00:20:03.509
a data receive handler so you can receive the data.

00:20:03.509 --> 00:20:07.789
Now earlier on I mentioned that the first
thing that you're going to learn today is how

00:20:07.789 --> 00:20:10.940
to use Game Kit to connect your application.

00:20:10.940 --> 00:20:16.430
And then I mentioned that there are two
classes that you can use to help you with this.

00:20:16.430 --> 00:20:20.170
>> I've just told you about the GKSession.

00:20:20.170 --> 00:20:28.890
The other object is the Peer Picker and it can actually
take care of stages 1 and 2 for you as well as provide you

00:20:28.890 --> 00:20:36.660
with a standard UI that you can immediately use to connect
your application across two devices and to tell you all

00:20:36.660 --> 00:20:41.269
about this, I would like to introduce
my colleague Jonathan Bennett.

00:20:41.269 --> 00:20:42.039
Thank you.

00:20:42.039 --> 00:20:46.750
[ Applause ]

00:20:46.750 --> 00:20:48.269
>> Thanks Joe.

00:20:49.630 --> 00:20:55.190
So I'm Jonathan Bennett and I'm a
software engineer on the Game Kit team.

00:20:55.190 --> 00:20:58.930
So you just heard Joe talked about
how you can use the Game Kit session

00:20:58.930 --> 00:21:05.310
to easily discover, connect, and send data to other peers.

00:21:05.309 --> 00:21:11.139
Now if you have a multiplayer game or a multiuser
application, one of the most important things you're going

00:21:11.140 --> 00:21:18.120
to need to do is provide your users with
a way to find and connect to other peers.

00:21:18.119 --> 00:21:26.929
Now we also know that you as developers are more
interested in what happens after your peers are connected.

00:21:26.930 --> 00:21:33.779
It's your in-game multiplayer experience that's
going to have your players coming back for more.

00:21:33.779 --> 00:21:45.000
So to help with this, if you have a one-on-one multiplayer
game, we provided a facility called the Peer Picker

00:21:45.000 --> 00:21:48.680
to make finding and connecting to peers even easier.

00:21:48.680 --> 00:21:51.519
So what is the Peer Picker?

00:21:51.519 --> 00:21:59.930
Simply it's a standard Apple user interface that you can
show to your users to have them connect two peers together

00:21:59.930 --> 00:22:04.360
into the Game Kit session that you can
then use to start your multiplayer game.

00:22:04.359 --> 00:22:07.879
So how does this fit in to your application?

00:22:07.880 --> 00:22:14.240
As Joe talked about, your application sits
on top and can call the Game Kit session

00:22:14.240 --> 00:22:19.099
to do this discovery connection
and sending data back and forth.

00:22:19.099 --> 00:22:25.429
Now if you have a one-on-one multiplayer application, you
can use the Peer Picker to sit in between your application

00:22:25.430 --> 00:22:30.259
and the Game Kit session and it will
handle everything you need to do

00:22:30.259 --> 00:22:35.000
for connect-- finding and connecting to another peer.

00:22:38.069 --> 00:22:43.839
So that's what the Peer Picker does for
you, what does it do for your users?

00:22:43.839 --> 00:22:53.240
Well first and importantly it provides a
list of nearby iPhones and iPod touches

00:22:53.240 --> 00:22:59.190
that your user can connect to in order to play a game.

00:22:59.190 --> 00:23:04.990
If your user wants to select somebody in the list
it will send an invitation to that other iPhone.

00:23:04.990 --> 00:23:12.289
The other iPhone will receive an invitation where
they can choose to accept or decline the invitation.

00:23:12.289 --> 00:23:25.329
And if they accept the Peer Picker manages the
connection of those two peers into a Game Kit session.

00:23:25.329 --> 00:23:30.919
Additionally, the Peer Picker provides your users with
a way to turn on Bluetooth from within your application

00:23:30.920 --> 00:23:34.220
so they don't have to go outside of
your application to turn on Bluetooth

00:23:34.220 --> 00:23:37.860
and come back in, in order to do peer-to-peer gaming.

00:23:37.859 --> 00:23:44.889
So let's go through a workflow of how
this looks and how your application

00:23:44.890 --> 00:23:48.710
and your users interact with the Peer Picker.

00:23:48.710 --> 00:23:58.870
So here we have John's iPhone and John wants to play a game
so he taps multiplayer and your application sends messages

00:23:58.869 --> 00:24:02.869
to Game Kit saying that they want to show the Peer Picker.

00:24:02.869 --> 00:24:11.129
The Peer Picker asks your session if you have a Game
Kit session that you'd like to provide to help do this.

00:24:11.130 --> 00:24:19.940
Your application provides it and now you have
a session that is sending and receiving data.

00:24:19.940 --> 00:24:23.279
So Jane's iPhone comes along and they discover each other

00:24:23.279 --> 00:24:29.910
and the session tells the Peer
Picker that they have found a peer.

00:24:29.910 --> 00:24:36.700
So the Peer Picker shows who is available on the list
and now let's say that John's iPhone or John wants

00:24:36.700 --> 00:24:44.080
to play a game with Jane so he taps Jane in
the list, automatically sends an invitation

00:24:44.079 --> 00:24:48.389
to Jane's iPhone and Jane receives this invitation.

00:24:48.390 --> 00:24:53.420
Now Jane also wants to play with
John so she accepts this invitation.

00:24:53.420 --> 00:24:59.840
Again, automatically this notifies
John's iPhone that she has accepted.

00:25:01.250 --> 00:25:08.930
The sessions become connected and the Peer Picker tells
your application that it is connected to another peer.

00:25:11.670 --> 00:25:19.019
Now that your application is done with the Peer Picker,
it dismisses it and it now has a fully configured

00:25:19.019 --> 00:25:23.559
and connected Game Kit session that you
can use to start your multiplayer game.

00:25:23.559 --> 00:25:28.759
So how do we get this into your application?

00:25:28.759 --> 00:25:30.930
There's three main steps.

00:25:30.930 --> 00:25:34.820
First you need to show the Peer Picker to your users.

00:25:34.819 --> 00:25:39.599
You then need to be able to respond to Peer
Picker events such as when a peer is connected.

00:25:39.599 --> 00:25:44.449
And when a peer is connected you
need to take over responsibility

00:25:44.450 --> 00:25:49.819
for the Game Kit session in order
to start your multiplayer game.

00:25:49.819 --> 00:25:52.269
Let's go into this first part showing the Peer Picker.

00:25:52.269 --> 00:25:54.539
It's pretty simple.

00:25:54.539 --> 00:26:04.450
First you need to initialize a Peer Picker by calling
the GKPeerPickerController object and allocating it.

00:26:04.450 --> 00:26:06.680
You then need to set the picker's delegate.

00:26:06.680 --> 00:26:13.000
And then lastly you need to show the picker by calling
the show method and this is all you need in order

00:26:13.000 --> 00:26:20.200
to display the Peer Picker to your users and have it
automatically start finding nearby peers over Bluetooth.

00:26:20.200 --> 00:26:28.269
And we also realized that some of you may be developing
games that you want to provide your users with an option

00:26:28.269 --> 00:26:35.279
to either do nearby peer-to-peer connections over
Bluetooth or you may have a remote internet service

00:26:35.279 --> 00:26:37.700
that you provide for internet connections.

00:26:37.700 --> 00:26:46.380
Well if your app supports this, you can tell the Peer
Picker this and we'll provide an additional UI to the user

00:26:46.380 --> 00:26:52.580
when it initially comes up that allows them to select
whether they want to do a nearby connection or they want

00:26:52.579 --> 00:26:55.549
to connect to your remote internet service.

00:26:55.549 --> 00:26:59.099
So how do you tell the Peer Picker this?

00:26:59.099 --> 00:27:03.269
It's really simple, same basic steps as we saw before except

00:27:03.269 --> 00:27:07.220
for before we call the show method
we set the connection types--

00:27:07.220 --> 00:27:14.779
the connectionTypesMask property to
both nearby and online connection types.

00:27:14.779 --> 00:27:20.430
And this is all you need to show
that UI for your users to select.

00:27:20.430 --> 00:27:27.690
So now you have shown your users the
Peer Picker, how do you interact with it?

00:27:27.690 --> 00:27:33.100
Oh sorry, there is one important note to this.

00:27:33.099 --> 00:27:40.250
The Peer Picker only handles configuring network
connections over nearby Bluetooth connections

00:27:40.250 --> 00:27:49.950
so if your application supports remote internet service,
you will need to provide a UI and a way for your users

00:27:49.950 --> 00:27:52.460
to configure your remote internet connections.

00:27:52.460 --> 00:28:03.490
So how do you interact with it, you do it through the
delegate and the delegate has a few responsibilities.

00:28:03.490 --> 00:28:15.589
First, it needs to respond to some user actions, then
it also needs to provide a way to tell the Peer Picker

00:28:15.589 --> 00:28:19.279
who to look for and it does that
by providing a GKSession object.

00:28:19.279 --> 00:28:26.720
And then lastly and importantly it needs to respond when
peers have been connected so you can start your game.

00:28:26.720 --> 00:28:31.910
And it does this through the GKPeerPickerControllerDelegate.

00:28:35.750 --> 00:28:40.269
So a first interaction to deal with is a user cancelled.

00:28:41.289 --> 00:28:47.409
This happens when the user taps on the
Cancel button and you can respond to this

00:28:47.410 --> 00:28:53.420
by implementing the -peerPickerController:didCancelDelegate
method.

00:28:53.420 --> 00:28:59.080
And basically this is your opportunity to clean
up any state, deal with any memory management

00:28:59.079 --> 00:29:01.369
and show any new UI or enable any new UI.

00:29:01.369 --> 00:29:08.229
So what might this look like in
code, here is a quick example.

00:29:08.230 --> 00:29:14.160
Here we are releasing the Peer Picker since we're
done with it and in this example we have a reference

00:29:14.160 --> 00:29:20.230
to a Game Kit session so we're cleaning that up because
we're not going to use it since the user cancelled.

00:29:20.230 --> 00:29:26.099
And then we go and display our main
menu UI if we need to and that's it.

00:29:26.099 --> 00:29:31.129
The Peer Picker automatically dismisses
when the user cancels it

00:29:31.130 --> 00:29:34.040
so there is no need to programmatically dismiss it here.

00:29:34.039 --> 00:29:39.819
So your implementation will probably
look somewhat similar to this.

00:29:39.819 --> 00:29:48.619
Another user interaction that you'll need to deal with is if
the user taps on a connection type in that connection panel.

00:29:48.619 --> 00:29:55.959
Again, this is only shown if you told the Peer
Picker that you support multiple connection types

00:29:55.960 --> 00:29:59.289
and if you do you'll need to respond to this.

00:29:59.289 --> 00:30:04.659
And you do that through the
-peerPickerController:didSelectConnectionTypeDelegate

00:30:04.660 --> 00:30:05.820
method.

00:30:07.049 --> 00:30:14.319
Now as I mentioned, the Peer Picker only supports a
way to configure nearby connections over Bluetooth.

00:30:14.319 --> 00:30:24.169
>> So if you have a-- if you support multiple
connection types and the user taps the online button,

00:30:24.170 --> 00:30:28.970
you'll need to programmatically dismiss
the Peer Picker, and how do you do this.

00:30:28.970 --> 00:30:36.130
Quite simply, you just check if the
selected type is the online type and if so,

00:30:36.130 --> 00:30:40.770
you programmatically dismiss the Peer
Picker by calling the dismiss method.

00:30:40.769 --> 00:30:45.579
You release the Peer Pickers as you're done with it because
you're going to dismiss it and then show your own UI

00:30:45.579 --> 00:30:49.250
for configuring remote internet connections.

00:30:53.109 --> 00:30:57.459
So another thing you may want to do is
tell the Peer Picker who to look for

00:30:57.460 --> 00:31:00.519
and you do this by providing a Game Kit session.

00:31:06.109 --> 00:31:11.609
And you provide it through the peerPickerController
session for ConnectionTypeDelegate method.

00:31:11.609 --> 00:31:20.789
And this is, excuse me, the reason why you
may want to do this is as Joe mentioned,

00:31:20.789 --> 00:31:28.740
when you create a Game Kit session you can
provide a session ID and a display name.

00:31:28.740 --> 00:31:35.460
Joe mentioned that you may register your-- a
Bonjour service type and use that as a session ID.

00:31:35.460 --> 00:31:41.440
And you may also want to provide a custom
display name such as a gamer handle.

00:31:41.440 --> 00:31:45.080
And it's this display name that
we show in the list to other peers

00:31:45.079 --> 00:31:50.669
and that's how other peers will see you in the Peer Picker.

00:31:50.670 --> 00:31:56.240
So if you're just trying to get things up and running
or you don't really care about those two aspects,

00:31:56.240 --> 00:32:01.740
if you decide not to implement this delegate method,

00:32:01.740 --> 00:32:11.150
the Peer Picker will automatically create a default Game
Kit session for you to use to find peers and connect them.

00:32:11.150 --> 00:32:15.090
So what does this look like in code?

00:32:15.089 --> 00:32:18.730
There's a few ways you can do this.

00:32:18.730 --> 00:32:28.299
The real simple way is allocating a GKSession object,
setting your custom session ID, setting your display name

00:32:28.299 --> 00:32:34.450
and then we also, you can see here, set the
session mode to the peer mode and that's required

00:32:34.450 --> 00:32:36.920
for any session you provide the Peer Picker.

00:32:36.920 --> 00:32:43.259
And we provide the Peer Picker by returning it
and we auto release it just so we don't leak.

00:32:45.170 --> 00:32:54.980
So lastly, importantly, you'll need to be able to respond
to when the Peer Picker has connected to another peer.

00:32:54.980 --> 00:33:02.779
And you can do this by implementing the
peerPickerController:didConnectPeer:toSession

00:33:02.779 --> 00:33:03.980
delegate method.

00:33:03.980 --> 00:33:08.259
And there's a couple of things you need to do here.

00:33:08.259 --> 00:33:16.150
One is, if you haven't it already, you'll need to retain
a reference to the Game Kit session and that's basically

00:33:16.150 --> 00:33:22.420
so you can use it later to send data
back and forth in your multiplayer game.

00:33:22.420 --> 00:33:28.370
The other thing is that the Peer Picker does not
automatically dismiss when a peer is connected

00:33:28.369 --> 00:33:32.809
so you'll need to programmatically dismiss it and
you want to do it within this delegate method.

00:33:32.809 --> 00:33:36.079
So what will this look like?

00:33:36.079 --> 00:33:41.759
Here we are setting the session
to a property that retains it.

00:33:41.759 --> 00:33:51.150
And then down below we programmatically dismiss by calling
the dismiss method and then we release the Peer Picker

00:33:51.150 --> 00:33:56.740
as we're done with it and then basically
you start your multiplayer game.

00:33:56.740 --> 00:34:02.740
Now there's one more aspect I want to
talk about which is the relationship

00:34:02.740 --> 00:34:06.250
between the Peer Picker and the Game Kit session.

00:34:06.250 --> 00:34:14.110
Now the Peer Picker is there and it makes
it really easy to provide a user interface

00:34:14.110 --> 00:34:18.160
that finds and connects to other devices.

00:34:18.159 --> 00:34:26.369
So, but to do this you want to wait
to respond to any Session events

00:34:26.369 --> 00:34:33.159
until after the Peer Picker has told you
that it is connected to another peer.

00:34:33.159 --> 00:34:40.909
So this is a snippet from the previous slide and
focusing in on here is that after we retain a reference

00:34:40.909 --> 00:34:47.170
to the Game Kit session, we then set ourselves
as the delegate and set the data receive handler

00:34:47.170 --> 00:34:54.630
so we can start responding to Session events.

00:34:54.630 --> 00:35:03.210
So with that I invite you all to start playing around with
Game Kit, the Game Kit Peer Picker and the Game Kit session.

00:35:03.210 --> 00:35:10.320
And to help you do this we are providing some sample
code called GKTank and this is a simple two-player game

00:35:10.320 --> 00:35:17.260
that uses the Peer Picker for peer discovery and
connection and uses the Game Kit session to drive

00:35:17.260 --> 00:35:24.120
that multiplayer game, and this is
available on the attendee site for download.

00:35:24.119 --> 00:35:27.130
And with that I'd like to invite Roberto up on stage to talk

00:35:27.130 --> 00:35:31.760
to you how you can take your game to
the next level by adding voice chat.

00:35:32.789 --> 00:35:39.130
>> Hi my name is Roberto and I had the
pleasure of working on the GKVoiceChatService.

00:35:39.130 --> 00:35:42.030
Today we're going to tell you how you
can add voice chat to your application.

00:35:42.030 --> 00:35:46.890
Now some of you maybe thinking why add
voice chat, and the answer is simple.

00:35:46.889 --> 00:35:53.000
It's fun. Your customers are going to love it and we've
made it easy for you to add this to your application.

00:35:53.000 --> 00:35:58.699
So if you attended Allan's talk yesterday
you got a short preview, and if you haven't

00:35:58.699 --> 00:36:03.659
and you've never seen this API before, today you're
going to learn enough to go back and get started.

00:36:03.659 --> 00:36:11.349
And if you already have an application and you want
to know, well, is the voice chat service compatible

00:36:11.349 --> 00:36:15.339
with my existing code or my existing server infrastructure,

00:36:15.340 --> 00:36:19.860
after today's session you'll be
able to make an informed decision.

00:36:19.860 --> 00:36:27.059
And lastly, if you're anything like me and you need to see a
concrete example, we're presenting a working implementation

00:36:27.059 --> 00:36:33.019
of the voice chat service built right on top of an
existing piece of Bonjour sample code called WiTap voice.

00:36:33.019 --> 00:36:38.239
So let's dive right in.

00:36:38.239 --> 00:36:44.379
What exactly does your application get
when it uses the voice chat service?

00:36:44.380 --> 00:36:47.410
Well, you heard Joe mention this earlier but I'll reiterate.

00:36:47.409 --> 00:36:50.759
We're going to do all of the audio processing for you.

00:36:50.760 --> 00:36:55.080
We're going to pull from the mic, we're
going to encode, we're going to decode,

00:36:55.079 --> 00:37:01.659
and we're even going to do echo suppression
thanks to the voice processing audio unit.

00:37:01.659 --> 00:37:06.940
If you're not a real-time network
engineer you can breathe a sigh of relief.

00:37:06.940 --> 00:37:11.780
We're going to do the packetization, we're
going to do NAT traversal and we're even going

00:37:11.780 --> 00:37:16.410
to send and receive audio on our own socket.

00:37:16.409 --> 00:37:21.369
So, you've heard a lot about what
your application doesn't need to do

00:37:21.369 --> 00:37:26.299
and you're probably thinking well what do I need to do.

00:37:26.300 --> 00:37:28.030
Your application needs to do two things.

00:37:28.030 --> 00:37:32.610
The first thing is called the VoiceChatService methods.

00:37:32.610 --> 00:37:38.660
The second thing is implement the
GKVoiceChatClient protocol.

00:37:38.659 --> 00:37:42.420
The VoiceChatClient protocol does two things.

00:37:42.420 --> 00:37:49.059
The first thing is that it acts as a
delegate to the voice chat service.

00:37:49.059 --> 00:37:55.269
And the second thing, this is really the important
thing that it does and the thing that you'll need

00:37:55.269 --> 00:38:05.380
to pay attention to, is that it provides a mechanism for
the voice chat service to exchange a few control packets

00:38:05.380 --> 00:38:10.700
so that we can do our NAT traversal and
set up our own peer-to-peer connection.

00:38:13.949 --> 00:38:17.829
So how does your application use the voice chat service?

00:38:17.829 --> 00:38:25.739
Well if you want to send a voice chat invitation all
you have to do is call startVoiceChatWithParticipantID.

00:38:25.739 --> 00:38:28.049
Don't get hang up on what a participant ID is yet.

00:38:28.050 --> 00:38:31.410
We're going to cover that in great detail later.

00:38:32.469 --> 00:38:40.889
When your application receives a voice chat
invitation you should call acceptCallID or denyCallID.

00:38:40.889 --> 00:38:45.230
Don't worry about what a call ID
is, that's going to be passed to you

00:38:45.230 --> 00:38:50.460
when you receive the invitation and it's just an NSInteger.

00:38:50.460 --> 00:38:58.220
And lastly, you can tear down the call at any
point by calling stopVoiceChatWithParticipantID.

00:38:58.219 --> 00:39:06.329
So these methods were all designed with the
metaphor that should seem very familiar to you

00:39:06.329 --> 00:39:10.690
and that is placing a phone call on your iPhone.

00:39:10.690 --> 00:39:17.119
When you dial a number this is like
calling startVoiceChatWithParticipantID.

00:39:18.389 --> 00:39:25.969
When you receive a call you can either accept or decline
it and this is like calling acceptCallID or declineCallID.

00:39:25.969 --> 00:39:31.879
And lastly either party can press
the End Call button at any point.

00:39:31.880 --> 00:39:37.200
Likewise in the voice chat service API you
can call stopVoiceChatWithParticipantID.

00:39:37.199 --> 00:39:45.789
So how exactly is a voice chat set up, let's look at that.

00:39:45.789 --> 00:39:52.590
Earlier you heard me mention that your application is going
to provide a mechanism to exchange a few control packets.

00:39:52.590 --> 00:39:55.350
What does that look like?

00:39:55.349 --> 00:40:00.319
Well when your application call
startVoiceChat, the voice chat service is going

00:40:00.320 --> 00:40:03.590
to create what we'll call an invite packet.

00:40:03.590 --> 00:40:09.070
From your applications perspective this
is really just an opaque data blob.

00:40:09.070 --> 00:40:17.059
The voice chat service is going to pass the
voice chat invite up to the application.

00:40:17.059 --> 00:40:23.190
>> The application is going to forward it across
your application's existing infrastructure

00:40:23.190 --> 00:40:31.269
and the remote instance of your application is going to pass
it down to the remote instance of the voice chat service.

00:40:31.269 --> 00:40:35.719
Should you accept the call or should
your user accept the call

00:40:35.719 --> 00:40:43.199
The voice chat service is going to create an
appropriate reply and repeat the process in reverse.

00:40:43.199 --> 00:40:47.259
So this is what I mean by exchange packets.

00:40:47.260 --> 00:40:56.220
So now that these packets have been exchanged,
the voice chat service, each instance of it,

00:40:56.219 --> 00:41:04.009
has enough information to do NAT traversal and set up its
own peer-to-peer audio connection using its own socket.

00:41:04.010 --> 00:41:11.610
[ Pause ]

00:41:11.610 --> 00:41:19.130
>> So the key takeaway is that your application
will be providing a mechanism or a channel

00:41:19.130 --> 00:41:27.090
that the voice chat service can use to exchange
these control packets and you'll provide this channel

00:41:27.090 --> 00:41:30.960
by implementing the VoiceChatClient protocol.

00:41:33.679 --> 00:41:38.379
So it has two methods, two required methods.

00:41:38.380 --> 00:41:44.460
The first is named participantID and it returns an NSString.

00:41:44.460 --> 00:41:47.269
For now you can think of this as how other instances

00:41:47.269 --> 00:41:50.809
of your application will address the
local instance of your application.

00:41:50.809 --> 00:41:57.759
The next method is
voiceChatService:sendData:toParticipantID.

00:41:57.760 --> 00:42:05.200
This is the method that the voice chat service is going to
call when it wants to send one of these control packets.

00:42:05.199 --> 00:42:08.929
And lastly although this isn't part of the protocol,

00:42:08.929 --> 00:42:14.779
it's implied that when you receive a voice chat service
packet you'll pass it down to the voice chat service later

00:42:14.780 --> 00:42:21.550
and you'll do that by calling the
receivedData:fromParticipantID of voice chat service method.

00:42:21.550 --> 00:42:24.730
So let's address each one of these respectively.

00:42:26.570 --> 00:42:34.820
ParticipantID, this is a string that
only has meaning to your application,

00:42:34.820 --> 00:42:42.059
the voice chat service doesn't know anything about
this and it's going to depend greatly on the service

00:42:42.059 --> 00:42:45.289
that your application uses to communicate.

00:42:45.289 --> 00:42:53.029
For instance, hypothetically, if you are running
a name client you would return the screen name

00:42:53.030 --> 00:42:57.210
for your participantID because this is how
the other name clients would address you

00:42:57.210 --> 00:43:00.659
when they wanted to send you a message.

00:43:00.659 --> 00:43:06.690
If you were going to run the GKSession
you would return your peer ID

00:43:06.690 --> 00:43:11.740
because that's how other remote
GKSessions refer to your local GKSessions.

00:43:11.739 --> 00:43:20.659
For the next few slides I'm going to present an example
and that is my name is Bob and I'm running a client

00:43:20.659 --> 00:43:29.250
or an application on the iPhone on the
new fooim.org instant messenger service.

00:43:29.250 --> 00:43:31.590
Well what participantID would I return?

00:43:31.590 --> 00:43:40.120
It would be bob@fooim.org and that's because that's
how the other fooim.org clients would address me

00:43:40.119 --> 00:43:46.230
when they sent Bob a message.

00:43:46.230 --> 00:43:50.059
So voiceChatService:sendData:toParticipantID.

00:43:50.059 --> 00:43:57.250
This is the method that the voice chat service is going to
call when it wants to send one of these control packets.

00:43:57.250 --> 00:44:02.760
If you were to take a peek inside of
the voice chat service implementation,

00:44:02.760 --> 00:44:08.570
the codes that you see above would be
representative of a call to this method.

00:44:08.570 --> 00:44:14.110
The first parameter pass would be self since
the voice chat service is calling this method.

00:44:14.110 --> 00:44:18.039
The second parameter would be this opaque data blob,

00:44:18.039 --> 00:44:23.650
and the last parameter would be the destination
participantID or where the blob is going.

00:44:23.650 --> 00:44:25.619
In this case Bob is trying to start a voice chat with Alice

00:44:25.619 --> 00:44:30.940
so the voice chat service is sending
Alice a voice chat invitation.

00:44:30.940 --> 00:44:35.320
So that's what a call to this method looks like.

00:44:35.320 --> 00:44:39.630
What will your implementation look like?

00:44:39.630 --> 00:44:44.119
Your implementation will wrap the
voice chat service packet in such a way

00:44:44.119 --> 00:44:49.009
that they can be distinguished
from native application packets.

00:44:49.010 --> 00:44:57.840
By that I mean you should encapsulate the voice chat
service packet inside one of your native application packets

00:44:57.840 --> 00:45:02.980
and give it a type identifier, so that
when it's received by the remote instance

00:45:02.980 --> 00:45:09.019
of your application it can be distinguished,
it can be distinguished and unpacked

00:45:09.019 --> 00:45:11.320
and passed back down to the voice chat service layer.

00:45:11.320 --> 00:45:20.180
And your application will do that by calling
the receivedData:fromParticipantID method.

00:45:20.179 --> 00:45:25.839
So an example call of how your client will
call that method, you can see that above,

00:45:25.840 --> 00:45:32.110
the first parameter will be this opaque data blob, and
the second parameter would be where you got the blob from.

00:45:32.110 --> 00:45:36.140
Now this is up to your application so
you know where you got the message from

00:45:36.139 --> 00:45:38.400
and all you're doing is you're
telling the voice chat service later.

00:45:38.400 --> 00:45:47.050
In this case Alice's fooim.org client knows
that she received the message from Bob.

00:45:47.050 --> 00:45:52.720
So you've seen all of the relevant methods in
the voice chat service and the voice chat client.

00:45:52.719 --> 00:45:57.179
And I gave you a sort of a high level graph
of what the voice chat setup looks like.

00:45:57.179 --> 00:46:04.119
Now let's go fill in some of those gaps
and see a more detailed explanation.

00:46:04.119 --> 00:46:09.489
So Bob is going to want to start a voice chat with Alice.

00:46:09.489 --> 00:46:13.750
So he calls startVoiceChatWithParticipantID.

00:46:13.750 --> 00:46:19.940
The voice chat service will then create an invite packet.

00:46:19.940 --> 00:46:27.789
It will pass the invite packet up to the voice
chat client by calling sendData:toParticipantID

00:46:27.789 --> 00:46:31.420
where the participantID in this case is alice@fooim.org.

00:46:31.420 --> 00:46:37.820
The voice chat client will then wrap the packet
so that it looks like a native application packet

00:46:37.820 --> 00:46:43.390
and forward it across the fooim.org server.

00:46:43.389 --> 00:46:48.900
When Alice's application receives the packet it will
distinguish it first of all as a voice chat packet

00:46:48.900 --> 00:46:53.630
and pass it back down to voice chat service later.

00:46:53.630 --> 00:46:59.539
Remember, this is completely opaque to your application
so you don't need to worry about what the packet contains.

00:46:59.539 --> 00:47:08.809
So the voice chat service knows that it's an
invitation so it will tell Alice's client.

00:47:08.809 --> 00:47:13.989
Alice, yeah she is kind of fond of
Bob so she decides to accept the call.

00:47:13.989 --> 00:47:25.889
The voice chat service then will create an appropriate
reply and the process will be repeated in reverse.

00:47:25.889 --> 00:47:31.989
Now, both instances of the voice
chat service have enough information

00:47:31.989 --> 00:47:36.679
to do NAT traversal and set up a peer-to-peer audio channel.

00:47:36.679 --> 00:47:41.649
So this isn't a metaphorical dotted line.

00:47:41.650 --> 00:47:45.430
The voice chat service packets
will be running over on socket

00:47:45.429 --> 00:47:51.299
and both applications will be informed
that they started a voice chat.

00:47:51.300 --> 00:47:57.560
So you've seen all the methods for both the
voice chat client and the voice chat service,

00:47:57.559 --> 00:48:01.940
and now you've seen a detailed call flow setup

00:48:01.940 --> 00:48:04.550
Let's put it into practice.

00:48:04.550 --> 00:48:08.200
We'll do that by showing you the WiTap example.

00:48:08.199 --> 00:48:13.539
WiTap is the simplest game that Apple
ships and it's built right on top

00:48:13.539 --> 00:48:18.090
of Bonjour and we're going to add voice chat today.

00:48:18.090 --> 00:48:23.220
So what is WiTap, how does that work?

00:48:23.219 --> 00:48:29.469
It starts off by showing you a table where
each entry of the table is an instance

00:48:29.469 --> 00:48:33.619
of the WiTap application being advertised over Bonjour.

00:48:33.619 --> 00:48:40.539
When a user clicks on an entry in the table a
TCP connection is created between the instances

00:48:40.539 --> 00:48:44.610
of the application and the game is started.

00:48:44.610 --> 00:48:54.120
When one user clicks on the square the square is highlighted
and the same square is highlighted on the reverse side.

00:48:55.489 --> 00:48:58.529
So now we're going to dive into how you add voice chat.

00:48:58.530 --> 00:49:03.510
So the first thing you do is you want to initialize
the voice chat client or voice chat service.

00:49:03.510 --> 00:49:06.340
You do that by first calling defaultVoiceChatService.

00:49:06.340 --> 00:49:07.240
So this is a singleton.

00:49:07.239 --> 00:49:10.189
You're going to get the one instance
of the voice chat service.

00:49:10.190 --> 00:49:13.130
Once you have that you can set the client.

00:49:13.130 --> 00:49:16.660
In this case it's going to be self because
the voice chat client is implemented--

00:49:16.659 --> 00:49:19.750
voice chat client protocol is going to
be implemented by the app controller.

00:49:19.750 --> 00:49:27.000
And lastly, and this is really important, we're not going to
show it today but you'll set up an audio session and this is

00:49:27.000 --> 00:49:34.869
so that the voice chat service audio will integrate well
with the audio session audio or with your in-game audio.

00:49:34.869 --> 00:49:43.880
The sample code will have this so when you leave the
session and you want to use this, go back and look at it.

00:49:43.880 --> 00:49:48.349
So to add voice chat to your application you need

00:49:48.349 --> 00:49:54.049
to implement the voice chat client
protocol, and remember there are two methods.

00:49:54.050 --> 00:49:56.130
The first is participantID.

00:49:56.130 --> 00:50:03.769
In this case since we're running on top of Bonjour,
we're going to return the local service instance name,

00:50:03.769 --> 00:50:06.989
because this is how the other services,

00:50:06.989 --> 00:50:13.699
the other applications can resolve the local
instance of my application or the local service.

00:50:16.090 --> 00:50:23.670
>> For the send data method we're going to just go ahead
and call a convenience method called voiceChatSend.

00:50:23.670 --> 00:50:30.769
Now you'll see that we're performing the selector on
main thread and the reason for that is we don't want

00:50:30.769 --> 00:50:33.690
to end or leave rights to the TCP string.

00:50:33.690 --> 00:50:41.050
This will provide some thread safety because the
other right is also happening on the main thread.

00:50:41.050 --> 00:50:45.769
So before we dive into how voiceChatSend
is implemented now let's go back

00:50:45.769 --> 00:50:50.429
and look at how it currently is implemented
in the original WiTap source code.

00:50:50.429 --> 00:50:53.889
So this is-- the code you'll see today
will be a slight simplification just

00:50:53.889 --> 00:50:57.059
for brevity's sake and to fit everything on one slide.

00:50:57.059 --> 00:51:01.730
But you'll see there's a variable name
outStream and this is an NSoutputStream

00:51:01.730 --> 00:51:05.059
which is an abstruction over the TCP string.

00:51:05.059 --> 00:51:11.340
And all you do when you want to send which
square is being highlighted as you send one by--

00:51:11.340 --> 00:51:19.010
and that tells the remote instance everything it
needs to know to highlight or unhighlight a square.

00:51:19.010 --> 00:51:23.690
Well earlier I mentioned that you'll need
to wrap the voice chat service packets.

00:51:23.690 --> 00:51:28.860
What that also means is that if you don't wrap
your packets currently you'll need to do so.

00:51:28.860 --> 00:51:36.030
So we've added a WiTap message
header, a very simple network header.

00:51:36.030 --> 00:51:45.400
All it does is it contains a length and this is the length
of the message not including the header and the type.

00:51:45.400 --> 00:51:49.519
In this case we're sending a WiTap packet
type so we're letting the other instance

00:51:49.519 --> 00:51:52.829
of the WiTap application know we're
sending it a screen update.

00:51:52.829 --> 00:51:59.519
We then write the message header and write the byte.

00:52:00.849 --> 00:52:07.250
So voice chats then will look very similar
to this, the difference being instead

00:52:07.250 --> 00:52:11.369
of a WiTap packet type we're going
to send a voice packet type.

00:52:11.369 --> 00:52:15.920
And instead of sending the 1 byte
we're going to send the data blob.

00:52:15.920 --> 00:52:19.519
So that's sent.

00:52:19.519 --> 00:52:27.579
So now we have implemented the two required
methods, participantID and sendData.

00:52:27.579 --> 00:52:31.909
So the last implied method, so this isn't in the
protocol, this isn't the voice chat client protocol,

00:52:31.909 --> 00:52:34.829
it's a voice chat service method,
it's that you need to be able to pass

00:52:34.829 --> 00:52:38.239
to receive voice chat service packets
down to the voice chat service later.

00:52:38.239 --> 00:52:42.029
So let's look at the current implementation of WiTap.

00:52:42.030 --> 00:52:51.210
All it does is that when it receives the stream delegate
event it's going to use the inStream which is an abstraction

00:52:51.210 --> 00:52:56.710
over the input side of the TCP stream and
it's an NSinputStream to read the 1 byte.

00:52:56.710 --> 00:53:03.519
But now you're receiving more than 1 byte, you're
receiving a header and whatever the message is.

00:53:03.519 --> 00:53:07.480
So the first thing we'll do is
we'll read the WiTap message header.

00:53:07.480 --> 00:53:12.240
After we've done that and of course you
can see I put it back in the host by order

00:53:12.239 --> 00:53:23.419
so this is also good network practice, I can receive
the rest of the message, so if it's a WiTap--

00:53:23.420 --> 00:53:29.860
so we'll check the Witap message header type and if it's
a voice packet type we'll create an instance of an NSData

00:53:29.860 --> 00:53:36.940
and pass it out down to the voice chat service
later by calling receiveData:fromParticipantID

00:53:36.940 --> 00:53:40.050
and the participantID is going to be the remoteInstanceName

00:53:40.050 --> 00:53:43.610
because that's how our local instance
resolves the remote instance.

00:53:43.610 --> 00:53:51.340
All right, so that was the meat of it, this is very simple.

00:53:51.340 --> 00:53:58.230
So just to handle the initial calls that
your API will make, so to start a voice chat,

00:53:58.230 --> 00:54:03.179
if you haven't already started the voice chat, call
it and this will happen whenever the TCP stream opens

00:54:03.179 --> 00:54:06.099
so that way you have a way of sending the data blobs.

00:54:06.099 --> 00:54:12.130
So the first-- so it's just voice chat service
startVoiceChatWithParticipantID where the participantID

00:54:12.130 --> 00:54:16.809
of the person that you want to talk to or the application
you want to talk to is remoteInstanceName once again.

00:54:16.809 --> 00:54:22.039
And of course if the voice chat succeeds,
what you want to do is update your UI

00:54:22.039 --> 00:54:24.409
and this will depend on your application.

00:54:24.409 --> 00:54:28.500
And if it doesn't you should look at
the error and this will be very helpful

00:54:28.500 --> 00:54:33.219
when you're trying to get this set up and debugged.

00:54:33.219 --> 00:54:39.849
And accepting the chat, all you have to do is implement
the optional method so you don't have to implement this.

00:54:39.849 --> 00:54:43.900
It would be a good idea if you want to know
if you have a voice chat invitation though.

00:54:43.900 --> 00:54:49.039
And that is the voiceChatService
didReceiveInvitationFromParticipantID.

00:54:49.039 --> 00:54:54.309
So normally you probably want to-- well
depending again, once again on your application.

00:54:54.309 --> 00:55:00.409
You want to inform the user, hey, you got a voice chat
and they can decide if they want to accept or decline it.

00:55:00.409 --> 00:55:03.859
Now depending on your game, you might not want to do that.

00:55:03.860 --> 00:55:12.110
In any case you want to call if you want to accept the chat
VoiceChatService acceptCallID and you notice that the callID

00:55:12.110 --> 00:55:14.599
that I used is the one pass sensitive method.

00:55:14.599 --> 00:55:26.829
And if the voice chat fails, once again, you need to
inspect the error or if it succeeds, update your UI.

00:55:27.849 --> 00:55:29.969
So what's missing from this code?

00:55:29.969 --> 00:55:38.859
So a very important piece is working with the AudioSession
to handle interrupts because when you receive a phone call

00:55:38.860 --> 00:55:45.910
and your user comes back to it, to your application,
you want to handle that as smoothly as possible.

00:55:45.909 --> 00:55:51.519
So in the sample code that you'll get with the
WiTap voice sample app will show you how to do that.

00:55:52.530 --> 00:56:00.240
The other thing you want to do is you want to ensure that
the resources that you're playing in your game are going

00:56:00.239 --> 00:56:04.279
to integrate well with the voice
chat data or the voice chat audio.

00:56:04.280 --> 00:56:09.240
We'll also show you how to do that.

00:56:09.239 --> 00:56:15.239
And lastly the code I showed you for the receive bit
of this was a tad simplified again for brevity's sake,

00:56:15.239 --> 00:56:20.529
the spirit is there, but we'll show you how to be a
good non-blocking citizen so you don't want to hang

00:56:20.530 --> 00:56:25.630
up your main thread, you want to be able
to receive each asynchronous call in turn.

00:56:25.630 --> 00:56:30.950
And so again, once again the sample
code will have all of this.

00:56:30.949 --> 00:56:39.919
And lastly the recap, so the big thing you need to know
is that once you implement the voice chat client protocol

00:56:39.920 --> 00:56:44.769
which once again provides a mechanism just to exchange
these packets, we're going to do everything else

00:56:44.769 --> 00:56:48.860
for you and it's going to be a lot of fun.

00:56:48.860 --> 00:56:49.990
Go ahead and implement it.

00:56:49.989 --> 00:56:51.769
And with that I'll hand it to Joe.

00:56:51.769 --> 00:56:53.139
>> Thank you Roberto.

00:56:53.139 --> 00:57:05.289
So I hope that you've learn from us the capabilities of
Game Kit and how you may use Game Kit in the application

00:57:05.289 --> 00:57:10.130
that you write or any existing
application that you already have.

00:57:10.130 --> 00:57:15.940
When I spoke I talked to you about the GKSession
and the key point there that I want to point out is

00:57:15.940 --> 00:57:21.920
that there is essentially only three stages that you
need to follow to use GKSession in your application.

00:57:21.920 --> 00:57:29.970
Now note that GKSession doesn't have any UI to help
you with this, however, from Jonathan you learned

00:57:29.969 --> 00:57:36.399
about the Peer Picker and it's really easy
to get things connected with the Peer Picker.

00:57:36.400 --> 00:57:39.910
You initialize it then you basically
show it and then as long

00:57:39.909 --> 00:57:43.779
as you're handling the correct delegate
methods, everything will be taken care for you.

00:57:43.780 --> 00:57:50.810
And then most recently you just heard
from Roberto about the voice chat service

00:57:50.809 --> 00:57:55.400
and how it itself should be very easy for you to implement.

00:57:55.400 --> 00:58:00.650
Now to review, there are some sample code available for you.

00:58:00.650 --> 00:58:05.639
There is the GKTank sample that illustrates
how to use the Peer Picker and Session

00:58:05.639 --> 00:58:11.109
and then there is the WiTap voice
sample which shows a modified version

00:58:11.110 --> 00:58:16.559
of the WiTap sample but now with voice chat.

00:58:17.710 --> 00:58:25.289
Now if you want any other additional information
please contact our Evangelist Allan Schaffer.

00:58:25.289 --> 00:58:27.369
His email is here on the slide.
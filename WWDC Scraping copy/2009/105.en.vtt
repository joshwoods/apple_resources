WEBVTT

00:00:13.929 --> 00:00:16.429
>> Good afternoon, my name is Andrew Platzer.

00:00:16.429 --> 00:00:23.039
I'm a Senior Engineer on the UIKit Framework, Cocoa Touch, and
today I'll be talking about cut, copy, paste on the iPhone.

00:00:23.039 --> 00:00:25.259
It's a bit more than just cut, copy, paste.

00:00:25.260 --> 00:00:28.310
We'll be talking about editing and
sharing your data on the phone.

00:00:28.309 --> 00:00:31.309
This involves presenting the edit
control so these are canned cut, copy,

00:00:31.309 --> 00:00:36.969
paste to specify which actions are available so
maybe sometimes they can cut, sometimes they can't.

00:00:36.969 --> 00:00:42.030
We'll talk about the pasteboard and how to share your data
with, between your application and other applications.

00:00:42.030 --> 00:00:44.609
And finally, we'll talk about the undo manager.

00:00:44.609 --> 00:00:49.579
How to add the undo to your application so
the user can easily correct their mistakes.

00:00:49.579 --> 00:00:52.799
For this, we'll talk about four new features.

00:00:52.799 --> 00:00:54.209
We'll talk about the menu controller.

00:00:54.210 --> 00:01:00.689
This is a singled instance, sense of a class
that you can use to present the cut, copy, paste menu.

00:01:00.689 --> 00:01:02.719
We'll talk about the responder chain.

00:01:02.719 --> 00:01:10.150
This was already partially used in previous releases, but
now it's got more importance with the menu controller.

00:01:10.150 --> 00:01:15.950
We'll talk about the new Pasteboard API and then we'll
finally talk about the addition of the undo manager.

00:01:15.950 --> 00:01:19.570
For those of you who use Mac OS X,
this is the exact same undo manager.

00:01:19.569 --> 00:01:23.919
So first with the menu controller.

00:01:23.920 --> 00:01:31.689
The menu controller presents a way of access to
presenting the menu, a cut, copy, paste menu.

00:01:31.689 --> 00:01:37.700
It allows you to, it presents a sort of single shared
instance so that you don't need to create your own

00:01:37.700 --> 00:01:40.689
or you don't need to worry about
the window or anything like that.

00:01:40.689 --> 00:01:42.079
You just talk to it.

00:01:42.079 --> 00:01:46.870
It lets you position and show or hide the control
as necessary depending on what the user actions are.

00:01:46.870 --> 00:01:50.120
And finally, it lets you specify which items are enabled.

00:01:50.120 --> 00:01:53.530
So only cut or only copy or only select for example.

00:01:53.530 --> 00:01:57.000
To show the menu, you just want to use one call.

00:01:57.000 --> 00:01:58.569
Set menu visible animated.

00:01:58.569 --> 00:02:03.059
You'll just say set menu yes animated
yes and then the menu will fade in

00:02:03.060 --> 00:02:05.930
and you'll want to trigger the certain user action.

00:02:05.930 --> 00:02:09.189
If you look at for example in text
view, it's a press and hold gesture.

00:02:09.189 --> 00:02:15.859
And you'll want to try to do something similar so
the user knows they can do it at a certain time.

00:02:15.860 --> 00:02:20.260
To position a menu, you'll call on a
function called set target erect and view.

00:02:20.259 --> 00:02:22.139
And you pass in the target rectangle.

00:02:22.139 --> 00:02:27.219
This is sort of the area where there's a
selection or it might just be the view bounds.

00:02:27.219 --> 00:02:29.900
This target rectangle can be zero width or height.

00:02:29.900 --> 00:02:35.099
So it can just be a point specifying the origin or it
can be like a vertical insertion mark or something.

00:02:35.099 --> 00:02:40.859
And the menu will be automatically positioned above
or below that bounds so it's always on screen.

00:02:40.860 --> 00:02:45.310
One thing to notice that the target
rectangle you pass in, though it's in a view,

00:02:45.310 --> 00:02:47.629
it's actually converted to screen coordinates.

00:02:47.629 --> 00:02:51.539
So you don't, it doesn't actually
track the change in the view location.

00:02:51.539 --> 00:02:57.620
If the view scrolls programmatically, you're going
to have to call this function again, even while the,

00:02:57.620 --> 00:03:02.879
the controller is visible in order
to position it into the new location.

00:03:02.879 --> 00:03:07.849
And so here's an example of how we might
show the menu controller and show the menu.

00:03:07.849 --> 00:03:13.780
Here's an example, we will press and hold so
we'll just check to see that touch has began.

00:03:13.780 --> 00:03:17.000
Time, we remember, is now, enough time has passed.

00:03:17.000 --> 00:03:19.969
We'll show the, we want to show the menu.

00:03:19.969 --> 00:03:22.669
We'll ask for the shared menu controller.

00:03:22.669 --> 00:03:25.149
You don't need to create it, just ask for it.

00:03:25.150 --> 00:03:26.200
Then we'll just set the target [inaudible].

00:03:26.199 --> 00:03:28.219
In this case, it will be the views bounds.

00:03:28.219 --> 00:03:33.159
So anywhere around that view above or
below it will show that we're possible.

00:03:33.159 --> 00:03:37.150
And finally, we just say set menu visible
yes, animated yes, and the menu will fade in.

00:03:37.150 --> 00:03:41.539
In order to hide the menu you could just do the reverse.

00:03:41.539 --> 00:03:49.859
It's automatically hidden for you so when these are
touches in another view, or when an alert comes up,

00:03:49.860 --> 00:03:55.920
an action sheet comes up, or when a system alert comes
up like you've got a phone call and the app deactivates,

00:03:55.919 --> 00:03:58.969
we'll automatically hide it for you
so you don't need to do anything.

00:03:58.969 --> 00:04:02.560
It'll also hide when you actually select the command.

00:04:02.560 --> 00:04:05.890
You can hide explicitly using set many visible animated

00:04:05.889 --> 00:04:08.649
or just set the [inaudible] property,
which will instantly hide.

00:04:08.650 --> 00:04:13.700
For example, view is instantly removed, you'll want to
also take away the controller right away instead of waiting

00:04:13.699 --> 00:04:17.219
to fade it out because your interface no longer is showing.

00:04:17.220 --> 00:04:19.160
It needs to show it.

00:04:19.160 --> 00:04:26.550
And if you have any inter, any feedback or some kind of
you know, selection rectangle or whatever that depends

00:04:26.550 --> 00:04:30.090
on the menu controller, the menu
controller's menu being visible.

00:04:30.089 --> 00:04:33.769
You'll want to listen for UI menu
controller will hide menu notification.

00:04:33.769 --> 00:04:41.000
And this is sent whenever that menu bar is hidden
and you can change your interface as necessary.

00:04:41.000 --> 00:04:46.410
If you don't care, then you don't need
to listen to it and it'll just go away.

00:04:46.410 --> 00:04:51.730
The menu interface is automatically localized,
so depending on the language the user has chosen,

00:04:51.730 --> 00:04:57.120
they will get the appropriate text
and the items for that language.

00:04:57.120 --> 00:04:59.620
But, it is not customizable.

00:04:59.620 --> 00:05:02.209
This means that the item names are fixed.

00:05:02.209 --> 00:05:07.180
You cannot change cut to something else and you cannot
change select all of something else or whatever.

00:05:07.180 --> 00:05:09.660
Currently, you cannot add any items.

00:05:09.660 --> 00:05:14.710
That's it, you've got cut, copy, paste,
select, select all, you can't add any more.

00:05:14.709 --> 00:05:17.589
And finally, please don't even
try, I know some of you like to...

00:05:17.589 --> 00:05:18.799
[ Laughter ]

00:05:18.800 --> 00:05:19.819
...push the boundaries.

00:05:19.819 --> 00:05:22.730
But you will break it in the future, I assure you.

00:05:22.730 --> 00:05:27.080
We've already seen this in other cases, so please don't.

00:05:27.079 --> 00:05:33.199
Now that I've shown you how you can present the menu,
how you can show it, I want to talk a little bit

00:05:33.199 --> 00:05:37.250
about responders because this is used to
determine which actions are actually available,

00:05:37.250 --> 00:05:41.699
which actions will be presented to the
users when the menu control shows up.

00:05:41.699 --> 00:05:47.379
In previous releases, we did have responders, you may
have seen UI responder, but they weren't really used.

00:05:47.379 --> 00:05:48.980
They were used for a couple of things only.

00:05:48.980 --> 00:05:57.030
Just touches, when you touched in a view, you might not want
to handle it, so you'd want to let it go up the view chain

00:05:57.029 --> 00:06:03.709
and this is actually done going up the responder chain,
which for view, this is parallel to the view hierarchy.

00:06:03.709 --> 00:06:09.479
There is a UI application property called
key window, but it wasn't really used.

00:06:09.480 --> 00:06:15.379
But you may have seen calls in the sample code
or your code that calls make visible in Key.

00:06:15.379 --> 00:06:18.810
And UI text fields and text views
would become first responder,

00:06:18.810 --> 00:06:22.530
and I will talk about that, but no one really cares.

00:06:22.529 --> 00:06:30.439
So for example here in 2.0, 2.21, whatever you! know,
sees or touches in a view and that just gets called

00:06:30.439 --> 00:06:33.529
up the responder chain, the view chain to the next view.

00:06:33.529 --> 00:06:37.839
Or maybe the text field becomes
first responder, that was about it.

00:06:37.839 --> 00:06:42.959
And three, the responder chain is now much more important.

00:06:42.959 --> 00:06:48.699
The UI window has a key window property, read
only, which will tell you if it's key window.

00:06:48.699 --> 00:06:51.430
You do need to call, make visible in key if you want

00:06:51.430 --> 00:06:56.360
to make sure you're the key window as
far as the application is concerned.

00:06:56.360 --> 00:07:02.410
And this responder chain is now used for what we
call menu item validation or just to indicate,

00:07:02.410 --> 00:07:05.200
Yes this action is available, or No, it's not.

00:07:05.199 --> 00:07:13.199
So if you're going to use the menu, you're going to
have to be a bit more key window and responder aware

00:07:13.199 --> 00:07:16.810
so that you're going to have to know when
you're the first responder and when you're not.

00:07:16.810 --> 00:07:20.730
Or if you're using multiple windows, when
you're the key window or when you're not.

00:07:20.730 --> 00:07:23.160
For most of you, you know, you'll have the one window

00:07:23.160 --> 00:07:26.820
and your interface is automatically key
window if you've called make visible in key.

00:07:26.819 --> 00:07:30.079
You don't need to do anything at least
as far as the key window is concerned.

00:07:30.079 --> 00:07:38.039
So for example, here, one additional thing, we now
have, I was going to say, we have view controllers,

00:07:38.040 --> 00:07:39.830
they're actually part of the responder chain.

00:07:39.829 --> 00:07:45.819
So even though they are not part of the view hierarchy,
they actually do participate in the responder chain.

00:07:45.819 --> 00:07:52.040
And by default, the view controller's
next responder is its view's super view.

00:07:52.040 --> 00:07:56.900
So both the view and the view controller are
associated-- would point to that super view.

00:07:56.899 --> 00:08:01.529
So now, when you click on a text field it
becomes first responder, we really are interested

00:08:01.529 --> 00:08:04.519
in a bit more information than we were before.

00:08:04.519 --> 00:08:07.859
The application is a key window, it'll
point to that particular key window.

00:08:07.860 --> 00:08:11.500
That won't change when you click in that text
field so you'll need to set it explicitly.

00:08:11.500 --> 00:08:16.639
And then the text field of course will
become what's called a first responder.

00:08:16.639 --> 00:08:21.519
On the other hand, maybe at some point programmatically,
you want the view controller to be a first responder.

00:08:21.519 --> 00:08:22.829
And I'll explain why you want to do that.

00:08:22.829 --> 00:08:28.349
And in this case, now we have a direct link
from the window to that first responder.

00:08:28.350 --> 00:08:33.670
And then we can follow the link backwards all the way down,
all the way up the responder chain to the application.

00:08:33.669 --> 00:08:40.199
I was going to say, see here UI window's next responder
is actually just the application and that's the root.

00:08:40.200 --> 00:08:44.700
UI application's next responder is nil.

00:08:44.700 --> 00:08:50.310
So in order to be in the responder chain, you have to
be subclass of UI responder, UI view, UI view controller

00:08:50.309 --> 00:08:54.919
and UI application are subclasses of next, UI responder,

00:08:54.919 --> 00:08:58.709
which is sort of the base class
for most of the interface classes.

00:08:58.710 --> 00:09:00.690
These are chains, as I said, using the next responder.

00:09:00.690 --> 00:09:05.410
That's a read only property by default
views, next responder is its super view

00:09:05.409 --> 00:09:08.610
and so view controllers, this is
views, super view and so on.

00:09:08.610 --> 00:09:12.379
You can override that by subclassing
and returning something different.

00:09:12.379 --> 00:09:14.419
But in general, you probably don't want to.

00:09:14.419 --> 00:09:18.229
If you wanted to have a custom responder
class inserted somewhere you could,

00:09:18.230 --> 00:09:20.690
not something you'd probably want to do often.

00:09:20.690 --> 00:09:27.170
And as I said before, each window has a first responder, so
if you're going to switch windows, be aware that, you know,

00:09:27.169 --> 00:09:31.929
when the view is only the first responder in its window

00:09:31.929 --> 00:09:34.979
and each window will remember it
even if it isn't the key window.

00:09:34.980 --> 00:09:42.090
So to become first responder, you'll need to
subclass one of the existing classes by default--

00:09:42.090 --> 00:09:49.490
can become first responder returns No, and in order
to become first responder you'll have to return Yes.

00:09:49.490 --> 00:09:53.750
Once you do return yes for this, whenever you want

00:09:53.750 --> 00:09:57.480
to become first responder just call
the function to become first responder.

00:09:57.480 --> 00:10:03.170
That will over, go up the responder chain and
tell the window you are now the first responder.

00:10:03.169 --> 00:10:09.099
If you have a need to kind of feedback to show like
a selection or that you're the active editing area,

00:10:09.100 --> 00:10:14.690
that you are as the first responder, you'll want to override
to become first responder or resign first responder in order

00:10:14.690 --> 00:10:18.320
to display that in, to display that interface.

00:10:18.320 --> 00:10:24.430
If you just want to become first responder and have
no visual, you don't need to do anything as long

00:10:24.429 --> 00:10:30.509
as can become first responder returns yes, the
window will know you're the first responder.

00:10:30.509 --> 00:10:36.659
And one thing to really note is your first
responder must be in the window hierarchy because,

00:10:36.659 --> 00:10:40.079
so the only one that knows about
the first responder is the window.

00:10:40.080 --> 00:10:44.009
So if you call it too early at the
wrong time, it'll just be ignored.

00:10:44.009 --> 00:10:48.230
And I'll show you where you would call that
for example the view or the view controller.

00:10:48.230 --> 00:10:52.670
So here's a sample of how a custom
subview, a custom class subview

00:10:52.669 --> 00:10:57.509
which returns can become first responder
will, will become first responder.

00:10:57.509 --> 00:11:04.319
And again, here, we just see if the touch ended
inside the view itself and touches did end.

00:11:04.320 --> 00:11:07.670
The touch ended and just called self first responder.

00:11:07.669 --> 00:11:12.169
So at this point you know you're getting the touches, it
means you're part of the view hierarchy, you can do this.

00:11:12.169 --> 00:11:17.899
For view controllers this is even simpler, just
in view did appear call become first responder.

00:11:17.899 --> 00:11:22.139
At this point in view did appear, the
view is now part of the hierarchy,

00:11:22.139 --> 00:11:24.189
you'll tell the window I'm now the first responder.

00:11:24.190 --> 00:11:28.790
Don't do it in view did load, view will load, the
view will appear because at these times your view,

00:11:28.789 --> 00:11:32.740
which your controller points to
will not be part of the window

00:11:32.740 --> 00:11:37.370
and your becomes first responder
will become a new operation.

00:11:37.370 --> 00:11:43.429
So if your custom view or custom view controller
does become a first responder, you'll want,

00:11:43.429 --> 00:11:47.120
you'll want to be aware of when that happens.

00:11:47.120 --> 00:11:51.129
Text field and text view automatically
become first responder on touches.

00:11:51.129 --> 00:11:56.299
So if you, if you set your own view to be first
responder but you've got a text field inside there,

00:11:56.299 --> 00:11:58.679
and the user clicks on it they will become first responder.

00:11:58.679 --> 00:12:06.739
You want to listen then in that case for either
text field or text view delegate notifications,

00:12:06.740 --> 00:12:11.330
the text fielded an editing call or the
text fielded and editing notification.

00:12:11.330 --> 00:12:15.120
Those are your signal that you can
now set a responder back to your view

00:12:15.120 --> 00:12:17.330
or to some other view or to some other view or whatever.

00:12:17.330 --> 00:12:22.280
We don't automatically save what was the
previous first responder and then swap it back.

00:12:22.279 --> 00:12:27.019
We just, you know, we'll just reset it to nil effectively.

00:12:27.019 --> 00:12:32.699
So right now, we provide some system editing actions.

00:12:32.700 --> 00:12:39.640
These are the only sort of public responder actions you need
to worry about, cut, copy, paste, select and select all.

00:12:39.639 --> 00:12:47.799
These are declared in UI responder.h. Most classes
don't implement them, yours will as necessary.

00:12:47.799 --> 00:12:55.039
By default, if your first responder and the menu controller
needs to decide which menu item is to show, or cut or copy

00:12:55.039 --> 00:12:58.589
or whatever, if all you do is implement
them, they'll be enabled.

00:12:58.590 --> 00:13:02.100
They'll always be visible when
the user shows the menu controller

00:13:02.100 --> 00:13:05.389
and you're the first responder and it checks to see.

00:13:05.389 --> 00:13:09.480
These standard actions which are declared in the UI
responder.h are not actually implemented in them.

00:13:09.480 --> 00:13:11.670
They're only implemented in text field and text view.

00:13:11.669 --> 00:13:16.169
So you'll need to implement the ones
that you're interested in providing.

00:13:16.169 --> 00:13:21.559
If you want to customize which actions are
available, so when the menu controller is shown,

00:13:21.559 --> 00:13:24.849
you only want to show the cut item but you also want copy

00:13:24.850 --> 00:13:28.300
and paste so that there used at
other available to other times.

00:13:28.299 --> 00:13:31.709
You'll want to implement canPerformActionWithSender.

00:13:31.710 --> 00:13:33.200
This is called a lot.

00:13:33.200 --> 00:13:39.290
Every time the menu control is shown for every single
action this is called so you'll want to be quick about it.

00:13:39.289 --> 00:13:41.769
You don't want to sit there and do a lot of calculation.

00:13:41.769 --> 00:13:43.860
Should I be able to cut, should I be able to paste.

00:13:43.860 --> 00:13:50.919
Just check the state of the application, state
of the view, whatever and return yes or no.

00:13:50.919 --> 00:13:58.949
Any time you called with this with an unknown action, one
you don't recognize, just pass it on to the super, super,

00:13:58.950 --> 00:14:02.500
the next responder, the UI next
responder canPerformActionWithSender.

00:14:02.500 --> 00:14:04.440
That'll handle passing it down the chain.

00:14:04.440 --> 00:14:08.660
And if we have other actions in the
future which you don't know about,

00:14:08.659 --> 00:14:12.059
you won't block them from the application presenting them.

00:14:12.059 --> 00:14:15.919
So you always want to make sure that you don't, you know,

00:14:15.919 --> 00:14:20.110
don't just absorb the unknown actions
but rather pass them on down.

00:14:20.110 --> 00:14:27.800
So here's an example of how pretty much a standard template
you might use for implementing canPerformActionWithSender.

00:14:27.799 --> 00:14:34.799
Right now this view for example, or view controller,
doesn't allow editing so it also turns no uncut.

00:14:34.799 --> 00:14:37.709
It will return copy if we have something to copy.

00:14:37.710 --> 00:14:40.990
If we have some sort of selection,
otherwise it will return no.

00:14:40.990 --> 00:14:45.110
Paste, because also we don't allow
changing, we'll return no right now.

00:14:45.110 --> 00:14:51.539
And for select all, we'll say yes we can select
something if there is something there to select.

00:14:51.539 --> 00:14:55.259
In this case, we'll just check maybe an
item count variable or something like that.

00:14:55.259 --> 00:15:01.210
And as important, as I said, before, importantly
you must call supers canPerformActionWithSender

00:15:01.210 --> 00:15:07.620
if you don't implement the action if you don't know about
it, just pass it onto the next person to worry about.

00:15:07.620 --> 00:15:11.039
And so now, I'd like to give a quick little demo to start.

00:15:11.039 --> 00:15:17.819
That shows how you would present the
menu and how you would show certain items

00:15:17.820 --> 00:15:19.850
and certain times and how the responder chain works.

00:15:19.850 --> 00:15:27.710
It's a little application here and what it does is it
presents Sumerian cuneiform glyphs [assumed spelling].

00:15:27.710 --> 00:15:34.830
Sumerians invented writing about 4500 years ago, there're
about 200-300 different glyphs written on clay tablets.

00:15:34.830 --> 00:15:42.139
And so here we'll show you two rows of them and
I've written a small view here that tracks clicks

00:15:42.139 --> 00:15:48.120
and will show an insertion point or will
show a selection as you drag stuff out.

00:15:48.120 --> 00:15:53.100
Now what's more importantly, when you click and
hold it long enough, you get a cut or copy menu.

00:15:53.100 --> 00:16:00.090
Or if you've just got a selection, or sorry, insertion
point, sorry, you'll get just a select and select all.

00:16:00.090 --> 00:16:04.850
So it's similar to UI text field
depending on whether something is selected

00:16:04.850 --> 00:16:10.200
or whether there is a selection
range, you'll show different items.

00:16:10.200 --> 00:16:11.560
Sorry for that.

00:16:11.559 --> 00:16:19.169
Now just for your other code, there's a sample application,
which I believe is available, and this will, this,

00:16:19.169 --> 00:16:23.250
the important class for this one is UI
tablet view controller, Sumerian tablet.

00:16:23.250 --> 00:16:27.480
We'll start with the responder stuff.

00:16:27.480 --> 00:16:34.430
Here as I showed before, in view
will appear, where'd it go, sorry.

00:16:34.429 --> 00:16:39.000
Oh view, sorry, view did appear, my
apologies, we did call first responder.

00:16:39.000 --> 00:16:45.799
And what we've done here involved of course,
overridden can become first responder to return, yes.

00:16:45.799 --> 00:16:46.889
So that's all we needed to do.

00:16:46.889 --> 00:16:48.309
Now we're part of the responder chain.

00:16:48.309 --> 00:16:56.279
When our view, which slides in has been shown, we will
say become first responder and because we say we can,

00:16:56.279 --> 00:16:58.819
we now are as far as the window is concerned.

00:16:58.820 --> 00:17:03.020
So now, we've added a function that the
view calls back into the view controller.

00:17:03.019 --> 00:17:06.129
This is a view controller here that says the view did tabs.

00:17:06.130 --> 00:17:07.940
And now we know to present the view controller.

00:17:07.940 --> 00:17:12.890
And so at the bottom of the file here we have a show menu.

00:17:12.890 --> 00:17:16.550
We get the shared menu controller
and if it's not already visible,

00:17:16.549 --> 00:17:19.529
we set the target req to be the tablet view's selection req.

00:17:19.529 --> 00:17:22.789
So this is the function we've added on
the view to return the bounds on just

00:17:22.789 --> 00:17:25.230
that selection rather than the bounds of the whole view.

00:17:25.230 --> 00:17:30.730
This way we won't have the menu controller presented
in the wrong location and we want it faded in.

00:17:30.730 --> 00:17:33.940
So that's all we needed to do to
present the menu controller.

00:17:33.940 --> 00:17:37.390
Now we have to indicate which items to present.

00:17:37.390 --> 00:17:44.440
So we've implemented as you can see, cut and
copy and paste and select and select all.

00:17:44.440 --> 00:17:48.549
So all five of those known public actions.

00:17:48.549 --> 00:17:57.109
And we also have implemented the, excuse me, they
can perform action with sender call and as similar

00:17:57.109 --> 00:18:00.449
to the template that you already saw,
we check based on the certain actions.

00:18:00.450 --> 00:18:04.720
For example, cut and copy if there is a selection range.

00:18:04.720 --> 00:18:07.420
Or paste or select or select all.

00:18:07.420 --> 00:18:11.920
So for select or select all, we only want
to show it if there is something to select,

00:18:11.920 --> 00:18:15.210
the count is greater than zero
and there is no current selection.

00:18:15.210 --> 00:18:17.890
So if there is a selection, we
only show them cut, copy or paste.

00:18:17.890 --> 00:18:23.230
And as I said, very importantly, we call super
canPerformActionWithSender in order to present to--

00:18:23.230 --> 00:18:27.440
in order to pass on actions that we don't understand.

00:18:27.440 --> 00:18:30.720
So now, I'd like to talk about the pasteboard.

00:18:30.720 --> 00:18:39.190
So you've got cut, copy and paste, you've got a selection,
these are cut, you find the text that's been cut and so on,

00:18:39.190 --> 00:18:46.000
but you've got to put it somewhere and you want to--
you could put it just in your own application, you know,

00:18:46.000 --> 00:18:50.410
and share it within there but, you know, you
probably want to actually put that data, you know,

00:18:50.410 --> 00:18:53.009
on somewhere where other applications can read it.

00:18:53.009 --> 00:18:57.430
So if these are paste texts or something they can put
the text somewhere, another application can read it.

00:18:57.430 --> 00:19:02.299
Or maybe if they put text on the
pasteboard, you could read it.

00:19:02.299 --> 00:19:04.329
It gives you a shared and persistent storage.

00:19:04.329 --> 00:19:09.049
So even though your app quits the, the text remains.

00:19:09.049 --> 00:19:16.859
It allows you to set single or multiple items so you can set
a single string or you can set three strings or a mixture

00:19:16.859 --> 00:19:19.719
of three strings and three images
of whatever you want to do.

00:19:19.720 --> 00:19:23.509
And then for each item you can
specify a unique representation

00:19:23.509 --> 00:19:27.160
so you can have a plain text item that also has rich text.

00:19:27.160 --> 00:19:31.630
And then depending on the app that's reading that
information, it can decide, Oh I understand rich text

00:19:31.630 --> 00:19:36.880
or I only understand plain text and I'm not
going to be able to give you anything fancy.

00:19:36.880 --> 00:19:42.120
And we provide a standard general pasteboard
which every application knows about

00:19:42.119 --> 00:19:44.779
and which should be the most common thing you need to use.

00:19:44.779 --> 00:19:50.950
In order to get a pasteboard just ask the UI
pasteboard class for the general pasteboard.

00:19:50.950 --> 00:19:52.720
That's the most common paste you'll need.

00:19:52.720 --> 00:19:55.910
That's the one every application uses.

00:19:55.910 --> 00:20:00.450
If you want to do your own pasteboard stuff
either internally when you app or maybe a suite

00:20:00.450 --> 00:20:03.130
of apps, you can create your own pasteboard.

00:20:03.130 --> 00:20:06.750
You can save pasteboard with name,
create and that lets you specify a name.

00:20:06.750 --> 00:20:13.609
And then ask to create it if it doesn't exist, or if you say
No and to create and it doesn't exist, you'll get nil back.

00:20:13.609 --> 00:20:19.349
And you should name the pasteboard something
reasonably unique like com-- YourCompany.YourProgram.

00:20:19.349 --> 00:20:23.289
You can also ask for a pasteboard with a completely
unique name that gives you a long, you know,

00:20:23.289 --> 00:20:26.329
unique id string that used-- that only you know about.

00:20:26.329 --> 00:20:31.629
You might want to use this for an internal pasteboard or
something like that or if you somehow make it available

00:20:31.630 --> 00:20:34.790
and known to other applications, they can use it.

00:20:34.789 --> 00:20:37.470
The pasteboards that you create, you own.

00:20:37.470 --> 00:20:40.769
So your application creates that pasteboard,
it's marked with being owned by you.

00:20:40.769 --> 00:20:45.639
Other applications that are able to read and write to
just that pasteboard will not be able to change attributes

00:20:45.640 --> 00:20:47.670
about that pasteboard and I'll talk about some of those.

00:20:47.670 --> 00:20:50.720
So now about pasteboard items.

00:20:50.720 --> 00:20:54.720
You want to put stuff on the pasteboard,
you want to get stuff off.

00:20:54.720 --> 00:20:59.019
You can just provide a single item and we have
some simpler API for doing that; I'll show you.

00:20:59.019 --> 00:21:02.690
And for example, here we have a
single item with a plain text string.

00:21:02.690 --> 00:21:06.509
As I said before, you can have
unique representations for each item.

00:21:06.509 --> 00:21:13.049
So you can't have two text values for the same item,
but you can have a plain text value, a rich text value,

00:21:13.049 --> 00:21:19.000
you could even have a image representation of
that data or a PDF representation of that data.

00:21:19.000 --> 00:21:20.750
And then we allow multiple items.

00:21:20.750 --> 00:21:27.230
So for example if you're copying from a webpage, which
is a mixture of text and images all in a steam there,

00:21:27.230 --> 00:21:32.640
you'll want to, you know, copy a block of text, copy
a picture and so on and put them one after the other.

00:21:32.640 --> 00:21:37.250
Not every application will be able to read all the
items, but at least they'll be able to, if they can,

00:21:37.250 --> 00:21:41.789
present a much better representation
of the data that you copied.

00:21:43.059 --> 00:21:48.059
The data itself is normally just passed using NS data.

00:21:48.059 --> 00:21:51.589
There's the base sort of getter for
this is data for pasteboard type,

00:21:51.589 --> 00:21:54.740
you pass in a single type, you get back a chunk of NS data.

00:21:54.740 --> 00:21:57.609
That's up to you to interpret.

00:21:57.609 --> 00:22:03.619
We also provide a property list version of that for you
know, pretty much standard foundation property lists

00:22:03.619 --> 00:22:11.009
as any combination of dictionaries, arrays, strings, dates,
numbers and the data itself and you can mix and match that.

00:22:11.009 --> 00:22:15.049
That gets converted to an NS data when
it's saved and then reread back out.

00:22:15.049 --> 00:22:19.180
You can't extend these types right
now as far as I know, that's it.

00:22:19.180 --> 00:22:22.870
So you'll have to, if you've got a
custom type of data you want to store,

00:22:22.869 --> 00:22:26.289
you'll have to convert it to an
NS data to put in a property list.

00:22:26.289 --> 00:22:32.250
The pasteboard contents we'll talk about.

00:22:32.250 --> 00:22:37.950
Users put the pasteboard data on, maybe a plain
text or whatever, you want to know what's there.

00:22:37.950 --> 00:22:40.250
The simplest call list contains pasteboard types.

00:22:40.250 --> 00:22:43.910
You pass in an array of types and it
returns Yes or No, whether it's available.

00:22:43.910 --> 00:22:48.570
If for some reason your application is interested
in maybe preferring one type over another,

00:22:48.569 --> 00:22:52.139
if it's available you can ask for a
complete list of types for that item.

00:22:52.140 --> 00:22:59.690
And this pasteboard type returns an NS array of strings,
the pasteboard types for the, that particular item.

00:22:59.690 --> 00:23:02.269
So for example, plain text or rich text.

00:23:02.269 --> 00:23:04.269
And here is the single item method.

00:23:04.269 --> 00:23:06.879
These are the most common cases you'll probably want to use.

00:23:06.880 --> 00:23:09.280
They all operate on the first item only.

00:23:09.279 --> 00:23:15.379
So if you've got multiple items, these only work on
the first in terms of reading them and if you set

00:23:15.380 --> 00:23:18.590
to them using these methods, you
will clear out all the other items.

00:23:18.589 --> 00:23:24.980
So you say for example, set data for pasteboard type
and there's five items, you only have one item now left

00:23:24.980 --> 00:23:27.730
on the pasteboard, it'll clear out all the other ones.

00:23:27.730 --> 00:23:31.450
And there's basically is the ones I've talked about.

00:23:31.450 --> 00:23:36.529
The NS data setter and getter and
the property list setter and getter.

00:23:36.529 --> 00:23:44.750
We do support multiple items as I said, we add one more
property to the pasteboard, which is number of items.

00:23:44.750 --> 00:23:48.099
We use an index set to specify
which items you're interested in.

00:23:48.099 --> 00:23:51.419
If you're interested in items 1, 3 and
5 for example, you can specify that.

00:23:51.420 --> 00:23:55.050
Or you can just pass it, you're interested in all items.

00:23:55.049 --> 00:23:58.759
And there are equivalent methods for
every getter and setter that you saw.

00:23:58.759 --> 00:24:03.259
And contains some property lists and so
on that take this NS index and set it.

00:24:03.259 --> 00:24:07.319
So for example, data for pasteboard
type returns a single NS data,

00:24:07.319 --> 00:24:11.879
data for pasteboard type in item set returns an NS array.

00:24:11.880 --> 00:24:14.510
This returned list is compacted.

00:24:14.509 --> 00:24:18.670
So if you only ask for items 1, 3 and 5,
you'll get an array of threads and back.

00:24:18.670 --> 00:24:22.930
So you'll have to do that mapping
if you're really interested.

00:24:22.930 --> 00:24:27.950
And we do provide a bit more sort of basic
direct access to all the pasteboard items.

00:24:27.950 --> 00:24:31.190
There's a read write property that
takes an array of dictionaries.

00:24:31.190 --> 00:24:33.230
You can set and get as necessary.

00:24:33.230 --> 00:24:36.620
Be warned of course, that this is going
to get you everything in the pasteboard,

00:24:36.619 --> 00:24:38.709
which might be a lot if someone's pasted a few pictures.

00:24:38.710 --> 00:24:43.519
As a bit of a convenience, you can add items one at a time.

00:24:43.519 --> 00:24:48.639
Each of those items will be a dictionary of
pasteboard type and then the raw NS data.

00:24:48.640 --> 00:24:52.440
We don't do any conversion to property list
types or whatever so you're going to have

00:24:52.440 --> 00:24:58.860
to provide us just the plain NS data along
with the key which is the pasteboard type.

00:25:00.130 --> 00:25:08.450
So as I said before, if you create your own pasteboard, it's
not persistent by default, but if you own it, you can set,

00:25:08.450 --> 00:25:16.360
you-- I'm sorry, if you don't mark it as
persistent, it will be moved when the app exits.

00:25:16.359 --> 00:25:19.059
Which might be useful in some cases, but
probably you'll want to keep it around.

00:25:19.059 --> 00:25:23.879
So if you're the owner, you can set
the persistence flag on the pasteboard.

00:25:23.880 --> 00:25:27.270
But as I said, you, it's not a hundred percent persistent.

00:25:27.269 --> 00:25:30.139
There'll be cases where we will erase it.

00:25:30.140 --> 00:25:36.230
Maybe the application that owned it went away or
maybe we ran out of space or we rebooted or so on.

00:25:36.230 --> 00:25:39.170
So don't use it as a general storage mechanism.

00:25:39.170 --> 00:25:45.900
It's not guaranteed to be around as much as, you
know, just writing a file into your indicative space.

00:25:45.900 --> 00:25:50.640
And as the owner, besides hitting the persistence
blog, you can call it remove pasteboard with name.

00:25:50.640 --> 00:25:53.580
You don't need to create, load the pasteboard
note to remove it, just pass in the name.

00:25:53.579 --> 00:25:56.539
So you need to know the name and you
need to own it in order to remove it.

00:25:56.539 --> 00:25:59.170
If you don't it just won't do anything.

00:26:00.279 --> 00:26:04.250
We do provide support for a few pasteboard types.

00:26:04.250 --> 00:26:08.789
Sort of predesigned easy setter or
getter methods so you don't need to ask

00:26:08.789 --> 00:26:12.079
for the pasteboard type and convert to an NS data or so on.

00:26:12.079 --> 00:26:15.879
Right now, we support strings, images, URLs and colors.

00:26:15.880 --> 00:26:21.440
So that's NS string, UI image, NS URL and UI color.

00:26:21.440 --> 00:26:26.200
We have a single item case for this for example
here we're asked for the general pasteboard.

00:26:26.200 --> 00:26:30.670
We set the string value to be [inaudible]
and that replaces all the other items.

00:26:30.670 --> 00:26:35.420
We have multiple item versions of these calls.

00:26:35.420 --> 00:26:41.360
So for example, a string's property, which you can
set and get which works with an NS array like you saw

00:26:41.359 --> 00:26:46.439
and that will put in or get out an array of information.

00:26:46.440 --> 00:26:50.090
Obviously if there is only one item,
you get an array with one item back.

00:26:50.089 --> 00:26:56.419
And just like the other case with the direct setters
with the single item, if you use the single setter

00:26:56.420 --> 00:26:59.960
like just setting the single string
value, you will erase the old--

00:26:59.960 --> 00:27:02.069
all the other items if there are multiple items there.

00:27:02.069 --> 00:27:04.099
Just something to be aware of.

00:27:05.190 --> 00:27:09.730
And one other proviso is that UI images are
automatically converted to PNGs to be stored.

00:27:09.730 --> 00:27:15.039
This is a lostlist [assumed spelling] format and
we don't keep track of what the original data was.

00:27:15.039 --> 00:27:18.920
We don't know if it came from a JPEG
or a TIF or whatever you provided.

00:27:18.920 --> 00:27:20.970
So it will be slow if it's a big image.

00:27:20.970 --> 00:27:25.140
So if you've got a, you know, three megapixel
image and you're converting from a you know,

00:27:25.140 --> 00:27:29.880
UI image to stores of PNG the user will
notice that's going to take some time.

00:27:29.880 --> 00:27:34.340
So if possible, you'll want to keep track
of the original data that this came from.

00:27:34.339 --> 00:27:34.399
[Inaudible].

00:27:34.400 --> 00:27:41.140
So if it's originally from a JPEG just keep the
original NS data that stores that JPEG around,

00:27:41.140 --> 00:27:47.380
put that on the pasteboard rather than using the UI
image calls or setting the image or images property.

00:27:49.000 --> 00:27:54.509
For pasteboard types, we use what are called
UTIs, these are universal type identifiers.

00:27:54.509 --> 00:28:01.539
This is something that's been on Mac OS X already and
just presents sort of a simple not quite inheritance tree

00:28:01.539 --> 00:28:05.670
but something similar to different known types.

00:28:05.670 --> 00:28:12.940
For example, public.PNG with just the PNG
type is this type of public.image and so on.

00:28:12.940 --> 00:28:14.730
So you want to use these types.

00:28:14.730 --> 00:28:19.279
Why? Because it'll give everybody else knowledge
about what you're putting on the pasteboard.

00:28:19.279 --> 00:28:23.740
If you put, you know, your company.type on
there, only apps that have specifically written

00:28:23.740 --> 00:28:26.799
to understand your company's type,
we'll know what to do with the data.

00:28:26.799 --> 00:28:29.019
Otherwise, it will just ignore it.

00:28:29.019 --> 00:28:34.869
So for example, here we've got some of the
UTI types defined, PNG, mp3, URL and so on.

00:28:34.869 --> 00:28:38.789
And obviously we don't use them all ourselves,
but they are all available and you should use them

00:28:38.789 --> 00:28:42.440
if you have your particular type on the pasteboard.

00:28:42.440 --> 00:28:47.110
We use the, for example, when we provide
the list of types that we understand.

00:28:47.109 --> 00:28:53.379
So for example the image type, we actually say we
can understand these following four image types

00:28:53.380 --> 00:28:58.020
in this order actually; PNG, TIF, JPEG and JIF.

00:28:58.019 --> 00:29:04.019
So any of those items are placed on the
pasteboard and you ask for the images

00:29:04.019 --> 00:29:06.720
for that item, you will get one of these back.

00:29:06.720 --> 00:29:10.440
It will read one of these and you'll
get an actual image back.

00:29:10.440 --> 00:29:13.850
This is the same API as Mac OS X.

00:29:13.849 --> 00:29:18.059
A couple things we don't support are things
like four character codes; we don't need them.

00:29:18.059 --> 00:29:22.639
And the only difference between us and Mac
OS X otherwise is that this is now located

00:29:22.640 --> 00:29:25.810
in a new framework called mobileCoreServices.framework.

00:29:25.809 --> 00:29:30.569
So you'll want to look there for this API or
for any of the types you might want to put

00:29:30.569 --> 00:29:34.649
on the pasteboard that we already defined for you.

00:29:34.650 --> 00:29:42.130
A few sort of dos and don'ts just to reiterate what I talked
about earlier, do add multiple representations if possible.

00:29:42.130 --> 00:29:48.750
You know, provide a plain text at least or a simple
PNG plus, you know, more complex data type if necessary

00:29:48.750 --> 00:29:53.740
for example maybe a raw or camera or
whatever or html text or something.

00:29:53.740 --> 00:29:57.359
This way even a very simple application
will be guaranteed to be able to paste

00:29:57.359 --> 00:30:00.669
or if they want to paste text or some plain text.

00:30:00.670 --> 00:30:02.310
As I said before, just to read right.

00:30:02.309 --> 00:30:07.669
Don't use it as a general storage mechanism,
we'll erase it at various times you, you know,

00:30:07.670 --> 00:30:10.400
your user will be annoyed it something goes away.

00:30:10.400 --> 00:30:15.600
And use the original image data, don't
let it uncompress and then recompress

00:30:15.599 --> 00:30:19.139
as necessary, that's just going to annoy the user.

00:30:19.140 --> 00:30:22.490
And just don't put secure data on the general pasteboard.

00:30:22.490 --> 00:30:28.630
Just a good rule you know if someone pastes a, copies of
a password, you don't want to put it on the pasteboard.

00:30:28.630 --> 00:30:31.600
Otherwise of course, some-anybody-- other
application comes along and will be able to read it.

00:30:31.599 --> 00:30:38.509
So, for us for example for secure text fields, you
cannot copy the text into a-- into the pasteboard.

00:30:38.509 --> 00:30:41.740
We just disable the copy command completely.

00:30:41.740 --> 00:30:47.519
So now that I've sort of talked about the API, I'll show you
how we've added that to the application I showed you earlier

00:30:47.519 --> 00:30:52.389
to allow you to cut and paste between
the application and another application.

00:30:53.829 --> 00:30:59.369
So back to here.

00:30:59.369 --> 00:31:05.099
There are only three places we need to
add to give us full pasteboard support.

00:31:05.099 --> 00:31:09.879
One is in the paste command, and as I said before
for example, we get to the general pasteboard,

00:31:09.880 --> 00:31:14.140
and we ask if it contains the pasteboard type
and we'll just ask for only a plain string.

00:31:14.140 --> 00:31:17.810
So we're not a smart app, we don't
know images and rich text.

00:31:17.809 --> 00:31:22.179
We'll just look for plain text.

00:31:22.180 --> 00:31:26.200
Then there are only two operations
that really involve a pasteboard.

00:31:26.200 --> 00:31:29.650
That's cut and paste.

00:31:29.650 --> 00:31:32.720
Copy is really, oh sorry, copy and paste rather.

00:31:32.720 --> 00:31:36.039
Copy will read the text and put it on the pasteboard.

00:31:36.039 --> 00:31:40.839
Paste will take the text from the
pasteboard and put it into your document.

00:31:40.839 --> 00:31:46.809
So for copy, we ask the tablet for the text in the
current selection range and copy will only be enabled

00:31:46.809 --> 00:31:50.259
if there is a text selection so
we don't need to check it here.

00:31:50.259 --> 00:31:55.180
We'll ask, and then we'll just tell the general
pasteboard that its new screen value is this text.

00:31:55.180 --> 00:32:02.430
In the reverse case, we've enabled paste if
the pasteboard contains some kind of text data.

00:32:02.430 --> 00:32:11.100
So we'll ask for that text and then we'll call a function
called swapTextAndRange will replace the existing range

00:32:11.099 --> 00:32:13.539
with this new pasteboard text.

00:32:13.539 --> 00:32:17.480
And I'll show that function later
with, with-- as we go along.

00:32:17.480 --> 00:32:18.559
And that's all we really need to do.

00:32:18.559 --> 00:32:25.049
Now we can cut and paste text and
we can share it with applications.

00:32:25.049 --> 00:32:27.849
So we can for example, select these two characters.

00:32:27.849 --> 00:32:31.099
And what you see at the top is
the transliteration of the glyphs.

00:32:31.099 --> 00:32:34.129
So the first glyph is Tom and the second one is Lou.

00:32:34.130 --> 00:32:39.150
So we will copy and then maybe we can paste it down here.

00:32:39.150 --> 00:32:41.090
And notice here now, paste appears.

00:32:41.089 --> 00:32:44.639
Before there was nothing in the pasteboard,
so the paste command wasn't enabled.

00:32:44.640 --> 00:32:49.820
Now it is because there is something
and we paste and the text is there.

00:32:49.819 --> 00:32:52.619
And of course, now we can share
this data with other applications.

00:32:52.619 --> 00:32:59.529
So I've got just a little application, all it is,
is a text field, but because we have cut, copy,

00:32:59.529 --> 00:33:05.190
paste and text as well, what we've done is
actually pasted in the transliteration text.

00:33:05.190 --> 00:33:08.680
And there you can see it's copied the text in there.

00:33:08.680 --> 00:33:14.049
And we can even edit it here, add maybe another character.

00:33:14.049 --> 00:33:19.819
Copy that character.

00:33:19.819 --> 00:33:27.169
Now we go back to the original application, which knows
how to convert from the transliteration back to a glyph.

00:33:27.170 --> 00:33:33.210
So now, we can say paste and we get a new
character in that's the glyph that represents End.

00:33:33.210 --> 00:33:36.400
So that was all to add cut, copy, paste.

00:33:36.400 --> 00:33:44.860
Now your application is so much more useful
because other applications can get at your data.

00:33:46.200 --> 00:33:55.090
So now we've added-- show the cut, copy, paste menu
and be able to share that data with the pasteboard,

00:33:55.089 --> 00:33:59.109
we'll actually be able to give the user a
chance to maybe undo the accidental cut.

00:33:59.109 --> 00:34:04.699
They've cut or they've done a couple of cuts and
pastes and they go, That's not what I wanted to do.

00:34:04.700 --> 00:34:09.570
So the Mac O-- the Mac OS X foundation
has the NS undo manager

00:34:09.570 --> 00:34:13.039
and we've just brought that completely over to the iPhone.

00:34:13.039 --> 00:34:17.329
So it's in the same location and
foundation, it's the same API as Mac OS X,

00:34:17.329 --> 00:34:20.199
NS undo manager so if you've used
that before this is no different.

00:34:20.199 --> 00:34:25.029
And I just want to cover some of the features
for those that haven't used it before.

00:34:25.030 --> 00:34:28.510
What you need to do is every time
the user does an action, a cut,

00:34:28.510 --> 00:34:33.450
a paste or something that modifies the document
content, you want to register an undo action.

00:34:33.449 --> 00:34:36.539
Something that you'll want to do to reverse what was done.

00:34:36.539 --> 00:34:38.949
The undo manager will keep track of all of this for you.

00:34:38.949 --> 00:34:42.899
It will keep track of a stack of actions as you keep
doing more stuff, as the user keeps doing more stuff.

00:34:42.900 --> 00:34:46.420
It'll keep track of that stack and it'll be
able to play it back in the reverse direction,

00:34:46.420 --> 00:34:53.619
so as the user does undo it goes back down and keep track
of what was done and undone and lets you redo it again.

00:34:53.619 --> 00:34:59.109
It allows you to group actions together so
for example if user does a bunch of typing,

00:34:59.110 --> 00:35:05.530
it'll group that all under an undo typing block
rather than having to undo every single character.

00:35:05.530 --> 00:35:11.050
And it keeps track of an action name for an interface
so when the user sees, you know, that they need to undo

00:35:11.050 --> 00:35:16.810
and they bring up the undo alert, you will-- they will
see undo action rather than just a plain word undo.

00:35:16.809 --> 00:35:21.400
And this way it will be more likely to
remember what it is they want to undo.

00:35:21.400 --> 00:35:24.280
So to create an undo action, you
need to do one of two calls.

00:35:24.280 --> 00:35:26.990
And I'll show you why use one over the other.

00:35:26.989 --> 00:35:32.399
There's a target selector version that just
takes two objects and then a method name

00:35:32.400 --> 00:35:35.410
that you want to actually perform as the undo.

00:35:35.409 --> 00:35:42.019
Or you can use what's called an invocation, which
allows you more complex parameters to the undo.

00:35:42.019 --> 00:35:50.710
So you'll use the target action case when you've
got a simple reversible setter, like a setter method

00:35:50.710 --> 00:35:56.900
or you've got a case where the undo action
will just take a single object, an NS object.

00:35:56.900 --> 00:36:03.460
For example here we see a set color method and that's
completely reversible if you want to set the old color,

00:36:03.460 --> 00:36:07.320
you just need to set the old color with the--
and you need to remember what the old color is.

00:36:07.320 --> 00:36:14.890
So what we do is we get the undo manager and then we
just call register, undo with action with target selector

00:36:14.889 --> 00:36:17.500
and the object that you're going to undo.

00:36:17.500 --> 00:36:24.159
So for here it's a UI color and all
we need to do is call setColor again.

00:36:24.159 --> 00:36:29.389
Call it with setColor with the original
color under bar color and that's all.

00:36:29.389 --> 00:36:35.839
Undo manager is smart, it will remember what it's used
as the undo color, it'll remember what you passed in

00:36:35.840 --> 00:36:39.120
and as it does undo and redo it
will set the appropriate value.

00:36:39.119 --> 00:36:43.239
So you can just keep calling the same function
over and over and over again to undo and redo.

00:36:43.239 --> 00:36:51.059
For the invocation, we use this for if you've got multiple
parameters and I'll show you an example in the demo.

00:36:51.059 --> 00:36:55.670
Or if you've got something that the parameters are
not an NS object, something that can be retained.

00:36:55.670 --> 00:37:01.930
So for example here we've got a set level function
that takes an integer so we can't retain it

00:37:01.929 --> 00:37:04.919
but instead we'll call it prepared
with invocation with target self.

00:37:04.920 --> 00:37:10.289
That returns an invocation object, something that
will remember the action and pass in the function.

00:37:10.289 --> 00:37:13.630
And in this case this is a set
level call is also reversible.

00:37:13.630 --> 00:37:15.680
So we can just call set level again.

00:37:15.679 --> 00:37:20.619
But as necessary, you can have a undo set
level call that you would use instead.

00:37:20.619 --> 00:37:23.630
And so you'll use that one instead of this set level call.

00:37:23.630 --> 00:37:28.530
So it's up to you and your design app and
what kind of data you need to pass in.

00:37:30.190 --> 00:37:33.420
Once you've set the action, you'll
want to set the undo title.

00:37:33.420 --> 00:37:39.610
So this is what shows up in the alert when it pops up and
instead of just saying undo and redo, it'll show undo.

00:37:39.610 --> 00:37:42.539
Like here is setColor or redo setColor.

00:37:42.539 --> 00:37:48.670
So when the user shakes the phone, they'll see undo
setColor, Oh yeah, that's what I did, I set the color.

00:37:50.309 --> 00:37:54.860
Now that you've added all these actions up
and down and there's a whole stack of actions,

00:37:54.860 --> 00:37:58.440
you'll want to manage the sort of undo
state with actions that are available

00:37:58.440 --> 00:38:01.750
and when certain actions are no longer available.

00:38:01.750 --> 00:38:08.320
By default, you can register multiple,
you know, actions at the same time.

00:38:08.320 --> 00:38:14.080
The user presses a button, you do three cuts or something
or whatever, you can register three separate actions.

00:38:14.079 --> 00:38:18.730
They are grouped together for that
single event as a single action.

00:38:18.730 --> 00:38:21.820
If necessary, you might want to
combine actions across events.

00:38:21.820 --> 00:38:29.370
So for example typing or maybe you've a graphic and you're
moving the image around on the screen multiple times,

00:38:29.369 --> 00:38:32.219
the user probably wants to undo it right
back to the original location rather

00:38:32.219 --> 00:38:34.059
than having to undo each step as you did it.

00:38:34.059 --> 00:38:39.529
In this case you can use beginUndoGrouping
and endUndoGrouping and that will just sort

00:38:39.530 --> 00:38:44.420
of capture all the actions you did as one
big group until you hit undo grouping.

00:38:44.420 --> 00:38:49.780
These are nestable if necessary so you can
have your code, just call us multiple times.

00:38:49.780 --> 00:38:53.470
You'll want to clear the undo stack at certain times.

00:38:53.469 --> 00:38:57.359
Sometimes when the state of the program
changes you've like saved a document

00:38:57.360 --> 00:38:59.890
or whatever it is you've done, that you can no longer undo.

00:38:59.889 --> 00:39:03.299
So you'll just call the undo manager removeAllActions

00:39:03.300 --> 00:39:09.000
or if only a certain object is going away that's no
longer undoable, you'll need to call rootActionsForTarget.

00:39:09.000 --> 00:39:14.449
And that target might be the view that registered
the undo action or the controller or whatever.

00:39:14.449 --> 00:39:20.949
You have to do it based on the
design of the program so it depends.

00:39:20.949 --> 00:39:26.199
A lot of cases you'll just call to
remove all actions to clear things out.

00:39:26.199 --> 00:39:28.750
To enable undo, you don't have to do anything.

00:39:28.750 --> 00:39:33.110
If you put something on the undo manager and
told the undo manager here's something to do

00:39:33.110 --> 00:39:39.400
and the user shakes the phone they'll get the undo manager
alert appearing, bouncing in and they'll be able to undo.

00:39:39.400 --> 00:39:42.210
So you don't need to do anything, it just shows up.

00:39:42.210 --> 00:39:48.420
You can turn it off temporarily; there's a UI
application property that allows shakeToUndo.

00:39:48.420 --> 00:39:50.579
If that's turned off, shake that [inaudible]

00:39:50.579 --> 00:39:57.559
if that's turned off then you won't get any alert
appearing and the undo stack will remain as it is.

00:39:57.559 --> 00:39:59.210
It's invoked using the motion events.

00:39:59.210 --> 00:40:06.909
The UI responder if you've seen in 3.0 has the motion
began and ended and so on and we use the exact same system

00:40:06.909 --> 00:40:10.529
in the responder chain in order to show that alert.

00:40:10.530 --> 00:40:20.000
So even though you might have undo items on the-- items
in the undo manager, you'll also still get motion stuff.

00:40:20.000 --> 00:40:25.190
If you do want the undo manager to show the alert, you'll
need to make sure that those motion events get passed down

00:40:25.190 --> 00:40:27.550
or passed up the responder chain to the UI application.

00:40:27.550 --> 00:40:31.670
So if you intercept motion events and you're
not interested in doing them yourself,

00:40:31.670 --> 00:40:35.480
you'll want to make sure you call super
motionBegan, motionEnded and so on.

00:40:35.480 --> 00:40:38.420
So we know that we can present the alert.

00:40:38.420 --> 00:40:41.530
If there are times when you think you
want to shake to randomize or something,

00:40:41.530 --> 00:40:47.690
this is where you would use the flag applications for shake
to edit to turn it off temporarily while they're randomizing

00:40:47.690 --> 00:40:51.139
that particular view, and then they go back and reenable it.

00:40:52.730 --> 00:40:56.990
By default, we provide you an undo manager.

00:40:56.989 --> 00:40:58.049
That's in the UI window.

00:40:58.050 --> 00:41:03.660
So same as the first responder, there's
a shared undo manager in the UI window.

00:41:03.659 --> 00:41:09.719
We follow up the responder chain so there, the UI
responder itself has a method called undo manager

00:41:09.719 --> 00:41:15.149
and you just say self.undoManager, and that will
actually do the search up the chain for you.

00:41:15.150 --> 00:41:17.519
By default it said, Every window has its own undo manager,

00:41:17.519 --> 00:41:20.679
so as you switch windows you'd
get a new undo stack available.

00:41:20.679 --> 00:41:28.279
We do sometimes need special undo managers
because of modal state or some other state.

00:41:28.280 --> 00:41:30.920
In this case for example, text field.

00:41:30.920 --> 00:41:35.349
When you activate a text field, we want
to allow you to edit and undo and edit.

00:41:35.349 --> 00:41:39.269
But then when you finish editing in that
particular text field, you want to clear out,

00:41:39.269 --> 00:41:41.769
you don't want to have any more undo, you don't want to go

00:41:41.769 --> 00:41:46.300
to another text field activated undo what
you did in another text field into this one.

00:41:46.300 --> 00:41:51.150
And also the user might forget, or it's been a while,
so we just-- and this is no different than Mac OS X,

00:41:51.150 --> 00:41:55.849
we just clear out the undo stack when
the text field resigns first responder.

00:41:55.849 --> 00:42:02.480
Also, for those of you who use Core Data, there is an undo
manager available in what is the, NS managed object context.

00:42:02.480 --> 00:42:09.809
So if your class, if your view or controller is the
first responder, it can-- and it works with Core Data--

00:42:09.809 --> 00:42:13.409
it can just return that as managed
object context undo manager.

00:42:13.409 --> 00:42:19.049
And then whenever you do any Core Data operations,
adding or removing from the Core Data database,

00:42:19.050 --> 00:42:24.320
it'll record those undo actions so you'll be able to
just say, you know, undo, you know, inserting that row

00:42:24.320 --> 00:42:27.640
or undoing setting that property
and you'll get that automatically.

00:42:27.639 --> 00:42:32.670
So you don't have to do anything there except
return the undo manger that you want to use.

00:42:32.670 --> 00:42:37.030
And you might have your own cases where
you want to have custom undo managers.

00:42:37.030 --> 00:42:43.740
So for example, in the demo application, which I
don't have there, as I go to each different tablet,

00:42:43.739 --> 00:42:47.299
I might want to be able to undo
there and not in another one.

00:42:47.300 --> 00:42:50.950
I want to undo, sorry, in each tablet uniquely.

00:42:50.949 --> 00:42:56.139
So I make a change in one, I go to another one and make
a change, go back to the original and then it'll be able

00:42:56.139 --> 00:42:58.819
to undo that original change in that original view.

00:42:58.820 --> 00:43:02.090
And so in that case, each view
would have its own undo manager.

00:43:02.090 --> 00:43:08.039
And then you-- it'll remember so as you switch
to that view, it'll use that undo manager.

00:43:08.039 --> 00:43:12.360
It's the end to interface.

00:43:12.360 --> 00:43:18.240
When you undo you want to make sure that your
user has some feedback when this happens.

00:43:18.239 --> 00:43:20.589
So don't undo offstage, you know.

00:43:20.590 --> 00:43:22.820
The user shakes the undo and nothing happens.

00:43:22.820 --> 00:43:26.150
So you want to, you scroll to make sure that's visible.

00:43:26.150 --> 00:43:29.110
You want to show a selection or something when that happens.

00:43:29.110 --> 00:43:33.700
You know, you want to animate if possible, for
example, if it's a graphic you moved around the screen,

00:43:33.699 --> 00:43:39.609
and you do an undo, you may want to show it either retracing
its steps or just sliding back to the original location.

00:43:39.610 --> 00:43:44.650
You know, it's up to your application, but it's very
nice to see, Oh that's what I did, and that's-- what's--

00:43:44.650 --> 00:43:46.360
that's where it's back to its original place.

00:43:46.360 --> 00:43:50.260
You want to make sure it doesn't undo somewhere else.

00:43:50.260 --> 00:43:56.170
As I said before, you want to sort of clear the undo
state when it's logical to clear the undo state.

00:43:56.170 --> 00:44:01.730
You know maybe the user doesn't expect to be able to undo
and they go back somewhere and suddenly they can't again.

00:44:01.730 --> 00:44:07.460
It's up to you, you know, to your
application, but you want to do that.
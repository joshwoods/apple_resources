WEBVTT

00:00:13.000 --> 00:00:21.369
[ Applause ]

00:00:21.370 --> 00:00:24.120
>> Good afternoon and welcome to WWDC.

00:00:24.120 --> 00:00:27.650
This conference is about you, the developer.

00:00:27.649 --> 00:00:33.719
And if you remember in Bertrand's last slide
he said "the ball is now in your court."

00:00:33.719 --> 00:00:37.950
Now some people think that soccer is played on the
field and others down on pitch but Bertrand seems

00:00:37.950 --> 00:00:40.010
to think it something that is played on a court.

00:00:40.009 --> 00:00:42.679
[ Laughter ]

00:00:42.679 --> 00:00:45.350
[ Applause ]

00:00:45.350 --> 00:00:55.460
>> But I'm here to talk to you about Core OS, Core OS is
the foundation technology for the Mac and for the phone.

00:00:55.460 --> 00:01:01.179
And it's a foundation that's built
on the stable core of UNIX,

00:01:01.179 --> 00:01:07.140
a system that is renowned for its
reliability and its robustness.

00:01:07.140 --> 00:01:15.710
And our UNIX system forms the engine
of Mac OS X and the iPhone OS.

00:01:15.709 --> 00:01:19.579
Now UNIX has a time proven architecture.

00:01:19.579 --> 00:01:28.219
It's a modular system with well defined interfaces
between subcomponents inside the system that allows

00:01:28.219 --> 00:01:33.530
for the evolution of these subsystems
to face new technology challenges.

00:01:33.530 --> 00:01:39.969
For example, the Scheduler is evolving to
deal with the ever increasing number of calls

00:01:39.969 --> 00:01:47.099
and at the same time adding features like support
for symmetrical multithreading or hyperthreads.

00:01:49.609 --> 00:01:57.819
UNIX is also an extensible system, with things
like switches internally for things like VFS

00:01:57.819 --> 00:02:05.579
where you can add more file systems of different types and
then eventually add new file systems when the need arises

00:02:05.579 --> 00:02:12.870
or launchd which is replaced all the init style
daemons but kept all the interfaces with the rest

00:02:12.870 --> 00:02:21.849
of the system the same, but adding new functionality
to meet the challenges of an ever more dynamic world.

00:02:21.849 --> 00:02:26.049
And it's scalable.

00:02:26.050 --> 00:02:33.390
UNIX has always been a strong SMP scalable
operating system and this has stood us in good stead

00:02:33.389 --> 00:02:35.449
to meet the challenges of the multicore world.

00:02:35.449 --> 00:02:42.679
Now in the Core OS we are a very strong user of open source.

00:02:42.680 --> 00:02:47.520
And in fact there are a very large number
of open source projects that we use,

00:02:47.520 --> 00:02:53.070
in fact over 400 projects in Core OS alone.

00:02:53.069 --> 00:02:58.269
Some of these projects we just take from
the community, we compile them and use them.

00:02:58.270 --> 00:03:05.350
Others, we actively contribute to the technology
pushing the technology forward and yet others still

00:03:05.349 --> 00:03:10.789
where we create the projects, host them on
Mac OS Forge and drive the technology forward.

00:03:10.789 --> 00:03:16.179
An example of that would be Bonjour.

00:03:16.180 --> 00:03:25.150
UNIX is also a portable system and that stood us
in great stead when we moved from PowerPC to Intel.

00:03:25.150 --> 00:03:31.700
That transition was relatively straightforward for us
because of the porting layer of the base of the system.

00:03:31.699 --> 00:03:39.179
But more so, when we started to work on the phone
we could leverage the open source to provide a lot

00:03:39.180 --> 00:03:47.349
of the arms support that we could easily integrate
in making that transition from the Mac to the phone

00:03:47.349 --> 00:03:51.560
at the Core OS level also relatively straightforward.

00:03:51.560 --> 00:03:57.979
But it's not only the system that's
portable, applications are also portable.

00:03:59.189 --> 00:04:05.419
The POSIX standard has been around for a long time
and is very stable and allows your application to move

00:04:05.419 --> 00:04:12.349
around between systems but actually even if you go out
beyond the Core OS and look at the system as a whole.

00:04:12.349 --> 00:04:22.810
There are many shared APIs between the iPhone and
the Mac, and in fact with Leopard and iPhone OS 2.2,

00:04:22.810 --> 00:04:29.259
80% of the APIs available to you on the
phone are also shared with Mac OS X.

00:04:29.259 --> 00:04:30.870
That's a huge number.

00:04:30.870 --> 00:04:41.610
And as we move forward to Snow Leopard and to iPhone OS
3.0, even more of this APIs are shared with the movement

00:04:41.610 --> 00:04:48.110
of things like Core Data coming from the Mac onto the
phone and Core Location from the phone onto the Mac.

00:04:48.110 --> 00:04:55.350
And in fact we've added over 1,400 APIs into
this common set between the two platforms.

00:04:55.350 --> 00:04:58.230
But it's not only APIs that are common.

00:04:58.230 --> 00:05:05.430
In Core OS, 85% of the code that runs
on the phone also is running on the Mac,

00:05:05.430 --> 00:05:12.269
85% and that number is only going to increase.

00:05:12.269 --> 00:05:20.680
So we have a stable foundation at the core of our system
built for innovation, that's UNIX and that forms the center

00:05:20.680 --> 00:05:27.280
of the Core OS, the foundation
technology, from Mac OS X on iPhone OS.

00:05:27.279 --> 00:05:32.909
So I've told you a little bit about the foundation,
so let's talk a little bit about technology.

00:05:34.639 --> 00:05:40.839
The first technology I want to talk about is
Time Machine or more specifically Time Capsule.

00:05:40.839 --> 00:05:47.849
Now when you set up a Time Capsule and you do
your first backup, typically the first backup

00:05:47.850 --> 00:05:51.129
that you do is around about 100 gigabytes.

00:05:51.129 --> 00:05:53.560
That's a fair amount of data.

00:05:55.000 --> 00:06:02.949
Now we have improved the performance of
that initial backup and made it 55% faster.

00:06:02.949 --> 00:06:10.930
That means that you could do your first backup over
Wi-Fi in about 5 1/2 hours, that's easily done overnight.

00:06:10.930 --> 00:06:17.170
Now the interesting thing is that we
didn't optimized Time Machine to do that.

00:06:17.170 --> 00:06:20.439
We actually optimized a whole host of technologies.

00:06:20.439 --> 00:06:27.560
We took a slice across the whole system and made
sure that each part of it was working optimally.

00:06:27.560 --> 00:06:33.639
In Time Machine itself we added support for doing
overlapping IO, in Spotlight we increased the speed

00:06:33.639 --> 00:06:39.149
of indexing, in the networking code we
used hardware checksums whenever possible

00:06:39.149 --> 00:06:46.620
and when not possible we've optimized the software
checksums so that they're as fast as they can possibly be.

00:06:46.620 --> 00:06:50.579
We've increased the speed of journaling
in HFS, we're doing--

00:06:50.579 --> 00:07:00.209
adding concurrency for disc images and for AFP we've
reduced the amount of traffic that goes over the network.

00:07:00.209 --> 00:07:06.459
Now the great thing about this approach where you take
a slice of technology to solve a specific problem is

00:07:06.459 --> 00:07:11.979
that the whole system benefits, all the
applications will benefit from these optimizations.

00:07:11.980 --> 00:07:16.870
So that's Time Capsule.

00:07:16.870 --> 00:07:24.129
So the next technology I want to talk
about keeping in the networking vein

00:07:24.129 --> 00:07:27.659
and the file system vein, are network file systems.

00:07:27.660 --> 00:07:32.030
So let's start off and look at server performance.

00:07:32.029 --> 00:07:41.219
We've done a lot of work to optimize the performance of
our various different network file systems and so for AFP,

00:07:41.220 --> 00:07:45.840
our standard file sharing protocol,
we have increased server performance

00:07:45.839 --> 00:07:51.779
on the AFP bench, benchmark by 30% which is pr0etty good.

00:07:51.779 --> 00:07:59.649
But for NFS using the SPEC SFS 2008 benchmark  we've
doubled the speed of the server performance for NFS.

00:07:59.649 --> 00:08:04.870
And for CIFS which is the Samba implementation,

00:08:04.870 --> 00:08:14.670
that performance again for the SPEC SFS 2008 implementation
is 130% faster in Snow Leopard than it is in Leopard.

00:08:14.670 --> 00:08:22.930
But it's not only the server, we are all sitting
on clients and their performance is important too.

00:08:22.930 --> 00:08:30.420
So if you look at file copy, taking a file
and copying it across in a network volume,

00:08:30.420 --> 00:08:35.340
in AFP we've increased that performance by 30% too.

00:08:35.340 --> 00:08:42.360
With NFS that's gone up by 50% and
SMB, the Windows file sharing protocol,

00:08:42.360 --> 00:08:46.730
is 60% faster for doing a file copy in a share.

00:08:46.730 --> 00:08:57.039
But if you look at opening a finder window on a
network file system, AFP has always done pretty well

00:08:57.039 --> 00:09:04.949
because it's got some great caching technology and we've
taken that caching technology and put it into NFS and to SMB

00:09:04.950 --> 00:09:14.530
which has yielded a massive 5.6 times faster for NFS and
5 times faster for SMB when you open up your finder window

00:09:14.529 --> 00:09:18.509
on a network share, incredible performance improvements.

00:09:18.509 --> 00:09:22.279
And so that's on network file systems.

00:09:22.279 --> 00:09:33.139
The next technology I'd like to talk
about, also in the networking vein is VPN.

00:09:33.139 --> 00:09:39.259
But this time let's talk about the phone.

00:09:39.259 --> 00:09:44.330
Now, you have your phone and on your right
there's your enterprise providing services

00:09:44.330 --> 00:09:47.389
like mail and web and so forth.

00:09:47.389 --> 00:09:57.129
But your phone is outside the firewall so you
try and send the piece of mail and it won't go.

00:09:57.129 --> 00:09:58.500
So what do you do?

00:09:58.500 --> 00:10:06.649
So fortunately, your IS department has or IT department has
configured your phone to use VPN so you go into Settings

00:10:06.649 --> 00:10:12.110
and then General and Network and VPN,
and you find your VPN configuration

00:10:12.110 --> 00:10:16.379
and you select then you have to then put in your password.

00:10:16.379 --> 00:10:26.820
>> Finally when you got all that, you manage to get a
tunnel into your enterprise and then your mail can go out.

00:10:26.820 --> 00:10:28.190
So that's a bit of a challenge.

00:10:28.190 --> 00:10:32.250
I mean that's a lot of work to do in order
to be able to connect your enterprise.

00:10:32.250 --> 00:10:37.929
So what we have done in the Core OS is to take a bunch
of technologies that we had for various different things

00:10:37.929 --> 00:10:44.629
in different places and we've made a feature
called VPN on Demand and how does this work.

00:10:44.629 --> 00:10:50.889
Well you remember your IT department gave you-- the
VPN configuration is called a configuration profile

00:10:50.889 --> 00:10:53.620
and describes which servers you
access and so on and so forth.

00:10:53.620 --> 00:10:59.960
Well what they can do now, if they support
Cisco IPsec is that they can give you,

00:10:59.960 --> 00:11:02.889
in your configuration profile, a certificate.

00:11:02.889 --> 00:11:11.179
Now when you want to use your phone and you look up any
address in the enterprise like mail.myenterprise.com

00:11:11.179 --> 00:11:18.959
which is your mail server, what we do is we see that that's
behind the firewall and we send the certificate over.

00:11:18.960 --> 00:11:25.590
We initiate the VPN connection, open up the
firewall, so your mail just goes straight through.

00:11:25.590 --> 00:11:28.450
There's no user interaction required.

00:11:28.450 --> 00:11:34.020
And the great thing about this is because
we're triggering this off the DNS lookup

00:11:34.019 --> 00:11:38.759
of the application this works regardless
of whether you're sending email,

00:11:38.759 --> 00:11:45.279
whether you're browsing the enterprise's internal
websites or whether there's applications that your IS

00:11:45.279 --> 00:11:49.329
or IT department has given you and put on your phone.

00:11:49.330 --> 00:11:56.780
Any network request that looks up addresses behind the
firewall will trigger this behavior so they all just work.

00:11:56.779 --> 00:12:01.319
So that's VPN.

00:12:02.860 --> 00:12:12.440
The next technology I want to do, again in the
networking vein and again with the phone, is Hotspots.

00:12:12.440 --> 00:12:20.080
Now I'm sure we've all taken our phone into
a cafe or an airport or something like that.

00:12:20.080 --> 00:12:24.480
Got out and tried to look at mail and what do we see?

00:12:24.480 --> 00:12:28.060
We see a spinning cursor but we don't see any new mail.

00:12:29.730 --> 00:12:34.940
Now, if we were smart we'd gone off and looked
at Safari then we'd actually see a login page

00:12:34.940 --> 00:12:38.680
that this is what they were asking you to do.

00:12:38.679 --> 00:12:44.139
So you type in your username or was it the phone number

00:12:44.139 --> 00:12:48.009
or maybe it was a home phone number
or perhaps it was that account number.

00:12:48.009 --> 00:12:52.939
But anyway, whichever one what it was you type
that in and the password if you can remember it

00:12:52.940 --> 00:12:56.740
and then you can get access to the Hotspot.

00:12:56.740 --> 00:13:00.139
We don't think that's a particularly good experience either.

00:13:01.409 --> 00:13:05.939
Now these hotspots are what we call captive networks.

00:13:05.940 --> 00:13:13.720
These are the networks that you find in say airports, in
hotels, in coffee shops, McDonald's, that actually allow you

00:13:13.720 --> 00:13:20.090
to associate with the network but then don't give you
access to the internet as a whole because they want you

00:13:20.090 --> 00:13:28.129
to authenticate to allow you to say that you agree to
their terms or have paid or whatever it is that they do.

00:13:28.129 --> 00:13:32.439
So we've introduced some technologies
to be able to handle captive networks.

00:13:32.440 --> 00:13:34.800
So what does that do?

00:13:34.799 --> 00:13:40.169
So when you associate with the network, we
send a little test URL with the expectation

00:13:40.169 --> 00:13:42.639
that it comes back and says you're connected.

00:13:42.639 --> 00:13:49.569
But on these hotspots you're not and so it sent you back
a login page and we spot that and so we mark your phone

00:13:49.570 --> 00:13:52.520
as being captive which is our little fence here.

00:13:52.519 --> 00:14:00.490
And as soon as we notice that you're
captive what we do is bring on a web sheet.

00:14:00.490 --> 00:14:01.940
This is not the Safari as a whole.

00:14:01.940 --> 00:14:09.310
This is just a single page that provides you with a
login page so that you can type in your credentials.

00:14:09.309 --> 00:14:21.309
And once you've done that as in any Safari page we send it
back to the Hotspot but inside there's a couple of strings,

00:14:21.309 --> 00:14:27.209
one containing your username and one containing
your password and we spot that as it goes past.

00:14:27.210 --> 00:14:28.190
And we save it away.

00:14:28.190 --> 00:14:33.600
And once we've done that, we take away the web sheet.

00:14:33.600 --> 00:14:37.420
You're no longer captive so you
can access the internet but you--

00:14:37.419 --> 00:14:42.979
the key thing to notice is that you're back at
the application that you were using at the time

00:14:42.980 --> 00:14:48.000
that you turned the phone on in the Hotspot
which is a much, much better experience.

00:14:48.000 --> 00:14:54.769
[ Applause ]

00:14:54.769 --> 00:14:57.579
>> But it gets better.

00:14:57.580 --> 00:14:59.860
You want a second cup of coffee.

00:15:01.490 --> 00:15:07.889
So what happens now is that you go back into the
hotspot, where, Starbucks obviously, test URL goes back,

00:15:07.889 --> 00:15:12.029
we mark it as captive, you have the fence around your phone.

00:15:12.029 --> 00:15:18.549
But many of these hotspots implement a protocol
called Whisper and what Whisper allows you to do is

00:15:18.549 --> 00:15:25.439
to silently authenticate to the hotspot and so
what we do is that we remember your credentials,

00:15:25.440 --> 00:15:29.930
we get them out of the keychain and behind
your back we pass them over to the hotspot

00:15:29.929 --> 00:15:33.219
and then it authenticates and you're no longer captive.

00:15:33.220 --> 00:15:36.500
Now the thing to notice here is that there was no UI.

00:15:36.500 --> 00:15:45.590
You turned on your phone, it authenticated behind
the scenes and you're good to go, no UI whatsoever.

00:15:45.590 --> 00:15:48.000
And so that is our hotspot support.

00:15:48.000 --> 00:15:55.899
[ Applause ]

00:15:55.899 --> 00:15:58.990
>> I can tell you I like that one.

00:15:58.990 --> 00:16:04.769
The next technology again in the
networking space we'll talk about Bonjour.

00:16:04.769 --> 00:16:08.189
Now I have a sleeping problem.

00:16:08.190 --> 00:16:16.800
I have a printing sleeping problem so there's my computer
upstairs, it's the family computer, it's in the den

00:16:16.799 --> 00:16:20.649
and that is the printer connected
to it, it's the family's computer.

00:16:20.649 --> 00:16:25.639
Downstairs though in the study I have another computer which
you know I work on and I'm sitting there doing a document

00:16:25.639 --> 00:16:29.009
or whatever it is, and I decide I need to print something.

00:16:29.009 --> 00:16:31.340
So there's my document going up.

00:16:31.340 --> 00:16:38.670
Unfortunately, this machine upstairs is asleep so
it's like I don't have a computer, a printer, sorry.

00:16:38.669 --> 00:16:42.019
So I can't print, that's a problem.

00:16:43.820 --> 00:16:44.950
I have a streaming problem.

00:16:44.950 --> 00:16:47.610
There is the computer upstairs again running iTunes.

00:16:47.610 --> 00:16:52.110
iTunes has this great feature where you can
stream content to another machine and downstairs

00:16:52.110 --> 00:16:56.409
in the living room we're all rocking
out on our Apple TV streaming the music

00:16:56.409 --> 00:17:00.860
from our family music collection up on the iMac.

00:17:00.860 --> 00:17:05.839
Unfortunately, when that's asleep
you don't have any content.

00:17:07.240 --> 00:17:11.120
And finally, I have a back to my Mac problem.

00:17:11.119 --> 00:17:13.599
So there's my machine in the study.

00:17:13.599 --> 00:17:18.879
I was working on this presentation last
night and busy changing last minute things

00:17:18.880 --> 00:17:23.330
and the next morning a bit sleepy,
I go to work and I forget it.

00:17:23.329 --> 00:17:26.879
There's my office, well actually, there's my office.

00:17:26.880 --> 00:17:36.820
[Laughter] And fortunately, I have MobileMe and back to
my Mac so it's no problem, connect to my machine at home,

00:17:36.819 --> 00:17:40.129
get the presentation, I'm all set for today.

00:17:40.130 --> 00:17:46.140
Except that the machine is asleep so I'm stuck

00:17:46.140 --> 00:17:49.980
Now there is a solution to this
problem, it's a very simple solution.

00:17:49.980 --> 00:17:56.170
It's leave your computer on but that's a really
powerful solution and then not a good solution

00:17:56.170 --> 00:18:02.880
and we need a more energy efficient solution
because basically it's good to go to sleep.

00:18:02.880 --> 00:18:10.200
We want you to leave your machines so that they can
go and-- they can sleep and be energy efficient.

00:18:10.200 --> 00:18:12.960
So what's the solution?

00:18:12.960 --> 00:18:17.029
The solution is the Bonjour Sleep Proxy.

00:18:17.029 --> 00:18:19.710
Now how does that work?

00:18:19.710 --> 00:18:25.890
Well in your house, you have a
device that is on all the time.

00:18:25.890 --> 00:18:33.840
It's called your AirPort Extreme and it consumes
very little power so this is a perfect machine to use

00:18:33.839 --> 00:18:36.199
in order to keep your services available.

00:18:36.200 --> 00:18:41.860
So how this works is that when your machine
goes to sleep, your computer goes to sleep,

00:18:41.859 --> 00:18:46.449
it sends all the Bonjour service
records down to the AirPort Extreme.

00:18:46.450 --> 00:18:49.660
Say I have a printer.

00:18:49.660 --> 00:18:54.840
The AirPort Extreme immediately steals that IP
address of the machine and as far as the rest

00:18:54.839 --> 00:19:00.319
of the network is concerned it is
your computer with the printer.

00:19:00.319 --> 00:19:05.659
So now in the den I'm trying to print my document.

00:19:05.660 --> 00:19:11.070
And so I connect to the machine that I thought
was the computer with the printer attached to it.

00:19:11.069 --> 00:19:15.849
The AirPort Extreme will wake up
my computer upstairs in the den.

00:19:15.849 --> 00:19:19.669
It immediately steals back the IP
address from the AirPort Extreme.

00:19:19.670 --> 00:19:25.610
And so now my print goes through with
no user interaction from me in the den

00:19:25.609 --> 00:19:28.389
and no one running upstairs to wake up the machine.

00:19:28.390 --> 00:19:31.150
That's the Bonjour Sleep Proxy.

00:19:31.150 --> 00:19:34.000
And it solves all those problems.

00:19:34.000 --> 00:19:39.579
[ Applause ]

00:19:39.579 --> 00:19:43.539
>> So what do you need to do to take advantage of this?

00:19:43.539 --> 00:19:47.170
Well if you are using the Bonjour service
and connection APIs you don't need

00:19:47.170 --> 00:19:51.019
to do anything at all, all this just happens by magic.

00:19:51.019 --> 00:19:55.680
If you're not, you need to start looking at
these APIs and adopting them in your code

00:19:55.680 --> 00:19:58.690
as opposed to directly connecting services.

00:19:58.690 --> 00:20:03.230
But if you think about what we've done, we've taken Bonjour

00:20:03.230 --> 00:20:09.319
which is a local subdomain service
discovery and connection protocol.

00:20:10.569 --> 00:20:20.549
>> We've added wide area access so you can now get to
the computer from anywhere and the Bonjour Sleep Proxy

00:20:20.549 --> 00:20:26.629
which means you can now get to any machine
regardless of whether it's asleep or awake.

00:20:26.630 --> 00:20:34.170
So you can get access to any machine from
anywhere in the world regardless of its state.

00:20:34.170 --> 00:20:41.310
So what you need to do is to think about how you can take
advantage of that and innovate on top of our platform.

00:20:41.309 --> 00:20:45.730
And that's the Bonjour Sleep Proxy.

00:20:47.000 --> 00:20:53.750
[ Applause ]

00:20:53.750 --> 00:20:57.390
>> Now the next technology I want to talk about
we've heard a little bit about this morning

00:20:57.390 --> 00:21:02.870
but I should go into a little bit more detail.

00:21:02.869 --> 00:21:07.719
GCD is a technology that is designed
to address the problems of multicore.

00:21:07.720 --> 00:21:13.740
The big problem with multicore as we've heard earlier on is

00:21:13.740 --> 00:21:19.609
that our solutions are really SMP
based i.e. program in threads.

00:21:19.609 --> 00:21:23.679
But threads are hard.

00:21:23.680 --> 00:21:27.259
First of all you don't know how many to create.

00:21:27.259 --> 00:21:29.430
And the reason that you don't know how many to create is

00:21:29.430 --> 00:21:34.049
because you don't really know how
many resources are available to you.

00:21:34.049 --> 00:21:38.230
And not only that, but even the resources
that you have, the threads that you created,

00:21:38.230 --> 00:21:43.990
you don't really know whether they're blocked
or not so it's really hard for you outside

00:21:43.990 --> 00:21:47.750
of the system to know how many threads you need.

00:21:47.750 --> 00:21:53.579
And if that wasn't bad enough we
have these guys to deal with.

00:21:53.579 --> 00:21:58.039
You have to work out how to lock
and synchronize your application.

00:21:58.039 --> 00:22:03.809
How many locks do you need, what's the granularity,
you don't want too many because that puts too much

00:22:03.809 --> 00:22:06.659
of an overhead on your application, you don't want too few

00:22:06.660 --> 00:22:11.650
because then you won't get the concurrency
and you'll end up having contention.

00:22:11.650 --> 00:22:20.030
So having all these locks, now you need to deal with lock
hierarchies otherwise you end up with this guy, deadlock.

00:22:20.029 --> 00:22:25.990
So our solution is Grand Central Dispatch.

00:22:25.990 --> 00:22:30.620
Now the goals for Grand Central Dispatch
are actually relatively straightforward.

00:22:30.619 --> 00:22:35.459
It's a programming model for multicores.

00:22:35.460 --> 00:22:42.890
What you have to do as an application is to break your
application into blocks of work and we help you do that.

00:22:42.890 --> 00:22:47.460
You then hand those blocks of work
and the OS gets the work done.

00:22:47.460 --> 00:22:56.640
It takes care of all those details that you
didn't have enough information to be able to deal.

00:22:56.640 --> 00:23:00.040
So we've designed a whole new multicore engine.

00:23:01.859 --> 00:23:09.750
It consists of an ultra fast user space scheduler
to be able to switch between your blocks of work.

00:23:09.750 --> 00:23:14.450
It has optimal thread management,
always the right number of threads

00:23:14.450 --> 00:23:18.690
to maximize your concurrency and
never get the spinning pizza.

00:23:20.930 --> 00:23:32.070
We've simplified event handling dramatically and also
we have a simple synchronization method based on queues

00:23:32.069 --> 00:23:37.809
and all this is a new powerful multicore engine for GCD.

00:23:37.809 --> 00:23:39.440
So what are blocks of work look like?

00:23:39.440 --> 00:23:42.809
Well, it's relatively straightforward as I say.

00:23:42.809 --> 00:23:47.779
You just cut your application into
these blocks, queue them up with GCD,

00:23:47.779 --> 00:23:55.500
GCD then will find out how many resources are available
to it and schedules these little trains down the tracks

00:23:55.500 --> 00:24:05.200
and because it's part of the system, when more CPUs become
available, GCD creates more threads, schedules more work

00:24:05.200 --> 00:24:10.660
and your application gets better performance
without you having to do anything.

00:24:10.660 --> 00:24:12.580
Now we did this in our own applications.

00:24:12.579 --> 00:24:17.339
So if you look at Preview for example, it starts
off with-- in Leopard which is on the left.

00:24:17.339 --> 00:24:23.079
It starts off with a few threads, creates lot
of threads when this particular benchmark,

00:24:23.079 --> 00:24:31.069
which is basically a repeated page load of complex pages,
creates lots of threads to be able to deal with the load.

00:24:31.069 --> 00:24:35.500
When it's finished it tries its best to clean up but
the reality is that there's a lot of threads left over,

00:24:35.500 --> 00:24:39.869
normally for things like event handling and so forth.

00:24:39.869 --> 00:24:47.959
In Snow Leopard, we made Preview use GCD and as you
can see it starts off with a small number of threads,

00:24:47.960 --> 00:24:56.200
it scales much better, and then when the work is
done it drops back to a sensible number of threads,

00:24:56.200 --> 00:24:59.039
doesn't use up the resources of the system.

00:24:59.039 --> 00:25:05.009
And we did this not only with Preview but also with
Mail and you could see a significant difference there.

00:25:05.009 --> 00:25:11.950
Interestingly with Mail, with GCD we create more threads
than we did with Leopard and the reason is that, as I say,

00:25:11.950 --> 00:25:19.990
it's hard to judge exactly how many you need, and
we suspect that in Leopard we didn't create enough.

00:25:19.990 --> 00:25:28.349
Similarly with iChat, the same story, better
size to under load, saving resources when idle.

00:25:28.349 --> 00:25:33.469
Now, if you can imagine how this works when
you apply this to every single application,

00:25:33.470 --> 00:25:36.410
most application is idle for a lot of their lifetimes.

00:25:36.410 --> 00:25:39.240
That means that the number of system
resources with the threads,

00:25:39.240 --> 00:25:43.309
with their kernel representations has dropped dramatically.

00:25:43.309 --> 00:25:47.099
These are resources that your application can now use.

00:25:49.170 --> 00:25:54.029
So GCD has a highly tuned engine.

00:25:54.029 --> 00:25:56.099
It's incredibly low overhead.

00:25:56.099 --> 00:26:02.939
The overhead to switch between a completed piece of work
and the next piece of work is the order of a function call.

00:26:02.940 --> 00:26:05.430
That's amazingly fast.

00:26:05.430 --> 00:26:10.110
GCD is implemented with a completely lockless scheduler.

00:26:10.109 --> 00:26:13.279
It uses wait-free algorithms and what that means to you is

00:26:13.279 --> 00:26:19.750
that you can now implement your
application in a lockless way too.

00:26:19.750 --> 00:26:30.420
GCD scales up not only when you move it from a 2-core
MacBook to an 8-core MacPro but actually running it

00:26:30.420 --> 00:26:35.700
on a machine with lots of cores that
has load and then that load lessens.

00:26:35.700 --> 00:26:41.759
GCD will automatically expand up
as the system becomes free for you.

00:26:41.759 --> 00:26:47.069
It scales down to which means when the load goes back
up on that system it scales back the number of resources

00:26:47.069 --> 00:26:53.960
that it uses to stop that bit from-- the system
from contending and thrashing on resources.

00:26:53.960 --> 00:27:00.100
And in fact it scales down so far that even if you
have only a single CPU available to your application,

00:27:00.099 --> 00:27:05.349
the overhead on the system is so low
that it's still highly efficient.

00:27:06.500 --> 00:27:08.509
So we have a comprehensive solution.

00:27:08.509 --> 00:27:13.650
Not only do we have this multicore
engine but we have a language extension

00:27:13.650 --> 00:27:16.640
to make it simple for you to create these blocks of work.

00:27:16.640 --> 00:27:19.220
We have an object-oriented framework.

00:27:19.220 --> 00:27:22.579
We have new system-wide APIs and some tools.

00:27:22.579 --> 00:27:25.720
So let me talk through them.

00:27:25.720 --> 00:27:32.690
The language extension is very, very simple
in order for you to create lots of work.

00:27:32.690 --> 00:27:38.000
Basically it's like a function pointer
but instead of a star it's a little caret.

00:27:39.140 --> 00:27:44.810
And you place it in front of the curly braces of
your section of code and that now defines a block

00:27:44.809 --> 00:27:47.599
which you have appointed to, that you can hand to GCD.

00:27:47.599 --> 00:27:53.069
It's as simple as that.

00:27:53.069 --> 00:27:57.710
Now in Leopard we have an object-oriented
framework which we introduced called NSOperation

00:27:57.710 --> 00:28:06.990
and NSOperation is a very high level framework that actually
allows you to basically queue work up in a very similar way

00:28:06.990 --> 00:28:11.150
to GCD but it was a very high level framework.

00:28:11.150 --> 00:28:18.570
This was so successful that we've extended the
functionality to allow you to solve more complex problems

00:28:18.569 --> 00:28:22.839
and we built in Snow Leopard the dispatch framework.

00:28:22.839 --> 00:28:27.179
And in fact, it's so efficient that
we've implemented NSOperation in terms

00:28:27.180 --> 00:28:30.440
of dispatch so they're tightly integrated.

00:28:33.839 --> 00:28:36.409
We have many new systemwide APIs.

00:28:36.410 --> 00:28:44.290
Now all these frameworks tend to generate events so
whether it's fast system events or spotlight searches

00:28:44.289 --> 00:28:51.920
or network connectivity changes or reachability
changes, all these things are generating events.

00:28:51.920 --> 00:28:59.110
All these frameworks have got additional APIs which allow
you to define a block of code that you want to be executed

00:28:59.109 --> 00:29:06.679
when that event occurs and then the GCD queue that you
want it to be executed on when that event triggers.

00:29:06.680 --> 00:29:12.450
No more event loops, much, much
simpler event source handling.

00:29:12.450 --> 00:29:16.620
And this is the way it works, right.

00:29:16.619 --> 00:29:22.979
There's your work coming in on your blocks and suddenly
a file system event happens without you doing anything.

00:29:22.980 --> 00:29:31.069
It's just queued onto the GCD queue and then
managed in exactly the same way as all your work.

00:29:31.069 --> 00:29:37.970
The system will scale up and scale down and
then when the work is complete it tidies up.

00:29:37.970 --> 00:29:43.339
Very simple event management story.

00:29:43.339 --> 00:29:49.789
We've also extended Instruments to be able to
understand blocks and introspect what's going on.

00:29:49.789 --> 00:29:56.559
And there are three main areas, so this is the blocks
view that allows you to look at a list of all your blocks.

00:29:56.559 --> 00:30:01.009
There is one that allows you to look all the
queues and all the blocks that are attached to it.

00:30:01.009 --> 00:30:07.640
And there's another one, a core tree which allows you to
see what an individual block is doing in any given instant.

00:30:07.640 --> 00:30:16.930
It's a very power tools set and helps you understand
and introspect exactly what your application is doing.

00:30:16.930 --> 00:30:22.289
>> Now a little earlier on we saw Richard
Wright come and talk to us about Seeker

00:30:22.289 --> 00:30:32.750
and how he took a single threaded app and in a relatively
straightforward way he managed to get multicore performance

00:30:32.750 --> 00:30:36.900
by using as little 12 lines of GCD, of code calling GCD.

00:30:36.900 --> 00:30:45.480
That was pretty astonishing but what happens if you
already have a multithreaded app, what does that look like?

00:30:45.480 --> 00:30:53.569
Well I'd like to invite up on the stage Paul Carnine
who's a senior software engineer at Telestream to tell us

00:30:53.569 --> 00:30:56.899
about their experience of taking
a multithreaded app and using GCD.

00:30:56.900 --> 00:30:59.000
Welcome Paul.

00:30:59.000 --> 00:31:05.200
[ Applause ]

00:31:05.200 --> 00:31:09.299
>> I'm one of the developers working on
ScreenFlow and we've taken a quick look

00:31:09.299 --> 00:31:11.419
at optimizing ScreenFlow for Snow Leopard.

00:31:11.420 --> 00:31:19.910
Now some of you may know ScreenFlow is a screen casting
studio application that offers a streamline workflow

00:31:19.910 --> 00:31:22.240
for being able to create a video of your desktop.

00:31:22.240 --> 00:31:27.170
It also has an editor which you can see up here
and this editor allows you to create a very,

00:31:27.170 --> 00:31:36.700
very complex presentation using various sources such as your
iSight, your desktop of course, images, and all of these--

00:31:36.700 --> 00:31:39.990
any media you've got floating around in your disc.

00:31:39.990 --> 00:31:45.130
Now you can export that to disc and the process to export
inside of ScreenFlow is quite simple from a user point

00:31:45.130 --> 00:31:49.090
of view but from our point of view
inside the code, it's very complicated.

00:31:49.089 --> 00:31:55.169
If you think about the pipeline that needs to happen from
decoding all your sources, to going all the way through,

00:31:55.170 --> 00:32:01.240
to compositing them, and then sending them off to the
H.264 code that can go into disc, it's very complicated.

00:32:01.240 --> 00:32:07.410
And we spent a great deal of effort under the
current Leopard Operating System optimizing that.

00:32:07.410 --> 00:32:13.910
We have some very low level optimizations, SSE all of this
fun things and we have some very high level optimizations.

00:32:13.910 --> 00:32:21.730
We use a lot of pthreads inside of ScreenFlow during the
export process to optimize the export and to do that,

00:32:21.730 --> 00:32:25.920
we have well over 2,000 lines of simply glue code.

00:32:25.920 --> 00:32:31.750
So if we're talking about complications, it's
quite complicated to write this kind of stuff.

00:32:31.750 --> 00:32:35.960
Now the great thing is that Grand Central
Dispatch can do away with all of that code

00:32:35.960 --> 00:32:40.180
and in some instances you can just have one line of code

00:32:40.180 --> 00:32:43.950
that will actually allow you to
take advantage of multicore CPUs.

00:32:43.950 --> 00:32:50.640
So we said, OK, let's take a look at this and let's try
and improve even better our export inside of ScreenFlow.

00:32:50.640 --> 00:32:55.560
So we did what anyone of you would do, we'd fire up Shark,
we look to the Shark clocks, we'd fire up Instruments,

00:32:55.559 --> 00:33:02.099
we look at the traces, and we'd look-- we'd find our
hotspots and then all we do is trace up the stack

00:33:02.099 --> 00:33:04.789
and try and find the best place to fix this.

00:33:04.789 --> 00:33:10.069
Now the best thing is that GCD is so
simple that we're able to experiment.

00:33:10.069 --> 00:33:14.319
With pthreads it's a little more difficult
to find the best place to optimize.

00:33:14.319 --> 00:33:20.480
So with GCD we just throw in a change
here and we might get a 3% boost.

00:33:20.480 --> 00:33:21.559
Oh, that's great.

00:33:21.559 --> 00:33:25.960
We'd throw in another change and we'd
get 5 or 10% boost and remember this is

00:33:25.960 --> 00:33:33.319
with an application that's already heavily optimized
and uses pthreads all throughout the export process.

00:33:33.319 --> 00:33:38.500
Now in the end ScreenFlow with the future release
of ScreenFlow running under Snow Leopard we'll see

00:33:38.500 --> 00:33:46.730
up to two times speed improvement during export thanks GCD
and the best part is that it uses a heck of a lot less code.

00:33:46.730 --> 00:33:49.000
So I suggest that you guys go and check it out.

00:33:49.000 --> 00:33:56.029
[ Applause ]

00:33:56.029 --> 00:33:58.119
>> Thank you, Paul.

00:33:58.119 --> 00:34:02.269
So whether you're starting from a single threaded
application and wanting to get some parallelism

00:34:02.269 --> 00:34:07.200
on the multicore machines or whether you already
have a threaded application and you just need

00:34:07.200 --> 00:34:10.000
that turbo boost, then GCD is your answer.

00:34:10.000 --> 00:34:17.289
The next technology I want to talk to you about is 64-bit.

00:34:18.380 --> 00:34:24.980
So we started our 64-bit journey in Tiger
with the support for 64-bit UNIX appdlications.

00:34:24.980 --> 00:34:32.269
Now these applications were really your scientific or
high performance computing UNIX apps, the non-GUI apps.

00:34:32.269 --> 00:34:40.489
In Leopard, we went all the way up the framework
stack to support full GUI 64-bit Cocoa applications.

00:34:40.489 --> 00:34:49.989
And in Snow Leopard we have 64-bit applications,
a 32-bit application is also on the same system

00:34:49.989 --> 00:34:59.000
but more interestingly, 64-bit system applications,
all the major system applications are now 64-bit.

00:34:59.000 --> 00:35:00.659
So we're done, right, that's it.

00:35:00.659 --> 00:35:15.420
Or not quite, the kernel is still a 32-bit program and what
we've done in Snow Leopard is we built a 64-bit kernel.

00:35:15.420 --> 00:35:18.050
So why would we want to do that?

00:35:18.050 --> 00:35:22.840
Well, the reason is that physical
RAM sizes are rapidly increasing.

00:35:22.840 --> 00:35:35.130
You can see we went from 1 or 2 GB back in 2005, 2006; 16
GB in 2006 and 2007, up to 32 GB in 2008 and today w e're

00:35:35.130 --> 00:35:42.360
up to 48 GB and very soon, as soon as they get enough
dense actually, you should be able to put 96 GB

00:35:42.360 --> 00:35:48.000
of physical memory into-- in some of our
configurations of Xserve and Mac Pro.

00:35:48.000 --> 00:35:50.360
So what does that mean?

00:35:50.360 --> 00:35:58.740
Well in the kernel it takes 64 bytes, not very
much, to describe each 4K page of physical memory.

00:35:58.739 --> 00:36:05.349
Unfortunately, with 96 GB of RAM that's
1.5 GB of kernel virtual address base,

00:36:05.349 --> 00:36:11.670
and so almost a third of the kernel's virtual address space
just to describe physical memory that doesn't include any

00:36:11.670 --> 00:36:16.119
of the VM data structures, any of the
processed data structures, any of your VNotes,

00:36:16.119 --> 00:36:20.869
any of the file data that you've got cached, any of
the graphics memory that you have mapped, nothing.

00:36:20.869 --> 00:36:25.069
So basically, the kernel has run out of address space.

00:36:25.070 --> 00:36:27.140
So that's why we did a 64-bit kernel.

00:36:27.139 --> 00:36:31.980
But what does it mean for your apps?

00:36:31.980 --> 00:36:38.199
Well the 64-bit kernel has the exact same user kernel
interface which is not the read and write system call.

00:36:38.199 --> 00:36:42.069
That's actually the system call trap
in getting into the kernel mode,

00:36:42.070 --> 00:36:46.690
as the 32-bit kernel which we planned awhile ago.

00:36:46.690 --> 00:36:57.460
So your apps are 100% compatible with a 32-bit and a
64-bit kernel which is good news but there's better news.

00:36:57.460 --> 00:37:04.190
The system call entry point for 64-bit kernel is
actually is 250% faster than Pit is on a 32-bit kernel.

00:37:04.190 --> 00:37:10.130
Now you've probably never see that actually if you
try and benchmark the system because it doesn't happen

00:37:10.130 --> 00:37:12.940
that often and unless you use micro benchmarks.

00:37:12.940 --> 00:37:17.889
But the one that you will see is that there
is a 70% improvemepnt in the performance

00:37:17.889 --> 00:37:23.929
of the user kernel memory copy and you see
that because of things like read and write.

00:37:23.929 --> 00:37:27.829
So the 64-bit kernel actually brings
you performance improvements too.

00:37:27.829 --> 00:37:34.619
But there are things that you do in
the kernel as well, there are KEXTs.

00:37:34.619 --> 00:37:43.179
Now as I said the 64-bit kernel runs on some Xserve and
Mac Pro configurations but we expect that overtime to go

00:37:43.179 --> 00:37:51.619
across a broader set of machines and so consequently
at Apple, all of our KEXTs are both 32-bit and 64-bit.

00:37:51.619 --> 00:37:57.460
But we need all KEXTs to be 64-bit,
that's all of your KEXTs.

00:37:57.460 --> 00:38:03.309
Now we have removed a few KPIs but these were
deprecated anyway so that shouldn't be a problem for you.

00:38:03.309 --> 00:38:08.489
And then there are a couple of extra ones that we had
to remove because they were really very 32-bit specific2

00:38:08.489 --> 00:38:15.559
but there are new KPIs that replace them
that are not dependent on the word size.

00:38:15.559 --> 00:38:21.880
The remaining KPIs are fundamentally unchanged and
what we found in our experience of bringing KEXTs

00:38:21.880 --> 00:38:25.730
over to the 64-bit world is that
most of them just recompile.

00:38:25.730 --> 00:38:32.300
And so that's what we would like you to do to your KEXTs.

00:38:32.300 --> 00:38:43.480
So that's K64 the 64-bit kernel
which completes our 64-bit story.

00:38:43.480 --> 00:38:47.809
Now one thing I'd like to do is to remind you
of the calls to action that I've done today.

00:38:47.809 --> 00:38:57.619
For Bonjour, you need to adopt the Bonjour service
discovery and connection APIs and to look at what we've done

00:38:57.619 --> 00:39:05.650
with Bonjour to allow you to get to any machine from
anywhere in any state and see what you can do with that.

00:39:05.650 --> 00:39:10.740
GCD, give your application a turbo boost.

00:39:10.739 --> 00:39:16.469
Deal with the multicore situation, it's
very straightforward and very powerful.

00:39:16.469 --> 00:39:23.149
And 64-bit, those 64-bit KEXTs,
we need them to be converted.

00:39:23.150 --> 00:39:29.559
And so that's the end of my wander through the technology.

00:39:29.559 --> 00:39:38.039
We have two great products, Mac OS
X Snow Leopard and iPhone OS 3.0.

00:39:38.039 --> 00:39:45.960
Two great products, at the heart of which we have
one great technology in the Core OS and that's it.

00:39:45.960 --> 00:39:47.000
Thank you very much.

00:39:47.000 --> 00:39:53.380
[ Applause ]
WEBVTT

00:00:12.769 --> 00:00:17.420
>> My name is William Turner and
I'm in Developer Technical Support

00:00:17.420 --> 00:00:20.410
and I've probably worked with some of you over email.

00:00:20.410 --> 00:00:22.859
So let's get started.

00:00:22.859 --> 00:00:29.939
UIWebView is how you can take the internet and
rich content and display it directly in your app.

00:00:29.940 --> 00:00:35.789
You don't need to exit to Safari,
its right there, part of your app.

00:00:35.789 --> 00:00:42.759
So in this session we're going to
cover what UIWebView is, how to use it,

00:00:42.759 --> 00:00:46.719
we'll dig into the best practices for using UIWebView.

00:00:46.719 --> 00:00:52.149
Then we'll tackle some advanced topics,
some more interesting, trickier challenges,

00:00:52.149 --> 00:00:59.149
and finally we'll cap it off with
some new editions in iPhone OS 3.0.

00:00:59.149 --> 00:01:02.210
So UIWebView, rich content in your app.

00:01:02.210 --> 00:01:06.210
Let's start off with text.

00:01:06.209 --> 00:01:11.189
The challenge on iPhone is that text presentation is simple.

00:01:11.189 --> 00:01:17.659
You have UILabel, UITextField,
TextView, you can draw strings directly,

00:01:17.659 --> 00:01:22.450
but in all of these cases, it's
a single font, a single color.

00:01:22.450 --> 00:01:26.480
That's great for a lot of uses, but
sometimes you just need to add some style.

00:01:26.480 --> 00:01:29.840
So, here's another issue.

00:01:29.840 --> 00:01:34.140
You've got documents and you want
to display them in your application.

00:01:34.140 --> 00:01:36.760
Maybe it's a business app, you want to show a spreadsheet,

00:01:36.760 --> 00:01:41.780
or you'd like to show word processing
document, how do you do this?

00:01:41.780 --> 00:01:49.790
You need to display a PDF, iWork, you
want to view these documents but how?

00:01:49.790 --> 00:01:53.250
Another thing, there's a big Web
out there, there's a lot of content,

00:01:53.250 --> 00:01:57.489
you can enhance your user's experience
by tapping into that content.

00:01:57.489 --> 00:02:01.619
You know, we can always launch
a URL to open it up in Safari.

00:02:01.620 --> 00:02:08.500
But how much better would it be if we
could just keep it right there in the app?

00:02:08.500 --> 00:02:14.289
Or maybe you're a web developer and you
already have a really incredible web app.

00:02:14.289 --> 00:02:17.090
But you'd like to tap in to native functionality.

00:02:17.090 --> 00:02:23.110
UIKit, Address Book, Accelerometer, MapKit, you name it.

00:02:23.110 --> 00:02:27.760
Well, you don't want to start over, you
just want to enhance what you've got.

00:02:27.759 --> 00:02:32.229
So the solution to all of these challenges is UIWebView.

00:02:32.229 --> 00:02:36.689
It's a subclass of UIView, which
means you can embed it directly

00:02:36.689 --> 00:02:39.719
in your View hierarchy, just like you would any other view.

00:02:39.719 --> 00:02:47.219
And it renders a variety of content types that we'll talk
about, it provides basic browsing function, forward, back,

00:02:47.219 --> 00:02:57.259
reload, and it's powered by WebKit which is a first class
standard compliant rendering engine for web content.

00:02:57.259 --> 00:03:03.659
WebKit supports the content types, of
course HTML, and that's HTML 5.0, with CSS,

00:03:03.659 --> 00:03:07.549
JavaScript, and also renders PDF directly.

00:03:07.550 --> 00:03:09.570
You want styled text in your app?

00:03:09.569 --> 00:03:10.989
Just use HTML.

00:03:10.990 --> 00:03:14.080
You can't get much easier than that.

00:03:14.080 --> 00:03:17.170
So UIWebView also adds documents.

00:03:17.169 --> 00:03:25.829
WebView converts these documents to HTML and then WebKit
renders them and then that result is displayed in UIWebView.

00:03:25.830 --> 00:03:33.810
The supported types of documents include iWork
06 and newer, Microsoft Office 97 and newer,

00:03:33.810 --> 00:03:40.289
and now in 3.0 we've added rich
text and rich text directories.

00:03:40.289 --> 00:03:44.469
So UIWebView is the solution to all these problems.

00:03:44.469 --> 00:03:52.949
Use it when you want to display style content, show
document previews, embed web resources in your application,

00:03:52.949 --> 00:03:56.099
and you want to extend web apps with native functionality.

00:03:56.099 --> 00:03:59.620
So that's what UIWebView is.

00:03:59.620 --> 00:04:03.680
Now let's talk about how to use it.

00:04:06.550 --> 00:04:13.120
So I've got a couple design patterns to talk
about but I won't get too academic with you.

00:04:13.120 --> 00:04:21.360
We've got UIWebView which is the main class, and then
you've got UIWebViewDelegate which is a protocol that your,

00:04:21.360 --> 00:04:27.620
one of your controllers in your application, probably a
view controller will adopt this protocol and that's a way

00:04:27.620 --> 00:04:34.370
for the WebView to notify the controller
when a load is happening, when it's finished,

00:04:34.370 --> 00:04:37.389
or if there's an error, and allow you to handle that.

00:04:37.389 --> 00:04:47.149
And then the smaller, the bit players in this little cast
are the URL's, your HTML content, and JavaScript of course.

00:04:47.149 --> 00:04:49.299
So how do they interact?

00:04:49.300 --> 00:04:56.319
Well it's probably going to start with your controller,
it's going to request that the WebView load a URL

00:04:56.319 --> 00:05:02.149
or just some HTML data directly, and anytime
the WebView is asked to load a resource,

00:05:02.149 --> 00:05:06.359
it goes right back to the delegate
and says do you want me to load this?

00:05:06.360 --> 00:05:11.629
Because sometimes you might not want it to load that or
you may want to take some modifying action with the load.

00:05:11.629 --> 00:05:18.579
Then it will start loading the request and this could
take some time because it's often a network activity.

00:05:18.579 --> 00:05:26.389
And when it finishes or if there's a problem, it'll cap
it off by letting the delegate know what's happened.

00:05:26.389 --> 00:05:29.079
The life cycle of a WebView.

00:05:29.079 --> 00:05:33.919
So there's a little caveat I want to touch on
here, mostly you've probably, it's pretty obvious,

00:05:33.920 --> 00:05:41.689
you start off by creating the WebView and then you're going
to set its delegate, you're going to load the content,

00:05:41.689 --> 00:05:43.569
work with the content, do whatever you need to do,

00:05:43.569 --> 00:05:48.089
and then at some point you're done
with it and you want to release it.

00:05:48.089 --> 00:05:51.869
We just have to insert one really important step here.

00:05:51.870 --> 00:05:57.439
Before you release your WebView, set the delegate to nil.

00:05:57.439 --> 00:06:01.420
The reason for this we'll dig into more depth
later but it has to do with multi threading.

00:06:01.420 --> 00:06:07.860
WebView does a lot of stuff in the background for you so
it doesn't block your apps, your application's execution.

00:06:07.860 --> 00:06:16.870
However, if you release the WebView and it's delegated as
a nil, some of those background activities may come back

00:06:16.870 --> 00:06:23.490
and find themselves talking to an
invalid pointer and we don't want that.

00:06:23.490 --> 00:06:32.120
So another issue of working with WebView is how do you
communicate from the Objective-C code to your native code?

00:06:32.120 --> 00:06:34.189
Or back and forth?

00:06:34.189 --> 00:06:42.050
So you'd like to execute some JavaScript directly in
your web content, this turns out to be extremely easy.

00:06:42.050 --> 00:06:47.189
The WebView has a method called
stringByEvaluatingJavaScriptFromString.

00:06:47.189 --> 00:06:51.199
So perhaps you got into a JavaScript
function, it's called Insert.

00:06:51.199 --> 00:06:57.430
So an Objective-C would just put together a string
with the text insert, and you pass it to this method.

00:06:57.430 --> 00:07:03.300
Then the Insert function in the JavaScript and the
content will get called, and if it returns anything,

00:07:03.300 --> 00:07:05.949
that will get passed back through this method as well.

00:07:05.949 --> 00:07:12.959
Going the other direction from JavaScript to
Objective-C, this turns out to be a little trickier

00:07:12.959 --> 00:07:15.579
because there's not really an explicit API.

00:07:15.579 --> 00:07:18.519
But when would you want to do something like this?

00:07:18.519 --> 00:07:25.609
Well the great example is if your web content has
AJAX running, and you get data back asynchronously

00:07:25.610 --> 00:07:32.900
and you'd like to update something in your native UI, maybe
you want to update a status, or display a list of items

00:07:32.899 --> 00:07:39.269
in a native table view, so when that JavaScript
handler, when that AJAX handler gets called,

00:07:39.269 --> 00:07:43.889
you need some way to pass that
information up to the Objective-C layer.

00:07:43.889 --> 00:07:48.709
So like I said, there's no explicit API for this.

00:07:48.709 --> 00:07:58.109
But you can tap into that delegate method where again,
when the WebView asks the controller, its delegate,

00:07:58.110 --> 00:08:05.330
if it should load a request, we're going to sort of
overload this with some additional functionality.

00:08:05.329 --> 00:08:10.029
Basically what we do is we create a
URL that's with, got a dummy host.

00:08:10.029 --> 00:08:14.429
That's, you know, not a real URL
and we're going to use the path

00:08:14.430 --> 00:08:19.000
to specify the command we want to execute an Objective-C.

00:08:19.000 --> 00:08:22.290
So this is what it might look like.

00:08:22.290 --> 00:08:25.250
Obviously, that's not a real URL.

00:08:25.250 --> 00:08:30.170
So we might use window.location to trigger a load.

00:08:30.170 --> 00:08:33.649
So in our delegate we test the URL.

00:08:33.649 --> 00:08:36.490
The first thing we do is we grab the host out of it

00:08:36.490 --> 00:08:41.259
and we just do string compare and
we see if it matches my JavaScript.

00:08:41.259 --> 00:08:44.529
Then we know that we're not really
loading real requests here.

00:08:44.529 --> 00:08:46.409
We're doing something special.

00:08:46.409 --> 00:08:52.860
So then, we grab the command, which we're using
the path for, and we might have multiple commands

00:08:52.860 --> 00:08:58.690
that we test the command to see which one it
is and if it matches, then we do something.

00:08:58.690 --> 00:09:04.140
And I'll show you a demonstration
of this a little bit later on.

00:09:04.139 --> 00:09:08.159
So putting UIWebView to work.

00:09:08.159 --> 00:09:16.730
We've got WebView and WebViewDelegate, the
message flow between the delegate and the WebView,

00:09:16.730 --> 00:09:23.389
that really important life cycle detail of
setting the delegate to nil before releasing,

00:09:23.389 --> 00:09:28.840
then we talked about how we communicate back and
forth between the native content and the web content.

00:09:28.840 --> 00:09:35.210
Both from Objective-C into JavaScript and
then back from JavaScript into Objective-C.

00:09:35.210 --> 00:09:39.340
So now, let's build a little hybrid application

00:09:39.340 --> 00:09:43.200
that combines some web content with
some Objective-C functionality.

00:09:43.200 --> 00:09:50.700
Here's what it looks like, very simple, it's got the
embedded HTML content which will have a little bit of CSS

00:09:50.700 --> 00:09:58.030
and a little bit of JavaScript but any of you web developers
out there will laugh when you see how simple it is.

00:09:58.029 --> 00:10:03.269
And we've got some native components,
we've got of course the WebView itself,

00:10:03.269 --> 00:10:06.079
and we've got a UI toolbar at the bottom.

00:10:06.080 --> 00:10:09.030
And in that toolbar, we have a text field.

00:10:09.029 --> 00:10:15.819
And then we had hooked up some communication
between the WebView and its native code.

00:10:15.820 --> 00:10:21.670
And when we hit that HTML button, it's going to show
an alert, and that, you could actually do that just

00:10:21.669 --> 00:10:26.549
with plain JavaScript, but I thought an alert
was the simplest way to show you how this works.

00:10:26.549 --> 00:10:32.329
And then when we enter text in the text
field, we're going to use JavaScript

00:10:32.330 --> 00:10:36.889
to inject that into the DOM of the web content.

00:10:36.889 --> 00:10:40.620
Again, nothing too complicated but interesting enough.

00:10:40.620 --> 00:10:52.730
So let's switch over, alright, so I'm going to go to Xcode,
I'm going to create a new view controller based application.

00:10:52.730 --> 00:11:01.100
I'm going to call it hybrid app, and save it to the desktop.

00:11:01.100 --> 00:11:08.470
Now the first thing I want to do is go in and the
template has provided me with a view controller,

00:11:08.470 --> 00:11:12.470
but to speed things up I went ahead and wrote it earlier.

00:11:12.470 --> 00:11:21.259
So we're just going to throw away the one they gave
us and we're going to drag in this one that I wrote.

00:11:23.230 --> 00:11:26.170
Then I'm going to copy it in and then I'm going

00:11:26.169 --> 00:11:30.909
to grab this simple little webpage I wrote
and make it a resource in the project.

00:11:30.909 --> 00:11:38.649
So let's have a quick look at that webpage.

00:11:38.649 --> 00:11:42.069
Like I said, very simple, the whole
thing fits on the screen.

00:11:42.070 --> 00:11:47.320
Just have a little bit of CSS at the top,
then we have our two JavaScript functions.

00:11:47.320 --> 00:11:51.560
Now the one, the insert, we're
going to call from Objective-C,

00:11:51.559 --> 00:11:56.269
and you see it does some very basic DOM manipulation

00:11:56.269 --> 00:11:59.639
and then down here we have this
function called invoke Objective-C

00:11:59.639 --> 00:12:04.210
and that does windowed out location to load that dummy URL.

00:12:04.210 --> 00:12:13.300
The HTML itself, also very simple, we just have the button
and the little prompt here and then an empty DIV container,

00:12:13.299 --> 00:12:15.539
which is where our injected text will go.

00:12:15.539 --> 00:12:20.860
So now, I'm going to look at the
header file for the view controller.

00:12:20.860 --> 00:12:24.009
This tells us a lot about the UI we're going to build.

00:12:24.009 --> 00:12:30.309
We see that it's a WebView delegate and it's also a text
field delegate so again, TextView is like web views.

00:12:30.309 --> 00:12:34.819
Use a delegate mechanism to communicate with a controller.

00:12:34.820 --> 00:12:40.440
Now we have three native elements here, the
WebView, the text field, and the toolbar

00:12:40.440 --> 00:12:42.460
and we have IB outlets for each of those.

00:12:42.460 --> 00:12:50.950
We're going to go kind of slow with interface
builder in case you're not too familiar with it.

00:12:50.950 --> 00:12:57.180
So here, we have our Nib file and this is our
view controller and this is the basic view.

00:12:57.179 --> 00:13:02.529
The first thing I'm going to do is I'm
going to find a toolbar and I'm going

00:13:02.529 --> 00:13:07.079
to drag that in to the bottom of my view here.

00:13:07.080 --> 00:13:11.690
Now toolbars can have multiple items and
they position these from left to right.

00:13:11.690 --> 00:13:18.530
Now the default item is not interesting
to me, I want just a text field.

00:13:18.529 --> 00:13:24.059
And I want to place it down here, but
I'd like this text field to be centered.

00:13:24.059 --> 00:13:28.099
So to do that I need to use some flexible space items.

00:13:28.100 --> 00:13:31.889
And that's just a positioning tool for toolbars.

00:13:31.889 --> 00:13:34.789
I put this in here, and boom it pushes it all the way over.

00:13:34.789 --> 00:13:38.990
So I'll need one more, just to
balance it out so it's centered.

00:13:38.990 --> 00:13:41.990
Now the arrows you see on there won't actually display

00:13:41.990 --> 00:13:45.870
at runtime that's just a note for
you so you know what's going on.

00:13:45.870 --> 00:13:49.190
I can stretch this out and that's pretty good.

00:13:49.190 --> 00:13:52.510
Finally, I need to add my WebView.

00:13:52.509 --> 00:14:02.580
So drag that down, it sizes itself to fit the space, and
the next step is to connect all my outlets and my delegates.

00:14:02.580 --> 00:14:13.970
So from my file's owner, I have a text
field and a toolbar and the WebView.

00:14:13.970 --> 00:14:22.259
Going the other way, select the WebView and now I've
got the delegate, which goes back to my file's owner,

00:14:22.259 --> 00:14:27.399
and let's get the text field and connect it.

00:14:27.399 --> 00:14:29.579
And that's it.

00:14:29.580 --> 00:14:30.889
Our UI's done.

00:14:30.889 --> 00:14:33.269
Let's go back to Xcode.

00:14:33.269 --> 00:14:39.970
I'm going to build and run it so
we can see what this looks like.

00:14:39.970 --> 00:14:46.730
Alright, so we've got our web content here,
scrolling forth, let's try out this HTML button.

00:14:46.730 --> 00:14:49.100
And there we go, pretty cool.

00:14:49.100 --> 00:14:54.690
Alright, let's try the text, just
type something simple in here.

00:14:54.690 --> 00:14:55.980
And there it goes.

00:14:55.980 --> 00:15:04.220
So from Objective-C we're calling JavaScript, which inserts
arbitrary text that we want into the DOM of our content.

00:15:04.220 --> 00:15:07.450
One more time, and you see it just scrolls on down.

00:15:07.450 --> 00:15:10.480
So click here, we distance the keyboard.

00:15:10.480 --> 00:15:13.920
Let's go back and look at the code, see how this works.

00:15:13.919 --> 00:15:16.939
So we'll switch to this file.

00:15:16.940 --> 00:15:24.780
So it's not too big a file but to make it simpler
I'm just going to fold up all these methods, okay.

00:15:24.779 --> 00:15:29.230
So the first block at the top here, this is
all of our kind of life cycle manipulation.

00:15:29.230 --> 00:15:34.620
I'm not going to worry about it too much but I'm going
to open these up so you can see when the view unloads

00:15:34.620 --> 00:15:39.720
which can happen in response to a low memory
notification, I'm setting my outlets to nil

00:15:39.720 --> 00:15:44.330
but before I set the WebView to nil
I'm setting the delegate to nil.

00:15:44.330 --> 00:15:50.400
Likewise, in the dealloc I do pretty
much exactly the same thing.

00:15:50.399 --> 00:15:56.909
So now let's go up to viewDidLoad so,
this is when things first get started.

00:15:56.909 --> 00:16:02.829
I've dragged my webpage in as a resource so
that means it's bundled with my application.

00:16:02.830 --> 00:16:10.850
So at runtime I want to find that bundle, that file, and
load it up as a string and pass that string to my WebView.

00:16:10.850 --> 00:16:16.509
So the first thing I do is I get its path
and then I weave the file in as a string.

00:16:16.509 --> 00:16:20.090
And then I tell the WebView to load that string.

00:16:20.090 --> 00:16:24.360
There's no external URL upon which this depends.

00:16:24.360 --> 00:16:25.940
So the base URL is nil.

00:16:25.940 --> 00:16:30.760
Now we get into the interesting stuff.

00:16:30.759 --> 00:16:35.539
This is what happens when we try to load a new page.

00:16:35.539 --> 00:16:41.079
We get this delegate method called
webview:shouldStartLoadWithRequest:navigationType.

00:16:41.080 --> 00:16:45.960
The navigation type might be the user click to
link, or the header Back button or Forward button.

00:16:45.960 --> 00:16:51.519
Now in this case the navigation type would
be other because JavaScript triggered it.

00:16:51.519 --> 00:16:57.699
So just like this on the slides, we get the host, we
compare it, if it's a match we go in, get the command.

00:16:57.700 --> 00:17:07.460
If it's a match, here we put together our alert view, just
very simple, our title, message, and the Cancel button.

00:17:07.460 --> 00:17:13.750
Now after this, we return No because
they should load request,

00:17:13.750 --> 00:17:17.210
that's your chance to say yes you may or no, you may not.

00:17:17.210 --> 00:17:21.140
So we don't want to actually load anything
here, we're doing something different.

00:17:21.140 --> 00:17:25.610
But in all other cases, we would return yes.

00:17:25.609 --> 00:17:30.899
So now, let's look at what happens when we enter some text.

00:17:30.900 --> 00:17:36.420
This TextFieldDelegate method is called when
you hit the Return key on the iPhone keyboard.

00:17:36.420 --> 00:17:43.490
Again, we're taking the string from that text field
and we're wrapping it into this insert function.

00:17:43.490 --> 00:17:45.359
So it's being passed as a parameter.

00:17:45.359 --> 00:17:47.879
And you know that we're single quoting it here.

00:17:47.880 --> 00:17:55.440
Then we pass that to the WebView and next we just clear out
the text field so it's empty and ready for the next time.

00:17:55.440 --> 00:17:59.420
And we'd return yes because we
do want to allow it to return.

00:17:59.420 --> 00:18:06.330
Some of you may be thinking wow you just took arbitrary
text and just passed it through and that's not very safe.

00:18:06.329 --> 00:18:12.199
Well you're right, if this were a real app, I would want
to take this text and check and see if it's got any quotes

00:18:12.200 --> 00:18:16.620
or other extra characters that could
cause some problems and filter those out.

00:18:16.619 --> 00:18:18.849
But I wanted to keep things simple for this.

00:18:18.849 --> 00:18:22.179
So let's go back and run the app one more time.

00:18:22.180 --> 00:18:27.789
And see some of this in action again.

00:18:27.789 --> 00:18:37.000
So there's the button, and then down here we
enter our text, and it just goes right in.

00:18:37.000 --> 00:18:39.490
And there we go.

00:18:39.490 --> 00:18:40.440
Very cool.

00:18:40.440 --> 00:18:48.970
So you can see it's very simple to combine
native functionality with web content in an app.

00:18:48.970 --> 00:18:56.079
So now, we've talked about what UIWebView is and
how to use it, let's get into best practices.

00:18:56.079 --> 00:19:00.889
And best practices sometimes kind of sounds like
someone's lecturing you about what to do, what not to do,

00:19:00.890 --> 00:19:08.370
but what I really think it is, is it's knowing about
what you're using so you can get the most out of it.

00:19:08.369 --> 00:19:11.919
With anything, it's always using
the right tool for the right job.

00:19:11.920 --> 00:19:16.360
And with UIWebView, there's some jobs
for which it's absolutely the right tool

00:19:16.359 --> 00:19:19.969
and other jobs for which it's not the best tool.

00:19:19.970 --> 00:19:27.009
So let's talk about what's in a web
browser and what's in UIWebView.

00:19:27.009 --> 00:19:32.569
On Mac OS X we provide the full WebKit
framework, completely exposed to developers,

00:19:32.569 --> 00:19:35.179
so they can build their own web browsers.

00:19:35.180 --> 00:19:37.690
Well let's see what's in that.

00:19:37.690 --> 00:19:44.309
Wow 125 different classes, and some
of these are DOM manipulation classes,

00:19:44.309 --> 00:19:50.230
script handling classes, web content
classes, frames, etcetera.

00:19:50.230 --> 00:19:56.970
Twenty-seven protocols for communicating
with delegates and other objects.

00:19:56.970 --> 00:19:58.279
Over one thousand API's.

00:19:58.279 --> 00:20:03.000
Now on the iPhone we have UIWebView.

00:20:03.000 --> 00:20:06.190
one class.

00:20:06.190 --> 00:20:08.860
WebViewDelegate, one protocol.

00:20:08.859 --> 00:20:14.019
A total of twenty API's.

00:20:14.019 --> 00:20:19.869
So I'm going to go out on a limb and
say you don't have everything you need

00:20:19.869 --> 00:20:22.309
to build a full web browser with UIWebView.

00:20:22.309 --> 00:20:23.919
And there's a reason for that.

00:20:23.920 --> 00:20:27.380
The iPhone has an incredible web browser already.

00:20:27.380 --> 00:20:34.530
So with UIWebView it's about presenting your content.

00:20:34.529 --> 00:20:38.309
It's a lightweight presentation layer over WebKit.

00:20:38.309 --> 00:20:44.460
It's optimized for presenting style content,
your HTML, your JavaScript, etcetera,

00:20:44.460 --> 00:20:47.269
and it works best when you know the content.

00:20:47.269 --> 00:20:53.269
So if you've got an existing website or a website that's
relevant to your application, it's a known domain,

00:20:53.269 --> 00:20:56.160
that's great, that's perfect with UIWebView.

00:20:56.160 --> 00:21:01.120
But general browsing, you can get
into a little trouble there.

00:21:01.119 --> 00:21:04.809
Just the user starts clicking links
and soon they're all over the web,

00:21:04.809 --> 00:21:07.299
they're ten miles from where they started with your app.

00:21:07.299 --> 00:21:09.339
It doesn't really make sense.

00:21:09.339 --> 00:21:13.669
So that delegate method shouldStartLoadWithRequest
is your chance

00:21:13.670 --> 00:21:17.120
to exercise some control over what's shown in your app.

00:21:17.119 --> 00:21:22.569
And you might say well I'll start off with
a domain that's appropriate, my domain,

00:21:22.569 --> 00:21:29.720
and any request that exits my domain, instead of showing
it in my app, maybe I'll just launch it in Safari

00:21:29.720 --> 00:21:31.720
and then the user can have a real browsing experience.

00:21:31.720 --> 00:21:36.120
Or maybe I'll prompt them to see if
they'd like to exit and go to Safari.

00:21:36.119 --> 00:21:43.989
But just allowing yourself to spider all over the
web isn't going to work very well with UIWebView.

00:21:43.990 --> 00:21:46.529
There's also memory consumption to talk about.

00:21:46.529 --> 00:21:50.289
So UIWebView does require significant resources.

00:21:50.289 --> 00:21:57.759
Think about the Internet for a moment
and what's the largest webpage out there

00:21:57.759 --> 00:22:04.369
All the images on it, the JavaScripts that might
take several minutes to run, megabytes potentially.

00:22:04.369 --> 00:22:14.089
So with the WebView its memory footprint is really
predicated by the size of the content you load on it.

00:22:14.089 --> 00:22:17.619
There's no official limit on how big a webpage can be.

00:22:17.619 --> 00:22:21.269
So that can be a problem with WebViews.

00:22:21.269 --> 00:22:30.210
And finally data may be cached internally by WebView
or by some internal frameworks on which it depends.

00:22:30.210 --> 00:22:36.360
And you don't have an explicit mechanism for releasing
that cache in the case of a low memory situation.

00:22:36.359 --> 00:22:41.189
So you know, content is a consideration.

00:22:41.190 --> 00:22:46.120
So what about multiple web views?

00:22:46.119 --> 00:22:50.229
Well I'm not going to give you a hard and
fast rule on this because there isn't one.

00:22:50.230 --> 00:22:54.630
But just keep in mind, more content equals more memory.

00:22:54.630 --> 00:22:57.340
Be conservative in your use of web views.

00:22:57.339 --> 00:23:01.569
Let's consider JavaScript for a moment.

00:23:01.569 --> 00:23:09.189
So JavaScript is really fantastic and WebKit's
a really fast processing engine for it.

00:23:09.190 --> 00:23:13.720
But on the iPhone you really want to watch
out and make sure your scripts are fast.

00:23:13.720 --> 00:23:20.009
They really, they have to finish within ten10 seconds
and if you asked me personally I wouldn't want a script

00:23:20.009 --> 00:23:22.829
that took that long on a web page I was using.

00:23:22.829 --> 00:23:30.009
But if you've got longer scripts, break them down
into chunks and then execute each chunk serially.

00:23:30.009 --> 00:23:33.190
There's also a little bit to think
about with power consumption.

00:23:33.190 --> 00:23:41.930
Network is one of the major power consumers on the
device, the others being the screen and disc I/O.

00:23:41.930 --> 00:23:47.799
So you want to avoid rapid polling with AJAX where
you're just bouncing off the server every second

00:23:47.799 --> 00:23:54.599
or every thirty seconds and try to batch lots
of small data transfers into larger chunks.

00:23:56.809 --> 00:24:00.440
Threads. So I mentioned earlier
that you want to set the delegate

00:24:00.440 --> 00:24:04.799
to nil before you really selectView
and that this had to do with threading.

00:24:04.799 --> 00:24:08.960
Well first of all before I get into that,
you need to know that you need to know

00:24:08.960 --> 00:24:14.980
that UIWebView should only ever be accessed
on the main thread of your application.

00:24:14.980 --> 00:24:18.440
Of course that's true for all UIViews.

00:24:18.440 --> 00:24:25.690
Be extremely careful if you are threading in your app
that you're not handling any views off of the main thread.

00:24:25.690 --> 00:24:32.120
Now UIWebView uses background threads to
download its content and to render it.

00:24:32.119 --> 00:24:35.919
So the benefit of this is your application won't block.

00:24:35.920 --> 00:24:41.009
You can create a web view, tell it to go off and
load something and your app will keep running,

00:24:41.009 --> 00:24:44.789
keep being responsive while the web view
is doing this work in the background.

00:24:44.789 --> 00:24:49.829
And it'll just come up and be presented
to the user when it's ready.

00:24:49.829 --> 00:24:53.429
But this is why we have to set the delegate to nil.

00:24:53.430 --> 00:24:58.200
Those background requests if the web
view gets released and delegate goes away

00:24:58.200 --> 00:25:01.309
and they come back, we could have a crash.

00:25:01.309 --> 00:25:02.200
We don't want that.

00:25:02.200 --> 00:25:06.180
So just, it's very easy, just set
the delegate to nil before releasing.

00:25:06.180 --> 00:25:13.690
A lot of developers ask me about how
to get touch events in a web view.

00:25:13.690 --> 00:25:19.200
Not to be manipulated by their content but to
handle something extra in the native logic.

00:25:19.200 --> 00:25:28.569
And they will, maybe I can subclass UIWebView and
override the UI responder events for handling events.

00:25:28.569 --> 00:25:33.409
Well the problem with that is that
UIWebView's internal view hierarchy is private,

00:25:33.410 --> 00:25:39.950
it's complex and it's not safe for
developers to go and tamper with.

00:25:39.950 --> 00:25:43.750
And event handling goes deep into this view hierarchy.

00:25:43.750 --> 00:25:55.119
So instead what we suggest is not
subclassing UIWebView, there's a better way.

00:25:55.119 --> 00:25:56.769
You can do it at the window level.

00:25:56.769 --> 00:26:02.799
You can subclass the window because all events will
go through the window before they get to any view.

00:26:02.799 --> 00:26:05.329
So you override sendEvent.

00:26:05.329 --> 00:26:13.139
And in sendEvent the very first thing you should do is
call super sendEvent because I use the word observe.

00:26:13.140 --> 00:26:18.140
You should only observe the events, you should not
tamper with them or try to modify them in any way.

00:26:18.140 --> 00:26:22.009
So if you see that an event is going on that
you're interested in, it's perfectly legitimate

00:26:22.009 --> 00:26:24.859
to add some extra functionality on your part.

00:26:24.859 --> 00:26:28.279
But you don't want to interfere
with the existing functionality.

00:26:28.279 --> 00:26:30.899
So always call super.

00:26:30.900 --> 00:26:35.890
Now it goes without saying that if the changes
you want to do are at the content level,

00:26:35.890 --> 00:26:39.150
then you should really just stick
with the JavaScript event handlers.

00:26:39.150 --> 00:26:44.910
They're very powerful and will let you
do just about anything you need to do.

00:26:44.910 --> 00:26:51.980
So let's take our existing demo and
add some touch event handling to it.

00:26:51.980 --> 00:26:58.220
So where we last left our web app we've
got the ability to enter some text.

00:26:58.220 --> 00:27:08.480
Now the first thing I've noticed is I can't scroll
down because as soon as I do, the keyboard goes away.

00:27:08.480 --> 00:27:11.960
That's a bit frustrating.

00:27:11.960 --> 00:27:20.970
So the first thing I'm going to do is
I've prepared some little snippets of code

00:27:20.970 --> 00:27:26.870
and I'm going to add these in to the demo.

00:27:26.869 --> 00:27:32.539
Now to keep the keyboard from going away when I
don't want it to go away, the first thing I'm going

00:27:32.539 --> 00:27:38.579
to do is add a little Boolean that
I can use to track the state.

00:27:38.579 --> 00:27:42.259
And this I'm calling textfieldShouldResignFirstResponder.

00:27:42.259 --> 00:27:45.640
Resigning first responder is how the keyboard goes away.

00:27:45.640 --> 00:27:49.920
And in this case, there are sometimes when
I don't want to resign first responder.

00:27:49.920 --> 00:28:01.590
So what I'm going to do is add
implementation of another text delegate method

00:28:01.589 --> 00:28:06.689
and this one's called textfieldShouldEndEditing.

00:28:06.690 --> 00:28:12.240
And that's what happens when first responder,
when it tries to resign first responder.

00:28:12.240 --> 00:28:19.019
But I'll use my Boolean and say well if this isn't
set, I'm not going to resign first responder.

00:28:19.019 --> 00:28:24.889
But if it is set, then I'll go ahead and
resign but reset that flag back to nothing.

00:28:24.890 --> 00:28:30.390
So let's run the app again.

00:28:30.390 --> 00:28:42.050
And enter some text, and some more, great now I can scroll.

00:28:42.049 --> 00:28:46.450
I'd like to just tap and have the keyboard go away now.

00:28:46.450 --> 00:28:48.819
But I can't get rid of the keyboard.

00:28:48.819 --> 00:28:52.299
So I'm going to have to add some more code.

00:28:52.299 --> 00:28:54.379
Now I talked about subclassing UIWindows.

00:28:54.380 --> 00:29:01.980
So I have the subclass of UIWindow written that
I'm just going to add right in to the project.

00:29:05.509 --> 00:29:08.910
So let's look at this subclass.

00:29:08.910 --> 00:29:13.650
Well the first thing I see is a protocol at the
top, it's a tap observer protocol that I've created.

00:29:13.650 --> 00:29:18.390
And this is a way for the window to
communicate back with some controller object

00:29:18.390 --> 00:29:21.540
that is interested in getting tap events.

00:29:21.539 --> 00:29:26.639
So then the window itself, I have
the view that I'm observing,

00:29:26.640 --> 00:29:29.580
so I'm only carrying about tap events in one view.

00:29:29.579 --> 00:29:36.199
And I have some controller, I don't really know what
type it is, but I know that it conforms to this protocol.

00:29:36.200 --> 00:29:40.600
And then I have some properties to manage those variables.

00:29:40.599 --> 00:29:43.349
So here this is very simple.

00:29:43.349 --> 00:29:50.969
We have send event which is the workhorse and the first
thing I do is I call super, and then we go down and I want

00:29:50.970 --> 00:29:56.230
to do as much filtering of the event handling as
possible because it's possible for events to flow

00:29:56.230 --> 00:29:59.349
through the system very rapidly if
the user's doing a touch that moves

00:29:59.349 --> 00:30:02.039
across the screen, that will result in a lot of calls.

00:30:02.039 --> 00:30:04.289
So I want to minimize the work I do.

00:30:04.289 --> 00:30:11.659
The first thing I do to eliminate events I'm not interested
in is I see if I don't have a view that I'm observing

00:30:11.660 --> 00:30:17.170
or a controller that is observing, I just stop right there.

00:30:17.170 --> 00:30:20.070
The next thing I do is I get the touches in the event.

00:30:20.069 --> 00:30:23.689
I'm only interested in events with a single touch.

00:30:23.690 --> 00:30:28.860
So if the count of touches is not 1, I stop right there.

00:30:28.859 --> 00:30:33.689
Moving forward I get the touch out
of the event and I check its phase.

00:30:33.690 --> 00:30:37.610
So a touch can have a begin, a moved or an end phase.

00:30:37.609 --> 00:30:41.179
I'm only interested in touches that end.

00:30:41.180 --> 00:30:46.400
So if we're still, have gotten this far, I have
a slightly more expensive call which is to see

00:30:46.400 --> 00:30:50.650
if this touch occurred in the view that I care about.

00:30:50.650 --> 00:30:56.900
So I actually use isDescendentOfView because
it could be in any sub view within that view.

00:30:56.900 --> 00:30:59.960
If it's not, then I return.

00:30:59.960 --> 00:31:02.860
The last part is a little trickier.

00:31:02.859 --> 00:31:07.269
So what happens when you have a single tap?

00:31:07.269 --> 00:31:08.529
You get a tap count of 1.

00:31:08.529 --> 00:31:11.049
What happens if you have a double tap?

00:31:11.049 --> 00:31:13.319
We actually get two separate event messages.

00:31:13.319 --> 00:31:17.169
The first one has a tap count of
1, the second has a tap count of 2.

00:31:17.170 --> 00:31:24.350
So when you get the tap count of 1 you have no way of
knowing if a tap count of 2 is about to follow it up.

00:31:24.349 --> 00:31:32.309
So what we do is I'm just going to delay execution
of my response to the tap by half a second.

00:31:32.309 --> 00:31:37.500
This is an NSObject method called
performSelectorWithObjectAfterDelay.

00:31:37.500 --> 00:31:39.519
And then I wait.

00:31:39.519 --> 00:31:49.759
And in the next half second, if the double tap comes in,
I can use cancelPreviousPerformRequestWithTarget to cancel

00:31:49.759 --> 00:31:53.960
that request and I will ignore the double tap.

00:31:53.960 --> 00:32:00.759
If a double tap never comes then this forward tap method,
which is just a little helper method in my own class,

00:32:00.759 --> 00:32:07.079
will take place and my controller will
be informed that the user tapped my view.

00:32:07.079 --> 00:32:08.549
So it's pretty straightforward.

00:32:08.549 --> 00:32:17.609
The next thing we need to do is go back to our controller
and add some code so it actually uses this new window.

00:32:17.609 --> 00:32:26.059
The first thing I have to do is in the header
of the controller, import my window class,

00:32:26.059 --> 00:32:29.399
and then I want to add conformance to that protocol.

00:32:29.400 --> 00:32:35.950
So now my controller conforms to the tap
observer protocol in addition to these others.

00:32:35.950 --> 00:32:39.080
That takes care of the header file.

00:32:39.079 --> 00:32:48.230
Now in the implementation I have to actually start
observing so I'm going to do that and view will appear.

00:32:48.230 --> 00:32:50.490
Or view did appear.

00:32:50.490 --> 00:32:55.250
So I've written this code that just drops in here.

00:32:55.250 --> 00:33:03.250
So what this does is I get the window from my
view and I cast it to a tap observing window.

00:33:03.250 --> 00:33:12.289
Then I set its view to observe to be my web view
and I set the controller that observes to be myself.

00:33:12.289 --> 00:33:18.809
Then to be good about this, when the view
disappears, I don't want to continue observing.

00:33:18.809 --> 00:33:24.619
So I'm going to help the window be
more efficient by stop the observing.

00:33:24.619 --> 00:33:30.889
So that just sets these properties back to nil.

00:33:30.890 --> 00:33:35.610
And the biggie of course is responding to the tap.

00:33:35.609 --> 00:33:38.039
So what are we going to do with that?

00:33:38.039 --> 00:33:46.399
Well in responding to the tap, I just have to do two very
simple things, I set my personal textfieldShouldResign flag

00:33:46.400 --> 00:33:50.050
to yes and then I ask the text field to resign.

00:33:50.049 --> 00:33:53.909
So when there's a tap I want the keyboard to drop out.

00:33:53.910 --> 00:34:00.519
The only thing that's left is going
into my main Nib and changing my window

00:34:00.519 --> 00:34:05.160
to be not just a UI window, but a tap observing window.

00:34:05.160 --> 00:34:12.500
Why don't we go back to the app, and run it.

00:34:15.070 --> 00:34:27.700
So let's enter some text and we can scroll,
great, tap, and the keyboard drops out of sight.

00:34:27.699 --> 00:34:33.849
Let's go back in and let's try double tap, keyboard stays.

00:34:33.849 --> 00:34:36.179
Single tap keyboard disappears.

00:34:36.179 --> 00:34:37.509
So it's that easy.

00:34:37.510 --> 00:34:44.790
Going back to the code just one last look at
the event handling here, we start with super

00:34:44.789 --> 00:34:48.279
and then we do some filtering,
so we minimize the work we do.

00:34:48.280 --> 00:34:55.060
And then we, then what really matters is handling
the exact kind of event you're interested in.

00:34:55.059 --> 00:35:01.389
I'm caring about phase ended single taps but it
could be any event, it could be a multi touch event.

00:35:01.389 --> 00:35:05.859
It's really up to you and what you
want to do in your application.

00:35:05.860 --> 00:35:14.769
So there's some best practices for UIWebView
then we demoed how to handle touch events,

00:35:14.769 --> 00:35:17.980
which a lot of developers have asked us how to do that.

00:35:17.980 --> 00:35:22.900
Let's talk about some advanced topics.

00:35:22.900 --> 00:35:31.369
So in this, I'm going to talk about NSURLConnection, which
is a foundation level technology, and then I'm going to talk

00:35:31.369 --> 00:35:36.130
about handling HTTP authentication in UIWebView.

00:35:36.130 --> 00:35:45.019
Next we'll explore links that open in new windows, how to
save and restore state with UIWebView and then we'll finish

00:35:45.019 --> 00:35:53.309
up with offscreen rendering which is basically taking
the content of a web view and creating an image from it.

00:35:53.309 --> 00:35:55.789
Let's start with NSURLConnection.

00:35:55.789 --> 00:36:04.440
So this is a lower level API but it's very simple to
use and it's how you can download content directly

00:36:04.440 --> 00:36:07.179
which turns out to be a very powerful tool.

00:36:07.179 --> 00:36:16.250
So once again, it works with a delegate API and, the,
create a connection, you give it a URL request just

00:36:16.250 --> 00:36:24.019
like you would give your web view and it can call back to
your delegate as data is received or if there's an error.

00:36:24.019 --> 00:36:30.769
So it has two modes of operation, it has a
synchronous mode and an asynchronous mode.

00:36:30.769 --> 00:36:33.670
Don't use the synchronous mode, it blocks.

00:36:33.670 --> 00:36:37.869
So if you do a synchronous connection
to retrieve some data from a server,

00:36:37.869 --> 00:36:41.880
your app is going to sit right there
and spin until it has all that data.

00:36:41.880 --> 00:36:44.039
You don't want to do that on the main thread,

00:36:44.039 --> 00:36:48.980
and you might think well I'll just create a
separate thread and do that on my separate thread.

00:36:48.980 --> 00:36:54.990
Well that's really not the best approach either because
that creates a threading complexity in your application.

00:36:54.989 --> 00:37:01.869
Instead if you use the asynchronous mode, our foundation
in the background will do the threading work for you

00:37:01.869 --> 00:37:04.849
and you don't have to worry about that complexity.

00:37:04.849 --> 00:37:13.380
So it's fundamental for a lot of advanced use cases.

00:37:13.380 --> 00:37:16.039
Let's look at one of those right now.

00:37:16.039 --> 00:37:18.009
HTTP authentication.

00:37:18.010 --> 00:37:22.970
So UIWebView, I think I mentioned
it's not a full browser replacement.

00:37:22.969 --> 00:37:29.079
One of the things it doesn't do for you is
automatically provide a UI for authenticating

00:37:29.079 --> 00:37:33.210
to some site that's protected with HTTPAuth.

00:37:33.210 --> 00:37:36.380
However there's a simple way and a tricky way.

00:37:36.380 --> 00:37:44.670
The simple way for you to handle this is just to embed
that authorization information directly in the URL request.

00:37:44.670 --> 00:37:50.590
If you do that, you should use HTTPS
so that, that information is secure.

00:37:50.590 --> 00:37:57.910
Now if you do want to present a UI for
authentication, here's where NSURLConnection comes in.

00:37:57.909 --> 00:38:00.980
You create a separate connection for the URL

00:38:00.980 --> 00:38:05.940
and in the connection delegate you'll
get a didReceiveAuthentication challenge

00:38:05.940 --> 00:38:11.480
And then you can provide your custom UI to the
user, they can enter the username, their password,

00:38:11.480 --> 00:38:15.469
and what you're going to do is you're going
to store those credentials for the persistence

00:38:15.469 --> 00:38:19.569
of the session which is the lifetime of the app.

00:38:19.570 --> 00:38:25.940
Then you go back to your web view and you load that
URL request and it will use the cached credentials.

00:38:25.940 --> 00:38:29.630
Now you might say well but now I'm
downloading all that content twice.

00:38:29.630 --> 00:38:33.880
Well you could do that, but you don't have to.

00:38:33.880 --> 00:38:45.130
With NSURLConnection you can path an NSMutableURL request
and in the mutable request you can set the HTTP method.

00:38:45.130 --> 00:38:51.869
So usually you probably use get or post, but if you just
use the header method, you'll only get the header back

00:38:51.869 --> 00:38:55.789
from the server and you won't download
any of the body content.

00:38:55.789 --> 00:39:02.029
So links that open in new windows,
there's two ways this works.

00:39:02.030 --> 00:39:06.710
Its target="_blank" and JavaScripts window.open().

00:39:06.710 --> 00:39:12.159
Both of these are ignored by UIWebView because if you
think about it the web view is just a view in a window,

00:39:12.159 --> 00:39:18.639
it has no knowledge of how you want
it to suddenly pop open a new window.

00:39:18.639 --> 00:39:22.469
So it just silently ignores these requests.

00:39:22.469 --> 00:39:25.909
If you're dealing with content, well, the first thing is

00:39:25.909 --> 00:39:29.730
if the content is something you
control, just don't use those links.

00:39:29.730 --> 00:39:33.409
Just use standard links that will open in the same view.

00:39:33.409 --> 00:39:41.239
Now if you're dealing with content you don't control
directly and you know that this content has links that open

00:39:41.239 --> 00:39:44.919
in new windows, here again, NSURLConnection.

00:39:44.920 --> 00:39:51.510
You download the content into memory, and you can
parse through and replace those instances and then load

00:39:51.510 --> 00:39:54.680
that data from memory directly to the web view.

00:39:54.679 --> 00:40:00.669
And the links you might want to set
them up so they will just open to right

00:40:00.670 --> 00:40:02.889
within that or you can do whatever you want.

00:40:02.889 --> 00:40:10.339
You can, just as we did with the JavaScript to use the
webviewShouldLoadRequest, you can modify those links

00:40:10.340 --> 00:40:17.380
so that your web view delegate has a way of knowing that you
want them to open in a different window or a different view

00:40:17.380 --> 00:40:23.050
or have some other functionality and
then deal with them, as you want.

00:40:23.050 --> 00:40:24.990
Saving and restoring states.

00:40:24.989 --> 00:40:29.649
So with the iPhone we emphasize that
the user can exit your app at any time,

00:40:29.650 --> 00:40:32.619
a phone call could come in, they
could hit the lock, whatever.

00:40:32.619 --> 00:40:38.239
So you want to be ready to shut down instantly
and the next time the user runs the app,

00:40:38.239 --> 00:40:41.909
you want to be able to return right to the same place.

00:40:41.909 --> 00:40:44.639
So how do you do this with a web view?

00:40:44.639 --> 00:40:48.869
Well once again this is one of those
areas where if you control the content,

00:40:48.869 --> 00:40:53.269
this turns out to be a very easy problem and
if you don't control the content it turns

00:40:53.269 --> 00:40:56.840
out to be a somewhat more difficult problem.

00:40:56.840 --> 00:41:02.680
If you control the content then what you want to
do is keep your JavaScript and your CSS in line

00:41:02.679 --> 00:41:05.480
and you want to minimize external resources.

00:41:05.480 --> 00:41:12.750
That way you can do the same thing with NSURLConnection,
you can download it separately from memory,

00:41:12.750 --> 00:41:19.059
pass it to the web view and then if your app terminates
you just write what's currently in memory out to a file.

00:41:19.059 --> 00:41:23.159
And the next time you launch you just
have to see if that file's there.

00:41:23.159 --> 00:41:26.980
And then load the content from that
file and push it right to the web view.

00:41:26.980 --> 00:41:32.099
And this works great again if the
JavaScript and CSS is in line.

00:41:32.099 --> 00:41:37.360
If it's not, then you can end up with
something that doesn't look quite right.

00:41:37.360 --> 00:41:42.590
The reason for this is NSURLConnection
downloads a single URL.

00:41:42.590 --> 00:41:46.860
WebView will download the URL and
then each external resource in it,

00:41:46.860 --> 00:41:50.010
it uses additional connections to download those.

00:41:50.010 --> 00:41:55.490
So if you don't control the content and you're going
to try to do this robustly you would actually have

00:41:55.489 --> 00:41:59.899
to download the main URL and then look
through and find all the other resources

00:41:59.900 --> 00:42:02.840
and download those as well so you have them in memory.

00:42:02.840 --> 00:42:07.360
And that can be kind of tricky.

00:42:07.360 --> 00:42:09.490
Finally offscreen rendering.

00:42:09.489 --> 00:42:14.809
So you've got a webpage and you'd like to
show a thumbnail image or a full size image,

00:42:14.809 --> 00:42:18.299
you want to capture it, render it somehow to an image.

00:42:18.300 --> 00:42:21.880
Well this turns out to be fairly straightforward.

00:42:21.880 --> 00:42:29.579
You just load your content in a web view and then you
use some UIGraphics methods to render those contents.

00:42:29.579 --> 00:42:36.860
You would access the web view's core animation
layer and render that after it's been drawn.

00:42:36.860 --> 00:42:38.820
And it's not too hard.

00:42:38.820 --> 00:42:41.580
There are two challenges you have to deal with.

00:42:41.579 --> 00:42:44.409
The first is that Webview won't
render unless it's in a window.

00:42:44.409 --> 00:42:50.789
And if you want to do this offscreen, it won't
be in a window unless you create a new window

00:42:50.789 --> 00:42:54.000
and place it offscreen and that's what we'll do.

00:42:54.000 --> 00:42:56.019
The second thing is that drawing is asynchronous.

00:42:56.019 --> 00:43:03.130
So as I mentioned UIWebView uses threads both to
download content and actually also to its drawing.

00:43:03.130 --> 00:43:07.650
So when your web view delegate
gets the loaded finished message,

00:43:07.650 --> 00:43:11.230
that just means that we finished
grabbing all the content off the web.

00:43:11.230 --> 00:43:15.260
It doesn't mean that we've actually
finished drawing all the content.

00:43:15.260 --> 00:43:21.900
So you'll have to basically build in a little
delay just like we did with the event handling.

00:43:21.900 --> 00:43:27.030
So now we're going to demo an application
that does some offscreen rendering.

00:43:27.030 --> 00:43:38.800
I'm going to create a new project, again I'll use
the view based template, call it offscreen renderer.

00:43:43.650 --> 00:43:51.450
And again, the first thing I'm going to do is go
in and remove the view controller that was provided

00:43:51.449 --> 00:43:55.929
with the template and replace it
with one I've written already.

00:43:55.929 --> 00:44:12.379
Okay. So let's look at the other file because that's going
to tell us a lot about the UI that we're going to build.

00:44:12.380 --> 00:44:14.869
This is very similar to the other app as you see.

00:44:14.869 --> 00:44:18.440
We've got the web view delegate and the text view delegate.

00:44:18.440 --> 00:44:22.690
We have a different group of native
elements here to work with.

00:44:22.690 --> 00:44:29.740
We have an activity indicator, an image view,
a label, our offscreen window, and a web view.

00:44:29.739 --> 00:44:37.099
We also have this flag that's a little state variable saying
whether or not we're in the process of rendering a page.

00:44:37.099 --> 00:44:40.329
Now we have properties to manage each of
these variables and you'll notice that all

00:44:40.329 --> 00:44:43.329
of them are IB outlets except for the web view.

00:44:43.329 --> 00:44:48.139
The web view as it turns out, we're going to
create in code instead of in interface builder.

00:44:48.139 --> 00:44:54.139
So let's switch and open up our Nib
and we'll close these other Nibs.

00:44:54.139 --> 00:45:05.829
And then we start off with this NPView and this time
I'm going to build my UI just a little differently.

00:45:05.829 --> 00:45:12.489
Instead of having a toolbar at the bottom, I'm going to put
a navigation bar at the top and put my text field in there.

00:45:12.489 --> 00:45:26.129
So find the navigation bar, right here, and find
the text field, and we drop that in the middle,

00:45:26.130 --> 00:45:29.920
and you'll notice that this is positioned
in the center instead of over to the side.

00:45:29.920 --> 00:45:35.389
Navigation bars have, instead of just an
arbitrary set of items positioned left to right,

00:45:35.389 --> 00:45:38.379
it has a center item and a right item and a left item.

00:45:38.380 --> 00:45:43.890
And so we're using the center item and we'll give them
a little stretch to fill, and the next thing we want

00:45:43.889 --> 00:45:56.150
to do is put a label at the bottom of our display and
this will just be a little status message, just a,

00:45:56.150 --> 00:46:02.059
I'm going to center that label and
clear out that placeholder text.

00:46:02.059 --> 00:46:08.500
Next thing is an image view that will show
the final rendered contents of our webpage.

00:46:08.500 --> 00:46:15.130
I'll drag that down here, there we go.

00:46:15.130 --> 00:46:21.519
And while we don't have our content, I want to
show an activity indicator over top the image view.

00:46:21.519 --> 00:46:24.980
And then I'm going to set that to hide when stopped.

00:46:24.980 --> 00:46:29.559
So we won't see it except when it's actually working.

00:46:29.559 --> 00:46:32.309
The last thing I need is my offscreen window.

00:46:32.309 --> 00:46:37.960
So I'll just drag that directly
into the interface builder document.

00:46:37.960 --> 00:46:39.059
And let's make our connections.

00:46:39.059 --> 00:46:52.250
We have the files under, it's got its activity indicator,
and has the image view, and label, the offscreen window

00:46:52.250 --> 00:47:00.539
and then finally we just have to set our text
fields delegate back to the file's owner.

00:47:00.539 --> 00:47:10.250
And with that we can, we're ready to run.

00:47:10.250 --> 00:47:15.840
So let's try Apple.com.

00:47:15.840 --> 00:47:19.430
So there we go, an image representing web content.

00:47:19.429 --> 00:47:23.109
You can see this is not web content, it's a real image.

00:47:23.110 --> 00:47:34.130
Let's try another one, let's try developer.

00:47:34.130 --> 00:47:39.440
And it looks like I must have made a typo.

00:47:39.440 --> 00:47:41.920
Let's try, its offline?

00:47:41.920 --> 00:47:43.970
Oh, even better.

00:47:43.969 --> 00:47:49.459
Let's try store that'd better be online.

00:47:49.460 --> 00:47:52.949
There we go, okay, so you can see it's just that easy.

00:47:52.949 --> 00:47:57.219
We grab our web content and we draw it to an
image and present that image on the screen.

00:47:57.219 --> 00:47:59.849
So let's look at the code and see how that's working.

00:47:59.849 --> 00:48:08.750
Once again, I'm going to go ahead and fold
everything up, make this a little easier to look at,

00:48:08.750 --> 00:48:12.070
you can see again this is not too big a project.

00:48:12.070 --> 00:48:18.920
The lifecycle methods are exactly as they were before, I'm
setting the delegate to nil before I release the web view.

00:48:18.920 --> 00:48:23.340
So let's start with when the text field begins editing.

00:48:23.340 --> 00:48:27.789
Just because I'm a little lazy, I start
off the first thing I do is pop in the HTTP

00:48:27.789 --> 00:48:32.519
for me, save a little typing just a convenience.

00:48:32.519 --> 00:48:36.159
Now when we hit return, well we've
got a little more going on here.

00:48:36.159 --> 00:48:42.190
Start up the activity indicator and it becomes
visible when you tell it to start animating.

00:48:42.190 --> 00:48:46.010
Then I set the text fields text into my label.

00:48:46.010 --> 00:48:48.420
So we can see what URL we're loading.

00:48:48.420 --> 00:48:55.050
The next thing I do is I create a URL object from that.

00:48:55.050 --> 00:48:59.610
Then I create my web view and I set its
size to be the same size as the image view

00:48:59.610 --> 00:49:06.789
because basically whatever image you capture from the
web view is going to be the same size as the web view.

00:49:06.789 --> 00:49:11.219
And you can also resize it later but
that's extra work we don't need to do.

00:49:11.219 --> 00:49:15.969
I set the web view delegate to
self and I scale the pages to fit.

00:49:15.969 --> 00:49:19.909
So depending on how the page is styled
it may or may not size itself to fit.

00:49:19.909 --> 00:49:23.190
But if you use this property it will.

00:49:23.190 --> 00:49:26.909
Then to my offscreen window, I
add the web view as a sub view.

00:49:26.909 --> 00:49:34.269
And I tell it to load the request and then while
that's happening, again, that happens asynchronously

00:49:34.269 --> 00:49:37.679
so now web view's gone off in the background to do the work.

00:49:37.679 --> 00:49:42.649
I clear out the text field, I tell it to resign
first responder, so the keyboard goes away,

00:49:42.650 --> 00:49:46.320
and I clear out any previous image in the image view.

00:49:46.320 --> 00:49:51.140
And finally I set this flag renderingAWebpage equal to yes.

00:49:51.139 --> 00:49:57.759
The reason for this is that when you go and load a
page that's got certain kinds of JavaScript in it,

00:49:57.760 --> 00:50:00.490
you may get the load request more than once.

00:50:00.489 --> 00:50:04.969
And you don't want to handle it more than once
in this case where we're rendering an image.

00:50:04.969 --> 00:50:07.649
We just want to render the image one time.

00:50:07.650 --> 00:50:10.920
Believe me it's enough work rendering it once.

00:50:10.920 --> 00:50:14.880
So now we wait for the web view to finish loading.

00:50:14.880 --> 00:50:20.250
Now remember when this method calls, this just means
the web view is finished downloading the content.

00:50:20.250 --> 00:50:22.809
It doesn't mean it's actually finished drawing.

00:50:22.809 --> 00:50:31.090
So here we use our flag to make sure we only do this once,
and then we're going to delay our rendering by a second.

00:50:31.090 --> 00:50:36.550
That will give a chance for all the
drawing to take care of and make sure that,

00:50:36.550 --> 00:50:43.730
because if you draw too soon you might end up with a
white image instead of the actual content you want.

00:50:43.730 --> 00:50:47.190
The next thing is what happens in the rendering?

00:50:47.190 --> 00:50:53.240
So this is some UIGraphics work, you'll get a lot more
information about that in some of the graphics sessions,

00:50:53.239 --> 00:50:58.669
but we begin what we call an image context and
we make it the same size as the image view.

00:50:58.670 --> 00:51:05.869
Then we take the web view's layer, it's a core animation
layer, and we render it into the current graphics context.

00:51:05.869 --> 00:51:10.139
The current graphics context is
this one that we just created.

00:51:10.139 --> 00:51:17.519
The next step is that we set the image view's image from
the image that we retrieved from the current context.

00:51:17.519 --> 00:51:23.929
Then we finish that context so we've cleaned that up, we're
done with it and then we go ahead and remove our web view

00:51:23.929 --> 00:51:29.000
from its super view, set the delegate to
nil, and then release the web view itself

00:51:29.000 --> 00:51:33.099
and last of all we tell the activity
indicator to stop animating

00:51:33.099 --> 00:51:35.779
which will result in a disappearing from the screen.

00:51:35.780 --> 00:51:49.269
Let's have a look at that one more time.

00:51:49.269 --> 00:51:50.050
And there we go.

00:51:50.050 --> 00:51:54.980
So it's just that easy, rendering
content from a webpage to an image.

00:52:00.030 --> 00:52:09.769
So those are the advanced topics and the sort of unsung
hero in almost all of the advanced topics is NSURLConnection

00:52:09.769 --> 00:52:13.409
and its best use in its asynchronous mode.

00:52:13.409 --> 00:52:18.750
So now we've talked about web view, and how to
use it, the best practices, and advanced topics

00:52:18.750 --> 00:52:25.010
let's look at some of the cool new
features we've added in 3.0 now.

00:52:25.010 --> 00:52:27.950
So CopyPaste.

00:52:27.949 --> 00:52:32.659
The good news is, you get CopyPaste absolutely for free,

00:52:32.659 --> 00:52:36.699
it's built into UIWebView, you
don't have to do a single thing.

00:52:36.699 --> 00:52:45.649
You get all of the gestures, all of the functionality,
you can copy from a web view into native elements,

00:52:45.650 --> 00:52:54.380
copy from native elements and paste into web view's text
area, or input on a text, on a webpage back and forth.

00:52:54.380 --> 00:52:58.280
It's very easy, you can select
images, select text, the works.

00:52:58.280 --> 00:53:01.650
Sometimes you may want to disable selection.

00:53:01.650 --> 00:53:07.320
If you've got some JavaScript on your page, it
adds behavior to something with certain events.

00:53:07.320 --> 00:53:11.780
The selection may not play well
with that when that UI pops up.

00:53:11.780 --> 00:53:18.710
So the easiest way to deal with this is to use the
cascading style sheet selector WebKit user select

00:53:18.710 --> 00:53:20.849
and set that to none.

00:53:20.849 --> 00:53:28.309
But don't do that for the whole document, just do it on
a per element basis for the ones where you don't want,

00:53:28.309 --> 00:53:33.460
you explicitly don't want to tamper with the
built in, with the functionality you're providing.

00:53:33.460 --> 00:53:40.090
Because otherwise you want the user to be able to basically
have the same experience they have with all other content.

00:53:40.090 --> 00:53:45.460
They can copy it whenever they
want, paste it whenever they want.

00:53:45.460 --> 00:53:50.110
So the other big new thing are the data detectors.

00:53:50.110 --> 00:53:55.349
These automatically convert data in a
page that is formatted a certain way

00:53:55.349 --> 00:53:59.880
like a telephone number or a URL, into clickable URLs.

00:53:59.880 --> 00:54:05.590
The telephone number would make a phone call, the
clickable URL, the link would go to another page etcetera.

00:54:05.590 --> 00:54:11.160
And there's a property on UIWebView called
data detector types and this is a bit mask

00:54:11.159 --> 00:54:20.750
of the four types we currently provide which are phone
numbers, a type for links of course, you can specify none,

00:54:20.750 --> 00:54:26.119
or you can specify all and there's a lot
of benefit to adding all because this means

00:54:26.119 --> 00:54:29.049
that any data detector types we add in the future,

00:54:29.050 --> 00:54:32.980
your app will automatically support
them without needing to recompile.

00:54:32.980 --> 00:54:38.530
Use this instead of the detectsPhoneNumbers property.

00:54:38.530 --> 00:54:46.519
That was what we had in 2.0 and that's deprecated now, so
when you're updating your apps to resubmit them to the store

00:54:46.519 --> 00:54:53.659
with new features, take a moment and replace the
detectsPhoneNubmers with the data detector types.

00:54:53.659 --> 00:55:01.379
So that's what's new in iPhone 03S
and that concludes this session.

00:55:01.380 --> 00:55:08.829
We've got some additional information, you can talk to
Vicki Murley, she is our Safari Technologies Evangelist

00:55:08.829 --> 00:55:11.469
and I encourage you to look at the documentation.

00:55:11.469 --> 00:55:16.889
There's a class references and there's a
conceptual document called the URL loading system.

00:55:16.889 --> 00:55:22.549
It's extremely useful in understanding how
to work with not just URLs but requests,

00:55:22.550 --> 00:55:26.120
credential authentication, and URL connection itself.

00:55:26.119 --> 00:55:30.750
You can find all that documentation
on the web at developer.apple.com

00:55:30.750 --> 00:55:33.469
and it should also be something you can access from Xcode.

00:55:33.469 --> 00:55:38.579
So you can download the current doc sets and
access that information right on your computer.
WEBVTT

00:00:13.179 --> 00:00:20.789
>> This is Session 204, Building Compatible Websites Using
Emerging Web Technologies and my name is Vicki Murley,

00:00:20.789 --> 00:00:23.640
I'm the Safari Technologies Evangelist at Apple.

00:00:23.640 --> 00:00:28.830
So you have seen some pretty cool web technology this week.

00:00:28.829 --> 00:00:35.219
You saw a great presentation on CSS
Effects, how to create rich user interfaces

00:00:35.219 --> 00:00:38.449
and add rich animations to your websites.

00:00:39.630 --> 00:00:46.750
We had a great session on HTML 5 Audio and Video
Elements, where you saw how easy it was to add audio

00:00:46.750 --> 00:00:53.159
and video to web pages and then integrate
that media with other elements in the page.

00:00:53.159 --> 00:00:58.409
And just before this session we had another
great session on HTML 5 Offline Data,

00:00:58.409 --> 00:01:04.170
so you saw how you could store data
locally from your web application.

00:01:04.170 --> 00:01:13.670
The one thing that is generally very high on the
list of concerns for web developers is compatibility.

00:01:13.670 --> 00:01:18.799
So generally we think about compatibility
in kind of a one to one relationship.

00:01:18.799 --> 00:01:24.709
Like this plug works with this socket
or this mouse works with this computer

00:01:24.709 --> 00:01:28.640
or this website works with this web browser.

00:01:28.640 --> 00:01:35.900
And this one to one relationship would be
fine if we were back in 2002 for instance.

00:01:35.900 --> 00:01:45.580
Back then a little over 2% of people were using Netscape
Navigator, a little over 1% were using something else,

00:01:45.579 --> 00:01:51.259
but the vast majority of people were
using one version of Internet Explorer.

00:01:51.260 --> 00:01:58.469
Over the last couple of years the landscape for
browser market share has definitely changed.

00:01:58.469 --> 00:02:04.129
Now almost 40% of people are using
something other than Internet Explorer

00:02:04.129 --> 00:02:09.449
and even that Internet Explorer chunk
is divided into different versions.

00:02:09.449 --> 00:02:15.419
So lots of people visiting your website could
be using you know, any different browser.

00:02:15.419 --> 00:02:23.829
So instead now from that kind of one to one compatibility
relationship that I described, compatibility for websites

00:02:23.830 --> 00:02:27.890
and web browsers really means a
one to many kind of relationship.

00:02:27.889 --> 00:02:34.149
If you want your website to get lots of traffic,
have lots of visitors, have lots of users,

00:02:34.150 --> 00:02:39.349
you have to be compatible with a wide range of browsers.

00:02:39.349 --> 00:02:41.859
So that is the conundrum today.

00:02:41.860 --> 00:02:49.230
We have all of these amazing web technologies
and we want to make them available to users,

00:02:49.229 --> 00:02:56.709
to deliver the best possible user experience, but
at the same time we want your site to be available

00:02:56.710 --> 00:03:00.890
to the largest number of users that is possible as well.

00:03:00.889 --> 00:03:04.269
So this is the problem that we're going to address today.

00:03:04.270 --> 00:03:08.510
How to merge these two issues.

00:03:08.509 --> 00:03:17.759
The way we're going to address it, first we're going to
talk about some common coding pitfalls and how to avoid them

00:03:17.759 --> 00:03:24.340
and after that we're going to move on to specific
fallback techniques for each of the three technologies

00:03:24.340 --> 00:03:33.550
that I just mentioned, CSS Effects, HTML
5 Media Elements and HTML 5 Offline Data.

00:03:33.550 --> 00:03:38.890
So let's get started with common coding pitfalls.

00:03:38.889 --> 00:03:45.879
Probably the number one most common
coding pitfall that most people run into,

00:03:45.879 --> 00:03:49.120
that I've ever seen has got to be browser sniffing.

00:03:49.120 --> 00:03:58.200
And this is the practice of looking to see which web browser
the webpage is currently being viewed in and then serving

00:03:58.199 --> 00:04:01.299
up code that is specific to that browser.

00:04:01.300 --> 00:04:09.010
The way that people do browser sniffing
is by looking at the user agent string.

00:04:09.009 --> 00:04:16.629
The user agent string is a string that is sent by the
web browser to the web server when a webpage is requested

00:04:16.629 --> 00:04:22.300
and you can also see what the user
agent string is in JavaScript

00:04:22.300 --> 00:04:27.240
if you execute user, navigator.useragent, ask Safari.

00:04:27.240 --> 00:04:32.160
Safari will again return its user agent string.

00:04:32.160 --> 00:04:39.410
So you can fetch this user agent string in JavaScript and
then do some parsing on that string to figure out exactly

00:04:39.410 --> 00:04:45.990
with browser and which version of that browser
and on which platform you are running in.

00:04:45.990 --> 00:04:50.019
So let's take a quick look at the
anatomy of a user agent string.

00:04:50.019 --> 00:04:58.000
So this is Safari 4's user agent string
on 10_5_7 and it has some key components.

00:04:58.000 --> 00:05:03.540
The first is the Safari version number, it's version 4.0.

00:05:03.540 --> 00:05:09.020
The second we have the Safari build number, it's 530.17.

00:05:09.019 --> 00:05:13.669
The next one is the WebKit build number, it's also 530.17.

00:05:13.670 --> 00:05:15.670
And then we also have some platform information.

00:05:15.670 --> 00:05:21.470
So this particular version of Safari
is running on MacOS X 10_5_7.

00:05:21.470 --> 00:05:29.460
So you can look at this user agent string and
determine which browser your page is being viewed in

00:05:29.459 --> 00:05:31.799
and serve up code that is specific to that browser.

00:05:31.800 --> 00:05:34.720
To do that you have to parse the string.

00:05:35.810 --> 00:05:41.060
To take a closer look at parsing, we're
going to go all the way back to 1998,

00:05:41.060 --> 00:05:46.280
because this is kind of when the whole
browser sniffing, user agent string,

00:05:46.279 --> 00:05:49.099
examining that string, that's when
all of this kind of started.

00:05:49.100 --> 00:05:54.660
At this time in 1998, there were really two
browsers that almost everyone was using.

00:05:54.660 --> 00:06:03.830
It was like a 55/45 split almoUst and those two
browsers were Internet Explorer and Netscape Navigator.

00:06:03.829 --> 00:06:05.879
So we have an example here.

00:06:05.879 --> 00:06:13.779
We have both of their user agent strings and we have
some code to examine those strings and set variables

00:06:13.779 --> 00:06:20.399
to let us know whether the user is looking
at our page in IE or in Netscape Navigator.

00:06:20.399 --> 00:06:26.539
And what our code might look like, in pseudo code of
course, is we might have three branches of our code.

00:06:26.540 --> 00:06:35.629
One is the Internet Explorer branch, one is the Netscape
Navigator branch and the third is sort of everybody else.

00:06:35.629 --> 00:06:44.350
So I may have some you know, it's 1998, so maybe I have an
image rollover effect and I'm using document.all to do that,

00:06:44.350 --> 00:06:48.830
but with Netscape I have to use document.layers,
so I have a different branch for that

00:06:48.829 --> 00:06:52.019
and my everybody else branch, they
don't get a rollover at all.

00:06:52.019 --> 00:06:57.069
I'm just going to use a static image for everyone else.

00:06:57.069 --> 00:06:59.939
So you know, here's the idea.

00:06:59.939 --> 00:07:09.730
We've got these three branches but what happens when
the new information is added to the user agent string?

00:07:09.730 --> 00:07:16.540
So this was the Internet Explorer user
agent string back in 1998, this is MS IE4,

00:07:16.540 --> 00:07:22.569
this is the user agent string of IE8 today, 2009.

00:07:22.569 --> 00:07:31.079
So you can see, a lot of change has happened in you know,
more than ten years but those changes happened incrementally

00:07:31.079 --> 00:07:39.800
and the code that you're using to parse that string has to
be robust enough to handle all of those unexpected changes.

00:07:39.800 --> 00:07:45.540
You also can run into a situation where the
version number of the same browser changes

00:07:45.540 --> 00:07:49.900
and this isn't you know, a problem
that only happens in the past.

00:07:49.899 --> 00:07:51.560
This is currently happening as well.

00:07:51.560 --> 00:08:02.470
Opera is getting ready to ship Opera 10 and in their testing
they found that some very high profile key banking websites,

00:08:02.470 --> 00:08:06.360
identified them as Opera version 1, not version 10.

00:08:06.360 --> 00:08:11.250
Just because of an error in the way that
they were parsing the user agent string.

00:08:11.250 --> 00:08:15.240
You can read more about that on
one of their blog entries there.

00:08:15.240 --> 00:08:21.389
So we talked about you know, what
happens if the user agent string changes,

00:08:21.389 --> 00:08:25.449
well there are other problems with
this approach of browser sniffing.

00:08:25.449 --> 00:08:28.329
So what if new features are added?

00:08:28.329 --> 00:08:35.299
Well if it's supported in one browser, I have to
add the code there, then maybe it's later supported

00:08:35.299 --> 00:08:39.870
in another browser, I'm going to add
it there as well, modify my code again.

00:08:39.870 --> 00:08:47.580
The everyone else branch, it never gets
access to the new feature so sorry for them.

00:08:47.580 --> 00:08:51.900
Also not quite as common but sometimes features are removed.

00:08:51.899 --> 00:08:55.490
So we all know document.layers is not around anymore.

00:08:55.490 --> 00:08:58.659
Now that code path is totally broken.

00:08:58.659 --> 00:09:06.179
And often as we know now, especially in the last
couple years, new browsers are sometimes released.

00:09:06.179 --> 00:09:11.979
So any new browser that would come out
and you haven't updated your parsing code

00:09:11.980 --> 00:09:17.970
and the way you've structured these branches, it's
just going to get, your kind of everybody else branch

00:09:17.970 --> 00:09:25.430
and it could be that the new browsers that have come out
support every feature that you're looking for but the users

00:09:25.429 --> 00:09:32.719
that are visiting your site in those browsers are
going to get a very minimal, even degraded experience.

00:09:32.720 --> 00:09:40.070
So it becomes obvious as we think about the user agent
string changing, new versions of existing browsers,

00:09:40.070 --> 00:09:45.020
features being added, features being
removed, new browsers coming out,

00:09:45.019 --> 00:09:52.669
it becomes obvious that this approach
becomes unmanageable, very quickly.

00:09:52.669 --> 00:09:58.179
Luckily there is a better approach
and that is feature detection.

00:09:58.179 --> 00:10:03.019
And the premise of feature detection is
that you test and branch on features,

00:10:03.019 --> 00:10:07.000
not the current browser that the page is being viewed in.

00:10:07.000 --> 00:10:14.129
So a lot of the problems that we talked about user
agent string changes, new versions of existing browsers,

00:10:14.129 --> 00:10:17.379
features being added, features
being removed, new web browsers,

00:10:17.379 --> 00:10:21.879
a lot of these go away if you're using feature detection.

00:10:21.879 --> 00:10:27.559
It's not to say that feature detection is sort of the
end all, be all solution and you're never going to have

00:10:27.559 --> 00:10:34.079
to update your code again and your life is going to
be perfect, but it does alleviate a lot of the pain

00:10:34.080 --> 00:10:41.070
of unexpected changes and adopting new
features in other browsers, et cetera.

00:10:41.070 --> 00:10:45.210
So let's look at some common feature detection techniques.

00:10:45.210 --> 00:10:49.009
You can check to see if a certain object exists,

00:10:49.009 --> 00:10:54.120
you can check to see if a certain function
exists if you want to use a particular feature.

00:10:54.120 --> 00:11:02.769
I would see if the open database method
exists if I wanted to use the HTML 5 SQL API.

00:11:02.769 --> 00:11:06.500
You can test a property like innerHTML or contentEditable.

00:11:06.500 --> 00:11:12.000
So you can test all sorts of things
and branch your code accordingly.

00:11:12.000 --> 00:11:17.820
But there are some pitfalls that
I would like to make you aware of.

00:11:17.820 --> 00:11:19.860
First of all let's look at this one.

00:11:19.860 --> 00:11:22.700
Here I'm calling window.opendatabase.

00:11:22.700 --> 00:11:24.810
I'm actually executing the function here.

00:11:24.809 --> 00:11:26.129
I really don't need to.

00:11:26.129 --> 00:11:30.049
I just want to see if it exists.

00:11:30.049 --> 00:11:36.309
In this one I'm actually calculating
the value of .interhtml.

00:11:36.309 --> 00:11:41.939
So if I had a very large webpage and I
got all the .interhtml of that webpage,

00:11:41.940 --> 00:11:47.180
just to see if this property existed,
that would be really bad.

00:11:47.179 --> 00:11:51.519
And also at times you can get false negatives.

00:11:51.519 --> 00:11:58.360
So document.body.contenteditable, is actually
checking to see not if content editable exists,

00:11:58.360 --> 00:12:01.950
but if it is set on the body and set to true.

00:12:01.950 --> 00:12:09.170
You know, it could be set to false or not set at all, which
would evaluate to 0, but then that would be telling me

00:12:09.169 --> 00:12:14.169
that this feature isn't supported
if I were to use this approach.

00:12:15.320 --> 00:12:20.610
So there's actually a better approach for
testing just for the existence of objects,

00:12:20.610 --> 00:12:25.210
properties and methods and that's to use In.

00:12:25.210 --> 00:12:35.560
So we can change all of these to use In if
XMLHttpRequest with IN window, open database in window,

00:12:35.559 --> 00:12:40.539
enter HTML In document.body and
content editable, indocument.body

00:12:40.539 --> 00:12:46.149
and we'll save ourselves from the
problems that I just mentioned.

00:12:46.149 --> 00:12:49.179
So this is a much better approach.

00:12:49.179 --> 00:12:58.289
Another best practice if you're using feature
detection, always set construct your code branches

00:12:58.289 --> 00:13:01.179
so that you're branching to web standards first.

00:13:01.179 --> 00:13:09.109
Not only do you have a better chance of having
the same rendering across multiple browsers

00:13:09.110 --> 00:13:15.050
that all support standards, so your website is
likely to look and behave the same in more browsers

00:13:15.049 --> 00:13:23.429
if you're using standards, but also it's just you
know, best practices to test probable conditions first.

00:13:23.429 --> 00:13:31.870
Lastly, make sure that you don't use feature detection
as kind of a way to do browser sniffing you know.

00:13:31.870 --> 00:13:40.580
We all know that looking at the user agent string is bad
because parsing is often fragile, but you don't want to look

00:13:40.580 --> 00:13:44.820
at a given feature that you know only one
browser implements and then have a long,

00:13:44.820 --> 00:13:48.410
long block of code all specific to that browser.

00:13:51.210 --> 00:13:57.950
OK, so that covers some common coding
pitfalls and how to avoid them.

00:13:57.950 --> 00:14:05.009
Now we're going to get into specific fallback
techniques and we're going to start off with CSS Effects.

00:14:05.009 --> 00:14:13.600
[ no speaking ]

00:14:13.600 --> 00:14:22.200
So many, many applications on MacOS X use animation and
rich effects to enhance the experience for the user.

00:14:22.200 --> 00:14:29.610
So some really good example animations are when I
minimize a window to the dock, it doesn't just disappear

00:14:29.610 --> 00:14:33.960
and then reappear in the dock, there's an
animation that tells me exactly where it went.

00:14:33.960 --> 00:14:39.519
In iPhoto, if I want to get a closer look at
one of these photos, I can double-click it,

00:14:39.519 --> 00:14:47.059
it doesn't just appear at a larger size, it actually
animates out to the larger size for me to view.

00:14:47.059 --> 00:14:50.459
People are coming to expect these
same sort of rich interactions

00:14:50.460 --> 00:14:54.210
and rich animations in web applications as well.

00:14:54.210 --> 00:15:02.950
So here we have the same photo album in MobileMe and I
have the exact same experience that I have on the desktop.

00:15:02.950 --> 00:15:10.379
When I double-click a photo, it animates out to a
larger size so that I can get a closer look at it.

00:15:10.379 --> 00:15:15.340
One of the technologies that makes this
possible in web browsers is CSS Effects.

00:15:15.340 --> 00:15:21.280
So there are many different kinds of CSS
Effects, there's text and image effects,

00:15:21.279 --> 00:15:30.600
there's CSS Transforms which allow you to translate,
skew, scale or rotate an element in space on the page.

00:15:30.600 --> 00:15:35.600
There's CSS Transitions which are just simple animations.

00:15:35.600 --> 00:15:43.440
And we also have CSS Animations which give you
fine-grained control over the behavior of the animation path

00:15:43.440 --> 00:15:47.780
and there are also a couple dom
events associated with CSS Animations,

00:15:47.779 --> 00:15:51.689
so that you can know when an animation
has started, stopped or iterated.

00:15:51.690 --> 00:16:01.290
So I'm not going to go too in depth on the details
of how to implement CSS Effects in your web pages,

00:16:01.289 --> 00:16:06.399
because we already had a whole session on this
earlier this week and if you weren't able to catch it,

00:16:06.399 --> 00:16:13.939
you'll be able to watch it on video through ADC and I highly
recommend that you do that because it was a great session.

00:16:13.940 --> 00:16:18.750
Instead, we're going to dig into the
fallback techniques for CSS Effects.

00:16:18.750 --> 00:16:21.039
We're going to tackle three areas.

00:16:21.039 --> 00:16:27.139
First we're going to talk about Automatic Graceful
Fallback, next we're going to talk about Dynamic Fallback

00:16:27.139 --> 00:16:32.750
with JavaScript and third we're
going to talk about Media Queries.

00:16:32.750 --> 00:16:37.509
So let's get started with Automatic Graceful Fallback.

00:16:37.509 --> 00:16:41.639
So the concept here is incredibly simple.

00:16:41.639 --> 00:16:43.340
It could not be simpler.

00:16:43.340 --> 00:16:47.710
Automatic Graceful Fallback really
just means that any CSS property

00:16:47.710 --> 00:16:50.769
that a browser doesn't understand, it just ignores it.

00:16:50.769 --> 00:16:51.490
It drops it.

00:16:51.490 --> 00:16:53.310
It doesn't render it.

00:16:53.309 --> 00:16:54.059
That's it.

00:16:54.059 --> 00:16:57.849
That's the only thing that you need to know.

00:16:57.850 --> 00:17:02.750
What this requires though, this concept, it
requires you kind of letting go of that idea

00:17:02.750 --> 00:17:06.150
that every website has to look
exactly the same in any browser.

00:17:06.150 --> 00:17:08.019
So here's a great example.

00:17:08.019 --> 00:17:11.259
My text on the left is enhanced.

00:17:11.259 --> 00:17:16.599
It has a couple shadows behind it that are
two different colors and it looks really cool.

00:17:16.599 --> 00:17:21.699
The text on the right doesn't have those shadows
behind it, but it's still readable you know.

00:17:21.700 --> 00:17:28.920
So this is a great example of how
Graceful Fallback kind of works.

00:17:28.920 --> 00:17:32.900
Browser on the right doesn't understand
these text shadow properties

00:17:32.900 --> 00:17:37.800
and so it just simply doesn't render
them but the page is still functional.

00:17:37.799 --> 00:17:46.009
So to illustrate this idea we have a demo and we
are going to invite Dean Jackson to the stage.

00:17:46.009 --> 00:17:52.180
[ applause ]

00:17:52.180 --> 00:17:58.289
>> I'm pretty sure when they think
graceful they come straight to me.

00:17:58.289 --> 00:18:05.559
OK, so as Vicki said, CSS has this great feature
where effectively it breaks easily for you.

00:18:05.559 --> 00:18:07.480
It ignores things that it doesn't know about.

00:18:07.480 --> 00:18:14.329
And it's important to realize that this was actually
a conscious design decision from the start of CSS.

00:18:14.329 --> 00:18:20.019
Because the people writing the specifications wanted
to be able to update the specification and innovate

00:18:20.019 --> 00:18:24.150
without having to wait for browsers to catch up.

00:18:24.150 --> 00:18:28.130
And also you're not always sure what
type of browser you're going to be using.

00:18:28.130 --> 00:18:31.230
You might have users that are on an
old version of the current browser,

00:18:31.230 --> 00:18:34.130
say Safari 3, haven't upgraded to Safari 4 yet.

00:18:34.130 --> 00:18:39.160
Or they might be browsing with a completely
different context such as a voice browser

00:18:39.160 --> 00:18:44.300
or you know have a completely different device
characteristics or they might be stuck on a browser

00:18:44.299 --> 00:18:52.440
that has a huge market share but hasn't had
many new features added to it for a while.

00:18:52.440 --> 00:19:01.190
But so it would have been quite easy to sort of shame
some browsers in this bit so I'm trying to avoid that.

00:19:01.190 --> 00:19:10.029
So what am I going to do here is I've got this blog,
it's quite a prestigious blog, it's my WWDC blog

00:19:10.029 --> 00:19:15.619
and I believe I've stuck to the terms of the
NDA by not giving out too much information.

00:19:15.619 --> 00:19:19.919
You can see it's pretty, it's a pretty standard,
it's pretty minimal feel, something you want to do.

00:19:19.920 --> 00:19:23.750
Now this is in fact the display
you'd get on a legacy browser,

00:19:23.750 --> 00:19:28.890
sort of designed for the absolute base you
know, lowest common denominator type thing.

00:19:28.890 --> 00:19:31.640
But it's a pretty common view.

00:19:31.640 --> 00:19:34.700
What I want to do is add that bling
that Vicki mentioned on the slide.

00:19:34.700 --> 00:19:42.170
I want to add a few simple things in the CSS, using the
new features of CSS, but I don't want to break the page.

00:19:42.170 --> 00:19:44.690
So there's three important rules I want to do.

00:19:44.690 --> 00:19:46.769
I don't want to ever touch the content of the page.

00:19:46.769 --> 00:19:49.329
I'm not going to, let's assume
that I can't touch the content.

00:19:49.329 --> 00:19:53.379
I don't own it in this case because it's
my blog but I don't, can't touch it.

00:19:53.380 --> 00:19:57.500
Secondly, I'm not going to even touch the style
sheet that's currently applied to the page.

00:19:57.500 --> 00:20:00.349
I don't want to change any of the style rules.

00:20:00.349 --> 00:20:04.819
What I am going to do is add new style
rules to the page in the new style sheet.

00:20:04.819 --> 00:20:11.369
The most important rule number three is, the new rules
I add, every one of them has to gracefully degrade.

00:20:11.369 --> 00:20:14.949
So they have to be either ignored
or have no effect on an old browser.

00:20:14.950 --> 00:20:17.170
So basically just adding functionality to the page.

00:20:17.170 --> 00:20:22.570
You can sort of think of this as what you might be able
to do tonight to sort of you know, bling up your page.

00:20:22.569 --> 00:20:24.799
Because it turns out believe it, it was a surprise to me,

00:20:24.799 --> 00:20:30.319
but lots of attendees at WWDC use
modern browsers like Safari so.

00:20:30.319 --> 00:20:32.019
So OK, I'm going to show you what I do.

00:20:32.019 --> 00:20:35.059
Like I said, I don't want to shame a
browser, so I'm actually going to use a trick

00:20:35.059 --> 00:20:39.940
and normally you would just load you know, you'd
load the new styles in your existing style sheet.

00:20:39.940 --> 00:20:43.200
I've just got a little button up here
and it's got a little bit of JavaScript

00:20:43.200 --> 00:20:47.529
that adds a new style element to
the page with the new rules.

00:20:47.529 --> 00:20:50.079
So I can switch between sort of on or off.

00:20:50.079 --> 00:20:54.269
So here's what we're going for,
here's where we're coming from.

00:20:54.269 --> 00:20:57.220
Like I said, normally you would just put the new rules.

00:20:57.220 --> 00:21:00.230
So let's just have a look at the style sheet.

00:21:00.230 --> 00:21:02.950
These are the new rules on the page.

00:21:02.950 --> 00:21:06.160
I'm not going to worry too much about
the syntax because all this is documented

00:21:06.160 --> 00:21:09.670
on the developer.apple.com/safari website.

00:21:09.670 --> 00:21:11.670
Let me just point out some things.

00:21:11.670 --> 00:21:15.090
So one thing that's quite obvious
is we've got a custom style sheet.

00:21:15.089 --> 00:21:20.949
Now I guess most of you know that browsers have,
there's a very limited set of fonts that can be used

00:21:20.950 --> 00:21:25.759
across on all platforms and I assume if you
know a web developer they'll talk you to death

00:21:25.759 --> 00:21:29.029
about how annoyed they are that
there's only a limited set of browsers.

00:21:29.029 --> 00:21:33.399
So what I've done here is I want to,
I've added two new fonts to the page.

00:21:33.400 --> 00:21:41.800
I want to have a different font for the heading and I've
got a nice font down here for the, you see this is something

00:21:41.799 --> 00:21:44.019
that doesn't ship with the operating system.

00:21:44.019 --> 00:21:49.960
And all I've done in the CSS is I've
linked to the OTF, the Open Type File.

00:21:49.960 --> 00:21:52.019
You can link to a True Type or Open Type file.

00:21:52.019 --> 00:21:56.730
I just give it a name and then I put
it directly into my Font Family rule.

00:21:56.730 --> 00:22:03.069
Now what's happened is because Safari supports embedded
fonts, it sees this font first in the list and uses it.

00:22:03.069 --> 00:22:06.269
Other browsers that don't support the
embedded font, just go on to the list

00:22:06.269 --> 00:22:09.809
and get the default fonts that
I've already written for the page.

00:22:09.809 --> 00:22:14.669
You can see here I use Anivers, you can use
any name you want and you can link to any file.

00:22:14.670 --> 00:22:19.610
Next up let's have a look at this
element here, the blue navigation.

00:22:19.609 --> 00:22:22.939
Just added some rounded corners
to it, as I toggle between it.

00:22:22.940 --> 00:22:24.460
It's a really simple rule.

00:22:24.460 --> 00:22:27.670
I've just added a border radius of 12 pixels.

00:22:27.670 --> 00:22:28.950
Really simple one rule.

00:22:28.950 --> 00:22:35.809
On a browser that doesn't support border radius, it just
gets ignored and you can see actually how the extensions

00:22:35.809 --> 00:22:43.000
to CSS works because I've also included the rule for border
radius that Mozilla uses and this is running in Safari

00:22:43.000 --> 00:22:46.210
but because Safari doesn't understand
the Mozilla rule it just ignores it.

00:22:46.210 --> 00:22:48.829
It doesn't have any different, it
doesn't change the page in any way.

00:22:48.829 --> 00:22:50.750
So sort of using the extensions in reverse.

00:22:50.750 --> 00:22:58.009
Next, I've got this bright and bubbly personality so
I wanted to have a sort of glow effect on the header.

00:22:58.009 --> 00:23:04.589
This is the sort of purple little bit at the top and I could
have used an image and that would have been quite simple,

00:23:04.589 --> 00:23:07.319
but let's say I wanted to cut down on
the amount of resources I'm downloading.

00:23:07.319 --> 00:23:13.990
I want to declare a gradient in CSS and again I won't get
into the syntax, but here's the rule for the header element

00:23:13.990 --> 00:23:18.900
and I have a gradient, I just define, I wanted a circular
gradient, a radial gradient, I define where it is

00:23:18.900 --> 00:23:23.590
and how big I want it to be and then I just say the two
colors that I want to blend from and I get this sort

00:23:23.589 --> 00:23:28.759
of nice effect that you see is pretty
common in lots of the Apple designs.

00:23:28.759 --> 00:23:30.019
Next up shadows.

00:23:30.019 --> 00:23:33.759
Really wanted these sort of boxy
elements to pop out from the page.

00:23:33.759 --> 00:23:36.039
You can see here got this nice shadow.

00:23:36.039 --> 00:23:37.549
I ... actually do I...

00:23:37.549 --> 00:23:42.109
no. But anyway, you can see there's
a little shadow on the edge here.

00:23:42.109 --> 00:23:47.569
This is like again the simple, simple property to add,
WebKit box shadow and I just say where I want the shadow

00:23:47.569 --> 00:23:51.299
to be, offset, how blurred I want
it to be and I can specify color.

00:23:51.299 --> 00:23:56.919
Again, WebKit box shadow isn't supported on some
other browsers, but that's not going to matter.

00:23:56.920 --> 00:24:00.170
They'll just get the default fallback of no shadow.

00:24:00.170 --> 00:24:02.680
But it's not just limited to boxes.

00:24:02.680 --> 00:24:07.640
If you look really closely, its very subtle
effect is that the text here has a shadow.

00:24:07.640 --> 00:24:10.090
So it's hard to see, if you look while the font's changing,

00:24:10.089 --> 00:24:13.829
you can see it actually just jumps
out a bit from the background.

00:24:13.829 --> 00:24:15.710
It's got a shadow too.

00:24:15.710 --> 00:24:21.750
If you've ever looked really, really closely at the
iPhone UI, if you look at the top of the navigation bars,

00:24:21.750 --> 00:24:26.029
you'll see that the text, even though it's really
small, has this very, very small shadow inside it,

00:24:26.029 --> 00:24:32.369
these text shadows can really add to the page
without sort of being completely in your face.

00:24:32.369 --> 00:24:38.919
So just like box shadow, text shadow you don't even need the
prefix for this one, same rules and you can apply any color.

00:24:38.920 --> 00:24:45.400
Just the way shadows work in real life, well not really no.

00:24:45.400 --> 00:24:47.430
OK, another great example.

00:24:47.430 --> 00:24:54.910
I wanted to style the list here a little differently,
this is just a plain list but on my enhanced page I wanted

00:24:54.910 --> 00:24:59.340
to have alternate rows in a slightly
different background color.

00:24:59.339 --> 00:25:04.769
Now while I said, we mentioned
that property rules are the things,

00:25:04.769 --> 00:25:10.299
if the browser doesn't understand it it'll just
ignore it, in this case, background color is sort

00:25:10.299 --> 00:25:12.210
of supported by nearly every browser out there.

00:25:12.210 --> 00:25:17.220
But it's not just property rules that gets
ignored, here I've used a CSS selector.

00:25:17.220 --> 00:25:23.839
So I've used a CSS 3 selector called Nth Child and what this
means is every odd numbered child in the element is going

00:25:23.839 --> 00:25:28.599
to have this rule applied to it and so if the
browser doesn't support in this case the selector,

00:25:28.599 --> 00:25:31.349
all the property definitions within
that selector are just ignored.

00:25:31.349 --> 00:25:35.889
Same way property rules are ignored,
the selector rules can be ignored.

00:25:35.890 --> 00:25:38.830
So in this case, Safari gets background color.

00:25:38.829 --> 00:25:42.829
I've also added a little transition because
I wanted an effect where I say well,

00:25:42.829 --> 00:25:46.629
what happens when you put your mouse over it and I'll
sort of slide it down and you probably would do it faster

00:25:46.630 --> 00:25:50.100
in real life, but I wanted this nice effect
to give sort of interactive feedback.

00:25:50.099 --> 00:25:52.429
I didn't want it to just snap to a color.

00:25:52.430 --> 00:25:56.750
And I can do this again because transition isn't supported.

00:25:56.750 --> 00:25:58.380
Now lastly to the cool one.

00:25:58.380 --> 00:26:03.860
Now you'll notice here the difference between this
image, oh I've added sort of a feathered edge to it,

00:26:03.859 --> 00:26:09.529
I've also added a little pop effect, so
as I put my mouse over it, it does this.

00:26:09.529 --> 00:26:12.500
In the old browser of course, it's not doing anything.

00:26:12.500 --> 00:26:15.069
Sort of just an extra feature you can add.

00:26:15.069 --> 00:26:16.329
Now this one looks a bit complicated.

00:26:16.329 --> 00:26:17.669
We'll start with the mask.

00:26:17.670 --> 00:26:24.019
It's actually got quite a detailed syntax, but I've just
basically added some images that I've put into the page

00:26:24.019 --> 00:26:26.220
that will cut out of the image
and give you a blurred effect.

00:26:26.220 --> 00:26:29.410
You can actually do any sort of shape you want.

00:26:29.410 --> 00:26:36.040
I also said that when the image is being drawn
normally, I'm applying a transform at a scale of .97.

00:26:36.039 --> 00:26:40.549
What I've mean is I've just made the image a little
bit smaller and when it's in the hover state,

00:26:40.549 --> 00:26:46.450
I make the scale 1.03, just a little bit bigger
and I also give it this little 5 degree rotation.

00:26:46.450 --> 00:26:47.960
So I give it a twist.

00:26:47.960 --> 00:26:53.069
I've also added a transition, let's say over half a
second, I want you to animate between these two values

00:26:53.069 --> 00:26:56.849
and that's what you get, this pop in and pop out effect.

00:26:56.849 --> 00:26:58.859
So as you can see like that's all I did?

00:26:58.859 --> 00:27:01.339
The existing page hasn't changed.

00:27:01.339 --> 00:27:04.649
My grandfather who's still running an
old browser is going to see my blog.

00:27:04.650 --> 00:27:09.460
I don't know why he would be reading a
WWDC blog, but all the important users

00:27:09.460 --> 00:27:14.740
that are using modern browsers are
going to get a better experience.

00:27:14.740 --> 00:27:16.009
So that's it.

00:27:16.009 --> 00:27:21.440
[ applause ]

00:27:21.440 --> 00:27:23.430
>> Thanks Dean.

00:27:23.430 --> 00:27:27.420
So just a couple points to reiterate from the demo.

00:27:27.420 --> 00:27:35.330
Don't forget, if you're using web font or embedded
font, to always specify a fallback font as Dean did.

00:27:35.329 --> 00:27:43.859
Also if your layout is dependent on the metrics of
your current font, make sure that the embedded font

00:27:43.859 --> 00:27:47.359
that you choose, the web font that
you choose, has comparable metrics.

00:27:47.359 --> 00:27:55.179
So here maybe I'm going to use this stencil font
in my web page and my fallback font is Helvetica,

00:27:55.180 --> 00:28:04.200
well this isn't you know, quite as wide as the stencil
font, so maybe Verdana would be a better choice for me.

00:28:04.200 --> 00:28:07.890
Also as Dean pointed out, pay attention to prefixes.

00:28:07.890 --> 00:28:19.050
Prefixes are really in place so that we can get the style
property out to early adopters before the final standard is

00:28:19.049 --> 00:28:24.299
in place and people can use these
properties safely, essentially.

00:28:24.299 --> 00:28:27.299
What happens is we have the property now.

00:28:27.299 --> 00:28:32.470
When the property becomes part of a
final standard, that property is dropped

00:28:32.470 --> 00:28:37.650
and your website remains compatible
regardless of whether there were changes

00:28:37.650 --> 00:28:44.880
between where we first implemented the property with
the prefix and when the final standard was ratified.

00:28:44.880 --> 00:28:49.740
So that covers Automatic Graceful Fallback.

00:28:49.740 --> 00:28:52.779
Now let's move on to Dynamic Fallback with JavaScript.

00:28:52.779 --> 00:28:54.869
So this is very simple.

00:28:54.869 --> 00:28:58.699
We're actually using a technique that
we saw earlier in the presentation.

00:28:58.700 --> 00:29:03.990
We're just looking to see, we want to
see if CSS Transitions are supported.

00:29:03.990 --> 00:29:10.950
So we're going to check to see if the WebKit
transition property is in document.body.style

00:29:10.950 --> 00:29:16.580
and if that expression evaluates to
true, then transitions are supported.

00:29:16.579 --> 00:29:23.730
This is very useful because if you're already
using JavaScript to do some animations,

00:29:23.730 --> 00:29:27.529
CSS Animations are often triggered by JavaScript.

00:29:27.529 --> 00:29:33.190
So it's very easy to go and modify
your code to now use CSS Animations.

00:29:33.190 --> 00:29:42.289
This is actually really important, especially when you
consider devices with limited CPU power such as iPhone,

00:29:42.289 --> 00:29:47.680
that would benefit from the hardware
acceleration that you get in a CSS Animation

00:29:47.680 --> 00:29:51.390
that of course would never be possible
with a JavaScript animation.

00:29:51.390 --> 00:29:59.140
OK, lastly we're going to talk about media queries for CSS.

00:29:59.140 --> 00:30:08.420
So a media query allows you to tailor your CSS based on the
characteristics of the display and they generally consist

00:30:08.420 --> 00:30:15.509
of a media type, some that you may
have heard of are ScreenPrint, TTY, TV,

00:30:15.509 --> 00:30:20.009
All is another media type and a list of media features.

00:30:20.009 --> 00:30:26.190
So in this case we're talking about CSS Effects, so
our list of media features that we're going to talk

00:30:26.190 --> 00:30:31.660
about are transformed 2D, transformed
3D, transition and animation.

00:30:31.660 --> 00:30:36.180
There's many more, but this is the
list that we're talking about today.

00:30:36.180 --> 00:30:42.279
So here's an example where we have a media
query that loads a given style sheet.

00:30:42.279 --> 00:30:45.930
If it's a screen device and 2D transforms are supported.

00:30:45.930 --> 00:30:52.430
So here is our media type screen and here
is our media feature, transformed 2D.

00:30:52.430 --> 00:31:02.549
You can also use media queries as we just saw,
to load a style sheet or you can query inline.

00:31:02.549 --> 00:31:10.970
So here we have an example where we have a media
query inline in our CSS style sheet and we're saying

00:31:10.970 --> 00:31:20.140
if it's a screen device and 2D transforms and transitions
are supported, then make all my divs scale down by 80%

00:31:20.140 --> 00:31:28.310
but when I hover over them, scale them up
by 20% greater that their original size.

00:31:28.309 --> 00:31:36.950
So you can do these inline and also as you notice, you can
have a list of operators to compose more complex queries.

00:31:36.950 --> 00:31:43.250
Here we're using And to say that we want a device
that supports 2D transforms and transitions,

00:31:43.250 --> 00:31:46.619
but you can also use Or and Only I believe.

00:31:46.619 --> 00:31:54.009
So again, here's our media type and
here is our list of media properties.

00:31:54.009 --> 00:32:02.099
OK, so that covers CSS Effects, now
let's move on to HTML 5 Media Elements.

00:32:02.099 --> 00:32:07.569
All right, so we're going to talk about a few things here.

00:32:07.569 --> 00:32:13.480
First we're going to just briefly touch
on why HTML to embed media in web pages.

00:32:13.480 --> 00:32:20.339
Second we're going to talk about creating compatible static
markup and after that we're going to move on to talking

00:32:20.339 --> 00:32:25.079
about creating compatible content on the fly.

00:32:25.079 --> 00:32:26.419
So why HTML?

00:32:26.420 --> 00:32:32.630
Well HTML Media Elements greatly
simplify media playback on the web.

00:32:32.630 --> 00:32:37.890
Not only for you the developer, you just have
to add one line of code to now have a video

00:32:37.890 --> 00:32:40.259
in your webpage, but also for your users.

00:32:40.259 --> 00:32:45.650
They don't have to download a plug-in or
install anything to be able to see video.

00:32:45.650 --> 00:32:50.930
Also, this is part of the HTML 5 standard.

00:32:50.930 --> 00:32:58.529
It means that many, by virtue of being a standard, it
means it's available for anyone to adopt and implement

00:32:58.529 --> 00:33:03.430
and in fact, many browsers out there
today already implement these elements.

00:33:03.430 --> 00:33:10.180
It's also the best way to display
video in Safari on all platforms.

00:33:10.180 --> 00:33:15.160
You can have the same exact code and get
the optimized user experience whether you're

00:33:15.160 --> 00:33:18.660
on the desktop or in Safari on iPhone.

00:33:18.660 --> 00:33:26.930
So you saw for example at a session earlier this week,
how you could have rich interactions with other elements

00:33:26.930 --> 00:33:35.509
on the page if you were using HTML 5 Audio or
Video Elements on the desktop and on iPhone we saw

00:33:35.509 --> 00:33:40.140
that same exact code running full
screen, looking great on iPhone.

00:33:40.140 --> 00:33:49.130
That session that I was just talking about happened on
Wednesday and so I'm not going to go into much more detail

00:33:49.130 --> 00:33:55.310
about how to use just the basics of HTML 5 Media Elements,

00:33:55.309 --> 00:33:59.649
but I suggest that you catch this
one as well, via ADC on iTunes.

00:33:59.650 --> 00:34:00.940
Catch the video.

00:34:00.940 --> 00:34:06.610
So let's talk about creating compatible markup.

00:34:06.609 --> 00:34:08.960
There's really two things that you need to think about.

00:34:08.960 --> 00:34:14.309
There's basic content fallback and there's
also working with multiple media resources.

00:34:14.309 --> 00:34:18.799
So the basic content fallback is dead simple.

00:34:18.800 --> 00:34:27.390
It's basically whatever is nested in between the opening
and closing video tags, is your fallback content.

00:34:27.389 --> 00:34:35.179
One thing to note here is this fallback content is
only displayed if the video tag is not supported.

00:34:35.179 --> 00:34:37.039
It's not displayed for things like errors.

00:34:37.039 --> 00:34:44.880
Like if it tried to load the video and the file
was not found or the file was corrupt or broken

00:34:44.880 --> 00:34:51.619
or even if you're pointing to an unsupported codec in
none of those cases is the fallback content displayed.

00:34:51.619 --> 00:34:55.359
Only displayed if the video tag is not supported.

00:34:56.710 --> 00:35:01.720
Moving on to working with multiple media resources.

00:35:01.719 --> 00:35:08.649
So on the video tag you know, you may be used to
seeing like an embed tag that has a type attribute.

00:35:08.650 --> 00:35:12.340
Well there isn't one of the video tag here.

00:35:12.340 --> 00:35:18.260
Instead we just have this source attribute and
whatever we throw at it, it will attempt to play.

00:35:18.260 --> 00:35:24.290
So we sort of have built in dynamic
support with this source attribute.

00:35:24.289 --> 00:35:31.480
Safari will support any installed linear codec
supported by QuickTime, so that includes the default set

00:35:31.480 --> 00:35:37.480
of installed codecs and also any
codecs that a user may install later.

00:35:37.480 --> 00:35:42.340
Those will all work with the source
attribute on the video tag.

00:35:42.340 --> 00:35:50.230
You may want to be able to show different encodings on
different platforms or if users are viewing your page

00:35:50.230 --> 00:35:53.240
in different browsers that have different support.

00:35:53.239 --> 00:35:57.349
The way to do that is to use the source tag.

00:35:57.349 --> 00:36:05.079
So you can specify a list of sources within the video
tag and basically what happens is the user agent,

00:36:05.079 --> 00:36:11.340
the web browser iterates through the list and it
just attempts to play the first encoding that it can.

00:36:11.340 --> 00:36:13.130
The first supported encoding.

00:36:13.130 --> 00:36:18.150
It doesn't continue after there's a failure,
so back to those failure cases again.

00:36:18.150 --> 00:36:25.300
If there's you know, the file is corrupt or not found
or something, this isn't really a fallback technique

00:36:25.300 --> 00:36:32.470
in the sense that if there's a failure
it doesn't just try the next one.

00:36:32.469 --> 00:36:42.009
You can also use on the source tag a type, the type
attribute to specify a mime type and this is great

00:36:42.010 --> 00:36:50.240
because you can query within the web browser, whether or not
the web browser is going to be able to play a certain type.

00:36:50.239 --> 00:36:55.899
So without having to go hit the server
and touch the video on the server at all.

00:36:55.900 --> 00:36:56.530
So this is great.

00:36:56.530 --> 00:37:01.210
It really saves you a lot of network requests
and makes things better for your users.

00:37:01.210 --> 00:37:07.300
We talked about media queries before.

00:37:07.300 --> 00:37:13.190
You can use media queries here in the source
tag as well, using the media attribute.

00:37:13.190 --> 00:37:15.490
So this is just an example.

00:37:15.489 --> 00:37:24.719
Maybe I have in for Safari on the desktop, I want to serve
up Safaridemo.mp4, so I would look for a screen device maybe

00:37:24.719 --> 00:37:32.909
with a minimum device width of 600 pixels and maybe
for another example I want to serve up a different file

00:37:32.909 --> 00:37:40.009
for Safari on iPhone, so I might look for a screen
device with a device width of 340 pixels, for instance.

00:37:40.010 --> 00:37:43.700
That's the device width on iPhone.

00:37:43.699 --> 00:37:48.439
OK, now let's move on to Creating
Compatible Dynamic Content.

00:37:48.440 --> 00:37:54.380
So you can detect audio and video support in JavaScript.

00:37:54.380 --> 00:37:55.630
It is very simple.

00:37:55.630 --> 00:38:02.010
You might want to do this if you're generating markup
on the fly or if you're toggling the visibility

00:38:02.010 --> 00:38:07.800
of a customized user interface, we'll
talk more in more detail about that later.

00:38:07.800 --> 00:38:13.310
You also might want to detect on the fly,
whether or not a given codec is supported.

00:38:13.309 --> 00:38:19.340
Might want to do that if you want to direct
your users to a certain type of content.

00:38:23.670 --> 00:38:30.230
So the way that we check to see if audio and video tags
are supported at all is we just again use this technique

00:38:30.230 --> 00:38:37.409
that we used earlier in the presentation, we
checked to see if HTML video element is in window.

00:38:37.409 --> 00:38:40.899
If it's not, then video is not supported.

00:38:40.900 --> 00:38:50.579
So in the session earlier this week, they defined custom
controls to play, pause, scrub the video, et cetera.

00:38:50.579 --> 00:38:54.679
If the video tag isn't supported, then
your users aren't going to be able

00:38:54.679 --> 00:38:57.460
to use those controls to interact with the video.

00:38:57.460 --> 00:39:01.780
So in this case you would want to probably
hide those controls, fallback to a plug-in

00:39:01.780 --> 00:39:05.460
and just use those boring plug-in controls instead.

00:39:05.460 --> 00:39:14.220
You can also detect in JavaScript as I mentioned,
whether or not a given codec is supported.

00:39:14.219 --> 00:39:20.809
So you do this using the canPlayType
method and you supply it a mime type.

00:39:20.809 --> 00:39:24.299
The answer that you're going to get might surprise you.

00:39:24.300 --> 00:39:30.039
It's going to be either probably, maybe or no.

00:39:30.039 --> 00:39:35.739
The reason is though that all we're really
supplying to canPlayType is a mime type and codecs,

00:39:35.739 --> 00:39:42.359
there's so many details that are so complicated,
it's not really possible to know conclusively

00:39:42.360 --> 00:39:47.309
if a given user agent can play a
given codec just from the mime type.

00:39:47.309 --> 00:39:51.920
So "probably" is probably the best
answer that you're going to get.

00:39:51.920 --> 00:39:55.250
So here's an example of using canPlayType.

00:39:55.250 --> 00:40:01.579
We're checking to see if my video element that
I fetched earlier, can play the type video/MP4

00:40:01.579 --> 00:40:09.500
if the value returned is not equal to probably,
I'm just going to fallback to a plug-in

00:40:09.500 --> 00:40:13.110
and if it is supported I'm going to use the video element

00:40:13.110 --> 00:40:18.510
and maybe implement some custom controls
and do some very advanced, cool stuff.

00:40:18.510 --> 00:40:25.160
OK, so that covers it for HTML 5 Media Elements.

00:40:25.159 --> 00:40:30.000
Now let's move on to Offline Data.

00:40:30.000 --> 00:40:33.469
OK, storing data offline.

00:40:33.469 --> 00:40:36.659
What can you currently use to store data offline?

00:40:36.659 --> 00:40:44.049
There's not a lot out there for you, outside of browsers
that implement HTML 5 Offline Data capabilities.

00:40:44.050 --> 00:40:47.590
You have cookies and you have syncing to the cloud.

00:40:47.590 --> 00:40:54.910
Those are pretty much your options if your
browser doesn't support these HTML 5 features.

00:40:54.909 --> 00:41:04.139
So here in HTML 5, this is just a totally, extraordinarily
new and different way of thinking about things.

00:41:04.139 --> 00:41:08.989
You know, we have CSS Animations well you
can fallback to JavaScript animations maybe.

00:41:08.989 --> 00:41:15.799
There's not really a great substitute for
things like local storage and session storage.

00:41:15.800 --> 00:41:19.470
You could use a cookie but it's not as simple and easy.

00:41:19.469 --> 00:41:27.969
You also have the SQL API which you can use
to store structured data in a local database.

00:41:27.969 --> 00:41:32.089
And you also have the Application cache
which will store all the resources

00:41:32.090 --> 00:41:35.890
for your web application locally on the user's machine.

00:41:35.889 --> 00:41:43.879
The benefits here, they're open web standards so
even if they're not implemented everywhere now,

00:41:43.880 --> 00:41:47.890
they are able to be implemented
in any browser in the future.

00:41:47.889 --> 00:41:49.829
Your code complexity is greatly reduced.

00:41:49.829 --> 00:41:53.130
It's much easier to use local storage or session storage.

00:41:53.130 --> 00:41:57.480
Just set a key value instead of doing
some complicated cookie parsing.

00:41:57.480 --> 00:42:02.000
You have very fast data access because
the data is right there on disk

00:42:02.000 --> 00:42:05.719
and it's also functional without a network connection.

00:42:05.719 --> 00:42:11.309
So without going into too much more detail
about the nuts and bolts of how the basics

00:42:11.309 --> 00:42:14.469
of HTML 5 Offline Data, we just had a session about this.

00:42:14.469 --> 00:42:18.179
So again, catch it on ADC on iTunes.

00:42:18.179 --> 00:42:27.960
So we talked a little bit about how offline data in
HTML 5 is just a totally revolutionary technology.

00:42:27.960 --> 00:42:31.809
There's been nothing else like it up until this point.

00:42:31.809 --> 00:42:34.880
And so what is there really to fallback to?

00:42:34.880 --> 00:42:36.880
You know, there's not a while lot.

00:42:36.880 --> 00:42:42.710
there/s really no substitute for the structured
data storage that you're going to be able to get.

00:42:42.710 --> 00:42:50.699
There's really no substitute for storing all the resources
for your application locally on the user's machine.

00:42:50.699 --> 00:42:59.519
So one thing that you could do is modify your user
interfaces and modify your application to make sure

00:42:59.519 --> 00:43:03.059
that they work well even if offline
functionality isn't supported.

00:43:03.059 --> 00:43:06.779
So that's what we're going to talk about today.

00:43:06.780 --> 00:43:11.510
If you want to check for offline functionality,
again we're going to visit the same concepts

00:43:11.510 --> 00:43:15.000
that we've been talking about throughout this presentation.

00:43:15.000 --> 00:43:18.809
If you want to see if local storage
and session storage are supported,

00:43:18.809 --> 00:43:23.799
just look for localStorage or sessionStorage in window.

00:43:23.800 --> 00:43:30.120
If you want to see if the SQL API is supported,
just check for openDatabase in window.

00:43:30.119 --> 00:43:39.170
And also if you want to see if the offline application cache
is supported, you can check for applicationCache in window.

00:43:39.170 --> 00:43:46.849
So to illustrate this idea, we would like
to invite Beth Dakin back to the stage.

00:43:51.130 --> 00:43:51.849
>> Hi everyone.

00:43:51.849 --> 00:43:52.920
Thanks Vicki.

00:43:52.920 --> 00:43:59.480
If you were here at the offline data session just about an
hour ago, then you would have seen that my colleague Brady

00:43:59.480 --> 00:44:02.440
and I came up with a Checkers web application.

00:44:02.440 --> 00:44:06.849
So I'm going to show that to you now and
show how you can make it gracefully fallback

00:44:06.849 --> 00:44:10.210
in browsers that don't support local storage.

00:44:10.210 --> 00:44:24.750
OK cool. So here's our Checkers web application in
Safari 4 and it's just this pretty fun little game

00:44:24.750 --> 00:44:28.530
and we implemented two local storage features.

00:44:28.530 --> 00:44:30.730
There's this Manage Games button is one of them.

00:44:30.730 --> 00:44:35.500
It auto-saves games as I play and I
can manually save a game at any time.

00:44:35.500 --> 00:44:39.630
And then there's the High Scores feature
too that it keeps track of high scores

00:44:39.630 --> 00:44:43.789
as you play the game like over time between sessions.

00:44:43.789 --> 00:44:56.969
So now I'm going to show you this same game in Safari
3.1, which I am going to load here from a script.

00:44:56.969 --> 00:45:05.089
So this is Safari 3.1, which does not support local storage,
an old version of Safari and so I can still play my game

00:45:05.090 --> 00:45:10.390
but you'll see that if I go to my Manage
Games screen, it didn't auto-save anything

00:45:10.389 --> 00:45:13.549
and if I try to save a game, nothing happens.

00:45:13.550 --> 00:45:19.000
So really it's kind of silly to have these two
features, these two buttons, the Manage Games button

00:45:19.000 --> 00:45:24.420
and the High Scores button showing at all in this browser
or other browsers that don't support local storage.

00:45:24.420 --> 00:45:28.690
So our solution here is just going
to be to hide these buttons

00:45:28.690 --> 00:45:34.110
So let's take a look at the code.

00:45:34.110 --> 00:45:42.280
So I have, this is my JavaScript file that builds up the
UI for the game and you'll see I'm adding all kinds of dizz

00:45:42.280 --> 00:45:48.420
and checkerboards and turn indicator lights
and here's the relevant part to this.

00:45:48.420 --> 00:45:53.670
I have these three functions to add the buttons and
it's just the second two buttons that I don't want

00:45:53.670 --> 00:46:00.010
to include anymore, so I'm just going to add...

00:46:00.010 --> 00:46:05.990
[ no speaking ]

00:46:05.989 --> 00:46:14.629
... a conditional statement around them so that we'll
only add these buttons when we have local storage support.

00:46:14.630 --> 00:46:23.050
And I've been really careful with the way I've
built up my application so that none of this code,

00:46:23.050 --> 00:46:26.340
none of this local storage code will
run unless I click those buttons.

00:46:26.340 --> 00:46:27.940
So I don't have to worry about anything else.

00:46:27.940 --> 00:46:34.139
But I also added guards at all of those points, anytime that
I use local storage just because in case anything changes,

00:46:34.139 --> 00:46:38.739
it's always good to have a guard in place so that
we don't have a JavaScript exception anywhere.

00:46:38.739 --> 00:46:47.509
So let's look at this again in Safari 3.1,
you'll see the buttons have just disappeared

00:46:47.510 --> 00:46:56.650
and I can still play my Checkers game and if we go back
to Safari 4 and reload, then I still have the buttons

00:46:56.650 --> 00:47:05.090
and I can still play Checkers and I can still
access all of my great offline data features.

00:47:05.090 --> 00:47:06.110
And so that's all.

00:47:06.110 --> 00:47:06.890
[ Applause ]

00:47:06.889 --> 00:47:12.650
>> Thanks Beth.

00:47:12.650 --> 00:47:15.500
That was really simple.

00:47:15.500 --> 00:47:19.210
Just like one line of code and
it was fixed in any other browser

00:47:19.210 --> 00:47:23.940
that doesn't support local storage and that's the idea.

00:47:23.940 --> 00:47:26.670
So let's recap what you have learned today.

00:47:26.670 --> 00:47:30.059
So the first number one thing that we talked

00:47:30.059 --> 00:47:35.860
about was why you should not use browser
sniffing to construct branches in your code.

00:47:35.860 --> 00:47:38.200
Instead use feature detection.

00:47:38.199 --> 00:47:47.339
Next we looked at CSS and we saw that CSS
enhancements are incredibly easy to add and add a lot

00:47:47.340 --> 00:47:50.769
of visual interest and polish to your website.

00:47:50.769 --> 00:47:59.380
We took a close look at HTML 5 Audio and Video Elements
and we learned about simple fallback mechanisms

00:47:59.380 --> 00:48:06.280
and also some fine-grained control for
how to handle different codec support.

00:48:06.280 --> 00:48:13.420
And lastly, we talked about HTML 5 Offline
Data and what a great feature it is and we saw

00:48:13.420 --> 00:48:17.590
that it's just incredibly simple to detect.

00:48:17.590 --> 00:48:19.860
So that is it for today.

00:48:19.860 --> 00:48:25.079
If you want more information you can contact me,
Vicki Murley, the Safari Technologies Evangelist

00:48:25.079 --> 00:48:31.960
and also there's a wealth of documentation on the
Safari Dev Center at developer.apple.com/Safari.
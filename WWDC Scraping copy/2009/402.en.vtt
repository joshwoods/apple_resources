WEBVTT

00:00:12.750 --> 00:00:17.980
>> Chris Lattner: My name is Chris Lattner and
I'm here to start out the beginning of this talk.

00:00:17.980 --> 00:00:23.440
So before we get started I want to talk about where
we're coming from because this is not the first WWDC

00:00:23.440 --> 00:00:27.850
and we've been shipping tools for a
long time now of course and so we--

00:00:27.850 --> 00:00:31.580
you can really split the tools that
we ship into 4 different categories.

00:00:31.579 --> 00:00:33.640
If you're on the iPhone it's very simple.

00:00:33.640 --> 00:00:39.420
If you build for the 2.0 or the 2.x
series of SDKs you build with GCC 4.0.

00:00:39.420 --> 00:00:46.120
If you build with the 3.0 series of SDKs you're
building with CG 4.2 and that's the way it is.

00:00:46.119 --> 00:00:48.759
There's no choice, nothing to worry about, it just works.

00:00:48.759 --> 00:00:52.640
4.2 has a lot of improvements over 4.0.

00:00:52.640 --> 00:00:57.100
In particular support for the new iPhone 3G S.

00:00:57.100 --> 00:01:01.719
On the Mac side of things it's
a little bit more complicated.

00:01:01.719 --> 00:01:09.379
So as of last WWDC we supported 3
compilers: GCC 4.0, 4.2 and LLVM-GCC.

00:01:09.379 --> 00:01:13.379
This year we support the same set of
compilers with the addition of Clang.

00:01:13.379 --> 00:01:20.250
So I'm going to take you through some of the enhancements
that we've done with these compilers and then take you

00:01:20.250 --> 00:01:22.510
through all the exciting things we're doing.

00:01:22.510 --> 00:01:24.630
So let's get started.

00:01:24.629 --> 00:01:27.679
Most of this talk I should say is specific to the Mac.

00:01:27.680 --> 00:01:31.380
The iPhone is, since you have no choice you get

00:01:31.379 --> 00:01:34.390
to use the great compilers we have
and you don't have to worry about it.

00:01:34.390 --> 00:01:38.719
But on the Mac there's a lot more different
options that you have so we'll talk about that.

00:01:38.719 --> 00:01:43.629
So the one, the first great feature that I want
to talk about before we go any farther is Blocks.

00:01:43.629 --> 00:01:46.589
So yesterday you heard a lot about Grand Central Dispatch.

00:01:46.590 --> 00:01:51.689
Grand Central Dispatch is a great API and Blocks
are one critical piece that fits into that.

00:01:51.689 --> 00:01:54.689
But Blocks are really not specific
to Grand Central Dispatch.

00:01:54.689 --> 00:01:57.959
If you think about a lot of APIs they
are callback based and with a lot

00:01:57.959 --> 00:02:01.779
of callback based APIs you pass
pointers to functions around.

00:02:01.780 --> 00:02:06.129
Well, you pass a pointer function around until you
realize that you have some data that that function needs

00:02:06.129 --> 00:02:09.500
and then you end up passing void pointers
and function pointers around, right?

00:02:09.500 --> 00:02:12.990
Well, this really quickly gets nasty and gross.

00:02:12.990 --> 00:02:14.900
Blocks solve that.

00:02:14.900 --> 00:02:20.789
A Block is also known as a closure or a lambda in
other languages and the great feature they have is

00:02:20.789 --> 00:02:25.310
that you can write code inline in the middle
of another function and it's an expression.

00:02:25.310 --> 00:02:30.409
This means you can write your code and in addition to
representing code that can be passed around you can refer

00:02:30.409 --> 00:02:35.620
to variables outside of that code and so here I
have a little Block and this Block iterates over all

00:02:35.620 --> 00:02:40.120
of the elements in the array adding N to it and
is defined outside the Block and the great thing

00:02:40.120 --> 00:02:45.610
about Blocks are the compiler handles the packing of all the
data for you and so you don't have to pass around void *s

00:02:45.610 --> 00:02:49.110
that you then cast off structs and all that stuff right.

00:02:49.110 --> 00:02:52.240
It just magically is done.

00:02:52.240 --> 00:02:56.080
So if you use this with Grand Central Dispatch
you end up using it sort of like this.

00:02:56.080 --> 00:03:02.940
You end up saying hey I have a unit of work to
do, pass into Dispatch Apply which is the GCD API

00:03:02.939 --> 00:03:08.419
and then Grand Central Dispatch handles executing
that in parallel on all of your processors for you.

00:03:08.419 --> 00:03:16.250
So this is a really beautiful, natural language extension
and this feature is supported in GCC 4.2, LLVM-GCC and Clang.

00:03:16.250 --> 00:03:20.939
So there's a whole lot more to say about Blocks of course
and I'm not going to go into it very much in this session

00:03:20.939 --> 00:03:24.180
but if you want to find out more
go to the Programming With Blocks

00:03:24.180 --> 00:03:28.450
and the Grand Central Dispatch
section and they'll tell you about it.

00:03:28.449 --> 00:03:35.239
If you want to there's also discussion about it in the
various Objective-C sessions throughout the conference.

00:03:35.240 --> 00:03:41.840
So Blocks I want to single out because they're
the major new feature that we've added to GCC 4.2.

00:03:41.840 --> 00:03:47.330
If you look at the other enhancements to GCC
we've made, GCC 4.0 has only had a small handful

00:03:47.330 --> 00:03:49.780
of critical bugs fixed over the last year.

00:03:49.780 --> 00:03:56.120
GCC 4.2 has had 3 features or 3
changes; Block support which we added.

00:03:56.120 --> 00:04:00.569
It has some bug fixes and it switched to 64-bit by default.

00:04:00.569 --> 00:04:06.209
Well 64-bit by default means that if you run GCC on
the command line on a 64-bit machine it will default

00:04:06.210 --> 00:04:09.390
to producing a 64-bit binary bdut if you're using Xcode

00:04:09.389 --> 00:04:13.679
or you're passing the -arch series
of flags you won't see any change.

00:04:13.680 --> 00:04:16.769
Aside from that GCC hasn't really changed.

00:04:16.769 --> 00:04:22.490
So if it's OK with you guys I'd spend the
rest of the time talking about LLVM and Clang.

00:04:22.490 --> 00:04:24.009
Is that OK?

00:04:24.009 --> 00:04:27.230
[Applause] So let's dive in.

00:04:27.230 --> 00:04:29.319
So a quick recap.

00:04:29.319 --> 00:04:30.610
What is LLVM?

00:04:30.610 --> 00:04:34.220
LLVM is really about a new strategy for compilers.

00:04:34.220 --> 00:04:36.180
Right we've been using GCC for many years.

00:04:36.180 --> 00:04:38.030
We all know it.

00:04:38.029 --> 00:04:40.799
It works but it's just not great.

00:04:40.800 --> 00:04:44.900
So we're shipping compilers based on LLVM.

00:04:44.899 --> 00:04:50.969
These compilers are available along with GCC so you
can use them if you want to but GCC is still there.

00:04:50.970 --> 00:04:55.960
Another great thing about it is that LLVM is open source
so you can actually join in the development that we do

00:04:55.959 --> 00:05:00.699
with LLVM at the website, mailing list,
bug trackers all that kind of stuff there.

00:05:00.699 --> 00:05:04.750
You saw the cool new LLVM logo that
we whipped up for the conference.

00:05:04.750 --> 00:05:09.480
So the the dragon comes back too.

00:05:09.480 --> 00:05:14.580
The dragon implies like Dragon Book and
compilers and you know all of that stuff

00:05:14.579 --> 00:05:17.509
that fits together, in case you were wondering.

00:05:18.529 --> 00:05:21.250
So, so that's what LLVM is.

00:05:21.250 --> 00:05:23.899
So why not just fix GCC, right?

00:05:23.899 --> 00:05:27.029
Well the real answer is that GCC doesn't really--

00:05:27.029 --> 00:05:30.500
it's not a strong platform for the things
we want to do in the future, right.

00:05:30.500 --> 00:05:31.939
GCC is a compiler.

00:05:31.939 --> 00:05:33.149
It does what it does.

00:05:33.149 --> 00:05:39.579
But getting it to do anything that it wasn't
originally designed to do 20 years ago is really hard.

00:05:39.579 --> 00:05:44.099
And so LLVM is really the answer for that and we
want to do something new, we want to push forward.

00:05:44.100 --> 00:05:49.939
I think there's a huge amount of innovation that we can
bring to compilers and we're just starting to do that now.

00:05:49.939 --> 00:05:53.410
So LLVM is all about redesigning how we build compilers.

00:05:53.410 --> 00:05:54.630
We build them as libraries.

00:05:54.629 --> 00:05:58.560
We build them as libraries so that we can use
them in new ways, in different applications.

00:05:58.560 --> 00:06:00.199
So we can reuse them.

00:06:00.199 --> 00:06:06.599
So we can use, you know, an x86 code generator in
some way that you know we never would have thought

00:06:06.600 --> 00:06:09.080
about when we built it in the first place.

00:06:09.079 --> 00:06:15.490
So we're focusing on building something that's fast,
flexible, performant, supports all these crazy features.

00:06:15.490 --> 00:06:23.949
In case you haven't noticed GCC has a lot of features
and so making all of that happen has taken some time

00:06:23.949 --> 00:06:26.319
but I'm really happy to say that we're to that point now.

00:06:26.319 --> 00:06:32.399
And so now that all that work has been done we can
start building on doing new, exciting things with it.

00:06:32.399 --> 00:06:37.849
So of course LLVM as we talked about yesterday
is not just used in traditional compilers.

00:06:37.850 --> 00:06:44.760
OpenGL, OpenCL and, excitingly, the static analyzer
built into Xcode are really great demonstrations

00:06:44.759 --> 00:06:50.300
of what you can do with compiler technology that
most compiler people don't think about, right.

00:06:50.300 --> 00:06:55.129
The static analyzer is a great example of how the
compiler's data flow analysis can really be used

00:06:55.129 --> 00:06:59.170
to solve interesting problems that you know
aren't really related to making code go faster,

00:06:59.170 --> 00:07:02.020
which is really exciting but you
know very different [laughter

00:07:02.019 --> 00:07:06.060
We also have LLVM-GCC and the Clang compiler.

00:07:06.060 --> 00:07:11.560
So to tell you about some of these applications I'd
like to bring Evan Cheng up on stage and he'll tell you

00:07:11.560 --> 00:07:13.240
about what we're doing with LLVM here at Apple.

00:07:13.240 --> 00:07:13.960
Evan.

00:07:13.959 --> 00:07:14.689
>> Evan Cheng: Thank you Chris.

00:07:14.689 --> 00:07:21.019
[Applause] Good afternoon, My name is Evan Cheng.

00:07:21.019 --> 00:07:23.709
I work here at Apple's Compiler Team.

00:07:23.709 --> 00:07:28.859
So here at Apple we've been doing a
lot of very exciting things with LLVM.

00:07:28.860 --> 00:07:31.250
I just want to go through a few of them today.

00:07:31.250 --> 00:07:33.509
I hope you enjoy it.

00:07:33.509 --> 00:07:38.009
First, you've heard Chris talk
about LLVM, GCC, LLVM-GCC, Clang.

00:07:38.009 --> 00:07:41.800
You might be wondering, what are these things?

00:07:41.800 --> 00:07:43.030
What exactly is GCC?

00:07:43.029 --> 00:07:44.359
How are they related?

00:07:44.360 --> 00:07:48.850
So LLVM is a set of libraries of philosophy.

00:07:48.850 --> 00:07:50.550
It's a dragon.

00:07:50.550 --> 00:07:52.020
It's many things.

00:07:52.019 --> 00:07:53.259
So how does it fit?

00:07:53.259 --> 00:07:58.219
Well if you look at a static compiler like GCC
you can roughly break it down into 3 parts.

00:07:58.220 --> 00:08:02.500
You have the front end that's responsible
for parsing your program.

00:08:02.500 --> 00:08:07.110
Then you have the optimizer that
transform your program to make it go fast,

00:08:07.110 --> 00:08:11.270
then the code generator translates
that into the machine language.

00:08:11.269 --> 00:08:18.370
Well, think of LLVM-GCC as taking the
GCC front end technology and replace it--

00:08:18.370 --> 00:08:24.040
the optimizer and code generator with kind of a turbo
charged engine, the LLVM optimizer and code generator.

00:08:24.040 --> 00:08:31.680
It looks, smells, tastes just like GCC
but it's better and we want to take a--

00:08:31.680 --> 00:08:37.289
with Clang we're taking a step further by replacing
the front end as well and just completely do away

00:08:37.289 --> 00:08:43.110
with GCC technology to produce and kind of
stitch the Clang front end with LLVM optimizer

00:08:43.110 --> 00:08:46.649
and code generator to produce a Clang opt-- compiler.

00:08:46.649 --> 00:08:50.850
It's very exciting and Chris is going
to talk to you all about Clang later.

00:08:50.850 --> 00:08:53.870
But for now let's focus on the LLVM.

00:08:53.870 --> 00:08:59.210
So again LLVM if you take a look at LLVM-GCC
it's just a traditional static compiler.

00:08:59.210 --> 00:09:04.870
One of the major things was a static compiler, one of
the common things with a static compiler is depending

00:09:04.870 --> 00:09:11.480
on other tools to kind of take the code that's
generated by the compiler and produce an executable.

00:09:11.480 --> 00:09:18.810
So for example LLVM-GCC and GCC both produce
assembly code and then requires assembler

00:09:18.809 --> 00:09:22.179
and linker to kind of produce executable.

00:09:22.179 --> 00:09:24.169
Well the other compilers out there right?

00:09:24.169 --> 00:09:32.959
Compile their embedding applications in the OS in many
of the ways that they-- they compile code at the runtime.

00:09:32.960 --> 00:09:37.440
We call these just-in-time compilers or dynamic compilers.

00:09:37.440 --> 00:09:38.940
So these are not new.

00:09:38.940 --> 00:09:45.690
The new thing with LLVM is we take the same optimizer
and code generator and we produce static compiler

00:09:45.690 --> 00:09:49.160
but we can also use it to produce just-in-time compiler.

00:09:49.159 --> 00:09:58.100
So here at Apple we use this reusable
components LLVM, we'll call it the LLVM back end,

00:09:58.100 --> 00:10:06.080
to produce a number of different applications, you know,
different JITs imbedding as part of OpenGL and OpenCL.

00:10:06.080 --> 00:10:09.680
Let's take a quick look at them.

00:10:09.679 --> 00:10:10.439
First OpenGL.

00:10:10.440 --> 00:10:12.010
You know OpenGL?

00:10:12.009 --> 00:10:18.250
This is a language for you to program your
GPU to do 2D and 3D graphics animation.

00:10:18.250 --> 00:10:22.129
Well OpenGL is a very big standard.

00:10:22.129 --> 00:10:23.939
It has many, many features.

00:10:23.940 --> 00:10:28.530
Not every graphic card support
all the features that's in OpenGL.

00:10:28.529 --> 00:10:37.589
When that happens the OpenGL system will take the function
you press and basically dynamically compile the code into--

00:10:37.590 --> 00:10:41.910
into code that's executed on your host CPU.

00:10:41.909 --> 00:10:45.370
There are couple of ways to kind of support this, right?

00:10:45.370 --> 00:10:51.620
The older implementation used custom JITs
and interpreter this to support this.

00:10:51.620 --> 00:10:59.610
The problem with custom JITs is every different architecture
you you have to have a different custom JIT for it.

00:10:59.610 --> 00:11:06.800
Well the problem with this is obvious, the higher
engineering and maintenance cost and furthermore

00:11:06.799 --> 00:11:11.729
as OpenGL evolves and you add new
features you required to have--

00:11:11.730 --> 00:11:15.090
put in more optimizations to support these new features.

00:11:15.090 --> 00:11:19.379
That's not that easy to do with a custom JIT framework.

00:11:19.379 --> 00:11:25.470
So one of the ways to deal with this
problem, we can fall back into an interpreter

00:11:25.470 --> 00:11:30.279
that supports all the features, runs on all the platforms.

00:11:30.279 --> 00:11:35.029
The problem with interpreter is it can
be over 100 times slower in some cases.

00:11:35.029 --> 00:11:39.750
So we have replaced OpenGL interpretation
with one that's based on LLVM.

00:11:39.750 --> 00:11:49.419
The great things with LLVM's code generator is it can target
a variety of different architectures and a single optimizer,

00:11:49.419 --> 00:11:56.549
single code JIT that supports everything and it's
because this general compilation framework is really,

00:11:56.549 --> 00:12:01.779
really easy to put in new optimizations,
support the new functions that's in OpenGL.

00:12:01.779 --> 00:12:11.990
So the result is a more rigid, a more flexible framework
OpenGL implementation and we have learned that turned

00:12:11.990 --> 00:12:15.419
out to be faster than the old implementation.

00:12:17.730 --> 00:12:20.690
The next example is OpenCL.

00:12:20.690 --> 00:12:24.740
OpenCL is this new technology in
Snow Leopard you heard a lot about.

00:12:24.740 --> 00:12:30.549
Well if you boil it down to is it's a new
way for you to write C programs to tap

00:12:30.549 --> 00:12:36.439
in the computation power not only on
your CPUs but on your GPU as well.

00:12:36.440 --> 00:12:39.580
This is a very powerful way of programming.

00:12:39.580 --> 00:12:44.300
Of course to support this you need a
number-- kind of interesting technologies.

00:12:44.299 --> 00:12:52.559
You need a C parser that's fast and a small memory
footprint that can embed into the OpenCL system.

00:12:52.559 --> 00:12:59.369
You also need a back end compiler that is capable
of targeting not only your CPUs or your GPU as well.

00:12:59.370 --> 00:13:07.750
Of course it's no surprise OpenCL is built on top
of the Clang front end and LLVM backend technology.

00:13:07.750 --> 00:13:11.049
And not only that, the whole point of OpenCL is speed.

00:13:11.049 --> 00:13:12.979
You want to run your program fast.

00:13:12.980 --> 00:13:17.519
So the compiler must produce great code
and must compile really, really fast.

00:13:17.519 --> 00:13:23.039
Well, in Snow Leopard we have replaced a
core image implementation from a custom JIT,

00:13:23.039 --> 00:13:31.159
a very well-tuned custom JIT implementation to one that's
built on top of OpenCL and the result is 25% speed up.

00:13:31.159 --> 00:13:40.049
That shows how powerful the OpenG-- how powerful
OpenCL is and how powerful the LLVM technology is.

00:13:40.049 --> 00:13:44.659
If you're interested in learning more
about OpenCL I encourage you to go

00:13:44.659 --> 00:13:47.579
to the Introduction to OpenCL talk on Thursday.

00:13:47.580 --> 00:13:53.670
So LLVM is a very exciting compilation technology.

00:13:53.669 --> 00:13:54.909
It's very powerful.

00:13:54.909 --> 00:14:02.730
For you developers you want to take advantage of
it by compiling your code with Clang or LLVM-GCC.

00:14:02.730 --> 00:14:07.360
For the next part of the talk we're
going to focus a little more on LLVM-GCC.

00:14:07.360 --> 00:14:11.730
Why is it the worth the upgrade from GCC?

00:14:11.730 --> 00:14:15.379
When we designed LLVM-GCC we have a number of goals in mind.

00:14:15.379 --> 00:14:18.250
We wanted it to be a drop-in replacement for GCC.

00:14:18.250 --> 00:14:24.029
If you're compiling your code with GCC
you should be able to you should be able

00:14:24.029 --> 00:14:27.759
to migrate your LLVM-GCC by selecting a different compiler.

00:14:27.759 --> 00:14:30.279
There's nothing else you need to do.

00:14:30.279 --> 00:14:37.639
So the first thing we want to support is 100%
source and binary compatibility with GCC.

00:14:37.639 --> 00:14:41.549
And of course there's a lot of GCC
features you've come to rely upon.

00:14:41.549 --> 00:14:49.109
LLVM support every-- LLVM-GCC support all
of the major features that GCC provides.

00:14:49.110 --> 00:14:55.980
And of course this is on top of LLVM so
you expect it you expect it to be fast,

00:14:55.980 --> 00:15:02.210
compile code fast and generate fast code.

00:15:02.210 --> 00:15:07.160
So last year at WWDC we introduced
LLVM-GCC as one of the compilers.

00:15:07.159 --> 00:15:10.329
We support-- it was a great release of LLVM-GCC.

00:15:10.330 --> 00:15:14.639
It supported a majority of the GCC
features but we left a few things out.

00:15:14.639 --> 00:15:20.789
But this year we added support for stack
canaries, obviously a new Blocks feature,

00:15:20.789 --> 00:15:24.079
OpenMP and we really improved debugging support.

00:15:24.080 --> 00:15:29.330
So this year we're very happy to say LLVM-GCC
now support all the major features of GCC.

00:15:29.330 --> 00:15:31.530
[Applause] Thank you.

00:15:36.490 --> 00:15:43.629
Next let's turn to the things that make
us compiler geeks really excited: Speed.

00:15:43.629 --> 00:15:45.580
So speed is 2 parts right?

00:15:45.580 --> 00:15:50.180
Compile times performance as well
as speed of the generator code.

00:15:50.179 --> 00:15:52.279
So we have a different philosophy here.

00:15:52.279 --> 00:15:59.529
Because LLVM is going to be part of the runtime system
it's build to be a JIT and part of the operating system.

00:15:59.529 --> 00:16:04.309
Compile-- compile time speed is very, very important to us.

00:16:04.309 --> 00:16:07.079
So we really worked very, very hard in this area.

00:16:07.080 --> 00:16:10.560
We want to compare LLVM-GCC against GCC.

00:16:10.559 --> 00:16:16.559
Well the example I'm going to show you is AppKit
which is a very, very large Objective-C framework

00:16:16.559 --> 00:16:20.659
and it's thousands of thousands of source files.

00:16:20.659 --> 00:16:26.600
We found, this is only one example but the results
are pretty representative of everything we have tried.

00:16:26.600 --> 00:16:30.409
Let's look at compile time.

00:16:30.409 --> 00:16:35.959
So we're going to look at both release mode and debug mode.

00:16:35.960 --> 00:16:39.840
In release mode the default compilation option is -os.

00:16:39.840 --> 00:16:45.540
That means compile-- optimize for
size but not at the expense of speed.

00:16:45.539 --> 00:16:49.870
This turns out most optimizations.

00:16:49.870 --> 00:16:51.110
In debug mode it's -o0-g.

00:16:51.110 --> 00:16:57.700
That turns out just about all of the optimizations
done and code generated really, really fast.

00:16:57.700 --> 00:17:03.930
So as you can expect, debug mode compiles
really, really fast compared to release mode.

00:17:03.929 --> 00:17:06.849
Let's see how LLVM-GCC does.

00:17:06.849 --> 00:17:15.029
Well in release mode LLVM-GCC is 1.5
times faster, 35% faster than GCC.

00:17:15.029 --> 00:17:15.849
What does that mean to you?

00:17:15.849 --> 00:17:21.159
Well I'm sorry to say we have shortened your
coffee break by roughly 8 1/2 minutes here but--

00:17:21.160 --> 00:17:24.540
for your productivity has just gone through the roof.

00:17:24.539 --> 00:17:29.539
And how about debugging-- how about debug bill

00:17:29.539 --> 00:17:37.049
Well last year when we released LLVM-GCC we
noticed LLVM-GCC is doing way too much work at -O0.

00:17:37.049 --> 00:17:40.259
We still try to optimize your code
even though you don't care about it.

00:17:40.259 --> 00:17:43.740
So it turns out LLVM-GCC was slower than GCC last year.

00:17:43.740 --> 00:17:45.849
Well this year we've put in a lot of work.

00:17:45.849 --> 00:17:49.219
We're caught up and surpassed GCC by a bit.

00:17:49.220 --> 00:17:53.079
So you might be wondering why is it only 5% difference.

00:17:53.079 --> 00:17:59.909
Notice with optimization turned off majority of
the compile time is in the front end; parsing time.

00:17:59.910 --> 00:18:05.370
Since we share the same front end technology
as GCC there's not a whole lot we can do here.

00:18:05.369 --> 00:18:09.369
Of course that's the excuse, but
we don't want to use that excuse.

00:18:09.369 --> 00:18:11.119
We want to do a lot better.

00:18:11.119 --> 00:18:15.779
We'll talk about that later in the talk.

00:18:15.779 --> 00:18:17.839
So LLVM compile your code faster.

00:18:17.839 --> 00:18:22.799
Does it compile code-- does it
make-- generate better code than GCC?

00:18:22.799 --> 00:18:28.759
We want to compare-- do the comparison
across a number of benchmarks

00:18:28.759 --> 00:18:33.180
and focus on Intel performance for 32-bit and 64-bit.

00:18:33.180 --> 00:18:35.500
Let's see how we do.

00:18:35.500 --> 00:18:41.720
You have seen a number-- a different set-- a lot
of numbers in the DT's State of the Union Talk.

00:18:41.720 --> 00:18:48.509
For this talk we're going to focus
on a smaller set of benchmarks.

00:18:48.509 --> 00:18:51.369
First let's take a look at OpenSSL.

00:18:51.369 --> 00:19:00.329
OpenSSL as you know is kind of open source cryptography
library that a lot of applications are dependent upon.

00:19:00.329 --> 00:19:05.250
The data points here are different
ciphers, different message digest systems.

00:19:05.250 --> 00:19:09.259
They all behave differently; have
different reaction to compiler changes.

00:19:09.259 --> 00:19:14.629
So the speed up here as you can
tell is across the board right.

00:19:14.630 --> 00:19:21.540
Some cases we do slightly better than GCC,
4%, 5%, but there are cases where we are

00:19:21.539 --> 00:19:26.369
over 20%, 30%, or over twice as fast than GCC.

00:19:26.369 --> 00:19:30.199
Think-- think about what that means to your application.

00:19:30.200 --> 00:19:33.990
That means a secure transfer goes much much quicker.

00:19:33.990 --> 00:19:38.279
[Applause] Thank you.

00:19:41.650 --> 00:19:50.320
[Applause] In 64-bit the diffedrence is not quite as
dramatic but again most of the cases we win-- LLVM-GCC wins.

00:19:50.319 --> 00:19:53.379
The difference could be small or could be over 20% faster.

00:19:53.380 --> 00:20:02.160
So at this point you may be wondering is there a
way I can tell LLVM-GCC to work really, really hard?

00:20:02.160 --> 00:20:05.960
You know just give me the best you
can do, forget about everything else.

00:20:05.960 --> 00:20:08.110
The answer is yes.

00:20:08.109 --> 00:20:12.119
Now LLVM-GCC provide you with a
Link Time Optimization feature.

00:20:12.119 --> 00:20:15.049
What does Link Time Optimization do?

00:20:15.049 --> 00:20:18.409
Why can it can squeeze more performance out of your program.

00:20:18.410 --> 00:20:25.100
Well Link Time Optimization is a way for
LLVM to optimize your code by looking--

00:20:25.099 --> 00:20:27.789
working across all the files at the same time.

00:20:27.789 --> 00:20:34.099
So traditionally when you compile you
compile one source file at a time.

00:20:34.099 --> 00:20:37.669
The best the compiler can do is look at all
the function in that single source file.

00:20:37.670 --> 00:20:43.950
With Link Time Optimization you
still compile one file at a time.

00:20:43.950 --> 00:20:49.059
For the linker at link time is going to take all
of the source code and it's going to call back

00:20:49.059 --> 00:20:52.019
to the LLVM optimizer and code generator.

00:20:52.019 --> 00:20:57.039
So it will work on your complete
set of source files at one time.

00:20:57.039 --> 00:21:01.809
It's going to do aggressive inter-procedure optimization.

00:21:01.809 --> 00:21:08.789
For example it can inline one function in one source
file into another function in a different source file.

00:21:08.789 --> 00:21:12.720
It can do all kinds of very aggressive optimization.

00:21:12.720 --> 00:21:13.480
What does that mean?

00:21:13.480 --> 00:21:18.930
It means it sometimes can squeeze out performance
that even the programmer may not be able

00:21:18.930 --> 00:21:22.700
to do because it can work on such a big scope.

00:21:24.170 --> 00:21:27.750
Well let's see how what LTO can do.

00:21:27.750 --> 00:21:29.240
Take a look at the OpenSSL example.

00:21:29.240 --> 00:21:34.089
Here we're looking at 2 data points.

00:21:34.089 --> 00:21:38.929
In one case LLVM-GCC already does
quite well, it's 20% faster.

00:21:38.930 --> 00:21:42.539
In another case it's behind GCC by 1%.

00:21:42.539 --> 00:21:47.920
With Link Time Optimization turned on the first
case got even faster; 5 additional percent.

00:21:47.920 --> 00:21:50.160
The second case got 10% faster.

00:21:50.160 --> 00:21:52.940
It turns a slight loss into win.

00:21:55.690 --> 00:21:57.330
Thank you.

00:21:59.029 --> 00:22:01.039
[Applause] Here's another case: JPEG decoding.

00:22:01.039 --> 00:22:03.970
JPEG is such a well known compression standard.

00:22:03.970 --> 00:22:08.390
The decoder has been worked on over the
years of being tuned and tuned and tuned.

00:22:08.390 --> 00:22:12.450
There's really not a lot of room for improvement.

00:22:12.450 --> 00:22:14.220
In fact LLVM-GCC doesOK.

00:22:14.220 --> 00:22:17.480
It can be 1% of performance benefit.

00:22:17.480 --> 00:22:18.490
Not interesting.

00:22:18.490 --> 00:22:23.900
With Link Time Optimization we're able to
squeeze out 7% additional improvements.

00:22:27.490 --> 00:22:29.849
Link Time optimizing is very powerful.

00:22:29.849 --> 00:22:32.629
It's also extremely easy to use.

00:22:32.630 --> 00:22:37.990
With our implementation of Link Time
Optimization all you have to do is go into Xcode,

00:22:37.990 --> 00:22:43.250
change the configuration compile
configuration and select Link Time Optimization.

00:22:43.250 --> 00:22:48.480
If your project's makefile-base--
makefile-based it's also really easy.

00:22:48.480 --> 00:22:53.610
Just add the -flto compile time option.

00:22:53.609 --> 00:23:02.069
Alternatively you can use -04 which
is equivalent to -03 and -flto.

00:23:05.930 --> 00:23:10.370
So we know LLVM-GCC is a great compiler.

00:23:10.369 --> 00:23:13.219
It's relatively young but it's also very mature.

00:23:13.220 --> 00:23:16.460
It's product, it's a production compiler.

00:23:16.460 --> 00:23:23.059
In the Snow Leopard you got, we already building
several bits of the Snow Leopard with LLVM-GCC.

00:23:23.059 --> 00:23:28.099
CoreData, of course OpenSSL, but also Java HotSpot.

00:23:28.099 --> 00:23:34.039
I'm pointing out Java HotSpot you know
because it's such huge cross-platform project.

00:23:34.039 --> 00:23:36.450
It's millions of lines of C++ code.

00:23:36.450 --> 00:23:40.029
Used every trick in the book to get performance.

00:23:40.029 --> 00:23:46.559
If LLVM-GCC can compile Java HotSpot it
can probably compile your C++ project.

00:23:46.559 --> 00:23:52.470
So to recap, how does LLVM-GCC compare to GCC 4.2?

00:23:52.470 --> 00:23:55.339
Well we got all the features that GCC provides.

00:23:55.339 --> 00:23:58.379
It will also give you Link Time Optimization.

00:23:58.380 --> 00:24:02.920
And LLVM-GCC generate better code than GCC.

00:24:02.920 --> 00:24:08.710
And LLVM is also significantly faster in
terms of compile time in release mode.

00:24:08.710 --> 00:24:12.329
In debug mode we are only slightly better.

00:24:12.329 --> 00:24:13.980
So we need to rethink the problem.

00:24:13.980 --> 00:24:20.380
We need a new front end technology, new parsing technology
that's a significant faster, that's where Clang comes in.

00:24:20.380 --> 00:24:24.010
I'd like to ask Chris to talk to you about Clang.

00:24:24.009 --> 00:24:29.920
[ Applause ]

00:24:29.920 --> 00:24:31.220
>> Chris Lattner: A new front end technology.

00:24:31.220 --> 00:24:32.460
Why would we do that?

00:24:32.460 --> 00:24:34.100
I mean C's has been around for years.

00:24:34.099 --> 00:24:36.839
How could possibly improve a C compiler right?

00:24:36.839 --> 00:24:40.199
Well it turns out there's like a few ways [laughter].

00:24:40.200 --> 00:24:42.610
So what is Clang?

00:24:42.609 --> 00:24:45.849
You've heard about this a few times already.

00:24:45.849 --> 00:24:49.079
It seems like we like to overload terms here so LLVM means

00:24:49.079 --> 00:24:51.809
about 4 different things depending
on what context you're asking.

00:24:51.809 --> 00:24:57.000
Clang also means several different things depending
on who's asking and what they're asking about.

00:24:57.000 --> 00:25:04.950
The first Clang is a set of libraries, a set of libraries
built just like LLVM is and so right now this implements a C

00:25:04.950 --> 00:25:10.090
and an a Objective-C front end and it follows the
normal LLVM design approach so we go for modularity,

00:25:10.089 --> 00:25:13.750
readability and this is what allows us
to build the static analyzer, right,

00:25:13.750 --> 00:25:16.279
which uses the front end but not the code generator LLVM.

00:25:16.279 --> 00:25:23.750
Clang is also a compiler so you can pick it out of Xcode and
use it to build your apps and this combines the strengths

00:25:23.750 --> 00:25:28.210
of the Clang front end with the power
of the LLVM backend and optimizer.

00:25:28.210 --> 00:25:30.880
Finally Clang is also an open source project.

00:25:30.880 --> 00:25:38.110
Clang has a much better webpage than LLVM does
[laughter] and you can find it on clang.llvm.org.

00:25:38.109 --> 00:25:39.969
So why do we care, right?

00:25:39.970 --> 00:25:44.400
Well, the great thing about being a compiler
person is that you know people make fun

00:25:44.400 --> 00:25:47.190
of you and-- oh wait, no, that's not the right thing.

00:25:47.190 --> 00:25:51.730
The great thing about being a compiler person is
that you can build tools that you use yourself.

00:25:51.730 --> 00:25:55.110
Right and this is the same for all the developer tools.

00:25:55.109 --> 00:25:59.679
Right we build tools because we're
programmers and we want programming to be fun.

00:25:59.680 --> 00:26:01.759
We want-- we do this all the time.

00:26:01.759 --> 00:26:02.440
Let's make it great.

00:26:02.440 --> 00:26:08.940
And so that's why we care about things like fast
compile times, fast generator code and great features.

00:26:08.940 --> 00:26:12.289
So Clang and LLVM going forward are
really where we're investing this.

00:26:12.289 --> 00:26:14.759
We think we can make things a lot better than they are now.

00:26:14.759 --> 00:26:18.150
We can push forward and there's a lot of work to be done.

00:26:18.150 --> 00:26:26.120
So I'm going to do the first ever compiler demo that I
know of just to give you an idea of what this feels like.

00:26:26.119 --> 00:26:29.639
So here I have a simple objective CF called Blast F.

00:26:29.640 --> 00:26:34.560
This is a developer example that we showed
before and you can download it from the webpage

00:26:34.559 --> 00:26:37.379
and like many applications this with builds with GCC.

00:26:37.380 --> 00:26:41.250
And so if we build this guy with
GCC you can see how this works.

00:26:41.250 --> 00:26:51.420
Just make sure it's all clean and we hit
Build and we can see 1, 2, 3, 4, 5, 6,

00:26:51.420 --> 00:26:54.080
you know, roughly 6 seconds to build this in.

00:26:54.079 --> 00:26:57.740
Well switching to either LLVM-GCC or Clang is really easy.

00:26:57.740 --> 00:27:03.450
You just go to either your target or your project
settings in Xcode and you say Edit Active Target

00:27:03.450 --> 00:27:07.910
and you get a nice list of different options
and you can search for compiler and then one

00:27:07.910 --> 00:27:10.420
of the options here is the compiler that we're using.

00:27:10.420 --> 00:27:12.420
Right and so here's GCC.

00:27:12.420 --> 00:27:15.060
And so if you pick this guy you can
pick a number of different options.

00:27:15.059 --> 00:27:19.019
You can pick Clang, you can pick
LLVM-GCC and they all work really well.

00:27:19.019 --> 00:27:25.049
One nice thing about picking Clang out of Xcode
is if you have a mixed project that has C++,

00:27:25.049 --> 00:27:30.819
Objective-C++ all mixed together in the same project
that the C and Objective-C pieces will build with Clang

00:27:30.819 --> 00:27:34.970
and the C++ and Objective-C++ pieces
will build with LLVM-GCC.

00:27:34.970 --> 00:27:37.500
So it's completely transparent.

00:27:37.500 --> 00:27:40.170
So now that we've picked that we're done.

00:27:40.170 --> 00:27:46.740
All we have to do is hit Build
and you see 1, 2, 3, whoa-- OK.

00:27:51.460 --> 00:27:58.490
Well [Applause] So so the reason I like to do this is not
because it is, you know, a specific percent faster than GCC.

00:27:58.490 --> 00:27:59.740
That's really not the point.

00:27:59.740 --> 00:28:04.900
I mean I'll show you numbers later but the
point is that Clang feels a lot faster.

00:28:04.900 --> 00:28:07.890
It's not just one of these theoretical
numbers that you throw up on a chart.

00:28:07.890 --> 00:28:14.040
Just doing development with Clang it-- it-- it's
a much nicer experience and I hope you agree.

00:28:14.039 --> 00:28:20.649
So if we come back to the slides and keep going.

00:28:20.650 --> 00:28:21.830
[Background sounds]

00:28:21.829 --> 00:28:25.269
>> Chris Lattner: So I gave you a
brief introduction of what Clang is.

00:28:25.269 --> 00:28:32.210
I want to talk about several different topics related
to Clang: compatibility, specifically GCC compatibility.

00:28:32.210 --> 00:28:35.769
This is the limiting factor of whether or
not it will actually work with your code.

00:28:35.769 --> 00:28:37.329
Talk about compile times.

00:28:37.329 --> 00:28:40.569
Give you some more, more detailed
numbers than you saw yesterday.

00:28:40.569 --> 00:28:42.159
Talk about some nice features that Clang has.

00:28:42.160 --> 00:28:46.259
I think that you'll like some of these
and then we'll wrap things up in the end.

00:28:46.259 --> 00:28:51.539
So the first thing that we want to talk
about when it comes to compatibility is C++.

00:28:51.539 --> 00:28:58.619
Well I know that many of you are thinking, oh, Clang only
supports C and Objective-C and I use C++ for everything

00:28:58.619 --> 00:29:01.629
or a big chunk of my stuff and therefore Clang's irrelevant.

00:29:01.630 --> 00:29:04.320
Well obviously C++ is a critical language for us.

00:29:04.319 --> 00:29:06.069
It's a critical language for Apple.

00:29:06.069 --> 00:29:10.849
It's a critical language for our developers and we're--
I'm happy to say that we're committed to implementing this.

00:29:10.849 --> 00:29:14.959
It's a ridiculously huge language
[applause] but we're gonna do it.

00:29:17.069 --> 00:29:22.109
Beyond just doing it we actually intend to do a
really good job because one interesting factoid is

00:29:22.109 --> 00:29:25.109
that Clang itself and LLVM itself is all written in C++.

00:29:25.109 --> 00:29:28.949
So we have-- we have some motivation to do this.

00:29:28.950 --> 00:29:36.380
I've also noticed that C++ has-- C++ compilers seem
to have some room for improvement too [laughter].

00:29:36.380 --> 00:29:40.230
Maybe we'll be able to do some good things there.

00:29:40.230 --> 00:29:44.870
So that said Clang currently has no C++ support
as we said before and so if you've tried

00:29:44.869 --> 00:29:51.839
to build an Xcode project using C++ we'll use LLVM
G++ for you and your program will build just fine

00:29:51.839 --> 00:29:55.099
and you just won't get the benefit of Clang on the C++ code.

00:29:55.099 --> 00:29:58.349
So I'm happy to say that not only
are we committed to doing it

00:29:58.349 --> 00:30:02.429
in some abstract theoretical way we've
actually been working like crazy on this.

00:30:02.430 --> 00:30:08.390
Right C++ is a big enough feature that you want to start
early because it takes time to do and not only are we

00:30:08.390 --> 00:30:15.210
to the point where we can do things like you know references
and you know bool and you know really exciting features

00:30:15.210 --> 00:30:21.400
like that we're to the point where last week we started
implementing things like partial template specialization

00:30:21.400 --> 00:30:26.710
and other features that are actually
you know real C++ things.

00:30:26.710 --> 00:30:30.900
The caveat being that C++ is a huge
language and there's still a lot to be done.

00:30:30.900 --> 00:30:34.720
So if you're interesting in learning more
we have a lot of details about C++ prog--

00:30:34.720 --> 00:30:39.279
C++ progress on the webpage and you
know patches welcome [laughter].

00:30:40.470 --> 00:30:47.400
So command line compatibility; so continuing in our theme
of compatibility, one of the the big things we wanted

00:30:47.400 --> 00:30:51.670
to make sure that you could do is take Clang
and drop it in and build your code with it.

00:30:51.670 --> 00:30:55.210
Right and so because of this we've worked
really hard to make Clang as compatible

00:30:55.210 --> 00:30:57.240
as possible with GCC even on the command line.

00:30:57.240 --> 00:31:03.269
And so this means that all of your favorite or most
hated command line options for GCC should work just fine.

00:31:03.269 --> 00:31:09.879
This means that if you have a makefile you can just
set CC = Clang and it's in the Developer/usr/bin folder

00:31:09.880 --> 00:31:14.250
in most installations and it should just build just fine.

00:31:14.250 --> 00:31:18.410
If you do this you don't get the auto fallback
to LLVM G++ and so you usually set CXX

00:31:18.410 --> 00:31:20.860
and your makefile will do the right thing.

00:31:20.859 --> 00:31:23.740
It should be really easy to use.

00:31:23.740 --> 00:31:26.630
The next thing is source compatibility.

00:31:26.630 --> 00:31:32.980
So who here loves it when you upgrade your compiler and then
it says, oh, you have an error that you didn't have before?

00:31:32.980 --> 00:31:35.089
Is that your favorite feature of compilers?

00:31:35.089 --> 00:31:35.689
>> Yeah.

00:31:35.690 --> 00:31:38.080
>> Chris Lattner: I'm not seeing a lot of hands here.

00:31:38.079 --> 00:31:41.750
Yeah, I've noticed that too and in fact any major--

00:31:41.750 --> 00:31:46.279
any difference between compilers
really prevents it from being adopted.

00:31:46.279 --> 00:31:49.059
Right because if you upgrade compilers
and say, oh, I have 10,000 errors.

00:31:49.059 --> 00:31:51.849
Is it really worth it, right?

00:31:51.849 --> 00:31:54.500
That's going to take a lot of time
to adapt, to change your code.

00:31:54.500 --> 00:31:59.769
Well I'm really happy to say that we put a ridiculous
amount of work in making Clang compatible with GCC.

00:31:59.769 --> 00:32:05.000
So not only do we support the C standard
we also support a bunch of GCC extensions.

00:32:05.000 --> 00:32:09.200
So things like inline assembly is
a obvious one that many people use.

00:32:09.200 --> 00:32:11.880
We support a broad range of GCC extensions.

00:32:11.880 --> 00:32:19.420
We also support a broad range of interesting quirks you
know that are dubious and then even some outright bugs

00:32:19.420 --> 00:32:25.259
that GCC has that that real code depends on
and we're committed to doing things right

00:32:25.259 --> 00:32:30.890
and so if we have you know a bug or a quirk here depending
on we'll have to put out a warning where GCC wouldn't--

00:32:30.890 --> 00:32:36.090
the nice thing about that is you can decide whether or not
you care about it and you can deal with it at your leisure.

00:32:36.089 --> 00:32:42.470
But this means that you can basically just pick up Clang,
use it and it and it should work which is very powerful.

00:32:42.470 --> 00:32:48.670
That said Clang still is a relatively new technology and
when Clang builds your code you should have confidence

00:32:48.670 --> 00:32:53.640
that it does work but if you use a feature that we
haven't implemented yet you'll get an error from Clang.

00:32:53.640 --> 00:32:58.180
And so if you use OpenMP for example Clang
doesn't support that yet so your program

00:32:58.180 --> 00:33:00.630
in the case of OpenMP just won't be parallel.

00:33:00.630 --> 00:33:06.910
If you use nested functions or the crazy underbar underbar
label thing or a couple of other really similar levels

00:33:06.910 --> 00:33:12.509
of obscure features to GCC Clang will output
an error and say hey I can't build this.

00:33:12.509 --> 00:33:19.890
For right now that means that you
have to build your code with LLVM-GCC.

00:33:19.890 --> 00:33:20.150
Sorry [laughter].

00:33:20.150 --> 00:33:26.110
That said we've run a ton of code through it and so
we're pretty confident that the major bases are covered.

00:33:26.109 --> 00:33:31.159
So Objective-C is very similar so we also want
to be extremely compatible with Objective-C.

00:33:31.160 --> 00:33:35.830
The only difference here is that there are a few
things we intentionally decided to remove from Clang

00:33:35.829 --> 00:33:42.369
and these are things that are either wildly incorrect
that we discovered in a new implementation of the language

00:33:42.369 --> 00:33:44.979
or some things that we're already deprecating in GCC.

00:33:44.980 --> 00:33:49.180
I'll give you an example of these and I
hope you agree they're pretty, pretty gross.

00:33:49.180 --> 00:33:54.259
So if you depend on these you're going to get
an error message out of Clang and it should say,

00:33:54.259 --> 00:33:57.710
this is this is invalid and we don't plan to add it

00:33:57.710 --> 00:34:02.350
and so if you use these you should fix
your code and there's 2 reasons to this.

00:34:02.349 --> 00:34:07.019
1: We're moving to Clang and so you need
to eventually get your code to build.

00:34:07.019 --> 00:34:10.409
A second big reason is that the stack
analyzer uses the same parser as Clang.

00:34:10.409 --> 00:34:14.379
Right, or it uses the Clang parser and
so it won't work on your code either,

00:34:14.380 --> 00:34:18.670
and so fortunately these are pretty weird things [laughter].

00:34:18.670 --> 00:34:26.050
Cast of Super is one example of that so Cast of
Super is one of the instances I've seen have occurred

00:34:26.050 --> 00:34:31.940
when people were passing around instance variables and
they change the call super instead and a cast remained.

00:34:31.940 --> 00:34:37.139
Well in Objective-C super sends a message to
you-- sends a message to your super class.

00:34:37.139 --> 00:34:42.009
Super is not supposed to be an expression, it's supposed
to be a magic token in there and so we fixed this

00:34:42.010 --> 00:34:45.750
and usually it's just a matter of
removing that cast from your code.

00:34:45.750 --> 00:34:47.789
Cast of L-Value is another interesting example.

00:34:47.789 --> 00:34:53.349
Cast of L-Value is a crazy GCC feature
that even they removed from their compiler

00:34:53.349 --> 00:34:57.259
but we had it accidentally enabled for
Objective-C and so some of these guys snuck

00:34:57.260 --> 00:35:00.910
into some Objective-C code base-- code bases.

00:35:00.909 --> 00:35:04.369
So this was up and a warning already with GCC.

00:35:04.369 --> 00:35:06.619
So hopefully you've already fixed this.

00:35:06.619 --> 00:35:10.049
Generally instead of assigning into a
cast you cast the thing that you want

00:35:10.050 --> 00:35:13.430
to assign and it's a much better way to go.

00:35:13.429 --> 00:35:19.710
The third one is really interesting, so
this is 64-bit specific and 64-bit we--

00:35:19.710 --> 00:35:24.349
64-bit Objective-C uses what's called the
non-fragile ABI and this allows at link time you

00:35:24.349 --> 00:35:27.549
to add instance variables to your classes.

00:35:27.550 --> 00:35:31.140
Well that means that the size of an
interface is only specified at runtime.

00:35:31.139 --> 00:35:36.199
It's not specified at compile time and GCC lets
you use sizeof, well what does sizeof give you?

00:35:36.199 --> 00:35:40.399
Well it gives you the size of the class
when GCC saw it and that's not the same size

00:35:40.400 --> 00:35:44.329
as when you run your app which is a pretty scary situation.

00:35:44.329 --> 00:35:45.360
The fix for this is real easy.

00:35:45.360 --> 00:35:47.970
You just change your code to call
the Objective-C runtime function,

00:35:47.969 --> 00:35:52.989
class_getInstanceSize, and that's all you have to do.

00:35:52.989 --> 00:35:57.000
So I hope you agree these are some
pretty weird and pretty quirky things.

00:35:57.000 --> 00:35:59.869
Most Objective-C code just builds just fine the first time.

00:35:59.869 --> 00:36:05.339
If you try Clang and you have any problems, you're
welcome to come to the lab tomorrow morning and a fleet

00:36:05.340 --> 00:36:09.230
of compiler engineers will be happy
to help you with the code [laughter].

00:36:09.230 --> 00:36:13.409
So the last thing I want to say
about compatibility is a gotcha.

00:36:13.409 --> 00:36:17.549
So the-- the trajectory of C has
followed a couple of different steps.

00:36:17.550 --> 00:36:20.769
You know before 1989 there was no standard in C,

00:36:20.769 --> 00:36:24.269
it was this weird soup of different
implementations and nobody's compilers agreed.

00:36:24.269 --> 00:36:31.050
In 1989 the language was standardized and the Anzio
and the ISO language standards and that gave us C89.

00:36:31.050 --> 00:36:34.470
10 years later they had a new language standard called C99.

00:36:34.469 --> 00:36:37.649
C99 adds a whole bunch of features to C.

00:36:37.650 --> 00:36:41.300
Well GCC is always defaulted to C89.

00:36:41.300 --> 00:36:46.180
And so now I'm happy to say that Clang is
going to leap into the feature and default

00:36:46.179 --> 00:36:49.869
to a language that is only 1 decade old, not 2.

00:36:51.010 --> 00:36:54.830
[ Laughter and applause ]

00:36:54.829 --> 00:36:59.179
>> Chris Lattner: So C99 is pretty
much a transparent extension to C89.

00:36:59.179 --> 00:37:02.029
There's only one minor thing and that's inline.

00:37:02.030 --> 00:37:07.700
So if you build your app with Clang and you specifically
say the compiler should use its default compiler

00:37:07.699 --> 00:37:14.669
and you get some link errors you may find out that those are
inline functions and so inline changed between C89 and C99.

00:37:14.670 --> 00:37:18.860
The easy solution for this is just to change inline
to static inline and it will work in both modes,

00:37:18.860 --> 00:37:22.430
it'll work with GCC, it works with
Clang and everything is good.

00:37:22.429 --> 00:37:27.449
The other fix for this is you can explicitly say,
hey, I want C89 and you can do that either in Xcode

00:37:27.449 --> 00:37:33.549
with the C language dialect setting or you can
say -scd=C89 or gnu 89 on the command line.

00:37:33.550 --> 00:37:34.410
It's really easy.

00:37:34.409 --> 00:37:39.609
And so if you don't tell Clang what
language to use for C it will pick C99.

00:37:39.610 --> 00:37:42.079
Should be pretty straightforward.

00:37:42.079 --> 00:37:46.469
Those are the only compatibility gotchas
that we really have to talk about.

00:37:46.469 --> 00:37:48.769
So we built it to be extremely compatible to GCC.

00:37:48.769 --> 00:37:51.429
You should just be able to drop it in and it just works.

00:37:51.429 --> 00:37:57.089
If you're using a feature that Clang doesn't support
it should tell you and if you're using something crazy

00:37:57.090 --> 00:38:01.579
that we intentionally removed it should
tell you that, and there's a C99 thing.

00:38:01.579 --> 00:38:04.309
So it should be really, really straight forward to adopt.

00:38:04.309 --> 00:38:05.679
So compile time speed.

00:38:05.679 --> 00:38:06.940
Most of-- this one's interesting.

00:38:06.940 --> 00:38:12.340
Yesterday Andreas told you that Clang
compiles code twice as fast as GCC.

00:38:12.340 --> 00:38:14.850
That's true but it's only part of the story.

00:38:14.849 --> 00:38:19.960
If you look at how much faster Clang is
than GCC it's a lot more interesting.

00:38:19.960 --> 00:38:22.190
So here we have a whole bunch of different applications.

00:38:22.190 --> 00:38:29.240
The ones on the left are a bunch of Apple applications
like Mail and Automator and Dashcode and even Xcode.

00:38:29.239 --> 00:38:34.569
These guys are a couple of open source applications
and these are some developer examples that we've shown.

00:38:34.570 --> 00:38:36.539
Just for a range of different source code.

00:38:36.539 --> 00:38:40.170
If you look at how much faster Clang is
and how much faster the Clang compiler is

00:38:40.170 --> 00:38:46.280
than the GCC compiler it's actually pretty fast.

00:38:46.280 --> 00:38:56.960
Right so [applause] I'll talk about why this is later but
you can see in almost all cases, results vary of course,

00:38:56.960 --> 00:39:00.760
but in almost all cases Clang is
almost 3 times as fast as GCC.

00:39:00.760 --> 00:39:06.910
That's a pretty big victory right there and well it's
not an accident of course, this is because we've fought

00:39:06.909 --> 00:39:12.149
and fought really hard to make it happen
but this is also in a debug configuration.

00:39:12.150 --> 00:39:16.220
So this is in the configuration where
you're almost completely front end bound.

00:39:16.219 --> 00:39:22.589
Right so this means your -O0 compiles which is where we
all do our development in should be a lot faster right.

00:39:22.590 --> 00:39:27.410
So if the compiler speed is only part of the
story and so the compiler being fast is good

00:39:27.409 --> 00:39:30.099
but when you do a build you do a lot of other things.

00:39:30.099 --> 00:39:32.199
You run the build system.

00:39:32.199 --> 00:39:37.099
You compile some NIB files, you copy files around,
maybe you have some custom build scripts and other stuff

00:39:37.099 --> 00:39:42.849
in your project and so if you look at total
build time there we see it's about twice as fast.

00:39:42.849 --> 00:39:47.940
And so Clang is about twice as fast when you include
all of the other stuff that we haven't sped up.

00:39:47.940 --> 00:39:53.260
And so this is what you see when you when you
do actually build from Xcode like I did before.

00:39:53.260 --> 00:39:56.070
So that's great because this is what you care about right.

00:39:56.070 --> 00:40:01.460
An interesting note here is that that there are
things that you can do that go wrong and so Dashcode,

00:40:01.460 --> 00:40:07.210
the interesting reason that it's a little bit slower
is it uses a custom build step that uses a Java app

00:40:07.210 --> 00:40:09.710
to do some compression or something like that.

00:40:09.710 --> 00:40:15.690
I'm not familiar with all of the details but if you do
custom build steps of course the compiler can't help you.

00:40:15.690 --> 00:40:20.860
So I think that's-- that's-- those are some amazing
results and the question is how do we do it?

00:40:20.860 --> 00:40:23.240
Well there's not one easy answer right.

00:40:23.239 --> 00:40:27.229
I mean it's not like we fixed one problem in
GCC and magically got it dramatically faster.

00:40:27.230 --> 00:40:33.030
If you boil it down there's you know thousands of
specific engineering decisions we made or that,

00:40:33.030 --> 00:40:37.260
specific design decisions we made to to to achieve this.

00:40:37.260 --> 00:40:39.820
You know we can wave our hands and say
it's better algorithms and less memory

00:40:39.820 --> 00:40:43.840
but I want to give you an example of of 2 things.

00:40:43.840 --> 00:40:47.130
One is this LLVM and Clang separation.

00:40:47.130 --> 00:40:54.369
So GCC when it was implemented you know 20, 25 years ago
was built as a C compiler you know for VAX or something.

00:40:54.369 --> 00:40:58.139
Where they brought up the code generator and
they brought the C front at the same time

00:40:58.139 --> 00:41:03.139
and because they did this they got
intertwined a little bit because it was easier.

00:41:03.139 --> 00:41:09.949
Well over time and over the next 20 years it got
even worse and so it's this big intertangled mess.

00:41:09.949 --> 00:41:16.699
Well the problem with that is that GCC spends a lot of
time and even more memory doing things that don't matter.

00:41:16.699 --> 00:41:22.689
So specifically if you look at like a structure
declaration, GCC saves space, memory for--

00:41:22.690 --> 00:41:26.530
in a structure declaration for
backend code generator stuff right.

00:41:26.530 --> 00:41:32.310
Well in our system we have huge headers with millions,
well not millions, thousands of structure declarations

00:41:32.309 --> 00:41:34.809
and enum constants and all this stuff right.

00:41:34.809 --> 00:41:40.400
Well any 1 .m file doesn't use most of those and so if
you spend memory on that you're just wasting it right

00:41:40.400 --> 00:41:43.190
because the code generator doesn't
code gen stuff you're not using.

00:41:43.190 --> 00:41:49.000
LLVM and Clang are very different I mean I think
you'll believe me that LLVM doesn't depend on Clang

00:41:49.000 --> 00:41:51.829
because we've been using it for a
long time before Clang even existed,

00:41:51.829 --> 00:41:55.579
that we've intentionally built Clang
to be separate from LLVM as well.

00:41:55.579 --> 00:41:59.719
This is to allow things like the static analyzer and
other things that don't use the code generator right?

00:41:59.719 --> 00:42:09.019
Well the good thing about this is that if we-- keeping
them separate and unentangled really helps us both

00:42:09.019 --> 00:42:11.190
in purity and reusability and all that stuff.

00:42:11.190 --> 00:42:15.639
But it also means that we spend time and
memory doing things that really matter.

00:42:15.639 --> 00:42:20.909
We only spend memory on stuff that-- for the code
generator actually goes through the code generator.

00:42:20.909 --> 00:42:25.489
This is not that novel of a concept but it's
actually a pretty big design decision in GCC

00:42:25.489 --> 00:42:29.669
that would be almost impossible to reverse,
right, and so this is an example of design

00:42:29.670 --> 00:42:33.559
and how it impacts performance and
memory and all that kind of stuff.

00:42:33.559 --> 00:42:36.230
Another thing I want to talk about is precompiled headers.

00:42:36.230 --> 00:42:42.940
Precompiled headers are what we use on the system to
handle the fact that you have 10 MB of headers coming

00:42:42.940 --> 00:42:46.760
into your 100 line.m file right and
so if you're not careful you spend all

00:42:46.760 --> 00:42:49.750
of your time parsing these header files, right

00:42:49.750 --> 00:42:56.429
So if we look at PCH we can look
at how GCC and how Clang does it.

00:42:56.429 --> 00:43:01.649
Well there's 2 scenarios, generation and use, and
you can see that here we're looking at memory use.

00:43:01.650 --> 00:43:08.059
GCC spends takes almost 125 MB to
generate a PCH file for say Cocoa.h

00:43:08.059 --> 00:43:10.500
but it only take 48 MB of memory when you use it.

00:43:10.500 --> 00:43:14.500
Well that's good because when you only generate
once and then you use it a lot of times right.

00:43:14.500 --> 00:43:18.750
Well we've finally optimized our PCH
implementation to be dramatically lazier.

00:43:18.750 --> 00:43:22.670
So instead of pulling in everything off the disk
we only pull in the declarations and the types

00:43:22.670 --> 00:43:25.059
that you are using as you compile a file.

00:43:25.059 --> 00:43:32.559
Because of this Clang uses substantially less memory
and when we generate the PCH file this is head

00:43:32.559 --> 00:43:37.369
to head engineering difference right because of things
like we talked about before and so you can see by just

00:43:37.369 --> 00:43:44.230
by engineering it differently or better it's twice as good.

00:43:44.230 --> 00:43:50.889
By-- but by being-- making it dramatically more
lazy we really got a 4X reduction of memory use.

00:43:50.889 --> 00:43:52.799
Well this can really impact your build right.

00:43:52.800 --> 00:43:58.289
If you have a laptop that doesn't have very much memory
it's quite possible you're going to be swapping with GCC.

00:43:58.289 --> 00:44:04.529
Well going from a scenario from when you're swapping
to not swapping is more than 2X speed difference right

00:44:04.530 --> 00:44:08.820
and this can be a huge, a huge
difference in your build performance.

00:44:08.820 --> 00:44:15.980
Well beyond just being faster or using less memory,
PCH files are also dramatically smaller right

00:44:15.980 --> 00:44:17.920
and so if you're using network builds or other things

00:44:17.920 --> 00:44:21.470
where you're shipping PCH files
around, this could be a huge impact.

00:44:21.469 --> 00:44:27.409
And so we've really put a lot of work into finally
optimizing specific pieces of Clang that are used

00:44:27.409 --> 00:44:29.519
and really important in our scenarios right.

00:44:29.519 --> 00:44:36.650
And the problem is that with GCC the GCC folks really care
about building Unix apps and Unix apps typically are C files

00:44:36.650 --> 00:44:40.389
with you know a 10,000-line header file right.

00:44:40.389 --> 00:44:45.400
That's not the way our system works and so we're not getting
a lot of support from the community to help improve GCC

00:44:45.400 --> 00:44:50.980
in this respect and you know at the end of the day
the design would be very difficult to fix anyways

00:44:50.980 --> 00:44:56.090
and so that's why Clang is-- that's why we can push Clang
forward and we can do the right things for our system

00:44:56.090 --> 00:45:00.070
and the results I think speak for themselves.

00:45:00.070 --> 00:45:01.010
[Cough] So--

00:45:01.010 --> 00:45:06.550
[ Applause ]

00:45:06.550 --> 00:45:10.789
>> Chris Lattner: So I've told you all about how
we want to be exactly like GCC but faster right?

00:45:10.789 --> 00:45:16.279
Well I have a hard time being limited
to doing exactly what GCC does

00:45:16.280 --> 00:45:19.310
because GCC really isn't that great at a lot of things.

00:45:19.309 --> 00:45:22.039
So can we do anything better than GCC?

00:45:22.039 --> 00:45:23.009
The answer is yes, right.

00:45:23.010 --> 00:45:26.690
So I won't talk about error and warning improvements.

00:45:26.690 --> 00:45:30.990
Andreas talked a little bit about this yesterday
but I want to give you some more examples right.

00:45:30.989 --> 00:45:34.500
Errors and warnings, what we call
diagnostics are really important.

00:45:34.500 --> 00:45:39.300
It's not some glitzy feature, but errors and
warnings are things we deal with all the time.

00:45:39.300 --> 00:45:44.680
If you can make me be 30% faster at getting to
the problem and fixing it then that's, you know,

00:45:44.679 --> 00:45:50.839
multiplied by 100,000 bugs that I introduced in my own
programs and that makes me a lot more productive, right?

00:45:50.840 --> 00:45:54.940
So we put a lot of time into this and
this is something that really matters.

00:45:54.940 --> 00:45:59.590
The problem of course is that GCC
is just really not great at this.

00:45:59.590 --> 00:46:00.960
Here's a typical example.

00:46:00.960 --> 00:46:05.360
So here I have some apparently
perfectly legal code and I compile this

00:46:05.360 --> 00:46:11.519
and I get this very insightful message from GCC, right.

00:46:11.519 --> 00:46:16.920
Yeah, so I've gotten to the point basically when I'm
using GCC I don't even read the messages anymore.

00:46:16.920 --> 00:46:21.180
I just find the line number; I go scrutinize the
line and try to figure out what I did wrong, right.

00:46:21.179 --> 00:46:22.179
That's how bad it is.

00:46:22.179 --> 00:46:26.230
Well, with Clang we want to push this much
further and we want to do a lot better

00:46:26.230 --> 00:46:29.320
and so of course, like I say, we are, right.

00:46:29.320 --> 00:46:34.380
So here's an example, same example and the difference
between what GCC tells you and what Clang does, right.

00:46:34.380 --> 00:46:37.430
Here Clang will tell you hey, I don't know what NSString is.

00:46:37.429 --> 00:46:40.710
Well obviously I forgot to include Cocoa.h right?

00:46:40.710 --> 00:46:46.710
Well that message doesn't tell me anything about what the
compiler is thinking and it is legitimately a hard problem

00:46:46.710 --> 00:46:50.590
and it takes a lot of work because the compiler
just knows something is wrong, it has to guess

00:46:50.590 --> 00:46:55.579
or infer what you did wrong and tell it to
be able to explain in a way you understand.

00:46:55.579 --> 00:46:59.049
But this is a problem that's worth solving
and so we've put a lot of effort into it.

00:46:59.050 --> 00:47:00.780
And this isn't just isn't for Xcode.

00:47:00.780 --> 00:47:05.380
If you run Clang with a command line you
can also see very nice looking output.

00:47:05.380 --> 00:47:10.590
In this case we actually print the error and the
line of code that it occurs on to the command line

00:47:10.590 --> 00:47:14.210
which is really nice when you're
doing command line development.

00:47:14.210 --> 00:47:20.260
Another example is range information, so here's here's
a great example from yesterday where we have 4 plusess

00:47:20.260 --> 00:47:23.540
on the line and GCC tells us something is invalid right.

00:47:23.539 --> 00:47:30.400
Well in Xcode it's beautiful, you get these awesome
highlights of the subexpressions for these kinds of things

00:47:30.400 --> 00:47:33.099
and it says, hey, this subexpression is the problem.

00:47:33.099 --> 00:47:37.789
This is really useful when you have things that
are like precedence issues and things like that.

00:47:37.789 --> 00:47:40.849
This is also really nice for saying,
hey, this is supposed to match that,

00:47:40.849 --> 00:47:43.710
and the compiler can highlight
those and say what's happening.

00:47:43.710 --> 00:47:45.420
The same thing also happens on the command line.

00:47:45.420 --> 00:47:51.050
We, we underline the various pieces and we only
print out one line so it's not quite as nice as Xcode

00:47:51.050 --> 00:47:58.640
but if you have errors that are standing thousands of
lines anyways then hopefully you can fix it without that.

00:47:58.639 --> 00:48:01.000
But these are just 2 examples right.

00:48:01.000 --> 00:48:04.329
I want to tell you a couple more cute things.

00:48:04.329 --> 00:48:05.840
Let's look at macros.

00:48:05.840 --> 00:48:10.090
So macros are really interesting because
often you don't know something is a macro.

00:48:10.090 --> 00:48:16.130
Here I'm just calling MAX right and I include the
definition of MAX just so you can see it but I didn't--

00:48:16.130 --> 00:48:19.019
I get some error message from the compiler
saying hey I have invalid operands, right,

00:48:19.019 --> 00:48:21.949
which is the generic message saying there's something wrong.

00:48:21.949 --> 00:48:24.250
I didn't write a greater than.

00:48:24.250 --> 00:48:29.309
I don't even know that's a macro and I'm getting something
from the compiler that doesn't make any sense to me right.

00:48:29.309 --> 00:48:35.980
Well with Clang it's really nice because the front end
has been designed to keep track of this information.

00:48:35.980 --> 00:48:40.650
Not only does Clang tell you that you have that error
it actually unwinds all of the macro instantiations

00:48:40.650 --> 00:48:45.000
that are involved in that and it tells you the
different levels and highlights and so here you can say

00:48:45.000 --> 00:48:48.130
that is the greater than, that's the
problem and here's where it came from.

00:48:48.130 --> 00:48:53.250
In Xcode in the build results window you can click on
the instantiated from line there and it will jump right

00:48:53.250 --> 00:48:54.960
to the macro definition so you can look at it.

00:48:54.960 --> 00:48:58.010
It's really powerful and really really nice.

00:48:58.010 --> 00:49:03.540
[ Applause ]

00:49:03.539 --> 00:49:05.519
>> Chris Lattner: But that's not all [laughter].

00:49:05.519 --> 00:49:10.179
So there's a lot of other things we've-- a
lot of other improvements we put into this.

00:49:10.179 --> 00:49:10.789
How about warnings?

00:49:10.789 --> 00:49:12.460
You get a warning out of your compiler.

00:49:12.460 --> 00:49:17.440
The compiler inevitably has some flag that controls
that warning but how do you figure out what it is?

00:49:17.440 --> 00:49:18.539
Well Clang tells you.

00:49:18.539 --> 00:49:23.380
It says hey here's a warning, if you don't want
this warning that's the flag that controls it.

00:49:23.380 --> 00:49:25.599
I'll talk more about controlling warnings later.

00:49:25.599 --> 00:49:27.000
It's a very simple thing right.

00:49:27.000 --> 00:49:31.969
If you design it in so that you
have a database of warnings, right.

00:49:31.969 --> 00:49:33.799
Well one more example.

00:49:33.800 --> 00:49:38.539
So this is a little picky but this is the
kind of thing that has always irritated us

00:49:38.539 --> 00:49:44.110
which is here I have forgotten a semicolon and
GCC tells me that it's on the curly brace line.

00:49:44.110 --> 00:49:46.289
Well that's not where you put a semicolon.

00:49:46.289 --> 00:49:47.360
What's it talking about right.

00:49:47.360 --> 00:49:52.329
I mean Clang will actually tell you you're supposed to
put it there if you click on this in Xcode or you click

00:49:52.329 --> 00:49:54.349
on the build results window it
will actually go to the right place

00:49:54.349 --> 00:49:58.110
so you can hit semicolon instead
of going to the wrong line right.

00:49:58.110 --> 00:50:03.210
I mean this is little details like this
but this kind of stuff adds up over time.

00:50:03.210 --> 00:50:08.110
And coming back to C++ a lot of the improvements we made
for Clang for diagnostics are important and useful in C

00:50:08.110 --> 00:50:12.110
but I think that C++ is where a lot of it will pay off.

00:50:12.110 --> 00:50:14.990
So C++ has things like type defs.

00:50:14.989 --> 00:50:20.059
Right, well Clang is very good at preserving type def
information and the idea being that if you get a error

00:50:20.059 --> 00:50:28.250
about SGG string you get an error about SGG string instead
of SGG basic string, you know, all that kind of stuff right.

00:50:28.250 --> 00:50:30.110
So we put a lot of effort into making this great.

00:50:30.110 --> 00:50:31.599
I think that-- I think that you will like it.

00:50:31.599 --> 00:50:32.900
You should play with it.

00:50:32.900 --> 00:50:34.639
Talking about warnings.

00:50:34.639 --> 00:50:38.339
Warnings are really interesting right because
there is a lot of ways that you can control them

00:50:38.340 --> 00:50:43.059
So you can control them with the
-Wfoo flag for the foo warning.

00:50:43.059 --> 00:50:45.779
You can also turn it off with Wno-foo.

00:50:45.780 --> 00:50:48.260
You can also turn it into an error with -Werror=foo.

00:50:48.260 --> 00:50:54.490
But one of the things that I've talked to and maybe I hang
out with some very pedantic people but a lot of people

00:50:54.489 --> 00:51:01.500
like building with Werror right and if you
build with Werror [applause] if you build

00:51:01.500 --> 00:51:03.550
with Werror you get one warning, you're dead.

00:51:03.550 --> 00:51:04.360
How do I get rid of it?

00:51:04.360 --> 00:51:06.570
Maybe I can't change my code right?

00:51:06.570 --> 00:51:10.010
Well I'm happy to say that you can
actually turn off specific warnings.

00:51:10.010 --> 00:51:15.440
You can even turn specific warnings back into
warnings in Werror mode and so if you build

00:51:15.440 --> 00:51:21.740
with Werror-Wno-error=foo this says I want all my
warnings to be errors except that one right there

00:51:21.739 --> 00:51:27.149
and you can either make it a warning or you can make
it just completely ignored and so this is really nice.

00:51:27.150 --> 00:51:29.570
This lets you do things.

00:51:29.570 --> 00:51:36.370
But there's a little bit more right because
this lets you control on a per-file basis.

00:51:36.369 --> 00:51:40.539
Wouldn't it be nice if you could actually
have a little bit more control over this?

00:51:40.539 --> 00:51:45.590
Well something that people have suggested
to us for years that's very difficult

00:51:45.590 --> 00:51:49.340
to pull off is controlling warnings within the file right.

00:51:49.340 --> 00:51:51.380
I have a specific warning I want to get rid of.

00:51:51.380 --> 00:51:53.019
Stop it now!

00:51:53.019 --> 00:51:56.000
[Laughter] Well with Clang you can
use a simple fragment to control this.

00:51:56.000 --> 00:51:59.809
You can say ignore this warning at this
point or turn into an error at this point.

00:51:59.809 --> 00:52:07.659
Right this is really great if you have something like Bison
producing C file and you know Bison injects all of this code

00:52:07.659 --> 00:52:11.259
that does all of these horrible
things and you know produces warnings.

00:52:11.260 --> 00:52:14.440
I love Bison, Bison is great.

00:52:14.440 --> 00:52:17.190
[Laughter] But I mean you can use
this for a lot of different things.

00:52:17.190 --> 00:52:21.429
Combine this with the fact that Clang tells
you what warning flags control various warnings

00:52:21.429 --> 00:52:24.769
and suddenly you have full control
over what's happening in your compiler.

00:52:24.769 --> 00:52:26.509
Amazing right.

00:52:26.510 --> 00:52:27.090
So--

00:52:27.090 --> 00:52:31.000
[ Applause ]

00:52:31.000 --> 00:52:35.010
So so we put a lot of effort into making this really
nice and really powerful and one other nice thing

00:52:35.010 --> 00:52:39.910
about using pragmas is that you can use this in your code
and GCC will just silently ignore them and so you don't have

00:52:39.909 --> 00:52:42.489
to do if defs or any other weird things, this is just--

00:52:42.489 --> 00:52:44.989
you can just use this in your code
and there's no problem with that.

00:52:44.989 --> 00:52:47.039
Let's talk about something else.

00:52:47.039 --> 00:52:52.840
So we explain that OpenCL uses
vectors or OpenCL uses Clang right.

00:52:52.840 --> 00:52:57.680
And OpenCL is all about performance and one thing
that is really important for performance is vectors.

00:52:57.679 --> 00:53:02.190
Well Clang has a lot of really nice vector
extensions that you can use directly in your code even

00:53:02.190 --> 00:53:05.630
if you're building applications, you're not using OpenCL.

00:53:05.630 --> 00:53:11.760
So here I show you the kind of gross
horrible syntax for defining a vector type.

00:53:11.760 --> 00:53:17.870
This-- with this definition I get a new flip
4 and this says I have a vector of 4 floats.

00:53:17.869 --> 00:53:20.489
With this I can now declare some vectors.

00:53:20.489 --> 00:53:22.879
Now GCC has a vector extension that is similar to this.

00:53:22.880 --> 00:53:24.530
They call it the generic vector extension.

00:53:24.530 --> 00:53:27.290
Clang also supports that extension.

00:53:27.289 --> 00:53:32.449
But while you can declare vectors and you
can do basic operations with the GCC vectors.

00:53:32.449 --> 00:53:35.519
You can do things like loading them,
storing them, multiplying them,

00:53:35.519 --> 00:53:37.730
element wise, adding them, stuff like that.

00:53:37.730 --> 00:53:39.659
There's no way to get to the elements of the vector.

00:53:39.659 --> 00:53:44.269
If you want to get element 4 you
have to make it a union with an array

00:53:44.269 --> 00:53:48.179
and then use the array to get the element of that vector.

00:53:48.179 --> 00:53:48.750
That's horrible.

00:53:48.750 --> 00:53:51.440
I mean the whole reason you're
doing this is for performance right?

00:53:51.440 --> 00:53:52.780
Now you're going to memory?

00:53:52.780 --> 00:53:53.590
Why are we doing this?

00:53:53.590 --> 00:53:54.590
I mean that's bad.

00:53:54.590 --> 00:53:58.850
Well Clang has a lot of really nice syntax for doing this.

00:53:58.849 --> 00:54:03.489
If you want to get to element 3 of
your vector you use subscript 3.

00:54:03.489 --> 00:54:04.859
This is where you guess.

00:54:04.860 --> 00:54:06.450
This is amazing technology.

00:54:06.449 --> 00:54:08.619
[ Applause ]

00:54:08.619 --> 00:54:14.909
It also has a number of nice things from OpenCL like
access to all of the even or the odd elements of a vector.

00:54:14.909 --> 00:54:18.049
If you're doing things with complex numbers for
example this is a really nice way to extract

00:54:18.050 --> 00:54:20.480
out all the real or the imaginary components.

00:54:20.480 --> 00:54:29.949
It also supports GLSL-style swizzling operations so you
can say v.xxxxx to get a splat of all of the X elements.

00:54:29.949 --> 00:54:34.359
We even have a built-in that you can use to do
a fully general permutation of any 2 vectors.

00:54:34.360 --> 00:54:40.760
In this case I'm taking one element out of the 1 and
3 elements out of V2 and doing my own custom mix right

00:54:40.760 --> 00:54:45.860
and because this uses the LLVM backend you can be
sure you're getting really good code out of that

00:54:45.860 --> 00:54:50.700
and this is how OpenCL works and it's--
it's a very powerful set of extensions.

00:54:50.699 --> 00:54:54.359
It lets you write really portable and really powerful code.

00:54:54.360 --> 00:54:56.670
So if you want to learn more about the syntax,

00:54:56.670 --> 00:55:00.450
the Introduction to OpenCL session can
tell you all about that-- all about this.

00:55:00.449 --> 00:55:02.489
I only have one slide on that.

00:55:02.489 --> 00:55:06.639
So the the question now is can I actually use Clang right?

00:55:06.639 --> 00:55:11.289
So I told you hopefully why Clang is
really cool, why you should want to use it.

00:55:11.289 --> 00:55:14.590
So now can you actually in fact use it?

00:55:14.590 --> 00:55:19.019
Well I'm happy to say that yes in fact
actually Clang does actually work.

00:55:19.019 --> 00:55:28.590
It might be hard to believe [applause] so we've been
working on Clang for a long time now, 2 1/2, 3 years,

00:55:28.590 --> 00:55:34.829
something like that and Clang, remember, is
building on the LLVM code generator and optimizer

00:55:34.829 --> 00:55:40.139
so it's using the exact same well tested optimization
code generation technology LLVM-GCC is using

00:55:40.139 --> 00:55:44.219
and as I told you before if it sees something it
doesn't understand it doesn't hope for the best

00:55:44.219 --> 00:55:46.539
and keep going and output code and it might work.

00:55:46.539 --> 00:55:49.820
It actually says no I do not understand this.

00:55:49.820 --> 00:55:51.210
Sorry, right?

00:55:51.210 --> 00:55:56.429
Well beyond design philosophies and principles
we've also done a huge amount of testing

00:55:56.429 --> 00:55:58.299
and Clang again is an open source project.

00:55:58.300 --> 00:56:02.420
We've had a huge input from open
source people building little apps.

00:56:02.420 --> 00:56:10.289
Little apps you know like the FreeBSD
kernel and FreeBSD userspace

00:56:10.289 --> 00:56:14.469
and at Apple we've done a huge
amount of testing on internal apps.

00:56:14.469 --> 00:56:17.949
I mean you saw the big list of apps up above.

00:56:17.949 --> 00:56:23.269
So we've done a huge amount of testing on this and you
know the FreeBSD kernel of course it not only builds,

00:56:23.269 --> 00:56:27.090
it actually does work and boot and
do all of that great stuff right.

00:56:27.090 --> 00:56:29.360
So this isn't a theoretical exercise.

00:56:29.360 --> 00:56:31.269
So Clang really does work.

00:56:31.269 --> 00:56:37.789
Beyond that of course we told you yesterday that Clang
is being used to build applications in Snow Leopard.

00:56:37.789 --> 00:56:42.960
So not only we-- you know doing tests and see if
they build we're actually building applications,

00:56:42.960 --> 00:56:45.880
mastering them on the DVD and shipping them to you.

00:56:45.880 --> 00:56:49.349
So when you run Automator or Interface Builder or Dashcode

00:56:49.349 --> 00:56:54.889
or Property List Editor you're actually
running Clang compiled code right.

00:56:54.889 --> 00:56:57.500
We're serious about this.

00:56:57.500 --> 00:57:00.199
Beyond that we're actually building Xcode.

00:57:00.199 --> 00:57:03.049
Well just so you have an idea of what Xcode entails right.

00:57:03.050 --> 00:57:05.080
Xcode is not a small app.

00:57:05.079 --> 00:57:10.059
Xcode is 2 apps with 18 frameworks and 20 plug-ins.

00:57:10.059 --> 00:57:15.000
The source space is built out of 17 Xcode projects
and it's over 2 1/2 million lines of code.

00:57:15.000 --> 00:57:17.380
This is a major real-world app.

00:57:17.380 --> 00:57:19.960
This is this is the real deal.

00:57:19.960 --> 00:57:27.599
Now full disclosure, about 5% of that is Objective-C++
and so this is exercising the ability of the Xcode,

00:57:27.599 --> 00:57:32.619
Xcode's ability to fall back to LLVM and C++ to build
that but that's still a heck of a lot of code right

00:57:32.619 --> 00:57:36.230
and Xcode works great and particularly in Snow Leopard.

00:57:36.230 --> 00:57:38.070
So this is a real compiler.

00:57:38.070 --> 00:57:47.070
[Applause] So for me one of the great
things about actually building applications

00:57:47.070 --> 00:57:52.890
and shipping them is not just you know the-- you
know-- chalk it up 1, yay, compiler you actually work,

00:57:52.889 --> 00:57:55.339
it's actually getting people to live on the compiler.

00:57:55.340 --> 00:57:59.930
Right so we've had these teams living on this
compiler and doing their daily development with it

00:57:59.929 --> 00:58:04.989
and it's really exciting to talk to these people
because they have very interesting quotes.

00:58:04.989 --> 00:58:08.659
Apparently not all of them have
been thrilled with GCC either.

00:58:08.659 --> 00:58:11.879
This is a great quote from Chris Espinoza.

00:58:11.880 --> 00:58:18.800
He says, "I've never seen a transition to a new compiler
go as smoothly as this," and Chris adds, "When I say never,

00:58:18.800 --> 00:58:29.230
it's somewhat authoritative," having started in the
garage you know 25 years ago, 30 years ago, sorry Chris.

00:58:29.230 --> 00:58:30.010
So--

00:58:30.010 --> 00:58:36.130
[applause]

00:58:36.130 --> 00:58:39.809
>> Chris Lattner: So it's-- it's been really
exciting to see people use it and and so far

00:58:39.809 --> 00:58:44.429
from what I can tell people seem to love it and
this is just the first of things to come I hope.

00:58:44.429 --> 00:58:47.629
We have a lot of-- a lot of ideas for the future.

00:58:47.630 --> 00:58:52.890
So to wrap things up I want to talk
briefly about the Static Analyzer right

00:58:52.889 --> 00:58:57.500
because compilers are boring right
we learned that yesterday [laughter].

00:58:57.500 --> 00:58:59.429
Let's talk about the new cool stuff.

00:58:59.429 --> 00:59:04.960
Well the the new cool stuff is the
integration of the Static Analyzer with Xcode

00:59:04.960 --> 00:59:11.119
and the Xcode team has done an amazing job of making this
accessible and really useful and so we you saw a couple

00:59:11.119 --> 00:59:17.059
of demos that show you how the data flow information
and the control flow information from Clang is rendered

00:59:17.059 --> 00:59:18.980
in Xcode in a way that's truly beautiful.

00:59:18.980 --> 00:59:21.789
It's really fun to use too if you haven't tried it yet.

00:59:21.789 --> 00:59:23.739
This works with both the Mac and the iPhone.

00:59:23.739 --> 00:59:27.659
It's easy to use often-- often-- stuff.

00:59:27.659 --> 00:59:35.309
If you want to learn more about this we have a session right
after this in North Beach and the session Ted Kremenek,

00:59:35.309 --> 00:59:41.219
the Chief Architect will tell you all about it and so
it's a great session, I highly encourage you to go there.

00:59:41.219 --> 00:59:45.399
So at this point you may be wondering, I've
learned about all these different compilers,

00:59:45.400 --> 00:59:48.019
well, which one should I actually use, right?

00:59:48.019 --> 00:59:50.670
Well, there's many different ones to choose from.

00:59:50.670 --> 00:59:52.550
So let's talk about their virtues.

00:59:52.550 --> 00:59:58.030
With Clang, building with Clang is a great option
if it works for you because you have fast compiles,

00:59:58.030 --> 01:00:04.280
you get great generated code using the LLVM optimizer
and backend and you get a great user experience.

01:00:04.280 --> 01:00:07.350
Use Clang!

01:00:07.349 --> 01:00:12.299
However if you're using a feature that Clang doesn't
support yet like method functions is one example,

01:00:12.300 --> 01:00:18.030
or you really care about OpenMP, then
LLVM-GCC is a really good answer.

01:00:18.030 --> 01:00:23.780
Now OpenMP-- the LLVM-GCC supports all the same features
that GCC does and it's not as fast as Clang when building

01:00:23.780 --> 01:00:26.750
in debug mode but it's really fast for optimized compiles

01:00:26.750 --> 01:00:30.849
and the LLVM optimizer is substantially
faster than the GCC optimizer.

01:00:30.849 --> 01:00:38.460
You get fast generated code and you get really good
compatibility with GCC, including C++ and Objective-C++.

01:00:38.460 --> 01:00:45.190
Now if you want the minimum possible delta from our
tools release last year, GCC 4.2 is a good answer.

01:00:45.190 --> 01:00:49.130
This is a stable compiler from last year
with a few bug fixes and the Blocks feature.

01:00:49.130 --> 01:00:52.690
So we haven't done anything crazy, this is for people
who are in the middle of their development cycle

01:00:52.690 --> 01:00:55.530
and aren't ready to switch up to a different compiler.

01:00:55.530 --> 01:01:01.250
Finally, if you're still using GCC 4.0, please stop.

01:01:01.250 --> 01:01:06.110
[Laughter] GCC 4.0 was a great compiler but
it's really-- it's really time to move forward.

01:01:06.110 --> 01:01:13.579
Both on the Mac and the iPhone GCC 4.2 is really
the compiler you should be using at the least.

01:01:13.579 --> 01:01:17.739
And so this is the compiler landscape
and I hope that you'll, you know,

01:01:17.739 --> 01:01:21.779
have some fun with your compilers and start expecting more.

01:01:21.780 --> 01:01:25.380
So if you're interested in learning more information
about compilers or you have questions feel free

01:01:25.380 --> 01:01:29.760
to contact Michael Jurewitz, he's
our Developer Tools Evangelist.
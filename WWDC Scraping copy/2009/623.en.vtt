WEBVTT

00:00:12.630 --> 00:00:18.460
>> Hello everybody and thank you.

00:00:18.460 --> 00:00:26.500
I'm David Kramer and welcome to the final session
of the Podcast Producer Track at WWDC 2009.

00:00:26.500 --> 00:00:28.620
I hope you all had fun last night at the Beer Bash.

00:00:28.620 --> 00:00:31.250
I'm glad you all made it here this morning.

00:00:31.250 --> 00:00:33.210
We've got a really cool session here today.

00:00:33.210 --> 00:00:40.980
Because I'm going to get to talk about the technologies
that empower Podcast Producer and so usually most

00:00:40.979 --> 00:00:46.089
of these session are about features and even
if it's about some new technologies, some API,

00:00:46.090 --> 00:00:48.100
they're talking about the features of the API.

00:00:48.100 --> 00:00:53.109
And with all the other sessions you've heard this week
about Podcast Producer, have shown you the new features

00:00:53.109 --> 00:00:57.030
of Composer, of Capture, of the server, of the library.

00:00:57.030 --> 00:01:01.310
What we're going to talk about here
today are the technologies that we used

00:01:01.310 --> 00:01:06.850
to create Podcast Producer and so
this is like, this is my passion.

00:01:06.849 --> 00:01:11.629
This is what I do for a living is working with
these technologies to create Podcast Producer.

00:01:11.629 --> 00:01:16.629
I don't actually use Podcast Producer in my day to
day life, but I do use these technologies every day

00:01:16.629 --> 00:01:20.969
and so I'm just really excited to
be here to tell you about them.

00:01:20.969 --> 00:01:27.159
So, it's me, David and so the description
for the session was

00:01:27.159 --> 00:01:32.549
that Podcast Producer leverages several
industry leading Snow Leopard technologies.

00:01:32.549 --> 00:01:36.179
Which to me sounds like someone from marketing wrote.

00:01:36.180 --> 00:01:40.040
So you know, how do I internalize
that to mean something to me?

00:01:40.040 --> 00:01:41.990
Well that Snow Leopard rocks.

00:01:41.989 --> 00:01:45.899
I mean you've seen Podcast Producer
hopefully this week, you've seen what it does.

00:01:45.900 --> 00:01:51.390
I mean, the fact that we can use Podcast
Producer to do all that is amazing.

00:01:51.390 --> 00:01:54.070
Snow Leopard enables that for Podcast Producer.

00:01:54.069 --> 00:02:01.099
The other side of that statement is that by understanding
Snow Leopard, you're going to understand Podcast Producer.

00:02:01.099 --> 00:02:06.469
So you know, some of the session is going to be about
development techniques, but some of it's also going to be

00:02:06.469 --> 00:02:12.060
about administration techniques, to show you by
understanding the technologies behind Podcast Producer,

00:02:12.060 --> 00:02:16.650
you can see how to you know, deal
with issues with Podcast Producer.

00:02:16.650 --> 00:02:22.750
So Podcast Producer uses a lot of technologies and I'm
not going to have time to talk about all of them today

00:02:22.750 --> 00:02:28.400
and even on this list, this is not complete at all.

00:02:28.400 --> 00:02:30.969
One that's notably missing here is GCD.

00:02:30.969 --> 00:02:36.229
I don't know if any of you had a chance to see
the Grand Central Dispatch talks this week.

00:02:36.229 --> 00:02:41.000
At Dave's view session, he talked about how
everyone at the company who's been starting

00:02:41.000 --> 00:02:46.469
to use it has all reported back how
much fun it is to use the API and I can,

00:02:46.469 --> 00:02:50.900
I will admit I'm one of those people
who thinks this API is incredibly fun.

00:02:50.900 --> 00:02:56.409
So I'm not going to talk about GCD today other than
just to tell you that it's really neat technology.

00:02:56.409 --> 00:02:59.659
I'm not sure that really the overview does it justice.

00:02:59.659 --> 00:03:06.770
Once you start using it and programming in it and really
getting your mind around the difference in programming style

00:03:06.770 --> 00:03:11.450
between what you're used to and GCD, it just
opens up a whole new set of possibilities for you.

00:03:11.449 --> 00:03:14.509
So that's just my little pitch for GCD.

00:03:14.509 --> 00:03:19.739
We're going to talk about just a few technologies today.

00:03:19.740 --> 00:03:26.270
On Podcast Capture side we're going to talk about
Core Animation and using QTKit to capture video.

00:03:26.270 --> 00:03:33.560
In the middle, in Podcast Producer Server, we're
going to take a look at Ruby on Rails and at Xgrid.

00:03:33.560 --> 00:03:40.789
And in the third section we're going to
look at Ruby Cocoa and Quartz Composer

00:03:40.789 --> 00:03:44.919
and we'll also take a look at QTKit in code.

00:03:46.229 --> 00:03:49.129
Podcast Producer is like a factory.

00:03:49.129 --> 00:03:55.000
So I'm sure Podcast Producer's been
described to a lot of you many time this week,

00:03:55.000 --> 00:03:58.419
I want to describe it a little bit differently.

00:03:58.419 --> 00:04:03.079
It's about a mass production factory and what's
going on here is that you get to define the sequence

00:04:03.080 --> 00:04:09.100
of operations once and then use purpose built
components to repeatedly apply the sequence of operations

00:04:09.099 --> 00:04:12.189
to each raw input to produce finished goods.

00:04:12.189 --> 00:04:16.850
And yes, I did have to go to Wikipedia
to figure all that out.

00:04:16.850 --> 00:04:19.379
It so that's the factory.

00:04:19.379 --> 00:04:26.759
So Podcast Producer Server is here in the center
and it's going to need some sequence of operations.

00:04:26.759 --> 00:04:34.389
So Podcast Producer, Podcast Composer comes along, let's
you create the workflow and install it in the factory.

00:04:34.389 --> 00:04:40.779
Podcast Capture is the provider of the raw inputs and
that's where those submitted input videos come from,

00:04:40.779 --> 00:04:44.639
either recorded from a camera or just submitted as a file.

00:04:44.639 --> 00:04:52.240
And finally, once the workflow munches on it for a while,
out comes the finished podcast, your finished goods

00:04:52.240 --> 00:04:57.110
and they get put to the library
or sent off to other locations.

00:04:57.110 --> 00:05:00.480
In a real factory you don't ever
really see what's going on inside.

00:05:00.480 --> 00:05:01.920
Especially like a contract factory.

00:05:01.920 --> 00:05:04.670
You're going to send your spec to
them and they'll make the stuff.

00:05:04.670 --> 00:05:06.600
They're probably going to figure out where to get the goods.

00:05:06.600 --> 00:05:08.680
Maybe you'll tell them where to get
the goods but they're actually going

00:05:08.680 --> 00:05:10.900
to receive them, they're going to put them together.

00:05:10.899 --> 00:05:15.099
The widgets, the machines, all the different, the
purpose built components, you're not going to see them.

00:05:15.100 --> 00:05:18.910
They're behind the factory doors and so
Podcast Producer is sort of like that.

00:05:18.910 --> 00:05:25.430
We're hiding a lot of complexity from
you but that's not always what you want.

00:05:25.430 --> 00:05:32.079
So I'm going to contrast mass production to craft work
and sort of the message that drives that home for me is I

00:05:32.079 --> 00:05:35.719
like homemade buns right, I assume most of you do to.

00:05:35.720 --> 00:05:41.680
They're better than store bought in almost 100%
of the cases because you can taste the love,

00:05:41.680 --> 00:05:44.660
you can taste the time and they're fresh.

00:05:44.660 --> 00:05:49.850
So in the same vein I think, crafted podcasts
might taste better than mass produced podcasts.

00:05:49.850 --> 00:05:55.710
If you take the time to really set up all of your intro
videos and your credits and your titles and you know,

00:05:55.709 --> 00:06:01.180
when a new person shows up you put a little badge over
it with their name and you have multiple camera angles

00:06:01.180 --> 00:06:06.459
and you switch between all of them, great that's going
to be a high production quality, it's really crafted.

00:06:06.459 --> 00:06:11.389
It's going to take a lot of time and your
customers are really going to like it.

00:06:11.389 --> 00:06:16.509
But that's a lot of work and so manufactured
podcasts are going to be a lot easier for you

00:06:16.509 --> 00:06:20.349
and that's why we made Podcast Producer, is to make it easy.

00:06:20.350 --> 00:06:25.670
But the point of this session is that maybe
Podcast Producer isn't always right for you.

00:06:25.670 --> 00:06:28.870
Maybe you do want to craft your
podcasts, but you'd like to use some

00:06:28.870 --> 00:06:32.230
of the same techniques that Podcast Producer is using.

00:06:32.230 --> 00:06:36.180
So we're going to show you some.

00:06:36.180 --> 00:06:40.930
The two things, main things you're going to learn today
are, how to leverage the same technologies that we're using

00:06:40.930 --> 00:06:45.819
in Podcast Producer and how to be more
effective when using Podcast Producer.

00:06:45.819 --> 00:06:48.560
It's not going to be as convenient
to leverage these technologies.

00:06:48.560 --> 00:06:51.819
You're going to have to write your own code
but it's going to be a lot more flexible.

00:06:51.819 --> 00:06:57.349
We've chosen a specific path for Podcast Producer, which
might not be the path that you guys want to go under.

00:06:57.350 --> 00:07:03.590
So the other side to being more effective is that I'm
going to show you some debugging techniques and also talk

00:07:03.589 --> 00:07:08.000
about some places where you can start customizing your
workflows beyond even what Kjell

00:07:08.000 --> 00:07:10.209
and Eric were showing you with Podcast Composer.

00:07:10.209 --> 00:07:15.569
Let's step back a second.

00:07:15.569 --> 00:07:21.389
There might be one or two people here who didn't go
to any other Podcast Producer sessions and so I want

00:07:21.389 --> 00:07:24.099
to just describe the system real quickly.

00:07:24.100 --> 00:07:27.379
You've got the capture side where using Podcast Capture,

00:07:27.379 --> 00:07:32.870
you can submit files from other
sources or use a camera to record data.

00:07:32.870 --> 00:07:36.800
It then gets sent up to the server
which processes it through a workflow

00:07:36.800 --> 00:07:43.689
and finally distributes the process information out to
the library where it can be consumed by your clients,

00:07:43.689 --> 00:07:48.660
your mobile devices, computers, what have you.

00:07:48.660 --> 00:07:53.220
And you've see a few demo's of Podcast
Producer this week probably and I'm going

00:07:53.220 --> 00:08:00.800
to show you my own version of the
demo using the command line.

00:08:00.800 --> 00:08:02.199
Because that's where I live.

00:08:02.199 --> 00:08:06.389
It turns out I can type faster than
I can use the mouse most of the time.

00:08:06.389 --> 00:08:09.569
So I like to just sit down here.

00:08:09.569 --> 00:08:15.449
And so we've got this wonderful podcast command line tool
and in it's simplest form, you can just ask it to connect

00:08:15.449 --> 00:08:22.129
to the local host computer using your current
credentials and get info from the server.

00:08:22.129 --> 00:08:26.969
So let me make this bigger for all of you.

00:08:26.970 --> 00:08:34.440
There's a lot of data here and it's all in XML and we don't
need to spend a lot of time seeing it but we have a list

00:08:34.440 --> 00:08:39.260
of cluster members, you can see what
authentication types are supported on this server,

00:08:39.259 --> 00:08:43.960
what it's kerberos service principle is,
a unique identifier and the version number.

00:08:43.960 --> 00:08:46.450
So if you ever need to inter-operate with Podcast Producer,

00:08:46.450 --> 00:08:49.120
this using the command line tool
you need to know what version it is.

00:08:49.120 --> 00:08:51.399
This is a great way to get that information.

00:08:51.399 --> 00:08:55.399
You might instead of listing the info, want
to see a list of the installed workflows.

00:08:55.399 --> 00:08:59.029
So in this case this is an authenticated
operation and so you're going to need

00:08:59.029 --> 00:09:04.980
to enter a password and you get a list of all the workflows.

00:09:04.980 --> 00:09:07.779
Again, you can see there is a lot of description here.

00:09:07.779 --> 00:09:09.610
Here's the montage workflow.

00:09:09.610 --> 00:09:13.019
Here's the dual source workflow.

00:09:13.019 --> 00:09:15.529
Every workflow has a unique identifier.

00:09:15.529 --> 00:09:20.789
It specifies the kinds of input
types it can take, who created it.

00:09:20.789 --> 00:09:24.099
There's a lot of information here and we
don't really need to look at it right now.

00:09:24.100 --> 00:09:26.940
It's also going to tell you who
has access to those workflow.

00:09:26.940 --> 00:09:30.510
As an Admin, I have access to all workflows right now.

00:09:30.509 --> 00:09:32.250
So that is listing the workflows.

00:09:32.250 --> 00:09:39.419
We can also list the cameras and I don't have any cameras
bound to this machine, so we get an empty array back.

00:09:39.419 --> 00:09:46.899
You'll notice this is all XML property lists coming
back from Podcast Producer and you can even do things

00:09:46.899 --> 00:09:52.149
like start recordings or bind cameras
or submit files from the command line.

00:09:52.149 --> 00:09:54.689
So let's take a look at the man page.

00:09:54.690 --> 00:09:56.360
This man page is really complete.

00:09:56.360 --> 00:10:02.740
We've put a lot of work into making sure all of the
options are documented with examples where appropriate.

00:10:02.740 --> 00:10:04.690
The server is optional.

00:10:04.690 --> 00:10:07.380
So is the username and password but you
can pass them all on the command line.

00:10:07.379 --> 00:10:10.110
You can also specify the authentication type.

00:10:10.110 --> 00:10:14.180
It's often more convenient to use Kerberos authentication.

00:10:14.179 --> 00:10:16.699
And then there's various commands.

00:10:16.700 --> 00:10:21.800
We saw list workflows, list cameras,
feeds, catalogs, servers, info.

00:10:21.799 --> 00:10:29.959
And then for the agent you can bind the camera, unbind the
camera, you can get it's config, set some preference values.

00:10:29.960 --> 00:10:34.090
For instance, the recording quality or the which device.

00:10:34.090 --> 00:10:36.850
So we've got a few, few things here.

00:10:36.850 --> 00:10:43.790
On you can then get status about the
camera, start, stop it and cancer recording.

00:10:43.789 --> 00:10:47.360
And then there's some details here
about doing a multi-source recording

00:10:47.360 --> 00:10:49.649
from the command line which is a little complicated.

00:10:49.649 --> 00:10:52.860
But I urge you to read the manage page
for information and then submit file

00:10:52.860 --> 00:10:55.300
and this is the one that I'm just using all the time.

00:10:55.299 --> 00:11:01.669
Because like I said, I can type faster than I click
and so rather than using Podcast Capture application

00:11:01.669 --> 00:11:05.019
to submit files when I want to test the
system or test changes that I've made,

00:11:05.019 --> 00:11:07.319
I just use the command like and it's very easy.

00:11:07.320 --> 00:11:12.860
You submit, you specify the file path, which workflow
you want to go to and you can even specify the title

00:11:12.860 --> 00:11:18.560
and description here, making it really easy to get
content into your system from a command line tool.

00:11:18.559 --> 00:11:23.250
And so I want to encourage you to think about
how you could integrate this command line tool

00:11:23.250 --> 00:11:32.350
into your own software, to inter-operate
with Podcast Producer.

00:11:32.350 --> 00:11:38.330
So let's see if I can show you Podcast Capture now.

00:11:38.330 --> 00:11:46.070
We were having a few hardware issues earlier
with this demo, but it may be working now.

00:11:49.970 --> 00:11:52.670
So all those things I showed you in the command line.

00:11:52.669 --> 00:11:57.110
You can see if you log in, if you where to get videos.

00:11:57.110 --> 00:11:59.450
We don't have any cameras so it won't let me do that.

00:11:59.450 --> 00:12:02.530
I could do a screen recording.

00:12:02.529 --> 00:12:12.740
Or if I do a file submission, this list of workflows is
the same list that came back from the command line tool

00:12:12.740 --> 00:12:18.350
and again this title and description are the same thing
that got passed on the command line for the submit tool.

00:12:18.350 --> 00:12:20.550
And this isn't just oh well, it's the same.

00:12:20.549 --> 00:12:22.289
It looks the same, it's the same name.

00:12:22.289 --> 00:12:26.949
What we're actually doing here is using
the command line tool from Podcast Capture.

00:12:26.950 --> 00:12:32.600
So all of the functionality in Podcast
Capture is in the Podcast command line tool.

00:12:32.600 --> 00:12:39.540
So the cheat here is that one of the technologies
behind Podcast Capture is the Podcast command line tool.

00:12:39.539 --> 00:12:46.329
We sort of designed our own technologies
to support ourselves.

00:12:46.330 --> 00:12:49.759
That is the Podcast Producer from
the prospective of the command line.

00:12:49.759 --> 00:12:55.100
I did want to show you a couple more things, but like
I said, we had a few hardware issues so I wasn't able

00:12:55.100 --> 00:12:59.690
to get a camera down to this machine and show you that.

00:12:59.690 --> 00:13:03.210
So you can clap if you want but I
didn't really show anything impressive.

00:13:03.210 --> 00:13:05.990
But that was the demo.

00:13:05.990 --> 00:13:08.470
[ applause ]

00:13:08.470 --> 00:13:10.950
[ no speaking ]

00:13:10.950 --> 00:13:15.680
Like I said, Podcast Capture harnesses
the command line functionality and puts it

00:13:15.679 --> 00:13:18.159
into a simple interface and that's really the key.

00:13:18.159 --> 00:13:21.000
Is that the interface has been made simple.

00:13:21.000 --> 00:13:26.500
Most people don't like using the command line, I know I'm
in a very, very small minority of people who prefer to work

00:13:26.500 --> 00:13:32.269
down there and so created Podcast Capture
to really be the face of Podcast Producer.

00:13:32.269 --> 00:13:38.029
And because it's the face we want it to be pretty
and we want to make a good impression on users.

00:13:38.029 --> 00:13:43.990
So my seaway here is that we are using
Podcast, we're using Core Animation to do a lot

00:13:43.990 --> 00:13:47.629
of really nice effects and make
the user interface look good.

00:13:47.629 --> 00:13:54.809
I was going to show you some of those in the demo
but I was unable to so instead, I'll bring Nathan up

00:13:54.809 --> 00:14:01.509
and he will show you Podcast Capture
as well as how to use Core Animation.

00:14:01.509 --> 00:14:05.210
So, Nathan, please.

00:14:07.600 --> 00:14:16.360
>> Hey so as Dave said, I'm a Cocoa developer on Podcast
Capture and Server Admin Podcast Producer type stuff.

00:14:16.360 --> 00:14:22.680
And so we wanted to show you a bit behind the scenes of
how Podcast Capture uses some Snow Leopard technologies.

00:14:22.679 --> 00:14:28.429
As Dave mentioned, Podcast Capture is just a GUI
wrapper around the Podcast command line tool.

00:14:28.429 --> 00:14:34.879
Everything that Podcast Capture does, it harnesses the power
of Unix to execute the Podcast tool, look at it's output

00:14:34.879 --> 00:14:39.870
and present an intuitive interface to the user

00:14:39.870 --> 00:14:45.129
And so you guys too can build your own custom interfaces
as you've done with the Leopard Podcast Producer

00:14:45.129 --> 00:14:47.679
and you can continue to do with
Snow Leopard Podcast Producer.

00:14:47.679 --> 00:14:53.259
So what I wanted to talk about today was a
little bit of Core Animation and QTKit capture.

00:14:53.259 --> 00:14:58.179
Those are two very cool technologies
that Podcast Capture uses.

00:14:58.179 --> 00:15:02.839
How many of you guys have used Core Animation here?

00:15:02.840 --> 00:15:04.509
All right, a handful.

00:15:04.509 --> 00:15:10.860
So Core Animation is a technology that's
for graphics and animation programming.

00:15:10.860 --> 00:15:17.669
It was new in Leopard and it's available in Leopard,
Snow Leopard and also as a central component of iPhone.

00:15:17.669 --> 00:15:23.500
And you can do the same kind of similar types
of animations across all three platforms.

00:15:23.500 --> 00:15:31.669
So some basic concepts is a layer is the
kind of building block of core animation.

00:15:31.669 --> 00:15:39.889
It's really similar to views in AppKit, although layers
also have 3D and 2D transformation that you can apply.

00:15:39.889 --> 00:15:42.750
Another really cool and powerful
thing, probably the most powerful thing

00:15:42.750 --> 00:15:45.950
about Core Animation is it's animation engine.

00:15:45.950 --> 00:15:50.600
Whenever you change a property on a layer, you get
automatically an implicit animation if you move it

00:15:50.600 --> 00:15:56.540
or you change the opacity or you change it's rotation,
you automatically get a quick, short animation.

00:15:56.539 --> 00:15:59.709
You can also do more complicated
animations called, explicit animations,

00:15:59.710 --> 00:16:03.430
where you set up a bunch of steps to do in a row.

00:16:03.429 --> 00:16:09.519
Another really powerful aspect of Core Animation,
which is much more powerful than the similar technology

00:16:09.519 --> 00:16:12.090
in Cocoa is the consummate of layout managers.

00:16:12.090 --> 00:16:20.710
In Cocoa, the way you set up how a view moves or resizes
as it superview changes, is called, stress and strings,

00:16:20.710 --> 00:16:27.389
and Core Animation is called Layout Manager lets you do
much, much more complicated and flexible, powerful layouts.

00:16:27.389 --> 00:16:33.470
Two things to note when you use Core Animation
on the Mac and on iPhone, is to use restraint.

00:16:33.470 --> 00:16:39.040
You don't want to have every single part of
your UI animating for three or four seconds.

00:16:39.039 --> 00:16:40.959
It just becomes annoying on the user.

00:16:40.960 --> 00:16:50.730
You want to make it meaningful, so where something slides in
to attract the attention of a user or fade out to make them

00:16:50.730 --> 00:16:53.289
where it's no longer there are the
types of places where you should use it.

00:16:53.289 --> 00:16:58.679
Basically, if you study the iPhone or how
the animation technology is in Mac are built,

00:16:58.679 --> 00:17:01.750
you should model your use of Core Animation off that.

00:17:01.750 --> 00:17:06.319
And you should refer to the Apple Human
Interface guidelines, they have a great section

00:17:06.319 --> 00:17:09.179
on animation, where it should and shouldn't be used.

00:17:09.180 --> 00:17:12.720
So what I want to show you today
is how we built the reflection

00:17:12.720 --> 00:17:17.039
in the dual source, the new feature of Podcast Capture.

00:17:17.039 --> 00:17:22.609
The reflection is also seen in
CoverFlow and iTunes and the Finder.

00:17:22.609 --> 00:17:26.969
And so the way we built it is like this.

00:17:26.970 --> 00:17:33.710
So we have our root layer which will be black and
then we have a content layer which is the image.

00:17:33.710 --> 00:17:39.210
We'll create another layer and flip it
upside down, called the reflection layer.

00:17:39.210 --> 00:17:43.299
Then finally we'll add a gradient
layer on top to make it look shiny.

00:17:43.299 --> 00:17:48.769
And then we'll put them altogether in a
container layer, so that we can do rotations.

00:17:48.769 --> 00:17:52.910
And so I want to show you a quick demo on that.

00:17:52.910 --> 00:18:01.000
So I have a sample up here where I haven't done any
code yet, I've just set up a NIB, which I'll show you.

00:18:01.000 --> 00:18:07.170
[ no speaking ]

00:18:07.170 --> 00:18:09.269
And it's building.

00:18:09.269 --> 00:18:14.779
So this is the window.

00:18:14.779 --> 00:18:18.440
In the main area we'll have the
black area and show the reflection.

00:18:18.440 --> 00:18:24.130
But you'll see we have three controls to turn
off and show certain aspects of the animation.

00:18:25.180 --> 00:18:31.890
So, let's get started.

00:18:31.890 --> 00:18:37.750
So first we're going to create some
instance variables and properties

00:18:37.750 --> 00:18:41.200
for the four layers that I showed you in that slide.

00:18:41.200 --> 00:18:49.259
So, we create instance variables,
properties and then we'll synthesize them.

00:18:49.259 --> 00:18:53.539
This is all the standard ObjectiveC 2 technology.

00:18:53.539 --> 00:18:57.460
Then in our, away from NIB, we'll set up the root layer.

00:18:57.460 --> 00:19:00.700
So we're going to set up the entire UI programatically.

00:19:00.700 --> 00:19:02.910
That's generally how it's done in Core Animation.

00:19:02.910 --> 00:19:08.250
So we'll have our black root layer,
then we'll create the content layer.

00:19:08.250 --> 00:19:09.920
This is the layer with the static image.

00:19:09.920 --> 00:19:13.670
So we'll just use the lotus image.

00:19:13.670 --> 00:19:19.590
Then we'll create another layer, the reflection layer
and as you can see we copy the bounds and the contents

00:19:19.589 --> 00:19:25.049
from the layer we just created above, but note we put
a transformation on it which flips it upside down.

00:19:25.049 --> 00:19:35.629
And then finally we'll create the gradient layer,
which as you can see, goes from 70% black to 0% black,

00:19:35.630 --> 00:19:42.480
this little passed the little, and actually the CA
gradient layer is new API in Snow Leopard and iPhone OS3.

00:19:42.480 --> 00:19:49.670
Then finally we'll set up the layout constraints so
that the content layers on top and the other one's

00:19:49.670 --> 00:19:53.720
on the bottom and we'll put them in a parent layer.

00:19:53.720 --> 00:19:58.690
And then we'll set up our three actions
that I mentioned for those three controls.

00:19:58.690 --> 00:20:01.390
So as you can see, these actions are really simple.

00:20:01.390 --> 00:20:05.890
Enable reflection layer, just change the opacity
from 1 to 0, same with the gradient layer

00:20:05.890 --> 00:20:12.780
and then changing the layer rotation is just one line of
code to apply rotation, getting the value from the finder.

00:20:12.779 --> 00:20:18.619
And this EnableSLOWMO is a macro for
setting the animation when you hold

00:20:18.619 --> 00:20:22.079
down the Shift key, like you have seen in parts of OS X.

00:20:22.079 --> 00:20:24.609
So now I'll build and run.

00:20:24.609 --> 00:20:28.479
And so here we go.

00:20:28.480 --> 00:20:32.980
So with just a little bit of code we've
set up our black layer with the image,

00:20:32.980 --> 00:20:36.470
if we check this box we'll see the one upside down.

00:20:36.470 --> 00:20:39.440
If you notice it had a really quick implicit animation.

00:20:39.440 --> 00:20:43.220
There was no code to do animation, that was
the implicit animation I mentioned before.

00:20:43.220 --> 00:20:47.259
If we hold down the Shift key, it does two seconds.

00:20:47.259 --> 00:20:49.400
And if we enable the gradient layer, here we go.

00:20:49.400 --> 00:20:52.940
That's the standard Apple colorful, shiny look.

00:20:52.940 --> 00:20:56.420
And with that one line of rotation code, we can rotate.

00:20:56.420 --> 00:21:02.710
If you notice, it can go from any point to any
point and it takes the same amount of time.

00:21:02.710 --> 00:21:06.029
If I hold down the Shift key, it will do it slow.

00:21:06.029 --> 00:21:11.430
And another cool aspect of Core Animation which is
pretty unique among animation frameworks is that,

00:21:11.430 --> 00:21:15.279
if you change the value mid-flight in the
animation, it automatically knows what to do.

00:21:15.279 --> 00:21:19.450
So I can go back and forth and it doesn't get all choppy.

00:21:19.450 --> 00:21:24.960
So that's pretty cool, but that's
not what Podcast Capture does.

00:21:24.960 --> 00:21:27.460
I'll show you what Podcast Capture does.

00:21:29.369 --> 00:21:34.669
So you guys have all see this before and Snow
Leopard we now have the Dual Mode and the Dual Mode

00:21:34.670 --> 00:21:39.039
as you can see, it has a Quick Time thing on the left.

00:21:39.039 --> 00:21:43.079
So you see I have Live Preview, it's a
little choppy because this is a Macbook Air,

00:21:43.079 --> 00:21:45.449
which as you know is not our fastest Mac.

00:21:45.450 --> 00:21:47.990
That you can see there's a reflection below me

00:21:47.990 --> 00:21:53.759
and there's also a reflection below the screen
capture preview and they all update live.

00:21:53.759 --> 00:21:56.369
You can also see that there's a slight rotation on it.

00:21:56.369 --> 00:21:58.549
So how do we build that?

00:21:58.549 --> 00:22:05.279
Well all we're going to do to get live video
feed, is to change that one content layer

00:22:05.279 --> 00:22:09.170
from an image to a Quick Time capture layer.

00:22:09.170 --> 00:22:14.550
So in order to do so, I'll use QTKit.

00:22:14.549 --> 00:22:20.789
And so QTKits is a framework that was new in Leopard
and it's been enhanced significantly in Snow Leopard

00:22:20.789 --> 00:22:29.139
with Quick Time 10 stack and it allows, it's a Cocoa API
to do audio and video recording and it's really simple.

00:22:29.140 --> 00:22:31.900
All you do is you add inputs and outputs.

00:22:31.900 --> 00:22:39.269
So we'll set up a QT capture session and
some outlets to start and stop recording.

00:22:39.269 --> 00:22:52.150
So we have a couple more instance variables,
properties and now I'll hook them up in the NIB file.

00:22:52.150 --> 00:22:57.440
And it's really a small amount of code to do this.

00:22:57.440 --> 00:23:03.900
If you guys ever used the Quick Time API's before
the Cocoa framework, it took hundreds of thousands

00:23:03.900 --> 00:23:06.230
of lines of code to do similar functionality.

00:23:06.230 --> 00:23:15.000
So I'll unhide these buttons and hook them up.

00:23:15.000 --> 00:23:23.710
[ no speaking ]

00:23:23.710 --> 00:23:28.029
And so all the start and stop recording
buttons are going to do is start

00:23:28.029 --> 00:23:33.930
and stop the movie recording which
will go to Quick Time movie file.

00:23:33.930 --> 00:23:42.759
So we'll hook it up to our record and stop actions.

00:23:42.759 --> 00:23:46.869
Then backing away from NIB, we'll
set up a QT Capture session.

00:23:46.869 --> 00:23:53.750
This is not much good at all to create the capture session,
find a default video device which is going to be the built

00:23:53.750 --> 00:23:58.319
in eyesight and add and movie file is the output.

00:23:58.319 --> 00:24:07.419
And then we'll change the content layer, which is before
we had that static image, we're going to comment that out

00:24:07.420 --> 00:24:11.100
and add a QT Capture layer and set it's
bounds to the size of the eyesight.

00:24:11.099 --> 00:24:15.409
And that's all you have to do to get live preview.

00:24:15.410 --> 00:24:22.600
And then finally, we'll add the
actions for starting and stopping.

00:24:22.599 --> 00:24:28.659
As you can see, starting is one line of code
and stopping is also another one line of code.

00:24:28.660 --> 00:24:30.529
We'll build and run.

00:24:34.039 --> 00:24:36.779
And we'll see that now we have live video feed.

00:24:36.779 --> 00:24:40.970
Notice that I didn't have to change the
reflection code at all, but it still works live.

00:24:40.970 --> 00:24:44.680
Which is really cool and I can rotate it as I speak.

00:24:44.680 --> 00:24:53.299
And we can start recording, rotate if
we want to, you know do all this live

00:24:53.299 --> 00:24:56.430
and then stop recording and we'll get our movie file.

00:24:56.430 --> 00:24:59.060
This is the same exact stuff that Podcast Capture does.

00:24:59.059 --> 00:25:04.629
It uses Core Animation and it uses QTKit
capture to do all this kind of stuff.

00:25:04.630 --> 00:25:13.060
And so really the point to drive home is that we've created
Podcast Capture as the ideal experience we saw would be

00:25:13.059 --> 00:25:18.089
for Podcast Producer, but as we've heard from
you guys, there's a lot of custom installations,

00:25:18.089 --> 00:25:22.629
custom deployments where people want to do a web
app or they want a more streamlined interface.

00:25:22.630 --> 00:25:26.050
And you can build the same on the
Mac or you can do it on the Web.

00:25:26.049 --> 00:25:28.000
And now I'll hand it back to Dave.

00:25:28.000 --> 00:25:32.930
[ applause ]

00:25:32.930 --> 00:25:34.440
>> Thank you very much Nathan.

00:25:34.440 --> 00:25:38.269
That stuff is really cool.

00:25:38.269 --> 00:25:46.660
So what we saw was Core Animation and I don't think we
mentioned it, but the little highlight also at the beginning

00:25:46.660 --> 00:25:52.670
of Podcast Capture, sort of when you hover your mouse over
one of those squares that doesn't quite look like a button,

00:25:52.670 --> 00:25:58.310
it puts a blue, a blue glow around the button
so that you realize that it's a clickable area.

00:25:58.309 --> 00:26:04.500
And the Dual Source Picker as you saw, is implemented using
Core Animation and we've just given away all of our secrets,

00:26:04.500 --> 00:26:07.849
so please go ahead and write your
own version of Podcast Capture

00:26:07.849 --> 00:26:12.599
that meets exactly your site's needs
and still looks just as great as ours.

00:26:12.599 --> 00:26:14.519
And you saw QTKits Capture.

00:26:14.519 --> 00:26:20.150
It's a really simple API, they've done a great job at
simplifying all of the details and making it really easy

00:26:20.150 --> 00:26:29.960
to just start capturing from a built in device to
a file right away, with very little code at all.

00:26:29.960 --> 00:26:34.110
We talked about Podcast Capture, now
let's what does Podcast Capture talk to?

00:26:34.109 --> 00:26:36.119
It talks to Podcast Producer Server.

00:26:36.119 --> 00:26:41.059
And the two aspects of Podcast Producer
Server that I would like to talk

00:26:41.059 --> 00:26:47.579
about today are the HTTP application
server side and the Xgrid client side

00:26:47.579 --> 00:26:52.000
and these both live inside Podcast Producer Server.

00:26:52.000 --> 00:26:57.160
[ no speaking ]

00:26:57.160 --> 00:27:03.370
The way Podcast Producer Server works is it's running
an HTTP application server so it accepts requests coming

00:27:03.369 --> 00:27:08.339
in on the network and Podcast Capture is one
of the clients that makes these web requests

00:27:08.339 --> 00:27:11.139
and actually it's the Podcast command
line tool that I showed you

00:27:11.140 --> 00:27:15.270
that is actually the process making these web requests.

00:27:15.269 --> 00:27:22.180
When a request comes in, for instance a submit file, what
ends up happening is that that server saved some data

00:27:22.180 --> 00:27:27.910
into the database and then the Xgrid client
aspect of Podcast Producer Server notices hey,

00:27:27.910 --> 00:27:31.390
there's some new video that needs
to be processed through a workflow.

00:27:31.390 --> 00:27:36.570
So it generates an Xgrid job and submits that off to Xgrid.

00:27:36.569 --> 00:27:42.819
Xgrid runs this work and the workflow as it's
running, will want to publish data back to the library

00:27:42.819 --> 00:27:47.559
and to notify the Podcast Producer Server
that the library is ready to be updated,

00:27:47.559 --> 00:27:51.990
it also makes a web request back
in to the application server.

00:27:51.990 --> 00:27:57.130
And finally the application server is also serving
up the Podcast Producer library, so when Safari

00:27:57.130 --> 00:28:02.940
or iTunes comes along and requests the content,
it's also hitting the exact same application server.

00:28:02.940 --> 00:28:10.370
The application server itself is built
on an open source web application stack.

00:28:10.369 --> 00:28:14.929
We start with Apache as our web server
and then we use mod_proxy_balancer,

00:28:14.930 --> 00:28:19.250
to distribute over single threaded
application servers running in the back end.

00:28:19.250 --> 00:28:25.710
Mongrel is our application container process
and it loads the Ruby on Rails environment.

00:28:25.710 --> 00:28:29.799
Podcast Producer Server is written
almost entirely in Ruby on Rails.

00:28:29.799 --> 00:28:38.519
And then finally, we're using the SQLite 3 database adapter
to save all of our data into a SQLite database on the disk.

00:28:38.519 --> 00:28:42.789
So the web request comes in and it hits Apache.

00:28:42.789 --> 00:28:48.409
Apache then hands it off to the mod_proxy_balancer
plug in, mod_proxy_balancer has been configured

00:28:48.410 --> 00:28:54.779
with multiple Mongrel instance addresses and depending
on which one is available, hands off a request.

00:28:54.779 --> 00:28:57.660
If one of the Mongrel's is busy,
it'll hand it off to another one.

00:28:57.660 --> 00:29:00.350
If one of them crashes, it'll move on to the next one.

00:29:00.349 --> 00:29:04.399
So we get a little bit of redundancy here and
it's all hidden behind the mod_proxy_balancer.

00:29:04.400 --> 00:29:08.240
So clients just see a single website.

00:29:08.240 --> 00:29:14.839
The Mongrel's are actually listening on a local port at a
local IP address, that is not advertised on the network.

00:29:14.839 --> 00:29:22.049
So people coming in remotely have to go through Apache and
so we can use Apache to do certain kinds of access control

00:29:22.049 --> 00:29:24.639
or logging, because it's our single funnel point.

00:29:24.640 --> 00:29:31.020
Finally, as the request comes through here, the Mongrel
immediately passes the request off to Ruby on Rails

00:29:31.019 --> 00:29:36.879
and which then executes our application codes and
ultimately most requests to our server end up talking

00:29:36.880 --> 00:29:40.890
to the database, if only to verify your cookie.

00:29:42.099 --> 00:29:48.179
The part of that stack that I want to talk about,
that's interesting to me, is Ruby on Rails.

00:29:48.180 --> 00:29:51.549
This has been included with Mac OS X since Leopard I think.

00:29:51.549 --> 00:29:52.879
It's still there in Snow Leopard.

00:29:52.880 --> 00:30:01.310
It's got an updated version and the sort of special sauce
with Mac OS X server is that we've added user interface,

00:30:01.309 --> 00:30:08.149
Server Admin, to make it easy to deploy a Ruby
on Rails application using exactly the same stack

00:30:08.150 --> 00:30:10.640
that I just described that Podcast Producer is using.

00:30:10.640 --> 00:30:15.770
So we haven't actually used Server Admin to deploy
Podcast Producer but all of the same techniques

00:30:15.769 --> 00:30:18.559
that we're using are being used in Server Admin.

00:30:18.559 --> 00:30:23.779
The details of how to set all of that up are in the
Server Admin Help, so you can just go to the Help menu.

00:30:23.779 --> 00:30:27.180
But you know, why read it when I can show it to you.

00:30:27.180 --> 00:30:31.000
So let's do a Ruby on Rails demo.

00:30:31.000 --> 00:30:42.529
[ no speaking ]

00:30:42.529 --> 00:30:47.099
All right so, let's say, yeah we got the web
server here and let's make a Rails directory

00:30:47.099 --> 00:30:50.769
and the we'll run the Rails command
to create a new application.

00:30:50.769 --> 00:30:59.230
So that creates the sort of Ruby on Rails basic structure
of an application and we can cd in there

00:30:59.230 --> 00:31:07.569
and if we run the server script right off the bat,
it tell us that it's listening on this local port

00:31:07.569 --> 00:31:13.200
and local IP address using Mongrel and
if we come in here and try to hit it,

00:31:13.200 --> 00:31:16.840
we actually get to our web server running on that port.

00:31:16.839 --> 00:31:22.549
And so this is a static web page that we served up, but
if we click this link it's going to make an AJAX request

00:31:22.549 --> 00:31:26.180
and we say hey, Rails is working and
we're in the development environment,

00:31:26.180 --> 00:31:31.660
we have the SQLite 3 database adapter
and we're running Ruby 1.8.7, super.

00:31:31.660 --> 00:31:36.580
But I'm pretty sure you don't want people to see
that page when they go to your Ruby on Rails site.

00:31:36.579 --> 00:31:38.889
We certainly didn't want that for Podcast Producer.

00:31:38.890 --> 00:31:45.790
So it's actually pretty simple to do stuff.

00:31:45.789 --> 00:31:54.289
My preferred environment for doing coding is Textmate
for Ruby on Rails and to get rid of that main page,

00:31:54.289 --> 00:31:59.289
that welcome page that we saw,
we're going to edit the route.

00:31:59.289 --> 00:32:02.399
And so there's a bunch of comments in
here sort of describing what you can do

00:32:02.400 --> 00:32:07.960
and the default routes match your URL to the
classes and methods that you had defined.

00:32:07.960 --> 00:32:16.090
So based on the URL it'll go to the object with the control
with that name, it'll go to the method with the action name

00:32:16.089 --> 00:32:19.789
and then it'll pass the final part of
the URL as a parameter to that method.

00:32:19.789 --> 00:32:25.019
That's sort of the default way Rails works,
but you can customize it however you want.

00:32:25.019 --> 00:32:28.029
What we're going to do is set up a welcome controller.

00:32:28.029 --> 00:32:31.349
So we're going to map the route of
our site to the welcome controller

00:32:31.349 --> 00:32:38.539
and Rails helpfully reminds us that
we need to remove this static file.

00:32:38.539 --> 00:32:46.809
So now I've set that up and I can start my server
running again and if I come back here I get an error

00:32:46.809 --> 00:32:51.519
because I haven't actually implemented the
controller yet and it spit out a huge Ruby exception.

00:32:51.519 --> 00:32:57.650
So no problem, what we're going to do is
run a script to generate a controller.

00:32:57.650 --> 00:33:02.130
So we're going to generate a controller called
Welcome with a single action called Index.

00:33:02.130 --> 00:33:07.790
Let's pop back to Textmate and
take a look at what it created.

00:33:07.789 --> 00:33:16.109
So it created for us a welcome controller with an index
action and more importantly it created a view and step back

00:33:16.109 --> 00:33:21.259
for a second Ruby on Rails is designed around a
version of the Model View Controller Paradigm,

00:33:21.259 --> 00:33:28.619
so you're going to have Model classes which map your
model to your database, you're going to have view classes

00:33:28.619 --> 00:33:33.589
which are actually HTML templates and then
you're going to have your controller classes

00:33:33.589 --> 00:33:42.099
which handle all the input parameters and massage them
into a format that's ready for templating into your HTML.

00:33:42.099 --> 00:33:50.559
So if we go here we see that it created an HTML file,
it's actually a template because it's a .erv file

00:33:50.559 --> 00:33:58.069
and so you can put Ruby code in here, it's very similar to
active server pages or JSP or even cold fusion like that

00:33:58.069 --> 00:34:01.879
where you can template in a little
bit of code within your HTML.

00:34:01.880 --> 00:34:09.400
So if we now just pop back and run the server after
running, after creating stunning design, all right,

00:34:09.400 --> 00:34:20.900
we run the server, we see that the page
that it created has been created for us

00:34:20.900 --> 00:34:23.910
as is now shows up when we go to the route.

00:34:23.909 --> 00:34:28.049
So we're almost there, I just want to show
you that we can make this a little dynamic.

00:34:28.050 --> 00:34:36.590
So I say well what time is it now, when I make the
request and so this, that's the little escape sequence

00:34:36.590 --> 00:34:40.809
to tell Rails hey, I want to execute some Ruby code in here.

00:34:40.809 --> 00:34:46.039
And so we're just going to say, take the
instance variable now and HTML escape it.

00:34:46.039 --> 00:34:48.630
How about that?

00:34:48.630 --> 00:34:51.250
And so well, where does this instance variable come from?

00:34:51.250 --> 00:34:57.329
All views in Rails inherit, sort of have access to
the instance variables for their controller class.

00:34:57.329 --> 00:35:05.049
So over here, ever time an index request comes in, I can
just say, let's say the now variable to be the current time.

00:35:05.050 --> 00:35:09.410
And if I just refresh this, I don't even need to
restart the server because we're running in development,

00:35:09.409 --> 00:35:14.449
Rails will reload all the classes
every time, I get the time.

00:35:14.449 --> 00:35:17.719
And if I refresh, I get four seconds later.

00:35:17.719 --> 00:35:20.309
So that's a simple little Rails demo.

00:35:20.309 --> 00:35:22.409
But not really what I wanted to show you.

00:35:22.409 --> 00:35:24.889
What I wanted to show you was the Server Admin integration.

00:35:24.889 --> 00:35:28.000
So let's take a look at how that looks.

00:35:28.000 --> 00:35:33.760
[ no speaking ]

00:35:33.760 --> 00:35:34.970
Great, all right.

00:35:34.969 --> 00:35:41.789
So we don't have Web set up yet, so let's enable that.

00:35:41.789 --> 00:35:49.670
And the way this is going to work is we're
going to take our default site and I'm going

00:35:49.670 --> 00:35:53.440
to turn off the other web services just
because we don't need them for this demo.

00:35:53.440 --> 00:35:57.840
And we're going to use this proxy panel to set up the proxy.

00:35:57.840 --> 00:36:04.230
So actually before I do this, I need to set up my
servers to be running Mongrel instances persistently

00:36:04.230 --> 00:36:10.360
so that whenever Apache is running, it has access, the
mod_proxy_balancer has access to these Mongrel instances.

00:36:10.360 --> 00:36:17.000
So normally how you would do that on another
system is you might use Mongrel Rails

00:36:17.000 --> 00:36:20.349
and let's see if we can get some help on this.

00:36:20.349 --> 00:36:22.099
It's a pretty simple tool.

00:36:22.099 --> 00:36:26.569
Let' see what's up.

00:36:26.570 --> 00:36:29.140
Yes, so start, stop, restart.

00:36:29.139 --> 00:36:37.679
What we've done with Mac OS X server is create a tool called
Mongrel Rails Persist that creates a launch DP list for you

00:36:37.679 --> 00:36:40.919
that contains the correct commands to use Mongrel Rails.

00:36:40.920 --> 00:36:45.210
So that if your server crashes
or if you restart your server,

00:36:45.210 --> 00:36:49.260
the Mongrels are going to come back
immediately and always be accessible.

00:36:49.260 --> 00:36:58.840
So the command to deploy is going to be
Mongrel Rails Persist and we're going to go

00:36:58.840 --> 00:37:05.440
in the production environment instead of the development
environment in this case and we're going to use port 3000

00:37:05.440 --> 00:37:16.090
for the first instance and we're going to
start this and we're going to do a hazard.

00:37:16.090 --> 00:37:19.970
All right, so that created one instance and I want to
create another instance too because the point of view is

00:37:19.969 --> 00:37:25.929
in this balancer to cluster and have
both fault tolerance and load balancing.

00:37:25.929 --> 00:37:32.759
So now I have two instances running
on port 3000 and port 3001

00:37:32.760 --> 00:37:36.270
So come on over to Server Admin.

00:37:36.269 --> 00:37:42.159
I enabled reverse proxy and then I'm going to add
some workers here and we've actually done something

00:37:42.159 --> 00:37:44.159
to make it really easy to add the workers.

00:37:44.159 --> 00:37:48.420
It's doing a Bonjour registration
up from Mongrel Rails Persist.

00:37:48.420 --> 00:37:53.000
So I can just pick the ones that
are already here, very easy.

00:37:53.000 --> 00:37:58.469
[ no speaking ]

00:37:58.469 --> 00:38:03.929
All right, now let's see if that all worked.

00:38:03.929 --> 00:38:13.539
So whereas before we aren't going to the site at 0.0.0 Quam
[assumed spelling] 3000, now if I 0just go to local host,

00:38:13.539 --> 00:38:18.440
to the default port of the web which is
port 80, I come back and I got my Rails app.

00:38:18.440 --> 00:38:22.300
And so that's how easy it is to
deploy a Rails app using Server Admin

00:38:22.300 --> 00:38:25.990
and that's almost how we did with Podcast Producer.

00:38:25.989 --> 00:38:30.189
Finally, what do I want to tell you about.

00:38:30.190 --> 00:38:39.000
So that was pretty cool and the one last thing to show
you is how Podcast Producer is using Ruby on Rails.

00:38:39.000 --> 00:38:49.119
[ no speaking ]

00:38:49.119 --> 00:38:51.989
So you may have seen the web application that we showed off.

00:38:51.989 --> 00:38:54.759
It looks almost identical to the desktop application.

00:38:54.760 --> 00:38:59.190
This is an HTML web app, written in Ruby on Rails.

00:38:59.190 --> 00:39:06.179
So it's and because it's written in Ruby on Rails,
the source code is there, you can peak into it.

00:39:06.179 --> 00:39:12.759
I don't recommend you read too far into it or make too
many changes and expect them to continue working over time,

00:39:12.760 --> 00:39:17.890
but definitely if you want to be inspired about how
to use Ruby on Rails and how to do things similar

00:39:17.889 --> 00:39:24.250
to what we've done and especially some of these CSS effects
are pretty impressive considering we don't have Core

00:39:24.250 --> 00:39:28.750
Animation in the browser, it's still pretty nice.

00:39:28.750 --> 00:39:35.159
So you can do a lot with Ruby on Rails on
MacOS X server to make a very rich application.

00:39:35.159 --> 00:39:40.379
So I encourage you all to look more into
Ruby on Rails for your own personal use.

00:39:40.380 --> 00:39:42.090
Thank you.

00:39:44.000 --> 00:39:51.539
[ applause ]

00:39:51.539 --> 00:39:58.679
The other side of things, after Ruby on Rails has accepted
these requests and in the case of a job submission

00:39:58.679 --> 00:40:05.199
or a file submission, it's going to them
create an extra job and send it off to Xgrid.

00:40:05.199 --> 00:40:06.859
What is Xgrid?

00:40:06.860 --> 00:40:09.170
If any of you have been coming to WWDC for a few years,

00:40:09.170 --> 00:40:12.430
you'll know that I've given sessions
about Xgrid in the past.

00:40:12.429 --> 00:40:16.549
We haven't had any here recently because
we've been focusing on Podcast Producer

00:40:16.550 --> 00:40:18.500
and the information hasn't changed a lot.

00:40:18.500 --> 00:40:22.530
But let me just give a quick refresher for
people who aren't aware of what Xgrid is.

00:40:22.530 --> 00:40:25.320
It's a general purpose distribute computing system.

00:40:25.320 --> 00:40:29.380
In some ways it's about parallel computing but not exactly.

00:40:29.380 --> 00:40:33.160
It's more about doing computing
somewhere else and if you have a lot

00:40:33.159 --> 00:40:36.420
of somewhere else's, then you'll be doing it in parallel.

00:40:36.420 --> 00:40:42.470
But in it's basic form, it's really just about moving
the data processing that you want done, somewhere else,

00:40:42.469 --> 00:40:48.789
so that your client can be turned
off, can go to sleep or whatever.

00:40:48.789 --> 00:40:51.090
And so there's a three tier architecture here.

00:40:51.090 --> 00:40:53.500
We've got the clients who have
the work that need to be done.

00:40:53.500 --> 00:40:55.190
They submit jobs to the controller.

00:40:55.190 --> 00:41:02.400
The controller breaks these jobs up into tasks and a
task in Xgrid is just a command line utility invocation.

00:41:02.400 --> 00:41:07.470
So it's just what I've been doing in
terminal, a command, some argument, hit Return.

00:41:07.469 --> 00:41:10.239
That's basically what Xgrid's going
to run for you out on the grid.

00:41:10.239 --> 00:41:17.399
So anything, any computing project that you have that could
be expressed as a command line tool that takes some inputs,

00:41:17.400 --> 00:41:21.079
you can adapt to use with Xgrid pretty easily.

00:41:21.079 --> 00:41:26.719
Once the controller has split these jobs up into tasks,
it distributes the tasks out to the available agents,

00:41:26.719 --> 00:41:34.919
in this case it's a rack of exerts and the job, the task run
out there and when they're done they send their results back

00:41:34.920 --> 00:41:37.280
to the controller, the controller notifies the client

00:41:37.280 --> 00:41:40.540
that the data is available and the
client can retrieve the output.

00:41:40.539 --> 00:41:46.909
If the agents go offline, the controller detects
this and it reschedules the work somewhere else.

00:41:46.909 --> 00:41:55.750
So we're using this in Podcast Producer to give us a
sort of a reliability, because we can just send the jobs

00:41:55.750 --> 00:42:00.300
out to Xgrid and then we don't need to worry about
who's going to do it or when it's going to get done.

00:42:00.300 --> 00:42:06.200
We know that Xgrid controller is going to make sure
that it will get done eventually, as soon as possible.

00:42:06.199 --> 00:42:13.449
And the Podcast Producer workflows that Podcast
Composer makes or that you can make your own self,

00:42:13.449 --> 00:42:20.019
the .pwf bundle format, actually
contain a file called template.plist

00:42:20.019 --> 00:42:25.250
which is an Xgrid job specification template
that contains substitution variables.

00:42:25.250 --> 00:42:30.469
So if you understand how to set up an
Xgrid job, you're about 80% of the way

00:42:30.469 --> 00:42:32.759
to setting up a Podcast Producer workflow.

00:42:32.760 --> 00:42:39.490
Because all you need to do is add in the substitution
variables that you want to have vary depending on the input.

00:42:39.489 --> 00:42:45.709
So substitutions can include the title or
how long the recording is or the description.

00:42:45.710 --> 00:42:52.059
Rather than talk more about Xgrid,
let's just take a look at how it works.

00:42:52.059 --> 00:42:58.900
And again, we're going to take a look at the command
line, because that is my preferred, preferred environment.

00:42:58.900 --> 00:43:10.760
All right, so let's, so the actually command line
tool, it's got some options, there's a Man page, great.

00:43:10.760 --> 00:43:12.710
OK. How do you use it?

00:43:12.710 --> 00:43:16.590
You specify your host name, which
is really long on this computer

00:43:16.590 --> 00:43:20.710
for some reason and you give it an authentication type.

00:43:20.710 --> 00:43:24.210
I like using Keberos because then I
don't have to keep typing my password.

00:43:24.210 --> 00:43:28.610
And at the simplest level you can
just say hey, what jobs do I have?

00:43:28.610 --> 00:43:29.880
Well we don't have any jobs.

00:43:29.880 --> 00:43:36.960
So another simple thing you can do with Xgrid on the
command line is just run a command and so if I were

00:43:36.960 --> 00:43:42.429
to just run the cal command here, it
prints out the current month calendar.

00:43:42.429 --> 00:43:49.739
Great. So if I just prefix that whole bit here
now with Xgrid, just like with job or run,

00:43:49.739 --> 00:43:52.799
it's going to do exactly the same thing but out on the grid.

00:43:52.800 --> 00:43:57.960
So you know, it may not look like it did in anything
different, but it actually submitted this job off

00:43:57.960 --> 00:44:02.079
to the server, which then submitted it to the
agent, the agent ran the task, captured the output,

00:44:02.079 --> 00:44:05.949
sent it back to the controller, came back to the client.

00:44:05.949 --> 00:44:12.129
But rather than just running it directly, we can submit
it, which is the asynchronous way of using Xgrid.

00:44:12.130 --> 00:44:18.309
So now we've gotten a job identifier back and if I take
a look at the job list now, sure enough, there's the job.

00:44:18.309 --> 00:44:28.750
So I can take a look at the job attributes and see
that it was submitted with a command line tool,

00:44:28.750 --> 00:44:33.769
when it was submitted, when it was finished,
that it actually finished, it didn't fail.

00:44:33.769 --> 00:44:34.949
This might also be pending.

00:44:34.949 --> 00:44:40.389
For instance if there's a lot of jobs in the queue that
were already running, then this would still be pending.

00:44:40.389 --> 00:44:43.059
And we can see the name of it and how done it is.

00:44:43.059 --> 00:44:44.529
There was only one task and it's done.

00:44:44.530 --> 00:44:47.010
So it's 100% done.

00:44:47.010 --> 00:44:49.380
I talked about this specification for a job.

00:44:49.380 --> 00:44:58.030
It's an XML property list and we can actually retrieve
this specification that the command line created for us.

00:44:58.030 --> 00:45:05.560
So in this case I printed it out in a TXT format
rather than XML, but it's still a property list

00:45:05.559 --> 00:45:13.449
and what you can see here is that it's going to
run a task with no arguments and a single command.

00:45:13.449 --> 00:45:17.409
So if you, we can actually crack
open a, where did I keep that,

00:45:17.409 --> 00:45:27.929
we can crack open a workflow here,
let's take a look at this one.

00:45:27.929 --> 00:45:38.469
Here in the resources there's this template.plist
and this is an extra job specification.

00:45:38.469 --> 00:45:41.639
It's a lot more complicated than
the one we just created but this is,

00:45:41.639 --> 00:45:45.879
this is what Podcast Producer's
using to generate the jobs for Xgrid.

00:45:45.880 --> 00:45:50.550
So you can see here we're substituting
in some global variables.

00:45:50.550 --> 00:45:55.120
We also have dependencies in Xgrid.

00:45:55.119 --> 00:46:02.659
So in this case the edit core master task is
dependent on the import plug in movie generate task

00:46:02.659 --> 00:46:06.149
and it won't get started until this task finishes.

00:46:06.150 --> 00:46:09.260
Anything else I want to show you?

00:46:09.260 --> 00:46:14.320
So a lot of these are just static because the
task are taking input from a previous task

00:46:14.320 --> 00:46:17.030
and then generating them for the next task.

00:46:17.030 --> 00:46:19.870
And because we've created all of
these tasks at the same time,

00:46:19.869 --> 00:46:22.670
we've coordinated the output files
names and the input file names.

00:46:22.670 --> 00:46:24.750
So we don't need to substitute those.

00:46:24.750 --> 00:46:29.980
But back here at the beginning, as far
as edit core annotator was concerned,

00:46:29.980 --> 00:46:33.960
well somewhere here we've got our
input file getting passed in.

00:46:33.960 --> 00:46:42.050
So here we're actually getting substituted in the file
name and so ever time this job gets submitted to Xgrid

00:46:42.050 --> 00:46:47.180
from Podcast Producer, a different value is
going to be put into that substitution variable.

00:46:47.179 --> 00:46:48.789
So it's pretty complicated.

00:46:48.789 --> 00:46:50.699
We don't need to understand all this right now.

00:46:50.699 --> 00:46:55.359
But I just wanted to show you that Podcast Producer
is in fact using Xgrid at a very basic level

00:46:55.360 --> 00:47:00.519
and by understanding how to create an
Xgrid job, you're really well on your way

00:47:00.519 --> 00:47:03.059
to understanding how to create a Podcast Producer workflow.

00:47:03.059 --> 00:47:06.940
You can dig through those PWF bundles
to see what other details are in there.

00:47:06.940 --> 00:47:11.360
One of the easiest things to do is
just to take an existing PWF that works

00:47:11.360 --> 00:47:15.760
and then start modifying it by hand
and hopefully it keeps working.

00:47:15.760 --> 00:47:21.100
You won't be able to open up these workflows with
Podcast Composer once you've edited them by hand,

00:47:21.099 --> 00:47:27.579
so make sure you've done everything you want to
in Podcast Composer before you start doing that.

00:47:27.579 --> 00:47:36.170
Let's see, so that's the extra client and that's the command
line tool, but there's also the Xgrid Admin application

00:47:36.170 --> 00:47:41.690
and we've improved this for Snow Leopard as well.

00:47:41.690 --> 00:47:43.550
It supports Kerberos.

00:47:43.550 --> 00:47:53.850
Give you a list of our agents, a list of the jobs and we've
added auto-logging here so if I quit and I open it back up,

00:47:53.849 --> 00:47:56.309
it remembers the servers I have and what's available.

00:47:56.309 --> 00:47:59.449
Thank you.

00:47:59.449 --> 00:48:04.980
You can add more controllers clearly, I
got Bonjour browsing and you can add grids.

00:48:04.980 --> 00:48:10.320
My favorite second grid is Ygrid.

00:48:10.320 --> 00:48:12.769
And so well what else can we do here?

00:48:12.769 --> 00:48:15.420
We can see a little bit of information here.

00:48:15.420 --> 00:48:18.559
These are the job attributes we
saw in the command line tool.

00:48:18.559 --> 00:48:21.139
But another feature that we've added is the job log.

00:48:21.139 --> 00:48:27.289
So if I double-click on this job here or
show the log, I get a list of everything

00:48:27.289 --> 00:48:29.070
that happened and when it happened for this job.

00:48:29.070 --> 00:48:36.680
So we see when it was created, when it started getting
scheduled, when it was submitted, who it was submitted to,

00:48:36.679 --> 00:48:40.649
when it started running, when it
finished, and when the job finished.

00:48:40.650 --> 00:48:43.639
So you've got a lot of tasks here, you'd see all of them.

00:48:43.639 --> 00:48:49.319
They're all going to have their identifier
based on what's in the job specification.

00:48:49.320 --> 00:48:52.460
So in the case of Podcast Producer,
if you looked at a job log,

00:48:52.460 --> 00:48:58.210
at a failed job you might see edit core master
as one of the tasks and edit had failed.

00:48:58.210 --> 00:49:02.240
And so then you might say hum, there's
something wrong with in coding today.

00:49:02.239 --> 00:49:09.479
More likely though the kinds of things that you'll see
fail in a Podcast Producer job are using external services.

00:49:09.480 --> 00:49:13.820
So you might have a mail action and you
maybe typed in the mail server wrong

00:49:13.820 --> 00:49:17.260
or the credential is wrong or maybe the mail server is down.

00:49:17.260 --> 00:49:22.570
Whatever the case though, if that task is
set up to be required as part of the job,

00:49:22.570 --> 00:49:26.680
if it fails the whole job's going to fail and
so you're going to want to know why aren't

00:49:26.679 --> 00:49:30.049
by Podcast Producer content getting posted to the library.

00:49:30.050 --> 00:49:36.210
So if you come into Xgrid Admin and take a look at the job
log here, you can see oh, it was the mail task that failed

00:49:36.210 --> 00:49:40.240
and so you might guess that well,
maybe I typed in something wrong.

00:49:40.239 --> 00:49:41.779
So you could go start checking.

00:49:41.780 --> 00:49:48.920
But you don't have to guess, you can actually get more
information about what happened and unfortunately,

00:49:48.920 --> 00:49:51.800
I also don't have that demo set
up due to our hardware failure.

00:49:51.800 --> 00:50:00.000
But what I did want to show you was that on the
command line if you get the job results for a job,

00:50:00.000 --> 00:50:08.170
so back here if I get the results for
job one, which you remember was cal,

00:50:08.170 --> 00:50:10.619
you get the standard output and standard error.

00:50:10.619 --> 00:50:16.489
And so what we've done with Pcast action for
Snow Leopard is add a whole bunch of logging

00:50:16.489 --> 00:50:20.789
to describe exactly what's going on and what's failing.

00:50:20.789 --> 00:50:26.250
So in the case of a mail failure, you'll definitely see that
it tried to contact the server, either the connection failed

00:50:26.250 --> 00:50:31.050
or the authentication failed and you'll
have a way of diagnosing what's going on.

00:50:31.050 --> 00:50:34.760
So the workflow here really is look in Podcast Producer,

00:50:34.760 --> 00:50:38.230
if your jobs are failing come in
to Xgrid Admin, look for the job.

00:50:38.230 --> 00:50:40.760
You'll see a little red dot for the failed jobs.

00:50:40.760 --> 00:50:44.740
Take a look at the job log, figure out
which task failed and then come back

00:50:44.739 --> 00:50:48.309
to the command line tool and ask it for the results.

00:50:48.309 --> 00:50:50.949
And so that's actually a lot of work.

00:50:50.949 --> 00:50:55.909
We've been telling people hey, this is how you debug
Podcast Producer and nobody really wants to do all that.

00:50:55.909 --> 00:51:03.629
So we're like OK fine, we can do it ourselves
and what we've done is create in library logs,

00:51:03.630 --> 00:51:09.010
a new location under pcast server
D called Diagnostic Reports.

00:51:09.010 --> 00:51:15.370
So I haven't had any Podcast research off scale here today,
but what we've done is whenever Podcast Producer notices

00:51:15.369 --> 00:51:20.989
that a job has failed, it will actually retrieve all of the
results for you and then put it into this folder in a file.

00:51:20.989 --> 00:51:23.879
So you're using consult.app, you can browse in here

00:51:23.880 --> 00:51:27.980
and see exactly why your jobs are failing
and hopefully be able to solve them.

00:51:27.980 --> 00:51:32.769
So that is it for the Xgrid demo.

00:51:32.769 --> 00:51:40.690
One more point about Xgrid is that if you have Xgrid
available to you, if you have Podcast Producer running

00:51:40.690 --> 00:51:43.420
on your system, you also have Xgrid running.

00:51:43.420 --> 00:51:48.200
So you can start thinking about how to use
Xgrid independently of Podcast Producer

00:51:48.199 --> 00:51:52.689
or how to use your knowledge of Podcast
Producer to help how you use Podcast Producer.

00:51:52.690 --> 00:52:01.990
So the two things we saw here were Ruby on Rails and Xgrid
and Podcast Capture Web is an HTML based web application

00:52:01.989 --> 00:52:03.929
and this is the standard use of Ruby on Rails.

00:52:03.929 --> 00:52:07.730
The 37signals guys have their website,
it's all running on Rails.

00:52:07.730 --> 00:52:13.159
There's a lot of sites out there using Rails to serve
up really rich user experiences through the web.

00:52:13.159 --> 00:52:15.409
And Ruby on Rails makes it real easy to do.

00:52:15.409 --> 00:52:19.969
AJAX and real modern style web programming.

00:52:19.969 --> 00:52:25.539
But the rest of Podcast Producer Server
is also Ruby on Rails and we're using it

00:52:25.539 --> 00:52:28.460
in this case as an XML based web service.

00:52:28.460 --> 00:52:35.960
So the Podcast command line tool is making web
requests to the server and getting XML back, not HTML.

00:52:35.960 --> 00:52:41.059
And it's not rendering the stuff on a web page,
it's using this information to make choices

00:52:41.059 --> 00:52:46.639
and likewise the Podcast Capture application
gets these XML plists back from the server

00:52:46.639 --> 00:52:50.549
and then converts them into a rich
user experience in the UI.

00:52:50.550 --> 00:52:56.760
And this is a really powerful technique, it
can also be used for iPhone applications.

00:52:56.760 --> 00:53:03.870
Ruby on Rails is perfectly suited for setting up the server
side of an iPhone application and it's network based.

00:53:03.869 --> 00:53:10.409
And as I said, if you're using Podcast Producer,
you have a grid, go ahead and start using it

00:53:10.409 --> 00:53:16.429
and think about what other things you have at your
organization that could benefit from a batch queue system

00:53:16.429 --> 00:53:22.419
where you can send it a bunch of work and know that it
will all get done eventually on the available resources.

00:53:22.420 --> 00:53:29.349
And finally, now that you've seen how to use Xgrid,
you have a better idea of how to dig into failed jobs

00:53:29.349 --> 00:53:32.269
when your Podcast Producer workflows
aren't working as you expected.

00:53:32.269 --> 00:53:41.929
So I've been talking about workflows, sort of from the
perspective of submitting to them or the factory uses them

00:53:41.929 --> 00:53:46.869
or the capture or the composer creates them,
but you know this is about the technology

00:53:46.869 --> 00:53:50.109
so let's really dig in to what these workflows do.

00:53:50.110 --> 00:54:01.690
On the right there you see the screen shot from Composer and
the stages in Composer, the five middle stages really map

00:54:01.690 --> 00:54:03.690
on directly to what the workflow is doing.

00:54:03.690 --> 00:54:09.539
So in the generic sense of what does a Podcast Producer
workflow do, is it's going to import the source materials

00:54:09.539 --> 00:54:15.809
into a single video and the dual source
case, that's a picture in picture effect,

00:54:15.809 --> 00:54:21.289
in the case of the montage workflow, that's
a number of documents or multi-page documents

00:54:21.289 --> 00:54:23.690
that you're then going to convert into a single video.

00:54:23.690 --> 00:54:28.030
You then edit the video, you add
titles, transitions, overlays, credits.

00:54:28.030 --> 00:54:35.110
Then once you've got your edited master, you're going to
encode the video to your target devices, formats, iPod,

00:54:35.110 --> 00:54:40.890
iPhone, audio only, AppleTV and then distribute the
video, send it to the library, send it to the Wiki Server,

00:54:40.889 --> 00:54:45.349
send it to iTunesU and finally you want
to notify people, send an iChat message

00:54:45.349 --> 00:54:48.210
or an email letting then know that new content is available.

00:54:48.210 --> 00:54:56.769
I want to talk about the montage workflow specifically
here because it's pretty interesting in what it does.

00:54:56.769 --> 00:55:00.519
We're using the Quick Look technology
to covert documents into images.

00:55:00.519 --> 00:55:02.789
You've seen, the Wiki Server also does this

00:55:02.789 --> 00:55:08.099
and of course the Finder does it any
time you press spacebar on a document.

00:55:08.099 --> 00:55:17.949
The montage workflow then, once it's gotten it's images out
of the documents, it uses Quartz Composer to composition

00:55:17.949 --> 00:55:23.919
from Quartz Composer to render these images into a movie
and the movie that we get out of that is a reference movie

00:55:23.920 --> 00:55:29.889
that only works on the machine that we're running on, so
what we then want to do is use QTKit in code to flatten

00:55:29.889 --> 00:55:31.809
and transcode the movies to device format.

00:55:31.809 --> 00:55:40.659
So this is exactly what the montage workflow that
is installed by default with Podcast Producer does.

00:55:40.659 --> 00:55:51.139
All of our workflows and pcast action tool and the Podcast
tool and pcast server d, they're all written in Ruby

00:55:51.139 --> 00:55:54.549
and we want to access some ObjectiveC APIs from them.

00:55:54.550 --> 00:55:58.120
So we're using Ruby Cocoa almost everywhere.

00:55:58.119 --> 00:56:04.539
And what's really cool about Ruby Cocoa is it allows
you to take a Ruby shell script and use ObjectiveC APIs.

00:56:04.539 --> 00:56:05.639
And why does this matter?

00:56:05.639 --> 00:56:12.699
Well because almost every technology that's interesting
in Mac OS X, is exposed through an ObjectiveC API

00:56:12.699 --> 00:56:18.809
and even the ones that are only exposed through C, are
actually still available through the ObjectiveC APIs

00:56:18.809 --> 00:56:23.840
because C is just a subset of ObjectiveC,
so you get access to a whole bunch of stuff

00:56:23.840 --> 00:56:26.960
from Ruby once you start using Ruby Cocoa.

00:56:26.960 --> 00:56:32.309
So Podcast Producer's using Ruby and Ruby Cocoa to glue
together all of these technologies that we've talked

00:56:32.309 --> 00:56:38.179
about into a solution and in the case of the montage
workflow, that's what we've done that we're calling

00:56:38.179 --> 00:56:48.169
into Quick Look, calling into QTKit, we're calling
into various APIs to make everything happen in the end.

00:56:48.170 --> 00:56:51.550
Someone once said that PERL is
the duct tape of the Internet.

00:56:51.550 --> 00:56:55.280
I don't know what that makes Ruby, but it's pretty cool.

00:56:55.280 --> 00:57:01.200
So the demo I'm going to do for you
now is to replicate the functionality

00:57:01.199 --> 00:57:04.639
of the montage workflow, without using Podcast Producer.

00:57:04.639 --> 00:57:14.179
And the basic idea here is to start with a multi-page
pdf and then generate a series of TIF images

00:57:14.179 --> 00:57:19.190
and then also an XML file describing
the location of these images.

00:57:20.309 --> 00:57:29.049
We're then going to take a Quartz Composer composition
and this XML and these images and run them all through QC

00:57:29.050 --> 00:57:36.070
to movie which will generate a reference movie file
and then we're going to use the QTKit encode APIs

00:57:36.070 --> 00:57:43.940
to covert this movie into an MPEG4, MP4 iPod format
movie that we can then transfer to any mobile device.

00:57:43.940 --> 00:57:49.760
And we're going to do all this using Ruby Cocoa.

00:57:49.760 --> 00:57:54.290
So I'm not going to open up Xcode for this demo, I'm going
to use Textmate and I'm going to show you how to use all

00:57:54.289 --> 00:57:58.320
of these APIs yourself, just the way
we're using them in Podcast Producer.

00:58:01.980 --> 00:58:05.420
All right, so here's my empty file.

00:58:05.420 --> 00:58:13.000
We're going to call this script
mantage.rv, let's save this someplace.

00:58:13.000 --> 00:58:18.440
[ no speaking ]

00:58:18.440 --> 00:58:19.730
All right.

00:58:19.730 --> 00:58:24.889
And I've got my EZ Bake recipe over
here where I've already created it,

00:58:24.889 --> 00:58:28.549
so I'm just going to copy this stuff
over and talk about it as I do.

00:58:28.550 --> 00:58:37.760
We're going to require some Ruby libraries here
and then we're going, by doing require OS X Cocoa,

00:58:37.760 --> 00:58:48.580
we have loaded Ruby Cocoa and we can then use the OS X class
object to require frameworks and in this case we're going

00:58:48.579 --> 00:58:55.610
to load PDFKit and QTKit, because we're going
to use PDFKit to convert this PDF into images

00:58:55.610 --> 00:58:59.019
and we're going to use QTKit to then encode the videos.

00:58:59.019 --> 00:59:03.809
I've chosen to use PDFKit here as opposed
to Quick Look, just for simplicity,

00:59:03.809 --> 00:59:06.329
to make it a little bit clearer for you all.

00:59:06.329 --> 00:59:10.349
So next thing we're going to do is this
script is going to read some input.

00:59:10.349 --> 00:59:17.909
So either we're going to take the first argument or we're
going to exit and then we're going to set some variables.

00:59:17.909 --> 00:59:22.699
So given the input path, we're going to figure out
what the name the file was without the extension.

00:59:22.699 --> 00:59:29.509
We're going to create a temporary directory that we can put
our trials that our intermediate steps and then we're going

00:59:29.510 --> 00:59:37.330
to output the file, the movie that we generate,
to the same folder that the input came from.

00:59:37.329 --> 00:59:42.960
And then this line here just tells Finder to open up this
temporary directory that we just created and I'm doing this

00:59:42.960 --> 00:59:47.460
for the demo so that we can see the files as we get created.

00:59:47.460 --> 00:59:53.800
Let's see, so I mentioned we're going to create
an XML document to contain a list of all the paths

00:59:53.800 --> 01:00:05.590
that have passed the Quartz Composer, so here we use
the RXML class from Ruby and then we're going to,

01:00:05.590 --> 01:00:10.630
we don't have any XML to write yet, so
we'll just leave this element alone.

01:00:10.630 --> 01:00:17.650
And we're going to then read in the input path to
create the and once we have the URL for the input path,

01:00:17.650 --> 01:00:23.530
we're going to read in the PDF document and then
we're going to have a page count from that class.

01:00:23.530 --> 01:00:27.790
So these are just the ObjectiveC classes
that we're using directly from Ruby.

01:00:27.789 --> 01:00:29.210
It's very easy.

01:00:29.210 --> 01:00:32.679
So here's the real meat of this script.

01:00:32.679 --> 01:00:38.960
And what we're going to do is extract TIF
images from each stage of the document.

01:00:38.960 --> 01:00:45.449
So we're going to go through this loop page count times,
for each page index, we're going to find the documents page

01:00:45.449 --> 01:00:49.219
at that index, we're going to ask
the page for it's data representation

01:00:49.219 --> 01:00:55.029
and what this does is it basically creates a PDF
document of just the page that we're looking at.

01:00:55.030 --> 01:01:03.320
So now we have this page data and we can ask
NS Image to turn this PDF data into an image

01:01:03.320 --> 01:01:05.940
and we can ask the image for it's TIF representation.

01:01:05.940 --> 01:01:13.320
So this is sort of a round about way of doing
this, but it's very easy to do from Ruby Cocoa.

01:01:13.320 --> 01:01:18.940
We are going to need to save this image out
and since we're saving pages out we're going

01:01:18.940 --> 01:01:22.220
to need unique file names, so here the index is 0 based.

01:01:22.219 --> 01:01:28.500
So we're going to add a 1 to it and just save
out the file name page 1, page 2, page 3.

01:01:28.500 --> 01:01:34.349
We're going to write a little message out so we can see
what's going on and then finally once we have the TIF data,

01:01:34.349 --> 01:01:39.400
we're going to write it to the file that we just
created, the file path that we just generated

01:01:39.400 --> 01:01:46.079
and these are all just the methods that you would
see in ObjectiveC, but used from Ruby Cocoa.

01:01:46.079 --> 01:01:47.409
And now we're going to use the XML.

01:01:47.409 --> 01:01:54.960
So that now that we have a path to write to, we're
going to add an image path element to this XML

01:01:54.960 --> 01:02:03.280
and set the text of that element to be the path.

01:02:03.280 --> 01:02:06.080
All right, next.

01:02:06.079 --> 01:02:09.139
We're going to save the XML document.

01:02:09.139 --> 01:02:11.529
Pretty simple.

01:02:11.530 --> 01:02:15.940
Again, this is a little bit round about, there are
Ruby methods for saving strings but when you're living

01:02:15.940 --> 01:02:20.179
in a Ruby Cocoa world, it's usually
easier just to stay there.

01:02:20.179 --> 01:02:28.329
So here I take the XML that document object from Ruby and
I ask it to turn it into a Ruby string and then I pass

01:02:28.329 --> 01:02:33.909
that into NS string so that now I have an NS
string containing the TXT for this XML document

01:02:33.909 --> 01:02:40.389
and I just use NS strings write to
file atomically method to write it out.

01:02:40.389 --> 01:02:48.829
So let's stop there and see what
happens when we run this script.

01:02:48.829 --> 01:02:59.039
So, montage, OK it doesn't do anything
because I didn't give it a file name.

01:02:59.039 --> 01:03:04.159
I have a file in here called french4paris.pdf.

01:03:04.159 --> 01:03:10.049
So let's trying passing that one.

01:03:10.050 --> 01:03:10.880
That was quick.

01:03:10.880 --> 01:03:14.010
This machine's a lot faster than the one I tested on.

01:03:14.010 --> 01:03:15.490
So what did we get?

01:03:15.489 --> 01:03:18.039
We got some images from the PDF.

01:03:18.039 --> 01:03:19.250
Can Quick Look them.

01:03:19.250 --> 01:03:27.349
So this is the multi-page PDF you may have seen in
a previous session and then we've got this XML file.

01:03:27.349 --> 01:03:35.610
And well it doesn't look too nice there, maybe
we can... this bundle XML...tidy maybe?

01:03:35.610 --> 01:03:36.890
Yes, there we go.

01:03:36.889 --> 01:03:43.279
So as you can see, we saved these images
out to some temporary location but,

01:03:43.280 --> 01:03:46.970
we've got an array of image paths and each path is a string.

01:03:46.969 --> 01:03:49.449
So we're going to use this from Quartz Composer.

01:03:49.449 --> 01:03:54.539
So how am I doing on time?

01:03:54.539 --> 01:03:56.880
All right, I better speed this up.

01:03:56.880 --> 01:04:02.289
We are going to create a Quartz Composition
now and this is always fun to do.

01:04:02.289 --> 01:04:06.639
Because you get to stop thinking about text
and start thinking about rounded rectangles.

01:04:06.639 --> 01:04:14.969
So, let's take a look, here's where
I've sort of set myself up.

01:04:14.969 --> 01:04:23.019
So we're going to have input and then we're going to
determine the path of the current image to display,

01:04:23.019 --> 01:04:27.099
then we're going to load that image from the
path and then we're going to display the image.

01:04:27.099 --> 01:04:35.619
It's actually easier to start, well
we'll start with the inputs first.

01:04:35.619 --> 01:04:41.989
So the easiest way to set up a splitter is with
an input splitter, set up an input is so I'm going

01:04:41.989 --> 01:04:55.729
to call this one XML location and I'm going to publish it's
input, except I can't do that until I set it to be a string.

01:04:55.730 --> 01:05:01.019
All right, impose XML location.

01:05:01.019 --> 01:05:04.949
All right and I'm going to have another
one which is the image duration.

01:05:04.949 --> 01:05:09.379
So here the idea is that we're going to
do a slide show right and so we want each,

01:05:09.380 --> 01:05:13.099
each page of this PDF to be displayed
for some period of time.

01:05:13.099 --> 01:05:23.420
So I'm going to take this as a number and
we'll call this guy image duration and again,

01:05:23.420 --> 01:05:27.630
we're going to publish same as administration.

01:05:27.630 --> 01:05:29.180
OK great. So those are the inputs.

01:05:29.179 --> 01:05:34.629
So now let's head on over to the end here, because it's a
little bit easier for me to think about this from this side.

01:05:34.630 --> 01:05:39.750
So we're going to create a bell bar, because
bell bars are how you display things here

01:05:39.750 --> 01:05:43.539
and let's take a look at the settings and parameters.

01:05:43.539 --> 01:05:51.039
I'm going to do the width too, so it fills up the whole area
the way Quartz Composer addressed the coordinates face works

01:05:51.039 --> 01:05:53.110
as that it goes from 0 to 1 from the center.

01:05:53.110 --> 01:05:57.400
So -1 to 1 is the full screen, so
width of 2 gives you full screen wide,

01:05:57.400 --> 01:06:00.710
that's what we're going to do with the billboard.

01:06:00.710 --> 01:06:05.789
So the other thing then is we're
going to work backwards from here.

01:06:05.789 --> 01:06:17.279
Well, OK. I have the XML location and we're going
to load the XML with using the XML importer.

01:06:17.280 --> 01:06:18.519
Pretty simple.

01:06:18.519 --> 01:06:21.420
We just hook up the location to the location.

01:06:21.420 --> 01:06:23.349
All right and then what are we going to do with that?

01:06:23.349 --> 01:06:28.029
Well we need to get the element out
of it and the way to get elements

01:06:28.030 --> 01:06:32.780
out this structure is using the Structure Index Number.

01:06:32.780 --> 01:06:39.340
So the parsed XML is going to be a structure that
we can pass in here and well what index do we want,

01:06:39.340 --> 01:06:43.200
well we want all of them but we
want the first one for a few seconds

01:06:43.199 --> 01:06:46.829
and then after image duration we want the
second one and then we want the third one.

01:06:46.829 --> 01:06:49.960
So let's come back to that in a second.

01:06:49.960 --> 01:06:56.559
Once we've gotten the image path out of
this XML, we're going to want to load it.

01:06:56.559 --> 01:07:08.829
So use the image importer patch and
we just path it in image location

01:07:08.829 --> 01:07:12.190
and then the image we're going to pass on to the bell bar.

01:07:12.190 --> 01:07:14.599
So that's pretty simple.

01:07:14.599 --> 01:07:18.139
But what about this index all right?

01:07:18.139 --> 01:07:27.799
Well like I said, we're going to base this on the
time and the duration but let's work backwards here

01:07:27.800 --> 01:07:33.870
and start with a mathematical expression that we're
going to use to determine the current one to do.

01:07:33.869 --> 01:07:40.449
So in this case the expression I'm going to do is well
I'm going to take the current patch time, whatever it is,

01:07:40.449 --> 01:07:49.699
0 seconds, 10 seconds, however long has elapsed through
this event and then multiply that by the image duration

01:07:49.699 --> 01:07:56.079
or rather divide it and we're going to just
floor that so that I get an integer value back.

01:07:56.079 --> 01:08:00.250
So this is going to be 0 until image
duration has elapsed and then it's going

01:08:00.250 --> 01:08:02.019
to be 1 and then it's going to be 2 right.

01:08:02.019 --> 01:08:02.460
Real simple.

01:08:02.460 --> 01:08:07.559
And then because the duration might be longer than the
number, the total duration of the movie might be longer

01:08:07.559 --> 01:08:16.539
than the number of images I have to show,
I'm going to do this all modulo image count

01:08:16.539 --> 01:08:20.640
and I apologize if you thought there would be no math.

01:08:20.640 --> 01:08:27.289
So QC has already detected all of these sort of
infra-variables that I gave it, so the patch time comes

01:08:27.289 --> 01:08:38.420
from the patch time, speaking of time I'm running out of it
and then we've got a the image duration comes from the input

01:08:38.420 --> 01:08:48.090
and the image count is actually to
get from that structure, struc count.

01:08:48.090 --> 01:08:56.239
So we're going to take the same XML structure, pass
it in, take out the count, stick it there, good to go.

01:08:56.239 --> 01:09:01.460
All right, so that is the entire patch,
which should do everything we want.

01:09:01.460 --> 01:09:05.520
Load the XML depending on the time,
display different image to the bell bar.

01:09:05.520 --> 01:09:10.010
So let's see what we can do with that.

01:09:10.010 --> 01:09:20.810
Heading back here, what we're going to do is use QC
to movie to generate the movie file and so I'm going

01:09:20.810 --> 01:09:24.450
to go real quick here, we're going to use
that montage, that QTZ I just created,

01:09:24.449 --> 01:09:28.010
we're going to create a QC.mov, reference movie.

01:09:28.010 --> 01:09:32.460
We're going to hard code some width, height and
duration and the movie duration we're just going

01:09:32.460 --> 01:09:36.090
to say the page count times the image
duration so we don't do any wrapping,

01:09:36.090 --> 01:09:39.020
the modulo wasn't necessary, but
I just did there for completeness.

01:09:39.020 --> 01:09:42.110
Now we're going to run QC to movie
using Ruby system command.

01:09:42.109 --> 01:09:48.979
We pass in the XML location and the image duration
as inputs that we, those are the ones we published

01:09:48.979 --> 01:09:53.889
and then the standard QC to movie arguments
are the composition path, the movie path,

01:09:53.890 --> 01:09:57.510
the width you want to use and the
total duration of the movie.

01:09:57.510 --> 01:10:08.460
OK? And then finally once we have that QC movie file,
we're going to export it and so this is where we use QTKit.

01:10:08.460 --> 01:10:15.550
I happen to know that the iPod format is m4vspace, so I
just use QTOS type for string to get that as a string.

01:10:15.550 --> 01:10:21.810
We then create an export attribute
dictionary, QT export, movie export, true,

01:10:21.810 --> 01:10:24.240
QT movie export type, the iPod export type.

01:10:24.239 --> 01:10:27.920
We give it a file name and then it's
really easy to export this movie.

01:10:27.920 --> 01:10:33.279
You just say you load the composition movie, movie
with the file and then you take that same movie

01:10:33.279 --> 01:10:37.369
and you just write it back to another
file using those export attributes.

01:10:37.369 --> 01:10:38.369
Couldn't be simpler.

01:10:38.369 --> 01:10:43.819
And then finally what our script's going to do is open up
Quick Time Player to show us the movie that we generated.

01:10:43.819 --> 01:10:50.779
So cross fingers, let's see what happens.

01:10:50.779 --> 01:10:55.340
Why don't I try saving the script first.

01:10:55.340 --> 01:10:57.750
And let's see what happens.

01:10:57.750 --> 01:11:05.670
All right, generating the intermediate movie, exporting file
movie, so here you can see we got it, yes that was quick.

01:11:05.670 --> 01:11:06.840
Wow this is great machine.

01:11:06.840 --> 01:11:10.640
You guys all should get 16 core duo processors, I tell you.

01:11:10.640 --> 01:11:20.800
Watch it all right, a few seconds
here and oh I did, all right.

01:11:20.800 --> 01:11:21.710
Thanks guys.

01:11:21.710 --> 01:11:28.239
You could have told me a little earlier I think but all
right, so actually what I'm going to do here is just

01:11:28.239 --> 01:11:45.000
to cheat, as I will show you the final
one, just do and no, no such luck.

01:11:45.000 --> 01:11:49.359
[ no speaking ]

01:11:49.359 --> 01:11:54.949
All right hopefully it'll switch, yes hooray.

01:11:57.449 --> 01:12:02.109
So that's it, that's seventy-five lines
of Ruby code to completely replicate,

01:12:02.109 --> 01:12:06.250
almost what we've done in Podcast
Producer with Montage workflow.

01:12:06.250 --> 01:12:11.710
You notice we didn't get the page called transitions, or
the intros or the exits, but if you need to do something

01:12:11.710 --> 01:12:14.779
like this you can and you don't
need to use Podcast Producer.

01:12:16.319 --> 01:12:19.989
So the stuff I've been talking about, there's
various sources of information about it.

01:12:19.989 --> 01:12:24.649
You can get that coordination sample code, not the
one that we saw but basically what we based it off

01:12:24.649 --> 01:12:29.839
of from developer.apple.com, also in
your developer folder on your computer.

01:12:29.840 --> 01:12:35.390
The QTKit Capture sample code is also very similar to
what we showed you and is available on the website.

01:12:35.390 --> 01:12:41.160
The Deployment documentation for Ruby on Rails is available
from support.apple.com as well as the Server Admin Help.

01:12:41.159 --> 01:12:46.930
I recommend reading the Xgrid Administration and High
Performance Computing guide, which is a PDF available

01:12:46.930 --> 01:12:52.170
from support.apple.com and finally for Ruby Cocoa,
there's an external website you can take a look

01:12:52.170 --> 01:12:56.560
at that's got a whole bunch of links to a whole
bunch of resources about how to use Ruby Cocoa.

01:12:56.560 --> 01:13:02.310
I have never found a problem that
wasn't more fun to solve with Ruby.

01:13:02.310 --> 01:13:04.600
So I love using Ruby.

01:13:04.600 --> 01:13:10.000
Anytime I have a problem to solve, if I'm typing
the same thing more than twice in the terminal,

01:13:10.000 --> 01:13:14.840
maybe it would have taken me three minutes to do in the
terminal, I'll spend ten minutes writing a Ruby script

01:13:14.840 --> 01:13:17.369
to do it, just so I don't have to do it that third time.

01:13:17.369 --> 01:13:19.489
That's just how I roll.

01:13:19.489 --> 01:13:22.019
I love using Ruby so, I recommend it.

01:13:22.020 --> 01:13:27.900
More information we've got our IT Evangelist
Mark, the training and certification website.
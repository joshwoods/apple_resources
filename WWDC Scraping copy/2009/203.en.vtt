WEBVTT

00:00:13.869 --> 00:00:18.609
>> My name is Brady Eldson, I'm a software
engineer on the Safari and Web Kit team.

00:00:18.609 --> 00:00:19.989
First I want to ask you a quick question.

00:00:19.989 --> 00:00:25.199
How many of you have developed
real applications for the desktop.

00:00:25.199 --> 00:00:26.449
A lot of hands.

00:00:26.449 --> 00:00:30.530
OK. How many of you have developed web
applications that run in a browser.

00:00:30.530 --> 00:00:33.250
A lot of the same hands.

00:00:33.250 --> 00:00:36.659
And for that one guy way in the back who
didn't raise his hand for the web app question,

00:00:36.659 --> 00:00:40.029
I'm going to talk about really quick what a web app is.

00:00:40.030 --> 00:00:43.250
The web started out with single web pages.

00:00:43.250 --> 00:00:51.390
Throw some HTML up on the screen, some images, some
bouncing marquees and banners and call it a day.

00:00:51.390 --> 00:00:58.370
After a little bit we started to get what we call web
sites, collections of pages on the same topic that were --

00:00:58.369 --> 00:01:03.759
the same kind of methodology, just throwing it
out there and making things a little more complex.

00:01:03.759 --> 00:01:11.060
As browsers and web technology evolved, things started
to get a lot more organized, a lot more dynamic,

00:01:11.060 --> 00:01:15.480
and we started to call these collections web applications.

00:01:15.480 --> 00:01:21.300
Now with modern browsers and modern standards really
turbo charging what these web applications can do.

00:01:21.299 --> 00:01:27.939
So it's a lot more like what you desktop
application developers are used to developing.

00:01:27.939 --> 00:01:36.069
With technologies like font face and SVG
fonts, and great new text editing APIs.

00:01:36.069 --> 00:01:43.409
Rich media, and desktop-like UI experiences with the
audio and video elements, and accessibility support.

00:01:43.409 --> 00:01:49.969
All the cool image effects and graphics effects
you can do with CSS masks and transforms

00:01:49.969 --> 00:01:53.599
and gradients and animations, all that cool stuff.

00:01:53.599 --> 00:01:58.289
The data of the application yourself, we're giving
you the turbo charged nitro JavaScript engine,

00:01:58.290 --> 00:02:05.880
and we're giving you great developer tools to make
developing a web application feel a lot more real.

00:02:05.879 --> 00:02:08.439
But there's been one thing missing here.

00:02:08.439 --> 00:02:10.539
What about the data.

00:02:10.539 --> 00:02:11.900
Some of you might be saying what data.

00:02:11.900 --> 00:02:15.590
Well, what about your application's
data, the state of the application,

00:02:15.590 --> 00:02:20.689
where in the middle of a long running procedure
was your application, what was it doing,

00:02:20.689 --> 00:02:23.039
where were the windows, how were they set up.

00:02:23.039 --> 00:02:26.280
How about the resources to make up the application itself.

00:02:26.280 --> 00:02:31.810
Your markup, your style, your scripts,
and then there's your user's data.

00:02:31.810 --> 00:02:36.449
Your users probably have a preferred way
of using or viewing your application.

00:02:36.449 --> 00:02:39.239
So all their preferences and settings.

00:02:39.240 --> 00:02:44.330
And in many of your applications your users are
generating content right there in the browser.

00:02:44.330 --> 00:02:47.040
So all this data has to go somewhere.

00:02:47.039 --> 00:02:49.799
And typically it's been on a server somewhere, right?

00:02:49.800 --> 00:02:53.710
The application resources themselves,
they come from a server,

00:02:53.710 --> 00:02:58.250
and then we're used to shipping data back off to a server.

00:02:58.250 --> 00:02:59.719
Well, users have machines.

00:02:59.719 --> 00:03:06.229
Sometimes they're brand new hot machines, sometimes
they're machines that have been around a little bit.

00:03:06.229 --> 00:03:09.079
And the machines really take all sorts of forms, right?

00:03:09.080 --> 00:03:12.490
And all these machines have something in common.

00:03:12.490 --> 00:03:14.969
They all have some sort of local storage.

00:03:14.969 --> 00:03:18.289
Disc drive, solid state flash drives.

00:03:18.289 --> 00:03:24.859
And we want to give you a standard way to
access that and use it to its full potential.

00:03:26.770 --> 00:03:28.340
Standard way.

00:03:28.340 --> 00:03:32.250
We love working with web standards,
Apple work, has been working closely

00:03:32.250 --> 00:03:36.270
with the WHAT Working Group in W3C on the HTML 5 standard.

00:03:36.270 --> 00:03:41.490
And we're trying to bring these technologies forward
in Safari and in a standard interoperable way

00:03:41.490 --> 00:03:43.640
that hopefully everyone will be implementing.

00:03:43.639 --> 00:03:52.819
And everything I'm going talk to you about -- to you today,
is available in Safari 4 that was released on Monday,

00:03:52.819 --> 00:03:56.250
on Mac, on Windows, and in iPhone OS 3.0.

00:03:56.250 --> 00:04:03.990
So we're going to talk a little more about data on the web.

00:04:03.990 --> 00:04:07.610
We have some new solutions, but this is an old problem.

00:04:07.610 --> 00:04:15.430
So we're going to talk a little bit about the ingenious
ways you as developers have been managing the data so far.

00:04:15.430 --> 00:04:20.410
Then we'll jump into our first
standard, the HTML 5 Key/Value storage.

00:04:20.410 --> 00:04:25.250
It comes in a couple flavors that
do a couple cool different things.

00:04:25.250 --> 00:04:31.040
Then we'll get into the power of the HTML 5
structure databases, some really cool, powerful stuff.

00:04:31.040 --> 00:04:35.240
A relational database in the browser,
accessible through JavaScript.

00:04:35.240 --> 00:04:42.019
And then we'll cap it off with a little discussion about
the HTML 5 application cache, which is all the resources

00:04:42.019 --> 00:04:48.459
that make up your application living in a
predictable way inside of your user's browser.

00:04:48.459 --> 00:04:51.459
So data on the web.

00:04:51.459 --> 00:04:53.509
Right now there's all this data flinging around.

00:04:53.509 --> 00:05:00.259
I've gone over most of it, the application resources, the
data your application needs, the data your users generate.

00:05:00.259 --> 00:05:07.480
And there hasn't been a good solution
for how to wrangle all this data.

00:05:07.480 --> 00:05:12.290
You as developers have come up with some
pretty creative solutions in the meantime.

00:05:12.290 --> 00:05:17.680
Ways of handling the data in the
absence of a better alternative.

00:05:17.680 --> 00:05:19.740
For example, cookies.

00:05:19.740 --> 00:05:25.810
Cookies were invented as part of the HTTP
spec for shipping data automatically back

00:05:25.810 --> 00:05:28.329
and forth between the server and the web browser.

00:05:28.329 --> 00:05:31.729
They're great for that, they'll always be great for that.

00:05:31.730 --> 00:05:36.060
But they're more fragile than some of you might think.

00:05:36.060 --> 00:05:42.610
The cookie standard says that a browser can be very limited
in the cookies it supports, it can prune them any time.

00:05:42.610 --> 00:05:47.439
You might set an expiration date far off in the
future and assume it will be there years from now.

00:05:47.439 --> 00:05:49.110
In most cases, it won't be.

00:05:49.110 --> 00:05:59.319
There's severe limits on the sizes of cookies, and they're
just too limited and fragile when it comes down to it.

00:06:01.839 --> 00:06:03.889
What about the cloud.

00:06:03.889 --> 00:06:08.990
Sending data through the Internet to
a server somewhere that you control.

00:06:08.990 --> 00:06:15.019
This is very important, and it will continue
to be important, using form data to post,

00:06:15.019 --> 00:06:22.669
using query strings in URLs, or shipping data off
with an XMLHttpRequest to a server you control.

00:06:22.670 --> 00:06:30.930
The problem here is the network is fundamentally unreliable
compared to knowing what's going on on the local machine.

00:06:30.930 --> 00:06:35.220
The network is slow compared to how data
is transferred around within the machine.

00:06:35.220 --> 00:06:36.860
You have to control the server.

00:06:36.860 --> 00:06:37.759
You have to manage it.

00:06:37.759 --> 00:06:39.659
You have to keep it up-to-date.

00:06:39.660 --> 00:06:44.390
And really, it's just too complex and
expensive for a lot of the solutions you

00:06:44.389 --> 00:06:48.180
as developers really need to -- really need.

00:06:48.180 --> 00:06:52.220
And then there's plug-ins.

00:06:52.220 --> 00:06:58.670
Many of you have turned to some popular plug-ins, some
unpopular plug-ins, and sometimes your own custom plug-ins

00:06:58.670 --> 00:07:06.290
to store small nuggets of data in the user's
web browser, or to store large volumes of data.

00:07:06.290 --> 00:07:10.670
The problem with plug-ins is that they
don't integrate into the browser very well.

00:07:10.670 --> 00:07:16.810
Each plug-in has their own UI that the user has
to access outside of the browser standard UI.

00:07:16.810 --> 00:07:19.660
Plug-ins might have different bugs on different platforms.

00:07:19.660 --> 00:07:24.070
And if they do have different bugs in different
platforms, you either have to be in control of the plug-in

00:07:24.069 --> 00:07:27.040
and debug on all the different platforms,
or you have to talk to the vendor,

00:07:27.040 --> 00:07:30.569
and some users might not have the plug-in, and
some users just don't want to browse with plug-ins,

00:07:30.569 --> 00:07:36.569
and some plug-ins may be slow to load out of the
browser space, and there's just all these problems.

00:07:36.569 --> 00:07:39.649
They're just not standard web technology.

00:07:39.649 --> 00:07:44.199
Some of you might be overwhelmed right now.

00:07:44.199 --> 00:07:47.719
You're saying to yourself, I never
thought about it all that way.

00:07:47.720 --> 00:07:49.380
What should I be looking for.

00:07:49.379 --> 00:07:55.649
When we're manipulating simple data, what's an ideal world.

00:07:55.649 --> 00:07:59.339
Manipulating simple data should
be fast and it should be easy.

00:07:59.339 --> 00:08:03.539
Back to the cookies example, where we're
storing small nuggets of data in cookies.

00:08:03.540 --> 00:08:08.780
How many of you are familiar with writing a cookie
parsing string just to get a document.cookies.

00:08:08.779 --> 00:08:10.709
See a few hands come up.

00:08:10.709 --> 00:08:13.009
Have fun with that, some time, if you haven't tried it.

00:08:13.009 --> 00:08:15.870
It's ridiculous just for Key/Value pairs of data.

00:08:15.870 --> 00:08:17.910
So it should be a lot easier than that.

00:08:17.910 --> 00:08:22.140
And then with more complex data, we need to be flexible.

00:08:22.139 --> 00:08:27.669
We need to be able to handle any size of data,
any complexity of data, data with structure.

00:08:27.670 --> 00:08:35.610
And it needs to be just in a built in native way in
the browser, standard -- standard base way, hopefully.

00:08:35.610 --> 00:08:37.680
And it also needs to be fast.

00:08:37.679 --> 00:08:41.579
Modern users aren't going to wait
for anything, in the web browser

00:08:41.580 --> 00:08:43.900
or on the desktop application, it's the same to them.

00:08:43.899 --> 00:08:49.829
If your page is locking up the browser or taking a long time
to complete something, they're not going to put up with it.

00:08:49.830 --> 00:08:53.830
So even large amounts of complex data needs to be fast.

00:08:53.830 --> 00:09:00.440
And no matter what kind of data we're
manipulating, it needs to be persistent and secure.

00:09:00.440 --> 00:09:04.390
We need to know if we want it to be there ten years
from now, it will be there ten years from now.

00:09:04.389 --> 00:09:05.669
It needs to be secure.

00:09:05.669 --> 00:09:11.159
We need to know that our web application
and our users are in control of our data,

00:09:11.159 --> 00:09:16.049
and are the only ones who have access to it.

00:09:16.049 --> 00:09:22.839
So with these things in mind, I'd like to talk
to you about the HTML 5 Key/Value storage system.

00:09:22.840 --> 00:09:32.250
Key/Value storage is about a simple way to
manipulate simple data in JavaScript in the browser.

00:09:32.250 --> 00:09:39.779
Data that will be persistent and accessible to you a
long time from now and off line with no network required.

00:09:39.779 --> 00:09:49.230
In the Key/Value storage API, data items are
Key/Value pairs, much like in a cookie string,

00:09:49.230 --> 00:09:53.110
or if you're familiar with using
LocalStorage in Flash, for example.

00:09:53.110 --> 00:09:54.190
It's the same type of data.

00:09:54.190 --> 00:09:58.170
And it's really simple to manipulate.

00:09:58.169 --> 00:10:02.479
The way the Key/Value storage works,
and I'll get into it in just a minute,

00:10:02.480 --> 00:10:05.570
it just integrates into the JavaScript language natively.

00:10:05.570 --> 00:10:08.190
It feels like -- you're just using JavaScript.

00:10:08.190 --> 00:10:12.680
If you know how to use JavaScript you
already know how to use Key/Value storage.

00:10:12.679 --> 00:10:15.159
So it's really great.

00:10:15.159 --> 00:10:17.289
It has origin-based security.

00:10:17.289 --> 00:10:22.740
This has been the standard security model on the
web and it's being really formalized in HTML 5.

00:10:22.740 --> 00:10:31.370
All this means is that documents and web pages from your
web server, your domain, HTTP, your protocol, your port,

00:10:31.370 --> 00:10:33.820
they are the only ones who can get at this data.

00:10:33.820 --> 00:10:39.970
So if you set a Key/Value pair item, you
will be the only one who can get at it later.

00:10:39.970 --> 00:10:45.470
It comes in two varieties, which I'll
go into a little more detail on shortly.

00:10:45.470 --> 00:10:47.779
The SessionStorage and LocalStorage.

00:10:47.779 --> 00:10:55.429
They attack two different problems, and together
they really replace both plug-ins and cookies

00:10:55.429 --> 00:11:00.139
for manipulating any simple data you
have to throw at your application.

00:11:00.139 --> 00:11:02.539
And finally, it has some events.

00:11:02.539 --> 00:11:08.149
So you can listen to changes in the keys
and the values in different documents

00:11:08.149 --> 00:11:12.029
different frames, and really keep things in sync.

00:11:12.029 --> 00:11:14.679
So what are these two mysterious
things I've touched on a couple

00:11:14.679 --> 00:11:18.909
of times now, the SessionStorage and the LocalStorage.

00:11:18.909 --> 00:11:25.809
These are the two objects that you'll access
in script to get at the Key/Value storage API.

00:11:25.809 --> 00:11:28.000
Each of them does something different.

00:11:28.000 --> 00:11:29.789
SessionStorage.

00:11:29.789 --> 00:11:33.299
Now I was booking a vacation earlier this year.

00:11:33.299 --> 00:11:34.849
I had a couple of weeks off.

00:11:34.850 --> 00:11:38.790
I wanted to go to Boston, I wanted to
go to Paris, I wanted to go to London.

00:11:38.789 --> 00:11:43.889
I opened up my favorite travel web site in a couple
different browser Windows, found the perfect flight to Paris

00:11:43.889 --> 00:11:50.039
in one, the perfect flight to London in the other, and
then I clicked purchase on both and checked my e-mail

00:11:50.039 --> 00:11:54.339
and I was the proud owner of two tickets to Paris.

00:11:54.340 --> 00:11:55.580
What happened?

00:11:55.580 --> 00:11:58.530
What happened was they were using
cookies to manage my session.

00:11:58.529 --> 00:12:02.600
Now a lot of the time this is important to manage
a session between the browser and the server.

00:12:02.600 --> 00:12:06.550
But when the session is only important
within the browser, they're overkill,

00:12:06.549 --> 00:12:10.379
and they have this fundamental
problem is that they're global.

00:12:10.379 --> 00:12:14.679
So SessionStorage replaces cookies for
session tracking, and the way it does this is

00:12:14.679 --> 00:12:19.219
by giving you one session per browser
window per browser or tap.

00:12:19.220 --> 00:12:21.690
So I would have gotten one ticket
to Paris, one ticket to London.

00:12:21.690 --> 00:12:26.730
I would have been on my way for two weeks of
fun instead of one week of the same fun twice.

00:12:26.730 --> 00:12:37.960
And the LocalStorage object is using the same API to
persistently pin down some data inside of the browser.

00:12:37.960 --> 00:12:41.759
It is persistent on the disc, on the Flash device.

00:12:41.759 --> 00:12:42.590
It is global.

00:12:42.590 --> 00:12:48.960
SessionStorage is per browser tab or window,
LocalStorage is accessible in every browser tab or window.

00:12:48.960 --> 00:12:51.230
Quite deliberately.

00:12:51.230 --> 00:12:53.389
So how do we use it.

00:12:53.389 --> 00:12:57.850
SessionStorage, for example here,
the exact same API for LocalStorage.

00:12:57.850 --> 00:12:59.080
Call set item.

00:12:59.080 --> 00:13:03.690
First argument is the key, second argument is the value.

00:13:03.690 --> 00:13:10.150
Or you can use array property access in JavaScript that
you're probably familiar with to do the same thing.

00:13:10.149 --> 00:13:14.169
The key inside the brackets equals the value.

00:13:14.169 --> 00:13:18.689
Or.property access, if it's a static
property that you know beforehand.

00:13:18.690 --> 00:13:21.840
All these three statements right
here do the exact same thing.

00:13:21.840 --> 00:13:28.190
Just integrates right into the language,
getting at an item, exact same thing in reverse.

00:13:28.190 --> 00:13:34.440
You can iterate over all the items
in either the SessionStorage

00:13:34.440 --> 00:13:39.630
or LocalStorage object using a
standard JavaScript loop, four loop.

00:13:39.629 --> 00:13:46.049
You can use get item here or the bracket property access.

00:13:46.049 --> 00:13:51.399
You can remove items with removeItem,
or built right into the language,

00:13:51.399 --> 00:13:53.569
go ahead and delete the property off the object.

00:13:53.570 --> 00:13:58.379
You can clear the entire thing out in
one fell swoop with the clear method.

00:13:58.379 --> 00:13:59.519
And that's it.

00:13:59.519 --> 00:14:06.509
We're on our way, storing simple Key/Value
pair nuggets of data in our user's browser.

00:14:10.190 --> 00:14:14.130
Now there's the events I mentioned
earlier, they're kind of cool.

00:14:14.129 --> 00:14:18.929
They help you keep tabs and windows in sync,
like I side, whether it's within one tab

00:14:18.929 --> 00:14:22.609
or window for SessionStorage, or
over all of them for LocalStorage.

00:14:22.610 --> 00:14:25.539
They set whenever any item changes.

00:14:25.539 --> 00:14:28.599
So when you set a new item, when
you change it, when you delete it.

00:14:28.600 --> 00:14:31.940
And it's sent out to keep different documents in sync.

00:14:31.940 --> 00:14:37.690
And it's sent to all the documents that are
open in the web browser with the same origin,

00:14:37.690 --> 00:14:41.770
the same domain that you control,
that your web app is served from.

00:14:41.769 --> 00:14:47.259
And like I mentioned, with SessionStorage it's sent to
each frame in the current page within the current session.

00:14:47.259 --> 00:14:54.610
And with LocalStorage, to every frame in every
page, because everyone can get at LocalStorage.

00:14:54.610 --> 00:15:01.110
The event has -- oh, I'm sorry, to listen to the event
at event listener, the name of the event is storage.

00:15:01.110 --> 00:15:04.870
Or you can go ahead and use the on
storage attribute on the body element.

00:15:04.870 --> 00:15:11.039
And once you have the event it has everything
you need to know about what happened.

00:15:11.039 --> 00:15:16.730
The new key -- I'm sorry, the key, the old value,
the new value, and then you can find out a little bit

00:15:16.730 --> 00:15:19.009
about where the event was generated from.

00:15:19.009 --> 00:15:25.350
And that's it for the entire API and the entire
event system, SessionStorage and LocalStorage.

00:15:25.350 --> 00:15:28.120
It's so simple to use, builds right into the language.

00:15:28.120 --> 00:15:29.210
It's a great tool.

00:15:29.210 --> 00:15:34.290
To show you a demo of something that we've been working on,

00:15:34.289 --> 00:15:38.009
I'd like to invite my esteemed
colleague Beth Dakin up on stage.

00:15:38.009 --> 00:15:43.419
[ Applause ]

00:15:43.419 --> 00:15:45.870
>> Thanks Brady, that was great.

00:15:45.870 --> 00:15:49.750
So Brady and I love playing checkers.

00:15:49.750 --> 00:15:51.460
We play whenever we have free time.

00:15:51.460 --> 00:15:58.330
We play on evenings, weekends, we play on lunch
breaks, holidays, we are 24-7 checkers playing fiends.

00:15:58.330 --> 00:16:02.550
So we decided to get together and write
a little checkers web application.

00:16:02.549 --> 00:16:07.549
So I'm going to show you what we have, and I'm going to
tell you how we want to enhance it with LocalStorage.

00:16:07.549 --> 00:16:10.289
So let me see.

00:16:10.289 --> 00:16:12.110
There we go.

00:16:17.129 --> 00:16:20.419
OK, so here's our checkers application.

00:16:20.419 --> 00:16:21.839
And I'll give you a little tour.

00:16:21.840 --> 00:16:24.660
Down here we have turn indicator lights.

00:16:24.659 --> 00:16:28.740
So I'm blue and I go first, and the computer is green.

00:16:28.740 --> 00:16:30.580
And then we have a few buttons down here.

00:16:30.580 --> 00:16:34.139
The first button is a New Game button
to start a new game at any point.

00:16:34.139 --> 00:16:40.600
And then these other two buttons represent the LocalStorage
features that we want to add to our web application.

00:16:40.600 --> 00:16:46.470
First is the Manage Games button, which will
autosave games as we play using LocalStorage,

00:16:46.470 --> 00:16:48.649
so they will be saved locally on the machine.

00:16:48.649 --> 00:16:52.990
And you can manually save a game at any
point and have a copy stored locally.

00:16:52.990 --> 00:16:57.779
And then the High Scores button will keep
track of high scores as you play over time.

00:16:57.779 --> 00:17:03.169
So you will have a copy of that data, and
you can see how you improve over time.

00:17:03.169 --> 00:17:10.970
So the game itself, we made it kind of extra fun
with these CSS -- sweet, achievement unlocked.

00:17:10.970 --> 00:17:17.710
We made it extra fun with all these CSS things
and -- oh man, that was such a stupid move.

00:17:17.710 --> 00:17:23.110
Brady, I wish that we had implemented saved games already so
I wouldn't have to look like an idiot in front of everybody.

00:17:23.109 --> 00:17:25.589
I was playing earlier today and I was doing so well.

00:17:25.589 --> 00:17:29.099
>> OK, so Beth, actually last night after
we finished playing, like, at midnight,

00:17:29.099 --> 00:17:32.919
and we had gone for three hours playing checkers,
I actually took a few minutes before going to bed

00:17:32.920 --> 00:17:35.019
and actually implemented the Auto Save feature.

00:17:35.019 --> 00:17:35.930
>> No way.

00:17:35.930 --> 00:17:41.150
>> So your game from earlier today might actually be there.

00:17:41.150 --> 00:17:42.019
>> Oh my God.

00:17:42.019 --> 00:17:42.750
There it is.

00:17:42.750 --> 00:17:44.509
From 10:56 this morning.

00:17:44.509 --> 00:17:47.470
And here is an autosaved game from me playing just now.

00:17:47.470 --> 00:17:48.990
That is so sweet.

00:17:48.990 --> 00:17:50.180
How did you do it, Brady?

00:17:50.180 --> 00:17:51.190
>> Well, you've got the code.

00:17:51.190 --> 00:17:52.809
I think you probably know where I implemented it.

00:17:52.809 --> 00:17:53.909
Go check it out.

00:17:53.910 --> 00:17:55.870
>> True, true.

00:17:57.619 --> 00:18:04.229
OK, so I'm guessing that Brady did
this in our game_manager.JS file.

00:18:04.230 --> 00:18:10.630
And yes, sure enough he fleshed out our save
and restore functions which were empty before.

00:18:10.630 --> 00:18:14.520
And you can see it was this simple for him to save a game.

00:18:14.519 --> 00:18:18.799
He just had to add a few Key/Value
pairs to the LocalStorage object.

00:18:18.799 --> 00:18:21.159
Just enough data to fully restore a game.

00:18:21.160 --> 00:18:27.890
So you know, the first one you can see is he takes
player 0 and stores an array of the positions of all

00:18:27.890 --> 00:18:29.890
of the board pieces, the checkers, at that time.

00:18:29.890 --> 00:18:34.790
And then a few other pieces of information, like the
same data for player 1, enough data to restore the game.

00:18:34.789 --> 00:18:40.930
And then the restore function just retrieves
that information from the LocalStorage object,

00:18:40.930 --> 00:18:46.750
and does the right thing with all of our member
variables to get everything in the right state.

00:18:46.750 --> 00:18:48.950
So let's load that game.

00:18:48.950 --> 00:18:52.059
I was doing really well.

00:18:52.059 --> 00:18:59.000
Yes! All right, and now just to show you
-- I can manually save this game too.

00:18:59.000 --> 00:19:02.039
So now I have another copy of it there.

00:19:02.039 --> 00:19:08.079
And I'm just going to play a little checkers.

00:19:08.079 --> 00:19:11.679
And I won.

00:19:14.259 --> 00:19:14.379
Yes!

00:19:14.380 --> 00:19:15.720
[ Applause ]

00:19:15.720 --> 00:19:21.250
>> OK, so you can see that here this
immediately brought me to the High Scores page.

00:19:21.250 --> 00:19:26.180
And it put in my awesome game data for me to remember.

00:19:26.180 --> 00:19:29.880
But we haven't implemented high scores
yet, unless Brady did that last night too.

00:19:29.880 --> 00:19:31.680
>> I had to go to sleep and be refreshed.

00:19:31.680 --> 00:19:32.810
>> I didn't think so.

00:19:32.809 --> 00:19:37.879
So as soon as I close this window or navigate
away from the page, open a new window,

00:19:37.880 --> 00:19:41.780
go back to my checkers game, that data is lost.

00:19:41.779 --> 00:19:45.910
So let's implement high scores right now, shall we?

00:19:45.910 --> 00:19:49.950
So I'm going to go to my high scores.JS file.

00:19:49.950 --> 00:19:55.080
Here we're doing all this stuff to pop
up the panel that contains all the data.

00:19:55.079 --> 00:20:00.339
But right now as you saw, that data
is lost once we start a new session.

00:20:00.339 --> 00:20:02.649
So set score.

00:20:02.650 --> 00:20:04.730
Let's do that first.

00:20:04.730 --> 00:20:06.509
Have it over here.

00:20:06.509 --> 00:20:13.319
OK, so here we just have a very small function, again,

00:20:13.319 --> 00:20:16.720
where returning early for browsers
that don't support LocalStorage.

00:20:16.720 --> 00:20:19.190
That's just a good backwards compatible move.

00:20:19.190 --> 00:20:24.890
And then down here we're just storing the
name and score in the LocalStorage object,

00:20:24.890 --> 00:20:28.670
and then load score which will be
called wherever we show that panel,

00:20:28.670 --> 00:20:33.950
the high scores panel, we just need to retrieve that data.

00:20:35.529 --> 00:20:37.730
There we go.

00:20:37.730 --> 00:20:40.509
So let's see this in action.

00:20:40.509 --> 00:20:43.990
Oops. Let's refresh my board.

00:20:43.990 --> 00:20:53.339
Let's go back to that sweet game.

00:20:53.339 --> 00:21:02.859
I'm going to try to save this again.

00:21:02.859 --> 00:21:13.009
OK, now if I close the window, open it again, go back to
checkers, then my high score is saved for all eternity.

00:21:13.009 --> 00:21:16.220
[ Applause ]

00:21:16.220 --> 00:21:17.630
>> And you know, that's all.

00:21:17.630 --> 00:21:22.220
Just to implement those two really cool features, to add
them to my web application, just a few lines of code.

00:21:22.220 --> 00:21:25.100
So back to slides.

00:21:25.099 --> 00:21:25.699
Thanks, Brady.

00:21:25.700 --> 00:21:26.970
>> Thank you very much, Beth.

00:21:26.970 --> 00:21:29.569
So that was pretty cool.

00:21:29.569 --> 00:21:34.700
So now that we have those implemented, when we're
playing one on one we can compare our results later

00:21:34.700 --> 00:21:37.559
and continue the argument about whose better at checkers.

00:21:37.559 --> 00:21:42.929
So -- so what Beth showed you is that LocalStorage
just integrates right into the language.

00:21:42.930 --> 00:21:46.210
We used a few different forms of accessing LocalStorage.

00:21:46.210 --> 00:21:50.579
I prefer the array property access.

00:21:50.579 --> 00:21:51.549
They all work the same.

00:21:51.549 --> 00:21:56.460
But it just builds right into JavaScript.

00:21:56.460 --> 00:21:59.529
And really, we're saving the application state locally.

00:21:59.529 --> 00:22:00.509
That's the key.

00:22:00.509 --> 00:22:05.839
The high scores, the saved games, where
the user is in the middle of the game.

00:22:05.839 --> 00:22:11.169
We can quit the browser, come back, it's
stored there in a predictable way on the disc,

00:22:11.170 --> 00:22:14.900
it was all done just using straight forward JavaScript.

00:22:14.900 --> 00:22:17.660
That is Key/Value storage in a nut shell.

00:22:17.660 --> 00:22:22.580
New HTML 5 standard, standard way
to manipulate data in the browser.

00:22:22.579 --> 00:22:27.879
But some of you have different kinds of data.

00:22:27.880 --> 00:22:30.130
More complex data.

00:22:30.130 --> 00:22:33.150
You have data with structure.

00:22:33.150 --> 00:22:38.700
You have relational data and you
have massive amounts of data.

00:22:38.700 --> 00:22:41.009
So what can we give you?

00:22:41.009 --> 00:22:45.609
We can give you the HTML 5 structured databases.

00:22:45.609 --> 00:22:56.439
These are a database inside of the web browser
that you can use to store complex data off line.

00:22:57.630 --> 00:23:00.000
For example, let's take a look at a calendar.

00:23:00.000 --> 00:23:03.799
This is one type of data we might
want to enhance using databases.

00:23:03.799 --> 00:23:06.970
We have a lot of different events,
each event has a lot of rich data.

00:23:06.970 --> 00:23:13.460
We have relationships between the events, we want to select
from different calendars for different types of views.

00:23:13.460 --> 00:23:16.200
This is a Mobile Me calendar,
it does not have this feature.

00:23:16.200 --> 00:23:19.980
But last year we implemented an off line calendar.

00:23:19.980 --> 00:23:22.880
It's available on webkit.org if
you guys want to check it out.

00:23:22.880 --> 00:23:23.820
It does have this feature.

00:23:23.819 --> 00:23:30.200
We're storing calendar data off line and
it's just really easy to enhance features

00:23:30.200 --> 00:23:33.090
of the calendar by using database queries on the data.

00:23:33.089 --> 00:23:38.629
And it's all written in the same
JavaScript most of you are familiar with.

00:23:38.630 --> 00:23:39.860
A mail application.

00:23:39.859 --> 00:23:47.669
Another type of data that would -- is commonly used
in a web application that could be enhanced by storing

00:23:47.670 --> 00:23:52.600
or caching a local copy of the
data inside of the user's browser.

00:23:52.599 --> 00:23:57.769
So structured databases HTML 5
standard way to do all of that.

00:23:57.769 --> 00:24:00.629
And it is real-world SQL.

00:24:00.630 --> 00:24:06.970
The same SQL that you're used to using -- many of
you anyway, are used to using on your web servers

00:24:06.970 --> 00:24:09.539
in applications using database programming.

00:24:09.539 --> 00:24:15.430
It is the real world SQL that you're familiar with.

00:24:15.430 --> 00:24:17.779
Is asynchronous and callback-based.

00:24:17.779 --> 00:24:21.170
Remember, two things are very important to us.

00:24:21.170 --> 00:24:25.100
I'm sorry -- one thing that is
very important to us was the speed.

00:24:25.099 --> 00:24:31.659
Was making sure that the user never feels our
pain as developers of wrangling lots of data.

00:24:31.660 --> 00:24:35.880
So the way we achieved that with the database
API is by making everything callback based.

00:24:35.880 --> 00:24:41.010
So it's running in the background while your user
continue to interact with your web application.

00:24:41.009 --> 00:24:47.619
It has the same origin-based security, that
is the standard security model on the web.

00:24:47.619 --> 00:24:50.399
And that is very explicitly defined
in the Key/Value storage.

00:24:50.400 --> 00:24:55.680
This means the same thing, documents from
your domain have their own set of databases

00:24:55.680 --> 00:25:00.860
that they can access and no one else can touch them.

00:25:00.859 --> 00:25:04.909
So I kind of tried to reiterate on this point a little bit.

00:25:04.910 --> 00:25:07.650
What do I mean by real world SQL.

00:25:07.650 --> 00:25:08.880
I mean real world SQL.

00:25:08.880 --> 00:25:10.710
There are tables.

00:25:10.710 --> 00:25:12.529
There are rows of data.

00:25:12.529 --> 00:25:19.579
There's definitely indexes, you bet there's
triggers, and there are transactions.

00:25:19.579 --> 00:25:20.829
They're built into the API.

00:25:20.829 --> 00:25:24.230
We do not let you forget about the transactions.

00:25:24.230 --> 00:25:28.799
They're important to keep things fast and
keep things efficient and the database small.

00:25:28.799 --> 00:25:34.559
So what are some advantages of storing our data locally.

00:25:34.559 --> 00:25:38.529
Well, first off, it works off line, right?

00:25:38.529 --> 00:25:41.809
That's the key of this talk, the off line data aspect.

00:25:41.809 --> 00:25:46.609
A lot of the time, in fact, most of the time, table,
it's still going to be very important to ship data back

00:25:46.609 --> 00:25:52.019
to a server that you can control, so it's
accessible from multiple places, multiple browsers.

00:25:52.019 --> 00:25:56.980
But I bet a lot of you can find a lot
of ways where it makes sense to store

00:25:56.980 --> 00:26:00.160
and cache a local copy of the data inside of the browser.

00:26:00.160 --> 00:26:02.570
And that data will be available off line.

00:26:02.569 --> 00:26:06.759
You won't need a network connection to
any server to get at all this rich data.

00:26:06.759 --> 00:26:11.589
What about some performance enhancements
we get from doing this.

00:26:11.589 --> 00:26:15.179
By keeping the data local we get a great speed boost.

00:26:15.180 --> 00:26:21.820
For a lot of the time when we just need to cache data, or
just need to perform a local query on data that makes sense

00:26:21.819 --> 00:26:25.799
that we have cached locally, when we
take the network out of the equation,

00:26:25.799 --> 00:26:30.960
that's just a fantastic boon for
performance and responsiveness.

00:26:30.960 --> 00:26:33.559
Take the latency out of the question.

00:26:33.559 --> 00:26:35.480
And for battery life.

00:26:35.480 --> 00:26:40.960
We have notebooks, we have the iPhone, and
other mobile devices that support this.

00:26:40.960 --> 00:26:42.789
Take the network out, take the radio out.

00:26:42.789 --> 00:26:44.109
That's fantastic.

00:26:44.109 --> 00:26:53.019
And in the cases where it makes sense to cache some of the
data locally inside of the browser, there's less complexity.

00:26:53.019 --> 00:26:56.599
We don't have to set up a connection to
the server using your favorite flavor

00:26:56.599 --> 00:27:00.159
of connection, be it a host or an XMLHttpRequest.

00:27:00.160 --> 00:27:04.070
Taking that out of the equation and
just running the SQL right on the --

00:27:04.069 --> 00:27:09.950
right on your user's machine can help take
a little complexity out of the equation.

00:27:09.950 --> 00:27:13.620
So back to the mail example.

00:27:13.619 --> 00:27:19.989
You know, I ride the train to work many mornings,
and a lot of the times there's no network connection,

00:27:19.990 --> 00:27:24.990
be it on my phone because we're going through
tunnels or we're in the middle of the wilderness,

00:27:24.990 --> 00:27:27.460
the trains around here don't necessarily have Wi-Fi yet.

00:27:27.460 --> 00:27:29.220
It's sad, being Silicon Valley and all.

00:27:29.220 --> 00:27:30.640
But it's coming.

00:27:30.640 --> 00:27:35.009
But until then, I want to download
my mail at home, hit the train,

00:27:35.009 --> 00:27:39.059
and then be able to compose replies
on the way to work, for example.

00:27:39.059 --> 00:27:42.889
Very important replies, about pictures
of cute puppies and kittens.

00:27:42.890 --> 00:27:50.740
So let's talk through how we might augment a
mail web application to do something like this.

00:27:50.740 --> 00:27:55.089
The first -- this is just going to be a
scrape of the surface of the database API.

00:27:55.089 --> 00:27:59.049
But we're just going to walk through
the workflow of how you might use it.

00:27:59.049 --> 00:28:00.990
So first we're going to need a database handle

00:28:00.990 --> 00:28:04.900
This is the entry point into the HTML 5 database's API.

00:28:04.900 --> 00:28:09.720
There's an open database method on the window,
called an openDatabase with a few nuggets of data,

00:28:09.720 --> 00:28:13.470
and you have a database handle ready to go.

00:28:13.470 --> 00:28:19.509
The important piece of data here for all of you who just
want to cut to the chase is the name of your database.

00:28:19.509 --> 00:28:24.379
Your origin, your dmain that you
control has its own set of databases.

00:28:24.380 --> 00:28:29.820
And you can create individual named
databases within that set.

00:28:29.819 --> 00:28:32.579
So here we're going to go ahead and call it off line mail.

00:28:32.579 --> 00:28:37.599
So we have our off line mail database handle.

00:28:37.599 --> 00:28:44.559
The entry point into actually doing something with
our database handle is the transaction method.

00:28:44.559 --> 00:28:47.109
Like I said, transactions are built into the API.

00:28:47.109 --> 00:28:48.919
We do not let you ignore them.

00:28:48.920 --> 00:28:51.620
And they are how you get things done.

00:28:51.619 --> 00:28:54.879
And this is also the first time you're going
to see the callbacks I was calling about.

00:28:54.880 --> 00:28:57.460
This API is asynchronous and callback-based.

00:28:57.460 --> 00:29:05.319
So you will often be passing in JavaScript functions as
callbacks for the browser to notify when certain parts

00:29:05.319 --> 00:29:09.210
of the database operation are progressing or complete.

00:29:09.210 --> 00:29:10.279
The most important one here.

00:29:10.279 --> 00:29:13.440
You can go ahead and ignore the
error callback or the completion one.

00:29:13.440 --> 00:29:15.900
The most important one is the transaction callback.

00:29:15.900 --> 00:29:21.170
When you call database stop transaction you're getting a
transaction object that is a guarantee that you're ready

00:29:21.170 --> 00:29:24.890
to go, performing SQL queries inside the database.

00:29:24.890 --> 00:29:29.550
Here's an example of a transaction callback.

00:29:29.549 --> 00:29:32.259
Given the transaction object.

00:29:32.259 --> 00:29:34.960
I have some SQL to run.

00:29:34.960 --> 00:29:40.590
And now for the first time in this chain of
events I am actually running an SQL query inside

00:29:40.589 --> 00:29:42.919
of the browser using JavaScript.

00:29:42.920 --> 00:29:48.680
I'm going to go ahead and create a messages
table in my off line mail database here.

00:29:50.769 --> 00:29:55.099
There is an alternate form of SQL for arguments.

00:29:55.099 --> 00:30:01.619
As you know, the database sanitization considerations, a
lot of the time we want to put place holders in our query,

00:30:01.619 --> 00:30:03.399
we use question marks for the place holders.

00:30:03.400 --> 00:30:05.470
That's written into the standard.

00:30:05.470 --> 00:30:10.130
And then for each question mark you have, you
pass in an array of arguments and each member

00:30:10.130 --> 00:30:12.950
of the array replaces one of the question marks.

00:30:12.950 --> 00:30:15.850
So now we're actually putting a message into our database.

00:30:15.849 --> 00:30:23.699
We need to get stuff out of the database, of course.

00:30:23.700 --> 00:30:27.390
And the way you do that is with the
very important statement callback.

00:30:27.390 --> 00:30:30.960
This is another form of SQL, and
when you expect to get results out,

00:30:30.960 --> 00:30:32.930
you need to pass in a statement callback function.

00:30:32.930 --> 00:30:39.509
When that SQL statement is done executing,
this callback will be called with the results

00:30:39.509 --> 00:30:42.950
that were pulled out of the database, if there were any.

00:30:42.950 --> 00:30:47.500
And it also gives you a chance to continue
a chain of statements in this transaction.

00:30:47.500 --> 00:30:50.950
So that's it.

00:30:50.950 --> 00:30:55.200
Like I said, I was scraping the
surface of how the database API works.

00:30:55.200 --> 00:30:59.130
It is a rich API, and I just want
to give you a sense of the flow.

00:30:59.130 --> 00:31:04.640
To really understand it and to get to know
it well, it's great to look at examples.

00:31:04.640 --> 00:31:07.430
This is the off line calendar that we implemented last year.

00:31:07.430 --> 00:31:10.420
It's now available on webkit.org.

00:31:10.420 --> 00:31:13.930
And it has a lot of great code you can look at.

00:31:13.930 --> 00:31:20.440
This is all what has now become a semi famous example, the
sticky notes, which is probably overkill for database usage.

00:31:20.440 --> 00:31:25.900
But that makes it a great educational example because it's
really simple to see where the database operations fit

00:31:25.900 --> 00:31:29.740
in to just creating and editing sticky notes.

00:31:29.740 --> 00:31:35.630
Now many of you that are familiar with database
programming sometimes like to get down to the metal

00:31:35.630 --> 00:31:39.560
and log into the database and just run queries directly.

00:31:39.559 --> 00:31:44.609
Not in code, just tinker around in
the database and know what's going on.

00:31:44.609 --> 00:31:47.639
And Safari's great web inspector will let you do that.

00:31:47.640 --> 00:31:50.580
In the web inspector there's this -- let me back up there.

00:31:50.579 --> 00:31:52.079
There's this databases panel.

00:31:52.079 --> 00:31:55.179
Any time you are at a page that has databases you can go in

00:31:55.180 --> 00:31:59.390
and click on the databases tab
and see what's going on there.

00:31:59.390 --> 00:32:05.690
It will just give you a view of the first
few rows in the database to see what the --

00:32:05.690 --> 00:32:09.350
what the rows in the table are,
what data is in there right now.

00:32:09.349 --> 00:32:11.299
It's pretty cool.

00:32:11.299 --> 00:32:15.809
And then like I said, you want to get down
to the metal and run some SQL queries,

00:32:15.809 --> 00:32:17.319
and the inspector will let you do that too.

00:32:17.319 --> 00:32:21.009
You can see here, we're playing around
with our Web Kit sticky notes example,

00:32:21.009 --> 00:32:25.740
and we're just poking around in the
database, just like any other SQL database.

00:32:25.740 --> 00:32:27.120
Pretty cool stuff.

00:32:27.119 --> 00:32:33.959
So that was an overview of the HTML 5 structured databases.

00:32:33.960 --> 00:32:37.779
Like I said, those great examples are great to look at.

00:32:37.779 --> 00:32:43.950
And you can look at the documentation to
really flesh out your understanding of it.

00:32:43.950 --> 00:32:51.529
But it is a standard way, HTML 5 standard way to manipulate
structured relational data inside the web browser.

00:32:51.529 --> 00:32:56.839
Some of you might be asking yourselves
well, what else can I store off line.

00:32:56.839 --> 00:33:02.049
I'm storing simple Key/Value nuggets
of data with using LocalStorage,

00:33:02.049 --> 00:33:05.750
and I'm storing rich structured
data using the databases API.

00:33:05.750 --> 00:33:08.450
Is there anything else I could do.

00:33:08.450 --> 00:33:10.970
And there's something very important you could do.

00:33:10.970 --> 00:33:14.970
And that is the HTML 5 application cache.

00:33:14.970 --> 00:33:21.799
The application cache has really caught on since we
introduced it in the Safari 4 developer preview last year,

00:33:21.799 --> 00:33:24.009
and other browsers are starting to implement it.

00:33:24.009 --> 00:33:25.150
It's a fantastic idea.

00:33:25.150 --> 00:33:30.480
It's storing all of the different resources
that make up your application off line.

00:33:30.480 --> 00:33:39.130
The mark up, the style, the scripting, the images and
other media, storing them in a reliable manner inside

00:33:39.130 --> 00:33:43.120
of the web browser, so that the web browser
knows how to load your web application,

00:33:43.119 --> 00:33:46.279
even when the network is completely absent.

00:33:49.799 --> 00:33:54.819
The application cache requires you to
put together a manifest of resources.

00:33:54.819 --> 00:33:58.579
It's a list of all the different
URLs that go into your application.

00:33:58.579 --> 00:34:07.740
That's a new object that you can poke at and tinker
with to monitor how the application cache is working.

00:34:07.740 --> 00:34:13.219
It's -- it's a simple object, but it gives you some
important insight as to how the mechanism is working.

00:34:13.219 --> 00:34:17.299
I'll touch on that a little more later.

00:34:17.300 --> 00:34:21.840
And importantly, to me, anyway, and a lot
of the developers that we've heard from,

00:34:21.840 --> 00:34:27.329
the application cache has an automated
atomic update mechanism.

00:34:27.329 --> 00:34:32.869
Automatically, when a network connection is available, the
web browser will go to your web server in the background,

00:34:32.869 --> 00:34:37.409
see if there's an update to your web application,
and start downloading it in the background.

00:34:37.409 --> 00:34:41.819
And then when it's time, it will
perform the update atomically.

00:34:41.820 --> 00:34:48.809
In college, a lot of times I was editing really complex
web sites and you know, refresh things in the browser,

00:34:48.809 --> 00:34:53.739
and things were all broken to hell, because it got
Version 1 of one file, but Version 2 of another file.

00:34:53.739 --> 00:34:56.809
Application cache would love to
just get rid of that problem.

00:34:56.809 --> 00:35:00.809
The updates will be atomic in a predictable manner.

00:35:00.809 --> 00:35:08.099
And finally there's also a mechanism
to monitor on line and off line status.

00:35:08.099 --> 00:35:14.699
So you know when you have that network connection and
when you definitely don't have that network connection.

00:35:14.699 --> 00:35:17.719
Because a lot of the time, a web
application why trying to behave

00:35:17.719 --> 00:35:22.619
like a full-fledged first-class citizen
desktop application really would

00:35:22.619 --> 00:35:25.529
like to change its behavior based
on whether it's online or off line.

00:35:25.530 --> 00:35:29.170
Present a different UI, take certain
features in, certain features out.

00:35:29.170 --> 00:35:31.720
So now we can start to do that in a pretty cool way.

00:35:31.719 --> 00:35:35.500
So this resource manifest.

00:35:35.500 --> 00:35:36.510
Let me get back on this.

00:35:36.510 --> 00:35:39.640
This is a pretty important part of things.

00:35:39.639 --> 00:35:41.829
It is a text file.

00:35:41.829 --> 00:35:49.789
It is a text file that has a list of every
URL your application needs to operate.

00:35:49.789 --> 00:35:55.860
When you're using the application cache mechanism you're
opting into an alternate loading behavior of the browser.

00:35:55.860 --> 00:36:00.160
The standard loading model does not apply any longer.

00:36:00.159 --> 00:36:05.710
And one important thing here is that every
URL your application will ever need needs

00:36:05.710 --> 00:36:07.610
to be listed in the cache manifest.

00:36:07.610 --> 00:36:13.539
With many applications that have been
constructed with modern web practices

00:36:13.539 --> 00:36:16.029
and the future of the web in mind, this is easy.

00:36:16.030 --> 00:36:19.269
Sometimes it will require reworking
the application a little.

00:36:19.269 --> 00:36:21.480
But it is important that you list every URL.

00:36:21.480 --> 00:36:26.409
Any URL that's not listed in the manifest will
not be accessible from your web application.

00:36:26.409 --> 00:36:35.349
As two types of entries, the explicit entries, these are
the cached entries, these are the things we know we want

00:36:35.349 --> 00:36:39.519
to store off line, to be available
all of the time no matter what.

00:36:39.519 --> 00:36:43.869
And then it has the online white list entries.

00:36:43.869 --> 00:36:46.380
Because we usually do have a network connection.

00:36:46.380 --> 00:36:52.619
And we do have to list every URL that our application
might need, we need to list the URLs that should always go

00:36:52.619 --> 00:36:55.690
to the network, so they are accessible
to our web application.

00:36:55.690 --> 00:37:00.530
Here's a sample manifest file.

00:37:00.530 --> 00:37:04.730
You always start it off with the
big all caps phrase cache manifest.

00:37:04.730 --> 00:37:07.059
And then you just start listing URLs.

00:37:07.059 --> 00:37:09.239
Here's the cache section, this is the explicit section.

00:37:09.239 --> 00:37:10.659
Also, it's the default section

00:37:10.659 --> 00:37:12.639
You can leave cache off if you want to.

00:37:12.639 --> 00:37:17.489
You can see here I have a relative
URL, I've got a fully qualified URL.

00:37:17.489 --> 00:37:21.219
I've got a few different kinds of
resources that make up the application.

00:37:21.219 --> 00:37:24.509
And I can even grab an off site URL if I'd like.

00:37:24.510 --> 00:37:30.250
So any standard web site you could build
here using resources from different domains,

00:37:30.250 --> 00:37:32.760
you can do that using the application cache as well.

00:37:32.760 --> 00:37:39.140
And then we have our network entries, the dynamic things,
the things it doesn't make sense to store off line,

00:37:39.139 --> 00:37:41.929
and we always will need a network connection to use.

00:37:41.929 --> 00:37:46.369
And that's it for the text file, that's a list of URLs.

00:37:46.369 --> 00:37:48.710
How do we get this into play.

00:37:48.710 --> 00:37:55.610
How do we tell the browser, hey, I'm a hot new developer
who is using this great new application cache feature.

00:37:55.610 --> 00:37:58.420
I want you to go ahead and get it
from my server and start using it.

00:37:58.420 --> 00:38:01.610
I introduce to you the HTML element.

00:38:01.610 --> 00:38:09.180
The loneliest of all elements, with no
official specified attributes until now.

00:38:09.179 --> 00:38:12.109
Specify the manifest attribute on your HTML at element.

00:38:12.110 --> 00:38:14.990
Point it to the manifest file on your server.

00:38:14.989 --> 00:38:19.399
And you have now opted into the application cache mechanism.

00:38:19.400 --> 00:38:21.720
With one more caveat.

00:38:21.719 --> 00:38:23.919
You will have to tweak something on your server.

00:38:23.920 --> 00:38:32.980
The server will have to send explicitly the text
cache manifest mime type for the manifest files.

00:38:32.980 --> 00:38:38.300
This is an explicit thing that we're
very deliberate about opting into.

00:38:38.300 --> 00:38:44.760
Which is why this is required in the
spec. So the loading process changes.

00:38:44.760 --> 00:38:46.260
I mentioned this a little while ago.

00:38:46.260 --> 00:38:50.070
What is the new loading process when
you're using the application cache.

00:38:50.070 --> 00:38:54.530
When your users visit your web application,
the URL for your web application,

00:38:54.530 --> 00:38:59.000
the web browser will load all the
resources from the local cache as copied.

00:38:59.000 --> 00:39:03.679
It won't even try to get them from the network.

00:39:03.679 --> 00:39:11.359
However, that automated update process will kick
off the moment they visit your web application.

00:39:11.360 --> 00:39:17.019
Safari will refetch the manifest file
in the background from your web server.

00:39:17.019 --> 00:39:21.500
And if it is changed, it will start
revalidating all the resources

00:39:21.500 --> 00:39:25.099
that it's caching locally off line
and download them as necessary.

00:39:25.099 --> 00:39:33.759
Now when the update is complete, when the new manifest has
been registered and we've downloaded all the new resources

00:39:33.760 --> 00:39:40.250
and we have our own off line copy, you can call
a tiny little JavaScript, which I'll show you,

00:39:40.250 --> 00:39:47.130
to right in place switch your users over
from Version 1 to Version 2 of your app.

00:39:47.130 --> 00:39:52.059
Or the new version will be available
the next time they visit your site.

00:39:54.989 --> 00:39:59.959
So the way you do the atomic update explicitly,
so you can use that application cache object,

00:39:59.960 --> 00:40:05.059
and listen for the on update ready
event, and pass it an event handler,

00:40:05.059 --> 00:40:07.719
and then you just go ahead and call swap cache

00:40:07.719 --> 00:40:12.599
. And now you've just in place slid your users over
from Version 1 to Version 2 of your application.

00:40:12.599 --> 00:40:13.809
It's pretty cool.

00:40:13.809 --> 00:40:20.139
Will -- like I said, will happen automatically if
you don't do that, so you don't even need to do this.

00:40:20.139 --> 00:40:26.079
You can listen to a lot of other progress events
about this automated background update process.

00:40:26.079 --> 00:40:30.590
So in case you want to -- your application is
huge and complex and you want to present a UI,

00:40:30.590 --> 00:40:35.970
or you want to monitor the progress for your
own error handling or statistics gathering,

00:40:35.969 --> 00:40:37.939
you could go ahead and listen to all of these great things.

00:40:37.940 --> 00:40:40.059
I'm not going to go into detail on them now.

00:40:40.059 --> 00:40:44.079
But the documentation on application
cache will tell what they do.

00:40:44.079 --> 00:40:51.119
And then we have these online and off
line events, and the status in general.

00:40:51.119 --> 00:40:53.319
There's window.navigator on line.

00:40:53.320 --> 00:41:00.250
It's a new property on the navigator that will tell
you, hey, am I on line or am I for sure off line.

00:41:00.250 --> 00:41:06.820
Go ahead and add an event listener, in case you want
to monitor as the network connection status changes.

00:41:06.820 --> 00:41:15.940
One use we've seen is when the device, the -- your user's
machine, whether it's an iPhone or a desktop or a notebook,

00:41:15.940 --> 00:41:21.860
when it gets back on line, you'll kick off the
update mechanism manually, even though it's automatic

00:41:21.860 --> 00:41:24.720
when they visit the URL, you can
manually kick it off if you'd like.

00:41:24.719 --> 00:41:27.759
So it's pretty cool.

00:41:27.760 --> 00:41:29.360
That's the application cache.

00:41:29.360 --> 00:41:32.980
A standard way to store all of
the different resources that make

00:41:32.980 --> 00:41:36.719
up your application off line, inside of the web browser.

00:41:36.719 --> 00:41:44.469
Now to show you further augmentation we can do to our way
sweet checkers app, I'd like to invite Beth back on stage.

00:41:44.469 --> 00:41:46.009
Beth?

00:41:46.010 --> 00:41:49.890
[ Applause ]

00:41:49.889 --> 00:41:51.339
>> Thanks, Brady.

00:41:51.340 --> 00:41:52.890
So we have this problem.

00:41:52.889 --> 00:41:59.690
We just made our checkers web application pretty
recently, and it's a lot more popular than we expected.

00:41:59.690 --> 00:42:03.440
And we have kind of a crappy server,
you know, not great bandwidth.

00:42:03.440 --> 00:42:08.700
So we're having this problem where a lot of our
users are complaining to us that there's a lot

00:42:08.699 --> 00:42:11.049
of lag during peak checker playing hours.

00:42:11.050 --> 00:42:15.080
So this is a real problem for us that we want to
address, but we don't really have money to throw

00:42:15.079 --> 00:42:17.909
at the problem right now and get
a better server or anything.

00:42:17.909 --> 00:42:20.960
So we think that a great solution in
the meantime is off line checkers.

00:42:20.960 --> 00:42:27.400
It will make things faster for our users, and they won't
even know what kind of magic we're doing under the covers.

00:42:27.400 --> 00:42:30.099
And really, this isn't a meantime kind of thing.

00:42:30.099 --> 00:42:32.789
This is a really great feature all the time.

00:42:32.789 --> 00:42:36.349
It's great on the desktop, but it's
particularly compelling on the iPhone.

00:42:36.349 --> 00:42:41.619
Because on the iPhone you often find yourself
with a really low bandwidth network situation,

00:42:41.619 --> 00:42:46.719
like on the beach in Barbados, or in a no
network situation, like on the plane to Barbados,

00:42:46.719 --> 00:42:50.259
and in these situations you want
to be able to be playing checkers.

00:42:50.260 --> 00:42:56.170
So let's implement off line checkers right now

00:42:56.170 --> 00:42:57.740
OK, great.

00:42:57.739 --> 00:43:04.559
So as Brady said, we need a manifest
file, which we already put together here.

00:43:04.559 --> 00:43:07.690
And we also already took care of tweaking our server.

00:43:07.690 --> 00:43:15.460
So the one last thing we have to do is include
the manifest attribute in our source file.

00:43:15.460 --> 00:43:17.599
Oops, wrong spot.

00:43:17.599 --> 00:43:19.139
There we go.

00:43:20.170 --> 00:43:21.280
Save that.

00:43:21.280 --> 00:43:25.710
Let's open our checkers game.

00:43:25.710 --> 00:43:26.340
Reload it.

00:43:26.340 --> 00:43:30.240
OK, so the first load was a regular
network load, and this is an off line load,

00:43:30.239 --> 00:43:34.029
and you'll see that I am actually missing a resource here.

00:43:34.030 --> 00:43:40.940
So even though I have network enabled right now, I
must have missed that resource in my manifest file.

00:43:40.940 --> 00:43:43.150
And because I missed it, then it won't load.

00:43:43.150 --> 00:43:47.630
And yes, it looks like I only have
one turn indicator light here.

00:43:47.630 --> 00:43:50.829
And I'm supposed to have another one for player 0.

00:43:50.829 --> 00:43:56.989
So let me fix this.

00:43:56.989 --> 00:43:59.549
Oops. Save that.

00:43:59.550 --> 00:44:00.620
Let's reload.

00:44:00.619 --> 00:44:01.519
There we go.

00:44:01.519 --> 00:44:05.460
So with the reload, I have my turn indicator
light, and I have off line checkers.

00:44:05.460 --> 00:44:08.179
And I can still play with it and everything.

00:44:08.179 --> 00:44:16.389
I can still access all of my saved games,
see my high scores, and it's pretty sweet.

00:44:16.389 --> 00:44:23.269
So now let's take a look at it on the iPhone.

00:44:27.329 --> 00:44:37.880
All right, so first I'll take us into
Safari where we can load it there.

00:44:37.880 --> 00:44:40.809
So here's my checkers game.

00:44:40.809 --> 00:44:43.809
I can play it like always.

00:44:43.809 --> 00:44:47.179
Yes. It's always exciting.

00:44:47.179 --> 00:44:57.089
So -- but now let's check it out in airplane mode.

00:44:58.900 --> 00:45:05.210
And I saved this web application,
so I'm just going to load it again.

00:45:05.210 --> 00:45:08.309
Now fully in airplane mode without any network.

00:45:08.309 --> 00:45:10.670
All right, reload.

00:45:10.670 --> 00:45:19.010
I can still play my checkers game.

00:45:19.010 --> 00:45:22.910
[ Applause ]

00:45:22.909 --> 00:45:28.940
>> I can access all of my features here too.

00:45:28.940 --> 00:45:30.650
And that's it.

00:45:30.650 --> 00:45:37.289
Just editing my HTML in one spot and doing a couple
of other little things, we have off line checkers.

00:45:37.289 --> 00:45:48.420
>> Great, thank you very much, Beth.

00:45:48.420 --> 00:45:49.500
[ Applause ]

00:45:49.500 --> 00:45:56.789
>> So with the way we developed our checkers
application from scratch, it was really just a matter

00:45:56.789 --> 00:46:00.500
of listing all the URLs in a text
file to make it work off line.

00:46:00.500 --> 00:46:02.409
This gives us a few benefits, like Beth said.

00:46:02.409 --> 00:46:08.619
It not only works completely off line, like
in airplane mode, or in low bandwidth mode,

00:46:08.619 --> 00:46:13.289
like on the beach in Barbados, but even
when a network is completely available.

00:46:13.289 --> 00:46:15.190
We're saving server bandwidth, right?

00:46:15.190 --> 00:46:17.809
We're avoiding a hit to the server
for all these different resources,

00:46:17.809 --> 00:46:22.400
no matter what the HTTP caching
mechanism we wanted to put in place was.

00:46:22.400 --> 00:46:25.389
And it's a better loading experience for our users as well.

00:46:25.389 --> 00:46:28.579
Which is exactly what I just said, speeds on line loading.

00:46:28.579 --> 00:46:33.309
And I already said that at the very beginning too.

00:46:33.309 --> 00:46:34.579
Just a few steps to add.

00:46:34.579 --> 00:46:39.009
Now one thing we didn't show in the demo is
we had already tweaked our Apache server.

00:46:39.010 --> 00:46:43.710
So don't think that I said you have to do that, and
then we left it out, so maybe I was lying to you.

00:46:43.710 --> 00:46:45.420
That is important, so we did do that.

00:46:45.420 --> 00:46:50.599
But otherwise, just -- that manifest file, and
we're good to go with our off line checkers.

00:46:50.599 --> 00:46:54.719
That's all I have to talk to you about today.

00:46:54.719 --> 00:46:58.919
Talked a little about the -- little bit
about the current state of data on the web,

00:46:58.920 --> 00:47:02.420
an old problem that we finally have new solutions for.

00:47:02.420 --> 00:47:03.930
And we went over those new solutions.

00:47:03.929 --> 00:47:09.109
The great HTML 5 standard Key/Value storage
integrates into JavaScript beautifully.

00:47:09.110 --> 00:47:17.769
The structured databases which gives you the power of an SQL
database inside of your web application using JavaScript.

00:47:17.769 --> 00:47:19.329
And finally, the application cache.

00:47:19.329 --> 00:47:23.269
A standard way to sort all of the different
resources that make up your application

00:47:23.269 --> 00:47:28.030
in a neat little package that's available off line.

00:47:28.030 --> 00:47:33.630
For more information, I encourage you to look at
the HTML 5 specs for all of these technologies.

00:47:33.630 --> 00:47:38.280
They are kind of spread out over the WG
web site, and the W3C web site right now.

00:47:38.280 --> 00:47:40.610
But here's the URLs for them.

00:47:40.610 --> 00:47:47.220
We'd love to hear from you at the Web Kit open source
project, both to report bugs, to hear how awesome we are,

00:47:47.219 --> 00:47:50.279
to try new nightlies, to interact with the community.

00:47:50.280 --> 00:47:52.480
And those cool demos that I showed you.

00:47:52.480 --> 00:47:59.070
The off line calendar that we implemented, and the Web Kit
sticky notes demo for some great database code examples.

00:47:59.070 --> 00:47:59.870
They're up there.

00:47:59.869 --> 00:48:04.380
And we also expect the checkers
demo to be there pretty soon.

00:48:04.380 --> 00:48:11.070
Vicki Murley is our Safari Technologies Evangelist, if you
have any questions she'd be happy to answer them by e-mail.
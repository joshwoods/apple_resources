WEBVTT

00:00:12.839 --> 00:00:14.589
>> Hi, everybody.

00:00:14.589 --> 00:00:18.050
Welcome to In-House App Development for iPhone.

00:00:18.050 --> 00:00:23.410
I'm assuming there's a lot of IT
people here in the audience.

00:00:23.410 --> 00:00:26.320
We're definitely IT people ourselves.

00:00:26.320 --> 00:00:32.509
We definitely know what this is like, so let's start.

00:00:32.509 --> 00:00:35.179
My name is Steven Cotterill.

00:00:35.179 --> 00:00:38.179
And my colleague Jake Logan and I are going to talk to you

00:00:38.179 --> 00:00:43.359
about developing mobile productivity
applications for your organization.

00:00:43.359 --> 00:00:48.549
And we're going to go over some tips
and best practices that we've found

00:00:48.549 --> 00:00:52.969
in building and deploying those applications, so.

00:00:52.969 --> 00:01:01.839
As I said, we're IT folk, so Jake
and I both work in IT at Apple.

00:01:04.359 --> 00:01:08.780
Excuse me.

00:01:08.780 --> 00:01:14.579
We've actually been working on deploying mobile
applications for Apple employees for several years now.

00:01:14.579 --> 00:01:16.959
We did a lot of research and we've
been some of the first people

00:01:16.959 --> 00:01:21.189
to bring Enterprise applications
to a mobile device for Apple.

00:01:21.189 --> 00:01:23.629
Of course, we started before the iPhone.

00:01:23.629 --> 00:01:29.060
We definitely tried out things like
J2ME first, which was not terribly fun.

00:01:29.060 --> 00:01:32.010
I don't know if any of you have tried it.

00:01:32.010 --> 00:01:33.790
It's not very fun for a couple of reasons.

00:01:33.790 --> 00:01:35.359
One is the technology.

00:01:35.359 --> 00:01:37.370
Technology isn't very well polished.

00:01:37.370 --> 00:01:38.790
It's all very new.

00:01:38.790 --> 00:01:42.930
I know mobile phones have been around, but
mobile phones working or actually doing something

00:01:42.930 --> 00:01:45.270
where they're handling a call,
that's a relatively new concept.

00:01:45.269 --> 00:01:48.979
And so those tools weren't very well refined.

00:01:48.980 --> 00:01:51.900
Plus there was no consistent platform.

00:01:51.900 --> 00:01:53.750
You never knew what you were going to develop for.

00:01:53.750 --> 00:01:58.489
When we did a survey of what devices Apple
employees had that we would need to target,

00:01:58.489 --> 00:02:01.780
we just came up with 50 different
phones that happened to support Java.

00:02:01.780 --> 00:02:07.159
And we didn't have any standards on the size of
the screen or the number of buttons or anything.

00:02:07.159 --> 00:02:10.840
It was pretty miserable actually.

00:02:10.840 --> 00:02:16.460
So we definitely have thought about these concepts,
and we know that you've thought about them too.

00:02:16.460 --> 00:02:20.310
There's the technical challenges that I mentioned,
but there's also the design problems that come

00:02:20.310 --> 00:02:23.420
with bringing applications into the mobile world.

00:02:23.419 --> 00:02:30.849
You have to make sure that whatever you do integrates with
the information technology systems that you already have.

00:02:30.849 --> 00:02:34.669
And you have to make sure that you can
actually deploy these applications to people.

00:02:34.669 --> 00:02:42.199
It's very hard to figure out how to get a J2ME app
to different people without some kind of a store.

00:02:42.199 --> 00:02:48.810
And finally, you have to make sure that while you're
doing this you're keeping your company secrets secure

00:02:48.810 --> 00:02:50.680
and safe, so.

00:02:50.680 --> 00:03:00.280
The one thing that you can't change is the tech--
the one thing that you can change is the technology.

00:03:00.280 --> 00:03:04.300
You can wait for it to get better, and fortunately,
it has gotten better in the last couple of years.

00:03:04.300 --> 00:03:06.610
The dev tools have become much better.

00:03:06.610 --> 00:03:10.370
Many platforms have stores now, and
you can take advantage of those things.

00:03:10.370 --> 00:03:12.950
But the one thing that you can't change is the problem.

00:03:12.949 --> 00:03:17.689
The problem is that you're trying to build
an application to go into the mobile world

00:03:17.689 --> 00:03:22.979
and let your users be connected
when they're not in the office.

00:03:22.979 --> 00:03:26.679
And what we realized was that you can't fix that problem.

00:03:26.680 --> 00:03:28.219
There's nothing you can do to change it.

00:03:28.219 --> 00:03:33.710
We had to actually just stand up and
accept the fact that this is not the place

00:03:33.710 --> 00:03:36.110
that we've been for the last 20 to 30 years.

00:03:36.110 --> 00:03:38.770
This is an entirely new world.

00:03:38.770 --> 00:03:42.570
And everything that we're comfortable with,
everything we've been doing for the desktop

00:03:42.569 --> 00:03:45.680
in our Enterprises is miles and miles and miles away.

00:03:45.680 --> 00:03:47.950
Maybe millions of miles away.

00:03:47.949 --> 00:03:52.679
So once you accept that this is where
you are now, you can move forward.

00:03:52.680 --> 00:04:00.409
What makes this place uncomfortable and
different and new from what you're used to is

00:04:00.409 --> 00:04:03.960
that for one, it's a completely new environment.

00:04:03.960 --> 00:04:08.540
Your application is going to go not onto a
regular computer, like you've been used to.

00:04:08.539 --> 00:04:12.259
It's going to go onto these little handheld computers.

00:04:12.259 --> 00:04:16.259
And you don't know that you're
going to have a very fast processor.

00:04:16.259 --> 00:04:19.629
Actually probably bet that you're not
going to have a very fast processor.

00:04:19.629 --> 00:04:23.480
And you can definitely guarantee that
you're not going to have unlimited power.

00:04:23.480 --> 00:04:25.980
These devices run on batteries.

00:04:25.980 --> 00:04:32.840
Another change, and this is not necessarily a bad
thing, but these devices are not multi-user systems.

00:04:32.839 --> 00:04:44.469
They're actually very much single-user systems, and arguably
the most personal computer that you've ever targeted.

00:04:44.470 --> 00:04:48.300
In addition to this, there are many
more variables in the mobile world.

00:04:48.300 --> 00:04:50.900
Your battery connection could give out.

00:04:50.899 --> 00:04:52.359
Your network connection could give out.

00:04:52.360 --> 00:04:55.830
If you have a network connection, you
have no idea how fast it's going to be.

00:04:55.829 --> 00:04:56.789
It could be Wi-Fi.

00:04:56.790 --> 00:04:57.870
It could be 3G.

00:04:57.870 --> 00:04:59.579
It could 2G.

00:04:59.579 --> 00:05:02.219
It could be no G.

00:05:02.220 --> 00:05:12.400
And this is the really weird one, the mind melter
here, is that in your hand time actually moves slower.

00:05:12.399 --> 00:05:18.899
When a user's out in a park and they pull out their phone
or their mobile device, and they hold it in their hand

00:05:18.899 --> 00:05:25.299
and they're waiting for their email to load,
and the world is passing by right behind them,

00:05:25.300 --> 00:05:33.680
every single solitary second is an eternity.

00:05:33.680 --> 00:05:37.379
It takes forever to get your email,
even though it's only 3 seconds.

00:05:37.379 --> 00:05:38.629
It's not that long.

00:05:38.629 --> 00:05:41.139
But it feels really long.

00:05:41.139 --> 00:05:44.269
So what was fast before, what was fast in your web browsers,

00:05:44.269 --> 00:05:47.889
what was fast on your desktop,
these things aren't fast anymore.

00:05:47.889 --> 00:05:54.519
And you're going to have to work extra
hard to make them still seem fast.

00:05:54.519 --> 00:05:59.490
And then this is the part that where
it's really kind of an insult to injury.

00:05:59.490 --> 00:06:04.060
Your users actually are going to
demand even more from you here.

00:06:04.060 --> 00:06:07.370
Your users are going to-- it's their phone.

00:06:07.370 --> 00:06:09.290
It's with them wherever they are.

00:06:09.290 --> 00:06:14.990
They're not plugged into a wall, so they want your
applications to be available wherever they are.

00:06:14.990 --> 00:06:17.009
And that means that they could be in the office.

00:06:17.009 --> 00:06:18.370
They could be at home.

00:06:18.370 --> 00:06:22.230
They could be in the car driving,
perhaps at very high speeds.

00:06:22.230 --> 00:06:26.129
They could actually be in the bathroom
using your application.

00:06:26.129 --> 00:06:32.730
And when they can be anywhere and use their
application, it can be used at any time.

00:06:32.730 --> 00:06:37.110
So your application doesn't have to
just work during business hours anymore.

00:06:37.110 --> 00:06:45.280
Your application has to work 24 hours a day, 7 days a week,
every single day of the year depending on which year it is.

00:06:46.680 --> 00:06:53.170
In addition, users are going to want to
know that they can trust your application.

00:06:53.170 --> 00:06:58.300
They want to be able to give your application
data and trust that you're not going to lose it,

00:06:58.300 --> 00:07:01.800
and you're not going to drop it, and you're not
going to mangle it, and you won't expose it.

00:07:01.800 --> 00:07:07.560
And they're not going to go to any extra
effort to check to see that you've done this.

00:07:07.560 --> 00:07:10.550
If they gave you something to do, they expect you to do it.

00:07:10.550 --> 00:07:15.319
And if you didn't do it, then they're going to be mad.

00:07:15.319 --> 00:07:22.740
And finally, users are never going to ask for
security because they assume it's going to be secure.

00:07:22.740 --> 00:07:30.750
No user ever says, I have a requirement and that it must
be completely secure and it must follow certain protocols

00:07:30.750 --> 00:07:33.339
as set forth by the NSA or anything like that.

00:07:33.339 --> 00:07:34.269
Users won't say that.

00:07:34.269 --> 00:07:39.609
What will happen is when your data is not secure
and it leaks and it goes out to the press,

00:07:39.610 --> 00:07:45.240
or your company secrets go out, then they're going
to come after you and say, why wasn't it secure?

00:07:45.240 --> 00:07:46.990
So you definitely have to keep this in mind.

00:07:46.990 --> 00:07:48.800
I don't actually have to tell this audience that.

00:07:48.800 --> 00:07:53.199
I know that you guys know about that.

00:07:53.199 --> 00:07:59.319
So with all these additional challenges,
there's actually some good news.

00:07:59.319 --> 00:08:00.699
And it's that.

00:08:00.699 --> 00:08:02.039
Oh, sorry.

00:08:02.040 --> 00:08:03.550
Yes. Totally secure.

00:08:03.550 --> 00:08:10.110
Users, they're not going to want to put in a long
password, and they're not going to want to use a VPN token.

00:08:10.110 --> 00:08:12.180
They just want it to be secure.

00:08:12.180 --> 00:08:14.009
Excuse me.

00:08:14.009 --> 00:08:21.750
[ Silence ]

00:08:21.750 --> 00:08:28.290
The good news is that the technological
problem has actually been addressed,

00:08:28.290 --> 00:08:32.430
and this new device called the iPhone has
some great dev tools that comes with it.

00:08:32.429 --> 00:08:37.709
And it offers great deployment features.

00:08:37.710 --> 00:08:42.280
So you can actually learn to leverage the iPhone.

00:08:42.279 --> 00:08:47.839
It can be your one piece of certainty
in a sea of uncertainty.

00:08:47.840 --> 00:08:54.019
Wherever you don't know users are, you don't know when
they're calling, you don't know anything about them,

00:08:54.019 --> 00:08:58.429
you can still bet that if they have
an iPhone, you can get to that iPhone.

00:08:58.429 --> 00:09:00.569
That iPhone will be connected.

00:09:00.570 --> 00:09:03.920
That iPhone will have the same processor, the same screen.

00:09:03.919 --> 00:09:04.559
You know that.

00:09:04.559 --> 00:09:09.439
And users are increasingly choosing
the iPhone as their personal phone.

00:09:09.440 --> 00:09:17.170
And they're going to bring it to your
Enterprise and they will want it to work.

00:09:17.169 --> 00:09:26.839
So, how can you build applications
for the iPhone that users will like?

00:09:26.840 --> 00:09:32.629
Since you can't change so many things about the mobile
world, you actually have to change some things on your side.

00:09:32.629 --> 00:09:38.200
And one of the things that you can do
is don't give users more things to do.

00:09:38.200 --> 00:09:43.250
Instead, make them better at the things they're
already doing or they already want to do.

00:09:43.250 --> 00:09:47.960
And that means building applications
that make them smarter, for example.

00:09:47.960 --> 00:09:51.500
If the user has answers in their
pocket, then they know more.

00:09:51.500 --> 00:09:54.330
And they know more wherever they are.

00:09:55.740 --> 00:10:03.259
Applications like Lookup or Status, these things
give users quick answers to simple questions.

00:10:03.259 --> 00:10:09.399
And they don't have to have the
answer if they can look it up.

00:10:09.399 --> 00:10:13.610
Of course, the iPhone is almost
always connected to some network.

00:10:13.610 --> 00:10:18.560
And you can actually build applications that poke the user.

00:10:18.559 --> 00:10:19.849
Not physically.

00:10:19.850 --> 00:10:24.470
But nudge the user and let them know
hey, there's something that happened.

00:10:24.470 --> 00:10:27.269
And you can keep them informed of events and news.

00:10:27.269 --> 00:10:33.579
And since it's on a communications device they have their
choice of modes of communication for getting back to you,

00:10:33.580 --> 00:10:36.830
calling back to the organization, and
actually doing something about it,

00:10:36.830 --> 00:10:42.420
which in turn makes your users faster at what they do.

00:10:42.419 --> 00:10:50.240
And by giving users applications that work remotely
so that they can control servers, let's say,

00:10:50.240 --> 00:10:54.430
or their desk back at work, from
wherever in the world they happen to be,

00:10:54.429 --> 00:10:57.009
you're making them more influential
than they've ever been before.

00:10:57.009 --> 00:11:01.639
[ Silence ]

00:11:01.639 --> 00:11:10.279
What I'm trying to say is when you go out to build a mobile
application for your employees or your students or faculty

00:11:10.279 --> 00:11:18.129
or whoever exists in your organization, don't think of it
as a miniversion of a desktop app that you already have.

00:11:18.129 --> 00:11:20.580
That's not going to work.

00:11:20.580 --> 00:11:28.009
Instead, consider your applications as safe
and legal performance enhancers for your users.

00:11:28.009 --> 00:11:34.539
[ Silence ]

00:11:34.539 --> 00:11:39.240
Now, to get into some more detail on the design problem.

00:11:39.240 --> 00:11:46.159
I've identified 7 key properties that I think
make for successful Enterprise applications.

00:11:46.159 --> 00:11:51.639
And I've distilled them into a
series of F words for your enjoyment.

00:11:51.639 --> 00:11:54.250
The first is Fast, you know.

00:11:54.250 --> 00:12:00.059
Like I said, when a-- with a device
in your hand, time feels slow.

00:12:00.059 --> 00:12:04.229
To make matters worse, the processor
in your hand is not very quick either.

00:12:04.230 --> 00:12:10.300
So you're going to have to work very hard to optimize your
code to make sure you're not wasting any of the user's time.

00:12:10.299 --> 00:12:14.240
And to optimize your services that back
your code so that they give answers

00:12:14.240 --> 00:12:18.590
over the network very quickly with very light payloads.

00:12:18.590 --> 00:12:22.040
Your application should be Familiar to users.

00:12:22.039 --> 00:12:28.089
If you've been to any of the UI sessions earlier
today, you've already heard this a few times.

00:12:28.090 --> 00:12:32.899
It doesn't hurt to follow the same
patterns that you see over and over again.

00:12:32.899 --> 00:12:35.759
These patterns have emerged because they work very well.

00:12:35.759 --> 00:12:43.269
So things like the maps or table views,
or alert sheets with buttons on them,

00:12:43.269 --> 00:12:49.730
don't be afraid to use these standard
interface and interaction design patterns.

00:12:49.730 --> 00:12:53.779
It's OK. These things will make
it very comfortable for a user.

00:12:53.779 --> 00:12:56.250
They won't have to spend any time
learning to use your application

00:12:56.250 --> 00:12:58.710
because they'll feel that they already know how to use it.

00:12:58.710 --> 00:13:05.990
Next is you have to make sure that
you're Formatting whatever is in your--

00:13:05.990 --> 00:13:12.450
the content in your application for what's
probably the smallest screen you've ever targeted.

00:13:12.450 --> 00:13:17.020
And that means that you have to consider that for
some people it's very hard to read small text.

00:13:17.019 --> 00:13:21.059
And you have to make sure that whatever you're going to--
the data that you're going to give them is actually legible.

00:13:21.059 --> 00:13:25.439
If you can't do that, then you would
probably want to support zooming.

00:13:25.440 --> 00:13:31.270
But also, and this is I think more important, any
inputs that you wanted to present your user with need

00:13:31.269 --> 00:13:34.149
to be large enough to be touched by fingers.

00:13:34.149 --> 00:13:39.289
Keeping in mind that some people's fingers are kind of big.

00:13:39.289 --> 00:13:41.299
Next is Focus.

00:13:41.299 --> 00:13:48.959
As I said, users are not going to stop what they're
doing to use your application, so your application needs

00:13:48.960 --> 00:13:52.009
to focus on solving a particular problem.

00:13:52.009 --> 00:13:56.939
So the user knows that they can go to your
app and get a quick answer, for example.

00:13:56.940 --> 00:13:58.140
There are many apps in the store.

00:13:58.139 --> 00:14:07.610
Some of the most successful and highest rated ones
solve particular problems, and they do it very quickly.

00:14:07.610 --> 00:14:12.100
The apps that track flights, for
example, or apps that track packages.

00:14:12.100 --> 00:14:19.009
Or apps that quickly convert from one unit to another,
these launch very fast and they give the ans--

00:14:19.009 --> 00:14:22.419
the user a quick answer to a simple question.

00:14:22.419 --> 00:14:30.069
Your app should have the Foresight to know or to

00:14:30.070 --> 00:14:35.070
at least guess what users are going to
want to do after you give them data.

00:14:35.070 --> 00:14:40.140
So if you give them data that's a phone
number, the user may want to call that number.

00:14:40.139 --> 00:14:44.819
So linking to other applications
and services is a good idea.

00:14:44.820 --> 00:14:49.240
So integrating with things like
contacts, for example, so that, you know,

00:14:49.240 --> 00:14:54.830
if you're talking about a person there's a link to
get information about how to contact that person.

00:14:54.830 --> 00:15:05.129
Or if you're talking about a location there's a link
to get information about how to get to that location.

00:15:05.129 --> 00:15:08.820
Your applications should be Forgiving,
and by that what I mean is

00:15:08.820 --> 00:15:12.890
that the users are not perfect and
they're going to make mistakes.

00:15:12.889 --> 00:15:16.189
They might touch the screen when
they didn't mean to touch the screen.

00:15:16.190 --> 00:15:20.350
They might drop the phone and accidentally
touch it on the way down.

00:15:20.350 --> 00:15:21.830
They may not know what they're doing.

00:15:21.830 --> 00:15:27.210
So you should definitely protect
the user from destructive actions.

00:15:27.210 --> 00:15:34.190
Now that iPhone 3.0 offers undo support, you should
absolutely try and build that in where appropriate.

00:15:34.190 --> 00:15:38.250
But you can't rely on it.

00:15:38.250 --> 00:15:42.129
The best support for undo would be
the undo that you never have to use

00:15:42.129 --> 00:15:46.970
because you've already protected the
user from doing something dangerous.

00:15:46.970 --> 00:15:52.379
And finally, finally, it's OK to be a little bit of Fun.

00:15:52.379 --> 00:15:55.700
It's OK to have a little bit of fun at work.

00:15:55.700 --> 00:15:58.150
If people like to work then they like to work.

00:15:58.149 --> 00:16:05.709
So where you can, if it makes sense,
put a little fun into your applications.

00:16:05.710 --> 00:16:08.290
One of the best ways to do this, one
of the most effective ways to do this,

00:16:08.289 --> 00:16:13.009
is to use things like the Accelerometer
so that you can present different views.

00:16:13.009 --> 00:16:18.659
If the user tilts it from portrait to landscape mode,
or you could respond to the user shaking their phone.

00:16:18.659 --> 00:16:21.709
Things like that.

00:16:21.710 --> 00:16:29.680
I actually try, and I know a lot of organizations have
already deployed iPhone applications into their org.

00:16:29.679 --> 00:16:34.649
They find great value in making their apps
a little bit playful, a little bit fun.

00:16:34.649 --> 00:16:37.629
This is also important because if your user owns

00:16:37.629 --> 00:16:44.649
and administers their own phone,
they will put games on that phone.

00:16:44.649 --> 00:16:51.009
And your application, whether or not you like it,
is going to stand right next to games on that phone.

00:16:51.009 --> 00:16:56.679
And even though it's not fair, users are going to judge
the quality of your application against those games.

00:16:56.679 --> 00:17:01.569
So you're going to have to try a
little harder to woo them back to work.

00:17:01.570 --> 00:17:06.960
The one caveat on this: Don't go overboard.

00:17:06.960 --> 00:17:08.789
Don't pick a bad color scheme.

00:17:08.789 --> 00:17:11.019
Don't reinvent the blink tag.

00:17:11.019 --> 00:17:13.170
Please, don't do these things.

00:17:13.170 --> 00:17:18.890
Usability is far more important than crazy, crazy fun.

00:17:18.890 --> 00:17:24.320
So once you've figured out what you're going to build,
then you have to figure out how you're going to build it.

00:17:24.319 --> 00:17:27.200
And on the iPhone you have 2 choices.

00:17:27.200 --> 00:17:32.380
You can build your applications to run
within Safari as mobile web applications.

00:17:32.380 --> 00:17:35.510
Or you can target the iPhone SDK.

00:17:35.509 --> 00:17:40.289
Of course, in iPhone 1.0 we launched
with web application support.

00:17:40.289 --> 00:17:46.420
And you could immediately integrate with things
like the phone, the mail, the maps applications.

00:17:46.420 --> 00:17:53.100
Later we let you put an app icon on the home screen
so that users had immediate access to your web app.

00:17:53.099 --> 00:17:56.199
And of course, web apps by nature are instant deployment.

00:17:56.200 --> 00:18:01.819
This is probably the biggest argument for a web
app, is that you don't have version problems.

00:18:01.819 --> 00:18:05.269
Everybody's always using the latest and greatest version.

00:18:05.269 --> 00:18:13.569
In 2.0, Safari grew quite a bit and it
now supported multi-touch gesture support.

00:18:13.569 --> 00:18:19.369
And it provided 3D and hardwar=e
accelerated graphics and animation

00:18:19.369 --> 00:18:22.369
so you could do some really amazing things with it.

00:18:22.369 --> 00:18:27.579
One of the most important aspects from a data
and information management perspective was

00:18:27.579 --> 00:18:38.069
that you could now store data in a web app locally using
a HTML 5 database spec. And the actual applications

00:18:38.069 --> 00:18:43.039
on the iPhone could be sort of saved to be
run even when there's no Internet connection

00:18:43.039 --> 00:18:45.029
at all, which is actually pretty amazing.

00:18:45.029 --> 00:18:50.289
Of course also the big thing with 2.0 was the
introduction of the SDK, which did all those things.

00:18:50.289 --> 00:18:56.519
And in addition gave developers access to the
neat sensors that are available in the iPhone

00:18:56.519 --> 00:18:59.730
so that they could take advantage
of the camera or the Accelerometer.

00:18:59.730 --> 00:19:01.120
Things like that.

00:19:01.119 --> 00:19:07.049
Now in 3.0 Safari has completed its support
for HTML 5, so it's got a lot of new things.

00:19:07.049 --> 00:19:11.200
Including, this is sort of an exclusive,
but location services.

00:19:11.200 --> 00:19:17.460
There's now a JavaScript API to figure out where
you are and tell your web application about that.

00:19:17.460 --> 00:19:22.870
And based on where you happen to be at the
time, you can tailor your web application

00:19:22.869 --> 00:19:25.189
to provide more relevant data to the user.

00:19:25.190 --> 00:19:32.150
And of course, the big thing in 3.0, I know, is
the arrival of the Push Notification Service.

00:19:32.150 --> 00:19:36.410
So there's these two platforms, but
there's a hidden platform in here.

00:19:36.410 --> 00:19:40.370
There's actually a third platform,
which is hybrid applications.

00:19:40.369 --> 00:19:45.209
Hybrid applications are a combination
of web and native, obviously.

00:19:45.210 --> 00:19:51.120
And the neat thing about hybrids is that they
can do everything that either platform can do.

00:19:51.119 --> 00:19:54.750
And we're going to talk a little bit more about this later.

00:19:54.750 --> 00:20:01.009
Real quick though, a hybrid application means that you're
building a web application so it's like building for Safari.

00:20:01.009 --> 00:20:06.970
But instead of building it to run in Safari, you're
building it to run in your own Safari-like browser.

00:20:06.970 --> 00:20:13.180
And then when you deploy that application,
your own custom browser, to your user's phones,

00:20:13.180 --> 00:20:19.210
and then they can pull up your
hybrid web applications within it.

00:20:19.210 --> 00:20:22.230
It doesn't sound very compelling,
but here's why it's compelling.

00:20:22.230 --> 00:20:29.279
If you build a hybrid web application for
your own hybrid web application platform,

00:20:29.279 --> 00:20:34.019
you can actually support communication between
the web application and the native platform.

00:20:34.019 --> 00:20:40.839
So if the web application wanted something that
only the SDK could provide, it could tell the portal

00:20:40.839 --> 00:20:44.799
or the hybrid web application that using an HTTP request.

00:20:44.799 --> 00:20:46.990
So it could say, I need a photo.

00:20:46.990 --> 00:20:49.940
And then the application would hear that.

00:20:49.940 --> 00:20:55.799
Being a native SDK application it could work
with SDK services like the camera to get a photo.

00:20:55.799 --> 00:20:58.430
And then it could send it up to your web server.

00:20:58.430 --> 00:21:01.310
And your web server could return its location.

00:21:01.309 --> 00:21:07.470
And then your hybrid platform could actually invoke
a JavaScript call to tell your web application

00:21:07.470 --> 00:21:09.930
that it got it, and now here's where you can use it.

00:21:09.930 --> 00:21:14.440
Jake's definitely going to talk
more about what you need to do

00:21:14.440 --> 00:21:21.700
to build this third platform, and
how powerful it really can be.

00:21:21.700 --> 00:21:27.670
What's really cool about it is that once you've deployed
this platform, the users can run multiple web apps.

00:21:27.670 --> 00:21:33.330
And they never have to configure or install anything again.

00:21:33.329 --> 00:21:37.980
So with the 3 platforms, remember
it's not actually 3 choices.

00:21:37.980 --> 00:21:41.400
You can actually look at it as a road map.

00:21:41.400 --> 00:21:43.820
An evolution for your mobile application.

00:21:43.819 --> 00:21:50.389
You could start today by building a web application on the
same services that you already have in your organization.

00:21:50.390 --> 00:21:53.980
And you can build it pretty quickly,
using Dashcode for example.

00:21:53.980 --> 00:21:59.470
And tie with those web standards
using web standard development talent.

00:21:59.470 --> 00:22:05.549
And then while your users are satisfied with that, you
can keep them distracted while you, behind the scenes,

00:22:05.549 --> 00:22:09.799
rush off and either build a richer
web application on a hybrid platform

00:22:09.799 --> 00:22:13.399
or a very high performance native application.

00:22:13.400 --> 00:22:20.790
So, that said I'm going to hand it over to Jake now, and
he's going to give you some more information about tips

00:22:20.789 --> 00:22:25.139
and best practices in developing and
deploying applications in your Enterprise.

00:22:25.140 --> 00:22:30.030
As well as what you need to know in order to
take advantage of this magical third platform.

00:22:30.029 --> 00:22:31.230
So, Jake?

00:22:31.230 --> 00:22:37.170
>> Thanks a lot, Steve.

00:22:37.170 --> 00:22:39.240
So thanks for coming everybody.

00:22:39.240 --> 00:22:40.430
My name's Jake Logan.

00:22:40.430 --> 00:22:47.650
I also work at Apple IS&T and I'm going to share a few
best practices with you for architecture and development.

00:22:47.650 --> 00:22:51.790
How we do things inside Apple to build
great iPhone applications for our users.

00:22:51.789 --> 00:22:56.899
So I just have 7 best practices to share with you today.

00:22:56.900 --> 00:23:01.250
The first is that the iPhone is not a desktop,
and we'll go a little bit in-depth on that.

00:23:01.250 --> 00:23:03.819
But it's just important to remember
that it's a whole new paradigm.

00:23:03.819 --> 00:23:07.460
You want to think about this kind of development
differently than you have on the desktop.

00:23:07.460 --> 00:23:13.400
I expect there are folks here from a Mac
development background, and probably folks here

00:23:13.400 --> 00:23:18.200
from a Windows development background, and maybe
some mobile application developers as well.

00:23:18.200 --> 00:23:22.720
So the main point here is, think
about it a little bit differently.

00:23:22.720 --> 00:23:24.120
It's really not a desktop.

00:23:24.119 --> 00:23:31.319
Next is use the existing infrastructure that you
have, and we'll go into depth on this as well.

00:23:31.319 --> 00:23:34.960
But it's important to just remember
that there's a lot of great services

00:23:34.960 --> 00:23:39.019
in your organization today and you want to leverage those.

00:23:39.019 --> 00:23:40.950
Engineer for Performance.

00:23:40.950 --> 00:23:42.710
This is a really key point.

00:23:42.710 --> 00:23:49.850
There's so many ways to really enhance your
services so that they work well on the phone.

00:23:49.849 --> 00:23:54.149
And of course you want to test on the device.

00:23:54.150 --> 00:23:55.620
Don't wait until the last minute.

00:23:55.619 --> 00:24:00.239
Test early, test often on the device.

00:24:00.240 --> 00:24:02.289
And architect for security.

00:24:02.289 --> 00:24:09.190
Of course, like Steve was saying it's really important
that security play a big role in your development model.

00:24:09.190 --> 00:24:14.670
It's easy to forget, but it's really important
that you secure your applications properly

00:24:14.670 --> 00:24:20.330
to protect your company data, trade secrets and so on.

00:24:20.329 --> 00:24:26.339
This sixth point is really kind of
a fun look at the hybrid platform

00:24:26.339 --> 00:24:29.879
that Steve was talking about, and
we'll go into depth on that as well.

00:24:29.880 --> 00:24:34.440
And lastly, you want to customize your deployment plan.

00:24:34.440 --> 00:24:37.390
You want to think through up front
how you're going to deploy your apps.

00:24:37.390 --> 00:24:42.810
And that's true for web apps, for native
apps, and also for hybrid applications.

00:24:42.809 --> 00:24:44.379
How is your scheme going to work?

00:24:44.380 --> 00:24:48.090
How are you going to make these apps work together?

00:24:48.089 --> 00:24:57.599
So when we talk about iPhone not being a desktop,
one of the key differentiating factors is the reality

00:24:57.599 --> 00:24:59.889
that it's got a totally different security model.

00:24:59.890 --> 00:25:01.030
The device is personal.

00:25:01.029 --> 00:25:01.960
It's in your pocket.

00:25:01.960 --> 00:25:06.660
It's not shared like a desktop computer would be.

00:25:06.660 --> 00:25:13.850
And each app is sandboxed, so they can't necessarily
talk to other apps, although there are ways to get

00:25:13.849 --> 00:25:18.569
around that problem, as we'll show you in a little bit.

00:25:18.569 --> 00:25:24.519
But each app runs one at a time so,
you know, you need to think about that.

00:25:24.519 --> 00:25:27.869
You need to factor that into your plans.

00:25:27.869 --> 00:25:30.259
Network performance is quite a bit different, right?

00:25:30.259 --> 00:25:34.500
So on the desktop we have, you know, usually wired networks.

00:25:34.500 --> 00:25:38.130
100 based-T, 10 based-T, fast connections and so on.

00:25:38.130 --> 00:25:44.990
On the device, well, 3G is a great
networking protocol and it's quite quick.

00:25:44.990 --> 00:25:50.609
It's not nearly as fast as the desktop, so
it's a key differentiating factor again.

00:25:50.609 --> 00:25:53.709
And lastly processing power.

00:25:53.710 --> 00:25:59.319
So it would be really great if we had multi-core
Intel processors on the phone, but we don't.

00:25:59.319 --> 00:26:02.710
So we need to take that into consideration as well.

00:26:04.509 --> 00:26:06.779
So Don't Try to Port Your Desktop Apps.

00:26:06.779 --> 00:26:11.789
And what this graphic here is really showing
is that again, it's a whole new paradigm.

00:26:11.789 --> 00:26:15.389
You need to look at iPhone development
for the device in a mobile environment.

00:26:15.390 --> 00:26:18.290
Don't try and port your desktop code over to the phone.

00:26:18.289 --> 00:26:20.950
It's not going to work very well.

00:26:20.950 --> 00:26:29.549
So there are some differences between Cocoa Touch and
Cocoa on the desktop, and you need to think about those.

00:26:29.549 --> 00:26:34.039
One of the differences is there's no
dynamic link libraries on the phone.

00:26:34.039 --> 00:26:39.039
So when you want to build a library
and share it between applications,

00:26:39.039 --> 00:26:43.539
you need to build a statically linked library
instead of a dynamically linked library.

00:26:43.539 --> 00:26:50.759
And you can do that with a new Xcode
target that's available in the latest SDK,

00:26:50.759 --> 00:26:52.700
which allows you to build a statically linked library.

00:26:52.700 --> 00:26:56.539
Once you've got that library you
can share it between applications.

00:26:56.539 --> 00:27:01.200
So we're going to talk a little bit
more about that in a few minutes.

00:27:01.200 --> 00:27:04.009
And you want to wrap LDAP with web services.

00:27:04.009 --> 00:27:05.480
Well, it's not only LDAP.

00:27:05.480 --> 00:27:11.190
It's when there's something that you want to do on
the phone that you don't already have a framework for.

00:27:11.190 --> 00:27:15.380
You want to maybe move that functionality
over to the server.

00:27:15.380 --> 00:27:19.510
Make a wrapper for it, and then
call it with NSURLConnection.

00:27:20.670 --> 00:27:25.690
So our number two point here is
Build on Existing Infrastructure.

00:27:25.690 --> 00:27:30.420
And I imagine there's folks here
from educational institutions,

00:27:30.420 --> 00:27:32.720
government institutions, and of course corporations.

00:27:32.720 --> 00:27:33.750
Maybe small companies.

00:27:33.750 --> 00:27:35.109
Maybe medium-sized companies.

00:27:35.109 --> 00:27:37.199
You all have existing infrastructure.

00:27:37.200 --> 00:27:40.680
You want to take what you've got and build on top of that.

00:27:40.680 --> 00:27:45.259
Maybe make some wrappers specifically for mobile usage.

00:27:45.259 --> 00:27:48.690
So again, leverage existing services and business processes.

00:27:48.690 --> 00:27:57.059
You want to employ a service-oriented
architecture for scalability, right?

00:27:57.059 --> 00:28:01.179
And you want that to be stateless so that
when you build a really great iPhone app

00:28:01.180 --> 00:28:05.630
and all of your users begin using it, you don't
find yourself in a situation where you can't scale

00:28:05.630 --> 00:28:10.130
out horizontally and add servers to support the
new load that the organization is generating.

00:28:10.130 --> 00:28:14.470
You want to think through, you know,
what's your expectation for the load

00:28:14.470 --> 00:28:20.720
and build a lot more capacity than
that expectation would require.

00:28:20.720 --> 00:28:27.799
And you want to create RESTful wrappers for
your web services, for your SOAP services.

00:28:27.799 --> 00:28:30.849
SOAP can be a little bit heavy for the phone.

00:28:30.849 --> 00:28:37.799
SOAP tends to have extra parameters, extra
baggage so to speak which may be useful

00:28:37.799 --> 00:28:40.480
in a data center environment or even on a desktop.

00:28:40.480 --> 00:28:44.799
But really what you want to do is
take those fairly heavyweight services

00:28:44.799 --> 00:28:47.289
and create very thin, RESTful wrappers for them.

00:28:47.289 --> 00:28:48.849
So what are RESTful wrappers?

00:28:48.849 --> 00:28:55.089
Well, they're essentially HTTP post
services that return an XML document.

00:28:55.089 --> 00:29:02.569
So when you do that there's an added advantage, and that
is that you can then use a lot of industry standard tools

00:29:02.569 --> 00:29:09.829
to check out your performance, the payload sizes, and so on.

00:29:09.829 --> 00:29:13.929
We'll go into that a little bit in the
performance section on how you can use some

00:29:13.930 --> 00:29:17.890
of the Safari web tools to do that sort of thing.

00:29:17.890 --> 00:29:20.630
So Engineering for Performance.

00:29:20.630 --> 00:29:22.000
Our number 3 best practice.

00:29:22.000 --> 00:29:24.609
This is critical.

00:29:24.609 --> 00:29:26.529
Minimize the service invocations.

00:29:26.529 --> 00:29:34.980
So there are generally a number of calls that
you need to make when you build an application.

00:29:34.980 --> 00:29:37.059
And on the desktop it's not such a big deal, you know.

00:29:37.059 --> 00:29:39.659
You might make one call to the server, get some data back.

00:29:39.660 --> 00:29:41.890
And you might make another call to get some different data.

00:29:41.890 --> 00:29:45.730
But the two pieces of data sit on the same page together.

00:29:45.730 --> 00:29:47.870
Why couldn't you get those in one shot?

00:29:47.869 --> 00:29:54.649
So on the phone, service invocations are very
expensive due to the reasons I was mentioning before.

00:29:54.650 --> 00:29:55.700
Processor.

00:29:55.700 --> 00:29:58.470
Power. Networking performance and so on.

00:29:58.470 --> 00:30:02.370
So you really want to bundle those up and do
as few service invocations as you possibly can.

00:30:02.369 --> 00:30:10.059
You want to construct mobile optimized
wrappers, as I was alluding to before.

00:30:10.059 --> 00:30:14.539
You want to create wrappers for your existing
services that are really, really thin.

00:30:14.539 --> 00:30:22.680
You want to shrink down those payloads and really figure
out ways to shrink the size of your containers as well.

00:30:22.680 --> 00:30:25.740
You don't want a whole lot of extra
kilobytes going over the wire.

00:30:25.740 --> 00:30:31.609
Or, in this case over the air.

00:30:31.609 --> 00:30:36.209
So you want to test with the faster
wireless protocols turned off.

00:30:36.210 --> 00:30:39.170
You want to focus on the lowest common denominator.

00:30:39.170 --> 00:30:42.970
And if it works great on 2G, well it's.

00:30:42.970 --> 00:30:46.809
It'll work even better on 3G, and
even better than that on Wi-Fi.

00:30:46.809 --> 00:30:50.750
So don't assume that all your users necessarily have 3G.

00:30:50.750 --> 00:30:54.400
And take advantage of caching mechanisms.

00:30:54.400 --> 00:30:56.160
This is a key point as well.

00:30:56.160 --> 00:31:04.210
In Safari, in the new HTML 5 spec, there's support for
web app caching, and that's great for pure web apps.

00:31:04.210 --> 00:31:11.930
You could also implement your own cashing mechanisms
in a Cocoa application, a Cocoa Touch application.

00:31:11.930 --> 00:31:13.700
You do that with NS user defaults.

00:31:13.700 --> 00:31:20.900
You can store images that don't change very much
or maybe ever in your NS user defaults cache.

00:31:20.900 --> 00:31:24.600
And you could also store any other
non-changing data, you know.

00:31:24.599 --> 00:31:31.899
XML plist maybe, or maybe some other types of textual data.

00:31:31.900 --> 00:31:33.920
So you want to think about caching, you know.

00:31:33.920 --> 00:31:39.519
How can you leverage caching to really
give the perception of better performance?

00:31:39.519 --> 00:31:45.319
So you want to Shrink Response Times,
and let's talk about how you do that.

00:31:45.319 --> 00:31:49.549
Well, the first thing is you write some
code in your client and also in your server

00:31:49.549 --> 00:31:53.279
that captures the timings for performance, right?

00:31:53.279 --> 00:31:57.529
So you want to see how long a particular
service takes to be called.

00:31:57.529 --> 00:32:00.980
And what you might find is that, you
know, you call a service on the device

00:32:00.980 --> 00:32:04.049
and it takes a full 2 seconds for the round trip.

00:32:04.049 --> 00:32:07.589
But on the server maybe it only takes 200 milliseconds.

00:32:07.589 --> 00:32:08.879
So there's a big delta there.

00:32:08.880 --> 00:32:14.920
And you know you're using Wi-Fi, say, so you
know that the network's not really the problem.

00:32:14.920 --> 00:32:22.090
So then you can look to your client code to look
for opportunities to shrink the response time.

00:32:22.089 --> 00:32:27.949
So you want to, again, evaluate your
timing data and look for low-hanging fruit.

00:32:27.950 --> 00:32:31.549
Look for opportunities to improve
the performance of your application.

00:32:31.549 --> 00:32:36.710
You want to tune your client server appropriately, right?

00:32:36.710 --> 00:32:39.600
Make the tweaks where they make
sense, and then rinse and repeat.

00:32:39.599 --> 00:32:47.609
Do this a few times so that you can
find ways to gradually remove hotspots.

00:32:47.609 --> 00:32:50.909
To get those things out of the way
that are slowing your system down.

00:32:50.910 --> 00:32:56.610
And you want to reduce the size
and number of your resources.

00:32:56.609 --> 00:33:03.029
So you can use the Safari Web Inspector is a great
tool to gauge the size of your app footprint.

00:33:03.029 --> 00:33:05.599
And this is where the RESTful service bit comes in.

00:33:05.599 --> 00:33:08.119
Because if you build all of your services RESTful,

00:33:08.119 --> 00:33:13.589
then you can invoke them right on
the URL line, the URL bar on Safari.

00:33:13.589 --> 00:33:17.929
So that you can even for services that won't be
used for a web app, maybe they're going to be used

00:33:17.930 --> 00:33:25.190
for a Cocoa Touch app, you can still get an understanding
as to how well they perform and what the payload size is.

00:33:25.190 --> 00:33:30.980
And for web apps it's even better of course, because you can
break it down into documents and style sheets and JavaScript

00:33:30.980 --> 00:33:36.279
and so on, so you can get a real strong
picture of how your app footprint looks.

00:33:36.279 --> 00:33:39.849
So the next step is to combine your textual resources.

00:33:39.849 --> 00:33:44.579
You have probably in a web app a number of JavaScript files.

00:33:44.579 --> 00:33:46.329
You can combine those all into one.

00:33:46.329 --> 00:33:50.220
Or you might even consider sticking those
in a script tag in the top of your page.

00:33:50.220 --> 00:33:54.900
Then you've bought yourself another HTTP connection.

00:33:54.900 --> 00:33:59.370
Another connection that you don't need to open up.

00:33:59.369 --> 00:34:02.269
So you can do this with any textual resources, right?

00:34:02.269 --> 00:34:08.280
JavaScript, CSS, XML, JSON, some
home-rolled protocol, you know.

00:34:08.280 --> 00:34:12.220
Whatever you use there's opportunities
here to really increase performance.

00:34:12.219 --> 00:34:14.719
You also want to combine your image resources.

00:34:14.719 --> 00:34:19.159
So a key technique in doing this is called spriting.

00:34:19.159 --> 00:34:26.659
And what it's really about is taking your
imagery and creating optimized images

00:34:26.659 --> 00:34:29.289
for each of your icons, images and so on.

00:34:29.289 --> 00:34:35.539
And then bundling all those up into one large image,
and using either CSS or Cocoa to shift that image

00:34:35.539 --> 00:34:38.869
at run time to only show one small part of it.

00:34:38.869 --> 00:34:41.639
Then of course you'll optimize that large image as well.

00:34:41.639 --> 00:34:46.509
So once you've done all of that
you can really see a huge gain.

00:34:46.510 --> 00:34:49.190
You know, many orders of magnitude in a lot of cases.

00:34:49.190 --> 00:34:53.369
So it's a really effective technique
to increase performance.

00:34:53.369 --> 00:34:57.279
And again, to optimize the image file size.

00:34:57.280 --> 00:35:00.460
And lastly, you want to turn on service side compression.

00:35:00.460 --> 00:35:06.610
In Apache, there's a plug-in called
mod_deflate that will turn on gzip compression

00:35:06.610 --> 00:35:17.740
and Safari automatically will gzip or, excuse me, un-gzip
on the fly so that it'll be seamless on the client side.

00:35:17.739 --> 00:35:19.059
There's nothing to do on the client side.

00:35:19.059 --> 00:35:21.009
It's just a configuration in Apache.

00:35:21.010 --> 00:35:25.950
This can make a big difference too, especially
if you have a lot of textual resources.

00:35:28.230 --> 00:35:30.179
So test on the device.

00:35:30.179 --> 00:35:31.859
Can't stress this enough.

00:35:31.860 --> 00:35:32.570
Test early.

00:35:32.570 --> 00:35:33.380
Test often.

00:35:33.380 --> 00:35:38.360
What you really don't want is to find
yourself at the end of your development cycle

00:35:38.360 --> 00:35:40.530
and you never really tested on the device.

00:35:40.530 --> 00:35:45.110
And you find that things aren't really performing
as well as you thought they would, you know.

00:35:45.110 --> 00:35:49.050
It can be a little bit of an illusion with a simulator to--

00:35:49.050 --> 00:35:54.390
you really tend to feel like your
app is really fast on the simulator.

00:35:54.389 --> 00:35:56.579
And then when you go test on the
device it's not nearly as fast.

00:35:56.579 --> 00:35:57.699
Well, why is that?

00:35:57.699 --> 00:36:01.919
Well, excuse me.

00:36:01.920 --> 00:36:09.380
It's great for rapid debugging, but it's kind
of like having an iPhone with an Ethernet cable

00:36:09.380 --> 00:36:13.230
and a multi-core processor plugged into it, you know.

00:36:13.230 --> 00:36:20.079
It's really misleading in the sense that everything
feels so fast, so you really need to test on the device.

00:36:20.079 --> 00:36:24.069
And you need to be aware of the
simulator differences as well.

00:36:24.070 --> 00:36:28.880
Security framework is the first of those differences.

00:36:28.880 --> 00:36:33.390
And the thing about the security framework is
on the iPhone, well, that's the Keychain, right?

00:36:33.389 --> 00:36:36.779
And it's a little bit different than the
desktop in the sense that it's headless.

00:36:36.780 --> 00:36:39.220
There's no nice Keychain application.

00:36:39.219 --> 00:36:45.179
Keychain access application that you
can use to see what's in the Keychain.

00:36:45.179 --> 00:36:51.789
So, you know, when you run a Cocoa Touch
application in the simulator that needs

00:36:51.789 --> 00:36:54.250
to use the Keychain, it's not going to work.

00:36:54.250 --> 00:36:56.380
So you need to figure out ways to overcome that.

00:36:56.380 --> 00:37:02.250
Some of the ways are to write some fake code that
simulates what the Keychain would do in the simulator.

00:37:02.250 --> 00:37:10.900
Another way is to call the Mac OS X desktop Keychain APIs
to simulate the behavior of the Keychain on the phone.

00:37:10.900 --> 00:37:17.610
But it's something to think about when you want to keep
your development train going and be able to rapidly debug

00:37:17.610 --> 00:37:21.490
on both the simulator and the device concurrently.

00:37:21.489 --> 00:37:23.649
So again, network performance.

00:37:23.650 --> 00:37:27.740
There's a big difference between the
simulator and the device and processing power.

00:37:27.739 --> 00:37:29.299
One more time, big difference.

00:37:29.300 --> 00:37:32.010
Just pointing these out again because they're so important.

00:37:32.010 --> 00:37:38.350
[ Silence ]

00:37:38.349 --> 00:37:43.809
So let's talk about security now.

00:37:43.809 --> 00:37:48.239
So, fundamental to your plan should
be a secure architecture.

00:37:48.239 --> 00:37:51.089
You really need to think through how
you're going to make that happen.

00:37:51.090 --> 00:37:54.670
What are you going to do to make your application secure?

00:37:54.670 --> 00:37:58.440
And also everything that you do over the network's secure.

00:37:58.440 --> 00:38:02.860
So the first point is always use
SSL in everything that you do.

00:38:02.860 --> 00:38:04.470
Because what we're going to talk to you a little bit

00:38:04.469 --> 00:38:14.609
about in a minute is extending your applications outside
the firewall and how to do that, without VPN actually.

00:38:14.610 --> 00:38:17.620
Implement secondary encryption on passwords.

00:38:17.619 --> 00:38:23.730
Since passwords are the most sensitive data in your
application, the most critical piece of information.

00:38:23.730 --> 00:38:27.280
For instance, if somebody steals your password
they can steal all your company data too.

00:38:27.280 --> 00:38:30.320
You really want to consider possibly
doing secondary encryption

00:38:30.320 --> 00:38:34.710
on your password before you pass it over the wire.

00:38:34.710 --> 00:38:38.360
And you want to use the Keychain to persist sensitive data.

00:38:38.360 --> 00:38:41.200
Everything that goes in the Keychain
is encrypted, of course.

00:38:41.199 --> 00:38:44.539
So take advantage of it and don't go reinvent the wheel.

00:38:44.539 --> 00:38:47.420
Use the Keychain for the purpose intended.

00:38:50.030 --> 00:38:53.769
So let's go through how to create
a secure transport library.

00:38:53.769 --> 00:39:02.289
And I want to stress that as I walk through these
concepts, these building blocks that we're going to use,

00:39:02.289 --> 00:39:05.590
that we're really working towards a special requirement.

00:39:05.590 --> 00:39:06.620
At Apple we had a requirement.

00:39:06.619 --> 00:39:13.089
We needed to make a single authentication system work for
both web applications and native Cocoa Touch applications,

00:39:13.090 --> 00:39:16.550
and so we wanted to build a system
that would work perfectly for both.

00:39:16.550 --> 00:39:23.789
And really allow the user just one time in the morning to
sign in and be into all of his applications all day long.

00:39:23.789 --> 00:39:30.880
So the first component of this is the transport library.

00:39:30.880 --> 00:39:37.769
And we implement that as a static library project in Xcode.

00:39:37.769 --> 00:39:41.099
And we wrap the NSURL connection and implement SSL.

00:39:41.099 --> 00:39:45.900
So we make sure that it's implemented in a single place

00:39:45.900 --> 00:39:51.380
so that whenever anybody uses our library
they automatically get the benefits of SSL.

00:39:51.380 --> 00:39:57.030
They don't-- we don't have to worry that,
you know, one app team didn't implement SSL

00:39:57.030 --> 00:39:58.310
and now we've got a security hold, right?

00:39:58.309 --> 00:40:02.309
If everybody uses the same library and it's
on by default, everybody gets the benefit.

00:40:02.309 --> 00:40:12.579
You want to leverage in-built NSDictionary
parsing code since it's really nice to not have

00:40:12.579 --> 00:40:15.449
to have a lot of XML parsing code in the client.

00:40:15.449 --> 00:40:16.429
It can be brittle.

00:40:16.429 --> 00:40:18.919
It requires more maintenance.

00:40:18.920 --> 00:40:25.349
There's a lot of reasons why it's nice
to do this for maintainability mostly.

00:40:25.349 --> 00:40:32.289
But there are other benefits as well for
sharing code, consistent behavior, and so on.

00:40:32.289 --> 00:40:36.329
So the second step here is to create
a shared authentication library.

00:40:36.329 --> 00:40:40.289
And we're going to leverage the transport
that we just built when we do that.

00:40:43.130 --> 00:40:47.210
And of course, the main point here is we
want to support multi-app single sign-on.

00:40:47.210 --> 00:40:49.440
And that means web apps and native apps.

00:40:49.440 --> 00:40:55.929
And we want to control access to apps in a centralized way.

00:40:55.929 --> 00:40:57.690
That's authorization, right?

00:40:57.690 --> 00:41:05.110
We want to have some system where probably it's LDAP groups
or maybe some other access control system that you have.

00:41:05.110 --> 00:41:06.039
Maybe ACLs.

00:41:06.039 --> 00:41:11.570
You want to leverage that and build
authorization right into your library

00:41:11.570 --> 00:41:15.880
so that every app that uses it gets the benefit of it.

00:41:15.880 --> 00:41:19.559
Finally, you want to implement Keychain slice sharing.

00:41:19.559 --> 00:41:27.519
And this is the key point, the tip that will allow
you to create a true multi-app single sign-on system.

00:41:27.519 --> 00:41:29.730
So let's look at how that works.

00:41:29.730 --> 00:41:33.059
So the first thing is to get Keychain access working, right?

00:41:33.059 --> 00:41:36.489
You want to be reading and writing to
the Keychain at least from one app.

00:41:36.489 --> 00:41:38.629
That's the first step.

00:41:38.630 --> 00:41:49.150
The second step is to write to a shared Keychain slice,
so to create a system by which you can share a Keychain

00:41:49.150 --> 00:41:54.280
and hence a single sign-on token
between applications, right?

00:41:54.280 --> 00:41:59.160
So how do we set this up?

00:41:59.159 --> 00:42:02.299
How do we do this Keychain slice sharing business?

00:42:02.300 --> 00:42:04.380
Well, it's not too tough.

00:42:04.380 --> 00:42:10.250
The first is you go to the Program
Portal and create a wild-card app ID.

00:42:10.250 --> 00:42:17.780
And so when you create your Enterprise account in
the developer connection for iPhone development,

00:42:17.780 --> 00:42:21.019
you'll have access to the Program Portal.

00:42:21.019 --> 00:42:28.610
And you'll go into the distribution area
and you'll create this wild-card app ID.

00:42:28.610 --> 00:42:33.269
The first portion there, those
uppercase alphanumeric characters,

00:42:33.269 --> 00:42:36.489
are a unique seed ID that's generated
for you for the portal.

00:42:36.489 --> 00:42:37.629
So there's nothing to do there.

00:42:37.630 --> 00:42:39.369
That part is automatic.

00:42:39.369 --> 00:42:44.789
The second part, com.mycompany.

00:42:44.789 --> 00:42:49.219
* is your wild-card app ID, so you
can define it however you want.

00:42:49.219 --> 00:42:53.149
It doesn't have to be only two
components, com and mycompany.

00:42:53.150 --> 00:42:53.980
It could be 3 or 4.

00:42:53.980 --> 00:42:55.380
Whatever you really want.

00:42:55.380 --> 00:42:56.059
Or it could just be *.

00:42:56.059 --> 00:42:58.849
But, excuse me.

00:42:58.849 --> 00:43:00.380
That's not right actually.

00:43:00.380 --> 00:43:10.280
Once you have that wild-card app ID, the next
step is to add a Keychain access group name

00:43:10.280 --> 00:43:12.700
to the Entitlements.plist and it looks like this.

00:43:12.699 --> 00:43:19.809
And you can do this in the plist editor,
Xcode, even in the regular text editor.

00:43:19.809 --> 00:43:27.029
And so the com.mycompany.MyGroup of course matches
the com.mycompany that you created earlier.

00:43:27.030 --> 00:43:29.450
And MyGroup is really an ad hoc stream.

00:43:29.449 --> 00:43:30.389
It can be whatever you want.

00:43:30.389 --> 00:43:37.210
It might be the name of a security principle or just
some identifier that's unique for your organization.

00:43:37.210 --> 00:43:43.470
Lastly, you want to access the shared
Keychain slice with the access group name.

00:43:43.469 --> 00:43:47.230
So it looks like this in Objective-C code.

00:43:47.230 --> 00:43:55.170
And the key point is that when you access the Keychain
you're going to read and write to it or maybe search it.

00:43:55.170 --> 00:43:57.430
You're going to pass a dictionary to it, and inside

00:43:57.429 --> 00:44:00.049
that dictionary you're going to
include the Keychain access group.

00:44:00.050 --> 00:44:05.010
This is what tells the Keychain APIs to
go ahead and write to that shared slice.

00:44:05.010 --> 00:44:15.270
[ Silence ]

00:44:15.269 --> 00:44:19.440
So the next step, and this is really
just a standard principle.

00:44:19.440 --> 00:44:25.610
Probably a lot of people that are working in information
technology are already employing mutual authentication,

00:44:25.610 --> 00:44:27.829
but I'll just go through it here
for the folks that don't know.

00:44:27.829 --> 00:44:34.420
You want to prevent man-in-the-middle
attacks and this is done with SSL, right?

00:44:34.420 --> 00:44:38.769
SSL by the nature of it supports mutual authentication.

00:44:38.769 --> 00:44:39.969
So there are two parts.

00:44:39.969 --> 00:44:43.939
The client has to authenticate the server,
and the server has to authenticate the client.

00:44:43.940 --> 00:44:49.579
So when you open up your SSL connection
that handshake is mutual authentication.

00:44:49.579 --> 00:44:53.840
There's a second part that you want to do.

00:44:53.840 --> 00:44:57.930
Since you don't want to store your
password on the device, right?

00:44:57.929 --> 00:45:03.710
You'd rather have a token, if you can, that expires, right?

00:45:03.710 --> 00:45:06.990
A password is probably a long-term password.

00:45:06.989 --> 00:45:12.179
It might need to be changed, you know, 3
months, 6 months, a year or something like that.

00:45:12.179 --> 00:45:15.659
Whereas a token will expire much more frequently.

00:45:15.659 --> 00:45:16.699
Maybe in a few hours.

00:45:16.699 --> 00:45:21.019
So it's a lot safer to use a token rather than a password.

00:45:21.019 --> 00:45:30.239
So what we have here is an application, and then
our authentication library that we just built.

00:45:30.239 --> 00:45:35.089
And we're going to go through the steps
on how we implement token verification.

00:45:35.090 --> 00:45:42.760
So the first step is to go ahead and pass the
user name and password over SSL of course,

00:45:42.760 --> 00:45:45.590
after mutual authentication to the authentication server.

00:45:45.590 --> 00:45:49.430
The authentication will go off and authenticate
with whatever your authentication system is.

00:45:49.429 --> 00:45:50.239
Maybe it's L.

00:45:50.239 --> 00:45:55.469
Maybe you have some homegrown APIs in
your organization that do authentication.

00:45:55.469 --> 00:46:01.909
Second part is to return an SSO
token to the authentication library.

00:46:01.909 --> 00:46:07.589
And that token will be stored in the share
Keychain slice that we just discussed.

00:46:07.590 --> 00:46:13.170
Third part is for the application to
go ahead and use the authentication API

00:46:13.170 --> 00:46:16.409
to pass the token over to the application server.

00:46:16.409 --> 00:46:17.739
The app server there on the left.

00:46:17.739 --> 00:46:27.479
Once the app server gets that request, and of course
the request is probably for some data to show in a view,

00:46:27.480 --> 00:46:34.750
the app server will go ahead and verify the
token with the authentication server, right?

00:46:34.750 --> 00:46:38.789
So now you've closed the authentication loop.

00:46:38.789 --> 00:46:46.110
Next, the off server will respond with an OK message.

00:46:46.110 --> 00:46:47.420
Token is verified.

00:46:47.420 --> 00:46:50.550
Go ahead and pass your data back
to the application and the user.

00:46:50.550 --> 00:46:51.920
And so that's the last step.

00:46:51.920 --> 00:46:54.289
To actually return the data to the user.

00:46:54.289 --> 00:46:57.009
So that's how token verification works.

00:46:57.010 --> 00:47:02.430
[ Silence ]

00:47:02.429 --> 00:47:07.109
So our next concept, and this is really
optional but it's worked great for us.

00:47:07.110 --> 00:47:14.000
It's allowed us to really kind of blur the
lines between web apps and native apps.

00:47:14.000 --> 00:47:20.449
Is to create a hybrid portal platform, and so
this is what Steve was alluding to earlier.

00:47:20.449 --> 00:47:26.149
So a key benefit here is that you can implement
authentication centrally for all web apps.

00:47:26.150 --> 00:47:31.369
You don't need to actually do anything
special for each web app.

00:47:31.369 --> 00:47:36.639
By default when they run in the portal they take
advantage of the authentication system that you've built.

00:47:36.639 --> 00:47:45.809
Next, you want to create stubs or web app
stubs to launch your web apps in the portal.

00:47:45.809 --> 00:47:47.489
Well, why do we need to do this?

00:47:47.489 --> 00:47:51.769
It's not required, but it's really
a nice benefit to the user.

00:47:51.769 --> 00:47:56.769
Because what it allows us to do is provide
one-touch access to web applications running

00:47:56.769 --> 00:48:01.019
within our portal app from the iPhone home screen.

00:48:01.019 --> 00:48:08.190
Otherwise, we'd need to build in some navigation within our
portal application to find these apps and to launch them.

00:48:08.190 --> 00:48:12.880
Well, wouldn't it be nice if we could just do it in
the same way that all other applications are launched

00:48:12.880 --> 00:48:15.019
on the iPhone right from the home screen?

00:48:15.019 --> 00:48:21.429
Another key benefit is that you can access native APIs
from JavaScript, and you can do that in a central way

00:48:21.429 --> 00:48:26.969
so you can offer this ability to all web
applications running within your portal.

00:48:26.969 --> 00:48:36.359
And again, the purpose here is to really kind of
blur the lines between native and web applications.

00:48:36.360 --> 00:48:40.760
The nice thing about web apps, of course, is
you get the instant deployment capability.

00:48:40.760 --> 00:48:46.930
So it's always a tough decision, you know,
whether to build a native or a web app.

00:48:46.929 --> 00:48:56.259
But you really do derive a significant benefit from having
that instant deployment, so it's something to consider.

00:48:56.260 --> 00:48:59.470
So all this works on a secure cloud architecture.

00:48:59.469 --> 00:49:06.209
And the cloud is really a set of servers outside the
firewall, and another set of servers inside the firewall.

00:49:06.210 --> 00:49:08.010
It's a proxy system that.

00:49:08.010 --> 00:49:16.520
Well, of course everything's over SSL, and it passes
the traffic through, right, on behalf of your user.

00:49:19.570 --> 00:49:23.530
So again, you're securing external data access.

00:49:23.530 --> 00:49:31.610
You're bringing data outside the firewall for
your users over SSL using this proxy cloud.

00:49:31.610 --> 00:49:33.640
Again, no VPN token needed.

00:49:33.639 --> 00:49:37.079
Well, you know, we've got such a
nice powerful device in our pockets.

00:49:37.079 --> 00:49:41.139
People rightly wonder why should we have to
carry around this VPN token with us all the time,

00:49:41.139 --> 00:49:47.079
and type these digits every time we need to
access something related to our work, you know?

00:49:47.079 --> 00:49:48.190
It's really kind of a hassle.

00:49:48.190 --> 00:49:50.720
So wouldn't it be nice to not need the VPN token?

00:49:50.719 --> 00:49:53.959
And that's exactly why we built this system.

00:49:55.340 --> 00:49:56.870
So how does the client architecture work?

00:49:56.869 --> 00:50:03.009
Well, the first part is you build these web app stubs, and
I'm going to just show you how to do that in a few minutes.

00:50:03.010 --> 00:50:10.740
But once you've got your web app stubs,
you install them onto the home screen.

00:50:10.739 --> 00:50:15.939
And when a user touches one it goes ahead
and this is sort of the last dying shout-out

00:50:15.940 --> 00:50:20.510
as the app dies as it launches the portal app.

00:50:20.510 --> 00:50:26.670
Right? So the stub dies and the portal is
launched, and it goes off and verifies the token.

00:50:26.670 --> 00:50:28.260
That's the connecting part, right?

00:50:28.260 --> 00:50:33.110
So it's doing authentication behind the scenes there.

00:50:33.110 --> 00:50:35.050
And finally it launches the web application.

00:50:35.050 --> 00:50:39.440
It lets you right in, assuming you've already
logged in, you know, earlier in the day.

00:50:39.440 --> 00:50:42.240
If not, it would pop up an authentication screen.

00:50:42.239 --> 00:50:46.689
You'd type your user name and password if it
was the first time, you know, for the day.

00:50:49.730 --> 00:50:56.469
So we have a couple concept apps here that Steve's
going to show us in a demo in a couple minutes.

00:50:56.469 --> 00:51:01.769
What this is really showing here is that
each application has its own domain.

00:51:01.769 --> 00:51:05.869
So, you know, this Directory app can't
talk to the blue app Server 2 there.

00:51:05.869 --> 00:51:07.869
It's got its own server.

00:51:07.869 --> 00:51:10.699
The traffic is routed only to its
app server it's checked, right?

00:51:10.699 --> 00:51:15.939
It's verified that it really should go
to that app server using certificates.

00:51:17.159 --> 00:51:20.339
And again, it's our second concept app here.

00:51:20.340 --> 00:51:25.750
It's living in its own domain.

00:51:25.750 --> 00:51:30.719
So to make this all happen you want to
leverage URL schemes across your applications.

00:51:30.719 --> 00:51:32.569
And this is a standard supported feature.

00:51:32.570 --> 00:51:39.750
It's been there on the MAC OS for a long time, and it's been
there, you know, on iPhone OS from the beginning as well.

00:51:39.750 --> 00:51:45.960
And so you want to launch your
app from any app on the iPhone OS.

00:51:45.960 --> 00:51:47.199
That's the key point here.

00:51:47.199 --> 00:51:49.679
You can have links on a Safari web page.

00:51:49.679 --> 00:51:51.619
You can have a link on a mail message.

00:51:51.619 --> 00:51:52.920
Maybe an SMS.

00:51:52.920 --> 00:51:55.340
Maybe in your own Cocoa Touch application.

00:51:55.340 --> 00:51:59.450
And it'll allow you to enable inner-wrap messaging.

00:51:59.449 --> 00:52:05.769
Well, you know, it's not really messaging, but what
it allows you to do is pass data between applications.

00:52:05.769 --> 00:52:10.699
So just like I showed you on the previous
slide, when one app dies it can pass parameters

00:52:10.699 --> 00:52:12.669
on the URL when it launches a second app.

00:52:12.670 --> 00:52:17.880
And then maybe that second app can go ahead
and do something on behalf of the first app,

00:52:17.880 --> 00:52:21.260
and then launch the first app and pass some parameters back.

00:52:21.260 --> 00:52:26.470
So that's kind of what the concept here is.

00:52:26.469 --> 00:52:28.339
And you just want to use it with caution.

00:52:28.340 --> 00:52:33.039
You really want to protect any
abilities that you're exposing,

00:52:33.039 --> 00:52:36.059
since you don't know who might be
calling them, with authentication.

00:52:36.059 --> 00:52:42.210
So you want to make sure that you're authenticating the user
before you go ahead and execute that action on their behalf.

00:52:42.210 --> 00:52:51.909
And so this little URL that we have
below, portal://, that's just an example.

00:52:51.909 --> 00:52:57.409
You want to define your URL schemes in such a way that
they won't collide with other people's URL schemes.

00:52:57.409 --> 00:53:03.119
So maybe a portal wasn't the best choice, but
it's good for demos and describing the concept.

00:53:03.119 --> 00:53:09.329
So what that's doing there is it's invoking the
portal, and it's calling it action launchwebapp

00:53:09.329 --> 00:53:13.730
and it's passing the parameter Dir for Directory
to launch the Directory app within the portal.

00:53:13.730 --> 00:53:17.300
So that's what that's doing there.

00:53:17.300 --> 00:53:19.990
So let's look at how we set that up.

00:53:19.989 --> 00:53:21.169
It's really pretty simple.

00:53:21.170 --> 00:53:27.090
First is to create a small Cocoa Touch project in Xcode.

00:53:27.090 --> 00:53:31.820
The next part is to launch the web app
into applicationDidFinishLaunching.

00:53:31.820 --> 00:53:34.330
And there's a little bit of code there on how to do that.

00:53:34.329 --> 00:53:35.509
It's pretty straightforward, right?

00:53:35.510 --> 00:53:44.310
You create an NSURL, set up your URL with the
proper call, and then go ahead and call openURL.

00:53:44.309 --> 00:53:50.340
That will cause this app, if this code is inside,
to shut down and it'll launch the portal app.

00:53:50.340 --> 00:53:53.030
And there is no step 3.

00:53:53.030 --> 00:53:56.120
It's really that simple to make a web app stub.

00:53:58.170 --> 00:54:03.010
So with that, Steve's going to come
up and show us how this all works.

00:54:03.010 --> 00:54:13.170
>> As you already got a look, we've created
this sort of concept for the demo here.

00:54:13.170 --> 00:54:16.690
And we're going to pretend that we're
a company with the initials A.I.

00:54:16.690 --> 00:54:18.750
It could be any company.

00:54:18.750 --> 00:54:21.250
It doesn't mean anything in particular.

00:54:21.250 --> 00:54:29.989
What we've got here is our hybrid app portal, which
has to be here in order for the web app stubs to work.

00:54:29.989 --> 00:54:32.319
But then we have these two stubs.

00:54:32.320 --> 00:54:35.390
One's labeled Directory and one's labeled Transit.

00:54:35.389 --> 00:54:40.929
And all they are, these small web stub projects
that Jake just mentioned, they only do one thing.

00:54:40.929 --> 00:54:44.159
They tell the portal what app to launch.

00:54:44.159 --> 00:54:48.049
So the very first time that a user
will do this in a day, let's say,

00:54:48.050 --> 00:54:52.000
he'll click on Directory and it'll open the portal.

00:54:52.000 --> 00:54:54.489
And they're seeing the portal because
they haven't signed in.

00:54:54.489 --> 00:54:56.169
So what you have to do.

00:54:56.170 --> 00:54:58.470
It's morning, so I haven't done this yet.

00:54:58.469 --> 00:55:07.039
I'll just put in my name and my super secret password, and
I sign in and then it will take me to that web application.

00:55:07.039 --> 00:55:10.440
So that was the interrupted case, right?

00:55:10.440 --> 00:55:15.800
An hour later I have to look up somebody
again, all I have to do is click Directory.

00:55:15.800 --> 00:55:20.600
It will launch the portal and my app.

00:55:20.599 --> 00:55:24.269
And then this becomes really powerful
when you deploy a suite of applications.

00:55:24.269 --> 00:55:25.389
I signed in for Directory.

00:55:25.389 --> 00:55:27.219
I've been using Directory today.

00:55:27.219 --> 00:55:30.759
Now I need to get a bus home and I need
to know when that bus is going to be here.

00:55:30.760 --> 00:55:36.060
If I click Transit it's checking the same token,
but it takes me to a different application.

00:55:37.659 --> 00:55:41.619
So I guess I could show you this code.

00:55:41.619 --> 00:55:43.619
It's ridiculously simple.

00:55:43.619 --> 00:55:48.009
So this is the code to launch Directory.

00:55:48.010 --> 00:55:52.550
[ Silence ]

00:55:52.550 --> 00:55:54.500
It's one class.

00:55:54.500 --> 00:56:02.170
And in our implementation file all we
did is exactly what Jake showed you.

00:56:02.170 --> 00:56:04.789
No tricks up our sleeves.

00:56:04.789 --> 00:56:08.840
It launches a single URL.

00:56:08.840 --> 00:56:10.690
And for this demo I'm.

00:56:10.690 --> 00:56:15.889
We've obscured this URL, but trust
me it really is that simple.

00:56:15.889 --> 00:56:19.619
So back to you, Jake.

00:56:19.619 --> 00:56:22.000
>> Thanks, Steve.

00:56:22.000 --> 00:56:27.329
So the seventh best practice is to think
about how to customize your deployment plan.

00:56:27.329 --> 00:56:29.429
And this really shouldn't be an after-thought.

00:56:29.429 --> 00:56:33.789
You should think about it as part of your development plan.

00:56:33.789 --> 00:56:38.650
Don't wait till the last minute to do it,
or it could be a little bit challenging.

00:56:38.650 --> 00:56:43.389
So the first thing is to create a universal
provisioning profile in the Program Portal.

00:56:43.389 --> 00:56:46.289
And this is really an Enterprise profile.

00:56:46.289 --> 00:56:52.210
So to make one of these you have
to have an Enterprise account.

00:56:52.210 --> 00:56:59.429
So once you've got the UPP, the
Distribution Profile is another name for it,

00:56:59.429 --> 00:57:05.359
you can sign your apps in Xcode
using the provisioning profile.

00:57:05.360 --> 00:57:11.590
This is what will allow you within your
organization to distribute them to your devices.

00:57:11.590 --> 00:57:18.240
So then you want to think about creating a website to
host your applications so users can download them and drag

00:57:18.239 --> 00:57:22.599
and drop them into iTunes or IPCU,
which we'll talk about in a moment.

00:57:22.599 --> 00:57:24.250
And also the UPP.

00:57:24.250 --> 00:57:28.699
So you need to get the UPP on the device once for all apps,

00:57:28.699 --> 00:57:33.799
and then you also of course want to
sync your apps on the device as well.

00:57:33.800 --> 00:57:38.960
So you can do this with iTunes or IPCU.

00:57:38.960 --> 00:57:43.170
iPhone Configuration Utility is what IPCU stands for.

00:57:43.170 --> 00:57:45.170
It's a free utility from Apple.

00:57:45.170 --> 00:57:47.349
So that's the first option.

00:57:47.349 --> 00:57:53.460
iTunes. I think we all are familiar how you
sync apps from the app store onto the device.

00:57:53.460 --> 00:57:54.820
It works just like that.

00:57:54.820 --> 00:57:56.920
There's also a nice feature.

00:57:56.920 --> 00:58:03.840
If you want to get a little bit more advanced, you
can create a script or maybe a small Cocoa application

00:58:03.840 --> 00:58:08.340
to drop your applications from some
remote location into the iTunes directory,

00:58:08.340 --> 00:58:10.530
so they'll automatically show up in iTunes.

00:58:10.530 --> 00:58:13.600
So that's the first option.

00:58:13.599 --> 00:58:14.469
It's the one we recommend.

00:58:14.469 --> 00:58:22.599
But some organizations don't like to run iTunes for various
reasons, so that's where the second option comes in.

00:58:22.599 --> 00:58:27.210
iPhone Configuration Utility is a little
bit more surgical approach, right?

00:58:27.210 --> 00:58:31.309
It won't sync your contacts or your music
or your photos or anything like that.

00:58:31.309 --> 00:58:37.269
It'll just surgically install the
application over the cable.

00:58:37.269 --> 00:58:39.050
So it's also a lot more lightweight.

00:58:39.050 --> 00:58:39.830
It's a quick download.

00:58:39.829 --> 00:58:40.429
It's free.

00:58:40.429 --> 00:58:42.309
It works on Windows.

00:58:42.309 --> 00:58:47.079
So it's a pretty effective way to get
applications on the device as well.

00:58:47.079 --> 00:58:52.889
So lastly, I just want to share with
you some of our development ideas.

00:58:52.889 --> 00:58:54.500
This is kind of fun stuff.

00:58:54.500 --> 00:58:57.320
Some of these things we've already done.

00:58:57.320 --> 00:58:59.700
Some of them we're looking at now.

00:58:59.699 --> 00:59:03.179
The first is Directory Services, and
that's the app that Steve just showed.

00:59:03.179 --> 00:59:06.869
Look up people, groups, places, applications.

00:59:06.869 --> 00:59:18.089
Great. Well, with the new location services it's a really
great opportunity to leverage that for Directory Services.

00:59:18.090 --> 00:59:21.700
What if you walked into the lobby
of a building and touched a button

00:59:21.699 --> 00:59:24.389
and got a list of conference rooms in that building?

00:59:24.389 --> 00:59:28.329
Well, maybe you know you need to go to a
particular conference room, so you touch on that

00:59:28.329 --> 00:59:30.539
and you get a map of how to find the conference room.

00:59:30.539 --> 00:59:31.619
So things like that.

00:59:31.619 --> 00:59:38.069
Leveraged location services within your directory
services infrastructure is a really good idea.

00:59:39.769 --> 00:59:40.969
Collaborative.

00:59:40.969 --> 00:59:42.559
So approvals.

00:59:42.559 --> 00:59:44.130
Meeting requests.

00:59:44.130 --> 00:59:46.410
Expense report approvals.

00:59:46.409 --> 00:59:48.019
Business process approvals.

00:59:48.019 --> 00:59:53.469
Change requests to deploy things into production.

00:59:53.469 --> 00:59:55.009
Service tickets.

00:59:55.010 --> 01:00:00.530
Group calendaring of course, right?

01:00:00.530 --> 01:00:07.560
So the thing about iPhone nowadays is it's getting
so advanced that it's hard to make a justification

01:00:07.559 --> 01:00:13.170
for building your own calendar client
or your own software on the device.

01:00:13.170 --> 01:00:18.200
But you might want to for certain key features
that are only available in your organization.

01:00:18.199 --> 01:00:21.589
But really this is more about implementing the server side

01:00:21.590 --> 01:00:24.680
and leveraging the great client
applications that are on the device.

01:00:24.679 --> 01:00:33.199
iCal or. Not iCal, but Calendar
in contacts application and so on.

01:00:33.199 --> 01:00:34.489
Remote access to voicemail.

01:00:34.489 --> 01:00:36.639
So this is a pretty cool idea.

01:00:36.639 --> 01:00:40.489
What you can do is use Audix APIs that you
probably have available in your organization

01:00:40.489 --> 01:00:47.549
to capture landline desktop voicemails, and allow people
to listen to their desktop voicemails right on the iPhone.

01:00:47.550 --> 01:00:51.500
Pretty cool idea we think.

01:00:51.500 --> 01:00:53.710
So an organizational news channel.

01:00:53.710 --> 01:00:57.380
Transit tracker is the concept that Steve just showed you.

01:00:57.380 --> 01:01:00.530
There's also another one that we
do is menu service, you know.

01:01:00.530 --> 01:01:04.680
Wouldn't it be nice to know what's for lunch?

01:01:04.679 --> 01:01:12.489
And lastly, VPN on demand is new on iPhone OS 3.0,
and we're very seriously looking at that as well.

01:01:12.489 --> 01:01:17.099
It's really outstanding because it doesn't
require you to type anything, right?

01:01:17.099 --> 01:01:26.389
You just access a website that's within the firewall and
boom, it connects automatically and lets you right in.

01:01:26.389 --> 01:01:32.509
So with that I'd like to bring
up Steve again to finish us off.

01:01:35.840 --> 01:01:36.930
>> OK. Thanks, Jake.

01:01:36.929 --> 01:01:45.480
So you've heard an awful lot about things you can
do, and we've even given you some tips on some

01:01:45.480 --> 01:01:46.840
of the things you might not have thought of.

01:01:46.840 --> 01:01:48.210
Hopefully it's new information.

01:01:48.210 --> 01:01:51.329
Hopefully we didn't bore you.

01:01:51.329 --> 01:01:56.019
And now you actually also have some
ideas on where you could go next.

01:01:56.019 --> 01:01:59.239
You might have already come here with
an idea for an internal application,

01:01:59.239 --> 01:02:02.589
but you might have thought of something
really great just now.

01:02:02.590 --> 01:02:05.300
So we just want you to remember a few things.

01:02:05.300 --> 01:02:11.140
First of all, as we've said several times, the iPhone's not
a desktop and it doesn't take a genius to figure that out.

01:02:11.139 --> 01:02:14.349
But it does take a genius to remember the details.

01:02:14.349 --> 01:02:16.920
It's not as fast.

01:02:16.920 --> 01:02:18.400
It won't last all day.

01:02:18.400 --> 01:02:20.349
Things like that.

01:02:20.349 --> 01:02:21.940
Second is test on the device.

01:02:21.940 --> 01:02:24.720
Jake hammered this point home very strongly.

01:02:24.719 --> 01:02:26.399
I totally agree with him.

01:02:26.400 --> 01:02:32.970
You can use a simulator to work out the big bugs, but
you really need to get onto the device at some point.

01:02:32.969 --> 01:02:38.209
And earlier is better before you can
say that your app is ready to ship.

01:02:38.210 --> 01:02:41.019
Third is engineer for performance.

01:02:41.019 --> 01:02:42.929
And fourth is architect for security.

01:02:42.929 --> 01:02:46.059
Both of these things are not things
you can go back and put in later.

01:02:46.059 --> 01:02:47.529
They're the foundation for your house.

01:02:47.530 --> 01:02:56.400
If they're not solid you're screwed, so you
have to think about these things up front.

01:02:56.400 --> 01:03:01.990
So if you want any more information, if you
have any questions, Mark Malone is the Internet

01:03:01.989 --> 01:03:07.559
and Server Technologies Evangelist at
Apple and he will be able to help you out.

01:03:07.559 --> 01:03:09.500
You can email him at his email address.

01:03:09.500 --> 01:03:14.530
And you can always go to the Apple website, or the
developer's website, to get any more information

01:03:14.530 --> 01:03:17.790
about developer tools, technologies,
documentation and things like that.
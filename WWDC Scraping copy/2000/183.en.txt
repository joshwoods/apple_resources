---
Title:  QuickTime for Java
Year:   2000
Web:    https://nonstrict.eu/wwdcindex/wwdc2000/183/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Thank you all for coming. This session is about QuickTime for Java. We've been in QuickTime's install since QuickTime 3. We provide a meeting place for the two very interesting technologies in both QuickTime and in Java, of course. What I'd like to do is to cover basically a sort of summation of where we are with QuickTime for Java currently.

We'd actually like to profile a couple of products that are using QuickTime for Java. If you saw the keynote this morning, you had the web objects part of that where they had the movie being shown. That was using QuickTime for Java because the runtime environment for that was actually Java. So you're seeing the QuickTime capabilities being activated.

That's very much a part of some of the uses that developers are putting QuickTime for Java to. We'll go over some other products during the talk. Then we're going to be posing a question, Java for QuickTime, Java and QuickTime. We'll come back to that Okay, so just in case you're new to the technology, I'd like to just give you a very brief overview of what QuickTime for Java is. I'm going to call it QtJava now, it's a little bit less words. So it's a Java class library and it provides access from a Java language environment, from a Java runtime environment to the underlying QuickTime engine.

What we decided to do with this was rather than to invent a completely new API, we decided to base the QuickTime for Java classes on top of the existing QuickTime C API. So we use structures that are very familiar to all of you like movies, movie controllers, tracks, media objects and so forth. And we organize these into a set of Java packages that correspond roughly to the way that QuickTime is distributed in the C headers because it kind of makes sense.

So you've got movie objects in tracks and media in movies packages. You've got sound things in sound package, sequence grabbers in a sequence package. And packages in Java are just a way of sort of breaking down the name space. It also provides some additional services. One of the things we wanted to do with QuickTime for Java was to make it easy for Java engineers and Java developers to use QuickTime in a very sort of simplified manner. If you want to make a movie and put it up in an applet, then you can do it in a couple of lines of code rather than having to write a whole bunch of C code.

And you can actually get started with QuickTime for Java with very little knowledge of QuickTime and just use some kind of helper classes and some capabilities. We also wanted to provide some extended presentation focus on presenting media in a Java environment. Giving you sort of programmatic control. We'll actually go through a demo that does some of that.

So the current release of QuickTime for Java is QtJava 4.1. We just changed the version number with QuickTime with QtJava. Originally we were going to version our releases with the version of the QuickTime API set that we are matched to, but we decided to change that just to document the version of QuickTime we go out with.

The Qt Java that's in 4.1.1 currently basically supports the 4.1 APIs that, sorry, it represents the QuickTime 4 APIs that are in the QuickTime 4 runtime and it will provide 4.1 APIs in the subsequent release. An important thing to understand about what that means is the functionality of QuickTime involves, evolves in two distinct areas.

The first area that involves is that you have an API and some additional capability of QuickTime is presented to developers and to programs using an existing API. If you think of the way that streaming was incorporated into QuickTime, for instance you can open a movie with just giving it a URL. In QuickTime 3 that was a file. When QuickTime 4 came about you could use the same API but you could open up an HTTP or FTP URL with that same API set.

So even though we may not have 4.1 APIs in the current Qt Java release, you can still access features of that. You just don't have API access to the new features. And we're going to try and bridge that gap and basically get to a parity with that at some point in the future.

Some of the biggest changes that we made in 4.1 for Qt Java was to deprecate AWT usage. Now we're not saying we don't like AWT or that we're not going to work in an AWT context, but what we wanted to do was to make an explicit statement about where you're depending on Java AWT classes and services in your Java application. Now there's a couple of reasons why we would do that. One of them we'll actually discuss a little bit later on in the session today.

In IBM's website, they've been developing a very interesting technology called Direct DOM. And it is a way for you to author a complete web page in Java, very similar to the way that you do it in JavaScript. There's a whole set of Java classes that represent the document object model of a web page as a set of Java classes. And those Java classes interact with the web browser's rendering agent in the same way that JavaScript does. But you're in Java and you have all of the extra capability of a Java VM. But the really interesting part of this is that you don't have Java AWT there.

You're not writing an applet. You're actually authoring using the JavaScript direct document model objects. So there's no AWT there. And we don't really need AWT and Qt Java as such. We have some classes that integrate with Java.AWT and for those of you who are not familiar with Java, the AWT is the display packages abstract windowing toolkit is what the AWT stands for. If you're interested in the Direct DOM technology, alphaworks.com has an alpha version of that up on the website and we'll be contributing to that with some Qt Java stuff in the near future.

So we also, as part of this migration away from a dependency on AWT, we also introduced a new event model. And we have a QtEvents superclass. It uses the same listener broadcast model that Java presents and uses throughout. We base our event subsystem on the core event class, and then the AWT event system is built off this way. And we have the same type of model. We have mouse listeners and so forth.

And we also reworked some of the way that we allow you to access QuickTime-specific features in the QtJava spaces. And in the QtZoo demo, which we'll get to fairly soon, you'll see that we have like a display space with various different elements in it. And there's a new controller architecture for the programmer to describe interest in those events and go forward from there.

The QtZoo application was written primarily to focus on and highlight some of the specific technologies that QtJava provides. Its main focus is in the areas of spaces. It uses a compositor, which will composite various different elements like text and movies. It uses mouse control handling so that the user can interact with those.

And it uses the new event handling structure that we have. And that's the new event handling structure that we have in the QtJava. So with that, I'd like to bring up Michael Hopkins. He's from Developer Relations at Apple. And he'll be talking about QtZoo. Thank you. Now the QTZoo application was developed by myself and Levi Brown, who's also here. Stand up please, Levi.

We designed this primarily as a learning tool to get people who were unfamiliar with QuickTime for Java to sort of experience the things that QuickTime for Java is good for. When most people think about QuickTime for Java, they associate QuickTime for Java with QuickTime and therefore also with movies. Everybody knows that QuickTime has rich media presentation features, support for various file system, or excuse me, media formats.

But there are a lot of other really cool things that QuickTime offers. So we wanted to go ahead and introduce and show how to use those various other types of support and brand new features. So what did we do with the Zoo project? First of all, it's designed as a kiosk application.

It's a representation of something perhaps you might find in an actual zoo at an informational booth. It runs full screen. And takes over the entire user interface. This allows us to not only customize the interface, but really take control and only show what we want to show and simplify it.

The first feature we wanted to demonstrate was the ability to do irregular region head testing. We also have transitions. We have a series of different regions in the zoo that you can mouse over, and they are not just squares. The AWT, if you were just using Java, you'd be able to do hit testing, but not in the same manner where we have very complex shapes that you can mouse in and mouse over, and I'll show that in the demo later. We also have transitions between various areas in the zoo.

We also wanted to show how to play sound, and not just AU files such as sun supports, but various other types of sound files, AU, MPEGs, etc. We wanted to show how to play movies and do custom controls. Additionally, as I mentioned, we do full screen mode. Bless you.

We also finally show how to do basic QuickTime drawing operations to draw text. So I'm going to show each one of these features individually and talk a little bit about them. As I mentioned, Qt Java allows complex region hit testing, and you do this for free. So as you can see in the tiger, when you move the mouse over that region, it automatically highlights. Get that all for free, no additional work needed.

Transitions. Since QuickTime supports all the standard types of transitions such as wipes and iris in and outs and fades and crossfades and dissolves, we decided we'd show how to take advantage of that feature. So we have two different main pages, and when you click from page to page, there's a transitional wipe between those two. It's very easy to use and it looks great. Adds that additional visual interest.

As you can hear the tiger growling, we play sounds. Sound playing is very easy. Not only do you as a developer have to not worry about the format of the sound, but you also for free get support for sounds contained on the network somewhere, either on a streaming server or on an FTP server. It doesn't matter to you as a developer where that file is. You can still use QuickTime for Java in the same manner and get that support for free.

Playing Movies. Of course, everybody knows that QuickTime gives you movie support. As I mentioned, it gives you different file type of support. MPEG, as you heard in the keynote, now we're going to be supporting MPEG-1 and MPEG-2. If you use QuickTime for Java when those features are added to QuickTime, you'll get that functionality for free in your Java application. Something that's really cool. How many Java applications can play DVD-quality movies?

Oops, excuse me. And custom controls. There's nothing wrong with the controls that QuickTime gives you. They're very nice. However, if you have an application where you want complete control, you can use QuickTime for Java's custom buttons to customize your interface. And we've done that to provide only a rewind, play, and stop button instead of allowing users to have access to the entire controller. Again, this is very easy. Finally, we allow full screen mode. Normal AWT windows do not allow you to hide the menu bar, but with QuickTime for Java, you can do so.

Oh, and basic QuickDraw text. Any QuickDraw routines, not just text drawing, but move to, line to, drawing shapes, drawing regions, you can do that in QuickTime for Java. So if you have a whole bunch of old QuickDraw toolbox code and you don't want to do AWT drawing, you can do that in a QuickDraw graphics context using QuickTime for Java. Again, this works cross-platform on Mac and Windows. Now we're going to have a demo.

So as you can see, all the media is being loaded now. As I mentioned, we have full screen. We can move around here to the various animals. You'll see how fast this highlight occurs. We're applying real-time transference effects in a Java application very fast. You can hear the sound of the elephant.

And you see the QuickTime transition there between these two panes. We have a movie playing in here. These are all different types of medias that are being drawn using QuickTime. We have Photoshop files, JPEG files, you can have TIFFs. Again, anything that QuickTime supports. Same code on your part, but you get that support.

Custom controllers here to rewind, stop, start the playing. This updating is done for you automatically. You don't have to manage individual images and refreshing those as the user interacts with those controls. So that's very powerful. Again, we can see the transitions. You also notice that it's very fast.

Do that in your Java application using JMF. And that's what I have. So thank you very much, and back to you, Bill. The main focus of this, of course, is that we're writing these applications in a Java context. We're in the QDZoo application, we're making quite extensive use of the QuickTime's capability as a media engine. As Michael was saying, we're using the transitions.

But all of the compositing that's being done there, the whole assemblage of that image that you're seeing and the control of the behavior and everything, is all being done from Java code. It's not just a movie that you've sort of authored and distributed. It's actually a running Java application.

And this is very much the kind of thing that we're seeing with developers who've been using our stuff currently, that they're in some kind of Java context, and they're using QuickTime to give them the kind of capabilities that they don't get with the normal sets of classes. classes that Java provides.

What I want to do now is go through some of the products that have been using QuickTime for Java. The CineKit is an application that is primarily focused around authoring movies. TV/Radio is a network-based radio, and we saw a bit of that in the QuickTime overview session. We've also got the Oracle Intermedia story, and we'll talk a little bit about how that's being done.

One thing I should actually say about the Zoo application before I forget is that the Zoo is broken down into a set of tutorials. There's, I think, ten tutorials just to do different parts, and that's actually available on Apple's website. We'll give you the URL at the end of the session. There's some comments, documentation about each of the examples and everything. And the whole source code for that, I think, is also available at the website. So CineKit. CineKit's a tool that's been built by a company called Expressto. The URL is expresso.com.

They're a small company. They've been working in university contexts for quite a number of years. They've been using QuickTime for a long time. They have a very unique set of requirements that they wanted from the use of QuickTime. What they wanted to be able to do was to make sure that they were able to use QuickTime for a long time.

They wanted to be able to use QuickTime for a long time. What they wanted to be able to do was to provide a different kind of metaphor for people to create presentations. They also deal with children, with youth, as well as more sort of like professors and lecturers and so forth.

They had originally started off writing in C and C++, but given the size of the company, it was actually like just a research project. They wanted to go over into Java because to get money, financial support, to support their users across different platforms, they needed to be both on Windows as well as Macintosh.

And QuickTime for Java gave them that capability because they're a QuickTime-centric tool and they can access QuickTime directly through QtJava. And of course, they chose QuickTime because of the extensive support that QuickTime has for different media formats and that was a very strong focus. But they're a Java application that's using all of the Java application frameworks. So if we can go to Demo Machine 3, please.

So this is an example of their application running. They use like a sort of a storyboard scene description type of language. And what we're basically doing here is authoring a movie. And what I'm going to do is to-- I've created a scene, and I'm going to add a couple of shots. And I can collapse the scene down, and I can open it up. Again, I can have several scenes, and away we go like that. So let's just grab a movie here.

They have this sort of preview window here. They have a sort of a movie, All through editing kind of window with in points and out points, you can see a display of the waveform that's in the movie here. You can preview the movie and all that kind of thing. And I'm not going to do anything there just for the moment. Let's grab a picture here.

Hello. I love demoing other people's products. OK, so that's not working. All right, can we go back to the slides, please? I'm not going to pursue that. Basically the idea of that, I don't know what I've done wrong, it's probably something my fault there. But basically the point about that is that it's a cross-platform company. They have the same product on both Mac and Windows. They've been in public beta for a while now. You can register with their beta program. You can download their application. It imports media, all the different types of media that QuickTime understands.

You can do media capturing into the application. And you can save all that up and export it as a movie. It's quite an interesting full-featured set. And if you go to their website, you can sign up. And they've had children using this from like year five upwards. And it's quite interesting. The second company, which is quite a bit bigger than the first one, is Oracle. Oracle have been, as you know, a database company. And they've been very interested in getting into the cataloging of media resources.

QuickTime is, as we know, is a very large market in terms of formats for media. So they have this tool called InterMedia. One of the things that Oracle has been doing over the last couple of years is moving their development efforts into Java because of their multi-platform deployment.

So InterMedia is a tool that they developed in order to be able to store media into a database, but not just the media. Media just in a database isn't very useful. You need to be able to annotate the text and annotate the media and put text fields into the database so you can actually do searches on the media or get back media from the database and so on. So Oracle.com. InterMedia is their URL. And you can go up there and have a look.

The QD Java component of this is that because they're a Java environment in the annotation side of it, they needed to access QuickTime and to be able to pull information out of QuickTime files from Java. So they used QD Java. The tool is not just a QuickTime tool, although QuickTime is a very strong part of what the tool does. It also deals with other different types of media and they have a sort of a plug-in model to do the annotation component.

of it and you can extend that and provide your own custom plug-ins for your own support, or say you want to annotate it in some different manner. Some of the information actually it pulls out. It will pull out all of the user data that is stored in the media, like author, copyright, date. It can also pull out things like the particular encoding that was used on a particular track. It can also pull out the actual text that's in the track. It can pull out other descriptions about the media that's in the movie.

One of the things that this does is it gives you a very comprehensive description of what's in that media file. And because it's in the database, it can be searched. And you can access it from even things like Sherlock. You can use standard Internet web search engines as well.

And in the demos that I've seen Oracle do this, they actually use the... I used this at the developers conference for Oracle last November. You can type in a text, go and find that text in the movie, and you can stream the movie straight from that place in the text.

You don't have to download the whole movie or whatever. You can just stream from that particular location in the movie where you found that text. And they do that through using plug-ins on the QuickTime streaming server. Tim talked a little bit about that in the overview and there will be sessions covering that.

But there's a plug-in for the streaming server that will interface to the database and will use all of their commands and everything to go and stream directly from that location. It's a very interesting technology and I'd encourage you if this is something that you do that you need to keep assets of media and stuff around, this is well worth exploring. So I'd like to now bring up a partner of Apple's really, Eric Lemoine. He works with a French company called TV Radio. Thanks.

So my name is Eric Lemoine and I'm the CEO of Vincennes Quimaux. We are a web agency based in Paris. We are more than 100 people. And last summer one of our new clients came and the name of this company is TVradio.com and these guys are owned by the French broadcast company named TDF, French Broadcast Company.

In fact, it's just a French telecom behind. Right now these guys have 95% of market share in streaming radio but over the regular network. So they are broadcasting radios. The project they asked us was to broadcast 200 French radios that are already done, already client companies and TV station by September 2000. The objective was to propose first a full service to radio, to add a multimedia experience to a radio service and synchronize in real time the content with the audio you're listening to, to develop the project around a virtual tuner and to sell records and tickets.

So all the service and feature we developed around this tuner was first to access to content based on flash movies, to access to e-business, to open our application to the web, to have some internal search engine and to have a dynamic update to the client. Each time we are using the client we are connecting to our server and updating the client and sending some new Java class. And we developed a complete workflow production process. We've done 200 Flash movies for this project. And all this project is based on first a client.

The client is running on Java, on MRG on the Mac and GRE on Windows. And behind this there is QuickTime for Java who was one of the key technology in the project. The back end is based on WebObject and with WebObject we're managing all the session with the client and with the back end. We are also using Oracle as our database and Flash generator which is one of the key technology to produce every night some content or to produce some content in real time. And we are using the QuickTime TV network to broadcast all this streaming.

I'm going to make a demo of this. So in fact as soon as you install your application you've got the TV radio alias on your machine. And then the first thing we are connecting to our server. So here we are back to France, to the UUNet data center in Paris.

So, in fact, I don't know what's going on. A few minutes ago it was working well. We are connecting to the server right now and we are trying to have access to the tuner and then we will have a synchronous interface with the audio stream and we are in real time connected to the radio to know what is on air on this radio.

So we are able to push to the users the name of the song, the name of the artist, the biography of the artist, his best stuff, and we are managing also some content value information around the radio and we are able to have access to the frequencies to the contact listing of all the speakers in this radio.

So if it's working, but it's not working, you would have seen this. Well, if the network is not working, it's going to be really hard to show you something. By the end of the show, maybe it will work. So as soon as it's working, we'll come back. Thanks.

We actually saw some of that demo in Tim's keynote, the session before this one. Of course, Mac OS X is a big part of this conference and Apple's future direction. Qt Java is available and it is on your DP4 CDs. It's working. The SDK is not actually on the DP4 CDs. You didn't quite get that cleaned up in time, but we will have that available from our website to download by probably tomorrow.

The SDK examples basically run as is. I know I've just said the SDK is not available. We've been running some shell scripts and so forth to do that. But what we're trying to get to with the Qt Java SDK is that you don't have to recompile your Java code. If you've written platform-neutral Java code, you're not doing anything based on a specific platform, which most Java applications are. The code should just run.

And that's what we're finding with the samples that we're getting up and running, that they're just running the same version that's actually out on the Qt Java 4.1 SDK. We're not even recompiling them. We just bring the Java zip files over and we run them. There's still some unresolved issues that we're working out both from the Java side and from the QuickTime side and so forth. Because we kind of sit in the middle of these two technologies and that can be an interesting experience sometimes.

So we basically consider Qt Java to be at an alpha stage where kind of the API is feature complete. There's about half a dozen or so of the SDK examples that actually run fine. We've got various different problems with others. Some are cosmetic, some are more serious. But we're on target to being complete by this and we'll certainly be in a very healthy state by the beta of Mac OS X at New York.

The SDK examples run as is. I know I've just said the SDK examples run fine. We've got various different problems with others. Some are cosmetic, some are more serious. But we're on target to being complete by this and we'll certainly be in a very healthy state by the beta of Mac OS X at New York.

If we can shift over to Demo Machine 1, please. I just thought I'd show you a couple of the Qt Java on 10 examples. So here we are on 10. This is the movie controller example, movie callbacks example in the SDK. And what this example basically does is opens a VR movie and then we've installed a bunch of callbacks that is Java code into the movie controller that is saying to the movie controller, "When something happens, I want you to tell me." So some of the callbacks that we've got are drawing callbacks.

And all that we're doing down here in the terminal window is doing like a printout of the fact that like here you see I've got a drawing command. I've got some actions here. And you can do specific things there. You can have your Java code responding to that. If I do a click to another node, you'll get callbacks, enter or leave them. nodes and all that kind of thing.

and you can install interceptor records, QDVI, you can intercept actions like a transition from one node to another action and you can do whatever you'd like to do at that point because the program is handed back control to your Java code. And that Java code will run on Mac and Windows. It's the same kind of deal. And of course we're on OS X so I can just kill the application which is one of the nice features of OS X. Maybe you don't want to be doing that all the time. This is another example in our SDK.

It's called run transitions example. It's a little scary. We've got a spaceship here. It's X-Files kind of stuff. But this is just basically to show that we've got not just movies playing in OS X but we've also got the compositing stuff that QD Java does that uses the underlying compositing engine of QuickTime.

And we've got a couple of background pictures here. We've got the ripples being applied to a picture of a water. And we've got this sprite here that's just being faded in and out. And all of this assemblage and all of the control, the timing control and everything, it has been done in the Java code. It's not a movie at this point. And I can also close things in a more traditional manner. Can we go to demo 2 machine please?

Given that we've got network problems, I'm not sure that this is going to work, but I'll try it anyway. So I'm just going to click in that movie, and then I'm going to go back to the slides, because I'm wetting your appetite for what's to come. So can we go back to the slides, please?

Okay, so the third part of this talk is Java into QuickTime. And what are we really talking about here? We're talking about the ability to not be a Java application that's using QuickTime content. What we're talking about trying to do here is to have Java code that's in the context of QuickTime. It's in a movie. And it's Java code that's going to be executed as a result of something occurring, whether it's a user or a user. It's a user interaction or just opening the movie or getting to a certain time in the movie or so forth.

What this enables is for you to provide as a developer custom actions to provide custom tailored solutions to your specific environment using a fully featured language that Java is with a full set of capabilities like URLs, like network capabilities and so forth. And of course we also support Java's security model.

So we provide the security features of Java. Now there's a couple of different ways that we could do this. The alternatives that are before us is the wide actions that QuickTime already provides. The other alternative would be to have some kind of Java media track where the media track itself was your Java code that was controlling everything that occurred in that track. And you could actually imagine a whole movie that was completely controlled by Java. So the Cutie Zoo example, for instance, that could be delivered as a Java track in a QuickTime movie and everything else is just in control from your program.

On a related area to this, there's been a lot of work in the MPEG-4 committee on a couple of different areas called BIFS and MPEG-J. So BIFS stands for Binary Format for Scenes and MPEG-J is Java in MPEG. We'll talk a little bit more about that a little later.

Okay, so for the Java wired actions, what we decided to do is to support QuickTime's existing wired action architecture in the custom action handler. This is an existing component in QuickTime. It has a subtype of wire, and for the Java wired actions, the subtype of the component is Java.

The Java wide actions component would be installed with QtJava. So it would be able to, you know, to be something that you could rely on as being installed when QtJava was installed. It uses an open component action in the movie and that's something that you have to add with the custom action handler to register the component, have the component opened. And then you attach the compiled Java bytecodes to the particular target that you want to be executing.

[Transcript missing]

To support that activity, we're developing a Java-wide action, which is an abstract class. It will be in the Qt Java. It has a number of methods that can give you the context of when this particular action has been fired. So you'll be able to get things like the movie that you're in, the track that you're in in that movie, and you'll also get an abstract execute method, and that's the part where you basically put your code.

[Transcript missing]

Okay, so I don't know if this is going to completely work because we're having some problems with the network, but we'll give it a shot. So this is a QuickTime movie, and it has a Java-wide action that's attached to the background sprite of this movie. And the background sprite of the movie is just the static picture. and I think we might be going live on the web. I'm not really sure.

Just give it a minute to see if it'll come up. What's happening with this particular Java-wide action is that it's attached to the background. Any click on that background is going to execute that wide action. When the action first fires up, If I open, so if I go back to here, which was the thing, you see that what you've got there is two, three different pictures, and you've got both a text track and you've got a video track here. And you can see a timestamp here that's changing, which is the time that I actually clicked this movie to go and get that image from a webcam, which was the Reef camera at the moment.

Now if I close that movie and open it again, you'll notice that I've actually saved the movie with the new content in it. So the click that I just did, which was at 5.18, that has now been saved in the movie. Now this is all being done for you in the movie by the Java code.

I'm writing the movie file out, and if I have a look at the original movie, you'll see that all I've got here is a single sprite track. And that sprite track has just got actions added to it. And then when I've gone out and got to the image and so forth, I've added a pick track, which is that and the text track.

We're just basically authoring the movie while the movie is alive and running. This is just a very simple example that we built up over the last week or so. We're still in very early stages with this. But you can basically do anything that you'd like to do within the bounds and the constraints of the kind of condition you're in at runtime when you're trying to do it. We've got some transparency on the text there. You can play back the movie and it's saved, etc. Shall we go back to the slides, please?

Okay, so we're in a prototype stage with this. We're really just getting this working and getting ahead to deploying this. We've been operating a seeding list for a couple of years or so now, and we continue to support that list. And we'll be seeding the Java-wide action components and the Java classes for it to developers on that list as soon as we're ready to do that in the next month or two. And there'll be details at the end of the talk that can describe to you how to get onto that seeding.

So a couple of future directions. We talked a little bit about a Java media track. This is a very interesting concept if you want to be primarily some kind of QuickTime movie and you want to interact with QuickTime's media format, but you want to actually have maybe some more dynamic behavior that you can't really get or that you want to be able to do some very intricate client-server interactions or whatever it is.

You might want to just control the whole compositing yourself or just randomly add tracks or add movies into it. So something like the QT Zoo, that could be re-embedded and deployed as a QuickTime movie. As it's very dependent on QuickTime, that kind of makes a lot of sense and it's a good distribution model for it. With MPEG-4 and the BIFS, the BIFS is a sort of a vermal type audio and visual 3D model space.

It provides a complete sort of 3D modeling area for you to create interactive scenes for. You can place audio at different locations. You can have objects moving in and out and you can construct a whole scene. Now when the MPEG-4 committee did this, they took a couple of things that they wanted to improve on with vermal.

Vermal was a textual based one and the MPEG-4 specification is a binary based one, so it's a lot smaller. It can be compressed also a lot more and it's a lot better suited for transmission over the web. The other thing that they wanted to do is to provide a much richer programmatic model in accessing the scene. And so they actually chose Java as the primary means to do that.

There is a set of Java classes and a guaranteed sort of Java VM as part of this whole BIFS implementation in MPEG-4. And some of the capability that the Java classes that have been provided by the MPEG-4 committee, some of the capability that they represent is your ability at runtime to say, "What kind of computer am I on? What kind of resolution do I have? What kind of network connection am I going to get? What are the characteristics?" You can only know when someone opens this up.

So they've provided those APIs and those controls in Java for you. So you can do that, then you can make decisions at runtime about the kind of media that you download. You can even do your own pinging using networking classes in Java to really see what kind of network performance you're getting if you want to control that kind of stuff in such a finite and intricate detail.

And this is very much the same kind of thing as having a Java media track in QuickTime in the sense that your Java code controls it. It's just that with MPEG-4 it's formalized and it's a standard that you don't have to just rely on a particular vendor to support because there's a lot of different vendors providing all kinds of different MPEG-4 solutions. And QuickTime is a very strong part of that MPEG-4 story.

So who to contact? We have a public list that's available for developers for QuickTime for Java. That's at list.apple.com. For general developer information, including the SDK and including the zoo examples that Michael went over earlier, we've got that URL there, developapple.com slash QuickTime slash QDJava. If you're interested in getting an early access to any of the seeding that we do, we actually have an email that you can email us at QDJava at apple.com and you can get enrolled. But before you email us to tell us that you want to be in the seeding, you must be a registered developer with Apple for us to do that.

So I'd like to thank you all for attending and we've got time for Q&A if you've got some questions. I'll leave these URLs up in case you want to view them. Oh, yeah, I might try the TV radio thing again, see if we can get that going. Yeah. Can we have demo station two up, please?

Hey. So the rest are very . I came from Paris for this, so I hope it's going to work this time. Basically, this application is composed of two parts. Here, all this area is managing the stream. Here, you can manage the sound. We are expecting to have in QuickTime for Java the Equalizer feature coming really soon. Here we have all the balance, treble and so on, the credits also. And here we are managing all the streams. It's a pre-selection. It's working just like your player in your car.

It's just a long click to wait for the pre-selection in memory. And if you want to have access to all our stations, right now we have 40 stations in the tuner. You just use this. We are working, here it's just a Flash Movie for the moment, but we are working on a Java tuner with a selection from style, area in Paris or in France. And so on. And here you can choose the radio you want to listen to. We can close this.

And all this area is information we are pushing to the user. And this area basically is information regarding the radio and here regarding the artist. And all this information are pushed and synchronized with the radio, with the program and with the music on air at this time in the day. At this time in this radio in Paris. All this information I push to the user, but we are able to pull, the user is able to pull some information.

For example, if you want to have the frequencies of VFM, this radio, it can access through this Flash Movie to all the friends and see where it can get the frequency of this radio. We can access to the contact information in the radio. For example, here we have all the list.

[Transcript missing]

And here you can have some information of

[Transcript missing]

We're going to come back after with this. And what else? We have a small interface.

Here, all this information area is synchronized with the music, but we are able to push some information regarding a special show. For example, you have an artist on air, which is speaking tonight at the radio. You can say, "Okay, this guy is coming tonight on the radio." And we can have flash movies accessing. All this information is a flash movie. And all the radio are able to create by themselves and manage all their content.

And they are able to say, "Okay, during two hours, we want this flash movie to be here and to have another flash movie behind in this area with more details on the product, on the show, on the concert, on everything." So all the radios are managing by themselves.

They are able to create by themselves and manage all their content. And they are able to say, "Okay, during two hours, we want this flash movie to be here and to have another flash movie behind in this area with more details on the product, on the show, on the concert, on everything." And we provide them a tool through the web with some access using a web object. And every night, hundreds of flash movies are generated.

We have some connection errors. And here we have a search engine. We are able to search in our database. For example, if you're looking for information on a radio or on an artist. And we have a web search engine here, Voila. Voila is a search engine from France Telecom. And as soon as you make your research, it's opening your web browser and that's it.

WEBVTT

00:00:11.890 --> 00:00:12.300
Hello.

00:00:12.320 --> 00:00:13.900
As he said, I'm Mike Gobbi.

00:00:13.900 --> 00:00:16.370
I'm one of the trainers here at Apple.

00:00:16.370 --> 00:00:20.150
And although I usually train
in front of crowds of people,

00:00:20.270 --> 00:00:22.480
this is a first for me
for a crowd this large.

00:00:22.670 --> 00:00:25.590
So if I seem a little bit nervous, well,
I'm not.

00:00:25.640 --> 00:00:27.980
I'm just bluffing really well.

00:00:29.380 --> 00:00:33.730
How many people here have ever
used EOF WebObjects or any

00:00:33.730 --> 00:00:35.630
of these technologies before?

00:00:36.110 --> 00:00:37.080
Almost everybody.

00:00:37.160 --> 00:00:41.150
How many people here never have?

00:00:41.150 --> 00:00:41.150
Okay.

00:00:41.610 --> 00:00:45.370
Hopefully the people who never have will
give you a quick sketch to go into this,

00:00:45.370 --> 00:00:48.950
but my basic assumption in this
exercise is that you either have

00:00:48.960 --> 00:00:52.890
a basic idea of what's happening,
or if you don't, you come and watch the

00:00:53.030 --> 00:00:56.810
previous demonstrations,
you'll have at least a few minutes

00:00:56.810 --> 00:00:58.970
old knowledge of what's happening.

00:01:00.130 --> 00:01:03.600
I'll be talking about persistent
object modeling with EOModelers,

00:01:03.720 --> 00:01:07.660
which is the technology we use to
connect from a database through

00:01:07.690 --> 00:01:12.250
the web application and out to
the browser on the user interface.

00:01:13.550 --> 00:01:17.880
So WebObjects is a new
technology from Apple that lets

00:01:17.880 --> 00:01:20.160
you build dynamic websites.

00:01:20.160 --> 00:01:23.310
And most of these websites are
backed up by relational databases.

00:01:23.480 --> 00:01:25.810
Typically you'll have an
e-commerce application that

00:01:25.810 --> 00:01:27.400
lets customers make purchases.

00:01:27.400 --> 00:01:30.370
You need to know what products
can be sold and that's all

00:01:30.370 --> 00:01:32.350
stored in a relational database.

00:01:32.400 --> 00:01:36.190
And EOF allows the persistent
access to that data within your

00:01:36.190 --> 00:01:38.330
object-oriented application.

00:01:39.030 --> 00:01:42.810
In this presentation I'll talk
about the basics of what is EOF,

00:01:42.810 --> 00:01:46.460
it's Enterprise Objects Framework,
and what is WAF,

00:01:46.460 --> 00:01:50.630
the WebObjects Framework,
and how these two technologies can work

00:01:50.630 --> 00:01:52.950
together to build your application.

00:01:53.140 --> 00:01:57.640
I'll talk a bit about EOModelers,
the tool that you actually use to

00:01:57.690 --> 00:02:02.050
configure your application and tell
it how to connect to the database.

00:02:02.640 --> 00:02:06.990
I won't be talking in this too much
detail about how databases work.

00:02:07.000 --> 00:02:09.870
So I'll give a quick sketch of the
basic technology of what a table is,

00:02:09.880 --> 00:02:13.600
what a row is, but I won't go into very
much detail beyond that.

00:02:13.600 --> 00:02:16.600
So what are the basic
concepts we need to know?

00:02:16.600 --> 00:02:19.710
Well first we need to know the
structure of a Web application,

00:02:19.730 --> 00:02:23.220
and the architecture of WebObjects
and Enterprise Objects and how they

00:02:23.410 --> 00:02:25.600
fit together to make your application.

00:02:25.600 --> 00:02:31.010
And finally I'll talk about some
entity relational modeling concepts.

00:02:32.830 --> 00:02:35.790
Start off with a web application.

00:02:35.790 --> 00:02:38.340
Typically, this is a three-tier model.

00:02:38.340 --> 00:02:40.790
On the first side, we have a browser.

00:02:40.840 --> 00:02:43.050
In the middle,
we've got your web application.

00:02:43.360 --> 00:02:47.540
And finally, backing it all up,
we have a relational database.

00:02:48.000 --> 00:02:53.230
When some user somewhere on the
internet types a URL into the browser,

00:02:53.230 --> 00:02:57.810
an HTTP request gets
sent to your application.

00:02:58.200 --> 00:03:02.150
Your application will then send
a SQL request off to the database

00:03:02.760 --> 00:03:07.630
to request the objects it needs
to service the HTTP request.

00:03:08.800 --> 00:03:16.160
The SQL database gives rows of data back
to your application as simply raw data.

00:03:16.200 --> 00:03:19.870
But because this is an
object-oriented application,

00:03:19.870 --> 00:03:25.780
those rows of data will get turned into
objects that your application can use.

00:03:26.850 --> 00:03:30.170
Your application then takes
those dynamically fetched objects

00:03:30.400 --> 00:03:35.700
and turns them into HTML to
get sent back out to the browser.

00:03:35.700 --> 00:03:40.520
And all of this is something that
we call the Request Response Loop.

00:03:42.540 --> 00:03:45.740
Now WebObjects does more than just this.

00:03:45.870 --> 00:03:50.800
It also keeps track of the unique
editing context for every user.

00:03:50.930 --> 00:03:55.110
So we already have one user who has
fetched information from the database.

00:03:55.110 --> 00:03:58.560
Perhaps they've fetched the record
and they're about to make a purchase,

00:03:58.640 --> 00:04:02.400
so we've fetched the number of
available records from the database.

00:04:02.500 --> 00:04:07.550
But while they're making the decision,
some other user comes along.

00:04:08.230 --> 00:04:12.970
and that other user will send
a request to the application,

00:04:12.970 --> 00:04:17.010
which will result in a SQL fetch
and some data coming back to

00:04:17.200 --> 00:04:19.840
the WebObjects application.

00:04:20.340 --> 00:04:26.250
And even if the same rows are
retrieved that have already

00:04:26.250 --> 00:04:26.250
been shown to the other user,

00:04:26.680 --> 00:04:31.540
EOF will create a completely different
pool of objects that are stored

00:04:31.540 --> 00:04:34.810
in a separate editing context.

00:04:34.810 --> 00:04:38.780
And that way the two users don't
interact with each other until one

00:04:38.780 --> 00:04:42.890
of them actually tries to make a
purchase or does something that will

00:04:42.900 --> 00:04:45.470
commit their changes to the database.

00:04:46.170 --> 00:04:48.840
And finally,
those objects will turn into HTML to

00:04:48.840 --> 00:04:50.690
get sent out to the second user.

00:04:52.340 --> 00:04:57.460
So the WebObjects Framework
represents the top half of this

00:04:57.550 --> 00:04:59.300
object-oriented application.

00:04:59.300 --> 00:05:04.570
The WebObjectsFramework knows how to take
these enterprise objects and turn them

00:05:04.570 --> 00:05:07.140
into HTML to be displayed on the web.

00:05:08.350 --> 00:05:13.350
The Enterprise Objects Framework,
that's the part I'll be talking

00:05:13.350 --> 00:05:15.900
about in this presentation,
knows how to talk to a database,

00:05:15.920 --> 00:05:21.430
fetch in rows of data,
and then create objects that WebObjects

00:05:21.430 --> 00:05:23.970
can then use to produce HTML.

00:05:24.320 --> 00:05:26.390
So we have a layered architecture.

00:05:26.390 --> 00:05:28.690
At the very bottom,
you'll have third-party

00:05:28.800 --> 00:05:29.910
database libraries.

00:05:29.990 --> 00:05:33.630
The Oracle database libraries,
standard ODBC libraries,

00:05:33.810 --> 00:05:36.930
whatever third-party libraries you need.

00:05:37.070 --> 00:05:39.910
On top of those we
have the adapter layer,

00:05:39.910 --> 00:05:44.480
which knows how to connect to the
database and just fetch raw data.

00:05:44.860 --> 00:05:48.770
The database layer,
which knows all about the classes in your

00:05:48.770 --> 00:05:54.900
application and knows how to turn that
raw data into an object for you to use.

00:05:55.180 --> 00:05:57.940
The Control Layer,
which keeps track of what

00:05:57.940 --> 00:05:59.230
you've done to those objects.

00:05:59.350 --> 00:06:02.250
So if you make changes,
you can eventually save those

00:06:02.250 --> 00:06:07.500
changes back into the database or
maybe undo or redo the changes.

00:06:07.600 --> 00:06:11.900
And then finally we have the
WebObjects Framework on the very top.

00:06:12.000 --> 00:06:16.440
And the WebObjects Framework knows
how to take those objects and

00:06:16.440 --> 00:06:18.970
present them to the user in HTML.

00:06:19.430 --> 00:06:24.640
And the database and adapter layer are
what we'll be editing using EOModeler.

00:06:24.990 --> 00:06:27.980
All of the changes that we make to
describe how the database and the

00:06:28.100 --> 00:06:31.900
application will interact live inside
something we call the model file.

00:06:31.900 --> 00:06:37.680
And the model file just describes a
straightforward one-to-one relationship.

00:06:37.750 --> 00:06:41.640
This class goes to this table,
this column goes to

00:06:41.640 --> 00:06:44.240
this instance variable,
although it can be more

00:06:44.240 --> 00:06:48.150
complicated if you have a class
that spans several databases.

00:06:48.380 --> 00:06:51.520
And to edit the EOModel file,
we'll use a tool cleverly

00:06:51.520 --> 00:06:54.100
enough named EOModelr.

00:06:54.160 --> 00:06:57.160
And EOModelr knows how to
configure the adapter to say which

00:06:57.290 --> 00:06:59.620
database you're connecting to.

00:06:59.670 --> 00:07:02.310
It knows how to work with the
schema to edit the entities,

00:07:02.350 --> 00:07:05.060
the attributes, and the relationships.

00:07:05.120 --> 00:07:09.300
And it can identify the various stored
procedures and let you create fetch

00:07:09.540 --> 00:07:14.240
specifications to be used later when
you actually run the application.

00:07:16.900 --> 00:07:21.410
the first step in EO model will be
to configure the database adapter.

00:07:21.410 --> 00:07:25.690
You'll choose configure adapter from
the menu bar and then from the list

00:07:25.710 --> 00:07:30.500
of available adapters you'll choose
which database you want to pick.

00:07:30.500 --> 00:07:34.980
In this case we've chosen the
Oracle database and once you go on from

00:07:34.980 --> 00:07:39.540
there you'll get a custom Oracle login
panel that lets you configure

00:07:39.660 --> 00:07:44.450
which Oracle database to connect to,
what the user name you want to use is,

00:07:44.630 --> 00:07:49.170
what the password is and when you say
okay all of that gets put into the model

00:07:49.290 --> 00:07:51.830
file for later use by your application.

00:07:51.900 --> 00:07:55.150
Once you've connected to the database
we have to work with the entities,

00:07:55.220 --> 00:07:58.700
that is the tables in the database.

00:07:58.700 --> 00:08:02.050
In the database the entity
is simply a table and in the

00:08:02.160 --> 00:08:05.600
application it's a class,
not a particular object but an

00:08:05.730 --> 00:08:10.060
entire class of objects in your
object oriented application.

00:08:10.060 --> 00:08:13.760
In this case the studio
table and the studio class.

00:08:17.310 --> 00:08:22.930
To create an entity using EOModelers,
you'll choose New Entity and using

00:08:23.070 --> 00:08:28.730
the Inspector Panel you'll specify
what the name of the table is,

00:08:28.740 --> 00:08:32.260
what the name of the entity is,
in this case the Director Entity,

00:08:32.270 --> 00:08:35.540
the name of the table,
and the name of the class

00:08:35.630 --> 00:08:37.060
in your application.

00:08:37.090 --> 00:08:40.080
And if you want to keep your life simple,
you probably want to choose similar

00:08:40.080 --> 00:08:44.310
names like Director and Director,
although EOModelers

00:08:44.310 --> 00:08:45.900
doesn't actually care.

00:08:46.340 --> 00:08:48.880
And in fact,
if you don't care about the class at all,

00:08:48.900 --> 00:08:53.370
we have a special class you can
use called the EOGeneric Record,

00:08:53.370 --> 00:08:56.200
which is essentially a
glorified dictionary.

00:08:56.280 --> 00:08:59.430
All it does is fetch data from
the database and stores it as

00:08:59.440 --> 00:09:02.740
key value pairs in a dictionary
so you can display the data,

00:09:02.740 --> 00:09:05.760
but you can't put in any
custom business logic.

00:09:05.820 --> 00:09:10.190
If you wanted custom business logic,
we'd choose a class name such as

00:09:10.190 --> 00:09:12.910
Director Class or even just Director.

00:09:13.680 --> 00:09:16.900
EOModelers also lets us
set up the attributes.

00:09:17.020 --> 00:09:20.240
In the database,
an attribute is the name of a column,

00:09:20.250 --> 00:09:24.600
in this case,
the name column of the studio table.

00:09:24.920 --> 00:09:28.670
In our object-oriented application,
it's an instance variable

00:09:28.670 --> 00:09:30.550
in the various objects.

00:09:30.690 --> 00:09:33.650
So we have the studio,
has the Warner Brothers and

00:09:33.690 --> 00:09:36.500
20th Century Fox,
and here we have two

00:09:36.620 --> 00:09:41.750
instance variables containing
Warner Brothers and 20th Century Fox.

00:09:43.810 --> 00:09:47.500
Now most attributes are what
we call simple attributes.

00:09:47.660 --> 00:09:52.540
Just simple strings, integers,
floating point numbers.

00:09:52.600 --> 00:09:58.460
An EOF automatically knows how to take
that data from the database and convert

00:09:58.460 --> 00:10:01.550
it into the appropriate Java data types.

00:10:02.990 --> 00:10:07.830
We also have more complicated data that
gets stored in the database as a blob.

00:10:07.850 --> 00:10:13.710
And a blob is just a large chunk of data,
usually containing an image or a sound,

00:10:13.710 --> 00:10:15.050
quick time movie.

00:10:15.320 --> 00:10:18.520
And they do get read out of
the database into a special

00:10:18.670 --> 00:10:20.840
class called the NSData class.

00:10:20.960 --> 00:10:28.190
And in your model file,
you specify which particular class,

00:10:28.190 --> 00:10:30.540
like NSImage or NSSound,
you want that data to turn into,

00:10:30.630 --> 00:10:35.730
and which factory method will actually
convert the data object into the

00:10:35.890 --> 00:10:37.960
particular class that you need.

00:10:38.100 --> 00:10:43.300
And finally, the third type of attribute
we'll have are key attributes.

00:10:43.470 --> 00:10:47.400
Primary keys in database
terminology are the column

00:10:47.400 --> 00:10:49.880
that uniquely identifies a row.

00:10:50.200 --> 00:10:53.780
And a foreign key is a column
that uniquely identifies

00:10:53.940 --> 00:10:55.790
the row in some other table.

00:10:56.620 --> 00:10:59.840
Now in your object-oriented application,
we don't actually have primary

00:10:59.840 --> 00:11:03.260
and foreign keys at all,
because we don't need them.

00:11:03.400 --> 00:11:06.230
Objects are intrinsically unique.

00:11:06.230 --> 00:11:09.340
This computer monitor and this
computer monitor are different

00:11:09.530 --> 00:11:11.400
because they're at different places.

00:11:11.510 --> 00:11:15.200
In the same way, in your application,
two objects are at different

00:11:15.200 --> 00:11:17.750
locations in memory,
so we don't need a primary

00:11:17.750 --> 00:11:19.010
key to tell them apart.

00:11:19.150 --> 00:11:21.390
They're already unique.

00:11:24.590 --> 00:11:27.900
So if we want to edit the
attributes in EOModelers,

00:11:28.020 --> 00:11:32.300
first we'll select the particular
entity that we want to work with,

00:11:32.320 --> 00:11:36.270
like the director,
and once the director has been selected,

00:11:36.500 --> 00:11:38.720
On the top,
we'll see a list of all of the

00:11:38.720 --> 00:11:40.400
attributes of that director.

00:11:40.400 --> 00:11:43.800
They're outlined in blue on the screen.

00:11:43.940 --> 00:11:46.890
And if we bring up our Inspector Panel,

00:11:47.570 --> 00:11:52.040
We'll see that this particular
attribute is called the Talent ID.

00:11:52.080 --> 00:11:55.720
Its database column is Talent ID.

00:11:55.810 --> 00:11:59.880
It's a long type in the database,
and in our application

00:11:59.880 --> 00:12:01.890
it's stored as an integer.

00:12:02.380 --> 00:12:05.450
Relationships are a bit more complicated.

00:12:05.450 --> 00:12:08.810
In the database,
a relationship is a join operation

00:12:09.320 --> 00:12:14.810
between the primary key of one table,
in this case the Studio ID of

00:12:14.810 --> 00:12:19.230
the Studio table,
and a foreign key of a different table,

00:12:19.230 --> 00:12:22.010
the Studio ID in the Movie table.

00:12:23.100 --> 00:12:27.200
Now in the application, when you actually
instantiate your objects,

00:12:27.210 --> 00:12:30.640
the relationship is represented
as an instance variable that

00:12:30.880 --> 00:12:32.610
points off at other objects.

00:12:32.790 --> 00:12:36.740
So here we have the movies variable,
which points to an

00:12:36.740 --> 00:12:39.310
array of movie objects.

00:12:40.020 --> 00:12:43.800
Now there's two kinds of relationships
in the database that look very similar:

00:12:43.910 --> 00:12:47.120
a 2-1 relationship or a 2-many.

00:12:47.120 --> 00:12:50.200
But in the application
they look quite different.

00:12:51.310 --> 00:12:56.280
In the application, a relationship to one
is simply a pointer,

00:12:56.280 --> 00:13:02.840
a variable that points directly
to another business object.

00:13:02.840 --> 00:13:02.840
The movie points to its studio.

00:13:03.220 --> 00:13:06.830
A Too Many Relationship,
on the other hand,

00:13:07.000 --> 00:13:09.230
points to an array of other objects.

00:13:09.370 --> 00:13:12.970
So here we have the movie
variable which refers to the

00:13:12.970 --> 00:13:15.860
array of Alien and Star Wars.

00:13:16.050 --> 00:13:21.600
We also have the choice between a
one-way or a two-way relationship.

00:13:21.780 --> 00:13:24.600
In the case of a two-way relationship,

00:13:25.690 --> 00:13:30.500
The studio knows all about its movies,
and the movies all know about

00:13:30.500 --> 00:13:32.510
the studio that they're in.

00:13:33.030 --> 00:13:38.020
But this does occupy more memory in
your application and it also introduces

00:13:38.020 --> 00:13:42.440
the possibility of inconsistency
where the movie may contain a

00:13:42.440 --> 00:13:46.000
studio but that studio doesn't
have a back pointer to the movie.

00:13:46.000 --> 00:13:50.340
So what you might choose to do
to simplify your object model

00:13:50.860 --> 00:13:55.500
is taking out the back pointers and
only have a one-way relationship.

00:13:55.610 --> 00:13:59.840
So now our studio knows about the movies,
but a given movie doesn't actually

00:13:59.840 --> 00:14:02.950
know what studio it came from.

00:14:03.280 --> 00:14:06.200
and EOModelers the way you would
do this is by only setting up

00:14:06.310 --> 00:14:08.200
one half of the relationship.

00:14:08.200 --> 00:14:11.000
You can figure the two
of them independently.

00:14:13.440 --> 00:14:16.750
So to use EOModeler to
edit our relationship,

00:14:16.750 --> 00:14:20.440
once we've selected the entity,
we'll go down to the bottom half

00:14:20.570 --> 00:14:24.640
of the screen and we'll see a
list of all of the relationships.

00:14:24.700 --> 00:14:28.840
If we select a relationship,
in this case the movie,

00:14:28.920 --> 00:14:33.430
and bring up our inspector panel,
we see that we can give it the name

00:14:33.430 --> 00:14:38.490
"Movie". The entity is a movie,
so it's a relationship from the

00:14:38.490 --> 00:14:41.200
director table to the movie table.

00:14:41.410 --> 00:14:46.170
and we're using the movie ID of the
director and the movie ID of the

00:14:46.170 --> 00:14:49.620
movie table to actually resolve this
relationship when we perform the fetch.

00:14:51.990 --> 00:14:56.740
Many-to-many relationships in the
database require a third table.

00:14:56.890 --> 00:15:00.420
This is a situation where
a movie could have multiple

00:15:00.520 --> 00:15:05.910
talents who starred in the movie,
but at the same time, a given talent,

00:15:05.980 --> 00:15:10.740
a given actor, could have acted in
several different movies.

00:15:10.850 --> 00:15:14.290
In the database,
we need a third table that's called

00:15:14.290 --> 00:15:19.120
the "join table," and it simply has the
primary keys of the appropriate movie

00:15:19.120 --> 00:15:21.520
and talent to form the relationship.

00:15:22.140 --> 00:15:25.590
In the application,
we don't need that third class

00:15:25.750 --> 00:15:31.000
because we simply have the movie
maintains an array of talent.

00:15:31.160 --> 00:15:35.140
Every piece of talent will
maintain an array of movies.

00:15:35.240 --> 00:15:40.160
And when you update the relationships,
EOModelers and EOF will automatically

00:15:40.160 --> 00:15:45.730
insert the appropriate rows into the
acted-in table to form that relationship.

00:15:45.840 --> 00:15:47.850
Happens automatically.

00:15:50.410 --> 00:15:55.600
To set up this relationship in EOModelr,
you could create that entity,

00:15:55.970 --> 00:15:59.470
create the relationships,
and put it all together by hand,

00:15:59.470 --> 00:16:01.600
but that's fairly tedious.

00:16:01.750 --> 00:16:04.770
So instead,
the engineers of Apple gave us a nice

00:16:04.770 --> 00:16:07.540
graphical user interface way to do it.

00:16:07.650 --> 00:16:12.890
We'll simply select the two entities,
in this case the movie and the talent,

00:16:13.710 --> 00:16:18.940
and from the property menu we'll
choose Join in Many-to-Many

00:16:21.020 --> 00:16:24.490
When we do that,
a third entity gets created,

00:16:24.620 --> 00:16:27.900
the Movie Talent Entity,
and all of the appropriate

00:16:27.900 --> 00:16:31.190
relationships are set up,
so that now we have the

00:16:31.290 --> 00:16:33.370
many-to-many relationship.

00:16:35.230 --> 00:16:39.990
If we were to select one of the entities,
in this case the movie,

00:16:40.120 --> 00:16:43.410
and choose the talents relationship,

00:16:44.340 --> 00:16:45.770
and bring up the inspector panel.

00:16:45.940 --> 00:16:49.670
We don't get the usual
relationship inspector.

00:16:50.000 --> 00:16:54.090
This inspector panel just tells
us that this relationship,

00:16:54.090 --> 00:16:57.230
talents,
is actually a combination of the movie

00:16:57.230 --> 00:17:03.930
talent relationship in movie and then
the talent relationship in movie talent.

00:17:03.930 --> 00:17:07.490
And we'll just use a dot
notation to join them together.

00:17:08.010 --> 00:17:11.340
We can also use EOModelers to
set up relationships between

00:17:11.340 --> 00:17:12.930
more than one database.

00:17:13.040 --> 00:17:17.030
This is especially useful when we have
to connect to legacy systems where we

00:17:17.030 --> 00:17:22.080
didn't get to design the databases and
we have one system from one company

00:17:22.080 --> 00:17:27.760
that was used one database environment
and then perhaps a newer company that

00:17:27.760 --> 00:17:32.530
has just been acquired uses a totally
different database system and your

00:17:32.530 --> 00:17:32.530
application needs to talk to both.

00:17:33.030 --> 00:17:35.390
Well, in EOModelers,
the way we'll set this up is

00:17:35.390 --> 00:17:39.320
first we'll open up the model
file for one of the databases,

00:17:39.530 --> 00:17:42.300
in this case the video rentals.

00:17:43.010 --> 00:17:46.590
And now we have another database
of all of the movies ever made:

00:17:46.730 --> 00:17:49.290
the Movie Stars database.

00:17:51.110 --> 00:17:54.120
Within the Video Rentals,
we'll simply select the entity that

00:17:54.250 --> 00:17:57.390
we want to create a relationship in.

00:17:59.060 --> 00:18:02.600
and bring up the Relationship Inspector.

00:18:02.600 --> 00:18:04.620
And there's a pop-up labeled Model.

00:18:04.790 --> 00:18:08.510
In this case it's set to Video Rentals,
a relationship back

00:18:08.510 --> 00:18:10.580
into the same database.

00:18:12.340 --> 00:18:16.480
But all we have to do is select
the pop-up list and change

00:18:16.480 --> 00:18:21.030
that to the other database,
the MovieStars database.

00:18:21.500 --> 00:18:25.050
And from there on we'll just
wire things up in the usual way.

00:18:25.050 --> 00:18:29.870
Specify which entity in the
MovieStars database we want to use,

00:18:29.870 --> 00:18:33.540
whether it's a 2-1 or
a 2-many relationship,

00:18:33.680 --> 00:18:37.970
and specify the attributes that
we'll use to create the join.

00:18:38.320 --> 00:18:43.870
And now at runtime, when you actually try
to fetch a video rental,

00:18:43.970 --> 00:18:48.270
EOF will automatically perform
a fetch across the databases,

00:18:48.270 --> 00:18:51.330
perform the appropriate
cross-database join,

00:18:51.330 --> 00:18:54.090
and retrieve all the
information that you need.

00:18:54.210 --> 00:18:57.690
If you update the relationships
and then save your changes,

00:18:57.710 --> 00:19:01.860
EOF will automatically save the
appropriate changes to each database

00:19:01.860 --> 00:19:04.240
to keep your relationships intact.

00:19:05.220 --> 00:19:09.340
So that was part one,
the basics of how does EOF work,

00:19:09.380 --> 00:19:12.320
what is EOModelers,
and what is a database anyway.

00:19:14.490 --> 00:19:18.500
Well, the next thing to do is how to work
specifically with the entities.

00:19:18.610 --> 00:19:25.640
We have a particular studio or talent
or director table in the database.

00:19:25.640 --> 00:19:27.890
Well, what do we want to do with it?

00:19:28.010 --> 00:19:32.140
We'll probably want to generate
some SQL code if we haven't already

00:19:32.140 --> 00:19:35.600
inherited a database from our legacy.

00:19:35.700 --> 00:19:39.290
You might want to browse the data,
see what's already there.

00:19:40.320 --> 00:19:42.350
If there already is a
database that exists,

00:19:42.460 --> 00:19:46.730
we might want to just pull all that
information into EOModelers and have

00:19:46.730 --> 00:19:49.990
EOModelers build our entities for us.

00:19:50.160 --> 00:19:53.240
And finally, to actually start
writing our application,

00:19:53.270 --> 00:19:56.690
we'll probably want to
generate some Java classes.

00:19:59.100 --> 00:20:06.200
To generate the SQL,
you simply select the particular entity,

00:20:06.210 --> 00:20:09.000
in this case the talent,
and bring up the SQL generation panel.

00:20:09.170 --> 00:20:12.000
And here we'll say that we
want to drop the old table,

00:20:12.000 --> 00:20:16.940
drop the old support for primary keys,
create a new table,

00:20:17.410 --> 00:20:20.560
create the new primary key support,
and we can see all of the

00:20:20.560 --> 00:20:23.000
SQL code that will get executed.

00:20:23.000 --> 00:20:26.740
And we can either execute it
immediately or save it off into

00:20:26.850 --> 00:20:30.000
a temporary file so we can give
it to a database administrator

00:20:30.000 --> 00:20:32.000
to execute on a remote server.

00:20:35.160 --> 00:20:39.270
If the database already exists,
we might want to browse the data.

00:20:39.380 --> 00:20:42.600
So in this case,
we could select the Talent table,

00:20:42.890 --> 00:20:47.650
Talent Entity, bring up the Data Browser,
and see a list of all of

00:20:47.760 --> 00:20:50.200
the talent in the database.

00:20:50.590 --> 00:20:53.460
We can also type in a
particular qualifier,

00:20:53.460 --> 00:20:57.220
last name begins with F,
and just see the talent whose

00:20:57.220 --> 00:20:58.880
last name begins with F.

00:21:02.880 --> 00:21:07.260
And if we already have a database,
which nine times out of ten is the

00:21:07.260 --> 00:21:10.240
situation because we already have
existing applications and we're now

00:21:10.240 --> 00:21:13.160
trying to move into the Internet,

00:21:13.350 --> 00:21:17.210
We can just use the reverse
engineering tools to specify

00:21:17.210 --> 00:21:21.870
which database we're using,
in this case OpenBase Lite.

00:21:22.950 --> 00:21:27.700
Bring up the login panel to specify
how to connect to that particular

00:21:27.700 --> 00:21:30.600
database and where it's located.

00:21:32.490 --> 00:21:36.640
And then choose information to help us
guide us through the creation process.

00:21:36.750 --> 00:21:39.970
Yes, we want to give primary
keys to the entities.

00:21:40.060 --> 00:21:43.080
Yes,
we want to use custom Enterprise Objects.

00:21:43.190 --> 00:21:46.320
So if there's a talent table,
we want EOModelers to automatically

00:21:46.320 --> 00:21:50.630
generate the talent class for us to use.

00:21:52.830 --> 00:21:56.340
And then finally,
select from all the tables in the

00:21:56.340 --> 00:22:02.100
database which particular tables
we want to use in the model file.

00:22:06.530 --> 00:22:10.080
And the last thing we'll want to do,
once we've already imported our model

00:22:10.150 --> 00:22:13.950
and started to work with it for a while,
and in the meantime our database

00:22:13.950 --> 00:22:16.810
administrator over in that
corner of the world is busy

00:22:16.810 --> 00:22:20.500
working with our database schema,
we need to bring these two

00:22:20.500 --> 00:22:22.710
worlds into sync again.

00:22:23.070 --> 00:22:26.210
And we can use that by,
we can do that by bringing up

00:22:26.210 --> 00:22:28.370
the synchronized schema window.

00:22:28.950 --> 00:22:33.290
And that window will list all of
the new tables in the database or

00:22:33.290 --> 00:22:37.590
new entities in your model file,
any new attributes that were added or any

00:22:37.590 --> 00:22:40.510
attributes whose properties were changed.

00:22:40.620 --> 00:22:43.340
And when you click the
synchronize button,

00:22:43.390 --> 00:22:47.620
EOModelers will automatically go
and make the appropriate changes to

00:22:47.620 --> 00:22:49.820
your model file and to the database.

00:22:54.010 --> 00:22:56.780
Once we've synchronized
and our application is now

00:22:56.780 --> 00:23:01.300
in sync with the database,
we can generate some Java classes so

00:23:01.300 --> 00:23:04.200
we can start coding our application.

00:23:04.380 --> 00:23:07.720
So again, you'll just select the entity,
the talent,

00:23:07.720 --> 00:23:12.770
say please generate some Java classes,
specify where to save them,

00:23:12.770 --> 00:23:15.890
and if you do try to
save them into a project,

00:23:15.890 --> 00:23:19.680
then the alert panel will appear asking
you whether you want to add the files to

00:23:19.840 --> 00:23:24.300
the project as well as just putting them
physically into the project directory.

00:23:25.300 --> 00:23:26.930
And at that point,
those Java classes are now

00:23:27.210 --> 00:23:29.300
standard Java source code.

00:23:29.330 --> 00:23:33.210
You can fire up Project Builder,
make any edits you need to make,

00:23:33.360 --> 00:23:36.610
and then build and run your
WebObjects application.

00:23:41.840 --> 00:23:46.400
And the last tool that EOModelers
provides is a convenient diagram view to

00:23:46.400 --> 00:23:50.110
give you a graphical view of your schema.

00:23:50.300 --> 00:23:53.850
And you can just inspect this view
to see what your various entities

00:23:53.850 --> 00:23:55.830
are and how they're related.

00:23:55.830 --> 00:23:59.160
Or if you want, you can actually do
simple edit operations,

00:23:59.290 --> 00:24:01.610
creating relationships,
breaking relationships,

00:24:01.790 --> 00:24:06.640
or renaming various attributes
directly in the diagram view.

00:24:11.300 --> 00:24:15.520
So now,
we know some basic database concepts.

00:24:15.540 --> 00:24:19.670
We know how to use EOModelers to do
a little bit of custom configuration.

00:24:19.810 --> 00:24:21.470
How do we generate the SQL?

00:24:21.560 --> 00:24:24.510
How do we generate the Java classes?

00:24:25.220 --> 00:24:29.180
Well the next step, now that we have our
application up and running,

00:24:29.180 --> 00:24:33.040
is actually going to be
to have runtime behavior.

00:24:33.190 --> 00:24:36.490
How do we validate the data,
keep bad information from

00:24:36.490 --> 00:24:38.150
hitting the database?

00:24:38.570 --> 00:24:42.740
How do we detect a conflict when two
different users are both trying to

00:24:42.740 --> 00:24:45.920
edit the same record at the same time?

00:24:47.080 --> 00:24:53.780
Shared entities we can use
for memory improvements.

00:24:53.780 --> 00:24:53.780
And then we can use stored procedures

00:24:53.840 --> 00:24:59.060
and Fetch specifications to also give
our application better performance.

00:25:01.210 --> 00:25:03.320
So there's different ways to validate.

00:25:03.410 --> 00:25:07.490
The simplest validation is
done right within EOModelers.

00:25:08.400 --> 00:25:11.200
Bring up the Inspector panel
for an attribute.

00:25:11.360 --> 00:25:17.890
Click on the second icon in the icon path
and you can see the Advanced Inspector.

00:25:18.370 --> 00:25:22.130
And in this inspector we can say
that this entity will not permit

00:25:22.130 --> 00:25:23.990
null values in the attribute.

00:25:24.260 --> 00:25:30.390
For example, a customer can't have
null for a last name.

00:25:31.000 --> 00:25:33.060
You can limit the string lengths.

00:25:33.170 --> 00:25:36.790
We won't sell to anybody whose name
contains more than 15 characters

00:25:37.510 --> 00:25:40.880
because we have an old database
that just can't cope with it.

00:25:41.650 --> 00:25:45.440
Maybe we can make our
relationships mandatory.

00:25:45.490 --> 00:25:49.240
Perhaps every customer has to
have a sales representative.

00:25:49.300 --> 00:25:52.990
Or perhaps every movie
has to have a director.

00:25:54.210 --> 00:25:59.200
and we can also specify what
happens when we do a deletion.

00:25:59.200 --> 00:26:02.480
If I delete a studio,
should I also delete all of

00:26:02.480 --> 00:26:04.500
the movies that studio created

00:26:05.670 --> 00:26:08.660
Should I set them up as
movies with no studio?

00:26:08.720 --> 00:26:11.850
Or should I in fact refuse to
allow the studio to get deleted

00:26:12.260 --> 00:26:16.990
until I've first gone through
manually and reassigned its movies?

00:26:19.350 --> 00:26:26.110
And this validation is fairly useful,
but often doesn't meet all of our needs.

00:26:26.420 --> 00:26:30.540
Maybe it's okay to have last
names that are not null or null,

00:26:30.670 --> 00:26:32.950
but what if we want to put
in rules that say the last

00:26:32.950 --> 00:26:35.140
name can't contain any spaces?

00:26:35.280 --> 00:26:39.030
That's more complicated than
EOModelers can represent.

00:26:40.110 --> 00:26:44.450
So to do that sort of validation,
in your Java class,

00:26:44.450 --> 00:26:47.750
you'll create a special
validation method.

00:26:47.890 --> 00:26:53.500
In this case, validate for save throws
an EOValidationException,

00:26:53.610 --> 00:26:56.660
and before we try to save
the changes to the database,

00:26:56.770 --> 00:26:57.720
we'll check.

00:26:57.850 --> 00:27:02.750
And if the person is too young but
claims to have a driver's license,

00:27:02.760 --> 00:27:06.160
we'll throw the exception saying,
"We're not going to let that

00:27:06.160 --> 00:27:07.770
data into the database."

00:27:08.180 --> 00:27:21.150
You can also write custom validation
methods for every attribute.

00:27:21.150 --> 00:27:21.150
So we could just say validateLastName
and that method will automatically

00:27:21.150 --> 00:27:21.150
get called if the user tries
to change somebody's last name.

00:27:23.680 --> 00:27:27.010
In addition to validation
on a single user basis,

00:27:27.010 --> 00:27:31.020
making sure that a particular
user doesn't try to let a

00:27:31.020 --> 00:27:35.170
young person drive a car,
we can also get a problem

00:27:35.180 --> 00:27:36.900
of conflict detection.

00:27:36.980 --> 00:27:40.260
Where perhaps over here
in one application,

00:27:40.320 --> 00:27:44.280
I've decided that this customer
is in fact only 13 years old

00:27:44.280 --> 00:27:46.830
because I just called her up,
talked to her parents,

00:27:46.950 --> 00:27:50.440
and found out that no,
she's not 26 after all.

00:27:50.510 --> 00:27:54.540
Meanwhile,
off in another corner of the world,

00:27:54.720 --> 00:28:00.900
some other user has called up the same
customer record and has just tried

00:28:00.900 --> 00:28:03.820
to give the user a driver's license.

00:28:04.010 --> 00:28:07.740
Now each of those operations
independently is correct,

00:28:07.790 --> 00:28:10.890
but put together,
they'll form a conflict.

00:28:11.890 --> 00:28:17.810
EOModelers and EOF supports two ways
of dealing with those conflicts.

00:28:18.430 --> 00:28:22.510
If we use pessimistic locking,
we're going to assume

00:28:22.510 --> 00:28:24.240
that there are problems.

00:28:25.390 --> 00:28:29.180
And the way we make ourselves safe with
that assumption is when EOF fetches

00:28:29.330 --> 00:28:34.500
the records out of the database,
it actually locks those rows.

00:28:34.620 --> 00:28:39.540
And no other user can fetch those
rows from the database until we

00:28:39.540 --> 00:28:42.770
either commit or revert our changes.

00:28:43.160 --> 00:28:46.120
That's very safe,
but unfortunately in the

00:28:46.120 --> 00:28:49.790
world of web browsers,
when people call up a screen,

00:28:50.030 --> 00:28:52.870
then follow a hyperlink,
then follow another hyperlink,

00:28:53.030 --> 00:28:55.690
then they go for lunch,
then the day is over and they go home,

00:28:55.690 --> 00:28:59.030
and they never did save or commit,
pessimistic locking

00:28:59.030 --> 00:29:00.210
doesn't work very well.

00:29:00.420 --> 00:29:03.890
Because now all of a sudden
nobody can use your database.

00:29:04.680 --> 00:29:09.040
So EOF also supports something
called optimistic locking.

00:29:09.040 --> 00:29:12.390
And with optimistic locking,
we will allow two users

00:29:12.390 --> 00:29:14.610
to fetch the same record.

00:29:15.010 --> 00:29:19.540
But before any user saves their
changes back into the database,

00:29:19.620 --> 00:29:24.870
EOF will automatically compare the record
in memory against the record in the

00:29:24.870 --> 00:29:27.370
database and make sure that they match.

00:29:27.760 --> 00:29:31.080
And if they don't match,
that means someone else has made a change

00:29:31.450 --> 00:29:36.680
and EOF will throw an exception and
say that we can't save those changes.

00:29:38.050 --> 00:29:43.370
And within EOModelers,
you can use the little padlock icon.

00:29:43.370 --> 00:29:43.370
It's not a suitcase.

00:29:43.770 --> 00:29:47.830
and specify which particular
attributes you care about.

00:29:47.830 --> 00:29:50.010
In this case,
we don't want anybody changing the

00:29:50.140 --> 00:29:53.490
first and last name without both of
them being changed or without one

00:29:53.590 --> 00:29:57.630
person having access to both of them,
but we don't really care

00:29:57.630 --> 00:29:58.990
about the pay grade.

00:29:59.270 --> 00:30:01.720
If I want to change somebody's
first and last name while somebody

00:30:01.720 --> 00:30:05.200
else changes their pay grade,
we don't care.

00:30:08.180 --> 00:30:11.980
So we have these exceptions
being thrown by EOF,

00:30:12.010 --> 00:30:15.240
and now we have to know how to
deal with them in your class.

00:30:15.360 --> 00:30:19.640
Well, we'll use the standard
Java exception handling mechanism.

00:30:20.070 --> 00:30:24.670
Inside our Save Changes method,
we'll ask the session for

00:30:24.770 --> 00:30:26.790
the default editing context.

00:30:26.800 --> 00:30:31.700
Remember, the default editing context is
the little pool of objects that

00:30:31.700 --> 00:30:35.140
this particular user is using,
and it's kept separate

00:30:35.140 --> 00:30:36.730
from every other user.

00:30:37.700 --> 00:30:40.570
will try to save our changes.

00:30:40.670 --> 00:30:43.470
And if there were any
validation exceptions,

00:30:43.470 --> 00:30:48.410
then we'll generate an error page
displaying the appropriate error message.

00:30:49.170 --> 00:30:53.900
If everything went through okay,
we'll return null, save our changes,

00:30:54.030 --> 00:30:55.590
and redisplay the current page.

00:30:59.000 --> 00:31:02.980
EOF also supports the
concept of shared objects,

00:31:02.980 --> 00:31:05.210
because as I said,
normally every user gets

00:31:05.360 --> 00:31:08.110
their own editing context.

00:31:08.370 --> 00:31:09.970
And that's good for security.

00:31:10.090 --> 00:31:13.570
The two users can't
interfere with each other.

00:31:13.570 --> 00:31:16.100
But it's very bad for memory.

00:31:16.150 --> 00:31:19.330
As soon as we have five
users hitting our database,

00:31:19.410 --> 00:31:24.490
every user looking at all of
the products in our catalog,

00:31:24.620 --> 00:31:28.190
suddenly we've got more memory
that our computer can handle.

00:31:28.970 --> 00:31:30.790
So we have the concept of shared objects.

00:31:30.950 --> 00:31:34.330
This is a new feature in WebObjects.

00:31:35.300 --> 00:31:40.310
If you have a read-only entity,
like the product in a catalog,

00:31:40.310 --> 00:31:42.810
you can mark it as a shared entity.

00:31:43.040 --> 00:31:46.090
And when your web
application launches up,

00:31:46.090 --> 00:31:52.430
EOF will automatically fetch all
instances of that entity into memory.

00:31:52.630 --> 00:31:59.410
and then all the different users will all
share access to those particular objects.

00:32:00.140 --> 00:32:02.450
And if, by chance,
some user should try to

00:32:02.560 --> 00:32:06.760
change one of those objects,
even though it's shared, that's okay.

00:32:06.770 --> 00:32:10.390
EOF is clever enough to notice that,
and it throws one of those validation

00:32:10.390 --> 00:32:11.900
exceptions we talked about.

00:32:12.050 --> 00:32:14.440
Tell the user, "No,
this is a read-only entity.

00:32:14.440 --> 00:32:16.600
You're not allowed to edit it."

00:32:17.970 --> 00:32:21.340
EOModelers also lets us
create stored procedures.

00:32:21.340 --> 00:32:23.700
If there's a particular fetch
operation we'll be doing

00:32:23.820 --> 00:32:27.260
over and over and over again,
we can build it

00:32:27.260 --> 00:32:30.180
graphically in EOModelers.

00:32:31.280 --> 00:32:32.740
Oh, sorry,
that was the FEPP specification.

00:32:32.910 --> 00:32:34.300
That was stored procedures.

00:32:34.410 --> 00:32:37.200
Stored procedures is what we
use to improve our performance.

00:32:37.200 --> 00:32:41.690
So we can create stored
procedures within EOModelers

00:32:42.030 --> 00:32:45.250
And then they can get triggered
automatically to inserts,

00:32:45.250 --> 00:32:49.290
updates, and deletes into any database
triggers that we want executed.

00:32:49.820 --> 00:32:52.810
We can also have fetch
specifications that we use to

00:32:52.810 --> 00:32:57.650
retrieve data from the database,
build it once in EOModelers,

00:32:57.650 --> 00:33:01.590
and then at runtime we can just
reuse that fetch specification

00:33:01.590 --> 00:33:02.880
time and time again.

00:33:04.190 --> 00:33:10.810
In EOModelers, you'll select an entity,
in this case the Talent entity,

00:33:11.020 --> 00:33:15.950
Create a new fetch specification
and then graphically assemble

00:33:16.380 --> 00:33:18.510
the query that you want.

00:33:18.880 --> 00:33:24.520
So here we want a list of all of the
actors based on the movie revenues.

00:33:24.770 --> 00:33:29.260
So we can actually build up a key
path where the actors where the roles,

00:33:29.300 --> 00:33:34.000
movies,
revenue is greater than the revenue.

00:33:34.100 --> 00:33:39.730
And all that actors, roles, movies,
date released are after a certain

00:33:40.190 --> 00:33:45.290
date and their movies date
released is before another date.

00:33:45.890 --> 00:33:50.640
And when you actually execute this fetch,
EOF will automatically perform the

00:33:50.680 --> 00:33:53.600
join operations to resolve that query.

00:33:53.690 --> 00:33:57.240
Because we actually have three
different tables involved here.

00:33:57.310 --> 00:34:00.580
There's the talent table for the actor.

00:34:01.360 --> 00:34:08.180
The Movie Table for the
movie and the Roles Table,

00:34:08.180 --> 00:34:10.870
that was the Join Table I told you about,
that actually relates an actor and

00:34:10.900 --> 00:34:12.300
the movies that they've been in.

00:34:12.300 --> 00:34:15.300
And EOF will automatically put
all that together at one time.

00:34:15.300 --> 00:34:16.300
You don't worry about it.

00:34:16.300 --> 00:34:21.000
You just call the fetch
Actor by Movie Revenue.

00:34:23.680 --> 00:34:25.850
And your source code,
the way this will look is

00:34:25.860 --> 00:34:31.210
again you'll create or get
hold of your editing context.

00:34:31.750 --> 00:34:36.600
Declare an array variable to
store the results of your fetch.

00:34:36.660 --> 00:34:38.890
And then use the EOUtilities class.

00:34:39.010 --> 00:34:44.720
This is a class that has a bunch of
static methods for common operations.

00:34:44.850 --> 00:34:49.510
So here we'll ask EOUtilities:
Please give me all of the objects with

00:34:49.510 --> 00:34:52.640
the fetch specification and bindings.

00:34:52.690 --> 00:34:56.300
And pass in the name of
the fetch specification:

00:34:56.350 --> 00:34:58.560
Actor by MovieRevenue.

00:34:58.620 --> 00:35:01.880
And then a dictionary
of key value bindings.

00:35:01.900 --> 00:35:05.870
In this case the revenue
and the before date.

00:35:06.520 --> 00:35:09.760
Now in this example,
we actually had an after date

00:35:09.760 --> 00:35:11.900
in our fetch specification.

00:35:12.020 --> 00:35:16.340
The dollar signs represent the variables
that will be looked up in the dictionary.

00:35:16.540 --> 00:35:19.770
So we have revenue, after date,
and before date.

00:35:21.750 --> 00:35:25.450
In our dictionary,
we don't provide the after date,

00:35:25.450 --> 00:35:29.430
so EOF will automatically prune
that particular clause out

00:35:29.430 --> 00:35:31.600
of the fetch specification.

00:35:31.670 --> 00:35:35.730
If you didn't provide a value,
we'll assume that you don't care.

00:35:36.660 --> 00:35:40.640
And that's the essence of how
EOF and EOModelers work together

00:35:40.640 --> 00:35:41.800
to build your application.

00:35:43.670 --> 00:35:48.200
First you use EOModeler
to inspect the database,

00:35:48.360 --> 00:35:50.580
pull in all the data
that you need to look at,

00:35:50.730 --> 00:35:56.480
set up the entities that describe how
a particular database table corresponds

00:35:56.480 --> 00:35:58.890
to a class in your application.

00:36:00.080 --> 00:36:03.350
Use EOModeler to do any custom
entity work you need to do.

00:36:03.650 --> 00:36:07.120
Generate some SQL code,
maybe set up some simple

00:36:07.120 --> 00:36:10.460
validation rules in EOModeler,
or perhaps write some more

00:36:10.460 --> 00:36:15.840
complicated validation rules
within EOF and in your Java code.

00:36:15.950 --> 00:36:18.500
And then finally,
you actually build and run

00:36:18.500 --> 00:36:22.190
the application that will be
displaying your information.

00:36:22.410 --> 00:36:25.060
And in fact,
I'll do that for you right now.

00:36:25.140 --> 00:36:29.460
We can switch over to
monitor number four.

00:36:30.670 --> 00:36:33.080
And if I had a show of
hands here in the audience,

00:36:33.080 --> 00:36:38.510
how many people here did not see
the previous presentation where you

00:36:38.510 --> 00:36:42.120
saw how EOModel and Project Builder,
how you saw WebObjects Builder

00:36:42.120 --> 00:36:44.290
and Project Builder work together?

00:36:44.390 --> 00:36:46.850
How many people here did not see that?

00:36:47.370 --> 00:36:48.140
So most people did.

00:36:48.330 --> 00:36:48.600
Good.

00:36:48.600 --> 00:36:51.590
I'll quickly sketch out
the details of that,

00:36:51.590 --> 00:36:55.290
but I'll focus most of my
attention here on EOModelers.

00:37:00.070 --> 00:37:06.200
So I'll bring up the EOModeler
application and I'll create a new model.

00:37:09.170 --> 00:37:12.640
I'll choose which type of
database I want to connect to.

00:37:12.740 --> 00:37:15.430
In this case, I'll use OpenBase Lite.

00:37:18.090 --> 00:37:22.840
OpenBase Lite is actually
a file system database.

00:37:22.960 --> 00:37:27.640
So we'll navigate off to in the file
system where the database is stored.

00:37:27.700 --> 00:37:32.910
And that is in local library databases,
the movies database.

00:37:37.810 --> 00:37:43.460
I'll say that's the
database I want to use.

00:37:43.510 --> 00:37:45.370
I then get to make some selections here.

00:37:45.400 --> 00:37:49.790
I do want to assign primary
keys to the entities.

00:37:50.240 --> 00:37:52.350
I don't want to be asked about
all of the relationships.

00:37:52.440 --> 00:37:55.890
I'll just trust EOF to
do the right thing.

00:37:56.040 --> 00:37:58.000
I don't want to be asked
about story procedures.

00:37:58.000 --> 00:38:02.730
Again, I'll just trust EOModelers and
EOF to make the right choices.

00:38:02.860 --> 00:38:06.190
And I do want to use
custom Enterprise Objects.

00:38:06.190 --> 00:38:09.600
So I do want a Director class,
a Talent class,

00:38:09.640 --> 00:38:12.690
and a Movie class in my application.

00:38:17.320 --> 00:38:20.830
On the next screen we have a list
of all the tables in that database

00:38:21.310 --> 00:38:25.680
and I choose which particular
tables I want to use in this model.

00:38:26.370 --> 00:38:30.680
Well, in this particular
table I want the movie,

00:38:30.680 --> 00:38:38.130
and I want the movie role,
and the studio, and the talent.

00:38:43.330 --> 00:38:47.030
Although EOF is going to do its
best to ask all the right questions,

00:38:47.220 --> 00:38:49.650
sometimes it does need
to come to me for help.

00:38:49.820 --> 00:38:53.310
In the case of our movie role,
there isn't a single column

00:38:53.310 --> 00:38:57.050
that's the primary key,
because that was a join table between

00:38:57.050 --> 00:39:00.350
the movie and the talent entities.

00:39:00.750 --> 00:39:04.650
So EOModelers comes back and tells me,
"I don't know which of these is meant

00:39:04.650 --> 00:39:09.060
to be the primary key." I'll tell it,
"It's actually both the

00:39:09.060 --> 00:39:11.410
movie ID and the talent ID."

00:39:13.010 --> 00:39:15.500
and I'll finish.

00:39:15.610 --> 00:39:18.370
So now we have our EOModel file.

00:39:18.990 --> 00:39:21.460
Because this is a live
demo and I am paranoid,

00:39:21.540 --> 00:39:22.900
I'll save my changes right now.

00:39:22.900 --> 00:39:30.030
And I'll call this 403/

00:39:32.130 --> 00:39:38.580
Movies It'll come up and tell me
that the 403 directory doesn't exist.

00:39:38.600 --> 00:39:42.700
I'll say, "Yes,
please create that directory for

00:39:42.700 --> 00:39:45.500
me." And here we are in EOModelr.

00:39:49.020 --> 00:39:53.790
We can select a particular entity,
the movie,

00:39:53.920 --> 00:39:57.140
and see a list of all of its attributes.

00:39:57.140 --> 00:40:02.690
So the movie has a category,
the date it was released, the movie ID,

00:40:02.920 --> 00:40:07.460
which we'll see is the primary
key of this particular entity,

00:40:07.600 --> 00:40:10.530
and it doesn't have the diamond icon.

00:40:10.730 --> 00:40:14.190
And that diamond icon tells us
whether or not there's going to be an

00:40:14.190 --> 00:40:18.440
instance variable in our application
that goes along with that column.

00:40:18.600 --> 00:40:20.480
And for the movie ID, the answer is no.

00:40:20.540 --> 00:40:25.310
We don't want the primary key to
be visible inside the application.

00:40:26.830 --> 00:40:31.070
Down below we have our relationships,
the two movie rule and the

00:40:31.230 --> 00:40:33.200
two studio relationship.

00:40:33.200 --> 00:40:36.870
And I don't like those names,
so I will change them to...

00:40:37.500 --> 00:40:43.090
The roles of the movie and
the studio of the movie.

00:40:44.520 --> 00:40:46.530
And we can also look
at the Inspector Panel.

00:40:46.580 --> 00:40:51.090
So if I select a particular attribute,
the category,

00:40:52.120 --> 00:40:54.580
I'm going to bring up
the Inspector Panel.

00:40:54.580 --> 00:40:57.480
We can see the name of it is Category.

00:40:57.480 --> 00:41:01.100
The column name in the database is,
all caps, Category.

00:41:01.100 --> 00:41:03.480
External type is Character.

00:41:03.790 --> 00:41:08.290
And internally, it's a string,
but we're going to limit the width to

00:41:08.290 --> 00:41:13.660
20 characters because that's how many
characters we can put into the database.

00:41:16.810 --> 00:41:21.540
Similarly, I could select a relationship.

00:41:21.600 --> 00:41:25.080
And the relationship
name here is "Rules."

00:41:26.770 --> 00:41:30.650
It's a relationship to
the movie role entity,

00:41:30.650 --> 00:41:33.340
and it's a one-to-many relationship.

00:41:33.520 --> 00:41:36.680
So a particular movie has a
relationship to many roles.

00:41:36.690 --> 00:41:40.200
And we're doing the join.

00:41:40.310 --> 00:41:46.020
Using the Movie ID and the
Movie ID columns of the two tables.

00:41:51.560 --> 00:41:55.100
EOModelers will also let me see the
diagram view that I showed you about,

00:41:55.260 --> 00:41:57.250
told you about before.

00:41:57.780 --> 00:42:02.940
So here we can actually view
our entire schema as a picture.

00:42:03.830 --> 00:42:08.440
And if we arrange it nicely,
we can see the relationships

00:42:08.440 --> 00:42:10.290
between our various objects.

00:42:12.200 --> 00:42:18.040
So now we see that we have the movie
and the talent are connected through

00:42:18.040 --> 00:42:23.930
this movie role and that the movie also
has a relationship to the single studio.

00:42:31.520 --> 00:42:36.340
Well, we also have more than one
relationship between movies and talent.

00:42:36.440 --> 00:42:40.390
A movie stars a number of actors,
but it's also directed

00:42:40.650 --> 00:42:43.500
by a particular director,
and some movies have

00:42:43.500 --> 00:42:45.220
more than one director.

00:42:49.100 --> 00:43:07.000
[Transcript missing]

00:43:09.580 --> 00:43:14.060
And we get another entity
here called the Movie Talent,

00:43:14.270 --> 00:43:17.500
which I happen to know because
I've seen this database before.

00:43:17.500 --> 00:43:20.270
It's actually called the Director.

00:43:20.500 --> 00:43:26.330
And the table is Director.

00:43:34.200 --> 00:43:43.990
And now, once we've done all of this,
we're ready to actually

00:43:43.990 --> 00:43:46.230
build an application.

00:43:47.720 --> 00:43:49.090
So I'll hide EOModelers.

00:43:49.210 --> 00:43:51.720
Actually, before I hide EOModelers,
I'm going to have a look at this

00:43:51.720 --> 00:43:55.590
director table and make sure it
does what I think it's going to do.

00:43:55.750 --> 00:43:59.950
The movie ID, the talent ID,
the movie ID, the talent ID.

00:43:59.950 --> 00:43:59.950
Yep.

00:44:00.800 --> 00:44:03.030
Looks good.

00:44:03.040 --> 00:44:05.910
And we can do a fetch.

00:44:07.730 --> 00:44:11.700
It says that there is no
talent ID on director.

00:44:11.700 --> 00:44:14.550
So rather than actually try
to resolve what's going on,

00:44:14.570 --> 00:44:18.190
I'll just take that out because
we don't need it for this demo.

00:44:23.240 --> 00:44:27.780
So that was the basics of how to use
EOModelers to explore a database,

00:44:27.830 --> 00:44:30.830
pull in all the
information that we needed,

00:44:30.830 --> 00:44:34.620
and then construct a model file
that described the mapping between

00:44:34.620 --> 00:44:36.600
the database and our application.

00:44:38.010 --> 00:44:44.210
I can put EOModeler away and
bring up Project Builder.

00:44:44.210 --> 00:44:47.410
And now in Project Builder,
I'll build a simple application that

00:44:47.410 --> 00:44:52.910
uses this data to actually display
some information on the screen.

00:44:56.020 --> 00:45:01.130
We'll call this the Actor App.

00:45:01.130 --> 00:45:04.400
And it's going to be a
WebObjects application.

00:45:07.510 --> 00:45:09.640
We'll say that we want some help
building this application and

00:45:09.760 --> 00:45:13.720
we're going to be using Java.

00:45:13.770 --> 00:45:17.410
And we'll open the model
file that we just built.

00:45:20.490 --> 00:45:22.930
So we'll grab the movies model file.

00:45:22.940 --> 00:45:28.430
And because this application
is called Actors,

00:45:28.430 --> 00:45:31.980
we want to display the
talent in the database.

00:45:33.680 --> 00:45:41.910
I will show a table of all of the
particular actors that match our query.

00:45:44.270 --> 00:45:47.370
We choose which attributes
we want to display.

00:45:47.370 --> 00:45:51.780
So this basic web application,
if we go back to our previous screen,

00:45:51.830 --> 00:45:58.150
is going to display a query form and then
a table of results that match the query.

00:45:58.990 --> 00:46:02.500
So what do we want to
actually show in the table?

00:46:02.600 --> 00:46:06.890
Well, let's show the first
name and the last name.

00:46:10.030 --> 00:46:14.420
And which attributes do we want the
user to be able to execute a query on?

00:46:14.710 --> 00:46:16.870
The last name, the first name,
what do we want?

00:46:17.000 --> 00:46:25.950
Let's say we want to query on
the... Let's put that back,

00:46:26.090 --> 00:46:28.000
because we want the first
name to appear first,

00:46:28.040 --> 00:46:30.090
then the last name.

00:46:32.930 --> 00:46:39.220
And now the assistant is going to go away
and actually build a project for us that

00:46:39.220 --> 00:46:44.290
once we build and execute it will give
us the user interface we've asked for.

00:46:45.430 --> 00:46:50.610
So I'll bring up the build panel
and I'll build this application.

00:46:54.080 --> 00:46:59.160
Once the application
has finished building,

00:46:59.180 --> 00:47:02.890
put that away and we'll
bring up our launch panel.

00:47:03.640 --> 00:47:07.910
and will actually run our
WebObjects application.

00:47:07.910 --> 00:47:12.430
Now after launching the server
side of the WebObjects application,

00:47:12.860 --> 00:47:16.050
WebObjects is automatically
going to launch a browser

00:47:16.050 --> 00:47:18.520
to display this information.

00:47:18.560 --> 00:47:21.880
And it does this for your
convenience as a developer.

00:47:21.920 --> 00:47:26.310
One of your final steps before you
ship an application and deploy it is

00:47:26.310 --> 00:47:29.760
to go into preferences and turn off
that preference so that you don't have

00:47:29.760 --> 00:47:34.360
a browser firing up on your server,
off in your server room.

00:47:39.710 --> 00:47:44.940
And here in OmniWeb,
we can see our application,

00:47:44.940 --> 00:47:49.460
where we can search for the talents,
specify what talents we want to display.

00:47:49.610 --> 00:47:56.010
Let's say we want everybody
whose last name begins with F.

00:48:00.620 --> 00:48:06.040
And we'll go out a list of all
the talent in our database.

00:48:06.050 --> 00:48:09.300
Actually, all the talent whose
last name begins with F.

00:48:10.550 --> 00:48:15.940
So that was the simplest case
of bringing up EOModelers,

00:48:16.050 --> 00:48:18.500
pointing at an existing
database and saying,

00:48:18.500 --> 00:48:23.360
"Please build me a database
that will work with this."

00:48:23.660 --> 00:48:28.440
and then using the assistant in
WebObjects Builder and Project Builder

00:48:28.440 --> 00:48:33.320
to actually build an application
that will display that information.

00:48:35.350 --> 00:48:38.330
Well, the more complicated case might be
if we wanted to use one of those

00:48:38.330 --> 00:48:41.180
FET specifications that I told you about.

00:48:43.430 --> 00:48:50.740
So we'll go back to Project Builder
and in our resources we'll

00:48:50.750 --> 00:48:53.020
find the movies model file

00:48:57.840 --> 00:49:04.900
And here in our movies model file,
we'll select the talent entity.

00:49:07.800 --> 00:49:11.050
And I'll say that I want to
create a fetch specification

00:49:11.050 --> 00:49:13.170
that goes along with the talent.

00:49:14.830 --> 00:49:17.800
And the fetch specification,
let's give it a name.

00:49:17.800 --> 00:49:22.920
We'll call it Fetch Actors.

00:49:26.600 --> 00:49:48.550
And we want to fetch where the
first name is like $firstname.

00:49:48.550 --> 00:49:48.550
And that $firstname means there will
be a key in the dictionary whose

00:49:48.550 --> 00:49:48.550
value is the first name we care about.

00:49:48.550 --> 00:49:48.550
And whose last name is like $firstname.

00:49:50.300 --> 00:49:57.500
[Transcript missing]

00:49:59.300 --> 00:50:06.700
[Transcript missing]

00:50:12.180 --> 00:50:17.320
So we'll save this model file now that
we've added the new fetch specification.

00:50:17.320 --> 00:50:19.790
And now,
rather than just doing query by example,

00:50:19.800 --> 00:50:25.100
we can actually use this particular
fetch specification in our application.

00:50:25.100 --> 00:50:30.270
So, we'll hide EOModelr.

00:50:34.950 --> 00:50:39.230
We'll go have a look at this component
that Project Builder and WebObjects

00:50:39.450 --> 00:50:42.380
Builder built for us automatically.

00:50:45.440 --> 00:50:49.590
And this component has the query
by example segment in which we

00:50:49.590 --> 00:50:52.570
specify the talents to display.

00:50:52.640 --> 00:50:56.400
We set their first and last name
and we have the match button.

00:50:57.120 --> 00:51:01.160
And then we have the table segment
where we actually construct the

00:51:01.160 --> 00:51:05.800
table using repeating rows and
columns to display the information.

00:51:09.610 --> 00:51:16.540
Well up here, what I'd like to do is
create another query field.

00:51:16.550 --> 00:51:19.500
So we'll say we also want
to search by movie title.

00:51:19.500 --> 00:51:27.220
And in fact, I want to make all the
fonts a bit larger.

00:51:37.200 --> 00:51:58.900
[Transcript missing]

00:52:03.200 --> 00:52:04.100
Title.

00:52:04.100 --> 00:52:09.380
And because the query
is simply a dictionary,

00:52:09.430 --> 00:52:13.590
I can associate arbitrary
key value pairs in with it.

00:52:17.630 --> 00:52:22.180
So now we have our application
which will display all the

00:52:22.180 --> 00:52:25.170
talent that we need to display.

00:52:28.170 --> 00:52:32.940
Save these changes.

00:52:33.010 --> 00:52:37.200
I'll add a special action because
we can't use our default fetch.

00:52:37.250 --> 00:52:43.840
And this action will be called Search.

00:52:43.910 --> 00:52:50.720
And we'll have a look at our source code.

00:52:50.810 --> 00:52:53.570
And our search action will say

00:53:02.200 --> 00:53:29.200
[Transcript missing]

00:53:37.740 --> 00:53:41.680
And the results will be,
we'll use eUtilities

00:53:41.680 --> 00:53:45.180
to get the objects with

00:53:48.100 --> 00:53:58.270
Objects with Fetch Specifications
and Bindings Passing the editing

00:53:58.270 --> 00:53:58.270
context The name of the entity

00:54:00.830 --> 00:54:05.140
The name of the fetch specification,
which I'm suspicious,

00:54:05.180 --> 00:54:05.940
so I'll go back and double check.

00:54:06.060 --> 00:54:09.700
Yep, and it is called Fetch Actors.

00:54:09.700 --> 00:54:14.370
And our dictionary of bindings.

00:54:14.740 --> 00:54:16.620
And then say

00:54:22.840 --> 00:54:26.560
Talent Display Group Set Object Array
Results.

00:54:26.580 --> 00:54:30.020
And the display group,
I won't go into it in a lot of detail,

00:54:30.040 --> 00:54:35.920
but essentially the display group is an
object that knows how to display objects,

00:54:35.920 --> 00:54:38.250
in particular a group of objects.

00:54:38.380 --> 00:54:42.520
In the case of Query by Example,
it built the query on the fly.

00:54:42.540 --> 00:54:45.950
In the case of our query,
we did the query by hand,

00:54:46.070 --> 00:54:48.590
so once we get the results,
we just hand the results to

00:54:48.590 --> 00:54:51.680
the display group and say,
These are the objects

00:54:51.680 --> 00:54:53.390
that you'll be managing.

00:55:01.500 --> 00:55:17.800
[Transcript missing]

00:55:24.500 --> 00:55:27.640
We'll launch the application.

00:55:27.770 --> 00:55:31.430
And now, we could again ask for

00:55:31.880 --> 00:55:36.910
All the actors whose names begin
with F by typing an F asterisk.

00:55:40.040 --> 00:55:45.540
Or, if we just wanted to know all
the actors in a particular movie,

00:55:45.650 --> 00:55:49.980
we could say we want to know all
the actors in the movie Star Wars.

00:55:52.120 --> 00:55:59.280
And it tells us that there
is no title available.

00:55:59.310 --> 00:56:02.090
And since I have only one minute left,
I'm going to say I'm not going

00:56:02.090 --> 00:56:03.320
to bother trying to debug this.

00:56:03.340 --> 00:56:06.140
And instead, I'm going to invite
Steve up on the stage,

00:56:06.140 --> 00:56:08.670
and we'll have the question and answers.
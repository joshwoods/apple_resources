WEBVTT

00:00:11.100 --> 00:00:14.940
Welcome to session 157 on
Mac OS X and localization.

00:00:14.980 --> 00:00:18.160
I think it's probably about that time
on this Thursday afternoon where you're

00:00:18.160 --> 00:00:20.230
all thinking of going to the beer bash,
so we'll try to make

00:00:20.320 --> 00:00:20.890
this short and sweet.

00:00:21.000 --> 00:00:22.940
My name is Chris Hansten.

00:00:23.010 --> 00:00:26.990
I work in the localization and
integration group here at Apple.

00:00:26.990 --> 00:00:29.000
In just a couple of minutes,
we're going to bring Mike up here,

00:00:29.000 --> 00:00:31.680
one of our engineers,
and he's going to discuss some of the

00:00:31.710 --> 00:00:35.000
APIs that we've developed and how to make
your software work well for localization.

00:00:35.000 --> 00:00:38.270
But before we do that,
I want to say just a couple of words on

00:00:38.270 --> 00:00:42.710
why we think localization is actually a
very strategic thing and something you

00:00:42.710 --> 00:00:45.430
should consider for all of your products.

00:00:45.820 --> 00:00:51.180
So, now Apple has always considered
localization very strategic and

00:00:51.180 --> 00:00:52.460
very important to our business.

00:00:52.520 --> 00:00:55.270
And that first line up there on
that slide says all you really

00:00:55.280 --> 00:00:56.660
need to hear about why that is.

00:00:56.660 --> 00:00:58.340
It makes it very obvious.

00:00:58.400 --> 00:01:02.750
Approximately one half of Apple's
computers are sold outside the U.S.

00:01:03.140 --> 00:01:06.360
That's 50% of course of the market
for your applications as well.

00:01:06.450 --> 00:01:11.140
So, now there's no way we can position
ourselves in the market this way and

00:01:11.140 --> 00:01:15.490
sell all these Macs overseas without
significant investment in high quality

00:01:15.490 --> 00:01:17.300
localization of our system software.

00:01:17.590 --> 00:01:20.600
In fact,
this is so important to us that we do,

00:01:20.710 --> 00:01:23.880
we go to great lengths to deliver
our operating system software

00:01:23.960 --> 00:01:27.740
and CPU software virtually
simultaneously with the U.S.

00:01:27.800 --> 00:01:28.520
product.

00:01:28.720 --> 00:01:31.600
Now, with Mac OS X,
we want to do this even better.

00:01:31.660 --> 00:01:34.890
And we've put some capabilities in
our operating system that should make

00:01:34.890 --> 00:01:37.660
this easier both for us and for you.

00:01:39.400 --> 00:02:56.700
[Transcript missing]

00:02:56.850 --> 00:03:00.620
For example, multiple localizations
can now be packaged and

00:03:00.620 --> 00:03:03.700
included in a single product,
which cuts down significantly on the

00:03:03.700 --> 00:03:06.500
overhead in delivering localized product.

00:03:06.550 --> 00:03:10.850
As well, alternatively,
a language add-on for your app can

00:03:10.850 --> 00:03:13.860
be easily packaged and delivered as,
say, a web download.

00:03:13.900 --> 00:03:16.860
And this allows you some flexibility
in doing your scheduling around

00:03:16.860 --> 00:03:20.350
localization and scheduling,
you know, vis-a-vis your US product.

00:03:20.490 --> 00:03:23.890
So these sorts of things are
possibilities generated by these

00:03:23.890 --> 00:03:26.260
APIs and these capabilities in the OS.

00:03:26.280 --> 00:03:29.870
Now, as you can see,
we're very excited ourselves to use these

00:03:30.140 --> 00:03:32.600
capabilities within our own products.

00:03:32.640 --> 00:03:35.850
And we want to encourage all of you
to do that as well in your products.

00:03:35.970 --> 00:03:38.780
So to do that,
let's get straight to the fun

00:03:38.780 --> 00:03:42.530
stuff and have Mike come up here
and give some demonstrations and

00:03:42.530 --> 00:03:44.530
describe these technologies to you.

00:03:44.590 --> 00:03:47.160
So, Mike.

00:03:48.300 --> 00:03:56.550
Chris Hansen: Is my mic live?

00:03:56.550 --> 00:03:56.550
Okay, there it is.

00:03:57.270 --> 00:04:01.450
I want to talk to you just a
bit about localization on OS X.

00:04:01.450 --> 00:04:05.300
And what we're going to cover
is basically what you need to

00:04:05.300 --> 00:04:09.850
be thinking of to produce an
application that's localizable,

00:04:09.850 --> 00:04:14.040
and then how the core foundation
frameworks help you in your code to

00:04:14.040 --> 00:04:19.080
deal with these issues and to build
an application which is localizable.

00:04:19.200 --> 00:04:22.440
And then finally,
we're going to look a little bit

00:04:22.440 --> 00:04:25.480
about how Project Builder supports
this in the development cycle.

00:04:26.700 --> 00:04:29.680
First of all,
let's look a little bit about

00:04:29.680 --> 00:04:32.580
delivering localized applications.

00:04:32.750 --> 00:04:37.930
The old way,
a separate application for each language.

00:04:38.080 --> 00:04:41.300
You have to have multiple SKUs,
multiple boxes, packaging,

00:04:41.300 --> 00:04:42.440
all this stuff.

00:04:42.580 --> 00:04:46.690
And you also then,
if you want to have multiple

00:04:46.690 --> 00:04:48.940
languages supported,
have to have multiple copies

00:04:48.990 --> 00:04:50.120
of that app on the system.

00:04:50.120 --> 00:04:54.400
So it's not very good for a multi-user
situation where you might have some

00:04:54.400 --> 00:04:58.980
people using your application who want
to run it in one language and some other

00:04:58.980 --> 00:05:01.480
people who want to run it in another.

00:05:02.560 --> 00:05:08.360
What we want to move towards is one
of the two second possibilities here.

00:05:08.530 --> 00:05:11.910
Either you simultaneously ship
your application that contains

00:05:11.910 --> 00:05:14.160
all of the localizations together.

00:05:14.290 --> 00:05:16.420
Now this would be ideal,
but we recognize that it's

00:05:16.420 --> 00:05:18.030
not always totally practical.

00:05:18.130 --> 00:05:21.940
Not everybody can spend the
effort to actually produce all

00:05:22.040 --> 00:05:27.250
the localizations before they
actually can sell one of them.

00:05:27.400 --> 00:05:30.940
We don't force you to do this,
but it's totally possible.

00:05:31.030 --> 00:05:36.300
The other option is you just
ship localizations as you finish

00:05:36.300 --> 00:05:39.960
them after you ship the main app,
but all they are is add-ons.

00:05:40.060 --> 00:05:42.200
It's not a whole other
copy of the application,

00:05:42.340 --> 00:05:46.500
and the installation ends up
merging the new localizations into

00:05:46.500 --> 00:05:49.300
the app that the user already has.

00:05:50.520 --> 00:05:53.690
Now, what I want to demo first,
if we can get the demo

00:05:53.690 --> 00:05:57.890
machine up on the display,
is just what it means for an

00:05:57.970 --> 00:06:01.210
application to be multiply localized.

00:06:03.490 --> 00:06:05.520
You've probably seen this
panel in a few other talks.

00:06:05.520 --> 00:06:08.400
This is the
International Preferences panel.

00:06:08.500 --> 00:06:13.310
And this list here is basically, for me,
the person who's logged

00:06:13.310 --> 00:06:15.660
into this machine,
what's the preferred

00:06:15.660 --> 00:06:17.670
ordering of languages for me?

00:06:18.030 --> 00:06:20.700
And, okay,
so I might want to see English, you know,

00:06:20.730 --> 00:06:22.550
primarily.

00:06:22.670 --> 00:06:28.300
And if I launch an application, you know,
we can see that it comes up in English.

00:06:28.690 --> 00:06:30.060
Okay, easy enough.

00:06:30.210 --> 00:06:32.050
You've probably seen that.

00:06:32.160 --> 00:06:36.610
But what if I reordered this
list and say that I'd like to see

00:06:36.610 --> 00:06:38.830
French first if it's available?

00:06:39.070 --> 00:06:42.160
Well, now, you know,
it comes up in French when

00:06:42.160 --> 00:06:44.180
I launch this application.

00:06:45.010 --> 00:06:47.380
These preferences are per user,
so if you have multiple

00:06:47.380 --> 00:06:50.110
users that use the machine,
they all get their own

00:06:50.120 --> 00:06:52.640
list of ordered languages.

00:06:52.660 --> 00:06:56.070
Somebody might want to
see Japanese instead.

00:06:58.850 --> 00:07:01.880
The app launches in Japanese.

00:07:02.000 --> 00:07:03.750
This is the same app recognized, right?

00:07:03.890 --> 00:07:06.560
But it's just that depending
on what my preferences are,

00:07:06.560 --> 00:07:09.820
it's going to pick the
localization that's appropriate.

00:07:10.230 --> 00:07:12.240
All right,
so that's the end of the first demo here.

00:07:12.310 --> 00:07:14.600
We can go back to the slides.

00:07:21.700 --> 00:07:25.510
So, all right, first of all,
what does it mean to be localizable?

00:07:25.540 --> 00:07:28.230
Localizable is different from localized,
right?

00:07:28.370 --> 00:07:33.650
Localizable means that it's possible
to localize this application,

00:07:33.790 --> 00:07:34.000
right?

00:07:34.440 --> 00:07:38.700
The developer can easily produce
a localizable application.

00:07:38.700 --> 00:07:40.350
You know,
they don't have to speak any languages

00:07:40.350 --> 00:07:41.700
other than their native language.

00:07:41.700 --> 00:07:44.700
They can still produce an
application that can be translated.

00:07:44.700 --> 00:07:47.690
And that's what you should be
shooting for as a developer.

00:07:47.800 --> 00:07:50.200
You should build an application
that could be translated,

00:07:50.240 --> 00:07:51.680
even if you don't plan
to do it right now.

00:07:51.700 --> 00:07:55.420
Because later, you might want to do that.

00:07:55.420 --> 00:07:57.930
And if it's localizable,
it'll be very easy to do that.

00:07:57.930 --> 00:07:59.660
You won't have to rev your code at all.

00:07:59.660 --> 00:08:02.340
You just have to send your
resources off to some translator,

00:08:02.340 --> 00:08:04.730
who will then translate it
into the target language,

00:08:04.730 --> 00:08:06.530
send it back to you,
you put it in the app,

00:08:06.610 --> 00:08:07.970
and it all just works.

00:08:10.570 --> 00:08:14.750
What the developer has to be
aware of is not necessarily issues

00:08:14.750 --> 00:08:19.280
specific to any language or region,
but just general issues that

00:08:19.300 --> 00:08:22.080
have to do with localizability.

00:08:22.330 --> 00:08:27.560
So you want to have your code
deal with strings in a way that's

00:08:27.590 --> 00:08:32.330
flexible enough that it's going to
work for strings in any language.

00:08:32.450 --> 00:08:34.760
Carstar is no good, right?

00:08:34.800 --> 00:08:35.760
You want to use something else.

00:08:35.820 --> 00:08:39.510
We'll get into how that is
supported in Core Foundation.

00:08:39.960 --> 00:08:44.380
You want to look at the same
issue with regard to file formats.

00:08:44.380 --> 00:08:46.680
Don't use ASCII in your file
format if you can help it.

00:08:46.840 --> 00:08:50.520
Use something that can
represent more languages.

00:08:51.830 --> 00:08:54.530
You want to deal with text input issues.

00:08:54.650 --> 00:09:01.040
So not all languages are as simple
and easy to type as English.

00:09:01.910 --> 00:09:04.870
Typing Japanese can be very complex
because there are so many different

00:09:04.920 --> 00:09:08.200
characters and you're not going to have
a keyboard with 50,000 characters on it.

00:09:08.200 --> 00:09:12.060
So you have to have some sort of
input method that lets users type

00:09:12.060 --> 00:09:15.490
in arbitrarily complex languages.

00:09:16.880 --> 00:09:20.620
You also have to be aware of things
like differing formats for dates

00:09:20.620 --> 00:09:24.600
and numbers and so on and so forth,
and even potentially differing

00:09:24.700 --> 00:09:28.120
formats of various hardware
standards that are available in

00:09:28.120 --> 00:09:30.150
different areas of the world.

00:09:30.250 --> 00:09:32.690
And then finally,
and what people always think

00:09:32.690 --> 00:09:35.900
about sort of first when you
think about localization is,

00:09:35.900 --> 00:09:38.650
you have to make sure that all of
your interface and all of the other

00:09:38.650 --> 00:09:44.310
resources that might be different
for different languages can be.

00:09:46.020 --> 00:09:48.270
Let's look at how
Core Foundation actually

00:09:48.270 --> 00:09:49.900
helps you to achieve this.

00:09:49.900 --> 00:09:52.900
We won't go through all of
the things that I just listed,

00:09:52.900 --> 00:09:55.620
but we'll cover most of them here.

00:09:56.630 --> 00:10:01.530
Some of the main classes, I'll call them,
even though they're not

00:10:01.530 --> 00:10:05.490
really in core foundation,
which help you with this sort of

00:10:05.850 --> 00:10:08.000
thing are CFString and CFCharacterSet.

00:10:08.000 --> 00:10:11.550
Those help you deal with strings
in a way that will not limit

00:10:11.550 --> 00:10:13.810
you to a particular script.

00:10:14.750 --> 00:10:18.780
CF Property List and CF XML Parser.

00:10:18.830 --> 00:10:26.210
These are options for file formats that
will be totally internationalizable.

00:10:27.000 --> 00:10:30.920
And then CFBundle,
which is really a very central

00:10:30.920 --> 00:10:34.020
piece of the system on Mac OS X.

00:10:34.020 --> 00:10:35.930
And in addition to all the
other things that it does,

00:10:35.930 --> 00:10:38.970
it helps make sure that you're
going to get the right versions

00:10:38.990 --> 00:10:43.490
of your localizable resources when
the user runs your application.

00:10:43.570 --> 00:10:46.500
If you use CFBundle properly,
you won't have to worry about the

00:10:46.590 --> 00:10:48.210
user's preferred language order.

00:10:48.540 --> 00:10:50.570
It'll all just work.

00:10:52.630 --> 00:10:56.410
So what about strings?

00:10:56.460 --> 00:11:03.720
CFString should be used as much
as you possibly can in your app.

00:11:03.780 --> 00:11:07.820
Use it instead of Carstar everywhere
in your internal representations.

00:11:07.860 --> 00:11:12.820
Avoid converting it to Carstars or
Pascal strings whenever you can.

00:11:12.860 --> 00:11:15.080
CFStrings are Unicode strings.

00:11:15.160 --> 00:11:18.970
So Unicode can represent text in
almost any language in the world,

00:11:18.970 --> 00:11:19.300
right?

00:11:19.340 --> 00:11:20.580
Maybe any language.

00:11:20.640 --> 00:11:24.110
No, OK, almost any language at least.

00:11:24.710 --> 00:11:29.220
And when you do have to actually
deal with other character encodings,

00:11:29.220 --> 00:11:32.720
CsString also provides
conversion facilities.

00:11:34.170 --> 00:11:38.580
So, okay, here are a few tips for
dealing with strings.

00:11:38.590 --> 00:11:41.030
First of all,
the Unicode spec is fairly complicated,

00:11:41.030 --> 00:11:45.290
and to correctly handle Unicode strings,
there are a lot of details.

00:11:46.040 --> 00:11:50.450
Unless this is your domain of expertise,
you probably don't want to

00:11:50.450 --> 00:11:51.900
get involved in these details.

00:11:51.960 --> 00:11:55.850
So let CFString do it.

00:11:58.290 --> 00:12:02.640
Avoid going through a string
character by character.

00:12:02.640 --> 00:12:05.440
In Unicode,
there's almost always an infinite number

00:12:05.440 --> 00:12:09.200
of ways that basically the same semantic
content could be represented in a string.

00:12:09.200 --> 00:12:14.670
There's different forms you can
use that basically don't go through

00:12:14.730 --> 00:12:19.700
character by character doing
comparisons because it's not going

00:12:19.700 --> 00:12:22.190
to necessarily be the right thing.

00:12:22.950 --> 00:12:24.700
So use built-in character sets.

00:12:24.720 --> 00:12:30.970
The CF Character Set class allows you
to test for membership in certain sets.

00:12:30.980 --> 00:12:32.520
There are a bunch of predefined sets.

00:12:32.520 --> 00:12:35.260
So you can say,
is this particular character a letter?

00:12:35.260 --> 00:12:36.720
Is it a number?

00:12:36.720 --> 00:12:38.360
Is it white space punctuation?

00:12:38.360 --> 00:12:39.920
Is this a diacritic mark?

00:12:40.060 --> 00:12:41.360
There's all kinds of built-in sets.

00:12:41.380 --> 00:12:44.630
So if you need to figure out for
a particular character sort of

00:12:44.640 --> 00:12:49.520
what class this character is in,
you can use CF Character Set.

00:12:49.780 --> 00:12:54.040
You can also use the built-in
support for collation and comparison.

00:12:54.160 --> 00:12:59.230
So to do locale correct
sorting or string comparison.

00:12:59.240 --> 00:13:02.480
Remember I said that there's various
different ways that you could

00:13:02.480 --> 00:13:04.230
represent the same string in Unicode.

00:13:04.310 --> 00:13:07.570
If you compare them byte for byte,
two strings that are really the same

00:13:07.580 --> 00:13:09.690
semantic content might look different.

00:13:09.830 --> 00:13:12.960
If you use the comparison
functions in Core Foundation,

00:13:13.030 --> 00:13:15.170
they should look the same.

00:13:16.490 --> 00:13:17.900
And also,
if you're looking for substrings,

00:13:17.900 --> 00:13:23.040
this is sort of a sub-point of the
whole comparison and collation thing.

00:13:23.040 --> 00:13:25.580
If you're looking for substrings
within a bigger string,

00:13:25.630 --> 00:13:28.490
use the APIs in Core Foundation.

00:13:30.900 --> 00:13:35.490
Now, unfortunately,
not every API in the world

00:13:35.500 --> 00:13:37.100
is based on CFString.

00:13:37.190 --> 00:13:42.900
Not even every API in Mac OS X currently
has CFString APIs to deal with it.

00:13:43.010 --> 00:13:47.820
So sometimes you're going to have
to convert to some other encoding.

00:13:48.400 --> 00:13:51.640
CS String provides the facility
to convert back and forth between

00:13:51.640 --> 00:13:56.200
CarStars or Star 255s and CS Strings.

00:13:56.790 --> 00:14:00.540
But this is an area where you're going
to have to kind of pay attention,

00:14:00.540 --> 00:14:01.130
right?

00:14:01.240 --> 00:14:04.880
Not every encoding can support
all of the characters in Unicode.

00:14:04.880 --> 00:14:07.740
If, you know, ASCII could support all
the characters in Unicode,

00:14:07.740 --> 00:14:09.200
you wouldn't need Unicode.

00:14:09.290 --> 00:14:11.310
So if you're going to be
converting to some encoding,

00:14:11.320 --> 00:14:14.960
you have to be aware that a
particular CFString might have

00:14:14.960 --> 00:14:19.890
stuff in it that just cannot be
converted to a particular encoding.

00:14:20.010 --> 00:14:21.860
In areas where you have
to do these conversions,

00:14:21.860 --> 00:14:24.770
just make sure that you're
aware of these issues.

00:14:27.110 --> 00:14:33.960
So here's a few selected methods
for CFString and CFCharacterSet.

00:14:34.010 --> 00:14:38.760
You can create a string from
bytes of a particular encoding.

00:14:38.830 --> 00:14:41.520
So that's the way that if you
had a car star that you knew

00:14:41.520 --> 00:14:45.860
was in a particular encoding,
or maybe a star 255 or whatever,

00:14:45.920 --> 00:14:50.180
you can create a CFString from that,
converting the string,

00:14:50.190 --> 00:14:53.820
whatever encoding it's in,
into the internal representation.

00:14:53.820 --> 00:14:56.710
Now, it's not always going to blow
the thing up into full Unicode,

00:14:56.910 --> 00:15:00.530
but conceptually,
you can think of it that way.

00:15:00.730 --> 00:15:03.350
The opposite of that is CFStringGetBytes.

00:15:03.460 --> 00:15:08.460
You can use that to extract
a representation of a

00:15:08.510 --> 00:15:11.100
CFString in a given encoding.

00:15:11.220 --> 00:15:14.090
And this is one because not
all encodings can represent

00:15:14.160 --> 00:15:17.340
all strings that might fail,
and you have various

00:15:17.420 --> 00:15:19.540
options to figure that out.

00:15:20.420 --> 00:15:23.760
You can compare strings with
CFString compare with options.

00:15:23.760 --> 00:15:27.660
You can find substrings with
CFString find with options.

00:15:27.780 --> 00:15:30.260
And then I mentioned character
sets a little bit earlier.

00:15:30.260 --> 00:15:35.360
You can get the predefined ones
using CFCharacterSetGetPredefined.

00:15:35.470 --> 00:15:39.290
There are a bunch of constants
in the header file for that class

00:15:39.310 --> 00:15:44.810
which basically list the various
predefined sets you can ask for.

00:15:45.210 --> 00:15:49.970
And then once you have a character set,
you can test whether any individual

00:15:50.030 --> 00:15:54.890
character is a member of that set with
the CF character set is character member.

00:15:57.100 --> 00:15:59.410
File formats.

00:15:59.690 --> 00:16:02.260
Again,
the same sort of issues with strings.

00:16:02.260 --> 00:16:04.850
You don't want to pick a file
format that's not rich enough to

00:16:04.850 --> 00:16:06.460
express international content.

00:16:06.460 --> 00:16:10.340
Don't tie yourself to
limited string encodings.

00:16:10.340 --> 00:16:12.970
While I'm mentioning it,
don't tie yourself to

00:16:12.970 --> 00:16:14.340
a specific platform.

00:16:14.340 --> 00:16:16.160
This is mostly sort
of endian-ness issues.

00:16:16.160 --> 00:16:20.330
Make sure that you take
that into account as well.

00:16:21.480 --> 00:16:23.500
Use a standard format
if it's appropriate.

00:16:23.560 --> 00:16:26.760
So XML is a standard format
that's a particularly good

00:16:26.760 --> 00:16:31.240
choice here because XML is either
stored in Unicode or in UTF-8,

00:16:31.310 --> 00:16:36.370
which is another representation
that is just as rich as Unicode.

00:16:36.810 --> 00:16:41.530
Core Foundation has support
for dealing with XML.

00:16:41.640 --> 00:16:46.100
For simple and small sets of data,
you can use CF Property List,

00:16:46.210 --> 00:16:52.650
an extremely simple API for serializing
and deserializing graphs of data objects

00:16:52.680 --> 00:16:55.840
like dictionaries and arrays and strings.

00:16:55.960 --> 00:16:59.590
For more complex stuff,
you can use the CF XML Parser,

00:16:59.700 --> 00:17:03.700
which is a full XML parser that
you can use to write XML of

00:17:03.730 --> 00:17:06.000
whatever format you want.

00:17:08.460 --> 00:17:11.180
So here's a couple of examples.

00:17:11.370 --> 00:17:12.990
The property list stuff is very simple.

00:17:13.110 --> 00:17:18.410
You just hand it a data object,
and it'll give you back the original

00:17:18.410 --> 00:17:22.080
graph of objects that you used
to create it in the first place.

00:17:22.080 --> 00:17:24.900
You can then take that graph
of objects and hand it to

00:17:25.080 --> 00:17:28.350
CF Property List Create XML,
and it'll hand you back a

00:17:28.390 --> 00:17:30.030
data with the XML in it.

00:17:30.460 --> 00:17:34.070
The parser,
these are the entry points for the

00:17:34.070 --> 00:17:37.460
simple entry points for the XML parser.

00:17:37.520 --> 00:17:38.540
There's lots of options.

00:17:38.540 --> 00:17:40.220
There's also a more complex API.

00:17:40.220 --> 00:17:41.190
We're not going to get into that.

00:17:41.350 --> 00:17:43.800
But just so you know,
Core Foundation does have

00:17:43.800 --> 00:17:46.710
support for XML parsing.

00:17:48.770 --> 00:17:51.660
This doesn't really relate
to Core Foundation so much,

00:17:51.760 --> 00:17:53.540
but it's another big issue.

00:17:53.540 --> 00:17:55.660
You need to deal with text input.

00:17:55.680 --> 00:17:59.660
The way that you deal with text input
is actually a little bit different

00:17:59.660 --> 00:18:01.930
for the Carbon and the Cocoa stack.

00:18:02.020 --> 00:18:04.970
In Carbon applications,
all the controls are

00:18:04.970 --> 00:18:06.440
pretty much ready to go.

00:18:06.440 --> 00:18:09.860
So if you're using appearance
controls for those things,

00:18:09.860 --> 00:18:12.180
you should be fine.

00:18:12.440 --> 00:18:15.320
For larger text,

00:18:15.670 --> 00:18:18.050
Instead of using the
older TextEdit Manager,

00:18:18.300 --> 00:18:20.500
consider using the
multilingual TextEdit Manager,

00:18:20.500 --> 00:18:22.900
which is Unicode-based and
can deal with these things,

00:18:22.950 --> 00:18:26.000
and it also can have more
than 32K of text in it.

00:18:26.050 --> 00:18:28.410
And if you're writing
your own text system,

00:18:28.510 --> 00:18:31.690
you can integrate with
the Text Services Manager,

00:18:31.870 --> 00:18:35.160
which is basically the
sort of lower-level input

00:18:35.160 --> 00:18:37.290
management API for Carbon.

00:18:38.110 --> 00:18:42.460
On the Cocoa side, well,
the Cocoa text system is used for

00:18:42.550 --> 00:18:44.860
all of the text drawing in Cocoa.

00:18:44.860 --> 00:18:47.790
And the Cocoa text system
is fully Unicode aware.

00:18:47.790 --> 00:18:51.380
And it also,
it automatically integrates with the text

00:18:51.380 --> 00:18:53.750
services manager to do input management.

00:18:54.460 --> 00:18:59.130
And so basically for
99% of your Cocoa needs,

00:18:59.130 --> 00:19:00.810
just use the text system.

00:19:00.900 --> 00:19:04.030
If you're writing your own text
system for whatever reason,

00:19:04.150 --> 00:19:06.570
you can implement the
text input protocols.

00:19:06.760 --> 00:19:09.870
Those automatically integrate
with TSM and they allow you to,

00:19:09.870 --> 00:19:12.840
if you're doing your own
text entry management,

00:19:12.920 --> 00:19:17.420
take full advantage of the
input management facilities.

00:19:19.630 --> 00:19:22.000
Okay.

00:19:22.000 --> 00:19:24.000
So here's where we're going to
spend a fair amount of time,

00:19:24.000 --> 00:19:27.790
is talking about resources and bundles.

00:19:29.390 --> 00:19:31.840
Resources.

00:19:31.940 --> 00:19:35.120
Well, OK, the term is a little bit
overloaded these days.

00:19:35.230 --> 00:19:38.300
Resources,
when we talk about resources on Mac OS X,

00:19:38.400 --> 00:19:39.290
there's kind of two kinds.

00:19:39.290 --> 00:19:42.660
There's bundle resources,
which are just basically files

00:19:42.670 --> 00:19:46.950
that live inside of a bundle,
and there's resource manager resources,

00:19:46.950 --> 00:19:50.350
which are the traditional
sort of Mac OS 9 resources.

00:19:50.800 --> 00:20:09.870
CFBundle provides a way to
deal with both of these things.

00:20:09.870 --> 00:20:09.870
And it also provides the structure
for dealing with localization.

00:20:09.870 --> 00:20:09.870
And it knows the proper way to search for
resources that may be locale-specific.

00:20:09.870 --> 00:20:09.870
Inside of a bundle,

00:20:10.750 --> 00:20:14.120
The localized resources are
segregated into their own areas,

00:20:14.170 --> 00:20:15.700
what we call lproj folders.

00:20:15.790 --> 00:20:17.670
We'll actually see some
of that in a moment.

00:20:17.700 --> 00:20:23.690
I want to talk a little bit about the
difference between regions and languages.

00:20:24.220 --> 00:20:29.700
A region actually includes
both a language and a location.

00:20:31.070 --> 00:20:34.010
There's the English that we
speak here in the United States.

00:20:34.110 --> 00:20:36.740
There's the English that
they speak in England.

00:20:36.850 --> 00:20:40.000
There's the French that
is spoken in France,

00:20:40.000 --> 00:20:42.030
and there's the French that's
spoken in Canada.

00:20:42.100 --> 00:20:46.850
We can localize by region,
so you can actually provide different

00:20:46.850 --> 00:20:50.990
variants for French-Canadian
and for France-French.

00:20:51.290 --> 00:20:55.500
Or you can just do it by language.

00:20:55.500 --> 00:20:56.680
Or you can do it by a combination.

00:20:56.740 --> 00:21:00.740
So let's say that for the most part,
all your resources are the same,

00:21:00.740 --> 00:21:03.050
whether people are in
Canada or in France,

00:21:03.090 --> 00:21:07.140
but there's a small subset that
actually have to be specific.

00:21:07.380 --> 00:21:11.690
You can put most of them into
language localization areas,

00:21:11.740 --> 00:21:15.490
but put just the small set
into the regional areas,

00:21:15.500 --> 00:21:18.700
and we'll take care of all that for you.

00:21:20.640 --> 00:21:23.500
Oh, I should mention,
the region names are actually

00:21:23.520 --> 00:21:26.760
the ISO standard region names,
so like EN underbar

00:21:26.760 --> 00:21:28.500
US and so on and so forth.

00:21:28.500 --> 00:21:32.500
Language names,
mostly for compatibility reasons,

00:21:32.500 --> 00:21:41.860
are OpenSTEP style language names,
which are typically English versions

00:21:41.860 --> 00:21:44.500
of language names like English,
French, Japanese.

00:21:44.500 --> 00:21:47.800
So it's German, not Deutsch,
even though if you were going

00:21:47.800 --> 00:21:50.500
to display it in the UI,
it would be Deutsch.

00:21:53.380 --> 00:21:57.220
I'm not going to go through
this slide in any great detail.

00:21:57.400 --> 00:22:01.700
You can find this picture in the
system overview manual if you

00:22:01.700 --> 00:22:03.520
want to go through it in detail.

00:22:03.640 --> 00:22:07.880
My point for showing this slide
is just to impress upon you

00:22:07.880 --> 00:22:13.390
that you're better off letting
CFBundle find the resources for you.

00:22:13.940 --> 00:22:16.830
Because otherwise,
these are the places that you have to

00:22:16.830 --> 00:22:19.760
look and the steps you have to go through
to make sure that you're going to get the

00:22:19.760 --> 00:22:22.890
right version for the user's preferences.

00:22:22.950 --> 00:22:25.400
So I don't know if this is
readable at all from back there,

00:22:25.440 --> 00:22:28.360
but basically we're going to go
off and look in all the appropriate

00:22:28.360 --> 00:22:31.500
places for these resources,
and the first place we find it,

00:22:31.530 --> 00:22:33.800
that's the one that we're going to use.

00:22:35.840 --> 00:22:38.360
I spoke a little bit about the
difference between resource manager

00:22:38.360 --> 00:22:40.930
resources and bundle resources.

00:22:40.990 --> 00:22:44.030
Just to hit on that again,
the resource manager resources

00:22:44.030 --> 00:22:47.470
are the ones that are typically
found in the resource fork of

00:22:47.480 --> 00:22:49.720
an application on Mac OS 9.

00:22:49.840 --> 00:22:52.860
Bundle resources, on the other hand,
are just files that go

00:22:52.860 --> 00:22:54.350
inside your app wrapper.

00:22:56.700 --> 00:22:59.250
And as I mentioned,
CFBundle deals with both of these,

00:22:59.250 --> 00:23:02.870
and both of them can be
either global or localized.

00:23:05.160 --> 00:23:08.420
So resource manager resources,
we're trying to get away from relying

00:23:08.420 --> 00:23:13.300
on the resource fork because we want
to be volume format independent.

00:23:13.350 --> 00:23:17.270
And also, there's only one resource
fork in your application,

00:23:17.270 --> 00:23:19.980
but we need several places to be
able to store these resources so that

00:23:19.980 --> 00:23:22.160
you can have multiple localizations.

00:23:22.260 --> 00:23:25.970
So instead, we put resource manager
resources into the data fork.

00:23:26.040 --> 00:23:28.370
It's the same format that you
used to find in the resource fork.

00:23:28.390 --> 00:23:33.250
It's just in the data fork of separate
files that go inside the app wrapper.

00:23:33.300 --> 00:23:37.200
The resource manager resources
are actually stored in files,

00:23:37.200 --> 00:23:40.330
which are themselves bundle
resources of the bundle.

00:23:43.520 --> 00:23:47.250
We separate out the resource manager
resources that don't need to be

00:23:47.250 --> 00:23:50.880
localized from the ones that do,
so you don't have to ship multiple

00:23:50.880 --> 00:23:54.160
copies of the stuff that doesn't change,
only multiple copies of

00:23:54.160 --> 00:23:56.160
the stuff that does change.

00:23:57.310 --> 00:24:01.940
Now, CFBundle has API to open the
resource manager resource forks

00:24:02.000 --> 00:24:05.500
and put them onto the chain,
the resource chain in Carbon.

00:24:05.630 --> 00:24:09.750
And it correctly deals with opening both
the global and the localized resources.

00:24:10.000 --> 00:24:13.430
For the localized ones,
it correctly deals with finding the right

00:24:13.450 --> 00:24:15.690
version for this user's preferences.

00:24:16.770 --> 00:24:21.350
Carbon automatically calls this API when
your app launches for your application,

00:24:21.410 --> 00:24:23.040
so you don't have to worry about that.

00:24:23.160 --> 00:24:26.350
Just like on Mac OS 9,
your resource fork was already

00:24:26.350 --> 00:24:28.400
open for you when your app started.

00:24:29.700 --> 00:24:33.780
For frameworks or for plugins,
you can use this bundle API to

00:24:33.780 --> 00:24:38.060
cause the frameworks or the plugins
resource manager resources to be

00:24:38.060 --> 00:24:41.170
added to the Carbon resource chain.

00:24:44.080 --> 00:24:49.500
Bundle resources, again,
just files inside the bundle.

00:24:49.500 --> 00:24:53.900
The API on CFBundle, basically,
you ask for a resource by name,

00:24:53.900 --> 00:24:58.610
we give you back the URL of that resource
where it resides inside the bundle.

00:24:58.810 --> 00:25:02.560
Don't go groping around inside the
bundle to try to find them yourselves.

00:25:02.720 --> 00:25:06.520
Because again,
that picture is very complex.

00:25:06.720 --> 00:25:10.880
Once you've found the URL that locates
this resource inside the bundle,

00:25:10.900 --> 00:25:14.360
you use whatever API is appropriate for
the kind of file that you're looking for.

00:25:14.360 --> 00:25:17.990
So, you know, if it's a TIFF file,
you're going to go off and

00:25:17.990 --> 00:25:21.400
use a TIFF library to open
up that image and parse it.

00:25:21.490 --> 00:25:25.760
If it's, you know, an RTF file,
you're going to go and tell, you know,

00:25:25.760 --> 00:25:28.420
some RTF editor to open it or whatever.

00:25:30.590 --> 00:25:33.250
Now, there's one kind of bundle
resource that's handled kind

00:25:33.250 --> 00:25:37.850
of specially by CFBundle,
and that's strings files.

00:25:37.850 --> 00:25:37.850
And I want to kind of--

00:25:38.000 --> 00:25:40.730
You can spend a little time talking
about strings files because for

00:25:40.730 --> 00:25:45.000
the Carbon folks in the room,
this is, I think,

00:25:45.000 --> 00:25:48.550
one of the first kind of bundle
resources that you might want to

00:25:48.550 --> 00:25:52.780
look at moving some of your resource
manager resources to use instead.

00:25:53.190 --> 00:25:54.890
If you're using
Resource Manager resources

00:25:54.890 --> 00:25:57.310
to do string localization,
I guess there's the STR number

00:25:57.310 --> 00:25:58.850
resources and so forth.

00:25:59.110 --> 00:26:02.090
Okay, fine,
but those are not necessarily the

00:26:02.090 --> 00:26:06.110
easiest things in the world to maintain,
and you have to compile them with

00:26:06.110 --> 00:26:07.540
res and all this other stuff.

00:26:07.540 --> 00:26:10.940
Strings files provide a nice,
easy way to do that same thing.

00:26:10.940 --> 00:26:13.340
And so I anticipate
that Carbon developers,

00:26:13.340 --> 00:26:16.750
if they want to get started using
some bundle resources instead,

00:26:17.110 --> 00:26:19.970
this might be the first thing
that you're going to do.

00:26:20.340 --> 00:26:23.940
Any user-visible strings
obviously should be localizable.

00:26:23.940 --> 00:26:30.020
And strings files are basically
key-value pairs stored in Unicode

00:26:30.120 --> 00:26:32.570
in a plain text file-- well,
a plain Unicode text

00:26:32.720 --> 00:26:35.360
file-- inside your bundle.

00:26:35.470 --> 00:26:39.600
And CFBundle actually has
specific API that you can use

00:26:39.600 --> 00:26:42.620
to locate these strings files,
open them up, cache their contents,

00:26:42.620 --> 00:26:46.520
fetch strings out of them for
the particular localization

00:26:46.520 --> 00:26:48.390
that's appropriate.

00:26:49.860 --> 00:26:54.460
The developer tools also have support
for helping you to even generate these

00:26:54.460 --> 00:26:56.360
strings files just from your code.

00:26:56.980 --> 00:27:00.890
So there's a command line
tool called genstrings in DP4.

00:27:00.920 --> 00:27:03.450
This is not integrated into the
project builder bank process,

00:27:03.480 --> 00:27:04.800
but it will be eventually.

00:27:04.810 --> 00:27:09.320
And what this tool does is it just
sort of goes through all your code,

00:27:09.700 --> 00:27:12.400
looking for places where you're
looking up localized strings,

00:27:12.400 --> 00:27:16.250
and then it spits out skeleton
strings files that contain

00:27:16.310 --> 00:27:19.460
all the keys that you're ever
going to look for in your code.

00:27:20.220 --> 00:27:21.920
you go in and just fill in the values.

00:27:25.940 --> 00:27:26.910
Oh, you know what?

00:27:26.970 --> 00:27:28.860
One more thing I want to
mention with the strings files.

00:27:28.900 --> 00:27:33.900
CFString has sort of printf-like
APIs so you can use format strings

00:27:33.900 --> 00:27:35.400
and format arguments into them.

00:27:35.400 --> 00:27:38.010
With strings files,
we actually have support,

00:27:38.010 --> 00:27:41.400
and with CFString itself,
we have support for argument reordering.

00:27:41.400 --> 00:27:45.030
So if you have two arguments that
in English are in this order,

00:27:45.030 --> 00:27:47.540
but in Japanese they
need to be in this order,

00:27:47.540 --> 00:27:48.400
no problem.

00:27:48.400 --> 00:27:50.470
That can all be done.

00:27:52.150 --> 00:27:57.000
All right,
so here's some of the API for CFBundle.

00:27:57.150 --> 00:28:01.460
For actually locating bundles,
you can easily get hold of the bundle

00:28:01.570 --> 00:28:07.710
that contains the application that's
running with CFBundle Get Main Bundle.

00:28:08.110 --> 00:28:13.010
If you're a framework or a plugin
and you want to locate the bundle

00:28:13.130 --> 00:28:16.970
for that framework or that plugin,
you can use CFBundle,

00:28:17.030 --> 00:28:18.390
get bundle with identifier.

00:28:18.590 --> 00:28:21.490
You can basically assign a
unique identifier to each bundle.

00:28:21.600 --> 00:28:25.900
And then if in that bundle's code,
you can look it up by that identifier.

00:28:25.900 --> 00:28:29.350
You can make sure that
you get the right bundle.

00:28:29.450 --> 00:28:31.300
You don't have to know where it
lives on the disk or anything

00:28:31.300 --> 00:28:33.000
as long as your code is running.

00:28:33.000 --> 00:28:36.180
You know that it's loaded into
the app and you'll be able to find

00:28:36.180 --> 00:28:38.000
that bundle by its identifier.

00:28:39.750 --> 00:28:43.200
The Info.plist of a bundle
contains a bunch of metadata.

00:28:43.200 --> 00:28:44.650
We're not going to talk
too much about that,

00:28:44.750 --> 00:28:48.670
but you can use CFBundle.get.info
dictionary to get the whole

00:28:48.900 --> 00:28:50.900
Info.plist dictionary.

00:28:50.990 --> 00:28:53.940
Some of the values in the
Info.plist dictionary actually end

00:28:53.940 --> 00:28:58.310
up being localized a lot of the time,
and they get localized in a separate

00:28:58.440 --> 00:29:01.560
file called Info.plist.strings.

00:29:01.630 --> 00:29:07.420
You can use CFBundle.get.value.for.info
dictionary key to look up specific

00:29:07.890 --> 00:29:09.770
values from the info dictionary.

00:29:10.230 --> 00:29:13.360
That API will actually look
into localized stuff first.

00:29:13.470 --> 00:29:19.920
If you have, say, a CFBundle.name key,
which is what Carbon uses to display the

00:29:19.920 --> 00:29:23.790
name of the application in the menu bar,

00:29:23.930 --> 00:29:27.910
You want that to be localized, obviously,
so you can use CFBundle.getValue for

00:29:27.910 --> 00:29:31.520
info dictionary key to get that string
and make sure that it gets it out

00:29:31.520 --> 00:29:35.700
of the localized data if it's there,
otherwise out of the global data.

00:29:37.750 --> 00:29:43.360
You can use CFBundleCopyResourceURL to
find bundle resources inside the bundle.

00:29:43.480 --> 00:29:45.700
Again, you just give it the name.

00:29:45.810 --> 00:29:48.950
We'll go out and look for it
inside the bundle and return

00:29:48.950 --> 00:29:50.650
you the appropriate one.

00:29:51.060 --> 00:29:55.100
Open Bundle Resource Files is
the one that you can use in a

00:29:55.100 --> 00:29:58.630
framework or a plugin to open
up the Resource Manager resource

00:29:58.630 --> 00:30:01.000
files inside of a bundle.

00:30:01.070 --> 00:30:06.630
CF Copy Localize String is one of these
functions that we have for specifically

00:30:06.630 --> 00:30:08.390
dealing with these strings files.

00:30:08.640 --> 00:30:12.710
You just give it a key and it
will go find the strings file,

00:30:12.800 --> 00:30:15.700
look that key up, and return it to you.

00:30:16.230 --> 00:30:20.360
And these localized strings functions
are also the thing that that GenStrings

00:30:20.440 --> 00:30:25.470
tool looks for when it's automatically
generating strings files for you.

00:30:26.240 --> 00:30:28.660
Okay, next demo.

00:30:28.790 --> 00:30:32.240
So we get the demo machine
back up on the screen.

00:30:32.950 --> 00:30:37.970
I want to show just briefly,
and I know that this has been

00:30:37.990 --> 00:30:41.320
shown a couple times before,
so bear with me if you've seen it,

00:30:41.400 --> 00:30:44.160
what the insides of
the bundle looks like.

00:30:45.240 --> 00:30:49.360
We have a little secret shortcut here
to actually go inside of a bundle,

00:30:49.360 --> 00:30:52.090
which is usually shown
opaque in the finder.

00:30:52.170 --> 00:30:56.070
Let's put that in list mode.

00:30:56.600 --> 00:31:02.030
The only thing that's in the top
level of a bundle is typically

00:31:02.030 --> 00:31:04.400
this contents directory.

00:31:04.930 --> 00:31:08.300
Inside that, we have the info P list,
which again is this

00:31:08.300 --> 00:31:10.270
metadata about the bundle.

00:31:10.270 --> 00:31:12.760
There's been more info on
that in other sessions,

00:31:12.760 --> 00:31:14.160
so I'm not going to go into that.

00:31:14.210 --> 00:31:17.790
And the package info, which again,
you may have heard some about,

00:31:17.820 --> 00:31:19.680
but we won't be talking about.

00:31:20.180 --> 00:31:25.090
The actual binary for the application
lives inside of a folder named after

00:31:25.170 --> 00:31:27.040
the platform it's supposed to run on.

00:31:27.110 --> 00:31:29.930
You might have another folder
in here called Mac OS Classic,

00:31:29.930 --> 00:31:34.430
which would contain the binary
for Mac OS 9 if you had a

00:31:34.440 --> 00:31:37.540
separate binary for Mac OS 9.

00:31:37.620 --> 00:31:42.110
Then what we're really interested
in here is the resources directory.

00:31:43.110 --> 00:31:45.290
All the plain files that
you see in this directory,

00:31:45.290 --> 00:31:50.760
those are the global resources,
the ones that don't need to be localized.

00:31:50.820 --> 00:31:54.000
I don't need to localize the
icon file for this application.

00:31:54.000 --> 00:32:00.240
It doesn't have any text in it,
and it doesn't need to be localized,

00:32:00.470 --> 00:32:02.190
so it sits here.

00:32:02.720 --> 00:32:05.240
One that deserves special mention,
perhaps, is this guy.

00:32:05.240 --> 00:32:10.600
This is the DataFork file that
contains the resource manager

00:32:10.600 --> 00:32:13.600
resources for this application,
which are global.

00:32:13.600 --> 00:32:18.080
So these are the ones that
don't need to be localized.

00:32:18.760 --> 00:32:21.980
Now all the localized resources go
inside these Lproj directories that

00:32:21.980 --> 00:32:23.790
I talked about a little bit earlier.

00:32:23.790 --> 00:32:25.700
You can see that we have
four localizations here,

00:32:25.700 --> 00:32:30.020
one for English, one for French,
one for German, and one for Japanese.

00:32:30.170 --> 00:32:34.600
The contents of these
directories is always identical,

00:32:34.600 --> 00:32:36.890
or should always be identical.

00:32:36.990 --> 00:32:38.960
Basically,
you need a copy of each and every

00:32:38.960 --> 00:32:43.040
one of these localized resources
for each language or region

00:32:43.040 --> 00:32:45.260
that you're localizing for.

00:32:45.340 --> 00:32:49.850
So we have the credits file in French,
and we have the credits file in English,

00:32:49.860 --> 00:32:53.100
and we have all the various
interface builder files.

00:32:53.190 --> 00:32:58.660
We have a standard strings file
that is going to be localized.

00:32:58.790 --> 00:33:04.390
This one is the resource manager
resources for this application,

00:33:04.390 --> 00:33:05.500
the localized ones.

00:33:05.630 --> 00:33:09.000
So you notice we have a copy in here,
and we have a copy in here.

00:33:09.100 --> 00:33:12.850
And again, when you use the bundle APIs,
the appropriate one is going to get

00:33:12.900 --> 00:33:15.220
opened and put onto your resource chain.

00:33:16.400 --> 00:33:19.440
So, okay, pretty simple.

00:33:19.560 --> 00:33:21.350
And, uh...

00:33:27.510 --> 00:33:33.030
Oh, the localized plist would also
go into the lproj folders in a

00:33:33.120 --> 00:33:37.050
file called Info.plist.strings,
I believe.

00:33:37.160 --> 00:33:41.580
So that's just another strings file,
but it has a special name so that we

00:33:41.580 --> 00:33:43.720
know that it's the one for the plist.

00:33:43.810 --> 00:33:49.240
And it just goes in the lproj with
the rest of the localized resources.

00:33:49.280 --> 00:33:53.160
OK, that's the end of this demo.

00:33:56.320 --> 00:33:59.370
You can see what the
structure of the bundle is.

00:33:59.490 --> 00:34:00.840
You should never have to mess with that.

00:34:00.930 --> 00:34:03.160
Project Builder knows
how to build bundles,

00:34:03.190 --> 00:34:05.780
and we're going to get
into that right now.

00:34:05.780 --> 00:34:08.720
So Project Builder, the new development
environment for Mac OS X,

00:34:08.840 --> 00:34:11.740
has full support for building bundles,
for building multiply

00:34:11.740 --> 00:34:14.690
localized applications,
for managing all the details that

00:34:14.690 --> 00:34:19.310
you need to have taken care of
when you're dealing with multiply

00:34:19.310 --> 00:34:21.570
localized Mac OS X bundles.

00:34:21.870 --> 00:34:24.200
So we know how to build
the bundle disk structure.

00:34:24.200 --> 00:34:27.180
You shouldn't involve yourself in that
if you can avoid it at all because,

00:34:27.340 --> 00:34:29.850
well, you know,
we know how to do that and

00:34:29.850 --> 00:34:33.700
you shouldn't necessarily have
to also know how to do that.

00:34:34.230 --> 00:34:37.860
We let you localize the InfoP-List data.

00:34:37.860 --> 00:34:39.860
We let you localize
your bundle resources.

00:34:39.860 --> 00:34:42.810
We let you localize your
resource manager resources,

00:34:42.810 --> 00:34:43.690
all of that.

00:34:45.150 --> 00:34:50.390
So Project Builder has target
types that represent applications,

00:34:50.500 --> 00:34:55.100
frameworks,
and bundles or loadable plug-ins.

00:34:55.200 --> 00:35:00.060
All of these basically end up building
bundles of one flavor or another.

00:35:00.190 --> 00:35:02.960
Each of these targets
basically constructs the bundle

00:35:02.960 --> 00:35:04.680
automatically as it builds.

00:35:05.130 --> 00:35:09.020
And the build system knows where
to put all the various pieces.

00:35:09.310 --> 00:35:12.730
Then, as I think I had mentioned,
actually, Project Builder has full

00:35:12.770 --> 00:35:16.550
control for managing what's
in your info P list as well.

00:35:18.380 --> 00:35:22.560
For the resources,
the target model in Project Builder

00:35:22.560 --> 00:35:24.340
is that we have these build phases.

00:35:24.340 --> 00:35:26.500
And so, you know,
we're going to go through and for

00:35:26.500 --> 00:35:28.260
the target we build each build phase.

00:35:28.260 --> 00:35:31.400
And so there's build phases that
will compile your source code.

00:35:31.400 --> 00:35:34.160
There's build phases for frameworks
that will copy your headers into

00:35:34.160 --> 00:35:37.320
the frameworks header directory.

00:35:37.320 --> 00:35:41.620
There's build phases that will copy
your bundle resources into the bundle.

00:35:41.650 --> 00:35:47.450
There's a build phase that will run res
or res merge on all your .r or your .rsrc

00:35:47.450 --> 00:35:50.550
files and put those into the bundle.

00:35:50.560 --> 00:35:54.080
And so this is how Project Builder
deals with building things.

00:35:54.080 --> 00:35:58.450
And the build phases that do bundle
resources and resource manager

00:35:58.450 --> 00:36:00.930
resources know about localization.

00:36:00.940 --> 00:36:01.940
X.

00:36:02.540 --> 00:36:06.030
Now within the IDE,
we also help to enforce some of

00:36:06.030 --> 00:36:10.000
the requirements for CFBundles.

00:36:10.040 --> 00:36:12.990
One of those requirements is that

00:36:14.070 --> 00:36:18.130
A resource has to be either
global or localizable.

00:36:18.260 --> 00:36:22.000
You shouldn't have a file in your
Lproj directory and also have it

00:36:22.000 --> 00:36:24.210
at the top level of the resources.

00:36:24.320 --> 00:36:28.900
If you do, the global one is the only
one that will be found.

00:36:29.230 --> 00:36:30.420
That seems a little backwards.

00:36:30.420 --> 00:36:31.860
The reason that's done
is for performance.

00:36:31.860 --> 00:36:33.140
You're not supposed to have them both.

00:36:33.190 --> 00:36:35.120
If you do have them both,
the first one we look

00:36:35.170 --> 00:36:37.580
for is the global one,
because we only have to

00:36:37.580 --> 00:36:39.330
look in one place for that.

00:36:40.450 --> 00:36:46.200
We also make sure that whatever the
development language of your project is,

00:36:46.310 --> 00:36:49.660
you have to have a full
set of resources for those.

00:36:49.750 --> 00:36:53.830
You should have a full set of resources
for any other regions that you support,

00:36:53.830 --> 00:36:56.280
but if you don't,
for a particular resource,

00:36:56.280 --> 00:36:58.740
we'll fall back on the
development region version.

00:36:58.860 --> 00:37:01.590
And that's why you have to have
a development region version.

00:37:01.690 --> 00:37:04.910
That means that we'll always
be able to find at least one

00:37:04.910 --> 00:37:06.730
version of this resource.

00:37:07.230 --> 00:37:11.580
And then for the platform-specific stuff,
we require that there be a generic one

00:37:11.640 --> 00:37:13.940
if you have any platform-specific ones.

00:37:14.010 --> 00:37:17.860
And that's just in case, say,
another platform was to be

00:37:17.860 --> 00:37:19.600
supported at a later date.

00:37:19.650 --> 00:37:23.140
If you only had platform-specific ones,
which one do we use, right?

00:37:23.380 --> 00:37:24.960
You didn't anticipate the new platform.

00:37:25.040 --> 00:37:28.660
If there's a generic one in there,
though, we can use that.

00:37:30.100 --> 00:37:32.550
So, all right,
let's actually look at how this

00:37:32.620 --> 00:37:38.760
gets done in Project Builder.

00:37:38.760 --> 00:37:38.760
Now, what

00:37:39.300 --> 00:37:44.200
Slightly modified version of
the SimpleText project that

00:37:44.870 --> 00:37:47.060
ships as an example on OS X.

00:37:47.060 --> 00:37:50.250
And when I say slightly modified,
what I've done is I've made

00:37:50.250 --> 00:37:54.060
SimpleText localizable already.

00:37:54.060 --> 00:37:58.900
So SimpleText wasn't quite
fully set up to be localizable,

00:37:58.900 --> 00:38:02.210
but I've tweaked it around a little,
so it is.

00:38:03.460 --> 00:38:09.670
We can see all the .R files
that are in the project.

00:38:11.070 --> 00:38:15.400
These are the things that are going to
go through REST and build the resource

00:38:15.400 --> 00:38:18.000
manager resources that SimpleTax needs.

00:38:18.000 --> 00:38:26.990
Now, first let's go ahead and build this.

00:38:30.210 --> 00:38:34.230
While that's building,
maybe I'll point out that I've

00:38:34.230 --> 00:38:37.820
also sort of broken up the .R
files a little further than they

00:38:37.820 --> 00:38:39.510
are in the default simple text.

00:38:39.590 --> 00:38:47.310
I've actually taken out and put in
a separate file all of the stuff.

00:38:47.400 --> 00:39:34.200
[Transcript missing]

00:39:34.490 --> 00:39:39.840
All the R files were merged together and
put into one .rsrc file in the data fork.

00:39:39.840 --> 00:39:44.250
All right,
let's prove that this actually works.

00:39:46.960 --> 00:39:51.040
So here's simple text.

00:39:51.070 --> 00:39:54.340
I can bring up the Find panel
and so on and so forth.

00:39:54.340 --> 00:39:56.300
OK, fine.

00:39:58.110 --> 00:40:02.480
SimpleText has a bug, yes.

00:40:02.550 --> 00:40:06.790
Now, OK, so I have this application
now that's localizable,

00:40:06.790 --> 00:40:08.670
but it's not localized, right?

00:40:08.780 --> 00:40:10.200
How do I localize it?

00:40:10.310 --> 00:40:14.250
Well, these are the files, again,
that need to be localized.

00:40:14.410 --> 00:40:17.540
This one, the global stuff file,
this one does not need to be localized.

00:40:17.630 --> 00:40:20.750
But this one, these all do.

00:40:20.850 --> 00:40:25.490
So what I'm going to do is I'm going
to go to the project inspector.

00:40:26.040 --> 00:40:27.720
The inspector can act
on multiple selections,

00:40:27.750 --> 00:40:29.340
so you can do all this stuff in a batch.

00:40:29.340 --> 00:40:32.970
And there's this localization
and platforms pull-down menu.

00:40:33.170 --> 00:40:35.000
And all you really
have to do here is say,

00:40:35.000 --> 00:40:36.510
"Okay,
I'd like all these to be localized,

00:40:36.650 --> 00:40:40.340
please." You'll notice that they
all got disclosure triangles.

00:40:40.540 --> 00:40:46.000
And what that shows, if you disclose it,
it shows a list of all of the

00:40:46.000 --> 00:40:48.990
different variants that we have
for this localized resource.

00:40:49.000 --> 00:40:52.290
And so when we first make it localized,
we just get English,

00:40:52.290 --> 00:40:55.000
which is the development
region for this project.

00:40:55.240 --> 00:40:57.910
And that's what we start out with.

00:40:58.060 --> 00:41:00.000
But the whole point here is we
want to actually localize it.

00:41:00.000 --> 00:41:02.790
So once we've made these
localizable resources,

00:41:02.790 --> 00:41:05.000
we can go ahead and add a new variant.

00:41:05.000 --> 00:41:09.070
So let's say add one for French.

00:41:10.390 --> 00:41:12.000
You'll notice that for
the ones I disclosed,

00:41:12.000 --> 00:41:14.460
it added the French version here.

00:41:14.570 --> 00:41:17.760
Initially,
when you add a new region variant,

00:41:17.760 --> 00:41:21.340
it starts out as a copy
of the development region.

00:41:21.470 --> 00:41:25.520
So if I open up this file,
which actually seems to

00:41:25.520 --> 00:41:28.710
contain a lot of the strings,
we'll see that the

00:41:28.710 --> 00:41:33.090
French version is in English,
right?

00:41:33.090 --> 00:41:36.600
Because it just copied the English file.

00:41:36.750 --> 00:41:38.700
I'm not going to make you
sit here and watch me,

00:41:38.700 --> 00:41:41.240
my poor command of French here.

00:41:41.240 --> 00:41:46.160
I actually had a colleague
localize this one for me,

00:41:46.160 --> 00:41:49.820
and I have this little cheater file.

00:41:49.820 --> 00:41:53.310
We'll go ahead and just copy the
contents out of there and go back

00:41:53.310 --> 00:41:59.730
to the French version of localize.r,
and we'll just replace it.

00:42:00.110 --> 00:42:01.610
Save that.

00:42:01.610 --> 00:42:06.400
Now we have this version,
which if I go up to part

00:42:06.520 --> 00:42:10.160
that actually was localized,
you can see it has been

00:42:10.300 --> 00:42:13.400
localized into French.

00:42:14.400 --> 00:42:15.400
Let's build that.

00:42:15.400 --> 00:42:18.640
Now, it didn't build any of the code
because we already built that.

00:42:18.640 --> 00:42:21.400
Now, if you notice though,
now it's running res on some of these

00:42:21.490 --> 00:42:25.940
files and it's putting them into the
localized.rsrc of the English.lproj.

00:42:25.940 --> 00:42:27.800
It's doing some more of
them for the French.lproj,

00:42:27.840 --> 00:42:31.080
right, because we have French versions
for everything now.

00:42:31.080 --> 00:42:33.320
And then finally,
it's doing the global one for

00:42:33.320 --> 00:42:34.750
the one that we didn't localize.

00:42:38.110 --> 00:42:39.780
Okay.

00:42:39.780 --> 00:42:42.560
And now we can run.

00:42:42.590 --> 00:42:44.640
Hopefully it will still come
up in English because I haven't

00:42:44.680 --> 00:42:46.060
changed my language preference.

00:42:46.220 --> 00:42:47.480
Ooh.

00:42:47.680 --> 00:42:49.550
You know what, though?

00:42:50.720 --> 00:42:53.440
I forgot to change my preference
back to English after the first demo.

00:42:53.470 --> 00:42:55.160
So, all right, well,
here it is in French.

00:42:55.460 --> 00:42:59.150
All right,
let's do this in the right order, though.

00:42:59.160 --> 00:43:01.620
All right, so.

00:43:01.620 --> 00:43:04.070
We can run this and
it'll come up in English.

00:43:04.580 --> 00:43:08.540
Actually, you'll notice that before I had
left the preference order Japanese,

00:43:08.740 --> 00:43:10.200
French, English, right?

00:43:10.270 --> 00:43:14.050
We hadn't localized it into Japanese,
but we had localized it into French,

00:43:14.250 --> 00:43:16.360
so it showed up in French,
even though I would have preferred

00:43:16.360 --> 00:43:17.490
Japanese if there had been one.

00:43:17.490 --> 00:43:18.500
Okay.

00:43:18.500 --> 00:43:20.340
So here it is in English, right?

00:43:20.500 --> 00:43:24.270
We still have the find panel.

00:43:24.270 --> 00:43:26.190
Okay, fine.

00:43:27.260 --> 00:43:31.810
But if we go back here and we say, OK,
well, let's make that French instead

00:43:32.490 --> 00:43:34.900
and run it again.

00:43:37.200 --> 00:43:41.700
Okay, here it comes in French.

00:43:41.700 --> 00:43:44.240
And you'll see that in this case,
just doing the strings isn't

00:43:44.240 --> 00:43:45.200
going to quite be enough.

00:43:45.200 --> 00:43:49.200
We'll probably have to go in and
tweak some of the DITL resources

00:43:49.200 --> 00:43:52.720
to change some of the control sizes
when we want to make this actually

00:43:52.720 --> 00:43:54.200
fully localized into French.

00:43:54.200 --> 00:43:56.160
But you get the idea, right?

00:43:56.160 --> 00:43:59.830
So that's as easy, you know,
as it is to actually support

00:43:59.890 --> 00:44:02.200
this stuff in Project Builder.

00:44:02.200 --> 00:44:06.190
And that is the end of that demo.

00:44:13.150 --> 00:44:15.800
So that pretty much
concludes the content here.

00:44:15.850 --> 00:44:18.250
All of my pointers point backwards.

00:44:18.550 --> 00:44:20.820
All of these sessions
have already taken place.

00:44:20.820 --> 00:44:22.220
If you saw them, good for you.

00:44:22.310 --> 00:44:24.030
If you didn't, well, OK.

00:44:24.150 --> 00:44:27.390
Maybe some of these slides or even
the video for these presentations

00:44:27.390 --> 00:44:29.330
will be available at some point.

00:44:29.330 --> 00:44:32.340
And if they are,
you might take a peek at some of them.

00:44:32.510 --> 00:44:37.000
Core Foundation is a wonderful technology
for dealing with these localization

00:44:37.000 --> 00:44:39.220
issues as well as a lot of other stuff.

00:44:39.250 --> 00:44:42.650
So definitely check out the
Core Foundation stuff if you want

00:44:42.650 --> 00:44:44.050
to learn about Project Builder.

00:44:44.060 --> 00:44:47.740
There's the Project Builder sessions.

00:44:47.740 --> 00:44:51.180
There's the application packaging
and document typing talk that Arnaud

00:44:51.180 --> 00:44:56.980
gave earlier this afternoon that
deals with other bundle issues.

00:44:56.980 --> 00:44:59.210
There's the
Apple Localization Tools talk,

00:44:59.210 --> 00:45:02.400
which was in this room
right before this talk.

00:45:02.400 --> 00:45:08.770
And then the one that isn't already over,
there's the Texan International Feedback

00:45:08.770 --> 00:45:10.500
session tomorrow morning.

00:45:11.450 --> 00:45:19.070
Tim Holmes is the one to
contact about this technology.

00:45:19.070 --> 00:45:19.070
His email address is there.

00:45:19.360 --> 00:45:22.430
And now I'll invite a
few people to come up.

00:45:22.520 --> 00:45:25.370
Hopefully they showed up for Q&A.
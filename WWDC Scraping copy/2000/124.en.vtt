WEBVTT

00:00:10.030 --> 00:00:13.600
We're going to start by talking about
CF's role in Mac OS X as a whole.

00:00:13.600 --> 00:00:16.400
Then we're going to look at some of
the concepts and paradigms there.

00:00:16.590 --> 00:00:21.390
And finally, in this talk,
we'll be introducing the basic CF types.

00:00:21.820 --> 00:00:26.700
So, when I talk about Core Foundation,
this is the big take-home point.

00:00:26.800 --> 00:00:31.600
Core Foundation is the
lingua franca in Mac OS X.

00:00:31.650 --> 00:00:34.050
Well, what does that mean?

00:00:34.840 --> 00:00:38.140
A lingua franca is a medium
of communication between

00:00:38.140 --> 00:00:41.100
people of different languages.

00:00:41.250 --> 00:00:44.710
So what are the different
languages on Mac OS X?

00:00:45.630 --> 00:00:50.890
Carbon and Cocoa Core Foundation is
a substrate layer that lives

00:00:50.890 --> 00:00:54.340
beneath both Carbon and Cocoa,
so it provides the common

00:00:54.340 --> 00:00:58.710
language by which those two
environments speak to one another.

00:00:58.880 --> 00:01:02.710
As such, it bridges the basic
types between both stacks,

00:01:02.950 --> 00:01:06.700
and provides those common services
that both stacks need to share,

00:01:06.860 --> 00:01:10.190
things like the pasteboard,
the event model.

00:01:11.680 --> 00:01:15.980
So, just as an example here,
you see the Carbon types on the right

00:01:15.980 --> 00:01:17.510
and the Cocoa types on the left.

00:01:17.740 --> 00:01:24.390
Core Foundation acts to convert to
and from the types on either side.

00:01:26.550 --> 00:01:28.540
Hopefully you've seen
this diagram by now.

00:01:28.540 --> 00:01:31.900
This is the basic
architecture on Mac OS X.

00:01:31.900 --> 00:01:34.520
I want to point out the core
services layer that lives

00:01:34.650 --> 00:01:38.200
below the application services,
the graphical services like

00:01:38.200 --> 00:01:44.090
Quartz and OpenGL and QuickTime,
but above Darwin, the operating system.

00:01:44.220 --> 00:01:45.770
That layer is where we live.

00:01:45.910 --> 00:01:52.480
We provide the common services
needed by everything above us

00:01:52.480 --> 00:01:53.150
that does not depend on graphics.

00:01:53.410 --> 00:01:55.520
So if you look inside
the core services layer,

00:01:55.520 --> 00:01:59.500
you'll see a number of the non-graphical
managers you're familiar with.

00:01:59.500 --> 00:02:03.500
Things like the file manager,
memory manager, resource manager.

00:02:03.530 --> 00:02:05.840
And in with all of those
is Core Foundation.

00:02:05.840 --> 00:02:13.930
In fact, Core Foundation,
were you to look inside

00:02:13.930 --> 00:02:14.090
the core services code,
lies below almost all of those.

00:02:17.830 --> 00:02:19.760
So, what is CF?

00:02:20.020 --> 00:02:25.700
It's a non-graphical substrate library
available to both Carbon and Cocoa.

00:02:25.700 --> 00:02:28.060
In fact, it's even below Classic.

00:02:28.290 --> 00:02:31.780
It is written in pure C because
that is the common language

00:02:31.780 --> 00:02:39.070
beneath all of those layers,
and it's designed around some

00:02:39.070 --> 00:02:39.070
basic object-oriented paradigms.

00:02:40.820 --> 00:02:44.600
So, CF provides two basic
things to the system.

00:02:44.620 --> 00:02:47.050
The first one is some basic
types by which all of the

00:02:47.140 --> 00:02:49.040
different substrates can speak.

00:02:49.090 --> 00:02:51.910
So that's things like strings, arrays,
and dictionaries,

00:02:51.910 --> 00:02:55.830
and then we combine them together in an
abstraction that we call property lists.

00:02:55.930 --> 00:03:00.060
The other thing it provides
is the non-graphical services

00:03:00.160 --> 00:03:02.490
that every application needs.

00:03:02.670 --> 00:03:07.560
So, that's localization support,
user preferences, as I said,

00:03:07.560 --> 00:03:09.240
also the pasteboard and the run loop.

00:03:12.280 --> 00:03:15.450
In this talk, we're going to focus on
the basic data types.

00:03:15.740 --> 00:03:17.960
There's a follow-on to
this talk immediately after

00:03:17.960 --> 00:03:25.380
lunch in this same room,
where we'll be talking about

00:03:25.380 --> 00:03:25.380
the second half of that stack,
the app services.

00:03:27.670 --> 00:03:30.080
So where is CF available?

00:03:30.080 --> 00:03:34.390
On Mac OS X, Core Foundation is available
as its own library.

00:03:34.390 --> 00:03:38.840
On 8 and 9,
it ships as part of CarbonLib.

00:03:38.860 --> 00:03:41.450
Now there are some pieces
of Core Foundation that

00:03:41.500 --> 00:03:42.940
are only available on 10.

00:03:42.980 --> 00:03:45.820
Those center around the
mock-specific pieces,

00:03:45.820 --> 00:03:48.600
which obviously do not apply on 8 and 9.

00:03:48.600 --> 00:03:58.830
Finally, a subset of Core Foundation is
available inside of Darwin.

00:03:58.830 --> 00:03:58.830
So if you're interested,
you can check out the Darwin source

00:03:58.830 --> 00:03:58.830
code and see what we're doing.

00:04:01.230 --> 00:04:04.490
So I know that as a developer,
when I go and approach a stack,

00:04:04.490 --> 00:04:07.590
one of the first things
I don't want to hear is,

00:04:07.590 --> 00:04:11.710
by the way, there's this other large
API I have to learn.

00:04:11.870 --> 00:04:14.120
So if you don't want to learn CF, relax.

00:04:14.360 --> 00:04:15.820
You don't really have to.

00:04:16.080 --> 00:04:18.500
You're missing out,
but you don't have to.

00:04:18.540 --> 00:04:21.920
Carbon and Cocoa are both
complete APIs unto themselves.

00:04:22.210 --> 00:04:25.040
You can write entirely to
those APIs if you wish.

00:04:25.070 --> 00:04:28.520
And Core Foundation will silently
help out underneath the stacks,

00:04:28.520 --> 00:04:30.500
providing smooth communication.

00:04:30.530 --> 00:04:34.060
However,
this is what you're going to miss.

00:04:34.070 --> 00:04:38.100
If you yourself need to write code
that bridges between Carbon and

00:04:38.210 --> 00:04:41.770
Cocoa applications-- for instance,
if you're writing a low-level library

00:04:41.810 --> 00:04:45.870
that several different applications
are going to use-- you should be using

00:04:45.990 --> 00:04:48.210
CF to convert the types to and from.

00:04:48.500 --> 00:04:51.940
Internationalization support
is wired into Core Foundation.

00:04:51.940 --> 00:04:54.740
It's one of the easiest
places to get it from.

00:04:54.780 --> 00:04:57.450
There's a rich,
simple set of data types around

00:04:57.550 --> 00:04:59.900
the internationalized strings
inside of Core Foundation.

00:04:59.900 --> 00:05:02.250
That's what we're going
to focus on here today.

00:05:02.280 --> 00:05:06.140
And there is some new functionality
which you can only get by talking

00:05:06.140 --> 00:05:09.190
to the Core Foundation stack.

00:05:09.440 --> 00:05:11.820
So what is that new functionality?

00:05:11.900 --> 00:05:14.200
Property lists is a big one,
and that's the one

00:05:14.200 --> 00:05:15.700
we'll talk about today.

00:05:15.780 --> 00:05:19.830
There's also an XML parser
inside of Core Foundation.

00:05:19.840 --> 00:05:22.300
It's not the only
XML parser on the system,

00:05:22.420 --> 00:05:28.300
but it's the only one in C,
and it's nice and low level for your use.

00:05:28.340 --> 00:05:31.240
User preferences:
There's a unified user preferences

00:05:31.320 --> 00:05:33.300
model inside of Core Foundation.

00:05:33.300 --> 00:05:37.300
It will save you from having to invent
your own preferences file format,

00:05:37.480 --> 00:05:41.290
and doing your own work of
reading and writing to file.

00:05:41.480 --> 00:05:44.810
Finally, and perhaps most importantly,

00:05:45.230 --> 00:05:48.990
The bundle and plug-in model
that surrounds the entire app

00:05:49.050 --> 00:05:53.180
packaging scheme on Mac OS X is
centered in Core Foundation.

00:05:53.610 --> 00:06:00.450
So if you want to pull apart the
pieces of that app packaging format,

00:06:00.450 --> 00:06:00.450
you should be talking to Core Foundation.

00:06:02.070 --> 00:06:05.120
Okay, so now I'm going to move on to
talk about the basic concepts and

00:06:05.230 --> 00:06:08.200
paradigms inside of Core Foundation.

00:06:09.240 --> 00:06:12.770
I'm going to spend a moment on the
general philosophy of the library.

00:06:12.770 --> 00:06:16.300
Then I'm going to talk about how we
manage to get some object orientation

00:06:16.300 --> 00:06:20.060
inside of what is a purely C library.

00:06:20.740 --> 00:06:24.620
And finally,
I'm going to look at the memory

00:06:24.620 --> 00:06:24.620
management scheme that we use.

00:06:25.530 --> 00:06:29.100
The general philosophy of core
foundation is to be lean and mean.

00:06:29.100 --> 00:06:32.270
We are just barely above
the operating system layer.

00:06:32.280 --> 00:06:36.410
Performance and efficiency
is perhaps our primary goal.

00:06:36.420 --> 00:06:40.080
For that reason,
we have exported a minimal API and

00:06:40.090 --> 00:06:43.480
tried to make it as powerful
and extensible as possible.

00:06:43.480 --> 00:06:47.750
So you will not find a lot of convenience
functions to do simple operations.

00:06:47.860 --> 00:06:52.640
You will find some complex, powerful,
functional API where you may

00:06:52.640 --> 00:06:55.890
have to do some configuration
of the arguments going in.

00:06:57.370 --> 00:07:00.600
Finally, there is no safety net
in Core Foundation.

00:07:00.700 --> 00:07:03.280
We follow the same
philosophy as the C language:

00:07:03.280 --> 00:07:07.200
if you tell us to do something,
we're going to do it, no questions asked.

00:07:07.300 --> 00:07:11.180
So if you hand us a bad pointer,
we're going to try and access it.

00:07:11.550 --> 00:07:15.830
To try and ease the road a little bit,
we do provide a debug library,

00:07:15.830 --> 00:07:19.510
and that debug library is
available so that as you code,

00:07:19.580 --> 00:07:21.690
you can run against it,
and it will catch a

00:07:21.690 --> 00:07:23.500
number of common errors.

00:07:23.740 --> 00:07:28.060
And that way you can start
to debug your program.

00:07:29.580 --> 00:07:35.190
So, object orientation inside of
Core Foundation focuses on CF types.

00:07:35.530 --> 00:07:40.300
And we try to make this as
available as possible in the

00:07:40.300 --> 00:07:42.760
naming inside of Core Foundation.

00:07:42.850 --> 00:07:46.380
So each type is opaque and
represents a pseudo class,

00:07:46.500 --> 00:07:52.070
and each such type is
going to be named CF,

00:07:52.070 --> 00:07:52.070
and then the class name Ref.

00:07:52.800 --> 00:07:56.200
The related functions,
which are acting as methods on the class,

00:07:56.450 --> 00:07:58.980
will always be prefixed
with the name of the class,

00:07:58.980 --> 00:08:01.450
cf, class name,
and then an action describing

00:08:01.520 --> 00:08:03.080
what the function does.

00:08:03.080 --> 00:08:07.490
Related constants also are
prefixed with the class name,

00:08:07.600 --> 00:08:10.690
k, cf, class, and then a descriptor.

00:08:10.700 --> 00:08:15.700
So for example, if we look at CFStrings,
the type is CFStringRef.

00:08:15.700 --> 00:08:19.620
An example of a function
would be CFString append,

00:08:19.690 --> 00:08:25.720
and an example of the constant
would be kcf string encoding ascii.

00:08:27.140 --> 00:08:30.260
Furthermore, inside the functions,
the first argument is

00:08:30.260 --> 00:08:33.010
always the type instance,
what you would consider the

00:08:33.020 --> 00:08:36.500
receiver if you were writing in
a true object-oriented language.

00:08:36.630 --> 00:08:38.240
Now there's one important
exception to that,

00:08:38.240 --> 00:08:41.590
and that's creators,
and we'll get to those in a minute.

00:08:41.970 --> 00:08:54.180
We use common verbs to have common
meanings throughout the API,

00:08:54.180 --> 00:08:54.180
so that CFArray add is going to work
the same way as CFDictionary add.

00:08:54.440 --> 00:08:57.650
Finally, when we are passing
information back to you,

00:08:57.650 --> 00:09:01.500
we will always put those out parameters,
the ones that are going

00:09:01.550 --> 00:09:04.400
to be passed by reference,
at the very end.

00:09:06.700 --> 00:09:11.250
There are a small number of
polymorphic functions inside of CF.

00:09:11.400 --> 00:09:13.600
This is the entire list.

00:09:13.750 --> 00:09:18.410
These functions can be
used with any CF type,

00:09:18.580 --> 00:09:20.990
regardless of class.

00:09:21.380 --> 00:09:25.640
So, equality and hashing,
CFEqual and CFHash,

00:09:25.710 --> 00:09:32.390
that's what allows us to add objects into
collections and retrieve them out of it.

00:09:32.760 --> 00:09:39.410
There's a little bit of introspection.

00:09:39.410 --> 00:09:39.410
CFGetTypeId will return
the type ID of the class.

00:09:39.720 --> 00:09:44.520
CF copy description will provide a
string description of the object.

00:09:44.520 --> 00:09:46.260
This is for debugging purposes only.

00:09:46.260 --> 00:09:48.120
These are not intended
to show to the user.

00:09:48.120 --> 00:09:50.430
In fact,
they will frequently have the hex

00:09:50.490 --> 00:09:54.530
address of the object embedded in them.

00:09:54.560 --> 00:09:56.840
And finally, memory management.

00:09:56.840 --> 00:10:00.130
We use a reference counting
memory management scheme,

00:10:00.140 --> 00:10:03.360
so CF retain gains a reference,
CF release releases it.

00:10:03.580 --> 00:10:07.100
CF get retain count is intended
for debugging purposes only,

00:10:07.190 --> 00:10:10.120
so you can track how the
reference counting goes

00:10:10.280 --> 00:10:11.240
through an object's lifetime.

00:10:11.240 --> 00:10:16.110
And then CF get allocator allows you to
discover how the object was allocated.

00:10:19.170 --> 00:10:21.990
So, as I just said,
CF types are reference counted,

00:10:22.340 --> 00:10:26.100
retained to take a reference,
released to release it.

00:10:26.100 --> 00:10:28.440
Anytime you have a
reference counting scheme,

00:10:28.440 --> 00:10:35.160
you have this common problem of
who has the reference when an

00:10:35.160 --> 00:10:35.160
object is returned by a function.

00:10:35.500 --> 00:10:36.590
Here are the rules.

00:10:36.780 --> 00:10:38.060
Very, very simple.

00:10:38.130 --> 00:10:43.090
If the function you called includes the
word "get," you did not get a reference.

00:10:43.260 --> 00:10:46.560
The object you called
retains the reference.

00:10:46.680 --> 00:10:51.650
So if you intend to keep that object,
you'd better retain it yourself.

00:10:51.860 --> 00:11:02.670
Functions that include the words
"copy" or "create," on the other hand,

00:11:02.670 --> 00:11:02.670
give you a reference.

00:11:02.670 --> 00:11:02.670
And when you are done with that object,
you must release it,

00:11:02.670 --> 00:11:02.670
or else you will have a leak.

00:11:05.380 --> 00:11:07.360
There is something important
to keep in mind here.

00:11:07.480 --> 00:11:11.840
We are simply using copy and
create as a way of telling you,

00:11:12.080 --> 00:11:16.230
the developer,
whether or not you've got a reference.

00:11:16.230 --> 00:11:19.890
There may be some optimizations
going on in the back,

00:11:19.970 --> 00:11:23.290
particularly in the case
of immutable objects.

00:11:23.290 --> 00:11:26.070
So even though you've
received a reference,

00:11:26.090 --> 00:11:28.840
copy may not actually
do any memory copying,

00:11:28.840 --> 00:11:32.140
and likewise,
create may not do any allocation.

00:11:32.260 --> 00:11:35.520
CF is simply being more efficient
and it shouldn't matter to you.

00:11:38.700 --> 00:11:39.240
Allocators.

00:11:39.240 --> 00:11:44.070
An allocator, there is a type for it,
CFAllocatorRef.

00:11:44.070 --> 00:11:48.390
An allocator encapsulates
an allocation scheme.

00:11:48.390 --> 00:11:54.390
You call an allocator to allocate memory,
to release it, to reallocate it,

00:11:54.560 --> 00:11:55.400
and so on.

00:11:55.400 --> 00:11:59.010
And every create function,
so every function that

00:11:59.010 --> 00:12:02.790
could create a CF object,
takes an allocator as its first

00:12:03.120 --> 00:12:07.160
argument and uses that allocator
to create the memory necessary.

00:12:08.330 --> 00:12:11.700
Normally, you're going to want to
pass kcfallocator default,

00:12:11.810 --> 00:12:16.660
which asks CF to use whatever
the current default allocator is.

00:12:16.840 --> 00:12:19.610
There's one,
we have one that we install by default.

00:12:19.620 --> 00:12:21.750
If you want to,
you can install your own to

00:12:21.750 --> 00:12:23.510
do custom memory management.

00:12:26.680 --> 00:12:30.360
That's all I'm going to say
on the basic structure of CF,

00:12:30.360 --> 00:12:32.070
or the basic concepts.

00:12:32.190 --> 00:12:34.800
And now I'm going to move on
to talk about some of the basic

00:12:34.870 --> 00:12:36.600
types inside of Core Foundation.

00:12:36.600 --> 00:12:40.160
We're going to start with CFString,
because that's probably the

00:12:40.160 --> 00:12:42.410
most basic of the types,
the one that you're

00:12:42.410 --> 00:12:43.600
most likely to be using.

00:12:43.600 --> 00:12:47.230
Then we're going to talk briefly
about CFArray and CFDictionary,

00:12:47.260 --> 00:12:49.600
which are two of our collection types.

00:12:49.600 --> 00:12:52.120
Once we're done with that,
we'll look at how collections

00:12:52.120 --> 00:12:54.600
and mutability work together
inside this library.

00:12:54.600 --> 00:12:57.530
And finally,
we're going to see how all of that

00:12:57.640 --> 00:13:00.390
comes together to form property lists.

00:13:02.120 --> 00:13:07.790
Conceptually, a CFString is simply an
array of Unicode characters.

00:13:08.500 --> 00:13:11.920
The goal in creating a CF type,
whereas I show here,

00:13:11.920 --> 00:13:15.490
we're trying to get strings
to a new level of abstraction.

00:13:15.490 --> 00:13:19.080
We're trying to solve
the 8-bit ASCII problem.

00:13:20.650 --> 00:13:30.090
If we can do that,
then internationalization becomes easy,

00:13:30.090 --> 00:13:30.090
because the basic type
throughout the entire system

00:13:30.090 --> 00:13:30.090
will support Unicode characters.

00:13:31.100 --> 00:13:34.750
Because we're at such a low level,
we've worked hard to assure performance.

00:13:34.750 --> 00:13:37.570
So even though conceptually
you're looking at an array

00:13:37.570 --> 00:13:40.990
of Unicode characters,
it may not internally be stored that way.

00:13:41.000 --> 00:13:46.610
In particular,
you're not always going to be

00:13:46.610 --> 00:13:46.610
storing two bytes per character.

00:13:47.770 --> 00:13:51.460
And as we move forward,
CFStrings are becoming the

00:13:51.460 --> 00:13:56.330
way to communicate strings
in all of the public APIs.

00:13:57.660 --> 00:14:01.300
CFString maintains a very
rich functionality set.

00:14:01.450 --> 00:14:05.000
There are a number of different creation
functions depending on where you may

00:14:05.000 --> 00:14:08.690
have gotten your string data from,
whether it's coming from

00:14:08.690 --> 00:14:13.150
a Carbon stack or Cocoa,
or you just read it out of a file.

00:14:13.320 --> 00:14:19.700
There's a lot of support for encoding
conversions from CFStrings to

00:14:19.700 --> 00:14:19.700
whatever encoding you need to use.

00:14:20.300 --> 00:14:23.040
We will do comparisons, finds, searches.

00:14:23.120 --> 00:14:27.190
There are some more complex operations
like exploding a string into its

00:14:27.290 --> 00:14:31.090
component pieces or combining
the component pieces back again.

00:14:31.270 --> 00:14:36.510
And there's even some printf style
formatting and parsing available.

00:14:38.410 --> 00:14:42.400
So, let's look at some of the API.

00:14:42.400 --> 00:14:46.360
For creation and access,
I give an example of a couple of

00:14:46.360 --> 00:14:48.540
the basic creation methods here.

00:14:48.540 --> 00:14:52.470
CF Create With Characters allows you
to take an array of Unicode characters

00:14:52.570 --> 00:14:54.140
and create a string out of it.

00:14:54.370 --> 00:14:55.180
Pretty straightforward.

00:14:55.300 --> 00:14:58.580
If, on the other hand,
you're coming from a Pascal string,

00:14:58.670 --> 00:15:01.400
for instance,
you would use the second function:

00:15:01.400 --> 00:15:03.300
CFString Create With Pascal String.

00:15:03.300 --> 00:15:07.220
There are several other similar kinds
of functions for the other types:

00:15:07.320 --> 00:15:09.920
CFString Create With File System
Representation,

00:15:09.920 --> 00:15:14.710
CFString Create From Data,
where you provide an encoding, and so on.

00:15:15.020 --> 00:15:23.330
For basic access,
you'll use the next two functions.

00:15:23.430 --> 00:15:25.580
CFString getLength returns the
current length of the string.

00:15:25.580 --> 00:15:25.580
CFString getCharacterAtIndex returns
the character at the given index.

00:15:25.770 --> 00:15:33.710
If you want more efficient processing,
you can get a range of characters at

00:15:33.710 --> 00:15:37.900
once using CFString GetCharacters.

00:15:37.900 --> 00:15:43.290
And if you have a CFString and find that
you need a Pascal string or some other

00:15:43.290 --> 00:15:43.290
type to communicate with another API,
you can get it with

00:15:43.290 --> 00:15:43.290
CFString GetPascalString.

00:15:43.470 --> 00:15:45.800
Finally,
the last line there shows you how

00:15:45.800 --> 00:15:47.800
you create a constant CFString.

00:15:47.900 --> 00:15:51.750
CFSTR, all caps,
and then the string within quotes will

00:15:51.820 --> 00:15:54.900
produce a constant CFString for your use.

00:15:57.320 --> 00:15:59.340
Mutating, some CFStrings are mutable.

00:15:59.340 --> 00:16:01.340
We'll talk more about that in a bit.

00:16:01.420 --> 00:16:05.290
If you have immutable strings,
here are the basic functions you'll use.

00:16:05.410 --> 00:16:09.600
CFString append appends another
string onto the base string.

00:16:09.710 --> 00:16:14.070
CFString replace replaces a range
of characters inside the current

00:16:14.070 --> 00:16:16.090
string with another string.

00:16:16.190 --> 00:16:19.560
CFString insert performs
a straight up insertion,

00:16:19.630 --> 00:16:22.490
and CFString trim is added
here as an example of more

00:16:22.610 --> 00:16:24.850
complex functionality available.

00:16:25.060 --> 00:16:29.460
CFString trim will take a trim string
and compare it to the beginning and the

00:16:29.460 --> 00:16:34.380
end of the given string and strip it
off however many times it may appear.

00:16:36.930 --> 00:16:40.320
Now, I said that CFStrings are becoming
the way by which strings are

00:16:40.320 --> 00:16:42.020
communicated throughout the APIs.

00:16:42.130 --> 00:16:44.800
So here's an example of this.

00:16:44.800 --> 00:16:47.920
If you look inside the Carbon toolbox,
there's some old API you

00:16:47.920 --> 00:16:51.260
may be familiar with:
setWtitle and getWtitle,

00:16:51.260 --> 00:16:54.140
which set and get the title of a window.

00:16:55.500 --> 00:17:01.460
After the introduction
of Core Foundation,

00:17:01.460 --> 00:17:10.690
the API below it has been introduced:
Set Window Title with CFString,

00:17:10.690 --> 00:17:11.370
Copy Window Title as CFString,
which allows you to set the

00:17:11.370 --> 00:17:11.370
window title in a richer,
Unicode-ready manner.

00:17:17.390 --> 00:17:23.330
Okay, another basic type
inside of CF is CFData.

00:17:23.420 --> 00:17:29.710
CFData is simply a way to get an object
representation around an array of bytes.

00:17:30.410 --> 00:17:35.270
It's more versatile than using a
simple void star or a struct pointer

00:17:35.580 --> 00:17:39.400
because it's opaque and because it
encapsulates the notion of length.

00:17:39.400 --> 00:17:42.400
And there are a couple
very basic accessors:

00:17:42.400 --> 00:17:45.500
cfdata-get-length and
cfdata-get-byte-pointer.

00:17:47.680 --> 00:17:51.100
I'm going to move on now
to talk about collections.

00:17:51.220 --> 00:17:54.960
There are a number of different
collections inside of Core Foundation,

00:17:54.960 --> 00:18:02.700
and by a collection I simply mean an
object which can hold other pointers,

00:18:02.700 --> 00:18:02.700
and most of the time you're going
to be holding other objects.

00:18:02.890 --> 00:18:05.780
CFArray and dictionary are
by far the most common of the

00:18:05.860 --> 00:18:07.860
collections you would be using.

00:18:07.990 --> 00:18:11.560
An array, as you would expect,
holds an ordered list of values,

00:18:11.560 --> 00:18:14.550
and a dictionary holds
values as key-value pairs.

00:18:14.800 --> 00:18:18.220
You give me the key,
I'll give you the value.

00:18:18.530 --> 00:18:22.330
There are a number of less common
collections also on the system:

00:18:22.330 --> 00:18:26.600
Set, Bag, Bit Vector, Binary Heap,
Tree are just a few of them.

00:18:26.600 --> 00:18:29.270
There are actually
several others as well.

00:18:31.220 --> 00:18:34.440
So, let's look at CFArray.

00:18:34.440 --> 00:18:37.570
A couple creation methods:
CFArray create creates

00:18:37.570 --> 00:18:39.040
an immutable array.

00:18:39.040 --> 00:18:41.910
You give me an array of
values and the number there,

00:18:41.910 --> 00:18:44.100
and I'll create an array around it.

00:18:44.140 --> 00:18:46.860
CFArray create mutable
creates a mutable array.

00:18:47.100 --> 00:18:51.480
And you will tell us the
capacity and the callbacks.

00:18:51.620 --> 00:18:53.090
We'll talk about that in a moment.

00:18:53.100 --> 00:18:56.100
Once you've got an array,
the basic API is CFArray get

00:18:56.100 --> 00:18:59.090
count to find out how many
objects are in the array,

00:18:59.090 --> 00:19:02.400
and then CFArray get value at index,
which will give you the

00:19:02.450 --> 00:19:04.100
value at the given index.

00:19:04.100 --> 00:19:11.610
CFArray insert value at index
is the most common mechanism.

00:19:12.200 --> 00:19:13.100
CFDictionary.

00:19:13.100 --> 00:19:15.540
You'll notice the naming
between CFDictionary and

00:19:15.540 --> 00:19:17.100
CFArray is very consistent.

00:19:17.100 --> 00:19:19.950
CFDictionary create creates
an immutable dictionary.

00:19:20.180 --> 00:19:22.880
CFDictionary create mutable
creates a mutable one.

00:19:23.100 --> 00:19:26.820
CFDictionary get count gives you
the number of key value pairs

00:19:26.820 --> 00:19:29.230
currently stored in the dictionary.

00:19:29.350 --> 00:19:32.540
Get value, you provide the key,
will give you the value back

00:19:32.540 --> 00:19:34.040
associated with that key.

00:19:34.160 --> 00:19:39.680
And set value allows you to
associate a value with a given key.

00:19:41.980 --> 00:19:43.720
So now that we've looked
at those basic APIs,

00:19:43.800 --> 00:19:47.340
let's talk about collections
in more general terms.

00:19:47.390 --> 00:19:50.180
All of our collections
contain pointer-sized values.

00:19:50.180 --> 00:19:53.860
As I said, most of the time,
you're going to be storing other objects,

00:19:53.860 --> 00:19:54.860
but not always.

00:19:54.900 --> 00:19:57.480
So how do you configure
the behavior differently,

00:19:57.510 --> 00:19:59.240
depending on what's being stored?

00:19:59.300 --> 00:20:01.450
Well,
that's what the callbacks are all about.

00:20:01.700 --> 00:20:05.580
You pass the callbacks when the
collection is first created.

00:20:05.590 --> 00:20:10.110
And the callbacks tell the object
what to do as objects are being added

00:20:10.110 --> 00:20:13.060
and removed from the collection.

00:20:14.320 --> 00:20:21.080
Collections can also be created
either mutable or immutable,

00:20:21.200 --> 00:20:26.000
and we'll go into both callbacks
and mutability in greater detail.

00:20:26.570 --> 00:20:28.190
Okay.

00:20:28.320 --> 00:20:30.950
So as I said,
callbacks determine what the array

00:20:30.950 --> 00:20:36.150
or the dictionary is going to do
as values are added or removed.

00:20:36.530 --> 00:20:39.260
90% of the time,
you're going to be storing other

00:20:39.470 --> 00:20:41.740
CF objects inside of the collection.

00:20:41.810 --> 00:20:44.960
When that happens,
use the default callbacks we provide.

00:20:45.230 --> 00:20:48.760
So for example,
KCF type array callbacks is the set

00:20:48.760 --> 00:20:53.060
of callbacks you use for an array
that's going to store CF types.

00:20:53.130 --> 00:20:56.280
As you would expect,
as objects are added to an array,

00:20:56.410 --> 00:20:59.550
this set of callbacks will
retain the objects on the way in,

00:20:59.880 --> 00:21:02.270
release them on the way out.

00:21:02.970 --> 00:21:06.560
Of the remaining 10% of the time,
9% of that is going to be,

00:21:06.560 --> 00:21:10.070
your collections are probably
going to hold pointers that you

00:21:10.100 --> 00:21:12.080
just want to manage yourself.

00:21:12.220 --> 00:21:16.100
You would rather the collection
does not do any management for you.

00:21:16.270 --> 00:21:18.660
When that's the case, simply pass null.

00:21:18.780 --> 00:21:23.480
At that point, CFArray, CFDictionary,
all the collections will

00:21:23.580 --> 00:21:25.830
simply take their hands off.

00:21:25.830 --> 00:21:28.690
You give it a pointer value,
it'll hold the pointer value,

00:21:28.690 --> 00:21:28.690
but it won't do anything with it.

00:21:29.200 --> 00:21:32.560
Once in a blue moon,
you will be using CFArray or

00:21:32.560 --> 00:21:36.920
CFDictionary to store a special
data structure that has its

00:21:36.920 --> 00:21:39.560
own memory management scheme.

00:21:39.700 --> 00:21:43.640
This is the point at which you're
going to be writing your own callbacks.

00:21:43.780 --> 00:21:47.380
You will have to add functions that
define how the object is retained

00:21:47.380 --> 00:21:51.100
on the way into the collection,
how it should be released on the way out,

00:21:51.250 --> 00:21:54.650
and then you will pass those
callbacks to CFArray or whatever

00:21:54.710 --> 00:21:56.490
collection you're using.

00:21:58.680 --> 00:22:00.560
Moving on to mutability.

00:22:00.850 --> 00:22:04.160
There are three kinds of
mutability in this system.

00:22:04.740 --> 00:22:07.900
An immutable object, as you would expect,
you can change neither

00:22:07.900 --> 00:22:10.580
the contents nor the size.

00:22:10.680 --> 00:22:16.800
Once the object has been created,
the data is going to remain constant

00:22:16.800 --> 00:22:16.800
until the object is destroyed.

00:22:17.480 --> 00:22:21.960
A fixed-size collection:
you can change the contents all you want,

00:22:21.960 --> 00:22:25.300
as long as you do not
exceed the given capacity.

00:22:25.440 --> 00:22:29.940
And a fully mutable collection:
you can change the contents and the size.

00:22:30.860 --> 00:22:33.900
Not all of the collections support
all of the kinds of mutability.

00:22:33.900 --> 00:22:35.300
Both array and dictionary do.

00:22:35.680 --> 00:22:37.450
When you're in doubt,
check the documentation.

00:22:37.450 --> 00:22:40.750
The documentation clearly marks
what kinds of mutability are

00:22:40.750 --> 00:22:42.700
supported by which collections.

00:22:42.700 --> 00:22:47.000
And also, I wanted to mention here,
although CFString and CFData are not

00:22:47.090 --> 00:22:50.600
themselves collections of other objects,
conceptually,

00:22:50.640 --> 00:22:54.520
a string is a collection of characters,
and data is a collection of bytes.

00:22:54.700 --> 00:22:58.080
And therefore,
we use these mutability principles

00:22:58.080 --> 00:23:00.700
for both CFString and CFData as well.

00:23:00.720 --> 00:23:03.700
And they also support all
three types of mutability.

00:23:06.200 --> 00:23:10.900
So the way it works is this:
when you call CFString create,

00:23:10.950 --> 00:23:15.240
CFArray create, whatever,
you're going to get back

00:23:15.240 --> 00:23:17.710
a fully immutable object.

00:23:18.170 --> 00:23:23.740
When you call CFArrayCreateMutable,
you will get back a mutable object.

00:23:23.890 --> 00:23:26.740
If the specified capacity
is greater than zero,

00:23:27.040 --> 00:23:31.000
that will be taken as the maximum
capacity for your collection.

00:23:31.050 --> 00:23:40.010
So CFArrayCreateMutable with a
capacity of 10 produces an array that

00:23:40.010 --> 00:23:40.010
can never hold more than 10 objects.

00:23:40.290 --> 00:23:43.040
On the other hand,
if you pass a capacity of zero,

00:23:43.140 --> 00:23:46.200
we will create a fully
mutable object for you,

00:23:46.230 --> 00:23:50.510
and the array or string or
dictionary will automatically

00:23:50.520 --> 00:23:53.180
grow as new objects are added in.

00:23:54.820 --> 00:23:57.960
So, for example,
CFArray create is going to

00:23:57.960 --> 00:23:59.290
produce an immutable array.

00:23:59.590 --> 00:24:03.490
You just provide the objects that
are going in and the number of them,

00:24:03.610 --> 00:24:05.160
and there you go.

00:24:05.260 --> 00:24:09.640
CFDictionary create mutable,
passing a capacity of 10,

00:24:09.780 --> 00:24:13.870
creates a mutable dictionary
that can never contain more

00:24:13.870 --> 00:24:16.200
than 10 key value pairs.

00:24:16.410 --> 00:24:24.540
CFString Create Mutable,
passing a capacity of zero,

00:24:24.540 --> 00:24:31.780
produces a fully mutable
string of unlimited length,

00:24:31.780 --> 00:24:31.780
and as strings and characters
are added to this string,

00:24:31.780 --> 00:24:31.780
it will grow to accommodate them.

00:24:34.410 --> 00:24:37.290
So, how does this all come together?

00:24:37.420 --> 00:24:40.310
Well,
given these basic pieces of strings,

00:24:40.620 --> 00:24:44.680
datas, arrays, and dictionaries,
you can actually build up some

00:24:44.680 --> 00:24:47.030
very complex trees of objects.

00:24:47.280 --> 00:24:52.530
We also support several other types,
but String, Data, Array,

00:24:52.530 --> 00:24:55.770
and Dictionary form the core of them.

00:24:56.790 --> 00:24:58.190
There are a couple restrictions.

00:24:58.280 --> 00:25:00.440
First of all, it has to be a true tree,
no loops,

00:25:00.440 --> 00:25:06.740
so arrays can't include themselves,
dictionaries can't include themselves.

00:25:07.240 --> 00:25:11.100
Secondly, the keys of the dictionaries
must always be strings.

00:25:11.290 --> 00:25:14.980
And we create an abstraction
on top of such a structure and

00:25:14.980 --> 00:25:17.240
call it a CF property list ref.

00:25:17.360 --> 00:25:20.210
So why are property lists useful?

00:25:20.640 --> 00:25:23.500
They're useful because
we make them persistent.

00:25:23.500 --> 00:25:26.600
They have a simple,
flattened XML representation,

00:25:26.600 --> 00:25:31.020
and you can easily convert to and from
that flattened XML representation,

00:25:31.200 --> 00:25:34.500
expressed as a data,
and the rich tree structure.

00:25:34.500 --> 00:25:37.420
Now, we do not handle the
file access part of this.

00:25:37.500 --> 00:25:40.500
As a rule, Core Foundation does not
touch the file system.

00:25:40.500 --> 00:25:44.930
So it's up to you to read and
write the data to and from whatever

00:25:44.930 --> 00:25:47.310
file you're taking it from.

00:25:50.630 --> 00:25:55.740
So why does this make
property lists useful?

00:25:55.750 --> 00:26:00.340
It's useful because property
lists are very easy to program.

00:26:00.400 --> 00:26:01.330
They're small.

00:26:01.730 --> 00:26:03.140
They're very, very flexible.

00:26:03.140 --> 00:26:08.370
If you need to represent new data,
just tack another object onto the end

00:26:08.370 --> 00:26:10.330
of the array or create a new string.

00:26:10.460 --> 00:26:14.430
And as I said, they're persistent.

00:26:14.430 --> 00:26:15.580
The API for persistency
is very straightforward.

00:26:16.140 --> 00:26:19.060
So, if you ever find
yourself needing a small,

00:26:19.060 --> 00:26:23.230
flexible data format of some kind,
try out CF Property Lists.

00:26:23.290 --> 00:26:25.500
See if it'll manage your needs.

00:26:25.650 --> 00:26:28.380
The one caveat here is,
property lists are not

00:26:28.380 --> 00:26:30.160
useful as a general database.

00:26:30.160 --> 00:26:34.740
It does not scale well,
and that's because XML is a

00:26:34.740 --> 00:26:38.110
serialized data representation.

00:26:38.110 --> 00:26:39.550
So there's no ability to scan
into the middle and locate

00:26:39.550 --> 00:26:39.550
an object out of the middle.

00:26:41.930 --> 00:26:44.650
So for example,
if you look in Mac OS X where

00:26:44.650 --> 00:26:48.720
we use property lists ourselves,
you'll find them in small

00:26:48.720 --> 00:26:51.760
configuration files all over the place.

00:26:51.800 --> 00:26:54.910
We use them to configure
applications and provide much of

00:26:54.970 --> 00:26:57.240
the information that Finder needs,
for instance,

00:26:57.360 --> 00:26:59.620
when viewing an app package.

00:26:59.850 --> 00:27:03.580
Plug-ins use configuration
files to announce their APIs,

00:27:03.740 --> 00:27:08.110
as well as announcing
how they fulfill the API.

00:27:08.150 --> 00:27:11.490
There are a number of small
system Unix-y kind of parameter

00:27:11.490 --> 00:27:16.600
configuration files that have
been migrated to property lists.

00:27:16.630 --> 00:27:19.840
We also use them for the user
preferences on this system.

00:27:19.850 --> 00:27:25.440
User preferences is a classic example
of where we don't know what information

00:27:25.440 --> 00:27:28.750
a given application needs to store,
but we do know that

00:27:28.880 --> 00:27:31.660
it's likely to be small,
and we do know that our types

00:27:31.700 --> 00:27:33.760
are likely to accommodate them.

00:27:34.700 --> 00:27:47.400
[Transcript missing]

00:27:47.580 --> 00:27:50.460
So you need to deliver
an application yesterday?

00:27:50.460 --> 00:27:53.410
You might well prototype using
property lists as your data store.

00:27:53.810 --> 00:27:56.880
That will at least save you
the burden of figuring out

00:27:56.960 --> 00:28:01.270
what your final data format is,
and we found it remarkably flexible

00:28:01.270 --> 00:28:03.500
for doing quick prototyping.

00:28:03.550 --> 00:28:08.230
In fact,
the original HTML rendering engine

00:28:08.820 --> 00:28:12.710
in the Cocoa framework used property
lists entirely for its backing store.

00:28:15.610 --> 00:28:18.780
So I mentioned there were some
other property list types.

00:28:18.890 --> 00:28:22.930
These are very simple object wrappers
that you would rarely use except

00:28:22.930 --> 00:28:27.140
that you need to store a particular
kind of value in a property list.

00:28:27.670 --> 00:28:34.530
The three most common are listed here:
CFDate, Wraps a date or time, CFNumber,

00:28:34.530 --> 00:28:37.600
and CFBoolean wrap simple numeric values.

00:28:37.600 --> 00:28:40.370
And again,
we're not suggesting that you use this in

00:28:40.370 --> 00:28:42.600
place of a raw integer or a raw Boolean.

00:28:42.880 --> 00:28:49.480
Rather, when you find you need to store
such a value in a property list,

00:28:49.480 --> 00:28:53.630
these wrappers are available to do that.

00:28:53.710 --> 00:28:54.430
Okay.

00:28:54.430 --> 00:28:56.070
Debugging and getting help.

00:28:57.830 --> 00:29:01.840
I mentioned earlier that there
is a debug library available

00:29:01.840 --> 00:29:03.700
inside of Core Foundation.

00:29:03.750 --> 00:29:07.460
What the debug library adds is
a number of extra assertions,

00:29:07.460 --> 00:29:10.080
argument checking, that kind of thing.

00:29:10.080 --> 00:29:12.680
And what happens is as soon
as one of those assertions

00:29:12.680 --> 00:29:15.790
finds an invalid argument,
it's going to log an error

00:29:15.790 --> 00:29:17.060
and abort your program.

00:29:17.200 --> 00:29:19.970
That's going to make it much
easier to isolate the problem,

00:29:19.970 --> 00:29:22.470
find the change, get a good backtrace.

00:29:22.500 --> 00:29:27.580
And we found that many of the most
common programming errors we see with

00:29:27.710 --> 00:29:30.020
Core Foundation can be caught this way.

00:29:30.020 --> 00:29:34.560
So please run against the debug library
as you develop Core Foundation code.

00:29:36.950 --> 00:29:39.510
I've also put a list here
of the most common errors in

00:29:39.620 --> 00:29:42.540
programming with Core Foundation.

00:29:42.540 --> 00:29:43.900
Passing null is a CF type.

00:29:43.900 --> 00:29:45.140
There's a classic one.

00:29:45.180 --> 00:29:46.580
Null is not a CF type.

00:29:46.610 --> 00:29:53.530
It is not a valid argument to any of the
pseudo-methods inside of Core Foundation.

00:29:55.560 --> 00:29:59.760
Another common error is releasing
the return value of a get function.

00:29:59.880 --> 00:30:01.640
You call CFArray getValue.

00:30:01.640 --> 00:30:05.560
You never got a reference,
the function includes the word get,

00:30:05.970 --> 00:30:07.270
but you release it anyway.

00:30:07.600 --> 00:30:12.590
Well, sooner or later that array
is going to be destroyed,

00:30:12.630 --> 00:30:17.910
or someone else is going to
remove that value from the array.

00:30:17.910 --> 00:30:18.600
At that point,
the array will release the object itself.

00:30:18.600 --> 00:30:18.600
Boom, memory smasher.

00:30:19.620 --> 00:30:24.490
The other half of that equation is
failing to retain the value that

00:30:24.600 --> 00:30:26.500
came back from a get function.

00:30:26.630 --> 00:30:32.100
So once again, you get a value out of
CFArray using CFArrayGetValue.

00:30:32.270 --> 00:30:36.250
You intend to keep that value
past the lifetime of the array.

00:30:36.360 --> 00:30:37.440
You need to retain it.

00:30:37.440 --> 00:30:41.540
If you do not, when the array disappears,
so does your object.

00:30:43.390 --> 00:30:46.100
Okay,
so there you are in a debugging session.

00:30:46.100 --> 00:30:47.990
You've got a CF type,
you don't know what it is,

00:30:48.060 --> 00:30:51.100
and you're trying to figure
out what's gone wrong.

00:30:51.360 --> 00:30:55.560
Use CF get-type-ID to determine
the class of the object you've got.

00:30:55.560 --> 00:31:03.330
You can compare that with
CF type name get-type-ID.

00:31:03.330 --> 00:31:07.510
So CFString get-type-ID returns
the type ID for all strings.

00:31:07.510 --> 00:31:07.510
CFArray get-type-ID returns
the type ID for all arrays.

00:31:07.880 --> 00:31:11.430
CF Show will print out any
CF object to the console,

00:31:11.540 --> 00:31:14.480
or wherever standard out happens to be.

00:31:14.620 --> 00:31:19.150
In GDB, you can invoke CF Show directly
from within a breakpoint.

00:31:19.650 --> 00:31:24.110
It's very useful for looking at what
exactly has gotten into your string.

00:31:24.280 --> 00:31:27.290
If you would rather get that
information into memory,

00:31:27.290 --> 00:31:29.840
use CF copy description,
and it will give you

00:31:29.840 --> 00:31:37.190
exactly the same output,
but stored in a CFString, so you can,

00:31:37.190 --> 00:31:37.190
if you want, write it to file,
look at it later, whatever.

00:31:40.800 --> 00:31:43.800
Tracking memory problems
that occur in this system.

00:31:43.800 --> 00:31:47.800
CFGEP retain count will always return
the current reference count of an object.

00:31:47.800 --> 00:31:54.110
You can use that to make sure that
the reference count is incrementing

00:31:54.110 --> 00:31:54.110
or decrementing as you expect.

00:31:54.890 --> 00:31:58.580
You can install a custom default
allocator and use that to locate

00:31:58.580 --> 00:32:00.470
leaks and memory corruption.

00:32:00.470 --> 00:32:04.590
And finally, if you look on a DP4 system,
there's an application in

00:32:04.700 --> 00:32:07.690
System Developer Applications
called ObjectAlloc.

00:32:08.130 --> 00:32:11.510
You can run your program
under ObjectAlloc,

00:32:11.510 --> 00:32:17.450
and it will show you some of the CF types
as they are allocated and destroyed.

00:32:17.450 --> 00:32:20.330
All of the common ones are there:
CFString, Array, Dictionary,

00:32:20.330 --> 00:32:20.330
all that kind of stuff.

00:32:21.650 --> 00:32:25.330
Finally, there's a fair bit of
documentation online.

00:32:25.650 --> 00:32:28.730
You can find it in
System Developer Documentation

00:32:28.730 --> 00:32:30.940
Core Foundation on the DP4 CD.

00:32:31.010 --> 00:32:37.360
It's also available on the web at
developer.apple.com/techpubs/corefound

00:32:37.930 --> 00:32:38.160
ation.

00:32:38.160 --> 00:32:43.220
There is some example code inside of
System Developer Examples Core Foundation

00:32:44.150 --> 00:32:44.260
.

00:32:44.260 --> 00:32:48.680
And the release notes are available
in System Developer Documentation

00:32:48.850 --> 00:32:51.450
release notes:
corefoundation.html.
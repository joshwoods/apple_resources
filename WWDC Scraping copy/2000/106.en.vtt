WEBVTT

00:00:08.600 --> 00:00:23.800
[Transcript missing]

00:00:25.600 --> 00:00:28.250
I want to thank you all for
coming this early in the morning

00:00:28.330 --> 00:00:33.530
to talk about something so
wildly exciting as the kernel.

00:00:37.570 --> 00:00:40.560
Okay, what are we going to talk
about in this session?

00:00:40.560 --> 00:00:43.500
Well, mostly we're going to talk
about the Mach kernel,

00:00:43.780 --> 00:00:48.500
what the basics of the Mach kernel are,
what the basic abstractions are,

00:00:48.680 --> 00:00:53.290
when you want to program to those,
when you don't, but most importantly,

00:00:53.400 --> 00:00:57.500
how the Mach kernel and its environment
affects the rest of your development.

00:00:57.590 --> 00:01:00.140
For the majority of you,
you may be bringing over

00:01:00.200 --> 00:01:04.470
a Carbon application,
and for a lot of those applications,

00:01:04.500 --> 00:01:07.060
you fix a couple of things that
the Carbon data tells you are

00:01:07.060 --> 00:01:10.270
wrong with your application,
and you're done.

00:01:10.550 --> 00:01:13.820
But you're not,
because things don't behave exactly

00:01:13.860 --> 00:01:18.020
the same on X as they do on IX,
and a lot of those differences are based

00:01:18.090 --> 00:01:20.500
on what happens in the Mach kernel.

00:01:20.500 --> 00:01:23.830
And so we want to give you a
little background about what's

00:01:23.870 --> 00:01:27.500
happening under the covers so
you can understand your app.

00:01:28.910 --> 00:01:32.950
Okay, you're probably kind of
tired of seeing this picture,

00:01:33.020 --> 00:01:38.410
but it's basically the layout
of all applications in Mac OS X.

00:01:38.940 --> 00:01:41.090
Your application is going to
fall into one of the basic

00:01:41.190 --> 00:01:45.050
categories of a classic app,
a Carbon app, or a Cocoa app.

00:01:45.450 --> 00:01:48.740
At the bottom of that
is the Darwin layer.

00:01:48.740 --> 00:01:53.330
And inside the Darwin layer is
where the Mach kernel resides.

00:01:53.590 --> 00:02:03.690
The Mach kernel is the
foundation of the OS.

00:02:04.450 --> 00:02:06.360
It provides the basic abstractions
for getting the system running,

00:02:06.360 --> 00:02:06.360
things that

00:02:06.780 --> 00:02:08.860
Your task and your threads.

00:02:08.860 --> 00:02:12.900
The CPU and memory
abstractions of the system.

00:02:13.430 --> 00:02:20.510
Mach is intended to provide a rich set
of semantics for those kinds of services.

00:02:20.610 --> 00:02:25.230
One of the things you'll find is that
Mach was intended to develop lots of

00:02:25.490 --> 00:02:28.650
different operating systems on top.

00:02:28.770 --> 00:02:34.010
It was originally designed as a
foundation for Unix operating systems,

00:02:34.110 --> 00:02:38.530
but then other operating
systems came along,

00:02:38.600 --> 00:02:41.870
people provided DOS boxes
running on top of Mach,

00:02:42.150 --> 00:02:47.430
provided specialized operating systems
or embedded environments on top of Mach,

00:02:47.430 --> 00:02:52.460
and over the years the Mach semantics
have become richer and richer and

00:02:52.460 --> 00:02:55.400
a little bit more formal each time.

00:02:55.560 --> 00:03:00.880
And that ends up giving you a set of
semantics that let us do some things in

00:03:00.980 --> 00:03:04.300
Mac OS X that you wouldn't otherwise see.

00:03:04.300 --> 00:03:06.410
Mach is, you know,

00:03:06.560 --> 00:03:07.940
intends to be policy neutral.

00:03:07.940 --> 00:03:13.090
It leaves the policy decisions
to higher layers of software.

00:03:13.980 --> 00:03:17.880
In our situation,
a lot of those policy decisions end up

00:03:17.910 --> 00:03:21.200
in being implemented in the BSD layer.

00:03:21.300 --> 00:03:24.030
Some bubble up in the higher layer,
so Classic has some of

00:03:24.030 --> 00:03:25.960
its own policy decisions.

00:03:26.080 --> 00:03:29.980
They use Mach services,
but the Mach services

00:03:29.980 --> 00:03:32.400
try to be policy neutral.

00:03:32.550 --> 00:03:36.680
They give you a set of mechanisms,
but not the policy.

00:03:37.030 --> 00:03:39.160
So what, that's what Mach is.

00:03:39.470 --> 00:03:42.390
What Mach isn't is an operating system.

00:03:42.560 --> 00:03:43.240
Alright.

00:03:43.300 --> 00:03:48.070
Mach is just the foundation for
building operating systems on top.

00:03:48.170 --> 00:03:49.730
Mach does not provide I/O.

00:03:49.890 --> 00:03:53.600
We have I/O Kit for that,
and it provides those

00:03:53.640 --> 00:03:54.900
set of abstractions.

00:03:55.270 --> 00:03:56.860
Mach does not provide any networking.

00:03:56.950 --> 00:04:02.060
Although people have taken Mach and
networked some of the Mach services,

00:04:02.060 --> 00:04:05.900
Mach itself does not provide
any network services.

00:04:06.150 --> 00:04:10.040
Mach doesn't do file systems,
as you saw yesterday if you

00:04:10.120 --> 00:04:11.900
were in the file system session.

00:04:11.900 --> 00:04:15.930
The file systems are implemented
inside the BSD layer.

00:04:16.640 --> 00:04:19.610
Mach doesn't do any
security policies either.

00:04:19.850 --> 00:04:22.800
Again, Mach tries to provide mechanisms.

00:04:22.800 --> 00:04:25.580
It provides lots and lots
of security mechanisms and

00:04:25.590 --> 00:04:27.570
some really fundamental ones.

00:04:28.210 --> 00:04:30.540
But it makes no decisions
about how they get applied.

00:04:30.600 --> 00:04:34.290
In our situation,
a lot of those policy decisions

00:04:34.290 --> 00:04:36.380
again fall to the BSD layer.

00:04:36.600 --> 00:04:41.600
So you're going to see that we use the
BSD style of user ID and permissions.

00:04:41.600 --> 00:04:48.530
BSD then restricts your access to certain
Mach resources based on those attributes.

00:04:48.530 --> 00:04:54.730
But the Mach services really are all
based on whether you have access to

00:04:54.730 --> 00:04:59.720
those services and don't care who,
what your user ID is or what permissions

00:04:59.720 --> 00:05:01.550
you have or who you logged in as.

00:05:01.600 --> 00:05:05.760
We basically have a set of services,
a set of access points,

00:05:05.980 --> 00:05:10.600
and if you're granted access to
those services by the policy maker,

00:05:10.600 --> 00:05:14.570
the decision maker, in this case BSD,
then you get to have access.

00:05:15.100 --> 00:05:15.590
Otherwise not.

00:05:15.600 --> 00:05:20.600
Mach doesn't really provide
application APIs either.

00:05:20.870 --> 00:05:26.600
While you may dip down sometimes into the
Mach APIs in some of your applications,

00:05:26.600 --> 00:05:30.540
you're not going to be
programming to Mach itself.

00:05:30.600 --> 00:05:38.580
Mach is intended to be the layer that the
operating system pieces converse with.

00:05:38.710 --> 00:05:41.030
All right,
and all of those abstractions that

00:05:41.030 --> 00:05:44.980
we just talked about are actually
provided in higher levels of Mac OS X,

00:05:44.980 --> 00:05:46.570
or Darwin.

00:05:47.660 --> 00:05:50.670
Okay,
so why are we doing this Mach thing?

00:05:50.700 --> 00:05:53.260
It's the number one
question people ask when,

00:05:53.260 --> 00:05:55.740
in the Darwin mailing lists or otherwise.

00:05:55.740 --> 00:05:57.190
Why Mach?

00:05:59.240 --> 00:06:03.660
Well,
we do have a complex system in Mac OS X.

00:06:03.770 --> 00:06:07.340
We have lots of
environments to program to.

00:06:07.390 --> 00:06:09.750
We have the classic environment,
the Carbon environment,

00:06:09.830 --> 00:06:10.940
the Cocoa environment.

00:06:11.100 --> 00:06:14.190
We have BSD, we have I/O Kit,
we have Java.

00:06:14.500 --> 00:06:17.630
Others are coming that people
may be working on in here.

00:06:17.720 --> 00:06:23.040
People are doing DOS emulators or doing
other environments for this system.

00:06:23.090 --> 00:06:26.760
Each of these has a set of
semantics and policies that they

00:06:26.760 --> 00:06:30.800
implemented and they control,
and they cannot change.

00:06:30.920 --> 00:06:32.630
It's legacy.

00:06:33.160 --> 00:06:36.770
Mach provides a set of abstractions
that sits below a common

00:06:36.770 --> 00:06:39.540
layer that sits below those,
that allows you to

00:06:39.560 --> 00:06:42.130
implement all of those.

00:06:42.660 --> 00:06:46.080
It's been tuned over the years
to give a fairly good match

00:06:46.080 --> 00:06:47.980
to each of those environments.

00:06:48.030 --> 00:06:51.590
There are some environments which
people have tried to put under Mach,

00:06:51.630 --> 00:06:54.580
or on top of Mach,
and haven't had such a good match.

00:06:54.710 --> 00:06:58.200
But for all of the ones that,
that traditional operating systems

00:06:58.320 --> 00:07:02.340
and the new Java VM and those things,
there's been a lot of work to

00:07:02.420 --> 00:07:06.600
tune those layers between Mach and
those environments to provide a,

00:07:06.600 --> 00:07:10.600
a good match,
a good impedance match between them.

00:07:10.600 --> 00:07:12.600
But Mach does more than that.

00:07:12.600 --> 00:07:17.660
It makes sure that those services
are consistent across each other,

00:07:17.660 --> 00:07:23.600
so that a Carbon application using
memory in a certain way doesn't,

00:07:23.820 --> 00:07:26.590
doesn't destroy a Classic application
doing the same thing,

00:07:26.600 --> 00:07:31.110
or a BSD application
doing the same thing.

00:07:34.630 --> 00:07:36.300
Another reason for Mach.

00:07:36.330 --> 00:07:43.150
Again, 15 years now, Mach is nothing new
to the research world.

00:07:43.690 --> 00:07:47.780
It's new to Mac OS X,
but it's to the Mac OS environment,

00:07:47.860 --> 00:07:51.350
but it's been around for 15 years now.

00:07:51.360 --> 00:07:54.300
Lots and lots and lots and
lots and lots of research.

00:07:54.380 --> 00:07:58.250
Obviously the original research done
at Carnegie Mellon was intended to

00:07:58.250 --> 00:08:03.780
prove that you could build an operating
system by defining a layer underneath

00:08:03.810 --> 00:08:08.960
that provided the basic services and
layering the operating system on top.

00:08:09.730 --> 00:08:11.800
More work was done at
the University of Utah,

00:08:11.800 --> 00:08:13.520
kind of jumping forward in time.

00:08:13.600 --> 00:08:18.720
They took the Mach work that had been
done before them and tried to make

00:08:18.720 --> 00:08:25.600
it more modular and embedded and add
a bunch of real-time services to it.

00:08:25.810 --> 00:08:30.350
And then a lot of research was done at
the Open Group/Open Software Foundation,

00:08:30.430 --> 00:08:32.600
depending upon your time frame.

00:08:32.860 --> 00:08:36.760
There are research institutes,
both in Cambridge and in Grenoble,

00:08:36.790 --> 00:08:37.600
France.

00:08:37.960 --> 00:08:44.600
Lots and lots of real-time work done
for government contracts and otherwise.

00:08:44.880 --> 00:08:48.980
And as some of you may know,
OSF focused a lot of their

00:08:49.110 --> 00:08:53.980
research on cluster work,
building up complex systems

00:08:54.410 --> 00:08:56.590
out of modular boxes.

00:08:56.600 --> 00:09:00.600
A single system image, if you will,
across many, many boxes.

00:09:00.600 --> 00:09:05.600
And there was a lot
more research in Mach.

00:09:05.600 --> 00:09:09.520
Mach was one of the first
publicly available source codes

00:09:09.590 --> 00:09:13.600
for something other than Unix.

00:09:13.600 --> 00:09:17.600
Most people had been using BSD in
the research community forever.

00:09:17.800 --> 00:09:20.600
But if you've tried
to do research on BSD,

00:09:20.600 --> 00:09:24.360
you realize that there's a lot of knots
and a lot of things tied together in

00:09:24.360 --> 00:09:27.770
BSD that makes it difficult to pick
a piece out and do your research and

00:09:27.770 --> 00:09:29.580
replace it with a different piece.

00:09:29.600 --> 00:09:33.390
Mach is really good at
allowing pieces of the system,

00:09:33.600 --> 00:09:33.600
higher level systems, to be picked apart.

00:09:33.690 --> 00:09:36.490
And replaced.

00:09:36.600 --> 00:09:41.600
So a lot of that research
occurred on Mach.

00:09:41.600 --> 00:09:45.600
And most of that research is
available to us and to others.

00:09:45.600 --> 00:09:49.860
And we've been picking pieces,
select pieces of it to

00:09:50.400 --> 00:09:51.600
include in Mac OS X.

00:09:54.860 --> 00:09:56.600
And another obvious reason.

00:09:56.660 --> 00:10:00.780
If, for some of you that don't know,
Avi Tavenian, Dr.

00:10:00.780 --> 00:10:05.800
Avi Tavenian, our senior VP of software,
was one of the original authors of Mach.

00:10:06.100 --> 00:10:09.800
And obviously he has a fondness for it.

00:10:10.100 --> 00:10:14.120
But that's not a misplaced fondness,
in my opinion.

00:10:14.620 --> 00:10:17.040
Okay, so which Mach?

00:10:17.140 --> 00:10:21.480
If we're going to choose Mach because
it allows us to build complex systems,

00:10:21.630 --> 00:10:25.600
multi-environmented systems on a
single box that maintain consistency

00:10:25.600 --> 00:10:29.520
and yet provide good performance
to each of the environments,

00:10:29.520 --> 00:10:32.350
there are several Machs to choose from.

00:10:32.460 --> 00:10:36.350
Lots of research produces lots of Machs.

00:10:36.760 --> 00:10:40.940
The original Mach, Mach 2.x,
most of you probably know

00:10:40.940 --> 00:10:42.750
the 2.5 version of Mach.

00:10:42.760 --> 00:10:48.550
It's the one that originally got out
from CMU and found its way around.

00:10:48.640 --> 00:10:51.640
It was that,
the original work at CMU to decide,

00:10:51.640 --> 00:10:55.640
to prove that you could build
a layered operating system,

00:10:55.890 --> 00:10:59.320
that there were common services
underneath of those that a

00:10:59.380 --> 00:11:04.630
traditional operating system provides,
and that you could formalize those.

00:11:04.760 --> 00:11:08.620
But Mach 2.5 was monolithic in nature.

00:11:08.850 --> 00:11:13.200
It was a layer underneath
of BSD inside of BSD,

00:11:13.200 --> 00:11:14.160
if you will.

00:11:14.300 --> 00:11:19.710
They picked apart some of the pieces,
but built it as a single unit.

00:11:20.240 --> 00:11:25.400
Areas where that kind of showed through
the most is the virtual memory system.

00:11:25.500 --> 00:11:30.700
They provided an abstraction for
virtual memory inside of Mach,

00:11:30.830 --> 00:11:35.400
but the lower levels of that
virtual memory system had hard-coded

00:11:35.490 --> 00:11:41.690
dependencies on what BSD did
for file systems and the like.

00:11:41.940 --> 00:11:45.860
It also had hard-coded dependencies
to a lot of the other parts of BSD for

00:11:45.980 --> 00:11:50.540
signal handling and the like that
was kind of intertwined with Mach.

00:11:50.600 --> 00:11:55.650
And I/O, it had direct dependencies
on BSD I/O style.

00:11:56.160 --> 00:12:02.360
That kernel was also not really
available in a form useful for SMP.

00:12:02.950 --> 00:12:06.500
And when they did the work,
their main goal was to see if we could

00:12:06.500 --> 00:12:12.150
take a Unix operating system with Unix
current real-time constraints and see if

00:12:12.230 --> 00:12:14.710
we can implement it in a layered fashion.

00:12:14.890 --> 00:12:19.310
They did not try to extend
it in any real-time fashion.

00:12:20.600 --> 00:12:23.870
Next in the horizon was Mach 3.0.

00:12:23.900 --> 00:12:25.910
And again,
that was started at CMU to say,

00:12:26.000 --> 00:12:27.990
"Can we take this a little bit further?

00:12:28.190 --> 00:12:31.770
Can we formalize the rest of the
interfaces so that we have no dependence

00:12:32.320 --> 00:12:36.560
between the Mach portion of the
kernel and the rest of the kernel?"

00:12:37.190 --> 00:12:40.680
So they formalized all those
interfaces which had been in

00:12:40.680 --> 00:12:43.100
2.5 hard coded dependencies.

00:12:43.100 --> 00:12:47.090
So they ended up with a more
modular architecture as a result.

00:12:47.100 --> 00:12:53.090
And there was a lot of work that
occurred once this basic work happened.

00:12:53.200 --> 00:12:56.290
There was a lot of research that
came along in the areas of real

00:12:56.420 --> 00:12:59.100
time and in the areas of MP.

00:12:59.260 --> 00:13:02.100
And most of that work got folded back in.

00:13:02.100 --> 00:13:03.080
Some of it didn't.

00:13:03.160 --> 00:13:05.100
There was a bunch of
work at CMU on real time,

00:13:05.100 --> 00:13:07.520
if any of you are familiar with Dr.

00:13:07.520 --> 00:13:09.100
Takuda's work on real time.

00:13:09.100 --> 00:13:14.290
A lot of that did not get directly
into the standard Mach 3.0 base,

00:13:14.550 --> 00:13:19.100
but found its way in over time
through various other projects.

00:13:19.380 --> 00:13:25.100
And Mach 3.0 was where MP became
a very formal part of the system.

00:13:25.100 --> 00:13:28.930
And of course that's
quite interesting to us.

00:13:29.540 --> 00:13:34.670
Okay, Mac OS X, the server product,
and the Darwin zero dot variants

00:13:34.680 --> 00:13:40.380
of the operating system were based
on that original Mach 2.5 work.

00:13:40.400 --> 00:13:45.400
It included, if any of you have looked
at the Darwin source,

00:13:45.430 --> 00:13:48.790
a lot of the features,
the niceties at the user

00:13:48.790 --> 00:13:51.400
level from the Mach 3.0 work.

00:13:51.400 --> 00:13:55.980
A lot of the Mach 3.0 IPC interfaces
and the like had been brought forward

00:13:56.090 --> 00:13:58.400
by Apple and others into that kernel.

00:13:58.400 --> 00:14:01.000
internal.

00:14:01.000 --> 00:14:02.990
Mostly by next, but we, we

00:14:03.210 --> 00:14:08.000
picked a lot of that up at Apple,
and that was in the Mach,

00:14:08.340 --> 00:14:10.290
the server kernel.

00:14:10.540 --> 00:14:14.240
For Mac OS X,
and you've got to excuse me, I'm,

00:14:14.380 --> 00:14:18.230
a lot of times I'll say Mach OS X,
a bias.

00:14:19.200 --> 00:15:21.100
[Transcript missing]

00:15:21.310 --> 00:15:27.240
Basically, a lot of distribution was
what they were going after.

00:15:27.240 --> 00:15:30.410
But we had,
there was a bunch of work going

00:15:30.410 --> 00:15:33.290
on at OSF also to fold back in
some of the research that had

00:15:33.290 --> 00:15:35.600
been happening at other places.

00:15:35.700 --> 00:15:40.050
After CMU stopped working on Mach 3.0,
a lot of the Mach work drifted

00:15:40.140 --> 00:15:42.940
over to University of Utah.

00:15:42.940 --> 00:15:46.340
And they were working
on their Mach 4.0 base,

00:15:46.340 --> 00:15:49.030
which actually wasn't, wasn't, wasn't,
wasn't

00:15:49.440 --> 00:15:52.800
A lot of people think 4.0 may
be more advanced than 3.0,

00:15:52.820 --> 00:15:53.350
but it's not.

00:15:53.460 --> 00:15:56.970
It just had different goals and
they chose a new name because

00:15:57.260 --> 00:15:59.050
3.0 had been used so much.

00:15:59.220 --> 00:16:04.230
So a lot of that work from that
environment had been brought back by

00:16:04.230 --> 00:16:07.880
OSF and integrated into their kernels,
but not the ones that they

00:16:07.880 --> 00:16:11.000
made publicly available,
the ones that were used internally

00:16:11.510 --> 00:16:13.840
and given to their partners.

00:16:13.880 --> 00:16:18.410
Well, when we started our work,
we had that code brought back and

00:16:18.410 --> 00:16:23.770
merged with the work we had done
with our Mac Linux Mach 3.0 kernel,

00:16:23.770 --> 00:16:25.840
and that became our base.

00:16:25.920 --> 00:16:28.360
So in essence,
we actually pulled a lot of that

00:16:28.420 --> 00:16:32.420
private code that had been done at
OSF and only available to OSF partners,

00:16:32.420 --> 00:16:35.340
and through our licensing of that,
have made it available into

00:16:35.430 --> 00:16:39.890
the public source again,
where it had not been available before.

00:16:40.460 --> 00:16:44.530
And besides the work that we
had done on Mac Linux at Apple,

00:16:44.580 --> 00:16:48.390
we have done lots and lots and
lots of things to it since then,

00:16:48.790 --> 00:16:53.000
and you'll see some of that
work in the further slides.

00:16:53.400 --> 00:16:57.660
Okay, so, a lot of people say,
but that Mach 3.0 thing,

00:16:57.660 --> 00:17:00.040
it's inefficient.

00:17:00.100 --> 00:17:00.860
I've heard it.

00:17:00.920 --> 00:17:06.220
Everyone tells me it's inefficient,
because the general goal of Mach 3.0 was,

00:17:06.520 --> 00:17:10.150
in order to prove that you could
have the Mach kernel providing

00:17:10.580 --> 00:17:14.000
a rich set of abstractions,
we wanted to be able to prove that you

00:17:14.000 --> 00:17:17.600
could run the Mach kernel separate from
the other environments in the system.

00:17:17.740 --> 00:17:22.610
So BSD ran as a user level
task in that environment.

00:17:23.700 --> 00:19:09.300
[Transcript missing]

00:19:10.870 --> 00:19:14.580
Okay, so how do you guys access all
these powerful abstractions that

00:19:14.750 --> 00:19:17.470
allow all of these funny things,
all these wonderful things

00:19:17.560 --> 00:19:19.910
to happen in Mac OS X?

00:19:20.430 --> 00:19:24.180
Well, for the most part, you don't.

00:19:24.290 --> 00:19:28.760
Most of the Mach abstractions are
used directly by lower layers of

00:19:28.760 --> 00:19:30.950
software than the application.

00:19:31.370 --> 00:19:34.490
So for the most part you should
be programming to Carbon,

00:19:34.540 --> 00:19:37.770
to Classic, to Cocoa,
and sticking at those layers,

00:19:37.820 --> 00:19:42.100
even BSD or Java, and using those.

00:19:43.090 --> 00:19:45.540
If you need to get a little
bit lower in the system,

00:19:45.540 --> 00:19:48.130
a little more detail and
a little more control,

00:19:48.250 --> 00:19:51.620
you're typically going to drop
one layer down from that and

00:19:51.630 --> 00:19:54.300
maybe you're going to access some
core foundation things directly,

00:19:54.300 --> 00:19:57.180
some bundle stuff,
or access some of the CF run

00:19:57.180 --> 00:19:58.970
loop stuff in the system.

00:19:59.000 --> 00:19:59.970
Right.

00:19:59.990 --> 00:20:03.120
But you're going to possibly
stop at the CF level as well,

00:20:03.210 --> 00:20:05.000
the core foundation level.

00:20:05.000 --> 00:20:08.000
Or you're going to use
I/O Kit to do things.

00:20:08.170 --> 00:20:12.000
Or you're going to use the
BSD file system extensions,

00:20:12.000 --> 00:20:15.000
or you're going to use the
BSD networking extensions.

00:20:15.000 --> 00:20:21.460
But typically you don't end up
having to program to Mach directly.

00:20:23.300 --> 00:20:24.300
Okay.

00:20:24.300 --> 00:20:27.160
If you do program the Mach directly,
one thing you've got to

00:20:27.160 --> 00:20:29.280
realize is it's not portable.

00:20:29.280 --> 00:20:31.880
If you drop,
if you have a Carbon application

00:20:31.910 --> 00:20:34.430
that tries to reach under
the covers and access Mach,

00:20:34.490 --> 00:20:37.320
that obviously,
that Carbon application is not

00:20:37.320 --> 00:20:39.300
going to go directly back to 9.

00:20:39.540 --> 00:20:43.770
There are tricks you can play with
Gestalts and trying to load extensions

00:20:43.850 --> 00:20:48.740
and load bundles to do some of that work,
and if you really need to, you can do it,

00:20:48.740 --> 00:20:51.380
but again,
it won't be portable and you've

00:20:51.380 --> 00:20:53.300
got to go out of your way.

00:20:53.730 --> 00:20:57.490
Some of these interfaces are
not final at the Mach level.

00:20:57.720 --> 00:21:01.800
As we build up the
Mac OS X environment with all the

00:21:01.810 --> 00:21:06.500
stacks coming up now to their,
pretty much their final form, right,

00:21:06.500 --> 00:21:10.000
we're taking a look at the
abstractions that Mach provides and

00:21:10.000 --> 00:21:14.620
we're trying to find more efficient
paths and better matches to the

00:21:14.620 --> 00:21:16.120
semantics of all those environments.

00:21:16.180 --> 00:21:20.000
So we're tweaking them
a bit as we go along.

00:21:20.030 --> 00:21:24.100
You're gonna see some of that work happen
between now and when the product's final.

00:21:24.260 --> 00:21:27.400
And so some of these interfaces
are gonna change on you.

00:21:27.500 --> 00:21:31.050
But again,
the majority of them are correct and,

00:21:31.050 --> 00:21:33.660
and final, or reasonably final.

00:21:33.810 --> 00:21:36.630
There aren't gonna be that many changes.

00:21:39.640 --> 00:21:41.590
So then why should I care about Mach?

00:21:41.600 --> 00:21:43.600
Right.

00:21:43.600 --> 00:21:47.600
You care about Mach because you need to
understand how your application works.

00:21:47.730 --> 00:21:49.540
You need to understand how
the frameworks are built.

00:21:49.600 --> 00:21:54.050
Um, mostly so that when you go to
debug your application and you,

00:21:54.050 --> 00:21:57.590
you see that all of your threads
are blocked in a certain location,

00:21:57.600 --> 00:21:59.600
oh, what does that mean?

00:21:59.600 --> 00:22:01.600
Why would that happen?

00:22:01.600 --> 00:22:04.020
And you need to understand
how your application and those

00:22:04.110 --> 00:22:05.600
frameworks might interact.

00:22:05.930 --> 00:22:10.320
And a lot of the things that you
will see end up being Mach things.

00:22:13.590 --> 00:22:15.940
So what are these wonderful
abstractions that lets us build

00:22:15.940 --> 00:22:18.620
all these different environments?

00:22:18.670 --> 00:22:23.500
Tasks and threads are, are fairly common,
fairly well understood abstractions.

00:22:23.610 --> 00:22:27.960
In Mach, a task owns all resources
for an application.

00:22:28.040 --> 00:22:30.500
So all resources are task-wide.

00:22:30.690 --> 00:22:34.500
Every thread inside a task,
then you have threads.

00:22:34.500 --> 00:22:37.340
Threads are the unit of execution,
the things that the

00:22:37.410 --> 00:22:39.220
operating system schedules.

00:22:40.100 --> 00:22:47.030
and virtual memory provides protection
for loads and stores to your application.

00:22:48.090 --> 00:22:50.080
Then once we build up all
of those environments,

00:22:50.140 --> 00:22:53.980
that gives you all the isolation
that Mac OS X is supposed to

00:22:53.980 --> 00:22:56.500
give you to a Carbon application,
let's say.

00:22:56.600 --> 00:22:59.500
You've now got a nice
isolated application.

00:22:59.500 --> 00:23:01.520
It's got its own private
virtual address space.

00:23:01.560 --> 00:23:04.400
It's got its own set of resources.

00:23:04.520 --> 00:23:07.860
They're protected into the task itself.

00:23:07.940 --> 00:23:11.610
And you've got another
Carbon application on the other side.

00:23:11.950 --> 00:23:14.400
Now, for the first time,
you've got to have formal ways

00:23:14.400 --> 00:23:16.040
of communicating between them.

00:23:16.110 --> 00:23:18.290
Right,
you used to be able to cheat and poke

00:23:18.420 --> 00:23:21.550
this location in memory and check
that when you're coming around your

00:23:21.550 --> 00:23:25.290
next loop in the Carbon application
if you need two to communicate.

00:23:25.300 --> 00:23:27.790
Right, but now they're isolated.

00:23:27.790 --> 00:23:31.000
So you need some formal way
for them to communicate.

00:23:31.080 --> 00:23:35.350
And so there's a formal task-to-task
communication mechanism in Mach.

00:23:36.220 --> 00:23:41.240
Okay, so a Mach task, as I said before,
owns all resources.

00:23:41.310 --> 00:23:43.410
It sets up an environment
for threads to run.

00:23:43.410 --> 00:23:48.060
All your threads have equal access
to all of the task resources.

00:23:48.200 --> 00:23:52.880
There are other resources available,
so virtual memory and a port namespace,

00:23:52.880 --> 00:23:56.700
and we'll get into what the port
namespace is in a little bit.

00:23:56.700 --> 00:23:59.190
Virtual memory,
I think most of you understand.

00:23:59.340 --> 00:24:02.420
It's a protected address
space for each application,

00:24:02.420 --> 00:24:03.200
each task.

00:24:03.200 --> 00:24:06.200
But there are other resources
associated with a task.

00:24:06.200 --> 00:24:10.190
We won't get into them too much,
but there's task-wide exception handlers,

00:24:10.300 --> 00:24:14.200
and a bootstrap server
reference for a task.

00:24:14.200 --> 00:24:18.180
That's basically how a task
understands what kind of task it is.

00:24:18.300 --> 00:24:22.860
When Mach gets a task created,
all Mach tasks kind of look alike.

00:24:23.180 --> 00:24:27.650
So how do you distinguish
a Java task from a,

00:24:28.060 --> 00:24:28.880
A Carbon task.

00:24:29.100 --> 00:24:31.730
Well, a lot of that happens
through the bootstrap server.

00:24:32.010 --> 00:24:34.690
The task,
very first thing it does when it executes

00:24:34.740 --> 00:24:38.340
is go converse with its bootstrap
server and that gives it some of its

00:24:38.670 --> 00:24:40.960
original primordial references to things.

00:24:41.500 --> 00:24:47.000
And then it bootstraps itself up from
that and all of a sudden becomes one

00:24:47.000 --> 00:24:47.000
of the environments or the other.

00:24:48.680 --> 00:24:51.590
So when you look in Mac OS X,
you're gonna have your application,

00:24:51.600 --> 00:24:53.600
maybe it's a Carbon application.

00:24:53.830 --> 00:24:57.590
Well each Carbon application
is actually a BSD application.

00:24:57.600 --> 00:24:59.600
It's a BSD process.

00:24:59.800 --> 00:25:03.540
And a BSD process has two basic
sets of resources with it.

00:25:03.990 --> 00:25:07.100
The Mach task part and,
and file descriptors.

00:25:07.100 --> 00:25:12.600
There's other BSD resources,
shared memory ID, um, space and the like,

00:25:12.700 --> 00:25:18.100
but most of the things in BSD processes
are file descriptors or tasks.

00:25:19.260 --> 00:25:21.640
You end up with that environment.

00:25:21.710 --> 00:25:25.700
But inside a Mach task you have multiple
threads executing in a single task,

00:25:25.800 --> 00:25:29.880
sharing a virtual memory
space and a port name space.

00:25:30.750 --> 00:25:31.700
The thread.

00:25:31.700 --> 00:25:33.980
The thread's the unit
of execution in Mach.

00:25:34.190 --> 00:25:36.250
They're preemptively
scheduled against each other.

00:25:36.330 --> 00:25:40.490
This is how Mac OS X gives
you preemptive scheduling.

00:25:40.580 --> 00:25:44.400
Mach does all of the scheduling
work for those threads.

00:25:44.520 --> 00:25:47.800
Carbon and Classic don't have
to do their own scheduling work.

00:25:47.890 --> 00:25:50.540
Again, they have equal access
to the system resources.

00:25:50.590 --> 00:25:52.600
An important thing to note,
at the Mach level,

00:25:52.610 --> 00:25:59.050
a thread is nothing more than a register
state and some scheduling attributes.

00:25:59.830 --> 00:26:04.460
There's no such thing as a stack to a,
to a thread at the Mach level.

00:26:04.460 --> 00:26:06.200
We don't care whether
there's a stack there or not.

00:26:06.200 --> 00:26:08.380
You give us a register
state to start the thing,

00:26:08.520 --> 00:26:11.900
we start it running,
we'll preemptively schedule it,

00:26:11.950 --> 00:26:15.690
take it off the processor,
restart it at that state.

00:26:15.710 --> 00:26:18.620
Something else is responsible
for doing those other layers.

00:26:18.620 --> 00:26:19.840
Right.

00:26:19.950 --> 00:26:24.590
So this is what a,
a thread ends up looking like.

00:26:24.830 --> 00:26:27.500
Each application in Mach is
going to have threads,

00:26:27.510 --> 00:26:28.940
multiple threads.

00:26:29.090 --> 00:26:35.460
Each in Mac OS X, each of those threads
actually is a POSIX thread.

00:26:35.610 --> 00:26:38.930
And the POSIX thread is the part
that's responsible and does the work

00:26:39.040 --> 00:26:43.410
to allocate the stacks and set up
things that you would expect from

00:26:43.410 --> 00:26:46.330
a higher level concept of a thread.

00:26:47.230 --> 00:26:50.500
And even inside of that,
in a Carbon application when you

00:26:50.500 --> 00:26:53.820
have preemptively scheduled threads,
or sorry,

00:26:53.820 --> 00:26:59.220
cooperatively scheduled threads in Mach,
in Carbon, those are Pthreads

00:26:59.220 --> 00:27:02.780
which are Mach threads,
and Carbon does some work to make

00:27:02.780 --> 00:27:08.920
sure that Mach schedules them in
a way that they look like they're

00:27:08.920 --> 00:27:08.920
cooperative rather than preemptive.

00:27:09.440 --> 00:27:11.850
One of the things you also
have to be careful when you're

00:27:12.030 --> 00:27:14.840
developing your applications,
you may create a simple

00:27:14.950 --> 00:27:18.480
Carbon application today,
single threaded Carbon application,

00:27:18.480 --> 00:27:20.750
and you go and you look in the
debugger and lo and behold there

00:27:20.750 --> 00:27:22.400
are two or three threads in there.

00:27:22.400 --> 00:27:24.330
Where'd those other threads come from?

00:27:24.390 --> 00:27:27.360
Well they're actually
created by the frameworks.

00:27:27.980 --> 00:27:31.300
The frameworks sometimes have
to create threads to bridge the

00:27:31.450 --> 00:27:36.660
gap between the semantics of the
services below them and what the

00:27:36.670 --> 00:27:38.400
Carbon application may expect up above.

00:27:39.470 --> 00:27:44.590
So you're going to end up with some
threads that you're not aware of,

00:27:44.780 --> 00:27:47.390
and you're going to have to worry about
those when you're doing your debugging,

00:27:47.500 --> 00:27:50.150
so be aware they come.

00:27:50.250 --> 00:27:53.250
A lot of the work we're doing for
semantic matching is trying to

00:27:53.330 --> 00:27:56.400
eliminate some of those worker threads.

00:27:57.140 --> 00:28:00.150
And all of our tools are thread aware.

00:28:00.150 --> 00:28:04.290
So you're going to see that our
debuggers will show you dumps and

00:28:04.290 --> 00:28:06.100
tracebacks of all the threads.

00:28:06.100 --> 00:28:10.100
Our sampler tool will show
you what your thread is doing,

00:28:10.100 --> 00:28:17.700
but it'll also at the same time show you
what the worker threads that are provided

00:28:17.700 --> 00:28:17.700
by some of the frameworks are doing.

00:28:19.120 --> 00:28:22.000
And so you end up with
a picture like this,

00:28:22.040 --> 00:28:23.170
that you have Mach threads.

00:28:23.240 --> 00:28:28.780
Mach threads are wrapped at user level by
P threads to provide stacks and the like.

00:28:29.380 --> 00:28:31.900
Inside of a Carbon application
you may have those thread manager

00:28:31.900 --> 00:28:36.150
threads like I talked about that are
cooperatively scheduled against each

00:28:36.150 --> 00:28:38.440
other through the assistance of Carbon.

00:28:38.500 --> 00:28:43.010
But you then have MP threads
which are free to run and execute,

00:28:43.010 --> 00:28:46.300
and Mach is the only
one who schedules those.

00:28:46.300 --> 00:28:50.860
So obviously if you're worried
about getting true MP performance

00:28:50.860 --> 00:28:55.220
and true parallelism,
the Carbon guys are trying to push people

00:28:55.220 --> 00:28:56.970
a little bit towards the MP threads.

00:28:57.000 --> 00:29:00.130
If you're doing a Cocoa application,
all of the Cocoa threads

00:29:00.130 --> 00:29:01.170
are POSIX threads.

00:29:01.560 --> 00:29:04.120
There's no cooperatively
scheduled notion in those,

00:29:04.120 --> 00:29:07.990
so you don't have to worry about
the cooperatively scheduled part.

00:29:09.940 --> 00:29:14.720
What's new for threads in Mach,
in Mac OS X versus server and

00:29:15.000 --> 00:29:17.420
Darwin 1.0 versus previous Darwin's?

00:29:17.520 --> 00:29:20.660
Well, Pthreads replaces Cthreads.

00:29:20.660 --> 00:29:24.930
Cthreads was something that was
explicitly for Mach from way back when.

00:29:24.930 --> 00:29:29.260
Pthreads are a more standard version
of a lot of the same services,

00:29:29.260 --> 00:29:31.600
so we've switched to Pthreads.

00:29:31.600 --> 00:29:34.930
We also have scheduling
frameworks in the Mach 3.0,

00:29:34.940 --> 00:29:39.260
or in the Darwin 1.0 and
Mach 3.0 code that we've got.

00:29:39.260 --> 00:29:42.770
Scheduling frameworks allow for different
scheduling policies for threads,

00:29:43.020 --> 00:29:46.860
rather than just the standard timeshare
scheduling policy that's trying

00:29:47.150 --> 00:29:49.400
to gain fair access to everything.

00:29:49.440 --> 00:29:52.740
There's also some fixed priority
real-time scheduling policies in there,

00:29:52.890 --> 00:29:55.850
and you can select those from user state.

00:29:56.490 --> 00:30:00.580
And one of the big things,
obviously on the PowerPC processor,

00:30:00.580 --> 00:30:04.200
is G4 support for
Velocity Engine is now in.

00:30:06.130 --> 00:30:08.590
What's coming soon for threads?

00:30:08.590 --> 00:30:12.620
Additional real-time work,
additional policies,

00:30:12.680 --> 00:30:16.760
isochronous policies that some people
are looking for are being investigated,

00:30:16.760 --> 00:30:19.330
no promises,
but we're looking into those.

00:30:19.430 --> 00:30:25.130
There's been a lot of research in Mach,
again, with being able to leverage work

00:30:25.130 --> 00:30:25.130
that other people have done.

00:30:25.330 --> 00:30:28.360
Real-time priority inversion avoidance.

00:30:28.360 --> 00:30:32.040
A lot of the work that came from
the University of Utah was about

00:30:32.110 --> 00:30:35.410
trying to avoid those situations
for real-time applications where

00:30:35.420 --> 00:30:38.900
you're dependent upon a resource and
that resource is currently consumed

00:30:38.900 --> 00:30:43.000
by some other thread in the system,
one that you don't really care about,

00:30:43.130 --> 00:30:44.070
but you've got to wait for it.

00:30:44.200 --> 00:30:47.610
And that thread may be so low a
priority that it's not actually

00:30:47.610 --> 00:30:51.130
making any progress to get rid
of its hold on that resource.

00:30:51.130 --> 00:30:57.440
And so the system-wide approach of
promoting those threads in order,

00:30:57.440 --> 00:31:00.690
so that they could let go of
their resources and then let the

00:31:00.930 --> 00:31:05.710
high priority thread continue
is something that's being,

00:31:06.050 --> 00:31:10.700
extended--it's already in the code base
that you're looking at now in Darwin 1.0,

00:31:10.700 --> 00:31:14.790
but it's being extended
and deployed system-wide.

00:31:14.920 --> 00:31:18.230
In kernel preemption,
it's something that was built in to

00:31:18.250 --> 00:31:21.560
the Mach 3.0 code that we've got.

00:31:21.560 --> 00:31:25.100
It's currently disabled,
but it's there and

00:31:25.100 --> 00:31:30.730
enabled and it will be,
or, enableable, and it will be turned

00:31:30.730 --> 00:31:30.730
on in the near future.

00:31:32.220 --> 00:31:36.100
Another service in
Mach is virtual memory.

00:31:36.340 --> 00:31:39.100
Again, it provides a protected address
space for each application.

00:31:39.100 --> 00:31:44.100
It provides a flexible way to
construct those address spaces.

00:31:44.270 --> 00:31:47.100
And it allows for controlled sharing.

00:31:47.100 --> 00:31:50.040
Don't go hog wild,
because Mach lets you do sharing,

00:31:50.460 --> 00:31:52.100
jumping down there and
doing wild sharing.

00:31:52.100 --> 00:31:57.100
We do sharing in a
controlled way in Mac OS X.

00:31:57.100 --> 00:32:03.090
One of the key features of virtual
memory in Mach is copy on write behavior.

00:32:03.090 --> 00:32:06.690
If you look at each Carbon application,
you can almost consider a

00:32:06.690 --> 00:32:12.100
Carbon application as a unique
instance of the Mac OS X environment.

00:32:12.100 --> 00:32:17.020
A lot of the frameworks that used
to get loaded once in Mac OS X,

00:32:17.020 --> 00:32:20.620
or sorry, in Mac OS 9,
get loaded into each

00:32:20.620 --> 00:32:23.070
application as it starts.

00:32:23.100 --> 00:32:26.100
If each application had to have a
unique copy of those frameworks,

00:32:26.100 --> 00:32:26.100
it would have to be loaded
into the Mac OS X environment.

00:32:27.100 --> 00:32:28.100
It would take forever to load.

00:32:28.120 --> 00:32:33.020
It would be huge amounts of
memory that would be required.

00:32:33.100 --> 00:32:37.940
So Mach provides a way to flexibly
share those spaces and to flexibly

00:32:38.070 --> 00:32:41.100
provide copy on write semantics to those.

00:32:41.160 --> 00:32:46.060
So that unless you modify a page,
you get to share a common page.

00:32:46.210 --> 00:32:48.420
But as soon as you modify it,
only that one page gets to

00:32:48.510 --> 00:32:50.020
be a unique copy for you.

00:32:50.100 --> 00:32:54.460
And that's done lazily, as you touch it,
rather than up front.

00:32:56.490 --> 00:32:59.070
So when you look at the
virtual memory system,

00:32:59.070 --> 00:33:02.160
each task ends up having its
own virtual memory space.

00:33:02.260 --> 00:33:08.380
And inside that virtual memory space is
little regions of mapped memory objects.

00:33:08.490 --> 00:33:10.400
Well what do you map as a memory object?

00:33:10.400 --> 00:33:15.140
Well for most of you,
you make calls to frameworks and

00:33:15.140 --> 00:33:18.520
they do this magically for you,
but let's take an example where you map

00:33:18.700 --> 00:33:22.570
a file descriptor under a BSDM map call.

00:33:22.830 --> 00:33:25.390
That file gets converted
to a memory object,

00:33:25.390 --> 00:33:28.460
an abstract memory object,
inside the kernel.

00:33:28.610 --> 00:33:31.380
Won't go too much into that,
but there's a general concept

00:33:31.560 --> 00:33:32.700
called an abstract memory object.

00:33:32.700 --> 00:33:37.930
When you map that into an address space,
the kernel creates an object

00:33:38.030 --> 00:33:40.700
called a virtual memory object.

00:33:40.700 --> 00:33:44.700
It's the manager of the cache of
that data associated with that file.

00:33:44.700 --> 00:33:48.700
So we don't bring the whole file in,
we don't even know what the file is,

00:33:48.700 --> 00:33:52.700
but we know that there's some object
that we have to cache data for.

00:33:52.700 --> 00:33:55.680
And so we create a virtual
memory object for it.

00:33:55.680 --> 00:34:00.700
And as you touch pages or access
locations in your address space,

00:34:00.700 --> 00:34:03.820
we bring in some of those
pages and cache them,

00:34:03.860 --> 00:34:06.660
and then make them available
to your application.

00:34:06.870 --> 00:34:07.800
So here's an example of that.

00:34:07.800 --> 00:34:10.610
Now I've come along and touched,
in that second page,

00:34:10.680 --> 00:34:12.630
I've touched a location.

00:34:12.710 --> 00:34:16.560
And when I do it, that causes a fault in
the operating system,

00:34:16.650 --> 00:34:17.680
right, at the lowest level.

00:34:18.290 --> 00:34:21.800
That gets translated into,
we look up the address space,

00:34:21.800 --> 00:34:25.660
we look up the mapping, the region,
and describe,

00:34:25.660 --> 00:34:30.230
figure out which object and which
range of that object and with

00:34:30.670 --> 00:34:33.870
which permissions you have access,
and we go and check the

00:34:33.870 --> 00:34:33.870
virtual memory object.

00:34:37.240 --> 00:34:43.880
In that page we just map it into your
address space and everything's fine.

00:34:43.880 --> 00:34:48.500
There's only one version
of that data in the cache.

00:34:48.540 --> 00:34:52.680
If you were in the file
system session yesterday,

00:34:52.680 --> 00:34:52.680
you heard some of the ways that
we make sure that not only are we

00:34:52.680 --> 00:34:52.680
maintaining it at the VM level,
but we also maintain

00:34:52.680 --> 00:34:52.680
consistency at the file level.

00:34:53.270 --> 00:34:56.180
But sharing isn't the only thing we do.

00:34:56.180 --> 00:34:59.790
As I said before,
you've got a situation where

00:35:00.330 --> 00:35:03.090
You don't want to have to bring
in whole copies of things that

00:35:03.100 --> 00:35:05.190
you want unique copies of.

00:35:05.330 --> 00:35:08.410
So the data section for each file
or framework that you have loaded.

00:35:08.960 --> 00:35:12.980
We don't want to bring that all
in at process initialization

00:35:12.980 --> 00:35:15.100
or at task initialization time.

00:35:15.200 --> 00:35:18.200
So we want to do copy on write.

00:35:18.200 --> 00:35:23.080
We want to access the original object
as much as possible and only copy,

00:35:23.080 --> 00:35:27.150
bring in unique copies of
pages for those that we modify.

00:35:27.200 --> 00:35:30.190
So here's the situation
of how that works.

00:35:30.190 --> 00:35:32.840
When you map something copy on write,
rather than having a direct

00:35:32.840 --> 00:35:35.680
reference to the object,
there's a new object that gets

00:35:35.720 --> 00:35:37.160
created and stuck in the middle.

00:35:37.200 --> 00:35:39.200
Alright.

00:35:39.200 --> 00:35:42.690
And when you take a write
fault on one of the pages,

00:35:43.120 --> 00:35:46.240
All right,
we go to that virtual copy object.

00:35:46.380 --> 00:35:49.270
It, instead of going directly to its, its

00:35:49.660 --> 00:35:52.400
abstract memory manager at
first checks the thing that

00:35:52.400 --> 00:35:54.620
it's a virtual copy of and says,
"Do you have that

00:35:54.620 --> 00:35:58.010
page?" And in this case,
it's really that second page

00:35:58.020 --> 00:36:00.600
that we just talked about,
and of course he does.

00:36:00.970 --> 00:36:05.810
So he sends us a copy of that page back,
and we cache only that one copy page,

00:36:05.810 --> 00:36:07.600
and we make that available.

00:36:07.600 --> 00:36:11.600
So as you run a bunch of
the tools in the system,

00:36:11.650 --> 00:36:13.600
you're going to see
things like private pages,

00:36:13.600 --> 00:36:18.160
alias pages, virtual pages, right?

00:36:18.350 --> 00:36:23.710
The private pages are those things which
we have pulled our unique copies of.

00:36:25.110 --> 00:36:27.930
At the lower level below
that abstract memory manager,

00:36:27.930 --> 00:36:29.700
what happens there?

00:36:29.750 --> 00:36:32.700
Well, as I said before,
typically each one of those

00:36:32.720 --> 00:36:37.720
things is a file that got mapped,
and so those go through the VNode

00:36:37.730 --> 00:36:44.740
pager and they access the BSD file
system directly for each file type.

00:36:45.660 --> 00:36:49.500
But there's also those other kinds
of objects which aren't files.

00:36:49.670 --> 00:36:52.080
Those things,
when you allocate memory or you just

00:36:52.080 --> 00:36:55.300
did one of those copy operations,
we end up creating some

00:36:55.300 --> 00:36:56.490
magical data for you.

00:36:56.580 --> 00:37:01.500
A new object that you didn't know about,
nobody really has an explicit handle to.

00:37:01.500 --> 00:37:04.400
All of those objects are actually
managed by a pager in the

00:37:04.510 --> 00:37:06.500
system called the default pager.

00:37:06.500 --> 00:37:09.480
And what he does is takes
all of those objects and the,

00:37:09.480 --> 00:37:13.710
since they are very sparse objects,
they have a one page touch,

00:37:13.710 --> 00:37:16.710
maybe at the beginning of the object,
and another page touch way

00:37:16.770 --> 00:37:21.490
down inside the object,
you know, at offset ten thousand.

00:37:21.610 --> 00:37:25.440
We don't want to create unique files for
each one of those objects you've created.

00:37:25.760 --> 00:37:28.660
There are thousands of
these in a running system.

00:37:28.820 --> 00:37:33.350
So he creates the default pager,
creates a set of swap files, right,

00:37:33.540 --> 00:37:37.140
and maps those data,
that data from those sparse objects,

00:37:37.620 --> 00:37:42.390
down into a swap file and writes
that through the file system to disk

00:37:42.390 --> 00:37:45.690
or across the network or wherever
your file systems happen to be.

00:37:45.700 --> 00:37:50.660
And there's a daemon in the
system that gets queries from,

00:37:50.700 --> 00:37:52.620
you know,
notifications from the default pager.

00:37:52.720 --> 00:37:57.040
If one swap file is filling up,
we send a notification up to

00:37:57.090 --> 00:38:01.920
that daemon and he allocates
another swap file and creates one

00:38:01.920 --> 00:38:04.700
and we start swapping into that.

00:38:04.980 --> 00:38:08.390
One really neat feature
that's new to Mac OS X,

00:38:08.390 --> 00:38:11.500
for those who are used
to Mac OS X Server,

00:38:11.500 --> 00:38:14.700
is now swap files can go away.

00:38:14.700 --> 00:38:15.650
And they do automatically.

00:38:15.700 --> 00:38:22.840
So if you burst up in your system and
access huge amounts of written data,

00:38:23.030 --> 00:38:26.580
anonymous data, and then all of a sudden
deallocate it all,

00:38:26.580 --> 00:38:31.670
the, as the data gets freed,
space gets freed up in the swap files,

00:38:31.670 --> 00:38:34.700
and then the swap files
are free to coalesce.

00:38:34.700 --> 00:38:36.630
And you can actually
take a swap file offline.

00:38:36.740 --> 00:38:41.010
So if you want to put a
swap file on one volume,

00:38:41.220 --> 00:38:43.500
You could even put it on removable media.

00:38:43.650 --> 00:38:48.200
Start swapping to it,
then when you want to unmount that media,

00:38:48.200 --> 00:38:51.200
you can say, okay,
unmount that swap file,

00:38:51.380 --> 00:38:54.280
and the default pager moves
all the data from that swap

00:38:54.280 --> 00:38:58.060
file into the other swap files,
maybe making space available

00:38:58.060 --> 00:39:02.540
somewhere else for that data to move,
and then frees up that volume.

00:39:02.820 --> 00:39:07.430
So that's a neat,
unique feature that we've

00:39:07.430 --> 00:39:07.430
got in the current kernel.

00:39:08.140 --> 00:39:11.100
Okay, how does it show all
this funny stuff to you?

00:39:11.320 --> 00:39:14.660
Well, what you're going to see when you
look at your applications is this

00:39:14.660 --> 00:39:19.100
long range of memory regions in each
virtual memory space of an application.

00:39:19.100 --> 00:39:22.090
You're going to see a little bit
that got created here for mapping

00:39:22.280 --> 00:39:25.050
this framework and a little bit
that was here for this framework.

00:39:25.100 --> 00:39:28.100
All right, they're going to be sparse.

00:39:28.100 --> 00:39:32.100
They're typically going to be copy
on write for things like frameworks.

00:39:32.160 --> 00:39:34.490
Most of them are not,
you never touch them,

00:39:34.500 --> 00:39:38.480
like all your text is
mapped copy on write.

00:39:38.480 --> 00:39:38.490
Well,

00:39:38.850 --> 00:39:39.770
I don't write text.

00:39:39.870 --> 00:39:42.730
Why should I map text copy on write?

00:39:42.830 --> 00:39:44.760
Well, debuggers do.

00:39:44.780 --> 00:39:46.920
When you run a debugger
on your application,

00:39:47.000 --> 00:39:51.050
you would hate to sticking a
breakpoint in one application at a

00:39:51.050 --> 00:39:52.780
particular location in a framework.

00:39:52.780 --> 00:39:56.520
It would cause every application
to take that breakpoint.

00:39:56.680 --> 00:39:59.480
Alright,
so by doing everything copy on write,

00:39:59.500 --> 00:40:03.570
you have the ability to come along
and modify just one application.

00:40:04.940 --> 00:40:07.200
You're going to see lots of tools.

00:40:07.500 --> 00:40:09.890
Hopefully some of you will be able
to go to the tools session later

00:40:09.980 --> 00:40:12.790
today or the debugging session
first thing tomorrow morning.

00:40:12.800 --> 00:40:16.300
You're going to see a lot of
tools around managing your virtual

00:40:16.300 --> 00:40:18.800
memory space of your application.

00:40:18.800 --> 00:40:22.800
malloc-debug is probably going to be the
one that you're going to go to first.

00:40:22.800 --> 00:40:23.790
Well, maybe second.

00:40:23.830 --> 00:40:25.800
You're probably going to go to top first.

00:40:25.800 --> 00:40:28.790
Top is going to tell you
how much memory you've got,

00:40:28.790 --> 00:40:31.800
how many regions you've
got in your application.

00:40:31.800 --> 00:40:34.650
And if you see that starting to leak,
you're going to turn around

00:40:34.650 --> 00:40:35.800
and go to malloc-debug.

00:40:35.800 --> 00:40:39.390
And malloc-debug is going to
help you walk through each of

00:40:39.490 --> 00:40:41.910
your applications in these areas.

00:40:42.480 --> 00:40:47.890
There's another neat program
that's not--it's a demo program,

00:40:47.890 --> 00:40:51.400
a helper program right now,
it's not finalized.

00:40:51.490 --> 00:40:55.300
But I really like it,
not necessarily as a debugging tool,

00:40:55.410 --> 00:40:57.940
but as a tool to understand
how an address space or an

00:40:57.940 --> 00:41:02.490
application is put together,
and that's the pagewatch.app.

00:41:02.680 --> 00:41:08.180
PageWatch is in debug developer tools,
I think, or debug developer applications.

00:41:08.200 --> 00:41:11.520
Sorry,
local developer applications on your CD.

00:41:11.520 --> 00:41:15.370
And when you bring it up,
it gives you a visual image of

00:41:15.410 --> 00:41:20.220
what your address space looks like,
a little square for each page in

00:41:20.520 --> 00:41:22.180
the system in your application.

00:41:22.180 --> 00:41:24.860
And it tells you whether
that page is present or not.

00:41:24.900 --> 00:41:27.310
And you can set it to
scan at certain intervals,

00:41:27.320 --> 00:41:27.880
right?

00:41:27.880 --> 00:41:29.780
And you can see pages
faulting in and out.

00:41:29.830 --> 00:41:32.080
You can also click on another view.

00:41:32.550 --> 00:41:33.680
Now, that's the VM summary view.

00:41:33.680 --> 00:41:39.170
There's another view that lets you
see each of the individual things

00:41:39.180 --> 00:41:43.240
that got mapped into your application,
each library,

00:41:43.240 --> 00:41:46.490
and which pages are being used
and how many pages are being

00:41:46.490 --> 00:41:47.610
used out of each one of those.

00:41:47.680 --> 00:41:52.330
It's really neat just to get a sense
of how an application's put together.

00:41:56.720 --> 00:42:01.600
Okay, what's new in Darwin 1.0?

00:42:01.600 --> 00:42:03.940
We've got the external
memory manager interface.

00:42:04.030 --> 00:42:06.540
That was something that
wasn't in Mac OS X Server.

00:42:07.110 --> 00:42:11.570
Now we don't currently have
any need for user level pagers.

00:42:11.600 --> 00:42:15.620
This is actually an exportable
interface between the kernels so we

00:42:15.740 --> 00:42:17.540
can call out to a pager at user space.

00:42:17.590 --> 00:42:20.450
And a lot of people will go, oh,
really neat.

00:42:20.540 --> 00:42:23.780
I can go ahead and build
myself my own private pager.

00:42:23.780 --> 00:42:26.100
And I can do really
neat things with that.

00:42:26.400 --> 00:42:28.300
Well,
in most cases you don't want to do that.

00:42:28.300 --> 00:42:34.300
In most cases what you would rather
do is build a file system layer.

00:42:34.410 --> 00:42:34.590
Right?

00:42:34.730 --> 00:42:37.680
Because you don't want something
that just behaves that way.

00:42:37.700 --> 00:42:39.300
Let's say you wanted to
do an encryption pager.

00:42:39.300 --> 00:42:42.170
Oh, I could do encryption on my data.

00:42:42.300 --> 00:42:47.300
Well, but you want reads and writes
to see that data encrypted or

00:42:47.300 --> 00:42:50.300
decrypted appropriately as well.

00:42:50.300 --> 00:42:50.890
Right?

00:42:50.890 --> 00:42:54.870
If you do it as a file system extension,
the VNode pager I showed you

00:42:54.870 --> 00:42:58.300
earlier allows you to go ahead
and access those things for free.

00:42:58.300 --> 00:43:00.260
It becomes a pager for free.

00:43:00.300 --> 00:43:00.920
Right?

00:43:00.920 --> 00:43:04.460
If you do it just as a pager, well,
you've got no way to

00:43:04.460 --> 00:43:06.220
access it the other way.

00:43:06.350 --> 00:43:10.160
So there's very limited use for
pagers through that formal interface.

00:43:10.300 --> 00:43:12.300
But it gives a nice
separation between the two.

00:43:12.300 --> 00:43:14.270
And you can access those
things even inside the kernel.

00:43:14.300 --> 00:43:16.300
Right?

00:43:16.300 --> 00:43:19.420
Another thing that's in
Darwin 1.0 is the ability,

00:43:19.420 --> 00:43:24.260
rather than just having an address space,
be a linear list of memory regions.

00:43:24.810 --> 00:43:26.840
You may have...

00:43:26.900 --> 00:43:30.540
A bunch of things in common
between a bunch of applications.

00:43:30.680 --> 00:43:34.540
And so rather than mapping
each one into each application,

00:43:34.540 --> 00:43:39.890
you may want to just create one
memory address space that has all

00:43:40.000 --> 00:43:41.890
of those files mapped into it.

00:43:41.900 --> 00:43:45.210
And then rather than mapping, again,
each individual file

00:43:45.210 --> 00:43:48.190
into each address space,
you can take that one address

00:43:48.190 --> 00:43:51.900
space and recursively map it into
each of the other address spaces.

00:43:51.900 --> 00:43:54.860
So as data appears in
that single address space,

00:43:54.860 --> 00:43:58.770
as things get mapped in and out,
they magically appear in the

00:43:58.770 --> 00:44:00.940
other address spaces as well.

00:44:01.320 --> 00:44:02.930
It's a really neat feature.

00:44:02.970 --> 00:44:09.150
Most users won't have direct need for it,
but coming soon we'll actually,

00:44:09.210 --> 00:44:14.300
if you look at the bottom one,
where the shared memory part,

00:44:14.340 --> 00:44:21.260
shared region part,
we're going to use that to

00:44:21.260 --> 00:44:21.260
employ the system frameworks.

00:44:21.510 --> 00:44:22.400
throughout the system.

00:44:22.400 --> 00:44:23.950
They're all going to be
mapped into this common thing,

00:44:23.950 --> 00:44:26.760
and then that common thing is
mapped into each address space.

00:44:26.760 --> 00:44:31.380
It provides a level of efficiency
that we don't have today.

00:44:31.590 --> 00:44:34.280
Other things coming in virtual memory,
if you were in the file

00:44:34.280 --> 00:44:37.740
system session yesterday,
they talked about how the file

00:44:37.740 --> 00:44:42.690
system part of the system is
already enabled for 64-bit files,

00:44:42.690 --> 00:44:42.690
but

00:44:43.700 --> 00:44:47.460
So, the VM subsystem keeps them
from being able to be mapped,

00:44:47.610 --> 00:44:50.240
and one of the things,
the first things we're doing is

00:44:50.250 --> 00:44:52.700
adding the 64-bit object size support.

00:44:53.270 --> 00:44:56.700
And if people are familiar
with the PowerPC roadmap,

00:44:56.900 --> 00:45:00.700
there's 64-bit PowerPC processes
coming right down the pike,

00:45:00.700 --> 00:45:05.480
and we're looking at ways to
add 64-bit address support.

00:45:05.700 --> 00:45:09.680
Now this is a little bit different
than traditional 64-bit systems,

00:45:09.680 --> 00:45:14.160
because in the PowerPC roadmap you
can mix 64-bit applications and 32-bit

00:45:14.160 --> 00:45:16.600
applications on a single running system.

00:45:16.620 --> 00:45:20.280
So we need to be able to
flexibly support both,

00:45:20.450 --> 00:45:23.080
and that kind of work is ongoing.

00:45:24.920 --> 00:45:28.800
And there's also some changes
in that EMMI layer to add

00:45:28.800 --> 00:45:31.000
some efficiencies there.

00:45:31.160 --> 00:45:34.800
Okay, so we now have a task,
and it's isolated and it has

00:45:34.870 --> 00:45:38.090
one or more threads in it,
and it has its virtual space,

00:45:38.120 --> 00:45:40.100
and we may have two of those tasks.

00:45:40.210 --> 00:45:43.100
Alright,
but how do they talk to each other?

00:45:43.100 --> 00:45:45.090
Now that they're isolated,
we've got to let them talk.

00:45:45.090 --> 00:45:49.080
And the way they talk is through IPC.

00:45:49.280 --> 00:45:52.310
IPC in Mach has three basic abstractions.

00:45:52.440 --> 00:45:57.800
It has ports, which are the endpoints of
communication between tasks.

00:45:57.890 --> 00:45:59.340
They're highly restricted.

00:45:59.400 --> 00:46:04.440
Each, you cannot send a message to a port
unless somebody hands you a write

00:46:04.440 --> 00:46:06.860
to send a message to that port.

00:46:08.110 --> 00:46:12.600
And through that restriction we
actually get the basics of how the

00:46:12.600 --> 00:46:15.100
security model in the system works.

00:46:15.100 --> 00:46:15.790
Right?

00:46:15.810 --> 00:46:21.540
But you're only granted access to those
things which the policy makers decide

00:46:21.540 --> 00:46:23.100
that you're allowed to have access to.

00:46:23.220 --> 00:46:27.160
And by not having access to the
task port for some other task,

00:46:27.260 --> 00:46:33.370
some other process like a system process,
you can't do things to that process.

00:46:33.820 --> 00:46:37.610
A port set is a collection of ports.

00:46:37.820 --> 00:46:40.800
So you can have both sends
and receive rights to ports.

00:46:40.800 --> 00:46:43.790
You can implement something so that
someone can send you a message.

00:46:43.790 --> 00:46:47.600
And a port set allows you to collect
those into a single spot so you

00:46:47.630 --> 00:46:51.780
can have a single thread wait and
receive on any one of those ports.

00:46:51.870 --> 00:46:56.140
It's kind of like select sets
or FD sets for file descriptors,

00:46:56.240 --> 00:46:58.800
except that they exist forever.

00:46:58.800 --> 00:47:01.850
The kernel maintains them and you
can add things to them so you don't

00:47:01.980 --> 00:47:03.750
have to construct them on each call.

00:47:05.060 --> 00:47:06.660
And where are all these ports maintained?

00:47:06.660 --> 00:47:11.310
There's a namespace for each task that,
that maintains the task, the port space.

00:47:11.320 --> 00:47:14.700
So here at the bottom
you have this port space,

00:47:14.700 --> 00:47:18.220
right, and you may have a port which
gives you the permission for one

00:47:18.270 --> 00:47:20.860
task to send a message to another,
right.

00:47:20.860 --> 00:47:23.680
And that task may own a port of its own,
right,

00:47:23.680 --> 00:47:26.040
that it owns the receive right for.

00:47:26.040 --> 00:47:30.590
And so it can construct a message,
not only that sends data,

00:47:30.700 --> 00:47:35.240
but it can also send writes
to ports to that other task.

00:47:35.240 --> 00:47:40.230
And it can also send memory,
copy on write memory to that other task.

00:47:40.310 --> 00:47:45.680
So all of these systems inside of
Mach are kind of recursively defined.

00:47:45.680 --> 00:47:47.880
They each depend upon each other
and they each take advantage

00:47:47.880 --> 00:47:49.020
of each other's services.

00:47:49.020 --> 00:47:49.980
So.

00:47:50.560 --> 00:47:55.100
VM uses IPC to implement
itself in certain areas,

00:47:55.100 --> 00:48:00.490
and IPC uses VM to send
data to other tasks.

00:48:00.580 --> 00:48:03.160
So when you send that message
over to the other side,

00:48:03.440 --> 00:48:06.490
and the other guy receives it, virtual,
new virtual memory appears

00:48:06.490 --> 00:48:13.960
in that other task,
and now he sees a virtual copy of

00:48:13.960 --> 00:48:14.490
what was sent by the other process.

00:48:15.300 --> 00:48:18.880
And you also received that port,
so you can now send a

00:48:18.880 --> 00:48:21.270
message back the other way.

00:48:22.320 --> 00:48:27.300
And through this mechanism and building
up of these little individual ports and

00:48:27.300 --> 00:48:32.000
sending writes and sending messages,
all of the interfaces to the kernel

00:48:32.000 --> 00:48:37.200
use that mechanism to the Mach part of
the kernel to implement their services.

00:48:37.200 --> 00:48:41.480
So when you say task or thread create,
the first parameter to

00:48:41.480 --> 00:48:43.190
that is the task reference.

00:48:43.200 --> 00:48:45.900
Well, that's really a port write
that gives you the right to

00:48:45.900 --> 00:48:49.200
send a message to a task port.

00:48:49.210 --> 00:48:50.170
Right.

00:48:50.240 --> 00:48:52.190
That sends a message to the kernel.

00:48:52.680 --> 00:48:54.520
The kernel processes that request.

00:48:54.740 --> 00:48:56.820
If you didn't have a write to

00:48:56.970 --> 00:49:00.040
To that task port, you couldn't create a
thread in that task port,

00:49:00.040 --> 00:49:01.220
in that task.

00:49:01.220 --> 00:49:02.750
But by having a right
to send to that port,

00:49:02.860 --> 00:49:05.400
you have the right to do that operation.

00:49:05.470 --> 00:49:08.240
That goes into the kernel,
he does the work,

00:49:08.240 --> 00:49:13.090
and as a result he sends you back
a right to manipulate that thread.

00:49:13.800 --> 00:49:14.630
That's how the kernel works.

00:49:14.700 --> 00:49:17.000
This is how the Windows server works.

00:49:17.060 --> 00:49:19.640
So when you converse back
and forth between the

00:49:19.660 --> 00:49:23.610
Windows server and applications,
the Windows server gives you rights

00:49:23.680 --> 00:49:27.690
to access certain core graphic
fundamental pieces of the system.

00:49:27.690 --> 00:49:29.940
If you don't have the
right to access that,

00:49:29.940 --> 00:49:30.700
you can't.

00:49:30.730 --> 00:49:33.600
So you can't trounce
somebody else's window.

00:49:34.860 --> 00:49:39.690
As I said,
by using the protection of Mach ports,

00:49:39.690 --> 00:49:43.630
you're going to see that each application
ends up having a pile of ports.

00:49:43.750 --> 00:49:47.080
Typical application will
have 50 or so ports to it.

00:49:47.430 --> 00:49:51.150
These are reference handles to
objects implemented somewhere else,

00:49:51.180 --> 00:49:55.720
either in the kernel or
inside a Windows server.

00:49:55.780 --> 00:50:00.500
But they can also be things that
you implement and reference,

00:50:00.580 --> 00:50:03.250
and give references to other people.

00:50:03.250 --> 00:50:07.920
Exception handlers are one of the common
examples from the Mach perspective.

00:50:07.920 --> 00:50:11.440
When an exception happens in a task,
we'll send a message to whoever

00:50:11.440 --> 00:50:14.140
the exception handler is for that.

00:50:14.390 --> 00:50:18.800
Um, that task, whoever registered a port
with us to send a message,

00:50:18.800 --> 00:50:23.790
and we'll send a message that says,
"This exception happened." Um,

00:50:23.910 --> 00:50:26.070
and that may be your own
task or that may be GDB.

00:50:26.300 --> 00:50:29.360
You're going to see
that each application,

00:50:29.360 --> 00:50:35.040
almost every time you look at your stacks
or your tracebacks inside of Sampler App,

00:50:35.160 --> 00:50:38.810
you're going to see that they're all
blocked waiting on IPC operations,

00:50:38.860 --> 00:50:40.200
right, at the very highest level.

00:50:40.200 --> 00:50:43.290
That's because almost
everything in the system is,

00:50:43.290 --> 00:50:46.180
at its fundamental basis,
an IPC operation.

00:50:46.200 --> 00:50:50.200
So when you're waiting
for a semaphore to go off,

00:50:50.200 --> 00:50:56.150
or you're in your event loop, right,
for Carbon or whatever, you're going to,

00:50:56.300 --> 00:50:58.190
that thread is going to see,
at the very lowest level,

00:50:58.190 --> 00:51:02.200
you're going to see that it's
in Mach message overwrite trap.

00:51:02.200 --> 00:51:05.200
Today you're going to see that
over and over and over again.

00:51:05.200 --> 00:51:08.550
And you've got to realize that, okay,
well that's because everything

00:51:08.550 --> 00:51:10.800
degenerates down to a message eventually.

00:51:11.740 --> 00:51:13.850
And you're going to see
those things through TOP,

00:51:13.930 --> 00:51:15.410
and you're going to see
them through SC Usage.

00:51:15.810 --> 00:51:19.600
SC Usage is really nice to see
what you're doing in the system.

00:51:19.600 --> 00:51:22.990
And that should be coming up
in the tools session later.

00:51:23.620 --> 00:51:25.860
Okay, so how does this show to me?

00:51:25.860 --> 00:51:29.300
Like I just said,
each of your applications is

00:51:29.300 --> 00:51:33.180
going to have a set of ports
for accessing other things.

00:51:33.310 --> 00:51:36.230
But each of your applications is
actually going to have a set of

00:51:36.590 --> 00:51:38.380
ports for delivering events to it.

00:51:38.380 --> 00:51:39.440
Right?

00:51:39.730 --> 00:51:42.450
And at the lowest level they
are a collection of ports.

00:51:42.450 --> 00:51:45.650
They're wrapped up in port sets
so that a single thread in your

00:51:45.650 --> 00:51:47.300
application can receive them.

00:51:47.590 --> 00:51:50.800
Typically your application's
going to be using something

00:51:50.810 --> 00:51:52.420
like a Carbon Event Queue.

00:51:52.420 --> 00:51:56.440
The Carbon Event Queue
actually internally has a

00:51:56.440 --> 00:51:58.450
run loop associated with it.

00:51:58.540 --> 00:52:01.500
And that run loop has a
port set and that thread,

00:52:01.500 --> 00:52:04.500
eventually when it's
waiting on that event queue,

00:52:04.500 --> 00:52:08.650
you're going to see at the lowest
level it's waiting for a message

00:52:08.860 --> 00:52:11.300
to come in on that port set.

00:52:11.450 --> 00:52:14.430
All right, so all of these things that
deliver events to you are

00:52:14.590 --> 00:52:16.180
typically created as ports.

00:52:16.270 --> 00:52:18.540
For those that aren't,
there are certain things that are in

00:52:18.580 --> 00:52:20.340
CFRunLoop that aren't delivered that way.

00:52:20.380 --> 00:52:24.860
CFRunLoop actually
creates a port so that,

00:52:24.940 --> 00:52:30.300
and possibly a thread sitting in
that other box to receive that event

00:52:30.300 --> 00:52:34.290
and then pass it on as a message,
a simple message that says this

00:52:34.350 --> 00:52:38.060
event happened to one of those other
port sets because that's where your

00:52:38.060 --> 00:52:41.000
application's thread is waiting,
in that one spot.

00:52:41.080 --> 00:52:43.240
And it just tells him to come
over and look at the others.

00:52:43.240 --> 00:52:46.540
Right, and the same thing at the
Carbon event loop model,

00:52:46.540 --> 00:52:48.000
or the Carbon event queue model.

00:52:48.000 --> 00:52:51.160
Things will happen that
aren't delivered by ports,

00:52:51.190 --> 00:52:54.000
but because your thread
is waiting for a message,

00:52:54.000 --> 00:52:58.090
a port is created to send that,
the notification that happened.

00:53:00.580 --> 00:53:04.500
What happened in Darwin 1.0 or Mac OS X?

00:53:04.540 --> 00:53:06.740
Well, there were some IPC changes.

00:53:06.740 --> 00:53:11.040
One of them allowed that discussion
we just talked about where you may

00:53:11.040 --> 00:53:15.500
have a CF run loop and he may have
more than one mode or event queue.

00:53:15.500 --> 00:53:18.570
So you're in a certain mode,
you're in a modal environment

00:53:18.570 --> 00:53:21.480
where you only have a few
things you want to wait on.

00:53:21.970 --> 00:53:26.880
Before, lots of activity had to happen
in order to change the set of

00:53:26.880 --> 00:53:28.390
things that you were waiting on.

00:53:28.500 --> 00:53:32.960
We added a facility that lets you wait,
lets you put those events into

00:53:33.020 --> 00:53:37.030
multiple port sets simultaneously
and then you just have to switch

00:53:37.070 --> 00:53:38.490
your set that you're waiting on.

00:53:38.630 --> 00:53:42.010
That all happens under the covers,
but you'll see that if

00:53:42.010 --> 00:53:43.260
you look at the code.

00:53:43.500 --> 00:53:46.600
Coming soon,
as you saw that there were certain

00:53:46.600 --> 00:53:51.520
things that cannot be delivered
efficiently through the port mechanism,

00:53:51.570 --> 00:53:53.490
and since that's where
your application's waiting,

00:53:53.520 --> 00:53:56.500
we had to come up with some other
mechanism to ping pong it over there.

00:53:56.500 --> 00:53:56.500
Well, we're not going to do that.

00:53:57.500 --> 00:53:57.500
Okay.

00:53:58.500 --> 00:54:01.570
But we can do that more efficiently
and so we're creating additional

00:54:01.570 --> 00:54:05.300
channel types other than a message
queue so that we can deliver those

00:54:05.340 --> 00:54:10.500
events directly to that waiting thread
rather than having to ping pong it.

00:54:10.500 --> 00:54:14.590
And there's, there are new IPC,
new IPC APIs coming with those

00:54:14.730 --> 00:54:18.500
and related MIG enhancements
to come with those.

00:54:18.570 --> 00:54:21.500
Well, you saw earlier that I'm
a part-time MIG pilot.

00:54:21.760 --> 00:54:23.500
What is MIG?

00:54:23.500 --> 00:54:26.880
MIG is a tool that allows you
not to have to worry about the

00:54:26.970 --> 00:54:27.500
details of how this actually works.

00:54:27.500 --> 00:54:28.500
It's used for system services.

00:54:28.500 --> 00:54:34.700
You typically won't have to deal with it,
but a lot of the interfaces you

00:54:34.700 --> 00:54:39.440
may want to call may be defined.

00:54:39.500 --> 00:54:41.500
Graphic services use it.

00:54:41.500 --> 00:54:43.500
The low-level Mach services use it.

00:54:43.500 --> 00:54:47.760
And it's just an IDL that creates, uh,

00:54:48.230 --> 00:54:51.640
message formats for you and packages
them up so that you can just do

00:54:51.640 --> 00:54:53.990
a remote procedure call model.

00:54:54.140 --> 00:54:57.100
Again,
you'll typically use higher level things.

00:54:57.140 --> 00:55:00.170
You'll use Apple script or Apple events
in your Carbon application,

00:55:00.590 --> 00:55:04.200
where you may get down to a
lower level and use CF messages.

00:55:04.510 --> 00:55:05.840
But that's typically where you'd stop.

00:55:05.910 --> 00:55:09.250
If you want to go below
that and use Mach,

00:55:09.270 --> 00:55:13.960
well we suggest you don't
use Mach messaging directly,

00:55:13.960 --> 00:55:14.370
but try and stick with
the interface generator.

00:55:15.210 --> 00:55:17.080
There's other things that Mach provides.

00:55:17.090 --> 00:55:21.150
Won't have time really to get into those,
but it provides all of the

00:55:21.150 --> 00:55:24.400
host resources as well,
the system-wide resources.

00:55:24.500 --> 00:55:30.820
Security management, control, rebooting,
all that stuff is a Mach function.

00:55:31.000 --> 00:55:35.320
And processor control and statistics.

00:55:35.610 --> 00:55:41.840
Coming soon to a processor near you is
power management and thermal management.

00:55:41.890 --> 00:55:45.390
A lot of that work is
pretty much ready to go.

00:55:46.260 --> 00:55:51.520
Obviously, all of this stuff is not
only as the core of Mac OS X,

00:55:51.630 --> 00:55:53.190
but it's also Darwin.

00:55:53.200 --> 00:55:54.200
Right?

00:55:54.200 --> 00:55:56.200
It's open sourced.

00:55:56.650 --> 00:56:00.140
This is in keeping with the Mach legacy.

00:56:00.230 --> 00:56:02.040
Mach has always been,
or pretty much always

00:56:02.040 --> 00:56:03.200
been an open source thing.

00:56:03.200 --> 00:56:06.210
There was that brief period where
OSF did a lot of research and

00:56:06.210 --> 00:56:09.200
didn't make it available to anyone
except their paying partners.

00:56:09.200 --> 00:56:12.750
But again,
we've taken that legacy and now we're

00:56:12.750 --> 00:56:19.200
extending it by adding all of our changes
to Mach into the open source environment.

00:56:19.200 --> 00:56:23.090
Obviously, when all else fails,
having that source is a

00:56:23.440 --> 00:56:26.200
wonderful form of documentation.

00:56:26.200 --> 00:56:27.480
What is going on?

00:56:27.480 --> 00:56:31.120
Why is my application
not making any progress?

00:56:31.180 --> 00:56:35.730
Well, if it really comes down to that,
you can dive down and look at the source,

00:56:35.800 --> 00:56:38.020
because you know that
thing's blocked in a foobar,

00:56:38.020 --> 00:56:40.200
you know, Mach message overwrite trap.

00:56:40.200 --> 00:56:43.200
Well, what am I, what am I waiting on?

00:56:43.590 --> 00:56:44.080
Right?

00:56:44.190 --> 00:56:47.190
And you can actually use in really,
really, really bad situations,

00:56:47.190 --> 00:56:50.820
because we have open source,
you can actually be debugging the

00:56:50.820 --> 00:56:53.200
kernel at the same time you're
debugging your application.

00:56:53.200 --> 00:56:56.150
So you can kind of watch
it go through the kernel.

00:56:56.190 --> 00:57:00.830
That requires two machines, but again,
if you're really stuck,

00:57:00.830 --> 00:57:04.200
it's an interesting
way to look at things.

00:57:05.420 --> 00:57:08.130
The roadmap, well sorry,
most of the things that talked

00:57:08.240 --> 00:57:10.510
about a lot of this stuff
has already been completed,

00:57:10.570 --> 00:57:12.300
a lot of the BSD and file system stuff.

00:57:12.300 --> 00:57:15.300
But there's some
interesting sessions left.

00:57:15.300 --> 00:57:19.300
There's the performance
tools later today.

00:57:19.300 --> 00:57:21.280
You definitely want to look
at that because when you're

00:57:21.280 --> 00:57:24.300
tuning your application,
you're going to be looking at things

00:57:24.300 --> 00:57:27.210
that show all of these Mach pieces.

00:57:27.300 --> 00:57:31.300
There's the feedback forum tomorrow.

00:57:31.300 --> 00:57:34.690
Actually,
tomorrow morning at 9 o'clock is the

00:57:34.690 --> 00:57:39.300
debugging your Mac OS X application
session at 9 o'clock in the big hall.

00:57:39.300 --> 00:57:42.060
I didn't add this to that slide,
but it's probably a really

00:57:42.060 --> 00:57:43.230
good session to go to.

00:57:43.340 --> 00:57:48.290
And they will dip into a minor
amount of these kind of things.

00:57:48.300 --> 00:57:51.320
How, as you're debugging,
you're going to see the

00:57:51.320 --> 00:57:53.300
Mach pieces showing through.

00:57:53.300 --> 00:57:56.300
And then there's a session
also later tomorrow.

00:57:57.530 --> 00:58:02.190
on BSD and how the
BSD environment is made available.

00:58:03.710 --> 00:58:06.200
Where else can I find out
about this stuff if I care?

00:58:06.440 --> 00:58:12.150
On your CD there's a Kernel Environments
book and you can look at that.

00:58:12.250 --> 00:58:15.480
It actually discusses in more
detail a lot of these pieces.

00:58:16.260 --> 00:58:19.600
Obviously the Darwin open source,
you can go get that.

00:58:19.870 --> 00:58:23.460
And the Mac OS X homepage talks
quite a bit about what Mach provides.

00:58:23.600 --> 00:58:26.300
There's also a book,
Programming Under Mach.

00:58:26.350 --> 00:58:28.310
It's getting a little bit dated.

00:58:28.310 --> 00:58:33.000
You may have trouble finding
it in some of your bookstores,

00:58:33.000 --> 00:58:35.380
but you can go to libraries
and pick it up there.

00:58:35.630 --> 00:58:40.070
But it gives you a good overall
concept of how Mach is put together.

00:58:41.310 --> 00:58:42.520
And who to contact?

00:58:42.620 --> 00:58:46.140
John Signa,
if you have business questions.

00:58:46.200 --> 00:58:51.190
But you also have the Darwin mailing
list to contact us on technical issues.

00:58:51.190 --> 00:58:55.060
Most of us are on the
Darwin mailing list all the time,

00:58:55.190 --> 00:58:57.190
watching what's going on.

00:58:57.570 --> 00:58:59.230
And with that,
I'd like to invite the rest of the

00:58:59.240 --> 00:59:01.520
team up and we can have some Q&A.
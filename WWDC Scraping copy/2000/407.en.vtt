WEBVTT

00:00:09.400 --> 00:00:12.400
So, I'm pleased to announce that
here we're going to unveil Apple.

00:00:12.400 --> 00:00:14.940
I know there's been a lot of interest
in Apple's JavaBean Strategy.

00:00:14.980 --> 00:00:17.300
I'm here to unveil our
new JavaBean Strategy.

00:00:17.300 --> 00:00:20.710
Tied closely to our
QuickTime Distribution Strategy.

00:00:20.910 --> 00:00:22.610
Here it is.

00:00:23.600 --> 00:00:26.800
This is the Enterprise scale
JavaBeans here.

00:00:26.830 --> 00:00:28.090
Those of you.

00:00:28.090 --> 00:00:30.980
So hopefully that will
satisfy a lot of you.

00:00:31.060 --> 00:00:33.970
For those of you who won't,
I am pleased to announce Rory Lydon,

00:00:33.970 --> 00:00:36.410
the Tools Manager,
often known just as the Tool Guy.

00:00:36.500 --> 00:00:40.070
And he's here to tell you about
the other kind of JavaBeans.

00:00:42.800 --> 00:00:44.800
Thanks, thanks.

00:00:44.800 --> 00:00:45.800
Good afternoon.

00:00:45.800 --> 00:00:49.190
Thanks for coming, everybody.

00:00:49.800 --> 00:00:53.710
It's a little dangerous to tackle such
a soporific subject matter in that

00:00:53.820 --> 00:00:56.620
witching hour between lunch and coffee,
but we'll see if we can

00:00:56.620 --> 00:00:57.990
keep each other awake.

00:00:58.270 --> 00:01:05.870
As Ernie said, I'm Rory Lydon,
and the subtitle of this session is

00:01:05.870 --> 00:01:08.890
"Making the Best of a Bad Thing."

00:01:14.000 --> 00:01:18.840
All right,
so obviously this session has two topics,

00:01:18.840 --> 00:01:21.440
WebObjects and EJB.

00:01:21.520 --> 00:01:23.900
I'm going to cover a little bit of each.

00:01:23.900 --> 00:01:27.690
It's certainly not going to
be exhaustive of either topic,

00:01:27.690 --> 00:01:31.500
but if there's anything I don't
cover that's a curiosity to you,

00:01:31.510 --> 00:01:33.610
please ask a question at the end.

00:01:33.610 --> 00:01:33.610
All right?

00:01:33.790 --> 00:01:40.880
So, first thing we're going to do is kind
of talk a little bit about what EJB is.

00:01:40.880 --> 00:01:44.040
How many of you here--I saw
some people have used EJB.

00:01:44.040 --> 00:01:46.910
How many of you think
you know what it is?

00:01:48.100 --> 00:01:55.700
[Transcript missing]

00:01:56.170 --> 00:02:00.170
Then we'll talk about the differences
between WebObjects and EJB,

00:02:00.170 --> 00:02:03.700
kind of the competition or
tension between the two.

00:02:03.740 --> 00:02:06.950
And then we'll talk
about WebObjects and EJB,

00:02:06.970 --> 00:02:09.860
how they can and will work together.

00:02:09.890 --> 00:02:12.420
And then we'll do Q&A.

00:02:12.450 --> 00:02:14.780
Okay, so what is EJB?

00:02:15.560 --> 00:02:19.400
First and foremost, it's over 300 pages.

00:02:19.440 --> 00:02:21.000
Here's the specification.

00:02:21.000 --> 00:02:23.540
This is my copy.

00:02:23.560 --> 00:02:25.740
If you want to understand it,
there's really nothing for it.

00:02:25.880 --> 00:02:28.080
You've got to read this thing.

00:02:28.090 --> 00:02:30.180
It's a very interesting document.

00:02:30.190 --> 00:02:33.670
We'll come back to that later.

00:02:34.210 --> 00:02:36.600
EJB is part of J2EE.

00:02:36.600 --> 00:02:38.000
This is very interesting.

00:02:38.130 --> 00:02:44.560
It's packaged separately and
it's not a prerequisite to be

00:02:44.580 --> 00:02:49.280
a J2EE vendor to support EJB,
but the two are actually

00:02:49.440 --> 00:02:50.640
very closely bound.

00:02:50.640 --> 00:02:54.600
And you can't in fact ship
the interfaces for EJB without

00:02:54.600 --> 00:02:57.590
shipping the J2EE package as well.

00:02:57.590 --> 00:03:00.540
So it's a little,
they're very closely bound.

00:03:00.670 --> 00:03:03.920
It's a very impressive
marketing achievement.

00:03:05.400 --> 00:03:12.010
I mean, anybody who deals with IS or
IT managers knows that,

00:03:12.120 --> 00:03:15.180
for a long time,
as application servers and web-based

00:03:15.180 --> 00:03:18.910
applications came to the fore,
they were freaking out because

00:03:18.970 --> 00:03:20.960
there were absolutely no standards.

00:03:20.960 --> 00:03:25.000
And they never knew -- they barely
knew the nomenclature; they didn't

00:03:25.000 --> 00:03:26.360
know how to compare different products.

00:03:26.490 --> 00:03:29.630
So for them, this was a godsend, right,
because they heard from Java Soft,

00:03:29.660 --> 00:03:32.950
"This is the way things are going
to be." And suddenly they realized,

00:03:32.950 --> 00:03:36.030
"Oh, well, as long as vendor A and vendor
B both implement Java beans

00:03:36.030 --> 00:03:38.740
-- enterprise Java beans,
I can just stack them next to each other,

00:03:38.740 --> 00:03:41.140
run a test suite,
and whichever one is faster

00:03:41.140 --> 00:03:42.660
will buy and use," right?

00:03:42.660 --> 00:03:44.480
So -- and at this point,
the truth be told,

00:03:44.480 --> 00:03:47.160
it's impossible to be competitive
in the application server

00:03:47.160 --> 00:03:50.190
market without supporting EJB,
for better or worse.

00:03:50.220 --> 00:03:53.460
So it is a very impressive
marketing achievement.

00:03:53.460 --> 00:03:58.450
And it's also the death of EOF,
according to a wide variety of people.

00:03:58.460 --> 00:04:01.980
We even had people in our hallways
running around saying that there

00:04:01.980 --> 00:04:03.630
was no need for EOF anymore.

00:04:03.660 --> 00:04:08.740
We're just going to do
everything with EJB.

00:04:08.740 --> 00:04:09.760
We'll come back to that later.

00:04:09.900 --> 00:04:11.730
All right.

00:04:12.060 --> 00:04:13.650
Now, specifics.

00:04:13.690 --> 00:04:18.280
Several times today, I'm going to quote
from the specification.

00:04:18.280 --> 00:04:20.340
There is some very
interesting material in it,

00:04:20.340 --> 00:04:23.930
and it is ultimately the
definition of the product.

00:04:24.060 --> 00:04:28.060
It's an unusually turgid
piece of technical writing.

00:04:28.170 --> 00:04:31.380
It has phrases in it like,
"The EJB is the best." Yeah.

00:04:31.380 --> 00:04:31.640
Yeah.

00:04:31.640 --> 00:04:35.440
container provider
container provider for short

00:04:38.860 --> 00:04:42.530
And my personal favorite,
the EJB server must also provide a

00:04:42.530 --> 00:04:46.670
container for the Enterprise Beans
which is called an EJB container.

00:04:49.370 --> 00:04:53.340
Slightly less humorous note,
the Enterprise JavaBeans architecture

00:04:53.340 --> 00:04:56.820
will be the standard component
architecture for building distributed

00:04:56.820 --> 00:05:00.990
object-oriented business applications
in the Java programming language.

00:05:01.130 --> 00:05:05.360
That's the fundamental
goal of Javasoft for EJB.

00:05:06.330 --> 00:05:10.560
In terms of what is EJB,
the Enterprise JavaBeans

00:05:10.560 --> 00:05:14.500
architecture is an architecture for
component-based distributed computing.

00:05:14.660 --> 00:05:18.230
Okay, so that's the core definition here.

00:05:18.310 --> 00:05:19.150
We'll take a look at that.

00:05:19.320 --> 00:05:23.130
First of all,
what does it mean to be component-based?

00:05:23.560 --> 00:05:25.830
This is very interesting to me.

00:05:25.850 --> 00:05:29.530
There's been a big surge in the
media and in the industry about

00:05:29.650 --> 00:05:33.070
component-based development.

00:05:33.240 --> 00:05:36.990
But when you try and find out what
component-based development really is,

00:05:36.990 --> 00:05:41.060
it's pretty hard to get
a concrete definition.

00:05:41.180 --> 00:05:43.330
So what is a component?

00:05:43.910 --> 00:05:46.030
People say it's more than an object.

00:05:46.110 --> 00:05:48.290
Now,
I personally find this very interesting

00:05:48.290 --> 00:05:51.950
because to me the whole genius of
the object-oriented programming

00:05:52.060 --> 00:05:54.760
paradigm is that it's all-encompassing.

00:05:54.830 --> 00:05:59.170
All the things that we see around us in
the world and even a surprising number

00:05:59.280 --> 00:06:04.800
of the thoughts that we have in our
heads are easily renderable as objects,

00:06:04.800 --> 00:06:04.800
right?

00:06:04.800 --> 00:06:10.450
So, I'm not sure why anyone would need
to come outside that paradigm,

00:06:10.450 --> 00:06:14.710
but they're composable,
as the name would suggest.

00:06:15.020 --> 00:06:16.400
and they're portable.

00:06:16.560 --> 00:06:20.180
Alright, so if you'll indulge me,
I'd like to back up a little bit and

00:06:20.180 --> 00:06:22.360
if components are more than an object,
I'd like to take a quick

00:06:22.450 --> 00:06:24.400
look at what an object is,
alright?

00:06:24.530 --> 00:06:27.240
Most of you probably are already
familiar with the concept,

00:06:27.290 --> 00:06:31.400
but an object consists of data,
fundamentally,

00:06:31.450 --> 00:06:37.770
and a wrapper of code around that data,
which is that data's interface

00:06:37.960 --> 00:06:39.790
to the outside world.

00:06:40.300 --> 00:06:43.030
Some objects have just a little data.

00:06:43.030 --> 00:06:45.320
Some objects are almost nothing but data.

00:06:45.540 --> 00:06:49.850
They just have this
candy veneer of logic.

00:06:49.920 --> 00:06:52.060
But objects always have data.

00:06:52.150 --> 00:06:54.830
They always have data.

00:06:54.920 --> 00:07:00.690
Even if the data is just other objects.

00:07:02.580 --> 00:07:04.250
What does it mean to be
more than an object then?

00:07:04.270 --> 00:07:08.790
Well, what they're really talking
about here is it's an object,

00:07:08.790 --> 00:07:13.500
but it's got an interface outside it,
okay, which essentially constitutes

00:07:13.500 --> 00:07:18.500
a contract between the object
and the rest of the world.

00:07:18.510 --> 00:07:22.970
Essentially what is often referred to
as the object's habitat or environment,

00:07:22.970 --> 00:07:23.500
okay?

00:07:23.500 --> 00:07:25.510
So there are two parties
to this contract:

00:07:25.510 --> 00:07:28.500
the object, which implements its
half of the interface,

00:07:28.500 --> 00:07:31.740
and the habitat,
which supports the object and

00:07:31.740 --> 00:07:36.290
provides the infrastructure it
needs to get its business done.

00:07:36.460 --> 00:07:40.600
When they say that it's composable,
they just mean that given this contract,

00:07:40.600 --> 00:07:43.010
you can take objects from a
variety of different sources

00:07:44.940 --> 00:07:47.190
and they can communicate
with the habitat,

00:07:47.380 --> 00:07:49.690
leverage the habitat support.

00:07:49.690 --> 00:07:53.810
They can communicate with each
other in terms of that support.

00:07:53.810 --> 00:07:56.620
And in an ideal world,
in the most sophisticated systems,

00:07:56.630 --> 00:07:59.220
they can communicate with each
other purely in terms of their

00:07:59.220 --> 00:08:02.880
own logic and the environment
is essentially transparent.

00:08:03.470 --> 00:08:06.380
When they say that
components are portable,

00:08:06.390 --> 00:08:09.620
well, what they really mean is that
because of this contract,

00:08:09.670 --> 00:08:12.240
as long as the objects
support this contract,

00:08:12.270 --> 00:08:19.920
you can essentially rip out the habitat
and replace it with another habitat,

00:08:19.930 --> 00:08:22.060
excuse me, with another habitat,
and the objects will be perfectly happy.

00:08:22.060 --> 00:08:25.160
They won't even know that the rug has
been pulled out from underneath them.

00:08:25.420 --> 00:08:27.780
So that's what they're
really talking about.

00:08:28.090 --> 00:08:29.950
So they say that a component
is more than an object.

00:08:30.040 --> 00:08:31.640
It's composable, it's portable.

00:08:31.640 --> 00:08:37.210
To me, a component is just a
well-designed object that works.

00:08:39.660 --> 00:08:43.490
So that's the component-based part.

00:08:43.640 --> 00:08:45.250
So what about distributed?

00:08:45.410 --> 00:08:48.500
Well, or actually, sorry,
before we go into that,

00:08:48.540 --> 00:08:53.250
what does this notion of component-based
technology mean in terms of EJB?

00:08:54.650 --> 00:08:59.200
Well, there's a contract for every
EJB called Enterprise Bean.

00:08:59.200 --> 00:09:04.640
This is a basic interface in the
technology that all EJBs implement.

00:09:05.190 --> 00:09:10.340
The counterpart in that contract
is something called a container.

00:09:10.520 --> 00:09:16.500
It's providing services to
the object that allow it to

00:09:16.560 --> 00:09:19.070
do whatever it needs to do.

00:09:20.630 --> 00:09:23.080
Some of these services,
well actually all of these services:

00:09:23.080 --> 00:09:26.880
JNDI, this is the Java naming
and directory interface.

00:09:26.960 --> 00:09:32.580
It's essentially a distributed
naming scheme and lookup technology.

00:09:32.700 --> 00:09:37.580
JDBC, Java Database Connectivity.

00:09:38.460 --> 00:09:44.300
A single class in a larger interface
called the Java Transaction API.

00:09:44.300 --> 00:09:47.690
I don't know in terms of these
mnemonics which is funnier using

00:09:47.820 --> 00:09:53.690
two words for database or using
the A in API as part of an acronym.

00:09:54.260 --> 00:09:58.340
The only part that you have to
support is user transaction.

00:09:58.460 --> 00:10:00.240
You're also supposed
to support Java mail,

00:10:00.240 --> 00:10:01.000
but whatever.

00:10:01.200 --> 00:10:06.700
Okay, so these are the big three for EJB.

00:10:06.920 --> 00:10:11.320
Now it's interesting because the
relationship between the container and

00:10:11.320 --> 00:10:13.900
the contained object is unidirectional.

00:10:14.000 --> 00:10:16.440
The container messages
the contained object,

00:10:16.580 --> 00:10:20.360
but the contained object has
absolutely no access to its container.

00:10:20.580 --> 00:10:25.080
So it has really a kind of implicit
relationship with these services.

00:10:25.190 --> 00:10:27.660
It acquires them indirectly.

00:10:29.000 --> 00:10:34.040
These services actually inhabit
a larger outside object,

00:10:34.040 --> 00:10:36.000
which is the server.

00:10:36.150 --> 00:10:40.290
In EJB you have the concept of
a container and then a server

00:10:40.610 --> 00:10:42.940
which contains the container.

00:10:43.910 --> 00:10:50.020
Turns out the server is actually
remarkably similar to a J2EE server.

00:10:50.370 --> 00:10:56.130
J2EE also supports these other
technologies like Java server pages,

00:10:56.270 --> 00:10:59.140
Java messaging system,
and again our friend JavaMail.

00:10:59.200 --> 00:11:03.400
But JNDI, JDBC,
and the user transaction component of

00:11:03.400 --> 00:11:09.460
JTA are the only components of this
system that are really required for EJB.

00:11:13.070 --> 00:11:18.450
Okay, now a container can also obviously
contain more than one object,

00:11:18.450 --> 00:11:22.530
and a server can operate
more than one container.

00:11:22.760 --> 00:11:26.680
This is actually important
because this is how you achieve

00:11:26.760 --> 00:11:33.190
scaling and distribution with EJB.

00:11:34.860 --> 00:11:37.490
Okay, so let's see.

00:11:37.730 --> 00:11:40.290
Let's take a close look at distributed.

00:11:40.380 --> 00:11:44.240
Well, again, if you'll indulge me,
I'd like to delve into the definition

00:11:44.240 --> 00:11:50.600
of distribution a little bit,
especially as it pertains to objects.

00:11:50.600 --> 00:11:50.600
You have some process.

00:11:51.210 --> 00:11:54.710
That process lives on a network
and there's a boundary between

00:11:54.710 --> 00:11:57.750
the process and its client.

00:11:58.180 --> 00:12:03.340
In traditional client-server world,
one side is called the server,

00:12:03.340 --> 00:12:06.510
the other is called the client,
but in a truly distributed system,

00:12:06.510 --> 00:12:08.090
that definition disappears.

00:12:08.220 --> 00:12:11.980
You really have a democratic
topology where there isn't

00:12:11.980 --> 00:12:15.120
really a subordinate process,
there are really just two

00:12:15.130 --> 00:12:16.910
processes communicating.

00:12:17.210 --> 00:12:19.390
One process invokes something in another.

00:12:19.390 --> 00:12:23.590
In the simplest world,
in a procedural world, this is an RPC,

00:12:23.660 --> 00:12:26.240
something we're all pretty familiar with.

00:12:26.900 --> 00:12:30.360
In a slightly more sophisticated world,
such as CORBA,

00:12:30.420 --> 00:12:34.800
one is actually invoking a method on an
object contained in the remote process.

00:12:34.800 --> 00:12:37.900
And of course in a highly
sophisticated system,

00:12:37.930 --> 00:12:41.800
you're just talking about
object-to-object communication.

00:12:41.980 --> 00:12:44.090
Now, the big problem with this,
of course,

00:12:44.090 --> 00:12:45.800
is that objects tend to be chatty.

00:12:45.800 --> 00:12:50.680
And the amount of overhead
associated with communicating back

00:12:50.730 --> 00:12:54.780
and forth over the network can
really bring a system to its knees.

00:12:54.800 --> 00:12:58.800
This is a very, very interesting problem.

00:12:59.080 --> 00:13:02.640
One solution to this problem

00:13:03.730 --> 00:13:09.460
is essentially to introduce a proxy on
the remote side of the network such that

00:13:09.680 --> 00:13:15.700
objects manipulating that proxy have
the opinion that the object is local.

00:13:15.760 --> 00:13:21.280
And you have some distribution
system which manages synchronizing

00:13:21.280 --> 00:13:23.690
the proxy with the original.

00:13:23.720 --> 00:13:26.890
I don't know how many of you
were here for the Direct-to-Java

00:13:26.890 --> 00:13:30.850
client session this morning,
but that's what our distribution

00:13:30.850 --> 00:13:32.560
technology is all about.

00:13:33.050 --> 00:13:36.210
And indeed,
this balance of the remote object and the

00:13:36.210 --> 00:13:41.560
local object is kind of one of the key
skills in the modern development world.

00:13:41.630 --> 00:13:44.770
Especially moving forward,
it's all going to be about deciding

00:13:45.110 --> 00:13:50.500
how much of the logic you put
on what side of the network.

00:13:50.590 --> 00:13:54.570
Typically, on the server side,
you have larger objects

00:13:54.570 --> 00:13:56.350
than you do on the client.

00:13:56.710 --> 00:14:00.580
But the client-side object can have a
lot of unique logic to it that isn't

00:14:00.580 --> 00:14:02.990
even present on the server side.

00:14:03.500 --> 00:14:14.400
[Transcript missing]

00:14:14.870 --> 00:14:19.140
is to have some kind of stub
object which represents the

00:14:19.140 --> 00:14:22.350
remote object but doesn't really

00:14:22.580 --> 00:14:28.950
allows you to execute any of the objects
logic locally or access any of its data

00:14:29.700 --> 00:14:46.500
[Transcript missing]

00:14:48.430 --> 00:14:52.060
Okay,
so going back to the definition of EJB,

00:14:52.110 --> 00:14:54.330
again you have your Enterprise Bean.

00:14:54.440 --> 00:14:56.420
It's in a container.

00:14:58.240 --> 00:15:03.010
The convention in EJB for
distribution is to have a

00:15:03.010 --> 00:15:07.600
remote stub called an EJBObject.

00:15:08.330 --> 00:15:12.200
which communicates back to the
Enterprise Bean on the server side.

00:15:12.200 --> 00:15:17.880
Every time you want to invoke
any business logic on the object

00:15:18.180 --> 00:15:23.810
or access any of its data,
you do a round trip on the network.

00:15:25.290 --> 00:15:27.400
and incur all the overhead
associated with that.

00:15:27.450 --> 00:15:33.190
Now one might think, well,
what if I managed to have

00:15:33.200 --> 00:15:37.140
an Enterprise JavaBean in
a container that's local?

00:15:37.300 --> 00:15:42.700
So even though the object has
this distribution paradigm,

00:15:42.700 --> 00:15:45.690
it's actually in the same
process and in the same VM as me.

00:15:45.780 --> 00:15:47.180
Won't that make things faster?

00:15:47.200 --> 00:15:51.190
Well, in fact,
according to the specification,

00:15:51.190 --> 00:15:55.760
every method call to an entity object,
that's a form of EJB,

00:15:55.880 --> 00:15:59.120
via the remote and home interface,
the only way to get at an EJB,

00:15:59.120 --> 00:16:00.200
is potentially a remote call.

00:16:00.200 --> 00:16:04.560
Even if the calling and called entity
bean are collated in the same JVM,

00:16:04.560 --> 00:16:09.140
the call must go through the container,
which must create copies of all

00:16:09.220 --> 00:16:13.450
the parameters that are passed
through the interface by value.

00:16:15.260 --> 00:16:18.110
The container is also required
to check security and apply the

00:16:18.110 --> 00:16:21.840
declarative transaction attribute
on the intercomponent calls.

00:16:21.910 --> 00:16:25.940
The overhead of an intercomponent call
will likely be prohibitive for object

00:16:25.990 --> 00:16:28.460
interactions that are too fine-grained.

00:16:28.590 --> 00:16:31.480
So obviously this is a
very coarsely grained,

00:16:31.600 --> 00:16:33.120
heavyweight technology.

00:16:33.210 --> 00:16:36.880
Even when two EJBs are
in the same process,

00:16:36.880 --> 00:16:40.760
there's an inordinate amount of
overhead for them to communicate.

00:16:40.860 --> 00:16:44.750
Hardly the most hospitable habitat.

00:16:44.830 --> 00:16:47.960
Okay, so that's the distributed portion.

00:16:49.000 --> 00:16:50.500
Just a word here.

00:16:50.500 --> 00:16:54.320
Like I said,
I'm not going to go into too much detail.

00:16:54.420 --> 00:16:58.320
And that's not because it
isn't interesting or because

00:16:58.320 --> 00:16:59.850
I'm attempting to avoid it.

00:16:59.900 --> 00:17:01.900
It's just I'm trying to keep
this as simple as possible.

00:17:01.930 --> 00:17:07.760
There are two flavors of EJB:
a session bean and an entity bean.

00:17:07.960 --> 00:17:10.430
The fundamental difference really
is that an entity bean is very

00:17:10.430 --> 00:17:18.730
similar to what we call an EO or an
Enterprise Object in that it has a

00:17:18.910 --> 00:17:21.660
primary key and it really represents

00:17:21.820 --> 00:17:24.260
A business object,
a single business object

00:17:24.260 --> 00:17:25.340
within your system.

00:17:25.350 --> 00:17:27.290
A session bean is much more of a process.

00:17:27.390 --> 00:17:30.860
It's more akin to a
WebObjects direct action.

00:17:30.910 --> 00:17:32.520
Typically you'll find
that a session bean,

00:17:32.520 --> 00:17:36.690
in order to implement its functionality,
will manipulate a whole slew

00:17:36.690 --> 00:17:39.280
of what would be entity beans.

00:17:39.320 --> 00:17:43.300
The basic idea is that if you're going
to be interacting heavily with an object,

00:17:43.330 --> 00:17:46.500
you don't want to use an entity bean,
you want to use a session bean in

00:17:46.500 --> 00:17:48.550
order to avoid the overhead problem.

00:17:50.210 --> 00:17:52.660
Okay, so now I'd like to talk just a
little bit about persistence because

00:17:52.660 --> 00:17:55.440
persistence is essential to EJB.

00:17:55.480 --> 00:17:58.910
I mean, the bottom line is that
objects are at least 50% data.

00:17:59.020 --> 00:18:01.440
Well, I mean, the ratio may vary,
but you can't have an

00:18:01.440 --> 00:18:02.760
object without data.

00:18:02.870 --> 00:18:05.230
And chances are,
most meaningful data is going

00:18:05.230 --> 00:18:07.040
to have to be stored somewhere.

00:18:07.110 --> 00:18:09.980
So persistence is very, very important.

00:18:10.090 --> 00:18:13.360
There are two flavors, again,
of persistence in EJB:

00:18:13.470 --> 00:18:17.960
bean-managed persistence and
container-managed persistence.

00:18:17.960 --> 00:18:22.290
So let's talk a little bit about
being a managed persistence.

00:18:23.140 --> 00:18:26.720
Again,
going back to this contract between

00:18:26.720 --> 00:18:30.840
Container and Enterprise JavaBean,

00:18:32.190 --> 00:18:38.800
There's a bunch of APIs associated with
entity beans for managing persistence.

00:18:38.800 --> 00:18:43.700
Essentially, the container invokes
these methods and the EJB,

00:18:43.700 --> 00:18:45.630
the entity bean,
is expected to react to them

00:18:45.630 --> 00:18:47.080
and behave appropriately.

00:18:47.120 --> 00:18:51.300
So, when the container sends
an EJB or an entity bean

00:18:51.300 --> 00:18:56.790
specifically a create message,
it's expected to initialize

00:18:56.840 --> 00:19:00.100
its data as appropriate on
the basis of the arguments,

00:19:00.630 --> 00:19:03.010
Communicate with JDBC.

00:19:03.410 --> 00:19:08.510
Introduce the data associated
with itself into either a table

00:19:09.030 --> 00:19:11.300
or tables in the database.

00:19:11.300 --> 00:19:15.300
The entity bean itself,
in the case of BeanManagedPersistence,

00:19:15.300 --> 00:19:19.300
is responsible for performing
all those operations.

00:19:19.300 --> 00:19:25.460
It's interesting when one
considers this is a method.

00:19:25.460 --> 00:19:27.300
If you implement this
method in your code,

00:19:27.300 --> 00:19:31.300
and the only interface you
have at your disposal is JDBC,

00:19:31.300 --> 00:19:36.300
you're going to wind up writing
essentially SQL code in your entity bean.

00:19:36.430 --> 00:19:40.110
So what happens when
you change the schema?

00:19:40.290 --> 00:19:43.300
Let's say you do something as
simple as change a column name,

00:19:43.300 --> 00:19:45.300
let alone change a database vendor.

00:19:45.300 --> 00:19:47.300
You're going to have to recompile a bean.

00:19:47.370 --> 00:19:51.200
Same thing for EJB_LOAD.

00:19:51.290 --> 00:19:56.110
In this case, there's a couple of really
weird semantics in EJB.

00:19:56.300 --> 00:19:56.780
In this case,
you're going to have to write a code

00:19:56.790 --> 00:19:57.300
that's going to be in the database.

00:19:57.300 --> 00:20:00.630
In this case, even though the entity bean
hasn't been initialized,

00:20:00.630 --> 00:20:03.300
in other words,
it doesn't have its identity yet,

00:20:03.300 --> 00:20:06.860
it doesn't have its primary key yet,
the only interface between the

00:20:06.920 --> 00:20:10.300
container and the logic that
you've implemented is the bean.

00:20:10.300 --> 00:20:15.300
So it kind of initializes an entity bean
and then tells itself to load itself.

00:20:15.300 --> 00:20:19.300
So the entity bean at this
point doesn't have its data.

00:20:19.300 --> 00:20:24.000
It's expected again to go through JDBC,
go out to the database, get its data,

00:20:24.000 --> 00:20:26.300
populate itself appropriately.

00:20:26.320 --> 00:20:27.300
Same cycle.

00:20:27.300 --> 00:20:31.550
same responsibilities for the entity.

00:20:33.490 --> 00:20:36.180
Again, when the container tells
the bean to store itself,

00:20:36.250 --> 00:20:42.990
it's responsible for figuring out what
portions of its data have changed.

00:20:43.360 --> 00:20:48.110
Communicate those changes to
JDBC so that JDBC can update

00:20:48.120 --> 00:20:51.830
columns or rows in the database.

00:20:52.740 --> 00:20:56.340
Now, very interesting thing to do
if you download the reference

00:20:56.340 --> 00:21:01.180
implementation of EJB from Sun,
just take one of the entity beans,

00:21:01.280 --> 00:21:04.440
change it so that the only thing
you do in any of these methods is,

00:21:04.700 --> 00:21:10.500
you know, println to standard out,
you'll see that the slew of invocations

00:21:10.600 --> 00:21:16.600
of EJB load and EJB store that transpire
in even the simplest operation.

00:21:16.640 --> 00:21:20.920
So, if this process of loading
oneself from the database,

00:21:20.920 --> 00:21:25.590
let alone storing oneself on the basis
of only that data that has changed,

00:21:25.900 --> 00:21:31.590
isn't very carefully managed,
performance just degradates phenomenally.

00:21:31.730 --> 00:21:35.730
And really,
EJB does not provide any assistance

00:21:35.730 --> 00:21:41.540
in this process for entity beans
with bean-managed persistence.

00:21:41.940 --> 00:21:46.290
The final two cases are EJB Remove.

00:21:46.700 --> 00:21:51.120
The bean is supposed to
figure out how to destroy any

00:21:51.200 --> 00:21:53.600
references to itself in store.

00:21:53.740 --> 00:21:56.420
Do that and then just kind of go away.

00:21:56.600 --> 00:22:01.600
And finally, EJB.find,
which I'm not even going to get into.

00:22:01.600 --> 00:22:04.820
Again,
this is one of those things where the

00:22:04.840 --> 00:22:10.410
container asks an instance of an entity
bean class to go out and find a bunch of

00:22:10.410 --> 00:22:13.600
other instances of that class for itself.

00:22:13.600 --> 00:22:17.600
It's a little weird.

00:22:17.710 --> 00:22:23.600
The bottom line, though,
is that this EJB specification,

00:22:23.600 --> 00:22:26.600
and the use of the word "this" is
actually kind of interesting here,

00:22:26.600 --> 00:22:30.950
this EJB specification does not
define the architecture for data

00:22:31.030 --> 00:22:33.510
access objects or strategies.

00:22:33.780 --> 00:22:37.920
This means that EJB...

00:22:38.090 --> 00:22:40.850
EJB persistence is limited to JDBC.

00:22:40.960 --> 00:22:45.040
The only tool that an entity bean
has at its disposal to implement

00:22:45.040 --> 00:22:50.990
all of that logic that we just
saw is pure row oriented JDBC,

00:22:50.990 --> 00:22:50.990
essentially SQL.

00:22:52.840 --> 00:22:56.870
In the case of container
managed persistence,

00:22:56.970 --> 00:23:00.350
the theory here is that the
container will manage all that

00:23:00.350 --> 00:23:02.300
hard work for the entity bean.

00:23:02.300 --> 00:23:05.220
I mean,
who really would want to deal with all

00:23:05.220 --> 00:23:08.000
that and just leave it to the container?

00:23:08.230 --> 00:23:15.510
So, well, it still invokes all these
methods on the entity bean.

00:23:15.510 --> 00:23:15.510
The entity bean is just...

00:23:15.700 --> 00:23:20.160
is a container that is supposed to do
anything when it gets these messages.

00:23:20.160 --> 00:23:24.110
But the container is what
manages the relationship between

00:23:24.480 --> 00:23:26.100
the bean and the database.

00:23:26.100 --> 00:23:27.720
It invokes JDBC.

00:23:27.720 --> 00:23:31.270
It performs all these
operations for the entity bean.

00:23:32.820 --> 00:23:36.650
According to the spec,
the disadvantage of container-managed

00:23:36.650 --> 00:23:40.200
persistence is that sophisticated
tools must be used at deployment

00:23:40.200 --> 00:23:44.060
time to map the entity bean's
fields to a data source.

00:23:44.080 --> 00:23:48.370
It's kind of strange that sophisticated
tools are such a disadvantage,

00:23:48.370 --> 00:23:48.370
but

00:23:51.070 --> 00:23:55.280
What they're really saying here is
that these tools and containers are

00:23:55.280 --> 00:23:58.330
typically specific to each data source.

00:23:58.440 --> 00:24:03.090
Well, typically I suppose they are.

00:24:05.190 --> 00:24:08.760
Furthermore, if the Bean provider,
this is the person who

00:24:08.760 --> 00:24:11.650
writes the entity Bean,
Sun defines all these roles

00:24:11.680 --> 00:24:14.550
which typically coalesce
into one or two people.

00:24:14.930 --> 00:24:18.280
If the Bean provider expects that
the container managed fields will

00:24:18.280 --> 00:24:22.600
be mapped to database fields,
he should provide mapping instructions

00:24:23.140 --> 00:24:27.310
to the deployer for realization by
the data access classes generated

00:24:27.400 --> 00:24:29.800
by the container provider's tools.

00:24:30.520 --> 00:24:35.220
Because entity beans are
typically coarse-grained objects,

00:24:35.220 --> 00:24:38.970
the content of the container-managed
fields may be stored in multiple rows,

00:24:38.980 --> 00:24:42.300
possibly spread across
multiple database tables.

00:24:42.400 --> 00:24:47.390
These mapping techniques are beyond
the scope of the EJB specification.

00:24:47.560 --> 00:24:52.570
and do not need to be supported
by an EJB compliant container.

00:24:53.870 --> 00:24:56.560
I thought the container was going
to handle all this hassle for me,

00:24:56.560 --> 00:24:59.240
but I guess it turns out
that it isn't going to.

00:24:59.280 --> 00:25:02.120
And indeed,
because a compliant EJB container is

00:25:02.120 --> 00:25:06.020
not required to provide any support
for mapping the container-managed

00:25:06.020 --> 00:25:09.380
fields to a database schema,
a bean provider of entity beans

00:25:09.780 --> 00:25:14.430
that need a particular mapping to an
underlying database schema instead

00:25:15.020 --> 00:25:17.930
should use bean-managed persistence.

00:25:17.970 --> 00:25:21.310
So, they just threw the ball
right back in the beans court.

00:25:23.430 --> 00:25:26.200
An entity bean designer who runs
into the limitations of container

00:25:26.200 --> 00:25:31.540
managed persistence should use
bean managed persistence instead.

00:25:31.570 --> 00:25:34.790
I guess I'll be using
bean managed persistence.

00:25:37.170 --> 00:25:40.520
Okay, so that's a brief
overview of what EJB is.

00:25:40.830 --> 00:25:43.320
Very brief.

00:25:43.320 --> 00:25:47.270
Now I'd like to talk a little
bit about WebObjects versus EJB.

00:25:53.720 --> 00:25:55.410
WebObjects has a contract too.

00:25:55.630 --> 00:26:01.020
We call these things objects,
not components, but same basic principle.

00:26:01.820 --> 00:26:04.940
Our contract is called EnterpriseObject.

00:26:04.940 --> 00:26:12.420
The two parties of the contract are
your business class and something

00:26:12.420 --> 00:26:14.340
we call an editing context.

00:26:15.050 --> 00:26:19.360
The editing context is
essentially our container.

00:26:19.460 --> 00:26:23.430
The relationship and communication
between the editing context and the

00:26:23.480 --> 00:26:25.840
Enterprise object is bidirectional.

00:26:27.500 --> 00:26:44.900
[Transcript missing]

00:26:46.970 --> 00:26:52.590
The editing context, I mean,
there's just no notion of

00:26:52.950 --> 00:26:55.750
Enterprise Object Managed Persistence.

00:26:55.760 --> 00:26:58.400
The whole idea is that the
editing context takes care

00:26:58.400 --> 00:27:00.680
of all that hassle for you.

00:27:00.820 --> 00:27:04.310
So it communicates with
the database driver.

00:27:05.180 --> 00:27:09.730
and manages conveying data
from the data store to the

00:27:09.730 --> 00:27:11.670
Enterprise Object and back again.

00:27:11.820 --> 00:27:15.080
It also manages the
relationships between objects,

00:27:15.080 --> 00:27:18.230
manages rendering them in
terms of the database schema,

00:27:18.230 --> 00:27:19.840
and it also tracks changes.

00:27:20.000 --> 00:27:25.860
So it always knows what components of
the Enterprise Object have been modified.

00:27:26.060 --> 00:27:29.860
So it's able to optimize
this communication.

00:27:31.220 --> 00:27:35.990
You'll see in WebObjects 5 for
Java that JDBC is the driver.

00:27:36.090 --> 00:27:41.110
So this is very analogous in
that respect to the container.

00:27:41.460 --> 00:27:44.670
It's worth pointing out here, actually,
I'm simplifying things,

00:27:44.670 --> 00:27:48.400
but actually it isn't the editing context
that communicates with the database.

00:27:48.480 --> 00:27:53.400
The editing context communicates with
something called an object store.

00:27:53.400 --> 00:27:56.380
The editing context is itself
a kind of object store,

00:27:56.500 --> 00:28:01.140
but object store is our general
paradigm for persistence.

00:28:01.470 --> 00:28:04.730
The fundamental assumption
of an enterprise object

00:28:04.850 --> 00:28:07.290
is that it does have data,
and believe it or not,

00:28:07.400 --> 00:28:08.290
that data will persist.

00:28:08.500 --> 00:28:12.650
The whole architecture of
WebObjects is designed from the

00:28:12.660 --> 00:28:15.310
ground up to support this notion.

00:28:15.400 --> 00:28:18.190
The editing context communicates
with the object store.

00:28:18.390 --> 00:28:26.260
The object store communicates with JDBC,
and JDBC communicates with the database.

00:28:27.440 --> 00:28:28.870
WebObjects distribution.

00:28:29.090 --> 00:28:31.400
I don't know how many of
you were here this morning,

00:28:31.400 --> 00:28:36.200
but the basic idea here is that
you have an editing context

00:28:36.200 --> 00:28:39.570
containing an Enterprise object
on one side of the network.

00:28:39.720 --> 00:28:42.150
You have an object on the
other side of the network that

00:28:42.150 --> 00:28:43.840
wants to communicate with it.

00:28:45.240 --> 00:28:48.300
Again,
we want to avoid this overhead of the

00:28:48.300 --> 00:28:51.110
conversation between the two objects.

00:28:51.220 --> 00:28:55.730
So what we do is we introduce an
editing context on the client side.

00:28:55.860 --> 00:28:56.200
Okay?

00:28:56.570 --> 00:29:00.000
Now the reason that we can do this, well,
there are two fundamental

00:29:00.000 --> 00:29:01.000
reasons that we can do this.

00:29:01.120 --> 00:29:07.940
First of all, from the ground up, again,
we have this understanding that objects

00:29:08.520 --> 00:29:11.910
have data that changes and will persist.

00:29:12.140 --> 00:29:15.430
So from the ground up,
we know that we're going to be editing

00:29:15.430 --> 00:29:18.930
objects and we're going to want to
push those changes to an object store.

00:29:19.100 --> 00:29:19.590
Okay?

00:29:19.720 --> 00:29:21.980
So what happens here is that
the object store is just on

00:29:22.070 --> 00:29:23.550
the other side of the network.

00:29:23.590 --> 00:29:23.910
All right?

00:29:24.020 --> 00:29:27.130
But all the optimization is
performed locally so that the

00:29:27.130 --> 00:29:30.940
amount of communication back and
forth when rendering those changes

00:29:31.040 --> 00:29:34.060
back to the server and perhaps
or perhaps not to the database,

00:29:34.170 --> 00:29:38.000
that amount of communication
is kept to an absolute minimum.

00:29:38.010 --> 00:29:40.370
So there's an editing
context on the client side.

00:29:40.610 --> 00:29:45.230
There are editing contexts in the direct
to Java client applications that you saw.

00:29:45.330 --> 00:29:48.310
We have an object on the server side.

00:29:48.780 --> 00:29:51.590
and a proxy or another
rendition of the object.

00:29:51.630 --> 00:29:56.380
It's actually another edition of
the object on the client side.

00:29:56.410 --> 00:29:59.030
And as far as the client
editing context is concerned,

00:29:59.030 --> 00:30:04.320
the editing context on the
server or more concretely,

00:30:04.370 --> 00:30:08.160
the distributed object store which
connects it to that editing context,

00:30:08.190 --> 00:30:10.080
is just another object store.

00:30:10.160 --> 00:30:14.090
So the editing context behaves
just as it would as if this

00:30:14.090 --> 00:30:16.470
was a single unified process.

00:30:18.060 --> 00:30:21.650
Keep network overhead to a minimum.

00:30:21.750 --> 00:30:25.700
Okay, and again,
you've got this fundamental need to

00:30:25.700 --> 00:30:27.820
balance the client and the server.

00:30:27.820 --> 00:30:31.180
How much logic do you put -- how much
logic do you leave on the server?

00:30:31.420 --> 00:30:33.660
How much do you transmit
down to the client?

00:30:33.750 --> 00:30:36.180
Again, with WebObjects,
you have complete control over that.

00:30:36.180 --> 00:30:39.790
As you should have -- if you saw,
you would have seen this morning,

00:30:39.930 --> 00:30:43.220
you can specify what class you
want to use on the client side.

00:30:43.370 --> 00:30:46.100
That class can have less data.

00:30:46.200 --> 00:30:48.030
It can be a much smaller object.

00:30:48.140 --> 00:30:52.580
It can have a whole lot of
client-side specific logic.

00:30:53.070 --> 00:30:55.620
But you have complete control
over that distribution.

00:30:55.760 --> 00:31:00.410
And that control over that
distribution is essential to

00:31:00.410 --> 00:31:05.200
creating scalable applications,
scalable distributed applications.

00:31:05.270 --> 00:31:10.720
Okay, so that's a gloss on
WebObjects versus EJB.

00:31:11.080 --> 00:31:14.320
Now I'd like to talk very
briefly about what our plans

00:31:14.390 --> 00:31:16.390
are for WebObjects and EJB.

00:31:16.500 --> 00:31:20.680
Our first goal,
our first and foremost goal

00:31:20.680 --> 00:31:23.070
is to create a container.

00:31:23.300 --> 00:31:46.900
[Transcript missing]

00:31:47.430 --> 00:31:51.740
That way, if someone hands you
an Enterprise JavaBean,

00:31:51.740 --> 00:31:55.770
you'll be able to install it
in your WebObjects application

00:31:56.430 --> 00:31:59.970
and act as an EJB server.

00:32:00.020 --> 00:32:05.230
So, to clients of that EJB,
you'll be indistinguishable

00:32:05.780 --> 00:32:08.070
from any other EJB server.

00:32:08.500 --> 00:32:21.200
[Transcript missing]

00:32:21.950 --> 00:32:28.180
is making it possible to
define one's business objects

00:32:28.180 --> 00:32:31.600
in terms of our paradigm,
in terms of our contract between

00:32:31.920 --> 00:32:36.170
enterprise object and editing context.

00:32:36.700 --> 00:32:42.300
and then expose that object,
that Enterprise object, as an EJB.

00:32:42.440 --> 00:32:47.440
So the container will think it's
manipulating an Enterprise JavaBean,

00:32:47.540 --> 00:32:51.430
but in fact this Enterprise JavaBean
will be implemented in terms

00:32:51.430 --> 00:32:56.470
of WebObjects and our contract,
so it will have all the power

00:32:56.890 --> 00:33:01.120
and simplicity of our contract,
but appear to the

00:33:01.370 --> 00:33:03.350
outside world as an EJB.

00:33:03.900 --> 00:33:05.800
This is where things get much
more interesting because,

00:33:05.800 --> 00:33:09.630
for example, if one has implemented a lot
of custom logic in classes

00:33:09.730 --> 00:33:13.940
that are Enterprise objects,
with the flick of a switch,

00:33:14.070 --> 00:33:18.800
you'll be able to expose them to the
outside world as Enterprise JavaBeans.

00:33:19.080 --> 00:33:23.050
This is very important in shops
where there are several WebObject

00:33:23.050 --> 00:33:27.840
zealots and a bunch of people down
the hall in accounting who are using

00:33:28.250 --> 00:33:31.800
some EJB server and wonder why these
guys are doing something different.

00:33:31.800 --> 00:33:36.800
To the outside world,
it'll all look like EJB.

00:33:38.370 --> 00:33:43.540
Okay, and then beyond that, well,
when you look at this closely though,

00:33:43.590 --> 00:33:49.020
because of the tight link between an
Enterprise Object and an editing context,

00:33:49.060 --> 00:33:53.410
you can't really make an
Enterprise Object seem like an

00:33:53.470 --> 00:33:57.050
Enterprise JavaBean without embedding

00:33:57.470 --> 00:34:02.370
and editing context and enough of
WebObjects logic and WebObjects

00:34:02.370 --> 00:34:04.400
contract inside the bean.

00:34:04.870 --> 00:34:12.400
Well, once you've done this though,
there's really no need for a WebObjects

00:34:12.400 --> 00:34:15.870
application to act as a server.

00:34:15.960 --> 00:34:18.500
This is one of the huge
benefits that we're going to

00:34:18.500 --> 00:34:20.350
see from going to pure Java.

00:34:20.630 --> 00:34:22.330
This is all pure Java, right?

00:34:22.460 --> 00:34:26.400
So it doesn't really
matter where it's running.

00:34:26.400 --> 00:34:31.310
So we'll be able to
essentially take our container,

00:34:32.860 --> 00:34:36.500
Rip it out,
throw this Enterprise JavaBean

00:34:36.550 --> 00:34:40.720
into someone else's container,
any other vendor's container,

00:34:40.810 --> 00:34:44.260
and have it execute just as if it
was something they had developed

00:34:44.840 --> 00:34:48.800
or something that was running
in a WebObjects application.

00:34:48.920 --> 00:34:53.160
So this represents a very interesting
opportunity for our technology because

00:34:53.730 --> 00:34:58.230
this interface's contract between the
Enterprise JavaBean and the container

00:34:58.530 --> 00:35:00.800
will be something of a Trojan horse.

00:35:00.800 --> 00:35:03.990
You're suddenly going to find
our technologies running in

00:35:03.990 --> 00:35:07.800
foreign platforms in ways that
they never could have previously.

00:35:07.800 --> 00:35:10.790
So that's a very interesting possibility.

00:35:10.790 --> 00:35:14.930
There's some obvious
technical complications,

00:35:15.120 --> 00:35:17.900
but we've already gone a long
way towards resolving these in

00:35:17.900 --> 00:35:19.790
implementing direct-to-Java client.

00:35:19.800 --> 00:35:23.800
The client side is not a
traditional WebObjects application.

00:35:23.800 --> 00:35:26.800
It's a Java application or Java applet.

00:35:26.800 --> 00:35:28.780
So we've resolved some of
the technical mechanics.

00:35:28.800 --> 00:35:32.750
There are also obviously licensing
issues and marketing issues,

00:35:32.750 --> 00:35:35.750
but this is something
that has great potential.

00:35:36.170 --> 00:35:40.010
Okay,
so our goals are to provide a container,

00:35:40.080 --> 00:35:42.490
a very basic container.

00:35:44.020 --> 00:35:47.910
Expose Enterprise Objects
as Entity Beans.

00:35:47.910 --> 00:35:50.870
Now I'm emphasizing entity beans because

00:35:51.080 --> 00:35:54.240
They map pretty well
to Enterprise objects.

00:35:54.240 --> 00:35:57.270
For example,
if you have an entity in modeler,

00:35:57.270 --> 00:36:01.190
chances are that that will map
pretty well to an entity bean.

00:36:01.280 --> 00:36:02.960
One has to be very careful.

00:36:03.350 --> 00:36:09.030
Because of the distribution model in EJB,
you're going to find that you're

00:36:09.030 --> 00:36:11.410
incurring a lot of overhead
whenever you invoke methods.

00:36:11.410 --> 00:36:15.200
So it's not quite like it
is for an Enterprise object.

00:36:15.200 --> 00:36:19.870
So even though with the check of a
radio box you're going to be able to

00:36:20.400 --> 00:36:24.070
render an entity as an entity bean,
you're probably going to want to

00:36:24.070 --> 00:36:26.690
go in subsequently and tune it with
the understanding that you don't

00:36:26.780 --> 00:36:30.720
necessarily want to expose a lot of
logic that comes natural in a single

00:36:30.720 --> 00:36:33.200
process or our distribution model.

00:36:33.200 --> 00:36:39.930
But it's a great way
to get off the ground.

00:36:40.430 --> 00:36:46.770
And finally, we want to generate
exportable WebObjects EJBs.

00:36:46.770 --> 00:36:52.540
So, be able to create a system with
logic in WebObjects using our tools,

00:36:52.540 --> 00:36:56.490
our patented object relational mapping,
all the goodies that Editing

00:36:56.580 --> 00:36:59.520
Context takes care of for you,
and then export that

00:36:59.520 --> 00:37:01.230
into some other vendor.

00:37:01.410 --> 00:37:04.140
If a company has a deployment
requirement that they use some

00:37:04.140 --> 00:37:06.300
other vendor's technology,
no problem.

00:37:06.300 --> 00:37:10.630
We'll be able to take our beans,
put them in there, and deploy.

00:37:11.320 --> 00:37:14.890
Alright,
that's really about all I had planned,

00:37:15.040 --> 00:37:18.270
so now I'd like to turn it over to Q&A.
WEBVTT

00:00:09.950 --> 00:00:10.900
Good morning!

00:00:10.900 --> 00:00:11.500
Alright.

00:00:11.630 --> 00:00:13.980
Wow, the home stretch, the last day.

00:00:14.230 --> 00:00:17.840
Well, as you can see, again,
I always keep saying this, but Mac OS X,

00:00:17.840 --> 00:00:19.270
Carbon, the theme of this week.

00:00:19.450 --> 00:00:23.020
We are so excited about how
much progress we've made,

00:00:23.170 --> 00:00:25.650
and how much progress we've
made helping you get on the

00:00:25.740 --> 00:00:27.400
platform as fast as possible.

00:00:27.610 --> 00:00:31.450
This session about Carbon Enhancements
II to the High Level Toolbox is going

00:00:31.590 --> 00:00:35.160
to go further into depth about ways
that your process of carbonizing

00:00:35.160 --> 00:00:36.890
your application is affected.

00:00:36.900 --> 00:00:38.670
It's really good stuff to know,
so without delay,

00:00:38.680 --> 00:00:41.370
I'm just going to bring up Pete Gontier
from the High Level Toolbox team.

00:00:41.410 --> 00:00:43.170
Please welcome Pete.

00:00:44.940 --> 00:00:49.440
So, I hope you had a chance to check out
the Carbon Enhancements I session.

00:00:49.440 --> 00:00:52.700
This is going to be a session
very similar in theme.

00:00:52.800 --> 00:00:56.800
We've been doing so much work on,
not only on Aqua,

00:00:56.800 --> 00:01:00.060
but on the toolbox in general,
that we had to do two

00:01:00.060 --> 00:01:01.800
sessions to fit it all in.

00:01:01.800 --> 00:01:04.800
This session will have basically the
same structure as the last session.

00:01:04.800 --> 00:01:08.800
We're going to do a big section
on architectural changes,

00:01:08.940 --> 00:01:13.340
which are things that you pretty much
have to do in order to come up on Carbon.

00:01:13.560 --> 00:01:15.830
And the ones that we'll talk
about in this session are the

00:01:15.880 --> 00:01:19.770
fact that you can no longer draw
directly the Window Manager Port,

00:01:20.420 --> 00:01:25.410
There's a small change to the way control
indicator action procedures are called.

00:01:26.350 --> 00:01:31.620
There are some changes you will need to
make to control and window definitions.

00:01:31.620 --> 00:01:32.720
Not anything too radical.

00:01:33.820 --> 00:01:40.060
There is a change in the way you
need to instantiate custom control

00:01:40.060 --> 00:01:42.110
window and other definitions.

00:01:42.820 --> 00:01:46.480
And then of course there are some new
dialog item list accessors that you'll

00:01:46.570 --> 00:01:49.290
want to use because of dialog opacity.

00:01:50.630 --> 00:01:53.570
Then we'll move on to the stuff
that you don't have to do,

00:01:53.650 --> 00:01:56.940
but the stuff that you'll probably want
to do as soon as you hear about it.

00:01:57.070 --> 00:02:01.030
There's Unicode support
in the toolbox everywhere.

00:02:01.220 --> 00:02:04.770
We've added drag and drop
support for controls.

00:02:05.630 --> 00:02:11.870
Then we've added the usual collection
of new Control Manager APIs.

00:02:13.630 --> 00:02:15.650
And then finally,
we'll talk a little bit about

00:02:15.650 --> 00:02:17.150
Carbon Enhancments in the Toolbox.

00:02:17.270 --> 00:02:19.170
Not too much,
because there were two whole

00:02:19.300 --> 00:02:22.740
sessions on Carbon events,
Sessions 121 and 122,

00:02:22.740 --> 00:02:26.900
and those are already passed,
but I wanted to mention them

00:02:26.900 --> 00:02:30.930
just to emphasize the fact that
if you get a chance to pull

00:02:31.130 --> 00:02:35.700
down webcasts or videotapes,
you definitely should

00:02:35.700 --> 00:02:39.220
prioritize 121 and 122,
because Carbon events

00:02:39.220 --> 00:02:39.220
are really important.

00:02:41.110 --> 00:02:45.000
So let's talk about the
Window Manager Port.

00:02:45.220 --> 00:02:49.400
Mac OS X is, as you've heard,
a preemptive operating system,

00:02:49.490 --> 00:02:54.440
and the screen buffer is basically
a huge global shared resource.

00:02:54.520 --> 00:02:57.770
And for performance reasons,
we have not yet solved the

00:02:58.090 --> 00:03:02.840
problem of letting you draw
to it in the general case.

00:03:02.900 --> 00:03:05.610
It would be a mess if we didn't
control the access to it,

00:03:05.700 --> 00:03:08.670
and controlling the access to it is
actually more difficult than it sounds.

00:03:08.740 --> 00:03:12.610
So we're still working on that issue.

00:03:13.950 --> 00:03:19.240
Now you may find through experimentation
that you actually can kind of sort

00:03:19.240 --> 00:03:23.660
of draw to what seems to be the
Window Manager Port under DP4.

00:03:23.660 --> 00:03:27.980
And hopefully that will only happen
by accident because you don't,

00:03:28.100 --> 00:03:32.830
definitely don't want to have
code that expects to draw to the

00:03:32.910 --> 00:03:38.270
Window Manager Port on purpose
because soon after DP4 we're going

00:03:38.320 --> 00:03:39.430
to be making some changes that
will make it basically impossible.

00:03:40.270 --> 00:03:43.120
But the news isn't all bad.

00:03:43.140 --> 00:03:47.700
We have provided a few replacement
services that cover the common cases

00:03:47.700 --> 00:03:52.610
that most people needed to draw
to the Window Manager Port for.

00:03:54.020 --> 00:03:56.900
The first of those cases
is custom window dragging.

00:03:57.120 --> 00:04:00.370
Instead of rolling your
own window dragging code,

00:04:00.380 --> 00:04:04.260
we really need you to use the
DragWindow system call now.

00:04:04.460 --> 00:04:08.720
It's basically,
not only do you get live dragging,

00:04:08.970 --> 00:04:16.810
which is a nice, whizzy effect for users,
but it's the, excuse me,

00:04:17.010 --> 00:04:20.240
DragWindow is now sufficiently
customizable that you really shouldn't

00:04:20.240 --> 00:04:25.320
have any problem figuring out how to
get the constraining and gridding and

00:04:25.320 --> 00:04:28.020
the other custom behavior that you need.

00:04:28.260 --> 00:04:31.390
And this is part of the
whole Carbon Events thing.

00:04:31.880 --> 00:04:34.220
Basically,
we send you Carbon Events during

00:04:34.220 --> 00:04:37.860
window dragging,
and you can decide what to do with them.

00:04:37.890 --> 00:04:42.900
We send you such things as the
rectangle the window would be

00:04:42.900 --> 00:04:46.400
in if you were to not change it,
and then you have the choice

00:04:46.400 --> 00:04:49.040
of changing it or not,
so that you get the little

00:04:49.040 --> 00:04:51.020
gridding effect that you need.

00:04:51.020 --> 00:04:56.880
I believe in the Carbon Events session
there was a demo where we showed sort of

00:04:56.880 --> 00:05:00.590
docking behavior during window dragging,
where windows were docked

00:05:00.590 --> 00:05:02.720
against the edge of a screen
and docked against each other.

00:05:02.860 --> 00:05:08.680
And I guess I should also point out
that dragWindow now supports layering

00:05:08.980 --> 00:05:13.710
in the sense that the outline that's
dragged around the-- excuse me,

00:05:13.730 --> 00:05:18.690
the window that's dragged around the
screen is clipped according to the

00:05:18.690 --> 00:05:22.660
windows that are actually in front of it,
so you don't have to override

00:05:22.660 --> 00:05:25.790
dragWindow just to make it look decent.

00:05:27.780 --> 00:05:33.940
The next case is Grow Window.

00:05:33.960 --> 00:05:37.300
Basically, if you use the system's
Grow Window service,

00:05:37.360 --> 00:05:42.920
that enables us to provide live growing,
which is basically the window contents

00:05:42.920 --> 00:05:46.080
redraw as the user grows the window.

00:05:46.190 --> 00:05:51.230
So if the window becomes bigger,
the image in the window

00:05:51.760 --> 00:05:56.190
can be drawn by the system,
more or less interactively.

00:05:56.260 --> 00:05:59.700
And of course,
there are the usual ways to

00:05:59.700 --> 00:06:05.710
customize window growing,
again, mostly based on Carbon events.

00:06:06.080 --> 00:06:11.590
There's one method you can use by
overwriting a window definition message,

00:06:11.590 --> 00:06:15.990
and that is, of course,
the get_grow_image_region message.

00:06:16.090 --> 00:06:19.160
And the reason we mention this,
even though it's not a

00:06:19.160 --> 00:06:25.040
Carbon Events sort of facility,
is that it's basically your only option

00:06:25.040 --> 00:06:29.290
if you need to do this for CarbonLib 102,
or 102 through 104, I guess I should say.

00:06:29.900 --> 00:06:39.000
[Transcript missing]

00:06:39.300 --> 00:06:42.030
And then of course the best
method would be to override the

00:06:42.270 --> 00:06:44.380
window size change Carbon event.

00:06:44.380 --> 00:06:48.060
And the difference there is that one
of these messages hands you a region

00:06:48.060 --> 00:06:50.190
and one of them hands you a rectangle.

00:06:50.260 --> 00:06:54.420
So if you really, really,
really need to change the visual

00:06:54.760 --> 00:06:58.570
appearance of the growing process,
then you're probably going to get

00:06:58.640 --> 00:07:00.200
stuck overriding the region version.

00:07:00.200 --> 00:07:06.040
But it's much better if you stick with
the rectangle version because I believe

00:07:06.040 --> 00:07:12.280
if you override the region version that
prevents us from doing the live growing.

00:07:14.980 --> 00:07:18.790
So some developers were
rolling their own dragging,

00:07:18.790 --> 00:07:21.930
and it would draw into
the Window Manager Port.

00:07:22.010 --> 00:07:25.540
And the primary reason they were
rolling their own dragging was that the

00:07:25.600 --> 00:07:27.900
drag manager wasn't versatile enough.

00:07:28.050 --> 00:07:34.510
So what we did was we added a function,
excuse me, an API to change an arbitrary

00:07:34.510 --> 00:07:39.770
drag reference so that you can
turn off the zoom back animation

00:07:39.770 --> 00:07:42.290
for an unsuccessful drag.

00:07:43.020 --> 00:07:45.640
And of course this API,
Change Drag Behaviors,

00:07:45.810 --> 00:07:49.790
can expand in the future for us to
add more flags that you can turn

00:07:49.800 --> 00:07:52.660
on or off on a drag-by-drag basis.

00:07:52.840 --> 00:07:56.710
And basically the way you
would use this facility is you

00:07:56.710 --> 00:07:59.630
would create a drag reference,
just like you would for any other

00:07:59.630 --> 00:08:04.570
interaction with the drag manager,
and turn off its zoom back animation,

00:08:04.570 --> 00:08:07.860
and then either add no flavors
and maintain all the state

00:08:07.860 --> 00:08:11.130
within your application,
or add some flavors that tell you what

00:08:11.130 --> 00:08:15.900
to do and mark them all sender-only
flavors so that you don't get windows

00:08:16.150 --> 00:08:21.740
in other applications highlighting it
as if they're going to accept the drag.

00:08:22.350 --> 00:08:27.970
And so, the way we sort of,
the usage scenario that we sort

00:08:28.100 --> 00:08:32.410
of entertained was people who
need to drag out of a window,

00:08:32.590 --> 00:08:36.180
some object out of a window,
and then let the user more or less

00:08:36.220 --> 00:08:40.260
drop it in the middle of nowhere
and have something appear there

00:08:40.260 --> 00:08:42.610
where there used to be nothing.

00:08:47.770 --> 00:08:53.200
So, the last scenario we have a good
explanation for is people who need

00:08:53.200 --> 00:08:55.690
to sample the pixels on the screen.

00:08:55.780 --> 00:09:03.240
And of course,
you can still sample pixels right

00:09:03.390 --> 00:09:05.490
out of your own windows because
we have a per window buffer

00:09:05.490 --> 00:09:05.490
that you'll be sampling out of.

00:09:05.800 --> 00:09:11.000
The problem case is sampling pixels
that are outside any of your windows.

00:09:12.430 --> 00:09:16.780
In order to work well with the
preemptive window manager that

00:09:16.780 --> 00:09:22.670
underlies the Carbon window manager,
we have a very window-centric outlook,

00:09:22.670 --> 00:09:26.310
and we're working on
ways to overcome that.

00:09:26.320 --> 00:09:34.310
But basically, let me think here.

00:09:37.730 --> 00:09:41.160
Basically,
what we think is going to happen is

00:09:41.160 --> 00:09:45.620
that there will probably never be
a platform independent way to peek

00:09:45.620 --> 00:09:47.880
at pixels outside of your windows.

00:09:47.960 --> 00:09:50.090
And I guess I'll talk a little bit
more about that on the next slide.

00:09:50.100 --> 00:09:53.390
But once again,
we have the caveat of there are

00:09:53.390 --> 00:09:58.020
things that work in DP4 that
you can discover on your own.

00:09:58.100 --> 00:10:01.260
And in this case,
you can create a port and then sort

00:10:01.360 --> 00:10:05.130
of look at its Pixmap handle and
sample pixels out of it that way.

00:10:05.340 --> 00:10:08.500
And that's one of those things that
very soon after DP4 we're going to

00:10:08.500 --> 00:10:11.290
change so that it doesn't work anymore.

00:10:11.660 --> 00:10:15.320
And then the final thing to keep in mind,
of course, is rather than grabbing

00:10:15.320 --> 00:10:19.330
video RAM directly,
you should definitely use copy

00:10:19.420 --> 00:10:21.450
bits for a number of reasons.

00:10:23.900 --> 00:10:29.790
So the plain old drawing case
is the most general case,

00:10:29.910 --> 00:10:35.360
and of course there's not a lot of
sort of semantic opportunity for us to

00:10:35.520 --> 00:10:42.030
provide other services when you consider
the problem in such a general way.

00:10:43.410 --> 00:10:46.780
Sometimes developers need to
draw directly to the screen,

00:10:46.780 --> 00:10:48.950
or sometimes developers
draw directly to the screen,

00:10:48.950 --> 00:10:51.290
just because they want to
take over the whole screen.

00:10:51.300 --> 00:10:54.770
And of course you can still do that,
but you've got to do a little work ahead

00:10:54.770 --> 00:10:56.300
of time in order to make that happen.

00:10:56.300 --> 00:11:02.160
The basic idea is to create a
window that covers the whole screen.

00:11:02.300 --> 00:11:07.510
And you can do that on your
own by hiding the menu bar,

00:11:07.670 --> 00:11:13.170
or you can do that by asking QuickTime or
GamesProcess to do it for you.

00:11:13.300 --> 00:11:16.800
And I sort of tend towards
asking QuickTime or GamesProcess

00:11:16.800 --> 00:11:20.980
to take care of it for you,
because they also know about things

00:11:20.980 --> 00:11:23.300
like hiding the control strip.

00:11:23.300 --> 00:11:28.300
And I imagine that eventually they'll
be wired up to hide the dock as well,

00:11:28.300 --> 00:11:32.000
so you don't have to worry
about all those extra details.

00:11:32.870 --> 00:11:37.360
Um, and then of course the obvious
alternative is to start thinking about,

00:11:37.360 --> 00:11:41.350
uh, ways to provide the same
functionality that your application

00:11:41.440 --> 00:11:44.840
was providing by drawing directly
to the screen in some other way.

00:11:44.890 --> 00:11:48.110
And we realize that probably
involves thinking about a

00:11:48.380 --> 00:11:49.830
little bit of a redesign.

00:11:49.890 --> 00:11:51.420
Um...

00:11:52.820 --> 00:11:56.220
But there's not really an
alternative we have to present

00:11:56.220 --> 00:11:58.160
today to solve that problem.

00:11:58.330 --> 00:12:01.690
And as I said,
there may eventually be some kind of

00:12:01.740 --> 00:12:04.400
platform-dependent way to do this.

00:12:04.400 --> 00:12:07.880
Right now there's not,
but we expect there probably won't

00:12:07.960 --> 00:12:10.100
be a platform-independent way.

00:12:10.540 --> 00:12:14.850
We're still looking at this problem,
but we're not able to commit

00:12:14.850 --> 00:12:16.890
to anything right now.

00:12:18.800 --> 00:12:23.450
So, control indicator action procedures
have changed a little bit,

00:12:23.450 --> 00:12:25.410
and it all has to do with performance.

00:12:25.570 --> 00:12:28.260
It used to be the case that the
control manager would call your

00:12:28.350 --> 00:12:32.700
control indicator action procedure
basically as fast as it could.

00:12:32.730 --> 00:12:38.100
And so if your proc needed idle time,
all you had to do was wait for

00:12:38.100 --> 00:12:43.100
some of these excessive calls,
and call movies task,

00:12:43.100 --> 00:12:47.560
or whatever else it was that
you needed to call at idle time.

00:12:47.920 --> 00:12:53.200
And in order to provide more
blocking behavior to allow other

00:12:53.310 --> 00:12:58.340
processes to have more processor,
the Control Manager will now only call

00:12:58.340 --> 00:13:01.510
your Control Indicator Action proc
when the mouse actually moves.

00:13:01.810 --> 00:13:07.260
So if you need idle time at this time,
you should install a timer.

00:13:07.260 --> 00:13:10.820
And again, the Carbon Events session
went into detail about timers.

00:13:10.950 --> 00:13:14.360
But basically,
a timer is a callback that gets called

00:13:14.360 --> 00:13:16.720
at various times by the toolbox.

00:13:17.270 --> 00:13:20.860
And one of those times is during the,
during control drag tracking,

00:13:20.970 --> 00:13:25.070
or I should say, control tracking.

00:13:25.460 --> 00:13:28.870
And you can pretty much do whatever
you like inside that timer.

00:13:29.020 --> 00:13:32.340
It's not a sort of a time
manager sort of situation where

00:13:32.340 --> 00:13:34.650
you're at quasi-interrupt time.

00:13:34.790 --> 00:13:39.540
So definitely look at adopting
timers in order to get idle

00:13:39.540 --> 00:13:42.480
time during control tracking.

00:13:43.360 --> 00:13:48.130
So, some of the definition functions in
the toolbox are changing a little bit.

00:13:48.190 --> 00:13:50.950
For the most part,
you're probably not going to

00:13:51.060 --> 00:13:53.300
notice a whole lot of difference.

00:13:53.300 --> 00:13:57.300
We've done a fair amount of work
building compatibility shims

00:13:57.300 --> 00:14:00.510
into the Control Manager and the
Window Manager so that old control

00:14:00.590 --> 00:14:04.420
definitions continue to work,
even though, in general,

00:14:04.420 --> 00:14:08.060
definitions are Carbon event driven now.

00:14:08.060 --> 00:14:12.770
You can now write a Carbon event
driven control definition

00:14:12.770 --> 00:14:17.660
or a window definition,
but you don't absolutely have to.

00:14:17.700 --> 00:14:23.100
And, of course, you can't if you need to
ship onto CarbonLib 104.

00:14:23.140 --> 00:14:26.700
Control definitions now
take an initialized message,

00:14:26.700 --> 00:14:30.160
and the initialized message,
one of the parameters to

00:14:30.270 --> 00:14:34.240
the initialized message is a
Collection Manager collection.

00:14:35.030 --> 00:14:38.710
And this sort of replaces all
of the nasty overriding that you

00:14:38.710 --> 00:14:40.450
might have had to do in the past.

00:14:40.480 --> 00:14:45.930
You can basically associate data with
tags in a collection manager collection,

00:14:46.010 --> 00:14:49.610
and then the control definition can
pull the data out of that collection,

00:14:49.610 --> 00:14:52.580
and the tags will actually make
sense instead of being the minimum

00:14:52.580 --> 00:14:55.900
and the maximum and the refcon,
and they really mean something else.

00:14:55.900 --> 00:15:00.140
Control initialization messages
also can return an OS status

00:15:00.140 --> 00:15:04.900
so that if something goes wrong
during the creation of the control,

00:15:04.900 --> 00:15:09.940
the definition can actually
report what went wrong instead

00:15:09.940 --> 00:15:12.360
of just mindlessly fail.

00:15:12.400 --> 00:15:16.640
And this will allow, ultimately,
the application to figure out, okay,

00:15:16.640 --> 00:15:20.900
not only did something go wrong,
but here's a hint as to what went wrong,

00:15:20.900 --> 00:15:23.720
so maybe you can work around it
or present an error to the user

00:15:23.720 --> 00:15:25.370
and let the user work around it.

00:15:28.350 --> 00:15:33.860
The region calculation messages for
control definitions have a long,

00:15:33.860 --> 00:15:35.130
nasty history.

00:15:35.580 --> 00:15:40.280
For a number of years they were
what we would call 32-bit dirty,

00:15:40.290 --> 00:15:44.780
in that they sort of overrode
some pointer values and set

00:15:44.780 --> 00:15:46.800
some flags in the high bits.

00:15:46.990 --> 00:15:52.200
We used to, for compatibility,
preserve support for those

00:15:52.200 --> 00:15:56.140
messages in certain cases,
but in Carbon it just doesn't

00:15:56.200 --> 00:15:57.350
make any sense anymore.

00:15:57.500 --> 00:16:02.270
So we've gotten rid of those
control region messages.

00:16:02.300 --> 00:16:06.510
What we'd like you to respond to instead
now is a message called "Get Region,"

00:16:06.700 --> 00:16:08.520
which has been around for a while.

00:16:08.600 --> 00:16:14.100
It's basically a query to you
to provide a particular region,

00:16:14.100 --> 00:16:16.600
and then the control manager decides
how to associate that region.

00:16:16.600 --> 00:16:19.110
that region with your control.

00:16:19.390 --> 00:16:22.590
With window definitions,
the story is pretty much the same.

00:16:22.640 --> 00:16:26.010
We have a Carbon event driven
model for window definitions with a

00:16:26.010 --> 00:16:28.300
compatibility shim for old messages.

00:16:28.420 --> 00:16:31.880
And there are some changes
to the old messages as well.

00:16:32.210 --> 00:16:35.480
There's also,
there's a window message get region,

00:16:35.480 --> 00:16:38.300
which is, works pretty much the same.

00:16:38.300 --> 00:16:41.440
We ask you for a specific part of
the window and you return to us a

00:16:41.600 --> 00:16:45.260
region and then we decide how to
associate that region with the window.

00:16:45.370 --> 00:16:49.170
WCalcRegions is pretty
much gone away because it,

00:16:49.170 --> 00:16:53.860
well, it was not only not,
it was not only insufficiently versatile,

00:16:54.440 --> 00:16:58.800
but basically required you to poke
around inside the window record.

00:16:58.800 --> 00:17:02.080
And since we want the
window record to be opaque,

00:17:02.080 --> 00:17:05.450
even to window definitions,
that simply wasn't a

00:17:05.450 --> 00:17:07.420
workable model anymore.

00:17:08.690 --> 00:17:10.980
And then of course, as I said,
there's no drawing into

00:17:10.980 --> 00:17:11.830
the Window Manager Port.

00:17:11.950 --> 00:17:13.950
You would expect,
if anything would draw directly

00:17:13.950 --> 00:17:16.550
into the Window Manager Port,
it would be a window definition.

00:17:16.600 --> 00:17:20.100
But we can't even allow
it for window definitions.

00:17:20.100 --> 00:17:22.500
So what we've done is we've
made sure that when your

00:17:22.500 --> 00:17:25.690
window definition is called,
the current port is already set

00:17:25.690 --> 00:17:27.200
up to something it can draw into.

00:17:27.210 --> 00:17:30.500
So you don't need to explicitly
get the Window Manager Port.

00:17:30.500 --> 00:17:34.320
You can just assume that the port
is set correctly when you're called.

00:17:35.080 --> 00:17:40.330
So even if you don't write
a custom control definition,

00:17:40.380 --> 00:17:43.380
you still often need to instantiate them.

00:17:44.020 --> 00:17:50.320
And basically, we've added some functions
which allow you to more easily

00:17:50.800 --> 00:17:54.640
create custom toolbox objects.

00:17:54.740 --> 00:18:00.400
And they're basically analogs between
the old classic APIs and the new APIs.

00:18:00.490 --> 00:18:06.340
You're not required to use
the new APIs in all cases.

00:18:06.400 --> 00:18:09.290
The old APIs are still there,
but for the custom definition case,

00:18:09.380 --> 00:18:12.110
you probably want to use the new APIs.

00:18:12.800 --> 00:19:35.900
[Transcript missing]

00:19:36.690 --> 00:19:41.820
And it is definitely the case that
putting control definitions and resources

00:19:41.940 --> 00:19:44.040
is no longer the right thing to do.

00:19:44.160 --> 00:19:47.990
However, that doesn't mean you have to
throw out all of your client code.

00:19:48.720 --> 00:19:55.900
Basically, we have a map which maps your
old resource IDs ultimately to

00:19:55.900 --> 00:19:58.760
control definition functions.

00:19:58.760 --> 00:20:02.190
So if you have a CNTL resource,
for example,

00:20:02.440 --> 00:20:06.700
which specifies that control definition,
excuse me,

00:20:06.700 --> 00:20:15.200
which specifies control proc ID 2064,
that ultimately maps to control

00:20:15.840 --> 00:20:18.640
definition resource ID of 129.

00:20:19.990 --> 00:20:24.780
And then the Control Manager has a map
that knows to map 129 to your function,

00:20:24.780 --> 00:20:27.090
or actually to your control def spec.

00:20:27.170 --> 00:20:31.260
And I call this a sort of a virtual
resource ID because the CNTL resource

00:20:31.830 --> 00:20:37.360
thinks there's a control definition
which has a certain resource ID,

00:20:37.420 --> 00:20:40.750
but in fact that control definition
doesn't exist as a resource,

00:20:40.750 --> 00:20:42.260
it only exists as a map entry.

00:20:42.320 --> 00:20:45.530
And the Control Manager knows
that when somebody asks for that

00:20:45.530 --> 00:20:48.220
control definition resource ID,
It should relate it back

00:20:48.360 --> 00:20:52.020
to your control def spec,
which you registered earlier.

00:20:52.290 --> 00:20:58.590
So here's the function you use
to register a control definition.

00:20:58.590 --> 00:20:58.590
Excuse me.

00:20:59.550 --> 00:21:01.760
Yes, okay, at the bottom of the screen.

00:21:01.760 --> 00:21:03.370
Let's just start with the beginning.

00:21:03.440 --> 00:21:05.540
Basically,
when you register a control definition,

00:21:05.540 --> 00:21:10.020
you not only provide a control def spec,
and a C def, or I should say a virtual

00:21:10.090 --> 00:21:13.970
C def resource ID,
but you also provide a callback which

00:21:13.970 --> 00:21:20.690
allows you to translate the fields that
were in the CNTL resource into either,

00:21:20.740 --> 00:21:25.660
excuse me, into a collection so that
the control definition,

00:21:25.660 --> 00:21:29.920
when its initialized message gets called,
it can extract parameters from the

00:21:29.920 --> 00:21:33.600
collection in a tagged format instead
of knowing about all those weird,

00:21:33.600 --> 00:21:38.270
overridden,
semantically confusing parameters

00:21:38.280 --> 00:21:40.180
that you used to have to deal with.

00:21:40.210 --> 00:21:43.640
And that mechanism is obviously
still needs to be there because

00:21:43.640 --> 00:21:46.980
CNTL resources are in a certain
format and they have certain fields,

00:21:46.980 --> 00:21:50.310
and we can't really make that go away.

00:21:50.470 --> 00:21:57.090
So at some level,
you do have to know that, for example,

00:21:58.160 --> 00:22:01.140
maximum and minimum fields
really mean something else.

00:22:01.140 --> 00:22:05.240
But at least your control definition
doesn't really have to know.

00:22:05.280 --> 00:22:08.460
And if you play your cards right,
your client code, for the most part,

00:22:08.520 --> 00:22:10.410
doesn't have to know.

00:22:11.480 --> 00:22:22.660
So yet another instance in the
series of toolbox object opacity

00:22:22.660 --> 00:22:22.660
is that dialog item lists are,
of course, opaque.

00:22:23.500 --> 00:22:27.230
And when we analyzed what
kind of problems that was

00:22:27.230 --> 00:22:30.930
going to cause developers,
we found a couple of cases where

00:22:31.090 --> 00:22:35.360
developers were actually pulling
individual items out of a dialog

00:22:35.390 --> 00:22:39.060
item list or inserting new
ones into a dialog item list.

00:22:39.150 --> 00:22:45.060
And so we've got now two APIs which
allow you to do this in a controlled,

00:22:45.480 --> 00:22:46.980
supportable way.

00:22:47.530 --> 00:22:53.050
And I guess the only sort of
non-obvious part of these APIs is

00:22:53.050 --> 00:22:57.400
the second dialog item index
parameter to remove dialog items.

00:22:57.430 --> 00:23:00.940
You're not forced to just remove one,
you can remove two or three in the

00:23:00.940 --> 00:23:03.300
middle of the list if you feel like it.

00:23:03.400 --> 00:23:06.650
Now we're getting into the section
of stuff that you may want to

00:23:06.650 --> 00:23:09.760
do once you find out about it.

00:23:09.950 --> 00:23:13.370
Basically, all the toolbox objects
now support UniCode,

00:23:13.370 --> 00:23:18.150
and they support it not only in the APIs,
but also internally.

00:23:18.550 --> 00:23:22.120
We still have the Pascal String APIs,
but basically what they do

00:23:22.120 --> 00:23:26.990
is create a CF StringRef,
which is the object in core foundation

00:23:26.990 --> 00:23:31.900
which supports UniCode as well as
several other encodings internally.

00:23:31.960 --> 00:23:37.690
And then we, from there on,
the string stays CFString forever.

00:23:38.270 --> 00:23:41.630
If you use CFString APIs,
you can pretty much be guaranteed

00:23:41.770 --> 00:23:45.520
that if you-- the string that you
set into a control will come back

00:23:45.600 --> 00:23:47.910
with 100% round-trip fidelity.

00:23:48.240 --> 00:23:51.550
If you use the Pascal String APIs,
then we may or may not be

00:23:51.590 --> 00:23:54.250
forced to do some conversion,
and you might lose a

00:23:54.310 --> 00:23:55.260
little bit of fidelity.

00:23:55.260 --> 00:24:00.200
So that's one reason you might
want to adopt the CFString APIs.

00:24:00.240 --> 00:24:04.560
There's no, you know,
there's no sort of--

00:24:05.000 --> 00:24:07.570
There's no requirement
that you adopt them,

00:24:07.570 --> 00:24:17.280
but over the long run it's
probably in your best interest.

00:24:18.240 --> 00:24:21.510
Internally,
we're working with CFString completely,

00:24:21.530 --> 00:24:25.650
so we're not just sort of paying
lip service to the Unicode thing.

00:24:25.660 --> 00:24:30.320
It's really down into
the core of the toolbox.

00:24:31.010 --> 00:24:35.380
Finally, I want to talk about
CFStringRef semantics just

00:24:35.380 --> 00:24:37.200
a little bit in brief.

00:24:37.420 --> 00:24:43.000
Core Foundation introduces this new
concept of retain-release semantics,

00:24:43.090 --> 00:24:45.650
and we of course support those.

00:24:45.790 --> 00:24:51.510
And what that means is, in some cases,
we will not actually make a copy of

00:24:51.510 --> 00:24:53.510
the string from the toolbox object.

00:24:53.640 --> 00:24:57.810
We may, effectively,
increment the ref count of

00:24:58.090 --> 00:25:02.700
that string instead of making
an actual byte copy of it.

00:25:02.790 --> 00:25:06.500
And basically, you don't need to worry
too much about that,

00:25:06.680 --> 00:25:10.540
except that we wanted to bring
it up to point out that that is,

00:25:10.630 --> 00:25:13.100
in some cases, will be a performance win.

00:25:13.160 --> 00:25:17.030
And you should probably read up
on CFStringRef and retain-release

00:25:17.060 --> 00:25:19.530
semantics to understand that fully.

00:25:20.470 --> 00:25:27.620
Now, in appearance, I think in Mac OS 8,
we introduced a new API to

00:25:27.620 --> 00:25:30.700
deactivate a control.

00:25:32.490 --> 00:25:35.850
But usually when developers
need to disable a control,

00:25:35.850 --> 00:25:39.760
they resort to highlight control,
which is another one of these

00:25:39.810 --> 00:25:42.560
functions with overloaded semantics.

00:25:42.560 --> 00:25:46.080
So now we've introduced a function
called disable-- an explicit

00:25:46.130 --> 00:25:48.010
function we call disable control.

00:25:48.900 --> 00:25:54.370
And not only is there sort of a semantic
cleanup associated with this control,

00:25:54.370 --> 00:25:57.460
but it allows us to do some
things in Aqua which we weren't

00:25:57.460 --> 00:25:59.100
really able to do before.

00:25:59.800 --> 00:26:03.370
Basically under Platinum,
a disabled control looks pretty

00:26:03.370 --> 00:26:06.340
much like a deactivated control,
but under Aqua,

00:26:06.520 --> 00:26:07.630
they look a little bit different.

00:26:07.700 --> 00:26:12.250
I don't know if you can read,
maybe you can, the labels under each

00:26:12.350 --> 00:26:14.100
of these button images.

00:26:14.220 --> 00:26:18.200
So I'll just read them
out so we're clear.

00:26:18.630 --> 00:26:23.050
The one on the far left is active.

00:26:23.670 --> 00:26:26.170
Meaning it's basically in the
frontmost window and the user

00:26:26.170 --> 00:26:29.260
expects to interact with,
excuse me, it's in a window that the

00:26:29.260 --> 00:26:33.000
user expects to interact with,
but it's disabled.

00:26:33.300 --> 00:26:37.060
The second one over from the
left is active and enabled,

00:26:37.090 --> 00:26:40.490
so it's not only in a window the
user expects to interact with,

00:26:40.700 --> 00:26:44.300
but that button actually
responds to clicks.

00:26:44.840 --> 00:26:47.250
The third one over from
the left is inactive,

00:26:47.250 --> 00:26:50.130
meaning it's probably
in a background window,

00:26:50.130 --> 00:26:55.320
and it's disabled,
so it's sort of the most colorless.

00:26:55.960 --> 00:27:00.150
And then the one on the right
is inactive and enabled,

00:27:00.220 --> 00:27:02.450
and that just means it's
in some background window,

00:27:02.450 --> 00:27:06.200
but if it were in a foreground window,
it would be clickable.

00:27:06.330 --> 00:27:12.310
Now, we've added some contextual menu
manager support to controls.

00:27:12.910 --> 00:27:17.580
And basically that support is intended
to be provided by the control definition.

00:27:17.620 --> 00:27:20.030
So the control definition is
in the best position to know

00:27:20.640 --> 00:27:23.850
what contextual menu to provide.

00:27:23.950 --> 00:27:27.870
So we let it provide one.

00:27:27.870 --> 00:27:27.870
And basically,

00:27:28.830 --> 00:27:31.980
The way that the application level
client code works is you call

00:27:32.050 --> 00:27:36.170
handle control contextual menu
click and it will query the control

00:27:36.170 --> 00:27:40.690
definition to find out whether it
wants to provide a contextual menu.

00:27:40.720 --> 00:27:43.650
If it doesn't want to
provide a contextual menu,

00:27:43.670 --> 00:27:47.420
it will, excuse me,
the control manager will ultimately set

00:27:47.420 --> 00:27:49.700
the menu displayed parameter to false.

00:27:49.810 --> 00:27:54.700
And then you can test that after calling
handle control contextual menu click.

00:27:54.710 --> 00:27:58.190
And if it is false,
then it means if your application

00:27:58.240 --> 00:28:02.700
knows something about that
control or the enclosing window

00:28:02.700 --> 00:28:06.180
or something along those lines,
then it can provide its

00:28:06.250 --> 00:28:07.700
own contextual menu.

00:28:07.700 --> 00:28:10.780
We've added control, excuse me,
we've added drag and drop

00:28:10.780 --> 00:28:12.700
support to the control manager.

00:28:12.700 --> 00:28:17.910
We've got a few slides on this because
it's a pretty comprehensive support.

00:28:19.100 --> 00:28:25.190
Now, the first point here where it says,
by default, controls do not track drags,

00:28:25.190 --> 00:28:29.140
basically what that means is
there are some controls which

00:28:29.140 --> 00:28:35.000
support drag and drop inherently,
and that support does not change.

00:28:35.000 --> 00:28:38.050
But you can tell an
individual control whether,

00:28:38.050 --> 00:28:41.180
regardless of whether it
supports drag and drop,

00:28:41.240 --> 00:28:46.710
you can tell it whether it should or not,
so it's really up to you.

00:28:47.380 --> 00:28:51.830
Some controls will call
Set Control Drag Tracking Enabled

00:28:51.830 --> 00:28:54.800
on themselves as they're created.

00:28:54.860 --> 00:28:58.660
The only control that does this right
now is the Data Browser control.

00:28:58.660 --> 00:29:02.650
And I believe there's a way to
specify that it not do that.

00:29:02.810 --> 00:29:05.530
But in any case, you can turn it off.

00:29:06.250 --> 00:29:09.460
And of course there are APIs to
enable or disable the capability.

00:29:09.460 --> 00:29:11.980
And I think they're
pretty straightforward.

00:29:12.360 --> 00:29:15.820
There's a setter and
a getter and there's,

00:29:15.820 --> 00:29:15.820
um...

00:29:16.100 --> 00:29:18.050
Not really much confusion there.

00:29:18.190 --> 00:29:22.560
So the way drag tracking works is,
or at least in one of the cases,

00:29:22.560 --> 00:29:25.280
is you install your normal
drag tracking handlers,

00:29:25.280 --> 00:29:30.670
and while drag tracking is occurring,
your application needs to maintain

00:29:30.670 --> 00:29:38.320
state so that it knows which of the drag
tracking messages to pass to the control.

00:29:38.600 --> 00:29:40.750
And, of course,
as the mouse enters a control,

00:29:40.750 --> 00:29:43.900
you send it the enter control message,
and as the mouse is moving

00:29:44.360 --> 00:29:46.850
around within the control,
you send it the tracking

00:29:46.880 --> 00:29:49.600
in control message,
and I'm guessing you can figure out

00:29:49.600 --> 00:29:51.100
what the leave control message is for.

00:29:51.100 --> 00:29:54.320
But anyway,
the important message here is that

00:29:54.420 --> 00:29:58.830
your app needs to maintain the
state during drag tracking so that

00:29:58.830 --> 00:30:04.090
controls are given the right clues
to draw the user feedback correctly.

00:30:04.160 --> 00:30:09.160
And of course, when you receive,
or when the user releases the mouse

00:30:09.170 --> 00:30:14.200
and the drag manager tells you
that the user is intending to drop,

00:30:14.300 --> 00:30:18.600
you basically pass the drag reference
off to the control definition.

00:30:18.660 --> 00:30:21.710
It looks at the drag reference,
figures out what data it cares about

00:30:21.710 --> 00:30:25.110
and what data it doesn't care about,
and then incorporates that

00:30:25.110 --> 00:30:27.100
information into the control.

00:30:27.140 --> 00:30:30.390
And in a way, this is sort of like
calling set control data,

00:30:30.440 --> 00:30:33.520
except that you get to pass
many different flavors,

00:30:33.670 --> 00:30:35.100
perhaps many different items.

00:30:35.100 --> 00:30:38.540
So it's sort of like,
it's almost like a container

00:30:38.540 --> 00:30:42.470
being shipped off to the control,
and the control incorporates

00:30:42.590 --> 00:30:44.100
whatever data it cares about.

00:30:44.100 --> 00:30:46.470
Now there's a much easier
way to get support for drag

00:30:46.580 --> 00:30:50.800
and drop in your application,
and basically it involves telling the

00:30:50.860 --> 00:30:55.090
control manager for a given window,
just handle tracking.

00:30:55.100 --> 00:30:57.100
You don't need to install
tracking handlers.

00:30:57.100 --> 00:30:59.090
You don't need to install drop handlers.

00:30:59.100 --> 00:31:01.090
Everything is taken care
of for you automatically.

00:31:01.100 --> 00:31:05.100
And you give up a certain amount
of control over the process,

00:31:05.100 --> 00:31:10.570
but we think the majority case,
people will just simply turn

00:31:10.680 --> 00:31:12.100
it on and forget about it.

00:31:12.100 --> 00:31:16.040
And from then on,
their controls will just work.

00:31:16.300 --> 00:31:22.660
We're really proud of this API because
it is definitely the longest function

00:31:22.660 --> 00:31:25.440
name in the entire Mac OS API.

00:31:27.730 --> 00:31:30.190
We worked really hard
to put that in there.

00:31:30.320 --> 00:31:32.750
So, idle controls.

00:31:32.900 --> 00:33:04.800
[Transcript missing]

00:33:05.660 --> 00:33:09.800
It's basically one of these
Carbon event driven things,

00:33:09.800 --> 00:33:11.380
for the most part.

00:33:11.470 --> 00:33:14.580
If you need to add support
for it in your control,

00:33:14.680 --> 00:33:17.770
you need to add a Carbon event
handler and we'll tell you when

00:33:17.770 --> 00:33:19.600
to do the scroll to here thing.

00:33:19.730 --> 00:33:22.420
Now of course,
like the rest of the Carbon event

00:33:22.420 --> 00:33:26.550
support in control definitions,
we have a shim for the old messages,

00:33:26.600 --> 00:33:30.880
but there are some conditions
under which we can't do the

00:33:30.880 --> 00:33:33.600
shim translation sort of thing.

00:33:33.600 --> 00:33:36.740
The way to stay out of the situation
where we can't support scroll to

00:33:36.740 --> 00:33:40.600
here for your scroll bars or sliders,
the simplest way anyway,

00:33:40.600 --> 00:33:42.590
is to instantiate the
live controlling variant,

00:33:42.600 --> 00:33:48.600
excuse me, the live tracking variants.

00:33:48.950 --> 00:33:51.900
Another way to do it is if you,
for some reason,

00:33:51.900 --> 00:33:56.470
need to have non-live tracking variants,
specify no action proc for

00:33:56.470 --> 00:33:58.650
those scroll bars or sliders.

00:33:58.770 --> 00:34:03.100
Really what you need to stay
away from is Dry Gray Region UPP.

00:34:03.190 --> 00:34:06.880
And that's a weird historical sort of...

00:34:07.440 --> 00:34:10.340
I don't want to call it an accident,
but basically it's, once again,

00:34:10.360 --> 00:34:13.500
it's one of those weird
overloaded semantic cases where

00:34:13.500 --> 00:34:17.910
sometimes you specify an action
proc with a certain prototype,

00:34:17.910 --> 00:34:21.140
and sometimes you specify an
action proc with another prototype,

00:34:21.140 --> 00:34:24.360
and it's really hard for the
Carbon Event shim to figure

00:34:24.360 --> 00:34:26.400
out which situation you're in.

00:34:26.400 --> 00:34:29.180
So basically,
it eliminates the possibility that

00:34:29.180 --> 00:34:32.940
it will try to call a function with
the incorrect prototype by simply

00:34:32.940 --> 00:34:39.130
establishing conditions under which it
won't even try to do scroll to here.

00:34:39.400 --> 00:34:44.090
So if you stay away from those situations
where it's a possibility that you would

00:34:44.090 --> 00:34:48.070
have to specify drag-ray region UPP,
then basically you don't have to

00:34:48.110 --> 00:34:51.110
worry too much about scroll to here,
it'll just work.

00:34:51.360 --> 00:34:55.600
Click activation is a whole
new facility we've added.

00:34:55.630 --> 00:35:01.240
Basically,
click activation is a way for a control

00:35:01.290 --> 00:35:06.150
to specify what kind of behavior it
wants when it's been clicked on and

00:35:06.150 --> 00:35:08.180
the window it's in is not active.

00:35:08.180 --> 00:35:11.020
And again,
an active window is basically any window

00:35:11.020 --> 00:35:13.990
that the user expects to interact with.

00:35:14.000 --> 00:35:17.710
And there are four cases that a
control can specify-- or I should

00:35:17.710 --> 00:35:22.600
say four behaviors that a control
can specify for the situation.

00:35:22.640 --> 00:35:26.170
I think the names are
pretty straightforward.

00:35:26.240 --> 00:35:30.970
Control basically either wants
the window to be activated or not,

00:35:31.230 --> 00:35:36.800
and it wants the control
to actually be hit or not.

00:35:37.560 --> 00:35:40.540
And then you can specify all
the combinations thereof.

00:35:40.590 --> 00:35:43.450
And so basically your application,
when it detects a click

00:35:43.610 --> 00:35:47.720
in an inactive window,
it can call getControlClickActivation

00:35:47.840 --> 00:35:50.500
and then find out what
to do next as a result.

00:35:50.540 --> 00:35:55.880
I believe the control which supports
getControlClickActivation is the

00:35:55.880 --> 00:36:00.180
Data Browser control right now,
but in the future there may be more

00:36:00.180 --> 00:36:02.490
controls which actually care about this.

00:36:02.500 --> 00:36:04.800
So if you're building
framework type of code,

00:36:04.800 --> 00:36:07.720
you probably want to use
getControlClickActivation in the

00:36:07.720 --> 00:36:14.360
general case and not just avoid it just
because you don't use Data Browser.

00:36:15.100 --> 00:36:17.480
So here's a chunk of sample
code that shows get control

00:36:17.550 --> 00:36:20.480
click activation in action.

00:36:20.680 --> 00:36:24.760
The first if case is basically,
if the window is active,

00:36:24.830 --> 00:36:26.000
do what you always did.

00:36:26.000 --> 00:36:28.000
Do what you're doing now.

00:36:28.000 --> 00:36:29.200
No change is necessary.

00:36:29.200 --> 00:36:32.010
But if the window is not active,
then get control click

00:36:32.010 --> 00:36:33.680
activation comes into play.

00:36:33.690 --> 00:36:40.390
And that, basically, after you find out
what the control wants,

00:36:40.470 --> 00:36:43.200
you can figure out whether
you need to select the window.

00:36:43.200 --> 00:36:46.320
So if the control is
saying activate the window,

00:36:46.320 --> 00:36:48.660
then you just call select window.

00:36:48.960 --> 00:36:51.600
And if the control is saying
that it wants to handle a click,

00:36:51.650 --> 00:36:54.890
then again, you just call the same old
code that you've always had

00:36:54.990 --> 00:36:58.660
to handle clicks and controls,
and it should work just fine.

00:36:58.760 --> 00:37:01.390
So I've given you a long
laundry list of features we've

00:37:01.390 --> 00:37:04.990
been adding to the toolbox,
and I want to go back

00:37:05.460 --> 00:37:06.940
over some of them to

00:37:08.340 --> 00:37:14.980
I want to emphasize what's in store
for you in the next few weeks or a

00:37:14.980 --> 00:37:14.980
few months or hopefully a few days.

00:37:15.390 --> 00:37:16.930
Basically,
drawing to the Window Manager Port is

00:37:16.930 --> 00:37:18.260
no longer supported.

00:37:18.260 --> 00:37:22.190
It's kind of doable in DP4,
but don't get used to that

00:37:22.190 --> 00:37:27.190
idea because it's going to
stop being possible very soon.

00:37:28.130 --> 00:37:31.870
There's some changes to the custom
window and control definition model.

00:37:31.870 --> 00:37:35.830
There's not only changes to the
way you need to instantiate them,

00:37:35.920 --> 00:37:39.640
but also changes to the way
they need to work internally.

00:37:39.780 --> 00:37:44.350
And then of course there's the dialog
item list accessors that we've added

00:37:44.380 --> 00:37:48.590
in order to support dialog opacity.

00:37:49.270 --> 00:37:53.900
Then there's the Unicode support,
pervasive in the toolbox.

00:37:53.900 --> 00:37:58.100
Unicode is obviously an
important future direction.

00:37:58.400 --> 00:38:00.030
There's the Carbon Events support
in the toolbox,

00:38:00.150 --> 00:38:03.220
and once again I want to emphasize,
if you get a chance to see sessions

00:38:03.220 --> 00:38:09.110
121 and 122 on QuickTime streaming
or videotape or however it is they

00:38:09.110 --> 00:38:13.260
end up distributing these things,
definitely take that chance.

00:38:13.360 --> 00:38:16.530
And then we've added a bunch of
new Control Manager features,

00:38:16.530 --> 00:38:20.870
some to support the Aqua user experience
and some just because they were cool.
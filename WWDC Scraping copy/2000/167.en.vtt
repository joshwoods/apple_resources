WEBVTT

00:00:09.200 --> 00:00:11.040
Hi, good morning.

00:00:11.040 --> 00:00:13.860
My name is Sari,
and my topic for today is a

00:00:13.880 --> 00:00:16.200
set of APIs called URL Access.

00:00:16.200 --> 00:00:19.630
Now,
URL Access has actually been a topic at

00:00:19.630 --> 00:00:23.570
WWDC for the past couple few years now,
but this year we got

00:00:23.570 --> 00:00:25.200
our very own session,
which is pretty exciting.

00:00:25.200 --> 00:00:30.890
We're going to have time to go through
pretty much everything you've ever wanted

00:00:30.890 --> 00:00:30.890
to know about URL Access and then some.

00:00:31.350 --> 00:00:33.250
Let's get started.

00:00:33.320 --> 00:00:35.430
Here's what I plan on covering today.

00:00:35.490 --> 00:00:38.140
We're going to go through
what URL Access does and why

00:00:38.140 --> 00:00:40.500
you might want to use it.

00:00:40.570 --> 00:00:43.460
We'll spend some time,
quite a bit of time,

00:00:43.460 --> 00:00:45.740
on going over the APIs in depth.

00:00:45.830 --> 00:00:53.950
We'll talk about what URL Access is
like on 9 versus 10 versus your DP4

00:00:53.950 --> 00:00:53.950
CDs that you got at the conference.

00:00:54.300 --> 00:00:57.430
We'll talk a little bit about what we
plan to do with URL Access in the future.

00:00:57.430 --> 00:01:00.930
We'll have a very quick demo,
which you guys are going to need

00:01:00.930 --> 00:01:03.340
to pay attention to because we have
very little UI in this product.

00:01:03.340 --> 00:01:08.210
So we'll have a quick demo,
and then we should have some

00:01:08.210 --> 00:01:08.210
time left over to do Q&A.

00:01:10.050 --> 00:01:12.610
My goals for this session,
what I hope you'll learn today,

00:01:12.610 --> 00:01:17.980
is what you can do with URL Access,
how to use it to get your

00:01:17.980 --> 00:01:21.390
Carbon applications going.

00:01:21.880 --> 00:01:25.340
And finally,
since this API is a mature API now,

00:01:25.340 --> 00:01:28.530
it's been around for a few years,
some developers have run into some

00:01:28.530 --> 00:01:31.770
limitations with it and some issues,
and I want to make sure that any

00:01:31.860 --> 00:01:34.470
first-time users don't hit those as well.

00:01:36.380 --> 00:01:38.860
So what is URL Access?

00:01:38.870 --> 00:01:41.400
If it's not totally
obvious from the name,

00:01:41.400 --> 00:01:44.260
it's an API to allow you to
access data on the Internet.

00:01:44.320 --> 00:01:47.620
And the way you do this
is you give it a URL.

00:01:48.340 --> 00:01:53.080
We have support for the following
schemes or URL prefixes:

00:01:53.120 --> 00:01:57.890
HTTP, HTTPS, FTP and file.

00:01:58.670 --> 00:02:02.990
It supports both downloading
of data and uploading of data.

00:02:03.060 --> 00:02:06.980
And it's a Carbon API,
so it's available on 9 and 10.

00:02:09.220 --> 00:02:13.330
So this diagram gives an overview
of the Apple security APIs,

00:02:13.360 --> 00:02:17.880
of which URL Access is one,
partly because it supports

00:02:17.880 --> 00:02:22.340
SSL for HTTPS and also for
organizational reasons.

00:02:22.440 --> 00:02:24.300
So as you can see,
URL Access is part of the

00:02:24.340 --> 00:02:27.140
classic environment and part
of the Carbon environment.

00:02:27.220 --> 00:02:30.060
And it's callable from legacy apps,
Carbon apps, and it's also actually

00:02:30.060 --> 00:02:32.900
callable for Mac OS X apps,
although the diagram

00:02:33.000 --> 00:02:34.950
does not make that clear.

00:02:36.960 --> 00:02:42.320
The URL Access architecture,
it's part of Carbon.

00:02:42.370 --> 00:02:47.160
As I said before, it implements HTTP,
HTTPS, FTP, and file.

00:02:47.210 --> 00:02:51.620
And some of the toolboxes
it uses are OpenTransport,

00:02:51.700 --> 00:02:53.600
Internet Config.

00:02:54.160 --> 00:03:13.360
The Keychain and SSL.

00:03:13.360 --> 00:03:13.360
We use OpenTransport, of course,
to do our networking.

00:03:13.360 --> 00:03:13.360
We use Internet Config to find
out about proxies and firewalls

00:03:13.360 --> 00:03:13.360
that the user has configured.

00:03:13.360 --> 00:03:13.360
We use the Keychain to automatically
access sites that require authentication.

00:03:13.360 --> 00:03:13.360
And we use SSL to do HTTPS.

00:03:15.160 --> 00:03:18.080
So now you know what it does overall.

00:03:18.150 --> 00:03:20.220
What does it do specifically?

00:03:20.450 --> 00:03:23.930
This is a set of features that
are available to you independent

00:03:23.930 --> 00:03:26.000
of what scheme your URL is.

00:03:26.030 --> 00:03:30.230
We have an authentication dialog,
which will come up automatically

00:03:30.230 --> 00:03:33.530
if the site you're going
to requires authentication,

00:03:33.530 --> 00:03:35.730
and that is an optional feature.

00:03:35.880 --> 00:03:39.630
We have a progress dialog if you'd
like for the user to be able to view

00:03:39.630 --> 00:03:43.200
the progress of the download or upload
and stop the download or upload.

00:03:43.200 --> 00:03:46.230
And that, once again, is optional.

00:03:46.810 --> 00:03:48.920
We support encoding
and decoding of files.

00:03:48.970 --> 00:03:53.710
We encode binhex before
you upload a file,

00:03:53.730 --> 00:03:56.400
if you like,
and we also attempt to decode the file.

00:03:56.400 --> 00:04:00.560
We support binhex again,
and we support using the stuff engine

00:04:00.590 --> 00:04:03.060
if the stuff engine is installed.

00:04:03.170 --> 00:04:06.460
It is a scriptable API,
and we do have proxy

00:04:06.470 --> 00:04:07.800
and firewall support.

00:04:07.950 --> 00:04:12.740
Specifically, we support HTTP proxies,
and we support the SOX firewall.

00:04:13.050 --> 00:04:14.930
And as I mentioned before,
we support the keychain for

00:04:15.000 --> 00:04:18.050
automatic authentication.

00:04:20.060 --> 00:04:21.220
HTTP feature set.

00:04:21.400 --> 00:04:24.230
We support download, no upload yet.

00:04:24.280 --> 00:04:26.070
We support posting,
but that does require a

00:04:26.070 --> 00:04:29.150
little additional work,
and I'll go through a

00:04:29.150 --> 00:04:30.870
code sample of that.

00:04:31.250 --> 00:04:34.940
We support auto-redirection,
so if the URL you're going to

00:04:34.940 --> 00:04:40.090
is relocated to another site,
we will follow that redirection until

00:04:40.090 --> 00:04:44.500
it terminates in some actual data
and just hand you back the data.

00:04:44.660 --> 00:04:46.840
That is an optional feature.

00:04:47.050 --> 00:04:50.940
You do have full access to the
server response if you need it.

00:04:51.120 --> 00:04:54.590
And we do support proxy authentication,
so some HTTP proxies

00:04:54.590 --> 00:04:57.970
require you to authenticate,
and we will bring up a

00:04:57.970 --> 00:05:00.110
dialogue for that as well.

00:05:01.470 --> 00:05:04.650
With FTP,
you can not only download files,

00:05:04.710 --> 00:05:06.020
but you can upload files.

00:05:06.040 --> 00:05:08.070
And you can not only
download and upload files,

00:05:08.080 --> 00:05:10.130
but you can download
and upload directories,

00:05:10.160 --> 00:05:12.590
entire directories as well.

00:05:12.920 --> 00:05:16.000
Or if you prefer,
your URL points to a directory.

00:05:16.000 --> 00:05:19.140
You can also get a directory listing,
but you're going to have to parse

00:05:19.200 --> 00:05:22.070
it yourself because we don't
provide any parsing support.

00:05:24.370 --> 00:05:25.980
HTTPS,
right now there's a little bit of a

00:05:25.990 --> 00:05:29.310
disparity between Mac OS X and Mac OS 9.

00:05:29.390 --> 00:05:34.600
On 10, we already support SSL 3
with 128-bit encryption.

00:05:34.810 --> 00:05:41.290
The current status of OS 9 is that we
support SSL 2.0 and 40-bit encryption.

00:05:43.810 --> 00:05:47.510
Now I want to apologize in advance
for this next few slides because the

00:05:47.510 --> 00:05:51.650
whole point of URL access is that
you don't need to know the technical

00:05:51.650 --> 00:05:53.450
details behind the protocols.

00:05:53.630 --> 00:05:57.770
However, that being said,
let's talk about some functional

00:05:57.780 --> 00:05:59.890
limitations in URL access.

00:05:59.970 --> 00:06:02.820
First of all we don't parse HTML.

00:06:02.850 --> 00:06:06.160
Well, of course not,
but what does that mean to you?

00:06:06.200 --> 00:06:10.080
What that means is when a
webmaster designs a website,

00:06:10.080 --> 00:06:13.540
they often have two options for
implementing a given feature.

00:06:13.540 --> 00:06:17.190
They can do it in the HTTP or
they can do it in the HTML.

00:06:17.250 --> 00:06:20.980
If they opt for the former,
then we likely is not supported.

00:06:21.070 --> 00:06:25.900
If they opt to implement it in the HTML,
there's nothing we can do.

00:06:25.930 --> 00:06:28.800
The best example of this is login.

00:06:28.800 --> 00:06:32.380
When you use your web browser
and you get a dialogue saying,

00:06:32.400 --> 00:06:37.420
you know, please log into this site,
that's an HTTP authentication.

00:06:37.420 --> 00:06:40.070
Now when you use your web browser
and you get a form asking you to

00:06:40.140 --> 00:06:42.400
-- for a username and password,
that's HTML.

00:06:42.400 --> 00:06:45.900
That's HTML authentication
and we don't support that.

00:06:45.900 --> 00:06:48.750
Some other examples are
file not found could,

00:06:48.750 --> 00:06:50.480
you know,
there could be a web page saying file

00:06:50.480 --> 00:06:54.740
not found and they don't tell us in
the HTTP that the file isn't there.

00:06:54.750 --> 00:06:57.720
And redirection can also
be implemented in the HTML,

00:06:57.720 --> 00:06:59.510
but it's usually implemented in HTTP.

00:07:02.520 --> 00:07:06.030
Now because of this fact
that we don't parse HTML,

00:07:06.110 --> 00:07:08.490
there's some FTP limitations.

00:07:08.670 --> 00:07:14.100
If you go through a proxy,
FTP is basically transformed into HTML.

00:07:14.160 --> 00:07:20.670
And because we don't parse the HTML,
we can't upload files and we can't

00:07:20.670 --> 00:07:20.670
download or upload direct views.

00:07:22.060 --> 00:07:25.240
And the last one has been
hit by a number of people.

00:07:25.280 --> 00:07:29.730
URL Access is pretty popular as an
option for getting HTTPS support

00:07:29.800 --> 00:07:33.190
because it's some fairly...

00:07:33.800 --> 00:07:50.900
[Transcript missing]

00:07:52.210 --> 00:07:56.430
So the first thing that happens when you
make an SSL connection is the client asks

00:07:56.430 --> 00:07:59.690
the server for the server certificate.

00:07:59.800 --> 00:08:02.590
And the server obliges.

00:08:04.160 --> 00:08:06.240
And then the client has to
do due diligence to make sure

00:08:06.240 --> 00:08:10.060
that this certificate is from
a server that they trust.

00:08:10.180 --> 00:08:11.020
How do they do this?

00:08:11.290 --> 00:08:13.480
They need to find out who
issued the certificate,

00:08:13.520 --> 00:08:15.100
who signed the certificate.

00:08:15.470 --> 00:08:20.090
And that certificate in red,
which we also call the root certificate.

00:08:21.700 --> 00:08:25.400
URL Access goes through its list
of known root certificates to

00:08:25.400 --> 00:08:28.200
see if that root is in its list.

00:08:28.310 --> 00:08:30.750
If it isn't, you don't get to connect.

00:08:30.830 --> 00:08:32.380
If it is, you do.

00:08:32.540 --> 00:08:37.600
And this set of root
certs is a static set.

00:08:37.720 --> 00:08:40.900
The only way to update it is to
get a new version of URL Access,

00:08:40.900 --> 00:08:44.550
which is unfortunate,
but we hope to rectify that with

00:08:44.550 --> 00:08:48.940
the secure transport library,
which some of you may have heard

00:08:49.020 --> 00:08:49.880
about in the security overview.

00:08:52.790 --> 00:08:54.840
So now let's talk about what
you can do with URL Access.

00:08:54.870 --> 00:09:00.260
I thought I'd give a few sample uses,
and hopefully that will get you

00:09:00.260 --> 00:09:02.300
thinking about what you can do with it,
too.

00:09:02.410 --> 00:09:05.070
Internally at Apple,
we have several high-profile

00:09:05.070 --> 00:09:06.450
clients of URL Access.

00:09:06.630 --> 00:09:10.040
Sherlock uses it to do
its Internet searching.

00:09:10.130 --> 00:09:14.260
Software Updater uses it to
upgrade files over the Internet.

00:09:14.930 --> 00:09:18.310
Help Viewer uses it to
display Internet content.

00:09:18.400 --> 00:09:22.220
When the content isn't local,
it uses URL Access to go get the content.

00:09:22.640 --> 00:09:35.590
Network Browser uses
it to access FTP sites,

00:09:35.590 --> 00:09:35.590
which is a pretty cool feature
if you haven't played with it.

00:09:35.590 --> 00:09:35.590
You go to Network Browser,
enter the Connect To dialog,

00:09:35.590 --> 00:09:35.590
your FTP site,
and you can browse through the FTP sites.

00:09:37.330 --> 00:09:38.940
Some third-party uses, iCab.

00:09:38.980 --> 00:09:43.000
Some of you may be familiar with
this web browser on the Macintosh.

00:09:43.080 --> 00:09:47.110
It uses URL Access only for HTTPS sites.

00:09:47.280 --> 00:09:50.760
Adobe uses it in Acrobat to implement
a feature called Web Capture.

00:09:50.760 --> 00:09:55.200
This is a feature that allows
them to take HTML files and

00:09:55.480 --> 00:09:58.390
transform them into PDF.

00:09:59.470 --> 00:10:01.440
And finally,
numerous companies are using the

00:10:01.440 --> 00:10:06.180
scripting component internally
to do various and sundry things.

00:10:07.880 --> 00:10:09.360
So now you know what
you're going to do with it,

00:10:09.360 --> 00:10:11.370
I hope,
and let's talk about how to do it.

00:10:11.390 --> 00:10:13.040
Let's go through the API.

00:10:13.130 --> 00:10:16.960
We'll talk about the synchronous API,
which is the easiest to use.

00:10:16.960 --> 00:10:20.800
We'll go through flags which
control aspects of the transfer.

00:10:20.880 --> 00:10:25.610
We'll talk about properties,
and then we'll move into

00:10:25.610 --> 00:10:27.800
the asynchronous API.

00:10:27.800 --> 00:10:31.090
It's a little more flexible,
but consequently a little

00:10:31.090 --> 00:10:31.090
more difficult to use.

00:10:31.090 --> 00:10:31.090
And we'll talk about states.

00:10:33.210 --> 00:10:37.010
The very easiest way to download
a URL on any platform-- OK,

00:10:37.070 --> 00:10:40.310
I don't know for that for sure,
but it's kind of fun to

00:10:40.310 --> 00:10:42.220
say-- is URL Simple Download.

00:10:42.220 --> 00:10:44.290
It's a single call.

00:10:44.590 --> 00:10:45.550
to download a URL.

00:10:45.560 --> 00:10:48.400
All you do is you provide the source URL.

00:10:48.500 --> 00:10:56.400
You provide it the destination FS spec
if you want to download to a file,

00:10:56.400 --> 00:10:56.400
or you provide the destination handle
if you'd like to download to memory.

00:10:57.160 --> 00:11:00.040
And you also pass in any flags, you know,
if you want it to do

00:11:00.040 --> 00:11:02.160
something in particular.

00:11:02.200 --> 00:11:04.300
Now,
I'm going to make a request that you all,

00:11:04.300 --> 00:11:06.800
if you use this API,
please use it in thread.

00:11:06.860 --> 00:11:07.710
It's a synchronous API.

00:11:07.750 --> 00:11:12.260
It's going to take some time to complete,
so please put it in a separate thread.

00:11:13.900 --> 00:11:16.400
So let's see how
URL Simple Download works.

00:11:16.400 --> 00:11:19.130
Here we have a routine, getURL,
which I'm going to implement

00:11:19.130 --> 00:11:21.660
in several different ways
throughout this presentation.

00:11:21.790 --> 00:11:26.180
It takes a source URL,
it takes a destination FS spec,

00:11:26.520 --> 00:11:29.670
And in this case, we're going to use
URL Simple Download to implement it.

00:11:29.690 --> 00:11:31.160
As you can see, it's pretty simple.

00:11:31.240 --> 00:11:32.220
We declare some flags.

00:11:32.280 --> 00:11:33.880
We declare status.

00:11:33.890 --> 00:11:35.860
And we call URL Simple Download.

00:11:35.870 --> 00:11:37.080
We pass in the URL.

00:11:37.240 --> 00:11:40.150
We pass in the destination FS spec.

00:11:40.280 --> 00:11:42.240
We say we don't want
to download to memory,

00:11:42.240 --> 00:11:45.900
which is the following nil, and we say,
here's some flags saying what

00:11:45.900 --> 00:11:47.200
I want you to do with my download.

00:11:47.200 --> 00:11:52.260
When the URL simple download completes,
the download is complete, and we're done.

00:11:55.010 --> 00:11:59.620
So I kind of breezed over the two
last parameters to UFSimple Download,

00:11:59.700 --> 00:12:02.950
and those parameters involve
the system event procedure.

00:12:03.640 --> 00:12:08.300
This is a way,
a parameter to all the synchronous calls.

00:12:08.340 --> 00:12:10.990
And if you're going to display a dialog,
or you think a dialog

00:12:10.990 --> 00:12:12.790
is going to come up,
you really need to

00:12:12.790 --> 00:12:14.130
implement one of these.

00:12:14.180 --> 00:12:17.240
It allows the dialogs to be
displayed as movable modal.

00:12:17.240 --> 00:12:20.250
If you don't implement one,
the dialogs will be just

00:12:20.350 --> 00:12:22.620
your regular modal dialogs.

00:12:22.690 --> 00:12:25.880
And what the system event procedure
does is basically receive update events

00:12:25.880 --> 00:12:30.470
so your app has time to update itself
while we're moving our dialog around.

00:12:31.020 --> 00:12:34.400
The second synchronous API I want to
talk about is slightly more complex.

00:12:34.400 --> 00:12:37.700
There's two more steps,
but it's significantly more powerful,

00:12:37.780 --> 00:12:40.560
and it's called URL Download.

00:12:40.560 --> 00:12:45.420
The two extra steps are you have to
create and dispose of a URL reference.

00:12:46.530 --> 00:12:48.030
And once again,
it should be used in a thread

00:12:48.040 --> 00:12:50.940
because it's going to take some time.

00:12:51.010 --> 00:12:53.040
Now,
why would you use URL Download instead

00:12:53.040 --> 00:12:54.300
of URL Simple Download?

00:12:54.440 --> 00:12:56.390
Well,
because you have this URL reference,

00:12:56.500 --> 00:13:00.400
you can make any of the other API calls
to do various and sundry things.

00:13:00.400 --> 00:13:06.450
You can call get and set property
before and after the download.

00:13:06.450 --> 00:13:10.200
Or if you're threaded
from another thread,

00:13:10.200 --> 00:13:10.200
you could monitor the state of
the download or even abort it.

00:13:12.620 --> 00:13:16.250
So here is our get URL routine again,
implemented in terms of

00:13:16.250 --> 00:13:18.480
the URL download call.

00:13:18.700 --> 00:13:21.260
As you can see,
there's just two extra steps.

00:13:21.260 --> 00:13:25.070
Once again, we declare our flags,
we declare our status,

00:13:25.070 --> 00:13:29.270
we declare URL reference now,
called URL ref, and we create it by

00:13:29.270 --> 00:13:31.300
calling URL new reference.

00:13:31.500 --> 00:13:32.400
Then we call URL Download.

00:13:32.400 --> 00:13:37.800
This time we pass in the URL Ref instead
of the source URL directly.

00:13:37.870 --> 00:13:40.940
We pass in the destination FS spec.

00:13:41.020 --> 00:13:42.480
Don't download to memory.

00:13:42.600 --> 00:13:44.180
Pass in our flags.

00:13:44.270 --> 00:13:46.490
And when that call returns,
the download is done and we are

00:13:46.520 --> 00:13:49.570
free to dispose our URL reference.

00:13:49.970 --> 00:13:51.660
So now we've talked about
synchronous downloading.

00:13:51.660 --> 00:13:54.950
Let's talk just briefly
about synchronous uploading.

00:13:55.650 --> 00:13:59.150
There's two ways, once again,
URL Simple Upload and URL Upload

00:13:59.230 --> 00:14:02.260
to upload synchronously,
and they're very similar to

00:14:02.330 --> 00:14:05.900
their downloading counterparts,
with the following exceptions.

00:14:05.900 --> 00:14:09.150
You provide a destination
URL instead of a source URL,

00:14:09.150 --> 00:14:09.980
of course.

00:14:09.980 --> 00:14:15.000
You provide a source FS spec
instead of a destination FS spec.

00:14:15.000 --> 00:14:17.820
In addition,
you cannot upload from memory.

00:14:17.820 --> 00:14:19.200
You can only upload from a file.

00:14:19.200 --> 00:14:22.140
And, of course,
different flags apply to uploading

00:14:22.140 --> 00:14:23.840
as opposed to downloading.

00:14:25.320 --> 00:14:30.380
Finally, in its current state,
uploading is FTP only.

00:14:32.230 --> 00:14:33.960
So we've talked about flags a lot.

00:14:34.060 --> 00:14:36.200
Let's get into some detail on those.

00:14:36.410 --> 00:14:40.420
They do control optional
aspects of the transfer,

00:14:40.430 --> 00:14:43.760
and they are used in both
synchronous and asynchronous calls.

00:14:43.780 --> 00:14:45.620
Here are some sample flags.

00:14:45.630 --> 00:14:47.970
Replace existing flag.

00:14:48.510 --> 00:14:53.650
basically says if the destination file,
be it an upload or a download, exists,

00:14:53.880 --> 00:14:54.860
then go ahead and replace it.

00:14:54.900 --> 00:14:59.240
Now if you don't set this flag,
what we do is we create a unique name.

00:14:59.240 --> 00:15:03.050
We never return destination exists error.

00:15:03.430 --> 00:15:06.020
So that's something to keep in mind.

00:15:06.020 --> 00:15:09.020
The next flag, display progress flag,
is how you indicate that

00:15:09.020 --> 00:15:10.380
you want a progress dialog.

00:15:10.520 --> 00:15:13.200
Display authentication flag
is how you indicate you want

00:15:13.200 --> 00:15:15.240
an authentication dialog.

00:15:15.280 --> 00:15:18.720
Expand file flag says,
after the file is downloaded,

00:15:18.760 --> 00:15:21.890
please do everything you
can to decode it for me.

00:15:22.260 --> 00:15:26.210
Benhex file flag says
before the file is uploaded,

00:15:26.240 --> 00:15:29.220
if the file has a resource
fork and it's not of type text,

00:15:29.750 --> 00:15:31.890
please Benhex it for me.

00:15:32.560 --> 00:15:35.100
And finally, the no auto-redirect flag.

00:15:35.120 --> 00:15:38.850
If the HTTP site does redirect you and
you don't want that redirect followed,

00:15:38.930 --> 00:15:41.140
then you can set this
flag and it won't be.

00:15:41.200 --> 00:15:42.730
Now let's talk about properties.

00:15:42.840 --> 00:15:46.500
Properties fall into one of
four different categories.

00:15:46.560 --> 00:15:49.000
They are either aspects
of the URL itself,

00:15:49.090 --> 00:15:52.970
for example,
the host name or the entire URL.

00:15:53.310 --> 00:15:56.870
Or they are aspects of the
resource that the URL points to.

00:15:56.940 --> 00:16:00.750
For example, the size of the file,
the name of the file,

00:16:00.750 --> 00:16:02.920
or the MIME type of the data.

00:16:03.390 --> 00:16:07.120
The third category is aspects
of the transfer itself.

00:16:07.170 --> 00:16:09.110
A good example here is
the URL status string,

00:16:09.390 --> 00:16:11.240
which changes as the download progresses.

00:16:11.240 --> 00:16:15.970
It goes from initiating to connecting
to downloading to aborting,

00:16:15.970 --> 00:16:16.990
et cetera.

00:16:17.580 --> 00:16:20.600
URL Total Items is a property that's
available if you're downloading

00:16:20.600 --> 00:16:22.100
or uploading an entire directory.

00:16:22.100 --> 00:16:24.230
It tells you how many
items there are total.

00:16:24.360 --> 00:16:29.590
Those first two are both useful if you're
displaying your own progress dialog.

00:16:30.330 --> 00:16:31.760
HTTP redirected URL.

00:16:31.760 --> 00:16:35.700
If there is a redirect,
you can find out about

00:16:35.700 --> 00:16:36.590
it in this property.

00:16:36.760 --> 00:16:39.320
The last category of
properties is they're another

00:16:39.320 --> 00:16:41.440
way to control the transfer.

00:16:41.440 --> 00:16:44.340
If something is more complicated
than just a yes or no question

00:16:44.340 --> 00:16:48.090
and we couldn't make it a flag,
we made it a property instead.

00:16:48.370 --> 00:16:52.840
For example, the HTTP request method
is something you can set.

00:16:52.910 --> 00:16:54.040
Or the HTTP user agent.

00:16:54.060 --> 00:16:54.800
This is really useful.

00:16:54.800 --> 00:16:58.540
A lot of websites are quirky in that
they want you to be Mozilla compliant,

00:16:58.540 --> 00:17:02.370
so you can set your user agent
to have a string Mozilla in it.

00:17:04.000 --> 00:17:06.830
So properties can be retrieved
with URL Get Property.

00:17:06.860 --> 00:17:09.280
They're set with URL Set Property.

00:17:09.280 --> 00:17:11.540
And they may change during the transfer.

00:17:11.570 --> 00:17:14.520
Two examples of this are the status ring,
which changes frequently.

00:17:14.520 --> 00:17:20.380
Another example is some properties may
move from an unknown to a known state.

00:17:20.430 --> 00:17:25.050
In HTTP, if the HTTP server tells
us the size of the file,

00:17:25.050 --> 00:17:29.620
the resource size property goes
from unknown to a known state,

00:17:29.620 --> 00:17:32.150
and that is a property change.

00:17:34.000 --> 00:17:35.600
Here's a list of all the
properties you can set.

00:17:35.600 --> 00:17:37.070
This is conclusive.

00:17:37.150 --> 00:17:39.590
No other properties are settable.

00:17:39.900 --> 00:17:43.740
That first line should read
URL HTTP request header,

00:17:43.740 --> 00:17:47.780
which is how you set the entire
header of the HTTP request.

00:17:47.860 --> 00:17:50.480
Or you can just set
the method or the body.

00:17:51.060 --> 00:17:52.810
You can set the user
agent and the last two,

00:17:52.810 --> 00:17:54.060
username and password.

00:17:54.060 --> 00:17:57.090
This is how you would implement
your own authentication dialog.

00:17:57.100 --> 00:17:59.510
Display the dialog, enter,
have the user enter the

00:17:59.540 --> 00:18:03.170
username and password,
call set property on both of those items,

00:18:03.170 --> 00:18:04.900
and then do the download.

00:18:04.900 --> 00:18:07.620
So now I want to show
you how to do a post.

00:18:07.620 --> 00:18:11.250
Doing a post is a pretty
popular thing in URL Access.

00:18:11.250 --> 00:18:13.810
A lot of people use it for posting.

00:18:15.470 --> 00:18:17.680
In this case, we're going to use
URL download once again,

00:18:17.680 --> 00:18:20.000
but we're going to set
some properties first.

00:18:20.010 --> 00:18:22.990
We're going to create
a new URL reference.

00:18:23.090 --> 00:18:28.270
Then we're going to set the
HTTP request method property to be post,

00:18:28.360 --> 00:18:32.800
and the HTTP request body
property to be our post data.

00:18:33.310 --> 00:18:34.650
And then we simply call URL Download.

00:18:34.650 --> 00:18:37.280
That does the post,
and the answer to the post will be

00:18:37.400 --> 00:18:41.510
put into whatever your destination is.

00:18:41.860 --> 00:18:45.740
So that's it for the synchronous APIs,
flags, and properties.

00:18:45.740 --> 00:18:49.150
Let's move on to the asynchronous APIs.

00:18:49.490 --> 00:18:53.290
Once again, to use the asynchronous APIs,
you need a URL reference.

00:18:53.380 --> 00:18:56.210
But instead of calling
URL Download or URL Upload,

00:18:56.290 --> 00:18:58.800
you're going to call URL Open.

00:18:59.620 --> 00:19:01.340
URL Open is an asynchronous call.

00:19:01.340 --> 00:19:04.370
What it does is return immediately
and starts the download or

00:19:04.370 --> 00:19:05.930
upload in the background.

00:19:06.010 --> 00:19:14.210
You can use it to download to a file,
or you can choose to get the

00:19:14.210 --> 00:19:14.210
data yourself by calling get
buffer and release buffer.

00:19:14.720 --> 00:19:18.200
Now, there's two ways to monitor
an asynchronous download.

00:19:18.220 --> 00:19:19.920
You can either use a
notification routine,

00:19:19.920 --> 00:19:22.870
which is the preferred method,
or if you insist,

00:19:22.910 --> 00:19:25.570
you can poll with URL Get Current State.

00:19:27.710 --> 00:19:30.940
Now, why would anyone want to
use the asynchronous APIs?

00:19:30.970 --> 00:19:33.930
If you can't think of a reason,
here's a couple.

00:19:34.170 --> 00:19:38.140
If you're a filter,
there's a very good reason.

00:19:38.250 --> 00:19:41.790
For example,
if you're a web crawler and all you do

00:19:41.810 --> 00:19:48.540
is parse the HTML that you receive for
more URLs and then go and download those,

00:19:48.600 --> 00:19:53.540
you can consume the data before
the data is completely downloaded.

00:19:53.620 --> 00:19:57.710
This is a very good reason
to use the asynchronous APIs.

00:19:57.920 --> 00:20:01.050
Another good reason is if you
want to display your own progress,

00:20:01.050 --> 00:20:03.930
the async APIs are the only way to
get enough information to do that.

00:20:03.940 --> 00:20:07.740
And finally, if you have some moral
opposition to threading,

00:20:07.740 --> 00:20:11.430
then you should probably
use the async APIs.

00:20:12.770 --> 00:20:14.280
So this one's a little longer,
as you can see.

00:20:14.280 --> 00:20:16.460
And please don't go
back and copy this code,

00:20:16.460 --> 00:20:18.760
because it's not how
we want you to do it.

00:20:18.760 --> 00:20:21.700
It does pull, but I want it to be
consistent with my example.

00:20:21.700 --> 00:20:28.120
And so we're going to implement
getURL in terms of the URL open call.

00:20:29.280 --> 00:20:31.540
So the first,
the beginning is pretty much the same.

00:20:31.540 --> 00:20:33.250
We set some variables up.

00:20:33.300 --> 00:20:35.600
We create a new reference.

00:20:35.640 --> 00:20:42.170
The first highlighted line, notify UPP,
creates a new URL notify UPP.

00:20:42.200 --> 00:20:44.790
That is a carbon-only step.

00:20:44.840 --> 00:20:47.820
If you're implementing online only,
then you don't need to do this,

00:20:47.850 --> 00:20:50.650
but hopefully you all are going
to carbonize your applications,

00:20:50.650 --> 00:20:52.280
so you need to create a notify UPP.

00:20:52.370 --> 00:20:56.430
You pass in the notification
routine that you want to use,

00:20:56.430 --> 00:20:59.020
and then you simply call URL open.

00:20:59.200 --> 00:21:00.300
- Yeah.

00:21:00.380 --> 00:21:02.460
Pass in the URL reference.

00:21:02.470 --> 00:21:04.890
You say, "Nil,
I don't want to download to a

00:21:04.890 --> 00:21:09.250
file." You pass in any flags you
want to control the download.

00:21:09.320 --> 00:21:11.000
You notify UPP.

00:21:11.070 --> 00:21:13.790
And then you pass in a mask
for what events you want

00:21:13.880 --> 00:21:15.850
your notification to receive.

00:21:16.150 --> 00:21:17.200
and any user contacts.

00:21:17.200 --> 00:21:20.800
In this case,
I'm passing in a pointer to a Boolean.

00:21:20.900 --> 00:21:21.270
Done.

00:21:21.270 --> 00:21:24.670
That's the part I don't
want you to emulate.

00:21:24.930 --> 00:21:26.420
And then I'm going to sit and spin.

00:21:26.670 --> 00:21:27.900
Well, I'm not done.

00:21:27.900 --> 00:21:28.460
URL Idle.

00:21:28.460 --> 00:21:32.590
And URL Idle is a call that allows
URL Access time to do its work.

00:21:32.600 --> 00:21:36.040
It's very important,
especially for polling.

00:21:36.140 --> 00:21:38.440
And finally, once I'm done,
I can dispose my UPP,

00:21:38.520 --> 00:21:40.620
I dispose my reference, and that's it.

00:21:44.120 --> 00:21:47.650
So here's our notification routine.

00:21:47.730 --> 00:21:49.750
My notifier.

00:21:50.130 --> 00:21:52.080
The parameters passed in
are your user context,

00:21:52.080 --> 00:21:55.160
of course,
the event for which you were called,

00:21:55.160 --> 00:21:59.900
and the rest of the information is
in the URL callback info struct.

00:21:59.910 --> 00:22:03.600
This is mainly so if we want to pass
you in more information in the future,

00:22:03.610 --> 00:22:05.780
we can do so by modifying the struct.

00:22:05.870 --> 00:22:09.510
There is a version
number in the structure.

00:22:10.310 --> 00:22:12.600
So the first thing we're going
to do in our notification routine

00:22:12.600 --> 00:22:16.440
is set up our user context,
our done variable.

00:22:16.830 --> 00:22:19.070
And then we're going to switch
on the event that we received.

00:22:19.160 --> 00:22:22.460
If we get a data available event,
we need to go process some data.

00:22:22.480 --> 00:22:25.130
If we get a completed
or error occurred event,

00:22:25.220 --> 00:22:25.980
that means we're done.

00:22:26.000 --> 00:22:29.490
So we set our done variable to true.

00:22:32.410 --> 00:22:34.400
Process data.

00:22:34.450 --> 00:22:37.120
We're passing the URL ref so
we can actually get the data.

00:22:37.120 --> 00:22:41.020
And then we're going to sit in a loop,
getting data and releasing data.

00:22:41.110 --> 00:22:45.890
Now, URL get buffer says I'm borrowing
a buffer from URL Access.

00:22:45.900 --> 00:22:48.400
You notice that there is no
memory allocation in this routine.

00:22:48.400 --> 00:22:49.180
That's not a bug.

00:22:49.180 --> 00:22:51.000
It's not going to crash.

00:22:51.110 --> 00:22:56.200
We're basically getting
the buffer from URL Access.

00:22:56.200 --> 00:22:57.830
We consume it in any way we so desire,
and then we give it back.

00:22:57.810 --> 00:23:00.110
Once again,
we're going to call URL idle because

00:23:00.130 --> 00:23:02.040
we could be in this loop for a while.

00:23:02.040 --> 00:23:04.420
And then we get the current
state of the download to see if

00:23:04.420 --> 00:23:05.850
there's still data available.

00:23:06.080 --> 00:23:09.430
When you get the data available event,
you get it one time per

00:23:09.470 --> 00:23:11.000
set of data available.

00:23:11.000 --> 00:23:15.140
So you have to consume all the data
before you're going to get another event.

00:23:15.370 --> 00:23:16.690
Let's talk a little
bit more about events.

00:23:16.760 --> 00:23:20.990
They are, of course,
reported to the notification routine.

00:23:21.810 --> 00:23:23.590
You can register for a subset of events.

00:23:23.610 --> 00:23:26.020
You can say,
I only want events that relate

00:23:26.020 --> 00:23:28.000
to data being downloaded.

00:23:28.000 --> 00:23:30.200
That's the all buffer events mask.

00:23:30.360 --> 00:23:33.440
Or you can just, for example,
register for just the completed

00:23:33.440 --> 00:23:36.090
and error occurred event,
if all you care about is whether

00:23:36.170 --> 00:23:37.570
or not the download is done.

00:23:40.150 --> 00:23:42.760
Let's talk about a few of
the events that we have.

00:23:42.760 --> 00:23:47.510
The resource found event means
URL Access has gone out and looked

00:23:47.510 --> 00:23:50.750
for the resource and it actually
has successfully found the resource.

00:23:50.750 --> 00:23:51.920
The resource is there.

00:23:51.920 --> 00:23:53.150
Everything is great.

00:23:53.420 --> 00:23:56.570
The property changed event happens
anytime any property changes,

00:23:56.600 --> 00:24:02.420
either from an unknown state to a known
state or from one value to another value.

00:24:03.430 --> 00:24:08.500
The error occurred event
reports non-recoverable errors.

00:24:08.530 --> 00:24:11.940
It does not report any interim
errors that we've worked around.

00:24:11.990 --> 00:24:15.010
If you get an error occurred event,
the download is done.

00:24:15.320 --> 00:24:19.740
The data available event,
as I talked about earlier,

00:24:19.740 --> 00:24:24.060
you're going to get one per
set of data that's available.

00:24:24.200 --> 00:24:27.490
Periodic event just gives you time
to do whatever you want to do.

00:24:27.500 --> 00:24:30.610
I didn't mention earlier that
the notification routine is

00:24:30.610 --> 00:24:32.000
called at a memory-safe time.

00:24:32.000 --> 00:24:34.540
You can do whatever you want,
allocate memory,

00:24:34.660 --> 00:24:42.210
take a whole lot of time,
draw to the screen, do anything you want,

00:24:42.210 --> 00:24:42.210
as long as you call
URL Idle periodically.

00:24:42.460 --> 00:24:50.210
Abort initiated event says,
"Somebody hit the abort button," or

00:24:50.210 --> 00:24:54.680
"Somebody called URL abort." And we
have this event mainly because

00:24:54.680 --> 00:24:58.170
aborts are non-instantaneous,
so you may need to know that an

00:24:58.170 --> 00:25:00.530
abort is beginning to happen,
and that will be followed

00:25:00.530 --> 00:25:02.220
quickly by the completed event.

00:25:02.530 --> 00:25:03.400
States.

00:25:03.430 --> 00:25:05.960
Let's talk about states anyway,
because states are useful even

00:25:05.960 --> 00:25:07.420
if you don't want to poll.

00:25:08.060 --> 00:25:11.410
URL Get Current State reports
the state of the transfer.

00:25:11.470 --> 00:25:13.100
And some states have event counterparts.

00:25:13.100 --> 00:25:15.790
For example,
there's a data available event

00:25:15.830 --> 00:25:17.100
in a data available state.

00:25:17.170 --> 00:25:20.130
There's an error occurred event
in an error occurred state.

00:25:20.220 --> 00:25:21.600
But some of them don't.

00:25:21.760 --> 00:25:26.300
The one thing that you cannot find
out with state that you have to

00:25:26.320 --> 00:25:29.310
have events for is property changes.

00:25:29.550 --> 00:25:32.630
And they are useful with
both the async and sync APIs.

00:25:32.700 --> 00:25:34.400
All you need is a URL reference,
and you can find out the

00:25:34.400 --> 00:25:36.310
state of your download.

00:25:36.830 --> 00:25:38.090
Here's a list of sample states.

00:25:38.100 --> 00:25:39.320
It should be all pretty obvious.

00:25:39.390 --> 00:25:41.940
Connecting, we're downloading,
there's data available,

00:25:41.940 --> 00:25:44.690
an error occurred, and we've finished.

00:25:46.940 --> 00:25:50.700
So let's go through some issues that
other developers have hit in the past

00:25:50.910 --> 00:25:53.340
when they're programming to URL Access.

00:25:53.460 --> 00:25:56.880
URL Access is a highly-threaded API.

00:25:56.920 --> 00:26:00.200
So you absolutely have to call URL Idle,
and I hope I drilled

00:26:00.200 --> 00:26:02.060
that home in my examples.

00:26:02.860 --> 00:26:08.740
Set property expects C and
Pascal strings in some cases.

00:26:08.810 --> 00:26:11.590
Now this is a bug,
but it is a released bug,

00:26:11.600 --> 00:26:13.600
so we have to continue to support it.

00:26:13.600 --> 00:26:17.960
I do want to try and rectify
this issue on Mac OS X,

00:26:18.050 --> 00:26:21.000
possibly with the addition of a new API.

00:26:21.320 --> 00:26:25.380
So for example,
when you set the user agent,

00:26:25.380 --> 00:26:26.240
it's got to be a C string.

00:26:26.240 --> 00:26:29.340
When you set the user name,
it's got to be a P string.

00:26:29.460 --> 00:26:32.970
And this is documented in the
latest rev of the documentation.

00:26:34.040 --> 00:26:36.500
Another issue people have had is
that you can't call URL Dispose

00:26:36.580 --> 00:26:38.970
Reference from notification routine.

00:26:38.990 --> 00:26:41.380
You will crash, I promise.

00:26:44.700 --> 00:26:45.720
A few more.

00:26:45.720 --> 00:26:48.240
The HTTP request body
cannot contain null bytes.

00:26:48.280 --> 00:26:51.640
That's a direct result of the fact
that we expect it to be a C string.

00:26:51.730 --> 00:26:57.380
This is fixed in post-904 releases,
of which there are none, I realize,

00:26:57.380 --> 00:27:00.100
but there will be some day, I expect.

00:27:00.200 --> 00:27:02.140
URL reference is not reusable.

00:27:02.140 --> 00:27:05.400
You can't set properties on it,
call URL download,

00:27:05.530 --> 00:27:09.000
and then set some more properties,
call URL download again.

00:27:09.080 --> 00:27:12.630
You have to create and dispose it,
one download per.

00:27:12.890 --> 00:27:15.110
Finally, the authentication dialog
and the progress dialog,

00:27:15.150 --> 00:27:18.560
for that matter,
are not supported in the async APIs.

00:27:18.560 --> 00:27:21.560
So if you are using the async APIs,
you have to do your own authentication

00:27:21.560 --> 00:27:24.310
dialog and your own progress dialog.

00:27:26.340 --> 00:27:27.300
So that's it for the API.

00:27:27.300 --> 00:27:30.760
Let's just quickly go over
what we've talked about.

00:27:30.760 --> 00:27:35.140
We talked about the synchronous API,
URL simple download, URL simple upload,

00:27:35.320 --> 00:27:38.280
URL download, URL upload, four calls,
very easy to use.

00:27:38.280 --> 00:27:42.580
We talked about the asynchronous API,
URL open, URL get buffer,

00:27:42.580 --> 00:27:44.220
URL release buffer.

00:27:44.220 --> 00:27:49.000
We talked about flags that control
aspects of the transfer and properties

00:27:49.080 --> 00:27:51.030
which do all sorts of things.

00:27:51.030 --> 00:27:54.380
We talked about events which are
reported to your notification routine

00:27:54.380 --> 00:27:57.880
and states which are available to you
any time you have a URL reference.

00:28:00.870 --> 00:28:04.660
So Mac OS 9 and Mac OS X URL Access are
different slightly,

00:28:04.660 --> 00:28:06.460
and here's how they differ.

00:28:06.520 --> 00:28:09.560
For those of you who have been to
this talk in the past couple of years,

00:28:09.560 --> 00:28:16.440
we talked about the ability
to extend the capabilities

00:28:16.440 --> 00:28:16.440
of URL Access using plug-ins.

00:28:16.570 --> 00:28:18.040
Now, this is not supported on Mac OS X.

00:28:18.040 --> 00:28:22.320
We may add it back at some point,
but it will not be in the first release.

00:28:23.010 --> 00:28:25.400
Scripting may not make the
first release of Mac OS X.

00:28:25.400 --> 00:28:29.150
Actually,
now that Steve has announced that summer

00:28:29.150 --> 00:28:33.490
is our beta and January is our GM,
I think we'll be able

00:28:33.490 --> 00:28:35.440
to get scripting done.

00:28:37.000 --> 00:28:41.280
Mac OS X, as I mentioned before,
has 128-bit SSL 3.

00:28:41.280 --> 00:28:45.570
And the current Mac OS X has SSL 2,
40-bit.

00:28:46.160 --> 00:28:51.130
Properties will work correctly,
possibly with the addition of a new API.

00:28:51.200 --> 00:28:53.140
And this last one is just kind of an FYI.

00:28:53.140 --> 00:28:57.040
Mac OS X is a carbonized version
of the Mac OS 9 source base,

00:28:57.080 --> 00:28:59.900
which means that it will
be bug-for-bug compatible.

00:28:59.900 --> 00:29:02.290
Hopefully that's good news.

00:29:03.210 --> 00:29:08.850
Now, DP4 works as much as it
needed to work for Sherlock,

00:29:08.870 --> 00:29:09.440
basically.

00:29:09.440 --> 00:29:13.850
We locked down quite a while ago,
so things are much better on my machine.

00:29:14.090 --> 00:29:15.570
But HTTPS isn't working.

00:29:15.630 --> 00:29:20.220
Deauthentication and progress
dialogues are not yet working.

00:29:20.220 --> 00:29:24.160
Proxy support is disabled because of
some issues we had with Internet config.

00:29:24.160 --> 00:29:26.820
Keychain support is disabled
for the same reason.

00:29:26.860 --> 00:29:29.320
And we're not yet part of Carbon.

00:29:29.320 --> 00:29:31.180
It's a separate framework right now.

00:29:31.180 --> 00:29:33.010
The path to that is
System Library Frameworks

00:29:33.090 --> 00:29:36.200
URL Access.framework,
so you have to link that in.

00:29:37.400 --> 00:29:41.900
So hopefully you're all raring to go,
you have ideas, you want to get started.

00:29:41.990 --> 00:29:46.640
If you want to develop on Mac OS 9,
you need to download the security SDK,

00:29:46.730 --> 00:29:50.060
because we are a member
of the security APIs.

00:29:50.150 --> 00:29:51.760
That's where the URL Access SDK is.

00:29:51.780 --> 00:29:54.550
Or of course you could
just download CarbonLib.

00:29:57.040 --> 00:30:00.790
You want to develop on Mac OS X,
URL Access is on DP4

00:30:00.800 --> 00:30:02.840
with its limitations.

00:30:02.850 --> 00:30:04.860
And you need to link with
system library frameworks,

00:30:04.860 --> 00:30:06.980
URL Access.framework.

00:30:07.210 --> 00:30:08.860
You are going to want to get
the latest documentation.

00:30:08.860 --> 00:30:10.100
It has been revved recently.

00:30:10.100 --> 00:30:12.480
It's a big improvement.

00:30:12.480 --> 00:30:15.090
And that is up on the TechPubs website.

00:30:18.580 --> 00:30:21.780
So what are we going to do in the future?

00:30:21.810 --> 00:30:26.250
We are going to support 128-bit SSL 3,
and we're going to have new

00:30:26.250 --> 00:30:28.500
root certs for Mac OS 9.

00:30:28.500 --> 00:30:29.940
We're going to do some bug fixing, too.

00:30:29.940 --> 00:30:33.560
We're going to fix a memory leak that
a number of you have told us about.

00:30:33.640 --> 00:30:35.040
Thank you very much.

00:30:35.040 --> 00:30:36.860
We knew about it.

00:30:37.460 --> 00:30:38.770
But it's fixed now.

00:30:38.900 --> 00:30:41.150
We're going to support
NELS in the HTTP request body.

00:30:41.150 --> 00:30:45.460
That has been requested
by several developers.

00:30:45.510 --> 00:30:49.160
And this last one, support for SHA1 with
RSA signed certificates.

00:30:49.190 --> 00:30:51.570
I'm going to briefly
get SSL technical again.

00:30:51.640 --> 00:30:57.730
VeriSign has recently changed the way
that they sign their certificates.

00:30:57.800 --> 00:31:01.480
So as people,
as servers on the web update

00:31:01.490 --> 00:31:06.870
and get new certificates,
these certificates are not going

00:31:06.870 --> 00:31:08.560
to be readable by URL Access.

00:31:08.560 --> 00:31:09.520
It's a very bad thing.

00:31:09.520 --> 00:31:11.570
We are going to fix that.

00:31:13.800 --> 00:31:16.440
On 10, we have more grandiose plans.

00:31:16.440 --> 00:31:20.620
We do intend to implement HTTP upload.

00:31:20.620 --> 00:31:22.500
We want to implement connection reuse.

00:31:22.500 --> 00:31:26.240
What this means is that if you want to
do a series of uploads or downloads,

00:31:26.240 --> 00:31:29.400
you don't have to bring up and tear
down a connection every time because

00:31:29.400 --> 00:31:31.590
you're going to have a session.

00:31:31.730 --> 00:31:34.050
We're going to move to the
secure transport library,

00:31:34.050 --> 00:31:38.290
which will give us our
dynamic route cert database.

00:31:38.900 --> 00:31:41.300
We'd like to improve our
built-in encoding and decoding.

00:31:41.300 --> 00:31:43.550
Certainly,
we want to support Nick Binary and

00:31:43.820 --> 00:31:46.990
whatever else you all think is important.

00:31:47.520 --> 00:31:53.280
And we may re-enable plugins and/or
add additional scheme support built in.

00:31:55.130 --> 00:31:56.940
Okay, so this is where you all
have to pay attention.

00:31:57.000 --> 00:31:58.080
It's a very quick demo.

00:31:58.210 --> 00:32:00.980
We can move over to the Demo 1 machine.

00:32:01.420 --> 00:32:04.290
Now what I have here is an
application URL Access demo.

00:32:04.360 --> 00:32:08.140
What I did was I went to the
Carbon Sample Apps folder and

00:32:08.140 --> 00:32:14.430
I basically used it without modification,
except I added two menu items,

00:32:14.500 --> 00:32:16.270
FTP Download, HTTP Download.

00:32:16.800 --> 00:32:20.010
Both of which simply call
URL Simple Download with

00:32:20.010 --> 00:32:21.790
a hard-coded URL.

00:32:21.840 --> 00:32:25.010
Let's start with the HTTP download.

00:32:25.380 --> 00:32:26.590
So here's our progress bar.

00:32:26.610 --> 00:32:29.480
As you can see, the user can see the
progress of the download.

00:32:29.480 --> 00:32:32.240
They could hit the stop
button if they so desired.

00:32:32.370 --> 00:32:36.750
They have an indication of the
time remaining less than a minute.

00:32:37.080 --> 00:32:40.530
If they want more information,
they can find out what they're copying,

00:32:40.540 --> 00:32:43.340
where they're copying it from,
where they're copying it to.

00:32:43.340 --> 00:32:45.710
In this case,
we're downloading to memory,

00:32:45.770 --> 00:32:47.240
so the to field is empty.

00:32:47.260 --> 00:32:50.930
And they get a running total of
how many bytes have already been

00:32:50.930 --> 00:32:53.900
copied and how many bytes are total.

00:32:54.080 --> 00:32:57.270
And of course,
we can abort it at any time.

00:32:59.870 --> 00:33:06.100
FTP download,
this is connecting to FTP.apple.com,

00:33:06.100 --> 00:33:07.930
as you can see from the initial line.

00:33:08.150 --> 00:33:12.340
You can go ahead and type in your
username and type in a password.

00:33:12.340 --> 00:33:15.800
You could add it to the
keychain if you wanted to.

00:33:15.940 --> 00:33:23.960
Or if you know that the site that you are
connecting to supports anonymous login,

00:33:23.960 --> 00:33:25.590
you could just go ahead and
click the anonymous button.

00:33:25.650 --> 00:33:28.500
I'm going to try this, actually,
earlier this morning.

00:33:28.500 --> 00:33:29.150
It did not work.

00:33:29.220 --> 00:33:31.600
I think FTPI.com is
just really busy today.

00:33:31.600 --> 00:33:34.170
It's just refusing my connection,
but I'm going to go ahead

00:33:34.170 --> 00:33:35.380
and give it a try anyway.

00:33:35.530 --> 00:33:37.260
and it refused my connection.

00:33:37.280 --> 00:33:41.190
So what you would have seen
is another progress bar.

00:33:41.240 --> 00:33:43.020
So we've already seen that.

00:33:43.090 --> 00:33:44.500
And that's it for the demo.

00:33:44.650 --> 00:33:47.650
Can we move back to the slides, please?

00:33:53.860 --> 00:33:57.840
So to summarize,
URL Access is the API to use if you

00:33:57.840 --> 00:33:59.720
want to get data off the Internet.

00:33:59.740 --> 00:34:01.400
It's a Carbon API.

00:34:01.400 --> 00:34:02.970
It's available to you on 9 and 10.

00:34:02.970 --> 00:34:09.250
It's very easy to use, synchronous APIs,
single call to do a download or upload.

00:34:09.360 --> 00:34:11.600
And we also have flexible
async APIs if you need them.

00:34:15.050 --> 00:34:17.940
The one session I want to point you
to is the Security Feedback Forum.

00:34:17.940 --> 00:34:20.400
If you don't have time to get
your feedback to me today,

00:34:20.400 --> 00:34:21.900
then you can go to this.

00:34:21.900 --> 00:34:29.230
We are including URL Access in
the Security Feedback Forum,

00:34:29.230 --> 00:34:29.230
and that's in room J1 today at 5 p.m.

00:34:32.130 --> 00:34:35.670
And if you want to talk to
somebody about this after the show,

00:34:35.720 --> 00:34:38.900
you want to contact Tom Weier,
who's our Network and

00:34:38.920 --> 00:34:44.380
Communications Technology Manager in
Apple Worldwide Developer Relations.
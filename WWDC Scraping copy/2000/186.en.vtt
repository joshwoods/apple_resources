WEBVTT

00:00:10.850 --> 00:00:12.460
I'll be talking today about OpenGL.

00:00:12.460 --> 00:00:15.960
I'll be doing an introduction to
that and talking about how you can

00:00:15.960 --> 00:00:21.010
get started in OpenGL and exactly
what Apple's OpenGL implementation,

00:00:21.090 --> 00:00:22.830
how it's made up.

00:00:25.830 --> 00:00:28.490
First of all, this is going to be a
high-level overview of OpenGL.

00:00:28.500 --> 00:00:31.690
We're going to talk about a little bit
of Apple's implementation and the setup.

00:00:31.740 --> 00:00:34.690
We're going to introduce OpenGL and
talk about how that works.

00:00:34.820 --> 00:00:41.670
And then we're going to discuss
Apple's implementation and give

00:00:41.670 --> 00:00:41.670
a little bit of how-to to get you
going to lead into the next session.

00:00:42.230 --> 00:00:46.060
First we'll talk about what is OpenGL,
exactly how does it fit in,

00:00:46.210 --> 00:00:48.660
what does it do,
and for some people who've kind of

00:00:48.660 --> 00:00:50.610
heard OpenGL term bounced around a lot.

00:00:50.700 --> 00:00:52.930
We've talked about it,
we've said this is a great thing,

00:00:53.100 --> 00:00:54.340
but how is it a great thing for you?

00:00:54.340 --> 00:00:55.830
What can you do with it?

00:00:55.950 --> 00:00:58.520
And then we'll talk about
our implementation details,

00:00:58.600 --> 00:01:02.420
we'll talk about using OpenGL,
and we'll give you some references to get

00:01:02.420 --> 00:01:06.580
started and to get you on your way that
will give you some really good source

00:01:06.580 --> 00:01:08.780
code and some documentation for it.

00:01:10.540 --> 00:01:14.170
First, OpenGL really is just a software
interface for graphics hardware.

00:01:14.300 --> 00:01:18.500
It drills down and allows you to
really get at the meat of the hardware.

00:01:18.500 --> 00:01:21.540
And with all the research we're
doing these days in the 3D

00:01:21.540 --> 00:01:25.110
hardware that companies are doing,
it really allows you a really

00:01:25.110 --> 00:01:28.500
good way of getting high
performance graphics to the screen.

00:01:29.200 --> 00:01:30.810
It's platform agnostic.

00:01:30.810 --> 00:01:34.310
So a lot of you who have things
that may run on Unix or may run on

00:01:34.310 --> 00:01:37.500
Windows or may run on the Mac OS,
OS 9 or OS 10,

00:01:37.500 --> 00:01:42.930
can use the same OpenGL graphics code for
both and have that stay the same across

00:01:43.060 --> 00:01:46.500
multiple platforms for your application.

00:01:46.500 --> 00:01:48.940
So it solves your development
problems that way.

00:01:49.040 --> 00:01:52.450
You don't have to write windowing
code for every single application and

00:01:52.450 --> 00:01:56.500
write the specific graphics engine for
every different platform you're on.

00:01:56.800 --> 00:01:57.500
It's also asynchronous.

00:01:57.500 --> 00:01:58.500
This is a key to
understanding the application.

00:01:58.500 --> 00:02:02.490
You have a graphics engine
and you have your application.

00:02:02.500 --> 00:02:04.500
You're submitting commands
to the graphics engine.

00:02:04.500 --> 00:02:08.770
This kind of comes back from when it
was originally from the SGI design

00:02:08.770 --> 00:02:11.940
that you could have the graphics,
you have a client server kind of

00:02:12.060 --> 00:02:16.380
operation that you would not have
in what you'd say a PC today.

00:02:16.500 --> 00:02:19.500
We've carried that over and everyone's
carried that over when they build OpenGL.

00:02:19.500 --> 00:02:23.200
And what that does is means that your
commands are submitted and then you

00:02:23.200 --> 00:02:26.630
swap the buffers and it basically
executes a batch of commands and

00:02:26.630 --> 00:02:27.500
displays whatever your commands are.

00:02:27.500 --> 00:02:27.500
So it's a really good
way to understand OpenGL.

00:02:27.500 --> 00:02:27.500
So it's a really good
way to understand OpenGL.

00:02:27.500 --> 00:02:31.340
whatever your image
becomes on the screen.

00:02:31.390 --> 00:02:33.620
It's also based on geometric primitives.

00:02:33.620 --> 00:02:38.080
Instead of some higher level languages,
that might be PDF-based, like Quartz,

00:02:38.080 --> 00:02:41.400
or that might have a
file handling capability,

00:02:41.400 --> 00:02:42.450
it doesn't have that.

00:02:42.540 --> 00:02:45.370
What it has, basically,
it has the basic points, lines,

00:02:45.510 --> 00:02:48.550
and polygons,
and you build from the bottom up.

00:02:48.690 --> 00:02:53.710
And, real important understanding of
OpenGL is that it's a state machine.

00:02:53.880 --> 00:02:56.990
What state you set it in is
always the state it's gonna be in.

00:02:57.050 --> 00:03:00.060
If you're texturing on,
it's gonna stay on until you turn it off.

00:03:00.060 --> 00:03:03.640
If texturing's off initially,
if you try and texture a polygon,

00:03:03.640 --> 00:03:04.780
you're not gonna get any texture.

00:03:04.780 --> 00:03:06.680
You're probably gonna
get a white polygon,

00:03:06.710 --> 00:03:09.260
'cause it's not gonna apply a texture
until you turn the texturing on.

00:03:09.260 --> 00:03:10.740
And there's lots of examples of that.

00:03:10.740 --> 00:03:13.860
And a lot of new OpenGL programmers,
myself included,

00:03:13.860 --> 00:03:17.760
have been bitten by that many times.

00:03:17.780 --> 00:03:18.580
That's about it.

00:03:18.870 --> 00:03:20.670
Let's move on.

00:03:22.460 --> 00:03:24.850
So we talked about it as a state machine.

00:03:25.020 --> 00:03:27.390
As I said,
this is a key to understanding OpenGL and

00:03:27.470 --> 00:03:29.230
successful development with OpenGL.

00:03:29.400 --> 00:03:33.960
By understanding it as a state machine,
you can understand why things

00:03:34.060 --> 00:03:35.400
happen in your application.

00:03:35.400 --> 00:03:38.530
And as I said, with texturing,
you can add almost anything in OpenGL,

00:03:38.590 --> 00:03:42.180
including the modes,
not just the switch kind of mode,

00:03:42.180 --> 00:03:44.400
but including some of the
drawing modes against states.

00:03:44.400 --> 00:03:47.110
And you can change drastically
the behavior of the application

00:03:47.110 --> 00:03:48.400
by setting simple states.

00:03:48.400 --> 00:03:50.400
Also, state changes can be expensive.

00:03:50.400 --> 00:03:53.400
Sometimes they're not,
but in a lot of cases they can be.

00:03:53.400 --> 00:03:58.940
For example, you design an engine to draw
something on the screen that every

00:03:58.940 --> 00:04:02.400
frame goes through and sets every
single state that you need set.

00:04:02.400 --> 00:04:05.120
In some cases,
you can really be hitting some long paths

00:04:05.300 --> 00:04:08.600
through our drivers and through OpenGL,
thus making your application run

00:04:08.600 --> 00:04:12.790
significantly slower than it could run if
you actually set the state once and then

00:04:12.870 --> 00:04:15.370
think about when you need to change it.

00:04:15.460 --> 00:04:18.400
So, for example,
if there's only two things in your state,

00:04:18.430 --> 00:04:21.400
one is texture mapped and
one is not texture mapped,

00:04:21.400 --> 00:04:23.310
draw everything that's texture mapped,
and then draw everything

00:04:23.350 --> 00:04:24.400
that's not texture mapped.

00:04:24.400 --> 00:04:29.090
That switch once rather than on a
per polygon or a per point basis.

00:04:29.470 --> 00:04:32.400
So also,
we talk about setting and getting states.

00:04:32.400 --> 00:04:36.400
It's really key when you want to know
how to set a state or how to get a state,

00:04:36.400 --> 00:04:38.400
you can use glEnable and glDisable.

00:04:38.400 --> 00:04:42.400
Throughout the API,
you can use them for almost every state.

00:04:42.540 --> 00:04:46.400
The documentation covers the
litany of states that you can set.

00:04:46.400 --> 00:04:48.400
Also, there is a lot of information.

00:04:48.400 --> 00:04:51.390
The key here is a
glIsEnabled and a glGet.

00:04:51.430 --> 00:04:55.400
The key here also,
sometimes that has to query the hardware.

00:04:55.400 --> 00:04:58.400
And to do that,
since it is an asynchronous operation,

00:04:58.400 --> 00:05:02.400
you can have a command that changes
a state somewhere in your pipeline.

00:05:02.400 --> 00:05:07.210
If you call a glGet, say, "Hey,
is texturing enabled?" What happens

00:05:07.300 --> 00:05:11.400
is it may have to wait for your
whole command pipeline to execute

00:05:11.400 --> 00:05:13.280
to query the hardware to say,
"Am I in that state?"

00:05:13.400 --> 00:05:15.390
Get the command back.

00:05:15.400 --> 00:05:18.400
So, as you can see,
that could be also an expensive thing.

00:05:18.400 --> 00:05:19.400
That's not a shortcut.

00:05:19.400 --> 00:05:22.400
There's not a state that is
always saved off in the software.

00:05:22.400 --> 00:05:27.420
It really ties the software,
OpenGL drivers, and the hardware tied

00:05:27.420 --> 00:05:29.370
together very closely.

00:05:29.750 --> 00:05:32.190
And GL push attribute and pop attribute.

00:05:32.290 --> 00:05:36.200
The reason I mention these is sometimes
if you want to change a lot of states,

00:05:36.200 --> 00:05:38.020
you have a pile of
things you're changing,

00:05:38.120 --> 00:05:40.470
you may want to use push
attribute and pop attribute.

00:05:40.470 --> 00:05:47.730
So a lot of times it's faster to
do that than it is to save all

00:05:47.850 --> 00:05:49.920
your states or check your states,
enable your states,

00:05:49.920 --> 00:05:49.920
disable your states one at a time.

00:05:51.590 --> 00:05:53.660
So let's talk a little bit
about the OpenGL Pipeline.

00:05:53.660 --> 00:05:57.080
Real simply, the OpenGL Pipeline,
this is a really high level

00:05:57.080 --> 00:05:58.380
overview of the pipeline.

00:05:58.380 --> 00:06:00.460
I say that you might want
to go to the references,

00:06:00.580 --> 00:06:02.610
and there's a lot of,
in the specification and

00:06:02.610 --> 00:06:05.160
in all the references,
there's a lot of more in-depth

00:06:05.160 --> 00:06:06.980
section on the OpenGL Pipeline.

00:06:06.980 --> 00:06:08.880
So I'm not going to
really go deep into this,

00:06:08.880 --> 00:06:10.730
but it gives you an idea of how it works.

00:06:10.760 --> 00:06:13.810
And so this is,
all your data comes into this pipeline.

00:06:13.820 --> 00:06:17.290
And first thing that vertexes come into,
so if you have a vertex,

00:06:17.380 --> 00:06:19.950
you have a point in space,
it comes in there,

00:06:19.950 --> 00:06:24.160
and basically when the vertex comes in,
it applies a transformation that

00:06:24.160 --> 00:06:26.350
puts that vertex somewhere in space.

00:06:26.360 --> 00:06:30.340
It says, okay, the model transformation,
it's over here by the podium.

00:06:30.340 --> 00:06:33.430
And then it takes the transformation,
the view transformation, basically says,

00:06:33.430 --> 00:06:35.240
I'm looking at it from this perspective.

00:06:35.240 --> 00:06:40.020
And so that sets out the relationship
between the point and the eye.

00:06:40.040 --> 00:06:43.910
And also the projection transformation,
which actually projects that point from

00:06:43.910 --> 00:06:46.640
your 3D space into your 2D flat screen.

00:06:46.640 --> 00:06:48.350
That all happens in the vertex operation.

00:06:48.440 --> 00:06:51.590
Then we clip the thing,
perspective divide and viewport

00:06:51.590 --> 00:06:54.960
transformation happens,
so we actually transform it

00:06:54.960 --> 00:06:57.340
into what size your viewport is.

00:06:57.340 --> 00:07:00.060
You'll see in one of the applications
I'll demo later that you can drag

00:07:00.060 --> 00:07:01.720
the window and make it larger.

00:07:01.720 --> 00:07:05.640
That's a, you'll translate that,
and it's resetting the

00:07:05.640 --> 00:07:07.140
viewport to a size.

00:07:07.620 --> 00:07:13.180
Perspective divide basically scales
things via your Z or how far away it is,

00:07:13.180 --> 00:07:15.500
making things smaller, far away,
and closer.

00:07:15.500 --> 00:07:20.480
And when things are closer,
it makes them larger, obviously.

00:07:20.500 --> 00:07:24.080
One key here is that perspective
divide is based on information

00:07:24.080 --> 00:07:25.500
you supply to OpenGL.

00:07:25.500 --> 00:07:28.500
It's not based on
OpenGL always does this.

00:07:28.500 --> 00:07:29.500
It's a 3D application.

00:07:29.500 --> 00:07:31.410
It has to look exactly this way.

00:07:31.500 --> 00:07:34.170
For example,
one thing we'll talk about later in

00:07:34.170 --> 00:07:38.500
the week is using OpenGL for not a game
or not an immersive 3D application.

00:07:38.500 --> 00:07:41.500
You can say, "Hey,
I want this to be orthographic.

00:07:41.500 --> 00:07:41.500
I don't want that perspective.

00:07:41.500 --> 00:07:44.550
I just want everything to be
directly parallel projection,

00:07:44.570 --> 00:07:47.580
and I'm going to make everything
the same size no matter how far

00:07:47.690 --> 00:07:49.900
away it is." And you can do that
if you're working on a CAD program,

00:07:49.900 --> 00:07:50.470
for example.

00:07:50.540 --> 00:07:52.990
So these are things
that it does in general,

00:07:52.990 --> 00:07:55.950
but depending on how it's set
up and what state it's in,

00:07:56.070 --> 00:07:59.500
maybe depending on how
actually it carries out these.

00:07:59.620 --> 00:08:01.500
And it calls either...
It can do a lot of things.

00:08:01.500 --> 00:08:02.500
It can do backface culling.

00:08:02.500 --> 00:08:06.860
So if you have my proverbial cube,
and I don't want to show the backfaces of

00:08:06.860 --> 00:08:09.780
that cube because maybe it's transparent,
it will look at the

00:08:09.780 --> 00:08:12.260
polygons and determine,
based on whether it's

00:08:12.370 --> 00:08:15.730
clockwise or counterclockwise,
what polygons to throw away that

00:08:15.730 --> 00:08:17.890
may be facing away from you.

00:08:18.410 --> 00:08:20.300
Now we talk about pixel operations.

00:08:20.450 --> 00:08:23.380
Pixel operations are parallel
to the vertex operations.

00:08:23.470 --> 00:08:26.260
If you put a texture in there
or you put a bitmap into OpenGL,

00:08:26.360 --> 00:08:28.300
they go through the pixel
part of the pipeline.

00:08:28.300 --> 00:08:31.500
Basically the pixels are
unpacked and sorted into a format

00:08:31.500 --> 00:08:33.240
that OpenGL can understand.

00:08:33.370 --> 00:08:36.560
And that's real important because
when we talk about texturing later,

00:08:36.560 --> 00:08:42.440
OpenGL expects a certain types of formats
and you need to be able to supply this

00:08:42.490 --> 00:08:44.300
type of format graphics for it to expect.

00:08:44.300 --> 00:08:47.260
And you'll see why we have some
good news in that area as I get

00:08:47.360 --> 00:08:49.300
through the presentation here.

00:08:49.300 --> 00:08:53.300
Pixel maps are processed and they're
passed to the texture memory or

00:08:53.300 --> 00:08:55.270
to the rasterizer to be drawn.

00:08:55.360 --> 00:08:57.130
So basically it hands it
off to texture memory.

00:08:57.430 --> 00:08:58.430
Here you go.

00:08:58.430 --> 00:09:03.300
Here's your form,
your bits and pixels in a proper format.

00:09:03.300 --> 00:09:06.300
And then when the texturing
instructions come in,

00:09:06.300 --> 00:09:10.130
they can pull that texture out and
they can texture to the screen.

00:09:10.660 --> 00:09:12.000
Rasterization.

00:09:12.040 --> 00:09:15.740
Rasterization basically takes
your geometry and pixels and

00:09:15.830 --> 00:09:17.500
converts them into fragments.

00:09:17.650 --> 00:09:21.280
Fragments is something that represents
basically one pixel on the screen.

00:09:21.280 --> 00:09:24.430
As you notice at the bottom
of this slide I have X,

00:09:24.430 --> 00:09:26.370
Y, Z, W, RGB, ST, R and Q.

00:09:26.370 --> 00:09:29.500
So those are basically a
point in space that has an X,

00:09:29.500 --> 00:09:30.320
Y and Z value.

00:09:30.320 --> 00:09:33.000
You may say, "Hey,
didn't he just say that it was

00:09:33.000 --> 00:09:35.620
already... We already converted to 2D.

00:09:35.620 --> 00:09:37.780
We did this perspective divide thing.

00:09:37.780 --> 00:09:40.300
Why do I have a Z?" Well,
you can do depth sorting

00:09:40.340 --> 00:09:40.980
with this fragment.

00:09:40.990 --> 00:09:42.810
So when it's... If you have
depth sorting turned on,

00:09:42.810 --> 00:09:46.570
it turns into a fragment and says, "Hey,
am I in front of everything else?

00:09:46.570 --> 00:09:50.130
Am I fully topaq and am I in front of
everything else?" This is the fragment

00:09:50.220 --> 00:09:53.220
should actually be this fragment
instead of the fragment behind it.

00:09:53.220 --> 00:09:54.430
RGB is obvious.

00:09:54.430 --> 00:09:57.220
ST, R and Q are using texture mapping.

00:09:57.220 --> 00:10:00.510
But basically... So this converts
everything to the single pixel

00:10:00.510 --> 00:10:03.650
on the screen and allows it to
then be drawn to the screen.

00:10:04.100 --> 00:10:06.730
And lastly, we do fragment operations,
which is texturing and fog.

00:10:06.850 --> 00:10:09.750
So it says, "Hey, I got this colored
pixel." It may be white,

00:10:09.750 --> 00:10:12.350
it may be gray, it may be blue,
but now I want to find

00:10:12.750 --> 00:10:16.340
what piece of a texture map
corresponds to that single pixel,

00:10:16.340 --> 00:10:18.680
and I color that pixel with
my piece of the texture map,

00:10:18.680 --> 00:10:19.800
if we're doing texturing.

00:10:20.080 --> 00:10:22.740
If fog's applied,
it applies the appropriate fog,

00:10:22.740 --> 00:10:26.190
and it can do scissor checking,
scissor something down, alpha,

00:10:26.190 --> 00:10:29.000
stencil buffer, depth test,
all done in here.

00:10:29.000 --> 00:10:31.000
So this is why I talk about depth tests.

00:10:31.000 --> 00:10:34.000
So you're going to take multiple
fragments with different depths.

00:10:34.000 --> 00:10:36.000
It's going to take the front one,
but one could have an alpha value,

00:10:36.000 --> 00:10:38.990
so you may have some
different interactions there,

00:10:38.990 --> 00:10:40.000
but this is where it's done.

00:10:42.590 --> 00:10:44.000
Okay, what does OpenGL not have?

00:10:44.000 --> 00:10:45.840
This is what people
don't understand a lot.

00:10:45.900 --> 00:10:48.500
OpenGL doesn't have a
built-in windowing system.

00:10:48.500 --> 00:10:51.500
It doesn't know about Mac windows,
it doesn't know about Windows windows,

00:10:51.500 --> 00:10:53.960
it doesn't know about Unix windows,
it doesn't know how to

00:10:53.980 --> 00:10:55.500
draw things to the screen.

00:10:55.500 --> 00:11:01.500
So on the Mac we have AGL, we have NSGL,
we have GLUT, and we have NS OpenGL View.

00:11:01.500 --> 00:11:05.930
These are all ways to set up
an environment that OpenGL can

00:11:05.930 --> 00:11:08.500
use and use that to draw into.

00:11:08.600 --> 00:11:15.330
AGL is fairly simple to work with because
it can be used with OS 9 and OS 10.

00:11:15.600 --> 00:11:18.500
NSGL is going to be on 10,
GLUT is on OS 9 and OS 10,

00:11:18.500 --> 00:11:21.490
and NS OpenGL View is also on OS 10.

00:11:21.500 --> 00:11:23.500
There are different ways to work with it.

00:11:23.500 --> 00:11:27.500
The NSGL and the NS OpenGL View are
both object oriented.

00:11:27.500 --> 00:11:30.500
NS OpenGL View is kind of interesting
because you basically can do everything.

00:11:30.500 --> 00:11:33.900
You just instantiate an
NS OpenGL View object and it

00:11:33.920 --> 00:11:36.320
already sets up your OpenGL for you.

00:11:36.540 --> 00:11:37.500
You're ready to go.

00:11:37.500 --> 00:11:38.470
It also doesn't have a built-in window.

00:11:38.500 --> 00:11:38.500
It's a little bit more complicated.

00:11:38.500 --> 00:11:38.500
It's a little bit more complicated.

00:11:38.510 --> 00:11:39.490
It also doesn't have input methods.

00:11:39.490 --> 00:11:43.500
Input methods are OS specific things.

00:11:43.500 --> 00:11:46.550
So for example,
if you're in a Mac OS application,

00:11:46.550 --> 00:11:48.600
you're going to have to take
care of the normal keystrokes,

00:11:48.600 --> 00:11:49.500
those kind of things.

00:11:49.500 --> 00:11:50.890
OpenGL is just a graphics API.

00:11:50.890 --> 00:11:52.470
It does not have any kind of input.

00:11:52.500 --> 00:11:56.500
If you're using GLUT, obviously also,
which I'll talk a little bit about later,

00:11:56.500 --> 00:11:59.500
GLUT has its own keyboard
interface and mouse interface.

00:11:59.500 --> 00:12:01.490
It also does not have file handling.

00:12:01.490 --> 00:12:05.270
This is one of the things that
OpenGL being a lower level

00:12:05.270 --> 00:12:09.340
API rather than a high level API,
it doesn't have the handling of an

00:12:09.340 --> 00:12:11.480
importer for a certain kind of file.

00:12:11.770 --> 00:12:15.620
If you build a model in
Maya and you export it,

00:12:15.630 --> 00:12:21.490
it doesn't have intrinsically a way to
read that Maya model in and display that.

00:12:21.500 --> 00:12:26.500
You have to put that together or use
some sample code that's already created.

00:12:26.880 --> 00:12:28.930
It also does not have, like I said,
high-level modeling.

00:12:28.970 --> 00:12:31.190
It doesn't have any tools built
in to do high-level modeling or

00:12:31.190 --> 00:12:32.780
to understand high-level models.

00:12:32.800 --> 00:12:34.980
High-level models can have a
certain way of texture mapping.

00:12:34.980 --> 00:12:38.600
It also can have a certain way of
handling a hierarchical structure,

00:12:38.600 --> 00:12:39.790
like a skeleton.

00:12:39.810 --> 00:12:40.780
And that's not built in.

00:12:40.850 --> 00:12:43.250
You can decide how to do that,
and that's something for you

00:12:43.250 --> 00:12:44.800
to do in your applications.

00:12:44.800 --> 00:12:45.800
Or you don't have to.

00:12:45.800 --> 00:12:48.380
If you don't have high-level models,
you want to display some small

00:12:48.380 --> 00:12:50.800
things or some primitives or use
some of the primitive drawing,

00:12:50.800 --> 00:12:54.790
you don't have to build a complete
handling system for every file out there.

00:12:54.800 --> 00:12:58.800
Okay, now we're going to talk
about Apple's implementation.

00:12:58.960 --> 00:13:01.260
First thing I'll do is go
over a quick overview of what

00:13:01.270 --> 00:13:02.710
hardware we have out there.

00:13:02.800 --> 00:13:04.730
I know I probably have some
new Mac developers out here,

00:13:04.820 --> 00:13:05.750
probably have some old faithfuls here.

00:13:05.830 --> 00:13:06.800
This is going to be a
real review for you guys.

00:13:06.800 --> 00:13:10.790
Then I'll talk about some
frameworks for OS 9 and OS 10.

00:13:10.840 --> 00:13:12.800
I'll talk about what
extensions we're supporting.

00:13:12.800 --> 00:13:14.750
I'll talk a little bit about GLUT.

00:13:14.820 --> 00:13:17.420
And I'll talk about AGL and SetupGL.

00:13:18.780 --> 00:13:20.340
So current hardware is
obviously the iBook,

00:13:20.440 --> 00:13:24.260
the iMac, the PowerBook,
and the PowerMac.

00:13:24.340 --> 00:13:28.480
The iBook, the first part is standard,
but the key here if you're working

00:13:28.480 --> 00:13:32.490
with OpenGL is what kind of graphics
hardware is it going to support.

00:13:32.750 --> 00:13:34.960
It has a Rage Mobility
graphics processor,

00:13:34.960 --> 00:13:36.680
which is basically like a Rage Pro.

00:13:36.840 --> 00:13:39.400
It has 4 Mega VRAM and AGP2X.

00:13:39.650 --> 00:13:40.880
So what does that tell you?

00:13:40.940 --> 00:13:44.010
The 4 Mega VRAM says about
how much limitation you have

00:13:44.080 --> 00:13:46.980
on texturing and buffering.

00:13:47.170 --> 00:13:49.990
When you're working with OpenGL,
it's not critical to understand,

00:13:50.000 --> 00:13:53.560
but something you do want to understand
is the fact that if you're doing OpenGL,

00:13:53.560 --> 00:13:54.500
you have a front window.

00:13:54.600 --> 00:13:57.100
You have a screen that takes
up a certain amount of VRAM.

00:13:57.100 --> 00:14:00.100
You have a back buffer for your
OpenGL window that takes up VRAM.

00:14:00.100 --> 00:14:04.030
And you also have a depth
buffer which may take up VRAM.

00:14:04.270 --> 00:14:07.060
And any textures you upload are
also going to be in the VRAM.

00:14:07.100 --> 00:14:10.680
So thinking about what the
configurations you're shipping to,

00:14:10.680 --> 00:14:13.100
what kind of VRAM, is kind of critical.

00:14:13.100 --> 00:14:17.000
And also I would say testing on multiple
systems is also critical for OpenGL.

00:14:17.100 --> 00:14:19.100
I'll tell you a little story here.

00:14:19.100 --> 00:14:21.930
When I came in to do my demo,
I brought my PowerBook in.

00:14:22.100 --> 00:14:22.860
Works great.

00:14:22.860 --> 00:14:23.060
My demos run great.

00:14:23.170 --> 00:14:24.050
They're really simple.

00:14:24.050 --> 00:14:25.100
Shouldn't be any big deal.

00:14:25.100 --> 00:14:28.060
Hooked it up here,
turned on video mirroring.

00:14:28.240 --> 00:14:32.910
Forgot that the VRAM was split between
the mirrored and my PowerBook display.

00:14:33.100 --> 00:14:36.100
And when I loaded my texture,
it was doing texture paging.

00:14:36.100 --> 00:14:37.100
So that's something that's important.

00:14:37.100 --> 00:14:39.470
And that's a good reason to go
test your app on your multiple

00:14:39.590 --> 00:14:41.930
platforms and make sure you're
running and make sure you understand

00:14:41.930 --> 00:14:43.100
the constraints of running your app.

00:14:43.100 --> 00:14:47.050
iMac has a Rage 128
VR graphics processor.

00:14:47.110 --> 00:14:49.100
Really great thing to work with.

00:14:49.100 --> 00:14:53.100
I mean, if you have an iMac,
you can surely do OpenGL development.

00:14:53.100 --> 00:14:56.050
It has really good support
for OpenGL and is one of our,

00:14:56.060 --> 00:14:59.070
you know,
the Rage 128 is our top processor we're

00:14:59.070 --> 00:15:03.100
going to support as far as feature sets.

00:15:03.100 --> 00:15:05.100
So you're going to get
all the features there.

00:15:05.100 --> 00:15:06.100
8 Mega VRAM, that's good.

00:15:06.100 --> 00:15:07.090
AGP 2X also.

00:15:07.100 --> 00:15:08.310
Amen.

00:15:08.530 --> 00:15:11.820
PowerBook,
400 and 500 megahertz PowerBooks,

00:15:11.950 --> 00:15:14.700
ATI Rage Mobility 128
graphics controller,

00:15:14.780 --> 00:15:17.400
8 mega VRAM, and ATP2X.

00:15:17.400 --> 00:15:21.770
One thing that I have to say is
that this is one of the unsung

00:15:21.770 --> 00:15:25.380
heroes of our product line for me,
because I'm like, "This is great!

00:15:25.430 --> 00:15:28.790
You can get this,
you can do OpenGL work here." I mean,

00:15:28.790 --> 00:15:31.530
I used to develop OpenGL on a Rage 2,
which I had to do like

00:15:31.550 --> 00:15:34.310
a 200 by 100 window,
and looking at it,

00:15:34.310 --> 00:15:36.840
"Did it get right?" So,
this is great to have this,

00:15:36.890 --> 00:15:39.400
because you can develop
full-speed applications,

00:15:39.400 --> 00:15:42.970
you can develop full-screen applications,
you can work on your PowerBook wherever

00:15:42.970 --> 00:15:45.390
you are without having to
sacrifice the graphics processing.

00:15:45.400 --> 00:15:48.540
Another PowerMac,
the Rage 128 Pro graphics processor,

00:15:48.540 --> 00:15:50.400
up to 16 mega VRAM and ATP2X.

00:15:50.400 --> 00:15:53.360
There are also third-party
hardware that's supported for Mac.

00:15:53.510 --> 00:15:57.160
3DFX, both have good offerings.

00:15:57.480 --> 00:15:59.380
3DFX has obviously
announced full Mac support,

00:15:59.470 --> 00:16:02.390
and they're going to be rolling
out some really high-powered cards.

00:16:02.400 --> 00:16:07.660
So, we're looking also for people to add
on cards and get more performance

00:16:07.660 --> 00:16:10.400
even than we may supply initially.

00:16:11.410 --> 00:16:15.500
Okay, let's talk about how OpenGL is
structured in the OS.

00:16:15.650 --> 00:16:19.940
So for Mac OS 9 implementation framework,
we have an application,

00:16:20.020 --> 00:16:21.360
we have a little setup code.

00:16:21.580 --> 00:16:23.740
The reason I segment
those out is because,

00:16:23.740 --> 00:16:26.540
as I said,
OpenGL does not have a windowing system.

00:16:26.540 --> 00:16:28.400
It does not know all about
how to draw to a window.

00:16:28.400 --> 00:16:30.930
It does not know what
your windows are like.

00:16:30.960 --> 00:16:32.800
So the setup code is what handles that.

00:16:32.800 --> 00:16:36.950
So when I say setup,
I say constructing your window

00:16:36.950 --> 00:16:38.790
and telling OpenGL this is
where it's going to draw.

00:16:39.320 --> 00:16:41.700
Two ways to do setup in Mac OS 9.

00:16:41.700 --> 00:16:43.980
Through the GLUT,
which GLUT handles the setup for you.

00:16:43.990 --> 00:16:45.520
Basically you say, "Hey,
this is my window.

00:16:45.710 --> 00:16:48.180
Here's what I want," and
it builds it for you.

00:16:48.290 --> 00:16:51.050
Or AGL,
which you build your window and you say,

00:16:51.170 --> 00:16:53.050
"I want a certain pixel format.

00:16:53.150 --> 00:16:54.140
Here's my drawable.

00:16:54.200 --> 00:16:56.250
It's that window,
and I'm going to pass it to you,

00:16:56.250 --> 00:16:58.600
and you're going to take care of that,
and you're going to use that

00:16:58.600 --> 00:17:02.410
for me." Once you get past that,
you can see that then you actually

00:17:02.410 --> 00:17:04.200
can talk to OpenGL directly.

00:17:04.200 --> 00:17:07.670
The application for GLUT application
can actually do some things

00:17:07.670 --> 00:17:10.890
in GLUT to produce output,
but also it can go directly to

00:17:10.890 --> 00:17:13.200
OpenGL once you have the setup done.

00:17:13.200 --> 00:17:15.090
Then you go through OpenGL,
make all the GL calls once

00:17:15.190 --> 00:17:17.030
you have the setup done,
and then that passes

00:17:17.250 --> 00:17:20.870
through to the drivers,
which handle actually rasterizing

00:17:20.870 --> 00:17:23.420
and drawing things to the screen.

00:17:25.730 --> 00:17:28.300
OS X is a little more complicated.

00:17:28.380 --> 00:17:30.270
OS X, there's a lot of
different ways to set up.

00:17:30.380 --> 00:17:34.970
But if you notice that the application
still is using GLUT or is using OpenGL.

00:17:34.970 --> 00:17:36.410
That hasn't changed.

00:17:36.530 --> 00:17:39.370
You can pick a lot of different
options for setting up.

00:17:39.530 --> 00:17:43.180
But in reality, your OpenGL,
your application code doesn't change.

00:17:43.180 --> 00:17:45.560
I have a number of examples I've
been working on over the past few

00:17:45.560 --> 00:17:48.960
weeks for some of the demos and
just for some of my stuff on OS X.

00:17:48.960 --> 00:17:51.400
And I didn't change
any of my OpenGL code.

00:17:51.400 --> 00:17:51.850
None.

00:17:51.850 --> 00:17:52.300
Zero.

00:17:52.300 --> 00:17:54.740
I mean,
all I did was change my setup code,

00:17:54.740 --> 00:17:56.130
which is really a good story.

00:17:56.240 --> 00:17:58.540
Because it means that you can
move your applications that may

00:17:58.540 --> 00:18:01.720
be on 9 forward and you can create
applications that run on 10,

00:18:01.720 --> 00:18:05.020
run on 9, run on Windows,
run on Unix without having to change your

00:18:05.020 --> 00:18:07.140
code for every single platform specific.

00:18:07.160 --> 00:18:09.300
You just have to change
some of the setup stuff.

00:18:09.300 --> 00:18:11.310
We talked about some of these.

00:18:11.310 --> 00:18:14.000
The NSOpenGL view is available in Cocoa.

00:18:14.000 --> 00:18:16.550
We also have GLUT,
which is going to be available.

00:18:16.580 --> 00:18:19.970
And the GLUT that's available will
be available on OS X and OS 9.

00:18:19.970 --> 00:18:23.780
And there are different implementations,
but they should be code compatible.

00:18:23.780 --> 00:18:29.630
GLUT is a, if you don't know, is a,
basically a free,

00:18:29.840 --> 00:18:33.070
not freely distributable as far as,
better way to say that.

00:18:33.110 --> 00:18:35.320
It is not given to you free.

00:18:35.320 --> 00:18:37.120
We, it's not our application.

00:18:37.120 --> 00:18:39.780
Mark Kilgard, who used to work at SGI,
wrote it.

00:18:39.780 --> 00:18:41.910
And he distributes it freely,
but it's not,

00:18:41.910 --> 00:18:43.750
he still owns the source code.

00:18:43.750 --> 00:18:47.340
You're not free to go and change
it and call it yours and resell

00:18:47.340 --> 00:18:48.520
it or something like that.

00:18:48.520 --> 00:18:50.030
NSGL is also there.

00:18:50.130 --> 00:18:54.420
GLUT is implemented on top of it
and NSGL OpenView calls into NSGL.

00:18:54.420 --> 00:18:55.560
AGL is there.

00:18:55.560 --> 00:19:00.200
Works,
works basically the same on 10 and 9.

00:19:00.200 --> 00:19:03.360
They call into the low
level core graphics GL,

00:19:03.360 --> 00:19:08.360
so it's CGL and that goes to
the kernel and to the drivers.

00:19:08.360 --> 00:19:10.780
So the key here is to
understand is there's lots

00:19:10.780 --> 00:19:12.090
more ways to get out of OpenGL.

00:19:12.170 --> 00:19:14.300
If you have a Cocoa application,
no problem.

00:19:14.440 --> 00:19:17.740
Set up OpenGL through Cocoa,
through NSGL, off you go.

00:19:17.880 --> 00:19:19.410
Dave Springer is going
to talk in the next talk.

00:19:19.420 --> 00:19:22.120
We'll show you some demonstrations of
using NSGL and show you how easy it is.

00:19:22.290 --> 00:19:25.210
and show you how easy that can be.

00:19:25.670 --> 00:19:28.160
Okay, this is what we have for
extensions right now.

00:19:28.210 --> 00:19:31.360
A couple Apple extensions that
may improve some rendering,

00:19:31.360 --> 00:19:34.430
some transform hints,
compile vertex array for speed,

00:19:34.550 --> 00:19:36.800
Quake uses that, multi-texture,
Quake uses that too,

00:19:36.800 --> 00:19:41.010
a lot of people use multi-texture,
get the texture working,

00:19:41.010 --> 00:19:42.450
and text-dnv-add.

00:19:42.600 --> 00:19:44.650
Well,
what I'm going to tell you right now is

00:19:44.650 --> 00:19:48.090
that we've had a lot of developers say,
"I need this, I need pack pixels,

00:19:48.230 --> 00:19:52.600
I need this other format." Actually,
let me back up a little bit.

00:19:52.600 --> 00:19:53.600
Extensions to OpenGL.

00:19:53.600 --> 00:19:56.080
For those of you not familiar,
but I may have moved a little

00:19:56.180 --> 00:19:59.200
bit too fast here with OpenGL,
OpenGL has a particular

00:19:59.200 --> 00:20:00.560
graphics API it defines.

00:20:00.600 --> 00:20:04.600
It has a method by providing
extensions that extend that API.

00:20:04.600 --> 00:20:09.600
For example, with the multi-texture,
it allows you to do multi-texturing,

00:20:09.600 --> 00:20:12.810
layering more than one texture on
top of each other in OpenGL and

00:20:12.810 --> 00:20:15.730
passing that to the OpenGL pipeline,
rather than having to do it in software,

00:20:15.730 --> 00:20:18.600
where you might blend things together
and then pass it as a single texture.

00:20:18.600 --> 00:20:23.570
So, there's a litany of extensions,
there's a lot of extensions out there.

00:20:23.600 --> 00:20:26.600
We picked some of those to implement.

00:20:26.600 --> 00:20:32.600
Some of them are vendor-specific,
so they might be an SGI-only thing.

00:20:32.600 --> 00:20:37.600
And some of them are the ext type,
which are multi-vendor.

00:20:37.920 --> 00:20:39.980
Obviously,
we have two vendor-specific ones here,

00:20:39.980 --> 00:20:41.600
and the rest are multi-vendor.

00:20:41.760 --> 00:20:45.400
There's a lot of other extensions that
people say can handle textures better,

00:20:45.400 --> 00:20:47.600
can do some more kind
of combining textures.

00:20:47.600 --> 00:20:50.590
And we, up to this point,
haven't supported that.

00:20:50.800 --> 00:20:54.250
What I can say is that, basically,
as of... I'll tell you the

00:20:54.460 --> 00:20:55.570
availability when I get there.

00:20:55.620 --> 00:20:56.600
I'll tell you the availability right now.

00:20:56.600 --> 00:21:00.580
OS 9, VADC seeding,
and very shortly we're going to

00:21:00.580 --> 00:21:05.600
have these extensions available
on a seed for OpenGL 1.2,

00:21:05.600 --> 00:21:08.590
which will be a 1.2.2 compliant OpenGL.

00:21:08.770 --> 00:21:13.350
One of the keys here is our software
implementation and the API that you

00:21:13.350 --> 00:21:16.600
can write to is 1.2.2 compliant.

00:21:16.600 --> 00:21:18.590
So, OpenGL, there's two pieces.

00:21:18.590 --> 00:21:21.600
There's a driver piece,
and there's our implementation piece.

00:21:21.600 --> 00:21:25.560
As drivers come up to speed with 1.2.2,
you get a full OpenGL 1.2.2

00:21:25.560 --> 00:21:26.600
implementation.

00:21:26.600 --> 00:21:30.590
But the key here is you can get these
extensions very shortly from seeding,

00:21:30.730 --> 00:21:33.570
and then after that,
they'll be in our next OS rev

00:21:33.710 --> 00:21:36.470
when we bring that out,
next OpenGL rev.

00:21:36.600 --> 00:21:40.660
Also, for OS X,
the same set of extensions will be

00:21:40.660 --> 00:21:43.520
available for OS X very shortly.

00:21:43.680 --> 00:21:45.600
So, for developers who want to
look and use these things,

00:21:45.600 --> 00:21:50.760
they'll be available very shortly,
and pay attention to the OpenGL list,

00:21:51.020 --> 00:21:55.280
and also in the ADC seeding,
and they should be available for

00:21:55.280 --> 00:21:58.600
download and for installation
onto DP4 or onto Mac OS 9.

00:21:58.600 --> 00:22:02.150
We're looking for Apple PAC pixels,
and some people who are familiar

00:22:02.160 --> 00:22:03.890
with PAC pixels are saying,
"Why is it Apple PAC pixels?" We're

00:22:04.010 --> 00:22:07.520
extending it a little bit to recognize
the kind of pixel formats we need,

00:22:07.800 --> 00:22:10.590
but it should be the same
as the normal PAC pixels.

00:22:10.620 --> 00:22:11.600
We have a transpose matrix.

00:22:11.600 --> 00:22:14.600
We have an ABGR,
so we can do different pixel orders.

00:22:14.600 --> 00:22:17.600
We have pixel ordering,
pixel color ordering,

00:22:17.600 --> 00:22:19.600
and a whole bunch of others.

00:22:19.600 --> 00:22:21.950
We may even add to this if we
see that there are some that

00:22:21.950 --> 00:22:23.580
the developers are looking for.

00:22:23.600 --> 00:22:26.720
So, this is, I think,
good news for developers,

00:22:26.730 --> 00:22:30.600
and we can really extend your
ability to develop on the platform.

00:22:31.000 --> 00:22:33.000
Okay, let's talk about GLUT a little bit.

00:22:33.240 --> 00:22:36.000
GLUT is GL Utility Toolkit.

00:22:36.000 --> 00:22:38.640
As I said,
it was written by Mark Kilgard of SGI.

00:22:38.930 --> 00:22:40.700
Written a number of years ago.

00:22:40.700 --> 00:22:45.000
It's available as source code through
a number of different vendors.

00:22:45.000 --> 00:22:48.000
We give it out with our
SDKs also as source code.

00:22:48.000 --> 00:22:51.190
When we first brought
the OpenGL SDK 1.0 out,

00:22:51.190 --> 00:22:53.210
we brought GLUT over to the Mac.

00:22:53.210 --> 00:22:54.940
It's on Windows and Unix.

00:22:55.100 --> 00:22:59.950
We ported that in the 3.6 format,
which had some things that it lacked.

00:23:00.070 --> 00:23:02.950
We ported that to the
Mac with the 1.0 SDK.

00:23:03.000 --> 00:23:05.860
Shortly we'll be releasing
the 3.7 version of GLUT,

00:23:05.860 --> 00:23:08.000
which includes a couple of new things.

00:23:08.000 --> 00:23:14.180
It included game mode or game GLUT,
which basically allows you to

00:23:14.180 --> 00:23:17.000
get a full screen mode on GLUT.

00:23:17.000 --> 00:23:18.000
Also some contextual information.

00:23:18.000 --> 00:23:20.070
We have contextual menu support,
which is a normal way

00:23:20.150 --> 00:23:21.000
for GLUT to operate.

00:23:21.000 --> 00:23:24.100
We're finishing this up right now,
and this should be sealed up and should

00:23:24.100 --> 00:23:25.930
be out with our next SDK release shortly.

00:23:26.000 --> 00:23:29.710
Some bug fixes we're on 9 are
better child window handling

00:23:29.710 --> 00:23:32.000
and just some general bug fixes.

00:23:32.000 --> 00:23:37.000
3.7 will be available for
Mac OS 9 and Mac OS X.

00:23:37.000 --> 00:23:40.200
I have to actually think
that is this correct,

00:23:40.200 --> 00:23:45.230
but the 3.7 API, maybe minus game mode,
should be on the DP4 CD,

00:23:45.260 --> 00:23:46.820
and that's correct.

00:23:47.000 --> 00:23:47.980
So GLUT is a little bit different.

00:23:48.080 --> 00:23:50.330
The 3.7 is on DP4,
and a significant amount of

00:23:50.330 --> 00:23:52.990
the examples that we have going
with it will be there also.

00:23:53.000 --> 00:23:56.890
So why should we use GLUT?

00:23:57.000 --> 00:23:59.580
I would honestly say GLUT is probably
not something you would want to

00:23:59.580 --> 00:24:01.000
use for a shipping application.

00:24:01.000 --> 00:24:02.880
If you want to build a
little bit of OpenGL,

00:24:02.880 --> 00:24:03.760
experiment with it.

00:24:04.000 --> 00:24:08.620
If you want to check out a rendering
technique or do some work on an engine

00:24:08.620 --> 00:24:12.110
that you may want to put into GLUT,
that might be a good framework

00:24:12.110 --> 00:24:13.000
just to work with it.

00:24:13.000 --> 00:24:16.990
It provides an API or
a platform agnostic.

00:24:17.000 --> 00:24:18.930
I

00:24:19.150 --> 00:24:21.100
A GUI environment.

00:24:21.100 --> 00:24:22.850
I'll say GUI,
a little bit of a GUI environment.

00:24:22.920 --> 00:24:26.100
Basically gives the platform setup,
the setup for the Windows,

00:24:26.100 --> 00:24:29.090
handles some input, handles keyboard,
handles some mouse events,

00:24:29.190 --> 00:24:31.100
handles menus and those kind of things.

00:24:31.150 --> 00:24:36.120
And your code can go from Windows to
Mac to UNIX without really any changes.

00:24:37.770 --> 00:24:38.930
AGL and SetupGL.

00:24:38.940 --> 00:24:41.050
I alluded to this a little bit earlier.

00:24:41.160 --> 00:24:43.600
We talked about AGL and SetupGL.

00:24:43.600 --> 00:24:46.290
AGL is Apple GL.

00:24:46.410 --> 00:24:50.330
It's basically our interface to the GL.

00:24:50.340 --> 00:24:52.700
So this is the thing that
handles Windows setup.

00:24:52.700 --> 00:24:56.990
It handles basically
all the pixel formats.

00:24:57.040 --> 00:24:59.700
It handles some utility
and some error codes.

00:24:59.700 --> 00:25:02.000
AGL is available on Mac OS 9.

00:25:02.020 --> 00:25:05.690
It's also available on
Mac OS X for Carbon.

00:25:05.690 --> 00:25:10.620
And you can write basically the
same code in Mac OS 9 and Mac OS X.

00:25:10.800 --> 00:25:15.700
And I've been working on some stuff
that basically compiles one binary,

00:25:15.700 --> 00:25:19.700
runs on 9, runs on 10,
runs on OS 9 as an OS non-Carbon.

00:25:19.700 --> 00:25:22.940
And I'm sorry, one set of code and the
same code runs on 10.

00:25:22.940 --> 00:25:24.700
It wasn't that difficult to do.

00:25:24.700 --> 00:25:28.700
They were talking about a
few weeks to carbonize it.

00:25:28.700 --> 00:25:29.700
It took me two weeks to do it.

00:25:29.700 --> 00:25:31.700
Maybe, you know, probably an afternoon.

00:25:31.700 --> 00:25:34.690
Probably really four or
five hours at one sitting.

00:25:34.700 --> 00:25:36.700
It's better to cost two or three days.

00:25:36.750 --> 00:25:37.690
And what is SetupGL?

00:25:37.770 --> 00:25:41.370
If you're not familiar with OpenGL on
the Mac and you're not paying

00:25:41.370 --> 00:25:44.700
attention to our OS OpenGL news group,
you probably haven't heard of it.

00:25:44.700 --> 00:25:48.590
It's actually a piece of sample code
that you can have all the source to.

00:25:48.760 --> 00:25:52.700
What I try to do is in our sample code,
we have a section we call more is better.

00:25:52.700 --> 00:25:54.570
And there's more network setup.

00:25:54.670 --> 00:25:58.670
There's more files that some of
our other engineers have written.

00:25:58.740 --> 00:26:02.330
And what they've done is basically
trying to encapsulate a real significant

00:26:02.330 --> 00:26:05.700
piece of the functionality that you
will need into a piece of sample code.

00:26:05.700 --> 00:26:08.100
Instead of having a
sample code that shows,

00:26:08.100 --> 00:26:10.700
okay,
here's how to draw a square in OpenGL.

00:26:10.700 --> 00:26:13.280
Instead of just doing
the absolute minimum,

00:26:13.280 --> 00:26:16.700
try to do better error checking,
better error returns.

00:26:16.700 --> 00:26:19.310
Try to add in actually handling,
you know,

00:26:19.310 --> 00:26:23.650
your VRAM requirements so you can
send a different VRAM requirements.

00:26:24.030 --> 00:26:27.700
Handle full screen window switching.

00:26:27.700 --> 00:26:29.700
So one call can get you
a full screen context.

00:26:29.700 --> 00:26:32.860
You can destroy that context
and call one call again and get

00:26:32.860 --> 00:26:34.690
you a window to the same thing.

00:26:34.700 --> 00:26:37.700
So it's not limited to
just doing one thing.

00:26:37.700 --> 00:26:40.700
So I think it's a reasonable
thing to start with.

00:26:40.700 --> 00:26:44.700
It gives you either a good base of
source code or you can use it directly.

00:26:44.700 --> 00:26:46.700
SetupGL is Mac OS 9 currently.

00:26:46.700 --> 00:26:47.690
And I say Carbon soon.

00:26:47.700 --> 00:26:48.670
That's actually not correct.

00:26:48.790 --> 00:26:52.700
As of when this presentation was written,
it was Carbon soon.

00:26:52.700 --> 00:26:59.700
Now it is carbonized and it should
be out this week on... on the ADCC.

00:26:59.700 --> 00:27:01.620
It should be on the sample code site.

00:27:01.700 --> 00:27:04.730
You should have a Carbon version of
it that you can run in Carbon and

00:27:04.730 --> 00:27:09.700
run on Mac OS X DP4 and in OS 9.

00:27:11.580 --> 00:27:14.160
So AGL, we're going to talk a little bit
more about AGL and a little bit

00:27:14.160 --> 00:27:16.260
more about the specifics of AGL.

00:27:16.570 --> 00:27:18.500
AGL handles,
we're going to talk about the basics,

00:27:18.500 --> 00:27:21.480
and it handles pixel formats,
handles context, drawables,

00:27:21.570 --> 00:27:23.000
swapping fonts, and errors.

00:27:23.000 --> 00:27:24.500
So what are all of those things?

00:27:24.930 --> 00:27:26.500
First, the basics.

00:27:26.500 --> 00:27:30.260
As we talked about before,
it handles setups, it handles swaps,

00:27:30.260 --> 00:27:32.500
and it provides utility function.

00:27:32.500 --> 00:27:35.470
If you're familiar with Windows at all,
you'll see that an AGL drawable,

00:27:35.520 --> 00:27:39.500
which is defined as AGL,
and that's the main construct that

00:27:39.500 --> 00:27:41.500
you're going to pass to GL and say
this is what you're going to use.

00:27:41.500 --> 00:27:44.470
It's equivalent basically
to a C window pointer,

00:27:44.490 --> 00:27:47.420
which is also equivalent
on Windows to an HDC.

00:27:47.450 --> 00:27:51.690
So that's kind of the equivalency
if you're coming from WGL.

00:27:52.070 --> 00:27:57.000
The key here is that people
sometimes try and get away from it,

00:27:57.000 --> 00:27:59.000
"Well, I can use a C graph pointer.

00:27:59.010 --> 00:28:02.950
I can just point to my off screen,
or I can point to this piece of memory,

00:28:03.040 --> 00:28:04.000
I can point to whatever.

00:28:04.000 --> 00:28:07.410
I can grab a C graph pointer on the
screen and just draw to that." A key,

00:28:07.420 --> 00:28:10.920
a real key for GL here is it uses
the information in the window

00:28:10.920 --> 00:28:14.990
pointer to figure out what piece
of hardware you're rendering on.

00:28:15.000 --> 00:28:17.990
If you have two cards, one's 3DFX,
one's Apple,

00:28:18.000 --> 00:28:22.330
and you drag your window from
one monitor to the other,

00:28:22.330 --> 00:28:22.330
using

00:28:22.560 --> 00:28:27.760
AGL correctly if you have a window
pointer you can fairly easily do

00:28:27.780 --> 00:28:30.550
that and it will render on one and it
will render on the other no problem.

00:28:30.620 --> 00:28:34.370
If you pass it a C graph pointer,
probably best case is if you

00:28:34.490 --> 00:28:36.490
start on your main monitor
it will render correctly.

00:28:36.490 --> 00:28:38.120
If you move it off it
may not render anything.

00:28:38.120 --> 00:28:39.770
If you start on,
if you have your window on your

00:28:39.770 --> 00:28:42.860
secondary monitor and you pass a
C graph pointer it will probably draw

00:28:42.860 --> 00:28:46.480
on the upper right corner of your main
monitor just over everything else.

00:28:46.480 --> 00:28:47.760
So the key here is use a window.

00:28:47.760 --> 00:28:50.010
The window information is important,
you can't substitute a

00:28:50.010 --> 00:28:52.560
C graph pointer in this case.

00:28:52.560 --> 00:28:53.200
An AGL context.

00:28:53.200 --> 00:28:59.640
An AGL context basically maintains an
AGL state and a GL state with that.

00:28:59.640 --> 00:29:02.110
So basically you can switch
between contexts and now switch

00:29:02.220 --> 00:29:04.760
between one rendering state
to another rendering state.

00:29:04.800 --> 00:29:06.940
And that's the same as HGLRC.

00:29:07.000 --> 00:29:09.740
I love this one man, this is great.

00:29:09.740 --> 00:29:14.010
We have a nice AGL context
and they have capital HGLRC.

00:29:14.240 --> 00:29:17.070
So what is an AGL pixel format?

00:29:17.370 --> 00:29:20.440
You say,
isn't that like what's on the screen?

00:29:20.540 --> 00:29:21.600
Well, not quite.

00:29:21.700 --> 00:29:23.440
An AGL pixel format may be a misnomer.

00:29:23.440 --> 00:29:27.240
AGL pixel format actually is
a request for a drawing mode.

00:29:27.470 --> 00:29:28.620
It has some more things in it.

00:29:28.620 --> 00:29:29.740
You can tell it.

00:29:29.740 --> 00:29:32.470
You know, RGBA,
you can say you want a double buffer.

00:29:32.480 --> 00:29:36.360
You can say you want a back buffer,
or a depth buffer.

00:29:36.500 --> 00:29:38.150
You can say how deep
that depth buffer is.

00:29:38.270 --> 00:29:40.820
There's a lot of specification
to the AGL pixel format.

00:29:40.820 --> 00:29:46.320
And it's not just saying I want 32 bits,
16 bits, 8 bits, whatever.

00:29:46.320 --> 00:29:46.850
It's more than that.

00:29:46.860 --> 00:29:48.160
We'll go through that in a minute.

00:29:48.210 --> 00:29:52.060
But it's equivalent to the
pixel format descriptor.

00:29:52.080 --> 00:29:53.040
I like that.

00:29:53.040 --> 00:29:55.690
So moving on.

00:29:55.910 --> 00:29:56.710
Pixel formats.

00:29:56.830 --> 00:29:57.730
Okay.

00:29:57.930 --> 00:30:02.040
So the two main things we're going
to use is AGL Choose Pixel Format

00:30:02.250 --> 00:30:03.800
and AGL Destroy Pixel Format.

00:30:03.800 --> 00:30:07.790
And please, if you're doing GL,
check for errors, check for AGL errors.

00:30:07.790 --> 00:30:10.340
It's reasonable that when,
if you give it a pixel format

00:30:10.480 --> 00:30:13.930
that's not supported on a card
or on software or on this other

00:30:13.950 --> 00:30:17.120
monitor you're using or whatever,
then it may fail.

00:30:17.120 --> 00:30:20.620
And if you go off in your merry way and
set up your context and draw your GL,

00:30:20.620 --> 00:30:23.250
you're wondering why you're not getting
anything or why your program's crashing,

00:30:23.260 --> 00:30:26.320
it's because you could have not
returned a valid pixel format.

00:30:26.400 --> 00:30:28.440
It says, hey, I can't do this.

00:30:28.440 --> 00:30:30.080
So you have a set of attributes there.

00:30:30.080 --> 00:30:32.160
And what do those
attributes actually say?

00:30:32.160 --> 00:30:35.760
Well, in this case,
it's telling AGL that you want a red,

00:30:35.760 --> 00:30:38.220
green, blue, and alpha buffer.

00:30:38.220 --> 00:30:39.360
You want it to be accelerated.

00:30:39.390 --> 00:30:40.920
You want it to be double buffered.

00:30:40.920 --> 00:30:43.180
And then the AGL none
says you terminate that,

00:30:43.260 --> 00:30:44.640
that set of attributes.

00:30:44.640 --> 00:30:49.900
You'll do this, this for every kind of
pixel format you work with.

00:30:49.900 --> 00:30:52.840
You can add the double back
buffering to that or depth buffer.

00:30:52.840 --> 00:30:53.270
You add that and you want to
have a double back buffer.

00:30:53.270 --> 00:30:54.540
And then you want to have
a double back buffer.

00:30:54.660 --> 00:30:56.880
And after that, you specify the depth,
how many pixels your back buffer,

00:30:56.880 --> 00:31:00.660
or I'm sorry,
how many bits your back buffer is.

00:31:00.660 --> 00:31:01.940
What are some other
things you can specify?

00:31:01.940 --> 00:31:08.180
You can specify or you can ask for how
many bits for each component you want.

00:31:08.200 --> 00:31:13.880
And one of the keys here is that,
is the AGL accelerated in that string.

00:31:13.880 --> 00:31:16.810
AGL accelerated, I think I've written,
or maybe I didn't write,

00:31:16.820 --> 00:31:18.460
I can't remember actually.

00:31:18.460 --> 00:31:20.280
There is a, actually there is.

00:31:20.280 --> 00:31:22.690
There's a Q&A about
AGL choose pixel format,

00:31:22.790 --> 00:31:26.310
which I would recommend anyone who's
looking to open GL to read and look at.

00:31:26.320 --> 00:31:29.820
There's some caveats on how this works
and it's probably more in depth that

00:31:29.820 --> 00:31:31.560
I can go into it in this setting.

00:31:31.560 --> 00:31:34.920
But realize that it may not be obvious
how it's choosing pixel format.

00:31:35.000 --> 00:31:37.770
It's very logical and it's very
easy to figure out once you know it,

00:31:37.770 --> 00:31:40.120
but it may not be obvious
first looking at it.

00:31:40.120 --> 00:31:43.940
For example, what it tries to do is tries
to match across any possible

00:31:43.950 --> 00:31:47.140
display that you pass it,
this pixel format.

00:31:47.140 --> 00:31:51.160
So if I have four displays and I say
I want this pixel format anywhere,

00:31:51.170 --> 00:31:53.360
but having two of those displays
are not on accelerated AGL,

00:31:53.370 --> 00:31:54.540
I'm going to have to do
a little bit of a test.

00:31:54.600 --> 00:31:55.730
So if I have a display that's
not on accelerated card at all,

00:31:55.730 --> 00:31:56.560
I pull some cards out of the junk bin,
put them in there.

00:31:56.630 --> 00:31:57.170
It'll fail.

00:31:57.170 --> 00:31:59.650
It'll say, hey,
I can't accelerate this because I,

00:31:59.650 --> 00:32:01.480
these two don't have GL renders on it.

00:32:01.560 --> 00:32:03.840
So that's, and people will say, no,
why is it failing?

00:32:03.850 --> 00:32:07.700
I have my Rage 128, I want to,
that's where the window is and so.

00:32:08.000 --> 00:32:10.740
There's some nuances there
as far as selecting displays

00:32:10.740 --> 00:32:11.740
and what you want to do.

00:32:11.740 --> 00:32:13.740
If you want a window to be draggable,
you want to,

00:32:13.740 --> 00:32:16.010
you want to make sure you do a
choose pixel format for all the

00:32:16.010 --> 00:32:17.450
displays you could drag it across.

00:32:17.560 --> 00:32:20.900
If you want a window not to be draggable,
you want to probably limit it to

00:32:20.900 --> 00:32:22.560
the display that you're actually on.

00:32:22.560 --> 00:32:23.560
So that's some nuances there.

00:32:23.560 --> 00:32:25.550
So that's an AGL choose pixel format.

00:32:25.550 --> 00:32:26.210
But then it's real simple.

00:32:26.210 --> 00:32:28.440
You call AGL choose pixel format,
you pass in an HGD,

00:32:28.440 --> 00:32:32.470
you tell it how many displays that
you're passing in a list of HGDs,

00:32:32.480 --> 00:32:34.550
and you pass it the attributes.

00:32:34.620 --> 00:32:37.560
So in this case, we're going to say I'm
on this HGD handle,

00:32:37.600 --> 00:32:43.170
I'm sorry, that's my shorthand,
handle to a G device or a GD handle.

00:32:43.170 --> 00:32:49.220
And I have one monitor and I want to run
on that monitor and here's my attributes.

00:32:49.220 --> 00:32:51.630
When you're done with it,
you call AGL destroy pixel format.

00:32:51.830 --> 00:32:54.560
When you're done means when
you're done creating it.

00:32:54.560 --> 00:32:57.540
You don't need to keep it around
until you're finished with GL.

00:32:57.560 --> 00:33:00.140
You can actually create it,
assign it to a context,

00:33:00.270 --> 00:33:04.400
attach the drawable and off you
go and destroy it right then.

00:33:05.800 --> 00:33:06.690
So context.

00:33:06.770 --> 00:33:08.700
Next step in the process,
you have a pixel format.

00:33:08.700 --> 00:33:11.850
You said I want to do RGB,
I want to have a double buffer,

00:33:11.860 --> 00:33:14.940
I want to have a depth buffer, etc.

00:33:14.940 --> 00:33:17.700
Now I have my pixel
format for those displays.

00:33:17.700 --> 00:33:21.020
Now you want to create a GL context
that you're drawing in which,

00:33:21.020 --> 00:33:23.700
say, CASELE can encapsulate the GL state.

00:33:23.800 --> 00:33:25.100
You can have more than one of these,
by the way.

00:33:25.100 --> 00:33:26.700
It doesn't mean you have
to have one of everything.

00:33:26.700 --> 00:33:29.700
You can have as many as you
really want to work with.

00:33:29.700 --> 00:33:31.700
I'd recommend, depending on what you do,
you look carefully at the

00:33:31.700 --> 00:33:34.700
difference between a pixel format,
a context, and a drawable.

00:33:34.700 --> 00:33:38.440
You may want to create one pixel format,
create a context,

00:33:38.440 --> 00:33:42.690
and create a couple drawables to
that pixel format and context.

00:33:42.700 --> 00:33:45.510
Or if you have maybe a window that
you don't need any depth buffer,

00:33:45.580 --> 00:33:48.780
then maybe you have a different pixel
format for that without a depth buffer

00:33:48.780 --> 00:33:50.420
and a context that encapsulates that.

00:33:50.730 --> 00:33:53.110
But if you have everything
that needs the same thing,

00:33:53.150 --> 00:33:55.870
everything needs a depth buffer,
everything needs RGBA,

00:33:55.870 --> 00:34:00.400
everything needs to be accelerated,
you can use one context and create

00:34:00.600 --> 00:34:03.690
multiple drawables for that context.

00:34:03.700 --> 00:34:04.590
This is simple.

00:34:04.720 --> 00:34:07.060
This is basically,
you pass it in a pixel format,

00:34:07.090 --> 00:34:09.600
you pass in null,
and you just create a context.

00:34:09.700 --> 00:34:11.610
Pretty simple.

00:34:11.840 --> 00:34:13.450
You get the context out,
check your errors,

00:34:13.460 --> 00:34:16.700
and when you're done with it,
you actually want to destroy it.

00:34:16.700 --> 00:34:20.630
Another thing is set current context.

00:34:20.630 --> 00:34:23.620
If you have multiple contexts,
you want to do set current context when

00:34:23.620 --> 00:34:25.630
you want to draw more than one context.

00:34:25.730 --> 00:34:30.700
One of the things that I also find
that people miss is AGL update context.

00:34:30.700 --> 00:34:32.690
It's not on the slide,
but I'll go over it a little bit.

00:34:32.700 --> 00:34:37.110
If you're moving your window,
sizing your window, showing your window

00:34:37.160 --> 00:34:39.640
or hiding your window,
you definitely want to

00:34:39.640 --> 00:34:40.700
do AGL update context.

00:34:40.700 --> 00:34:45.230
It lets AGL tell OpenGL how
to reset the drawables and

00:34:45.370 --> 00:34:48.700
reallocate buffers if necessary.

00:34:48.700 --> 00:34:51.350
For example, if you size a window,
we have to reallocate

00:34:51.440 --> 00:34:52.650
the back buffer there.

00:34:52.720 --> 00:34:54.470
We have to make sure that we
have a new back buffer that's

00:34:54.550 --> 00:34:55.570
the right size of the window.

00:34:55.780 --> 00:34:58.420
So it's not a good thing to
do these updates without,

00:34:58.420 --> 00:35:01.670
or do updates to your window
without actually telling it.

00:35:01.760 --> 00:35:03.700
Same thing if you move from
one renderer to another,

00:35:03.700 --> 00:35:07.280
we need to tell GL to not use the
RAID 1.28 and to use the VUDU that

00:35:07.280 --> 00:35:09.470
you have on this other monitor.

00:35:13.980 --> 00:35:15.900
Okay, drawables.

00:35:15.900 --> 00:35:17.580
Real simple set drawable.

00:35:17.580 --> 00:35:19.230
You basically,
all the set drawable's going to do is

00:35:19.230 --> 00:35:20.850
going to attach a drawable to a context.

00:35:20.910 --> 00:35:22.890
You can say, "I want to draw into
this window," basically.

00:35:22.900 --> 00:35:25.900
And so you can have five windows,
or you can have, for example,

00:35:25.900 --> 00:35:29.920
the standard CAD program has three views:
top, left, front,

00:35:29.920 --> 00:35:31.900
and the projection view.

00:35:31.900 --> 00:35:34.860
What you could do is you could set
up those three are orthographic.

00:35:34.950 --> 00:35:36.900
You set those three up
that basically have,

00:35:37.030 --> 00:35:38.900
you know, they're parallel projections.

00:35:39.020 --> 00:35:40.660
And you're going to do one
context for those three,

00:35:40.660 --> 00:35:42.820
and you're going to have all of
those be parallel projections

00:35:42.890 --> 00:35:43.890
with three separate drawables.

00:35:43.950 --> 00:35:47.730
And you attach one, you move your camera,
you draw that one.

00:35:47.970 --> 00:35:49.890
You attach the other, move your camera,
draw that one.

00:35:49.900 --> 00:35:51.900
Move your camera, draw that one.

00:35:51.900 --> 00:35:55.570
Then what you're going to do is you
have a second context for the one

00:35:55.590 --> 00:35:59.340
that has the perspective projection,
and you're going to set

00:35:59.480 --> 00:36:00.900
that up with perspective.

00:36:00.970 --> 00:36:03.100
And you have that as its own context,
its own drawable,

00:36:03.100 --> 00:36:06.900
and you basically switch to that context,
set the current context, draw that one,

00:36:06.910 --> 00:36:07.900
and off you go.

00:36:07.900 --> 00:36:08.810
Calling sort.

00:36:08.940 --> 00:36:12.200
buffers have when you finish
drawing for each one of them.

00:36:16.360 --> 00:36:19.020
Okay, for swap buffers,
it basically tells OpenGL I'm

00:36:19.020 --> 00:36:22.060
done submitting stuff to you,
go ahead and draw.

00:36:22.070 --> 00:36:26.740
So it's kind of the go ahead and take off
and let your engine chew on this data.

00:36:26.820 --> 00:36:30.300
So you pass data, you pass data,
you pass data, call swap buffers,

00:36:30.300 --> 00:36:31.700
it sends it all off to the card.

00:36:31.700 --> 00:36:35.160
And actually that's probably not correct
to say it sends it all off to the card,

00:36:35.160 --> 00:36:40.200
but it actually starts executing that
actual frame to draw to the screen.

00:36:40.200 --> 00:36:41.500
Real simple.

00:36:41.640 --> 00:36:45.340
Here's AGL swap buffers with a context.

00:36:45.340 --> 00:36:47.500
One note here is it does
implicitly call GL flush,

00:36:47.510 --> 00:36:50.670
which means it basically terminates
that scene for rendering and says go

00:36:50.780 --> 00:36:55.010
ahead and at some finite time in the
future I know this will actually execute.

00:36:56.670 --> 00:37:00.310
AGL use font, AGL use font is a real
nice thing to have.

00:37:00.370 --> 00:37:05.640
When I first looked at GL a while
ago and looked at AGL use font,

00:37:05.640 --> 00:37:07.760
you know, I can't quite understand it.

00:37:07.760 --> 00:37:10.470
I can't get it, and then I thought
I pulled around and said,

00:37:10.470 --> 00:37:11.840
"Oh, this is really easy.

00:37:11.880 --> 00:37:15.210
This is like super simple,
and this is great because I can

00:37:15.240 --> 00:37:17.320
put all kinds of data in my stuff.

00:37:17.320 --> 00:37:20.100
I can put out, render them on,
I can put in my frame rate.

00:37:20.100 --> 00:37:21.020
I can put out what it's doing.

00:37:21.020 --> 00:37:22.060
I can put out state information.

00:37:22.130 --> 00:37:27.280
I can do all this by putting text on
the screen in OpenGL without having to,

00:37:27.420 --> 00:37:31.240
you know, draw text to the screen,
which I'll talk a little bit about later.

00:37:31.240 --> 00:37:33.880
But basically you don't want to
try and draw text in OpenGL window

00:37:33.880 --> 00:37:36.380
because OpenGL doesn't know you're
drawing text and there's no idea,

00:37:36.380 --> 00:37:39.790
and so it'll draw right over it or
your text will draw over the OpenGL,

00:37:39.800 --> 00:37:42.590
and it's not designed
to work in that fashion.

00:37:42.700 --> 00:37:46.790
But AGL use font,
I get an Fnum for Monaco, for example,

00:37:46.960 --> 00:37:51.070
and then I'm going to go use,
create a GL unsigned integer,

00:37:51.130 --> 00:37:52.120
which GLU is.

00:37:52.120 --> 00:37:56.140
And I'm going to create a new element,
list base, and that's the base of my,

00:37:56.160 --> 00:37:59.730
base of a list of basically
textures I'm going to have there.

00:37:59.800 --> 00:38:04.460
I call gen list 256,
which generates 256 slots in that list.

00:38:04.460 --> 00:38:10.960
I then call use font with my contact,
my font ID, the normal 9.0200 is the

00:38:10.960 --> 00:38:14.150
beginning of the list,
256, which is the end of the list,

00:38:14.150 --> 00:38:15.140
and the list base.

00:38:15.140 --> 00:38:16.140
And what does that do?

00:38:16.140 --> 00:38:17.780
That creates,
that basically takes that font

00:38:17.790 --> 00:38:19.780
and draws it into all those
little slots in the list.

00:38:19.960 --> 00:38:23.620
So now I can go and I can say,
. . . . . . my nice little function here,

00:38:23.620 --> 00:38:28.200
which is I use call list,
with the string length

00:38:28.240 --> 00:38:31.960
and set the list base,
and basically what I can do is I can,

00:38:31.960 --> 00:38:36.420
with the base of the C string,
and I can put a C string to the display.

00:38:36.420 --> 00:38:39.040
I set a position,
I use this call list function,

00:38:39.040 --> 00:38:41.670
tell it what the string is
with a null terminated string,

00:38:41.670 --> 00:38:43.740
and use a, and, well,
put the string and then

00:38:43.740 --> 00:38:45.270
the length of the string,
and it just writes the text

00:38:45.380 --> 00:38:46.530
out to the screen no problem.

00:38:46.530 --> 00:38:48.440
So it's really easy to
put text to the screen.

00:38:48.440 --> 00:38:50.640
You can use printf, you can use,
you know,

00:38:50.640 --> 00:38:53.040
S printf to format whatever you want,
and you can just put it out.

00:38:53.040 --> 00:38:55.190
You can put out errors if
you want to the screen.

00:38:55.210 --> 00:38:56.910
So it's real, real simple to do.

00:38:58.280 --> 00:38:59.240
Agl errors.

00:38:59.240 --> 00:39:02.460
This is to differentiate
from the gl error,

00:39:02.510 --> 00:39:06.420
but agl error has agl error,
agl get error and agl error string.

00:39:06.420 --> 00:39:07.170
Real simple.

00:39:07.180 --> 00:39:10.090
You get, you, what you're gonna do is
you're gonna get the error,

00:39:10.090 --> 00:39:12.620
you're gonna pass it in if it's not
no error to an agl error string,

00:39:12.620 --> 00:39:14.980
it actually puts the
string in a parsed format,

00:39:15.010 --> 00:39:18.910
what I a lot of times do, is you do,
do a debug string and so it drops into

00:39:18.910 --> 00:39:23.320
the debugger and then I'll conditionalize
that in a debug mode or non-debug mode

00:39:23.410 --> 00:39:27.360
so I actually don't get the debug strings
when I'm in my final build but in my,

00:39:27.500 --> 00:39:30.430
I always want to be,
I always want agl to tell me if

00:39:30.430 --> 00:39:34.340
there's problems creating something
when I'm doing my non-debug build.

00:39:34.340 --> 00:39:36.770
So there you go for agl error.

00:39:36.770 --> 00:39:39.060
It's pretty simple to use and I'm
putting in parse it right there.

00:39:39.060 --> 00:39:41.390
We give you the ways to parse

00:39:41.550 --> 00:39:43.140
I set up GL back to that sample code.

00:39:43.230 --> 00:39:45.500
This sample code is about five files,
six files.

00:39:45.500 --> 00:39:49.540
And you can pull it apart,
you can tweak it around,

00:39:49.540 --> 00:39:50.500
you can do whatever you want with it.

00:39:50.500 --> 00:39:53.020
It's provided as is,
but I think it does you

00:39:53.020 --> 00:39:54.480
a pretty good service.

00:39:54.520 --> 00:39:55.500
You can just get it.

00:39:55.500 --> 00:39:58.580
It's just one call to set up,
one call to take it down,

00:39:58.580 --> 00:39:59.490
and off you go on your GL.

00:39:59.500 --> 00:40:01.500
You don't have to do anything else.

00:40:01.500 --> 00:40:04.600
I ported a couple screensavers
from one of the folks who

00:40:04.600 --> 00:40:05.500
do Windows 3D screensavers.

00:40:05.520 --> 00:40:09.500
And I ported literally one of them
in like 30 minutes using setup GL.

00:40:09.500 --> 00:40:12.160
I just replaced something,
moved a couple things

00:40:12.160 --> 00:40:13.500
around for the WGL calls,
and that was it.

00:40:13.540 --> 00:40:14.500
And I was done.

00:40:14.500 --> 00:40:16.500
So it works pretty well.

00:40:16.500 --> 00:40:20.160
It was originally used for Quake 3,
and this is based on the Quake 3

00:40:20.470 --> 00:40:24.300
code that we worked with them for.

00:40:24.610 --> 00:40:26.500
It handles both Windows and full screen.

00:40:26.500 --> 00:40:29.500
The full screen is
currently Mac OS 9 only.

00:40:29.500 --> 00:40:32.500
And I'll go through that
a little bit right now.

00:40:32.500 --> 00:40:35.560
Full screen on 10 is being
implemented right now,

00:40:35.560 --> 00:40:37.480
or is in development right now.

00:40:37.500 --> 00:40:42.390
And we're going to provide that
shortly via seeding as a patch to 10.

00:40:42.690 --> 00:40:49.380
So we don't have a way of getting
full screen for OpenGL at this time.

00:40:49.510 --> 00:40:51.500
That's something I would
love to have had in DP4,

00:40:51.500 --> 00:40:55.150
but we have to close the lid at some
point and get something to you so

00:40:55.150 --> 00:40:56.500
you can be developing with it today.

00:40:56.500 --> 00:40:58.500
But expect that really shortly.

00:40:58.500 --> 00:41:01.500
Obviously I can't give
you definite times,

00:41:01.500 --> 00:41:04.860
but I'll alert people on the
OpenGL mailing list when it's

00:41:04.860 --> 00:41:05.500
available so they can get
it and they can download it.

00:41:05.520 --> 00:41:07.110
and so they can get it
and they can download it,

00:41:07.110 --> 00:41:10.040
and immediately after it's
available I'll extend this to

00:41:10.070 --> 00:41:13.140
use the full screen section,
and if you want to find

00:41:13.200 --> 00:41:16.590
more about full screen,
full screen applications,

00:41:16.590 --> 00:41:20.420
we have a games on X session tomorrow,
I believe it's tomorrow,

00:41:20.460 --> 00:41:25.090
that will talk about some of the
options in OS X for full screen games.

00:41:25.100 --> 00:41:27.420
It handles multiple contexts,
has a pause and resume in it,

00:41:27.460 --> 00:41:30.140
and the source is available
sample code at that URL.

00:41:30.220 --> 00:41:35.130
It's really simple though,
developer.apple.com/samplecode,

00:41:35.130 --> 00:41:37.040
and we have a real good
hierarchy in the sample code,

00:41:37.040 --> 00:41:39.360
it's really easy to find,
so you just go to 3D graphics

00:41:39.430 --> 00:41:42.900
and you'll see any of our sample
code for 3D graphics there.

00:41:45.500 --> 00:41:47.390
So let's talk about using OpenGL.

00:41:47.430 --> 00:41:49.480
I'll go through a little
section about how the basics

00:41:49.490 --> 00:41:54.200
to set up and use OpenGL is,
how to set it up,

00:41:54.320 --> 00:41:57.940
how to do some basic transformations,
how to do some basic using

00:41:57.940 --> 00:42:03.630
what the basic primitives are,
talk about alpha blending,

00:42:03.630 --> 00:42:03.630
and talk about texture
mapping a little bit.

00:42:05.370 --> 00:42:07.500
Okay, so let's look at this code here.

00:42:07.600 --> 00:42:08.960
This is through AGL.

00:42:09.030 --> 00:42:12.460
The first thing we're going to do is
we're going to set up AGL attributes,

00:42:12.490 --> 00:42:16.300
basically the same thing we did before,
AGL RGBA, double buffered and none.

00:42:16.300 --> 00:42:19.180
So this is saying I want a double
buffered context so a swap is

00:42:19.180 --> 00:42:22.320
actually going to draw into the
back and a swap to the front.

00:42:22.540 --> 00:42:26.540
AGL RGBA, obviously, red, green, blue,
and alpha, channel for it.

00:42:26.540 --> 00:42:28.500
And depending on what my
display resolution is,

00:42:28.500 --> 00:42:30.400
is depending on actually
what the target is.

00:42:30.400 --> 00:42:32.320
This does not set your display
resolution or have anything

00:42:32.330 --> 00:42:33.400
to do with that kind of thing.

00:42:33.400 --> 00:42:37.400
It just tells OpenGL how
you want to draw.

00:42:37.740 --> 00:42:41.400
Pixel format and context,
I'll set those variables up.

00:42:41.400 --> 00:42:42.380
I'll choose a pixel format.

00:42:42.400 --> 00:42:44.390
In this case, it's a different example
of choose pixel format.

00:42:44.440 --> 00:42:46.400
In this case,
I pass null and I pass zero.

00:42:46.400 --> 00:42:50.400
What happens here is it looks across
every monitor that you're looking at,

00:42:50.510 --> 00:42:54.400
and it says, "Can every monitor that
is attached to the system,

00:42:54.490 --> 00:42:56.400
or every video card,
every graphics display device,

00:42:56.400 --> 00:43:00.300
satisfy that pixel format?" If it can't,
this may fail.

00:43:00.400 --> 00:43:03.150
So realize that's when the
accelerator thing comes in again.

00:43:03.160 --> 00:43:06.710
If you realize that setting
AGL accelerator means that

00:43:06.710 --> 00:43:10.400
everything it looks at has to be
accelerated for it to succeed.

00:43:10.400 --> 00:43:13.150
That's one thing to think about.

00:43:13.740 --> 00:43:16.470
I'll call AGL create context,
passing the format in that

00:43:16.520 --> 00:43:17.770
I got out of the pixel format.

00:43:17.780 --> 00:43:20.760
Obviously there's no error
checking included here,

00:43:20.760 --> 00:43:24.000
but I would definitely say given
the code for the error checking,

00:43:24.120 --> 00:43:26.540
it's pretty simple to
write in the AGL git error,

00:43:26.540 --> 00:43:27.670
AGL error string.

00:43:27.700 --> 00:43:29.670
And then I set the drawable.

00:43:29.830 --> 00:43:31.700
Basically I'm going to cast a
p window to an AGL drawable.

00:43:31.700 --> 00:43:35.920
Again, I can't stress enough that
you want to use a window,

00:43:35.920 --> 00:43:38.270
not a c graph pointer for this.

00:43:38.580 --> 00:43:44.420
SetupGL simplifies your coding,
or you can rip it apart,

00:43:44.500 --> 00:43:46.470
you can pull pieces out of it,
and you look at it as an example.

00:43:46.530 --> 00:43:48.500
I really don't care.

00:43:48.500 --> 00:43:52.500
Whatever works best for you and whatever
helps you in your development efforts.

00:43:52.500 --> 00:43:54.330
In this case, I call it PreflightGL.

00:43:54.570 --> 00:43:58.980
Basically, if I expand this a little bit,
the way SetupGL works

00:43:58.980 --> 00:44:01.500
is there's a glInfo,
which is a structure.

00:44:01.500 --> 00:44:02.500
You fill out the structure.

00:44:02.500 --> 00:44:03.090
It's pretty simple.

00:44:03.090 --> 00:44:04.500
It's a width, it's a height.

00:44:04.500 --> 00:44:05.950
Do I want full screen?

00:44:05.950 --> 00:44:08.500
Do I have to have this width and height?

00:44:08.500 --> 00:44:10.860
Because otherwise SetupGL will
pick out a window that kind

00:44:10.860 --> 00:44:15.500
of fits into your screen,
what works with that, what works there.

00:44:15.500 --> 00:44:20.750
I pass in the glInfo full screen
to PreflightGL to know whether

00:44:20.750 --> 00:44:26.170
I want to use DrawlSprocket in
this case to do full screen or not.

00:44:26.600 --> 00:44:29.020
If I don't,
all it checks for is the existence of GL.

00:44:29.020 --> 00:44:31.070
If I do,
it checks for also if DrawlSprocket

00:44:31.070 --> 00:44:32.500
exists and can call that.

00:44:32.710 --> 00:44:33.500
Then I call BuildGL.

00:44:33.500 --> 00:44:34.500
In this case, I'm going to pass in
the name of the script.

00:44:34.500 --> 00:44:36.500
I'm going to pass a
pointer to a drawable,

00:44:36.500 --> 00:44:39.630
a pointer to a context,
and a pointer to a DSP context,

00:44:39.630 --> 00:44:42.500
which may be null if I don't
have a DrawlSprocket.

00:44:42.500 --> 00:44:44.500
If I don't want it on full screen,
that could come back as null.

00:44:44.890 --> 00:44:49.490
Then I can pass a number of the device,
so which screen I want on,

00:44:49.500 --> 00:44:51.500
and basically pass my
information in there.

00:44:51.500 --> 00:44:55.420
Inside that information is the pixel
format descriptor like we saw before.

00:44:55.580 --> 00:44:57.500
That one call, boom, you're done.

00:44:57.500 --> 00:45:00.410
Out of that,
you get your drawable and your context,

00:45:00.550 --> 00:45:02.970
which is what you need to draw for GL.

00:45:03.250 --> 00:45:05.640
DestroyGL, real simple,
pass the same information in.

00:45:05.650 --> 00:45:10.890
It takes care of shutting everything
down for you and closing everything out.

00:45:11.010 --> 00:45:13.720
Okay, let's move on to transformations.

00:45:15.320 --> 00:45:18.130
This is kind of a tough slide to
go through and there's a lot of

00:45:18.130 --> 00:45:22.200
information on there and this is
absolutely scratching the surface here.

00:45:22.290 --> 00:45:25.270
One thing I look back on the
years ago when I was in college,

00:45:25.320 --> 00:45:28.250
I say, "Man, I really wish I had

00:45:28.240 --> 00:45:31.200
studied more and paid more
attention to linear algebra.

00:45:31.200 --> 00:45:32.030
If you're work,
if you want to work in GL,

00:45:32.040 --> 00:45:35.660
and you want to do more than,
than your fairly simple applications,

00:45:35.660 --> 00:45:39.380
I would really look to make
sure your linear algebra,

00:45:39.470 --> 00:45:42.180
and your matrix handling is good.

00:45:42.180 --> 00:45:43.870
There's a lot of simple
things you can do without it,

00:45:43.870 --> 00:45:47.060
but if you really want to, for example,
if you want to write the next quake,

00:45:47.080 --> 00:45:49.840
definitely you want to
understand how matrices work,

00:45:49.840 --> 00:45:52.910
and how rotations work,
and how offsets work, and how,

00:45:52.910 --> 00:45:55.980
how that interact with each other,
because that's a,

00:45:55.980 --> 00:45:59.370
that's a key to actually being
effective in open GL programming.

00:45:59.540 --> 00:46:01.280
But there are some simplifications here.

00:46:01.330 --> 00:46:03.950
There are some,
some things you can do that don't require

00:46:03.950 --> 00:46:06.670
the super knowledge of linear algebra.

00:46:06.670 --> 00:46:07.730
GLU, look at.

00:46:07.730 --> 00:46:09.490
I didn't mention GLU yet.

00:46:09.490 --> 00:46:11.460
GLU is not a GL call, it's a GLU call.

00:46:11.580 --> 00:46:13.040
It's a little bit higher level.

00:46:13.040 --> 00:46:16.850
With every open GL implementation,
there's also a GLU.

00:46:17.010 --> 00:46:21.200
The GLU does some nice things for you,
and kind of builds higher

00:46:21.200 --> 00:46:24.420
level instructions that
rely on the GL instructions.

00:46:24.420 --> 00:46:27.860
In this case,
you tell it where your eye is, x, y, z.

00:46:27.860 --> 00:46:30.680
You tell it where the
center of your display is,

00:46:30.680 --> 00:46:31.350
x, y, z.

00:46:31.350 --> 00:46:34.740
And you tell it up, x, y, z, so what,
what the up vector is.

00:46:34.950 --> 00:46:36.680
So you can say, I'm at zero.

00:46:36.680 --> 00:46:42.000
I want to look at 10, 10, you know, 10,
or 0, 0, negative 10, z.

00:46:42.000 --> 00:46:43.570
And you can tell them
what your up vector is,

00:46:43.570 --> 00:46:44.840
and you're, you're rolling.

00:46:44.840 --> 00:46:47.550
You don't have to figure out, well, okay,
that's a right hand rule,

00:46:47.550 --> 00:46:50.420
and I'm looking here,
and I'm moving around here.

00:46:50.420 --> 00:46:52.400
You just tell it where you are,
tell them what you want to look at,

00:46:52.460 --> 00:46:53.820
and I'll set up.

00:46:53.820 --> 00:46:55.580
So it sets up the model
view transformation.

00:46:55.580 --> 00:46:58.670
It basically sets the basis for
where your eye is relative to

00:46:58.780 --> 00:47:00.180
where the center of your screen is.

00:47:00.180 --> 00:47:03.450
So if you just draw something now,
it'll draw relative to the center,

00:47:03.450 --> 00:47:05.840
relative to the zero on your screen,
which you can,

00:47:05.840 --> 00:47:09.660
you can move back and look at
the zero if you wanted to also.

00:47:09.660 --> 00:47:11.860
For modeling, that's for moving your eye.

00:47:11.860 --> 00:47:14.280
For modeling, to move your model,
you basically want to set up

00:47:14.280 --> 00:47:16.630
whatever you're going to do,
whether it's the, whether it's a cube,

00:47:16.660 --> 00:47:20.230
a square, or whether it's the,
the Sarge and Quake,

00:47:20.300 --> 00:47:22.370
or whether it's a Maya face model.

00:47:22.370 --> 00:47:25.240
What you're going to do is
you're going to use translate,

00:47:25.280 --> 00:47:26.250
rotate, and scale.

00:47:26.370 --> 00:47:27.720
What that's going to
do is you're going to,

00:47:27.720 --> 00:47:29.040
they do exactly what they say.

00:47:29.040 --> 00:47:33.540
One translates, one rotates, one scales,
and they can move your model around.

00:47:33.540 --> 00:47:35.430
You want to apply this to all
the vertexes in your model,

00:47:35.430 --> 00:47:38.560
obviously, and you want to realize that
what order you do things in,

00:47:38.560 --> 00:47:41.130
where you translate first and
then rotate has different things

00:47:41.130 --> 00:47:42.600
than if you rotate then translate.

00:47:42.600 --> 00:47:43.490
We can easily see that.

00:47:43.600 --> 00:47:46.250
If you have a square in front of you,
or you have whatever,

00:47:46.270 --> 00:47:48.970
a car in front of you, and you rotate,
and then you translate in that,

00:47:49.040 --> 00:47:50.490
in local coordinates,
it may translate differently than

00:47:50.510 --> 00:47:50.900
translating and then rotating.

00:47:50.900 --> 00:47:51.920
So you're going to use,
you're going to use translate, rotate,

00:47:51.970 --> 00:47:52.220
and scale.

00:47:52.220 --> 00:47:52.220
What that's going to do
is you're going to use,

00:47:52.220 --> 00:47:53.220
you're going to rotate,
and then you're going to rotate.

00:47:53.250 --> 00:47:54.620
So that's something to look at.

00:47:54.620 --> 00:47:56.960
Some of the OpenGL references
talk about that and talk about

00:47:56.960 --> 00:47:59.830
how to think about that in a way
that works for people who have not

00:47:59.830 --> 00:48:01.630
done a lot of OpenGL programming.

00:48:01.720 --> 00:48:02.440
It's not too bad.

00:48:02.440 --> 00:48:05.880
If you work through it closely,
it's pretty easy to do once

00:48:05.880 --> 00:48:07.820
you kind of get the hang of it.

00:48:07.820 --> 00:48:09.450
One of the keys here,
one of the funny things that

00:48:09.450 --> 00:48:12.540
I think every OpenGL programmer
realizes is there's more ways in

00:48:12.540 --> 00:48:15.950
OpenGL to get a black screen than in
anything else in the entire world.

00:48:16.250 --> 00:48:19.190
Everyone who's working OpenGL goes,
"Okay, I got this figured out,

00:48:19.190 --> 00:48:22.130
and I got it out there, and I checked it,
and I have my paper,

00:48:22.240 --> 00:48:25.520
and I'm sat in my office
and stared at my thing,

00:48:25.520 --> 00:48:27.390
and I got this rolling.

00:48:27.390 --> 00:48:27.390
Okay,

00:48:32.180 --> 00:48:33.100
Let me look at something.

00:48:33.100 --> 00:48:35.070
Let me look at my GLU look at.

00:48:35.100 --> 00:48:38.340
Well, so how do you know if
your GLU look at is wrong?

00:48:38.340 --> 00:48:40.320
I mean,
your model could be off in the next

00:48:40.340 --> 00:48:42.100
building over as far as you know.

00:48:42.100 --> 00:48:45.560
I mean, so there is,
my recommendation for all of this is to,

00:48:45.560 --> 00:48:48.100
there's a ton of examples
out there for OpenGL,

00:48:48.100 --> 00:48:49.100
a lot of GLUT examples.

00:48:49.100 --> 00:48:50.100
It does tons of things.

00:48:50.100 --> 00:48:53.100
Dave will show you some examples
and some of the stuff he's done.

00:48:53.100 --> 00:48:57.100
And there is like 500
examples in our SDK.

00:48:57.100 --> 00:49:00.570
Use them, build off of them,
look at how they do things,

00:49:00.570 --> 00:49:02.100
move in small steps.

00:49:02.100 --> 00:49:06.480
Don't decide, like I did the other day,
that you want to display a movie on a

00:49:06.580 --> 00:49:13.100
surface that's rotating and deforming and
have your eye move around at one time.

00:49:13.100 --> 00:49:14.100
I'll add this all at one time.

00:49:14.100 --> 00:49:16.100
I don't want to add all this in pieces.

00:49:16.100 --> 00:49:19.610
So, you know, work slowly,
look at your transformations carefully,

00:49:19.710 --> 00:49:22.070
learn what they're doing,
look at the different effects of

00:49:22.070 --> 00:49:25.080
the different transformations,
and you'll move forward quickly.

00:49:25.100 --> 00:49:26.100
If you sit there and decide
you want to write a new model,

00:49:26.100 --> 00:49:26.100
you're going to have to do it.

00:49:26.100 --> 00:49:27.100
You're going to have to do it.

00:49:27.100 --> 00:49:29.090
If you're going to write it from scratch
and you want to figure it all out,

00:49:29.100 --> 00:49:32.040
I guarantee that you'll be
looking at a lot of lock screen.

00:49:32.170 --> 00:49:36.100
For projection,
GLU Perspective is really nice.

00:49:36.230 --> 00:49:40.100
Field of view Y and aspect
ratio in a near and far plane.

00:49:40.250 --> 00:49:41.100
Pretty simple.

00:49:41.100 --> 00:49:43.640
I mean, it just basically,
you can go from the fisheye

00:49:43.720 --> 00:49:45.100
lens to the telephoto lens.

00:49:45.190 --> 00:49:48.100
And, you know, how squished it is,
how round it is.

00:49:48.100 --> 00:49:50.100
I mean, it's like aspect is probably
going to be your screen aspect.

00:49:50.100 --> 00:49:52.100
But you can do special effects with it.

00:49:52.100 --> 00:49:55.100
You can squish things by changing
aspect ratios and those kind of things.

00:49:55.100 --> 00:49:56.100
It also tells you how powerful
a lot of the major things are.

00:49:56.100 --> 00:49:59.100
A lot of the matrices are in OpenGL.

00:49:59.380 --> 00:50:04.150
Because it allows you to
actually change some things that,

00:50:04.150 --> 00:50:05.950
I mean, because you have a square window,
it does not mean you have

00:50:05.950 --> 00:50:07.060
to have a square projection.

00:50:07.110 --> 00:50:08.070
It can squish it.

00:50:08.090 --> 00:50:08.890
It can stretch it.

00:50:08.890 --> 00:50:10.100
It can do whatever you want.

00:50:10.100 --> 00:50:13.100
GL Ortho is an example of how to
do an orthographic projection.

00:50:13.100 --> 00:50:17.060
Thus, you can do a parallel projection,
and it specifies instead of a frustum,

00:50:17.140 --> 00:50:20.000
it specifies a box.

00:50:20.380 --> 00:50:24.390
And GL viewport allows you to set the X,
Y location and the width and

00:50:24.390 --> 00:50:27.770
height of your drawable inside,
of your actual rendering

00:50:27.770 --> 00:50:29.280
area inside your viewport.

00:50:29.300 --> 00:50:30.800
So that's something nice to do.

00:50:30.800 --> 00:50:33.290
Also you can move it around
and you can move windows off.

00:50:33.340 --> 00:50:37.430
There's other nuances there as far
as like using a buffer rack in AGL,

00:50:37.430 --> 00:50:40.280
but viewport allows you
to do the basic GL setup.

00:50:41.630 --> 00:50:45.610
Basic primitives: Points, lines,
triangles, quads, polygons.

00:50:45.610 --> 00:50:47.430
Real simple,
I guess saying this is actually

00:50:47.450 --> 00:50:51.180
pulled out of the draw a square code,
which you'll see later in

00:50:51.180 --> 00:50:53.500
its full wonderfulness.

00:50:53.790 --> 00:50:57.470
Setup a color, call three vertices,
and end.

00:50:57.570 --> 00:50:58.500
Actually that draws a
piece of the square,

00:50:58.500 --> 00:50:59.490
that draws a face of the square.

00:50:59.490 --> 00:51:00.470
Or a face.

00:51:00.600 --> 00:51:02.500
And you can do that,
I mean this can be complicated.

00:51:02.500 --> 00:51:05.030
For example, the Maya demo you saw.

00:51:05.160 --> 00:51:09.440
They don't use the OpenGL internal
NURBS kind of calculation.

00:51:09.510 --> 00:51:11.480
They tessellate everything and they
turn everything into tri-scripts.

00:51:11.500 --> 00:51:15.420
So they have, they basically,
in their code, you're going to see GL,

00:51:15.420 --> 00:51:20.550
you're going to see a GL triangles,
or a GL tri-script,

00:51:20.550 --> 00:51:22.610
and then you're going to see
three vertices with color,

00:51:22.620 --> 00:51:24.500
with some,
with a texture coordinates or whatever.

00:51:24.500 --> 00:51:27.000
But they're basically
doing the same thing.

00:51:27.000 --> 00:51:29.370
It's just a low level drawing primitive.

00:51:30.540 --> 00:51:32.340
Alpha blending.

00:51:32.660 --> 00:51:35.920
Alpha blending is real simple,
simple transparency.

00:51:35.920 --> 00:51:39.000
And what you do is you have
to enable a blend mode.

00:51:39.000 --> 00:51:40.500
It's again a state machine.

00:51:40.500 --> 00:51:42.500
You can, normally it's not enabled.

00:51:42.500 --> 00:51:45.480
When you enable a blend mode,
you can then set your blend function,

00:51:45.550 --> 00:51:48.910
which basically tells what the
foreground and what the background does,

00:51:48.920 --> 00:51:51.310
and then you basically set,
instead of your color,

00:51:51.370 --> 00:51:53.450
which you noticed before
I had set a color.

00:51:53.450 --> 00:51:55.540
This time I set up an
alpha value in the color.

00:51:55.620 --> 00:51:57.960
So I use four components and
the last being the alpha value,

00:51:57.960 --> 00:52:00.480
and the alpha value says this
is 50 percent transparent,

00:52:00.560 --> 00:52:03.130
and I do the same thing I did before.

00:52:04.410 --> 00:52:05.200
we got.

00:52:05.600 --> 00:52:05.900
Okay.

00:52:05.900 --> 00:52:08.780
Let me show two demos real quick.

00:52:08.860 --> 00:52:13.100
And these, these are, I have to say,
the idea with these demos was to make

00:52:13.140 --> 00:52:16.690
something really simple to show some
of the things that OpenGL can do.

00:52:16.690 --> 00:52:19.110
So, so this is not supposed to be Quake.

00:52:19.110 --> 00:52:23.480
This is not supposed to be, you know,
the next great app because what we

00:52:23.480 --> 00:52:25.760
kind of get is the spinning square.

00:52:25.760 --> 00:52:27.900
You know, this is a good place to start.

00:52:27.900 --> 00:52:29.990
You're looking at something
that really works.

00:52:30.050 --> 00:52:32.070
You get, you get a square and
you can go from there.

00:52:32.080 --> 00:52:33.740
So that's, that's the spinning square.

00:52:33.740 --> 00:52:37.200
So that's the setting with no,
with no blending or alpha on.

00:52:37.200 --> 00:52:40.680
Why don't we turn on, let's see, let's

00:52:41.320 --> 00:52:47.010
: So basically I pulled the code
that you saw on the other monitor

00:52:47.050 --> 00:52:50.600
out of that and basically I just
do an alpha blend with a square.

00:52:50.600 --> 00:52:53.640
I mean, it's not great,
but it shows the effect and you

00:52:53.640 --> 00:52:55.290
can do some cool things with it.

00:52:55.390 --> 00:52:59.300
So, I'm going to go back to the
texture mapping slide now.

00:52:59.300 --> 00:53:05.490
You can go back to the PowerPoint.

00:53:12.930 --> 00:53:16.620
So, in reality, I mean, flat objects,
objects that have smooth shading,

00:53:16.650 --> 00:53:18.900
don't really, aren't really exciting.

00:53:18.900 --> 00:53:21.900
As you saw in the demo this morning,
as in the keynote,

00:53:21.900 --> 00:53:25.140
it's really a lot more exciting when
you put the texture mapping on there,

00:53:25.140 --> 00:53:28.880
when you've got a scene that looks,
looks lifelike, pops out at you.

00:53:28.960 --> 00:53:30.890
That's when it gets real interesting.

00:53:30.990 --> 00:53:33.900
So, steps in texture mapping.

00:53:33.900 --> 00:53:35.400
How do you texture map?

00:53:35.400 --> 00:53:37.240
The texture mapping is a
little bit strange when you

00:53:37.360 --> 00:53:40.200
first look at it on the Mac,
because you kind of understand that

00:53:40.200 --> 00:53:43.940
you supply this buffer to OpenGL,
and you want to use that for a texture,

00:53:43.940 --> 00:53:45.890
but you're kind of like, well,
how do I get the buffer into the Mac,

00:53:45.900 --> 00:53:49.730
and how do I tell OpenGL to use it,
and what's the difference between, like,

00:53:49.730 --> 00:53:50.900
a GWorld and a buffer?

00:53:50.900 --> 00:53:52.970
So, basically,
you need to create and draw your

00:53:52.970 --> 00:53:56.900
texture and set your texture parameters,
and then you enable texturing.

00:53:56.900 --> 00:53:57.790
The enable texturing is easy.

00:53:57.920 --> 00:53:59.790
That's basically how I'm going
to put my code down there,

00:53:59.790 --> 00:54:00.900
and I'll show you code on the next page.

00:54:00.900 --> 00:54:04.660
To create a texture in OpenGL,
the simplest thing is to draw

00:54:04.820 --> 00:54:06.850
anything you can into a GWorld.

00:54:06.900 --> 00:54:09.900
So, for example, you use QuickTime.

00:54:09.900 --> 00:54:12.900
I love using QuickTime, and you can use,
read any file format you want.

00:54:12.900 --> 00:54:16.640
basically want to save things as,
and you read it into a GWorld,

00:54:17.740 --> 00:54:19.670
Then you would do what's
called swizzling texture,

00:54:19.730 --> 00:54:20.600
swizzling pixels.

00:54:20.600 --> 00:54:23.600
You have to actually put the
pixels in an order right now.

00:54:23.600 --> 00:54:25.600
This isn't until when with
the packed pixel format.

00:54:25.600 --> 00:54:28.040
This is one reason packed pixels
is a really good thing to have.

00:54:28.190 --> 00:54:30.990
But right now you have to move those
pixels into a buffer that has them

00:54:30.990 --> 00:54:32.530
in an order that OpenGL expects.

00:54:32.600 --> 00:54:35.600
So for example,
most textures you may want RGBA.

00:54:35.600 --> 00:54:39.760
If you say your texture is RGBA,
you set up a buffer that just has a

00:54:39.760 --> 00:54:46.600
width and height times three components
times 24 bits size buffer of RGBA.

00:54:46.780 --> 00:54:52.580
And then you extract components from your
GWorld and put them into that buffer.

00:54:52.650 --> 00:54:53.600
It's not really difficult to do.

00:54:53.600 --> 00:54:54.600
There is sample code.

00:54:54.600 --> 00:54:56.600
I'm not sure if it's up yet,
but it will be up this week.

00:54:56.650 --> 00:55:00.230
That tells you how to do that and
it's basically a 1015 line function.

00:55:00.310 --> 00:55:01.530
It's pretty simple to do.

00:55:01.820 --> 00:55:03.590
And it's not that slow either.

00:55:03.590 --> 00:55:04.590
You can do some good stuff with it.

00:55:04.630 --> 00:55:07.530
If you really want to be aggressive,
you can go and use the velocity engine

00:55:07.530 --> 00:55:10.600
and optimize that using the permute
instructions to blast pixels in.

00:55:10.600 --> 00:55:13.040
But for me,
I just picked the right pixels out,

00:55:13.040 --> 00:55:15.600
put them in the right order,
and moved them over.

00:55:15.600 --> 00:55:17.600
And it works pretty well.

00:55:17.600 --> 00:55:20.540
So the first part is set
track texture parameters.

00:55:20.990 --> 00:55:22.110
Basically,
these are kind of some standard

00:55:22.200 --> 00:55:23.600
settings for texture parameters.

00:55:23.600 --> 00:55:31.190
I set up some filtering for it so
it knows how to filter textures.

00:55:32.050 --> 00:55:33.810
Then here's the actual meat of it.

00:55:34.020 --> 00:55:38.190
We enable texturing, state machine again,
we make sure we enable 2D texturing.

00:55:38.190 --> 00:55:43.430
GL text image 2D, and this actually,
this is probably easier to look at in the

00:55:43.890 --> 00:55:47.380
documentation than it is on the screen,
but the key here is that

00:55:47.380 --> 00:55:49.590
basically I have three components.

00:55:49.590 --> 00:55:52.740
I pass the width and the height
and then I tell it it's RGB,

00:55:52.740 --> 00:55:56.040
it's a 2D texture, unsigned bytes,
and I pass the buffer there

00:55:56.040 --> 00:55:58.490
as a pointer to my buffer,
which I've extracted from my

00:55:58.490 --> 00:56:01.020
G World and put in the right format,
and that's the texture.

00:56:01.120 --> 00:56:03.460
So that tells GL what the texture is.

00:56:03.500 --> 00:56:06.300
I can then go,
the same thing I did before,

00:56:06.300 --> 00:56:09.290
which is basically say, hey,
I got the face of the square,

00:56:09.290 --> 00:56:12.840
make a quad, but also I've added
the GL text coordinate,

00:56:12.840 --> 00:56:16.060
and then GL text coordinate
is pretty simple.

00:56:16.060 --> 00:56:19.940
Texture coordinates are
set up to be zero to one.

00:56:19.940 --> 00:56:23.740
So if I have a texture that's 512 by 512,
it's zero to one as far

00:56:23.740 --> 00:56:26.280
as texture coordinates,
so assuming that I'm mapping

00:56:26.280 --> 00:56:28.960
it to one single polygon,
it's real simple to set up.

00:56:29.080 --> 00:56:32.680
When you're mapping to multiple polygons,
it can be a lot more complicated.

00:56:32.680 --> 00:56:34.900
One thing you should look
at is another GLU function,

00:56:34.900 --> 00:56:36.480
is a GLU textgen function.

00:56:36.480 --> 00:56:39.770
It's a fairly complicated function,
probably beyond the

00:56:40.020 --> 00:56:42.130
scope of this talk here,
but it's something to look at.

00:56:42.150 --> 00:56:44.700
Look at some of the sample code that
uses it because it really can be

00:56:44.770 --> 00:56:48.240
an interesting function for texture
mapping on more complicated surfaces

00:56:48.560 --> 00:56:53.860
that you don't want to calculate every
single texture coordinate yourself.

00:56:53.860 --> 00:56:54.740
What else was there?

00:56:54.740 --> 00:56:58.470
Another note on textures is
textures should be powers of two.

00:56:58.470 --> 00:57:02.300
Our implementation right now specifies
that texture needs to be power of two,

00:57:02.300 --> 00:57:06.150
and people will say,
"Why do I get white textures?" And so,

00:57:06.150 --> 00:57:09.560
I talked about QuickTime for
image handling.

00:57:09.580 --> 00:57:12.210
I talked that the
pixels must be swiveled,

00:57:12.210 --> 00:57:17.230
swiveled from Apple ARGB to RGB until
packed pixel format is actually out.

00:57:17.420 --> 00:57:19.540
And alpha channels are
indeterminate in QuickDraw.

00:57:19.540 --> 00:57:23.340
One key there is that QuickDraw does
not support maintaining alpha channels.

00:57:23.360 --> 00:57:26.340
Thus, for QuickDraw,
you're going to need to

00:57:26.340 --> 00:57:26.680
put your own alpha in.

00:57:26.680 --> 00:57:27.480
There is cases where you
can put your own alpha,

00:57:27.480 --> 00:57:28.480
and there are cases where you
can put your own alpha in.

00:57:28.480 --> 00:57:29.480
But I'm not going to talk about that.

00:57:29.480 --> 00:57:31.290
There is cases where you can read it
in using QuickTime and immediately

00:57:31.290 --> 00:57:33.000
blast it out with the alpha,
but you've got to be real careful

00:57:33.090 --> 00:57:35.280
that you're doing the right thing.

00:57:35.280 --> 00:57:36.040
White textures.

00:57:36.130 --> 00:57:37.020
What things can it do?

00:57:37.090 --> 00:57:39.630
If you're out of system memory,
I think people have seen that with Quake,

00:57:39.750 --> 00:57:41.600
if you don't have enough
system memory there,

00:57:41.600 --> 00:57:45.020
you may run out of texture
memory in the system that we

00:57:45.080 --> 00:57:47.300
need to store textures into.

00:57:47.300 --> 00:57:49.690
You can increase the VRAM,
or the virtual memory, sorry,

00:57:49.760 --> 00:57:53.380
increase the virtual memory on this,
and that will solve that problem.

00:57:53.480 --> 00:57:55.000
It may not ever access
that texture again.

00:57:55.000 --> 00:57:56.320
It may just sit there,
but it needs somewhere to

00:57:56.320 --> 00:57:57.460
store it so it can restore it
if the card has to purge it.

00:57:57.460 --> 00:58:00.760
So, you can have a texture mode error.

00:58:00.760 --> 00:58:02.740
For example,
you didn't turn texturing on.

00:58:02.740 --> 00:58:05.720
So, that didn't work,
or that was the last one actually,

00:58:05.720 --> 00:58:09.000
or in this case I was referring
to if you have 255 by 255,

00:58:09.000 --> 00:58:11.790
it's going to say I can't,
I can't texture this thing.

00:58:11.800 --> 00:58:13.240
I don't know how to read that texture in.

00:58:13.240 --> 00:58:16.400
So it's just going to fail reading
and you get a nice white texture.

00:58:16.400 --> 00:58:19.130
So what kind of texture demo I can have?

00:58:19.140 --> 00:58:20.880
And this is again really simple.

00:58:20.880 --> 00:58:24.790
One of the, one of the things that
I wanted to stress about these,

00:58:24.790 --> 00:58:24.790
you know, I'm not going to go into

00:58:25.130 --> 00:58:29.880
The design of the OpenGL application
is that these are all built with

00:58:29.920 --> 00:58:34.120
a carbonized version of Setup GL,
runs on 9 and 10.

00:58:34.160 --> 00:58:38.270
The design is to make it real simple,
but using Setup GL for

00:58:38.270 --> 00:58:39.860
both simplifies it.

00:58:39.870 --> 00:58:43.430
As long as your application
is Carbon compliant,

00:58:43.430 --> 00:58:47.080
Setup GL will allow you
to be Carbon compliant.

00:58:49.100 --> 00:58:49.620
So I'll run this,
and this makes it at least

00:58:49.630 --> 00:58:50.090
a little bit more exciting.

00:58:50.170 --> 00:58:53.230
Pulling the Maya face from
what we had earlier today,

00:58:53.440 --> 00:58:55.100
putting a marble texture on.

00:58:55.100 --> 00:58:57.490
And this literally,
the code you saw I added was

00:58:57.630 --> 00:58:59.100
basically the code I have to add.

00:58:59.100 --> 00:59:01.780
I mean really, going from something
that's really nothing,

00:59:01.860 --> 00:59:04.360
just a flat shaded square,
to something that's actually

00:59:04.370 --> 00:59:07.210
interesting to look at,
or reasonably interesting to look at,

00:59:07.210 --> 00:59:08.070
is not hard.

00:59:08.150 --> 00:59:09.810
Also, we added the reflection there.

00:59:09.810 --> 00:59:12.060
The reflection was just
using an alpha blending.

00:59:12.270 --> 00:59:15.880
Real simple stuff,
but something that is not hard to do.

00:59:16.100 --> 00:59:17.100
If you haven't used OpenGL,
you can use it.

00:59:17.100 --> 00:59:19.100
But with Setup GL,
it's pretty easy to get to this point.

00:59:19.100 --> 00:59:22.890
Can you go back to PowerPoint?

00:59:24.590 --> 00:59:26.490
So we're going through that.

00:59:26.800 --> 00:59:29.020
The last thing I'll
cover is some references.

00:59:29.260 --> 00:59:30.380
Big time.

00:59:30.380 --> 00:59:32.240
If you're looking at
open GL get the red book.

00:59:32.370 --> 00:59:34.780
The red book is the
OpenGL programming guide.

00:59:34.890 --> 00:59:36.590
Also if you want a reference manual.

00:59:36.860 --> 00:59:38.600
I can go back and forth.

00:59:38.680 --> 00:59:44.110
If you can download this specification
from www.opengl.org or you can actually

00:59:44.110 --> 00:59:48.350
buy the blue book and buy that as a
reference depending on what you like.

00:59:48.430 --> 00:59:52.690
I think the OpenGL specs in
PDF format and you have to have,

00:59:52.700 --> 00:59:54.300
if you want to print it,
I think you have to have a

00:59:54.310 --> 00:59:59.900
PostScript level 2 printer to actually
print it because of the font handling.

01:00:00.010 --> 01:00:03.720
But as far as the programming guide
is really critical to have and it

01:00:03.720 --> 01:00:07.300
actually goes through kind of step by
step through all the pieces of OpenGL.

01:00:07.420 --> 01:00:08.900
Goes through a lot of examples.

01:00:08.900 --> 01:00:12.150
Go through a lot of kind of hand
holding to show you how things work

01:00:12.400 --> 01:00:15.140
without just sending functions at you.

01:00:15.140 --> 01:00:17.250
Where the reference manual
is just a function reference.

01:00:17.300 --> 01:00:19.980
In alphabetical order the whole
book is just function reference.

01:00:20.110 --> 01:00:23.080
So they're both critical
to have in different ways.

01:00:23.170 --> 01:00:23.340
Online.

01:00:23.340 --> 01:00:25.280
www.opengl.org.

01:00:25.380 --> 01:00:26.650
Great place to go.

01:00:26.720 --> 01:00:28.030
A lot of developer documentation.

01:00:28.040 --> 01:00:29.310
A lot of white papers.

01:00:29.340 --> 01:00:32.440
Tremendous amount of things that you
can find there if you look around.

01:00:32.440 --> 01:00:35.640
People ask me questions sometimes and
I go there and I search around a little

01:00:35.640 --> 01:00:38.670
bit and I'll find the answer to their
question that I may not have known just

01:00:38.740 --> 01:00:39.740
by something else that someone wrote.

01:00:39.890 --> 01:00:42.110
Mark Kilgard has some
great papers out there.

01:00:42.190 --> 01:00:43.960
Michael Gold has some
great stuff out there.

01:00:43.960 --> 01:00:46.300
Steve Baker has some great
stuff out there about some of,

01:00:46.310 --> 01:00:50.260
I think Mark Kilgard has the
16 common OpenGL mistakes

01:00:50.350 --> 01:00:51.200
that almost everyone makes.

01:00:51.200 --> 01:00:52.760
It's a good thing to read when
you're getting going with OpenGL.

01:00:52.760 --> 01:00:55.720
And also list.apple.com.

01:00:55.900 --> 01:00:58.500
Easy thing to do is just
go to list.apple.com,

01:00:58.640 --> 01:01:01.300
search for OpenGL and
you'll see the OpenGL list.

01:01:01.430 --> 01:01:03.190
Subscribe to that, ask questions.

01:01:03.280 --> 01:01:04.860
We monitor,
the engineers monitor the list and

01:01:04.860 --> 01:01:09.240
we try and answer a lot of questions
there and that's a really good thing

01:01:09.280 --> 01:01:11.380
to get information on Apple's OpenGL.

01:01:11.380 --> 01:01:13.640
And I'll be in,
when we have the seeds ready,

01:01:13.730 --> 01:01:14.780
they'll be announced there.

01:01:14.920 --> 01:01:16.320
When the full screen
support is out there,

01:01:16.320 --> 01:01:17.970
that'll be announced there also.

01:01:18.080 --> 01:01:20.150
So it's a good thing to look for.

01:01:20.250 --> 01:01:20.480
Okay.

01:01:20.480 --> 01:01:22.120
I think that's about all I have.

01:01:22.120 --> 01:01:22.610
Thank you.

01:01:22.760 --> 01:01:25.520
Ah, key.

01:01:25.520 --> 01:01:26.990
Roadmap.

01:01:27.250 --> 01:01:28.400
OpenGL Mac OS X.

01:01:28.400 --> 01:01:29.540
Dave Springer's going to talk about that.

01:01:29.620 --> 01:01:31.700
That'll go into a lot
more depth than I did,

01:01:31.700 --> 01:01:34.900
and I'll talk about OS X-specific OpenGL.

01:01:34.960 --> 01:01:38.910
OpenGL Beyond Games talks about using
OpenGL for non-gaming applications.

01:01:39.150 --> 01:01:40.980
We're talking about
handling multiple windows,

01:01:41.080 --> 01:01:43.520
how to texture map a
movie onto a surface,

01:01:43.540 --> 01:01:44.460
and things you can do with it.

01:01:44.460 --> 01:01:45.930
You don't have to use OpenGL.

01:01:45.990 --> 01:01:49.240
You can use OpenGL for, like,
a 2D sprite engine that gets you

01:01:49.240 --> 01:01:51.180
a lot of special effects for free.

01:01:51.250 --> 01:01:52.840
It gets you rotation,
it gets you translucency,

01:01:52.840 --> 01:01:54.850
it gets you all these things for free,
and you can take advantage

01:01:54.930 --> 01:01:56.560
of the GL hardware.

01:01:56.620 --> 01:01:59.480
Our OpenGL tech lead is going to
talk about advanced optimization

01:01:59.480 --> 01:02:02.310
techniques following that,
and then we'll have the feedback

01:02:02.600 --> 01:02:04.200
form after lunch after that.

01:02:04.200 --> 01:02:07.070
And I welcome you all to please
come to the feedback form,

01:02:07.200 --> 01:02:10.330
tell us what we're doing right,
tell us what we're doing wrong,

01:02:10.330 --> 01:02:13.210
and give us suggestions so
that we can move forward.

01:02:14.210 --> 01:02:15.640
Okay, question and answer?

01:02:15.640 --> 01:02:16.810
And actually, this lies.

01:02:16.810 --> 01:02:21.150
I want to bring Bob Beretta up on stage,
who is one of our OpenGL engineers.

01:02:21.360 --> 01:02:23.160
He's the guru.

01:02:23.210 --> 01:02:26.200
So when you ask a hard question,
he's going to answer it.

01:02:26.200 --> 01:02:27.630
So, Bob.

01:02:28.270 --> 01:02:31.810
So, if you have a question,
please come up to the mics

01:02:32.010 --> 01:02:33.590
and ask your question.
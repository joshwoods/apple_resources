WEBVTT

00:00:17.360 --> 00:00:19.920
Good afternoon everyone, welcome back.

00:00:20.100 --> 00:00:21.280
You have a good lunch?

00:00:21.400 --> 00:00:23.200
Yeah, I see a lot of empty seats.

00:00:23.340 --> 00:00:27.110
That usually means either lunch
was really good or really bad.

00:00:27.310 --> 00:00:32.640
But we have here the session that was
hinted at several times yesterday.

00:00:32.840 --> 00:00:35.630
How many of you remember the EJB session?

00:00:35.910 --> 00:00:38.780
How many of you have
digested all of it yet?

00:00:38.800 --> 00:00:40.790
A handful of you, yeah.

00:00:40.930 --> 00:00:43.360
So you might also think
about retitling this session

00:00:43.630 --> 00:00:47.370
Caching In on Synchronization,
because as you learned yesterday,

00:00:47.370 --> 00:00:50.780
one of the real advantages of
WebObjects has is incredibly powerful

00:00:50.780 --> 00:00:54.800
mechanisms for caching and synchronizing
data across multiple object stores

00:00:54.800 --> 00:00:56.920
running on multiple systems,
not just the sort of

00:00:56.920 --> 00:00:59.320
heavyweight "who am I,
here am I" kind of

00:00:59.320 --> 00:01:00.800
things you get with EJB.

00:01:00.800 --> 00:01:02.800
And to tell you all about that,
here is Daniel Abrams.

00:01:02.800 --> 00:01:05.360
Please give him a warm welcome.

00:01:09.400 --> 00:01:10.270
Thanks.

00:01:10.400 --> 00:01:12.330
It's really great to see everyone.

00:01:12.420 --> 00:01:16.180
I'm frankly amazed at how many
WebObjects people were getting into these

00:01:16.180 --> 00:01:20.260
sessions and a little intimidated too,
but we'll go ahead.

00:01:20.400 --> 00:01:22.630
Like Ernie said,
the name of this session is

00:01:22.630 --> 00:01:24.400
Caching and Synchronization.

00:01:24.400 --> 00:01:27.360
And at a very high level,
it's a very simple concept.

00:01:27.400 --> 00:01:31.560
Caching in the sense of grabbing
data from an external data

00:01:31.560 --> 00:01:34.400
store like a relational database
and displaying it to users.

00:01:34.400 --> 00:01:38.940
And the real issue is how fresh that
data is that your users are seeing

00:01:38.980 --> 00:01:44.520
and a balance between hitting that
external store and caching that data so

00:01:44.520 --> 00:01:46.400
that you're not hitting it too often.

00:01:46.400 --> 00:01:50.380
But as a consequence, users might not be
seeing the freshest data.

00:01:50.400 --> 00:01:53.280
And synchronization,
which is taking changes that your

00:01:53.280 --> 00:01:58.090
users make to objects and applying them
back to the database in an orderly,

00:01:58.090 --> 00:01:59.280
organized way.

00:01:59.400 --> 00:02:02.400
So we'll jump right
into it and get started.

00:02:02.400 --> 00:02:03.400
I want to divide the
presentation into two parts.

00:02:04.400 --> 00:02:06.400
I want to divide the presentation
into essentially three parts.

00:02:06.400 --> 00:02:09.950
The first part, at a high level,
we'll use the slides to go

00:02:09.950 --> 00:02:14.380
over some of the caching and
synchronization issues and solutions.

00:02:14.400 --> 00:02:17.290
We'll jump into a little demo
app that I've prepared to

00:02:17.360 --> 00:02:19.380
demonstrate some of these things.

00:02:19.400 --> 00:02:22.810
And then we'll get into the Q&A and
hopefully get a constructive

00:02:22.810 --> 00:02:26.400
discussion going about how to
deal with some of these things.

00:02:26.500 --> 00:02:30.600
Before we get started,
I did want to sort of get a show of hands

00:02:30.600 --> 00:02:33.350
just to see the level we should go at.

00:02:33.520 --> 00:02:37.280
How many people here have a good sense
of what an EOFetch specification is,

00:02:37.280 --> 00:02:40.400
how to deal with it,
have used that before?

00:02:40.470 --> 00:02:41.400
Okay.

00:02:41.400 --> 00:02:43.400
So maybe half, I would say.

00:02:43.400 --> 00:02:47.040
Which means that we're probably
going to lose some of you,

00:02:47.180 --> 00:02:50.400
at least in the PowerPoint part
of the presentation.

00:02:50.400 --> 00:02:52.400
And hopefully we'll bring
you back in with the demo.

00:02:52.400 --> 00:02:54.800
But let's get right to it.

00:02:55.040 --> 00:02:56.190
So I'm Daniel Abrams.

00:02:56.330 --> 00:03:00.090
I work out in the field as a
consulting engineer and I've been

00:03:00.220 --> 00:03:04.690
building web applications with
WebObjects for about three years now,

00:03:04.760 --> 00:03:07.900
large scale, small scale,
all sorts of different types.

00:03:07.900 --> 00:03:12.000
So I've run into these issues over
and over again and I think I have

00:03:12.090 --> 00:03:15.940
a pretty good and broad perspective
on how to fix these things.

00:03:15.940 --> 00:03:20.370
And I think if you've built WebObjects
applications out in the field at all,

00:03:20.370 --> 00:03:23.520
you've probably run into
these issues as well.

00:03:23.520 --> 00:03:25.330
So this is what I want to cover.

00:03:25.460 --> 00:03:29.770
I want to go over the default
WebObjects EOF deployment scenario

00:03:29.770 --> 00:03:32.860
that is out of the box when you go
to deploy a WebObjects application.

00:03:32.860 --> 00:03:35.190
What does that look like and
what effect does that have on

00:03:35.190 --> 00:03:36.840
caching and synchronization?

00:03:36.890 --> 00:03:38.990
I want to go over
fetching and snapshotting.

00:03:39.070 --> 00:03:43.260
Snapshotting is sort of at the heart of
the synchronization and caching issues,

00:03:43.350 --> 00:03:47.000
committing and receiving changes
and coordinating updates.

00:03:47.000 --> 00:03:50.400
So this is what the default
deployment scenario looks like.

00:03:50.500 --> 00:03:53.500
You essentially have a whole bunch of
client browsers out in the real world.

00:03:53.500 --> 00:03:55.040
You have a bunch of client
browsers out in the real world.

00:03:55.040 --> 00:03:58.950
You could have one or more web
servers and WebObjects adapters,

00:03:58.950 --> 00:04:01.650
but let's take the simple
situation where you have one.

00:04:01.780 --> 00:04:04.980
And it's very likely that if you
have any sort of volume at all

00:04:04.980 --> 00:04:09.100
coming into your application,
you have multiple application instances.

00:04:09.100 --> 00:04:11.660
So if you look at this slide,
you'll see we have instance

00:04:11.720 --> 00:04:12.600
one and instance two.

00:04:12.600 --> 00:04:15.900
And within each instance,
we have multiple editing contexts

00:04:15.900 --> 00:04:18.000
sitting on top of a shared EOF stack.

00:04:18.000 --> 00:04:21.510
So that's essentially what you
get out of the box with WebObjects

00:04:21.510 --> 00:04:26.290
without making any changes to the
the default deployment scenario.

00:04:28.350 --> 00:04:31.290
So I wanted to spend a little
time talking about snapshots

00:04:31.400 --> 00:04:34.810
because I think that if you
understand how snapshots work,

00:04:34.860 --> 00:04:39.610
how broadcasts occur and what's going
on behind the scenes with your data,

00:04:39.610 --> 00:04:45.280
then you can figure out any given
caching or synchronization issue.

00:04:45.280 --> 00:04:48.780
There's the master repository
for coordinating all data

00:04:48.890 --> 00:04:50.500
retrieval and updates.

00:04:51.660 --> 00:04:57.430
And by default, in a single instance,
you have editing context

00:04:57.480 --> 00:04:59.080
sharing a set of snapshots.

00:05:01.030 --> 00:05:04.480
So these are some of the issues that
when I go in and I see clients who

00:05:04.560 --> 00:05:07.980
have built WebObjects applications,
they talk about or they say,

00:05:08.200 --> 00:05:10.610
"Why is it that I'm not
seeing the freshest data?

00:05:10.840 --> 00:05:13.130
Or why am I seeing the
application hit the database,

00:05:13.260 --> 00:05:19.710
but my users aren't seeing that data
show up?" So let's talk a little bit

00:05:19.710 --> 00:05:19.710
about how fetching occurs in WebObjects.

00:05:21.170 --> 00:05:24.480
So one thing before we get into this
that I wanted to go over was that

00:05:24.480 --> 00:05:28.390
when you do have multiple application
instances in a deployment scenario,

00:05:28.480 --> 00:05:31.860
by default, they're not communicating
with each other at all.

00:05:31.860 --> 00:05:35.390
So this leads into the first level
of complexity of what would seem to

00:05:35.390 --> 00:05:37.310
be a relatively simple situation.

00:05:37.310 --> 00:05:40.070
We're about to see a number
of behaviors where within a

00:05:40.070 --> 00:05:43.910
single application instance,
editing contexts are communicating with

00:05:43.960 --> 00:05:47.950
one another because they share a shared
stack and a shared set of snapshots.

00:05:47.950 --> 00:05:52.400
But when we're in multiple instances,
there's no communication going on

00:05:52.400 --> 00:05:54.470
whatsoever between those instances.

00:05:54.490 --> 00:05:58.710
So if an editing context in one instance
makes an update to the database,

00:05:58.710 --> 00:06:03.660
the editing contexts that sit in the
other instance in no way recognize that.

00:06:03.660 --> 00:06:07.750
And it's essentially the equivalent
of another application going in and

00:06:07.780 --> 00:06:09.600
making a change to the database.

00:06:09.600 --> 00:06:12.870
There's no real difference
from within the instance.

00:06:13.600 --> 00:06:18.930
So let's talk about a fetch within
a single application instance.

00:06:19.010 --> 00:06:21.060
For those who don't know,
for those who weren't familiar with

00:06:21.080 --> 00:06:23.380
the concept of fetch specifications,
in EOF,

00:06:23.380 --> 00:06:29.100
you essentially can programmatically
construct a fetch specification.

00:06:29.100 --> 00:06:31.070
And there's a series of parameters.

00:06:31.080 --> 00:06:33.920
When we go over the demo app,
I'll show you how you do that.

00:06:33.990 --> 00:06:36.860
That allows you to query a database,
get back a group of objects,

00:06:36.860 --> 00:06:39.210
and display them to the user,
if you want to.

00:06:39.310 --> 00:06:43.260
So after you've constructed this fetch
specification and triggered a fetch,

00:06:43.260 --> 00:06:46.260
we'll obviously query the
database to get the data.

00:06:46.260 --> 00:06:49.570
We'll snapshot that object
within that shared stack.

00:06:49.930 --> 00:06:54.530
So even though a given editing context,
in this case, editing context one,

00:06:54.530 --> 00:06:58.240
has triggered a fetch,
it's actually snapshotted

00:06:58.240 --> 00:07:00.300
in a shared location.

00:07:00.520 --> 00:07:04.390
So editing context two and editing
context three will eventually

00:07:04.390 --> 00:07:06.460
become aware of that object,
as we'll see,

00:07:06.460 --> 00:07:08.940
as they either fetch it or manipulate it.

00:07:08.940 --> 00:07:11.640
And finally,
we create an object and pull it

00:07:11.710 --> 00:07:14.740
into the first editing context.

00:07:15.630 --> 00:07:21.420
So now I want to talk about what happens
when an additional editing context

00:07:21.420 --> 00:07:23.330
attempts to display the same object.

00:07:23.430 --> 00:07:27.260
So in this particular case,
we have editing context to initiating

00:07:27.260 --> 00:07:31.140
a fetch on the same object,
an object with global ID 1.

00:07:31.140 --> 00:07:35.250
Global ID is just EOF's way of
displaying and packaging up primary keys.

00:07:35.320 --> 00:07:37.970
So it's just a way of uniquely
identifying an object.

00:07:38.810 --> 00:07:41.280
So in this case,
we do the exact same thing.

00:07:41.280 --> 00:07:45.820
Editing context to triggers a fetch
on an object with global ID 1.

00:07:45.820 --> 00:07:46.890
We query the database.

00:07:47.220 --> 00:07:51.610
And what's significant here is
that when that data comes back,

00:07:51.610 --> 00:07:54.980
we actually ignore any
updates to the data.

00:07:54.980 --> 00:07:54.980
So

00:07:55.310 --> 00:07:58.930
If an external instance or even some
other external application has changed

00:07:59.110 --> 00:08:02.780
that data and we simply do a fetch,
the out of the box behavior is

00:08:03.010 --> 00:08:04.200
that you're not going to see it.

00:08:04.320 --> 00:08:06.540
So this is the first thing that
actually throws people off.

00:08:06.680 --> 00:08:07.960
They're not aware of this.

00:08:08.080 --> 00:08:10.720
They construct a fetch spec,
they fetch their data,

00:08:10.940 --> 00:08:13.110
and they don't see updates,
but they do see the application

00:08:13.160 --> 00:08:14.120
hitting the database.

00:08:14.150 --> 00:08:16.880
And I'll show you that in the demo.

00:08:16.880 --> 00:08:20.730
But it's important to be aware
that that's the default behavior.

00:08:21.740 --> 00:08:23.420
So we've ignored updates.

00:08:23.420 --> 00:08:26.740
We create an object in Editing Context 2,
but that object is actually

00:08:26.740 --> 00:08:31.040
created off the snapshot because
we haven't specified otherwise.

00:08:31.420 --> 00:08:36.960
So I want to talk about what you can do
to change that situation if you want to.

00:08:36.970 --> 00:08:40.570
Let's say that you always want users
to have fresh data or you want users to

00:08:40.570 --> 00:08:42.520
have fresh data in this particular case.

00:08:42.520 --> 00:08:45.060
What are some of the things that
you can do to make that happen?

00:08:45.230 --> 00:08:48.180
Well, one of the things you can do is on
your fetch specs you can use a method

00:08:48.260 --> 00:08:51.900
called Refreshes Refetched Objects.

00:08:51.900 --> 00:08:54.770
And if you do that,
when you query the database

00:08:54.960 --> 00:08:58.260
and the data comes back,
it updates the snapshot.

00:08:58.260 --> 00:09:01.280
So in this case,
Editing Context 3 has triggered

00:09:01.280 --> 00:09:05.780
a fetch and they've set that
flag for Refetched Objects to on.

00:09:05.870 --> 00:09:09.170
So we query the database and we
can see that the snapshot gets

00:09:09.170 --> 00:09:11.180
updated in that shared stack.

00:09:11.190 --> 00:09:13.880
Now, there's an additional
wrinkle when this happens.

00:09:13.880 --> 00:09:18.550
When we have an update to a snapshot,
all of the editing contexts that

00:09:18.550 --> 00:09:22.050
share that stack are referred
to as Peer Editing Context,

00:09:22.330 --> 00:09:25.500
receive that change,
receive a broadcast of that change.

00:09:25.500 --> 00:09:31.210
So, we can see that when this
snapshot gets updated,

00:09:31.210 --> 00:09:35.540
we broadcast out to those editing
contexts that are peers that already

00:09:35.540 --> 00:09:38.440
have an instance of that object.

00:09:38.440 --> 00:09:41.260
And then we pull that object
into Editing Context 3.

00:09:41.270 --> 00:09:45.790
Now, we'll get into more detail later
what happens if Editing Context

00:09:45.790 --> 00:09:49.230
1 or Editing Context 2 have made
changes to that object before

00:09:49.230 --> 00:09:50.620
that broadcast has occurred.

00:09:50.620 --> 00:09:52.760
And what actually happens
is you get a merge.

00:09:52.760 --> 00:09:55.400
And we'll talk about that more
when we get it more in detail.

00:09:55.400 --> 00:09:58.770
So,
we're going to go into synchronization.

00:09:58.820 --> 00:10:01.060
There's an additional wrinkle
I wanted to talk about,

00:10:01.060 --> 00:10:03.840
which is specific to 4.5.

00:10:03.840 --> 00:10:09.090
So, 4.5 has added a number of different
ways that you can manipulate the way

00:10:09.090 --> 00:10:12.040
objects are refreshed or updated.

00:10:12.040 --> 00:10:16.640
And they sort of add an additional
level of flexibility to what you can do,

00:10:16.640 --> 00:10:19.920
but also an additional layer of
complexity that you have to be aware of.

00:10:19.930 --> 00:10:24.500
So, in 4.5, if Editing Context 3
were to trigger a fetch,

00:10:24.500 --> 00:10:27.110
this slide shows how the
query database and check

00:10:27.200 --> 00:10:29.060
timestamp are actually inverted.

00:10:29.060 --> 00:10:33.150
So, what will happen is Editing
Context 3 triggers a fetch.

00:10:33.150 --> 00:10:35.210
We will check the timestamp.

00:10:35.250 --> 00:10:39.440
If that timestamp has expired,
we'll actually go back to the database.

00:10:39.440 --> 00:10:40.570
We'll do a query.

00:10:40.620 --> 00:10:43.580
We'll update the snapshot.

00:10:43.580 --> 00:10:46.640
And again,
because the snapshot has been updated,

00:10:46.690 --> 00:10:48.480
we'll broadcast those changes

00:10:51.600 --> 00:10:54.500
So I wanted to talk about one
of the alternative methods that

00:10:54.500 --> 00:10:58.900
you can use to update snapshots,
and that's invalidating objects.

00:10:58.980 --> 00:11:02.780
So I've added a little bit of
complexity here to the diagram.

00:11:02.780 --> 00:11:05.980
What you see in each of the
editing contexts is the object

00:11:05.980 --> 00:11:09.660
that we were talking about before,
and it now has a too many relationship,

00:11:09.670 --> 00:11:13.280
because relationships are actually
treated a little bit differently.

00:11:13.290 --> 00:11:15.680
And again,
we're sort of layering complexity

00:11:15.680 --> 00:11:17.660
on top of what we were doing before.

00:11:17.740 --> 00:11:24.160
So one thing that happens when you
do a fetch with refresh turned on,

00:11:24.180 --> 00:11:27.800
you actually don't update that
object's too many relationships.

00:11:27.870 --> 00:11:31.310
So you might see changes to that object,
but you're not going to see changes

00:11:31.430 --> 00:11:35.940
to the too many relationship or the
other relationships that it has,

00:11:35.940 --> 00:11:37.480
even 2-1 relationships.

00:11:37.530 --> 00:11:40.740
So I want to spend a little time
dealing with both alternative ways of

00:11:40.740 --> 00:11:46.320
invalidating as well as methods for
dealing with updating relationships.

00:11:46.380 --> 00:11:49.400
So in this particular case,
we have editing context one

00:11:49.400 --> 00:11:52.620
invalidating the given object
that we were talking about.

00:11:52.660 --> 00:11:55.340
And there's two ways to do invalidation.

00:11:55.450 --> 00:11:59.000
One is on an individual object,
and one is to invalidate every

00:11:59.000 --> 00:12:02.150
object in either the editing
context or within the stack.

00:12:02.200 --> 00:12:05.350
We'll deal with individually first,
and then we'll move on

00:12:05.350 --> 00:12:07.520
to invalidating globally.

00:12:07.620 --> 00:12:11.030
So when editing context one
triggers this invalidation,

00:12:11.080 --> 00:12:12.650
we refault the object.

00:12:12.680 --> 00:12:17.650
We refault its too many relationships,
but we preserve its 2-1 relationship.

00:12:17.660 --> 00:12:18.720
Thank you.

00:12:19.620 --> 00:12:22.630
When editing context
one trips that fault,

00:12:22.720 --> 00:12:25.500
we see a series of
actions occur as a result.

00:12:25.500 --> 00:12:28.390
We first query the database
against that object,

00:12:28.620 --> 00:12:32.350
so we now have a fault for that
object and it specifically queries

00:12:32.460 --> 00:12:34.680
for that particular object.

00:12:34.680 --> 00:12:37.400
We update the snapshot
and update that object,

00:12:37.410 --> 00:12:42.760
and then we broadcast those changes out
because the snapshot has been updated.

00:12:42.760 --> 00:12:46.200
Now there's one additional wrinkle here,
which is that the broadcast actually

00:12:46.300 --> 00:12:50.000
occurs a little differently than it
does when you have refreshes turned on.

00:12:50.130 --> 00:12:53.790
In the case of refresh,
when you broadcast out in editing

00:12:54.240 --> 00:12:57.860
context two or editing context three,
if you had a dirty object,

00:12:57.860 --> 00:13:00.030
that is an object that
someone has modified,

00:13:00.030 --> 00:13:02.420
that broadcast would
merge in those changes.

00:13:02.420 --> 00:13:04.430
When you invalidate an object,
by default,

00:13:04.430 --> 00:13:07.510
if you don't do anything else,
it will overwrite those changes

00:13:07.580 --> 00:13:11.480
and the users in the other editing
contexts will lose their changes.

00:13:11.480 --> 00:13:14.590
So in some ways,
invalidating is a more powerful tool,

00:13:14.590 --> 00:13:16.260
but in some ways you have
to do it in a different way.

00:13:16.260 --> 00:13:16.260
So in some ways,
invalidating is a more powerful tool,

00:13:16.260 --> 00:13:16.300
but in some ways you have
to do it differently.

00:13:16.360 --> 00:13:16.360
So in some ways,
invalidating is a more powerful tool,

00:13:16.360 --> 00:13:16.360
but in some ways,
invalidating is a more powerful tool,

00:13:16.360 --> 00:13:16.360
but in some ways,
invalidating is a more powerful tool,

00:13:16.360 --> 00:13:19.040
but in some ways, you have to be careful
because you could potentially

00:13:19.040 --> 00:13:20.930
overwrite other users' changes.

00:13:21.080 --> 00:13:26.900
So right now we have this object
with global ID 1 pulled into

00:13:26.900 --> 00:13:29.670
each of the editing contexts,
but we still have the too

00:13:29.810 --> 00:13:32.640
many relationship faulted,
and I want to go over what happens

00:13:32.640 --> 00:13:35.400
when that fault is tripped as well.

00:13:35.840 --> 00:13:38.900
So when the too many
relationship fault is stripped,

00:13:39.010 --> 00:13:41.460
we will create a database for
that too many relationship,

00:13:41.600 --> 00:13:45.620
just like it did the first time,
but it will actually discard the changes.

00:13:45.760 --> 00:13:49.700
So you will not see any updates to
the too many relationship when you

00:13:49.700 --> 00:13:53.700
invalidate an object like that,
and then it will pull that relationship

00:13:53.700 --> 00:13:55.460
in from the existing snapshot.

00:13:55.600 --> 00:13:59.680
So invalidating objects
individually is an effective

00:13:59.680 --> 00:14:04.610
way to update the given object,
but it will not work for updating

00:14:04.610 --> 00:14:07.700
changes to a too many relationship.

00:14:07.700 --> 00:14:10.560
And actually, as an additional wrinkle,
it will query the database

00:14:10.570 --> 00:14:11.620
against that relationship.

00:14:11.620 --> 00:14:15.400
So I'll show you the demo app,
and users are sometimes confused

00:14:15.400 --> 00:14:19.410
because they see that query occur,
but you don't see changes.

00:14:20.080 --> 00:14:21.920
So finally,
the most drastic thing you can

00:14:21.920 --> 00:14:25.690
do is invalidate all the objects.

00:14:26.260 --> 00:14:29.920
When you invalidate all the objects,
essentially everything,

00:14:30.070 --> 00:14:32.210
either in the editing
context or the shared stack,

00:14:32.210 --> 00:14:33.020
is refaulted.

00:14:33.120 --> 00:14:36.960
So every object is refaulted,
every relationship is refaulted.

00:14:37.200 --> 00:14:42.200
Every time you trip one of those faults,
you're going to have a new query.

00:14:42.200 --> 00:14:44.200
Every snapshot is updated.

00:14:44.200 --> 00:14:47.200
All those changes are broadcast,
including too many.

00:14:47.230 --> 00:14:51.470
So when you invalidate all the objects,
you will

00:14:53.090 --> 00:14:57.600
update the TooMany's that's an
effective way of pulling in new

00:14:57.600 --> 00:15:01.010
data through your TooMany's,
but there's a lot of really

00:15:01.010 --> 00:15:05.400
significant issues associated
with invalidating all objects.

00:15:05.400 --> 00:15:11.200
One is that it's very expensive, period,
to try and pull every single object as

00:15:11.330 --> 00:15:13.520
you trip them back into the database.

00:15:13.520 --> 00:15:15.440
And two is,
it can actually be more expensive

00:15:15.530 --> 00:15:17.480
than your original queries.

00:15:17.480 --> 00:15:20.730
So if you pull in a bunch of
objects into editing context

00:15:20.730 --> 00:15:23.950
through a series of queries,
you pull those objects

00:15:23.950 --> 00:15:25.680
in in sets at a time,
right?

00:15:25.820 --> 00:15:28.510
So you might pull in objects
five or ten at a time.

00:15:28.650 --> 00:15:32.010
Unless you recreate every single
one of those original queries when

00:15:32.010 --> 00:15:35.820
you have to even validate it all,
it's going to trigger a fetch

00:15:35.890 --> 00:15:40.670
individually on each of those
objects as you trip the faults.

00:15:41.610 --> 00:15:46.650
The other issue is that it will
wipe out any changes to any editing

00:15:46.650 --> 00:15:48.660
context that share those objects.

00:15:48.770 --> 00:15:53.260
So if editing context one invalidates
all objects and editing context two,

00:15:53.260 --> 00:15:57.270
editing context three happen to
be making changes to those objects

00:15:57.320 --> 00:16:00.400
or deleted those objects but
haven't committed those changes,

00:16:00.440 --> 00:16:03.700
those changes will be lost.

00:16:03.700 --> 00:16:03.700
So,

00:16:04.090 --> 00:16:09.430
One user will have the freshest data,
but another user may simply lose

00:16:09.430 --> 00:16:12.400
data behind the scenes without
really realizing what's going on.

00:16:12.400 --> 00:16:15.450
So you have to be very careful
when you do that to ensure that

00:16:15.650 --> 00:16:16.950
your users don't lose data.

00:16:17.050 --> 00:16:19.430
And then the other thing to
be aware of is that with every

00:16:19.430 --> 00:16:21.940
single one of these mechanisms,
when you actually go to

00:16:21.940 --> 00:16:24.840
deploy an application,
a user may end up on one

00:16:24.840 --> 00:16:28.000
instance or multiple instances.

00:16:28.280 --> 00:16:30.180
Actually,
a better way to say that is that users

00:16:30.180 --> 00:16:33.940
may end up on a shared instance or they
may end up across application instances.

00:16:34.000 --> 00:16:37.510
So if they end up on a shared
application instance and you're

00:16:37.660 --> 00:16:42.100
doing things like updating fetches
with refresh or invalidating objects,

00:16:42.100 --> 00:16:45.680
then those two users who are editing
the same object are going to see

00:16:45.850 --> 00:16:48.000
changes as a result of those broadcasts.

00:16:48.000 --> 00:16:53.370
If by random chance they happen to end up
on two different application instances,

00:16:53.370 --> 00:16:57.060
even if your code is exactly the same,
they're going to see a different

00:16:57.060 --> 00:16:58.000
set of behavior changes.

00:16:58.000 --> 00:17:01.320
So potentially users are going to
be very confused unless you're very

00:17:01.320 --> 00:17:04.790
careful about the way you're doing
this because from their perspective,

00:17:05.100 --> 00:17:05.940
they're doing the exact same thing.

00:17:06.010 --> 00:17:08.400
But from the perspective of
the WebObjects application

00:17:08.520 --> 00:17:11.400
instances that are running,
they're either not communicating

00:17:11.410 --> 00:17:14.490
with each other or they aren't,
just depending on where

00:17:14.490 --> 00:17:15.980
those users ended up.

00:17:17.240 --> 00:17:21.610
You particularly start to get into
these issues when you talk about

00:17:21.610 --> 00:17:25.370
coordinating changes and different
users having the ability to edit

00:17:25.370 --> 00:17:27.200
the same object at the same time.

00:17:27.200 --> 00:17:30.200
I want to start going
over some of those things,

00:17:30.200 --> 00:17:34.390
talk a bit about the locking
behavior in EOF and how it works,

00:17:34.680 --> 00:17:38.340
explain why sometimes users see that
locking and sometimes they don't,

00:17:38.740 --> 00:17:42.670
and explain why relationships can change.

00:17:43.910 --> 00:17:47.800
So let's talk about committing changes
within a single application instance.

00:17:47.800 --> 00:17:51.320
So what we're looking at
here is editing context one,

00:17:51.410 --> 00:17:54.880
modifying and committing
changes to an object.

00:17:54.880 --> 00:17:56.530
It has a too many relationship.

00:17:56.530 --> 00:17:58.560
We won't worry about that right now.

00:17:58.630 --> 00:18:02.600
And as you can see,
all of the other objects are in

00:18:02.710 --> 00:18:04.190
line with what's in the snapshot.

00:18:04.300 --> 00:18:08.360
So what I mean is in editing context two,
you can see that there haven't

00:18:08.360 --> 00:18:10.360
been any changes to the object.

00:18:10.360 --> 00:18:14.000
The data in editing context two is the
same data that's in the snapshot and

00:18:14.000 --> 00:18:16.100
the same with editing context three.

00:18:16.100 --> 00:18:18.700
So right now,
the only user who's committed changes

00:18:18.810 --> 00:18:21.220
to an object is in editing context one.

00:18:21.220 --> 00:18:24.420
He modifies the object and commits.

00:18:24.420 --> 00:18:26.380
He goes to save to the database.

00:18:26.380 --> 00:18:28.420
So we see an update to the database.

00:18:28.420 --> 00:18:29.820
The snapshot is updated.

00:18:30.000 --> 00:18:32.120
And again,
every time the snapshot is updated,

00:18:32.260 --> 00:18:35.780
we're going to broadcast out those
changes to other editing contexts,

00:18:35.780 --> 00:18:39.090
that is,
other users who are sharing a stack.

00:18:41.340 --> 00:18:42.930
So, okay, good.

00:18:43.060 --> 00:18:47.740
Before it was getting cut off,
but I think it's okay.

00:18:47.740 --> 00:18:50.340
So in this particular case,
I want to talk about what happens

00:18:50.390 --> 00:18:53.490
when two users within the same
application instance modify and

00:18:53.580 --> 00:18:58.220
attempt to commit changes to an
object at essentially the same time.

00:18:58.610 --> 00:19:02.490
So, editing context one and edit
context two modify an object.

00:19:02.620 --> 00:19:05.800
So, editing context one and editing
context two are now out of sync

00:19:05.930 --> 00:19:07.490
with what's in the snapshot.

00:19:07.910 --> 00:19:12.730
They haven't committed their changes,
but they're carrying around locally dirty

00:19:12.930 --> 00:19:16.480
versions of this object with global ID 1.

00:19:17.290 --> 00:19:20.680
Editing Context 1 goes
to commit its change.

00:19:20.680 --> 00:19:24.310
We update the database,
checking to make sure that we

00:19:24.310 --> 00:19:27.070
don't have a locking failure,
which in this case we don't.

00:19:27.190 --> 00:19:31.190
The snapshot was in sync with
what was in the database.

00:19:31.260 --> 00:19:37.200
The snapshot is then updated and
the changes are broadcast out.

00:19:37.200 --> 00:19:40.570
You notice Editing Context 3
has received that broadcast,

00:19:40.570 --> 00:19:43.500
while Editing Context 2
receives that broadcast,

00:19:43.500 --> 00:19:46.200
but essentially maintains
its own changes.

00:19:46.200 --> 00:19:51.090
We'll attempt to merge in those changes
and where there's discrepancies,

00:19:51.270 --> 00:19:55.380
Editing Context 2 will reapply
the changes that it's already

00:19:55.480 --> 00:19:57.960
made and maintain those changes.

00:19:58.770 --> 00:20:01.620
And the other thing to note is
that right now the snapshot is in

00:20:01.620 --> 00:20:03.600
sync with what's in the database.

00:20:03.600 --> 00:20:06.070
So,
Editing Context 1 has committed a change.

00:20:06.240 --> 00:20:07.320
We updated the database.

00:20:07.450 --> 00:20:08.700
We updated the snapshot.

00:20:08.700 --> 00:20:10.640
So, those two are in sync.

00:20:10.700 --> 00:20:13.770
And that's important because this
is essentially EOF's mechanism

00:20:13.850 --> 00:20:15.700
for doing optimistic locking.

00:20:15.700 --> 00:20:16.140
Right?

00:20:16.140 --> 00:20:19.320
So, what happens when you go to save a
change is we compare what's in the

00:20:19.380 --> 00:20:21.280
snapshot with what's in the database.

00:20:21.360 --> 00:20:24.140
And if they're out of sync,
we have an optimistic locking failure.

00:20:24.320 --> 00:20:27.510
And as long as those two are in sync,
we're not going to get an optimistic

00:20:27.510 --> 00:20:30.700
locking failure and we're going to
be allowed to update those changes.

00:20:30.700 --> 00:20:33.460
So,
let's look at what happens when Editing

00:20:33.460 --> 00:20:36.130
Context 2 goes to commit its changes.

00:20:36.160 --> 00:20:39.020
The database is updated because,
like I said,

00:20:39.020 --> 00:20:43.250
the snapshot was in sync with what's
in the database and we broadcast those

00:20:43.250 --> 00:20:45.100
changes out to the other objects.

00:20:45.100 --> 00:20:48.840
So the important thing to note here
is that the out-of-the-box behavior

00:20:49.220 --> 00:20:54.100
is even when you have an attribute
on a given object marked for locking,

00:20:54.390 --> 00:20:58.090
within the same application instance
they share the same stack by default,

00:20:58.190 --> 00:21:03.590
they share the same set of snapshots,
so you're not going to see one editing

00:21:03.610 --> 00:21:08.540
context that's a pure of another
attempt to lock against each other.

00:21:09.940 --> 00:21:12.860
Now I want to talk about the
exact same behavior within

00:21:12.860 --> 00:21:14.660
multiple editing contexts.

00:21:14.660 --> 00:21:18.160
So in this case we have editing
context one and editing context

00:21:18.310 --> 00:21:19.840
three modifying an object.

00:21:19.840 --> 00:21:22.850
You can see that they're in
different application instances and

00:21:22.850 --> 00:21:26.150
attempting to commit those changes.

00:21:26.910 --> 00:21:31.980
So, editing context one and three,
modify the object, and you can see that.

00:21:32.920 --> 00:21:37.470
Editing Context 1 updates the database
and we lock against the snapshot.

00:21:37.490 --> 00:21:39.550
So in this particular case,
the database is in

00:21:39.550 --> 00:21:40.650
sync with the snapshot.

00:21:40.720 --> 00:21:43.420
We don't have any problems with locking.

00:21:43.880 --> 00:21:46.160
The snapshot is updated,
and we broadcast out to

00:21:46.160 --> 00:21:48.360
the other shared instances.

00:21:48.510 --> 00:21:52.440
So editing context 2 is now aware
of the fact that we've committed

00:21:52.440 --> 00:21:55.210
this update to the database,
whereas editing context 3 and

00:21:55.210 --> 00:21:56.860
editing context 4 are not.

00:21:56.990 --> 00:22:01.670
And just to be perfectly clear,
from a user's perspective,

00:22:01.670 --> 00:22:02.900
there's really no difference.

00:22:02.900 --> 00:22:06.460
They could have ended up in
the first application instance,

00:22:06.510 --> 00:22:07.840
and they could have
ended up in the second.

00:22:07.840 --> 00:22:10.760
They could be editing
context 2 or 3 or 4.

00:22:11.040 --> 00:22:14.830
They really don't know what editing
context they're going in the beginning.

00:22:16.000 --> 00:22:18.580
So let's see what happens when
editing context three commits

00:22:18.580 --> 00:22:20.600
changes to the database.

00:22:20.600 --> 00:22:24.330
We go to lock against the
snapshot and in this case we fail,

00:22:24.340 --> 00:22:27.790
right, because we have a snapshot
that has been updated,

00:22:27.900 --> 00:22:30.430
or rather a database that has
been updated since the last

00:22:30.560 --> 00:22:32.210
time we've updated the snapshot.

00:22:32.240 --> 00:22:35.740
So editing context one,
or rather application instance one,

00:22:35.850 --> 00:22:37.120
updated the database.

00:22:37.130 --> 00:22:41.020
Editing context two goes to update
that database and it's going to fail

00:22:41.020 --> 00:22:43.860
with an optimistic locking failure.

00:22:44.810 --> 00:22:50.050
So I wanted to go right to the demo
and show you some of these behaviors.

00:22:50.080 --> 00:22:53.170
There's actually some additional
wrinkles that come into play when you're

00:22:53.170 --> 00:22:55.110
doing this in a real world situation.

00:22:55.230 --> 00:22:58.180
So from a high level,
or from an application instance level,

00:22:58.270 --> 00:22:59.810
this is exactly what happens.

00:22:59.890 --> 00:23:02.130
But because the web
is a stateless medium,

00:23:02.130 --> 00:23:06.440
there's some additional wrinkles that are
introduced when you have a web browser

00:23:06.440 --> 00:23:11.100
that has a chance to get out of sync
with what's actually in your application.

00:23:11.100 --> 00:23:14.780
So if we could cut over
to the demo machine,

00:23:14.780 --> 00:23:15.670
that'd be good.

00:23:21.300 --> 00:23:24.440
So the demo is about as
simple as you can get.

00:23:24.440 --> 00:23:26.400
This is the EO model for the demo.

00:23:26.400 --> 00:23:29.920
You can see we have an object called
movie here with a too many relationship

00:23:30.060 --> 00:23:34.040
to role and a 2-1 relationship to studio.

00:23:34.080 --> 00:23:38.220
And essentially I've
constructed a demo that

00:23:40.100 --> 00:24:13.000
[Transcript missing]

00:24:14.310 --> 00:24:18.880
So these two different sessions,
and I'm going to start to make

00:24:18.990 --> 00:24:21.430
some changes to the objects.

00:24:21.440 --> 00:24:24.280
So I've done a fetch,
and I've pulled all the objects into

00:24:24.350 --> 00:24:27.100
each of the associated editing contexts.

00:24:27.120 --> 00:24:30.140
Right now they're on the
same application instance,

00:24:30.250 --> 00:24:34.100
and I'm going to make a change.

00:24:37.550 --> 00:24:40.060
So I'm going to go behind the
scenes and I'm going to edit

00:24:40.110 --> 00:24:41.660
one of the objects directly.

00:24:41.700 --> 00:24:45.290
So I'm going to edit the
movie's description and change

00:24:45.290 --> 00:24:50.100
this from labor union history,
let's say, to labor union movie.

00:24:54.160 --> 00:24:57.540
So right now you would
expect that if I did a fetch,

00:24:57.540 --> 00:25:00.000
I probably wouldn't see that change
according to what I told you.

00:25:00.120 --> 00:25:01.490
So let's go ahead and do that.

00:25:01.610 --> 00:25:06.740
And before we do that,
I just want to pull up what's

00:25:06.950 --> 00:25:10.670
going on so you can see.

00:25:13.620 --> 00:25:17.680
So we do a fetch against those movies.

00:25:17.700 --> 00:25:19.570
You can see that

00:25:20.520 --> 00:25:21.710
We've hit the database.

00:25:22.020 --> 00:25:25.860
We've actually pulled
back all three movies,

00:25:25.860 --> 00:25:29.160
but we don't see that change, right?

00:25:31.000 --> 00:25:33.380
So I want to do the same thing,
but this time I'll do a fetch

00:25:33.520 --> 00:25:35.580
and refresh the snapshot.

00:25:35.580 --> 00:25:39.440
So according to what I've told you,
if you fetch and refresh the snapshot,

00:25:39.470 --> 00:25:42.380
you should pull back from the database,
update that snapshot,

00:25:42.500 --> 00:25:46.370
broadcast out to the other instances,
and you should see the change.

00:25:46.510 --> 00:25:48.900
So let's do that.

00:25:48.900 --> 00:25:50.760
Sure enough, we see the change.

00:25:51.060 --> 00:25:53.890
But I want to introduce
an additional wrinkle.

00:25:54.050 --> 00:25:58.540
So let's actually go to the
other application instance and

00:25:58.590 --> 00:26:00.900
let's do something similar.

00:26:02.250 --> 00:26:04.790
Let's do fetch and refresh,
and you would expect that

00:26:04.800 --> 00:26:06.240
you might see the change,
right?

00:26:06.300 --> 00:26:07.480
But you're not.

00:26:07.680 --> 00:26:12.230
So in this particular case,
we're still seeing labor union movie,

00:26:12.230 --> 00:26:16.860
whereas in this particular case,
we see the old value,

00:26:16.860 --> 00:26:18.240
labor union history.

00:26:18.240 --> 00:26:21.270
And if you go into the console,

00:26:21.670 --> 00:26:24.710
You can see that sure enough,
I'll demonstrate it just

00:26:24.870 --> 00:26:28.150
to be absolutely sure,
that when we go in and fetch,

00:26:28.160 --> 00:26:32.650
sure enough, we're hitting the database,
but we're not seeing any updates.

00:26:32.800 --> 00:26:34.670
So what's going on here?

00:26:34.770 --> 00:26:37.720
Well, what's going on is that

00:26:38.300 --> 00:26:42.310
When this first session went
and refreshed the snapshot,

00:26:42.310 --> 00:26:45.480
it broadcast out those changes
to all the other instances.

00:26:45.710 --> 00:26:48.380
So it pulled that data into
its own editing context,

00:26:48.510 --> 00:26:50.090
so we saw the change.

00:26:50.190 --> 00:26:54.370
It then broadcast that change out to
the editing context that's sitting

00:26:54.490 --> 00:26:58.600
on the server that is represented
by this particular session.

00:26:58.720 --> 00:27:02.890
But when this session went
back to do a fetch and refresh,

00:27:03.000 --> 00:27:04.700
it synchronized the bindings.

00:27:04.910 --> 00:27:08.660
So it took the values,
labor union history,

00:27:08.860 --> 00:27:15.090
that was saved within this overview,
compared it to the values it had,

00:27:15.090 --> 00:27:17.400
which had been broadcast
out from the other object,

00:27:17.410 --> 00:27:20.660
and noticed they were different,
and assumed that this particular

00:27:20.660 --> 00:27:22.500
user was actually making changes.

00:27:22.620 --> 00:27:26.160
So from this user's perspective,
he hasn't made any changes at all.

00:27:26.390 --> 00:27:28.450
And not only has he not
made any changes at all,

00:27:28.760 --> 00:27:31.970
but he's committed an
action that you would think,

00:27:31.990 --> 00:27:36.890
and that he would think,
would send him to... to the latest data.

00:27:36.910 --> 00:27:40.700
But in fact, it hasn't done that at all,
and in fact,

00:27:40.740 --> 00:27:45.170
committing this action has cemented
this older version of the object

00:27:45.310 --> 00:27:47.230
right back into the editing context.

00:27:47.400 --> 00:27:51.850
So if we were to hit save changes,
which does nothing more than an

00:27:51.910 --> 00:27:56.990
editing context save changes,
so it merely saves unchanged

00:27:57.410 --> 00:28:02.410
objects within his editing context,
it will actually update

00:28:02.410 --> 00:28:04.500
the database at this point.

00:28:04.500 --> 00:28:07.540
So I'll go ahead and do that.

00:28:11.830 --> 00:28:14.340
So we can see that it's
updated the database.

00:28:14.530 --> 00:28:18.840
So without either user being aware of it,
we've actually managed to overwrite

00:28:18.840 --> 00:28:24.070
the commit that the first user's done
and replace it with an older value.

00:28:24.220 --> 00:28:28.700
So this isn't even a case where two users
are attempting to edit the same data,

00:28:28.700 --> 00:28:32.150
but there's still one user fighting
against another and overwriting the data.

00:28:32.430 --> 00:28:36.920
And what's actually sort of interesting,
I want to do the same thing,

00:28:37.030 --> 00:28:39.680
but rather than fetch
and refresh the snapshot,

00:28:39.760 --> 00:28:42.680
which in this case is a
button which submits the form,

00:28:42.680 --> 00:28:46.120
I want to follow this hyperlink
that says "Do Nothing," which

00:28:46.120 --> 00:28:47.700
is essentially a no-op action.

00:28:47.700 --> 00:28:50.160
It simply returns the same page.

00:28:50.280 --> 00:28:54.200
But before I do that,
I want to clear out all the changes.

00:28:54.200 --> 00:28:57.450
So in both cases,
I'll invalidate all the objects.

00:28:57.450 --> 00:29:01.420
So we're completely up to date right now.

00:29:04.700 --> 00:29:07.690
I will commit to change the
database from the back end.

00:29:07.700 --> 00:29:13.660
So we'll change this back to labor union.

00:29:13.660 --> 00:29:16.730
I'll just get rid of the word altogether.

00:29:19.100 --> 00:29:20.420
So we're up to date in that.

00:29:20.640 --> 00:29:23.830
In this case,
we'll fetch and refresh snapshots

00:29:23.880 --> 00:29:26.940
exactly like we did before,
and we can see that it's gone.

00:29:26.990 --> 00:29:32.690
But in this case, we're going to follow
the do-nothing hyperlink.

00:29:34.000 --> 00:29:36.650
And you can see we're up to date.

00:29:36.740 --> 00:29:38.040
So what's the difference here?

00:29:38.190 --> 00:29:40.340
The difference is that
when we follow a hyperlink,

00:29:40.460 --> 00:29:43.310
we don't actually submit any
of the data that's in the form.

00:29:43.440 --> 00:29:45.600
We don't update those bindings.

00:29:45.740 --> 00:29:50.580
And so we see the update
that's been broadcast out to

00:29:50.580 --> 00:29:53.390
us in the editing context.

00:29:53.510 --> 00:29:57.680
So the other thing I want to
demonstrate is a very similar behavior,

00:29:57.680 --> 00:30:00.390
but with regards to
too many relationships.

00:30:00.540 --> 00:30:03.650
So let's clear everything out again.

00:30:06.550 --> 00:30:09.620
This time I'm going to
make a change to an EO,

00:30:09.940 --> 00:30:14.390
but I'm going to make the change
directly to one of the relationships.

00:30:19.590 --> 00:30:24.200
So I've now made a change
to this role right here.

00:30:24.200 --> 00:30:29.460
And in this particular case,
why don't we start by doing a fetch?

00:30:29.550 --> 00:30:32.020
So I'll do a fetch,
and you can see that we don't see

00:30:32.020 --> 00:30:36.400
the change to the relationship,
which is probably what you'd expect.

00:30:36.400 --> 00:30:39.240
And if we go to the console,
you can see that even though

00:30:39.240 --> 00:30:42.010
we don't see that change,
we've actually gone out

00:30:42.010 --> 00:30:44.140
and hit the database again.

00:30:44.280 --> 00:30:48.870
So let's do the same thing,
but let's this time do a fetch and

00:30:48.870 --> 00:30:52.330
movies and refresh the snapshot.

00:30:52.480 --> 00:30:55.400
Well, what do we have in this case?

00:30:56.250 --> 00:30:59.120
We again go out and hit the database.

00:30:59.270 --> 00:31:03.900
We again pull back those three rows,
but we again haven't seen that update.

00:31:03.940 --> 00:31:08.740
Okay,
why don't we try invalidating that movie?

00:31:11.230 --> 00:31:14.490
So we invalidate that movie.

00:31:14.490 --> 00:31:16.060
And again, we don't see that change.

00:31:16.220 --> 00:31:18.610
Let's look at what's going
on behind the scenes.

00:31:18.800 --> 00:31:20.680
You can see that we do a
fetch against the movie,

00:31:20.860 --> 00:31:24.320
so we pull back that particular movie,
the one that we've invalidated.

00:31:24.490 --> 00:31:27.250
We've also refaulted its
too many relationship,

00:31:27.330 --> 00:31:30.320
so we actually pull back
those new roles right here,

00:31:30.460 --> 00:31:32.340
but you're still not seeing it.

00:31:32.490 --> 00:31:34.240
So the point is that
even when you invalidate,

00:31:34.240 --> 00:31:37.980
you're not necessarily getting
updates to a too many relationship.

00:31:37.980 --> 00:31:41.020
So this time, let's invalidate all.

00:31:44.870 --> 00:31:46.970
So we do an invalidate all.

00:31:46.980 --> 00:31:50.740
You can see that we've actually
gotten that update to that object.

00:31:50.740 --> 00:31:53.290
But I mean, we really have a flurry
of database activity,

00:31:53.290 --> 00:31:53.590
right?

00:31:53.870 --> 00:31:58.870
We've hit the database once
for every single movie,

00:31:59.100 --> 00:32:01.460
whereas before we were pulling
back three movies at a time.

00:32:01.460 --> 00:32:04.790
And that's because we're
essentially iterating over an

00:32:04.790 --> 00:32:06.100
array with these movies in them.

00:32:06.100 --> 00:32:09.170
And rather than fetching,
we're simply pulling

00:32:09.170 --> 00:32:10.800
all those movies back.

00:32:12.130 --> 00:32:14.850
And then we're also fetching
back each of the relationships,

00:32:14.950 --> 00:32:16.560
so the too many and the too ones.

00:32:16.580 --> 00:32:19.120
But in this particular case,
when we pull back the too many,

00:32:19.120 --> 00:32:20.560
we can see that it's updated.

00:32:25.840 --> 00:32:29.760
So the other thing I wanted to show
you was the difference in behavior

00:32:29.760 --> 00:32:33.030
between when you update within a
single instance versus when you

00:32:33.030 --> 00:32:34.870
update within shared instances.

00:32:34.950 --> 00:32:37.890
So let's make a change.

00:32:38.180 --> 00:32:41.300
Actually, I think we're invalidated,
but just to be sure,

00:32:41.300 --> 00:32:45.200
let's clear out the entire cache.

00:32:45.240 --> 00:32:47.370
Let's make a change.

00:32:47.730 --> 00:32:48.810
So I have overview.

00:32:48.930 --> 00:32:53.780
I don't know if you noticed in the model,
but I have overview designated

00:32:53.780 --> 00:32:55.050
as a locking attribute.

00:32:55.380 --> 00:33:00.420
So you would expect that if two
different users make changes to

00:33:00.420 --> 00:33:04.300
an overview behind the scenes that
you should lock on that attribute.

00:33:04.990 --> 00:33:07.840
So when they're within
the same editing context,

00:33:07.840 --> 00:33:10.140
or sorry,
when they have the same shared stack,

00:33:10.140 --> 00:33:15.580
but so you have editing context that
share a stack and we commit saves.

00:33:20.700 --> 00:33:23.940
We're just going to see that
they can override each other.

00:33:24.020 --> 00:33:26.800
So let's take a look
at that in the console.

00:33:28.860 --> 00:33:32.290
So we have two sets of
updates right there,

00:33:32.290 --> 00:33:35.960
and we haven't detected any
conflicts because the snapshots are

00:33:35.960 --> 00:33:37.540
always in sync with the database.

00:33:37.620 --> 00:33:41.330
So even though those particular
attributes are marked for locking,

00:33:41.580 --> 00:33:42.760
we're able to update.

00:33:42.980 --> 00:33:46.440
But let's simulate the
exact same behavior within

00:33:46.590 --> 00:33:48.900
separate editing contexts.

00:33:49.050 --> 00:33:51.460
So we'll start over.

00:33:51.590 --> 00:33:53.890
Pull the plug.

00:33:54.050 --> 00:33:56.730
Make a change behind the scenes.

00:34:03.500 --> 00:34:05.550
I'll attempt to make a change.

00:34:05.660 --> 00:34:08.980
So this is, like I said,
analogous to a user in another

00:34:08.980 --> 00:34:12.500
application instance committing
a change to the database.

00:34:12.530 --> 00:34:17.830
And we'll also commit a change in this
editing context and attempt to save it.

00:34:18.690 --> 00:34:24.760
And what you can see is that we've got
an optimistic locking failure occurring.

00:34:24.820 --> 00:34:31.130
So the exact same behavior could result
in the user seeing either an update

00:34:31.130 --> 00:34:35.810
to the data or a locking failure,
depending on which application

00:34:35.810 --> 00:34:38.110
instance they end up in.

00:34:38.300 --> 00:34:40.520
So there's actually a couple
other things we could demo,

00:34:40.520 --> 00:34:42.720
but I think I'd rather just
jump right to questions and

00:34:42.720 --> 00:34:46.120
then as people have questions,
maybe we'll demo that behavior in there.

00:34:46.120 --> 00:34:50.050
So I'd like to bring Steve Miner
and Eric Nui-Yao up to the stage.

00:34:50.180 --> 00:34:53.150
They're both part of the
WebObjects engineering team

00:34:53.200 --> 00:34:55.040
and open it up for questions.

00:34:55.040 --> 00:35:00.590
First of all,
a big hand for our presenters.

00:35:00.590 --> 00:35:00.590
Thank you very much.
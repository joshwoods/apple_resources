WEBVTT

00:00:07.610 --> 00:00:12.680
Ladies and gentlemen, please welcome
Carbon Technology Manager David Wright.

00:00:17.700 --> 00:00:18.960
Thank you very much.

00:00:18.960 --> 00:00:23.220
Welcome to session 130,
"Carbon-- The Lower Levels." Oh, OK.

00:00:23.220 --> 00:00:24.410
I didn't see that title.

00:00:24.440 --> 00:00:26.890
Carbon, low level in the book.

00:00:27.190 --> 00:00:29.720
Wow, I'm really excited to see
how many of y'all made it.

00:00:29.720 --> 00:00:33.190
I know that lots of questions that
are going to be answered in this

00:00:33.190 --> 00:00:36.980
session were asked during previous
Q&As during the rest of the week.

00:00:36.980 --> 00:00:40.560
And I told you guys to keep coming here,
and you did, so I'm really glad.

00:00:40.560 --> 00:00:42.840
And then it's mixed with sadness,
because this is the last

00:00:42.840 --> 00:00:45.160
session of the conference,
so it's kind of weird.

00:00:45.160 --> 00:00:46.370
Ooh, I know.

00:00:46.420 --> 00:00:47.580
It's like Christmas ending.

00:00:47.580 --> 00:00:48.760
Well, for me, anyway.

00:00:48.760 --> 00:00:49.740
I don't know.

00:00:49.740 --> 00:00:50.240
I don't know.

00:00:50.240 --> 00:00:51.980
Has it been a good
conference for you guys?

00:00:51.980 --> 00:00:53.280
I sure hope so.

00:00:53.280 --> 00:00:53.780
Yeah.

00:00:53.780 --> 00:00:55.940
I'm so glad.

00:00:55.940 --> 00:00:56.900
Great.

00:00:56.900 --> 00:01:00.070
We have so much information to get out,
and I'm so glad you

00:01:00.080 --> 00:01:01.200
were here to receive it.

00:01:01.200 --> 00:01:03.540
We've certainly received
a lot of good feedback.

00:01:03.540 --> 00:01:06.780
Have a lot to go back to Apple with
and work on to make bringing your

00:01:06.780 --> 00:01:10.220
applications to 10 a lot easier.

00:01:10.220 --> 00:01:13.190
So anyway,
let's nail down the final details of

00:01:13.200 --> 00:01:16.400
what's involved for you as you bring
your applications to 10 by Carbonite.

00:01:16.400 --> 00:01:18.280
We're going to have a
little bit of a chat.

00:01:18.280 --> 00:01:22.040
We're going to have a little
bit of a chat with the team.

00:01:31.180 --> 00:01:34.260
Good afternoon.

00:01:34.260 --> 00:01:36.280
Wow.

00:01:36.280 --> 00:01:40.540
Glad everyone can make it on
5:00 on a Friday afternoon.

00:01:43.460 --> 00:01:48.240
So I'm going to take you through,
as it says, Carbon Lower Levels.

00:01:48.240 --> 00:01:53.250
It's a pretty generic term,
starting with a slide that I'm

00:01:53.260 --> 00:01:55.390
sure everyone here has seen.

00:01:55.460 --> 00:02:00.400
Anyone here not seen this slide yet?

00:02:00.520 --> 00:02:05.280
Here there's alternative
designs up on the web.

00:02:07.560 --> 00:02:11.860
Core Services.

00:02:11.860 --> 00:02:12.150
Okay.

00:02:12.180 --> 00:02:15.040
The technologies that I'm going to
go through today are actually part

00:02:15.040 --> 00:02:18.500
of this box called Core Services.

00:02:18.500 --> 00:02:22.700
It's a little confusing because
when we initially had a lot of

00:02:22.700 --> 00:02:26.450
these technologies up and running,
they were part of the Carbon runtime,

00:02:26.530 --> 00:02:27.260
specifically.

00:02:27.260 --> 00:02:29.740
They were part of the Carbon stack,
if you will.

00:02:29.740 --> 00:02:33.860
And what's happened over
time is we've seen that

00:02:34.380 --> 00:02:37.430
We have some similar services
that are available in all stacks,

00:02:37.430 --> 00:02:41.940
and we decided to factor these lower
into the system and actually share them.

00:02:42.090 --> 00:02:45.900
And that's why you'll see some
familiar-looking technologies

00:02:45.900 --> 00:02:47.930
down in the core services layer.

00:02:48.260 --> 00:02:50.650
The other thing that you may not
have noticed when you saw this kind

00:02:50.740 --> 00:02:55.170
of slide in other presentations is

00:02:55.810 --> 00:02:57.320
Well,
the first thing you probably did notice

00:02:57.320 --> 00:02:58.690
is it's an architectural diagram.

00:02:58.700 --> 00:03:01.700
It's a layer diagram trying
to describe the system.

00:03:01.700 --> 00:03:07.930
But it's also real in that it
corresponds to the frameworks

00:03:07.930 --> 00:03:10.690
that we have on Mac OS X.

00:03:10.700 --> 00:03:13.510
Just to make sure we're
all on the same page here,

00:03:13.720 --> 00:03:18.690
framework is a term that's
being bandied about a lot.

00:03:18.700 --> 00:03:24.700
It really tends to be used in the same
way in which you'd say shared library.

00:03:24.700 --> 00:03:27.680
Other folks call this a DILIB.

00:03:27.790 --> 00:03:32.280
A framework is really a
collection of files and folders

00:03:32.500 --> 00:03:35.620
grouped around a shared library.

00:03:35.700 --> 00:03:36.700
It includes headers.

00:03:36.700 --> 00:03:39.700
It might include the resources for this.

00:03:39.700 --> 00:03:41.630
And I'll talk about
frameworks quite a bit.

00:03:41.700 --> 00:03:45.820
So if you are one of those
folks who has actually installed

00:03:45.850 --> 00:03:48.700
DP4 on your PowerBooks,
and you look in,

00:03:48.700 --> 00:03:53.060
System Library Frameworks,
that's where we keep most of

00:03:53.110 --> 00:03:54.700
the frameworks on the system.

00:03:54.930 --> 00:03:59.070
In particular, you should note there,
there's one framework

00:03:59.160 --> 00:04:00.590
called Core Services.

00:04:00.700 --> 00:04:06.890
Core Services is the lowest framework in
the system above the system framework,

00:04:06.890 --> 00:04:08.700
or the Darwin layer.

00:04:08.800 --> 00:04:12.370
And it is intended for...

00:04:12.960 --> 00:04:19.750
Tools and processes that
would use the system in a way,

00:04:19.990 --> 00:04:22.500
but probably not use
any graphic services,

00:04:22.660 --> 00:04:24.900
not use any UI.

00:04:25.020 --> 00:04:28.560
An example of things that use
core services is the res tool

00:04:28.620 --> 00:04:32.800
that we have on the system you
see running in Project Builder.

00:04:33.350 --> 00:04:36.870
Okay, so there's a lot of things
that are in core services.

00:04:37.050 --> 00:04:38.390
I'm not going to go over all of them.

00:04:38.450 --> 00:04:40.810
I'm just going to go over a subset.

00:04:41.310 --> 00:04:44.150
You should notice here that
most of the things that are in

00:04:44.150 --> 00:04:48.190
core services are things that
don't deal with UI or graphics.

00:04:48.290 --> 00:04:51.220
In cases where it seems
like that's not the case,

00:04:51.410 --> 00:04:55.200
for example, say the alias manager when
it brings up a dialogue,

00:04:55.200 --> 00:05:00.120
or some UI associated
with the NSL manager,

00:05:00.190 --> 00:05:03.560
what we've actually done there is
factored that out of core services into

00:05:03.560 --> 00:05:09.220
a framework above that in an upper layer,
typically application services

00:05:09.220 --> 00:05:11.210
or even Carbon or Cocoa.

00:05:11.890 --> 00:05:15.390
So what am I actually going
to talk about in this session?

00:05:15.540 --> 00:05:18.560
This subset of technologies.

00:05:18.560 --> 00:05:23.690
And basically this list here is kind of
roughly in chronological order as you

00:05:23.730 --> 00:05:29.380
would bring an application up from when
you double-click in the finder and that

00:05:29.820 --> 00:05:34.190
gets launched via the process manager.

00:05:34.800 --> 00:05:38.770
I will be going through these
technologies and kind of

00:05:38.770 --> 00:05:41.720
giving you an update on what's
been happening with them,

00:05:41.720 --> 00:05:47.780
but I'll also be looking at some of the
things that are unique about them on 10.

00:05:47.780 --> 00:05:51.590
In particular,
I'm going to be highlighting some

00:05:51.610 --> 00:05:54.410
of the core services design goals.

00:05:54.500 --> 00:05:57.910
Performance is kind of a constant
theme that we've seen throughout most

00:05:57.910 --> 00:06:00.060
of the core services technologies.

00:06:00.080 --> 00:06:05.860
Almost all of the slides to follow
will have some aspect of performance,

00:06:05.860 --> 00:06:07.500
some impact of performance.

00:06:07.500 --> 00:06:12.050
Scalability and extensibility
are essential for these services,

00:06:12.060 --> 00:06:15.660
mostly because they are
factored low in the system.

00:06:15.720 --> 00:06:19.830
It really is essential to have
these qualities at that level so

00:06:19.830 --> 00:06:25.500
that higher levels that build upon
them can take advantage of that.

00:06:25.500 --> 00:06:30.500
Stability is one of the
major points of Mac OS X.

00:06:30.500 --> 00:06:33.630
That's both from the point
of view of looking at the

00:06:33.750 --> 00:06:39.110
APIs that are in this layer,
but also from the point of view

00:06:39.110 --> 00:06:43.040
of making sure the system itself,
the actual underlying implementations

00:06:43.040 --> 00:06:44.330
of the technology are stable.

00:06:44.340 --> 00:06:50.100
Thread safety, this layer,
this core services layer,

00:06:50.100 --> 00:06:52.290
is the foundation for our

00:07:01.010 --> 00:07:01.870
There will be a slide later on
exactly what services are thread-safe,

00:07:01.870 --> 00:07:06.000
and I'll speak about that a
little bit when we get to those.

00:07:07.060 --> 00:07:11.710
This slide should look a bit
familiar from the Carbon overview.

00:07:11.710 --> 00:07:16.000
I just wanted to stress that there
are lots of different application

00:07:16.000 --> 00:07:20.000
environments that are taking
advantage of and using core services,

00:07:20.250 --> 00:07:26.000
including the classic environment,
which runs all-in-one address space,

00:07:26.000 --> 00:07:27.000
Carbon apps, Java apps.

00:07:27.000 --> 00:07:31.400
Java apps are a little bit different
in that they may not actually use

00:07:31.450 --> 00:07:37.000
core services and Carbon things
until they actually use a UI,

00:07:37.000 --> 00:07:39.890
so they're kind of a little
bit more dynamic that way.

00:07:40.020 --> 00:07:44.490
Cocoa apps are somewhat similar,
but there are some foundation

00:07:44.490 --> 00:07:49.100
technologies in core services
that are used across the board.

00:07:50.150 --> 00:07:53.400
Okay, so now I'm going to get into
the technologies proper,

00:07:53.490 --> 00:07:57.010
starting with code loading.

00:07:58.290 --> 00:08:00.410
I don't think it's a secret.

00:08:00.450 --> 00:08:04.760
You've pretty much heard the terms
throughout the conference so far.

00:08:04.890 --> 00:08:09.140
We do have two code loading
mechanisms on Mac OS X.

00:08:09.480 --> 00:08:12.300
From an architectural point of view,
this isn't something

00:08:12.300 --> 00:08:14.100
that we set out to do,
that we design.

00:08:14.100 --> 00:08:17.710
This isn't something that's necessarily

00:08:24.960 --> 00:08:26.160
Something we put on our list,
we need two code loading architectures.

00:08:26.160 --> 00:08:26.980
The contrary,
it would simplify things to some

00:08:26.980 --> 00:08:29.900
degree to actually just have one,
especially in the areas of tools.

00:08:30.160 --> 00:08:33.900
However, what we were faced with
when we started OS X,

00:08:33.900 --> 00:08:37.830
we're talking about
Carbon in the early days,

00:08:38.050 --> 00:08:41.900
we had a system that was
predominantly a mock-o system.

00:08:41.900 --> 00:08:46.630
The terminology there is
the dynamic loader or DYLD,

00:08:46.750 --> 00:08:51.140
and it knows about these
mock-o shared libraries,

00:08:51.150 --> 00:08:53.730
which we refer to as Dylibs.

00:08:53.900 --> 00:08:58.360
We thought about it for a little
while and actually went into a

00:08:58.360 --> 00:09:03.270
certain amount of analysis on how
much cost we would incur to change

00:09:03.270 --> 00:09:05.890
over to a whole new set of tools.

00:09:05.900 --> 00:09:08.520
At that point in time,
we had other things that

00:09:08.520 --> 00:09:09.900
we were planning on.

00:09:09.900 --> 00:09:14.070
For example, if you'll remember,
two years back,

00:09:14.070 --> 00:09:18.190
we were just then talking about
changing the microkernel from

00:09:18.190 --> 00:09:19.900
the earlier version of Mach.

00:09:19.900 --> 00:09:24.210
What we basically decided is that we
did not need a whole sweeping change

00:09:24.210 --> 00:09:26.900
like this throughout the entire system.

00:09:27.060 --> 00:09:28.900
This was key.

00:09:28.900 --> 00:09:30.900
For me,
I've been at Apple for a very long time.

00:09:30.900 --> 00:09:34.040
This was one of those decisions
that really was instrumental in

00:09:34.040 --> 00:09:37.880
letting us continue to develop and
continue to have a live system.

00:09:37.940 --> 00:09:41.690
That's why you have DP 1, 2, 3,
and now 4.

00:09:41.900 --> 00:09:44.900
Because we made decisions
like this at that time.

00:09:44.900 --> 00:09:47.840
It's not ideal from a
technical point of view,

00:09:47.980 --> 00:09:49.900
but it is the right compromise.

00:09:49.900 --> 00:09:52.900
It's giving us pretty much
the best of both worlds.

00:09:52.900 --> 00:09:56.890
We have a CFM world now that's very good,
and I'll get into that

00:09:56.950 --> 00:10:00.300
a little bit later,
and the mock-o world that

00:10:00.300 --> 00:10:02.900
we kind of started from.

00:10:03.650 --> 00:10:07.370
Okay, just again on the terminology,
because I know this can be confusing,

00:10:07.520 --> 00:10:11.620
the way you talk about the
kind of output file format of

00:10:11.620 --> 00:10:15.100
the shared libraries for CFM,
those are PEF shared libraries,

00:10:15.290 --> 00:10:21.100
and in general, we refer to the mock-oath
shared libraries as DILIBs.

00:10:21.420 --> 00:10:25.510
Okay,
so to go along with the code loading,

00:10:25.990 --> 00:10:30.220
There are differences that
you'll find if you're developing

00:10:30.220 --> 00:10:36.010
Mako and CFM applications
that are interesting to note.

00:10:38.020 --> 00:10:43.490
For CFM, as you're already familiar with,
you end up using dummy libraries

00:10:43.490 --> 00:10:45.900
to link your application.

00:10:45.900 --> 00:10:52.500
This gives you the important
information of what libraries you

00:10:52.510 --> 00:10:58.050
need to get symbols from and what
the name of those symbols are.

00:10:59.210 --> 00:11:02.990
After you've linked your
application and you actually run it,

00:11:02.990 --> 00:11:06.810
the CodeFragment Manager makes sure
and ensures that at launch time,

00:11:07.000 --> 00:11:11.020
right when you start your application up,
that all of those libraries that you

00:11:11.020 --> 00:11:14.970
need and all of those symbols that you
need are present right then and there.

00:11:15.280 --> 00:11:19.510
It's kind of flip-flop
with DYLD and Mako.

00:11:19.830 --> 00:11:23.710
Linking an application,
a Mako application,

00:11:23.710 --> 00:11:26.800
all of your libraries and all of
the libraries that they depend on

00:11:26.800 --> 00:11:30.110
have to be available at link time.

00:11:30.530 --> 00:11:34.570
And that's primarily because
Mako supports what we refer to as

00:11:34.570 --> 00:11:37.230
lazy initialization at runtime.

00:11:37.350 --> 00:11:39.620
So, let me go through a scenario here.

00:11:39.680 --> 00:11:44.160
You have an application,
you link a Mako application, you link it,

00:11:44.290 --> 00:11:48.140
everything's good,
and then you're going along

00:11:48.140 --> 00:11:51.700
and running on a system,
and all of a sudden,

00:11:51.810 --> 00:11:55.410
some symbol that you need is missing
because you inadvertently removed

00:11:55.410 --> 00:11:57.350
that framework from the system.

00:11:57.460 --> 00:11:59.010
That is something that
can actually happen.

00:11:59.020 --> 00:12:02.970
That is by design with
the code loader on a...

00:12:03.200 --> 00:12:15.000
[Transcript missing]

00:12:15.290 --> 00:12:19.200
I will get to what we've done
with CFM there that actually

00:12:19.480 --> 00:12:23.440
kind of compromises between the
two when I get to that slide.

00:12:23.510 --> 00:12:25.630
And then the other thing that
I want to make sure is clear,

00:12:25.650 --> 00:12:28.730
as of right now in DB4,
we still do not have support

00:12:28.890 --> 00:12:32.470
for two-level namespace in DYLD.

00:12:33.140 --> 00:12:36.520
We're working on it.

00:12:36.520 --> 00:12:38.920
We expect to have it for the public beta.

00:12:38.970 --> 00:12:42.700
But the basic problem there
is that we have a big,

00:12:42.810 --> 00:12:44.940
flat namespace,
and we have some tools that you

00:12:44.940 --> 00:12:47.960
may have seen here in performance
talks and things like that that

00:12:47.960 --> 00:12:50.520
actually rely on that flat namespace.

00:12:50.680 --> 00:12:54.180
So we're trying to figure out a way that
we can actually preserve that investment

00:12:54.180 --> 00:12:59.600
in tools and move forward to a bi-level
namespace that we know you need for

00:12:59.600 --> 00:13:02.980
your plugins and your shared libraries.

00:13:03.900 --> 00:13:07.580
Okay, to go with the two code
loading mechanisms we have,

00:13:07.690 --> 00:13:08.790
two runtimes.

00:13:09.530 --> 00:13:14.710
They are very similar,
kind of at a high level.

00:13:15.040 --> 00:13:18.670
The real difference is what
gets passed around when you're

00:13:18.680 --> 00:13:22.610
looking at the assembly code,
particularly in terms of

00:13:22.610 --> 00:13:24.800
what a function pointer is.

00:13:24.830 --> 00:13:31.660
A function pointer in the CFM runtime,
sometimes referred to as a TOC runtime,

00:13:31.660 --> 00:13:35.610
a function pointer is really a
pointer to a little bit of memory.

00:13:35.740 --> 00:13:40.940
It has a function address, you know,
the code address, and another word that's

00:13:40.940 --> 00:13:42.700
used for data offsets.

00:13:42.810 --> 00:13:47.380
In Mach-O, you actually have a function,
a function pointer is a

00:13:47.380 --> 00:13:49.620
pointer to the code itself.

00:13:49.900 --> 00:14:04.800
[Transcript missing]

00:14:05.600 --> 00:14:09.000
And that brings us to Mixed Mode.

00:14:09.080 --> 00:14:14.160
The differences that we have between
the two runtimes are actually dealt

00:14:14.160 --> 00:14:18.940
with in a slight change to the Mixed
Mode that you probably know and

00:14:18.940 --> 00:14:23.500
use regularly in Mac OS in general.

00:14:23.500 --> 00:14:28.560
So basically what we did with Mixed
Mode is we changed from macros in

00:14:28.560 --> 00:14:31.500
the headers to actual function calls.

00:14:31.500 --> 00:14:35.500
And this was because we had these
two different runtimes to support.

00:14:35.730 --> 00:14:42.080
And this is key to having a
single CFM application binary

00:14:42.080 --> 00:14:47.730
that can run on both OS 8,
9, and 10.

00:14:48.390 --> 00:14:54.280
The differences come in when
you do a new or a disposed UPP.

00:14:54.310 --> 00:14:57.310
And that's when we actually take into
account the differences in between

00:14:57.310 --> 00:14:59.300
how you pass code addresses around.

00:14:59.520 --> 00:15:04.100
At invoke time,
it's essentially the same.

00:15:22.160 --> 00:15:22.160
Specifically,
the way that all gets invoked in

00:15:22.160 --> 00:15:22.160
your application is you link your
CFM application with CarbonLib.

00:15:22.160 --> 00:15:22.160
The CarbonLib that lives on OS X has this
little bit of glue that gets you from

00:15:22.160 --> 00:15:22.190
kind of a CFM world to the Mach-O world.

00:15:22.870 --> 00:15:26.620
"That Carbon lib that's on 10
is different in that regard than

00:15:26.620 --> 00:15:29.830
the Carbon lib that's on 8 or 9."

00:15:31.460 --> 00:15:35.500
Okay, now onto the memory model
that we have in OS X.

00:15:35.600 --> 00:15:40.100
This slide really is about
what's not in the memory model.

00:15:40.540 --> 00:15:43.900
You notice right at the top of the list,
I'm sure you've heard this before,

00:15:43.900 --> 00:15:46.090
but there's no low mem.

00:15:46.250 --> 00:15:51.030
The region corresponding to low
mem is actually not even mapped.

00:15:51.080 --> 00:15:55.150
So if you access it, you'll take a fault,
crash,

00:15:55.220 --> 00:15:57.560
or you'll break into your debugger.

00:15:57.730 --> 00:15:58.880
That's by design.

00:15:58.970 --> 00:16:02.650
That's one of the key differences
that helps with stability.

00:16:02.700 --> 00:16:07.700
It helps with cases where you
have code you're unintentionally

00:16:07.700 --> 00:16:13.050
dereferencing nil or looking at low mem
addresses and getting something that

00:16:13.080 --> 00:16:16.580
sometimes is valid and sometimes isn't,
because sometimes it's the last thing

00:16:16.580 --> 00:16:20.700
you wrote there or sometimes it's
something that somebody else wrote there.

00:16:21.090 --> 00:16:24.920
This is one whole area of
instability on the traditional

00:16:25.250 --> 00:16:28.520
Mac OS that we just don't have on 10.

00:16:28.630 --> 00:16:31.200
And that actually brings
me to a good point.

00:16:31.350 --> 00:16:35.870
This is one of the real important
reasons why you have to take your

00:16:35.950 --> 00:16:39.040
applications and try them out on 10.

00:16:39.350 --> 00:16:41.670
You have to qualify
your applications on 10.

00:16:41.700 --> 00:16:46.420
We're not saying that something that
is perfect on 9 linking to CarbonLib

00:16:46.420 --> 00:16:48.700
is going to run unchanged on 10.

00:16:48.700 --> 00:16:51.700
As a matter of fact,
I would say the opposite.

00:16:51.700 --> 00:16:54.800
I would say that if
you run your app on 10,

00:16:54.800 --> 00:16:56.820
you're probably going
to have a better app,

00:16:56.820 --> 00:17:01.700
a more stable app, that is very likely to
run unmodified on 9.

00:17:04.180 --> 00:17:06.640
Okay, so what else do you
see in this memory map,

00:17:06.650 --> 00:17:08.240
or what else don't you see?

00:17:08.350 --> 00:17:09.860
Well, there's no system heap.

00:17:09.860 --> 00:17:15.190
There's no globally allocatable
memory whose address you

00:17:15.330 --> 00:17:20.100
can rely on being around,
who exists beyond the

00:17:20.100 --> 00:17:22.860
lifespan of the application.

00:17:23.010 --> 00:17:26.690
That again is a stability issue.

00:17:26.850 --> 00:17:29.800
I'll get to that a little bit more
when we talk about shared memory.

00:17:30.000 --> 00:17:32.910
No process manager heap.

00:17:32.910 --> 00:17:33.800
It's really unnecessary.

00:17:33.800 --> 00:17:38.800
The tempmem functions that you may
be familiar with are just mapped to

00:17:38.800 --> 00:17:42.780
the same as the non-tempmem versions.

00:17:42.800 --> 00:17:47.690
A handle, whether it's a tempmemory
handle or just a new handle,

00:17:47.810 --> 00:17:49.800
end up being the same thing.

00:17:50.300 --> 00:17:52.910
And then...

00:17:53.730 --> 00:17:56.000
Well,
you don't have any other kind of heap.

00:17:56.000 --> 00:17:58.800
You don't have to worry about zones.

00:17:58.860 --> 00:18:03.940
And this is all mostly motivated
by performance reasons and working

00:18:03.940 --> 00:18:08.410
better on a world where you actually
have a very large address space,

00:18:08.420 --> 00:18:10.140
like we do on 10.

00:18:10.200 --> 00:18:14.050
And then,
no direct device access is another

00:18:14.060 --> 00:18:17.630
thing that kind of comes with the map,
the memory map.

00:18:17.740 --> 00:18:23.100
So what do you have in
the memory map on 10?

00:18:23.280 --> 00:18:26.110
First thing of note that helps
out a lot with performance,

00:18:26.160 --> 00:18:34.810
particularly performance of the system,
is code and read-only data being shared.

00:18:37.210 --> 00:18:43.280
These sections, from a VM point of view,
code and read-only data that are shared,

00:18:43.290 --> 00:18:48.790
are the best kind of sharing that we
have on the system because basically

00:18:49.290 --> 00:18:52.900
they're backed by wherever the
original data and code came from.

00:18:52.900 --> 00:18:55.810
In the case of the system,
most of the code and data

00:18:56.100 --> 00:18:59.530
you're talking about is coming
from individual frameworks.

00:18:59.560 --> 00:19:02.720
And it's basically only
in one place on disk,

00:19:02.810 --> 00:19:08.160
and it's shared and mapped into every
address space that needs to use it.

00:19:08.850 --> 00:19:12.380
In addition,
other things that you'll find in

00:19:12.380 --> 00:19:16.410
your address space are going to be:

00:19:16.730 --> 00:19:19.350
Well, towards the beginning
of the address space,

00:19:19.360 --> 00:19:22.180
you'll find code and
data of your application.

00:19:22.180 --> 00:19:25.550
You'll find a stack for your main thread.

00:19:25.670 --> 00:19:30.060
You'll find more than one
thread running on OS X.

00:19:30.060 --> 00:19:36.430
It's likely you'll find on the order of
a couple in DP4 running your application.

00:19:36.880 --> 00:19:43.730
Each one of these threads has their
own stack surrounded by guard pages.

00:19:43.730 --> 00:19:48.280
That deals with issues like flowing
under or over the stack size.

00:19:48.400 --> 00:19:49.660
Stacks are very large.

00:19:49.690 --> 00:19:52.760
I believe right now they're
set at half a megabyte.

00:19:52.830 --> 00:19:57.450
That's something we have to
look at and tune correctly.

00:19:57.550 --> 00:20:02.010
In general, we're talking about a
very sparse address space.

00:20:02.010 --> 00:20:05.860
Lots of space,
lots of holes in the address space.

00:20:05.860 --> 00:20:07.590
It's discontinuous.

00:20:07.700 --> 00:20:10.970
The reason I'm going into that
is that you shouldn't assume

00:20:11.080 --> 00:20:13.400
anything about that address space.

00:20:13.490 --> 00:20:16.960
You will find, if you're sitting there
probing in the debugger,

00:20:16.960 --> 00:20:19.760
you will find a certain
amount of determinism.

00:20:19.760 --> 00:20:22.860
You'll see certain things
loaded at the same address.

00:20:22.980 --> 00:20:27.450
But that's not necessarily the case.

00:20:27.540 --> 00:20:31.430
Because of the dynamicity of
the dynamic loader and CFM,

00:20:31.520 --> 00:20:34.590
you will find things on
the first run of the app.

00:20:34.660 --> 00:20:39.120
You'll find certain things loaded,
code or data, at a certain address and

00:20:39.120 --> 00:20:40.760
then do this very same thing.

00:20:40.840 --> 00:20:44.010
And because between the two
times something else got loaded,

00:20:44.080 --> 00:20:45.700
you won't be loaded in the same address.

00:20:45.850 --> 00:20:49.310
So don't make any assumptions
about where you'll be loaded.

00:20:51.090 --> 00:20:54.530
Then the other thing
I'd like to point out,

00:20:54.530 --> 00:20:57.760
more on a practical note,
if you're looking at DP4,

00:20:57.760 --> 00:21:01.000
there's two command line tools that
really help you get a good grasp on this.

00:21:01.000 --> 00:21:04.000
The first one is just size.

00:21:04.000 --> 00:21:07.770
And basically size,
when given a path to a shared

00:21:07.940 --> 00:21:12.500
library or an application,
will tell you the sections that

00:21:12.500 --> 00:21:15.000
your shared library application has.

00:21:15.000 --> 00:21:18.340
Things like how big your code is,
how big your data sections are,

00:21:18.400 --> 00:21:22.000
what portion of those are read-only,
what portion are read-write.

00:21:22.000 --> 00:21:27.200
One of the things that we hit a lot
as we brought code over from OS 8

00:21:27.200 --> 00:21:32.140
is we had lots of data sections
that were marked as writable,

00:21:32.140 --> 00:21:35.000
which meant that they
really didn't get shared.

00:21:35.000 --> 00:21:39.880
And that was simply a matter of,
in the code, saying that these were

00:21:39.930 --> 00:21:42.000
constant data sections.

00:21:42.000 --> 00:21:44.810
At that point, they became read-only
and were fully shared.

00:21:45.000 --> 00:21:50.050
That optimization is something
I would look at with your own shared

00:21:50.050 --> 00:21:53.200
libraries and your own applications.

00:21:53.470 --> 00:21:57.860
The other tool is VM Map,
which takes as an argument

00:21:58.030 --> 00:22:01.700
either the name or the PID of
the process that is running.

00:22:01.770 --> 00:22:06.020
And this gives you a snapshot,
if you will, of a running process.

00:22:06.140 --> 00:22:11.310
And there should be a one-to-one
correspondence between a size and VM Map.

00:22:11.400 --> 00:22:12.380
I shouldn't say a one-to-one.

00:22:12.580 --> 00:22:15.190
Everything that you see in size
you should see in the VM map.

00:22:15.320 --> 00:22:18.150
You will also in VM maps see
the size of other things that

00:22:18.150 --> 00:22:21.400
are in your address space,
other frameworks that you're using.

00:22:21.400 --> 00:22:23.920
You should be able to see
read-only and read-write

00:22:23.920 --> 00:22:25.800
sections in there fairly clearly.

00:22:25.820 --> 00:22:29.410
In talking to the tools folks,
there's an internal tool that works

00:22:29.410 --> 00:22:33.820
where you didn't get ready for DP4,
but it's basically a UI that lets

00:22:33.820 --> 00:22:36.800
you see this so you don't have to
actually use command line tools.

00:22:36.800 --> 00:22:40.270
I thought I'd bring that up
in case you're looking at

00:22:40.460 --> 00:22:42.370
these kinds of things in DP4.

00:22:43.420 --> 00:22:47.440
Okay, so now we know about memory maps,
but what does this actually mean to you

00:22:47.530 --> 00:22:50.510
when you're doing memory allocation?

00:22:50.540 --> 00:22:53.700
Well, the first thing is

00:22:54.510 --> 00:22:58.790
Memory Manager in general is fully
supported on both pointer-based,

00:22:58.790 --> 00:23:01.040
handle-based objects.

00:23:01.150 --> 00:23:05.140
And I think what you have to keep
in mind here is that this is one

00:23:05.140 --> 00:23:07.970
of these areas where we have some
APIs in the Memory Manager that

00:23:08.030 --> 00:23:12.490
make sense on 8 and 9,
that don't make sense on 10.

00:23:12.580 --> 00:23:16.600
They're still part of Carbon,
so you can write a single binary.

00:23:16.740 --> 00:23:22.090
The best example of this
is the free mem call.

00:23:22.170 --> 00:23:25.300
There isn't really a good
answer for that on 10.

00:23:25.520 --> 00:23:27.640
We could tell you there's four gigabytes.

00:23:27.640 --> 00:23:30.290
We could tell you there's half that.

00:23:30.480 --> 00:23:33.470
It's not really something
that makes sense when you

00:23:33.470 --> 00:23:35.700
have a sparse address space.

00:23:35.780 --> 00:23:39.300
And that's why we came up with the
Gestalt Memory Map Sparse Selector.

00:23:39.370 --> 00:23:44.290
That's what you should check
when you're wondering whether

00:23:44.290 --> 00:23:46.810
you need to ask these questions,
whether you're wondering

00:23:46.810 --> 00:23:49.700
whether you really have to
police your memory allocation.

00:23:49.810 --> 00:23:54.580
Some other differences that kind
of fall into this boat is purging.

00:23:54.600 --> 00:24:10.200
[Transcript missing]

00:24:10.400 --> 00:24:12.730
So this is actually a counterpoint
to what I said earlier about

00:24:12.730 --> 00:24:15.870
where you should qualify your app,
because this is an area that you could

00:24:15.930 --> 00:24:19.320
have something that runs fine on 10.

00:24:20.290 --> 00:24:24.700
And you write some new code and you
don't lock your handle and you never

00:24:24.700 --> 00:24:28.880
set handle size so that you can
dereference that without a problem

00:24:28.880 --> 00:24:31.390
and you'll never find a bug on 10.

00:24:31.390 --> 00:24:34.900
But take that same code and
move it back to 8 or 9 and you

00:24:35.040 --> 00:24:36.920
likely will find a problem.

00:24:36.920 --> 00:24:42.940
And that's because 8 or 9 has a limited,
you know, fixed-size application heap.

00:24:44.100 --> 00:24:47.860
The other thing I want
to address on is kind of,

00:24:47.860 --> 00:24:50.540
we spent quite a bit of time trying
to understand the performance

00:24:50.600 --> 00:24:53.210
of memory allocation on 10.

00:24:53.750 --> 00:24:58.440
And one of the things we found
is that the assumptions are

00:24:58.440 --> 00:25:01.070
almost reversed in a sense.

00:25:01.510 --> 00:25:04.190
The memory manager on 8 and 9

00:25:04.510 --> 00:25:11.000
made a very explicit design decision
to favor handles over pointers.

00:25:11.320 --> 00:25:16.580
That was the right decision at the time
because we did have a fixed size heap.

00:25:16.620 --> 00:25:21.240
Basically, the reverse is true on 10.

00:25:21.280 --> 00:25:27.560
In a VM-based system like 10
with sparse address spaces,

00:25:28.140 --> 00:25:33.790
The most basic representation
for memory is a pointer.

00:25:34.940 --> 00:25:37.720
One of the things that kind
of sounds counter-intuitive,

00:25:37.720 --> 00:25:43.270
but I really encourage you to do,
is to try to get your code set up so that

00:25:43.270 --> 00:25:48.880
you basically refrain from doing any kind
of sub-allocation that you may be doing.

00:25:48.880 --> 00:25:52.650
It's very typical in
your OS 8 and 9 code.

00:25:53.100 --> 00:25:59.080
The reason being here is that a
lot of the tools on OS X depend on

00:25:59.080 --> 00:26:05.710
you using malloc directly or new
pointer and new handle directly.

00:26:06.230 --> 00:26:09.800
The tools have been revved to understand

00:26:10.000 --> 00:26:15.440
those two packages for memory allocation
and the tools I'm talking about are

00:26:15.440 --> 00:26:19.630
going to help you find things like leaks,
they're going to help you find

00:26:19.630 --> 00:26:23.480
cases where you've overwritten
a block of memory underwritten.

00:26:23.480 --> 00:26:27.400
And this has all kind of gone over in
one of the performance tool sessions.

00:26:27.400 --> 00:26:32.600
But the point here is that at least in
a debug version of your app you want

00:26:32.700 --> 00:26:37.230
to have your memory allocation factored
so that it calls one of these routines

00:26:37.230 --> 00:26:40.220
directly so you can use the tools.

00:26:40.220 --> 00:26:43.880
The other thing I would
encourage you to do is

00:26:44.590 --> 00:26:49.690
Do some measurements of your
application and see what they're

00:26:49.690 --> 00:26:52.620
like just with the system allocator.

00:26:52.620 --> 00:26:55.850
Either malloc directly,
and you probably should look at

00:26:55.870 --> 00:27:00.300
malloc if you don't rely on any of the

00:27:01.010 --> 00:27:04.890
uh features of the memory manager with
regards to pointers and handles and

00:27:04.900 --> 00:27:09.000
recovering handles and things like
that if you're going to be interacting

00:27:09.000 --> 00:27:12.690
with handle based apis in the toolbox
of course you're required to use

00:27:12.690 --> 00:27:16.770
handles there but for your own internal
allocation needs start off try malloc

00:27:16.860 --> 00:27:21.540
there's a there's a big advantage
to actually all of us using the same

00:27:21.540 --> 00:27:26.580
allocator and it actually is not
something you typically see unless you're

00:27:26.580 --> 00:27:31.590
looking at the overall system performance
the problem we initially had when we

00:27:31.590 --> 00:27:36.640
brought off brought over large subsystems
early on in the Carbon effort on

00:27:36.730 --> 00:27:42.120
os10 was we had a lot of sub allocation
going on every big subsystem had their

00:27:42.120 --> 00:27:46.810
own memory allocation and the problem
with that is that we have essentially

00:27:47.300 --> 00:27:52.510
different high water marks in every
subsystem that has allocations and that

00:27:52.590 --> 00:27:58.440
meant that we didn't really do a good job
as a whole of get getting rid of memory

00:27:58.600 --> 00:28:02.780
and freeing it up in a timely sense.

00:28:02.970 --> 00:28:04.900
Take a look at that.

00:28:04.900 --> 00:28:08.780
If you have issues specifically
with malloc and its performance,

00:28:08.900 --> 00:28:13.270
both size and speed,
let us know because we want

00:28:13.330 --> 00:28:15.400
malloc to be the system allocator.

00:28:15.400 --> 00:28:16.920
We want it to be as fast as possible.

00:28:16.920 --> 00:28:20.880
We want it to be as
efficient in terms of speed.

00:28:21.380 --> 00:28:23.320
I'm sorry, in terms of size.

00:28:23.550 --> 00:28:25.240
And that actually brings
me to another point,

00:28:25.320 --> 00:28:28.760
which is the problems we've
been dealing with in terms of

00:28:28.760 --> 00:28:33.630
performance and allocation have
largely been size problems,

00:28:33.670 --> 00:28:36.450
not speed problems.

00:28:36.550 --> 00:28:42.930
And I think that's going to be
the case with your applications

00:28:42.930 --> 00:28:42.930
and your shared libraries as well.

00:28:44.590 --> 00:28:47.830
It's not just a matter of having a
big sparse address space and being

00:28:47.830 --> 00:28:52.110
able to allocate a lot of memory,
but

00:28:52.760 --> 00:28:55.470
It's a matter of actually being
able to account for your space and

00:28:55.480 --> 00:28:59.310
understand the relationship between
things that get allocated underneath

00:28:59.970 --> 00:29:04.760
a system framework compared to what
you really intended to do above it.

00:29:04.820 --> 00:29:08.760
So, again,
take a look at that if you have

00:29:09.070 --> 00:29:12.980
really good reasons or really good

00:29:13.400 --> 00:29:22.190
Performance observations,
please share those with us because

00:29:22.190 --> 00:29:22.190
we really want to understand why you
would think of doing something other

00:29:22.190 --> 00:29:22.190
than using malloc on this system.

00:29:23.360 --> 00:29:26.960
Lastly, there's an issue that
came up late in DP4.

00:29:26.960 --> 00:29:28.800
We didn't get a fix in for it.

00:29:28.800 --> 00:29:33.020
Basically,
one of the changes we were doing

00:29:33.020 --> 00:29:42.110
to the memory manager to enable
additional debugging support ended us

00:29:42.130 --> 00:29:46.110
up with a memory manager that doesn't
allocate on a 16-byte boundary.

00:29:46.330 --> 00:29:51.180
In particular,
this is important for AlteVec

00:29:51.190 --> 00:29:57.300
or Velocity Engine data,
which ignores some of the lower bits.

00:29:57.300 --> 00:30:04.640
So if you run into that situation,
there's a release note on DP4 with

00:30:04.670 --> 00:30:07.300
a workaround on how to do that,
essentially copying the memory out.

00:30:07.300 --> 00:30:11.420
We'll fix this for the user beta.

00:30:12.330 --> 00:30:14.500
Okay, shared memory.

00:30:14.820 --> 00:30:19.110
This one has quite a story to it too.

00:30:20.030 --> 00:30:23.260
So, you know,
early on in Carbon we basically said,

00:30:23.260 --> 00:30:26.690
new pointer sys and the system heap,
they have to go,

00:30:26.700 --> 00:30:30.900
there's stability problems around them,
they're being used way too much,

00:30:30.910 --> 00:30:33.690
they're used between
extensions and applications,

00:30:33.690 --> 00:30:37.900
and those things don't essentially
have the same counterparts on OS X.

00:30:37.900 --> 00:30:41.170
We really looked at this closely,
and we listened to some of

00:30:41.170 --> 00:30:44.440
the developers that wanted,
that really knew what they wanted

00:30:44.440 --> 00:30:47.900
out of a shared memory system,
they wanted particular features.

00:30:47.900 --> 00:30:52.180
And after a lot of consideration,
what we ended up with is saying,

00:30:52.180 --> 00:30:55.420
you know,
the features that most developers want

00:30:55.420 --> 00:30:59.900
in this area are completely covered
by the POSIX shared memory APIs,

00:30:59.900 --> 00:31:03.960
and it really makes no sense to try
to come up with a system that works on

00:31:03.960 --> 00:31:06.840
both 9 and 10 regarding shared memory.

00:31:06.900 --> 00:31:10.900
The two systems in this
area are quite different.

00:31:11.030 --> 00:31:13.310
The single address space versus
multi-address space nature of

00:31:13.360 --> 00:31:15.900
the systems makes it really hard
to kind of abstract that away.

00:31:15.900 --> 00:31:15.900
This is something that
we're trying to do.

00:31:16.900 --> 00:31:16.900
Yeah.

00:31:17.900 --> 00:31:20.660
that you have to be aware of if
you're dealing with shared memory.

00:31:22.730 --> 00:31:26.550
And then, of course,
to use shared memory safely,

00:31:26.760 --> 00:31:29.160
you have to synchronize,
and that's what the

00:31:29.160 --> 00:31:30.430
POSIX semaphores are for.

00:31:30.600 --> 00:31:34.450
Those are fully documented
on the DP4 release.

00:31:34.580 --> 00:31:40.580
The shared memory
documentation didn't get there,

00:31:40.580 --> 00:31:40.580
but I've provided a URL here
at the bottom of the screen.

00:31:41.460 --> 00:31:46.350
One additional note:
If you're a CFM application,

00:31:46.350 --> 00:31:50.290
since currently there's no
way to get to services that

00:31:50.300 --> 00:31:54.620
are in the system framework,
like the POSIX shared

00:31:54.620 --> 00:31:59.260
memory and Semaphore APIs,
you're going to need to get to

00:31:59.260 --> 00:32:03.400
them through CFBundle or a plug-in.

00:32:03.510 --> 00:32:06.400
Basically,
there's two different ways of doing this.

00:32:06.400 --> 00:32:10.560
One, you could use CFBundle to ask
for the address of a routine

00:32:10.560 --> 00:32:15.190
in the system framework,
so you could inquire and then call that.

00:32:15.400 --> 00:32:19.920
The other is you could factor
your application to use bundles

00:32:19.990 --> 00:32:24.620
that are specific to a platform,
and we recommend doing this,

00:32:24.840 --> 00:32:31.310
so that basically you have a Mako
plug-in on 10 that links with the system,

00:32:31.390 --> 00:32:33.390
uses these APIs,
and then uses them to do the work.

00:32:33.400 --> 00:32:37.390
you would just invoke the plugin.

00:32:38.840 --> 00:32:42.200
Okay, that gets us over shared memory
and into the file manager.

00:32:42.310 --> 00:32:46.000
The file manager is probably one
of the largest chunks of work that

00:32:46.000 --> 00:32:48.480
we had to do over the last year.

00:32:48.700 --> 00:32:54.590
The biggest disconnect,
or the biggest missing feature from the

00:32:54.590 --> 00:33:01.690
file manager on 10 was support for these
volume formats that I have up here:

00:33:01.710 --> 00:33:07.700
NFS, UFS,
and other POSIX-style volume formats.

00:33:07.700 --> 00:33:09.300
Um...

00:33:13.380 --> 00:33:17.050
Now,
why are these file formats important?

00:33:17.220 --> 00:33:19.690
Basically,
this gives us a certain level of

00:33:19.700 --> 00:33:24.880
interoperability that we've never
really had with a Mac before.

00:33:26.640 --> 00:33:29.430
It's not just NFS and UFS,
it's anything that

00:33:29.430 --> 00:33:31.180
complies to a POSIX API.

00:33:31.300 --> 00:33:33.600
It's anything that,
if you went to the file system talk,

00:33:33.600 --> 00:33:36.060
it plugs into the VFS layer.

00:33:36.140 --> 00:33:40.960
And this is a bunch,
there's a bunch of opportunities here in

00:33:41.010 --> 00:33:46.500
up-and-coming file systems that we really
wanted to be able to take advantage of.

00:33:46.990 --> 00:33:52.990
The other point is that this wasn't
really an afterthought for us.

00:33:53.150 --> 00:33:58.310
We were coming from an environment
that was heavily using UFS and NFS.

00:33:58.380 --> 00:34:01.140
We were coming from the
Mac OS X server environment.

00:34:01.260 --> 00:34:08.030
And as a matter of fact, internally,
we were using NFS and UFS very heavily.

00:34:08.160 --> 00:34:11.610
To this date,
I keep my source code in my home

00:34:11.610 --> 00:34:14.670
directory that's on an NFS server.

00:34:21.900 --> 00:34:22.160
That's the way that I personally develop.

00:34:22.160 --> 00:34:22.430
Other folks choose whatever they want to.

00:34:22.430 --> 00:34:23.140
I do that mostly because I tend
to go from machine to machine,

00:34:23.280 --> 00:34:25.400
and I like to have the
same kind of environment.

00:34:25.520 --> 00:34:28.900
Keep my sources there locally,
they're backed up centrally.

00:34:28.900 --> 00:34:30.900
That works beautifully on DP4.

00:34:31.980 --> 00:34:35.620
But to do that,
we had to really look at how the file

00:34:35.630 --> 00:34:38.750
manager talked to these kind of volumes.

00:34:38.980 --> 00:34:41.870
For one,
the classic file manager APIs really

00:34:42.210 --> 00:34:44.860
kind of assumed a volume format.

00:34:45.540 --> 00:34:49.130
They were very HFS-centric.

00:34:49.700 --> 00:34:59.400
[Transcript missing]

00:35:06.500 --> 00:35:06.700
Two particular features of HFS.

00:35:06.700 --> 00:35:06.950
One was forks, resource forks, the like.

00:35:06.950 --> 00:35:10.690
Just the general concept that you
have more data associated with a

00:35:10.690 --> 00:35:14.790
file than just that one data fork.

00:35:15.300 --> 00:35:19.790
And then the other was the
idea of persistent file IDs,

00:35:19.810 --> 00:35:25.370
basically the backbone
for aliases on HFS.

00:35:25.490 --> 00:35:30.030
You have something similar
in UFS called an inode,

00:35:30.030 --> 00:35:32.900
but it doesn't work the same way.

00:35:33.160 --> 00:35:39.540
It isn't quite the same experience in
terms of something that's persistent.

00:35:41.080 --> 00:35:43.340
We knew we had to support
these volume formats,

00:35:43.340 --> 00:35:49.000
and what we settled on was basically
two different solutions in a sense.

00:35:49.110 --> 00:35:54.520
One, we knew that the current APIs were
not very good for dealing with this,

00:35:54.520 --> 00:35:58.260
and we actually had a luxury that
we rarely seen in the industry.

00:35:58.260 --> 00:36:03.450
We actually had some time to make
sure that the set of APIs that

00:36:03.450 --> 00:36:08.580
we call now HFS+ APIs worked
well with this environment.

00:36:09.630 --> 00:36:31.350
The other thing that
we did is standardize.

00:36:31.350 --> 00:36:31.350
We knew we had to store the extra
data that we're talking about,

00:36:31.350 --> 00:36:31.350
the fork information and the file ID,
essentially the catalog

00:36:31.350 --> 00:36:31.350
information from HFS.

00:36:31.350 --> 00:36:31.350
We had to store that somewhere,
persistently.

00:36:31.350 --> 00:36:31.350
So for that,
we chose the Apple double file format.

00:36:34.320 --> 00:36:38.130
By dealing with these volume
formats by using Apple Double,

00:36:38.220 --> 00:36:41.230
basically what we get
is the file manager API,

00:36:41.230 --> 00:36:47.400
both the classic and the new HFS+ APIs,
deal with volumes transparently.

00:36:47.450 --> 00:36:50.590
Even if they're underlying,
they may not have a catalog node or

00:36:50.590 --> 00:36:54.400
they may not have a resource fork,
we store this in Apple Double format

00:36:54.400 --> 00:36:59.660
so that the HFS and HFS+ APIs work
transparently across all of

00:36:59.660 --> 00:37:02.350
these different volume formats.

00:37:04.470 --> 00:37:09.460
Of course, we have support for the volume
formats that we're already

00:37:09.480 --> 00:37:11.470
used to in Mac OS 8 and 9.

00:37:11.610 --> 00:37:14.500
And almost all of these are on in DP4.

00:37:14.500 --> 00:37:18.350
The only exception is UDF,
and that's coming.

00:37:20.290 --> 00:37:24.990
In addition to the
different volume formats,

00:37:24.990 --> 00:37:31.000
we had to deal with something,
two essentially foreign concepts.

00:37:31.120 --> 00:37:35.110
One was the idea of mount points,
the idea that a volume can be mounted

00:37:35.620 --> 00:37:39.200
or contained within another volume.

00:37:39.280 --> 00:37:43.040
And the other is
symbolic links from Unix.

00:37:43.950 --> 00:37:51.940
This work actually made its way into
DP3 and we've refined it since then.

00:37:51.970 --> 00:37:56.840
But basically we came up with
a mechanism whereby both mount

00:37:56.840 --> 00:38:00.170
points and symbolic links are

00:38:01.840 --> 00:38:05.980
Show up to you through the
File Manager API as aliases,

00:38:05.980 --> 00:38:08.790
that is files that have alias bits set.

00:38:08.880 --> 00:38:10.760
They're not really alias files.

00:38:11.370 --> 00:38:13.800
This information is synthesized.

00:38:14.010 --> 00:38:17.350
This is one of the rare cases
in the File Manager where we

00:38:17.560 --> 00:38:19.790
actually synthesize something.

00:38:19.830 --> 00:38:22.800
Typically, we're giving you exactly
what's on the disk.

00:38:22.800 --> 00:38:25.760
The other exception to that would be,
of course, the Apple double format.

00:38:25.880 --> 00:38:29.640
We're not actually giving you
that information directly.

00:38:29.740 --> 00:38:31.800
We're providing the extra information.

00:38:31.810 --> 00:38:37.440
The way that you need to support
mount points and symbolic links on

00:38:37.440 --> 00:38:40.500
OS X is just to respect the alias bit.

00:38:40.650 --> 00:38:43.510
If you intend to resolve them,
to resolve them via

00:38:43.510 --> 00:38:44.800
the resolve alias file.

00:38:44.800 --> 00:38:48.590
You need to use that call
as opposed to other variants

00:38:49.270 --> 00:38:52.100
because it isn't an alias file,
really.

00:38:53.410 --> 00:38:59.310
Now, for those that are interested,
the reason we had to go this route is...

00:38:59.420 --> 00:39:09.950
A very pervasive assumption that most
people have in dealing with file systems,

00:39:09.950 --> 00:39:09.950
particularly in iteration,
is you're going through a

00:39:09.950 --> 00:39:09.950
directory full of files,

00:39:10.860 --> 00:39:14.240
You're not assuming that the VREF num,
which is sprinkled

00:39:14.240 --> 00:39:17.450
throughout most of our APIs,
is going to change.

00:39:17.930 --> 00:39:21.440
That is the case with AmountPoint,
and it's potentially the

00:39:21.440 --> 00:39:22.860
case with the SimLink.

00:39:22.900 --> 00:39:31.400
So, that's what got us to
a solution like this.

00:39:35.270 --> 00:39:39.270
Okay, so the file manager is an area
we put a lot of effort into,

00:39:39.590 --> 00:39:44.790
and I've told you about kind of the
differences in the file system on 10.

00:39:45.370 --> 00:39:49.640
The one thing that I really want you
to come away from this session with

00:39:49.950 --> 00:39:57.390
is there's really a lot of win in
OS X to go and use the HFS+ APIs.

00:39:57.490 --> 00:40:01.900
The HFS+ APIs are very well
designed for this system.

00:40:02.550 --> 00:40:07.700
There's one notion in particular in
the HFS+ APIs that really pays off,

00:40:07.820 --> 00:40:11.070
and that's the ability to be very
specific about the information

00:40:11.070 --> 00:40:12.860
that you want from the file.

00:40:14.060 --> 00:40:20.870
So, using the HFS+ APIs and asking for
as little information or exactly the

00:40:20.870 --> 00:40:25.080
information that you need is the best
solution on these volume formats that

00:40:25.080 --> 00:40:30.630
don't support some of the things that
you may have become used to in HFS.

00:40:31.750 --> 00:40:36.260
Uh... and then in particular you
really have to try this out for

00:40:36.870 --> 00:40:39.290
yourself on these volume formats.

00:40:39.300 --> 00:40:43.410
You can do that in DP4,
you can format a volume uh...

00:40:44.960 --> 00:40:48.150
The first thing is to use UFS.

00:40:48.150 --> 00:40:54.160
You can also, if you have NFS servers
in the general area,

00:40:54.160 --> 00:40:56.250
you can mount them.

00:40:56.560 --> 00:41:04.180
NFS or over a CD, the experience will be,
you'll be able to see it a lot easier

00:41:04.190 --> 00:41:05.130
just because of the general performance
characteristics of those volume formats.

00:41:06.040 --> 00:41:08.730
Okay,
so then the other thing I wanted to bring

00:41:08.730 --> 00:41:13.020
up because people keep on hitting this
over and over as they bring their apps,

00:41:13.020 --> 00:41:16.150
as they carbonize and
bring their apps to 10,

00:41:16.150 --> 00:41:19.700
are some assumptions that are out there.

00:41:19.800 --> 00:41:23.660
First is that VREF nums start at -1.

00:41:24.140 --> 00:41:32.540
They typically don't start at
-1 on OS X in the file manager.

00:41:32.790 --> 00:41:37.310
Really need to treat those
VREF nums as cookies.

00:41:37.950 --> 00:41:40.660
We've run into a lot
of code that basically,

00:41:40.680 --> 00:41:43.740
you know, it's quickly written code that
basically works on 8 and 9.

00:41:43.740 --> 00:41:47.300
It's something like, you know,
looping between -1 and -10,

00:41:47.300 --> 00:41:50.630
assuming that they're going
to find all volumes that way.

00:42:04.720 --> 00:42:04.720
Use the volume calls to
iterate through volumes.

00:42:04.720 --> 00:42:04.720
That'll prevent that
whole set of problems.

00:42:04.720 --> 00:42:04.720
The other is the whole
notion of file IDs.

00:42:04.720 --> 00:42:04.720
File IDs...

00:42:13.000 --> 00:42:13.280
Like I said earlier,
are not available on some

00:42:13.280 --> 00:42:13.460
of these volume formats.

00:42:13.460 --> 00:42:13.810
On some of these volume formats,
what we have to revert to is

00:42:13.810 --> 00:42:17.460
a path embedded in the alias.

00:42:17.550 --> 00:42:19.960
This is essentially like a minimal alias.

00:42:19.990 --> 00:42:23.360
You can treat them exactly the same way.

00:42:23.460 --> 00:42:26.480
And on these volume formats,
with the current implementation,

00:42:26.480 --> 00:42:29.440
the way it works on DP4,
they'll have some limitations.

00:42:29.510 --> 00:42:32.500
They won't behave like a normal alias.

00:42:32.560 --> 00:42:36.690
You can break aliases more
easily on these volume formats.

00:42:36.770 --> 00:42:41.190
We'll be looking into things
that we can do to improve that.

00:42:41.280 --> 00:42:43.900
But in particular,
changing an element of the path,

00:42:43.900 --> 00:42:47.380
you know, renaming a directory somewhere
in the middle of the path is

00:42:47.380 --> 00:42:48.940
going to break that alias.

00:42:54.570 --> 00:42:59.450
Okay, so I spoke about this one concept
earlier that really helps out.

00:42:59.450 --> 00:43:03.340
This is a tie-in to performance
and just working well on OS X.

00:43:03.460 --> 00:43:07.050
And that's the notion that
you can be very specific about

00:43:07.050 --> 00:43:08.740
the information that you want.

00:43:08.840 --> 00:43:13.640
When asking for information for
a file using FSGit Catalog Info,

00:43:13.640 --> 00:43:21.180
the HFS+ API for that,
if you just need the name of that file,

00:43:21.510 --> 00:43:24.990
Then use the bitmap as an argument
and just say you want the name.

00:43:25.150 --> 00:43:29.900
That's a very cheap way of
determining if the file is there.

00:43:30.040 --> 00:43:34.190
The same kind of approach works
in some of these other cases.

00:43:34.200 --> 00:43:38.500
When you're going through a directory,
what is it that you're really after?

00:43:38.500 --> 00:43:42.250
Are you trying to just enumerate by name,
or are you trying to find

00:43:42.250 --> 00:43:44.990
all files with an extension?

00:43:45.030 --> 00:43:49.000
Are you trying to find only the
directories inside another directory?

00:43:49.010 --> 00:43:53.200
These are all things that
can be set in the bitmap,

00:43:53.200 --> 00:43:56.000
and doing so will really help.

00:43:56.000 --> 00:43:59.580
In particular,
on a network volume like NFS,

00:43:59.770 --> 00:44:03.890
where each one of those file
system operations ends up being

00:44:04.440 --> 00:44:08.920
some kind of packet over the wire,
there's a certain amount

00:44:08.920 --> 00:44:13.190
of non-determinism to that
on your typical network.

00:44:14.790 --> 00:44:17.450
And volume iterations,
same thing goes for that.

00:44:17.670 --> 00:44:21.930
Set the bitmap and ask for what you want.

00:44:23.040 --> 00:44:26.380
Let's see,
this is actually an area where the advice

00:44:26.380 --> 00:44:31.140
we gave you earlier on ended up biting
us a little bit in terms of performance.

00:44:31.260 --> 00:44:37.480
So long ago we basically said
that the VCBQ is gone from Carbon.

00:44:37.670 --> 00:44:41.510
You can't just get this low mem and
increment it and start walking through

00:44:41.510 --> 00:44:43.640
volume control blocks that way.

00:44:43.730 --> 00:44:50.360
The replacement technology for that
was use the volume iteration APIs.

00:44:50.480 --> 00:44:52.140
Works fine.

00:44:52.560 --> 00:44:54.740
When the volumes that
you're iterating over are,

00:44:54.830 --> 00:44:58.640
for example, NFS volumes,
it doesn't work so well.

00:44:58.680 --> 00:45:00.940
Again,
from a point of view of performance.

00:45:01.010 --> 00:45:04.740
When you go through using
volume iteration calls,

00:45:04.790 --> 00:45:07.120
you're asking for a lot of
data that often you don't want.

00:45:07.130 --> 00:45:11.760
If you just wanted the name or you
wanted to get to the next V refnum,

00:45:11.990 --> 00:45:15.870
You probably don't want
the size of the volume,

00:45:15.870 --> 00:45:17.540
which can be very expensive to compute.

00:45:17.540 --> 00:45:20.130
The size of blocks, things like that.

00:45:20.190 --> 00:45:23.960
Some of the other information that
comes back in some of these calls has

00:45:23.960 --> 00:45:29.550
always been cheap on HFS and HFS+.
Not so on some of these volume formats.

00:45:29.590 --> 00:45:33.060
Again,
this is why you want to use fsgetvolinfo.

00:45:33.140 --> 00:45:37.160
In addition,
there's a just getvolparams call,

00:45:37.220 --> 00:45:40.760
which gives you a subset
of the same information.

00:45:42.890 --> 00:45:47.780
Okay, I'm going to go through a
little bit of code here.

00:45:47.860 --> 00:45:49.800
This should look familiar to most people.

00:45:49.940 --> 00:45:54.940
This is your typical, you know,
go through a directory looking

00:45:54.940 --> 00:45:57.390
for files in the directory.

00:45:58.350 --> 00:46:02.300
The dot dot dot is just pseudo-code.

00:46:02.300 --> 00:46:03.250
That's a little bit of setup.

00:46:03.370 --> 00:46:07.100
Additional setup is not something
you would compile and work correctly.

00:46:07.250 --> 00:46:11.970
You'll notice the main call
in a directory iteration,

00:46:11.970 --> 00:46:19.860
this is the old file manager APIs,
is pbgetcat info sync, sync in this case.

00:46:20.540 --> 00:46:23.140
You notice that basically as
you go through a directory,

00:46:23.140 --> 00:46:30.870
you have to make this call for
every item in the directory.

00:46:32.040 --> 00:46:34.280
Here's the replacement loop.

00:46:34.310 --> 00:46:38.680
Notice first,
same kind of structure code, right?

00:46:38.720 --> 00:46:44.340
A do-while loop, same kind of call,
you're asking for catalog info.

00:46:44.340 --> 00:46:48.080
One big difference is it's a bulk call.

00:46:48.080 --> 00:46:52.900
So you can ask for more than
one file information at a time.

00:46:53.180 --> 00:46:55.420
The number of files is up to you.

00:46:55.430 --> 00:47:00.180
It's actually a parameter for
the FSGit catalog info bulk.

00:47:03.440 --> 00:47:06.360
So this is something that's tunable.

00:47:06.360 --> 00:47:13.490
This is something that in DP4 works
down to a bulk call in the file manager,

00:47:13.500 --> 00:47:17.730
but what we're going to do is actually
move that even further post-DP4,

00:47:17.770 --> 00:47:21.570
make a better performance enhancement,
and move that call all the

00:47:21.570 --> 00:47:23.400
way down to the kernel.

00:47:23.650 --> 00:47:26.110
That'll give us the best efficiency.

00:47:27.050 --> 00:47:35.760
So now I want to actually-- can
we get demo one up on stage?

00:47:37.260 --> 00:47:41.200
I want to show you a quick demo
application that we brought together.

00:47:41.240 --> 00:47:45.320
Just as an aside here,

00:47:45.710 --> 00:47:50.600
This was, you know,
in the tradition of WWDC, done in,

00:47:50.600 --> 00:47:54.420
I guess it was late last week now,
in a few hours.

00:47:54.670 --> 00:48:00.230
But the surprise that we had was
actually a lot of folks on my team,

00:48:00.230 --> 00:48:04.560
the low-level,
the Advanced Mac Toolbox team,

00:48:04.600 --> 00:48:09.590
hadn't really had a chance to
seriously use Interface Builder.

00:48:09.600 --> 00:48:14.120
We don't typically do those kinds
of things that have to do with

00:48:14.530 --> 00:48:16.830
interface and bits on the screen.

00:48:16.830 --> 00:48:16.830
And this was a...

00:48:29.290 --> 00:48:29.290
Basically,
I was surprised to actually see Interface

00:48:29.290 --> 00:48:29.290
Builder generating Carbon App in
almost no time flat without actually

00:48:29.290 --> 00:48:29.290
having to understand some of the
new technologies that are there.

00:48:29.720 --> 00:48:31.460
Okay, so what do I have here?

00:48:31.460 --> 00:48:39.040
I have... Let me go and hide
this... Can I hide this?

00:48:41.100 --> 00:48:46.850
John Iarocci, thank you.

00:48:46.850 --> 00:48:46.850
Okay.

00:48:47.230 --> 00:48:53.220
The top progress bar is the classic APIs,
the PBGetCatInfo sync

00:48:53.220 --> 00:48:55.220
call that we just saw.

00:48:55.580 --> 00:48:57.060
It's basically that loop.

00:48:57.060 --> 00:49:01.100
The bottom is the newer call,
the bulk call.

00:49:01.410 --> 00:49:05.100
Before I actually say go on this,
I wanted to bring up one other thing.

00:49:05.100 --> 00:49:09.100
I wanted to do this in a pretty fair way.

00:49:09.100 --> 00:49:16.100
I'll get to actually the way I went
about doing this a little bit later.

00:49:16.100 --> 00:49:20.080
Basically, I decided to do both of
these tests on an MP thread.

00:49:20.100 --> 00:49:25.970
Basically, the only difference between
the two executing is the kernel

00:49:25.970 --> 00:49:29.100
time-slicing them appropriately.

00:49:29.100 --> 00:49:32.610
Most of what these threads are
doing shouldn't take that long

00:49:32.670 --> 00:49:36.100
in terms of... ...CPU processing.

00:49:36.100 --> 00:49:41.670
They should go in and either
block very quickly because the

00:49:41.670 --> 00:49:44.710
OS detects that the data in question
isn't there and they have to

00:49:44.710 --> 00:49:48.560
actually get that from the device,
or rip right through that and just

00:49:48.560 --> 00:49:51.100
fetch the next one if it's cached.

00:49:52.530 --> 00:49:57.910
The other thing I want to bring
up is basically both of these,

00:49:57.910 --> 00:50:00.240
the new and the old,
are both iterating through

00:50:00.840 --> 00:50:03.270
two different directories.

00:50:04.470 --> 00:50:10.110
So that you don't get any caching
effects from one disturbing the other.

00:50:10.290 --> 00:50:13.250
And with that, I'll just let them go.

00:50:15.800 --> 00:50:18.960
It's a fairly small directory,
roughly double the time.

00:50:18.960 --> 00:50:22.160
The results are 65 ticks versus 31 ticks.

00:50:22.530 --> 00:50:28.370
This is extremely exaggerated in
the case where you go on a CD,

00:50:28.480 --> 00:50:33.800
a little bit less so on NFS,
and this is UFS on DP4.

00:50:33.960 --> 00:50:36.740
And you see that doubling is
something that you can easily do.

00:50:36.930 --> 00:50:41.050
One thing to note, though,
is it really will depend on the

00:50:41.050 --> 00:50:43.800
contents of what's in the directory.

00:50:43.800 --> 00:50:45.800
And that gets back to, you know,
are there resource forks?

00:50:45.800 --> 00:50:50.800
Are there things that aren't easily
represented on the volume format?

00:50:50.800 --> 00:50:54.390
Okay, can we get the slides back?

00:50:58.980 --> 00:51:02.580
Okay, so we've talked about the
file manager again there.

00:51:02.720 --> 00:51:07.130
The biggest advice I have
is to use the HFS+ APIs.

00:51:07.220 --> 00:51:09.770
Now we're on to the folder manager.

00:51:11.410 --> 00:51:16.130
The biggest change to the folder
manager for OS X has been to support

00:51:16.190 --> 00:51:20.060
a concept that we call domains.

00:51:20.780 --> 00:51:26.020
OS X supports a notion where
you have basically a system,

00:51:26.160 --> 00:51:29.590
what we ship to you, that's read-only.

00:51:30.000 --> 00:51:32.000
It's not modified by the user.

00:51:32.000 --> 00:51:35.500
It's not typically modified
after it's shipped.

00:51:35.830 --> 00:51:37.700
That's kind of like the base domain.

00:51:37.700 --> 00:51:39.240
That's what you start with.

00:51:39.270 --> 00:51:45.980
Above that is typically either a
network or a local domain where

00:51:45.980 --> 00:51:49.960
you do install things in that
are shared by all applications,

00:51:49.960 --> 00:51:51.050
by all users.

00:51:51.320 --> 00:52:00.550
User Domain:
User Domain is roughly just for the user.

00:52:00.550 --> 00:52:09.100
Things that apply to all
domains are preferences,

00:52:09.100 --> 00:52:12.630
fonts, and fonts.

00:52:12.710 --> 00:52:19.200
You don't want to use your own fonts.

00:52:19.200 --> 00:52:21.900
Alternatively,
fonts could also be installed

00:52:21.900 --> 00:52:23.640
in one of the other domains.

00:52:23.660 --> 00:52:27.670
Actually,
domains have to do a lot with sharing.

00:52:27.940 --> 00:52:39.770
The folder manager has been enhanced
to support these domains by using the

00:52:39.880 --> 00:52:45.760
first parameter of the defined folder
instead of just supporting the refnums.

00:52:45.760 --> 00:52:49.720
It also supports some
well-known domain constants.

00:52:50.040 --> 00:52:53.420
It's important to note, though,
that there are some types of

00:52:53.420 --> 00:52:57.190
things that the selectors that
the folder manager supports that

00:52:57.190 --> 00:52:58.850
don't make sense in domains.

00:52:58.930 --> 00:53:03.130
The two examples that I have here,
temporary items and trash.

00:53:03.450 --> 00:53:08.600
Temporary items, for example,
is typically used when you

00:53:08.690 --> 00:53:11.310
want to do some kind of

00:53:11.400 --> 00:53:16.060
Well, the best case I have is when
you want to use PBXchange files,

00:53:16.090 --> 00:53:20.650
you want to basically make sure that the
file in question that you're going to

00:53:20.650 --> 00:53:24.960
save atomically is on the same volume,
right?

00:53:25.100 --> 00:53:27.340
Trash is another case.

00:53:27.340 --> 00:53:30.240
If that ended up being
in some different volume,

00:53:30.350 --> 00:53:33.120
then you'd end up doing a
copy for trash and that's not

00:53:33.210 --> 00:53:34.750
really what you wanted either.

00:53:34.890 --> 00:53:42.360
So to check for the support of this,
you just have to check this Gestalt bit.

00:53:42.360 --> 00:53:42.370
Folder Manager supports domains.

00:53:42.640 --> 00:53:49.130
The other thing that I wanted to
bring up is you'll see a bullet

00:53:49.140 --> 00:53:50.910
item on a lot of these slides.

00:53:50.930 --> 00:54:00.600
Most of these lower-level technologies
have up-and-coming FSRef-based APIs.

00:54:00.600 --> 00:54:04.410
If you had already started
on HFS+ conversion,

00:54:04.410 --> 00:54:10.180
you may have ran into the fact that,
yeah, you're using HFS+ APIs,

00:54:10.250 --> 00:54:12.780
but then when you have to ask
the folder manager for something,

00:54:12.810 --> 00:54:15.100
it's in terms of an FS spec.

00:54:15.280 --> 00:54:20.290
We're slowly taking HFS+ APIs.

00:54:20.520 --> 00:54:29.480
My guess is for the public beta,
you'll have variant APIs in a

00:54:29.480 --> 00:54:29.480
bunch of these technologies that
let you use them more directly.

00:54:30.770 --> 00:54:32.460
Okay, resources.

00:54:32.460 --> 00:54:34.720
There's been a lot of
questions about resources,

00:54:34.760 --> 00:54:38.630
in particular,
are resource forks supported?

00:54:45.630 --> 00:54:49.100
Very quickly, we'll go through the
chain management APIs.

00:54:49.100 --> 00:54:51.500
These are things that have
been there since CarbonLib 1.0.

00:54:51.500 --> 00:54:58.360
They allow an insertion and
removal of resources in the chain.

00:54:58.520 --> 00:55:03.810
One thing to keep aware of on
OS X is that we actually support

00:55:03.810 --> 00:55:05.500
file mapping of resource files.

00:55:05.870 --> 00:55:10.130
That is,
we file map things that would be shared.

00:55:10.360 --> 00:55:13.180
Things that roughly
equate to the system file.

00:55:13.200 --> 00:55:16.690
And what that means to you is that

00:55:16.800 --> 00:55:22.600
[Transcript missing]

00:55:22.890 --> 00:55:27.260
This is very similar to a
ROM on older Macintoshes.

00:55:27.270 --> 00:55:29.840
You might get ROM data in older Macs.

00:55:29.880 --> 00:55:32.910
You'll probably end up

00:55:33.380 --> 00:55:39.300
You can actually silently dereference
a handle to ROM data on OS X.

00:55:39.300 --> 00:55:40.300
You won't be able to do that.

00:55:40.300 --> 00:55:42.700
If you need that data,
if you want to modify that data,

00:55:42.700 --> 00:55:44.290
you're going to have
to use Detach Resource.

00:55:44.300 --> 00:55:49.000
And then the Resource Manager is
going to continue the trend and have

00:55:49.000 --> 00:55:52.300
some FSRef-based APIs available.

00:55:52.760 --> 00:55:57.740
There have been a lot of questions
about resource forks in CFBundle.

00:55:58.750 --> 00:56:01.630
I guess the biggest thing here is
that basically because we want to

00:56:01.630 --> 00:56:04.990
interoperate with other volume formats,
we've introduced an app

00:56:04.990 --> 00:56:11.250
packaging specification that
doesn't use resource forks.

00:56:11.320 --> 00:56:14.630
It uses resources in data forks.

00:56:15.450 --> 00:56:16.570
Now why is that a good thing?

00:56:16.660 --> 00:56:20.230
It's a good thing because that's
kind of a lowest common denominator

00:56:20.230 --> 00:56:22.200
solution that transfers easily.

00:56:22.220 --> 00:56:24.990
You can copy that off the web,
off of FTP,

00:56:25.010 --> 00:56:28.310
you can copy it up to an NFS server,
copy it back without

00:56:28.450 --> 00:56:31.620
having to modify tools,
without having to understand

00:56:31.620 --> 00:56:33.310
about things like forks.

00:56:33.950 --> 00:56:39.080
So there are some APIs that enable
this in the Resource Manager,

00:56:39.080 --> 00:56:43.900
and this happens for you for free
for your application resources.

00:56:43.900 --> 00:56:46.990
If you're packaged,
you'll basically get two DataFork

00:56:46.990 --> 00:56:52.310
resource files open for you,
assuming you've localized your app, one,

00:56:52.310 --> 00:56:53.480
if you haven't.

00:56:54.550 --> 00:56:58.990
And then just in case you haven't
gotten to any of the CF talks,

00:56:58.990 --> 00:57:01.400
if you need to get to anything
else within your application

00:57:01.400 --> 00:57:06.100
that's been packaged,
just make sure you use the CFBundle APIs.

00:57:06.720 --> 00:57:08.260
Okay, Code Fragment Manager.

00:57:08.390 --> 00:57:11.580
There's been a big change we
were actually able to get in.

00:57:11.580 --> 00:57:14.190
We hadn't planned on making
this available for DP4,

00:57:14.200 --> 00:57:19.700
but we got far enough along that we did
get a preview of this technology in DP4.

00:57:19.700 --> 00:57:21.650
It's not on by default.

00:57:21.750 --> 00:57:23.700
You're going to have to go and enable it.

00:57:23.980 --> 00:57:28.390
In the release notes on DP4
in the documentation folder,

00:57:28.510 --> 00:57:31.820
there's a release note on
the Code Fragment Manager on

00:57:31.820 --> 00:57:33.700
how to actually enable it.

00:57:33.700 --> 00:57:37.770
One of the key features of the
work we've done on this is it

00:57:37.770 --> 00:57:40.130
really helps with launch time.

00:57:40.680 --> 00:57:42.540
Basically,
we were able to take a calculation

00:57:42.550 --> 00:57:47.830
that happened at runtime previously,
make that occur at link time,

00:57:47.830 --> 00:57:51.700
so that CFM launches are a lot
faster with this technology enabled.

00:57:51.700 --> 00:57:56.820
The current default implementation
in Code Fragment Manager does

00:57:56.830 --> 00:57:59.020
not support data exports.

00:57:59.020 --> 00:58:00.700
This new one does.

00:58:00.700 --> 00:58:05.330
In addition, because of the way in which
the work was done at link time,

00:58:05.480 --> 00:58:09.700
we support lazy initialization
in the same way that DYLD does.

00:58:09.910 --> 00:58:15.700
You do not pay the cost until you
actually use the library in question.

00:58:17.120 --> 00:58:20.150
There are two particular issues on OS X.

00:58:20.160 --> 00:58:24.300
Resource-based fragments
are not supported.

00:58:24.300 --> 00:58:28.600
The workaround or the alternative to
doing that is actually handling whatever

00:58:28.660 --> 00:58:33.200
you want to load from a resource yourself
by calling the resource manager and

00:58:33.470 --> 00:58:36.000
then using memory fragments instead.

00:58:36.000 --> 00:58:40.480
And then, in general,
shared data sections are not supported.

00:58:40.950 --> 00:58:43.500
We already talked about
the velocity engine issue.

00:58:43.720 --> 00:58:45.570
Okay, the process manager.

00:58:45.570 --> 00:58:49.700
The process manager is fully
functional on the current release.

00:58:49.700 --> 00:58:51.990
It's compatible with app packages.

00:58:52.090 --> 00:58:54.680
There's been some confusion about this.

00:58:54.680 --> 00:58:59.080
Basically, if we preserve the illusion in
the process manager that you

00:58:59.080 --> 00:59:00.800
kind of have in the finder.

00:59:00.870 --> 00:59:05.270
If you ask for the process information
of a process that is app packaged,

00:59:05.270 --> 00:59:10.880
the spec associated with it, the FS spec,
is the spec to the .app, the .app.

00:59:10.900 --> 00:59:14.110
The .app is the package,
not to the executable

00:59:14.240 --> 00:59:15.870
contained within it.

00:59:16.180 --> 00:59:21.870
However, we also support traditionally
packaged single file applications,

00:59:21.870 --> 00:59:24.860
and that works pretty
much the same as it has.

00:59:27.230 --> 00:59:28.390
Thread Manager.

00:59:28.390 --> 00:59:29.100
Okay.

00:59:29.100 --> 00:59:33.900
There's a couple things I want to get
through here on the Thread Manager.

00:59:34.330 --> 00:59:38.660
One is that there's a lot of code
out there that goes through great

00:59:38.660 --> 00:59:44.250
pains to make sure that they use
threads in a memory-savvy way.

00:59:44.370 --> 00:59:47.420
They're trying to make sure they're not
using too much memory with their threads,

00:59:47.820 --> 00:59:50.990
managing the stack sizes,
and things like that.

00:59:51.100 --> 00:59:54.100
Most of that is unnecessary on 10.

00:59:54.100 --> 00:59:57.100
Some of that you can't
really do very well on 10.

00:59:57.100 --> 01:00:00.030
You can't really get the
stack size of another thread,

01:00:00.730 --> 01:00:04.920
particularly if that thread happens
to be running on another processor.

01:00:05.670 --> 01:00:11.330
This is just one of those kinds of
things that wasn't anticipated when

01:00:11.340 --> 01:00:14.600
the original Thread Manager came along.

01:00:14.850 --> 01:00:19.610
These threads and MP threads are
all layered on top of P threads.

01:00:19.980 --> 01:00:24.050
In the Thread Manager case,
they're still completely cooperative.

01:00:24.140 --> 01:00:26.430
So that is,
even though they're P-threads,

01:00:26.480 --> 01:00:29.900
they all race for the same lock and
only one of them can run at the time.

01:00:29.900 --> 01:00:34.220
The other problem that folks have
had with these kinds of threads

01:00:34.220 --> 01:00:39.010
is that generally the way that you
schedule them is off of null events,

01:00:39.010 --> 01:00:42.890
which doesn't really work very well
from a performance standpoint on 10.

01:00:42.900 --> 01:00:47.030
We've talked about in the Carbon event
sessions and other sessions,

01:00:47.030 --> 01:00:50.900
we really want you to be blocked
waiting for events to come in.

01:00:50.900 --> 01:00:54.210
If you're blocked waiting
for events to come in,

01:00:54.210 --> 01:00:58.880
then you can't really be calling
yield to any thread all the time.

01:00:58.920 --> 01:01:02.750
That's part of the problem
with Thread Manager threads.

01:01:02.900 --> 01:01:06.290
And of course, no concurrency.

01:01:06.960 --> 01:01:08.940
However,
I do want to bring up that Thread

01:01:08.940 --> 01:01:14.800
Manager is often the best solution
for your UI layer of your application.

01:01:14.800 --> 01:01:15.790
Why is that?

01:01:15.790 --> 01:01:19.370
Let me give this example.

01:01:19.950 --> 01:01:23.440
If you are handling four
different windows with four

01:01:23.440 --> 01:01:27.600
different preemptive threads,
and the user says,

01:01:27.600 --> 01:01:30.560
"Command + W," the shortcut
for closing the window,

01:01:30.580 --> 01:01:34.530
to all four windows,
what's going to happen if those threads

01:01:34.730 --> 01:01:36.800
are preemptive is completely random.

01:01:37.520 --> 01:01:39.160
There's not going to be any order.

01:01:39.290 --> 01:01:42.720
You'll do it one time and all the
windows will shut in one order.

01:01:42.930 --> 01:01:46.400
You do four command Ws again
and it'll be different.

01:01:46.610 --> 01:01:51.410
This is not good for a decent,
predictable UI.

01:01:51.560 --> 01:01:54.400
You do want cause and effect in your UI.

01:01:54.470 --> 01:01:59.620
The best way to keep that is probably
something like cooperative threads

01:01:59.620 --> 01:02:03.480
or even a single thread for your
UI and then have the backend of your

01:02:03.490 --> 01:02:07.300
application use preemptive threads.

01:02:07.900 --> 01:02:09.780
And that brings us to the MPA APIs.

01:02:09.830 --> 01:02:12.760
I already mentioned that they're
layered on top of P-threads.

01:02:12.760 --> 01:02:15.520
These are the APIs that we
really want to push you towards.

01:02:15.600 --> 01:02:19.830
These are the APIs that
work preemptively on Carbon,

01:02:19.950 --> 01:02:22.130
both on 9 and on 10.

01:02:22.380 --> 01:02:26.640
One difference,
there's been some confusion on this,

01:02:26.640 --> 01:02:30.000
is that MP constructs
are not system global.

01:02:30.520 --> 01:02:33.280
That is to say, on a 9,
where everything works

01:02:33.280 --> 01:02:37.240
in an address space,
an MPQ can be used to

01:02:37.330 --> 01:02:39.200
talk between processes.

01:02:39.300 --> 01:02:41.720
That's not the case on 10.

01:02:42.270 --> 01:02:45.200
The MP package is a fairly
thin layer on top of P threads.

01:02:45.200 --> 01:02:50.190
It's a per-process or
per-address space package.

01:02:51.790 --> 01:02:56.400
Then I just want to refer you to
another release note on how to

01:02:56.620 --> 01:02:59.100
use MP Create Tasks from CFM Maps.

01:02:59.100 --> 01:03:01.810
It's also on the DP4 release.

01:03:02.810 --> 01:03:05.740
And then I mentioned earlier
different thread-safe services.

01:03:05.860 --> 01:03:09.700
These are the ones that we're
talking about right now.

01:03:09.870 --> 01:03:14.530
Mostly file I/O networking,
that kind of thing.

01:03:16.560 --> 01:03:25.030
One more thing about threading is
that the models between 9 and 10 are

01:03:25.160 --> 01:03:29.420
Particularly different when
you're doing threading and I/O.

01:03:29.480 --> 01:03:32.770
Something you want to look at
is if you're using cooperative

01:03:32.910 --> 01:03:34.700
threads and a synchronous I/O.

01:03:35.330 --> 01:03:40.640
That is not going to perform
as well as synchronous I/O and

01:03:40.680 --> 01:03:42.570
preemptive threads on 10.

01:03:42.650 --> 01:03:45.660
It'll still work,
but it's just not going to get your

01:03:45.660 --> 01:03:47.490
last little bit of performance.

01:03:49.600 --> 01:03:53.310
Okay, Apple Events.

01:03:53.860 --> 01:03:57.140
Apple Events is basically the
only solution that we have for

01:03:57.190 --> 01:04:00.820
cross-process IPC inside of Carbon.

01:04:21.990 --> 01:04:21.990
There's been a little bit of,
there's been questions in the hallways

01:04:21.990 --> 01:04:21.990
about this and things like that.

01:04:21.990 --> 01:04:21.990
So if you need to do cross-process IPC,
this is the solution.

01:04:21.990 --> 01:04:21.990
The other alternatives are
only available on 10 are CF,

01:04:21.990 --> 01:04:21.990
Core Foundation allows for some
level of cross-process communication,

01:04:21.990 --> 01:04:21.990
and then Mach messaging directly.

01:04:22.800 --> 01:04:31.700
[Transcript missing]

01:04:32.440 --> 01:04:34.700
Other than that,
they're a foundation technology.

01:04:34.700 --> 01:04:38.200
They're being used throughout
all the frameworks:

01:04:38.200 --> 01:04:41.900
Cocoa, Carbon, Classic.

01:04:42.000 --> 01:04:45.450
One of the things I didn't mention
in the process manager is all the

01:04:45.450 --> 01:04:49.720
applications within Classic actually
have an individual PSN,

01:04:49.750 --> 01:04:52.770
so they're each uniquely
targetable that way.

01:04:54.820 --> 01:04:57.610
Okay,
now I'd like to bring Steve Zellers up,

01:04:57.680 --> 01:05:01.090
who's going to do an
Apple event-related demo.

01:05:03.800 --> 01:06:06.300
[Transcript missing]

01:06:09.310 --> 01:06:14.400
So here's my window over here with a
bunch of predefined searches and things.

01:06:14.460 --> 01:06:18.430
And as I'm executing searches,
you can see that the database

01:06:18.430 --> 01:06:21.470
over here connects to the server,
performs a search,

01:06:21.550 --> 01:06:24.100
and then displays a search.

01:06:24.130 --> 01:06:28.090
Now, that's obviously not something you
want your database to do all the time.

01:06:28.100 --> 01:06:30.980
If this were a commercial database
like one of you would develop,

01:06:30.980 --> 01:06:33.900
you would return the data
without updating the UI.

01:06:34.140 --> 01:06:38.020
But you could do that in a background
application without having to

01:06:38.020 --> 01:06:40.050
present the UI to the user at all.

01:06:40.130 --> 01:06:44.450
So over here,
you can see the session transcript

01:06:44.450 --> 01:06:49.490
of what the Perl script actually
told the command line tool

01:06:49.630 --> 01:06:52.100
to send to the database.

01:06:52.140 --> 01:06:56.630
It's over here, and what gets returned is
standard Apple script results,

01:06:56.630 --> 01:07:01.100
which are in turn interpreted by the
Perl script and turned into HTML.

01:07:01.100 --> 01:07:03.270
Let's do all searches at once,
because that's more interesting

01:07:03.270 --> 01:07:04.100
to watch over there.

01:07:04.100 --> 01:07:08.620
So as you can see,
you can put together a real application,

01:07:08.620 --> 01:07:13.090
a real workflow,
using Carbon and your applications.

01:07:13.100 --> 01:07:16.100
Okay, thanks, Steve.

01:07:20.860 --> 01:07:23.650
Okay,
we're at the More Information section.

01:07:23.700 --> 01:07:27.440
You've probably seen the
Carbon documentation URL,

01:07:27.480 --> 01:07:28.700
but that's up there again.

01:07:28.700 --> 01:07:32.560
The two release notes that I referred
to are on the DP4 release in

01:07:32.560 --> 01:07:35.700
System Developer Documentation
Release Notes.

01:07:36.170 --> 01:07:41.280
CarbonCore.html is going to go over some
of the issues that I mentioned with the

01:07:41.530 --> 01:07:44.600
Memory Manager and CodeFragment Manager.

01:07:44.600 --> 01:07:52.290
And then the CodeFragment Manager has
its own release note on how to

01:07:52.300 --> 01:07:55.500
enable the new vector libraries.

01:07:56.060 --> 01:07:58.750
And now that summary.

01:07:58.860 --> 01:08:03.670
So HFS+ APIs, that's the big one.

01:08:04.030 --> 01:08:07.170
Most of the applications that
we've seen have just been ported.

01:08:07.210 --> 01:08:10.430
Not a lot of them have adopted HFS+ APIs.

01:08:10.820 --> 01:08:15.000
Now there's even a bigger
reason to adopt these APIs.

01:08:15.000 --> 01:08:17.800
And in particular,
using these APIs and using

01:08:17.800 --> 01:08:23.460
multi-processing APIs for a factored
application is a very good proven

01:08:23.980 --> 01:08:28.190
combination that's worked well on OS X.

01:08:29.540 --> 01:08:33.690
So to get back to one of the
Carbon overview sessions,

01:08:33.690 --> 01:08:37.510
Scott Forstall was actually
up there saying that he had

01:08:37.520 --> 01:08:38.690
some challenges for you.

01:08:38.700 --> 01:08:42.930
I have the same challenges and I'd
really like to see the development

01:08:42.990 --> 01:08:44.830
community take us up on this.

01:08:44.980 --> 01:08:50.500
In particular, with these core services,
we need feedback on things that may be

01:08:50.500 --> 01:08:53.400
impacting you in terms of performance,
in terms of features.

01:08:53.440 --> 01:08:56.040
We need things earlier rather than later.

01:08:56.090 --> 01:09:01.070
Particularly these layers of the system,
we can't rev at the very last second

01:09:01.120 --> 01:09:03.330
just because of the dependencies.

01:09:03.400 --> 01:09:08.210
So I encourage you to
bring your app up on DP4.

01:09:10.730 --> 01:09:16.230
Okay,
now I'd like to bring up a few of the

01:09:16.230 --> 01:09:21.390
people on my team for some quick Q&A.

01:09:21.730 --> 01:09:25.950
Actually, John, whoo-hoo.

01:09:26.350 --> 01:09:27.300
We are out of time.

01:09:28.300 --> 01:09:28.300
I'll wait to do a few questions.

01:09:28.300 --> 01:09:31.300
I told them that you had a lot
of information and you did.

01:09:32.300 --> 01:09:32.300
Okay.

01:09:32.300 --> 01:09:36.290
Actually, it looks like we have -- well,
I better not -- I can't even

01:09:36.300 --> 01:09:39.290
start it because of the -- Time.

01:09:39.570 --> 01:09:40.180
Yeah.

01:09:40.940 --> 01:09:41.220
Okay.

01:09:41.310 --> 01:09:42.300
Well, I can take some questions.

01:09:42.300 --> 01:09:43.200
We can probably go towards
the back over there.

01:09:43.500 --> 01:09:44.110
Yeah.

01:09:44.380 --> 01:09:46.300
So thank you all so much for
coming to this conference.

01:09:46.300 --> 01:09:49.300
Again, the feedback that you've
given us is so great.

01:09:49.300 --> 01:09:51.600
I know that Apple engineering has
been way encouraged by the show

01:09:51.600 --> 01:09:53.300
and hopefully you have been too.

01:09:53.300 --> 01:09:54.300
And we'll see you all next year.

01:09:54.300 --> 01:09:55.290
Thanks.

01:09:56.300 --> 01:09:57.970
♪ ♪
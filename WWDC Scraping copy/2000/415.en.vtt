WEBVTT

00:00:10.380 --> 00:00:13.900
Good morning, everybody.

00:00:13.940 --> 00:00:15.340
I hope you will understand me.

00:00:15.440 --> 00:00:18.760
Even with my French accent,
I'm going to try to talk slowly

00:00:19.130 --> 00:00:21.460
so everybody can understand,
especially the Japanese people

00:00:21.460 --> 00:00:24.130
in the box there that told me
to just please talk slowly,

00:00:24.140 --> 00:00:26.610
otherwise we don't understand anything.

00:00:27.530 --> 00:00:31.740
I want to talk about Advanced EOF.

00:00:31.740 --> 00:00:34.460
So what is Advanced EOF?

00:00:34.520 --> 00:00:41.810
Something like a month ago somebody
came into my into my office and said,

00:00:41.820 --> 00:00:43.530
"Hey,
you're going to have a talk at WWDC.

00:00:43.600 --> 00:00:46.250
You're going to talk about
Advanced EOF." I can say,

00:00:46.400 --> 00:00:48.900
"Okay,
what am I going to talk about?" I say,

00:00:48.900 --> 00:00:50.330
"Oh, that's your problem.

00:00:50.330 --> 00:00:51.490
That's Advanced EOF.

00:00:51.630 --> 00:00:53.100
You're the Advanced EOF guy.

00:00:53.100 --> 00:00:56.420
Deal with it."

00:00:56.610 --> 00:01:00.340
So I took a piece of paper and started,
you know, jotting notes on it and said,

00:01:00.340 --> 00:01:05.470
"Okay, what can I talk about?" I can talk
about how to write an adapter,

00:01:05.500 --> 00:01:11.350
or I can talk about some stupid things
that I've seen some customers doing.

00:01:11.500 --> 00:01:16.500
I can talk about all the features in EOF,
you know, we have plenty of features.

00:01:16.500 --> 00:01:18.780
And I went to see the other
member of the team and asked,

00:01:18.900 --> 00:01:22.530
you know, "What can I talk about?"
And everybody had a different idea

00:01:22.530 --> 00:01:24.500
about what I should talk about.

00:01:24.500 --> 00:01:25.500
And I didn't end up with this list.

00:01:25.500 --> 00:01:30.090
I could have filled the 18 sessions
just with just the content of the list.

00:01:30.120 --> 00:01:36.200
So it was really hard to find
something that's advanced and

00:01:36.300 --> 00:01:38.610
something that's interesting.

00:01:39.620 --> 00:01:47.150
And I finally tried to reduce this thing
in a session that lasts just an hour.

00:01:47.460 --> 00:01:50.820
And I finally reduced it and reduced
it and then re-upholstered the session.

00:01:50.820 --> 00:01:53.700
And it was still two hours,
so I reduced it a little more.

00:01:53.760 --> 00:01:56.940
And I did end up with an agenda
that contained only two items.

00:01:56.980 --> 00:01:59.790
But these are good items.

00:02:00.270 --> 00:02:07.190
First item is what I want to cover is
how do you do a good enterprise object?

00:02:07.210 --> 00:02:09.380
What's the process?

00:02:09.460 --> 00:02:15.490
What should be the mindset
at every step on the way?

00:02:16.140 --> 00:02:18.460
It's actually a real problem.

00:02:18.460 --> 00:02:22.040
When you see all these demos
of direct-to-Java client,

00:02:22.100 --> 00:02:26.000
direct-to-web,
or any kind of WebObjects demo,

00:02:26.000 --> 00:02:28.920
you see the demo is always starting, "Oh,
I have this model file

00:02:28.920 --> 00:02:30.480
I have somewhere on my disk.

00:02:30.670 --> 00:02:34.360
Just drop it there." But actually
making the model file and getting to

00:02:34.360 --> 00:02:38.460
this where you can just drop some model
file in your application and having

00:02:38.460 --> 00:02:41.560
everything work is actually quite tough.

00:02:41.560 --> 00:02:43.550
So I want to talk about this.

00:02:43.720 --> 00:02:46.040
It's going to take half of my time.

00:02:46.040 --> 00:02:53.180
And the second thing I want to talk
about is about the new features in 4.5.

00:02:53.180 --> 00:02:56.220
We introduced a lot of
really cool things in 4.5.

00:02:56.220 --> 00:02:59.700
And who in the room is using 4.5?

00:03:00.270 --> 00:03:03.930
That's, that's... okay.

00:03:04.450 --> 00:03:07.160
So I want to point out what are
the little things that we did,

00:03:07.190 --> 00:03:10.400
and the big thing that we did
in 4.5 that were not in 4,

00:03:10.400 --> 00:03:12.770
that were not here before,
and that you can use

00:03:12.770 --> 00:03:16.710
in your applications,
and some of them are really good.

00:03:17.100 --> 00:03:19.680
So, let's start.

00:03:20.120 --> 00:03:21.600
How to design a good EOF?

00:03:21.680 --> 00:03:23.000
Where do you start?

00:03:23.160 --> 00:03:26.000
Well, you start with your data model.

00:03:26.000 --> 00:03:28.000
You start with your data.

00:03:28.000 --> 00:03:29.960
You start with what's in your database.

00:03:30.350 --> 00:03:34.490
Most of the time,
you have an existing database

00:03:34.490 --> 00:03:35.900
that you have to deal with.

00:03:36.000 --> 00:03:39.500
Some of the time, you have the liberty to
create your own database,

00:03:39.590 --> 00:03:44.000
and that's better because you can make
better decisions to integrate with EOF.

00:03:44.000 --> 00:03:47.940
But, you know, we know what real life is,
and you have to integrate

00:03:48.050 --> 00:03:51.360
with what's already there,
what exists, you know,

00:03:51.360 --> 00:03:55.820
and deal with this database administrator
who is in no way going to change his view

00:03:56.160 --> 00:03:59.940
and giving you nice access to his table.

00:04:01.380 --> 00:04:06.630
So when you look at what's in
your database and you're thinking

00:04:06.630 --> 00:04:12.650
about integrating with EOF,
the first thing is think about the

00:04:12.880 --> 00:04:15.020
performance implications of the design.

00:04:15.040 --> 00:04:22.560
If your customer table,
every row has a 10 megabyte blob in it,

00:04:22.560 --> 00:04:24.400
well,
you're not going to have good performance

00:04:24.510 --> 00:04:27.120
because you're going to fetch these
blobs over and over and over again,

00:04:27.120 --> 00:04:29.360
and it's going to take all your time.

00:04:32.920 --> 00:04:38.210
Also, when you look at a database,
especially a database that's really split

00:04:38.210 --> 00:04:43.630
in little tables all over the place,
you have a tendency to think, "Oh,

00:04:43.630 --> 00:04:45.550
I can model that with object inheritance.

00:04:45.550 --> 00:04:46.290
That would be great.

00:04:46.350 --> 00:04:48.610
I can have this 20-legger
of inheritance thing,

00:04:48.730 --> 00:04:52.380
and it's going to be
great." But the problem is,

00:04:52.440 --> 00:04:54.130
there is a performance
problem with inheritance.

00:04:54.190 --> 00:05:01.210
Inheritance is working,
but it's a dangerous thing.

00:05:02.310 --> 00:05:07.320
If you go with something that's too deep,
you're going to have a really,

00:05:07.320 --> 00:05:11.050
really hard time keeping the
performance up and being able

00:05:11.050 --> 00:05:14.990
to fetch all these things,
not mentioning that

00:05:15.360 --> 00:05:18.980
Sometimes you're going to have
some problems with EOF in certain

00:05:18.980 --> 00:05:22.200
cases of inheritance that you are
going to need to deal with it.

00:05:22.420 --> 00:05:29.910
If you don't have any inheritance,
that's way simpler to work with EOF.

00:05:31.350 --> 00:05:34.190
Another thing are trigger
and stored procedures.

00:05:34.200 --> 00:05:37.690
EOF is working fine with
trigger and stored procedures,

00:05:37.690 --> 00:05:40.180
but you have some work to do in
order to make this thing work.

00:05:40.280 --> 00:05:45.180
By default,
we don't do anything in this area.

00:05:45.200 --> 00:05:49.350
The worst I've seen was actually
an internal project at Apple,

00:05:49.350 --> 00:05:52.360
where we've seen this
internal application,

00:05:52.360 --> 00:05:56.460
and we decided to try to write a
prototype to replace the existing

00:05:56.460 --> 00:06:00.070
application using EOF and Java Client,
actually.

00:06:01.780 --> 00:06:05.500
And so we asked the DBA,
a person in ISNT in charge of database,

00:06:05.560 --> 00:06:12.030
"Hey, give us database access,
right?" And this person gave us

00:06:13.020 --> 00:06:15.880
So, we had an access to a database
that was really weird.

00:06:15.880 --> 00:06:19.910
It gave us an access to a bunch of views,
views on everything in the database.

00:06:19.910 --> 00:06:23.310
No real table, just views,
read-only views all over the place.

00:06:23.310 --> 00:06:27.270
And to modify the database was, oh,
we have all these stored procedures that

00:06:27.270 --> 00:06:29.220
you can call and doing other things.

00:06:29.220 --> 00:06:32.440
And what they did, actually,
was encoding all their business

00:06:32.440 --> 00:06:35.510
logic in the stored procedure there,
all their validation

00:06:35.510 --> 00:06:37.230
rules and everything.

00:06:37.850 --> 00:06:40.410
From the database standpoint,
that makes some sense.

00:06:40.660 --> 00:06:44.020
From the DBA position,
he doesn't want his database

00:06:44.020 --> 00:06:46.940
to be touched in a way
he doesn't understand it.

00:06:47.330 --> 00:06:50.890
But for an EOF point of view,
this is a nightmare.

00:06:58.130 --> 00:06:58.280
It's just insane.

00:06:58.320 --> 00:06:58.780
You cannot just,
you have to modify all your updates,

00:06:58.780 --> 00:06:59.470
you have to modify all your delete,
you have to modify all your fetch,

00:06:59.580 --> 00:07:05.420
because of course all the view he was
giving us were doing joins in the back,

00:07:05.420 --> 00:07:06.850
so they were relatively slow.

00:07:06.850 --> 00:07:09.450
In order to get data,
we had to fetch from multiple views

00:07:09.450 --> 00:07:13.090
and doing join between the views and
getting the same data multiple times.

00:07:13.140 --> 00:07:15.100
This was just insane.

00:07:16.010 --> 00:07:19.140
And to be honest with you, we gave up.

00:07:19.140 --> 00:07:21.600
We decided that it was
not worth the trouble,

00:07:21.710 --> 00:07:26.230
and we banged on the DBAA until it
gave us real access to the database,

00:07:26.390 --> 00:07:27.100
to the real tables.

00:07:28.100 --> 00:07:31.070
And at that time,
we discovered why there was views,

00:07:31.130 --> 00:07:32.660
is because the real database was,
you know,

00:07:32.660 --> 00:07:35.100
an old database that was revised
and revised and revised and revised.

00:07:35.100 --> 00:07:40.640
And this was just a mess,
and it took us something like a week just

00:07:40.730 --> 00:07:44.470
to understand what was in the database.

00:07:45.960 --> 00:07:50.890
And finally, last thing you have to think
about is how your primary key

00:07:50.890 --> 00:07:54.080
are generated in the database.

00:07:54.100 --> 00:07:56.740
That's something that's important.

00:07:56.880 --> 00:07:59.460
And we kind of defer this thing.

00:07:59.500 --> 00:08:01.340
Oh, I'll deal with it later.

00:08:01.670 --> 00:08:04.950
And you have to think it right away,
because it's going to impact the design.

00:08:05.050 --> 00:08:09.510
It's going to change the way
you interact with the database.

00:08:09.780 --> 00:08:15.820
I have a slide on primary key generation
here showing off the four main ways that

00:08:15.820 --> 00:08:19.700
EOF supports generating primary keys.

00:08:19.700 --> 00:08:22.700
The first,
easiest way is you control the database.

00:08:22.700 --> 00:08:25.700
You are the only user of the database,
or you're creating the database.

00:08:25.700 --> 00:08:28.630
Let the EO adapter or underlet adjust.

00:08:28.760 --> 00:08:31.460
If you're in Oracle, that's a sequence.

00:08:31.730 --> 00:08:34.700
If you're on Sybase,
that's a stored procedure.

00:08:34.700 --> 00:08:39.740
If you're using ODBC,
that's just a separate table that we read

00:08:39.940 --> 00:08:42.620
and update and do these kind of things.

00:08:42.710 --> 00:08:47.310
It's working just fine,
but you have to be aware that

00:08:47.310 --> 00:08:50.700
actually this is the slowest
way you can do primary key.

00:08:50.720 --> 00:08:53.450
Every time you insert an object,
you're going to do an additional

00:08:53.550 --> 00:08:57.640
round trip to the database to get
the primary key for this object.

00:08:57.750 --> 00:09:01.700
So if you insert 200 objects,
that's 200 round trips.

00:09:01.700 --> 00:09:06.700
So if you don't insert a lot of objects,
that's fine.

00:09:06.700 --> 00:09:08.790
If you insert a lot of objects,
you may want to try one

00:09:09.040 --> 00:09:10.700
or the other approach.

00:09:12.220 --> 00:09:16.490
The second approach is,
in your database you make the

00:09:16.490 --> 00:09:21.100
primaric of your object NSData,
some kind of blob value.

00:09:21.100 --> 00:09:25.600
On the application side,
you make this an NSData,

00:09:25.600 --> 00:09:28.100
and you make it exactly 12 bytes long.

00:09:28.320 --> 00:09:33.710
What's going to happen there
is WebObjects.EOF is going to

00:09:33.760 --> 00:09:36.930
generate this primaric for you.

00:09:37.410 --> 00:09:43.880
creating something from the process ID,
the IP address, a timestamp,

00:09:43.960 --> 00:09:44.920
and some other stuff.

00:09:44.920 --> 00:09:48.420
We generate something unique on
the application side and stuff

00:09:48.600 --> 00:09:52.310
that in the snapshot and send
that to the database server.

00:09:52.400 --> 00:09:53.640
So we don't make any round trips.

00:09:53.730 --> 00:09:55.470
It's way faster.

00:09:55.810 --> 00:09:59.070
You notice my stump here,
Web Objects 5 for Java.

00:09:59.180 --> 00:10:00.700
Why is it there?

00:10:00.700 --> 00:10:03.500
Well, you know, we're going pure Java.

00:10:03.500 --> 00:10:07.730
In pure Java, we don't have a process ID,
right?

00:10:15.100 --> 00:10:15.100
And we have no way to get one,
so we had to change this feature,

00:10:15.100 --> 00:10:15.110
actually.

00:10:15.110 --> 00:10:17.500
And I just want to point out that
for the next three of the WebObjects,

00:10:17.670 --> 00:10:22.070
the 12-byte binary is going
to be a 24-byte binary.

00:10:22.170 --> 00:10:25.580
So if you're using this feature,
you have to be aware of that,

00:10:25.580 --> 00:10:30.170
because that means that your database is
going to need to change when you're going

00:10:30.240 --> 00:10:33.090
to transition from 4.5 to 5 for Java.

00:10:33.310 --> 00:10:37.100
That's why I've used this
little red warning there.

00:10:37.220 --> 00:10:40.030
So the way of generating
primary keys is to use delegate,

00:10:40.030 --> 00:10:42.890
database context, new primary key,
and you basically do

00:10:42.890 --> 00:10:44.060
whatever you want in there.

00:10:44.100 --> 00:10:47.810
You just return a dictionary
containing your primary keys,

00:10:47.810 --> 00:10:52.660
and at the end of it, this is -- you can,
for example, do that to -- with Oracle,

00:10:52.660 --> 00:10:55.100
you can use sequences
the same way that we do,

00:10:55.100 --> 00:10:57.660
but instead of asking, you know,
one number at a time,

00:10:57.680 --> 00:11:03.100
you can just go there and ask for 100
numbers and then reuse them in memory,

00:11:03.100 --> 00:11:06.030
and when you are out of them,
you ask for the next batch of 100.

00:11:06.270 --> 00:11:11.050
So that's a way to solve the
performance issue with the first one.

00:11:11.100 --> 00:11:15.940
And finally,
a way that's actually really simple.

00:11:16.140 --> 00:11:20.100
You make the primary key a
class property attribute,

00:11:20.100 --> 00:11:23.100
so it's part of your object,
and in a way, from insertion,

00:11:23.100 --> 00:11:26.040
you just stuff something in there,
and that's your primary key.

00:11:26.150 --> 00:11:29.370
Simplest way to do it.

00:11:31.820 --> 00:11:34.770
So once you have your data model,
you understand what's going

00:11:34.770 --> 00:11:36.650
to be in your database,
how you're going to

00:11:36.650 --> 00:11:40.470
generate your primary key,
how you're going to make EOF interface

00:11:40.470 --> 00:11:44.680
with your stored procedure,
how you're going to

00:11:44.680 --> 00:11:51.100
deal with the triggers,
all this kind of information, well,

00:11:51.490 --> 00:11:54.540
it's time to build your model
file to model this mapping between

00:11:54.540 --> 00:11:54.540
your database and your objects.

00:11:56.650 --> 00:11:59.840
The first thing is spend
time on your model file.

00:11:59.860 --> 00:12:01.340
Your model file is really important.

00:12:01.340 --> 00:12:05.400
That's what your application,
that's what EOF is going to rely

00:12:05.400 --> 00:12:07.280
on to mess with your objects.

00:12:07.280 --> 00:12:09.560
So if there is something
wrong in the model file,

00:12:09.560 --> 00:12:13.970
we are going to mess something
wrong with your objects.

00:12:14.170 --> 00:12:15.500
So make sure you click
on all the inspector,

00:12:15.590 --> 00:12:18.340
you look all around,
you understand all of the checkboxes,

00:12:18.340 --> 00:12:19.510
read the documentation.

00:12:19.600 --> 00:12:24.610
I've seen a bug from a
customer once saying,

00:12:24.610 --> 00:12:28.030
"Hey, this thing is not working at all."
And I was trying to reproduce it,

00:12:28.030 --> 00:12:29.590
and impossible to reproduce it.

00:12:29.600 --> 00:12:32.590
I finally asked him, "Send me your model
file and your database,

00:12:32.600 --> 00:12:36.570
and send me this huge thing in a
mail attachment." And I looked at it,

00:12:36.570 --> 00:12:40.410
and I looked in the model file,
and there was little checkbox like

00:12:40.600 --> 00:12:44.600
Propagate Primarii Key that was
checked on one of the relationships.

00:12:44.750 --> 00:12:46.700
And of course,
nothing was working because he was

00:12:46.700 --> 00:12:50.600
trying to propagate Primarii Key,
something that should not propagate.

00:12:50.600 --> 00:12:52.600
Just bad.

00:12:52.600 --> 00:12:54.540
So I told him,
"Just take your model file,

00:12:54.680 --> 00:12:55.570
check out this thing.

00:12:55.620 --> 00:12:59.600
It's working just fine." And why
did you check this thing?

00:12:59.600 --> 00:13:00.600
He said, "Oh, I don't know.

00:13:00.600 --> 00:13:03.600
I just wanted to know
what this thing was doing,

00:13:03.600 --> 00:13:09.600
so I just checked it." And so this is
every single checkbox in this little box.

00:13:09.650 --> 00:13:12.600
So this little checkbox in this
little panel is really important.

00:13:12.600 --> 00:13:15.820
If you check Propagate Primarii Key,
you better know what this thing is doing,

00:13:15.860 --> 00:13:18.600
because otherwise you're
going to get in trouble.

00:13:18.600 --> 00:13:22.400
A good way to see if your relationships
are good is we actually spend

00:13:22.400 --> 00:13:25.030
some time in the model file,
in the stupid model file

00:13:25.030 --> 00:13:27.720
we have in our examples,
the studio and movie,

00:13:27.890 --> 00:13:29.590
and the one you see in all the demos.

00:13:29.750 --> 00:13:32.050
The reason why you see them in
all the demos is because they

00:13:32.050 --> 00:13:33.590
are actually good model files.

00:13:33.630 --> 00:13:36.560
You drop them in any demo,
and your demo is going to work because

00:13:36.630 --> 00:13:38.440
the model file is well-constructed.

00:13:38.730 --> 00:13:41.600
So what you can do is
compare your relationships.

00:13:41.600 --> 00:13:45.720
If you have too many relationships,
go look in the movie database,

00:13:45.720 --> 00:13:50.600
the relationship between the movie and
talent for the directors of a movie,

00:13:50.600 --> 00:13:53.600
and see if the checkbox are the same way.

00:13:53.600 --> 00:13:56.600
If the checkbox are not the same way,
if you have something slightly different,

00:13:56.600 --> 00:13:59.350
try to understand why.

00:13:59.640 --> 00:14:03.530
Just go look at all these relationships
everywhere in the example.

00:14:03.620 --> 00:14:07.600
I think we have all the possible
relationships defined in our model file.

00:14:07.600 --> 00:14:12.600
We have too many, we have too one,
we have one propagated primarities,

00:14:12.600 --> 00:14:14.600
we have optional to one,
mandatory to one.

00:14:14.600 --> 00:14:17.600
I think we have almost everything.

00:14:17.860 --> 00:14:21.390
Last but not least, do the demo.

00:14:21.740 --> 00:14:25.600
The direct to Java client
demo that Andreas did.

00:14:25.750 --> 00:14:30.600
Just take the template
for direct to Java client,

00:14:30.600 --> 00:14:33.590
drop your model in there,
compile the thing, run the thing.

00:14:33.600 --> 00:14:36.600
If the application you
get back looks good,

00:14:36.920 --> 00:14:39.600
there is a really good chance
that your model is good.

00:14:39.600 --> 00:14:42.600
If the application you get
back is showing some entities,

00:14:42.600 --> 00:14:45.600
some kind of relationships
you don't expect there,

00:14:45.630 --> 00:14:49.590
if the query window
contains all your entities,

00:14:49.660 --> 00:14:52.600
there is probably something
wrong in the relationships.

00:14:52.600 --> 00:14:55.690
Because the way direct to Java client
works is it's analyzing your model and

00:14:56.040 --> 00:15:00.080
making guesses on what's good and not
good based on the different relationships

00:15:00.080 --> 00:15:01.600
and how you specify the relationships.

00:15:01.600 --> 00:15:04.600
If they are optional,
if they are not optional, etc.

00:15:04.600 --> 00:15:05.600
So that's a good way of validating.

00:15:05.600 --> 00:15:09.070
evaluating your model file.

00:15:10.370 --> 00:15:14.180
And finally, once you have your
database that's all set up,

00:15:14.300 --> 00:15:18.260
you have a model file to work with it,
it's time to implement your logic.

00:15:18.330 --> 00:15:21.370
And implementing your logic, you have--

00:15:28.810 --> 00:15:29.100
So, you have multiple choices.

00:15:29.100 --> 00:15:29.480
The first one is you do
an EO generic record.

00:15:29.480 --> 00:15:29.650
It's just the data.

00:15:29.690 --> 00:15:30.020
You don't need anything else in the data.

00:15:30.040 --> 00:15:30.290
So, that's fine.

00:15:30.380 --> 00:15:31.730
That's working in all cases.

00:15:31.800 --> 00:15:35.570
Second case is you want,
you can use custom enterprise objects

00:15:35.580 --> 00:15:39.800
where you can actually build some
logic in the implement methods.

00:15:39.800 --> 00:15:47.980
But when you subclass custom objects in
Java and put your instance variable here,

00:15:47.980 --> 00:15:51.800
every time you change your model
file or you change your database,

00:15:51.920 --> 00:15:54.490
that's change your model file,
and then you want to change

00:15:54.490 --> 00:15:57.460
your enterprise object,
it's going to, you are going to have

00:15:57.460 --> 00:15:58.800
to do some maintenance.

00:15:58.800 --> 00:16:02.450
Because you are going to have to
add and remove all these instance

00:16:02.450 --> 00:16:04.800
variables and access all that stuff.

00:16:04.800 --> 00:16:09.150
So, in 4.5, I already talked about that.

00:16:09.820 --> 00:16:11.200
yesterday, I think.

00:16:11.200 --> 00:16:13.270
You can subclass your generic record.

00:16:13.290 --> 00:16:15.890
It gives you less maintenance
because you don't have to maintain

00:16:15.890 --> 00:16:16.800
all these instance variables.

00:16:16.800 --> 00:16:23.120
And it gives you better performance
in Java because you don't have

00:16:23.120 --> 00:16:28.290
to cross a bridge with all
your attributes all the time.

00:16:28.500 --> 00:16:33.260
So that's an example of a
few EO generic record class.

00:16:33.370 --> 00:16:37.160
I like, it's a personal preference,
I like to have a public

00:16:37.250 --> 00:16:40.000
final string with a name,
so I can use key value

00:16:40.000 --> 00:16:41.360
coding with no names.

00:16:41.360 --> 00:16:45.100
And this is the way you
implement two accessors.

00:16:45.100 --> 00:16:47.360
You're not forced to
implement your accessors,

00:16:47.360 --> 00:16:48.150
by the way.

00:16:48.200 --> 00:16:50.920
WebObjects and EOF,
when they access your EOs,

00:16:50.920 --> 00:16:52.860
don't need the accessor,
so you don't have to implement

00:16:52.860 --> 00:16:54.200
all the list of accessor.

00:16:54.200 --> 00:16:58.560
You know, if you have 30 attributes
in your objects,

00:16:58.560 --> 00:17:02.940
you don't need to implement 60
methods and 30 final strings.

00:17:02.940 --> 00:17:05.790
You can just remove everything,
unless you need it in your

00:17:05.790 --> 00:17:07.360
business logic to access it.

00:17:07.520 --> 00:17:12.470
Keeps the thing smaller if you
don't put everything in there.

00:17:13.940 --> 00:17:15.430
So,

00:17:16.660 --> 00:17:19.430
Eogenic Recur,
you can see here this stored value for

00:17:19.430 --> 00:17:23.240
key and text stored value for key thingy.

00:17:23.290 --> 00:17:26.570
I want to talk a little more about this,
because when EOF and

00:17:26.580 --> 00:17:29.650
WebObjects are using,
accessing your object

00:17:29.780 --> 00:17:32.610
to put value into it,
or to get value out of your object,

00:17:32.610 --> 00:17:34.330
we are using key value coding.

00:17:34.460 --> 00:17:38.020
And it's really important when
you write your code to understand

00:17:38.130 --> 00:17:42.190
how key value coding is working.

00:17:42.900 --> 00:17:49.720
This is actually a slide
that's going to take a while.

00:17:49.720 --> 00:17:52.600
We have two ways of
accessing your objects.

00:17:52.600 --> 00:17:56.620
We either use key value coding or
we use stored key value coding.

00:17:56.710 --> 00:17:59.430
And for both of these ways
to access your object,

00:17:59.550 --> 00:18:03.520
we have a get method and a set method,
and different ways of

00:18:03.520 --> 00:18:05.720
finding all this information.

00:18:05.720 --> 00:18:08.980
So let's start with the simplest way.

00:18:08.980 --> 00:18:11.600
Key value coding, you know,
your WebObjects application.

00:18:11.600 --> 00:18:15.960
You have a binding in your
UI that's bound to your display

00:18:15.960 --> 00:18:18.420
group and your object.name.

00:18:18.420 --> 00:18:22.540
WebObjects is going to use key
value coding to get to your object.

00:18:22.540 --> 00:18:23.390
And what's it going to use?

00:18:23.640 --> 00:18:25.360
Well, it's going to look in
your object and say,

00:18:25.410 --> 00:18:26.780
"Okay, what do we have in there?

00:18:26.780 --> 00:18:32.530
Is there a method name?"
If there is no method name,

00:18:32.530 --> 00:18:35.770
it's going to look for an
instance variable name,

00:18:35.780 --> 00:18:36.490
name.

00:18:36.890 --> 00:18:40.350
If there is still nothing,
it's going to try for underbar

00:18:40.780 --> 00:18:43.950
name as a method and underbar
name as an instance variable.

00:18:43.950 --> 00:18:45.290
Fairly easy.

00:18:45.480 --> 00:18:47.970
By the way,
this search is done only once, you know,

00:18:48.090 --> 00:18:49.040
once per class.

00:18:49.040 --> 00:18:51.040
We do the search and then we
cache information and then

00:18:51.040 --> 00:18:57.530
we have this thing that,
you know, you don't want to know.

00:18:59.610 --> 00:19:02.900
So this is fast, even if it seems that
it's doing a search,

00:19:02.980 --> 00:19:04.500
a search, a search, a search.

00:19:04.520 --> 00:19:08.130
This is plentiful fast.

00:19:08.620 --> 00:19:12.060
The set method is doing
exactly the same thing.

00:19:12.120 --> 00:19:14.970
It's looking for a set
method saying set name.

00:19:15.070 --> 00:19:17.560
It's doing-- it's looking for
an instance variable name.

00:19:17.610 --> 00:19:20.650
It's looking for another
set name and another name.

00:19:21.480 --> 00:19:23.300
Same kind of search.

00:19:23.300 --> 00:19:28.300
Now,
key value coding is used by WebObjects.

00:19:28.300 --> 00:19:31.300
WebObjects is using
only key value coding.

00:19:31.300 --> 00:19:37.300
It's never using stored key value coding,
because WebObjects is a user of your EO.

00:19:37.300 --> 00:19:39.300
It's just getting
information from your EO,

00:19:39.300 --> 00:19:42.400
displaying it in the UI,
and when the user changes something,

00:19:42.400 --> 00:19:44.090
it's putting back something in your EO.

00:19:44.300 --> 00:19:47.290
Stored key value coding is another beast.

00:19:47.300 --> 00:19:50.300
Stored key value coding is coming
from the other side of your EO.

00:19:50.300 --> 00:19:53.900
This is something we use
when we fetch data from the

00:19:53.900 --> 00:19:56.300
database and put it in your EO.

00:19:57.170 --> 00:20:01.320
So this stored key value coding
is used exclusively by EOF.

00:20:01.510 --> 00:20:05.580
It's mostly used when we snapshot.

00:20:05.670 --> 00:20:08.100
It's used when we fetch.

00:20:08.100 --> 00:20:15.600
It's used when there is anything that has
to do with the persistence of the object.

00:20:15.600 --> 00:20:19.810
We use stored key value coding
instead of using key value coding.

00:20:19.990 --> 00:20:21.700
So what are the differences
between the two?

00:20:21.830 --> 00:20:22.900
Well, the differences are easy.

00:20:22.900 --> 00:20:25.400
It's just the order of the search.

00:20:25.700 --> 00:20:28.680
We look for the underbar before
looking for the real thing.

00:20:28.750 --> 00:20:31.380
And the same thing for the set method.

00:20:31.500 --> 00:20:33.910
So what does this give you?

00:20:34.190 --> 00:20:38.150
Imagine that in your object
you have an instance variable

00:20:38.150 --> 00:20:40.140
name and a variable name.

00:20:40.140 --> 00:20:45.100
And you have a method
name and a method setName.

00:20:45.420 --> 00:20:48.300
So when you're going to fetch
your data from the database,

00:20:48.360 --> 00:20:50.940
we're going to go straight
to your instance variable.

00:20:51.030 --> 00:20:51.960
It's under the name.

00:20:51.960 --> 00:20:53.620
That's the first one I'm going to find.

00:20:53.620 --> 00:20:55.630
We're going to go straight
to this instance variable,

00:20:55.740 --> 00:20:58.460
stuff the data in it, and that's it.

00:20:58.460 --> 00:21:02.500
Now when, and when you save the object,
we are going to go straight to

00:21:02.620 --> 00:21:05.480
the instance variable again,
get the data there,

00:21:05.480 --> 00:21:07.180
and save it to the database.

00:21:07.180 --> 00:21:10.330
Now that's different in key value
coding because you have this method

00:21:10.330 --> 00:21:12.350
name and this method set name.

00:21:12.490 --> 00:21:17.370
So that means that when WebObjects
are going to access your object,

00:21:17.370 --> 00:21:22.520
or when any user is going
to access your object,

00:21:22.640 --> 00:21:24.210
it's going to...

00:21:24.580 --> 00:21:27.000
to execute some of your code.

00:21:27.090 --> 00:21:29.880
So you can actually do
something else in this code,

00:21:29.910 --> 00:21:32.600
because it's not going to
impact the fetch performance,

00:21:32.630 --> 00:21:35.380
because the fetch performance is going
to access the end-of-bar name first.

00:21:35.390 --> 00:21:37.590
It's not going to go through your method.

00:21:37.940 --> 00:21:41.670
So in your method,
you can enhance your business

00:21:42.080 --> 00:21:43.890
logic by putting some...

00:21:44.100 --> 00:22:00.500
[Transcript missing]

00:22:01.340 --> 00:22:04.890
By being careful,
you can do some things that are in

00:22:05.100 --> 00:22:10.600
your access source that are executed
only when a user is changing something,

00:22:10.600 --> 00:22:13.930
not when EOF is fetching.

00:22:14.180 --> 00:22:15.620
Of course, you can change your behavior.

00:22:15.810 --> 00:22:19.970
You can say, oh, I don't want you to
access my field directly,

00:22:19.970 --> 00:22:25.540
or I don't want to use stored access,
or just always use key value coding

00:22:25.550 --> 00:22:28.910
and never use stored key value coding,
and then EOF is going to behave

00:22:28.910 --> 00:22:31.100
the same way that WebObjects is.

00:22:31.170 --> 00:22:35.280
Little word of warning, again,
WebObjects 5 for Java.

00:22:36.170 --> 00:22:41.230
Key value coding is,
the way we do it is we use

00:22:41.330 --> 00:22:43.300
the Objective-C runtime.

00:22:43.300 --> 00:22:47.010
So the way we do it in 4.5 is
we use the Objective-C runtime.

00:22:47.560 --> 00:22:51.100
Even if you're on Java,
we use the Objective-C runtime.

00:22:51.100 --> 00:22:55.100
That means that if you have a, you know,
private string name,

00:22:55.100 --> 00:22:58.100
who cares about the private, right?

00:22:58.100 --> 00:23:00.550
Objective-C runtime,
we just stuff the data

00:23:00.670 --> 00:23:02.970
in your private variable,
no problem.

00:23:03.350 --> 00:23:06.400
Well, we've gone pure Java.

00:23:06.420 --> 00:23:08.820
And pure Java,
that's the thing interesting,

00:23:08.820 --> 00:23:12.020
is it has this security thing,
and when you have a private thing,

00:23:12.030 --> 00:23:14.200
it's really private, you can't access it.

00:23:14.200 --> 00:23:16.180
So, and same thing for protected.

00:23:16.210 --> 00:23:21.200
If you are in a separate package and
your instance variable is protected,

00:23:21.200 --> 00:23:24.650
well, we won't be able to access it
with key value coding or stored

00:23:24.650 --> 00:23:26.190
key value coding or whatever.

00:23:26.200 --> 00:23:32.200
So, look at your EOs,
actually look at your components, too.

00:23:32.200 --> 00:23:35.190
If you have anything that's
private or protected,

00:23:35.630 --> 00:23:39.590
maybe key value coding won't
be able to access it when you

00:23:39.850 --> 00:23:42.020
converge to WebObjects 5 or Java.

00:23:42.200 --> 00:23:44.210
It's probably going to be
covered by a reason or somewhere,

00:23:44.340 --> 00:23:46.150
because it's going to be
an interesting problem.

00:23:46.240 --> 00:23:48.200
We have some solutions.

00:23:48.200 --> 00:23:49.200
You can put everything.

00:23:49.200 --> 00:23:51.200
For private, there is no solution.

00:23:51.200 --> 00:23:53.120
For private, it's private,
we can't access it.

00:23:53.210 --> 00:23:54.200
For protected, we have some solutions
that we can't access.

00:23:55.200 --> 00:23:56.200
Okay.

00:23:56.200 --> 00:24:00.040
So, we can, you know,
run some loops around

00:24:00.040 --> 00:24:04.200
and do something there,
but be aware of that.

00:24:07.350 --> 00:24:10.720
Validate, validation,
still implementing your logic,

00:24:10.980 --> 00:24:16.800
validation, validate name, or validate,
you know, first name, validate whatever,

00:24:16.810 --> 00:24:18.300
validate salary.

00:24:18.300 --> 00:24:20.300
Just implement this
method on your object,

00:24:20.300 --> 00:24:24.270
it's going to be called automatically
when a WebObject is changing.

00:24:24.340 --> 00:24:26.210
Every time,
it's going to be called automatically

00:24:26.320 --> 00:24:29.160
if WebObject is changing it,
or display group is changing it.

00:24:29.300 --> 00:24:34.300
In all other cases,
it's not going to be validated.

00:24:34.300 --> 00:24:37.300
You see this WebObjects file for Java.

00:24:37.300 --> 00:24:41.120
You notice that my validate
name is taking an object,

00:24:41.120 --> 00:24:42.300
not a string.

00:24:42.630 --> 00:24:47.210
Actually, I think that this build,
now we can put a string in there.

00:24:47.300 --> 00:24:52.300
So, I should have removed this sticker
because we actually fixed it.

00:24:52.300 --> 00:24:54.210
So, you can put string or
you can put objects,

00:24:54.360 --> 00:24:58.050
and we're going to find the method.

00:25:00.100 --> 00:25:03.000
The method ValidateForSave,
ValidateForDelete, ValidateForInsert,

00:25:03.130 --> 00:25:05.590
by default, the three of them do
exactly the same thing.

00:25:05.600 --> 00:25:08.200
They go to the model file, basically,
and check, you know,

00:25:08.200 --> 00:25:10.890
everything you check on the model file,
if it's mandatory, not mandatory,

00:25:10.890 --> 00:25:11.270
whatever.

00:25:11.400 --> 00:25:15.520
And it's also calling all
these validate methods,

00:25:15.690 --> 00:25:17.810
validate name, and whatever.

00:25:18.000 --> 00:25:20.290
You can override these
methods on your EO.

00:25:20.540 --> 00:25:25.110
If you override them, call super,
because if you don't call super,

00:25:25.110 --> 00:25:27.500
all the validation that's in your
model file is never going to happen.

00:25:27.600 --> 00:25:31.180
And don't update your objects
while you're doing a validation.

00:25:31.220 --> 00:25:34.110
You're validating something
that somebody's passing you.

00:25:34.300 --> 00:25:36.760
You're not changing your
object at that time.

00:25:36.870 --> 00:25:39.200
Changing your object is done in set name.

00:25:39.200 --> 00:25:43.140
And these three methods,
ValidateForDelete, ValidateForInsert,

00:25:43.240 --> 00:25:46.200
are called at the end of
the request-response loop.

00:25:46.200 --> 00:25:50.630
And ValidateForSave is, of course,
called every time you press the

00:25:50.650 --> 00:25:53.310
save button in your editing context.

00:25:55.930 --> 00:25:59.250
Other method you can
implement on your EO,

00:25:59.250 --> 00:26:01.640
unable to set null for key.

00:26:01.690 --> 00:26:04.160
If in your database you have
some kind of number or float,

00:26:04.180 --> 00:26:10.090
whatever, and in your EO you have a float
or a double or something that

00:26:10.230 --> 00:26:14.270
you cannot put null in it,
this method is going to

00:26:14.270 --> 00:26:15.800
be called on your EO.

00:26:15.800 --> 00:26:20.360
If this method doesn't exist,
we are going to throw an exception.

00:26:20.360 --> 00:26:22.800
In this method,
you can do the behavior you want.

00:26:22.800 --> 00:26:26.960
You can use another variable to note
that this thing is actually null.

00:26:28.280 --> 00:26:30.440
Interesting method also,
AwakeFromInsertion.

00:26:30.440 --> 00:26:33.380
It's good every time you insert
an object into an editing context.

00:26:33.380 --> 00:26:34.360
We call it AwakeFromInsertion.

00:26:34.360 --> 00:26:38.600
It's a good place to do all the
initialization for your object.

00:26:38.600 --> 00:26:40.300
And finally, AwakeFromFetch.

00:26:41.820 --> 00:26:44.300
That's when we get your
object from the database,

00:26:44.300 --> 00:26:46.260
we fetch it,
we put it into your editing context,

00:26:46.260 --> 00:26:48.630
we call a wake from fetch
when we're done with it.

00:26:48.790 --> 00:26:51.240
You can use this awake from
fetch method to set up,

00:26:51.420 --> 00:26:52.670
for example, derived value.

00:26:52.700 --> 00:26:56.060
If you have a customer object with
a first name and last name and

00:26:56.060 --> 00:26:59.700
you want a full name accessor,
in a wake from fetch,

00:26:59.700 --> 00:27:01.700
you can drill this full name.

00:27:01.700 --> 00:27:03.660
Actually, this is a bad example.

00:27:03.730 --> 00:27:04.650
I won't recommend that.

00:27:04.770 --> 00:27:07.530
I would actually do that lazily,
build a full name the first

00:27:07.570 --> 00:27:08.700
time somebody's asking for it.

00:27:08.700 --> 00:27:14.590
There is some interesting
thing you can do in there.

00:27:14.740 --> 00:27:17.650
Methods you should not override,
on the other hand,

00:27:17.770 --> 00:27:20.360
are probably willChange and willRead.

00:27:20.370 --> 00:27:25.830
willRead is used for faulting,
and willChange is used to detect that

00:27:25.830 --> 00:27:29.190
you are maybe going to change a subject.

00:27:29.520 --> 00:27:30.400
Maybe.

00:27:30.550 --> 00:27:32.000
That's not guaranteed.

00:27:32.000 --> 00:27:33.780
When will change is called,
maybe the object is not

00:27:33.780 --> 00:27:36.030
going to change after all.

00:27:36.050 --> 00:27:39.780
So if you use will change to say,
I've seen use of will change saying,

00:27:39.780 --> 00:27:42.970
"Okay, I'm going to override will change,
and every time I receive a will change,

00:27:42.970 --> 00:27:44.730
I'm going to change a
timestamp on my object,

00:27:44.730 --> 00:27:48.600
because my object is going to change,
so I want the latest timestamp." This is

00:27:48.600 --> 00:27:53.150
actually not the right place to do it,
because it's called sometimes

00:27:53.270 --> 00:27:56.150
when there is no changes at all.

00:27:57.380 --> 00:27:59.250
I should go a little faster.

00:27:59.290 --> 00:28:02.300
I'm going to run out of time there.

00:28:02.300 --> 00:28:03.430
Reaction chip management.

00:28:03.650 --> 00:28:06.320
The only one method you should
know about is addObject to both

00:28:06.400 --> 00:28:08.490
sides or ReactionChip with key.

00:28:08.910 --> 00:28:12.210
If you use anything else,
you might run into trouble

00:28:12.220 --> 00:28:14.800
because if your model changes
and you don't change your logic,

00:28:14.820 --> 00:28:17.270
you may get some kind of inconsistency.

00:28:17.350 --> 00:28:20.080
This method is the only one
that's taking care of everything.

00:28:20.140 --> 00:28:22.540
If you use this method everywhere,
you're safe.

00:28:22.540 --> 00:28:24.160
You have the relationship,
you don't have the relationship,

00:28:24.200 --> 00:28:26.600
the class properties,
not the class properties,

00:28:26.700 --> 00:28:28.940
it's going to work in all cases.

00:28:28.940 --> 00:28:32.190
So it's a long method to type,
but you have completion

00:28:32.190 --> 00:28:34.640
in Project Builder,
so that's easy.

00:28:34.640 --> 00:28:38.210
You press F2 on Windows and
Escape on Mac OS X server and

00:28:38.210 --> 00:28:40.840
it's just filling the blank.

00:28:40.840 --> 00:28:43.260
So please use this one.

00:28:47.900 --> 00:29:56.900
[Transcript missing]

00:29:57.000 --> 00:30:16.700
[Transcript missing]

00:30:17.770 --> 00:30:20.900
So that's it for the first
part of our presentation.

00:30:20.900 --> 00:30:23.900
You know,
how I see you should do a good EO.

00:30:24.100 --> 00:30:25.280
Start from the bottom.

00:30:25.510 --> 00:30:27.340
Start from the data.

00:30:27.340 --> 00:30:28.660
And build your EO model.

00:30:28.820 --> 00:30:30.420
Spend time on your EO model.

00:30:30.420 --> 00:30:31.040
Really important.

00:30:31.200 --> 00:30:32.420
Spend time on your EO model.

00:30:32.450 --> 00:30:34.200
Validate your EO model.

00:30:34.200 --> 00:30:36.460
Make sure that that is correct.

00:30:36.460 --> 00:30:40.260
Don't let your junior programmer go in
there and click on all the check boxes,

00:30:40.260 --> 00:30:42.660
because you want to see
what this thing is working.

00:30:42.660 --> 00:30:45.700
And the last thing you do
is implement your logic.

00:30:45.860 --> 00:30:47.280
You can, of course, cycle this thing.

00:30:47.280 --> 00:30:47.780
OK?

00:30:47.780 --> 00:30:48.500
It's not a rigid thing.

00:30:48.580 --> 00:30:50.730
You have to do it-- you know,
I saw Eric on stage.

00:30:50.740 --> 00:30:52.720
He told me to do this, this, and this.

00:30:52.720 --> 00:30:53.520
No.

00:30:53.520 --> 00:30:56.380
You can cycle it.

00:30:56.380 --> 00:30:59.680
Just be careful when you cycle
to keep everything in sync.

00:30:59.680 --> 00:31:04.480
And keep the thing in sync always
from the top to the bottom.

00:31:05.150 --> 00:31:09.720
There are some alternate
ways of doing this.

00:31:09.730 --> 00:31:12.060
If you are starting fresh and
writing an application and you

00:31:12.060 --> 00:31:15.510
have control over everything,
you can start from the model file

00:31:15.560 --> 00:31:19.370
and then generate a database.

00:31:20.760 --> 00:31:25.450
But personally, I still prefer to start
with the database,

00:31:25.450 --> 00:31:30.040
but that's probably a personal
preference at this point.

00:31:32.320 --> 00:31:36.360
So,
let's move on to the new features in 4.5,

00:31:36.360 --> 00:31:41.730
the thing that might cause
you trouble or might actually

00:31:41.730 --> 00:31:43.910
save your butt in some cases.

00:31:44.480 --> 00:31:47.440
First one,
we talk about subclass EO generic record.

00:31:47.440 --> 00:31:49.880
I'm going to spend more time on it.

00:31:49.890 --> 00:31:53.400
It's giving you performance
if you are in 4.5 using Java.

00:31:53.400 --> 00:31:59.350
And it's giving, it's more flexible than
the customer objects.

00:31:59.420 --> 00:32:00.500
It's less maintenance.

00:32:00.510 --> 00:32:01.400
And you ask for it.

00:32:01.400 --> 00:32:05.220
You know, raise your hands,
the one who asked for subclass,

00:32:05.310 --> 00:32:07.400
subclassable EO generic record.

00:32:08.100 --> 00:32:09.360
That's it?

00:32:09.420 --> 00:32:10.390
Why did you bother?

00:32:10.880 --> 00:32:13.400
Okay.

00:32:13.860 --> 00:32:15.600
Actually,
I think maybe there was only one person,

00:32:15.600 --> 00:32:18.510
but he was really vocal then.

00:32:21.260 --> 00:32:26.000
Important feature in 4.5:
shared editing contexts.

00:32:26.000 --> 00:32:30.160
This is your regular WebObjects
application with two editing contexts,

00:32:30.350 --> 00:32:34.510
two object graphs, as I should say,
editing contexts.

00:32:34.980 --> 00:32:39.660
And what shared editing contexts
introduce is a way to have another

00:32:39.660 --> 00:32:44.980
editing context that's in the middle
and that contains some objects

00:32:45.090 --> 00:32:50.510
that are shared by all the other
editing contexts in your application.

00:32:51.340 --> 00:32:55.520
This shared editing context
in the middle is read-only,

00:32:55.530 --> 00:32:58.200
because if you share data,
you cannot change the data.

00:32:58.200 --> 00:33:02.270
Remember that every editing context on
both sides may be running a different

00:33:02.270 --> 00:33:03.960
thread and these kind of things.

00:33:04.270 --> 00:33:05.940
So this data in the middle is read-only.

00:33:06.180 --> 00:33:08.150
No way to change it.

00:33:08.750 --> 00:33:13.660
These objects in the middle also are
only destinations of reaction chips.

00:33:13.680 --> 00:33:17.240
Because, you know,
you should have a reaction chip

00:33:17.240 --> 00:33:20.680
going outside of the shared editing
context to another editing context.

00:33:20.680 --> 00:33:24.470
Imagine that you have a reaction
chip going from this blue object

00:33:24.470 --> 00:33:26.680
there to the purple editing context.

00:33:26.760 --> 00:33:29.810
Now you're in the red editing context,
and you follow the reaction chip,

00:33:29.810 --> 00:33:31.680
and you're like "Oh,
I'm going to the blue object,

00:33:31.680 --> 00:33:34.300
and then I'm following this other
reaction chip." And you do end

00:33:34.300 --> 00:33:37.650
up having an object graph that's
spawning multiple editing contexts,

00:33:37.880 --> 00:33:38.680
and that's bad.

00:33:38.680 --> 00:33:41.040
You don't want to do that, ever.

00:33:41.490 --> 00:33:43.560
Never, never.

00:33:43.610 --> 00:33:45.590
Don't do that.

00:33:46.120 --> 00:33:48.670
If you do it,
you're going to have really big troubles

00:33:48.750 --> 00:33:50.330
and weird crashes and everything.

00:33:50.410 --> 00:33:56.110
So the idea is unique in scope change.

00:33:56.540 --> 00:34:04.960
From the EOF 2.0 to WebObjects 4.0.1,
the unique in scope

00:34:04.960 --> 00:34:08.080
was an editing context.

00:34:08.080 --> 00:34:09.400
That was the end of the story.

00:34:09.400 --> 00:34:13.740
Now, the unique in scope changes
the editing context plus its

00:34:13.740 --> 00:34:16.360
eventual shared editing context.

00:34:16.420 --> 00:34:20.710
The two together is your unique in scope.

00:34:21.040 --> 00:34:25.050
You have to be aware of it in some cases,
but really if you're

00:34:25.200 --> 00:34:26.880
doing some weird things.

00:34:27.000 --> 00:34:29.790
Usually it's fairly transparent.

00:34:30.750 --> 00:34:32.940
To put your objects into
the shared editing context,

00:34:32.940 --> 00:34:35.380
there is a checkbox in your modeler.

00:34:35.380 --> 00:34:38.940
You can check to say, oh,
this thing is shared, and that's it.

00:34:38.940 --> 00:34:42.150
And now, no matter where you fetch it,
when you fetch it,

00:34:42.300 --> 00:34:45.240
it's going to be in the shared context.

00:34:45.240 --> 00:34:47.970
And that's going to be--

00:34:48.510 --> 00:34:53.610
shared between all the editing contexts
in your application everywhere.

00:34:54.100 --> 00:34:55.410
It's good for read-only data.

00:34:55.560 --> 00:34:57.300
It's good, for example,
if you have a catalog app,

00:34:57.420 --> 00:35:00.530
you can put all your products in
there and whoever is browsing your

00:35:00.530 --> 00:35:05.890
catalog application is reusing the
same objects over and over again.

00:35:09.970 --> 00:35:13.640
Third interesting feature:
snapshot ref counting.

00:35:13.660 --> 00:35:17.940
We talked about it yesterday also.

00:35:17.970 --> 00:35:19.880
You fetch an object
in an editing context,

00:35:19.880 --> 00:35:22.900
we create a snapshot down there.

00:35:22.930 --> 00:35:27.040
Now you fetch an object in
another editing context,

00:35:27.040 --> 00:35:29.480
we now ref count this snapshot.

00:35:29.490 --> 00:35:32.420
And when the two objects
are gone from memory,

00:35:32.460 --> 00:35:34.660
the snapshot is gone too.

00:35:34.990 --> 00:35:36.430
It's just really simple.

00:35:36.450 --> 00:35:39.310
That's a feature you always
thought was already in EOF,

00:35:39.440 --> 00:35:39.840
right?

00:35:39.900 --> 00:35:43.900
So, now it is.

00:35:44.650 --> 00:35:48.710
I'll help you reduce memory footprint,
help you snapshot freshness,

00:35:48.710 --> 00:35:51.150
because if nobody's using any memory,
it's gone.

00:35:51.270 --> 00:35:54.320
So next time you need it,
you're going to refresh it,

00:35:54.320 --> 00:35:56.180
so it's going to be fresher.

00:35:57.920 --> 00:36:03.280
A couple of little gotchas with this
feature that are actually interesting.

00:36:03.280 --> 00:36:08.230
If you used to use global ID,
actually these gotchas,

00:36:08.250 --> 00:36:09.620
this one applies only to Objective-C.

00:36:09.620 --> 00:36:14.430
If you used to use your global
ID all the way around and passing

00:36:14.430 --> 00:36:18.650
global ID to move an object from
one editing context to another,

00:36:18.650 --> 00:36:21.310
look at your code and
make sure you retain it,

00:36:21.420 --> 00:36:23.520
because now global IDs are going away.

00:36:23.520 --> 00:36:27.140
Before they were never going away,
but now they are.

00:36:27.140 --> 00:36:31.270
I'm pointing this thing because
actually we had the problem

00:36:31.390 --> 00:36:33.240
in our example framework.

00:36:33.240 --> 00:36:37.650
In the movie example,
if you diff the 401 and the 405,

00:36:37.650 --> 00:36:39.750
you're going to see the bug.

00:36:40.170 --> 00:36:41.420
So be careful with that.

00:36:41.440 --> 00:36:45.030
And if your application assumes that
because you fetch an object once,

00:36:45.030 --> 00:36:49.040
you have the snapshot down there,
that's not true anymore.

00:36:49.050 --> 00:36:51.210
I don't think you should make
assumptions like that anywhere.

00:36:51.220 --> 00:36:58.400
But if you do,
be careful when you move to 4.5.

00:36:59.380 --> 00:37:04.540
Next feature is actually
the hardest to explain.

00:37:04.910 --> 00:37:09.090
It's a simple concept,
but it's difficult to explain.

00:37:09.280 --> 00:37:14.030
So the yellow arrow up there
at the top is a timeline going

00:37:14.110 --> 00:37:16.200
from the past to the future.

00:37:16.200 --> 00:37:20.080
Let's say I'm creating
an editing context.

00:37:20.080 --> 00:37:22.490
So in my timeline,
I have this proper editing

00:37:22.500 --> 00:37:26.280
context created there.

00:37:26.980 --> 00:37:30.180
I fetch an object into
this editing context.

00:37:30.180 --> 00:37:34.110
At the time of the fetch,
EO Access is putting a

00:37:34.110 --> 00:37:37.880
timestamp on this snapshot,
saying, "Hey,

00:37:37.880 --> 00:37:43.430
have we seen this snapshot from the
database at that time?" And mark it,

00:37:43.440 --> 00:37:45.330
remember it.

00:37:45.550 --> 00:37:51.730
Now you create a second editing
context and fetch an object into it.

00:37:53.070 --> 00:37:57.890
So every editing context has a lag time.

00:37:57.990 --> 00:38:03.800
What we mean by lag time,
the time of the creation of the

00:38:03.800 --> 00:38:09.440
editing context minus its lag
time give us an absolute date.

00:38:09.440 --> 00:38:12.460
And from this absolute date,
we determine if we can

00:38:12.460 --> 00:38:13.970
use a snapshot or not.

00:38:14.020 --> 00:38:17.460
If the snapshot we have in memory
is after this absolute date,

00:38:17.530 --> 00:38:18.960
we are going to use it.

00:38:18.990 --> 00:38:21.670
If the snapshot we have
in memory is before,

00:38:21.690 --> 00:38:26.000
we just are going to trash this
snapshot and fetch the object again.

00:38:26.160 --> 00:38:29.150
So here you can see
that after this fetch,

00:38:29.240 --> 00:38:33.790
I snapshot at that time on the timeline,
and then I created the

00:38:33.950 --> 00:38:35.810
second editing context.

00:38:36.160 --> 00:38:41.020
And the date that's giving me the
absolute time is the date of the

00:38:41.020 --> 00:38:44.000
creation of the editing context.

00:38:44.220 --> 00:38:48.000
And in that case,
we see that this object there is fine.

00:38:48.000 --> 00:38:53.000
It's in my time lag,
so I'm going to reuse the snapshot.

00:38:53.000 --> 00:38:57.570
Now if I create a third
editing context here,

00:38:58.310 --> 00:39:01.580
You see the timeline again,
and the lag time,

00:39:01.670 --> 00:39:04.960
and you see that the object
is not in the lag time.

00:39:04.960 --> 00:39:07.140
So in that case,
in this shared editing context,

00:39:07.260 --> 00:39:10.350
if I fetch the object,
I'm going to actually

00:39:10.610 --> 00:39:13.200
refetch from the database,
update the snapshot,

00:39:13.210 --> 00:39:16.280
and of course send the
notification saying,

00:39:16.280 --> 00:39:19.810
"Object change in store," and
update the object everywhere

00:39:19.920 --> 00:39:21.200
if the snapshot changes.

00:39:21.200 --> 00:39:25.240
And re-put a new
timestamp on this object,

00:39:25.300 --> 00:39:28.180
on this snapshot,
so next time another editing

00:39:28.180 --> 00:39:31.200
context is going to need it,
it's going to be there.

00:39:31.200 --> 00:39:33.200
So what does that mean?

00:39:33.430 --> 00:39:36.060
That means that every time you
create a new editing context,

00:39:36.060 --> 00:39:40.200
you have the potential to refetch
some objects from the database,

00:39:40.230 --> 00:39:43.190
because your editing
context was created later.

00:39:43.390 --> 00:39:46.040
So you can control the
freshness of the data.

00:39:46.110 --> 00:39:52.410
The shorter the lag time you
use for your editing context,

00:39:52.420 --> 00:39:57.950
the shorter lifespan your
snapshots are going to have.

00:39:58.320 --> 00:40:00.200
That means that if you
don't use the objects,

00:40:00.200 --> 00:40:04.660
if you don't fetch these
objects really often,

00:40:04.660 --> 00:40:10.360
you are not going to update
and generate all this freshness

00:40:10.360 --> 00:40:13.230
update all over the place.

00:40:14.110 --> 00:40:16.860
We are going to fetch from the
database only if you need it.

00:40:16.980 --> 00:40:19.860
And we are going to
refresh only if you know,

00:40:19.860 --> 00:40:23.360
we know that when you're editing,
your editing context knows it.

00:40:23.480 --> 00:40:25.190
And, um,

00:40:25.820 --> 00:40:28.300
It's also an easy way
to get updated data.

00:40:28.300 --> 00:40:33.200
You want to update a certain graph
of objects in your application.

00:40:33.230 --> 00:40:34.520
Well, that's really easy.

00:40:34.520 --> 00:40:36.460
You create an editing context.

00:40:36.460 --> 00:40:39.680
You set its fetch timestamp to now.

00:40:39.690 --> 00:40:42.700
So you remove all the lag.

00:40:42.710 --> 00:40:43.690
So you create an editing context.

00:40:43.780 --> 00:40:44.610
You remove all the lag.

00:40:44.700 --> 00:40:45.980
You say, we fetch everything now.

00:40:46.000 --> 00:40:49.770
And you fetch the object
graph you want to fetch.

00:40:50.150 --> 00:40:52.870
That's going to mean that you are going
to update the snapshots at the bottom

00:40:52.970 --> 00:40:56.000
for every single object that you're
fetching this new editing context.

00:40:56.130 --> 00:40:59.780
And at the same time,
refresh things in all your

00:40:59.780 --> 00:41:02.000
other editing contexts.

00:41:02.000 --> 00:41:07.330
So you can use this instead of
fetch specification with the

00:41:07.560 --> 00:41:10.990
refreshing objects and all that.

00:41:11.270 --> 00:41:15.000
That's actually another way to perform
the same task that I think is...

00:41:16.780 --> 00:41:21.810
It's actually a little cleaner,
but it's possible only with 4.5.

00:41:31.740 --> 00:41:32.570
Still following?

00:41:32.630 --> 00:41:33.560
Nobody's sleeping yet?

00:41:33.610 --> 00:41:34.520
Fine.

00:41:34.520 --> 00:41:38.510
Deferred faulting.

00:41:39.110 --> 00:41:40.380
Another 4.5 feature.

00:41:40.390 --> 00:41:44.400
This is a pre-4.5 application.

00:41:44.760 --> 00:41:47.600
You're fetching a bunch of objects.

00:41:47.600 --> 00:41:48.990
And what does happen
when you fetch an object?

00:41:48.990 --> 00:41:52.540
You fetch the object,
and then for every relationship

00:41:52.630 --> 00:41:54.800
around this object,
we're creating a fault.

00:41:54.900 --> 00:41:59.030
Either a two-and fault,
like I have in my little graphic there,

00:41:59.030 --> 00:42:00.630
or a too-many fault.

00:42:01.200 --> 00:42:05.280
So that means that for,
if your entity has something like,

00:42:05.290 --> 00:42:09.650
you know, 10 reaction chips,
and you fetch 50 objects, well,

00:42:09.650 --> 00:42:13.620
you are going to create these 50 objects,
and you are going to create

00:42:13.620 --> 00:42:16.660
another 500 objects around them.

00:42:16.660 --> 00:42:17.660
All right.

00:42:17.660 --> 00:42:23.810
So fetch performance is impacted
by these kind of things.

00:42:23.860 --> 00:42:26.690
It's usually fine, but we have...

00:42:28.830 --> 00:42:32.120
To help the performance,
it's actually a really good feature.

00:42:32.190 --> 00:42:36.180
Of course, it's a trade-off.

00:42:36.600 --> 00:42:38.320
If we don't do that,
that means that we don't

00:42:38.440 --> 00:42:41.210
have the transparency of,
do you just follow a pointer

00:42:41.630 --> 00:42:43.920
and get information that's
at the end of the pointer and

00:42:43.920 --> 00:42:45.500
having the fault firing for you?

00:42:45.500 --> 00:42:47.490
You would have to do, actually,
something.

00:42:47.500 --> 00:42:50.500
So what's deferred faulting?

00:42:50.630 --> 00:42:54.390
Deferred faulting says,
when you fetch an object and

00:42:54.390 --> 00:42:57.880
there is ten reaction chips,
we are going to create one

00:42:57.880 --> 00:42:59.390
object per reaction chip.

00:42:59.490 --> 00:43:00.500
No more.

00:43:00.500 --> 00:43:03.040
So if you fetch,
if I take my example again,

00:43:03.300 --> 00:43:06.430
you have ten reaction chips
and you fetch fifty objects,

00:43:06.510 --> 00:43:08.630
you are going to create
your fifty objects,

00:43:08.630 --> 00:43:12.470
but you are only going to create
ten objects for your reaction chips.

00:43:12.690 --> 00:43:16.110
And we are going to make
every single EO that you fetch

00:43:16.110 --> 00:43:18.500
point to these shared objects.

00:43:18.620 --> 00:43:21.500
We call this shared
object deferred fault.

00:43:21.500 --> 00:43:23.500
These objects are actually not faults.

00:43:23.500 --> 00:43:27.490
They are just a way to get a fault later.

00:43:28.250 --> 00:43:33.880
And how does that work is when you need
the destination of the relationship,

00:43:33.880 --> 00:43:37.580
before following the pointer,
you ask this deferred fault,

00:43:37.580 --> 00:43:39.320
"Give me my real fault.

00:43:39.320 --> 00:43:42.820
Give me the thing I should have
got when I fetched." And we have

00:43:42.840 --> 00:43:46.100
a new method to do that that's
named WillReadReactionShip,

00:43:46.100 --> 00:43:52.180
and you pass yourself as an argument
and you send that to the deferred fault,

00:43:52.180 --> 00:43:54.750
and you get the real fault.

00:43:56.250 --> 00:43:58.400
This feature is optional.

00:43:58.400 --> 00:44:00.560
You don't have to implement it.

00:44:00.770 --> 00:44:03.200
It's giving you big advantages.

00:44:03.200 --> 00:44:07.520
It's giving you faster fetches,
and it's less memory usage

00:44:07.730 --> 00:44:11.110
because you don't create all
these objects all over the place.

00:44:11.200 --> 00:44:19.170
And the only method you should know to
work with this is read-read relationship.

00:44:20.080 --> 00:44:22.590
When I say it's optional,
it's actually optional

00:44:22.590 --> 00:44:24.620
unless you use EOG.

00:44:24.780 --> 00:44:28.560
If you subclass EOG,
EOG is using deferred

00:44:28.560 --> 00:44:30.040
faulting all over the place.

00:44:30.120 --> 00:44:33.840
But it's completely transparent for you
because you don't have instance variable.

00:44:33.840 --> 00:44:36.820
You just access the dictionary
of stored key value coding.

00:44:36.890 --> 00:44:41.780
And stored key value coding on
EOG knows how to do these things.

00:44:41.930 --> 00:44:45.790
So it's completely transparent for you.

00:44:47.520 --> 00:44:54.500
Another interesting side effect
of this feature is inheritance.

00:44:54.680 --> 00:44:58.690
Remember inheritance,
when you're pointing,

00:44:58.690 --> 00:45:01.820
when you're in Objective-C and
you have a relationship to the

00:45:01.820 --> 00:45:04.500
top of an inheritance tree there.

00:45:04.640 --> 00:45:06.910
When we fetch your object,
we create your relationship,

00:45:06.980 --> 00:45:09.060
but we don't know what kind
of object is going to be at

00:45:09.140 --> 00:45:10.470
the end of our relationship.

00:45:10.650 --> 00:45:14.290
It could be the top of an
inheritance tree or anything below,

00:45:14.630 --> 00:45:16.500
any kind of object.

00:45:16.500 --> 00:45:18.870
So the way we do that in
Objective-C is saying,

00:45:18.870 --> 00:45:21.500
"Hey, we don't know which
object is going to be,

00:45:21.500 --> 00:45:28.220
so we're going to look at this
hierarchy and create the largest piece

00:45:28.250 --> 00:45:32.500
of memory that could fit one of these
objects and allocate this thing there."

00:45:32.650 --> 00:45:36.820
And then when we fire the fault,
we are going to play some tricks

00:45:36.820 --> 00:45:41.290
with the Objective-C runtime,
changing the ISA pointer to point

00:45:41.290 --> 00:45:45.500
to the right class and doing
some insane things in there.

00:45:45.500 --> 00:45:47.290
And then we're going to
actually get rid of all of that,

00:45:47.390 --> 00:45:49.220
because default faulting,
you have a default fault,

00:45:49.220 --> 00:45:50.500
you don't have the real object.

00:45:50.640 --> 00:45:53.370
So that means that when
you're firing the fault,

00:45:53.640 --> 00:45:56.450
what we do if there is
any inheritance involved,

00:45:56.520 --> 00:45:59.000
we are going to go fetch from the
database the information and get

00:45:59.000 --> 00:46:01.500
the role before creating the object.

00:46:01.500 --> 00:46:05.500
So we know what objects
we need to create.

00:46:05.500 --> 00:46:08.730
And the trick we are playing
in Objective-C is actually

00:46:08.730 --> 00:46:10.500
not working at all in Java.

00:46:10.500 --> 00:46:14.500
In Java, you just say object, new object,
and that's the end of it.

00:46:14.500 --> 00:46:21.500
There's no way to change the ISA pointer
and do all this magic that we used to do.

00:46:21.500 --> 00:46:26.450
So the only way in pure Java that
inheritance is going to work,

00:46:26.450 --> 00:46:30.500
this way, via default faulting.

00:46:36.160 --> 00:46:40.040
Another 4.5 feature,
database reconnection.

00:46:40.040 --> 00:46:43.840
In 4.5, if you lose your
connection to the database,

00:46:43.840 --> 00:46:47.070
we're going to try to
reconnect automatically.

00:46:47.090 --> 00:46:51.380
A number of you asked for this thing.

00:46:51.380 --> 00:46:53.030
You can change the behavior.

00:46:53.030 --> 00:46:55.220
We have two delegates that you can use.

00:46:55.220 --> 00:47:00.080
You can, if there is, if we try,
if we lose a connection to the database,

00:47:00.230 --> 00:47:03.410
before we try to reconnect,
we ask you some questions saying, "Hey,

00:47:03.410 --> 00:47:05.410
should I try to reconnect
to the same database,

00:47:05.410 --> 00:47:08.030
to another database,
or do you want to handle the

00:47:08.110 --> 00:47:10.270
reconnection by yourself?"

00:47:10.790 --> 00:47:16.160
One thing you need to know is all
these things assume that you're

00:47:16.160 --> 00:47:17.550
connecting to the same database.

00:47:17.780 --> 00:47:20.700
That means that we are not
throwing away any snapshots.

00:47:20.700 --> 00:47:23.700
So if you're connecting
to a different database,

00:47:23.700 --> 00:47:26.520
it's your responsibility to make
sure that your snapshots match

00:47:26.670 --> 00:47:30.120
what are in the database so you
don't have optimistic locking

00:47:30.660 --> 00:47:33.290
failure when you shouldn't have one.

00:47:37.330 --> 00:47:43.230
We change the behavior of missing faults,
coming back to how do

00:47:43.230 --> 00:47:45.380
you create an object.

00:47:45.450 --> 00:47:47.840
You fetch an object,
and you have a fault to this.

00:47:47.940 --> 00:47:49.110
It's only for 2.1.

00:47:49.380 --> 00:47:52.600
You have a relationship
to another object,

00:47:52.840 --> 00:47:55.900
and this object, when you fetch,
you have a foreign key for it.

00:47:55.970 --> 00:47:58.220
So you are going to create--
we can create a global ID,

00:47:58.380 --> 00:48:00.410
create this thing, and say, OK,
we need this object later.

00:48:00.730 --> 00:48:01.580
Here it is.

00:48:01.740 --> 00:48:03.270
And then you touch this subject.

00:48:03.390 --> 00:48:05.820
You go to the database,
and this object's not there.

00:48:05.880 --> 00:48:07.160
Oops.

00:48:08.380 --> 00:48:14.400
What happened in 4.0 and before
was we just gave up and said,

00:48:14.400 --> 00:48:16.130
"Oh, you don't have these
objects in the database.

00:48:16.170 --> 00:48:17.970
Your database isn't consistent.

00:48:18.280 --> 00:48:18.600
Too bad.

00:48:18.760 --> 00:48:20.710
Let's throw an exception."

00:48:21.080 --> 00:48:23.740
Problem with this exception,
it was thrown all over the place.

00:48:23.860 --> 00:48:25.210
You don't know where to cache it.

00:48:25.300 --> 00:48:27.990
It could be while following
something in your business logic.

00:48:28.000 --> 00:48:31.930
It could be while following a
dot notation inside WebObjects,

00:48:32.080 --> 00:48:34.310
some kind of bindings.

00:48:34.390 --> 00:48:36.190
It was actually thrown
all over the place.

00:48:36.340 --> 00:48:39.170
It was really, really hard to cache.

00:48:40.880 --> 00:48:44.100
So in 4.5,
we are not sending an exception

00:48:44.100 --> 00:48:45.990
when we discover these problems.

00:48:46.070 --> 00:48:48.760
We are just noting that
there is a problem,

00:48:49.100 --> 00:48:53.020
and we send you an empty object.

00:48:53.300 --> 00:48:55.560
The exception is going
to be thrown on save.

00:48:55.560 --> 00:48:58.460
If you try to save and don't
do anything about this object,

00:48:58.600 --> 00:49:01.760
you're going to get an exception saying,
"Hey, you're trying to save something,

00:49:01.760 --> 00:49:04.580
but your database was
inconsistent in the first place,

00:49:04.580 --> 00:49:07.960
so deal with it." And you can,
at this point,

00:49:07.960 --> 00:49:11.750
insert this new object and do everything.

00:49:12.640 --> 00:49:14.500
You can use a delegate
to control the behavior.

00:49:14.500 --> 00:49:16.500
Why did I put an S at delegate?

00:49:16.500 --> 00:49:19.580
It's the only one delegate you
need to know for this is database

00:49:19.670 --> 00:49:21.500
context fail to fetch object.

00:49:21.620 --> 00:49:24.930
If you want the previous behavior,
you can just throw an exception

00:49:24.930 --> 00:49:26.500
in there and that's it.

00:49:26.500 --> 00:49:27.500
You have the previous behavior.

00:49:27.500 --> 00:49:31.340
Or in this method, you can actually deal
with the problem and say,

00:49:31.500 --> 00:49:33.500
oh, yeah, I'm missing this object.

00:49:33.500 --> 00:49:37.500
Let me go insert it into the database,
refetch it, and do all that,

00:49:37.500 --> 00:49:40.520
and that's going to be fine.

00:49:42.840 --> 00:49:45.460
4.5 feature, another one that's good.

00:49:45.460 --> 00:49:47.600
This one, I love it.

00:49:47.600 --> 00:49:51.290
On your adapter, your adapter context,
your database context,

00:49:51.290 --> 00:49:54.470
you can call a method
that's set default delegate.

00:49:54.540 --> 00:49:56.900
It's a class method.

00:49:56.900 --> 00:49:58.980
You call this once and
you'll be done with it.

00:49:58.980 --> 00:50:02.170
You don't have to go phishing,
tracking all the exit,

00:50:02.220 --> 00:50:05.900
or also notification, "Hey,
I have created a new channel.

00:50:05.900 --> 00:50:10.010
Oh, geez, I need to be the delegate of
this thing." Just one place and

00:50:10.060 --> 00:50:11.110
you're the delegate of everything.

00:50:12.140 --> 00:50:12.940
Yeah.

00:50:12.940 --> 00:50:15.900
I don't know why we
didn't do that before.

00:50:16.090 --> 00:50:20.070
Just... probably two hours
when I'm playing around

00:50:20.160 --> 00:50:21.030
with this thing everywhere.

00:50:21.150 --> 00:50:26.370
And it's just... it's a lifesaver.

00:50:27.600 --> 00:50:31.250
Another 4.5 feature, LDAP adapter.

00:50:31.470 --> 00:50:33.100
A lot of requests for LDAP adapter.

00:50:33.100 --> 00:50:34.750
I think, hey, we want to access LDAP.

00:50:34.820 --> 00:50:36.180
We want to validate our user.

00:50:36.180 --> 00:50:38.500
We want to, you know,
to have all these things.

00:50:38.650 --> 00:50:41.700
So now we have an LDAP adapter.

00:50:42.130 --> 00:50:47.380
Interesting feature,
the LDAP adapters can read, update,

00:50:47.380 --> 00:50:48.400
delete.

00:50:48.440 --> 00:50:49.000
It's an adapter.

00:50:49.000 --> 00:50:53.000
It's working like any
other EO adapter in EOF.

00:50:53.000 --> 00:50:56.960
The interesting thing is you don't
need a model file to do authentication.

00:50:56.990 --> 00:50:59.990
You don't need to build a
big model file to do that.

00:51:00.000 --> 00:51:02.000
Authentication is actually
a really simple protocol.

00:51:02.140 --> 00:51:05.400
The LDAP adapter has a static
method that's authenticate user,

00:51:05.410 --> 00:51:09.870
and you pass its username, the password,
and the information about, you know,

00:51:10.050 --> 00:51:14.500
all the LDAP thingy there.

00:51:14.500 --> 00:51:14.510
What subtree, what, you know.

00:51:14.890 --> 00:51:20.060
And this thing is returning...
What is this thing returning?

00:51:20.130 --> 00:51:21.100
Probably returning a Boolean.

00:51:21.290 --> 00:51:22.100
Yes, no.

00:51:22.100 --> 00:51:22.800
Is it true?

00:51:22.800 --> 00:51:23.800
Is it false?

00:51:23.960 --> 00:51:26.800
Can you... Is this
user legitimate or not?

00:51:26.800 --> 00:51:29.970
So, the thing interesting is this is
an interesting feature because

00:51:30.140 --> 00:51:33.800
it's really lightweight and you
don't need a Neo model for it.

00:51:33.800 --> 00:51:38.030
And that's the most common
use of the YieldApp adapter.

00:51:39.500 --> 00:51:41.620
So here we go.

00:51:41.630 --> 00:51:46.690
List of all the five
features I went over.

00:51:47.630 --> 00:51:48.600
I don't think it's complete.

00:51:48.600 --> 00:51:51.040
It's probably missing a couple,
but these are the most

00:51:51.160 --> 00:51:54.600
important ones in EOF.

00:51:54.600 --> 00:52:00.460
That's a...

00:52:04.760 --> 00:52:11.250
I want to, before I finish this thing,
I want to stress one thing that I've

00:52:11.250 --> 00:52:14.640
seen done over and over and over again.

00:52:14.640 --> 00:52:18.580
And I'd like to

00:52:20.870 --> 00:52:26.430
I don't know, try to influence you in not
doing these things again.

00:52:26.730 --> 00:52:33.200
I've seen a lot of our customers
trying to force EOF to work in the

00:52:33.540 --> 00:52:38.660
way they think EOF should work.

00:52:38.870 --> 00:52:43.110
And it's, you know, you think, oh,
EOF should work this way, so, you know,

00:52:43.130 --> 00:52:46.160
no, EOF is working this way,
so I'm writing my code thinking

00:52:46.160 --> 00:52:49.100
that EOF is working this way,
and then I come to the conclusion,

00:52:49.100 --> 00:52:52.140
after a while, I say, hey,
this is not working like this at all.

00:52:52.140 --> 00:52:54.540
Oh, Jesus, it was working this other way.

00:52:54.540 --> 00:53:00.770
And instead of trying to fit with EOF,
what you're trying to do is, you know,

00:53:00.810 --> 00:53:05.830
coerce EOF into coming there and
work the way I want it to work,

00:53:05.830 --> 00:53:07.570
damn it, you know.

00:53:07.570 --> 00:53:08.490
Eric Noyau

00:53:10.330 --> 00:53:15.700
After that, a couple of months later,
I sit in my office.

00:53:15.700 --> 00:53:17.970
I receive an email from
support telling me,

00:53:17.970 --> 00:53:22.540
"I have this weird bug and I don't
understand it." I look at the bug,

00:53:22.540 --> 00:53:26.060
can't reproduce it, don't know anything,
and then they say,

00:53:26.060 --> 00:53:29.900
"Send me an example." Well,
it's the whole customer application,

00:53:29.900 --> 00:53:33.000
it's 20 meg of stuff,
and you do end up trying to

00:53:33.000 --> 00:53:37.540
find to reproduce this thing,
and you do end up finding that it's

00:53:37.540 --> 00:53:43.590
because you try to coerce this thing into
working the way you think it should work

00:53:43.810 --> 00:53:46.930
and not try to use it the way it worked.

00:53:46.930 --> 00:53:50.980
By doing that,
you're going to introduce bugs and it's

00:53:50.980 --> 00:53:56.420
going to be impossible for us to fix
them because it's actually in your code.

00:53:56.420 --> 00:54:00.130
So message, work with EOF,
not against it.

00:54:00.130 --> 00:54:04.820
Just try to understand how
you can use it the way it is

00:54:04.820 --> 00:54:06.700
working and try to play with EOF.

00:54:06.700 --> 00:54:09.540
There is a lot of room to play with EOF.

00:54:09.540 --> 00:54:12.470
We have delegates everywhere.

00:54:12.470 --> 00:54:16.540
We have a lot of ropes that
you can hang yourself with.

00:54:16.540 --> 00:54:19.740
You don't need to do your
stuff to hang yourself with.

00:54:19.740 --> 00:54:22.540
You can just use EOF the way
it was intended to be and

00:54:22.960 --> 00:54:25.540
you can eat yourself with it.

00:54:25.540 --> 00:54:28.460
So take that as a message.

00:54:28.460 --> 00:54:30.140
Please try to work with it.

00:54:30.180 --> 00:54:32.540
Try to understand how EOF is working.

00:54:32.540 --> 00:54:33.540
EOF is really powerful.

00:54:33.540 --> 00:54:34.150
There was a lot of features.

00:54:34.200 --> 00:54:34.200
There was a lot of features.

00:54:34.200 --> 00:54:36.960
There was a lot of features in it.

00:54:37.070 --> 00:54:41.200
If you think there is something
that EOF is not doing,

00:54:41.200 --> 00:54:43.200
well, talk to somebody else.

00:54:43.200 --> 00:54:45.200
Maybe he's going to tell
you a different view.

00:54:45.200 --> 00:54:48.500
There is always ten
ways of doing something.

00:54:48.500 --> 00:54:49.960
And there is these ten ways.

00:54:49.960 --> 00:54:54.200
There is three that are going to work
well with EOF and there is seven that

00:54:54.200 --> 00:54:56.380
are not going to work well with EOF.

00:54:56.380 --> 00:55:01.380
Try to use the three that
are going to work with EOF.

00:55:01.380 --> 00:55:03.410
And that's it.
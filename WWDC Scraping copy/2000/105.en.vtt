WEBVTT

00:00:12.410 --> 00:00:15.020
Ladies and gentlemen,
please welcome the Director of

00:00:15.090 --> 00:00:19.650
Graphics and Imaging for Mac OS X,
Peter Graffagnino.

00:00:25.780 --> 00:00:26.400
Hi, everybody.

00:00:26.400 --> 00:00:29.220
Welcome to WWDC.

00:00:29.400 --> 00:00:31.100
My name is Peter Graffagnino.

00:00:31.150 --> 00:00:34.110
I'm the Director of Graphics
and Imaging at Apple Computer,

00:00:34.280 --> 00:00:37.330
and I'll be talking about some of
the technologies we're putting in

00:00:37.430 --> 00:00:42.780
Mac OS X at the graphics services layer
for all of you to take advantage of.

00:00:43.210 --> 00:00:46.190
Basically, we're going to overview
a bunch of technologies.

00:00:46.380 --> 00:00:47.440
Some of these are new.

00:00:47.450 --> 00:00:50.450
Some of these we're talking
about for the first time here.

00:00:50.870 --> 00:00:52.860
Some of these should be very familiar.

00:00:52.970 --> 00:00:54.130
And we're going to have lots of demos.

00:00:54.200 --> 00:00:57.810
We're going to have Ralph Brunner
come up on stage and run us through

00:00:57.810 --> 00:00:59.670
a whole bunch of demos for you.

00:01:01.210 --> 00:01:04.710
So let me go to the architecture slide,
which you've probably seen

00:01:04.710 --> 00:01:10.140
in every presentation so far,
which is the basic layer diagram of OS X.

00:01:10.240 --> 00:01:13.850
At the lowest level,
we have the core operating system,

00:01:13.950 --> 00:01:18.500
and we have core services above that,
application services layer where

00:01:18.510 --> 00:01:22.980
most of our technology lives,
and then frameworks on top of that.

00:01:23.990 --> 00:01:28.660
I'll be centering mostly my
talk on this area right here.

00:01:28.660 --> 00:01:32.440
We have a lot of great technology
for you that we've built into

00:01:32.440 --> 00:01:34.900
the graphics system in OS X.

00:01:34.900 --> 00:01:38.900
Based on industry standards as
well as some Apple innovations,

00:01:38.900 --> 00:01:42.810
we have 2D for PDF and PostScript.

00:01:42.880 --> 00:01:45.990
We have 3D with OpenGL.

00:01:46.340 --> 00:01:49.410
We have Apple innovations
such as ColorSync,

00:01:49.410 --> 00:01:51.900
Quartz, TrueType, QuickTime.

00:01:51.900 --> 00:01:56.390
You combine all of that with an
industrial strength operating system

00:01:56.390 --> 00:02:01.480
underneath based on Mac and BSD and some
pretty great frameworks above Carbon,

00:02:01.640 --> 00:02:02.900
Quartz, Java.

00:02:03.030 --> 00:02:06.730
And you really have a great platform
for innovation for the future.

00:02:06.900 --> 00:02:10.040
And we're pretty excited about
all the ideas we have internally.

00:02:10.040 --> 00:02:12.450
And hopefully you guys will be
able to generate a lot of cool

00:02:12.480 --> 00:02:13.810
ideas too about what you can do.

00:02:13.940 --> 00:02:21.110
Let me touch on the graphics
block diagram a little.

00:02:22.680 --> 00:02:26.360
Mac OS X is a layered system,
and even within our

00:02:26.360 --> 00:02:31.400
graphic services layer,
we have divided into little sub-layers.

00:02:31.560 --> 00:02:36.100
We have at the bottom what we
call Core Graphics Services,

00:02:36.140 --> 00:02:39.550
which is the Windows server that's
the central repository of global

00:02:39.550 --> 00:02:42.550
information for the computer,
the Windows database,

00:02:42.570 --> 00:02:43.530
those sorts of things.

00:02:43.600 --> 00:02:47.520
On top of that,
we have a variety of drawing frameworks

00:02:47.520 --> 00:02:50.540
that are linked into your application.

00:02:50.680 --> 00:02:53.600
We have the new framework,
the Core Graphics 2D rendering.

00:02:53.600 --> 00:02:56.610
We have QuickDraw,
which you're all familiar

00:02:56.760 --> 00:02:57.590
with from Carbon.

00:02:57.600 --> 00:03:01.600
We have QuickTime for media handling,
and OpenGL for 3D.

00:03:01.600 --> 00:03:04.600
So those libraries link
into your application.

00:03:04.600 --> 00:03:10.470
The Core Graphics Services server handles
the coordination among all the apps.

00:03:11.900 --> 00:03:16.960
So to give kind of a full list
of all the technologies that

00:03:17.050 --> 00:03:19.630
I'll be talking about today,
with the exception of

00:03:19.720 --> 00:03:22.170
QuickTime at the bottom there,
we have Quartz,

00:03:22.210 --> 00:03:24.700
which is the new technology,
the Core Graphic

00:03:24.700 --> 00:03:28.580
Services windowing system,
as well as the 2D rendering library.

00:03:28.650 --> 00:03:31.380
We have QuickDraw,
which you're all familiar

00:03:31.380 --> 00:03:32.670
with from Carbon.

00:03:32.760 --> 00:03:35.560
We have ColorSync,
our color management technology.

00:03:35.600 --> 00:03:39.500
Mac OS X printing,
I'll be talking about that.

00:03:39.530 --> 00:03:40.990
OpenGL for 3D.

00:03:41.310 --> 00:03:44.270
ImageCapture,
which is a new framework you

00:03:44.270 --> 00:03:51.650
saw demoed in Bertrand's talk,
which is for 2D still image acquisition.

00:03:51.750 --> 00:03:54.140
And QuickTime,
which there are a bunch of sessions

00:03:54.270 --> 00:03:57.620
on elsewhere in the conference,
but I won't be covering here.

00:03:59.200 --> 00:04:01.240
So the first thing I'm going
to talk about is the core

00:04:01.250 --> 00:04:04.470
graphics services layer,
which is that bottom substrate that

00:04:04.470 --> 00:04:11.100
kind of sits below all of the 2D and 3D
and media that happens on the display.

00:04:11.100 --> 00:04:15.930
It's a client-server windowing system,
not unlike DisplayPostScript or XWindows,

00:04:15.930 --> 00:04:19.040
if you're familiar with
any of those technologies.

00:04:19.120 --> 00:04:21.430
And it's really responsible
for the low-level window

00:04:21.480 --> 00:04:23.010
system programming interface.

00:04:23.100 --> 00:04:28.130
The Carbon Window Manager and
the Cocoa Window Object are

00:04:28.410 --> 00:04:31.580
clients of this API,
and when you make calls to

00:04:31.580 --> 00:04:34.730
those in your applications,
it turns around and calls the

00:04:34.730 --> 00:04:38.090
server to allocate a window,
destroy a window, or what have you.

00:04:38.100 --> 00:04:41.560
The server is also
responsible for event routing,

00:04:41.560 --> 00:04:46.220
making sure the event stream gets
to the correct application based on

00:04:46.220 --> 00:04:49.100
focus and what they're interested in.

00:04:49.100 --> 00:04:51.100
And also basic real estate management.

00:04:51.140 --> 00:04:52.100
And that's really important.

00:04:52.150 --> 00:04:53.100
Thank you.

00:04:53.100 --> 00:04:57.530
in terms of getting everyone to
share the display cooperatively.

00:04:59.340 --> 00:05:01.700
some of the key innovations
in the Core Graphics Services.

00:05:01.700 --> 00:05:07.010
Some of this stuff we haven't
been able to talk about before

00:05:07.010 --> 00:05:11.010
because we were waiting for the
Aqua user interface to come out,

00:05:11.150 --> 00:05:13.590
but we've been working on this
stuff for a couple of years,

00:05:13.690 --> 00:05:16.520
and the basic idea is
that the Windows system is

00:05:16.520 --> 00:05:18.730
really upgrading its model.

00:05:18.730 --> 00:05:24.280
Instead of being a per pixel switcher,
which is primarily what Mac OS or

00:05:24.340 --> 00:05:30.650
X Windows or other windowing systems are,
we've gone for a model where there's a

00:05:30.650 --> 00:05:38.800
per pixel mix from all the windows on the
display to create the final presentation.

00:05:38.800 --> 00:05:40.220
What does this mean?

00:05:40.220 --> 00:05:43.910
Well, this means that Windows can have a
bunch of attributes that get applied

00:05:43.910 --> 00:05:48.870
to them on the pixels in your window,
can have attributes applied

00:05:48.880 --> 00:05:51.180
on their way to the display.

00:05:51.180 --> 00:05:51.180
For example,
if you're going to have a window

00:05:51.180 --> 00:05:51.180
that's a little bit smaller
than the size of the window,

00:05:51.180 --> 00:05:51.180
you can have a window that's a little
bit smaller than the size of the window.

00:05:51.180 --> 00:05:51.180
So for example,
if you're going to have a window

00:05:51.180 --> 00:05:51.180
that's a little bit smaller
than the size of the window,

00:05:51.180 --> 00:05:51.280
you can have a window that's a little
bit smaller than the size of the window.

00:05:51.280 --> 00:05:51.280
So for example,
if you're going to have a window

00:05:51.280 --> 00:05:52.100
that's a little bit smaller than
the size of the For example,

00:05:52.100 --> 00:05:55.600
Windows have a full per-pixel
alpha channel for transparency.

00:05:55.700 --> 00:05:58.320
There's also layer opacity,
so there's an overall

00:05:58.460 --> 00:05:59.720
fade value on each window.

00:06:00.310 --> 00:06:06.220
There's a transform, an affine transform,
a mesh warp, and color space conversion

00:06:06.290 --> 00:06:08.560
for YUV and depth conversion.

00:06:08.560 --> 00:06:11.550
So a lot of these attributes
apply at mix time to the

00:06:11.600 --> 00:06:15.160
graphics to create the display,
regardless of what drawing

00:06:15.270 --> 00:06:16.800
framework you're using.

00:06:17.540 --> 00:06:22.190
The client-server mechanism is in
place for window system control,

00:06:22.330 --> 00:06:25.400
creation and deletion, moving,
resizing of windows.

00:06:25.610 --> 00:06:28.360
Drawing, however,
happens through a shared memory mechanism

00:06:28.690 --> 00:06:33.270
using anonymous memory objects in
Mach to share a read-write memory

00:06:33.640 --> 00:06:36.410
between the client and the server.

00:06:36.930 --> 00:06:40.640
QuickDraw is just drawing
into standard memory,

00:06:40.750 --> 00:06:45.300
same as core graphics,
and the server is able to see that

00:06:45.300 --> 00:06:47.910
memory and apply the mix to the display.

00:06:48.210 --> 00:06:52.370
Since the server is a mixing server,
it needs to repair part of the display.

00:06:52.700 --> 00:06:55.900
It may need pixels from your
application and pixels from

00:06:56.000 --> 00:06:59.890
someone else's application to
actually make up the display.

00:07:01.270 --> 00:07:06.380
So the important thing to remember is
that the drawing happens in the client,

00:07:06.540 --> 00:07:11.870
so it's fast, just procedure call,
hitting the memory of the back buffer,

00:07:12.110 --> 00:07:17.410
and the mixing is in the server where
the complete display is constructed.

00:07:20.430 --> 00:07:22.460
So I'm going to bring up Ralph now.

00:07:22.530 --> 00:07:23.530
There he is.

00:07:23.630 --> 00:07:27.400
Ralph Brunner,
member of the graphics team.

00:07:31.590 --> 00:07:33.850
We're going to do a little
demo for you of just the basic

00:07:33.850 --> 00:07:36.510
windowing facilities on OS X.

00:07:36.750 --> 00:07:41.090
We could have the demo machine.

00:07:41.600 --> 00:07:45.940
Okay, you can see the display.

00:07:45.940 --> 00:07:49.900
The UI folks have been able to do a very
clean window outline because we've given

00:07:49.900 --> 00:07:51.500
them the ability to do the shadowing.

00:07:51.500 --> 00:07:55.480
So you can see if you
bring up the zoom tool,

00:07:55.480 --> 00:07:58.960
you know, it's kind of a subtle effect.

00:07:58.960 --> 00:07:59.860
They didn't go overboard.

00:07:59.900 --> 00:08:02.190
But that's all live
content underneath there.

00:08:02.310 --> 00:08:05.060
If the finder were drawing,
you would be seeing those pixels

00:08:05.060 --> 00:08:06.750
updating underneath the shadow.

00:08:06.900 --> 00:08:10.500
And so that really gives the user
interface a nice subtle effect and

00:08:10.510 --> 00:08:14.400
allows the application to use as
much of the real estate as possible.

00:08:14.400 --> 00:08:18.380
So that's kind of the first thing that
the windowing system has given us.

00:08:18.430 --> 00:08:21.400
You can also see the inactive title
bars are partially translucent.

00:08:21.700 --> 00:08:26.750
The menus,
we use the fading and the opacity.

00:08:26.890 --> 00:08:29.400
So you can see the window fade out.

00:08:29.400 --> 00:08:32.400
You can see if the window
is hanging up there.

00:08:32.400 --> 00:08:35.320
You can move around behind it.

00:08:37.400 --> 00:08:40.260
It fades out.

00:08:40.260 --> 00:08:43.580
If you bring up an application document,
we'll show you some of

00:08:43.580 --> 00:08:45.890
the warping features.

00:08:45.910 --> 00:08:48.390
So here's a tech sample document.

00:08:48.410 --> 00:08:53.700
If you go to save that document if it's
dirty or close it and when it's dirty,

00:08:53.730 --> 00:08:55.080
you get a little animation.

00:08:55.080 --> 00:08:58.390
You can see that alert
is translucent as well.

00:08:58.560 --> 00:09:01.590
Now the application has just
drawn its alert to that.

00:09:01.600 --> 00:09:05.350
It doesn't necessarily know
that that window is translucent.

00:09:05.440 --> 00:09:08.340
That's happening in the mix when
it's presented to the display,

00:09:08.490 --> 00:09:10.400
as is the animation.

00:09:10.540 --> 00:09:14.030
If the window's too small,
we have this sheet effect and

00:09:14.140 --> 00:09:18.010
that's done by an animation of a
mesh warp on the bits as they're

00:09:18.020 --> 00:09:20.370
getting flushed to the screen.

00:09:20.400 --> 00:09:24.810
So that's how we do that and
the windows can move together,

00:09:24.810 --> 00:09:26.390
things like that.

00:09:26.400 --> 00:09:26.840
So if you make the window
a little more rectangular,

00:09:26.850 --> 00:09:27.400
you can see that the window is
now a little bit more transparent.

00:09:27.400 --> 00:09:27.840
So if you make the window
a little more rectangular,

00:09:27.840 --> 00:09:28.400
you can see that the window is
now a little bit more transparent.

00:09:28.400 --> 00:09:32.160
Angular, then we can minify it,
which brings in the Gini,

00:09:32.160 --> 00:09:35.620
which is another application
of the Mesh Warp.

00:09:35.620 --> 00:09:42.360
We create a nicely sync-filtered snapshot
of the actual content of the graphics,

00:09:42.360 --> 00:09:48.040
and then we run it through the
mesh motion path down to the dock.

00:09:48.040 --> 00:09:52.690
In the dock, all of the dock content is
little windows including the

00:09:52.700 --> 00:09:58.480
back translucent part there,
and that's showing off the scaling

00:09:58.540 --> 00:10:06.350
as well as the per pixel alpha
so you can see through the icon.

00:10:07.810 --> 00:10:11.790
So I think that's about it
for the basic window demo.

00:10:11.870 --> 00:10:14.130
OK, we can go back to the slides.

00:10:19.620 --> 00:10:22.800
So now I'm going to cover some
of the drawing components that

00:10:22.860 --> 00:10:29.370
you can use in your applications
to draw in 2D or 3D or whatever.

00:10:29.800 --> 00:10:35.960
First and foremost is QuickDraw,
which is the key 2D component of Carbon,

00:10:36.010 --> 00:10:37.740
which you're all familiar with.

00:10:37.740 --> 00:10:42.070
It's the same API,
and it's the same code base, in fact,

00:10:42.140 --> 00:10:45.220
with just a few minor changes
at the bottom end to talk to

00:10:45.230 --> 00:10:49.660
the new windowing system that we
support on Mac OS 9 and Mac OS X.

00:10:49.700 --> 00:10:54.060
There are a few key differences
that you need to be aware of.

00:10:54.060 --> 00:10:56.170
You don't need to be
aware of all of them,

00:10:56.170 --> 00:10:58.460
but you might want to in certain cases.

00:10:58.460 --> 00:11:01.580
One is there's automatic
buffering support.

00:11:01.620 --> 00:11:05.860
So when you talk to a Windows graph port,
you're not really talking to the display.

00:11:06.060 --> 00:11:10.220
You're talking to the shared memory area
where your graphics is being blitted to,

00:11:10.310 --> 00:11:13.900
and then those graphics are
being flushed to the display,

00:11:14.080 --> 00:11:17.580
either at wait next
event time or end update,

00:11:17.680 --> 00:11:20.840
or you can call it explicitly
if you want those graphics

00:11:20.840 --> 00:11:22.780
to be flushed to the display.

00:11:22.780 --> 00:11:29.010
So that's one thing to be aware of if
you do a lot of drawing and it's not

00:11:29.010 --> 00:11:32.740
showing up because you haven't hit
end update or gotten another event.

00:11:32.980 --> 00:11:36.680
You might want to sprinkle a
few flushing calls in there.

00:11:39.640 --> 00:11:44.540
The other thing we're not allowing is
direct access to the screen's graph port.

00:11:44.540 --> 00:11:46.460
There is a full-screen
API if you want to do a game,

00:11:46.510 --> 00:11:47.440
so we have that covered.

00:11:47.500 --> 00:11:50.080
But when the graphical
user interface is running,

00:11:50.080 --> 00:11:52.640
you can see there's a lot
of dynamicism going on,

00:11:52.720 --> 00:11:57.440
and we can't allow applications
to draw directly to the screen.

00:11:57.500 --> 00:12:01.050
We have certain optimizations
in there for people like

00:12:01.190 --> 00:12:05.500
QuickTime and things like that,
so there are some corner cases to that.

00:12:05.600 --> 00:12:10.730
But the window has to be on top, opaque,
not mesh-transformed and all that stuff

00:12:10.730 --> 00:12:13.420
to actually allow that case to happen.

00:12:13.500 --> 00:12:16.730
By and large,
it's best just to stay away from that

00:12:16.730 --> 00:12:19.620
and let us handle the window composite.

00:12:20.280 --> 00:12:26.120
All the quickdraw drawing is opaque since
the window has a per pixel alpha channel.

00:12:26.120 --> 00:12:28.440
We had to make a decision
about what kind of pixels,

00:12:28.460 --> 00:12:32.190
what kind of alpha quickdraw
drew and it's basically 1.0.

00:12:32.350 --> 00:12:36.200
So all quickdraw content
in the window is opaque.

00:12:36.210 --> 00:12:39.700
The window can still have an overall
fade value on it so you can get

00:12:39.780 --> 00:12:43.440
translucency with a quickdraw window,
but it can't actually draw

00:12:43.440 --> 00:12:45.190
a partially opaque pixel.

00:12:45.200 --> 00:12:49.230
You need to be aware of this in
certain cases in 32-bit mode where

00:12:49.230 --> 00:12:51.200
we do store the alpha inline.

00:12:51.200 --> 00:12:54.200
In 16-bit mode we have a separate
plane which quickdraw doesn't see.

00:12:54.470 --> 00:12:59.390
But in 32-bit mode we actually do
use the high byte of the color for

00:12:59.530 --> 00:13:05.200
the alpha and that needs to be set to
FF if you're doing your own blitting.

00:13:05.200 --> 00:13:08.180
If it's not, you might see holes in
your windows occasionally,

00:13:08.180 --> 00:13:10.200
which is kind of fun, but not intended.

00:13:10.640 --> 00:13:15.200
The other thing to be aware
of is in the printing case,

00:13:15.200 --> 00:13:18.530
the quickdraw bottlenecks are
implemented rather than by

00:13:18.530 --> 00:13:20.200
drivers by system software.

00:13:20.200 --> 00:13:23.100
I'll get to how they're
implemented in a second,

00:13:23.210 --> 00:13:28.080
but it's a common set of quickdraw
bottlenecks regardless of what driver you

00:13:28.180 --> 00:13:32.130
may be talking to in the printing case.

00:13:34.290 --> 00:13:38.540
The other 2D rendering library we have,
this is the new 2D rendering library

00:13:38.540 --> 00:13:42.180
we've talked about for a few WWDCs now.

00:13:42.180 --> 00:13:46.950
It's called Core Graphics 2D Rendering,
part of the Core Graphics Framework.

00:13:47.050 --> 00:13:52.960
It's the key 2D graphics engine
beneath Cocoa and also beneath Java,

00:13:52.960 --> 00:13:58.670
or Java 2D implementation is
implemented on top of Core Graphics.

00:13:59.010 --> 00:14:04.280
It's a PDF PostScript imaging model,
very industry standard.

00:14:04.480 --> 00:14:06.300
We interpret PDF files.

00:14:06.490 --> 00:14:10.920
We're based on the PDF 1.2 spec
with some 1.3 features now.

00:14:11.020 --> 00:14:14.570
The major feature we're
missing is the shaded fill.

00:14:14.650 --> 00:14:17.500
We're working on that
and we'll get that soon.

00:14:17.670 --> 00:14:21.310
And we'll continue to track the
specs as closely as possible and work

00:14:21.370 --> 00:14:23.540
with Adobe on future enhancements.

00:14:23.630 --> 00:14:27.570
It's fully anti-alias,
very fast scan converter.

00:14:27.650 --> 00:14:28.780
Scan converts on the fly.

00:14:28.780 --> 00:14:31.440
Anti-alias is text at
subpixel position on the fly.

00:14:31.440 --> 00:14:35.230
And it's vector-based for
resolution independence,

00:14:35.280 --> 00:14:38.510
which has always been true
of PostScript and PDF,

00:14:38.650 --> 00:14:40.620
but this vector-based
buzzword is out there now,

00:14:40.700 --> 00:14:45.940
so we have to remember to apply
it to older technology too.

00:14:46.590 --> 00:14:51.920
The Core Graphics 2D architecture, again,
is sort of layered and factored out.

00:14:52.020 --> 00:14:55.920
It's basically a hub
architecture where we have the

00:14:55.920 --> 00:14:58.390
Core Graphics API at the core.

00:14:58.710 --> 00:15:04.500
Above that, we have the ability to parse
PDF files and call the API to draw it.

00:15:04.500 --> 00:15:07.500
We have a C API that you can
call from your applications.

00:15:07.500 --> 00:15:11.240
QuickDraw, with the QuickDraw printing
bottlenecks in the printing case,

00:15:11.410 --> 00:15:14.500
are implemented by calling down
to the Core Graphics layer.

00:15:14.500 --> 00:15:17.340
And Java 2D, as well,
is implemented by calling the

00:15:17.470 --> 00:15:19.500
Core Graphics rendering library.

00:15:19.560 --> 00:15:23.500
Underneath the different context
implementations we currently have,

00:15:23.500 --> 00:15:26.500
obviously,
we have an on-screen rendering context.

00:15:26.670 --> 00:15:31.490
We have a PDF file creation context.

00:15:31.630 --> 00:15:35.650
We have a PostScript file
creation context and a raster

00:15:35.700 --> 00:15:38.010
data context for printing.

00:15:42.090 --> 00:15:44.950
In the printing case,
what happens is if you're printing from

00:15:45.010 --> 00:15:51.270
a Carbon app going through QuickDraw,
your graphics come in through QuickDraw,

00:15:51.430 --> 00:15:55.360
get recorded in the first pass when
we generate the spool file through

00:15:55.360 --> 00:15:59.720
the core graphics rendering library
and out that PDF arrow there,

00:15:59.780 --> 00:16:01.750
sent to the back end
of the printing system.

00:16:01.820 --> 00:16:05.030
The back end of the printing system,
it comes back in the top through a PDF.

00:16:05.080 --> 00:16:06.930
Depending upon what kind
of printer it ended up at,

00:16:07.000 --> 00:16:12.320
you get either PostScript or raster
data or I'm sure third parties will

00:16:12.320 --> 00:16:17.330
do their own PDF renderers as well
to plug into that architecture.

00:16:17.430 --> 00:16:21.290
But standardizing on PDF as that
back end of the printing system,

00:16:21.290 --> 00:16:23.910
I think, will be a big advantage for us.

00:16:25.500 --> 00:16:30.120
So the Core Graphics 2D rendering
library really leverages and is leveraged

00:16:30.270 --> 00:16:31.870
by a bunch of Apple technologies.

00:16:31.900 --> 00:16:35.230
I talked about Cocoa and Java 2D.

00:16:35.350 --> 00:16:37.670
But also internally,
we rely on other pieces

00:16:37.670 --> 00:16:40.300
of Apple technology,
tried and true technologies

00:16:40.440 --> 00:16:43.050
like Color Sync,
Apple Type Services.

00:16:43.150 --> 00:16:46.220
These are mature technologies,
been at Apple for a while,

00:16:46.220 --> 00:16:50.450
and we're able to just leverage those
to do our PDF Core Graphics rendering.

00:16:50.580 --> 00:16:51.850
So that's really great.

00:16:51.960 --> 00:16:54.380
On the other side,
in addition to Cocoa and Java 2D,

00:16:54.380 --> 00:16:57.540
Appearance Manager is using
Core Graphics to draw all the text.

00:16:57.560 --> 00:17:00.920
If you'll notice,
it's anti-alias and has a slight blur,

00:17:00.920 --> 00:17:03.570
drop shadow effect added to it.

00:17:03.670 --> 00:17:06.930
And so that's going through the
Core Graphics API so you can draw

00:17:06.930 --> 00:17:10.720
Appearance Manager text and it's
actually calling Core Graphics.

00:17:10.800 --> 00:17:13.960
QuickTime,
we've worked with the QuickTime team

00:17:13.960 --> 00:17:15.910
on a PDF graphics importer.

00:17:16.050 --> 00:17:21.800
This allows PDF to be handled
by QuickTime Graphics.

00:17:21.870 --> 00:17:23.350
So we've got a lot of graphics
importer architecture.

00:17:23.410 --> 00:17:25.820
So if you're using
QuickTime Graphics importer,

00:17:25.990 --> 00:17:29.420
you'll get a PDF if you hook it
up to do drag and drop or import

00:17:29.530 --> 00:17:31.860
or whatever in your application.

00:17:31.880 --> 00:17:34.800
In fact, we have a demo of that.

00:17:34.830 --> 00:17:37.330
We can go back to the demo machine.

00:17:38.940 --> 00:17:41.800
We're going to show you,
this is a version of

00:17:41.850 --> 00:17:45.550
Apple Works that's in development.

00:17:45.570 --> 00:17:48.740
It's an update that will
hopefully be coming out soon,

00:17:48.770 --> 00:17:50.210
running under OS X here.

00:17:50.290 --> 00:17:54.900
This is actually a
CFM application in all its glory.

00:17:54.980 --> 00:17:58.360
And what we're going to do
is Ralph created a little

00:17:58.360 --> 00:18:02.650
word processing document,
typed in some text, and now he's got a

00:18:02.680 --> 00:18:03.850
directory full of PDFs.

00:18:03.980 --> 00:18:05.890
He's going to drag it over.

00:18:05.900 --> 00:18:09.100
Apple Works guys have hooked up the
graphics import capability to ask

00:18:09.100 --> 00:18:12.430
QuickTime if it can handle the file,
so you can do the same

00:18:12.530 --> 00:18:14.900
thing with TIFF or whatever.

00:18:14.900 --> 00:18:17.260
But now with, on OS X,
with our PDF support,

00:18:17.280 --> 00:18:18.790
you just get that for free.

00:18:18.900 --> 00:18:21.900
So that's pretty cool.

00:18:21.900 --> 00:18:25.530
I think that's, you know, a great,
if you're not using graphics importers

00:18:25.530 --> 00:18:28.890
now and you have an application
like this that can embed graphics,

00:18:28.900 --> 00:18:30.900
definitely start looking at that.

00:18:30.900 --> 00:18:32.740
So you see on resize,
the codec gets called

00:18:32.740 --> 00:18:33.760
to re-render the data.

00:18:33.940 --> 00:18:35.890
It's fully vectors and re-antialiased.

00:18:35.900 --> 00:18:37.740
and everything.

00:18:37.790 --> 00:18:39.890
So that's pretty cool.

00:18:44.350 --> 00:18:47.050
So back to the slides.

00:18:47.060 --> 00:18:50.520
So if you want to dig a little deeper
and not just do the core graphics or

00:18:50.550 --> 00:18:56.540
the graphics importer with QuickTime,
but you actually want to call the API,

00:18:56.630 --> 00:19:00.280
there's going to be a detailed session
on Friday about the 2D drawing API.

00:19:00.370 --> 00:19:04.240
Derek Clegg is going to give a
pretty detailed overview of it.

00:19:04.320 --> 00:19:05.300
I'll just give you a few bullets here.

00:19:05.300 --> 00:19:10.060
It's a C-based API, very straightforward,
virtually one-to-one with

00:19:10.060 --> 00:19:12.280
PDF PostScript imaging model.

00:19:12.320 --> 00:19:15.670
The naming convention we use for the
functions is similar to core foundation

00:19:15.670 --> 00:19:17.300
if you were at any of those talks.

00:19:17.300 --> 00:19:20.300
So for example, to draw the current path,
to fill the current path,

00:19:20.300 --> 00:19:24.390
the BCG context draw path,
you pass it the context,

00:19:24.390 --> 00:19:27.300
and then an enumeration that
says you want it filled.

00:19:27.300 --> 00:19:30.300
You can also say stroke
or stroke and fill.

00:19:30.300 --> 00:19:32.300
Very straightforward.

00:19:32.300 --> 00:19:36.950
There's abstractions for transformations,
color spaces, images, paths,

00:19:37.050 --> 00:19:41.960
kind of all the objects you would expect
in the PDF and PostScript imaging model.

00:19:42.870 --> 00:19:45.320
So to give you a demo,
a short demo of that,

00:19:45.320 --> 00:19:48.240
you're also going to see
this at Derek's session.

00:19:48.360 --> 00:19:51.050
But if we can get back
to the demo machine.

00:19:53.410 --> 00:19:55.830
We have a little application
here we call Carbon Draw.

00:19:56.030 --> 00:19:59.520
One of our engineers, Mike Marinkovitch,
had this as a little quick draw example.

00:19:59.540 --> 00:20:02.980
And it's basically a little
drawing canvas that you can

00:20:02.980 --> 00:20:06.900
create simple line art in just
how to build a basic application.

00:20:06.900 --> 00:20:11.520
What Mike did was he had already
kind of factored out his code and he

00:20:11.530 --> 00:20:15.940
had one module which basically did
all of the content rendering there.

00:20:15.960 --> 00:20:19.700
And he replaced that with a module
on OS X that calls Core Graphics.

00:20:19.700 --> 00:20:23.400
And so he also prettied up the
user interface a little bit to

00:20:23.410 --> 00:20:28.180
bring out some of the features
of OS X and Core Graphics.

00:20:28.330 --> 00:20:30.370
Well,
here's the Carbon Color Picker which

00:20:30.370 --> 00:20:32.120
is looking pretty good these days.

00:20:32.430 --> 00:20:36.490
The crayons are my favorite.

00:20:37.300 --> 00:20:39.360
and I got that Aqua look going.

00:20:39.500 --> 00:20:44.600
We have the full PostScript line
style implementation as you'd expect,

00:20:44.650 --> 00:20:49.990
so you can change the end caps,
round end caps.

00:20:51.040 --> 00:20:57.040
You can see if you create an ellipse,
we can show you that.

00:20:57.090 --> 00:20:59.140
And Mike actually didn't
get totally done converting.

00:20:59.140 --> 00:21:01.620
You can see when he rubber bands,
it's actually QuickDraw doing

00:21:01.620 --> 00:21:04.630
the rubber banding and then uses
Core Graphics to draw the content.

00:21:04.630 --> 00:21:06.230
So he's kind of halfway
through converting it.

00:21:06.240 --> 00:21:09.990
But it's a nice thing to show that you
can kind of live in both worlds there.

00:21:10.000 --> 00:21:11.820
So we have the dash implementation.

00:21:11.860 --> 00:21:13.980
We've got one particular dash setting.

00:21:13.980 --> 00:21:17.050
You can change the joins
and the dashes and,

00:21:17.050 --> 00:21:19.000
you know, so kind of fun.

00:21:19.000 --> 00:21:22.240
So we're going to make
this available sometime.

00:21:22.240 --> 00:21:23.700
Thanks.

00:21:25.750 --> 00:21:28.290
Sometime after WWC,
the one thing the app doesn't do yet,

00:21:28.290 --> 00:21:32.720
which we want to show how to do,
is print that out to show how to

00:21:32.720 --> 00:21:37.440
get from the QuickDraw graph port
to the core graphics context when

00:21:37.610 --> 00:21:41.050
you're printing so you can replay the
same objects in the printing path.

00:21:41.390 --> 00:21:42.190
So that's it for that.

00:21:42.190 --> 00:21:44.100
If you want to see more of that,
I think they're going to show

00:21:44.100 --> 00:21:47.940
actual code snippets of that as
well at the session on Friday.

00:21:50.910 --> 00:21:52.320
So printing.

00:21:52.430 --> 00:21:56.960
Printing for OS X is a
completely new architecture.

00:21:57.020 --> 00:22:01.210
It's a client-server architecture with
a clean separation between the front end

00:22:01.210 --> 00:22:03.800
of the printing process and the back end.

00:22:03.800 --> 00:22:07.790
And they communicate via the PDF spool
file and a job ticket mechanism,

00:22:07.820 --> 00:22:10.670
which is an XML file that
basically describes the

00:22:10.670 --> 00:22:13.450
finishing options on the file,
whether it's supposed to be NUP or

00:22:13.450 --> 00:22:18.790
a certain paper tray or a certain
color correction strategy or whatever.

00:22:18.960 --> 00:22:21.650
It simplifies the driver model a lot.

00:22:21.820 --> 00:22:24.800
For those of you who have
written printer drivers on OS 9,

00:22:24.800 --> 00:22:28.620
you know, from the QuickDraw bottlenecks
to the paper and the printer

00:22:28.630 --> 00:22:29.800
is basically your deal.

00:22:29.800 --> 00:22:32.640
If you want to do spooling,
background printing, queue management,

00:22:32.720 --> 00:22:34.490
whatever, you know,
you've got to write a ton

00:22:34.490 --> 00:22:35.800
of code to get that done.

00:22:35.800 --> 00:22:39.180
We're taking care of all of that in OS X,
and if you're bringing up a new printer,

00:22:39.180 --> 00:22:41.720
you really just have to write
the engine control logic.

00:22:41.800 --> 00:22:45.870
In fact, most of the I/O code we have
for USB you can probably reuse

00:22:45.870 --> 00:22:47.790
and other I/O techniques.

00:22:47.800 --> 00:22:50.100
And, you know,
a little bit of UI to bring out

00:22:50.210 --> 00:22:53.800
your printer-specific features,
but that's really about it.

00:22:54.640 --> 00:22:57.950
Again,
PDF is the default school file format.

00:22:58.290 --> 00:23:02.530
That brings us a lot of
advantages in the sense that we

00:23:02.530 --> 00:23:06.240
can do print preview for free.

00:23:06.240 --> 00:23:09.510
You can also debug your printing code
pretty quickly by just looking at the

00:23:09.510 --> 00:23:11.600
PDF output rather than wasting paper.

00:23:11.600 --> 00:23:17.850
It also leverages Core Graphics,
the 2D rendering library as a RIP,

00:23:17.850 --> 00:23:21.600
which we spend a lot of time optimizing.

00:23:21.600 --> 00:23:26.230
The printer developers can take
advantage of that out of the box and

00:23:26.370 --> 00:23:29.540
get pretty high-performance rendering.

00:23:31.690 --> 00:23:34.170
So demos of printing
are never very exciting,

00:23:34.340 --> 00:23:37.000
so we're going to demo print preview.

00:23:37.090 --> 00:23:39.850
I shouldn't say that totally, but...

00:23:40.100 --> 00:23:44.570
We don't have a printer on stage,
but this again is Apple Works.

00:23:44.680 --> 00:23:51.100
So Ralph created a little spreadsheet
here for his wild creature collection.

00:23:51.160 --> 00:23:54.140
We're going to exercise the
PDF graphic importer a little bit

00:23:54.140 --> 00:23:58.600
and drag in a couple of files.

00:23:58.620 --> 00:24:01.160
So this is the raptor.

00:24:01.160 --> 00:24:03.100
We resize it down.

00:24:03.130 --> 00:24:07.490
This is the ferocious chicken.

00:24:10.460 --> 00:24:13.450
So it's getting the vector resizing.

00:24:13.630 --> 00:24:17.470
Now, a spreadsheet is typically something
that's difficult to share unless the

00:24:17.700 --> 00:24:19.000
other person has the application.

00:24:19.000 --> 00:24:22.400
You don't always want to
send them the original file.

00:24:22.400 --> 00:24:25.400
So exchanging a PDF is kind
of a good way to do that.

00:24:25.400 --> 00:24:28.520
So one way you can do that
on OS X is to bring up print

00:24:28.540 --> 00:24:30.290
and hit the preview button.

00:24:30.400 --> 00:24:33.230
So all the QuickDraw calls are
going to get translated to PDF,

00:24:33.230 --> 00:24:36.400
and we're going to open
up our little PDF viewer.

00:24:36.400 --> 00:24:39.020
And we still have a couple
of bugs with the black there,

00:24:39.030 --> 00:24:40.400
but ignore that for now.

00:24:40.500 --> 00:24:47.850
So you see basically we've got a nice
PDF file in preview out of QuickDraw,

00:24:47.850 --> 00:24:50.710
and that's just built in.

00:24:51.120 --> 00:24:53.540
Thanks.

00:24:53.540 --> 00:24:55.000
There's more.

00:24:55.020 --> 00:25:00.060
If you bring up mail then,
you want to mail that to someone,

00:25:00.060 --> 00:25:02.100
CC someone else.

00:25:06.120 --> 00:25:08.100
If you have any questions
about something,

00:25:08.240 --> 00:25:11.460
you can actually just drag out
of that title bar proxy there and

00:25:11.460 --> 00:25:13.100
that will image right in line.

00:25:13.160 --> 00:25:15.590
You can send that if
someone's not running OS X,

00:25:15.590 --> 00:25:18.100
that'll just show up as a PDF attachment.

00:25:18.100 --> 00:25:22.610
It'll launch in Acrobat and
look just like that in print.

00:25:26.660 --> 00:25:29.400
So as I said before, you know,
not just for users but for developers,

00:25:29.400 --> 00:25:32.460
when you're debugging your printing code,
you're trying to figure out how to lay

00:25:32.460 --> 00:25:34.340
out your graphics so you don't have,
like,

00:25:34.340 --> 00:25:36.650
hanging words off one page to the next.

00:25:36.740 --> 00:25:39.080
You can iterate in that preview
loop to get your pages to

00:25:39.080 --> 00:25:41.580
lay out correctly before,
you know, you have to get it all

00:25:41.580 --> 00:25:42.800
the way to the printer.

00:25:42.840 --> 00:25:49.190
So that's a good way to debug
printing code for developers too.

00:25:49.190 --> 00:25:49.190
Okay, back to the slides.

00:25:52.110 --> 00:25:53.760
Image Capture.

00:25:53.880 --> 00:25:59.000
Image Capture is a new framework that
we'll be talking about at WWDC tomorrow.

00:25:59.060 --> 00:26:04.210
It's an API and some system
services for digital still cameras.

00:26:04.360 --> 00:26:06.440
We're focusing primarily on cameras.

00:26:06.650 --> 00:26:09.930
Right now, the architecture is flexible
enough to handle scanners

00:26:09.930 --> 00:26:11.500
and other devices as well.

00:26:11.500 --> 00:26:14.690
We're going to be building in
support for the new USB still

00:26:14.690 --> 00:26:17.910
camera protocol called PTP,
which is coming out soon.

00:26:18.030 --> 00:26:20.690
I'm told the cameras this summer will,
by and large,

00:26:20.740 --> 00:26:22.410
be shipping with that protocol.

00:26:22.500 --> 00:26:24.570
There's a bunch of
cameras out there already.

00:26:24.570 --> 00:26:26.980
We have drivers for some,
and we'll get drivers for more

00:26:26.990 --> 00:26:28.500
by working with the vendors.

00:26:28.500 --> 00:26:31.130
But writing a driver for
this architecture is actually

00:26:31.210 --> 00:26:32.500
very straightforward.

00:26:32.500 --> 00:26:37.500
The API will be available on
both Mac OS 9 and Mac OS X.

00:26:37.500 --> 00:26:41.340
And we're also providing a simple user
experience for downloading the photos.

00:26:41.500 --> 00:26:43.450
So when the hot plug event
comes into the computer,

00:26:43.550 --> 00:26:47.040
there'll be a control panel that'll
come up and allow the users to say

00:26:47.040 --> 00:26:51.170
what they want to do with their image,
most likely just download

00:26:51.170 --> 00:26:52.500
them or whatever.

00:26:52.500 --> 00:26:54.500
We'll be showing that.

00:26:54.500 --> 00:26:57.110
I think there are going to be some
good demos tomorrow at this session,

00:26:57.170 --> 00:26:57.460
too.

00:26:57.490 --> 00:27:00.500
So if you're interested in that stuff,
please attend.

00:27:04.090 --> 00:27:08.490
Another piece of technology you
definitely should be aware of is OpenGL.

00:27:08.590 --> 00:27:13.000
OpenGL is the only 3D graphics
API we support on Mac OS X.

00:27:13.000 --> 00:27:20.000
So things like Rave and QuickDraw 3D
are not being brought forward to OS X.

00:27:20.000 --> 00:27:25.000
Focusing all of our energy on OpenGL,
right now we're at the 1.1 spec level.

00:27:25.000 --> 00:27:29.860
We have a bunch of extensions,
all of the interesting extensions that

00:27:29.860 --> 00:27:33.000
the game developers have been asking for.

00:27:33.000 --> 00:27:35.610
We'll continue to track as
more extensions come out and

00:27:35.750 --> 00:27:39.000
more hardware comes out with
those extensions and hardware.

00:27:39.110 --> 00:27:42.000
We will track those as
quickly as possible.

00:27:42.000 --> 00:27:46.000
And OpenGL 1.2 is also
on the horizon as well.

00:27:46.000 --> 00:27:50.000
It's fully accelerated on
Rage 128 based systems.

00:27:50.000 --> 00:27:53.000
That's in DP4, in what you have.

00:27:53.000 --> 00:27:55.990
That's all of the Macs you can
currently buy except for the iBook.

00:27:56.000 --> 00:28:01.970
Support for earlier hardware
is in software right now,

00:28:02.000 --> 00:28:02.000
so you can definitely
write your app on that.

00:28:02.060 --> 00:28:04.890
The software renderer
is actually pretty good.

00:28:05.000 --> 00:28:08.380
We are working on support
for Rage Pro and some of the

00:28:08.620 --> 00:28:10.970
earlier accelerators as well.

00:28:11.000 --> 00:28:14.000
We're juggling that with support
for new hardware that's coming,

00:28:14.000 --> 00:28:16.510
which it's always easier to
get engineers to work on the

00:28:16.510 --> 00:28:18.000
new stuff than the old stuff.

00:28:18.000 --> 00:28:21.000
So hopefully we'll be
able to get it all done,

00:28:21.000 --> 00:28:22.930
but just to let you know,
we're probably going to be

00:28:22.940 --> 00:28:25.990
prioritizing new hardware before
going back to the old stuff.

00:28:26.000 --> 00:28:28.000
Just to put that out there.

00:28:28.000 --> 00:28:31.000
But it's not my call,
so give us feedback.

00:28:31.000 --> 00:28:34.580
One of the things we've done in
the OpenGL implementation since

00:28:34.580 --> 00:28:38.530
it was being brought up at the
same time as the I/O Kit and all

00:28:38.690 --> 00:28:42.390
of that stuff happening together,
we have a pretty advanced resource

00:28:42.390 --> 00:28:44.980
allocation hardware abstraction
layer inside the kernel.

00:28:45.000 --> 00:28:50.860
This layer is able to quickly manage
texture paging and buffer paging on and

00:28:50.980 --> 00:28:55.000
off the card in a very optimized format.

00:28:55.000 --> 00:28:58.260
And we've been able to do things
like play Quake reasonably

00:28:58.260 --> 00:29:00.000
with 2 meg of texture memory.

00:29:00.000 --> 00:29:05.370
Launch many applications which
saturate the texture memory and you

00:29:05.430 --> 00:29:09.000
get a very smooth slowdown as you
need to load more and more textures.

00:29:09.000 --> 00:29:12.000
It's really just the cost of that
extra command to load the texture.

00:29:12.000 --> 00:29:14.000
It's a very smooth degradation.

00:29:14.260 --> 00:29:16.130
Because we think over time more and
more applications are going to be

00:29:16.130 --> 00:29:20.000
taking advantage of this and we really
want to optimize not just for games,

00:29:20.010 --> 00:29:25.000
but for a world where, say,
every application is using the 3D pipe.

00:29:32.980 --> 00:29:34.900
Okay, so I have to apologize first.

00:29:34.900 --> 00:29:37.470
This part of the demo,
you are going to see a command line,

00:29:37.470 --> 00:29:40.890
so if that bothers you, hold your eyes.

00:29:41.230 --> 00:29:45.060
I apologize, it's my program.

00:29:45.060 --> 00:29:49.190
This is a little program
I wrote called Slide,

00:29:49.190 --> 00:29:53.440
and it talks to OpenGL,
talks to QuickTime to

00:29:53.440 --> 00:29:54.460
load a bunch of JPEGs.

00:29:54.460 --> 00:29:57.090
These are some
JPEGs I took at the office.

00:29:57.140 --> 00:29:59.100
I took my own advice,
used graphic importers,

00:29:59.100 --> 00:30:00.100
it wasn't that hard.

00:30:00.140 --> 00:30:04.880
About 600 lines of code,
and you can see what I've done is just

00:30:04.950 --> 00:30:09.020
put the textures on little planes and
kind of moving them back and forth,

00:30:09.120 --> 00:30:12.580
so it kind of looks like a 2D app.

00:30:12.700 --> 00:30:16.980
So, these are all my friends at work.

00:30:17.180 --> 00:30:20.370
But just to show you it's 3D,
I added a little mouse handling in

00:30:20.370 --> 00:30:26.700
there so Ralph can move back on the
camera and then ease it off to the side.

00:30:26.700 --> 00:30:30.160
Kind of awkward,
but... So you can see what's

00:30:30.160 --> 00:30:35.220
happening is those planes are just
kind of moving along an axis in and

00:30:35.360 --> 00:30:39.700
out of the camera with the... using
the texture blending functions.

00:30:39.700 --> 00:30:44.120
get kind of a nice effect.

00:30:45.090 --> 00:30:47.970
There's Ralph's modeling
tool for the water demo.

00:30:48.000 --> 00:30:50.000
I don't know if you saw that go by.

00:30:50.400 --> 00:30:57.990
Maybe now with Maya we can get
you some better modeling tools.

00:30:58.220 --> 00:31:00.840
So I took my own advice
and used graphic importers.

00:31:00.890 --> 00:31:03.090
I said, "Well, we've got this other
directory full of PDFs.

00:31:03.140 --> 00:31:09.060
Maybe I should try to run my same program
on those PDFs." I honestly did this.

00:31:09.060 --> 00:31:12.720
I realized after the fact, I said, "Wait,
that slide demo I'm working on,

00:31:12.720 --> 00:31:15.870
I could use that with
PDFs." And a few days ago,

00:31:15.880 --> 00:31:19.020
I tried it, and it actually worked.

00:31:20.390 --> 00:31:38.800
The next demo will show a way to
use Core graphics and 3D together.

00:31:38.920 --> 00:31:42.300
Because we think with the
Core graphics 2D rendering library,

00:31:42.300 --> 00:31:47.320
you can do pretty nice dynamic alpha
textures if you have a game that you want

00:31:47.320 --> 00:31:52.270
to do UI or you just want to do some nice
2D rendering to then use as a texture.

00:31:52.330 --> 00:31:56.580
We think the combination of those
two things will be pretty useful.

00:31:57.500 --> 00:32:02.000
So that's that.

00:32:02.000 --> 00:32:04.240
We can go back to the
slides for just one sec.

00:32:04.250 --> 00:32:06.200
Thanks.

00:32:10.480 --> 00:32:12.100
The next demo is a 3D compositor.

00:32:12.100 --> 00:32:13.910
You saw this in the keynote.

00:32:14.000 --> 00:32:17.650
Ralph is responsible for it,
so thank him.

00:32:17.780 --> 00:32:20.810
And he was responsible for the
compositor you saw last year,

00:32:20.810 --> 00:32:21.240
too.

00:32:21.240 --> 00:32:25.300
And it just added more features.

00:32:25.840 --> 00:32:28.030
The basic idea was here.

00:32:28.040 --> 00:32:31.800
Originally, we wrote the app as a demo of
what can you do with PDF and

00:32:31.840 --> 00:32:34.390
compositing and anti-aliasing.

00:32:34.390 --> 00:32:37.860
And actually, the engine that drives this
application is the same thing that's

00:32:37.950 --> 00:32:39.410
running the whole windowing system.

00:32:39.490 --> 00:32:47.460
When we first showed the application,
we couldn't really talk about that,

00:32:47.460 --> 00:32:48.640
but the layer composite engine here
is actually running the whole display.

00:32:49.060 --> 00:32:50.910
And so what we thought
would be fun is to,

00:32:50.910 --> 00:32:53.510
you know, maybe,
I don't know if you have like a

00:32:53.530 --> 00:32:55.440
packaging application or something.

00:32:55.490 --> 00:32:59.160
Again, there's a way with the
PDF built into the system,

00:32:59.220 --> 00:33:01.930
you know,
maybe there's a nice application

00:33:01.930 --> 00:33:05.970
idea here to do some kind
of simulation like that.

00:33:06.000 --> 00:33:08.760
And you can get pretty high performance.

00:33:08.760 --> 00:33:12.140
You can drag around the PDF,
take advantage of the

00:33:12.140 --> 00:33:13.930
high performance 2D.

00:33:13.960 --> 00:33:19.480
You can resize it, rotate it,
and it's just getting texture mapped.

00:33:19.520 --> 00:33:20.970
Ralph can also move around the lights.

00:33:20.970 --> 00:33:22.020
Did you move those yet?

00:33:22.020 --> 00:33:27.010
Steve didn't show all
the features on stage.

00:33:29.180 --> 00:33:33.390
So that little thing there is
the light that's whipping around.

00:33:33.390 --> 00:33:35.370
That can animate too.

00:33:37.970 --> 00:33:40.000
So anyway, I mean,
this was something literally, you know,

00:33:40.000 --> 00:33:42.650
we put together in the last week or so,
you know,

00:33:42.670 --> 00:33:46.140
to try to show off a little bit of
OS X and all the work we've been doing.

00:33:46.190 --> 00:33:48.540
But, you know,
you guys have a whole year until

00:33:48.540 --> 00:33:51.730
next year to impress us with what
you can do with all this technology.

00:33:51.740 --> 00:33:57.740
So just to kind of whet
your appetite there.

00:33:57.780 --> 00:34:00.610
Okay, I think that's it for that.

00:34:06.650 --> 00:34:12.550
Okay, the next thing we're going to
talk about is performance tools.

00:34:12.880 --> 00:34:16.880
It's pretty important in this new world
where you don't always see what's going

00:34:16.880 --> 00:34:22.820
on if your application is drawing that
you take some time to optimize because

00:34:22.820 --> 00:34:26.040
you can find that you'll be drawing
things a lot of times in the back buffer

00:34:26.120 --> 00:34:29.650
that aren't necessarily being shown.

00:34:29.660 --> 00:34:31.880
You may be drawing the same
thing over and over again.

00:34:31.880 --> 00:34:33.460
You may be flushing too much.

00:34:33.630 --> 00:34:37.750
It's really important
to try to tune that.

00:34:38.130 --> 00:34:43.290
We've gone through inside of Apple on
a lot of iterations with all the other

00:34:43.290 --> 00:34:46.170
teams to try to improve performance.

00:34:46.200 --> 00:34:48.630
Some of the tools we've
developed in-house we're

00:34:48.750 --> 00:34:50.390
going to be making available.

00:34:50.400 --> 00:34:54.140
They're not fully supported in DP4.

00:34:54.430 --> 00:34:56.300
The windowing system
has the debugging hooks,

00:34:56.300 --> 00:34:58.030
but we don't have a tool to turn them on.

00:34:58.070 --> 00:35:00.990
It's just a question of giving
you a small app that can turn on

00:35:01.090 --> 00:35:02.750
some of these debugging hooks.

00:35:02.930 --> 00:35:08.060
Ralph is going to bring you through
some of the performance tools.

00:35:08.060 --> 00:35:10.810
Hopefully,
if there are any of our colleagues

00:35:10.810 --> 00:35:14.360
at Apple whose apps we're going
to show here and embarrass,

00:35:14.360 --> 00:35:16.200
we apologize in advance.

00:35:16.200 --> 00:35:21.400
We'll help you tune your code later.

00:35:23.200 --> 00:35:24.260
Okay, back to Ralph.

00:35:24.480 --> 00:35:24.890
Okay.

00:35:24.890 --> 00:35:25.410
Go ahead.

00:35:25.620 --> 00:35:26.900
Okay.

00:35:26.920 --> 00:35:31.160
What I'm going to show is this little
application called Quartz Debug.

00:35:31.190 --> 00:35:36.400
And what it does is whenever an
application flushes the contents of

00:35:36.410 --> 00:35:41.750
the backing store onto the screen,
it flashes that area briefly in yellow

00:35:41.750 --> 00:35:43.820
so you see what's getting drawn.

00:35:43.950 --> 00:35:45.950
So for example,
if you move over the dock,

00:35:46.020 --> 00:35:50.610
which does a lot of drawing,
you see it flickers light madly.

00:35:51.090 --> 00:35:53.540
So, how do you use that?

00:35:53.660 --> 00:35:58.690
So, for example,
I take a demo application called Sketch,

00:35:59.320 --> 00:36:03.000
and I draw a circle which
has reasonable performance,

00:36:03.220 --> 00:36:06.670
but when I turn on the rulers,

00:36:09.450 --> 00:36:14.160
I noticed that performance
is suddenly very bad.

00:36:14.260 --> 00:36:16.950
So, with that little tool,

00:36:19.200 --> 00:36:21.540
What this setting does,
it flashes yellow,

00:36:21.540 --> 00:36:25.400
waits for a few milliseconds,
and then does the actual drawing so that

00:36:25.400 --> 00:36:28.600
you can see more clearly what's going on.

00:36:29.410 --> 00:36:31.950
So you see,
this application actually redraws quite

00:36:31.950 --> 00:36:36.300
a bit of the rulers every mouse update,
and that's the reason why it's so slow.

00:36:36.420 --> 00:36:39.410
And what's that rectangle
like in the upper left?

00:36:39.720 --> 00:36:40.600
Which one?

00:36:40.600 --> 00:36:42.840
I don't know,
the big yellow one that goes in

00:36:42.840 --> 00:36:43.980
the upper left of the content.

00:36:43.980 --> 00:36:45.600
I'm not sure why that needs to be drawn.

00:36:45.600 --> 00:36:47.260
Oh, I don't know.

00:36:47.430 --> 00:36:50.920
Obviously there's some pixel
touched in the upper left corner.

00:36:51.530 --> 00:36:53.620
Okay.

00:36:53.730 --> 00:36:58.480
So, the message here is whenever
you have an event loop,

00:36:58.780 --> 00:37:03.140
try to flush exactly once per mouse move,
mouse click, or whatever the event

00:37:03.270 --> 00:37:04.500
is you're responding to.

00:37:04.500 --> 00:37:06.470
And that has two reasons.

00:37:06.570 --> 00:37:12.280
One, it just looks better because the
end user just sees one single

00:37:12.280 --> 00:37:14.500
update and everything is just there.

00:37:14.500 --> 00:37:18.580
And the second thing is that memory
bandwidth to the backing store is

00:37:18.580 --> 00:37:23.440
about six times higher on our current
machines than it is to the frame buffer.

00:37:23.490 --> 00:37:27.910
So, flushing less actually
helps a lot performance.

00:37:30.300 --> 00:37:34.490
Okay, let me quit this one.

00:37:34.490 --> 00:37:39.830
Another application I'm
going to show is Champollion.

00:37:40.540 --> 00:37:46.080
And I clicked on another switch up there,
which is all the flush drawing.

00:37:46.190 --> 00:37:50.530
So now I'm not only marking
every time the application flush,

00:37:50.610 --> 00:37:54.310
I actually mark every time
a single primitive is drawn.

00:37:54.430 --> 00:37:59.230
So it's similar to seeing a
drawing directly on screen.

00:37:59.300 --> 00:38:04.280
And you see it's now redrawing the
icon bar at the top of the window.

00:38:04.510 --> 00:38:05.050
With pauses.

00:38:05.060 --> 00:38:06.060
That's not that slow in the back.

00:38:06.100 --> 00:38:08.640
Yeah,
there's a little delay in there that

00:38:08.640 --> 00:38:10.940
you actually see what's going on.

00:38:10.990 --> 00:38:15.670
Okay, and what this application does,
when I type a character,

00:38:15.670 --> 00:38:19.790
you see it's actually redrawing
the scroll bars several times.

00:38:20.500 --> 00:38:31.500
[Transcript missing]

00:38:33.200 --> 00:38:37.900
Sometimes you have an application and
it does not perfectly efficient drawing,

00:38:37.900 --> 00:38:41.260
but you still get away with it
because you have a lot of CPU power.

00:38:41.320 --> 00:38:47.140
Well, you should try to remove those
performance bottlenecks anyway,

00:38:47.160 --> 00:38:50.390
because when the computer
is under heavy load,

00:38:50.390 --> 00:38:52.660
like several other
applications are running,

00:38:52.710 --> 00:38:56.670
then this stuff can actually cause
additional paging because you execute

00:38:56.670 --> 00:38:58.740
code which doesn't need to be executed.

00:38:59.110 --> 00:39:03.390
So,
it is quite a... I would like to advise

00:39:03.480 --> 00:39:05.860
people to actually use that tool and...

00:39:06.490 --> 00:39:11.710
Basically, only draw whatever has changed
and skip everything else.

00:39:11.980 --> 00:39:12.600
Okay.

00:39:12.720 --> 00:39:13.670
Okay, thanks.

00:39:13.830 --> 00:39:15.060
Well, wait a second.

00:39:15.060 --> 00:39:15.900
Oh, wait.

00:39:15.910 --> 00:39:17.700
We have something else.

00:39:17.700 --> 00:39:21.900
You can also get a list from the
Windows Server which lists you all

00:39:21.930 --> 00:39:23.880
Windows that have been allocated.

00:39:24.060 --> 00:39:27.030
So it's probably a bit
hard to see up here,

00:39:27.030 --> 00:39:30.680
but every line represents
a window and you see which

00:39:31.310 --> 00:39:33.460
application has allocated it.

00:39:33.460 --> 00:39:33.460
So, for example,

00:39:33.930 --> 00:39:38.200
Yes, Champollion here has one window
which is about 600 by 500 pixels,

00:39:38.200 --> 00:39:41.570
which is the main document window,
and another window which

00:39:41.590 --> 00:39:45.510
is 1,000 by 22 pixels,
which is the menu bar.

00:39:45.860 --> 00:39:49.870
So,
all of these windows require additional

00:39:49.870 --> 00:39:56.350
memory because there's a backing
store there that catches the bits.

00:39:56.750 --> 00:40:02.720
Essentially, if a window is off-screen,
it is a good idea to release it.

00:40:02.800 --> 00:40:05.290
Otherwise,
you're just spending something like a few

00:40:05.290 --> 00:40:09.740
hundred K of memory just for that window,
and it's usually faster to redraw

00:40:09.740 --> 00:40:13.810
a window when you need it again
than swapping it in from disk.

00:40:14.530 --> 00:40:18.940
So, as a typical example here,
we have a login window here,

00:40:18.940 --> 00:40:22.570
which was launched before
the entire show here started.

00:40:22.570 --> 00:40:25.960
And actually, the login window has its
window allocated somewhere,

00:40:26.000 --> 00:40:27.390
it's just off-screen.

00:40:27.510 --> 00:40:33.050
So here are something like 300K
which could have been saved.

00:40:33.070 --> 00:40:34.060
Okay.

00:40:34.060 --> 00:40:35.060
Great.

00:40:35.060 --> 00:40:37.050
Some great tips there.

00:40:39.700 --> 00:40:45.540
We'll be getting you some of those
tools like the Quartz debug as

00:40:45.540 --> 00:40:49.810
soon as we can after DP4 here.

00:40:53.240 --> 00:40:54.890
Actually,
that one's pretty easy because it is

00:40:55.010 --> 00:41:01.000
really just that app and it just sets
a few bits in the Windows server.

00:41:01.290 --> 00:41:03.180
Future directions.

00:41:03.300 --> 00:41:06.580
As we move forward,
one of the things to notice

00:41:06.760 --> 00:41:10.470
is there hasn't been a huge
change of story in terms of the

00:41:10.470 --> 00:41:12.680
technologies we're working on.

00:41:12.700 --> 00:41:15.970
In terms of 2D, 3D,
we made the OpenGL decision

00:41:15.970 --> 00:41:17.190
over a year ago.

00:41:17.190 --> 00:41:19.640
Media with QuickTime, obviously.

00:41:19.700 --> 00:41:23.820
We're pretty pleased with the core set
of technologies we've picked to focus on,

00:41:23.930 --> 00:41:26.720
and we think that those bets
are really going to pay off.

00:41:26.910 --> 00:41:29.640
What we're doing now
is a couple of things.

00:41:29.770 --> 00:41:33.320
We're continuing in each technology
area to obviously advance

00:41:33.700 --> 00:41:35.530
the state of the art there.

00:41:35.600 --> 00:41:39.590
For example,
in core graphics in the 2D rendering,

00:41:39.610 --> 00:41:43.600
we're looking at things
like raster effects model.

00:41:43.600 --> 00:41:46.090
If you've seen the SVG spec,
there's a pretty sophisticated

00:41:46.100 --> 00:41:47.540
raster effects model in there.

00:41:47.610 --> 00:41:51.930
More extensions for transparency and
blending modes and things like that.

00:41:52.100 --> 00:41:57.900
To really upgrade the 2D graphics
to... be able to do a lot of the

00:41:58.000 --> 00:42:03.320
capabilities on the fly to render
the whole button instead of just

00:42:03.320 --> 00:42:04.770
the label text and things like that.

00:42:04.900 --> 00:42:07.760
To do that, you need a lot of power,
a lot of filtering operations

00:42:07.760 --> 00:42:08.890
and things like that.

00:42:08.940 --> 00:42:14.900
We really see 2D going
towards that expressiveness,

00:42:14.900 --> 00:42:18.570
almost a blend of image processing
and 2D is the direction that

00:42:18.570 --> 00:42:20.900
core graphics is going to go in.

00:42:20.900 --> 00:42:25.130
The other thing that we're really
working on is continuing to look

00:42:25.130 --> 00:42:29.900
for opportunities to integrate all
this technology together better.

00:42:29.900 --> 00:42:32.880
A prime example of that is
OpenGL and the windowing system.

00:42:33.000 --> 00:42:37.640
We didn't show you back in the demo,
but you can actually drag a

00:42:37.660 --> 00:42:41.900
translucent icon over the 3D
content and it all gets mixed in,

00:42:41.960 --> 00:42:46.900
following the mixing metaphor
that we've set up for the desktop.

00:42:46.990 --> 00:42:48.600
Of course,
what we have to do to achieve that,

00:42:48.670 --> 00:42:51.860
you don't want to hear about,
but it actually works.

00:42:51.970 --> 00:42:53.970
There is some loss in frame rate,
but the user experience,

00:42:54.060 --> 00:42:55.390
it just feels like any other window.

00:42:55.400 --> 00:42:58.010
Over time,
we want to be able to do those things

00:42:58.010 --> 00:43:01.950
much more efficiently and hardware,
take advantage of OpenGL within

00:43:01.950 --> 00:43:05.930
the windowing system itself,
and to fully accelerate the whole

00:43:05.930 --> 00:43:07.360
desktop and make a great experience.

00:43:07.460 --> 00:43:12.390
That's another key integration
area that we're looking at as well.

00:43:18.820 --> 00:43:23.430
So the summary here,
if you're doing a Carbon application,

00:43:23.430 --> 00:43:26.930
there's a couple of
simple things you can do.

00:43:27.030 --> 00:43:30.020
You can definitely take a look at
these performance tools and see if

00:43:30.040 --> 00:43:33.490
there's too much flushing going on
or flushing you don't understand.

00:43:33.550 --> 00:43:36.170
A lot of times it's not necessarily
your code if you're using

00:43:36.290 --> 00:43:38.100
Power Plan or something like that.

00:43:38.100 --> 00:43:41.160
The updates may be coming from there,
so kind of chasing down

00:43:41.160 --> 00:43:44.380
through the layers,
making sure that the buffering

00:43:44.380 --> 00:43:46.540
is as efficient as possible.

00:43:46.640 --> 00:43:48.980
And of course,
using QuickTime graphic importers,

00:43:48.990 --> 00:43:51.720
if your application needs to
import any graphical images,

00:43:51.720 --> 00:43:53.090
it's a great way to do that.

00:43:53.250 --> 00:43:59.330
And you'll get the free feature of
the PDF graphics importer on OS X.

00:43:59.750 --> 00:44:02.700
Also, if you're interested in
Mac OS X only opportunities,

00:44:02.700 --> 00:44:05.550
I think there's a real fertile
ground here for applications.

00:44:05.620 --> 00:44:10.290
You consider by the time we ship 1.0,
the average system running OS X,

00:44:10.300 --> 00:44:15.320
if you will, is going to be a pretty
high-performance machine.

00:44:15.320 --> 00:44:19.760
G4s or high clock rate G3s,
good graphics systems.

00:44:19.780 --> 00:44:24.820
You can really target a much
higher functionality set.

00:44:24.840 --> 00:44:28.260
Even for us on OS X,
we do live window drag because

00:44:28.480 --> 00:44:31.230
we're starting from scratch here.

00:44:31.290 --> 00:44:38.220
On OS 9, where you need to go back to
the previous architectures,

00:44:38.270 --> 00:44:39.840
maybe that's not always possible.

00:44:39.840 --> 00:44:41.590
They could probably do it on OS 9 too.

00:44:41.840 --> 00:44:44.600
Just an example of trade-offs where
if you know you're going to be

00:44:44.600 --> 00:44:47.980
hitting a certain performance level,
why not take advantage of it?

00:44:48.120 --> 00:44:51.580
There are some benefits for, say,
the smaller market of OS X.

00:44:51.580 --> 00:44:56.130
You can turn that around to an
opportunity to really take advantage

00:44:56.130 --> 00:44:58.570
of the hardware to its fullest.

00:44:59.110 --> 00:45:02.180
The other thing is the technology
combination or the palette of

00:45:02.240 --> 00:45:04.970
technologies we're offering on
OS X is really kind of a unique

00:45:05.630 --> 00:45:06.990
combination in the industry.

00:45:07.050 --> 00:45:11.910
I think if you look at BSD,
the plumbing and the standard

00:45:11.910 --> 00:45:15.220
Unix facilities there,
up to the stuff we're doing with the

00:45:15.310 --> 00:45:21.000
windowing system and the Quartz APIs,
OpenGL, Cocoa, QuickTime,

00:45:21.000 --> 00:45:24.510
you kind of mix all that stuff
up together and you've got some

00:45:24.520 --> 00:45:29.000
pretty interesting opportunities
to do some pretty innovative apps.

00:45:29.000 --> 00:45:32.960
So if you're looking
for OS X opportunities,

00:45:32.960 --> 00:45:34.990
I would say go for it.

00:45:35.000 --> 00:45:37.250
And hopefully next year
at this conference,

00:45:37.250 --> 00:45:39.730
we'll all be surprised by
the demos you guys give,

00:45:39.730 --> 00:45:41.000
which would be great.

00:45:43.520 --> 00:45:47.520
So I do have some roadmap slides here to
point you at some additional sessions.

00:45:47.520 --> 00:45:51.810
Then I think we're going to have
time for some Q&A after that.

00:45:51.920 --> 00:45:55.230
Today, there's one more session
this afternoon in Room C,

00:45:55.240 --> 00:45:57.750
which is the font management session.

00:45:57.800 --> 00:46:00.750
If you want to learn how
to manage fonts on OS X,

00:46:00.890 --> 00:46:04.950
since they're between the font management
away from the resource manager,

00:46:04.990 --> 00:46:07.200
you need to hear about that.

00:46:07.300 --> 00:46:11.800
On Thursday, there are some sessions
on OpenGL in the morning.

00:46:11.800 --> 00:46:15.270
There's a Beyond Games session
that Jeff Stahl is doing to show

00:46:15.270 --> 00:46:20.290
some of the other ideas for how
you can use OpenGL in not just 3D,

00:46:20.290 --> 00:46:21.200
in games.

00:46:21.400 --> 00:46:25.200
There's an
OpenGL Advanced Optimization session,

00:46:25.200 --> 00:46:30.370
which talks about some of the
extensions that we're working on and

00:46:30.370 --> 00:46:33.160
some of the optimization techniques,
like compiled vertex

00:46:33.160 --> 00:46:35.560
arrays and other things,
if you really want to make your

00:46:35.660 --> 00:46:37.180
frames go as fast as possible.

00:46:37.220 --> 00:46:40.200
There is certain code passed through
OpenGL that you need to be aware of

00:46:40.200 --> 00:46:44.200
if you're really trying to get as
many triangles through as possible.

00:46:44.200 --> 00:46:49.170
There's an OpenGL Feedback
Forum tomorrow as well,

00:46:49.170 --> 00:46:51.200
so you can meet the team,
give them some feedback.

00:46:51.200 --> 00:46:54.200
And tomorrow, of course,
is the Image Capture session also,

00:46:54.200 --> 00:46:57.580
which will be across the street
in the Civic Center to learn

00:46:57.580 --> 00:47:01.200
about the Image Capture framework
and see some demos of that.

00:47:01.200 --> 00:47:02.200
And then, for the rest of the session,
we'll be back with some more information.

00:47:02.310 --> 00:47:04.400
Friday,
we have a pretty full slate for you,

00:47:04.580 --> 00:47:10.130
starting at 9:00, the ColorSync session,
the Mac OS X printing session.

00:47:10.230 --> 00:47:13.200
There are two printing sessions,
introductory and advanced.

00:47:13.330 --> 00:47:17.980
There's the session on the Quartz APIs,
which will be in Hall 2, in here,

00:47:17.980 --> 00:47:19.080
at 2:00.

00:47:19.200 --> 00:47:21.430
And then, finally,
the last event of the conference,

00:47:21.500 --> 00:47:24.280
which you're all going to hang out for,
is the Graphics and

00:47:24.340 --> 00:47:26.200
Printing Feedback session.

00:47:26.230 --> 00:47:28.630
And so we'll all be there,
and you can meet the team and

00:47:28.630 --> 00:47:30.200
give us additional feedback.

00:47:31.460 --> 00:47:34.170
So with that, one more slide.

00:47:34.580 --> 00:47:40.080
Who to contact on the DTS side
at Developer Relations as far as

00:47:40.180 --> 00:47:42.320
our developer partnership folks.

00:47:42.730 --> 00:47:47.210
John Signa,
who is the technology manager for Mac OS,

00:47:47.410 --> 00:47:49.400
Core OS, and Graphics Services.

00:47:49.660 --> 00:47:53.040
Sergio Mello,
who's recently joined the Apple team

00:47:53.050 --> 00:47:55.370
as a 3D technology manager.

00:47:55.640 --> 00:47:57.200
Their email addresses are there.

00:47:57.530 --> 00:48:01.850
And there's a feedback address at
apple.com for graphics feedback as well.

00:48:01.960 --> 00:48:04.670
So you can send stuff there.

00:48:06.100 --> 00:48:10.080
Okay, I'd like to invite a few members
of the team who might be around,

00:48:10.080 --> 00:48:13.890
and John back on stage to
bring up the house lights,

00:48:13.960 --> 00:48:15.360
maybe do a few Q&A here.
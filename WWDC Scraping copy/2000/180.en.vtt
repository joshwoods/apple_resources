WEBVTT

00:00:14.800 --> 00:00:16.650
Well, good afternoon.

00:00:16.700 --> 00:00:18.900
Actually, I am not Steve Naroff.

00:00:19.110 --> 00:00:21.700
For those of you who know me,
and for those of you who don't,

00:00:21.700 --> 00:00:24.730
I'm Alan Samuel,
the Java Technology Manager in

00:00:24.730 --> 00:00:27.880
Apple Worldwide Developer Relations.

00:00:28.180 --> 00:00:31.780
So I think I'm in a very good mood today.

00:00:31.810 --> 00:00:32.900
You guys probably all know why.

00:00:32.900 --> 00:00:38.020
I actually get to stand up here and
hopefully tell you what you want to hear.

00:00:40.210 --> 00:00:42.330
I'm one of those people who's
probably gotten a lot of emails

00:00:42.330 --> 00:00:46.120
from you in the crowd asking me
when are we going to have Java 2?

00:00:46.130 --> 00:00:49.760
And for the first time we're really
able to go out publicly and as you

00:00:49.760 --> 00:00:54.630
saw today in the keynote give you what
you want and talk to you a little bit

00:00:54.760 --> 00:00:58.260
about what we're doing with Java 2.

00:00:58.280 --> 00:01:04.640
And before I bring up Steve,
I just want to go ahead and

00:01:04.890 --> 00:01:11.110
Put a general thank you out to all the
engineers that work on Java at Apple.

00:01:11.220 --> 00:01:17.100
I think these guys have
basically gone a long way.

00:01:17.100 --> 00:01:20.330
We've come from a situation where
you could say in the MRJ land,

00:01:20.330 --> 00:01:24.140
maybe we weren't doing as
good as we'd like to be.

00:01:24.140 --> 00:01:28.370
And I think we are in a prime position
to be a leader in the Java platform.

00:01:28.470 --> 00:01:32.550
And I think today's the day we start
to tell you all the information

00:01:32.550 --> 00:01:34.860
that you need to make that happen.

00:01:34.860 --> 00:01:39.670
So I want to give a little
hand to the entire Java team.

00:01:43.300 --> 00:01:54.200
[Transcript missing]

00:01:57.300 --> 00:02:05.900
[Transcript missing]

00:02:07.200 --> 00:02:09.300
I want to take a quick poll.

00:02:09.300 --> 00:02:12.740
How many folks were here last year?

00:02:12.740 --> 00:02:13.090
Quite a few.

00:02:13.380 --> 00:02:16.180
At the Java talk, not only WWDC?

00:02:16.380 --> 00:02:18.020
Okay, great.

00:02:18.020 --> 00:02:24.260
You know where we've come from,
so I won't belabor it too much.

00:02:24.260 --> 00:02:27.280
As Alan said,
the team has really come together,

00:02:27.280 --> 00:02:30.830
not only the engineering team,
but the developer support team,

00:02:30.940 --> 00:02:34.100
Alan and his folks,
that help a lot of you guys before we

00:02:34.100 --> 00:02:38.580
get a chance to help a lot of you guys.

00:02:38.650 --> 00:02:42.260
So I think all across the company we've
pulled together and made Java actually

00:02:42.310 --> 00:02:46.320
pretty relevant in the Apple community,
and I think it's just going

00:02:46.410 --> 00:02:47.880
to get better and better.

00:02:47.880 --> 00:02:54.280
You saw in the keynote that we're going
to be offering Java 2 on Mac OS X.

00:02:54.280 --> 00:02:56.600
It's a great fit.

00:02:56.830 --> 00:03:03.740
The Mac OS X platform is a
great foundation for Java.

00:03:04.050 --> 00:03:09.040
A lot of the modern components of
the operating system are components

00:03:09.040 --> 00:03:13.000
that Java really depends on,
like the preemptive, multitasking,

00:03:13.000 --> 00:03:14.490
protected memory, all that good stuff.

00:03:14.570 --> 00:03:17.250
You've heard a lot of the
features in Bertrand's talk,

00:03:17.310 --> 00:03:17.930
I'm sure.

00:03:18.000 --> 00:03:19.830
I think most of you attended that.

00:03:19.860 --> 00:03:24.180
Java was developed on Unix
in a modern operating system,

00:03:24.180 --> 00:03:27.520
so again,
it benefits us as we move the technology

00:03:27.520 --> 00:03:33.810
forward to be on a modern operating
system and have modern underpinnings.

00:03:34.900 --> 00:03:38.400
The Java that we're going to be
shipping is Java 2 Standard Edition.

00:03:38.680 --> 00:03:41.800
Later on I'll talk a little
bit more about what that means.

00:03:41.800 --> 00:03:45.010
The Swing UI toolkit is built
into the Standard Edition,

00:03:45.010 --> 00:03:46.780
if you aren't aware of that.

00:03:46.800 --> 00:03:51.800
Swing is the modern GUI toolkit that
people use to write Java applications.

00:03:51.800 --> 00:03:59.800
AWT was a smaller UI toolkit that
was used primarily for applets.

00:03:59.980 --> 00:04:02.800
The two coexist right now in
the Java 2 Standard Edition.

00:04:02.800 --> 00:04:06.460
We've done a lot to integrate with Aqua.

00:04:06.800 --> 00:04:11.800
The demo that you saw on
stage with WebObjects,

00:04:11.800 --> 00:04:15.800
that UI was a Swing application.

00:04:15.800 --> 00:04:20.800
It was a pure Java Swing,
Java 2 Standard Edition application.

00:04:20.800 --> 00:04:24.640
It wasn't Cocoa, for instance.

00:04:25.050 --> 00:04:29.290
That user interface work was done
by a very talented person we have

00:04:29.610 --> 00:04:33.550
working on our staff from Sun,
named Leanne Rucker.

00:04:33.790 --> 00:04:37.800
I know she worked really
hard with the WebObjects team

00:04:37.800 --> 00:04:39.800
to get that demo together.

00:04:40.950 --> 00:04:44.960
and last and definitely not least,
we have the Hotspot Client VM.

00:04:45.010 --> 00:04:52.880
This is an extremely robust
VM that in many cases is a second

00:04:52.880 --> 00:04:55.760
or third generation technology.

00:04:55.760 --> 00:04:59.500
The garbage collection technology
in it is state of the art.

00:05:00.110 --> 00:05:03.900
The compiler in it is state of the art.

00:05:03.900 --> 00:05:07.080
We'll go through some numbers later.

00:05:07.080 --> 00:05:11.850
The team, Ivan Posva, Jim Lasky,
are our two leads on that project.

00:05:12.000 --> 00:05:17.320
Just incredible results
with the Hotspot technology.

00:05:17.320 --> 00:05:20.570
It was the type of decision that
we were contemplating last year.

00:05:20.570 --> 00:05:22.680
I think we talked about that.

00:05:22.680 --> 00:05:24.930
We were disappointed that
we couldn't tell you that we

00:05:25.040 --> 00:05:26.500
were going to commit to it.

00:05:26.590 --> 00:05:28.690
That's because we didn't know last year.

00:05:28.690 --> 00:05:34.380
It's amazing how well that
technology has worked out for us.

00:05:34.380 --> 00:05:37.850
Now we'll go through a brief timeline.

00:05:41.140 --> 00:05:45.440
In February of '99,
right before last year's WWDC,

00:05:45.440 --> 00:05:49.400
we shipped MRJ 2.1 GM.

00:05:49.400 --> 00:05:57.500
And that was the first release of
Java that I think the team felt proud of.

00:05:57.500 --> 00:06:01.230
We felt proud of it because
it performed fairly well.

00:06:01.230 --> 00:06:04.760
It didn't exceed our expectations,
but I think met our

00:06:04.760 --> 00:06:06.770
expectations in many ways.

00:06:06.920 --> 00:06:10.540
But more importantly,
it ran a lot of applications.

00:06:10.540 --> 00:06:12.870
And that's something that
MRJ 2.0 was not doing.

00:06:13.020 --> 00:06:15.090
It was not running a lot of applications.

00:06:15.090 --> 00:06:18.560
It was crashing and it was dying
and it just wasn't the type of

00:06:18.560 --> 00:06:20.880
robust platform that we all wanted.

00:06:20.880 --> 00:06:24.080
So 2.1 was a real breakthrough for us.

00:06:24.080 --> 00:06:28.200
I think it delivered on the
strategy we outlined in '98.

00:06:28.550 --> 00:06:33.040
and it's interesting because
when I stood up here in '98,

00:06:33.040 --> 00:06:37.060
I was trying to think how could
I put in perspective for you guys.

00:06:37.140 --> 00:06:42.170
I felt about four feet tall
when I stood up here in '98.

00:06:42.170 --> 00:06:45.500
And last year I felt 5'7",
which is actually what I am.

00:06:45.500 --> 00:06:51.500
And because we delivered on a strategy,
we still weren't happy

00:06:51.500 --> 00:06:53.500
with where we were,
but we knew where we were going.

00:06:53.740 --> 00:06:57.710
This year I feel 7' tall and
you can tell I'm not 7' tall,

00:06:57.710 --> 00:06:59.200
but I feel that way.

00:06:59.310 --> 00:07:03.170
And I feel that way because again,
I'm standing on the shoulders of

00:07:03.600 --> 00:07:07.360
some really great people that make
it fun to come to work every day,

00:07:07.400 --> 00:07:08.260
frankly.

00:07:08.510 --> 00:07:14.250
Another part of the strategy
we delivered on is we wanted to

00:07:15.160 --> 00:07:19.220
give you incremental releases that
fixed incremental bugs and solved

00:07:19.220 --> 00:07:21.940
incremental performance problems.

00:07:21.940 --> 00:07:24.840
So we did a release in March, May,
and July.

00:07:24.840 --> 00:07:28.670
And that was another promise
that I think we've done a good

00:07:28.710 --> 00:07:32.080
job delivering on or keeping,
was that we didn't want to

00:07:32.080 --> 00:07:33.580
go dark for nine months.

00:07:33.580 --> 00:07:36.700
And that was a problem before,
that we would just wait too long

00:07:36.700 --> 00:07:38.920
before we'd show incremental progress.

00:07:38.920 --> 00:07:42.280
So I thank the team for working
hard on those incremental releases.

00:07:42.680 --> 00:07:48.380
And those are driven by emails, bugs,
customer requests.

00:07:48.380 --> 00:07:51.780
I really feel that we do a pretty
good job trying to prioritize

00:07:51.890 --> 00:07:55.200
what we're hearing from you and
building it into the product.

00:07:55.200 --> 00:07:58.740
If not, you need to get a hold of our,
if there are features that you've

00:07:58.740 --> 00:08:02.360
requested or bugs that you haven't
seen fixed throughout the dot

00:08:02.360 --> 00:08:06.160
releases that we've released,
you just need to get a hold of Alan or

00:08:06.160 --> 00:08:10.270
our developer support team and make
sure that feedback gets back to us.

00:08:10.280 --> 00:08:12.660
So along with the 2.1.1.

00:08:12.680 --> 00:08:16.600
1.3, we shipped 2.2 alpha.

00:08:19.320 --> 00:08:24.640
and 214 was the last of
our 2.1 based releases.

00:08:24.640 --> 00:08:27.570
The milestone there was we met
Oracle Bronze Certification.

00:08:27.620 --> 00:08:30.420
We've been working really closely
with Oracle because they're a

00:08:30.530 --> 00:08:34.520
very heavy Java user and they want
to make sure their applications

00:08:34.520 --> 00:08:36.840
run really great on our platform.

00:08:36.840 --> 00:08:40.310
We've, again, worked closely with them
to make that happen.

00:08:45.750 --> 00:08:48.540
So in October, we released DP2.

00:08:48.540 --> 00:08:51.560
That was our first Java 2-based VM.

00:08:51.560 --> 00:08:53.600
So that's when,
even though we made no public statements

00:08:53.640 --> 00:08:57.040
about where we're going with Java 2,
folks looked under the covers and

00:08:57.130 --> 00:08:59.160
started figuring it out for themselves.

00:09:00.740 --> 00:09:02.490
And we did a 2.2 beta.

00:09:02.490 --> 00:09:06.600
And then in January, we went GM with 2.2.

00:09:06.600 --> 00:09:12.070
2.2 was our, for lack of a better term,
IE 5.0 release.

00:09:12.400 --> 00:09:18.070
We did fix bugs outside IE 5.0,
but it really was targeted at giving

00:09:18.070 --> 00:09:24.480
the user or developer a better
experience within the scope of IE 5.0.

00:09:24.760 --> 00:09:29.290
and then we did DP3,
which added the classes.

00:09:29.560 --> 00:09:31.040
It was our first release.

00:09:31.070 --> 00:09:33.840
There were still a lot of bugs in it.

00:09:33.840 --> 00:09:38.380
Here we're at DP4, and the big addition
is the Hotspot client,

00:09:38.380 --> 00:09:42.700
and many,
many bug fixes to the Java classes,

00:09:42.700 --> 00:09:45.780
which we released in DP3.

00:09:45.780 --> 00:09:47.060
That's been the progression.

00:09:47.060 --> 00:09:48.100
It's been a lot of work.

00:09:48.100 --> 00:09:53.140
We actually combined our Java 2
MRJ team with our Mac 10 Java team,

00:09:53.140 --> 00:09:54.760
so now we're one Java team.

00:09:54.760 --> 00:09:58.250
I think the productivity enhancements
we've gotten from even making that

00:09:58.250 --> 00:09:59.750
change has been pretty dramatic.

00:10:00.220 --> 00:10:02.320
Again, I'm thrilled with the last year.

00:10:02.410 --> 00:10:06.320
I think a lot of people working on the
team look back and are probably startled

00:10:06.380 --> 00:10:08.980
with how much we actually accomplished.

00:10:09.150 --> 00:10:14.680
So before I go into the crux of the talk,
which is centered around Mac 10,

00:10:14.760 --> 00:10:19.270
I'd like to briefly go over
our currently shipping product.

00:10:21.080 --> 00:10:22.500
It's MRJ 2.2.

00:10:22.500 --> 00:10:26.700
I believe the latest version,
minor version, is MRJ 2.2.1,

00:10:26.710 --> 00:10:31.870
and it integrates with
the IE5 networking stack.

00:10:32.090 --> 00:10:34.840
Cabinet File Support, Cookie Support,
Applicaching,

00:10:34.840 --> 00:10:38.000
all these features you're probably aware
of if you've been using the product.

00:10:38.110 --> 00:10:40.900
How many people are using 2.2 right now?

00:10:40.990 --> 00:10:43.460
Okay, so you're familiar with it.

00:10:43.460 --> 00:10:47.420
And we added along file name support.

00:10:47.790 --> 00:10:50.770
So that's our Mac 9 product,
and we're going to continue to

00:10:50.800 --> 00:10:55.710
enhance it along the 118 code base.

00:10:55.810 --> 00:11:00.410
And now I'd like to go
into the crux of the talk,

00:11:00.520 --> 00:11:03.860
which centers around
a three-mug strategy.

00:11:03.980 --> 00:11:04.820
Cutesy.

00:11:05.170 --> 00:11:07.410
So we have performance.

00:11:07.500 --> 00:11:29.400
[Transcript missing]

00:11:30.080 --> 00:11:35.040
So SpecJVM 98 is the benchmark
we're currently using.

00:11:35.040 --> 00:11:39.000
You might remember in previous years,
we were using caffeine marks.

00:11:39.000 --> 00:11:43.000
We decided, along with a lot of other
folks in the industry,

00:11:43.200 --> 00:11:46.720
that caffeine marks are not a
great measure of performance.

00:11:46.720 --> 00:11:51.270
So we decided to look for a
benchmark which would meet our needs,

00:11:51.270 --> 00:11:55.340
and in fact came up with
the SpecJVM 98 benchmark.

00:11:55.340 --> 00:12:00.070
These performance numbers I'm
going to show you are for DP4.

00:12:04.070 --> 00:12:06.590
Just to be clear,
the numbers you're seeing

00:12:06.880 --> 00:12:08.010
here are not seconds.

00:12:08.170 --> 00:12:09.220
They're a score.

00:12:09.220 --> 00:12:13.530
So it's a score that the
spec JVM benchmark gives you,

00:12:13.860 --> 00:12:17.200
and higher is better,
as you might imagine.

00:12:17.200 --> 00:12:22.750
And right here we have the orange,
which is basically the interpreter

00:12:22.830 --> 00:12:25.500
running without the compiler.

00:12:25.500 --> 00:12:32.500
So the classic Java Virtual Machine prior
to Hotspot was running at 1.8.

00:12:32.500 --> 00:12:38.000
The interpreted Hotspot runs at 2.6,
which is roughly a 50% increase.

00:12:38.000 --> 00:12:41.500
And you can see the
green is the compiler.

00:12:41.500 --> 00:12:45.780
The compiler in both cases
runs roughly 10 times faster

00:12:45.780 --> 00:12:47.700
than the interpreted code.

00:12:48.000 --> 00:12:53.010
But what's much more important
and compelling than the 50%

00:12:53.010 --> 00:13:01.400
boost we get is the amazing,
amazing reduction in memory.

00:13:01.400 --> 00:13:01.400
Amazing reduction in memory.

00:13:06.690 --> 00:13:11.900
Taking pages off disk is very costly.

00:13:11.900 --> 00:13:16.600
It's clear that even though we've
upgraded most Macs with 64MB now,

00:13:16.600 --> 00:13:23.600
asking people to have upwards to
128 and 256MB is not appropriate.

00:13:23.600 --> 00:13:26.610
We want to find ways to
make Java programs run

00:13:26.800 --> 00:13:28.600
in a sensible footprint.

00:13:28.600 --> 00:13:33.950
So what this graph tells you is
it only costs 7MB to run this

00:13:33.950 --> 00:13:36.600
benchmark in compiled mode.

00:13:36.600 --> 00:13:41.750
And that 7MB not only includes
the compiled data structures,

00:13:41.750 --> 00:13:46.600
but it includes the data structures
for the compiler itself to do its job.

00:13:46.750 --> 00:13:51.510
And it's going to be, I think,
roughly 40-60, 50-50 split.

00:13:51.610 --> 00:13:56.580
But in any event, from my perspective,
that's a reasonable price

00:13:56.580 --> 00:13:58.590
to pay for compilation.

00:13:58.610 --> 00:14:02.600
And if you do the math,
it's 4.5 times smaller.

00:14:02.600 --> 00:14:06.690
And we've seen this translate
into not only our benchmarks,

00:14:06.710 --> 00:14:11.600
but all the applications we're running
use far less memory than they used to.

00:14:11.710 --> 00:14:13.600
So we're extremely excited about this.

00:14:13.600 --> 00:14:15.290
It's only DP4.

00:14:15.700 --> 00:14:17.600
We still have a lot of tweaking to do.

00:14:17.600 --> 00:14:22.580
But we still feel fairly confident that
we're heading in the right direction.

00:14:22.870 --> 00:14:25.510
The thing that...

00:14:25.840 --> 00:14:28.900
Just briefly about adaptive
compilation technology,

00:14:28.900 --> 00:14:33.760
the reason it's so much less is in
the semantic JIT world where you're

00:14:33.760 --> 00:14:38.140
running in a classic virtual machine,
what the compiler tries to

00:14:38.220 --> 00:14:40.490
do is compile everything.

00:14:40.520 --> 00:14:44.320
That's its goal in life,
to try and make everything fast.

00:14:44.320 --> 00:14:50.300
What happens with a hotspot adaptive
technology is it measures itself.

00:14:50.300 --> 00:14:53.830
As the program's running,
it tries hard to only compile the

00:14:53.830 --> 00:14:57.660
things that matter and not compile
the things that don't matter.

00:14:57.660 --> 00:15:03.160
An obvious example of something that
doesn't matter is an initialized method.

00:15:03.160 --> 00:15:06.790
There are obviously lots of
other methods that are used once,

00:15:06.790 --> 00:15:10.560
twice, maybe used a lot for, let's say,
printing, but then printing gets swapped

00:15:10.600 --> 00:15:12.040
out and you don't need it anymore.

00:15:12.040 --> 00:15:16.820
The hotspot adaptive compilation
system is always measuring to make sure

00:15:16.820 --> 00:15:19.490
that it's compiling the right stuff.

00:15:20.480 --> 00:15:22.740
and SpecJVM is measuring.

00:15:22.840 --> 00:15:26.340
It's basically a suite of applications.

00:15:26.600 --> 00:15:28.400
I think it's six altogether.

00:15:28.400 --> 00:15:30.290
Database, the Java compiler.

00:15:30.290 --> 00:15:36.390
I think our Java compiler is two to three
times faster now as a result of Hotspot.

00:15:37.170 --> 00:15:40.290
There's a compiler compiler
for Purdue in there.

00:15:40.430 --> 00:15:43.490
There's data compression,
an expert system shell,

00:15:43.490 --> 00:15:45.090
and MPEG audio decompression.

00:15:45.100 --> 00:15:50.100
So you can see these are applications
that most of you have probably heard of.

00:15:50.100 --> 00:15:51.100
Certainly you know Java.

00:15:51.100 --> 00:15:53.800
The Java compiler,
you've heard of database,

00:15:53.800 --> 00:15:57.100
you've heard of compiler compilers,
data compression.

00:15:57.100 --> 00:16:01.570
All this stuff is stuff that benefits
real world applications that are

00:16:01.570 --> 00:16:03.850
being used out in the Java community.

00:16:05.630 --> 00:16:08.540
So what do we have left?

00:16:08.560 --> 00:16:09.600
Hotspot tuning.

00:16:09.610 --> 00:16:11.000
This is our first release.

00:16:11.000 --> 00:16:14.680
Even though we're happy,
we still have a ways to go.

00:16:14.880 --> 00:16:17.100
Graphics Tuning.

00:16:17.100 --> 00:16:19.230
Especially AWT,
there's still some issues with how

00:16:19.380 --> 00:16:23.350
we integrate with Quartz and the
windowing system that we need to

00:16:23.350 --> 00:16:27.220
resolve before we're really happy
with our AWT graphics performance.

00:16:27.320 --> 00:16:29.320
We're fairly happy with
the swing performance,

00:16:29.320 --> 00:16:32.720
and you'll see a demo later that
I think will show you that we're

00:16:32.720 --> 00:16:37.710
in pretty good shape with swing,
yet we still have some work to do there.

00:16:38.840 --> 00:16:44.380
This is a feature which I've
been persistent about for years,

00:16:44.450 --> 00:16:47.400
and I think we're finally getting
to the point we're going to have it,

00:16:47.400 --> 00:16:52.730
I believe, hopefully by GM,
is the ability to run multiple

00:16:52.830 --> 00:16:56.300
Java applications and share
a lot of its metadata.

00:16:56.300 --> 00:16:59.460
It turns out that if you
look at a class file,

00:16:59.460 --> 00:17:05.180
the instruction stream is only a small
part of what makes up a .class file.

00:17:05.530 --> 00:17:08.260
There's an awful lot
of metadata in there,

00:17:08.260 --> 00:17:13.760
and if you don't share that metadata
across invocations of a Java VM,

00:17:13.890 --> 00:17:16.140
then you could end up eating
lots and lots of memory,

00:17:16.140 --> 00:17:17.660
especially for something like Swing.

00:17:17.660 --> 00:17:19.800
It's a fairly large UI toolkit.

00:17:19.800 --> 00:17:24.020
So, again,
imagine running five Java applications.

00:17:24.020 --> 00:17:26.210
You want them to share
as much data as possible,

00:17:26.210 --> 00:17:27.980
again, to get the footprint down.

00:17:31.300 --> 00:17:33.860
And last and not least, launch time.

00:17:33.860 --> 00:17:38.880
We're very adamant that applications have
to launch in a fairly sensible timeframe,

00:17:38.880 --> 00:17:41.960
where sensible is between
one and five seconds.

00:17:41.960 --> 00:17:47.630
And we have some very large
Java apps we're running now that

00:17:47.690 --> 00:17:51.300
take about ten seconds on Mac OS X.

00:17:51.300 --> 00:17:52.940
And again, we'll show you that.

00:17:52.940 --> 00:17:54.980
We hope to get that down to five seconds.

00:17:55.600 --> 00:17:59.180
But it's certainly a long
way from where we've come,

00:17:59.180 --> 00:18:04.100
where some Java applications on MRJ on
Mac 9 could take as much as 30 seconds,

00:18:04.100 --> 00:18:05.380
30, 40, 50 seconds.

00:18:07.650 --> 00:18:11.000
Here's a quick pointer.

00:18:11.080 --> 00:18:13.980
Three incredibly talented people,
two in the VM space,

00:18:14.120 --> 00:18:17.970
and one graphics nut, John Berkey.

00:18:18.330 --> 00:18:22.830
Why does it say Jim Berkey?

00:18:22.830 --> 00:18:22.830
Did I say Jim?

00:18:25.600 --> 00:18:39.300
[Transcript missing]

00:18:41.290 --> 00:18:42.810
Compatibility.

00:18:42.810 --> 00:18:46.700
This section of the talk
is mostly Sun stuff,

00:18:46.700 --> 00:18:50.790
but I still think it's
important to review with you.

00:18:51.210 --> 00:18:53.980
If you haven't kept up
with the Java lingo,

00:18:53.980 --> 00:18:57.100
when they went to Java 2,
they defined a whole new process,

00:18:57.100 --> 00:19:00.360
they defined a whole new set of terms,
and so on.

00:19:00.360 --> 00:19:04.640
And a lot of that was actually good,
but it takes some getting used to.

00:19:04.640 --> 00:19:08.120
And standard edition is called J2SE,
that's the acronym that

00:19:08.120 --> 00:19:09.100
a lot of people use.

00:19:09.500 --> 00:19:12.880
There's a micro edition,
and there's an enterprise edition.

00:19:12.880 --> 00:19:17.860
Right now, we're focusing on the orange,
which is the standard edition.

00:19:18.860 --> 00:19:22.100
I think it might be
better termed desktop,

00:19:22.130 --> 00:19:24.030
so that's why I put that up.

00:19:24.190 --> 00:19:27.680
The micro edition is probably
better termed embedded,

00:19:27.680 --> 00:19:30.550
and you can think of the
enterprise edition as the server.

00:19:30.700 --> 00:19:35.450
So since desktop is our focus at Apple,
we want to be great on the desktop,

00:19:35.710 --> 00:19:39.680
and then potentially worry about
some of the other editions.

00:19:39.840 --> 00:19:44.470
Web objects, for instance,
might take some components from J2EE,

00:19:44.840 --> 00:19:46.620
like Java beans,
but might not support the

00:19:46.620 --> 00:19:46.620
whole stack in its entirety.

00:19:46.620 --> 00:19:52.790
Those are decisions that
we have yet to make.

00:19:53.810 --> 00:19:56.820
So, key features.

00:19:56.820 --> 00:19:59.100
Swing interface objects,
I guess one of the more compelling

00:19:59.100 --> 00:20:03.800
features of Swing is it supports
multiple platform look and feels,

00:20:03.800 --> 00:20:05.180
and we'll get into that later.

00:20:05.180 --> 00:20:08.380
Java 2D, advanced graphics support.

00:20:08.380 --> 00:20:11.550
The Java 2D API is actually
very similar and supports a

00:20:11.640 --> 00:20:13.560
similar feature set to Quartz.

00:20:13.560 --> 00:20:17.120
And, in fact,
our implementation on Mac 10

00:20:17.120 --> 00:20:19.280
relies heavily on Quartz.

00:20:21.370 --> 00:20:23.970
There's new collection classes.

00:20:25.540 --> 00:20:30.440
Drag and drop is a feature that
I believe we have in our MRJ.

00:20:30.440 --> 00:20:32.840
We put that in as a stopgap.

00:20:32.840 --> 00:20:37.650
It was modeled after the Java 2 support,
so now we're just relying on the standard

00:20:37.930 --> 00:20:40.240
drag and drop that Java 2 supports.

00:20:40.400 --> 00:20:46.710
We have print support and improved
font and international text.

00:20:48.000 --> 00:20:51.390
There's a very fancy
policy-based security mechanism.

00:20:51.500 --> 00:20:52.480
There's Corva support.

00:20:52.810 --> 00:20:56.400
For those who are unfamiliar with Corva,
Corva is a way for other

00:20:56.400 --> 00:21:00.900
languages and other processes
to talk to Java and vice versa.

00:21:00.980 --> 00:21:05.370
Many people are using that
technology in the enterprise.

00:21:05.560 --> 00:21:11.260
A really cool feature of Java 2 is
they've really taken each subcomponent

00:21:11.260 --> 00:21:13.750
of the VM and made some nice APIs to it.

00:21:13.760 --> 00:21:17.240
For instance, there's a JNI.h JVM.

00:21:17.240 --> 00:21:20.070
These are all interfaces which,
if you wanted to plug your own

00:21:20.070 --> 00:21:23.400
VM into our implementation,
you could.

00:21:23.400 --> 00:21:26.420
I don't anticipate that most of
you are going to go to the trouble

00:21:26.420 --> 00:21:29.720
of implementing your own VM,
but some of you may plug into the

00:21:29.720 --> 00:21:31.980
debugger or the profile interface.

00:21:32.640 --> 00:21:36.750
That enables you to basically write
GUI-based tools atop our VM for

00:21:37.160 --> 00:21:40.370
profiling and debugging and so on.

00:21:40.400 --> 00:21:43.150
For instance,
those are the APIs that MetroWorks,

00:21:43.150 --> 00:21:46.570
CodeWarrior, Project Builder,
and so on and so forth use.

00:21:46.580 --> 00:21:48.400
Sound support.

00:21:50.190 --> 00:21:52.320
and a ton of other stuff.

00:21:52.430 --> 00:21:54.320
It's huge.

00:21:54.320 --> 00:21:55.900
Talking about that.

00:21:55.900 --> 00:22:01.800
1.1.8 is a set of 23 packages,
about 5,000 members.

00:22:01.800 --> 00:22:05.600
Java 2 Standard Edition is
a huge platform.

00:22:05.600 --> 00:22:10.260
It offers a ton of functionality.

00:22:10.260 --> 00:22:12.400
We went through this last year,
people who were here.

00:22:12.400 --> 00:22:15.690
It contains about three times more APIs.

00:22:16.100 --> 00:22:21.870
Now, whenever you do that big a
release where you've expanded the

00:22:21.870 --> 00:22:26.390
API surface area by three times and
you've made all kinds of changes,

00:22:26.390 --> 00:22:29.340
you're undoubtedly going to break people.

00:22:29.340 --> 00:22:33.270
That's one of the concerns that
people had in the Java community

00:22:33.370 --> 00:22:37.950
is as they take their 1.1 apps,
it can be challenging to find

00:22:38.060 --> 00:22:45.430
the compatibility differences,
particularly in the AWT area.

00:22:47.180 --> 00:22:49.200
This is an issue that
we're working on with Sun.

00:22:49.200 --> 00:22:51.540
All the licensees are
working on with Sun.

00:22:51.540 --> 00:22:53.680
I don't think Sun will
ever make that big a leap.

00:22:53.680 --> 00:22:56.440
That is,
add three times more APIs at one step.

00:22:56.440 --> 00:22:59.700
I think they've learned their lesson,
so to speak,

00:22:59.700 --> 00:23:02.740
and the releases that will be
coming out now will be more

00:23:02.740 --> 00:23:04.220
of an incremental fashion.

00:23:04.220 --> 00:23:09.980
Again, it's just more sensible to
incrementally release these

00:23:09.980 --> 00:23:13.380
APIs rather than go to 3X overnight.

00:23:13.380 --> 00:23:16.240
As a result,
mission-critical applications

00:23:17.110 --> 00:23:18.650
have been slow to move.

00:23:19.300 --> 00:23:23.230
There's a very good 15-page
document on the web.

00:23:23.290 --> 00:23:26.960
If you're interested and concerned
about moving your 1.1 code to 2.0,

00:23:27.120 --> 00:23:28.240
reference this document.

00:23:28.240 --> 00:23:35.400
It has a ton of great information
on what the source level,

00:23:35.400 --> 00:23:38.780
binary, and other types of changes that
you're likely to encounter.

00:23:39.150 --> 00:23:45.580
And in general, new Java applications are
targeting the Java 2 platform.

00:23:45.610 --> 00:23:49.810
Applets aren't being written
to Java 2 in general.

00:23:50.990 --> 00:23:58.500
So we test our Java product
with something called the JCK,

00:23:58.500 --> 00:24:02.520
the Java Conformance Kit or
Compliance Kit from Sun.

00:24:02.520 --> 00:24:06.330
And we're obligated as
licensees to pass it.

00:24:06.900 --> 00:24:11.350
But what's much more compelling to me is
how many real world applications we run.

00:24:11.400 --> 00:24:15.400
So for instance,
Oracle has 40,000 test suites.

00:24:15.590 --> 00:24:19.810
We currently pass their tests as
well and are continuing to work with

00:24:19.810 --> 00:24:20.880
them on passing even more tests.

00:24:34.700 --> 00:24:43.400
Charles Schwab has this
really cool trading app.

00:24:43.400 --> 00:24:43.400
It was advertised in this guy over here.

00:25:01.490 --> 00:25:01.490
It's called Velocity.

00:25:01.490 --> 00:25:01.490
Anyway.

00:25:01.490 --> 00:25:01.490
But it's our first example of
a shrink-wrapped Java app that

00:25:01.490 --> 00:25:01.490
actually people are using day to day,
in this case for trading stocks,

00:25:01.490 --> 00:25:01.490
a pretty mission critical thing,
if that's what you want to do.

00:25:01.490 --> 00:25:01.490
And it's...

00:25:02.220 --> 00:25:03.580
That's worked incredibly well.

00:25:03.580 --> 00:25:06.360
We're extremely happy with the
reliability of that product as well,

00:25:06.360 --> 00:25:08.100
and they've been great to work with.

00:25:08.180 --> 00:25:11.350
And SAP is another company we're
working closely with to make sure

00:25:11.350 --> 00:25:15.640
their enterprise applications
are working really well.

00:25:15.720 --> 00:25:23.460
We're getting a lot of testing,
and it's really neat to see how

00:25:23.460 --> 00:25:27.840
relevant actually this Java technology
has become in the enterprise space.

00:25:27.940 --> 00:25:32.060
So with that in mind,
I'd like to bring up someone from Oracle.

00:25:32.130 --> 00:25:34.250
His name is Peter Heller.

00:25:34.320 --> 00:25:35.930
Thanks, Peter.

00:25:43.660 --> 00:25:45.100
Okay.

00:25:45.100 --> 00:25:50.280
Our apps, this is, excuse me,
there's actually just one great word,

00:25:50.280 --> 00:25:52.560
which is finally.

00:25:52.760 --> 00:25:55.140
We've been working,
I've been working with Apple on

00:25:55.140 --> 00:25:58.650
trying to get our apps running on
their Mac platform and a variety

00:25:58.650 --> 00:26:02.450
of hardware OSs in the past for,
I think, three or four years.

00:26:02.450 --> 00:26:05.180
So we've finally actually
been able to achieve this

00:26:05.180 --> 00:26:07.680
with the most recent release.

00:26:07.680 --> 00:26:10.670
If you don't know Oracle apps,
Oracle apps are basically

00:26:11.030 --> 00:26:14.230
mission critical enterprise
apps dealing with financials and

00:26:14.230 --> 00:26:18.370
manufacturing and CRM applications,
call centers, sales force automation,

00:26:18.370 --> 00:26:19.880
all these different things.

00:26:19.880 --> 00:26:21.360
There are 70 in total.

00:26:21.360 --> 00:26:24.740
And our co-markets really are
the university market and a

00:26:24.740 --> 00:26:28.410
lot of creative services firms,
people that are, obviously have Mac as

00:26:28.410 --> 00:26:29.590
a dedicated platform.

00:26:29.780 --> 00:26:32.460
And they also want to run
their standard business apps.

00:26:32.460 --> 00:26:35.480
They don't want to have to have
them sit side by side with PCs.

00:26:35.480 --> 00:26:40.520
So we have actually, I think easily,
a hundred million dollars of potential

00:26:40.520 --> 00:26:44.360
revenue that we could probably earn,
we will probably earn as we

00:26:44.360 --> 00:26:46.120
move forward into this space.

00:26:46.200 --> 00:26:48.780
So that's a great
opportunity for you as well.

00:26:48.850 --> 00:26:54.040
What I thought I'd do is just show
you a little bit about our apps.

00:26:54.050 --> 00:26:58.020
If we can switch to the system.

00:26:58.230 --> 00:27:03.740
This is,
these apps are built with Oracle's Jade,

00:27:03.950 --> 00:27:09.480
with Oracle's developer tool,
which is a 4GL style tool and

00:27:09.490 --> 00:27:12.140
it runs now on the Mac platform.

00:27:12.140 --> 00:27:15.000
So what we're looking at here is,
this is just going to be a

00:27:15.000 --> 00:27:18.860
quick general ledger example,
but basically what we have

00:27:18.930 --> 00:27:21.120
is a process flow navigator.

00:27:21.120 --> 00:27:25.080
So users as they want to do transactions,
whether it's purchasing or general ledger

00:27:25.080 --> 00:27:28.800
or manufacturing or billing or whatever,
they have a kind of a map that

00:27:28.800 --> 00:27:32.800
they can walk through as they
go through the transactions.

00:27:32.800 --> 00:27:34.760
So one of the things
that we can do here is,

00:27:34.760 --> 00:27:37.510
for instance, let's say we were going
to reclassify our revenue.

00:27:37.620 --> 00:27:40.600
As we move through these maps,
you get a little green line.

00:27:40.600 --> 00:27:40.600
You can see that we have a map that says,
"I'm going to go through this.

00:27:40.600 --> 00:27:49.290
I'm going to go through this." And then
you can see that we have a map that says,

00:27:49.290 --> 00:27:49.290
"I'm

00:27:50.520 --> 00:27:55.390
The App comes up relatively quickly.

00:27:55.440 --> 00:27:57.400
I guess I should also
mention the environment here.

00:27:57.540 --> 00:28:00.740
All we've got here running
is Internet Explorer with

00:28:00.740 --> 00:28:05.510
the standard Apple MRJ,
and all of our apps and everything is

00:28:05.510 --> 00:28:09.980
across the network at Oracle Corporate.

00:28:09.980 --> 00:28:14.480
What we have here is basically
a way to look at information.

00:28:14.480 --> 00:28:17.600
For all our journal entries,
we can resize some columns,

00:28:17.600 --> 00:28:19.780
we can add and subtract some things.

00:28:19.780 --> 00:28:23.750
Let's just quickly do a
journal entry to show you.

00:28:24.070 --> 00:28:31.540
I want you to see part of the modified
or enhanced AWT is you see the whole

00:28:31.540 --> 00:28:35.490
screen just pop at once because all
the objects are being laid down in

00:28:35.490 --> 00:28:37.460
memory before they're being displayed.

00:28:37.460 --> 00:28:42.100
So what we can do is we can
do a quick transaction here.

00:28:42.290 --> 00:28:44.460
If I can type without my fingers here.

00:28:48.070 --> 00:28:50.040
So we can kind of go down here.

00:28:50.090 --> 00:28:54.700
One of the characteristics of
a Java app for us is what we

00:28:54.700 --> 00:28:56.950
call high volume productivity.

00:28:56.960 --> 00:29:01.290
One of the key elements-- we have two
product strategies or design points,

00:29:01.290 --> 00:29:02.760
if you will, for our apps.

00:29:02.760 --> 00:29:05.240
We have what we call a
self-service design point,

00:29:05.240 --> 00:29:09.680
which is generally characterized as HTML,
easy to use, single click,

00:29:09.680 --> 00:29:10.480
that kind of thing.

00:29:10.480 --> 00:29:12.480
We're all familiar with it.

00:29:12.480 --> 00:29:15.380
And placed in the hands of
completely untrained users.

00:29:15.400 --> 00:29:17.240
The other audience,
what we would call the

00:29:17.390 --> 00:29:20.460
professional clerk,
is somebody that actually

00:29:20.460 --> 00:29:22.820
demands high productivity apps.

00:29:22.890 --> 00:29:23.660
They're sitting down.

00:29:23.660 --> 00:29:26.750
Their whole job is doing nothing
but keying in data all day long.

00:29:27.090 --> 00:29:29.930
And what they have-- some of
their requirements are things

00:29:29.930 --> 00:29:31.350
that only Java can handle.

00:29:31.530 --> 00:29:32.860
Things like type ahead.

00:29:33.080 --> 00:29:35.220
Things like when you're
looking for a list of values,

00:29:35.270 --> 00:29:38.620
the windows pop up in the
context of the screen.

00:29:38.840 --> 00:29:40.380
Having keyboard equivalents.

00:29:40.420 --> 00:29:42.140
There's actually a
large number of things,

00:29:42.140 --> 00:29:43.880
as you probably have
made choices yourself,

00:29:43.880 --> 00:29:47.220
about what's good for
Java versus what's good for HTML.

00:29:47.560 --> 00:29:49.840
And of course,
we have Java embedded in HTML as well.

00:29:49.990 --> 00:29:52.100
But these are the core,
what we would call,

00:29:52.160 --> 00:29:53.740
heads down administrative apps.

00:29:53.920 --> 00:29:58.200
So you get certain kinds
of dialogues popping up.

00:29:58.760 --> 00:30:00.520
And all sorts of keyboard
equivalents here.

00:30:00.520 --> 00:30:02.560
I'll just show you some of our UI here.

00:30:02.560 --> 00:30:04.790
What we're going to do is--

00:30:05.020 --> 00:30:13.890
We're going to move product
revenue from-- let's see here.

00:30:13.890 --> 00:30:13.890
I have to find my accounts here.

00:30:16.200 --> 00:30:32.300
[Transcript missing]

00:30:33.800 --> 00:30:49.000
[Transcript missing]

00:30:50.010 --> 00:30:53.310
from unearned revenue,
we're going to go to

00:30:53.310 --> 00:30:57.650
miscellaneous revenue,
and we just so happen--oops,

00:30:57.650 --> 00:30:59.880
an error message there.

00:31:03.140 --> 00:31:11.030
Product X, which means Mac 10.

00:31:11.030 --> 00:31:11.030
So we're going to go with that,
and we're going to put in

00:31:12.700 --> 00:31:20.000
[Transcript missing]

00:31:20.200 --> 00:31:21.200
Okay.

00:31:21.330 --> 00:31:24.640
So basically we do a transaction.

00:31:24.640 --> 00:31:26.270
We interact with it a little bit.

00:31:26.280 --> 00:31:27.800
We go ahead and post the transaction.

00:31:27.800 --> 00:31:30.650
Oh, tells me it did it.

00:31:32.810 --> 00:31:37.180
and it gives me a tracking number and
basically the transaction is done.

00:31:37.180 --> 00:31:44.200
That's kind of an interactive
experience for a production user.

00:31:44.200 --> 00:31:50.200
What I can do now is just show you as
we go down through the process map.

00:31:51.550 --> 00:31:55.480
What we want to do is as we go through
the process and post the journals,

00:31:55.480 --> 00:32:00.520
then you end up seeing the
continuousness of the process.

00:32:00.520 --> 00:32:02.640
It's a great way to write apps,
and it's a great way to

00:32:02.640 --> 00:32:05.140
build them modularly,
and based on different kinds of

00:32:05.140 --> 00:32:09.020
control points that businesses need,
this is a really nice user

00:32:09.020 --> 00:32:13.520
interface to break up big apps into
functional components and do stuff.

00:32:13.520 --> 00:32:15.940
That's just the marketing
of our own products.

00:32:15.940 --> 00:32:21.820
Basically, that's what I wanted to show,
which is our developer product.

00:32:21.820 --> 00:32:26.050
This product actually is the
development tool for roughly 7,000 of

00:32:26.050 --> 00:32:29.270
these products that cover 70 modules.

00:32:29.270 --> 00:32:34.170
It's a very big app,
and it's Oracle's premier application.

00:32:34.250 --> 00:32:34.260
Thanks, Steve.

00:32:34.260 --> 00:32:35.260
Thanks a lot.

00:32:35.260 --> 00:32:36.260
Okay.

00:32:42.900 --> 00:32:44.700
So I know there are
folks out there saying,

00:32:44.800 --> 00:32:51.640
"Well, that doesn't look like a Macintosh
UI." That's not the idea.

00:32:51.640 --> 00:32:55.840
The idea for Oracle is--and
people could argue with this,

00:32:56.030 --> 00:32:58.930
but at least it's their
goal to have a branded UI,

00:32:58.940 --> 00:33:05.240
and for them to have a UI that works the
same across multiple operating systems.

00:33:05.240 --> 00:33:06.950
And in fact,
Oracle spends quite a bit of time

00:33:06.960 --> 00:33:11.820
making sure their app does have
the Oracle branded look and feel.

00:33:11.820 --> 00:33:14.940
So that's, in a nutshell,
why it looks different.

00:33:14.940 --> 00:33:19.070
And again,
that's one of the goals of the platform,

00:33:19.180 --> 00:33:21.860
the Java 2 UI toolkit,
is to allow you to have the

00:33:21.860 --> 00:33:23.370
branded UI if that's what you want.

00:33:26.300 --> 00:33:28.800
So I don't know how many
of you folks caught it,

00:33:28.800 --> 00:33:34.030
but there was a release, press release,
April 14th,

00:33:34.030 --> 00:33:38.860
that talks about Sun working closely
with some Blue Ribbon vendors.

00:33:38.860 --> 00:33:41.060
Fortunately, Apple was one of them.

00:33:41.060 --> 00:33:43.700
There's been a lot of frustration
in the Java community,

00:33:43.700 --> 00:33:48.750
some of you are probably aware of this,
with Sun's attempt, or lack thereof,

00:33:48.750 --> 00:33:50.740
to standardize Java.

00:33:51.350 --> 00:33:55.870
There was an ANSI attempt,
there was an ECMA attempt,

00:33:56.220 --> 00:34:02.150
and now the third pitch, so to speak,
is this new JCP 2.0.

00:34:02.160 --> 00:34:06.410
And we've been working closely with them
to make sure this is a sensible process,

00:34:06.410 --> 00:34:09.740
which will benefit Apple,
as well as the other companies,

00:34:09.740 --> 00:34:15.980
and actually as well as individuals who
might want to get their say in as well.

00:34:15.980 --> 00:34:18.480
So I think this process is
actually looking pretty good,

00:34:18.480 --> 00:34:19.740
and it's still evolving.

00:34:21.100 --> 00:34:22.400
But the good news is we're at the table.

00:34:23.910 --> 00:34:27.440
The other press release,
as far as Java compatibility

00:34:27.870 --> 00:34:30.920
is concerned,
is they just released 1.3,

00:34:30.920 --> 00:34:36.180
which is the hotspot client
VM that actually we're shipping.

00:34:36.180 --> 00:34:39.070
It's the same hotspot client
VM we're shipping in DP4,

00:34:39.070 --> 00:34:42.220
but we haven't integrated
all the 1.3 stuff yet.

00:34:42.300 --> 00:34:47.780
So the release that you're getting
is based on somewhere in the

00:34:47.780 --> 00:34:51.860
middle between 1.2.2 and 1.3.

00:34:51.860 --> 00:34:56.310
But by the time we go GM,
we will upgrade to 1.3 entirely,

00:34:56.310 --> 00:34:59.460
which is the current shipping standard.

00:34:59.460 --> 00:35:04.980
We currently pass 96% of the JCK tests,
I'm told, for a beta product.

00:35:05.050 --> 00:35:09.270
I'm pretty happy with that,
so we have 4% left that we'll

00:35:09.290 --> 00:35:11.500
nail by the time we go GM.

00:35:13.180 --> 00:35:21.020
and Sun really did listen
to their customers for 1.3.

00:35:21.020 --> 00:35:24.190
Again, they got a little bit burned
by the big gulp they asked

00:35:24.190 --> 00:35:29.740
everyone to take with 1.2,
and 1.3 is almost entirely

00:35:29.740 --> 00:35:32.760
performance and compatibility focused.

00:35:32.760 --> 00:35:36.160
It has almost no new features
and has about the same footprint

00:35:36.360 --> 00:35:39.970
as the previous version.

00:35:41.100 --> 00:35:44.480
So another demo.

00:35:44.480 --> 00:35:48.280
The first demo might have been obvious,
but again,

00:35:48.280 --> 00:35:53.860
it's MRJ 2.2 running on a Mac 9 platform.

00:35:54.350 --> 00:35:58.860
The demo I want to give
now is ask Blake Stone,

00:35:58.860 --> 00:36:04.600
an incredibly talented
engineer from InPrize,

00:36:04.600 --> 00:36:09.830
to come up and give a
demo on Java 2 on 10.

00:36:11.200 --> 00:36:12.200
Thanks, Dave.

00:36:12.200 --> 00:36:17.040
Before we launch into this,
I have to clarify a few things.

00:36:17.040 --> 00:36:20.670
We're going to be showcasing some
fairly interesting technology here.

00:36:20.820 --> 00:36:23.110
At this point, it is a technology demo.

00:36:23.350 --> 00:36:28.250
We're obviously working with early
technology from Apple in the form of DP4.

00:36:28.420 --> 00:36:30.270
We're working with technology of our own.

00:36:30.270 --> 00:36:32.830
But we haven't announced
any products at this point,

00:36:32.950 --> 00:36:35.990
so I'd like to remind people of
that before things get too excited.

00:36:36.100 --> 00:36:38.970
But it is interesting to
note what we've been doing.

00:36:39.190 --> 00:36:40.960
What we've been doing is we've
been working with a partner

00:36:41.350 --> 00:36:46.010
who is extremely interested in
building a premier Java 2 platform,

00:36:46.010 --> 00:36:50.240
in building technology that makes
Java developers sit up and take notice.

00:36:50.330 --> 00:36:51.860
So that attracts our attention.

00:36:51.970 --> 00:36:53.880
After all,
we have some absolute world-beating

00:36:53.920 --> 00:36:56.840
products in that area as well,
and so there's some natural synergy.

00:36:56.930 --> 00:37:00.680
And we thought this is an opportunity
to see how they work with partners

00:37:00.700 --> 00:37:02.690
and how that process might work out.

00:37:02.700 --> 00:37:04.990
And to be honest, it's been exceptional.

00:37:04.990 --> 00:37:06.070
I've been very responsive to
our need to work with partners.

00:37:06.100 --> 00:37:06.680
And I've been very interested
in working with them.

00:37:06.710 --> 00:37:07.200
And I've been very interested
in working with them.

00:37:07.200 --> 00:37:07.600
And I've been very interested
in working with them.

00:37:07.600 --> 00:37:07.600
And I've been very interested
in working with them.

00:37:07.600 --> 00:37:07.600
And I've been very interested
in working with them.

00:37:07.600 --> 00:37:07.600
And I've been very interested
in working with them.

00:37:07.600 --> 00:37:09.160
And I've been very interested
our need for performance tweaks,

00:37:09.200 --> 00:37:11.780
our need for fixes in some areas.

00:37:11.780 --> 00:37:15.010
In fact, just the last session
I was in with John Berkey,

00:37:15.010 --> 00:37:19.270
I saw him in the row ahead of me,
busy trying to tweak a few last things

00:37:19.400 --> 00:37:21.290
to make the product even faster.

00:37:21.290 --> 00:37:25.240
I'm not going to take the chance and
run with those fixes here on stage,

00:37:25.430 --> 00:37:28.080
but just so you know,
that kind of thing is ongoing,

00:37:28.100 --> 00:37:29.960
we're getting better
and better performance.

00:37:29.960 --> 00:37:31.400
So what is it that I'm talking about?

00:37:31.400 --> 00:37:33.990
Of course,
what I'm talking about is JBuilder.

00:37:33.990 --> 00:37:36.630
So if we can switch to
the machine over here.

00:37:40.300 --> 00:37:41.190
and bring it up.

00:37:41.280 --> 00:37:46.600
I'd like to have a look at a product
that consists of about 5,000 classes.

00:37:46.870 --> 00:37:49.350
So you saw the statistics
on Java 2 itself.

00:37:49.500 --> 00:37:50.550
This is enormous.

00:37:50.660 --> 00:37:53.550
In terms of code bulk,
our product is actually larger

00:37:53.550 --> 00:37:56.840
than the JDK in terms of the
amount of Java code involved.

00:37:56.960 --> 00:38:00.330
So will it run on this new
platform in a preview stage?

00:38:00.470 --> 00:38:01.890
Well, we'll hope so.

00:38:01.890 --> 00:38:03.400
This is a demo after all.

00:38:03.400 --> 00:38:04.920
We'll see just how far we can get.

00:38:05.040 --> 00:38:09.590
But I'd like to showcase some of what
you can do with a pure Java application.

00:38:09.820 --> 00:38:13.140
For those of you who aren't familiar,
JBuilder is a Java development IDE.

00:38:13.140 --> 00:38:15.690
And as such, it has a lot of what
you'd normally expect,

00:38:15.690 --> 00:38:17.850
the ability to create
and manipulate projects,

00:38:18.040 --> 00:38:19.130
edit code, and so forth.

00:38:19.130 --> 00:38:21.950
And I'm going to start with a new
project and just bring up some of the

00:38:21.950 --> 00:38:25.870
wizards that we have for manipulating
projects in our environment.

00:38:25.870 --> 00:38:28.580
Let the system swap itself back in.

00:38:39.250 --> 00:38:44.160
This is always the way I like
demonstrations to begin.

00:38:44.200 --> 00:38:45.910
We'll see if this doesn't
behave well for us,

00:38:46.050 --> 00:38:47.040
we'll restart the product.

00:38:47.040 --> 00:38:50.420
Of course, this all went incredibly
well in rehearsals.

00:38:51.150 --> 00:38:54.660
So some of what was being talked
about earlier is the launch

00:38:54.820 --> 00:38:56.980
performance for Java applications.

00:38:57.110 --> 00:39:00.270
So we'll get an ideal opportunity
to demonstrate that here.

00:39:00.400 --> 00:39:01.840
Launch performance for
a Java application,

00:39:01.840 --> 00:39:03.100
of course, is critical.

00:39:03.100 --> 00:39:07.150
And a lot of what we're seeing is
a very expensive startup process in

00:39:07.150 --> 00:39:11.840
terms of loading the imaging and so
forth at the basic class libraries.

00:39:11.970 --> 00:39:14.630
But really, the launch time for
the product is not bad.

00:39:14.640 --> 00:39:18.390
It's actually faster than a lot of
native applications on the platform,

00:39:18.510 --> 00:39:20.500
which has got us quite gratified.

00:39:20.610 --> 00:39:22.320
So from there,
we're going to go ahead and

00:39:22.460 --> 00:39:24.020
start off with our new project.

00:39:24.350 --> 00:39:27.220
So we built a new project here.

00:39:27.530 --> 00:39:29.730
Within that project,
I'm going to request that we go

00:39:29.740 --> 00:39:31.920
ahead and build an application.

00:39:31.920 --> 00:39:36.760
And it will give us a couple of the
sort of basic application starting

00:39:36.850 --> 00:39:40.430
point and a frame and bring us into
the editor in this environment.

00:39:40.510 --> 00:39:44.680
What's interesting here to note is that
we're running a pure Java application.

00:39:44.680 --> 00:39:47.740
The editor isn't some piece of
native code in the environment.

00:39:47.800 --> 00:39:50.050
The editor is actually
written in Java code.

00:39:50.370 --> 00:39:54.060
And as such, you'd expect it to exhibit
performance problems.

00:39:54.170 --> 00:39:57.150
But in practice,
things like syntax highlighting,

00:39:57.150 --> 00:40:00.400
noticing with a keystroke that
the contents is changed into

00:40:00.400 --> 00:40:02.110
a comment is incredibly quick.

00:40:02.220 --> 00:40:05.160
The ability of the environment
to keep up with structural

00:40:05.160 --> 00:40:07.010
changes is quite amazing as well.

00:40:07.350 --> 00:40:10.150
What you're seeing on the left-hand
side here is a structure pane

00:40:10.150 --> 00:40:12.010
showing me the structure of my file.

00:40:12.100 --> 00:40:14.470
But I have a single class with
a number of elements declared.

00:40:14.470 --> 00:40:18.200
If I were to go in and declare
a new structure element,

00:40:18.320 --> 00:40:19.890
it just shows up in a list.

00:40:19.960 --> 00:40:23.380
So we're parsing behind the scenes
to try to give us the information.

00:40:23.460 --> 00:40:28.310
So we can see the information about
what is in our particular file here.

00:40:28.310 --> 00:40:29.060
And we can browse

00:40:29.250 --> 00:40:32.090
We're also getting additional information
on the fly because we're parsing

00:40:32.090 --> 00:40:33.540
the Java code in the background.

00:40:33.700 --> 00:40:36.600
If I make a mistake in my
code and just keep working,

00:40:36.650 --> 00:40:40.020
it'll notify me by showcasing that
there are errors in my code and allow

00:40:40.020 --> 00:40:44.370
me to go directly to that line of
code so I can fix my error on the fly.

00:40:44.470 --> 00:40:46.860
So we're not waiting for compile
time to catch that kind of thing.

00:40:46.860 --> 00:40:49.440
It's an extraordinarily
productive environment.

00:40:49.540 --> 00:40:51.970
So I like to start with that as
a starting point and go ahead

00:40:52.040 --> 00:40:53.190
and try to build something.

00:40:53.540 --> 00:40:55.230
But of course,
when you're building something,

00:40:55.250 --> 00:40:57.400
what you'd really like to be
able to do is use a visual

00:40:57.400 --> 00:40:58.800
layout to work with Java Bean.

00:40:58.800 --> 00:41:00.710
So I'm going to move over
to the designer here.

00:41:00.800 --> 00:41:04.480
And in the design environment,
we have the ability to place Java Beans.

00:41:04.730 --> 00:41:05.890
I'm going to use swing components.

00:41:06.100 --> 00:41:09.200
After all, they are more or less
standard Java Beans,

00:41:09.300 --> 00:41:13.160
and they'll allow me to
prototype a UI fairly rapidly.

00:41:13.340 --> 00:41:15.790
For those of you coming from
an environment where I hear

00:41:15.790 --> 00:41:18.910
lots of concerns about layouts,
is there enough space on my

00:41:18.910 --> 00:41:20.760
layout to accommodate this change?

00:41:20.760 --> 00:41:23.390
Well, if you're a Java developer,
you know that there's some

00:41:23.460 --> 00:41:26.350
extremely sophisticated technology
for dealing with layouts,

00:41:26.450 --> 00:41:28.050
but it can be quite difficult to learn.

00:41:28.210 --> 00:41:31.190
So it's easiest to start in
sort of a raw positioning,

00:41:31.200 --> 00:41:32.830
an XY layout mode.

00:41:32.840 --> 00:41:38.790
I'm going to go ahead and use
XY layout to place a scrolling region.

00:41:40.420 --> 00:41:45.240
and within that scrolling region
and go ahead and drop back a list

00:41:45.320 --> 00:41:48.870
and i want to drop in couple buttons

00:41:50.170 --> 00:41:52.130
and I want to drop in a text field.

00:41:52.170 --> 00:41:54.440
And then we'll go ahead
and write some code.

00:41:54.480 --> 00:41:57.990
What's interesting is that I have
been writing code all along.

00:41:57.990 --> 00:42:01.230
Everything I do in here,
every time I drop a component,

00:42:01.390 --> 00:42:04.770
every time I edit something,
it's writing Java source code.

00:42:04.950 --> 00:42:08.850
So you can see behind the scenes that
it's written source code here to set

00:42:08.850 --> 00:42:11.100
the text on the buttons and so forth.

00:42:11.240 --> 00:42:14.070
What's unique about our approach is
that we don't deal with this as a

00:42:14.070 --> 00:42:16.420
code generation or one-way technology.

00:42:16.670 --> 00:42:19.150
We don't block this
off from your editing.

00:42:19.290 --> 00:42:24.560
We treat this as a fully two-way tool
where I can go ahead and modify my source

00:42:24.560 --> 00:42:27.960
code and then drop back into design
mode and you'll see that those changes

00:42:27.960 --> 00:42:30.210
are reflected immediately in my design.

00:42:30.240 --> 00:42:31.820
It's actually parsing
and executing the source.

00:42:36.690 --> 00:42:39.340
So we'll make a few more
adjustments to my layout here.

00:42:39.540 --> 00:42:42.180
And once I've got the layout
more or less the way I want it,

00:42:42.220 --> 00:42:45.100
of course,
this gives me absolute positioning,

00:42:45.100 --> 00:42:48.200
which when I scale things or change
the text on buttons isn't going

00:42:48.200 --> 00:42:50.100
to work for internationalization.

00:42:50.270 --> 00:42:53.210
So I'd like to change
it to a grid bag layout.

00:42:53.330 --> 00:42:54.170
So what do I need to do?

00:42:54.430 --> 00:42:57.100
I need to tell it to change
to a grid bag layout.

00:42:57.130 --> 00:43:03.450
And what's happened is behind the scenes,
it's figured out the optimal grid bag

00:43:03.450 --> 00:43:05.140
layout to use for that positioning.

00:43:08.980 --> 00:43:14.960
So as I internationalize this,
excuse my internationalization,

00:43:14.960 --> 00:43:17.700
we'll see the automatic
adjustments that are taking place.

00:43:17.810 --> 00:43:20.990
So I've got the basic layout in place,
and I'd like to go and add a little

00:43:20.990 --> 00:43:22.140
bit of code behind the scenes.

00:43:22.210 --> 00:43:23.780
And, of course,
we can just wire events up.

00:43:23.960 --> 00:43:27.280
I'd like to go ahead
and wire up an add item.

00:43:27.360 --> 00:43:30.580
And immediately I discover
I want to add an item to a list.

00:43:30.600 --> 00:43:32.850
Swing lists are a little awkward.

00:43:32.890 --> 00:43:33.600
You need a model.

00:43:33.600 --> 00:43:35.840
You need to wire up the model,
and so forth.

00:43:35.970 --> 00:43:36.440
That's fine.

00:43:36.440 --> 00:43:37.360
This is fully two-way.

00:43:37.360 --> 00:43:41.420
We can drop back into our
designer and pick up a swing

00:43:41.420 --> 00:43:43.550
model using our class browser.

00:43:43.740 --> 00:43:47.180
You'll notice that our class browser
knows about comApple classes.

00:43:47.420 --> 00:43:49.900
It's because it's dynamically
discovering from the class path

00:43:49.900 --> 00:43:51.100
what classes are available.

00:43:51.100 --> 00:43:54.980
So if you add third party classes or
switch to a different version of the VM,

00:43:55.140 --> 00:43:57.660
we'll automatically adapt to
that additional technology.

00:43:57.800 --> 00:44:00.930
But let's go in right now
and pick up the JavaX swing.

00:44:01.110 --> 00:44:04.480
And I'm going to use
the default list model,

00:44:04.550 --> 00:44:06.330
if I can find it.

00:44:07.290 --> 00:44:10.400
and so I'm going to drop a
default list model in place,

00:44:10.400 --> 00:44:15.470
take my JList and wire the model up,
and now I've established a relationship

00:44:15.470 --> 00:44:19.440
between those two and I can do
something interesting in code with them.

00:44:19.610 --> 00:44:22.810
What I'd like to do in code is go ahead
and add something to that list model.

00:44:23.110 --> 00:44:25.280
Do I remember the name of the list model?

00:44:25.380 --> 00:44:26.240
No, heavens.

00:44:26.240 --> 00:44:28.980
It's a list,
default list model something.

00:44:29.120 --> 00:44:32.540
So I'm going to invoke Code Insight,
which is a technology that,

00:44:32.680 --> 00:44:35.600
from within this context,
tells me here are the things

00:44:35.650 --> 00:44:36.920
I can legally refer to.

00:44:36.990 --> 00:44:40.230
In this case it knows about
default list model one because

00:44:40.380 --> 00:44:42.180
within this scope it's visible.

00:44:42.180 --> 00:44:44.130
So, okay,
I want to use default list model one.

00:44:44.130 --> 00:44:45.130
What do I want to do with it?

00:44:45.130 --> 00:44:47.390
Well,
now it's reevaluated that scope and said,

00:44:47.500 --> 00:44:48.970
here are the available methods.

00:44:48.970 --> 00:44:51.520
And there is, in fact,
something called add element.

00:44:51.540 --> 00:44:53.880
And for add element,
it's gone and checked and there's

00:44:53.880 --> 00:44:55.780
only one overloading of that method.

00:44:55.780 --> 00:44:58.730
It takes one parameter of type
object and it's even gone to the

00:44:58.910 --> 00:45:01.730
source code for that method to
find the name of the parameter,

00:45:01.730 --> 00:45:02.050
obj.

00:45:02.050 --> 00:45:04.740
And it's kind of convenient.

00:45:04.740 --> 00:45:08.260
So we'll go through and
pick up the jtext field,

00:45:08.260 --> 00:45:10.760
this jtext field one.

00:45:10.760 --> 00:45:13.840
And again,
use Code Insight to find get text.

00:45:13.940 --> 00:45:17.520
It takes either no parameters
or an offset in the length,

00:45:17.520 --> 00:45:19.360
but that sounds fine to me.

00:45:19.360 --> 00:45:21.820
We'll go to the next step,
which is that I want to wire up

00:45:21.820 --> 00:45:25.590
the delete button to go ahead
and delete the selected item.

00:45:25.590 --> 00:45:27.280
Okay.

00:45:27.520 --> 00:45:30.700
So it looks vaguely similar,
but what I really need to do

00:45:30.700 --> 00:45:33.730
is I need to find out the,
the position of the selected item.

00:45:33.740 --> 00:45:36.350
And I can do this from the list.

00:45:36.400 --> 00:45:38.730
There's a get selected index.

00:45:38.820 --> 00:45:42.600
But what does that return
if there's no selection?

00:45:42.680 --> 00:45:46.200
Well, if I can't remember offhand,
I can simply select with a single

00:45:46.200 --> 00:45:50.440
keystroke that I'd like to go and
find the declaration for that method.

00:45:50.440 --> 00:45:53.280
It found the source code
where I can see the Java doc,

00:45:53.380 --> 00:45:56.440
see offhand that it returns negative
one if there's no selected item,

00:45:56.500 --> 00:46:00.100
and just use the browser style
controls to navigate back to where

00:46:00.100 --> 00:46:02.200
I was writing my source code.

00:46:06.700 --> 00:48:19.400
[Transcript missing]

00:48:19.930 --> 00:48:22.970
So this database,
we can see how much object allocation

00:48:22.970 --> 00:48:24.760
is working within the file.

00:48:24.760 --> 00:48:27.610
We can see a bunch of the tables
that are available within the tables.

00:48:27.710 --> 00:48:29.500
We can see indexes and so forth.

00:48:29.590 --> 00:48:31.210
So we have this full
management interface.

00:48:31.380 --> 00:48:34.550
Again, the management interface itself,
of course, is written in Java.

00:48:34.600 --> 00:48:37.100
So we've got a database to connect to.

00:48:37.100 --> 00:48:42.330
Let's go ahead and use an existing
connection to this JDataStore database.

00:48:42.330 --> 00:48:46.250
Test that connection to make sure, again,
the database is up and running

00:48:46.250 --> 00:48:48.170
and that we can connect to
it without any problems.

00:48:48.240 --> 00:48:54.090
Probably shut the database down helpfully
by quitting that prior application.

00:48:54.510 --> 00:48:57.310
And then go ahead and
connect a query to it.

00:48:57.310 --> 00:49:04.820
And so we have a nice little
component that represents a query.

00:49:04.830 --> 00:49:04.830
Let's see.

00:49:04.830 --> 00:49:04.830
Hang on.

00:49:06.820 --> 00:49:10.840
and connect the query to
our existing database,

00:49:11.020 --> 00:49:16.240
use our built-in SQL builder to
go and find a table within that,

00:49:16.370 --> 00:49:18.690
grab all of the columns from the table.

00:49:18.810 --> 00:49:21.800
We can see the SQLs that it's
automatically generated on our behalf,

00:49:21.970 --> 00:49:23.340
and we have a query.

00:49:23.450 --> 00:49:26.250
Fine, but we need to connect
that to visual information.

00:49:26.250 --> 00:49:26.740
That's fine.

00:49:26.740 --> 00:49:28.260
We have components for that as well.

00:49:28.260 --> 00:49:33.250
I'm actually going to
just use border layout

00:49:33.670 --> 00:49:55.100
: I'm going to do my work here.

00:49:55.100 --> 00:49:55.100
Drop a scrolling region and a table,
and how much code have I written so far?

00:49:55.100 --> 00:49:55.100
Well,
I can connect to this database and get

00:49:55.100 --> 00:49:55.100
live data at design time and at runtime
without writing a single line of code.

00:49:55.100 --> 00:49:55.100
And we'll take that a step further,
drop in a

00:49:55.680 --> 00:50:01.440
and the navigation interface as well,
and connect those both

00:50:01.440 --> 00:50:02.740
to the same data set.

00:50:02.870 --> 00:50:08.780
So now I have an application that I'm
going to go ahead and compile and run.

00:50:08.780 --> 00:50:08.780
And I'm going

00:50:09.150 --> 00:50:12.820
will go ahead and connect to the database
and see what Xero code can do in terms

00:50:12.820 --> 00:50:14.340
of database connectivity with Java.

00:50:18.240 --> 00:50:26.260
: Excuse me, launch time again.

00:50:26.260 --> 00:50:26.260
It takes a moment for it to
come up and actually connect to

00:50:26.260 --> 00:50:26.260
the database in the background.

00:50:27.420 --> 00:50:34.000
But what we'll have here is a UI that
allows me to view that information,

00:50:34.010 --> 00:50:38.150
manipulate information,
navigate through it, et cetera.

00:50:38.380 --> 00:50:40.320
So we can navigate.

00:50:40.360 --> 00:50:43.700
We can, of course, resize columns.

00:50:43.700 --> 00:50:45.610
We can reorder columns.

00:50:45.680 --> 00:50:47.910
If I want to change the
name of somebody here,

00:50:48.080 --> 00:50:49.590
I can change it.

00:50:49.680 --> 00:50:52.370
We can see in the status
area that I am editing a row.

00:50:52.670 --> 00:50:55.600
Normally the status area
shows us what record we're on.

00:50:55.600 --> 00:51:01.040
We can commit those changes
back to the database,

00:51:01.040 --> 00:51:01.040
all without writing a
single line of code.

00:51:09.500 --> 00:51:10.240
So that's fine.

00:51:10.240 --> 00:51:10.840
That's dandy.

00:51:10.840 --> 00:51:13.980
What we've got is the ability to
be extremely productive at dealing

00:51:14.230 --> 00:51:17.170
with Java code in this environment,
but you wouldn't have much

00:51:17.170 --> 00:51:19.570
of a full-featured IDE if
you didn't have a debugger.

00:51:19.690 --> 00:51:21.400
So I'd like to take a
quick tour of the debugger,

00:51:21.400 --> 00:51:22.720
if we're doing okay on time here.

00:51:22.720 --> 00:51:26.870
I have no idea, to be honest.

00:51:27.720 --> 00:51:31.780
Basically,
I'd like to bring up a basic application,

00:51:31.960 --> 00:51:35.790
place a breakpoint in it,
and we'll go in and launch the debugger.

00:51:36.940 --> 00:51:40.660
Our little application here
performs some basic console UI.

00:51:40.660 --> 00:51:42.670
In this case,
it's going to prompt me for my name

00:51:42.670 --> 00:51:44.840
before hitting that breakpoint,
and then stops when it

00:51:44.960 --> 00:51:46.080
hits the breakpoint,
of course.

00:51:46.220 --> 00:51:50.990
At that point, I'd like to be able to see
the context that I'm in.

00:51:51.120 --> 00:51:53.580
So I can see that I am stopped
at a thread called main

00:51:53.580 --> 00:51:57.210
in the main thread group,
which is in the system thread group,

00:51:57.210 --> 00:51:59.750
and that there are two stack frames here.

00:51:59.920 --> 00:52:03.270
I called from the main
method into the go method,

00:52:03.270 --> 00:52:07.590
and I can see in the go method
that I can see the this reference,

00:52:07.640 --> 00:52:10.750
drill down into that,
see the class that it belongs to,

00:52:10.750 --> 00:52:14.190
any of that class's parent
classes and static members.

00:52:14.380 --> 00:52:18.920
I can see other variables in context,
like this first, what have you.

00:52:18.920 --> 00:52:23.170
We have some interesting convenience
functionality for allowing you to

00:52:23.170 --> 00:52:24.620
manipulate information as well.

00:52:24.780 --> 00:52:29.210
I can actually go and change values on
the fly in an application I'm debugging.

00:52:29.970 --> 00:52:31.720
For example, if I see that I'm in
the main thread group,

00:52:31.790 --> 00:52:33.990
and I step past this
line that prints my name,

00:52:33.990 --> 00:52:38.850
I could go and even change a string
value on the fly and say the new string

00:52:38.850 --> 00:52:46.140
value... I got focus in the wrong place

00:52:50.470 --> 00:52:52.640
Of course,
we are running on beta software.

00:52:52.750 --> 00:52:54.790
Please expect a few quirks along the way.

00:52:54.910 --> 00:52:58.000
So we can change string values,
integer values within the debugger.

00:52:58.280 --> 00:53:01.880
We can also do things that are
quite unusual for a debugger,

00:53:01.920 --> 00:53:03.940
like create a field breakpoint.

00:53:03.980 --> 00:53:05.230
What's a field breakpoint?

00:53:05.230 --> 00:53:09.880
It's going to tell me every time it tries
to reference this particular variable.

00:53:10.070 --> 00:53:11.990
So I'm going to continue
my execution here,

00:53:11.990 --> 00:53:14.940
and we'll see that it has stopped
automatically at this line,

00:53:14.940 --> 00:53:17.420
which is referring to name,
and given me the message,

00:53:17.440 --> 00:53:21.530
"Stopped at breakpoint reading
debug me name." In fact,

00:53:21.630 --> 00:53:24.600
we can go and select for that
field breakpoint individually,

00:53:24.600 --> 00:53:27.220
whether it should break on
reads of that variable or break

00:53:27.220 --> 00:53:28.580
on writes of that variable.

00:53:28.640 --> 00:53:31.610
So an enormous amount of flexibility.

00:53:34.950 --> 00:53:39.730
I'd like to do one last look,
because Java takes a serious

00:53:39.730 --> 00:53:43.430
look at what it takes to do
multi-threaded applications.

00:53:43.530 --> 00:53:46.840
There's language support built
right in for multi-threading.

00:53:46.840 --> 00:53:50.300
So what happens when we go to
debug a multi-threaded application?

00:53:50.460 --> 00:53:54.030
Well,
it adds a whole new set of problems,

00:53:54.030 --> 00:53:57.920
because we need to be able to keep
track of what locks are being acquired.

00:53:57.920 --> 00:54:00.270
In this case,
I'm acquiring two locks on a thread,

00:54:00.270 --> 00:54:03.080
and our debugger will actually
show you the monitors.

00:54:03.130 --> 00:54:05.790
It'll show you what the
object is that's locked,

00:54:05.790 --> 00:54:07.190
and what thread is locking it.

00:54:07.510 --> 00:54:10.790
And as I proceed a little further
here and get three threads,

00:54:10.790 --> 00:54:14.450
we can see situations where this
object is owned by one thread,

00:54:14.450 --> 00:54:18.250
there's another thread waiting on it,
so that we can see situations

00:54:18.250 --> 00:54:21.440
where we're getting multiple
threads cooperating here,

00:54:21.650 --> 00:54:24.180
and go a step further to
situations where our entire

00:54:24.270 --> 00:54:25.980
application has locked up on us.

00:54:26.290 --> 00:54:29.210
And by pausing it,
we can see that it's highlighted these

00:54:29.470 --> 00:54:32.960
two as the cause of the deadlock that
is currently active in my system.

00:54:39.600 --> 00:54:41.760
I can tell we're running
a little low on time here,

00:54:41.760 --> 00:54:42.630
I suspect.

00:54:42.730 --> 00:54:46.630
But I would like to take this
time to really point out that

00:54:46.630 --> 00:54:48.790
what we've taken here is,
again,

00:54:48.790 --> 00:54:53.420
an enormous Java application and brought
it over to the Mac OS X platform.

00:54:53.420 --> 00:54:56.950
And while it would be natural to say,
what kind of porting work

00:54:57.000 --> 00:54:59.840
did you do to bring it here,
the porting work we've done is

00:54:59.840 --> 00:55:03.440
working with Apple to tell them
what issues we've run into in terms

00:55:03.790 --> 00:55:05.870
of compatibility with their VM.

00:55:05.990 --> 00:55:09.920
Not a single line of code has
changed from our shipping product.

00:55:10.100 --> 00:55:13.680
This is the product you can purchase
today on a number of other platforms.

00:55:13.770 --> 00:55:15.840
So that's really exciting
from our perspective.

00:55:15.880 --> 00:55:18.010
We're looking forward to moving a
little further with this technology.

00:55:18.020 --> 00:55:19.010
Incredible.

00:55:19.020 --> 00:55:20.020
Thank you.

00:55:20.020 --> 00:55:20.020
Incredible.

00:55:28.440 --> 00:55:31.580
Well, that demo blows me away.

00:55:31.640 --> 00:55:33.180
You guys were a little quiet.

00:55:33.220 --> 00:55:35.970
Didn't it blow you away, too?

00:55:37.200 --> 00:55:43.240
Again, it's the best way for me to show
you how real Java 2 is on Mac 10.

00:55:43.240 --> 00:55:48.360
This thing is a torture
test for the Java VM.

00:55:48.360 --> 00:55:52.890
I think Sun uses it internally
to make sure their stuff runs

00:55:52.970 --> 00:55:55.440
every time they make a change.

00:55:55.440 --> 00:55:58.660
Again, it's not a shipping product.

00:55:58.690 --> 00:56:02.670
It's not perfect yet,
but considering how much work

00:56:02.670 --> 00:56:08.820
was done on Enprise's part,
it's just incredible how far we are.

00:56:08.820 --> 00:56:12.560
The person on our end who actually
helped get it to this point and

00:56:12.660 --> 00:56:15.910
really owned this is John Berkey.

00:56:15.910 --> 00:56:19.780
John, could you stand up for a second?

00:56:24.470 --> 00:56:27.490
In fact, last year at WWDC when
I got off the stage,

00:56:27.490 --> 00:56:31.830
Blake introduced himself and told me
they were doing this work and asked

00:56:31.830 --> 00:56:33.980
if we were going to have Java 2.

00:56:33.980 --> 00:56:36.170
And I said, "Yes,
we're working on it." And then

00:56:36.170 --> 00:56:40.020
went back to the shop and just
informally said to the folks,

00:56:40.020 --> 00:56:45.060
"We have to make sure this stuff
works for next WWDC." And to see it

00:56:45.060 --> 00:56:48.540
working now again is really great.

00:56:48.540 --> 00:56:50.200
At that time, it wasn't even a product.

00:56:50.200 --> 00:56:52.930
You would come and show
me the product later on.

00:56:53.000 --> 00:56:57.820
And actually, I gave Avi a demo as well
because it was the first large,

00:56:57.820 --> 00:57:03.380
pure Java application we had seen
running on Windows at the time that

00:57:03.380 --> 00:57:05.920
looked like a great application.

00:57:05.920 --> 00:57:07.190
It wasn't slow.

00:57:07.190 --> 00:57:09.940
It didn't look funny,
and so on and so forth.

00:57:10.040 --> 00:57:14.340
Whereas a lot of the other IDEs and
products in the Java space were

00:57:14.340 --> 00:57:19.200
typically not of the fit and finish
that we typically expect at Apple.

00:57:20.200 --> 00:57:21.930
Let me find my beeper.

00:57:22.170 --> 00:57:24.190
I think it's in my pocket.

00:57:24.220 --> 00:57:28.430
The last part of the talk,
we have 15 minutes left.

00:57:28.470 --> 00:57:32.180
And because this is an overview talk,
we're advised not to do Q&A.

00:57:32.200 --> 00:57:35.160
So I don't think we're going to
have any time to do Q&A today.

00:57:35.160 --> 00:57:38.770
So I urge any of you,
if you have any questions on this stuff,

00:57:38.770 --> 00:57:43.570
either go see the other talks about
Java or come to our feedback forum,

00:57:43.570 --> 00:57:45.150
which we'll talk about later.

00:57:46.290 --> 00:57:47.900
So now I'd like to talk
about the third mug.

00:57:49.920 --> 00:57:52.910
which is integration.

00:57:53.540 --> 00:57:57.200
by far this is the most important
thing we're doing at Apple is

00:57:57.200 --> 00:58:00.400
integrating this in a sensible
integrating Java in a sensible way.

00:58:00.400 --> 00:58:04.400
What does that mean?

00:58:06.170 --> 00:58:08.800
From my perspective,
Windows deployment is totally

00:58:08.880 --> 00:58:12.290
busted now because again,
Sun has made this big leap.

00:58:12.290 --> 00:58:17.170
They went from 1.1.8 to
a 2.6 megabyte footprint,

00:58:17.390 --> 00:58:21.810
that's what those numbers say,
to a 19.2 megabyte installed

00:58:21.940 --> 00:58:24.660
footprint with 1.2.2.

00:58:24.660 --> 00:58:27.230
Microsoft doesn't bundle this.

00:58:27.370 --> 00:58:31.560
We are going to be bundling this,
so anyone who writes to the Java 2

00:58:32.010 --> 00:58:35.540
platform gets to depend on it,
on our platform.

00:58:35.540 --> 00:58:38.820
They don't have to lug it around
like they have to on Windows.

00:58:38.880 --> 00:58:45.230
To give you a sense for what
20 megabytes installed is like,

00:58:45.230 --> 00:58:48.480
I decided I'd measure Carbon.

00:58:48.540 --> 00:58:54.300
Carbon weighs in at about
11 megabytes on DP4.

00:58:54.300 --> 00:58:58.760
You know, since you're a Mac developer,
what Carbon is about.

00:58:59.060 --> 00:59:02.500
Imagine two times that,
which is again what the installed

00:59:02.980 --> 00:59:04.960
footprint is on Windows.

00:59:04.980 --> 00:59:09.910
But the installed footprint
is only one side of the story.

00:59:10.100 --> 00:59:17.580
I think the most important side of the
story is Java was not designed with

00:59:17.580 --> 00:59:21.540
a static deployment model in mind.

00:59:21.620 --> 00:59:24.370
Just think,
if you're an application and you're

00:59:24.370 --> 00:59:28.720
carrying around this Java runtime
environment that's 20 megabytes,

00:59:28.800 --> 00:59:33.120
and it's just a part of yourself,
so to speak, why are you paying for

00:59:33.120 --> 00:59:34.420
the interpretation?

00:59:34.420 --> 00:59:36.660
Why are you paying for
the class verification?

00:59:36.700 --> 00:59:38.560
Why are you paying for interpreting?

00:59:38.590 --> 00:59:43.880
There's just so much stuff you pay for
because Java is a great systems model,

00:59:43.970 --> 00:59:48.130
system language and VM model that
carrying it around makes no sense

00:59:48.180 --> 00:59:50.050
from a time perspective either.

00:59:50.080 --> 00:59:53.050
So both from a time and
a space perspective,

00:59:53.050 --> 00:59:56.620
what people are doing on
Windows is nonsensical.

00:59:56.670 --> 01:00:00.980
Sun will solve this problem, I believe,
even in spite of Microsoft,

01:00:01.140 --> 01:00:03.860
but it's solved today on our platform.

01:00:03.860 --> 01:00:08.510
So Oracle can go to their customers
when they move to Java 2 and not have

01:00:08.510 --> 01:00:15.000
to carry around another 20 megabyte jar
file every time they open a connection,

01:00:15.000 --> 01:00:15.970
for instance.

01:00:16.200 --> 01:00:19.390
So I think it's pretty critical
that we're bundling this stuff,

01:00:19.500 --> 01:00:23.960
we're tightly integrating it,
and we're going to make sure

01:00:23.960 --> 01:00:26.960
the footprint is very low.

01:00:27.440 --> 01:00:30.980
As I think most of you are aware,
we really like the Java language

01:00:31.420 --> 01:00:32.220
and virtual machine.

01:00:32.220 --> 01:00:33.860
Again, it's a great model.

01:00:33.860 --> 01:00:35.650
It's a great systems model.

01:00:35.650 --> 01:00:43.430
C++ drifted away from many application
uses at the system layer because it

01:00:43.550 --> 01:00:46.660
wasn't a great system-level object model.

01:00:46.660 --> 01:00:50.140
It's a fine object model,
but it just isn't appropriate

01:00:50.140 --> 01:00:53.100
for systems development,
and that's one of the reasons Java's

01:00:53.100 --> 01:00:55.560
taken off technically as much as it has.

01:00:55.560 --> 01:00:59.090
It's very appropriate for
a system object model.

01:00:59.200 --> 01:01:01.710
Just to further explain
what I mean by that,

01:01:01.710 --> 01:01:05.550
I'm sure some of you are aware with
the fragile base class problem,

01:01:05.550 --> 01:01:08.160
I guess is one common
way of referring to it.

01:01:08.160 --> 01:01:13.290
Basically, the ABI that a compiler
uses is in the C++ world,

01:01:13.690 --> 01:01:17.400
typically proprietary and
owned by the compiler.

01:01:17.400 --> 01:01:21.410
Java VM specifies how all .class
files are to be interpreted.

01:01:21.720 --> 01:01:24.800
This is a huge interoperability win.

01:01:24.800 --> 01:01:30.950
It means you can... migrate to new
instances of the VM fairly painlessly.

01:01:32.120 --> 01:01:37.000
We have the Java 2
Standard Edition packages.

01:01:37.050 --> 01:01:38.160
But here's where we innovate.

01:01:38.160 --> 01:01:39.100
We have WebObjects.

01:01:39.100 --> 01:01:41.420
And as you heard today,
we're going to a pure

01:01:41.420 --> 01:01:45.060
Java version of WebObjects,
but even right now it's all wrapped

01:01:45.180 --> 01:01:48.420
today so that you don't even
know it's written in Objective-C,

01:01:48.610 --> 01:01:50.060
even though it is.

01:01:50.220 --> 01:01:51.660
Cocoa is written in Objective-C.

01:01:51.660 --> 01:01:55.320
We wrapped that as well,
but it's totally accessible from Java.

01:01:55.320 --> 01:02:00.780
And QuickTime is also
accessible from Java.

01:02:00.780 --> 01:02:05.560
All three of these technologies
are incredibly important to Apple.

01:02:05.580 --> 01:02:11.390
And sitting atop is Project Builder
and Interface Builder.

01:02:11.560 --> 01:02:13.740
Let's take the tools first.

01:02:13.800 --> 01:02:18.580
I just want to show you a screenshot of
something I think you saw in the keynote.

01:02:18.580 --> 01:02:21.260
Avi brought it up briefly.

01:02:21.260 --> 01:02:25.410
We have totally rewritten what
Next used to call Project Builder.

01:02:25.680 --> 01:02:28.400
Rather than rename it,
we kept the name but

01:02:28.400 --> 01:02:30.500
rewrote the entire product.

01:02:30.730 --> 01:02:34.120
We figured most folks in
the Apple community weren't

01:02:34.120 --> 01:02:38.310
familiar with Project Builder,
so the name was sensible.

01:02:38.310 --> 01:02:41.600
We kept the name and
rewrote the whole product.

01:02:41.600 --> 01:02:47.560
What you're seeing here is a sketch,
which is on the system.

01:02:47.560 --> 01:02:48.600
You can go look at it.

01:02:48.600 --> 01:02:50.330
It's a Cocoa Objective-C program.

01:02:50.370 --> 01:02:51.670
It's a little bit silly.

01:02:51.860 --> 01:02:54.530
We still have yellow
in the package names,

01:02:54.740 --> 01:03:00.520
but they'll be renamed appropriately
before we go final with this.

01:03:02.090 --> 01:03:06.690
Right there you can see with
Project Builder we're going more for,

01:03:06.750 --> 01:03:09.500
I guess some people refer
to it as user centered,

01:03:09.590 --> 01:03:11.680
some people refer to it
as document centered,

01:03:11.680 --> 01:03:17.000
but that editor/viewer is used to
viewer edit multiple data types.

01:03:17.000 --> 01:03:19.870
In the keynote I think you
saw a fancy diagram in there.

01:03:20.000 --> 01:03:23.260
In this case you can see
there are release notes,

01:03:23.440 --> 01:03:28.000
which is an RTF file, that's a TIFF file,
and that's a Java file,

01:03:28.000 --> 01:03:29.000
all from the same context.

01:03:29.000 --> 01:03:33.000
You're not switching
to and from many apps.

01:03:33.000 --> 01:03:38.520
Project Builder is a tool
which at DP4 fully supports C,

01:03:38.630 --> 01:03:42.000
C++, ANSI C obviously,
and supports a lot of our frameworks.

01:03:42.000 --> 01:03:44.340
Java development is just coming online.

01:03:44.340 --> 01:03:46.660
It works fairly well,
but for GM it's going

01:03:46.660 --> 01:03:47.950
to work a lot better.

01:03:48.080 --> 01:03:52.000
If you care about it,
go see the Project Builder talks.

01:03:53.570 --> 01:03:57.380
Another important thing to
mention about Project Builder.

01:03:57.380 --> 01:04:00.160
You just saw the great enterprise
development environment.

01:04:00.160 --> 01:04:05.100
One of the big differences between
Project Builder and JBuilder is JBuilder

01:04:05.170 --> 01:04:09.960
is pretty much a single language,
single framework development environment.

01:04:09.960 --> 01:04:11.350
It's targeting Java 2.

01:04:11.780 --> 01:04:15.430
What Project Builder is,
is a multi-language,

01:04:15.890 --> 01:04:17.990
multi-framework development environment.

01:04:18.260 --> 01:04:21.470
Again, it supports the C-based languages
along with Java and is going to

01:04:21.510 --> 01:04:23.400
be supporting AppleScript as well.

01:04:23.400 --> 01:04:25.310
There are some demonstrations on that.

01:04:25.450 --> 01:04:29.160
There are trade-offs you make in a
multi-lingual environment that you

01:04:29.160 --> 01:04:33.160
don't have to make in a single language,
single framework environment.

01:04:33.160 --> 01:04:37.310
I believe both actually have different
markets and I hope to see both

01:04:37.310 --> 01:04:39.540
of them thrive in our community.

01:04:42.470 --> 01:04:58.710
WebObjects, they're giving their
State of the Union right now.

01:04:58.710 --> 01:04:58.710
I snarfed a couple of their slides.

01:04:58.710 --> 01:04:58.710
Fortunately, they're going at the same
time because this was going to

01:04:58.710 --> 01:04:58.710
steal some of their thunder.

01:04:58.710 --> 01:04:58.710
Powerful,
I'm sure you're familiar with it.

01:04:58.950 --> 01:05:03.330
We use it internally pretty extensively.

01:05:03.420 --> 01:05:06.600
We run our whole Apple store on it.

01:05:08.720 --> 01:05:11.170
and here are some of the features.

01:05:11.290 --> 01:05:14.310
So one thing that's important
to note with WebObjects,

01:05:14.630 --> 01:05:15.680
again, we use it.

01:05:15.680 --> 01:05:19.600
There are many,
many customers who are using it, Disney,

01:05:19.600 --> 01:05:21.180
MCI.

01:05:21.530 --> 01:05:25.100
Just Steve showed the whole
list of them at the keynote.

01:05:25.100 --> 01:05:26.960
It's technology which is very mature.

01:05:26.980 --> 01:05:29.100
It's been around for a while.

01:05:29.100 --> 01:05:34.490
And it integrates not only with Java now,
but with QuickTime for Java,

01:05:34.490 --> 01:05:37.330
as you saw in the keynote.

01:05:38.790 --> 01:05:39.870
We've won many awards.

01:05:40.150 --> 01:05:46.300
The most recent one, I believe,
is we won the CODI in March.

01:05:46.300 --> 01:05:47.150
It's critically acclaimed.

01:05:47.340 --> 01:05:48.000
5.0.

01:05:48.120 --> 01:05:50.900
The big thing with 5.0 is
it's going to pure Java.

01:05:50.900 --> 01:05:53.330
Right now,
it depends on the Objective-C runtime

01:05:53.410 --> 01:05:54.360
for its deployment.

01:05:54.360 --> 01:05:59.640
The benefit of going pure Java is
WebObjects can benefit from all the

01:05:59.640 --> 01:06:04.170
other Java VMs that are being done at HP,
at Sun, and so on,

01:06:04.270 --> 01:06:07.160
just as we're investing in Java.

01:06:07.160 --> 01:06:12.610
It means we don't have to deploy
some of the Objective-C technology

01:06:12.610 --> 01:06:13.890
on some of the servers.

01:06:14.170 --> 01:06:16.100
and it uses JDBC.

01:06:16.100 --> 01:06:19.200
I don't know when 5.0
is going to be released.

01:06:19.230 --> 01:06:20.640
I guess I shouldn't say.

01:06:20.740 --> 01:06:25.110
In the future.

01:06:25.200 --> 01:06:27.660
Quick time for Java.

01:06:28.130 --> 01:06:30.530
I won't go into it,
except there's a beautiful

01:06:30.530 --> 01:06:31.850
book that's been written.

01:06:32.170 --> 01:06:35.570
I don't have a copy,
and I couldn't get a screenshot of it,

01:06:35.570 --> 01:06:40.220
but I urge you to take a look at Stacy's
or wherever you buy your computer books.

01:06:40.380 --> 01:06:42.760
There's a great book
on QuickTime for Java.

01:06:43.050 --> 01:06:46.030
Again, it gives you the real
professional quality digital

01:06:46.030 --> 01:06:49.830
media capabilities from Java,
and in fact allows those class

01:06:49.830 --> 01:06:53.300
files to be used verbatim
on either Windows or Mac.

01:06:53.300 --> 01:06:57.620
There's nothing proprietary or special
that we're doing to make this work.

01:06:59.840 --> 01:07:03.550
and there's a quick time for
Java talk actually right after this

01:07:03.550 --> 01:07:12.810
one that'll probably be a really
nice talk for you to attend in A2.

01:07:15.050 --> 01:07:20.390
The Swing integration we've done
is pretty unique in that many of

01:07:20.390 --> 01:07:24.910
the platform look and feels that
are done with Swing are emulated.

01:07:24.950 --> 01:07:28.360
That means they don't interact
with the native system at all.

01:07:28.670 --> 01:07:31.520
They try and emulate the look and feel.

01:07:31.520 --> 01:07:35.920
What happens there, as you can imagine,
is when the look and feel changes,

01:07:35.920 --> 01:07:42.240
you have to then re-emulate or end
up having the wrong look and feel.

01:07:42.240 --> 01:07:45.730
In addition to changes,
sometimes you just get it wrong

01:07:45.730 --> 01:07:48.710
because you didn't really understand
what the native look and feel was.

01:07:48.910 --> 01:07:53.840
There's a whole class of bugs that
usually crop up around emulation.

01:07:53.840 --> 01:07:57.040
What we're doing is integrating
directly with the appearance manager.

01:07:57.170 --> 01:08:03.670
The Aqua look and feel you saw on
stage in the WebObjects demo with

01:08:03.670 --> 01:08:07.340
Swing was a Swing application that was,
again,

01:08:07.340 --> 01:08:09.760
written directly to appearance manager.

01:08:09.760 --> 01:08:16.310
The Java programmer didn't know
anything about the integration.

01:08:16.550 --> 01:08:16.760
It just happened automagically.

01:08:16.760 --> 01:08:20.430
We also do the correct menu placement.

01:08:21.700 --> 01:08:31.300
[Transcript missing]

01:08:31.730 --> 01:08:35.040
Now that Java is fairly fast,
and I think it shows that that demo,

01:08:35.040 --> 01:08:39.790
again, that's a large application,
the performance of it is fairly good.

01:08:40.080 --> 01:08:43.310
So the only problem, so to speak,
with that app is it didn't

01:08:43.310 --> 01:08:45.140
have the Aqua look and feel.

01:08:45.250 --> 01:08:51.430
So I'm going to bring Blake up
briefly to show you that.

01:08:58.400 --> 01:09:03.600
: What we're going to do is have
a quick look at the fact that

01:09:03.600 --> 01:09:08.020
JBuilder was designed from the
beginning to be look and feel aware.

01:09:08.380 --> 01:09:12.440
So when we go to choose IDE options,
it gives us the ability,

01:09:12.440 --> 01:09:15.740
among other things, to switch between the
installed look and feel.

01:09:15.870 --> 01:09:20.010
So here the Mac OS adaptive look and feel
is just one of the ones that shows up.

01:09:20.110 --> 01:09:25.630
So once we pick that and hit OK,
we'll see that we get

01:09:25.630 --> 01:09:26.110
the Aqua look and feel.

01:09:31.500 --> 01:10:02.300
[Transcript missing]

01:10:08.100 --> 01:10:14.500
[Transcript missing]

01:10:25.500 --> 01:10:25.500
Okay.

01:10:25.500 --> 01:10:25.500
So actually, I have these boring --
these will seem boring now.

01:10:25.500 --> 01:10:25.500
But that's good.

01:10:25.500 --> 01:10:25.500
So you can see --

01:10:26.110 --> 01:10:26.910
What did I do?

01:10:26.990 --> 01:10:28.540
Oh, I hit, okay.

01:10:28.610 --> 01:10:30.970
So, you can see switching back and forth.

01:10:31.390 --> 01:10:35.000
It's almost like, well,
let's go to the next one.

01:10:35.200 --> 01:10:37.150
Here's a, it's called Metal.

01:10:37.350 --> 01:10:39.300
It's the built-in Java look and feel.

01:10:39.300 --> 01:10:42.790
And when you switch to Aqua,
it's almost like it comes to life.

01:10:42.940 --> 01:10:47.400
It's just so much prettier.

01:10:47.400 --> 01:10:51.400
Right.

01:10:57.210 --> 01:11:03.900
So, unfortunately, some of this cool
Aqua integration isn't in DP4,

01:11:03.910 --> 01:11:06.120
so you guys won't be able
to play with it for DP4.

01:11:06.120 --> 01:11:07.240
Sorry about that.

01:11:07.240 --> 01:11:11.690
We actually hope to do a net
release in between now and GM,

01:11:11.690 --> 01:11:15.960
where you can get some of this stuff
from us before we actually go GM.

01:11:16.320 --> 01:11:20.180
We're going to improve our
project builder support for Java.

01:11:20.180 --> 01:11:22.050
I think I mentioned that.

01:11:22.280 --> 01:11:25.640
We're going to a new
application embedding model.

01:11:25.640 --> 01:11:28.200
The main folks who care
about this are like OmniWeb,

01:11:28.200 --> 01:11:31.080
the Internet Explorer folks.

01:11:31.390 --> 01:11:37.190
That's how you embed a VM and
an applet within an application.

01:11:37.330 --> 01:11:40.690
But you may have an application that
wants to embed this stuff within you.

01:11:40.690 --> 01:11:46.070
If so, then you'll have this application
embedding model that we're doing.

01:11:46.910 --> 01:11:47.830
Wow, closing thoughts.

01:11:47.960 --> 01:11:49.190
We have how many minutes?

01:11:49.240 --> 01:11:52.990
We have four minutes left.

01:11:53.350 --> 01:11:58.010
I guess what's getting fun now
is we have a team that's kicking

01:11:58.010 --> 01:12:02.590
some serious butt on this stuff,
and there's real applications that are

01:12:02.620 --> 01:12:09.300
starting to get exciting like Velocity,
like Oracle's apps, like this beautiful

01:12:09.300 --> 01:12:11.900
IDE that Enprise has done.

01:12:11.900 --> 01:12:14.430
Fundamentally, that's what we do.

01:12:14.430 --> 01:12:18.410
There's no way to look at Java by
itself and say it's great.

01:12:18.530 --> 01:12:21.750
You have to look at the applications
that are going to be produced on

01:12:21.750 --> 01:12:24.160
top of it and say they're great.

01:12:24.160 --> 01:12:27.700
If in fact they're great,
then we're happy and we

01:12:27.870 --> 01:12:29.940
know we're doing a good job.

01:12:29.970 --> 01:12:31.320
I have two or three minutes left.

01:12:31.380 --> 01:12:36.710
I'd like to bring the team up and
give them a round of applause.
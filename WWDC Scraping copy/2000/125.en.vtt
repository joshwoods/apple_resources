WEBVTT

00:00:15.910 --> 00:00:18.900
Ladies and gentlemen,
please welcome David Wright,

00:00:18.900 --> 00:00:22.900
Mac OS X Applications Technology Manager.

00:00:26.870 --> 00:00:30.600
Welcome everybody to
session 125 Core Foundation:

00:00:30.600 --> 00:00:31.420
Advanced.

00:00:31.420 --> 00:00:34.170
So after the last session
I heard two comments.

00:00:34.170 --> 00:00:38.230
One developer said this stuff was blowing
him away and someone else said they

00:00:38.320 --> 00:00:40.490
can't wait to get their hands on it.

00:00:40.490 --> 00:00:44.220
So I'm really pleased to introduce
more of it in this advanced session.

00:00:44.250 --> 00:00:46.980
So at this time please
welcome Becky Willrich from

00:00:46.980 --> 00:00:48.430
the Cocoa Framework team.

00:00:53.470 --> 00:00:55.450
Thank you, David.

00:00:55.850 --> 00:00:58.400
Wow, well welcome back.

00:00:58.400 --> 00:01:04.790
So we're just going to continue what
we started talking about this morning.

00:01:07.580 --> 00:01:12.080
I'm Becky Willrich still.

00:01:12.110 --> 00:01:16.100
And what we're going to do today in
this afternoon is continue where the

00:01:16.110 --> 00:01:19.070
Core Foundation basics picked up.

00:01:19.070 --> 00:01:21.800
So for those of you that maybe
did not make this morning's talk,

00:01:21.800 --> 00:01:25.600
we're going to repeat some of the
initial parts where we talk about where

00:01:25.600 --> 00:01:28.800
Core Foundation lives inside of Mac OS X.

00:01:29.040 --> 00:01:33.300
And then we're going to move on and
look at some of the subsystems and

00:01:33.300 --> 00:01:36.220
services that Core Foundation provides.

00:01:37.610 --> 00:01:41.790
So, in particular we're going to be
looking at CFBundle and CFPlugin and

00:01:41.960 --> 00:01:44.770
what they can do for you.

00:01:44.770 --> 00:01:49.790
Then we're going to talk a little
bit about preferences and how CF can

00:01:49.790 --> 00:01:52.280
make it easier for you to manage
user preferences in your application.

00:01:52.390 --> 00:01:56.610
We're going to look very briefly
at what XML services are provided.

00:01:56.610 --> 00:01:59.090
And then finally we're going to
spend a moment talking about advanced

00:01:59.180 --> 00:02:02.750
memory tricks that you can use
when working with Core Foundation.

00:02:02.760 --> 00:02:05.760
As I mentioned in this morning's talk,
Core Foundation lives right

00:02:05.780 --> 00:02:07.440
above the operating system layer.

00:02:07.530 --> 00:02:12.480
And at that layer we are very concerned
with performance because we impact most

00:02:12.480 --> 00:02:14.800
everything that runs on the system.

00:02:14.900 --> 00:02:19.640
That's reflected in the APIs and there
are a number of advanced tricks you can

00:02:19.640 --> 00:02:20.390
use to reduce your memory footprint.

00:02:21.720 --> 00:02:23.320
So just to repeat what
I said this morning,

00:02:23.450 --> 00:02:27.200
Core Foundation is the
lingua franca on Mac OS X.

00:02:27.220 --> 00:02:32.640
It is the language by which you can
communicate across both Carbon and Cocoa.

00:02:32.790 --> 00:02:34.730
So there's the same definition
you saw this morning:

00:02:34.750 --> 00:02:38.700
a medium of communication between
peoples of different languages.

00:02:38.940 --> 00:02:41.880
And for us,
we're interested in communicating

00:02:42.010 --> 00:02:43.700
between Carbon and Cocoa.

00:02:45.790 --> 00:02:50.540
So there's the architecture
diagram for Mac OS X.

00:02:50.540 --> 00:02:53.100
And there we are inside
the core services layer.

00:02:53.100 --> 00:02:58.260
The core services layer, remember,
is that layer where many common

00:02:58.260 --> 00:03:03.450
application needs are provided
that are below the graphics layer.

00:03:03.720 --> 00:03:07.240
So in particular, you'll see the file
manager inside of there,

00:03:07.240 --> 00:03:09.680
the alias and resource managers as well.

00:03:09.920 --> 00:03:13.480
And beneath all of that is
Core Foundation providing the basic

00:03:13.480 --> 00:03:15.840
types used throughout the system.

00:03:17.200 --> 00:03:21.150
So this morning we talked about the
basic data types in Core Foundation:

00:03:21.150 --> 00:03:23.870
strings, arrays, dictionaries,
and then finally how it all

00:03:23.870 --> 00:03:26.500
came together as property lists.

00:03:26.580 --> 00:03:29.840
Now we're going to focus on the
second half of the equation:

00:03:29.920 --> 00:03:33.260
the non-graphical services
that Core Foundation provides

00:03:33.720 --> 00:03:35.630
to all its clients.

00:03:35.730 --> 00:03:40.000
In particular, we're going to look at
localization support as provided

00:03:40.450 --> 00:03:42.820
by CFBundle and user preferences.

00:03:44.390 --> 00:03:47.290
So what do I mean when
I talk about a CF service?

00:03:47.400 --> 00:03:51.900
What I'm talking about is an integrated
subsystem that's built based on the

00:03:51.920 --> 00:03:54.470
CF types that we saw this morning.

00:03:54.610 --> 00:03:56.670
There are several
inside Core Foundations,

00:03:56.670 --> 00:03:59.250
some of which you are likely
to never use yourself.

00:03:59.350 --> 00:04:01.760
CFRunLoop is an example.

00:04:01.860 --> 00:04:04.720
We use the RunLoop to maintain
the main event loop in both

00:04:04.900 --> 00:04:06.730
Carbon and Cocoa applications.

00:04:06.840 --> 00:04:09.650
In all likelihood,
you'll never need to use it,

00:04:09.750 --> 00:04:13.530
but it's silently doing its work
inside of a Carbon application

00:04:13.530 --> 00:04:15.180
or a Cocoa application.

00:04:15.250 --> 00:04:17.520
Others you will find
yourself using directly.

00:04:17.570 --> 00:04:21.030
CFBundle is an example of that.

00:04:21.990 --> 00:04:27.010
So this afternoon we're going to be
talking particularly about CFBundle,

00:04:27.070 --> 00:04:29.840
which you will use to get at
the different pieces inside

00:04:29.850 --> 00:04:32.240
your applications package.

00:04:32.360 --> 00:04:36.590
CFPreferences, which you can use to
store user preferences.

00:04:36.590 --> 00:04:39.600
CFPreferences will do the work of
reading and writing to file and

00:04:39.720 --> 00:04:42.940
creating the persistency format for you.

00:04:43.070 --> 00:04:46.130
And CF XML Parser,
which if you're interested

00:04:46.260 --> 00:04:50.760
in parsing XML files,
obviously we'll give you a hand.

00:04:51.730 --> 00:04:54.500
So with that, I'm going to turn the stage
over to Doug Davidson,

00:04:54.500 --> 00:04:57.700
my colleague, who's going to spend some
time talking about bundles

00:04:57.700 --> 00:05:00.160
in the app packaging scheme.

00:05:00.160 --> 00:05:00.450
Doug?

00:05:00.510 --> 00:05:02.190
Thanks, Becky.

00:05:05.470 --> 00:05:06.500
So I'm Doug Davidson.

00:05:06.560 --> 00:05:07.300
Good afternoon.

00:05:07.350 --> 00:05:09.910
I'm here to talk to you about bundles.

00:05:09.980 --> 00:05:13.740
What they are, what they do,
how to use them.

00:05:13.800 --> 00:05:17.180
By the end of this talk,
you should know what bundles are

00:05:17.250 --> 00:05:23.470
and what they can do for you,
how to use the CFBundle APIs to

00:05:23.470 --> 00:05:27.220
deal with them,
and where to go to get more

00:05:27.220 --> 00:05:27.220
detailed information about them.

00:05:28.010 --> 00:05:31.100
So, first of all, what is a bundle?

00:05:31.140 --> 00:05:35.240
A bundle is a way to treat all
of the files associated with an

00:05:35.240 --> 00:05:36.900
executable as a single object.

00:05:36.900 --> 00:05:42.710
Now, once upon a time,
an application was a single simple thing,

00:05:42.940 --> 00:05:44.470
just an executable file.

00:05:44.470 --> 00:05:46.900
But, applications need resources.

00:05:46.900 --> 00:05:50.780
So you add a resource fork and
you put resources in there and

00:05:50.870 --> 00:05:52.900
you still have a single file.

00:05:52.900 --> 00:05:57.890
But, applications have a way of
accumulating other files with them.

00:05:58.340 --> 00:06:04.890
Additional executables, libraries,
text files, quick time content, HTML,

00:06:04.920 --> 00:06:05.900
all sorts of stuff.

00:06:05.900 --> 00:06:08.410
Now, with Mac OS X,
it gets even worse because you

00:06:08.470 --> 00:06:11.900
might want to have potentially
different versions of this stuff,

00:06:11.900 --> 00:06:15.770
one for Mac OS 8 and 9
and one for Mac OS X.

00:06:15.900 --> 00:06:21.190
Plus, this is a multilingual system,
which means that you would want to have

00:06:21.190 --> 00:06:22.900
different versions of these things.

00:06:23.090 --> 00:06:26.740
Some of these things for the different
languages or language regions that

00:06:26.740 --> 00:06:28.900
your application is localized into.

00:06:28.900 --> 00:06:30.820
So,
how are you going to hold all this stuff?

00:06:30.900 --> 00:06:33.900
The answer is in a bundle.

00:06:34.680 --> 00:06:36.890
Now what can a bundle hold?

00:06:36.990 --> 00:06:39.640
First of all,
a bundle can be wrapped around many

00:06:39.640 --> 00:06:41.850
different kinds of executables.

00:06:41.960 --> 00:06:44.840
Application packages are bundles.

00:06:44.940 --> 00:06:47.100
Frameworks are bundles.

00:06:47.190 --> 00:06:48.210
They have loadable bundles.

00:06:48.370 --> 00:06:50.910
Plug-ins can be bundles.

00:06:51.180 --> 00:06:56.850
A bundle can contain multiple executables
and it can potentially contain

00:06:57.020 --> 00:07:02.150
different versions of these executables,
one for Mac OS 8 and 9, one for Mac OS X,

00:07:02.150 --> 00:07:03.320
if you like.

00:07:04.400 --> 00:08:48.300
[Transcript missing]

00:08:49.360 --> 00:08:52.300
Some characteristics of bundles.

00:08:52.300 --> 00:08:54.200
Bundles are cross-platform.

00:08:54.200 --> 00:08:58.390
That means Mac OS 8 and 9 and Mac OS X.

00:08:58.440 --> 00:09:01.010
Anything in them can be versioned.

00:09:01.480 --> 00:09:04.900
One version for Mac OS 8 and 9,
one version for 10.

00:09:04.900 --> 00:09:06.390
They are multilingual.

00:09:06.440 --> 00:09:10.320
You can have different versions of
your resources for particular languages

00:09:10.320 --> 00:09:12.640
or particular language regions.

00:09:12.720 --> 00:09:16.060
Cross-binary.

00:09:16.060 --> 00:09:19.540
On Mac OS X we have both
CFM and Mac OS binaries.

00:09:19.540 --> 00:09:21.830
And CFBundle will automatically
know the difference,

00:09:21.860 --> 00:09:25.070
understand both,
and automatically provide the glue

00:09:25.070 --> 00:09:27.060
to allow you to call between them.

00:09:28.120 --> 00:09:30.560
Self-contained, movable, renameable.

00:09:30.560 --> 00:09:36.700
They're designed to be a single
object to the user so that,

00:09:36.730 --> 00:09:39.080
for example,
your install procedure can just

00:09:39.080 --> 00:09:41.000
be drag and drop in the finder.

00:09:41.040 --> 00:09:44.990
For your uninstall procedure,
just a drag and drop, rename them.

00:09:44.990 --> 00:09:50.000
As long as the internals are not touched,
the bundle does not break.

00:09:50.160 --> 00:09:53.000
And finally, file system independent.

00:09:53.000 --> 00:09:59.000
That means they're designed so that it
is not necessary to use resource forks.

00:09:59.000 --> 00:10:03.840
So that these bundles can be
moved to file systems that may not

00:10:03.970 --> 00:10:06.980
have support for different forks.

00:10:07.000 --> 00:10:10.320
So you could store them
on arbitrary file systems,

00:10:10.420 --> 00:10:13.000
arbitrary servers, CD ROMs, etc.

00:10:13.000 --> 00:10:19.000
And without loss of fidelity,
you can just drag and drop from them.

00:10:19.000 --> 00:10:21.000
Or maybe you don't even
need to install them.

00:10:21.000 --> 00:10:24.000
Maybe you just launch it
directly from the server.

00:10:27.150 --> 00:10:30.900
Now, I should say one thing that bundles
don't provide is they don't provide

00:10:30.900 --> 00:10:32.500
a space for you to write on.

00:10:32.500 --> 00:10:34.560
If you have files that
you need to write out,

00:10:34.560 --> 00:10:37.000
those should probably go somewhere else.

00:10:37.020 --> 00:10:39.580
And one reason for this is
because your application might

00:10:39.580 --> 00:10:42.000
have been launched from a server,
from a CD-ROM.

00:10:42.000 --> 00:10:45.000
It's kind of hard to write to a CD-ROM.

00:10:45.000 --> 00:10:51.030
The next section of this talk about
CFPreferences will go into a little

00:10:51.110 --> 00:10:53.110
more detail about possible places
where you can write out files.

00:10:55.740 --> 00:10:58.480
Now, I thought that probably the best
way to explain about bundles

00:10:58.560 --> 00:11:00.960
would be to just show you one.

00:11:00.960 --> 00:11:04.210
So, if we could get demo two here.

00:11:09.900 --> 00:11:11.460
I've made up a simple bundle.

00:11:11.460 --> 00:11:13.900
This happens to be an
application package.

00:11:14.110 --> 00:11:16.490
I called it simple test.

00:11:18.760 --> 00:11:20.910
And so here's my install procedure.

00:11:21.110 --> 00:11:23.370
Notice I'm copying to the desktop.

00:11:23.400 --> 00:11:24.390
That's it.

00:11:24.470 --> 00:11:27.580
Here's my uninstall procedure.

00:11:27.580 --> 00:11:29.570
Let's see that again.

00:11:32.490 --> 00:11:34.770
Okay, now just one thing.

00:11:34.970 --> 00:11:35.900
It's obvious how to launch it.

00:11:36.100 --> 00:11:37.900
Double click on it.

00:11:39.470 --> 00:11:41.610
And here's my application.

00:11:41.610 --> 00:11:42.740
Okay.

00:11:42.840 --> 00:11:46.380
But suppose I prefer to work in French.

00:11:46.450 --> 00:11:46.870
Okay.

00:11:47.130 --> 00:11:49.190
Now I'm working in French.

00:11:54.240 --> 00:11:59.940
Here's my application in French.

00:11:59.940 --> 00:12:02.580
Or maybe I prefer Japanese.

00:12:13.590 --> 00:12:16.520
One thing I want you to notice
is that this is not just

00:12:16.530 --> 00:12:19.400
picking a single language,
this is a preference order.

00:12:19.530 --> 00:12:26.610
So suppose I prefer Italian,
my second choice is German, then French.

00:12:26.950 --> 00:12:32.160
Now, I didn't actually localize
this application into Italian.

00:12:32.230 --> 00:12:37.580
So when I launch it,
what I get is my second choice,

00:12:37.580 --> 00:12:39.790
which was German.

00:12:46.120 --> 00:12:52.300
So now let's take a look and
see what's inside this bundle.

00:12:52.300 --> 00:12:54.830
Now what I want to say is this
is a typical bundle layout,

00:12:54.840 --> 00:12:57.580
but I don't want you to pay too
much attention to exactly the

00:12:57.580 --> 00:12:59.240
details of where things are located.

00:12:59.240 --> 00:13:02.640
There are several variations,
just look at the various components

00:13:02.640 --> 00:13:03.810
and how they work together.

00:13:03.830 --> 00:13:06.320
See a bundle understands
all the variations,

00:13:06.380 --> 00:13:10.140
past, present, and future,
and it will deal with them for you.

00:13:10.140 --> 00:13:12.660
So what do we have?

00:13:12.730 --> 00:13:14.090
First of all we have our executables.

00:13:14.130 --> 00:13:17.420
This is the executable
for Mac OS plus 10.

00:13:19.910 --> 00:13:25.040
And there is another version of
the executable for Mac OS 8 and 9

00:13:25.040 --> 00:13:28.700
called-- labeled Mac OS Classic.

00:13:28.810 --> 00:13:30.030
What else do we have?

00:13:30.140 --> 00:13:32.240
We have the metadata that I talked about.

00:13:32.350 --> 00:13:35.070
There's a special file
called package info,

00:13:35.070 --> 00:13:38.420
just holds the type and
creator information.

00:13:38.860 --> 00:13:42.760
and then we have the Info.plist which
holds our info dictionary.

00:13:42.760 --> 00:13:46.090
So I want to take a special look at that.

00:13:46.460 --> 00:13:48.440
And here that is.

00:13:48.470 --> 00:13:51.450
And I have set up a
number of keys in here.

00:13:51.730 --> 00:13:54.830
I just want to point out some of them.

00:13:55.020 --> 00:13:57.140
CFBundle executable.

00:13:57.210 --> 00:14:03.100
That is what tells CFBundle what your
primary executable is for this bundle.

00:14:03.900 --> 00:14:09.600
[Transcript missing]

00:14:12.040 --> 00:14:14.000
There are a number of others.

00:14:14.000 --> 00:14:14.800
Let's see.

00:14:14.800 --> 00:14:16.760
See a bundle identifier.

00:14:16.760 --> 00:14:21.470
This is supposed to be a unique
identification string for your bundle.

00:14:21.560 --> 00:14:26.970
We recommend that people use the
format that may be familiar from Java,

00:14:26.990 --> 00:14:35.000
which is com.yourname, and so forth,
a reverse Internet name.

00:14:35.000 --> 00:14:39.390
Just so that you'll get a unique
string so that each bundle

00:14:39.450 --> 00:14:41.820
can be uniquely identified.

00:14:43.420 --> 00:14:49.990
Now, there are many possible keys that
could go in the info dictionary.

00:14:49.990 --> 00:14:49.990
And, um, I'm going

00:14:50.250 --> 00:14:52.460
Some of them have
significance to see a bundle.

00:14:52.460 --> 00:14:55.600
Some of them have significance
to other things like the finder.

00:14:55.640 --> 00:14:57.360
There is going to be
another talk tomorrow,

00:14:57.360 --> 00:15:00.120
I believe it is,
on application packaging in particular,

00:15:00.630 --> 00:15:06.070
which will discuss in much more
detail what the finder wants to see.

00:15:06.870 --> 00:15:10.340
Some of these entries in
the InfoDictionary can be

00:15:10.340 --> 00:15:15.630
localized themselves and I'll
go into that a little later.

00:15:18.300 --> 00:15:21.190
So what else is there in the bundle?

00:15:21.260 --> 00:15:23.900
Well, we have the resources.

00:15:23.930 --> 00:15:26.020
And first of all,
let's take a look at the

00:15:26.020 --> 00:15:28.720
non-localized resources,
those that don't depend on

00:15:28.720 --> 00:15:30.520
which language you're using.

00:15:31.150 --> 00:15:35.490
And simpletest.rsrc.

00:15:35.640 --> 00:15:40.930
This contains the non-localized resource
manager resources for this application

00:15:41.130 --> 00:15:44.090
in the data fork of that file.

00:15:44.430 --> 00:15:46.300
And there is also
another version of that,

00:15:46.300 --> 00:15:49.960
SimpleTest Mac OS Classic,
which contains the same

00:15:49.960 --> 00:15:53.000
thing but for Mac OS 8 and 9.

00:15:53.600 --> 00:15:57.270
You don't actually have to have that,
but if you have separate versions,

00:15:57.270 --> 00:16:01.160
you can have separate versions
for different platforms.

00:16:01.230 --> 00:16:06.370
Then I have an icon and, oh,
maybe a movie.

00:16:06.460 --> 00:16:09.110
Anything you want, you can put in here.

00:16:09.570 --> 00:16:13.280
Now we also have localized resources,
and these are in separate

00:16:13.280 --> 00:16:16.300
folders for this type of
languages or language regions.

00:16:16.440 --> 00:16:25.120
So for English, I have in localized.rsrc,
I have the localized resource manager

00:16:25.150 --> 00:16:28.120
resources for this application.

00:16:28.490 --> 00:16:34.020
And then I have the simple test.nib,
which is one of those interface builder,

00:16:34.020 --> 00:16:36.320
interface definitions.

00:16:36.320 --> 00:16:38.860
And if you haven't seen
interface builder in action,

00:16:38.860 --> 00:16:40.680
you really should.

00:16:40.940 --> 00:16:44.480
Then I have info-plist.strings.

00:16:44.720 --> 00:16:48.760
This is what contains the localizations
for any of the items in the info

00:16:48.760 --> 00:16:51.480
dictionary that need localizing.

00:16:52.040 --> 00:16:56.340
and localizable.strings,
which contains localizations

00:16:56.340 --> 00:16:58.340
for other CFStrings.

00:16:58.430 --> 00:17:02.400
We give special attention to the
localization of CFStrings because the

00:17:02.500 --> 00:17:07.600
CFString is our basic Unicode-savvy,
internationalization-ready string,

00:17:07.680 --> 00:17:11.090
and so it's the most common
thing you want to localize.

00:17:11.200 --> 00:17:14.270
and then anything else
that I want to put in here.

00:17:14.270 --> 00:17:16.600
And then you'll see that the French

00:17:16.900 --> 00:17:28.950
The CFBundle automatically picks the
right one based on the user's language

00:17:28.950 --> 00:17:28.950
preferences and on the platform.

00:17:29.850 --> 00:17:34.240
There is also another talk
tomorrow afternoon specifically on

00:17:34.240 --> 00:17:37.780
Mac OS X localization which will
go into this in much more detail.

00:17:37.800 --> 00:17:46.180
Now,
if we could get the slides back on...

00:17:52.250 --> 00:17:58.340
So, now we just talked about bundles
as they live on the disk.

00:17:58.420 --> 00:17:59.700
Now what is a CFBundle?

00:17:59.700 --> 00:18:04.290
A CFBundle is a programmatic
object that represents the bundle

00:18:04.290 --> 00:18:07.070
on the disk to your application.

00:18:07.100 --> 00:18:10.150
So, if you know that there's a bundle,
how do you create the

00:18:10.150 --> 00:18:12.100
CFBundle that corresponds to it?

00:18:12.100 --> 00:18:15.090
A canonical way to do so is simple.

00:18:15.120 --> 00:18:18.390
You take the URL that points to the
bundle's location and pass it into

00:18:18.430 --> 00:18:21.730
CFBundleCreate and you get a CFBundle.

00:18:22.660 --> 00:18:28.700
If the code for the bundle is already
loaded and running in your process,

00:18:28.700 --> 00:18:32.500
then there are other ways to
get a hold of the CFBundle.

00:18:32.500 --> 00:18:35.900
For example,
the bundle for the application

00:18:35.900 --> 00:18:38.200
itself is called the main bundle.

00:18:38.270 --> 00:18:45.390
And you use CFBundle get main bundle,
and it gives you the main bundle,

00:18:45.390 --> 00:18:46.590
no arguments.

00:18:46.860 --> 00:18:51.200
If you have some other bundle,
perhaps a framework or a loadable bundle,

00:18:51.320 --> 00:18:56.300
plug-in, and you know that its code
has already been loaded,

00:18:56.500 --> 00:18:58.980
then you can look it
up by its identifier.

00:18:59.230 --> 00:19:02.450
Remember, the identifier was that unique
string that we talked about.

00:19:02.560 --> 00:19:06.340
This is very useful, for example,
if you have a framework,

00:19:06.380 --> 00:19:09.250
a loadable bundle,
you don't necessarily want to know

00:19:09.250 --> 00:19:13.380
exactly where it's located on the disk,
but once it's loaded inside its code,

00:19:13.410 --> 00:19:14.690
you want to be able to find its bundle.

00:19:14.700 --> 00:19:17.940
So you look it up by the identifier.

00:19:18.020 --> 00:19:22.730
Now then, once you have a CFBundle,
what can you do with it?

00:19:23.370 --> 00:19:27.020
Well, probably the most important,
most common thing is to look

00:19:27.140 --> 00:19:29.360
up these bundle resources.

00:19:29.410 --> 00:19:31.340
Again, it's very simple.

00:19:31.440 --> 00:19:33.760
CFBundle copy resource URL.

00:19:33.820 --> 00:19:36.030
You pass in the name of
the resource you want,

00:19:36.030 --> 00:19:40.130
and CFBundle returns you
a URL that points to it.

00:19:41.210 --> 00:19:44.590
It will look up the correct version
based on the user's language

00:19:44.590 --> 00:19:47.300
preference again on the platform.

00:19:48.360 --> 00:19:52.360
Another thing you may want to do
is to look at the metadata from the

00:19:52.360 --> 00:19:56.890
info dictionary and see if bundle
get value for info dictionary key.

00:19:57.110 --> 00:20:00.250
You pass in a key,
it passes out a value correctly

00:20:00.250 --> 00:20:03.270
localized if that particular
value happens to be localized.

00:20:03.290 --> 00:20:10.950
And there's also a CFBundle get package
info which gets the type and creator that

00:20:10.950 --> 00:20:10.950
I mentioned in the package info file.

00:20:12.890 --> 00:20:14.890
What else can you do with CFBundle?

00:20:14.990 --> 00:20:20.290
Well, as I mentioned,
you can have resource manager resources.

00:20:20.290 --> 00:20:25.640
And so there is an API CFBundle,
OpenBundleResourceFiles,

00:20:25.700 --> 00:20:32.560
which simply opens both the non-localized
and the localized resource manager

00:20:32.560 --> 00:20:35.550
resource files for that application.

00:20:35.800 --> 00:20:40.290
Now, in case of an application bundle,
you actually don't need to call this.

00:20:40.290 --> 00:20:42.730
It will be done automatically
for you on launch.

00:20:42.800 --> 00:20:43.800
But if you have some
other kind of bundle,

00:20:43.800 --> 00:20:47.800
framework, loadable bundle that have
resource manager resources in it,

00:20:47.800 --> 00:20:51.630
you might need to call this
API yourself explicitly.

00:20:52.380 --> 00:20:54.510
And as I mentioned,
we give special attention to

00:20:54.510 --> 00:20:57.100
the localization of CFStrings.

00:20:57.160 --> 00:21:01.710
And so we have a number of functions
starting with CF copy localized

00:21:01.710 --> 00:21:06.450
string to get the localizations
of CFStrings out of files like the

00:21:06.450 --> 00:21:09.700
localizable.strings that I mentioned.

00:21:12.180 --> 00:21:13.850
What else can CFBundle do?

00:21:13.950 --> 00:21:17.280
Well, CFBundle can also load code.

00:21:18.230 --> 00:21:21.920
And again, it's very simple.

00:21:22.300 --> 00:21:26.550
All you do is tell your bundle, load,
CFBundle load executable,

00:21:26.550 --> 00:21:27.740
and it loads the code.

00:21:27.750 --> 00:21:32.670
CFBundle automatically figures out on
OS X whether the code is CFM or MachO and

00:21:32.670 --> 00:21:34.980
uses the correct procedure to load it.

00:21:34.980 --> 00:21:39.150
Of course, on OS X and 9, it's just CFM.

00:21:39.940 --> 00:21:44.790
And once you have the code loaded,
then you can,

00:21:44.810 --> 00:21:48.270
if you want to call into it,
and you can look up functions by name,

00:21:48.400 --> 00:21:54.260
and CFBundle will return
you a function pointer.

00:21:54.260 --> 00:21:54.260
And, um,

00:21:54.530 --> 00:21:58.490
Whether you are calling from
CFM or MacO and whether the bundle

00:21:58.500 --> 00:22:02.120
you are loading is CFM or MacO,
CFBundle automatically figures out and

00:22:02.120 --> 00:22:04.450
returns an appropriate function pointer.

00:22:04.450 --> 00:22:06.660
In either case, it can be used to call.

00:22:06.710 --> 00:22:08.800
One caveat though.

00:22:09.130 --> 00:22:15.540
On DP4, if you are calling this from CFM,
then in order for it to work correctly,

00:22:15.540 --> 00:22:19.850
you must have turned on the
new Carbon vector libraries.

00:22:19.890 --> 00:22:25.340
This is described in the Code Fragment
Manager release note on your CD.

00:22:25.840 --> 00:22:30.140
In future, this will be available
all the time to everyone.

00:22:33.600 --> 00:22:37.030
Okay.

00:22:37.110 --> 00:22:42.040
Now the next thing I wanted
to talk about is CFPlugin.

00:22:44.370 --> 00:22:49.220
If you're writing plug-ins,
perhaps the functionality I just

00:22:49.240 --> 00:22:50.860
talked about is perfectly fine for you.

00:22:50.860 --> 00:22:55.570
All you want to do is be able to load
code and look up functions by name.

00:22:55.650 --> 00:22:58.960
Or maybe you already have your
own plug-in model that manages the

00:22:58.960 --> 00:23:01.630
interface between the application
and the plug-in yourself.

00:23:01.700 --> 00:23:04.790
In that case, you may not need to
look at CFPlugin at all.

00:23:04.950 --> 00:23:07.980
However,
if you're looking for a sophisticated

00:23:07.980 --> 00:23:13.680
API for managing interfaces between
an application and its plug-ins,

00:23:13.780 --> 00:23:16.010
CFPlugin may be what you want to use.

00:23:16.100 --> 00:23:20.660
And there are a number of Apple projects,
which you may have heard about

00:23:20.710 --> 00:23:24.560
and various other things,
that will use CFPlugin for

00:23:24.560 --> 00:23:26.020
their plug-ins.

00:23:26.030 --> 00:23:30.060
I don't really have time to go into
the details of CFPlugin right now.

00:23:30.120 --> 00:23:33.300
I just want to briefly
describe what it does.

00:23:33.300 --> 00:23:38.380
The application will describe the
interfaces that it was looking for,

00:23:38.550 --> 00:23:41.760
and the plug-in itself will advertise

00:23:42.100 --> 00:23:50.200
[Transcript missing]

00:23:51.000 --> 00:23:55.100
And then the application will
then look at the plug-in,

00:23:55.100 --> 00:24:00.840
interrogate it,
see what interfaces it supports.

00:24:01.030 --> 00:24:07.000
The interfaces are looked up by UUID,
which is just a universal identifier.

00:24:07.160 --> 00:24:11.000
And the interfaces are
tables of function pointers.

00:24:11.000 --> 00:24:13.840
They are COM compatible if you use COM.

00:24:13.840 --> 00:24:17.000
In particular,
we specify the IUnknown interface.

00:24:17.000 --> 00:24:21.960
We're not using COM,
but they should be compatible in layout.

00:24:22.090 --> 00:24:27.250
There is an example of this,
a detailed example, in the CFBundle and

00:24:27.430 --> 00:24:29.000
CF plug-in release note.

00:24:29.000 --> 00:24:33.360
And really, this is something that is
best learned by example.

00:24:35.520 --> 00:24:41.290
So now what I want to reiterate is,
what you take home is bundles are a

00:24:41.290 --> 00:24:47.840
way to treat all the files associated
with an executable as a single object.

00:24:47.850 --> 00:24:51.650
And CFBundle is the programmatic
interface that you will

00:24:51.860 --> 00:24:53.380
use to deal with them.

00:24:53.460 --> 00:24:56.070
So I'm going to turn
things back over to Becky.

00:25:04.900 --> 00:25:06.260
Thanks Doug.

00:25:06.260 --> 00:25:09.660
Looks simpler than what
you're doing today?

00:25:09.700 --> 00:25:10.400
Good.

00:25:10.420 --> 00:25:12.250
That's the idea.

00:25:13.510 --> 00:25:18.140
Okay, so I'm going to go on now to talk
about the user preferences services

00:25:18.290 --> 00:25:21.810
that Core Foundation provides.

00:25:22.230 --> 00:25:26.030
and it provides it via CFPreferences.

00:25:26.030 --> 00:25:30.010
The idea was to give you a mechanism
for easily storing and retrieving your

00:25:30.010 --> 00:25:37.200
user preferences without forcing you
to define your own file structure.

00:25:38.090 --> 00:25:44.000
You give every preference a name,
then you assign a value to that name.

00:25:44.000 --> 00:25:47.560
The value can be any of the property
list types we talked about this morning.

00:25:47.660 --> 00:25:51.470
You can even make it an
array or a dictionary with a

00:25:51.470 --> 00:25:54.060
complex structure underneath.

00:25:54.460 --> 00:25:57.300
And then you hand it off to us
and we handle everything else.

00:25:57.330 --> 00:25:59.630
And in particular,
the data format and the

00:25:59.630 --> 00:26:01.940
storage is our problem,
not yours.

00:26:02.160 --> 00:26:05.590
You will always be
dealing with the CF types.

00:26:08.090 --> 00:26:08.970
So the details.

00:26:09.000 --> 00:26:12.870
These are kind of internal
implementation details,

00:26:12.870 --> 00:26:15.420
but I thought I'd share
them with you anyway.

00:26:15.570 --> 00:26:17.600
We use XML for most
of the backing stores.

00:26:17.680 --> 00:26:22.640
There are a couple exceptions to that,
in particular when we have

00:26:22.750 --> 00:26:24.640
to share across the network.

00:26:24.690 --> 00:26:28.590
We cache preference values for
efficiency so that every time you

00:26:28.680 --> 00:26:31.670
ask for a preference and every
time you write a preference,

00:26:31.700 --> 00:26:33.940
we don't actually hit the disk.

00:26:34.010 --> 00:26:37.270
And CFPreferences,
like all of Core Foundation,

00:26:37.270 --> 00:26:39.170
is a thread-safe system.

00:26:41.140 --> 00:26:45.720
The caveats:
CFPreferences is not intended for

00:26:45.720 --> 00:26:49.510
hundreds upon hundreds of Ks of data.

00:26:51.440 --> 00:26:55.670
Doug mentioned that if your
application needs to write data,

00:26:55.690 --> 00:26:57.400
it should not go into the bundle.

00:26:57.400 --> 00:27:02.000
You can put it in preferences if it's
of an appropriate size and nature.

00:27:02.010 --> 00:27:04.400
On the other hand, if you need to write
hundreds of K of data,

00:27:04.440 --> 00:27:06.230
you have two solutions available to you.

00:27:06.380 --> 00:27:09.280
If it's a temporary cache,
write it to the temporary folder.

00:27:09.400 --> 00:27:11.790
If you need a permanent
storage mechanism,

00:27:11.860 --> 00:27:15.230
you can still use find folder to
find the preferences folder and

00:27:15.270 --> 00:27:17.360
write your own data there that way.

00:27:17.480 --> 00:27:19.400
However, we are using property lists.

00:27:19.400 --> 00:27:23.650
Property lists are XML and we have
all the same serialization problems

00:27:23.650 --> 00:27:24.690
I talked about this morning.

00:27:25.190 --> 00:27:29.860
And it's best used for
under 100 K of data.

00:27:30.800 --> 00:27:34.410
Also, CFPreferences is not intended
for app critical data.

00:27:34.410 --> 00:27:35.440
Well, what do I mean by that?

00:27:35.540 --> 00:27:38.250
Most people consider their
preferences critical.

00:27:38.390 --> 00:27:42.900
Well, I simply mean that if it turns
out that a preference value is

00:27:43.000 --> 00:27:47.300
not in the preferences file,
your app should not crash.

00:27:47.390 --> 00:27:51.460
Likewise, if someone has gone in there
and written a bad value,

00:27:51.690 --> 00:27:53.360
your app should not crash.

00:27:53.460 --> 00:27:57.470
We guarantee when we read the file
that if the file itself is corrupted,

00:27:57.470 --> 00:28:00.460
we will fail gracefully and return null.

00:28:00.590 --> 00:28:03.230
Your job is just to catch
that and make sure that you're

00:28:03.230 --> 00:28:07.940
not going to crash because we
couldn't load your preferences.

00:28:10.480 --> 00:28:12.850
So the API is very simple.

00:28:12.850 --> 00:28:16.470
Most clients are only ever going
to need these three functions.

00:28:16.630 --> 00:28:20.890
CFPreferences copy app value
will read a preference.

00:28:21.070 --> 00:28:30.020
CFPreferences write app value
will take a preference value

00:28:30.020 --> 00:28:32.770
from you and write it out.

00:28:32.770 --> 00:28:32.770
And then CFPreferences app synchronizes
what you use to synchronize the

00:28:32.770 --> 00:28:32.770
cache with the permanent storage.

00:28:33.110 --> 00:28:36.770
If you call CFPreferences app
synchronize every time you

00:28:36.860 --> 00:28:40.610
read or write a preference,
then you've defeated the cache.

00:28:40.710 --> 00:28:43.770
The idea here is that you would
write several preferences at once

00:28:43.910 --> 00:28:47.420
and then synchronize the cache,
or perhaps even leave it to

00:28:47.450 --> 00:28:50.790
a lower library to do the
synchronization for you.

00:28:52.510 --> 00:28:55.840
So let's take a look at the
three functions in detail.

00:28:55.970 --> 00:28:58.830
CFPreferences copy app
value takes two arguments.

00:28:58.830 --> 00:29:02.340
The first one is the key or the name
of the preference you wish to retrieve.

00:29:02.470 --> 00:29:07.680
And the second argument is a string
which identifies your application.

00:29:07.800 --> 00:29:11.370
This is going to cause CFPreferences to
go out and look at all the various

00:29:11.370 --> 00:29:14.960
places that preferences are stored,
find a match for the key,

00:29:14.960 --> 00:29:19.210
and assuming it finds such a match,
it will return the value.

00:29:20.230 --> 00:29:23.940
The other half is writing,
CFPreferences set app value.

00:29:24.040 --> 00:29:29.100
You supply the key, the new value,
and again your application ID.

00:29:29.270 --> 00:29:31.520
Once you've written,
make sure that at some point in the

00:29:31.520 --> 00:29:34.810
future you call CFPreferences app
synchronize or you know that a

00:29:34.810 --> 00:29:37.100
library is going to do it for you.

00:29:37.260 --> 00:29:40.880
This is mostly of interest
for Cocoa applications.

00:29:40.940 --> 00:29:43.940
The Cocoa frameworks
will synchronize for you.

00:29:47.450 --> 00:29:51.300
So what was that
application ID in the API?

00:29:51.340 --> 00:29:55.400
Most of the time you're simply going
to pass KCF preferences current

00:29:55.400 --> 00:30:03.550
application and that says this is a
preference for the current application

00:30:03.550 --> 00:30:05.380
use CFBundles abilities to locate the
correct place to store this information.

00:30:06.000 --> 00:30:08.510
In those cases where you are
writing code that needs to write

00:30:08.510 --> 00:30:12.620
preferences to other locations,
the apps are going to be identified

00:30:12.720 --> 00:30:14.610
by their bundle identifier.

00:30:14.650 --> 00:30:18.130
We chose the bundle identifier
because the bundle ID,

00:30:18.130 --> 00:30:20.100
as Doug mentioned, is unique.

00:30:20.370 --> 00:30:24.100
As he showed you,
the bundle ID should be set somewhere

00:30:24.100 --> 00:30:29.180
in the info.p list under the
CFBundleIdentifier key and should be

00:30:29.250 --> 00:30:33.290
of the form com.companyname.appname.

00:30:33.820 --> 00:30:37.700
Now, if CFPreferences is asked to write
a preference for an application

00:30:37.710 --> 00:30:40.800
that has not set this key,
CFPreferences is going to default back

00:30:40.800 --> 00:30:43.140
to using the application's name itself.

00:30:43.330 --> 00:30:47.260
But, you know, as soon as you do that,
we run the risk of conflicts,

00:30:47.260 --> 00:30:51.170
and that's why we're encouraging
everyone to set the bundle identifier.

00:30:53.270 --> 00:30:57.820
Okay, so there are a handful
of convenience functions.

00:30:57.820 --> 00:31:00.530
A lot of times when you're
reading a preference value,

00:31:00.530 --> 00:31:02.800
you just want a Boolean value,
true/false.

00:31:02.950 --> 00:31:07.030
Other times you just need
to store an integer value.

00:31:07.130 --> 00:31:09.520
So that's what these two
functions are intended for,

00:31:09.520 --> 00:31:13.710
cf_preferences_get_app_Boolean_value and
cf_preferences_get_app_integer_value.

00:31:14.030 --> 00:31:17.240
In both of these cases,
it returns the value that it finds,

00:31:17.240 --> 00:31:20.760
or if it can't find the value or
the value is not of the proper type,

00:31:21.000 --> 00:31:23.120
they default to different values.

00:31:23.120 --> 00:31:26.550
cf_preferences_get_app_Boolean_value
is going to return false,

00:31:26.710 --> 00:31:28.920
get_app_integer_value
is going to return zero.

00:31:29.000 --> 00:31:34.390
If you're interested in the difference
between a genuine zero value and the

00:31:34.480 --> 00:31:40.280
preference not being properly set,
you use the second is valid argument,

00:31:40.280 --> 00:31:43.960
and we will tell you whether we
found a valid preference or not.

00:31:45.550 --> 00:31:48.500
CFPreferences,
these functions will go through and check

00:31:48.500 --> 00:31:50.780
for several different possible formats.

00:31:50.780 --> 00:31:53.240
So by using CFPreferences get
at Boolean value,

00:31:53.240 --> 00:31:57.260
we will not only check
for a true CFBoolean type,

00:31:57.350 --> 00:32:05.210
but also check for a CFString that
matches true or false,

00:32:05.210 --> 00:32:05.210
for instance,
and also check for some number formats.

00:32:07.730 --> 00:32:10.210
So where are these
preferences coming from?

00:32:10.220 --> 00:32:12.760
I've mentioned,
kind of alluded a couple different

00:32:12.760 --> 00:32:15.570
times to the fact that an
application's preferences could come

00:32:15.580 --> 00:32:18.140
from several different locations.

00:32:18.140 --> 00:32:22.320
We call each of these locations a domain,
and then we combine all the

00:32:22.330 --> 00:32:25.840
different domains that are relevant
to a particular application

00:32:25.970 --> 00:32:28.080
into what we call the search list.

00:32:28.080 --> 00:32:30.290
And when we look for a
preference for your application,

00:32:30.330 --> 00:32:34.530
we're going to just walk the search list
in a fixed order until we find what,

00:32:34.530 --> 00:32:39.760
until we find the one we're looking for
or we fall off the bottom of the list.

00:32:41.320 --> 00:32:43.660
So what's a preference domain?

00:32:43.740 --> 00:32:48.330
A preference domain is uniquely
identified by three things:

00:32:48.460 --> 00:32:53.930
the user, the host,
and the applications identifier.

00:32:54.350 --> 00:32:58.470
So I could, for instance,
talk about the mail preferences for

00:32:58.470 --> 00:33:04.100
the user Becky Willrich on the host,
this particular host.

00:33:04.180 --> 00:33:08.300
But you can also simply refer to each
of these as either the current or any.

00:33:08.300 --> 00:33:14.540
So I can look for the mail preferences
for the user Becky on the current host.

00:33:14.630 --> 00:33:21.330
Or search for preferences set by the mail
application for the user Becky on any

00:33:21.700 --> 00:33:24.790
host on a fully networked environment.

00:33:25.440 --> 00:33:30.030
So in all cases, current means the user,
host, or application relevant

00:33:30.130 --> 00:33:32.200
to the current process.

00:33:32.240 --> 00:33:37.350
That's the user who ran the application,
the application being run,

00:33:37.350 --> 00:33:40.500
and the host that the
application is run on.

00:33:40.510 --> 00:33:45.070
Any means that the preference is not
specific to a particular application.

00:33:45.180 --> 00:33:47.500
So for instance,
it's very rare to want to write

00:33:47.500 --> 00:33:51.200
a preference for an application
that's specific to just this host.

00:33:51.220 --> 00:33:57.970
Most of the time those application
preferences go to the any host domains.

00:33:59.540 --> 00:34:02.740
So just some examples.

00:34:02.740 --> 00:34:04.780
Preferences for the current
user on any host for the

00:34:04.780 --> 00:34:08.500
currently running application
is the most common domain used.

00:34:08.500 --> 00:34:12.300
This is where 90% of your
preferences are going to be stored,

00:34:12.300 --> 00:34:16.480
maybe 99%. But you can
have other combinations.

00:34:16.490 --> 00:34:21.500
For instance, the current user on any
host for any application.

00:34:21.500 --> 00:34:25.340
I might want to set a global
font preference in that domain,

00:34:25.340 --> 00:34:26.500
for instance.

00:34:26.940 --> 00:34:32.620
I might also have a preference
that pertains to any user on this

00:34:32.750 --> 00:34:34.960
particular host for any application.

00:34:34.960 --> 00:34:38.350
So printer preferences
might be an example of that.

00:34:41.660 --> 00:34:45.750
Once those domains are set,
here's where CFPreferences looks.

00:34:45.870 --> 00:34:47.900
This is the search list.

00:34:48.010 --> 00:34:53.310
In general, we give preference to current
settings over any settings.

00:34:53.460 --> 00:34:56.750
We consider the current users
preferences the most important

00:34:57.040 --> 00:35:01.400
and we consider application
preferences more important than host.

00:35:01.550 --> 00:35:04.990
So we start by looking at
the most specific domain,

00:35:05.110 --> 00:35:08.960
the current user for the current
application for the current host,

00:35:09.080 --> 00:35:11.400
and move downwards to the most general.

00:35:11.420 --> 00:35:16.520
And you can see we're going to search
all of the current users defaults before

00:35:16.520 --> 00:35:18.990
looking at the global user defaults.

00:35:21.690 --> 00:35:25.380
When we write preferences, by default,
we're going to write it to that most

00:35:25.420 --> 00:35:27.360
common domain I was talking about.

00:35:27.430 --> 00:35:32.730
This user, this application,
but not specific to any particular host.

00:35:36.950 --> 00:35:40.930
So once in a while you find yourself
in a situation where you're writing

00:35:41.060 --> 00:35:44.500
four or five different applications
that need to share preferences.

00:35:44.510 --> 00:35:47.530
Perhaps they're sharing a
library that defines some common

00:35:47.530 --> 00:35:51.740
functionality and there's a
preference unique to that library.

00:35:53.370 --> 00:35:56.380
In these cases,
you're going to want to use the suite

00:35:56.380 --> 00:35:59.660
preferences provided by C of Preferences.

00:35:59.660 --> 00:36:02.290
We consider the applications
that are going to share the

00:36:02.390 --> 00:36:05.260
preferences to form the suite.

00:36:07.570 --> 00:36:11.900
To do this, you'll need to simply choose
an identifier for your suite.

00:36:12.030 --> 00:36:15.260
Usually,
if you're using a shared library,

00:36:15.260 --> 00:36:20.400
we recommend that you use the
bundles identifier for that purpose.

00:36:20.540 --> 00:36:24.350
And then all the applications that
link against that library or that wish

00:36:24.440 --> 00:36:30.000
to partake in the suite simply add the
suite preferences to their search list.

00:36:30.130 --> 00:36:34.950
They do this by calling CFPreferences add
suite preferences to app.

00:36:35.150 --> 00:36:36.760
The first argument is the app ID.

00:36:36.760 --> 00:36:41.240
That's the application to which the
suite preferences will be added.

00:36:41.320 --> 00:36:45.740
The second argument is the suite ID,
which tells us which

00:36:45.740 --> 00:36:47.770
suite should be loaded.

00:36:48.160 --> 00:36:55.990
Once this is done,
all queries to CFPreferences will

00:36:55.990 --> 00:36:55.990
search the suite preferences as well.

00:36:56.260 --> 00:37:00.520
When you need to write suite preferences,
you'd use the same API you would to

00:37:00.620 --> 00:37:02.360
write an application preferences.

00:37:02.420 --> 00:37:07.390
You simply substitute the suite's
ID for the application ID.

00:37:11.140 --> 00:37:14.070
Once in a blue moon,
you may find yourself needing to

00:37:14.070 --> 00:37:18.870
access a specific domain without
going through the search list.

00:37:19.060 --> 00:37:21.110
This should be an
incredibly rare occurrence.

00:37:21.180 --> 00:37:23.760
In fact,
I don't think any application needs

00:37:23.760 --> 00:37:29.410
to do this except for an application
like preferences which itself manages

00:37:29.410 --> 00:37:32.300
the full preferences database.

00:37:33.910 --> 00:37:38.750
In this case we have the same
three kinds of functions.

00:37:38.830 --> 00:37:40.610
We have a read function,
a write function,

00:37:40.610 --> 00:37:42.080
and a synchronize function.

00:37:42.530 --> 00:37:45.610
However,
instead of specifying the preference

00:37:45.700 --> 00:37:51.230
location simply by app ID,
you're going to have to specify

00:37:51.230 --> 00:37:55.810
the full triplet of user name,
host name, application name,

00:37:55.810 --> 00:37:55.810
application ID I should say.

00:37:57.810 --> 00:38:00.500
Now there's some caveats if
you find yourself doing this.

00:38:00.620 --> 00:38:04.500
The first one is that not all
of the domains are implemented.

00:38:04.620 --> 00:38:10.560
In particular, the defaults for any user,
any host are not implemented yet.

00:38:10.690 --> 00:38:13.320
Likewise, on Mac OS 9,
if you have not installed the

00:38:13.420 --> 00:38:17.190
login window or if you're not
configured for multiple users,

00:38:17.230 --> 00:38:20.290
current user doesn't make any sense.

00:38:20.700 --> 00:38:29.300
The intention behind the low-level
APIs is to fail gracefully under these

00:38:29.300 --> 00:38:29.300
conditions and simply return null to you.

00:38:29.670 --> 00:38:32.910
However,
you have to be prepared for that.

00:38:32.910 --> 00:38:36.820
The other promise we make is that
the app functions always work and

00:38:36.940 --> 00:38:42.590
properly take care of using only
those domains that are relevant.

00:38:45.160 --> 00:38:46.800
Debugging Preferences.

00:38:46.820 --> 00:38:50.870
So you're an app developer
and something's gone wrong.

00:38:50.870 --> 00:38:55.570
There is a command line tool on DP4,
it's the defaults command,

00:38:55.680 --> 00:38:59.950
that allows power users to view and
modify the preferences database directly.

00:38:59.950 --> 00:39:02.860
As I said,
you run it from the command line.

00:39:02.860 --> 00:39:04.250
There are a number of different options.

00:39:04.270 --> 00:39:06.100
I'm not going to go through them now.

00:39:06.100 --> 00:39:10.180
But if you just go to the command
line and execute defaults help,

00:39:10.180 --> 00:39:12.160
you'll get the full details.

00:39:12.160 --> 00:39:13.890
It's got a lengthy usage statement there.

00:39:15.900 --> 00:39:18.750
and that's all I want to
say about preferences.

00:39:18.750 --> 00:39:21.980
So I'm going to go on now to spend a
moment to talk about the XML services

00:39:21.980 --> 00:39:25.200
provided inside of Core Foundation.

00:39:25.460 --> 00:39:27.820
There are basically three
levels of XML support.

00:39:27.920 --> 00:39:30.470
The first one we've spent a fair
bit of time talking about already.

00:39:30.770 --> 00:39:33.010
That's property lists.

00:39:33.900 --> 00:39:37.800
The second one is a handful of simple,
quick parsing functions that

00:39:37.960 --> 00:39:42.120
parse XML to and from XML trees.

00:39:42.120 --> 00:39:47.490
And finally, there's a fine-tuned parsing
API available through CFXML Parser.

00:39:49.370 --> 00:39:51.850
So just a reminder,
a property list is any tree

00:39:51.850 --> 00:39:53.600
built from the basic CF types.

00:39:53.750 --> 00:39:55.740
I've listed them again here.

00:39:55.740 --> 00:39:58.360
Array, dictionary, data,
and string should

00:39:58.360 --> 00:40:00.140
handle 90% of your data.

00:40:00.290 --> 00:40:03.640
Date, number,
and boolean make up the rest.

00:40:03.720 --> 00:40:06.910
Property lists have a
flattened XML representation,

00:40:06.910 --> 00:40:10.910
and there's a very easy API to convert
back and forth between the rich

00:40:11.040 --> 00:40:14.250
CF type tree and the flat XML data.

00:40:14.360 --> 00:40:19.820
If you're interested,
CFPropertyList.h for details.

00:40:19.820 --> 00:40:19.820
There's also documentation on the web.

00:40:21.620 --> 00:40:26.000
CFXML tree provides the
next level of support.

00:40:26.010 --> 00:40:27.840
Well, what is a CFXML tree?

00:40:27.840 --> 00:40:34.100
A CFXML tree is a specialized
form of a CF tree where each node,

00:40:34.100 --> 00:40:36.600
in addition to just the
basic tree structure,

00:40:37.250 --> 00:40:39.080
stores a CFXML node.

00:40:39.410 --> 00:40:45.130
The CFXML node provides information
to you about the XML structure itself.

00:40:45.230 --> 00:40:46.530
So are you looking at a tag?

00:40:46.690 --> 00:40:47.780
Are you looking at a comment?

00:40:47.850 --> 00:40:51.200
Is this a data string?

00:40:51.240 --> 00:40:56.370
And what you find yourself doing is to
walk the tree structure of the XML file,

00:40:56.370 --> 00:40:59.280
use the CF tree functions
for CF tree get parent,

00:40:59.350 --> 00:41:03.960
CF tree get child count, and so on.

00:41:04.050 --> 00:41:07.670
To examine the XML structure
of a particular node,

00:41:07.760 --> 00:41:08.810
use CFXML node.

00:41:09.120 --> 00:41:12.370
So from the tree,
call CFXML tree get node.

00:41:12.730 --> 00:41:13.960
That'll give you the node.

00:41:14.060 --> 00:41:18.110
Then the node API can be used
to extract the information

00:41:18.150 --> 00:41:20.800
specific to the XML structure.

00:41:23.020 --> 00:41:26.140
The API looks like this,
just a couple functions.

00:41:26.280 --> 00:41:29.260
CFXMLTreeCreateFromData.

00:41:29.390 --> 00:41:32.860
You pass it the allocator
as with any create function.

00:41:32.970 --> 00:41:38.330
XMLData is the flattened XML file
just read from disk or retrieved

00:41:38.400 --> 00:41:40.700
over the internet or whatever.

00:41:40.860 --> 00:41:47.800
SourceURL is the URL to use for any
relative references inside the XML data.

00:41:47.930 --> 00:41:52.700
ParseOptions has to do with the different
options available on the parser.

00:41:52.840 --> 00:41:56.210
And then the version,
this last field is very important.

00:41:56.530 --> 00:42:00.400
The version number tells us which
version of the APIs you're working

00:42:00.400 --> 00:42:04.260
with as well as what version
of XML you're working with.

00:42:04.360 --> 00:42:08.800
We can guarantee binary compatibility
for a fixed version number.

00:42:08.900 --> 00:42:14.450
However, as XML is revved by the W3C and
as the standards change,

00:42:14.450 --> 00:42:17.750
we expect to bump the version
numbers and extend the API.

00:42:17.760 --> 00:42:17.970
live.

00:42:19.830 --> 00:42:24.640
The other direction is to go
from an XML tree to an XML data.

00:42:24.810 --> 00:42:26.190
Here the function is a little simpler.

00:42:26.220 --> 00:42:28.680
You just pass an allocator
for where to create the data

00:42:28.830 --> 00:42:30.260
from and the tree in question.

00:42:30.260 --> 00:42:34.410
We walk the tree, generate the XML,
and hand it back to you.

00:42:37.230 --> 00:42:39.930
Alright,
so that's all very well and good if

00:42:39.930 --> 00:42:44.560
you are happy with using the CFXML tree
structure to represent the XML.

00:42:44.620 --> 00:42:46.960
However,
since that can represent any XML file,

00:42:46.960 --> 00:42:48.660
it's fairly generic.

00:42:48.780 --> 00:42:51.620
Also,
since we're parsing the entire file and

00:42:51.620 --> 00:42:55.950
generating the entire tree in one pass,
it can be very memory expensive.

00:42:56.050 --> 00:42:58.960
You've loaded the entire file into
data and then we've duplicated

00:42:58.960 --> 00:43:01.570
that in constructing the tree.

00:43:01.940 --> 00:43:06.140
For higher performing and
more customized behavior,

00:43:06.390 --> 00:43:07.930
use CFXML parser.

00:43:09.730 --> 00:43:12.340
CFSML parser is callback based.

00:43:12.340 --> 00:43:20.250
It's much the same as the SACS parsers.

00:43:20.840 --> 00:43:24.200
There are a number of options
available for configuring the parser.

00:43:24.200 --> 00:43:29.540
That was that parser option field
that we looked at in the earlier API.

00:43:29.640 --> 00:43:33.630
Just a word of warning: in DP4,
not all of the options are implemented.

00:43:33.910 --> 00:43:37.030
The documentation has the full
details and is up to date as to what's

00:43:37.030 --> 00:43:42.600
implemented in DP4 and what is not.

00:43:42.720 --> 00:43:45.720
And that's as much as
I want to say on XML.

00:43:52.350 --> 00:43:55.340
I'm going to move on now to talk a
little bit about some of the advanced

00:43:55.430 --> 00:43:57.600
memory tricks you can play with CF.

00:43:57.730 --> 00:44:02.600
And I'm going to focus on
CFString for those purposes.

00:44:04.050 --> 00:44:09.700
The reason why I chose CFString to
focus on in this conversation is,

00:44:09.700 --> 00:44:11.140
well, for several reasons.

00:44:11.140 --> 00:44:14.940
First of all,
it's the most common CF type.

00:44:15.080 --> 00:44:19.200
If people are going to only use
one thing from Core Foundation,

00:44:19.200 --> 00:44:21.240
it's probably the String.

00:44:21.730 --> 00:44:24.680
Also, it demonstrates many of the
different memory strategies that

00:44:24.680 --> 00:44:26.260
are used throughout the system.

00:44:26.330 --> 00:44:29.800
So once you know how to use
CFString's optimizations,

00:44:29.800 --> 00:44:33.500
the other APIs should look
very straightforward to you.

00:44:33.610 --> 00:44:37.020
And finally, probably because it is
the most common type,

00:44:37.070 --> 00:44:41.340
CFString supports the most different
kinds of memory optimizations.

00:44:43.180 --> 00:44:47.670
So, let's start with the
simplest things you can do.

00:44:47.670 --> 00:44:50.320
Move towards immutable whenever possible.

00:44:50.590 --> 00:44:53.920
Immutable strings use the least
amount of memory of any string,

00:44:53.930 --> 00:44:56.720
because we don't have to
worry about the extra overhead

00:44:56.770 --> 00:44:58.900
necessary to grow the string,
right?

00:44:59.040 --> 00:45:02.900
Likewise, fixed mutable uses less
than fully mutable.

00:45:03.580 --> 00:45:07.090
Secondly, if you're going to have
to walk the entire string,

00:45:07.090 --> 00:45:08.740
fetch multiple characters at once.

00:45:08.740 --> 00:45:12.490
And you can do that using the
Get Characters API and simply

00:45:12.770 --> 00:45:16.290
pass a buffer of characters.

00:45:20.070 --> 00:45:26.540
Similarly, there's a handful of functions
that include the word PTR,

00:45:26.680 --> 00:45:27.660
pointer.

00:45:27.660 --> 00:45:31.930
The pointer functions ask that you
check to see if the CFString has

00:45:31.930 --> 00:45:33.820
the desired type on hand.

00:45:34.040 --> 00:45:36.520
In other words,
can you return this type to me in

00:45:36.520 --> 00:45:40.000
O without any memory allocations,
without any work done?

00:45:40.000 --> 00:45:43.710
Now, of course, if the answer is no,
we're going to return null,

00:45:43.710 --> 00:45:45.850
and you should be prepared for that.

00:45:46.010 --> 00:45:49.000
So you might well see
snippets of code like this:

00:45:49.000 --> 00:45:52.420
CFString get Pascal string pointer.

00:45:52.630 --> 00:45:53.970
If we have it, we'll return it.

00:45:54.000 --> 00:46:00.530
If not, you need to check for null,
and if so, you need to allocate a

00:46:00.530 --> 00:46:04.920
buffer for the Pascal string,
and then call the other

00:46:05.310 --> 00:46:09.330
The other API,
CFString get pascal string,

00:46:09.330 --> 00:46:13.450
passing in your buffer
and then we fill it.

00:46:16.700 --> 00:46:20.940
A little more complex is
to use an inline buffer.

00:46:20.950 --> 00:46:26.110
This case is useful when you're going
to walk the entire length of a string

00:46:26.610 --> 00:46:29.370
or when you're going to be moving around
a lot in a small area and then move

00:46:29.490 --> 00:46:31.620
forward and look at another small area.

00:46:31.750 --> 00:46:34.380
In other words,
when your access is either

00:46:34.400 --> 00:46:36.690
sequential or highly localized.

00:46:36.740 --> 00:46:40.950
It keeps the memory overhead
down considerably from either

00:46:40.950 --> 00:46:44.340
walking character by character.

00:46:44.900 --> 00:47:02.300
[Transcript missing]

00:47:03.050 --> 00:47:04.000
And it looks like this.

00:47:04.320 --> 00:47:06.400
Create a CFString inline buffer.

00:47:06.420 --> 00:47:10.100
That's a structure,
a straight up C structure.

00:47:10.240 --> 00:47:13.130
And you can create it on the stack as
long as you know that you don't need

00:47:13.130 --> 00:47:17.060
to pass the buffer out from its scope.

00:47:17.170 --> 00:47:18.900
Initialize it with your CFString.

00:47:18.900 --> 00:47:22.200
So you give it the
CFString init inline buffer.

00:47:22.330 --> 00:47:24.390
Give it the CFString in question.

00:47:24.500 --> 00:47:27.240
Give it a pointer to the
buffer you allocated.

00:47:27.350 --> 00:47:30.070
And then pass the range of
characters you're going to

00:47:30.070 --> 00:47:31.820
be interested in looking at.

00:47:32.390 --> 00:47:35.670
Now when you need to fetch a character,
instead of going to the CFString,

00:47:35.670 --> 00:47:37.200
go to the inline buffer.

00:47:37.250 --> 00:47:40.460
CFString get character
from inline buffer,

00:47:40.550 --> 00:47:44.900
pass a pointer to the buffer,
and the index of the

00:47:44.900 --> 00:47:44.900
character in question.

00:47:47.500 --> 00:47:50.530
Beyond that,
the most complex level of memory

00:47:50.530 --> 00:47:54.060
management is the no copy functions.

00:47:54.230 --> 00:47:58.860
The no copy functions create
CFStrings around your own storage so

00:47:58.870 --> 00:48:04.520
you are not running into any memory
copy overhead or double data overhead.

00:48:04.770 --> 00:48:07.710
When you do this though,
you are transferring ownership of

00:48:07.710 --> 00:48:11.480
the backing storage to CFString.

00:48:12.340 --> 00:48:16.150
That means you're going to
tell CFString how to free

00:48:16.160 --> 00:48:18.400
the buffer when you're done.

00:48:18.670 --> 00:48:20.340
And if you're working
with mutable strings,

00:48:20.340 --> 00:48:24.230
you'll also have to tell
CFString how to grow that buffer.

00:48:26.000 --> 00:48:31.430
Now, using this trick you can even use
character buffers directly on the stack.

00:48:31.470 --> 00:48:33.220
But if you do that,
there are a couple things you

00:48:33.280 --> 00:48:34.440
need to be very careful of.

00:48:34.590 --> 00:48:37.770
First of all,
obviously if you pass the string outside

00:48:37.770 --> 00:48:41.300
of the scope of your stack buffer,
you're going to have a memory exception,

00:48:41.300 --> 00:48:41.660
right?

00:48:41.660 --> 00:48:43.900
Because the buffer's been blown away.

00:48:44.050 --> 00:48:48.030
Likewise,
if even within the buffer's scope you

00:48:48.030 --> 00:48:54.690
pass the string down to a function that
then retains the string for later use,

00:48:54.770 --> 00:48:56.540
you're going to have the same problem.

00:48:56.680 --> 00:48:59.340
You're going to exit the
scope of your buffer.

00:48:59.420 --> 00:49:03.360
Whoever it was who retained the string
thinks the string is still good,

00:49:03.360 --> 00:49:04.420
but it's not.

00:49:05.530 --> 00:49:06.690
So it looks like this.

00:49:06.700 --> 00:49:09.500
CFString create with characters no copy.

00:49:09.500 --> 00:49:13.230
The first allocator there,
KCF allocator default,

00:49:13.730 --> 00:49:16.060
explains how the string
itself should be allocated.

00:49:16.060 --> 00:49:19.680
Then you pass it a pointer to
the characters that you have,

00:49:19.790 --> 00:49:20.220
my buffer.

00:49:20.220 --> 00:49:24.190
You pass it the length of the buffer,
and then finally you pass

00:49:24.200 --> 00:49:25.560
the buffer allocator.

00:49:25.560 --> 00:49:29.320
This allocator is what the
string is going to use to

00:49:29.580 --> 00:49:31.320
manage the memory of my buffer.

00:49:31.950 --> 00:49:36.220
When the string is freed,
buffer allocator is going to be

00:49:36.310 --> 00:49:38.360
consulted on how to free the characters.

00:49:38.360 --> 00:49:41.940
If the buffer needs to grow,
buffer allocator is going

00:49:41.940 --> 00:49:43.150
to be used to do that.

00:49:46.360 --> 00:49:51.260
So normally you're going to simply
pass whatever allocator you use to

00:49:51.260 --> 00:49:53.900
allocate myBuffer in the first place.

00:49:54.020 --> 00:49:57.250
On the other hand,
if you don't want CF to do any

00:49:57.250 --> 00:50:04.150
management over the myBuffer memory,
pass kcfallocator null.

00:50:06.790 --> 00:50:12.600
Okay, so these final slides are mostly
a repeat from this morning,

00:50:12.610 --> 00:50:13.890
where you can go to get help.

00:50:13.900 --> 00:50:16.290
There's a lot of documentation online.

00:50:16.290 --> 00:50:20.380
It's available on the DP4 CD at
System Developer Documentation

00:50:20.380 --> 00:50:21.440
Core Foundation.

00:50:21.530 --> 00:50:26.750
It's available on the web at
developer.apple.com/techpubs/corefound

00:50:26.800 --> 00:50:27.530
ation.

00:50:27.660 --> 00:50:30.680
Example code in
System Developer Examples Core Foundation

00:50:31.040 --> 00:50:31.040
.

00:50:31.130 --> 00:50:33.700
Release notes:
System Developer Documentation.

00:50:33.700 --> 00:50:37.090
Core Foundation.html

00:50:39.060 --> 00:50:42.110
There's a little additional
information for bundle services,

00:50:42.110 --> 00:50:42.760
however.

00:50:42.830 --> 00:50:46.750
Inside the release notes directory,
you will find several different

00:50:46.760 --> 00:50:48.240
documents of interest.

00:50:48.280 --> 00:50:53.250
CFBundle and CFPlugin provide sample
code on how you would use CFBundle and

00:50:53.320 --> 00:50:56.000
CFPlugin to create a plugin model.

00:50:56.070 --> 00:50:59.650
Info.plist describes the keys
that we define inside the

00:50:59.880 --> 00:51:01.950
bundle's information plist.

00:51:01.950 --> 00:51:06.500
That's where we configured all the
finder information for the app package.

00:51:06.560 --> 00:51:10.680
And localization.html provides
information on how to use the app

00:51:10.680 --> 00:51:15.860
packaging model to localize your app
as simply and effectively as possible.

00:51:18.150 --> 00:51:20.900
Here are some of the other talks
that you might be interested in.

00:51:21.000 --> 00:51:22.790
Core Foundation Basics already happened.

00:51:22.790 --> 00:51:25.700
Hopefully you all had
a chance to see that.

00:51:25.850 --> 00:51:31.570
Carbon Low Level is Friday and you
can see some of the other pieces that

00:51:31.640 --> 00:51:34.190
comprise that core services level.

00:51:34.530 --> 00:51:38.020
The App Packaging and Document Typing
talk is going to go into the

00:51:38.030 --> 00:51:43.000
details of just exactly what the
structure inside the app package is.

00:51:43.140 --> 00:51:46.410
The Localization talk will
give you the details on how to

00:51:46.500 --> 00:51:48.340
go about localizing your app.

00:51:48.480 --> 00:51:52.190
And then the Localization Tools talk
will tell you about the tools

00:51:52.190 --> 00:51:54.550
available on the system to help you.

00:51:55.080 --> 00:51:57.640
With that, oh yes, one more thing.

00:51:57.720 --> 00:51:59.600
Who to contact?

00:51:59.790 --> 00:52:01.760
David Wright is our technology manager.

00:52:01.760 --> 00:52:05.400
He's the gentleman who introduced me
and he'll be coming back up for the Q&A.

00:52:05.520 --> 00:52:08.370
And we also have an
external feedback list,

00:52:08.370 --> 00:52:10.600
cf-feedback@apple.com.

00:52:10.600 --> 00:52:17.200
We'll reach all of the developers
involved in Core Foundation.
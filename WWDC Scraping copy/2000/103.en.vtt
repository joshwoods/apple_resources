WEBVTT

00:00:08.130 --> 00:00:09.810
My name is John Signa.

00:00:09.950 --> 00:00:16.070
I am the technology manager for Mac OS X,
and I focus on the Core OS,

00:00:16.070 --> 00:00:19.090
covering drivers, file systems,
and networking.

00:00:19.100 --> 00:00:22.090
And I'd like to welcome
you to the I/O Kit session.

00:00:22.130 --> 00:00:24.100
It's really good to see we
have a full house today.

00:00:24.100 --> 00:00:28.100
How many of you like the I/O Kit demos
that have happened so far?

00:00:28.100 --> 00:00:29.010
We've been doing a ton of them.

00:00:29.100 --> 00:00:32.820
In case you haven't noticed,
they've done some in the Carbon session,

00:00:32.820 --> 00:00:34.050
some in the Keynote.

00:00:34.110 --> 00:00:37.230
Let's see them do those fancy
graphics demos without the

00:00:37.230 --> 00:00:39.070
display drivers and so forth.

00:00:39.100 --> 00:00:41.100
Those are the cool demos.

00:00:41.100 --> 00:00:43.100
The drivers are working.

00:00:43.850 --> 00:00:45.780
So to tell you actually how
you can actually get your

00:00:45.780 --> 00:00:52.370
devices working with Mac OS X,
I would now like to introduce Dean Reece,

00:00:52.380 --> 00:00:54.730
who is the manager of the
I/O Kit engineering team.

00:00:55.260 --> 00:00:56.910
Dean Reece.

00:01:01.090 --> 00:01:01.670
Good afternoon.

00:01:01.830 --> 00:01:03.060
Thanks for coming out.

00:01:03.060 --> 00:01:04.840
It's good to see you all here.

00:01:04.940 --> 00:01:08.280
So if you've come to previous WWDCs,
you've probably seen me up

00:01:08.310 --> 00:01:11.160
here before talking about
what I/O Kit is going to be.

00:01:11.160 --> 00:01:13.370
And this year,
I'm going to talk to you a lot

00:01:13.540 --> 00:01:17.610
about what it is and has been
and is going to evolve into.

00:01:17.620 --> 00:01:20.420
So we've got a little bit of history,
and we've also got some

00:01:20.420 --> 00:01:21.850
future direction for you.

00:01:21.990 --> 00:01:23.780
So let's get started.

00:01:25.090 --> 00:01:27.720
So I'm sure you've seen
plenty of these by now.

00:01:27.850 --> 00:01:32.810
This is sort of the view from orbit,
and we'll be getting closer and closer.

00:01:32.900 --> 00:01:35.680
So we're going to be focusing
in on the very bottom box here,

00:01:35.730 --> 00:01:37.860
the Darwin section.

00:01:38.820 --> 00:01:40.910
And of course, within that,
we'll be focusing in a little

00:01:40.910 --> 00:01:44.450
bit finer on I/O Kit and drivers.

00:01:47.130 --> 00:01:51.020
So today we'll talk a little bit
about the current state of I/O Kit,

00:01:51.020 --> 00:01:55.050
and then we'll spend a little time
talking about developing code to

00:01:55.060 --> 00:01:58.420
run inside the Mac OS X kernel,
because there are some very special

00:01:58.420 --> 00:02:02.080
conditions that you have to follow
to be successful at doing that,

00:02:02.320 --> 00:02:04.450
that are definitely different
than what you would encounter

00:02:04.450 --> 00:02:05.630
doing application development.

00:02:05.640 --> 00:02:08.780
We're also going to spend some time
talking about the I/O registry,

00:02:08.780 --> 00:02:13.040
because this is probably the
single most important element that

00:02:13.040 --> 00:02:15.940
is in the core part of I/O Kit.

00:02:15.940 --> 00:02:19.410
This is used by all families,
and all drivers will be involved in it,

00:02:19.420 --> 00:02:20.940
whether they know it or not.

00:02:20.940 --> 00:02:24.660
We're also going to talk a little
bit about our user-client model.

00:02:25.170 --> 00:02:28.800
Basically,
drivers live inside the kernel,

00:02:28.800 --> 00:02:30.190
users don't.

00:02:31.350 --> 00:02:35.380
So you have to get-- wow, they like that.

00:02:35.470 --> 00:02:37.900
So we're going to have to figure
out a way to move the data

00:02:37.900 --> 00:02:39.240
across the user kernel boundary.

00:02:39.240 --> 00:02:41.980
And there are a number of ways
of doing that inside Mac OS X.

00:02:42.370 --> 00:02:45.460
I/O Kit has a small bag
of tricks for doing this.

00:02:45.460 --> 00:02:48.600
And there are other mechanisms available,
but we'll talk about those.

00:02:48.620 --> 00:02:51.830
And then I'm going to spend, actually,
some good amount of time this year

00:02:52.180 --> 00:02:55.320
going down each individual family
and explaining where we stand,

00:02:55.430 --> 00:02:57.540
where we're going,
and directing you to what other

00:02:57.540 --> 00:03:00.820
sessions are coming up that will
actually give you some details

00:03:00.900 --> 00:03:02.680
about how to use those families.

00:03:02.730 --> 00:03:05.090
So let's get started.

00:03:05.580 --> 00:03:07.100
What is I/O Kit?

00:03:07.190 --> 00:03:11.300
So there's really two main
definitions that I use.

00:03:11.340 --> 00:03:14.030
And the first one is it makes it
as easy as possible to develop

00:03:14.030 --> 00:03:15.970
correct Mac OS X drivers.

00:03:16.070 --> 00:03:19.830
Now, kind of a vague blanket statement.

00:03:19.840 --> 00:03:21.880
We'll get back to the word
correct a little bit later.

00:03:21.880 --> 00:03:24.690
But that is basically our goal.

00:03:24.700 --> 00:03:28.220
We're a framework that's
intended to enable all of you

00:03:28.220 --> 00:03:30.250
to write drivers for Mac OS X.

00:03:30.250 --> 00:03:32.410
That's its primary purpose.

00:03:32.490 --> 00:03:33.890
Would you like fries with that driver?

00:03:33.910 --> 00:03:35.170
We're a service organization.

00:03:37.100 --> 00:03:39.690
So the next one,
the other definition is not from

00:03:39.830 --> 00:03:41.980
the driver-writer perspective,
but what does I/O Kit do

00:03:41.980 --> 00:03:43.480
from the system perspective?

00:03:43.530 --> 00:03:46.000
And that is,
it provides software abstractions

00:03:46.110 --> 00:03:47.740
for all the hardware on your system.

00:03:47.800 --> 00:03:51.140
Because if there's not a way
to find a device from software,

00:03:51.180 --> 00:03:53.320
apps aren't going to talk to it.

00:03:53.430 --> 00:03:56.950
And more from a tactical perspective,
I/O Kit is delivered as

00:03:56.950 --> 00:04:00.400
part of the Mac OS X KDK,
the Kernel Developer Kit.

00:04:00.530 --> 00:04:04.770
And we've kind of broken from
the traditional DDK terminology,

00:04:04.770 --> 00:04:06.360
because it's not just
for writing drivers.

00:04:06.360 --> 00:04:09.000
It's writing all kernel
extensions for Mac OS X.

00:04:09.050 --> 00:04:12.000
So I/O Kit is in there.

00:04:13.680 --> 00:04:16.040
So who is I/O Kit for?

00:04:16.080 --> 00:04:20.640
Well, if you're writing a device driver,
there's a good chance I/O Kit is for you.

00:04:20.680 --> 00:04:23.770
There's a little bit of special
language here that we add in,

00:04:23.850 --> 00:04:27.220
is if your driver must run
inside the Mac OS X kernel,

00:04:27.220 --> 00:04:28.780
then you use I/O Kit.

00:04:28.790 --> 00:04:32.830
Now, we'll be talking a little bit more
later about why you would or would

00:04:32.830 --> 00:04:35.420
not be running inside the kernel.

00:04:35.430 --> 00:04:39.060
Ideally, we put as much code as
possible outside of the kernel,

00:04:39.060 --> 00:04:40.850
for reasons I'll get into later.

00:04:40.970 --> 00:04:43.660
But keep this in mind throughout
the whole presentation.

00:04:43.770 --> 00:04:45.340
When you're thinking about
your software product,

00:04:45.490 --> 00:04:49.280
you need to be thinking about where
does it need to fit into Mac OS X.

00:04:49.280 --> 00:04:53.420
And I'll be giving you clues all
along as the subjects come up.

00:04:53.460 --> 00:04:58.340
But as an example, printer drivers do not
live inside the kernel.

00:04:58.570 --> 00:05:00.100
They live actually inside
the printer framework,

00:05:00.190 --> 00:05:03.980
and there's a session to
talk about how to do those.

00:05:04.010 --> 00:05:08.000
Also, developers of applications that
need to talk to devices directly.

00:05:08.000 --> 00:05:12.000
By directly,
I mean there's a-- a USB security dongle,

00:05:12.000 --> 00:05:16.290
and you've got an application that
wants to directly talk to that dongle.

00:05:16.490 --> 00:05:20.170
Indirectly would be your
application wants to talk to files.

00:05:20.280 --> 00:05:23.700
Well, obviously,
the file systems live on devices.

00:05:23.730 --> 00:05:27.080
In that case, by going through the file
system to access files,

00:05:27.080 --> 00:05:28.460
you are, of course, getting to a device.

00:05:28.560 --> 00:05:30.320
But I don't consider that direct access.

00:05:30.320 --> 00:05:32.570
That's not really an I/O Kit thing.

00:05:32.590 --> 00:05:38.340
But also-- OK, I've already talked
about the third point,

00:05:38.390 --> 00:05:40.120
so I got out of order for myself.

00:05:41.730 --> 00:05:43.600
So the state of I/O Kit.

00:05:43.730 --> 00:05:47.920
Last year, we first shipped
I/O Kit code in binary form.

00:05:48.020 --> 00:05:51.630
The developer preview that we gave
out was actually running on I/O Kit.

00:05:51.840 --> 00:05:53.460
All I/Os were going through it.

00:05:53.510 --> 00:05:56.470
But it was not quite mature enough or
stable enough to give to developers

00:05:56.510 --> 00:05:58.440
because we didn't want to misdirect them.

00:05:58.440 --> 00:06:01.850
We knew there were areas that
were changing and improving.

00:06:01.950 --> 00:06:06.270
So that was the first time it
ever really saw the light of day.

00:06:06.790 --> 00:06:10.380
Then last February,
we shipped the first KDK,

00:06:10.380 --> 00:06:14.770
and inside of that was a lot of I/O Kit,
but not all of it.

00:06:14.770 --> 00:06:18.340
We had the KDK elements
for a number of families,

00:06:18.340 --> 00:06:23.270
like USB and SCSI and so on,
but it wasn't complete.

00:06:23.280 --> 00:06:29.360
Now, with this year, with DP4,
we've given you an updated KDK,

00:06:29.360 --> 00:06:33.300
it's actually part of the CD,
and you might look on there trying

00:06:33.410 --> 00:06:34.880
to find a package that says KDK.

00:06:34.880 --> 00:06:36.570
We haven't broken it
out as a separate thing.

00:06:36.580 --> 00:06:40.580
When you install the developer package,
you get all of the KDK bits.

00:06:40.580 --> 00:06:43.950
There are still some
things that are missing.

00:06:43.950 --> 00:06:46.120
We'll go over exactly what's
there and what's not there,

00:06:46.120 --> 00:06:47.510
but we're continuing to add more.

00:06:47.540 --> 00:06:50.070
And in June,
we intend to ship an add-on for

00:06:50.070 --> 00:06:53.860
DP4 that you would be able to
install that would add even more,

00:06:53.860 --> 00:06:55.930
and would update a few things.

00:06:55.960 --> 00:07:00.210
So we're making progress here,
and hopefully we've gotten to the point

00:07:00.210 --> 00:07:02.660
now where most of you can get started.

00:07:02.660 --> 00:07:05.470
Many of you, if not most of you,
will actually be able to

00:07:05.470 --> 00:07:06.460
complete your work based on DP4.

00:07:06.460 --> 00:07:10.080
Some of you will have to wait
for additional support from

00:07:10.190 --> 00:07:13.830
Apple before you can get going,
but we'll get into who you

00:07:13.830 --> 00:07:17.800
are and how you would go about
getting that information.

00:07:18.270 --> 00:07:25.430
So Mac OS X uses kernel
extensions to extend the kernel.

00:07:25.740 --> 00:07:29.100
Simply put, a kernel extension is
just a wrapper for code.

00:07:29.100 --> 00:07:32.060
It's a way to get a chunk of
binary code linked into the

00:07:32.180 --> 00:07:33.910
kernel and get it executing.

00:07:34.010 --> 00:07:39.700
And each environment, like I/O Kit is an
environment inside the kernel,

00:07:39.700 --> 00:07:42.440
the network kernel extension support
is an environment inside the kernel,

00:07:42.440 --> 00:07:44.260
and the file system
plug-in is an environment.

00:07:44.260 --> 00:07:47.770
Each of these environments have
their own set of APIs that a

00:07:47.820 --> 00:07:52.170
driver developer would use to,
excuse me, a software developer would use

00:07:52.290 --> 00:07:54.550
to get at the services they need.

00:07:54.560 --> 00:07:57.290
So, at the top level,
a kernel extension is just

00:07:57.310 --> 00:07:58.900
a way to deliver the code.

00:07:58.940 --> 00:08:02.620
It doesn't actually have
any real API in it yet.

00:08:02.660 --> 00:08:06.750
The other thing I want to say about
kernel extensions is they're not

00:08:06.760 --> 00:08:09.400
synonymous with Mac OS 9 extensions.

00:08:09.400 --> 00:08:13.870
Now, there are certainly Mac OS 9
extensions that would map to

00:08:13.990 --> 00:08:16.220
kernel extensions in Mac OS X.

00:08:16.260 --> 00:08:18.210
But this is not an
assumption you want to make.

00:08:18.340 --> 00:08:23.150
You want to consider very carefully
where your software fits into Mac OS X.

00:08:23.220 --> 00:08:28.420
So, an example would be a foreign file
system plug-in extension would be

00:08:28.420 --> 00:08:31.010
a file system plug-in in Mac OS X.

00:08:31.030 --> 00:08:33.020
So, it would be a kernel
extension in that case.

00:08:33.280 --> 00:08:38.490
But a shared library in Mac OS 9 is not
going to be a kernel extension in X.

00:08:38.560 --> 00:08:42.050
We have other ways to
deliver that functionality.

00:08:42.520 --> 00:08:45.420
Now that being said, I will reiterate,
you should only put your code

00:08:45.520 --> 00:08:47.370
inside the kernel if you have to.

00:08:47.550 --> 00:08:49.400
And here's some of the reasons.

00:08:49.400 --> 00:08:52.970
When you develop inside a kernel,
you are, first off,

00:08:52.970 --> 00:08:55.150
you have to use our tools right now.

00:08:55.410 --> 00:08:57.400
I don't believe there's an
alternative tool set available

00:08:57.400 --> 00:08:59.930
to develop kernel extensions.

00:08:59.930 --> 00:09:01.360
If there is,
I certainly am not aware of it.

00:09:01.400 --> 00:09:05.400
Now, it's certainly,
we will work with any developer

00:09:05.400 --> 00:09:09.470
that is building IDEs and wants
to be able to have a tool to

00:09:09.470 --> 00:09:13.400
develop Mac OS X kernel extensions,
but it's going to be their products.

00:09:13.400 --> 00:09:15.400
They have to drive that development.

00:09:15.400 --> 00:09:18.120
So, just to be clear,
Apple will provide you with an

00:09:18.170 --> 00:09:20.400
IDE for developing kernel extensions.

00:09:20.400 --> 00:09:23.410
And we will work with third
parties to get their tools up to

00:09:23.410 --> 00:09:25.390
speed if that's their intention.

00:09:25.400 --> 00:09:29.400
The other thing about developing
in the kernel is debugging.

00:09:29.400 --> 00:09:31.400
Has to be done using a tech tool.

00:09:31.400 --> 00:09:33.400
So, we will be using a two
machine debug environment.

00:09:33.400 --> 00:09:36.400
And this is done not over a serial port,
but over Ethernet.

00:09:36.430 --> 00:09:39.520
So, what happens is you have one
machine that actually has the

00:09:39.520 --> 00:09:41.400
kernel extension you are testing.

00:09:41.400 --> 00:09:46.340
And that's connected on the same Ethernet
segment to a host machine where typically

00:09:46.340 --> 00:09:51.190
you'll also be doing your development,
which will have GDB running over there.

00:09:51.570 --> 00:09:54.400
You'll attach to the kernel
running on your target machine.

00:09:54.400 --> 00:09:57.410
You'll be able to stop it,
single step it, look at the stacks,

00:09:57.410 --> 00:09:59.220
look at memory, things like that.

00:09:59.450 --> 00:10:01.400
It is not as seamless as it looks.

00:10:01.400 --> 00:10:04.400
It is as seamless a debugging experience
as you would get with applications.

00:10:04.400 --> 00:10:08.370
We are going to work on improving it,
but it's not probably ever going

00:10:08.370 --> 00:10:10.670
to be as glitzy as application,
you know,

00:10:10.670 --> 00:10:17.400
GUI application debugging because it's
just a very different development style.

00:10:18.260 --> 00:10:19.920
Also,
there are limited language features.

00:10:19.920 --> 00:10:24.900
And this is-- we talked about
this a little bit last year.

00:10:24.940 --> 00:10:29.400
I/O Kit uses C++ object-oriented
structures for managing a lot

00:10:29.430 --> 00:10:31.840
of the way our framework works.

00:10:31.990 --> 00:10:34.770
But we've restricted what
features of C++ we use.

00:10:34.860 --> 00:10:37.640
And we've done this for a couple reasons.

00:10:37.800 --> 00:10:41.230
Probably the most
important is for stability.

00:10:41.330 --> 00:10:45.460
The entire Mac OS X kernel is not in C++.

00:10:46.100 --> 00:12:23.000
[Transcript missing]

00:12:23.780 --> 00:12:27.470
Okay, so the next issue with developing
inside the kernel is that you can't

00:12:27.480 --> 00:12:29.150
directly interact with the user.

00:12:29.300 --> 00:12:32.150
Now,
we do have some services that will allow

00:12:32.150 --> 00:12:35.490
your code to throw up alert panels,
for example.

00:12:35.720 --> 00:12:38.690
In general, though,
the theory is that drivers

00:12:38.760 --> 00:12:41.270
should drive hardware,
and you should have some

00:12:41.270 --> 00:12:44.520
higher-level policymaker deciding
what the user experience is.

00:12:44.750 --> 00:12:47.390
There are a few cases, however,
a good example would be an

00:12:47.500 --> 00:12:50.420
encrypted disk that needs a
password before it can be mounted,

00:12:50.460 --> 00:12:53.600
where it may be reasonable for the
driver to actually throw up some UI.

00:12:53.670 --> 00:12:59.580
We have some resources for that
coming in to later releases,

00:12:59.680 --> 00:13:02.240
but for now at least,
if you want to have a user

00:13:02.240 --> 00:13:06.030
entity interact with a driver,
you have to write both pieces of code.

00:13:06.130 --> 00:13:10.140
You have to have a user
piece that communicates with

00:13:10.140 --> 00:13:12.460
the driver to throw up UI.

00:13:13.140 --> 00:13:15.910
The other thing about developing inside
the kernel that you have to keep in mind,

00:13:15.910 --> 00:13:19.350
I can't stress this enough,
resources inside the kernel are

00:13:19.350 --> 00:13:21.750
more expensive than user resources.

00:13:21.820 --> 00:13:26.170
And what I mean by that,
kernel memory is by default wired.

00:13:26.200 --> 00:13:30.090
You don't want to take page faults
when running inside the kernel,

00:13:30.100 --> 00:13:35.080
because that can lead to various problems
that will end up with a dead machine.

00:13:35.120 --> 00:13:39.140
So effectively, when you allocate a K of
memory inside the kernel,

00:13:39.170 --> 00:13:42.670
that's a K of memory that isn't
available to any application,

00:13:42.750 --> 00:13:45.880
no matter whether they're
paged out or paged in or what.

00:13:45.910 --> 00:13:48.420
If you allocate a K of
memory in an application,

00:13:48.720 --> 00:13:51.980
and that application is idle,
then it's going to be paged out as

00:13:51.980 --> 00:13:57.300
part of the application's working set,
and other applications will be hot.

00:13:57.300 --> 00:14:01.560
So effectively, memory inside the kernel
is much more expensive.

00:14:03.330 --> 00:14:06.840
There are other resource issues
inside the kernel as well,

00:14:06.850 --> 00:14:09.760
but memory is really the
one you want to look at.

00:14:09.830 --> 00:14:12.220
Also, failures are fatal.

00:14:13.080 --> 00:14:16.420
If you crash inside the kernel,
you've crashed the entire machine.

00:14:16.420 --> 00:14:18.090
You've panicked the kernel.

00:14:18.200 --> 00:14:20.900
An application,
something running outside of the kernel,

00:14:20.900 --> 00:14:23.220
only crashes itself, its own process.

00:14:23.390 --> 00:14:27.080
So these are all good reasons
to stay outside the kernel.

00:14:27.340 --> 00:14:30.000
Now, of course,
a lot of you are going to have to

00:14:30.000 --> 00:14:32.120
develop code that runs inside the kernel,
and that's fine.

00:14:32.120 --> 00:14:36.580
We intend-- I have lots of no
lifeguard on duty warnings and so on.

00:14:36.640 --> 00:14:38.360
But we do it all the time.

00:14:38.360 --> 00:14:40.400
There's quite a lot of code and
quite a lot of drivers that we

00:14:40.410 --> 00:14:41.610
develop and put inside the kernel.

00:14:41.730 --> 00:14:43.590
So it is possible.

00:14:44.030 --> 00:14:47.110
And to get you started with this,
we've put together a few tutorials.

00:14:47.130 --> 00:14:52.110
Now, in DP4,
these tutorials show you how to

00:14:52.110 --> 00:14:56.230
generate first a Hello Kernel extension.

00:14:56.240 --> 00:15:00.730
This is just sort of the minimal
piece of code that will load in,

00:15:00.730 --> 00:15:04.440
it will log a message to the
console when it's loaded,

00:15:04.440 --> 00:15:07.240
then you can manually unload it,
it will log a message saying goodbye,

00:15:07.240 --> 00:15:08.060
and it will unload.

00:15:08.060 --> 00:15:10.360
And you can sit there and load
it and unload it and load it

00:15:10.360 --> 00:15:11.660
and unload it and experiment.

00:15:11.850 --> 00:15:15.970
It's a great way for you to get
started because it shows you how to

00:15:15.980 --> 00:15:17.260
go through your development cycle.

00:15:17.300 --> 00:15:20.010
It gives you the skills you
need to build a project,

00:15:20.010 --> 00:15:23.520
get it loaded, see that it's loaded,
and then you can start adding

00:15:23.520 --> 00:15:25.650
code and experimenting with APIs.

00:15:25.720 --> 00:15:31.750
The second tutorial is I/O Kit focused,
and this is called Hello I/O Kit.

00:15:31.810 --> 00:15:38.690
It layers on top of the first one in the
sense that it adds I/O Kit-specific APIs.

00:15:38.730 --> 00:15:42.380
It shows you some of the basic entry
points like start and stop that most

00:15:42.380 --> 00:15:46.130
driver writers are going to need
to override and do something with.

00:15:46.200 --> 00:15:49.010
It also shows you a little bit
about the way our matching works.

00:15:49.200 --> 00:15:51.950
These tutorials, by the way,
are not intended to educate you as to

00:15:52.050 --> 00:15:53.920
why you are doing all of these things.

00:15:53.980 --> 00:15:56.680
They are intended to walk you
through the steps so that you

00:15:56.680 --> 00:15:58.360
can then begin to experiment.

00:15:58.420 --> 00:16:02.110
We are working on some improved
versions of these tutorials.

00:16:02.180 --> 00:16:07.990
Both of them, by the way,
show you the project builder web objects.

00:16:08.150 --> 00:16:10.620
The I/O Kit is a new interface,
excuse me, IDE.

00:16:10.620 --> 00:16:13.940
So when you follow these instructions,
you'll be using the older

00:16:13.940 --> 00:16:17.310
style project builder,
and then you will build these projects.

00:16:17.310 --> 00:16:19.830
You can import them into
the new project builder,

00:16:19.940 --> 00:16:24.100
the fancier one, and you can, I believe,
continue to make progress there.

00:16:24.100 --> 00:16:28.470
In the June KDK that I mentioned,
we intend to cut over all development

00:16:28.480 --> 00:16:31.090
of drivers to the new project builder.

00:16:31.090 --> 00:16:33.600
And at that point,
we'll give you new tutorials

00:16:33.600 --> 00:16:37.100
that show you how to create those
projects in the new project builder.

00:16:37.260 --> 00:16:42.440
But they do work as expected now
using the old project builder,

00:16:42.610 --> 00:16:45.280
project builder web objects.

00:16:46.030 --> 00:16:49.920
Oh, the second tutorial that talks
about I/O Kit also spends a good bit

00:16:49.920 --> 00:16:52.730
of time showing you how to set up
the two machine debug environment.

00:16:52.740 --> 00:16:57.460
This is going to be a tricky step
for a lot of you if you don't

00:16:57.520 --> 00:17:00.090
have Unix or GDB experience.

00:17:00.140 --> 00:17:05.260
It requires that you spend some time
at the command line and manipulating

00:17:05.260 --> 00:17:09.790
some files in a way that won't be
immediately familiar to a lot of you.

00:17:09.800 --> 00:17:12.080
So just be patient and work through it.

00:17:12.120 --> 00:17:13.390
It's an important skill to have.

00:17:13.400 --> 00:17:16.070
And I assure you it is possible,
it does work.

00:17:16.210 --> 00:17:18.830
It's very,
very powerful once you get it connected.

00:17:18.900 --> 00:17:23.850
So these are exercises you
should all be going through,

00:17:23.950 --> 00:17:24.900
I think.

00:17:24.900 --> 00:17:28.970
So I/O Kit's design goals.

00:17:30.240 --> 00:17:33.170
In the very early slide,
I told you that I/O Kit is to

00:17:33.170 --> 00:17:35.100
help you write correct drivers.

00:17:35.210 --> 00:17:39.180
Well, this is where I talk about
what I mean by correct.

00:17:39.480 --> 00:17:42.740
The Mac OS X kernel environment
has some real complexity to it,

00:17:42.900 --> 00:17:46.700
and I/O Kit is there to help
smooth over a lot of it.

00:17:46.810 --> 00:17:47.700
MP and preemption.

00:17:47.700 --> 00:17:52.180
The Mac OS X kernel is intended to
be able to run on an MP machine,

00:17:52.190 --> 00:17:54.500
and as it works out,
the software constructs are more

00:17:54.500 --> 00:17:57.260
or less identical to what you
need to support kernel preemption,

00:17:57.380 --> 00:18:03.590
which we will be turning on at some point
to get better real-time performance.

00:18:04.490 --> 00:18:08.770
For those of you that have not developed
software that either runs on MP or

00:18:08.770 --> 00:18:11.520
runs in a preemptive environment,
there's a lot of stuff you have to

00:18:11.620 --> 00:18:15.210
do to protect your data because you
might have code that gets re-entered.

00:18:15.300 --> 00:18:20.300
I/O Kit has some primitives,
Command Gate and Work Loop and

00:18:20.300 --> 00:18:25.810
a few other things that help you
thread your driver accordingly so

00:18:25.810 --> 00:18:29.400
that you get the expected behavior
with the minimum amount of fuss.

00:18:29.400 --> 00:18:32.630
This is not to say this is the
only way to thread your driver.

00:18:32.690 --> 00:18:36.150
You have complete power to
write it however you want.

00:18:36.200 --> 00:18:41.280
You can use a lot of the BSD locking
primitives if that's your preference.

00:18:41.400 --> 00:18:44.060
We recommend, of course,
following the I/O Kit models that

00:18:44.130 --> 00:18:45.890
you'll see in the example drivers.

00:18:45.900 --> 00:18:49.400
You'll, I think, have a much quicker
bring-up of your driver.

00:18:49.400 --> 00:18:54.190
But I/O Kit is not there to limit you,
it's simply there to assist you.

00:18:54.560 --> 00:18:59.090
Another thing that the Mac OS X kernel
gives you is multiple address spaces.

00:18:59.250 --> 00:19:02.340
The kernel runs in its own address space.

00:19:02.450 --> 00:19:06.230
Each application also runs
in its own address space.

00:19:06.240 --> 00:19:11.440
And by that I mean address 4000 is
going to mean something completely

00:19:11.440 --> 00:19:14.260
different to each application
as it does to the kernel.

00:19:14.260 --> 00:19:18.720
It may not be mapped at all in some
application or in the kernel space.

00:19:18.880 --> 00:19:23.000
So when you write a driver that
receives a request from a user,

00:19:23.190 --> 00:19:26.710
You've got to be aware of the fact that
that request may not be in an address

00:19:26.710 --> 00:19:28.340
space that you can directly access.

00:19:28.340 --> 00:19:31.570
You have to go through and either
copy it or map it into the kernel

00:19:31.590 --> 00:19:33.280
address space and do some I/O.

00:19:33.580 --> 00:19:36.050
Again, I/O Kit has some primitives
for making this easy.

00:19:36.280 --> 00:19:39.370
By and large,
most of you won't have to do this because

00:19:39.370 --> 00:19:43.530
if you follow what I/O Kit's done,
it comes for free.

00:19:43.620 --> 00:19:47.630
Another thing that we have thought about
in I/O Kit is architecture neutrality.

00:19:47.640 --> 00:19:50.540
The Darwin presentation the other day,
I guess yesterday,

00:19:50.540 --> 00:19:54.540
you saw an Intel machine
running the Darwin kernel.

00:19:54.630 --> 00:19:59.430
And one of the reasons that's
possible is I/O Kit has

00:19:59.520 --> 00:20:02.720
built-in byte swap capabilities.

00:20:02.840 --> 00:20:07.880
There's actually OS byte order, I think,
is the header that you look at.

00:20:08.060 --> 00:20:12.830
But it allows you to write a driver
that can be compiled for architecture

00:20:12.840 --> 00:20:16.210
of any Indianness and work correctly.

00:20:17.820 --> 00:20:21.270
Now, I/O Kit drivers really are
intended to focus on mechanism.

00:20:21.350 --> 00:20:26.630
And by that, I mean providing the conduit
for information to flow from the

00:20:26.800 --> 00:20:29.300
operating system into the device.

00:20:29.380 --> 00:20:34.740
We try to avoid having drivers
make user experience policies.

00:20:34.800 --> 00:20:36.650
And one of the reasons for
that is we want to have a

00:20:36.650 --> 00:20:38.000
more uniform user experience.

00:20:38.070 --> 00:20:41.100
We'd like those policies to
be enforced at a higher level.

00:20:41.190 --> 00:20:44.990
So the way a disk drive, for example,
is dealt with as far as whether it

00:20:44.990 --> 00:20:49.180
mounts on the desktop or not shouldn't
be driven out of the device driver.

00:20:49.300 --> 00:20:52.670
It should be driven out of something
higher level that looks at the volumes

00:20:52.800 --> 00:20:54.580
and decides what's to mount or not.

00:20:54.670 --> 00:20:58.540
This does also have the side effect of
making the drivers a little simpler for

00:20:58.540 --> 00:21:02.620
you because you get to write the code
to deal with mechanism and not policy.

00:21:04.610 --> 00:21:08.680
Another fundamental design goal we had
with I/O Kit is that we're not going to

00:21:08.680 --> 00:21:10.620
do something that is private for Apple.

00:21:10.620 --> 00:21:15.960
I/O Kit is not intended to be
Apple's private I/O system and,

00:21:15.960 --> 00:21:18.790
oh, by the way,
third parties can maybe do a few things.

00:21:18.800 --> 00:21:21.190
We're actually giving you the
power to write your own families.

00:21:21.190 --> 00:21:26.340
You can pick a standard that Apple is
probably not going to do a family for,

00:21:26.340 --> 00:21:29.740
like IEEE 488 or some other protocol.

00:21:29.740 --> 00:21:32.700
You can define a standard set of headers.

00:21:32.800 --> 00:21:35.680
You can public open source it in Darwin.

00:21:35.680 --> 00:21:37.200
In fact, I would strongly encourage that.

00:21:37.240 --> 00:21:40.200
If you do develop a family,
follow Apple's lead.

00:21:40.290 --> 00:21:41.400
We're open sourcing our families.

00:21:41.400 --> 00:21:42.230
You could do the same.

00:21:42.230 --> 00:21:46.470
This gives you an opportunity
to present new API that other

00:21:46.600 --> 00:21:51.360
developers can then build on and it
does it within a standard framework.

00:21:51.420 --> 00:21:54.480
You don't have to invent your
own mechanism for doing this.

00:21:54.600 --> 00:21:56.220
We actually have it built in.

00:21:56.240 --> 00:21:58.050
So you have all the same
power that Apple does.

00:21:58.080 --> 00:21:59.080
And as I said, their families are a
little bit different.

00:21:59.080 --> 00:21:59.080
Another fundamental design
goal we had with I/O Kit,

00:21:59.080 --> 00:21:59.080
the Mac OS X driver model,
how they are dynamically loaded,

00:21:59.080 --> 00:21:59.080
how they are dynamically loaded,
and how to begin making your

00:21:59.080 --> 00:21:59.100
own families work with Mac OS X.

00:21:59.100 --> 00:22:03.820
families are open source so you can also
if you want to follow the Apple public

00:22:03.870 --> 00:22:10.220
source license you can also lift our
code for your family and plagiarize

00:22:11.820 --> 00:22:14.740
Okay, so I've talked a lot about
families and drivers.

00:22:14.740 --> 00:22:19.890
I'm going to explain a little bit
about what the distinction is and why.

00:22:20.600 --> 00:22:21.830
So I/O Kit is just a framework.

00:22:21.940 --> 00:22:25.450
It doesn't understand anything
about particular protocols.

00:22:25.520 --> 00:22:29.580
There's no built-in
SCSI support in I/O Kit proper.

00:22:29.590 --> 00:22:30.780
So it's just a framework.

00:22:30.880 --> 00:22:33.650
It's a bunch of services
for memory management,

00:22:33.650 --> 00:22:37.100
interrupt management, device discovery,
matching and loading.

00:22:37.100 --> 00:22:39.380
There's a lot there,
but it doesn't know anything

00:22:39.940 --> 00:22:41.540
about particular devices.

00:22:41.580 --> 00:22:44.820
So families are loadable chunks of code.

00:22:44.820 --> 00:22:48.080
They are themselves kernel extensions.

00:22:48.080 --> 00:22:49.960
Some of them are built
into our kernel for now,

00:22:49.960 --> 00:22:53.050
but we intend to make all the families
loadable as kernel extensions.

00:22:53.060 --> 00:22:57.940
And that's where the code that
deals with a protocol lives,

00:22:57.940 --> 00:23:00.940
but not for a particular device.

00:23:00.940 --> 00:23:02.420
So this is the middle piece.

00:23:02.460 --> 00:23:06.260
So for example, all SCSI controllers have
some things in common.

00:23:06.260 --> 00:23:08.770
The way they queue messages,
the way that maybe they'll

00:23:08.770 --> 00:23:10.630
deal with error recovery,
the way they scan their bus.

00:23:10.660 --> 00:23:14.600
These things are not something
that the controller driver,

00:23:14.620 --> 00:23:17.310
the SIM writer,
wants to have to implement

00:23:17.370 --> 00:23:18.830
every single time.

00:23:18.860 --> 00:23:22.020
It also gives you the opportunity to
get wrong or get behavior different

00:23:22.030 --> 00:23:23.540
from one controller to another.

00:23:23.660 --> 00:23:26.540
The family is,
you can think of largely as a library

00:23:26.550 --> 00:23:29.150
that provides that functionality for you.

00:23:29.240 --> 00:23:32.060
And since it's object-oriented,
you can also override it.

00:23:32.250 --> 00:23:36.260
So we give it to you, you can use it,
but you can also override it and say,

00:23:36.260 --> 00:23:38.030
"You know,
I want to scan my SCSI devices in the

00:23:38.070 --> 00:23:40.440
reverse order because I think it's
cooler that way." So we give it to you,

00:23:40.440 --> 00:23:40.440
you can use it,
but you can also override it and say,

00:23:40.440 --> 00:23:40.440
"You know,
I want to scan my SCSI devices in the

00:23:40.440 --> 00:23:43.540
reverse order because I think it's
cooler that way." You have that power,

00:23:43.570 --> 00:23:47.100
but we encourage you to take
advantage of the functionality we do

00:23:47.110 --> 00:23:49.340
provide in the family superclasses.

00:23:49.360 --> 00:23:52.410
So the device specifics
then go into a third piece,

00:23:52.410 --> 00:23:54.220
which is the device driver.

00:23:54.260 --> 00:23:58.750
And our intent is by the time you
get down to that level of code,

00:23:58.750 --> 00:24:02.200
you're really only writing code to deal
with a particular piece of hardware

00:24:02.200 --> 00:24:03.600
or a particular set of hardware.

00:24:03.600 --> 00:24:06.380
That you don't have to worry
about scanning the SCSI bus.

00:24:06.420 --> 00:24:10.220
All you have to do is be able to take a
SCSI command and push it out on the bus.

00:24:10.220 --> 00:24:14.040
And when it completes,
call a completion routine.

00:24:14.120 --> 00:24:14.490
That's it.

00:24:14.750 --> 00:24:19.540
The superclass will make use of
that to cause the scanning to occur.

00:24:19.550 --> 00:24:20.590
It's a very nice layering.

00:24:20.590 --> 00:24:21.880
It's very powerful.

00:24:22.000 --> 00:24:23.780
And we take advantage of KEXTs.

00:24:23.860 --> 00:24:27.140
Kernel extensions really in this
case are a library mechanism.

00:24:27.240 --> 00:24:31.720
And we have the built-in understanding
in KEXTs for dependencies.

00:24:31.830 --> 00:24:35.360
So for example,
a SCSI controller driver would

00:24:35.360 --> 00:24:37.600
be dependent on the SCSI family,
obviously.

00:24:37.860 --> 00:24:40.000
But it's also going to be
dependent on typically this.

00:24:40.010 --> 00:24:45.770
The PCI family because you're
making a PCI SCSI controller driver.

00:24:45.890 --> 00:24:49.880
So what happens when you actually
go to load that device driver,

00:24:49.890 --> 00:24:52.470
it's going to see,
the KEXT mechanism will see that

00:24:52.630 --> 00:24:56.160
there's a dependency on both the
SCSI family and the PCI family.

00:24:56.170 --> 00:24:58.750
And we'll make sure that they're
both loaded for you and that

00:24:58.750 --> 00:25:00.480
you're linked against them.

00:25:00.480 --> 00:25:02.930
And in fact, it's arbitrarily deep.

00:25:03.040 --> 00:25:06.590
So let's say you have a
very complex product space,

00:25:06.590 --> 00:25:10.480
and you have some code that can be
shared between a number of your drivers.

00:25:10.490 --> 00:25:14.010
Well, cut and paste obviously works,
but that can be a real

00:25:14.010 --> 00:25:15.520
maintenance burden.

00:25:15.560 --> 00:25:19.180
But you can also introduce your
own sort of private family.

00:25:19.210 --> 00:25:21.870
That is something that maybe
extends the SCSI family,

00:25:21.870 --> 00:25:24.390
but isn't even a complete
driver in and of itself.

00:25:24.520 --> 00:25:27.950
You can then have a set of drivers,
a small cloud of other drivers,

00:25:28.120 --> 00:25:29.000
that then depend on that.

00:25:29.110 --> 00:25:31.020
So it's a generic library mechanism.

00:25:31.020 --> 00:25:32.830
It's actually very cool.

00:25:32.930 --> 00:25:35.070
Once we got it working and
started using it ourselves,

00:25:35.080 --> 00:25:41.220
we were actually pretty pleased
with how easily it is to work with.

00:25:43.070 --> 00:25:46.820
So each family contains a set
of classes that present an

00:25:46.820 --> 00:25:48.910
abstract view of a device.

00:25:48.910 --> 00:25:53.450
Now, this is important because this
is the point of mix and match.

00:25:53.450 --> 00:25:59.880
I/O Kit has a stacking mechanism so
that you can have any file system,

00:25:59.880 --> 00:26:02.550
for example, talking to any disk drive.

00:26:02.600 --> 00:26:07.010
Well, any implies that they all
look reasonably similar.

00:26:07.010 --> 00:26:09.600
Well, this is the point at which
we make them look similar.

00:26:09.600 --> 00:26:12.990
So first and foremost,
a family provides a set of

00:26:13.000 --> 00:26:17.580
abstractions that you must conform to
if you are a device of that family.

00:26:17.600 --> 00:26:21.120
A storage device, for example,
needs to have more or less the same

00:26:21.120 --> 00:26:23.570
access APIs as some other storage device.

00:26:23.600 --> 00:26:27.600
So you start with that base
class and you override.

00:26:27.600 --> 00:26:30.600
We'll also include a lot
of functionality there.

00:26:30.600 --> 00:26:32.580
As I said, minimally,
we provide the APIs.

00:26:32.610 --> 00:26:36.400
We could get by with basically just a
virtual empty class and then require

00:26:36.410 --> 00:26:38.600
you to do the entire implementation.

00:26:38.600 --> 00:26:41.860
But our intent is to go a lot
farther and actually give you

00:26:41.990 --> 00:26:45.570
as much of the implementation
as we believe is useful to you.

00:26:45.600 --> 00:26:49.850
And a couple examples of that,
I/O PCI device is an abstraction

00:26:49.850 --> 00:26:54.590
that every PCI device in the system
will be derived from this class.

00:26:54.600 --> 00:26:58.770
Same I/O parallel SCSI controller,
same thing.

00:26:59.430 --> 00:27:02.510
So ideally,
drivers will inherit most of the device's

00:27:02.600 --> 00:27:04.160
independent details from the family.

00:27:04.400 --> 00:27:08.420
Now, the other thing is that we
have an I/O prefix in front of

00:27:08.630 --> 00:27:11.800
all the families of I/O Kit.

00:27:11.820 --> 00:27:14.560
Apple is reserving this prefix.

00:27:14.560 --> 00:27:18.820
We do intend to allow you
to introduce new families.

00:27:18.990 --> 00:27:21.620
But for support reasons,
we ask that you release those families

00:27:21.700 --> 00:27:23.460
with a different prefix other than I/O.

00:27:23.460 --> 00:27:26.940
We'll talk about vendor
naming in just a minute.

00:27:26.960 --> 00:27:30.050
But when you encounter a
class that has the I/O prefix,

00:27:30.050 --> 00:27:33.660
that is officially part of Apple's
I/O Kit or one of its families.

00:27:33.680 --> 00:27:37.600
And that means it's something that's
intended for developers to use.

00:27:37.600 --> 00:27:43.390
It's either there for you to instantiate
or to subclass or to call into.

00:27:45.150 --> 00:27:47.670
So drivers are leaf classes.

00:27:47.770 --> 00:27:50.750
They basically have to be
because they need to be complete.

00:27:50.890 --> 00:27:53.940
They have to drive hardware.

00:27:53.960 --> 00:27:58.300
So for those of you not familiar
with object-oriented terminology,

00:27:58.300 --> 00:28:00.500
a leaf class is simply
something that doesn't have

00:28:00.500 --> 00:28:02.260
anything else building upon it.

00:28:02.260 --> 00:28:04.010
It's the final implementation.

00:28:04.210 --> 00:28:07.760
So in the class hierarchy,
what you would see is some classes

00:28:07.760 --> 00:28:10.770
provided by I/O Kit proper,
and then some additional

00:28:11.340 --> 00:28:14.980
subclassing going on in the family,
and then you would write the

00:28:14.980 --> 00:28:17.350
final class in your driver.

00:28:17.590 --> 00:28:19.660
It inherits a lot of
functionality from the family,

00:28:19.660 --> 00:28:22.200
as I said before,
and it focuses on the details

00:28:22.200 --> 00:28:23.950
of one specific device.

00:28:24.040 --> 00:28:30.630
Now, for naming your drivers,
we use Apple as a prefix for our classes.

00:28:30.650 --> 00:28:34.900
So when you, in Darwin,
encounter a class that starts with Apple,

00:28:34.990 --> 00:28:37.850
you'll know that that actually is not
intended for a developer to extend.

00:28:37.860 --> 00:28:39.890
That is what we consider a Leaf class.

00:28:39.990 --> 00:28:42.260
It's one of our own device drivers.

00:28:42.350 --> 00:28:47.130
Certainly a good choice as an example,
but probably not something

00:28:47.130 --> 00:28:49.370
you should be subclassing.

00:28:49.970 --> 00:28:55.780
Now, we have a namespace issue,
and that is in the Mac OS X kernel,

00:28:55.800 --> 00:30:09.100
[Transcript missing]

00:30:09.300 --> 00:30:11.950
Really,
it's only when you're defining them.

00:30:12.010 --> 00:30:15.200
It's actually a pretty
flexible mechanism.

00:30:15.200 --> 00:30:17.500
This is what we're intending
to go forward with,

00:30:17.540 --> 00:30:20.760
but would welcome any feedback
from you as to alternatives

00:30:20.760 --> 00:30:22.700
that you think might be better.

00:30:25.880 --> 00:30:29.890
So I've talked about
families and drivers,

00:30:29.930 --> 00:30:32.300
which are sort of static elements,
what goes where.

00:30:32.450 --> 00:30:35.420
Talk a little bit more about
the dynamic aspects of I/O Kit.

00:30:35.450 --> 00:30:37.030
When do things happen?

00:30:37.140 --> 00:30:39.710
So driver matching is really
at the heart of our plug and

00:30:39.830 --> 00:30:42.570
play and our hot swap story.

00:30:42.770 --> 00:30:46.710
And in general,
matching is provided by the family.

00:30:46.780 --> 00:30:48.620
The bulk of the matching
is provided there.

00:30:48.640 --> 00:30:52.380
And the reason it goes there is
because matching typically depends

00:30:52.400 --> 00:30:54.980
on device protocol specifics.

00:30:55.030 --> 00:31:00.940
So you aren't going to, for example,
see SCSI device matching

00:31:00.940 --> 00:31:05.530
overlap very much with,
say, FireWire device matching.

00:31:05.560 --> 00:31:07.970
There may be some similarities,
but it's sufficiently different

00:31:08.480 --> 00:31:12.600
that it makes sense to codify the
details of each bus in the family.

00:31:12.610 --> 00:31:17.400
Now, we use a subtractive logic,
which means we start with the list of

00:31:17.400 --> 00:31:20.520
all available drivers on the system.

00:31:20.580 --> 00:31:25.560
And we remove them from the list
at each layer in our matching

00:31:25.630 --> 00:31:27.740
system until we get down to one.

00:31:27.740 --> 00:31:30.720
So the very first step is class matching.

00:31:30.720 --> 00:31:35.190
As I said, we use classes to present
abstractions of devices.

00:31:35.200 --> 00:31:38.420
I named IOPCI device as an example.

00:31:38.420 --> 00:31:44.050
So you could pretty easily declare
that my driver will only talk to

00:31:44.050 --> 00:31:47.360
something of class IOPCI device.

00:31:47.360 --> 00:31:52.120
And when a PCI device nub pops
up and wants to be matched,

00:31:52.180 --> 00:31:54.940
it's going to ask for a list of
everything that can consume it.

00:31:54.940 --> 00:31:55.730
So I'm going to say,
I'm going to use this list of everything

00:31:55.740 --> 00:31:57.220
that can consume IOPCI device objects.

00:31:57.280 --> 00:32:00.210
And that will eliminate a
tremendous number of drivers

00:32:00.220 --> 00:32:01.440
from the list right there.

00:32:01.440 --> 00:32:04.460
Obviously,
USB device drivers need not apply.

00:32:04.460 --> 00:32:07.040
So that's done in I/O Kit proper.

00:32:07.300 --> 00:32:10.140
That's part of a service
we call the I/O Catalog.

00:32:10.190 --> 00:32:13.950
And once that's done,
it's up to the family to take that

00:32:14.210 --> 00:32:16.520
list of drivers and then apply
what we call passive matching.

00:32:16.520 --> 00:32:18.780
Now the reason we call
it passive matching,

00:32:18.780 --> 00:32:21.580
it's passive from the driver
developer's point of view.

00:32:21.580 --> 00:32:24.580
The person writing the driver
doesn't write any code here.

00:32:24.580 --> 00:32:28.600
You're going to put some matching
strings in your definition file,

00:32:28.600 --> 00:32:32.860
and the family will look at that file
and look at those strings and decide

00:32:32.860 --> 00:32:36.960
if you're a candidate for further
matching or if you should be excluded.

00:32:36.960 --> 00:32:39.980
So for example, in PCI,
you can use a name match,

00:32:39.980 --> 00:32:43.960
which is sort of derived from
the open firmware device naming,

00:32:43.960 --> 00:32:48.240
or you can use vendor ID and
device ID with a wild mask right

00:32:48.240 --> 00:32:50.070
out of the PCI config space.

00:32:50.080 --> 00:32:54.370
Different families, as I said,
will apply different logic here,

00:32:54.720 --> 00:32:58.690
but it allows you to very quickly
whittle down the list of drivers

00:32:58.690 --> 00:33:01.210
to a couple that are appropriate.

00:33:01.410 --> 00:33:05.860
Now, one of the things that we did not
want to do was invent a new language.

00:33:05.960 --> 00:33:09.650
We could very easily have gone overboard
and put in all sorts of regular

00:33:09.650 --> 00:33:14.300
expression goo and had the passive
matching be just incredibly powerful.

00:33:14.440 --> 00:33:18.850
But we decided that C++ is
already a pretty good language.

00:33:19.020 --> 00:33:19.970
Some people will debate that.

00:33:20.090 --> 00:33:23.290
But it's certainly something
that our compiler already

00:33:23.290 --> 00:33:25.280
supports and is very flexible.

00:33:25.360 --> 00:33:29.060
So we came up with a third stage,
which we call active matching.

00:33:29.140 --> 00:33:32.100
And as the term implies,
this means the driver being

00:33:32.100 --> 00:33:33.980
matched is active in this process.

00:33:34.020 --> 00:33:37.660
Its probe entry point gets called
with a reference to the thing

00:33:37.660 --> 00:33:39.350
it's being matched against.

00:33:39.410 --> 00:33:43.890
And it's then up to the driver
to actually talk to the thing.

00:33:44.020 --> 00:33:45.160
Is this one of my devices?

00:33:45.200 --> 00:33:46.660
Is it something I can talk to?

00:33:46.720 --> 00:33:49.330
This is sort of the ultimate catch-all.

00:33:49.410 --> 00:33:51.970
Ideally, we want to filter out as much
as we can in passive matching.

00:33:51.980 --> 00:33:54.270
But realistically,
we know you're never going to

00:33:54.270 --> 00:33:59.570
get 100%. So active matching
gives us the hooks to do very,

00:33:59.570 --> 00:34:01.710
very thorough matching.

00:34:01.970 --> 00:34:06.290
It also allows you to make decisions
based on dynamic characteristics.

00:34:06.300 --> 00:34:07.680
Do I want to match this right now?

00:34:07.830 --> 00:34:10.340
Whereas passive matching is static.

00:34:10.340 --> 00:34:13.890
You set the strings once,
and you'll match or not based on that.

00:34:13.900 --> 00:34:16.900
Now, this scheme allows for ties.

00:34:16.900 --> 00:34:23.670
You can have multiple drivers that all
claim to be able to drive a device.

00:34:23.940 --> 00:34:27.230
And we wanted to come up with
a reasonably safe mechanism

00:34:27.400 --> 00:34:29.900
for breaking those ties,
and it's simply based on scores.

00:34:29.900 --> 00:34:34.660
Our theory is that a more generic
driver should lose out to a more

00:34:34.660 --> 00:34:39.900
specific driver when both of them
claim to be able to drive a device.

00:34:40.070 --> 00:34:44.710
In practice with I/O Kit,
we have not run into cases where we have

00:34:45.010 --> 00:34:47.230
We have collisions past this point.

00:34:47.300 --> 00:34:51.030
It is entirely possible that somebody
else writes a generic driver that

00:34:51.190 --> 00:34:54.290
has the same match score as the
Apple-provided generic driver.

00:34:54.390 --> 00:34:57.420
And in this case, right now, the system,
I think,

00:34:57.420 --> 00:34:59.390
picks the first one that it sees.

00:34:59.650 --> 00:35:03.660
We might improve on this if
it proves to be necessary,

00:35:03.660 --> 00:35:07.320
but I suspect that what we
have here is flexible and

00:35:07.320 --> 00:35:09.980
powerful enough to be complete.

00:35:10.340 --> 00:35:11.440
There's a lot you can do here.

00:35:11.440 --> 00:35:13.740
If you're writing a family,
it's your responsibility

00:35:13.740 --> 00:35:17.700
to do the passive matching.

00:35:18.150 --> 00:35:20.450
Class matching, as I said,
is done by I/O Kit proper,

00:35:20.580 --> 00:35:24.150
and the active matching is
done by the driver writer.

00:35:27.550 --> 00:35:30.600
All right, the I/O Registry is
very central to I/O Kit.

00:35:30.660 --> 00:35:33.960
It is sort of the glue
that holds it all together.

00:35:34.070 --> 00:35:37.060
I've said object, object,
object quite a bit up here.

00:35:37.110 --> 00:35:39.590
Well,
I/O Registry is the collection of all the

00:35:39.590 --> 00:35:43.140
objects that make up the running system.

00:35:43.190 --> 00:35:47.080
So if you imagine that each device
driver is represented by a single object,

00:35:47.080 --> 00:35:49.700
and some of the other
device abstractions,

00:35:49.700 --> 00:35:53.080
like partitions on a disk are
represented by single objects,

00:35:53.120 --> 00:35:55.440
you have this sort of cloud of objects.

00:35:55.540 --> 00:35:59.490
Well,
the Iowa registry ties them all together.

00:35:59.920 --> 00:36:01.360
It's dynamic.

00:36:01.570 --> 00:36:03.500
It's the collection of
actual live running drivers.

00:36:03.500 --> 00:36:07.730
I want to call it a database,
but that implies, you know,

00:36:07.700 --> 00:39:03.500
[Transcript missing]

00:39:03.650 --> 00:39:07.010
Also, every driver has a property list,
and this is incredibly important

00:39:07.480 --> 00:39:10.890
in the registry and in an I/O Kit.

00:39:10.940 --> 00:39:17.090
The property list is really a
description of random properties that,

00:39:17.100 --> 00:39:20.080
some of them are things that we
declare that you need for the family,

00:39:20.200 --> 00:39:23.840
some of them are just notes
that you care to put in there.

00:39:23.900 --> 00:39:27.420
It is a collection,
typically a dictionary,

00:39:27.500 --> 00:39:30.600
and a dictionary is a
named set of values.

00:39:30.720 --> 00:39:39.690
So, for example, a driver would have a
property called version,

00:39:39.690 --> 00:39:39.690
and you could do a

00:39:39.810 --> 00:39:43.650
The I/O Kit is a very simple,
easy-to-use software that

00:39:43.650 --> 00:39:46.700
allows you to create a lot of
different types of I/O Kit.

00:39:46.700 --> 00:39:49.930
It's a very simple,
easy-to-use software that

00:39:50.240 --> 00:39:53.580
allows you to create a lot of
different types of I/O Kit.

00:39:53.690 --> 00:39:53.700
It's a very simple,
easy-to-use software that

00:39:53.700 --> 00:39:56.690
allows you to create a lot of
different types of I/O Kit.

00:39:56.700 --> 00:39:59.290
The I/O Kit is a very simple,
easy-to-use software that

00:39:59.290 --> 00:40:02.690
allows you to create a lot of
different types of I/O Kit.

00:40:02.720 --> 00:40:04.290
It's a very simple,
easy-to-use software that allows you

00:40:04.290 --> 00:40:08.740
to create list file in your driver
as part of the kernel extension.

00:40:08.870 --> 00:40:13.060
And in there,
you put in your primordial property list.

00:40:13.060 --> 00:40:15.910
So later on, when you actually get
down to running your code,

00:40:16.070 --> 00:40:18.930
that same bit of data is given to you.

00:40:19.110 --> 00:40:22.890
And you can then use
that as input parameters.

00:40:23.210 --> 00:40:26.010
You can also use it,
once you've gotten it,

00:40:26.330 --> 00:40:28.410
as a dynamic communication mechanism.

00:40:28.500 --> 00:40:32.980
There are libraries available to allow
an application to scan the registry

00:40:32.980 --> 00:40:35.990
looking for a particular object,
either by its type or by some

00:40:35.990 --> 00:40:37.710
property in this property list.

00:40:37.720 --> 00:40:40.270
And once you've found the object,
you can do get property and

00:40:40.270 --> 00:40:41.420
set property calls on it.

00:40:41.480 --> 00:40:45.340
And the driver can just allow
those calls to communicate with

00:40:45.410 --> 00:40:48.480
its property list directly,
or it can override them.

00:40:48.640 --> 00:40:49.860
And this is where it gets cool.

00:40:49.860 --> 00:40:57.140
So an application can do a set property,
say it wants to send a password down.

00:40:57.820 --> 00:40:59.940
The driver receives
the set property call,

00:41:00.010 --> 00:41:02.500
and because they've
overridden set property,

00:41:02.510 --> 00:41:05.300
they look at the property being
set and see that it's my password.

00:41:05.300 --> 00:41:09.100
And they intercept that call,
they do something special,

00:41:09.100 --> 00:41:12.660
and they don't actually have to
put the password into the registry.

00:41:12.660 --> 00:41:16.320
You can actually kind of hijack that
as a communication mechanism for low

00:41:16.320 --> 00:41:18.480
bandwidth configuration-y type stuff.

00:41:18.500 --> 00:41:22.060
I know a lot of driver developers
will use this for turning

00:41:22.570 --> 00:41:24.310
on and off verbose mode.

00:41:24.340 --> 00:41:27.850
You can do a set property verbose
and set it to some number,

00:41:27.850 --> 00:41:30.330
and then your driver can receive
that call and do something with it.

00:41:30.340 --> 00:41:36.930
So it's very open-ended as
to what you can do with this.

00:41:41.010 --> 00:41:43.320
So how do you see it and
how do you get at it?

00:41:43.400 --> 00:41:45.970
It's important that you, I think,
understand what it's there

00:41:45.970 --> 00:41:47.080
for and how it's used.

00:41:47.190 --> 00:41:49.280
So we've put an application together.

00:41:49.280 --> 00:41:51.660
It's actually a pretty nice
graphical application called

00:41:51.660 --> 00:41:53.610
I/O Registry Explorer.app.

00:41:53.660 --> 00:41:56.440
It was present in the KDK that
we shipped last February,

00:41:56.440 --> 00:41:59.130
and it's present again in
DP4 and will continue to be

00:41:59.190 --> 00:42:00.780
present as a developer tool.

00:42:00.780 --> 00:42:06.740
It allows you to use a browser view to
walk through any plane of the registry.

00:42:06.850 --> 00:42:09.540
So by default, it lets you walk through
the service plane,

00:42:09.540 --> 00:42:14.170
but it will allow you to switch planes,
I believe.

00:42:14.980 --> 00:42:17.410
Once you land on a driver,
it also shows you the

00:42:17.520 --> 00:42:19.490
property list for that driver.

00:42:19.580 --> 00:42:23.900
So we don't yet have the ability to
allow you to change those properties,

00:42:24.030 --> 00:42:26.900
but right now, today,
you can take a look at the actual

00:42:27.120 --> 00:42:30.550
set of drivers running in your
system and what properties they

00:42:30.550 --> 00:42:32.010
have and how they're being used.

00:42:32.010 --> 00:42:34.770
And it's great just to sit
down and explore and see how

00:42:34.770 --> 00:42:36.340
the thing's put together.

00:42:36.420 --> 00:42:40.900
Now, for Darwin developers
that don't have the GUI,

00:42:40.900 --> 00:42:44.300
or if you're just interested in, say,
maybe piping some information

00:42:44.300 --> 00:42:47.940
into an email message,
you want to cut and paste it, like,

00:42:48.010 --> 00:42:50.520
why is this object showing up
here when I don't understand it,

00:42:50.610 --> 00:42:53.490
to send that to us so we
can explain it to you.

00:42:53.700 --> 00:42:56.220
We have a command line
version called I/O Reg,

00:42:56.220 --> 00:43:00.230
and this is sort of a BSD-style
command line utility that you can run.

00:43:00.360 --> 00:43:03.760
By default, it just gives you a list of
which drivers are out there.

00:43:03.840 --> 00:43:06.650
You can also give it an option to
actually give you all the drivers

00:43:06.650 --> 00:43:08.400
and all of their properties,
and it will spew a

00:43:08.400 --> 00:43:10.160
tremendous amount of text.

00:43:10.250 --> 00:43:15.690
But it's a very powerful way to
figure out what's in the system.

00:43:16.050 --> 00:43:18.420
Look at it before you load your
driver and after to verify that

00:43:18.420 --> 00:43:23.040
your driver is matching where
you expect it to and present.

00:43:23.090 --> 00:43:28.600
So, very, very powerful tool both during
development and actually as a mechanism

00:43:28.600 --> 00:43:31.480
for communicating with your driver.

00:43:32.500 --> 00:43:36.270
Which leads us into the
user kernel boundary.

00:43:36.420 --> 00:43:39.690
Now, as I said before,
drivers are inside the kernel and users

00:43:39.690 --> 00:43:41.200
and applications are outside the kernel.

00:43:41.200 --> 00:43:43.730
So obviously,
we've got to bridge this user kernel

00:43:43.730 --> 00:43:47.370
boundary for I/O to be of any use
at all in the operating system.

00:43:47.380 --> 00:43:51.580
So we have several mechanisms at
our disposal in the Mac OS X kernel.

00:43:51.580 --> 00:43:56.380
System calls, and by this I mean sort of
the BSD-style system call.

00:43:56.380 --> 00:44:02.380
This is also how networking communication
works using the socket system calls.

00:44:02.380 --> 00:44:06.320
We also have a Mach inter-process
communication that's available,

00:44:06.320 --> 00:44:08.250
and we have Mach shared memory.

00:44:08.330 --> 00:44:13.370
I/O Kit uses all of these mechanisms
at various times to communicate

00:44:13.370 --> 00:44:15.380
between user space and the kernel.

00:44:15.380 --> 00:44:19.620
And in most of these cases,
we try to wrap this with family code.

00:44:19.620 --> 00:44:23.380
So inside the kernel,
it's buried inside of a family,

00:44:23.380 --> 00:44:26.380
and in user space,
it's buried inside of a library.

00:44:26.380 --> 00:44:28.380
So you don't have to actually
get at the guts of this.

00:44:28.380 --> 00:44:32.360
If you have special
communication requirements

00:44:32.360 --> 00:44:34.680
between user and kernel space,
then you might actually have to

00:44:34.680 --> 00:44:36.360
get at these mechanisms directly.

00:44:36.360 --> 00:44:37.360
And I direct you to Darwin.

00:44:37.360 --> 00:44:40.360
There's a rich source of
examples of how to do this,

00:44:40.360 --> 00:44:42.360
because all three of these are used.

00:44:44.260 --> 00:44:46.390
Well, in I/O Kit,
we really are trying to push

00:44:46.390 --> 00:44:49.180
a wrapped version of those
mechanisms that is a little cleaner.

00:44:49.180 --> 00:44:51.070
We call it the user-client model.

00:44:51.250 --> 00:44:54.920
And by user-client,
that name is really from

00:44:55.040 --> 00:44:56.790
a kernel perspective.

00:44:57.140 --> 00:44:59.650
And what this means is
I am a kernel driver,

00:44:59.650 --> 00:45:02.820
and I have a client that's
actually in user space.

00:45:03.300 --> 00:45:05.870
So this is part of the
I/O Kit infrastructure,

00:45:06.080 --> 00:45:07.330
the main framework.

00:45:07.410 --> 00:45:13.260
And the cool thing is,
from a driver-writer's perspective,

00:45:13.260 --> 00:45:14.450
you don't have to do anything different.

00:45:14.630 --> 00:45:19.700
A user client looks
like an internal client.

00:45:19.710 --> 00:45:23.290
But from an application's viewpoint,
it looks like a library or a CF plug-in.

00:45:23.300 --> 00:45:26.640
And effectively,
we've written both of the pieces of code

00:45:26.710 --> 00:45:31.020
and wrapped the transmission mechanism,
and you just make use of the

00:45:31.260 --> 00:45:34.240
simple APIs that you already
would be doing in kernel anyway.

00:45:34.300 --> 00:45:38.880
And you have a communication mechanism.

00:45:39.330 --> 00:45:42.360
And as I said,
if you have additional requirements

00:45:42.570 --> 00:45:46.730
for low bandwidth communication,
you can hijack get property set property.

00:45:46.820 --> 00:45:49.300
If you have requirements for other
high bandwidth communication,

00:45:49.300 --> 00:45:52.730
then you're probably going to
have to do something like shared

00:45:53.260 --> 00:45:55.000
memory or some other mechanism.

00:45:55.360 --> 00:45:57.590
If you need something, let us know.

00:45:57.600 --> 00:45:58.300
Give us the feedback.

00:45:58.300 --> 00:46:01.000
Because again, as I said,
I/O Kit is a framework there to help

00:46:01.000 --> 00:46:03.140
you make your drivers easy to write.

00:46:03.140 --> 00:46:05.400
And if you need it, there's a good chance
somebody else needs it.

00:46:05.440 --> 00:46:08.910
And if it looks like we've got a
community of developers that need

00:46:09.020 --> 00:46:12.320
a service we're not providing,
we'll try to add that in.

00:46:13.470 --> 00:46:16.720
The other thing that's important,
as I described earlier,

00:46:16.720 --> 00:46:19.510
the matching process of
I/O Kit starts at the bottom,

00:46:19.520 --> 00:46:23.440
the platform expert,
and matches up as we discover devices,

00:46:23.440 --> 00:46:25.110
we load and add new drivers.

00:46:25.120 --> 00:46:28.590
Well,
user client reaches down from user land.

00:46:28.630 --> 00:46:32.500
The kernel can't really go
out and find an app and say,

00:46:32.500 --> 00:46:34.540
"Oh,
I bet you need to talk to me." It really

00:46:34.650 --> 00:46:36.220
has to happen the other way around.

00:46:36.330 --> 00:46:38.990
So the application has to
request the connection.

00:46:39.070 --> 00:46:39.910
So here's how it works.

00:46:40.020 --> 00:46:42.730
First, the application is going
to find the target driver,

00:46:42.730 --> 00:46:45.280
and it does this by looking
in the I/O registry.

00:46:45.330 --> 00:46:47.420
It will, again,
it'll search for something

00:46:47.420 --> 00:46:49.150
of a given class,
or it'll search for

00:46:49.150 --> 00:46:50.760
something with properties.

00:46:50.800 --> 00:46:53.480
But once it finds the
driver it's interested in,

00:46:53.520 --> 00:46:57.820
it generates a connection request
through the appropriate user client.

00:46:58.010 --> 00:47:01.390
That causes a temporary kernel
object to be created to act as the

00:47:01.500 --> 00:47:03.550
kernel half of that communication.

00:47:03.810 --> 00:47:06.220
And from that point on, the user,
application,

00:47:06.220 --> 00:47:06.230
and the client are going to be
able to connect to the driver.

00:47:06.290 --> 00:47:08.780
And then the application has access
to communicate with the device.

00:47:08.930 --> 00:47:14.880
If the user application dies
unexpectedly or exits normally,

00:47:14.900 --> 00:47:19.490
the Mach kernel will notice the fact
that that communication pathway no

00:47:19.500 --> 00:47:23.420
longer has any user space listeners
and will clean up all resources.

00:47:23.420 --> 00:47:26.250
So you don't have to worry
about an application dying,

00:47:26.250 --> 00:47:28.910
leaving some device in
an inaccessible state.

00:47:30.000 --> 00:47:36.050
This is part of our push to make sure
that one app can't affect another app.

00:47:37.690 --> 00:47:41.940
Okay, so that was really the high-level
overview of how I/O Kit is put together.

00:47:42.230 --> 00:47:45.250
Now I want to give you a roadmap
of where we're going and show

00:47:45.280 --> 00:47:47.630
you what other sessions are
going to be of interest to you.

00:47:47.660 --> 00:47:51.660
So, in DP4,
we have driver loading and unloading,

00:47:51.660 --> 00:47:54.760
and that's available for
a number of families.

00:47:54.760 --> 00:47:57.930
Actually, it's available for any family
you can write a driver for.

00:47:57.940 --> 00:48:02.860
Plug and Play and Hot Swap are
there now and implemented for USB,

00:48:03.030 --> 00:48:07.700
FireWire, and storage,
and we'll be making it available

00:48:07.820 --> 00:48:08.870
a little bit more widely.

00:48:08.940 --> 00:48:12.910
But it really depends on
the semantics of the family.

00:48:12.910 --> 00:48:17.100
Right now, we don't have the
ability to hot swap PCI,

00:48:17.100 --> 00:48:20.450
so we don't have hot swap
capabilities in the PCI family.

00:48:20.580 --> 00:48:26.230
As those technologies become important,
we'll extend families to deal with that.

00:48:26.300 --> 00:48:29.130
And device power management
has been implemented for screen

00:48:29.130 --> 00:48:31.680
dimming and for drive spin down.

00:48:31.770 --> 00:48:34.170
We'll be coming to
other families shortly.

00:48:34.310 --> 00:48:37.160
This is something we're pushing
on rather aggressively right now.

00:48:37.160 --> 00:48:41.020
We actually had done a lot of
work that was not ready for DP4.

00:48:41.320 --> 00:48:43.820
So we didn't want to risk
destabilizing DP4 by dumping

00:48:43.820 --> 00:48:45.150
in changes at the last minute.

00:48:45.280 --> 00:48:48.080
But it is, we've made actually quite a
lot of progress and we'll be

00:48:48.080 --> 00:48:50.000
coming out with that soon.

00:48:50.180 --> 00:48:53.100
And there are many families in DP4.

00:48:53.260 --> 00:48:55.380
As I said earlier,
we're going to be pushing out another

00:48:55.380 --> 00:48:58.320
KDK for you to install on top of DP4.

00:48:58.700 --> 00:49:01.700
And so we're going to provide
updates for a few families.

00:49:01.780 --> 00:49:05.420
And we're going to add more documentation
and examples beyond what you see in DP4.

00:49:05.710 --> 00:49:06.840
And there'll be more user clients.

00:49:06.920 --> 00:49:08.550
This is another area we're pushing.

00:49:08.610 --> 00:49:12.710
Right now in DP4,
the primary user clients for storage

00:49:12.710 --> 00:49:17.670
have been there for a while because
it's necessary to get at disks.

00:49:17.720 --> 00:49:22.150
But we really only had direct
device access for USB devices.

00:49:22.280 --> 00:49:28.110
In June, we hope to add SCSI and
possibly some others as well.

00:49:30.490 --> 00:49:35.320
Then the public beta this summer,
we will have boot time driver loading.

00:49:35.380 --> 00:49:39.450
Right now, kernel extensions have to be
loaded after the system comes up,

00:49:39.450 --> 00:49:42.750
because the mechanism through which
we load them requires a system

00:49:42.750 --> 00:49:45.460
folder effectively to be mounted.

00:49:45.460 --> 00:49:48.770
But we're adding that capability
into the booter so that in future

00:49:49.190 --> 00:49:52.360
versions you won't have to have
your drivers built into the kernel,

00:49:52.540 --> 00:49:55.610
which I know is going to be
very difficult for most of you.

00:49:55.640 --> 00:49:59.080
So, boot time driver loading is coming.

00:49:59.130 --> 00:50:01.030
Full device and system power management.

00:50:01.040 --> 00:50:04.740
As I said before,
we've got a strong push going on here.

00:50:05.080 --> 00:50:07.900
And also more families and user clients.

00:50:08.780 --> 00:50:11.180
So now I'm going to walk through
each of the families and just

00:50:11.180 --> 00:50:14.330
give you some status and pointers.

00:50:14.480 --> 00:50:17.290
For the SCSI family,
this is of particular interest to

00:50:17.290 --> 00:50:19.790
people writing SCSI controller drivers.

00:50:19.960 --> 00:50:23.600
So if you're writing a parallel
SCSI controller driver,

00:50:23.640 --> 00:50:26.660
you're going to need to inherit
from a class in this family.

00:50:26.690 --> 00:50:29.160
It also provides SCSI device access.

00:50:29.270 --> 00:50:32.020
So if you are writing a driver
that talks to the SCSI bus,

00:50:32.150 --> 00:50:34.470
then you're also going to
care about this family.

00:50:34.570 --> 00:50:37.510
You won't be inheriting from it,
but you will be communicating

00:50:37.510 --> 00:50:38.510
with its abstraction.

00:50:38.520 --> 00:50:42.080
So you will be including
headers that it provides.

00:50:42.170 --> 00:50:45.120
So it was in the alpha KDK that
we shipped in February,

00:50:45.120 --> 00:50:46.900
and it's also in DP4.

00:50:47.030 --> 00:50:49.230
It's effectively final.

00:50:49.430 --> 00:50:53.080
We expect a few minor changes,
a few bug fixes, and maybe adding some

00:50:53.080 --> 00:50:55.200
additional helper functions.

00:50:55.270 --> 00:50:57.690
But by and large,
you can consider what's in there,

00:50:57.910 --> 00:50:59.310
what we intend to ship for SCSI.

00:50:59.330 --> 00:51:02.520
So you should be able
to make progress there.

00:51:03.360 --> 00:51:07.050
So there is not presently a
user client available for it.

00:51:07.090 --> 00:51:09.830
That will be available in June.

00:51:09.960 --> 00:51:11.580
It has been HeaderDoc'd.

00:51:11.580 --> 00:51:13.190
It has been open sourced.

00:51:13.190 --> 00:51:15.910
And there are example drivers in Darwin.

00:51:15.950 --> 00:51:21.850
So if you're developing this area,
you should be fairly good to go.

00:51:22.730 --> 00:51:26.200
We recommend going to session
108 on Friday morning.

00:51:26.200 --> 00:51:28.470
We're going to actually not be
spending a tremendous amount of

00:51:28.600 --> 00:51:31.690
time talking about SCSI controllers,
but we will be talking about

00:51:32.190 --> 00:51:34.780
the infrastructure needed for
writing a peripheral driver,

00:51:34.790 --> 00:51:36.200
a storage peripheral driver.

00:51:36.200 --> 00:51:40.230
So if you're writing a SCSI disk
driver or some description,

00:51:40.230 --> 00:51:42.280
this would be a good session for you.

00:51:43.110 --> 00:51:47.350
The ATA and ATAPI family is, again,
of interest to you if you're

00:51:47.350 --> 00:51:50.240
writing a controller for ATA.

00:51:50.270 --> 00:51:54.340
And it also is of interest to you if
you're writing a device driver that

00:51:54.340 --> 00:51:58.640
needs to communicate through the ATA bus,
either as an ATA or an ATAPI device.

00:51:58.650 --> 00:52:03.120
It is in DP4 and, like SCSI,
only has minor changes left,

00:52:03.120 --> 00:52:06.820
some cleanup and some bugs removed,
as you would expect.

00:52:06.970 --> 00:52:10.190
But you should be able
to make progress there.

00:52:10.400 --> 00:52:14.050
We expect to have a user client in June.

00:52:14.050 --> 00:52:16.860
This is not quite as far along,
so this is a little bit

00:52:16.860 --> 00:52:19.700
softer of a promise,
but this will be particularly

00:52:19.700 --> 00:52:20.690
for a TAPI devices.

00:52:20.700 --> 00:52:24.020
I don't think we intend to export
ATA devices outside the kernel.

00:52:24.020 --> 00:52:27.840
It is not yet HeaderDoc'd, but will be.

00:52:27.880 --> 00:52:31.020
It is open sourced and
there are example drivers,

00:52:31.040 --> 00:52:33.850
so you should be able to at
least look at them and...

00:52:34.100 --> 00:52:41.300
[Transcript missing]

00:52:42.980 --> 00:52:47.980
So FireWire and SPP2 are obviously
of great importance to Apple.

00:52:48.040 --> 00:52:53.290
And for those of you that don't know,
SPP2, Serial Bus Protocol 2,

00:52:53.350 --> 00:52:58.320
is a sort of a CDB or command descriptor
based mechanism for delivering

00:52:58.380 --> 00:53:00.620
command packets over the FireWire bus.

00:53:00.620 --> 00:53:04.670
And a large number of devices are
SPP2 devices other than camcorders.

00:53:04.700 --> 00:53:10.180
So like SCSI, or excuse me,
FireWire disk drives are typically SPP2.

00:53:10.180 --> 00:53:12.780
You will care about this family if
you're writing a FireWire controller

00:53:12.780 --> 00:53:18.500
or if you're trying to gain access
to a FireWire or an SPP2 device.

00:53:18.500 --> 00:53:20.260
This is in DP4.

00:53:20.260 --> 00:53:22.600
There's going to be more
provided in the June KDK.

00:53:22.860 --> 00:53:25.280
And again,
it's mostly done--we're syncing

00:53:25.280 --> 00:53:28.450
up with development that's
been done against Mac OS 9.

00:53:28.450 --> 00:53:31.290
Those teams are bringing some
bug fixes forward that we

00:53:31.290 --> 00:53:32.710
didn't have in our code base.

00:53:32.790 --> 00:53:37.950
So coming soon, we hope to have basically
parity with what Mac OS 9 has.

00:53:39.630 --> 00:53:43.710
So, as I said, for ATA and a TAPI,
we're only providing a

00:53:43.710 --> 00:53:45.270
TAPI as a user client.

00:53:45.680 --> 00:53:47.120
Same is true with FireWire.

00:53:47.120 --> 00:53:49.660
We only intend to allow
SPP2 as a user client,

00:53:50.000 --> 00:53:52.200
because FireWire is really
a memory bus protocol,

00:53:52.200 --> 00:53:54.410
and for security reasons,
we don't want to expose

00:53:54.420 --> 00:53:55.760
that out into user space.

00:53:55.760 --> 00:53:59.970
It's not yet HeaderDoc'd,
but it is open sourced,

00:53:59.970 --> 00:54:05.070
and there are examples,
and we will be documenting it soon.

00:54:06.230 --> 00:54:10.580
So there are two FireWire sessions
coming up tomorrow and Thursday.

00:54:10.670 --> 00:54:12.970
If you're interested at all in FireWire,
I recommend you attend these.

00:54:13.160 --> 00:54:15.460
The in-depth session in
particular will be talking about

00:54:15.810 --> 00:54:18.250
I/O Kit drivers for FireWire.

00:54:19.560 --> 00:54:20.420
The USB family.

00:54:20.690 --> 00:54:23.280
If you're writing a
USB controller driver,

00:54:23.340 --> 00:54:26.940
then you will need to
subclass from code in here.

00:54:26.990 --> 00:54:30.740
If you are attempting
to access a USB device,

00:54:30.800 --> 00:54:33.390
then you also need to include
headers from this family.

00:54:33.520 --> 00:54:34.770
Again, it's mostly done.

00:54:34.900 --> 00:54:38.800
We're syncing up with some development
effort that had gone on for Mac OS 9,

00:54:38.870 --> 00:54:41.470
but we, again,
hope to have parity there soon.

00:54:41.510 --> 00:54:44.500
It was in the Alpha KDK last February.

00:54:44.500 --> 00:54:48.500
It's in DP4 today,
and there will be more coming in June.

00:54:49.990 --> 00:54:51.470
So there is a user client for it.

00:54:51.600 --> 00:54:53.690
It was there back in February.

00:54:53.830 --> 00:54:56.610
So from an application,
you can find and talk

00:54:56.840 --> 00:54:58.950
to USB devices directly.

00:54:59.210 --> 00:55:01.770
It's not yet HeaderDoc'd,
but we are working on that.

00:55:01.810 --> 00:55:06.040
It is open sourced,
and it does have example drivers.

00:55:06.040 --> 00:55:08.710
So you should be able to poke
around and figure out what

00:55:08.850 --> 00:55:10.630
we're doing there quite easily.

00:55:11.410 --> 00:55:13.190
So there's a USB session.

00:55:13.480 --> 00:55:17.180
There's not going to be a lot of depth
here about writing USB I/O Kit drivers,

00:55:17.180 --> 00:55:20.570
I believe,
but we'll give you some more pointers.

00:55:22.070 --> 00:55:25.450
The PCI and AGP families,
family singular,

00:55:25.460 --> 00:55:30.220
is what you would use for
getting access to a PCI device.

00:55:30.220 --> 00:55:34.400
And also, if you're writing a
PCI or AGP bus controller,

00:55:34.400 --> 00:55:37.290
you're going to inherit from this,
but I expect that's mostly

00:55:37.380 --> 00:55:39.270
for Apple at this point.

00:55:39.450 --> 00:55:41.980
And it's considered
feature complete in DP4.

00:55:42.260 --> 00:55:44.190
Obviously,
there's always going to be bugs to fix,

00:55:44.260 --> 00:55:46.420
but it's basically there.

00:55:46.760 --> 00:55:49.080
So we don't intend to
create a user client.

00:55:49.150 --> 00:55:54.500
We don't expect for applications to
directly generate PCI bus cycles.

00:55:54.500 --> 00:55:56.970
Again, it's a security issue,
and it's not something we

00:55:56.970 --> 00:55:58.410
actually see as that useful.

00:55:58.550 --> 00:56:00.490
There are a few cases where it might be.

00:56:00.610 --> 00:56:02.740
But any time you need
to talk to a PCI device,

00:56:02.740 --> 00:56:05.720
you should write a driver
that lives inside the kernel.

00:56:05.720 --> 00:56:08.460
It is HeaderDoc'd, it is open sourced,
and there are samples.

00:56:10.480 --> 00:56:14.710
So just after this, there is a session on
PCI and Open Firmware.

00:56:14.910 --> 00:56:17.160
There actually is going to
be a demonstration of the

00:56:17.160 --> 00:56:20.680
I/O Registry Explorer application
that I discussed earlier.

00:56:20.680 --> 00:56:23.100
And they're going to go into
a good bit of detail about

00:56:23.100 --> 00:56:25.560
how to get at PCI resources.

00:56:27.290 --> 00:56:29.070
So serial and telephony.

00:56:29.110 --> 00:56:34.560
This family today really
only supports serial modems,

00:56:34.560 --> 00:56:35.960
AT-style serial modems.

00:56:35.960 --> 00:56:38.970
In the future,
we want to have USB modem support,

00:56:38.970 --> 00:56:40.910
feature phones, who knows?

00:56:40.910 --> 00:56:42.430
There's a lot that can be done here.

00:56:42.430 --> 00:56:46.710
But what we have in DP4 is not
what we expect to be final.

00:56:46.870 --> 00:56:49.860
It's actually not even structured very
much like what we expect to be final.

00:56:49.860 --> 00:56:56.530
So if you have telephone or serial needs,
then DP4 is probably not

00:56:56.530 --> 00:56:58.700
going to get you very far.

00:56:58.850 --> 00:57:03.990
We do have support for AT-style modems
and basic PPP connectivity in there.

00:57:03.990 --> 00:57:09.750
But from a developer perspective,
there's not much you can do.

00:57:09.760 --> 00:57:11.860
It does have a user client.

00:57:11.910 --> 00:57:16.920
That is,
you can go through the /dev/tty interface

00:57:17.000 --> 00:57:18.640
to get at serial ports Unix style.

00:57:18.640 --> 00:57:21.890
So it is not the final
way we want to do this.

00:57:21.900 --> 00:57:23.590
It's not HeaderDoc'd.

00:57:23.860 --> 00:57:25.860
And by the way,
when I put this slide together,

00:57:25.870 --> 00:57:27.140
it was not open sourced.

00:57:27.150 --> 00:57:28.840
It actually now is.

00:57:28.840 --> 00:57:33.160
So if you go out to Darwin,
you can see the current serial drivers,

00:57:33.160 --> 00:57:35.640
which then also implies
that they're examples.

00:57:35.640 --> 00:57:39.130
This is not what we intend to be final,
but it does work.

00:57:39.140 --> 00:57:43.580
And if you need to have a serial
product working in the near term,

00:57:43.580 --> 00:57:46.050
you should build on what we've done.

00:57:49.130 --> 00:57:51.830
So I'm going to talk a little
bit more about telephony in the

00:57:51.830 --> 00:57:55.100
early part of the networking
hardware session on Friday morning.

00:57:55.100 --> 00:57:56.740
Again,
there's not a whole lot to say there

00:57:56.750 --> 00:57:59.520
because it's mostly in the future,
but it will give you a little

00:57:59.520 --> 00:58:01.100
more idea of what's going on.

00:58:01.100 --> 00:58:04.620
ADB family,
not particularly interesting at

00:58:04.700 --> 00:58:09.100
this stage in Apple's evolution,
but if you're wanting

00:58:09.100 --> 00:58:13.270
to write an ADB dongle,
then say a USB to ADB dongle driver,

00:58:13.270 --> 00:58:18.100
then you're going to need to subclass
from the ADB controller class.

00:58:18.110 --> 00:58:21.090
And if you're wanting to
talk to an ADB device,

00:58:21.100 --> 00:58:23.900
then you're going to need to
communicate with an I/O ADB device

00:58:24.160 --> 00:58:25.080
by looking at that header.

00:58:25.110 --> 00:58:27.040
It's basically complete at this point.

00:58:27.170 --> 00:58:29.100
It's pending review.

00:58:29.100 --> 00:58:31.680
As I said,
it's not our top priority at this point

00:58:31.770 --> 00:58:35.720
because we're obviously focusing forward
on technologies like USB and FireWire,

00:58:35.720 --> 00:58:40.100
but we need to review it and close
it out so we can say this is done.

00:58:40.100 --> 00:58:45.050
We don't expect any major changes,
and if it's reviewed in time,

00:58:45.050 --> 00:58:47.090
it may be in the June KDK.

00:58:47.100 --> 00:58:47.100
So it's not yet HeaderDoc'd.

00:58:47.100 --> 00:58:52.100
It does have a user client,
and it is open sourced.

00:58:52.970 --> 00:58:54.460
Not a whole lot more to stay there.

00:58:54.550 --> 00:58:58.480
The storage family,
this is kind of a long buzzword,

00:58:58.550 --> 00:59:01.930
but we don't want to say disks because,
you know, they're solid state storage

00:59:01.940 --> 00:59:03.510
and other forms of storage.

00:59:03.600 --> 00:59:05.840
So persistent mass storage devices.

00:59:05.840 --> 00:59:07.940
How's that not offending anybody?

00:59:07.940 --> 00:59:14.150
Storage family is used to represent
both the drives and the media.

00:59:14.150 --> 00:59:16.770
And we distinguish between the
two of them in I/O Kit because

00:59:16.890 --> 00:59:17.940
it's very important.

00:59:17.940 --> 00:59:20.580
Obviously, with removable media,
the drive sticks around,

00:59:20.580 --> 00:59:21.360
but the media goes.

00:59:21.360 --> 00:59:23.880
Or in FireWire,
sometimes the whole drive goes.

00:59:23.890 --> 00:59:25.390
And it's important to
know the difference.

00:59:25.390 --> 00:59:29.360
You're going to care about this if
you're writing a partition scheme,

00:59:29.360 --> 00:59:33.840
if you're writing a new disk drive,
if you are trying to do software arrayed.

00:59:33.840 --> 00:59:35.500
This is where you're going to look.

00:59:35.500 --> 00:59:38.240
The infrastructure is
basically complete in DP4.

00:59:38.350 --> 00:59:40.470
We are, as I said,
continuing to do some bug

00:59:40.480 --> 00:59:43.540
fixes and some enhancements,
but what's there is basically

00:59:43.540 --> 00:59:44.890
what's going to be there.

00:59:45.080 --> 00:59:48.190
And you should be able to make progress.

00:59:48.870 --> 00:59:50.120
So it does have a user client.

00:59:50.310 --> 00:59:54.840
The stated mechanism for getting
at storage devices in Mac OS X is

00:59:54.910 --> 00:59:57.600
through /dev/disk whatever.

00:59:57.730 --> 01:00:00.910
This is the way the mechanism that
the file system is used to get at it.

01:00:00.910 --> 01:00:03.060
And it goes through
the Unix buffer cache,

01:00:03.100 --> 01:00:05.700
which provides a lot of
performance benefits.

01:00:05.790 --> 01:00:09.460
So that is what we consider
the user client for storage.

01:00:09.530 --> 01:00:12.900
That being said, all of the drivers,
all the storage drivers,

01:00:12.910 --> 01:00:14.500
are visible in the registry.

01:00:14.500 --> 01:00:16.250
And you can find them
and do get property,

01:00:16.250 --> 01:00:17.220
set property on them.

01:00:17.370 --> 01:00:21.950
But the way that you actually get data
on and off the disk is through /dev.

01:00:22.110 --> 01:00:25.100
It is HeaderDoc'd, it is open sourced,
and there are examples.

01:00:25.270 --> 01:00:28.370
So this family is actually in
very good shape and you should

01:00:28.380 --> 01:00:29.930
be able to make progress here.

01:00:31.030 --> 01:00:34.500
First thing, Friday morning,
for you early birds, 9:00 AM.

01:00:34.500 --> 01:00:36.150
We're going to go through this in depth.

01:00:36.420 --> 01:00:40.160
This session is pretty meaty and
really talks about the details of

01:00:40.160 --> 01:00:43.630
how you fit your code into the stack.

01:00:45.050 --> 01:00:47.750
HID family is not particularly far along.

01:00:47.920 --> 01:00:52.780
Human Interface Devices is
something that we support now,

01:00:52.780 --> 01:00:55.170
and we do a fairly good job of it,
but it's not as flexible

01:00:55.180 --> 01:00:56.150
as we'd like it to be.

01:00:56.160 --> 01:01:00.410
So what we have in there today is
temporary until HID Manager comes along.

01:01:00.430 --> 01:01:02.940
And for those of you
familiar with Input Sprocket,

01:01:02.940 --> 01:01:05.920
HID Manager is the evolution of that,
and there's going to be a

01:01:05.920 --> 01:01:06.930
session to talk about this.

01:01:06.940 --> 01:01:11.010
So since what we have today is
relatively primitive compared to

01:01:11.010 --> 01:01:14.030
what we want with HID Manager,
I believe we'll be able to

01:01:14.030 --> 01:01:15.470
provide backwards compatibility.

01:01:15.480 --> 01:01:18.360
So if you do any work here,
we'll see what we can do to allow

01:01:18.360 --> 01:01:21.400
you to continue to work even
once HID Manager comes along.

01:01:21.440 --> 01:01:22.970
We don't have a user client.

01:01:22.970 --> 01:01:25.480
It's not HeaderDoc'd yet,
but it is open sourced,

01:01:25.480 --> 01:01:28.460
and there are examples out on Darwin,
so if you want to poke around,

01:01:28.500 --> 01:01:31.650
I certainly encourage you to do that.

01:01:32.930 --> 01:01:35.800
This session,
Input Devices for Applications,

01:01:35.800 --> 01:01:38.570
I believe we'll be talking a
little bit about the direction

01:01:38.570 --> 01:01:40.540
we want to go with HID Manager.

01:01:41.100 --> 01:01:46.000
Graphics family, frame buffers,
2D accelerators, 3D accelerators.

01:01:46.000 --> 01:01:47.250
It's not quite finished.

01:01:47.260 --> 01:01:50.480
This is very complex,
and we've been working hard, as you know,

01:01:50.480 --> 01:01:53.940
on OpenGL, getting the performance
where we want it to be,

01:01:53.940 --> 01:01:56.190
or at least getting it to work,
and then starting to get

01:01:56.190 --> 01:01:57.420
performance where we want it to be.

01:01:57.420 --> 01:02:02.030
So this family has been
evolving to catch up with that.

01:02:02.060 --> 01:02:06.190
We do have support for NDRVs
to sort of bootstrap you.

01:02:06.200 --> 01:02:09.760
We don't intend for your graphics
NDRV to be your final solution

01:02:09.760 --> 01:02:12.630
because there's no acceleration there,
and I'm guessing customers are not

01:02:12.630 --> 01:02:15.000
going to rush out and buy graphics
cards that aren't accelerated.

01:02:15.000 --> 01:02:18.180
So you're going to need to do more work,
but at least you can get pixels on

01:02:18.220 --> 01:02:21.360
the screen very easily if you have
a reasonably well-behaved NDRV.

01:02:21.360 --> 01:02:24.660
So it's not there for you yet.

01:02:24.740 --> 01:02:26.490
It is open-sourced,
so you can poke around

01:02:26.490 --> 01:02:28.960
at the source code,
but we don't really have a

01:02:28.960 --> 01:02:30.850
DDK for you in graphics yet.

01:02:30.900 --> 01:02:34.480
So there are a number of sessions
here in graphics overview

01:02:34.480 --> 01:02:35.780
and OpenGL that would apply.

01:02:38.090 --> 01:02:39.940
And the audio family.

01:02:39.940 --> 01:02:44.360
We have a version in DP4 that's very
close to what we intend to ship.

01:02:44.500 --> 01:02:46.650
We know we're cleaning
it up a little bit.

01:02:46.690 --> 01:02:49.740
We went through an API review
that just missed getting

01:02:49.740 --> 01:02:53.270
the final version into DP4,
but we are going to get it into the

01:02:53.280 --> 01:02:54.840
KDK that we're shipping next month.

01:02:55.000 --> 01:03:01.570
So if you're into audio, look there,
look in DP4, and watch the developer

01:03:01.760 --> 01:03:03.950
website for updates.

01:03:04.020 --> 01:03:07.240
So it's not HeaderDoc'd yet,
but everything else is

01:03:07.240 --> 01:03:09.100
basically there for you to go.

01:03:10.550 --> 01:03:14.180
And there's two sessions on Friday that
will give you a lot more detail.

01:03:14.180 --> 01:03:19.330
In fact, the 177 audio drivers is going
to outline the architecture

01:03:19.340 --> 01:03:22.780
that we intend to be final,
not the architecture that's in DP4,

01:03:22.780 --> 01:03:25.220
which, as I said,
are similar but not identical.

01:03:25.220 --> 01:03:28.300
So this is the more
forward-looking approach.

01:03:28.300 --> 01:03:29.580
Network family.

01:03:29.710 --> 01:03:33.380
It's considered,
at least for Ethernet devices,

01:03:33.500 --> 01:03:35.300
as complete in DP4.

01:03:35.300 --> 01:03:38.300
In the future, we may consider adding
support for other interfaces,

01:03:38.300 --> 01:03:40.300
but this is not my decision.

01:03:40.300 --> 01:03:44.570
This is just a framework
mechanism that we can add them

01:03:44.570 --> 01:03:47.290
to as the demand appears or not.

01:03:47.570 --> 01:03:49.840
So there is a user client for networking.

01:03:49.840 --> 01:03:51.080
It's Sockets.

01:03:51.180 --> 01:03:55.410
There's a whole stack that lives
inside the kernel that acts as the

01:03:55.410 --> 01:03:57.850
primary client for network drivers.

01:03:57.870 --> 01:04:00.680
And Sockets is its mechanism
for communicating with apps.

01:04:00.680 --> 01:04:02.580
The network family is HeaderDoc'd.

01:04:02.580 --> 01:04:03.590
It is open sourced.

01:04:03.600 --> 01:04:04.980
And there are examples.

01:04:04.980 --> 01:04:07.580
We also have a cookbook
which is coming together.

01:04:07.580 --> 01:04:13.160
And in this session on Friday morning,
actually we'll be seeing the example

01:04:13.160 --> 01:04:17.480
driver and some discussion there about
how that cookbook is coming along.

01:04:17.480 --> 01:04:18.480
Thanks, everyone.

01:04:19.630 --> 01:04:21.920
PC Card family is under development.

01:04:21.920 --> 01:04:25.760
It's going to allow you to
write controller drivers for

01:04:25.860 --> 01:04:32.500
PC Card socket drivers and also
allow you to access PC Card devices.

01:04:32.890 --> 01:04:40.280
It is derived actually as one of the few
pieces of I/O Kit that actually has been

01:04:40.280 --> 01:04:42.120
imported from the open source community.

01:04:42.220 --> 01:04:45.700
It's being heavily recrafted to
fit into the way I/O Kit works,

01:04:45.720 --> 01:04:50.190
but it's leveraging heavily
what's gone on for Linux.

01:04:50.570 --> 01:04:52.540
So we don't intend to have
a user client for this.

01:04:52.540 --> 01:04:56.090
Again, for memory buses,
we tend not to want to expose those in

01:04:56.090 --> 01:04:57.920
the user space for security reasons.

01:04:57.940 --> 01:05:01.270
But as it's under development,
we don't have anything

01:05:01.270 --> 01:05:02.780
present for you yet.

01:05:04.660 --> 01:05:07.360
So imaging devices are
not part of I/O Kit.

01:05:07.360 --> 01:05:10.680
Printers and scanners and
cameras get to their hardware

01:05:10.680 --> 01:05:14.570
by talking through I/O Kit,
but they are user-land entities.

01:05:14.600 --> 01:05:17.850
So I recommend going to one or more
of these sessions to learn more

01:05:17.880 --> 01:05:23.090
about how software to drive imaging
devices gets plugged into the system.

01:05:24.100 --> 01:05:27.360
So in summary, I/O Kit is real.

01:05:27.400 --> 01:05:30.780
There are several companies, not Apple,
there are several companies out there

01:05:30.780 --> 01:05:32.880
that have working I/O Kit drivers today.

01:05:32.890 --> 01:05:34.740
I've seen them,
they haven't shipped them yet because

01:05:34.740 --> 01:05:38.710
they don't really have a platform
on which to ship them against,

01:05:38.930 --> 01:05:41.990
but you can expect to see them coming.

01:05:42.090 --> 01:05:45.350
Now, I/O Kit isn't finished by any means.

01:05:45.390 --> 01:05:47.340
There's more work to
be done in many areas,

01:05:47.350 --> 01:05:49.440
there's certainly more
documentation to be done.

01:05:49.540 --> 01:05:53.440
But I would recommend very strongly
that you look at what's there and

01:05:53.440 --> 01:05:56.280
figure out what you can do today,
because your competitors

01:05:56.350 --> 01:05:59.100
may be farther along,
and you really don't want to give

01:05:59.100 --> 01:06:02.040
them the opportunity to have an
uncontested market in the beginning

01:06:02.100 --> 01:06:03.840
of a new operating system launch.

01:06:03.920 --> 01:06:08.290
So I strongly recommend that you take
advantage of what is there today and

01:06:08.290 --> 01:06:10.520
make as much progress as you can.

01:06:11.280 --> 01:06:16.100
So on both DP3 and DP4,
all I/O goes through I/O Kit.

01:06:16.150 --> 01:06:18.300
It's all open sourced.

01:06:18.550 --> 01:06:19.300
I/O Kit is real.

01:06:19.330 --> 01:06:20.130
It's working.

01:06:20.190 --> 01:06:24.090
If you've got DP4 running on
your PowerBook in your lap,

01:06:24.160 --> 01:06:25.130
it's going through I/O Kit.

01:06:25.230 --> 01:06:28.620
So we can't stress enough that
it's there and really working,

01:06:28.620 --> 01:06:32.450
and you can make progress just like
Apple has and other companies have too.

01:06:33.310 --> 01:06:38.780
So with this, I'd like to hand the
mic over to John Signa.

01:06:38.780 --> 01:06:40.490
Thank you, Dean.

01:06:46.870 --> 01:06:49.680
We have just a few minutes to go
before we have to wrap this up.

01:06:49.810 --> 01:06:52.360
But beforehand,
what I wanted to do was talk a little

01:06:52.360 --> 01:06:57.860
bit about the resources that we are
providing and where you should go next.

01:06:57.940 --> 01:07:00.940
First of all, as Dean mentioned heavily
throughout his presentation,

01:07:00.940 --> 01:07:03.960
we do have the Darwin open
source available to you.

01:07:04.000 --> 01:07:07.090
While code isn't exactly the
same thing as documentation,

01:07:07.100 --> 01:07:10.660
it does give you very good
insights as to what's going on.

01:07:10.700 --> 01:07:14.510
And it gives you actually some very good
examples of what we're doing down there.

01:07:14.970 --> 01:07:19.310
As far as Mac OS X Developer Preview 4,
it's actually nice to be able

01:07:19.350 --> 01:07:21.390
to actually be at one of these
conferences and say the DDK is

01:07:21.490 --> 01:07:22.810
going to be shipping this summer.

01:07:22.820 --> 01:07:25.390
Well, it's actually nice to say
that it's shipping now.

01:07:25.400 --> 01:07:31.040
So, actually, on your CD,
you will find the I/O Kit DDK.

01:07:31.040 --> 01:07:34.000
You'll find in the documentation folder,
you'll find the tutorials,

01:07:34.000 --> 01:07:38.240
you'll find a bunch of the header
documentation and so forth.

01:07:38.260 --> 01:07:41.870
Please take a look at that
and get started with that.

01:07:42.600 --> 01:07:46.670
And finally, for future updates,
I'm going to refer you to check

01:07:46.670 --> 01:07:51.220
the Mac OS X developer page on the
Apple Developer Connection website.

01:07:51.220 --> 01:07:55.850
Any notifications about updates
or changes that we're doing,

01:07:55.850 --> 01:07:58.120
we'll have a notification
up there telling you how

01:07:58.220 --> 01:07:59.840
to get to the new packages.

01:08:03.640 --> 01:08:05.470
The one other resource
that we do have available,

01:08:05.470 --> 01:08:07.980
and I actually did want to spend
a little bit of time clarifying,

01:08:07.980 --> 01:08:12.500
is we will be hosting several
I/O Kit kitchens throughout between

01:08:12.500 --> 01:08:16.080
now and the time Mac OS X ships,
and actually even beyond that.

01:08:16.190 --> 01:08:20.360
I do want to set some expectations,
however.

01:08:20.390 --> 01:08:25.740
First, when we have I/O Kit kitchens,
they will be family-focused.

01:08:25.760 --> 01:08:30.380
Because the differences between
storage drivers and input device

01:08:30.390 --> 01:08:31.990
drivers are very different.

01:08:32.090 --> 01:08:35.550
You can't just put them in the same
room and expect to support them all.

01:08:35.640 --> 01:08:37.120
So they are going to
be very family-focused.

01:08:37.210 --> 01:08:43.050
We'll have a storage family kitchen,
we'll have a display card kitchen,

01:08:43.200 --> 01:08:45.190
along that line.

01:08:45.400 --> 01:08:48.300
Also,
we do have a limited number of attendees.

01:08:48.330 --> 01:08:51.670
So because of this, I can't just post a
notice out there saying,

01:08:51.680 --> 01:08:54.900
OK, everyone that wants to come
to the Display Card Kitchen,

01:08:54.900 --> 01:08:55.400
come.

01:08:55.450 --> 01:08:58.060
Because I'd get 6,000 responses saying,
yes, I want to be there.

01:08:58.130 --> 01:09:02.470
And we want to ensure that we
get some of the key players in

01:09:02.470 --> 01:09:06.230
there that are really important
to the majority of the customers.

01:09:06.310 --> 01:09:10.460
So what we'll be doing is actually
a balance between companies that are

01:09:10.530 --> 01:09:15.280
very prominent out in that particular
field and companies that we feel have

01:09:15.350 --> 01:09:18.050
interesting products that need to
come onto the platform very early.

01:09:18.170 --> 01:09:20.160
We're trying to support as
many developers as we can.

01:09:20.160 --> 01:09:23.010
However,
we do have to make some limitations.

01:09:23.130 --> 01:09:26.710
So the best way to find out
about I/O Kitchens is to actually

01:09:26.760 --> 01:09:30.960
just keep us informed of what
you're doing with your products.

01:09:31.020 --> 01:09:34.200
If we don't know what products
you are coming out with,

01:09:34.240 --> 01:09:36.220
we can't invite you to
the appropriate kitchens.

01:09:36.250 --> 01:09:38.810
I've already had it happen to me already
that one company came to me and said,

01:09:38.880 --> 01:09:40.200
oh, I wish I was at that kitchen.

01:09:40.200 --> 01:09:43.320
I was like, I didn't know you were doing
anything in that space.

01:09:43.380 --> 01:09:46.180
So please keep us informed
of what you're doing.

01:09:46.350 --> 01:09:51.340
And as we have appropriate kitchens,
we may be sending invitations for them.

01:09:52.570 --> 01:09:53.560
So I'm doing a little bit more.

01:09:53.560 --> 01:09:55.350
Normally we just put
up your email address,

01:09:55.420 --> 01:09:59.060
but I'm also putting up
my snail mail address.

01:09:59.120 --> 01:10:01.700
Because if you want,
please put me on your mail

01:10:01.700 --> 01:10:03.240
list for product literature.

01:10:03.370 --> 01:10:04.980
I do devour that stuff.

01:10:05.100 --> 01:10:08.760
I actually have a full
file cabinet full of it.

01:10:08.820 --> 01:10:11.720
And I do pass it along to engineering.

01:10:11.820 --> 01:10:16.040
So just keep us informed on what
you're doing with your products.

01:10:16.120 --> 01:10:18.640
And with that,
I'm going to go ahead and we're

01:10:18.770 --> 01:10:20.240
going to go into some Q&A.
WEBVTT

00:00:09.970 --> 00:00:11.330
Good morning.

00:00:11.370 --> 00:00:12.060
I'm Geoff Stahl.

00:00:12.060 --> 00:00:14.130
I'm going to be talking about
OpenGL and talking about using

00:00:14.140 --> 00:00:18.570
OpenGL for non-game applications,
even though a lot of this may be

00:00:18.570 --> 00:00:21.260
applicable to game applications.

00:00:21.330 --> 00:00:24.260
I'm manager of the DTS group
that handles OpenGL,

00:00:24.260 --> 00:00:28.720
handles 2D graphics, handles QuickTime,
Java, and printing.

00:00:28.850 --> 00:00:33.580
But the real people who do the real
work are here today also visiting,

00:00:33.690 --> 00:00:36.690
throwing things at me,
and making comments about

00:00:36.700 --> 00:00:38.080
things that get wrong later.

00:00:38.180 --> 00:00:43.090
John Stauffer is the engineering
manager for OpenGL group over here.

00:00:43.430 --> 00:00:49.510
Also, we have a number of guests from
ATI who do OpenGL drivers for us.

00:00:49.680 --> 00:00:55.550
Chris Bentley is sitting on the side,
Brian Raderman, and Jeremy Sammel working

00:00:55.560 --> 00:00:58.890
on the OS X work with ATI.

00:00:59.010 --> 00:01:00.980
We appreciate them being here.

00:01:01.100 --> 00:01:04.990
Let's jump right into the good stuff.

00:01:11.040 --> 00:01:13.040
Okay, again, as I said,
we're going to use OpenGL for

00:01:13.040 --> 00:01:15.050
non-full-screen immersive applications.

00:01:15.170 --> 00:01:20.080
So a lot of people look at OpenGL and
see Quake or see some of the full-screen

00:01:20.080 --> 00:01:21.900
immersive things that have been done.

00:01:21.900 --> 00:01:26.180
OpenGL works really well for maybe a
2D application that just needs to do

00:01:26.250 --> 00:01:29.900
some rendering or some drawing and
wants to have high-speed rendering,

00:01:29.900 --> 00:01:32.970
wants to have that acceleration,
and doesn't want to have to

00:01:32.970 --> 00:01:34.900
reinvent the wheel yourself.

00:01:34.900 --> 00:01:38.260
It takes advantage of the
fastest Macintosh pipeline.

00:01:38.260 --> 00:01:41.760
What this means is basically
that all your graphics there,

00:01:41.760 --> 00:01:45.900
even if it's a 2D texture map,
just a 2D image sent to the screen,

00:01:45.900 --> 00:01:48.400
is going to go through all the
acceleration layers and use

00:01:48.400 --> 00:01:49.880
all the accelerated context.

00:01:49.910 --> 00:01:54.380
So this allows you to get truly
high-performance graphics without

00:01:54.380 --> 00:01:58.700
having to get down into the bits
and figure out how to flush caches

00:01:58.700 --> 00:02:02.900
and what the bus bandwidth is
and how to keep that optimized.

00:02:02.900 --> 00:02:03.900
That's all done for you.

00:02:04.130 --> 00:02:08.290
Another thing about this is that they've
done a lot of hand-coding and hard work

00:02:08.290 --> 00:02:10.900
to take advantage of the Velocity Engine.

00:02:10.900 --> 00:02:13.840
There's significant improvement
you can see on OpenGL applications

00:02:13.920 --> 00:02:17.900
from a non-Velocity Engine to
a Velocity Engine machine,

00:02:17.900 --> 00:02:18.890
and this is for free.

00:02:18.890 --> 00:02:20.900
You just get this and it works great.

00:02:22.550 --> 00:02:25.870
It's good for 2D, 2.5D, and 3D.

00:02:25.940 --> 00:02:29.500
And for those of you unfamiliar
with how I'm using 2.5D,

00:02:29.660 --> 00:02:32.100
let's talk about maybe,
let's talk about a game

00:02:32.100 --> 00:02:32.730
actually in this case.

00:02:32.740 --> 00:02:34.500
Let's talk about something like Diablo.

00:02:34.500 --> 00:02:37.000
Diablo basically is a
sprite-like based game.

00:02:37.000 --> 00:02:40.850
They have a background,
they have orthographic or flat sprites

00:02:40.850 --> 00:02:42.490
that move around on top of this.

00:02:42.500 --> 00:02:46.310
OpenGL can be used for this kind of
thing or any other 2D kind of sprite

00:02:46.470 --> 00:02:50.490
game where there may be a depth,
there might be a stacking of things.

00:02:50.490 --> 00:02:51.500
Look at PowerPoint.

00:02:51.500 --> 00:02:55.500
PowerPoint is really a 2D thing,
but there's a sorting order to it.

00:02:55.500 --> 00:02:58.140
So you could do PowerPoint in OpenGL,
rendering the text,

00:02:58.140 --> 00:03:00.900
putting the things up there,
and you would get all the fades,

00:03:00.910 --> 00:03:03.440
transitions, rotations,
those kinds for free.

00:03:03.510 --> 00:03:05.490
Because it's all accelerated,
all in hardware.

00:03:05.490 --> 00:03:08.490
Once you get your image in there,
you can manipulate it however you want.

00:03:08.500 --> 00:03:12.500
So that's good for 2.5D, good for 2D,
good for some things like this.

00:03:12.500 --> 00:03:16.480
Some things it may not be
good for is vector drawing.

00:03:16.500 --> 00:03:19.190
For example, we have Quartz,
which is exceedingly

00:03:19.190 --> 00:03:22.500
good at handling PDFs,
handling text, handling vectors, scaling.

00:03:22.500 --> 00:03:26.450
OpenGL does scaling,
but the scaling is for a bitmap.

00:03:26.490 --> 00:03:29.050
So if you send a texture in,
it's going to scale

00:03:29.200 --> 00:03:30.470
based on that texture.

00:03:30.620 --> 00:03:33.560
So if your texture is 32 by 32,
a little icon there,

00:03:33.560 --> 00:03:36.450
and you blow it up to full screen size,
you're going to get a 32 by 32

00:03:36.550 --> 00:03:37.500
icon blown up to full screen size.

00:03:37.500 --> 00:03:39.500
It doesn't do anything special with it.

00:03:39.500 --> 00:03:42.500
Whereas Quartz may have
a bit of a texture.

00:03:42.500 --> 00:03:45.500
So you can have a text and a description
of the text in a vector format,

00:03:45.500 --> 00:03:47.500
which will then, when you blow it up,
keeps the vector format,

00:03:47.500 --> 00:03:49.500
keeps the smooth curves and lines.

00:03:49.500 --> 00:03:52.340
So OpenGL,
if one thing it doesn't really do well,

00:03:52.340 --> 00:03:56.720
is handle images in a vector format,
though the bases, the polygons,

00:03:56.730 --> 00:04:00.500
the points are all vectors,
and those scale infinitely, basically.

00:04:00.500 --> 00:04:02.500
And it's easy to add to
applications and code.

00:04:02.500 --> 00:04:06.910
You don't have to go take a
linear algebra class and go

00:04:06.910 --> 00:04:10.770
find some dark corner of some
library that has some dusty old

00:04:10.770 --> 00:04:12.480
volume of how to code in OpenGL.

00:04:12.570 --> 00:04:14.690
it's not that difficult.

00:04:14.910 --> 00:04:18.270
So let's kind of jump right
into things here and move ahead.

00:04:18.280 --> 00:04:21.820
What I'm going to do in this
session is I'm going to go through,

00:04:21.820 --> 00:04:23.150
I don't have a lot of slides.

00:04:23.160 --> 00:04:24.800
I have a lot of code I'm
kind of going to show you.

00:04:24.800 --> 00:04:25.730
We're going to go through some demos.

00:04:25.740 --> 00:04:30.040
You're going to see kind of one
ubiquitous spinning square demo a lot,

00:04:30.210 --> 00:04:32.630
but basically I'm going to use it
to show you how to manipulate kind

00:04:32.690 --> 00:04:34.520
of different constructs of OpenGL.

00:04:34.520 --> 00:04:39.040
One of the keys in this is I'm going to
be talking about AGL in a lot of ways

00:04:39.040 --> 00:04:42.340
and how to manipulate your buffers,
how to set it up so if you had

00:04:42.340 --> 00:04:45.260
text in one half of your window,
you could put OpenGL in another half,

00:04:45.360 --> 00:04:47.110
how to do some texture mapping and stuff.

00:04:47.140 --> 00:04:50.040
A lot of this is basically,
I'm going to demo in

00:04:50.040 --> 00:04:53.170
an OS 9 for simplicity,
but basically it's all carbon-based.

00:04:53.300 --> 00:04:55.320
Almost everything you
see here is carbonized,

00:04:55.350 --> 00:04:59.590
runs on 10, AGL works on 10,
and the stuff you see here

00:04:59.620 --> 00:05:01.500
almost all works on 10.

00:05:01.500 --> 00:05:03.250
Now I'm trying to think,
some of the full-screen

00:05:03.250 --> 00:05:06.410
stuff is not quite supported,
but that will be supported shortly.

00:05:06.420 --> 00:05:07.880
So what are we going to do?

00:05:07.910 --> 00:05:10.150
We're first going to
talk about pixel formats.

00:05:10.200 --> 00:05:13.110
I think I mentioned pixel formats
in some of my other OpenGL talks.

00:05:13.190 --> 00:05:14.210
We're going to talk about some of the,
I think I mentioned some

00:05:14.220 --> 00:05:15.720
of the caveats there,
especially when you're dealing

00:05:15.720 --> 00:05:18.820
with windows and multiple
monitors and multiple renders.

00:05:18.860 --> 00:05:21.220
We're going to talk about
using multiple windows.

00:05:21.280 --> 00:05:24.030
If I want to draw OpenGL, this window,
this window, and this window,

00:05:24.030 --> 00:05:25.350
maybe I want a CAD application.

00:05:25.360 --> 00:05:30.620
Do the perspective view and then four
orthographic views from the front,

00:05:30.620 --> 00:05:33.170
a side, and a back, or a front, a side,
and a top actually.

00:05:33.280 --> 00:05:35.840
In that case,
you can use multiple windows OpenGL.

00:05:36.010 --> 00:05:37.820
Just update them, mine update events,
real simple.

00:05:37.820 --> 00:05:40.660
It works right in an event loop,
works great for good stuff.

00:05:40.680 --> 00:05:43.700
Subwindows, combining 2D and 3D.

00:05:43.720 --> 00:05:46.130
How actually do you get
2D and 3D on a window?

00:05:46.180 --> 00:05:49.030
If you've played with OpenGL at all,
one thing you'll see is if you

00:05:49.030 --> 00:05:52.020
draw 2D and then you draw some
OpenGL and call swap buffers,

00:05:52.020 --> 00:05:53.260
it's going to blow away that 2D.

00:05:53.300 --> 00:05:55.840
It does not know anything
about that drawing.

00:05:55.840 --> 00:05:58.420
It does not know about how you,
that you had something there.

00:05:58.420 --> 00:06:01.040
It does not know about
compositing to your background.

00:06:01.040 --> 00:06:04.180
So you have to consider that,
that the area you're updating

00:06:04.180 --> 00:06:08.330
in OpenGL is going to take over
basically that area that you set up.

00:06:08.340 --> 00:06:10.750
Talk about some basic font handling.

00:06:10.820 --> 00:06:13.380
Then we'll talk about
physical simulation.

00:06:13.380 --> 00:06:13.700
I have a couple of things
I want to talk about.

00:06:13.710 --> 00:06:15.100
I want to talk about a couple of
demos and talk about just using

00:06:15.100 --> 00:06:16.520
OpenGL for physical simulation.

00:06:16.520 --> 00:06:18.600
Nothing really, really big.

00:06:18.660 --> 00:06:20.060
There's no real good answer.

00:06:20.060 --> 00:06:23.340
I can't give an answer for the
world on physical simulation.

00:06:23.340 --> 00:06:24.770
There's a lot of text on that.

00:06:24.840 --> 00:06:26.620
But how to use OpenGL,
some of the considerations.

00:06:26.620 --> 00:06:28.650
Orthographic projections.

00:06:28.660 --> 00:06:30.880
Orthographic projection
is kind of a big word.

00:06:30.900 --> 00:06:33.540
And you say it real
quick and someone says,

00:06:33.570 --> 00:06:36.440
"What the heck are you talking
about?" Real simple is that for like

00:06:36.450 --> 00:06:39.740
an orthographic projection might be
something that puts the text on the

00:06:39.750 --> 00:06:43.680
screen while behind that you have
a perspective view of orthography.

00:06:43.680 --> 00:06:45.340
So, you're going to have a walk through.

00:06:45.340 --> 00:06:47.880
So, as you're walking through
your virtual library,

00:06:47.880 --> 00:06:50.240
you want to identify what room you're in.

00:06:50.240 --> 00:06:51.620
And you want to do that in text.

00:06:51.810 --> 00:06:54.510
Well, you would switch to an orthographic
projection which allows you to

00:06:54.510 --> 00:06:55.840
nicely place your text on the screen.

00:06:55.840 --> 00:06:59.460
It wouldn't, you know,
do your-- do any manipulation

00:06:59.460 --> 00:07:01.240
or any perspective on that text.

00:07:01.300 --> 00:07:03.780
And then we'll talk about
texture mapping at the end.

00:07:03.780 --> 00:07:04.480
Real simple.

00:07:04.480 --> 00:07:07.180
I'm going to show you how to
get textures into the Macintosh,

00:07:07.180 --> 00:07:08.300
how to texture map them.

00:07:08.380 --> 00:07:10.180
So, you can get some of
the basic stuff going,

00:07:10.180 --> 00:07:13.160
which is kind of the
crux of doing 2D and 3D.

00:07:16.190 --> 00:07:18.050
Okay, pixel format considerations.

00:07:18.060 --> 00:07:24.900
AGL Choose Pixel Format is how you
set up basically your kind of drawing,

00:07:24.900 --> 00:07:27.060
I want to say context,
but that's not the right word.

00:07:27.060 --> 00:07:33.060
AGL Choose Pixel Format sets
up the basics of pixel format.

00:07:33.060 --> 00:07:38.320
And what it handles is it handles
things like RGBA displays,

00:07:38.320 --> 00:07:39.240
so red, green, blue.

00:07:39.240 --> 00:07:42.030
It handles whether you
want a depth buffer or not.

00:07:42.040 --> 00:07:45.790
It handles whether you require
an accelerated context or not.

00:07:46.110 --> 00:07:50.250
And also handles if you want
to choose a specific renderer.

00:07:50.280 --> 00:07:54.410
And let me pull up an example of
some of these and we'll look at it.

00:07:54.460 --> 00:07:57.750
Some of the caveats here are
handling multiple displays,

00:07:57.760 --> 00:07:59.400
handling movable windows,
and I'll talk about some

00:07:59.410 --> 00:08:00.310
special considerations.

00:08:00.400 --> 00:08:03.240
Actually, let me move forward a slide.

00:08:06.330 --> 00:08:08.760
Okay, we've got all kinds of
things on the computer here,

00:08:08.760 --> 00:08:10.960
and this is going to
be a real simple one.

00:08:10.960 --> 00:08:15.340
I need to set my font size here.

00:08:32.210 --> 00:08:35.990
What we have here is talking
about some pixel formats.

00:08:36.050 --> 00:08:40.900
I brought this up so it's easier to
talk about to see some examples of them.

00:08:42.190 --> 00:08:45.100
Basically, in almost all cases,
if you want to do hardware acceleration,

00:08:45.100 --> 00:08:47.750
you want to do red, green, blue,
and alpha.

00:08:47.840 --> 00:08:51.630
8-bit is supported in software,
but almost no hardware right

00:08:51.640 --> 00:08:53.100
now supports 8-bit context.

00:08:53.100 --> 00:08:54.660
So if you want to do
hardware acceleration,

00:08:54.740 --> 00:08:56.780
do high-speed graphics,
you want to do red, green, blue,

00:08:56.780 --> 00:08:57.030
and alpha.

00:08:57.100 --> 00:09:01.100
Then we're talking about AGL render ID.

00:09:01.100 --> 00:09:03.940
AGL render ID says,
I want a specific render.

00:09:04.240 --> 00:09:06.100
And you can ask for any
render that we enumerate.

00:09:06.100 --> 00:09:09.100
If you want a 3D effects render,
you can ask for a 3D effects render.

00:09:09.100 --> 00:09:12.100
In this case,
I want to say generic render ID.

00:09:12.100 --> 00:09:14.090
But this says,
I want the software render.

00:09:14.090 --> 00:09:17.590
The reason I put this up here is
so you know that one good test you

00:09:17.740 --> 00:09:21.240
can do if you're working OpenGL and
you're not getting things right,

00:09:21.240 --> 00:09:24.050
and this driver is really bad,
it's buggy,

00:09:24.140 --> 00:09:27.100
it's not drawing my stuff right,
go to the software render.

00:09:27.100 --> 00:09:28.970
Check out and see what
the software render says.

00:09:28.970 --> 00:09:30.720
If the software render
renders it correctly,

00:09:30.720 --> 00:09:32.090
then it may be a bug on our part.

00:09:32.090 --> 00:09:35.170
If the software render
renders it incorrectly,

00:09:35.170 --> 00:09:38.090
then it probably is
something in your code.

00:09:38.100 --> 00:09:40.400
So I have a challenge,
and this challenge is for,

00:09:40.400 --> 00:09:43.100
I put it out pretty much every
time I talk about OpenGL.

00:09:43.100 --> 00:09:46.050
I have tremendous confidence in
John Stauffer and his ability to

00:09:46.170 --> 00:09:49.100
code outstanding implementation
of the software render.

00:09:49.100 --> 00:09:53.750
So if the software render you find is not
compliant with the OpenGL specification,

00:09:53.780 --> 00:09:56.100
send what you think is not compliant.

00:09:56.100 --> 00:09:56.630
We'll look at it.

00:09:56.710 --> 00:09:58.100
If you're correct,
I'll send you a t-shirt.

00:09:58.100 --> 00:10:01.730
Right now I'm doing the OpenGL t-shirts,
but I'll find something

00:10:01.730 --> 00:10:03.100
if I run out of those.

00:10:03.100 --> 00:10:05.100
But I haven't given out a t-shirt yet.

00:10:05.100 --> 00:10:07.100
So that's the challenge.

00:10:07.100 --> 00:10:10.560
So if you think you have a
non-compliance in the software render,

00:10:10.560 --> 00:10:14.050
send me a note, and if you're right,
I'll send you a t-shirt.

00:10:14.100 --> 00:10:15.530
.

00:10:16.950 --> 00:10:21.280
The AGL render ID should
be followed by a render ID,

00:10:21.280 --> 00:10:22.860
and that's in the AGL header files.

00:10:22.860 --> 00:10:25.980
The AGL render generic
ID says software render,

00:10:25.980 --> 00:10:26.600
basically.

00:10:26.640 --> 00:10:29.200
So AGL generic render ID says
I want the software render.

00:10:29.200 --> 00:10:30.780
That generic render is
the software render.

00:10:31.170 --> 00:10:32.900
There's another trick to do this.

00:10:32.900 --> 00:10:35.120
If you want to go to software
render on a pre-compiled code,

00:10:35.230 --> 00:10:36.710
you just want to check out,
see how it runs,

00:10:37.140 --> 00:10:43.900
pull out the ATI or 3DFX actual
OpenGL accelerators or OpenGL components

00:10:43.900 --> 00:10:45.760
out of your system folder,
and the only renderer left

00:10:45.760 --> 00:10:46.900
will be the software renderer.

00:10:46.900 --> 00:10:48.900
That's another test you can do.

00:10:48.900 --> 00:10:53.180
If I want to get any render,
basically I'm going to say RGBA,

00:10:53.180 --> 00:10:56.900
AGL all renders, AGL double buffer,
and none.

00:10:56.900 --> 00:10:59.360
The double buffer means I actually
want a double buffer surface,

00:10:59.360 --> 00:11:00.900
which in almost all cases you do.

00:11:00.900 --> 00:11:03.910
AGL all renders,
what does that really tell you?

00:11:03.910 --> 00:11:06.630
Why is that different
than just leaving it out?

00:11:06.960 --> 00:11:09.900
AGL all renders will accept
non-compliant renders.

00:11:09.900 --> 00:11:12.900
For example,
the Rage 2 shipped on the original

00:11:12.900 --> 00:11:12.900
Rev AI Max is a non-OpenGL component.

00:11:12.900 --> 00:11:12.900
The AGL render ID should be followed by
a render ID saying AGL generic render

00:11:12.900 --> 00:11:12.900
ID says I want the software render.

00:11:12.900 --> 00:11:12.900
The AGL render ID says
I want the software render.

00:11:12.900 --> 00:11:15.020
The Rage 2 shipped on the
original Rev AI Max is a

00:11:15.020 --> 00:11:16.290
non-OpenGL compliant renderer.

00:11:16.380 --> 00:11:18.900
In that case, this will select that.

00:11:19.050 --> 00:11:24.280
Star Wars Racer wanted
to run on iMac Rev A's,

00:11:24.280 --> 00:11:26.580
so they would use a string
such as this to make sure they

00:11:26.700 --> 00:11:26.900
would be able to select that.

00:11:26.930 --> 00:11:29.190
Otherwise,
it will refuse to select any hardware

00:11:29.190 --> 00:11:30.900
accelerator render in that case.

00:11:31.870 --> 00:11:34.700
OpenGL hardware compliant renderer,
same as the above string basically,

00:11:34.700 --> 00:11:39.230
but I got rid of the HL_AllRenderers,
hardware accelerators,

00:11:39.230 --> 00:11:40.700
and added HL_Accelerated.

00:11:40.890 --> 00:11:42.620
Here's a key that I talked
about moving windows.

00:11:42.620 --> 00:11:45.760
If you have a window
that you're using OpenGL,

00:11:45.760 --> 00:11:48.700
and you're moving the window around,
and you ask for an accelerated renderer,

00:11:48.700 --> 00:11:50.690
it's going to fail.

00:11:50.800 --> 00:11:54.700
Why does it fail?

00:11:54.700 --> 00:11:59.700
It fails on multiple screen displays
because we coded a fallback case,

00:11:59.720 --> 00:12:03.700
so when the window spans two screens,
you go to the software renderer.

00:12:03.700 --> 00:12:05.690
So it gives you rendering
while you span two screens.

00:12:05.690 --> 00:12:09.700
So if I have a 3D effects
card in one of my slots,

00:12:09.700 --> 00:12:12.700
and I have an ATI card in the other slot,
and I drag across,

00:12:12.700 --> 00:12:17.430
if you use a string such as this,
I'm sorry,

00:12:17.430 --> 00:12:19.690
in most cases you'll get ATI rendering.

00:12:19.730 --> 00:12:20.690
You'll get a lot of rendering.

00:12:20.710 --> 00:12:21.330
So if I have a 3D effect
card in one of my slots,

00:12:21.330 --> 00:12:21.700
it moves across.

00:12:21.700 --> 00:12:24.700
When it's between screens,
you get the software renderer.

00:12:24.700 --> 00:12:28.700
When it's back on the 3D effects display,
it'll get 3D effects renderer.

00:12:28.700 --> 00:12:32.600
And one interesting thing is you can
easily check if you use GL_GitString,

00:12:32.960 --> 00:12:35.670
check for the manufacturer
and the version string,

00:12:35.790 --> 00:12:39.690
you'll get either the ATI,
the Apple software, or the 3D effects.

00:12:39.710 --> 00:12:41.660
So you can identify what
renderer you're actually on.

00:12:41.710 --> 00:12:45.710
If I use this string right
here with the AVL_Accelerated,

00:12:45.710 --> 00:12:48.730
and I had a movable window,
so I basically say I want

00:12:48.730 --> 00:12:51.110
it for all my monitors,
and it'll fail because it

00:12:51.110 --> 00:12:54.680
says I can't handle the case
where you're between screens.

00:12:54.700 --> 00:12:57.700
It's pretty logical,
but it may be a little caveat.

00:12:57.700 --> 00:12:59.700
Say, hey, why is this never working?

00:12:59.700 --> 00:13:02.270
I have AGL_Accelerated,
and I can never get an accelerated

00:13:02.270 --> 00:13:03.690
context with my multiple screens.

00:13:03.700 --> 00:13:05.590
So that's something I've
run into with people.

00:13:05.700 --> 00:13:07.590
So that's a little note on that.

00:13:07.700 --> 00:13:11.700
ATI compliant renderer, if I want an ATI,
again, AGL_Renderer_ID,

00:13:11.700 --> 00:13:13.700
add an AGL_Renderer_ATI_ID.

00:13:13.700 --> 00:13:19.530
And if I wanted to get
an OpenGL compliant,

00:13:20.110 --> 00:13:25.140
ATI Render Hardware Accelerated Render
I would add the AGL Accelerated.

00:13:25.270 --> 00:13:26.840
So what does this look like?

00:13:26.960 --> 00:13:28.540
Real simple,
one of the simple ways to do it,

00:13:28.550 --> 00:13:31.790
you can do it like above or you can
just add the attributes in order,

00:13:31.860 --> 00:13:34.150
RGBA, double buffered accelerated.

00:13:34.270 --> 00:13:36.230
In here, in this case,
I'm indicating that

00:13:36.310 --> 00:13:37.360
I want a depth buffer.

00:13:37.470 --> 00:13:39.840
One key here is with the depth buffer,
if you actually do

00:13:39.840 --> 00:13:41.730
something that has depth,
if you're going to have

00:13:41.860 --> 00:13:44.850
back-to-front sorting,
you need to set a depth buffer up.

00:13:44.980 --> 00:13:47.610
You can turn on depth sorting,
you can do everything you want,

00:13:47.620 --> 00:13:50.020
you can turn on Z value,
you can do everything you

00:13:50.330 --> 00:13:51.890
possibly can in your GL code.

00:13:51.990 --> 00:13:55.800
If you don't set up a depth size and
actually have that depth buffer there,

00:13:56.030 --> 00:13:57.060
it will never do any depth sorting.

00:13:57.060 --> 00:13:58.840
You'll be like, why is this not working?

00:13:58.960 --> 00:14:00.250
Because you don't have a depth buffer.

00:14:00.270 --> 00:14:01.940
GL is like that in a lot of ways.

00:14:02.030 --> 00:14:05.250
You get down a road and you're sure
you got it right and you forgot to

00:14:05.260 --> 00:14:07.160
enable a mode or set up a depth buffer.

00:14:07.250 --> 00:14:08.560
So that's a little caveat there.

00:14:08.560 --> 00:14:12.270
So you definitely want to do these two
lines if you want to use depth sorting.

00:14:12.400 --> 00:14:14.820
And then AGL none terminates all these.

00:14:14.970 --> 00:14:16.440
So.

00:14:25.300 --> 00:14:27.560
Let's talk about multiple windows,
which is really, for me,

00:14:27.560 --> 00:14:33.240
the main difference between a full-screen
immersive and a non-immersive application

00:14:33.310 --> 00:14:37.860
is handling windowed cases and combining
2D and 3D together and combining text.

00:14:37.900 --> 00:14:42.570
For multiple windows,
we'll talk about-- oh, I'm sorry.

00:14:43.390 --> 00:14:43.750
There we go.

00:14:43.920 --> 00:14:46.800
We'll talk about handling
multiple pixel formats,

00:14:46.870 --> 00:14:47.800
what that means.

00:14:48.070 --> 00:14:50.890
We'll handle multiple contexts,
multiple drawables,

00:14:51.000 --> 00:14:54.540
and considerations such
as AGL up-fate context.

00:14:54.640 --> 00:14:56.300
That should be update context, my bad.

00:14:56.300 --> 00:14:57.100
I'm sorry.

00:14:57.230 --> 00:14:58.260
And resizing.

00:14:58.400 --> 00:15:01.240
Multiple pixel formats,
we've talked about that.

00:15:01.240 --> 00:15:04.270
Pixel formats set up whether
you have a depth buffer,

00:15:04.380 --> 00:15:07.940
whether you're accelerated or not,
what render you may be using,

00:15:07.940 --> 00:15:09.300
those kind of things.

00:15:09.500 --> 00:15:12.260
Multiple context
encapsulates an OpenGL state.

00:15:12.260 --> 00:15:15.300
A drawable is actually a window.

00:15:15.300 --> 00:15:18.190
And when we talk about considerations,
we'll talk about how that

00:15:18.190 --> 00:15:20.290
relates to all the above.

00:15:20.300 --> 00:15:25.020
Let me actually go through this.

00:15:35.210 --> 00:15:38.330
I have my little cheat sheet here.

00:15:38.330 --> 00:15:40.100
So what are we going to do?

00:15:40.100 --> 00:15:42.100
I'm going to go through a
lot of coding examples here.

00:15:42.100 --> 00:15:44.100
I talked about this as non-gaming.

00:15:44.100 --> 00:15:45.940
So what do we have?

00:15:45.940 --> 00:15:49.060
I want to run the ubiquitous game app.

00:15:49.300 --> 00:15:50.100
So this is the app.

00:15:50.100 --> 00:15:52.480
You'll see this kind of thing
all over the demos and hopefully

00:15:52.480 --> 00:15:54.020
the projector will think awesome.

00:15:54.020 --> 00:15:58.010
So this is our game app.

00:15:58.100 --> 00:16:43.900
[Transcript missing]

00:16:44.300 --> 00:16:46.720
There's really no,
since a pixel format is

00:16:46.720 --> 00:16:51.130
your basically lowest level,
everything needs to set up to that,

00:16:51.400 --> 00:16:54.800
there's really no reason to have more
than one pixel format per context.

00:16:54.980 --> 00:16:58.170
Because when you create a context,
you're required to supply a pixel format.

00:16:58.490 --> 00:17:01.800
You'd have to destroy the context
and pass in a new pixel format.

00:17:01.800 --> 00:17:03.400
So there's no changing a pixel format.

00:17:03.400 --> 00:17:07.000
You can't maintain a depth buffered
one and a non-depth buffered one.

00:17:07.300 --> 00:17:10.550
If you want to make that kind of change,
you're going to have to

00:17:10.550 --> 00:17:13.380
recreate the context,
create a second context,

00:17:13.380 --> 00:17:15.900
or recreate the pixel format.

00:17:15.900 --> 00:17:18.950
You can't go through and have pixel
formats swapping to multiple contexts.

00:17:19.070 --> 00:17:20.890
So that's the thought,
that if you do have something you want

00:17:20.890 --> 00:17:22.770
depth buffered and not depth buffered,
you're going to have to

00:17:22.770 --> 00:17:27.290
work on multiple contexts,
not multiple pixel formats.

00:17:27.420 --> 00:17:30.530
Okay, so now let's talk about
multiple contexts.

00:17:31.450 --> 00:17:33.880
So, multiple contexts,
we'll pull up on my

00:17:33.880 --> 00:17:36.400
little application here.

00:17:36.400 --> 00:17:39.610
I'm going to have to, again,
I'm going to resize this to

00:17:39.710 --> 00:17:44.380
make sure that everyone can see
this once I bring up the file.

00:17:44.870 --> 00:17:47.640
Basically, multiple contexts handle
different GL settings,

00:17:47.640 --> 00:17:48.900
basically the state of GL.

00:17:48.900 --> 00:17:51.860
You can say, hey,
I want to draw with shaded,

00:17:51.860 --> 00:17:53.380
I want to draw with line version.

00:17:53.410 --> 00:17:59.790
So what we're going to look at is just
this little section right here of code.

00:17:59.800 --> 00:18:01.230
Let me make this bigger for you.

00:18:05.400 --> 00:18:09.530
So this works.

00:18:10.020 --> 00:18:15.140
What we're going to look at here
is setting up a couple contexts.

00:18:15.140 --> 00:18:17.560
I have two rectangles at the top here.

00:18:17.560 --> 00:18:19.670
They're

00:18:27.100 --> 00:18:27.500
So, in this case,
they're both different sized rectangles.

00:18:27.500 --> 00:18:27.630
They have a window.

00:18:27.630 --> 00:18:27.750
I go through here.

00:18:27.750 --> 00:18:32.100
I set up my pixel formats,
and I use my setup GL sample code

00:18:32.100 --> 00:18:34.100
and call build GL from window.

00:18:34.100 --> 00:18:36.100
So, I build a GL context there.

00:18:36.100 --> 00:18:38.100
You can see that's context number one.

00:18:38.370 --> 00:18:41.110
Then, basically,
do a similar thing on this side.

00:18:41.270 --> 00:18:43.100
Create a window up here.

00:18:43.300 --> 00:18:47.700
Set up some similar settings.

00:18:48.160 --> 00:18:50.100
You notice this line right in here.

00:18:50.100 --> 00:18:54.440
For draggable windows, as I said before,
we can't use AGL accelerated because

00:18:54.590 --> 00:18:57.280
what happens with draggable windows,
you're saying you want them

00:18:57.440 --> 00:18:59.100
across multiple monitors.

00:18:59.100 --> 00:19:03.870
If it ends up between two monitors,
you're going to have that fail because it

00:19:03.870 --> 00:19:06.560
can't fall back to the software render.

00:19:06.880 --> 00:19:10.280
In most cases, you will actually get
an accelerated context.

00:19:10.430 --> 00:19:13.600
There's very few cases you won't
if you have an acceleration card.

00:19:13.600 --> 00:19:15.930
So usually I just eliminate
AGEL Accelerate and I should get

00:19:15.930 --> 00:19:17.920
an accelerated context with that.

00:19:18.270 --> 00:19:21.150
Then I build the Gelfand window.

00:19:21.240 --> 00:19:24.640
And what I did here was,
on the second context, I said,

00:19:24.640 --> 00:19:26.790
really I want this one to be flat shaded.

00:19:26.960 --> 00:19:29.000
So if we run this,

00:19:33.470 --> 00:19:33.900
Very simple.

00:19:33.900 --> 00:19:34.800
I have two contexts.

00:19:34.940 --> 00:19:36.600
One's a draggable window.

00:19:36.640 --> 00:19:37.890
One's a normal window.

00:19:37.970 --> 00:19:43.730
And this window over here,
exactly the same drawing routine.

00:19:43.950 --> 00:19:45.850
Calling the exact same thing,
so the code paths for

00:19:45.850 --> 00:19:47.220
each is exactly the same.

00:19:47.610 --> 00:19:52.690
All I'm doing in this case is that this
context here is set up for flat shading.

00:19:52.820 --> 00:19:55.430
If I take it out,
then it would just look exactly

00:19:55.430 --> 00:19:57.000
the same as the first one.

00:19:57.000 --> 00:19:58.870
We can see that.

00:20:01.090 --> 00:20:05.390
Normally the shade
model is smooth shaded,

00:20:05.510 --> 00:20:09.890
so I'll go back to the
default version of that.

00:20:13.410 --> 00:20:18.600
This session covers
handling multiple contexts,

00:20:18.600 --> 00:20:25.110
combining 2D and 3D graphics,
and using the orthographic

00:20:25.110 --> 00:20:31.980
projection to create accelerated
2D graphics in any window.

00:20:32.600 --> 00:20:36.830
: In the next slide,
we will see how the fixed window

00:20:36.830 --> 00:20:41.450
is projected into the hallway,
and the actual line view

00:20:41.560 --> 00:20:43.390
of the fixed window.

00:20:43.470 --> 00:20:48.020
The fixed window is the
working copy of the actual line

00:20:48.020 --> 00:20:50.640
view of the actual building.

00:20:50.640 --> 00:20:56.620
The fixed window is the one that
shows the actual rendered image.

00:20:56.620 --> 00:20:56.620
This is the kind of thing you
would use multiple contexts for.

00:20:58.590 --> 00:20:59.860
Okay, so what else do I got?

00:20:59.860 --> 00:21:03.680
Okay, so I did flatline drawing that one,
so we're done there.

00:21:03.740 --> 00:21:06.050
Let's move on.

00:21:07.130 --> 00:21:08.360
Let's look at multiple drawables.

00:21:08.400 --> 00:21:10.520
So in this case,
multiple drawables is the same

00:21:10.520 --> 00:21:13.000
context with multiple windows.

00:21:13.040 --> 00:21:16.000
Maybe you want the exact
same thing to show,

00:21:16.000 --> 00:21:18.110
but you want it to show
in different windows,

00:21:18.210 --> 00:21:20.160
in a different view,
you just want to rotate a camera,

00:21:20.160 --> 00:21:24.000
and you want all basically the
GL settings will always be linked.

00:21:24.000 --> 00:21:28.300
So if you set one to a different setting,
both of them will link together,

00:21:28.350 --> 00:21:32.160
but it gives you different views
or viewpoints on the same scene,

00:21:32.190 --> 00:21:33.000
we'll say.

00:21:33.040 --> 00:21:39.120
So, let's get back to another simple
spinning square application here.

00:21:41.870 --> 00:21:47.300
And in this one,
let's just run this and see what we get.

00:21:47.500 --> 00:21:51.560
So I have two windows, same size,
exactly the same view,

00:21:51.790 --> 00:21:53.800
same view of the world,
everything's the same.

00:21:53.930 --> 00:21:55.780
So let me prove that to you.

00:21:55.870 --> 00:21:58.180
So let's go back into our...

00:22:08.800 --> 00:22:18.300
[Transcript missing]

00:22:18.480 --> 00:22:20.140
Let's say,
let's make the drawables actually

00:22:20.220 --> 00:22:23.060
a different size instead of
making them the same size,

00:22:23.170 --> 00:22:25.100
showing that they're actually
drawing exactly the same thing

00:22:25.100 --> 00:22:27.870
unless I do something to affect that.

00:22:32.360 --> 00:22:33.100
There you go.

00:22:33.130 --> 00:22:35.940
So in this case, they're actually,
since they're drawable setup

00:22:35.940 --> 00:22:38.800
on the back window first,
the front window thinks it's basically

00:22:38.800 --> 00:22:44.130
the same size as the back window,
and just draws exactly the same thing.

00:22:44.260 --> 00:22:47.760
The question is, how do we fix this?

00:22:47.830 --> 00:22:49.450
So that's basically
the point of all this,

00:22:49.460 --> 00:22:52.600
is if you're handling multiple
drawables with a single context,

00:22:52.630 --> 00:22:55.040
what do you need to do for that?

00:22:55.050 --> 00:22:57.850
And what you need to do is
you need to make sure that you

00:22:57.850 --> 00:22:59.900
set the viewport correctly.

00:22:59.910 --> 00:23:03.900
And to set the viewport,
we'll scroll down a

00:23:03.900 --> 00:23:04.740
little bit in the code,
into our drawing routine.

00:23:04.740 --> 00:23:06.660
This is a simple drawing routine.

00:23:06.670 --> 00:23:10.860
Basically what I'm doing here is I'll
use these two lines of code here.

00:23:10.860 --> 00:23:12.800
What this does

00:23:13.280 --> 00:23:14.830
As you notice, this is the due update.

00:23:14.950 --> 00:23:17.100
So I used to have a standard Mac program.

00:23:17.100 --> 00:23:19.400
Every time I update,
I'm drawing GL again.

00:23:19.490 --> 00:23:23.820
In this case, I use GL viewport.

00:23:34.650 --> 00:23:34.650
GeoViewport takes the X and Y offset and
then also takes the width and height.

00:23:34.650 --> 00:23:34.650
And in this case I did screw up again.

00:23:34.650 --> 00:23:34.650
Wow, I'm not doing very well here.

00:23:34.650 --> 00:23:34.650
It should be bottom.

00:23:43.970 --> 00:23:46.910
and if we compile this,
you'll see that we should

00:23:46.910 --> 00:23:50.660
now have the drawable size to
the appropriate window sizes.

00:23:52.780 --> 00:23:53.530
Okay, there we go.

00:23:53.540 --> 00:23:56.040
So we're back at something
we kind of expected.

00:23:56.040 --> 00:24:00.000
And if we do like a window size here,
it actually keeps the

00:24:00.050 --> 00:24:01.570
viewport to the window.

00:24:01.680 --> 00:24:04.660
So another thought here is one
thing you'll notice when you're

00:24:04.690 --> 00:24:05.810
working with OpenGL is that

00:24:05.890 --> 00:24:08.290
If you're doing something that's
supposed to look realistic,

00:24:08.290 --> 00:24:10.690
and someone does that to your window,
you realize that just

00:24:10.690 --> 00:24:13.300
by setting the viewport,
OpenGL is going to scale everything.

00:24:13.300 --> 00:24:16.620
OpenGL thinks of everything
as basically zero to one.

00:24:16.750 --> 00:24:17.840
Zero to one.

00:24:17.990 --> 00:24:20.540
And so what happens is,
when you scale things

00:24:20.540 --> 00:24:24.300
in a very small space,
if I scale things like that,

00:24:24.300 --> 00:24:25.830
you get definitely...

00:24:26.100 --> 00:24:28.460
OpenGL says, "Hey, I can do this.

00:24:28.460 --> 00:24:30.660
I can fill this rectangle,
whatever you provide me,

00:24:30.660 --> 00:24:37.050
with that right size of your
drawing." And at that point,

00:24:37.150 --> 00:24:37.890
it'll just scale.

00:24:37.900 --> 00:24:39.400
So there's ways to avoid that.

00:24:39.400 --> 00:24:42.100
You can set your aspect ratios and
you can check that you're so instead

00:24:42.100 --> 00:24:45.650
of really smishing your viewing up,
you're actually just

00:24:45.650 --> 00:24:47.080
taking a piece of it out.

00:24:47.100 --> 00:24:51.650
So, and one more thing is to,
let me prove that actually

00:24:51.650 --> 00:24:55.410
this is actually a separate,
you know, draw,

00:24:55.410 --> 00:24:57.100
and this is using the same context.

00:24:57.100 --> 00:25:00.920
So if it's using the same context,
you would think any OpenGL state

00:25:00.920 --> 00:25:03.060
change to that contact,
anything affecting the state

00:25:03.080 --> 00:25:04.040
would change both of these.

00:25:04.100 --> 00:25:07.310
So let's make a state change here.

00:25:12.360 --> 00:25:14.760
So, same lines of code
I used in the last one.

00:25:14.760 --> 00:25:16.900
In the last one, I had two contexts,
I changed lines of code,

00:25:16.900 --> 00:25:18.100
they operate independently.

00:25:18.100 --> 00:25:20.600
In this case, again,
this is something you may want to

00:25:20.610 --> 00:25:23.130
have two views with the same context,
two views of the same scene.

00:25:23.380 --> 00:25:25.300
So we should get basically
two views of the same scene.

00:25:25.300 --> 00:25:29.300
So the scene when it's
drawn should look the same.

00:25:29.300 --> 00:25:31.040
Oh, there we go.

00:25:31.140 --> 00:25:31.720
Flat shaded lines.

00:25:31.720 --> 00:25:35.680
And so, as we saw,
when we change the context variables,

00:25:35.750 --> 00:25:38.050
when we change the
OpenGL state variables,

00:25:38.100 --> 00:25:40.860
what happens is we get the
flat shaded kind of thing,

00:25:40.930 --> 00:25:43.830
we get the line outline instead
of the little spinning square.

00:25:43.970 --> 00:25:45.870
So, again, let me recap a little bit.

00:25:45.870 --> 00:25:49.110
If you're doing an OpenGL application,
you want to have multiple views

00:25:49.110 --> 00:25:52.990
and you want to have multiple
views that have different kind

00:25:52.990 --> 00:25:57.830
of OpenGL large scale states,
such as orthographic versus a projection,

00:25:57.830 --> 00:26:00.570
such as a flat shaded
versus a smooth shaded.

00:26:00.910 --> 00:26:04.760
You may want to set it up so you're
having the two are separate contexts.

00:26:04.760 --> 00:26:08.740
If you're doing something that just
has different views of the same world,

00:26:08.740 --> 00:26:12.670
you want to set it up so you're
using two different drawables,

00:26:12.700 --> 00:26:13.860
same context.

00:26:13.970 --> 00:26:15.910
Let's move on a little bit.

00:26:23.690 --> 00:26:25.600
So,
multiple contexts and multiple windows.

00:26:25.600 --> 00:26:27.350
This one is a real simple one.

00:26:27.360 --> 00:26:30.080
I already showed the
viewport from the last one,

00:26:30.140 --> 00:26:32.760
and this just shows a
couple other things on it.

00:26:32.870 --> 00:26:39.080
And probably I don't really
even need to show this.

00:26:41.120 --> 00:26:44.500
Other than we'll talk about some
specifics I didn't talk on the last one.

00:26:44.560 --> 00:26:46.980
Same kind of thing.

00:26:46.980 --> 00:26:46.980
Okay.

00:26:47.000 --> 00:26:49.410
What you see here is
basically the same thing,

00:26:49.420 --> 00:26:51.780
but you notice there's a black
border around one of the things.

00:26:51.800 --> 00:26:55.240
And the black border is
from basically a sub-window,

00:26:55.240 --> 00:26:57.140
which I'll talk about in a second.

00:26:57.170 --> 00:27:03.740
The key here is that when I move this,
when I drag this, when I do that,

00:27:03.860 --> 00:27:05.970
what do I need to do to
OpenGL to tell it that actually

00:27:05.970 --> 00:27:08.280
I did something to the window?

00:27:08.370 --> 00:27:09.380
And it's pretty important.

00:27:09.470 --> 00:27:11.660
Because if you don't,
the window won't change.

00:27:11.660 --> 00:27:12.270
Nothing will happen.

00:27:12.280 --> 00:27:15.310
The window will draw the same size,
thinking that it's

00:27:15.350 --> 00:27:16.520
drawable is the right size.

00:27:16.560 --> 00:27:18.540
You need to call updateContext.

00:27:18.540 --> 00:27:20.600
And let me,
this code may be a little bit convoluted

00:27:20.600 --> 00:27:27.560
because of the Carbon stuff in it,
but we'll show it to you and we can

00:27:28.450 --> 00:27:31.300
We can look at exactly when you
need to call update contexts and how

00:27:31.300 --> 00:27:34.360
you actually grow and drag windows.

00:27:34.460 --> 00:27:36.750
And so, just so you know that if you're
not taking notes on this and

00:27:36.880 --> 00:27:39.630
don't have the right feverishly,
I'm going to put all the

00:27:39.750 --> 00:27:41.160
code up on the website.

00:27:41.240 --> 00:27:43.880
There will be examples of this
on the sample code website,

00:27:43.980 --> 00:27:46.200
so you can pull it down and play
around with it and look at it.

00:27:46.320 --> 00:27:49.710
So for example, let's look at the ingrow.

00:27:50.310 --> 00:27:52.860
standard thing for growing a window.

00:27:52.860 --> 00:27:54.400
This is kind of code.

00:27:54.420 --> 00:27:56.140
You set REC to a big REC,
you grow the window,

00:27:56.140 --> 00:28:00.360
but then what do I need to
do to open GL for the grow?

00:28:00.390 --> 00:28:02.790
Basically I set the port here,
I inval the REC to make

00:28:02.790 --> 00:28:05.400
sure it redraws all,
and then the key here

00:28:05.400 --> 00:28:06.430
is down in this area.

00:28:06.440 --> 00:28:08.610
We'll look at the window 2,
this window first.

00:28:08.650 --> 00:28:10.280
This is a window I actually can drag.

00:28:10.310 --> 00:28:10.840
I call

00:28:15.090 --> 00:28:17.600
I'll call updateContext here.

00:28:17.640 --> 00:28:19.400
Oops, sorry.

00:28:19.400 --> 00:28:23.700
Call updateContext,
and I call glSephViewport.

00:28:24.030 --> 00:28:28.700
What that does is update context tells
OpenGL that you've changed something

00:28:28.700 --> 00:28:30.000
as far as that drawable in the window.

00:28:30.000 --> 00:28:32.350
For example,
if you look at the anatomy of

00:28:32.430 --> 00:28:36.140
how OpenGL works with a window,
what happens is there's a front buffer,

00:28:36.140 --> 00:28:37.700
which may be a certain size,
and we talked about

00:28:37.700 --> 00:28:38.600
the back buffer before.

00:28:38.600 --> 00:28:41.160
The back buffer actually is
built behind that front buffer,

00:28:41.240 --> 00:28:41.880
pixel for pixel.

00:28:41.960 --> 00:28:45.180
So if you resize the window,
the front buffer changes and the

00:28:45.180 --> 00:28:46.720
back buffer must be reallocated.

00:28:47.000 --> 00:28:49.790
So what we have is we have a lot
of reallocation in that video card.

00:28:49.790 --> 00:28:52.350
I mean, for example,
if you had loaded it up with your

00:28:52.560 --> 00:28:56.820
200x300 little context and you
had all your textures loaded in

00:28:56.820 --> 00:29:01.500
there and then you go to 1024x768,
definitely there's a lot more

00:29:01.670 --> 00:29:04.450
things that are being used,
a lot more resources that are being

00:29:04.460 --> 00:29:07.900
allocated on your video card for the
back buffer and that front context.

00:29:07.900 --> 00:29:09.950
Thus,
it's going to have to do some shuffling.

00:29:09.950 --> 00:29:11.170
It may purge some textures.

00:29:11.220 --> 00:29:14.860
There are a lot of things going on in the
background just by resizing that window.

00:29:14.930 --> 00:29:15.900
I'm going to kill myself up here.

00:29:15.900 --> 00:29:16.860
But that's okay.

00:29:16.900 --> 00:29:22.260
I think I'll get through
this before I die.

00:29:22.540 --> 00:29:28.650
GL update context tells AGL,
which tells GL that you've

00:29:28.730 --> 00:29:29.400
changed the context.

00:29:29.620 --> 00:29:31.980
Show and hide, definitely should call it.

00:29:32.010 --> 00:29:36.920
Move window and resize window are
cases where you definitely should call

00:29:36.940 --> 00:29:40.810
AGL update context to let GL know that
something has changed for that context.

00:29:40.940 --> 00:29:43.180
GL viewport then was a
thing I showed you before.

00:29:43.180 --> 00:29:47.300
The GL viewport basically sets
the size of your viewport to that

00:29:47.300 --> 00:29:51.710
window and scales anything you're
drawing to that size of the window.

00:29:55.440 --> 00:29:57.100
Subwindows.

00:29:57.100 --> 00:29:58.450
Let's look at subwindows now.

00:29:58.600 --> 00:29:59.880
Subwindows are pretty cool.

00:30:00.090 --> 00:30:02.680
Subwindows is probably one of the
most useful things for people who are

00:30:02.680 --> 00:30:05.340
using OpenGL in a non-fullscreen app.

00:30:05.400 --> 00:30:08.730
Any kind of thing where you have a part
of your window you want to draw a chart,

00:30:08.820 --> 00:30:11.400
a graph, or anything like that,
it's really simple to do.

00:30:11.400 --> 00:30:14.400
You can use any of the line constructs,
you can just draw squares,

00:30:14.400 --> 00:30:16.400
you can draw filled squares,
shaded squares.

00:30:16.400 --> 00:30:17.090
That's really simple.

00:30:17.090 --> 00:30:18.400
Any OpenGL book can
tell you how to do that.

00:30:18.400 --> 00:30:20.810
But the question is how do
you constrain your drawing,

00:30:20.810 --> 00:30:26.050
how do you make your drawing work,
draw in the areas you want it to draw in.

00:30:28.590 --> 00:30:32.260
So let's run this first, actually,
and then I'll show you how it works.

00:30:32.260 --> 00:30:35.160
Again, this is a spinning square,
and you notice now we

00:30:35.170 --> 00:30:36.820
have two spinning squares.

00:30:36.820 --> 00:30:39.860
This is pretty simple.

00:30:39.860 --> 00:30:41.040
It just puts a square.

00:30:41.040 --> 00:30:43.320
We have the one window,
which is exactly the same as before.

00:30:43.320 --> 00:30:45.280
And what I've done in the second window,
when I go to draw it,

00:30:45.480 --> 00:30:48.650
it's the same context, same drawable,
but I draw it twice setting

00:30:48.790 --> 00:30:50.110
up what's called a buffer rec.

00:30:50.200 --> 00:30:52.490
And the buffer rec is
nice because in this case,

00:30:52.490 --> 00:30:55.700
when I click the mouse,
it adjusts the vertical part of

00:30:55.700 --> 00:30:57.610
it to where I click the mouse.

00:30:57.810 --> 00:31:00.680
So you can see that I can
adjust the buffer recs there.

00:31:00.680 --> 00:31:05.880
So you can see that you can put a divider
bar and have your OpenGL rendering,

00:31:05.880 --> 00:31:09.400
whatever you're doing,
a visualization of a 3D visualization

00:31:09.400 --> 00:31:13.000
of a website layout with a list on
the other side of all the web pages.

00:31:13.000 --> 00:31:17.200
And as you drag the slider bar,
you can adjust the size of your display.

00:31:17.200 --> 00:31:18.410
This is an easy way to do it.

00:31:18.480 --> 00:31:19.230
This works great.

00:31:19.240 --> 00:31:21.160
This is called AGL buffer rec.

00:31:21.240 --> 00:31:24.690
And again, someone may wonder,
if they're new to GL,

00:31:25.010 --> 00:31:26.320
why is it AGL and GL?

00:31:26.860 --> 00:31:29.780
AGL is the Apple's
implementation-dependent

00:31:29.780 --> 00:31:31.280
sections of OpenGL.

00:31:31.280 --> 00:31:34.510
Anything that has to do with windowing,
anything that has to do with

00:31:34.530 --> 00:31:36.520
the display is all through AGL.

00:31:36.520 --> 00:31:39.810
Thus, a buffer rec,
which is adjusting inside a window,

00:31:39.810 --> 00:31:42.820
inside a drawable, will set up in AGL.

00:31:42.820 --> 00:31:45.220
And that basically sets up
kind of a clipping area.

00:31:45.220 --> 00:31:48.980
It sets up a small area that it clips to
that area and just draws GL in that area.

00:31:51.110 --> 00:31:54.440
One note here, if I didn't set the
viewport as we saw before,

00:31:54.570 --> 00:31:55.500
Buffer Rec works great.

00:31:55.500 --> 00:31:59.390
It'll draw a little window that
you can move around or whatever.

00:31:59.390 --> 00:32:00.840
They don't just draw a little cutout.

00:32:01.040 --> 00:32:04.110
So if you set your viewport,
your viewport will stay in the bottom

00:32:04.110 --> 00:32:07.000
corner as normal of your drawable.

00:32:07.000 --> 00:32:09.560
And you can set a Buffer Rec without
setting the viewport and it'll

00:32:09.570 --> 00:32:11.000
just move around on your screen.

00:32:11.000 --> 00:32:13.000
I may not even show you that.

00:32:13.000 --> 00:32:17.000
Let's quit this and I'll show you a
very simple setup here to do here.

00:32:17.000 --> 00:32:21.070
This is the Buffer Rec code.

00:32:21.070 --> 00:32:21.070
I'll bring it bigger for you.

00:32:24.140 --> 00:32:30.110
Okay, on my do update again,
what I do is these are, I have two,

00:32:30.640 --> 00:32:34.300
- Section of the drawing,
one here and one here.

00:32:34.320 --> 00:32:37.100
And if you notice that
I use the buffer rack,

00:32:37.160 --> 00:32:43.410
and the buffer rack is, in this case, x,
y, width, height.

00:32:43.620 --> 00:32:46.850
And what I'm doing here is
setting the height of it

00:32:47.270 --> 00:32:48.200
to my mouse location.

00:32:48.200 --> 00:32:50.540
When I get a mouse down,
I find the location

00:32:50.540 --> 00:32:52.200
in window coordinates,
and I find out what it is,

00:32:52.200 --> 00:32:52.980
and so I set that.

00:32:53.080 --> 00:32:57.060
So that gives me the height
of that mouse location there.

00:32:57.080 --> 00:32:59.800
I call glSetInteger,

00:33:00.210 --> 00:33:06.080
Set my context, set call AGL buffer rack,
and pass in the buffer rack.

00:33:06.120 --> 00:33:10.080
So that tells it how I want
to constrain my drawing.

00:33:10.620 --> 00:33:15.680
And I called GLViewport
for the actual viewport.

00:33:15.870 --> 00:33:21.930
I'm trying to think of how I can do
this to make it actually interesting.

00:33:22.010 --> 00:33:24.100
Okay, I know what I can do.

00:33:24.160 --> 00:33:26.040
We'll get rid of that and
we'll do this in a second,

00:33:26.040 --> 00:33:27.850
and we'll get rid of that.

00:33:27.860 --> 00:33:29.340
But basically the other
one's the same way.

00:33:29.340 --> 00:33:33.620
So I'm basically drawing two pieces,
just adjusting the interior.

00:33:33.910 --> 00:33:37.650
I talked about how you can use
Buffer Rack to actually take a little

00:33:37.650 --> 00:33:42.850
window on the world kind of thing,
and this should do that.

00:33:42.850 --> 00:33:42.850
Yes?

00:33:43.260 --> 00:33:46.090
If you notice,
it's in my infinite wisdom,

00:33:46.100 --> 00:33:50.620
I have some update context in there,
but basically the update is

00:33:50.620 --> 00:33:52.140
out of sync as I move down.

00:33:52.140 --> 00:33:56.530
You see that unless you call viewport
synced with your buffer rack,

00:33:56.540 --> 00:34:00.850
that you have cases where you're
looking at either old data that's

00:34:00.850 --> 00:34:04.670
not being updated or you're looking
at the viewports remaining the

00:34:04.760 --> 00:34:06.090
same because it's not updating.

00:34:06.100 --> 00:34:08.650
This section up here has never been
updated again because a swap is just

00:34:08.680 --> 00:34:10.170
calling it on the small buffer rack.

00:34:10.240 --> 00:34:13.740
We can also see that... Let me
show you another case of that.

00:34:13.740 --> 00:34:17.540
That's something to worry about,
or not to worry about, but to understand.

00:34:17.540 --> 00:34:21.440
I'm going to go back one example,
the multi-context one.

00:34:22.810 --> 00:34:24.960
Just run it for you.

00:34:24.960 --> 00:34:26.920
If you notice I talked
about that black border.

00:34:27.030 --> 00:34:29.500
The black border is
inset with a buffer rack,

00:34:29.520 --> 00:34:30.400
real simple.

00:34:30.510 --> 00:34:32.700
But notice OpenGL doesn't
update any of that area.

00:34:32.700 --> 00:34:34.510
OpenGL is not responsible for that.

00:34:34.740 --> 00:34:37.480
So if you have areas that you change
your buffer rack or areas that you

00:34:37.480 --> 00:34:41.030
take over and you want to update,
you need to make sure that

00:34:41.030 --> 00:34:45.730
you're updating that area because
OpenGL is not going to do it.

00:34:45.730 --> 00:34:45.730
You saw it in this

00:34:46.100 --> 00:34:50.670
Right here you can see it,
whereas when I change my drawable, here,

00:34:50.820 --> 00:34:52.400
it doesn't update that top part.

00:34:52.490 --> 00:34:55.000
Buffer Rack resets it to
set that area of draws.

00:34:55.000 --> 00:34:58.850
It just constrains the drawing,
but doesn't say, "Oh,

00:34:58.850 --> 00:35:01.500
erase the background."
OpenGL works the same.

00:35:01.500 --> 00:35:05.140
It's very linear thinking,
so if you don't think it's

00:35:05.410 --> 00:35:07.430
going to do something,
it probably won't do it.

00:35:07.500 --> 00:35:12.490
So let's go back and see where we are.

00:35:16.340 --> 00:35:17.840
Okay, actually good, good.

00:35:17.840 --> 00:35:20.760
I'm about where I want to be.

00:35:20.810 --> 00:35:22.800
You notice on almost all of those,
you may have noticed on the screen

00:35:22.910 --> 00:35:24.230
that you saw fonts on there.

00:35:24.290 --> 00:35:25.310
How do you do fonts?

00:35:25.360 --> 00:35:26.540
Fonts are a great thing
to put out because you can

00:35:26.540 --> 00:35:28.220
just put text on the screen.

00:35:28.270 --> 00:35:30.820
Works pretty well.

00:35:31.850 --> 00:35:34.000
It's something that you
definitely want to probably do,

00:35:34.010 --> 00:35:40.500
and if you don't have a way to do that,
then

00:35:40.920 --> 00:35:43.800
We talked about OpenGL Buffer
by combining 2D and 3D.

00:35:43.800 --> 00:35:46.400
One thing, actually,
there is another caveat here.

00:35:46.400 --> 00:35:48.400
Let me go back to this for a second.

00:35:48.650 --> 00:35:50.390
2D and 3D.

00:35:50.570 --> 00:35:51.350
Keep them separate.

00:35:51.590 --> 00:35:56.740
Don't try and draw OpenGL on an area
that you're also writing 2D on an area.

00:35:56.790 --> 00:35:58.780
Make sure that your 2D
and 3D are separate areas.

00:35:58.860 --> 00:36:00.750
If you want to put a
frame around a 3D area,

00:36:00.840 --> 00:36:01.500
that's fine.

00:36:01.500 --> 00:36:03.520
Just set the buffer record
for whatever you want.

00:36:03.640 --> 00:36:05.830
And then put the frame around it
with your 2D drawing conventions.

00:36:05.900 --> 00:36:07.100
Just don't try and overlap them.

00:36:07.100 --> 00:36:09.250
Because what's going to happen is,
the OpenGL is going to draw right

00:36:09.250 --> 00:36:10.840
over whatever you have there.

00:36:10.870 --> 00:36:11.840
The OpenGL doesn't know any better.

00:36:11.840 --> 00:36:13.900
It doesn't know that
you're constraining it.

00:36:13.990 --> 00:36:15.510
OpenGL does abide by clip regions.

00:36:15.600 --> 00:36:17.600
You notice if I switch the
windows in the background,

00:36:17.600 --> 00:36:19.200
it didn't draw over top the other window.

00:36:19.200 --> 00:36:21.070
It does handle those
things in windowed areas.

00:36:21.080 --> 00:36:22.000
So it's just fine.

00:36:22.050 --> 00:36:24.120
So there's no problem with
the app switching to the back.

00:36:24.240 --> 00:36:27.540
You don't have to worry about, oh my god,
I have to set this weird area to draw.

00:36:27.540 --> 00:36:29.160
And it'll take care of that.

00:36:29.200 --> 00:36:31.440
But don't try and draw OpenGL,
like for example,

00:36:31.440 --> 00:36:32.440
in that spinning square.

00:36:32.440 --> 00:36:34.620
Don't try and do a swap buffer,
and then immediately try

00:36:34.620 --> 00:36:36.160
and draw text to the screen.

00:36:36.160 --> 00:36:40.560
OpenGL is a pipelined and
asynchronous method of drawing.

00:36:40.640 --> 00:36:44.360
So what happens in it is that
swap buffer basically says,

00:36:44.550 --> 00:36:46.660
sometime in the future, I'll get to it.

00:36:46.680 --> 00:36:50.960
The engine usually is running much
faster than you can sync commands to it.

00:36:51.060 --> 00:36:54.130
So usually, you saw 400,
600 frames per second.

00:36:54.230 --> 00:36:58.130
So if you draw in text every frame,
it's probably synchronized.

00:36:58.190 --> 00:37:00.800
But what's going to
happen is that in reality,

00:37:00.970 --> 00:37:01.990
you're lucky if it's synced.

00:37:02.000 --> 00:37:03.490
It doesn't really synchronize together.

00:37:03.560 --> 00:37:05.690
By calling swap buffers,
it doesn't sync to anything.

00:37:05.710 --> 00:37:09.180
There are ways in glFlush and
glFinish to do some synchronization.

00:37:09.210 --> 00:37:10.980
But I recommend staying away from that.

00:37:10.990 --> 00:37:13.260
I recommend using the buffer recs.

00:37:13.260 --> 00:37:14.990
I recommend drawing parts of the screen.

00:37:15.000 --> 00:37:18.800
I recommend you could even do a clipping
region and clip out the area that you

00:37:18.800 --> 00:37:23.170
don't don't want to draw into and then
using 2D specifically in those areas.

00:37:24.410 --> 00:37:26.380
So we taught you full window updates.

00:37:26.510 --> 00:37:30.090
If you're doing a full window update,
make sure you draw the 2D pieces also.

00:37:30.100 --> 00:37:32.490
If you change your buffer rack,
OpenGL is going to forget about the

00:37:32.540 --> 00:37:35.970
piece it doesn't want to draw anymore,
how you moved it, and you have to take

00:37:35.970 --> 00:37:37.350
care of drawing that.

00:37:38.700 --> 00:37:39.390
Basic font handling.

00:37:39.400 --> 00:37:42.300
As you saw in my demos,
there's some fonts on there.

00:37:42.300 --> 00:37:45.730
If you want to put fonts on top of 2D,
don't draw text on top of 2D,

00:37:45.740 --> 00:37:48.480
or on top of 3D, sorry, on top of 3D,
because it won't work.

00:37:48.580 --> 00:37:51.780
So you have to use some of the font
handling that we have in OpenGL.

00:37:51.780 --> 00:37:55.390
John's been very nice to work
and put AGL font handling

00:37:55.390 --> 00:37:56.660
in that works like a champ.

00:37:56.680 --> 00:37:57.580
It's super easy.

00:37:57.580 --> 00:37:59.590
Once you figure it out,
it's like you can put

00:37:59.700 --> 00:38:00.770
any text you want on it.

00:38:00.840 --> 00:38:03.110
What you can do, though,
is you can't rotate it

00:38:03.110 --> 00:38:04.370
and you can't blend it.

00:38:04.420 --> 00:38:06.470
It's just bitmap raster fonts.

00:38:06.770 --> 00:38:08.990
It'll work great to draw strings,
work great to color it,

00:38:09.040 --> 00:38:11.260
whatever you want, but you can't blend it
with the background,

00:38:11.290 --> 00:38:11.870
and you can't.

00:38:11.920 --> 00:38:15.080
I'm sorry, when I say blend,
I mean blend the actual text,

00:38:15.120 --> 00:38:16.460
not the background.

00:38:16.460 --> 00:38:18.080
You don't get blocks of black letters.

00:38:18.080 --> 00:38:22.020
The text is transparent in the areas
that it aren't actually drawn to,

00:38:22.020 --> 00:38:26.290
but you can't blend the white text into
gray into the background kind of thing.

00:38:26.300 --> 00:38:31.780
So let's look at the code to do that,
and it is super simple,

00:38:31.780 --> 00:38:34.350
and I think I have it
on the web right now.

00:38:34.360 --> 00:38:35.820
And.

00:38:38.360 --> 00:38:40.850
And if it's not, I'll put this up.

00:38:40.860 --> 00:38:42.530
I like this stuff.

00:38:42.540 --> 00:38:46.490
Because it's really, really easy.

00:38:50.390 --> 00:38:52.540
Okay, I have this big draw frame rate,
but that's not the real key.

00:38:52.540 --> 00:38:57.070
The real key is the build font GL.

00:38:57.200 --> 00:38:58.610
Okay.

00:38:59.160 --> 00:39:03.490
We call GL unsigned integer list base,
and the GL gen list,

00:39:03.490 --> 00:39:07.970
and basically that makes 256
slots for basically display lists,

00:39:07.980 --> 00:39:10.600
so it's holders for the font letters.

00:39:10.640 --> 00:39:13.680
Then I'm going to call
AGL use font right here.

00:39:13.810 --> 00:39:17.900
I give it the context it was passed in,
a font ID, so I use like Monaco,

00:39:17.900 --> 00:39:20.130
whatever I call, get font FNUM.

00:39:20.200 --> 00:39:24.210
A face, a size, so a face may be normal,
size would be 9.0256,

00:39:24.300 --> 00:39:27.580
this sets the parameters for
how many it's going to generate,

00:39:27.710 --> 00:39:31.200
and the list base,
which is what I got right here.

00:39:31.270 --> 00:39:33.120
Basically what that does,
it generates all your fonts.

00:39:33.180 --> 00:39:35.430
It takes all the fonts,
stuffs it into the list,

00:39:35.530 --> 00:39:39.990
and you get a font that you wanted,
whatever raster font you wanted.

00:39:40.290 --> 00:39:44.180
This is something,
because of the way AGL use font

00:39:44.180 --> 00:39:48.380
sets up a GL pixel map handling,
you want to reset your pixel store,

00:39:48.380 --> 00:39:49.920
called GL pixel store I to zero.

00:39:49.920 --> 00:39:50.120
This is kind of a little bit of a trick,
but it's a little bit of a trick.

00:39:50.170 --> 00:39:53.770
This is kind of a key thing to do to
make sure that you don't have problems

00:39:53.830 --> 00:39:55.820
later on trying to draw textures.

00:39:55.840 --> 00:39:58.720
And real simple,
to delete it you call delete list,

00:39:58.870 --> 00:40:01.200
the font list you
created that's passed in,

00:40:01.260 --> 00:40:03.220
and 256 elements in that list.

00:40:03.470 --> 00:40:04.620
Pretty simple.

00:40:04.640 --> 00:40:09.700
And what's even better
is my drawl C string GL.

00:40:09.920 --> 00:40:13.720
All you do is go, you take GL int,
set an I equal to one.

00:40:13.770 --> 00:40:16.680
Wall,
you have letters in your out string,

00:40:16.680 --> 00:40:20.080
you want to use call list,
font list plus the base in your,

00:40:20.330 --> 00:40:21.580
and increment I.

00:40:21.620 --> 00:40:24.520
And there's other ways to do this
with for loops and some other loops.

00:40:24.680 --> 00:40:28.590
But basically what that does,
it's going to walk through your list,

00:40:28.590 --> 00:40:31.020
and the list basically says,
it's a display list in GL,

00:40:31.020 --> 00:40:34.980
which basically says draw this character
at the raster position and advance the

00:40:34.980 --> 00:40:36.860
raster position with the character.

00:40:36.980 --> 00:40:39.040
So you get the
proportionally spaced fonts.

00:40:39.100 --> 00:40:39.580
So it works fine.

00:40:39.580 --> 00:40:41.230
It's not like they're all blocked out.

00:40:41.320 --> 00:40:43.600
And you get all the letters,
and the letters will draw

00:40:43.830 --> 00:40:44.970
nicely on the screen.

00:40:44.980 --> 00:40:45.710
You get nice letters.

00:40:45.770 --> 00:40:46.720
You can put information out.

00:40:46.720 --> 00:40:47.620
You can put your frame rates out.

00:40:47.620 --> 00:40:48.730
You can put version numbers out.

00:40:48.740 --> 00:40:50.030
You can put debugging information out.

00:40:50.040 --> 00:40:51.970
You can put information
what your states are.

00:40:52.060 --> 00:40:53.000
Works great.

00:40:53.280 --> 00:40:53.880
Simple.

00:40:54.150 --> 00:40:56.970
So you then have a,
basically you're kind of print F for GL.

00:40:57.140 --> 00:40:59.040
You can, in that way.

00:40:59.040 --> 00:41:00.030
Or I'll say print F.

00:41:00.040 --> 00:41:02.990
You can use print F to,
print F to format, and then you can just

00:41:02.990 --> 00:41:04.040
spit it out to here.

00:41:04.040 --> 00:41:04.870
So that works well.

00:41:05.220 --> 00:41:07.260
And in this case,
this is just some code that

00:41:07.260 --> 00:41:11.040
I'm using here to do frame
rate timing inside of it.

00:41:11.040 --> 00:41:11.980
So I call that once per frame.

00:41:12.100 --> 00:41:15.810
So that's more of a,
there's no real complication there.

00:41:16.680 --> 00:41:20.000
So, I won't show you anything with fonts.

00:41:20.000 --> 00:41:21.880
I'm just going to show you
something else with fonts right now.

00:41:22.000 --> 00:41:24.000
And in a second, I'll show you that when
you want to draw fonts,

00:41:24.000 --> 00:41:28.000
you want to make sure
you're in a context or in a,

00:41:28.000 --> 00:41:29.820
you can set your raster position
to the 2D position on the

00:41:29.820 --> 00:41:30.970
screen you want your fonts in.

00:41:31.000 --> 00:41:32.280
If you're drawing a
complicated 3D screen,

00:41:32.280 --> 00:41:33.000
you may not be able to.

00:41:33.000 --> 00:41:37.270
It may be your X0, Y0,
maybe back face of this polygon

00:41:37.270 --> 00:41:41.000
over here until your font comes out
backwards and over here or whatever.

00:41:41.000 --> 00:41:43.090
So that's not,
you want to be careful about that

00:41:43.260 --> 00:41:45.000
because that won't work very well.

00:41:45.000 --> 00:41:48.840
So, we'll look at, remind me about that,
and I'll tell you how to set up an

00:41:48.840 --> 00:41:49.920
orthographic context in a minute.

00:41:50.030 --> 00:41:51.920
And so, I think I'll go back here.

00:41:51.920 --> 00:41:52.920
How are we doing?

00:41:52.920 --> 00:41:55.860
We've got about 20 minutes, I think.

00:41:56.940 --> 00:42:01.910
And let's go back to... I don't
believe I... No one told me?

00:42:03.520 --> 00:42:04.430
I did?

00:42:04.550 --> 00:42:04.870
I did?

00:42:04.870 --> 00:42:05.750
Okay, awesome.

00:42:05.750 --> 00:42:06.400
Thank you.

00:42:06.560 --> 00:42:07.500
Save me.

00:42:07.660 --> 00:42:10.500
Okay, so basic font handling is good.

00:42:10.500 --> 00:42:13.040
Physical simulation.

00:42:13.040 --> 00:42:16.410
Really simple physical
simulation is... I'm going to

00:42:16.410 --> 00:42:20.150
talk about some examples of it,
of how to do physical simulation,

00:42:20.150 --> 00:42:23.780
or examples of doing physical
simulation in OpenGL.

00:42:23.780 --> 00:42:27.060
You can do something from very simple,
just to get the idea of what's going on,

00:42:27.060 --> 00:42:29.980
just to get, hey, you know,
sometimes visualization of something

00:42:29.980 --> 00:42:33.300
is a lot easier than describing it
or writing a text-based program.

00:42:33.300 --> 00:42:37.800
So with a little bit of hooks in there,
you have your physics simulator

00:42:37.800 --> 00:42:40.500
working out at a university,
and you want to simulate some effect,

00:42:40.500 --> 00:42:41.780
and you want to just map it out.

00:42:41.830 --> 00:42:43.840
It's pretty simple to
just toss it into OpenGL.

00:42:43.840 --> 00:42:46.130
A couple of recommendations here.

00:42:46.160 --> 00:42:47.820
If you don't want to do
any kind of Mac handling,

00:42:47.820 --> 00:42:50.490
you want to make the thing run on Unix,
you want to make it run on Windows,

00:42:50.490 --> 00:42:54.570
you want to make it run on the Macintosh,
what you can do is you can use GLUT.

00:42:54.570 --> 00:42:56.780
GLUT is GLUT Utility Toolkit.

00:42:56.780 --> 00:43:02.740
It's a cross-platform, on the code level,
based kind of... UI handler.

00:43:02.740 --> 00:43:04.930
So it gives you the keyboard events,
it gives you the Windows and

00:43:04.930 --> 00:43:05.630
that kind of stuff.

00:43:05.630 --> 00:43:06.420
You write the same code.

00:43:06.620 --> 00:43:08.000
I wouldn't recommend
it for shipping code,

00:43:08.330 --> 00:43:11.470
but I would recommend it for if
you're doing any kind of a profile,

00:43:11.470 --> 00:43:14.530
any kind of research areas,
any kind of... you want to

00:43:14.530 --> 00:43:16.200
look at some algorithms,
you want to do a quick one-off

00:43:16.200 --> 00:43:18.780
application for in-house
to demonstrate something,

00:43:18.850 --> 00:43:20.160
GLUT works like a champ.

00:43:20.160 --> 00:43:21.000
So what am I going to show?

00:43:21.000 --> 00:43:22.350
I'm going to show you some fun examples.

00:43:22.450 --> 00:43:26.310
So you've now pretty much
finished with my spinning square.

00:43:26.310 --> 00:43:31.300
I appreciate you kind of hanging in
there for the spinning square demos.

00:43:31.300 --> 00:43:33.030
Now we'll look at some
more interesting things.

00:43:33.080 --> 00:43:36.200
Thank you very much.

00:43:36.200 --> 00:43:37.390
Skyrocket.

00:43:37.390 --> 00:43:40.560
Skyrocket is a program that
was written by Terry Welsh.

00:43:40.560 --> 00:43:44.080
And the reason I bring this up is because
I ported this from Windows to Macintosh.

00:43:44.080 --> 00:43:46.600
It took me about two hours to do this.

00:43:46.600 --> 00:43:47.590
It's a screen saver.

00:43:47.740 --> 00:43:49.720
It took me about two
hours to do the port.

00:43:49.720 --> 00:43:52.140
And it runs very well.

00:43:52.260 --> 00:43:53.910
It's not... it wasn't a big deal.

00:43:53.940 --> 00:43:56.340
It's OpenGL and based on a
standard template library.

00:43:56.480 --> 00:43:57.460
It was really easy.

00:43:57.570 --> 00:43:58.680
Came over, no problem.

00:43:58.770 --> 00:44:00.360
No changes in the GL code at all.

00:44:00.410 --> 00:44:02.260
Didn't change anything.

00:44:02.260 --> 00:44:02.460
I mean, not a line.

00:44:02.530 --> 00:44:05.760
I did a little bit of AGL setup
and that was about it.

00:44:05.760 --> 00:44:08.250
And so then we go to the GL code,
leave it the same.

00:44:08.260 --> 00:44:10.860
And okay,
so I'm going to run this in 1024,

00:44:10.930 --> 00:44:13.560
768 and I think it will
all fit on the screen.

00:44:13.560 --> 00:44:15.020
It should work just fine.

00:44:15.020 --> 00:44:18.510
And I ask you to bear with me for
a minute because it takes a little

00:44:18.510 --> 00:44:20.090
while to get started to see it.

00:44:20.090 --> 00:44:21.540
And I'm not sure how
well you can see that.

00:44:21.540 --> 00:44:23.360
You probably can.

00:44:23.360 --> 00:44:25.260
And the camera will take
maybe a few minutes to rotate.

00:44:25.270 --> 00:44:28.650
But what he has done here is basically
set up a texture for the clouds.

00:44:28.650 --> 00:44:31.220
He set up a texture for the sky,
for the stars.

00:44:31.220 --> 00:44:32.260
And then he's going to rotate the stars.

00:44:32.260 --> 00:44:34.060
He also has some terrain below you.

00:44:34.210 --> 00:44:36.720
You can't really see that real well,
can you?

00:44:36.720 --> 00:44:37.400
That's not bad.

00:44:37.490 --> 00:44:39.720
We'll wait for it to rotate
and then I'll show you.

00:44:39.720 --> 00:44:41.300
And then you'll actually see it's 3D.

00:44:41.300 --> 00:44:43.880
So it's your standard
fireworks kind of demo.

00:44:43.920 --> 00:44:48.250
If you notice that the fireworks light
the smoke up with the other fireworks.

00:44:48.250 --> 00:44:51.080
So he has a lot of
lighting effects going on.

00:44:51.080 --> 00:44:52.600
The clouds get lit up.

00:44:52.600 --> 00:44:54.080
And of course,
it wouldn't... since I don't

00:44:54.080 --> 00:44:56.530
have mouse keys to rotate it,
it wouldn't start... want to start

00:44:56.530 --> 00:44:59.320
rotating for me because it kind of
randomly picks the times to rotate.

00:44:59.320 --> 00:45:01.180
So we'll let it... we'll
sit here and be patient.

00:45:01.240 --> 00:45:04.720
Let it fool around anymore.

00:45:04.720 --> 00:45:08.120
So what else can I tell you about it?

00:45:08.120 --> 00:45:09.640
Each... the way this works,
if you notice,

00:45:09.640 --> 00:45:13.110
each piece of smoke is a texture
and he scales the texture

00:45:13.110 --> 00:45:14.760
and colors the polygon color.

00:45:14.760 --> 00:45:17.550
So he takes a texture of the
cloud with some alpha values.

00:45:17.670 --> 00:45:20.940
And then what he does,
he puts the polygon in the right place

00:45:20.940 --> 00:45:25.520
and he turns on... he sets the polygon
color to let the... now here we go.

00:45:25.570 --> 00:45:29.230
If you notice,
it really is full 3D application

00:45:29.230 --> 00:45:31.140
rotating at that little matrix like that.

00:45:31.140 --> 00:45:35.260
So you can see the effect
of the camera rotating.

00:45:35.290 --> 00:45:40.090
And what's really nice about
this application is... I mean,

00:45:40.090 --> 00:45:41.680
it just... it looks good.

00:45:41.840 --> 00:45:44.440
It gives some power on
OpenGL and it's pretty small,

00:45:44.440 --> 00:45:45.660
pretty compact.

00:45:45.660 --> 00:45:46.620
One guy did it.

00:45:46.900 --> 00:45:48.630
I mean,
if you want to simulate something,

00:45:48.630 --> 00:45:51.880
if you want to do some simulation,
you can see that you get kind of... you

00:45:51.880 --> 00:45:54.060
can do some really nice things in OpenGL.

00:45:54.460 --> 00:45:59.590
You get a nice moon glow and
some lighting effects there.

00:45:59.590 --> 00:45:59.590
And

00:46:01.770 --> 00:46:04.250
So you can see that he did
a real nice job with this.

00:46:04.360 --> 00:46:12.380
And what's nice about some OpenGL stuff
is that I can turn it off full screen,

00:46:12.420 --> 00:46:13.880
go to 400 by 300.

00:46:13.880 --> 00:46:16.340
Remember, I haven't done anything
to the OpenGL itself.

00:46:16.340 --> 00:46:18.850
All I'm doing is changing it to a window,
calling the same thing

00:46:18.850 --> 00:46:21.740
I've talked about before,
the GL viewport, making sure the window

00:46:21.740 --> 00:46:23.000
is set up the right way.

00:46:23.020 --> 00:46:23.620
And there I am.

00:46:23.620 --> 00:46:25.220
I got it in a window.

00:46:25.270 --> 00:46:28.440
Same stuff, running exactly the same,
no changes, same code,

00:46:28.450 --> 00:46:29.690
works like a champ.

00:46:29.810 --> 00:46:31.590
So OpenGL works in a window.

00:46:31.660 --> 00:46:34.440
I could have something that says, hey,
this is my rocket simulation.

00:46:34.440 --> 00:46:35.460
I'm going to show you.

00:46:35.460 --> 00:46:38.360
This is the fireworks effect that
my fireworks company is going to set

00:46:38.360 --> 00:46:40.320
up for your 4th of July celebration.

00:46:40.340 --> 00:46:42.600
Here's an example of what
it's going to look like,

00:46:42.620 --> 00:46:45.760
and have some cost or
some presentation on it,

00:46:45.780 --> 00:46:47.070
using OpenGL to demo it.

00:46:47.200 --> 00:46:51.190
So that could be a use for someone
who wanted to use OpenGL without

00:46:51.250 --> 00:46:54.300
having to do too much extra work.

00:46:54.470 --> 00:46:57.700
I actually want to whiz through
these ones a little bit quickly

00:46:57.700 --> 00:46:59.690
so I can get to the end.

00:46:59.900 --> 00:47:04.830
New Wave,
this is an example that comes with

00:47:06.350 --> 00:47:07.720
This is a really cool feature.

00:47:07.720 --> 00:47:09.870
It comes with the GLUT,
the code comes with this.

00:47:09.870 --> 00:47:12.780
You have source code for that with our
SDK and you can find it and this is

00:47:12.780 --> 00:47:14.400
something that's really easy to do.

00:47:14.400 --> 00:47:15.350
That's kind of nice.

00:47:15.350 --> 00:47:16.300
That's kind of cool.

00:47:16.300 --> 00:47:19.030
What's nice about it actually
is that you can do this.

00:47:24.600 --> 00:47:25.840
And let's do something else here.

00:47:25.840 --> 00:47:33.840
Let's set size to... Let's
use the environment mapping.

00:47:33.840 --> 00:47:37.100
The reason I say this is a physical
simulation other than just a cool

00:47:37.100 --> 00:47:42.080
piece of eye candy is because...
Let's display the wireframe.

00:47:42.080 --> 00:47:44.800
The wireframe is actually
just a set of springs.

00:47:44.810 --> 00:47:48.620
And they used to use a simple physical
simulation of springs to set this up

00:47:48.620 --> 00:47:50.840
and to do the propagating waves on it.

00:47:50.880 --> 00:47:53.000
So this is another physical simulation.

00:47:53.000 --> 00:47:53.700
That's kind of cool.

00:47:53.700 --> 00:47:54.550
You could talk about it.

00:47:54.630 --> 00:47:55.180
You can do it.

00:47:55.180 --> 00:47:57.770
But then you put it in OpenGL,
throw the environment mapping on,

00:47:57.770 --> 00:48:00.000
and you've got something that
really catches your eye and says,

00:48:00.000 --> 00:48:04.120
"Hey, that's something great." You notice
it runs in a window just fine.

00:48:04.120 --> 00:48:07.210
It's not like you have to go
full screen to demo this stuff.

00:48:07.260 --> 00:48:12.020
and the last one is actually a real
simple demo uh... and I apologize for

00:48:12.020 --> 00:48:17.780
this one because on this machine it
kind of runs a little fast uh... so this

00:48:17.780 --> 00:48:23.770
is a demonstration of Lorenz attractors
and uh... you can see that that's

00:48:24.580 --> 00:48:26.980
So it's showing,
it's following the little red ball

00:48:26.980 --> 00:48:29.000
around in the little Lorenzo tractor.

00:48:29.000 --> 00:48:31.400
So that's another idea
of someone using OpenGL,

00:48:31.460 --> 00:48:35.270
mapping it out to 3D and
implementing it in a very simple way.

00:48:35.400 --> 00:48:38.300
So just to show that you can
do simple stuff there too.

00:48:38.860 --> 00:48:39.800
Okay, let's move on.

00:48:39.860 --> 00:48:42.830
And you're awesome,
because he's going to have to switch

00:48:42.960 --> 00:48:43.790
it over by the time I get here.

00:48:43.800 --> 00:48:45.760
I'm just going to beat him.

00:48:45.780 --> 00:48:46.140
Oh, damn.

00:48:46.140 --> 00:48:46.710
I couldn't beat him.

00:48:46.840 --> 00:48:47.790
Orthographic projections.

00:48:47.840 --> 00:48:49.040
We talked about that a little bit.

00:48:49.120 --> 00:48:51.800
Orthographic projection is
basically a parallel projection.

00:48:51.800 --> 00:48:54.720
It's one-to-one for the
screen and the context.

00:48:54.860 --> 00:48:57.800
And one good use for
this is a sprite engine.

00:48:57.800 --> 00:48:59.360
I wanted to have a sprite
engine example here,

00:48:59.360 --> 00:49:02.200
honestly, but I did not have the time
to put it together with all

00:49:02.200 --> 00:49:03.800
the other things we're doing.

00:49:03.800 --> 00:49:05.540
So what I have is I have my font.

00:49:05.550 --> 00:49:06.730
My font's at the end.

00:49:06.860 --> 00:49:09.800
I'll show you how that
works with the font display,

00:49:09.800 --> 00:49:11.730
how it actually is an
orthographic projection.

00:49:11.800 --> 00:49:12.780
And you can set them up.

00:49:12.780 --> 00:49:14.060
And it's really fairly simple.

00:49:14.170 --> 00:49:15.800
It's just a little three lines of code.

00:49:15.800 --> 00:49:18.800
But you had to hold on for that,
so I'll move on into a minute.

00:49:20.360 --> 00:49:21.530
Texture Mapping.

00:49:21.530 --> 00:49:24.890
In my last 10 minutes here,
I'm going to tell you all how to do

00:49:24.890 --> 00:49:27.050
texture mapping on the Macintosh.

00:49:27.050 --> 00:49:28.500
Because it seems that first people go,
"Ooh,

00:49:28.500 --> 00:49:29.700
I don't know how to do texture mapping.

00:49:29.700 --> 00:49:31.300
I don't know how to put
cool stuff on the screen.

00:49:31.300 --> 00:49:35.710
All I know how to do is actually
draw boxes like I did." That's easy.

00:49:35.780 --> 00:49:36.420
Texture mapping is hard.

00:49:36.590 --> 00:49:38.300
Texture mapping is easy.

00:49:38.780 --> 00:49:40.300
Basically, you've got to read the image.

00:49:40.500 --> 00:49:42.300
You've got to swizzle the pixels.

00:49:42.380 --> 00:49:46.230
What I mean by swizzle the pixels,
that's an official industry term now,

00:49:46.230 --> 00:49:47.500
swizzling pixels.

00:49:47.500 --> 00:49:52.300
Swizzling pixels is you've got an ARGB,
so it's 8 bits alpha, 8 bits red,

00:49:52.300 --> 00:49:55.300
8 bits green, 8 bits blue in the
Macintosh 32-bit off screen.

00:49:55.300 --> 00:49:56.290
That's what you get.

00:49:56.300 --> 00:49:58.300
That's when you read
it in using QuickTime,

00:49:58.300 --> 00:50:01.300
read it in using your
Read Picture or whatever.

00:50:01.480 --> 00:50:03.300
That's what you're going to have.

00:50:03.360 --> 00:50:04.320
OpenGL doesn't like that.

00:50:04.320 --> 00:50:07.300
It doesn't like taking that format in
and doesn't like handling that format.

00:50:07.300 --> 00:50:09.250
So what you need to do with that
is you need to swizzle the pixels.

00:50:09.340 --> 00:50:12.300
So what you're going to do is
read it into a different buffer.

00:50:12.300 --> 00:50:16.300
And you're going to take the RGB values
out of it and put it in the other buffer,

00:50:16.300 --> 00:50:21.410
set it up as just 3 byte values
or tuples of RGB values and

00:50:21.410 --> 00:50:23.300
use that for your texture,
send that into OpenGL.

00:50:23.300 --> 00:50:24.300
That's swizzling pixels.

00:50:24.300 --> 00:50:25.300
You have to do that.

00:50:25.300 --> 00:50:29.940
But we've just announced that we're
going to have packed pixel format

00:50:29.940 --> 00:50:32.750
support in our next version of GL,
which will be seeded to

00:50:32.820 --> 00:50:33.300
developers very shortly.

00:50:33.380 --> 00:50:37.030
And that will allow you to take
standard Macintosh pixel formats,

00:50:37.030 --> 00:50:41.300
like something you get in an off screen,
and apply it directly to a texture.

00:50:41.320 --> 00:50:42.300
So you can get that.

00:50:42.300 --> 00:50:45.300
You can do 1555 16 bit.

00:50:45.300 --> 00:50:47.290
If you want to fill the alpha channel in,
you can.

00:50:47.300 --> 00:50:48.280
Or you can blank the alpha channel.

00:50:48.360 --> 00:50:51.300
Or you can fill it in with ones and you
can send it directly into a texture.

00:50:51.300 --> 00:50:53.470
And there you go,
your texture mapping without

00:50:53.560 --> 00:50:55.210
having to do any pixel swizzling.

00:50:55.490 --> 00:50:57.030
Then we'll talk about
handling GL textures,

00:50:57.030 --> 00:51:01.090
just the basics of how to texture,
and we'll combine that with QuickTime.

00:51:07.150 --> 00:51:09.340
Magic.

00:51:09.340 --> 00:51:12.280
Let me show you the texture mapping demo.

00:51:12.610 --> 00:51:15.720
I just want to make sure I don't run
over and have time for the last demo.

00:51:15.780 --> 00:51:17.680
That's the only one I'm really,
really proud of.

00:51:17.800 --> 00:51:22.780
So this is just my-- I stole the
Maya face that the guys worked on and

00:51:22.840 --> 00:51:24.150
basically did texture mapping demo.

00:51:24.400 --> 00:51:26.350
Can you see that real well,
or is that really hard to see?

00:51:26.380 --> 00:51:28.470
I think it's probably hard to see.

00:51:28.970 --> 00:51:42.330
and I can see it.

00:51:42.330 --> 00:51:42.330
You can see the reflection
better than anything else.

00:51:42.330 --> 00:51:42.330
But basically,
you have the texture map floor,

00:51:42.330 --> 00:51:42.330
you have a reflection in the cube,
and the reflection in the

00:51:42.330 --> 00:51:42.330
cube is really simple.

00:51:42.330 --> 00:51:42.330
It's just the same thing.

00:51:42.330 --> 00:51:42.330
Did anyone notice
something's wrong with that?

00:51:44.860 --> 00:51:46.260
Exactly.

00:51:46.440 --> 00:51:47.790
The reflection is totally wrong.

00:51:47.800 --> 00:51:50.080
The reflection should be, in this case,
should be going,

00:51:50.090 --> 00:51:52.980
as it dives down the top,
the point should come up in the bottom.

00:51:52.980 --> 00:51:54.750
So that's all screwed up.

00:51:54.750 --> 00:51:58.540
But that's not the point of this,
so I can do that.

00:51:59.560 --> 00:52:01.920
And by the way, I mean,
this is a big thing for

00:52:02.030 --> 00:52:03.640
anyone who's using OpenGL.

00:52:03.640 --> 00:52:05.170
There's so many resources on the web.

00:52:05.170 --> 00:52:08.170
It's one of the-- the people who work
with OpenGL love to write about it,

00:52:08.180 --> 00:52:09.650
I guess, too,
or have seen their names in print.

00:52:09.790 --> 00:52:14.580
Because you go to www.opengl.org
and you follow the links there,

00:52:14.930 --> 00:52:19.120
and there is tons of stuff about
doing reflections correctly,

00:52:19.260 --> 00:52:21.300
what mistakes not to make.

00:52:21.300 --> 00:52:23.700
All that stuff is out on the web.

00:52:23.700 --> 00:52:25.110
It's great stuff.

00:52:25.150 --> 00:52:25.800
So what was I going to show you?

00:52:25.800 --> 00:52:25.800
Oh, texture mapping.

00:52:27.190 --> 00:52:29.530
Okay, load texture res.

00:52:29.590 --> 00:52:31.280
So what we're going to do is we're
going to again go to the bigger

00:52:31.280 --> 00:52:34.070
size so you can actually see this.

00:52:35.400 --> 00:52:43.540
I'm not going to worry
about the setup here,

00:52:43.550 --> 00:52:46.520
but I'm going to basically
do getPictureResID.

00:52:46.520 --> 00:52:47.620
We all know that.

00:52:47.680 --> 00:52:50.160
If you actually get the picture,
getPicInfo.

00:52:50.160 --> 00:52:51.880
The reason I want to get the
PicInfo is because I want to

00:52:51.980 --> 00:52:53.120
get the size of the picture.

00:52:53.160 --> 00:52:56.150
I want to create a new GWorld the
size of that picture if it's 32 bits.

00:52:56.150 --> 00:52:57.800
I want to actually lock the pixels.

00:52:57.800 --> 00:53:00.640
Remember to check to make sure
that the lock doesn't fail,

00:53:00.640 --> 00:53:02.670
because if it fails, you're in trouble.

00:53:02.790 --> 00:53:05.400
That's something you
should always be doing.

00:53:05.400 --> 00:53:08.310
The reason I say that actually is
partly because that's something you

00:53:08.310 --> 00:53:11.200
should do and partly because as we
move forward to 10 and there are

00:53:11.200 --> 00:53:13.630
actual locks and unlocks that matter,
locking pixels,

00:53:13.710 --> 00:53:15.820
if it doesn't let you lock it,
there may be a reason

00:53:15.820 --> 00:53:16.690
you can't draw with it.

00:53:16.800 --> 00:53:19.160
There really is something
you should pay attention to.

00:53:19.200 --> 00:53:21.360
I draw a picture into
the off-screen GWorld.

00:53:21.360 --> 00:53:22.320
I set the GWorld.

00:53:22.320 --> 00:53:25.760
Now here's the magic,
really simple magic here.

00:53:26.770 --> 00:53:29.130
Width, height, stride, base address.

00:53:29.130 --> 00:53:30.490
Width is the width of the picture.

00:53:30.590 --> 00:53:31.640
Height is the height of the picture.

00:53:31.640 --> 00:53:37.510
Stride is the actual
row-to-row distance in bytes.

00:53:37.870 --> 00:53:40.060
which is the row bytes,
the base address is the

00:53:40.150 --> 00:53:41.600
first address of the buffer.

00:53:41.640 --> 00:53:44.160
I create a new pointer,
so I create a buffer for my texture

00:53:44.160 --> 00:53:47.430
that's the size of the width and height,
and three for one byte

00:53:47.430 --> 00:53:49.300
for each RGB component.

00:53:49.400 --> 00:53:54.240
And then really simple, what I do is,
in this section, I pull out

00:53:56.150 --> 00:53:59.570
I pull out the... This is
offset by 4 because it's ARGB,

00:53:59.590 --> 00:54:01.860
so it's 4 bytes for each component.

00:54:01.860 --> 00:54:06.310
This is by 3, so it's RGB, 3 bytes,
and I pull out the 0

00:54:06.310 --> 00:54:10.280
and I pull out the red,
the green, the blue, in order,

00:54:10.280 --> 00:54:15.250
and then the simple call for OpenGL...
Now I have a buffer that's width

00:54:15.250 --> 00:54:20.380
by height that's set up for the
texture and I call glTextImage2D,

00:54:20.490 --> 00:54:26.630
Chuckster2D, 3 components, width, height,
RGB, unsigned bytes for the components,

00:54:26.630 --> 00:54:28.540
and the pointer to its buffer.

00:54:29.660 --> 00:54:31.740
Dispose pointer, dispose usual,
release resource.

00:54:31.740 --> 00:54:31.980
Boom.

00:54:32.040 --> 00:54:32.740
Done.

00:54:32.800 --> 00:54:33.910
That's all you need to do to texture.

00:54:34.020 --> 00:54:34.240
OK.

00:54:34.410 --> 00:54:36.220
But you have to get it to the screen.

00:54:36.300 --> 00:54:39.710
I think I have that somewhere.

00:54:42.190 --> 00:54:42.430
Okay.

00:54:42.430 --> 00:54:47.660
Little trickery here that I'm not going
to show you today but you can look up,

00:54:47.660 --> 00:54:49.050
this bind texture thing.

00:54:49.050 --> 00:54:51.100
I call it bind texture because
I only want to load the texture once.

00:54:51.100 --> 00:54:54.260
So actually I load the
texture right here,

00:54:54.260 --> 00:54:55.060
that call.

00:54:55.060 --> 00:54:59.860
I call bind texture to say I want
to pay attention to the marble,

00:54:59.860 --> 00:55:02.610
lightning or the face or the mask.

00:55:02.740 --> 00:55:06.130
So I say pay attention to this,
set these parameters for the texture,

00:55:06.130 --> 00:55:07.250
load the texture.

00:55:07.260 --> 00:55:10.690
And then every time I call bind texture
I'm saying I want to use that texture.

00:55:10.690 --> 00:55:13.240
So I go back down here
and I say bind texture.

00:55:13.240 --> 00:55:14.290
So I want to use the mask.

00:55:14.380 --> 00:55:19.110
I then go to draw cube and draw cube
says here's a texture coordinate,

00:55:19.110 --> 00:55:20.300
0, 0, 0.

00:55:20.300 --> 00:55:24.190
Here's a vertex coordinate which
is a position for that face vertex.

00:55:24.190 --> 00:55:27.230
Texture coordinate 0, 1, 1, 1, 0.

00:55:27.230 --> 00:55:30.070
If you notice I'm just
walking around the polygon.

00:55:30.070 --> 00:55:31.950
I'm just boom, boom,
boom all four corners.

00:55:32.120 --> 00:55:33.810
Textures are going to be mapped 0 to 1.

00:55:33.810 --> 00:55:36.840
So what happens when you map a 0 to 1,
it makes it really easy for you to map

00:55:36.840 --> 00:55:39.810
a full texture to a polygon because
you just map the corners to the

00:55:39.810 --> 00:55:41.630
right places 0 to 1 and it's simple.

00:55:41.650 --> 00:55:42.060
It's gone.

00:55:42.060 --> 00:55:42.960
Done.

00:55:43.180 --> 00:55:43.510
Perfect.

00:55:43.610 --> 00:55:44.140
Awesome.

00:55:44.140 --> 00:55:44.810
We're done.

00:55:44.840 --> 00:55:47.820
We're not done, but we're done with that.

00:55:47.820 --> 00:55:51.240
So texture mapping is not hard.

00:55:51.240 --> 00:55:55.560
I think that's all I need
to show you on that one.

00:55:55.560 --> 00:55:57.440
So we saw that.

00:55:57.440 --> 00:55:59.790
And then I have--

00:56:01.290 --> 00:56:02.270
Swizzling texture updates.

00:56:02.400 --> 00:56:04.010
Oh, texture updates.

00:56:04.140 --> 00:56:05.360
Oh, I'll show you this one.

00:56:05.360 --> 00:56:08.190
This is actually the demo I'm kind of
actually thinking is actually reasonable.

00:56:08.190 --> 00:56:12.340
Do you want to see what
Steve and those guys showed,

00:56:12.340 --> 00:56:14.190
or do you want to see
a different trailer?

00:56:16.580 --> 00:56:21.100
This is the large size
of the dinosaur trailer.

00:56:21.100 --> 00:56:23.020
Basically what it is,
is QuickTime playing it into an

00:56:23.020 --> 00:56:26.930
off-screen and then playing it,
and you should see it in a second

00:56:26.930 --> 00:56:28.700
because it's actually dark to start with.

00:56:28.700 --> 00:56:32.690
Oh, I'm sorry, one thing,
that is really dark.

00:56:33.890 --> 00:56:37.200
Can you turn down, is there a way to turn
down some of these lights?

00:56:37.310 --> 00:56:37.830
Yeah, turn them off.

00:56:37.930 --> 00:56:40.450
They don't need to see me.

00:56:40.450 --> 00:56:40.450
I'm ugly.

00:56:43.150 --> 00:56:46.720
Thank you, I appreciate it.

00:56:46.760 --> 00:56:47.540
Okay.

00:56:47.570 --> 00:56:51.250
OpenGL Texture,
and you can't see the cool part is,

00:56:51.250 --> 00:56:54.710
which I'm, you can't really see,
is this is running at 99, 89,

00:56:54.710 --> 00:56:56.780
this is running at about
100 frames per second.

00:56:56.870 --> 00:56:58.870
So it's texture mapping from
a QuickTime movie onto the

00:56:58.960 --> 00:57:00.750
texture at 100 frames per second.

00:57:00.900 --> 00:57:03.350
So it's blowing away the QuickTime movie,
it easily can update at the

00:57:03.420 --> 00:57:04.660
rate the QuickTime movie is.

00:57:04.690 --> 00:57:08.240
And one thing I have here also is,
I have a fog set up,

00:57:08.390 --> 00:57:10.020
so as it fades out it actually is fading.

00:57:10.020 --> 00:57:13.500
That's why you get the
fade as it goes away.

00:57:13.500 --> 00:57:16.300
So it actually, that's not a mistake,
I set it up on purpose

00:57:16.300 --> 00:57:19.280
with a black fog to go out,
fade in, fade out.

00:57:19.350 --> 00:57:21.240
And there actually is sound
playing with it and all that stuff,

00:57:21.310 --> 00:57:22.350
we don't have that hooked up.

00:57:22.430 --> 00:57:23.500
So, but that's not a big deal.

00:57:23.550 --> 00:57:26.300
So this is a real simple,
it's playing the trailer,

00:57:26.530 --> 00:57:28.040
and if I click it ends.

00:57:28.100 --> 00:57:30.710
And if you notice that
all I can do is just pick,

00:57:30.850 --> 00:57:33.270
I'll play the same one they always play.

00:57:33.350 --> 00:57:36.040
You can leave the lights down still.

00:57:36.100 --> 00:57:38.480
It plays any movie.

00:57:38.520 --> 00:57:40.020
No big deal, no tricks, no.

00:57:40.020 --> 00:57:41.040
No, nothing.

00:57:44.300 --> 00:57:45.990
So, can we do that at home, right?

00:57:46.000 --> 00:57:46.600
Is that easy?

00:57:46.600 --> 00:57:48.900
Actually, if someone wants to bring the
lights up or leave them down,

00:57:48.900 --> 00:57:51.000
I don't care,
and I have a couple minutes here

00:57:51.000 --> 00:57:53.180
to actually show you how I did it.

00:57:53.280 --> 00:57:56.100
The texturing routine is
almost exactly the same.

00:57:56.100 --> 00:57:59.090
I basically use some of the
utilities that we have out there.

00:57:59.170 --> 00:58:01.440
I sat around for about a
couple hours and figured out,

00:58:01.440 --> 00:58:03.530
hey, this is not that hard to do.

00:58:03.660 --> 00:58:10.170
And the key here is, I have a movie,
and let me show you the section

00:58:10.180 --> 00:58:12.740
that I want to show you.

00:58:32.500 --> 00:58:32.720
This is a very simple task fog setup.

00:58:32.720 --> 00:58:33.040
By the way, this is all that was
required to set any fog.

00:58:33.070 --> 00:58:33.310
Start, an end, linear fog,
and a fog color.

00:58:33.580 --> 00:58:34.500
Real simple.

00:58:34.600 --> 00:58:37.500
I enable textures at the top.

00:58:37.500 --> 00:58:39.420
I set a clear color,
which is really pretty simple.

00:58:39.500 --> 00:58:41.500
I empty my texture buffer,
which is pretty simple.

00:58:41.500 --> 00:58:44.500
Here's the quick time
to texture conversion.

00:58:44.760 --> 00:58:48.210
Basically what I'm doing is I have
a texture size and I want to set

00:58:48.320 --> 00:58:50.500
offsets into subsample the movie.

00:58:50.500 --> 00:58:52.490
I set these up ahead of time right here.

00:58:52.500 --> 00:58:54.750
I'm going to put the code on
the web so people can really

00:58:54.820 --> 00:58:56.500
look at exactly how I do it.

00:58:56.500 --> 00:59:00.300
The key is to find all your offsets
into an array so I can do an array

00:59:00.300 --> 00:59:02.180
offset into the actual texture.

00:59:02.670 --> 00:59:05.370
When I come down to make texture,

00:59:05.830 --> 00:59:12.700
If you notice,
basically I'm taking the offsets into,

00:59:12.700 --> 00:59:19.690
I get my Pixmap,
which is the Pixmap for the movie,

00:59:19.690 --> 00:59:23.960
base address, I got that,
I set up my array for my texture,

00:59:24.300 --> 00:59:28.200
and I work through this by
offsetting from my Gmovie,

00:59:28.200 --> 00:59:34.230
which is the texture, into my,
using my base address for the 4, the RGB,

00:59:34.370 --> 00:59:35.680
and I offset correctly into the array.

00:59:35.700 --> 00:59:39.700
The array is already offset
to avoid the alpha value.

00:59:39.700 --> 00:59:41.600
It's a little trickery there,
but not too complicated.

00:59:41.730 --> 00:59:44.680
I mean, that's all the code that
does to handle the texture.

00:59:44.850 --> 00:59:48.070
If you notice, in this code,
that's all the stuff to

00:59:48.070 --> 00:59:51.430
do the window moving,
and all I call is Make Texture,

00:59:51.610 --> 00:59:54.700
and then the key other
line is glTexSubImage2D.

00:59:54.700 --> 00:59:57.110
Once I call texture once,
I can call glTexSubImage2D,

00:59:57.240 --> 01:00:00.060
doesn't recreate the texture,
all it's going to do is update the

01:00:00.060 --> 01:00:03.100
contents of the texture on the card,
so it keeps filling

01:00:03.300 --> 01:00:05.700
stuff more to the card,
a little faster than the normal texture.

01:00:05.700 --> 01:00:09.700
And then I can make the
glTexture text image 2D.

01:00:09.700 --> 01:00:12.680
And I really don't want to
go through the text image 2D,

01:00:12.760 --> 01:00:14.620
I mean, I guess I can run it.

01:00:15.100 --> 01:00:19.680
I'll do that to let people know that
I don't think there's going to be

01:00:19.680 --> 01:00:23.360
much of a degradation at all in this,
but that's another way to do

01:00:23.430 --> 01:00:26.710
it if you have textures that
are changing all the time.

01:00:28.700 --> 01:00:32.250
And I'll tell you what the frame rate is.

01:00:32.360 --> 01:00:33.700
87 instead of 100.

01:00:33.700 --> 01:00:36.940
So I lost 10 frames per
second by doing it this way.

01:00:37.050 --> 01:00:40.400
So, and if anyone's interested,
they really want to see,

01:00:40.400 --> 01:00:44.060
I know you can't see the
frame rate counter up there.

01:00:44.140 --> 01:00:46.510
Absolutely,
you're welcome to come up and look at it.

01:00:46.590 --> 01:00:50.300
And again, the code will be up so you can
look at the code and figure it out.

01:00:50.470 --> 01:00:55.880
So, if we can switch back to this one.

01:00:57.540 --> 01:00:57.870
Roadmap.

01:00:57.880 --> 01:00:59.860
Okay,
what are we doing next with QuickTime?

01:00:59.860 --> 01:01:02.790
In this room, right after this,
is the advanced optimization.

01:01:02.880 --> 01:01:08.880
John Stauffer has graciously given his
time to put some cool demos together,

01:01:08.880 --> 01:01:12.080
talked about optimization with QuickTime,
or sorry, QuickTime OpenGL,

01:01:12.080 --> 01:01:13.440
and talked about how to do that.

01:01:13.440 --> 01:01:14.460
He's going to talk about how to do that.

01:01:14.480 --> 01:01:16.660
And then we have the feedback
form right after lunch.

01:01:16.740 --> 01:01:20.140
Please,
if you have anything to say about OpenGL,

01:01:20.140 --> 01:01:22.380
about 3D direction on Apple,
come to the feedback form.

01:01:22.380 --> 01:01:25.700
We'd love to hear any of your opinions,
comments, goods, others,

01:01:25.700 --> 01:01:26.470
whatever you have.

01:01:26.830 --> 01:01:29.470
We'll take them down and we'll take
them in and try and get you the best

01:01:29.640 --> 01:01:32.240
3D implementation out there anywhere.
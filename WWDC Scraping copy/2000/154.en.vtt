WEBVTT

00:00:10.850 --> 00:00:11.800
I'm Chris Espinosa.

00:00:11.800 --> 00:00:16.300
If you were at the earlier session,
the AppleScript overview session,

00:00:16.380 --> 00:00:18.540
you've heard a lot from me.

00:00:25.430 --> 00:00:28.670
If I press the forward button
and the machine just bings,

00:00:28.670 --> 00:00:30.710
what does that mean?

00:00:39.810 --> 00:00:42.500
This session is going to be a lot
different than the overview this morning.

00:00:42.500 --> 00:00:44.670
This is a very code-oriented session.

00:00:44.670 --> 00:00:47.830
If you are looking to learn
how to script in AppleScript,

00:00:48.070 --> 00:00:50.790
now would be a fine time
to debark this aircraft.

00:00:50.860 --> 00:00:53.640
We are going to be
talking about C++ code.

00:00:53.640 --> 00:00:56.580
We're going to be talking about classes.

00:00:56.580 --> 00:00:59.680
We're going to be talking about
a lot of things that are only of

00:00:59.770 --> 00:01:04.030
interest to people who are writing
applications that want to be scriptable.

00:01:04.220 --> 00:01:07.510
If you are a scripter,
don't hurt yourself by

00:01:07.510 --> 00:01:09.470
trying to listen to me.

00:01:09.690 --> 00:01:16.320
Go to www.apple.com/applescript and
download some of Sal Sehgoyen's very,

00:01:16.320 --> 00:01:20.600
very fine AppleScript guidebook
modules on how to write AppleScripts.

00:01:20.700 --> 00:01:25.330
For those of the rest of you,
if you want to learn how to make a

00:01:25.330 --> 00:01:30.700
scriptable application in C or C++,
you're in the right place.

00:01:32.700 --> 00:01:34.690
Good.

00:01:34.780 --> 00:01:38.700
What you're going to learn in this
session is why there are relatively

00:01:38.700 --> 00:01:43.140
few good scriptable applications
on the Macintosh platform,

00:01:43.300 --> 00:01:44.360
because it's hard.

00:01:44.370 --> 00:01:49.090
There are a lot of bad scriptable
applications on the Macintosh

00:01:49.250 --> 00:01:52.520
platform because it's easier to
make a bad scriptable application

00:01:52.520 --> 00:01:54.660
than a good scriptable application.

00:01:55.620 --> 00:01:56.590
Frameworks can help.

00:01:56.590 --> 00:01:59.490
Frameworks can help by doing
a lot of the work for you.

00:01:59.500 --> 00:02:01.090
Frameworks can hurt.

00:02:01.170 --> 00:02:04.560
Frameworks can hurt because you
assume they're doing a lot of the

00:02:04.560 --> 00:02:06.290
work for you when they're not.

00:02:06.350 --> 00:02:11.330
So we're going to tell what it does for
you versus what you have to do yourself.

00:02:12.900 --> 00:02:15.140
We're going to talk a
lot about PowerPlant.

00:02:15.360 --> 00:02:18.840
There has been a very good
PowerPlant solution out there.

00:02:18.840 --> 00:02:22.300
Greg Dow put a lot of work
into making some good scripting

00:02:22.400 --> 00:02:23.930
classes in PowerPlant.

00:02:23.930 --> 00:02:27.230
And it's the most widely
distributed and widely used

00:02:27.230 --> 00:02:29.930
application framework for Macintosh.

00:02:30.030 --> 00:02:31.490
So we're going to be
focusing a lot on that.

00:02:31.590 --> 00:02:33.240
And then we'll be covering
some alternatives.

00:02:33.880 --> 00:02:37.700
One of the alternatives I want to
stress is a relatively new one,

00:02:37.870 --> 00:02:41.450
which DTS put up just last
week as the More OSL package.

00:02:41.450 --> 00:02:46.930
If you're familiar with More Files,
More Apple Events, More Toolbox from DTS,

00:02:46.930 --> 00:02:51.330
which basically fills in for
developers the functionality that

00:02:51.330 --> 00:02:55.780
developers want in the OS that
the OS designers didn't put there,

00:02:55.780 --> 00:03:00.030
well, this is another in that long
and esteemed series of software

00:03:00.610 --> 00:03:03.170
codebases that does just that.

00:03:03.820 --> 00:03:07.400
DTS has done a wonderful job
of responding to what the most

00:03:07.490 --> 00:03:11.590
frequently asked developer gripes
about how to write scriptable

00:03:11.730 --> 00:03:17.210
applications are and filling that in
in a very coherent and manageable way.

00:03:17.250 --> 00:03:18.800
It's a great piece of work,
and I'm going to be

00:03:18.800 --> 00:03:19.920
walking you through that.

00:03:19.920 --> 00:03:24.050
Let's start with some background,
because I know that some

00:03:24.050 --> 00:03:28.310
of you are approaching
scriptability for the first time.

00:03:29.300 --> 00:03:32.560
AppleScript and the
Open Scripting Architecture,

00:03:32.560 --> 00:03:37.600
OSA, is a way for a high-level language,
a user-written script,

00:03:37.620 --> 00:03:41.370
to send events to applications
so that applications can act on

00:03:41.380 --> 00:03:43.440
those events and execute them.

00:03:43.700 --> 00:03:49.310
And the biggest problem that we find,
the biggest sin that is committed,

00:03:49.320 --> 00:03:53.510
is applications that simply
expose a flat programmer's

00:03:53.570 --> 00:03:56.320
API to the scripting language.

00:03:56.320 --> 00:03:59.960
A whole lot of events and
not a lot of information.

00:03:59.960 --> 00:04:03.150
Because what we've found over the
years with what is popular with

00:04:03.380 --> 00:04:06.560
scripters in AppleScript is that
they don't just want to send a

00:04:06.560 --> 00:04:08.580
bunch of events to applications.

00:04:08.620 --> 00:04:12.400
They want to get and set
information within that application.

00:04:12.560 --> 00:04:15.600
And the information they
want to get and set is the

00:04:15.600 --> 00:04:20.340
information on the user's model,
the conceptual model of the

00:04:20.530 --> 00:04:22.410
information inside that application.

00:04:22.420 --> 00:04:26.760
Rather than clicking a checkbox or
pushing a button or choosing a menu item,

00:04:26.760 --> 00:04:31.240
they want to get the value of something
or they want to create a new user

00:04:31.240 --> 00:04:33.760
object somewhere in the document.

00:04:33.800 --> 00:04:38.760
It's not, you know,
an automation like a macro maker

00:04:39.230 --> 00:04:42.020
or a playback or recording.

00:04:42.470 --> 00:04:46.140
It's more like we want to make queries
on the data in your application,

00:04:46.180 --> 00:04:48.820
make intelligent decisions
based on that data,

00:04:49.070 --> 00:04:52.010
and then do something
that manipulates the data,

00:04:52.010 --> 00:04:54.110
not manipulating the application.

00:04:54.400 --> 00:04:57.890
Because most of the really,
really good process automation

00:04:57.900 --> 00:05:02.390
and workflow solutions that are
built using AppleScript are very,

00:05:02.390 --> 00:05:06.090
very data-driven, not command-driven.

00:05:06.310 --> 00:05:08.940
And this is why the object
model is so important.

00:05:09.030 --> 00:05:10.200
And what is the object model?

00:05:10.200 --> 00:05:15.950
The object model is the way that
OSA languages access the user-visible

00:05:15.950 --> 00:05:17.980
information in your application.

00:05:17.980 --> 00:05:22.960
And it applies a human terminology
to the programmatic elements

00:05:22.960 --> 00:05:24.200
inside your application.

00:05:24.200 --> 00:05:29.130
The two biggest things people do is, one,
is that they just provide an event

00:05:29.240 --> 00:05:33.340
interface and no object interface
so that the users can't see the

00:05:33.340 --> 00:05:36.180
objects because of all these events.

00:05:36.200 --> 00:05:40.290
And two is that they fail to
give human names to the objects

00:05:40.990 --> 00:05:45.650
within their applications and
just basically propagate the C++

00:05:45.650 --> 00:05:49.010
identifiers up to the scriptor levels.

00:05:49.910 --> 00:05:52.730
And that's confusing to people.

00:05:53.030 --> 00:05:57.200
An object is-- can be,
but is not necessarily-- your

00:05:57.200 --> 00:06:01.700
concept of a programmatic
object inside your application.

00:06:01.830 --> 00:06:06.500
If you look at the model view
controller paradigm for developing

00:06:06.570 --> 00:06:09.260
an object-oriented application,
what we're really talking

00:06:09.260 --> 00:06:10.910
about is the model.

00:06:10.920 --> 00:06:12.300
We're not talking about the view.

00:06:12.300 --> 00:06:14.250
We're not talking about how
it's drawn on the screen.

00:06:14.260 --> 00:06:17.440
And we're not talking about the
controller-- how it's manipulated.

00:06:17.600 --> 00:06:21.000
We're talking about the
existence of the object and the

00:06:21.000 --> 00:06:23.590
properties that that object has.

00:06:23.600 --> 00:06:27.500
Those properties can be read and set,
preferably from the scripting language.

00:06:27.600 --> 00:06:30.620
It's of a designated class,
so it can be told apart from

00:06:30.620 --> 00:06:31.760
other things of that class.

00:06:31.820 --> 00:06:35.610
And that class may be in a hierarchy,
and it can share some things or

00:06:35.610 --> 00:06:38.010
inherit some things from other classes.

00:06:38.130 --> 00:06:43.620
It can be a container of other objects,
like a window can contain data elements,

00:06:43.620 --> 00:06:47.460
or a folder can contain files,
or a page can contain graphs.

00:06:47.460 --> 00:06:52.660
Graphic objects or a paragraph
can contain words or characters.

00:06:52.780 --> 00:06:56.290
And it can be contained
by other objects as well.

00:06:56.610 --> 00:07:01.250
We script objects,
and the best scriptable applications

00:07:01.300 --> 00:07:04.460
are those that use as few verbs
as possible to script all of the

00:07:04.500 --> 00:07:06.200
objects in your applications.

00:07:06.310 --> 00:07:09.610
That's a subjective statement,
but I lay claim to it.

00:07:10.060 --> 00:07:14.800
The way that AppleScript and
OSA languages designate to your

00:07:14.800 --> 00:07:18.160
application what they're trying to
act on is through this structure

00:07:18.160 --> 00:07:19.640
called an object specifier.

00:07:19.640 --> 00:07:23.900
And an object specifier is possibly the
most heinous data structure you're going

00:07:23.900 --> 00:07:26.310
to come across in Macintosh programming.

00:07:26.320 --> 00:07:28.760
It can be incredibly complex.

00:07:28.840 --> 00:07:31.340
It can be vague and ambiguous.

00:07:31.340 --> 00:07:34.700
It can be very detailed
in inappropriate places.

00:07:35.200 --> 00:07:40.290
And there are 247 different variants
that you have to special case

00:07:40.290 --> 00:07:43.950
to make sure that when somebody
sends you an object specifier,

00:07:43.970 --> 00:07:46.210
you understand really what
they're talking about.

00:07:46.260 --> 00:07:49.660
Because what it does is it drills
down from the top level of your

00:07:49.660 --> 00:07:53.980
application down to a specific piece
of data in your application and can

00:07:54.070 --> 00:07:58.080
get there through multiple routes.

00:07:58.080 --> 00:08:02.280
And you don't necessarily have to
have a strict containment tree.

00:08:02.280 --> 00:08:05.010
So it can really go through
pretty bizarre ways.

00:08:05.040 --> 00:08:09.950
Let me show you,
I'll show you a little later how complex

00:08:10.250 --> 00:08:13.080
and how weird object specifiers can be.

00:08:14.410 --> 00:08:17.740
The way you get an object
specifier is as an Apple event

00:08:17.750 --> 00:08:19.880
record that is deeply nested.

00:08:20.030 --> 00:08:22.970
It's going to look on the top level like,
"Oh, this is easy.

00:08:23.080 --> 00:08:26.650
It's an Apple event record with
four parts to it." But then one of

00:08:26.650 --> 00:08:29.860
those parts is an object specifier
which has four parts to it,

00:08:29.900 --> 00:08:33.960
which can be an object specifier
that has four parts to it.

00:08:33.960 --> 00:08:37.560
And it can go on, down, and down,
and down.

00:08:37.560 --> 00:08:40.940
The four parts are basically
the container of the object,

00:08:40.940 --> 00:08:45.500
that's the from part,
the type of data that's being requested,

00:08:45.500 --> 00:08:49.270
which is the want,
how to select a value from the container,

00:08:49.270 --> 00:08:51.320
which is the key form,
and we'll be talking

00:08:51.320 --> 00:08:55.240
a lot about key forms,
and then using that key form,

00:08:55.240 --> 00:08:56.590
which one to pick.

00:08:57.080 --> 00:09:03.320
So if I say I want folder
one of startup disk,

00:09:03.590 --> 00:09:09.060
that's basically from is startup disk,
want is a folder,

00:09:09.060 --> 00:09:11.120
form is by absolute position.

00:09:11.120 --> 00:09:11.120
And then the other part is the
data that's being requested,

00:09:11.120 --> 00:09:11.120
which is the want.

00:09:11.120 --> 00:09:11.120
So that's the from part.

00:09:11.120 --> 00:09:11.120
The type of data that's being requested,
which is the want.

00:09:11.120 --> 00:09:11.120
How to select a value from the container,
which is the key form,

00:09:11.120 --> 00:09:11.120
and we'll be talking
a lot about key forms,

00:09:11.120 --> 00:09:11.120
and then using that key form,
which one to pick.

00:09:11.120 --> 00:09:13.000
So if I say I want folder one
of and selection data is one.

00:09:13.040 --> 00:09:17.010
That's a fairly simple object specifier,
but they can be more complex.

00:09:17.120 --> 00:09:21.940
For example, the object specifier,
the modification date of file 2 through

00:09:21.940 --> 00:09:26.530
file 4 of folder applications of startup
disk is nested kind of like this.

00:09:26.600 --> 00:09:31.080
In the top level on the outside,
you're looking for the property.

00:09:31.080 --> 00:09:32.960
You want a property.

00:09:32.960 --> 00:09:35.580
The selection is the
code for that property,

00:09:35.580 --> 00:09:37.110
which is the modification date.

00:09:38.180 --> 00:09:43.050
And the container is,
you want the property of a file.

00:09:43.060 --> 00:09:46.710
So the next thing is,
you want a file selected

00:09:46.840 --> 00:09:48.580
by the key form range.

00:09:48.580 --> 00:09:52.550
The key form range is going
to make two parts come.

00:09:52.560 --> 00:09:56.180
You want the selection data,
which itself is a record

00:09:56.180 --> 00:09:59.730
with a start and a stop,
and the start's going to be,

00:09:59.740 --> 00:10:03.690
you want form index,
you want a file from the

00:10:04.030 --> 00:10:08.160
current container index 2,
and the stop is going,

00:10:08.180 --> 00:10:12.210
you want a file index,
that's actually wrong,

00:10:12.220 --> 00:10:13.420
that should be index 4.

00:10:13.420 --> 00:10:16.460
See how easy it is to make a mistake?

00:10:16.510 --> 00:10:20.580
So you want start at 2,
stop at 4 from the current container,

00:10:20.580 --> 00:10:23.480
and then the last thing,
the from goes all the way

00:10:23.480 --> 00:10:30.060
down to the bottom there,
and is by name, the selection, a folder,

00:10:30.060 --> 00:10:34.190
the selection data is, quote,
applications from the startup disk.

00:10:34.200 --> 00:10:38.160
And the startup disk's container is null,
which means it's rooted at the app,

00:10:38.210 --> 00:10:54.230
it's a from an Apple script.

00:10:54.290 --> 00:10:59.940
And then this is a parameter to an event,
which can be, get the modification date,

00:10:59.940 --> 00:11:04.810
set the modification date,
or this could be just a clause in a,

00:11:04.850 --> 00:11:08.160
you know, delete every file,
who's modifying it,

00:11:08.160 --> 00:11:10.260
who's modification date, you know,
et cetera.

00:11:10.260 --> 00:11:15.840
So, it's, object specifiers can
be arbitrarily complex,

00:11:16.080 --> 00:11:18.740
and if you tried to write
code yourself to parse this,

00:11:18.760 --> 00:11:20.180
you'd go fairly nuts.

00:11:20.180 --> 00:11:21.840
I know, because people have.

00:11:24.120 --> 00:11:25.740
Here are the basic key forms.

00:11:25.740 --> 00:11:29.310
One of the reasons is the
combinatorial problems of all of

00:11:29.410 --> 00:11:33.160
your containers against all of your
objects versus all of the key forms.

00:11:33.160 --> 00:11:35.770
And so, before you go into that,
you really need to know

00:11:35.770 --> 00:11:36.670
what the key forms are.

00:11:36.830 --> 00:11:39.860
The most familiar one
is by numeric index,

00:11:40.100 --> 00:11:41.970
file one, first page.

00:11:42.050 --> 00:11:45.400
That's the form absolute position.

00:11:45.400 --> 00:11:49.330
And the selection data you're
going to get is usually an integer,

00:11:49.330 --> 00:11:50.430
which is very nice.

00:11:50.430 --> 00:11:55.070
Now, one of the things to remember is
that you are in control of this.

00:11:55.070 --> 00:11:59.530
So you can be expecting any selection
data you want in form absolute position.

00:11:59.540 --> 00:12:03.580
So you could make form absolute
position any arbitrary thing.

00:12:03.750 --> 00:12:05.400
You could make it a string.

00:12:05.400 --> 00:12:08.830
As long as it identifies
what you're talking about,

00:12:08.910 --> 00:12:13.910
AppleScript will tend to do that
in the form absolute position.

00:12:14.160 --> 00:12:25.400
If you say window quote untitled
or folder quote preferences,

00:12:25.500 --> 00:12:27.880
that's going to trigger
the by name key form,

00:12:27.990 --> 00:12:28.950
form name.

00:12:28.950 --> 00:12:32.390
And your selection data for
that is usually a string.

00:12:32.420 --> 00:12:38.590
And it's usually going to be
a string in the system script.

00:12:38.640 --> 00:12:40.790
We don't have Unicode
selection yet for that,

00:12:40.790 --> 00:12:43.150
so it's going to be a
string in the system script.

00:12:44.300 --> 00:12:45.700
Those are the two main ones.

00:12:45.730 --> 00:12:49.190
And if all you support is
by numeric index and by name

00:12:49.190 --> 00:12:51.500
and you support them well,
that's okay.

00:12:51.500 --> 00:12:54.700
For certain classes,
Unique ID is going to be interesting,

00:12:54.700 --> 00:12:56.700
but it really had better be unique.

00:12:56.780 --> 00:13:02.870
Form Unique ID means I want this thing
regardless of what its index is because

00:13:02.870 --> 00:13:08.570
its index may change and what its
name is because its name may change.

00:13:08.640 --> 00:13:09.850
I mean, think of this.

00:13:09.850 --> 00:13:14.080
If you're writing a script that's
trying to script a finder folder,

00:13:14.080 --> 00:13:14.080
you're going to have to
write a finder folder.

00:13:14.100 --> 00:13:17.720
And you want to change its name.

00:13:17.720 --> 00:13:20.890
And when you change its name,
its index changes in the list

00:13:20.890 --> 00:13:24.440
because the finder automatically
resorts the list by name.

00:13:24.440 --> 00:13:28.670
How are you going to refer to that
thing again if you've changed its name?

00:13:28.670 --> 00:13:32.230
And if you don't know what the name is
and don't know what the new index is,

00:13:32.240 --> 00:13:34.600
you're really going to need
to hold on to something,

00:13:34.600 --> 00:13:36.140
and that's what the Unique ID is for.

00:13:36.140 --> 00:13:41.420
So what you'd write in the finder
is set X to ID of folder foo.

00:13:41.420 --> 00:13:44.730
Set name of folder foo to... bar.

00:13:45.230 --> 00:13:48.460
And then it's no longer folder foo,
it's folder bar.

00:13:48.710 --> 00:13:51.600
And its index is different,
but the ID is the same.

00:13:51.600 --> 00:13:56.290
And then you can say folder ID M,
and you'll be able to

00:13:56.290 --> 00:13:58.800
work on that folder again.

00:13:59.190 --> 00:14:00.960
Those are the simple key forms.

00:14:01.060 --> 00:14:05.600
The more complex ones
to handle are before,

00:14:05.600 --> 00:14:07.840
after another element,
that's relative position.

00:14:07.840 --> 00:14:12.240
This is how you insert things in
the list or append things to a list.

00:14:12.360 --> 00:14:13.900
It's usually used with text.

00:14:13.900 --> 00:14:16.140
That's form relative position.

00:14:16.180 --> 00:14:19.720
And form relative position is
basically a tuple of an absolute

00:14:20.380 --> 00:14:24.160
position or any other reference,
any other object specifier.

00:14:24.160 --> 00:14:28.690
And then a tag that says before or after.

00:14:29.100 --> 00:14:34.750
As a range of items is a pair of the
start element and the stop element,

00:14:34.750 --> 00:14:38.750
which both can be any
arbitrary object specifiers.

00:14:38.750 --> 00:14:42.340
And that's how you do page
one through three in Quark,

00:14:42.580 --> 00:14:43.600
for example.

00:14:43.600 --> 00:14:47.620
And then satisfying a test,
which is the most interesting one.

00:14:47.620 --> 00:14:53.860
It's every folder whose name
starts with or ends with .jpg.

00:14:53.860 --> 00:14:56.310
A very useful thing to do in the finder.

00:14:56.320 --> 00:14:58.830
That's the form test and the form whose.

00:14:59.100 --> 00:15:04.280
In order to make your object model
really usable by all of these,

00:15:04.280 --> 00:15:09.830
all of these key forms can be
compiled by the Apple script language.

00:15:10.060 --> 00:15:11.730
And so users can use these.

00:15:11.740 --> 00:15:17.080
You should document in your scripting
terminology in your dictionary which

00:15:17.080 --> 00:15:20.140
objects support which key forms,
just to not mislead people.

00:15:20.140 --> 00:15:22.500
Apple script will pay
no attention to that.

00:15:22.540 --> 00:15:22.610
It will try to compile all of
these key forms regardless of

00:15:22.620 --> 00:15:22.660
what you say in your terminology.

00:15:22.660 --> 00:15:22.730
It will generate these object specifiers.

00:15:22.730 --> 00:15:22.820
It will send you a message that says,
"This is a good idea.

00:15:22.820 --> 00:15:23.100
I'm going to use this."
And then you can use it to make

00:15:23.100 --> 00:15:23.100
your application scriptable.

00:15:24.160 --> 00:15:25.080
So, you can use this.

00:15:29.150 --> 00:15:31.810
And then you can send them
to your application and your

00:15:31.830 --> 00:15:34.640
application will either say,
"I don't support this key

00:15:34.640 --> 00:15:35.850
form," or do it right.

00:15:35.850 --> 00:15:39.720
Now too often, applications don't say,
"I don't support this key form,"

00:15:39.720 --> 00:15:41.160
and they don't do it right.

00:15:41.160 --> 00:15:44.100
And they just take a wild
stab and return an error.

00:15:44.100 --> 00:15:46.600
And what we--if there's one
thing I'd like to come out of

00:15:46.600 --> 00:15:49.440
this session is people at least
being honest with scripters,

00:15:49.540 --> 00:15:52.080
both in their terminology
and in their implementation,

00:15:52.080 --> 00:15:54.260
what key forms are
supported on what objects.

00:15:54.260 --> 00:15:58.100
And that's a hard thing to do because
you have to be honest with the scripter.

00:15:59.100 --> 00:16:02.550
have to know them all and
know all their combinations.

00:16:03.870 --> 00:16:07.560
Because all of the example,
users can come up with wonderful,

00:16:07.560 --> 00:16:11.800
wonderful phrases in AppleScript that
your application just can't handle.

00:16:11.810 --> 00:16:15.690
Like, name of every track of movie
one who's enabled is true.

00:16:15.690 --> 00:16:18.630
Or modification date of every file
of folders one through two of every

00:16:18.630 --> 00:16:20.800
folder whose name starts with A.

00:16:20.910 --> 00:16:23.560
All of these generate
valid object specifiers.

00:16:23.800 --> 00:16:26.800
And your application,
if you say you've got an object model

00:16:26.800 --> 00:16:29.280
and you've got all these objects,
you should be able to

00:16:29.280 --> 00:16:31.380
handle things like this.

00:16:32.430 --> 00:16:33.400
How do you handle this?

00:16:33.400 --> 00:16:37.080
The process of handling these is
something called object resolution.

00:16:37.160 --> 00:16:40.180
And basically,
when an event comes in and there's

00:16:40.190 --> 00:16:44.360
an object specifier in its parameter,
your first task is to resolve that

00:16:44.360 --> 00:16:48.730
object to some indication of what
the thing is in your application that

00:16:48.730 --> 00:16:50.280
that object specifier represents.

00:16:50.280 --> 00:16:53.890
What you have to do is you have
to descend in the structure

00:16:53.890 --> 00:16:58.270
until you find that from null,
which means, oh, that's the root object.

00:16:58.970 --> 00:17:01.790
And then you have to back out,
looking at each key form

00:17:01.790 --> 00:17:05.810
and selection data in turn,
and then maybe walking back down and

00:17:05.940 --> 00:17:10.220
doing it again if it's like a range form
and you need to descend into those object

00:17:10.280 --> 00:17:14.080
specifiers and figure out what they mean.

00:17:14.080 --> 00:17:17.760
Descending from that root,
just basically unpack the object

00:17:17.760 --> 00:17:20.100
specifier until you get back to the O.

00:17:20.100 --> 00:17:24.020
And what they eventually want
is the modification date or

00:17:24.020 --> 00:17:25.960
the file or the whatever.

00:17:25.960 --> 00:17:30.920
So when you walk in,
you find null and then you walk out

00:17:31.090 --> 00:17:34.470
until you get to the outermost object
specifier and then you're done.

00:17:34.480 --> 00:17:36.260
But that's a hard process.

00:17:36.260 --> 00:17:38.850
It's recursive and it's got
a lot of different cases.

00:17:38.870 --> 00:17:44.040
Sometimes, the intermediate thing that's
generated will be a list,

00:17:44.320 --> 00:17:47.560
like a range, so that at the next level,
you have to iterate over that

00:17:47.650 --> 00:17:51.900
range and do the same thing to it,
like the modification date of every file.

00:17:51.920 --> 00:17:55.830
You can find every file and then you
have to iterate over every file to

00:17:55.830 --> 00:17:57.230
get the modification date of that.

00:17:57.260 --> 00:17:58.760
There are a lot of rules
that you have to follow.

00:17:58.780 --> 00:18:01.480
have to follow in order to do it right.

00:18:02.090 --> 00:18:04.340
They're arbitrarily complex.

00:18:04.400 --> 00:18:07.960
You have to have basically a
three-dimensional matrix of switch cases.

00:18:07.960 --> 00:18:11.020
You have to have a switch for
every containment relationship.

00:18:11.020 --> 00:18:14.440
You have to have a switch for
every key form supported by

00:18:14.450 --> 00:18:16.740
each containment relationship.

00:18:16.740 --> 00:18:20.130
And you have to have a switch
for every potential data

00:18:20.130 --> 00:18:22.130
type of the selection data.

00:18:22.140 --> 00:18:25.190
You know,
the form name could have a name.

00:18:25.190 --> 00:18:28.980
It could have--the absolute
position could be an integer.

00:18:28.980 --> 00:18:31.650
The absolute position could be
something other than an integer.

00:18:31.900 --> 00:18:33.930
Your ranges could be object specifiers.

00:18:34.010 --> 00:18:36.550
They could be absolute position.

00:18:36.690 --> 00:18:41.500
And there are no good general rules about
how to handle the weird corner cases.

00:18:41.500 --> 00:18:46.900
A lot of this stuff isn't
written down anywhere.

00:18:47.400 --> 00:19:52.100
[Transcript missing]

00:19:53.730 --> 00:19:57.930
So what do you do if it's so hard,
if it's so complicated,

00:19:57.930 --> 00:20:00.050
and the system software
gives you so little support?

00:20:00.160 --> 00:20:00.540
What do you do?

00:20:00.540 --> 00:20:03.700
Well, you do it badly,
which is what most of you have done.

00:20:03.810 --> 00:20:05.200
And I don't blame you.

00:20:05.310 --> 00:20:09.310
But there are tools now
that help you do it well.

00:20:10.000 --> 00:20:13.450
If you're scripting with the framework,
the general process is that

00:20:13.530 --> 00:20:18.600
you create model objects in C++
that reflect your user's view,

00:20:18.600 --> 00:20:20.900
your scripter's view of your application.

00:20:21.000 --> 00:20:27.890
So if you have a graphic object concept
that a user can draw a graphic object,

00:20:28.170 --> 00:20:30.900
you make a graphic object class in C++.

00:20:30.920 --> 00:20:34.680
And maybe you don't really
have a graphic object class

00:20:34.860 --> 00:20:39.690
in C++ in your implementation,
but just create one whose implementation

00:20:39.690 --> 00:20:42.860
then specializes to circle,
square, line, or whatever.

00:20:42.900 --> 00:20:46.500
But create something that
you can hang off scripting.

00:20:47.110 --> 00:20:50.050
Then the general paradigm,
and this is used in almost every

00:20:50.060 --> 00:20:55.650
framework that offers scriptability,
is that any incoming event,

00:20:55.650 --> 00:21:01.810
like make new, delete, move, whatever,
that operates on an object will become a

00:21:01.810 --> 00:21:04.120
call to a member function on that object.

00:21:05.640 --> 00:21:11.010
And any Apple event properties,
like the size, the dimensions,

00:21:11.010 --> 00:21:15.360
the visible, the color,
that a scripter can get at,

00:21:15.420 --> 00:21:20.060
are just represented as
data members of that object.

00:21:20.060 --> 00:21:24.320
And then your element,
your containment relationships,

00:21:24.320 --> 00:21:28.370
become collection class
collections on that object.

00:21:28.420 --> 00:21:32.440
And so basically what you do is,
what I'd recommend doing is

00:21:32.440 --> 00:21:34.800
you start with your user model.

00:21:35.870 --> 00:21:36.950
Create your terminology.

00:21:37.000 --> 00:21:44.200
Then design a bunch of C++ objects that
implement a C++ view of that terminology.

00:21:44.260 --> 00:21:48.680
Wire them up on the top side to the
scripting engine of that framework,

00:21:48.680 --> 00:21:51.590
on the bottom side to your
actual implementation object,

00:21:51.590 --> 00:21:53.620
and then try it out and see how it works.

00:21:53.710 --> 00:21:56.100
And you may have to do a little
tuning to get it all right.

00:21:56.120 --> 00:22:00.220
But that's the order that
I really recommend you start in.

00:22:00.220 --> 00:22:03.440
Start from the user model
of your application.

00:22:03.500 --> 00:22:05.420
Design your scripting terminology.

00:22:05.640 --> 00:22:10.460
Implement C++ objects that are
structured like that terminology.

00:22:10.460 --> 00:22:12.560
Then wire them up to
the scripting engine,

00:22:12.560 --> 00:22:14.850
and then wire them to your
actual implementation,

00:22:14.850 --> 00:22:18.350
so that the script commands can
flow all the way from the scripter's

00:22:18.350 --> 00:22:22.380
view of the world to your actual
objects in your C++ application.

00:22:25.870 --> 00:22:27.780
And so this is how it
works in PowerPlant.

00:22:27.780 --> 00:22:30.980
If you get PowerPlant off the shelf,
and this has been true for years,

00:22:30.980 --> 00:22:36.820
what you can do is if you have
a C++ class and you derive it

00:22:36.970 --> 00:22:41.760
from the L model object class,
that becomes the equivalent of an

00:22:42.330 --> 00:22:44.890
Apple event object model class.

00:22:44.980 --> 00:22:48.750
And so in your terminology,
if it has class window,

00:22:48.760 --> 00:22:52.970
if you look in PowerPlant,
the window class in PowerPlant

00:22:52.970 --> 00:22:56.560
derives from L model object,
and so it looks like a

00:22:56.760 --> 00:23:00.850
window to AppleScript,
the AppleScript window class.

00:23:00.960 --> 00:23:07.380
The events are member functions,
so just as the window L model

00:23:07.380 --> 00:23:14.300
object in PowerPlant has a lot
of internal C++ method functions,

00:23:14.940 --> 00:23:15.710
that

00:23:17.300 --> 00:23:18.780
member functions that it responds to.

00:23:19.060 --> 00:23:23.010
It also responds to member functions
that correlate to the standard

00:23:23.080 --> 00:23:24.960
suite of Apple event objects.

00:23:24.960 --> 00:23:30.570
Make new, delete, for Windows it's close,

00:23:30.710 --> 00:23:32.960
Save, Save As.

00:23:32.960 --> 00:23:36.760
So there's a correlation between
the events that come in and the

00:23:36.760 --> 00:23:39.200
member functions on that class.

00:23:39.240 --> 00:23:42.320
The parameters are arguments
to those member functions.

00:23:42.410 --> 00:23:47.140
Properties of objects correlate to
the data members on those classes.

00:23:47.560 --> 00:23:50.660
PowerPlant implements the
containment relationships using their

00:23:50.660 --> 00:23:53.360
collection classes called LLists.

00:23:53.360 --> 00:23:56.620
And so everything,
every object that descends from

00:23:56.620 --> 00:24:03.120
LModelObject has a number of LList,
has basically an LList attached to it,

00:24:03.120 --> 00:24:06.520
which is all the things
that that object contains.

00:24:06.520 --> 00:24:08.680
And so a window,
if you have a window that's

00:24:08.920 --> 00:24:11.420
populated with widgets,
and widgets also descend

00:24:11.420 --> 00:24:15.920
from LModelObject,
then your window class is going to

00:24:15.920 --> 00:24:18.880
have an LList of widget objects.

00:24:18.990 --> 00:24:22.770
And then each widget object
is going to have a data member

00:24:22.770 --> 00:24:26.050
that's called mSuperModel,
and that's going to be

00:24:26.060 --> 00:24:27.370
the window it belongs to.

00:24:27.680 --> 00:24:31.400
So that's how you do the
containment relationship with

00:24:31.570 --> 00:24:37.610
the LList on the container and
the mSuperModel on the contained.

00:24:37.880 --> 00:24:42.070
And this makes it very,
very easy once you have your object

00:24:42.070 --> 00:24:46.970
model designed and your terminology
designed to go in and write all

00:24:46.970 --> 00:24:51.110
these C++ classes that derive from
L model object and have L lists

00:24:51.110 --> 00:24:53.350
and have M supermodel data members.

00:24:53.360 --> 00:24:56.990
And that makes your internal
structure resemble the

00:24:56.990 --> 00:24:59.600
terminology that you've defined.

00:25:01.480 --> 00:25:06.200
And PowerPlant helps you out
a lot in this by doing some

00:25:06.200 --> 00:25:09.200
of the stuff automatically,
especially the event registration.

00:25:09.310 --> 00:25:13.400
Basically, first you start with your
terminology resource.

00:25:13.420 --> 00:25:18.480
And I hope all of you have learned how to
create and edit a terminology resource.

00:25:18.480 --> 00:25:21.770
We could have a special clinic just
on that because it's pretty hard.

00:25:21.780 --> 00:25:27.360
But you add an Apple event object
model class to your terminology

00:25:27.360 --> 00:25:30.670
resource and you invent a
four-character code for your class.

00:25:30.920 --> 00:25:32.610
A WIDG for your widget.

00:25:32.620 --> 00:25:37.710
Then you create the C++ class that has
L model object as a public ancestor.

00:25:37.780 --> 00:25:41.770
And then you redefine the
constructor on your WIDG object,

00:25:41.780 --> 00:25:43.470
on your widget object.

00:25:43.600 --> 00:25:46.040
So it takes an L model object
reference to its container.

00:25:46.040 --> 00:25:50.000
And you pass that pointer to
the L model object constructor.

00:25:50.110 --> 00:25:53.170
And when somebody says make new widget...

00:25:53.380 --> 00:25:56.680
Your constructor gets called,
and it just happens automatically.

00:25:56.810 --> 00:25:57.450
It's very nice.

00:25:57.540 --> 00:25:59.350
It's a very clean system.

00:25:59.450 --> 00:26:02.140
In the constructor,
you set the model kind to that

00:26:02.340 --> 00:26:05.020
four character code that you've
defined in your terminology,

00:26:05.020 --> 00:26:07.310
and that's how it gets linked.

00:26:08.140 --> 00:26:11.900
And then in each container that
has that class as an element,

00:26:12.020 --> 00:26:17.430
this is the containment relationship,
you call set uses submodel list to true,

00:26:17.470 --> 00:26:19.560
and that says, oh, I'm a container.

00:26:19.670 --> 00:26:22.140
I contain these things.

00:26:22.610 --> 00:26:26.340
And then you'll get method calls,
you'll get member function

00:26:26.340 --> 00:26:29.780
calls on your objects that
correspond to Apple event calls.

00:26:29.780 --> 00:26:35.170
So it's sort of like handle,
if somebody makes a new thing of you,

00:26:35.170 --> 00:26:38.950
like if you say make new widget,
that container object will get

00:26:39.080 --> 00:26:41.390
a call handle create element.

00:26:41.400 --> 00:26:45.050
And that says, oh, you know,
this container, the window,

00:26:45.050 --> 00:26:47.080
wants a new widget created in it.

00:26:47.510 --> 00:26:48.970
Then there you go.

00:26:48.980 --> 00:26:51.500
Here's the new widget
object that's been created.

00:26:52.210 --> 00:26:54.380
Here's the container that
it's being created in.

00:26:54.380 --> 00:26:59.220
Do what you need to do in your
low-level code to draw it or initialize

00:26:59.220 --> 00:27:00.460
it or whatever you need to do.

00:27:03.100 --> 00:27:05.660
Once the object exists,
then getting and setting the class

00:27:05.660 --> 00:27:07.100
properties are very straightforward.

00:27:07.100 --> 00:27:10.360
You, again,
define your properties in your AETE.

00:27:10.360 --> 00:27:13.860
You create a four-character code
for each property on each object.

00:27:13.920 --> 00:27:19.560
And then there's a method on
each class called getAEProperty.

00:27:19.560 --> 00:27:22.400
You just override that method,
and you switch off the

00:27:22.400 --> 00:27:25.260
four-character code,
and there you go.

00:27:26.200 --> 00:27:31.700
So if you have a widget that has color,
size, shape property,

00:27:31.700 --> 00:27:33.990
you have three four-character
codes for those.

00:27:34.000 --> 00:27:38.940
Your getAEProperty method will
be called on your widget class.

00:27:38.960 --> 00:27:43.270
It'll be called with the parameter
that is the property code.

00:27:43.280 --> 00:27:47.640
You just switch off that and say, oh,
if I'm getting the size, I return this.

00:27:47.660 --> 00:27:49.250
If I'm getting the shape, I return this.

00:27:49.320 --> 00:27:51.110
If I'm getting the color, I return this.

00:27:51.140 --> 00:27:56.180
Then you can go in and do
the appropriate manipulation.

00:27:56.180 --> 00:28:00.340
To get the right data,
you create an AEDesk with the value.

00:28:00.340 --> 00:28:04.080
And then you return that as the
return value of getAEProperty.

00:28:04.100 --> 00:28:05.820
It's very straightforward again.

00:28:07.250 --> 00:28:08.670
Here's an example of it.

00:28:08.760 --> 00:28:13.040
I mean, you switch on the in property,
do three cases.

00:28:13.040 --> 00:28:15.760
This is contents filled and line width,
for example.

00:28:15.760 --> 00:28:19.240
And you just get the appropriate
value straight from the object,

00:28:19.240 --> 00:28:21.560
or you synthesize it if it's necessary.

00:28:22.280 --> 00:28:26.880
And then you call aecreateDesk to
put it into the right form that

00:28:27.050 --> 00:28:31.660
correlates to the class that you
defined it as in your terminology.

00:28:31.660 --> 00:28:37.970
You know, if your terminology said that
your contents are a QD rectangle,

00:28:37.980 --> 00:28:41.340
R-E-C-T, then you'd better return
it as a rectangle.

00:28:41.340 --> 00:28:42.620
That would be good.

00:28:44.760 --> 00:28:46.640
Setting class properties is similar.

00:28:46.640 --> 00:28:50.740
What's going to come in to your
setAeproperty is a property

00:28:50.740 --> 00:28:53.400
switch and a value in an Aedesk.

00:28:53.410 --> 00:28:57.210
You write a switch statement that
switches off the in property.

00:28:57.210 --> 00:29:01.640
Then you extract the value
from the Aedesk and coerce it,

00:29:01.700 --> 00:29:03.140
if necessary, to the right one.

00:29:03.190 --> 00:29:04.440
And then you set it.

00:29:04.440 --> 00:29:06.640
And if it can't be set,
you return an error.

00:29:06.640 --> 00:29:10.100
If the set is successful,
then you return silently.

00:29:10.940 --> 00:29:13.250
So here's a set AE property switch.

00:29:13.350 --> 00:29:15.860
Notice something in here.

00:29:16.450 --> 00:29:18.170
There's a refresh call.

00:29:18.500 --> 00:29:21.070
Basically,
if your application has a user interface,

00:29:21.290 --> 00:29:23.940
when a scripter sets
properties on an object,

00:29:24.010 --> 00:29:26.680
you may want to update
your visual display.

00:29:26.850 --> 00:29:32.350
You may want your model to talk
to your view to refresh the image.

00:29:32.700 --> 00:29:36.300
If somebody set the bounds of something,
you wanted to redraw it.

00:29:36.300 --> 00:29:38.890
So you have to call refresh to redraw it.

00:29:41.700 --> 00:29:45.190
How do key forms work in PowerPlant?

00:29:45.250 --> 00:29:53.760
PowerPlant implements
most key forms for free.

00:29:53.760 --> 00:29:59.630
Because L lists are indexed lists,
PowerPlant knows how to get

00:29:59.630 --> 00:30:04.750
widget four of window two,
because it just goes down the L list

00:30:04.920 --> 00:30:08.650
and gets the fourth widget from
that and sends them to that object.

00:30:08.650 --> 00:30:11.580
Form name works if you
have a P name property.

00:30:11.580 --> 00:30:14.170
It's special case if you
have a name property,

00:30:14.170 --> 00:30:15.300
form name works.

00:30:15.350 --> 00:30:17.700
But everything else you
really have to do yourself.

00:30:17.950 --> 00:30:21.800
There's this method called get model
token self which passes in the key

00:30:21.800 --> 00:30:26.860
form and you pretty much have to
figure out from there how it works.

00:30:26.900 --> 00:30:28.200
Mostly they're pretty easy.

00:30:28.290 --> 00:30:31.470
There's some sample code on the web,
I can give you a reference to it,

00:30:31.760 --> 00:30:33.300
that implements form range.

00:30:33.300 --> 00:30:37.040
Doesn't implement it well,
but it basically implements it.

00:30:37.040 --> 00:30:37.040
What's the key form?

00:30:37.040 --> 00:30:37.040
L lists are indexed lists.

00:30:37.040 --> 00:30:37.040
PowerPlant implements
most key forms for free.

00:30:37.040 --> 00:30:37.040
Because L lists are indexed lists.

00:30:37.040 --> 00:30:37.040
PowerPlant implements
most key forms for free.

00:30:37.040 --> 00:30:37.040
Because L lists are indexed lists.

00:30:37.040 --> 00:30:37.290
PowerPlant implements
most key forms for free.

00:30:37.290 --> 00:30:37.640
Because L lists are indexed lists.

00:30:37.640 --> 00:30:38.040
PowerPlant implements
most key forms for free.

00:30:38.040 --> 00:30:38.040
Because L lists are indexed lists.

00:30:38.040 --> 00:30:38.080
PowerPlant implements
most key forms for free.

00:30:38.080 --> 00:30:40.530
Form unique ID is fairly straightforward.

00:30:40.670 --> 00:30:43.130
Whose clauses are kind
of difficult though?

00:30:44.400 --> 00:30:45.250
And how do events work?

00:30:45.500 --> 00:30:48.440
Well, the good news is that
PowerPlant implements,

00:30:48.470 --> 00:30:53.830
exists, make, delete, count, duplicate,
and move, the basic standard events,

00:30:53.850 --> 00:30:56.640
for any object that
descends from lmodelobject.

00:30:56.640 --> 00:31:00.550
So these come for free,
which is really nice.

00:31:01.160 --> 00:31:04.900
You just have to implement the
constructors and destructors.

00:31:05.000 --> 00:31:06.720
Duplicate is fairly simple.

00:31:06.720 --> 00:31:10.950
The difficult part for duplicate is
that you've got to set the initial,

00:31:10.950 --> 00:31:15.100
like make new, you've got to set the
appropriate initial values for,

00:31:15.100 --> 00:31:19.250
so for duplicate, you've got to get the,
you've got to get the initial

00:31:19.250 --> 00:31:21.450
values for the initial values.

00:31:21.700 --> 00:31:24.630
Get the properties that are
important of the object you're

00:31:24.630 --> 00:31:26.280
duplicating and then set them.

00:31:26.280 --> 00:31:29.090
You know, if you duplicate an object,
all the properties are

00:31:29.090 --> 00:31:30.120
not going to be identical.

00:31:30.120 --> 00:31:31.320
The index will be different.

00:31:31.320 --> 00:31:33.330
The unique ID will be different,
for example.

00:31:33.340 --> 00:31:36.800
So, if you're duplicating a widget,
you need to get the important

00:31:36.900 --> 00:31:39.160
properties of widget,
of the old widget,

00:31:39.160 --> 00:31:43.450
and then set the properties
of the new widget to that set,

00:31:43.480 --> 00:31:48.160
skipping the ones that
are defined to be unique,

00:31:48.290 --> 00:31:53.210
like the name perhaps, like the index,
like the unique ID.

00:31:53.710 --> 00:31:57.020
And then you've got to handle
createElement event in each container.

00:31:57.020 --> 00:31:59.200
You know,
create has to happen in two place.

00:31:59.270 --> 00:32:02.200
If you're creating a widget in a window,
the widget has to know

00:32:02.200 --> 00:32:03.220
it's being created.

00:32:03.470 --> 00:32:07.490
And the window has to know that a new
widget has been created in it in order

00:32:07.500 --> 00:32:10.300
to get all the updating to happen right.

00:32:11.980 --> 00:32:14.170
Here's some code,
and this will be on the slides

00:32:14.170 --> 00:32:16.620
on the CD if you want to read it,
if it's too hard to read up here.

00:32:16.620 --> 00:32:20.460
But basically,
this is the create element event.

00:32:20.460 --> 00:32:24.650
You switch on what class you're creating.

00:32:24.650 --> 00:32:31.450
If your container can handle multiple
different classes created in it,

00:32:31.550 --> 00:32:32.820
then if it's...

00:32:33.080 --> 00:32:36.140
If you get a create event to create this,
then you do a new that.

00:32:36.290 --> 00:32:38.820
If it's that, then you do a new this.

00:32:38.930 --> 00:32:41.510
If it's not, then you throw an error.

00:32:42.570 --> 00:32:43.560
Now what about custom events?

00:32:43.650 --> 00:32:49.510
I mean, it's all well and good to have
an application that is just

00:32:49.610 --> 00:32:51.260
objects in the standard events.

00:32:51.260 --> 00:32:53.430
And I really,
really applaud you if you can make

00:32:53.430 --> 00:32:56.200
an application that is nothing but
objects in the standard events.

00:32:56.200 --> 00:32:58.570
But you might want to do
your own custom event.

00:32:58.590 --> 00:33:02.210
I mean, the finder does for like
restart and shut down.

00:33:02.220 --> 00:33:03.890
That's pretty easy too.

00:33:03.890 --> 00:33:06.780
Once again,
you start by defining the events

00:33:06.780 --> 00:33:10.190
in your terminology resource and
inventing a four character code.

00:33:10.210 --> 00:33:12.580
And it's actually a pair
of four character codes,

00:33:12.630 --> 00:33:15.090
the event class and the event type.

00:33:15.120 --> 00:33:23.710
What you do in PowerPlant is PowerPlant
has a resource called the AEDT resource.

00:33:23.710 --> 00:33:31.250
And the AEDT resource is nothing but a
table that maps event class code pairs.

00:33:31.280 --> 00:33:31.380
Okay.

00:33:32.310 --> 00:33:34.550
To long ends.

00:33:34.640 --> 00:33:35.330
And that's all it is.

00:33:35.330 --> 00:33:38.180
It's just a table of event
class code and long end.

00:33:38.250 --> 00:33:40.290
And what happens is

00:33:40.320 --> 00:33:45.830
That when an Apple event comes
into a PowerPlant application,

00:33:45.830 --> 00:33:48.850
it gets looked up in this table,
the long end is generated,

00:33:48.850 --> 00:33:51.510
and then you switch off of that long end.

00:33:51.720 --> 00:33:54.700
Because it's too hard to
switch off of two 4K codes,

00:33:54.760 --> 00:33:57.680
so it basically switches
off the long end.

00:33:57.730 --> 00:34:02.170
So if you want to create a custom event,
you know, like a refresh event

00:34:02.180 --> 00:34:07.050
or something like that,
you invent the class creator code for it,

00:34:07.150 --> 00:34:11.610
you associate it with a number,
and then in the switch

00:34:11.610 --> 00:34:15.640
statement in handleAppleEvent,
you switch off of that number,

00:34:15.750 --> 00:34:19.720
and then when that case is called,
you just execute your code there.

00:34:22.350 --> 00:34:28.280
And you do that on every object
that can handle that event.

00:34:28.380 --> 00:34:32.390
So if every object has
its own refresh event,

00:34:32.390 --> 00:34:36.870
you might want to have that
handleAppleEvent method and have that

00:34:36.870 --> 00:34:40.970
case in the handleAppleEvent method for
each object that handles a refresh event.

00:34:40.980 --> 00:34:44.130
Or you might want to have it,
for example, if you've got a number of

00:34:44.130 --> 00:34:47.360
objects that can be refreshed,
you might want to just do it once

00:34:47.400 --> 00:34:51.660
and have all the other refreshable
objects inherit from that so that you

00:34:51.930 --> 00:34:55.460
just assume the inherited capability.

00:34:55.460 --> 00:34:58.130
And in many of the cases
for the standard events,

00:34:58.310 --> 00:35:01.760
that's exactly what PowerPlant does,
is it doesn't implement

00:35:01.760 --> 00:35:04.660
it in the object itself,
but it just hands it off to the

00:35:04.660 --> 00:35:06.280
class that it inherits from.

00:35:06.280 --> 00:35:08.600
So here's an example.

00:35:08.600 --> 00:35:10.100
Here's a rotate event.

00:35:10.120 --> 00:35:13.020
You switch on the AppleEvent number.

00:35:13.020 --> 00:35:15.880
If the case is 8erotate,
then you call rotate.

00:35:15.880 --> 00:35:20.780
If not, then you call the inherited
handleAppleEvent so that you pass it up.

00:35:20.910 --> 00:35:24.180
to the superclass to
see if it can handle it.

00:35:25.650 --> 00:35:28.460
Here's some things to
remember about PowerPlant.

00:35:28.630 --> 00:35:31.130
Number one is that

00:35:31.430 --> 00:35:36.220
PowerPlant applications are, by default,
scriptable in the most

00:35:36.220 --> 00:35:40.800
stupid possible way,
in that they support a small number of

00:35:40.800 --> 00:35:45.140
standard events on the window class only,
but they expose a full,

00:35:45.360 --> 00:35:50.160
in some cases too full,
Apple event terminology that promises

00:35:50.590 --> 00:35:53.150
more than it actually delivers.

00:35:53.160 --> 00:35:56.840
So, for example,
if you just build the demo

00:35:57.340 --> 00:36:03.000
PowerPlant application,
it says it supports make new, delete,

00:36:03.000 --> 00:36:08.240
count, create, whatever,
on a whole bunch of objects,

00:36:08.320 --> 00:36:11.250
and none of that support
is actually in the code,

00:36:11.250 --> 00:36:12.350
and that's bad.

00:36:12.400 --> 00:36:17.480
So the first thing I want you to do is
to trim or throw away the terminology

00:36:17.750 --> 00:36:21.050
resource in your PowerPlant application.

00:36:21.060 --> 00:36:25.540
Treat it as if it's just... You know,
start from scratch.

00:36:25.970 --> 00:36:29.110
design your scriptability,
then write a terminology

00:36:29.110 --> 00:36:33.350
resource from scratch,
and then implement that

00:36:33.440 --> 00:36:35.380
terminology that you've defined.

00:36:35.380 --> 00:36:37.480
Because if you don't do that,
what's going to happen is that

00:36:37.480 --> 00:36:40.520
the default terminology resource
that gets compiled into your

00:36:40.520 --> 00:36:43.630
Power Plant application is going
to promise that it supports all

00:36:43.630 --> 00:36:46.750
these events on all these objects,
which just aren't there.

00:36:46.770 --> 00:36:50.250
And it's a source of great frustration
for a lot of scripters that,

00:36:50.380 --> 00:36:53.890
you know, they get a new application and
the first thing they do is they

00:36:53.890 --> 00:36:56.620
drag it onto the script editor
to see whether it's scriptable.

00:36:56.740 --> 00:36:58.350
And this dictionary
pops up and it's great.

00:36:58.440 --> 00:36:59.840
Oh, look at all these events.

00:36:59.840 --> 00:37:01.410
They're the standard suite.

00:37:01.500 --> 00:37:03.100
They've got all these objects.

00:37:03.240 --> 00:37:06.540
And you look at it and
it's just Power Plant.

00:37:06.630 --> 00:37:07.700
And that's all it is.

00:37:07.800 --> 00:37:10.110
And then you know it's not going to work.

00:37:10.140 --> 00:37:14.210
So please trim your
Power Plant dictionary.

00:37:14.460 --> 00:37:17.560
The second thing is,
I cannot possibly do PowerPlant

00:37:17.630 --> 00:37:20.880
scripting justice in the time
I have in this presentation.

00:37:20.900 --> 00:37:24.020
But luckily,
on CodeWarrior Pro and actually

00:37:24.020 --> 00:37:27.520
every version of CodeWarrior
back for several years,

00:37:27.750 --> 00:37:32.510
there's been a very good introduction
to doing scriptability in PowerPlant.

00:37:32.540 --> 00:37:37.470
In the PowerPlant Advanced Topics
book that's in PDF form on the

00:37:37.850 --> 00:37:42.760
PowerPlant documentation CD,
in the CodeWarrior documentation CD.

00:37:43.140 --> 00:37:43.900
It's there.

00:37:43.900 --> 00:37:44.800
It's good.

00:37:44.800 --> 00:37:45.520
Read it.

00:37:45.520 --> 00:37:46.230
Study it.

00:37:46.500 --> 00:37:50.790
These slides were basically
stolen shamelessly from there.

00:37:50.800 --> 00:37:53.650
It's good documentation and it
will help get your head around

00:37:53.650 --> 00:37:55.260
the whole Apple Events thing.

00:37:55.260 --> 00:38:01.120
So, if you want to code in PowerPlant,
go to PowerPlant Advanced Topics,

00:38:01.120 --> 00:38:05.400
trim the AET resource,
start with designing what

00:38:05.510 --> 00:38:09.210
you want the user to see,
build your terminology,

00:38:09.590 --> 00:38:13.120
build some C++ objects that reflect that,
then wire them up.

00:38:13.140 --> 00:38:15.930
Both to the scripting interface
through L model object and then

00:38:15.930 --> 00:38:17.180
to your actual implementation.

00:38:17.180 --> 00:38:18.900
That's the way to go about it.

00:38:21.320 --> 00:38:25.070
But what if I don't
want to use PowerPlant?

00:38:25.190 --> 00:38:27.400
Well, you've got options.

00:38:28.550 --> 00:38:33.340
One of the things you can do is you
can manually extract LModelObject

00:38:33.830 --> 00:38:39.050
and the LList class and some of the
other classes that are hanging on.

00:38:39.080 --> 00:38:42.710
You can just extract them from PowerPlant
and compile them into your application.

00:38:42.750 --> 00:38:45.250
Now there are a lot of little threads
that you may have to pick up of

00:38:45.360 --> 00:38:48.850
things that PowerPlant depends upon,
but the PowerPlant classes are

00:38:49.000 --> 00:38:51.550
extractable from PowerPlant itself.

00:38:51.660 --> 00:38:53.640
So you don't have to
use their window model.

00:38:53.640 --> 00:38:56.490
You don't have to use
their drawing model,

00:38:56.490 --> 00:38:58.380
their load and save model.

00:38:58.400 --> 00:39:01.810
You can just extract the classes
and adapt them and use them as

00:39:01.810 --> 00:39:03.820
a model in your own application.

00:39:03.820 --> 00:39:06.530
Could be a lot of work,
but it does save you a lot of work.

00:39:06.530 --> 00:39:08.180
So that's one thing you can do.

00:39:08.180 --> 00:39:12.500
There's another framework,
an old venerable framework called

00:39:12.500 --> 00:39:17.780
Sprocket by Steve Sissick that hasn't
been updated for I guess four years now,

00:39:17.780 --> 00:39:21.380
but it's still available
online at CodeWell.com,

00:39:21.380 --> 00:39:22.430
I believe.

00:39:22.440 --> 00:39:27.020
And it supports some decent
Apple event scripting.

00:39:27.020 --> 00:39:28.350
It's some helper classes.

00:39:28.400 --> 00:39:30.850
There's a lot of other things that
help you get your head around it.

00:39:31.040 --> 00:39:34.700
It's not terribly up to date,
but it's a start.

00:39:35.120 --> 00:39:38.750
If you want to commit to
using Objective-C or Java and

00:39:38.750 --> 00:39:42.390
deploying on MacOSX only,
you can use the Cocoa framework.

00:39:42.400 --> 00:39:44.660
There's some very good
scriptability in Cocoa,

00:39:44.660 --> 00:39:48.790
and you can go to the
Cocoa Advanced Topics presentation,

00:39:48.840 --> 00:39:52.850
which is at 3 o'clock today,
to talk about that.

00:39:52.940 --> 00:39:58.010
Or you can use the Mac App Framework,
and I'm sure Tom Becker will be very

00:39:58.010 --> 00:40:00.910
happy to show you what scriptability
is in the Mac App Framework.

00:40:01.870 --> 00:40:04.750
But there's one more opportunity,
which has just presented itself,

00:40:04.780 --> 00:40:08.610
coming from our DTS group called MoreOSL.

00:40:08.620 --> 00:40:12.670
MoreOSL is not a framework per se.

00:40:12.680 --> 00:40:16.730
It's more like a support
library that you can use from a

00:40:16.730 --> 00:40:19.660
C application or a C++ application.

00:40:19.660 --> 00:40:23.120
It's carbon-ready,
which if you want to deploy on

00:40:23.120 --> 00:40:25.710
MacOS 9 and MacOSX is very nice.

00:40:25.840 --> 00:40:26.860
It'll get you there faster.

00:40:26.860 --> 00:40:30.480
And it deploys all the way
back to MacOS 8.5 and compiles

00:40:30.540 --> 00:40:31.740
all the way back to Cocoa.

00:40:31.780 --> 00:40:32.880
And it's also available
on the CodeWarrior Pro 2.

00:40:32.900 --> 00:40:36.810
So those of you who are sticking back
on earlier versions of CodeWarrior and

00:40:36.810 --> 00:40:41.000
don't want to use the latest and greatest
are not cut off from this functionality.

00:40:41.000 --> 00:40:45.460
It supports, it really does support
doing a good object model.

00:40:45.460 --> 00:40:47.730
I really like the way that
it goes about doing it.

00:40:47.760 --> 00:40:52.260
And it's comprehensive, it's tested,
and it comes with a good sample

00:40:52.260 --> 00:40:55.070
application that shows you how it works.

00:40:55.150 --> 00:40:56.660
And I'm going to be demoing
that in a little while.

00:40:56.660 --> 00:41:00.580
You can get it on developer.apple.com
slash sample code.

00:41:00.580 --> 00:41:01.740
It's a little bit more expensive.

00:41:01.740 --> 00:41:04.080
It's a little deeper in there,
but at the moment there's

00:41:04.110 --> 00:41:05.150
a top-level link to it.

00:41:05.180 --> 00:41:07.700
Very small, quick download.

00:41:07.700 --> 00:41:09.570
Go for it.

00:41:11.080 --> 00:41:12.140
Here's the theory of operation.

00:41:12.140 --> 00:41:15.040
It's a little different from the
way the PowerPlant thing works.

00:41:15.040 --> 00:41:18.750
You have to define your user
classes and your user events,

00:41:18.790 --> 00:41:20.460
and I recommend you do that the same way.

00:41:20.460 --> 00:41:23.400
You start with the user model,
and then you define your terminology,

00:41:23.400 --> 00:41:27.030
and figure out what your
object model classes and object

00:41:27.100 --> 00:41:29.150
model events are going to be.

00:41:29.160 --> 00:41:31.350
But then you make tables.

00:41:31.380 --> 00:41:35.740
You make a table of all your classes,
and you make a table of all your events,

00:41:35.780 --> 00:41:39.320
and then you make a table for each class
of what events apply to that class.

00:41:39.880 --> 00:41:44.430
and you build those
in straight C structs.

00:41:47.000 --> 00:41:49.310
Fans of straight C structs.

00:41:49.430 --> 00:41:53.400
You create an event table entry
for each event on each class.

00:41:53.450 --> 00:41:57.300
And it maps the event codes to
the classes they operate on.

00:41:57.330 --> 00:42:01.470
And then it also has some bits
that declare what's supposed to

00:42:01.470 --> 00:42:04.700
happen with the direct parameter,
whether it's required or optional,

00:42:04.710 --> 00:42:07.040
whether this generates a reply or not,
things like that.

00:42:07.110 --> 00:42:09.920
So you set a couple
flags in these tables.

00:42:10.170 --> 00:42:11.700
So basically,
the first thing your application

00:42:11.700 --> 00:42:15.690
does is creates all these tables
that defines its scriptability.

00:42:16.100 --> 00:42:19.810
Then, you, then,
more OSL does all of the registry

00:42:19.810 --> 00:42:25.430
with the object support library and
with the Apple event handler for you.

00:42:25.430 --> 00:42:29.700
It registers its handlers,
so you don't have to.

00:42:29.850 --> 00:42:34.000
So, when an event handler gets called
or an object accessor gets called,

00:42:34.000 --> 00:42:37.160
more OSL takes control,
and it will call back

00:42:37.300 --> 00:42:40.590
to you when it needs to,
but you don't have to interact

00:42:40.650 --> 00:42:44.730
directly with the operating system,
which is very nice.

00:42:44.970 --> 00:42:49.610
And in many cases, the generic handlers,
the generic event handlers from

00:42:49.610 --> 00:42:52.670
MoreOSL will do what you want
with no further intervention,

00:42:52.680 --> 00:42:54.170
which is actually pretty cool.

00:42:54.180 --> 00:42:56.820
When your application
processes an Apple event,

00:42:56.820 --> 00:42:59.180
MoreOSL resolves the direct parameter.

00:42:59.180 --> 00:43:02.300
It calls OSA Resolve for you.

00:43:02.300 --> 00:43:07.200
It dispatches the event to the event
handler for your class directly.

00:43:07.200 --> 00:43:09.540
It's class-first dispatching.

00:43:09.540 --> 00:43:10.910
It's the right way to do it.

00:43:11.680 --> 00:43:16.390
And then the generic handler handles the
event unless you've defined a specific

00:43:16.420 --> 00:43:19.350
handler for that event on your class,
in which case your specific

00:43:19.350 --> 00:43:20.210
handler gets called.

00:43:22.920 --> 00:43:25.640
So let me show you just
basically a class table entry.

00:43:25.640 --> 00:43:30.090
There are three main parts to it.

00:43:30.580 --> 00:43:34.530
There's an event ID, which is, you know,
here's the event that's coming in.

00:43:34.540 --> 00:43:37.560
And then a couple of
pointers to other tables,

00:43:37.560 --> 00:43:40.930
a table for the properties and a table
for all the events on that class.

00:43:41.020 --> 00:43:45.620
And then for each class,
you must supply a couple

00:43:45.720 --> 00:43:48.080
of callback routines.

00:43:48.080 --> 00:43:51.320
And you can supply others and just leave
them null if you're not supplying them.

00:43:52.150 --> 00:43:56.260
For each class,
you must write a counter routine

00:43:56.260 --> 00:43:59.040
that counts how many of those
classes there are in a container.

00:43:59.040 --> 00:44:04.460
And then you can provide accessors
that are get a class by unique ID.

00:44:04.460 --> 00:44:07.940
You know,
get me from my container by unique ID,

00:44:07.970 --> 00:44:09.670
by index, by name.

00:44:11.270 --> 00:44:14.410
And then there's get
me or something of me.

00:44:14.670 --> 00:44:16.630
There's a set me or something of me.

00:44:16.980 --> 00:44:18.500
And then there's a coerced token.

00:44:18.500 --> 00:44:21.840
And the tokens are pretty much
the way that the OSL works.

00:44:21.980 --> 00:44:25.940
The token is a representation
of the internal object.

00:44:26.070 --> 00:44:28.770
And tokens in more OSL are
basically just pointers.

00:44:28.800 --> 00:44:29.840
They can be a class pointer.

00:44:29.850 --> 00:44:30.550
They can be a pointer.

00:44:30.680 --> 00:44:31.560
They can be a handle.

00:44:31.560 --> 00:44:37.750
But it's basically 32 bits that uniquely
identify something in your application.

00:44:38.760 --> 00:44:42.290
So then there's an event table entry,
and the event table is

00:44:42.290 --> 00:44:43.120
very straightforward.

00:44:43.120 --> 00:44:47.610
It's just the four character codes
for the event and the event class,

00:44:47.610 --> 00:44:50.430
whether or not the direct
object is required,

00:44:50.430 --> 00:44:54.940
and whether or not there's a result
and what action to take on the result.

00:44:54.940 --> 00:44:58.800
And then in each class,
there's a table for where's the

00:44:58.980 --> 00:45:03.910
handler for the exists event,
the count event, the get data event,

00:45:03.910 --> 00:45:05.880
and the set data event.

00:45:07.460 --> 00:45:10.860
And then as you add more custom
events to the event table,

00:45:10.860 --> 00:45:15.350
you have to provide corresponding
events in the class event handlers.

00:45:15.360 --> 00:45:17.100
I mean, it's really dumb dispatching.

00:45:17.100 --> 00:45:21.570
The event table, the master one,
and every class event table

00:45:21.570 --> 00:45:23.410
have to be in parallel.

00:45:23.420 --> 00:45:27.520
That is, if you add a rotate event
to the event table entry,

00:45:27.520 --> 00:45:30.910
you have to add a rotate
event in the same position

00:45:30.910 --> 00:45:34.890
in every class event handler,
even if many of them are null

00:45:34.890 --> 00:45:37.010
because you can't rotate those.

00:45:37.020 --> 00:45:39.780
But the one you have,
one that does support rotate,

00:45:39.780 --> 00:45:42.220
that's the pointer to the rotate routine.

00:45:42.220 --> 00:45:42.620
Okay?

00:45:42.620 --> 00:45:46.950
So the class event handler table
should look like the event table

00:45:47.230 --> 00:45:49.730
entry customized for each class.

00:45:51.000 --> 00:45:54.240
And then the property table off of
each class is very straightforward.

00:45:54.240 --> 00:45:58.060
It's property code and a bunch
of flags that say what it does.

00:45:58.140 --> 00:46:03.020
And the property access is actually done
through the class's getter setter event

00:46:03.040 --> 00:46:04.700
with the same kind of switch statement.

00:46:04.700 --> 00:46:08.270
If you provide a pproperties property,
a properties property

00:46:08.350 --> 00:46:12.080
in your terminology,
which is the way things are done now,

00:46:12.120 --> 00:46:16.810
more OSL will automatically iterate over
all of the properties in your property

00:46:16.810 --> 00:46:19.780
table and get them or set them on NAS,
which is great.

00:46:20.000 --> 00:46:21.500
It saves you the trouble of doing that.

00:46:21.540 --> 00:46:25.070
If you provide a pinherits property
in your terminology and you put

00:46:25.070 --> 00:46:29.270
it in your property table entry,
more OSL will automatically look in

00:46:29.270 --> 00:46:34.340
your container classes for properties
that you don't support directly.

00:46:34.340 --> 00:46:39.790
So if I have, like in the finder,
there's an item and a file.

00:46:39.800 --> 00:46:42.140
And items have names.

00:46:42.140 --> 00:46:43.440
Files don't have names.

00:46:43.440 --> 00:46:46.590
Files have modification dates,
but they inherit names.

00:46:46.620 --> 00:46:53.350
So in the... In more OSL parlance,
there won't be a property table

00:46:53.350 --> 00:46:55.660
entry for name in the file object.

00:46:55.760 --> 00:46:58.330
And more OSL will see
the inherits and say,

00:46:58.350 --> 00:47:00.220
"Oh,
if I'm looking for the name property,

00:47:00.220 --> 00:47:01.550
I don't look in the file object.

00:47:01.600 --> 00:47:04.450
I look in the item object
that it inherits from,

00:47:04.480 --> 00:47:07.470
and it'll do the right thing for
you." Which is really very nice.

00:47:08.980 --> 00:47:12.300
In terms of event handler,
moreOSL does exist, count, getObject,

00:47:12.400 --> 00:47:13.470
and setObject for you.

00:47:13.600 --> 00:47:16.340
It implements those generically,
and in most cases,

00:47:16.340 --> 00:47:21.530
you really won't need to do anything
to change or override those.

00:47:21.600 --> 00:47:24.140
Most of the key forms are
handled automatically,

00:47:24.190 --> 00:47:26.510
and this is good for two reasons.

00:47:26.510 --> 00:47:31.220
One is that you just don't have
to implement like form range and

00:47:31.220 --> 00:47:33.340
several of the form test cases.

00:47:33.340 --> 00:47:38.130
And second is you can read the source
code and see how it ought to work,

00:47:38.130 --> 00:47:41.820
if you so desire to see
how it ought to work.

00:47:41.820 --> 00:47:43.140
It's really great.

00:47:43.140 --> 00:47:46.330
The only one that's not handled
automatically in the current version

00:47:46.330 --> 00:47:49.890
of OSL is the form relative position,
before, after an event.

00:47:51.480 --> 00:47:52.890
Let me talk a little bit about tokens.

00:47:52.890 --> 00:47:56.850
Like I said,
tokens are the way that you relate

00:47:56.990 --> 00:48:01.020
a resolved object specifier to
something in your application.

00:48:01.060 --> 00:48:05.990
And a token is basically a token code,
an object code, a property code,

00:48:05.990 --> 00:48:08.430
and then a pointer to something.

00:48:08.460 --> 00:48:11.350
And this is a simple token definition.

00:48:11.390 --> 00:48:13.980
That pointer to something
can be like a window pointer,

00:48:13.980 --> 00:48:15.540
a pointer to a toolbox structure.

00:48:16.060 --> 00:48:19.980
It can be a pointer to one of
your C or C++ data structures,

00:48:20.020 --> 00:48:21.950
or it can be a C++ object.

00:48:21.960 --> 00:48:27.280
It's just 32 bits that your application,
if given a pointer, can say, oh,

00:48:27.490 --> 00:48:31.240
this is a pointer,
and the object code reminds

00:48:31.480 --> 00:48:33.840
me what it's a pointer to.

00:48:33.840 --> 00:48:36.660
That means I can do
something with this data.

00:48:36.660 --> 00:48:40.760
I can create it, I can delete it,
I can get information from it, whatever.

00:48:40.760 --> 00:48:44.080
The only important thing about a
pointer is that your application

00:48:44.080 --> 00:48:45.470
understands what it is.

00:48:45.880 --> 00:48:46.430
A token.

00:48:46.430 --> 00:48:49.060
Tokens never leave your app.

00:48:49.220 --> 00:48:50.600
They're never sent back to Apple Script.

00:48:50.600 --> 00:48:52.280
They're never sent to anybody else.

00:48:52.340 --> 00:48:55.130
So all that a token has to
do is be creatable by and

00:48:55.140 --> 00:48:57.620
understandable by your application.

00:49:01.680 --> 00:49:03.090
Properties, getters and setters.

00:49:03.210 --> 00:49:04.380
It's very straightforward.

00:49:04.380 --> 00:49:10.000
If somebody gives you a property token,
your getter ought to return

00:49:10.270 --> 00:49:12.650
an appropriate value.

00:49:12.660 --> 00:49:15.540
If somebody says,
I want this property of this object,

00:49:15.540 --> 00:49:18.210
you've got to return an
AEDesk that's that value.

00:49:18.300 --> 00:49:19.760
That's all there is to it.

00:49:20.400 --> 00:49:21.750
Setter, the same thing.

00:49:21.750 --> 00:49:24.340
If somebody says,
here's a token of an object,

00:49:24.340 --> 00:49:26.850
here's the property,
and here's the new value

00:49:26.850 --> 00:49:30.840
I want you to set it to,
you should set that property somewhere in

00:49:30.840 --> 00:49:33.560
your application and return error or no.

00:49:33.570 --> 00:49:35.140
That's all you need to do.

00:49:37.300 --> 00:49:39.380
If there are other
parameters on an Apple event,

00:49:39.380 --> 00:49:43.490
you have to extract them manually
with good old AE Get Param Desk.

00:49:43.600 --> 00:49:48.100
And there's a useful more
OSL routine to coerce it.

00:49:48.320 --> 00:49:52.070
If it happens to be an object specifier,
it'll do the resolution for you.

00:49:52.100 --> 00:49:54.850
You know,
this is useful for things like set

00:49:54.860 --> 00:49:57.250
name of file 1 to name of file 2.

00:49:57.260 --> 00:50:01.320
In that case,
the 2 parameter is an object specifier,

00:50:01.410 --> 00:50:02.760
name of file 2.

00:50:03.420 --> 00:50:07.660
And so what happens is the set command
will resolve the direct parameter

00:50:07.820 --> 00:50:09.820
name of object 1 and give you a token.

00:50:09.820 --> 00:50:14.450
And then it'll be set
token to object specifier.

00:50:14.460 --> 00:50:17.600
And then your setter will have to say,
well, you know,

00:50:17.600 --> 00:50:19.180
I don't know what this is.

00:50:19.280 --> 00:50:20.440
It's an object specifier.

00:50:20.440 --> 00:50:26.510
So you hand it off to coerce object,
MOSL coerce object desk.

00:50:26.620 --> 00:50:31.940
And it will take the 2 parameter,
the object specifier.

00:50:32.300 --> 00:50:35.880
And it will call back inside
your application and resolve

00:50:35.880 --> 00:50:38.460
that and get the name of file 2.

00:50:38.460 --> 00:50:41.610
And return the string and say, okay,
this is what you should set it to.

00:50:41.860 --> 00:50:45.190
Set name of,
set this token to this string.

00:50:45.220 --> 00:50:47.860
And then you just do it because
then you know what it is.

00:50:50.530 --> 00:50:54.490
More OSL does deep object resolution,
which is really cool.

00:50:54.660 --> 00:50:58.780
It's for cases like...

00:50:59.690 --> 00:51:05.540
First file of every folder of every disk.

00:51:05.570 --> 00:51:06.960
That's going to be a list.

00:51:07.000 --> 00:51:10.140
And what that's going to be
a list of is on every disk,

00:51:10.250 --> 00:51:12.830
for every folder at the
top level of every disk,

00:51:12.830 --> 00:51:15.030
you want the first file
of each of those folders.

00:51:15.060 --> 00:51:18.700
Or the name of the first file
of each of those folders.

00:51:18.700 --> 00:51:22.760
And so,
MoroSL has an object resolution algorithm

00:51:22.760 --> 00:51:27.440
that goes deep into those structures
and creates one long list from that.

00:51:28.260 --> 00:51:29.550
We could go into it.

00:51:29.650 --> 00:51:32.350
It's well documented in
the MoroSL documentation.

00:51:32.350 --> 00:51:37.430
So, without further ado,
if we could have demo machine one up.

00:51:43.900 --> 00:51:49.010
Great.

00:51:49.110 --> 00:51:51.520
When you download more OSL,
one of the first things you

00:51:51.520 --> 00:51:55.220
notice is you get a lot of the
more is better classes with you.

00:51:55.220 --> 00:51:58.020
You get more Apple events, more Windows,
more text utils.

00:51:58.020 --> 00:52:01.930
The demo application
relies on a bunch of those.

00:52:02.310 --> 00:52:04.530
But there are two main things.

00:52:04.710 --> 00:52:09.640
The more OSL files, relatively small.

00:52:09.640 --> 00:52:13.880
Most of the work is done in this
140k text file called moreOSL.c.

00:52:14.190 --> 00:52:17.350
There are a couple of separate
files for the string comparisons,

00:52:17.350 --> 00:52:21.000
which are A, heinous, and B,
the cause of many bug reports,

00:52:21.010 --> 00:52:24.310
which Quinn has filed,
basically saying AppleScript should

00:52:24.320 --> 00:52:26.950
either do this itself or
have callbacks to do this,

00:52:27.040 --> 00:52:30.220
because as you might know,
it's very hard for your application

00:52:30.340 --> 00:52:34.450
to do string comparisons the same way
AppleScript does string comparisons,

00:52:34.450 --> 00:52:36.900
and that can be unexpected to users.

00:52:36.900 --> 00:52:40.540
So we're taking that feedback and
trying to do something with it.

00:52:40.760 --> 00:52:47.180
There's a a a small source
code file to manipulate tokens,

00:52:47.180 --> 00:52:49.880
small source code file
that's some helper routines,

00:52:49.880 --> 00:52:52.770
but really,
moreOSL is itself a relatively

00:52:52.780 --> 00:52:54.350
small piece of code.

00:52:54.360 --> 00:52:58.120
The second thing you'll find is a
fully functional test application

00:52:58.120 --> 00:53:02.310
in CodeWarrior called testmoreOSL,
and the delightful thing about this is

00:53:02.310 --> 00:53:04.680
it has almost no user interface at all.

00:53:04.700 --> 00:53:08.500
So you won't be tempted to
try to play with the UI.

00:53:08.500 --> 00:53:11.590
It is mostly a scriptable application.

00:53:11.600 --> 00:53:24.250
And so if we um go to CodeWarrior,
and open up should have moreOSL,

00:53:24.710 --> 00:53:27.700
testmoreOSL.com.

00:53:31.560 --> 00:53:36.100
Here's the test application,
and there's one source file for the test

00:53:36.180 --> 00:53:39.250
application and a terminology resource,
and that's about it.

00:53:39.320 --> 00:53:42.280
And then the rest are
the more OSL sources.

00:53:42.280 --> 00:53:47.180
And the test application is one file,
and what it does is it

00:53:47.180 --> 00:53:52.450
creates a model of a,
you have the application,

00:53:52.530 --> 00:53:55.770
the application has windows,
and each window can have nodes in it,

00:53:55.970 --> 00:54:00.000
and nodes are just simple rectangles,
and nodes can have subnodes in them.

00:54:00.500 --> 00:54:02.120
And that is the user model.

00:54:02.140 --> 00:54:05.100
So what we did was we
created a user model,

00:54:05.100 --> 00:54:07.380
windows, nodes, subnodes.

00:54:07.460 --> 00:54:11.250
Then did a terminology for it and came up
with all the appropriate four-character

00:54:11.250 --> 00:54:14.280
codes for all of the events and
the class and things like that.

00:54:14.360 --> 00:54:20.320
And then built those tables and wrote
those accessors like we talked about.

00:54:20.360 --> 00:54:28.780
So, for example,
in the testmoreosl.c file, here's the,

00:54:30.400 --> 00:54:34.230
here are all of the
routines on the application,

00:54:34.270 --> 00:54:36.040
because the application contains windows.

00:54:36.540 --> 00:54:43.030
There's a getter, setter, counter,
and access by index routine,

00:54:43.100 --> 00:54:46.040
and those are listed in
its appropriate tables.

00:54:46.390 --> 00:54:51.810
There's the events it handles, open,
reopen, open document, quit, and make.

00:54:52.040 --> 00:54:54.990
So basically you have one
routine for the getter,

00:54:54.990 --> 00:54:58.240
setter, counter, and access,
and then one routine

00:54:58.240 --> 00:54:59.840
for each event it takes.

00:54:59.840 --> 00:55:02.660
And the routines are pretty simple.

00:55:02.660 --> 00:55:04.480
So here's the application getter.

00:55:04.480 --> 00:55:06.740
I thought I'd set the text size on this.

00:55:06.740 --> 00:55:08.600
I hit power plant.

00:55:08.610 --> 00:55:11.770
There we go.

00:55:13.800 --> 00:55:18.700
So here's your application getter,
and it gets a token in,

00:55:18.700 --> 00:55:23.400
and if the token is a property,
then you switch on that property,

00:55:23.400 --> 00:55:26.920
and if it's the version,
then you get the version

00:55:26.920 --> 00:55:28.770
property and return it.

00:55:31.510 --> 00:55:35.050
If it's a unique ID,
then you return a unique ID.

00:55:35.050 --> 00:55:36.960
And otherwise, you say, no such object.

00:55:37.020 --> 00:55:38.570
It's a very simple getter.

00:55:42.510 --> 00:55:46.230
So then there's a window class,
and the window has its getter setter,

00:55:46.230 --> 00:55:48.780
and its event it responds to,
which is close.

00:55:48.850 --> 00:55:54.810
And so here's the handler
for the window close event,

00:55:54.810 --> 00:55:54.810
which is basically--

00:55:55.480 --> 00:56:01.670
handles the saving in parameter,
so it gets that, and then

00:56:01.990 --> 00:56:05.650
closes the window with or
without the save options.

00:56:05.770 --> 00:56:07.910
It's a very simple handler.

00:56:10.470 --> 00:56:15.380
So here's the document inside the window,
and the document handles make new.

00:56:15.400 --> 00:56:21.470
And so this routine handles the...

00:56:21.720 --> 00:56:28.260
make event when it determines
we want to make a document.

00:56:28.260 --> 00:56:29.690
And it creates a new properties record.

00:56:30.400 --> 00:56:37.700
And this actually uses more of the
more is better window classes in order

00:56:37.700 --> 00:56:41.300
to put the window up on the screen.

00:56:41.400 --> 00:56:44.570
But it basically creates
the classes for that.

00:56:45.280 --> 00:56:47.110
And then here are some
of the custom objects.

00:56:47.200 --> 00:56:49.540
Here's the node.

00:56:49.540 --> 00:56:51.250
And here's your node access by index.

00:56:51.350 --> 00:56:55.660
Since more OSL doesn't have
like an L list structure,

00:56:55.790 --> 00:56:58.610
it has to manage its own
data structures itself.

00:56:58.700 --> 00:57:01.160
It doesn't have collection
classes to fall back on.

00:57:01.160 --> 00:57:05.830
So it just basically has
an index list of nodes,

00:57:05.970 --> 00:57:08.710
which are node pointers.

00:57:08.710 --> 00:57:11.450
And then it finds it by index.

00:57:11.600 --> 00:57:15.180
And if it doesn't find it,
then it says it doesn't have an L list.

00:57:15.200 --> 00:57:17.070
of this type.

00:57:17.880 --> 00:57:22.670
So you can see that once you
set up the more OSL structure,

00:57:22.740 --> 00:57:27.500
actually implementing the Apple event
and object model handling,

00:57:27.500 --> 00:57:28.400
it's very straightforward.

00:57:28.400 --> 00:57:32.750
For every event and these specific
things you have to do for every class,

00:57:32.860 --> 00:57:35.440
you write one routine whose inputs
are these and outputs are these,

00:57:35.460 --> 00:57:38.400
and then the rest of the stuff is
just basically handled for you,

00:57:38.530 --> 00:57:39.920
and it makes it a lot simpler.

00:57:39.920 --> 00:57:43.940
Let me show you this in action.

00:57:44.540 --> 00:57:47.670
Is it running?

00:57:47.680 --> 00:57:49.700
We'll debug this.

00:57:51.960 --> 00:57:52.890
and run it.

00:57:53.070 --> 00:57:55.900
And we can open up the script.

00:57:55.900 --> 00:58:00.820
One of the things I love about
this is that it comes with

00:58:00.960 --> 00:58:06.600
a test script which has some
particularly heinous cases in it.

00:58:06.600 --> 00:58:10.970
I mean it ba--it really
ex--exercises most of the code paths

00:58:11.120 --> 00:58:14.840
with--within the test application
and within MoreOSL itself.

00:58:14.840 --> 00:58:16.920
So, for example,
here's a lot of things that

00:58:17.220 --> 00:58:20.830
you should be able to send from
AppleScript to your application

00:58:20.840 --> 00:58:24.240
and have your application handle.

00:58:24.240 --> 00:58:27.450
You know,
set frontmost of window to true and make

00:58:27.570 --> 00:58:35.600
new document with properties and set
position of node dis--set position of

00:58:35.600 --> 00:58:40.420
some element of some document to a list.

00:58:40.900 --> 00:58:44.930
Make a new window with properties.

00:58:44.940 --> 00:58:46.790
You know,
these are a bunch of things that you

00:58:46.950 --> 00:58:53.590
should support in your code if you have
classes that support--that support them.

00:58:54.150 --> 00:58:59.040
And so we're going to open
up the event log here,

00:58:59.180 --> 00:59:02.520
show the event results.

00:59:02.520 --> 00:59:06.380
Let's compile this
against the application.

00:59:09.410 --> 00:59:11.560
There are a lot of test cases in here.

00:59:11.660 --> 00:59:12.860
It's a big script.

00:59:12.860 --> 00:59:18.410
And we're going to execute
it against that application.

00:59:18.410 --> 00:59:22.290
And here are all the test
cases we're going to run.

00:59:32.800 --> 00:59:39.030
and we're going to run it before
the Apple event times out.

00:59:39.030 --> 00:59:42.510
And you can see as they scroll by,
here are a whole lot of object model

00:59:42.620 --> 00:59:45.000
events going to this application.

00:59:45.190 --> 00:59:49.420
There's getters, there's setters,
there's create new, there's delete,

00:59:49.420 --> 00:59:51.650
there's move, there's duplicate.

00:59:51.740 --> 00:59:55.360
And that relatively simple application,
okay, it doesn't do anything with nodes,

00:59:55.360 --> 00:59:58.980
it does very little with Windows,
but that relatively simple

00:59:58.980 --> 01:00:04.020
application is handling all of these
Apple events and handling them well.

01:00:04.020 --> 01:00:08.820
You can see some of the
stuff we're doing here.

01:00:08.840 --> 01:00:12.410
Set the properties property of a
window to a list of properties,

01:00:12.410 --> 01:00:13.350
which is nice.

01:00:13.480 --> 01:00:23.990
Set names of windows,
get names of startup disks, exist files.

01:00:24.710 --> 01:00:26.530
Get ID of Last window.

01:00:26.650 --> 01:00:31.900
Here, the sum key form,
which is supposedly take a random

01:00:31.900 --> 01:00:37.000
element from this list of element,
that's fully implemented.

01:00:37.110 --> 01:00:38.940
So if we can go back
to the slide machine,

01:00:39.090 --> 01:00:40.980
and we'll wrap up here.

01:00:42.420 --> 01:00:43.790
Some other nice things about it.

01:00:43.890 --> 01:00:46.850
The application and window
classes are populated,

01:00:46.850 --> 01:00:51.010
so if you're using the other
more is better window classes,

01:00:51.010 --> 01:00:55.940
then you can just get that functionality
for free for things like normal

01:00:55.940 --> 01:00:58.550
application and window properties.

01:00:58.560 --> 01:01:02.200
And it knows about file objects,
which are another thing that

01:01:02.200 --> 01:01:07.180
Quinn filed a lot of bugs on,
is that sometimes AppleScript will

01:01:07.180 --> 01:01:11.860
send your application queries
about system-wide objects,

01:01:11.860 --> 01:01:14.910
like the name of a file given an FS spec.

01:01:14.980 --> 01:01:18.210
And it expects you to handle that,
to be able to get the name

01:01:18.210 --> 01:01:19.850
of an FS spec and return it.

01:01:19.930 --> 01:01:22.520
And if you don't know that
you're supposed to do that,

01:01:22.640 --> 01:01:24.460
and nobody tells you
you're supposed to do that,

01:01:24.460 --> 01:01:27.840
it's a pain in the butt,
and it will result in a user bug report.

01:01:27.840 --> 01:01:28.380
But.

01:01:28.650 --> 01:01:31.110
More OSL does that for you.

01:01:31.170 --> 01:01:32.200
Okay.

01:01:32.310 --> 01:01:34.310
Here's some notable omissions.

01:01:34.440 --> 01:01:35.930
There's really no object management.

01:01:35.940 --> 01:01:38.650
Like I said, there are no collection
classes for your objects,

01:01:38.650 --> 01:01:40.630
so you need to manage
your objects yourself,

01:01:40.700 --> 01:01:43.360
and you need to have the
actual routines to do make,

01:01:43.460 --> 01:01:46.410
new, delete, move,
and duplicate the objects yourself.

01:01:46.600 --> 01:01:49.690
I mean, the routines will call you,
but since it's not C++,

01:01:49.820 --> 01:01:53.770
it's not going to fire off constructors
and destructors automatically.

01:01:53.870 --> 01:01:56.060
You have to write that code yourself.

01:01:56.060 --> 01:01:58.080
The print event is not implemented.

01:01:58.080 --> 01:01:58.560
Selection.

01:01:58.560 --> 01:01:59.960
And insertion points.

01:02:00.010 --> 01:02:02.580
Generally,
the text classes are not supported.

01:02:02.820 --> 01:02:04.460
You'll have to do that yourself.

01:02:04.530 --> 01:02:07.520
Like I said,
form relative position isn't implemented,

01:02:07.530 --> 01:02:10.840
but we're going to try to twist
somebody's arm to get that in.

01:02:10.880 --> 01:02:14.930
And no support for things like
properties of a built-in type.

01:02:15.030 --> 01:02:20.080
Like if the result of a
get operation is a string,

01:02:20.280 --> 01:02:23.340
and you ask for the class of that,
if you ask for class of

01:02:23.340 --> 01:02:27.660
version of application,
it won't handle that right.

01:02:27.690 --> 01:02:28.460
But then again, I don't know.

01:02:28.480 --> 01:02:31.600
I know of relatively few
applications that do.

01:02:31.680 --> 01:02:33.990
And it also doesn't support
class properties whose

01:02:33.990 --> 01:02:35.880
values are records or lists.

01:02:36.040 --> 01:02:39.270
And that's a philosophical decision,
and we're going to have a

01:02:39.310 --> 01:02:42.100
philosophical discussion about it.

01:02:43.820 --> 01:02:47.130
So, in summary,
if you want to use PowerPlant,

01:02:47.140 --> 01:02:51.410
PowerPlant can provide easy scripting
for your scriptable application.

01:02:51.520 --> 01:02:54.780
There are some things, you know,
a lot of things you have to do yourself.

01:02:54.800 --> 01:03:00.320
But you can really get
started by just overriding,

01:03:00.500 --> 01:03:05.340
you know, inheriting from,
descending from LL object and

01:03:05.340 --> 01:03:08.520
overriding a few handlers,
and you can get a scripting

01:03:08.670 --> 01:03:09.840
implementation started.

01:03:10.570 --> 01:03:13.730
What I really recommend you
do is you trash the default

01:03:13.730 --> 01:03:16.860
dictionary implementation,
and you start from the beginning

01:03:16.860 --> 01:03:19.900
rather than just trying to,
like, monkey with the sample application.

01:03:21.350 --> 01:03:25.650
For more OSL, if you don't have a
framework-based application,

01:03:25.650 --> 01:03:27.570
this is really most appropriate for it.

01:03:27.750 --> 01:03:30.050
It's the fastest way
to get the basics done,

01:03:30.050 --> 01:03:32.120
because all you do is
write a few handlers,

01:03:32.120 --> 01:03:34.130
install them in tables, and there you go.

01:03:34.140 --> 01:03:36.530
It assumes you're doing
your own object management,

01:03:36.530 --> 01:03:38.260
which most of you are doing anyway.

01:03:38.260 --> 01:03:40.880
And it's very well commented
and very well tested.

01:03:40.880 --> 01:03:45.350
And we have some investment in it,
in that when we come out with a new

01:03:45.350 --> 01:03:50.260
dictate of how a new AppleScript feature
is supposed to be implemented,

01:03:50.260 --> 01:03:52.890
like a properties property,
we'll try to get that into

01:03:52.890 --> 01:03:54.450
more OSL as sample code.

01:03:56.650 --> 01:04:02.300
We have a couple of sessions coming
up in a very short period of time.

01:04:02.380 --> 01:04:03.440
I think it's at 3:30.

01:04:03.440 --> 01:04:07.380
A feedback forum across the hall,
way on the other end,

01:04:07.490 --> 01:04:09.810
for general feedback on AppleScript.

01:04:09.960 --> 01:04:13.060
If you want to know more about
doing scripting in Cocoa,

01:04:13.150 --> 01:04:16.740
you should go to the
Cocoa in-depth session instead,

01:04:16.850 --> 01:04:18.800
which is across the street
at the Civic Auditorium.

01:04:19.000 --> 01:04:22.860
A long walk, too bad,
but Mike Ferris will give you a good show

01:04:22.860 --> 01:04:25.360
on what you can do in Cocoa scripting.

01:04:25.770 --> 01:04:29.760
Same contact information
for the last presentation,

01:04:29.760 --> 01:04:34.010
but for Code Warrior and PowerPlant,
I recommend you contact

01:04:34.010 --> 01:04:35.480
Metrowerk's technical support.

01:04:35.710 --> 01:04:40.600
And for questions about more OSL,
DTS at Apple.com.

01:04:40.620 --> 01:04:42.660
Thanks very much for your attention.

01:04:42.660 --> 01:04:48.420
Yes?

01:04:48.420 --> 01:04:49.390
Yes.
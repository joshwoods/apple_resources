WEBVTT

00:00:13.030 --> 00:00:16.650
Ladies and gentlemen,
please welcome the Mac OS X Applications

00:00:16.700 --> 00:00:19.840
Technology Manager,
David Wright.

00:00:24.160 --> 00:00:24.580
Thank you.

00:00:24.680 --> 00:00:27.210
Welcome to session 121
of Carbon Events 1.

00:00:27.220 --> 00:00:28.640
We're going to do this
one more time today,

00:00:28.640 --> 00:00:30.750
so it's good to have it.

00:00:31.010 --> 00:00:33.720
This is a really exciting
day today in Hall 2.

00:00:33.860 --> 00:00:36.880
The technologies being presented
are amazing and will increase

00:00:36.880 --> 00:00:38.830
your productivity tenfold.

00:00:38.990 --> 00:00:42.830
This next session is about Carbon Events,
and I just want to hear it.

00:00:43.000 --> 00:00:45.790
How many of you want
Carbon Events like yesterday?

00:00:46.040 --> 00:00:49.010
I know it's true.

00:00:49.730 --> 00:00:52.930
When I was working with the team
to prepare for this presentation,

00:00:52.930 --> 00:00:56.870
I just was like so grateful that
today is here because the number

00:00:56.870 --> 00:01:00.900
one request from Carbon developers
has been Carbon Events because

00:01:00.900 --> 00:01:04.420
of the productivity,
code cleanup, performance gain that

00:01:04.420 --> 00:01:06.690
Carbon Events brings
to Carbon applications.

00:01:06.700 --> 00:01:09.800
So, would you please give a
big welcome to Ed Voas,

00:01:09.800 --> 00:01:14.270
Manager of High Level Toolbox in
Apple Software Engineering Group.

00:01:20.910 --> 00:01:28.270
So, the Carbon Event Model is without
a doubt the most significant change

00:01:29.000 --> 00:01:35.900
that we've made to the Mac OS Toolbox
since its inception over 15 years ago.

00:01:35.900 --> 00:01:38.900
And I'm not just saying
that because I wrote it.

00:01:38.900 --> 00:01:40.820
It's actually a fact.

00:01:40.900 --> 00:01:46.220
This should change the way that you
think about the toolbox from just

00:01:46.280 --> 00:01:51.030
a collection of APIs that you call
in some hopefully correct order,

00:01:51.030 --> 00:01:53.900
to a model where the toolbox
does a lot of the work for you.

00:01:53.900 --> 00:01:58.900
And you just tap into that event
flow and override things as you like.

00:01:59.060 --> 00:02:01.280
So what you're going to learn today:

00:02:01.520 --> 00:02:05.090
There's a lot of basic concepts and
terminology that we use whenever

00:02:05.090 --> 00:02:08.080
we talk about Carbon Events.

00:02:08.140 --> 00:02:12.720
You'll also learn about how
events flow in Mac OS X.

00:02:13.670 --> 00:02:20.410
And you'll also learn where Waitnext
Event fits into all of this.

00:02:20.800 --> 00:02:25.550
And you'll also learn that I'm right,
and Carbon Events rock!

00:02:25.630 --> 00:02:26.860
So, what is Carbon Events?

00:02:26.980 --> 00:02:30.740
Carbon Events is the
event system for Carbon.

00:02:30.810 --> 00:02:34.340
This isn't something that we stuck
on the side of WaitNext Event and

00:02:34.340 --> 00:02:35.430
just kind of grafted it on.

00:02:35.610 --> 00:02:37.280
This is the event system.

00:02:37.350 --> 00:02:42.620
WaitNext Event actually is built
in terms of this new event system.

00:02:42.690 --> 00:02:44.890
But, of course,
you wouldn't go through all the

00:02:44.890 --> 00:02:47.700
trouble of inventing this event system
just to put WaitNext Event on top.

00:02:47.740 --> 00:02:49.340
There's got to be something more to it.

00:02:49.500 --> 00:02:51.400
And, of course, there is.

00:02:51.450 --> 00:02:53.640
And what that is,
is there's a completely new way of

00:02:53.640 --> 00:02:56.550
getting events into your application.

00:02:56.690 --> 00:03:01.740
This is a way where you basically install
handlers on windows controls and menus,

00:03:01.790 --> 00:03:05.170
and get events directly
dispatched by the toolbox.

00:03:05.940 --> 00:03:09.380
The best part is that this
new event model can be mixed

00:03:09.460 --> 00:03:12.640
with the old event model,
meaning that apps that continue

00:03:12.670 --> 00:03:15.410
to call "wait next event" can
still take advantage of all the

00:03:15.600 --> 00:03:19.530
features that I'll be talking
about throughout the presentation.

00:03:19.850 --> 00:03:21.580
So why did we do this?

00:03:21.780 --> 00:03:25.480
Well, we wanted to make it really,
really simple to write

00:03:25.550 --> 00:03:27.300
a Carbon application.

00:03:27.370 --> 00:03:30.450
In fact, it's actually possible to write
a Carbon application in about

00:03:30.480 --> 00:03:32.750
seven to ten lines of code.

00:03:33.760 --> 00:03:36.900
And we do that by providing all of
the default behaviors that everybody

00:03:37.100 --> 00:03:42.590
in the world has ever had to write
in order to bring up a Macintosh app.

00:03:43.940 --> 00:03:48.280
We also wanted an event system
that encouraged high performance,

00:03:48.510 --> 00:03:50.900
especially on Mac OS X.

00:03:52.150 --> 00:03:56.860
We'll go into a little bit of that
as we go throughout the presentation.

00:03:56.900 --> 00:04:00.960
We also have all these nutty,
disparate ways of getting

00:04:00.960 --> 00:04:02.960
notifications into your application.

00:04:02.960 --> 00:04:04.950
We have event records.

00:04:05.080 --> 00:04:09.280
We have different
notifications via callbacks.

00:04:09.420 --> 00:04:12.900
We also have things like defprocs
for windows controls and menus.

00:04:12.940 --> 00:04:15.800
And we wanted a system that
would actually unify all of

00:04:15.870 --> 00:04:20.000
those into one consistent,
homogenous model.

00:04:21.700 --> 00:04:24.940
And as a side benefit to all of this,
we ended up getting a system

00:04:24.940 --> 00:04:28.040
that actually provides much
better support for plug-ins.

00:04:28.160 --> 00:04:31.660
This is a model where events can
actually be dispatched directly to

00:04:31.750 --> 00:04:36.590
a window that's owned by a plug-in,
rather than having the host application

00:04:36.590 --> 00:04:38.490
even involved in the event flow.

00:04:40.450 --> 00:04:45.880
So, here's a comparison of the
current WaitNext Event model

00:04:46.130 --> 00:04:48.900
with the new Carbon Event model.

00:04:48.930 --> 00:04:53.700
So, with WaitNext Event, you know,
it's basically your job to do everything.

00:04:53.730 --> 00:04:56.540
You pick up an event from the system
and then you decide what to do with it.

00:04:56.620 --> 00:04:59.040
So you have to dispatch the events.

00:04:59.070 --> 00:05:01.770
And you typically do this by getting,
say, a mouse down,

00:05:01.860 --> 00:05:06.500
calling something like FindWindow,
deciding it's on,

00:05:06.500 --> 00:05:10.350
maybe the mouse went down on the window,
and

00:05:11.000 --> 00:05:13.400
Based on the result of that call,
then doing something interesting

00:05:13.400 --> 00:05:15.200
like dragging the window.

00:05:15.290 --> 00:05:16.960
So as a result,
you have to write all this

00:05:16.960 --> 00:05:18.760
code over and over and over.

00:05:19.580 --> 00:05:23.590
This has resulted in many people writing
their own little skeleton applications,

00:05:23.650 --> 00:05:27.200
or things like that,
just to get a simple app up and running.

00:05:27.300 --> 00:05:31.600
On the Carbon Event side,
for a pure Carbon Event app,

00:05:31.640 --> 00:05:34.420
the main API that you would call
to drive your application is

00:05:34.500 --> 00:05:36.500
called RunApplicationEventLoop.

00:05:36.560 --> 00:05:37.990
Once you're inside there, that's it.

00:05:38.150 --> 00:05:39.820
Your app is running.

00:05:40.310 --> 00:05:42.810
And while inside there,
all the events are actually

00:05:43.080 --> 00:05:46.280
dispatched by the toolbox to the
appropriate handlers that make sense

00:05:46.280 --> 00:05:48.120
for the specific type of event.

00:05:48.230 --> 00:05:49.820
As a result of this,
you don't have to write

00:05:49.820 --> 00:05:50.940
that boilerplate code.

00:05:51.050 --> 00:05:52.040
We've done all the work.

00:05:52.100 --> 00:05:54.400
You just do the interesting stuff.

00:05:56.700 --> 00:05:59.950
In the WaitNext Event Model,
in order to get time to do

00:05:59.950 --> 00:06:03.900
things like blink the cursor or
whatever other periodic tasks

00:06:03.900 --> 00:06:07.840
your application might have,
you rely on something called Null Events.

00:06:07.940 --> 00:06:09.650
When WaitNext Event didn't have
anything better to give you,

00:06:09.650 --> 00:06:11.660
it would hand you a Null Event,
and you would try to do

00:06:11.660 --> 00:06:13.490
something interesting with that.

00:06:13.920 --> 00:06:17.770
In the Carbon Event Model,
we have a concept called Timers.

00:06:17.930 --> 00:06:20.160
You install Timers,
and that's the way your

00:06:20.180 --> 00:06:21.990
application gets timed.

00:06:23.050 --> 00:06:27.000
In the old world,
the only way to actually

00:06:27.000 --> 00:06:32.300
override any aspect of what the
toolbox was doing was to patch.

00:06:32.680 --> 00:06:34.740
And obviously you can't
patch in Mac OS X,

00:06:34.740 --> 00:06:38.360
but what we do have is the ability to
install event handlers on all of the

00:06:38.360 --> 00:06:40.600
objects that the Toolbox supports.

00:06:40.630 --> 00:06:44.110
And that is the way you
override Toolbox behavior.

00:06:44.600 --> 00:06:47.180
So here's a conceptual picture
of what we're talking about.

00:06:47.270 --> 00:06:50.260
At the bottom,
we have the Carbon Event Model.

00:06:50.320 --> 00:06:55.760
On top of that, we have Wait Next Event,
Run Application Event Loop.

00:06:56.150 --> 00:06:58.500
And on top of that sits your application.

00:06:58.550 --> 00:07:00.550
And your application can
call WaitNextEvent or run

00:07:00.550 --> 00:07:03.050
Application Event Loop,
but it's also going to talk to the

00:07:03.050 --> 00:07:08.540
Event Model directly to do things
like install event handlers or timers.

00:07:09.850 --> 00:07:14.220
Now the first new thing to be aware
of is something called the Event Loop.

00:07:14.280 --> 00:07:17.600
You'll also hear this
referred to as a Run Loop.

00:07:17.950 --> 00:07:20.590
This isn't the event loop
that's in your application.

00:07:20.600 --> 00:07:24.040
This is another construct,
very low level in the system,

00:07:24.110 --> 00:07:24.900
inside Carbon.

00:07:25.120 --> 00:07:28.900
This is essentially where events
arrive for your application.

00:07:28.900 --> 00:07:33.110
Its main job is to take events
from the lower level sources and

00:07:33.130 --> 00:07:37.160
turn them into a Carbon Event and
put them in your Event Queue.

00:07:37.760 --> 00:07:41.200
This is implicitly run for you whenever
you call an API like "wait_next_event",

00:07:41.230 --> 00:07:43.520
"run_application", "event_loop", etc.

00:07:43.590 --> 00:07:46.780
The best part is that when
you call the event loop,

00:07:46.930 --> 00:07:54.430
if there are no events waiting,
your application blocks,

00:07:54.430 --> 00:07:54.430
meaning you're not spending
CPU time for no reason.

00:07:55.700 --> 00:08:02.060
So, I want to just cover the way
events actually flow in Mac OS X.

00:08:02.570 --> 00:08:07.830
So, first, some event comes in,
because somebody clicked the mouse,

00:08:07.930 --> 00:08:11.930
so it comes in to some
I/O Kit driver in the kernel.

00:08:12.040 --> 00:08:14.850
The kernel just ends up handing
that off to the Windows Server.

00:08:14.960 --> 00:08:18.140
The Windows Server is actually
where the interesting part happens,

00:08:18.220 --> 00:08:23.040
because the Windows Server has the
knowledge necessary to determine what app

00:08:23.310 --> 00:08:25.100
This event should go to.

00:08:25.200 --> 00:08:28.270
So it does that by looking at
what the front most process is.

00:08:28.310 --> 00:08:32.180
You know, if it was a mouse down,
what window did the mouse happen to hit?

00:08:32.190 --> 00:08:34.750
And depending on what
the state of things are,

00:08:34.930 --> 00:08:39.760
it'll finally send the event up
into the application's event loop.

00:08:40.000 --> 00:08:41.640
And of course,
the event loop just turns around,

00:08:41.660 --> 00:08:44.320
creates a Carbon Event,
and puts it in the event queue.

00:08:44.330 --> 00:08:46.870
Now the interesting thing to
note in this picture is that

00:08:47.440 --> 00:08:49.020
each app has its own event queue.

00:08:49.020 --> 00:08:52.860
There's not one global event
queue like there was on Mac OS 9.

00:08:53.600 --> 00:08:56.990
The other interesting thing about
the event loop in general is that

00:08:57.220 --> 00:09:00.600
you need to run it in order to
get the events in your queue,

00:09:00.750 --> 00:09:02.590
which is a little
different from Mac OS 9,

00:09:02.620 --> 00:09:05.440
because in Mac OS 9,
all these events came in asynchronously.

00:09:05.520 --> 00:09:09.430
They were typically posted
through some interrupt handler.

00:09:11.980 --> 00:09:13.900
So once you actually get the
events in your application,

00:09:13.900 --> 00:09:17.180
you probably want to
do something with it.

00:09:17.230 --> 00:09:19.490
The way you would drive an
application is you can either call

00:09:19.490 --> 00:09:22.420
waitNextEvent like you always have,
or you can switch to

00:09:22.420 --> 00:09:24.000
runApplicationEventLoop.

00:09:24.040 --> 00:09:28.080
Again, runApplicationEventLoop is really
for the pure Carbon Event-based apps.

00:09:28.110 --> 00:09:29.260
You wouldn't just drop that in.

00:09:29.310 --> 00:09:31.300
I don't think it would do
exactly what you wanted.

00:09:31.360 --> 00:09:38.580
But those two APIs actually
dispatch events when they're called.

00:09:38.910 --> 00:09:42.320
So while you're inside Waitnext
Event or run the application event loop,

00:09:42.320 --> 00:09:44.610
events will get dispatched to any
handlers that you have installed,

00:09:44.720 --> 00:09:47.430
provided the event makes
sense for that handler.

00:09:47.710 --> 00:09:51.990
If you happen to need to get an
event from the event system and

00:09:51.990 --> 00:09:55.490
not have any dispatching happen,
there's a lower-level

00:09:55.620 --> 00:09:57.960
API called ReceiveNextEvent.

00:09:59.690 --> 00:10:03.900
So let's take a closer look
at what Waitnext Event looks

00:10:03.960 --> 00:10:06.280
like in this new system.

00:10:06.350 --> 00:10:09.390
So obviously it still works.

00:10:09.390 --> 00:10:09.390
Good thing.

00:10:10.700 --> 00:10:14.160
The biggest change is
that when it's called,

00:10:14.200 --> 00:10:16.990
like I said, events get dispatched.

00:10:17.480 --> 00:10:20.530
And this means that an event, actually,
if an event does get dispatched and

00:10:20.600 --> 00:10:23.670
handled by some handler that you might
have installed in your application,

00:10:23.670 --> 00:10:26.400
it actually does not get
returned to a WaitNext event.

00:10:26.400 --> 00:10:29.400
And this is actually the way that
I mentioned that actually helps plugins.

00:10:29.400 --> 00:10:32.140
The event will actually get
dispatched to some plugin,

00:10:32.240 --> 00:10:34.290
and WaitNext event just never sees it.

00:10:35.590 --> 00:10:39.350
Another change from the traditional
Mac OS point of view is that the

00:10:39.350 --> 00:10:42.570
sleep time is fully respected,
regardless of whether you're in the

00:10:42.570 --> 00:10:44.500
foreground or you're in the background.

00:10:44.980 --> 00:10:49.480
Typically, on traditional Mac OS 9,
if your app is in the background,

00:10:49.490 --> 00:10:53.500
we respect your sleep time,
but if you're in the foreground,

00:10:53.500 --> 00:10:57.510
we will just call you as often
as possible with null events.

00:10:58.300 --> 00:11:00.190
So, this is an important distinction.

00:11:00.200 --> 00:11:03.030
So you might have some scrolling
animation in your about box or something,

00:11:03.030 --> 00:11:05.760
and you'd be wondering,
"Why is it running so slow on Mac OS X?

00:11:05.760 --> 00:11:10.670
I thought Mac OS X was
fast." And the point is,

00:11:10.670 --> 00:11:10.670
you're actually sleeping,
but you didn't know you were.

00:11:11.950 --> 00:11:14.130
So another interesting thing
about WaitNext Event is that

00:11:14.140 --> 00:11:17.860
WaitNext Event can actually have
performance implications on Mac OS X,

00:11:17.860 --> 00:11:21.620
because it's very typical for an
application to assume that they can

00:11:21.620 --> 00:11:24.650
get all this idle time and then just,
you know, sleep for one tick.

00:11:24.700 --> 00:11:27.600
And if we have 20 applications running
and they're all sleeping for one tick,

00:11:27.700 --> 00:11:32.150
we're really like using all the
CPU and possibly for no good.

00:11:32.300 --> 00:11:36.780
It might just be you're updating,
you know, polling for modifier change

00:11:36.840 --> 00:11:38.520
or something like that.

00:11:39.680 --> 00:11:43.870
Here's a picture,
and it just illustrates what

00:11:43.910 --> 00:11:46.160
happens inside WaitNext Event.

00:11:46.210 --> 00:11:49.700
What WaitNext Event does is it actually
iterates through the event queue,

00:11:49.850 --> 00:11:54.060
and for each event, start at the top,
and we peek at the event,

00:11:54.070 --> 00:11:56.750
and we attempt to dispatch it.

00:11:57.030 --> 00:12:00.660
If the dispatching is successful,
we remove it from the queue,

00:12:00.710 --> 00:12:02.390
we go back and get another one.

00:12:02.430 --> 00:12:05.890
If the dispatching is unsuccessful,
then it's a candidate to actually

00:12:05.890 --> 00:12:07.340
be returned from WaitNextEvent.

00:12:07.410 --> 00:12:12.150
And we do the usual mask test to
make sure the event was actually

00:12:12.400 --> 00:12:13.640
something that the caller wanted.

00:12:13.770 --> 00:12:15.990
If so, we pull it out of the queue,
we're done.

00:12:16.050 --> 00:12:19.960
Else we loop back around.

00:12:20.040 --> 00:12:23.580
Now I mentioned
RunApplicationEventLoop is the

00:12:25.080 --> 00:12:31.410
A pure Carbon Event way
to drive your application.

00:12:31.630 --> 00:12:33.570
And the reason I said
a little bit ago that

00:12:34.020 --> 00:12:36.740
If you just plop this in
place of "wait next event,"

00:12:36.840 --> 00:12:38.230
it won't do what you expected.

00:12:38.230 --> 00:12:42.820
That's because runApplicationEventLoop,
once entered, never exits until something

00:12:42.820 --> 00:12:45.990
in your application calls
quitApplicationEventLoop.

00:12:46.000 --> 00:12:48.470
So it's expected that you'll
just call this in your app

00:12:48.470 --> 00:12:50.000
and then your app is running.

00:12:50.160 --> 00:12:52.000
And the flow chart
looks a little simpler.

00:12:52.040 --> 00:12:54.860
We just pull an event and we dispatch it.

00:12:57.710 --> 00:13:00.960
So I mentioned that timers are
the way to get time in order to

00:13:01.050 --> 00:13:03.540
do things like blink the cursor.

00:13:03.660 --> 00:13:08.040
So they can be used to do
periodic tasks like that,

00:13:08.040 --> 00:13:10.140
or you can also use them
as a one-shot timer.

00:13:10.140 --> 00:13:14.110
So you might want something to
time out in a couple of minutes.

00:13:14.240 --> 00:13:18.840
The best part about this
is that you can actually

00:13:19.550 --> 00:13:22.480
Put the timer code with
the code that wants it.

00:13:22.500 --> 00:13:25.540
You don't have to rely on some
outside entity to be gracious

00:13:25.540 --> 00:13:27.200
enough to hand you some idle time.

00:13:27.220 --> 00:13:30.040
You just say,
"I want idle time," and you'll get it.

00:13:30.080 --> 00:13:33.030
A good example of that is Netatext
Control that wants to blink the cursor.

00:13:33.040 --> 00:13:36.150
It can install its own timer,
and it will get that

00:13:36.150 --> 00:13:38.250
time to blink the cursor.

00:13:39.320 --> 00:13:43.160
In some ways this is really
similar to something like

00:13:43.160 --> 00:13:46.570
a construct in Power Plant,
where you might have L Periodic,

00:13:46.660 --> 00:13:49.200
which kind of doles out idle time.

00:13:49.200 --> 00:13:53.380
The main difference, of course,
is that we're actually doing

00:13:53.380 --> 00:13:55.200
this inside the event loop.

00:13:55.200 --> 00:13:57.880
And we can do it a lot more efficiently,
and we will block at

00:13:57.950 --> 00:14:00.580
the appropriate times,
which won't happen in

00:14:00.580 --> 00:14:02.550
something like L Periodic.

00:14:03.420 --> 00:14:06.260
Another important distinction,
something I just want to clarify,

00:14:06.260 --> 00:14:08.210
is that these timers run at task level.

00:14:08.530 --> 00:14:10.690
These are not asynchronous
to your application.

00:14:10.820 --> 00:14:13.920
They're very deterministic
in when they fire.

00:14:14.540 --> 00:14:16.960
and they fire when you
call the event loop.

00:14:16.960 --> 00:14:19.500
So when you call wait next event,
your timers will fire.

00:14:19.500 --> 00:14:23.820
When you call run application event loop,
your timers will fire.

00:14:23.850 --> 00:14:26.480
And they fire serially,
one after the other.

00:14:26.540 --> 00:14:30.440
So it's very well understood when
these things are going to fire.

00:14:30.490 --> 00:14:33.870
However,
there are also calls that will fire

00:14:33.870 --> 00:14:35.660
timers that you might not expect.

00:14:35.750 --> 00:14:41.760
For example, there is an API called
Track Mouse Location.

00:14:41.790 --> 00:14:44.650
And we're actually going to
see an example of this later,

00:14:44.650 --> 00:14:46.730
and especially in the next session.

00:14:46.800 --> 00:14:50.970
But Track Mouse Location is a replacement
for doing your standard mouse tracking.

00:14:51.570 --> 00:14:54.490
In order to do this,
what it does is it actually

00:14:54.710 --> 00:14:55.890
blocks on the event loop.

00:14:55.980 --> 00:14:59.390
So,
you might be tracking a mouse down event,

00:14:59.390 --> 00:15:00.490
but timers will be firing.

00:15:00.490 --> 00:15:03.800
And this might seem odd,
but it actually leads to some

00:15:03.930 --> 00:15:05.830
pretty cool functionality.

00:15:09.000 --> 00:15:13.170
The core event type of
Carbon Events is the Event Ref.

00:15:13.170 --> 00:15:15.260
This is the replacement
for the Event Record.

00:15:15.360 --> 00:15:17.410
This is your new friend.

00:15:18.600 --> 00:15:23.600
Essentially, it's an opaque data type,
like most of the toolbox types,

00:15:23.620 --> 00:15:27.780
and you get at things inside
this data type with accessors.

00:15:27.790 --> 00:15:29.900
If you're familiar at
all with Apple Events,

00:15:29.920 --> 00:15:32.840
this is going to seem like
a really familiar type,

00:15:32.840 --> 00:15:37.470
in that every event is actually
identified by a class and a kind.

00:15:37.560 --> 00:15:41.450
So we might send you an
event of class Mouse,

00:15:41.480 --> 00:15:43.680
but the kind is Mouse Down.

00:15:44.670 --> 00:15:48.610
We also have,
you can also have an arbitrary

00:15:48.940 --> 00:15:51.960
number of parameters on any event.

00:15:51.960 --> 00:15:54.570
And you get at them
via some symbolic name,

00:15:54.630 --> 00:15:58.160
and they're actually pseudo-type-safe,
just like Apple Events are.

00:15:59.730 --> 00:16:02.590
We also have retain
and release semantics.

00:16:02.590 --> 00:16:07.600
And if you're familiar with this
from Core Foundation terminology,

00:16:07.630 --> 00:16:08.840
you know what I'm talking about.

00:16:08.840 --> 00:16:12.540
If you have no idea what I mean,
it's just fancy terminology

00:16:12.670 --> 00:16:13.990
for ref counting.

00:16:14.350 --> 00:16:17.230
We do that to handle threaded cases.

00:16:17.420 --> 00:16:21.230
The best part about EventRefs is they're
not just a one-way communication idiom.

00:16:21.410 --> 00:16:25.030
They aren't just "something happened."
They can also be used to retrieve

00:16:25.390 --> 00:16:27.240
information from some entity.

00:16:27.250 --> 00:16:29.380
For example,
the Window Manager might send a

00:16:29.380 --> 00:16:33.240
hit-test event to a Window Definition.

00:16:33.240 --> 00:16:35.240
The Window Definition could
actually take that event,

00:16:35.240 --> 00:16:38.170
put in the part code,
and then the sender of that

00:16:38.170 --> 00:16:42.230
event will get that part code
once the event comes back.

00:16:43.980 --> 00:16:46.170
Times are much more
expressive in Event Riffs.

00:16:46.290 --> 00:16:49.790
Event records have times
expressed in terms of ticks.

00:16:49.840 --> 00:16:52.970
Ticks are very, very coarse-grained,
especially for some of the new

00:16:52.970 --> 00:16:54.520
input devices that are coming out.

00:16:54.720 --> 00:16:58.130
Things like high-resolution
tablets and stuff,

00:16:58.130 --> 00:17:02.520
which really want very,
very fine timestamping of events.

00:17:04.190 --> 00:17:06.810
We actually express
this time in a double.

00:17:06.810 --> 00:17:11.190
So we use a floating point
type to represent our time,

00:17:11.260 --> 00:17:15.380
which might seem a little odd,
but the fact is doubles

00:17:15.480 --> 00:17:17.300
have very fine precision.

00:17:17.410 --> 00:17:20.310
And though we're currently
using nanosecond granularity

00:17:20.440 --> 00:17:23.610
for our event times,
if we can get down some data, whatever,

00:17:23.800 --> 00:17:28.350
picosecond granularity,
we don't have to change our data type,

00:17:28.350 --> 00:17:31.810
because it still can be
expressed in terms of a float.

00:17:32.300 --> 00:17:35.570
And of course,
events are no good unless you

00:17:35.600 --> 00:17:36.750
can do something with them.

00:17:36.750 --> 00:17:39.280
So obviously you can post
them to the event queue,

00:17:39.280 --> 00:17:42.200
but the most important thing is
that you can send them to objects.

00:17:42.320 --> 00:17:45.190
And that is what the
Carbon Event Model is all about.

00:17:46.520 --> 00:17:49.940
And where you send an
event is an event target.

00:17:50.050 --> 00:17:54.780
This is an abstract concept.

00:17:55.170 --> 00:17:59.510
But what it is,
is it's just a place to send an event.

00:17:59.510 --> 00:18:02.100
And they're normally associated
with some sort of toolbox object.

00:18:02.100 --> 00:18:04.500
So if you want to send
an event to a window,

00:18:04.560 --> 00:18:08.730
you get the window's event target
by calling getWindowEventTarget.

00:18:08.930 --> 00:18:13.080
And each target has a stack of
handlers that have been installed.

00:18:14.170 --> 00:18:17.620
And they're a real stack,
so when they get installed,

00:18:17.620 --> 00:18:21.580
they get pushed on top of other handlers
that might have already been installed.

00:18:22.560 --> 00:18:28.000
So the topmost handler is
basically who gets the event first.

00:18:28.540 --> 00:18:30.120
And that handler could
turn around and say,

00:18:30.170 --> 00:18:33.540
"I handled it," or could decide, "No,
I didn't handle it.

00:18:33.620 --> 00:18:35.820
Let somebody else deal with it."

00:18:36.130 --> 00:18:43.580
and it does that basically by
returning the right OS status result.

00:18:44.140 --> 00:18:46.820
And this is the overriding idiom.

00:18:46.840 --> 00:18:51.390
This is the way you override
and customize the toolbox.

00:18:51.710 --> 00:18:55.120
Just by the mere fact that
you've installed a handler means

00:18:55.120 --> 00:18:56.400
you're overriding something.

00:18:56.520 --> 00:18:58.710
You're going to get an event,
and if you say you handled it,

00:18:58.820 --> 00:19:00.500
well then it's not going to
fall through to the toolbox,

00:19:00.500 --> 00:19:02.290
which may do something,
or it may do nothing,

00:19:02.300 --> 00:19:06.700
but you got first crack at that event,
and that's the important part.

00:19:07.090 --> 00:19:09.600
This is a conceptual
picture of an event target.

00:19:09.720 --> 00:19:12.800
So here we have an event
target with three handlers.

00:19:12.930 --> 00:19:15.900
The one on the bottom is for the object.

00:19:16.030 --> 00:19:18.860
So, let's use the example of a window.

00:19:18.960 --> 00:19:25.810
That object handler might be the DefProc,
or the DefProc replacement

00:19:25.810 --> 00:19:27.540
in terms of Carbon Events.

00:19:28.400 --> 00:19:31.370
On top of that, the toolbox might have
installed its own handler,

00:19:31.370 --> 00:19:35.080
which provides standard behaviors,
like dragging the window around.

00:19:35.930 --> 00:19:37.860
But on top of that,
your application might have

00:19:37.930 --> 00:19:39.130
pushed another handler.

00:19:39.230 --> 00:19:41.200
And that handler might say, "Well,
you know, I like all that drag

00:19:41.200 --> 00:19:43.060
window stuff you're doing,
but I really want it to dock to

00:19:43.060 --> 00:19:46.590
the size of the screen." That's
where you'd actually be able to tap

00:19:46.590 --> 00:19:48.530
in and override what was going on.

00:19:48.610 --> 00:19:51.520
So when an event comes in,
it tries to go down as far as it

00:19:51.520 --> 00:19:54.550
can through that stack of handlers,
and eventually yields a result.

00:19:54.730 --> 00:19:57.620
Either it was handled,
or it was not handled.

00:19:58.130 --> 00:20:00.810
If it wasn't handled,
we end up trying to send it to

00:20:00.810 --> 00:20:03.000
another target in the event system.

00:20:03.000 --> 00:20:08.000
And we use our, what we term,
our standard containment hierarchy

00:20:08.000 --> 00:20:11.000
of the toolbox to determine this.

00:20:11.000 --> 00:20:15.000
And the hierarchy is largely defined by
windows and controls and sub-controls.

00:20:15.000 --> 00:20:18.000
We rely on control
embedding for a lot of this.

00:20:18.000 --> 00:20:21.930
And events are automatically sent
to the innermost object possible.

00:20:22.040 --> 00:20:23.910
If you click on a button,
the button will get the click first,

00:20:24.050 --> 00:20:26.980
then the window, and then it will fall
through to the application.

00:20:27.030 --> 00:20:31.400
The application is like the catchall
for every event that we send out.

00:20:32.170 --> 00:20:36.000
And this is just a picture of
that containment hierarchy.

00:20:36.150 --> 00:20:37.440
It's pretty standard.

00:20:37.580 --> 00:20:39.550
Shouldn't surprise you.

00:20:41.370 --> 00:20:46.310
When we send an event out,
it may or may not be processed.

00:20:47.520 --> 00:20:51.450
So if the toolbox gets a click,
we may send it out to some specific

00:20:51.450 --> 00:20:53.040
object and it may not be handled.

00:20:53.150 --> 00:20:55.330
Well, we may decide

00:20:55.600 --> 00:20:58.340
Well, we kind of know what it is,
so we're going to send out

00:20:58.340 --> 00:21:02.850
another event which has a little
bit more semantic meaning.

00:21:03.240 --> 00:21:06.700
So, what started as a click could
cascade into something really

00:21:06.700 --> 00:21:09.430
meaningful like "Window Moved."

00:21:09.790 --> 00:21:11.620
And in general,
you want to listen to the higher level

00:21:11.620 --> 00:21:14.100
events rather than the lower level
events because it means you didn't

00:21:14.100 --> 00:21:18.140
have to do all the code necessary
to actually drag the window around.

00:21:19.330 --> 00:21:24.250
So, if we take a visual example of that,
say a click comes into an application,

00:21:24.300 --> 00:21:27.610
and we send it out,
nobody responds to it, we feel bad,

00:21:27.870 --> 00:21:31.490
but we turn around and we take that,
and we actually say, "Oh, you know what?

00:21:31.580 --> 00:21:33.460
That was on the Zoom box.

00:21:33.590 --> 00:21:36.410
Let's tell people it was on the
Zoom box." So we send out another

00:21:36.410 --> 00:21:39.650
event saying the Zoom box was hit,
and nobody responds.

00:21:39.850 --> 00:21:43.710
We still feel bad, but anyways,
we go on and we say,

00:21:44.080 --> 00:21:45.400
Oh, we know what to do when that happens.

00:21:45.470 --> 00:21:46.690
We'll just track the widget.

00:21:46.810 --> 00:21:51.880
Oh, it was a successful trap,
a successful tracking, whatever.

00:21:52.090 --> 00:21:57.820
So, let's just broadcast out that
the window needs to be zoomed.

00:21:58.170 --> 00:22:01.080
and if nobody cares about that,
we'll just zoom the window and say, "Hey,

00:22:01.080 --> 00:22:04.680
the window was zoomed." Now the benefit
of all of this is that you can actually

00:22:04.680 --> 00:22:08.860
tap in at any one of these levels and
intercept any one of these events to get

00:22:08.960 --> 00:22:10.820
the level of functionality that you want.

00:22:10.850 --> 00:22:12.180
You might not care
about any of this stuff.

00:22:12.270 --> 00:22:13.900
Maybe you don't even care
that the window is zoomed.

00:22:13.920 --> 00:22:16.160
You know,
you want to support that feature,

00:22:16.190 --> 00:22:19.680
but you don't want to deal with
the code necessary to drive that.

00:22:19.700 --> 00:22:21.040
We can take care of that.

00:22:21.080 --> 00:22:24.600
Maybe you really have a problem with
the way the toolbox does zooming.

00:22:24.810 --> 00:22:29.080
I can't imagine that, but if you do,
you can just override that part of it.

00:22:29.090 --> 00:22:31.050
It's totally up to you.

00:22:33.500 --> 00:22:36.000
So we have a lot of
events that we've defined.

00:22:36.030 --> 00:22:37.960
We used to be limited by
the size of the Event Mask.

00:22:38.090 --> 00:22:44.210
The Event Mask was limited to 16 events,
because the Event Mask was 16 bits wide.

00:22:45.720 --> 00:22:48.060
Kind of limiting.

00:22:48.060 --> 00:22:53.400
In the Carbon Event Model,
we have lots of events.

00:22:53.640 --> 00:22:53.640
We went nuts.

00:22:53.690 --> 00:22:55.450
Some of these events you already know.

00:22:55.450 --> 00:22:57.910
You know things like mouse down,
you know things like window update,

00:22:57.920 --> 00:22:58.900
window activate.

00:22:58.920 --> 00:23:01.380
But we also introduced a
whole new set of events,

00:23:01.380 --> 00:23:04.590
things like control hit,
process a command please,

00:23:04.590 --> 00:23:08.090
or the window was moved
or it zoomed or whatever.

00:23:08.260 --> 00:23:12.270
I want to talk about a couple of
specific events that have changed,

00:23:12.280 --> 00:23:14.400
or maybe are a little better.

00:23:16.470 --> 00:23:20.070
Maybe I should have shown that later.

00:23:20.140 --> 00:23:21.450
So the first one,
I want to talk about mouse events.

00:23:21.560 --> 00:23:24.020
We now actually have
multi-button mouse support.

00:23:24.070 --> 00:23:27.510
If the system tells us that
the right mouse button was hit,

00:23:27.510 --> 00:23:28.190
we'll tell you.

00:23:28.250 --> 00:23:29.640
I mean, we have no problem.

00:23:29.690 --> 00:23:30.920
We just give you the information.

00:23:30.970 --> 00:23:36.440
And also, if you load up DP4,
hook up your favorite USB mouse,

00:23:36.480 --> 00:23:39.470
and start moving the mouse wheel,
we're going to start sending

00:23:39.470 --> 00:23:40.980
you mouse wheel events.

00:23:41.190 --> 00:23:47.260
And if you actually look at the
simple text example that is on DP4,

00:23:47.380 --> 00:23:48.840
you'll see how to handle it.

00:23:48.950 --> 00:23:51.530
It's kind of a hack, but it works.

00:23:52.920 --> 00:23:55.150
And the last thing is we
have multi-click detection,

00:23:55.240 --> 00:23:58.220
so you don't necessarily need to
determine that a double-click happened.

00:23:58.220 --> 00:23:59.870
We'll just tell you.

00:24:03.800 --> 00:24:05.400
Alright, now to make you sad.

00:24:05.440 --> 00:24:08.800
Keyboard input is actually
different than it was.

00:24:08.880 --> 00:24:09.790
It used to be pretty simple.

00:24:09.790 --> 00:24:13.790
You get an event, it had a key character,
I mean a key code,

00:24:13.790 --> 00:24:16.980
and the actual character that was typed.

00:24:18.460 --> 00:24:24.700
What we want to do in Carbon is
provide full Unicode keyboard input.

00:24:24.790 --> 00:24:27.000
So we changed things a little bit.

00:24:28.300 --> 00:24:30.080
Now I'm going to jump to the last point,
which is that if you're

00:24:30.080 --> 00:24:32.620
calling WaitNextEvent,
you're still going to get keyboard

00:24:32.620 --> 00:24:33.880
events just like you're used to.

00:24:33.980 --> 00:24:35.200
Nothing has changed.

00:24:35.200 --> 00:24:36.690
However,
if you're using the new event model,

00:24:36.690 --> 00:24:38.170
you need to be aware
of a couple of things.

00:24:38.260 --> 00:24:40.200
First,
there are two types of keyboard events.

00:24:40.200 --> 00:24:44.180
There are the Raw Key Events,
which are the ones that just basically

00:24:44.180 --> 00:24:46.200
tell you which virtual key was pressed.

00:24:46.270 --> 00:24:50.160
And then, those can actually build
up into Text Input Events,

00:24:50.190 --> 00:24:52.170
and that happens through TSM.

00:24:52.210 --> 00:24:54.200
TSM is built-in.

00:24:54.370 --> 00:24:57.190
This means that your app doesn't
necessarily have to become TSM-aware.

00:24:57.200 --> 00:25:00.350
It is TSM-aware if it's
a Carbon application,

00:25:00.350 --> 00:25:01.730
automatically.

00:25:02.130 --> 00:25:05.020
So the raw key events, like I said,
they're pretty much

00:25:05.020 --> 00:25:06.430
just a virtual key code.

00:25:06.600 --> 00:25:09.440
But TSM actually does do a
little bit of processing on

00:25:09.510 --> 00:25:11.290
that before it hands it to you.

00:25:11.390 --> 00:25:14.000
But the result of that may
not be what you expect.

00:25:14.260 --> 00:25:16.990
The event may not have any
character information in it.

00:25:16.990 --> 00:25:20.000
It may be part of a dead key sequence.

00:25:20.130 --> 00:25:24.520
Or it may have multiple characters in it,
depending on the keyboard layout.

00:25:24.920 --> 00:25:30.540
and TSM just uses these and
processes them and talks to input

00:25:31.370 --> 00:25:36.290
methods in terms of these events.

00:25:36.360 --> 00:25:39.530
But the most interesting
low-level keyboard event is the

00:25:39.530 --> 00:25:41.120
Keyboard Modifiers Changed event.

00:25:41.210 --> 00:25:43.820
With this, you don't have to poll
for modifiers anymore.

00:25:43.820 --> 00:25:45.720
We'll just tell you that
the modifiers changed.

00:25:45.720 --> 00:25:50.200
It's very simple, which is another reason
that you don't have to poll.

00:25:52.020 --> 00:25:55.150
So the actual Text Input Event,
when it comes to you,

00:25:55.150 --> 00:25:58.900
is one or more Unicode characters.

00:25:58.900 --> 00:26:01.820
And this is the result of
TSM talking to any input method

00:26:01.900 --> 00:26:05.900
that may be present or up.

00:26:05.980 --> 00:26:10.010
And finally,
it'll just give you some Unichars.

00:26:11.440 --> 00:26:15.670
If you actually look in carbonevents.h,
you'll see the text input

00:26:15.670 --> 00:26:17.600
events and what their names are.

00:26:17.710 --> 00:26:20.340
And you'll notice that they
look very similar to what the

00:26:20.340 --> 00:26:22.200
old TSM Apple events were.

00:26:22.280 --> 00:26:25.770
And that's because the
Carbon Event version of those

00:26:25.770 --> 00:26:29.950
events is the replacement
for the old TSM Apple events.

00:26:30.030 --> 00:26:32.720
This doesn't mean that we
won't send those Apple events.

00:26:32.890 --> 00:26:36.550
It only means that we will only
send the Apple events if nobody

00:26:36.550 --> 00:26:38.740
responded to the Carbon event.

00:26:38.880 --> 00:26:44.200
So, in that way, we actually prefer the
Carbon Event model.

00:26:44.270 --> 00:26:46.660
What advantage of...

00:26:47.770 --> 00:26:51.600
Having a text input event like this is
that you can actually unify keyboard

00:26:51.600 --> 00:26:55.240
filters and paste filters into one
thing by just always assuming that

00:26:55.240 --> 00:26:59.790
you might have more than one character
coming in to your edit text fields.

00:27:00.720 --> 00:27:05.510
And text input is a unique
problem in that we need to

00:27:05.510 --> 00:27:07.160
know where the text input goes.

00:27:07.250 --> 00:27:10.170
If we have something like a mouse down,
it's pretty evident where it goes.

00:27:10.170 --> 00:27:12.600
We just look at what
window it happened to hit.

00:27:12.800 --> 00:27:15.440
With keyboard event,
with a keyboard input event,

00:27:15.500 --> 00:27:20.100
we kind of need to have something
tell us where the event should go.

00:27:20.200 --> 00:27:23.280
And in Mac OS 8,
we had a concept of the keyboard

00:27:23.400 --> 00:27:25.500
focus for any given window.

00:27:25.610 --> 00:27:28.400
And that's fine, that's great,
we love it.

00:27:28.510 --> 00:27:31.900
But we need to know which window.

00:27:32.030 --> 00:27:37.740
So we have this concept of user focus,
which is a combination of a window and

00:27:37.740 --> 00:27:40.720
any focused control in that window.

00:27:41.620 --> 00:27:47.140
If the window happens to have... well,
the toolbox defines this, the user focus,

00:27:47.140 --> 00:27:52.070
to be the currently focused control
in the frontmost document window.

00:27:52.280 --> 00:27:54.140
That's our definition of it.

00:27:54.250 --> 00:27:57.190
If that window happens
to have no controls,

00:27:57.190 --> 00:28:00.250
or nothing has focus,
then it's the window.

00:28:03.400 --> 00:28:05.150
In order to send an
event to the user focus,

00:28:05.210 --> 00:28:07.490
we have an API called
Get User Focus Target.

00:28:07.610 --> 00:28:11.350
And that might actually return the
target for a control or a window.

00:28:11.600 --> 00:28:12.440
But it's really not important.

00:28:12.440 --> 00:28:15.580
You just want to give the text
to somebody who might care.

00:28:17.780 --> 00:28:21.900
If, for example,
you need to redirect the user focus,

00:28:22.010 --> 00:28:23.540
you could do that.

00:28:23.660 --> 00:28:26.840
The best example that I can provide
for this is you have flowing

00:28:26.840 --> 00:28:28.770
palettes in your application.

00:28:29.100 --> 00:28:31.920
And you're typing in your document,
and then the user clicks

00:28:32.020 --> 00:28:33.160
in a floating palette.

00:28:33.280 --> 00:28:35.640
And now you want the
keyboard focus to go there.

00:28:35.760 --> 00:28:39.940
You can use Set User Focus Window to say,
"That's the window that has focus now.

00:28:40.150 --> 00:28:43.760
Please send all text input there,
and we'll obey that." And that would

00:28:43.760 --> 00:28:44.890
be the way that you would override it.

00:28:44.950 --> 00:28:47.920
Normally,
the toolbox deals with all of this stuff,

00:28:47.920 --> 00:28:49.350
and you don't need to.

00:28:54.140 --> 00:28:58.570
In Mac OS 8, we introduced the
concept of Menu Commands,

00:28:58.570 --> 00:29:04.310
which was not a new concept,
but it allowed a position-independent

00:29:04.410 --> 00:29:06.570
way of identifying your menu items.

00:29:07.620 --> 00:29:12.310
What we've done in Carbon Events is we've
created these things called HI Commands,

00:29:12.310 --> 00:29:15.300
which are essentially just a
wrapper around those menu commands.

00:29:15.310 --> 00:29:18.790
They basically contain the command,
plus a little bit of extra information

00:29:19.290 --> 00:29:23.160
necessary in order to have the
toolbox dispatch it properly.

00:29:23.190 --> 00:29:24.760
And why is that important?

00:29:24.780 --> 00:29:26.930
Well,
we actually want to dispatch commands

00:29:26.930 --> 00:29:31.590
to the originator of the command first,
and then send it to user focus.

00:29:33.390 --> 00:29:37.240
So let me give you an example of why we'd
want to send it to the originator first.

00:29:37.240 --> 00:29:40.060
Best example there is a plugin.

00:29:40.080 --> 00:29:43.680
A plugin might install a
menu into the menu bar.

00:29:43.910 --> 00:29:47.180
And it would really love to
just get those events itself.

00:29:47.350 --> 00:29:50.380
All it would need to
do is install the menu,

00:29:50.440 --> 00:29:53.740
install the menu handler on that menu,
and then whenever a selection

00:29:53.740 --> 00:29:55.260
was made from that menu,
it would actually

00:29:55.370 --> 00:29:56.430
inform the plugin first.

00:29:56.430 --> 00:29:58.840
And if the plugin said,
"I handled it," that would be it.

00:29:58.880 --> 00:30:00.670
End of processing.

00:30:01.750 --> 00:30:04.710
Why you would want it to go to the user
focus is because usually commands and

00:30:04.710 --> 00:30:10.100
menus apply to the currently selected
control or field or something like that.

00:30:10.260 --> 00:30:11.990
The best example is an Edit Text field.

00:30:12.120 --> 00:30:16.250
You know, cut, copy, and paste obviously
apply to the user focus.

00:30:16.490 --> 00:30:19.580
and we've predefined a whole bunch of
commands if you look in Carbon events

00:30:19.580 --> 00:30:23.880
dot h uh... we have things for like quit,
copy, paste,

00:30:23.880 --> 00:30:26.890
uh... a number of things and the
interesting thing is that a control can

00:30:26.980 --> 00:30:31.200
actually generate a command as well and
we'll actually see an example of that

00:30:31.260 --> 00:30:36.640
very shortly so short in fact that it's
now so what i'd like to do is actually

00:30:36.640 --> 00:30:41.700
bring up Guy Fullerton who works
on HLTV with me to show you a little

00:30:41.900 --> 00:30:42.510
demo and he's actually over there

00:30:47.650 --> 00:30:50.130
Okay, so if I can switch over
to the demo machine,

00:30:50.170 --> 00:30:54.600
that would be helpful.

00:30:54.690 --> 00:30:56.790
So as Ed mentioned earlier
in the presentation,

00:30:56.850 --> 00:30:59.040
the toolbox is attempting
to become a framework.

00:30:59.130 --> 00:31:01.230
It's attempting to do a lot of
the work that your applications

00:31:01.230 --> 00:31:02.900
used to have to do on its own.

00:31:02.970 --> 00:31:06.000
And we want to make your lives easier
and allow you guys to write a lot less

00:31:06.140 --> 00:31:10.100
code and just deal with the code that
gives your app the unique functionality.

00:31:10.230 --> 00:31:13.280
And I want to show you a
couple of admittedly fairly

00:31:13.280 --> 00:31:15.110
simple examples of that.

00:31:15.400 --> 00:31:19.300
The first one is a simple
Hello World application.

00:31:19.350 --> 00:31:21.670
It's got one source file.

00:31:23.350 --> 00:31:25.960
Fairly short, about a page,
page and a half of code.

00:31:25.960 --> 00:31:27.600
Our main does some fairly simple stuff.

00:31:27.710 --> 00:31:29.140
We install a standard menu bar.

00:31:29.290 --> 00:31:30.860
We create a window.

00:31:30.860 --> 00:31:32.290
We install an event
handler on that window.

00:31:32.300 --> 00:31:33.300
We show the window.

00:31:33.300 --> 00:31:37.150
And we call the run application event
loop API that Ed mentioned earlier.

00:31:37.360 --> 00:31:38.140
And then we quit.

00:31:38.340 --> 00:31:41.300
When our event loop exits,
we're going to end up being done.

00:31:41.300 --> 00:31:43.710
Our window handler looks for two events.

00:31:43.710 --> 00:31:47.710
We look for a draw content event,
and we look for a window close event.

00:31:47.720 --> 00:31:50.290
We do a little bit of special processing.

00:31:50.360 --> 00:31:55.300
I have a routine which
does my window drawing.

00:31:55.300 --> 00:31:58.360
And then I have a utility function
I called for my main routine

00:31:58.360 --> 00:32:00.230
called install standard menu bar.

00:32:00.520 --> 00:32:02.170
There's no event processing
in this code at all.

00:32:02.170 --> 00:32:03.550
I'm never calling wait next event.

00:32:03.550 --> 00:32:04.650
I'm never fetching events.

00:32:04.650 --> 00:32:06.260
I'm never looking for
clicks in the menu bar,

00:32:06.390 --> 00:32:08.300
clicks in windows, or anything like that.

00:32:08.300 --> 00:32:11.300
And when I run the app,

00:32:13.850 --> 00:32:15.480
You get the simple app.

00:32:15.480 --> 00:32:17.090
And it does a lot of the
stuff that your application

00:32:17.090 --> 00:32:18.200
normally has to do on its own.

00:32:18.200 --> 00:32:21.400
It tracks menus,
you can move the window around,

00:32:21.450 --> 00:32:24.590
you can grow it, you can window shade it,
and do all the stuff that

00:32:24.690 --> 00:32:26.800
you would expect a normal
Mac OS X application to do,

00:32:26.800 --> 00:32:30.110
and you did it in about a page,
page and a half of code.

00:32:32.230 --> 00:32:35.440
So I want to show you a
slightly more complex example.

00:32:35.440 --> 00:32:37.700
When we're doing work on the toolbox,
we're doing a lot of

00:32:37.770 --> 00:32:39.000
work on user interface.

00:32:39.000 --> 00:32:41.740
And the last several months
have been spent on Aqua.

00:32:41.890 --> 00:32:44.850
And we have to do a lot of checking to
make sure our interface is just right.

00:32:44.960 --> 00:32:47.880
We need to zoom in the pixels
and make sure the right shadowing

00:32:47.880 --> 00:32:49.260
is going on and all this stuff.

00:32:49.310 --> 00:32:53.460
But for Mac OS X,
we didn't have a tool to help us do that.

00:32:53.460 --> 00:32:56.940
So last year, we actually wrote a tool
called Magnify to do that.

00:32:56.940 --> 00:32:59.320
And we thought, well,
we're writing an app for the ground up.

00:32:59.320 --> 00:33:01.720
We might as well test out
our Carbon event model

00:33:01.720 --> 00:33:03.020
and see how that's going.

00:33:03.020 --> 00:33:05.790
So we decided to implement
it with Carbon events.

00:33:06.100 --> 00:33:08.960
And it ended up being really,
really easy to do.

00:33:09.050 --> 00:33:11.540
So once again,
I just have one source file.

00:33:11.670 --> 00:33:13.000
It's a little bit
longer than Hello World,

00:33:13.000 --> 00:33:17.400
probably four pages of code, maybe.

00:33:17.510 --> 00:33:21.000
One of the main pieces of code
is a timer that I'd mentioned.

00:33:21.100 --> 00:33:23.190
We've got a timer that
executes every so often.

00:33:23.190 --> 00:33:27.750
This is the real meat of the application
right here in this one function.

00:33:29.140 --> 00:33:32.230
We have a routine which
creates our window,

00:33:32.230 --> 00:33:33.640
right here.

00:33:33.660 --> 00:33:37.820
We have an event handler for that window,
which only looks for one event,

00:33:37.830 --> 00:33:39.780
I believe.

00:33:41.710 --> 00:33:43.900
And we have a command handler that
we're going to end up installing

00:33:43.900 --> 00:33:47.620
on the application to handle
a few special menu commands.

00:33:47.730 --> 00:33:48.930
And finally we've got our main.

00:33:49.040 --> 00:33:53.140
You know,
probably only 10-12 lines of real code.

00:33:53.220 --> 00:33:58.110
We install a menu bar,
we install our application handler.

00:33:58.170 --> 00:34:02.180
We jump through some hoops so
our timer can do some work later,

00:34:02.270 --> 00:34:04.490
and then we create our window.

00:34:05.250 --> 00:34:07.920
So it's not a super simple app,
but as you can see,

00:34:07.920 --> 00:34:10.960
it really only did the work that
matters to that application.

00:34:11.000 --> 00:34:13.540
And when I run it,
we get our Magnify app,

00:34:13.670 --> 00:34:16.300
which simply magnifies the
pixels underneath wherever

00:34:16.300 --> 00:34:18.200
the mouse happens to be.

00:34:18.240 --> 00:34:20.420
And Ed mentioned timers
and how they fire,

00:34:20.470 --> 00:34:22.920
sometimes when you may
not necessarily expect,

00:34:22.920 --> 00:34:24.980
but when it's still very powerful.

00:34:25.190 --> 00:34:28.740
So if I happen to, oh I don't know,
drag the window around, you can see that,

00:34:28.740 --> 00:34:30.860
well, the timer's still firing,
it's still updating the window,

00:34:30.860 --> 00:34:32.960
it's not exactly an interesting update.

00:34:32.990 --> 00:34:36.730
But if I pull down the menus,
the timer's still firing,

00:34:36.800 --> 00:34:38.320
it's still drawing into the window.

00:34:38.360 --> 00:34:41.860
And the few menu commands I wired
up get sent to the application and

00:34:41.860 --> 00:34:43.960
I change the magnification level.

00:34:46.940 --> 00:34:52.140
And the last example I'd like to show
you actually ties into Interface Builder.

00:34:52.160 --> 00:34:55.920
Interface Builder is one of the new
tools we're showing on Mac OS X,

00:34:55.920 --> 00:34:58.700
and we've done a lot
of Carbon integration

00:34:58.700 --> 00:35:00.480
into Interface Builder.

00:35:00.610 --> 00:35:08.720
It's got a way by which you can
create a Carbon application.

00:35:08.720 --> 00:35:08.720
Let's see.

00:35:09.200 --> 00:35:11.800
I can select Carbon Application Nib Base.

00:35:11.800 --> 00:35:13.990
This takes you through a little
assistant to do those kinds of things,

00:35:13.990 --> 00:35:17.710
but I've already got a project set up.

00:35:18.630 --> 00:35:20.380
So I'll go ahead and open that up.

00:35:20.380 --> 00:35:23.600
And this is what it would look
like when you first create it.

00:35:23.600 --> 00:35:25.840
It's got two interesting pieces in it.

00:35:25.840 --> 00:35:30.680
It's got some source, simple main.c,
probably only about

00:35:30.680 --> 00:35:32.070
20 lines of real code.

00:35:32.160 --> 00:35:35.610
It simply loads the interface from a nib
and creates a window which is also from a

00:35:35.610 --> 00:35:38.380
nib and calls run application event loop.

00:35:38.380 --> 00:35:41.830
And the nib is what defines
a little bit of interface.

00:35:41.920 --> 00:35:42.600
It's fairly simple.

00:35:42.600 --> 00:35:43.840
Once again, it's just a window.

00:35:43.940 --> 00:35:46.870
And Interface Builder does
this for you automatically.

00:35:46.880 --> 00:35:50.800
It creates sort of a simple one
window application interface.

00:35:50.920 --> 00:35:52.960
And if I run that--

00:35:53.950 --> 00:35:55.530
You get what you expect:
a simple one-window

00:35:55.530 --> 00:35:56.560
application interface.

00:35:56.590 --> 00:35:59.000
Once again,
we do all the standard behavior for you.

00:35:59.000 --> 00:36:01.900
We track the menus, we move the window,
we resize the window,

00:36:01.900 --> 00:36:06.120
we can window shade the window,
and do all those things you would expect.

00:36:06.420 --> 00:36:09.600
But I want to go a little,
one step further.

00:36:09.680 --> 00:36:11.820
Let's actually add some
functionality to the app,

00:36:11.820 --> 00:36:18.520
and at the same time... Let's cancel
that and get that out of the way.

00:36:21.030 --> 00:36:22.900
Oh, that's not what I want.

00:36:22.900 --> 00:36:24.890
That works.

00:36:24.890 --> 00:36:27.340
Okay, we're back in the nib.

00:36:27.470 --> 00:36:30.500
He'd mentioned that you can
attach commands to controls.

00:36:30.500 --> 00:36:31.900
So let's go ahead and do that.

00:36:31.940 --> 00:36:34.810
I'll drag a button out of the interface
builder palette and put it in the window.

00:36:34.880 --> 00:36:37.490
And if I bring up the
inspector for that button,

00:36:37.720 --> 00:36:41.570
it's got a field by which you can
associate a command ID to that control.

00:36:41.900 --> 00:36:45.060
Now there's a whole bunch of standard
system commands that we offer,

00:36:45.060 --> 00:36:47.990
and our application event loop
pays attention to these commands

00:36:47.990 --> 00:36:49.460
and does what you would expect.

00:36:49.610 --> 00:36:52.420
So I can go ahead and just
tell that control that,

00:36:52.480 --> 00:36:56.610
"Hey, you issue the quit command."
And I'll save my nib.

00:36:57.530 --> 00:36:59.400
Go back, rebuild.

00:36:59.400 --> 00:37:00.890
Should take a second.

00:37:00.960 --> 00:37:01.550
Done.

00:37:01.660 --> 00:37:03.350
Rerun.

00:37:04.500 --> 00:37:43.600
[Transcript missing]

00:37:50.810 --> 00:37:55.460
So, you've just seen an example where
you can basically bring up an

00:37:55.460 --> 00:38:00.460
interface from some data store,
in this case an interface builder nib,

00:38:00.460 --> 00:38:06.900
and have the toolbox deal with all
the user interaction in that window,

00:38:06.900 --> 00:38:09.740
and then potentially just tell
you about the interesting things.

00:38:09.800 --> 00:38:13.920
Well, it seems like we kind of
already had something like that,

00:38:13.940 --> 00:38:16.790
and we used to call
it the Dialog Manager.

00:38:16.790 --> 00:38:19.760
Everybody's friend, the Dialog Manager.

00:38:19.880 --> 00:38:24.090
Well, with all the stuff that we've
been working on in Carbon Events,

00:38:24.090 --> 00:38:27.150
the Dialog Manager is
effectively obsolete.

00:38:27.820 --> 00:38:29.750
This doesn't mean it's not supported,
this doesn't mean they were

00:38:29.750 --> 00:38:34.080
taking it away from you,
but it does mean that you can do pretty

00:38:34.180 --> 00:38:39.530
much anything that you could have done in
a dialogue with pure Carbon events now.

00:38:39.960 --> 00:38:42.780
We have things like
interface builder support.

00:38:42.780 --> 00:38:46.000
We have the ability to actually
reference a control by an

00:38:46.000 --> 00:38:48.660
arbitrary ID that you assign.

00:38:49.310 --> 00:38:54.020
And we also will be supporting
window modality without actually

00:38:54.020 --> 00:38:55.900
resorting to using modal dialog.

00:38:56.000 --> 00:39:00.160
The best example of where we're
headed with that is if you check

00:39:00.240 --> 00:39:05.580
out the Adopting Aqua session,
which is tomorrow,

00:39:06.520 --> 00:39:12.610
You'll actually see how some of our
Sheet APIs rely on this modality,

00:39:12.610 --> 00:39:17.060
and Sheets are completely
Carbon Event based.

00:39:17.150 --> 00:39:21.110
I mentioned at the beginning that
we're trying to unify different models.

00:39:23.360 --> 00:39:26.530
One of those models is the DefProc model.

00:39:26.530 --> 00:39:32.580
Instead of a callback-based DefProc,
what we really wanted was

00:39:32.580 --> 00:39:35.840
an event-based DefProc,
and we have that.

00:39:35.840 --> 00:39:42.300
In DP4, windows and controls are
completely driven through events.

00:39:42.540 --> 00:39:46.300
The old DefProcs don't exist anymore.

00:39:49.570 --> 00:39:51.770
This doesn't mean you
can't create a button,

00:39:51.770 --> 00:39:52.380
of course.

00:39:52.400 --> 00:39:55.260
But Carbon Events is the native model.

00:39:55.310 --> 00:39:57.200
And we're just going to keep
doing more and more of this as

00:39:57.240 --> 00:39:59.000
we go forward with the toolbox.

00:39:59.020 --> 00:40:01.300
And the beauty here is that
you can override these events

00:40:01.350 --> 00:40:02.730
like you would anything else.

00:40:02.830 --> 00:40:05.380
If you don't like the
way the control draws,

00:40:05.590 --> 00:40:08.140
intercept the draw and
do something cooler.

00:40:08.290 --> 00:40:09.420
I don't know.

00:40:09.420 --> 00:40:11.180
Actually,
if you stick around for the second

00:40:11.180 --> 00:40:14.990
session-- that's my plug to keep you
here-- we'll actually show you an

00:40:15.010 --> 00:40:17.900
example of some of the cool things
that you can do with this stuff.

00:40:17.900 --> 00:40:20.800
And while we redid this
stuff in Carbon Events,

00:40:20.800 --> 00:40:23.420
we took the opportunity to
actually clean up the messages,

00:40:23.430 --> 00:40:26.920
get rid of some old messages
that didn't make any sense.

00:40:26.920 --> 00:40:28.780
And of course,
the beauty of all of this is

00:40:28.790 --> 00:40:32.060
that def procs were really weird.

00:40:32.060 --> 00:40:34.300
It's the best word I could think of.

00:40:34.300 --> 00:40:40.150
I mean, for each different message,
you needed to learn the arcane

00:40:40.210 --> 00:40:43.190
rules of what would come
through the param parameter and

00:40:43.190 --> 00:40:44.900
what you should be returning.

00:40:44.900 --> 00:40:47.950
And in controls,
there was this thing like test new

00:40:47.950 --> 00:40:50.420
message support and all this weird stuff.

00:40:50.470 --> 00:40:54.200
Carbon Events just make that go away.

00:40:56.080 --> 00:41:00.120
I also mentioned at the beginning
that we wanted an API that

00:41:00.120 --> 00:41:05.150
would encourage performance,
specifically on Mac OS X.

00:41:05.790 --> 00:41:07.060
We do that in a number of ways.

00:41:07.060 --> 00:41:09.290
The first is timers.

00:41:09.330 --> 00:41:12.210
It is highly recommended that
you use timers instead of small

00:41:12.210 --> 00:41:14.200
timeouts and wait next event.

00:41:14.250 --> 00:41:17.960
This is largely because timers are
much more efficient to fire when

00:41:17.960 --> 00:41:19.980
you're already in the event loop.

00:41:20.200 --> 00:41:22.910
Restarting the event loop has a cost.

00:41:23.440 --> 00:41:26.840
Another way to help your app
perform well on Mac OS X is

00:41:26.910 --> 00:41:28.940
to adopt Track Mouse Location.

00:41:29.080 --> 00:41:31.600
The second session shows
an example of that.

00:41:31.680 --> 00:41:35.670
And again, I mentioned at the beginning
that this is a way to rewrite

00:41:35.670 --> 00:41:37.740
your mouse tracking loops.

00:41:37.860 --> 00:41:42.690
The traditional mouse tracking loop
will actually pin the CPU on Mac OS X.

00:41:43.890 --> 00:41:46.930
You can listen to events like
the Modifiers Changed event,

00:41:46.930 --> 00:41:49.000
which is an example of an event
that we're sending out now

00:41:49.120 --> 00:41:52.690
that you didn't have before,
so you had to resort to polling.

00:41:52.960 --> 00:41:55.000
And in fact,
if there is anything that you

00:41:55.000 --> 00:41:57.700
know of that you are polling
for in your application,

00:41:57.700 --> 00:42:00.640
we absolutely want to know so
that we can try our best to

00:42:00.930 --> 00:42:02.900
get an event in there instead.

00:42:02.900 --> 00:42:08.890
I mean, making it work that way
is for all our benefits.

00:42:09.540 --> 00:42:13.690
And another thing that we want to do is
move to something called Tracking Areas.

00:42:13.740 --> 00:42:15.400
This isn't in there right now.

00:42:15.400 --> 00:42:17.400
I'm not sure exactly when it will be.

00:42:17.400 --> 00:42:22.400
But, right now we send your application
tons of mouse-move events.

00:42:22.400 --> 00:42:24.240
Every time the mouse moves one pixel,
you have an event.

00:42:24.400 --> 00:42:28.190
Which is good in some cases,
but in a lot of cases, you don't care.

00:42:28.330 --> 00:42:31.000
All you want to know is,
did the mouse enter or exit this

00:42:31.000 --> 00:42:32.400
particular region of my window?

00:42:32.400 --> 00:42:35.400
Because I need to update
the cursor or something.

00:42:35.740 --> 00:42:39.400
Well,
Tracking Areas are a way to do that.

00:42:39.400 --> 00:42:40.400
And hopefully they'll come online soon.

00:42:41.680 --> 00:42:45.710
So, with that,
I mean there's a lot of stuff here.

00:42:45.890 --> 00:42:47.480
So much stuff that
I have a second session.

00:42:47.550 --> 00:42:48.600
Did I mention my second session?

00:42:48.600 --> 00:42:55.860
So, what you should be seeing from this
is that the toolbox is largely doing

00:42:56.440 --> 00:42:59.820
all the work for you these days,
and we want to continue on that path.

00:42:59.960 --> 00:43:04.040
We want to make it such that when
you write an application for Carbon,

00:43:04.080 --> 00:43:06.200
the only lines of code that
you write are the kinds that

00:43:06.200 --> 00:43:08.920
are unique to your application.

00:43:09.460 --> 00:43:11.350
That is what it's all about.

00:43:11.720 --> 00:43:17.070
It's also important to know that learning
Carbon Events is important in that

00:43:17.430 --> 00:43:21.800
everything we do from this point forward
will be in terms of Carbon Events.

00:43:21.960 --> 00:43:23.500
Carbon Events is our messaging model.

00:43:23.750 --> 00:43:25.280
Carbon Events is our event model.

00:43:25.430 --> 00:43:28.100
Carbon Events is our notification model.

00:43:28.240 --> 00:43:31.430
And once you learn that one paradigm,
you've learned them all.

00:43:32.060 --> 00:43:35.570
and I mentioned you get new
toolbox features essentially

00:43:35.620 --> 00:43:38.200
for free and the way that

00:43:38.580 --> 00:43:43.840
The way that you get that is just because
we can start sending out new events.

00:43:43.950 --> 00:43:47.640
And if you're really Carbon Event savvy,
you're probably not looking for them

00:43:47.640 --> 00:43:49.440
because they're like new and stuff.

00:43:49.550 --> 00:43:53.770
So we can actually send these new events,
implement new functionality,

00:43:53.800 --> 00:43:56.090
and then when your app is ready,
you can actually start tapping

00:43:56.090 --> 00:43:57.200
into that functionality.

00:43:57.290 --> 00:44:00.330
So we won't get into a lot of the
problems that we've had in the past

00:44:00.500 --> 00:44:05.440
trying to implement functionality a la
Windows Shade behind your app's back.

00:44:06.220 --> 00:44:08.420
And the best part,
the absolute best part,

00:44:08.550 --> 00:44:10.540
is that this is a gradual adoption path.

00:44:10.600 --> 00:44:14.580
There is no need for you to
even rewrite one line of code

00:44:14.580 --> 00:44:16.910
just to make your app port.

00:44:17.180 --> 00:44:18.640
However,
if you want to make it perform well,

00:44:18.780 --> 00:44:21.280
you might have to do a couple of things.

00:44:21.310 --> 00:44:24.930
Beyond that, you can start installing
handlers on a case-by-case basis

00:44:25.030 --> 00:44:26.280
throughout your application.

00:44:26.320 --> 00:44:27.760
We're not telling you
to rewrite your app.

00:44:27.790 --> 00:44:29.550
We don't want you to have to
completely rewrite your app.

00:44:29.650 --> 00:44:36.490
That's the whole point of Carbon.

00:44:40.770 --> 00:44:42.060
I don't know.

00:44:42.130 --> 00:44:44.910
This stuff is just cooler than cool.

00:44:45.000 --> 00:44:50.100
And if you're not seeing that,
I don't know what to do.

00:44:51.420 --> 00:44:53.740
Can you tell I'm excited about it?

00:44:53.740 --> 00:44:57.030
In any case,
what I'd like to do is have you check

00:44:57.050 --> 00:44:59.880
out carbonevents.h start looking at it.

00:44:59.980 --> 00:45:02.260
The API is really refined now.

00:45:02.300 --> 00:45:04.950
This is one of the few projects
where I've been able to actually

00:45:04.970 --> 00:45:09.200
get time to really refine the
API over and over and over again.

00:45:09.200 --> 00:45:10.930
If you've actually been
following Carbon Events,

00:45:11.040 --> 00:45:13.120
you know that it's changed over time.

00:45:13.120 --> 00:45:20.570
Now I think we have a really,
really highly refined API that

00:45:20.610 --> 00:45:23.080
actually feels really good as well.

00:45:23.080 --> 00:45:24.260
So please take a look.

00:45:24.260 --> 00:45:27.340
Check out all the events we have.

00:45:27.340 --> 00:45:29.360
And let us know what other
events you might need.

00:45:29.360 --> 00:45:31.520
I mean,
sometimes a lot of these are easy.

00:45:31.520 --> 00:45:36.480
We've had requests, for example,
people want to know we want to know

00:45:36.480 --> 00:45:38.920
when the window is hidden or shown.

00:45:38.920 --> 00:45:39.880
Well, that's easy for us.

00:45:39.880 --> 00:45:42.700
We can just add an event and send it out,
and then you get that notification.

00:45:42.700 --> 00:45:43.270
No need to patch.

00:45:44.880 --> 00:45:47.100
Another simple thing
you can do is right now,

00:45:47.100 --> 00:45:51.960
on your PowerBook,
just pass MaxLong into your

00:45:51.960 --> 00:45:55.800
sleep time on WaitNext Event and
start installing timers.

00:45:55.800 --> 00:45:56.800
They're really easy to adopt.

00:45:56.800 --> 00:45:59.930
And of course, you want lots of feedback,
and you can direct your

00:46:00.040 --> 00:46:04.800
feedback to toolbox@apple.com,
or you can talk to your pal, Dave Wright.

00:46:04.800 --> 00:46:07.820
And I'd like to bring Dave Wright back
up here so he can lead us

00:46:07.820 --> 00:46:09.600
through the roadmap and onto Q&A.

00:46:09.800 --> 00:46:11.800
Thanks.

00:46:19.020 --> 00:46:19.500
Thanks, Ed.

00:46:19.730 --> 00:46:21.350
So, can we get all into Ed's head?

00:46:21.430 --> 00:46:23.070
This stuff is cool, no?

00:46:23.290 --> 00:46:24.830
Let's, I mean, just give it up.

00:46:24.920 --> 00:46:28.750
It's just amazing stuff.

00:46:28.750 --> 00:46:28.750
So, alright.

00:46:29.600 --> 00:46:32.970
So I just want to do a brief
overview of the roadmap that kind of

00:46:32.980 --> 00:46:34.600
follows on to this kind of content.

00:46:34.670 --> 00:46:37.760
Right after this session,
there's the advanced

00:46:37.760 --> 00:46:39.440
session of Carbon Events.

00:46:39.510 --> 00:46:43.090
So go ahead and get a
drink and come on back.

00:46:43.180 --> 00:46:46.840
Tomorrow, the high-level toolbox team is
going to be giving a session

00:46:46.840 --> 00:46:48.880
on adopting the Aqua interface.

00:46:49.000 --> 00:46:53.380
So those are high-level toolbox changes
to APIs that are specifically about Aqua.

00:46:53.550 --> 00:46:57.230
And then there'll be two other sessions,
one on Thursday and one on Friday,

00:46:57.310 --> 00:47:01.540
about generic high-level toolbox changes
that affect all Carbon applications.

00:47:01.540 --> 00:47:07.070
So be sure to go to those sessions to get
your apps carbonized as best possible.

00:47:07.150 --> 00:47:07.580
At this time...
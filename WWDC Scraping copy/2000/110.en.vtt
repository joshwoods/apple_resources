WEBVTT

00:00:04.760 --> 00:00:09.930
Ladies and gentlemen,
please welcome tech lead for Quartz,

00:00:09.930 --> 00:00:11.120
Derek Clegg.

00:00:14.100 --> 00:00:15.620
Welcome.

00:00:16.020 --> 00:00:21.400
Welcome to the last afternoon session,
or the first afternoon session

00:00:21.400 --> 00:00:23.050
of the last day of WWDC.

00:00:24.510 --> 00:00:27.140
My name is Derek Clegg,
and I'm going to be

00:00:27.190 --> 00:00:29.390
talking today about Quartz.

00:00:29.640 --> 00:00:31.180
There's my name.

00:00:31.790 --> 00:00:33.700
So what are we going to talk about today?

00:00:33.750 --> 00:00:37.610
Well, I'm going to focus on the
rendering APIs in Quartz.

00:00:37.700 --> 00:00:42.140
If some of you may have gone to
Peter Grappanino's session on Wednesday,

00:00:42.210 --> 00:00:44.940
you might remember that
there's two layers of Quartz.

00:00:44.940 --> 00:00:46.890
There's the bottom layer,
sort of the Windows server,

00:00:46.890 --> 00:00:47.700
and the top layer.

00:00:47.700 --> 00:00:49.700
We're going to focus
really on the top layer.

00:00:49.700 --> 00:00:52.900
That's the part you can use in DP4.

00:00:52.900 --> 00:00:59.100
We're going to talk about how you'd
use Quartz in your application today,

00:00:59.100 --> 00:00:59.660
and also have a little demo.

00:01:00.250 --> 00:01:04.590
So what I hope you'll learn by the
end of the day is what Quartz is,

00:01:04.960 --> 00:01:08.520
when you should use it in your app,
maybe when you shouldn't as well,

00:01:08.660 --> 00:01:15.300
what APIs there are that
we have available for you,

00:01:15.300 --> 00:01:15.300
and how would you actually go about
using the APIs in your application.

00:01:15.460 --> 00:01:18.240
So you've undoubtedly
seen this diagram many,

00:01:18.240 --> 00:01:22.100
many times,
where the little part in the green box.

00:01:22.100 --> 00:01:25.060
And to spread that out a little bit,

00:01:25.270 --> 00:01:28.900
Here's a little bit
detailed view of Quartz.

00:01:28.940 --> 00:01:33.010
So as I mentioned, there's really sort of
the underlying-- Quartz,

00:01:33.010 --> 00:01:36.190
actually, just to clarify,
Quartz is really sort of the

00:01:36.290 --> 00:01:38.090
orange piece in this diagram.

00:01:38.240 --> 00:01:41.530
Underneath a lot of other parts of
the technology is the Windows Server,

00:01:41.530 --> 00:01:43.090
the Core Graphics Services.

00:01:43.090 --> 00:01:45.100
That's the part that manages
your screen real estate,

00:01:45.100 --> 00:01:51.000
brings Windows up and back
from the display and so on.

00:01:51.100 --> 00:01:54.590
What I'm going to focus on is
the Core Graphics rendering,

00:01:54.690 --> 00:01:57.800
the little part up in the
upper left-hand corner.

00:01:57.940 --> 00:02:00.420
As you can see,
the other technologies that we have

00:02:00.680 --> 00:02:04.700
live on top of Core Graphic Services,
and those are, of course, available,

00:02:04.700 --> 00:02:06.210
and you're probably
familiar with most of those.

00:02:06.360 --> 00:02:09.420
So what I'm focusing
on is the newer piece,

00:02:09.420 --> 00:02:11.790
the rendering layer itself.

00:02:11.900 --> 00:02:15.490
So what's Quartz really?

00:02:17.410 --> 00:02:19.120
Well, it's a 2D drawing engine.

00:02:19.140 --> 00:02:20.090
We're 2D only.

00:02:20.100 --> 00:02:23.800
We really leave 3D to
other parts of the system.

00:02:23.980 --> 00:02:29.300
We're focusing primarily on just
providing a really great 2D model.

00:02:29.300 --> 00:02:36.940
We use technology,
or we base our APIs on Adobe's PDF model.

00:02:37.320 --> 00:02:38.300
The PDF spec is great.

00:02:38.300 --> 00:02:43.150
It provides a really great
way of giving high fidelity

00:02:43.220 --> 00:02:46.110
images and pages for printing.

00:02:46.300 --> 00:02:48.250
We've adopted that pretty much wholesale.

00:02:48.300 --> 00:02:53.390
It's also a very clean,
very nice API that we leverage.

00:02:53.920 --> 00:02:56.290
What Quartz does on the back end, I mean,
you know,

00:02:56.290 --> 00:02:58.070
you sort of tell us to do something.

00:02:58.190 --> 00:03:00.790
On the back end,
what we're putting out is, of course,

00:03:00.790 --> 00:03:01.680
screen display.

00:03:02.000 --> 00:03:03.790
Anything that might
go on the screen goes,

00:03:03.790 --> 00:03:06.800
in the long run, through the back end of
the Core Graphics layer,

00:03:06.800 --> 00:03:08.800
of the Core Graphics Services layer.

00:03:08.800 --> 00:03:10.920
We also generate bitmap images.

00:03:10.940 --> 00:03:13.920
We generate PDF streams
and PostScript streams,

00:03:13.970 --> 00:03:14.800
as well.

00:03:14.960 --> 00:03:18.970
And Quartz, the whole package,
is really the low-level services

00:03:18.970 --> 00:03:20.800
to get bits on the screen.

00:03:20.800 --> 00:03:23.660
Of course,
the rendering layer is just one way that

00:03:23.660 --> 00:03:26.800
you get into the whole set of things,
but in the long run,

00:03:26.800 --> 00:03:30.800
Quartz as a package is the way
to get stuff onto the screen.

00:03:34.960 --> 00:03:40.200
So what sort of API, I mean,
what is this API that we have for Quartz?

00:03:40.280 --> 00:03:43.740
Well, as I said, it's the way to get into
the rendering layer,

00:03:43.880 --> 00:03:48.720
and it's a really nice set of 2D
drawing primitives based on PDF.

00:03:49.850 --> 00:03:52.120
Now one thing that I want
to mention is what we don't

00:03:52.120 --> 00:03:55.300
really provide now in the API.

00:03:55.300 --> 00:03:58.020
We're not really giving
access to window management.

00:03:58.040 --> 00:04:01.440
There's a lot of semantics about
the way windows are managed.

00:04:01.440 --> 00:04:03.980
There's things like, you know,
which little candy does

00:04:03.980 --> 00:04:05.280
what when you click on it.

00:04:05.280 --> 00:04:06.560
We're not really at that level.

00:04:06.560 --> 00:04:08.500
That's really the higher level toolkits.

00:04:08.520 --> 00:04:10.830
So if you want to do any
sort of window management,

00:04:10.830 --> 00:04:13.160
you should really go
through Cocoa or Carbon.

00:04:13.170 --> 00:04:14.800
That's the right place.

00:04:14.800 --> 00:04:18.880
The other thing that we're not providing
is machine-to-machine displays.

00:04:18.880 --> 00:04:21.700
So you can't sort of say on this machine,
"Oh, I want you to draw something over

00:04:21.700 --> 00:04:25.150
here on that machine." We don't
do any sort of that type of thing.

00:04:25.180 --> 00:04:27.160
Timbuk2 is an example of
an app that does that.

00:04:29.520 --> 00:04:32.850
So the question would come up, of course,
well, there's this nice API.

00:04:32.860 --> 00:04:35.470
When should you use it?

00:04:35.470 --> 00:04:35.470
Well,

00:04:35.680 --> 00:04:37.880
It's a tricky question to answer.

00:04:37.880 --> 00:04:41.870
The truth is, Cocoa or Carbon are often
the right thing to use.

00:04:42.280 --> 00:04:45.240
For one thing, Quartz is Mac OS X only.

00:04:45.420 --> 00:04:49.750
If your application needs
to run on OS 9 and OS X,

00:04:49.850 --> 00:04:51.950
you probably should not use Quartz.

00:04:52.060 --> 00:04:55.510
In that case,
you should really stick with Carbon.

00:04:55.600 --> 00:04:59.620
For Cocoa, Cocoa has this nice
object-oriented layer.

00:04:59.620 --> 00:05:01.820
It's all more modern and so on.

00:05:01.820 --> 00:05:04.100
We're very function-based.

00:05:04.100 --> 00:05:07.600
If you want that type of abstraction,
you might want to go with Cocoa.

00:05:07.600 --> 00:05:11.550
Both those frameworks provide a
lot more of additional things,

00:05:11.550 --> 00:05:15.400
like NSString and stuff like that,
than we're providing.

00:05:15.780 --> 00:05:21.410
But there are cases when you
would want to use Quartz.

00:05:21.510 --> 00:05:23.900
A good example would
probably be a situation,

00:05:23.900 --> 00:05:27.980
maybe you have an application where
you've abstracted out the drawing

00:05:27.980 --> 00:05:32.530
piece of the application from the
UI and the behavior and so on.

00:05:32.790 --> 00:05:35.890
And maybe that application
lives on multiple platforms,

00:05:35.900 --> 00:05:39.690
so on Windows you go directly to
GDI with that little drawing piece,

00:05:39.820 --> 00:05:43.700
and maybe on Mac OS 9 you've
gone directly to Quick Draw.

00:05:43.700 --> 00:05:46.000
So a situation like that,
maybe for Mac OS X you want to

00:05:46.010 --> 00:05:47.700
call Quartz directly in that part.

00:05:47.700 --> 00:05:49.690
That's one example.

00:05:49.750 --> 00:05:52.680
There are other cases
where you'd want to,

00:05:52.680 --> 00:05:58.000
so it's really something that you'll
have to sort of weigh for yourself.

00:05:59.460 --> 00:06:01.800
Suppose you decided to
use Quartz directly.

00:06:01.840 --> 00:06:04.500
This is sort of a general
overview of how that works.

00:06:04.500 --> 00:06:07.000
Of course,
you'll be calling Carbon or Cocoa,

00:06:07.110 --> 00:06:08.330
and they call into us.

00:06:08.400 --> 00:06:11.300
Cocoa calls into the
rendering layer itself.

00:06:11.540 --> 00:06:15.400
Carbon, of course, will call down to the
Core Graphic Services layer.

00:06:15.530 --> 00:06:17.400
And then your application
can call Quartz directly.

00:06:17.400 --> 00:06:20.100
So they sort of can all co-ex- well,
Cocoa and Carbon can't

00:06:20.100 --> 00:06:23.020
necessarily co-exist,
but your application call Quartz

00:06:23.120 --> 00:06:26.390
interleaved with calls that Cocoa or
Carbon might be making to Quartz.

00:06:26.400 --> 00:06:28.780
You don't have to do anything special.

00:06:28.780 --> 00:06:32.400
There's no funky stuff that goes
on to allow you to use it with-

00:06:32.400 --> 00:06:35.380
intermixed with the other frameworks.

00:06:35.400 --> 00:06:38.040
And of course,
this diagram shows on the back end what's

00:06:38.110 --> 00:06:42.400
coming out would be screen rendering,
PDF, PostScript, bitmap, raster data.

00:06:42.400 --> 00:06:44.270
So you get all of that for free,
of course,

00:06:44.390 --> 00:06:46.400
because you're using Quartz in any case.

00:06:46.400 --> 00:06:52.130
So the Quartz display model.

00:06:53.310 --> 00:06:56.930
Those of you who are familiar with
PostScript or PDF are probably

00:06:57.080 --> 00:06:59.900
pretty aware of the way they work.

00:07:00.000 --> 00:07:01.990
It's basically a painter's algorithm.

00:07:02.290 --> 00:07:04.760
You take some paint and you put down
some more paint on top and put down

00:07:04.900 --> 00:07:06.200
some more paint on top and so on.

00:07:06.220 --> 00:07:10.200
You just build up your image that way,
sort of from back to front.

00:07:10.330 --> 00:07:14.920
Now, because we have transparency,
the paints are more like watercolors

00:07:14.920 --> 00:07:19.660
instead of oil things that are opaque,
but you nevertheless get a nice image

00:07:19.710 --> 00:07:22.200
out of it as you're building it up.

00:07:22.200 --> 00:07:24.360
We're also--

00:07:24.710 --> 00:07:27.060
From the ground up,
we've striven to be device

00:07:27.060 --> 00:07:28.780
and resolution independent.

00:07:28.780 --> 00:07:32.210
So we're not really dependent
upon the number of dots per inch.

00:07:32.480 --> 00:07:36.020
We're not really dependent upon
the number of-- what your pixel

00:07:36.080 --> 00:07:37.460
depth is and stuff like that.

00:07:37.480 --> 00:07:41.260
We're really going for a situation
where when you use the API,

00:07:41.260 --> 00:07:45.910
it doesn't matter where you're going to
a printer or going to a screen display

00:07:46.060 --> 00:07:50.950
or any particular type of screen display,
you should get the same nice results.

00:07:50.950 --> 00:07:53.300
So your application doesn't
need to worry about that.

00:07:53.540 --> 00:07:58.400
For font support,
of course we support TrueType.

00:07:58.400 --> 00:07:59.600
We've had that for a long time.

00:07:59.600 --> 00:08:03.120
In developer preview 4,
we've added support for Type 1

00:08:03.220 --> 00:08:06.840
that's not completely finished,
so you will notice some places

00:08:06.840 --> 00:08:08.390
where it doesn't quite work.

00:08:08.440 --> 00:08:09.400
Excuse me.

00:08:09.400 --> 00:08:13.400
But that will certainly be
done in a future release.

00:08:13.600 --> 00:08:15.630
And of course we have CID font support.

00:08:15.630 --> 00:08:19.710
CID fonts are used for languages where
there's a large number of glyphs.

00:08:19.710 --> 00:08:22.170
Chinese or Japanese are good examples.

00:08:22.340 --> 00:08:25.480
And you need something a little bit
more sophisticated to manage the

00:08:25.520 --> 00:08:27.380
big glyph set in order to show text.

00:08:27.390 --> 00:08:33.200
So we have support for CID fonts as well,
both the CID TrueType and CID Type 1.

00:08:33.680 --> 00:08:35.240
And then we're also,
because we do care about

00:08:35.350 --> 00:08:39.490
device independence and so on,
we also support device independent color.

00:08:39.490 --> 00:08:42.690
And we leverage ColorSync for that,
and Apple technology does a great job of

00:08:42.690 --> 00:08:44.480
giving us device independence for color.

00:08:44.600 --> 00:08:48.590
And then one thing I want to clarify,
some people have asked me, well,

00:08:48.590 --> 00:08:52.600
you know, they remember the days when
we used Display Postscript.

00:08:52.600 --> 00:08:55.600
And the model there is you
have a client and a server,

00:08:55.600 --> 00:08:58.070
and if I say to the client,
"Draw me a rectangle," a little

00:08:58.070 --> 00:09:01.590
byte stream gets wadded up and
gets sent over to the server,

00:09:01.600 --> 00:09:02.600
and the server interprets
that byte stream and says,

00:09:02.640 --> 00:09:05.600
"Oh, draw a rectangle."
The rectangle gets drawn.

00:09:05.600 --> 00:09:06.600
We're not that.

00:09:06.600 --> 00:09:11.550
The Quartz display model doesn't use
sort of a PDF stream in between the two,

00:09:11.590 --> 00:09:12.590
the client-server side.

00:09:12.600 --> 00:09:14.600
Instead, we share memory.

00:09:14.600 --> 00:09:16.580
The client and the server have
a single shared memory buffer.

00:09:16.600 --> 00:09:18.640
And on the client side, you say,
"Draw me a rectangle," it

00:09:18.640 --> 00:09:19.500
gets drawn right there.

00:09:19.610 --> 00:09:21.600
The server takes it and
flushes that to the screen.

00:09:21.600 --> 00:09:23.600
So there's not some
intermediate representation,

00:09:23.600 --> 00:09:26.620
and that's a concern for some
people who are worried that

00:09:26.620 --> 00:09:28.250
it might not be efficient.

00:09:32.230 --> 00:09:36.080
So let me give you an
overview of our API.

00:09:36.080 --> 00:09:38.110
As I said before, we're very low-level.

00:09:38.390 --> 00:09:39.470
We're entirely in C.

00:09:39.580 --> 00:09:43.190
No objective-oriented stuff, no Java,
no other things.

00:09:43.390 --> 00:09:47.510
And because we're trying to
maybe increase consistency

00:09:47.690 --> 00:09:51.140
with other parts of the system,
we really do try to follow

00:09:51.140 --> 00:09:53.440
the core foundation style,
both for naming, conventions,

00:09:53.440 --> 00:09:54.200
and other things.

00:09:54.200 --> 00:09:58.290
So as a consequence,
the names are all pretty

00:09:58.290 --> 00:10:01.050
much exactly the same style.

00:10:01.270 --> 00:10:04.300
So there's CG, the prefix,
everything starts with CG so

00:10:04.300 --> 00:10:07.170
that you don't get the namespace
pollution you do in other frameworks.

00:10:07.200 --> 00:10:09.720
There's the class,
and I use that pretty loosely.

00:10:09.720 --> 00:10:12.200
I don't mean that in an
object-oriented sense.

00:10:12.200 --> 00:10:15.270
I mean that as sort of the
collection of common functions

00:10:15.270 --> 00:10:17.190
that this function belongs to.

00:10:17.200 --> 00:10:21.200
And then a verb and an object,
so do something to something.

00:10:21.200 --> 00:10:24.170
Here's an example, CG context show text.

00:10:24.260 --> 00:10:26.160
show some text in a context.

00:10:26.270 --> 00:10:29.030
And we'll get into that a
little bit more down the road.

00:10:29.500 --> 00:10:32.200
So what sort of classes,
collections of functions

00:10:32.200 --> 00:10:33.090
do we have available?

00:10:33.190 --> 00:10:37.080
These are a few and I'm going
to go into each one of them

00:10:37.140 --> 00:10:40.790
in a little bit more detail.

00:10:40.790 --> 00:10:40.790
Get a little bit more water.

00:10:44.940 --> 00:10:47.400
So, affine transforms.

00:10:47.440 --> 00:10:50.770
What we do is we model collections
of data just as a C struct,

00:10:50.770 --> 00:10:51.300
right?

00:10:51.460 --> 00:10:53.400
There's really nothing special about it.

00:10:53.400 --> 00:10:58.380
It's a simple C struct that provides all
the data you need for a particular thing.

00:10:58.480 --> 00:11:00.330
An affine transform is
one example of this.

00:11:00.420 --> 00:11:04.050
We have some functions that
let you create and use and

00:11:04.050 --> 00:11:06.290
modify the affine transform.

00:11:06.450 --> 00:11:09.210
An affine transform,
for those of you who are

00:11:09.210 --> 00:11:13.520
not familiar with them,
is a 3x2 matrix that lets you transform a

00:11:13.520 --> 00:11:16.350
two-dimensional space in a very nice way.

00:11:16.400 --> 00:11:19.650
You can do rotations, scaling, skewing,
pretty much the standard sorts

00:11:19.650 --> 00:11:22.450
of things that you might do if
you were trying to do a pretty

00:11:22.450 --> 00:11:27.390
straightforward display of things.

00:11:27.430 --> 00:11:30.370
Whoops.

00:11:30.480 --> 00:11:32.290
The nice thing about affine
transforms is that they form

00:11:32.290 --> 00:11:33.400
a group under multiplication.

00:11:33.400 --> 00:11:36.400
So if I scale or skew
something and do this,

00:11:36.400 --> 00:11:36.400
I can do this.

00:11:36.400 --> 00:11:38.750
those two things one after another,
what I end up with is

00:11:38.750 --> 00:11:40.700
another affine transform.

00:11:41.260 --> 00:11:48.860
In Quartz, what we use them for is
transforming our user space

00:11:48.860 --> 00:11:50.690
from one orientation to another.

00:11:50.770 --> 00:11:54.430
We can use them to flip or rotate,
the type of stuff that you might

00:11:54.430 --> 00:11:56.190
want to do if you're doing drawing.

00:11:56.340 --> 00:11:59.200
We have a couple of
convenience functions.

00:11:59.200 --> 00:12:02.200
There's functions to create
a rotation or a scale.

00:12:02.200 --> 00:12:04.200
We also have some other ones,
some simple ones.

00:12:04.200 --> 00:12:07.070
For example,
CG Affine Transform Invert takes

00:12:07.070 --> 00:12:09.550
an Affine Transform and inverts it.

00:12:11.140 --> 00:12:14.570
We also have some geometry structures.

00:12:14.650 --> 00:12:18.500
In this case, we have points,
which are just an X, Y position in space,

00:12:18.500 --> 00:12:21.950
a size, which is a width and a height,
and a rectangle, an origin,

00:12:21.950 --> 00:12:24.500
a point in space,
and a width and a height.

00:12:24.650 --> 00:12:29.580
They use floating point values for the
representation of the data because we're

00:12:29.590 --> 00:12:32.500
basically a vector-based drawing model.

00:12:32.500 --> 00:12:34.490
We really want to have
the device independence,

00:12:34.500 --> 00:12:36.500
and floating point works
very well for that.

00:12:36.500 --> 00:12:39.700
The functions we provide in
terms of manipulating these

00:12:39.700 --> 00:12:41.400
objects are pretty simple.

00:12:41.500 --> 00:12:43.500
You can create one, of course.

00:12:43.500 --> 00:12:47.120
You can do some simple
rectangular operations,

00:12:47.120 --> 00:12:50.500
such as intersect two rectangles,
get a rectangle, or union two rectangles,

00:12:50.500 --> 00:12:53.000
and get the rectangular union.

00:12:53.020 --> 00:12:56.270
There are some convenience things,
such as this example,

00:12:56.270 --> 00:12:59.970
CG_REC_CONTAINS_POINT_RETURNS_1,
if a point is inside a REC.

00:12:59.970 --> 00:13:02.830
That can be useful for
certain applications.

00:13:03.280 --> 00:13:04.900
So what I've talked about
so far is some pretty,

00:13:04.900 --> 00:13:08.070
those are, you know, you can imagine,
very simple structures.

00:13:08.130 --> 00:13:10.680
Now we're getting into something
a little bit more complicated,

00:13:10.690 --> 00:13:12.640
a little bit more data
associated with them.

00:13:12.740 --> 00:13:17.820
Color spaces are the way,
are the collection of information we

00:13:17.820 --> 00:13:21.090
need to represent a color in Quartz.

00:13:21.200 --> 00:13:24.040
We have functions that let
you work with device-dependent

00:13:24.040 --> 00:13:25.900
and device-independent colors.

00:13:26.000 --> 00:13:30.400
Device-dependent colors are, well,
let me, device-independent colors,

00:13:30.400 --> 00:13:34.840
that's very important when you have,
for example, a magazine illustration.

00:13:35.150 --> 00:13:38.340
Say you want to scan it in and
bring it up on your screen and you

00:13:38.340 --> 00:13:43.000
want the red value here to exactly
match so that the page here and the

00:13:43.000 --> 00:13:44.300
display here are exactly the same.

00:13:44.330 --> 00:13:47.720
You don't want to use device-independent
color in that case because

00:13:47.720 --> 00:13:50.620
you really don't want the,
you want the color to be independent of

00:13:50.620 --> 00:13:52.180
the device it's being represented on.

00:13:52.210 --> 00:13:55.870
Device-dependent colors are more
useful when you don't care so much.

00:13:55.940 --> 00:13:58.690
You sort of, you scan it in,
but you want like a nice red value.

00:13:58.700 --> 00:14:01.000
You wouldn't want some
blue value or something,

00:14:01.070 --> 00:14:04.390
but you're not precisely concerned
that they match 100%. So both of

00:14:04.390 --> 00:14:07.720
those are very useful in different
contexts and they're both,

00:14:07.720 --> 00:14:09.200
we support both of them.

00:14:09.240 --> 00:14:13.340
What we provide in Quartz,
what we use in Quartz to represent

00:14:13.430 --> 00:14:15.610
a color is just a C array of floats.

00:14:16.050 --> 00:14:19.600
So we're not doing anything
more special than that.

00:14:19.600 --> 00:14:23.200
Typically for like, for example, RGB,
you'd have three float values.

00:14:23.200 --> 00:14:25.310
CMYK would be four
float values and so on.

00:14:25.470 --> 00:14:25.790
We.

00:14:25.800 --> 00:14:30.370
Have convenience functions which let
you specify an RGB value directly,

00:14:30.540 --> 00:14:34.000
but we're not, but in, you know,
the primitive is an array

00:14:34.000 --> 00:14:36.760
of floating point values.

00:14:38.330 --> 00:14:43.410
So,
what color spaces do we really provide?

00:14:44.550 --> 00:14:48.160
In the device-dependent color spaces,
we support gray,

00:14:48.210 --> 00:14:51.500
which is just a monochrome 0 to 1 value,
black and white.

00:14:51.500 --> 00:14:55.780
RGB, which you're familiar with,
of course, for screen displays, and CMYK,

00:14:55.780 --> 00:14:57.800
which is used in printing.

00:14:57.860 --> 00:15:02.850
Device-independent colors,
the two special cases are

00:15:02.850 --> 00:15:06.080
calibrated gray and calibrated RGB.

00:15:06.560 --> 00:15:09.700
Those are both essentially
subsets of ICC profiles.

00:15:09.700 --> 00:15:12.300
Some of you might be familiar
with that from ColorSync,

00:15:12.360 --> 00:15:14.220
which uses those.

00:15:14.560 --> 00:15:17.700
To specify a device-independent color,
the calibrated gray and RGB are

00:15:17.700 --> 00:15:19.500
just simple special cases of those.

00:15:19.500 --> 00:15:22.790
But we do, using leverage from ColorSync,
we do have support for the

00:15:23.160 --> 00:15:25.880
full range of ICC profiles,
so you can work with

00:15:25.990 --> 00:15:30.570
those as you need to,
if that's what your application requires.

00:15:31.810 --> 00:15:34.810
You sort of have the device
dependent and device independent

00:15:34.860 --> 00:15:36.590
color spaces are sort of two axes.

00:15:36.600 --> 00:15:38.420
Indexed is a little special.

00:15:38.420 --> 00:15:42.510
Indexed works by essentially
associating with a number

00:15:42.780 --> 00:15:46.640
from 0 to some higher number,
0 to 255, for example,

00:15:46.710 --> 00:15:49.450
for each one of those numbers
is associated a single color

00:15:49.450 --> 00:15:50.730
and a given color space.

00:15:50.740 --> 00:15:56.260
It's a way to sort of compactly represent
a set of colors that really aren't

00:15:56.330 --> 00:15:58.510
the full range of all possible colors.

00:15:58.840 --> 00:16:01.470
GIF files, for example,
some of you might be familiar with those,

00:16:01.470 --> 00:16:07.550
use index color space essentially where
each number from 0 to 255 represents

00:16:07.550 --> 00:16:09.330
a single RGB value for the image.

00:16:09.340 --> 00:16:13.250
So we support those in Quartz
and they can be very powerful

00:16:13.250 --> 00:16:14.610
in some circumstances.

00:16:14.620 --> 00:16:20.020
An example of the functions that we have,
CG color space create device

00:16:20.440 --> 00:16:23.980
RGB creates the device RGB color space.

00:16:26.260 --> 00:16:29.100
Now, we also have support for images.

00:16:29.100 --> 00:16:33.140
In our parlance,
images are two-dimensional

00:16:33.140 --> 00:16:34.180
arrays of sample data.

00:16:34.240 --> 00:16:37.010
You have a width and a height, you know,
a bitmap, right?

00:16:37.120 --> 00:16:40.400
A width and a height, for every pixel,
you have a pixel depth,

00:16:40.400 --> 00:16:43.500
number of samples per pixel,
might be RGB, for example,

00:16:43.500 --> 00:16:45.090
would be three samples.

00:16:45.100 --> 00:16:48.970
In addition,
the image can have an alpha channel,

00:16:48.970 --> 00:16:53.090
so it can basically specify
coverage information.

00:16:53.110 --> 00:16:55.140
So not,
if you don't want all of the image

00:16:55.140 --> 00:16:58.060
to be displayed in a big rectangle,
you would use the alpha channel

00:16:58.100 --> 00:17:02.100
to knock out parts of the image
when you're displaying it.

00:17:02.100 --> 00:17:05.100
We also provide a function to
let you create an image mask,

00:17:05.190 --> 00:17:08.100
which you can think of as
just pure alpha coverage.

00:17:08.100 --> 00:17:11.650
It's just coverage information,
and you would use that typically

00:17:11.650 --> 00:17:15.100
to draw a color through there,
and so you'd end up with a, with a color.

00:17:15.120 --> 00:17:19.060
It's just the parts where the,
where the coverage mask was non-zero,

00:17:19.310 --> 00:17:21.100
actually drawn on the display.

00:17:21.100 --> 00:17:23.680
An example, a trivial example,
CG image create,

00:17:23.680 --> 00:17:27.600
though it does take an awful lot of
arguments to actually create an image.

00:17:28.850 --> 00:17:32.140
So what I've talked about so far is
really sort of data-bearing objects.

00:17:32.220 --> 00:17:35.160
They don't really have any
behavior associated with them.

00:17:35.160 --> 00:17:37.850
They just sort of contain information,
contain state.

00:17:37.860 --> 00:17:41.920
And those are useful, but, you know,
it's like, well, they don't do anything.

00:17:41.920 --> 00:17:46.190
So the drawing context is actually the
thing that carries behavior in Quartz.

00:17:46.230 --> 00:17:47.520
It's the thing that does something.

00:17:47.520 --> 00:17:52.120
You can think of the drawing context
as your connection to the device.

00:17:52.120 --> 00:17:54.780
The device might be the screen display.

00:17:54.780 --> 00:17:56.380
It might be a PDF file
that you're creating.

00:17:56.380 --> 00:17:57.280
It might be a bitmap.

00:17:57.770 --> 00:18:00.620
But the drawing context
really is associated with the

00:18:00.790 --> 00:18:02.660
thing that you're drawing to.

00:18:02.660 --> 00:18:06.150
Now, in addition,
it's not just the connection.

00:18:06.180 --> 00:18:07.940
It actually maintains state for you.

00:18:07.940 --> 00:18:11.730
Similar to QuickDraw,
we actually have a model where

00:18:11.740 --> 00:18:15.580
you set a bunch of state,
and then you ask the drawing

00:18:16.230 --> 00:18:18.890
context to do something for you.

00:18:18.910 --> 00:18:22.450
So you might want to draw a dotted rect,
for example.

00:18:22.520 --> 00:18:25.630
So you would set the dash pattern,
and you would set the line width,

00:18:25.750 --> 00:18:27.560
and then you would say, oh,
now go draw the rect.

00:18:27.740 --> 00:18:30.170
When that rect gets drawn,
it uses the information from the

00:18:30.170 --> 00:18:33.020
graphic state to display the rectangle.

00:18:35.470 --> 00:18:38.890
And, oh I should just mention,
these are some of the things that

00:18:38.940 --> 00:18:40.740
are part of the graphic state.

00:18:40.740 --> 00:18:45.020
Now, it's nice to have a graphic state,
but it's even nicer

00:18:45.020 --> 00:18:47.080
to have more than one.

00:18:47.080 --> 00:18:51.200
We actually allow you to,
again following the PDF PostScript model,

00:18:51.210 --> 00:18:52.720
you can save the graphic state.

00:18:52.720 --> 00:18:55.680
So you essentially are making
a copy of the current state.

00:18:55.680 --> 00:18:57.940
And then you can modify that
to your heart's content.

00:18:57.940 --> 00:19:00.220
When you restore it,
you go back to the original one.

00:19:00.220 --> 00:19:03.740
So that's really important if
you don't want to interfere

00:19:03.740 --> 00:19:05.000
with other people's drawing.

00:19:05.000 --> 00:19:07.940
You save the graphic state,
change whatever, and then restore it.

00:19:07.940 --> 00:19:10.440
You don't have to track
that information yourself.

00:19:10.440 --> 00:19:12.910
It's a stack,
so you can save and save and save

00:19:12.920 --> 00:19:14.300
and save and save the graphic state.

00:19:14.300 --> 00:19:16.310
And then you can restore, restore,
restore, restore, restore,

00:19:16.330 --> 00:19:18.920
and you get back to the original
graphic state that you're in.

00:19:18.940 --> 00:19:22.160
So that's actually a
really nice property.

00:19:22.160 --> 00:19:25.950
And again, that follows the
PDF PostScript model very closely.

00:19:27.900 --> 00:19:32.800
So what sorts of things can
you do to a drawing context?

00:19:32.800 --> 00:19:35.300
These are all parts of
the graphic state as well.

00:19:35.300 --> 00:19:37.740
You can modify the
display transformation.

00:19:37.770 --> 00:19:41.440
That's used if you want to, for example,
draw a rotated piece of text.

00:19:41.440 --> 00:19:44.100
You might change the
display transformation,

00:19:44.100 --> 00:19:47.360
rotate, draw your text,
which will go drawn in a nice angle,

00:19:47.360 --> 00:19:49.600
and then you might rotate back.

00:19:49.600 --> 00:19:53.390
Again, we're using the affine
transform to specify-- that's

00:19:53.390 --> 00:19:54.690
the sort of the primitive.

00:19:54.700 --> 00:19:57.960
The full affine transform specifies how
the display is transformed or how your

00:19:58.390 --> 00:20:02.030
drawing context state is transformed.

00:20:02.150 --> 00:20:06.490
There are convenience functions for doing
a simple rotation or a simple scale.

00:20:08.650 --> 00:20:13.200
Then the heart of what you do in a
graphics context is you specify a path.

00:20:13.200 --> 00:20:16.600
You specify a path to draw something,
to fill, to stroke, whatever.

00:20:16.600 --> 00:20:19.460
But the real meat of it is a path.

00:20:19.600 --> 00:20:25.670
In Quartz, we're really going for
something as simple as possible,

00:20:25.670 --> 00:20:27.440
but not too simple.

00:20:27.690 --> 00:20:30.510
Every path in Quartz is
composed of three parts:

00:20:30.620 --> 00:20:37.600
a line, or a collection of these, a line,
a Bezier curve, or a quadratic curve.

00:20:37.600 --> 00:20:40.600
Everything else is built up from that.

00:20:40.600 --> 00:20:45.540
We do have in the API convenience
functions for creating an arc,

00:20:45.600 --> 00:20:48.480
but we approximate that by
a sequence of Bezier curves.

00:20:48.600 --> 00:20:51.750
We also have functions for
working with rectangles,

00:20:51.750 --> 00:20:55.400
because those are just so common
that it's silly to have to build

00:20:55.450 --> 00:20:57.360
that up every time yourself.

00:20:57.570 --> 00:21:02.300
Now once you have the path specified,
you want to do something with it.

00:21:02.380 --> 00:21:02.860
What do you do?

00:21:02.880 --> 00:21:06.900
Well, again,
we're following the PDF model here.

00:21:06.900 --> 00:21:09.730
Typically you want to fill the path
or you want to stroke the path.

00:21:09.940 --> 00:21:12.060
Those things are often
done with different color.

00:21:12.060 --> 00:21:14.180
It's pretty rare you fill and
stroke it with the same color.

00:21:14.180 --> 00:21:16.430
So those two things are split out.

00:21:16.500 --> 00:21:18.080
There's a fill color and a stroke color.

00:21:18.080 --> 00:21:22.270
There's also a fill and stroke
color space because since the color

00:21:22.270 --> 00:21:26.690
itself doesn't convey any notion
of how to interpret its values,

00:21:27.200 --> 00:21:32.120
You also specify the color
space to the graphic state.

00:21:32.150 --> 00:21:33.840
I mean, as part of the graphic state.

00:21:33.950 --> 00:21:36.560
And then, as I said,
once you've set a color,

00:21:36.560 --> 00:21:38.080
you can fill the path,
you can stroke the path,

00:21:38.160 --> 00:21:40.070
you can fill and stroke
the path in one operation,

00:21:40.090 --> 00:21:43.100
sort of a sequence of things like that.

00:21:43.260 --> 00:21:45.210
And then another nice
thing that you can do is,

00:21:45.220 --> 00:21:48.040
once you've specified a path,
and it can be any path you want,

00:21:48.040 --> 00:21:49.100
you can clip to it.

00:21:49.320 --> 00:21:52.070
What that means is that
from that point on,

00:21:52.070 --> 00:21:56.100
nothing will be displayed
outside of that path's region.

00:21:56.400 --> 00:22:02.090
And then it turns out that the clip
region is part of the graphic state,

00:22:02.140 --> 00:22:03.100
so you can actually do
some really nice things.

00:22:03.100 --> 00:22:06.640
For example,
maybe you want to draw a nice picture

00:22:06.640 --> 00:22:09.100
of an ocean through a porthole.

00:22:09.120 --> 00:22:11.770
So you might draw, well,
what you first do is you'd

00:22:11.810 --> 00:22:14.020
save the graphic state,
because you don't want to

00:22:14.020 --> 00:22:15.100
screw up other people later.

00:22:15.140 --> 00:22:19.090
You draw as part of your path a circle,
you clip to it,

00:22:19.150 --> 00:22:23.100
and then you draw your image of
the seascape in the background.

00:22:23.100 --> 00:22:25.100
Well, nothing is going to be drawn
outside of that circle.

00:22:25.100 --> 00:22:26.090
So you'll get a nice image.

00:22:26.100 --> 00:22:28.980
You'll get a nice image of the
seascape through your porthole.

00:22:29.100 --> 00:22:31.050
Then we do a restore
of the graphic state.

00:22:31.130 --> 00:22:33.070
You're back to the original,
and the clip path is gone.

00:22:33.260 --> 00:22:35.090
And so now you can draw
any other part of the,

00:22:35.220 --> 00:22:37.100
maybe the rest of the room or something.

00:22:37.140 --> 00:22:39.560
So that's actually a pretty
nice thing that the clip path

00:22:39.650 --> 00:22:41.100
is part of the graphic state.

00:22:44.040 --> 00:22:46.900
Oh, and I should also mention
in terms of paths,

00:22:46.920 --> 00:22:49.290
it's not just a single, say,
a single arc.

00:22:49.360 --> 00:22:52.140
I mean, a path could be disjoint
pieces of like a line,

00:22:52.140 --> 00:22:53.770
a rectangle, a circle, a circle,
a circle.

00:22:54.140 --> 00:22:58.230
That whole wad would be considered
one path that you can work with.

00:22:59.300 --> 00:23:01.000
And then finally,
for the drawing context,

00:23:01.000 --> 00:23:03.020
clearly you can display an image.

00:23:03.130 --> 00:23:05.020
Once you've created one, you can draw it.

00:23:05.190 --> 00:23:08.100
It respects the parameters
of the graphic state.

00:23:08.100 --> 00:23:09.940
So if you've rotated it
and you've clipped it,

00:23:10.200 --> 00:23:12.540
that image will be clipped and
rotated exactly as you want.

00:23:12.600 --> 00:23:15.200
We handle all that stuff for you.

00:23:15.250 --> 00:23:20.250
You can select fonts in the API,
and then you can display text.

00:23:22.500 --> 00:23:26.500
So I should mention with displaying text,
we're not really in the

00:23:26.500 --> 00:23:28.740
business of Unicode display.

00:23:28.740 --> 00:23:31.500
The functions that we
provide are pretty basic.

00:23:31.520 --> 00:23:35.500
Go to a point and show some glyphs,
show some characters.

00:23:35.790 --> 00:23:39.980
If you want sort of Unicode
translation and that type of thing,

00:23:39.980 --> 00:23:42.270
that stuff's really hard,
and you should really go to

00:23:42.290 --> 00:23:43.520
a higher-level framework.

00:23:43.790 --> 00:23:47.140
At Sui, Carbon,
both those provide functions

00:23:47.140 --> 00:23:48.730
to allow you to do this.

00:23:49.050 --> 00:23:52.690
Cocoa has a great text display layout
system that is all Unicode-based.

00:23:52.700 --> 00:23:55.500
So really,
if you want that type of thing,

00:23:55.500 --> 00:23:57.690
and you want to go to a higher level,
we're working at a

00:23:57.710 --> 00:23:59.130
little bit lower level.

00:23:59.130 --> 00:24:02.690
But it might still be
sufficient for your needs.

00:24:03.830 --> 00:24:06.960
Now, of course, Steve showed a bunch of
PDF files getting displayed.

00:24:07.100 --> 00:24:10.700
Peter Graffagnino on
Wednesday talked about PDF.

00:24:10.820 --> 00:24:13.790
So one question you might have
is what sort of things can you do

00:24:13.790 --> 00:24:15.660
in the Quartz API with PDF files?

00:24:15.700 --> 00:24:19.390
Well, in DP4,
at the level of the Quartz API,

00:24:19.390 --> 00:24:23.610
we don't have functions that
are public for you to use.

00:24:23.790 --> 00:24:26.850
If you want to do, for example,
a page display, you really should

00:24:26.850 --> 00:24:31.700
probably go through Cocoa,
or Carbon, I should say.

00:24:31.700 --> 00:24:35.120
Here in Cocoa,
you can create an NSPDF image rep

00:24:35.120 --> 00:24:37.700
that will display pages for you.

00:24:37.700 --> 00:24:39.640
If you're Carbon,
you can use a QuickTime graphic importer.

00:24:39.730 --> 00:24:43.300
Unfortunately, for DP4,
we don't have API in Quartz that lets you

00:24:43.380 --> 00:24:45.620
directly display a page from a PDF file.

00:24:45.690 --> 00:24:48.700
We will in a future version,
which I think will be very nice.

00:24:48.700 --> 00:24:51.320
A typical example might be if
you had a PDF file that contained

00:24:51.320 --> 00:24:54.100
your logo for your business,
and you just draw it up in

00:24:54.100 --> 00:24:56.870
some part of your screen,
and then you'd fill in the

00:24:56.870 --> 00:24:59.700
rest of it with either Cocoa,
Carbon, or Quartz calls.

00:24:59.700 --> 00:25:03.660
And of course,
it's just like an image in that respect.

00:25:03.740 --> 00:25:06.700
It will respect all the
parameters of the graphic state,

00:25:06.700 --> 00:25:08.750
so you could rotate the PDF file,
or scale it, or skew it,

00:25:08.750 --> 00:25:09.680
whatever you want.

00:25:09.700 --> 00:25:09.700
All that stuff is handled for you.

00:25:09.700 --> 00:25:12.620
All right.

00:25:12.680 --> 00:25:18.440
We'll also provide, post-DP4,
support to create a PDF drawing context.

00:25:18.470 --> 00:25:21.580
I'll talk a little bit later about how
you actually get a hold of a context.

00:25:21.700 --> 00:25:25.030
Right now, though,
there's no way to sort of create one of

00:25:25.030 --> 00:25:27.600
your own that you can then stream PDF to.

00:25:27.600 --> 00:25:30.280
Post-DP4 will let you,
will give you API that will

00:25:30.320 --> 00:25:31.720
let you create a PDF context.

00:25:32.030 --> 00:25:36.980
You can do a whole bunch
of Quartz calls into it,

00:25:36.980 --> 00:25:37.810
and what comes out on the
back end will be a PDF file.

00:25:39.790 --> 00:25:42.940
So, how would you use quartz if you
actually decided to in your application?

00:25:42.940 --> 00:25:45.740
I'm not going to talk
too much about Cocoa,

00:25:45.740 --> 00:25:48.940
basically you want to
get a context for NSVU.

00:25:48.940 --> 00:25:52.560
There's a good example,
a small example of how to do

00:25:52.560 --> 00:25:54.700
this in the Sketch example.

00:25:54.750 --> 00:25:59.600
It's I think in system library,
or system developer examples,

00:25:59.600 --> 00:26:03.220
sketch.app or roughly that,
you'll find it.

00:26:03.220 --> 00:26:05.870
And that's actually has an
example of how to do this.

00:26:05.920 --> 00:26:09.790
For Carbon, which probably more of
you are interested in,

00:26:09.810 --> 00:26:13.560
the way you get a drawing context to
work with is from your graph port.

00:26:13.560 --> 00:26:14.740
And they're really,
you can think of them as like

00:26:14.790 --> 00:26:15.580
a one to one correspondence.

00:26:15.580 --> 00:26:18.160
If you have a graph port,
you can get a drawing context.

00:26:18.160 --> 00:26:20.310
As I said before,
you can keep using the graph port

00:26:20.480 --> 00:26:22.000
while you're using the context.

00:26:22.000 --> 00:26:25.190
There's nothing that sort of stops
you from doing one or the other.

00:26:26.220 --> 00:26:31.130
Post-DP4, as I mentioned before,
you'll be able to create a

00:26:31.130 --> 00:26:34.840
PDF context that you can write to
and PDF comes out on the back end.

00:26:34.840 --> 00:26:38.340
We'll also provide you with
a bitmap generation context.

00:26:38.340 --> 00:26:42.550
For example,
you can create an image for a bitmap

00:26:42.550 --> 00:26:48.820
that has all of the coordinates drawing
in the bitmap that you can then take and

00:26:48.890 --> 00:26:54.100
convert to a JPEG file or maybe send it
to a printer or some other use for it.

00:26:54.100 --> 00:26:58.410
That will be available post-DP4.

00:26:59.310 --> 00:27:02.970
So if you decide, oh,
I want to use this API, it's really cool,

00:27:03.010 --> 00:27:04.640
where do you find it?

00:27:04.670 --> 00:27:07.390
The header files are in the
core graphics framework.

00:27:07.480 --> 00:27:09.990
Somebody the other day was asking me,
I don't see any Quartz

00:27:09.990 --> 00:27:11.120
frameworks anywhere.

00:27:11.200 --> 00:27:14.200
And that's because they're in
the core graphics framework.

00:27:14.200 --> 00:27:17.620
For DP4, there's documentation
in the header files.

00:27:17.620 --> 00:27:20.200
There's comments before each function.

00:27:20.200 --> 00:27:22.530
I realize it's not
official documentation,

00:27:22.530 --> 00:27:24.200
but it's available in DP4.

00:27:24.200 --> 00:27:29.110
Post-DP4, we should have documentation
available on the developer website.

00:27:29.190 --> 00:27:34.200
We'll also probably have some
examples of code that uses Quartz,

00:27:34.200 --> 00:27:38.820
and you can use that to get
an idea of how to use it.

00:27:39.240 --> 00:27:43.190
I believe the demo we're going to
show you later will be up shortly.

00:27:44.510 --> 00:27:47.680
So now actually I'd like to show
you the demo and I'd like to welcome

00:27:47.770 --> 00:27:52.570
Mike Marinkovich up on stage,
who's going to lead you through how he

00:27:52.570 --> 00:27:56.400
used Quartz in his Carbon application.

00:27:56.410 --> 00:27:58.990
Well thank you very much Derek.

00:28:01.690 --> 00:28:03.710
So as Derek mentioned,
what we're showing today

00:28:03.710 --> 00:28:05.540
is a Carbon application.

00:28:05.560 --> 00:28:09.500
What makes this Carbon application
special is the fact that we've modified

00:28:09.500 --> 00:28:12.600
it to take advantage of core graphics.

00:28:12.890 --> 00:28:16.190
So, this application's been a
long time in the making.

00:28:16.190 --> 00:28:19.300
It's been started off as a Mac OS 8 app.

00:28:19.610 --> 00:28:23.760
We eventually ported it to Carbon,
and now we've modified it once again

00:28:23.760 --> 00:28:25.700
to take advantage of Core Graphics.

00:28:25.800 --> 00:28:31.290
So the first thing we did to create
this Core Graphics project is we moved

00:28:31.320 --> 00:28:36.800
our source files over to Mac OS X,
and we created a project builder project,

00:28:37.200 --> 00:28:38.800
imported all our source files.

00:28:38.800 --> 00:28:42.750
So, what you're seeing up on the
screen is our project builder

00:28:42.750 --> 00:28:44.700
project called Carbon Draw.

00:28:45.370 --> 00:28:49.480
Carbon Draw is a vector-based
drawing application.

00:28:49.820 --> 00:28:54.010
It's Carbon, but it uses Core Graphics
for its rendering.

00:28:54.640 --> 00:28:56.330
So a couple interesting notes.

00:28:56.410 --> 00:29:00.200
Derek was pointing out
the frameworks usage.

00:29:00.200 --> 00:29:06.190
And one thing we had to do to our project
was import the core graphics framework.

00:29:06.220 --> 00:29:09.930
And you'll see here where the mouse is,
we have imported that.

00:29:10.100 --> 00:29:15.190
And that's under the project menu,
add a framework.

00:29:15.240 --> 00:29:18.050
And that is in system
libraries frameworks,

00:29:18.050 --> 00:29:21.200
which you've probably
heard a lot of this week.

00:29:21.210 --> 00:29:23.440
So from here,
why don't I launch the application,

00:29:23.440 --> 00:29:25.700
and I'll show you what we've done.

00:29:26.500 --> 00:29:29.340
Hopefully it doesn't have to recompile.

00:29:29.380 --> 00:29:32.310
So at first glance,
you'll notice the app looks

00:29:32.340 --> 00:29:33.710
like any other Carbon app.

00:29:33.860 --> 00:29:41.100
It's got standard event manager calls,
standard window dragging, event handling,

00:29:41.180 --> 00:29:43.390
even Apple events.

00:29:43.920 --> 00:29:48.900
It's just a regular old Carbon app
that we call Core Graphics.

00:29:48.900 --> 00:29:52.300
So the first thing I'll
show you is a line,

00:29:52.300 --> 00:29:53.370
simply.

00:29:53.630 --> 00:29:57.490
And this app allows us
to resize the object,

00:29:57.620 --> 00:30:03.140
drag it around,
can make the line width a little bigger,

00:30:03.200 --> 00:30:05.720
drag the object around.

00:30:06.110 --> 00:30:09.930
So one of the great features of
Core graphics is the fact that

00:30:09.990 --> 00:30:11.800
we have anti-aliased graphics.

00:30:11.800 --> 00:30:16.140
So to demonstrate this,
I will bring up a little app that

00:30:16.140 --> 00:30:19.560
shows us effectively fat bits,
and you'll notice that

00:30:19.560 --> 00:30:21.290
the edge is anti-aliased.

00:30:21.400 --> 00:30:27.880
So we have real clean-looking,
nice graphics with Core graphics.

00:30:28.920 --> 00:30:33.640
So another feature we took
advantage of was line caps.

00:30:33.640 --> 00:30:40.480
Now, if I make this a little bigger,
you will be able to see that we have

00:30:40.830 --> 00:30:43.090
Quartz is a flat end on this.

00:30:43.190 --> 00:30:46.180
And what this is,
is this is the butt line cap.

00:30:46.300 --> 00:30:52.210
Now the butt line cap is rendering
from the origin to the destination

00:30:52.690 --> 00:30:55.550
and giving you a square end.

00:30:55.700 --> 00:31:00.600
Well, we also have other line caps,
and one of which would

00:31:00.600 --> 00:31:02.700
be the round line cap.

00:31:02.700 --> 00:31:05.430
So we have a nice round edge.

00:31:05.490 --> 00:31:10.040
And once again,
if I bring up the fat bits application,

00:31:10.040 --> 00:31:13.400
you'll notice that it's
anti-aliased as well.

00:31:13.720 --> 00:31:20.080
So we can also apply the square line cap,
which gives you relatively

00:31:20.080 --> 00:31:24.390
the same as the butt line cap,
except for the rendering occurs half

00:31:24.510 --> 00:31:29.310
the line width before the origin and
half the line width after the origin,

00:31:29.310 --> 00:31:31.130
giving you a square pen.

00:31:31.870 --> 00:31:36.520
So, besides that,
we're able to apply some

00:31:36.520 --> 00:31:41.190
other aspects to this object,
such as Derek mentioned, LineDash.

00:31:41.260 --> 00:31:44.210
So if I make this a little smaller...

00:31:45.040 --> 00:31:51.680
We can apply a line dash to this,
and this will give us, in this case,

00:31:51.810 --> 00:31:55.060
just a square line dash,
but since the dashes are

00:31:55.060 --> 00:31:58.730
all individual lines,
we can apply a line cap

00:31:58.730 --> 00:32:00.400
to each one of those.

00:32:00.510 --> 00:32:04.310
So if I can apply

00:32:04.500 --> 00:32:08.720
I can apply the round line
cap to it as an example,

00:32:08.720 --> 00:32:12.500
and we have round line caps
on the individual lines,

00:32:12.500 --> 00:32:15.410
and I can also apply the butt line cap.

00:32:15.500 --> 00:32:20.500
We supply the dash to
Core Graphics as an array,

00:32:20.500 --> 00:32:24.500
so if we had, in this case we're using
an array of two items,

00:32:24.500 --> 00:32:26.500
a length of the dash and
a length of the space,

00:32:26.500 --> 00:32:29.500
but you can also apply as
many as you would like.

00:32:29.500 --> 00:32:35.770
So if we wanted to make the dashes
smaller and say apply the round line cap,

00:32:35.770 --> 00:32:40.500
we could have little round
circles as our line dash.

00:32:45.140 --> 00:32:49.200
So from here,
a lot of people have asked if we can

00:32:49.200 --> 00:32:55.460
actually render with Quickdraw and
Core Graphics into the same buffers.

00:32:55.510 --> 00:33:00.520
Well, what we're doing for our selection
process is we're using Quickdraw

00:33:00.520 --> 00:33:03.380
in XOR mode to render the line.

00:33:03.490 --> 00:33:07.550
So if I drag this out,
you'll notice that we're using XOR mode

00:33:07.800 --> 00:33:10.330
and the edges are fairly jagged.

00:33:10.390 --> 00:33:11.880
That's Quickdraw.

00:33:11.960 --> 00:33:15.470
And you'll also notice
that the ends of the line,

00:33:15.470 --> 00:33:20.400
the line caps, are pointed,
which is the effect of Quickdraw's

00:33:20.400 --> 00:33:24.900
hanging pen drawing algorithm,
which is really far from optimal.

00:33:24.980 --> 00:33:27.900
If you look at the
Core Graphics line above it,

00:33:27.900 --> 00:33:30.300
you'll see much nicer graphics.

00:33:30.410 --> 00:33:34.820
So I release that and we
have a Core Graphics object.

00:33:35.640 --> 00:33:38.380
So from here,
I'll delete these two items.

00:33:38.380 --> 00:33:41.360
I'd like to show you rectangles.

00:33:41.410 --> 00:33:46.360
So as with Quick Draw, in Core Graphics,
we can draw rectangles,

00:33:46.360 --> 00:33:49.550
and we get the anti-alias
graphics as well.

00:33:49.600 --> 00:33:53.820
So if I make this a little bigger,
I'll show you another feature,

00:33:53.960 --> 00:33:55.560
and that is line joins.

00:33:55.600 --> 00:34:00.370
So in Core Graphics,
you can apply a line join to this item,

00:34:00.370 --> 00:34:04.600
so wherever the lines meet,
in this case with the rectangle,

00:34:04.600 --> 00:34:08.230
you have four corners,
you can apply a join.

00:34:08.770 --> 00:34:15.210
So what we're seeing here
is the mitered line join.

00:34:15.210 --> 00:34:15.210
We can also apply...

00:34:15.340 --> 00:34:17.120
Other line joints such as round.

00:34:17.230 --> 00:34:21.050
So now we have rounded corners and
I'll bring up a little fat bits to

00:34:21.050 --> 00:34:23.930
show you the rounded corners again.

00:34:26.110 --> 00:34:29.000
And for you QuitDraw folks,
you'll notice that the interior

00:34:29.000 --> 00:34:32.540
of the rectangle is still square,
which is different from

00:34:32.540 --> 00:34:34.890
QuitDraw's rendering algorithm.

00:34:36.720 --> 00:34:41.290
So we can also apply another line join,
which is the bevel line join,

00:34:41.290 --> 00:34:44.150
which is another nice effect.

00:34:45.900 --> 00:34:49.340
So from here,
I'll also show you that we can

00:34:49.340 --> 00:34:53.190
apply line dash to this object.

00:34:53.650 --> 00:34:59.910
So what we have here is we
have the butt line dash,

00:34:59.910 --> 00:35:02.850
and I can apply all the
other line dashes to it,

00:35:03.020 --> 00:35:04.860
or the other line caps to it.

00:35:05.210 --> 00:35:07.030
So you'll notice that
here we have rounded,

00:35:07.130 --> 00:35:09.720
but we still have our

00:35:09.910 --> 00:35:12.800
Our line join application to this.

00:35:12.850 --> 00:35:16.840
So, in this case we have bevel,
and if we move this around,

00:35:16.840 --> 00:35:18.800
you'll notice that the
corners are beveled,

00:35:18.800 --> 00:35:21.230
but yet we have a rounded line dash.

00:35:21.230 --> 00:35:23.870
So it's an interesting effect.

00:35:27.200 --> 00:35:32.650
So, another interesting thing is
that Core graphics can interact

00:35:32.800 --> 00:35:35.480
with the rest of the toolbox,
or I should say it's easy to

00:35:35.480 --> 00:35:38.800
interact with the Carbon toolbox.

00:35:38.960 --> 00:35:41.590
And for the demo, we set up a fill color.

00:35:41.850 --> 00:35:46.550
So, I'll bring up the color picker,
and we're looking at the standard

00:35:46.560 --> 00:35:51.150
Mac OS color picker on Mac OS X,
the crayons.

00:35:51.370 --> 00:35:55.800
We'll pick a new color, let's say yellow,
so it's not too bright.

00:35:56.040 --> 00:35:58.400
Okay,
and now we have a fill color of yellow.

00:35:58.400 --> 00:36:03.900
Well, what this demonstrates is it's
easy to convert an RGB color,

00:36:03.900 --> 00:36:06.490
a Macintosh RGB color,
which is four shorts,

00:36:06.630 --> 00:36:12.050
into a floating point RGB color,
the more modern floating point

00:36:12.050 --> 00:36:14.660
RGB color that Core Graphics uses.

00:36:14.880 --> 00:36:20.270
And we can also change the stroke color,
just so I can show you that

00:36:20.270 --> 00:36:22.650
we can actually do this.

00:36:22.650 --> 00:36:22.650
Pick purple.

00:36:23.860 --> 00:36:29.560
So from here,
I'd like to move on to something else.

00:36:29.570 --> 00:36:33.840
I'll try and pick a little
bit more useful colors.

00:36:33.840 --> 00:36:35.830
I don't want to blind you.

00:36:37.900 --> 00:36:41.400
So we can also draw ovals,
as Derek mentioned.

00:36:41.440 --> 00:36:45.700
So we have an oval with
nice anti-aliased edges,

00:36:45.700 --> 00:36:48.300
which is a nice change.

00:36:48.300 --> 00:36:52.440
And we can also apply
the line dash to this.

00:36:52.440 --> 00:36:57.540
You'll notice you can resize this,
and Core Graphics dynamically

00:36:57.540 --> 00:37:03.000
reconfigures where the dashes
are and even get the nice

00:37:03.000 --> 00:37:05.800
bending effects in the corners.

00:37:08.460 --> 00:37:14.950
So, there are other architecture changes
that we took advantage of in this

00:37:15.060 --> 00:37:18.600
application that aren't apparent here.

00:37:18.650 --> 00:37:25.110
On the old Mac OS 8 application,
we used an off-screen to buffer all these

00:37:25.110 --> 00:37:29.100
objects and copy bits them to the screen.

00:37:29.150 --> 00:37:33.740
Well, that was quite a bit of work
and we also had to do...

00:37:33.760 --> 00:37:35.940
We're going to be rendering
in different spaces.

00:37:35.940 --> 00:37:40.120
So we'd be rendering in our off-screen
when we really wanted to show it on

00:37:40.120 --> 00:37:42.570
the screen and so forth and so on.

00:37:42.700 --> 00:37:46.650
So what we're doing in this application
is we've taken advantage of the

00:37:46.650 --> 00:37:48.700
fact that the windows are buffered.

00:37:48.700 --> 00:37:52.890
So we render directly into our window,
and when we're done

00:37:52.890 --> 00:37:54.700
rendering we just call flush.

00:37:54.700 --> 00:37:59.720
The graphics system keeps track of
what we've changed in the window,

00:37:59.890 --> 00:38:02.620
and it flushes only that
that has been changed.

00:38:02.700 --> 00:38:08.000
So we can get relatively flicker-free,
if not completely flicker-free

00:38:08.000 --> 00:38:11.700
drawing by using this method.

00:38:11.700 --> 00:38:13.890
So if I...

00:38:14.640 --> 00:38:16.400
Create a few objects here.

00:38:16.400 --> 00:38:21.250
All going to be the same color,
but maybe I'll set the background color.

00:38:22.940 --> 00:38:25.900
Something a little different here.

00:38:25.930 --> 00:38:31.390
You'll notice that we can drag
these objects around flicker-free.

00:38:31.420 --> 00:38:35.930
Hopefully on this display it's
flicker-free without doing too much work.

00:38:36.080 --> 00:38:40.620
So we've taken advantage of the
low-level architecture for our buffering.

00:38:40.990 --> 00:38:43.160
So from here,
I'd like to turn it back over to Derek,

00:38:43.180 --> 00:38:46.400
where he is going to talk about
some of the techniques we use to

00:38:46.400 --> 00:38:47.900
make this application possible.

00:38:47.900 --> 00:38:50.050
Thank you.

00:38:53.400 --> 00:40:25.000
[Transcript missing]

00:40:26.110 --> 00:40:29.120
As a second example,
here's how we draw the ovals

00:40:29.120 --> 00:40:29.950
that Mike was showing you.

00:40:29.960 --> 00:40:34.480
What we want to do is play a trick.

00:40:34.560 --> 00:40:38.180
Instead of actually drawing an oval,
what we're going to do is draw a circle.

00:40:38.180 --> 00:40:41.980
But we're going to scale the
drawing context so that we actually

00:40:41.980 --> 00:40:44.020
stretch it out to get a nice oval.

00:40:44.020 --> 00:40:48.450
That's a pretty convenient trick because
it's really hard to actually do all the

00:40:48.450 --> 00:40:49.960
math to figure out how to draw the oval.

00:40:49.960 --> 00:40:51.480
It's really nice to just draw the circle.

00:40:51.480 --> 00:40:53.140
So what do we do?

00:40:53.140 --> 00:40:54.980
Well,
we begin by saving the graphic state.

00:40:55.100 --> 00:40:57.700
We want to have our changes
not affect other people.

00:40:57.700 --> 00:41:00.630
Then we do begin path.

00:41:00.710 --> 00:41:01.390
We start a path.

00:41:01.500 --> 00:41:03.910
And then we scale the
transformation matrix.

00:41:03.980 --> 00:41:07.920
We scale an X and Y by the amount we
want to stretch so that we get the oval.

00:41:07.920 --> 00:41:10.450
We then add an arc to the path.

00:41:10.550 --> 00:41:12.880
This is one of the convenience
functions I mentioned earlier.

00:41:12.880 --> 00:41:16.210
This takes a center
radius and then an angle,

00:41:16.210 --> 00:41:18.310
0 to 2 pi in this case.

00:41:18.390 --> 00:41:19.240
We're going to draw the whole circle.

00:41:19.240 --> 00:41:21.100
And then whether it's
clockwise or counterclockwise.

00:41:21.100 --> 00:41:22.950
And then we close the path.

00:41:23.040 --> 00:41:25.730
And then we... Once we've...
We've done that.

00:41:25.740 --> 00:41:26.610
We specified the path.

00:41:26.810 --> 00:41:27.430
We fill it.

00:41:27.520 --> 00:41:30.760
We just fill it with the current
color from the graphic state.

00:41:30.780 --> 00:41:33.560
And then because we're done
working with the graphic state,

00:41:33.560 --> 00:41:34.930
we restore it back to what it was.

00:41:34.960 --> 00:41:36.180
You want to have those things balanced.

00:41:36.280 --> 00:41:38.620
So that's a pretty simple
example of drawing an oval.

00:41:38.620 --> 00:41:42.020
Most of the demo has about as
much code as this for each one

00:41:42.020 --> 00:41:44.200
of the different little pieces.

00:41:44.200 --> 00:41:47.520
So Quartz does an awful lot for you.

00:41:49.070 --> 00:41:52.200
So just to summarize
before we get to Q&A,

00:41:52.240 --> 00:41:55.710
what we're providing is a pretty
straightforward low-level 2D API.

00:41:55.720 --> 00:41:59.300
That's the goal, and that's, I think,
what we're providing.

00:41:59.480 --> 00:42:03.760
You want to sort of think about
using Quartz when it makes

00:42:03.770 --> 00:42:04.880
sense in your application.

00:42:04.880 --> 00:42:08.220
It probably doesn't make sense to
write your whole app in Quartz.

00:42:08.340 --> 00:42:10.730
I don't know, maybe,
but I would think not.

00:42:10.910 --> 00:42:13.490
The toolkits above,
Cocoa and Carbon they're great.

00:42:13.580 --> 00:42:16.420
They have lots of things
available for you to work with.

00:42:16.490 --> 00:42:19.300
There will be times you might want
to drop down to the level of Quartz.

00:42:19.490 --> 00:42:21.260
When that makes sense do that.

00:42:21.490 --> 00:42:24.480
But you're going to have to
decide that question for yourself

00:42:24.670 --> 00:42:25.960
for your own application.

00:42:26.200 --> 00:42:27.960
And then finally we're not done.

00:42:28.060 --> 00:42:32.860
The API that is in DP4
is our first set of API.

00:42:32.860 --> 00:42:35.780
We're not going to take anything away,
but we're planning on adding more.

00:42:35.900 --> 00:42:41.100
So as we get feedback and as we
think about more things to do,

00:42:41.190 --> 00:42:42.800
we'll be adding more API for the future.

00:42:42.830 --> 00:42:46.650
So we're really interested in having
your feedback to sort of help us

00:42:46.650 --> 00:42:48.990
focus what we need to do next.

00:42:49.210 --> 00:42:53.630
The people to contact if you want to
actually send email to some human being.

00:42:53.800 --> 00:42:55.560
John Signa is our technology manager.

00:42:55.560 --> 00:42:56.410
You can mail him.

00:42:56.490 --> 00:42:57.880
David Wright is our application manager.

00:42:57.970 --> 00:42:59.660
He's our communications
technology manager.

00:42:59.660 --> 00:43:00.930
You can mail him.

00:43:00.970 --> 00:43:04.460
It's not on this slide,
but there's an email address,

00:43:04.460 --> 00:43:09.300
graphics-feedback@apple.com
that will go to us.

00:43:09.300 --> 00:43:13.860
And you can certainly send any
email you want to that address.

00:43:14.030 --> 00:43:16.280
And we'll take a look at it.

00:43:16.280 --> 00:43:18.080
For those of you who are
interested later today,

00:43:18.080 --> 00:43:20.920
I guess actually right after
my talk in this same hall,

00:43:20.920 --> 00:43:23.790
we'll have the Mac OS X advanced
printing session that will probably

00:43:23.810 --> 00:43:25.960
touch on some aspects of Quartz.

00:43:25.960 --> 00:43:27.820
And then a very important thing.

00:43:27.970 --> 00:43:28.960
We're going to be open
until 5:00 on Friday,

00:43:28.960 --> 00:43:30.060
the last day of the conference.

00:43:30.150 --> 00:43:32.670
But we'd really love it if you
could make it to the feedback

00:43:33.090 --> 00:43:35.340
forum for graphics and printing.

00:43:35.390 --> 00:43:37.830
It would be super if you could do that.

00:43:38.930 --> 00:43:42.240
So I'd like to have the
people in the team come up,

00:43:42.240 --> 00:43:45.100
and we'll have some Q&A.
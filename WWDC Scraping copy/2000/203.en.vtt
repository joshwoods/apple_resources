WEBVTT

00:00:14.140 --> 00:00:17.860
Whenever a transition occurs,
like we had one about two

00:00:17.860 --> 00:00:22.050
years ago in terms of I/O from
USB to USB and FireWire,

00:00:22.050 --> 00:00:25.560
that always causes a
heartache for customers,

00:00:25.680 --> 00:00:28.720
for developers,
because you've got to do some work

00:00:28.720 --> 00:00:32.680
for Apple because you have to do
all this work to get it out there.

00:00:32.680 --> 00:00:36.720
That also gives rise
to great opportunities.

00:00:36.720 --> 00:00:40.150
We think that the people who
really grab this on are the ones

00:00:40.150 --> 00:00:42.320
that are eventually successful.

00:00:42.320 --> 00:00:46.760
So here again, Apple is presenting you
with another opportunity to

00:00:47.230 --> 00:00:51.320
write drivers for Mac OS X,
because all the customers that

00:00:51.410 --> 00:00:56.070
now start upgrading to Mac OS X in
the next year are going to need

00:00:56.660 --> 00:01:00.340
peripherals with the appropriate
drivers to make sure that it works.

00:01:00.340 --> 00:01:03.040
And I think the people,
the developers that really give

00:01:03.220 --> 00:01:07.160
them these drivers will be the one
eventually that come up on top.

00:01:07.160 --> 00:01:10.600
So we are presenting you
with an opportunity here.

00:01:10.680 --> 00:01:13.330
To get into details of
Mac OS X and writing drivers,

00:01:13.420 --> 00:01:17.140
by the way, this session is entirely
devoted to writing X drivers,

00:01:17.210 --> 00:01:19.370
I'd like to welcome William Guland.

00:01:19.690 --> 00:01:24.740
William is the tech lead for Mac OS X,
and in fact he's the one who's been doing

00:01:24.740 --> 00:01:30.220
all this hard work to make sure that
X FireWire in DP4 works really well.

00:01:30.320 --> 00:01:34.150
William?

00:01:37.270 --> 00:01:41.520
Good afternoon.

00:01:41.550 --> 00:01:45.040
I'm going to be talking to you about,
as Jai said,

00:01:45.150 --> 00:01:49.180
how to write drivers for OS X,
FireWire drivers.

00:01:49.180 --> 00:01:53.130
I also want to go over briefly what

00:01:54.060 --> 00:01:59.290
is in DP4,
what's in the CD that you have now,

00:01:59.410 --> 00:02:04.130
what will be in the OS X public
beta when we release that,

00:02:04.110 --> 00:02:06.830
So therefore,
I'll be talking to you a bit about

00:02:07.710 --> 00:02:12.520
the things that we haven't done yet,
the things that aren't in DP4,

00:02:12.520 --> 00:02:17.050
and give you some pointers to the kind of
things that might change in the future.

00:02:17.100 --> 00:02:22.760
I really want to make sure that you have
a basic idea of how you're going to start

00:02:22.760 --> 00:02:25.530
writing FireWire drivers in Mac OS X.

00:02:26.440 --> 00:02:30.480
I'm going to explain briefly
how driver matching works,

00:02:30.540 --> 00:02:35.490
so we can make sure that your
driver gets loaded for your device,

00:02:35.490 --> 00:02:38.470
not for someone else's device,
and can start running

00:02:38.470 --> 00:02:40.410
and do the right thing.

00:02:41.800 --> 00:02:47.800
I'm also showing you here where
you'll be able to find the SDK.

00:02:48.040 --> 00:02:51.950
That isn't actually-- we don't
have an SDK ready for you yet.

00:02:52.110 --> 00:02:56.300
But if you check this URL,
we'll be sure to point

00:02:56.300 --> 00:02:58.240
out where you can get it.

00:02:59.350 --> 00:03:05.390
And of course, really important,
the FireWire code is open source.

00:03:05.390 --> 00:03:06.300
It's part of Darwin.

00:03:06.300 --> 00:03:12.120
If you're going to write a device driver,
please sign up for Darwin.

00:03:12.120 --> 00:03:12.760
Get the source.

00:03:12.760 --> 00:03:16.370
Use the source, Luke.

00:03:16.430 --> 00:03:18.920
It's a lot easier if you can
see how we're doing things,

00:03:18.920 --> 00:03:21.180
see how you should do things as well.

00:03:23.800 --> 00:03:28.800
Okay, so how do things work?

00:03:29.360 --> 00:03:37.490
The FireWire drivers in OS X,
they use I/OKit.

00:03:37.700 --> 00:03:41.680
I based the code on
the OS 9 architecture,

00:03:41.730 --> 00:03:44.400
basically took all the source
code over to 10 and converted

00:03:44.400 --> 00:03:49.570
it to fit into I/O Kit,
converted it to C++, which made a lot of

00:03:49.660 --> 00:03:51.800
things much easier for me.

00:03:53.510 --> 00:03:57.280
In DP4,
it's implemented as a set of kernel

00:03:57.930 --> 00:04:02.930
extensions that are loaded up when a
driver needs the FireWire services.

00:04:04.370 --> 00:04:10.690
There's three main kernel
extensions for FireWire in DP4.

00:04:11.670 --> 00:04:15.020
is the IO FireWire family .txt.

00:04:15.060 --> 00:04:17.780
This is the core of FireWire.

00:04:17.930 --> 00:04:25.100
It's the code that provides all
the basic services for FireWire,

00:04:25.100 --> 00:04:25.100
hardware independent for everything.

00:04:25.430 --> 00:04:30.430
Then we have two drivers for the
two different types of FireWire

00:04:30.430 --> 00:04:34.890
controller chip that we've used
at Apple in our various computers.

00:04:35.910 --> 00:04:41.390
AppleLynx.txt is the driver
for the Texas Instruments

00:04:41.390 --> 00:04:43.160
PCI Lynx controller chip.

00:04:44.000 --> 00:04:49.520
That's the controller chip that's
used in the blue and white G3,

00:04:49.520 --> 00:04:55.720
and also in the
PCI Apple card that we also,

00:04:55.800 --> 00:04:56.730
I think, still sell.

00:04:56.780 --> 00:05:00.110
Kind of obsolete, but still available,
I think.

00:05:01.100 --> 00:05:11.980
Finally, Apple FW-OHCI is the driver
for the OHCI FireWire standard.

00:05:11.980 --> 00:05:15.500
All our current machines
that have FireWire built in,

00:05:15.590 --> 00:05:21.100
they're all using versions
of this open standard.

00:05:21.100 --> 00:05:25.410
So this driver is for
all the current machines.

00:05:28.840 --> 00:05:33.800
Okay, so what's in DP4?

00:05:33.830 --> 00:05:37.950
Driver matching and loading is
all done now for FireWire devices.

00:05:38.040 --> 00:05:42.250
So if you have a driver for your device,
and you've written it correctly,

00:05:42.320 --> 00:05:44.710
which you probably don't
know how to do yet,

00:05:44.710 --> 00:05:47.350
but I hope you'll be
figuring it out soon,

00:05:47.500 --> 00:05:51.070
DP4 can load drivers
for the right devices,

00:05:51.080 --> 00:05:52.990
get them running.

00:05:53.330 --> 00:05:58.910
The core services for FireWire
are pretty nearly complete.

00:05:59.000 --> 00:06:02.200
You can do most of the things
you need to do with FireWire,

00:06:02.200 --> 00:06:05.200
of sending packets, receiving packets,
allocating address spaces,

00:06:05.490 --> 00:06:11.650
looking at what devices are on the bus,
finding out how fast things are,

00:06:11.650 --> 00:06:13.930
what the bus topology is,
all that kind of useful

00:06:13.930 --> 00:06:13.930
stuff that you need to do.

00:06:15.590 --> 00:06:19.260
The Apple Lynx driver is complete.

00:06:19.350 --> 00:06:22.860
It handles everything that
I believe it needs to handle.

00:06:22.880 --> 00:06:27.160
It's probably got some bugs,
but we'll sort those out.

00:06:27.230 --> 00:06:33.380
The OXCI controller is not so far along.

00:06:33.380 --> 00:06:36.090
We'll start on it a bit later.

00:06:36.100 --> 00:06:39.370
It's newer machines.

00:06:40.570 --> 00:06:44.730
The asynchronous packet
handling is all complete,

00:06:45.060 --> 00:06:49.150
but the isochronous packet
handling isn't done yet,

00:06:49.400 --> 00:06:56.440
which means you can't do DV development,
for example, using an OXCI controller.

00:06:56.550 --> 00:07:02.510
So you need to get a Lynx card, perhaps,
for doing that.

00:07:04.180 --> 00:07:10.460
We also threw in a prototype
FireWire disk driver that we wrote

00:07:10.540 --> 00:07:14.370
to make sure that the core services
have all been the right thing,

00:07:14.530 --> 00:07:18.840
and so we had all the interaction
with I/O Kit and the file system

00:07:18.950 --> 00:07:22.010
all sorted out and done correctly.

00:07:23.070 --> 00:07:28.410
We're not quite sure whether
we should be shipping a generic

00:07:29.020 --> 00:07:32.000
disk driver in the future.

00:07:32.000 --> 00:07:35.450
We put in for DP4 because, well,
we didn't have any other drivers,

00:07:35.550 --> 00:07:37.150
so it was a good one to have.

00:07:37.310 --> 00:07:42.230
So if you have opinions about that,
perhaps you can give feedback to

00:07:42.230 --> 00:07:49.840
jai@firewire@apple.com whether we should
have a drive-- a driver or just do what

00:07:50.000 --> 00:07:56.370
we did in OS 9 of leaving the driver for
each disk manufacturer to do themselves

00:07:56.370 --> 00:07:58.780
based on code we provided them.

00:08:01.620 --> 00:08:06.490
The last thing in DP4 is, well,
not in DP4.

00:08:06.490 --> 00:08:12.820
We don't have any documentation yet
written for FireWire in DP4 for 10.

00:08:12.820 --> 00:08:16.990
We don't even have very good
header documentation yet.

00:08:16.990 --> 00:08:24.410
So that's kind of something that,
bear in mind, again,

00:08:24.940 --> 00:08:30.460
Sign up for Darwin, get the source,
and you can figure out what we're doing.

00:08:34.790 --> 00:08:39.660
For the public beta, of course,
we'll be adding most of the

00:08:40.010 --> 00:08:44.550
things that you'd expect for
a complete implementation.

00:08:45.900 --> 00:08:52.900
We'll be splitting apart the disk
driver we wrote into the SBP-2 services

00:08:52.900 --> 00:08:57.980
that's generic for all SBP devices
and a separate hard disk driver,

00:08:57.980 --> 00:09:01.900
or we'll leave it out completely
depending on how we decide to do that.

00:09:01.900 --> 00:09:08.010
Again, that's something that OS 9 has,
you have separate SBP-2 services for

00:09:08.100 --> 00:09:11.370
all the devices that use that standard.

00:09:12.700 --> 00:09:20.840
We also have to add the FCP services
that are used by DV camcorders and MLan,

00:09:20.840 --> 00:09:24.210
that kind of stuff.

00:09:25.150 --> 00:09:28.530
will be, of course,
providing a DV driver,

00:09:28.860 --> 00:09:31.430
just as we do in Mac OS 9.

00:09:31.900 --> 00:09:37.550
and also protocol driver support.

00:09:38.490 --> 00:09:41.710
When I first started working on FireWire,
I wasn't quite sure what

00:09:41.810 --> 00:09:44.270
protocol drivers were.

00:09:44.850 --> 00:09:48.380
So I didn't implement them at first.

00:09:48.410 --> 00:09:49.870
But they're pretty neat.

00:09:50.040 --> 00:09:53.940
The thing you have to remember about
FireWire is that FireWire is a bus.

00:09:53.940 --> 00:09:55.580
It's peer-to-peer.

00:09:55.580 --> 00:09:57.880
You can connect several
Macintoshes together,

00:09:57.900 --> 00:09:59.800
and they can talk to each other.

00:10:00.000 --> 00:10:05.240
Protocol driver is a way of setting
things up so each Mac knows what services

00:10:05.240 --> 00:10:10.580
other Macs are providing because they've
had a driver loaded to match and talk to.

00:10:11.680 --> 00:10:18.740
I'm also going to be improving the,
I should really say, config ROM services.

00:10:18.760 --> 00:10:22.870
I left them as CSR because
that's what they're called

00:10:22.980 --> 00:10:25.060
in the current source code.

00:10:25.060 --> 00:10:29.080
Services to read the
configuration ROM from a device,

00:10:29.480 --> 00:10:33.640
services to add stuff to the
Macintosh config ROM for other

00:10:33.640 --> 00:10:38.280
devices to read so that they know
what services the Mac can do for them.

00:10:39.740 --> 00:10:44.600
We'll also be adding booting
from FireWire disk drives.

00:10:44.600 --> 00:10:47.840
That's one of the
things that isn't in 10.

00:10:48.040 --> 00:10:50.590
We have a disk driver,
but we can't boot from it.

00:10:50.600 --> 00:10:53.860
And we'll do an SDK.

00:10:53.940 --> 00:10:57.190
We'll document it.

00:10:57.190 --> 00:10:57.190
Honest.

00:10:59.820 --> 00:11:09.040
Looking a bit beyond the public beta,
timeline getting a bit vaguer now,

00:11:09.040 --> 00:11:09.040
we want to

00:11:10.430 --> 00:11:16.500
provide AVC services in the
same way that we do for SBP-2,

00:11:16.570 --> 00:11:18.840
because in the past,
there have only been camcorders

00:11:18.960 --> 00:11:23.600
that needed the AVC protocol.

00:11:23.610 --> 00:11:25.270
In the future,

00:11:25.520 --> 00:11:29.140
Camcorders again still,
but also MLan audio

00:11:29.140 --> 00:11:32.060
devices and AV hard disks.

00:11:32.400 --> 00:11:35.440
Now all those three
different kind of devices,

00:11:35.440 --> 00:11:40.860
they all are based on the AVC standards,
so we want to provide services

00:11:40.970 --> 00:11:45.110
to do that that you can then
build on with other devices.

00:11:46.530 --> 00:11:48.740
We're going to provide MLan support,
of course.

00:11:48.740 --> 00:11:54.170
If you saw Will's demo yesterday,
that looks pretty exciting.

00:11:55.090 --> 00:11:59.940
That huge bandwidth available for audio,
hundreds of channels, the pro guys,

00:12:00.010 --> 00:12:01.750
and it's just great for them,
and it's also going to be

00:12:01.750 --> 00:12:05.290
nice for home theater stuff.

00:12:05.370 --> 00:12:06.650
Just less cables.

00:12:06.650 --> 00:12:07.580
It's great.

00:12:10.480 --> 00:12:14.290
Power Management also is not
in DB4 and probably won't be

00:12:15.280 --> 00:12:17.400
in the public beta either.

00:12:17.650 --> 00:12:20.490
Really,
that's most important for PowerBooks,

00:12:20.530 --> 00:12:22.400
but we like to control
power on all our machines.

00:12:22.400 --> 00:12:31.390
So, where does FireWire drivers fit into
the whole big picture of Mac OS X?

00:12:31.670 --> 00:12:33.960
Well,
there's just a little tiny box down in

00:12:33.960 --> 00:12:37.480
the bottom corner underneath I/O Kit.

00:12:39.050 --> 00:12:44.110
You notice that there's a dotted
line that goes across and then up?

00:12:44.590 --> 00:12:49.640
Separating the Mac kernel and
I/O Kit from the rest of the kernel.

00:12:49.660 --> 00:12:53.710
That little right-hand side, kind of,
up the side,

00:12:54.830 --> 00:13:00.280
implies that an iRakit
driver can actually get,

00:13:00.310 --> 00:13:04.840
provide services straight to applications
without having to go through BSD or

00:13:04.840 --> 00:13:08.200
networking or the file system,
if that makes sense for

00:13:08.200 --> 00:13:10.850
your kind of device,
which is often the case

00:13:11.180 --> 00:13:17.320
for FireWire devices,
because a lot of the really fun stuff,

00:13:17.320 --> 00:13:21.290
camcorders again, cameras,
MLan and so on,

00:13:21.290 --> 00:13:21.290
are the kind of things that

00:13:22.460 --> 00:13:25.390
and the good old-fashioned Unix
isn't really terribly interested in,

00:13:25.390 --> 00:13:28.300
and the kernel just doesn't
want to need to know about it.

00:13:28.340 --> 00:13:30.930
We're going to put that
up into the applications.

00:13:34.800 --> 00:13:41.030
So what I want to go through
here is show you how iLokit

00:13:41.380 --> 00:13:45.190
goes through the process of

00:13:45.820 --> 00:13:50.980
Getting a driver running when your
device is connected to the Mac.

00:13:53.200 --> 00:13:58.550
Initially, when the machine starts up,
I/O Kit will look through all the

00:13:58.550 --> 00:14:04.520
hardware that's on the Mac motherboard,
and it'll find a FireWire

00:14:04.810 --> 00:14:07.750
controller of some kind.

00:14:07.750 --> 00:14:07.750
It'll either be

00:14:07.960 --> 00:14:13.120
The Apple Lynx, I mean sorry,
the Lynx PCI controller or the,

00:14:13.140 --> 00:14:16.400
one of many OHCI controllers.

00:14:16.420 --> 00:14:24.790
So the IOC matching system will then load
either Apple Lynx or OHCI as appropriate.

00:14:26.280 --> 00:14:32.200
Apple Links and OHCI are subclasses
of IO FireWire Controller,

00:14:32.200 --> 00:14:38.200
which, remember, is the core of the
FireWire services system.

00:14:38.230 --> 00:14:42.540
That itself is subclassed
from IO FireWire Bus,

00:14:42.580 --> 00:14:47.570
which is a very abstract
view of FireWire.

00:14:49.880 --> 00:14:53.040
So, first thing that happens,
you plug your device in.

00:14:53.100 --> 00:14:54.640
That will cause a bus reset.

00:14:54.690 --> 00:14:59.640
We'll go and scan the bus,
find that there's a device now.

00:15:00.580 --> 00:15:02.470
And,

00:15:02.920 --> 00:15:08.500
We, the iCube,
then creates a standard object for

00:15:08.920 --> 00:15:12.990
communicating with FireWire devices,
which we call our FireWire device.

00:15:13.100 --> 00:15:14.400
Pretty logical.

00:15:14.400 --> 00:15:19.860
It, in turn,
will then look at the device,

00:15:19.860 --> 00:15:26.800
read its config ROM, and see what unit
directories are in the ROM.

00:15:26.800 --> 00:15:32.570
The unit directories are where FireWire
devices will be storing information

00:15:32.730 --> 00:15:35.800
on what kind of device it is,
who makes it,

00:15:35.800 --> 00:15:42.790
all the information that you need.

00:15:44.200 --> 00:16:01.400
[Transcript missing]

00:16:02.700 --> 00:16:06.180
Now things get a bit more interesting.

00:16:06.190 --> 00:16:09.800
The IOK matching system now looks at--

00:16:10.260 --> 00:16:16.790
The entries in the unit directory
figure out what kind of unit it is.

00:16:16.800 --> 00:16:21.700
And with a bit of luck,
it's a device that a

00:16:21.700 --> 00:16:25.390
driver's been installed for,
and at that point,

00:16:25.570 --> 00:16:30.780
We'll load up your driver,
attach it to the FireWire unit,

00:16:30.780 --> 00:16:37.910
and then your driver can start running,
talk to the device, and start its thing.

00:16:39.980 --> 00:16:46.710
For example, if it was a hard disk,
your driver would then have to

00:16:47.530 --> 00:16:53.040
tell the I/O Kit file system
services that it's a hard disk,

00:16:53.060 --> 00:16:59.160
it's got partitions and so on,
and the file system will

00:16:59.160 --> 00:16:59.160
then take up to it and start

00:16:59.470 --> 00:17:02.160
and the reading and writing sectors.

00:17:02.180 --> 00:17:04.620
I'm not going to go into
much detail about how a file

00:17:04.670 --> 00:17:06.400
system side of I/O Kit works.

00:17:06.530 --> 00:17:11.680
There's a session tomorrow that will
really go into that in great detail.

00:17:14.070 --> 00:17:17.060
To plug another device in, of course,
we create another FireWire device

00:17:17.060 --> 00:17:19.310
object to represent that one.

00:17:20.770 --> 00:17:24.170
Now, again,
we look at unit directories and

00:17:24.170 --> 00:17:29.200
create a FireWire unit object
for each directory we find.

00:17:29.290 --> 00:17:32.100
Perhaps we find two unit
directories because it's some

00:17:32.180 --> 00:17:34.550
kind of multi-functional device.

00:17:34.670 --> 00:17:40.560
We couldn't actually think of an
example of one except for a Macintosh.

00:17:40.630 --> 00:17:45.600
A Macintosh, which had several
protocol drivers loaded,

00:17:45.600 --> 00:17:49.500
perhaps an MLan driver,
maybe an IP driver,

00:17:49.570 --> 00:17:52.780
then it would have a unit directory
for each of those protocol drivers,

00:17:52.780 --> 00:17:57.930
and other Macs on the bus,
beating that Mac's ROM,

00:17:57.930 --> 00:18:03.570
would create a unit object for each of
those units so that the right device

00:18:03.570 --> 00:18:06.130
driver can be matched up with each unit.

00:18:06.480 --> 00:18:08.880
I put one in gray, or dim,
because we're going to

00:18:08.880 --> 00:18:12.600
concentrate on one side.

00:18:13.070 --> 00:18:16.760
The appropriate unit driver is found,
loaded, starts running.

00:18:16.810 --> 00:18:23.920
I suppose this is a device that doesn't
communicate with the rest of the kernel.

00:18:24.000 --> 00:18:27.920
Perhaps it's a camcorder, it's a scanner,
it's a printer.

00:18:28.000 --> 00:18:33.120
Something that applications,
right at the top, really want to talk to,

00:18:33.120 --> 00:18:35.840
but the rest of the kernel
doesn't want to talk to.

00:18:36.890 --> 00:18:42.380
IOCit provides services for applications
outside the kernel to get notified of

00:18:43.540 --> 00:18:48.800
kinds of devices that they're interested
in appearing inside the kernel.

00:18:48.900 --> 00:18:51.640
And when they see that,

00:18:51.850 --> 00:18:58.410
They can then go and find
a Core Foundation plugin to

00:18:58.800 --> 00:19:02.140
represent that device outside the kernel.

00:19:02.210 --> 00:19:05.480
The plugin then has to

00:19:05.740 --> 00:19:10.460
asked the unit driver inside the kernel
to create what we call a user client,

00:19:10.490 --> 00:19:16.730
which is an in-kernel object that
provides services to get across

00:19:16.730 --> 00:19:22.740
the kernel boundary between the
plugin outside the kernel and the

00:19:22.820 --> 00:19:24.790
unit driver inside the kernel.

00:19:28.430 --> 00:19:33.150
So I've just highlighted the
pieces that you would need to

00:19:33.250 --> 00:19:37.120
write for two kinds of devices.

00:19:38.480 --> 00:19:42.490
On the right, something like a hard disk.

00:19:42.550 --> 00:19:44.780
It's pretty straightforward.

00:19:44.810 --> 00:19:48.220
You write a device
driver inside the kernel,

00:19:48.260 --> 00:19:49.880
gets loaded.

00:19:49.910 --> 00:19:51.720
It talks to the file system.

00:19:51.730 --> 00:19:54.780
And essentially,
you have one object to worry about.

00:19:55.810 --> 00:20:00.960
If you're doing a device
that-- for a device that you'd

00:20:00.960 --> 00:20:03.790
like to provide direct access,

00:20:04.210 --> 00:20:06.600
to applications outside the kernel.

00:20:06.610 --> 00:20:11.650
As things stand in DP4,
you need to do a little bit more work.

00:20:12.010 --> 00:20:15.340
You need to write your--
in kernel device driver,

00:20:15.490 --> 00:20:19.820
you also need to write a piece
of extra code to the user client

00:20:20.420 --> 00:20:23.640
to cross the kernel boundary.

00:20:23.660 --> 00:20:31.540
And you almost certainly want to write
a core foundation plug-in outside the

00:20:31.700 --> 00:20:34.290
kernel for any application that wants
to talk to your device to go through.

00:20:34.770 --> 00:20:38.840
Probably shouldn't directly,
you could directly from the application

00:20:38.950 --> 00:20:42.870
go to the user client inside the kernel,
but it's architecturally almost

00:20:42.960 --> 00:20:46.350
certainly going to be better for
you and for everybody to have a

00:20:46.350 --> 00:20:51.460
plug-in to your device rather than
building things into applications.

00:20:54.360 --> 00:20:59.850
One thing that we hope to
do for the public beta that

00:20:59.850 --> 00:21:02.290
I didn't mention was make

00:21:03.080 --> 00:21:09.560
This left-hand side three-stage thing
a little easier by providing our own

00:21:09.590 --> 00:21:16.060
unit driver and user client inside the
kernel that you can plug in to say,

00:21:16.060 --> 00:21:17.400
I want the standard one.

00:21:17.400 --> 00:21:18.540
I don't do anything.

00:21:18.540 --> 00:21:22.660
I don't need any special
high-performance communication.

00:21:22.660 --> 00:21:27.500
I can stick with the servers we provide,
which should be pretty fast anyway.

00:21:28.690 --> 00:21:31.860
I think I'll certainly
be fine for scanners,

00:21:31.860 --> 00:21:35.760
printers, probably MLan devices as well,
maybe.

00:21:38.000 --> 00:21:44.940
Okay, so as I mentioned earlier,
the FireWire controller is the

00:21:44.940 --> 00:21:47.080
heart of the FireWire family.

00:21:47.380 --> 00:21:53.800
It does most of the hardware-independent
work that needs to be done to

00:21:53.800 --> 00:21:56.540
get FireWire up and running,
get your devices going,

00:21:56.540 --> 00:21:59.300
be able to talk to your devices,
know which devices you have,

00:21:59.340 --> 00:22:01.310
which other devices there are.

00:22:01.600 --> 00:22:03.360
bus management.

00:22:03.360 --> 00:22:06.200
It does address space
management inside the Mac.

00:22:06.200 --> 00:22:09.910
That's where you have-- you want to--

00:22:10.080 --> 00:22:14.300
have FireWire addresses inside
the Mac that your device

00:22:14.460 --> 00:22:19.270
can talk to to send status,
that kind of thing.

00:22:19.900 --> 00:22:24.090
Of course,
FireWire Controller provides methods

00:22:24.360 --> 00:22:30.390
for transmitting and receiving packets,
both asynchronous and isochronous.

00:22:31.760 --> 00:22:37.070
If you're writing a protocol
driver where you're making the

00:22:37.130 --> 00:22:41.630
Mac perform a service for people,
other devices on the bus,

00:22:42.530 --> 00:22:48.330
then your protocol driver will
match the FireWire controller,

00:22:48.500 --> 00:22:53.820
because that's what provides the
services it needs to change the,

00:22:53.820 --> 00:22:59.180
update the Macintosh ROM and
allocate address space.

00:23:00.290 --> 00:23:05.900
As I mentioned earlier,
Apple Links and IAFW-OHCI,

00:23:05.920 --> 00:23:09.740
they're the hardware drivers that
access the Macintosh hardware.

00:23:10.010 --> 00:23:15.680
They're subclasses of IAFW-FireWire
controller that implement the actual

00:23:16.020 --> 00:23:19.230
hardware, register bashing
necessary to send packets,

00:23:19.230 --> 00:23:21.890
receive transmit packets,
handle interrupts,

00:23:21.890 --> 00:23:24.600
all that hardware stuff.

00:23:28.290 --> 00:23:32.640
I have a FireWire device,
one per device on the bus.

00:23:32.700 --> 00:23:41.150
This is the object that handles some of
the fiddly bits about FireWire that you

00:23:41.150 --> 00:23:43.930
really don't want to have to bother with.

00:23:44.050 --> 00:23:47.400
It tracks the node ID of your
device with the bus reset,

00:23:47.450 --> 00:23:51.750
and node IDs of devices can change.

00:23:52.100 --> 00:23:54.200
But you still have the same
FireWire device to talk to.

00:23:54.430 --> 00:23:56.930
It'll just internally know that its
node ID has changed when it sends

00:23:56.930 --> 00:23:59.420
and receives packets over the bus.

00:24:00.580 --> 00:24:06.940
For matching a FireWire device,
if your device driver wants to do that,

00:24:06.940 --> 00:24:10.500
we only provide two very
basic pieces of information.

00:24:10.500 --> 00:24:14.460
The vendor ID of the device,
and the GUID,

00:24:14.710 --> 00:24:17.840
the globally unique ID of the device.

00:24:18.930 --> 00:24:25.170
Neither of those really are terribly
useful for matching their either,

00:24:25.170 --> 00:24:26.400
rather general, vendor ID.

00:24:26.400 --> 00:24:30.200
I mean, every device you make,
whatever kind it is,

00:24:30.330 --> 00:24:31.230
can have the same vendor ID.

00:24:31.400 --> 00:24:33.400
Or it's incredibly specific.

00:24:33.500 --> 00:24:37.400
GUID is going to be a driver for that
one device in the entire universe,

00:24:37.400 --> 00:24:42.960
which probably isn't terribly useful.

00:24:43.790 --> 00:24:44.820
There could be uses.

00:24:44.890 --> 00:24:50.820
There was a question in Eric and
Jai's presentation yesterday where

00:24:50.820 --> 00:24:55.040
someone was asking about having
10 Mac installers networked,

00:24:55.140 --> 00:24:59.440
next together with FireWire,
and he had a FireWire hard disk that

00:24:59.440 --> 00:25:02.380
he wanted to only mount on one Mac.

00:25:02.750 --> 00:25:06.780
Now, one way of doing that,
at least in OS X,

00:25:06.860 --> 00:25:12.860
might be to use the GUID of the
disk drive and have a driver that

00:25:13.130 --> 00:25:15.860
only matches that one disk drive,
and have that driver only

00:25:15.860 --> 00:25:17.700
on one of the Macintoshes.

00:25:17.720 --> 00:25:22.100
The others won't match the drive
because it's got the wrong GUID.

00:25:22.140 --> 00:25:24.970
The Mac that you want to
use the drive will match it

00:25:24.970 --> 00:25:26.890
because it has the right GUID.

00:25:28.140 --> 00:25:30.840
But that's pretty esoteric, really.

00:25:30.850 --> 00:25:37.910
The main job of a FireWire device
object is to look at the device's ROM,

00:25:38.770 --> 00:25:44.520
Pick out all unit directories and
create and publish IO FireWire units.

00:25:44.590 --> 00:25:51.940
Feature those unit directories
for your own drivers to match on.

00:25:55.670 --> 00:26:01.660
FireWire, I/O FireWire unit,
said one unit directory and a device ROM.

00:26:01.820 --> 00:26:05.380
Typically, there will only be one unit
directory and a device ROM,

00:26:05.600 --> 00:26:09.290
but the spec allows for more,
and we allow for more.

00:26:11.200 --> 00:26:16.330
For FireWire Unit,
we provide much more useful matching.

00:26:16.360 --> 00:26:21.340
A driver can match on the unit spec ID,
unit software version,

00:26:21.380 --> 00:26:26.000
and also the render ID and GUID,
which we've brought up

00:26:26.340 --> 00:26:28.180
from the FireWire device.

00:26:29.590 --> 00:26:39.460
is the provider for most
FireWire drivers for devices,

00:26:39.500 --> 00:26:42.710
since it has the information
on what kind of protocol,

00:26:42.710 --> 00:26:46.900
the unit spec ID and software
version that the device can handle.

00:26:49.130 --> 00:26:54.320
FireWire device and FireWire unit really
are only different in how they are,

00:26:54.390 --> 00:26:59.200
where they fit in the IOC hierarchy
and in the matching information.

00:26:59.290 --> 00:27:06.160
They both derive from I/O FireWire Nub,
which provides methods for all the

00:27:06.160 --> 00:27:13.890
things you want to do with the device,
of sending packets to it,

00:27:13.890 --> 00:27:13.890
receive packets from it.

00:27:17.720 --> 00:27:25.070
So in Iocat,
we have what's essentially like

00:27:25.200 --> 00:27:30.370
the name registry in Mac OS 9,
but a lot more sophisticated.

00:27:32.100 --> 00:27:37.530
and I had fun taking advantage
of that for FireWire.

00:27:37.840 --> 00:27:45.490
The main IOCit service plane, we call it,
is the part of the IOCit registry

00:27:45.800 --> 00:27:47.780
which is used for matching.

00:27:48.800 --> 00:27:53.670
So all the objects that I create
that can be involved in matching are

00:27:53.670 --> 00:27:58.170
in that part of the HiKit registry.

00:27:58.590 --> 00:28:01.260
for the matching functions
of I/O Kit to work on.

00:28:01.330 --> 00:28:06.020
So those are I/O FireWire
controller for protocol drivers,

00:28:06.080 --> 00:28:10.200
I/O FireWire device,
perhaps for a specific device drivers,

00:28:10.240 --> 00:28:15.970
I/O FireWire unit for
most device drivers.

00:28:17.810 --> 00:28:21.820
I also implemented a second
plane in the registry,

00:28:21.820 --> 00:28:30.590
which I use to keep track of the
bus topology of FireWire Bus.

00:28:30.650 --> 00:28:33.220
In other words,
which device is connected to which

00:28:33.220 --> 00:28:36.550
other device physically by the cable.

00:28:36.730 --> 00:28:41.500
Which is useful for figuring out what
speed you can send to if there's a

00:28:41.620 --> 00:28:43.240
slow device between two fast devices.

00:28:43.240 --> 00:28:48.680
Then the FireWire plane might be a
way to check if that's happening and

00:28:48.680 --> 00:28:51.190
maybe alert the user if you want to.

00:28:52.470 --> 00:28:59.500
Since this is only intended to represent
the topology of the network and not the

00:28:59.900 --> 00:29:11.400
[Transcript missing]

00:29:12.840 --> 00:29:16.420
FireWire device essentially,
or the Mac OS itself,

00:29:16.420 --> 00:29:21.520
and all the other devices that
have been found on the bus.

00:29:24.450 --> 00:29:31.040
Okay, now I'd like to show you the
registry in OS X in action.

00:29:31.070 --> 00:29:33.030
First, I'm going to bring

00:29:35.170 --> 00:29:42.580
A very useful application that we have
in DP4 called the IR Registry Explorer.

00:29:42.630 --> 00:29:47.190
It's a very simple application that
shows you what's in the registry.

00:29:53.990 --> 00:29:57.140
When it starts up,
it starts up showing the service plane.

00:29:57.180 --> 00:30:00.610
I'm going to switch the plane--

00:30:00.810 --> 00:30:06.130
I'm going to display
to the FireWire plane.

00:30:10.190 --> 00:30:14.100
So that we can see what the
bus looks like right now.

00:30:14.110 --> 00:30:19.500
Now, there's nothing connected
to the Mac right now.

00:30:19.850 --> 00:30:22.700
On the front side,
we see what's available.

00:30:22.730 --> 00:30:30.100
There's the Apple FireWire OCI object,
the Mac's own internal hardware.

00:30:30.610 --> 00:30:34.720
And then there's four other
objects in the registry whose

00:30:34.830 --> 00:30:35.970
purpose I really don't know.

00:30:36.000 --> 00:30:40.290
They're always there in each plane.

00:30:41.550 --> 00:30:45.650
The OHCI driver,
you see we have a whole bunch of

00:30:45.730 --> 00:30:47.940
properties being displayed down here.

00:30:47.940 --> 00:30:52.910
I'll just move this so you can
see a bit better what's going on.

00:30:53.750 --> 00:30:59.130
We have the node ID of the Macintosh.

00:31:01.320 --> 00:31:02.820
tells us it's a number.

00:31:02.820 --> 00:31:07.030
This application is built with Cocoa,
and it was done-- well,

00:31:07.130 --> 00:31:10.070
it's very simple application.

00:31:10.440 --> 00:31:14.080
One of the things that we didn't
do was show numbers as hex,

00:31:14.110 --> 00:31:16.960
which probably makes some
things a little clearer.

00:31:17.020 --> 00:31:20.650
We just showed normal
decimal representation.

00:31:21.680 --> 00:31:28.480
I also keep in the registry for people
to look at the self-ID packets that that

00:31:28.500 --> 00:31:33.940
node sent out at the last bus reset,
which you can use to perhaps

00:31:34.190 --> 00:31:38.100
look at the speed of the device.

00:31:39.400 --> 00:31:43.400
have the ROM of the device.

00:31:43.400 --> 00:31:46.400
The ROM in this case, of course,
is the Macintosh.

00:31:49.360 --> 00:31:54.500
have here some showing a
bit of the I/O Kit matching.

00:31:54.600 --> 00:31:58.740
Since the OHCI controller
is a PCI device,

00:31:58.750 --> 00:32:02.460
its provider class,
the thing that it talks to,

00:32:02.550 --> 00:32:06.490
to talk with hardware, is I/O PCI device.

00:32:06.540 --> 00:32:08.920
That's probably kind
of what you'd expect.

00:32:08.960 --> 00:32:18.360
Here I see I've matched
on PCI class of 0010,

00:32:18.360 --> 00:32:22.510
which I guess is the right
thing for an OHCI writer.

00:32:23.400 --> 00:32:29.320
More information about what kernel
extension this driver is loaded from.

00:32:29.380 --> 00:32:36.320
Loaded from the Apple FW-OHCI extension.

00:32:40.550 --> 00:32:42.290
More matching information.

00:32:42.390 --> 00:32:46.620
There's a lot of stuff here for
seeing how your device got matched.

00:32:50.000 --> 00:32:50.940
is a good one to check.

00:32:50.940 --> 00:32:56.610
The class of the object
is what we expect.

00:33:00.160 --> 00:33:06.340
Now, when I plug the device in,
we're going to go and look and try

00:33:06.340 --> 00:33:11.320
and find the right driver for this.

00:33:11.350 --> 00:33:14.940
I'm just going to briefly show you

00:33:23.370 --> 00:33:30.260
This is the XML file being
displayed by the XML browser for

00:33:30.260 --> 00:33:34.910
our prototype SBP-2 disk driver.

00:33:37.410 --> 00:33:44.430
As a root property,
the date when we last worked on it.

00:33:46.810 --> 00:33:54.450
The module that it is,
it's a-- this is the file it lives in.

00:33:57.020 --> 00:33:58.500
Mac O binary.

00:33:58.520 --> 00:34:03.530
All executables loaded into
the kernel have to be Mac O.

00:34:03.900 --> 00:34:07.040
We don't support CFM inside the kernel.

00:34:12.060 --> 00:34:19.640
Here, the driver is specifying that it
needs the FireWire services to run.

00:34:19.820 --> 00:34:24.800
Me just got a backwards
URL to keep names unique.

00:34:24.800 --> 00:34:28.850
com.apple.iFiWireFamily.

00:34:28.850 --> 00:34:32.400
The driver wants to
use the iFiWire family.

00:34:36.360 --> 00:34:39.840
Finally, the personality of the driver.

00:34:39.880 --> 00:34:45.000
This is the real matching information
used to load the correct driver.

00:34:45.650 --> 00:34:51.990
specifies what class should be created
when this device is detected on the bus.

00:34:52.120 --> 00:34:54.980
IOFW SBP-2 HD drive.

00:34:55.000 --> 00:34:57.470
It's a SBP-2 hard disk drive.

00:34:59.200 --> 00:35:08.100
IO Imports specifies what kind of object
the driver needs to directly talk to.

00:35:08.350 --> 00:35:13.100
It needs to talk to the
FireWire unit to communicate.

00:35:13.290 --> 00:35:15.700
You have a score for matching,
so if you have several

00:35:15.850 --> 00:35:19.260
drivers that all match,
use a probe score.

00:35:19.260 --> 00:35:21.650
The driver with the highest
probe score will be the one

00:35:21.650 --> 00:35:23.150
that will get loaded and used.

00:35:25.850 --> 00:35:29.580
Finally,
the two pieces of information that

00:35:29.670 --> 00:35:33.360
we're going to use for matching for
this driver are the unit spec ID from

00:35:33.360 --> 00:35:39.640
the unit directory and the unit software
version from the unit directory.

00:35:39.640 --> 00:35:41.530
OK, so close that down.

00:35:41.560 --> 00:35:48.060
Plug it in.

00:36:05.530 --> 00:36:07.120
This dialog pops up.

00:36:07.510 --> 00:36:11.600
It's been popped up by the
Registry Explorer application.

00:36:11.600 --> 00:36:13.710
You wouldn't normally see it.

00:36:13.930 --> 00:36:17.980
What Registry Explorer application
is doing is it's asked I/O Kit to

00:36:18.050 --> 00:36:20.900
tell it any time anything
changes in the I/O Kit registry.

00:36:20.960 --> 00:36:24.790
And when it does,
it asks me if I want to see this update.

00:36:25.030 --> 00:36:28.100
Sure, I want to see what's changed.

00:36:34.050 --> 00:36:41.020
Now, we're still looking at the
FireWire registry plane.

00:36:41.050 --> 00:36:45.210
We now have I/O FireWire
devices as the root of the bus.

00:36:45.460 --> 00:36:48.270
So this guy is being the root now.

00:36:49.470 --> 00:36:51.940
The little arrow on the right
shows that we can Nib over

00:36:51.940 --> 00:36:54.710
and see what's connected to.

00:36:54.850 --> 00:36:57.240
These drivers have an
interesting feature.

00:36:57.290 --> 00:37:01.770
They actually have a second
PHY inside them for some reason.

00:37:02.060 --> 00:37:05.600
that doesn't have a link,
doesn't have a ROM I can read.

00:37:05.730 --> 00:37:09.140
So I represent that simply
by a IR registry entry,

00:37:09.190 --> 00:37:12.230
and I just show what little
information I have on that.

00:37:14.170 --> 00:37:18.850
which is the PHY information, node ID,
and the speed of the device,

00:37:18.970 --> 00:37:20.940
and the self ID packet.

00:37:21.000 --> 00:37:29.000
[Transcript missing]

00:37:31.110 --> 00:37:33.450
That's the finder,
and you can see the drive got mounted.

00:37:33.570 --> 00:37:34.780
Pretty encouraging.

00:37:34.780 --> 00:37:49.910
And if I switch to the service plane,
track down to

00:37:54.710 --> 00:38:04.740
The Service Plane Apple FWHCI will
always be the first thing in the

00:38:04.740 --> 00:38:04.740
FireWire plane because it provides
services to everybody else.

00:38:05.270 --> 00:38:08.790
Connected to it in the service
plane is the FireWire device

00:38:09.230 --> 00:38:11.440
representing this drive.

00:38:11.520 --> 00:38:14.380
FireWire device has created a
FireWire unit for the one unit

00:38:14.440 --> 00:38:16.780
directory inside the device.

00:38:18.080 --> 00:38:23.690
IOCit has looked at the Unispec ID,
Unisoftware version,

00:38:24.430 --> 00:38:28.000
Can I look to the extensions
and go to what we wanted,

00:38:28.040 --> 00:38:34.280
the HD drive driver,
this driver for this guy.

00:38:34.660 --> 00:38:38.360
who's then done the work of
connecting up to the file system.

00:38:38.390 --> 00:38:43.140
In this case, that means creating this
little drive knob object,

00:38:43.190 --> 00:38:47.420
then a IOHC drive object,
then we have a media object,

00:38:47.420 --> 00:38:53.060
this kind of goes on for a long time,
partition schemes, couple of partitions,

00:38:53.120 --> 00:38:55.590
so you've got two
partitions on this drive.

00:38:56.650 --> 00:39:00.100
There's a lot of objects
for the file system.

00:39:00.150 --> 00:39:04.480
Again, if you need to know about stuff,
there's a talk tomorrow on that.

00:39:04.540 --> 00:39:13.840
Finally, let's dismount the disk.

00:39:18.020 --> 00:39:21.220
Again, the average application is saying,
hey, things have changed.

00:39:21.240 --> 00:39:28.110
And now if I--

00:39:29.340 --> 00:39:33.060
Nib back down to FireWire again.

00:39:33.090 --> 00:39:33.810
Drivers still connected.

00:39:33.880 --> 00:39:36.270
Things look pretty much the same so far.

00:39:38.970 --> 00:39:41.000
Since we unmounted the
disk from the file system,

00:39:41.210 --> 00:39:44.430
the file system objects have all
been cleaned up and gone away.

00:39:45.560 --> 00:39:48.500
There's no right-hand arrow.

00:39:48.500 --> 00:39:51.460
There's no more high-level
devices in the registry anymore.

00:39:51.500 --> 00:39:53.500
We unplug this.

00:39:53.500 --> 00:39:58.610
It'll then clean up the
rest of the I/O Kit.

00:40:06.730 --> 00:40:10.680
You can see now,
back just having the one FireWire device

00:40:11.280 --> 00:40:14.820
driver waiting for devices to appear.

00:40:16.730 --> 00:40:23.910
That's basically it for my demonstration
of how the iCat registry works,

00:40:23.960 --> 00:40:28.600
how FireWire fits into that,
how your drivers will fit in as well.

00:40:28.600 --> 00:40:33.810
Now, I've talked about the
objects that are created to

00:40:34.440 --> 00:40:37.340
represent how everything's
fitted together.

00:40:37.440 --> 00:40:40.840
So you've got things you can talk to,
to talk to your device.

00:40:40.970 --> 00:40:43.500
How do you actually do things?

00:40:43.810 --> 00:40:47.800
How do you send packets, receive packets,
to all the things I was talking about?

00:40:48.270 --> 00:40:53.100
In a similar way to how
things are done in Mac OS 9,

00:40:53.160 --> 00:40:57.940
I have an object called the I0FW command.

00:40:58.020 --> 00:41:02.820
This is an abstract object
representing issuing a command

00:41:03.160 --> 00:41:05.860
to the FireWire hardware.

00:41:08.310 --> 00:41:13.200
The base object handles
all the thread blocking,

00:41:13.200 --> 00:41:17.920
scheduling, completion callback,
stuff that's needed.

00:41:17.990 --> 00:41:22.590
We'll handle SMP in the future,
should we do such a thing.

00:41:24.100 --> 00:41:28.680
and I have loads of derived classes
from this base class to do all the

00:41:28.700 --> 00:41:33.760
interesting FireWire things we can do.

00:41:33.990 --> 00:41:40.890
Main subclasses of our FireWire command
are the async command for sending

00:41:41.370 --> 00:41:48.870
asynchronous packets out over the bus,
and the bus command for

00:41:49.890 --> 00:41:55.900
Doing bus management stuff like
allocating local addresses,

00:41:56.090 --> 00:41:59.720
setting who the route is,
those sort of functions

00:42:00.160 --> 00:42:02.530
that are bus-wide.

00:42:05.440 --> 00:42:12.900
Another important object that I have
is for doing isochronous transfers.

00:42:12.990 --> 00:42:17.300
The way isochronous packets are

00:42:18.220 --> 00:42:23.540
Transferred over FireWire is, there's a,
sort of separate from devices,

00:42:23.630 --> 00:42:30.190
there's channels that Socratus
packets are sent over.

00:42:31.200 --> 00:42:35.380
So I have an object to
represent a channel that's

00:42:35.480 --> 00:42:37.620
been used for communicating.

00:42:39.230 --> 00:42:42.860
One for each Isokronis
channel that's been allocated.

00:42:42.920 --> 00:42:49.010
Its job is to know how much bandwidth
that channel has been configured to use,

00:42:49.170 --> 00:42:53.300
make sure that after bus reset,
all the right.

00:42:55.010 --> 00:42:59.780
Register,
ReasonWrite's locks are done to reserve

00:42:59.780 --> 00:43:02.620
the bandwidth again after bus reset.

00:43:02.620 --> 00:43:04.810
Also to handle what happens if

00:43:05.000 --> 00:43:07.000
The channel can't be reallocated.

00:43:07.020 --> 00:43:09.820
Notify everybody who's registered
an interest in that channel

00:43:10.430 --> 00:43:12.480
what state the channel is in.

00:43:15.650 --> 00:43:22.840
For things that are using the channel,
these have an abstract object

00:43:23.060 --> 00:43:26.350
called the isochronous port.

00:43:27.880 --> 00:43:35.840
Port for the transmitter on the channel,
and one or more for everything

00:43:35.840 --> 00:43:38.740
that's listening to that channel.

00:43:40.780 --> 00:43:44.300
Each Sucmas channel,
when you create a channel

00:43:44.300 --> 00:43:49.790
and you create ports,
you give the ports to the channel,

00:43:49.790 --> 00:43:52.840
and then once the channel's all
been configured with who's talking,

00:43:52.840 --> 00:43:55.240
who's listening,
you can then call methods in the

00:43:55.330 --> 00:43:58.490
channel to start and stop transmitting,
and it'll...

00:43:58.800 --> 00:44:04.040
Call each port that's configured to use
it to tell that port to start listening,

00:44:04.040 --> 00:44:07.330
to start sending,
kind of stuff like that.

00:44:09.160 --> 00:44:14.780
If you're using isochronous transfers,
you'll need to provide a subclass

00:44:14.780 --> 00:44:18.800
of this object that knows how to
tell your device to start listening,

00:44:18.870 --> 00:44:20.960
stop listening, stop transmitting,
stop transmitting,

00:44:20.960 --> 00:44:27.590
maybe change the data that's being sent,
whatever.

00:44:29.270 --> 00:44:35.070
And of course, you also need to create,
if Macintosh is going to be taking

00:44:35.070 --> 00:44:39.620
part in the Socratic Transfers,
you also need to create a local Socratic

00:44:40.030 --> 00:44:45.190
support to represent the data coming
in and going out of the Macintosh.

00:44:47.530 --> 00:44:52.360
This is the object that you
would give a DCL program,

00:44:52.360 --> 00:44:57.350
just the same DCL programs as you
may have written already in Mac OS 9.

00:44:57.500 --> 00:45:00.580
This object looks after those for you,
compiles them,

00:45:00.670 --> 00:45:04.420
feeds them into the hardware,
starts and stops them,

00:45:04.420 --> 00:45:07.080
allocates hardware for them.

00:45:09.180 --> 00:45:15.880
The nice thing about VCL is
that it tells us what

00:45:16.790 --> 00:45:17.660
Data is going to be transferred.

00:45:17.660 --> 00:45:19.860
We compile it.

00:45:19.910 --> 00:45:22.970
And we know which task the--

00:45:23.180 --> 00:45:28.390
and I will be talking about the
data that the DCL program came from.

00:45:28.480 --> 00:45:33.060
So we can program up the hardware
and configure the kernel,

00:45:33.060 --> 00:45:37.340
the virtual memory system,
so that the data flowing in

00:45:37.340 --> 00:45:41.850
and out over the bus can go
straight to your application.

00:45:41.990 --> 00:45:45.490
It doesn't have to go into
the kernel and get copied out,

00:45:45.490 --> 00:45:45.490
doing lots of interrupts
and faffing about.

00:45:45.490 --> 00:45:45.490
You get data straight from where it

00:45:45.820 --> 00:45:50.160
We started to where it belongs
without any interaction from the CPU,

00:45:50.300 --> 00:45:54.920
all with the FireWire
controller hardware,

00:45:54.920 --> 00:45:59.110
which is very important for
keeping up data rates on

00:45:59.110 --> 00:46:02.560
high-speed devices like camcorders.

00:46:07.240 --> 00:46:09.060
I know it's 10,
and we have this terrifying

00:46:09.060 --> 00:46:12.380
thing called the kernel,
the kernel boundary.

00:46:13.690 --> 00:46:17.700
In ECOS 9,
you had the application heap for each

00:46:17.700 --> 00:46:22.100
application and a system heap for kind
of common stuff like device drivers.

00:46:22.130 --> 00:46:25.830
And they were distinct,
but not very distinct.

00:46:26.160 --> 00:46:28.760
The kernel boundary is a bit like

00:46:29.840 --> 00:46:33.390
That division between
application and system heap,

00:46:33.430 --> 00:46:36.770
but it's a much more
rigidly enforced boundary.

00:46:36.770 --> 00:46:41.330
You really need to be aware of it,
make sure you know how you're going

00:46:41.330 --> 00:46:43.590
to get data across that boundary.

00:46:43.730 --> 00:46:49.090
Ideally, you use services we provide,
don't have to worry about it too much.

00:46:49.150 --> 00:46:54.370
But if you're doing interesting things,
you may need to consider that.

00:46:57.790 --> 00:47:00.160
So if you remember going right back,
we were showing two different

00:47:00.160 --> 00:47:01.650
devices being plugged in.

00:47:01.700 --> 00:47:09.800
Should your device-- do you need a
kernel extension to control your device?

00:47:10.090 --> 00:47:14.780
Can you just do all your
work outside of the kernel?

00:47:17.060 --> 00:47:21.200
To figure out the
answer to that question,

00:47:21.200 --> 00:47:26.800
you want to consider four main
points about what your driver does,

00:47:26.880 --> 00:47:30.000
what the applications
expect to use the driver do,

00:47:30.130 --> 00:47:32.100
the kind of performance you need.

00:47:32.200 --> 00:47:33.790
Is the driver used by the kernel?

00:47:33.930 --> 00:47:35.940
For example, a hard disk?

00:47:36.400 --> 00:47:38.600
If you want your hard disk to
get mounted by the file system,

00:47:38.600 --> 00:47:42.320
which is in the kernel,
then you need to provide a kernel

00:47:42.320 --> 00:47:44.740
driver to talk to the file system.

00:47:44.740 --> 00:47:47.880
Otherwise, you just don't get it mounted.

00:47:50.430 --> 00:47:54.360
If your driver is going to
be used simultaneously by

00:47:55.080 --> 00:47:58.480
many of the applications or
tasks running in the system,

00:47:58.480 --> 00:48:00.980
then it might make sense
to put it in a kernel.

00:48:01.750 --> 00:48:07.330
to allow the different applications
to all access at the same time.

00:48:08.340 --> 00:48:10.800
You have maybe been used by many
applications at different times,

00:48:10.800 --> 00:48:11.980
like a printer.

00:48:12.000 --> 00:48:15.760
Print all at the same time,
then that would be something that

00:48:15.930 --> 00:48:19.460
you would put out of the kernel,
even though at different times

00:48:19.460 --> 00:48:21.220
many applications use it.

00:48:23.340 --> 00:48:28.280
Does your hardware,
your driver need access to the

00:48:28.360 --> 00:48:30.300
hardware interrupts in the Mac?

00:48:30.440 --> 00:48:33.160
For FireWire,
I think that's basically going to be no,

00:48:33.160 --> 00:48:35.640
because we control the FireWire hardware.

00:48:35.720 --> 00:48:39.680
Of course, if you're writing a...

00:48:39.780 --> 00:48:45.260
The driver for a PCI card from Mac to
fit into the FireWire system then.

00:48:45.520 --> 00:48:48.960
That would have to be a kernel extension,
because it's used by the kernel and

00:48:48.960 --> 00:48:51.470
it's going to handle primary interrupts.

00:48:52.360 --> 00:48:56.670
Finally, do you need to synchronize
between several applications that

00:48:56.670 --> 00:48:57.540
are running at the same time?

00:48:57.540 --> 00:49:01.260
An example would be audio.

00:49:01.390 --> 00:49:05.140
If you're mixing several audio channels
together from different applications,

00:49:05.140 --> 00:49:06.910
and wanting them all
to come out together,

00:49:07.030 --> 00:49:11.540
you may need to do stuff in
the kernel to make sure that

00:49:11.540 --> 00:49:14.570
everything is scheduled correctly.

00:49:17.680 --> 00:49:20.760
So some examples of where things belong.

00:49:20.760 --> 00:49:22.440
Our storage, disk drives.

00:49:22.440 --> 00:49:23.920
They belong in the kernel.

00:49:24.130 --> 00:49:26.110
You have to write a kernel driver.

00:49:26.860 --> 00:49:31.540
Scanners,
printers don't belong in the kernel.

00:49:31.540 --> 00:49:34.740
You really want to do a CF plug-in.

00:49:35.000 --> 00:49:39.140
We'll certainly provide SBP-2 services
out of the kernel for you to use,

00:49:39.180 --> 00:49:45.530
and I'm pretty confident we'll be
providing even lower level FireWire

00:49:45.650 --> 00:49:49.410
access for you outside the kernel,
so you can just stay outside

00:49:49.410 --> 00:49:49.410
the kernel and not have to
worry about kernel extensions.

00:49:50.370 --> 00:49:57.910
An interesting kind of device, a CDR,
CD recording machines.

00:49:58.890 --> 00:50:02.840
When it's being a CD drive,
and you just put a normal CD in it,

00:50:02.840 --> 00:50:06.700
you want to be in the kernel so that you
can fit in with the file system and our

00:50:06.730 --> 00:50:11.560
users can see what's in that CD writer,
make sure it's the right CD.

00:50:11.560 --> 00:50:17.350
On the other hand,
when you're recording a CD,

00:50:19.070 --> 00:50:21.530
You feel like you should
be outside the kernel.

00:50:21.640 --> 00:50:24.010
You only have one application
writing a CD at a time.

00:50:24.050 --> 00:50:26.440
You don't want the fastest in trying
to mount the CD as you write it.

00:50:26.440 --> 00:50:29.750
I mean, that would be pretty terrible.

00:50:29.860 --> 00:50:33.560
So it looks like you're probably
going to end up with two drivers,

00:50:33.560 --> 00:50:39.430
a kernel driver for
mounting ready-recorded CDs,

00:50:39.430 --> 00:50:45.920
and a user driver for applications
like Toast to talk to for recording.

00:50:46.090 --> 00:50:48.040
Which means you have to worry
a little bit about sharing,

00:50:48.040 --> 00:50:51.880
make sure that the two
drivers don't conflict.

00:50:52.980 --> 00:50:59.340
Finally, high-performance, isochronous,
time-critical applications

00:50:59.390 --> 00:51:01.410
like camcorders.

00:51:01.720 --> 00:51:08.820
We have a prototype DV camcorder driver
that didn't quite make it into DP4,

00:51:08.820 --> 00:51:11.900
which is currently
implemented inside the kernel.

00:51:11.900 --> 00:51:14.980
And we did it in the kernel because
we knew it would work in the kernel.

00:51:14.980 --> 00:51:20.010
But it would really be nice to have
that not in the kernel because,

00:51:20.010 --> 00:51:23.850
again, there's only one application
using a camcorder at a time.

00:51:23.860 --> 00:51:27.430
Things in the kernel are
overhead for every application.

00:51:28.600 --> 00:51:33.690
And I'm pretty confident that using DCL

00:51:33.850 --> 00:51:38.970
We can get enough data rate through...
We don't really need to be in the kernel.

00:51:38.990 --> 00:51:43.710
However,
that's something I need to verify.

00:51:47.650 --> 00:51:54.900
To conclude,
FireWire in DP4 is a work in progress.

00:51:54.900 --> 00:51:56.750
It's not finished.

00:51:57.170 --> 00:51:59.430
But there's a lot of functionality there.

00:51:59.630 --> 00:52:01.780
You can do plenty of stuff.

00:52:01.920 --> 00:52:04.640
You can certainly write
a FireWire disk driver,

00:52:04.720 --> 00:52:06.630
because we managed to do that.

00:52:07.510 --> 00:52:10.320
It's open source.

00:52:10.360 --> 00:52:11.500
Get the source.

00:52:11.970 --> 00:52:18.330
The Darwin site doesn't actually
have the SBP-2 just drive

00:52:18.530 --> 00:52:21.120
source on it at the moment,
but I think we'll sort that

00:52:21.120 --> 00:52:22.440
out and it'll be there.

00:52:22.500 --> 00:52:26.890
The FireWire family code definitely is
all where I checked earlier in the week.

00:52:29.180 --> 00:52:33.640
Keeping an eye out on our web page to
see how we're getting on with stuff.

00:52:33.660 --> 00:52:36.770
I'm sure we'll be updating
that as time goes on.

00:52:37.060 --> 00:52:40.640
Remember the architecture is
like Mac OS 9 for FireWire.

00:52:40.680 --> 00:52:42.710
It's not the same.

00:52:42.820 --> 00:52:47.660
You do have to change your code,
but you shouldn't need to redesign

00:52:48.470 --> 00:52:50.900
fundamentally how your driver works.

00:52:50.960 --> 00:52:55.490
If you have a driver that's sort of
following the right OS 9 FireWire rules,

00:52:55.500 --> 00:52:57.900
you should find that you
just go through your code,

00:52:57.900 --> 00:53:01.900
look at the calls you're
making to FireWire 9,

00:53:01.990 --> 00:53:06.880
move them over to equivalent calls in 10,
and things should be all work.

00:53:07.040 --> 00:53:07.900
That's worked for me.

00:53:07.900 --> 00:53:09.900
I hope it'll work for you, too.

00:53:11.500 --> 00:53:18.500
Of course, FireWire is based on I/OKit,
and my code is in C++,

00:53:18.760 --> 00:53:23.680
which means that to call my objects,
at least that part of your

00:53:23.680 --> 00:53:30.000
driver needs to be in C++ so
that you can call my code.

00:53:30.070 --> 00:53:32.040
But that doesn't mean to say
that you have to convert all

00:53:32.040 --> 00:53:33.490
your-- if you have a big,
complicated driver,

00:53:33.500 --> 00:53:39.080
you have to convert all
of it from C to C++.

00:53:39.080 --> 00:53:39.080
You only need to convert--

00:53:39.440 --> 00:53:43.140
The pieces that interact with I/O Kit,
the call I/O Kit.

00:53:43.290 --> 00:53:48.130
C and C++ actually work
together quite well.

00:53:48.520 --> 00:53:53.200
Finally, be aware of the kernel boundary.

00:53:53.270 --> 00:53:58.040
If you're playing fast and loose in the
system heap and the application heap,

00:53:58.100 --> 00:54:00.850
and your driver and the applications
that talk to your driver,

00:54:00.860 --> 00:54:03.690
you're going to have
to do a bit more work

00:54:03.850 --> 00:54:09.300
in OS X to get across
the kernel boundary.
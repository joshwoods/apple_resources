WEBVTT

00:00:07.400 --> 00:00:24.500
[Transcript missing]

00:00:24.980 --> 00:00:28.460
The purpose of this session is to
build upon the Cocoa Overview session,

00:00:28.460 --> 00:00:32.870
which you might have attended on Tuesday,
to give you somewhat more detail

00:00:32.910 --> 00:00:35.880
into some of the topics that
Becky touched upon that day,

00:00:35.880 --> 00:00:39.360
and also to give you a flavor more about
how Cocoa works and how it's designed.

00:00:39.380 --> 00:00:42.650
So the in-depth discussions,
the topics that we're going to

00:00:42.650 --> 00:00:46.290
provide you are the document objects,
scripting, and undo,

00:00:46.450 --> 00:00:48.660
which are three topics that go in hand.

00:00:48.680 --> 00:00:51.350
The text system, we're going to give you
a little detail on that.

00:00:51.920 --> 00:00:55.270
Then we're going to give you a bit of
performance tips and tools and how it

00:00:55.270 --> 00:00:57.480
impacts Cocoa in the context of Mac OS X.

00:00:57.480 --> 00:01:01.340
We're going to talk a few minutes
about using Carbon from Cocoa,

00:01:01.340 --> 00:01:04.030
and also how to use
Java to program Cocoa.

00:01:06.060 --> 00:01:09.850
Okay, so for the first part of the talk,
"Document Scripting and Undo,"

00:01:10.090 --> 00:01:15.070
I would like to invite Mike Ferris,
who is a member of the engineering staff,

00:01:15.070 --> 00:01:16.060
on stage.

00:01:16.370 --> 00:01:18.170
Mike.

00:01:22.970 --> 00:01:27.060
So I'm going to talk
about three topics here,

00:01:27.060 --> 00:01:29.820
which all have a bit in common.

00:01:29.980 --> 00:01:33.970
Am I holding this wrong?

00:01:37.570 --> 00:01:43.280
So the document architecture
and the AppleScript support and

00:01:43.280 --> 00:01:50.500
the undo support in the app kit
all have some stuff in common.

00:01:50.530 --> 00:01:54.410
Of the features in the kit,
a lot of the stuff in the kit is

00:01:54.410 --> 00:02:00.290
basically widgets and things that you use
in your application but don't necessarily

00:02:00.690 --> 00:02:03.780
affect the design of your application.

00:02:03.890 --> 00:02:09.230
Traditionally with the kit in the past,
you've basically been able

00:02:09.310 --> 00:02:13.230
to structure your app however
you feel you want to do that,

00:02:13.230 --> 00:02:17.140
and it hasn't really impacted you
in your ability to use the kit.

00:02:17.140 --> 00:02:23.980
But as we try to add some of
these higher level features,

00:02:24.100 --> 00:02:25.590
we find that the application

00:02:26.450 --> 00:02:31.120
If your app has a particular structure,
it's a lot easier for us

00:02:31.310 --> 00:02:33.670
to do a lot more for you.

00:02:33.840 --> 00:02:36.890
The structure that we've kind of
chosen to hang all this off of is the

00:02:36.890 --> 00:02:40.260
Model-View-Controller design pattern.

00:02:40.620 --> 00:02:44.160
And I want to mention that basically
all these features are separate,

00:02:44.160 --> 00:02:47.200
but they work really well together,
and sort of with the document stuff

00:02:47.270 --> 00:02:48.720
at the center of the equation.

00:02:48.720 --> 00:02:52.240
So if you're not familiar with
the model view controller pattern,

00:02:52.340 --> 00:02:55.130
I want to spend just a
moment talking about that.

00:02:55.170 --> 00:02:58.140
This is basically a design pattern.

00:02:58.140 --> 00:03:00.520
It came from, I think,
Smalltalk originally.

00:03:00.520 --> 00:03:06.410
And it's a way of structuring user
interface applications and basically

00:03:06.410 --> 00:03:09.320
splitting up your object model.

00:03:09.960 --> 00:03:12.590
Now, it divides models into
sort of three categories,

00:03:12.600 --> 00:03:14.440
or objects into three categories.

00:03:14.440 --> 00:03:16.870
There's your model objects that
are basically data-bearing.

00:03:16.880 --> 00:03:21.280
They have behavior,
but that behavior is basically

00:03:21.280 --> 00:03:25.900
concerned with how your model,
the thing that you're trying to

00:03:25.900 --> 00:03:28.570
represent in your application,
works.

00:03:28.620 --> 00:03:32.010
And so you have behaviors here that
help ensure the consistency and the

00:03:32.010 --> 00:03:34.120
invariance that you need in your model.

00:03:34.120 --> 00:03:37.120
The views...

00:03:38.430 --> 00:03:40.740
are basically the things
that you use to present data.

00:03:40.890 --> 00:03:44.190
Most of the objects in the kit
are basically view type objects.

00:03:44.340 --> 00:03:46.210
They help you to present
your data to the user.

00:03:46.300 --> 00:03:49.300
And then finally the controllers
kind of sit in the middle,

00:03:49.300 --> 00:03:50.300
coordinate everything.

00:03:50.300 --> 00:03:55.680
Controllers are a large amount
of the code that you end up

00:03:55.690 --> 00:03:57.300
writing in an application.

00:03:58.710 --> 00:04:02.980
So here's a little picture.

00:04:02.980 --> 00:04:05.440
We can look at this two ways.

00:04:05.440 --> 00:04:09.380
There's a couple of dotted lines which
you actually can't see very clearly here.

00:04:09.540 --> 00:04:12.340
Actually,
they don't even look dotted anymore.

00:04:12.340 --> 00:04:14.440
The little,
the black lines that kind of go

00:04:14.440 --> 00:04:18.880
down the middle of the box and
divide everything into three spaces,

00:04:18.880 --> 00:04:24.580
on the far left we have the model area in
the middle where it says NS Document and

00:04:24.670 --> 00:04:26.060
then it's Window Controller.

00:04:26.170 --> 00:04:28.220
That's the controller layer.

00:04:28.220 --> 00:04:31.680
And then on the far right,
you've got the view layer.

00:04:31.680 --> 00:04:36.410
Now the two boxes that sort of span
and enclose different parts of this,

00:04:36.410 --> 00:04:40.760
these represent a couple of objects that
are key in the document system and show

00:04:40.760 --> 00:04:43.500
where they kind of fit into this model.

00:04:43.500 --> 00:04:47.510
In the document system,
NS Document objects tend to be the

00:04:47.510 --> 00:04:51.060
controller objects that own your model.

00:04:51.080 --> 00:04:57.920
And NS Window Controller objects are
the controller objects that own your UI.

00:04:57.920 --> 00:05:02.590
So that's just a little brief
introduction to Model-View-Controller.

00:05:05.850 --> 00:05:10.980
So let's dive right into
the document architecture.

00:05:11.390 --> 00:05:15.020
Basically,
the intent here is to provide a

00:05:15.020 --> 00:05:21.800
structure where we can provide a lot of
the common behavior that all document

00:05:21.800 --> 00:05:28.140
applications need and provide you with
a place to put your behavior and easily

00:05:28.660 --> 00:05:32.540
customize for the kinds of documents
that your application deals with.

00:05:32.960 --> 00:05:37.240
Now,
the classes in the kit have a lot of sort

00:05:37.240 --> 00:05:41.040
of built-in implementation to do things
like running the open and save panel,

00:05:41.200 --> 00:05:43.440
loading nib files,
and managing the objects

00:05:43.480 --> 00:05:46.420
that come out of them,
and all the sorts of things

00:05:46.520 --> 00:05:48.350
that you always have to do.

00:05:48.700 --> 00:05:53.660
And they also provide subclassing
and overriding points where you

00:05:53.660 --> 00:05:57.040
get to plug in your specific stuff.

00:05:57.180 --> 00:05:59.170
Now,
the document architecture is also heavily

00:05:59.250 --> 00:06:03.120
tied into the application packaging,
and in particular,

00:06:03.270 --> 00:06:06.550
the same data that the finder
uses to know what kind of

00:06:06.610 --> 00:06:09.800
documents your application opens,
the document system uses so that

00:06:09.800 --> 00:06:13.990
your application will know what kind
of documents your application opens.

00:06:16.710 --> 00:06:20.540
There's three main classes
involved in the document system.

00:06:20.540 --> 00:06:24.640
The first and most obvious
one is the NSDocument class.

00:06:24.780 --> 00:06:27.720
Basically,
each instance of this class represents

00:06:27.720 --> 00:06:29.780
an open document in your app.

00:06:30.320 --> 00:06:35.000
It's responsible for loading
and saving the document.

00:06:35.000 --> 00:06:39.090
It also is responsible
primarily for owning the actual

00:06:39.090 --> 00:06:42.420
contents of the document,
the model objects.

00:06:42.750 --> 00:06:46.330
You pretty much always subclass
NSDocument to provide your

00:06:46.330 --> 00:06:49.330
specific kind of document,
a text document, an image document,

00:06:49.390 --> 00:06:52.170
whatever it is that
your app is going to do.

00:06:52.810 --> 00:06:57.050
And just to sort of look forward
a little bit to the other two

00:06:57.110 --> 00:07:03.250
topics in this part of the session,
documents are typically the primary entry

00:07:03.260 --> 00:07:05.700
point for scripting in an application.

00:07:05.700 --> 00:07:10.700
And then also, each document usually
has an undo manager.

00:07:10.700 --> 00:07:14.970
So we'll get into those two
aspects a little bit later.

00:07:16.070 --> 00:07:18.580
Now,
the next object is basically a singleton.

00:07:18.680 --> 00:07:21.760
There's one NSDocumentController
in your application.

00:07:22.070 --> 00:07:24.520
It knows about all the open documents.

00:07:24.580 --> 00:07:29.190
And it also handles behaviors
which are not associated

00:07:29.190 --> 00:07:32.570
with a particular document,
like new and open.

00:07:34.490 --> 00:07:37.060
This is also where you would go
if you actually needed to query

00:07:37.060 --> 00:07:41.840
the metadata about your document
types that's in your Info.plist.

00:07:41.960 --> 00:07:45.910
It parses all that when the application
launches and provides you with

00:07:45.910 --> 00:07:48.220
some queries that you can make.

00:07:48.590 --> 00:07:50.500
Now,
you rarely have to subclass this object.

00:07:50.500 --> 00:07:55.500
You can, it's easy,
but mostly you don't need to bother.

00:07:55.500 --> 00:08:00.490
The majority of the kinds of things
that you're going to want to customize,

00:08:00.530 --> 00:08:04.490
you can actually customize through
the application's delegate object.

00:08:07.780 --> 00:08:11.240
And then finally,
there's Ennis Window Controller.

00:08:11.290 --> 00:08:16.480
Basically, this is a class which manages
a window that is typically

00:08:16.480 --> 00:08:19.630
loaded out of an IB file,
and it usually manages a

00:08:19.630 --> 00:08:22.350
window on behalf of a document.

00:08:23.200 --> 00:08:25.950
Now, documents can have multiple
window controllers.

00:08:25.990 --> 00:08:30.120
So you might have a CAD application
that had four windows,

00:08:30.120 --> 00:08:34.330
you know, that was showing a top and
a left and a front view and,

00:08:34.340 --> 00:08:38.300
you know, maybe a preview wireframe
of the 3D or whatever.

00:08:38.320 --> 00:08:42.170
You might also have an application
that allowed multiple views of the same

00:08:42.170 --> 00:08:46.260
document to be open so that you could
look at different scales or whatever.

00:08:46.460 --> 00:08:50.290
So documents can have
multiple window controllers.

00:08:50.580 --> 00:08:54.380
and although you don't have to
subclass NSWindowController,

00:08:54.520 --> 00:08:57.260
it's very common to do so.

00:08:57.260 --> 00:08:59.470
And one last point I'd like to make
about the WindowControllers is you can

00:08:59.470 --> 00:09:03.320
actually use them without NSDocument.

00:09:03.320 --> 00:09:06.910
You can subclass NSWindowController
to provide controller objects for your

00:09:07.390 --> 00:09:11.420
auxiliary panels and everything else,
and they provide management

00:09:11.500 --> 00:09:14.370
of the nib file contents.

00:09:16.700 --> 00:09:19.970
So if you were at Becky's
talk a couple days ago,

00:09:20.150 --> 00:09:22.030
you saw this picture.

00:09:22.240 --> 00:09:25.000
This is a non-document-based
Cocoa application.

00:09:25.000 --> 00:09:28.830
And you may be wondering what
the document system sort of

00:09:28.830 --> 00:09:30.240
changes this picture into.

00:09:30.240 --> 00:09:35.260
Basically, the delegate objects,
the window delegate objects,

00:09:35.260 --> 00:09:37.780
become NSWindowControllers.

00:09:37.800 --> 00:09:41.410
Now, a window controller often is
the delegate of its window.

00:09:41.550 --> 00:09:42.970
It doesn't have to be.

00:09:43.060 --> 00:09:46.760
But if you're going to subclass it,
it may as well be.

00:09:46.760 --> 00:09:49.150
And then there are NSDocument objects,
right?

00:09:49.150 --> 00:09:51.780
And you can see that one of
these document objects has a

00:09:51.780 --> 00:09:54.190
couple of window controllers.

00:09:54.230 --> 00:09:55.800
And other than that,
everything's about the same.

00:09:55.800 --> 00:09:58.560
You can see also the
NSDocumentController object that

00:09:58.640 --> 00:10:01.590
knows about all the open documents.

00:10:04.990 --> 00:10:09.220
So that's a very brief
introduction to documents.

00:10:09.260 --> 00:10:13.280
Now, an equally brief
introduction to scripting.

00:10:13.520 --> 00:10:17.050
Scripting is based on key value coding.

00:10:17.100 --> 00:10:19.890
We'll talk about that in just a moment.

00:10:20.110 --> 00:10:26.850
And the two main areas of the scripting
support is classes that support you

00:10:26.850 --> 00:10:31.130
defining your script terminologies,
and then classes that support

00:10:31.160 --> 00:10:34.070
you handling script commands.

00:10:35.610 --> 00:10:37.700
First of all, let's talk a little bit
about key value coding,

00:10:37.700 --> 00:10:42.200
because this is a totally crucial
concept in the scripting framework.

00:10:42.300 --> 00:10:46.310
We get key value coding from the
Enterprise Objects framework.

00:10:46.920 --> 00:10:54.350
and it is basically a standardized
way of accessing pieces of an object.

00:10:54.760 --> 00:10:58.510
What you do in your object is
implement accessor methods,

00:10:58.560 --> 00:11:00.420
and they basically have a naming pattern.

00:11:00.420 --> 00:11:03.660
You just, you know,
you have a get method that's

00:11:03.770 --> 00:11:06.330
just the name of the key,
and then a set method

00:11:06.410 --> 00:11:08.040
that goes along with it.

00:11:08.120 --> 00:11:11.760
Keys, for example,
are things like the line width of this

00:11:11.760 --> 00:11:14.350
circle and the line color and so forth.

00:11:14.390 --> 00:11:18.670
And so some of the methods might be,
you know, line width and set line width.

00:11:20.390 --> 00:11:25.090
width and set width,
height and set height, whatever.

00:11:25.950 --> 00:11:30.830
The standardization part of this comes
in in that there are two methods,

00:11:30.830 --> 00:11:33.900
valueForKey and takeValueForKey.

00:11:33.900 --> 00:11:36.900
So valueForKey,
you just give it the name of a key,

00:11:36.900 --> 00:11:38.240
like line width.

00:11:38.240 --> 00:11:41.500
It figures out, oh, look, okay,
this object has a line width method.

00:11:41.500 --> 00:11:44.090
I'm going to go off and
call this and return this,

00:11:44.090 --> 00:11:45.900
the value of that.

00:11:45.900 --> 00:11:49.600
And then takeValueForKey
similarly works for setting.

00:11:49.600 --> 00:11:53.780
But this allows a subsystem that
knows nothing about your specific

00:11:54.010 --> 00:11:59.910
objects to nonetheless be able to,
you know, get at the individual pieces of

00:11:59.910 --> 00:12:02.620
your object and deal with them.

00:12:02.620 --> 00:12:06.000
And so the scripting system
makes heavy use of this.

00:12:06.000 --> 00:12:07.870
How?

00:12:07.870 --> 00:12:07.880
Well,

00:12:08.090 --> 00:12:13.670
We use key value coding to
provide automatic evaluation

00:12:13.750 --> 00:12:16.510
of object specifiers.

00:12:16.510 --> 00:12:16.510
If you're familiar with Apple script,
you know that

00:12:16.900 --> 00:12:19.730
Basically,
the receiver of an AppleScript command

00:12:19.740 --> 00:12:23.810
is usually an object that's
qualified along the lines of,

00:12:23.900 --> 00:12:29.060
OK, well, tell the first graphic of
the front document of the

00:12:29.060 --> 00:12:32.580
application sketch to do something.

00:12:32.600 --> 00:12:36.200
The first graphic of the front
document of application sketch,

00:12:36.210 --> 00:12:38.620
that's an object specifier.

00:12:40.160 --> 00:12:42.930
We pretty much provide
automatic resolution of these

00:12:42.990 --> 00:12:44.790
things using key value coding.

00:12:44.910 --> 00:12:48.250
So if your document object has a key,
which is the graphics that

00:12:48.250 --> 00:12:51.340
that document contains,
and your application has a key,

00:12:51.340 --> 00:12:54.700
which is the documents that
the application has open,

00:12:54.750 --> 00:12:58.910
then we can automatically find the
first graphic of the front document.

00:13:01.160 --> 00:13:05.070
In addition to the simple ones,
we can automatically do, say,

00:13:05.170 --> 00:13:07.560
arbitrarily complex "whose"
clauses in this way.

00:13:10.760 --> 00:13:16.070
We also use key value coding to
provide default implementations for

00:13:16.070 --> 00:13:17.690
a lot of the common script commands.

00:13:17.700 --> 00:13:21.780
You can see that set and get,
those are pretty easy to

00:13:21.780 --> 00:13:23.700
do with key value coding.

00:13:23.710 --> 00:13:29.700
We can also do stuff like move
and create and count and exists.

00:13:29.700 --> 00:13:33.970
So a lot of the core scripting
suite commands actually have default

00:13:34.010 --> 00:13:38.580
implementations and your objects won't
have to specifically support them at all.

00:13:38.790 --> 00:13:41.950
All they need to do is claim that
they can support them and they'll

00:13:41.950 --> 00:13:43.700
automatically support them.

00:13:48.170 --> 00:13:52.580
So let's talk a little
bit about terminologies.

00:13:52.580 --> 00:13:55.590
In AppleScript,
your scripting terminology is

00:13:55.670 --> 00:13:57.860
usually broken up into suites.

00:13:57.860 --> 00:14:02.690
And so this is the granularity that
we have for defining these things.

00:14:02.940 --> 00:14:10.000
Script Suites are defined in frameworks
or applications or loadable bundles.

00:14:10.260 --> 00:14:14.370
They are property lists that
live inside of your frameworks

00:14:14.370 --> 00:14:16.240
or applications or bundles.

00:14:16.240 --> 00:14:19.380
And at runtime, Cocoa is going to go
out and find them all,

00:14:19.380 --> 00:14:21.140
all of the frameworks
you're linked against,

00:14:21.340 --> 00:14:24.260
all of the bundles you've loaded,
your app itself.

00:14:24.260 --> 00:14:27.060
We'll find all the script suites
and then combine them all together,

00:14:27.060 --> 00:14:31.020
and that produces the
terminology for your application.

00:14:33.000 --> 00:14:38.160
Now, the contents of a script suite is
basically descriptions of the classes

00:14:38.240 --> 00:14:43.260
that this suite defines and descriptions
of the commands that it defines.

00:14:46.640 --> 00:14:52.330
The classes are represented by
NS Scripting class description objects.

00:14:52.330 --> 00:14:57.820
And basically, classes have keys,
both properties,

00:14:57.880 --> 00:15:01.870
or if you're used to databases,
sometimes those are called attributes,

00:15:01.870 --> 00:15:06.110
and elements,
sometimes called relationships.

00:15:06.120 --> 00:15:09.450
And then also a list of the
commands that the classes support.

00:15:09.460 --> 00:15:13.520
Classes can inherit from each other,
just like in an object-oriented

00:15:13.520 --> 00:15:15.290
programming language.

00:15:15.320 --> 00:15:19.780
And then the script command,
the scripting command description

00:15:20.290 --> 00:15:24.220
class is used to define
commands in the script suite.

00:15:24.280 --> 00:15:28.360
And commands basically have arguments
and they have return values and

00:15:28.400 --> 00:15:30.880
the things you'd probably expect.

00:15:31.160 --> 00:15:33.300
There's a property list
definition for all of this stuff,

00:15:33.320 --> 00:15:36.050
so that you just sort of
describe in a property list the

00:15:36.050 --> 00:15:37.730
various classes and commands.

00:15:37.820 --> 00:15:39.690
And then at runtime,
those will all be parsed in,

00:15:39.690 --> 00:15:43.770
and these instances of these objects
will be created to represent them.

00:15:47.190 --> 00:15:52.790
Now, once the script editors say,
knows your terminology,

00:15:53.360 --> 00:15:57.180
Somebody might write a script
and then tell it to run,

00:15:57.180 --> 00:16:01.360
and at that point,
you're gonna start getting script

00:16:01.360 --> 00:16:01.360
commands in your application.

00:16:01.790 --> 00:16:04.160
So script commands come
in as Apple events,

00:16:04.160 --> 00:16:06.930
just like they do for any
application in Mac OS X.

00:16:07.000 --> 00:16:09.100
But we take them before you
ever see them and turn them

00:16:09.100 --> 00:16:11.810
into NS script command objects.

00:16:12.970 --> 00:16:16.240
So these basically,
NScript command objects are the things

00:16:16.300 --> 00:16:20.040
that you'll see if you have to implement
a handler for a custom command,

00:16:20.040 --> 00:16:25.410
or if maybe your object knows that it
can do counting better than the default

00:16:25.410 --> 00:16:28.510
implementation of the count command.

00:16:29.860 --> 00:16:34.130
Basically, the script command allows you
access to all the important pieces,

00:16:34.130 --> 00:16:35.800
you know, of that command.

00:16:35.800 --> 00:16:40.790
So it'll let you get at the
receivers of the command,

00:16:40.800 --> 00:16:42.800
which is basically an object specifier.

00:16:42.800 --> 00:16:45.500
It'll let you actually
get at the real receivers,

00:16:45.500 --> 00:16:48.750
which is the result of
evaluating that object specifier.

00:16:48.790 --> 00:16:53.790
And subclasses of NSScriptCommand

00:16:53.970 --> 00:16:57.550
are actually where the default
implementations are provided

00:16:57.550 --> 00:16:59.790
in cases where we can have
a default implementation.

00:16:59.840 --> 00:17:05.970
So you'll see in the framework, you know,
NS set commands and get commands and

00:17:05.970 --> 00:17:08.100
NS count commands and so on and so forth.

00:17:08.560 --> 00:17:11.400
When you define your own commands,
you can choose to have a subclass

00:17:11.500 --> 00:17:15.680
or not based on whether you're going
to have a default implementation and

00:17:15.680 --> 00:17:19.020
possibly based on other things as well.

00:17:19.520 --> 00:17:24.640
And then the other object that we have
here is the NSObjectReference class.

00:17:24.640 --> 00:17:29.790
This basically represents one
chunk of an object specifier.

00:17:29.790 --> 00:17:32.600
So again,
graphic one of the front document

00:17:32.600 --> 00:17:36.220
of application sketch would turn
into three object references

00:17:36.220 --> 00:17:38.250
that are all chained together.

00:17:39.450 --> 00:17:41.550
and again,
object references know how to evaluate

00:17:41.640 --> 00:17:43.200
themselves using key value coding.

00:17:45.550 --> 00:17:48.950
Object references are found as both the
receivers of a script command and also

00:17:48.950 --> 00:17:51.960
possibly as arguments to that command.

00:17:55.780 --> 00:17:58.140
So this is all, you know,
sounds pretty complicated.

00:17:58.140 --> 00:18:00.870
It's actually pretty easy
to get started with this.

00:18:00.930 --> 00:18:04.590
We provide a lot of the behavior for you.

00:18:04.710 --> 00:18:10.220
We have a lot of the core suite
and text suite implemented in the

00:18:10.220 --> 00:18:13.230
frameworks that come with Cocoa.

00:18:13.540 --> 00:18:18.900
So the application AppleScript class
is implemented by NSApplication.

00:18:18.960 --> 00:18:23.300
The document AppleScript class
is implemented by NSDocument.

00:18:23.410 --> 00:18:25.560
You know, the window class is
implemented by NSWindow,

00:18:25.560 --> 00:18:26.300
etc., etc.

00:18:26.300 --> 00:18:29.300
You can see where that's going.

00:18:29.500 --> 00:18:34.260
The text suite is pretty much fully
implemented by the NSTextStorage class.

00:18:34.490 --> 00:18:39.900
So what that means to you is if you
wanted to expose in your object model,

00:18:40.080 --> 00:18:42.440
Something that conforms
to the text suite.

00:18:42.490 --> 00:18:44.940
You just have an NSTextStorage object.

00:18:44.940 --> 00:18:49.740
And so, for instance, in Sketch, right,
Sketch has a text graphic type.

00:18:49.740 --> 00:18:52.520
And you can, you know, type some text in,
whatever, right.

00:18:52.520 --> 00:18:56.620
And the text graphic type exposes
one of its instance variables,

00:18:56.620 --> 00:18:59.260
which is an NSTextStorage,
to AppleScript.

00:18:59.260 --> 00:19:03.970
And then, boom, automatically,
the text graphic in Sketch will

00:19:04.120 --> 00:19:06.300
support the text suite.

00:19:08.000 --> 00:19:10.220
So there's a lot of this
stuff built in there.

00:19:10.220 --> 00:19:12.990
You can incrementally start
exposing your own stuff.

00:19:13.140 --> 00:19:15.340
You have to do a little bit
of work to start exposing

00:19:15.430 --> 00:19:16.520
some of your model objects.

00:19:16.520 --> 00:19:19.360
But often,
with just a very small amount of work,

00:19:19.380 --> 00:19:23.640
you can get a lot of basic scripting
functionality almost for free.

00:19:26.440 --> 00:19:31.000
Finally, even briefer than the documents
and the scripting stuff,

00:19:31.060 --> 00:19:35.800
I'll talk a little bit about Undo.

00:19:35.800 --> 00:19:35.800
So,

00:19:36.930 --> 00:19:40.850
First, let me make the point,
undo should be implemented in your model.

00:19:41.190 --> 00:19:44.860
You don't want to implement
undo in your interface layer,

00:19:44.860 --> 00:19:46.900
because then if something
else comes along,

00:19:46.900 --> 00:19:51.550
like for instance, Apple script,
and starts talking directly

00:19:51.550 --> 00:19:51.550
to your model layer,

00:19:51.910 --> 00:19:55.950
That's not a good thing if you're
going to support multiple undo levels.

00:19:56.070 --> 00:20:01.710
If somebody changes the font
through the user interface,

00:20:01.710 --> 00:20:05.800
and then a script comes along
and deletes that whole paragraph,

00:20:05.810 --> 00:20:08.390
and then later the user says undo, well,
okay,

00:20:08.400 --> 00:20:10.210
what are you going to undo at that point?

00:20:10.220 --> 00:20:14.180
You've kind of lost the synchronization
of the undo stack in the model.

00:20:14.240 --> 00:20:17.130
So it's very important that undo
be implemented in your model.

00:20:17.130 --> 00:20:19.460
It's also the easiest place to put it.

00:20:19.530 --> 00:20:20.900
So that works out.

00:20:23.020 --> 00:20:26.250
Again, for multiple undo,
every change to your

00:20:26.250 --> 00:20:29.670
document has to be undoable,
because if not, you're going to start

00:20:29.670 --> 00:20:31.340
getting out of sync again.

00:20:32.100 --> 00:20:35.900
Now, the class in the kit,
actually in Foundation,

00:20:35.950 --> 00:20:39.000
that supports Undo is
called NSUndoManager,

00:20:39.140 --> 00:20:44.560
and it basically represents
a stack of Undo operations.

00:20:44.670 --> 00:20:47.340
As I said before,
a document object typically

00:20:47.340 --> 00:20:50.430
owns an UndoManager,
so in document-based apps,

00:20:50.430 --> 00:20:53.630
Undo stacks are per document.

00:20:54.890 --> 00:20:57.260
If you're not a document-based app,
then by default,

00:20:57.290 --> 00:20:58.800
Undo stacks are per window.

00:20:59.650 --> 00:21:06.800
Now, NSUndo Manager is based on another
foundation class called NSInvocation.

00:21:06.800 --> 00:21:10.800
And what that means is that
basically to implement Undo,

00:21:10.920 --> 00:21:13.760
all you have to do is do exactly
the opposite of what you're gonna do

00:21:13.800 --> 00:21:15.800
every time you're gonna do something.

00:21:15.800 --> 00:21:17.710
Clear enough?

00:21:18.440 --> 00:21:23.200
So the code in yellow here is all
you have to do in order to make

00:21:23.330 --> 00:21:26.680
setStrokeColor in Sketch undoable.

00:21:26.680 --> 00:21:30.670
Now this is one of the primitive
model methods in Sketch,

00:21:30.720 --> 00:21:30.900
right?

00:21:30.950 --> 00:21:33.240
The graphic object has this method.

00:21:33.240 --> 00:21:37.520
This is the way that the stroke color
changes no matter who's changing it.

00:21:37.520 --> 00:21:41.740
And therefore, this is the appropriate
place to put this undo logic.

00:21:41.740 --> 00:21:43.560
We know that the stroke color's
never going to change unless

00:21:43.560 --> 00:21:45.810
it goes through this code.

00:21:45.820 --> 00:21:49.150
And every time it does change,
the first thing we're going

00:21:49.240 --> 00:21:54.030
to do is tell the undo manager
to prepare a new invocation,

00:21:54.310 --> 00:21:59.760
which will basically, if undo is chosen,
end up sending the same graphic

00:21:59.830 --> 00:22:03.820
object another setStrokeColor
message with the old stroke color,

00:22:03.820 --> 00:22:07.910
that underbar stroke color,
that's our instance variable that,

00:22:07.950 --> 00:22:10.520
you know, contains the stroke color.

00:22:10.520 --> 00:22:13.590
So as long as we just say, oh, OK,
if I need to undo this,

00:22:13.590 --> 00:22:15.770
just call it again with the old value.

00:22:15.780 --> 00:22:16.970
and

00:22:17.830 --> 00:22:23.010
Everything is going to be set up
and it's going to work just fine.

00:22:23.210 --> 00:22:26.090
Now, a lot of these undo invocations,
because they're implemented in

00:22:26.090 --> 00:22:29.000
the primitives in the model,
might happen during an event,

00:22:29.090 --> 00:22:34.190
but NSUndoManager, by default,
will group all of the invocations

00:22:34.670 --> 00:22:40.100
that get told to it during a single
run of the event loop into one thing,

00:22:40.100 --> 00:22:42.290
and they'll all undo together.

00:22:44.150 --> 00:22:46.160
Let me give you a little bit of a demo.

00:22:46.390 --> 00:22:50.060
Mostly this will be a scripting demo.

00:22:50.110 --> 00:22:54.080
And if we could switch--we've switched.

00:22:54.080 --> 00:22:54.080
Okay, good.

00:22:56.820 --> 00:23:01.230
So I have here a script editor.

00:23:01.270 --> 00:23:05.830
And I have a little script which
I've written that does a very

00:23:05.830 --> 00:23:09.880
small amount of Sketch stuff here.

00:23:09.880 --> 00:23:16.730
So this script is targeted
at the Sketch application,

00:23:17.800 --> 00:23:20.370
I wonder if I can make that bigger.

00:23:20.400 --> 00:23:21.800
Alright, never mind.

00:23:21.810 --> 00:23:25.800
So, you don't need to read this,
but basically this is going

00:23:25.800 --> 00:23:30.540
to tell Sketch to create a new
document and then put some graphics

00:23:30.620 --> 00:23:31.800
in it and so on and so forth.

00:23:31.800 --> 00:23:34.380
So if I run that,
you can see that it creates

00:23:34.420 --> 00:23:38.730
a new Sketch document,
puts a little content in there,

00:23:38.730 --> 00:23:39.800
and so forth.

00:23:39.980 --> 00:23:44.420
And then the only other thing I want
to show here is Sketch was implemented

00:23:44.420 --> 00:23:46.800
prior to scripting being available.

00:23:46.800 --> 00:23:48.800
So scripting was kind of put in later.

00:23:48.800 --> 00:23:53.190
So nobody was thinking at the
time about the fact that somebody

00:23:53.190 --> 00:23:55.800
might be coming in and changing
things besides the user interface.

00:23:55.850 --> 00:23:59.710
But because Undo was
implemented in the model,

00:24:00.130 --> 00:24:01.000
That all just works.

00:24:01.000 --> 00:24:02.920
When we added scripting, it's fine.

00:24:03.220 --> 00:24:06.890
You know, things that are done through a
script are undoable the same as

00:24:06.890 --> 00:24:09.330
if they were done through the UI.

00:24:11.110 --> 00:24:13.100
So, okay, that's the end of the demo.

00:24:13.100 --> 00:24:21.690
And I believe I have one more slide here,
which is just where to get

00:24:21.690 --> 00:24:23.320
some more info on this.

00:24:25.350 --> 00:24:30.760
So there is a chapter of the
programming topics document.

00:24:30.770 --> 00:24:34.510
I think it's called App Design,
and it basically goes into

00:24:34.610 --> 00:24:38.890
a lot more detail on exactly
these three concepts-- document,

00:24:38.890 --> 00:24:40.350
scripting, and undo.

00:24:40.520 --> 00:24:46.780
There's new for, I think,
DP3 is an FAQ on NSDocument.

00:24:47.050 --> 00:24:49.100
People have questions.

00:24:49.100 --> 00:24:51.800
A lot of them tend to be commonly asked.

00:24:51.800 --> 00:24:53.990
These are some answers.

00:24:54.570 --> 00:24:56.950
There's pretty good scripting
documentation that tells

00:24:56.950 --> 00:25:00.810
you how to do script suites,
how to handle scripting in your app,

00:25:00.810 --> 00:25:02.270
so on and so forth.

00:25:02.390 --> 00:25:04.780
There's various release notes
that you might want to look at.

00:25:04.940 --> 00:25:09.060
And then, of course,
there's the Cocoa reference

00:25:09.060 --> 00:25:10.740
documentation.

00:25:10.740 --> 00:25:14.780
So OK, now let's bring Ali up,
and he can talk about text.

00:25:23.570 --> 00:25:26.260
If you were at the
Cocoa overview session,

00:25:26.260 --> 00:25:30.360
you saw Mike Ferris actually
put together the text edit demo,

00:25:30.360 --> 00:25:32.830
and now we want to talk a
little bit about the text system

00:25:32.840 --> 00:25:35.230
that he used in that demo.

00:25:35.480 --> 00:25:37.870
The text system,
we have a fairly sophisticated

00:25:37.970 --> 00:25:39.150
text system in Cocoa.

00:25:39.320 --> 00:25:41.660
There are three major
high-level features.

00:25:41.740 --> 00:25:43.260
First of all, it's international.

00:25:43.350 --> 00:25:45.370
It was designed with being
international in mind.

00:25:45.410 --> 00:25:46.380
It's Unicode-based.

00:25:46.420 --> 00:25:48.250
It supports inline input methods.

00:25:48.380 --> 00:25:51.400
It doesn't support every aspect
of internationalization yet.

00:25:51.400 --> 00:25:54.330
For instance,
you cannot type bidirectional

00:25:54.430 --> 00:25:55.400
text or vertical text in there.

00:25:55.400 --> 00:25:59.590
However,
because it's Unicode-based and because

00:25:59.730 --> 00:26:05.230
the API encourages use of Unicode
and other proper methodologies,

00:26:05.460 --> 00:26:08.000
if you use the text system,
it's highly likely that your

00:26:08.090 --> 00:26:11.380
application will just work with
bidirectional and even vertical text.

00:26:11.400 --> 00:26:13.400
It's also flexible.

00:26:13.400 --> 00:26:15.400
It's got multiple
replaceable classes in there.

00:26:15.400 --> 00:26:17.390
And we'll just talk about the major ones.

00:26:17.400 --> 00:26:20.400
And it has a wide range of intended uses.

00:26:20.400 --> 00:26:22.430
All the text you see
in Cocoa applications,

00:26:22.530 --> 00:26:25.510
ranging from a text field all
the way up to a large text view,

00:26:25.720 --> 00:26:28.400
for instance,
the text area of Project Builder,

00:26:28.400 --> 00:26:31.400
which has colored text and it has
a lot of specialized behavior,

00:26:31.400 --> 00:26:34.290
or the text area in HTML edit,
which has even a totally

00:26:34.370 --> 00:26:38.340
different object model behind it,
is built using the text system.

00:26:38.400 --> 00:26:40.320
It's also powerful.

00:26:40.410 --> 00:26:43.400
Even if you don't want to subclass
and add stuff on your own,

00:26:43.400 --> 00:26:45.400
it has a lot of features out of the box.

00:26:45.400 --> 00:26:48.420
as Mike showed during the demo.

00:26:48.710 --> 00:26:52.660
So there are two, you know,
you can approach a text system

00:26:52.660 --> 00:26:55.500
casually and just use it in your
application without doing anything

00:26:55.500 --> 00:26:57.730
else than just a simple usage.

00:26:57.800 --> 00:26:59.500
And I'll just talk about two of these.

00:26:59.630 --> 00:27:01.390
One of them is NSTextField.

00:27:01.710 --> 00:27:04.600
This is a class that represents,
you know, all of those elements

00:27:04.700 --> 00:27:05.500
in that little window.

00:27:05.500 --> 00:27:09.070
The editable field, the password field,
the non-editable field,

00:27:09.070 --> 00:27:10.300
those are all text fields.

00:27:10.300 --> 00:27:11.820
It's usually one line.

00:27:12.040 --> 00:27:13.460
Could be multiple, but it's usually one.

00:27:13.760 --> 00:27:16.160
It's usually non-rich, but could be rich.

00:27:16.330 --> 00:27:18.480
And it's read-only or editable.

00:27:18.480 --> 00:27:18.480
You can use it for a lot of things.

00:27:18.500 --> 00:27:20.640
So you see both examples there.

00:27:20.690 --> 00:27:23.060
And these are subclasses of NSControl.

00:27:23.090 --> 00:27:25.980
What it means is when the user
enters data and hits return,

00:27:26.030 --> 00:27:28.740
a target action method is sent
so you can take action based

00:27:28.740 --> 00:27:30.170
on what the user changed.

00:27:30.300 --> 00:27:31.660
So it's obvious what the use is.

00:27:31.660 --> 00:27:34.960
It's for text fields and stuff, you know,
little fields that appear.

00:27:34.960 --> 00:27:37.360
The other use is TextView,
the other class.

00:27:37.500 --> 00:27:39.840
This is for more sophisticated editing.

00:27:39.840 --> 00:27:41.330
Typically they're rich.

00:27:41.360 --> 00:27:45.100
You know, they have rulers,
they have color panels, font panels,

00:27:45.100 --> 00:27:47.760
you can drop graphics in there,
and so on.

00:27:47.780 --> 00:27:50.670
It's got a lot of the additional
powerful features of the text

00:27:50.810 --> 00:27:52.830
system accessible directly in there.

00:27:52.990 --> 00:27:55.080
The good news about both of
these cases is they're both

00:27:55.180 --> 00:27:56.840
available in Interface Builder.

00:27:56.890 --> 00:28:00.570
You know, you can say new application,
drag a text field, drag a text view,

00:28:00.570 --> 00:28:05.230
and you can check a few boxes and
most of the features are available.

00:28:05.740 --> 00:28:08.840
Now, so that's the TextView class.

00:28:08.870 --> 00:28:11.240
Let's look at what's beyond TextView.

00:28:11.240 --> 00:28:13.500
We have the LayoutManager class.

00:28:13.840 --> 00:28:17.880
The LayoutManager is the piece of
the text system that coordinates

00:28:18.130 --> 00:28:19.960
the layout of text and so on.

00:28:20.240 --> 00:28:23.910
And we have the text storage,
which Mike talked about earlier,

00:28:23.910 --> 00:28:27.600
which is basically the back end of text,
where the text is actually stored.

00:28:27.600 --> 00:28:30.980
And in fact,
these three pieces form the model, view,

00:28:31.090 --> 00:28:34.350
and controller,
which is what Mike just talked about.

00:28:34.770 --> 00:28:39.190
The text storage stores the text,
the LayoutManager lays text out,

00:28:39.270 --> 00:28:41.310
and TextView displays it.

00:28:42.310 --> 00:28:46.830
OK, so the NSTextStorage class,
which is the model, the back end,

00:28:46.900 --> 00:28:49.200
it basically stores the text
as an attributed string.

00:28:49.270 --> 00:28:54.470
There is a class in
Foundation called NSAttributedString,

00:28:54.470 --> 00:28:56.020
and this is actually a subclass of that.

00:28:56.360 --> 00:28:59.590
NSAttributedString is
basically a NSString,

00:28:59.590 --> 00:29:02.460
meaning it has Unicode characters in it.

00:29:02.670 --> 00:29:05.120
Becky talked about this on Tuesday.

00:29:05.300 --> 00:29:10.200
And then it's got on every character
an NSDictionary of attributes.

00:29:10.370 --> 00:29:13.160
And for efficiency,
we put these on ranges of characters.

00:29:13.270 --> 00:29:14.950
Let me show you a picture.

00:29:15.490 --> 00:29:20.190
Here is a string which contains,
I believe, eight characters.

00:29:20.390 --> 00:29:22.900
Now, because this is Unicode,
we can say there's just

00:29:23.070 --> 00:29:24.960
eight characters in there,
in here.

00:29:25.200 --> 00:29:27.990
If you're not talking Unicode
and you're talking classic one

00:29:28.100 --> 00:29:31.190
or two byte type encodings,
you know, this could be maybe

00:29:31.240 --> 00:29:32.070
ten bytes or whatever.

00:29:32.250 --> 00:29:33.820
You know,
I don't know the exact byte count,

00:29:33.820 --> 00:29:36.200
but it would depend on what
characters are being displayed.

00:29:36.200 --> 00:29:39.410
So there are eight characters here.

00:29:39.800 --> 00:29:42.900
Now,
the first one is an H with an underline.

00:29:42.900 --> 00:29:46.220
So its attributes for that
range of one character is that

00:29:46.290 --> 00:29:49.660
it's got a color of light blue,
it's got a font of Courier 72,

00:29:49.660 --> 00:29:52.560
and it's got an underline
style that's solid.

00:29:52.670 --> 00:29:54.920
Now,
if you look at the next five characters,

00:29:55.010 --> 00:29:58.280
the color there is light blue
and the font is Courier 72.

00:29:58.610 --> 00:30:01.020
We don't have an underline
attribute in that case.

00:30:01.100 --> 00:30:02.810
By default,
if there's an underline attribute,

00:30:02.940 --> 00:30:04.660
it means there's no underline.

00:30:04.850 --> 00:30:08.050
Finally, the last two characters,
they don't have a color attribute,

00:30:08.120 --> 00:30:10.190
which would mean that
we're using the default,

00:30:10.260 --> 00:30:13.880
which means white, actually,
probably black, assume it's reverse.

00:30:14.020 --> 00:30:16.490
And the font there is Osaka 72.

00:30:16.600 --> 00:30:19.500
Now, so there are three ranges here,
three bags of attributes,

00:30:19.500 --> 00:30:21.140
and they apply to these ranges.

00:30:21.240 --> 00:30:24.840
Now, one other thing to say about
attributes is you can have your own

00:30:24.870 --> 00:30:27.030
attributes in these dictionaries.

00:30:27.130 --> 00:30:28.720
For instance,
if you want to have a special

00:30:28.860 --> 00:30:31.360
indexing attribute you add onto text,
you can just add them

00:30:31.420 --> 00:30:33.920
into these dictionaries,
call the attribute whatever you want,

00:30:33.960 --> 00:30:34.660
and you can add any of that.

00:30:34.660 --> 00:30:35.660
You can add any value you want.

00:30:35.660 --> 00:30:38.560
These attributes will be
maintained at the text is edited,

00:30:38.560 --> 00:30:40.090
pushed around, et cetera and so forth.

00:30:40.220 --> 00:30:42.670
So it's, you know,
you can overload these things

00:30:42.670 --> 00:30:46.000
and add your own information on
any range of character you want.

00:30:46.600 --> 00:30:48.310
So the layout manager
is the middle piece,

00:30:48.380 --> 00:30:49.480
the controller.

00:30:49.580 --> 00:30:51.680
It coordinates typesetting of text.

00:30:51.760 --> 00:30:54.830
It reads text from the text storage,
it lays it out into lines,

00:30:54.830 --> 00:30:57.090
and then it gives it to
text view to display.

00:30:57.230 --> 00:30:59.740
So it's the middle coordinator guy.

00:30:59.740 --> 00:31:02.350
The other interesting thing
about layout managers,

00:31:02.350 --> 00:31:05.580
it also stores information
about the laid out text.

00:31:05.580 --> 00:31:10.170
So if you want to ask, where is line one,
or where is, you know,

00:31:10.240 --> 00:31:13.620
where are the characters one through
twenty displayed on the screen,

00:31:13.660 --> 00:31:16.900
and so forth, or what's the bounding box
that this text took up,

00:31:16.900 --> 00:31:18.270
this is the place to go.

00:31:18.280 --> 00:31:19.720
This has APIs to give you that.

00:31:21.590 --> 00:31:25.180
One thing to note about Layout Manager,
in fact the whole text system is,

00:31:25.510 --> 00:31:28.890
you'll note that there are APIs that
are in terms of characters and

00:31:28.890 --> 00:31:32.340
APIs that are in terms of glyphs.

00:31:32.360 --> 00:31:35.050
Most of the time people use the
term characters to mean both,

00:31:35.050 --> 00:31:38.760
but one, the distinction,
the important distinction in our APIs,

00:31:38.860 --> 00:31:42.380
where we sort of have to be exact,
is that characters refer to the

00:31:42.500 --> 00:31:44.380
elements in the text storage.

00:31:44.530 --> 00:31:46.540
Each Unicode character is a character.

00:31:46.820 --> 00:31:49.550
And when we say character range,
we're talking about the

00:31:49.550 --> 00:31:51.020
range in the text storage.

00:31:51.080 --> 00:31:53.470
Glyphs are the displayable elements.

00:31:53.740 --> 00:31:58.240
Glyphs are usually elements of fonts,
and they're computed as a

00:31:58.240 --> 00:32:00.660
result of laying the text out.

00:32:00.660 --> 00:32:02.920
And the characters and
glyphs are distinct.

00:32:02.980 --> 00:32:05.170
And in fact,
one character might lead to two,

00:32:05.170 --> 00:32:07.600
three glyphs,
or maybe several characters can

00:32:07.710 --> 00:32:10.400
be combined to show one glyph.

00:32:10.400 --> 00:32:14.290
And which glyphs get shown, display,
which glyphs are shown

00:32:14.290 --> 00:32:17.110
basically depends on the font.

00:32:17.330 --> 00:32:19.070
Let me give you an example.

00:32:19.130 --> 00:32:21.980
Most good text systems
would take an F and an I,

00:32:22.070 --> 00:32:24.100
the two characters,
and put them together to

00:32:24.230 --> 00:32:25.730
display the ligature FI.

00:32:25.750 --> 00:32:29.290
So the,
the ligature is really just one glyph.

00:32:29.320 --> 00:32:32.640
So the character range that contains
two characters corresponds to a glyph

00:32:32.760 --> 00:32:34.900
range that only contains one glyph.

00:32:34.900 --> 00:32:37.080
So, you know,
if you look at the NSLayoutManager API,

00:32:37.080 --> 00:32:40.110
keep this distinction in mind,
because it's important.

00:32:40.500 --> 00:32:42.460
Finally,
a little more detail about the TextView,

00:32:42.460 --> 00:32:44.750
the view part of the whole picture.

00:32:44.980 --> 00:32:46.580
It's the user interaction layer.

00:32:46.580 --> 00:32:47.590
It displays the glyphs.

00:32:47.650 --> 00:32:53.030
It also handles all the events, key up,
key down, et cetera, all go to TextView.

00:32:53.050 --> 00:32:56.610
It also deals with the ruler, the font,
and all the other color panels,

00:32:56.610 --> 00:33:00.940
and all the other user elements
that basically the user is doing.

00:33:01.000 --> 00:33:03.480
It also turns out that if you
want to have multiple columns,

00:33:03.610 --> 00:33:07.720
multiple pages, multiple weird areas,
you just have multiple TextViews that

00:33:07.720 --> 00:33:10.150
are attached to the same layout manager.

00:33:10.520 --> 00:33:13.960
Now one thing to note here is
that NSTextView is a subclass

00:33:14.070 --> 00:33:18.340
of a class called NSText,
which in turn is a subclass of NSView.

00:33:18.340 --> 00:33:20.700
And NSText is a sort of a
legacy class that's in there.

00:33:20.700 --> 00:33:24.940
NSTextView is a class you should use,
but for the whole picture, the whole API,

00:33:24.940 --> 00:33:27.580
you should really look at
both TextView and text,

00:33:27.760 --> 00:33:30.820
and think of those as the
combined API for TextView.

00:33:30.900 --> 00:33:33.890
It turns out you can do most things
with the text system using TextView,

00:33:34.200 --> 00:33:37.580
but for more sophisticated usages you
would go beyond TextView and talk to

00:33:37.580 --> 00:33:40.550
the layout manager or text storage.

00:33:40.570 --> 00:33:42.840
So just to recap,
text storage stores the text,

00:33:42.840 --> 00:33:45.430
layout manager lays it out,
and TextView displays it.

00:33:47.620 --> 00:33:53.160
and two other interesting text system
components are the TextContainer class.

00:33:53.230 --> 00:33:55.720
TextContainers display,
they basically describe the

00:33:55.720 --> 00:33:57.500
areas that text should flow into.

00:33:57.500 --> 00:34:00.730
In fact, you can use a TextContainer to
describe a donut-shaped area,

00:34:01.060 --> 00:34:02.380
whatever you want.

00:34:02.450 --> 00:34:04.440
It basically describes the area.

00:34:04.580 --> 00:34:08.500
It turns out there is one
TextContainer per TextView.

00:34:08.530 --> 00:34:10.720
And in fact,
it turns out that you can rip out

00:34:10.720 --> 00:34:14.420
the TextView from this equation and
just leave the TextContainer and have

00:34:14.480 --> 00:34:17.390
a text system that doesn't display,
but instead can be used

00:34:17.390 --> 00:34:19.410
to lay out a newspaper,
for instance,

00:34:19.410 --> 00:34:21.280
in the back end without ever
displaying it because it's going

00:34:21.340 --> 00:34:22.490
to the printers or whatever.

00:34:22.500 --> 00:34:26.490
So TextContainer is the part of
TextView that describes the area.

00:34:26.500 --> 00:34:28.500
And finally we have Typesetter.

00:34:28.500 --> 00:34:30.410
There is usually one instance of this.

00:34:30.530 --> 00:34:33.500
Typesetter's purpose is to get
the glyphs and put them on a line.

00:34:33.560 --> 00:34:34.390
And then you can use the
glyphs to describe the area.

00:34:34.570 --> 00:34:36.500
And basically do all the justification.

00:34:36.500 --> 00:34:40.500
So Typesetter is invoked by LayoutManager
as a part of laying out the text.

00:34:43.070 --> 00:34:44.800
Okay, so much for text.

00:34:44.800 --> 00:34:47.740
Now I want to talk a
bit about performance.

00:34:47.820 --> 00:34:50.350
It turns out there's a performance
session going on right now,

00:34:50.350 --> 00:34:52.790
which you're all missing,
so we figured we might,

00:34:52.790 --> 00:34:55.300
we'd give you some of the interesting
aspects of that talk here,

00:34:55.440 --> 00:34:58.230
especially how it relates to Cocoa.

00:35:01.430 --> 00:35:04.750
So in the context of Cocoa application,
and in general actually,

00:35:04.750 --> 00:35:07.740
Mac OS X as well,
there are certain causes

00:35:07.740 --> 00:35:09.960
for performance issues.

00:35:10.000 --> 00:35:13.650
Memory, or the lack thereof,
network or disk operations,

00:35:13.760 --> 00:35:16.760
or too much of them, too much drawing,
and polling.

00:35:16.840 --> 00:35:19.360
So these turn out to be major concerns.

00:35:19.360 --> 00:35:22.790
It turns out that pure
CPU usage is rarely the problem.

00:35:22.790 --> 00:35:25.180
I mean,
typically if your application is slow,

00:35:25.300 --> 00:35:28.930
you're rarely going to find that
it's because of lack of CPU power.

00:35:28.930 --> 00:35:33.490
But of course it happens, you know,
bad algorithms can strike anywhere.

00:35:34.630 --> 00:35:37.030
So let's talk about memory.

00:35:37.030 --> 00:35:40.970
One cause for problem is maybe one
problem that you might not have on

00:35:40.970 --> 00:35:43.500
Mac OS is window backing stores.

00:35:43.500 --> 00:35:48.450
Both Carbon and Cocoa apps all have
backing stores corresponding to

00:35:48.540 --> 00:35:50.500
every window that's on the screen.

00:35:50.610 --> 00:35:52.580
In fact, every window that's
even not on the screen.

00:35:52.580 --> 00:35:56.550
So if you have a 1K by 1K
window that's 32 bits deep,

00:35:56.550 --> 00:35:59.820
that's, I think,
4 megabytes of memory right

00:35:59.930 --> 00:36:01.690
there for that window.

00:36:03.000 --> 00:36:05.230
And of course,
this window backing store is

00:36:05.230 --> 00:36:08.130
something that's used to give
you a really nice display,

00:36:08.130 --> 00:36:09.380
flicker free, and so on.

00:36:09.380 --> 00:36:12.450
Another reason is the
custom heap management.

00:36:12.540 --> 00:36:14.950
A lot of applications might be
doing their own heap management,

00:36:15.040 --> 00:36:18.220
especially on Mac OS,
and this turns out to cause,

00:36:18.220 --> 00:36:22.720
this turns out to be a potential
problem for apps running on Mac OS X.

00:36:22.720 --> 00:36:24.550
Finally, failure to release memory.

00:36:24.550 --> 00:36:26.690
You know,
just leaking it or holding onto it too

00:36:26.690 --> 00:36:28.730
much turns out to be a potential problem.

00:36:28.740 --> 00:36:31.500
So window backing stores, as I said,
windows are by default windows.

00:36:31.500 --> 00:36:33.350
buffered.

00:36:33.510 --> 00:36:38.080
Also, NSImages,
which is the image displaying

00:36:38.080 --> 00:36:41.510
component in Cocoa,
NSImage will sometimes use caches,

00:36:41.510 --> 00:36:44.250
which are basically
window backing stores,

00:36:44.250 --> 00:36:45.470
to cache images in.

00:36:45.790 --> 00:36:47.470
And again, you know,
you load hundreds of images,

00:36:47.520 --> 00:36:49.980
that could add up to a few
megabytes in your application.

00:36:49.980 --> 00:36:54.480
Now, there are tools to look at these,
and I'll mention these in a few minutes,

00:36:54.490 --> 00:36:56.980
but there are a few
solutions in this area.

00:36:56.980 --> 00:37:00.000
You can make your windows one shot,
which means when the window

00:37:00.000 --> 00:37:00.000
is no longer on the display,
you can load a few images in there.

00:37:00.000 --> 00:37:02.860
It's memory is released,
and every time the window

00:37:02.870 --> 00:37:06.300
comes back on the display,
a memory region is created for it,

00:37:06.460 --> 00:37:09.000
and then the window is displayed.

00:37:09.040 --> 00:37:12.760
And you can assure that NSImages
are not creating caches,

00:37:12.760 --> 00:37:15.420
and there are several ways to do this.

00:37:16.300 --> 00:37:19.290
So one other solution that
you might think about is why

00:37:19.430 --> 00:37:20.950
use the buffering at all?

00:37:21.060 --> 00:37:26.110
And it turns out that using buffering
allows Windows to be flicker-free.

00:37:26.230 --> 00:37:29.250
If we didn't have buffering,
when you do that lovely window

00:37:29.250 --> 00:37:32.730
moving on top of other windows,
all the exposed regions would

00:37:32.730 --> 00:37:35.390
have to constantly be drawing
themselves to keep up with,

00:37:35.460 --> 00:37:37.370
you know, keep up with the users moving.

00:37:37.370 --> 00:37:39.630
And, you know,
that's a bit Windows-like maybe,

00:37:39.630 --> 00:37:44.230
and it's a bit, you know,
not in the spirit of Aqua.

00:37:44.640 --> 00:37:46.780
Custom heap management.

00:37:46.790 --> 00:37:51.540
Again, a lot of apps, you know,
in order to assure that they have

00:37:51.540 --> 00:37:54.440
enough memory to complete an operation
might be allocating large blocks of

00:37:54.440 --> 00:37:56.340
memory which they carve themselves.

00:37:56.430 --> 00:38:00.340
Maybe the memory that they used before in
Mac OS 9 was not quite enough for them.

00:38:00.490 --> 00:38:02.380
It didn't do the right
interrupt handling,

00:38:02.380 --> 00:38:03.000
whatever.

00:38:03.130 --> 00:38:06.970
It turns out that this is bad
because it just causes fragmentation.

00:38:07.000 --> 00:38:10.460
If every subsystem allocated one
megabyte for no use and carved it out,

00:38:10.750 --> 00:38:12.650
there are all these little
pieces of memory that are

00:38:12.650 --> 00:38:14.000
not being used in the system.

00:38:14.160 --> 00:38:17.230
And perhaps they're being kept hot
because the custom memory management

00:38:17.230 --> 00:38:18.930
ends up touching all of those bytes.

00:38:19.000 --> 00:38:22.480
And another disadvantage here is
that standard tools to track memory,

00:38:22.480 --> 00:38:25.410
which we'll show you one of, you know,
it won't work.

00:38:25.510 --> 00:38:27.500
It doesn't know how this
memory is allocated.

00:38:27.500 --> 00:38:30.510
So the solution here is just to
use the standard memory system,

00:38:30.510 --> 00:38:33.000
the standard malloc that
comes with the system.

00:38:33.000 --> 00:38:34.500
It's pretty powerful.

00:38:34.500 --> 00:38:36.000
It covers a wide range of uses.

00:38:36.000 --> 00:38:39.400
It should be good enough for
almost all uses on Mac OS X.

00:38:39.500 --> 00:38:43.280
Finally, failure to release memory
is the last point here.

00:38:43.710 --> 00:38:48.020
As Becky mentioned,
Cocoa introduces reference counting where

00:38:48.020 --> 00:38:50.420
objects can retain each other and so on.

00:38:50.500 --> 00:38:55.710
So one problem is that, you know,
you simply retain something or you have

00:38:55.790 --> 00:38:58.500
a copy of it and you don't release it.

00:38:58.500 --> 00:38:59.500
Well, that's an obvious memory leak.

00:38:59.500 --> 00:39:00.500
You know, you have to release it.

00:39:00.500 --> 00:39:05.240
Another problem is sometimes one
object can retain another object and

00:39:05.500 --> 00:39:08.000
that object in return retains me.

00:39:08.000 --> 00:39:10.000
So these two objects are
retaining each other.

00:39:10.000 --> 00:39:11.920
They might be totally useless,
but they're just sitting

00:39:12.000 --> 00:39:12.980
around not getting freed.

00:39:13.160 --> 00:39:16.990
And to solve that,
you really need to be consistent

00:39:16.990 --> 00:39:20.000
in how you do retains and releases.

00:39:20.000 --> 00:39:23.350
One guideline we use is if you
have parent-child type things,

00:39:23.350 --> 00:39:27.000
you know,
where you have a hierarchy of objects,

00:39:27.000 --> 00:39:29.000
typically the top level objects
retain the lower level objects

00:39:29.000 --> 00:39:31.840
and the lower level objects,
even if they point to

00:39:31.840 --> 00:39:35.000
the higher level objects,
do not retain the higher level objects.

00:39:35.610 --> 00:39:38.000
Another case is loose connections.

00:39:38.000 --> 00:39:41.000
For instance, in Cocoa we have delegates,
outlets, targets.

00:39:41.000 --> 00:39:41.990
Those are typically entities
pointing to objects.

00:39:42.060 --> 00:39:44.000
Typically entities
pointing at each other.

00:39:44.000 --> 00:39:46.930
Typically those loose connections
do not involve retains,

00:39:47.000 --> 00:39:51.000
meaning an object does not retain
its delegate or its targets.

00:39:51.000 --> 00:39:54.000
Because those are all entities that
are objects in their own regard.

00:39:54.000 --> 00:39:57.000
So the performance tools
to track malloc memory,

00:39:57.000 --> 00:39:59.990
there's object alloc and malloc debug.

00:40:00.000 --> 00:40:01.990
I believe we'll show you
object alloc in a few minutes.

00:40:02.000 --> 00:40:04.770
To track all memory,
meaning everything an app

00:40:04.860 --> 00:40:08.370
might be touching that includes
all the shared frameworks,

00:40:08.480 --> 00:40:13.000
etc., there is tools like TOPS and PS,
which you run on the command line.

00:40:13.000 --> 00:40:17.000
Now, if you run these and you see V size,
which means virtual size,

00:40:17.000 --> 00:40:19.000
you might at first be shocked.

00:40:19.000 --> 00:40:21.000
You'll see numbers like 80 megabytes.

00:40:21.120 --> 00:40:24.550
That includes all of the shared
frameworks and all the other things

00:40:24.550 --> 00:40:26.930
that are shared across the system.

00:40:27.000 --> 00:40:29.770
So that's not really the number that's,
you know,

00:40:29.770 --> 00:40:32.000
what your app is actually occupying.

00:40:32.000 --> 00:40:35.470
But looking at number and seeing
whether it's growing or getting

00:40:35.480 --> 00:40:38.990
smaller and looking at trends at
that number is still interesting.

00:40:39.970 --> 00:40:42.000
Finally, the track window backing stores.

00:40:42.060 --> 00:40:45.890
There's no tool on DP4, no obvious,
no easy way to do it,

00:40:46.020 --> 00:40:47.950
but Chris will show you a tool that's,
I think,

00:40:47.950 --> 00:40:50.520
going to be released pretty soon.

00:40:50.690 --> 00:40:52.710
So quickly, the other reasons.

00:40:52.720 --> 00:40:55.460
Network or disk operations.

00:40:55.460 --> 00:40:57.440
These take a long time,
relatively speaking,

00:40:57.570 --> 00:41:01.500
and you probably all know you've
had to deal with these things.

00:41:01.500 --> 00:41:04.240
These might have an unpredictable
effect on performance because

00:41:04.330 --> 00:41:07.600
sometimes the disk is slow,
sometimes network is slow.

00:41:07.600 --> 00:41:09.960
One thing to watch out
for is on Mac OS X,

00:41:09.960 --> 00:41:14.400
user directories can be either on a local
machine or they can be in a network.

00:41:14.400 --> 00:41:17.980
And we go to the user directory
to read stuff like preferences,

00:41:18.030 --> 00:41:20.700
or you might put caches
there or other documents.

00:41:20.790 --> 00:41:22.930
If you always test in the
context of a local user,

00:41:23.060 --> 00:41:25.760
and then you might find that
on the network user case,

00:41:25.760 --> 00:41:29.060
where the network access is much slower,
you might find that things are

00:41:29.060 --> 00:41:34.310
just way slower and you weren't
prepared for network accesses.

00:41:34.310 --> 00:41:34.310
So.

00:41:35.190 --> 00:41:38.860
and the thing here is obviously
you should avoid or delay or call

00:41:38.860 --> 00:41:40.650
us operations that touch the disk.

00:41:40.780 --> 00:41:42.500
For instance,
if you're writing preferences out,

00:41:42.650 --> 00:41:45.010
don't write them out every
time something gets changed.

00:41:45.100 --> 00:41:46.830
Maybe wait to write them out at the end.

00:41:47.190 --> 00:41:50.790
Cocoa applications actually write out
the preferences when they're quitting,

00:41:50.870 --> 00:41:54.600
so you could just let the Cocoa system do
it for you when you update preferences.

00:41:54.690 --> 00:41:57.790
There are tools, Sampler,
I believe Chris might show that,

00:41:57.890 --> 00:41:58.960
and FS usage.

00:41:59.260 --> 00:42:04.080
FS usage is a command line tool which
will show you all file system calls that

00:42:04.090 --> 00:42:04.580
a process or the whole system calls.

00:42:05.100 --> 00:42:06.040
whole system is doing.

00:42:06.040 --> 00:42:08.690
It's pretty entertaining
if you haven't seen it.

00:42:09.760 --> 00:42:11.810
I'm entertaining in a sad sort of way.

00:42:11.820 --> 00:42:16.700
Drawing too many times is
another common problem.

00:42:16.700 --> 00:42:18.750
Sometimes in object
oriented environments,

00:42:18.830 --> 00:42:21.700
because multiple subsystems
might be doing drawing,

00:42:21.700 --> 00:42:24.700
two different subsystems might
cause update of an element

00:42:24.700 --> 00:42:27.700
and you just might not notice,
it might not be obvious.

00:42:27.770 --> 00:42:33.520
NSView, the abstract drawing class,
actually provides facilities for

00:42:33.930 --> 00:42:35.700
managing and coalescing dirty regions.

00:42:35.700 --> 00:42:38.570
So instead of causing
a display immediately,

00:42:38.570 --> 00:42:42.240
you should call set needs display,
which records in NSView that

00:42:42.240 --> 00:42:45.270
this region updated,
and eventually it will display

00:42:45.270 --> 00:42:46.630
at the appropriate time.

00:42:46.700 --> 00:42:49.210
We have various tools,
and again I think Chris might

00:42:49.280 --> 00:42:54.700
show one of them I mentioned,
that show you displaying as it happens,

00:42:54.700 --> 00:42:58.270
so it gives you an idea
of what's going on.

00:42:58.450 --> 00:42:59.560
Finally, polling.

00:42:59.800 --> 00:43:00.460
Polling is bad.

00:43:00.460 --> 00:43:03.950
Sometimes polling is used,
I think sometimes Mac OS 9

00:43:03.960 --> 00:43:08.030
applications use polling more than,
say, on Mac OS X.

00:43:08.030 --> 00:43:11.420
Polling is bad because it
keeps applications awake,

00:43:11.420 --> 00:43:15.740
the kernel has to schedule them in,
the applications memory is kept hot,

00:43:15.740 --> 00:43:18.210
and it also interferes with power
management and with scheduling.

00:43:18.210 --> 00:43:20.610
I mean, the kernel is trying to
schedule applications,

00:43:20.610 --> 00:43:23.330
and there's an application that
every tenth of a second says,

00:43:23.380 --> 00:43:24.370
anything happening?

00:43:24.370 --> 00:43:25.340
Anything happening?

00:43:25.340 --> 00:43:26.300
Anything happening?

00:43:26.310 --> 00:43:28.350
You know, you eventually, you know,
you get,

00:43:28.420 --> 00:43:31.340
you can see how it could be a problem.

00:43:31.340 --> 00:43:33.460
So the solutions are,
there are pretty good

00:43:33.460 --> 00:43:34.780
solutions in the system.

00:43:34.790 --> 00:43:38.750
There are event mechanisms both in
Carbon and Cocoa that let you catch

00:43:38.760 --> 00:43:41.390
events when interesting things happen.

00:43:41.640 --> 00:43:42.730
Mouse down happened.

00:43:42.940 --> 00:43:44.420
Mouse move happened, et cetera.

00:43:44.700 --> 00:43:47.640
Rather than you sitting there
polling the mouse location.

00:43:47.640 --> 00:43:51.040
And there are also notifications
that will tell you that

00:43:51.080 --> 00:43:52.600
certain things changed.

00:43:52.600 --> 00:43:54.890
Another thing is,
even if you can't avoid polling,

00:43:54.890 --> 00:43:56.800
maybe you can do polling at key points.

00:43:56.800 --> 00:44:00.110
When your application becomes active,
you could update the state of some

00:44:00.110 --> 00:44:02.020
certain thing that you're displaying.

00:44:02.080 --> 00:44:05.310
Perhaps when your app is active,
the chance that it's being displayed,

00:44:05.310 --> 00:44:09.290
changed behind you are very small,
so it's not interesting to update.

00:44:09.450 --> 00:44:13.640
And Sampler and Tops will again
show you the cases for polling.

00:44:13.710 --> 00:44:19.420
OK, so I will now invite Chris Kane on
stage for a demo of some of these tools.

00:44:27.500 --> 00:44:29.840
Let's see.

00:44:29.840 --> 00:44:34.700
In the short time we have,
I don't have nearly enough time to

00:44:34.700 --> 00:44:41.140
go into any detail on these apps
as far as how you go about to use

00:44:41.140 --> 00:44:43.830
them to solve particular problems.

00:44:43.840 --> 00:44:51.220
I just want to show that the apps
exist and generally what they're about.

00:44:51.220 --> 00:44:55.330
The first app here I've
launched is Sampler.

00:44:55.950 --> 00:45:02.000
and I am going to choose TextEdit.

00:45:02.540 --> 00:45:06.150
I'm going to sample the launch of Texted.

00:45:06.280 --> 00:45:13.350
And so what I've done is I have just hit
the button that said Launch and Sample.

00:45:13.410 --> 00:45:15.410
And now it's done.

00:45:16.600 --> 00:45:24.500
and what we have is a call graph on
the left to the center of the window.

00:45:24.500 --> 00:45:31.250
And this is showing the call stacks
that Sampler found the app in,

00:45:31.650 --> 00:45:32.500
if you will.

00:45:32.500 --> 00:45:37.580
What Sampler is doing is every,
in my case, 50 milliseconds,

00:45:37.580 --> 00:45:40.500
it's going out to the other app,
it's stopping it,

00:45:40.500 --> 00:45:42.500
it's going and plundering
around in the application,

00:45:42.500 --> 00:45:45.500
finding out where all the threads are,
what they're doing,

00:45:45.500 --> 00:45:47.500
and it's recording that information.

00:45:47.500 --> 00:45:51.680
And so what it's displaying in
the call graph is the sort of

00:45:51.680 --> 00:45:58.610
coalesced call tree view of that,
of what was going on.

00:45:59.070 --> 00:46:05.970
Over in the call stack list,
over on the far right,

00:46:06.000 --> 00:46:13.360
what's going on is Sampler
has chosen the hottest frame,

00:46:13.360 --> 00:46:20.460
hottest node at every frame in this
coalesce call graph to show you

00:46:20.530 --> 00:46:24.270
what's the hottest thing going on.

00:46:24.470 --> 00:46:29.350
What we're seeing here in this
case is the app spent most of

00:46:29.350 --> 00:46:31.530
its time while it was sampling.

00:46:31.580 --> 00:46:35.680
It launched very quickly and
then I let it run a little bit.

00:46:35.680 --> 00:46:38.560
And it has spent most of its
time just blocked waiting.

00:46:38.560 --> 00:46:40.640
So that's what this is doing.

00:46:40.640 --> 00:46:43.340
We see NS application run.

00:46:43.340 --> 00:46:45.840
It's looking for a next event.

00:46:45.840 --> 00:46:48.240
And a lot of internal routines here.

00:46:48.240 --> 00:46:50.950
We see CF run loop is being run.

00:46:51.040 --> 00:46:54.840
So we're going down into
the layers of the system.

00:46:54.840 --> 00:46:58.720
And eventually we trap into the
kernel and we're blocked in the kernel

00:46:58.870 --> 00:47:02.020
waiting for an event to come in,
a user input event.

00:47:02.020 --> 00:47:07.500
Now I haven't clicked over here so no
user input events have come into the app.

00:47:07.500 --> 00:47:11.050
Certainly not while I was sampling.

00:47:11.360 --> 00:47:14.400
So, one thing I just wanted to
point out while I was here

00:47:14.410 --> 00:47:19.350
is that it's very normal,
very normal to see this sort of

00:47:19.350 --> 00:47:24.800
backtrace that if you find your app
in the situation where Mach message

00:47:24.870 --> 00:47:28.440
overwrite trap is stuck in,
essentially,

00:47:28.440 --> 00:47:30.770
that is normal and that is good.

00:47:30.820 --> 00:47:33.840
And we want apps to be very quiet,
not doing anything while

00:47:33.840 --> 00:47:37.410
they're in the background,
like text that's in the background.

00:47:39.020 --> 00:47:42.950
If I sample, again, here,
let me crank this down

00:47:42.960 --> 00:47:45.090
to one millisecond.

00:47:45.350 --> 00:47:49.120
So every one millisecond,
stopping the app and sampling.

00:47:49.170 --> 00:47:54.580
Now, one thing to note is that I have
not built a special text edit here.

00:47:54.580 --> 00:47:58.320
This is just the text edit
that comes on the system.

00:47:58.340 --> 00:48:00.050
I don't know if there's any
way for me to prove that.

00:48:00.140 --> 00:48:03.060
I guess you'll just
have to trust me there.

00:48:03.100 --> 00:48:06.970
But to sample an app,
you do not need to specially

00:48:07.210 --> 00:48:10.980
build a profile version of
the app or anything like that.

00:48:10.980 --> 00:48:15.570
And so what we see is,
while I was sampling, all the samples,

00:48:15.680 --> 00:48:20.840
all 5,439 of them,
are stuck in Mach message override trap,

00:48:20.880 --> 00:48:22.310
waiting for events to come in.

00:48:22.420 --> 00:48:27.980
So that would wake up, for example,
when I click the window there and go

00:48:27.980 --> 00:48:30.700
and do some drawing and stuff like that.

00:48:30.910 --> 00:48:31.940
So that's Sampler.

00:48:31.950 --> 00:48:34.400
That's just a very quick look.

00:48:34.400 --> 00:48:37.480
The best way to find out more about
these applications is to go in and

00:48:37.580 --> 00:48:38.890
play with them and see what they do.

00:48:38.900 --> 00:48:43.500
The next app I'm going to
show you is Object Alloc.

00:48:43.600 --> 00:48:57.550
Object Alloc is a way of looking at
the memory usage of an application.

00:48:57.550 --> 00:48:57.550
I'm going to choose TextEdit again,
and I'm going to choose the binary.

00:48:57.860 --> 00:49:01.840
So here we see the Object Alloc window.

00:49:01.840 --> 00:49:04.040
The first button over
here is the Start button.

00:49:04.040 --> 00:49:05.800
I'm going to start up the task.

00:49:05.800 --> 00:49:07.700
Now it's launching TextEdit.

00:49:07.830 --> 00:49:13.800
What we see here is the histogram of
various categories of allocations.

00:49:13.800 --> 00:49:18.970
Object Alloc is seeing all
the allocations that are done

00:49:18.970 --> 00:49:23.680
by the application and is
categorizing them as best it can.

00:49:23.870 --> 00:49:30.290
In some ways it's more sophisticated,
and in some places it really doesn't

00:49:30.350 --> 00:49:36.580
know how to categorize an allocation,
so it just gives it a generic moniker.

00:49:36.800 --> 00:49:41.800
Now the font is probably too
small for you to see there,

00:49:42.190 --> 00:49:48.020
but the first column is a category,
and the category name in the

00:49:48.150 --> 00:49:50.800
first row here is ZoneMalloc22.

00:49:50.800 --> 00:49:53.800
And what that means is just
a generic allocation occurs.

00:49:53.800 --> 00:49:57.800
So we have a column that's
the number of blocks,

00:49:57.800 --> 00:50:02.800
which are 22 bytes in length,
that are currently still allocated.

00:50:02.800 --> 00:50:06.600
And the other most interesting
column is the total column,

00:50:06.900 --> 00:50:09.800
which I've selected here
and we're sorting on.

00:50:10.070 --> 00:50:14.320
And that shows that
2,075 of these blocks,

00:50:14.320 --> 00:50:20.660
blocks of length 22, were allocated while
the program was running.

00:50:20.800 --> 00:50:22.800
One interesting feature we've added since
DP3 is that we've added a new column.

00:50:22.800 --> 00:50:23.800
We've added a new column.

00:50:23.800 --> 00:50:24.780
We've added a new column.

00:50:24.810 --> 00:50:26.110
And what's interesting about DP3,
and what's interesting

00:50:26.110 --> 00:50:28.440
about Object Alloc,
is that we understand

00:50:28.440 --> 00:50:29.800
some of the CF types.

00:50:29.800 --> 00:50:34.800
So in the second row,
you see CFStrings collected,

00:50:34.800 --> 00:50:38.800
and it identifies these particular
strings as the immutable ones.

00:50:39.000 --> 00:50:41.800
And I'm going to go over
it in the second tab here.

00:50:41.800 --> 00:50:47.330
And if I click on CFString, immutable,
here it's showing me a list of all

00:50:47.420 --> 00:50:50.730
the CFStrings that are currently
allocated in the application.

00:50:50.800 --> 00:50:52.800
So if I click on one,
it's showing me the content.

00:50:52.800 --> 00:50:55.830
It's showing me the contents
of the string down here,

00:50:55.830 --> 00:50:56.750
for example.

00:50:56.800 --> 00:50:59.800
There's a string with
.global_preferences.

00:50:59.800 --> 00:51:01.800
There's a string with a path in it.

00:51:01.800 --> 00:51:02.800
Thank you.

00:51:04.670 --> 00:51:11.730
So that also works for
other types of objects,

00:51:11.850 --> 00:51:16.000
so CFArray,
the mutable variable kind of CFArray.

00:51:16.000 --> 00:51:18.100
Here it's showing the debug description.

00:51:18.100 --> 00:51:19.520
This is an empty array.

00:51:19.600 --> 00:51:20.420
The count is zero.

00:51:20.600 --> 00:51:23.600
Let's see,
is there one with something interesting?

00:51:23.600 --> 00:51:26.600
A lot of empty arrays are pretty common.

00:51:26.600 --> 00:51:30.580
There's an array with one thing
in it which looks like a string,

00:51:30.620 --> 00:51:33.530
a path to the application I launched,
in fact.

00:51:33.600 --> 00:51:36.590
And so on.

00:51:36.590 --> 00:51:40.150
So here's CF set,
and here's a description of a nasty

00:51:40.150 --> 00:51:42.580
CF set with a bunch of stuff in it.

00:51:42.600 --> 00:51:47.790
So that's Object Alloc.

00:51:48.190 --> 00:51:50.900
The last thing,
and there are other things

00:51:50.920 --> 00:51:52.500
you can do with Object Alloc.

00:51:52.500 --> 00:51:55.040
I suggest running it,
playing around with it a little bit.

00:51:55.170 --> 00:51:58.270
Here, I'm going to demonstrate
this in a moment,

00:51:58.420 --> 00:52:04.220
what's going on when this happens,
but you can scale the view, for example,

00:52:04.220 --> 00:52:07.820
sort by the different columns, and so on.

00:52:07.820 --> 00:52:11.130
The last thing I want to show,
let me stop that.

00:52:11.500 --> 00:52:17.540
is, let's move it over here,
this new tool Ali alluded

00:52:17.540 --> 00:52:20.260
to called Quartz Debug.

00:52:20.290 --> 00:52:23.040
It might not be called Quartz
Debug when we release it,

00:52:23.160 --> 00:52:24.560
but hopefully it will be released soon.

00:52:24.560 --> 00:52:28.720
It's not in DP4,
but it goes in and talks to

00:52:28.720 --> 00:52:32.300
the Core Graphics server,
the Windows server, Window Manager,

00:52:32.300 --> 00:52:38.690
and tells it to turn on various
graphical debugging features.

00:52:38.700 --> 00:52:43.070
So I'm gonna, let's see, what...

00:52:43.390 --> 00:52:45.780
Let's turn on all of these.

00:52:45.920 --> 00:52:49.400
So what we see,
what we saw briefly there,

00:52:49.450 --> 00:52:57.470
is the bits of the window that are
being redrawn are first drawn in yellow.

00:52:57.680 --> 00:53:00.490
And then they're drawn
with their true content.

00:53:00.640 --> 00:53:06.010
So if I click on a button, for example,

00:53:07.160 --> 00:53:10.800
We see, it's hard to see that the
button is actually being

00:53:10.800 --> 00:53:12.990
redrawn since it's so quick.

00:53:13.000 --> 00:53:17.990
Let me turn on the delay.

00:53:17.990 --> 00:53:18.000
If we turn on the delay,

00:53:22.270 --> 00:53:27.770
We see the very labor-intensive
process that graphical drawing

00:53:27.770 --> 00:53:33.960
goes through to produce a window as
complicated as Object Alloc's window.

00:53:34.100 --> 00:53:38.540
So here we see the tab view being drawn.

00:53:38.700 --> 00:53:43.570
There, that background pattern is
being blatted onto the screen.

00:53:44.300 --> 00:53:52.800
[Transcript missing]

00:53:54.500 --> 00:54:00.000
[Transcript missing]

00:54:00.460 --> 00:54:01.400
and so on.

00:54:01.530 --> 00:54:06.800
So turning on the delay allows you to
see where you have redundant drawing.

00:54:06.800 --> 00:54:08.800
I'm going to turn that off.

00:54:08.800 --> 00:54:11.720
That's just too painful.

00:54:18.310 --> 00:54:25.190
Okay, so we've recovered.

00:54:25.220 --> 00:54:28.000
But I've, I've, I've,
so I turned off the delay,

00:54:28.000 --> 00:54:31.200
and now we're just, you know,
every time the window

00:54:31.200 --> 00:54:32.760
has to become inactive,
of course,

00:54:32.760 --> 00:54:36.920
we have to redraw all the controls
because they're now gray instead of blue,

00:54:36.920 --> 00:54:38.610
and, and things like that.

00:54:38.840 --> 00:54:41.470
One thing I've noticed,
as far as debugging here,

00:54:41.520 --> 00:54:46.620
is that if I choose a different column,
you can see, if you look closely,

00:54:46.670 --> 00:54:49.290
that the whole outline
view is being redrawn.

00:54:49.460 --> 00:54:51.970
And that's probably correct and okay.

00:54:51.970 --> 00:54:58.390
If I, you know, change the view around,
the outline view is just drawn once.

00:54:58.700 --> 00:55:03.250
But if I change the slider here,
do you see that?

00:55:03.390 --> 00:55:06.390
It's being redrawn twice.

00:55:10.720 --> 00:55:12.800
Really obvious if I do it out here.

00:55:13.050 --> 00:55:13.180
Nope.

00:55:13.300 --> 00:55:13.850
There.

00:55:13.850 --> 00:55:14.350
Twice.

00:55:14.580 --> 00:55:17.420
And in fact,
the slider is also being drawn twice,

00:55:17.420 --> 00:55:21.060
so that's a little more subtle,
and you might not be able to see

00:55:21.060 --> 00:55:23.100
that going on up in the screen.

00:55:23.100 --> 00:55:28.740
So I probably have a bug here that
when I'm readjusting the scaling,

00:55:28.740 --> 00:55:32.060
I'm over-displaying the system.

00:55:32.060 --> 00:55:34.570
I might have a direct call to
the display method in there,

00:55:34.570 --> 00:55:38.970
for example,
rather than doing set needs display

00:55:39.000 --> 00:55:42.270
and letting the app kit display system

00:55:42.810 --> 00:55:44.640
will take care of that for me.

00:55:44.780 --> 00:55:48.580
I'd like to call Ali back.

00:55:48.580 --> 00:55:48.580
Where did he go?

00:55:53.000 --> 00:57:18.000
[Transcript missing]

00:57:18.630 --> 00:57:23.140
So examples of Carbon APIs you can
use from Cocoa include Quick Draw,

00:57:23.180 --> 00:57:25.890
Apple Events, File Manager,
Resource Manager,

00:57:25.890 --> 00:57:29.470
Text and Coding Converter, Speech,
and anything else that comes from

00:57:29.480 --> 00:57:31.610
low-level Carbon or application services.

00:57:31.740 --> 00:57:34.170
And of course, Core Foundation.

00:57:35.040 --> 00:57:36.760
Now, high-level toolbox APIs.

00:57:36.870 --> 00:57:41.170
The high-level toolbox is the fundamental
drawing stuff that is in Carbon,

00:57:41.360 --> 00:57:43.660
and it sits in the
Carbon framework bucket.

00:57:43.780 --> 00:57:46.390
Those, in general,
are currently not available.

00:57:46.400 --> 00:57:49.410
You can try to call them, but in general,
events might not work,

00:57:49.530 --> 00:57:50.670
the drawing might not be right.

00:57:50.840 --> 00:57:53.540
So at this point,
this is not something you can do

00:57:53.580 --> 00:57:55.430
in the context of a Cocoa app.

00:57:56.710 --> 00:58:00.200
Now, I said that you could pass
basic data types back and forth,

00:58:00.350 --> 00:58:03.310
so obviously C types and structures,
no problem.

00:58:03.560 --> 00:58:05.900
Those are all the same
between the two environments.

00:58:06.000 --> 00:58:08.370
Now,
there are APIs to convert other types.

00:58:08.510 --> 00:58:11.330
Some of the more fundamental types
you might be using in your app

00:58:11.330 --> 00:58:14.800
are file paths or FSREFs or URLs.

00:58:14.880 --> 00:58:19.500
And, for instance, File Manager,
a Carbon manager, and CFURL,

00:58:19.500 --> 00:58:22.890
which is in Core Foundation,
both provide ways to convert

00:58:22.890 --> 00:58:26.220
URLs and paths back to FSREFs
and FS specs and so on.

00:58:26.240 --> 00:58:29.990
So you could actually intermix those
two APIs by doing these conversions.

00:58:30.310 --> 00:58:33.830
And also, some Carbon APIs still
take Pascal strings,

00:58:33.940 --> 00:58:39.010
and in the context of a Cocoa app,
you might have NSStrings or CFStrings,

00:58:39.060 --> 00:58:42.330
and then you can use CFString or
NSString conversion facilities

00:58:42.600 --> 00:58:44.140
to call down to those APIs.

00:58:44.380 --> 00:58:47.330
Now, I'm saying NSString or CFString.

00:58:47.600 --> 00:58:52.220
This brings us to toll-free bridging,
which enables passing,

00:58:52.220 --> 00:58:55.880
which enables treating
those two as the same.

00:58:55.880 --> 00:59:01.430
So what NSString does is some CF types
are the same as their Cocoa counterparts.

00:59:01.760 --> 00:59:04.880
CFString is the exact
same as an NSString.

00:59:04.950 --> 00:59:07.380
Array, dictionary, data, URL,
the same thing.

00:59:07.380 --> 00:59:09.480
And there are a few other
classes this is true for.

00:59:09.530 --> 00:59:12.740
What this means is if you have
some Cocoa API and it gave you an

00:59:12.750 --> 00:59:16.270
NSString and you have to call a
Carbon API that takes a CFString,

00:59:16.530 --> 00:59:17.460
just cast away.

00:59:17.630 --> 00:59:19.940
It's the same thing, no problem.

00:59:19.940 --> 00:59:20.380
Okay?

00:59:20.480 --> 00:59:23.520
So this is -- thank you.

00:59:23.620 --> 00:59:25.000
So you can just pass
these back and forth.

00:59:25.040 --> 00:59:25.520
Okay.

00:59:26.840 --> 00:59:29.640
Okay, so much for Carbon.

00:59:29.730 --> 00:59:35.120
Now, as I said, our intent over time is
to improve the bridging,

00:59:35.120 --> 00:59:38.120
and currently you might find that some
areas are not properly bridged yet.

00:59:38.180 --> 00:59:41.210
And if you hit upon a wall,
if you hit something you need definitely,

00:59:41.320 --> 00:59:42.240
please let us know.

00:59:42.240 --> 00:59:45.950
And finally, the last topic for today is
programming Cocoa with Java.

00:59:45.950 --> 00:59:49.080
As you know, Objective-C and Java are
both the languages with

00:59:49.090 --> 00:59:50.850
which you can program Cocoa.

00:59:50.870 --> 00:59:54.520
And here I'm going to talk about some
of the design flaws of what happens

00:59:54.520 --> 00:59:56.510
when you use Java to program Cocoa.

00:59:56.700 --> 01:00:00.130
You can access most
Cocoa APIs using the Java language,

01:00:00.130 --> 01:00:03.080
and I'll explain why it's not everything.

01:00:03.080 --> 01:00:05.690
Cocoa objects can be subclassed in Java.

01:00:05.700 --> 01:00:08.870
So if you have an NSView,
which is a Cocoa object

01:00:08.870 --> 01:00:11.400
with an Objective-C,
and you want to have a

01:00:11.400 --> 01:00:13.410
subclass of it in Java,
you can do that.

01:00:13.500 --> 01:00:18.360
You can also pass objects back and
forth between Java and Objective-C.

01:00:18.360 --> 01:00:20.940
So NSView is an Objective-C class.

01:00:21.080 --> 01:00:23.730
It wants, you know, some object.

01:00:23.860 --> 01:00:25.270
It wants to have a window passed to it.

01:00:25.380 --> 01:00:26.680
You can pass a Java version of it.

01:00:26.730 --> 01:00:27.330
You can pass a Java version
of it back and forth.

01:00:27.440 --> 01:00:28.880
It's all automatic.

01:00:29.000 --> 01:00:33.130
And your applications can either be 100
percent Java or you can make them hybrid,

01:00:33.280 --> 01:00:37.610
meaning parts of them can be Objective-C,
parts of them can be Java.

01:00:38.610 --> 01:00:43.630
So the philosophy we have in the
Java APIs is that we want developers

01:00:43.630 --> 01:00:48.220
to be able to use the Java language to
program and to create Cocoa applications.

01:00:48.310 --> 01:00:51.970
However, we want to preserve and expose
the Cocoa programming model,

01:00:51.970 --> 01:00:54.770
because we have this
Cocoa application model.

01:00:55.070 --> 01:00:58.480
It's one way, and you should be able to
use that in the application.

01:00:58.600 --> 01:01:02.460
But we also want you to be able to
use Java paradigms and objects where

01:01:02.460 --> 01:01:04.940
possible and where it makes sense.

01:01:04.940 --> 01:01:07.440
One example is the Java string class.

01:01:07.440 --> 01:01:09.840
It's all over the place in Java.

01:01:09.840 --> 01:01:14.140
And in the Java side,
it might be a better idea to

01:01:14.240 --> 01:01:17.350
use the Java string rather
than use the NSString class.

01:01:17.610 --> 01:01:21.240
And functionally,
they're pretty much equivalent.

01:01:21.240 --> 01:01:24.310
The other goal we have is that you
want to be able to integrate and use

01:01:24.310 --> 01:01:26.480
Java libraries as much as possible.

01:01:26.490 --> 01:01:29.850
Java network libraries,
whatever else you might have,

01:01:29.880 --> 01:01:31.280
Java utility libraries.

01:01:31.280 --> 01:01:33.530
You should be able to use them
in the context of your app.

01:01:33.540 --> 01:01:36.340
And this is pretty much
confined to the lower levels,

01:01:36.490 --> 01:01:39.350
meaning at the UI layer,
it might not work so good,

01:01:39.400 --> 01:01:42.050
but the lower levels, networking,
et cetera,

01:01:42.110 --> 01:01:44.290
those APIs are all available to you.

01:01:44.710 --> 01:01:46.850
So I talked earlier that,
I said earlier that

01:01:46.850 --> 01:01:48.640
most APIs were exposed.

01:01:48.900 --> 01:01:52.550
It turns out almost all of the app
kit is exposed using this name,

01:01:52.710 --> 01:01:55.600
com.apple.application.

01:01:55.600 --> 01:01:59.390
And then we have some
of foundation exposed.

01:01:59.600 --> 01:02:02.270
When I say some,
it turns out to be at least half of it,

01:02:02.430 --> 01:02:04.600
com.apple.yellow.foundation.

01:02:04.660 --> 01:02:08.670
Now the areas that are not exposed
is basically areas where we decided

01:02:08.670 --> 01:02:10.590
that Java has an equivalent.

01:02:10.600 --> 01:02:12.840
And finally,
there are additional frameworks,

01:02:12.840 --> 01:02:17.090
com.apple.yellow.scripting has the
scripting functionality that is

01:02:17.170 --> 01:02:19.590
added onto the Cocoa frameworks.

01:02:19.720 --> 01:02:24.030
Now, we will rename these
things at some point soon,

01:02:24.070 --> 01:02:24.600
so.

01:02:25.110 --> 01:02:28.300
Okay,
so most objects are exposed directly.

01:02:28.300 --> 01:02:29.400
We call these wrap.

01:02:29.520 --> 01:02:34.950
So NSView in Objective-C is the class
com.apple.yellow.application.nsview

01:02:35.290 --> 01:02:36.560
in Java.

01:02:36.560 --> 01:02:39.870
Now I talked about the string class,
which is not exposed.

01:02:39.870 --> 01:02:43.600
Those are morphed, meaning any time it
goes to the other side,

01:02:43.690 --> 01:02:46.620
it goes to a change,
it basically changes into an

01:02:46.620 --> 01:02:48.420
object of the other language.

01:02:48.690 --> 01:02:52.130
So NSString instances are converted
to the string class in Java,

01:02:52.230 --> 01:02:55.760
and there are a few other
classes to which this happens.

01:02:55.760 --> 01:02:58.120
And we repackage some functionality.

01:02:58.170 --> 01:03:00.470
For instance,
categories is an Objective-C feature

01:03:00.470 --> 01:03:03.670
which lets you add methods
on top of an existing class.

01:03:03.670 --> 01:03:05.580
It's not available in Java.

01:03:05.580 --> 01:03:07.740
So in those cases,
we either take the methods that are in a

01:03:07.740 --> 01:03:11.540
category and fold it into the base class,
or we repackage them

01:03:11.540 --> 01:03:13.380
into a separate object.

01:03:13.380 --> 01:03:17.210
And C functions, which Cocoa has some of,
are not exposable directly in Java,

01:03:17.340 --> 01:03:20.200
so we usually package
them into a utility class,

01:03:20.200 --> 01:03:22.760
much like the math class in Java.

01:03:23.340 --> 01:03:25.950
And Cocoa also has a bunch
of structs and selectors,

01:03:25.950 --> 01:03:29.470
and Java doesn't have a concept
of structs and selectors,

01:03:29.470 --> 01:03:32.410
and those are converted
to Java objects as well.

01:03:32.680 --> 01:03:35.900
And as far as method name mapping,
in Objective-C,

01:03:35.900 --> 01:03:40.060
method names can have arguments,
keyword arguments,

01:03:40.060 --> 01:03:41.680
or keywords for each argument.

01:03:41.810 --> 01:03:45.300
For instance, post event, at start,
there are two arguments there,

01:03:45.300 --> 01:03:46.800
one between each colon.

01:03:46.800 --> 01:03:50.670
In Java, we convert that to post event,
meaning we drop the other argument names,

01:03:50.790 --> 01:03:53.350
because often the main part
of the name is good enough.

01:03:53.460 --> 01:03:56.910
And Java also allows overloading,
which means you can have

01:03:56.910 --> 01:03:58.690
various versions of that.

01:03:58.700 --> 01:04:01.280
Sometimes when the name
would be not very obvious,

01:04:01.280 --> 01:04:04.640
or sometimes when the second argument
is as important as the first one,

01:04:04.700 --> 01:04:07.250
we tend to keep the whole thing,
so set object for key

01:04:07.250 --> 01:04:09.720
becomes set object for key.

01:04:09.780 --> 01:04:12.380
Finally, init methods,
which are the constructors

01:04:12.480 --> 01:04:15.370
in Objective-C,
in Java are just converted

01:04:15.370 --> 01:04:16.800
to constructor methods.

01:04:16.830 --> 01:04:19.080
For instance,
the NSView init with frame method,

01:04:19.080 --> 01:04:22.430
which is how you create an NSView,
in Java is simply NSView,

01:04:22.430 --> 01:04:26.120
which is how you create objects in Java.

01:04:26.120 --> 01:04:29.450
So those of you who are familiar
with Java probably have tools to

01:04:29.500 --> 01:04:34.180
inspect and look at Java APIs,
like JavaP and so on.

01:04:34.180 --> 01:04:37.930
One tool we provide on the system
is this app called Java Browser.

01:04:38.110 --> 01:04:38.880
It's really handy.

01:04:39.020 --> 01:04:44.730
It just shows you a browser up there
of all the classes it knows about,

01:04:44.800 --> 01:04:47.360
which includes the Cocoa classes,
plus all the other classes,

01:04:47.360 --> 01:04:48.800
including the Sun classes.

01:04:48.800 --> 01:04:52.120
And you can choose any class,
and down below it will show you a

01:04:52.120 --> 01:04:54.780
nicely formatted API for that class.

01:04:54.780 --> 01:04:57.940
So it's a fairly handy tool if you're,
if you want to browse through the APIs.

01:04:57.940 --> 01:04:58.940
Thanks.

01:04:59.630 --> 01:05:02.200
Okay, so I think Becky went
through the documentation.

01:05:02.280 --> 01:05:06.190
There's documentation on DP4,
release notes and so on.

01:05:06.250 --> 01:05:09.780
The release notes are really quite handy.

01:05:09.830 --> 01:05:12.010
There's documentation in
system developer documentation,

01:05:12.150 --> 01:05:12.530
Cocoa.

01:05:12.530 --> 01:05:14.880
You can also go to the website
to see if there's updated

01:05:14.880 --> 01:05:16.930
documentation in any of these areas.

01:05:17.050 --> 01:05:20.860
We have example code in both system
developer examples app kit and system

01:05:20.860 --> 01:05:26.480
developer examples Java app kit for
Java applications written with Cocoa.

01:05:26.480 --> 01:05:27.420
And here's the roadmap.

01:05:27.560 --> 01:05:30.580
Some of these talks have passed, but,
you know, if you have a chance,

01:05:30.590 --> 01:05:34.470
if the facilities will
provide to review them,

01:05:34.470 --> 01:05:36.560
you can choose to do so.

01:05:36.600 --> 01:05:38.730
Let's see, the localization talk is
happening right after this.

01:05:38.820 --> 01:05:43.660
I think that's Mike talking about how to
localize Cocoa and Carbon applications.

01:05:43.660 --> 01:05:45.990
The Quartz talk is tomorrow
where it talks about Quartz

01:05:46.120 --> 01:05:50.350
APIs that you can use directly from
Cocoa applications if you want to.

01:05:50.350 --> 01:05:52.360
And the performance talk,
that is pretty much

01:05:52.360 --> 01:05:54.100
wrapping up right now,
I believe.

01:05:54.100 --> 01:05:56.400
So, okay, let's see.

01:05:56.400 --> 01:05:58.920
So I think we have about ten minutes.

01:05:58.950 --> 01:06:03.660
I would like to invite Mike and
Chris back on stage for some QA.

01:06:03.720 --> 01:06:06.120
And Becky, I think I see her there, too.

01:06:06.120 --> 01:06:08.400
Now, one, one thing,
we have a brand new address,

01:06:08.480 --> 01:06:10.710
cocofeedback@group.apple.com.

01:06:10.710 --> 01:06:11.440
It works.

01:06:11.440 --> 01:06:13.580
So if you have comments
and feedback on the APIs,

01:06:13.580 --> 01:06:16.910
new features you'd like to see added
to AppKit and Foundation and such,

01:06:17.180 --> 01:06:19.040
please send, send us mail.

01:06:19.040 --> 01:06:20.680
Thank you.
---
Title:  Alternative Programming Languages for QuickTime
Year:   2004
Web:    https://nonstrict.eu/wwdcindex/wwdc2004/216/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Welcome to session 216. My name is Tim Monroe. I'm with the QuickTime Engineering Group, and in a little while I'll bring up John Cromie from Skylark Associates. We're going to talk today about alternative programming environments, or languages as they seem to have changed the title, for QuickTime. Let me just start off by saying that in all the digital media sessions we've heard a whole lot about Moore's Law, right?

It seems like everyone wants to talk about Moore's Law. Well, I'm not even going to mention the words "Moore's Law" during this talk. But I do want to talk about something which is really more important, and I want to call that Twain's Law. And that is, to a man with a hammer, everything looks like a nail.

Or as we might say today, modulo hammers, it's all nails. So the truth here is that if you have a problem you want to solve, generally you are restricted to the tools that you know about. And so sometimes we end up solving a problem in the wrong way because we don't really have acquaintance with the correct tools.

So one of the things I want to do here today is sort of throw out a survey of some of the tools that we can use to do QuickTime. I'll talk a little bit about how we can extend some of these tools to perhaps take advantage of more than is built into the tool. And then in a few minutes we're going to reveal to you for the first time an exciting new tool for Windows developers.

So let's talk about traditional development. So when I talk about alternative, we do that against the backdrop of what's the tradition that we're working in usually. And probably for the first eight or nine years of QuickTime's development, the standard way of doing application development was using the C programming language with what we now consider to be Carbon APIs, or what we would then call the Mac User Interface Toolbox in the Mac operating system.

Now on Windows we can develop QuickTime programs, but again the standard programming paradigm is using C with, believe it or not, the Mac OS Toolbox and user interface toolbox. And we do that with this magical little thing called the QuickTime Media Layer, or QTML, which essentially is just a whole lot of the Mac Toolbox and a whole lot of the Mac OS taken over and put on top of Windows. And where you actually had some choice in the traditional development model was in the IDEs that you would use. So early on people would possibly use MPW. About the System 7 timeframe we would move to Code Warrior, a very good tool.

On Windows you might be using Visual Studio. And then nowadays you could still do the same sort of development using Xcode. Well, that's okay, that's great. But today I want to look at what's possible apart from this traditional model. And I've sort of roughly classified these into three major groups.

The first group is what's really fun, and that's what we would call rapid application development tools. So we've got Cocoa, we've got some very good third-party tools, REALbasic and Runtime Revolution. On the Windows side we have Visual Basic and Delphi. There's this new kid on the block, AppleScript Studio. And then there's this thing, SuperCard, that doesn't seem to want to go away. So all of these development environments have some built-in support for QuickTime. Actually, there's one of these that actually has no built-in support for QuickTime. Anybody know what that is?

Visual Basic is put out by a company up in Redmond, and for some reason they seem to have left out the QuickTime support in their application. And I'm sure this is just an oversight. But enterprising third-party developers have actually stepped into this void and developed what's called an ActiveX control.

So the way you would, in Visual Basic, use QuickTime is by finding an appropriate QuickTime ActiveX control, adding it to your project, and then going from there. Now here there's sort of an embarrassment of riches. There are in fact three different ActiveX controls that you could get right now to do application development in Visual Basic on Windows.

It turns out that to do even a basic multiplayer, a multi-window, or a multiplayer application that allows you to do editing and maybe some extra stuff, none of those three existing ActiveX controls gives you quite what you need. So it's an embarrassment of riches, but it's also embarrassingly bad in that you can't go very far with any one of those three.

So then we have four that I'll, what I'll call application frameworks. So they're not really rad tools, or maybe some of these are, I don't know. QuickTime for Java with the Java, or QuickTime, Java with QuickTime for Java bindings, very good story for developing QuickTime applications. There's a cross-platform application framework called Qt, or QT.

There's one that's apparently not very well known called WX Widgets. It used to go by the name WX Widgets, but now it's called WX Widgets. It used to be WX Windows, but for some reason they had to change the name. And then there's a good old Power Plant, provides a good basis for supporting QuickTime applications.

The last category I want to talk about is actually quite an interesting one, and one I've been working with recently, and that is what we might call scripting. Scripting in the sense that I have a text file, I type in some commands, and then somehow Those commands get interpreted at runtime to give me a QuickTime application.

The one that I will look at in depth is tclTk with an add-on called QuickTime Tcl. It's a very interesting little environment. We're going to be looking at a mystery guest that I won't tell you about. And then I have question marks by Python, Perl, and Ruby. And the reason I have question marks is that, to my knowledge, there's no out-of-the-box solution to use, for instance, Perl to develop a QuickTime playback and editing application. But once you see what I do with this mystery guest, I think you'll be convinced that you could, if you wanted to, use these three other scripting languages to build a QuickTime application. So let's take a look here at the old way of doing things.

So I'm going to look at what it used to look like. What I've got here is Code Warrior, and I've got two project files opened. One of them is a Windows project file, and one is a Macintosh. So I'm going to look at what it used to look like.

What I've got here is Code Warrior, and I've got two project files opened. One of them is a Windows project file, and one is a Macintosh. Let me bump this up a little bit so we can actually read it. You can see that the files in each of these two projects are very similar.

There are two – oh, that's cool. There's one here called WinFramework, which is, as you might guess, some basic application support geared at the Windows application. On the Mac side, you can see there's a Mac framework, which is the same stuff for the Mac side. There's some common stuff, which is really where all the QuickTime support lies. And then there's this com application, which is where I would put any application-specific code. And in Qt Shell, that's fairly empty, that file. So let's look at WinFramework.c.

So here we've got just some standard C source code. Let me bump down here a little bit. One nice thing is we're seeing Windows data types here: bool, handle, hwind, cars. We've got LP stirs here. So, and let's just look down here. We've got a window proc, or this is our win main, where we set things up.

And if you've ever done any Windows programming, you feel right at home with this. This is just the kind of stuff that you expect to see. Let's just go down a little bit more, and we actually have a window proc for our frame window. So this is an MDI application. And we have a win proc for the movie Windows inside of there. So this is a good story right there. That's the kind of mindset that Windows developers have.

If we look at the corresponding file on the Macintosh, We get pretty much the same picture. Okay, here's Mac data types. This is the stuff that Carbon programmers understand. If we go down here, we'll get to installing some Carbon event handlers. Somewhere down here we've got event loops, that's wonderful. So again, if you learned how to program on Mac, that's just the sort of stuff that you expect to see. Now let's look at the common file.

see what we've got in there. Now as I said, this is mostly QuickTime specific stuff. Okay, we've got some platform specific defines here. That's okay. I can handle that. Down here sort of we've got a file menu handling that calls application specific functions here. That's good. Again, some more wrappers for the edit menu. Now we're getting some QuickTime functions here. MC cut is how we're going to handle the cut command and so forth. Let's go down a little bit further, see what we run into.

Fairly generic stuff here. Here's a nasty guy. FS make FS spec. For Windows programmers this is wrong in so many ways. They don't want to have to work with FS specs. FS spec is a relic of the Mac operating system. So the barriers to entry for this kind of development for Windows programmers are fairly high. We're asking them to learn not only the Windows way of doing things, but also the Mac way of doing things. So again, that's a bad story. So let's go back to slides.

That's also a bad story for Cocoa developers, right? They don't want to have to work with those Carbon data types. They'd rather work with stuff that's good for Cocoa. Well, if you were at the last session, the QT kit session, you saw that we have a very good story coming out in Tiger for Cocoa programmers.

We have this new QT kit that insulates the Cocoa programmer from as much of that underlying stuff as possible. Wouldn't it be nice if we could do the same thing for Windows? And I want to invite up John to show you that we're announcing here exactly that same sort of thing for Windows developers. Please welcome John Cromie.

Thank you, Tim. I must say it gives me a kind of a perverse pleasure, if you like, to be standing up here at the Apple Developer Conference and talking about, of all things, Visual Basic, ActiveX, and COM. But, whether we like it or not, Visual Basic is probably the most popular programming environment ever. There are about 8 million developers out there using Visual Basic, and with VisualBasic.net and with C Sharp now using many of the same ideas from Visual Basic, that development base is bound to grow in the coming years.

Now, Much of the success of Visual Basic has been based around the component architecture that underlies the Visual Basic platform, and that is called COM, Component Object Model. And it's quite a similar story to QuickTime in a way. QuickTime was based on a very successful component architecture that underlies the platform.

And If you're a COM developer or a Visual Basic developer and attempting to use QuickTime, as Tim has mentioned, the choices were rather limited. And some of us have been trying since Visual Basic three days to attempt to use QuickTime in Visual Basic to develop QuickTime applications in the COM or Windows environment, but with limited success.

So I'm delighted to announce today that Apple is finally addressing this problem and announcing a brand new QuickTime COM or ActiveX control for QuickTime developers. This control can be used out of the box in the .NET development environment and also in traditional COM development tools. So we're talking about the leading RAD development tools here. We're talking about VB.NET, we're talking about C#, we're talking about Delphi. Those are the three big ones.

But the COM technology underlies many other development environments and underlies many other desktop applications as well. And because of this shared COM environment, the QuickTime ActiveX control can also bring this QuickTime technology into those environments as well. So rather than stand up here just describing this control in detail, I'd like to take you through a short development sequence. What we're going to do is put together a very simple movie player and editor using the new ActiveX control.

Thank you. Okay, so I'm going to launch VB.net. Well, in fact, I've already launched VB.net. And I'm just going to... Drag in a sample application. Okay, so this is the, anybody who's used visualstudio.net or VB will recognize this environment. We've got a form here. And I've made life easy by already populating the forum with some menus.

But basically this application does nothing as is. So the first thing we have to do is to put the new QuickTime com control on the form. Now, like most Windows controls, the COM control resides in this toolbox containing hundreds of controls. And it's in here under the General section, sitting beside a friend. So let's pop it on the forum. There we go. So the first public instance of the QuickTime column control I'm going to press F4 and get some properties. And this just shows the way in which you can manipulate the control in the design environment.

So I just want to change its name and make it slightly simpler. I'm going to give it a plain name. No border, and I'm going to set its position to be 0, 0. Now, double-click and we go into the code behind the form. Now, Visual Basic fills in a lot of this.

When you add the menus, Visual Basic fills in the prototypes for the various functions. So most of this code has already been written for me, and I'm just going to start filling in the actual bits that depend on the control itself. So first thing we want to do is we want to open a movie.

So we go to the Welcome to the handler that handles the open menu item. I've already put in some code here that gives us a file dialogue to choose a movie. So, in a few lines of code, hopefully less than six lines, we can create a simple movie player application. Welcome to the handler that handles the open menu item. I've already put in some code here that gives us a file dialogue to choose a movie. So, in a few lines of code, hopefully less than six lines, we can create a simple movie player application.

.file name. There we go. Syntactically checked and all for me. Now, I want to implement a few other things, so let's allow ourselves to close the movie. .file name. There we go. Syntactically checked and all for me. Now, I want to implement a few other things, so let's allow ourselves to close the movie.

.file name. There we go. Syntactically checked and all for me. Now, I want to implement a few other things, so let's allow ourselves to close the movie. Okay, dot. Oops, dot. Now, this time instead of telling the control to play, I actually want to tell the movie which is inside the control to play. So we pick the next object in the hierarchy.

Okay, dot. Oops, dot. Now, this time instead of telling the control to play, I actually want to tell the movie which is inside the control to play. So we pick the next object in the hierarchy. And just to show that we can do other things as well, we've got .rewind. So let's leave it at that for now. Let's run this application. Okay, so it's building a binary. And here we are. So let's try opening a movie.

And here we've got a movie. Oops, it's set at the... Okay, I've rewind it, and I can play it. Okay, so very simple QuickTime application developed from a Visual Basic skeleton in a matter of minutes. That's the power of the new QuickTime comm control. But obviously we want to do more than that, and the control is quite fully featured. So what I'm going to drag in now is a slightly more baked version of this skeleton application.

Most of the code has been filled in now, but we're going to add a few little interesting bits. First of all, we've seen how to tell the movie to do certain things or send commands to the movie. Now we want to see how do we get some information back out of that movie.

So what I've done is I've set up a little media inspector form. And what I'm going to do is put some code in there. Here you can see the code here. I can add properties and I can add sections to this little form. And we're just going to type in some code. So let's get the duration of the movie, the width, the height, some metadata, some user data from the movie. So qt control 1 dot movie Dot duration. Okay. And to save you and me a lot of time, I'll just copy in the rest.

Oh, there's one more thing I'd like to show you. Notice this one here, track one. Let's put into this little information dialogue the data format or the media format of the first track of the movie. Okay, so we're starting to drill down into the movie here. Let's see how we get this.

So we start off with a control, Qt control 1, .movie. Dot, what's inside a movie, tracks. We want the first track, and we want its format. Okay, so without looking up any documentation virtually, I can use the autocomplete or IntelliSense technology to work out what roughly looks like something I might want.

So that's getting information out of the movie. Now anybody who's developed a QuickTime application will know that very soon you need the movie or the control to tell you what's going on inside. In other words, you need to be able to handle callbacks or notifications. Now if you're a Visual Basic developer and you've never come across C++ or C before, you don't know what a callback is. You don't know what a notification is even. The only thing you know about are events. And sure enough, we've added to the QuickTime control a suite of events.

[Transcript missing]

The container window to resize itself to fit the movie. So let's have a look down, see what events are here. Remember, I haven't looked up any documentation. I'm using this for the first time. There's a size changed event that looks kind of reasonable. And here's the prototype that VB puts in for me. So the form I'm in is called me. And I want to set its client size, the bit inside it. And I want to make it equal to a new size object. This is all standard VB. And the size object is qtctl1.width and qtctl1.height.

There we go. Notice the way VB immediately syntactically checks the whole thing for me and underlines anything that's wrong. Now, so that's the control telling the application when it's changed size. But as a QuickTime developer, you're probably familiar with MC action events with the need to set up a filter proc and to get information back from the movie.

What I'd like to do is to have this application know whenever the movie is playing and when it isn't playing. In fact, what I want to do is I want to make the play item in the movie menu change from play to stop and stop to play whenever the movie is playing and stopped. In other words, I want to make a context-sensitive menu.

First of all, let's go back up to the code for the play. Here we are, and let's modify this. So let's say if.

[Transcript missing]

If it's greater than zero, zero, then... If the rate is greater than zero, we want to make it stop. So movie.stop, all the things you might expect are in here. And play.

Great. So that will work fine. That'll stop and play the movie. But what it won't do is it won't change the label on the menu from play to stop and from stop to play. So that would be a nice touch. And in order to do that effectively, what we really want is for the movie to be able to tell us when it's playing or when it's stopped. And this is where we come to the events that are exposed from within QuickTime.

Now the way this is implemented in the QuickTime com control is that all of the objects within the control have an event listener's collection. And if you're interested in an event within the control, then you register for a particular event. So what I'm going to do is immediately after I've opened the movie here, I'm going to Type qtctl1.movie.eventlisteners.add. We want to add a new event listener.

Notice the various options are popped up immediately for me. I don't have to look up any documentation. I want a high-level event.

[Transcript missing]

So that tells QuickTime, or tells the control, to let me know when the movie rate has changed. So how do we handle this event when it comes back to us? All of these events from within the movie are all marshalled through a single Qt event callback or event handler within Visual Basic. Here's the prototype for it. Now rather than typing in code, I'm just going to copy this here and paste it in.

Now, because you can get events, lots of different events that you might register for here, you might register for an event when the volume has changed, when the time has changed, that kind of thing. When a sprite has moved, lots of kind of things you can register for. So obviously we need a case statement in here so we can do what we want to do at particular times.

So I have a case here on the event changed event, and I've got some code here which simply looks at the movie rate and determines whether or not the menu item should say play or stop. Okay, so let's leave it at that. Let's save this and build it. Hopefully it'll all work.

Open a movie, let's open a different bird this time. We've got bee eaters. Okay, first of all, immediately we notice that the application window has resized to fit the movie. Now remember that was one line of very simple, straightforward code. Not only that, but we can scale, and the application window scales as well to fit the movie. Okay, let's see if our play button works. Okay, good.

[Transcript missing]

Notice that it's already changed to stop. That's because we know that our event callbacks are actually working here.

So, what else can you do with this control? Well, I've got a fully baked version of this application, which I'm just about to show you now. Fullscreen works as a single call. qtcontrol.movie.fullscreen = true So I'm just going to launch finished application here and do one or two quick things with it. Let's kill studio and kill that and open another movie.

Okay, so I've got a movie over here that I've opened in QuickTime Player, and I'm going to say File, New Movie here. Okay, so I've created an empty new movie. I'm going to grab a bit of this. A little bit of this snowy egret and copy it. I'm going to go over here and paste it. What's the command for paste? qtctrl1.movie.paste. Very simple. I've now got a new movie here. Okay, I can cut a bit out of it if I like.

Okay, but best of all, I can go to Export Movie. And all of the exporters that are available to QuickTime are available here to the VB developer. Let's give it a name. Okay, so within the code I've popped up the export settings dialog. I can go and change those. And it's basically exporting the movie at the moment. Okay, and it's done, so let's close this movie and open the one we just exported.

[Transcript missing]

To develop in C# is very, very similar. In fact, the code is almost identical, just slightly syntactically different. Can we have the slides again, please? Anybody who's developed in QuickTime, or sorry, in Visual Basic will know that the object model is something that you deal with very often.

And in order to expose the QuickTime API in a way which made sense to comm developers, we've imposed an object model, if you like, on QuickTime. And you can see on the right-hand side of the slide here, that some of the elements of that object model, and it's no coincidence that there's a lot of commonality between this object model and between the object model that was being described earlier as part of the QT kit. In other words, the object model of QuickTime transcends the implementation details of how you actually use QuickTime, and that's a really important thing to understand. If you understand the object model as a developer, then you really, you can develop with QuickTime in lots of different environments.

I just want to emphasize as well, many of you might have turned up your nose when I mentioned Visual Basic, and C developers have a habit of doing that. Let's not forget that these environments, particularly C#, Delphi, and Visual Basic, can all be used to produce very professional QuickTime applications.

So those are the big three: Visual Basic, C#, and VB.NET. But there are others. And many development environments are now comm aware. There's a few listed here. I want to draw your attention to one in particular which I've been really enjoying using, and that is the Troll Tech Qt Framework.

It's brilliant for cross-platform Mac and Windows development, but it's also very good on Windows because it has an excellent com container class. What I'm going to do is very quickly show you, if we just have the Qt application, which is identical to the Visual Basic application that I've just developed. All the QuickTime implementation uses the QuickTime com control.

There's nothing fancy going on here. And, but I've added a little extra to this because it was so easy to program. With a few lines of code, I can grab a series of interesting faces. Let's end with a happy face. Drag them over here. Oops, this is going to crash, sorry. Start again.

Should have created a new movie first. Okay, let's create a new movie. Okay, and let's grab some interesting faces again. So these are images that I'm dropping on a Qt QuickTime application. You notice that it's now creating a movie out of these images. The code is really, really simple here.

It's maybe four or five lines of code, and I've created a simple drag and drop, droplet if you like, for creating QuickTime movies from content on your desktop. And because I can get at the export menu, I'm going to have another go at exporting. I can export these as a DV stream.

Okay, setting is again, and it's exporting at the moment. So let's give it a bit of time this time. Close the movie, open it. And now we've got a DV movie created from those. Using the QuickTime object model within the control, I can play with all of the various export settings. And as you can see here, you've got the bones of some quite powerful production tools. Back to the slides, please.

So there's a couple of other development environments which you shouldn't forget about. Draw your attention particularly to Delphi and Toolbook as well. Lots of developers using QuickTime in Toolbook on Windows using a comm control. As I mentioned before, the QuickTime abstraction is exactly the same everywhere. However, because COM underlies not just developer environments, but many desktop applications, then all of a sudden we've got the ability to use QuickTime in places that we might never have dreamt of before.

[Transcript missing]

I've got a list of movies down the side here, and I can click on a movie. It opens up within the middle of my spreadsheet. And lo and behold, with a few lines of scripting code behind this worksheet, I've been able to populate some cells in the spreadsheet with various pertinent details from the movie. So for example, there's the copyright, or the full name.

But not only can I read information from the movie, why can't I just type "Greeb" in there for the name? John for the author. And click on the Save Movie cell. Okay, just to show you I'm not doing anything behind the scenes, I'm going to go and delete the contents of these cells.

Click on a different movie, click back on the same movie again, and you'll notice that the name and the author has changed on that movie. Now I won't waste time by going into QuickTime Player to actually show you that that's happened, but believe me, that is actually changing the user data in the movie. Now this is really useful if you're production oriented. Have a look at this example.

I've got a folder of movies here. Now there's only five movies in this folder, but there might be 500 movies. I'm going to read four user data fields from these movies, four metadata fields. My problem is that I want to change the copyright on all of these. Let's change the copyright to 2005. It's a spreadsheet, so why can't we just do an edit, fill, down.

Let's Save the movie data. So we're opening up each movie in turn and writing this data back to it from the spreadsheet. Let's clear it and get it all back again. And notice that very quickly and very easily we've changed the copyright on a whole folder of movies. That's Excel.

Many of you probably don't realize that behind Excel on Windows is a very powerful Visual Basic programming environment. Virtually anything you can do in Visual Basic you can also do in Excel.

[Transcript missing]

Can we use the QuickTime control in PowerPoint? Of course. I think. Yep. So here we've got a movie. I've added some buttons to the PowerPoint slide, and I can play the movie.

That's very simple, but you can also do more. Here's a movie which is essentially a chapter movie. It's actually a smile movie which creates a series of chapters. And as you can see, it's standard QuickTime chapter access. But what happens if I want to get at the chapters using buttons within PowerPoint? Well, again, a few lines of scripting code behind the slide, and we can jump from chapter to chapter within the movie. Last slide, a little bit of fun. Some of you might remember this interesting wired sprite movie.

This is really to demonstrate how deep you can get within the object model within QuickTime. I've got two buttons down here. This one turns off the left eyeball, and this one turns off the right eyeball. How are we doing this? QuickQtControl.movie.tracks.sprites.1. visible=false. or true. Okay? Or we can make them go cross-eyed. By enlarging each of those sprites. So essentially, within simple desktop applications like this, with the Visual Basic environment behind them, we can use the comm control to do interesting things with QuickTime.

Lastly, I just wanted to come revisit the Qt framework one more time. I mentioned that it was very good for cross-platform development. And if you choose to use on the Windows side the new QuickTime com control and on the Mac the new high movie view, Then you can actually create quite powerful cross-platform applications which share a lot of the code. Here's one I've been working on.

This is an application that's going to ship hopefully shortly. It's all about birds, believe it or not. And there we've got a QuickTime movie. And unfortunately...

[Transcript missing]

Okay, so this uses the Qt framework. All the code is cross-platform virtually. Much of the QuickTime API code is also cross-platform, and yet we've got applications that look very similar on two separate platforms with shared development effort. That's really all I want to say. Any questions afterwards about other frameworks or other common environments, I'll be happy to take. And back to you, Tim.

Okay, so let's switch gears for a little bit. We've been looking at standard application development tools on Windows and also on Mac. We've seen that there's some really good high-level solutions coming, the QuickTime kit for Cocoa developers, the new ActiveX COM control for Windows developers. For Carbon developers, we also have a new H.I.

Movie View that I haven't talked about here, but which you should look at. Now what I want to do is look at the sort of scripting languages. And again, this is pretty cool. Let me come over here to demo one. And open -- what I'm going to do is just show you the text file.

So this is written in a language called tcl.

[Transcript missing]

Top level is the way you create a new top level window. So I'll hit return there, and lo and behold, instantly I have a new window on the screen. So by typing in some commands, I get a nice GUI element. So let's-- So did I quit that? All right, let's launch it again. Now, I showed you that script of, actually quite lengthy script of tcl tk and QuickTime tcl commands. I'm going to open that with the source command here.

I'm just going to... and what we notice is that the console window and the basic window it gives me have gone away. I explicitly hid those. And now I have a menu bar with commands that look fairly reasonable for QuickTime movies. So let's see if I can open a QuickTime movie. Okay, here's some MPEG-4s.

And it will play them just like you'd expect. I can come in here and cut. I can come over here and say paste. Or maybe I like that clip so much I'll paste it again. One nice thing about QuickTime tcl is that I can then come back here, undo the second paste, undo the first paste, excuse me, undo the cut, so I have unlimited levels of undo.

So that's really pretty cool. I showed that earlier on Monday for the CocoaKit, and you expect that with Cocoa. You don't necessarily expect that with just a standard scripting language. That's QuickTime, that's tcl tk, and QuickTime tcl. Let's go back to slides briefly. Now it's time for our mystery guest.

Okay, and I won't reveal what that is. Let me motivate that first, so let me quit here. Let's open up a terminal window, and I have some commands I've already run here. It turns out that if you, let's try this, if I ls user bin

[Transcript missing]

Let's see what happens. Lo and behold, that Wish application opened and it did what I wanted. It hid the default window you get and it opened a new window called Foo. So what does this tell me?

It tells me that I can use the standard input of that command line version of the tcl TK interpreter to do commands. Now I've also got another one here, let's do three. "Three is, says echo this command, that's some tcl script, that means put string hello world, pipe that through the tcl tk interpreter, and let's see what it does, it echoes hello world. So that's sort of a roundabout way of doing the hello world thing, namely send this string of tcl commands over to the tcl tk interpreter and the tcl command is just, to your standard output, write this string." string.

So what have we learned? That command line version of the tclTk interpreter takes standard input. It's got a standard output. Now here lights may be going on in your head. You can do some pretty funky stuff here. Why? Well, I could write a shell script or a Perl script or whatever that sent some standard output to the tclTk interpreter.

And if I was clever, if I had a bidirectional pipe, I could get some output back. So what this shows us is, If I know some tk, if I know tk well enough to be able to do the graphical user interface stuff, I don't need tcl at all. I don't need that. I could write my application in some other language altogether.

So this is where our mystery guest comes in. So what I did is when I had that realization that I can just plug in any language I want, and as long as that script for that language or that application knows how to write tk to its standard output, and read things in from the standard input, I'm golden.

So can we go back here? My mystery guest. So what I was doing, I was looking around the Unix system, and I came across a small little language, hasn't been used in years, and that language is awk. So I decided I would write a full-featured QuickTime application using just awk.

And let me show you that that actually works. So I need one more piece of this puzzle. I need something that takes the standard output of the tclTK interpreter and sends it to awk. And then I need something that takes the standard output of awk and sends it to the tclTK interpreter.

So I wrote a little Perl script, and because this is sort of some glue between awk and wish, I called it the awk-to-wish adhesive, or I like to abbreviate that as awkwa. So here I've got the awkwa interface between awk and the TK interpreter, and I'll just do 12 here again.

So 12 just says let's run this Perl script. Doesn't look like anything's happened because I don't know how to tell Perl to make the application come forward. Down here in my doc, this is an awk script running QuickTime. Well, there's no QuickTime movies here. It's just an about box. Let's see if we can open a QuickTime movie.

This looks just like it did before because the graphical user interface portion of this is identical. All that has changed is that I've taken a perfectly reasonable scripting language, namely tcl, and replaced it with a perfectly ridiculous scripting language, namely awk. And again, I can play this. I've got the multi-level undo and redo. I've got everything I had before. Okay, that's pretty cool.

[Transcript missing]

I'm kind of slow, so I thought, "Geez, that's a wonderful solution I've just got. I know that QuickTime Tcl has this command where I can add frames to a movie, and it can create a new movie, and it can write it out to disk. So I'll use this great technology, this Aqua technology I've got, and I'll write some sort of script that sends the tk commands over to QuickTime Tcl." And suddenly I realized, that's not what I want to do at all.

What I want to do is just write a command line tool that takes as its parameters the names of the files I want to use and creates the movie. And let me just show you that here. I've got an Xcode project, but using Xcode is way overkill for this. I could just do this all on the command line.

That's wonderful. So it's real simple. I've got a main routine here. It's got some arguments. One nice thing about this script is I'm using the latest and greatest QuickTime APIs. So I do a little checking on the number of arguments I get. If I don't get the right number, I'll print out some nasty warnings. I'll call enter movies to initialize QuickTime. There's actually a step missing here that I don't have. In theory, QuickTime likes to have a graphics port available when it's doing stuff.

Even if I'm not actually going to display any QuickTime movies, it's generally a good idea to have a graph port lying around. So at this point, I should call open new port. Is that what it's called? And have a port lying around. It turns out I've never crashed without it, so let's see what happens. Let's not bother.

So the first thing I want to do is grab the first thing on the command line and do a CFString create with CString. So you're giving me a CString on the command line, and I'm going to get a CFString from that. I want a CFString because there's this wonderful new QuickTime data reference utility called QT New Data Reference from URL CFString. And what that gives me back in its parameters "A data reference is a data reference and the type of a data reference. Again, a data reference is our standard way of referring to something on the disk or something out there on the Internet or something somewhere."

Once I've got the data reference, I'm going to use this new QuickTime storage API called CreateMovieStorage. It takes the data ref and the data ref type, It takes the type of file I want, takes some flags, and it gives me back a data handler and a movie. So now that I've, with just a few lines of code, figured out what the output file should be called and created in a movie, I can loop over all the rest of the command line parameters, which presumably are URLs to the images. And I do sort of the same thing. I get a CFString for the argument. I get a data reference from it.

I'm going to open the image as a movie, and I can do that with Open Movie Storage. Um, get the movie. Finally, when you do that, when you open an image as a movie, at least on Mac OS X, the duration of that movie is, I believe, a fifth of a second.

That would be pretty small for the slideshow I want to build, so I'm going to scale the movie segment of the movie that I just opened to some predefined Duration. Finally, I'm going to insert that segment that I just scaled up to be the right size into the movie that I created.

I'm going to do that for every image on the command line. Finally, I'm going to update movie in storage, which writes out the new movie, and I'm done. So here with about, I don't know, maybe 30 lines of fairly up-to-date QuickTime APIs, I have a command line tool that I can specify a whole bunch of image files to, and then it will create a movie for me. All right, so let's go back to slides.

So that was the case study for command line tools. So let me just wrap up. I hope we've shown today that we've got a whole array of interesting sorts of tools that you can use to build QuickTime apps, not only GUI apps, but also command line apps that will do useful and interesting things. Many of these tools have very standard ways of extending them. For instance, REALbasic or Revolution you can write plug-ins for if there are QuickTime APIs that they don't support natively.

And I really think that right now is the best time to be developing QuickTime software. We've seen at this conference really important new tools, the QuickTime Cocoa Kit, the ActiveX Control, and things like this that really bring us into the 21st century. So you can contact John or me at quicktime@quicktime.com. So you can contact John or me at quicktime@quicktime.com.

And let me just refer you to a couple of sources of information. Mac Tech Magazine, starting back in December of 2002, has had a nice series of articles about various QuickTime programming environments. So virtually everything that I've mentioned here today, there will be at some point in this presentation, there will be a quick time program.

[Transcript missing]

---
Title:  Introduction to Xcode
Year:   2004
Web:    https://nonstrict.eu/wwdcindex/wwdc2004/304/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Ladies and gentlemen, please welcome Cocoa and Developer Tools Evangelist, Matthew Formica. Thank you, everyone. I want to welcome you this afternoon to Introduction to Xcode. Many of you were at Ted Goldstein's keynote yesterday afternoon, where you saw some of the new things we're doing in Xcode. This session is going to continue that, diving down a little bit further into how Xcode works and how you can use it.

Before we get started, though, a couple points to mention. A contest was announced yesterday, an opportunity for you to bring Thursday evening to the Xcode table on Apple Campus, your application building and running in Xcode. This is more than Hello World, but bring your application to the Xcode area, and you can sign in, and you will get a free T-shirt, an Xcode shirt.

The other point I would mention as we're getting started is there, if you go to connect.apple.com, there are some supplementary release notes about Xcode 2.0 associated with Ted's keynote in a disk image, session 300. So you can download those late-breaking news announcements. As I said, this session is about an introduction to Xcode. It's going to talk about some of the new features that we've added. It's also going to give you an overview of the IDE.

To help round out your knowledge of some of the areas you might not be as familiar with. Xcode has been innovating very rapidly over the last year, and the manager of the Xcode team is here with us to go into the details. I'd like to, if you could join me in welcoming Matt Furlick, manager of the Xcode team.

[Transcript missing]

Ah, come on, more thrill-seekers. All right, so before we start threatening you with what's new, let's talk about what Xcode is. Xcode is Apple's integrated development environment for developing software on the platform. Go into a little bit of detail about what it is, but let's talk about what this thing is that you're using and how it got here.

Last year at WWDC, we released a preview of the software on Jaguar and Panther, and we released the first version at the same time that Panther shipped. It includes a lot of features, fix and continue, distributed builds, zero link, a number of great, great features to help you get up to speed.

We released that one in October. We followed that one up with Xcode 1.1 in December. Some bug fix releases, improved SDK support, trying to get you the latest and greatest just before Christmas, 'cause we know you're all working hard right about then. Follow that up with Xcode 1.2. How many of you have 1.2 installed?

Excellent. 1.2 was what we like to consider an enhanced performance release, stability, lots of polish on the IDE. But what we're here today to talk about are two new releases. And to be very clear, we are talking about two releases, Xcode 1.5 on Panther and Xcode 2.0 on Tiger. So you actually have two pieces of software. On the DVDs that you have with Tiger comes a version of Xcode 2.0. But we also have available Xcode 1.5 for you to run on Panther. It's available on ADC sites for download.

Also if you go to the labs, we have disk images of both of these where you can drag them onto your machines and go ahead and install them. So for the thrill seekers that want to be on Tiger, we have software. But for those people who want to stay on Panther, we also have something for you to look at.

So Xcode 1.5 is a beta release. Includes a number of features, faster editing, a better support for indexing, remote debugging, a lot of other great debugging capabilities. Xcode 2.0 is the same feature set but includes a little bit more. Things like design. Tools. Things like workspace layouts, which we'll get into in a little bit. So that's where we stand today. Let's talk about what this thing is. We're an integrated development environment. So let's figure out what that means. Let's take the environment first.

It's Mac OS X. Living on Xcode 1.0 shipped on Panther, so it's moving on that and forward. With SDK support, though, you can develop for any of the Mac OS X releases for the platform. Lots of language support. All the C dialects, Java, scripting languages like AppleScript and shell scripting. Lots of different products, too, whether it's an application, your libraries, your plugins, your frameworks. Lots of different functionality in this application, and we're trying to cater to a lot of different people here.

But we're trying to do so in a way that makes it feel like it's part of the platform. So we're including things like user interface paradigms that you've seen all over the place. Search fields, inspectors, smart lists of things. Things that you're used to seeing and vary the ease of use applications in the Mac OS X. We're going to bring those to you in the development environment to make it as easy as possible for you to work.

So let's talk about development. What does it mean to be development? What are the things that we're including to try and make things a little bit easier for you? To be a development environment, it really requires a number of things. First is workflow and management. There are a lot of things other than source code and compiling things that are really important to your daily life. Project organization, project management, dealing with conflicts from source control management systems, all sorts of big issues. Workflow, where the buttons are, how I get to them, how I get from one place to another. These are all very, very key issues that we've tried to address in Xcode.

Source code editing. I want to edit my source code file, but I want to do it in a particular way. I want a certain color, a certain font size. I want the buttons in the right place. I want things at my fingertips with key bindings. All sorts of different and intricate things that really are important to us as individual developers to get our work done. But then also the ability to provide things like assistance and documentation.

We've got a wealth of knowledge, a wealth of information, both about your product and the APIs you're trying to use, and how we bring those to you in a seamless and easy way is as important to us as it is to you. So let's talk about some of these things.

First, in Xcode 2.0 on Tiger, you'll notice some new workflows, some new what we call workspace layouts. Xcode has a traditional layout, which you've all seen up until this point. We've included a couple different ones to try and give you the ease of use that you're looking for, because we know that there's an extreme breadth of different ways of developing. I don't want to call it religious, but in some cases, it sort of is.

One of these is an all-in-one workspace, the ability to have everything that you've ever wanted all in one window. So per project, you have one window. You have four projects, you have four windows. But there are people that really would like something else, and they want something that's a little more condensed, but so they can have lots of windows.

So a very, very compact project view, but having lots of editor windows or lots of other ancillary windows for your project. So we try and give you both extremes of lots of things or very few things, depending on who you are. And you can have a lot of different ways of developing. And you can see these in the new workspace layouts in the 2.0 version.

Other things that you can see are new attached editors. So things like the build results window, the find window, the ability to attach an editor to the bottom so that as you're in the middle of doing something, as you're in the middle of that workflow and you just want to see a file, I just want to change one thing or scroll and see something, you don't have to get out of that particular mindset or context. You can do it right there.

: Customizable views. Things like being able to take the headers or the columns that are displayed in a certain place and view just the things you want or add things that you want for a particular workflow. Things like SCM information, target management, the size of code, whether it needs to be rebuilt, errors and warnings. All sorts of things to allow you to customize the view to the way you work when you need it.

will be talking about Xcode and some of the new features that are coming out of it. So let's get started. So let's talk about the new features that are coming out of Xcode. So we'll get started with the new features. So let's talk about the new features. The first thing we're going to talk about is the key bindings.

So the key bindings are not just a simple thing. They're not just a simple thing. They're a lot of different things. They're also things like customizable key bindings. I'm sure there are lots of people in here that love Emax, or love a particular program where it's all done right here. You know exactly what it is. Someone says build, you don't think of an action. You think of a finger stroke, or some way of grabbing the keyboard to do something. That's important.

And you'll see that in a little bit. is the founder of Xcode. He's the founder of the Xcode platform. And Matt is the founder of Xcode. And we've had a lot of great conversations with him on this. And he's the founder of Xcode. And we're glad to have him on the panel.

And we're glad to have him on the panel. Over and above just managing your project and deal with some of the niceties, it's getting into your project. It's figuring out what I want to do and how I want to do it. So Xcode includes a number of things like project templates and assistance to help you get up to speed. Pick the type of application or the type of thing you're trying to build, whether it's a Cocoa application or an Automator stage or any of these things. Just go ahead and grab one of the assistance and get up to speed very, very quickly. : Inspectors.

Once you're looking at something, you probably want to change things. You probably want to modify values. You probably want to tweak it just a little bit so that the name looks a little different or it's got a different setting. Inspectors are a very, very familiar paradigm, and we use them all over the place in Xcode to try and give you that ease of use, to make things very, very familiar, but also very, very flexible.

Listing information is very complex. Where you want things to go, how you want things to be viewed can be very, very difficult. And there are things like the whole smart concept, smart playlists in iTunes that keep track of things you looked at last, or mail folders that keep track of some heuristic. We were doing this last year.

Smart groups, the ability to look at something based on a particular element, whether it's a file name or it's the type of thing you're looking at, whether it's a find result or it's an SCM information. Smart, smart things. Let Xcode do the work for you. you just take the benefit of being able to go there very, very quickly and take advantage of it.

When your projects get big, and we know they do, it's the ability to go ahead and search and find things, filter things down, get access to things. It's that one file or that one method you can't find that you'll sit there for minutes just being frustrated, and then sometimes go to the terminal and use grep to find the file it's in. That's not necessary. Xcode provides a lot of functionality to help you find things, both find files, find methods, find functions, find the things that you need, get to them quickly, get on with your life.

Once you get there, though, it's what do I do with it? It's the concept of source code editing, of providing you the ability to use different kinds of editors, whether it's an editor inside of one window or lots of external editors in different applications, using the things that you're used to and getting the functionality that you want.

Things like file editing history, be able to go back and forth between a number of files very, very quickly. If you're looking at an implementation file or a definition, go back to the declaration, or pop between three or four files if they're all related. These are things that are relatively easy to do, and we provide them for you.

Function pop-ups, being able to introspect a source code file and show you what's in it, give you quick access to jump to a particular point in your file. Also things like counterparts and inclusions. We know all sorts of things about your project by virtue of having it indexed.

We can show you things like, oh, I know where that other file is. I know where the header is for this particular element. Or I know all the files that happen to include the one you're in. So if you make a change here, we make it easy to go to the other ones. Little tiny things, intuitive things, that we provide right at your fingertips.

Even things like an annotated gutter, when you build and you have problems, errors and warnings. We know where they're from. We know specifically where they're from. We make it very, very easy to get back to those places, get those things fixed, and get on with the things you need.

I mentioned editor support a little bit. We also have support for external editors, popular editors like bbedit, subethaedit, even textedit if you like. Use those as your standard editor if that's your preferred method of editing your source code file. But take all advantage of the rest of Xcode to allow you to use that functionality and work through your project. projects.

Once you start working, again, there's lots of assistance we can provide, and we've done a lot to take what we call code sense, our ability to take a symbolic index of your source code and provide it to you in useful ways. One way that you saw last year in Xcode 1.0 was code completion, the ability to take this symbol-rich information and say, you know what?

Contextually in my source code file, I'm right here. Help me with this. I don't know the method I'm looking for. I forget the function name. I know there's a variable, but I can't remember what it is. The ability to provide that to you at your fingertips. I'm very pleased to announce that last year we mentioned that we were going to do it for all the C dialects. Today we have it for Java. So all the Java developers here, you have code completion now.

Also things like design tools. If you saw Ted's keynote yesterday, you saw the ability to take source code that you have and design it, look at models of it, take an overview of it, not just from how it's implemented, but as a management tool, as a design tool, as a way to work with other developers and say, this is the kind of thing I'm looking for. Very, very powerful tools built on stuff that, again, we already know about your source code. So it's not work you have to do. It's just something you can take advantage of.

also thinks like something simple like open quickly. We know there are lots of things on your system. We know there are lots of places you want to look for things. We help you with that by giving you the ability to specify, you know, regardless of what project I'm in, I want you to look all over here to add to Xcode's purview just a list of all sorts of things that you want to have access to, to, again, make it very, very easy to keep track of those things, but make sure that they're right at your fingertips when you need them.

and certainly not least, documentation. We have the pleasure of having lots of lots of very, very good and rich documentation on both our APIs, our tools, and all sorts of different functionality. And this is integrated into Xcode. There's full API and full text searching, so you can type in whatever you're looking for, whether it's a particular method or a particular class, and find what you're looking for.

All the reference materials, all the tutorials right at your fingertips, with quick navigation, with different keystrokes to get right to it from your source code, but also the ability, the new ability in the new Xcode releases of bookmarking it, of waiting all the way down to the depths of the documentation, being able to mark it and say, you know, this is important to me. I want to get back here. So we've included bookmarks in that. will be here to talk about the basic things. Let's go through a quick demo of some of those project navigation elements.

So what we're looking at here is I'm going to open up a simple app. It's called Blast App, and it's actually a Java application. So we're going to go ahead and open this up using the older style workspace, just as an example here. But we'll see it's divided into two main elements.

We've got the outline view on the left-hand side, which lists a hierarchical view of your application or your project. It gives you the ability to structure your project in any way, shape, or form. These are groups that you can create. You can drag files into any group that you want to, regardless of where they are on the file system, allowing you to organize your project maybe the way you think about it, not the way it's laid out on disk.

But you'll note that beneath that are some of the elements that we call smart groups, the ability to do something interesting with content about your project for you, things like errors and warnings, fine results, bookmarks, other smart folders that we create for you, the ability to take this information and provide it right at your fingertips.

Now, as you click through things on the left-hand side in the outline view, they're going to show up in the detail view on the right-hand side, just a flat table view. So you can see that you have a flat table view of all of the content that are inside those groups. This makes it very easy to navigate and look for things.

Whereas the hierarchy gives you structure, allows you to compartmentalize things, it also requires that you have lots of hierarchy, potentially lots of hierarchy, that where you don't want to find something that was way down at the bottom, you'd have to go through and twiddle open all the folders and potentially close them all back up.

But with the detail view, you can just go ahead and select something. And we'll show you the aggregate of the selection on the right-hand side. So as I select different folders, we'll start to see that the contents of those folders appear on the right-hand side, making it very easy to look at different kinds of things.

Now this is particularly useful in these little smart folders we have down here, which are actually folders we've set up to look at a particular type of file. It's basically a rule that we ask it to filter on. In this case, the first one is nib files. So we're just going to show the nib files here on the right-hand side.

The next one is implementation files. And in this case, I only see one. Unfortunately, our default implementation file smart group filters on .m and .h. Well, I don't have .m and .h, I have .java in my application here. So let me just go ahead and add a new smart group here to show you how easy it is to get something particularly powerful. So I'm just going to go ahead and call this java files. And I'm going to change the pattern here to instead of being star.nib, just to star.java. And you see that instantly, there are all the java files in my application, or my project.

Maybe I want to do something a little more interesting. In this case, the Blast app has a bunch of what are called smart elements. So I can just do smart star.java. And there's a particular set of files. Now, that may not seem relatively powerful, but the ability to hone this down and say, you know, today I'm working on just these files.

They're spread all over across my project, but I want them in one place. I want them in a simple place that I can go and get access to them. We make it very easy to go ahead and create those. Additionally, we can actually save these on a per project or for all your projects on a per user basis. So were you to find something you find really, really useful, you can go ahead and set this up once, and all of your projects take advantage of it.

[Transcript missing]

So in addition to some of these file-based smart groups, we also have things like project symbols. So the project symbol smart group takes the contents from the symbolic index that we have about this project and shows us a list. So I can scroll down through the list here of all the different symbols that are in this project. And I have the same capabilities of being able to filter on it. So I can filter by name. And let's just go ahead again, look for the word "explode." And apparently, everything in this app explodes.

[Transcript missing]

For some people, though, this is not enough real estate to edit. No matter how big I make this or I want this, I want something a little bit different. So, in addition to providing the internal editor, we can also provide a separate editor. I can go ahead and double-click on a source code file, and you note that it pops up in this separate window. I can go ahead and do that for a number of other files, just bring up as many files as I want here, and I can get all the windows that I could ever possibly want.

: How many windows are too many? At this point, we have four windows for editing, and the screen's getting a little bit cluttered. So we provide you the functionality to tailor your workflow in such a way that if I close some of these other windows and go back to the first one, I see that I have a little tiled editing mode button up here. When I click it, it becomes a single window, such that if I go through and now open some more files, you'll note that they all appear in that one window.

So we allow you to say whether you want all of your stuff in the project window, you want all your stuff in separate windows, or you want one separate window to put all of your source code in, making it easy to move back and forth between different pieces of source code.

So now we've got source code. Let's do something interesting with it. So as I've mentioned before, we now support code completion for Java. So here's a little bit of Java code in the Arrow Base class. I'm just going to go ahead and I'm just going to move this code down a little bit, give myself some room here, and say that I was just typing this for the first time. So pretend this doesn't exist here, but use this as reference for what I'm going to start typing in. I could just go ahead and start typing, you know, "game piece," and you see the ability to not type when you're up on stage is pretty prevalent.

So what I want to do is in this next case, I'm going to say, "All right, I have this Arrow element. I should be able to use something I know about this by the virtue of the fact that the project knows all kinds of things about the Arrow class." So I could just go ahead and hit the code completion key, and it's going to go ahead and bring up a list of things. You'll note at the bottom of the completion pop-up, it says "game piece." It knows what type it is, and it's showing me things that match that.

In this case, it's showing me all the elements that seem appropriate based on the letter "i" that I typed in. In this case, what I want is the "init in game" method. So I can just arrow down, or I can use the mouse to select that. It's going to automatically select the placeholder for me, and I can type that in. I can also do something like the next one, where I know that the Arrow also has lots of set methods, and I can go ahead and set the velocity. And in this case, it's a new NS size.

But now I might get here and realize, you know, I don't know what an NS size is. I don't actually know how to use this. At this point, we can use the fact that we have lots of documentation, and we can use the reference to figure out what these things are. We also have two keystrokes that are particularly useful, that I think most people don't realize at first, but once they do, feel like they can't live without. Those are Command-double-click and Option-double-click.

If I command-double-click on NS size, what it's actually going to go do is bring up a list of all the things in the symbol index that match that and allow me to go ahead and select one and take me right to it. In this case, it's not necessarily very interesting. The implementation doesn't really do very much here.

So let's instead do an option double-click, which is going to bring up our documentation window, automatically put NS size up here in the upper right, find some matches, and automatically show me one of them. And that's the one I'd be looking for, would be the Java reference implementation for NS size. This is a very, very handy window. If you've never used it before, I implore you to go ahead and grab the Help menu and pull up the documentation.

The ability to look based on groups, the ability to take my search and click on a library and refine that search to that particular set, to be able to look in the drivers, to be able to look in Java and refine this search, but also the ability to change my search from, in this case, we're looking at APIs. Maybe I want to do a full-text search of anything that has anything and everything to do with NS size. So go ahead and enter that. Hit Return, and we're going to go ahead and search all these locations, doing relevant searches on all the content here.

Where I'd actually want to go down and pull up a particular class, I could say, ah, this is the one I've been looking for for so long, I could just go ahead, add a bookmark to it, and it's going to appear right there, so it allows me quick access to go back to it later. Full suite of documentation right at your fingertips, very, very easy to use.

So you've seen some code completion. Let's talk a little bit about indexing in general. You've had a lot of feedback on indexing. We've listened. We've done some things about it. We've given you code completion for Java. We've improved the indexing speed in general and our accuracy in our parsers. But probably the most requested feature, we've put indexing on a background thread.

So now as we parse your source code, that's all going to be done on a background thread. It's not going to interfere with you. It's not going to bother you. Go ahead and go about your daily work when the index is done. You won't even know it because it won't even have been bothering you.

But we've improved the speed in general. And what I'd like to do is show you an example of how that looks. So what I'm going to do is I'm actually going to bring up something I mentioned before, which is the activity window. It's going to sit down here in the lower right.

And the activity window is going to show me things that are going on in my application. Now in this case, what I want to do is actually show you the indexing. So I'm going to go ahead and bring up the Project Inspector. And I'm going to go ahead and bring up the CodeSense tab. And you see that there's this little button here called Rebuild Index.

Now I'm sure most of you are sitting there going, he's not going to press that, is he? He's not actually going to try and rebuild a Java index for a project on stage, is he? That takes forever, doesn't it? If it's going to work for you, it's got to work for me up here. So I'll watch the activity view in the lower right. I'm going to go ahead and click Rebuild Index. It's going to ask me if I really want to do this. Do I?

So I'm going to go ahead and click OK. We're going to see the project industry starts up. And wait. That can't have worked. Let me go back here to my project symbols, just make sure that-- we actually do have project symbols. We seem like we had them before. Let's just make sure. Let's go pull up the class browser here.

This will be the true test. Well, we've got the class browser here. Let's make sure we do have the-- well, yeah, we do have all the JDK information. All right. So to prove to you that this is not sleight of hand, I'm not making this up, I'm going to go ahead and disable indexing. So I'm going to turn this off. And you'll note that both of these windows go away. I no longer have content. I can't code code complete. I can't do anything because I have no more index.

So now I'm going to go back, bring the activity window here to the front, go ahead and click on Enable Indexing. You'll see that the project indexer starts up. And lo and behold, there's my project symbols. I can go back here. And again, I'm not making this up. There's the JDK.

Now, to be honest, this is using a lot of capabilities of Xcode. We have index templates. We have updated parsers. We have all sorts of things that make this possible. But indexing should no longer be a burden on you. It should be something you guys all want to use, all want to take advantage of.

One final thing I want to talk about with just general workflow is the ability to set key bindings. An oft-- or a seldom used control panel-- or a preference here is the key bindings. The ability to go in and select a key binding for Xcode or for another IDE, and the ability to go through and set things. Here are all the menu items, and here are all the key bindings.

The ability to just go ahead and double-click on one of those and set it to whatever you want. I would encourage you guys to go ahead and look here, because it also shows you a list of all the things that are available in Xcode, all the different functions, all the different features. Customize it to your will. Make it the way you want. Very, very useful feature. So that's just a quick overview of some of the project management and navigation elements. Let's take a look at some of the other parts of Xcode.

I would implore you that there's an increasing productivity session tomorrow in this very room at 2 o'clock, which goes into a lot of these elements in much, much more detail. So I'd encourage you guys to come to that if you're interested in this content. We talked about the environment. We've talked about development. Let's talk about integration, because that's what Xcode is about, is integrating all sorts of really great features into an IDE.

There are all sorts of things we have to pull together to make development possible-- build system, debugger, source control management tools, profiling tools. These are all things that we can add in and leverage from our platform to give you advantages, to give you things to get your work done. The first one is an integrated build system.

This is kind of key. We have a system that takes a project model and implements the idea of targets. Targets are instructions or sets of things to create something or do something. And we have lots of different support for different kinds of targets. We spend a lot of time creating something which we call the native build system, native support for creating projects. Native being that we control things. We have lots of ability to do really good dependency analysis and give you all sorts of benefits. We have support for the same Jam targets that Project Builder had.

And we also have external targets support for things like Make and Ant, the ability to do something outside of Xcode but still take advantage of the Xcode build system. And there are all kinds of different aspects of the build system, where you have products and executables, lots of different ways to customize your application, customize your project to get the things that you want.

A good deal of the build system is customizing it to suit your needs, to do the things that you want. The ability to take and inspect settings both on your project, on your targets, set compiler options, set build flags, set encodings on files, get the things that you want in the way that you want them. And we'll take a look at some of the inspectors for this in a little bit.

But there are lots of different features to the build system that provide lots of great functionality. As I mentioned before, the ability to provide you inline errors and warnings, to show you in your source code where things are going wrong, allow you to change them and keep them back up to speed, get your application running again.

Smart groups of errors and warnings to keep track of those things as you make changes. But even a detailed build log for those who like to live on the bleeding edge to see the absolute honest truth of what's going on and filter through all the content to see exactly what's happening with your application. The ability to manage source trees, working between applications and saying, here's where all my sources are and I want to manage this across a number of different people, even though we have different structures on our machines.

Shared build locations, so I can build something once and everybody can take advantage of it, or I can use it across multiple projects. And the ability to use SDKs, the ability to say, I'm on this platform, but I want to build for a different one. Very, very powerful, very compelling feature.

But in the end, it's all about performance. It's all about saying, you know, this is the heart of the matter. If it takes too long, it's not useful. It's not helpful. And what we've tried to do is implement a number of features to give you the green light to make sure that build performance is not an issue for you.

So the first one of these is the support for pre-compiled headers. The fact is, no matter how big our applications are, the amount of information we're pulling in from other resources, from frameworks and libraries, outweighs ours by perhaps an order of magnitude or more. Our applications are this small when you compare it to all the stuff that's being compiled in there. The ability to pre-compile those and to say, you know, I know I'm going to need them. Why wait till I want to compile my app to get them?

Pre-compile the header. Get it out of the way. Take it out of the way, because that's not what we need to worry about. What you need to worry about is the stuff in your project. So pre-compiled headers gets a lot of that bottleneck out of the way and gets it done ahead of time.

[Transcript missing]

Something we also introduced called Zero Link, the ability to just take the link step out of the way, to dynamically load in the elements that you need as you need them. When your application starts up, you may not need everything, so why try and link it? Why spend that time overhead early? Let's just do it later. So we're going to reduce the linking step down to a very, very small fraction.

and then distributed builds, the ability to say, I've got all these machines. We do take advantage of the fact that if you have two processors, we'll do parallel compilations, so you get twice as much. But what about all those other processors that are sitting out there, all those other machines that are potentially idle? We want you to take advantage of those. So distributed builds allow you to take advantage of all sorts of machines. Heterogeneous, homogeneous environments, whatever you have, we'll take advantage of those. Start sending the files out across the wire, let them compile, and bring them back.

So we do the pre-compilation for the headers and the linking on your machine, but we only do those once. So you take care of those, send everything out, and bring it all back. So I want to go through a quick demo of some of the build system features.

What I'm going to do is actually change applications on you here. At the moment, we have native support for the C-based languages, not for Java, although we are working on that. So I'm going to go ahead and open up an OpenGL app here called Boing. I'm sure this is an app you guys have all seen before. Just has an OpenGL rendering of a little bouncing ball that we'll see in a little bit.

As I mentioned before, we have elements like inspectors that can go ahead and look at different attributes on a file. So I can just go ahead and select one of the files here in the detail view, bring it up, and look at different information. I can see that there's path information, there's all sorts of file encoding information. There's actually an additional compiler flags. I can set per-file compiler flags, which make it very easy to customize on a per-file basis.

But one of the things we've included in Xcode as a result of lots and lots of feedback is the ability to do multiple selection. For example, here's the directory structure for my project. And here's something that perhaps a lot of people like to do is say, you know, I want to create this source folder, and I want to grab a whole bunch of files, and I really want to put them in here because that's really the way I work with my project. And the problem is, you go back to your project, and now they're all red. Xcode says, I don't know what happened. They went somewhere.

And normally, you'd have to go through and inspect each one and change them. But now we have support for the ability to select multiples, come up with a new one, and then we can go ahead and do that. So let's go ahead and go ahead and go ahead and select the source folder location. And you'll notice that they all turn black again. The ability to modify multiple selections very, very quickly and easily.

Now, of course, we all know that our source code revision control system would really not appreciate us doing that. So I'm going to go ahead and take that back out, and I'll play nice and put them back the way they were. But this multiple selection works both on the file level, and it also works on the target level. The ability to go ahead and select multiple targets, for example, and set the same setting on multiple targets at the same time. So all the sorts of settings you want, you can set them now on a per-target basis -- or multiple-target basis, rather, as well.

Let's go ahead and look at the inspector for the targets, because we've made some improvements here that you guys also should see. I'm going to go ahead and go to the Build Settings tab here for my target, and we'll see that here are all the different build settings for my particular target. Now, you'll note that one thing we've changed here is the ability to look at collections or groups of settings.

By default, we're looking at all of the settings, but there's this nice little pop-up here where I can now go through and say, "Oh, I want to just look at the versioning flags," or I want to look at all of the -- everything that has to do with the compiler, or something that has to do with linking. The ability to filter down the list to see just the things you want and the way you want them.

You'll also note that there's a setting at the top for customized settings, and these all appear in bold. These are settings that you've customized or that are changed in your target from the defaults. So just a little bit of piece of information here. When you see the bold settings -- if I go back to the All settings and you see that there are some in bold -- you know that these are ones that have customized values. You also note that the ones with little strikethrough, those are ones that have been overridden by your build style, but there'll be more on that in a later session.

Some other advancements we've made in setting information here is the ability to edit large settings. For example, a product name. You're probably not going to have a really huge name for this. I could just go ahead and click on this and change it right in here. But there may be settings that are particularly large or need to be set. For example, header search paths. I may have lots of header search paths.

Up until this point, you've had to click in here and start typing and scrolling all the way over. It was kind of like setting the path back in Windows 95 where you just had to keep moving over and over and over. We apologize for that. And now what we've done is given you an edit settings button. So now what we're going to do is bring up a table view, which you can go ahead and click in here and start adding different settings.

You can also do nice things like, I don't know, I can grab a folder from my project and do that. I could also go into the finder here and grab a folder and bring that up. To be able to take large settings. and manage them in an easy way.

We also do this for just plain string values. So I could go ahead and go back down here to my product name and just go ahead and click the Edit Settings. And I could make this as big as I want to, were my app to be named something really large. So build settings.

So quick and easy way to go ahead and modify information in your project. Let's go ahead and let's just actually go ahead and build this. So what I'm going to do is I'm actually going to select the implementation files down here, just so that they're visible, and I'm going to go ahead and click the build hammer.

So what this is going to do is start building, and you'll see that as it's building, the size of the code is going through here, and you'll see that we have different sizes here, and oh, look at that. Build failed. What a surprise. So now I need to figure out something happened.

Something is wrong with my build, I need to figure out what's going on. There are a number of different ways to do that. You see that we annotate the status bar with the build information on both sides. You'll also note that now the errors and warnings smart group is in red, and if I click on that, I can see all the details about what those are and where the problems were. I could also go to the detailed build log up under the build menu here and see all the detailed build results. So I'm going to make this window a little bit bigger and scroll this down, and it's the same information that you saw before.

But what we're going to do is just put in the detailed build window, and for those who really want to see everything, we can scroll it up and see here's exactly what happened through the build. And it's important to note that these windows actually track. So we're going to go and select an error up here. We actually highlight the appropriate line down here that shows where that error was generated from.

So you can get exactly down to all of your problems. So let's just figure out something was wrong with apparently the Boeing view class. I'm going to go ahead and bring that up in the editor here, and you'll note that we annotate a number of things. First, we annotate the scroller here, which will give you access to where the things have gone wrong. We can see we've got a couple of different spots here, and we also annotate the gutter for the different elements.

So I can see if I look at this first one here and I go ahead and click on it, you'll note that the error comes up here, and it says that new is undeclared. That's because that really was meant to be no. So I can go ahead and fix that error. I can scroll down here to the bottom and say, oh, well, here's just a warning on something I needed to do before. I left that in there. I can just go ahead and take that out.

Let me scroll back up to the top here and see what these other errors were. Again, it's a simple one here. I just forgot a semicolon. Maybe that will take care of it. So I'll go ahead and fix those and click build again. It's going to go ahead and build it, and it's like, nope, still didn't do it. I still have this one problem where there's this index default value. It doesn't know where it is. It's not declared anywhere. Well, that was actually my fault. I meant to actually define that as a preprocessor macro.

So I can just go back to my build settings here and take advantage of this nice search field at the bottom. And start typing in preprocessor. And I can just go ahead and take this value here and put it back over here, paste it in, and say that equals zero. Now I should be able to go ahead and build my application. Go ahead and click compile. Build succeeded.

Quick and easy way to find some of the problems that are in your application, get on with just building it. We also have a number of other build features. We have the ability to compile a single file at once, to preprocess it. Where you actually want to see what the assembly code looks like for your particular file, you can actually go ahead and do that. ahead and do that and here's the assembly for what this particular file would look like.

So that's just a quick overview of some of the build system features. There are other sessions on the build system later on in the week, actually one tomorrow at 3:30 in this very room, the increasing productivity with Xcode 2, which I would encourage you guys to go to if you want to learn more about the build system. So let's learn more about Xcode, and this time going into the debugger.

So if we go back to the slides, please. Debugging is also important. Once you've built your application, you need to figure out, all right, how do I deal with it now? How do I figure out all these problems? Just not just warnings and error, but aberrant behavior. We include a completely integrated debugging experience. It's a full-featured debugger for the C dialects for Java, even for AppleScript, with all the common operations you would expect-- the ability to step through things, to pause through things, look at things, introspect things. It's very, very feature-rich, includes a lot of new features.

We include things like inline breakpoints, set them right in the gutter, move them around, PC backup, and try things again. A complete graphical interface to look at things like a thread view and a stack view. Look at all of your different variables with custom data formatters, even based on your types, to look at the information you want in the debugger.

Also some new features-- the Globals browser, which maybe you saw yesterday in Ted's keynote. You'll be able to look at global variables for your application. A memory viewer to go ahead and look at memory points for your application and see exactly what's going on. Even the ability to look at disassembly and see the different things that are in your application.

But there's lots of other integrated debugging features. Things like data formatters, as I said before. The ability to take a particular piece of information in the variables view and customize it. You may know something about it and you want to format it or summarize it in such a way that's easier for your work flow.

We provide a lot of those by default for the Carbon data types, but you can actually go ahead and do those for your own data types as well. But much like with the build system we also try to provide you features that get you up to speed, get you running, get you very productive, as productive as possible with a debugging experience. is fix and continue. How many of you have actually used fix and continue?

Thanks, Matt. Not enough. It's a very, very good feature. Fixing to Xcode allows you to take a running application that you're debugging, make changes to the source code, change the application on the fly, and keep running. So you go ahead and patch the running application. Things like logic errors, errors of trial and error, where you need to try something over and over and over again.

If your application takes a long time to compile or takes a while to start up, you don't want to have to go through that just for a simple change of, "Oh, I forgot a semicolon there," or "That was supposed to be two instead of one." The ability to go ahead and fix your running application and get it back up to speed is very, very useful. And I would encourage you guys all to try it. Other things like remote debugging. We saw a demonstration yesterday of a game developer debugging an application running on one machine with a debugger running on the other.

This is extremely useful for both full-screen applications, but also applications that have lots of intricate event handling, things like mouse clicks and keys and highlights and stuff. The ability to track those. Let your application deal with it in such a way that it's not affecting by the debugger popping up or a breakpoint being set, but still being able to debug your application like you would normally. It works exactly like it would on your one machine. So the debugger experience is exactly the same, but you take the leverage of the fact that you have two separate machines.

And something included now, which is called GuardMalloc, the ability to actually use the fact that we know when bad things happen to your memory, and we're actually going to show those to you. When there are memory access errors, we're actually going to throw an exception and say, "You know what? This is a problem. You need to go and look at it." So it's a great debugging feature. So I want to show you a quick debugging demo on what some of these features look like.

So we have the application that I just got done building here. So this is the same Boeing application. I'm just going to go ahead and launch it under the debugger. So I just said, go ahead and debug. I probably didn't need to say build again, since it's already built. is going to go ahead in a second here. The debugger is going to start up, and we'll see what it looks like. So right now, we are going through and debugging our application.

Now, I've scripted my application demo here in a very, very specific way to talk about what happens when we're dealing with beta software. All right? Now, we release beta software just as much as you do. Things happen. Now, this is a really important point, is that this panel right here is your gateway to salvation, because it's your way of giving us information. The ability to go ahead and say Report, to click on this and say, look, here's the crash information for Xcode.

Here's what happened. You have lots of power at your fingertips to fill out exactly what happened or what you were doing here, and click Submit and give us that information. Even more to the point, were you nice ADC developers and you'd want to actually take advantage of the fact that we have this little website called Bug Reporter. You could actually go in and file a bug, take that Stacktrace information, and put it in the bug. Because the fact is, the benefits of our application, the feedback that we get on our application, shows in what we release to you guys.

The better feedback that we get, the better the product is when it comes back out. So I'd encourage you-- I can only speak to my application, but I would implore you that were something-- not that it happens, but were something to happen in Xcode where you'd get this panel, I'd implore you to please submit that information. Please submit us a bug report so that we can show you what's going on with it.

So now that the little public service announcement is done, let's go back to the demo and go back to the application here. So now I'm just going to go ahead and let's just clean the application. Again, show you the nice build system at work. And we're going to go ahead and build and debug. So again, we'll watch the application compile here. And we'll watch it come back up, this time in the debugger, much as we would expect.

So now I'm just going to go ahead and let's just clean the application. Again, show you the nice build system at work. And we're going to go ahead and build and debug. So again, we'll watch the application compile here.

[Transcript missing]

So let's go ahead and look at some of the other controls that are up here.

We can go ahead and continue through-- we paused right here on our breakpoint. We can go ahead and step over a particular element. Just go ahead and keep stepping through my application. I can open up and look at more elements in the debugger. But we can go ahead and do that. Or we can just go ahead and continue. It's going to hit my breakpoint again, so I'm going to go ahead and unset that and continue along the merry way.

Let's show you some of the elements that we talked about, like fix and continue. For example, I'm looking at this, and red is just not the color I'm looking for. I really want something else. So I've actually set some nice little bookmarks in this file to go ahead and jump right to a particular point. And we see that right here is where the colors for that panel are that this panel is defined.

Right now it's red. It's an RGB value. And I can just go ahead and change those values from red to blue. I'm going to go ahead and save that file. And now I'm going to go up here and click Fix. So while my application is running, I'm going to hit the Fix button. It's going to go ahead and compile it.

It's going to go ahead, and now my ball is blue. Application's still running, but I'm changing values that my application is using. I could do other things, like changing simple things, like set the background color. I think that that background color is way too dark. Let's just go ahead and change the value here.

is a very good example of how to use the Xcode application. So, I'm going to go ahead and save that again. Again, while the application is running, go ahead and click "Fix." And now we're changing the value. Now, these are just simple values that we're changing. It doesn't look that complex. But the ability to try things out like this, to do trial and error things while the application is running, is very, very useful.

Let's do something a little more complex. For example, there's something here called the "light factor." When I hit the "L" key, it's actually going to start applying a light factor to the side of this cube. And you'll see that the cube gets a little bit darker. Now, the problem is, I have no way of undoing this.

The way they implemented it was it just starts the shading, and there's no way to change that value. You can actually see the code is actually right here, where as it's drawing, it says, "If I'm supposed to do this, increase the light factor over time until we get to 1, and that's it." There's no way to undo this.

So, let me actually show you modifying this code while it's running, something more than just little logic values. Well, to do this, the problem is I want to be able to cycle back and forth between the light value and the non-light value. So, I'm going to go ahead and add this other Boolean in here.

Called "DoLightIncrease." And I'm going to go ahead and say that, well, in this particular case, if our light factor is -- if we're increasing, then I certainly want to make the light factor increase just the way it was before. So, we'll say the light factor still increases by .005. But if it's not, what I want to do is I want to decrement the value.

So, we're going to use this Boolean to track whether the light is increasing or decreasing. So, in this particular case, I need to say, well, if we are increasing, and the light factor is over one, just stop at one. Don't go over and above that. But now I need to add a little else clause in here that says, well, if I'm not increasing, if I'm actually going down, and I don't want it to go below zero, because I don't want it to fade out completely, then just set the value to zero, and we'll be done.

So, now I've just added some code to go ahead and allow us the ability to cycle between whether this has a light factor or not. One last thing I actually need to change was that there's this keystroke at the bottom here, or we actually go ahead and click the key. It's right here where you see if I hit L, it says do light equals yes.

And in this case, I want to say, well, I only want you to do -- we use some code completion to get that value for this. I only want you to increase if the light factor is already at zero. Otherwise, I just want you to decrease. So, we're going to go ahead and set that up, save that, and now I'm going to go ahead and click fix.

So, while this is running, we're going to go ahead and fix that, and now I should be able to come back here, hit L, and turn the shading off. So, the ability to add, you know, different instance variables, change the logic to your application while it's running makes it very, very useful to debug.

There's some simple things we could do. We could go ahead and, if we want this all to end very, very quickly, I can just check the animation, change the velocity by which this is running to something much, much quicker, and make the ball stop for all of us.

So let's look at some of the other elements to our application while it's still running. I'm showing you a couple other things. Features that we didn't talk about yesterday but are worth showing is something like the memory browser. So what if I want to look at different pieces of memory in my application? I want to look at something, you know, something interesting.

We allow you to go ahead and let's just go ahead and let's just pause this and... Here's a memory viewer. This is not my particularly favorite view, but I know a lot of people are looking for this kind of information and being able to actually step through your memory and look at different pieces of information, to look at all sorts of things. If this is for you, we're happy to provide it. There are other things, like even a console view. If you love the console view and you want to live there, we provide a quick and easy access way to get to it.

So we try to provide you the best of all worlds. Functionality gets you up to speed with what you're looking at from debugging features, from simple things like looking at variables, to fixing your application while it's running, or looking at memory. The ability to take your application, figure out what's wrong, and get back to what's important.

So these are just some of the quick debugging features. We have a complete demonstration of debugging on Thursday. So we go back to the slides. There's a complete session on this on Thursday morning at 9 o'clock, again in this room, debugging in Xcode. But I'd encourage you guys all to go to for more information.

Another thing that's important once we're building and debugging our application is working with other people. Source control management. For those of you who are using Xcode, you may not have realized that source control management is in there because it's actually integrated. It's immersed in the IDE in a large number of places. You'll see it in visualization columns, in the outline view and the detail view.

You'll see it in a smart group of showing you all the things that have changed. We have a complete SCM window for showing you all the things that have changed in your product and looking at the SCM log. And we also have inspectors to allow you to look at different revisions and track things and compare things based on a particular file.

Now, we support all the common commands from the IDE, the ability to look at annotations, to update, to discard changes, to look at revisions, annotations, diffs. These are all available in the IDE, both from menus and context menus, right at your fingertips. As was announced yesterday, we are happy to support now Subversion as one of our ICM systems, fully integrated into Xcode. So what I'd like to do is show you that right now.

So let's just take the same project that I was working on for a quick second. I'm going to go ahead and stop the debugger because I don't really need that anymore. And you guys are probably going to remember to do this, so I'll close that window. So now I'm in my application. And you've seen me make changes. You saw me make some changes for fix and continue. Question is, how do I know that I've made those changes?

Well, one way to do it is to customize the view here. I could go ahead and customize the panel here by control clicking on the header. And I can select SCM. And we'll see that it tells me that the project has changed. And as I expand things, we also see that there are other files that have changed.

I could actually go ahead and add the SCM column over here, if I want to look at it in the detail view, so I can see it in either or both of these views. But if you want to look at all the SCM information in one place, there are two ways to do it.

If you want to look at it in the project view, you can go ahead and select the SCM Smart Group. And now we're going to filter on all the files that have some kind of SCM status, whether it's modified, changed, conflict, whatever it is, this is going to be the one-stop place you want to go out and look at.

We can also, though, bring that up in a separate window. So I can bring up under the SCM menu the SCM window and show it to you here. So here are all the files that have changed. And I see that I have the files that I changed, and now I have my user file and the project file. Let's go ahead and look at something interesting about what these files are.

So let's go ahead and select a file here. And I'm going to go ahead and bring up the inspector for this particular file. And you see that there's an SCM tab. And when I click on this, you'll note that here is the SCM history. So I have the revision history, I have my name, the date, and I have a message.

So I can go ahead and look at-- I can go ahead and look at different pieces of information. So let's take the version we have, and let's compare it to something from 9:00 this morning. And I can click on Diff. So what it's going to do is take the version I have on disk, go and grab the selected version from a repository, and here's a diff. So I can go ahead and put this into a bug. I can send this to someone as changes I've made, very, very quick and easy way to compare revisions.

[Transcript missing]

if I were to go back in here and grab my element, we can actually go now and look at the annotations. So let me grab that particular source file, say grab the latest for that. And it's going to take that and pull it up in an editor.

And here is the annotation response for this particular file. There haven't been that many changes. I've only made a few changes. But as we scroll through, you can see what revision was changed and by whom. Now you might be asking, well, these revision numbers look really kind of strange. I don't know that I've seen these before.

One thing that we actually pride ourselves on is the fact that all of our SCM functionality is seamless. It also feels the same. So you may not have been noticing, but this is actually using subversion. So if we pull up our little status window here, and I can just go ahead and zoom in for you right there, you'll note that user local subversion bin SVN.

This is all been using subversion. So same thing as CVS acts like CVS commands in Xcode, but it's using the power of subversion. So the fact that you can't tell the difference is actually a win for us and makes it feel like we've done the right thing. the right job of not making things all different based on different SCM systems.

So we can actually just go ahead and once we're done, let's just actually show the very simple thing of go ahead and selecting a couple files, go ahead and committing to changes and say this was in the demo. Go ahead and commit those. We'll go ahead and commit those to the repository.

You'll note that they go ahead and leave the view and they've been committed. Simple SCM actions, simple things that your daily workflow probably requires doesn't require you to leave the IDE. So that's just a quick visual of source code management. There's more on this in the presentation tomorrow. tomorrow if you guys want to learn more information.

[Transcript missing]

So what I'm going to go ahead and do is I'm just going to quickly rebuild my app because I made changes with ZeroLink, and I want to make sure that we've actually built those into the application. But under the Debug menu, we'll see that there is Launch Using Performance Tool, and there's a couple here. Let's just go ahead and pick Object ALEC first.

What it's going to go ahead and do is it's going to go ahead and launch Object ALEC for me, and it's going to configure Object ALEC to go ahead and launch my application. So you see that Object ALEC comes up. It already knows about where my application lives.

I can go ahead and hit the little play button here and tell it what I want it to do. And now it's going to go ahead and launch my application and start looking at it, start looking at all the things that are being allocated in this. Right now we have live updating going on, and I can start scaling this back.

So you can start to see what the allocations are, how they're being projected through your application, and you can start to figure out where the leaks are happening, where you may be creating more things than you really need to, where things can be trimmed down a little bit.

Quick and easy way. We've already built the app, launched it in Object ALEC, but it makes it really easy to test and see how your application is working. But say you want to do something a little bit more complex than this. Say you want to figure out not just where things are being allocated, but where you're spending the most time. To do this, we're going to go ahead and use Shark. The same way, we're going to go ahead and launch Shark. It's going to be pre-configured to know where our application is.

Go ahead and say OK, and it's going to start up our application. Shark is now sampling up here. We can go ahead and click Stop. And it's going to go ahead and take all the samples that it just found from our application and bring them up in this view. How many of you guys have used Shark?

I would implore you guys all to take a look at it. It may seem a little complex from the beginning, but it's a very, very simple application to use, and it provides a lot of information about what your app is doing, about the ability to go and look at even just the things that you have source for, and to go ahead and drill down into, I'm spending 34% of my time in this draw rect particular function.

You can see that based on where the shading is of where you're spending the most amount of time. It doesn't take that much effort to go ahead and look at this, but it provides you a vast amount of information about where you can improve your application. So just a quick overview of launching a couple of the performance tools. If we go back to the slides, again, there are complete sessions on this. There is one on Friday in the afternoon on actually using Shark to work with your application.

This is what we do all day, is Xcoding, is providing you a set of tools to work for all kinds of different development projects to help you guys bring things to the Mac OS X platform. And as we talked before, we're providing you two ways to do that today. To be very clear, Xcode 1.5 is on Panther. It's a beta release that we'd love to get your feedback on. Xcode 2.0 is on Tiger. It's a preview, and you can see the number of features that are in each.

The difference being the workspace layouts and the design tools on Tiger are just some of the differences, some of the major differences between those two. But we'd love to get your feedback on both versions, on the different Xcode versions that you guys want to try. is going to be the contact for you guys for other things that you might want to know about Xcode. And we'll bring him back up on stage right now to go through a little bit of a Q&A.

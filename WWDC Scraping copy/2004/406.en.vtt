WEBVTT

00:00:13.220 --> 00:00:17.070
And with that,
I would like to introduce Becky Willrich,

00:00:17.110 --> 00:00:20.520
and she'll talk about modern
networking using CFNetwork.

00:00:25.220 --> 00:00:26.610
Hi, I'm Becky Willrich.

00:00:26.700 --> 00:00:29.340
I'm the technical lead for CFNetwork,
and I'll be talking to you

00:00:29.340 --> 00:00:32.320
about how you can use CFNetwork
in a Mac OS X application.

00:00:34.390 --> 00:00:36.230
What we're going to cover
today is we'll start out with

00:00:36.230 --> 00:00:37.540
an introduction and overview.

00:00:37.540 --> 00:00:39.990
We're going to breeze through that
pretty fast because I figure that's

00:00:39.990 --> 00:00:41.600
review for most everybody at this point.

00:00:41.600 --> 00:00:44.280
We're going to talk about
what's new in Tiger.

00:00:44.280 --> 00:00:47.560
In particular,
we're going to highlight two new classes,

00:00:47.660 --> 00:00:50.640
CFNet Diagnostics and
CFHTTP Authentication.

00:00:50.640 --> 00:00:54.310
Then we're going to look at a couple
common CFNetwork tasks that we know

00:00:54.310 --> 00:00:58.340
from feedback from you as something
you want a little more guidance with.

00:00:58.740 --> 00:01:02.120
We're going to look at how you
manage proxies using CFNetwork

00:01:02.260 --> 00:01:07.140
and how you can use CFNetwork to
perform asynchronous host lookups.

00:01:07.140 --> 00:01:09.570
Finally, at the end,
we're going to wrap up by

00:01:09.570 --> 00:01:13.740
comparing CFNetwork with some of
the other URL loading APIs on the

00:01:13.740 --> 00:01:17.550
system and help you figure out
which one is most appropriate for

00:01:17.630 --> 00:01:21.330
the programming task you have.

00:01:21.730 --> 00:01:25.610
So I'm going to dive straight into
the introduction and overview now.

00:01:25.870 --> 00:01:33.770
What we're going to do is start out
by talking about what is CFNetwork,

00:01:33.770 --> 00:01:39.100
and then we're going to look
and see how CFNetwork fits into

00:01:39.100 --> 00:01:39.100
the Mac OS X stack as a whole.

00:01:39.100 --> 00:01:39.100
And then finally, we're going to look at
the feature set in depth.

00:01:39.780 --> 00:01:42.700
So, CFNetwork is chock full
of networky goodness.

00:01:42.700 --> 00:01:45.840
I have this on high
authority from a coworker.

00:01:45.850 --> 00:01:48.470
What CFNetwork is,
is a framework that provides

00:01:48.470 --> 00:01:51.950
high-level APIs for a number of
different internet protocols,

00:01:52.060 --> 00:01:53.500
and I listed them here.

00:01:53.500 --> 00:01:56.130
Well, what do I mean by high-level?

00:01:56.140 --> 00:01:58.160
I mean higher level than BSD sockets.

00:01:58.160 --> 00:02:03.110
I do not mean high-level like, you know,
just give me the URL and go do

00:02:03.110 --> 00:02:05.610
some magic and give me the data.

00:02:05.620 --> 00:02:10.300
It's not that high-level,
but it is better than sockets.

00:02:10.320 --> 00:02:13.190
It's better than managing select
yourself and parsing yourself.

00:02:14.190 --> 00:02:18.490
We also provide support for advanced
features like proxies and authentication,

00:02:18.580 --> 00:02:21.160
so you don't have to
program those yourself.

00:02:21.190 --> 00:02:24.630
One of our goals is to provide
web compatibility because,

00:02:24.680 --> 00:02:28.090
you know, wonder of wonders,
not every server out there

00:02:28.090 --> 00:02:30.100
is actually HTTP compliant.

00:02:30.100 --> 00:02:34.100
We do our best to provide full
access to those servers anyway.

00:02:35.440 --> 00:02:38.530
And it's worth noting that
the HTTP engine that underlies

00:02:38.670 --> 00:02:40.170
Safari is in fact CFNetwork.

00:02:40.210 --> 00:02:43.420
So every time you download a
URL off the web using Safari,

00:02:43.420 --> 00:02:45.820
you're going through CFNetwork code.

00:02:49.510 --> 00:02:52.780
CFNetwork's APIs are all in the
style of core foundation that

00:02:53.000 --> 00:02:55.000
has two important consequences.

00:02:55.000 --> 00:02:58.060
The first one is that you're
constantly using CF types.

00:02:58.060 --> 00:03:00.240
So you're going through
the whole CF retain,

00:03:00.240 --> 00:03:02.440
CF release, reference counting thing.

00:03:02.440 --> 00:03:06.750
We use a couple types from
core foundation pretty heavily,

00:03:06.750 --> 00:03:09.520
CF read stream and CF write stream.

00:03:09.520 --> 00:03:12.380
We also add new types in CFNetwork.

00:03:12.380 --> 00:03:14.960
Those are all CF types as well.

00:03:14.960 --> 00:03:19.380
I listed three common ones here, CF host,
CF net services, CF html, and CF network.

00:03:19.400 --> 00:03:24.920
All introduced in CFNetwork,
all also CF types.

00:03:24.920 --> 00:03:29.630
The other important consequence
of having an API based on core

00:03:29.630 --> 00:03:35.170
foundation is that we produce all
of our asynchrony using CF run loop.

00:03:35.240 --> 00:03:39.390
So the advantage of that is that
it fits in very easily with your

00:03:39.480 --> 00:03:42.380
application's natural event model.

00:03:42.380 --> 00:03:47.010
Carbon events and NS run loop are
both built on top of CF run loop.

00:03:47.050 --> 00:03:49.380
So CFNetwork fits in very naturally with
your application's natural event model.

00:03:49.400 --> 00:03:52.390
However,
it also means that if you want to

00:03:52.390 --> 00:03:57.350
use CFNetwork to its best effect,
you are going to need to understand

00:03:57.350 --> 00:04:00.400
CF run loop to program it effectively.

00:04:00.400 --> 00:04:02.880
That's not going to be
important for this talk,

00:04:02.920 --> 00:04:05.820
but just to warn you,
when you get into the code itself,

00:04:05.820 --> 00:04:09.390
you're going to want to have a
good understanding of CF run loop.

00:04:11.950 --> 00:04:16.040
So I said before, CFNetwork is not this
convenience API where you hand

00:04:16.040 --> 00:04:19.720
over the URL and you're like,
please just download the data.

00:04:19.760 --> 00:04:22.000
I don't want to know the details.

00:04:22.000 --> 00:04:25.420
There are APIs on the
system that do that for you,

00:04:25.590 --> 00:04:27.560
but CFNetwork is not it.

00:04:27.560 --> 00:04:30.740
Pardon me.

00:04:35.800 --> 00:04:39.830
So for example, we do not automatically
apply any settings for you.

00:04:39.900 --> 00:04:44.630
CFNetwork is intended to be a power
API where you go through and explicitly

00:04:44.660 --> 00:04:49.560
set each bit and flag that you are
interested to customize the process.

00:04:49.560 --> 00:04:53.460
The other part of the goal is
to expose the full power of the

00:04:53.530 --> 00:04:56.000
protocols that it implements.

00:04:56.000 --> 00:04:59.700
So you can very explicitly turn on
and off every individual feature

00:04:59.720 --> 00:05:01.570
of the protocol you're using.

00:05:02.260 --> 00:05:05.100
Now, the upside is that you do
in fact have full control.

00:05:05.100 --> 00:05:08.620
The downside is that you really need
to have some understanding of the

00:05:08.690 --> 00:05:12.520
protocol before you're going to be
able to use CFNetwork to good effect.

00:05:16.270 --> 00:05:19.200
So here's an architecture
diagram of Mac OS X.

00:05:19.200 --> 00:05:22.450
You guys have probably seen
this a few million times by now.

00:05:22.730 --> 00:05:31.350
Darwin, our Unix implementation,
is the Core OS.

00:05:31.350 --> 00:05:31.620
And then we have various layers
of libraries all the way up to

00:05:31.620 --> 00:05:31.620
the applications at the top.

00:05:31.770 --> 00:05:34.890
CFNetwork fits into this
core services layer.

00:05:34.980 --> 00:05:39.140
So that's below the graphics layer
at the point where all of the

00:05:39.140 --> 00:05:43.620
basic services that pretty much
every process on the system uses,

00:05:43.620 --> 00:05:46.030
unless it's a pure Unix process.

00:05:48.360 --> 00:05:51.920
And if you look specifically at
the networking pieces in the stack,

00:05:52.000 --> 00:05:53.350
here's how they line up.

00:05:53.430 --> 00:05:57.120
CFNetwork is what's available
at the core services layer.

00:05:57.120 --> 00:06:02.060
It's built on top of Berkeley SOPCITS,
TCP/IP,

00:06:02.250 --> 00:06:05.980
Rendezvous and DNS implementations,
all available from the

00:06:06.050 --> 00:06:07.790
Core OS Darwin layer.

00:06:07.940 --> 00:06:11.200
Not much going on in the networking
world at the application services layer,

00:06:11.200 --> 00:06:12.300
which isn't surprising.

00:06:12.300 --> 00:06:18.110
That's where the graphics and
user event pieces are added.

00:06:18.240 --> 00:06:21.350
But then above in the
application framework layers,

00:06:21.350 --> 00:06:23.580
NSURL and WebKit become available.

00:06:23.710 --> 00:06:25.920
And then built on top
of all of this stack,

00:06:26.040 --> 00:06:29.110
you'll see all of the major
networking apps on our system,

00:06:29.250 --> 00:06:33.670
like iChat, Sherlock, Safari, Mail,
iTunes.

00:06:36.160 --> 00:06:40.660
So specifically,
what feature set does CFNetwork provide?

00:06:40.800 --> 00:06:43.540
Well, first of all,
it provides an abstraction

00:06:43.620 --> 00:06:45.140
for TCP socket streams.

00:06:45.250 --> 00:06:49.840
We went beyond supporting basic TCP,
though, to add in support for

00:06:49.840 --> 00:06:52.020
TLS and SSL and SOX proxies.

00:06:52.020 --> 00:06:59.450
CFHost gives you access to DNS,
and in particular,

00:06:59.450 --> 00:06:59.450
provides asynchronous host resolution.

00:06:59.820 --> 00:07:04.920
Then we have streams to support
both the HTTP and the FTP protocols.

00:07:05.060 --> 00:07:08.930
CFNet Services is your
API into Rendezvous.

00:07:09.010 --> 00:07:11.110
CFNet Diagnostics is new,
and we'll talk about it

00:07:11.180 --> 00:07:12.480
some more in a little bit.

00:07:12.480 --> 00:07:18.310
And then, of course,
we have integrated proxy

00:07:18.310 --> 00:07:22.610
support at all these layers,
so that if you need to

00:07:22.610 --> 00:07:22.610
apply a proxy setting,
you can do that.

00:07:24.750 --> 00:07:30.710
That's as much of an
overview as I want to give.

00:07:30.710 --> 00:07:30.710
And from here, I'm going to dive into
what's new in Tiger.

00:07:31.870 --> 00:07:34.660
I've already said that
we have two new types,

00:07:34.660 --> 00:07:37.940
CFNet Diagnostics and
CFHTTP authentication.

00:07:37.940 --> 00:07:41.780
We also have some new
CFNet services APIs,

00:07:41.780 --> 00:07:47.940
and we have some new settings on
socket streams specifically to allow

00:07:47.970 --> 00:07:51.700
you to customize SSL and TLS sessions.

00:07:53.210 --> 00:07:55.180
So what is CFNet diagnostics?

00:07:55.180 --> 00:07:57.790
The basic scenario is this.

00:07:58.140 --> 00:08:00.000
You're in the middle of
some networking task,

00:08:00.120 --> 00:08:01.980
and for some reason it's not working.

00:08:01.980 --> 00:08:02.870
You don't know why.

00:08:02.870 --> 00:08:05.900
You just get an error
code back from a download,

00:08:05.900 --> 00:08:08.910
for instance,
or some kind of a POSIX error that

00:08:08.910 --> 00:08:11.690
tells you that the network has gone bad.

00:08:11.720 --> 00:08:15.870
How do you report that back to
the user in some meaningful way,

00:08:15.990 --> 00:08:19.700
and how do you help the user
move along to fix the problem

00:08:19.700 --> 00:08:22.120
so that your program can work?

00:08:24.120 --> 00:08:27.450
CFNet diagnostics provides an
easy interface for you to lead

00:08:27.450 --> 00:08:29.120
the user through these tasks.

00:08:53.060 --> 00:08:56.940
The user just did not enter
the right thing in the network

00:08:56.940 --> 00:08:59.070
system preferences panel.

00:09:00.070 --> 00:09:05.280
CFNet Diagnostics gives you a way
to prompt the user about the problem

00:09:05.280 --> 00:09:10.440
and then move through it and help
the user to correct the problem.

00:09:10.680 --> 00:09:12.670
Looks like this.

00:09:13.590 --> 00:09:17.790
So what would happen is you would
encounter this network failure.

00:09:17.790 --> 00:09:20.930
You'd lead the user to this panel,
essentially.

00:09:21.060 --> 00:09:25.130
And this panel would go through the
five steps you see on the left to

00:09:25.130 --> 00:09:27.780
try and determine what's gone wrong.

00:09:28.070 --> 00:09:31.310
Once it hits a problem
in the network settings,

00:09:31.310 --> 00:09:36.610
it tells the user about it and tells
them what they can do to correct it.

00:09:36.640 --> 00:09:40.050
Once the user's corrected it,
it goes further to tell the user

00:09:40.410 --> 00:09:42.560
that the situation's been corrected.

00:09:45.340 --> 00:09:48.170
So what's the advantage
of CFNet diagnostics?

00:09:48.450 --> 00:09:52.100
Well, the biggest advantage is you
don't have to write the code.

00:09:52.120 --> 00:09:56.980
But the second biggest advantage is it
provides a uniform interface to the user.

00:09:56.980 --> 00:10:00.890
It allows you, the programmer,
to easily query what the

00:10:00.890 --> 00:10:03.460
network connectivity status is.

00:10:03.460 --> 00:10:05.760
Is the network functioning
properly or not?

00:10:05.840 --> 00:10:08.470
And if it's not,
it gives you a localized string

00:10:08.470 --> 00:10:12.680
that you can present directly to the
user to explain what's gone wrong.

00:10:13.760 --> 00:10:15.810
Having done that,
it further leads the user

00:10:15.810 --> 00:10:19.070
to that panel we just saw,
so that the user can then go and try

00:10:19.080 --> 00:10:21.280
and correct the problem themselves.

00:10:23.070 --> 00:10:26.960
There is sample code available
showing how CFNet diagnostics works.

00:10:27.240 --> 00:10:31.840
Unfortunately, due to a mastering error,
it does not appear at this

00:10:31.840 --> 00:10:33.450
path on your Tiger CD.

00:10:33.560 --> 00:10:36.700
However, it is included,
along with every other sample code

00:10:36.700 --> 00:10:40.600
piece that I'm going to talk about,
in the disk image for this session.

00:10:40.600 --> 00:10:48.540
So I encourage you to download
the disk image for the session and

00:10:48.540 --> 00:10:49.110
grab the sample code from there.

00:10:50.840 --> 00:10:53.060
So how's it going to
look in your application?

00:10:53.140 --> 00:10:56.440
It's actually a very simple, minimal API.

00:10:56.480 --> 00:11:03.590
And what I've got here are the
three lines of code that you're

00:11:03.590 --> 00:11:03.590
going to need to add to your program
to integrate CFNet diagnostics.

00:11:05.060 --> 00:11:08.190
You can see at the top what we've done
is we've read bytes from a stream,

00:11:08.200 --> 00:11:10.590
and we got a negative one return,
which tells us that

00:11:10.590 --> 00:11:11.920
an error has occurred.

00:11:11.920 --> 00:11:14.240
So where do we go from there?

00:11:14.240 --> 00:11:15.900
Well, it's pretty straightforward.

00:11:15.900 --> 00:11:18.830
We take the failed read stream,
the read stream that

00:11:18.870 --> 00:11:21.430
we could not read from,
and instantiate a net

00:11:21.430 --> 00:11:23.330
diagnostic object from it.

00:11:24.410 --> 00:11:27.880
Having done that,
we call net diagnostic copy network

00:11:27.880 --> 00:11:32.900
status to retrieve an error string
that we can now display to the user.

00:11:32.900 --> 00:11:35.960
And we're going to display
it in some kind of an alert

00:11:36.010 --> 00:11:39.760
panel that has an OK button to
just dismiss it and continue,

00:11:39.760 --> 00:11:45.070
and a diagnose button to lead the
user to further perform diagnosis.

00:11:45.080 --> 00:11:48.160
If the user clicks the diagnose button,
we're going to call

00:11:48.430 --> 00:11:51.810
this line at the bottom,
diagnose problem interactively.

00:11:51.820 --> 00:11:54.080
That's going to return immediately.

00:11:54.120 --> 00:11:57.580
From your program's point of view,
but from the user's point of view,

00:11:57.580 --> 00:12:02.110
it's going to launch another application
and bring up a panel that will help

00:12:02.230 --> 00:12:04.970
the user start to diagnose the problem.

00:12:09.140 --> 00:12:15.560
So that's Net Diagnostics,
and now I'm going to move on to

00:12:15.560 --> 00:12:15.560
talk some about HTTP authentication.

00:12:20.900 --> 00:12:28.510
We've had authentication support for
HTTP in CFNetwork for a long time now,

00:12:28.510 --> 00:12:28.510
at least a couple, three years.

00:12:28.760 --> 00:12:32.790
However, we've made some substantial
changes in Tiger.

00:12:33.000 --> 00:12:36.470
Historically,
HTTP authentication has supported

00:12:36.470 --> 00:12:38.600
basic and digest schemes.

00:12:38.600 --> 00:12:40.870
Since I last talked
to you here last year,

00:12:40.870 --> 00:12:44.880
we've added support for NTLM and Spanago,
which are a couple schemes that

00:12:44.880 --> 00:12:46.930
are common in the Windows world.

00:12:48.610 --> 00:12:51.590
And the existing old API,
the one that's been available for years,

00:12:51.590 --> 00:12:53.840
was designed for
single-shot transactions.

00:12:53.850 --> 00:12:57.880
You'd issue a request and get
back an authentication challenge.

00:12:57.880 --> 00:13:00.990
Once you get the challenge,
you call the old API,

00:13:00.990 --> 00:13:04.410
it corrects the request,
you issue the request again,

00:13:04.480 --> 00:13:05.740
and away you go.

00:13:06.890 --> 00:13:07.660
And it worked fine.

00:13:07.660 --> 00:13:12.580
The problem was that you don't usually
issue just one request to a server.

00:13:12.580 --> 00:13:14.440
You usually issue 10 or 20.

00:13:14.440 --> 00:13:17.160
And it seems a shame to have
to go through this process

00:13:17.160 --> 00:13:18.800
for each and every request.

00:13:19.810 --> 00:13:23.630
So that's why we added
CFH-GDP authentication in Tiger,

00:13:23.650 --> 00:13:28.090
to allow you to carry state forward
from one request to another,

00:13:28.090 --> 00:13:31.270
going to the same authenticating server.

00:13:33.900 --> 00:13:39.600
So here's the old API,
CFHTTP message ad authentication.

00:13:39.600 --> 00:13:42.940
Every request is processed individually.

00:13:42.960 --> 00:13:47.540
Each time you receive a challenge,
you get the credentials from the user,

00:13:47.540 --> 00:13:50.990
you apply the credentials to the request,
and then you issue the

00:13:50.990 --> 00:13:52.420
entire request again.

00:13:52.420 --> 00:13:58.850
And there was no persistency across
multiple requests to the same servers.

00:13:59.730 --> 00:14:04.630
The new API uses an object,
a CFHTTP authentication object,

00:14:04.630 --> 00:14:08.970
to carry that state across
from request to request.

00:14:09.030 --> 00:14:12.720
And that gives you much
better performance,

00:14:12.720 --> 00:14:19.430
particularly when you're talking to some
host that has one of these very expensive

00:14:19.430 --> 00:14:24.090
authentication schemes that requires,
for instance,

00:14:24.110 --> 00:14:24.110
multiple legs just to compute
keys and negotiate protocols.

00:14:25.190 --> 00:14:26.660
So how's it going to work in code?

00:14:26.660 --> 00:14:28.990
In code,
you're going to maintain a set of

00:14:29.140 --> 00:14:31.240
CFH-TTP authentication objects.

00:14:31.240 --> 00:14:33.740
When you receive an
authentication challenge,

00:14:33.740 --> 00:14:38.000
you're going to look through the set of
objects to try and find one that applies.

00:14:38.000 --> 00:14:39.380
If you find one, great.

00:14:39.380 --> 00:14:41.480
If not, you're going to create one.

00:14:41.480 --> 00:14:45.290
Once you have that object,
you apply it to the request along

00:14:45.310 --> 00:14:50.010
with credentials from the user,
and CFNetwork will use the information

00:14:50.010 --> 00:14:55.020
stored in that object to process the
request as efficiently as possible.

00:14:55.100 --> 00:15:04.040
In the same way,
you can use CFNetwork to create a set

00:15:04.040 --> 00:15:10.810
of CFH-TTP authentication objects.

00:15:10.850 --> 00:15:10.850
When you're done,
you can use CFNetwork to create a set

00:15:10.850 --> 00:15:10.850
of CFH-TTP authentication objects.

00:15:12.340 --> 00:15:19.180
So here are the APIs you're
going to use along the way.

00:15:19.180 --> 00:15:28.810
From the store of authentication objects,
you'll use CFH-GTP authentication

00:15:28.810 --> 00:15:28.810
applies to request to find out
whether the auth object applies to

00:15:28.810 --> 00:15:28.810
the request you're trying to handle.

00:15:29.310 --> 00:15:34.080
If you have to create one from scratch,
you'll use create from response.

00:15:34.220 --> 00:15:36.960
Once you have that auth object,
you need to check to see

00:15:36.960 --> 00:15:38.400
if the object is valid.

00:15:38.610 --> 00:15:44.230
The reason why you need to do
that is because the authentication

00:15:44.230 --> 00:15:44.230
object may go stale over time.

00:15:44.400 --> 00:15:47.310
Assuming it's valid,
you get the credentials from

00:15:47.310 --> 00:15:50.760
the user or from some shared
store that you have in code.

00:15:50.760 --> 00:15:54.960
You can use requires username and
password and requires account domain

00:15:54.960 --> 00:15:59.000
to figure out what information
you need to collect from the user.

00:15:59.000 --> 00:16:02.500
And then finally,
you're going to apply all of the pieces

00:16:02.500 --> 00:16:06.930
to the request to correct the request
and prepare it for an authenticated

00:16:06.930 --> 00:16:09.080
transaction with the server.

00:16:09.080 --> 00:16:13.120
And you're going to do that using
apply credentials dictionary.

00:16:16.320 --> 00:16:19.940
Now, there are a couple tricks that
you have to be aware of when

00:16:19.940 --> 00:16:22.250
you're using HTTP authentication.

00:16:22.250 --> 00:16:25.880
The first one is that some
authentication schemes will only

00:16:25.880 --> 00:16:30.080
work if the subsequent requests go
out over precisely the same socket

00:16:30.080 --> 00:16:32.670
as the initial request went out over.

00:16:32.670 --> 00:16:37.210
So that means you have to turn
on persistent connections.

00:16:37.220 --> 00:16:42.060
So when you're in a situation where
you're trying to handle authentication,

00:16:42.170 --> 00:16:45.650
make sure you have persistent
connections turned on.

00:16:47.450 --> 00:16:51.670
But further than that,
in order for the persistent connections

00:16:51.670 --> 00:16:56.120
to be guaranteed to stay open,
you have to make sure to keep open one

00:16:56.120 --> 00:17:01.610
stream to hold open that socket inside
CFNetwork for the subsequent requests.

00:17:01.670 --> 00:17:05.140
So what I recommend is that as
you're going from request to request,

00:17:05.140 --> 00:17:08.290
don't close the stream for the
old request until you've opened

00:17:08.320 --> 00:17:10.200
the stream for the new request.

00:17:10.200 --> 00:17:14.610
That'll guarantee that the
socket underlying the connection

00:17:14.920 --> 00:17:17.160
will be kept open and reused.

00:17:19.640 --> 00:17:23.740
The other thing to be aware of is that
some of the authentication schemes

00:17:24.160 --> 00:17:28.840
require multiple legs back and forth to
the server just to negotiate hash values,

00:17:28.840 --> 00:17:30.580
protocols, whatever.

00:17:30.580 --> 00:17:34.960
So that means that even though
you have applied authentication

00:17:34.960 --> 00:17:38.660
once to a particular request,
that doesn't mean that it'll

00:17:38.660 --> 00:17:40.540
automatically work from there.

00:17:40.540 --> 00:17:44.460
You may have to keep reapplying it over
and over again until finally the server

00:17:44.460 --> 00:17:48.380
negotiation gets to a point where the
server's ready to return the data.

00:17:50.900 --> 00:17:54.720
The simple rule is just keep
reapplying the authentication object

00:17:54.920 --> 00:17:56.900
until or unless it goes invalid.

00:17:56.900 --> 00:18:00.200
The auth object knows how
many legs are required.

00:18:00.200 --> 00:18:03.800
It knows when the credentials are
simply wrong or when the server has

00:18:03.800 --> 00:18:06.040
decided to shut down the transaction.

00:18:06.040 --> 00:18:09.370
At that point,
you can fall back and figure out

00:18:09.380 --> 00:18:11.690
how to handle a failure case.

00:18:14.540 --> 00:18:18.230
So with that,
I'm going to switch over to the demo.

00:18:18.480 --> 00:18:23.030
What I've got here is a simple
application which downloads URLs.

00:18:23.170 --> 00:18:25.690
So I can type in--

00:18:26.060 --> 00:18:31.750
www.apple.com and click start.

00:18:34.300 --> 00:18:36.000
You can click start.

00:18:36.030 --> 00:18:37.740
There we go.

00:18:37.770 --> 00:18:39.800
Scared me for a moment there.

00:18:40.110 --> 00:18:44.320
You can see that the URL was
downloaded down here.

00:18:44.320 --> 00:18:48.560
Here we're looking at all
the text for www.apple.com.

00:18:48.560 --> 00:18:53.110
At the top, I've just displayed a
summary of the status line.

00:18:53.400 --> 00:18:56.730
Now, there are a couple things that are
not working properly in this demo.

00:18:56.740 --> 00:18:59.500
The first one is that
failures are not handled in a

00:18:59.500 --> 00:19:01.590
particularly interesting way.

00:19:01.610 --> 00:19:08.590
So if I go to www.idontexist.net
and click start,

00:19:11.820 --> 00:19:17.500
Thanks, Keith.

00:19:17.500 --> 00:19:20.870
It should come back with an error code.

00:19:20.910 --> 00:19:24.370
It should come back with a DNS error,
but it's not.

00:19:26.900 --> 00:19:35.530
I should, it depends how quickly
the DNS server responds.

00:19:35.530 --> 00:19:35.530
All right.

00:19:35.530 --> 00:19:35.530
Well, suppose it came back with a
little error string right here.

00:19:37.500 --> 00:19:57.600
[Transcript missing]

00:19:57.940 --> 00:20:01.330
jigsaw.w3.org.

00:20:01.330 --> 00:20:08.390
This is a little site set up
by the W3 Consortium to let

00:20:08.490 --> 00:20:13.000
you test authentication code.

00:20:13.000 --> 00:20:14.980
So we go there.

00:20:17.510 --> 00:20:18.490
There we go.

00:20:18.570 --> 00:20:27.420
And it comes back with a 401
unauthorized because we haven't

00:20:27.420 --> 00:20:29.970
provided username and password.

00:20:29.970 --> 00:20:29.970
Well, even if I provide the correct
username and password,

00:20:29.970 --> 00:20:29.970
it's still going to
come back with this 401.

00:20:32.220 --> 00:20:35.010
So what we're going to do is we're first
going to hook up NetDiagnostics so we

00:20:35.010 --> 00:20:38.710
can give better feedback to the user,
and then we're going to add

00:20:38.710 --> 00:20:41.080
authentication to this application.

00:20:41.260 --> 00:20:45.900
So I'm going to quit this app and
come and look at the code here.

00:20:45.900 --> 00:20:50.010
So this code is also on the disk image.

00:20:50.010 --> 00:20:54.220
It's a very simple Cocoa application.

00:20:54.320 --> 00:20:56.070
It has just one class,
DownloadController,

00:20:56.070 --> 00:20:56.070
which is wired up to the UI.

00:20:57.100 --> 00:21:00.860
And to integrate Net Diagnostics,
what I'm going to do is go

00:21:00.860 --> 00:21:02.850
to the handle error method.

00:21:03.840 --> 00:21:07.650
And here's the simple error
string that you would have seen.

00:21:07.730 --> 00:21:10.440
It does nothing but pull the error
out of the read stream and format

00:21:10.470 --> 00:21:12.060
it and display it in the text view.

00:21:12.060 --> 00:21:14.830
That's not very interesting,
so we're going to get rid of it.

00:21:14.990 --> 00:21:17.560
And we're going to replace
it with net diagnostics code.

00:21:17.560 --> 00:21:34.510
So CFNet diagnostic ref,
let's just do diagnostics,

00:21:34.510 --> 00:21:34.510
get CFNet diagnostics
create with streams.

00:21:34.510 --> 00:21:34.510
Null allocator.

00:21:34.600 --> 00:21:39.640
Stream is the instance variable
that's storing the failed read stream,

00:21:39.680 --> 00:21:43.290
and we don't have a write stream,
so that's there.

00:21:43.290 --> 00:21:46.370
Now we need a string ref for the errors.

00:21:46.930 --> 00:21:48.680
Error string.

00:21:48.680 --> 00:21:51.100
CFNet diagnostics.

00:21:51.100 --> 00:21:54.890
Copy network status passively.

00:21:54.890 --> 00:21:58.060
Diag at error.

00:21:58.060 --> 00:22:02.010
Okay, so what that call is going to do is
it's going to use the diagnostics

00:22:02.010 --> 00:22:05.000
object and ask for an error
string describing the failure.

00:22:05.000 --> 00:22:07.680
That error string is going
to be put into error.

00:22:07.680 --> 00:22:11.010
Now, if you're not a Cocoa programmer,
I'm going to ask you to

00:22:11.010 --> 00:22:12.600
just take my word on this.

00:22:12.600 --> 00:22:14.970
I'm about to add a line that's
going to run an alert panel.

00:22:16.320 --> 00:22:18.400
NS run alert panel.

00:22:18.400 --> 00:22:22.640
First argument is the title.

00:22:22.640 --> 00:22:27.840
Second argument is a printf string
for the contents of the panel.

00:22:27.840 --> 00:22:32.380
Third argument is button, default button.

00:22:32.380 --> 00:22:35.700
Third argument is the alternate button.

00:22:35.700 --> 00:22:38.990
So we're going to have an
alternate button of diagnose,

00:22:39.330 --> 00:22:42.000
which if the user clicks,
we're going to use to head

00:22:42.000 --> 00:22:45.860
off into CFNet diagnostics to
bring up that diagnostic panel.

00:22:47.750 --> 00:22:54.830
Don't have a third button,
and finally the argument for the printf.

00:22:54.830 --> 00:22:54.830
Okay.

00:22:55.670 --> 00:22:57.270
So that's going to run an alert panel.

00:22:57.310 --> 00:23:05.900
And what we're going to do
is if the result from that

00:23:05.900 --> 00:23:05.900
is NSAlertAlternateReturn,

00:23:07.700 --> 00:23:15.600
[Transcript missing]

00:23:16.670 --> 00:23:22.650
And we're just going to call
CFNet diagnostic diagnose

00:23:22.650 --> 00:23:25.020
problem interactively.

00:23:25.070 --> 00:23:28.490
I'm really a much better
typist when I'm not on stage.

00:23:30.260 --> 00:23:30.620
And that's it.

00:23:30.750 --> 00:23:31.200
We're done.

00:23:31.200 --> 00:23:33.100
Oh, except for a little cleanup.

00:23:33.100 --> 00:23:37.120
We should release the
objects we've created.

00:23:47.850 --> 00:23:48.700
There we go.

00:23:48.700 --> 00:23:48.760
Oh, good.

00:23:48.790 --> 00:23:50.410
All right.

00:23:50.410 --> 00:23:55.830
So now let's just see what happens.

00:24:03.200 --> 00:24:04.200
Oh yes, thank you.

00:24:04.200 --> 00:24:10.700
And is it CF?

00:24:10.700 --> 00:24:14.480
Ah yes, and there is no S here either.

00:24:14.510 --> 00:24:18.810
Let's try this again.

00:24:22.870 --> 00:24:25.040
That does not look good.

00:24:25.040 --> 00:24:26.480
There we go.

00:24:26.500 --> 00:24:27.820
All right.

00:24:27.820 --> 00:24:31.250
It's just taking a little time.

00:24:31.330 --> 00:24:33.180
All right.

00:24:33.240 --> 00:24:40.200
So given that the DNS server doesn't
seem to be too happy with us right now,

00:24:40.200 --> 00:24:40.200
I'm going to create a much
simpler networking failure.

00:24:41.900 --> 00:24:44.600
That's a very simple networking failure.

00:24:44.600 --> 00:24:51.690
Now let's see if we can
go to www.apple.com.

00:24:53.600 --> 00:24:54.200
No, we can't.

00:24:54.200 --> 00:24:55.600
And here's that alert panel.

00:24:55.600 --> 00:25:00.000
It comes up and it shows us a
string chosen by CFNet Diagnostics.

00:25:00.000 --> 00:25:03.800
The system's internet
connection appears to be down.

00:25:03.960 --> 00:25:08.610
All right,
let's see what CFNet Diagnostics

00:25:08.610 --> 00:25:11.210
can tell us about that.

00:25:11.290 --> 00:25:19.160
So here's the diagnostics panel,
and it was going to go through these five

00:25:19.160 --> 00:25:19.600
different types of networking errors,
but in fact it failed

00:25:19.600 --> 00:25:19.600
immediately at the first one.

00:25:19.600 --> 00:25:19.600
The built-in Ethernet is not working.

00:25:20.060 --> 00:25:22.810
So are we trying to connect to
the internet for the first time?

00:25:22.840 --> 00:25:24.560
No, we're not.

00:25:25.040 --> 00:25:28.440
We're trying to configure the ethernet.

00:25:29.490 --> 00:25:31.860
And now it says, well,
the Ethernet port's not active.

00:25:31.860 --> 00:25:33.530
Let's check the following things.

00:25:33.540 --> 00:25:35.950
And you'll notice in this list,
one of them is,

00:25:35.950 --> 00:25:37.870
is the Ethernet cable plugged in?

00:25:37.880 --> 00:25:38.930
Well, look at that.

00:25:38.930 --> 00:25:39.730
No, it's not.

00:25:39.760 --> 00:25:44.430
So let's just plug it back in.

00:25:45.300 --> 00:25:46.680
Let's just plug it back in.

00:25:46.800 --> 00:25:48.560
There we go.

00:25:48.810 --> 00:25:51.950
And now you can see NetDiagnostics
discovered that we've corrected the

00:25:52.050 --> 00:25:55.860
problem and is going through and checking
the remainder of our configuration.

00:26:05.730 --> 00:26:09.400
If I go back here,
I can download Apple.com.

00:26:09.520 --> 00:26:13.610
Now,
I have to make a little confession here.

00:26:13.660 --> 00:26:17.860
What you're looking at up
here is pure demo ware.

00:26:17.960 --> 00:26:22.590
If you were to build this program
on the WWDC seed that you received,

00:26:22.590 --> 00:26:25.060
you would not see that series of panels.

00:26:25.060 --> 00:26:29.130
Instead, you'd see a placeholder panel,
which would tell you that yes,

00:26:29.130 --> 00:26:31.550
net diagnostics fired correctly.

00:26:31.560 --> 00:26:34.180
It would tell you what application
had brought it up and what

00:26:34.280 --> 00:26:35.530
the code entry point was.

00:26:35.540 --> 00:26:39.500
But it wouldn't actually lead you
through that series of panels.

00:26:39.500 --> 00:26:43.200
The series of panels will, of course,
be there for the final Tiger release.

00:26:43.200 --> 00:26:45.840
We didn't have them quite
ready to where we were willing

00:26:45.840 --> 00:26:47.380
to include them in the seed.

00:26:47.380 --> 00:26:49.330
So for the seed,
you'll just see the placeholder panel,

00:26:49.330 --> 00:26:53.950
which is hopefully enough to
allow you to develop your code.

00:26:55.130 --> 00:27:00.340
So having done that,
now let's add authentication.

00:27:00.400 --> 00:27:04.880
Authentication is a little more complex
than just using CFNet diagnostics.

00:27:04.930 --> 00:27:09.270
To do that, I'm going to need to add
two new instance variables.

00:27:11.700 --> 00:27:19.370
So this is the auth object that
I'm going to use to store the

00:27:19.370 --> 00:27:19.370
current authentication state.

00:27:19.780 --> 00:27:23.960
And I'm going to add a CF mutable
array to store the set of all

00:27:23.960 --> 00:27:27.410
authentication pieces that I've received.

00:27:27.410 --> 00:27:30.700
So that's the change to the header file.

00:27:30.990 --> 00:27:36.480
Now over here in the source file,
we need a couple bookkeeping things.

00:27:36.480 --> 00:27:40.400
First of all,
we'd better release the objects when

00:27:40.400 --> 00:27:43.500
we're deallocated so we don't leak.

00:27:50.240 --> 00:27:54.280
Secondly, in the stop download method,
this is what happens when the user

00:27:54.400 --> 00:27:57.750
clicks stop or when the stream
is finally exhausted and the data

00:27:57.750 --> 00:27:59.760
has been successfully loaded.

00:27:59.760 --> 00:28:05.250
We need to throw out the auth
object if one exists so it's not

00:28:05.290 --> 00:28:09.140
carried forward to future requests.

00:28:12.900 --> 00:28:15.140
Okay, so that's the bookkeeping.

00:28:15.140 --> 00:28:16.410
Now to actually do the work.

00:28:16.410 --> 00:28:21.660
We have a method here, evaluate headers.

00:28:21.660 --> 00:28:24.760
This is going to fire the
first time we get a look at the

00:28:24.760 --> 00:28:26.780
headers back from the server.

00:28:26.780 --> 00:28:29.750
So what we want to do is look
for an authentication failure,

00:28:29.930 --> 00:28:32.650
which would be a status
code of 401 or 407.

00:28:32.650 --> 00:28:37.400
And if we have such a response,
we want to attempt authentication.

00:28:38.740 --> 00:28:41.850
So here if we got a response if

00:28:44.200 --> 00:28:52.900
CFH-TTP message,
get response status code, response.

00:28:52.900 --> 00:28:59.690
We're just going to deal
with 401s for the demo.

00:28:59.690 --> 00:29:01.280
407s would be a proxy
authentication failure.

00:29:01.280 --> 00:29:01.280
It's pretty much straightforward
in the same code for that.

00:29:02.500 --> 00:29:06.950
So if we got a 401,
we're going to attempt authentication

00:29:07.300 --> 00:29:10.280
and we'll pass the response we received.

00:29:10.320 --> 00:29:13.360
And if that succeeds,
so if this method returns true,

00:29:13.400 --> 00:29:16.940
then we're going to return no,
telling the surrounding code,

00:29:16.940 --> 00:29:21.310
ignore the stream you've been looking at,
there's a new stream coming.

00:29:25.320 --> 00:29:26.730
Okay, and that's it for that code.

00:29:26.840 --> 00:29:29.680
Now all we need to do is write
this attempt authentication method.

00:29:29.680 --> 00:29:32.270
Well,
I'm not going to force you to sit here

00:29:32.330 --> 00:29:34.940
and watch me introduce a million typos.

00:29:34.940 --> 00:29:43.790
I actually have that method
already written up here,

00:29:43.790 --> 00:29:43.920
and what I'm going to do is just
uncomment it and walk you through it.

00:29:44.800 --> 00:29:48.740
The first thing we do is look and see if
we already have an authentication object.

00:29:48.750 --> 00:29:50.590
If not, we're going to try and find one.

00:29:50.680 --> 00:29:53.780
And we'll do that by
walking through AuthArray.

00:29:54.010 --> 00:29:59.580
For each item in AuthArray, we ask it,
does it apply to our request?

00:29:59.660 --> 00:30:01.200
If so, that's still not good enough.

00:30:01.200 --> 00:30:02.780
We want to know if it's still valid.

00:30:02.780 --> 00:30:04.870
If it is valid, all right, great.

00:30:04.870 --> 00:30:08.720
Then we store it in our instance
variable and break out of the loop.

00:30:09.440 --> 00:30:13.760
Otherwise, there's no need to hold on to
invalid authentication items,

00:30:13.760 --> 00:30:17.130
so we dispose it and do
some updating for the loop.

00:30:19.110 --> 00:30:21.050
Once we reach,
once we're outside of that loop,

00:30:21.050 --> 00:30:23.160
if we still don't have
an authentication object,

00:30:23.160 --> 00:30:24.760
that means we couldn't find one.

00:30:24.760 --> 00:30:26.520
So now we're going to create one.

00:30:26.520 --> 00:30:31.140
So we call CFHTTP authentication
create from response.

00:30:34.690 --> 00:30:37.910
Now, it is actually possible for a
newly created authentication

00:30:37.910 --> 00:30:39.620
item to be invalid off the bat.

00:30:39.620 --> 00:30:43.640
What that usually means is that the
server has chosen to send an unauthorized

00:30:43.640 --> 00:30:47.700
response without any information
about how you can correct the error.

00:30:47.700 --> 00:30:49.680
The server is not going
to let you authenticate,

00:30:49.740 --> 00:30:50.200
period.

00:30:50.200 --> 00:30:51.920
There are some other possibilities.

00:30:52.000 --> 00:30:54.390
There could be some missing
headers in the response,

00:30:54.430 --> 00:30:57.630
but the main one is that the server
is simply not going to let you in.

00:30:57.640 --> 00:31:01.500
So you do have to check to make
sure that the authentication object

00:31:01.600 --> 00:31:03.810
you just created is in fact valid.

00:31:04.700 --> 00:31:07.060
If it is terrific,
we'll add it to the shared store.

00:31:07.060 --> 00:31:09.210
If not, then we give up.

00:31:13.340 --> 00:31:15.750
So now coming down here, at this point,
if we don't have an

00:31:15.750 --> 00:31:18.360
authentication object,
we're simply not going to get one.

00:31:18.360 --> 00:31:21.160
And we'll see at the end here
that we simply punt in that case.

00:31:21.160 --> 00:31:24.440
However, assuming we did get an
authentication object,

00:31:24.440 --> 00:31:27.290
we look to see if it
requires an account domain.

00:31:27.290 --> 00:31:30.720
And if it does, again,
we're going to punt because my UI wasn't

00:31:30.720 --> 00:31:32.910
clever enough to prompt for a domain.

00:31:32.910 --> 00:31:35.760
That mostly means we're
giving up on NTLM.

00:31:35.760 --> 00:31:39.730
That's the one authentication
scheme that requires a domain

00:31:39.730 --> 00:31:41.680
in addition to username.

00:31:43.400 --> 00:31:47.150
So in that case,
we release auth and just return no.

00:31:47.850 --> 00:31:51.840
Otherwise, we come down into this code.

00:31:51.870 --> 00:31:57.780
If the authentication requires
a username and password,

00:31:57.780 --> 00:31:57.780
we go and haul it out of the UI.

00:31:57.880 --> 00:32:01.530
And then we call HTTP message
apply credentials to apply the

00:32:01.670 --> 00:32:05.470
authentication we've got to the request.

00:32:05.910 --> 00:32:09.520
Assuming if that fails,
return no and bail.

00:32:09.540 --> 00:32:15.880
Otherwise, we're going to ultimately
return yes to say that the

00:32:15.880 --> 00:32:15.880
authentication has succeeded.

00:32:17.160 --> 00:32:22.760
Now comes the part where we have to
deal with the problem of persistency.

00:32:22.760 --> 00:32:27.190
We cannot dispose of the old stream
until the new stream is well established.

00:32:27.350 --> 00:32:30.300
So right here, we do all the work of
setting up the new stream.

00:32:30.300 --> 00:32:32.410
This is all standard CFNetwork code.

00:32:32.410 --> 00:32:36.700
Create the new stream, set the client,
schedule it with the run loop,

00:32:36.800 --> 00:32:40.800
set whatever properties you need,
and then open the stream.

00:32:42.280 --> 00:32:45.630
Once we've got that stream set up,
we can now go and dispose

00:32:45.630 --> 00:32:48.670
of the old stream,
close it, set the client to null,

00:32:48.670 --> 00:32:51.990
unschedule and release,
and ultimately set our instance

00:32:51.990 --> 00:32:54.020
variable to point to the new stream.

00:32:54.020 --> 00:32:56.720
At this point, we're done,
and we can return, yes,

00:32:56.720 --> 00:32:58.580
authentication has succeeded.

00:32:58.580 --> 00:33:02.100
So let's see if it actually works.

00:33:07.600 --> 00:33:17.490
Okay, so let's go to jigsaw.dub3.org,
that same test site.

00:33:17.500 --> 00:33:20.390
So without a username and password,

00:33:23.000 --> 00:33:31.120
Now,
it comes back with a 401 unauthorized.

00:33:31.120 --> 00:33:31.120
But this time, when we provide the
username and password,

00:33:31.120 --> 00:33:31.120
click Start,

00:33:31.160 --> 00:33:32.700
We come back with a 200 OK.

00:33:32.700 --> 00:33:35.950
And if we were to look
at the data we received,

00:33:35.990 --> 00:33:38.180
yay, your browser made it.

00:33:40.620 --> 00:33:47.310
Okay, but if I give the wrong
username and password,

00:33:47.490 --> 00:33:53.110
again, we get the 401 unauthorized.

00:33:53.110 --> 00:33:55.630
So there, in about 10 minutes,
we've added net diagnostic

00:33:55.630 --> 00:33:55.630
capability and HTTP authentication
to a simple download application.

00:34:00.700 --> 00:34:03.040
So if I could get back to the slides.

00:34:03.040 --> 00:34:05.170
If I could have the slides back.

00:34:10.210 --> 00:34:14.370
Okay, so there are a couple other
new APIs I want to mention.

00:34:14.530 --> 00:34:16.780
We redid the CFNet services APIs.

00:34:16.780 --> 00:34:21.550
That's the APIs that give you access
to Rendezvous via the run loop.

00:34:21.630 --> 00:34:24.430
We redid it in Tiger,
not just because we love

00:34:24.430 --> 00:34:26.320
making you change your code.

00:34:26.380 --> 00:34:29.720
We did it because we needed
to fix a few problems that we

00:34:29.720 --> 00:34:31.950
uncovered with the earlier APIs.

00:34:31.950 --> 00:34:35.370
And at the same time,
we found that the earlier APIs were

00:34:35.470 --> 00:34:40.150
insufficient to pick up some new
features being exposed by CFNetwork.

00:34:40.220 --> 00:34:42.000
CoreOS.

00:34:42.900 --> 00:34:44.260
We are deprecating the old API.

00:34:44.360 --> 00:34:46.830
That doesn't mean that it
will suddenly stop working.

00:34:46.950 --> 00:34:48.700
It'll still work as it always did.

00:34:48.700 --> 00:34:53.300
But one of the big things that you'll
pick up by going to the new APIs is

00:34:53.300 --> 00:34:55.640
better network IO performance.

00:34:55.640 --> 00:34:58.660
So we encourage you to
transition when you're ready to.

00:35:01.950 --> 00:35:03.920
The transition is as
simple as we could make it.

00:35:04.050 --> 00:35:06.800
It's very nearly search and replace.

00:35:06.800 --> 00:35:10.990
And what I've done is I've listed
here what the old calls were

00:35:11.080 --> 00:35:13.540
and what the new calls would be.

00:35:18.750 --> 00:35:21.870
To help you with the transition,
the release notes,

00:35:21.870 --> 00:35:25.870
which are on the Tiger CD and also
in the disk image for this session,

00:35:26.080 --> 00:35:29.720
give full instructions for how
to transition to the new API.

00:35:29.720 --> 00:35:35.180
We also updated the Echo and
Echo Client examples,

00:35:35.180 --> 00:35:41.900
which use CFNet services to
discover the client in the server,

00:35:41.900 --> 00:35:44.040
to use the new API.

00:35:44.060 --> 00:35:44.680
So you can look there for more examples.

00:35:46.570 --> 00:35:48.800
There is one important difference
that I want to mention.

00:35:48.800 --> 00:35:54.890
CFNet Service Resolve has been replaced
with CFNet Service Resolve with Timeout.

00:35:54.940 --> 00:36:00.530
One of the reasons why is that
CFNet Service Resolve would

00:36:00.680 --> 00:36:05.520
leave open the resolution until
it was explicitly canceled.

00:36:05.520 --> 00:36:09.580
What we found out is that this was
completely unexpected by most people.

00:36:10.200 --> 00:36:14.160
So, they would call Net Service Resolve,
they would get back the resolution,

00:36:14.160 --> 00:36:16.720
so they would get back the
information they were looking for,

00:36:16.800 --> 00:36:20.510
and then they would assume
that the Net Service was done.

00:36:20.520 --> 00:36:21.910
Well, it wasn't.

00:36:21.960 --> 00:36:23.200
It's still consuming bandwidth.

00:36:23.200 --> 00:36:26.420
It's still consuming network time
until it's explicitly canceled.

00:36:28.540 --> 00:36:33.040
So CFNet service resolve with timeout
has slightly different behavior.

00:36:33.070 --> 00:36:37.830
It now will exit when either a
suitable address has been found

00:36:37.880 --> 00:36:40.660
or the timeout has been reached.

00:36:40.680 --> 00:36:45.580
And as a result, it consumes considerably
less network bandwidth.

00:36:47.910 --> 00:36:57.410
Now, there was one legitimate time
when you would want to leave a net

00:36:57.670 --> 00:37:00.590
service open and running forever.

00:37:00.590 --> 00:37:00.590
You would want to do that if you
were monitoring a single net service

00:37:00.590 --> 00:37:00.590
and waiting for changes to occur.

00:37:01.950 --> 00:37:05.490
To address that problem,
we've added a new type,

00:37:05.530 --> 00:37:07.500
CFNet Service Monitor.

00:37:07.500 --> 00:37:10.500
New in Tiger,
and where you used to use a long-running

00:37:10.510 --> 00:37:14.930
CFNet Service Resolve call together
with GET protocol-specific information

00:37:14.940 --> 00:37:18.370
so you could find out what had
changed about that net service,

00:37:18.490 --> 00:37:20.980
instead just use Net Service Monitor.

00:37:21.030 --> 00:37:27.490
It has a much more efficient,
smaller network footprint

00:37:27.490 --> 00:37:27.490
in terms of the traffic.

00:37:30.400 --> 00:38:15.300
[Transcript missing]

00:38:16.840 --> 00:38:22.340
The other property is
KCF Stream property SSL settings.

00:38:22.380 --> 00:38:23.880
This is a settable property.

00:38:23.940 --> 00:38:25.320
Its value is a dictionary.

00:38:25.320 --> 00:38:29.340
The keys of the dictionaries are a number
of different configuration options,

00:38:29.340 --> 00:38:31.680
which you can find in cfsocketstream.h.

00:38:31.680 --> 00:38:36.340
And it allows you to
control how CFNetwork will

00:38:36.390 --> 00:38:40.800
judge the peer certificate,
by and large,

00:38:40.830 --> 00:38:45.910
and how CFNetwork will handle
the TLS or SSL handshake.

00:38:47.360 --> 00:38:50.430
I'm not going to go through
these in huge detail.

00:38:50.430 --> 00:38:53.770
These are all the different
properties you can set.

00:38:53.770 --> 00:38:58.980
SSL level lets you choose TLS v1 or
SSL v3 or what kind of fallback you want.

00:38:58.980 --> 00:39:02.410
Allows expired certificates
and allows expired routes,

00:39:02.410 --> 00:39:05.580
allows any route,
pretty much self-explanatory.

00:39:07.900 --> 00:39:11.570
Validates the certificate chain,
whether you want CFNetwork to even

00:39:11.570 --> 00:39:14.730
look at the certificate chain or
whether you want to do that yourself

00:39:14.840 --> 00:39:18.650
or you want to leave yourself wide
open to whatever the server gives you.

00:39:19.190 --> 00:39:22.010
SSL Peer Name allows you to
set the expected name that

00:39:22.290 --> 00:39:26.240
you're expecting to see on the
certificate from the remote side,

00:39:26.240 --> 00:39:30.510
because you might connect by IP address,
but the certificate is going

00:39:30.510 --> 00:39:34.780
to display a host name,
and so you'd need to set that separately.

00:39:34.780 --> 00:39:38.490
SSL Certificates allows you to
set the certificates for your

00:39:38.860 --> 00:39:40.850
side of the SSL transaction.

00:39:40.860 --> 00:39:43.380
So that's what you would
use if you wanted to do

00:39:43.380 --> 00:39:46.790
client-side certificate checking,
or if you wanted to

00:39:46.870 --> 00:39:48.630
write a server yourself.

00:39:49.200 --> 00:39:52.530
Speaking of servers,
you'd set SSL is server if

00:39:52.530 --> 00:39:55.660
you were performing the server
side of the transaction,

00:39:55.660 --> 00:39:57.200
as opposed to the client side.

00:39:59.040 --> 00:40:02.840
Default values are all
documented in cfsocketstream.h.

00:40:02.850 --> 00:40:10.470
In general, the defaults are for the
strongest security possible and

00:40:10.510 --> 00:40:14.350
the maximum amount of checking.

00:40:14.350 --> 00:40:14.350
So you would need to set these to
make the requirements more lax.

00:40:18.940 --> 00:40:22.160
That's the new APIs that
we have available in Tiger.

00:40:22.160 --> 00:40:27.160
Now I'm going to take a moment to talk
about a couple different CFNetwork tasks.

00:40:27.280 --> 00:40:35.690
In particular,
we're going to talk about how you use

00:40:35.690 --> 00:40:35.850
proxies using CFNetwork and how you
would perform an asynchronous DNS lookup.

00:40:38.840 --> 00:40:43.160
So one of CFNetwork's strengths over
working with other networking stacks or

00:40:43.240 --> 00:40:48.090
writing your own is that it's prepared to
handle complex combinations of proxies.

00:40:48.100 --> 00:40:52.030
So if you look at the system settings,
the user's turned on a SOX proxy and

00:40:52.030 --> 00:40:55.090
an HTTP proxy and an HTTPS proxy,
and you don't know which

00:40:55.170 --> 00:40:57.850
one you're going to use,
and you're not sure how the

00:40:57.850 --> 00:41:00.360
different communications are handled.

00:41:00.360 --> 00:41:01.500
Well, CFNetwork does.

00:41:01.500 --> 00:41:05.670
CFNetwork can figure out which proxy
should be applied and then do the correct

00:41:05.670 --> 00:41:07.980
communication for that type of proxy.

00:41:09.190 --> 00:41:12.440
However, CFNetwork's not intended
as a convenience API,

00:41:12.440 --> 00:41:18.650
so you have to explicitly turn proxies
on to get proxy support from CFNetwork.

00:41:19.480 --> 00:41:22.700
You're always going to do that by
calling CFReadStreamSetProperty.

00:41:22.800 --> 00:41:25.190
And the key,
or the property you're going to set is

00:41:25.190 --> 00:41:29.180
whatever proxy setting is appropriate
for the kind of stream you're using.

00:41:29.180 --> 00:41:33.250
Well, so one of the questions we get is,
well, there's an HTTP proxy

00:41:33.250 --> 00:41:37.120
and there's a SOX proxy,
but I'm working with an HTTP stream.

00:41:37.120 --> 00:41:40.130
Do I set the SOX property,
a proxy property,

00:41:40.230 --> 00:41:42.360
or the HTTP proxy property?

00:41:43.400 --> 00:41:44.300
Always set the highest level.

00:41:44.300 --> 00:41:47.460
So in that case,
you would be setting the HTTP proxy.

00:41:47.480 --> 00:41:51.440
If you were working with an FTP stream,
you would set the FTP proxy property,

00:41:51.440 --> 00:41:54.600
even if the proxy you're applying is SOX,
for instance.

00:41:54.600 --> 00:41:58.850
You should also always apply the proxy
settings before opening the stream,

00:41:58.850 --> 00:42:03.220
because we need that information
before we establish the correct socket.

00:42:05.660 --> 00:42:08.710
And what we found is that
our developers use proxies

00:42:08.710 --> 00:42:10.960
basically in two different ways.

00:42:10.980 --> 00:42:14.920
Either they simply want to apply the
default system proxy configuration,

00:42:14.920 --> 00:42:21.460
or they know that their
case is special in some way,

00:42:21.460 --> 00:42:25.820
and they have a custom proxy server
that they wish to apply regardless of

00:42:25.820 --> 00:42:25.820
what other settings may be present.

00:42:28.150 --> 00:42:29.720
So here's probably the more common one.

00:42:29.720 --> 00:42:32.740
You just want to use whatever the
current system proxy settings are.

00:42:32.740 --> 00:42:35.480
Well, the good news is that while you
have to be explicit about this,

00:42:35.480 --> 00:42:37.260
it's really fairly straightforward.

00:42:37.560 --> 00:42:40.170
Just call scdynamic store copy proxies.

00:42:40.170 --> 00:42:44.210
That will get you the default proxy
dictionary or the system proxy

00:42:44.210 --> 00:42:48.700
dictionary out of system config
and apply it blindly to the stream.

00:42:48.700 --> 00:42:49.500
Don't look at it.

00:42:49.500 --> 00:42:50.460
Don't tear it apart.

00:42:50.460 --> 00:42:52.240
Just pass the whole schmear through.

00:42:52.240 --> 00:42:56.190
CF read stream set property, stream,
property HTTP proxy,

00:42:56.390 --> 00:42:59.610
and the dictionary you got
back from system config.

00:42:59.610 --> 00:43:00.450
That's it.

00:43:00.450 --> 00:43:05.990
CFNetwork will pull the dictionary apart,
figure out what the correct settings are,

00:43:05.990 --> 00:43:07.170
and use them.

00:43:10.800 --> 00:43:13.140
If, on the other hand,
you need to use a custom

00:43:13.140 --> 00:43:16.030
proxy configuration,
you're going to need to create the

00:43:16.030 --> 00:43:18.040
custom proxy dictionary yourself.

00:43:18.120 --> 00:43:24.980
Look in the correct stream header
file to find out what the keys are.

00:43:24.980 --> 00:43:28.430
You're going to need a key for
the host and a key for the port,

00:43:28.460 --> 00:43:32.580
and those are the only two keys that
you need present in your dictionary.

00:43:32.580 --> 00:43:36.980
Some proxies, most notably SOCKS,
have some additional keys you

00:43:36.980 --> 00:43:38.970
could set if you would like.

00:43:40.380 --> 00:43:41.670
You can take a look at those.

00:43:41.700 --> 00:43:43.020
Those aren't actually required.

00:43:43.020 --> 00:43:45.040
Once you have constructed
that dictionary,

00:43:45.040 --> 00:43:48.720
you apply it exactly the same
way by calling set property

00:43:49.230 --> 00:43:51.320
stream HTTP proxy dictionary.

00:43:51.320 --> 00:43:54.160
So here's what it looks like in code.

00:43:56.280 --> 00:43:58.900
Create a mutable CFDictionary.

00:43:58.910 --> 00:44:02.400
Set value proxy host,
whatever the host is.

00:44:02.430 --> 00:44:06.440
Set value proxy port,
whatever the port is.

00:44:06.440 --> 00:44:10.020
Then call CFReadStream set
property exactly as you did before.

00:44:15.400 --> 00:44:19.840
So another task that's pretty common
that we hear about is the need to

00:44:19.920 --> 00:44:21.880
perform an asynchronous host lookup.

00:44:21.980 --> 00:44:23.160
What do I mean by that?

00:44:23.200 --> 00:44:25.510
Well, you have a host name,
you want the IP address.

00:44:25.560 --> 00:44:27.040
It's that straightforward.

00:44:27.090 --> 00:44:29.890
And the traditional Unix calls
for this are get host by name or

00:44:29.890 --> 00:44:31.700
the slightly newer get adder info.

00:44:31.700 --> 00:44:37.020
But the problem with those
calls is that they're blocking.

00:44:37.020 --> 00:44:40.990
They're going to tie up a thread,
and they're not going to return

00:44:40.990 --> 00:44:40.990
until they have the answer.

00:44:41.220 --> 00:44:45.350
That makes it very difficult to
process multiple host names at once.

00:44:45.420 --> 00:44:50.690
So the solution to that
is to use CFHost instead.

00:44:51.900 --> 00:45:01.780
CFHost is going to report
its results back to you

00:45:01.780 --> 00:45:01.780
asynchronously via the CF run loop.

00:45:01.780 --> 00:45:01.780
Excuse me.

00:45:02.750 --> 00:45:05.320
That way you can have as many
open queries as you'd like.

00:45:05.320 --> 00:45:07.510
They're all going to
happen on the same thread,

00:45:07.510 --> 00:45:10.860
and they're all going to report
the results back asynchronously.

00:45:10.860 --> 00:45:18.630
And incidentally,
CFHost will perform both IPv4

00:45:18.630 --> 00:45:18.630
and IPv6 lookups for you.

00:45:20.600 --> 00:45:22.810
Incidentally,
CFHost supports a number of other things,

00:45:22.860 --> 00:45:23.140
too.

00:45:23.140 --> 00:45:27.330
You can do reverse DNS lookups,
so you have the address,

00:45:27.330 --> 00:45:29.080
you want to know the common host names.

00:45:29.080 --> 00:45:33.140
You can use it to determine whether
a given host is reachable just now.

00:45:33.140 --> 00:45:35.870
If for some reason you
want to use a blocking API,

00:45:35.870 --> 00:45:39.540
you can use CFHost in that fashion,
although we always recommend

00:45:39.540 --> 00:45:42.880
that you use the asynchronous
non-blocking API instead.

00:45:42.880 --> 00:45:44.860
That's the power of the object.

00:45:44.960 --> 00:45:48.660
And for our purposes here today,
we're going to focus on

00:45:48.680 --> 00:45:50.590
just basic host lookups.

00:45:53.510 --> 00:45:59.340
So using CFHost is pretty much the same
as using every other CFNetwork object.

00:45:59.360 --> 00:46:01.100
You start by setting it up.

00:46:01.140 --> 00:46:05.260
You create it, set your callback,
all of that good stuff.

00:46:05.260 --> 00:46:07.840
Then you wait for the
callback to come in.

00:46:07.860 --> 00:46:10.660
When the callback comes in, you field it.

00:46:10.690 --> 00:46:12.980
And then finally, you clean up.

00:46:12.980 --> 00:46:16.660
Every CFNetwork object
follows this basic pattern.

00:46:16.660 --> 00:46:21.120
Set it up, wait for the events,
wait for the callbacks to come in,

00:46:21.130 --> 00:46:21.910
and then dispose of the object.

00:46:22.640 --> 00:46:24.280
So here's the setup.

00:46:24.690 --> 00:46:29.680
Here we're doing a
DNS lookup of www.apple.com.

00:46:29.800 --> 00:46:33.860
CFHost create with name, www.apple.com.

00:46:34.060 --> 00:46:36.440
Then we need to set up
the client callback.

00:46:36.440 --> 00:46:37.970
We use CFHost set client.

00:46:38.070 --> 00:46:43.960
That's just how you specify what function
CFHost should call when it receives the

00:46:43.960 --> 00:46:47.000
information that you're looking for.

00:46:47.010 --> 00:46:48.250
Schedule it with a run loop.

00:46:48.430 --> 00:46:52.120
Here we're scheduling it with the
current run loop in the default mode.

00:46:52.320 --> 00:46:56.260
That tells CFHost where you
want to receive that callback.

00:46:56.410 --> 00:46:59.660
You can schedule it on
another thread if you want.

00:46:59.890 --> 00:47:04.240
And then having done all that setup,
you start CFHost at its work by

00:47:04.760 --> 00:47:07.220
calling CFHost start info resolution.

00:47:07.220 --> 00:47:10.160
And here you pass the host
object and then the type of

00:47:10.270 --> 00:47:12.360
information you're looking for.

00:47:12.360 --> 00:47:15.380
We're looking for the addresses,
so that's kcfhost addresses.

00:47:18.080 --> 00:47:19.070
And you're done.

00:47:19.070 --> 00:47:21.790
Then the run loop runs,
and at some point later,

00:47:21.880 --> 00:47:23.230
CFHost has its answer.

00:47:23.230 --> 00:47:26.120
Once that happens,
it's going to call your callback

00:47:26.320 --> 00:47:28.000
on the run loop you specified.

00:47:28.000 --> 00:47:30.170
So here we're fielding the callback.

00:47:30.220 --> 00:47:34.730
First argument is going to be the host
object whose resolution has completed.

00:47:34.730 --> 00:47:38.180
Second argument tells you
what resolution has completed.

00:47:38.180 --> 00:47:42.150
We only signed up for one,
so we know what that's going to be.

00:47:42.940 --> 00:47:45.500
Third argument is an error,
if an error has occurred.

00:47:45.500 --> 00:47:49.980
And then finally is a context pointer,
which you could have provided

00:47:50.070 --> 00:47:53.380
to pass information or state
around inside your own program.

00:47:54.370 --> 00:47:55.990
To handle it, first we look at the error.

00:47:55.990 --> 00:47:58.060
If an error has occurred,
then we're going to need to

00:47:58.060 --> 00:47:59.380
field it in some fashion.

00:48:01.750 --> 00:48:04.650
Assuming no error has occurred,
we can now safely call

00:48:04.710 --> 00:48:07.640
CFHost getAddressing,
knowing that the host already

00:48:07.640 --> 00:48:09.400
has the address available.

00:48:09.400 --> 00:48:13.080
So that will return immediately,
providing the addresses

00:48:13.080 --> 00:48:14.690
that it just received.

00:48:15.190 --> 00:48:18.420
Your program will probably want
to do something more specific

00:48:18.740 --> 00:48:22.240
or more sophisticated than this,
but just to show you how we

00:48:22.240 --> 00:48:25.380
would get the information out,
here we get the value of

00:48:25.500 --> 00:48:27.340
the first item in the array.

00:48:27.340 --> 00:48:30.040
That's going to be CFDataRef.

00:48:30.040 --> 00:48:35.820
The CFData is essentially a sock adder,
so CFData get byte pointer is going

00:48:35.820 --> 00:48:38.780
to give you a pointer to a sock adder.

00:48:38.790 --> 00:48:42.240
CFData get length will give you
the length of that sock adder.

00:48:42.890 --> 00:48:45.840
You can pass it into any Unix call.

00:48:45.840 --> 00:48:48.440
Here I'm just calling
connect to connect a socket.

00:48:52.480 --> 00:48:54.600
Finally, we need to clean up.

00:48:54.620 --> 00:48:58.770
Any asynchronous process is going to
require a little extra cleanup compared

00:48:58.810 --> 00:49:01.030
to simply releasing a reference.

00:49:01.540 --> 00:49:02.770
Basically three phases.

00:49:02.880 --> 00:49:05.080
First, unschedule it from the run loop.

00:49:05.260 --> 00:49:09.380
That makes sure that the run loop
releases any reference it has on the

00:49:09.380 --> 00:49:14.720
host and that any data or state that's
being maintained by the host object

00:49:14.720 --> 00:49:17.290
or by the run loop gets freed up.

00:49:17.530 --> 00:49:21.630
CF host set client null tells
the host that you're done,

00:49:21.630 --> 00:49:25.330
you don't ever want to
receive a callback again.

00:49:25.470 --> 00:49:28.760
And then finally,
CF release releases your

00:49:28.790 --> 00:49:30.510
reference on the host object.

00:49:33.730 --> 00:49:41.690
And that's what I wanted to say about
those two basic CFNetworking tasks.

00:49:41.690 --> 00:49:41.690
Now we're running a little tight on time.

00:49:43.820 --> 00:49:46.980
So I'm going to fly
through this next section,

00:49:46.980 --> 00:49:51.090
where we're going to talk about some of
the other URL loading APIs on the system.

00:49:51.770 --> 00:49:55.740
The two other major URL loading
APIs on a Mac OS X system are

00:49:55.850 --> 00:50:00.220
the Foundation URL loading
pieces and URL Access Manager.

00:50:00.220 --> 00:50:04.510
The Foundation pieces are basically
represented by these three classes,

00:50:04.510 --> 00:50:07.340
NSURL Request, Response, and Connection.

00:50:07.340 --> 00:50:11.150
URL Access Manager is the
Carbon API that became available,

00:50:11.150 --> 00:50:14.650
I think, starting in 9,
maybe a little before that,

00:50:14.650 --> 00:50:16.320
and is now deprecated.

00:50:16.350 --> 00:50:18.100
It has been for a couple years now.

00:50:21.210 --> 00:50:33.350
So way back when I was talking about
how CFNetwork is intended as a power

00:50:33.350 --> 00:50:33.350
API that exposes all of the pieces,
all of the knobs and

00:50:33.350 --> 00:50:33.350
buttons on a given protocol.

00:50:33.710 --> 00:50:36.360
Foundation is the convenience API.

00:50:36.560 --> 00:50:41.830
Foundation provides a nice, smooth,
easy API to allow you to download

00:50:41.830 --> 00:50:44.560
a URL just like a browser would.

00:50:44.680 --> 00:50:51.180
Whatever it is that a browser
does in terms of cookies,

00:50:51.280 --> 00:50:54.710
authentication, caching,
all of that magic is just done

00:50:54.710 --> 00:50:54.710
automatically at the Foundation level.

00:50:54.800 --> 00:50:56.940
So there are two consequences of that.

00:50:56.980 --> 00:50:59.930
First, as you'd expect,
at the foundation level,

00:50:59.950 --> 00:51:02.290
we have support for a lot more features.

00:51:02.370 --> 00:51:05.780
Caching cookie support,
better authentication support in

00:51:05.780 --> 00:51:09.800
the sense that there will be some
automatic credential management.

00:51:09.800 --> 00:51:13.660
The callbacks are a little cleaner
at the foundation level than what

00:51:13.660 --> 00:51:16.000
you saw at the CFNetwork level.

00:51:16.000 --> 00:51:17.410
Becky Willrich

00:51:17.900 --> 00:51:21.660
But the other consequence is that
there are a lot more constraints

00:51:21.830 --> 00:51:25.470
because the URL loading system
has made some choices for you.

00:51:25.470 --> 00:51:29.720
You must use an asynchronous
delegation model.

00:51:29.720 --> 00:51:32.500
You must use the threading
model that Foundation dictates.

00:51:32.500 --> 00:51:35.480
And you must use
Foundation scheduling policy.

00:51:35.720 --> 00:51:38.350
So for instance,
there's no way to say download

00:51:38.370 --> 00:51:41.430
these URLs on this thread
and these others on another.

00:51:41.990 --> 00:51:45.200
There's no way to halt
a download in progress.

00:51:45.530 --> 00:51:48.910
There's no way to give a
particular URL download a

00:51:48.910 --> 00:51:51.680
higher priority than other ones.

00:51:51.790 --> 00:51:54.930
And then just as an added note,
the foundation always

00:51:54.930 --> 00:51:56.680
uses the system proxies.

00:51:56.680 --> 00:52:00.760
You cannot do any custom proxy
configuration at the foundation layer.

00:52:04.290 --> 00:52:06.980
So how do you decide which
one you're going to use?

00:52:07.040 --> 00:52:10.300
Well, use NSURL,
use the foundation APIs if you

00:52:10.300 --> 00:52:12.380
need the additional features.

00:52:12.500 --> 00:52:16.380
But more generally,
use NSURL if your task is really

00:52:16.380 --> 00:52:19.450
to download something pretty much
exactly like a browser would.

00:52:19.520 --> 00:52:24.390
So the classic example for me of this
is when you're downloading HTML mail.

00:52:24.470 --> 00:52:28.730
You're going to display it just the way
you would expect a browser to display it.

00:52:28.860 --> 00:52:31.820
You want to download all the
images exactly the same way,

00:52:31.820 --> 00:52:34.820
with the same cookies,
same authentication model

00:52:34.820 --> 00:52:37.280
that a browser would use.

00:52:37.920 --> 00:52:41.980
On the other hand,
use CFNetwork if you don't

00:52:41.980 --> 00:52:43.120
want to link that high.

00:52:43.190 --> 00:52:45.600
You don't want the extra
convenience and the extra pieces.

00:52:45.600 --> 00:52:48.260
You don't want to link
foundation or Objective-C.

00:52:48.260 --> 00:52:51.820
You want fine-tuned control
of the threading model.

00:52:51.820 --> 00:52:54.750
Or more generally,
you're not doing a basic

00:52:54.750 --> 00:52:56.620
browser-like download.

00:52:57.100 --> 00:53:01.420
So a classic example of that is
you're downloading a software update.

00:53:01.420 --> 00:53:03.630
You're only going to download it once.

00:53:03.630 --> 00:53:05.380
You don't want it cached.

00:53:05.420 --> 00:53:07.470
You know there are no cookies involved.

00:53:07.880 --> 00:53:09.910
Whatever authentication
needs to be performed,

00:53:09.910 --> 00:53:11.780
you already know all
the details about it.

00:53:11.860 --> 00:53:15.640
You can use foundation to do that
kind of a download if you want,

00:53:15.640 --> 00:53:19.840
but it's more work to go in and turn
off each and every one of those things

00:53:19.840 --> 00:53:24.140
than to just start with CFNetwork
and do the download from there.

00:53:28.400 --> 00:53:30.950
So then the other API,
URL Access Manager.

00:53:30.950 --> 00:53:33.970
You should never use
URL Access Manager anymore.

00:53:33.970 --> 00:53:35.340
Really, it's dead.

00:53:35.390 --> 00:53:38.210
We've been saying that for
at least two years now.

00:53:38.210 --> 00:53:42.120
And then I was thinking, well, OK,
is there any time I would recommend

00:53:42.200 --> 00:53:44.150
that you use URL Access Manager?

00:53:44.180 --> 00:53:50.050
Well, if you still need
compatibility with Mac OS 9,

00:53:50.050 --> 00:53:52.290
then you're stuck.

00:53:52.290 --> 00:53:52.420
Yeah, you're going to have to
use URL Access Manager.

00:53:52.810 --> 00:53:56.270
But to give you a little incentive
to kind of migrate that old

00:53:56.270 --> 00:54:00.620
code off of URL Access Manager,
I've listed here the major shortcomings

00:54:00.620 --> 00:54:05.100
of URL Access that have been fixed
with CFNetwork and with Foundation,

00:54:05.100 --> 00:54:08.180
but will never be fixed
in URL Access Manager.

00:54:08.180 --> 00:54:12.040
No authenticating proxies,
no HTTPS proxies,

00:54:12.040 --> 00:54:17.190
tied to a couple obsolete APIs,
the Thread Manager and FS specs,

00:54:17.260 --> 00:54:20.760
and no support never will be for IPv6.

00:54:24.420 --> 00:54:27.910
So if I want to migrate
from URL Access Manager to

00:54:28.140 --> 00:54:31.560
CFNetwork or Foundation,
what do I need to do?

00:54:31.560 --> 00:54:34.840
Three basic entry points
to URL Access Manager is

00:54:34.840 --> 00:54:37.600
URL Simple Download and URL Download.

00:54:37.600 --> 00:54:40.760
And then there's URL Open,
which is the asynchronous

00:54:40.760 --> 00:54:42.620
API for URL Access Manager.

00:54:43.620 --> 00:54:48.400
If you're doing a download to memory,
use these NSURL methods instead.

00:54:48.400 --> 00:54:51.830
If you're doing a download to file,
use NSURL download.

00:54:51.830 --> 00:54:53.880
It's designed for that purpose.

00:54:53.880 --> 00:54:56.200
You can use CFNetwork instead of NSURL.

00:54:56.200 --> 00:54:57.820
It takes a little more work.

00:54:57.880 --> 00:55:02.520
I listed NSURL as the first choice
because that's the one-line replacement.

00:55:02.520 --> 00:55:05.110
Using CFNetwork is maybe 50,
something like,

00:55:05.570 --> 00:55:08.300
depending on how sophisticated
a download you're doing.

00:55:08.300 --> 00:55:13.480
And there is some good sample
code available at developer.com.

00:55:13.630 --> 00:55:17.710
to show you how to do
a CF network download.

00:55:18.980 --> 00:55:21.650
URL open is considerably more
sophisticated and provides

00:55:21.650 --> 00:55:23.100
a number of different flags.

00:55:23.160 --> 00:55:27.160
So what you're going to do if
you're calling URL open depends

00:55:27.160 --> 00:55:29.130
on why you're using URL open.

00:55:29.340 --> 00:55:34.520
If the only reason you're using URL open
is to get some asynchrony support,

00:55:34.620 --> 00:55:36.870
use NSURL connection instead.

00:55:37.000 --> 00:55:40.550
If, on the other hand,
you need a high level of customization

00:55:40.660 --> 00:55:44.460
or detailed threading and buffer control,
drop to CFNetwork.

00:55:44.810 --> 00:55:48.780
That'll give you the extra knobs
you need to control the download.

00:55:49.940 --> 00:55:52.520
That's all I want to
say about those APIs.

00:55:52.560 --> 00:55:55.470
We are out of time,
so I'm just going to point out that

00:55:55.720 --> 00:55:59.500
there are about a million references,
a bunch of documentation

00:55:59.540 --> 00:56:01.480
and sample code available.

00:56:01.480 --> 00:56:08.550
All of this information is
available in the disk image,

00:56:09.080 --> 00:56:09.540
so just get the disk image and you'll see
all of this information replicated there.
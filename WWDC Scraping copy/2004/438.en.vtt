WEBVTT

00:00:11.060 --> 00:00:13.910
I'm Dominic Giampaolo,
a member of the Spotlight team,

00:00:13.970 --> 00:00:16.910
and this talk is working with Spotlight.

00:00:18.510 --> 00:00:21.000
First, I'd like to go over what
we're going to cover today.

00:00:21.100 --> 00:00:24.090
So the agenda that we
have is why Spotlight,

00:00:24.250 --> 00:00:26.470
how it works,
what is it that we were trying to solve,

00:00:26.540 --> 00:00:29.640
what did we try and accomplish.

00:00:29.700 --> 00:00:32.880
Then the next piece,
integrating your app with Spotlight,

00:00:33.010 --> 00:00:36.300
what does that mean,
what are the different parts of that,

00:00:36.450 --> 00:00:39.980
searching with Spotlight, and of course,
working with metadata.

00:00:40.030 --> 00:00:42.920
The main focus of the talk is really
going to be about what it means to

00:00:42.920 --> 00:00:45.590
integrate your app with Spotlight.

00:00:46.160 --> 00:00:47.400
First off, what's the problem?

00:00:47.420 --> 00:00:49.960
Any engineering task,
before you start it,

00:00:50.070 --> 00:00:53.210
you of course want to define what is,
put it in a box, define it.

00:00:53.320 --> 00:00:54.850
What is it that we're
trying to solve here?

00:00:54.860 --> 00:00:57.060
It's hard to find
things on your computer.

00:00:57.100 --> 00:00:58.520
I think we've all run into this.

00:00:58.560 --> 00:01:00.840
So, why is it hard?

00:01:00.840 --> 00:01:02.860
There's too many files.

00:01:02.910 --> 00:01:05.910
If you're anything like me,
you've accumulated a few

00:01:05.910 --> 00:01:09.150
files over the years,
a couple tens of thousands, and then,

00:01:09.320 --> 00:01:11.100
well, there's digital cameras.

00:01:11.100 --> 00:01:13.880
Oh, that's another couple thousand,
ten thousand files.

00:01:14.290 --> 00:01:17.800
And, oh yeah, all those MP3 files,
that's another bunch of files.

00:01:17.800 --> 00:01:20.580
Any movies that you've
created or downloaded,

00:01:20.580 --> 00:01:21.800
it starts to accumulate.

00:01:21.800 --> 00:01:23.110
Right?

00:01:23.170 --> 00:01:26.870
If you've bothered to put things
into some kind of organization,

00:01:26.870 --> 00:01:27.560
that's really nice.

00:01:27.680 --> 00:01:31.940
You have, like, I'm a little bit of a
librarian in a sense,

00:01:32.050 --> 00:01:34.720
you know, nice broad hierarchy,
but everything's fixed

00:01:34.720 --> 00:01:37.740
into a single location,
and that's not always what you want.

00:01:37.950 --> 00:01:40.730
You may have files that fit
into multiple categories.

00:01:40.740 --> 00:01:44.160
I have just got back from a trip,
and I took lots of pictures of flowers

00:01:44.160 --> 00:01:46.460
and lots of pictures of mountains,
but in different countries.

00:01:46.460 --> 00:01:49.100
If I want to say, show me all the flower
pictures I took in France,

00:01:49.140 --> 00:01:51.520
well, that's one thing,
but if I want to say,

00:01:51.520 --> 00:01:53.210
just show me all the flower
pictures from the trip,

00:01:53.460 --> 00:01:55.580
including France and
Italy and wherever else,

00:01:55.580 --> 00:01:56.370
can't do it.

00:01:56.420 --> 00:01:59.100
It's not an easy way to organize things.

00:02:00.660 --> 00:02:03.240
Next, there's also a lot of rich
information about files,

00:02:03.580 --> 00:02:05.760
and we're just not using it.

00:02:05.910 --> 00:02:09.560
So even though MP3 files are
tagged with a lot of rich metadata,

00:02:09.560 --> 00:02:14.510
email has quite a bit of metadata,
JPEG images, of course,

00:02:14.670 --> 00:02:17.890
the EXIF information from
the camera is quite a bit.

00:02:17.900 --> 00:02:21.040
You may want to say,
show me everything with an aperture

00:02:21.050 --> 00:02:26.090
less than f-stop of 3.0 for things that
you'd shot as close up or long distance.

00:02:26.120 --> 00:02:28.220
But there's no way to
easily search for that.

00:02:28.380 --> 00:02:31.170
So there's just no easy way
to find this information.

00:02:33.620 --> 00:02:35.160
What's the Spotlight solution?

00:02:35.310 --> 00:02:38.040
Obviously, we want to make it fast
and easy to find files,

00:02:38.040 --> 00:02:40.220
as opposed, of course,
to making it confusing and difficult,

00:02:40.220 --> 00:02:42.220
which I suppose if that was the goal,
we're already done.

00:02:42.220 --> 00:02:45.800
So how do we want to do this?

00:02:45.960 --> 00:02:48.190
By using metadata to
enable richer searches.

00:02:48.200 --> 00:02:52.240
Metadata is information about the
data or the contents of a file.

00:02:52.240 --> 00:02:57.030
We want to use that to enable users
to search in a more natural way.

00:02:57.040 --> 00:03:00.720
This allows you to organize files in
multiple ways so that you can set,

00:03:00.720 --> 00:03:06.040
like I was giving the example before,
mountains in France or French pictures,

00:03:06.050 --> 00:03:07.450
pictures I took in France.

00:03:07.520 --> 00:03:10.430
These are different axes
that you can flip around.

00:03:10.440 --> 00:03:12.960
We'd also like to allow
for additional metadata,

00:03:12.990 --> 00:03:16.480
things that maybe weren't
originally envisioned as being

00:03:16.480 --> 00:03:18.520
associated with the file,
but that you need to,

00:03:18.520 --> 00:03:19.780
such as workflow state.

00:03:20.090 --> 00:03:22.830
And the last point is a very key one.

00:03:22.840 --> 00:03:24.930
We don't want to require apps to change.

00:03:25.140 --> 00:03:28.120
It would be great if we
could wave our hands.

00:03:28.170 --> 00:03:29.380
Ta-da!

00:03:29.380 --> 00:03:30.160
New world!

00:03:30.160 --> 00:03:31.350
Everyone's rewritten all their apps.

00:03:31.640 --> 00:03:31.870
Great.

00:03:33.140 --> 00:03:35.230
We all work with metadata
and we're all very happy,

00:03:35.360 --> 00:03:36.760
but the world doesn't work that way.

00:03:36.760 --> 00:03:37.790
You have lots of code.

00:03:37.810 --> 00:03:38.980
It's difficult to change.

00:03:39.100 --> 00:03:41.680
So the minimal amount
that we can ask you to do,

00:03:41.680 --> 00:03:42.410
the better.

00:03:44.310 --> 00:03:49.150
Now I'm going to go through a quick demo
of Spotlight to cover a couple of things

00:03:49.150 --> 00:03:53.170
that I'd like to highlight for you.

00:03:53.200 --> 00:03:57.250
First, of course,
we'll start with the finder.

00:03:58.170 --> 00:04:00.800
So some of this you saw in the keynote,
but there's a couple of subtleties

00:04:00.800 --> 00:04:03.640
that I wanted to point out.

00:04:03.640 --> 00:04:06.050
So first query type, of course, HTML.

00:04:06.460 --> 00:04:10.370
We find 779 items out of
whatever are on this disk,

00:04:10.570 --> 00:04:11.890
and that's pretty fast.

00:04:11.940 --> 00:04:17.770
If I was to type something like JPEG,
like this, we find 1183,

00:04:17.880 --> 00:04:18.660
which is a little bit bigger.

00:04:18.660 --> 00:04:21.520
A few people missed this in the keynote,
or at least I heard,

00:04:21.520 --> 00:04:23.080
but there are smart folders.

00:04:23.200 --> 00:04:27.580
So if I type JPEG down here,
now I have a smart folder of JPEG images.

00:04:27.630 --> 00:04:30.060
I have another one of HTML as well.

00:04:30.210 --> 00:04:32.600
So you can save your searches
and come back to them,

00:04:32.600 --> 00:04:36.560
and of course,
they're re-executed at that time.

00:04:37.140 --> 00:04:41.830
Another thing, if I was to type
something like Frederick,

00:04:41.850 --> 00:04:43.880
okay, nothing matches.

00:04:44.050 --> 00:04:46.530
If I come over here,
I'll just position these

00:04:46.680 --> 00:04:50.480
windows appropriately,
and I go and create myself a new folder.

00:04:50.480 --> 00:04:53.300
But I'm not going to
type Frederick normally.

00:04:53.300 --> 00:04:55.610
I'm going to do it the French way
because there's so many

00:04:55.610 --> 00:04:57.140
wonderful French people at Apple.

00:04:57.140 --> 00:05:01.100
So we type it with a
few extra accents there.

00:05:01.100 --> 00:05:03.280
And when I hit return,
notice that it showed up

00:05:03.280 --> 00:05:05.340
automatically in this query over here.

00:05:05.340 --> 00:05:08.030
So even though I typed the
E's without the accents,

00:05:08.030 --> 00:05:11.560
we're doing case and diacritic
and sensitivity on the matches,

00:05:11.750 --> 00:05:13.400
and you saw that it was live as well.

00:05:13.400 --> 00:05:14.900
It showed up when I created it.

00:05:14.980 --> 00:05:20.010
And if I was to drag that to the trash,
it disappears from the query.

00:05:20.020 --> 00:05:24.170
Next, I'm going to show you
a little application.

00:05:24.310 --> 00:05:26.910
Well, not so little,
but a very nice application that we

00:05:27.170 --> 00:05:32.370
wrote internally called Bullsearch
to demonstrate another feature

00:05:32.370 --> 00:05:35.840
that we have called grouping.

00:05:35.840 --> 00:05:42.940
So if I was to search for JPEG, again,
we find, there's a bunch of items here,

00:05:43.040 --> 00:05:43.930
and I'm going to organize.

00:05:43.990 --> 00:05:46.310
There's an option for grouping.

00:05:46.400 --> 00:05:49.190
And so if I choose to
organize these by title,

00:05:49.510 --> 00:05:51.970
some of these things were
actually QuickTime movies that

00:05:51.970 --> 00:05:55.000
were compressed with JPEG,
photo JPEG compression.

00:05:55.090 --> 00:05:58.570
So now you see there's kind of these
set of virtual folders that were

00:05:58.570 --> 00:06:01.070
automatically created based on the title.

00:06:01.080 --> 00:06:04.780
So there were five different versions
of the Dungeons & Dragons trailer,

00:06:04.840 --> 00:06:09.330
and they get grouped together
because they all have the same title.

00:06:09.400 --> 00:06:12.730
So it's sort of synthetic virtual,
and then you have virtual folders that

00:06:12.730 --> 00:06:16.560
get created on the fly based on the set
of attributes that you're grouping by.

00:06:16.560 --> 00:06:21.560
And this is a very powerful way to kind
of build virtual hierarchies on the fly.

00:06:21.560 --> 00:06:25.560
So Finding Nemo, again,
there's only three versions of that film.

00:06:25.560 --> 00:06:30.560
These are different resolutions
or bit rates for the web or so on,

00:06:30.880 --> 00:06:34.550
which is kind of a nice
way to organize things.

00:06:34.620 --> 00:06:40.720
Now, the key part of this demo, actually,
let me just quit that,

00:06:40.720 --> 00:06:45.720
is that I'm going to run Microsoft Word.

00:06:45.720 --> 00:06:48.910
Fire that up here for a second,
and I'm going to bring

00:06:48.930 --> 00:06:51.150
up another Finder window.

00:06:51.220 --> 00:06:55.180
I'm going to type the word
"outrageous." Nothing matches

00:06:55.180 --> 00:06:59.480
the word "outrageous." Now,
in Word,

00:07:00.430 --> 00:07:04.960
Outrageous document baby.

00:07:04.960 --> 00:07:05.990
So I've just created this.

00:07:06.070 --> 00:07:09.520
If I save it, and I'm going to call it
whatever because if it had the

00:07:09.520 --> 00:07:12.640
word outrageous in the title,
that would be too easy.

00:07:12.640 --> 00:07:18.120
And so, of course,
it automatically matched in

00:07:18.120 --> 00:07:18.120
the content and showed up.

00:07:19.730 --> 00:07:22.230
Key thing to observe,
we didn't change Word, right?

00:07:22.230 --> 00:07:25.490
We don't have access to Word,
so we didn't actually do anything.

00:07:25.490 --> 00:07:28.130
The find by content,
that's pretty straightforward.

00:07:28.480 --> 00:07:31.160
Another thing, though,
that is a little bit more subtle,

00:07:31.160 --> 00:07:33.770
if you pull up the property sheet,
and this was alluded

00:07:33.870 --> 00:07:36.040
to in Bertrand's demo,
you can see that there's

00:07:36.300 --> 00:07:39.010
some metadata here that was
automatically filled in for me,

00:07:39.010 --> 00:07:40.970
both in the title and the author field.

00:07:40.970 --> 00:07:42.040
So just click OK there.

00:07:42.180 --> 00:07:44.820
If I was to come back over here,
and I'm just going to type

00:07:44.990 --> 00:07:49.510
something else that matches nothing,
so you can see there's nothing there.

00:07:49.600 --> 00:07:52.160
If I type my last name,
it matches the document,

00:07:52.220 --> 00:07:54.250
because we extracted that metadata.

00:07:54.250 --> 00:07:58.010
And again, this is the role of importers,
which is a key thing that we're

00:07:58.150 --> 00:08:00.360
going to talk about here in a second.

00:08:00.360 --> 00:08:05.420
And this is how you get your
app integrated into Spotlight.

00:08:05.420 --> 00:08:08.940
So without any changes to
Microsoft Word whatsoever,

00:08:08.940 --> 00:08:13.670
the simple addition of this importer,
we've managed to get it integrated

00:08:13.670 --> 00:08:17.940
very seamlessly so that you can
search for things by their author,

00:08:17.940 --> 00:08:19.330
so on and so forth.

00:08:19.690 --> 00:08:27.190
Okay, so let's quit out of here,
clean this up, don't bother saying that.

00:08:27.190 --> 00:08:32.160
And so going back to the slides,
if we can for a second.

00:08:35.810 --> 00:08:36.400
Why do you care?

00:08:36.400 --> 00:08:40.100
Spotlight enriches the user experience,
plain and simple.

00:08:40.100 --> 00:08:42.310
It makes your documents easier to find.

00:08:42.310 --> 00:08:46.520
When you're integrated properly
by the presence of an importer,

00:08:46.520 --> 00:08:49.170
your documents,
users can find them based on things

00:08:49.300 --> 00:08:52.050
that they remember about them,
not just the title.

00:08:52.080 --> 00:08:57.480
So that can take many different forms,
some of which we're going to go over.

00:08:57.480 --> 00:09:00.670
It doesn't require any
code changes in your app.

00:09:00.870 --> 00:09:03.690
There are things that you can
do to take additional advantage

00:09:03.690 --> 00:09:07.120
of Spotlight if you want,
but without doing anything at all,

00:09:07.260 --> 00:09:09.380
for example,
like we did with Microsoft Word,

00:09:09.530 --> 00:09:12.080
you can take advantage of,
you can get integrated

00:09:12.080 --> 00:09:13.590
into the Spotlight system.

00:09:13.700 --> 00:09:16.200
Users can find their
documents more easily.

00:09:16.200 --> 00:09:19.900
It's like an additional feature
for almost no work whatsoever.

00:09:19.900 --> 00:09:24.410
And it's another way to share data with
applications so that applications don't

00:09:24.410 --> 00:09:28.800
have to necessarily know everybody
else's file format for the information,

00:09:28.800 --> 00:09:33.240
the metadata that's important,
which can be published by the importer.

00:09:33.240 --> 00:09:36.560
Then it's more easily accessible
to other applications,

00:09:36.670 --> 00:09:38.960
and they don't have to go through
and parse your file format.

00:09:38.960 --> 00:09:41.370
There's a uniform way to access it.

00:09:43.340 --> 00:09:45.130
Now we're going to talk a
little bit about the Spotlight

00:09:45.130 --> 00:09:48.390
architecture so you can understand
kind of how it's put together and

00:09:48.400 --> 00:09:50.330
where you fit into the equation.

00:09:53.500 --> 00:09:56.900
Spotlight is a system for storing
and retrieving and querying and

00:09:56.900 --> 00:09:59.290
getting information about files.

00:09:59.320 --> 00:10:03.460
It's composed of a server,
which runs in the background,

00:10:03.460 --> 00:10:06.620
daemons that help the server,
and of course, importers.

00:10:06.620 --> 00:10:09.410
And I should not forget
to mention the client API,

00:10:09.410 --> 00:10:11.360
which is part of core services.

00:10:11.380 --> 00:10:16.100
The importers are the sort of
connection from the rest of the

00:10:16.100 --> 00:10:18.980
world to the system that stores it.

00:10:19.100 --> 00:10:20.830
Kind of what does it look like?

00:10:22.060 --> 00:10:23.480
Let's see if this can get this to work.

00:10:23.610 --> 00:10:26.760
So over here on the left side,
you have an application,

00:10:26.790 --> 00:10:29.200
which goes and writes a file.

00:10:29.240 --> 00:10:32.250
When that file is written,
the system notices this,

00:10:32.250 --> 00:10:35.900
and an importer is run to
extract metadata from that file,

00:10:35.900 --> 00:10:39.310
which is then connected up
to the Spotlight server,

00:10:39.310 --> 00:10:42.280
which stores it into the system's store.

00:10:42.280 --> 00:10:46.260
On the right-hand side of the picture,
you have the finder icon,

00:10:46.260 --> 00:10:50.210
which could be any application,
which issues queries and receives

00:10:50.310 --> 00:10:51.950
results and can display those.

00:10:51.960 --> 00:10:55.470
Not a lot of apps have a need for that,
but for those that do,

00:10:55.470 --> 00:10:57.790
that's the sort of final piece of it.

00:11:00.170 --> 00:11:02.570
There's three main concepts
in the Spotlight system.

00:11:02.570 --> 00:11:06.120
Of course, you have importers,
which I've mentioned here using

00:11:06.280 --> 00:11:09.920
the actual code terminology,
MD importer, which is how you extract

00:11:09.920 --> 00:11:12.650
metadata from a file,
publish it to the system.

00:11:12.660 --> 00:11:15.690
That's pretty straightforward,
and we're going to write one later

00:11:15.690 --> 00:11:17.220
on in the talk in a minute here.

00:11:17.220 --> 00:11:21.000
You have an MD query,
which is a way to write an expression

00:11:21.090 --> 00:11:24.980
about the attributes that you
want to find or the files that

00:11:24.980 --> 00:11:27.540
you want to find and retrieve them.

00:11:27.560 --> 00:11:30.800
And then the leaf items are MD items,
which represent files,

00:11:30.800 --> 00:11:32.900
and items are made up of attributes.

00:11:32.900 --> 00:11:36.480
And I use the word metadata and
attributes sort of interchangeably.

00:11:36.480 --> 00:11:41.250
Attributes are a name, type, and a value,
and represent some

00:11:41.250 --> 00:11:43.620
information about the file.

00:11:46.080 --> 00:11:48.880
Ways to integrate with Spotlight.

00:11:48.880 --> 00:11:52.300
You can write an importer if
you have a custom file format.

00:11:52.320 --> 00:11:57.020
So if you work with standard file
formats such as JPEG or AIFF or MP3,

00:11:57.020 --> 00:11:58.160
you don't have to do anything.

00:11:58.160 --> 00:12:01.960
We're going to cover the basic data
types that Apple supports natively.

00:12:01.960 --> 00:12:05.120
So there's no work to be done if
you work with standard file formats.

00:12:05.120 --> 00:12:10.090
With some caveats in the sense that you
want to put metadata in there if you can.

00:12:10.090 --> 00:12:13.040
But the first thing you can
do if you have a custom file

00:12:13.040 --> 00:12:15.000
format is to write an importer.

00:12:15.000 --> 00:12:19.000
This is what enables sophisticated
searches for your documents.

00:12:19.000 --> 00:12:22.000
You want to put useful
metadata in your documents.

00:12:22.000 --> 00:12:24.640
So that's sort of what I was
saying is that if you can,

00:12:24.640 --> 00:12:27.230
for example,
the EXIF data that comes in a camera,

00:12:27.230 --> 00:12:29.390
preserve it,
make sure it stays in there or

00:12:29.480 --> 00:12:32.670
put additional information in
there that we can extract because

00:12:32.690 --> 00:12:36.560
a lot of file formats already have
support for a variety of metadata.

00:12:36.560 --> 00:12:41.120
And then if you need, you can,
the final level of integration is

00:12:41.270 --> 00:12:45.850
to actually use Spotlight queries
for tracking documents or you know,

00:12:45.850 --> 00:12:47.750
displaying results.

00:12:48.820 --> 00:12:50.940
Now we're going to switch
to talking about importers.

00:12:50.950 --> 00:12:53.340
And in this section of the talk,
we will actually go through

00:12:53.340 --> 00:12:57.530
and create one and write it,
install it, and show you how it works.

00:12:57.820 --> 00:12:59.450
What are the rules of the game?

00:12:59.480 --> 00:13:03.050
Importers need to publish
metadata that helps users search.

00:13:03.230 --> 00:13:05.400
Kind of harping on this.

00:13:05.400 --> 00:13:10.010
You want to allow for richer previews,
which in the sense that some

00:13:10.010 --> 00:13:12.160
attributes are difficult to compute.

00:13:12.300 --> 00:13:13.400
So the length of a song.

00:13:13.490 --> 00:13:17.560
If you have a variable bit rate file,
computing how long it takes, you know,

00:13:17.720 --> 00:13:19.920
what's the duration, is difficult.

00:13:20.050 --> 00:13:22.930
So you would want to compute
that once and store it as an

00:13:22.930 --> 00:13:26.060
attribute so that we can say,
oh, find me songs that are

00:13:26.060 --> 00:13:27.560
longer than three minutes.

00:13:27.560 --> 00:13:28.540
That's useful.

00:13:28.560 --> 00:13:34.160
You want to avoid putting things into
publishing metadata that's private data,

00:13:34.330 --> 00:13:36.780
binary data, icon previews.

00:13:36.840 --> 00:13:38.870
This is not what Spotlight is about.

00:13:39.100 --> 00:13:41.920
Spotlight is in a sort of
fast and efficient way to

00:13:42.060 --> 00:13:46.850
search for user-oriented data,
things that users remember,

00:13:46.850 --> 00:13:50.070
the labels of layers in
a Photoshop document,

00:13:50.160 --> 00:13:54.240
the names of tracks in a multitrack
audio editor or movie editor.

00:13:54.240 --> 00:13:54.680
These are things that you want to avoid.

00:13:54.680 --> 00:13:54.940
And you want to avoid putting
things into publishing data

00:13:55.020 --> 00:13:59.120
that people would remember that
they would want to search for.

00:13:59.120 --> 00:14:02.690
A chunk of some data structure that's
internal to your app that's binary

00:14:02.690 --> 00:14:06.100
that the user has no connection to,
no, that's not something that

00:14:06.170 --> 00:14:07.690
they'd want to search for.

00:14:07.880 --> 00:14:10.840
And at the other end of the spectrum,
too much noise,

00:14:10.840 --> 00:14:13.480
too many attributes can confuse the user.

00:14:13.550 --> 00:14:18.880
If you have 500 attributes,
that's probably not the right approach.

00:14:19.420 --> 00:14:20.840
So what are attributes?

00:14:20.870 --> 00:14:24.750
Examples of good attributes: copyright,
title, author, dimensions.

00:14:24.950 --> 00:14:28.320
There's a special attribute
called KMDItemTextContent,

00:14:28.570 --> 00:14:32.340
which we use to represent the
text content of a document,

00:14:32.430 --> 00:14:35.330
and this is how we do
the full text searches.

00:14:35.340 --> 00:14:38.140
So that can take a couple
of different forms,

00:14:38.370 --> 00:14:40.480
and I'll cover that in
a couple of minutes.

00:14:40.600 --> 00:14:44.410
Some bad attributes would be, you know,
app-specific implementation

00:14:44.410 --> 00:14:49.120
details or binary data that the
user can't easily search on.

00:14:49.120 --> 00:14:51.620
We've predefined a whole
bunch of attributes.

00:14:51.620 --> 00:14:57.100
So you can see the list here,
KMDItemTitle, authors, keywords,

00:14:57.610 --> 00:14:59.440
projects, and so on.

00:14:59.800 --> 00:15:02.430
There's quite a different--quite
an extensive list.

00:15:02.520 --> 00:15:07.180
It hasn't covered everything, of course,
but a fairly broad set of things.

00:15:07.240 --> 00:15:14.010
And if you look in the include file,
metadataMDItem.h, you'll see that there's

00:15:14.010 --> 00:15:14.010
a list of attributes

00:15:14.110 --> 00:15:20.110
You will see the full
list of these attributes.

00:15:20.510 --> 00:15:22.550
So writing an importer.

00:15:22.550 --> 00:15:28.050
This is where we're going to actually
step through the process of writing one.

00:15:28.140 --> 00:15:29.160
What do you have to do to do it?

00:15:29.210 --> 00:15:32.080
In Xcode,
we've got a metadata importer template.

00:15:32.080 --> 00:15:34.540
There's one function to implement.

00:15:34.540 --> 00:15:37.300
So it's not that difficult.

00:15:37.300 --> 00:15:40.720
You can use your existing document
reading code with the caveat

00:15:40.720 --> 00:15:43.810
that you don't want to have
some piece of code that goes and

00:15:43.820 --> 00:15:46.100
inflates the entire data structure.

00:15:46.100 --> 00:15:49.850
You have some multi-megabyte
data image or whatever,

00:15:49.910 --> 00:15:53.670
and it gets pulled into memory
and exploded and decompressed.

00:15:54.000 --> 00:15:55.690
That's not what you would want to do.

00:15:55.690 --> 00:15:57.810
You would want to sort
of scrape the file,

00:15:57.810 --> 00:16:01.290
get the interesting bits of metadata,
and then publish that.

00:16:01.310 --> 00:16:04.130
So a lightweight version of
your document reading code.

00:16:04.140 --> 00:16:07.280
If you have a custom file format,
you know how to read and write it.

00:16:07.300 --> 00:16:09.660
So you probably have
code that you can use.

00:16:09.660 --> 00:16:12.930
And you return a CFDictionary of
the attributes that you would

00:16:12.930 --> 00:16:15.560
like to publish for that document.

00:16:15.590 --> 00:16:18.780
So those are sort of at a high level
what it takes to write an importer.

00:16:20.820 --> 00:16:23.640
There's three steps using
the MD Importer template.

00:16:23.640 --> 00:16:27.170
You have to create and define a GUID,
edit the Info.plist,

00:16:27.330 --> 00:16:28.600
and then implement the code.

00:16:28.620 --> 00:16:29.730
One, two, three.

00:16:29.740 --> 00:16:35.130
Defining the GUID, there's a command line
tool called UUIDgen.

00:16:35.140 --> 00:16:39.670
Type that in in the terminal, run it,
you get a string, put that into the code,

00:16:39.680 --> 00:16:45.960
edit the Info.plist to associate
that GUID with the code,

00:16:45.960 --> 00:16:50.300
and then identify the UTI types
that your plugin handles.

00:16:50.750 --> 00:16:54.030
So if you have a custom file
format with a custom file type,

00:16:54.340 --> 00:16:58.980
you would put the file type for
that document into the LSI item

00:16:59.110 --> 00:17:05.050
content types key in the Info.plist,
and that's how the system

00:17:05.120 --> 00:17:09.090
knows to associate your
importer with that data type.

00:17:09.170 --> 00:17:11.030
And we're going to go through a code.

00:17:11.160 --> 00:17:13.470
Then, of course,
you have to implement the code.

00:17:13.840 --> 00:17:17.750
There's a function, getMetadataForFile,
and that's that.

00:17:17.790 --> 00:17:19.480
So let's write an importer.

00:17:20.260 --> 00:17:22.950
And you'll see this
doesn't actually take too,

00:17:23.150 --> 00:17:23.780
too much.

00:17:23.780 --> 00:17:26.560
So I'll run Xcode.

00:17:26.560 --> 00:17:31.540
Oh,
can we switch over to the code machine?

00:17:31.540 --> 00:17:32.440
Okay.

00:17:35.330 --> 00:17:39.230
Okay, we'll create a new project.

00:17:39.290 --> 00:17:44.080
And this is a Apple standard plugin.

00:17:44.090 --> 00:17:51.070
We have metadata importer predefined.

00:17:51.070 --> 00:17:51.070
And we'll call this

00:17:51.960 --> 00:17:53.720
is the source importer,
although that's just because

00:17:53.750 --> 00:17:54.700
that's what I've been typing.

00:17:54.700 --> 00:17:56.700
It's not actually a source importer.

00:17:56.700 --> 00:17:58.700
Well, it sort of is.

00:17:58.700 --> 00:17:59.100
Let's see.

00:17:59.130 --> 00:18:05.970
So if we pull up main.c,
you can take a quick look here.

00:18:06.510 --> 00:18:11.970
We have a template and there is the
three steps that I talked about.

00:18:12.360 --> 00:18:16.100
First thing it says is create a
unique UUID for your importer.

00:18:16.100 --> 00:18:17.460
So fire up terminal.

00:18:17.460 --> 00:18:19.480
I type UUID gen.

00:18:19.480 --> 00:18:23.540
And I get this very beautiful 128-bit ID.

00:18:23.540 --> 00:18:27.300
And I will push that down there.

00:18:27.300 --> 00:18:30.080
And I paste that in there.

00:18:30.080 --> 00:18:30.880
Okay.

00:18:30.880 --> 00:18:35.090
And following the instructions,
go to step two, edit the Info.plist.

00:18:35.160 --> 00:18:35.520
All right.

00:18:35.550 --> 00:18:36.250
I can do that.

00:18:36.400 --> 00:18:39.990
and I come back over here and

00:18:40.930 --> 00:18:45.500
There is the metadata
import or plug-in ID.

00:18:45.520 --> 00:18:47.340
And I will paste in there.

00:18:47.360 --> 00:18:50.720
And once again,
this other part down here.

00:18:50.750 --> 00:18:54.730
And then the last thing that it said
to do was to change the UTI type.

00:18:54.940 --> 00:18:58.410
So in this case,
I'm going to say that we edit public-c,

00:18:58.410 --> 00:19:01.090
or we support public-c header files.

00:19:01.090 --> 00:19:02.440
Save that.

00:19:03.540 --> 00:19:06.740
And now,
the third step is to write the code.

00:19:06.740 --> 00:19:08.960
So of course,
I'm going to sit down and write

00:19:08.960 --> 00:19:11.860
a big chunk of code right now
that parses C header files.

00:19:11.860 --> 00:19:15.070
No, we're just going to cut
and paste a little bit.

00:19:15.100 --> 00:19:18.880
There's a couple of header files
that I need to throw in here.

00:19:18.880 --> 00:19:21.780
I'll put those up here at the top.

00:19:22.330 --> 00:19:28.640
And I will put in a...

00:19:30.290 --> 00:19:37.170
is the prototype for my function
which I wrote ahead of time.

00:19:37.170 --> 00:19:37.170
And...

00:19:37.550 --> 00:19:40.600
I'm just going to cut and paste a
nice big chunk of code down here

00:19:41.260 --> 00:19:47.090
below that is very rudimentary,
but...

00:19:47.110 --> 00:19:53.110
does enough work to make this demo
work to parse a C header file.

00:19:53.300 --> 00:19:56.340
The last thing said,
implement get metadata for file.

00:19:56.360 --> 00:20:00.290
So here we have that piece of
code that's empty at the moment.

00:20:00.320 --> 00:20:04.020
You're passed in a couple
of different arguments,

00:20:04.020 --> 00:20:06.330
and...

00:20:07.000 --> 00:20:09.280
The main one, of course,
is the attributes

00:20:09.340 --> 00:20:10.870
dictionary ref that you get.

00:20:11.190 --> 00:20:13.970
This is what we're going to fill
out with the information that we

00:20:13.970 --> 00:20:15.620
would like to publish for this file.

00:20:15.640 --> 00:20:19.020
We're also told the content type UTI,
so if you have an importer

00:20:19.060 --> 00:20:21.980
that handles multiple types,
you'll know what we think

00:20:22.100 --> 00:20:23.330
the type of the file is.

00:20:23.430 --> 00:20:27.270
And the last thing, most important,
is a reference to the file,

00:20:27.270 --> 00:20:30.410
the path to the file that
we would like you to parse.

00:20:30.460 --> 00:20:35.210
Now, I've already gone and filled in
the bit of code that does all this.

00:20:35.260 --> 00:20:36.780
I'm just going to cut and paste this.

00:20:36.900 --> 00:20:41.750
Into here, replacing this empty bit,
and then we'll go through

00:20:41.960 --> 00:20:42.990
it really briefly.

00:20:44.080 --> 00:20:50.690
And so this,
we get the full path and then we

00:20:51.420 --> 00:20:54.960
have this function getTypeDefNames,
which given a path,

00:20:54.960 --> 00:20:59.910
returns to us the number of type
defs in a C array and then does the

00:21:00.020 --> 00:21:06.910
magic to convert that into a CFArray,
which we then add as a dictionary

00:21:06.910 --> 00:21:12.500
value with a particular,
this is the attribute name,

00:21:12.500 --> 00:21:13.860
comAppleSourceTypeDefName.

00:21:14.000 --> 00:21:18.600
And there's one thing I have to do here
because we have a custom attribute name.

00:21:19.130 --> 00:21:21.970
And we pass in the CFTypeDefs,
which is a CFArray.

00:21:22.210 --> 00:21:24.120
So I can save this.

00:21:24.120 --> 00:21:28.630
Now the last thing that I have to do,
because we're,

00:21:28.630 --> 00:21:30.070
we have a custom attribute name, we

00:21:31.200 --> 00:21:50.000
[Transcript missing]

00:21:55.520 --> 00:22:03.880
So I need to call this com-- sorry,
I called it this.

00:22:03.880 --> 00:22:06.310
I copied this.

00:22:12.140 --> 00:22:15.790
This is where we actually
really say what it is.

00:22:15.790 --> 00:22:18.760
I'll talk about this again in a second.

00:22:18.940 --> 00:22:22.320
I'm just going to gloss
over this for a moment.

00:22:22.450 --> 00:22:24.490
That's all taken care of.

00:22:24.540 --> 00:22:25.510
Save that.

00:22:25.510 --> 00:22:29.020
We've saved this and
we're going to build it.

00:22:29.020 --> 00:22:32.720
If I didn't screw anything up, okay,
good job.

00:22:32.900 --> 00:22:33.850
It built.

00:22:34.570 --> 00:22:36.590
Now, what do we do with it?

00:22:36.750 --> 00:22:39.500
We have,
go into the source importer directory.

00:22:39.500 --> 00:22:44.160
If you look in the build directory,
there's a source importer.md importer.

00:22:44.160 --> 00:22:46.900
If I copy-r source importer.

00:22:51.140 --> 00:22:56.850
sourceimporter.mdimporter into
tilde slash library mdimporters.

00:22:56.880 --> 00:22:58.820
I'm just putting it in
my home directory here.

00:22:58.820 --> 00:23:00.420
I'll talk about where
else you can install it.

00:23:00.520 --> 00:23:01.810
I'm just putting it here for the second.

00:23:01.810 --> 00:23:03.650
We drop it in there.

00:23:03.660 --> 00:23:06.360
Basically,
that's all it took to install it.

00:23:06.800 --> 00:23:09.620
Now, we can run in developer tools.

00:23:09.650 --> 00:23:11.770
There's a program called mdimport.

00:23:11.810 --> 00:23:13.050
We do dash L.

00:23:13.050 --> 00:23:20.420
If we did everything properly,
it should show up in the list,

00:23:21.040 --> 00:23:22.830
which it did not.

00:23:22.880 --> 00:23:28.940
Okay, so I need to mdcheck schema.

00:23:34.450 --> 00:23:41.750
Check schema and that is on
schema.xml successfully parsed.

00:23:45.500 --> 00:23:46.580
Oh, that's right.

00:23:46.870 --> 00:23:47.240
Thank you.

00:23:47.400 --> 00:23:56.530
Yeah, so clearly I've used Unix
for only about six months.

00:23:57.520 --> 00:24:00.300
and of course being up
on stage helps a lot.

00:24:00.350 --> 00:24:01.840
Whoever said that,
I really appreciate it.

00:24:01.920 --> 00:24:04.900
I would have spent another
ten minutes realizing that.

00:24:04.900 --> 00:24:06.400
Okay.

00:24:06.400 --> 00:24:09.400
So now we will successfully
install it properly.

00:24:09.400 --> 00:24:14.210
And if we run developer
tools MD import -- ah,

00:24:14.210 --> 00:24:15.890
there we go.

00:24:15.890 --> 00:24:15.890
Beautiful.

00:24:20.100 --> 00:24:29.100
[Transcript missing]

00:24:31.740 --> 00:24:54.120
: I had a sample header
file in this test directory.

00:24:54.120 --> 00:24:54.120
If I run developer tools mdimport
again and with the -d3 option so it

00:24:54.120 --> 00:24:54.120
will print out loads of information,
I have this file myheader.h.

00:24:54.120 --> 00:24:54.120
First off, if I type -- let me just
go ahead and run it.

00:24:54.120 --> 00:24:54.120
What we can see happened here is

00:24:54.410 --> 00:24:58.480
It says importing data from file
and it tells me exactly what file,

00:24:58.480 --> 00:25:01.280
what type it thinks it is,
public C header,

00:25:01.760 --> 00:25:06.210
which is useful to see that it
matches what we defined ourselves as.

00:25:06.260 --> 00:25:09.300
And then we can see that, hey,
com.apple.source.typedefs,

00:25:09.310 --> 00:25:11.760
that's the name that we
defined for our attribute.

00:25:11.760 --> 00:25:16.390
And there's three typedefs, myinteger,
mybiginteger, and foostruct.

00:25:16.550 --> 00:25:20.170
And if we were to look at myheader.h,
we can see that there are three

00:25:20.410 --> 00:25:24.810
typedefs in here that were extracted
properly and published as header file.

00:25:24.820 --> 00:25:29.110
So this is a way that, you know,
we've just defined a new importer

00:25:29.450 --> 00:25:34.030
and installed it in the system and
successfully had it publish metadata,

00:25:34.070 --> 00:25:39.340
which, if we'd like to, go into Finder,
and if I say,

00:25:39.340 --> 00:25:46.390
what file defines mybiginteger,
we see that myheader.h shows up.

00:25:46.670 --> 00:25:49.950
So we're fully plugged into the system.

00:25:54.200 --> 00:26:02.300
[Transcript missing]

00:26:05.040 --> 00:26:06.500
So we wrote an importer.

00:26:06.500 --> 00:26:08.840
There's a couple of things
we still need to talk about,

00:26:08.840 --> 00:26:09.210
though.

00:26:09.390 --> 00:26:12.600
MD importers run in
several different contexts.

00:26:12.750 --> 00:26:15.700
So in the case that I showed there,
we ran MD import by

00:26:15.700 --> 00:26:16.900
hand on a single file.

00:26:16.900 --> 00:26:18.380
It ran, extracted the metadata.

00:26:18.380 --> 00:26:20.450
That's all very nice, well, and good.

00:26:20.850 --> 00:26:24.460
However, MD import can run in a couple
of different scenarios.

00:26:24.460 --> 00:26:27.350
For example,
if someone takes and plugs in a FireWire

00:26:27.350 --> 00:26:31.140
hard drive with 100,000 files on it,
we've got a lot of work to do,

00:26:31.140 --> 00:26:34.220
and so it can be part of a
slightly longer running process.

00:26:34.820 --> 00:26:36.220
This, of course, has implications.

00:26:36.220 --> 00:26:39.980
So when you run it once and it works,
you're all happy, that's great,

00:26:40.210 --> 00:26:42.520
and you don't notice
anything necessarily,

00:26:42.520 --> 00:26:44.780
because even if it goes and
allocates a lot of memory,

00:26:44.780 --> 00:26:46.560
you may not feel the impact.

00:26:46.700 --> 00:26:50.140
However, when it's running, excuse me,
as part of a longer-lived process,

00:26:50.140 --> 00:26:53.330
if it has leaks or trashes memory,
you're going to start

00:26:53.330 --> 00:26:54.960
to notice these things.

00:26:54.960 --> 00:26:56.110
So you need to be a good citizen.

00:26:56.230 --> 00:26:57.480
You need to pay attention to this.

00:26:57.560 --> 00:27:00.200
We're also taking
defensive measures as well.

00:27:00.200 --> 00:27:03.890
So if you're not a good citizen,
we'll make you be a good citizen.

00:27:04.580 --> 00:27:08.970
However, you want to avoid using a
lot of memory if you can.

00:27:08.980 --> 00:27:11.320
You have to pay attention
to things like leaks,

00:27:11.320 --> 00:27:12.780
and we have a lot of tools to do this.

00:27:12.980 --> 00:27:15.680
And you want to use some caution
when reading large files.

00:27:15.820 --> 00:27:18.910
So in some cases, like I said,
when you plug in a drive with

00:27:19.010 --> 00:27:21.840
a whole bunch of files on it,
you don't want to necessarily just

00:27:22.020 --> 00:27:25.770
read the file like you would normally,
because you can pollute the

00:27:25.770 --> 00:27:28.870
buffer cache of the computer,
which can cause a lot of

00:27:28.870 --> 00:27:31.900
unnecessary paging activity,
because in that scenario,

00:27:32.210 --> 00:27:34.220
data's not likely to be used again.

00:27:34.510 --> 00:27:36.950
So if you're running with
standard POSIX file descriptors,

00:27:36.960 --> 00:27:39.720
you can call the
F control for F no cache.

00:27:39.800 --> 00:27:43.620
And if the data is in the cache,
because it was a recently saved document,

00:27:43.620 --> 00:27:44.720
you'll get it from there.

00:27:44.720 --> 00:27:47.630
If it's not in the cache,
you won't waste time polluting

00:27:47.630 --> 00:27:49.810
the cache with data that you're
never going to read again.

00:27:49.820 --> 00:27:50.940
So that's always a win.

00:27:50.940 --> 00:27:53.700
If you're using Carbon,
you can use the no cache mask.

00:27:53.700 --> 00:27:55.970
If you're using Cocoa,
you can get it the raw file

00:27:56.090 --> 00:27:57.820
descriptor and call the F control.

00:27:59.600 --> 00:29:26.200
[Transcript missing]

00:29:26.830 --> 00:29:30.040
As you saw, I installed it into Tilda
Library MD Importers,

00:29:30.440 --> 00:29:33.880
which works pretty well for
initial testing and debugging,

00:29:33.880 --> 00:29:39.700
but most likely you would want to install
your importer into /library/mdimporters.

00:29:39.820 --> 00:29:45.160
For debugging, I used the mdimport-l,
which is a list of what

00:29:45.400 --> 00:29:47.620
importers are installed.

00:29:47.730 --> 00:29:49.660
That's a quick test to
see that it got there,

00:29:50.050 --> 00:29:52.690
which is where I had that
heart attack earlier.

00:29:52.700 --> 00:29:55.690
When you're testing it
to see what's happening,

00:29:55.690 --> 00:30:00.670
you can use mdimport with the -d option
to get different levels of debugging.

00:30:00.770 --> 00:30:02.690
-d4 is probably way too much.

00:30:02.700 --> 00:30:05.210
You can give it a path
to a hierarchy of files,

00:30:05.210 --> 00:30:07.590
or you can give it a
specific file as well.

00:30:07.700 --> 00:30:10.840
It's in developer tools,
and it's the way you

00:30:10.840 --> 00:30:12.700
would test things out.

00:30:15.060 --> 00:30:18.490
If you need to define new attributes,
and this is what I kind of glossed

00:30:18.490 --> 00:30:22.420
over in the code walkthrough,
there's a schema.xml file

00:30:22.570 --> 00:30:24.110
that's part of the project.

00:30:24.120 --> 00:30:27.340
And you can define new attributes
in a couple of different ways.

00:30:27.450 --> 00:30:29.520
So depending on what your needs are,
the first one,

00:30:29.520 --> 00:30:36.150
we have a string attribute,
which we define as a type of CFString,

00:30:36.320 --> 00:30:37.830
and we give it a name.

00:30:37.840 --> 00:30:39.780
You can have number, CFNumber.

00:30:40.380 --> 00:30:42.720
And the last one is kind
of an interesting one,

00:30:42.720 --> 00:30:45.160
and this is what I used
in the source importer.

00:30:45.160 --> 00:30:46.980
It's a multivalued string.

00:30:46.980 --> 00:30:51.060
What this means is you can
think of the attribute as an

00:30:51.070 --> 00:30:53.590
array of individual values.

00:30:53.600 --> 00:30:57.050
So foo, bar, blah,
those are all separate entities that

00:30:57.110 --> 00:30:59.400
are in an array for that attribute.

00:30:59.400 --> 00:31:03.160
Then you would localize,
or you can provide localization for your

00:31:03.160 --> 00:31:07.230
attribute with the schema.strings file,
which is again a standard convention.

00:31:07.340 --> 00:31:08.940
It's a UTF-16 file.

00:31:08.940 --> 00:31:09.810
And you map.

00:31:10.240 --> 00:31:13.480
You can also map what you wanted to call,
or what the name you gave it in the file,

00:31:13.480 --> 00:31:15.480
which is not something you
would display to the user.

00:31:15.690 --> 00:31:19.870
And then in my favorite language,
the only other language I know, Italian,

00:31:20.120 --> 00:31:21.500
what you would want it displayed as.

00:31:21.560 --> 00:31:24.760
And you can check this
with md_check_schema.

00:31:24.820 --> 00:31:30.090
You notice that we're using a kind
of funky naming convention here

00:31:30.090 --> 00:31:35.780
where the reverse DNS style naming,
but we have underbars instead of periods.

00:31:36.140 --> 00:31:38.620
That's because we wanted to
keep these attribute names

00:31:38.620 --> 00:31:40.100
compatible with the Cocoa key.

00:31:40.220 --> 00:31:43.060
So we have a little key value
coding scheme which doesn't

00:31:43.060 --> 00:31:44.830
allow for periods in the name.

00:31:44.860 --> 00:31:47.670
So that's why we did it that way.

00:31:48.570 --> 00:31:50.700
Apple has written a whole bunch, well,
a whole bunch,

00:31:50.730 --> 00:31:54.080
a couple of importers for the standard
file formats that we support natively,

00:31:54.080 --> 00:31:56.110
and you can expect us
to continue to do that.

00:31:56.180 --> 00:32:02.000
So things like JPEG, PNG, TIFF, so on,
we have that covered.

00:32:02.000 --> 00:32:04.680
QuickTime, of course,
you would expect that.

00:32:04.840 --> 00:32:05.380
PDF.

00:32:05.380 --> 00:32:10.420
And then things that the application
kit can open for text documents,

00:32:10.420 --> 00:32:13.200
which includes RTF and
RTFD and Word documents,

00:32:13.200 --> 00:32:15.490
we support that as well.

00:32:15.500 --> 00:32:17.510
So you don't have to do those.

00:32:18.220 --> 00:32:20.630
So in summary,
importers are pretty simple to write.

00:32:20.760 --> 00:32:21.800
There's not a lot to it.

00:32:21.950 --> 00:32:25.720
There's a bit of glue code
that you have to get together.

00:32:25.720 --> 00:32:26.940
We provide that in the template.

00:32:26.940 --> 00:32:30.920
It's a CF plug-in,
so it's not any great magic.

00:32:30.920 --> 00:32:33.570
It makes your documents easier to find.

00:32:33.590 --> 00:32:34.700
This is the connection.

00:32:34.730 --> 00:32:37.410
This whole system,
the whole Spotlight system lives and

00:32:37.410 --> 00:32:40.560
dies by the quality of the metadata
that's there and how easy it is

00:32:40.560 --> 00:32:42.260
for users to search for things.

00:32:42.300 --> 00:32:44.960
So it makes your
documents easier to find.

00:32:44.960 --> 00:32:47.590
It's in everybody's
best interest to do it.

00:32:47.820 --> 00:32:52.280
It handles full text indexing with
the KMDItemTextContent attribute.

00:32:52.280 --> 00:32:55.750
And it's the sort of thing you
could go home and write one tonight.

00:32:55.760 --> 00:33:00.070
So with that,
let's talk about queries and searching.

00:33:02.300 --> 00:33:03.030
Who needs queries?

00:33:03.030 --> 00:33:05.640
Well, not a lot of people, actually.

00:33:05.640 --> 00:33:09.450
There's not that many finder
applications that need to be written.

00:33:09.450 --> 00:33:14.310
But apps that have a custom UI where the
focus is working with groups of files,

00:33:14.310 --> 00:33:17.480
so take some of these things and
do some of this stuff over here,

00:33:17.500 --> 00:33:20.800
and that's the main focus of your
UI where you're not going through

00:33:20.800 --> 00:33:24.050
a traditional open save panel,
those are the kinds of things that

00:33:24.140 --> 00:33:26.420
would benefit from working with queries.

00:33:26.420 --> 00:33:32.170
So asset management, workflow,
or file type management applications.

00:33:32.200 --> 00:33:34.960
Even something like Soundtrack,
which you may not think

00:33:34.960 --> 00:33:36.790
of as working with files,
but in fact,

00:33:36.880 --> 00:33:40.030
I don't know if you're familiar
with the Soundtrack application,

00:33:40.030 --> 00:33:42.500
but you select different
sets of instruments and it

00:33:42.660 --> 00:33:44.040
issues queries to do this.

00:33:44.040 --> 00:33:48.160
This is something actually that could
take advantage of the Spotlight system

00:33:48.310 --> 00:33:52.700
to do queries on the attributes about
the instruments that it's searching for.

00:33:54.810 --> 00:33:57.750
Queries find items based
on their attributes.

00:33:57.850 --> 00:34:00.170
Attributes that you can search
on are the metadata that's

00:34:00.230 --> 00:34:03.770
published by the importers,
of course, file system attributes,

00:34:03.770 --> 00:34:05.420
that's what we've always
been able to search on,

00:34:05.420 --> 00:34:09.110
the file size, last modification time,
all those boring things that

00:34:09.280 --> 00:34:12.400
you don't really always think
about but are useful sometimes,

00:34:12.400 --> 00:34:14.260
and of course full text content.

00:34:15.200 --> 00:34:16.940
What does the query language look like?

00:34:17.050 --> 00:34:20.750
It's a simple C-like expression
with standard operators like equals,

00:34:20.750 --> 00:34:23.520
not equals, greater than,
what you would expect.

00:34:23.620 --> 00:34:25.300
You can have parentheses for grouping.

00:34:25.300 --> 00:34:27.880
So what does it look like
in an actual expression?

00:34:28.010 --> 00:34:31.640
They have two of them there,
kmd item keywords equals star foo star,

00:34:31.910 --> 00:34:34.350
and that's how you would
do a substring match.

00:34:34.380 --> 00:34:37.500
And then the bottom example
is slightly more complex.

00:34:37.500 --> 00:34:41.400
When I did the example of searching
for Frederic in the finder before,

00:34:41.400 --> 00:34:44.960
you noticed that it matched
because even though the accented,

00:34:45.200 --> 00:34:47.460
the characters,
the accented E and I hadn't

00:34:47.460 --> 00:34:49.470
typed an accented E,
it still matched.

00:34:49.700 --> 00:34:54.600
And what you see at the end here is,
whoops, I went too far.

00:34:56.640 --> 00:34:58.490
Okay.

00:34:58.520 --> 00:35:02.960
That little CD at the end stands for case
insensitive and diacritic insensitive.

00:35:02.990 --> 00:35:05.790
And because we have the
asterisks around both ends of it,

00:35:05.920 --> 00:35:08.720
it's a case and diacritic
insensitive substring match.

00:35:10.700 --> 00:35:12.000
Now, how do you write a query?

00:35:12.000 --> 00:35:14.380
There's three parts to it, really.

00:35:14.380 --> 00:35:19.290
You first create an MD query ref,
and you have the standard

00:35:19.290 --> 00:35:21.180
CFAllocator default.

00:35:21.180 --> 00:35:23.950
And the string you pass in
is the expression that we had

00:35:24.040 --> 00:35:25.700
just on the previous screen.

00:35:25.700 --> 00:35:29.870
In this case, we're saying KMDItemTitle
equals star tiger star,

00:35:29.990 --> 00:35:31.240
and we have the CD.

00:35:32.680 --> 00:35:35.940
And then we have some additional
options for grouping and sorting,

00:35:35.940 --> 00:35:39.560
which I showed in full search,
but we're not going to cover here today.

00:35:40.310 --> 00:35:41.280
We'll pass nulls for those.

00:35:41.330 --> 00:35:44.780
Then you start the query
running with MD query execute.

00:35:44.970 --> 00:35:48.270
And in this case,
we've specified that we want to have,

00:35:48.270 --> 00:35:50.860
want updates, which is a live query.

00:35:50.880 --> 00:35:53.450
If you just want to
issue a one-shot query,

00:35:53.450 --> 00:35:56.210
you pass zero, I believe,
for that argument,

00:35:56.340 --> 00:35:58.660
and then you don't get any updates.

00:35:58.710 --> 00:36:01.160
It just, that's the results,
that end of story.

00:36:01.820 --> 00:36:03.270
Then you read the results.

00:36:03.270 --> 00:36:06.440
When you get notifications
that there's results available,

00:36:06.550 --> 00:36:09.680
you get the result at query index I,
and there you have it.

00:36:09.700 --> 00:36:10.920
Thank you.

00:36:11.600 --> 00:36:13.540
Queries are designed to
work with CF run loops.

00:36:13.590 --> 00:36:15.860
So there's three phases, really.

00:36:15.860 --> 00:36:18.140
There's progress, okay,
you're getting results,

00:36:18.340 --> 00:36:20.100
things are coming in
from the initial set,

00:36:20.100 --> 00:36:21.220
we're going through.

00:36:21.220 --> 00:36:24.060
Then you get a finish
notification that says,

00:36:24.210 --> 00:36:26.270
okay, that's the initial set.

00:36:26.420 --> 00:36:29.780
If you selected for live queries,
then you'll start to get updates as

00:36:29.910 --> 00:36:31.870
things come and go from the query set.

00:36:31.940 --> 00:36:35.140
Now when you saw, like,
the liveness things, I did a query,

00:36:35.140 --> 00:36:37.580
nothing matched,
then something popped in,

00:36:37.580 --> 00:36:40.340
that's an update notification
coming in saying,

00:36:40.340 --> 00:36:41.480
hey, there's a new result.

00:36:41.500 --> 00:36:44.660
You have, like I mentioned,
one shot or live queries,

00:36:44.820 --> 00:36:47.740
and the sorting and grouping features,
which, again,

00:36:47.740 --> 00:36:50.720
unfortunately we're not going to cover
today because we will not have time.

00:36:50.720 --> 00:36:56.010
So if I can come back over here,
we're going to go through a little sample

00:36:56.460 --> 00:36:59.250
program that we have that does queries.

00:37:01.300 --> 00:37:03.800
I'm not going to write the code,
but we will go through it briefly

00:37:03.800 --> 00:37:05.930
to kind of see what it looks like.

00:37:06.020 --> 00:37:14.420
I have a little application that
looks like this guy right here.

00:37:14.420 --> 00:37:20.390
And there's a search field which is
hooked up to the code to a search now.

00:37:20.400 --> 00:37:25.590
So when I type in a string,
that gets plugged into

00:37:25.590 --> 00:37:30.880
this function here,
search now, in the code.

00:37:31.300 --> 00:37:33.810
Let me slow down a little bit.

00:37:34.160 --> 00:37:35.960
First thing we do is set
the title of the window,

00:37:35.960 --> 00:37:36.720
not very interesting.

00:37:36.720 --> 00:37:40.380
We create an NSString,
and this is a Coke application,

00:37:40.510 --> 00:37:45.700
and we do a star equals,
and then we put the

00:37:45.700 --> 00:37:48.830
string that they type,
that's the percent at that was

00:37:48.830 --> 00:37:52.630
typed into the search field,
and we put it in quotes and

00:37:52.630 --> 00:37:56.050
put it as a substring match
with the stars on either end,

00:37:56.230 --> 00:37:58.670
and we say CD for case and
diacritic and sensitive.

00:37:58.700 --> 00:38:06.480
Then we pass that on to start query,
which is another method down below,

00:38:06.480 --> 00:38:08.650
and that's right here.

00:38:09.140 --> 00:38:13.000
Here we take -- we add notifications.

00:38:13.000 --> 00:38:15.920
This is the very first
query that we've run.

00:38:15.920 --> 00:38:19.090
We add some notification
observers for progress,

00:38:19.150 --> 00:38:20.800
finish, and update.

00:38:21.010 --> 00:38:26.720
Then we call MD query execute just
like I mentioned on the slides earlier.

00:38:26.790 --> 00:38:31.510
Now, when we run this program,
let's go ahead and build it and run it.

00:38:32.220 --> 00:38:35.500
Here's what it looks like,
and if I type HTML,

00:38:35.500 --> 00:38:39.900
we'll get the same results we'd get
in any of the other applications,

00:38:39.960 --> 00:38:41.820
and we have 779 results.

00:38:42.260 --> 00:38:45.120
All right, pretty straightforward.

00:38:45.120 --> 00:38:48.060
Where did that all come from?

00:38:48.060 --> 00:38:51.570
When we got updates,
we asked the TableView to

00:38:51.570 --> 00:38:55.520
reload its data,
and I'm going to talk about that,

00:38:55.680 --> 00:39:01.130
how we actually display the data
later on in the last bit of this talk.

00:39:01.200 --> 00:39:07.490
And when we get the done notifications,
we don't have to actually do anything,

00:39:07.490 --> 00:39:09.930
we just note that it's done.

00:39:09.940 --> 00:39:14.280
And... Uh... That's
basically all there is to it,

00:39:14.430 --> 00:39:15.560
to issuing a query.

00:39:15.560 --> 00:39:20.320
That you... When you get updates,
you tell yourself to process them,

00:39:20.320 --> 00:39:22.560
and in this case, like I said,
we just asked the

00:39:22.640 --> 00:39:25.350
TableView to reload the data,
which is where we actually

00:39:25.510 --> 00:39:26.460
go and display it.

00:39:26.550 --> 00:39:29.810
And that's... That's that.

00:39:33.990 --> 00:39:37.540
So, I'll actually, I'll leave that,
I'll bring that back 'cause

00:39:37.540 --> 00:39:39.870
I'm gonna need it next.

00:39:40.200 --> 00:39:40.740
If we can go back to the slides,
actually.

00:39:42.620 --> 00:39:47.340
So really,
few apps need to perform queries.

00:39:47.340 --> 00:39:50.110
If you need to do it, it's not that hard,
but it's not the sort of

00:39:50.220 --> 00:39:51.360
thing that you have to think,
oh,

00:39:51.360 --> 00:39:53.240
what do I have to do to adopt Spotlight?

00:39:53.240 --> 00:39:54.360
I need to do this.

00:39:54.510 --> 00:39:56.200
Not everybody needs to.

00:39:56.200 --> 00:39:57.460
It's great if you do.

00:39:57.460 --> 00:39:59.940
It's not very hard,
but if it's appropriate

00:39:59.940 --> 00:40:01.460
for your application.

00:40:02.200 --> 00:40:06.050
Queries are C-like expressions about
the attributes that you want to search.

00:40:06.130 --> 00:40:09.660
So you saw we had some very simple
expressions with standard equals.

00:40:09.860 --> 00:40:13.460
You can build much more complex
ones with parentheses for grouping.

00:40:13.460 --> 00:40:17.110
So you can do ors and
ands and so on to build.

00:40:17.490 --> 00:40:22.470
Date is modified between this date
and it's less than this other date,

00:40:22.470 --> 00:40:25.160
or it's in this other date range.

00:40:25.220 --> 00:40:28.180
I mean, you can build some fairly
sophisticated things if you'd like.

00:40:28.260 --> 00:40:31.000
It's well integrated with CF run loops.

00:40:31.070 --> 00:40:32.060
It would be kind of a pain.

00:40:32.080 --> 00:40:34.780
If this was bolted on the side,
you had to jump through hoops

00:40:34.780 --> 00:40:37.450
and do contortions to make it
work with your application.

00:40:37.580 --> 00:40:40.270
But, you know,
we've worked very closely with the

00:40:40.270 --> 00:40:43.620
Finder team to meet their needs
and other applications like the

00:40:43.620 --> 00:40:45.860
Bullsearch demo or that AskMac demo.

00:40:45.860 --> 00:40:49.680
So we kind of understand how it
should be integrated properly.

00:40:49.680 --> 00:40:52.310
There's options for doing live queries.

00:40:52.310 --> 00:40:56.890
So if you want to continue to receive
updates and notifications on the fly,

00:40:56.890 --> 00:40:58.170
we support that.

00:40:58.390 --> 00:41:01.430
And as I mentioned or alluded to
and sort of demoed with Bullsearch,

00:41:01.610 --> 00:41:02.050
there's sorting.

00:41:02.080 --> 00:41:04.930
And grouping features,
which can provide you with some pretty

00:41:04.980 --> 00:41:07.060
advanced functionality if you require it.

00:41:08.960 --> 00:41:10.220
Now, displaying metadata.

00:41:10.250 --> 00:41:14.750
As you saw when I ran Ask Mac,
it displayed some information

00:41:14.800 --> 00:41:18.800
about the files in that it
was displaying the names,

00:41:18.800 --> 00:41:21.140
but it got that through
the Spotlight system.

00:41:21.140 --> 00:41:25.980
It's pretty straightforward
to display metadata.

00:41:25.980 --> 00:41:27.860
You have to have an item reference.

00:41:27.860 --> 00:41:30.300
You can get an item
reference in one of two ways.

00:41:30.310 --> 00:41:33.620
You can either first get it
as a result from a query,

00:41:33.620 --> 00:41:37.460
or you can create it
for an explicit path.

00:41:37.560 --> 00:41:40.530
So if you know the path
through some other mechanism,

00:41:40.540 --> 00:41:44.750
it was something returned to you via a
file open save panel or what have you,

00:41:44.830 --> 00:41:47.320
you can just explicitly create the item.

00:41:47.580 --> 00:41:51.340
Once you have the item reference,
then you can get a list of

00:41:51.450 --> 00:41:56.240
attribute names about the item,
a dictionary, an array, I'm sorry,

00:41:56.280 --> 00:42:00.070
of the names of attributes
that exist for that item.

00:42:00.080 --> 00:42:03.300
So if you don't know anything
about it and you want to display

00:42:03.300 --> 00:42:06.110
arbitrarily what's there,
you can get that list.

00:42:06.640 --> 00:42:09.410
And then go through and
get the actual values.

00:42:09.430 --> 00:42:13.450
Or if you know exactly what you want,
you can use the MD item copy

00:42:13.450 --> 00:42:15.460
attribute family of calls.

00:42:15.680 --> 00:42:19.480
And I say it's a family because there
are different variants depending

00:42:19.540 --> 00:42:21.660
on whether you want to get one,
a few,

00:42:21.790 --> 00:42:24.070
or all of the attributes for an item.

00:42:24.080 --> 00:42:26.130
And then you can use that information.

00:42:26.200 --> 00:42:28.050
And we all work with standard CF types.

00:42:28.140 --> 00:42:33.280
So if you have a multivalued string,
you'll get back a CFArray with all of

00:42:33.280 --> 00:42:36.070
the values for that attribute name.

00:42:36.480 --> 00:42:38.780
So in the case of going
back to the source importer,

00:42:38.920 --> 00:42:43.030
if I asked for,
if I call MD item copy attribute

00:42:43.030 --> 00:42:48.640
for this specific attribute,
com, apple, source, type defs,

00:42:48.820 --> 00:42:53.020
I would get back a CFArray that
contains the names or the

00:42:53.500 --> 00:42:55.990
values for that attribute name.

00:42:56.000 --> 00:42:58.560
Of course,
if the attribute doesn't exist,

00:42:58.560 --> 00:43:01.580
you'll get a null,
so you need to be aware of that.

00:43:01.720 --> 00:43:04.380
You want to use the one
that's most appropriate.

00:43:04.380 --> 00:43:06.370
Of course, bulkier calls.

00:43:06.450 --> 00:43:08.520
They're better in the sense
that if you're going to get five

00:43:08.700 --> 00:43:11.250
attributes and you know you're
always going to get five attributes,

00:43:11.300 --> 00:43:15.900
build a CFArray with those five attribute
names and get all five of them at once.

00:43:15.920 --> 00:43:17.760
Sort of standard best practices.

00:43:17.760 --> 00:43:20.750
That way you avoid round trips
back and forth to the server.

00:43:22.410 --> 00:43:27.730
So let's show you how we display
metadata back in the Ask Mac application.

00:43:30.670 --> 00:43:34.840
So going back down to that
mysterious function that I alluded

00:43:34.840 --> 00:43:38.080
to about reloading the data.

00:43:41.000 --> 00:43:45.900
Here we have the table view,
object for table column.

00:43:45.920 --> 00:43:49.920
And in this case,
you see we come in and we

00:43:49.920 --> 00:43:54.720
take the identity field of the

00:43:55.000 --> 00:45:20.300
[Transcript missing]

00:45:23.800 --> 00:45:24.520
Can we go back to the slides?

00:45:24.620 --> 00:45:25.060
No, thanks.

00:45:25.060 --> 00:45:26.180
Okay.

00:45:26.180 --> 00:45:30.340
So in summary,
items consist of a list of attributes.

00:45:30.340 --> 00:45:34.700
Items are the representation of
a file in the Spotlight system,

00:45:34.700 --> 00:45:39.520
and it's a list of attributes,
and attributes are name, type, and value.

00:45:39.520 --> 00:45:41.910
You can get a list of all
the attributes for an item.

00:45:41.920 --> 00:45:44.140
So if you know nothing at all
about it and you want to find

00:45:44.310 --> 00:45:47.100
out everything that's there,
you can get the full list of names,

00:45:47.100 --> 00:45:51.280
and then you can go through and
retrieve the actual values for each one.

00:45:52.240 --> 00:45:57.050
You can call... There's calls in the
MD item copy attribute family for one,

00:45:57.050 --> 00:46:00.380
some, or all of the attributes that
are associated with the file,

00:46:00.380 --> 00:46:04.090
and you want to use the
bulk calls when possible.

00:46:04.100 --> 00:46:06.930
One item that I should... Or one
attribute that I should mention that

00:46:07.210 --> 00:46:09.750
is special is KMDItemTextContent.

00:46:09.780 --> 00:46:12.790
You can't retrieve that in
the sense of give me the text

00:46:12.830 --> 00:46:14.320
content for this document.

00:46:14.340 --> 00:46:17.380
It doesn't work that way,
just so that you're aware of it.

00:46:19.400 --> 00:46:24.960
Now, we've talked a bit about the CDAPI,
and there's also a Cocoa API that

00:46:25.090 --> 00:46:27.550
I'd like to mention,
although we're not going to go

00:46:27.560 --> 00:46:28.740
into any code samples for it.

00:46:28.890 --> 00:46:32.430
As you might expect,
the lower-level core services API is

00:46:32.580 --> 00:46:35.280
very straightforward and procedural.

00:46:35.280 --> 00:46:39.540
There's the Cocoa API,
which is based on NSMetadataQuery,

00:46:39.540 --> 00:46:43.300
and as expected,
is higher-level object-oriented.

00:46:43.300 --> 00:46:45.090
It manages queries and results.

00:46:46.320 --> 00:46:50.140
Use the NSPredicate class,
which it should have in blue, but anyway,

00:46:50.140 --> 00:46:54.260
to populate or to initialize
an NSMetadataQuery.

00:46:54.260 --> 00:46:59.760
NSPredicate is an expression about
the attributes that you want to find,

00:46:59.760 --> 00:47:04.830
and that's how you would build
the expression as opposed to just

00:47:04.940 --> 00:47:06.440
using a straightforward string.

00:47:06.440 --> 00:47:09.980
NSMetadataQuery also
offers a grouping feature,

00:47:09.980 --> 00:47:13.900
and it's key-value coding
and observing compatible,

00:47:13.900 --> 00:47:16.230
so you can hook things up
to NSArray and NSPredicate.

00:47:16.240 --> 00:47:22.090
You can also use NSTreeControllers for
automatic connections between queries,

00:47:22.530 --> 00:47:24.990
their results, and their display.

00:47:27.770 --> 00:47:30.670
Another factor that I'd like to
talk about is full text indexing.

00:47:30.680 --> 00:47:34.420
I've mentioned it a few times
throughout the presentation that

00:47:34.610 --> 00:47:37.400
Spotlight uses full text indexing.

00:47:37.400 --> 00:47:42.570
The search kit has undergone some
dramatic improvements for Tiger.

00:47:42.600 --> 00:47:46.140
Content indexing is considerably faster.

00:47:46.140 --> 00:47:48.390
Incremental search,
which is something that

00:47:48.400 --> 00:47:51.300
wasn't really doable before,
is up to 20x faster.

00:47:51.300 --> 00:47:53.890
So you don't have to wait for
all the results to be relevance

00:47:53.890 --> 00:47:55.410
ranked before you get results.

00:47:55.590 --> 00:47:57.580
We can start getting results on the fly.

00:47:57.600 --> 00:48:00.700
Which kind of gives you that
find as you type functionality.

00:48:00.740 --> 00:48:04.110
And when you do want relevance ranking,
they've improved the

00:48:04.110 --> 00:48:06.030
relevance ranking quite a bit.

00:48:06.230 --> 00:48:07.660
Now why am I mentioning this?

00:48:07.750 --> 00:48:11.590
In some cases it's appropriate
to use the search kit directly

00:48:11.590 --> 00:48:14.860
for your own private index,
such as the help content

00:48:14.910 --> 00:48:16.910
or the Xcode documentation.

00:48:16.990 --> 00:48:21.410
These are things that are
sort of more appropriate to

00:48:21.410 --> 00:48:24.210
private or app specific index.

00:48:24.280 --> 00:48:27.320
And the search kit APIs which
were made public in Panther.

00:48:27.800 --> 00:48:33.830
And have been enhanced in Tiger are there
for you to use and fully documented.

00:48:35.910 --> 00:48:37.130
What's the current state of things?

00:48:37.140 --> 00:48:41.370
So obviously this is not a final release,
so we're not done yet.

00:48:41.390 --> 00:48:43.900
There's going to be issues and
things that you'll run into.

00:48:43.900 --> 00:48:48.530
There's some limits on attribute
size that we've kind of self-imposed.

00:48:48.800 --> 00:48:54.680
We're sort of proceeding very cautiously
with this whole project because this is

00:48:54.680 --> 00:48:57.710
sort of new territory in a lot of ways.

00:48:57.820 --> 00:49:01.040
I mean, I know some of these
things have existed before,

00:49:01.040 --> 00:49:05.760
but we don't want to put ourselves into a
situation where we wind up with something

00:49:05.760 --> 00:49:07.380
that's not sustainable in the future.

00:49:07.380 --> 00:49:12.620
So we're kind of defining
a fairly tight envelope,

00:49:12.620 --> 00:49:15.040
and then where we bump into it,
we look at it.

00:49:15.200 --> 00:49:17.260
Well,
why did we bump into that limit there?

00:49:17.260 --> 00:49:20.320
Is this the right place to expand things,
to push the boundary?

00:49:20.320 --> 00:49:22.470
And when appropriate, yeah,
we'll push it.

00:49:22.520 --> 00:49:24.990
So like I said,
there are some limits on the attribute

00:49:25.120 --> 00:49:26.330
size and number of attributes.

00:49:26.480 --> 00:49:27.750
When you run into these, talk to us.

00:49:27.870 --> 00:49:29.660
Let us know what it is
that you're trying to do.

00:49:29.660 --> 00:49:31.030
Why is it not working?

00:49:31.040 --> 00:49:33.290
Sometimes it's the right
thing to increase the limits,

00:49:33.420 --> 00:49:37.620
and sometimes it's like, no,
maybe that is an indication that things

00:49:37.620 --> 00:49:39.270
should be done in a different way.

00:49:39.280 --> 00:49:41.600
We need your feedback.

00:49:41.600 --> 00:49:44.100
Like I said,
this is kind of new territory for

00:49:44.100 --> 00:49:48.430
it to be in such a broadly available
general-purpose operating system,

00:49:48.440 --> 00:49:51.580
you know, these kind of metadata
functionality and so on.

00:49:51.720 --> 00:49:54.060
So we want to hear what
people are looking for,

00:49:54.060 --> 00:49:56.660
what they need, what they're missing,
what doesn't work for them with

00:49:56.770 --> 00:49:59.770
what we have today so that we
can build the system better,

00:49:59.780 --> 00:50:02.410
expand the system to meet those needs.

00:50:04.070 --> 00:50:06.580
So summarizing what
we've talked about today,

00:50:06.580 --> 00:50:10.420
importers are the main connection
from your application file

00:50:10.580 --> 00:50:13.420
format to the Spotlight system.

00:50:13.420 --> 00:50:16.230
So importers publish metadata from files.

00:50:16.300 --> 00:50:21.760
Spotlight takes that metadata and makes
the documents easier to find and allows

00:50:21.760 --> 00:50:24.760
them to be displayed more richly.

00:50:24.760 --> 00:50:29.250
Spotlight also allows applications to
interact in more sophisticated ways.

00:50:29.280 --> 00:50:32.160
So as I mentioned before,
you don't have N applications

00:50:32.280 --> 00:50:35.850
that have to know about M other
applications and all their file formats.

00:50:35.920 --> 00:50:39.320
They can just sort of ask for
the attributes about the file.

00:50:39.320 --> 00:50:42.950
They don't have to bother going to parse
it because the data has been published.

00:50:45.260 --> 00:50:45.920
What do you need to do?

00:50:45.920 --> 00:50:47.310
What is the end result of this?

00:50:47.380 --> 00:50:49.880
If you have a custom file format,
write an importer.

00:50:49.880 --> 00:50:51.770
That's the biggest thing,
that's the biggest favor

00:50:51.770 --> 00:50:54.350
you can do for your users,
for us, and for yourself.

00:50:54.360 --> 00:50:56.650
Put useful metadata in your documents.

00:50:56.660 --> 00:51:00.700
So a lot of file formats already have
support for various types of metadata,

00:51:00.700 --> 00:51:03.170
like I showed with Word,
there's that property sheet.

00:51:03.330 --> 00:51:06.920
Make sure to populate that where you
can with things that are interesting,

00:51:06.920 --> 00:51:10.360
things that would help the user
find that document later on.

00:51:10.420 --> 00:51:14.210
And when you're doing things,
if you're doing special things,

00:51:15.020 --> 00:51:18.660
manipulating a document and copying it,
or doing a save as,

00:51:19.020 --> 00:51:21.820
preserve the metadata where possible,
or when appropriate.

00:51:21.820 --> 00:51:24.260
So if there's an exif
chunk in a JPEG file,

00:51:24.260 --> 00:51:26.420
and it makes sense,
and you haven't completely

00:51:26.420 --> 00:51:29.200
modified the document so that
it no longer makes sense,

00:51:29.570 --> 00:51:33.150
preserve that, copy it,
as part of the file format.

00:51:33.180 --> 00:51:34.840
So,

00:51:36.520 --> 00:51:38.620
Now,
where can you find out more about this?

00:51:38.780 --> 00:51:40.960
Because I've gone through
this pretty quickly and,

00:51:40.960 --> 00:51:43.320
you know,
it's not like you're going to necessarily

00:51:43.320 --> 00:51:45.160
have everything in your head right now.

00:51:45.200 --> 00:51:50.430
There's a whole bunch of example
code and documentation online as

00:51:50.430 --> 00:51:56.360
well as some updates to what's
online and that disk image is where?

00:51:58.160 --> 00:51:59.370
Connect.apple.com.

00:51:59.500 --> 00:52:04.330
Okay, so there's an additional disk image
of documentation on connect.apple.com.

00:52:04.340 --> 00:52:07.960
So here we have...

00:52:09.330 --> 00:52:14.850
The different Spotlight importers,
where you would find that documentation,

00:52:14.850 --> 00:52:16.210
the MD importer reference.

00:52:16.300 --> 00:52:19.920
The template that's there
pretty much describes it all,

00:52:20.050 --> 00:52:22.760
so there's not too,
too much that you have to worry about.

00:52:22.860 --> 00:52:25.360
Oops, put that in the right place.

00:52:25.480 --> 00:52:30.320
MD item, to find out how you
would manipulate that,

00:52:30.320 --> 00:52:32.920
what the functions of that class are,
not class,

00:52:33.030 --> 00:52:37.660
but what the family of calls are,
how you would make use of them.

00:52:38.180 --> 00:52:41.810
query reference, schemas, and so on.

00:52:42.600 --> 00:52:49.100
[Transcript missing]
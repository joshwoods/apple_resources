WEBVTT

00:00:17.380 --> 00:00:18.180
Good morning.

00:00:18.450 --> 00:00:23.740
This is the Service Management for
Mac OS X talk or as I like to call it,

00:00:23.740 --> 00:00:29.250
writing modern daemons in Mac OS X.

00:00:29.710 --> 00:00:29.710
So what does that mean?

00:00:29.950 --> 00:00:31.660
Let's jump into some terminology.

00:00:31.720 --> 00:00:32.990
What is a daemon?

00:00:33.060 --> 00:00:35.960
A daemon is a long running
background process.

00:00:36.220 --> 00:00:37.620
People don't tend to see it.

00:00:37.640 --> 00:00:42.950
It's not in their immediate
view like the finder or Safari.

00:00:43.380 --> 00:00:45.900
Well,
we don't just have daemon on the system.

00:00:45.900 --> 00:00:48.160
We have super daemon, too.

00:00:48.160 --> 00:00:49.230
What is a super daemon?

00:00:49.540 --> 00:00:53.650
A super daemon is a daemon that
proxies work on behalf of other

00:00:53.720 --> 00:00:56.430
daemons to make their lives easier.

00:00:56.530 --> 00:01:00.930
We also have a notion of an agent,
which is more specifically a daemon

00:01:00.930 --> 00:01:03.280
that runs in the context of a user.

00:01:03.320 --> 00:01:08.910
After you log in,
something like the iChat agent might

00:01:08.910 --> 00:01:09.280
run in the background to help iChat out.

00:01:09.450 --> 00:01:12.300
Finally, something that's very important
for this talk is the notion

00:01:12.420 --> 00:01:13.640
of a communication handle.

00:01:13.640 --> 00:01:15.300
We talk about this a lot.

00:01:15.480 --> 00:01:18.830
Communication handles a file
descriptor or a Mach port,

00:01:18.830 --> 00:01:21.970
something you use to
talk to somebody else,

00:01:22.120 --> 00:01:23.600
be it near or far.

00:01:24.450 --> 00:01:28.040
also some assumptions I'd really
like to assume that most of

00:01:28.160 --> 00:01:32.440
you have prior experience in
writing a Mach or Unix daemon.

00:01:32.480 --> 00:01:37.630
Also some familiarity with the Mach or
Unix system calls to be very helpful.

00:01:37.640 --> 00:01:39.440
Let's jump right in.

00:01:40.510 --> 00:01:41.540
So what is this session about?

00:01:41.540 --> 00:01:43.360
It's all about background processes.

00:01:43.390 --> 00:01:47.170
You do work on behalf of
a user either directly,

00:01:47.280 --> 00:01:50.570
let's say like someone telnet's in,
the telnet server's launched,

00:01:50.690 --> 00:01:51.620
or indirectly.

00:01:51.850 --> 00:01:57.720
A thing like lookupd which is doing
queries on behalf of applications to look

00:01:57.720 --> 00:02:00.990
up users or internet hosts or whatnot.

00:02:01.000 --> 00:02:05.050
And finally, your code needs to get
running at some point.

00:02:05.190 --> 00:02:06.540
You have work to do.

00:02:06.540 --> 00:02:09.510
How do we know when to run you,
if at all?

00:02:10.440 --> 00:02:13.460
Now, what's wrong with the status quo?

00:02:13.510 --> 00:02:17.900
I believe and we believe that
daemons deserve better treatment.

00:02:17.900 --> 00:02:21.990
In both the UNIX and Mac OS world,
daemons were just processes which

00:02:22.010 --> 00:02:24.340
disassociated themselves from the user.

00:02:24.820 --> 00:02:27.540
They might say core graphics, nope,
don't need you.

00:02:27.690 --> 00:02:32.430
They'd call functions to remove
yourself from the user's context.

00:02:33.110 --> 00:02:35.920
In the Mac OS 9 world,
we call these faceless

00:02:35.920 --> 00:02:37.050
background applications.

00:02:37.120 --> 00:02:39.350
Again,
they were just programs which said, nope,

00:02:39.540 --> 00:02:40.180
don't need this.

00:02:40.410 --> 00:02:41.500
Don't need that.

00:02:41.610 --> 00:02:44.560
Oh, yeah,
don't need this subsystem over there.

00:02:44.560 --> 00:02:47.400
That's not the way to go.

00:02:47.400 --> 00:02:48.270
The solution?

00:02:48.330 --> 00:02:53.280
We're going to provide a new super daemon
to manage all the daemons on the system.

00:02:53.310 --> 00:02:54.920
It's designed to do work for you.

00:02:54.920 --> 00:02:57.180
It's designed to be flexible.

00:02:57.200 --> 00:03:00.190
It's designed to support
messaging and control.

00:03:00.190 --> 00:03:03.070
And finally,
we're going to call it LaunchD.

00:03:04.380 --> 00:03:08.760
A major component of this since we
want all daemon to be used this is

00:03:08.760 --> 00:03:11.200
that LaunchD will be open source.

00:03:11.340 --> 00:03:13.460
This is a critical objective of ours.

00:03:13.860 --> 00:03:16.200
We want Unix daemon to
adopt this technology.

00:03:16.310 --> 00:03:19.830
Things like Apache and
Bind and you name it.

00:03:19.980 --> 00:03:22.300
Any Unix daemon we'd like
to adopt this technology.

00:03:22.300 --> 00:03:24.660
We want to have it be open source.

00:03:24.660 --> 00:03:29.070
We want to have it run on FreeBSD and
Linux and Solaris and all those Unixes.

00:03:29.070 --> 00:03:32.900
It's in everybody's best interest.

00:03:33.430 --> 00:03:35.900
So what are you going to
learn in this session?

00:03:36.100 --> 00:03:41.300
The issues a modern daemon writer faces,
things that affect you as a developer,

00:03:41.430 --> 00:03:45.260
what LaunchD will provide for you,
what it won't provide for you,

00:03:45.310 --> 00:03:48.640
and how to port an
existing daemon to LaunchD.

00:03:48.640 --> 00:03:53.520
Also, I'll talk briefly about how
to write a savvy daemon.

00:03:54.000 --> 00:03:57.060
So let's talk about some history.

00:03:57.060 --> 00:03:59.360
Why do we need to write a new daemon?

00:03:59.560 --> 00:04:05.840
Well, in the Unix world,
the classic super daemon is INEDD.

00:04:05.880 --> 00:04:09.040
INEDD is responsible for
things like running the Telnet

00:04:09.040 --> 00:04:11.440
server or the FTP server,
you name it.

00:04:11.600 --> 00:04:13.100
Well, why was it created?

00:04:13.100 --> 00:04:17.070
It was created because there was the
observation was made that every daemon

00:04:17.070 --> 00:04:19.070
bit did basically the same thing.

00:04:19.070 --> 00:04:24.080
It opened a socket and sat there waiting
on accept and then forked a child and

00:04:24.080 --> 00:04:25.900
then had the child deal with the client.

00:04:25.900 --> 00:04:28.140
Well,
if they're all doing the same thing,

00:04:28.140 --> 00:04:31.380
we can have one daemon do that
for them and not have 20 daemons

00:04:31.380 --> 00:04:33.190
all running at the same time.

00:04:33.410 --> 00:04:37.000
Now, in hindsight, INetD was IP-centric.

00:04:37.000 --> 00:04:40.640
It also assumed that there was only
one communication handle per daemon.

00:04:40.770 --> 00:04:45.810
This is definitely not true these days
with the invention of things like SSL.

00:04:46.270 --> 00:04:50.200
Almost every daemon these days is
listening on at least two ports,

00:04:50.290 --> 00:04:53.970
one to handle SSL traffic,
one to handle non-SSL traffic.

00:04:54.330 --> 00:04:57.200
Also, in the UNIX world we had
something called a NIT.

00:04:57.210 --> 00:04:59.440
A NIT was centric to a
different kind of technology.

00:04:59.440 --> 00:05:02.960
It was centric to TTYs,
things like the console login

00:05:02.970 --> 00:05:07.200
session or a login session running
on a serial port off on the side.

00:05:07.200 --> 00:05:10.730
That was all fine and dandy,
but it was only specific

00:05:10.730 --> 00:05:13.160
towards a specific technology.

00:05:14.440 --> 00:05:16.780
Also,
to handle different kinds of daemons we

00:05:16.780 --> 00:05:19.200
had this callout starting from ETSI RC.

00:05:19.200 --> 00:05:23.200
When the system booted we
had a shell script run.

00:05:23.200 --> 00:05:25.440
It would then in turn run other things.

00:05:25.440 --> 00:05:31.200
Eventually a script of yours would be run
that would let your daemon be launched.

00:05:31.370 --> 00:05:35.200
Well, this is very, very static.

00:05:35.200 --> 00:05:37.060
This only happens at boot.

00:05:37.060 --> 00:05:40.200
There's no notion of
the world might change.

00:05:40.200 --> 00:05:41.190
We turn the system off.

00:05:41.200 --> 00:05:43.200
I mean,
we put it to sleep and woke it back up.

00:05:43.460 --> 00:05:46.710
It would be up somewhere else.

00:05:46.710 --> 00:05:52.240
And it also didn't deal
with shutdown very well.

00:05:52.620 --> 00:05:56.270
Finally, they also had cron, at,
and batch.

00:05:56.580 --> 00:05:57.270
They were time-centric.

00:05:57.400 --> 00:05:59.920
That's great, but maybe you want to run
for a different reason.

00:05:59.920 --> 00:06:03.620
Maybe you want to be like
sendmail and run once an hour

00:06:03.620 --> 00:06:08.190
to deal with spooled mail,
but you also want to deal with

00:06:08.280 --> 00:06:10.990
incoming connections on port 25.

00:06:12.680 --> 00:06:14.930
In the Mach world,
they had something similar

00:06:14.930 --> 00:06:16.560
to INDD called Mockinit.

00:06:16.640 --> 00:06:20.790
Mockinit can launch daemons on
demand based on Mach port IPC.

00:06:21.120 --> 00:06:23.200
That's great,
but it's only for Mach ports.

00:06:23.320 --> 00:06:24.500
What about file descriptors?

00:06:24.500 --> 00:06:26.610
Maybe you need both.

00:06:26.990 --> 00:06:30.260
So that brings us to today's problems.

00:06:30.260 --> 00:06:31.560
There's missing functionality.

00:06:31.620 --> 00:06:33.990
First of all,
INED doesn't handle Unix domain sockets

00:06:34.000 --> 00:06:36.660
despite them being file descriptors.

00:06:36.660 --> 00:06:40.030
We have file system events
to trigger a daemon launch.

00:06:40.130 --> 00:06:47.030
Maybe your daemon just sits waiting
for a mail spool to fill up and

00:06:47.030 --> 00:06:48.890
then try and drain it periodically.

00:06:48.960 --> 00:06:53.020
Well, we'd like to be able to run
your daemon when that spool

00:06:53.020 --> 00:06:55.900
directory gets files in it.

00:06:56.130 --> 00:07:00.480
Also, INED and INID don't
support user-supplied jobs.

00:07:00.730 --> 00:07:04.890
Why can't a normal user just
submit a job to INED saying,

00:07:04.990 --> 00:07:09.310
"Hey,
when somebody connects to port 54321,

00:07:09.310 --> 00:07:14.060
run my little custom daemon."
You can't do that today.

00:07:14.460 --> 00:07:18.680
because the config file is in /etc
and only root can write to that file.

00:07:18.720 --> 00:07:20.620
That's a shame.

00:07:20.620 --> 00:07:24.480
Also multiple event sources,
like we talked about with inetd,

00:07:24.480 --> 00:07:27.750
it only allows you to have
one communication port.

00:07:27.750 --> 00:07:30.240
That's just not practical these days.

00:07:30.240 --> 00:07:34.980
Worse still, some daemons listen on both
Mach and Unix file descriptors.

00:07:34.980 --> 00:07:39.080
Something like the multicast
DNS responders listening on a Mach port

00:07:39.080 --> 00:07:42.960
to handle requests from the GUI apps,
but also listening on a file descriptor

00:07:42.960 --> 00:07:44.730
to handle the network events.

00:07:44.970 --> 00:07:47.500
There's no reason why we can't
launch that daemon on demand today

00:07:47.550 --> 00:07:52.920
except that our super daemons
only support one technology.

00:07:53.130 --> 00:07:58.100
Ultimately, we believe that time,
file system, IPC events,

00:07:58.200 --> 00:08:02.340
all these various event sources need to
be supported in the same super daemon.

00:08:02.490 --> 00:08:07.360
We need to be able to launch it on demand
whenever any of your events happen.

00:08:07.860 --> 00:08:11.880
: Also, a critical request by many people
is that their daemon automatically

00:08:11.880 --> 00:08:17.030
be restarted if they inadvertently
exit or die for whatever reason.

00:08:17.140 --> 00:08:20.210
So that's something else we'd
like to support that not all

00:08:20.210 --> 00:08:22.320
the super daemons support.

00:08:22.680 --> 00:08:23.280
So the future.

00:08:23.450 --> 00:08:26.380
We're going to have one
daemon to rule them all.

00:08:26.400 --> 00:08:30.500
It's support for transferable-based
event sources at the moment.

00:08:30.530 --> 00:08:32.150
We support most file descriptors.

00:08:32.250 --> 00:08:36.120
And we will support Mach ports.

00:08:36.150 --> 00:08:41.320
Also, support for user supplied jobs is,
we believe, a very critical feature.

00:08:41.340 --> 00:08:45.300
We want users to be able to run their
own daemons to support their own needs,

00:08:45.410 --> 00:08:49.530
and not need to run their own
super daemon just when we already

00:08:49.560 --> 00:08:51.920
have one running on the system.

00:08:51.920 --> 00:08:53.460
So what does this mean?

00:08:53.460 --> 00:08:55.290
First of all, we want to save you work.

00:08:55.520 --> 00:08:57.150
In the Unix world, you need to fork.

00:08:57.310 --> 00:08:58.420
You need to call setSid.

00:08:58.420 --> 00:09:02.700
You need to close stray file descriptors,
reopen standard I/O as dev null.

00:09:02.700 --> 00:09:04.600
It's just a mess.

00:09:04.840 --> 00:09:08.820
Again, it goes back to the,
we were a user process.

00:09:08.960 --> 00:09:11.700
Now we need to disassociate
ourself from the user input.

00:09:11.710 --> 00:09:14.140
And these are some of
the items you need to do.

00:09:14.250 --> 00:09:17.520
And nobody likes trying to keep
on top of any new API they need

00:09:17.520 --> 00:09:21.240
to call just to disassociate
themselves from the user input.

00:09:21.350 --> 00:09:22.520
What are we going to do?

00:09:22.550 --> 00:09:26.420
When you hit main,
your program will be pre-daemonized.

00:09:26.640 --> 00:09:29.150
You can check in and go.

00:09:30.000 --> 00:09:32.170
We're also going to support
launching on demand.

00:09:32.400 --> 00:09:36.880
This helps you help us
save system resources.

00:09:36.880 --> 00:09:40.520
We will have your communication
handles open and alive even

00:09:40.530 --> 00:09:42.300
when you're not running.

00:09:42.300 --> 00:09:45.500
And should someone connect to them,
we will then launch you.

00:09:45.500 --> 00:09:47.150
It also improves the system boot up.

00:09:47.340 --> 00:09:49.610
If we don't need to run
your entire executable,

00:09:49.700 --> 00:09:52.560
if we just need to open
your communication handle,

00:09:52.560 --> 00:09:55.260
that's less work we need to
do at boot and our users will

00:09:55.260 --> 00:09:56.660
appreciate a faster boot up.

00:09:58.370 --> 00:10:01.020
It also means we can do
a parallel load-a-boot.

00:10:01.070 --> 00:10:06.040
We plan or actually we do implement the
registration of all the communication

00:10:06.040 --> 00:10:08.400
handles of all the daemons all at once.

00:10:08.400 --> 00:10:10.970
That means that if daemon
A needs to talk to daemon B,

00:10:11.210 --> 00:10:14.700
we don't really have a dependency
problem because that dependency is

00:10:14.700 --> 00:10:18.660
implicit by their communication through
a file descriptor or a Mach port.

00:10:18.710 --> 00:10:24.090
If we register them at the same time,
we don't need to worry about

00:10:24.090 --> 00:10:24.090
which one gets launched first.

00:10:25.340 --> 00:10:28.580
which helps us to,
if you're used to StartupItems,

00:10:28.580 --> 00:10:30.730
the little external dependencies
we've been listing there.

00:10:30.740 --> 00:10:32.220
You don't need to track them anymore.

00:10:32.300 --> 00:10:34.570
You don't even need to list them.

00:10:35.630 --> 00:10:39.370
Also, since we want to support
user-supplied jobs,

00:10:39.530 --> 00:10:41.900
we can support something
called user agents.

00:10:41.950 --> 00:10:47.850
We're going to standardize the way
background processes run for users.

00:10:47.850 --> 00:10:50.240
It allows them also to
launch those on demand.

00:10:50.240 --> 00:10:54.330
We've never been able to launch user
agents on demand in any standardized way.

00:10:54.740 --> 00:10:58.790
This will help our log-in performance,
which our users will appreciate.

00:10:59.780 --> 00:11:02.180
Finally, this is something I'm
really excited about.

00:11:02.270 --> 00:11:04.300
We're going to support messaging.

00:11:04.300 --> 00:11:06.520
Things like, you know, hey,
Apple file server,

00:11:06.620 --> 00:11:07.840
tell me about yourself.

00:11:07.930 --> 00:11:10.260
Tell me how many people are connected.

00:11:10.410 --> 00:11:12.210
Tell me, you know, who they are.

00:11:12.360 --> 00:11:13.720
Tell me about them.

00:11:13.720 --> 00:11:15.960
We'd also like to support
controlling daemons.

00:11:15.960 --> 00:11:19.770
Things like, hey, AFP server,
why do you disconnect that user?

00:11:19.770 --> 00:11:21.150
They're done now.

00:11:21.150 --> 00:11:22.700
Or please shut down.

00:11:22.700 --> 00:11:25.130
And the daemon can come
back to us and say,

00:11:25.210 --> 00:11:27.180
okay, I'm ready to shut down now.

00:11:27.180 --> 00:11:29.010
I've written out my log files.

00:11:29.010 --> 00:11:31.790
I've closed and cleaned all my state.

00:11:32.060 --> 00:11:32.850
Thank you.

00:11:32.850 --> 00:11:34.140
I'm done now.

00:11:34.140 --> 00:11:37.380
We believe this is very important
for things like database servers,

00:11:37.510 --> 00:11:41.340
which might have a lot of work
to do before they shut down.

00:11:41.340 --> 00:11:44.450
The old way in the Unix world
was just to send a signal,

00:11:44.460 --> 00:11:47.620
cross your fingers,
and hope that they exit someday.

00:11:47.730 --> 00:11:51.120
You know, that's not great.

00:11:51.130 --> 00:11:53.840
We need to be better than that.

00:11:54.050 --> 00:11:57.710
The number of messages that we can
support are potentially endless

00:11:57.710 --> 00:12:01.460
and we look forward to feedback
from you on what kinds of messages

00:12:01.460 --> 00:12:06.010
you'd like to see sent to you or
messages you'd like to send to us.

00:12:06.120 --> 00:12:08.810
What would you like to
tell us about yourself?

00:12:10.460 --> 00:12:12.460
Now, let's talk about some case studies.

00:12:12.460 --> 00:12:14.540
The real world is what matters.

00:12:14.580 --> 00:12:16.680
We have something called
CUPSD on the system.

00:12:16.680 --> 00:12:18.780
It's the Common Unix Printing System.

00:12:18.780 --> 00:12:20.060
They have a daemon.

00:12:20.160 --> 00:12:22.300
Today,
what they did to support restarting

00:12:22.300 --> 00:12:25.870
is they used some Mach APIs to
check in with Mockinet and tell it,

00:12:25.870 --> 00:12:30.100
"Hey, restart me if I die." That was
extra code they needed to add just

00:12:30.230 --> 00:12:32.160
to get restarted in case they exit.

00:12:32.160 --> 00:12:34.620
With LaunchD, there's no extra code.

00:12:34.620 --> 00:12:36.210
We know you want to keep running.

00:12:36.230 --> 00:12:37.180
You're a daemon.

00:12:37.220 --> 00:12:39.090
You exist to serve other people.

00:12:39.320 --> 00:12:43.910
This simplifies their port
to Mac OS X and makes life

00:12:43.910 --> 00:12:46.160
a lot easier for them.

00:12:46.160 --> 00:12:49.800
Something I brought up earlier
is the multicast DNS responder.

00:12:49.830 --> 00:12:52.510
It uses both Mach ports
and Unix file descriptors.

00:12:52.550 --> 00:12:55.240
We'd like to be able to
launch that on demand,

00:12:55.240 --> 00:12:59.550
but today we have INED on the right,
just supporting file descriptors,

00:12:59.550 --> 00:13:02.920
and we have Mockinit on the
left holding just Mach ports.

00:13:02.920 --> 00:13:05.360
They don't know anything
about each other.

00:13:05.360 --> 00:13:10.180
One could launch MDNS responder
based on communication on one type

00:13:10.180 --> 00:13:14.770
of technology but not the other,
leaving a problem for the MDNS responder

00:13:14.930 --> 00:13:16.820
if they want to launch on demand.

00:13:17.210 --> 00:13:18.240
Launch de-handles both.

00:13:18.790 --> 00:13:22.230
Nothing else does for launch on demand,
and we're very excited about this

00:13:22.430 --> 00:13:24.100
support for multiple technologies.

00:13:25.720 --> 00:13:29.120
Also, back to the user side,
let's bring another case study example.

00:13:29.120 --> 00:13:35.070
The SSH agent is a classic example of
a command line process that people want

00:13:35.100 --> 00:13:38.290
to run to support their SSH activities.

00:13:38.290 --> 00:13:43.250
A lot of people usually end up creating
these complicated statements at the

00:13:43.250 --> 00:13:47.780
beginning of their shell startup
just to make sure that they have only

00:13:47.780 --> 00:13:50.490
one SSH agent running on the system.

00:13:50.740 --> 00:13:54.380
So they'll create lock files,
then they'll try and see if they

00:13:54.380 --> 00:13:57.460
already have an agent running,
and if not, run it,

00:13:57.470 --> 00:14:00.850
and then unlock the whole
state that they've built up.

00:14:00.880 --> 00:14:04.740
Well, with LaunchD,
you can just drop an XMLP list into

00:14:04.830 --> 00:14:08.560
a directory in your home directory,
and at login time,

00:14:08.680 --> 00:14:14.150
we will register the SSH agent to launch
on demand the next time you talk to it.

00:14:14.240 --> 00:14:16.330
And only one of them
for your login session,

00:14:16.330 --> 00:14:20.140
which means all that complicated locking
and checking to see if one's running,

00:14:20.140 --> 00:14:20.610
nope.

00:14:20.820 --> 00:14:21.500
Don't need to do that.

00:14:21.560 --> 00:14:25.060
We're very excited about
this for user agents,

00:14:25.060 --> 00:14:26.390
and we...

00:14:26.970 --> 00:14:30.040
hope to see more cases
where people use it.

00:14:30.040 --> 00:14:33.710
Also, the changes to SSH agent
were very simple.

00:14:33.820 --> 00:14:39.670
This is something we're excited about
because it means less work for you guys.

00:14:39.670 --> 00:14:42.990
We know pretty much how daemons
operate their state engines.

00:14:42.990 --> 00:14:45.770
We know what information they
need in order to get running.

00:14:45.770 --> 00:14:48.590
We can get that to you right at
the beginning of your process.

00:14:48.590 --> 00:14:52.040
And again, you're pre-daemonized,
so you just take your check-in

00:14:52.460 --> 00:14:54.350
information and you can get running.

00:14:54.700 --> 00:14:58.500
So, okay,
I've told you about what LaunchD does,

00:14:58.500 --> 00:15:00.040
but what doesn't it do?

00:15:00.060 --> 00:15:03.280
Well, there's a lot of other kinds
of events on the system.

00:15:03.280 --> 00:15:07.750
We have configD's database of key
value pairs or configD's events.

00:15:07.750 --> 00:15:11.870
We have the NetInfo database
of key value pairs which can

00:15:11.870 --> 00:15:14.400
come and go as the system runs.

00:15:14.400 --> 00:15:18.500
We also have the Rendezvous
service advertisements.

00:15:18.500 --> 00:15:21.970
Some people want to launch on
demand just by virtue of another

00:15:22.000 --> 00:15:24.550
entity showing up on the network.

00:15:24.880 --> 00:15:28.420
We also, a very popular one is the
I/O Kit namespace which is

00:15:28.550 --> 00:15:30.520
built on top of Mach ports.

00:15:30.580 --> 00:15:34.690
And I/O Kit events, again,
built on top of infrastructure already

00:15:34.790 --> 00:15:39.350
which is built on top of Mach ports.

00:15:39.510 --> 00:15:39.510
Now, I'm going to talk a little bit about

00:15:39.920 --> 00:15:43.300
: We wait, you know, not I/O Kit events?

00:15:43.300 --> 00:15:45.350
Well,
we have things like the Bluetooth daemon.

00:15:45.400 --> 00:15:47.800
It wants to launch when
Bluetooth devices show up.

00:15:47.800 --> 00:15:49.700
We, Apple, have our own needs.

00:15:49.700 --> 00:15:51.400
We know you have your needs.

00:15:51.400 --> 00:15:57.710
So this list that I just gave of things
we don't support is subject to change.

00:15:57.730 --> 00:16:03.750
We're probably most likely add those
subsystems in the future as we figure

00:16:03.750 --> 00:16:05.270
out how to deal with technologies
that are built on top of each other.

00:16:06.400 --> 00:16:07.190
Now, porting.

00:16:07.370 --> 00:16:09.160
Let's start jumping
into the meat of things.

00:16:09.340 --> 00:16:13.420
We have a simple,
very simple IPC API and a very

00:16:13.420 --> 00:16:17.020
simple RTTI-based object system
to support the message passing

00:16:17.020 --> 00:16:22.360
that we want to use to communicate
between LaunchD and your daemon.

00:16:22.560 --> 00:16:24.840
Now, what does the IPC API look like?

00:16:24.850 --> 00:16:27.730
Well, it's kind of,
sort of Core Foundation.

00:16:28.050 --> 00:16:30.190
Well, why not Core Foundation?

00:16:30.400 --> 00:16:30.930
Portability.

00:16:30.940 --> 00:16:33.500
Just about what we talked about earlier.

00:16:33.510 --> 00:16:35.090
LaunchD is open source.

00:16:35.280 --> 00:16:39.560
This is a very important goal for us
to drive adoption and minimizing our

00:16:39.560 --> 00:16:43.560
dependencies helps make adoption easier.

00:16:43.740 --> 00:16:47.330
Also,
a stumbling block is the Mach port and

00:16:47.340 --> 00:16:51.610
file descriptor passing is not supported
by Core Foundation at the moment.

00:16:51.610 --> 00:16:53.800
It's very few people requested.

00:16:53.800 --> 00:16:58.990
It was just easier for us to implement
a simple object graph ourself

00:16:58.990 --> 00:17:03.430
and support serializing it and
sending it across to the other side.

00:17:03.430 --> 00:17:09.190
Finally, really all we need is RTTI,
dictionaries and arrays.

00:17:09.190 --> 00:17:12.610
We're just sending
messages back and forth.

00:17:12.950 --> 00:17:14.580
So to give you an example
of how simple it is,

00:17:14.970 --> 00:17:18.900
this is what the two
basic C APIs look like.

00:17:18.900 --> 00:17:21.320
We have LaunchMessage,
which supports sending an object graph

00:17:21.320 --> 00:17:24.020
and getting an object graph in response.

00:17:24.020 --> 00:17:26.660
And if you're going to be doing any
kind of asynchronous programming,

00:17:26.660 --> 00:17:30.440
we have a simple API to get the
file descriptor that we're using

00:17:30.440 --> 00:17:34.370
on the back end to communicate with
LaunchD and add it to your own run loop.

00:17:34.550 --> 00:17:37.270
If you're using KQ, Select,
it's up to you.

00:17:37.590 --> 00:17:40.170
We can give you the file descriptor,
you can add it,

00:17:40.170 --> 00:17:43.760
and you can call LaunchMessage when
messages are available to read.

00:17:45.200 --> 00:17:48.420
Now, to jump more into the meat of it,
a launch data T represents

00:17:48.420 --> 00:17:50.310
an object graph.

00:17:50.340 --> 00:17:51.740
It can be anything.

00:17:51.740 --> 00:17:52.760
You know, we have the RTTI.

00:17:52.760 --> 00:17:54.510
That's what makes it fun.

00:17:54.630 --> 00:17:58.380
And you can introspect it as you
get a response back or you can send

00:17:58.380 --> 00:18:00.580
just about any message you want.

00:18:00.730 --> 00:18:03.260
Also, launch message,
while it appears synchronous

00:18:03.260 --> 00:18:05.780
for the common case,
it actually, well,

00:18:05.780 --> 00:18:07.900
launch message is synchronous
for the common case.

00:18:07.900 --> 00:18:10.480
It returns null and sets error, no,
and failure,

00:18:10.560 --> 00:18:12.760
plain and simple for the simple case.

00:18:12.760 --> 00:18:16.480
Now, if you do send a message
requesting that asynchronous

00:18:16.950 --> 00:18:21.020
messages be sent in response,
you can then call launch message

00:18:21.020 --> 00:18:24.140
with no message to send by
using null as a parameter.

00:18:24.140 --> 00:18:27.650
And then you'll get any
asynchronous message back.

00:18:28.210 --> 00:18:31.020
And you can keep calling and keep calling
and keep calling until you get null back.

00:18:31.090 --> 00:18:33.720
And if error no is equal to zero,
then there's no more

00:18:33.720 --> 00:18:35.120
asynchronous messages.

00:18:35.120 --> 00:18:38.480
And if it's obviously equal to
something not equal to zero,

00:18:38.490 --> 00:18:40.120
then there's a problem.

00:18:42.060 --> 00:18:45.670
Now let's talk about those messages
we're sending back and forth.

00:18:45.900 --> 00:18:48.560
You know,
RTTI and container classes are fun.

00:18:48.560 --> 00:18:53.570
We have dictionaries, we have arrays,
and we have some basic objects

00:18:53.570 --> 00:18:55.800
to match the C basic types.

00:18:56.060 --> 00:19:00.680
We have file descriptors, Mach ports,
integers, real numbers, booleans,

00:19:00.680 --> 00:19:04.200
strings, and finally opaque
data should we need it.

00:19:05.100 --> 00:19:08.980
Now, again,
it's just enough for IPC and no more.

00:19:09.080 --> 00:19:11.880
We have get and set operations
for the basic types,

00:19:12.030 --> 00:19:15.600
and in the case of dictionaries,
we allow insertion, lookup, removal,

00:19:15.600 --> 00:19:16.610
and iterate.

00:19:16.730 --> 00:19:18.760
Again, all we need for IPC.

00:19:19.050 --> 00:19:22.360
For arrays,
get and set index and get count.

00:19:22.450 --> 00:19:24.490
It's enough to introspect
and set up an object graph.

00:19:24.700 --> 00:19:26.630
That's all we need.

00:19:27.320 --> 00:19:30.690
Now to understand the object graphs
we're going to be sending back and forth,

00:19:30.700 --> 00:19:35.490
let's talk about the XMLP list that
you'll use to configure a daemon for us

00:19:35.570 --> 00:19:37.580
to run at a later point in the system.

00:19:37.580 --> 00:19:41.130
You're going to have something like a
label to uniquely identify your job,

00:19:41.130 --> 00:19:43.230
and that really is the unique key.

00:19:43.260 --> 00:19:46.700
This is in case someone
wants to control your daemon,

00:19:46.700 --> 00:19:49.980
the label is what they're
going to use to send it,

00:19:50.090 --> 00:19:54.220
you know, turn it on, turn it off,
change some attribute of it.

00:19:54.220 --> 00:19:55.980
That's the important key.

00:19:55.980 --> 00:19:59.610
You can have things like the username
that you want the daemon to run as,

00:19:59.610 --> 00:20:03.720
the group name, program name,
and pretty much any kind of environmental

00:20:03.720 --> 00:20:06.380
setup you need to get the daemon running.

00:20:06.380 --> 00:20:09.060
You know, I want the daemon to run
in that working directory,

00:20:09.060 --> 00:20:12.260
I want to have this argument
and this environment variable.

00:20:12.260 --> 00:20:16.250
Any kind of setup detail
we plan on supporting.

00:20:16.930 --> 00:20:19.720
Now, if you notice at the bottom
of the list back there we had

00:20:19.720 --> 00:20:21.520
something called Event Sources.

00:20:21.520 --> 00:20:24.220
They're all about the
details of how to set up file

00:20:24.260 --> 00:20:26.140
descriptors in the Mach ports.

00:20:26.310 --> 00:20:29.380
You know, who to connect to, you know,
where to listen.

00:20:30.010 --> 00:20:33.250
Particularly file descriptors can be very
complicated since there are different

00:20:33.350 --> 00:20:34.380
technologies that can back them.

00:20:34.510 --> 00:20:38.180
You've got IPv4, IPv6,
Unix domain sockets.

00:20:38.180 --> 00:20:42.270
It could be a new type of
technology that we don't know

00:20:42.270 --> 00:20:46.100
about that requires different
APIs to set up the file descriptor.

00:20:46.100 --> 00:20:49.650
And we need all these
details put in one place.

00:20:49.650 --> 00:20:52.860
So this is what the Event Sources are.

00:20:53.180 --> 00:20:56.710
Now, before we send an
XMLP list over to LaunchD,

00:20:56.720 --> 00:20:59.900
we actually do some data distillation.

00:20:59.960 --> 00:21:02.300
We're going to turn those
usernames into UIDs,

00:21:02.320 --> 00:21:05.640
the group names into GIDs,
and we're going to take all those

00:21:05.640 --> 00:21:09.100
event sources and actually translate
them down to the file descriptors

00:21:09.100 --> 00:21:11.390
and Mach ports that back them.

00:21:11.390 --> 00:21:14.620
And then the resulting
object graph is much,

00:21:14.620 --> 00:21:15.660
much simpler.

00:21:15.690 --> 00:21:22.240
It requires no lookups by LaunchD to
find out the actual details of anything.

00:21:22.430 --> 00:21:24.860
And the great thing is,
since we've translated

00:21:24.870 --> 00:21:27.260
things to file descriptors,
any kind of security

00:21:27.260 --> 00:21:29.720
check the kernel would do,
we don't need to replicate.

00:21:32.270 --> 00:21:34.160
Now, let's look at some example messages.

00:21:34.230 --> 00:21:35.320
Life's pretty simple.

00:21:35.340 --> 00:21:38.450
You might want to submit a job
and then you're going to have

00:21:38.550 --> 00:21:40.190
that translated XMLP list.

00:21:40.190 --> 00:21:42.110
You might want to remove a job.

00:21:42.280 --> 00:21:43.780
Well, then you just need the label.

00:21:43.780 --> 00:21:45.170
You might want to get the jobs.

00:21:45.170 --> 00:21:46.950
You might want to introspect launch D.

00:21:46.950 --> 00:21:49.350
You might want to find out what
daemons are running on the system.

00:21:49.350 --> 00:21:51.870
That'll get you a big
dictionary coming back.

00:21:51.870 --> 00:21:53.380
You might want to check in.

00:21:53.380 --> 00:21:54.370
You're a daemon.

00:21:54.520 --> 00:21:58.650
You can send a check in message and the
file descriptors and Mach ports that you

00:21:58.650 --> 00:22:04.340
have allocated to you will come back and
you can proceed with them as you wish.

00:22:04.430 --> 00:22:07.880
And finally, something that supports for
things like the SSH agent is

00:22:07.880 --> 00:22:10.440
we need a notion of getting,
unsetting,

00:22:10.580 --> 00:22:15.390
and querying an environment that
isn't directly tied to your shell.

00:22:16.250 --> 00:22:20.030
Now, something that we're still working
on is becoming launch-d savvy.

00:22:20.160 --> 00:22:22.260
If you remember,
I talked to you about sending

00:22:22.260 --> 00:22:23.420
messages to control it.

00:22:23.600 --> 00:22:26.200
Tell me about the users
you have connected to you.

00:22:26.270 --> 00:22:29.040
Please,
I want to disconnect this user over here.

00:22:29.140 --> 00:22:30.620
We're still figuring this stuff out.

00:22:30.690 --> 00:22:36.730
We look forward to your feedback and
definitely some updated documentation

00:22:36.790 --> 00:22:42.180
for you in the Tiger timeframe so that
way you can understand what introspection

00:22:42.180 --> 00:22:42.180
and control operations we supply.

00:22:43.420 --> 00:22:47.600
Now let's hash things out again.

00:22:47.600 --> 00:22:50.540
So predaymonization,
we believe this is very,

00:22:50.770 --> 00:22:52.700
very important for you.

00:22:52.750 --> 00:22:54.960
It means, again,
you're going to hit main and

00:22:54.960 --> 00:22:56.160
your daemon is ready to run.

00:22:56.350 --> 00:22:59.440
You don't need to worry about
disassociating yourself from any

00:22:59.760 --> 00:23:05.080
kind of subsystem on the system,
be it the graphics or maybe Apple script.

00:23:05.080 --> 00:23:08.830
I actually don't program at that level,
but at least in the Unix world,

00:23:08.840 --> 00:23:12.300
no forking, no call set SID,
no closing stray file

00:23:12.300 --> 00:23:13.380
descriptors left behind.

00:23:13.400 --> 00:23:16.450
But who knows what shell?

00:23:16.450 --> 00:23:18.220
Life's good.

00:23:18.220 --> 00:23:19.620
Now you just need to check in and go.

00:23:21.180 --> 00:23:24.750
Also, again,
we automatically support restarting.

00:23:24.890 --> 00:23:27.640
So should you decide that
your configuration file

00:23:27.640 --> 00:23:29.940
changed and you want to rerun,
just exit.

00:23:30.170 --> 00:23:33.570
We'll launch you again the next
time someone connects to you.

00:23:33.710 --> 00:23:37.290
Also,
something we hope you will take advantage

00:23:37.290 --> 00:23:40.060
of is the multiple event sources.

00:23:40.060 --> 00:23:43.600
You might have a file descriptor
or 20 file descriptors.

00:23:43.740 --> 00:23:47.170
We can listen on all of them on
your behalf and run you whenever

00:23:47.170 --> 00:23:49.470
activity happens on any one of them.

00:23:49.720 --> 00:23:53.210
If you listen on a few Mach ports, sure,
tell us about them.

00:23:53.210 --> 00:23:56.510
We'll launch you when
activity happens on them too.

00:23:57.470 --> 00:23:59.960
We also,
those user agents are very excited about,

00:23:59.960 --> 00:24:03.380
should you have a foreground slash
background application combination?

00:24:03.380 --> 00:24:07.180
Well, maybe you don't want,
maybe the user doesn't want

00:24:07.180 --> 00:24:10.550
the foreground application to
necessarily run every time at login,

00:24:10.560 --> 00:24:13.140
but they still want the
background activity to run.

00:24:13.140 --> 00:24:17.420
The example I like to continuously
point back to is the iChat agent.

00:24:17.420 --> 00:24:18.690
You have the menu link.

00:24:18.700 --> 00:24:21.420
It supports showing you
which users are connected,

00:24:21.420 --> 00:24:23.500
but maybe you don't want
iChat running at login,

00:24:23.530 --> 00:24:26.270
but you do want the menu,
you do want to log in.

00:24:26.950 --> 00:24:30.010
Well, with LaunchD,
we can run the iChat agent

00:24:30.010 --> 00:24:32.140
at login without running
the foreground application.

00:24:35.370 --> 00:24:39.450
So to give you an example demo,
I would like to show the

00:24:39.470 --> 00:24:43.720
SSH agent running under LaunchD,
and I would like to show our debug

00:24:43.720 --> 00:24:48.380
daemon running under LaunchD and
acting as a pseudo web server to tell

00:24:48.380 --> 00:24:52.200
you about LaunchD itself by doing the
introspection that I talked about.

00:24:52.200 --> 00:24:56.700
So to show you,
let's show you the web server.

00:24:56.700 --> 00:25:03.610
I have -- this is a representation of the
object graph coming back from LaunchD.

00:25:03.860 --> 00:25:05.220
shows you that here's our key.

00:25:05.220 --> 00:25:10.020
We have the com.apple.launch debugd.

00:25:10.050 --> 00:25:13.000
We run it on demand.

00:25:13.000 --> 00:25:14.410
There's a Boolean set to true.

00:25:14.410 --> 00:25:15.780
It's got a PID of 328.

00:25:15.870 --> 00:25:19.760
If I reload this web page, you'll see,
you know, we keep launching it on demand

00:25:19.860 --> 00:25:21.910
because this number is changing.

00:25:22.220 --> 00:25:24.710
We have some, you know,
various setup details in

00:25:24.710 --> 00:25:26.010
which UID to run it as.

00:25:26.080 --> 00:25:28.660
If you notice, it's running as me,
the user.

00:25:28.810 --> 00:25:31.340
Finally, there's two file descriptors
we're listening on.

00:25:31.340 --> 00:25:36.300
They happen to represent the IPv4 and
IPv6 socket that were set up by the user.

00:25:36.540 --> 00:25:38.160
And also, look at this.

00:25:38.160 --> 00:25:39.410
We have an SSH agent.

00:25:39.480 --> 00:25:40.620
It's also running on demand.

00:25:40.670 --> 00:25:44.320
It doesn't have a PID set yet because
no one's tried to talk to him yet.

00:25:44.350 --> 00:25:47.510
And this is the Unix domain
socket he's listening on.

00:25:47.670 --> 00:25:52.530
So if we go back to the terminal,
we can run SSHAd.

00:25:53.090 --> 00:25:56.110
And now if we go back
here and run it again,

00:25:56.110 --> 00:25:59.750
we see that the SSH agent
launched on demand.

00:26:00.470 --> 00:26:01.390
How did this all happen?

00:26:01.570 --> 00:26:05.380
Well, it goes back to the simple plist we
talked about dropping on the system.

00:26:05.520 --> 00:26:08.910
If you see in tilde
library launch agents,

00:26:09.070 --> 00:26:10.400
we have a couple plists.

00:26:10.440 --> 00:26:14.400
There's that launch debug D that
I talked about and the SSH agent.

00:26:14.440 --> 00:26:19.850
And they're pretty simple files.

00:26:19.850 --> 00:26:19.850
We got com open SSH.

00:26:20.100 --> 00:26:24.300
All we have is again here's that label,
here's the program arguments and

00:26:24.300 --> 00:26:28.320
the listeners which the event
sources which get distilled down

00:26:28.370 --> 00:26:30.690
to an actual file descriptor.

00:26:30.700 --> 00:26:34.330
So in this case we have a little secure
socket with an environmental key which

00:26:34.520 --> 00:26:39.770
if you're using SSH agent you're familiar
with and the socket type we need.

00:26:40.040 --> 00:26:43.980
Now, that can show you how
simple it can be to -- oh,

00:26:43.980 --> 00:26:46.610
I might as well show the -- I

00:26:47.620 --> 00:26:50.740
So here's the debug daemon, for example.

00:26:50.740 --> 00:26:56.500
It just listens on a port 12345,
happens to be a passive socket,

00:26:56.500 --> 00:26:58.780
and it's a SOC stream.

00:26:58.780 --> 00:27:01.680
And what ends up happening,
if you're familiar with

00:27:01.680 --> 00:27:04.740
the get adder info API,
is we take these details,

00:27:04.740 --> 00:27:08.020
we throw it a get adder info,
and take whatever adder info

00:27:08.020 --> 00:27:11.200
structures come back and allocate a
file descriptor for each one of them,

00:27:11.200 --> 00:27:14.140
and then send it over to launchd,
and it just listens on them.

00:27:14.220 --> 00:27:18.350
So in this case,
IPv4 and IPv6 sockets came back,

00:27:18.440 --> 00:27:22.290
and that can change in the future,
and your daemon wouldn't

00:27:22.290 --> 00:27:23.500
even need to know about it.

00:27:23.550 --> 00:27:26.200
A new type of communication
technology might come out,

00:27:26.200 --> 00:27:28.520
and you don't care.

00:27:28.520 --> 00:27:31.160
As long as it's a file descriptor
and it comes back to you,

00:27:31.160 --> 00:27:33.770
you can get events off
of it and handle them.

00:27:35.120 --> 00:27:38.590
So we're very excited about this.

00:27:38.600 --> 00:27:43.310
And I believe it's time for Q&A now.

00:27:43.460 --> 00:27:44.400
Yeah.

00:27:44.400 --> 00:27:49.100
Oh, also for more information you
can talk to Jason and yeah.

00:27:49.150 --> 00:27:52.260
And this source will be
on the developer website,

00:27:52.260 --> 00:27:54.110
the Darwin developer website.
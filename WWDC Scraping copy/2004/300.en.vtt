WEBVTT

00:00:12.670 --> 00:00:19.700
Ladies and gentlemen,
please welcome Vice President of

00:00:19.700 --> 00:00:19.700
Development Technologies,
Ted Goldstein.

00:00:25.430 --> 00:00:27.290
Good afternoon.

00:00:27.430 --> 00:00:28.980
What an amazing day it's been so far.

00:00:28.980 --> 00:00:35.670
I hope to keep this on a roll.

00:00:35.670 --> 00:00:36.750
We have a lot to talk about.

00:00:36.750 --> 00:00:36.750
I want to give you a quick
agenda of what we're going on.

00:00:38.290 --> 00:00:42.440
Give you an update on what we've done
this last year with the Xcode Tool Suite,

00:00:42.440 --> 00:00:45.570
and then talk about something
everybody cares about is performance,

00:00:45.570 --> 00:00:48.960
and where we're going with what's next,
the future for Xcode,

00:00:49.140 --> 00:00:52.560
and the compiler and runtime,
which is such an important part of

00:00:52.640 --> 00:00:55.060
making applications great on Mac OS X.

00:00:56.170 --> 00:00:59.290
Performance tools are a critical,
critical part of how you

00:00:59.310 --> 00:01:03.220
make your application faster,
and we want to give you all the help,

00:01:03.350 --> 00:01:06.570
not just making the compiler
produce great code for you,

00:01:06.600 --> 00:01:11.340
but also give you the assistance it takes
to make your applications really perform.

00:01:11.340 --> 00:01:14.270
And then finally,
how can you use Xcode with all the

00:01:14.320 --> 00:01:18.420
great frameworks and SDKs you saw
this morning and this afternoon?

00:01:18.420 --> 00:01:22.640
So let's jump right in and give you a
quick update on the Xcode Tool Suite.

00:01:24.930 --> 00:01:28.810
So, in this last year,
we put out three releases of Xcode: 1.0,

00:01:28.810 --> 00:01:30.680
1.1, 1.2.

00:01:30.680 --> 00:01:33.200
And 1.0 was the feature release.

00:01:33.310 --> 00:01:38.140
It had predictive compilation, zero link,
fix and continue, distributed builds,

00:01:38.260 --> 00:01:40.040
smart groups, and code sense.

00:01:40.130 --> 00:01:41.590
A very rich build.

00:01:41.720 --> 00:01:45.840
In 1.1 and 1.2,
we elaborated and enhanced both the

00:01:45.840 --> 00:01:50.510
performance capabilities of that,
the stability and the robustness of it,

00:01:50.650 --> 00:01:54.550
and filled in a few of the missing
details and workflow issues.

00:01:55.160 --> 00:01:57.940
Third-party tools quickly jumped in.

00:01:57.990 --> 00:02:02.510
BBEdit and SubEtherEdit and Perforce,
almost immediately out of the gate,

00:02:02.510 --> 00:02:05.440
was great third-party support
to show that Xcode was not

00:02:05.440 --> 00:02:11.800
just an island by itself,
but included access for other tools.

00:02:13.250 --> 00:02:16.890
In the 1.1 timeframe,
we added support for IBM's

00:02:16.890 --> 00:02:19.890
terrific XLC and XLFC,
C++, and Fortran,

00:02:19.890 --> 00:02:21.600
and Objective-C compilers.

00:02:21.600 --> 00:02:24.670
And that is a great
benefit to the platform,

00:02:24.750 --> 00:02:26.220
working with IBM.

00:02:26.220 --> 00:02:30.140
They, of course,
also helped develop the 970 CPU,

00:02:30.220 --> 00:02:32.960
the G5 processor that Apple ships.

00:02:33.220 --> 00:02:35.450
And the combination is incredible.

00:02:35.450 --> 00:02:39.040
Much of the great scientific
computing that's been done over

00:02:39.040 --> 00:02:40.840
the years has been done in Fortran.

00:02:40.840 --> 00:02:43.310
It's been, you know,
I can remember as an undergraduate

00:02:43.360 --> 00:02:46.310
in school that we said,
I don't know what language people

00:02:46.320 --> 00:02:48.770
will be using in the year 2000,
but it will be named Fortran.

00:02:48.770 --> 00:02:49.990
Well, it's still true.

00:02:49.990 --> 00:02:52.630
It's still named Fortran,
and it's a great language.

00:02:54.400 --> 00:02:57.560
and there have been oodles of
templates and other components and

00:02:57.560 --> 00:03:01.340
capabilities that add to Xcode.

00:03:01.620 --> 00:03:05.240
This includes conduits and
AppleScript plugins and such

00:03:05.500 --> 00:03:10.300
that really round out the
corners of making Xcode terrific.

00:03:10.300 --> 00:03:16.340
And you've responded with over
300,000 downloads of these tools.

00:03:16.340 --> 00:03:18.870
And that's,
I want to thank you very much.

00:03:18.870 --> 00:03:18.870
I think that's an incredible
show of support for the platform.

00:03:24.320 --> 00:03:27.050
Of course,
it's great to have a volume of users

00:03:27.180 --> 00:03:31.510
using the tools and it's also extremely
important for us to be working with

00:03:31.510 --> 00:03:33.640
our important developer partners.

00:03:33.780 --> 00:03:40.100
Folks like Adobe are helping us to make
Xcode and GCC terrific for their tools.

00:03:40.210 --> 00:03:45.100
Here's a quote from Fritz Haberman,
lead architect and head of InDesign.

00:03:45.100 --> 00:03:47.920
And we think it's just an incredible
thing to be working with partners

00:03:48.150 --> 00:03:54.370
because frankly a large code base such
as InDesign takes a lot of resources

00:03:54.640 --> 00:03:59.530
to put it to a new environment and as
well for us to help the compiler really

00:03:59.590 --> 00:04:02.100
encompass such an enormous code base.

00:04:02.220 --> 00:04:06.090
And we learn and improve the product for
all of our developers with each step.

00:04:06.100 --> 00:04:08.050
We also see this as well with Quark.

00:04:08.100 --> 00:04:13.100
And Quark has been a fabulous partner
working with us to make Xcode great.

00:04:13.270 --> 00:04:15.100
And we find that it's so important.

00:04:15.100 --> 00:04:21.100
So important to be doing this process in
partnership with these key developers.

00:04:21.100 --> 00:04:24.910
Of course, this morning we heard
from Maya Engineering,

00:04:24.910 --> 00:04:28.740
from Bob Bennett,
and here very happy to say

00:04:28.740 --> 00:04:33.740
that Maya 6 and Maya HT,
incredible, incredible applications

00:04:33.740 --> 00:04:35.100
developed with Xcode.

00:04:35.220 --> 00:04:38.360
And using the benefit,
the productivity benefit and the

00:04:38.360 --> 00:04:43.070
performance gains that Xcode and
GCC provide to deliver on G5 performance.

00:04:43.100 --> 00:04:45.020
So that is the key.

00:04:45.100 --> 00:04:47.120
has been an amazing thing.

00:04:47.130 --> 00:04:49.290
Now I want to invite--

00:04:49.610 --> 00:04:54.990
Rich Siegel, CEO of Barebones Edit,
Barebones Software, sorry,

00:04:55.060 --> 00:04:59.410
to talk a little bit about
building BBEdit with Xcode.

00:05:04.610 --> 00:05:05.630
Thank you very much, Ted.

00:05:05.660 --> 00:05:06.700
Good afternoon, everybody.

00:05:06.700 --> 00:05:08.590
It's great to be here.

00:05:08.670 --> 00:05:12.940
So when Apple announced Xcode a year ago,
almost today, in fact,

00:05:12.940 --> 00:05:14.630
we were really intrigued.

00:05:14.630 --> 00:05:21.660
At Barebones Software,
we've got a long history of, of course,

00:05:21.660 --> 00:05:22.960
not only experience
using developer tools,

00:05:22.960 --> 00:05:22.960
but also some of us have worked on them.

00:05:23.170 --> 00:05:27.940
and we know that a diversity of
developer tools is a good thing to have.

00:05:27.940 --> 00:05:31.720
It's good for the ecosystem,
it makes a better developer experience,

00:05:31.720 --> 00:05:33.640
and that makes a better platform.

00:05:33.710 --> 00:05:37.540
So when Xcode 1.0 shipped in October,
we took a good close look at it,

00:05:37.540 --> 00:05:40.710
we kicked the tires,
and we thought about what's really

00:05:40.710 --> 00:05:44.760
important to us when it comes to making
better products to serve our customers.

00:05:44.810 --> 00:05:47.900
And it came down to really
three simple things.

00:05:47.900 --> 00:05:49.360
The first was compiler quality.

00:05:49.420 --> 00:05:52.070
And here, great job in Xcode.

00:05:52.140 --> 00:05:57.260
GCC is an excellent compiler,
and I'll get into that shortly.

00:05:57.360 --> 00:05:59.160
The next thing was build productivity.

00:05:59.160 --> 00:06:01.520
Usually the first thing we do
when there's a platform change,

00:06:01.520 --> 00:06:05.090
such as a new hardware platform
or a new tools platform,

00:06:05.090 --> 00:06:08.140
is we'll sit down and we'll whip out
a stopwatch and we'll see how long

00:06:08.140 --> 00:06:10.010
it takes to build our product line.

00:06:10.230 --> 00:06:12.900
And finally,
the really important thing for us was

00:06:13.050 --> 00:06:18.220
to be able to continue using as many
of our existing tools as we could.

00:06:18.220 --> 00:06:20.110
So, on the first front, compiler quality.

00:06:20.120 --> 00:06:21.680
Well, GCC is a great compiler.

00:06:21.680 --> 00:06:23.540
Its language conformance is very good.

00:06:23.540 --> 00:06:26.220
And what we found was when we
turned on all the warnings,

00:06:26.220 --> 00:06:29.740
which Xcode makes really easy to do
because it's a great GUI for GCC,

00:06:29.740 --> 00:06:32.720
is, you know,
we went through and we turned on

00:06:32.720 --> 00:06:36.830
all the warnings and we found a few
latent bugs and we found some good

00:06:36.830 --> 00:06:40.790
code quality improvements and so the
result is we have a cleaner code base,

00:06:40.790 --> 00:06:42.980
it's more maintainable,
and we can run it through

00:06:42.980 --> 00:06:46.570
even more compilers such as,
for example, XLC if we choose.

00:06:48.360 --> 00:06:52.570
Also, the generated code is favorably
comparable to pretty much

00:06:52.570 --> 00:06:54.700
everything else we've used.

00:06:54.700 --> 00:06:56.300
We gave up nothing in code quality.

00:06:57.830 --> 00:07:00.280
The next thing, as I mentioned,
was the productivity

00:07:00.280 --> 00:07:01.280
improvement of build times.

00:07:01.300 --> 00:07:05.000
And there, what we found was that
with distributed builds,

00:07:05.010 --> 00:07:09.500
we were seeing about a 30% to 40%
decrease in build times compared

00:07:09.500 --> 00:07:10.960
to building on a single machine.

00:07:10.960 --> 00:07:14.740
So we have a little bit less time to get
a cup of coffee while we're building,

00:07:14.740 --> 00:07:16.780
but in spite of that,
it turns into a real

00:07:16.780 --> 00:07:18.500
productivity improvement.

00:07:18.500 --> 00:07:22.700
The beautiful thing about that, however,
was that we were able to realize

00:07:22.700 --> 00:07:26.480
this improvement without any
capital investment whatsoever.

00:07:26.780 --> 00:07:30.410
We didn't have to go out and drop
$20,000 on a dedicated build farm.

00:07:30.730 --> 00:07:34.130
Instead, we were able to use existing
hardware in the office,

00:07:34.130 --> 00:07:38.570
administration workstations,
engineering workstations, operations,

00:07:38.680 --> 00:07:42.110
marketing, even the machine that drives
our CD duplicator as part

00:07:42.110 --> 00:07:43.640
of the in-house build farm.

00:07:43.640 --> 00:07:49.670
So no capital expense,
a free 30% to 40% in build times.

00:07:49.680 --> 00:07:51.470
It was like having our
cake and eating it,

00:07:51.470 --> 00:07:51.860
too.

00:07:51.860 --> 00:07:52.870
It just didn't get any better.

00:07:54.420 --> 00:07:57.300
Finally, of course,
was the ability to use our own tools,

00:07:57.300 --> 00:07:58.760
and here this was crucial.

00:07:58.850 --> 00:08:01.540
And the external editor
support in Xcode was great.

00:08:01.540 --> 00:08:03.820
I mean,
can you imagine us not using BBEdit?

00:08:03.840 --> 00:08:08.500
So, we were really pleased
to be able to do that,

00:08:08.530 --> 00:08:11.660
and in fact, on the converse,
not being able to do that would

00:08:11.660 --> 00:08:13.470
have been a real deal-breaker.

00:08:14.430 --> 00:08:21.020
So, I'm happy to say that as a result of
really meeting these three basic tests,

00:08:21.020 --> 00:08:24.980
compiler quality, productivity through
building performance,

00:08:24.990 --> 00:08:29.350
and being able to use our existing tools,
all of our product development,

00:08:29.350 --> 00:08:31.760
with the exception of maintaining
current shipping versions,

00:08:31.760 --> 00:08:35.040
but all of our products, BBEdit,
Text Wrangler, Mail Smith,

00:08:35.040 --> 00:08:37.950
and SuperGetInfo,
are being built with Xcode today.

00:08:37.960 --> 00:08:42.500
So, I just wanted to thank Ted and his
team for delivering a great tool chain.

00:08:44.360 --> 00:08:47.410
Thank you, Rich.

00:08:50.000 --> 00:08:51.010
It's so important.

00:08:51.260 --> 00:08:55.540
And we focus on performance in
every part of the development cycle,

00:08:55.540 --> 00:08:58.740
both on the build time, the launch time,
the runtime,

00:08:58.860 --> 00:09:00.710
and development and debug time.

00:09:00.820 --> 00:09:04.050
And each of these areas is critically,
critically important.

00:09:04.120 --> 00:09:06.740
With Xcode 1.0,
we placed an immense amount of

00:09:06.740 --> 00:09:10.530
emphasis on the batch build time,
that which you do in the office.

00:09:10.580 --> 00:09:13.310
In this last year, though,
a lot of people said to us, Ted,

00:09:13.310 --> 00:09:15.180
you know,
that's great when I'm in the office

00:09:15.180 --> 00:09:16.800
and I can use distributed builds.

00:09:16.900 --> 00:09:20.870
What about when I'm sitting in a cafe
drinking that cup of coffee on my laptop?

00:09:20.870 --> 00:09:24.140
And there, of course, we,
so in this last year,

00:09:24.140 --> 00:09:28.980
we have turned our attention really
from the main office build time

00:09:28.980 --> 00:09:32.210
to really the cafe build time,
if you will.

00:09:32.350 --> 00:09:35.420
And so I'm happy to say that
now Xcode build performance

00:09:35.450 --> 00:09:37.370
is 33% faster on laptops.

00:09:41.700 --> 00:09:46.570
We also get another 18% speed improvement
on dual processor machines as well.

00:09:46.670 --> 00:09:49.660
And so we think of these
things as incredibly important,

00:09:49.790 --> 00:09:53.630
and we will continue to make
improvements on each of the areas.

00:09:53.680 --> 00:09:57.850
I think that it's critically
important to realize that GCC,

00:09:57.850 --> 00:10:01.300
as the heart of this,
is already an amazingly fast compiler.

00:10:01.300 --> 00:10:06.170
We are innovating in multiple ways.

00:10:06.290 --> 00:10:08.270
One of the most important ways that
we're doing this is something we

00:10:08.270 --> 00:10:09.490
think of as shortcut compilation.

00:10:10.340 --> 00:10:15.780
And that is ignoring unnecessary
declarations and short-circuiting

00:10:15.980 --> 00:10:18.620
unnecessary recompilations.

00:10:18.710 --> 00:10:20.310
What's an unnecessary recompilation?

00:10:20.490 --> 00:10:22.730
For example,
when you hit a space or put in a comment.

00:10:22.790 --> 00:10:26.640
Really, the text and program meaning
of the code hasn't changed,

00:10:26.710 --> 00:10:32.170
but just the white space, if you will,
of the program has changed.

00:10:32.180 --> 00:10:34.010
And so this is coming out.

00:10:34.030 --> 00:10:37.220
It didn't make your DVDs,
but will be in a future

00:10:37.220 --> 00:10:39.730
download beta coming along soon.

00:10:41.680 --> 00:10:44.230
Now let's turn our attention
over to launch performance.

00:10:44.310 --> 00:10:46.760
The time it takes for
the program to start up.

00:10:46.890 --> 00:10:52.040
Mac OS X has seen continuous evolution
of the Mac object file format.

00:10:52.160 --> 00:10:56.330
Among the capabilities that we
typically advise people is to

00:10:56.600 --> 00:10:58.760
pre-bind their applications.

00:10:58.880 --> 00:11:02.490
Pre-binding is the set of setting
up the your application for a given

00:11:02.540 --> 00:11:09.260
release so that the addresses of
the libraries are already located

00:11:09.550 --> 00:11:11.920
in the executable text segment.

00:11:12.040 --> 00:11:16.270
But the feedback on
pre-binding has not been good.

00:11:16.370 --> 00:11:19.940
This is a great comment
from Arnold Sanity.org.

00:11:19.940 --> 00:11:22.540
I really hate the fact that
Mac OS X requires pre-binding

00:11:22.540 --> 00:11:24.060
for Mac OS X applications.

00:11:24.160 --> 00:11:26.080
And there are whole websites.

00:11:26.080 --> 00:11:27.200
Pre-binding is painful.

00:11:27.430 --> 00:11:28.720
It's time consuming.

00:11:28.720 --> 00:11:29.920
It's error prone.

00:11:30.050 --> 00:11:35.740
And now I'd like to say that it's
unnecessary for most applications.

00:11:39.710 --> 00:11:41.910
Starting in Jaguar,
but continue on in Panther,

00:11:42.040 --> 00:11:47.970
and then resulting in some work that we
finally put it all together in 10.3.4,

00:11:47.970 --> 00:11:53.070
we made it so that pre-bound Maya 6,
for example, one customer that we worked

00:11:53.260 --> 00:11:56.670
with who was taking their
application from CFM to MockO,

00:11:56.670 --> 00:12:00.070
originally in an un-pre-bound,
dynamically bound -- it's the

00:12:00.220 --> 00:12:03.580
opposite of pre-bound -- state
takes about 48 seconds to launch.

00:12:03.580 --> 00:12:05.770
And that kind of impends
on the development cycle.

00:12:05.780 --> 00:12:09.220
In the pre-bound state,
it takes about 12 seconds.

00:12:09.220 --> 00:12:13.180
And in 10.3.4 and Tiger,
it takes only five seconds

00:12:13.360 --> 00:12:17.120
in the dynamically bound,
not pre-bound state.

00:12:17.120 --> 00:12:18.100
Why could we do this so fast?

00:12:18.120 --> 00:12:22.330
It's because we put in important
things like two-level namespaces and

00:12:22.330 --> 00:12:26.230
hints to help to quickly find symbols,
so that it's not searching all of your

00:12:26.230 --> 00:12:30.250
address space as the binding is going on,
but it's doing that very quickly

00:12:30.370 --> 00:12:32.560
and searching a very small subset.

00:12:32.580 --> 00:12:38.740
So this is an important technology,
and I think it's very helpful to have.

00:12:38.740 --> 00:12:40.240
Tiger.

00:12:41.060 --> 00:12:43.700
We've even made it one step further.

00:12:43.820 --> 00:12:46.350
We're studying applications like Safari,
for example.

00:12:46.350 --> 00:12:49.200
These are some preliminary
measurements where we have both the

00:12:49.200 --> 00:12:51.280
pre-binding and the dynamically bound.

00:12:51.280 --> 00:12:52.550
The pre-bound state is no difference.

00:12:52.580 --> 00:12:53.640
We cannot tell the difference.

00:12:53.640 --> 00:12:58.990
Now, you should always, you know,
this is a preview release.

00:12:58.990 --> 00:13:03.770
We want to hear your feedback,
so please do some studies.

00:13:03.810 --> 00:13:04.930
But we believe that pre-binding
is no longer necessary.

00:13:04.930 --> 00:13:04.930
So that's pre-binding.

00:13:11.510 --> 00:13:13.920
So what's next for Xcode?

00:13:13.980 --> 00:13:20.300
With Xcode we have-- we're
releasing-- I think Peter had

00:13:20.410 --> 00:13:23.000
already turned on the RSS feed,
so we already saw some of the press

00:13:23.000 --> 00:13:26.900
releases hitting the Apple News site
that there is going to be an Xcode 2.0.

00:13:27.070 --> 00:13:31.370
But in fact, there are two releases,
an Xcode 1.5 for Panther and

00:13:31.370 --> 00:13:33.880
an Xcode 2.0 on Tiger.

00:13:33.930 --> 00:13:36.220
And we've gotten this because you've
given us the feedback that says,

00:13:36.220 --> 00:13:38.710
you know Ted, it's great for us to
get the next release,

00:13:38.710 --> 00:13:41.390
but we don't wait that long,
and we want to use the new tools

00:13:41.390 --> 00:13:44.590
and features that you have on
the current operating system

00:13:44.820 --> 00:13:46.080
that we're shipping today.

00:13:46.200 --> 00:13:51.290
So Xcode 1.5 contains most
of the goodies that 2.0 has.

00:13:51.590 --> 00:13:54.330
Certainly everything that
can work in a 1.5 context,

00:13:54.350 --> 00:13:57.000
it doesn't take advantage of
important frameworks and new

00:13:57.000 --> 00:13:59.720
features that are Tiger only.

00:13:59.800 --> 00:14:00.920
So we're going to try to do this.

00:14:00.940 --> 00:14:04.250
I'm not going to make a firm commitment,
but definitely we've heard you,

00:14:04.260 --> 00:14:07.470
that you want to have great
tools at the same time as you

00:14:07.470 --> 00:14:09.280
have the forward-looking tools.

00:14:09.360 --> 00:14:09.840
So let's focus in first.

00:14:09.840 --> 00:14:14.810
And really,
1.5 is a feature release where we

00:14:14.890 --> 00:14:17.570
focused on the features you've asked for.

00:14:17.800 --> 00:14:25.120
Principal among that is an important
feature called dead code stripping,

00:14:25.120 --> 00:14:25.120
essentially removing the
unnecessary code out of a program.

00:14:27.390 --> 00:14:30.730
We also realized that even
though we're doing this amazing

00:14:30.730 --> 00:14:33.280
formatting in code sense,
you also want to have

00:14:33.280 --> 00:14:34.570
faster edit performance.

00:14:34.750 --> 00:14:39.390
And edit performance is improved
in many cases by 10x and even

00:14:39.500 --> 00:14:41.820
more for the very large files.

00:14:45.600 --> 00:14:49.190
I think one,
saying that we love Java and AppleScript,

00:14:49.190 --> 00:14:52.560
but where then was the code
sense support in Xcode?

00:14:52.560 --> 00:14:54.550
And in 1.5 you've got it.

00:14:54.880 --> 00:15:02.420
You've got support for code sense
and incremental compilation,

00:15:02.420 --> 00:15:04.990
and Ant, and many other build system
features for Java and AppleScript.

00:15:04.990 --> 00:15:04.990
You'll see some of that later today.

00:15:06.780 --> 00:15:08.110
And finally, Subversion.

00:15:08.120 --> 00:15:13.840
Gee, I thought I'd have to explain
to you what Subversion was.

00:15:13.860 --> 00:15:15.780
So for the two people in
the room who don't know,

00:15:15.900 --> 00:15:19.230
Subversion is a new version of CVS,
or a CVS-type system,

00:15:19.230 --> 00:15:21.680
source code management system.

00:15:21.790 --> 00:15:25.220
Many people believe it is
the logical successor to CVS.

00:15:25.220 --> 00:15:27.020
It's done by the same
folks who did WebDAV,

00:15:27.080 --> 00:15:30.300
so it has a terrific network orientation.

00:15:30.410 --> 00:15:33.460
And so now Subversion support
is built in to Xcode 1.5.

00:15:33.580 --> 00:15:36.160
We've also made a number
of debug improvements.

00:15:36.210 --> 00:15:38.050
Now I want to bring up

00:15:39.140 --> 00:15:43.180
Chris Friesen,
and Gaveler State from Transgaming.

00:15:51.400 --> 00:15:52.810
Thanks, Ted.

00:15:52.890 --> 00:15:57.040
So, at Transgaming we work on
software portability tools for the

00:15:57.190 --> 00:15:59.300
entertainment software industry.

00:15:59.300 --> 00:16:03.460
Specifically what that means is that we
work to provide tools and technologies

00:16:03.460 --> 00:16:07.330
to allow developers and publishers
to take their games from one platform

00:16:07.330 --> 00:16:09.490
to another very quickly and cheaply.

00:16:09.680 --> 00:16:12.400
Now, we've been working on a
title called Tron 2.0,

00:16:12.400 --> 00:16:14.040
which was recently released.

00:16:14.040 --> 00:16:16.360
In fact,
you can actually go to CompUSA and

00:16:16.360 --> 00:16:17.890
pick it up in the stores.

00:16:17.900 --> 00:16:20.990
And one of the things we run into a
lot when we're dealing with porting

00:16:20.990 --> 00:16:23.600
games is the fact that a game,
by its nature,

00:16:23.600 --> 00:16:26.470
takes a huge amount of CPU,
huge amounts of RAM,

00:16:26.470 --> 00:16:29.360
and most importantly,
wants to actually take over

00:16:29.360 --> 00:16:32.300
your entire desktop and lock
your mouse into that window.

00:16:32.300 --> 00:16:35.240
So trying to debug a game on
a single CPU can be extremely

00:16:35.330 --> 00:16:37.240
difficult and cumbersome.

00:16:37.270 --> 00:16:40.370
You have to kind of change your
rendering code to put it into

00:16:40.370 --> 00:16:44.480
a window and share the RAM,
especially with huge symbols that you

00:16:44.480 --> 00:16:47.060
get with some of these large projects.

00:16:47.060 --> 00:16:47.060
So one of the things that we've
been working on is that we've

00:16:47.060 --> 00:16:47.100
been working on a lot of things
that we've been working on.

00:16:47.100 --> 00:16:47.100
And one of the things that we've been
working on is that we've been working

00:16:47.100 --> 00:16:47.100
on is that we've been working on a lot
of things that we've been working on.

00:16:47.100 --> 00:16:47.100
And one of the things that we've
been working on is that we've

00:16:47.100 --> 00:16:48.720
been working on a lot of things
that we've been working on.

00:16:48.720 --> 00:16:50.850
And one of the things that we've
been working on is that we've

00:16:50.850 --> 00:16:52.990
been working on a lot of things
that we've been working on.

00:16:52.990 --> 00:16:54.960
So one of the features
that Xcode 1.5 provides,

00:16:54.960 --> 00:16:56.650
we've been playing with
for the last week or so,

00:16:56.660 --> 00:16:57.840
is cross-machine debugging.

00:16:57.840 --> 00:16:59.760
What we're going to show you
here is running the game,

00:16:59.840 --> 00:17:01.600
Tron 2.0,
on one machine while debugging it

00:17:01.610 --> 00:17:02.970
on a completely different machine.

00:17:03.010 --> 00:17:06.060
Now, Chris Friesen has been intensively
training in the Tron 2.0 light cycle

00:17:06.060 --> 00:17:07.570
game over the course of the lunch break.

00:17:07.570 --> 00:17:09.820
And he's going to demonstrate
the results of that training.

00:17:09.820 --> 00:17:11.920
Please, Chris, go ahead.

00:17:11.920 --> 00:17:16.520
We have sound on the game machine?

00:17:35.360 --> 00:17:37.840
Now, you know, I believe,
I was watching Chris train,

00:17:37.840 --> 00:17:41.390
I believe this problem is not,
it's not that Chris didn't train enough.

00:17:41.400 --> 00:17:44.560
The problem here is really
something very different.

00:17:44.560 --> 00:17:47.660
Something that you wouldn't
necessarily expect on a light cycle.

00:17:47.660 --> 00:17:49.960
But I think Chris is going to go here,
he's going to show you the

00:17:49.960 --> 00:17:51.280
character he was set up to play.

00:17:51.280 --> 00:17:55.140
And clearly the problem here is
that his character had spiky hair.

00:17:55.140 --> 00:17:57.340
It was impeding the
airflow in the light cycle,

00:17:57.340 --> 00:17:58.620
it just wasn't working.

00:17:58.620 --> 00:18:01.560
So we're going to switch over to,
actually we're not going

00:18:01.560 --> 00:18:03.010
to switch over quite yet.

00:18:03.450 --> 00:18:05.630
What I'm going to do here is
I'm actually going to go on this

00:18:05.640 --> 00:18:07.340
machine and activate a breakpoint.

00:18:07.360 --> 00:18:08.570
All right.

00:18:09.990 --> 00:18:11.390
You'll see that the game
machine has stopped.

00:18:11.390 --> 00:18:15.140
And let's switch over to the
debugger machine for a moment.

00:18:15.250 --> 00:18:18.620
And what we're going to see on the
debugger machine is the actual code

00:18:18.620 --> 00:18:21.570
that's executing at this point,
which is in the middle of

00:18:21.570 --> 00:18:24.960
Transgaming's proprietary
Direct3D rendering technology,

00:18:24.960 --> 00:18:29.480
which allows us to take games written for
Win32 and bring them to other platforms.

00:18:29.520 --> 00:18:33.140
And we've got a little extra piece of
code here that I added that can deal

00:18:33.140 --> 00:18:35.030
with the whole spiky hair problem.

00:18:35.140 --> 00:18:37.380
If a certain kind of
rendering is happening,

00:18:37.380 --> 00:18:39.800
we're just going to mask it right out.

00:18:41.550 --> 00:18:47.790
All right, so let me go back to the
breakpoints and disable that one.

00:18:47.790 --> 00:18:47.790
And let's go back to the game machine.

00:18:52.300 --> 00:19:12.800
[Transcript missing]

00:19:16.400 --> 00:19:19.400
Remote debugging is also extremely
important when you're on two machines.

00:19:19.400 --> 00:19:20.540
Was there one other thing?

00:19:20.540 --> 00:19:21.030
I'm sorry?

00:19:21.040 --> 00:19:22.790
Was there one other thing?

00:19:22.800 --> 00:19:23.660
There is one other thing.

00:19:23.660 --> 00:19:25.840
It's going to take us a
second to get it ready.

00:19:25.840 --> 00:19:28.840
We'll run that right
before your next demo.

00:19:29.080 --> 00:19:30.300
Great.

00:19:30.430 --> 00:19:33.660
So remote debugging,
numerous other features

00:19:33.660 --> 00:19:35.380
in terms of globals,
support,

00:19:35.480 --> 00:19:40.200
being able to set arbitrary expressions,
and a host of interesting features

00:19:40.200 --> 00:19:43.360
you'll see as well in the 2.0 demo.

00:19:43.410 --> 00:19:47.500
So let's go to Tron level 2-- I mean,
Xcode level 2.

00:19:48.890 --> 00:19:53.910
So, a very big part of what people
care about is to be able to launch

00:19:53.910 --> 00:19:57.360
quickly into their application
and quickly over to Xcode.

00:19:57.360 --> 00:20:00.770
And you want to actually see
Xcode laid out in a way that's

00:20:00.770 --> 00:20:02.250
similar and very good for you.

00:20:02.330 --> 00:20:07.410
And so we've added a number of
important new layouts that are extremely

00:20:07.410 --> 00:20:10.640
familiar for people from both the
Visual Studio and Code Warrior worlds.

00:20:10.640 --> 00:20:17.520
We also saw earlier today Andreas Venker
give the modeling with the database.

00:20:17.680 --> 00:20:20.830
That same modeling technology is
also available for object-oriented

00:20:20.830 --> 00:20:24.390
programming for Java,
Objective-C, C, C++.

00:20:24.480 --> 00:20:27.360
And we think that's going to
be a very big help to you,

00:20:27.430 --> 00:20:30.240
even if you're not doing
database programming.

00:20:30.240 --> 00:20:35.000
That's on the front end.

00:20:35.000 --> 00:20:35.000
In the back end,

00:20:36.350 --> 00:20:41.430
We've added support for
GCC 3.5 and 64-bit tools.

00:20:41.430 --> 00:20:45.610
GCC 3.5 is the next generation of GCC,
and it has some amazing

00:20:45.610 --> 00:20:48.820
performance features,
some of which are being innovated

00:20:48.940 --> 00:20:51.400
by Apple and IBM working together.

00:20:51.490 --> 00:20:56.970
And 64-bit support,
so that you can generate and take

00:20:57.080 --> 00:20:59.780
advantage of the full address space.

00:20:59.780 --> 00:20:59.780
I'm going to spend some
time talking about that,

00:20:59.780 --> 00:20:59.780
too.

00:21:00.140 --> 00:21:04.660
They're also important new performance
tools and some incredible SDKs that Xcode

00:21:04.660 --> 00:21:07.970
is essentially the gateway to get to.

00:21:09.090 --> 00:21:12.940
The traditional Xcode layout is all
very nice and compact and very neat.

00:21:12.940 --> 00:21:15.510
And it has a number of great features.

00:21:15.620 --> 00:21:19.050
But one of the things, of course,
is to have the debugger,

00:21:19.050 --> 00:21:21.860
you have to open up a separate window.

00:21:21.860 --> 00:21:23.610
And that kind of takes
your mind away from it.

00:21:23.920 --> 00:21:26.900
Here we're looking at the console window.

00:21:26.900 --> 00:21:29.530
Oftentimes to actually see it,
you're then doing your

00:21:29.530 --> 00:21:30.860
own window management.

00:21:30.860 --> 00:21:34.020
And one of the things that's very
popular on the Microsoft platform,

00:21:34.020 --> 00:21:36.750
Visual Studio World,
is an all-in-one view where

00:21:36.750 --> 00:21:38.920
everything is nice and compact.

00:21:38.920 --> 00:21:41.300
And so we've added this now to Xcode.

00:21:41.300 --> 00:21:46.010
You have a new all-in-one view
that essentially puts the debugger,

00:21:46.010 --> 00:21:51.620
all of the tools embedded within
the tiling frame of Xcode.

00:21:51.620 --> 00:21:56.800
But of course, it's important to have
an easy way to switch.

00:21:56.800 --> 00:22:00.410
You'll see that there's a new toolbar
up on the top to be able to rapidly

00:22:00.410 --> 00:22:03.460
switch function from one to the other.

00:22:04.070 --> 00:22:07.300
The other important side of things
is this idea of a condensed view.

00:22:07.350 --> 00:22:09.740
People familiar with
Code Warrior will have many,

00:22:09.740 --> 00:22:12.660
many windows spawned off
of a central palette.

00:22:12.830 --> 00:22:17.080
And that also is a new part
of what Xcode 2.0 supports.

00:22:17.160 --> 00:22:20.800
So these two incredible features,
I think, help.

00:22:21.130 --> 00:22:24.950
And why don't we take a look at
this and some other nifty features.

00:22:25.010 --> 00:22:27.760
Let's bring Matt Firlik
and Chris Espinosa up to

00:22:27.760 --> 00:22:29.620
give a demo of Xcode 2.0.

00:22:35.000 --> 00:22:36.170
Thanks, Ted.

00:22:36.490 --> 00:22:39.690
Xcode 1.5 and Xcode 2.0
are replete with features.

00:22:39.890 --> 00:22:42.090
We only have a short time today,
so Chris and I are going

00:22:42.090 --> 00:22:42.960
to demo two of them.

00:22:42.990 --> 00:22:45.520
But we encourage you to go to the rest
of the sessions this week to check

00:22:45.520 --> 00:22:47.790
out some of those additional features.

00:22:47.990 --> 00:22:50.760
In addition to being a standard IDE,
Xcode provides a number of

00:22:50.760 --> 00:22:53.640
facilities for dealing with
large problems that you have.

00:22:53.700 --> 00:22:56.090
Let's stick on the whole concept
of debugging for a moment.

00:22:56.100 --> 00:22:57.230
Global variables.

00:22:57.300 --> 00:22:59.420
Kind of a necessary evil when working.

00:22:59.420 --> 00:23:01.860
Everybody has them,
and even if you have more than

00:23:01.860 --> 00:23:04.540
those just in your application,
there are potentially thousands

00:23:04.540 --> 00:23:07.240
in all the shared libraries that
your application loads as being

00:23:07.300 --> 00:23:08.640
an application on Mac OS X.

00:23:08.640 --> 00:23:10.820
The question is,
how do you deal with those?

00:23:10.900 --> 00:23:11.880
How do you figure out the values?

00:23:11.880 --> 00:23:14.510
How do you keep track of those as
part of your development work cycle?

00:23:14.520 --> 00:23:17.190
New in Xcode,
we're providing the ability to look at

00:23:17.290 --> 00:23:20.570
global variables in your application
in a very simple and easy manner.

00:23:20.600 --> 00:23:23.040
What you'll see right now is
that Chris has launched an

00:23:23.190 --> 00:23:24.440
application called Celestia.

00:23:24.440 --> 00:23:28.300
It's a freely downloadable application
for looking at 3D renderings of,

00:23:28.320 --> 00:23:29.350
in this case, the universe.

00:23:29.360 --> 00:23:34.900
What we've done is set up a breakpoint
under the history option here.

00:23:34.900 --> 00:23:37.000
So we're going to go ahead and hit that,
and we're actually going to stop

00:23:37.080 --> 00:23:37.930
right in the middle of the debugger.

00:23:37.940 --> 00:23:39.790
Probably something you're
all very familiar with.

00:23:39.940 --> 00:23:41.510
But say at this point we
wanted to actually go and

00:23:41.510 --> 00:23:43.520
look at something interesting,
something in the sense

00:23:43.580 --> 00:23:44.760
of global variables.

00:23:44.840 --> 00:23:47.080
If you go and look up
under the debug menu,

00:23:47.080 --> 00:23:49.820
you'll now see there's a tools menu,
and we have something called

00:23:49.820 --> 00:23:51.110
the global variables browser.

00:23:51.120 --> 00:23:53.980
Chris is going to go ahead and make this
window a little bit bigger so we can see

00:23:53.980 --> 00:23:55.240
some of the more information in here.

00:23:55.240 --> 00:23:57.640
You see on the left-hand side,
we have a list of all the

00:23:57.640 --> 00:23:59.540
shared libraries that this
application knows about.

00:23:59.540 --> 00:24:02.310
And when Chris selects one,
the right-hand side is populated with

00:24:02.310 --> 00:24:04.040
information from that shared library.

00:24:04.040 --> 00:24:06.420
We can see the name of
the global variable,

00:24:06.420 --> 00:24:07.620
the file name, the value.

00:24:07.620 --> 00:24:11.360
These are all standard views that we can
go ahead and reorganize the column view,

00:24:11.360 --> 00:24:13.530
so we can take the file name out
of the way to look at something

00:24:13.580 --> 00:24:14.390
a little more interesting.

00:24:14.400 --> 00:24:16.120
But you can obviously
see an app kit here,

00:24:16.120 --> 00:24:19.670
we have a lot of symbols,
in this case 500 that we're looking at.

00:24:19.680 --> 00:24:21.700
Makes it kind of difficult
to find the ones you want,

00:24:21.770 --> 00:24:24.420
so we've included standard features
like a search field at the top.

00:24:24.420 --> 00:24:26.780
Chris could go ahead
and type in something,

00:24:26.780 --> 00:24:29.650
for example, NSF,
and go ahead and filter all those

00:24:29.700 --> 00:24:32.750
global variables down to the ones
that start with a common prefix.

00:24:32.750 --> 00:24:35.470
Something relatively easy to do,
but it makes it very easy

00:24:35.480 --> 00:24:36.840
to find something by name.

00:24:36.840 --> 00:24:39.600
Not necessarily as interesting,
let's go and look at something

00:24:39.600 --> 00:24:41.060
for the Celestra application.

00:24:41.060 --> 00:24:43.780
Chris can go ahead and click on that,
and we're going to load the symbols

00:24:43.780 --> 00:24:45.330
for the Celestra application.

00:24:45.780 --> 00:24:48.170
Once it's done populating,
Chris is going to have to go

00:24:48.200 --> 00:24:50.900
ahead and remove the search
field that he's typed in,

00:24:50.900 --> 00:24:54.270
so he can get the values back.

00:24:54.280 --> 00:24:56.700
Now that we see that,
let's go ahead and search on

00:24:56.700 --> 00:24:57.770
something more interesting.

00:24:57.770 --> 00:24:59.720
What if you don't actually know
the name of your global variable,

00:24:59.720 --> 00:25:01.210
but you know, for example, it's an int?

00:25:01.270 --> 00:25:03.840
We can go ahead and change the
search to look based on type,

00:25:03.840 --> 00:25:06.720
as you see here, and Chris is going to go
ahead and type in int,

00:25:06.720 --> 00:25:08.610
and now we can see,
you can actually go find the

00:25:08.610 --> 00:25:10.790
global variables by type,
making it very easy to go

00:25:10.790 --> 00:25:12.190
ahead and look at them.

00:25:12.190 --> 00:25:14.950
So we made it very easy to
deal with the concept of large

00:25:15.030 --> 00:25:16.960
amounts of global variables,
but how do you get this

00:25:16.970 --> 00:25:18.170
into your workflow?

00:25:18.200 --> 00:25:20.420
Well, you'll see that there's a nice
little column here called view,

00:25:20.420 --> 00:25:21.920
and you can go ahead and check those.

00:25:22.040 --> 00:25:24.680
Chris can go ahead and
select a couple of them.

00:25:24.680 --> 00:25:27.360
Once we do that, if you close the global
variables browser and go back

00:25:27.380 --> 00:25:30.410
to the standard debugger view,
you'll note in the variables display,

00:25:30.410 --> 00:25:33.140
there's an element called globals,
but now when he expands it,

00:25:33.140 --> 00:25:34.680
you'll see the global variables.

00:25:34.680 --> 00:25:37.910
So we're giving the facility to take
something as large as global variables

00:25:38.000 --> 00:25:41.080
and bring it down to a standard workflow.

00:25:43.060 --> 00:25:46.040
On the same concept of this,
let's talk about designs.

00:25:46.100 --> 00:25:48.400
Chris, you want to show them the
new design features of Xcode?

00:25:48.480 --> 00:25:49.650
Sure.

00:25:49.700 --> 00:25:50.020
Thanks, Matt.

00:25:50.040 --> 00:25:53.790
Now, you got a taste of the design
features this morning in Bertrand

00:25:53.880 --> 00:25:58.380
and Andreas' presentation when they
did the core data model for the

00:25:58.380 --> 00:26:00.300
core data framework presentation.

00:26:00.300 --> 00:26:04.530
This is a new feature of Xcode where
we are going to add design features

00:26:04.530 --> 00:26:09.180
throughout the workflow from the
beginning of your application design all

00:26:09.240 --> 00:26:11.120
the way through deployment and debugging.

00:26:11.260 --> 00:26:15.690
The first two plugins for design
are here on your Xcode 2.0 CD.

00:26:15.710 --> 00:26:17.740
You've already seen the
core data one this morning.

00:26:17.750 --> 00:26:20.490
We're going to show you the
class plugin this afternoon.

00:26:20.500 --> 00:26:22.360
Now,
what Matt's going to do is he's going

00:26:22.420 --> 00:26:25.680
to take this Celestia application,
and he's going to create a new

00:26:25.680 --> 00:26:29.190
class model of some of the classes
in the Celestia source code.

00:26:29.220 --> 00:26:31.720
So he picks a class model,
gives it a name.

00:26:31.740 --> 00:26:34.980
A class model is a project file
like any other project file.

00:26:34.980 --> 00:26:36.700
It's stored in your project directory.

00:26:36.700 --> 00:26:39.750
It's committed to your
subversion or CVS repository.

00:26:40.610 --> 00:26:44.270
He's going to pick a set of sources,
a folder,

00:26:44.360 --> 00:26:47.020
and he's going to make a tracking model.

00:26:47.180 --> 00:26:49.810
He's going to add that to his group.

00:26:52.340 --> 00:26:55.770
And now he has a model of
the sources in that folder.

00:26:55.980 --> 00:26:57.500
Now, these are the classes.

00:26:57.500 --> 00:27:00.860
Now, you've probably been familiar with
other applications that give you

00:27:00.860 --> 00:27:04.600
a snapshot or a bird's eye view of
the classes in your application.

00:27:04.600 --> 00:27:05.920
But it's pretty static.

00:27:05.920 --> 00:27:10.640
It's how the IDE communicates
with you what the classes are.

00:27:10.770 --> 00:27:13.810
What you can do with the design
tools in Xcode is you can use

00:27:13.860 --> 00:27:16.650
the class model to communicate
to other people what they are.

00:27:16.760 --> 00:27:18.680
So you can move these classes around.

00:27:18.700 --> 00:27:23.320
You can expand them or collapse them to
show their methods and their functions.

00:27:23.340 --> 00:27:27.370
And you can make the design look like
how you think the application works,

00:27:27.650 --> 00:27:30.900
save it with your project,
and then when other people download or

00:27:30.900 --> 00:27:34.330
check out your project and open it up,
they can explore it using the

00:27:34.410 --> 00:27:36.320
class model that you've created.

00:27:36.550 --> 00:27:38.460
Now, this is, of course,
wired to the project.

00:27:38.680 --> 00:27:42.500
What Matt's going to do is he's going
to select a method in one class.

00:27:42.710 --> 00:27:44.770
He's going to go straight
to the implementation.

00:27:44.810 --> 00:27:47.040
That's fairly easy and obvious.

00:27:47.100 --> 00:27:49.000
And he's going to go
back and using the menu,

00:27:49.040 --> 00:27:51.970
he's going to go to the
definition in the header file.

00:27:52.610 --> 00:27:56.490
and you can also,
because all of your classes may descend

00:27:56.500 --> 00:28:05.040
from classes in the Apple frameworks
which have documentation behind them,

00:28:05.040 --> 00:28:05.040
he can select a class and go
to its documentation in the

00:28:05.040 --> 00:28:05.040
online documentation instantly.

00:28:06.210 --> 00:28:09.220
You can go either to the object
itself or directly to the method

00:28:09.220 --> 00:28:11.180
of the property on the object.

00:28:11.220 --> 00:28:14.160
So these design features
are all built in.

00:28:15.540 --> 00:28:21.160
Now, you've seen what we can do
with modeling your classes,

00:28:21.160 --> 00:28:24.390
but you're probably wondering, hey,
why do I have to create a

00:28:24.660 --> 00:28:28.280
separate file and store it in the
repository and in the project?

00:28:28.280 --> 00:28:30.640
And you're probably
wondering about scalability.

00:28:30.640 --> 00:28:32.210
How does it do one really well?

00:28:32.360 --> 00:28:35.650
No, first what we're going to do
is show that it's tracking.

00:28:35.740 --> 00:28:36.410
It's live.

00:28:36.670 --> 00:28:37.860
It's connected to your project.

00:28:37.860 --> 00:28:41.200
So as you change your project,
the model changes with you.

00:28:41.360 --> 00:28:44.260
So what Matt's going to go do
now is he's going to add another

00:28:44.260 --> 00:28:48.400
folder of sources to the model,
and there they go.

00:28:48.610 --> 00:28:51.270
The design automatically updates.

00:28:53.100 --> 00:30:05.600
[Transcript missing]

00:30:11.620 --> 00:30:12.590
Thanks Matt and Chris.

00:30:12.590 --> 00:30:15.920
By the way, of course,
great use for that is put it

00:30:15.920 --> 00:30:19.590
up on the wall in the hallway,
your boss will think you're

00:30:19.590 --> 00:30:19.590
really doing something.

00:30:20.480 --> 00:30:25.200
You can find out more about that
Friday at 9:00 in the Modeling and

00:30:25.200 --> 00:30:28.330
Design in Xcode session in North Beach.

00:30:28.410 --> 00:30:30.730
So this is, I think,
one of the terrific new features.

00:30:30.750 --> 00:30:37.590
I think it's one of the starring
great things in Xcode 2.0,

00:30:37.590 --> 00:30:42.540
and a reason to use
both Xcode 2.0 and 1.5.

00:30:42.540 --> 00:30:42.540
Now let's turn our attention to
the compiler and the runtime.

00:30:43.430 --> 00:30:45.730
First,
let's give a little bit of a road map,

00:30:45.820 --> 00:30:47.960
because we throw a lot
of version numbers out,

00:30:48.040 --> 00:30:50.150
and if you're not on
the GCC mailing list,

00:30:50.150 --> 00:30:51.290
you may lose track.

00:30:51.360 --> 00:30:57.010
GCC 295 is really the oldest compiler
anybody is likely to be using,

00:30:57.010 --> 00:31:00.710
and it generated code for G3 and G4,
but it didn't generate any of

00:31:00.720 --> 00:31:02.530
those 64-bit G5 instructions.

00:31:02.540 --> 00:31:08.210
295 is a compiler that we keep around,
because it supports original

00:31:08.210 --> 00:31:10.900
10.1 text file format.

00:31:10.900 --> 00:31:13.730
But other than that,
there really is no great

00:31:13.730 --> 00:31:16.320
reason to be using 295 anymore.

00:31:16.580 --> 00:31:19.080
The last compiler,
not the current compiler,

00:31:19.080 --> 00:31:24.750
but the last compiler, is GCC 3.1,
and it too didn't generate code for G5.

00:31:24.970 --> 00:31:27.920
The next compiler,
the current compiler that

00:31:27.930 --> 00:31:30.520
everyone should be using,
is GCC3.3.

00:31:30.630 --> 00:31:33.400
And it has great support
for optimization,

00:31:33.400 --> 00:31:35.460
great support for the G5.

00:31:35.630 --> 00:31:39.720
And so with this coming release,
we're going to obsolete some compiler.

00:31:39.910 --> 00:31:42.310
Now,
I'd like to obsolete both 295 and 31,

00:31:42.570 --> 00:31:46.670
but some people still want
to ship on 10.1 kecks.

00:31:47.000 --> 00:31:51.390
So what we're going to do is we're
going to get rid of the 31 compiler,

00:31:51.510 --> 00:31:56.830
and we're going to have the
GCC295 to be download only.

00:31:56.960 --> 00:32:00.820
And we think that that's a
reasonable compromise for things.

00:32:00.940 --> 00:32:04.980
So the current compiler, 3.3,
is the best -- is the compiler we

00:32:04.980 --> 00:32:07.020
should be using for shipping products.

00:32:07.150 --> 00:32:09.710
And this makes room for GCC3.5.

00:32:09.800 --> 00:32:11.560
This is the leading edge compiler.

00:32:11.640 --> 00:32:15.400
This compiler has terrific
new optimization features,

00:32:15.400 --> 00:32:17.090
a brand new C++ parser.

00:32:17.210 --> 00:32:20.810
It has also support for long doubles.

00:32:20.970 --> 00:32:24.780
And 3.5 really is where most of
the attention is happening in

00:32:24.800 --> 00:32:27.240
the Free Software Foundation,
the GCC community.

00:32:27.340 --> 00:32:31.340
And if you look at it,
3.5 is really something you

00:32:31.450 --> 00:32:33.330
want to start getting into.

00:32:33.490 --> 00:32:34.830
Give us some feedback on it now.

00:32:35.090 --> 00:32:38.290
We're putting it on the developer
tools distribution so that

00:32:38.290 --> 00:32:40.550
you can begin working with it.

00:32:40.670 --> 00:32:43.190
But of course, it's only in preview mode.

00:32:43.580 --> 00:32:47.270
The big lifting in 3.5 is in
the performance improvements.

00:32:47.300 --> 00:32:53.310
And we're totally retrofitting
the optimization technology.

00:32:53.320 --> 00:32:55.130
Something called single
static assignment.

00:32:55.200 --> 00:33:00.580
SSA form is really the
professional and best way to do

00:33:00.580 --> 00:33:01.700
code generation optimization.

00:33:01.700 --> 00:33:04.820
It's a little bit like register renaming,
for those of you who are

00:33:04.820 --> 00:33:06.210
familiar with the hardware world.

00:33:06.910 --> 00:33:09.980
And what it does is essentially
treats every expression that is

00:33:09.980 --> 00:33:16.360
computable as a separate arithmetic
expression inside the compiler.

00:33:16.360 --> 00:33:20.300
And the compiler can then do incredibly
good scheduling and overlapping and such.

00:33:20.300 --> 00:33:24.760
That also gives you the ability
to have very fine-grained control.

00:33:24.760 --> 00:33:27.780
And another terrific feature
called auto-vectorization.

00:33:29.230 --> 00:33:32.760
We heard a lot this morning
about the GPU processing.

00:33:32.800 --> 00:33:36.490
In fact, as well, the PowerPC, of course,
also has in it the AlteVec

00:33:36.510 --> 00:33:38.230
Velocity Engine Processor.

00:33:38.230 --> 00:33:43.680
And that allows us to have this
additional processing in parallel,

00:33:43.790 --> 00:33:47.410
in addition to the GPU, but on chip,
this terrific capability.

00:33:47.660 --> 00:33:50.800
Now, previously,
in order to take advantage of AlteVec,

00:33:50.820 --> 00:33:52.940
you had to handwrite your own intrinsics.

00:33:52.940 --> 00:33:56.100
You had to write, essentially,
very low-level instructions and do

00:33:56.210 --> 00:34:01.720
the formatting for your instructions
so that all of your data types began

00:34:01.720 --> 00:34:04.540
and ended on a 16-byte boundary.

00:34:04.540 --> 00:34:07.010
But with autovectorization,
we essentially say, hey,

00:34:07.010 --> 00:34:08.310
let's let the compiler do it.

00:34:08.350 --> 00:34:10.440
The compiler can worry
about those details.

00:34:10.440 --> 00:34:13.790
And so, instead of having to write the
autovectorizing code yourself,

00:34:13.800 --> 00:34:17.490
the autovectorizer converts
the code and operates it.

00:34:17.660 --> 00:34:20.120
And identifies your most common loops.

00:34:20.120 --> 00:34:22.380
It works best with memory-aligned data.

00:34:22.380 --> 00:34:25.920
So, if you can structure it so
that your blocks of memory

00:34:25.920 --> 00:34:29.740
are on 16-byte-aligned chunks,
that's terrific.

00:34:29.740 --> 00:34:31.690
But it doesn't have to be.

00:34:31.690 --> 00:34:37.000
And there are annotations to tell GCC to
go and try to keep the beginning of a

00:34:37.030 --> 00:34:40.470
data structure on a 16-byte alignment.

00:34:40.480 --> 00:34:42.110
But that's not always possible.

00:34:42.110 --> 00:34:45.160
The compiler will compensate and
put in the correct prologue and

00:34:45.160 --> 00:34:46.840
epilogue code for those loops.

00:34:46.840 --> 00:34:47.620
So, what's the problem?

00:34:47.660 --> 00:34:48.090
What's the payoff?

00:34:48.100 --> 00:34:52.830
Well, at the time I made these slides,
we were able to execute these

00:34:52.840 --> 00:34:55.650
types of instructions in parallel.

00:34:55.660 --> 00:34:59.610
When you have these kinds of arithmetic
expressions inside of a loop,

00:34:59.640 --> 00:35:02.320
we can see anywhere
from a 4x improvement,

00:35:02.320 --> 00:35:07.620
4x of a vector of values
being executed in parallel,

00:35:07.620 --> 00:35:10.120
up to 12 and even 14x.

00:35:10.120 --> 00:35:14.420
In fact, some late-breaking data,
some tests that I just read this morning,

00:35:14.420 --> 00:35:17.310
have it up to 20x
performance improvement.

00:35:17.620 --> 00:35:20.500
So, really amazing,
amazing improvement that you can get

00:35:20.500 --> 00:35:22.740
from auto-vectorization for some codes.

00:35:22.740 --> 00:35:25.130
And we think that you're going to
like using this feature because

00:35:25.130 --> 00:35:26.470
it's really very simple to use.

00:35:26.480 --> 00:35:27.940
You just enable it with one checkbox.

00:35:27.940 --> 00:35:29.760
So, that's auto-vectorization.

00:35:32.350 --> 00:35:34.940
Now, let's turn our attention to 64-bit.

00:35:35.050 --> 00:35:39.200
64-bit is something that we had, in fact,
on Panther.

00:35:39.200 --> 00:35:42.290
It's part of the G5,
access to greater than

00:35:42.290 --> 00:35:44.020
4 gigabytes of RAM.

00:35:44.020 --> 00:35:50.820
But we also gave this flag in GCC,
in Xcode, to compile for G5 architecture.

00:35:50.820 --> 00:35:57.290
And this actually gives you, from C, C++,
Objective-C source code,

00:35:57.290 --> 00:36:00.200
to 64-bit arithmetic operations.

00:36:00.950 --> 00:36:03.590
So long-longs can already
fit in one register.

00:36:03.600 --> 00:36:07.510
And we think that this is
already something that you

00:36:07.510 --> 00:36:10.900
should be using on G5s,
even today on Panther.

00:36:12.300 --> 00:36:15.460
But what do we actually
need with 64-bit memory?

00:36:15.610 --> 00:36:20.710
Why do you want to break the 64,
the 4-gigabyte barrier?

00:36:20.830 --> 00:36:23.500
And we think, in fact,
that a great many applications,

00:36:23.500 --> 00:36:28.600
certainly those eight megapixel displays,
are going to give you lots of opportunity

00:36:28.600 --> 00:36:30.960
to display all this great data,
all this supervision.

00:36:31.270 --> 00:36:33.680
So,
all of a sudden now new vistas of media,

00:36:33.680 --> 00:36:37.840
genomics, proteomics, medical,
engineering and one of my favorite,

00:36:37.840 --> 00:36:41.010
geo-spatial applications,
now become possible.

00:36:41.130 --> 00:36:44.940
Not to say that we didn't already
have techniques for sliding through

00:36:45.120 --> 00:36:49.670
larger than four gigabytes of data,
but it was cumbersome and awkward.

00:36:49.780 --> 00:36:52.980
So,
I'd like to have Steve Peters give you

00:36:53.050 --> 00:36:56.180
a demo of a geo-spatial application.

00:36:56.870 --> 00:36:58.580
Ken, we have this demo machine.

00:37:04.690 --> 00:37:06.540
Ted, we're looking at TerraVision.

00:37:06.550 --> 00:37:10.160
It's an open source app that
I downloaded from the net.

00:37:10.310 --> 00:37:14.270
TerraVision is a visualization
app for terrain data,

00:37:14.380 --> 00:37:15.890
and lets you see terrain data in 3D.

00:37:16.910 --> 00:37:21.880
It's a 32-bit application that
takes advantage of a variety of

00:37:22.000 --> 00:37:23.710
Mac OS X graphics frameworks.

00:37:23.840 --> 00:37:28.640
Behind the scenes,
there's a 64-bit service application,

00:37:28.640 --> 00:37:30.330
a service process.

00:37:30.410 --> 00:37:36.000
I built that using the Tiger Preview
and the tool chain and Lib C,

00:37:36.000 --> 00:37:37.580
readied for 64 bits.

00:37:37.580 --> 00:37:41.460
Sure, let's give it a go.

00:37:44.670 --> 00:37:47.560
So this is a computation, not a movie.

00:37:47.640 --> 00:37:52.170
And as we move through this data set,
we'll encounter more and more

00:37:52.170 --> 00:37:57.040
complicated terrain pieces,
going from topographical data,

00:37:57.040 --> 00:38:01.720
Yosemite shimmering off to the east,
Landsat data around the Bay Area,

00:38:01.730 --> 00:38:05.770
and finally this patch of high
altitude aircraft imagery data,

00:38:05.890 --> 00:38:09.280
which gets us down to a
resolution of about a meter.

00:38:09.280 --> 00:38:12.440
Anybody recognize that
feature in the Mid Bay?

00:38:12.440 --> 00:38:14.160
That's Stanford Stadium.

00:38:14.790 --> 00:38:17.500
and we'll swing around to
see... I think that's my house.

00:38:17.500 --> 00:38:26.930
Yeah, University of Palo Alto,
you can see the Apple store down there.

00:38:26.930 --> 00:38:29.030
I always wanted to visit Stanford,
so we'll roll up this way and see the

00:38:29.030 --> 00:38:29.030
main academic quad and Palm Drive.

00:38:29.420 --> 00:38:34.410
Little run up to the dish,
this is where the radio

00:38:34.410 --> 00:38:34.410
astronomy towers are sited.

00:38:36.410 --> 00:38:41.350
and then we'll sprint down,
actually sprint north, towards Slack.

00:38:41.680 --> 00:38:43.600
In the foreground are
the experimental halls,

00:38:43.600 --> 00:38:48.230
and then the linear accelerator running
off two kilometers into the background.

00:38:48.350 --> 00:38:50.280
And there's this curious
feature about Slack.

00:38:50.320 --> 00:38:53.240
It passes under Highway 280.

00:38:54.650 --> 00:38:57.510
So I'd like to acknowledge
the creators of TeraVision,

00:38:57.510 --> 00:39:00.290
Martin Reddy, Yvonne LeClercq,
and Lee Iverson.

00:39:00.370 --> 00:39:03.000
They did this at SRI a few years ago.

00:39:03.000 --> 00:39:06.560
And the take-home message here is,
with Tiger Preview,

00:39:06.560 --> 00:39:10.870
you can start to experiment with
application architectures that

00:39:10.990 --> 00:39:16.010
employ 64-bit service processes
like the ones we've shown you today.

00:39:16.010 --> 00:39:18.910
Check it out,
see if your app would benefit

00:39:18.910 --> 00:39:22.600
from some 64-bit goodness,
and enjoy the ride.

00:39:22.600 --> 00:39:23.200
Thanks.

00:39:23.340 --> 00:39:24.590
You bet, Ted.

00:39:32.380 --> 00:39:35.020
64-bit addressing in
Tiger essentially gives you

00:39:35.190 --> 00:39:36.860
access to much larger data sets.

00:39:36.860 --> 00:39:38.190
How large?

00:39:38.210 --> 00:39:45.780
Well, you can learn more about it,
by the way, on Wednesday at 10.30 a.m.

00:39:45.780 --> 00:39:48.720
in Presidio with the Programming
for Mac OS X session on 64-bit.

00:39:48.720 --> 00:39:50.640
We're doing a staged rollout.

00:39:50.680 --> 00:39:54.080
So initially, we're focusing on the
lib system functionality,

00:39:54.140 --> 00:39:55.120
the basic I.O.

00:39:55.120 --> 00:39:58.140
capabilities that you need,
and the capabilities to map

00:39:58.140 --> 00:40:02.020
it from a 32-bit address space
into a 64-bit address space.

00:40:03.430 --> 00:40:04.400
and many more.

00:40:04.400 --> 00:40:07.160
64-bit is an amazing number,
and if you're a geek like me,

00:40:07.220 --> 00:40:08.340
you love big numbers.

00:40:08.340 --> 00:40:09.780
How big is 2 to the 64?

00:40:09.780 --> 00:40:11.830
Well, it's 16 exabytes.

00:40:11.830 --> 00:40:13.620
It's that large number,
which I'm not going to read,

00:40:13.620 --> 00:40:15.400
or 18 times 10 to the 18th.

00:40:15.400 --> 00:40:17.460
And here,
your scientific training in exponential

00:40:17.460 --> 00:40:19.680
numbers is going to come in very handy.

00:40:19.710 --> 00:40:23.570
Really, it's -- having access to
these much larger data sets

00:40:23.640 --> 00:40:27.900
really is going to change,
to some extent, the way you think about

00:40:28.000 --> 00:40:29.920
data and data management.

00:40:30.100 --> 00:40:33.510
And what you just saw in the application
that Steve demonstrated is essentially

00:40:33.540 --> 00:40:36.200
we have a 32-bit GUI front end,
right?

00:40:36.610 --> 00:40:39.720
But it talks to a 64-bit
service address space.

00:40:39.740 --> 00:40:42.660
That service address space can
do a lot of the heavy lifting.

00:40:42.660 --> 00:40:45.170
It can access a uniform
memory environment.

00:40:45.230 --> 00:40:47.850
But the 32-bit address space
essentially is mapping in the data

00:40:48.050 --> 00:40:50.080
structures that are needed to present.

00:40:50.130 --> 00:40:52.610
Because, in fact, frankly,
there really is no great benefit

00:40:52.650 --> 00:40:55.750
to doubling the size of a
pointer that points to a window.

00:40:55.780 --> 00:40:59.280
There's only benefit to be derived
from a window that points into your

00:40:59.450 --> 00:41:01.280
memory that has your actual data in it.

00:41:01.350 --> 00:41:04.120
And so we believe that this is
a very convenient architecture.

00:41:04.120 --> 00:41:06.100
It's one that's extremely scalable.

00:41:06.170 --> 00:41:09.400
And it's one that gives you the benefits
of 64-bit without having to have to

00:41:09.400 --> 00:41:15.080
take the big plunge to port your entire
application from 32-bit to 64-bit.

00:41:15.080 --> 00:41:17.610
So this is what we mean by
kind of a scalable architecture

00:41:17.810 --> 00:41:19.140
for 64-bit computing.

00:41:19.160 --> 00:41:21.350
And as you can see,
we've already demonstrated that it

00:41:21.350 --> 00:41:23.690
actually works and does actually
give great performance today.

00:41:25.550 --> 00:41:27.780
I want to actually talk a
little bit about the future,

00:41:27.850 --> 00:41:30.120
because I believe that
64-bit has some incredibly

00:41:30.120 --> 00:41:31.870
interesting emergent properties.

00:41:31.880 --> 00:41:36.420
When we made the transition
from 16-bit data to 32-bit data,

00:41:36.420 --> 00:41:40.500
it's not that we all of a sudden had
the capabilities to do object-oriented

00:41:40.570 --> 00:41:44.090
programming and computer graphics
in an incredibly intense way.

00:41:44.120 --> 00:41:46.890
And that transition,
it's not to say that you couldn't

00:41:46.890 --> 00:41:50.400
do object-oriented programming
in a 16-bit address space.

00:41:50.400 --> 00:41:52.440
It just wasn't all that
useful or necessary.

00:41:53.020 --> 00:41:54.700
Applications didn't have
to scale that large.

00:41:54.760 --> 00:41:57.230
The functionality wasn't
all that impressive.

00:41:57.240 --> 00:41:59.960
Going from a 16-bit
space to a 32-bit space,

00:42:00.030 --> 00:42:03.150
all of a sudden now,
certain capabilities and technologies

00:42:03.150 --> 00:42:04.880
became very easy and uniform.

00:42:05.000 --> 00:42:07.070
And I believe the same
thing will happen now.

00:42:07.120 --> 00:42:10.550
As we move from 32-bit
space into 64-bit space,

00:42:10.760 --> 00:42:13.360
now we have amazing,
amazing capabilities to

00:42:13.360 --> 00:42:15.410
access just a breadth of data.

00:42:15.460 --> 00:42:17.890
And so I think of this
as kind of a supervision,

00:42:17.890 --> 00:42:18.480
right?

00:42:18.480 --> 00:42:21.760
We have this ability now to look at
scales of the universe and of data,

00:42:22.100 --> 00:42:26.000
to make seamless transitions
between data sets so that,

00:42:26.070 --> 00:42:29.860
in fact, you know, your locality search,
say, instead of Google being, you know,

00:42:29.900 --> 00:42:32.250
a zip code, you just pinpoint where
you are on the globe,

00:42:32.260 --> 00:42:34.490
zoom in, there you are, okay,
what's there?

00:42:34.500 --> 00:42:37.690
It's so,
it's going to unlock incredible vistas.

00:42:37.700 --> 00:42:40.460
And I'd love to see the
applications you folks are going

00:42:40.460 --> 00:42:44.000
to develop with the 64-bit tools
we're providing to you today.

00:42:44.020 --> 00:42:45.740
That's 64-bit.

00:42:48.060 --> 00:42:49.460
Let's talk about the
next generation runtime.

00:42:49.460 --> 00:42:51.660
Again, this is a little forward-looking.

00:42:51.660 --> 00:42:53.900
We are working on garbage collection.

00:42:53.900 --> 00:42:56.140
Why do you want garbage collection?

00:42:56.150 --> 00:43:00.570
Well, it simplifies coding,
especially in a multi-threaded

00:43:00.610 --> 00:43:03.540
world where events are
generated both by the network,

00:43:03.540 --> 00:43:08.390
by the user, by perhaps other people,
and it can improve correctness of

00:43:08.390 --> 00:43:12.070
your applications and improve the
memory efficiency of what you're doing.

00:43:12.080 --> 00:43:15.440
So what we've been cooking up in
the lab is semi-automatic memory

00:43:15.440 --> 00:43:16.860
management for Objective-C.

00:43:17.320 --> 00:43:17.850
It's fast.

00:43:17.850 --> 00:43:19.070
It has very low latency.

00:43:19.080 --> 00:43:20.640
It's designed for
interactive applications,

00:43:20.640 --> 00:43:22.390
and it's optional.

00:43:22.400 --> 00:43:23.970
You don't have to use it.

00:43:24.050 --> 00:43:26.940
On a per-application basis,
you can either enable

00:43:26.940 --> 00:43:28.180
it or not enable it.

00:43:28.180 --> 00:43:30.900
It's binary compatible with the
frameworks that we'll be shipping,

00:43:30.900 --> 00:43:37.220
and we believe that applications
should begin experimenting with this.

00:43:37.220 --> 00:43:40.240
It's kind of a rad feature
when it comes out in Tiger,

00:43:40.240 --> 00:43:44.860
so we really don't understand yet
the complete balance yet between

00:43:44.860 --> 00:43:49.380
high-performance applications and...
the amount of memory footprint it has.

00:43:49.430 --> 00:43:52.320
So this is something where
we'll be making this technology

00:43:52.320 --> 00:43:55.810
available in the Tiger timeframe,
and I think it's going

00:43:55.810 --> 00:43:58.220
to be very interesting,
but this is not a journey

00:43:58.220 --> 00:43:59.660
that lasts in one year,
right?

00:43:59.660 --> 00:44:01.940
This is something that we will
explore together to figure out

00:44:01.940 --> 00:44:04.970
different ways to tune this technology,
but I believe it's going to make a

00:44:04.970 --> 00:44:11.300
very big improvement to productivity
and debugging of applications.

00:44:11.300 --> 00:44:15.100
Instead of having to do sort of the
retained release style programming that

00:44:15.100 --> 00:44:19.540
we do today in Objective-C and C++,
we will have techniques there that say,

00:44:19.540 --> 00:44:21.730
you know what, memory,
when it's no longer being

00:44:21.730 --> 00:44:24.110
referenced by anyone,
it can just be... the garbage

00:44:24.110 --> 00:44:25.110
collector will reclaim it.

00:44:25.120 --> 00:44:29.520
So this is cooking up in the labs,
and I'm very excited by this.

00:44:29.560 --> 00:44:30.710
Thank you.

00:44:32.450 --> 00:44:35.530
The other side of things
is performance tools.

00:44:35.620 --> 00:44:40.000
So performance tools we provide help
you make your application great.

00:44:40.170 --> 00:44:42.950
One of my favorite
performance tools is Shark.

00:44:43.210 --> 00:44:44.000
What is Shark?

00:44:44.100 --> 00:44:45.720
Shark is a multi-purpose tool.

00:44:45.720 --> 00:44:48.710
We've enhanced it with functionality,
merging in capabilities

00:44:48.710 --> 00:44:51.320
such as sampler into Shark,
and what it does is it

00:44:51.390 --> 00:44:53.920
profiles everything,
all the way from the device driver

00:44:53.980 --> 00:44:56.020
level to the kernel to the applications.

00:44:56.020 --> 00:44:58.780
It has extremely low overhead,
and it works both in a

00:44:58.780 --> 00:45:00.230
static and a dynamic way.

00:45:00.230 --> 00:45:03.180
It annotates the source code
and the disassembly code,

00:45:03.180 --> 00:45:05.380
and it gives you optimization tips.

00:45:05.380 --> 00:45:09.290
So let's bring on Nathan Singleton
and Sanjay Patel to give

00:45:09.290 --> 00:45:11.120
us a quick demo of Shark.

00:45:13.100 --> 00:45:13.510
Thanks, Ted.

00:45:17.100 --> 00:45:18.520
Good afternoon.

00:45:18.590 --> 00:45:21.220
I'm really proud to announce
that we have a preview version of

00:45:21.240 --> 00:45:24.530
Shark on your Tiger preview disks,
and we're also going to be

00:45:24.530 --> 00:45:27.910
available shortly off the FTP site
with a new version of Shark.

00:45:27.910 --> 00:45:33.720
And what I'd like to do is just
demo some of the features in Shark.

00:45:33.720 --> 00:45:39.050
I think the best way to do that
is with an open source application

00:45:39.240 --> 00:45:41.730
that we think was rather cool.

00:45:41.730 --> 00:45:41.730
We found it out on the web.

00:45:41.730 --> 00:45:41.730
It's called Celestia.

00:45:42.100 --> 00:45:58.900
[Transcript missing]

00:46:00.120 --> 00:46:02.060
So here's Celestia running.

00:46:02.120 --> 00:46:04.880
And what you have to do if
you're going to optimize for

00:46:04.880 --> 00:46:06.360
performance is add a little metric.

00:46:06.400 --> 00:46:10.850
So we decided to figure out how long
it takes to run through this demo.

00:46:10.900 --> 00:46:13.110
And now if we launch Shark--

00:46:13.370 --> 00:46:16.050
You can see that we've added
lots of features to Shark,

00:46:16.050 --> 00:46:20.100
but the main thing we had to do was make
sure that it was still very easy to use.

00:46:20.140 --> 00:46:24.690
And the default workflow for most people
is simply to hit the Start button.

00:46:25.830 --> 00:46:28.060
So right now we're actually
taking samples of the system.

00:46:28.060 --> 00:46:33.220
So we're sampling not only Celestia,
all the running processes on the system,

00:46:33.220 --> 00:46:35.860
by default, once per millisecond.

00:46:35.860 --> 00:46:38.850
If we had stopped,
we're now going to process all

00:46:38.850 --> 00:46:40.770
those samples that we took.

00:46:42.270 --> 00:46:44.840
You can see by default we've
gotten what we call the heavy view,

00:46:44.910 --> 00:46:49.950
and this is ordered from time
spent in the topmost function down.

00:46:50.010 --> 00:46:57.550
Now you can also look and see that
we've sampled the entire system.

00:46:57.550 --> 00:46:57.550
Celestia is taking up a little less than
half of the CPU cycles on this system.

00:46:58.020 --> 00:47:01.290
You can see we have a thread pop-up to
show you all your threads of execution.

00:47:01.340 --> 00:47:02.870
Celestia is single-threaded.

00:47:02.870 --> 00:47:05.660
That explains why it's not
getting all of the CPU resources

00:47:05.660 --> 00:47:07.110
on a dual-processor Mac.

00:47:07.440 --> 00:47:11.330
Now we can also look at Celestia
in the more traditional tree view,

00:47:11.330 --> 00:47:15.070
so you can see your code executing
all the way from main down.

00:47:15.620 --> 00:47:18.320
New for Shark 4.0,
you can actually view heavy

00:47:18.370 --> 00:47:20.610
and tree simultaneously.

00:47:21.560 --> 00:47:23.300
So that was a big request.

00:47:23.340 --> 00:47:26.280
We've added what we call
data mining features as well.

00:47:26.360 --> 00:47:29.950
So we get a contextual menu,
as well as this side drawer,

00:47:29.960 --> 00:47:33.750
which lets you filter out things
that you don't want to see.

00:47:33.840 --> 00:47:36.500
For example, the system libraries.

00:47:38.320 --> 00:47:40.570
You can also color your code,
so it's very easy to figure

00:47:40.570 --> 00:47:42.240
out where you're spending time.

00:47:42.240 --> 00:47:46.960
Now one area we've really
improved is the chart view.

00:47:47.600 --> 00:47:50.300
So this is a chronological view
of your program's execution.

00:47:50.300 --> 00:47:53.200
In this case, we have two processors,
so we have two charts.

00:47:53.360 --> 00:47:55.500
Now we know that Celestia is
single-threaded at this point,

00:47:55.510 --> 00:47:58.340
so let's just focus in on
its one thread of execution,

00:47:58.390 --> 00:47:59.770
chronologically.

00:47:59.830 --> 00:48:03.300
Now a big feature we added
was this Zoom slider.

00:48:05.020 --> 00:48:06.400
So you can zoom in and out.

00:48:06.400 --> 00:48:10.930
If you click on the stack,
so along the x-axis we have time,

00:48:10.930 --> 00:48:17.150
and along the y-axis we have stack depth.

00:48:17.160 --> 00:48:19.840
And you can click or
mouse around through here,

00:48:19.840 --> 00:48:19.840
and you can see your stack at any
point during your program's execution.

00:48:24.660 --> 00:48:31.400
So now if we go back to the profile view,
probably the coolest feature, I think,

00:48:31.400 --> 00:48:38.480
of Shark is if you double
click on a function,

00:48:38.520 --> 00:48:39.890
and we found this one function
in particular called Big Fix that

00:48:39.890 --> 00:48:39.890
we're going to look at.

00:48:42.410 --> 00:48:43.870
You see your source code.

00:48:44.080 --> 00:48:45.400
But you don't just see your source code.

00:48:45.400 --> 00:48:48.080
It's actually annotated,
and it's highlighted.

00:48:48.170 --> 00:48:50.970
And what we did was we made
the brighter the yellow,

00:48:50.970 --> 00:48:53.140
it's more important for your code.

00:48:53.140 --> 00:48:57.210
That's the more important
time-consuming line of source.

00:48:57.730 --> 00:49:00.760
And so you can see also Shark is
going to offer you advice when it can.

00:49:00.760 --> 00:49:02.770
These are these exclamation points.

00:49:02.780 --> 00:49:05.060
So for example,
we have this floating point

00:49:05.060 --> 00:49:06.480
to integer conversion.

00:49:06.560 --> 00:49:11.990
Now this is really bad for
a G5 because it causes a

00:49:11.990 --> 00:49:11.990
serialization of the pipelines.

00:49:13.180 --> 00:49:16.680
Now new for Shark is the fact
that we can look at both source

00:49:16.870 --> 00:49:18.720
and assembly simultaneously.

00:49:18.720 --> 00:49:23.140
So you can see exactly what the compiler
generated for each line of source.

00:49:28.110 --> 00:49:30.060
And when you highlight
on a line of source,

00:49:30.060 --> 00:49:33.170
it automatically highlights and
scrolls the lines of assembly

00:49:33.240 --> 00:49:35.010
that correspond to each line.

00:49:35.750 --> 00:49:39.030
Now, for me, I generally speak PowerPC as
well as I do English,

00:49:39.130 --> 00:49:41.240
so we know that's not
true for most people.

00:49:41.240 --> 00:49:44.430
So we have this PPC Help button
down in the corner.

00:49:55.310 --> 00:49:56.300
and David S.

00:49:56.300 --> 00:49:58.290
As you can see, it's actually updating
as we scroll through.

00:49:58.300 --> 00:50:02.580
It updates and gives you a description
in English of what each mnemonic is.

00:50:02.650 --> 00:50:03.360
So that's really cool.

00:50:06.290 --> 00:50:08.440
And so it's really great to
be able to focus in on your

00:50:08.520 --> 00:50:11.120
performance hotspots right away.

00:50:11.120 --> 00:50:13.200
And we have this nice edit button now.

00:50:13.300 --> 00:50:16.600
And this will jump you right into Xcode.

00:50:16.640 --> 00:50:20.380
And the line that's highlighted in your
Shark Viewer is now highlighted in Xcode,

00:50:20.380 --> 00:50:21.490
so you can edit away.

00:50:23.910 --> 00:50:29.090
So if we go back to Celestia,
you can see that this demo has already

00:50:29.090 --> 00:50:32.230
been running for over four minutes,
and this is the original

00:50:32.230 --> 00:50:33.600
code when we got it.

00:50:33.600 --> 00:50:36.280
We decided we should spend
some time optimizing it based

00:50:36.340 --> 00:50:37.630
on what Shark had told us.

00:50:37.720 --> 00:50:39.980
And you can see we did nine steps.

00:50:39.980 --> 00:50:41.760
Now we don't have much time here.

00:50:41.760 --> 00:50:44.100
So let's just show you
Warp3 for a second here.

00:50:44.170 --> 00:50:46.680
If we restart the demo,
you can see that we're going to

00:50:46.680 --> 00:50:48.590
do a flight through the universe.

00:50:48.600 --> 00:50:55.030
We're going to stop around Saturn,
go off to one of its moons.

00:51:00.700 --> 00:51:04.620
and pretty soon here we'll be done.

00:51:04.730 --> 00:51:06.120
Now that's not bad.

00:51:06.130 --> 00:51:10.140
Originally this demo took over
a thousand seconds to run.

00:51:10.140 --> 00:51:13.180
So we made some
improvements at warp three.

00:51:13.180 --> 00:51:14.700
But we weren't done.

00:51:14.700 --> 00:51:20.140
We decided we should write AlteVec code,
we should do some G5 optimizations,

00:51:20.140 --> 00:51:24.460
we should unroll some loops,
we should schedule code better.

00:51:24.460 --> 00:51:27.740
And the sum of all that
is what we call warp nine.

00:51:27.740 --> 00:51:30.700
And if we take a look at that,
you can see--

00:51:38.600 --> 00:51:41.710
We got the demo to be a little
bit over 300 times faster from

00:51:41.710 --> 00:51:45.530
where we started using Shark.

00:51:46.080 --> 00:51:47.490
Thanks.

00:51:52.350 --> 00:51:53.500
I wanted to put up the URL.

00:51:53.540 --> 00:51:56.490
I think Celestia is a wonderful
application by itself,

00:51:56.490 --> 00:51:59.910
though spend more than
five seconds looking at it.

00:52:00.710 --> 00:52:04.340
There are lots more tools,
performance tools.

00:52:04.510 --> 00:52:06.860
Shark is terrific and such.

00:52:06.860 --> 00:52:11.450
But also, be able to look at, you know,
memory allocations, where is it going.

00:52:11.450 --> 00:52:13.570
Very often,
an application that is slow is not

00:52:13.570 --> 00:52:15.900
because it's algorithmically slow,
but because it's taking

00:52:15.920 --> 00:52:16.860
up too much memory.

00:52:17.100 --> 00:52:20.220
Features that also Shark has is to
be able to profile and set up the

00:52:20.220 --> 00:52:22.060
events of when allocations happen.

00:52:22.060 --> 00:52:24.850
There also are standalone
applications that you can leverage

00:52:24.850 --> 00:52:26.840
and work with without the GUI.

00:52:26.930 --> 00:52:29.030
Malik debug, object alloc.

00:52:29.030 --> 00:52:32.180
Quartz debug for looking to
see your quartz allocations.

00:52:32.180 --> 00:52:32.710
Sampler.

00:52:32.710 --> 00:52:36.760
Spin control is a great
thing when you see the pizza,

00:52:36.760 --> 00:52:40.950
the spinning cursor to understand
what it is the application is doing.

00:52:41.220 --> 00:52:41.940
Great, great thing.

00:52:42.160 --> 00:52:43.750
Thread viewer.

00:52:43.750 --> 00:52:45.480
Accessibility inspectors and verifiers.

00:52:45.560 --> 00:52:46.620
Very, very important.

00:52:46.650 --> 00:52:54.210
A lot of -- both to make your
application accessible to the unsighted.

00:52:54.210 --> 00:52:57.070
It's a terrific new -- it's a great
new set of capabilities in Mac OS X and

00:52:57.070 --> 00:53:01.090
will give you the tools to help
make your application accessible.

00:53:01.280 --> 00:53:05.860
So lots and lots of performance tools
and analysis tools on the developer CD.

00:53:05.860 --> 00:53:09.810
It's worthwhile to explore it and there
are sessions on all these features.

00:53:12.230 --> 00:53:15.160
Xcode is, in many ways,
the gateway to the

00:53:15.160 --> 00:53:17.090
frameworks on the system.

00:53:17.290 --> 00:53:22.110
And you heard this morning and
from Bertrand about a number

00:53:22.110 --> 00:53:24.190
of the terrific SDKs and tools.

00:53:24.430 --> 00:53:26.200
Spotlight is a great new SDK.

00:53:26.200 --> 00:53:30.340
Dashboard, Core Data,
all of these SDKs have both,

00:53:30.340 --> 00:53:33.670
in many cases, have additional tools.

00:53:33.670 --> 00:53:41.750
For example, Quartz Composer to better
understand how the filters interact.

00:53:42.220 --> 00:53:45.700
So it's a terrific thing to spend
some time and leverage this.

00:53:45.730 --> 00:53:53.310
Core Data is a terrific SDK that unlocks
the virtues of persistence and database

00:53:53.560 --> 00:53:56.310
for object-oriented programming.

00:53:56.380 --> 00:53:59.780
I think one of my favorites, though,
is going to be the Automator.

00:53:59.820 --> 00:54:04.660
And Automator SDK,
and let's bring on Tim Bumgarner

00:54:04.660 --> 00:54:09.340
and Todd Fernandez to give us a
demo of the Automator Action SDK.

00:54:16.310 --> 00:54:19.320
Thank you very much, Ted,
and good afternoon, developers.

00:54:19.320 --> 00:54:23.040
I hope that you all got a chance to see
Automator this morning in the keynote.

00:54:23.130 --> 00:54:27.090
While Sal did a great job of
showing off Automator's user side,

00:54:27.090 --> 00:54:30.760
and Tim is taking advantage
of it right now-- I'm sorry,

00:54:30.760 --> 00:54:34.530
it's already done-- running a
workflow to set up our demo,

00:54:34.530 --> 00:54:37.380
we're here to show you
the developer side.

00:54:37.380 --> 00:54:40.690
And the first thing we want
to do is show you an action

00:54:40.920 --> 00:54:43.880
you did not see this morning,
an action that allows you

00:54:43.880 --> 00:54:43.880
to create a new email.

00:54:45.490 --> 00:54:49.220
And if you take a look at
the Actions user interface,

00:54:49.270 --> 00:54:54.480
and Tim,
please bring up the people picker,

00:54:54.480 --> 00:54:54.480
you'll see that something's missing.

00:54:55.590 --> 00:54:58.260
There's no BCC support.

00:54:58.360 --> 00:55:01.320
So in order to show you how easy
it is to create automator actions,

00:55:01.530 --> 00:55:04.450
Tim and I are going to add
that support for you now.

00:55:04.920 --> 00:55:06.450
and to do that there's three main steps.

00:55:06.650 --> 00:55:09.320
We need to update our
actions user interface.

00:55:09.320 --> 00:55:13.130
We need to add the connections
between the new user interface

00:55:13.130 --> 00:55:14.560
elements and our code.

00:55:15.020 --> 00:55:17.380
And finally,
we need to add our source code

00:55:17.580 --> 00:55:19.800
in Apple Script and Objective-C.

00:55:20.110 --> 00:55:23.870
So Tim,
please open the project in Xcode 2.0.

00:55:25.100 --> 00:55:28.060
And the first thing to notice here
is that this is a native target.

00:55:28.230 --> 00:55:34.860
Native targets now support AppleScript.

00:55:34.940 --> 00:55:38.210
So let's go ahead and open
the nib in Interface Builder.

00:55:42.190 --> 00:55:47.140
And there's our new text field
to hold the BCC addresses.

00:55:47.140 --> 00:55:49.580
And we've added a BCC button
to the people picker.

00:55:52.420 --> 00:55:57.500
and we've already wired that up
to a new addBCC items method.

00:55:57.640 --> 00:56:01.300
Now what we have left to do is
to use Cocoa Bindings to bind the

00:56:01.300 --> 00:56:05.880
value of that new text field for
the BCC addresses to a new variable.

00:56:05.880 --> 00:56:09.830
Strangely enough, called BCC addresses.

00:56:10.910 --> 00:56:17.450
And we've got that all set,
so please save the nib, Tim,

00:56:17.450 --> 00:56:20.850
and let's get back to Xcode.

00:56:20.860 --> 00:56:26.510
So now that we have Cocoa Binding
setting this new variable,

00:56:26.510 --> 00:56:26.510
BCC addresses,
we need to actually use it in our script,

00:56:26.510 --> 00:56:26.510
which is used to manage
the actions user interface.

00:56:28.800 --> 00:56:37.780
Tim, go ahead and add a line of
code to read the BCC addresses

00:56:37.780 --> 00:56:37.780
out of the parameters block,
which is managed for

00:56:37.780 --> 00:56:37.780
us by Cocoa Bindings.

00:56:37.990 --> 00:56:41.230
and here we're showing off another great
new feature in Xcode 2.0 that we now

00:56:41.230 --> 00:56:43.970
have code completion for Apple Script.

00:56:50.710 --> 00:56:52.600
Excellent, let's save that.

00:56:52.620 --> 00:56:54.300
And Tim,
if you could just give us a brief tour.

00:56:54.300 --> 00:57:01.730
We already have the rest of the
AppleScript code analogous to what we

00:57:01.730 --> 00:57:01.730
already had for the two ANSI C addresses.

00:57:02.170 --> 00:57:14.830
and Dan Lebowitz.

00:57:15.970 --> 00:57:15.980
And down at the bottom,
we're taking advantage of Mail's

00:57:15.980 --> 00:57:15.980
great scriptability to add the new
BCC recipients to the new email message

00:57:15.980 --> 00:57:15.980
that the action will create for us.

00:57:15.980 --> 00:57:15.980
All right,
that's all we needed to do in our script,

00:57:15.980 --> 00:57:15.980
so let's please save that, Tim.

00:57:16.800 --> 00:57:19.680
And finally,
what we need to do is open up an

00:57:19.750 --> 00:57:25.430
Objective-C class and take a look
at that new addBCCItems method.

00:57:26.360 --> 00:57:31.670
And really all we needed to do was
copy and paste and change three CCs to

00:57:32.090 --> 00:57:38.070
BCCs to read the value from the people
picker and add it to the text field.

00:57:38.720 --> 00:57:44.650
So great, that's all we needed to do,
is add this new feature.

00:57:44.650 --> 00:57:44.650
So Tim, if you would hit build and go,
please.

00:57:45.390 --> 00:57:46.600
And we'll save our script.

00:57:46.670 --> 00:57:48.670
And what we're doing here
is taking advantage of a

00:57:48.810 --> 00:57:51.940
custom Automator executable,
which is a great Xcode feature,

00:57:52.030 --> 00:57:56.960
which has a launch argument which passes
the newly built action to Automator

00:57:56.960 --> 00:57:59.060
when we launch it directly from Xcode.

00:57:59.120 --> 00:58:04.490
This gives us a very efficient
development cycle and very much

00:58:04.490 --> 00:58:04.490
like building a normal application.

00:58:05.040 --> 00:58:09.740
So let's add our new email
action to the workflow.

00:58:09.790 --> 00:58:12.550
And we see it's got a BCC field.

00:58:13.060 --> 00:58:15.750
and the People Picker has the
button that allows us to add

00:58:15.750 --> 00:58:18.460
new addresses to that field.

00:58:18.460 --> 00:58:21.440
So Tim, if you'd BCC me please.

00:58:22.600 --> 00:58:25.590
And let's send a message to Ted,
since he's been so gracious

00:58:25.590 --> 00:58:28.190
as to let us share his stage.

00:58:28.370 --> 00:58:30.470
And CC Tony.

00:58:32.120 --> 00:58:35.200
And let's tell them what
a great combination that

00:58:35.200 --> 00:58:37.730
Automator and Xcode 2.0 are.

00:58:42.060 --> 00:58:47.310
It's kind of a boring email,
so let's make it a little

00:58:47.310 --> 00:58:47.310
bit more interesting.

00:58:47.310 --> 00:58:47.310
Let's add an image to it.

00:58:50.710 --> 00:58:57.800
Strangely enough,
an image of another great combination.

00:58:57.800 --> 00:58:57.800
And let's go ahead and run the workflow.

00:58:59.930 --> 00:59:03.150
And there's our email with the
VCC field correctly filled out,

00:59:03.150 --> 00:59:07.410
and we've got the Venus transit
a couple weeks back.

00:59:15.450 --> 00:59:17.860
So in a few short minutes,
we've shown you how easy it is to

00:59:17.860 --> 00:59:21.440
use your development language of
choice to create automator actions.

00:59:21.610 --> 00:59:25.120
And I hope that you'll all join me
tomorrow morning at 10:30 in the

00:59:25.120 --> 00:59:28.530
Mission for a full session explaining
just how easy it is to create a rich

00:59:28.570 --> 00:59:30.720
set of actions for your applications.

00:59:30.720 --> 00:59:34.150
Thanks very much, Ted.

00:59:34.150 --> 00:59:34.150
Thanks, Todd.

00:59:34.150 --> 00:59:34.150
Thanks, Tim.

00:59:37.500 --> 00:59:39.700
So, yes, tomorrow morning, 10:30.

00:59:39.720 --> 00:59:44.630
I think Automator and connecting
up applications is going to

00:59:44.660 --> 00:59:46.220
be a very incredible thing.

00:59:46.220 --> 00:59:49.820
We're asking all the application
developers to really think about

00:59:49.820 --> 00:59:53.270
and expose-- it's very simple to
expose an AppleScript interface

00:59:53.440 --> 00:59:54.530
and add these actions.

00:59:54.670 --> 00:59:57.030
You can actually add
Automator actions in,

00:59:57.030 --> 00:59:58.960
really, the language of your choice.

00:59:59.000 --> 01:00:00.630
It's very simple to do
it with AppleScript,

01:00:00.700 --> 01:00:02.320
but it doesn't require AppleScript.

01:00:02.460 --> 01:00:04.770
There's many different ways to do this.

01:00:04.800 --> 01:00:07.990
It's really a very simple set
of nibs that can be copied,

01:00:08.000 --> 01:00:12.580
dragged, and pasted into your project.

01:00:12.760 --> 01:00:15.940
And to really enable this
is a terrific way to do it.

01:00:16.020 --> 01:00:20.130
This technology grows out of work
done to also enable Unix shell

01:00:20.190 --> 01:00:22.540
scripting and many kinds of things.

01:00:22.750 --> 01:00:26.020
So this is a foundational piece of
technology that I think you're going to

01:00:26.020 --> 01:00:27.650
see a lot of exciting things happening.

01:00:27.680 --> 01:00:31.620
And it's a terrific way for many
applications to become very integrated

01:00:31.640 --> 01:00:34.720
and to leverage the capabilities
from one application to another.

01:00:34.720 --> 01:00:37.620
for our customers' benefits.

01:00:38.310 --> 01:00:42.540
So to summarize,
Xcode continues to advance

01:00:42.540 --> 01:00:44.990
for Panther and Tiger.

01:00:45.000 --> 01:00:50.580
We think that Xcode is helping people to
build faster applications in less time.

01:00:50.620 --> 01:00:53.440
So improving both the
performance of the applications,

01:00:53.440 --> 01:00:55.670
both with compiled code
and generated code,

01:00:55.790 --> 01:00:59.500
and by taking advantage of
new performance capabilities.

01:00:59.500 --> 01:01:02.510
We think it's going to be
extremely important to Automator

01:01:02.510 --> 01:01:04.360
enable your application.

01:01:04.370 --> 01:01:08.370
And we think that Xcode is
really the new foundation for a

01:01:08.380 --> 01:01:10.660
large number of terrific things.

01:01:10.720 --> 01:01:14.420
Now, I know many of you have seen
that a few of us around here

01:01:14.420 --> 01:01:15.530
sporting these great shirts.

01:01:15.540 --> 01:01:18.990
I want to invite Rich Siegel and
Gabrielle State back up here.

01:01:19.060 --> 01:01:21.240
I want to hand them some shirts
for being some of the first

01:01:21.250 --> 01:01:25.700
applications we're showing,
developed in Xcode.

01:01:25.700 --> 01:01:27.570
Hand them a shirt.

01:01:28.300 --> 01:01:29.300
Thank you.

01:01:29.300 --> 01:01:30.290
Thanks so much, Ted.

01:01:30.300 --> 01:01:31.300
Thank you.

01:01:31.300 --> 01:01:35.300
And you have a little other demo to show?

01:01:35.300 --> 01:01:36.280
Yeah.

01:01:36.300 --> 01:01:40.710
So while Ted was getting everything ready
and showing off that Automator demo,

01:01:40.710 --> 01:01:43.390
I thought, gee, you know,
I really hope that Apple concentrates

01:01:43.470 --> 01:01:46.260
on security for that stuff,
because it can be really important.

01:01:46.370 --> 01:01:49.120
You know, in the Tron game,
if we get the sound there,

01:01:49.280 --> 01:01:50.300
that'd be great.

01:01:50.300 --> 01:01:52.300
Get the sound on?

01:01:52.300 --> 01:01:54.300
Tron game,
there's a little problem with that, so.

01:01:54.300 --> 01:01:56.710
Please,
I've got to get back to my routing.

01:01:57.100 --> 01:02:10.200
[Transcript missing]

01:02:18.940 --> 01:02:20.890
Yeah, so that's the danger
of some of this stuff,

01:02:20.940 --> 01:02:23.010
so I'm sure you guys will
do a great job on that.

01:02:23.010 --> 01:02:24.840
Little email scripts can run amok, huh?

01:02:24.840 --> 01:02:25.350
Exactly.

01:02:25.350 --> 01:02:26.610
Thanks a lot, Gabriel.

01:02:31.840 --> 01:02:36.300
So we have a few more shirts here,
but in fact, when you come down to the

01:02:36.300 --> 01:02:38.940
Apple campus on Thursday,
we're going to have a lot more.

01:02:39.180 --> 01:02:47.030
And if you bring your application
running on a laptop and show us

01:02:47.060 --> 01:02:49.140
your application building in Xcode,
then we'll have a shirt for you as well.

01:02:49.140 --> 01:02:49.140
So we're going to throw out a few now.

01:02:57.300 --> 01:02:59.340
and David S.

01:02:59.340 --> 01:03:02.210
So only a few today.

01:03:02.470 --> 01:03:05.300
You've got to show us your
application building in Xcode.

01:03:05.300 --> 01:03:08.490
So thank you very much and
have a great conference.
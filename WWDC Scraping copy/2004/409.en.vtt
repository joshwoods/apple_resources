WEBVTT

00:00:12.360 --> 00:00:15.750
Ladies and gentlemen,
please welcome Frameworks

00:00:16.180 --> 00:00:18.370
Engineer Chris Parker.

00:00:21.700 --> 00:00:23.470
Thank you.

00:00:23.630 --> 00:00:26.530
Welcome to Session 409--
What's New in Cocoa.

00:00:26.590 --> 00:00:27.800
It's going to be a fast hour.

00:00:27.920 --> 00:00:30.000
So I'm going to get right into it.

00:00:30.140 --> 00:00:31.250
My name is Chris Parker.

00:00:31.390 --> 00:00:34.190
I'm a Cocoa Frameworks engineer
for the last three years.

00:00:34.260 --> 00:00:37.600
And we're starting with
a familiar formula here.

00:00:37.600 --> 00:00:41.350
What you'll see is everything that
we've done in Cocoa so far for Tiger,

00:00:41.350 --> 00:00:43.900
in both the app kit and foundation.

00:00:43.990 --> 00:00:47.570
We'll be covering a lot of new features,
a lot of new significant

00:00:47.570 --> 00:00:49.530
API changes or behavioral changes.

00:00:49.710 --> 00:00:51.060
We're going to skip the bug fixes.

00:00:51.140 --> 00:00:52.990
We're going to hope you guys are
all going to get out there and

00:00:52.990 --> 00:00:54.960
read the release notes for those.

00:00:54.960 --> 00:00:58.000
We'll talk about some usage patterns
for some of these new features.

00:00:58.040 --> 00:00:59.640
And we'll also give you some
pointers to other sessions.

00:00:59.690 --> 00:01:03.180
There's a lot of stuff in here with
a lot of new APIs that actually are

00:01:03.180 --> 00:01:04.920
implemented in some other places.

00:01:05.020 --> 00:01:09.280
So starting up with the app kit,
in Panther,

00:01:09.350 --> 00:01:12.250
there was some enhanced printing
support to support things like

00:01:12.340 --> 00:01:15.620
the number of pages you could put
across the page or down the page,

00:01:15.660 --> 00:01:18.160
or start and end pages,
and collating settings,

00:01:18.200 --> 00:01:19.300
and things like that.

00:01:19.370 --> 00:01:20.500
We've added some automatic support.

00:01:20.500 --> 00:01:23.740
We've added some nice support in
the printing system in Cocoa so

00:01:23.740 --> 00:01:26.760
that existing applications will
get some of these new features.

00:01:26.760 --> 00:01:29.920
But if you really want to do it right,
there's a new application

00:01:29.920 --> 00:01:34.520
delegate method on NSApplication--
application print files with

00:01:34.620 --> 00:01:36.120
settings and show print panels.

00:01:36.120 --> 00:01:38.530
And this will give you an opportunity
to be able to get information about

00:01:38.530 --> 00:01:40.120
what you're being told to print.

00:01:40.120 --> 00:01:41.920
And you'll be able to
return a value that says,

00:01:41.930 --> 00:01:44.530
hey, this printing operation succeeded.

00:01:44.590 --> 00:01:45.030
It failed.

00:01:45.060 --> 00:01:46.620
It's printing later.

00:01:47.860 --> 00:01:50.100
There's also NSDocument
enhanced printing support.

00:01:50.100 --> 00:01:54.090
So if you're NSDocument subclasses,
you can do print document with settings,

00:01:54.090 --> 00:01:55.220
show print panel.

00:01:55.220 --> 00:01:57.560
There's a delegate
object you can pass in,

00:01:57.560 --> 00:02:00.330
a selector for did print selector,
and a context info pointer

00:02:00.400 --> 00:02:02.690
that you'll get back when you
get this delegate callback.

00:02:02.720 --> 00:02:05.590
The settings dictionary should
be applied to the NSPrintInfo

00:02:05.610 --> 00:02:08.210
for the print operation,
and there are keys for

00:02:08.210 --> 00:02:10.940
print pages across,
pages down, what time to print,

00:02:11.120 --> 00:02:12.420
the printer name to print on.

00:02:12.420 --> 00:02:15.970
So there's a lot better fine-grained
control in Cocoa now over the

00:02:15.970 --> 00:02:19.020
printing mechanism that you
get for the information you

00:02:19.020 --> 00:02:21.130
get from the finder or other places.

00:02:21.140 --> 00:02:25.600
NSDocument now also has support
for dynamic document types.

00:02:25.600 --> 00:02:28.730
So a lot of applications are being
written now using bundles to do

00:02:28.730 --> 00:02:31.280
all of their reading and writing,
which means that they

00:02:31.280 --> 00:02:33.910
can extend the number of,
the kinds of documents that

00:02:33.920 --> 00:02:34.820
they can read and write.

00:02:34.820 --> 00:02:37.880
There are a number of different ways
you can represent those documents.

00:02:37.880 --> 00:02:43.370
So you can override using, to do this,
using a customizable output type,

00:02:43.450 --> 00:02:46.700
you can override writable
types for save operation.

00:02:47.700 --> 00:02:49.400
And you'd use this to limit those types.

00:02:49.440 --> 00:02:53.440
So if you've got something in the window
that can only be represented as an RTFD,

00:02:53.440 --> 00:02:55.230
you probably don't want to write out RTF.

00:02:55.470 --> 00:02:58.000
You can return an
NSRA containing RTFD from this.

00:02:58.000 --> 00:02:59.990
So some data may not be representable.

00:03:00.200 --> 00:03:03.230
You can control what's actually shown
in the UI when you write this out.

00:03:05.960 --> 00:03:08.310
NS Document now,
and in a lot of places throughout

00:03:08.320 --> 00:03:10.840
the app kit and foundation,
you'll see this,

00:03:10.880 --> 00:03:13.320
is now more consistently using NSError.

00:03:13.320 --> 00:03:16.060
So there are new methods
with error parameters.

00:03:16.060 --> 00:03:20.690
So init with contents of URL of type,
and now this by reference error pass.

00:03:20.710 --> 00:03:22.900
If something goes wrong,
we'll tell you what went

00:03:22.900 --> 00:03:24.080
wrong in that NSError.

00:03:24.080 --> 00:03:25.930
Also, write to URL of type with error.

00:03:25.930 --> 00:03:27.820
There's an error parameter on that also.

00:03:27.930 --> 00:03:29.520
Again, you pass it by reference.

00:03:29.520 --> 00:03:31.460
We'll try and tell you what went wrong.

00:03:31.800 --> 00:03:34.590
We're using NSURL as our
locator more consistently

00:03:34.590 --> 00:03:36.680
throughout foundation in the kit.

00:03:36.690 --> 00:03:40.510
So you probably won't quite see so
much init with contents of file.

00:03:40.520 --> 00:03:43.960
You'll start seeing a lot more
init with contents of URL.

00:03:46.490 --> 00:03:47.660
We've seen it in mail, right?

00:03:47.660 --> 00:03:52.310
You're typing away on your email message,
and it saves it periodically

00:03:52.310 --> 00:03:53.150
in the drafts folder.

00:03:53.150 --> 00:03:54.860
You might have three or
four drafts going on.

00:03:54.860 --> 00:03:59.020
NSDocument now supports this
kind of autosaving directly.

00:03:59.020 --> 00:04:02.920
So periodic autosaving of documents,
you can change--you can set how

00:04:02.920 --> 00:04:07.110
often that autosave is going to
occur using set autosaving delay.

00:04:07.260 --> 00:04:10.590
There's a new NSSaveOperation type that
you'll get told about when things happen.

00:04:10.590 --> 00:04:12.910
And there's also,
because the autosaving mechanism

00:04:12.980 --> 00:04:15.440
drops a copy of the document
next to the one you've got,

00:04:15.440 --> 00:04:16.160
initialize it.

00:04:16.170 --> 00:04:19.100
There's an initializer for customizing
the reopening of a document.

00:04:19.210 --> 00:04:21.800
So if you want to say, "Oh,
you've got an autosaved version

00:04:21.800 --> 00:04:24.440
here," you can init with the URL,
but the contents are going to

00:04:24.440 --> 00:04:25.960
come from that autosaved document.

00:04:25.960 --> 00:04:26.440
Okay?

00:04:26.440 --> 00:04:31.000
And again, we're providing init with
URL with--init for URL with

00:04:31.000 --> 00:04:33.470
contents of URL of type error.

00:04:33.640 --> 00:04:37.120
And that error parameter is
going to have as much information

00:04:37.120 --> 00:04:38.870
about what may have gone wrong

00:04:39.590 --> 00:04:41.860
One of the things you see in mail is as
you've been working and you quit mail,

00:04:41.860 --> 00:04:45.540
all those messages come back
when you fire it back up again.

00:04:45.540 --> 00:04:47.890
NS document now supports a
thing called Fast Log Out.

00:04:48.070 --> 00:04:51.800
So if you're a--if your NS document
class is supporting autosaving,

00:04:51.840 --> 00:04:55.090
you can also get
Fast Log Out support automatically.

00:04:55.090 --> 00:04:59.580
So when--Fast Log Out will come along,
it'll quit an application with no UI,

00:04:59.580 --> 00:05:03.200
it'll save auto--it'll autosave
the modified documents.

00:05:03.280 --> 00:05:06.090
And then when the--when the
application launches again,

00:05:06.090 --> 00:05:08.500
it'll open all the
autosaved documents for you,

00:05:08.510 --> 00:05:09.710
right where you left off.

00:05:09.710 --> 00:05:12.690
So when you log out quickly,
all the stuff comes back.

00:05:12.810 --> 00:05:15.270
If you're an NS document app,
you'll get most of this for free.

00:05:17.650 --> 00:05:20.160
We've put new controls in the kit.

00:05:20.160 --> 00:05:21.760
This is the NS level indicator.

00:05:21.820 --> 00:05:24.480
There's a control and
a cell variant of this.

00:05:24.520 --> 00:05:26.340
There are relevancy indicators.

00:05:26.340 --> 00:05:27.760
That's the top one here.

00:05:27.810 --> 00:05:30.820
So if you're displaying search results,
you'd use the relevancy indicator.

00:05:31.030 --> 00:05:34.290
A capacity indicator,
how full something is.

00:05:34.290 --> 00:05:38.990
The discrete capacity indicator,
so it fills up in quantums.

00:05:39.050 --> 00:05:41.260
And a rating indicator,
so just like in iTunes with

00:05:41.260 --> 00:05:43.250
the stars and the dots,
the rating indicator

00:05:43.350 --> 00:05:44.680
here lets you do that.

00:05:44.680 --> 00:05:45.980
And it's customizable.

00:05:46.070 --> 00:05:49.550
It's customizable for tick marks,
the small and large ones,

00:05:49.550 --> 00:05:50.780
kind of like the sliders.

00:05:50.870 --> 00:05:53.880
Capacity indicators do automatic
critical and warning values.

00:05:53.880 --> 00:05:56.490
So they'll turn yellow or
they'll turn red as it fills

00:05:56.490 --> 00:05:58.710
up and gets closer to that,
you know,

00:05:58.740 --> 00:06:01.220
running out of disk space indicator.

00:06:01.260 --> 00:06:04.390
The ranking indicator also
supports custom images,

00:06:04.390 --> 00:06:08.420
both for the filled in rank
and the not yet filled in rank.

00:06:08.490 --> 00:06:11.650
So if you've got seven out of ten,
you can have seven stars

00:06:11.650 --> 00:06:13.300
and three hollow stars.

00:06:13.690 --> 00:06:18.910
There's a new NSDate picker control.

00:06:22.270 --> 00:06:23.170
I lost the bet.

00:06:23.250 --> 00:06:26.400
I thought the applause
was going to come later.

00:06:26.400 --> 00:06:28.470
There's a control and
sell variant of this.

00:06:28.500 --> 00:06:30.490
Its object value is an NSDate.

00:06:30.640 --> 00:06:33.110
It's customizable,
so from what you're seeing here,

00:06:33.110 --> 00:06:35.860
you can edit and you can control
what things you can edit,

00:06:35.860 --> 00:06:39.620
what things you're not going to edit,
as well as enabling and disabling

00:06:39.620 --> 00:06:41.720
display of elements of the picker.

00:06:41.780 --> 00:06:43.360
There are range constraints.

00:06:43.360 --> 00:06:45.440
You can set a min value and a max value.

00:06:45.440 --> 00:06:48.170
And it also has full calendar, locale,
and time zone support.

00:06:48.170 --> 00:06:51.660
And we'll talk about some more of that
in the foundation talk in a minute.

00:06:51.700 --> 00:06:55.000
And there's also an additional
opportunity for you to validate the date

00:06:55.000 --> 00:06:57.590
that's in there from a delegate method.

00:06:59.300 --> 00:07:02.920
And also, again, you've seen it in mail,
NSTokenField.

00:07:02.960 --> 00:07:05.020
There's a control and sell
variant of this as well.

00:07:05.080 --> 00:07:07.380
So as you type,
you can set a tokenizing character,

00:07:07.380 --> 00:07:10.240
and it'll break it up into
those nice little blue lozenges

00:07:10.420 --> 00:07:12.810
that appear in the field.

00:07:12.890 --> 00:07:14.980
So it behaves a lot like
mail's address fields.

00:07:15.120 --> 00:07:16.440
It supports text completion.

00:07:16.440 --> 00:07:18.800
This is actually a text view.

00:07:18.800 --> 00:07:21.260
You can set your custom
character sets for tokenizing.

00:07:21.420 --> 00:07:23.000
You can also set represented objects.

00:07:23.090 --> 00:07:26.760
So if what you're putting in
here really isn't strings,

00:07:26.790 --> 00:07:30.250
you can set the represented object
for each token and then have a string

00:07:30.250 --> 00:07:31.800
representation for it show up here.

00:07:31.800 --> 00:07:34.070
And when you drag it to the pasteboard,
there's actually support for

00:07:34.070 --> 00:07:36.340
putting those represented
objects on the pasteboard.

00:07:36.360 --> 00:07:38.380
There will also be support
for menus coming up.

00:07:38.380 --> 00:07:41.810
So you can attach a menu to
these tokens and drop it down and

00:07:41.810 --> 00:07:44.180
put your own actions on those.

00:07:44.220 --> 00:07:48.640
And we actually have a very
short demo here of these.

00:07:48.680 --> 00:07:51.000
We'll walk all the way
across this huge stage,

00:07:51.000 --> 00:07:51.610
though.

00:07:55.100 --> 00:08:00.260
So the new UI elements,
many of them are bindable out of the box.

00:08:00.260 --> 00:08:03.830
I suppose I should look at the
smaller screen in front of me.

00:08:05.040 --> 00:08:08.550
And the level indicator,
this is the discrete

00:08:08.550 --> 00:08:12.760
capacity level indicator,
and we can set the warning value and the

00:08:13.000 --> 00:08:16.050
critical value here somewhere up higher.

00:08:16.160 --> 00:08:19.940
As I move the value slider up,
you'll see that as I cross the

00:08:19.940 --> 00:08:23.040
50 percent mark within each bar,
it fills in.

00:08:23.260 --> 00:08:26.240
Right, and as we get up here
close to the warning value,

00:08:26.240 --> 00:08:30.800
it crosses over into yellow,
and then turns into red.

00:08:30.800 --> 00:08:33.010
So we've now completely run
out of space here and have

00:08:33.010 --> 00:08:34.170
to go buy another hard drive.

00:08:34.200 --> 00:08:39.710
The date picker.

00:08:40.660 --> 00:08:43.120
So this is just three date
pickers dragged out from the

00:08:43.120 --> 00:08:45.320
interface builder palette.

00:08:45.320 --> 00:08:47.900
And I can set the minimum date here.

00:08:48.090 --> 00:08:51.150
Let's bump the year up
a little closer to--.

00:08:54.050 --> 00:09:06.640
So, as I try and exceed the values
there it automatically stops for me.

00:09:06.680 --> 00:09:12.200
And the delegate would have an
opportunity to handle these as well.

00:09:12.200 --> 00:09:15.960
So, and finally, TokenField.

00:09:16.030 --> 00:09:18.270
And TokenField actually is pretty slick.

00:09:18.280 --> 00:09:21.800
If we launch text out of here,
just so I can have this up as well.

00:09:22.090 --> 00:09:25.820
As I type, the default TokenField is set
to use comma as its separator.

00:09:25.910 --> 00:09:31.850
So, this is, let's see,
get an email address here.

00:09:36.890 --> 00:09:37.620
We have the tokens.

00:09:37.620 --> 00:09:41.840
I can drag these tokens
around within the token field.

00:09:41.840 --> 00:09:44.880
And if I select them all,
I can drag them out onto the

00:09:44.910 --> 00:09:47.260
pasteboard into text edit,
and all of this stuff just

00:09:47.260 --> 00:09:48.120
happens automatically.

00:09:48.210 --> 00:09:51.300
This is nibware here.

00:09:51.300 --> 00:09:55.370
I've got my main menu nib
that just drags these out as a

00:09:55.370 --> 00:09:58.020
custom class for token field.

00:09:58.880 --> 00:10:02.410
And I did a little bit of
binding stuff here for date

00:10:02.410 --> 00:10:06.130
picker and for indicator cell,
and the setup for token field

00:10:06.200 --> 00:10:07.610
is actually pretty short.

00:10:07.640 --> 00:10:11.660
So we could go back to the slides,
please.

00:10:17.140 --> 00:10:21.950
So as our UIs become more dynamic,
we need support for animation

00:10:22.010 --> 00:10:23.520
specifically in Cocoa.

00:10:23.580 --> 00:10:26.460
NSAnimation is the class
that supplies that.

00:10:26.520 --> 00:10:29.650
So this provides timing
for animations in Cocoa.

00:10:29.820 --> 00:10:32.520
It does some other things for you,
but it's mainly about timing.

00:10:32.600 --> 00:10:34.680
There are three modes
for this-- blocking,

00:10:34.680 --> 00:10:37.060
non-blocking, and non-blocking threaded.

00:10:37.090 --> 00:10:39.400
So a blocking animation,
everything's going to stop

00:10:39.400 --> 00:10:41.320
while the animation's running.

00:10:41.320 --> 00:10:45.120
So the non-blocking animation
runs in the current run loop.

00:10:45.250 --> 00:10:47.120
Other events are happening as it goes.

00:10:47.120 --> 00:10:49.740
And the non-blocking threaded means
that we'll spin off a background

00:10:49.740 --> 00:10:52.370
thread and do the animation back
there for you while other stuff

00:10:52.430 --> 00:10:54.020
is happening in the foreground.

00:10:54.100 --> 00:10:57.370
There's also an API that
supports animation progress,

00:10:57.490 --> 00:10:59.050
frame rate control, as well as the curve.

00:10:59.180 --> 00:11:02.770
So if it's going to proceed at the same
rate all the way across the animation,

00:11:02.890 --> 00:11:05.590
or if it eases in and out,
it happens really slowly at first,

00:11:05.810 --> 00:11:09.900
speeds up,
and then slows down again at the end.

00:11:09.960 --> 00:11:15.200
So the progress API uses a
thing called progress marks.

00:11:15.270 --> 00:11:16.860
So they're checkpoints for animations.

00:11:16.880 --> 00:11:19.360
And you set the progress
marks via this progress marks

00:11:19.450 --> 00:11:20.840
and set progress marks API.

00:11:21.070 --> 00:11:23.900
You provide an NSArray of floats.

00:11:23.950 --> 00:11:29.930
And as the animation proceeds,
the delegate will get callbacks

00:11:30.200 --> 00:11:32.320
as it crosses those marks.

00:11:32.820 --> 00:11:38.040
So if you set up animation progress
at 50% and at 75%, you'll hit those,

00:11:38.040 --> 00:11:39.520
and your delegate will get called back.

00:11:39.620 --> 00:11:42.230
There are also notifications
for these as well that you can

00:11:42.230 --> 00:11:44.600
listen for for NS Animation.

00:11:44.900 --> 00:11:47.160
And this animation also
allows you to link animations.

00:11:47.230 --> 00:11:50.300
So once you've got the progress
mark set on a particular animation,

00:11:50.330 --> 00:11:53.300
you can synchronize them using start
when animation reaches progress and

00:11:53.380 --> 00:11:54.860
stop when animation reaches progress.

00:11:54.900 --> 00:12:02.710
So you can say that this animation should
only start when that one hits 25%, and it

00:12:02.710 --> 00:12:02.710
should stop when the other one hits 75%.

00:12:04.780 --> 00:12:07.500
To do this with views,
a lot of the view animation

00:12:07.500 --> 00:12:08.540
stuff is pretty common.

00:12:08.540 --> 00:12:12.790
You want to do frames and ease
things in and out and do crossfades.

00:12:12.870 --> 00:12:16.420
And this NSViewAnimation
subclass is how you do that.

00:12:16.420 --> 00:12:19.720
So there's a dictionary that
defines the view animation behavior.

00:12:19.720 --> 00:12:23.130
You set a number of different keys,
the target key, the start frame key,

00:12:23.130 --> 00:12:25.620
the end frame key,
what kind of effect you want,

00:12:25.670 --> 00:12:27.540
whether it's a fade in or a fade out.

00:12:27.590 --> 00:12:29.110
And this can change
the frame and opacity,

00:12:29.440 --> 00:12:32.020
and it can be applied to
both views and windows.

00:12:32.080 --> 00:12:34.020
You initialize them using
an array of view animations.

00:12:34.020 --> 00:12:35.980
So you can have five or six
different dictionaries that

00:12:35.980 --> 00:12:38.070
represent the view animations.

00:12:38.170 --> 00:12:39.330
And you can also set them.

00:12:39.430 --> 00:12:42.260
So if you have an existing animation,
it's a mutable class,

00:12:42.290 --> 00:12:44.880
you can change the array of animations.

00:12:44.890 --> 00:12:47.340
And we actually have a
quick demo of this as well.

00:12:47.340 --> 00:12:51.670
I have to switch projects.

00:13:03.900 --> 00:13:06.300
is that.

00:13:06.300 --> 00:13:10.340
So in the demo controller now,
there's a tab view in that nib.

00:13:10.340 --> 00:13:14.520
And down here in demo controller dot m,

00:13:15.340 --> 00:13:22.440
We do some calculations at the tab view,
did select tab view item delegate moment.

00:13:22.600 --> 00:13:25.470
And after calculating the start frame
and the end frame and things like that,

00:13:25.580 --> 00:13:28.960
we set up here the animation
parameters in a dictionary.

00:13:28.960 --> 00:13:31.040
So the window is going to be the target.

00:13:31.160 --> 00:13:33.190
We'll have a start
frame and an end frame.

00:13:33.280 --> 00:13:37.590
We'll set up the animation,
set the blocking mode and the duration,

00:13:37.590 --> 00:13:38.430
and start it.

00:13:38.950 --> 00:13:41.600
So running this,
now as I shift from level

00:13:41.670 --> 00:13:45.800
indicator to token field,
we're starting and ending the frame.

00:13:45.810 --> 00:13:48.010
And in about four lines of code,
we've got that nifty effect

00:13:48.130 --> 00:13:49.170
from system preferences.

00:13:49.170 --> 00:13:52.200
And this can also do all
the crossfade and opacity.

00:13:52.270 --> 00:13:55.180
So if you're fading out to something,
it'll actually hide the window

00:13:55.180 --> 00:13:57.740
or order the window out or
hide the view automatically.

00:14:03.900 --> 00:14:10.240
I can have the next slide, please.

00:14:10.240 --> 00:14:16.500
We're starting to see with
those gorgeous 30-inch displays

00:14:16.500 --> 00:14:16.500
that they won't let me have.

00:14:16.910 --> 00:14:18.790
Resolution independent UI.

00:14:18.790 --> 00:14:21.930
What we'd like to be able to do
here is allow the user to set the

00:14:22.020 --> 00:14:25.140
scale of the interface to be as
large or as small as they want,

00:14:25.470 --> 00:14:28.940
and they can make the tradeoff between
detail versus screen real estate.

00:14:28.960 --> 00:14:31.250
If you're like me and you
want everything really,

00:14:31.250 --> 00:14:33.300
really small, you'll be able to do that.

00:14:33.300 --> 00:14:35.640
If you need the windows
a little bit larger,

00:14:35.680 --> 00:14:36.960
you can scale that up.

00:14:36.960 --> 00:14:39.670
This is independent of
the display resolution.

00:14:39.670 --> 00:14:41.710
But what does this mean for you guys?

00:14:41.750 --> 00:14:44.950
It means that you can't make
the assumption anymore that one

00:14:44.950 --> 00:14:45.400
point is equal to one pixel.

00:14:46.020 --> 00:14:49.170
The scaling factor is going to
affect some of the rectangles and

00:14:49.180 --> 00:14:51.820
events that you get in the kit.

00:14:54.600 --> 00:16:28.500
[Transcript missing]

00:16:30.850 --> 00:16:35.370
NSBitmapImageRep now has new support
for additional image formats.

00:16:35.410 --> 00:16:38.580
So we're not just handling
pre-multiplied RGBA anymore.

00:16:38.580 --> 00:16:40.680
We now have floating
point 32-bit samples.

00:16:40.680 --> 00:16:43.740
We can now take alpha as the
first portion of the sample order

00:16:43.740 --> 00:16:46.120
when we read these images in.

00:16:46.120 --> 00:16:47.520
We can also deal with
non-pre-multiplied images.

00:16:47.520 --> 00:16:49.740
And there's also JPEG 2000 support.

00:16:49.740 --> 00:16:52.470
This is probably the longest
method in this entire presentation.

00:16:52.480 --> 00:16:54.860
I don't think it's the
longest method in the kit yet,

00:16:55.140 --> 00:16:55.420
though.

00:16:55.420 --> 00:16:59.280
In it with bitmap data planes,
the important bit down there is

00:16:59.480 --> 00:17:01.820
the NSBitmapFormat bit field.

00:17:01.820 --> 00:17:05.440
That actually lets you say things like,
"I'm loading alpha first," or

00:17:05.440 --> 00:17:08.360
"I'm loading a different format."

00:17:10.290 --> 00:17:12.990
NSGraphicsContext,
you can now specify compositing

00:17:12.990 --> 00:17:14.930
operations in NSGraphicsContext.

00:17:14.930 --> 00:17:18.470
So these are saved and restored along
with all the other operations of

00:17:18.550 --> 00:17:20.980
saveGraphicState and restoreGraphicState.

00:17:21.190 --> 00:17:23.520
They have no effect on existing
things that already take it.

00:17:23.560 --> 00:17:27.660
So composite to point with operation,
that's already handled.

00:17:27.730 --> 00:17:31.700
But this allows you to set the
compositing operation for draws.

00:17:32.520 --> 00:17:34.890
NSView now supports drawing redirection.

00:17:34.980 --> 00:17:38.410
And Panther views drew to Windows or
for printing and things like that,

00:17:38.410 --> 00:17:39.790
and that's pretty much the
only place you could draw.

00:17:39.790 --> 00:17:42.780
Now you can draw view hierarchies,
any view hierarchy,

00:17:42.820 --> 00:17:44.940
to an arbitrary NSGraphics context.

00:17:44.940 --> 00:17:48.300
So you'll be able to take
something like your dialog,

00:17:48.300 --> 00:17:50.950
grab it into an NSGraphics context,
and put it on top of an

00:17:50.950 --> 00:17:54.170
OpenGL view or something like that,
and incorporate that into other

00:17:54.170 --> 00:17:57.130
user interface elements that
may come from other places.

00:17:58.000 --> 00:18:02.490
So you use display rect,
ignoring opacity in context.

00:18:02.540 --> 00:18:06.150
You can get bitmap image rep
for caching display in rect.

00:18:06.280 --> 00:18:09.460
That'll return a caching
appropriate bitmap image rep.

00:18:09.460 --> 00:18:11.780
And cache display in
rect to bitmap image rep,

00:18:11.830 --> 00:18:14.570
you can take the rectangle
for a given view and slam it

00:18:14.570 --> 00:18:16.320
right into that bitmap image.

00:18:19.250 --> 00:18:22.570
Keeping up with NSView and NSWindow,
we have new resizing support.

00:18:22.640 --> 00:18:25.650
One of the things that you do
when you resize a window is that

00:18:25.930 --> 00:18:30.470
you're really only dirtying that
L-shaped portion in the lower right,

00:18:30.470 --> 00:18:32.090
in the right-hand side.

00:18:32.180 --> 00:18:35.410
So you're not dirtying the entire window,
so we probably shouldn't

00:18:35.410 --> 00:18:36.700
draw the entire window.

00:18:36.740 --> 00:18:40.260
So valid contents is preserved
in a drag and a live resize,

00:18:40.260 --> 00:18:44.700
as long as it doesn't move relative to
the upper left-hand corner of the window.

00:18:44.890 --> 00:18:47.240
So this is enabled by
default for Windows.

00:18:47.550 --> 00:18:52.320
So when you drag out the Windows,
you'll get this behavior.

00:18:52.380 --> 00:18:55.000
You can find out--you can opt
out of it using set preserves

00:18:55.000 --> 00:18:57.190
content during live resize,
tell it no.

00:18:57.190 --> 00:18:59.750
You can find out whether
it's doing that or not.

00:18:59.820 --> 00:19:02.910
You can disable it by--it's disabled
by default for views rather.

00:19:02.910 --> 00:19:07.070
So if you override preserves content
during live resize to return yes,

00:19:07.070 --> 00:19:10.120
then it'll start doing
this behavior also.

00:19:10.170 --> 00:19:13.310
But as you're resizing all of this stuff,
you're going to need

00:19:13.310 --> 00:19:15.010
to know where to draw.

00:19:15.050 --> 00:19:16.350
So what changed?

00:19:16.660 --> 00:19:19.900
REC preserve during live resize
is that slot that didn't change,

00:19:19.900 --> 00:19:21.740
that section that didn't change.

00:19:22.100 --> 00:19:26.640
Get RECs exposed during live resize,
you'll get an array of four rectangles.

00:19:26.680 --> 00:19:29.560
At present in the seed,
you're only going to get the bottom two,

00:19:29.600 --> 00:19:31.760
but at most you may actually
wind up getting all four,

00:19:31.760 --> 00:19:37.010
if the view inside can be moved
in the middle of the window.

00:19:37.420 --> 00:19:40.140
So this can be called
anytime during live resize.

00:19:40.190 --> 00:19:42.160
And you have after set frame size,
or before the recursive

00:19:42.250 --> 00:19:43.210
display of the view hierarchy.

00:19:43.240 --> 00:19:46.230
So you've got this window where
you can actually work with it.

00:19:49.000 --> 00:19:49.280
NSWindow now automatically
calculates the key loop.

00:19:49.280 --> 00:19:51.800
So as you add a view,
it's got a bunch of subviews,

00:19:51.800 --> 00:19:53.760
it will automatically
recalculate this for you.

00:19:53.760 --> 00:19:57.230
You can change this behavior using
setAutoRecalculatesKeyViewLoop.

00:19:57.430 --> 00:20:00.000
And there are some accessors there also.

00:20:00.180 --> 00:20:04.000
And you can also tell it immediately
recalculate the key view loop now.

00:20:04.270 --> 00:20:07.000
Adding views to the window
recalculates the key loop.

00:20:07.030 --> 00:20:10.000
So it will do it right when
the window is first ordered in.

00:20:10.000 --> 00:20:11.920
And if you don't set the
initial first responder,

00:20:12.000 --> 00:20:14.000
it's the same as the default.

00:20:14.000 --> 00:20:16.000
And it's based on the order
of the views in the window.

00:20:16.000 --> 00:20:20.020
So if you've been adding things in,
it will do it from that order.

00:20:20.950 --> 00:20:22.410
NS Workspace.

00:20:22.470 --> 00:20:24.840
Moving a little bit
into the file space now.

00:20:24.920 --> 00:20:26.540
Custom icon creation.

00:20:26.640 --> 00:20:28.170
Set icon for file options.

00:20:28.510 --> 00:20:30.800
This supports transparency,
so if you've got any NS image,

00:20:30.800 --> 00:20:33.300
it's got some transparency,
it's got some nice effects in it.

00:20:33.630 --> 00:20:36.800
This will allow you to set
an icon on a given file.

00:20:36.800 --> 00:20:38.790
There are some compatibility options.

00:20:38.910 --> 00:20:41.260
Not all of our releases,
the operating system,

00:20:41.260 --> 00:20:43.120
support all of these icon formats.

00:20:43.120 --> 00:20:45.570
So if you tell it to
exclude quick draw elements,

00:20:45.570 --> 00:20:48.220
icon creation,
then it's only going to be visible,

00:20:48.220 --> 00:20:50.300
the icons will only be visible on 10.4.

00:20:50.480 --> 00:20:52.840
If you exclude the 10-4 elements,
then it'll work everywhere,

00:20:52.880 --> 00:20:55.540
but you won't get the spiffy,
larger icons.

00:20:55.540 --> 00:21:00.190
And this supports
things up to 256 by 256.

00:21:01.920 --> 00:21:05.870
In Panther, there were tablet events,
but tablets to Cocoa really

00:21:05.870 --> 00:21:08.740
looked like a big special mouse.

00:21:08.740 --> 00:21:11.040
And now in Tiger,
we've introduced explicit

00:21:11.150 --> 00:21:12.900
tablet event support.

00:21:12.980 --> 00:21:15.810
So native tablet events for Tiger.

00:21:16.890 --> 00:21:18.590
So you'll get actually proximity events.

00:21:18.600 --> 00:21:22.570
So as the pen approaches the tablet,
you'll actually get the event that says,

00:21:22.600 --> 00:21:24.790
oh, it's getting near the tablet.

00:21:24.900 --> 00:21:26.710
Tablet pointing events,
explicit for that also.

00:21:26.820 --> 00:21:30.800
There are subtypes for the mouse events,
right click, left click, stuff like that.

00:21:30.800 --> 00:21:31.800
And pointer type supports.

00:21:31.800 --> 00:21:36.940
A lot of these pens have
both a pen tip and an eraser.

00:21:36.940 --> 00:21:40.790
So you're actually going to be
able to tell the difference between

00:21:40.790 --> 00:21:40.790
those in the event hierarchy.

00:21:41.340 --> 00:21:43.940
There are accessors for most of
the common tablet properties.

00:21:43.960 --> 00:21:45.960
These are things like pressure.

00:21:45.960 --> 00:21:49.530
So when you stroke the pen,
you actually can find out how hard

00:21:49.530 --> 00:21:51.920
the user is pressing on the tablet.

00:21:51.950 --> 00:21:54.860
You'll get absolute X, Y,
and Z positions.

00:21:54.870 --> 00:21:58.870
You'll also find out whether the
pen is tilted if it supports that.

00:21:58.920 --> 00:22:00.580
Rotation, tangential pressure.

00:22:00.660 --> 00:22:04.240
And these are NS responder methods
for tablet point and tablet proximity.

00:22:04.240 --> 00:22:06.640
So you can hook this right into
the responder chain and handle

00:22:06.640 --> 00:22:09.990
those at a higher level than the
view that you may be looking at.

00:22:12.910 --> 00:22:17.040
NS Tree Controller,
hierarchical data structures.

00:22:17.080 --> 00:22:19.520
The API parallels NSArray Controller.

00:22:19.520 --> 00:22:22.150
So if you've got things
that are a tree structure,

00:22:22.150 --> 00:22:24.330
you can now do tree binding with this.

00:22:25.000 --> 00:22:26.780
It uses NS Index Path from Foundation.

00:22:26.820 --> 00:22:30.730
We'll talk about that in a minute that
defines how to find something in a tree.

00:22:30.740 --> 00:22:33.350
The content can be set to the root
of the tree of the model object.

00:22:33.490 --> 00:22:36.170
So you just hook this up right
to the root and it'll worry

00:22:36.170 --> 00:22:38.130
about finding all the children.

00:22:38.130 --> 00:22:41.220
And it uses KVC to find the
children of a model object.

00:22:41.220 --> 00:22:43.320
So set children key, set count key.

00:22:43.320 --> 00:22:46.760
There's an opportunity
for performance there.

00:22:46.770 --> 00:22:50.150
Insert object at a
range object index path.

00:22:50.150 --> 00:22:52.500
You can provide that so that
you can insert objects into

00:22:52.620 --> 00:22:54.560
the tree at specific locations.

00:22:54.560 --> 00:22:57.680
The implication here is that this is
the mechanism that NS Outline View and

00:22:57.680 --> 00:22:59.600
NS Browser use to be now fully bindable.

00:22:59.620 --> 00:23:04.120
So if you've been waiting for that,
this is your big chance.

00:23:07.490 --> 00:23:11.880
NS Table View now has better
auto-resizing support for its columns.

00:23:11.890 --> 00:23:15.270
So we actually take into account
things like proportional resizing

00:23:15.270 --> 00:23:17.710
for initial positions of columns.

00:23:17.710 --> 00:23:21.190
Set column auto-resizing style,
there's a flag that you can set on that.

00:23:21.190 --> 00:23:23.980
We now support custom
tooltips in NS Table View.

00:23:23.980 --> 00:23:26.770
So if you want different tooltips
on different cells and rows,

00:23:26.770 --> 00:23:29.150
you can get those now by
having your delegate return an

00:23:29.160 --> 00:23:32.790
appropriate string from Table View,
tooltip for cell, rect, table, column,

00:23:32.790 --> 00:23:34.220
row, mouse location.

00:23:34.220 --> 00:23:37.350
It's still shorter than
that one from NS Bitmap.

00:23:37.400 --> 00:23:40.400
Image Rep.

00:23:40.400 --> 00:23:43.380
And finally, in NS Table View,
variable row heights in Tiger.

00:23:48.120 --> 00:23:50.130
So your delegate can actually
say that the height of the

00:23:50.240 --> 00:23:51.360
row is a specific float.

00:23:51.360 --> 00:23:53.880
And you can note that the
height of the row is where the

00:23:53.880 --> 00:23:55.770
specific set of indexes changed.

00:23:57.460 --> 00:24:00.320
and his toolbar item now has some
automatic validation techniques.

00:24:00.490 --> 00:24:02.710
It used to be the toolbar
relied on NSWindow,

00:24:02.710 --> 00:24:06.040
on window updates in order
to do its validation work.

00:24:06.040 --> 00:24:08.360
And now validation can be
done on a per item basis.

00:24:08.390 --> 00:24:10.430
So you can set individual
tool items to say,

00:24:10.480 --> 00:24:14.800
yes, this auto validates, no,
this doesn't.

00:24:15.710 --> 00:24:18.100
You can also avoid overflow
with NSToolbarItems.

00:24:18.100 --> 00:24:21.130
In some cases, in your toolbar,
you may actually want a particular

00:24:21.130 --> 00:24:23.780
button to be on the toolbar all the time,
right?

00:24:23.820 --> 00:24:27.040
So when you resize the window and
that overflow menu gets generated,

00:24:27.050 --> 00:24:31.090
you can actually make sure that
some items will always be visible.

00:24:31.330 --> 00:24:34.920
But in keeping with our theme
that the user is king here,

00:24:34.920 --> 00:24:37.100
the users may want different
items visible themselves.

00:24:37.100 --> 00:24:39.510
So even though you may want something
jammed up there all the time,

00:24:39.510 --> 00:24:41.080
they may want something different.

00:24:41.090 --> 00:24:44.840
There are some priorities you can
set using set visibility priority,

00:24:45.100 --> 00:24:48.510
the standard low, high,
and user priorities.

00:24:48.840 --> 00:24:50.500
Okay, the user one is the most.

00:24:50.500 --> 00:24:53.060
You should not use
anything higher than that.

00:24:53.070 --> 00:24:54.510
You can define any range in here.

00:24:54.510 --> 00:24:55.860
These are defined in the kit headers.

00:24:55.860 --> 00:24:56.880
You can take a look at it.

00:24:56.880 --> 00:25:00.260
But standard means that basically
you're letting us do it.

00:25:00.380 --> 00:25:03.380
If you assign something low,
it will be one of the first things that

00:25:03.380 --> 00:25:05.280
gets pushed off in the overflow menu.

00:25:05.280 --> 00:25:11.790
And if you do something high,
it will stay up and not get overflowed.

00:25:14.050 --> 00:25:15.370
How did this slide wind up there?

00:25:15.370 --> 00:25:20.320
NSFontDescriptor is now the
primary font reference for the kit.

00:25:20.320 --> 00:25:23.040
And this replaces PostScript font
names as the method for

00:25:23.040 --> 00:25:26.950
matching and substitution,
as well as we do cascading with this now,

00:25:26.950 --> 00:25:27.400
too.

00:25:27.400 --> 00:25:35.430
So you can set up different font
descriptors representing various

00:25:35.430 --> 00:25:35.500
attributes without necessarily
having to specify the font itself.

00:25:37.340 --> 00:25:40.530
Texting controls now support
base writing direction support.

00:25:40.530 --> 00:25:44.160
This can be specified
on individual controls.

00:25:44.200 --> 00:25:47.030
There's IB support forthcoming for this,
so that if you're fortunate enough

00:25:47.030 --> 00:25:49.400
to have localizers working for you,
they can set the writing direction

00:25:49.400 --> 00:25:50.690
on the controls in the various nibs.

00:25:50.700 --> 00:25:54.300
The default setting is the natural
writing direction based on the content.

00:25:54.300 --> 00:25:57.710
So if you've got a string that is in
a space that would be right to left,

00:25:57.780 --> 00:25:59.960
this will get picked up
in that way automatically.

00:26:00.850 --> 00:26:03.480
You can set it explicitly using
the base writing direction

00:26:03.490 --> 00:26:06.340
accessors and specific ranges,
and you can also change

00:26:06.340 --> 00:26:07.670
the base writing direction.

00:26:07.680 --> 00:26:10.790
It'll toggle back and forth.

00:26:12.360 --> 00:26:17.070
NSTextView now supports
multiple selection.

00:26:17.130 --> 00:26:20.140
So there are new selection primitives
in the text system for multiple ranges.

00:26:20.170 --> 00:26:21.420
And there are also some
new delegate methods.

00:26:21.420 --> 00:26:24.680
And they take arrays of ranges
rather than just a single range.

00:26:24.860 --> 00:26:26.160
And there's a new Find Panel action, too.

00:26:26.160 --> 00:26:28.610
You can also have-- the
Find Panel actions are hooked up

00:26:28.650 --> 00:26:32.840
to do things like select all of
the things that match all at once.

00:26:32.900 --> 00:26:35.260
Existing methods,
if you've got code that is going

00:26:35.260 --> 00:26:39.850
to operate in a TextView that
has this attribute set,

00:26:39.910 --> 00:26:41.560
it'll return the first sub-range.

00:26:41.560 --> 00:26:42.960
So things will continue to work for you.

00:26:42.960 --> 00:26:44.590
You're only going to find
out about the first sub-range

00:26:44.640 --> 00:26:47.660
that's selected in all of these.

00:26:47.710 --> 00:26:51.080
The text system now supports tables.

00:26:55.580 --> 00:26:59.810
So this is actually text edit
with an HTML imported table here.

00:26:59.940 --> 00:27:03.080
And this is handled
through some new classes,

00:27:03.080 --> 00:27:04.350
as well as lists.

00:27:04.350 --> 00:27:06.900
Text system also supports lists.

00:27:06.900 --> 00:27:10.620
The table's new classes are
NSTextBlock and NSTextTableBlock.

00:27:10.620 --> 00:27:13.960
The lists allow you to do things
like customize the marker format,

00:27:13.960 --> 00:27:15.910
so you can have one dot
or you can have a bullet,

00:27:15.910 --> 00:27:16.900
or things like that.

00:27:16.920 --> 00:27:18.490
These appear on attributes
on the paragraphs,

00:27:18.510 --> 00:27:21.230
and there are also conveniences
for these on NSAttributedStrings.

00:27:21.310 --> 00:27:24.400
You'll be able to pick these out of your
strings and render them how you like,

00:27:24.400 --> 00:27:28.260
but the tech system will take care of
all the tables and stuff for you now.

00:27:29.190 --> 00:27:31.730
We've also started to incorporate,
in keeping up with Spotlight

00:27:31.730 --> 00:27:34.850
and things like that,
new document metadata.

00:27:34.900 --> 00:27:36.800
So there are new document
attributes in our,

00:27:36.800 --> 00:27:39.090
in our RTF files that we
support in the RTF reader.

00:27:39.090 --> 00:27:43.070
For title, what company, subjects,
authors.

00:27:43.170 --> 00:27:46.020
If you're fortunate enough to have an
editor who takes a look at your stuff,

00:27:46.060 --> 00:27:48.100
you can set the editor
document attribute type.

00:27:48.400 --> 00:27:54.110
All of these are available to
check for in the Spotlight APIs,

00:27:54.190 --> 00:27:57.380
as well as right off
the document attributes.

00:27:57.750 --> 00:27:58.510
NS-Type-setter.

00:27:58.510 --> 00:28:01.320
I've taken a lot of the stuff
that was in the ATS-Type-setter,

00:28:01.320 --> 00:28:04.510
the Apple type system type setter,
moved it up as the default

00:28:04.600 --> 00:28:06.890
type setter system now in,
in Tiger.

00:28:06.970 --> 00:28:10.010
And you'll be able to do things
like implement concrete subclasses

00:28:10.010 --> 00:28:11.440
with your own layout engines.

00:28:11.450 --> 00:28:14.160
And there's new access to a
number of ranges and attributes.

00:28:14.180 --> 00:28:15.980
I could talk for an
hour on the text system,

00:28:15.980 --> 00:28:18.770
but personally I don't know
enough about it and you guys don't

00:28:18.770 --> 00:28:20.400
have an hour to sit here for it.

00:28:20.420 --> 00:28:23.580
But there's another hour,
Advanced Development with Cocoa Text,

00:28:23.730 --> 00:28:25.020
session 437 on Friday.

00:28:25.020 --> 00:28:31.890
Doug Davidson will be talking about that
and he'll go into all of the tables,

00:28:32.070 --> 00:28:37.880
lists and everything for, for Cocoa Text.

00:28:39.530 --> 00:28:40.890
Talk about Foundation.

00:28:40.930 --> 00:28:44.100
Move down a step.

00:28:44.120 --> 00:28:49.670
Foundation now includes a new class,
NSXML

00:28:52.720 --> 00:28:55.420
This is a DOM-based API.

00:28:55.420 --> 00:28:57.350
You can initialize this from
strings and other types.

00:28:57.360 --> 00:28:59.620
So if you have a URL--or if
you have an XML--if you have

00:28:59.670 --> 00:29:02.320
an NSString that contains XML,
you can initialize it from that.

00:29:02.360 --> 00:29:06.460
You can also initialize it right off the
network with a NIT with contents of URL.

00:29:06.470 --> 00:29:09.600
There are options to set here,
things like fidelity and

00:29:09.600 --> 00:29:13.010
what kind of preservation
you want and stuff like that.

00:29:13.040 --> 00:29:15.570
It provides a DOM-like model,
so you can find out how many

00:29:15.860 --> 00:29:20.360
children are in a particular node,
what the children are, insertion,

00:29:20.460 --> 00:29:23.310
deletion, things like that.

00:29:24.360 --> 00:29:28.360
It also supports a lot of querying
and transformation behaviors.

00:29:28.360 --> 00:29:32.300
So XPath and Xquery are two query
formats that allow you to ask

00:29:32.300 --> 00:29:36.180
questions of the document and find
out more information from that.

00:29:36.180 --> 00:29:39.360
So you can actually say,
"Give me all of the nodes that have

00:29:39.400 --> 00:29:42.960
attributes of this particular value."
So the XPath--nodes for XPath,

00:29:42.960 --> 00:29:46.580
error and error will get returned
to you if something goes wrong.

00:29:46.580 --> 00:29:49.980
Objects for Xquery,
Xquery is a technology that we've

00:29:49.980 --> 00:29:52.540
been putting into things like
Sherlock and stuff like that.

00:29:52.540 --> 00:29:54.560
We also have XSLT support.

00:29:54.630 --> 00:29:57.540
So if you have a DOM tree and
you have an XSLT transform,

00:29:57.540 --> 00:30:01.030
you can just ask for object by
applying XSLT and you'll get

00:30:01.030 --> 00:30:02.940
back the appropriate items.

00:30:02.940 --> 00:30:05.660
So that may be an NSXML document
depending on what you

00:30:05.670 --> 00:30:07.860
ask for in the transform.

00:30:07.870 --> 00:30:11.490
There is a session on this as well,
"Easy and Powerful XML Processing

00:30:11.600 --> 00:30:15.520
with Cocoa." That's Friday at 10:30.

00:30:15.520 --> 00:30:16.760
So if you're still here,
you should probably go

00:30:16.770 --> 00:30:17.340
take a look at that.

00:30:17.340 --> 00:30:18.410
It's going to be an excellent talk.

00:30:21.290 --> 00:30:22.260
NSLocale.

00:30:22.260 --> 00:30:27.810
Now with a lot more localization
information and things like that,

00:30:27.830 --> 00:30:31.430
this is the preferred mechanism
and foundation to get localization

00:30:31.480 --> 00:30:33.180
information out of the system.

00:30:33.180 --> 00:30:35.650
So a lot of the things that you would
have gone to NS user defaults for,

00:30:35.650 --> 00:30:37.780
you're going to go to NSLocale for now.

00:30:37.780 --> 00:30:42.230
There's a lot of general information
that's stored in the NSLocale class.

00:30:42.230 --> 00:30:45.690
NS--you can ask for the
available locale identifiers.

00:30:45.690 --> 00:30:49.400
There are ISO language codes,
country codes, currency codes.

00:30:49.400 --> 00:30:53.880
You can also ask for all the components
from a specific locale identifier.

00:30:53.930 --> 00:30:56.290
And once you've got a locale,
you can get information from it.

00:30:56.290 --> 00:30:59.000
So object for key will tell you
basically the same kind of localization

00:30:59.000 --> 00:31:02.030
information you're getting from--again,
from NS user defaults.

00:31:02.100 --> 00:31:04.850
Display name for key value,
some of these may be localized in their

00:31:04.850 --> 00:31:08.820
particular languages and that's what this
display name for key value method is for.

00:31:08.820 --> 00:31:12.110
So you can get information
that represents the actual

00:31:12.110 --> 00:31:13.600
localized value for those.

00:31:15.000 --> 00:31:17.520
In continuing with this,
NSDateFormatter now has a

00:31:17.520 --> 00:31:18.950
number of new capabilities.

00:31:19.050 --> 00:31:22.000
There are a lot more settings
to configure in NSDateFormatter.

00:31:22.000 --> 00:31:25.000
You can go through and toggle
all sorts of switches in it.

00:31:25.000 --> 00:31:27.470
This is also replacing a lot of
the functionality that you would

00:31:27.470 --> 00:31:28.990
have gotten from NSUserDefaults.

00:31:28.990 --> 00:31:34.780
It's based on the CFDateFormatter,
stuff that we've got

00:31:34.780 --> 00:31:36.310
down in Core Foundation.

00:31:36.310 --> 00:31:36.310
That's actually based on the
international components for Unicode.

00:31:36.600 --> 00:31:39.000
So one side effect of this is
there's a new format string

00:31:39.000 --> 00:31:41.000
available in date formatter.

00:31:41.000 --> 00:31:42.400
So some of the things
that you've been doing,

00:31:42.400 --> 00:31:44.410
you'll have to change a little
bit in order to get this

00:31:44.410 --> 00:31:46.120
format to work correctly.

00:31:46.120 --> 00:31:47.810
So if you've been formatting
dates in a particular way,

00:31:47.810 --> 00:31:49.720
you may have to tweak that a little bit.

00:31:49.720 --> 00:31:51.050
There's a compatibility mode.

00:31:51.050 --> 00:31:54.080
Applications linked on
Panther will actually get this

00:31:54.080 --> 00:31:55.990
compatibility information.

00:31:56.020 --> 00:31:59.080
And you can set it so that the
formatter behavior will act

00:31:59.080 --> 00:32:00.610
the old way versus the new way.

00:32:00.610 --> 00:32:03.230
So if you've got existing code,
you want to make sure that it's

00:32:03.240 --> 00:32:05.150
actually going to continue to
work the way you expect it,

00:32:05.240 --> 00:32:07.920
can use this set format
or behavior method.

00:32:10.230 --> 00:32:13.440
NSNumber formatter also has
a number of new capabilities.

00:32:13.550 --> 00:32:15.290
There are new styles in formatting.

00:32:15.420 --> 00:32:19.060
You can format decimal, currency,
or scientific styles.

00:32:19.060 --> 00:32:21.460
You can spell things out, actually.

00:32:21.470 --> 00:32:23.500
There are a number of new settings
for this for group separators,

00:32:23.520 --> 00:32:26.100
whether you're showing
decimal in group separators.

00:32:26.140 --> 00:32:29.210
Prefix and suffixes for numbers,
as well as text attributes

00:32:29.240 --> 00:32:30.380
for some of those values.

00:32:30.380 --> 00:32:32.240
And this also has compatibility mode.

00:32:32.240 --> 00:32:36.990
Again, if you've got existing code,
it'll continue to work the old way,

00:32:36.990 --> 00:32:39.340
but this is new for Tiger.

00:32:41.800 --> 00:32:43.540
We spend a lot of time trying to do this.

00:32:43.540 --> 00:32:46.820
We're deprecating as many
C string methods that do not have

00:32:46.820 --> 00:32:48.990
encoding arguments as we can.

00:32:49.600 --> 00:32:52.320
So you've got a blob of data,
but you don't have any

00:32:52.320 --> 00:32:54.980
encoding information,
and instantiating a string from

00:32:54.980 --> 00:32:57.980
that is sort of fraught with a
little bit of guesswork and peril.

00:32:58.090 --> 00:33:00.780
So some new methods will report
errors in encoding conversion.

00:33:00.780 --> 00:33:03.320
There are a lot of new methods
for the C string encoding.

00:33:03.320 --> 00:33:06.530
We deprecated a bunch,
put a bunch in with encoding support,

00:33:06.570 --> 00:33:09.310
and it turns out we actually have
less API than we started with.

00:33:09.320 --> 00:33:12.340
So you can convert using
a specific encoding,

00:33:12.340 --> 00:33:16.150
using init with C string encoding.

00:33:16.160 --> 00:33:18.070
There's also string encoding sensing.

00:33:18.130 --> 00:33:20.100
So when you init with
the contents of a URL,

00:33:20.100 --> 00:33:22.760
we're going to pick out and try to
figure out what encoding that is.

00:33:22.800 --> 00:33:26.140
And you'll get an error back.

00:33:27.820 --> 00:33:29.810
You can also specify the
encoding on the output.

00:33:29.820 --> 00:33:31.990
So when you write to the URL,
if you specify an

00:33:31.990 --> 00:33:35.700
encoding that it can't do,
you'll get an error back about that also.

00:33:35.810 --> 00:33:37.790
And again,
we're trying to put as many places

00:33:38.080 --> 00:33:41.470
in Foundation in the kit where
we're using this error parameter

00:33:41.470 --> 00:33:45.100
to be able to allow you to return
more information up to the user.

00:33:48.080 --> 00:33:50.360
NSNet Service has some new features.

00:33:50.500 --> 00:33:53.050
One of the things that developers
did a lot-- and I have to admit,

00:33:53.050 --> 00:33:56.320
that's partially my fault,
because I did it in a sample code--

00:33:56.350 --> 00:33:59.460
oops-- was leaving the resolve open.

00:33:59.470 --> 00:34:01.230
If you leave the resolve
open for a long time,

00:34:01.230 --> 00:34:04.280
that generates a lot of network traffic.

00:34:04.280 --> 00:34:07.720
So now what we're doing is we're allowing
you to specify a timeout for resolves.

00:34:07.790 --> 00:34:09.620
So you can say, resolve for five seconds.

00:34:09.720 --> 00:34:11.270
Usually, if something's going to happen,
it's going to happen

00:34:11.340 --> 00:34:12.140
in that five seconds.

00:34:12.140 --> 00:34:15.940
So if you haven't gotten a response back,
it probably isn't coming.

00:34:16.080 --> 00:34:19.300
So there's also text record access.

00:34:19.380 --> 00:34:23.500
So for whatever reason,
the old get and set protocol specific

00:34:23.530 --> 00:34:26.970
information methods are actually
deprecated now in NSNet Service.

00:34:27.060 --> 00:34:28.980
And these are what you
should be using instead.

00:34:29.140 --> 00:34:31.060
Set text record data
and text record data.

00:34:31.060 --> 00:34:33.100
These are just NSData blobs.

00:34:33.170 --> 00:34:36.640
There's some conveniences to shift
things back and forth in NSNet Service.

00:34:36.740 --> 00:34:38.580
But this will allow you to be
able to put that information

00:34:38.580 --> 00:34:42.420
out so that other rendezvous
enabled applications can see that.

00:34:42.540 --> 00:34:45.810
It's a little data payload in each
Net Service that you can put in.

00:34:45.900 --> 00:34:47.730
And you can monitor those
for when they change.

00:34:47.800 --> 00:34:50.880
So this is actually very similar to
the mechanism that iChat uses in order

00:34:51.090 --> 00:34:56.900
to update your status on rendezvous
and update your status string.

00:34:56.900 --> 00:34:59.460
You can do the same kind of thing
now with NSNet Service using start

00:34:59.780 --> 00:35:01.460
monitoring and stop monitoring.

00:35:01.490 --> 00:35:04.210
And there's a new Net Service delegate
did update text record data

00:35:04.210 --> 00:35:07.430
where when the remote service
updates its text record,

00:35:07.430 --> 00:35:10.680
you'll get the data
back in that callback.

00:35:13.130 --> 00:35:14.310
NSIndexPath.

00:35:14.310 --> 00:35:18.590
NSIndexPath is a way that you
represent sequences of indexes.

00:35:18.630 --> 00:35:22.990
So, it'll be something like 1.3.5,
which is the fifth child of the third

00:35:22.990 --> 00:35:25.970
child of the first element in the path.

00:35:25.980 --> 00:35:29.530
It's for navigating a tree of objects,
and this is partly how NSTreeController

00:35:29.530 --> 00:35:31.970
gets a lot of its work done.

00:35:32.200 --> 00:35:37.110
There are also accessors for this,
index at position and get indexes.

00:35:37.300 --> 00:35:41.060
This will allow you to be able to pick
out individual indexes along the way.

00:35:42.030 --> 00:35:44.800
The mechanism,
if you have to use this directly,

00:35:44.800 --> 00:35:47.050
that's fine,
but it's mainly a behind the scenes

00:35:47.370 --> 00:35:49.990
edition specifically for Tree Controller.

00:35:51.800 --> 00:35:55.700
You've heard me jumping up and
down about NSError for a while.

00:35:55.700 --> 00:35:58.660
We've specified a new error
domain for the Cocoa frameworks.

00:35:58.720 --> 00:36:00.820
So NSCocoaErrorDomain,
as much as possible,

00:36:00.820 --> 00:36:04.400
is going to be the error that we use,
the error domain that we use.

00:36:04.400 --> 00:36:06.660
It may contain underlying
errors from other systems.

00:36:06.660 --> 00:36:09.360
So if a file not found error
occurred way down here,

00:36:09.360 --> 00:36:10.690
we'll bubble that up.

00:36:10.750 --> 00:36:15.090
It will also include the underlying
NSErrors as keys in the dictionary,

00:36:15.100 --> 00:36:17.140
as we were trying to do before.

00:36:17.140 --> 00:36:21.490
This CocoaErrorDomain is specifically
for use with foundation in the kit.

00:36:21.700 --> 00:36:26.610
We've defined a number of error codes
in app kit errors and foundation errors

00:36:26.610 --> 00:36:29.420
in order to describe all of these.

00:36:29.420 --> 00:36:32.980
There are some new methods
for richer error recovery.

00:36:32.980 --> 00:36:34.830
So localized description
was already there,

00:36:34.910 --> 00:36:38.080
and that's what you should be using
to describe the problem that occurred.

00:36:38.090 --> 00:36:40.720
The localized recovery
suggestion is an opportunity

00:36:40.720 --> 00:36:44.300
for you to say something like,
"Oh, you tried to save a document,

00:36:44.300 --> 00:36:45.710
and the disk is full."

00:36:46.000 --> 00:36:54.690
The Localized Recovery Options returns
an array of actions that the user can

00:36:54.690 --> 00:36:58.100
take in order to solve their problem.

00:36:58.100 --> 00:37:03.910
These should be designed specifically
for presentation to the user.

00:37:04.240 --> 00:37:07.540
What you do with a domain
in code is up to you,

00:37:07.690 --> 00:37:13.060
but these descriptions should be handled
specifically for showing to the user.

00:37:13.060 --> 00:37:16.690
We're trying to work on a couple of
interesting ways to be able to bubble

00:37:16.690 --> 00:37:20.320
this all the way up through into the kit,
and perhaps handle errors

00:37:20.320 --> 00:37:22.920
in a more graceful,
dynamic fashion.

00:37:24.750 --> 00:37:28.090
Spotlight metadata.

00:37:28.130 --> 00:37:30.640
Most of the files on your disks have
a number of different attributes.

00:37:30.640 --> 00:37:33.660
All right, creator, creation, time,
content, type.

00:37:33.940 --> 00:37:37.970
Images have sizes and widths and
heights and DPIs and things like that.

00:37:37.980 --> 00:37:40.210
And one of the things that we'd
like to be able to do is find them

00:37:40.210 --> 00:37:42.350
absolutely as fast as possible.

00:37:42.350 --> 00:37:43.980
All right.

00:37:43.980 --> 00:37:45.710
And as files change as
they come onto the disk,

00:37:45.770 --> 00:37:47.820
as they leave the disk,
we want to find out about those

00:37:47.820 --> 00:37:50.680
changes as much as--as fast as we can.

00:37:50.770 --> 00:37:54.380
One of the ways that we do this
is now with NSMetadataQuery.

00:37:54.480 --> 00:37:59.610
So this is the Cocoa API that
surrounds the Spotlight API that

00:37:59.680 --> 00:38:03.780
Steve was using in this demo and that
I believe there's a talk about soon,

00:38:03.780 --> 00:38:04.960
in the next couple of days.

00:38:04.960 --> 00:38:07.360
It uses NSPredicate.

00:38:07.360 --> 00:38:09.470
NSPredicate lives up in
a different framework.

00:38:09.480 --> 00:38:12.760
It lives up in Core Data.

00:38:12.780 --> 00:38:15.960
It's an expression that evaluates to
true or false given a set of objects.

00:38:16.180 --> 00:38:18.870
So you'll construct a predicate
that will define the kinds of

00:38:18.870 --> 00:38:20.820
things that you're searching for.

00:38:20.840 --> 00:38:23.480
And this finds files
matching that predicate.

00:38:23.520 --> 00:38:24.760
And then it stores the results.

00:38:24.760 --> 00:38:27.130
So you touch off the query,
and it's actually going to go

00:38:27.130 --> 00:38:29.050
out and find all this stuff,
and it's going to hang on

00:38:29.050 --> 00:38:30.240
to these results for you.

00:38:30.270 --> 00:38:33.520
And it can group these
results and attributes.

00:38:33.550 --> 00:38:35.960
So it can actually hang on
to all of these and say,

00:38:36.070 --> 00:38:42.380
OK, well, I've got this list of results,
and I'll sort them according to

00:38:42.820 --> 00:38:45.410
their creator or their author.

00:38:45.880 --> 00:38:48.420
can also answer some specific
questions about the results set,

00:38:48.630 --> 00:38:51.440
but most importantly,
it's actually a bindable model object.

00:38:51.500 --> 00:38:58.550
So once you set off one of these queries,
you can actually hook it up in

00:38:58.550 --> 00:38:59.170
Interface Builder and bind right to it.

00:38:59.170 --> 00:38:59.170
So you can have a very
dynamic user interface.

00:39:00.970 --> 00:39:03.160
Setting up a query is very simple.

00:39:03.220 --> 00:39:06.910
You create it with alloc init,
you set the query's predicate,

00:39:06.910 --> 00:39:08.600
and you start the query.

00:39:09.230 --> 00:39:11.560
You can optionally stop the query,
but if you leave the query open,

00:39:11.560 --> 00:39:14.280
it will continue to update its results.

00:39:14.650 --> 00:39:17.120
So set predicate, start query,
and stop query.

00:39:17.200 --> 00:39:19.690
This happens actually
on the current run loop,

00:39:19.780 --> 00:39:23.300
the run loop that you
instantiated the object on.

00:39:24.720 --> 00:39:27.470
And you can handle the results
either by direct access or binding.

00:39:27.580 --> 00:39:30.300
So there's actually an accessor for
result count and result at index.

00:39:30.320 --> 00:39:32.920
So you can actually ask it
specifically for individual

00:39:32.920 --> 00:39:35.220
results and at specific locations.

00:39:35.320 --> 00:39:37.840
Or you can just bind
to the results array.

00:39:38.000 --> 00:39:41.240
The results set has a value list.

00:39:41.240 --> 00:39:44.980
The value list is something like if
I've searched for all the RTFs on

00:39:44.980 --> 00:39:48.100
my machine and I come up with 15,
I'll probably come up with a lot more,

00:39:48.100 --> 00:39:50.300
but if I come up with only 15,
then I might have three

00:39:50.300 --> 00:39:51.310
individual authors.

00:39:51.310 --> 00:39:53.480
It might be me and Ali, my boss,
and Mark,

00:39:53.480 --> 00:39:55.280
the guy who works down the hall.

00:39:56.270 --> 00:40:00.700
So those three authors
work on those 15 documents.

00:40:00.700 --> 00:40:02.840
That's one way that I can
group those documents.

00:40:02.860 --> 00:40:05.620
Or I might have 250 MP3s
that I've searched for,

00:40:05.750 --> 00:40:07.660
and they might only be in three genres.

00:40:08.000 --> 00:40:09.000
Or four.

00:40:09.000 --> 00:40:13.970
Rock, pop, classical, and something else.

00:40:14.200 --> 00:40:17.160
I'd say country, but I'd be terribly

00:40:18.250 --> 00:40:20.060
Results can be sorted by
the NS metadata query.

00:40:20.090 --> 00:40:22.420
One of the things that happens is
the query is going to go out and

00:40:22.500 --> 00:40:23.710
it's going to do all this work.

00:40:23.710 --> 00:40:25.710
It's going to find all
these files on your disk.

00:40:25.750 --> 00:40:28.660
But since the query has all
of this information about it,

00:40:28.660 --> 00:40:30.370
you can tell the query to sort it.

00:40:30.400 --> 00:40:32.650
And this is actually
a big performance win.

00:40:32.720 --> 00:40:34.700
The query knows all this information.

00:40:34.720 --> 00:40:37.440
It can do all the work to sort
it as the results come in.

00:40:37.460 --> 00:40:40.420
And then when you actually go
ahead and display this in your

00:40:40.420 --> 00:40:43.720
table view or in your outline view,
it's taking care of a lot of the

00:40:43.720 --> 00:40:46.010
heavy lifting for the sorting for you.

00:40:46.910 --> 00:40:52.750
Results can also be grouped
by their attribute values.

00:40:52.750 --> 00:40:52.750
So again, those

00:40:53.050 --> 00:40:56.770
Country MP3s can get
packed into one group,

00:40:56.770 --> 00:41:00.160
along with, and then all the rock ones,
and

00:41:01.800 --> 00:41:05.060
classical ones.

00:41:05.070 --> 00:41:09.900
And this metadata query also
supports asynchronous updates.

00:41:09.970 --> 00:41:14.890
So as-- if you leave the query open,
as files come and go from your disk,

00:41:14.890 --> 00:41:16.400
this thing gets updated.

00:41:16.620 --> 00:41:17.910
So the queries go through a phase.

00:41:17.920 --> 00:41:20.940
When you first create them and
you touch off the Start Query,

00:41:20.940 --> 00:41:21.960
there's a gathering phase.

00:41:21.960 --> 00:41:22.460
It's going out.

00:41:22.460 --> 00:41:25.000
It's finding as many
results as it can initially,

00:41:25.030 --> 00:41:28.180
and it's going to drop-- it's going
to return those results to you.

00:41:28.190 --> 00:41:31.810
If you continue to let the query run,
new results matching the

00:41:31.810 --> 00:41:35.520
predicate will just appear and
you'll get a callback for that.

00:41:35.900 --> 00:41:42.190
and files no longer matching
the predicate will disappear.

00:41:42.190 --> 00:41:42.190
So if you have all this bound,
all this stuff sort of

00:41:42.190 --> 00:41:42.190
just happens automatically.

00:41:42.570 --> 00:41:43.790
There are some implications for this.

00:41:43.830 --> 00:41:46.130
You should be as lazy as
possible when you're using this.

00:41:46.130 --> 00:41:48.070
So when you get some of
these notifications that say,

00:41:48.070 --> 00:41:50.190
"Hey,
my results have changed," you should

00:41:50.190 --> 00:41:53.360
do as little processing as possible,
because the idea here is that

00:41:53.360 --> 00:41:55.880
you're providing a dynamic
look at the file system.

00:41:57.380 --> 00:42:00.970
A window into what's happening
as things come and go.

00:42:00.970 --> 00:42:02.300
Okay.

00:42:02.300 --> 00:42:05.100
And actually I have a
short demo here as well.

00:42:05.100 --> 00:42:08.810
So if we could cut over.

00:42:18.130 --> 00:42:30.340
So I have in my nib a simple field here
with a start button and a table view.

00:42:30.360 --> 00:42:34.090
And if we look at the table view here,
we'll see in the table columns

00:42:34.090 --> 00:42:37.890
portion of things that I've got
these bound to some identifiers.

00:42:38.010 --> 00:42:41.700
This identifier is actually
this KMDItemFS name is actually

00:42:41.700 --> 00:42:43.780
in the spotlight framework.

00:42:43.780 --> 00:42:47.050
And this is--these will
be defined--this is the

00:42:48.020 --> 00:42:54.560
The path here is the path
name of the file on disk,

00:42:54.680 --> 00:42:56.950
and that's actually bound to KMDItemPath.

00:42:56.950 --> 00:43:00.900
I've got my little results
array controller here,

00:43:01.320 --> 00:43:08.900
and those bindings are set up to
the content array of my results.

00:43:08.910 --> 00:43:14.200
And if we take a look at the
code here for a brief moment,

00:43:19.700 --> 00:43:20.960
You'll see this in the release notes.

00:43:21.030 --> 00:43:24.230
This is a way that we can control
what the notifications are that

00:43:24.230 --> 00:43:29.380
you'll get for various things like the
initial notification count and time,

00:43:29.380 --> 00:43:32.730
the progress notification,
and update notifications for

00:43:32.840 --> 00:43:34.660
how often you get callbacks.

00:43:34.660 --> 00:43:38.200
You can't really crank these down,
but you can extend the time.

00:43:38.200 --> 00:43:39.710
You don't want to get these
notifications a lot because

00:43:39.790 --> 00:43:40.880
it'll affect your performance.

00:43:41.540 --> 00:43:45.940
I have a sender action here
set up to toggle the query.

00:43:45.940 --> 00:43:50.330
So if I'm being told to start here,
I'm going to set up my predicate

00:43:50.750 --> 00:43:54.630
so that I'm looking for file
system names that are matching

00:43:54.630 --> 00:43:59.020
what I typed into the query string,
query field string.

00:43:59.460 --> 00:44:04.400
I create this NS predicate,
and then set the predicate on the query.

00:44:04.400 --> 00:44:07.780
I actually skipped a step here in that
when this thing wakes up from the nib,

00:44:07.780 --> 00:44:10.400
it allocates and it knits itself.

00:44:11.120 --> 00:44:14.830
We set these parameters in order
to handle the notifications,

00:44:14.830 --> 00:44:17.920
and then here I'm actually taking
advantage of the fact that Query is

00:44:17.920 --> 00:44:21.050
going to set these sort descriptors,
and it's going to set up an

00:44:21.050 --> 00:44:25.140
initial sort for the file system
name based on an ascending sort.

00:44:25.160 --> 00:44:32.630
I've added some notifications in here
that I believe actually I'm driving the

00:44:33.280 --> 00:44:53.290
will change and did change right here,
but you can't bind to this directly.

00:44:53.290 --> 00:44:53.290
And then, I just set the delegate,
start the query,

00:44:53.290 --> 00:44:53.290
and change my button title.

00:44:53.290 --> 00:44:53.290
There's not a whole lot of code here,
but it does actually--.

00:44:57.000 --> 00:45:08.120
There may be more things on
this disk than I thought.

00:45:08.120 --> 00:45:10.190
Hopefully, I won't have to show you
the crash reporter either.

00:45:18.500 --> 00:45:20.990
I think this G5 has a bigger
hard drive than my laptop.

00:45:21.000 --> 00:45:28.040
I'm not sure.

00:45:28.040 --> 00:45:30.780
I'd go back and look at the code,
but you've already seen it.

00:45:40.510 --> 00:45:41.400
Great.

00:45:41.400 --> 00:45:42.880
I joked that I was going to have
a John Cameron Swayze here moment

00:45:42.880 --> 00:45:44.390
and had to say I don't get it.

00:45:44.440 --> 00:45:46.560
It worked in rehearsal, but it did.

00:45:46.560 --> 00:45:48.200
It worked in rehearsal.

00:45:48.540 --> 00:45:51.620
You'll just, I suppose,
have to take my word for it.

00:45:51.650 --> 00:45:55.540
But--no, that's the P list.

00:45:55.540 --> 00:46:03.500
But again, it's mainly just making sure
that you set the predicate up,

00:46:03.500 --> 00:46:03.500
initialize the sort descriptors, and

00:46:04.700 --> 00:46:18.000
[Transcript missing]

00:46:19.600 --> 00:46:20.590
There we go.

00:46:20.880 --> 00:46:23.980
That are coming out in Tiger.

00:46:23.980 --> 00:46:24.000
Okay.

00:46:24.000 --> 00:46:25.920
One of them is the Core Data Framework.

00:46:26.000 --> 00:46:28.600
Core Data Framework provides
object life cycle management.

00:46:28.690 --> 00:46:31.120
This is a model-driven system.

00:46:31.150 --> 00:46:35.080
This is a way to manage persistence,
both in getting stuff up off of disk into

00:46:35.150 --> 00:46:37.510
memory and getting it back out to disk.

00:46:37.510 --> 00:46:40.670
There's a custom subclass,
NS Persistent Document,

00:46:40.670 --> 00:46:44.010
that's been defined that handles this.

00:46:44.120 --> 00:46:45.730
This will also allow you to
do a significant amount of

00:46:45.730 --> 00:46:48.480
UI synchronization with a lot of
very tight bindings integration.

00:46:48.480 --> 00:46:49.760
Okay.

00:46:49.760 --> 00:46:53.400
One of the side effects of using
Core Data is automatic undo and redo.

00:46:53.490 --> 00:46:55.860
And this is actually a new
framework that's on Tiger.

00:46:55.860 --> 00:46:57.140
This is under the Cocoa umbrella.

00:46:57.140 --> 00:46:58.140
Okay.

00:46:58.140 --> 00:47:01.100
So if you're linking the Cocoa framework,
you're getting this for free.

00:47:01.100 --> 00:47:03.270
And this provides everything
from faulting objects and now

00:47:03.270 --> 00:47:06.050
so you have 10,000 objects and
you're only looking at 50 of them.

00:47:06.260 --> 00:47:08.780
It'll take care of keeping only
those 50 in memory and handling

00:47:08.780 --> 00:47:10.260
all of the rest as dynamic objects.

00:47:10.310 --> 00:47:14.190
It handles all sorts of things like--.

00:47:14.250 --> 00:47:20.400
Both actual object inheritance
as well as entity inheritance.

00:47:20.400 --> 00:47:21.640
And there's--let me go back here.

00:47:21.640 --> 00:47:23.490
There's actually an
introduction to Core Data Talk.

00:47:23.490 --> 00:47:24.820
This is Andreas Wanker's team.

00:47:25.220 --> 00:47:29.550
That's at session 418, Wednesday at 2:00.

00:47:30.960 --> 00:47:31.650
The Qt kit.

00:47:31.960 --> 00:47:36.040
There's a new QuickTime kit on Tiger,
providing Objective-C APIs,

00:47:36.040 --> 00:47:38.440
new things for classes
for QuickTime media,

00:47:38.440 --> 00:47:41.530
for Qt movie, movie view, track media,
stuff like that.

00:47:41.540 --> 00:47:43.420
There's an IB palette for this.

00:47:43.420 --> 00:47:46.330
And this actually completely
adopts the Cocoa API model,

00:47:46.330 --> 00:47:47.890
using delegates and notifications.

00:47:47.940 --> 00:47:49.990
You don't have to drop into
idle procs and FS specs,

00:47:50.100 --> 00:47:50.990
anything like that.

00:47:51.020 --> 00:47:53.240
And it also covers
media import and export.

00:47:54.100 --> 00:47:59.400
And this is actually Thursday,
session 214 at 9 a.m.

00:47:59.400 --> 00:48:00.780
There's going to be a talk about that.

00:48:02.400 --> 00:48:07.400
The Instant Message framework
provides present services.

00:48:07.440 --> 00:48:09.720
So when your buddies change--

00:48:10.590 --> 00:48:14.150
There's online status availability
methods for getting all the

00:48:14.420 --> 00:48:16.190
buddy information out of

00:48:16.410 --> 00:48:19.190
provides official art
for the present status.

00:48:19.200 --> 00:48:23.240
Those little jelly gumdrops that
are green and yellow and red.

00:48:23.350 --> 00:48:26.390
It'll map AB persons and
name handles automatically.

00:48:26.970 --> 00:48:29.580
And this is actually the same
mechanism that iChat uses in

00:48:29.580 --> 00:48:31.150
order to get its work done.

00:48:31.420 --> 00:48:34.700
So you can actually add this
to your applications now.

00:48:35.500 --> 00:48:37.640
You saw in the demo,
core image framework provides

00:48:37.640 --> 00:48:39.840
image processing that's going
to push all the filtering and

00:48:39.920 --> 00:48:43.240
transforms and effects and things
like that off on the graphics card.

00:48:43.280 --> 00:48:45.750
So if you really wanted to hear
those fans fire up in the PowerBook,

00:48:45.830 --> 00:48:48.840
you've got an opportunity
to do it in Cocoa here.

00:48:48.890 --> 00:48:51.140
It uses the graphics card to do the work.

00:48:51.190 --> 00:48:54.450
There will be APIs to convert
between NS images and CI images,

00:48:54.450 --> 00:48:56.700
and NS colors and CI colors,
so you can do all those

00:48:56.700 --> 00:48:58.700
sepia tones and the things.

00:48:58.700 --> 00:49:01.540
If you want to make all the
electric zebras you want,

00:49:01.540 --> 00:49:02.150
you can.

00:49:05.520 --> 00:49:07.880
Please, read the release notes.

00:49:08.050 --> 00:49:10.450
There's a lot of bug fixes
described in the release notes,

00:49:10.450 --> 00:49:13.360
a lot of pointers to new behaviors,
a lot of different techniques for

00:49:13.360 --> 00:49:16.350
handling a lot of these new behaviors,
as well as APIs that

00:49:16.520 --> 00:49:18.870
I didn't even mention here.

00:49:18.880 --> 00:49:20.270
There's a lot of stuff in Cocoa.

00:49:20.300 --> 00:49:24.580
The documentation is now in the,
I believe on the Tiger seat,

00:49:24.630 --> 00:49:27.840
it's in ADC reference
library documentation,

00:49:27.910 --> 00:49:28.680
Cocoa.

00:49:28.680 --> 00:49:30.930
The release notes are also
in a similar location in the

00:49:30.930 --> 00:49:33.910
release notes folder there for
Cocoa Foundation and for the app kit.

00:49:36.900 --> 00:49:38.970
If you have any questions
about this stuff,

00:49:39.090 --> 00:49:41.140
Cocoa feedback at group.apple.com.

00:49:41.140 --> 00:49:44.920
There's Matt Formica, who is the
Cocoa Development Tools Evangelist,

00:49:44.920 --> 00:49:48.190
and John Randolph,
everybody's favorite DTS engineer.
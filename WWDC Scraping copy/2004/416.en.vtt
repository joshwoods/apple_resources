WEBVTT

00:00:12.600 --> 00:00:14.060
Cool.

00:00:14.200 --> 00:00:15.110
Good afternoon, everyone.

00:00:15.260 --> 00:00:17.400
Welcome to session 416.

00:00:17.480 --> 00:00:23.310
This session will be all about using
and customizing Cocoa Bindings.

00:00:23.310 --> 00:00:23.310
My name...

00:00:23.630 --> 00:00:24.700
is Ron Lue-Saang.

00:00:24.710 --> 00:00:26.700
I'm a glue code architect at Apple.

00:00:26.740 --> 00:00:32.240
I work on the Cocoa Bindings technology,
which we introduced last year at WWDC,

00:00:32.240 --> 00:00:36.550
and then shipped in Panther as
the controller layer for Cocoa.

00:00:36.980 --> 00:00:39.120
This year,
I'd like to take the next hour or so

00:00:39.550 --> 00:00:44.580
and talk about four high-level topics,
starting off with a general overview

00:00:44.780 --> 00:00:49.020
of Cocoa Bindings as a technology,
and how it can speed up your

00:00:49.020 --> 00:00:53.150
application development and raise
the quality of your applications.

00:00:53.400 --> 00:00:55.980
And then I'll talk about some of
the new features that we've added to

00:00:56.030 --> 00:00:58.760
Cocoa Bindings since the last release.

00:00:58.870 --> 00:01:02.420
And then I'll finish off with some tips
and tricks for using Cocoa Bindings

00:01:02.480 --> 00:01:05.960
in your everyday development,
including a section I call "Roll

00:01:05.960 --> 00:01:09.960
Your Own Bindings," where we'll
talk about making your View and

00:01:09.960 --> 00:01:12.810
Model subclasses more bindings-friendly.

00:01:13.380 --> 00:01:17.210
So let's-- Bless you.

00:01:20.450 --> 00:01:25.360
So let's start off with the
overview of Cocoa Bindings.

00:01:25.390 --> 00:01:28.040
If I've told you once,
I've told you a thousand times,

00:01:28.040 --> 00:01:30.250
model view controller.

00:01:30.600 --> 00:01:33.560
So to understand Cocoa Bindings,
you have to be familiar

00:01:33.560 --> 00:01:34.770
with Model-View-Controller.

00:01:34.930 --> 00:01:35.860
I'll say it again.

00:01:36.070 --> 00:01:39.700
You separate your application into
three distinct layers-- the Model,

00:01:39.700 --> 00:01:42.140
View, and Controller layer.

00:01:43.050 --> 00:01:46.580
And the Controller Layer is the part that
keeps the whole application together,

00:01:46.630 --> 00:01:50.100
synchronizing the data from your
Model Layer with the display

00:01:50.100 --> 00:01:52.020
logic in your View Layer.

00:01:52.020 --> 00:01:54.730
And that's why it's called Glue Code.

00:01:55.300 --> 00:01:58.200
Any Cocoa developer will
look at this diagram and see,

00:01:58.240 --> 00:01:59.900
"Oh, View Layer Logic.

00:02:00.150 --> 00:02:05.650
AppKit helps me with that." And then you
can see that the Model Layer Logic is

00:02:06.110 --> 00:02:10.750
built with foundation code,
as well as now core data.

00:02:11.890 --> 00:02:15.860
Then the glue code is left up to you.

00:02:16.220 --> 00:02:17.330
You do that part.

00:02:17.580 --> 00:02:20.100
Well, you did until Cocoa Bindings.

00:02:20.250 --> 00:02:22.640
So now we have a reusable
controller layer so that you

00:02:22.640 --> 00:02:27.590
can toss out all that glue code,
writing much, much less code to get

00:02:27.670 --> 00:02:29.780
the same functionality.

00:02:32.400 --> 00:02:34.400
Yeah, that's right.

00:02:34.400 --> 00:02:37.170
Oh, yeah.

00:02:37.170 --> 00:02:45.900
So, to give you an idea of exactly
what the clicker does...

00:02:46.690 --> 00:02:47.930
There we go.

00:02:48.170 --> 00:02:53.320
So now Cocoa Bindings completes
the picture of MVC the Cocoa way.

00:02:53.390 --> 00:02:58.160
It provides a reusable set of
controller classes that abstracts the

00:02:58.160 --> 00:03:00.460
interaction with model layer objects.

00:03:00.600 --> 00:03:05.600
And also Cocoa Bindings brings
with it the notion of a binding,

00:03:05.900 --> 00:03:09.590
which simply says what attribute of
one object should be kept in sync

00:03:09.690 --> 00:03:12.600
with what property of another object.

00:03:12.720 --> 00:03:17.570
Simply a description of how to bind
the values between the two objects.

00:03:20.620 --> 00:03:25.610
So let me just go through the technology
base on which Cocoa Bindings is built.

00:03:25.630 --> 00:03:29.550
There are three distinct protocols
that are in Cocoa that are required for

00:03:29.550 --> 00:03:32.980
the Cocoa Bindings technology to work.

00:03:33.240 --> 00:03:35.280
The first,
most of you are probably familiar with:

00:03:35.390 --> 00:03:37.320
key-value coding.

00:03:37.690 --> 00:03:41.290
Then there's Key-Value Observing,
which we introduced last year,

00:03:41.410 --> 00:03:43.800
and Key-Value Binding.

00:03:44.160 --> 00:03:48.170
Key-value coding is an informal
protocol that lets you access members

00:03:48.180 --> 00:03:51.040
of an object by name indirectly.

00:03:51.080 --> 00:03:54.840
That way you don't directly
access it by instance variable or

00:03:55.160 --> 00:03:59.070
sending method messages directly.

00:03:59.830 --> 00:04:05.810
Key Value Observing lets you describe
how an object should be notified

00:04:05.810 --> 00:04:10.300
of changes from another object,
so that an interested party

00:04:10.400 --> 00:04:14.670
can be notified when something
changes in an observed object.

00:04:16.310 --> 00:04:21.000
Key-value binding provides a
mechanism for establishing a binding,

00:04:21.070 --> 00:04:24.670
for creating that binding,
that definition of what should be

00:04:24.680 --> 00:04:27.140
kept in sync with what other object.

00:04:29.100 --> 00:04:35.900
[Transcript missing]

00:04:36.750 --> 00:04:40.600
All of the values that are transferred
between the layers are sent via KVC.

00:04:40.710 --> 00:04:44.050
So, key value coding messages are
sent all the time to notify,

00:04:44.200 --> 00:04:47.100
to send values between the
model and the controller,

00:04:47.290 --> 00:04:49.390
the controller and the view.

00:04:50.710 --> 00:04:53.930
And then Key-Value Observing
is used for the view,

00:04:54.080 --> 00:04:58.820
for example, to register itself as an
observer for the controller.

00:04:58.950 --> 00:05:02.460
That way, any changes to the controller,
like for its selection,

00:05:02.580 --> 00:05:05.440
the name of its selection, can be sent.

00:05:05.630 --> 00:05:08.820
A notification for that change
can be sent to the view.

00:05:09.010 --> 00:05:11.600
This is how it knows
that something's changed.

00:05:11.670 --> 00:05:14.820
Well, specifically, this is how it knows
that something's changed.

00:05:14.900 --> 00:05:19.780
The view implements a method also
defined via Key-Value Observing.

00:05:20.100 --> 00:05:22.840
The Observed Value for Keypath Method.

00:05:22.840 --> 00:05:24.920
This method is invoked
on the View object,

00:05:24.920 --> 00:05:29.000
on the observer,
whenever something in the controller,

00:05:29.210 --> 00:05:31.590
the observed object, changes.

00:05:34.300 --> 00:05:38.300
Key-value binding lets you
bind a view or multiple views

00:05:38.300 --> 00:05:40.120
to the same controller object.

00:05:40.200 --> 00:05:43.680
This is how the view knows
that it should add itself as

00:05:43.690 --> 00:05:45.590
an observer of the controller.

00:05:46.510 --> 00:05:50.320
So during a typical edit cycle,
when the user is actually

00:05:50.320 --> 00:05:54.020
interacting with the view,
something changes in the view,

00:05:54.080 --> 00:05:58.160
and it will propagate the
new value to the controller.

00:05:58.240 --> 00:06:00.860
The controller can then,
on behalf of the view,

00:06:00.930 --> 00:06:03.500
send that new value
onto the model object,

00:06:03.560 --> 00:06:06.920
thus keeping the view
and the model in sync.

00:06:08.040 --> 00:06:10.880
Furthermore,
once something does change in the model,

00:06:11.130 --> 00:06:14.230
the model can tell the controller
via key-value observing

00:06:14.580 --> 00:06:16.240
that something has changed.

00:06:16.390 --> 00:06:21.560
And again,
the controller can notify any other views

00:06:21.590 --> 00:06:24.860
that are registered with the controller.

00:06:24.950 --> 00:06:29.540
This way, not only do the views stay in
sync with the model objects,

00:06:29.540 --> 00:06:34.520
but views in the same view hierarchy
can stay in sync with each other.

00:06:35.430 --> 00:06:39.530
And all of this is done with
the magic of Interface Builder.

00:06:39.530 --> 00:06:42.460
So you can actually configure
these bindings in IB.

00:06:42.710 --> 00:06:46.440
It's not a code-- you can still
configure bindings by code,

00:06:46.470 --> 00:06:49.260
but you've got IB.

00:06:49.420 --> 00:06:56.700
So I think next is a short demo
of how exactly this looks in IB.

00:06:56.990 --> 00:07:00.890
We'll go to demo two, I believe.

00:07:11.800 --> 00:07:16.460
So we have -- I have a simple nib.

00:07:16.460 --> 00:07:19.210
It's even called simple.

00:07:19.210 --> 00:07:21.800
An interface builder.

00:07:21.800 --> 00:07:23.080
Oh.

00:07:23.190 --> 00:07:31.630
Could I get the other other screen,
please?

00:07:37.750 --> 00:07:39.380
One more.

00:07:39.450 --> 00:07:42.600
There we go.

00:07:42.600 --> 00:07:44.580
Thank you.

00:07:44.580 --> 00:07:48.600
Let's unclutter a bit.

00:07:49.970 --> 00:07:55.420
Here I have a simple window and
another simple panel hooked up

00:07:55.500 --> 00:07:57.840
to a simple array controller.

00:07:57.880 --> 00:08:01.760
Here you can see I've defined that
the NSArrayController uses a mutable

00:08:01.760 --> 00:08:09.670
dictionary for its model objects,
and that my table is bound to

00:08:10.270 --> 00:08:11.900
My array controller.

00:08:12.040 --> 00:08:16.010
And it's displaying the name of all
the objects in the array controller.

00:08:16.010 --> 00:08:21.090
And also the preferred food of all the
people displayed in the array controller.

00:08:21.170 --> 00:08:23.480
I'll just show you how this all runs.

00:08:23.480 --> 00:08:27.440
Just do test interface.

00:08:29.860 --> 00:08:33.400
You can add a couple of items here.

00:08:33.400 --> 00:08:37.390
Let's go with... I like pizza.

00:08:37.450 --> 00:08:42.910
Let's say Andreas, who likes chocolate,
I know.

00:08:44.630 --> 00:08:46.540
Bill, I think, is a sushi guy.

00:08:46.820 --> 00:08:48.460
So we can edit all of these values.

00:08:48.460 --> 00:08:51.200
And you'll see here that these
text fields up at the top are

00:08:51.200 --> 00:08:56.200
kept in sync with the number of
objects that are in the table,

00:08:56.280 --> 00:08:57.370
that are in the array.

00:08:57.500 --> 00:09:00.210
You can remove and add and
remove and add and remove.

00:09:00.450 --> 00:09:04.290
And we also have multiple selection,
so we can count how many

00:09:04.380 --> 00:09:05.960
things are selected.

00:09:06.050 --> 00:09:09.890
You can even edit other values,
like the favorite language

00:09:10.190 --> 00:09:12.270
of each of these people.

00:09:12.610 --> 00:09:16.230
I'm pretty sure Andres likes German.

00:09:16.330 --> 00:09:18.490
I think Bill likes foul language.

00:09:18.490 --> 00:09:19.500
I can't remember.

00:09:19.500 --> 00:09:23.160
So, and, you know,
I can change the attributes

00:09:23.160 --> 00:09:26.500
of the text field here,
the display attributes.

00:09:26.510 --> 00:09:32.620
So the text font size on a little -- this
is supposed to be a preferences panel,

00:09:32.640 --> 00:09:33.500
but, yeah.

00:09:33.500 --> 00:09:38.800
And even the text color -- oops.

00:09:40.200 --> 00:09:45.120
So, oh, there seems to be a break
in the binding here.

00:09:45.140 --> 00:09:48.700
Let's go update that.

00:09:48.710 --> 00:09:53.430
So here you can see I have
my text color binding bound

00:09:53.450 --> 00:09:57.210
to the shared user defaults.

00:09:57.580 --> 00:10:04.580
And here in the color well-- oh,
it wasn't highlighted.

00:10:08.500 --> 00:10:09.960
Well, you get the idea.

00:10:09.990 --> 00:10:12.700
The text color really
does normally change.

00:10:12.800 --> 00:10:15.550
So we can do all of this stuff
without writing any code,

00:10:15.670 --> 00:10:16.300
all in IB.

00:10:16.300 --> 00:10:20.510
We get a lot further developing
our application just finishing the

00:10:20.510 --> 00:10:23.240
interface in Interface Builder.

00:10:23.340 --> 00:10:25.860
So this is what
Cocoa Bindings will give you.

00:10:25.860 --> 00:10:27.980
If we can go back to the slides.

00:10:38.370 --> 00:10:38.680
Tiger.

00:10:38.800 --> 00:10:44.260
OK, so that ends the demo.

00:10:44.260 --> 00:10:46.800
That's, also,
the end of the overview section.

00:10:46.840 --> 00:10:49.870
How many of you guys have actually
played with Cocoa Bindings already,

00:10:49.910 --> 00:10:50.720
by the way?

00:10:50.750 --> 00:10:51.850
Oh, yeah.

00:10:52.090 --> 00:10:56.600
How many of you have, like,
never heard of Cocoa Bindings before?

00:10:56.620 --> 00:10:57.100
Raise your hands.

00:10:57.100 --> 00:10:58.380
It's OK.

00:10:58.380 --> 00:10:59.760
All right, OK.

00:10:59.810 --> 00:11:05.160
So then the overview isn't
completely without merit.

00:11:05.180 --> 00:11:07.260
So that's the end of the overview.

00:11:07.270 --> 00:11:11.690
Now we go into new features,
things that we've added to

00:11:11.710 --> 00:11:13.880
Cocoa Bindings for Tiger.

00:11:14.410 --> 00:11:16.880
The first two features that
I'll go over are the result

00:11:16.970 --> 00:11:19.550
of a lot of feature requests.

00:11:19.780 --> 00:11:23.480
The first will be a tree controller,
so that now you have something to bind

00:11:23.480 --> 00:11:26.330
to from the outline view in the browser.

00:11:31.000 --> 00:11:39.120
: And we also have filtering
built into the NSA controller,

00:11:39.120 --> 00:11:39.120
so you don't have to subclass anymore.

00:11:40.360 --> 00:11:42.690
Glad you like it.

00:11:43.090 --> 00:11:44.800
I'll show you a little bit
more about each of these.

00:11:45.040 --> 00:11:47.400
First, with the Tree Controller.

00:11:48.710 --> 00:11:50.840
With the Tree Controller,
we wanted to make it as easy as

00:11:50.960 --> 00:11:52.600
possible to get used to using it.

00:11:52.690 --> 00:11:56.600
So, it kind of feels a little bit
like using the Array Controller.

00:11:56.680 --> 00:11:59.690
Except, of course,
Array Controllers manage arrays,

00:11:59.690 --> 00:12:02.600
but the Tree Controller manages
a tree of objects.

00:12:03.590 --> 00:12:07.100
But that tree isn't
specifically any NS tree class,

00:12:07.500 --> 00:12:10.090
or you don't have to import your
data into any specific class,

00:12:10.140 --> 00:12:12.380
or re-architect all of your objects.

00:12:12.460 --> 00:12:15.420
We just expect that you have what
is probably natural for all of

00:12:15.420 --> 00:12:16.890
your data as far as tree goes.

00:12:17.250 --> 00:12:21.800
That you have arrays of objects
that have arrays as children

00:12:21.800 --> 00:12:24.170
objects of arrays of arrays.

00:12:24.260 --> 00:12:28.040
So this graph up here pretty
much sums up what the tree

00:12:28.120 --> 00:12:31.010
controller expects of your data.

00:12:31.600 --> 00:12:35.160
If you can describe your data this way,
then you can use your tree

00:12:35.160 --> 00:12:36.960
with the Tree Controller.

00:12:36.960 --> 00:12:41.820
All you have to do is
just describe your tree.

00:12:41.830 --> 00:12:45.380
And the main thing for that
description is the children key.

00:12:45.690 --> 00:12:50.710
If you set the Children key
of the Tree Controller,

00:12:50.910 --> 00:12:55.700
That's the key the Tree Controller will
use to traverse all of

00:12:55.780 --> 00:12:58.090
the nodes of your tree.

00:12:58.350 --> 00:13:02.460
So this has the caveat that all
of the objects in your tree have

00:13:02.550 --> 00:13:07.730
to respond to this children key,
"key." This can usually be done

00:13:07.730 --> 00:13:13.080
by subclassing or by adding a
category or changing the source.

00:13:13.160 --> 00:13:16.660
There are also some optional
keys that you can set,

00:13:16.720 --> 00:13:21.630
the leaf key and the count key,
which offer some optimizations for

00:13:21.750 --> 00:13:25.590
whether or not the tree controller
should traverse children there.

00:13:26.320 --> 00:13:29.860
And then of course there are some actions
that we expose for the Tree Controller.

00:13:30.020 --> 00:13:33.930
So you can bind buttons to it for
adding siblings to the selection,

00:13:33.930 --> 00:13:36.800
as well as adding child
objects to the selection,

00:13:37.010 --> 00:13:41.040
and removing any of the selected
objects from the Tree Controller.

00:13:41.680 --> 00:13:47.080
And then, after you've set all the keys
and set up your Tree Controller,

00:13:47.150 --> 00:13:50.520
you need to tell it where
the root of the tree is.

00:13:50.590 --> 00:13:53.770
You do this with either
a content object binding,

00:13:53.770 --> 00:13:57.960
or by explicitly setting the content
object the same way as an outlet,

00:13:58.130 --> 00:13:59.800
just using an outlet.

00:14:00.000 --> 00:14:02.950
From there,
the Tree Controller will start

00:14:02.960 --> 00:14:05.060
managing the tree of objects.

00:14:05.350 --> 00:14:07.540
There are also some extra
keys that we've added.

00:14:07.620 --> 00:14:10.160
They look a lot like the
Array Controller keys,

00:14:10.510 --> 00:14:16.190
starting off with the Arranged Objects,
which returns the root of the

00:14:16.840 --> 00:14:21.420
tree after any sorting has
happened to the child objects.

00:14:21.490 --> 00:14:24.100
Then there's also the Selection
that knows how to manage

00:14:24.170 --> 00:14:27.990
intelligently multiple selection,
no selection, not applicable,

00:14:28.090 --> 00:14:31.580
returning the appropriate
key value binding markers.

00:14:32.010 --> 00:14:36.880
And we've added a couple of keys just
for convenience in Interface Builder:

00:14:37.040 --> 00:14:39.660
canInsertChild and canAddChild.

00:14:39.740 --> 00:14:43.980
We also have canInsert and
canAdd in just plain form,

00:14:43.990 --> 00:14:48.150
so that now you can bind the enabled
value of one of your buttons,

00:14:48.280 --> 00:14:51.670
so that if the tree controller
doesn't support adding a child,

00:14:51.930 --> 00:14:55.600
then the button can stay disabled.

00:14:55.740 --> 00:14:59.740
And we've also added selection
index paths as a controller key,

00:14:59.860 --> 00:15:02.340
which isn't the same
as selection indexes.

00:15:02.450 --> 00:15:07.470
That's because we needed something
different to identify nodes in the tree.

00:15:07.610 --> 00:15:11.400
You can think of the NSIndexPath,
which we've added to Foundation,

00:15:11.550 --> 00:15:14.770
as the identifier for nodes in the tree.

00:15:14.980 --> 00:15:20.830
It's similar to thinking about how you
access elements of an array by index,

00:15:20.840 --> 00:15:25.590
except now we have a path of indexes
that represents all the children of each

00:15:25.630 --> 00:15:27.300
node that you traverse through the tree.

00:15:27.430 --> 00:15:33.500
So here,
249 would indicate the child at index 9,

00:15:33.500 --> 00:15:36.740
of the child at index 4,
of the child at index 2

00:15:36.740 --> 00:15:38.850
of the root of your tree.

00:15:38.970 --> 00:15:44.400
It's a condensed way of
representing each node in your tree.

00:15:46.290 --> 00:15:49.880
So now that you have the Tree Controller,
you can bind the NSOutlineView to

00:15:49.900 --> 00:15:54.260
the Tree Controller and the
NSOutlineView's table columns.

00:15:54.330 --> 00:15:56.270
And that looks, again,
exactly like binding a

00:15:56.270 --> 00:15:59.680
regular TableView table column
to the Array Controller.

00:15:59.870 --> 00:16:04.380
You just bind the values or
texts or font size or anything.

00:16:04.660 --> 00:16:09.350
And then you bind the content
and selection index paths of the

00:16:09.350 --> 00:16:12.540
OutlineView to the Tree Controller.

00:16:12.870 --> 00:16:15.880
The content binding gives the
OutlineView all of the objects,

00:16:16.080 --> 00:16:19.360
basically the root object, to display.

00:16:19.430 --> 00:16:24.210
And then the selection index paths is
how the OutlineView keeps its selection

00:16:24.220 --> 00:16:26.960
in sync with the Tree Controller.

00:16:29.470 --> 00:16:32.090
And as I said,
we also have support for NSBrowser,

00:16:32.090 --> 00:16:36.900
which has pretty much the same bindings,
content and selection index paths,

00:16:36.960 --> 00:16:40.580
and then also a content values
binding that you want to bind so

00:16:40.580 --> 00:16:45.340
that it'll actually get the value
to display in the browser cell,

00:16:45.340 --> 00:16:49.640
rather than just displaying
the description of the content,

00:16:49.640 --> 00:16:51.990
of any of the content objects.

00:16:54.050 --> 00:16:57.110
After that, oh, one thing.

00:16:57.430 --> 00:16:59.180
If you go home and
play with this tonight,

00:16:59.180 --> 00:17:01.630
try and hook up the outline
view to the tree controller,

00:17:01.640 --> 00:17:04.680
and you go and start adding things,
adding nodes to your tree,

00:17:04.750 --> 00:17:06.340
and start editing it.

00:17:06.390 --> 00:17:09.240
Editing isn't supported yet, sorry.

00:17:09.240 --> 00:17:10.700
That's coming.

00:17:10.700 --> 00:17:14.950
But you can still browse
through the outline view and

00:17:15.010 --> 00:17:17.620
adjust the layout of the tree.

00:17:17.620 --> 00:17:19.390
That's still supported.

00:17:20.280 --> 00:17:25.380
And the next major feature is
filtering in the NSRA Controller.

00:17:27.050 --> 00:17:29.660
We've added filtering directly
to the NSArrayController,

00:17:29.660 --> 00:17:32.900
so you don't have to subclass
anymore to get filtering support.

00:17:32.960 --> 00:17:36.230
But in the process of adding filtering
support to the array controller,

00:17:36.230 --> 00:17:39.080
we figured we'd add
filtering support to NSArray.

00:17:39.410 --> 00:17:43.020
And we've also improved the
synergy of using the array

00:17:43.020 --> 00:17:45.490
controller with the search field.

00:17:45.850 --> 00:17:49.580
And all of that comes to us
thanks to the NS predicate.

00:17:49.620 --> 00:17:54.460
If you caught the core data talk
earlier-- did anybody catch that talk?

00:17:54.480 --> 00:17:56.550
Yeah, good, good.

00:17:56.710 --> 00:18:01.820
With Core Data, we get a new class,
the NSPredicate.

00:18:02.500 --> 00:18:05.930
Basically,
it's a class that describes a condition.

00:18:06.040 --> 00:18:08.950
And here, the string representation
of one of these predicates,

00:18:08.950 --> 00:18:12.100
of a simple predicate,
it looks a lot like the condition

00:18:12.100 --> 00:18:14.060
statement of a C-based language.

00:18:14.270 --> 00:18:15.510
So it's pretty easy to use.

00:18:15.520 --> 00:18:16.860
It's really easy to work with.

00:18:17.110 --> 00:18:20.290
And once you have a predicate,
you can filter an array,

00:18:20.500 --> 00:18:23.840
get a filtered array from an
unfiltered one using this method,

00:18:24.020 --> 00:18:27.730
filterArrayUsingPredicate,
or filterMutableArrayInPlace

00:18:27.730 --> 00:18:30.620
using filterUsingPredicate.

00:18:30.980 --> 00:18:33.080
And of course,
you can filter an NSArrayController

00:18:33.480 --> 00:18:36.100
using setFilterPredicate.

00:18:36.150 --> 00:18:39.400
Once you have an array controller
and you set its filter predicate,

00:18:39.530 --> 00:18:42.990
all of the arranged objects,
the objects returned from the arranged

00:18:43.030 --> 00:18:48.720
objects accessor of the array controller,
are the ones that match the condition

00:18:48.840 --> 00:18:51.050
defined in the filter predicate.

00:18:51.800 --> 00:18:55.040
There's also a controller
key for the filter predicate,

00:18:55.040 --> 00:18:58.740
so you can bind objects that
provide predicates to the

00:18:58.820 --> 00:19:00.910
ray controller directly.

00:19:01.980 --> 00:19:05.710
And because of the way
the filtering works,

00:19:05.740 --> 00:19:08.590
there might be strange user interaction.

00:19:08.590 --> 00:19:13.850
If, for example, someone has filtered out
objects in a table view,

00:19:13.850 --> 00:19:16.240
and they go and add a new
object into the array controller

00:19:16.350 --> 00:19:20.000
pressing the little Add button,
and then it adds it,

00:19:20.000 --> 00:19:23.080
but immediately filters it out.

00:19:23.580 --> 00:19:27.740
That can be confusing to some users,
and so we've added a new

00:19:27.740 --> 00:19:33.220
option to the array controller:
clears filter predicate on insertion.

00:19:36.910 --> 00:19:40.860
With this option turned on,
which is by default,

00:19:40.900 --> 00:19:44.030
the array controller will
clear out the filter predicate,

00:19:44.120 --> 00:19:47.900
setting it to nil,
and then insert the new object.

00:19:47.910 --> 00:19:54.240
This should prevent a lot of confusion
when inserting new objects by users.

00:19:54.970 --> 00:19:58.740
And just to clarify,
remember that the arranged objects

00:19:58.870 --> 00:20:04.200
of the array controller is simply
a filtered representation of the

00:20:04.200 --> 00:20:05.920
content of the array controller.

00:20:06.060 --> 00:20:10.510
So don't worry about it deleting the
objects from your underlying array.

00:20:13.430 --> 00:20:14.800
Search fields.

00:20:14.820 --> 00:20:19.260
So when we released
Cocoa Bindings in Panther,

00:20:19.280 --> 00:20:23.890
we had search field support in the
form of a recent searches binding.

00:20:24.210 --> 00:20:29.120
This gave you the ability to build
search field menus much like the

00:20:29.120 --> 00:20:31.580
one that you'll find in Safari.

00:20:31.930 --> 00:20:33.950
With Tiger,
we've added support for building

00:20:34.260 --> 00:20:36.990
search fields that look a
lot like the one in Mail,

00:20:37.110 --> 00:20:39.910
so that you can select
what you want to filter on,

00:20:39.910 --> 00:20:42.600
and then the user can type
in the search criteria,

00:20:42.730 --> 00:20:48.470
and the filtering happens based on
whether it's from or to or subject.

00:20:48.940 --> 00:20:50.260
And it's pretty simple.

00:20:50.280 --> 00:20:55.830
You simply bind the filter predicate,
bind the predicate from the

00:20:55.990 --> 00:21:00.000
search field to the filter
predicate of the array controller.

00:21:00.040 --> 00:21:03.100
And for every binding you
make from the search field,

00:21:03.130 --> 00:21:07.260
you get another menu in
the resulting search field.

00:21:08.160 --> 00:21:09.820
And again,
for every binding that you make,

00:21:10.000 --> 00:21:13.780
for every menu item,
you have two options that you can set.

00:21:13.840 --> 00:21:18.190
The NSDisplayName binding option
lets you set the name of the menu

00:21:18.480 --> 00:21:20.620
that'll show up in the search field.

00:21:20.690 --> 00:21:23.580
So this way it's easy
to localize your nibs.

00:21:23.650 --> 00:21:29.260
And then NSPredicateFormat binding
option gives you the ability to set the

00:21:29.260 --> 00:21:32.860
predicate format for that menu item.

00:21:33.020 --> 00:21:38.580
So defining that the From menu
item should search on the

00:21:38.580 --> 00:21:42.330
From category of your model objects.

00:21:44.690 --> 00:21:46.950
We've also added some
integration with Core Data,

00:21:47.040 --> 00:21:50.100
speaking of NS predicates.

00:21:50.250 --> 00:21:54.400
What we've done is added support for
Core Data-like functionality directly

00:21:54.400 --> 00:21:57.710
to the NS Object and NSArray Controller.

00:21:57.990 --> 00:22:01.180
in the form of...well,
actually I'm getting ahead of myself.

00:22:01.240 --> 00:22:04.490
I should talk to you
about Core Data first.

00:22:05.100 --> 00:22:10.400
The idea behind Core Data is that you
define a description of your data,

00:22:10.600 --> 00:22:13.140
all of the model objects
of your application.

00:22:13.220 --> 00:22:17.180
Rather than writing all of the classes,
you define an entity.

00:22:17.370 --> 00:22:20.750
So the entity has all the
information that describes the

00:22:20.750 --> 00:22:23.300
model objects of your application.

00:22:23.460 --> 00:22:26.670
With that description,
you can use an NSManagedObject

00:22:26.810 --> 00:22:30.030
context to manage managed objects.

00:22:30.250 --> 00:22:32.890
There's a lot of management going on.

00:22:32.990 --> 00:22:39.520
With the managed object context, though,
it'll manage all of your

00:22:39.710 --> 00:22:43.600
I guess that's really
the only way to say it.

00:22:43.740 --> 00:22:47.210
It'll try and keep a minimal
set of objects that you're

00:22:47.210 --> 00:22:48.600
working with in memory.

00:22:48.700 --> 00:22:52.080
So this is a good way to do, like,
as-needed faulting of your

00:22:52.080 --> 00:22:55.580
objects into memory space without
you having to do much work.

00:22:55.580 --> 00:23:03.590
And it also manages storage
and retrieval of your data,

00:23:03.590 --> 00:23:03.590
so it can handle saves and opens for you.

00:23:04.220 --> 00:23:06.080
I think anyone who went to
the Core Data Talk knows

00:23:06.080 --> 00:23:07.290
what I'm talking about.

00:23:07.500 --> 00:23:11.440
So you don't have to write any of that
extra code in your NSDocuments subclass

00:23:11.520 --> 00:23:17.060
for saving and opening documents.

00:23:17.610 --> 00:23:20.880
And the way the managed object
context gets these objects,

00:23:20.880 --> 00:23:24.510
and how you specify which
objects it should manage,

00:23:24.510 --> 00:23:27.220
is by using a predicate.

00:23:27.500 --> 00:23:31.120
The predicate simply defines
for the managed object context

00:23:31.620 --> 00:23:33.070
which objects to fetch.

00:23:35.790 --> 00:23:38.970
With these three items,
you can pretty much manage all of your

00:23:39.180 --> 00:23:43.920
model objects just through Core Data with
a minimal amount of code work.

00:23:44.390 --> 00:23:47.150
And what we've done with the controllers

00:23:49.060 --> 00:23:55.350
is at the ability to define which
entity the controller uses to which

00:23:55.350 --> 00:23:58.270
entity the controller manages really.

00:24:01.520 --> 00:24:03.700
This is opposed to
what is normally there,

00:24:03.700 --> 00:24:07.410
which is defining the object class.

00:24:08.150 --> 00:24:11.810
Now that you can define the entity,
you can also define a fetch predicate,

00:24:11.820 --> 00:24:14.480
which is, in this case,
different from the filter

00:24:14.480 --> 00:24:16.040
predicate of the array controller.

00:24:16.100 --> 00:24:21.470
This is simply the predicate that the
controller should use to fetch objects.

00:24:21.920 --> 00:24:26.050
And there's also a way of setting
the managed object context that

00:24:26.150 --> 00:24:28.500
the controllers will fetch into.

00:24:28.610 --> 00:24:33.890
You can do this either via
binding or by an outlet in IB.

00:24:34.410 --> 00:24:37.800
So with these three items,
with these three pieces of information,

00:24:37.940 --> 00:24:41.370
the controllers can actually
fetch for you through core data,

00:24:41.390 --> 00:24:43.880
just by knowing the entity,
what fetch predicate

00:24:43.880 --> 00:24:47.270
to apply for the fetch,
and which managed object

00:24:47.360 --> 00:24:49.330
context to fetch into.

00:24:49.760 --> 00:24:54.640
You can even set the controllers to fetch
automatically for you on nib instantiate,

00:24:54.640 --> 00:24:57.720
or you can wire up an action from a
button so that users can click the

00:24:57.880 --> 00:25:00.510
little fetch button as much as they like.

00:25:01.020 --> 00:25:08.700
And something to note,
when you're executing a fetch from the

00:25:10.720 --> 00:25:13.540
Is that clock right?

00:25:13.540 --> 00:25:16.330
When you're executing a fetch from the--

00:25:16.340 --> 00:25:20.580
From the controller-- oh,
into the object context, sorry.

00:25:20.610 --> 00:25:23.780
So when you're fetching,
normally it's possible to define

00:25:23.780 --> 00:25:27.270
not only a fetch predicate,
but also a sort ordering.

00:25:27.400 --> 00:25:30.680
But once you have an array controller,
it's really better to sort in the UI.

00:25:30.800 --> 00:25:33.120
That's always going to be more correct.

00:25:33.140 --> 00:25:36.180
Another thing is we've added
a content set binding to the

00:25:36.180 --> 00:25:40.980
array controller so that you can
bind a detail array controller,

00:25:40.980 --> 00:25:46.050
like an array controller that manages
the relationship from a managed object.

00:25:46.260 --> 00:25:52.120
Because managed objects in core data
have relationships that are held in sets,

00:25:52.180 --> 00:25:56.830
the array controller can't directly
handle the relationship objects.

00:25:56.840 --> 00:25:59.510
So we've added the content set binding.

00:26:01.300 --> 00:26:03.790
And another cool side effect
of key-value observing,

00:26:03.800 --> 00:26:06.870
of building on those
three KV-BLA technologies,

00:26:06.910 --> 00:26:10.480
KV-STAR technologies,
with key-value observing,

00:26:10.560 --> 00:26:14.490
the controllers are always in sync with
what's in the managed object context.

00:26:14.580 --> 00:26:18.140
So you get all of that magic for free,
where if something is

00:26:18.140 --> 00:26:21.110
inserted into the context,
it's automatically

00:26:21.110 --> 00:26:22.800
propagated up to the UI.

00:26:24.500 --> 00:26:35.000
[Transcript missing]

00:26:37.700 --> 00:26:40.790
For this, I'd like demo two again.

00:26:40.850 --> 00:26:42.900
Sorry.

00:26:43.030 --> 00:26:44.510
False signals.

00:26:49.090 --> 00:26:53.410
Okay,
so we'll toss out this simple example.

00:26:53.420 --> 00:26:55.390
We'll go to Xcode.

00:26:55.840 --> 00:26:58.900
First, I'll demo the Tree Controller.

00:26:58.910 --> 00:27:01.540
I have a simple app that I ripped
off from one of my-- or borrowed

00:27:01.670 --> 00:27:04.380
from one of my coworkers.

00:27:04.440 --> 00:27:10.040
And it's a file system browser.

00:27:10.080 --> 00:27:15.960
Oh, I should show you that I don't
actually have much code in here.

00:27:16.180 --> 00:27:20.210
I have a couple of classes that
actually represent the nodes in

00:27:22.730 --> 00:27:24.980
The nodes of the file system.

00:27:25.030 --> 00:27:27.330
So these actually go out and
get the information of the

00:27:27.440 --> 00:27:31.350
files in the file system,
and return it as a path component.

00:27:31.470 --> 00:27:36.100
And my main controller
really has not much in it.

00:27:38.400 --> 00:27:51.600
[Transcript missing]

00:27:53.170 --> 00:27:55.880
So this is just a model
object sort of thing.

00:27:55.900 --> 00:27:57.820
I'll turn off Zoom for a sec.

00:27:57.880 --> 00:28:00.450
And go back to the app.

00:28:01.300 --> 00:28:06.420
So this is just an outline view bound
in the top to a tree controller,

00:28:06.490 --> 00:28:10.220
and a browser bound to the same
tree controller in the bottom,

00:28:10.260 --> 00:28:15.050
as well as a text field
that displays the selection.

00:28:15.460 --> 00:28:20.900
So I can traverse through
developer documentation.

00:28:20.910 --> 00:28:24.680
And you can see that the outline
view selection is being kept in

00:28:25.170 --> 00:28:28.000
sync with the browser selection.

00:28:29.900 --> 00:28:36.200
[Transcript missing]

00:28:37.180 --> 00:28:41.250
For the filtering demo,
I was going to run one application,

00:28:41.250 --> 00:28:43.340
but something's happened to it.

00:28:43.670 --> 00:28:45.530
So I'll skip that demo.

00:28:45.730 --> 00:28:49.530
I'll try and do something a
little later if I have time.

00:28:49.640 --> 00:28:52.010
So I'll just go back to the slides now.

00:28:59.780 --> 00:29:03.460
So, other new features.

00:29:03.460 --> 00:29:11.940
We've done a couple of other things
beyond just the core NSController work.

00:29:11.940 --> 00:29:16.420
We've also added a binding debug
mode to help you guys debug the

00:29:16.420 --> 00:29:19.530
binding problems you might run into.

00:29:21.780 --> 00:29:23.850
It's a pretty simple switch.

00:29:24.080 --> 00:29:27.320
There's a defaults write,
NSBindingDebugLogLevel.

00:29:27.510 --> 00:29:29.390
Set that to 1.

00:29:29.390 --> 00:29:34.940
And any errors that the bindings
encounter accessing or setting values or

00:29:34.940 --> 00:29:40.590
invoking methods will get logged for you,
defining what was bound

00:29:40.690 --> 00:29:42.070
and what the error was.

00:29:42.400 --> 00:29:46.910
So you can track down if there were
any configuration errors in your nib.

00:29:48.530 --> 00:29:50.680
Another thing we've added
is info for binding.

00:29:50.830 --> 00:29:56.390
This way you can get more information
about a binding for any bound object.

00:29:57.000 --> 00:30:00.200
So if you have a bound view,
a text field or something,

00:30:00.200 --> 00:30:05.590
and you invoke info for binding,
you'll get a dictionary back of

00:30:05.590 --> 00:30:09.990
information relating to a specific
binding for that text field.

00:30:10.310 --> 00:30:13.420
The dictionary has information
like the object that it's bound to,

00:30:13.560 --> 00:30:17.340
which is usually its NSController,
as well as the observed keypath,

00:30:17.470 --> 00:30:22.140
so the keypath that the
view was bound with.

00:30:22.240 --> 00:30:26.110
And also the options key gives
you back a dictionary of options

00:30:26.110 --> 00:30:28.180
that the view was bound with.

00:30:31.780 --> 00:30:34.450
More new things on the
NSArray Controller.

00:30:34.450 --> 00:30:40.270
If you've ever worked with the
Multiple Values Selection Marker,

00:30:41.550 --> 00:30:47.620
It's a cool thing if you select
multiple objects in an array controller,

00:30:47.620 --> 00:30:51.550
for example,
and they all have the same name,

00:30:51.740 --> 00:30:56.000
and you want to display the name of
the selection in the array controller.

00:30:56.390 --> 00:31:00.590
The selection proxy,
the object you get from asking the

00:31:01.030 --> 00:31:06.860
array controller for its selection,
can actually return either the multiple

00:31:06.860 --> 00:31:12.640
selections marker or the common name
for all the objects in the selection.

00:31:12.780 --> 00:31:15.200
The way it does this is it runs
through all of the selected objects

00:31:15.200 --> 00:31:18.300
and compares whatever you're going
to display for those objects.

00:31:18.300 --> 00:31:22.130
So if they all have the same name,
then we'll display the name.

00:31:22.530 --> 00:31:27.300
Otherwise, we display the multiple
selection marker placeholder.

00:31:27.440 --> 00:31:30.300
This might be a little bit
more information than you need.

00:31:30.300 --> 00:31:34.120
But the point is,
now there's a new option to turn off

00:31:34.120 --> 00:31:37.300
that behavior so that any time that
there's more than one item selected,

00:31:37.300 --> 00:31:41.470
we'll always return the
multiple selection placeholder,

00:31:41.610 --> 00:31:43.300
the selection marker.

00:31:43.360 --> 00:31:47.180
So this can be a big optimization
for selections that are very large

00:31:47.560 --> 00:31:51.300
where all the names might be similar,
or all the values might be similar.

00:31:53.310 --> 00:31:57.710
And we have other random options
and bindings that we've added.

00:31:57.860 --> 00:32:00.760
NSView now has a tooltip binding.

00:32:00.940 --> 00:32:04.380
NSTextView has an
attributed string binding,

00:32:04.400 --> 00:32:08.580
so now you don't have to
convert from RTF data,

00:32:08.590 --> 00:32:11.860
blah, to get attributed strings
into your text fields,

00:32:11.860 --> 00:32:13.120
your text views.

00:32:13.250 --> 00:32:16.490
NSWindow now has a display
pattern title binding,

00:32:16.590 --> 00:32:21.960
so you can customize the display of
the window based on multiple pieces

00:32:21.960 --> 00:32:24.490
of input from the controllers.

00:32:25.190 --> 00:32:28.700
The table column now has a new
option for turning off automatic

00:32:28.760 --> 00:32:31.400
creation of the sort descriptors.

00:32:31.400 --> 00:32:33.870
We automatically create sort
descriptors for all of the

00:32:33.870 --> 00:32:35.300
table columns in your table.

00:32:35.300 --> 00:32:37.370
That way you get sorting for free.

00:32:37.540 --> 00:32:40.400
Some people don't like that.

00:32:40.400 --> 00:32:41.480
So now you can turn that off.

00:32:42.780 --> 00:32:45.360
And as I said,
we have a new binding for the

00:32:45.360 --> 00:32:51.780
ArrayController content set for working
with the managed objects relationships.

00:32:53.680 --> 00:32:58.510
We've also added some changes to the
way NSPopupButton and NSMatrix work.

00:32:58.580 --> 00:33:02.400
Specifically, we've added ContentObjects
as a new binding.

00:33:02.520 --> 00:33:06.390
With ContentObjects, you can imagine

00:33:07.170 --> 00:33:15.350
If you bind the pop-up button to
an array of objects as its content,

00:33:15.350 --> 00:33:20.690
and you want to synchronize the
selected objects of the pop-up button,

00:33:20.890 --> 00:33:23.510
Normally,
you would get back in that selected

00:33:23.510 --> 00:33:29.180
objects array all of the objects that
are selected from the content array.

00:33:29.810 --> 00:33:34.340
But you might actually be more
interested in objects related to

00:33:35.160 --> 00:33:37.000
the objects in the content array.

00:33:37.110 --> 00:33:41.580
So now with content objects,
you can define, for example,

00:33:41.580 --> 00:33:45.380
the name of all the people in--
the name of the people that

00:33:45.410 --> 00:33:50.010
you're displaying at the pop-up
will become the selected objects.

00:33:50.140 --> 00:33:55.900
So you can target a different
object in your pop-up.

00:33:55.900 --> 00:33:58.780
It's really simpler to
use than to explain.

00:33:58.980 --> 00:34:00.550
Sorry.

00:34:02.080 --> 00:34:08.580
NSMatrix has two modes that we support.

00:34:08.590 --> 00:34:08.590
Three modes, really.

00:34:09.340 --> 00:34:12.960
In radio mode, the default,
we support single selection.

00:34:13.040 --> 00:34:16.540
So there are two bindings,
the selected value and

00:34:16.540 --> 00:34:18.540
the selected object.

00:34:19.020 --> 00:34:21.620
When the matrix is in
list or highlight mode,

00:34:21.740 --> 00:34:26.320
we now support multiple selection,
so that you have the selected values

00:34:26.540 --> 00:34:29.600
and selected objects bindings available.

00:34:29.670 --> 00:34:33.550
This is simply a change that
we had from last release.

00:34:35.110 --> 00:34:36.000
Oh, all right.

00:34:36.070 --> 00:34:38.830
New features, that's it.

00:34:38.960 --> 00:34:42.170
Now I'll go into some of the
tips and tricks for building

00:34:42.510 --> 00:34:47.030
Cocoa friendliness into your own classes.

00:34:50.950 --> 00:34:53.870
If you have model objects that you
want to use with Cocoa Bindings,

00:34:54.030 --> 00:34:56.590
you're probably done.

00:34:56.800 --> 00:34:59.560
Usually that's all you need to do,
as long as the attributes that

00:34:59.560 --> 00:35:04.860
you expect to be bindable are
key-value coding compliant.

00:35:04.990 --> 00:35:08.130
So in other words,
you have either a key-value coding

00:35:08.130 --> 00:35:14.560
compliant accessor for the attribute,
or you allow direct IVAR access.

00:35:14.690 --> 00:35:17.300
Usually that's all you really need to do.

00:35:19.490 --> 00:35:23.080
And part of that is that
Key-Value Observing automatically

00:35:23.640 --> 00:35:27.000
sends out notifications that
Cocoa Bindings requires.

00:35:27.100 --> 00:35:31.150
As long as the attributes that
you're exposing is bindable,

00:35:31.150 --> 00:35:35.710
or Key-Value Coding compliant,
Key-Value Observing does the

00:35:35.710 --> 00:35:38.270
notification generation for you.

00:35:38.960 --> 00:35:42.770
If for some reason you have
other attributes that you want

00:35:42.770 --> 00:35:46.120
to expose as bindable that aren't
key-value coding compliant,

00:35:46.240 --> 00:35:49.800
or you have some really complex
logic that changes lots of values,

00:35:49.800 --> 00:35:52.790
lots of attributes of your
model object all at once,

00:35:53.070 --> 00:35:55.560
then you can send out
notifications manually.

00:35:56.240 --> 00:36:00.060
Simply invoke self
willChangeValueForKeyPath defining

00:36:00.260 --> 00:36:04.530
the key path it is about to change,
change the value related

00:36:04.530 --> 00:36:07.020
to that key path,
and then invoke self

00:36:07.020 --> 00:36:08.740
didChangeValueForKeyPath.

00:36:09.000 --> 00:36:12.280
This is the way that you
send out key-value observing

00:36:12.280 --> 00:36:14.190
notifications manually.

00:36:15.040 --> 00:36:18.130
So as long as your object is
key-value observing compliant,

00:36:18.130 --> 00:36:23.500
and you have some key-value coding
compliant way of getting to the values,

00:36:23.520 --> 00:36:27.580
the next thing you would need to do-- oh,
actually, this is on the wrong slide.

00:36:27.580 --> 00:36:31.570
Key-value binding exposing
should be on this slide.

00:36:32.660 --> 00:36:37.160
If you have a view that you want
people to be able to bind from,

00:36:38.070 --> 00:36:42.750
so that it has those neat
little attribute boxes show

00:36:42.750 --> 00:36:49.250
up in Interface Builder,
all you need to do is pretend that those

00:36:49.350 --> 00:36:51.430
last two items are on the next slide.

00:36:51.500 --> 00:36:56.210
Exposed binding and exposed
bindings are two methods that

00:36:56.210 --> 00:36:58.460
you can use on your class.

00:36:58.490 --> 00:37:01.500
They're defined in key-value-binding.h.

00:37:01.500 --> 00:37:06.500
It lets you programmatically
expose bindings for your class.

00:37:06.500 --> 00:37:09.290
That way,
they show up in Interface Builder,

00:37:09.520 --> 00:37:14.490
as long as the class is loaded
by a bundle or a pallet.

00:37:15.700 --> 00:37:20.920
Continuing with making your
view Cocoa Bindings compliant,

00:37:21.110 --> 00:37:24.680
once you've exposed a
binding of your view,

00:37:25.220 --> 00:37:30.530
You'll need to implement the
bind-to and unbind methods.

00:37:32.370 --> 00:37:37.380
The BindTo method is how
you get the information of

00:37:37.380 --> 00:37:41.620
what your binding should do,
of what to synchronize between your

00:37:41.930 --> 00:37:44.450
view and some controller object.

00:37:44.810 --> 00:37:48.520
Typically there you would simply
cache the object you're binding to,

00:37:48.610 --> 00:37:51.960
as well as the key path and
options dictionary that you're

00:37:52.490 --> 00:37:54.500
creating the binding with.

00:37:54.500 --> 00:37:57.170
And immediately after,
you would typically add

00:37:57.180 --> 00:38:01.420
yourself as the observer of the
object you're being bound to.

00:38:01.550 --> 00:38:05.440
So your view would invoke
self add observer or object

00:38:06.180 --> 00:38:10.230
that you're binding to,
add observer self.

00:38:10.420 --> 00:38:13.860
So that way you'll get notifications
in the form of observed value

00:38:13.860 --> 00:38:18.930
for keypath whenever something
in the observed object changes.

00:38:25.090 --> 00:38:28.240
Once you have that in place,
if you have a view that's actually

00:38:28.240 --> 00:38:34.210
doing something that's editing related,
editing a value rather than just display.

00:38:34.520 --> 00:38:37.470
You'll probably also want to
implement the NS Editor and

00:38:37.650 --> 00:38:39.840
NS Editor registration methods.

00:38:39.840 --> 00:38:44.140
Well, really implement the
NS Editor methods and know about

00:38:44.140 --> 00:38:47.190
the NS Editor registration methods.

00:38:47.810 --> 00:38:53.300
NSEditor is an informal protocol
that defines how the controller

00:38:53.300 --> 00:38:57.900
can tell your view that it should
stop editing or discard editing.

00:38:57.970 --> 00:39:01.500
Commit editing is invoked on
your view if you should try

00:39:01.500 --> 00:39:07.660
and end editing in your view,
and then you can return a yes

00:39:08.200 --> 00:39:11.020
succeeded, or no,
if there was some sort of

00:39:11.220 --> 00:39:12.780
verification validation error.

00:39:14.390 --> 00:39:18.020
Discard editing is sent when
you should just throw out any

00:39:18.020 --> 00:39:23.140
changes that the user has made
and revert to the previous value.

00:39:24.820 --> 00:39:28.300
Once you start editing,
once an editing session has started,

00:39:28.360 --> 00:39:31.300
like the user has started moving
around something in your view,

00:39:31.440 --> 00:39:34.730
in your control,
then you can invoke objected

00:39:34.920 --> 00:39:39.400
begin editing on the controller
that you're bound to.

00:39:39.550 --> 00:39:45.580
You should be notified if it should
commit edits or discard any edits.

00:39:45.990 --> 00:39:48.090
And then, of course,
once editing is done,

00:39:48.140 --> 00:39:52.610
you can send the controller
objected and editing.

00:39:56.950 --> 00:40:01.180
Now once you have your view,
and it's bindable and beautiful,

00:40:01.240 --> 00:40:03.400
then you should really
put it on a pallet.

00:40:03.420 --> 00:40:05.390
That's the best way to take
advantage of Cocoa Bindings,

00:40:05.400 --> 00:40:09.680
so that people who use your view,
use your code,

00:40:09.680 --> 00:40:16.610
don't have to write the manual bind to
blah blah blah methods in their classes.

00:40:19.380 --> 00:40:24.120
Now, just going over again some of
the basics of how Cocoa Bindings

00:40:24.120 --> 00:40:27.830
works with key-value coding,
observing, and binding.

00:40:28.030 --> 00:40:30.140
When I say a key-value
coding compliant accessor,

00:40:30.250 --> 00:40:35.420
I'm really talking about a name
and set name kind of method pair.

00:40:36.010 --> 00:40:39.720
With that,
your model object will be key-value

00:40:39.720 --> 00:40:43.130
coding compliant for the key name.

00:40:44.300 --> 00:40:50.070
So that way you can bind the sum
attribute to an object that is of your

00:40:50.140 --> 00:40:54.300
object type with the keypath name.

00:40:57.540 --> 00:41:00.400
That's all you need to know for that one.

00:41:00.530 --> 00:41:01.840
Oh, oh, that's true.

00:41:02.000 --> 00:41:04.220
Now, if you're a Vue,
and you want to implement

00:41:04.340 --> 00:41:07.730
this bind method,
again, what you would typically do in

00:41:07.860 --> 00:41:11.640
your implementation is cache
away the observed controller,

00:41:11.800 --> 00:41:13.930
the keypath,
and the binding options that are

00:41:13.960 --> 00:41:16.640
sent in during the binding creation.

00:41:16.770 --> 00:41:18.640
And if you're going to
support more than one binding,

00:41:18.640 --> 00:41:23.830
it's probably a good idea to cache these
in a dictionary on a per-binding basis.

00:41:24.060 --> 00:41:29.210
This way when you get
the key value observed,

00:41:29.520 --> 00:41:33.890
Observe value for keypath
method invoked on your view.

00:41:34.500 --> 00:41:39.310
You can keep track of what attribute
you're supposed to update in your view.

00:41:41.900 --> 00:41:49.100
And here, I'd like to ask Andreas to
come up to do a little demo.

00:41:49.100 --> 00:41:53.090
He doesn't know what
I'm getting him into.

00:41:53.880 --> 00:41:58.520
So I think a lot of people are kind of
confused about how Cocoa Bindings works,

00:41:58.520 --> 00:42:02.950
how the BindTo method works.

00:42:05.100 --> 00:42:05.600
Perfect.

00:42:05.710 --> 00:42:15.500
If we pretend that you guys are the
developer of some application and I'm

00:42:15.700 --> 00:42:21.320
a view and Andreas is a controller--
not that I'm saying anything here-- in

00:42:21.320 --> 00:42:29.900
order for me to keep some attribute,
say my-- I'd wanted to find a hat

00:42:30.050 --> 00:42:33.900
actually-- say which arm is up,
if I wanted to keep that in

00:42:33.900 --> 00:42:39.080
sync with some value that
Andreas can give me-- exactly,

00:42:39.080 --> 00:42:39.720
see?

00:42:39.740 --> 00:42:46.630
All you have to do is say, Ron,
bind arm height to Andreas.

00:42:47.000 --> 00:42:52.430
Ron, bind arm height to Andreas.

00:42:52.430 --> 00:42:52.900
Perfect.

00:42:52.950 --> 00:42:53.800
So it's something like that.

00:42:54.340 --> 00:43:00.520
So now, anything Andreas does,
I can see and update my state.

00:43:01.060 --> 00:43:02.460
It's pretty simple, right?

00:43:02.460 --> 00:43:07.820
See, now the great thing is--

00:43:09.400 --> 00:43:12.870
The great thing is,
with bindings you can also add value

00:43:12.870 --> 00:43:18.470
transformers so that anything that
I get from the controller can be changed

00:43:18.620 --> 00:43:20.290
before actually sent to the view.

00:43:20.300 --> 00:43:24.420
So if there was an NS negate
boolean transformer,

00:43:24.560 --> 00:43:36.300
or negate arm height transformer,
anything he did would be in reverse.

00:43:40.900 --> 00:43:42.830
I'm not done with you yet.

00:43:43.020 --> 00:43:50.650
Let's do a little role reversal,
as my therapist would normally say.

00:43:50.720 --> 00:43:54.940
Let's pretend that I'm the controller
and that Andreas is the view.

00:43:55.080 --> 00:44:00.800
What really happens is,
if something changes in

00:44:00.800 --> 00:44:00.800
some model object somewhere,

00:44:00.940 --> 00:44:06.500
Then I would send a
notification to Andreas.

00:44:06.520 --> 00:44:13.350
And what this really highlights
is not only that the notification

00:44:13.350 --> 00:44:15.040
is really lightweight,

00:44:16.830 --> 00:44:19.300
But since it's so lightweight,
could you go get that?

00:44:19.350 --> 00:44:24.310
We can send a lot.

00:44:24.900 --> 00:44:28.800
Really fast.

00:44:28.800 --> 00:44:32.280
So this is how you should
think about Cocoa Binding.

00:44:32.330 --> 00:44:33.790
Well, maybe not.

00:44:33.840 --> 00:44:35.480
But you get the idea.

00:44:35.480 --> 00:44:39.820
Hopefully that clears up exactly
what's going on when you bind objects,

00:44:40.040 --> 00:44:42.070
bind a view to another object.

00:44:42.390 --> 00:44:46.460
And with that, I think...

00:44:48.930 --> 00:44:55.000
Now, quick recap.

00:44:55.000 --> 00:44:55.000
Yeah, yeah, there we go.

00:44:57.100 --> 00:44:59.210
So, Model-View-Controller.

00:44:59.450 --> 00:45:01.230
Again, Model-View-Controller.

00:45:01.440 --> 00:45:02.850
That's what we're based on.

00:45:02.890 --> 00:45:06.890
Cocoa lives and breathes
Model-View-Controller.

00:45:07.710 --> 00:45:10.110
Because of the code reuse,
that's really what we get out

00:45:10.110 --> 00:45:12.840
of Model-View-Controller here.

00:45:12.840 --> 00:45:14.660
And with Cocoa Bindings,
now we get a set of

00:45:14.660 --> 00:45:19.100
reusable controller objects,
as well as the notion of bindings,

00:45:19.160 --> 00:45:24.680
so that we can cut out all the glue
code that we're used to writing.

00:45:25.580 --> 00:45:30.360
And to keep with the
outline that I introduced,

00:45:30.590 --> 00:45:33.400
some of the new features
we've added to Cocoa Bindings

00:45:33.730 --> 00:45:35.220
includes a tree controller.

00:45:35.300 --> 00:45:38.540
So now you have something to bind to
from the outline view in the browser.

00:45:38.540 --> 00:45:41.970
We've also added filtering
directly to the array controller,

00:45:42.000 --> 00:45:44.830
also to NSArray and NSMutableArray.

00:45:45.040 --> 00:45:48.290
We've even added core data support
to the controllers so that you can

00:45:48.830 --> 00:45:51.840
fetch directly in the controllers.

00:45:51.840 --> 00:45:55.100
And then we've added some new
bindings and bindings options,

00:45:55.100 --> 00:45:59.340
which you'll see in the
documentation forthcoming.

00:45:59.340 --> 00:46:00.900
One more.

00:46:02.710 --> 00:46:08.620
And so the tips and tricks for rolling
your own bindings come down to making

00:46:08.620 --> 00:46:13.150
sure that your model objects and your
view objects are key-value coding,

00:46:13.330 --> 00:46:17.880
key-value observing,
and key-value binding friendly.

00:46:17.970 --> 00:46:25.080
This means making sure that all of your
model objects have actual KVC accessors,

00:46:25.080 --> 00:46:28.210
and that you can do the key-value
observing notifications.

00:46:28.350 --> 00:46:31.680
And then for your view classes,
it really helps to expose the

00:46:31.680 --> 00:46:36.510
bindings of any attributes you want,
and then put that view on a palette.

00:46:36.730 --> 00:46:41.600
And with that,
here's all the reference stuff.

00:46:41.610 --> 00:46:46.650
And who to contact would be Matt Formica,
who will be coming up shortly, I believe.
WEBVTT

00:00:13.340 --> 00:00:17.200
development team.

00:00:17.310 --> 00:00:20.580
Two years ago, we introduced iSync.

00:00:20.620 --> 00:00:24.860
iSync was an end user application that
let you synchronize your contacts,

00:00:24.920 --> 00:00:30.120
your calendars, with a phone, a PDA,
an iPod.

00:00:30.170 --> 00:00:32.590
With .Mac,
you could synchronize your contacts

00:00:32.600 --> 00:00:35.430
and your calendars to other computers.

00:00:35.620 --> 00:00:39.500
And we soon introduced Safari bookmarks.

00:00:40.050 --> 00:00:43.970
Today, it's my pleasure to be able to
tell you about Sync Services,

00:00:44.060 --> 00:00:46.900
with which you can add
sync to your applications.

00:00:46.900 --> 00:00:50.870
That kind of begs the question,
why would I want to sync?

00:00:50.900 --> 00:00:54.010
Well, for those of us with
more than one computer,

00:00:54.010 --> 00:00:56.900
it's a great way of never
having to worry about,

00:00:56.900 --> 00:01:00.880
did I leave the changes on this
computer or that computer or over here?

00:01:00.900 --> 00:01:04.890
Portable devices are becoming
more and more powerful,

00:01:04.970 --> 00:01:10.900
and so it's convenient to be able to have
my information available on my phone,

00:01:10.900 --> 00:01:13.900
or my palm, or wherever.

00:01:13.900 --> 00:01:16.390
But there's another reason too,
and it's not one that's

00:01:16.390 --> 00:01:18.900
immediately obvious when you
think about synchronization.

00:01:18.900 --> 00:01:22.900
People have got different applications
that kind of do the same thing,

00:01:23.030 --> 00:01:26.730
but some apps are better suited to one
particular kind of task than another.

00:01:26.900 --> 00:01:32.500
Sync can be used to share data
between different applications.

00:01:32.740 --> 00:01:36.210
What we're going to talk about
today is I'm going to tell

00:01:36.250 --> 00:01:39.600
you what Sync Services is,
going to get into the architecture,

00:01:39.600 --> 00:01:43.000
a bit of the data model,
and just give you a roadmap to the APIs.

00:01:43.000 --> 00:01:46.420
I'm not going to get too
deeply into what the APIs are.

00:01:46.600 --> 00:01:51.010
We've got a lot of great documentation
in the SDK that's on the Tiger DVD that

00:01:51.010 --> 00:01:54.830
you've got with you in your bags,
and also available on the web.

00:01:55.400 --> 00:01:59.210
There's a second session that directly
follows this one that's going to be a

00:01:59.210 --> 00:02:03.830
much more hands-on oriented approach
into getting actually into how you write,

00:02:03.830 --> 00:02:08.690
how you incorporate Sync
Services into your application.

00:02:09.280 --> 00:02:14.210
So let's jump in and answer the question,
what is Sync Services?

00:02:14.350 --> 00:02:20.010
It's a system service built directly
into Tiger for data synchronization.

00:02:20.950 --> 00:02:24.250
The basic gist is,
you provide us with access to your data,

00:02:24.530 --> 00:02:25.300
and we do the rest.

00:02:25.300 --> 00:02:28.630
We take care of all of the syncing
and all of the sync smarts for that.

00:02:29.870 --> 00:02:44.760
It's a single solution for everyone.

00:02:45.830 --> 00:02:45.890
Today,
if you want to get your contacts from

00:02:45.890 --> 00:02:45.890
your phone onto a Palm or some other PDA,
you often need two, three,

00:02:45.890 --> 00:02:45.890
sometimes more different solutions.

00:02:45.890 --> 00:02:45.890
We want to provide one
solution for everyone.

00:02:46.600 --> 00:02:50.250
The problem with the existing
solutions today is that they

00:02:50.250 --> 00:02:52.760
operate outside of your application.

00:02:52.760 --> 00:02:55.600
And this leads to a number
of different problems.

00:02:55.600 --> 00:02:59.250
There's the multiple writers issue,
meaning if you've got your application

00:02:59.250 --> 00:03:03.490
and there's a separate sync process,
both trying to access your data store,

00:03:03.490 --> 00:03:06.540
you have to solve the problem
of multi-process concurrent

00:03:06.640 --> 00:03:07.920
access to your data.

00:03:08.440 --> 00:03:11.440
And that's a hard problem to solve.

00:03:11.440 --> 00:03:15.650
If you're going for a file sync solution,
you want to keep your Word documents

00:03:15.650 --> 00:03:18.850
in sync with your laptop so you get
some kind of file sync solution.

00:03:18.950 --> 00:03:21.030
There's a granularity issue there.

00:03:21.170 --> 00:03:24.000
What happens if you change
the document in both places?

00:03:24.000 --> 00:03:26.930
What happens if you change just
part of the document on one and

00:03:26.930 --> 00:03:29.180
part of the document on the other?

00:03:29.280 --> 00:03:32.160
It'd be great if you
could merge those two.

00:03:32.160 --> 00:03:33.440
Proprietary formats.

00:03:33.440 --> 00:03:36.720
If you're a device developer and
you want to sync your device to

00:03:36.720 --> 00:03:39.820
some third-party application,
you have to go in,

00:03:39.820 --> 00:03:43.320
reverse engineer their format,
and figure out how they

00:03:43.340 --> 00:03:44.870
store their things.

00:03:44.910 --> 00:03:48.860
And that doesn't really create
a lasting solution there.

00:03:49.450 --> 00:03:52.840
What we're doing with Sync Services is
giving you the ability to build

00:03:52.840 --> 00:03:56.000
sync directly into your application.

00:03:56.130 --> 00:04:00.040
You focus on syncing your app,
and we'll take care of the rest,

00:04:00.260 --> 00:04:02.740
getting it to interoperate
with other applications,

00:04:02.890 --> 00:04:06.640
other devices, syncing between computers.

00:04:07.060 --> 00:04:09.400
Sync's not just about applications.

00:04:09.590 --> 00:04:11.920
It's for devices, too.

00:04:12.120 --> 00:04:16.490
We've worked a lot with devices with
various kinds of memory limitations,

00:04:16.680 --> 00:04:19.400
devices that can only store
a certain number of records,

00:04:19.460 --> 00:04:22.530
devices that can only store
fields of a certain length.

00:04:22.530 --> 00:04:26.920
We've got some good solutions to
help you manage that filtering,

00:04:26.920 --> 00:04:28.040
that formatting.

00:04:28.120 --> 00:04:33.320
You provide the application to
manage and configure your device.

00:04:33.540 --> 00:04:36.200
You incorporate Sync
into that application,

00:04:36.340 --> 00:04:37.360
and it's the same way.

00:04:37.360 --> 00:04:48.270
You sync the same way that you
would any other kind of application.

00:04:48.270 --> 00:04:48.270
You synchronize your devices the same
way you synchronize your applications.

00:04:48.270 --> 00:04:48.270
We're going for one
solution for everyone here.

00:04:49.060 --> 00:04:51.420
I want to talk a little
bit about the design goals

00:04:51.610 --> 00:04:56.040
because if you understand how,
what we were trying to do when

00:04:56.210 --> 00:05:00.360
we set out to accomplish things,
I think it will really help you get into

00:05:00.360 --> 00:05:05.520
the mode of what we were trying to do.

00:05:05.520 --> 00:05:07.840
We started with a really simple precept.

00:05:07.840 --> 00:05:11.660
Your data, where you want it,
when you want it.

00:05:11.730 --> 00:05:14.730
And from that we derived
three basic design goals.

00:05:14.770 --> 00:05:16.760
Syncs should be decoupled.

00:05:16.890 --> 00:05:19.090
Syncs should be extensible.

00:05:19.090 --> 00:05:21.100
And syncs should be invisible.

00:05:21.120 --> 00:05:25.820
Let's jump into what these
mean a little bit more.

00:05:25.820 --> 00:05:26.930
Syncs should be decoupled.

00:05:26.930 --> 00:05:29.660
Now there's two things
that we mean by this.

00:05:29.680 --> 00:05:35.610
Applications and devices should be able
to sync independently of each other.

00:05:36.100 --> 00:05:40.670
Sometimes when I want to sync with .Mac,
my phone's not turned on.

00:05:40.800 --> 00:05:44.060
Later, when my phone's available,
I don't have a network connection.

00:05:44.120 --> 00:05:49.560
And yet I still want my changes to flow
back and forth between the two of them.

00:05:49.560 --> 00:05:52.740
So we want to be able to synchronize
these things independently of each other.

00:05:52.740 --> 00:05:56.670
Now that being said,
we also want to try to synchronize

00:05:56.670 --> 00:05:58.750
these things at the same time.

00:05:58.760 --> 00:06:03.220
If I'm syncing two devices independently,
I have to do three syncs.

00:06:03.330 --> 00:06:07.650
One to get the changes from, say,
my phone into my computer,

00:06:07.880 --> 00:06:10.500
and then from my computer
into address book,

00:06:10.500 --> 00:06:13.470
and then from address book
back into my computer.

00:06:13.480 --> 00:06:13.480
And then I have to sync them.

00:06:13.480 --> 00:06:14.480
And then I have to sync
them back into my computer.

00:06:14.480 --> 00:06:17.440
And then I have to sync my phone again
to get the changes back onto the phone.

00:06:17.440 --> 00:06:20.300
So we want a way to be able
to try and sync both of these

00:06:20.300 --> 00:06:21.920
things at the same time.

00:06:21.920 --> 00:06:24.050
It reduces system resources.

00:06:24.050 --> 00:06:26.080
It makes things go faster.

00:06:26.080 --> 00:06:27.990
It's easier all around.

00:06:28.870 --> 00:06:32.280
The second kind of thing,
the second kind of decoupling that

00:06:32.390 --> 00:06:38.700
we're talking about is that schemas are
independent of applications and devices.

00:06:39.070 --> 00:06:42.520
The bookmark data model
is not owned by Safari,

00:06:42.700 --> 00:06:44.680
it's not owned by Mozilla.

00:06:44.740 --> 00:06:48.560
Address Book does not
own the contact schema.

00:06:48.670 --> 00:06:52.540
There's a clear separation
between the two there.

00:06:53.550 --> 00:06:56.400
The data model needs to be extensible.

00:06:56.540 --> 00:06:59.670
We provide some standard
schemas for contacts,

00:06:59.670 --> 00:07:02.400
for bookmarks, for calendar entries.

00:07:02.450 --> 00:07:04.900
If you want to be able to
exchange data between different

00:07:04.900 --> 00:07:08.380
applications and devices,
you need to conform to that schema.

00:07:08.400 --> 00:07:10.860
At the same time,
we want you to be able to

00:07:10.930 --> 00:07:13.400
achieve perfect synchronization.

00:07:13.400 --> 00:07:17.210
We're not going to be able to think of
everything that you're going to be able

00:07:17.360 --> 00:07:19.290
to synchronize in your application.

00:07:19.520 --> 00:07:21.340
We can't think of that ahead of time.

00:07:21.530 --> 00:07:26.400
And so you need a way to extend the
standard data types to add your fields.

00:07:26.400 --> 00:07:31.310
You need to be able to add new data
types if you want to synchronize photos,

00:07:31.310 --> 00:07:32.380
for example.

00:07:33.730 --> 00:07:37.540
And the most important point is
that syncs should be invisible.

00:07:37.640 --> 00:07:43.000
The user should not have to explicitly
think about synchronization.

00:07:43.320 --> 00:07:50.080
The idea is that changes should just flow
back and forth naturally between the two.

00:07:50.270 --> 00:07:53.630
To that end,
we put your application in control.

00:07:53.740 --> 00:07:56.990
You sync when you want to sync.

00:07:57.300 --> 00:07:59.700
Now,
it's important that you try and maintain

00:07:59.700 --> 00:08:01.950
application responsiveness during this.

00:08:02.100 --> 00:08:05.160
Sometimes, syncs can take a while.

00:08:05.220 --> 00:08:07.320
A device might be slow in responding.

00:08:07.560 --> 00:08:09.330
There might be a lot of changes going on.

00:08:09.480 --> 00:08:13.390
You don't want to give users the
spinning beach ball of death there.

00:08:13.870 --> 00:08:17.950
The model that we've come up with
is what we call trickle syncing.

00:08:18.160 --> 00:08:21.330
There's nothing that we do
to provide trickle syncing.

00:08:21.480 --> 00:08:27.240
It's a way that you write your
applications to synchronize.

00:08:27.310 --> 00:08:30.860
The idea is that we do
lots of frequent syncs.

00:08:30.920 --> 00:08:34.320
The more we sync,
the fewer changes we do on each sync.

00:08:34.430 --> 00:08:36.700
The fewer changes we
have to do on each sync,

00:08:36.760 --> 00:08:37.960
the faster the syncs go.

00:08:38.040 --> 00:08:45.600
The more frequently you can sync,
and so on and so forth.

00:08:45.600 --> 00:08:45.600
It creates kind of a virtual cycle there.

00:08:46.620 --> 00:08:50.060
So let's come back to the question
of what is Sync Services and

00:08:50.060 --> 00:08:54.800
answer it again from a bit of
a more of a geek perspective.

00:08:54.850 --> 00:08:56.650
It's a public framework.

00:08:56.850 --> 00:08:59.540
This framework provides administration.

00:08:59.580 --> 00:09:00.970
You register to synchronize.

00:09:01.080 --> 00:09:02.920
You register your schemas.

00:09:03.110 --> 00:09:07.880
It provides API with which you can
give changes to the Sync Engine.

00:09:08.060 --> 00:09:12.800
The Sync Engine processes those
changes and gives changes back to you.

00:09:13.540 --> 00:09:14.860
It's a daemon.

00:09:15.100 --> 00:09:18.720
The Sync Engine runs inside
the Sync Server there.

00:09:18.760 --> 00:09:21.840
It's a field level differencing engine,
and I'll come back to that point

00:09:21.910 --> 00:09:25.460
a little bit later to explain
exactly what we mean by that.

00:09:25.510 --> 00:09:29.900
But we're also coordinating syncs
between multiple applications,

00:09:29.900 --> 00:09:33.190
devices, servers,
and the Sync Server takes care

00:09:33.260 --> 00:09:35.420
of coordinating all of those.

00:09:35.420 --> 00:09:37.780
And finally, Sync Services is a UI.

00:09:37.780 --> 00:09:41.300
We provide a standard
UI for conflict resolution.

00:09:41.300 --> 00:09:44.940
We provide an airbag panel
so that the user can protect

00:09:44.940 --> 00:09:47.050
their data from rogue devices.

00:09:47.180 --> 00:09:53.460
We provide an API for you to reset
a specific device or an application.

00:09:53.460 --> 00:09:56.460
What I'm going to be focusing on
in this talk is mostly the Sync

00:09:56.460 --> 00:09:59.380
Server and the Sync Framework there.

00:10:00.500 --> 00:10:03.250
So let's get into some
of the details of Sync.

00:10:03.270 --> 00:10:05.280
There's three things
I'm going to cover here.

00:10:05.310 --> 00:10:07.160
We're going to talk about schemas.

00:10:07.170 --> 00:10:08.600
We're going to talk about clients.

00:10:08.670 --> 00:10:13.060
And then we're actually going to get into
the meat of how synchronization works.

00:10:13.400 --> 00:10:16.540
So what can you synchronize?

00:10:16.540 --> 00:10:21.300
I don't know how many of you went to
the core data talk a couple of days ago,

00:10:21.430 --> 00:10:24.510
but for those of you who were there,
I'm going to do a quick recap

00:10:24.610 --> 00:10:26.310
over what we can synchronize.

00:10:26.400 --> 00:10:29.270
We use the entity relationship model.

00:10:29.380 --> 00:10:31.920
This is the same model used
by the core data framework,

00:10:31.920 --> 00:10:35.170
and it's sort of based on the
precept that if you can save it,

00:10:35.240 --> 00:10:36.380
you can sync it.

00:10:36.470 --> 00:10:39.600
On top of that,
we've added some extras just for sync.

00:10:40.440 --> 00:10:44.760
Now, the entity relationship
model is an industry standard

00:10:44.760 --> 00:10:46.760
way of decomposing data.

00:10:46.760 --> 00:10:51.470
An entity describes a single,
discrete thing, a contact,

00:10:51.470 --> 00:10:55.250
a phone number, a bookmark, an MP3, etc.

00:10:55.280 --> 00:10:56.850
An entity has a name.

00:10:56.850 --> 00:11:01.140
In our case, the name must be unique
across the whole space.

00:11:01.140 --> 00:11:04.910
There's a global naming
space for entities there.

00:11:04.910 --> 00:11:10.420
So we recommend using a DNS-style syntax,
com.apple.contacts.phone.

00:11:10.440 --> 00:11:13.740
number, for example,
to avoid or to minimize

00:11:13.740 --> 00:11:15.660
the risk of collisions.

00:11:15.710 --> 00:11:18.850
Entities are composed of properties.

00:11:18.900 --> 00:11:22.020
A property is an attribute
which describes a single

00:11:22.020 --> 00:11:25.790
characteristic of the entity,
a first name, a last name,

00:11:25.980 --> 00:11:27.900
something along those lines.

00:11:27.960 --> 00:11:29.860
Attributes are strongly typed.

00:11:29.960 --> 00:11:33.110
You see on the monitor here the
list of types that we support.

00:11:33.250 --> 00:11:36.070
It's a fairly rich type,
and we can look at adding

00:11:36.070 --> 00:11:37.660
new types in the future.

00:11:37.760 --> 00:11:41.720
The basic types: strings, numbers, data,
date, etc.

00:11:42.050 --> 00:11:43.340
We've got some aggregate types.

00:11:43.340 --> 00:11:45.990
You can create arrays of
these primitive types.

00:11:46.120 --> 00:11:49.020
You can create dictionaries
of these primitive types.

00:11:49.130 --> 00:11:50.160
And we have an enum type.

00:11:50.420 --> 00:11:54.960
An enum is basically a string with a
fixed set of values that are allowed.

00:11:55.070 --> 00:12:01.100
And the engine will enforce a
certain level of data typing on this.

00:12:01.780 --> 00:12:04.550
Relationships are very interesting.

00:12:04.770 --> 00:12:08.360
Often data by itself
is not all that useful.

00:12:08.420 --> 00:12:12.990
What's interesting are the roles,
the relationships between the data.

00:12:13.140 --> 00:12:17.400
A relationship describes a
particular role between two entities.

00:12:17.400 --> 00:12:21.260
For example,
a contact has one or more phone numbers.

00:12:21.330 --> 00:12:23.750
A bookmark has a parent.

00:12:23.930 --> 00:12:27.390
So a relationship is directional.

00:12:27.390 --> 00:12:28.570
You have

00:12:29.030 --> 00:12:32.340
There are two kinds of
ordinalities for a relationship.

00:12:32.410 --> 00:12:35.990
You can have a two-one relationship,
or you can have a too-many relationship.

00:12:35.990 --> 00:12:40.990
A two-one relationship is a one-to-one
association between two entities.

00:12:40.990 --> 00:12:43.500
A bookmark has a single parent.

00:12:43.520 --> 00:12:47.540
In a too-many relationship,
you've got multiple relationships.

00:12:47.650 --> 00:12:49.890
A contact can have
multiple phone numbers,

00:12:49.900 --> 00:12:50.650
for example.

00:12:51.240 --> 00:12:54.280
There's the concept also
of an inverse relationship.

00:12:54.280 --> 00:12:58.280
If you have a relationship from
a bookmark to its parent folder,

00:12:58.280 --> 00:13:01.690
there's also going to be an interesting
relationship from a folder down

00:13:02.020 --> 00:13:03.800
to the bookmarks that it contains.

00:13:03.860 --> 00:13:08.580
And we'll come a little bit later
into why that's important to maintain.

00:13:08.580 --> 00:13:12.360
So,
what happens when an entity is deleted?

00:13:12.430 --> 00:13:15.760
This is, again,
where relationships come into play.

00:13:15.760 --> 00:13:20.100
When you delete a particular entity,
we find all of the relationships

00:13:20.100 --> 00:13:21.160
that point to that entity.

00:13:21.180 --> 00:13:23.740
And we nullify them out.

00:13:23.930 --> 00:13:28.180
You may also optionally say,
"When this entity is deleted,

00:13:28.180 --> 00:13:31.500
I want you to traverse through this
relationship and delete all of the

00:13:31.580 --> 00:13:36.640
guys that he points to." That's what
we call a cascading delete rule.

00:13:38.250 --> 00:13:41.040
Some of the extra stuff that
we've added for Sync is the

00:13:41.120 --> 00:13:43.700
notion of an identity property.

00:13:43.820 --> 00:13:48.400
When you add a new record into
the Sync Services engine there,

00:13:48.440 --> 00:13:51.980
we want to try and match that record
up against existing records already

00:13:52.100 --> 00:13:54.190
provided against by other clients.

00:13:54.310 --> 00:13:56.660
Otherwise, we'll end up with duplicates.

00:13:56.760 --> 00:13:59.560
In the case of a contact,
we want to find a contact that

00:13:59.560 --> 00:14:01.500
looks the same as this guy.

00:14:01.640 --> 00:14:05.460
And we use the identity properties
for that kind of matching.

00:14:05.520 --> 00:14:08.340
A contact,
your identity properties will most likely

00:14:08.340 --> 00:14:10.690
be the first name and the last name.

00:14:11.020 --> 00:14:13.550
Any object,
any record in the database that has the

00:14:13.550 --> 00:14:18.010
same first name and last name is probably
going to be the same kind of record.

00:14:18.010 --> 00:14:22.820
And so the Sync Engine will
merge those two records together.

00:14:22.970 --> 00:14:26.720
An identity property can be a
relationship or an attribute.

00:14:27.000 --> 00:14:31.180
For example, a phone number is bound
to a specific contact.

00:14:31.180 --> 00:14:34.390
You don't want to match the phone
number from one person to the

00:14:34.490 --> 00:14:34.780
phone number of another person.

00:14:34.780 --> 00:14:34.780
You want to match the phone
number of another person to the

00:14:34.780 --> 00:14:34.780
phone number of another person.

00:14:34.780 --> 00:14:34.780
You want to match the phone
number of another person to the

00:14:34.780 --> 00:14:34.780
phone number of another person.

00:14:34.780 --> 00:14:34.780
You want to match the phone
number of another person to the

00:14:34.780 --> 00:14:34.780
phone number of another person.

00:14:34.780 --> 00:14:34.780
You want to match the phone
number of another person to the

00:14:34.780 --> 00:14:34.780
phone number of another person.

00:14:34.780 --> 00:14:35.020
You want to match the phone
number of another person to the

00:14:35.020 --> 00:14:36.020
phone number of another person.

00:14:36.420 --> 00:14:39.410
Even if they're the same phone number,
they might be two roommates.

00:14:39.410 --> 00:14:42.200
And when one roommate moves away
and you change the phone number,

00:14:42.200 --> 00:14:46.040
you don't want the other person's phone
number to change at the same time.

00:14:46.170 --> 00:14:51.190
If you put the two contact relationship
into the identity set there,

00:14:51.340 --> 00:14:54.860
what it's saying is that we will limit
the set of records we look at to all of

00:14:54.860 --> 00:14:58.410
the records matched on that relationship.

00:14:59.410 --> 00:15:01.720
There's the notion of
dependent properties.

00:15:01.890 --> 00:15:05.500
For example,
let's say that I have a calendar event.

00:15:05.810 --> 00:15:09.140
He's got a start date,
and he also has a bit specifying

00:15:09.140 --> 00:15:10.880
whether or not he's an all-day event.

00:15:10.890 --> 00:15:15.110
These are two separate fields,
and so I don't want to try and merge

00:15:15.260 --> 00:15:18.810
them together in the sync engine,
but there is a semantic

00:15:18.810 --> 00:15:21.160
relationship between the two.

00:15:21.160 --> 00:15:25.400
If I change the start date on one event,
and I change the fact that

00:15:25.400 --> 00:15:29.600
it's an all-day event on
another--on a different client,

00:15:29.600 --> 00:15:32.700
I want the sync engine to
generate a conflict for that.

00:15:32.700 --> 00:15:35.830
By putting those two in the
dependent properties set there,

00:15:35.830 --> 00:15:39.840
by marking them as dependent properties,
the sync engine can catch and

00:15:39.840 --> 00:15:45.120
generate conflicts for those,
even though they're two different fields.

00:15:46.360 --> 00:15:51.020
I mentioned before the ability to extend
existing entities to add your own fields,

00:15:51.180 --> 00:15:52.790
to add your own attributes.

00:15:52.980 --> 00:15:55.210
These are what we call entity extensions.

00:15:55.300 --> 00:15:59.960
You can even create new relationships
on an existing entity to another

00:15:59.960 --> 00:16:02.050
entity or to a brand new entity.

00:16:02.060 --> 00:16:05.770
But it's very careful that you don't
change the fundamental properties

00:16:05.810 --> 00:16:07.870
of the entity that you're extending.

00:16:07.890 --> 00:16:11.820
If you add a new cascading delete
rule or something like that,

00:16:11.820 --> 00:16:15.430
you may end up causing bugs in
some other clients that were

00:16:15.920 --> 00:16:18.290
depending on the original behavior.

00:16:19.100 --> 00:16:22.750
Finally, we've introduced the
notion of a data class.

00:16:22.830 --> 00:16:27.480
A data class is just an informal
association of entities,

00:16:27.480 --> 00:16:29.000
an informal grouping of entities.

00:16:29.000 --> 00:16:33.910
There tends to be a lot of entities that
are going to fall out in your schema.

00:16:34.110 --> 00:16:37.000
You've got contacts, phone numbers, URLs,
AIM addresses,

00:16:37.000 --> 00:16:39.000
all of these kinds of things.

00:16:39.000 --> 00:16:42.670
And yet, in the mind of the user,
what they're thinking about for all of

00:16:42.670 --> 00:16:44.950
those things is the notion of a contact.

00:16:45.000 --> 00:16:49.990
And so the data class gives you a way
of presenting a user-friendly name

00:16:50.000 --> 00:16:52.900
to your collection of classes there.

00:16:53.000 --> 00:16:58.100
The Sync Engine itself doesn't
actually use data classes for anything

00:16:58.100 --> 00:17:01.230
intrinsic to the Sync operations.

00:17:03.080 --> 00:17:08.060
Your schema is described in a file.

00:17:08.060 --> 00:17:10.920
This file contains the description
of all of your entities,

00:17:11.090 --> 00:17:14.270
your extensions,
the attributes on the entities,

00:17:14.430 --> 00:17:16.000
the relationships.

00:17:16.100 --> 00:17:17.760
It's a standard plist file.

00:17:18.030 --> 00:17:21.000
The format's well documented
in our documentation,

00:17:21.130 --> 00:17:24.000
and it's contained in
a Sync Schema bundle.

00:17:24.040 --> 00:17:25.940
That bundle can be located anywhere.

00:17:25.990 --> 00:17:28.240
You can include it in a framework.

00:17:28.270 --> 00:17:30.020
You can include it in your app wrapper.

00:17:30.300 --> 00:17:32.740
You can put it in a
standard system location.

00:17:35.010 --> 00:17:38.320
The key point to remember
here is that your schema is

00:17:38.430 --> 00:17:41.610
decoupled from your application.

00:17:41.800 --> 00:17:47.620
Even if you're writing your application,
your schema, and that's all that's going

00:17:47.620 --> 00:17:50.980
to be syncing that schema,
in the eyes of the sync engine,

00:17:51.200 --> 00:17:53.320
the two are not related to each other.

00:17:53.320 --> 00:17:56.350
Your app does not own the schema.

00:17:57.180 --> 00:17:59.760
We provide three standard
schemas for contacts,

00:17:59.850 --> 00:18:04.180
calendars, and bookmarks,
and those are located in System, Library,

00:18:04.330 --> 00:18:06.100
Sync Services schemas.

00:18:06.220 --> 00:18:09.390
And I encourage you to go in,
open up the schema bundle,

00:18:09.530 --> 00:18:11.780
find the plist,
and have a look through it

00:18:11.780 --> 00:18:13.600
to see the standard formats.

00:18:13.800 --> 00:18:16.510
Unfortunately, we don't have any
documentation on that yet,

00:18:16.700 --> 00:18:20.390
but we hope to be addressing that
at some point in the near future.

00:18:21.530 --> 00:18:24.840
So let's come back again to the
what can you synchronize question.

00:18:24.840 --> 00:18:28.040
We've talked about entities,
relationships, attributes.

00:18:28.090 --> 00:18:31.390
This defines the data model
that you can synchronize.

00:18:31.400 --> 00:18:34.350
What you actually
synchronize are records.

00:18:34.410 --> 00:18:38.400
A record is the basic unit of exchange.

00:18:38.400 --> 00:18:41.380
In terms of the API,
it's expressed as an NSDictionary.

00:18:41.400 --> 00:18:44.400
The keys are the attribute
and relationship names.

00:18:44.400 --> 00:18:48.940
The values are the types that
correspond to the associated

00:18:48.940 --> 00:18:51.180
attribute or relationship.

00:18:51.400 --> 00:18:56.440
A record has an identifier,
and that identifier must be unique

00:18:56.440 --> 00:18:59.190
across your entire entity space.

00:18:59.400 --> 00:19:03.990
If you have a contact entity and
you have a phone number entity,

00:19:03.990 --> 00:19:07.330
the records are,
the identifiers must be unique.

00:19:07.510 --> 00:19:11.400
And this is where we differ a little bit
from your standard database terminology.

00:19:11.400 --> 00:19:17.400
One key point is that your record
dictionary must contain an entity name.

00:19:17.400 --> 00:19:21.300
You have to tell us what kind
of entity your record is.

00:19:21.420 --> 00:19:25.500
The Sync Engine depends on being able
to know what kind of record it is so

00:19:25.590 --> 00:19:30.390
it can do the right kind of matching,
the right things with the field values.

00:19:31.750 --> 00:19:35.720
So we've talked a lot about applications,
devices.

00:19:35.810 --> 00:19:39.100
We sort of mentioned that the Sync
Engine is a little bit agnostic.

00:19:39.410 --> 00:19:43.840
It doesn't much care whether your
client is an application or a device.

00:19:43.920 --> 00:19:46.020
And so we came up with
this generic name for them.

00:19:46.200 --> 00:19:48.930
We call them Sync Clients.

00:19:49.020 --> 00:19:51.880
A Sync Client has a unique identifier.

00:19:52.000 --> 00:19:55.910
That is how your client is
identified to Sync Services.

00:19:56.010 --> 00:19:59.570
You can also give it a user-friendly
display name and an image

00:19:59.570 --> 00:20:02.680
for display in some sync UI.

00:20:02.960 --> 00:20:06.040
There's a one-to-one
correspondence generally between

00:20:06.040 --> 00:20:08.200
a client and a data source.

00:20:08.320 --> 00:20:12.780
In the case of an application,
the association is pretty clear.

00:20:12.790 --> 00:20:17.980
But in the case of a device,
you've got to think that I'm writing a

00:20:17.980 --> 00:20:21.370
client for a specific kind of device,
but the user may end up

00:20:21.370 --> 00:20:25.120
with multiple copies,
with multiple kinds of devices.

00:20:25.150 --> 00:20:26.990
I've got many different kinds of phones.

00:20:26.990 --> 00:20:30.060
I've got a couple of PDAs, two iPods.

00:20:31.090 --> 00:20:34.830
Each of those corresponds
to a unique client that you

00:20:34.830 --> 00:20:37.290
register with the Sync Engine.

00:20:37.560 --> 00:20:43.640
A client description file provides a
template description for your client.

00:20:43.740 --> 00:20:46.600
It generally contains
just the static details.

00:20:46.740 --> 00:20:50.290
The type of your client,
is it an application or a device?

00:20:50.450 --> 00:20:52.960
The list of entities
that you've synchronized,

00:20:53.100 --> 00:20:56.980
and the specific properties on
those entities that you synchronize.

00:20:56.980 --> 00:20:58.570
That's important to note.

00:20:58.800 --> 00:21:02.720
Just because an entity defines a
set of fields doesn't mean that

00:21:02.720 --> 00:21:05.800
your client is going to want to
synchronize all of those fields.

00:21:05.800 --> 00:21:10.050
And so you can specify,
I'm only interested in synchronizing,

00:21:10.150 --> 00:21:13.800
say, the first name and the last
name on the contact entity.

00:21:13.800 --> 00:21:16.120
Some clients only push changes.

00:21:16.120 --> 00:21:18.300
Some clients only pull changes.

00:21:18.560 --> 00:21:21.400
The iPod is basically a pull-only device.

00:21:21.400 --> 00:21:24.280
You only pull information onto the iPod.

00:21:24.280 --> 00:21:27.980
The iPod is never going to
change that information.

00:21:27.980 --> 00:21:31.470
By specifying that in the
client description file,

00:21:31.550 --> 00:21:35.680
you can help the Sync Engine optimize
some of its processes.

00:21:35.680 --> 00:21:40.540
Now, a lot of the times there's going to
be a one-to-one association between

00:21:40.540 --> 00:21:43.290
the client and the client description.

00:21:43.380 --> 00:21:46.870
And so you can also include a
display name and an image directly

00:21:46.980 --> 00:21:48.940
in the client description file.

00:21:48.940 --> 00:21:52.060
And if you're writing an application,
that's probably what you're going

00:21:52.070 --> 00:21:53.420
to be using most of the time.

00:21:53.440 --> 00:21:57.950
You can also specify that information
dynamically using the Sync Services.

00:21:57.980 --> 00:22:01.320
So when a phone is registered,
when the user decides,

00:22:01.320 --> 00:22:05.450
I want to synchronize a phone,
your client can figure out what kind of

00:22:05.590 --> 00:22:10.890
phone it is and register the appropriate
name and image for that phone.

00:22:11.870 --> 00:22:16.380
Let's get now into the actual
meat of how Sync works.

00:22:16.570 --> 00:22:19.330
There's basically five phases of Sync.

00:22:19.380 --> 00:22:21.370
I'm going to cover them
briefly here just so we have a

00:22:21.750 --> 00:22:25.070
framework for the conversation,
and we'll start diving

00:22:25.070 --> 00:22:26.610
into the nitty gritty.

00:22:26.680 --> 00:22:30.360
The first thing you do is
you create a Sync session.

00:22:30.420 --> 00:22:33.700
You then negotiate how
you're going to sync.

00:22:33.750 --> 00:22:36.760
You push your changes into Sync Services.

00:22:36.810 --> 00:22:40.860
We process all of those changes,
and then you pull what changes are

00:22:40.900 --> 00:22:43.900
due to you back out of Sync Services.

00:22:43.960 --> 00:22:46.480
Now, there's a couple of things
that you have to know first.

00:22:46.670 --> 00:22:50.580
And what I'm going to cover
here is the truth database.

00:22:51.150 --> 00:22:54.750
The Truth database is an aggregate
of all of the information

00:22:55.180 --> 00:22:57.710
from all of the clients.

00:22:58.340 --> 00:23:02.240
If you have a client that is
synchronizing contacts and he pushes in

00:23:02.240 --> 00:23:06.400
just the first name and the last name,
you've got another client who's

00:23:06.400 --> 00:23:10.340
synchronizing the first name,
the last name, and the company name.

00:23:10.400 --> 00:23:14.220
What we store in the truth is the
aggregate of all of those fields,

00:23:14.220 --> 00:23:17.750
the first name, the last name,
and the company name.

00:23:17.930 --> 00:23:22.790
The truth is what the clients sync to,
not with each other.

00:23:22.820 --> 00:23:27.180
If you remember I mentioned earlier that
clients are decoupled from each other,

00:23:27.430 --> 00:23:29.800
and this is how we accomplish it.

00:23:29.860 --> 00:23:33.330
A client can sync into the truth,
another client can come along

00:23:33.330 --> 00:23:36.480
and sync into the truth,
and then they can pull their

00:23:36.480 --> 00:23:38.800
changes directly out of the truth.

00:23:38.800 --> 00:23:41.440
Now we are storing a
copy of the data here,

00:23:41.440 --> 00:23:43.790
and that's worth keeping in mind.

00:23:43.800 --> 00:23:45.550
If you're going to be
synchronizing photos,

00:23:45.560 --> 00:23:47.640
if you're going to be
synchronizing large data files,

00:23:47.810 --> 00:23:50.600
or things like that,
you probably don't want to push

00:23:50.660 --> 00:23:52.800
that information into the truth.

00:23:52.800 --> 00:23:55.910
Because then you're going to end
up with multi-gigabytes of data

00:23:56.180 --> 00:23:57.800
lying around on the user's disk.

00:23:57.800 --> 00:24:01.800
We're going to come up with a solution
for that at some point in the future.

00:24:06.200 --> 00:24:09.250
The Client State Database.

00:24:09.280 --> 00:24:13.200
What this contains is a snapshot
of all of the records on a device.

00:24:13.200 --> 00:24:18.500
We need this information
for a couple of reasons.

00:24:18.500 --> 00:24:21.320
What we do when we know
a record is on a device,

00:24:21.320 --> 00:24:25.810
when the device gives a record to us,
or when we push a record to the client,

00:24:25.810 --> 00:24:30.040
we store a copy of that
record in the client state.

00:24:30.040 --> 00:24:32.720
The reason we do this is
so that on the next sync,

00:24:32.830 --> 00:24:35.430
if the client gives
that record back to us,

00:24:35.560 --> 00:24:39.910
we can pull what we knew was on
the client before out of the client

00:24:39.910 --> 00:24:42.770
state and compare the two of them.

00:24:42.910 --> 00:24:46.690
From that, we can figure out has this
record changed at all?

00:24:46.730 --> 00:24:52.180
We can figure out specifically what
fields on that record have changed.

00:24:52.180 --> 00:24:57.040
What we push into the sync server
are just the field level differences.

00:24:57.040 --> 00:25:00.910
If you change just the first name,
we're not going to push

00:25:01.210 --> 00:25:02.700
the whole record across.

00:25:02.700 --> 00:25:08.150
We're going to push just the first
name across into the mingler.

00:25:09.060 --> 00:25:14.000
The other place where this is used
is when we're formatting records.

00:25:14.040 --> 00:25:17.910
I mentioned earlier that some devices
have limitations on the lengths

00:25:18.040 --> 00:25:19.760
of the fields that they can store.

00:25:19.910 --> 00:25:22.760
A phone may truncate
names at 20 characters,

00:25:22.860 --> 00:25:24.000
for example.

00:25:24.000 --> 00:25:27.920
So if we take a really long name
and we push it onto the phone,

00:25:27.920 --> 00:25:29.660
the phone's going to truncate it.

00:25:29.740 --> 00:25:32.220
If the phone then gives
that record back to us,

00:25:32.380 --> 00:25:35.400
what we would do is we would
look at the shortened name,

00:25:35.400 --> 00:25:38.090
we'd compare it to the longer
name in the client state,

00:25:38.090 --> 00:25:41.660
we'd say, "Hey, this has changed," and
we'd end up propagating the

00:25:41.740 --> 00:25:43.300
truncated name everywhere.

00:25:43.360 --> 00:25:45.990
And that would make people
generally pretty unhappy.

00:25:46.210 --> 00:25:49.890
So what we do is we store in the
client state the formatted record.

00:25:50.050 --> 00:25:53.740
We're going to store the truncated
name in the database there,

00:25:53.740 --> 00:25:56.070
in the client state,
so that when the client

00:25:56.080 --> 00:25:59.250
gives that record back to us,
we'll compare the two fields, we'll say,

00:25:59.250 --> 00:26:00.700
"Those are the same.

00:26:00.700 --> 00:26:04.910
It hasn't changed." Unless, of course,
the user has actually physically

00:26:04.910 --> 00:26:06.850
changed the name on the device.

00:26:07.220 --> 00:26:10.570
Now you're probably thinking, "Oh great,
they're storing yet another

00:26:10.570 --> 00:26:13.470
copy of all of my photos and my
contacts and the things." Well,

00:26:13.470 --> 00:26:15.100
it's not that bad actually.

00:26:15.100 --> 00:26:19.340
What we store in the client state is
really just a hash of the information

00:26:19.590 --> 00:26:21.100
that we push to the device.

00:26:21.100 --> 00:26:26.100
Just enough information so that we
can do that comparison successfully.

00:26:29.890 --> 00:26:33.850
One important thing to understand
is that the record identifiers are

00:26:33.940 --> 00:26:37.020
scoped to a particular name space.

00:26:37.050 --> 00:26:40.120
Each client has its own name space.

00:26:40.170 --> 00:26:45.400
The truth database has a name space,
and there is no correlation whatsoever

00:26:45.400 --> 00:26:47.910
between any of these name spaces.

00:26:48.050 --> 00:26:51.390
So if a client has a record called foo,
another client may have

00:26:51.390 --> 00:26:53.650
a record called foo,
and those can be two

00:26:53.660 --> 00:26:55.830
completely different records.

00:26:55.830 --> 00:26:59.300
There is no association
between the two of them there.

00:27:00.210 --> 00:27:04.510
So putting everything together,
the way things work is this.

00:27:04.520 --> 00:27:09.090
A client is going to take a record,
give it to Sync Services.

00:27:09.220 --> 00:27:15.090
Sync Services is going to pull the record
out of the client state and compare them.

00:27:15.130 --> 00:27:18.460
If the record isn't in the client state,
then we know that this

00:27:18.550 --> 00:27:21.280
must be a new record,
and we push what we call an

00:27:21.410 --> 00:27:23.110
add into the Sync Server.

00:27:23.110 --> 00:27:28.360
If the record exists in the client state,
we compare the two and push just

00:27:28.590 --> 00:27:29.760
the field level differences.

00:27:42.450 --> 00:27:42.460
So we're going to take a record,
give it to Sync Services,

00:27:42.460 --> 00:27:42.460
and we push what we call an
add into the Sync Server.

00:27:42.460 --> 00:27:42.460
The Sync Server processes those changes,
merges them into the truth,

00:27:42.460 --> 00:27:42.460
and clients then pull all of
the changes out of the truth.

00:27:43.400 --> 00:27:46.680
So,
coming back to the start of the process,

00:27:46.780 --> 00:27:48.940
creating a sync session.

00:27:48.960 --> 00:27:52.980
The first thing you have to understand
is you may not be allowed to synchronize,

00:27:52.980 --> 00:27:56.040
and there's many reasons for this.

00:27:56.090 --> 00:28:00.380
It could be that some other
client is already synchronizing.

00:28:00.400 --> 00:28:03.660
Now, because the sync server is
writing into a common database,

00:28:03.820 --> 00:28:07.920
we can't allow multiple people to
all synchronize at the same time.

00:28:08.040 --> 00:28:12.760
We need to maintain a certain state of
integrity of the truth database there,

00:28:12.770 --> 00:28:16.580
and so we can only process
sets of clients at a time.

00:28:16.670 --> 00:28:19.710
So, if a client is already in
the middle of synchronizing,

00:28:19.710 --> 00:28:23.290
other clients must wait
until that guy has finished.

00:28:24.010 --> 00:28:26.830
It's important to be able
to maintain application

00:28:26.850 --> 00:28:29.170
responsiveness throughout this.

00:28:29.220 --> 00:28:32.310
So we provide both blocking
APIs for convenience,

00:28:32.430 --> 00:28:36.860
but we also provide non-blocking
APIs so that you can basically

00:28:36.860 --> 00:28:38.340
request to sync services.

00:28:38.510 --> 00:28:41.350
I'd like to start a sync session now,
please.

00:28:41.510 --> 00:28:47.320
Generally, you'll probably be able
to go straight away,

00:28:47.320 --> 00:28:49.110
but if you can't, we'll call you back
when you're ready to go.

00:28:49.580 --> 00:28:52.640
Now that being said,
I also mentioned earlier that we want

00:28:52.750 --> 00:28:55.340
to synchronize clients simultaneously.

00:28:55.390 --> 00:28:57.540
This is not a contradiction.

00:28:57.600 --> 00:29:01.640
What Sync Services provides
is the notion of a sync alert.

00:29:01.840 --> 00:29:06.000
When you register your client,
you can specify the kinds of clients

00:29:06.220 --> 00:29:08.920
that you want to synchronize with.

00:29:08.970 --> 00:29:12.620
Address book pretty much wants
to synchronize with anything.

00:29:12.640 --> 00:29:14.800
So he'll says,
"I'll synchronize with apps,

00:29:14.930 --> 00:29:19.000
I'll sync with devices,
I'll sync with servers." A server

00:29:19.000 --> 00:29:24.730
would probably only synchronize when
other servers are synchronizing.

00:29:24.730 --> 00:29:28.540
A phone would synchronize
when a server is syncing,

00:29:28.590 --> 00:29:31.120
or when another phone is syncing.

00:29:31.120 --> 00:29:36.440
So you specify at registration
time who you want to sync with.

00:29:36.440 --> 00:29:39.320
When one of those guys
then starts syncing,

00:29:39.440 --> 00:29:42.460
Sync Services delivers an
advisory notice to the clients

00:29:42.500 --> 00:29:44.060
that have registered an interest.

00:29:45.090 --> 00:29:48.280
This is an advisory notice only.

00:29:48.320 --> 00:29:50.710
You're free to ignore it if
you're not ready to sync.

00:29:50.860 --> 00:29:53.550
We definitely encourage
you to sync if you can.

00:29:55.300 --> 00:29:58.150
There are two ways that the
notice can be delivered.

00:29:58.270 --> 00:30:01.200
We can launch a tool
that you've registered.

00:30:01.330 --> 00:30:04.870
We specify on the command line
to that tool the ID of the

00:30:04.980 --> 00:30:07.930
entity that's being synchronized,
the ID of the client

00:30:07.940 --> 00:30:09.460
that's being synchronized,
excuse me,

00:30:09.460 --> 00:30:13.150
and the list of entities that are
being synchronized with that client.

00:30:14.290 --> 00:30:17.040
Alternatively,
you can register a callback

00:30:17.040 --> 00:30:20.730
directly in your application,
an object and a selector,

00:30:20.970 --> 00:30:23.580
and we will invoke that selector saying,
"Hey,

00:30:23.790 --> 00:30:26.100
now's a good time to sync if you like.

00:30:26.200 --> 00:30:29.280
If you don't want to sync,
simply return without doing anything,

00:30:29.450 --> 00:30:31.190
and we'll pass you by this time.

00:30:31.360 --> 00:30:33.720
You can always sync later."

00:30:34.260 --> 00:30:39.530
Now, why would you want to choose
one method over another?

00:30:39.780 --> 00:30:43.860
Something like a server or a device
is probably going to register a tool

00:30:44.040 --> 00:30:46.320
to actually do the synchronization.

00:30:46.370 --> 00:30:49.520
They don't necessarily have any
multiple writers issues to worry

00:30:49.520 --> 00:30:51.400
about or anything like that.

00:30:51.450 --> 00:30:54.280
When they want to synchronize,
we just launch the tool,

00:30:54.320 --> 00:30:57.180
and all of the logic's
embedded in that tool.

00:30:57.220 --> 00:31:01.440
An application like iCal,
on the other hand, when it launches,

00:31:01.480 --> 00:31:03.940
will register a dynamic callback.

00:31:03.990 --> 00:31:06.910
While iCal is running,
we can call that callback

00:31:07.040 --> 00:31:09.040
to tell iCal to synchronize.

00:31:09.090 --> 00:31:13.720
When iCal quits,
the callback is deregistered implicitly,

00:31:13.760 --> 00:31:18.990
and iCal won't sync anymore
until the next time it launches.

00:31:20.920 --> 00:31:24.150
After you've successfully
created your sync session,

00:31:24.200 --> 00:31:26.800
you go through and you
negotiate the sync modes.

00:31:27.150 --> 00:31:31.640
Now there are four basic sync modes
that we need to talk about here.

00:31:31.800 --> 00:31:34.800
The first of these is fast syncing.

00:31:34.920 --> 00:31:37.800
Fast syncing is the preferred
mode of synchronization.

00:31:37.800 --> 00:31:41.800
When you're fast syncing,
you're basically just telling the

00:31:41.800 --> 00:31:46.800
engine what changes have happened
since the last time you synchronized.

00:31:46.800 --> 00:31:49.120
You tell the engine,
"These are the records that

00:31:49.120 --> 00:31:50.800
were added since I last synced.

00:31:50.800 --> 00:31:54.800
These are the records that were
modified since I last synced.

00:31:54.800 --> 00:31:59.400
These records have been deleted
since I last synchronized." That kind

00:31:59.540 --> 00:32:03.500
of implies that you can maintain
all of that state information,

00:32:03.500 --> 00:32:07.610
and not all applications,
not all devices are set up to do that.

00:32:08.420 --> 00:32:11.380
Sometimes, even when you can
maintain that information,

00:32:11.590 --> 00:32:12.630
you may not trust it.

00:32:12.940 --> 00:32:15.800
If you synchronized a
device with another machine,

00:32:16.030 --> 00:32:18.970
that information may be out of date.

00:32:19.250 --> 00:32:22.600
In that case, you will want to slow sync.

00:32:22.740 --> 00:32:25.100
When you slow sync,
you basically give all of

00:32:25.180 --> 00:32:30.100
your records to Sync Services,
and we figure out what's changed.

00:32:30.100 --> 00:32:33.710
You remember in the client state,
we store a complete copy of all of

00:32:33.880 --> 00:32:38.000
the records that we knew to be on
your device or in your application

00:32:38.260 --> 00:32:40.100
the last time we synchronized.

00:32:40.100 --> 00:32:44.300
When you give us all of the records,
we basically go through and

00:32:44.300 --> 00:32:47.940
we check off the records in
the client store one by one.

00:32:48.200 --> 00:32:51.920
Anything left in the client store
afterwards is a record that used to

00:32:51.920 --> 00:32:55.800
be in your client but isn't anymore,
and we will generate a

00:32:55.800 --> 00:32:57.790
delete for those records.

00:32:58.180 --> 00:33:01.100
And that's a very important
point to keep in mind.

00:33:01.150 --> 00:33:04.040
When you slow sync,
you tell us about everything,

00:33:04.140 --> 00:33:07.850
we figure out what the changes are,
and delete the records that you

00:33:07.850 --> 00:33:09.780
didn't tell us about anymore.

00:33:09.960 --> 00:33:13.430
Sometimes bad things happen.

00:33:13.450 --> 00:33:15.600
A device can be reset.

00:33:15.640 --> 00:33:19.020
The user can accidentally
delete your data store.

00:33:19.270 --> 00:33:23.160
If you were to slow sync at that point,
what would happen is this.

00:33:23.190 --> 00:33:25.680
We knew you had all of
these records before.

00:33:25.780 --> 00:33:27.840
Now you tell us you've got nothing.

00:33:27.870 --> 00:33:29.870
You must have deleted everything.

00:33:30.010 --> 00:33:32.240
So we delete everything in the truth.

00:33:32.270 --> 00:33:33.540
.Mac synchronizes.

00:33:33.630 --> 00:33:35.830
We delete everything on .Mac.

00:33:35.970 --> 00:33:38.970
By the time you get home,
all your data's gone.

00:33:39.160 --> 00:33:42.600
I'm sure this has happened
to some of you in the past.

00:33:43.260 --> 00:33:48.100
In this case,
what you want to do is do a refresh sync.

00:33:48.360 --> 00:33:51.530
When you do a refresh sync,
we throw away everything

00:33:51.530 --> 00:33:52.600
in the client store.

00:33:52.600 --> 00:33:54.970
We forget everything
we ever knew about you,

00:33:55.020 --> 00:33:58.100
and we go through this
process of rediscovery.

00:33:58.100 --> 00:34:00.010
You give us all of your records.

00:34:00.190 --> 00:34:02.070
We're going to pass those
into the sync server.

00:34:02.120 --> 00:34:03.990
We're going to let him figure out.

00:34:04.130 --> 00:34:08.140
He's going to take each of those records,
compare them to existing records in

00:34:08.140 --> 00:34:10.080
the truth to try to find a match.

00:34:10.200 --> 00:34:13.260
No deletes will be generated,
but what will happen is anything in

00:34:13.260 --> 00:34:16.760
the truth that you didn't give us is
going to come back to you at that point.

00:34:17.100 --> 00:34:22.010
So if your data store has been reset,
if your device has been erased,

00:34:22.010 --> 00:34:26.740
you need to be able to tell us that
so that we can do a refresh sync.

00:34:27.420 --> 00:34:31.420
We also have this notion of
pushing and pulling the truth.

00:34:31.470 --> 00:34:35.600
There are times where a user just wants
to erase everything on a device or

00:34:35.600 --> 00:34:39.400
an application or a computer and say,
replace it with the

00:34:39.400 --> 00:34:41.110
contents of this computer.

00:34:41.150 --> 00:34:43.000
I've got all of these
contacts in address book.

00:34:43.170 --> 00:34:44.640
I know they're in a good state.

00:34:44.720 --> 00:34:47.120
I want all of those on my phone.

00:34:47.170 --> 00:34:49.600
That's a mode that we
call pulling the truth.

00:34:49.690 --> 00:34:53.240
What happens when you pull the truth
is we expect you to delete all of

00:34:53.240 --> 00:34:56.880
the records in your client's data
store and replace them with the

00:34:56.880 --> 00:34:59.910
records that Sync Services gives you.

00:35:00.070 --> 00:35:03.420
The converse to this
is pushing the truth.

00:35:03.480 --> 00:35:05.980
When you push the truth,
what you're saying is,

00:35:05.980 --> 00:35:10.190
I've got a known good state in
this specific client here that

00:35:10.190 --> 00:35:14.900
I want to replicate everywhere,
through .Mac to all my other computers,

00:35:14.950 --> 00:35:19.080
to all of my other devices,
and to all of my other applications.

00:35:19.220 --> 00:35:22.810
When one client is pushing the truth,
Sync Services will tell all

00:35:22.870 --> 00:35:25.780
other clients to pull the truth.

00:35:25.830 --> 00:35:28.150
This is a very destructive operation.

00:35:28.200 --> 00:35:32.090
So you only want the user
to initiate this operation.

00:35:32.230 --> 00:35:35.970
Clients themselves should
never try to push the truth.

00:35:36.820 --> 00:35:39.540
Now that being said,
none of these sync modes are actually

00:35:39.540 --> 00:35:42.380
reflected directly in the API.

00:35:42.480 --> 00:35:44.330
Instead,
what we did was we looked at these and

00:35:44.360 --> 00:35:48.700
said there's a lot of commonality between
all of these different sync modes.

00:35:48.900 --> 00:35:52.690
When you're slow syncing or refresh
syncing or pushing the truth,

00:35:52.690 --> 00:35:56.860
we want you to push all of your
records out into Sync Services.

00:35:56.860 --> 00:35:59.540
In some cases,
when you're pulling the truth,

00:35:59.540 --> 00:36:01.860
we don't want you to push any records.

00:36:01.860 --> 00:36:05.330
Sometimes we don't want you
to pull any records at all.

00:36:05.350 --> 00:36:08.330
And so what we've done in
the API is we've focused in

00:36:08.330 --> 00:36:12.100
on those specific actions,
and we've oriented our

00:36:12.100 --> 00:36:14.360
API around those actions.

00:36:14.390 --> 00:36:16.820
So don't be surprised if you go
looking in the API and you don't

00:36:16.820 --> 00:36:21.050
see fast sync or slow sync or
refresh sync mentioned anywhere.

00:36:21.120 --> 00:36:23.730
It's the concepts that are important.

00:36:24.820 --> 00:36:27.540
So let's come back to
pushing changes now.

00:36:27.590 --> 00:36:30.540
You've got a choice when
you push your changes.

00:36:30.540 --> 00:36:33.690
First thing you're going to do is
you're going to ask Sync Services,

00:36:33.820 --> 00:36:37.180
should I push all of my records,
or can we fast sync here?

00:36:37.240 --> 00:36:40.300
If you can fast sync,
then we only want you to tell us about

00:36:40.400 --> 00:36:44.470
the records that have been added,
modified, or removed since the last

00:36:44.660 --> 00:36:46.500
time you synchronized.

00:36:46.570 --> 00:36:48.640
You've got a choice here too.

00:36:48.680 --> 00:36:49.890
You can do the hard work.

00:36:50.130 --> 00:36:53.320
If you know what specific
fields have changed,

00:36:53.370 --> 00:36:54.010
you can tell us.

00:36:54.170 --> 00:36:56.380
We just changed the
first name on this guy,

00:36:56.590 --> 00:36:58.430
we deleted this record,
and we changed the

00:36:58.460 --> 00:37:00.880
company name on this guy.

00:37:00.930 --> 00:37:04.850
Alternatively, if you don't want to go to
all of that extra effort,

00:37:05.040 --> 00:37:08.300
you can just give us the whole record,
and we'll figure out what's

00:37:08.300 --> 00:37:12.210
happened by pulling the information
out of the client state there.

00:37:12.410 --> 00:37:15.990
We're going to package those
things up and push the field level

00:37:15.990 --> 00:37:19.350
differences over to the Sync Server.

00:37:20.920 --> 00:37:25.140
So what happens if something
goes wrong right now?

00:37:25.180 --> 00:37:28.430
You're in the middle of pushing
all of your changes and the

00:37:28.440 --> 00:37:32.540
device runs out of battery,
or your application crashes,

00:37:32.580 --> 00:37:36.990
or God forbid, Sync Services crashes and
takes you down with it.

00:37:37.180 --> 00:37:39.560
What happens at this point?

00:37:39.650 --> 00:37:45.290
When you first start pushing changes,
we create an implicit transaction scope.

00:37:45.770 --> 00:37:48.820
All of the changes that you
push are going to fall into

00:37:48.930 --> 00:37:52.080
that transaction scope,
which is closed when you tell us,

00:37:52.080 --> 00:37:52.600
"I'm done.

00:37:52.600 --> 00:37:55.740
I've got no more changes for
you." And we ship the whole

00:37:55.740 --> 00:37:57.600
thing off to the Sync Server.

00:37:57.740 --> 00:38:01.550
If something goes wrong in the
middle of that transaction scope,

00:38:01.690 --> 00:38:04.040
we're going to unwind the whole thing.

00:38:04.100 --> 00:38:05.540
We're going to roll them back.

00:38:05.670 --> 00:38:07.580
We're going to forget all
of the changes you made.

00:38:07.600 --> 00:38:10.410
The next time you synchronize,
if you're smart enough

00:38:10.530 --> 00:38:13.210
to be able to figure out,
"Well, I was halfway through

00:38:13.210 --> 00:38:16.760
pushing at that point,
so I need to re-push all of those

00:38:16.760 --> 00:38:20.590
changes again," then by all means,
go ahead and fast sync.

00:38:20.600 --> 00:38:23.720
It might be safer to
slow sync at that point,

00:38:23.720 --> 00:38:24.600
however.

00:38:24.600 --> 00:38:28.110
You can tell the engine,
"I'm just going to give you everything.

00:38:28.190 --> 00:38:30.140
You figure out what's changed."

00:38:30.840 --> 00:38:35.370
Now, some of you might be wondering,
why do they roll back all of the

00:38:35.440 --> 00:38:36.970
changes that we've already given them?

00:38:37.080 --> 00:38:39.140
Why don't they just take
what we've given them,

00:38:39.330 --> 00:38:43.170
process them at that point,
and we'll pick up where we left off?

00:38:43.550 --> 00:38:48.140
The problem is that when you introduce
relationships into the question,

00:38:48.170 --> 00:38:51.580
there's a whole set of data
integrity issues that come up,

00:38:51.600 --> 00:38:53.010
that come into play.

00:38:53.210 --> 00:38:55.690
You might have pushed a couple
of records in that refer to some

00:38:55.690 --> 00:38:59.640
records that haven't been pushed yet,
because the device ran out of batteries,

00:38:59.640 --> 00:39:01.690
so you couldn't get those records.

00:39:01.840 --> 00:39:04.960
And so we erred on the side of safety,
and just said,

00:39:05.040 --> 00:39:08.740
we're going to replay the whole thing
to get back to a known good state.

00:39:08.780 --> 00:39:13.130
What we want to do is protect
the data in the truth.

00:39:14.240 --> 00:39:17.740
Mingling is the heart of Sync.

00:39:17.880 --> 00:39:21.100
This is where we take all of the
changes from all of the clients

00:39:21.100 --> 00:39:23.930
and we merge them into the truth.

00:39:23.930 --> 00:39:28.520
We process the changes on
a client by client basis.

00:39:28.610 --> 00:39:30.900
So we take all of the
changes from address book,

00:39:30.900 --> 00:39:32.140
we merge them into the truth.

00:39:32.140 --> 00:39:35.190
Take all of the changes from .Mac,
merge them in.

00:39:35.210 --> 00:39:38.380
All of the changes from the phone,
and merge them in.

00:39:38.380 --> 00:39:41.500
It's here that we do
our conflict detection.

00:39:41.500 --> 00:39:47.480
If a phone has changed the first name,
and the first name has also changed on

00:39:47.480 --> 00:39:51.140
.Mac since the last time it synchronized,
we need to generate a

00:39:51.140 --> 00:39:53.330
conflict at that point.

00:39:54.280 --> 00:39:58.580
Again, let's ask the question,
what happens if something goes bad here?

00:39:58.650 --> 00:40:01.150
The answer is,
you don't have to worry about it.

00:40:01.540 --> 00:40:03.100
That's our problem.

00:40:03.170 --> 00:40:05.310
Once those changes have
been handed off to us,

00:40:05.400 --> 00:40:06.980
we're responsible for them.

00:40:07.080 --> 00:40:09.650
We will make sure they
get into the truth,

00:40:09.650 --> 00:40:12.930
or we will take steps to recover
by asking for all records

00:40:13.030 --> 00:40:15.030
from all of the clients again.

00:40:16.840 --> 00:40:21.080
Again, let's ask the question,
what happens if something goes bad here?

00:40:21.080 --> 00:40:23.700
The answer is,
you don't have to worry about it.

00:40:23.860 --> 00:40:25.600
That's our problem.

00:40:25.600 --> 00:40:27.900
Once those changes have
been handed off to us,

00:40:27.900 --> 00:40:29.700
we're responsible for them.

00:40:29.700 --> 00:40:32.140
We will make sure they
get into the truth,

00:40:32.290 --> 00:40:35.430
or we will take steps to recover
by asking for all records

00:40:35.630 --> 00:40:37.540
from all of the clients again.

00:40:47.420 --> 00:40:50.480
So, we're going to use the schema
bundle to specify some code

00:40:50.480 --> 00:40:53.800
that gets loaded into the Sync
Server to handle those conflicts.

00:40:53.880 --> 00:40:55.350
He gets first crack at them.

00:40:55.530 --> 00:40:58.600
When we detect a conflict,
we're going to ask this code,

00:40:58.670 --> 00:40:59.570
can you deal with this?

00:40:59.750 --> 00:41:03.340
If he says yes,
we'll merge the response into the truth.

00:41:03.410 --> 00:41:06.780
If he says no, we're going to store the
conflict off on the side.

00:41:06.780 --> 00:41:11.870
We don't want to pop a panel up in the
user's face right in the middle of sync.

00:41:12.030 --> 00:41:15.290
Remember, applications and things can
be synchronizing at any time,

00:41:15.340 --> 00:41:18.260
and having panels popping up saying,
what do you want to do about this?

00:41:18.410 --> 00:41:19.430
What do you want to do about this?

00:41:19.430 --> 00:41:22.120
It's going to get really
stale really quickly.

00:41:22.930 --> 00:41:26.060
Instead, what we do is we save the
conflicted records off to the side,

00:41:26.090 --> 00:41:31.240
and we notify the user through a little
UI element that he's got some conflicts.

00:41:31.360 --> 00:41:33.160
We need his attention.

00:41:33.160 --> 00:41:37.000
And when the user's ready,
they can pull those conflicts

00:41:37.000 --> 00:41:40.280
up and resolve them,
and they'll be merged in the

00:41:40.280 --> 00:41:42.470
next time they synchronize.

00:41:43.510 --> 00:41:46.640
Pulling changes is pretty
much the easy part.

00:41:46.800 --> 00:41:50.570
Clients pull changes directly
from the truth database.

00:41:50.710 --> 00:41:53.900
They don't pull them
from the Sync Server.

00:41:54.110 --> 00:41:56.140
Once the Sync Server has
finished mingling,

00:41:56.320 --> 00:41:57.520
he's done.

00:41:57.630 --> 00:42:01.990
He's off, and someone else can come in
and synchronize at that point.

00:42:02.120 --> 00:42:04.900
What we do is we maintain a
snapshot of the truth database

00:42:05.020 --> 00:42:07.140
for some self-consistency there.

00:42:07.360 --> 00:42:10.900
It's held as long as clients
are pulling truth out of it.

00:42:11.090 --> 00:42:13.080
When you're getting
changes out of the truth,

00:42:13.190 --> 00:42:14.500
you have a choice.

00:42:14.580 --> 00:42:15.930
We give you both the deltas.

00:42:16.210 --> 00:42:18.180
We also give you the full record.

00:42:18.270 --> 00:42:19.340
So you can go in and look.

00:42:19.640 --> 00:42:22.380
Did I change just the first
name or the last name?

00:42:22.460 --> 00:42:25.430
Or you can take the whole
record and push it onto the

00:42:25.430 --> 00:42:27.980
device or into your application.

00:42:28.180 --> 00:42:31.660
You can filter out records
that you don't want.

00:42:31.820 --> 00:42:33.220
There's two ways this can be done.

00:42:33.410 --> 00:42:36.320
We can give you all of the records,
and you can tell us, I want this one,

00:42:36.320 --> 00:42:38.360
I want this one, I don't want this one.

00:42:38.510 --> 00:42:41.560
Sometimes it's much easier if
you just write a little filter

00:42:41.960 --> 00:42:46.070
independently that's loaded into sync
services that does that filtering

00:42:46.230 --> 00:42:50.140
for you so that you only get the
records that you're concerned with.

00:42:50.140 --> 00:42:54.380
For example,
in the phone device configuration UI,

00:42:54.380 --> 00:42:58.360
I might want to specify I'm only
going to synchronize contacts

00:42:58.450 --> 00:43:00.380
in this one specific group.

00:43:00.380 --> 00:43:03.260
We've got some standard
filters for that kind of thing.

00:43:03.420 --> 00:43:08.060
And so your UI can say,
let's use this filter for this client.

00:43:08.060 --> 00:43:10.240
That gets loaded into sync services.

00:43:10.380 --> 00:43:12.500
It gets rid of the records
that we don't want.

00:43:12.500 --> 00:43:17.600
And only gives to the client the
records that pass through that filter.

00:43:18.850 --> 00:43:22.410
When the engine gives you a new record,
we're going to make up

00:43:22.540 --> 00:43:23.890
an ID for that record.

00:43:23.990 --> 00:43:27.700
The reason is that there may be
relationships referring to that guy.

00:43:27.700 --> 00:43:29.700
We need to know what to call him.

00:43:29.840 --> 00:43:33.020
We're going to use a UUID for that,
but that may not always

00:43:33.020 --> 00:43:34.510
be convenient for you.

00:43:34.510 --> 00:43:39.160
If you're going to push a record onto a
phone or store it in your own database,

00:43:39.160 --> 00:43:42.650
you probably want to use
your own identifier for that.

00:43:42.730 --> 00:43:45.700
And so record identifiers can be changed.

00:43:46.260 --> 00:43:50.380
Any earlier references in a relationship
that we've already given to you,

00:43:50.490 --> 00:43:52.260
we can't change those, of course.

00:43:52.260 --> 00:43:57.700
But once you change a record identifier,
any references that we give you after

00:43:58.080 --> 00:44:01.000
that will use the new record identifier.

00:44:02.330 --> 00:44:06.430
Sync Services uses a two-phase
commit process at this point.

00:44:06.650 --> 00:44:10.790
Again, to answer the question,
what happens if something goes wrong?

00:44:10.790 --> 00:44:15.910
By two-phase commit, in this case,
I mean when the engine

00:44:15.910 --> 00:44:18.830
gives you a record,
you tell the engine, yes,

00:44:19.020 --> 00:44:22.610
I want this record, or no,
I don't want this record.

00:44:22.620 --> 00:44:24.820
Up to you to decide,
but you've got to tell

00:44:24.860 --> 00:44:26.200
us one way or another.

00:44:26.200 --> 00:44:29.680
If you don't tell us that you
accepted or rejected a record,

00:44:29.720 --> 00:44:32.160
we're going to give it
to you on the next sync.

00:44:32.220 --> 00:44:36.750
and the next sync until you tell
us what to do with that record.

00:44:37.630 --> 00:44:43.490
Now, if you're talking to a low latency
device over a USB connection to a phone,

00:44:43.500 --> 00:44:47.740
over a dial-up connection to a server,
it's not going to be terribly efficient

00:44:47.740 --> 00:44:50.900
if you have to push the record
and then tell us you accepted it,

00:44:51.040 --> 00:44:53.580
and push the record and tell us, yes,
it made it there, okay.

00:44:53.580 --> 00:44:56.780
And so we allow you to
do this batching process.

00:44:56.780 --> 00:44:59.870
What you can do is just tell
us you accepted a record,

00:44:59.870 --> 00:45:02.300
got this one, got this one, thanks.

00:45:02.300 --> 00:45:05.860
And then you tell us,
I've committed the records that

00:45:05.860 --> 00:45:10.280
I told you I accepted or Now,
if you're talking to a low latency

00:45:10.350 --> 00:45:15.580
device over a USB connection to a phone,
over a dial-up connection to a server,

00:45:15.690 --> 00:45:18.740
it's not going to be terribly efficient
if you have to push the record

00:45:18.910 --> 00:45:22.120
and then tell us you accepted it,
and push the record and tell us, yes,

00:45:22.120 --> 00:45:23.580
it made it there, okay.

00:45:23.580 --> 00:45:25.750
And so we allow you to
do this batching process.

00:45:25.750 --> 00:45:25.750
What you can do is just tell
us you accepted a record,

00:45:25.750 --> 00:45:25.750
got this one, got this one, thanks.

00:45:25.750 --> 00:45:25.750
And then you tell us,
I've committed the records

00:45:25.750 --> 00:45:25.750
that I told you I accepted or

00:45:26.190 --> 00:45:32.300
What happens if something goes bad is we
unwind that implicit transaction scope.

00:45:32.530 --> 00:45:36.690
When you first start pulling changes,
we create a new transaction.

00:45:36.860 --> 00:45:40.560
As you accept and reject changes,
we write them into the transaction.

00:45:40.910 --> 00:45:43.530
And when you commit
those acknowledgements,

00:45:43.650 --> 00:45:47.370
we commit and close that transaction
and implicitly create a new one.

00:45:59.750 --> 00:45:59.760
So if something bad happens,
we're going to unroll back

00:45:59.760 --> 00:45:59.760
to the last time you called,
committed those changes,

00:45:59.760 --> 00:45:59.760
last time you told us you
committed those changes,

00:45:59.760 --> 00:45:59.760
and we're going to give them
to you on the next sync.

00:46:01.360 --> 00:46:05.760
So the five phases of sync,
you can think of them as

00:46:05.920 --> 00:46:08.030
a finite state machine.

00:46:08.260 --> 00:46:13.270
The phases must be traversed in order,
but they can be canceled

00:46:13.270 --> 00:46:15.690
or finished at any time.

00:46:16.910 --> 00:46:22.220
The typical application sync model
that we recommend for people is this.

00:46:22.290 --> 00:46:25.140
When you first launch,
do a sync to pick up any changes

00:46:25.140 --> 00:46:29.100
that have been made since the last
time your application was run.

00:46:29.130 --> 00:46:30.810
Do it in the background.

00:46:30.810 --> 00:46:34.840
Again, remember to maintain
application responsiveness.

00:46:35.030 --> 00:46:38.850
We give you the methods to query
whether you need to slow sync,

00:46:38.850 --> 00:46:43.600
or we can tell you whether you think
a sync is going to take a long time.

00:46:43.600 --> 00:46:46.870
If so,
pop up a panel to the user and say, "Hey,

00:46:46.900 --> 00:46:48.580
this may take a long time.

00:46:48.580 --> 00:46:52.380
Do you want to do this now?" Or if you're
going to be even more sophisticated,

00:46:52.630 --> 00:46:55.080
just do the sync in the
background and let the user

00:46:55.080 --> 00:46:57.660
carry on with the app normally.

00:46:57.660 --> 00:47:01.540
As they make changes throughout
the course of the application,

00:47:01.590 --> 00:47:05.020
trickle sync periodically
to push those changes out.

00:47:05.030 --> 00:47:09.220
When you save to disk,
do a sync to get the changes out.

00:47:09.230 --> 00:47:13.140
When you quit,
what we want is to get those changes

00:47:13.140 --> 00:47:15.480
out to the sync engine again.

00:47:16.200 --> 00:47:20.100
You don't necessarily at that point want
to wait for the whole sync to complete.

00:47:20.100 --> 00:47:21.320
The user's quitting.

00:47:21.370 --> 00:47:23.640
You want to get out of there
as quickly as possible.

00:47:23.770 --> 00:47:27.770
What you can do is create a session,
push your changes, and then finish it.

00:47:27.770 --> 00:47:28.720
You're done.

00:47:28.830 --> 00:47:30.540
You don't have to wait for the mingling.

00:47:30.540 --> 00:47:32.480
You're definitely not going to pull
any changes at that point because

00:47:32.570 --> 00:47:34.340
they're quitting the application.

00:47:34.490 --> 00:47:36.280
They don't need it.

00:47:37.400 --> 00:47:40.540
The device has got a much simpler model,
typically.

00:47:40.570 --> 00:47:44.300
When a user initiates a sync,
there's an explicit action on

00:47:44.420 --> 00:47:46.070
the part of the user there.

00:47:46.200 --> 00:47:49.120
The device is plugged in,
they hit the hot sync button,

00:47:49.200 --> 00:47:52.780
a sync alert comes in because some
other device is synchronizing.

00:47:52.980 --> 00:47:55.850
Just go through the
whole sync at that point.

00:47:57.650 --> 00:48:00.130
So let's talk a little bit about the API.

00:48:00.480 --> 00:48:03.400
What I'm going to do here is not
actually get into the details.

00:48:03.450 --> 00:48:07.490
As I said, we've got some great reference
documentation on the Tiger DVD.

00:48:07.710 --> 00:48:09.880
What I want to do is just
give you a roadmap to some of

00:48:09.970 --> 00:48:11.520
the more important classes.

00:48:12.750 --> 00:48:18.110
Now, the API is Cocoa-based,
but it's procedurally oriented

00:48:18.260 --> 00:48:20.060
for a number of reasons.

00:48:20.470 --> 00:48:32.690
What this means is it's
easily wrapped in Java.

00:48:32.690 --> 00:48:32.690
I've got a lot of experience doing that,
so we kept that in mind

00:48:32.690 --> 00:48:32.690
while designing this API.

00:48:32.690 --> 00:48:32.690
You can also use it easily from C.

00:48:32.890 --> 00:48:36.280
We support almost all of
the core foundation types,

00:48:36.290 --> 00:48:39.120
the core foundation
toll-free bridge types.

00:48:39.190 --> 00:48:43.480
Most of the more important data
types are toll-free bridge types.

00:48:43.580 --> 00:48:47.960
And so again,
using this from Carbon is no problem.

00:48:48.540 --> 00:48:51.400
There are five classes
that we're interested in:

00:48:51.470 --> 00:48:56.900
iSync Manager, iSync Client,
iSync Session, iSync Change,

00:48:57.020 --> 00:48:59.270
and the Record Snapshot.

00:48:59.650 --> 00:49:01.600
I-Sync Manager is the singleton object.

00:49:01.600 --> 00:49:05.600
He is your basic administrative
point of contact there.

00:49:05.700 --> 00:49:07.550
He's where you go to
register your schemas.

00:49:07.620 --> 00:49:09.500
He's where you go to
register your clients.

00:49:09.590 --> 00:49:12.600
He's where you go to look up the
clients that have been registered.

00:49:12.600 --> 00:49:15.580
Not a lot to him there.

00:49:16.000 --> 00:49:21.100
iSync Client represents a
registered device or application.

00:49:21.300 --> 00:49:23.100
This is where you can get information.

00:49:23.100 --> 00:49:27.120
The identifier, the display name,
the image of the guy,

00:49:27.270 --> 00:49:30.000
what entities does he support,
how is he going to sync.

00:49:30.020 --> 00:49:33.050
I want him to reset
the next time he syncs.

00:49:33.050 --> 00:49:35.880
You can specify how he's
going to synchronize.

00:49:35.880 --> 00:49:39.420
And use iSync Client to set
up sync alerts to specify,

00:49:39.580 --> 00:49:42.810
I want this tool to be
launched when these kinds of

00:49:42.810 --> 00:49:45.270
clients start synchronizing.

00:49:47.200 --> 00:49:52.600
An iSync session encapsulates the whole
sync process that we just talked about.

00:49:52.690 --> 00:49:56.100
He's got all of the methods to walk
you through the state machine there.

00:49:56.210 --> 00:49:58.300
He's got the methods that
you can use to query,

00:49:58.300 --> 00:49:59.530
how should I sync?

00:49:59.570 --> 00:50:03.350
He's got the methods to allow
you to pull the changes out,

00:50:03.350 --> 00:50:05.490
to accept them, and to commit them.

00:50:05.800 --> 00:50:09.100
And the key point to know
here is that there is only

00:50:09.270 --> 00:50:12.990
one sync session per client,
per machine allowed.

00:50:13.090 --> 00:50:15.490
We've got a Sync Serve that's
going to gate that,

00:50:15.490 --> 00:50:19.160
and we will not let the same
client sync multiple times.

00:50:19.190 --> 00:50:24.660
So you don't have to worry about
preserving that kind of semantics.

00:50:25.140 --> 00:50:30.560
An iSync change encapsulates all
of the changes to a single record.

00:50:30.740 --> 00:50:33.500
The change specifies
whether it's a new record,

00:50:33.500 --> 00:50:38.000
an existing record being modified,
or a record being deleted.

00:50:38.180 --> 00:50:43.000
And he contains all of the field
level changes to that specific record.

00:50:43.220 --> 00:50:48.000
The changes that you get from the Sync
Server will contain those field deltas.

00:50:48.000 --> 00:50:51.000
It will also contain a
full copy of the record.

00:50:51.000 --> 00:50:54.890
If you're smart enough to be able to
tell the Sync Server what the field

00:50:54.890 --> 00:50:58.950
level changes are to your records,
you can create one of these.

00:50:58.990 --> 00:51:02.000
You only need to specify
the field level deltas.

00:51:02.000 --> 00:51:05.380
You don't need to give
us the whole record.

00:51:06.300 --> 00:51:57.800
[Transcript missing]

00:51:59.530 --> 00:52:01.620
The times where you might
want to use the snapshot,

00:52:01.770 --> 00:52:07.060
for example, are to give you an example,
in the case of a phone that's

00:52:07.120 --> 00:52:09.400
synchronizing calendar events.

00:52:09.540 --> 00:52:13.840
A phone doesn't actually synchronize
the calendar lists themselves.

00:52:14.410 --> 00:52:17.290
And yet,
when you create an event on the phone,

00:52:17.390 --> 00:52:20.300
it has to be filed in some calendar.

00:52:20.400 --> 00:52:22.380
So there's a bit of a paradox here.

00:52:22.920 --> 00:52:26.310
What you can do is you can use
the snapshot to get the list

00:52:26.310 --> 00:52:28.710
of calendars out of the truth.

00:52:28.710 --> 00:52:33.710
You can let the user in the configuration
UI choose a specific calendar

00:52:33.710 --> 00:52:36.200
and remember the ID of that guy.

00:52:36.200 --> 00:52:39.490
And when your device,
when your client is pushing those new

00:52:39.490 --> 00:52:43.510
calendar events into Sync Services,
you just set up a relation saying,

00:52:43.510 --> 00:52:47.730
this guy belongs in this calendar,
even though you're not syncing him.

00:52:48.460 --> 00:52:52.300
One thing to note is that the
truth database is organized

00:52:52.300 --> 00:52:56.820
to be efficient for sync,
not efficient necessarily for you.

00:52:56.840 --> 00:53:01.180
So don't use this too often as
a general purpose database API.

00:53:01.180 --> 00:53:04.770
You'll find the results a bit
disappointing in that respect.

00:53:06.330 --> 00:53:08.310
So let's have a quick recap.

00:53:08.510 --> 00:53:09.820
What do you do?

00:53:10.030 --> 00:53:13.700
You register your schemas,
you register your clients,

00:53:13.760 --> 00:53:17.110
you push data into Sync Services,
you pull your changes

00:53:17.180 --> 00:53:20.440
out of Sync Services,
and you provide the UI to

00:53:20.440 --> 00:53:22.700
configure your client.

00:53:22.770 --> 00:53:24.560
We take care of all of the rest.

00:53:24.620 --> 00:53:27.600
We synchronize your data,
we detect conflicts,

00:53:27.600 --> 00:53:31.890
and we provide a standard UI for
the user to resolve those conflicts.

00:53:32.080 --> 00:53:35.600
We give you an airbag to
preserve the data integrity,

00:53:35.700 --> 00:53:39.270
and we provide a .Mac
client to synchronize data

00:53:39.270 --> 00:53:41.390
between multiple machines.

00:53:42.010 --> 00:53:46.700
The design goals that underlie
everything that we've done with Sync.

00:53:46.840 --> 00:53:47.720
Decoupled.

00:53:48.050 --> 00:53:52.500
Decoupled clients,
schemas separate from the applications.

00:53:52.600 --> 00:53:57.570
Extensible schemas,
and Syncs must be invisible.

00:53:59.030 --> 00:54:01.700
Now, if you have questions,
you can contact

00:54:01.900 --> 00:54:05.020
Patrick Collins or Xavier,
and we definitely

00:54:05.020 --> 00:54:07.080
encourage you to file bugs.

00:54:07.380 --> 00:54:10.410
Radar is our friend in that respect.

00:54:10.830 --> 00:54:14.380
For more information,
we've got a lot of great documentation.

00:54:14.630 --> 00:54:17.570
The reference documentation
is on your Tiger DVD.

00:54:17.570 --> 00:54:21.700
It's also available on connect.apple.com.

00:54:21.910 --> 00:54:25.700
The concept documentation,
which I highly recommend you read,

00:54:25.700 --> 00:54:27.540
some great docs there,
is only available on

00:54:27.600 --> 00:54:28.690
the web at this point.

00:54:28.690 --> 00:54:31.480
We didn't manage to get it onto the DVD.

00:54:31.700 --> 00:54:35.700
And we've got some sample code
for some sample applications.

00:54:35.700 --> 00:54:40.640
It's in the usual place,
in Developer Examples, Sync Services.
WEBVTT

00:00:12.900 --> 00:00:13.800
Good morning.

00:00:13.800 --> 00:00:20.140
It's a pleasure to start the
OS Foundation track this year with

00:00:20.140 --> 00:00:25.800
a talk entitled Beyond Syslog:
The New Log Subsystem.

00:00:25.800 --> 00:00:29.230
We have a couple of interesting
things planned for logging,

00:00:29.230 --> 00:00:31.800
although they may look rather small.

00:00:31.910 --> 00:00:35.800
They're things that we'd like to
be able to leverage in the future.

00:00:35.800 --> 00:00:37.790
Unfortunately,
I have a confession to make.

00:00:37.810 --> 00:00:40.470
If you wanted to go ahead and
use the technology I'm presenting

00:00:40.510 --> 00:00:43.800
today to make a new dashboard
widget to win the competition,

00:00:43.810 --> 00:00:48.780
the APIs that we have to show you
today aren't actually on the CD,

00:00:48.800 --> 00:00:52.790
but will be coming sometime
before Tiger actually ships.

00:00:53.740 --> 00:00:56.380
So my name is Nicolai Krakoviak,
as I've been introduced,

00:00:56.440 --> 00:00:57.610
BSD Technology Group.

00:00:57.740 --> 00:01:02.870
And first I'd like to start
with a background on syslog,

00:01:02.870 --> 00:01:06.240
what it is, what it does,
what it does well,

00:01:06.240 --> 00:01:07.740
and what it does not so well.

00:01:07.740 --> 00:01:11.450
And then also do a little
bit on the motivations on why

00:01:11.450 --> 00:01:15.870
we're actually planning to do
a new logging infrastructure,

00:01:15.870 --> 00:01:18.730
again from some of syslog's
sort of deficiencies.

00:01:18.740 --> 00:01:22.730
There's a little bit on system
administration beyond just logging,

00:01:23.010 --> 00:01:28.030
plans that Apple has for the future,
for different things that Unix

00:01:28.060 --> 00:01:30.740
administrators have been asking for.

00:01:30.870 --> 00:01:34.020
And by the end of the talk,
you'll be able to have a

00:01:34.070 --> 00:01:37.740
little familiarity with the
API that we're planning,

00:01:37.740 --> 00:01:40.140
how to write log messages,
how to actually search

00:01:40.140 --> 00:01:43.610
through the log messages,
and best practices for

00:01:43.610 --> 00:01:45.340
when and what to log.

00:01:45.800 --> 00:01:48.300
So what is syslog?

00:01:48.300 --> 00:01:53.610
Well, in a world without syslog,
you just open up a file and

00:01:53.800 --> 00:01:55.520
start printing records to it.

00:01:55.580 --> 00:02:00.520
But what the syslog provides
you is a system-based facility

00:02:00.520 --> 00:02:04.680
for being able to do all of your
logging through a central point.

00:02:04.680 --> 00:02:10.250
This allows a lot of configurability
and allows for messages not to be

00:02:10.250 --> 00:02:14.430
scattered all over your system,
so you don't have each application

00:02:14.430 --> 00:02:18.220
writing individual log files to
various separate directories.

00:02:18.220 --> 00:02:21.610
So by having the centralized facility,
we can then gain other

00:02:21.610 --> 00:02:24.560
functionality in addition to printf.

00:02:24.560 --> 00:02:26.760
Things like being able
to tag priority messages.

00:02:26.760 --> 00:02:31.670
So a message like "my printer is
on fire" is very different from "I

00:02:31.670 --> 00:02:35.990
just opened up a TCP connection."
And to be able to differentiate

00:02:36.000 --> 00:02:37.960
between those is very useful.

00:02:37.960 --> 00:02:39.740
You can also do simple log filtering.

00:02:39.750 --> 00:02:42.950
Based on these priorities,
you can specify separate log

00:02:42.980 --> 00:02:45.800
files that get the messages.

00:02:45.800 --> 00:02:49.980
Things like system.log and varlog
gets the majority of the data,

00:02:49.980 --> 00:02:52.960
but you can also do things like
authorization information with a

00:02:52.960 --> 00:02:59.030
slightly more secure file permissions,
or things like logging mail

00:02:59.030 --> 00:03:03.780
messages or FTP connections also
go to their own separate files.

00:03:03.780 --> 00:03:06.500
For extreme cases,
you can also write things

00:03:06.500 --> 00:03:07.910
directly to dev console.

00:03:07.910 --> 00:03:11.800
Again, like "my printer is on fire."
That might be a very important

00:03:11.800 --> 00:03:12.710
thing to keep in mind.

00:03:12.800 --> 00:03:15.530
So administrator can configure it
so it goes directly to a console as

00:03:15.530 --> 00:03:21.270
opposed to just a file so users are
more likely to see it immediately.

00:03:21.280 --> 00:03:25.240
Syslog also provides a basic
capability for remote logging.

00:03:25.240 --> 00:03:29.980
This unfortunately was designed back
in the heyday before denial of service

00:03:29.990 --> 00:03:32.700
attacks and our fancy encryption.

00:03:32.700 --> 00:03:35.600
So it's not necessarily the most secure.

00:03:35.600 --> 00:03:38.400
So it's not enabled by default,
but we're looking into

00:03:38.470 --> 00:03:40.560
possibly fixing that.

00:03:40.560 --> 00:03:42.780
So there are a number of
things that Syslog got right.

00:03:42.780 --> 00:03:46.660
A centralized logging facility to be
able to have a centralized mechanism

00:03:46.660 --> 00:03:49.100
for dealing with log messages.

00:03:49.100 --> 00:03:53.440
Being able to specify
log levels for messages,

00:03:53.440 --> 00:03:56.960
everything from debug through emergency.

00:03:56.990 --> 00:03:59.840
It provides a lightweight API,
so it's a very low barrier

00:03:59.840 --> 00:04:01.680
for entry for adoption.

00:04:01.680 --> 00:04:05.810
And you don't want logging to
be necessarily a difficult thing

00:04:05.920 --> 00:04:08.920
for your users to have to do.

00:04:08.950 --> 00:04:11.020
It's also very configurable.

00:04:11.020 --> 00:04:14.540
Being able to filter on
its priority and level.

00:04:14.560 --> 00:04:18.620
And also the ability to log
to those remote machines.

00:04:18.620 --> 00:04:22.200
But there are a few things that
we'd like to address with Syslog.

00:04:22.200 --> 00:04:24.480
It has no internationalization support.

00:04:24.480 --> 00:04:28.040
You can only log messages
with a subset of ASCII.

00:04:28.040 --> 00:04:30.990
This isn't very good for -- because
a number of languages are very

00:04:30.990 --> 00:04:33.460
difficult to represent in just ASCII.

00:04:33.460 --> 00:04:36.140
The messages are also
a little too simple.

00:04:36.140 --> 00:04:40.070
By only providing the timestamp
and priority and then a message,

00:04:40.070 --> 00:04:43.580
there are a lot more things about
a log message that you can insert

00:04:43.710 --> 00:04:46.980
that might be useful for a person who
wants to look at those log messages.

00:04:46.980 --> 00:04:51.240
While you can't add them just for
the log message string itself,

00:04:51.240 --> 00:04:53.420
then it exhibits another
problem with Syslog.

00:04:53.420 --> 00:04:56.420
It's got an unstructured format,
so it's difficult to parse,

00:04:56.560 --> 00:04:58.680
and it's also difficult to search.

00:04:58.680 --> 00:05:03.350
You just have to do things like using
grep and fancy sort of expressions

00:05:03.350 --> 00:05:05.150
to be able to get what you want.

00:05:05.590 --> 00:05:11.230
So our goals include adding a
structured log format to make

00:05:11.260 --> 00:05:15.140
searching much faster and easier,
and in particular for a

00:05:15.140 --> 00:05:19.260
programmatic perspective,
to be able to have rich data to be

00:05:19.260 --> 00:05:23.830
able to attach to these log messages
as a separate field so you can log

00:05:23.880 --> 00:05:27.780
things that won't necessarily just
appear through the log interface.

00:05:27.860 --> 00:05:30.060
Again, a lightweight API.

00:05:30.060 --> 00:05:34.140
We don't want to make it too complicated
for you to actually log your messages.

00:05:34.440 --> 00:05:37.790
And of course, backwards compatibility.

00:05:37.960 --> 00:05:39.810
If your program is written
today to use syslog,

00:05:39.810 --> 00:05:44.090
it should continue to
work into the future.

00:05:44.630 --> 00:05:46.940
Another thing,
integrated log file maintenance.

00:05:46.960 --> 00:05:51.860
Currently, log files are rotated by some
external application usually done

00:05:52.040 --> 00:05:53.760
through a cron-like mechanism.

00:05:53.760 --> 00:05:56.700
But cron really doesn't know a
whole lot about log messages.

00:05:56.790 --> 00:06:00.650
So it'd be really nice to be able to
move some of that functionality inward.

00:06:00.660 --> 00:06:04.420
And then extensible input
and output facilities.

00:06:04.460 --> 00:06:08.230
Be able to stay control whether
or not you get log messages from

00:06:08.230 --> 00:06:12.710
different available resources or
being able to specify some outputs.

00:06:12.750 --> 00:06:14.430
And I'll give some
examples of that later.

00:06:14.600 --> 00:06:17.730
For log file maintenance,
I think it would be really

00:06:17.770 --> 00:06:21.390
nice to be able to have
configurable log file expiration.

00:06:21.500 --> 00:06:25.780
So a system administrator can say,
keep all messages higher than warning.

00:06:25.880 --> 00:06:31.270
Those are going to be messages that
I want to archive well into the future.

00:06:31.460 --> 00:06:34.420
But I might only want to keep
the last 200 info messages.

00:06:34.510 --> 00:06:37.960
And those can be just as
a rotating sort of buffer.

00:06:38.060 --> 00:06:41.230
You might want to say,
don't keep debug messages

00:06:41.230 --> 00:06:44.540
from an app that continually
spews out into the system.

00:06:44.540 --> 00:06:47.140
log because they're just cluttering
up your logs and you don't

00:06:47.230 --> 00:06:49.360
find that information valuable.

00:06:49.690 --> 00:06:51.600
We're also thinking of things like,
you know,

00:06:51.600 --> 00:06:54.880
don't spin up the disk so you can
save battery life as opposed to having

00:06:54.880 --> 00:06:56.600
to write these log file messages.

00:06:56.600 --> 00:07:00.970
And then also I'd like to add like
filtering on compound expressions.

00:07:00.970 --> 00:07:03.450
So all of these sort
of rules can be have,

00:07:03.480 --> 00:07:05.600
you know, complicated things like,
you know,

00:07:05.600 --> 00:07:08.960
John that has a level greater than
notice you might want to do something

00:07:08.960 --> 00:07:14.430
special with or all of my log levels
yesterday that were of a warning level.

00:07:19.640 --> 00:07:22.760
Back to that input/output
thing I mentioned.

00:07:22.850 --> 00:07:28.920
The next generation syslog, ASL,
will have a syslogd module so it can

00:07:29.170 --> 00:07:33.840
handle input from all of the standard
interfaces that syslog expects them from,

00:07:34.000 --> 00:07:35.440
like devlog and such.

00:07:35.560 --> 00:07:39.360
Also, from UDP if you so wish to
enable that because you're

00:07:39.360 --> 00:07:41.940
dependent on that functionality.

00:07:41.960 --> 00:07:46.700
And then for writing it'll have
full syslog comp support so you

00:07:46.700 --> 00:07:50.860
can have messages still continue
to go to their old locations,

00:07:50.860 --> 00:07:56.390
although it's not the preferred interface
for some of the things like searching.

00:07:56.740 --> 00:08:01.000
The local store, as you heard yesterday,
we have SQLite in Tiger,

00:08:01.030 --> 00:08:05.010
and it'll give you the facility to
be able to do a little bit richer

00:08:05.010 --> 00:08:08.010
searching on your log messages,
and also go through a

00:08:08.020 --> 00:08:09.200
programmatic interface.

00:08:09.200 --> 00:08:13.870
So your individual app can display a
short history of your possible debug

00:08:13.870 --> 00:08:19.100
output without having to send the user
to a separate location to find that data.

00:08:19.200 --> 00:08:22.800
We also have a couple of ideas
for possible future extensions.

00:08:22.810 --> 00:08:25.390
As we mentioned,
the remote logging is not secure,

00:08:25.420 --> 00:08:29.650
so maybe come up with a way of being
able to remedy that sort of problem.

00:08:29.700 --> 00:08:32.570
Be able to do logging
from SNMP information,

00:08:32.570 --> 00:08:36.790
to be able to integrate that
into the logging infrastructure.

00:08:36.800 --> 00:08:41.830
Maybe you want to advertise some of
your syslog information on your blog.

00:08:41.920 --> 00:08:44.410
You can do things like with RSS.

00:08:44.620 --> 00:08:49.090
Once the information is in a
separate modular sort of interface,

00:08:49.150 --> 00:08:51.500
you can do all sorts of things.

00:08:51.500 --> 00:08:54.390
Maybe message in the bedroom can
message the machine in the den,

00:08:54.390 --> 00:08:55.180
"My disk is full.

00:08:55.240 --> 00:08:56.950
I need help."

00:08:58.530 --> 00:09:02.300
The individual log records themselves
have a couple of components that

00:09:02.350 --> 00:09:05.000
are automatically filled in for you.

00:09:05.000 --> 00:09:07.970
We're going to be trying to capture
the user information both as a

00:09:07.970 --> 00:09:11.930
username string and as a UID if
you use separate record interfaces,

00:09:11.930 --> 00:09:14.590
because those might not
necessarily match all the time.

00:09:14.850 --> 00:09:17.660
Similarly, group information.

00:09:17.680 --> 00:09:21.510
You might want to know our
query across a group of which

00:09:21.510 --> 00:09:24.160
applications are doing logging.

00:09:24.310 --> 00:09:28.860
Timestamp for when of course
the log message is received.

00:09:28.860 --> 00:09:32.370
Machine name,
mostly for now for future extensibility

00:09:32.490 --> 00:09:35.300
for being able to support remote logging.

00:09:35.300 --> 00:09:39.960
And then the application name itself,
which is derived simply from RGB0,

00:09:39.960 --> 00:09:43.560
so if you wish to overload
that you can change it.

00:09:43.950 --> 00:09:47.880
And then of course things that you
have to specifically call from the API.

00:09:47.960 --> 00:09:52.240
The log level itself determines a
little bit how it gets filtered.

00:09:52.320 --> 00:09:53.800
The message itself.

00:09:53.800 --> 00:09:58.140
And then we're also providing an
ancillary data field so you can go ahead

00:09:58.140 --> 00:10:03.800
and attach a string that would not show
up necessarily in the central log message

00:10:03.800 --> 00:10:06.830
so it's searchable as a separate field.

00:10:07.970 --> 00:10:09.460
When is it a good idea
to log information?

00:10:09.470 --> 00:10:13.800
Well, really, all the time.

00:10:13.800 --> 00:10:17.010
Anytime you do anything sort of useful,
like a system service,

00:10:17.010 --> 00:10:21.500
like if you start listening on a
socket or start advertising a service,

00:10:21.500 --> 00:10:25.140
if you disable a service,
parsing configuration files,

00:10:25.240 --> 00:10:26.590
creating new files.

00:10:26.600 --> 00:10:30.540
And some of the reasons this is useful
is if things start to break down,

00:10:30.540 --> 00:10:33.130
then you can provide the
error messages saying,

00:10:33.140 --> 00:10:36.940
you know, this file was corrupted
and I can't deal with it.

00:10:36.940 --> 00:10:40.470
Some people have had applications
just go ahead and do a couple bounces

00:10:40.470 --> 00:10:42.050
in the dock and then not do anything.

00:10:42.080 --> 00:10:44.100
And that's really not
a very good interface.

00:10:44.150 --> 00:10:46.730
And to be able to provide some
sort of mechanism for the user to

00:10:46.830 --> 00:10:50.000
be able to figure out what exactly
went wrong and maybe possibly

00:10:50.000 --> 00:10:52.120
correct it would be very useful.

00:10:52.120 --> 00:10:58.040
So you can also use it for diagnostic
information for various things,

00:10:58.040 --> 00:11:01.970
not just from application,
like hard application errors,

00:11:02.080 --> 00:11:05.480
but things where the system
is in a consistent situation.

00:11:05.500 --> 00:11:07.880
state where your application can
deal with a particular problem,

00:11:07.900 --> 00:11:11.290
but it might not be ideal,
and the system can provide log messages

00:11:11.340 --> 00:11:16.770
to be able to give information for the
user to be able to tune their system.

00:11:16.820 --> 00:11:20.270
Again, providing a simple audit trail
to be able to figure out what the

00:11:20.270 --> 00:11:21.770
application is actually doing.

00:11:21.770 --> 00:11:24.860
One of the nice things about
Mac OS X is you get to hide a lot of

00:11:24.860 --> 00:11:30.180
that complexity from the lower layers
up through a nice user interface,

00:11:30.180 --> 00:11:32.870
but it's also nice to be able to
keep track of that information so

00:11:32.940 --> 00:11:36.980
if a person does need to use it,
it is available.

00:11:37.580 --> 00:11:40.580
For ASO,
we're planning on a log level policy very

00:11:40.580 --> 00:11:44.300
similar to what syslog currently uses.

00:11:44.300 --> 00:11:48.270
It's extensible in the manner for these
are going to be arbitrary strings that

00:11:48.270 --> 00:11:50.990
you can use to set these log messages.

00:11:51.060 --> 00:11:54.540
But for right now, we want to be able to,
as we migrate from syslog,

00:11:54.540 --> 00:11:57.750
be able to provide direct
syslog compatibility.

00:11:57.800 --> 00:12:01.080
At the top level,
it's an emergency log level,

00:12:01.260 --> 00:12:04.220
typically not for most
application developers.

00:12:04.220 --> 00:12:05.910
It's more for things
like the kernel to say,

00:12:05.910 --> 00:12:08.980
"The system is actually
completely stopped.

00:12:08.980 --> 00:12:12.350
I can't do anything more." It's
a wonder this log message will

00:12:12.350 --> 00:12:13.590
actually get written at all.

00:12:13.590 --> 00:12:17.610
It's to the point where you're
archiving the state of the world

00:12:17.620 --> 00:12:23.000
for future generations to come
back and determine what happened.

00:12:23.060 --> 00:12:26.500
Alerts are for things that the user
can handle and should immediately.

00:12:26.620 --> 00:12:29.610
Things like disk full or maybe
my network disconnected and I'm

00:12:29.610 --> 00:12:32.920
absolutely dependent on that network.

00:12:32.920 --> 00:12:33.920
And I'm not sure if I'm
going to be able to do that.

00:12:33.920 --> 00:12:34.060
I'm not sure if I'm going
to be able to do that.

00:12:34.080 --> 00:12:34.630
I'm not sure if I'm going
to be able to do that.

00:12:34.640 --> 00:12:38.180
I'm not sure if I'm going maybe
even but not quite the same as

00:12:38.180 --> 00:12:40.820
say like a hard device error,
like I had a problem reading

00:12:40.820 --> 00:12:42.190
from this hard drive.

00:12:42.200 --> 00:12:43.980
Again,
like these are some of the kernel level

00:12:43.980 --> 00:12:47.780
facilities and things like that that
are higher level than some applications.

00:12:47.820 --> 00:12:51.020
Application things start right
around error where it's errors,

00:12:51.070 --> 00:12:54.440
you know, a hard fatal error where you
were expecting something and

00:12:54.440 --> 00:12:58.070
that's not true anymore and
you can't do anything but exit.

00:12:58.150 --> 00:13:01.180
This will provide at least a mechanism
for you to provide the user with

00:13:01.220 --> 00:13:04.410
information of why you have to quit.

00:13:04.700 --> 00:13:08.830
Warnings, again, non-fatal errors,
things that the system or that your

00:13:08.830 --> 00:13:12.830
application may not necessarily
have a problem dealing with,

00:13:12.940 --> 00:13:14.820
but that shouldn't be that way.

00:13:14.930 --> 00:13:17.390
And this allows the users,
like if a configuration file

00:13:17.390 --> 00:13:21.160
is consistently missing,
it has to be regenerated or something.

00:13:21.220 --> 00:13:24.160
Notices are for things
that aren't errors,

00:13:24.160 --> 00:13:26.910
but you may still want
to inform the user,

00:13:26.930 --> 00:13:29.980
like I'm starting a particular service,
I've turned SSH on,

00:13:30.000 --> 00:13:32.690
I'm allowing remote printing.

00:13:33.740 --> 00:13:39.700
Info allows you to log
informational messages such as,

00:13:39.700 --> 00:13:44.100
"This user logged in from a remote
connection," or "There's mail

00:13:44.100 --> 00:13:48.850
waiting for you," or any number
of different things that could be

00:13:48.850 --> 00:13:51.290
useful for the user to know about.

00:13:51.890 --> 00:13:55.400
And then debug provides, again,
a lower level so you can do

00:13:55.620 --> 00:13:57.620
things like lightweight tracing.

00:13:57.620 --> 00:14:00.580
You know,
syslog isn't a profiling utility,

00:14:00.600 --> 00:14:02.840
so it shouldn't be used as such.

00:14:02.840 --> 00:14:06.380
But to be able to provide the
user like a set of clear things

00:14:06.380 --> 00:14:09.220
of how it got to where it did,
and then as you as

00:14:09.220 --> 00:14:11.920
application developers,
maybe you can do things like

00:14:12.100 --> 00:14:16.240
log analysis to figure out
what necessarily went wrong.

00:14:16.790 --> 00:14:20.060
There's a command line interface.

00:14:20.060 --> 00:14:24.530
Currently it's the same as what we
currently have for syslog compatibility,

00:14:24.530 --> 00:14:26.840
a command called logger.

00:14:26.840 --> 00:14:31.740
So logger by itself with a string
will log just that string at

00:14:31.740 --> 00:14:33.690
some default level priority.

00:14:33.700 --> 00:14:38.580
You can also do things slightly more
sophisticated like specify the actual

00:14:38.850 --> 00:14:42.700
app name that gets logged and then
the priority from the command line.

00:14:42.700 --> 00:14:48.060
So this would be just starting
back up at log level notice with

00:14:48.060 --> 00:14:50.700
the application name backup.sh.

00:14:50.700 --> 00:14:54.480
We're also planning a query interface
from the command line that'll sort

00:14:54.480 --> 00:14:58.700
of obsolete using grep and that'll
provide a little bit more functionality.

00:14:58.700 --> 00:15:02.110
Currently we haven't decided if
this command is going to live within

00:15:02.120 --> 00:15:03.700
logger or as a separate utility.

00:15:03.700 --> 00:15:09.700
But the interface will be something like
you can specify logger-q for a query.

00:15:09.700 --> 00:15:12.690
And then you can do globs
on the particular thing.

00:15:12.700 --> 00:15:14.700
So by default it would
glob the message itself.

00:15:14.700 --> 00:15:18.700
So this would get both starting
back up and started testing.

00:15:18.730 --> 00:15:24.230
Or you could say ask for things like
give me all log messages from backup.sh

00:15:24.260 --> 00:15:26.900
with a priority level of notice.

00:15:28.250 --> 00:15:32.040
The API, again, much like syslog,
is rather straightforward.

00:15:32.040 --> 00:15:36.040
All the headers that you need are just
going to be contained within ASL.h.

00:15:36.330 --> 00:15:39.760
There's very few basic data
structures that you need.

00:15:39.940 --> 00:15:42.610
One of them is opaque struct, ASL_REF.

00:15:42.680 --> 00:15:46.240
It's returned by ASL_OPEN.

00:15:46.240 --> 00:15:50.830
If it's null, you have an error,
and you really can't log the

00:15:50.830 --> 00:15:53.200
fact that you have an error.

00:15:53.200 --> 00:15:59.520
ASL_LOG then calls with a ref with a
tag that specifies the actual priority,

00:15:59.520 --> 00:16:06.200
and then takes a printf-style string
that specifies the log message itself.

00:16:06.200 --> 00:16:08.710
And then it's always nice to be
able to close your references

00:16:08.710 --> 00:16:10.060
if you don't need them anymore.

00:16:10.240 --> 00:16:14.340
But I also mentioned that you
can specify ancillary data.

00:16:14.700 --> 00:16:18.590
So using the ASL set command,
you can do things like

00:16:18.620 --> 00:16:20.540
specifying the key data.

00:16:20.540 --> 00:16:24.870
You can add, say,
an additional arbitrary string like, say,

00:16:24.870 --> 00:16:27.100
hostname to the log message.

00:16:27.170 --> 00:16:33.540
And then as you call ASL log,
then that extra information is going

00:16:33.540 --> 00:16:38.160
to be logged with the next log message,
and then that field is cleared.

00:16:38.220 --> 00:16:46.180
So that if I called ASL log again,
you would not have the hostname be set.

00:16:49.130 --> 00:16:50.940
How do we search?

00:16:50.940 --> 00:16:54.290
In addition to the ASL ref,
we also need another opaque

00:16:54.380 --> 00:16:56.500
struct called ASL response.

00:16:56.580 --> 00:16:59.870
Again,
opening the log reference is the same.

00:17:00.140 --> 00:17:03.500
And then you call ASL set,
and then a particular key

00:17:03.500 --> 00:17:08.300
that you wish to search for,
and then what that key should match as.

00:17:08.510 --> 00:17:13.640
So ASL level debug for the ASL key level
will return all messages that match the

00:17:13.640 --> 00:17:16.530
level debug throughout your log archive.

00:17:16.700 --> 00:17:20.560
Then you call ASL search
on that reference,

00:17:20.670 --> 00:17:23.590
and that returns an ASL response.

00:17:23.800 --> 00:17:27.470
Now with an ASL response,
you can iterate over

00:17:27.470 --> 00:17:31.130
calling ASL response next,
and then to get the individual

00:17:31.270 --> 00:17:34.800
fields from the log message,
you can say ASL response

00:17:34.800 --> 00:17:37.020
get on that response.

00:17:37.130 --> 00:17:40.160
So in this case,
you'll be retrieving the sender, the PID,

00:17:40.160 --> 00:17:43.190
and the message,
and then printing off them in a format

00:17:43.190 --> 00:17:46.690
similar to an old style syslog message.

00:17:46.760 --> 00:17:51.530
And then ASL response free cleanup
references along with ASL close.

00:17:53.510 --> 00:17:57.960
So, in summary,
we have a consolidated programming

00:17:57.960 --> 00:18:02.890
interface for accessing log information,
something that really quite

00:18:02.890 --> 00:18:04.390
hasn't been done before.

00:18:04.450 --> 00:18:09.560
Unified log information store, again,
being able to query the single

00:18:09.560 --> 00:18:12.960
SQLite database as the backend,
but also being able to specify

00:18:13.320 --> 00:18:16.430
other locations that the
messages could possibly go.

00:18:17.120 --> 00:18:22.000
The modular interface for
receiving and storing messages.

00:18:22.000 --> 00:18:25.680
The API isn't planned for Tiger,
but we're looking at things in the

00:18:25.680 --> 00:18:30.680
future for opening up things so you
can write your own modules for being

00:18:30.680 --> 00:18:33.970
able to deal with these messages,
both input and output.

00:18:34.000 --> 00:18:40.320
And it's just in general a good debugging
tool for users to be able to find out

00:18:40.450 --> 00:18:45.280
what went wrong with their system and
if they could do anything about it.

00:18:46.190 --> 00:18:52.600
This time I'd like to bring up
Jordan Hubbard for Beyond Syslog.

00:18:52.600 --> 00:18:56.210
Things that in system
administration that go beyond the

00:18:56.220 --> 00:18:59.410
scope of just looking at logs.

00:19:06.900 --> 00:19:07.900
Thanks.

00:19:07.900 --> 00:19:08.340
Am I on?

00:19:08.340 --> 00:19:09.180
Okay.

00:19:09.250 --> 00:19:12.120
So my portion of the talk
might be titled Beyond,

00:19:12.120 --> 00:19:14.830
Beyond Syslog,
because we realized in this session

00:19:14.830 --> 00:19:17.520
that we were going to have a lot of
system administrators in the audience,

00:19:17.630 --> 00:19:20.280
and we figured this would be a
good opportunity to talk about

00:19:20.280 --> 00:19:24.760
some stuff that we may not
actually be able to have in Tiger,

00:19:24.910 --> 00:19:27.460
but are all works in progress.

00:19:27.460 --> 00:19:30.830
We're certainly going to try and get
some or all of them done for Tiger,

00:19:30.830 --> 00:19:31.940
but no promises.

00:19:31.940 --> 00:19:34.640
But this is sort of the direction
we're going in and the types of

00:19:34.640 --> 00:19:36.160
problems we're trying to solve.

00:19:38.900 --> 00:19:41.990
So, one thing we've noticed
that's interesting about

00:19:42.000 --> 00:19:45.930
Apple's evolving user base,
if I can put it that way,

00:19:45.930 --> 00:19:48.080
is we're getting a lot more Unix people.

00:19:48.080 --> 00:19:52.150
And they tend to be
system administrators,

00:19:52.190 --> 00:19:57.610
they tend to deploy in IT environments,
they're deploying XSERs,

00:19:57.630 --> 00:19:59.440
which is obviously a
new product for Apple,

00:19:59.440 --> 00:20:03.350
and somewhat out of the boundaries
of the traditional desktop market.

00:20:03.360 --> 00:20:07.400
So, they're bringing to us a lot
of interesting new problems,

00:20:07.400 --> 00:20:08.380
shall I say.

00:20:08.870 --> 00:20:11.880
that I'll cover here.

00:20:12.270 --> 00:20:14.990
One thing, actually I'll say the number
one thing they asked for is

00:20:15.000 --> 00:20:16.200
better package management.

00:20:16.200 --> 00:20:22.200
Yeah, so... Unfortunately,
package management is actually hard.

00:20:22.300 --> 00:20:25.330
It's one of those really,
it's not very deep,

00:20:25.340 --> 00:20:27.200
but it's a very wide problem space.

00:20:27.200 --> 00:20:32.200
And dealing with dependency tracking,
dealing with undo, dealing with arbitrary

00:20:32.200 --> 00:20:35.200
scripts that might run,
sort of post-installation scripts

00:20:35.200 --> 00:20:38.690
where you have some really strange
piece of software that has to

00:20:38.710 --> 00:20:41.200
go off and perturb the system,
maybe add users.

00:20:41.200 --> 00:20:44.140
Perhaps go configure
something in the I/O registry.

00:20:44.200 --> 00:20:48.160
You never really know what an arbitrary
package is going to try to do.

00:20:48.200 --> 00:20:51.400
So,
to get it to do that in a way which is

00:20:51.400 --> 00:20:58.200
flexible and gives you some prayer of
security is not an easy problem to solve.

00:20:58.950 --> 00:21:02.630
So, as I said, one of the, well,
these are some of the issues that we

00:21:02.640 --> 00:21:05.610
have with today's package management.

00:21:05.610 --> 00:21:12.350
And one is, by which I mean the .pkg,
.mpkg files that the installer eats.

00:21:12.350 --> 00:21:15.620
And number one gripe,
I can't install what I've installed.

00:21:15.620 --> 00:21:17.040
Or I can't back out.

00:21:17.090 --> 00:21:22.620
So if I've installed a software update,
which for some unforeseen reason

00:21:22.770 --> 00:21:26.920
doesn't leave my system in
the best condition afterwards,

00:21:26.980 --> 00:21:28.840
I'd like to be able to go back in time.

00:21:28.900 --> 00:21:32.740
There's no dependency
tracking across packages.

00:21:32.740 --> 00:21:34.900
So if you have several packages
sitting in a directory together,

00:21:34.900 --> 00:21:40.190
and one depends on the other,
there's really no notion for that at all.

00:21:40.210 --> 00:21:43.890
The only thing that Apple provides
today is something called the M package,

00:21:43.890 --> 00:21:48.440
which is basically just an agglomeration
of a package and all of its dependencies.

00:21:48.520 --> 00:21:52.550
And if you have two M packages which
contain the same subcomponents,

00:21:52.770 --> 00:21:56.110
they'll both stupidly install the same
subcomponents over and over again.

00:21:56.220 --> 00:21:58.260
Plus, of course,
you have the overhead of downloading

00:21:58.320 --> 00:22:02.060
those same bits several times.

00:22:02.400 --> 00:22:07.860
We have library receipts and the
BOM or build of materials files

00:22:07.900 --> 00:22:12.330
as pretty much the only installed
software database that you get.

00:22:12.380 --> 00:22:14.090
And obviously this is insufficient.

00:22:14.090 --> 00:22:17.460
It doesn't let you do queries,
it doesn't let you at a glance find

00:22:17.610 --> 00:22:20.990
out what's installed on your system,
when it was installed,

00:22:20.990 --> 00:22:22.390
and other useful things.

00:22:22.790 --> 00:22:25.750
There's no file or
package conflict checking,

00:22:25.750 --> 00:22:29.680
so if two packages claim the same file,
that's just fine,

00:22:29.690 --> 00:22:31.700
which of course it's not.

00:22:31.790 --> 00:22:36.900
And upgrade support is really
pretty weak with the current system.

00:22:37.050 --> 00:22:40.940
It basically just checks that you're,
I think you're monotomically

00:22:40.940 --> 00:22:45.500
increasing inversion numbers and
then splats the new files into place.

00:22:45.610 --> 00:22:51.110
There is no command line interface that
I really know of for installing packages.

00:22:51.800 --> 00:22:58.000
[Transcript missing]

00:22:58.100 --> 00:25:04.500
[Transcript missing]

00:25:05.100 --> 00:27:31.900
[Transcript missing]

00:27:33.010 --> 00:27:39.240
So, for the future, we're not sure what
the future holds here.

00:27:39.240 --> 00:27:44.240
We're continuing to back Darwin Ports
just as a pretty good solution,

00:27:44.330 --> 00:27:48.580
but we're actually looking at
cooperating with some of the

00:27:48.580 --> 00:27:52.040
Linux distributions which have also
started to run into the same problem.

00:27:52.120 --> 00:27:57.240
Some of whom are saying SRPMs are not
really the right way to build software,

00:27:57.240 --> 00:28:00.990
it was a good solution for its time,
but we want something similar

00:28:00.990 --> 00:28:02.760
to the FreeBSD Ports collection.

00:28:02.760 --> 00:28:08.810
In the sense that we want a
massive tree of building recipes.

00:28:08.920 --> 00:28:13.310
It's important to note,
end users may consume packages,

00:28:13.330 --> 00:28:15.640
but those packages have
to come from somewhere.

00:28:15.640 --> 00:28:20.150
And so, creating the infrastructure and
environment for building these

00:28:20.430 --> 00:28:24.510
packages and maintaining that is at
least as important as coming up with

00:28:24.510 --> 00:28:26.920
a good package management system.

00:28:26.920 --> 00:28:29.990
And so,
we're looking at some interesting ways

00:28:29.990 --> 00:28:32.520
of doing maybe an end-to-end solution
where you start with the end user,

00:28:32.520 --> 00:28:36.130
you start with an XML recipe
which describes how to build it,

00:28:36.130 --> 00:28:39.380
and then as it goes along the
food chain and gets built into

00:28:39.400 --> 00:28:43.080
some sort of destination route,
and then it's finally packaged up,

00:28:43.080 --> 00:28:46.150
that same XML file simply has
more properties added to it which

00:28:46.210 --> 00:28:48.730
describe the package metadata,
and then that's bundled in as

00:28:48.730 --> 00:28:50.190
part of the package itself.

00:28:50.260 --> 00:28:53.950
So, you never actually lose
the original build recipe.

00:28:54.990 --> 00:28:57.660
So, some other issues.

00:28:57.950 --> 00:29:01.620
System configuration is still difficult.

00:29:01.810 --> 00:29:05.920
It's something that involves lots
and lots of different configuration

00:29:05.920 --> 00:29:07.700
files scattered around the system.

00:29:07.750 --> 00:29:12.570
You're never even sure at any given
time what daemons are configured or will

00:29:12.570 --> 00:29:15.140
launch in response to some stimulus.

00:29:15.180 --> 00:29:18.740
And then of course once you know
which daemons are out there,

00:29:18.740 --> 00:29:20.740
you have to learn their
configuration formats.

00:29:20.750 --> 00:29:24.420
And it seems like every single daemon
in the system has invented its own.

00:29:24.420 --> 00:29:28.740
Apache's got httpd.conf,
Samba has smb.conf.

00:29:28.770 --> 00:29:32.240
You name a daemon,
I'll name you a unique configuration

00:29:32.240 --> 00:29:36.110
format which applies to that
daemon and that daemon only.

00:29:36.250 --> 00:29:39.790
Different services also
have different semantics.

00:29:39.790 --> 00:29:43.920
So in some cases you can edit the
configuration file and then you

00:29:43.920 --> 00:29:47.000
need to go tell the daemon that
its configuration file changed

00:29:47.000 --> 00:29:48.600
by sending it a special signal.

00:29:48.700 --> 00:29:52.930
In other cases there's a management
command like Apache CTL which

00:29:52.930 --> 00:29:56.400
you need to run to restart it
in some sort of civilized fashion.

00:29:56.540 --> 00:29:58.390
In most cases there's nothing.

00:29:58.400 --> 00:30:01.280
You go and you find
the daemon in question,

00:30:01.280 --> 00:30:04.310
you shoot it down and you restart it
and you hope it restarts and didn't

00:30:04.310 --> 00:30:06.090
leave any state files lying around.

00:30:06.100 --> 00:30:08.170
Which annoy it the
second time it comes up.

00:30:08.610 --> 00:30:14.100
Basically a reboot is the only assured
method for restarting it properly.

00:30:14.100 --> 00:30:16.050
Which is by the way one of
the reasons why some of the

00:30:16.050 --> 00:30:17.390
software updates reboot you.

00:30:17.510 --> 00:30:20.790
It isn't just because
the kernel has changed,

00:30:20.790 --> 00:30:24.740
it's because it's altered some service
and the only way to get the new service

00:30:24.740 --> 00:30:26.500
running is to reboot your system.

00:30:26.820 --> 00:30:28.870
That blows.

00:30:30.200 --> 00:30:35.720
So, there's also no notion of a
configuration parameter space that

00:30:35.740 --> 00:30:37.870
they can share or rendezvous in.

00:30:37.880 --> 00:30:40.160
So, in some cases,
a number of daemons would

00:30:40.160 --> 00:30:41.680
like to share a common knob.

00:30:41.680 --> 00:30:44.220
It's a knob that controls
some global resource,

00:30:44.220 --> 00:30:47.420
and they should all respect it.

00:30:47.420 --> 00:30:51.000
Or a global knob that says,
"No daemons should run at all right now.

00:30:51.000 --> 00:30:56.200
Please, I'm doing a backup." Again,
so there's no notion of that.

00:30:56.200 --> 00:31:00.080
The closest thing we have to a
shared configuration space is

00:31:00.080 --> 00:31:02.340
the sysctl table in the kernel.

00:31:02.340 --> 00:31:06.800
And obviously, that's pretty low level
and only really--.

00:31:07.350 --> 00:31:09.020
It allows you to configure kernel knobs.

00:31:09.020 --> 00:31:11.730
It doesn't allow you to configure
things up in user space,

00:31:11.730 --> 00:31:13.370
nor should it.

00:31:13.550 --> 00:31:17.260
And the whole remote management
issue is basically nonexistent

00:31:17.260 --> 00:31:21.760
other than SSH-ing in and doing,
if it has a command line interface,

00:31:21.810 --> 00:31:23.670
doing it that way.

00:31:24.650 --> 00:31:29.190
So we've been looking at
this problem very hard,

00:31:29.210 --> 00:31:34.550
and one notion that we came up with,
which we've been prototyping

00:31:34.680 --> 00:31:39.360
and playing with,
is the notion of a configuration API.

00:31:39.360 --> 00:31:42.300
And that's good for a
lot of different reasons.

00:31:42.300 --> 00:31:47.030
And the chief reason I really like it is
it finally gives you a path to go down if

00:31:47.030 --> 00:31:51.160
you want to create a new service and say,
"I don't want to invent my

00:31:51.160 --> 00:31:52.910
own configuration file format.

00:31:53.010 --> 00:31:57.170
There are quite enough, thank you." So,
but I don't have any--there's nothing

00:31:57.170 --> 00:32:01.220
in libc or any of the standard Unix
APIs that allows you to do that.

00:32:01.260 --> 00:32:04.940
And, okay, if you use core foundation,
you can use CFPreferences,

00:32:05.110 --> 00:32:06.830
which is--which is a good start for this.

00:32:06.830 --> 00:32:10.330
It definitely eliminated a lot of
dot files in your home directory.

00:32:10.450 --> 00:32:15.090
But if you're not using CF,
if you're sort of a Unix demon,

00:32:15.090 --> 00:32:18.500
then that doesn't really do you
any good unless you want to drag

00:32:18.500 --> 00:32:21.530
all of CF in with--with the--with
the--your set of libraries.

00:32:21.530 --> 00:32:25.020
So, we're looking at a fairly
low level service--sorry,

00:32:25.020 --> 00:32:29.390
a fairly low level service which
lets you set and get properties,

00:32:29.390 --> 00:32:33.570
query, walk the tree,
something similar to an SNMP MIB,

00:32:33.570 --> 00:32:36.840
but a little bit with
more structured data.

00:32:36.840 --> 00:32:39.770
And so you have a
configuration in a space,

00:32:39.770 --> 00:32:42.190
you have APIs for getting
and setting this stuff,

00:32:42.190 --> 00:32:46.170
and you have a persistent data store,
probably an SQLite database

00:32:46.170 --> 00:32:48.170
is our first choice right now.

00:32:48.170 --> 00:32:52.060
So, you have tables and rows and you can
also bring up the SQLite tool to browse

00:32:52.060 --> 00:32:53.550
it if you want to do it that way.

00:32:53.880 --> 00:32:58.300
But we're not married to that right now,
it's just one potential data store.

00:32:58.300 --> 00:33:03.550
And the most important aspect of
this is its application agnostic.

00:33:03.720 --> 00:33:07.010
Now you can write a Cocoa browser
which lets you browse these

00:33:07.010 --> 00:33:08.340
things and tweak stuff.

00:33:08.360 --> 00:33:10.830
You can have services just
programmatically go in and

00:33:10.830 --> 00:33:12.300
setting and get values.

00:33:12.590 --> 00:33:16.680
You'll have a command line tool which for
any demon which conforms to this--this

00:33:16.680 --> 00:33:19.120
new API will have its knobs registered.

00:33:19.120 --> 00:33:19.550
And then you can have a command
line tool which for any demon which

00:33:19.600 --> 00:33:21.130
conforms to this--this new API will
have its knobs registered with so you

00:33:21.130 --> 00:33:25.010
don't have to think of which specific
command goes with a specific demon.

00:33:25.190 --> 00:33:28.120
And obviously if you also want
to have a web front end to it for

00:33:28.120 --> 00:33:30.650
remote management or whatever,
you could do that.

00:33:30.650 --> 00:33:34.550
Or you could write a proxy demon which
authenticates to a remote client,

00:33:34.550 --> 00:33:37.330
maybe a Cocoa application
again or whatever,

00:33:37.350 --> 00:33:39.240
and lets you do this remotely.

00:33:43.180 --> 00:33:46.900
So, some of the issues that are going
to make this a difficult problem

00:33:47.260 --> 00:33:51.970
is we have a number of existing
configuration data stores.

00:33:51.970 --> 00:33:55.040
There's the SC Dynamics store
stuff that ConfigD uses.

00:33:55.100 --> 00:33:57.570
There's surprisingly NetInfo,
which still stores

00:33:57.580 --> 00:34:00.240
certain system parameters,
so we need to merge those.

00:34:00.340 --> 00:34:03.470
And you need backwards compatibility.

00:34:03.680 --> 00:34:07.280
One of the cardinal sins in the Unix
market is to come up there with a

00:34:07.310 --> 00:34:11.120
bold new mechanism that completely
changes all the rules and say,

00:34:11.120 --> 00:34:12.650
"But it's really better.

00:34:12.800 --> 00:34:15.880
You really want it because
it's better." And they say,

00:34:15.980 --> 00:34:17.160
"I don't care.

00:34:17.160 --> 00:34:20.910
I can write Apache configuration
files in my sleep,

00:34:20.910 --> 00:34:23.110
and I want to keep doing that.

00:34:23.110 --> 00:34:27.290
Thank you very much." Or,
"I artist a set of common configuration

00:34:27.290 --> 00:34:31.780
files across my Linux machines,
my Mac OS X boxes." "My FreeBSD boxes,

00:34:31.780 --> 00:34:35.640
and I want that scheme
to continue to work." So,

00:34:35.640 --> 00:34:40.010
we are looking at the notion of
configuration file parsing plug-ins

00:34:40.010 --> 00:34:45.100
that map from one space to the other,
which is not easy to do because

00:34:45.100 --> 00:34:49.240
there's an imperfect match for a
lot of these configuration files.

00:34:49.340 --> 00:34:52.420
And you, of course,
have the issue of what happens when

00:34:52.420 --> 00:34:54.340
you update one or not the other.

00:34:54.340 --> 00:34:56.850
Do you try and back propagate
the change if you make it to

00:34:56.850 --> 00:35:00.340
the centralized data store,
but don't make it to the flat ASCII file?

00:35:00.340 --> 00:35:02.170
That it came from?

00:35:02.390 --> 00:35:04.340
Or do you just do it one way?

00:35:04.340 --> 00:35:06.230
Do you essentially do
it as a migration tool?

00:35:06.430 --> 00:35:08.530
So, there's a lot of interesting
trade-offs there,

00:35:08.530 --> 00:35:10.340
and we're looking at that very closely.

00:35:11.850 --> 00:35:18.320
So, and you need to come up with a fairly
high level API for this so that you

00:35:18.320 --> 00:35:22.350
can do something similar to PLIS where
you have dictionaries and arrays and

00:35:22.350 --> 00:35:27.080
sort of arbitrarily complex data types
so that people don't just use it as a

00:35:27.080 --> 00:35:31.610
binary blob data store and still have
to pick the data apart themselves.

00:35:31.620 --> 00:35:34.570
But obviously you don't know the full
range of configuration data that people

00:35:34.570 --> 00:35:37.610
are going to want to store so you
need to pick a very flexible format.

00:35:37.670 --> 00:35:40.080
The P-list format actually
isn't a bad one because it

00:35:40.080 --> 00:35:42.320
is quite flexible that way.

00:35:42.600 --> 00:35:45.060
And of course you need things
like transaction rollback.

00:35:45.070 --> 00:35:49.460
If I make a whole bunch of configuration
changes and then it blew the system up,

00:35:49.470 --> 00:35:51.110
it would be,
or somebody did it at 3 o'clock

00:35:51.160 --> 00:35:53.380
in the morning because you
have five or six administrators

00:35:53.380 --> 00:35:56.070
all sharing the same duties,
then I'd like to be

00:35:56.070 --> 00:35:58.330
able to come in and say,
you know, at 6 a.m.

00:35:58.330 --> 00:36:02.350
and say, "Burt messed up the system."
You probably wouldn't use that word,

00:36:02.440 --> 00:36:03.100
but anyway.

00:36:03.200 --> 00:36:05.290
And you want to be able to roll it back.

00:36:05.290 --> 00:36:07.240
So that's, and it's important.

00:36:07.360 --> 00:36:10.340
Or you can see the transaction
history to see who it was whose

00:36:10.340 --> 00:36:12.500
fingerprints are all over this mess.

00:36:13.700 --> 00:37:42.500
[Transcript missing]

00:37:43.800 --> 00:37:49.550
So, some other design goals,
and this doesn't just apply to

00:37:49.550 --> 00:37:52.800
the problem space I mentioned,
but overall,

00:37:52.950 --> 00:37:57.020
anything doable via the UI should
be doable on the command line.

00:37:57.090 --> 00:38:00.880
That's one of the number one
bricks to the head we've taken

00:38:00.880 --> 00:38:02.740
over the last year or so.

00:38:04.800 --> 00:38:07.700
Now, don't clap yet,
because I didn't promise this.

00:38:07.700 --> 00:38:10.160
I said this is a design goal,
and this is something we

00:38:10.160 --> 00:38:13.100
are getting at this point.

00:38:13.100 --> 00:38:16.760
Every time I go out to Hollywood or
somebody who uses a lot of machines,

00:38:16.760 --> 00:38:19.040
this is like one of the number
one things they hit me with.

00:38:19.040 --> 00:38:22.030
So we do understand this
is a really important goal.

00:38:22.120 --> 00:38:25.350
Some of the stuff that Apple has
done is very UI-centric,

00:38:25.470 --> 00:38:26.960
like software update.

00:38:27.050 --> 00:38:30.510
And it took a little while
to make it dual mode.

00:38:30.550 --> 00:38:35.360
So in some cases you have to go back
and sort of do retroactive design.

00:38:35.550 --> 00:38:37.960
But going forward,
we're really clear on the fact

00:38:38.100 --> 00:38:42.620
that you need to design that,
that is a design goal from the beginning.

00:38:43.790 --> 00:38:48.700
Another complaint we get is the UI did
something and I have no idea what.

00:38:48.700 --> 00:38:53.250
You know, I clicked on something and some
file was modified or some data

00:38:53.250 --> 00:38:55.920
store had an update made to it.

00:38:56.070 --> 00:38:57.700
Can you tell me what that was?

00:38:57.740 --> 00:39:00.870
I might also want to be able to
reproduce that action on the command line

00:39:00.880 --> 00:39:02.830
elsewhere where I don't have that UI.

00:39:02.900 --> 00:39:06.490
So the UI can be a great way of
showing you how to do something

00:39:06.770 --> 00:39:08.550
if it will show you how it did it.

00:39:08.620 --> 00:39:11.980
So that's another important
design goal for everything

00:39:11.980 --> 00:39:13.850
that we're doing in the future.

00:39:14.440 --> 00:39:20.410
Documentation for command line
tools turns out to be important.

00:39:21.530 --> 00:39:23.710
So we're actually now doing
this as part of our builds.

00:39:23.830 --> 00:39:27.060
We actually have a verification
phase which goes and says,

00:39:27.060 --> 00:39:27.880
"Hey, Mr.

00:39:27.880 --> 00:39:31.730
Maintainer, your command line tool,
you installed something in user bin and

00:39:31.730 --> 00:39:36.190
it does not have a man page." And it
slaps you upside the head repeatedly

00:39:36.190 --> 00:39:38.580
until you do something about it.

00:39:38.580 --> 00:39:38.580
So.

00:39:40.070 --> 00:39:42.230
So,
something that we're also trying to be

00:39:42.230 --> 00:39:48.810
really cognizant of is that the road
is littered with the decaying skeletons

00:39:48.820 --> 00:39:54.240
of those Unix folks who have gone
before us and tried to make this work.

00:39:54.270 --> 00:39:57.570
It is a hard problem space to
find the right balance for.

00:39:57.840 --> 00:40:01.870
If you get too hog wild in
front-ending everything,

00:40:01.870 --> 00:40:04.480
the admins scream that
you're dumbing things down,

00:40:04.480 --> 00:40:09.190
or that you didn't give them a button
for exactly what they wanted to do,

00:40:09.190 --> 00:40:10.000
how dare you.

00:40:10.150 --> 00:40:13.990
And if you make it too simplistic,
they won't use it.

00:40:14.010 --> 00:40:15.000
They'll say, "What's the point?

00:40:15.000 --> 00:40:16.490
I can do this all on the command line.

00:40:16.510 --> 00:40:19.000
My fingers are hardwired
for that command.

00:40:19.000 --> 00:40:23.130
What good is your UI tool?" And if
you look at a lot of things that

00:40:23.130 --> 00:40:26.670
people have done in the industry,
you'll see things on both

00:40:26.700 --> 00:40:28.500
sides of the number line.

00:40:29.280 --> 00:40:32.940
So this is something that-- one of the
reasons I wanted to cover these points

00:40:32.980 --> 00:40:35.200
here is these are all works in progress.

00:40:35.200 --> 00:40:38.940
These are all things that
either are under investigation

00:40:38.940 --> 00:40:42.110
or are being prototyped,
and this is an area where

00:40:42.160 --> 00:40:45.770
administrative feedback,
people who actually at the rock face

00:40:45.770 --> 00:40:50.200
doing this stuff day in and day out,
can really, really help us with.

00:40:50.200 --> 00:40:52.630
Because again,
we're engineers so we'll go out and build

00:40:52.640 --> 00:40:57.560
an elephant where a mouse is called for
or vice versa if you just leave us alone

00:40:57.630 --> 00:41:01.000
with the specs and no adult supervision.

00:41:01.000 --> 00:41:06.300
But if we have real world scenarios
and definite strong input,

00:41:06.300 --> 00:41:10.920
must do this, it must do that,
it must not do this other thing,

00:41:10.960 --> 00:41:13.340
that is incredibly important to us.

00:41:13.340 --> 00:41:17.100
So I encourage you to send me email,
contact us through channels,

00:41:17.100 --> 00:41:18.900
file enhancement reports.

00:41:18.900 --> 00:41:21.760
You don't just have to file bug
reports when you go to Bug Reporter.

00:41:21.760 --> 00:41:23.760
You can also say, I'd like this.

00:41:23.960 --> 00:41:27.160
enhanced, like a new feature place,
so I encourage you to do that.
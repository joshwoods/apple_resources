WEBVTT

00:00:12.330 --> 00:00:14.130
Good morning, everybody.

00:00:14.140 --> 00:00:18.640
Welcome to session 301,
Automated Testing on Mac OS X.

00:00:18.640 --> 00:00:21.340
I'm John Montbrien from
Apple Developer Relations,

00:00:21.340 --> 00:00:25.640
and I'm pleased to introduce your host,
John Comiskey,

00:00:25.660 --> 00:00:27.270
who will be speaking to you.

00:00:27.300 --> 00:00:30.180
He's a senior engineer from
AppleScript Engineering.

00:00:30.180 --> 00:00:32.880
And welcome, John Comiskey.

00:00:32.940 --> 00:00:33.180
Thank you.

00:00:33.180 --> 00:00:36.170
Thank you, John.

00:00:38.220 --> 00:00:40.100
Good morning,
and thank you for being here.

00:00:40.100 --> 00:00:41.100
I'm John Comiskey.

00:00:41.100 --> 00:00:43.440
I'm an engineer in the AppleScript group.

00:00:43.500 --> 00:00:47.810
I'm going to talk to you today
for about 15 minutes about using

00:00:47.810 --> 00:00:53.300
AppleScript to test your application,
and then some gentlemen from Redstone

00:00:53.300 --> 00:00:58.610
Software will be talking about Eggplant,
a much more high-powered way

00:00:58.610 --> 00:01:00.560
of testing your application.

00:01:00.750 --> 00:01:05.840
So this session will cover ways to use
AppleScript to test your application.

00:01:05.890 --> 00:01:07.030
Thorough testing is crucial.

00:01:07.050 --> 00:01:09.490
You want to make sure that your
program works correctly before

00:01:09.490 --> 00:01:10.780
you ship it to your customers.

00:01:10.910 --> 00:01:14.580
And the only way to do that
is with thorough testing.

00:01:14.940 --> 00:01:16.980
And making sure everything
works exactly right.

00:01:17.020 --> 00:01:21.600
We like to encourage people to use
AppleScript to test their applications

00:01:21.720 --> 00:01:25.710
because it has a lot of advantages,
it's very flexible.

00:01:25.720 --> 00:01:27.380
You can test what you want to test.

00:01:27.430 --> 00:01:30.050
You write the test yourself,
you control them.

00:01:30.060 --> 00:01:32.510
It's extensible,
every time you add something

00:01:32.510 --> 00:01:35.370
new to your program,
you can add new AppleScripts

00:01:35.420 --> 00:01:36.680
that test those features.

00:01:36.680 --> 00:01:38.690
It can be very complete.

00:01:38.920 --> 00:01:41.470
You can probe every single
corner of your application,

00:01:41.620 --> 00:01:44.900
press it into all of its
boundary cases this way.

00:01:44.900 --> 00:01:47.220
It improves your accuracy.

00:01:47.280 --> 00:01:50.550
You can keep track of what the
results of your tests were from one

00:01:51.230 --> 00:01:55.790
execution to the next and make sure
that you're getting the right answer.

00:01:55.900 --> 00:01:58.700
You can repeat those
tests time after time.

00:01:58.700 --> 00:02:02.070
Each time you change your application,
you can repeat all your tests

00:02:02.070 --> 00:02:04.070
and prove to your boss that
you haven't broken anything.

00:02:04.080 --> 00:02:06.010
And it's controllable.

00:02:06.010 --> 00:02:08.300
You say what's going to be tested.

00:02:08.300 --> 00:02:10.850
You can have a small test that
you run every single time that

00:02:10.850 --> 00:02:13.870
you build the application,
a larger test that you run

00:02:13.870 --> 00:02:17.360
just before you turn it over
to your testing organization,

00:02:17.360 --> 00:02:19.940
and then they can have a
massive suite of tests,

00:02:19.940 --> 00:02:23.740
like I said, that probe every single
corner of your application.

00:02:24.620 --> 00:02:27.280
And the best thing is that it
all goes a lot faster than if

00:02:27.430 --> 00:02:29.000
you're trying to do it by hand.

00:02:30.740 --> 00:02:33.110
So we're going to cover
lots of things today.

00:02:33.200 --> 00:02:34.620
You have to plan for scriptability.

00:02:34.620 --> 00:02:37.300
It just doesn't happen all by itself.

00:02:37.300 --> 00:02:39.660
You're going to want to
instrument your code so that when

00:02:39.660 --> 00:02:42.330
you're driving it with scripts,
you know what's happening.

00:02:42.470 --> 00:02:44.610
You can follow the flow and
make sure that that's what

00:02:44.640 --> 00:02:46.830
you wanted to have happen.

00:02:47.030 --> 00:02:48.800
You want to ensure that
you have code coverage.

00:02:48.800 --> 00:02:51.680
Like I said, probe into every single
corner of your application.

00:02:51.680 --> 00:02:56.230
Make sure that it all works,
not just the most frequently used stuff.

00:02:56.250 --> 00:02:59.770
Last year in Session 311,
we talked a lot about using Apple's

00:02:59.770 --> 00:03:02.070
GUI scripting to test your application.

00:03:02.210 --> 00:03:04.490
I'm going to say a little
bit more about that today.

00:03:04.630 --> 00:03:07.470
And then the most important
part is to sustain the effort.

00:03:07.530 --> 00:03:11.160
It's nice to have a good set of tests,
but it's very important to keep them

00:03:11.160 --> 00:03:13.420
up-to-date as your program changes.

00:03:13.520 --> 00:03:17.290
And then, like I said,
the fellows from Redstone will

00:03:17.290 --> 00:03:19.900
be talking to you about Eggplant.

00:03:21.430 --> 00:03:25.110
Last year,
we had a very long session about

00:03:25.110 --> 00:03:27.000
how to design a dictionary.

00:03:27.040 --> 00:03:28.300
That's session 414.

00:03:28.300 --> 00:03:30.800
If you have the DVDs,
you can watch it there.

00:03:30.800 --> 00:03:33.720
If not,
it's available on the developer website.

00:03:33.720 --> 00:03:37.830
We also promised you some guidelines
for putting together your dictionary,

00:03:37.980 --> 00:03:40.210
and Chris Nebel did an
excellent job of that,

00:03:40.210 --> 00:03:43.620
and those are now available
also on the developer website.

00:03:44.400 --> 00:03:46.870
So you should definitely look at
the scripting interface guidelines.

00:03:46.870 --> 00:03:48.590
Even if your program
is already scriptable,

00:03:48.600 --> 00:03:51.890
you should look at the guidelines
because it might help you out.

00:03:51.900 --> 00:03:54.680
Even if all you do is go through
and change some of the comments,

00:03:54.680 --> 00:03:56.660
your dictionary might be easier to use.

00:03:58.860 --> 00:04:01.070
If you're using Cocoa to
do your scriptability,

00:04:01.220 --> 00:04:04.730
it's necessary to align the
objects in your dictionary with the

00:04:04.850 --> 00:04:07.200
Cocoa objects inside your program.

00:04:07.320 --> 00:04:10.350
Even if you're not using Cocoa,
you're going to have to have

00:04:10.350 --> 00:04:13.420
some kind of mapping from
your dictionary to your code.

00:04:13.520 --> 00:04:16.590
In Cocoa,
it's very direct and one-to-one.

00:04:17.490 --> 00:04:20.740
You're going to want to streamline this
though from the user's point of view.

00:04:20.740 --> 00:04:24.600
You don't necessarily want to show
them all the ugly guts of your program.

00:04:24.760 --> 00:04:29.870
You want to name things what your
users call them and make them interact

00:04:29.870 --> 00:04:33.910
the way your users are familiar
with using them through the GUI.

00:04:34.510 --> 00:04:38.140
If you absolutely have to,
you can put in a private test suite

00:04:38.240 --> 00:04:40.800
that doesn't ship to your customers,
which will allow you to get to

00:04:40.800 --> 00:04:44.250
some of the lower-level things
that you know you need to test,

00:04:44.250 --> 00:04:47.490
but are not likely to be
useful to the end users.

00:04:48.770 --> 00:04:51.640
And you're going to want to cover all
the functionality of your program.

00:04:51.640 --> 00:04:54.140
You're going to want to make sure
that there's some way to test and

00:04:54.190 --> 00:04:56.560
get at everything your program does.

00:04:56.650 --> 00:04:59.420
That might be a pretty
daunting task at first.

00:04:59.520 --> 00:05:02.000
So we encourage you to go
ahead and phase this operation,

00:05:02.000 --> 00:05:06.060
and each release add a little bit more
scriptability than the time before.

00:05:06.140 --> 00:05:10.520
And that way you'll get there
at least in a couple of steps.

00:05:11.360 --> 00:05:15.300
To know what your code is doing inside,
it's got to be instrumented.

00:05:15.300 --> 00:05:17.280
And you can do this
lots of different ways.

00:05:17.370 --> 00:05:21.280
If your company standardizes on a
particular kind of profiling software,

00:05:21.340 --> 00:05:23.300
then of course you should use that.

00:05:23.450 --> 00:05:27.290
But if not, there's other ways to do it.

00:05:27.710 --> 00:05:31.800
First thing you're going to want to
do is build a skeleton of your code.

00:05:31.820 --> 00:05:34.940
If your application already exists,
you're going to skip this part.

00:05:34.950 --> 00:05:39.410
But if you're writing a new application,
you're going to need Cocoa objects

00:05:39.540 --> 00:05:43.220
for each of the objects in
your AppleScript dictionary.

00:05:43.230 --> 00:05:47.280
You're going to have to have accessors
for all the properties of those objects.

00:05:47.310 --> 00:05:49.860
And you're going to have to have
accessors for all the elements that

00:05:49.920 --> 00:05:52.400
can be inside of those objects.

00:05:52.540 --> 00:05:56.460
If you have commands in your dictionary,
you're going to need methods

00:05:56.500 --> 00:05:57.560
to handle those as well.

00:05:57.610 --> 00:06:01.330
If the command is directed
at a particular object,

00:06:01.440 --> 00:06:06.100
such as send mail,
then the method goes on the mail object.

00:06:06.100 --> 00:06:09.990
If it's directed towards
the application itself,

00:06:09.990 --> 00:06:13.320
such as sleep,
then that method is going to

00:06:13.320 --> 00:06:15.220
be coded slightly differently.

00:06:15.220 --> 00:06:18.690
And it's going to attach
to the application rather

00:06:18.710 --> 00:06:20.710
than one of your objects.

00:06:21.920 --> 00:06:26.190
You're going to need to add some
kind of instrumentation to your code.

00:06:26.270 --> 00:06:27.680
What I do is really very simple.

00:06:28.150 --> 00:06:30.620
I want to create a record
of where my program's been.

00:06:30.790 --> 00:06:32.800
I want to know every
routine that I've called,

00:06:32.800 --> 00:06:36.840
maybe what the input looked like,
and maybe whether it passed or failed.

00:06:36.840 --> 00:06:39.930
So you're going to want to create
a record of where you've been.

00:06:39.930 --> 00:06:43.390
You're going to want to log any
relevant error conditions that occur.

00:06:43.390 --> 00:06:45.500
If a file is supposed
to open and it doesn't,

00:06:45.500 --> 00:06:47.530
you're going to want to log that.

00:06:48.560 --> 00:06:50.740
If you've got a problem
with leaks in your program,

00:06:50.740 --> 00:06:54.520
you can track allocation and deallocation
and make sure that everything balances.

00:06:54.560 --> 00:06:57.060
And like I said,
it doesn't have to be fancy.

00:06:57.090 --> 00:06:57.840
This is what I use.

00:06:57.850 --> 00:07:00.370
It's just a couple of macros,
and if you set that

00:07:00.440 --> 00:07:03.490
switch from zero to one,
all of these macros expand.

00:07:03.560 --> 00:07:07.580
When you run an AppleScript,
you'll get a very extensive list

00:07:07.580 --> 00:07:09.730
of what your program's done.

00:07:10.120 --> 00:07:12.340
And then if you set the switch
back to zero and recompile,

00:07:12.340 --> 00:07:13.290
it all just goes away.

00:07:13.290 --> 00:07:16.590
So it's not part of the
program that you ship.

00:07:17.710 --> 00:07:20.200
When you look at these logs,
you're going to want to

00:07:20.200 --> 00:07:20.900
do a couple of things.

00:07:20.900 --> 00:07:25.220
You're going to have to understand why
your code did what it did and justify it.

00:07:25.310 --> 00:07:28.300
You don't want to be running off
into the weeds and doing a lot of

00:07:28.360 --> 00:07:30.450
computation that's not necessary.

00:07:30.580 --> 00:07:34.330
If you generate an error condition,
you're going to want to investigate why.

00:07:34.450 --> 00:07:37.920
You might be testing an error condition,
so you're doing it on purpose.

00:07:38.000 --> 00:07:41.140
Or you might be trying to, like I said,
open a file and for some

00:07:41.140 --> 00:07:42.520
reason it's not there.

00:07:42.620 --> 00:07:45.520
You're going to want to balance all
of your allocation and deallocations

00:07:45.520 --> 00:07:47.600
and make sure that you're not leaking.

00:07:47.730 --> 00:07:51.270
And you're going to want to retain
a record of all of this so that

00:07:51.270 --> 00:07:54.580
when you repeat the test later,
you can make sure that it did

00:07:54.600 --> 00:07:56.350
the same thing the same way.

00:07:56.360 --> 00:07:59.090
Or it didn't do the
same thing the same way,

00:07:59.160 --> 00:08:01.560
and that's the fix to the problem.

00:08:04.100 --> 00:08:09.080
And this is an example of what
I see when I run one of my programs

00:08:09.160 --> 00:08:10.980
with the logging turned on.

00:08:10.980 --> 00:08:13.820
I've got my initials in there because
it gives me a nice string to search for

00:08:13.820 --> 00:08:16.180
that's not likely to occur anywhere else.

00:08:16.180 --> 00:08:18.620
It lets the people I work with
know who it was that put this

00:08:18.650 --> 00:08:21.720
log message in there in case they
want to know what it's about.

00:08:21.740 --> 00:08:27.720
And this here is fetching the startup
disk from the System Events program.

00:08:27.750 --> 00:08:30.460
It calls the startup disk

00:08:30.600 --> 00:08:44.500
[Transcript missing]

00:08:50.600 --> 00:09:54.600
[Transcript missing]

00:09:56.170 --> 00:09:58.990
You're going to want to test
all the corners of your program.

00:09:59.120 --> 00:10:03.040
You want to test trivial things,
things that you don't expect to work,

00:10:03.060 --> 00:10:06.540
edge conditions, really large numbers,
really small numbers.

00:10:06.590 --> 00:10:07.940
You're going to want to
force all the errors.

00:10:07.940 --> 00:10:11.970
What happens when you tell your program
to open a file that doesn't exist?

00:10:13.780 --> 00:10:19.160
You want to make sure that the end user
is going to receive a meaningful response

00:10:19.220 --> 00:10:22.850
that tells him something's gone wrong
and you need to change your script.

00:10:23.110 --> 00:10:28.620
One thing that AppleScript can't do
particularly well is get at the glue

00:10:28.730 --> 00:10:33.000
code that you write to bind your
view and your model objects together.

00:10:33.000 --> 00:10:37.000
AppleScript drives your model
objects more or less directly.

00:10:37.000 --> 00:10:42.960
If you've got a lot of glue code that
stages things back and forth between

00:10:42.960 --> 00:10:47.000
your model objects and your view objects,
you're going to need a way to test that.

00:10:47.000 --> 00:10:50.930
One way is to write less code.

00:10:51.020 --> 00:10:55.140
If you use something like Cocoa Bindings,
you'll write a lot less glue code and

00:10:55.170 --> 00:10:56.950
you'll have to do a lot less testing.

00:10:57.020 --> 00:11:00.310
You don't have to test the
code that you don't write.

00:11:01.640 --> 00:11:04.440
Apple's GUI scripting we
talked about last year.

00:11:04.440 --> 00:11:07.050
It can be used to do a lot of things.

00:11:07.350 --> 00:11:12.840
Mostly it can access things that are not
scriptable to begin with and allow you

00:11:12.840 --> 00:11:16.760
to get past blockages in your workflows.

00:11:17.000 --> 00:11:18.920
There are several things
it does particularly well.

00:11:19.120 --> 00:11:21.140
It does exercise all of your glue code.

00:11:21.180 --> 00:11:25.300
Since it does come in through the view,
it's going to exercise your glue code.

00:11:25.300 --> 00:11:28.190
And if that's what you're trying to do,
GUI scripting can be

00:11:28.190 --> 00:11:29.500
a good way to do that.

00:11:29.500 --> 00:11:32.090
It recreates end-user scenarios exactly.

00:11:32.090 --> 00:11:36.160
If you've got a report from the field
that if I select this menu and then

00:11:36.160 --> 00:11:40.710
this menu and then press this button,
something bad happens,

00:11:40.710 --> 00:11:45.720
then you can recreate that scenario
exactly in your tests and see what it is

00:11:45.720 --> 00:11:49.620
that the user is talking about and then
repeat that test over and over again.

00:11:50.830 --> 00:11:54.320
If you're doing a phased implementation
of AppleScript in your program,

00:11:54.320 --> 00:11:56.400
you're still going to want
to test the rest of it.

00:11:56.410 --> 00:11:58.110
And you can use GUI scripting to do that.

00:11:58.300 --> 00:12:01.000
You don't have to write any
code for GUI scripting to work.

00:12:01.010 --> 00:12:03.700
You just have to turn on accessibility.

00:12:03.750 --> 00:12:09.100
And if you're testing your program
specifically for 508 compliance,

00:12:09.120 --> 00:12:12.420
there's a tool that's going to
be introduced here this week for

00:12:12.420 --> 00:12:15.400
testing accessibility compliance.

00:12:15.550 --> 00:12:19.290
You can also use GUI scripting
to do that yourself,

00:12:19.290 --> 00:12:21.070
starting right away.

00:12:22.470 --> 00:12:26.660
You're going to need to use GUI scripting
if your workflow depends on other

00:12:26.660 --> 00:12:28.440
applications that you don't control.

00:12:28.610 --> 00:12:31.100
Perhaps your application
interacts with an application

00:12:31.100 --> 00:12:33.200
written by another company,
and that application

00:12:33.200 --> 00:12:35.760
either isn't scriptable,
or some key part of it that

00:12:35.760 --> 00:12:37.400
you need isn't scriptable.

00:12:37.510 --> 00:12:39.280
You can use GUI scripting
to get past that.

00:12:39.460 --> 00:12:41.400
This is what GUI scripting
was invented for,

00:12:41.400 --> 00:12:45.500
for unblocking workflows for
scripting the unscriptable.

00:12:45.800 --> 00:12:47.780
And it may be what your
customers are using.

00:12:47.790 --> 00:12:50.280
If your application's
not fully scriptable yet,

00:12:50.400 --> 00:12:55.280
your end users may have worked around
that by writing GUI scripts of their own.

00:12:55.440 --> 00:12:59.080
If they've integrated those
into mission-critical workflows,

00:12:59.160 --> 00:13:01.580
you're going to have to make sure
you don't break those things before

00:13:01.580 --> 00:13:03.930
you ship a revision of your code.

00:13:06.370 --> 00:13:08.520
GUI scripting has got some limitations,
though.

00:13:08.520 --> 00:13:11.970
It shouldn't be used as a substitute
for your own scriptability.

00:13:11.990 --> 00:13:14.380
It's easy to get started
on GUI scripting,

00:13:14.380 --> 00:13:16.000
but it's hard to maintain.

00:13:16.150 --> 00:13:19.030
One of the reasons is
a lot of applications,

00:13:19.080 --> 00:13:22.220
the view layer has a complicated
containment hierarchy.

00:13:22.240 --> 00:13:26.280
There's controls inside of
controls inside of controls.

00:13:26.310 --> 00:13:30.560
And if you ever revise your application,
relay out any of the screens,

00:13:30.580 --> 00:13:34.800
then you're going to have to also
revise all of your GUI scripts as well.

00:13:34.810 --> 00:13:37.960
And whatever it is you're trying to
do is going to be bounded by the GUI.

00:13:38.150 --> 00:13:40.870
You might not be able to generate
the stress conditions that you'd

00:13:40.900 --> 00:13:44.380
like to just through the GUI.

00:13:44.410 --> 00:13:47.250
And if that's the case,
you're going to want to use

00:13:47.250 --> 00:13:49.430
object model scripting to do that.

00:13:54.220 --> 00:13:56.870
The most important part, I said,
is sustaining the effort.

00:13:56.970 --> 00:13:59.150
It's easy to get started,
add a little bit of

00:13:59.150 --> 00:14:02.060
scriptability to your program,
be very happy with it,

00:14:02.240 --> 00:14:05.400
use it to do some important testing,
and then set it aside.

00:14:05.510 --> 00:14:09.600
You'll revise your program every year,
every couple of months.

00:14:09.780 --> 00:14:12.180
When you add that functionality,
you're going to want

00:14:12.230 --> 00:14:15.390
to add testing for it,
and the way to add testing is to

00:14:15.460 --> 00:14:18.030
add scriptability at the same time.

00:14:18.270 --> 00:14:21.340
Whenever you do revise your program,
you're going to want to run

00:14:21.820 --> 00:14:24.150
all of your prior tests,
everything that you've ever done.

00:14:24.350 --> 00:14:25.960
Make sure that you haven't
regressed anything.

00:14:25.960 --> 00:14:27.500
Make sure that you
haven't broken anything.

00:14:27.500 --> 00:14:29.600
So you should hang on
to all of your tests,

00:14:29.600 --> 00:14:32.460
and you should hang on to the
results of all of your tests,

00:14:32.460 --> 00:14:35.270
so you can run them over again and make
sure they do the same thing each time.

00:14:35.280 --> 00:14:38.130
And when you add bug
fixes to your program,

00:14:38.130 --> 00:14:41.440
or you get reports from
the field from end users,

00:14:41.440 --> 00:14:44.040
you're going to want to write
test cases that cover that.

00:14:44.290 --> 00:14:46.300
Make sure that the end
user has what he needs.

00:14:46.900 --> 00:14:49.470
You're going to put those in
your testing suite as well,

00:14:49.480 --> 00:14:53.160
and repeat them every single
time you revise your program.

00:14:55.430 --> 00:14:57.390
So, these are the things
I've talked about today.

00:14:57.500 --> 00:14:58.690
You've got to plan for scriptability.

00:14:58.760 --> 00:15:00.390
It doesn't just happen.

00:15:00.500 --> 00:15:03.280
You've got to instrument your code
so you know what happened and why.

00:15:03.400 --> 00:15:06.400
You've got to probe into all
of the corners of your code

00:15:06.400 --> 00:15:09.400
so that you're testing all of
it instead of just part of it.

00:15:09.400 --> 00:15:12.450
You want to use GUI scripting
where it's appropriate,

00:15:12.450 --> 00:15:15.400
but you're going to want to use
your own model object scripting

00:15:15.400 --> 00:15:17.400
to the greatest extent possible.

00:15:17.400 --> 00:15:19.400
And you want to keep at
it over and over again.

00:15:19.400 --> 00:15:21.400
Don't give up.

00:15:21.400 --> 00:15:28.500
And I'd like to thank you and turn
this over to Doug Simons from Redstone,

00:15:28.500 --> 00:15:30.400
and he's going to talk about Eggplant.

00:15:35.070 --> 00:15:35.520
Thanks, John.

00:15:35.520 --> 00:15:38.100
Good to see everyone this morning.

00:15:38.100 --> 00:15:41.060
I'm Doug Simons,
one of the principal developers

00:15:41.160 --> 00:15:44.440
at Redstone Software,
and as John said, we'll be talking about

00:15:44.440 --> 00:15:46.020
our eggplant testing tool.

00:15:46.020 --> 00:15:49.390
We also want to... Hello.

00:15:49.890 --> 00:15:52.730
We also want to give you a little
bit of an overview of some different

00:15:52.820 --> 00:15:56.010
approaches you might want to
consider in testing your application.

00:15:56.280 --> 00:15:59.260
For each type of testing
we're talking about,

00:15:59.310 --> 00:16:02.860
we'll look at what are the
goals of testing and what value

00:16:02.860 --> 00:16:05.240
automation brings to that process.

00:16:05.270 --> 00:16:08.590
And we'll try and give you some
concrete examples of each of these

00:16:08.690 --> 00:16:14.310
to give you some idea of how you
want to spend your testing efforts.

00:16:16.420 --> 00:16:19.610
So, as I said, we'll talk about Eggplant.

00:16:19.920 --> 00:16:23.970
Eggplant is an
interface-level testing tool,

00:16:23.980 --> 00:16:26.460
and we'll give you some
idea of how that works,

00:16:26.490 --> 00:16:29.140
because we'll be using that in some
of the examples that we're presenting.

00:16:30.830 --> 00:16:32.850
Some of the different kinds of
testing that we're going to talk

00:16:32.930 --> 00:16:37.900
about this morning are unit testing,
which is to test your

00:16:37.900 --> 00:16:39.200
code at a low level.

00:16:39.200 --> 00:16:42.970
Look at functional testing,
which is testing how a user

00:16:42.970 --> 00:16:47.090
might interact with your
application through use cases.

00:16:47.100 --> 00:16:49.720
Stress testing,
you want to test your application

00:16:49.720 --> 00:16:53.490
in depth and really push it to its
limits in a number of different ways.

00:16:53.500 --> 00:16:56.580
Performance testing,
to measure how fast your

00:16:56.890 --> 00:16:58.500
application is running.

00:16:59.480 --> 00:17:02.680
And integration testing,
to test your application in a

00:17:02.680 --> 00:17:06.290
broader picture of the context
of where it will be running.

00:17:08.910 --> 00:17:11.360
will give you a little bit of idea
of some of the types of information

00:17:11.360 --> 00:17:15.800
and results you might be looking
to get from your testing process.

00:17:15.860 --> 00:17:18.820
And finally,
we'll take a look at some additional

00:17:18.830 --> 00:17:21.020
uses of automation beyond testing.

00:17:22.560 --> 00:17:24.140
So let me tell you a little
bit about how Eggplant works.

00:17:24.270 --> 00:17:27.640
As I said,
it's an interface-level testing tool.

00:17:28.020 --> 00:17:34.170
It, in fact, allows you to drive your
application exactly as a user would.

00:17:34.320 --> 00:17:35.480
So how does that work?

00:17:35.670 --> 00:17:38.190
Well, it's a two-computer system.

00:17:38.240 --> 00:17:42.780
Eggplant runs on your Mac OS X machine,
and it connects over a TCP/IP network

00:17:43.150 --> 00:17:46.360
to any computer running a VNC server.

00:17:46.420 --> 00:17:49.050
How many of you have
used VNC or heard of it?

00:17:49.350 --> 00:17:50.670
Yeah, quite a few.

00:17:50.680 --> 00:17:55.130
VNC is a neat program that is an
open-source software that allows

00:17:55.130 --> 00:17:58.180
you to access a computer remotely.

00:17:58.180 --> 00:18:01.990
People use it to access their home
computer from work or vice versa.

00:18:02.030 --> 00:18:05.320
And Eggplant has a
VNC client built into it,

00:18:05.330 --> 00:18:09.970
which allows it to access any
computer running a VNC server,

00:18:10.010 --> 00:18:13.680
which is pretty much
any computer out there.

00:18:13.680 --> 00:18:18.200
The VNC process gives Eggplant a
view of the screen of the other

00:18:18.200 --> 00:18:22.970
computer and allows it to control
the keyboard and the mouse.

00:18:23.130 --> 00:18:27.100
To that, Eggplant adds scripting,
which provides automation, of course.

00:18:27.100 --> 00:18:29.370
We have a scripting
language called SenseTalk,

00:18:29.380 --> 00:18:33.340
which is a very easy-to-understand,
English-like language that gives

00:18:33.400 --> 00:18:38.320
you all the control that you need
to develop some sophisticated tests.

00:18:38.320 --> 00:18:42.210
And so the end result is that
Eggplant can drive any software,

00:18:42.210 --> 00:18:45.380
it doesn't matter what
language it is written in,

00:18:45.380 --> 00:18:49.150
since we're driving directly
through the user interface,

00:18:49.150 --> 00:18:52.220
and can be running on
any operating system.

00:18:55.350 --> 00:18:58.230
So let's talk a little bit
about unit testing now.

00:18:58.250 --> 00:19:00.860
The goal here is to verify
the correctness of your

00:19:00.860 --> 00:19:03.180
application at the code level.

00:19:03.180 --> 00:19:07.930
Ordinarily, unit tests are written to
test an individual function or

00:19:07.930 --> 00:19:10.140
method within your application.

00:19:10.140 --> 00:19:14.020
And in recent years,
a number of agile development

00:19:14.020 --> 00:19:17.260
methodologies have become popular,
such as extreme programming.

00:19:17.260 --> 00:19:20.560
Any of you extreme programmers
or agile developers?

00:19:20.560 --> 00:19:25.050
Not too many in this crowd.

00:19:26.050 --> 00:19:31.210
One common component to many agile
approaches to software development

00:19:31.650 --> 00:19:33.140
is test-driven development.

00:19:33.140 --> 00:19:39.210
The idea of test-driven development
is for developers to write

00:19:39.210 --> 00:19:41.740
tests to verify their code.

00:19:41.740 --> 00:19:45.170
Quite often,
the tests are written before the code,

00:19:45.280 --> 00:19:49.130
and then you can develop the
code to satisfy those tests.

00:19:49.140 --> 00:19:55.760
There are some good open-source free
tools for doing this kind of testing.

00:19:56.160 --> 00:19:59.390
The first one was JUnit,
which is used for doing unit

00:19:59.390 --> 00:20:01.720
testing of Java applications.

00:20:01.720 --> 00:20:07.320
Since then, there have been a lot of
other tools of a similar sort.

00:20:07.440 --> 00:20:11.770
There's one called OCUnit, for example,
to do unit testing of Objective-C code

00:20:11.860 --> 00:20:13.810
that we use for our unit testing.

00:20:13.820 --> 00:20:17.170
AppleScript, of course,
can also test your code

00:20:17.280 --> 00:20:20.830
at a fairly low level,
interacting either with

00:20:20.830 --> 00:20:25.710
individual modules or testing
the model of your application.

00:20:27.580 --> 00:20:33.340
and John did a good job of covering a lot
of the benefits that automation brings in

00:20:33.340 --> 00:20:38.890
terms of repeatability and consistency.

00:20:39.210 --> 00:20:41.740
One of the other things
that's a great advantage,

00:20:41.740 --> 00:20:44.760
of course,
of automation is that you can build

00:20:44.760 --> 00:20:49.890
these unit tests into your build process,
providing a continual feedback to

00:20:49.900 --> 00:20:56.780
the developers as they're developing
the application and revising it.

00:20:56.990 --> 00:20:59.700
So that can be a big benefit.

00:21:01.280 --> 00:21:03.950
Functional testing is a little
bit higher-level testing.

00:21:03.970 --> 00:21:07.440
Now we're looking at how users
interact with the system.

00:21:07.440 --> 00:21:11.310
And the goal here is to verify the
requirements of your application.

00:21:11.320 --> 00:21:15.620
Most applications are developed
beginning with some requirements

00:21:15.620 --> 00:21:20.400
that tell you what it is that the
application is supposed to be able to do.

00:21:21.100 --> 00:21:25.150
And frequently these requirements are
written up in the form of use cases,

00:21:25.150 --> 00:21:29.840
which are individual scenarios of how a
user would walk through some particular

00:21:29.950 --> 00:21:31.520
process within the application.

00:21:31.520 --> 00:21:35.260
A lot of

00:21:36.120 --> 00:21:40.530
Functional testing is done manually,
and frequently this is done by

00:21:40.780 --> 00:21:44.030
developing test cases that are
modeled after those use cases.

00:21:44.060 --> 00:21:46.810
Again,
just so a manual tester can walk the

00:21:46.810 --> 00:21:50.800
application through some particular
sequence and make sure that it's

00:21:50.950 --> 00:21:52.420
performing the way that it should.

00:21:52.420 --> 00:21:57.760
Using an interface-level
tool such as Eggplant,

00:21:57.760 --> 00:22:04.290
you can automate those kinds of tests,
and this allows your

00:22:04.290 --> 00:22:08.580
regression tests to be run,
again, after every build for

00:22:08.580 --> 00:22:11.480
your functional tests,
in very much the same way

00:22:11.600 --> 00:22:13.200
that your unit tests are run.

00:22:17.400 --> 00:22:20.340
So I'd like to invite my
colleague Jonathan Gillaspie up.

00:22:20.340 --> 00:22:25.260
He's going to be doing the demos today,
and he's going to show you how we'd use

00:22:25.260 --> 00:22:28.170
Eggplant to do some functional testing.

00:22:29.240 --> 00:22:30.510
Thanks, Doug.

00:22:30.610 --> 00:22:31.280
Good morning.

00:22:31.290 --> 00:22:34.640
As our first demonstration,
I'm going to be showing you an example,

00:22:34.640 --> 00:22:37.200
as Doug said,
of a simple functional test script.

00:22:37.200 --> 00:22:40.200
But for those of you who haven't
seen our product Eggplant before,

00:22:40.210 --> 00:22:43.760
I also want to just give you an
idea of how easy it is to start

00:22:43.810 --> 00:22:46.150
writing test scripts using that.

00:22:46.370 --> 00:22:50.170
So as Doug mentioned,
Eggplat works by connecting

00:22:50.250 --> 00:22:51.380
to a remote machine.

00:22:51.460 --> 00:22:56.920
So let's go ahead and start by
connecting to my test system over here.

00:23:01.200 --> 00:23:05.380
And you can see here that I'm
controlling the remote machine directly,

00:23:05.380 --> 00:23:08.710
sending it keyboard and mouse events.

00:23:09.240 --> 00:23:11.440
Just like this.

00:23:11.440 --> 00:23:17.200
So if we wanted to create,
let's say we had a simple

00:23:17.200 --> 00:23:22.130
use case that we wanted to
create a functional test for.

00:23:22.350 --> 00:23:24.870
For my demonstration,
my first demonstration this morning,

00:23:24.890 --> 00:23:27.450
I'm going to go ahead and just
do a little simple use case

00:23:27.450 --> 00:23:29.160
using Apple's iTunes application.

00:23:29.190 --> 00:23:32.550
So here you can see we've just
got a real simple use case.

00:23:32.610 --> 00:23:34.250
We want to go ahead and launch iTunes.

00:23:34.290 --> 00:23:37.200
We want to search the iTunes
library for a particular song.

00:23:37.200 --> 00:23:38.640
We want to play that song.

00:23:39.230 --> 00:23:41.810
And when that song's finished,
we want to go ahead and quit iTunes.

00:23:41.870 --> 00:23:45.410
Just a typical use case scenario.

00:23:45.460 --> 00:23:48.680
So let's see how we'd go about
scripting that using Eggplant.

00:23:49.220 --> 00:23:52.800
The first thing we need to
do is create a test suite.

00:23:52.830 --> 00:23:55.810
A suite in Eggplant is just a
collection of scripts and other

00:23:55.810 --> 00:23:58.890
resources necessary to run a test.

00:24:00.200 --> 00:24:06.150
And let's go ahead and create
our first simple functional test.

00:24:08.470 --> 00:24:12.380
Now I could just start writing
a test script right here using

00:24:12.600 --> 00:24:14.400
Eggplant's scripting language,
SenseTalk.

00:24:14.400 --> 00:24:19.080
But instead,
let me take advantage of Eggplant's

00:24:19.080 --> 00:24:23.360
script generation mode that makes
it real easy to write a test.

00:24:23.400 --> 00:24:27.390
So I do that by switching from
live mode into capture mode.

00:24:27.400 --> 00:24:30.400
Now I'm no longer interacting
with the remote machine directly.

00:24:30.400 --> 00:24:32.810
Instead,
I have a selection rectangle that

00:24:32.810 --> 00:24:37.520
I'm using to identify elements of the
remote machine that I want to work with,

00:24:37.690 --> 00:24:38.400
graphically.

00:24:40.440 --> 00:24:44.620
So the first step in our use case
was we wanted to launch iTunes.

00:24:44.620 --> 00:24:47.390
So we're going to go ahead and do
that the exact same way a user would,

00:24:47.390 --> 00:24:49.640
by clicking on the iTunes
application down here in the dock.

00:24:49.760 --> 00:24:54.290
So I select the iTunes application,
and I tell Eggplant, using the toolbar,

00:24:54.380 --> 00:24:56.970
that I want to click on that image.

00:24:56.980 --> 00:25:00.640
Eggplant brings up a Save Image dialog,
and I go ahead and name

00:25:00.640 --> 00:25:02.090
the image and save it.

00:25:02.860 --> 00:25:06.860
And when that happens, when I do that,
three things happen.

00:25:06.860 --> 00:25:11.120
The first is that Eggplant stores that
image over here in our test suite,

00:25:11.150 --> 00:25:13.100
the iTunes icon.

00:25:13.210 --> 00:25:15.760
The second thing that it
does is it goes ahead,

00:25:15.890 --> 00:25:17.860
let me make that a little
bigger so you can all see it.

00:25:17.900 --> 00:25:21.730
Second thing is it does is it
actually writes that script

00:25:21.730 --> 00:25:23.610
command into our script.

00:25:23.680 --> 00:25:27.410
And the third thing is it does is
it actually executes that line.

00:25:27.500 --> 00:25:29.180
Click the iTunes icon.

00:25:29.180 --> 00:25:32.760
And when that line is executed,
what Eggplant does is actually

00:25:32.760 --> 00:25:35.960
searches through the remote
screen to find that image,

00:25:35.990 --> 00:25:37.480
and when it finds it, it clicks on it.

00:25:37.540 --> 00:25:42.940
You can see here that it's brought
up iTunes on the remote system.

00:25:44.600 --> 00:25:46.580
So the next step in our use
case is we want to search the

00:25:46.580 --> 00:25:48.640
library for a particular song.

00:25:48.640 --> 00:25:50.920
As a user,
we do that by clicking and entering

00:25:50.920 --> 00:25:52.800
something up here in the search field.

00:25:52.800 --> 00:25:56.140
And we identify the search field
by this search label right here.

00:25:56.140 --> 00:25:58.780
Of course, we don't want to click
directly on the search label.

00:25:58.800 --> 00:26:03.220
So Eggplant allows us to set what we
call a hotspot so that we can interact

00:26:03.420 --> 00:26:05.660
to positions relative to an image.

00:26:05.730 --> 00:26:09.780
So I'll just move that hotspot
directly above the search label.

00:26:09.780 --> 00:26:14.290
And again, tell Eggplant we want to click
there in the search field.

00:26:15.720 --> 00:26:18.600
You can see we have an
insertion point now.

00:26:18.600 --> 00:26:24.600
And we can send keystroke commands
to the remote machine just as easily.

00:26:24.690 --> 00:26:27.210
So let's go ahead and see if
there are any eggplant songs

00:26:27.210 --> 00:26:29.230
over here in my iTunes app.

00:26:30.140 --> 00:26:31.420
And sure enough, there's one.

00:26:31.460 --> 00:26:36.370
So the next step in our use case
is to go ahead and play that song.

00:26:36.410 --> 00:26:38.380
So we just do that, again,
the same way a user would,

00:26:38.380 --> 00:26:40.490
by clicking on the Play button.

00:27:10.900 --> 00:27:19.740
and David So we want to
continue on with our use case.

00:27:19.740 --> 00:27:22.980
We want to make sure to
wait for that song to end.

00:27:23.000 --> 00:27:27.160
iTunes goes ahead and changes
the play button to a pause

00:27:27.160 --> 00:27:29.410
button while the song is playing.

00:27:29.420 --> 00:27:31.520
So what we want to do is
wait for that pause button to

00:27:31.520 --> 00:27:32.890
return back to a play button.

00:27:33.050 --> 00:27:36.700
That's how we know the song has finished,
again, just like a user does.

00:27:36.720 --> 00:27:39.840
So eggplant can wait for certain
elements to appear on the remote

00:27:39.840 --> 00:27:41.480
screen using the wait for command.

00:27:44.620 --> 00:27:47.920
The WAV4 command allows us to
specify a maximum period of time

00:27:47.950 --> 00:27:50.580
for a particular image to show up.

00:27:50.900 --> 00:27:53.180
In this example,
we'll go ahead and just give

00:27:53.180 --> 00:27:54.720
it a maximum of 90 seconds.

00:27:54.750 --> 00:27:58.980
If the image doesn't appear in that time,
it's going to quit it,

00:27:59.210 --> 00:28:02.610
raise an exception, and fail the script.

00:28:04.900 --> 00:28:11.510
Yeah, I'm just naming these images
as I record the script.

00:28:15.290 --> 00:28:17.250
Yes, actually if you look over
here in our test script,

00:28:17.320 --> 00:28:19.340
we can actually see all
these images being recorded.

00:28:19.340 --> 00:28:23.630
I could have actually reused the
play image from before and that

00:28:23.630 --> 00:28:26.200
would have been a better way to go.

00:28:26.270 --> 00:28:30.110
So then the last step in our script is to
go ahead and quit the iTunes application.

00:28:30.280 --> 00:28:33.370
We'll do that here through the menu.

00:28:48.460 --> 00:28:53.120
So here we've written our first simple
functional test script using eggplant.

00:28:53.130 --> 00:28:54.570
And I can go ahead and run it here now.

00:28:54.660 --> 00:29:06.120
One, two, three, four, five.

00:29:06.120 --> 00:29:12.800
If there was a cow from the eggplant
that ate Chicago-- You can see just

00:29:12.800 --> 00:29:14.060
how analogous the functional test

00:29:32.260 --> 00:29:38.620
So that's our first demonstration on
functional testing using eggplant.

00:29:38.930 --> 00:29:40.040
Thanks, Jonathan.

00:29:40.040 --> 00:29:42.180
We have slides again.

00:29:49.410 --> 00:29:52.160
Let's talk a little bit
now about stress testing.

00:29:52.160 --> 00:29:54.990
Functional testing and unit
testing are great to ensure that

00:29:55.080 --> 00:29:58.560
your application is working and
doing what it's supposed to do,

00:29:58.560 --> 00:29:59.540
what it's designed to do.

00:29:59.540 --> 00:30:03.700
But you also are going to want to
push your application a little harder.

00:30:03.700 --> 00:30:09.010
As John mentioned,
put in some unexpected conditions,

00:30:09.070 --> 00:30:13.500
some things that are
likely to cause errors.

00:30:13.540 --> 00:30:17.700
Test some of the boundary conditions
there in your application.

00:30:18.680 --> 00:30:22.140
You don't really expect your
user to enter negative numbers,

00:30:22.140 --> 00:30:24.600
perhaps,
for a duration of time or something.

00:30:24.600 --> 00:30:26.810
But you know they will eventually.

00:30:26.820 --> 00:30:30.640
And so you want to be sure to test
some of those exceptional situations.

00:30:30.640 --> 00:30:34.720
So the goal here is not just to
verify that your application is

00:30:34.720 --> 00:30:38.430
doing what it's designed to do,
but that it's not doing what

00:30:38.430 --> 00:30:39.930
it's designed not to do.

00:30:39.960 --> 00:30:42.510
And so you want to push it a bit there.

00:30:42.520 --> 00:30:48.580
So the goal here is really
to find bugs and track them.

00:30:48.680 --> 00:30:51.280
down to their source if you can.

00:30:51.390 --> 00:30:54.940
Automation plays a really
critical role here.

00:30:54.940 --> 00:30:59.720
It's always, of course,
very nice to be able to automate things,

00:30:59.720 --> 00:31:01.120
to save some time and effort.

00:31:01.120 --> 00:31:04.490
But when it comes to this
kind of stress testing,

00:31:04.490 --> 00:31:08.160
you really want to be able
to do things repeatedly,

00:31:08.160 --> 00:31:11.560
and scripts do that a lot
better than people do.

00:31:11.560 --> 00:31:15.000
So you're going to want to be able
to iterate over large sets of data,

00:31:15.010 --> 00:31:18.470
to try your application with
different combinations of input,

00:31:19.080 --> 00:31:22.310
and also to be able to run tests
repeatedly to reproduce any

00:31:22.310 --> 00:31:24.640
intermittent crashes you might have.

00:31:24.640 --> 00:31:30.060
How many of you ever had bugs or reports
of bugs that were very hard to reproduce?

00:31:31.600 --> 00:31:33.180
They happen.

00:31:33.200 --> 00:31:37.840
In fact,
we had one in Eggplant a few months ago.

00:31:37.840 --> 00:31:41.700
People ask us sometimes whether
we use Eggplant to test Eggplant.

00:31:41.700 --> 00:31:43.400
As a matter of fact, we do.

00:31:43.400 --> 00:31:46.020
We have a test that we
call our EP squared test,

00:31:46.020 --> 00:31:50.240
or Eggplant squared, in which Eggplant is
driving another machine,

00:31:50.240 --> 00:31:52.910
which is also running Eggplant,
to create and run some

00:31:52.910 --> 00:31:54.660
tests on a third machine.

00:31:57.020 --> 00:32:00.150
When we had this occasional
crash showing up,

00:32:00.150 --> 00:32:04.980
we were able to run the Eggplant
squared test repeatedly overnight.

00:32:04.980 --> 00:32:08.230
It takes about three or four minutes
for each time through the test.

00:32:08.300 --> 00:32:12.300
Not something that a person would want
to sit there and do a hundred times over.

00:32:12.300 --> 00:32:15.930
By doing this, we were able to find that
this particular crash occurred

00:32:16.320 --> 00:32:18.240
once or twice every 100 runs.

00:32:18.260 --> 00:32:21.490
We were able to track down
where it was occurring and

00:32:21.490 --> 00:32:23.680
isolate it and fix the problem.

00:32:23.680 --> 00:32:27.000
I'd like to ask Jonathan to
give us some more information.

00:32:27.090 --> 00:32:30.150
a little demo of a data-driven test.

00:32:32.130 --> 00:32:33.530
Thanks again.

00:32:33.890 --> 00:32:36.290
As Doug and John Comiskey
before him pointed out,

00:32:36.400 --> 00:32:40.150
many times when you're looking
to stress test your application,

00:32:40.150 --> 00:32:43.760
you want to try providing
large amounts of varied data,

00:32:43.780 --> 00:32:48.510
and sometimes you want to try doing the
exact same actions over and over again.

00:32:49.230 --> 00:32:52.150
So for this demonstration,
I've created a simple

00:32:52.500 --> 00:32:55.250
little data file here.

00:32:55.260 --> 00:33:00.400
And I'm going to use this data file
to drive the address book application

00:33:00.400 --> 00:33:05.730
to just create some records in
address book and then look up the

00:33:05.730 --> 00:33:09.010
phone numbers once we've done that.

00:33:09.020 --> 00:33:10.830
So let me bring up this script here.

00:33:10.830 --> 00:33:15.140
I'll try and make that
a little bit larger.

00:33:19.270 --> 00:33:22.220
So I'm actually going to walk through
this script using a new feature of

00:33:22.430 --> 00:33:25.640
our upcoming release of Eggplant,
which is actually an

00:33:25.640 --> 00:33:27.580
interactive debugger.

00:33:29.050 --> 00:33:32.240
So when I run the script,
it's going to pause here after

00:33:32.450 --> 00:33:34.360
the pause script command.

00:33:34.360 --> 00:33:40.560
The first line in the script
is to call another script.

00:33:40.560 --> 00:33:43.160
Here you see that
eggplant is fully modular.

00:33:43.160 --> 00:33:46.460
We can call other scripts
passing parameters.

00:33:46.460 --> 00:33:50.790
This particular script actually
will launch an application on the

00:33:50.790 --> 00:33:53.310
remote system using the finder.

00:33:55.400 --> 00:33:57.820
Let's step through that.

00:33:57.820 --> 00:34:00.580
Or actually, I'll continue through that.

00:34:09.580 --> 00:34:14.840
So here we are in the
address book application.

00:34:16.090 --> 00:34:19.640
It's very easy to parse data
files and work with data in our

00:34:19.640 --> 00:34:21.160
SenseTalk scripting language.

00:34:21.160 --> 00:34:25.330
All we need to do there is create
a simple repeat loop with a

00:34:25.400 --> 00:34:29.490
simple construct like repeat with
each line of file my data file.

00:34:29.500 --> 00:34:33.670
Then inside that repeat loop we have
a number of interactive commands

00:34:33.700 --> 00:34:35.000
similar to the first script we did.

00:34:35.000 --> 00:34:37.500
We're just hitting command
N to create a new card.

00:34:37.500 --> 00:34:41.090
We're typing in the first
name from the data file and

00:34:41.390 --> 00:34:44.350
then the last name and so on.

00:34:44.360 --> 00:34:47.800
and entering all these
through the user interface.

00:34:50.760 --> 00:34:55.740
So we've gone ahead and entered all
five of our records for this data test.

00:34:55.860 --> 00:34:58.860
And now, like I said,
we want to go ahead and validate the

00:34:58.860 --> 00:35:01.630
information that Eggplant entered.

00:35:01.700 --> 00:35:06.800
So we'll go ahead and do that by
just stepping in here and using the

00:35:06.800 --> 00:35:09.700
find feature of the address book.

00:35:09.700 --> 00:35:12.960
Again, very similar,
just interactive commands

00:35:12.960 --> 00:35:14.690
with the remote system.

00:35:16.430 --> 00:35:20.130
and David So I'll go ahead
and let that continue running.

00:35:20.350 --> 00:35:24.010
A really important point I'd like to
make here is that this is all going

00:35:24.120 --> 00:35:28.780
directly through the user interface,
just the way users would.

00:35:28.780 --> 00:35:32.780
Back to our eggplant squared bug.

00:35:33.260 --> 00:35:37.000
The eggplant squared bug was a bug
with the interface of our application.

00:35:37.000 --> 00:35:39.260
It was a problem with
some thread timing we had,

00:35:39.340 --> 00:35:43.560
which is one of the reasons it
only showed up occasionally.

00:35:44.450 --> 00:35:48.320
And testing it from,
doing our unit tests and our model

00:35:48.320 --> 00:35:52.110
tests didn't expose this bug,
but running it through Eggplant

00:35:52.230 --> 00:35:54.080
through the interface did.

00:35:54.560 --> 00:35:59.450
This becomes increasingly more important
with the faster machines like the G5s and

00:35:59.450 --> 00:36:04.270
even more important with multiprocessor
machines that are really likely to expose

00:36:04.370 --> 00:36:06.890
threading problems that you might have.

00:36:07.740 --> 00:36:11.340
So that's a basic example of how
you would use Eggplant with some

00:36:11.340 --> 00:36:15.700
data to do some data-driven testing
and vary the input and results.

00:36:15.700 --> 00:36:16.670
Thanks.

00:36:16.750 --> 00:36:17.700
Thanks, Jonathan.

00:36:20.400 --> 00:36:30.100
Let's take a little look
at performance testing now.

00:36:30.100 --> 00:36:32.960
Performance testing, of course,
is designed to measure the speed of your

00:36:32.960 --> 00:36:34.590
application and how fast it's running.

00:36:34.600 --> 00:36:37.240
Quite often, developers,
when they think about

00:36:37.320 --> 00:36:40.420
performance testing,
are going to be concerned with the

00:36:40.430 --> 00:36:45.890
speed of their code and the cool new
algorithm that they've devised to wring

00:36:46.050 --> 00:36:49.320
the most out of their G5 processor.

00:36:50.400 --> 00:36:52.870
But there's another type of
performance that's important also,

00:36:52.880 --> 00:36:57.150
and that's the responsiveness of the
application as a user is using it.

00:36:57.240 --> 00:37:01.500
And this is very important, of course,
because you want your users to be

00:37:01.500 --> 00:37:06.020
happy with your application and not
frustrated as things are proceeding.

00:37:06.020 --> 00:37:10.480
So, for example, you might have a search
feature in your application,

00:37:10.480 --> 00:37:15.500
and you could test that with an eggplant
script that clicks on the search button

00:37:15.500 --> 00:37:18.800
and then waits for up to 30 seconds,
perhaps, for whatever the next thing

00:37:18.800 --> 00:37:20.380
is to show up on the screen
to indicate that it's running.

00:37:20.440 --> 00:37:22.400
And you can see that
the search has finished.

00:37:22.400 --> 00:37:25.260
And this is fine,
but 30 seconds is going to be an

00:37:25.260 --> 00:37:29.400
awful long time for your users to wait
if it's actually taking that long.

00:37:29.400 --> 00:37:35.400
And this script will only fail if,
in fact, it takes longer than 30 seconds.

00:37:35.400 --> 00:37:39.950
By adding the lines shown in blue here,
you could check to see how long it

00:37:39.950 --> 00:37:42.400
really takes that search to come back.

00:37:42.400 --> 00:37:45.770
And if it's greater than five seconds,
then you could log a warning message to

00:37:45.770 --> 00:37:49.400
indicate that there's a problem you may
want to look into in your application.

00:37:51.920 --> 00:37:56.270
So, of course, in the case where you're
testing performance,

00:37:56.300 --> 00:37:59.800
it's really important to be able
to gather consistent and repeatable

00:37:59.800 --> 00:38:03.780
timing data that you can compare
from one build of your application

00:38:03.830 --> 00:38:07.110
to the next to see if you're,
in fact, slowing down or have made

00:38:07.240 --> 00:38:09.030
some improvements there.

00:38:12.270 --> 00:38:16.360
Final type of testing we'd like to talk
about today is integration testing.

00:38:16.360 --> 00:38:21.970
The goal here is to really ensure a
quality experience for your users.

00:38:22.180 --> 00:38:27.140
Your application may work just
fine through your use cases and

00:38:27.140 --> 00:38:31.730
your unit tests and all that,
but chances are nowadays your

00:38:31.730 --> 00:38:33.600
application doesn't live on its own.

00:38:33.600 --> 00:38:36.400
It's going to be interacting
with other applications.

00:38:36.400 --> 00:38:39.460
It has to be able to go out
and live in the real world.

00:38:39.460 --> 00:38:44.510
So it's really important that tested
in that kind of an environment.

00:38:44.710 --> 00:38:48.970
You may also want to test a
complete process end-to-end.

00:38:49.040 --> 00:38:54.600
If your application, for example,
produces data that it can export that can

00:38:54.600 --> 00:38:56.820
then be read into an Excel spreadsheet,
perhaps,

00:38:56.870 --> 00:38:59.700
or a Quicken or something like that,
you're going to want to test

00:39:00.100 --> 00:39:06.990
not only that your program runs,
but that the data that it produces can

00:39:06.990 --> 00:39:09.040
be read in those other applications
and looks the way it should.

00:39:09.770 --> 00:39:13.470
You also may have different
configurations that you want to test.

00:39:13.570 --> 00:39:19.500
Perhaps your program has some plug-ins
or other modules that are optional.

00:39:19.560 --> 00:39:22.920
And so you're going to want to test
various combinations of things and

00:39:22.980 --> 00:39:27.850
perhaps run all of your tests in each
of these different configurations.

00:39:27.930 --> 00:39:31.770
And finally,
if you have a cross-platform application,

00:39:32.000 --> 00:39:37.100
Obviously you're going to want to test it
on different platforms that it runs on.

00:39:37.180 --> 00:39:41.160
Perhaps you have a web-based
application and there you need to

00:39:41.160 --> 00:39:46.070
not only test on different platforms,
but in each of the different browsers

00:39:46.070 --> 00:39:48.600
that you support on those platforms.

00:39:48.600 --> 00:39:52.120
Even if you don't have a
cross-platform application,

00:39:52.210 --> 00:39:56.880
you may want to test your program
running on different types of hardware,

00:39:56.880 --> 00:39:58.100
different Macs.

00:39:58.100 --> 00:40:02.680
This is a place where a remote
testing approach like Eggplant

00:40:02.750 --> 00:40:05.190
offers can come in handy.

00:40:05.240 --> 00:40:08.280
Perhaps you have a G5 that's in a
different department at your company and

00:40:08.280 --> 00:40:12.780
you'd like to be able to run your tests
against that when you reach this stage.

00:40:13.190 --> 00:40:18.410
You may have hardware at a
vendor's site even that you'd

00:40:18.420 --> 00:40:23.460
like to run your tests on,
or perhaps at the Apple ADC compatibility

00:40:23.460 --> 00:40:27.700
labs in Cupertino,
and that can be done remotely.

00:40:28.550 --> 00:40:33.380
Obviously, again,
automation provides consistent

00:40:33.380 --> 00:40:34.940
and repeatable results.

00:40:34.940 --> 00:40:38.030
If you're running your
tests automatically,

00:40:38.240 --> 00:40:45.770
you can do much more testing than you
would if you only had manual testers.

00:40:46.620 --> 00:40:51.220
One of the big wins, obviously,
with automation always is that

00:40:51.250 --> 00:40:55.730
you're eliminating a lot of your
manual testing time and giving

00:40:55.730 --> 00:40:57.630
a much more efficient execution.

00:40:57.640 --> 00:41:03.690
One of our customers develops tape
backup software that runs on Unix systems

00:41:03.690 --> 00:41:07.700
and works with a lot of different tape
drives from different manufacturers.

00:41:08.340 --> 00:41:12.770
Every time they get a new model of
tape drive from one of the vendors

00:41:12.770 --> 00:41:18.010
or want to revise their application,
they have to validate that everything

00:41:18.010 --> 00:41:22.260
is still working on all of these
different devices and on the different

00:41:22.260 --> 00:41:24.660
operating systems that they support.

00:41:24.660 --> 00:41:27.350
When they had a manual
process to do this,

00:41:27.350 --> 00:41:32.270
it took them about two weeks to go
through all of their validation tests.

00:41:32.280 --> 00:41:36.460
With Eggplant, they were able to write a
script that runs in eight hours.

00:41:37.120 --> 00:41:42.090
By being able to run their
tests overnight like this,

00:41:42.090 --> 00:41:45.480
of course, they not only saved a huge
amount of time and effort,

00:41:45.480 --> 00:41:48.620
but they were actually able
to modify their approach to

00:41:48.620 --> 00:41:50.300
developing their software.

00:41:50.300 --> 00:41:56.800
You can imagine with a two-week testing
cycle at the end of every build,

00:41:56.800 --> 00:42:00.340
you're not going to be able
to innovate quite as quickly.

00:42:03.440 --> 00:42:06.750
So, Johnson's going to show us kind
of an interesting integration

00:42:06.810 --> 00:42:09.620
test now on the demo machine.

00:42:09.620 --> 00:42:10.620
Thanks.

00:42:10.620 --> 00:42:14.660
So, for this next script,
let's say that my company wants to

00:42:14.660 --> 00:42:19.120
offer a free trial license of its
software to all WWDC attendees.

00:42:19.120 --> 00:42:23.040
We want to allow people
to come to the website,

00:42:23.040 --> 00:42:26.960
fill out a web form,
get a trial license key,

00:42:26.960 --> 00:42:30.420
download the software,
put in that license key,

00:42:30.420 --> 00:42:32.100
run the application.

00:42:33.420 --> 00:42:37.890
And test interactions that our
software has with the operating system.

00:42:37.900 --> 00:42:42.370
We can validate this entire process
using something like Eggplant.

00:42:42.400 --> 00:42:46.770
So, let's go ahead and just look
at this integration script

00:42:46.770 --> 00:42:48.930
at a real high level here.

00:42:50.850 --> 00:42:55.400
Again, we're going to reuse our
launch application command to

00:42:55.400 --> 00:42:58.120
go ahead and launch up Safari.

00:42:58.330 --> 00:43:00.800
And then we're just going to
go through that entire process.

00:43:00.800 --> 00:43:05.510
We're going to go test the free
trial download form by going to

00:43:05.510 --> 00:43:11.790
URL and filling out the form and then
grabbing the license key off the site.

00:43:12.580 --> 00:43:17.550
Then we want to go ahead and download
the application using Safari,

00:43:17.550 --> 00:43:21.080
make sure that downloads and the disk
image unpacks and installs correctly.

00:43:21.080 --> 00:43:24.440
Then we want to go ahead and
move on and launch our eggplant

00:43:24.440 --> 00:43:28.560
application and put in the license
key that we got from the website.

00:43:28.560 --> 00:43:32.190
Then you could imagine we would
actually run a whole battery,

00:43:32.200 --> 00:43:35.200
a whole series of functional
use case tests like we did

00:43:35.380 --> 00:43:37.200
in the first demonstration.

00:43:37.200 --> 00:43:39.970
But in particular,
we want to do things like

00:43:39.970 --> 00:43:41.630
test its interactions.

00:43:42.080 --> 00:43:44.540
All of eggplant's documentation
is written as PDF,

00:43:44.540 --> 00:43:46.730
so we want to go ahead and
make sure that they all open up

00:43:46.830 --> 00:43:50.820
properly in the preview application
and they can be read and seen.

00:43:50.820 --> 00:43:53.380
And finally,
we want to go ahead and clean up and

00:43:53.500 --> 00:43:57.420
quit out of that and go ahead and
even test the uninstallation process.

00:43:57.420 --> 00:44:01.540
So we can go ahead and do
all of that with eggplant.

00:44:01.540 --> 00:44:03.770
So I'm going to get started here.

00:44:13.800 --> 00:44:15.800
We can just run the script.

00:44:15.800 --> 00:44:20.800
And we can just sort of watch
it go through its paces.

00:44:20.800 --> 00:44:25.800
Again, driving various components
all on that remote system.

00:44:25.910 --> 00:44:29.800
An integration test like this
could also be a multi-system test.

00:44:29.850 --> 00:44:31.990
We could initiate one
process on a machine,

00:44:32.170 --> 00:44:35.800
close this connection,
open a connection to another machine,

00:44:35.800 --> 00:44:37.800
and start processing there.

00:44:37.800 --> 00:44:40.470
Here,
Eggplant automatically agrees to the

00:44:40.470 --> 00:44:42.910
licensing agreement panel that comes up.

00:44:45.900 --> 00:44:48.860
Here we're launching the application
and it says it needs a license,

00:44:48.860 --> 00:44:52.000
so we'll plug in the one that
we pulled off the website.

00:44:53.450 --> 00:44:55.540
Again, we could run a bunch
of eggplant tests now,

00:44:55.540 --> 00:44:58.500
or we can just go and check and
make sure that the documentation

00:44:58.500 --> 00:45:00.140
is coming up correctly.

00:45:00.700 --> 00:45:04.160
So there it is,
the bookmarks and everything.

00:45:04.160 --> 00:45:08.100
So having moved through all that,
we'll go ahead and just clean up,

00:45:08.100 --> 00:45:11.540
clear out the license,
and quit and close Eggplant.

00:45:11.540 --> 00:45:17.120
So there we're seeing an example of an
end-to-end process test of all of the

00:45:17.120 --> 00:45:20.540
steps necessary for a full integration.

00:45:20.540 --> 00:45:22.540
Thanks, Jonathan.

00:45:22.540 --> 00:45:24.530
That was great.

00:45:25.970 --> 00:45:28.120
So I think you can see the
power of automation there.

00:45:28.120 --> 00:45:31.440
In about a minute and a quarter,
we were able to do all of that,

00:45:31.450 --> 00:45:36.330
which is something that you'd like
to be able to validate after you're

00:45:36.340 --> 00:45:40.550
ready to ship your application,
to be sure that it's all ready to go.

00:45:40.810 --> 00:45:44.130
So some of the information that
you might be looking to get

00:45:44.130 --> 00:45:45.660
as a result of your testing.

00:45:45.840 --> 00:45:48.320
Of course, the first thing is that
you're looking for bugs.

00:45:48.470 --> 00:45:51.460
You want to find any bugs that
you might have in your application

00:45:51.870 --> 00:45:55.680
and be able to see what those are.

00:45:55.910 --> 00:46:00.200
Project managers usually are also looking
to gather some statistics about how many

00:46:00.200 --> 00:46:03.860
of your functional tests are passing
or failing at any given point in time

00:46:03.860 --> 00:46:08.600
and hopefully reducing the failures
throughout the development cycle.

00:46:09.950 --> 00:46:13.220
If you're doing some performance testing,
if that's important for your application,

00:46:13.220 --> 00:46:17.030
of course you're going to want to
gather some timing metrics there.

00:46:17.030 --> 00:46:22.690
So clearly that's an important thing.

00:46:23.080 --> 00:46:26.220
Another really important piece, though,
is to provide some

00:46:26.220 --> 00:46:27.720
feedback to developers.

00:46:27.820 --> 00:46:32.520
And I don't know how many of you
who are developers may have had

00:46:32.840 --> 00:46:37.420
situations where testers tell you,
"Oh, the thing crashed here," or,

00:46:37.420 --> 00:46:41.130
"Something didn't work," but
they're not very specific always

00:46:41.130 --> 00:46:44.220
about exactly how that occurred.

00:46:44.220 --> 00:46:47.970
Or on the other side, of course,
testers are sometimes frustrated

00:46:48.280 --> 00:46:52.690
that they tell the developers
that something doesn't work,

00:46:52.690 --> 00:46:55.760
and they're not always believed.

00:46:56.640 --> 00:47:00.720
and David Being able to provide
clear communication of exactly

00:47:00.720 --> 00:47:05.880
what the steps were that led up
to a crash or a bug can be really,

00:47:05.880 --> 00:47:07.440
really valuable.

00:47:07.460 --> 00:47:11.820
And that's one of the key things
that automation can provide.

00:47:11.820 --> 00:47:15.090
By having your test automated and
logging the information as it goes,

00:47:15.090 --> 00:47:17.520
it can show you exactly
what the steps were and,

00:47:17.520 --> 00:47:21.480
of course, you can reproduce that
for the developers.

00:47:21.480 --> 00:47:24.720
And, of course,
automation also is really critical for

00:47:24.840 --> 00:47:29.220
being able to reliably compare one run to
another and see the progress that you're

00:47:29.310 --> 00:47:31.330
making during the development cycle.

00:47:31.330 --> 00:47:36.400
Jonathan's going to give us a quick
view now of some results in Eggplant.

00:47:36.500 --> 00:47:37.500
Thanks.

00:47:37.590 --> 00:47:42.500
Eggplant automatically is going to
record results any time we run a script.

00:47:42.520 --> 00:47:45.450
So let's go ahead and just look back at
the results it recorded for that last

00:47:45.500 --> 00:47:48.140
integration demo that I ran for you.

00:47:48.170 --> 00:47:51.600
So we just come into Eggplant
and go over to the results tab.

00:47:52.220 --> 00:47:56.700
Here you can see it automatically
records each time a script is run,

00:47:56.760 --> 00:47:59.560
and then it keeps statistics
on any errors or warnings or

00:47:59.560 --> 00:48:01.090
exceptions that were raised.

00:48:01.270 --> 00:48:04.190
If we actually click on that run,

00:48:04.600 --> 00:48:08.940
and David You can actually see that
eggplant is actually logging every

00:48:08.940 --> 00:48:15.340
interaction that it performs to the
remote system in terms of clicking what

00:48:15.340 --> 00:48:19.120
time eggplant performed the action,
what action it performed,

00:48:19.120 --> 00:48:22.220
and even where on the
screen that was found.

00:48:22.220 --> 00:48:27.670
And we can step through all of this and
so you get a very clear sense of exactly

00:48:27.670 --> 00:48:32.430
what was happening during the test,
even down to the exact

00:48:32.430 --> 00:48:34.800
second that it happened.

00:48:34.800 --> 00:48:37.820
And we can go ahead and double-click
on any of these lines to jump

00:48:37.880 --> 00:48:43.110
back to the script and see what
command caused that interaction.

00:48:43.120 --> 00:48:46.370
Of course, something that's really
important to know about testing

00:48:46.370 --> 00:48:48.330
is how do errors get reported?

00:48:48.540 --> 00:48:51.710
How do you tell when
something went wrong?

00:48:51.830 --> 00:48:54.650
I'm going to go ahead and force
an error condition here in this

00:48:54.650 --> 00:48:58.720
integration demo by having us go
to a web page that doesn't exist.

00:48:58.720 --> 00:49:04.110
And then just go ahead and
run the script with that.

00:49:07.240 --> 00:49:12.600
So it won't take too long before eggplant
tries to move through its script.

00:49:12.900 --> 00:49:15.640
But lo and behold, the page isn't there.

00:49:15.880 --> 00:49:18.360
The webmaster did something bad.

00:49:18.870 --> 00:49:22.020
So Eggplant comes up and
says that a script failed.

00:49:22.020 --> 00:49:23.560
And now if we go back
and look at our results,

00:49:23.560 --> 00:49:26.760
we see that the result for
that execution is in red.

00:49:26.860 --> 00:49:30.460
And again, we can follow through here
everything that Eggplant was doing,

00:49:30.460 --> 00:49:33.000
including what it was trying to
do when it eventually failed.

00:49:33.020 --> 00:49:37.260
It was trying to find the name field
to fill out the form on the website.

00:49:37.290 --> 00:49:40.140
Any time a script fails,
Eggplant automatically grabs a

00:49:40.140 --> 00:49:44.060
full-size screenshot of exactly what
the screen looked like when it failed,

00:49:44.060 --> 00:49:48.510
so you can easily communicate to the
developers exactly what went wrong and

00:49:48.510 --> 00:49:51.440
exactly what it had done beforehand.

00:49:51.440 --> 00:49:54.370
So that's just a simple look
at the kind of logging results

00:49:54.390 --> 00:49:56.470
that are important for testing.

00:49:58.130 --> 00:50:00.100
Thanks, Jonathan.

00:50:00.240 --> 00:50:03.670
And I might also note that all
of Eggplant's reporting is done

00:50:03.790 --> 00:50:08.100
through standard text files that
you can easily import into other

00:50:08.100 --> 00:50:13.010
reporting tools to generate whatever
kind of reports you might need.

00:50:13.600 --> 00:51:56.600
[Transcript missing]

00:51:58.920 --> 00:52:01.550
One of our customers was
interested in doing some

00:52:01.550 --> 00:52:03.460
validation of third-party software.

00:52:03.460 --> 00:52:07.640
They're a big organization with
hundreds of Windows machines,

00:52:07.640 --> 00:52:11.380
and whenever they get
a new patch to Windows,

00:52:11.380 --> 00:52:14.410
they're interested in knowing
before they deploy that patch

00:52:14.460 --> 00:52:18.280
to all of their Windows boxes,
they'd like to know that all of

00:52:18.280 --> 00:52:22.390
the applications that are critical
to their users are still working.

00:52:22.400 --> 00:52:26.240
So they're interested in using
Eggplant to do this kind of

00:52:26.240 --> 00:52:28.500
validation of other software.

00:52:28.970 --> 00:52:31.480
running on the new version of
Windows before they deployed

00:52:31.480 --> 00:52:32.660
that throughout the organization.

00:52:34.830 --> 00:52:39.230
System administrators, of course,
do a lot of repetitive tasks in

00:52:39.230 --> 00:52:43.850
maintaining systems throughout a company.

00:52:44.200 --> 00:53:20.500
[Transcript missing]

00:53:21.810 --> 00:53:30.550
One of our customers, Fuji Film,
has taken a formerly manual process of

00:53:30.620 --> 00:53:34.150
validating X-ray film and automated that.

00:53:34.200 --> 00:53:39.760
This is a process that is subject to
audit by the FDA and it's very critical

00:53:39.760 --> 00:53:42.180
that this be done on a regular basis.

00:53:42.220 --> 00:53:46.680
There's a variety of different kinds
of automation that are possible.

00:53:48.100 --> 00:53:51.300
Hardware and BIOS-level testing is not
something maybe that would immediately

00:53:51.300 --> 00:53:55.610
pop to mind for something that is
typically thought of as driving software.

00:53:55.620 --> 00:54:01.220
But, in fact, most hardware, of course,
has some sort of an interface.

00:54:01.240 --> 00:54:05.080
And if it's got an interface,
then eggplant can interact

00:54:05.080 --> 00:54:06.600
with it and drive it.

00:54:06.660 --> 00:54:09.780
We even have one customer who
is doing BIOS-level testing.

00:54:09.780 --> 00:54:13.520
There's a hardware
KVM switch that supports VNC.

00:54:13.930 --> 00:54:17.110
And they're able to use that
to have eggplant drive the

00:54:17.110 --> 00:54:18.920
machine even at boot time.

00:54:22.160 --> 00:54:25.840
We also have come up with
an idea of creating movies.

00:54:25.960 --> 00:54:28.830
So we built in a feature into
Eggplant that will allow you to

00:54:28.930 --> 00:54:32.940
capture a quick-time movie of exactly
what's going on on the remote screen,

00:54:32.980 --> 00:54:36.660
either when you're interacting with
it live or under a script control.

00:54:36.660 --> 00:54:41.540
Since you have already developed tests
now to walk your application through

00:54:41.860 --> 00:54:46.620
the various use cases of how users are
going to interact with your system,

00:54:46.620 --> 00:54:49.520
it might be kind of nice to be able
to capture that as a movie and present

00:54:49.520 --> 00:54:51.160
that as part of your documentation.

00:54:52.190 --> 00:54:56.080
And we're going to have a
quick demo now of movies.

00:54:56.620 --> 00:54:59.710
Just really quickly for
our final demonstration,

00:55:00.000 --> 00:55:04.180
here's a little script that I've
written that actually records a

00:55:04.180 --> 00:55:07.480
QuickTime movie of that integration
demo that we've been working with.

00:55:07.560 --> 00:55:11.500
The first thing it does is just
sets up some timing parameters,

00:55:11.500 --> 00:55:15.010
and this just slows down the script
to make the movie easier for a user

00:55:15.010 --> 00:55:17.050
to follow exactly what's going on.

00:55:17.060 --> 00:55:20.490
And then we just say, start movie,
and go ahead and call the script

00:55:20.700 --> 00:55:22.720
that we've already been working with.

00:55:23.320 --> 00:55:28.000
I'm not going to run it and
have you watch the demo again,

00:55:28.000 --> 00:55:30.780
but I'll go ahead and show
you the results of having

00:55:30.800 --> 00:55:32.860
created this movie just before.

00:55:40.580 --> 00:55:44.020
So again,
it's a process that we've already gone

00:55:44.020 --> 00:55:48.720
through for testing and validating this,
but if we want to go ahead and

00:55:48.720 --> 00:55:52.000
create a simple interactive
movie to show users how to do

00:55:52.000 --> 00:55:57.050
something within our application,
it's real easy using Eggplant to

00:55:57.120 --> 00:56:02.940
just throw a little wrapper around it
like this and create a little quick

00:56:03.160 --> 00:56:07.760
30-second or minute-long QuickTime movie
that you can put up on your website.

00:56:08.730 --> 00:56:11.810
One of the nice things about
creating a movie using a script,

00:56:11.840 --> 00:56:14.270
of course,
is that if something changes in your

00:56:14.270 --> 00:56:17.530
application or you decide there's a
little different way you'd like to

00:56:17.540 --> 00:56:21.470
present that process to your users,
you can easily just modify your

00:56:21.580 --> 00:56:23.090
script and recreate the movie.

00:56:23.090 --> 00:56:29.010
It's a very quick process,
a lot easier than editing a movie file.

00:56:30.690 --> 00:56:33.490
So, just to sum up,
we've talked today about a number

00:56:33.490 --> 00:56:37.350
of different types of testing
and the kinds of value that

00:56:37.420 --> 00:56:38.630
automation can bring to those.

00:56:38.700 --> 00:56:41.890
Unit testing,
which is very important to validate

00:56:42.010 --> 00:56:43.780
your code at the low level.

00:56:43.780 --> 00:56:46.240
Functional testing to
test your use cases,

00:56:46.330 --> 00:56:49.160
how the user is going to
be interacting with it.

00:56:49.180 --> 00:56:52.690
Stress testing is very important
to bring out any bugs that may

00:56:52.700 --> 00:56:54.640
be hiding in the application.

00:56:55.180 --> 00:56:59.380
And performance testing, of course,
to make sure that it's running

00:56:59.380 --> 00:57:01.120
at an acceptable speed.

00:57:02.520 --> 00:57:05.200
Integration testing is often overlooked.

00:57:05.560 --> 00:57:09.890
It's one of those things, though,
that really impacts the experience

00:57:09.890 --> 00:57:14.230
that your users have with your
application when they get it.

00:57:14.360 --> 00:57:17.030
We also talked a little bit about
some of the kinds of results and

00:57:17.030 --> 00:57:19.880
information that you might be looking
for from your testing process,

00:57:19.880 --> 00:57:25.180
and had a quick look at some different
uses of automation beyond testing.

00:57:25.180 --> 00:57:30.840
So I hope this has been some information
that you can use to go home and improve

00:57:31.140 --> 00:57:36.060
your own testing processes and turn out
some great applications for Mac OS X.

00:57:47.300 --> 00:57:49.990
This is our contact information here.

00:57:50.000 --> 00:57:52.440
We also have a booth
downstairs in the exhibit area.

00:57:52.440 --> 00:57:56.190
We'd be very happy to talk to
you later today or tomorrow.

00:57:56.230 --> 00:58:01.220
There's also a free download
of Eggplant that's available

00:58:01.220 --> 00:58:04.200
to attendees of WWDC this year.

00:58:04.200 --> 00:58:10.610
The URL is included in the information
that's available as part of this session.

00:58:11.090 --> 00:58:13.760
or you can come talk to us in the booth.

00:58:13.770 --> 00:58:16.500
And I'd like to open it up to questions.

00:58:17.120 --> 00:58:20.090
Yes,
there's also some more information here

00:58:20.120 --> 00:58:24.400
about additional information that's
available through the Apple website.
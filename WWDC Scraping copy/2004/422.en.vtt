WEBVTT

00:00:18.050 --> 00:00:20.660
Hi, everybody.

00:00:20.690 --> 00:00:24.480
Welcome to session 422,
which actually we'd like to call

00:00:24.480 --> 00:00:28.110
the HIV toolbox day or HIView day.

00:00:28.270 --> 00:00:31.300
A lot of things have been
evolving inside Mac OS X,

00:00:31.300 --> 00:00:35.110
and this week you've probably
learned a lot of these evolutions.

00:00:35.450 --> 00:00:39.200
First, like you probably heard,
Quick Draw is being deprecated.

00:00:39.200 --> 00:00:42.200
We talked about being ready
for resolution independence.

00:00:42.200 --> 00:00:46.200
So what does that mean for you
as a Carbon and C/C++ developer?

00:00:46.200 --> 00:00:49.190
What does that mean for
you as an HI Toolbox user?

00:00:49.200 --> 00:00:51.200
Well, that means a couple of things.

00:00:51.200 --> 00:00:53.190
And first,
that means that your code is going to

00:00:53.220 --> 00:00:57.200
have to evolve as well to play great in
the next operating system of Mac OS X,

00:00:57.200 --> 00:00:59.200
the next version of Mac OS X.

00:00:59.410 --> 00:01:02.690
The good news is that we have a
lot of technologies that we're

00:01:02.690 --> 00:01:05.200
going to be announcing this
week here in the HI Toolbox,

00:01:05.270 --> 00:01:07.630
and a lot of things with
HIView that we've been doing

00:01:07.630 --> 00:01:09.200
that should really help you.

00:01:09.200 --> 00:01:14.190
And we have really packed sessions that
should really help you move forward.

00:01:14.200 --> 00:01:18.150
We're going to start today with Guy,
who is our representative from France,

00:01:18.290 --> 00:01:22.200
who's going to be actually talking
about switching to a Modern HI Toolbox,

00:01:22.200 --> 00:01:25.560
and he's going to teach you really the
architecture of HIView and how you as

00:01:25.560 --> 00:01:26.200
a developer can take advantage of it.

00:01:26.200 --> 00:01:30.060
How you're going to get there and
all the features that you're going

00:01:30.200 --> 00:01:32.200
to be able to take advantage of.

00:01:32.200 --> 00:01:35.080
So I think it's a great first
step for you to understand the

00:01:35.080 --> 00:01:37.200
foundations of where we're going here.

00:01:37.200 --> 00:01:40.180
After that,
please don't miss the session that

00:01:40.250 --> 00:01:43.200
we're going to have at 3:30 with Kurt,
Monsieur Kurt,

00:01:43.200 --> 00:01:47.430
where actually we know that a
lot of you guys are still based,

00:01:47.430 --> 00:01:50.200
have dialogues and Windows resources.

00:01:50.200 --> 00:01:54.050
And so we're going to take a full
hour to kind of like give you a basis

00:01:54.050 --> 00:01:59.290
and help you switch your resources
based user interfaces to Nib files.

00:01:59.290 --> 00:02:02.180
And then we'll teach you as well
how to kind of like link them

00:02:02.200 --> 00:02:03.200
together using Carbon events.

00:02:03.200 --> 00:02:05.300
Very, very cool session.

00:02:05.300 --> 00:02:07.200
I think you'll like it.

00:02:07.400 --> 00:02:10.200
Now, getting ready for
resolution independence,

00:02:10.200 --> 00:02:13.000
we're going to teach you tomorrow,
we're going to have a session

00:02:13.300 --> 00:02:16.330
that's going to explain to you
how to switch your custom drawing

00:02:16.370 --> 00:02:20.310
content and how to switch,
you know, like if you're using C-DEVs,

00:02:20.310 --> 00:02:22.180
for instance, to use custom HIViews.

00:02:22.200 --> 00:02:24.180
This is a very, very,
very important session.

00:02:24.270 --> 00:02:27.440
If you have custom controls,
I really encourage you

00:02:27.490 --> 00:02:29.200
to attend that session.

00:02:29.270 --> 00:02:31.200
So you're probably thinking, well,
that means, you know,

00:02:31.200 --> 00:02:34.330
I'm going to have like still to like,
you know, like rave some old code that

00:02:34.330 --> 00:02:35.200
I have that has been working.

00:02:35.200 --> 00:02:36.160
Yes, you're correct.

00:02:36.230 --> 00:02:39.190
You're going to have to revise and like,
you know, move some code.

00:02:39.200 --> 00:02:42.210
If you're using Quick Draw,
you're going to have to switch, you know,

00:02:42.210 --> 00:02:43.190
to core graphics.

00:02:43.350 --> 00:02:45.570
But what's very,
very important to understand

00:02:45.660 --> 00:02:48.200
is that this is very,
very good for like our users

00:02:48.200 --> 00:02:51.530
because your user interface and
your application is going to gain

00:02:51.530 --> 00:02:53.200
in performance and in features.

00:02:53.220 --> 00:02:56.190
And this is really where
we're moving towards.

00:02:56.200 --> 00:02:59.200
So I think we'll be very pleased
with the work that we've been doing.

00:02:59.200 --> 00:03:01.200
And let's start with Mr.

00:03:01.200 --> 00:03:04.900
Guy, who's going to be taking you for
the next hour with like the new

00:03:04.900 --> 00:03:06.140
things we'll be doing with HIView.

00:03:06.200 --> 00:03:07.440
Mr.

00:03:07.490 --> 00:03:08.200
Guy.

00:03:08.200 --> 00:03:10.690
Thank you, Xavier.

00:03:12.400 --> 00:03:14.240
So good afternoon.

00:03:14.240 --> 00:03:16.300
I hope everybody had a great lunch.

00:03:16.530 --> 00:03:19.400
Get ready for a very packed session.

00:03:19.400 --> 00:03:22.890
Maybe my fast speech will
help me for once here.

00:03:23.160 --> 00:03:25.250
Okay, so what I'm going to cover,
in essence,

00:03:25.350 --> 00:03:28.980
is the meaning of HIView and how
that can help your applications.

00:03:29.080 --> 00:03:31.860
And then I'm going to show you a
step-by-step example of how you can take

00:03:31.860 --> 00:03:34.100
advantage of HIView in your application.

00:03:34.100 --> 00:03:37.540
Then I'm going to have a section
on resolution independence.

00:03:37.600 --> 00:03:40.100
It got mentioned at the
graphic sessions already,

00:03:40.100 --> 00:03:42.070
but I'm going to show you the
Carbon story for resolution independence

00:03:42.120 --> 00:03:44.100
and how you can start thinking
about that for your applications.

00:03:44.100 --> 00:03:48.000
And finally, I'm going to go through a
potpourri of various new features

00:03:48.010 --> 00:03:49.720
in the HIToolbox for Tiger.

00:03:50.830 --> 00:03:52.390
So we use this word HIView a lot.

00:03:52.680 --> 00:03:55.380
Xavier probably said it 15
times as he was talking there.

00:03:55.500 --> 00:03:57.830
And a lot of people
wonder what HIView is.

00:03:57.960 --> 00:04:00.700
I mean, I'm sure you've seen the typedef,
and then we say adopt HIView.

00:04:00.700 --> 00:04:02.520
Does that mean I just
need to grab one view?

00:04:02.830 --> 00:04:03.400
Well, no.

00:04:03.400 --> 00:04:07.800
What HIView means when we say adopt
HIView is it means get on board with

00:04:08.050 --> 00:04:13.270
everything we've been doing for the
last three or four years in the Toolbox.

00:04:13.270 --> 00:04:17.700
HIView is this conglomeration of cool new
features we've been adding since Jaguar,

00:04:17.700 --> 00:04:17.700
essentially.

00:04:19.280 --> 00:04:22.740
So technically, HIView is our
object-oriented view system.

00:04:22.820 --> 00:04:24.230
It's based off the Control Manager.

00:04:24.270 --> 00:04:26.300
If you've seen the Control Manager and
you're familiar with it,

00:04:26.300 --> 00:04:29.070
and I know most of you are,
HIView is also going to feel very,

00:04:29.180 --> 00:04:30.170
very familiar.

00:04:30.180 --> 00:04:34.620
It's so familiar and so similar, in fact,
that it's the same type ref-- type def.

00:04:34.660 --> 00:04:36.280
A Control Ref is an HIView ref.

00:04:36.380 --> 00:04:37.340
It's the exact same type.

00:04:37.340 --> 00:04:39.450
They are literally type def
to one another in the header.

00:04:39.470 --> 00:04:43.050
It means you can use HIView
refs in Control Manager APIs,

00:04:43.120 --> 00:04:46.010
and you can use
Control refs in HIView APIs.

00:04:46.380 --> 00:04:48.840
Now our object model is based, of course,
on HIObject.

00:04:48.840 --> 00:04:50.140
We've talked about that in the past.

00:04:50.280 --> 00:04:53.210
It's a very cool subclassing
mechanism for Carbon clients.

00:04:53.540 --> 00:04:56.410
And we use Carbon Events as
the messaging model.

00:04:56.910 --> 00:04:59.250
Now,
HIView also includes all the new widgets

00:04:59.250 --> 00:05:02.580
we've added over the last few years,
like the search field and the

00:05:02.720 --> 00:05:04.300
toolbar and things like that.

00:05:04.500 --> 00:05:07.440
HIView also represents a much
more advanced drawing model

00:05:07.470 --> 00:05:09.800
where you can take advantage of
all the cool quartz features.

00:05:09.800 --> 00:05:11.800
And there's some other
side perks in there.

00:05:11.800 --> 00:05:16.450
HIView gives you much better drawing
support in the sense that the

00:05:16.510 --> 00:05:20.870
APIs now make sense when you use them,
and they don't do things

00:05:20.870 --> 00:05:21.560
you're not exactly expecting,
and they don't force

00:05:21.560 --> 00:05:21.560
you to take workarounds.

00:05:22.780 --> 00:05:25.380
Now the reason you want to adopt
HIView is it's because what your

00:05:25.380 --> 00:05:29.400
customers are asking for can
really only be granted by HIView.

00:05:29.410 --> 00:05:32.380
HIView can give you all those
buzzwords like the library sizing,

00:05:32.380 --> 00:05:36.140
quartz transparency,
various forms of animation.

00:05:36.270 --> 00:05:40.180
Going to HIView is also the only way
to adopt certain new Toolbox features

00:05:40.270 --> 00:05:42.380
we've added over the past couple years.

00:05:42.440 --> 00:05:43.800
The Toolbar is one.

00:05:43.800 --> 00:05:45.980
Our TextView and ScrollView,
which is our full-featured

00:05:46.020 --> 00:05:47.990
text editing view in Carbon,
is another.

00:05:48.320 --> 00:05:49.700
We've got an ImageView.

00:05:49.720 --> 00:05:52.230
We have HIView layout mechanisms,
which are like springs

00:05:52.230 --> 00:05:53.200
and rods on steroids.

00:05:53.320 --> 00:05:56.200
And all that only works under HIView.

00:05:56.200 --> 00:05:58.300
Now another reason you should
use HIView is it's just going

00:05:58.300 --> 00:05:59.690
to make your apps faster,
right?

00:05:59.750 --> 00:06:01.690
We did a lot of things
much more efficiently.

00:06:01.790 --> 00:06:05.200
We learned from our mistakes in the
Control Manager and just made it better.

00:06:05.200 --> 00:06:09.200
And the best thing about HIView is it
actually makes your jobs a lot easier.

00:06:09.210 --> 00:06:11.920
The code you end up writing to do
something custom in your app is a

00:06:12.050 --> 00:06:15.270
lot simpler when you use HIView to
implement it than if you have to

00:06:15.270 --> 00:06:17.540
hand-roll it yourself the old way.

00:06:19.010 --> 00:06:22.250
Some of you may be looking at your
applications these days and feeling like

00:06:22.260 --> 00:06:23.580
it looks a little bit like this house.

00:06:23.710 --> 00:06:27.040
It's kind of got a crummy lawn,
the paint's chipping here and there,

00:06:27.040 --> 00:06:29.650
the windows are kind of ugly,
the roof's maybe got a couple leaks.

00:06:29.700 --> 00:06:33.230
Well, one reason you might want to adopt
HIView is because it can allow

00:06:33.230 --> 00:06:34.630
your house to look like this.

00:06:34.700 --> 00:06:37.090
Put a little work into it,
give it some new paint,

00:06:37.090 --> 00:06:40.990
clean up the lawn, clean up the yard,
and suddenly it looks a lot better.

00:06:41.260 --> 00:06:43.940
But then there's another side perk:
that house isn't exactly the same

00:06:43.940 --> 00:06:45.200
as it was in the other picture.

00:06:45.200 --> 00:06:46.500
We've added some things, right?

00:06:46.500 --> 00:06:48.600
There's a new fence there,
there's new windows.

00:06:48.950 --> 00:06:50.900
In fact, one of the windows was
expanded a little bit.

00:06:50.920 --> 00:06:53.700
So HIView is going to not just let
you polish up your application,

00:06:53.700 --> 00:06:55.900
but it's going to let you
expand it and grow it.

00:06:59.010 --> 00:07:01.320
So there's five basic
steps to adopting HIView,

00:07:01.320 --> 00:07:03.340
or adopting all the
technologies in HIView.

00:07:03.370 --> 00:07:05.180
So let's jump right into the first one.

00:07:05.260 --> 00:07:07.180
That's using the standard
windows and controls.

00:07:07.290 --> 00:07:09.640
This is something we say every year,
and we need to repeat it

00:07:09.640 --> 00:07:11.420
because it bears repeating,
right?

00:07:11.420 --> 00:07:13.820
There's a lot of good reasons to do it,
and we know some of you still need a

00:07:13.820 --> 00:07:17.900
little bit of a push to keep adopting
the standard windows and controls.

00:07:20.170 --> 00:07:22.880
So we've added a lot of new views
over the last few years that can

00:07:22.880 --> 00:07:26.090
do basic things that your apps
used to have to do for themselves.

00:07:26.100 --> 00:07:29.100
If you want a list view that interacts
a lot like Finder's list view,

00:07:29.100 --> 00:07:30.300
go ahead and use the Data Browser.

00:07:30.420 --> 00:07:33.100
In fact, Finder uses the Data Browser
to do its list view.

00:07:33.100 --> 00:07:35.460
Like I mentioned before,
we have a TextView and a ScrollView that

00:07:35.570 --> 00:07:38.900
together can be a full-featured text
editing engine for Carbon applications.

00:07:38.900 --> 00:07:41.400
But you don't have to use the
ScrollView just with the TextView.

00:07:41.400 --> 00:07:44.080
You can use it to scroll image
views or any other custom

00:07:44.090 --> 00:07:45.690
view you might want to make.

00:07:46.070 --> 00:07:49.190
So take a look at the controls we offer,
and take a look at your application and

00:07:49.280 --> 00:07:50.570
find out what you were doing custom.

00:07:50.650 --> 00:07:54.280
And see if now there's some parity
between what we offer and what you do,

00:07:54.280 --> 00:07:58.600
and see if you can replace your custom
implementations with our new features.

00:07:59.230 --> 00:08:02.300
Also, be sure to take advantage of view
embedding or control embedding.

00:08:02.300 --> 00:08:04.950
This is something that
we've had a long time,

00:08:04.960 --> 00:08:08.310
since Mac OS 8.0,
but we know a lot of people like to

00:08:08.390 --> 00:08:10.790
use controls in a very flat hierarchy.

00:08:10.900 --> 00:08:13.000
They have a window and they
have a bunch of controls in it,

00:08:13.020 --> 00:08:15.750
and then they try to manage the
overlapping controls themselves and try

00:08:15.850 --> 00:08:17.100
to manage the containment themselves.

00:08:17.100 --> 00:08:20.080
Well, HIView can do all of that for you,
so you might as well use

00:08:20.080 --> 00:08:21.340
the built-in infrastructure.

00:08:21.340 --> 00:08:24.820
That's also going to give you a lot of
benefits with respect to accessibility.

00:08:24.820 --> 00:08:30.710
An app that's been revved to use HIView
is going to be mostly accessible.

00:08:31.980 --> 00:08:35.000
In addition,
going to HIView insulates you from future

00:08:35.000 --> 00:08:37.280
interface changes that we might make.

00:08:37.280 --> 00:08:39.900
The best example of this
is probably the tabs.

00:08:39.900 --> 00:08:41.490
On Jaguar,
the tabs looked a lot different

00:08:41.490 --> 00:08:44.780
than they started to on Panther and
continued to look on Tiger.

00:08:44.840 --> 00:08:48.140
But there were a lot of applications
that rolled their own tabs.

00:08:48.170 --> 00:08:50.150
And sure,
they used the appearance primitives

00:08:50.150 --> 00:08:53.220
to try to get the standard look,
but because of how the appearance

00:08:53.330 --> 00:08:56.380
needed to change in Panther,
those same primitives could

00:08:56.520 --> 00:08:58.040
not draw the new look.

00:08:58.040 --> 00:09:01.820
So people that did their custom tabs
on Jaguar and got a good Jaguar look,

00:09:02.290 --> 00:09:04.930
unfortunately carry that
Jaguar look into the future,

00:09:04.930 --> 00:09:06.380
into Panther and Tiger.

00:09:06.380 --> 00:09:08.480
So that's just another great
reason to use our standard tabs.

00:09:08.570 --> 00:09:11.650
If you use the standard tabs,
it's going to get the new looks

00:09:11.650 --> 00:09:13.330
as we rev the user interface.

00:09:14.720 --> 00:09:15.680
That's really the first step.

00:09:15.680 --> 00:09:16.920
It's pretty straightforward, right?

00:09:17.000 --> 00:09:18.520
But it's going to give
you a lot of good wins.

00:09:18.590 --> 00:09:21.260
And most of you already know how to do
that and are already at least partway

00:09:21.260 --> 00:09:22.600
through doing that in your application.

00:09:22.680 --> 00:09:25.280
So that one should be pretty easy.

00:09:26.100 --> 00:09:30.400
The next step, which is probably the
most time-consuming step,

00:09:30.470 --> 00:09:33.420
let's say,
is taking your custom user interface

00:09:33.420 --> 00:09:38.730
in your application and wrapping that
inside individual HIView objects.

00:09:40.700 --> 00:09:43.730
The first step as part of that
process is to look at your interface

00:09:43.870 --> 00:09:46.770
and factor your custom areas
into individual sub-components.

00:09:46.890 --> 00:09:50.150
It's standard engineering
design methodology.

00:09:50.260 --> 00:09:52.100
You want to make a view
around the simplest,

00:09:52.170 --> 00:09:54.300
smallest thing possible in most cases.

00:09:54.300 --> 00:09:55.900
If you do that,
it's going to be a lot easier

00:09:55.900 --> 00:09:58.130
to write HIViews around those
individual small widgets,

00:09:58.210 --> 00:10:00.400
and you'll be able to reuse
them in various places as well,

00:10:00.400 --> 00:10:02.030
which is cool.

00:10:03.420 --> 00:10:06.280
Then,
using our HIObject subclassing mechanism,

00:10:06.300 --> 00:10:11.390
you create a subclass of HIView
to represent your custom object.

00:10:14.100 --> 00:10:16.640
Then, when your custom object is
put in a view hierarchy,

00:10:16.750 --> 00:10:19.840
it will receive Carbon events to
handle things like mouse clicks,

00:10:19.850 --> 00:10:22.640
keyboard events,
all sorts of other user interaction,

00:10:22.780 --> 00:10:26.000
accessibility, activations,
deactivations, all that stuff.

00:10:26.070 --> 00:10:29.000
So you just handle those Carbon events,
do the right thing.

00:10:29.000 --> 00:10:31.390
We have lots of HeaderDoc in
Carbonevents.h for all of the

00:10:31.490 --> 00:10:33.000
Control and View related events.

00:10:33.000 --> 00:10:35.150
You can look in there,
it tells you what you need to do,

00:10:35.150 --> 00:10:37.370
what events you want to
handle for certain situations,

00:10:37.400 --> 00:10:39.000
and it's really straightforward.

00:10:40.980 --> 00:10:43.200
Then, if your view needs to
communicate state changes to

00:10:43.200 --> 00:10:46.190
other parts of your application,
like let's say when a button is clicked,

00:10:46.190 --> 00:10:49.520
right, you need to carry out some action
someplace else in your app.

00:10:49.520 --> 00:10:51.210
You can use HI commands to do that.

00:10:51.210 --> 00:10:53.840
We have convenient APIs to
send out HI commands.

00:10:53.910 --> 00:10:58.080
In fact, the view system already has
built in support for HI commands.

00:10:58.170 --> 00:11:00.160
You can associate a
command with a given view.

00:11:00.160 --> 00:11:02.890
It'll automatically get sent
out when the view is clicked.

00:11:02.890 --> 00:11:05.410
But if you have more complex
communications needs,

00:11:05.510 --> 00:11:08.310
you can use custom Carbon events
to communicate between

00:11:08.310 --> 00:11:10.040
different pieces of your app.

00:11:10.040 --> 00:11:12.900
One good example of
this is our scroll view.

00:11:12.900 --> 00:11:16.300
The scroll view is based on our
scroll view Carbon event protocol,

00:11:16.300 --> 00:11:18.660
which is just a set of simple
Carbon events that it can use to

00:11:18.670 --> 00:11:21.060
communicate with its scrollable canvas.

00:11:21.060 --> 00:11:22.370
If you have similar needs
in your application,

00:11:22.370 --> 00:11:24.780
there's no reason you can't use
Carbon events to implement them.

00:11:24.810 --> 00:11:26.580
They're really flexible,
really full-featured.

00:11:26.580 --> 00:11:28.150
You can put all sorts
of attributes in them.

00:11:28.250 --> 00:11:29.000
You can queue them.

00:11:29.130 --> 00:11:30.380
You can direct dispatch them.

00:11:30.380 --> 00:11:31.560
And it's just--it's really powerful.

00:11:50.990 --> 00:11:50.990
Then it bears repeating:
keep using view embedding.

00:11:50.990 --> 00:11:50.990
You might get partway
through this step and say,

00:11:50.990 --> 00:11:50.990
"Okay, well,
I wrap my custom content in some views,

00:11:50.990 --> 00:11:50.990
but I'm still going to use
a flat hierarchy." Well,

00:11:50.990 --> 00:11:50.990
I really recommend not doing that.

00:11:50.990 --> 00:11:50.990
I really recommend using the
full embedding hierarchy,

00:11:50.990 --> 00:11:50.990
because it's going to make
subsequent steps a lot easier.

00:11:52.450 --> 00:11:55.800
Finally, we have a bit of sample
code called HIFramework.

00:11:55.800 --> 00:11:57.540
It's on the developer website.

00:11:57.570 --> 00:12:00.180
We have a bunch of sample
applications based on HIFramework.

00:12:00.290 --> 00:12:04.170
And this is a C++ class library
that manages the kind of boring

00:12:04.280 --> 00:12:07.580
details of HIobject subclassing
and the HIView mechanism.

00:12:07.580 --> 00:12:11.640
You can just derive a
subclass from our TView class,

00:12:11.640 --> 00:12:15.400
and it'll automatically set
up the HIobject subclass,

00:12:15.410 --> 00:12:17.320
the event dispatcher, and all that.

00:12:17.350 --> 00:12:19.980
Then you just override whatever
virtual methods you need to and do

00:12:19.980 --> 00:12:22.820
whatever work you need to in those.

00:12:25.820 --> 00:12:26.880
Now we're going to be covering some of
these steps in more detail because I just

00:12:26.880 --> 00:12:27.520
don't have time to talk about them today.

00:12:27.580 --> 00:12:29.770
So we're going to cover
them in two other sessions.

00:12:29.850 --> 00:12:34.910
As Xavier mentioned,
session 421 immediately follows this,

00:12:34.920 --> 00:12:38.800
and it talks about taking an old
style dialog or some old window code

00:12:38.800 --> 00:12:41.890
and replacing it with a nib file,
and as part of that,

00:12:41.890 --> 00:12:43.780
adopting HIView in the
process where you can.

00:12:43.800 --> 00:12:46.340
And then tomorrow,
we have a session entirely on writing an

00:12:46.340 --> 00:12:49.790
HIView from the ground up to represent
some custom area in your application.

00:12:49.790 --> 00:12:52.330
So I strongly urge you to
attend these sessions to get

00:12:52.330 --> 00:12:53.800
more details on this step.

00:12:55.850 --> 00:12:58.340
So that's two of the five steps.

00:12:58.340 --> 00:13:01.460
The next is adopting the
standard window handler.

00:13:01.460 --> 00:13:05.930
This is probably the most fun step,
mainly because it gives you kind

00:13:05.930 --> 00:13:07.270
of this cool bang for the buck.

00:13:07.380 --> 00:13:08.700
It gives you this cool win.

00:13:08.700 --> 00:13:12.120
Now the standard window handler has
been around for several releases,

00:13:12.120 --> 00:13:14.890
and essentially what this is,
is it's a Carbon event handler that

00:13:14.970 --> 00:13:18.010
can automatically be put on your
windows to do all the normal event

00:13:18.010 --> 00:13:21.700
dispatching that you used to have to do
manually when you called waitnextevent.

00:13:21.700 --> 00:13:23.590
So you no longer have
to call waitnextevent,

00:13:23.660 --> 00:13:25.690
see if it's a mouse event,
call findwindow,

00:13:25.700 --> 00:13:27.700
see if it's in your window
that you're interested in.

00:13:27.700 --> 00:13:29.660
If so, call findcontrol,
route it to the control.

00:13:29.730 --> 00:13:31.700
If it's not a control,
you know that whole rigamarole.

00:13:31.700 --> 00:13:35.890
You don't have to do any of that if you
turn on the standard window handler.

00:13:37.300 --> 00:13:40.650
So the standard window handler is
designed to work directly with HIView.

00:13:40.710 --> 00:13:43.610
And what I mean by that is the
standard window handler only

00:13:43.710 --> 00:13:45.600
knows how to deal with views.

00:13:45.600 --> 00:13:48.670
It can route mouse events,
keyboard events, all that stuff to views.

00:13:48.920 --> 00:13:51.720
But if you have completely custom
stuff in your window and it's

00:13:51.760 --> 00:13:54.080
not represented by an HIView,
you have to jump through

00:13:54.080 --> 00:13:54.820
hoops to make that work.

00:13:54.950 --> 00:13:57.490
You have to install a bunch of
Carbon event handlers on your window

00:13:57.860 --> 00:13:59.510
and deal with all that rigamarole.

00:13:59.620 --> 00:14:01.970
So the right thing really to do
here is if you're going to use

00:14:01.970 --> 00:14:04.070
the standard window handler,
use HIView.

00:14:04.200 --> 00:14:06.890
They work together really, really well.

00:14:07.340 --> 00:14:11.960
The standard window handler is also the
most important key to using the Toolbar.

00:14:11.960 --> 00:14:16.820
The Toolbar essentially puts
a system-driven piece of code,

00:14:16.820 --> 00:14:19.180
or a system-driven piece of
interface in your window.

00:14:19.200 --> 00:14:25.420
And the only way that can receive events
is if you jump through some hoops to

00:14:25.510 --> 00:14:29.720
find the right events to send to it,
or if you just use the

00:14:29.720 --> 00:14:29.720
standard window handler.

00:14:29.720 --> 00:14:29.720
You might as well use the
standard window handler.

00:14:31.550 --> 00:14:33.400
So, to get the standard window
handler for your window,

00:14:33.400 --> 00:14:35.600
you need to do a few things.

00:14:35.600 --> 00:14:37.440
In Interface Builder,
which is our preferred way

00:14:37.630 --> 00:14:39.670
of creating your windows,
there's a checkbox in the

00:14:39.670 --> 00:14:40.760
window inspector palette.

00:14:40.760 --> 00:14:42.370
It says "Standard
Handler." Just check it,

00:14:42.420 --> 00:14:45.260
the standard handler will automatically
be turned on for your windows.

00:14:45.280 --> 00:14:48.520
But, if you need to programmatically
instantiate your windows,

00:14:48.520 --> 00:14:50.890
there is an attribute,
the case "WindowStandardHandler"

00:14:50.930 --> 00:14:54.500
attribute that you can
specify at creation time.

00:14:54.500 --> 00:14:57.330
Once you've turned that on for a window,
the standard handler will

00:14:57.330 --> 00:14:58.430
automatically be in effect.

00:14:58.430 --> 00:15:01.280
As soon as your application runs,
it'll start servicing events,

00:15:01.300 --> 00:15:04.930
which means you can go back into
your WaitNext event loop and rip out

00:15:05.020 --> 00:15:07.750
all the code that had to deal with
routing events to that one window.

00:15:07.750 --> 00:15:09.220
You can just get rid of it.

00:15:09.220 --> 00:15:11.300
It's generally not necessary.

00:15:11.740 --> 00:15:14.940
But the standard handler can't do some
sort of functional things on the window

00:15:14.940 --> 00:15:16.600
that you're going to need to respond to.

00:15:16.600 --> 00:15:19.940
For example,
when the Close box is clicked,

00:15:20.020 --> 00:15:23.940
a window gets sent the
KEventWindowClose CarbonEvent.

00:15:24.040 --> 00:15:26.840
And by default,
the window will tear down.

00:15:26.950 --> 00:15:29.520
But if you need to save
changes or do something else,

00:15:29.550 --> 00:15:33.230
you'll want to hook into that
CarbonEvent to handle it completely.

00:15:33.460 --> 00:15:34.940
There's a bunch of other
Carbon events like this.

00:15:34.970 --> 00:15:35.990
You can think of them as hooks.

00:15:35.990 --> 00:15:39.730
They're not strictly necessary,
but they're good ways for you to hook

00:15:39.730 --> 00:15:43.090
into the system's processing and provide
custom behavior where you need to.

00:15:43.220 --> 00:15:47.000
CarbonEvents.h, again,
has lots of documentation in that header.

00:15:47.120 --> 00:15:52.920
So I urge you to take a look at it,
see what sorts of other

00:15:52.970 --> 00:15:54.000
hook events are in there,
and take advantage of whatever

00:15:54.000 --> 00:15:54.000
makes sense for your application.

00:15:56.330 --> 00:15:58.750
So that's step three.

00:15:58.820 --> 00:16:02.860
Step four is probably the coolest
because it's the flashiest.

00:16:02.860 --> 00:16:07.070
That's switching on compositing mode
and starting to draw with Quartz.

00:16:07.590 --> 00:16:10.980
This is cool because it gives
you radically better performance,

00:16:11.040 --> 00:16:13.490
and it just makes your life
a heck of a lot easier.

00:16:13.500 --> 00:16:18.770
One of the ways we sped up the HIView
subsystem through compositing mode

00:16:19.200 --> 00:16:23.950
is that we no longer draw a pixel
twice unless we absolutely have to.

00:16:24.050 --> 00:16:27.290
And what I mean by that
is when a view draws,

00:16:27.290 --> 00:16:30.800
we know whether or not it's opaque,
and we know what part of

00:16:30.800 --> 00:16:32.000
it needs to be redrawn.

00:16:32.000 --> 00:16:34.680
And so we make sure to just
redraw the parts of the views

00:16:34.700 --> 00:16:36.500
that intersect that dirty area.

00:16:38.220 --> 00:16:42.020
In addition,
now that we are not redrawing

00:16:42.020 --> 00:16:46.790
right when you call various
APIs like set control value--.

00:16:46.810 --> 00:16:48.290
Well, let's step back for a second.

00:16:48.290 --> 00:16:50.640
So in the old control manager,
every time you called an

00:16:50.640 --> 00:16:52.950
API like set control value,
the control redrew.

00:16:53.070 --> 00:16:55.430
So if you did a typical setup
of a scroll bar where you call

00:16:55.490 --> 00:16:57.980
set control value minimum,
maximum and maybe view size,

00:16:58.060 --> 00:17:00.020
that's four redraws of the
scroll bar right there.

00:17:00.100 --> 00:17:01.600
That's a big waste of performance.

00:17:01.600 --> 00:17:02.850
HIV eliminates that.

00:17:03.010 --> 00:17:06.670
Now instead of redrawing in those APIs,
we mark the appropriate areas

00:17:06.730 --> 00:17:09.010
of the scroll bar as dirty
and needing redraw later.

00:17:09.010 --> 00:17:10.960
And so sometime later,
right before you get

00:17:10.960 --> 00:17:13.850
back into the event loop,
that view will automatically be redrawn.

00:17:15.410 --> 00:17:19.120
The other cool thing compositing mode
does is eliminates the need to erase.

00:17:19.140 --> 00:17:22.260
If you've ever written a custom CDEF,
you knew it was your responsibility

00:17:22.260 --> 00:17:26.790
to call setup control background and
erase before your control actually drew.

00:17:26.960 --> 00:17:29.960
Which meant that if you had a
complex view hierarchy of controls,

00:17:29.960 --> 00:17:32.040
there was a lot of erasing
and redundant drawing of the

00:17:32.040 --> 00:17:34.300
window background going on,
and that's just crummy.

00:17:34.330 --> 00:17:38.270
So we eliminate that in HIView,
which speeds up the drawing pipeline.

00:17:38.780 --> 00:17:41.310
Now, of course, compositing mode means
you can use Quartz really,

00:17:41.310 --> 00:17:44.930
really easily, which gives you access to
all the cool Quartz features.

00:17:44.980 --> 00:17:49.030
And additionally,
the compositing draw model is far

00:17:49.030 --> 00:17:51.530
easier to write than the old draw model.

00:17:51.720 --> 00:17:53.880
In the old draw model,
every time your control

00:17:53.880 --> 00:17:56.080
received certain messages,
it was your responsibility to

00:17:56.080 --> 00:17:58.600
execute your own draw code,
sometimes clipped

00:17:58.600 --> 00:18:00.600
differently or who knows how.

00:18:00.640 --> 00:18:04.080
Well, in the compositing mode,
you only draw at a very well-defined

00:18:04.080 --> 00:18:05.960
time in the K event control draw event.

00:18:05.970 --> 00:18:07.350
So suddenly your code is way simpler.

00:18:07.360 --> 00:18:09.470
You just handle the draw event,
and in your other events,

00:18:09.470 --> 00:18:11.660
you just handle your mouse tracking
or whatever else you need to,

00:18:11.660 --> 00:18:15.880
and you don't need to worry about weird
cross-pollination of functionality.

00:18:16.280 --> 00:18:18.520
So, let me give you a quick demo
of some of the cool things

00:18:18.560 --> 00:18:21.380
Compositing Mode can do for you.

00:18:28.370 --> 00:18:36.010
Okay, so to hammer home a point,
a lot of people made requests over

00:18:36.010 --> 00:18:40.100
time for the ability to draw controls
on top of an arbitrary picture.

00:18:40.160 --> 00:18:43.750
And this is how it would look if you
tried to do that in non-compositing mode.

00:18:43.890 --> 00:18:45.820
The controls try to
erase behind themselves,

00:18:45.930 --> 00:18:47.910
so they blow away whatever
picture was there.

00:18:48.030 --> 00:18:49.450
And sure, there were workarounds, right?

00:18:49.460 --> 00:18:51.100
You could hook into the
Quickdraw bottlenecks on your

00:18:51.100 --> 00:18:54.930
port and try to patch things up,
but those even broke as our views in the

00:18:55.020 --> 00:18:57.070
Toolbox started switching over to Quartz.

00:18:57.190 --> 00:19:00.680
So this is what you ended up with,
which is pretty crummy.

00:19:01.460 --> 00:19:05.290
Instead, with compositing mode,
you get something like this.

00:19:05.390 --> 00:19:07.820
Obviously a lot nicer.

00:19:09.030 --> 00:19:10.460
Now you can see the
controls are animating,

00:19:10.520 --> 00:19:12.890
and some of them,
the disabled button up at the top left,

00:19:12.940 --> 00:19:17.200
you can just barely tell that you
can see the picture through it,

00:19:17.270 --> 00:19:19.550
because that button itself
is partially transparent.

00:19:19.710 --> 00:19:22.490
In addition, the cloud and the sun
is somewhat transparent.

00:19:22.570 --> 00:19:24.640
And as I resize,
you might actually be able

00:19:24.750 --> 00:19:27.590
to see the background moving
underneath them and stuff.

00:19:27.650 --> 00:19:30.270
So one thing that David did when
he wrote this app is he just put a

00:19:30.270 --> 00:19:32.390
little bit of animation in there,
right?

00:19:32.580 --> 00:19:34.130
So clearly not smoke and mirrors.

00:19:34.210 --> 00:19:35.500
This stuff is clearly all live.

00:19:35.500 --> 00:19:36.460
It's very fast.

00:19:36.560 --> 00:19:37.500
It's very easy to use.

00:19:37.500 --> 00:19:39.200
It works really intuitively.

00:19:39.200 --> 00:19:41.800
One other thing I want to show
off with this application is

00:19:41.800 --> 00:19:45.000
if you make this really small,
all those views are overlapping,

00:19:45.070 --> 00:19:48.000
but they're all still properly Z-ordered,
and they all still draw

00:19:48.000 --> 00:19:49.160
in the proper Z-order.

00:19:49.370 --> 00:19:50.930
So you can see, you know,
various things going over

00:19:50.930 --> 00:19:51.610
top of the stop button.

00:19:51.870 --> 00:19:53.120
And, you know,
I can still click on things

00:19:53.120 --> 00:19:54.880
when this is going on,
and tracking still works.

00:19:55.000 --> 00:19:58.290
You know, I can track on -- oh,
hit testing is -- I'm getting

00:19:58.310 --> 00:20:00.800
blocked by other views Z-ordered on
top of this one from hit testing.

00:20:00.830 --> 00:20:01.170
There we go.

00:20:01.270 --> 00:20:03.540
So now I'm actually tracking
in the -- the other button.

00:20:03.540 --> 00:20:04.640
And that all just works.

00:20:04.750 --> 00:20:05.220
It's very cool.

00:20:07.600 --> 00:20:10.420
So not many other view systems
on this platform or otherwise

00:20:10.530 --> 00:20:12.670
can do anything like this.

00:20:16.420 --> 00:20:17.740
So here's a fun little app.

00:20:17.820 --> 00:20:20.300
This is not something I'd
necessarily recommend you do,

00:20:20.300 --> 00:20:24.660
but it might give you some idea of the
power of HIView and compositing mode.

00:20:24.770 --> 00:20:28.390
So like I said before,
every view draws in a

00:20:28.390 --> 00:20:32.000
very well-defined place,
the KEventControlDrawHandler.

00:20:32.060 --> 00:20:35.240
And that handler is passed a
Core Graphics context reference

00:20:35.330 --> 00:20:37.430
to do its drawing with,
and the view must do its

00:20:37.430 --> 00:20:39.200
drawing with that context.

00:20:39.270 --> 00:20:41.590
This means that anybody can
come along to your view,

00:20:41.720 --> 00:20:44.300
intercept handling of the
KEventControlDrawHandler,

00:20:44.330 --> 00:20:48.350
and manipulate the context a little
bit if it wants to for cool reasons.

00:20:48.450 --> 00:20:53.720
So what Eric did is he overwrote the draw
handlers on a couple of these controls

00:20:53.940 --> 00:20:57.940
and transformed the context to scale
up and down the various widgets here.

00:20:57.940 --> 00:20:59.460
Now granted,
there's some artwork problems.

00:20:59.520 --> 00:21:02.300
This is why I don't exactly
recommend that you do this technique.

00:21:02.350 --> 00:21:04.850
But you can see from the scroll bar
in the checkbox that you actually

00:21:04.970 --> 00:21:06.300
get kind of reasonable results.

00:21:06.420 --> 00:21:09.410
So these are the kind of cool things
you can do with compositing mode.

00:21:09.860 --> 00:21:12.500
So let me leave that open.

00:21:12.520 --> 00:21:14.860
And fire up transparent windows.

00:21:14.860 --> 00:21:15.440
OK.

00:21:15.480 --> 00:21:20.320
So Ignignoct here wants to show
you just how cool it is to do

00:21:20.350 --> 00:21:22.040
transparent windows on Carbon.

00:21:22.040 --> 00:21:23.870
This is something we
get requests for a lot.

00:21:24.020 --> 00:21:26.800
How do I do a splash screen with
transparency or something like that?

00:21:26.830 --> 00:21:29.040
This is an example of how
you might achieve that.

00:21:29.050 --> 00:21:33.360
This is an overlay window that inside
of it has a couple views embedded.

00:21:33.370 --> 00:21:36.550
It has a view that's drawing
that image of the character from

00:21:36.550 --> 00:21:39.810
"Aquatine Hunger Force." And there's
also a push button in that window,

00:21:39.810 --> 00:21:41.010
and also this slider.

00:21:41.310 --> 00:21:42.680
And they're all together
in the same window.

00:21:42.680 --> 00:21:43.480
I can move it around.

00:21:43.480 --> 00:21:45.220
It's got a shadow and everything.

00:21:45.270 --> 00:21:49.590
And I did this just by creating a custom
HIView class to render that image,

00:21:49.590 --> 00:21:53.280
and then put a couple other
controls in that window as well.

00:21:53.710 --> 00:21:55.280
But that doesn't exactly meet the goal.

00:21:55.380 --> 00:21:56.510
People want a transparent window.

00:21:56.640 --> 00:22:00.100
So what I did is I wired up this
alpha slider to talk to the other

00:22:00.100 --> 00:22:01.880
view and change its alpha value.

00:22:02.040 --> 00:22:02.850
So I can do stuff like this.

00:22:02.930 --> 00:22:03.530
And it's all live.

00:22:03.530 --> 00:22:04.280
It all keeps working.

00:22:04.280 --> 00:22:06.320
It's really easy to write
and it's really fast.

00:22:06.380 --> 00:22:07.450
And it's all still a window.

00:22:07.620 --> 00:22:10.170
In this button,
I put the standard minimize command.

00:22:10.210 --> 00:22:12.290
So when I click it,
window goes away just like

00:22:12.340 --> 00:22:13.560
you'd normally expect.

00:22:13.580 --> 00:22:15.490
So this stuff is really
powerful and really,

00:22:15.490 --> 00:22:16.310
really easy to use.

00:22:16.490 --> 00:22:18.340
It only took me about an hour to write.

00:22:18.340 --> 00:22:19.160
OK.

00:22:19.160 --> 00:22:24.120
So I can go back to slides, please.

00:22:32.100 --> 00:22:34.760
Okay, so to turn this on,
there's a few things you need to do,

00:22:34.760 --> 00:22:37.480
and I want to cover this from
two different perspectives.

00:22:37.490 --> 00:22:40.360
One is from an app's perspective,
as in they're going to be a

00:22:40.360 --> 00:22:41.840
client of the HIView APIs.

00:22:41.840 --> 00:22:44.300
The other is as a view's perspective,
and I'll cover the

00:22:44.390 --> 00:22:45.800
view's perspective later.

00:22:45.820 --> 00:22:48.320
So from an app's perspective,
what you need to do is go into

00:22:48.320 --> 00:22:51.300
Interface Builder with your
window and turn on the compositing

00:22:51.300 --> 00:22:52.940
mode checkbox for that window.

00:22:52.940 --> 00:22:56.200
If you create it programmatically,
of course, we have the kWindowCompositing

00:22:56.200 --> 00:22:58.350
attribute that you can set.

00:22:58.550 --> 00:23:01.590
Once you've done that,
all drawing in that window

00:23:01.620 --> 00:23:03.480
must be done with HIViews.

00:23:03.500 --> 00:23:05.380
We will no longer send
update events to you.

00:23:05.380 --> 00:23:09.410
You will not get update events for
that window out of WaitNext Event.

00:23:09.520 --> 00:23:11.210
So any drawing that you're
expecting to do through

00:23:11.210 --> 00:23:12.700
WaitNext Event isn't going to happen.

00:23:12.710 --> 00:23:15.580
You've got to put
everything inside HIViews.

00:23:15.610 --> 00:23:19.940
The other major change you need to worry
about is the notion of frame coordinates.

00:23:19.980 --> 00:23:21.840
So if you think back
to the Control Manager,

00:23:21.840 --> 00:23:24.370
when you want to position a button
at the bottom right-hand corner of

00:23:24.380 --> 00:23:29.140
your window in the Control Manager,
you figured out the coordinate,

00:23:29.140 --> 00:23:32.080
the top left coordinate for that button,
as if it were port relative.

00:23:32.230 --> 00:23:33.980
You find out the quick
draw port for the window,

00:23:34.200 --> 00:23:36.290
you find out the appropriate offset
from the top left of that port,

00:23:36.410 --> 00:23:38.380
and you use that as
the button's top left.

00:23:38.450 --> 00:23:41.780
It changes a little bit in
HIView mode and compositing mode.

00:23:41.850 --> 00:23:46.240
Now you specify the button's top
left relative to its parent view.

00:23:46.330 --> 00:23:48.840
So it's just a little change,
something we had to worry about

00:23:48.840 --> 00:23:52.380
when we rev navigation services in
Panther to start using compositing mode,

00:23:52.380 --> 00:23:54.940
but it's also something pretty
easy to get through your head.

00:23:54.940 --> 00:23:58.100
You just do it a couple times and
suddenly it becomes intuitive.

00:23:58.210 --> 00:24:01.160
Another change you need to make is
pretty much elimination of code.

00:24:01.220 --> 00:24:04.790
In compositing mode,
don't call APIs that draw right away.

00:24:04.800 --> 00:24:07.190
Don't call draw one control the
draw control in current port.

00:24:07.280 --> 00:24:08.640
They just don't make sense.

00:24:08.790 --> 00:24:11.400
Compositing mode is
all about invalidation,

00:24:11.400 --> 00:24:13.000
deferring drawing until later.

00:24:13.000 --> 00:24:15.610
So anytime you call draw one control,
you're defeating the purpose of HIView

00:24:15.610 --> 00:24:18.160
and you're slowing your application down.

00:24:18.250 --> 00:24:20.940
Auto embed control is another
API you want to avoid,

00:24:20.990 --> 00:24:23.360
but that's mainly because it doesn't
make sense really in compositing mode.

00:24:23.360 --> 00:24:25.850
It uses a different notion of
coordinates and it tries to figure

00:24:25.850 --> 00:24:26.860
out heuristically what the right,
you know, And it tries to figure out

00:24:26.960 --> 00:24:27.940
heuristically what the right,
you know,

00:24:27.940 --> 00:24:29.760
what the proper parent view would be.

00:24:29.880 --> 00:24:31.940
And it was really there for
dialogue manager compatibility.

00:24:31.940 --> 00:24:32.880
So just avoid it.

00:24:33.000 --> 00:24:36.480
Instead, use an API like HIView add
subview and figure out the parent.

00:24:36.720 --> 00:24:38.330
You'll usually know what
the parent is anyway.

00:24:38.340 --> 00:24:41.370
Just associate the child with the parent.

00:24:42.220 --> 00:24:44.930
So there's also a few steps
from the views perspective,

00:24:44.930 --> 00:24:47.400
and I want to cover them individually.

00:24:47.480 --> 00:24:50.220
So the first thing you can do is
test to see whether compositing

00:24:50.220 --> 00:24:51.770
mode is on for that window.

00:24:51.830 --> 00:24:53.150
You don't have to do this, right?

00:24:53.260 --> 00:24:55.760
Some people write HIViews just
to work in compositing mode.

00:24:55.780 --> 00:24:57.630
In fact,
that's what I did in that last demo app.

00:24:57.700 --> 00:24:59.400
I knew I was only going to
use it in compositing mode,

00:24:59.480 --> 00:25:00.370
so it was really easy to write.

00:25:00.380 --> 00:25:01.860
I didn't bother testing.

00:25:01.920 --> 00:25:05.740
But if you're going to rev to compositing
mode over time in one window and

00:25:05.750 --> 00:25:08.660
then another and another over a
couple of your application's releases,

00:25:08.800 --> 00:25:12.430
you may find it useful to package
your custom content up in views

00:25:12.450 --> 00:25:15.460
that can work in either compositing
mode or non-compositing mode.

00:25:15.460 --> 00:25:18.440
So if you want, you can take a look at
the views owning window,

00:25:18.440 --> 00:25:20.360
see whether the compositing
mode attribute is on,

00:25:20.360 --> 00:25:23.200
and if so, you can behave one way in
compositing mode and another

00:25:23.200 --> 00:25:25.610
way in non-compositing mode.

00:25:28.630 --> 00:25:31.410
The next step is to make sure
you invalidate appropriately.

00:25:31.540 --> 00:25:34.500
Don't draw on those state
changes like I was talking about.

00:25:34.610 --> 00:25:37.410
We send out a handful of
Carbon events when appropriate state

00:25:37.410 --> 00:25:39.500
changes occur in various views.

00:25:39.500 --> 00:25:41.500
We tell you when a view
activates or deactivates,

00:25:41.500 --> 00:25:44.500
when the highlight part changes,
when it enables or disables,

00:25:44.500 --> 00:25:46.500
or when its value changes.

00:25:46.500 --> 00:25:50.600
We also send out Carbon events
any time a view's bounds change,

00:25:50.630 --> 00:25:53.870
so that you can make intelligent
decisions about invalidating exactly

00:25:53.870 --> 00:25:55.500
the portions that need to update.

00:25:55.500 --> 00:25:59.420
This is really useful for a list,
like Data Browser.

00:25:59.660 --> 00:26:02.650
When Data Browser resizes,
it knows all the stuff in the

00:26:02.750 --> 00:26:05.500
upper left-hand corner of itself
doesn't need to get redrawn.

00:26:05.530 --> 00:26:08.620
So it'll just invalidate sort of the
L-shaped region that gets revealed,

00:26:08.620 --> 00:26:10.500
and maybe a few other
bits here and there,

00:26:10.500 --> 00:26:12.500
and just those areas get repainted.

00:26:12.500 --> 00:26:14.740
So when you get one of
these notification APIs,

00:26:14.790 --> 00:26:18.500
you just inform the HIView subsystem
what parts of your view are dirty.

00:26:18.500 --> 00:26:20.970
If the whole thing is dirty,
you can just call HIView

00:26:21.020 --> 00:26:23.430
set needs display,
pass the view, pass true.

00:26:23.500 --> 00:26:24.500
Marks the whole thing
as needing repainting,

00:26:24.500 --> 00:26:24.500
and the whole thing is not.

00:26:25.500 --> 00:26:26.490
Marks the whole thing
as needing repainting,

00:26:26.500 --> 00:26:26.500
and the whole thing will
get repainted later.

00:26:26.510 --> 00:26:29.500
But if you know just some
subpart needs to get redrawn,

00:26:29.500 --> 00:26:32.500
you can use an API like HIView
set needs display in rectangle.

00:26:32.500 --> 00:26:34.550
And there's a couple other
variants of that API,

00:26:34.550 --> 00:26:36.500
so you've got more fine-grained control.

00:26:38.630 --> 00:26:41.720
The next step is to switch your
view over to draw with Quartz.

00:26:41.760 --> 00:26:43.710
You pretty much have to draw
with Quartz in compositing mode.

00:26:43.810 --> 00:26:46.880
Now, that's not literally true,
but that's really the

00:26:46.880 --> 00:26:49.310
recommended solution,
and it's the only way you're going to be

00:26:49.310 --> 00:26:52.040
able to get the free resolution--well,
I can't say free--the low-cost

00:26:52.040 --> 00:26:54.920
resolution independent support,
which I'll talk about later.

00:26:54.920 --> 00:26:58.400
But the key here is that you only draw
on a K-Event controlled draw handler,

00:26:58.400 --> 00:26:59.760
like I mentioned before.

00:26:59.760 --> 00:27:03.360
And that event comes with the
core graphics context ref that

00:27:03.360 --> 00:27:04.500
you're supposed to draw with.

00:27:04.510 --> 00:27:06.390
Don't try to manufacture
one for the Windows port.

00:27:06.400 --> 00:27:07.640
It won't be clipped right.

00:27:07.640 --> 00:27:09.700
It won't necessarily
be transformed right.

00:27:09.700 --> 00:27:11.330
Just use the one in the event.

00:27:11.330 --> 00:27:12.770
It's there for a reason.

00:27:12.770 --> 00:27:13.720
Draw with it.

00:27:13.720 --> 00:27:15.630
Once you've done that,
you can start leveraging whatever

00:27:15.750 --> 00:27:16.870
Quartz features you want.

00:27:16.870 --> 00:27:18.640
You know,
start taking advantage of setting

00:27:18.640 --> 00:27:20.280
the transparency on the context.

00:27:20.280 --> 00:27:20.960
Use Bezier.

00:27:20.960 --> 00:27:22.230
Use whatever you want.

00:27:22.360 --> 00:27:24.260
But the key to remember is never erase.

00:27:24.260 --> 00:27:24.870
Only draw.

00:27:25.140 --> 00:27:28.240
You can count on the fact that
the HIView subsystem has painted

00:27:28.280 --> 00:27:30.300
the views behind you already.

00:27:30.300 --> 00:27:32.400
That's already taken care of.

00:27:32.400 --> 00:27:34.070
And if you want to make a view that
is aqua-compliant and aqua-savvy,

00:27:34.090 --> 00:27:34.990
we have a bunch of HIView subsystems
that are already painted on the screen.

00:27:35.050 --> 00:27:35.850
And if you want to make a view that
is aqua-compliant and aqua-savvy,

00:27:35.850 --> 00:27:38.480
we have a bunch of HITHeme drawing
primitives which are designed

00:27:38.480 --> 00:27:42.050
to be used with core graphics
or with a core graphics context.

00:27:42.150 --> 00:27:45.140
You can take a look in
HIToolbox/HITHeme.h for a

00:27:45.150 --> 00:27:47.530
bunch of different ways to
draw the standard button looks,

00:27:47.610 --> 00:27:49.550
the standard tabs looks,
and things like that.

00:27:53.220 --> 00:27:55.020
So that's step four.

00:27:55.060 --> 00:27:57.750
The next step is maybe
the most gratifying step,

00:27:57.750 --> 00:28:00.360
because it lets you toss out all
kinds of code from your application.

00:28:00.500 --> 00:28:02.880
That's switching to
runApplicationEventLoop.

00:28:02.980 --> 00:28:05.440
So over the course of time,
you put the standard window

00:28:05.440 --> 00:28:08.420
handler on your various windows,
you switch them over to compositing mode,

00:28:08.440 --> 00:28:10.170
and you finally just
finish the last window.

00:28:10.410 --> 00:28:12.220
So now you look at your
waitNextEventLoop and you say,

00:28:12.220 --> 00:28:14.010
wow,
this isn't doing a whole heck of a lot.

00:28:14.060 --> 00:28:17.080
I'm tracking the menus here,
and I'm calling aeprocessAppleEvent,

00:28:17.080 --> 00:28:18.180
and that's about it.

00:28:18.300 --> 00:28:21.610
Well, runApplicationEventLoop can
do that for you and allow for

00:28:21.690 --> 00:28:23.420
more future growth as well.

00:28:23.510 --> 00:28:25.950
So take your waitNextEventLoop,
toss it away,

00:28:26.130 --> 00:28:28.450
put runApplicationEventLoop in its place.

00:28:28.750 --> 00:28:31.800
Now one thing that waitNextEvent
also did that a lot of you rely

00:28:31.800 --> 00:28:33.690
on is give you periodic idle time.

00:28:33.770 --> 00:28:36.880
The problem with doing that through
waitNextEvent is you had to sort of

00:28:36.990 --> 00:28:39.330
centralize your notion of idle time,
and your objects had to

00:28:39.450 --> 00:28:40.560
communicate with waitNextEvent.

00:28:40.560 --> 00:28:43.000
You had to find the smallest time
slice that was needed by any given

00:28:43.000 --> 00:28:44.420
object that wanted to animate it.

00:28:44.420 --> 00:28:45.660
It was just a big mess.

00:28:45.750 --> 00:28:48.160
So instead,
we recommend using CarbonEventTimers.

00:28:48.160 --> 00:28:51.610
CarbonEventTimers are an easy way
to get either periodic processing

00:28:51.660 --> 00:28:54.450
or like one-shot deferred
processing off in the future.

00:28:54.460 --> 00:28:57.340
And it allows you to encapsulate
all of your code with an animating

00:28:57.410 --> 00:28:58.920
view right there in that view.

00:28:58.920 --> 00:29:01.610
That view doesn't need to know it's
operating under waitNextEvent or

00:29:01.610 --> 00:29:04.450
runApplicationEventLoop or whatever.

00:29:05.050 --> 00:29:07.780
Similarly,
WaitNextEvent also allows you to detect

00:29:07.780 --> 00:29:09.770
mouse movement based on a region.

00:29:09.780 --> 00:29:12.720
Well, again,
that had the same kinds of problems.

00:29:12.770 --> 00:29:15.110
Your views that wanted to
communicate with WaitNextEvent had

00:29:15.190 --> 00:29:16.440
to know WaitNextEvent was there.

00:29:16.440 --> 00:29:19.700
You had to figure out the minimal region,
and it was just a big mess.

00:29:19.700 --> 00:29:22.920
So instead, a couple of releases ago,
or maybe last release,

00:29:22.920 --> 00:29:26.220
we gave you tracking areas,
mouse tracking areas.

00:29:26.220 --> 00:29:30.390
And these tracking areas are designed to
manage a window-relative mouse region,

00:29:30.390 --> 00:29:33.880
and you'd get informed of enters
and exits into that region.

00:29:33.880 --> 00:29:36.190
So it's a very handy way
of doing something like

00:29:36.260 --> 00:29:38.940
rollover or cursor changes.

00:29:40.990 --> 00:29:43.320
So once you've switched over
to RunApplicationEventLoop,

00:29:43.390 --> 00:29:46.100
the thing you need to realize
is that RunApplicationEventLoop

00:29:46.100 --> 00:29:48.400
will not return until it's quit.

00:29:48.450 --> 00:29:50.790
And the way you quit it is
with QuitApplicationEventLoop.

00:29:50.870 --> 00:29:52.870
So you put that in an appropriate
place in your application,

00:29:52.940 --> 00:29:55.960
probably like your QuitAppleEvent
handler or something.

00:29:56.060 --> 00:30:00.140
And if you have various places in your
app where you call modal dialog or you

00:30:00.140 --> 00:30:04.040
call waitNextEvent in the fashion where
you're trying to simulate modality,

00:30:04.040 --> 00:30:07.610
the way you would do that now is
with RunAppModalLoop for window.

00:30:07.670 --> 00:30:09.310
You can pass that API a window.

00:30:09.340 --> 00:30:11.460
It will make the window
automatically modal.

00:30:11.460 --> 00:30:13.860
And it quits similarly to
RunApplicationEventLoop.

00:30:13.860 --> 00:30:17.310
You just call
QuitAppModalLoop for window.

00:30:19.660 --> 00:30:21.140
So that's all five steps.

00:30:21.140 --> 00:30:23.530
Once you take advantage of that,
you should be able to

00:30:23.600 --> 00:30:25.990
transfer your application so
it looks something like this.

00:30:26.180 --> 00:30:28.190
Really make it modern,
really make it great,

00:30:28.240 --> 00:30:30.610
start taking advantage of
other new Toolbox features,

00:30:30.680 --> 00:30:32.180
and be prepared for the future.

00:30:32.280 --> 00:30:34.970
The future might be something
like Resolution Independence.

00:30:35.090 --> 00:30:37.360
Hey, speaking of that.

00:30:37.360 --> 00:30:40.950
So,
Resolution Independence is kind of a big,

00:30:40.980 --> 00:30:42.130
big subject.

00:30:42.130 --> 00:30:45.820
So let me see if I can
explain better with a demo.

00:30:45.850 --> 00:30:47.690
It's very visual,
so that should do the trick.

00:30:52.560 --> 00:30:53.900
So maybe I should give a
little bit of background about

00:30:53.900 --> 00:30:58.180
resolution independence first.

00:30:58.290 --> 00:31:00.340
So we don't really have
high DPI hardware yet.

00:31:00.560 --> 00:31:04.740
We know that the industry is moving
that way over the next couple years.

00:31:04.770 --> 00:31:07.710
And we'd much rather have applications
that are going to be ready for that

00:31:07.740 --> 00:31:09.340
hardware when it becomes available.

00:31:09.420 --> 00:31:12.240
So we don't want you waiting to start
thinking about resolution independence

00:31:12.320 --> 00:31:13.570
until after the hardware shows up.

00:31:13.700 --> 00:31:15.540
We all know the hardware is
eventually going to show up.

00:31:15.640 --> 00:31:17.390
So let's start thinking
about these topics now.

00:31:17.480 --> 00:31:20.300
Start considering how you can
adopt resolution independence

00:31:20.300 --> 00:31:21.490
in your application.

00:31:24.020 --> 00:31:24.820
All right.

00:31:24.820 --> 00:31:26.360
So I've got this app.

00:31:26.410 --> 00:31:28.580
It's called Resolution Modes.

00:31:28.580 --> 00:31:29.920
Right now, it looks pretty normal.

00:31:29.920 --> 00:31:31.220
These are three windows.

00:31:31.220 --> 00:31:34.760
The windows are basically identical,
except for one slight change I made

00:31:34.760 --> 00:31:37.850
to each of them in Interface Builder.

00:31:37.880 --> 00:31:41.650
So that's how they look now,
but if you launch Quartz Debug

00:31:41.670 --> 00:31:45.080
and you go up to the Tools menu,
there's a new item called

00:31:45.100 --> 00:31:48.100
Show User Interface Resolution,
which gives you a little

00:31:48.100 --> 00:31:49.760
slider with a multiplier on it.

00:31:49.890 --> 00:31:53.300
If you change the value on this slider,
it multiplies the resolution

00:31:53.400 --> 00:31:54.480
that apps will run in.

00:31:54.670 --> 00:32:00.800
So if I move it up to 1.25,
relaunch my resolution modes application,

00:32:00.800 --> 00:32:03.740
you can see that the windows
got a little bit bigger.

00:32:03.900 --> 00:32:05.380
But you don't have to stop at 1.25.

00:32:05.380 --> 00:32:08.420
I'm actually going to
go really high here.

00:32:08.730 --> 00:32:11.270
So you can see it a little bit better.

00:32:11.330 --> 00:32:15.650
OK, so this window,
which is titled Magnified--

00:32:15.660 --> 00:32:20.690
let me see if I can get these
other windows out of the way.

00:32:21.280 --> 00:32:23.980
This magnified window has
not been modified at all.

00:32:24.190 --> 00:32:29.800
In fact, this application's core event
processing has not been modified at all.

00:32:29.900 --> 00:32:31.230
And this is the result.

00:32:31.350 --> 00:32:34.820
Sure, you get a bigger window,
but it looks a little grainy, right?

00:32:34.820 --> 00:32:36.780
I don't know if you can
see it on the big screen,

00:32:36.790 --> 00:32:39.340
but the magnified text
is a little blurry.

00:32:39.340 --> 00:32:40.910
It certainly looks like
it's been blown up.

00:32:41.060 --> 00:32:42.890
Well,
that's because it has been blown up.

00:32:43.050 --> 00:32:46.940
Magnified mode is what you will
get by default for any non-savvy

00:32:46.940 --> 00:32:49.260
window in your application.

00:32:49.360 --> 00:32:51.370
How we do this is we
tell the Windows server,

00:32:51.370 --> 00:32:54.830
look, this is a window that doesn't know
it's in resolution independence,

00:32:54.970 --> 00:32:57.220
or that it's under a scale factor.

00:32:57.220 --> 00:32:59.290
So please blow it up for me.

00:32:59.330 --> 00:33:01.230
Your Windows backing
store is still very small.

00:33:01.300 --> 00:33:04.970
So when we blow it up bigger,
you get kind of grainy.

00:33:05.510 --> 00:33:10.640
Now, there are two resolution-independent
savvy modes you can set on a window.

00:33:10.690 --> 00:33:13.100
First one I want to talk about
is Framework Scaled Mode.

00:33:13.210 --> 00:33:15.060
Now, obviously,
this window looks a lot better.

00:33:15.170 --> 00:33:18.400
You can see the text in the
text area is a lot crisper.

00:33:18.410 --> 00:33:23.400
The picture still looks kind of crummy,
but where are we?

00:33:23.580 --> 00:33:25.920
Can I not switch?

00:33:26.010 --> 00:33:29.640
Oh, we have bad things happening.

00:33:29.660 --> 00:33:31.560
Oh, we have really bad things happening.

00:33:31.560 --> 00:33:31.900
All right.

00:33:35.490 --> 00:33:35.900
Cool.

00:33:35.900 --> 00:33:38.420
All right, I've got to reboot the
machine from back here.

00:33:41.290 --> 00:33:42.360
And I can't get to the front.

00:33:42.510 --> 00:33:45.320
Alright, well, strictly speaking,
the demos are not necessary,

00:33:45.390 --> 00:33:47.590
so I'll just, uh...

00:33:50.150 --> 00:33:53.900
I'll just cover more detail here,
I guess.

00:33:54.080 --> 00:33:55.260
So Magnified Mode.

00:33:55.260 --> 00:33:57.040
Magnified Mode is the fallback case.

00:33:57.060 --> 00:34:00.050
This isn't really what you want to
have your application look like,

00:34:00.050 --> 00:34:01.640
but it'll work in a pinch.

00:34:01.670 --> 00:34:05.780
It'll allow users to get something
reasonable with your application,

00:34:05.780 --> 00:34:09.000
even if your application has not
revved for resolution independence.

00:34:09.010 --> 00:34:11.940
Like I showed, it looks kind of crummy,
particularly compared to the other mode,

00:34:12.050 --> 00:34:14.400
but it doesn't take any
effort on your part.

00:34:14.410 --> 00:34:16.640
Now, unfortunately,
I didn't actually get to show this,

00:34:16.640 --> 00:34:18.170
but David's going to
try to troubleshoot it,

00:34:18.260 --> 00:34:19.300
so maybe I can.

00:34:19.350 --> 00:34:23.210
The next mode is Application Scaled Mode.

00:34:23.280 --> 00:34:25.920
This mode is not the
second window I showed.

00:34:25.940 --> 00:34:27.860
It was that little
small one that came up.

00:34:27.920 --> 00:34:30.990
Application Scaled Mode is a
mode where you do all the work.

00:34:31.050 --> 00:34:32.900
Well, you do most of the work.

00:34:32.950 --> 00:34:35.430
The benefit of Application Scaled
Mode is that you can actually

00:34:35.430 --> 00:34:38.340
use Quick Draw in that mode,
unlike the third mode.

00:34:38.420 --> 00:34:42.460
So when you specify you want your window
to work in Application Scaled Mode,

00:34:42.510 --> 00:34:46.840
you're responsible for making
all parts of that window bigger,

00:34:46.870 --> 00:34:50.660
except subcomponents of
things driven by the toolbox.

00:34:50.790 --> 00:34:53.640
So if we can get this back up,
I can show you what I mean.

00:34:53.640 --> 00:34:58.660
The Application Scaled Mode window
was still at the same size as it

00:34:58.660 --> 00:35:01.650
was when the scale factor was 1.0,
but the title bar was

00:35:01.650 --> 00:35:02.470
a little bit bigger.

00:35:02.640 --> 00:35:04.950
Well, the title bar was bigger because
it's handled by the system,

00:35:04.950 --> 00:35:07.630
and we know to apply the
appropriate multiplier to it.

00:35:07.710 --> 00:35:09.620
And another thing you could
have seen there is that the

00:35:09.630 --> 00:35:10.860
text was a little bit bigger.

00:35:10.860 --> 00:35:13.640
We know the system font,
when somebody requests the system font,

00:35:13.750 --> 00:35:15.500
isn't just 13 pixels tall anymore.

00:35:15.500 --> 00:35:17.700
It's 13 times some multiplier tall,
so we made it bigger.

00:35:17.730 --> 00:35:21.090
But the problem was,
all the views inside that

00:35:21.100 --> 00:35:24.240
window that the application put
there were still the same size,

00:35:24.320 --> 00:35:26.690
and that's because that
app hadn't modified yet.

00:35:26.760 --> 00:35:29.530
An application that uses
Application Scaled Mode on its

00:35:29.640 --> 00:35:33.940
windows is responsible for sizing the
window content area bigger as well,

00:35:34.020 --> 00:35:36.200
and then you resize all
the views inside of it.

00:35:36.320 --> 00:35:38.490
This is the price you have
to pay for using Quick Draw.

00:35:38.580 --> 00:35:40.930
Now, we really would prefer
you to not use Quick Draw.

00:35:41.040 --> 00:35:44.370
If you can just switch over to HIV,
switch over to drawing with Quartz,

00:35:44.520 --> 00:35:46.900
you can take advantage
of Framework Scaled Mode.

00:35:47.040 --> 00:35:50.210
Cool thing about Framework Scaled
Mode is you get a really good appearance,

00:35:50.210 --> 00:35:52.060
and it's really, really easy to do.

00:35:52.150 --> 00:35:54.710
The second window that showed
up there that I was comparing

00:35:54.830 --> 00:35:57.720
the magnified window to,
that was an Application Scaled Mode.

00:35:57.900 --> 00:36:01.480
The only change I made to that window
relative to the magnified mode is I went

00:36:01.480 --> 00:36:04.640
into Interface Builder and changed
the value in a pop-up menu to say,

00:36:04.680 --> 00:36:07.170
"Please Framework Scale this,"
and you get all the rest for free.

00:36:07.270 --> 00:36:08.740
Events still get routed right.

00:36:08.820 --> 00:36:12.450
So speaking of event routing,
this is something I need

00:36:12.450 --> 00:36:13.900
to show off there.

00:36:14.100 --> 00:36:16.710
That was one application,
had three windows,

00:36:16.760 --> 00:36:19.200
and each of those windows
was in a different mode.

00:36:19.200 --> 00:36:22.300
Now, we don't necessarily know how that
application is getting events.

00:36:22.400 --> 00:36:24.260
It might be in a wait-next-event loop,
it might be in

00:36:24.260 --> 00:36:25.900
run-application-event loop,
who knows?

00:36:26.070 --> 00:36:28.000
It may be savvy, it may not.

00:36:28.140 --> 00:36:31.990
So what we have to do is,
since by default we magnify windows,

00:36:32.110 --> 00:36:36.000
we need to make sure that all global
coordinates that come through APIs,

00:36:36.000 --> 00:36:38.340
that get passed into APIs,
and that come out of structures

00:36:38.340 --> 00:36:41.380
like an event record,
all map to the coordinate space

00:36:41.420 --> 00:36:44.000
that a magnified window uses.

00:36:44.000 --> 00:36:47.640
So essentially what we do is we
magnify all the coordinates that

00:36:47.650 --> 00:36:52.200
come out of those sorts of APIs.

00:36:52.780 --> 00:36:54.930
Now, this is still a little bit
of work in progress here,

00:36:55.010 --> 00:36:56.450
and I've got another slide
that talks about this,

00:36:56.450 --> 00:37:02.060
but what we're going to try to do
is make it so that APIs that talk

00:37:02.170 --> 00:37:06.680
specifically about a window that we know
is either in application scaled mode

00:37:06.700 --> 00:37:10.700
or framework scaled mode can be used
with coordinates that are not magnified.

00:37:10.700 --> 00:37:13.370
So we're going to do
as best we can there.

00:37:13.810 --> 00:37:16.170
So really,
my point here is that these coordinates

00:37:16.170 --> 00:37:20.190
may be coming back in a way that at first
feels a little counterintuitive to you,

00:37:20.190 --> 00:37:21.700
but it'll make sense eventually.

00:37:21.700 --> 00:37:25.160
And we have a bunch of APIs that
can help you convert points from the

00:37:25.160 --> 00:37:29.180
sort of magnified sense of global
to the true pixel sense of global.

00:37:32.180 --> 00:37:36.240
Okay, so to turn on resolution
independence for your application,

00:37:36.340 --> 00:37:37.390
start with a window.

00:37:37.550 --> 00:37:38.860
Go into Interface Builder.

00:37:38.910 --> 00:37:41.770
There's now a little pop-up
menu there that says Scale Mode,

00:37:41.770 --> 00:37:42.400
I think.

00:37:42.400 --> 00:37:47.080
It's got three choices: Magnified,
App Scaled, and Framework Scaled.

00:37:47.100 --> 00:37:49.330
If you can't use the pop-up
menu and you need to create

00:37:49.330 --> 00:37:52.710
your windows programmatically,
we've got creation attributes for those,

00:37:52.710 --> 00:37:53.470
of course.

00:37:53.970 --> 00:37:56.250
Once you do that,
your application may or may not

00:37:56.250 --> 00:37:59.900
want to take advantage of that
knowledge inside your code.

00:37:59.940 --> 00:38:01.900
Obviously,
if you're in application scaled mode,

00:38:01.900 --> 00:38:04.460
you have to take advantage of
that knowledge because you're

00:38:04.460 --> 00:38:05.940
required to do a bunch of work.

00:38:05.960 --> 00:38:08.280
So you can determine a window's
scale mode at runtime by

00:38:08.280 --> 00:38:09.900
calling hiwindow.getScaleMode.

00:38:09.960 --> 00:38:12.700
It passes back whether or not the
window is running in app scaled mode or

00:38:12.700 --> 00:38:14.900
framework scaled mode or magnified mode.

00:38:14.900 --> 00:38:17.420
And additionally,
it hands back the scale factor in case

00:38:17.420 --> 00:38:20.900
you need to do multiplication to figure
out an appropriate size for a view.

00:38:20.900 --> 00:38:24.250
But if you want the user
scale factor without a window,

00:38:24.250 --> 00:38:26.900
we also have a convenience API for that.

00:38:26.900 --> 00:38:30.700
And like I mentioned before,
we have a whole bunch of coordinate

00:38:30.700 --> 00:38:34.440
conversion APIs in HIGeometry.h,
which were originally intended for

00:38:34.440 --> 00:38:35.900
use with resolution independence.

00:38:35.900 --> 00:38:38.770
But they actually end up being
really cool because they allow you

00:38:38.840 --> 00:38:41.900
to do things like translate between
a view and window coordinates,

00:38:41.900 --> 00:38:43.650
or a view's coordinates in
one window with a view's

00:38:43.650 --> 00:38:46.000
coordinates in another window,
which in rare circumstances

00:38:46.000 --> 00:38:46.900
might prove useful.

00:38:46.900 --> 00:38:49.890
But I found a couple of cool
things to do with those.

00:38:49.990 --> 00:38:52.900
Oh, the other cool thing about these
conversion APIs is up until now,

00:38:52.900 --> 00:38:57.460
the toolbox didn't have a great way,
like a one-stop shopping way,

00:38:57.460 --> 00:39:00.890
to take a global coordinate and
convert it to a window coordinate.

00:39:00.920 --> 00:39:03.160
Most of the time,
I think we recommended people

00:39:03.230 --> 00:39:05.900
convert that point to the
window's port coordinates,

00:39:05.900 --> 00:39:08.880
and then you can call QD local
to global and stuff like that.

00:39:08.930 --> 00:39:10.900
It was a little bit nasty.

00:39:10.900 --> 00:39:14.880
So now this set of APIs can
also achieve that for you.

00:39:14.900 --> 00:39:15.700
So hang on.

00:39:15.950 --> 00:39:16.900
Is it good?

00:39:16.900 --> 00:39:17.480
Bad?

00:39:18.060 --> 00:39:18.640
Bad.

00:39:18.640 --> 00:39:19.780
Okay.

00:39:22.020 --> 00:39:24.970
All right, so first thing to realize,
and the demo would have

00:39:24.970 --> 00:39:27.970
shown this as well,
is resolution independence for

00:39:27.970 --> 00:39:29.490
Tiger is a work in progress.

00:39:29.510 --> 00:39:31.810
It's intended as a
developer-only feature.

00:39:31.810 --> 00:39:34.720
You should not ship your applications
with this stuff turned on.

00:39:35.030 --> 00:39:36.540
Things could even change, right?

00:39:36.540 --> 00:39:39.310
We're not done developing and
engineering it internally,

00:39:39.310 --> 00:39:41.710
so we could have a few new
paradigms here and there.

00:39:41.710 --> 00:39:42.940
We just don't know yet.

00:39:42.940 --> 00:39:45.220
The least ready mode is
application scale mode,

00:39:45.250 --> 00:39:45.690
right?

00:39:45.690 --> 00:39:48.480
I did magnified mode first,
and that was really easy to do.

00:39:48.480 --> 00:39:52.290
And then we did framework scale mode,
and that was pretty easy to do.

00:39:52.570 --> 00:39:55.740
Application scale mode is taking a lot
more change throughout the Toolbox,

00:39:55.790 --> 00:39:56.690
so we'll get there.

00:39:56.690 --> 00:39:59.950
But it's not quite ready for
prime time on the Tiger seat.

00:40:00.240 --> 00:40:01.980
But still, I encourage you to try it out.

00:40:02.130 --> 00:40:04.230
You'll see very obvious visual artifacts.

00:40:04.230 --> 00:40:06.650
Just blame the Toolbox,
keep moving forward,

00:40:06.650 --> 00:40:11.400
see if you can continue exercising
the APIs and developing on it.

00:40:12.360 --> 00:40:15.270
But probably the coolest thing here is,
unlike previous WWDCs where we've given

00:40:15.270 --> 00:40:18.190
you this little window of time saying,
"Please give us your feedback," like,

00:40:18.300 --> 00:40:19.970
in the next two days
so we can implement it.

00:40:20.150 --> 00:40:22.590
This, because it's not going to
be a user feature for Tiger,

00:40:22.590 --> 00:40:25.380
we actually have a little bit window,
a little bit bigger window of

00:40:25.390 --> 00:40:26.940
opportunity to hear your feedback.

00:40:27.180 --> 00:40:29.420
And this is really important,
because there's a huge variety

00:40:29.420 --> 00:40:31.920
of applications out there,
particularly the ones that are going

00:40:31.960 --> 00:40:33.590
to need to use Application Scale mode.

00:40:33.660 --> 00:40:37.830
And I need to hear from you what sort of
things we could do with convenience APIs,

00:40:37.830 --> 00:40:39.890
what extra support you could need.

00:40:39.890 --> 00:40:42.550
You know, maybe you need a few
new APIs to help with,

00:40:42.680 --> 00:40:46.280
you know, blowing up your--blowing up a
window after you instantiate it

00:40:46.390 --> 00:40:47.450
from a nib or something like that.

00:40:47.540 --> 00:40:48.900
So please, try this stuff out.

00:40:48.900 --> 00:40:52.200
Start making a little brainstorm list of
things we might be able to do for you.

00:40:52.280 --> 00:40:54.080
Write bugs,
contact us on the mailing list.

00:40:54.160 --> 00:40:55.190
I want to hear your feedback.

00:40:55.200 --> 00:40:58.730
We also have a document referenced
by our HIToolbox release

00:40:58.820 --> 00:41:02.300
notes on your developer seed,
which is Carbon Resolution

00:41:02.300 --> 00:41:03.650
Independence Notes.

00:41:03.660 --> 00:41:07.110
It takes advantage of some knowledge
that's also in a sort of overarching

00:41:07.150 --> 00:41:10.660
resolution independence document
that's also in the release notes.

00:41:10.660 --> 00:41:12.520
So I encourage you to read both of those.

00:41:12.560 --> 00:41:13.640
It's going to go into more detail.

00:41:13.700 --> 00:41:15.230
In fact,
it'll cover some of the stuff I would

00:41:15.270 --> 00:41:16.660
have been able to cover in the demo.

00:41:16.660 --> 00:41:19.600
So please check that out.

00:41:20.470 --> 00:41:24.070
All right, so the rest of our time,
we've been doing things

00:41:24.070 --> 00:41:25.330
that you've asked us for.

00:41:25.440 --> 00:41:26.670
We pay attention to the mailing list.

00:41:26.850 --> 00:41:34.370
Obviously, we have Eric the Android on
the Carbon development list,

00:41:34.370 --> 00:41:34.370
responding to messages as soon as he can.

00:41:34.370 --> 00:41:34.370
And we hear what you ask for.

00:41:35.080 --> 00:41:37.510
And we've done a few of
those things for Tiger.

00:41:37.630 --> 00:41:39.200
The first thing,
which I think is the coolest,

00:41:39.200 --> 00:41:42.640
is that we actually now have text
notifications that you can get one-stop

00:41:42.830 --> 00:41:46.180
shopping knowledge whenever a text
in one of our Unicode fields changes.

00:41:46.330 --> 00:41:49.010
Doesn't matter if it was pasted in.

00:41:49.660 --> 00:41:52.320
Doesn't matter if it was typed in,
doesn't matter if there's inline input,

00:41:52.390 --> 00:41:52.820
who cares?

00:41:52.940 --> 00:41:54.600
You just get this notification.

00:41:54.770 --> 00:41:58.440
Similarly, there's the text should change
in range event that's sent out so

00:41:58.570 --> 00:42:00.580
you can have one-stop filtering.

00:42:00.610 --> 00:42:02.730
You can filter the text,
you can change it, block it,

00:42:02.730 --> 00:42:05.600
whatever you want, doesn't matter how the
text was put in there,

00:42:05.650 --> 00:42:06.590
you can do it.

00:42:06.660 --> 00:42:09.590
And we send this to all of
our Unicode-based edit fields.

00:42:09.660 --> 00:42:12.650
It doesn't work with the old text edit,
or edit text control,

00:42:12.770 --> 00:42:14.600
but everything more modern than that.

00:42:14.600 --> 00:42:19.800
The search field, the combo box,
the HITextView, the Unicode edit field,

00:42:19.800 --> 00:42:21.590
works with all of those.

00:42:21.750 --> 00:42:22.590
But there's a catch.

00:42:22.590 --> 00:42:23.590
That's not really a big catch.

00:42:23.590 --> 00:42:25.600
That's probably a
little too scary to say.

00:42:25.630 --> 00:42:29.600
On the seed, it doesn't quite work
right for a few edge cases.

00:42:29.600 --> 00:42:32.530
So while I encourage you to try this out,
please, you know, start switching your

00:42:32.530 --> 00:42:33.550
applications over to it.

00:42:33.800 --> 00:42:36.170
Take a look at the release notes,
see those couple edge cases

00:42:36.170 --> 00:42:38.240
where we know there's a problem,
and, you know,

00:42:38.240 --> 00:42:40.640
it'll save you time from having
to write the bug and we'll say,

00:42:40.650 --> 00:42:43.020
"Oh, no, no, we already fixed this,
we already know about it." So just take

00:42:43.020 --> 00:42:44.600
a look and see what those edge cases are.

00:42:44.600 --> 00:42:46.610
But other than that,
I encourage you to adopt

00:42:46.720 --> 00:42:47.720
this as soon as possible.

00:42:49.610 --> 00:42:51.970
Now we also expanded
the set of HIView APIs.

00:42:52.080 --> 00:42:54.240
Our first set wasn't really complete.

00:42:54.350 --> 00:42:56.940
I mean, it was functionally complete
because you could always rely on

00:42:56.940 --> 00:42:58.160
the control manager equivalence.

00:42:58.330 --> 00:43:02.300
But what we did is we put together a
whole new--another set of HIView APIs to

00:43:02.300 --> 00:43:04.480
sort of fill in all those missing holes.

00:43:04.480 --> 00:43:06.640
Well, all but one percent of those holes.

00:43:06.820 --> 00:43:09.340
But still,
we've got APIs like HIViewSetValue,

00:43:09.340 --> 00:43:10.660
HIViewCountSubViews.

00:43:10.660 --> 00:43:12.410
So your code is a lot more readable.

00:43:12.660 --> 00:43:14.750
And in addition,
we took the chance to modernize

00:43:14.750 --> 00:43:16.260
a few of the APIs so that,
you know,

00:43:16.260 --> 00:43:18.760
there was some clunky mechanisms
in the control manager side.

00:43:18.850 --> 00:43:22.190
We smoothed those over in
the HIView equivalence.

00:43:22.310 --> 00:43:25.820
The coolest part about this though is
that we had a big request to give back

00:43:25.920 --> 00:43:28.240
latent state information about our views.

00:43:28.240 --> 00:43:31.790
I'm sure some of you have switched
on compositing mode and you have an

00:43:31.830 --> 00:43:35.990
invisible window and you have a view
that you just called HIViewSetVisible.

00:43:36.090 --> 00:43:37.400
True, you know it's visible.

00:43:37.400 --> 00:43:39.140
It's definitely logically visible.

00:43:39.160 --> 00:43:41.600
But if you called HIViewIsVisible,
you get back false.

00:43:41.610 --> 00:43:43.900
Well,
that's because the compositing subsystem

00:43:43.900 --> 00:43:46.540
tells you a view's physical visibility,
not its logical visibility.

00:43:46.540 --> 00:43:48.290
So now we return the latent states.

00:43:48.290 --> 00:43:51.900
We have a new API to deal
with the latent visibility.

00:43:51.910 --> 00:43:55.240
We had to do a new API for that one
because we already had HIViewIsVisible,

00:43:55.410 --> 00:43:58.700
which obviously just returned
the physical visibility.

00:43:58.880 --> 00:44:02.970
But we added two new HIViewIsActive
and HIViewIsEnabled APIs,

00:44:02.970 --> 00:44:05.730
which tell you the physical
enabled and active state as

00:44:05.820 --> 00:44:07.120
well as the latent states.

00:44:07.280 --> 00:44:10.580
So it should make dealing with some
of your edge cases a lot better.

00:44:12.320 --> 00:44:16.130
We also had a request for more
fine-grained control over exactly

00:44:16.140 --> 00:44:20.200
which windows in your application
were supported by Expose.

00:44:20.200 --> 00:44:24.040
So we have the HI Window Get and
Set Availability APIs that allow

00:44:24.040 --> 00:44:29.030
you to control whether or not a
window gets handled by Expose.

00:44:31.200 --> 00:44:33.350
Now, I know I mentioned
tracking areas already.

00:44:33.350 --> 00:44:35.720
And I'm sure some of you were thinking,
yeah, yeah, right, tracking areas.

00:44:35.770 --> 00:44:36.500
They're a big pain.

00:44:36.500 --> 00:44:37.930
I try to use them with my HIViews.

00:44:38.030 --> 00:44:39.400
But HIViews are parent relative.

00:44:39.400 --> 00:44:40.810
And when they move,
I don't really know it.

00:44:40.810 --> 00:44:42.180
And then I've got to
try to figure it out,

00:44:42.180 --> 00:44:43.930
which means I have to
install hand event handlers.

00:44:44.030 --> 00:44:45.440
Anyway, we know.

00:44:45.550 --> 00:44:45.790
We know.

00:44:45.800 --> 00:44:46.830
We've had to do it ourselves.

00:44:46.870 --> 00:44:47.490
It really sucks.

00:44:47.640 --> 00:44:51.070
So what we did is we made
HIView-based tracking areas.

00:44:51.380 --> 00:44:54.010
Exact same concept,
very similar usage model,

00:44:54.290 --> 00:44:56.420
except the tracking areas
are bound to a view.

00:44:56.690 --> 00:44:59.320
Now, we know when a view moves
in a window relative space.

00:44:59.380 --> 00:45:02.910
So we can automatically adjust the
tracking area for you automatically.

00:45:03.050 --> 00:45:04.180
Automatically do it automatically?

00:45:04.190 --> 00:45:04.750
Anyway.

00:45:04.850 --> 00:45:07.290
So we send Carbon events directly
to the view whenever the mouse

00:45:07.290 --> 00:45:08.570
moves in or out of that view.

00:45:08.650 --> 00:45:10.700
So they're really easy to use.

00:45:10.810 --> 00:45:12.300
Suggest you adopt these wherever you can.

00:45:12.300 --> 00:45:15.830
They're a great way of doing
rollover or mouse tracking.

00:45:18.530 --> 00:45:20.580
Other people that started
adopting compositing said,

00:45:20.640 --> 00:45:24.200
"Compositing is great,
until I try to scroll a view greater

00:45:24.200 --> 00:45:25.820
than the Quickdraw coordinate space?

00:45:25.970 --> 00:45:26.900
That doesn't make any sense.

00:45:26.900 --> 00:45:28.640
It's supposed to be quartz-based." Yeah,
yeah, I know.

00:45:28.640 --> 00:45:33.260
The internals of the control manager used
to be based on Quickdraw coordinates,

00:45:33.390 --> 00:45:35.900
even though we supported
this cool compositing mode.

00:45:35.910 --> 00:45:39.890
And unfortunately, that was prevalent
throughout various events.

00:45:39.900 --> 00:45:42.770
We sent events to views saying,
"Tell me your structure region." Well,

00:45:42.770 --> 00:45:44.400
that's a Quickdraw region.

00:45:44.400 --> 00:45:48.300
Quickdraw regions are inherently
limited to 16-bit integer coordinates.

00:45:48.350 --> 00:45:49.390
It wasn't so good.

00:45:49.400 --> 00:45:52.400
So what we did is we
came up with HISHAPE.

00:45:52.400 --> 00:45:55.390
HISHAPE now has full integration
into the HIView subsystem.

00:45:55.490 --> 00:46:00.040
You can now communicate region-type
concepts in a way that breaks the

00:46:00.070 --> 00:46:03.400
16-bit Quickdraw limit of coordinates.

00:46:03.400 --> 00:46:06.140
HISHAPE also allows us to
improve performance throughout

00:46:06.140 --> 00:46:07.390
the HIView subsystem.

00:46:07.400 --> 00:46:10.440
We don't need to do as many
translations back and forth from

00:46:10.440 --> 00:46:12.400
Quickdraw coordinates anymore.

00:46:12.400 --> 00:46:13.370
more.

00:46:13.420 --> 00:46:14.260
So it's a boon there.

00:46:16.720 --> 00:46:19.340
We also added a few
new accessibility APIs.

00:46:19.340 --> 00:46:22.560
For those of you who got a chance
to see the accessibility sessions

00:46:22.560 --> 00:46:25.600
and the voiceover sessions,
these should help out a lot.

00:46:25.600 --> 00:46:29.600
We have a very easy way to add extra
attributes to an existing element,

00:46:29.600 --> 00:46:30.590
like, say, a push button.

00:46:30.670 --> 00:46:32.960
You want to give it a description,
you can use the

00:46:32.960 --> 00:46:36.590
SetAuxiliaryAccessibilityAttribute
API to do that really easily.

00:46:36.600 --> 00:46:39.860
In addition,
those of you who are implementing

00:46:39.890 --> 00:46:43.370
accessibility for your own objects,
but you need to use the

00:46:43.370 --> 00:46:45.600
standard roles and you want
the standard role descriptions,

00:46:45.600 --> 00:46:47.560
we have a way that you can
query the standard role

00:46:47.560 --> 00:46:50.060
description that the system uses.

00:46:50.700 --> 00:46:53.810
We also have a way that you can
easily override the accessibility

00:46:53.810 --> 00:46:55.700
hierarchy provided by an object.

00:46:55.700 --> 00:46:56.560
This is kind of an edge case.

00:46:56.560 --> 00:46:58.890
I bet most of you won't need to use it,
but if you do run into

00:46:58.890 --> 00:47:01.460
one of those situations,
we have an API that can help out.

00:47:01.600 --> 00:47:03.610
And finally,
one thing we realized when we

00:47:03.610 --> 00:47:06.600
were working with Finder to
provide accessibility information

00:47:06.620 --> 00:47:09.570
for their ListView is that,
you know, Data Browser is really great,

00:47:09.600 --> 00:47:12.760
but-- and Data Browser's accessibility
implementation is really good too,

00:47:12.900 --> 00:47:15.010
but we need to interject
some extra info in there,

00:47:15.010 --> 00:47:15.600
right?

00:47:15.600 --> 00:47:18.590
What is just a row in one
application might need to be called

00:47:18.660 --> 00:47:22.600
something else in my application,
so I want to be able to customize

00:47:22.600 --> 00:47:23.560
what Data Browser provides.

00:47:23.600 --> 00:47:26.430
And so we have a set of
APIs that allow you to modify the

00:47:26.430 --> 00:47:30.440
information sent out or passed into
Data Browser for any given element.

00:47:30.470 --> 00:47:31.600
It's pretty cool.

00:47:31.690 --> 00:47:34.600
Take a look at
controldefinitions.h for that.

00:47:34.600 --> 00:47:37.600
In fact, let's see,
that was this morning.

00:47:37.600 --> 00:47:39.600
Right,
so if you want more details on this,

00:47:39.650 --> 00:47:44.600
see if you can travel back in time a
few hours and check out session 424.

00:47:44.600 --> 00:47:45.580
We covered a lot of accessibility.

00:47:45.600 --> 00:47:46.590
information there.

00:47:49.450 --> 00:47:52.060
One thing we did to the toolbar to
kind of expand the possibilities for

00:47:52.090 --> 00:47:57.130
what you can do is allow for per window
enabling and disabling of toolbar items,

00:47:57.190 --> 00:47:58.830
as well as selection of toolbar items.

00:47:58.920 --> 00:48:03.250
So what I mean is you can have two
windows that use the same toolbar object,

00:48:03.370 --> 00:48:05.630
you know,
they both bind to the same toolbar,

00:48:05.970 --> 00:48:08.950
but you want,
let's say you want the delete button

00:48:08.950 --> 00:48:11.600
in the toolbar to be enabled in
one window but not in the other.

00:48:11.700 --> 00:48:14.130
Well, up to now,
there wasn't really a way to do that.

00:48:14.250 --> 00:48:18.200
What you ended up having to do is create
two different toolbar instances for each,

00:48:18.200 --> 00:48:20.500
or one for each window,
and that was kind of a pain.

00:48:20.620 --> 00:48:26.710
So we built in per window selection
enabling and disabling support.

00:48:26.980 --> 00:48:28.920
Now the cool thing is that
the Toolbar can manage the

00:48:28.930 --> 00:48:30.400
selection for you automatically.

00:48:30.560 --> 00:48:33.230
All you need to do is have
your Toolbar delegate respond

00:48:33.230 --> 00:48:36.700
to a Carbon event that says,
"Hey, tell me the selectable items."

00:48:36.850 --> 00:48:38.440
If you respond to that,
the Toolbar can manage

00:48:38.440 --> 00:48:39.780
it for you automatically.

00:48:39.800 --> 00:48:41.780
It'll just track the selection,
change the selection,

00:48:41.840 --> 00:48:44.200
send out a Carbon event when that
selection change has happened that

00:48:44.200 --> 00:48:45.390
you can listen to if you need to.

00:48:48.300 --> 00:48:51.510
There's lots of other stuff that
I just don't have time to cover today,

00:48:51.510 --> 00:48:54.200
though since my demos crashed,
I could probably talk about stuff.

00:48:54.200 --> 00:48:56.440
Let's see.

00:48:56.540 --> 00:48:57.220
Let's see what I can do here.

00:48:57.430 --> 00:48:58.940
HIobject archiving.

00:48:58.940 --> 00:49:00.550
I don't think this is actually turned on.

00:49:00.560 --> 00:49:01.080
Is that true?

00:49:01.340 --> 00:49:03.060
Yeah, unfortunately,
there is a runtime problem.

00:49:03.060 --> 00:49:04.240
We couldn't actually turn this on.

00:49:04.240 --> 00:49:06.860
But essentially what
HIobject archiving is,

00:49:06.910 --> 00:49:10.200
it's a way to take any HIobject,
which means a window or a control,

00:49:10.280 --> 00:49:12.820
and say, hey,
flatten yourself out to a stream.

00:49:12.820 --> 00:49:14.180
I want to write you someplace.

00:49:14.270 --> 00:49:16.700
And it grabs all the
information from those views.

00:49:16.770 --> 00:49:17.530
And you can hook into this.

00:49:17.640 --> 00:49:19.710
This is achieved through new
Carbon events that get sent to

00:49:19.710 --> 00:49:22.070
views in Windows or any HIobject,
really.

00:49:22.110 --> 00:49:24.600
And you can hook in and provide your
own data into this flattened stream.

00:49:24.600 --> 00:49:27.360
So you can store it out
wherever you need to.

00:49:30.450 --> 00:49:32.900
We also expanded the hotkey APIs.

00:49:32.900 --> 00:49:34.830
Let's see,
some cool stuff for the ComboBox.

00:49:34.960 --> 00:49:38.520
Ah, yeah, the ComboBox,
we were asked by you guys

00:49:38.520 --> 00:49:42.210
for better control over when
the list is shown and hidden.

00:49:42.210 --> 00:49:43.690
You know,
you want to programmatically invoke it

00:49:43.690 --> 00:49:45.020
and not just have the user click on it.

00:49:45.080 --> 00:49:45.970
So we gave you that.

00:49:45.970 --> 00:49:47.860
There's an easy way to
make the list show up.

00:49:48.030 --> 00:49:50.880
The search field,
we were seeing places in the

00:49:50.880 --> 00:49:53.890
interface where people wanted
a search field with an icon on

00:49:53.890 --> 00:49:56.870
both sides of the search field,
but they didn't want that left

00:49:56.870 --> 00:49:58.560
icon to actually bring down a menu.

00:49:58.560 --> 00:49:59.950
They just wanted it to act like a button.

00:49:59.950 --> 00:50:02.140
So you can do that now
in the search field.

00:50:02.140 --> 00:50:04.120
We added a bunch of new menu
glyphs to the menu manager so you

00:50:04.220 --> 00:50:07.250
can support those if you want to.

00:50:07.350 --> 00:50:12.200
Eric did a ton of work in Carbon to
kind of give us a lot better integration

00:50:12.200 --> 00:50:14.140
between Carbon and Cocoa Windows.

00:50:14.140 --> 00:50:17.840
If you've ever tried to integrate
them yourself or use system services

00:50:17.840 --> 00:50:20.910
that did the integration for you,
like the color panel

00:50:21.050 --> 00:50:23.690
or something like that,
you notice that sometimes there were

00:50:23.690 --> 00:50:26.960
some activation problems and it wasn't
clear which text field was focused.

00:50:27.070 --> 00:50:29.840
Well, we did a bunch of work in
that realm to clean it up.

00:50:29.840 --> 00:50:32.380
And we did it by using
proper window levels.

00:50:32.540 --> 00:50:37.160
So there are some things we changed
with respect to window levels.

00:50:37.160 --> 00:50:39.280
I think we always used
to use window level zero.

00:50:39.290 --> 00:50:42.140
And now we actually use the proper
window level so we can interact

00:50:42.210 --> 00:50:43.500
with the Cocoa Windows better.

00:50:43.510 --> 00:50:46.290
We cover this in the HIToolbox
release notes in detail.

00:50:46.590 --> 00:50:48.550
I urge you to take a look at
it just in case there's any

00:50:48.580 --> 00:50:50.060
compatibility concerns there.

00:50:50.060 --> 00:50:52.850
But see if there's any of this new
functionality you can take advantage

00:50:52.900 --> 00:50:55.080
of with the new APIs we offered.

00:50:55.080 --> 00:50:56.940
We also sent out a couple
of new Carbon events as--.

00:50:56.960 --> 00:50:58.660
I think it was sheets open and close,
I believe.

00:50:58.660 --> 00:51:00.600
Is that right, sheets open and close?

00:51:00.600 --> 00:51:01.800
I'm looking for Eric.

00:51:01.800 --> 00:51:02.850
I don't see him.

00:51:02.850 --> 00:51:03.330
Okay.

00:51:03.350 --> 00:51:03.680
No.

00:51:03.680 --> 00:51:05.640
No worries.

00:51:05.640 --> 00:51:08.620
So like I said,
HIToolbox release notes are the key.

00:51:08.620 --> 00:51:11.540
It goes into more detail about
everything I've talked about already,

00:51:11.540 --> 00:51:13.830
as well as the stuff on
this slides and even more.

00:51:16.670 --> 00:51:19.300
But there's three other
things I want to talk about.

00:51:19.300 --> 00:51:21.460
These are sort of compatibility concerns.

00:51:21.460 --> 00:51:24.460
These are changes we made to
Tiger that may affect your ways--your

00:51:24.460 --> 00:51:28.110
application in ways that you
don't exactly anticipate right now.

00:51:28.250 --> 00:51:31.570
The first change was to support
resolution independence.

00:51:31.580 --> 00:51:34.110
I don't know if you can remember,
but the machine before it crashed

00:51:34.250 --> 00:51:36.780
had a bigger menu bar when
I increased the scale factor.

00:51:36.910 --> 00:51:40.200
Well, that was achieved by switching
the menu manager over to using a

00:51:40.210 --> 00:51:42.190
compositing window for the menu bar.

00:51:42.210 --> 00:51:44.690
Now, since it's a regular
old compositing window,

00:51:44.690 --> 00:51:46.790
this window is going to
show up in the window list.

00:51:46.850 --> 00:51:50.090
So if you're calling APIs like
getWindowList or getFrontWindowOfClass,

00:51:50.090 --> 00:51:53.350
the all classes constant,
you're going to get the menu bar window.

00:51:53.350 --> 00:51:54.760
So you got to be prepared to expect that.

00:51:54.900 --> 00:51:57.440
But better yet,
don't use either of those APIs.

00:51:57.510 --> 00:51:58.920
We don't prefer those anyway.

00:51:58.980 --> 00:52:02.140
What you really want to use
is active non-floating window.

00:52:02.140 --> 00:52:05.420
That generally gives you the
front most document window,

00:52:05.430 --> 00:52:07.610
which is what you want nine
times out of ten anyway.

00:52:09.000 --> 00:52:11.480
Another change we made is we
brought the user pane control

00:52:11.610 --> 00:52:14.320
sort of up into the HIV space,
so at least it can be

00:52:14.510 --> 00:52:17.980
used as a grouping view,
but that required a few changes.

00:52:17.980 --> 00:52:20.280
One of the changes we had to
make is we no longer store its

00:52:20.280 --> 00:52:21.750
private--did I say private?

00:52:21.750 --> 00:52:25.260
Private, that's stuff internal to Apple,
instance data in the

00:52:25.260 --> 00:52:26.540
controls data handle.

00:52:26.610 --> 00:52:30.350
We found a few applications out
there that access that data,

00:52:30.410 --> 00:52:33.360
or at least query it,
and we had to do some weird

00:52:33.360 --> 00:52:36.720
workarounds to make those
applications continue to work.

00:52:36.720 --> 00:52:39.930
So, don't ever access the private
data of a system control.

00:52:40.040 --> 00:52:42.100
In fact,
don't ever access the private data of any

00:52:42.190 --> 00:52:43.960
control you're not in charge of writing.

00:52:43.980 --> 00:52:45.960
It's a bad idea,
and don't even to reference it.

00:52:47.730 --> 00:52:49.880
Now the third change,
which is something we haven't made yet,

00:52:49.880 --> 00:52:53.100
but it's something we're going
to do by the time Tiger ships.

00:52:53.100 --> 00:52:56.550
There are some APIs like Event Avail,
Still Down, and Wait Mouse Up that

00:52:57.030 --> 00:53:01.480
currently flush window buffers,
meaning you could do some drawing

00:53:01.480 --> 00:53:04.900
in a window and then you could call
Event Avail and that drawing would

00:53:04.900 --> 00:53:06.840
be flushed to the screen right away.

00:53:07.080 --> 00:53:10.360
That's kind of convenient,
but it killed performance in many ways.

00:53:10.460 --> 00:53:13.730
A lot of people use Event Avail
or Still Down as part of a

00:53:13.730 --> 00:53:15.690
very tight mouse tracking loop.

00:53:15.990 --> 00:53:18.840
And so any painting that happened was
either a visual inconvenience because

00:53:18.840 --> 00:53:22.380
they didn't want it to happen or it
just slowed down that tracking loop,

00:53:22.380 --> 00:53:23.640
which is kind of crummy.

00:53:23.810 --> 00:53:26.710
So by the time Tiger ships,
we're going to make changes to

00:53:26.710 --> 00:53:30.480
those three APIs such that they no
longer automatically flush window

00:53:30.560 --> 00:53:34.660
buffers with the big parentheses,
which is only for applications

00:53:34.690 --> 00:53:36.020
linked on Tiger and later.

00:53:36.180 --> 00:53:40.070
So if you built your application
on Panther and you run it on Tiger,

00:53:40.310 --> 00:53:43.200
those three APIs are still going
to flush the way they always have.

00:53:43.240 --> 00:53:45.760
It's only if you link on
Tiger and then run on Tiger.

00:53:45.970 --> 00:53:49.680
So if you find some
situations where suddenly,

00:53:49.680 --> 00:53:52.340
wait, my window's not drawing,
I'm expecting it to draw,

00:53:52.380 --> 00:53:53.240
what's going on?

00:53:53.330 --> 00:53:54.690
It's probably because of this change.

00:53:54.780 --> 00:53:57.270
Look to see if you rebuilt
for Tiger and surely that's

00:53:57.270 --> 00:53:58.980
going to be what's going on.

00:53:58.980 --> 00:54:01.950
So if you really depend on this behavior,
what I suggest doing is find

00:54:02.120 --> 00:54:05.100
those tracking loops where you
depend on the behavior and make

00:54:05.100 --> 00:54:08.540
manual calls to QD flush port
buffer or something like that,

00:54:08.650 --> 00:54:10.020
and that'll get the
flushing behavior back.

00:54:10.030 --> 00:54:13.140
But maybe a better solution is
to stop doing your own tracking

00:54:13.140 --> 00:54:15.620
loops in those places where it is a
tracking loop and instead switch to

00:54:15.660 --> 00:54:20.390
an API like track mouse location,
which does flush because

00:54:20.390 --> 00:54:21.810
it's documented to flush.

00:54:24.800 --> 00:54:27.370
So, what I want you guys to go do now,
well maybe not right now,

00:54:27.370 --> 00:54:28.630
because I need to
attend the next session.

00:54:28.650 --> 00:54:29.760
Install the seed.

00:54:29.780 --> 00:54:31.860
Take a look at the toolbox release notes.

00:54:31.860 --> 00:54:33.680
Start looking at the
new things we've added.

00:54:33.680 --> 00:54:35.820
Start playing with HIV if
you haven't already.

00:54:35.820 --> 00:54:38.000
Try switching on compositing
mode in the standard handlers

00:54:38.000 --> 00:54:39.090
for some of your Windows.

00:54:39.100 --> 00:54:41.620
You may actually find out that
it's a lot easier to adopt this

00:54:41.620 --> 00:54:43.170
stuff than you may have thought.

00:54:43.200 --> 00:54:46.310
Then take a look at the resolution
independence release notes.

00:54:46.390 --> 00:54:47.660
There's a lot of cool info in there.

00:54:47.660 --> 00:54:48.810
It's really fun to play with.

00:54:48.900 --> 00:54:50.940
I mean, even if you don't start
developing for it right away,

00:54:50.940 --> 00:54:53.830
turn it on, run your application,
see what looks good,

00:54:53.830 --> 00:54:54.920
see what doesn't look good.

00:54:54.920 --> 00:54:57.180
Start making lists of things
you might need from us,

00:54:57.290 --> 00:54:58.140
from the toolbox.

00:54:58.140 --> 00:55:01.020
And then maybe start fiddling
with it in your app and see

00:55:01.150 --> 00:55:02.690
if you can't make it work.

00:55:02.770 --> 00:55:04.620
It might actually end up
being easier than you thought,

00:55:04.780 --> 00:55:06.420
particularly if you've adopted HIV.

00:55:06.420 --> 00:55:09.300
Also start looking at
supporting accessibility.

00:55:09.300 --> 00:55:12.510
If you're supporting HIV,
it's just a tiny additional little

00:55:12.510 --> 00:55:14.420
step to support accessibility.

00:55:14.420 --> 00:55:16.510
If you're in there and
you're modifying your nibs,

00:55:16.650 --> 00:55:19.300
hey, by all means,
when we get support in IB for

00:55:19.660 --> 00:55:23.990
adding extra attributes to widgets,
sorry, extra accessibility

00:55:23.990 --> 00:55:26.560
attributes to widgets,
start throwing that information in there.

00:55:26.560 --> 00:55:27.600
It's only going to do good.

00:55:30.470 --> 00:55:33.010
And then take a look at all the
other Tiger features we've added

00:55:33.010 --> 00:55:37.200
and see what you can do to make
your application look great.

00:55:37.280 --> 00:55:39.420
So we've got a bunch of
information out there on the

00:55:39.420 --> 00:55:40.900
web and in the release notes.

00:55:40.950 --> 00:55:44.320
The top item here,
this upgrading to the Mac OS HIToolbox,

00:55:44.320 --> 00:55:47.200
is one of the featured articles
on the developer Applecom website.

00:55:47.200 --> 00:55:48.100
It's really, really good.

00:55:48.100 --> 00:55:49.000
It's a great article.

00:55:49.000 --> 00:55:53.500
It covers all kinds of aspects
of HIView and HIToolbox.

00:55:53.540 --> 00:55:55.850
A little bit of older documentation
is introducing HIView.

00:55:55.960 --> 00:55:57.090
It takes you through some of the basics.

00:55:57.100 --> 00:55:59.900
If you need a little refresher course,
go check that out.

00:55:59.900 --> 00:56:02.180
We have the reference
material for HISHape.

00:56:02.200 --> 00:56:05.600
It's going to be critical to start
using HISHape once you become HIView,

00:56:05.600 --> 00:56:07.900
because it's going to break
various quick draw limitations.

00:56:07.930 --> 00:56:09.400
And finally, the release notes.

00:56:09.400 --> 00:56:11.800
Did I say release notes enough?

00:56:11.870 --> 00:56:16.800
So now I'd like to bring Xavier back
up and the rest of the Toolbox crew,

00:56:16.800 --> 00:56:19.100
and we can go through some Q&A.
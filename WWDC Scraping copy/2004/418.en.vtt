WEBVTT

00:00:12.960 --> 00:00:15.050
Good afternoon.

00:00:15.050 --> 00:00:19.100
Welcome to session 418,
Introduction to Core Data.

00:00:20.890 --> 00:00:23.700
My name is Andreas Wendker,
and I'm the senior manager

00:00:23.780 --> 00:00:26.430
for Core Data and WebObjects.

00:00:26.510 --> 00:00:30.910
Core Data is a new framework that
we added under the Cocoa umbrella,

00:00:30.910 --> 00:00:34.150
and it continues an initiative we
started last year with Cocoa Bindings.

00:00:34.310 --> 00:00:37.900
That's the initiative to bring you and
your applications more functionality

00:00:37.900 --> 00:00:39.890
for writing significantly less code.

00:00:40.740 --> 00:00:46.550
Like bindings, Core Data fills a gap in
the Cocoa functionality.

00:00:46.750 --> 00:00:51.440
Core Data is concerned with
fine-grained management of data objects.

00:00:51.440 --> 00:00:54.410
In this space, it solves a number of
very difficult problems,

00:00:54.430 --> 00:00:57.540
and I actually believe that it
will have a much stronger impact

00:00:57.540 --> 00:01:00.750
on your application development
than even Cocoa bindings had.

00:01:01.450 --> 00:01:03.280
When I talk about data
objects in this session,

00:01:03.300 --> 00:01:06.140
I really mean the objects that you
usually refer to as the "model objects"

00:01:06.140 --> 00:01:07.800
in the ModelViewController sense.

00:01:07.800 --> 00:01:09.610
But I'm going to use the
term "model" in a different

00:01:09.670 --> 00:01:12.800
context throughout the session,
so I decided to stick with data objects.

00:01:12.800 --> 00:01:15.660
Also,
I'd like to distinguish Core Data clearly

00:01:15.940 --> 00:01:18.800
from the new Metadata API,
the new Spotlight API.

00:01:19.060 --> 00:01:22.790
Core Data is about the
inside of your data files,

00:01:22.880 --> 00:01:26.800
about your own applications' documents.

00:01:26.800 --> 00:01:30.300
Metadata is about the surface,
about the outside of those files

00:01:30.300 --> 00:01:33.930
that you want to export to the
file system and to the search API.

00:01:35.920 --> 00:01:39.480
So in one single sentence,
Core Data is a model-driven object graph

00:01:39.480 --> 00:01:41.880
management and persistency framework.

00:01:41.970 --> 00:01:45.710
That's certainly a mouthful,
but what does it actually mean?

00:01:47.240 --> 00:01:50.540
It means that with Core Data,
instead of writing a lot of code,

00:01:50.550 --> 00:01:52.830
you create a description
of your data objects.

00:01:52.920 --> 00:01:55.960
You create a description in Xcode,
and that description is called

00:01:55.990 --> 00:01:57.200
the model of your application.

00:01:57.200 --> 00:02:01.470
And the model is what's used by
Core Data to manage pretty much most

00:02:01.490 --> 00:02:05.520
aspects of your data objects for you,
and it's doing that both

00:02:05.520 --> 00:02:07.100
in memory and on disk.

00:02:07.880 --> 00:02:11.720
That means that you are actually
freed up to focus entirely on your

00:02:11.720 --> 00:02:15.510
application-specific problem domain,
instead of having to focus on developing

00:02:15.570 --> 00:02:17.520
infrastructure for your application.

00:02:19.860 --> 00:02:21.520
So what can we do with the model?

00:02:21.540 --> 00:02:24.790
I think the most immediate benefit
to many of you will probably be that

00:02:24.790 --> 00:02:28.010
we can provide you with automatic
undo and redo in your applications.

00:02:28.010 --> 00:02:31.700
So with Core Data, no more worrying about
that NSUndoManager.

00:02:36.790 --> 00:02:40.370
We also provide you with scalable
object lifecycle management.

00:02:40.370 --> 00:02:43.250
That means that we actually only
keep the pieces of your data in

00:02:43.250 --> 00:02:46.730
memory that is currently needed
and we leave the rest on disk,

00:02:46.760 --> 00:02:48.300
so it scales very well.

00:02:48.390 --> 00:02:50.570
We will automatically
synchronize the user interface.

00:02:50.650 --> 00:02:53.810
We do that through Cocoa bindings,
but we added a few pieces to bindings

00:02:53.810 --> 00:02:55.940
to make the integration even smoother.

00:02:56.030 --> 00:02:58.680
And Core Data also helps you
greatly to manage the consistency

00:02:58.680 --> 00:03:00.000
and correctness of your data.

00:03:00.100 --> 00:03:04.040
And all you have to do is specify a
bunch of rules in the model that tell

00:03:04.100 --> 00:03:08.490
Core Data how to validate user input
and how to maintain relationships or

00:03:08.490 --> 00:03:11.060
references of your objects to each other.

00:03:12.970 --> 00:03:15.460
The other thing we can do is
we can automatically read and

00:03:15.460 --> 00:03:17.010
write your objects to the disk.

00:03:17.010 --> 00:03:19.240
And we're going to support
three different file formats

00:03:19.240 --> 00:03:22.720
in this first release:
SQL databases, XML files,

00:03:22.720 --> 00:03:24.900
and binary archive files.

00:03:24.940 --> 00:03:27.240
SQL files are implemented
on top of SQLite,

00:03:27.240 --> 00:03:30.890
which is a very nice, lightweight,
embeddable SQL database.

00:03:30.920 --> 00:03:32.900
It's an open source project.

00:03:33.050 --> 00:03:36.090
And SQL databases will usually
give you the best scalability

00:03:36.110 --> 00:03:37.850
if you have large sets of data.

00:03:38.210 --> 00:03:40.900
And that's the case because
with SQL databases we can

00:03:41.050 --> 00:03:42.970
update your files incrementally.

00:03:42.980 --> 00:03:45.590
We don't have to write the entire
file if just one object changes.

00:03:45.640 --> 00:03:48.870
Everything is incremental and a lot
of the data can stay on the disk.

00:03:48.970 --> 00:03:51.790
We only fetch them into
memory when needed.

00:03:52.790 --> 00:03:56.140
XML files have the huge advantage that
they are human readable and they are

00:03:56.140 --> 00:03:58.900
easily consumed by other applications
if you need to exchange data,

00:03:58.900 --> 00:04:01.620
but they won't give you
the same performance.

00:04:01.700 --> 00:04:04.700
One other advantage of XML files is
that they are written atomically,

00:04:04.700 --> 00:04:08.670
so if you are in a typical Cocoa document
context where you want to write

00:04:08.740 --> 00:04:11.530
the files atomically if you save,
then XML files are

00:04:11.540 --> 00:04:12.700
actually a very good fit.

00:04:12.700 --> 00:04:16.350
Binary files are kind of in the middle,
they are probably a good compromise,

00:04:16.410 --> 00:04:19.860
they don't give you quite the performance
of SQL databases and they don't

00:04:19.860 --> 00:04:23.800
scale to the very large data sets,
but they are written atomically

00:04:23.800 --> 00:04:25.720
and they are reasonably fast.

00:04:26.300 --> 00:04:29.700
What's important for this first
release is that when you use Core Data,

00:04:29.700 --> 00:04:32.290
we will take ownership
of the file formats,

00:04:32.290 --> 00:04:33.700
of the file schemas.

00:04:33.770 --> 00:04:35.580
So on the one hand,
that's great because you don't

00:04:35.580 --> 00:04:38.100
even have to worry about creating
tables in your SQL database or

00:04:38.220 --> 00:04:39.900
creating the schema for XML.

00:04:39.980 --> 00:04:44.180
On the other hand, you will lose detailed
control of your file formats.

00:04:46.300 --> 00:04:48.870
To give you some examples of
what you could do with Core Data,

00:04:48.870 --> 00:04:51.470
I actually just looked at my
doc and the typical applications

00:04:51.470 --> 00:04:52.740
I use on a daily basis.

00:04:52.760 --> 00:04:54.810
And none of these applications,
disclaimer,

00:04:54.810 --> 00:04:56.620
are actually using Core Data right now.

00:04:56.620 --> 00:04:57.760
We are still building up Core Data.

00:04:57.760 --> 00:04:58.440
It's really early.

00:04:58.500 --> 00:05:01.420
But I think it gives you an idea
of what the scope is of things

00:05:01.420 --> 00:05:03.160
that you can solve with Core Data.

00:05:03.160 --> 00:05:05.720
So, starting with Safari,
the history and bookmark files,

00:05:05.870 --> 00:05:08.200
that would be a great thing
you could do with Core Data.

00:05:08.510 --> 00:05:12.000
Persons and groups,
even the mailbox files within Mail,

00:05:12.330 --> 00:05:15.380
the music library of iTunes,
calendar files in iCal,

00:05:15.400 --> 00:05:18.360
even sketch documents,
which have the different graphics in it,

00:05:18.390 --> 00:05:20.030
and project files in Xcode.

00:05:20.100 --> 00:05:22.590
Those are all great
candidates for Core Data.

00:05:22.700 --> 00:05:24.840
Essentially,
every application that manages

00:05:24.840 --> 00:05:27.750
lots of objects will benefit
greatly from using Core Data.

00:05:27.800 --> 00:05:31.730
The applications that will not see
that much of a benefit are applications

00:05:31.730 --> 00:05:33.730
that work on large blobs of data.

00:05:33.850 --> 00:05:37.630
So, for example, TextEdit,
that works on the RTF or text files,

00:05:37.720 --> 00:05:43.090
and maybe image processing software
won't benefit that much from Core Data.

00:05:44.800 --> 00:05:46.010
So why is it good for you?

00:05:46.090 --> 00:05:48.790
Most importantly,
because it relieves you from

00:05:48.790 --> 00:05:51.700
having to reinvent the wheel
again and again and again.

00:05:51.720 --> 00:05:55.800
Implementing undo and Redo,
managing the lifecycle of your objects,

00:05:55.860 --> 00:05:58.110
input validation,
it's all very mundane work that you

00:05:58.110 --> 00:06:00.700
have to implement for every application,
and with Core Data it's done for you.

00:06:00.700 --> 00:06:03.150
You save a lot of time,
you will have a much

00:06:03.150 --> 00:06:04.700
faster development cycle.

00:06:04.700 --> 00:06:08.820
Core Data also will give you
robustness and flexibility.

00:06:08.820 --> 00:06:11.700
The choice of different types of data
stores with the different characteristics

00:06:11.700 --> 00:06:13.700
and scalability and human readability,
etc.

00:06:13.700 --> 00:06:16.700
I think will turn out very handy
for many of your applications.

00:06:16.700 --> 00:06:19.340
And also very important,
Core Data will prepare you well

00:06:19.340 --> 00:06:22.700
for the future for features
you might add in Cocoa.

00:06:22.700 --> 00:06:25.000
Now that we have a model,
we can interpret that model

00:06:25.000 --> 00:06:27.700
in many different ways without
you writing any line of code.

00:06:27.700 --> 00:06:30.670
So you could envision us to, for example,
add Apple Scriptability

00:06:30.670 --> 00:06:33.030
to your applications,
or maybe automatic

00:06:33.030 --> 00:06:34.700
rendezvous connectivity.

00:06:34.710 --> 00:06:37.100
So there are some features we are
looking at in the future that I think

00:06:37.120 --> 00:06:40.700
you will be able to pick up automatically
if you start using Core Data soon.

00:06:43.330 --> 00:06:46.010
These are actually fine-wet screenshots
from an actual application we

00:06:46.010 --> 00:06:48.440
converted over to Core Data recently.

00:06:48.440 --> 00:06:50.630
And that application was
already using Cocoa bindings,

00:06:50.630 --> 00:06:52.200
so there was no glue
code for the UI layer.

00:06:52.200 --> 00:06:54.520
And as you can see,
we were still able to shave

00:06:54.730 --> 00:06:56.080
off a lot of the code.

00:06:56.100 --> 00:06:57.610
And by the way,
this application now has more

00:06:57.610 --> 00:06:58.740
features than it had before.

00:06:58.740 --> 00:07:01.310
For example, now it has undo and redo.

00:07:02.850 --> 00:07:05.760
So with that,
I would like to ask James Dempsey

00:07:05.770 --> 00:07:09.390
to come up on stage and give
you a first demo of Core Data.

00:07:14.160 --> 00:07:15.540
Thank you, Andreas.

00:07:15.620 --> 00:07:19.000
So what we're taking a look
at here is an XML document as

00:07:19.000 --> 00:07:21.890
might be managed by Core Data.

00:07:21.950 --> 00:07:24.100
We're going to put that away for now.

00:07:24.100 --> 00:07:28.100
We're going to jump right in
and build a full-featured,

00:07:28.250 --> 00:07:32.450
document-based application with
zero lines of code using Core Data.

00:07:32.590 --> 00:07:36.580
We're going to use the
Core Data Document-Based

00:07:37.000 --> 00:07:38.800
Application Project.

00:07:38.800 --> 00:07:38.800
Call that thing.

00:07:39.530 --> 00:07:41.780
Demo 1.

00:07:41.780 --> 00:07:45.410
And with Cocoa bindings,
you essentially had your data objects

00:07:45.500 --> 00:07:49.590
able to be synchronized with user
interface objects through bindings,

00:07:49.590 --> 00:07:52.500
but you still had to manage
those data objects yourself.

00:07:52.710 --> 00:07:55.500
With Core Data, it's kind of like the
other half of the equation,

00:07:55.500 --> 00:07:58.370
where those data objects,
you can model them,

00:07:58.660 --> 00:08:02.500
Core Data will help you manage them,
and also deal with the persistence.

00:08:02.580 --> 00:08:05.800
So let's take a little
look at the project.

00:08:06.080 --> 00:08:08.000
and the code that's in there.

00:08:08.000 --> 00:08:12.190
If we take a look at the classes,
we have a document class,

00:08:12.190 --> 00:08:14.800
which is a subclass of
NSPersistentDocument,

00:08:14.890 --> 00:08:17.660
which in turn is a
subclass of NSDocument,

00:08:17.690 --> 00:08:22.920
and this subclass adds all of the hooks
needed to interoperate with Core Data,

00:08:22.940 --> 00:08:24.750
including persistence.

00:08:24.860 --> 00:08:26.860
Let's take a look at
the implementation file,

00:08:26.890 --> 00:08:31.580
and you'll notice a couple of
common NSDocument methods here,

00:08:31.600 --> 00:08:35.350
and a few that are missing,
ostensibly those that are

00:08:35.450 --> 00:08:38.920
for writing and reading data.

00:08:39.030 --> 00:08:42.300
So, we don't need these
initialization items either.

00:08:42.360 --> 00:08:46.630
So, in essence,
this is a negative lines of code demo.

00:08:47.300 --> 00:08:51.860
We'll next look at a new
resource in the project:

00:08:51.860 --> 00:08:52.960
the model.

00:08:53.200 --> 00:08:57.590
A little later in the session,
you're going to see how you can

00:08:57.640 --> 00:09:00.330
create a model from scratch,
but to save time,

00:09:00.390 --> 00:09:04.410
we're going to import that
XML file that I showed you earlier.

00:09:06.120 --> 00:09:09.770
and Xcode is going to build an
entity relationship diagram based

00:09:09.850 --> 00:09:12.240
on the structure of that XML file.

00:09:12.350 --> 00:09:15.750
And if we take a look, we have persons,
events, tasks,

00:09:15.750 --> 00:09:18.600
an event management sort of model.

00:09:18.730 --> 00:09:22.200
So now we have our model,
let's build our user interface.

00:09:22.320 --> 00:09:25.830
We'll head into our document nib file.

00:09:25.830 --> 00:09:27.240
Get rid of this.

00:09:27.350 --> 00:09:29.650
And what we're going
to do is option drag,

00:09:29.650 --> 00:09:33.930
in this case the person entity,
let me pick it up here,

00:09:33.930 --> 00:09:35.500
into interface builder.

00:09:35.620 --> 00:09:38.150
Interface builder is going to
ask us whether we want a user

00:09:38.150 --> 00:09:44.290
interface for one object handled by
an object controller or many objects

00:09:44.290 --> 00:09:46.000
handled by an array controller.

00:09:46.000 --> 00:09:48.500
We're going to deal with
many objects in this case.

00:09:48.500 --> 00:09:52.570
And you'll notice that a user
interface has been built based on the

00:09:52.710 --> 00:09:55.000
properties of the person in the model.

00:09:55.000 --> 00:09:59.410
And in addition, an array controller has
been added to the project.

00:09:59.500 --> 00:10:03.650
Let's just take a look at the
bindings of this text field here.

00:10:03.970 --> 00:10:05.000
Take a look at the value.

00:10:05.000 --> 00:10:09.000
And you'll notice that it's hooked
up to the array controller selection

00:10:09.000 --> 00:10:10.870
for the model key path first name.

00:10:11.000 --> 00:10:13.920
It's just a straight
standard Cocoa binding.

00:10:14.030 --> 00:10:16.470
In fact,
all of the user interface is dealing

00:10:16.470 --> 00:10:21.000
with Cocoa bindings in that array
controller in the way it has in Panther.

00:10:21.000 --> 00:10:22.820
So what's the new stuff?

00:10:23.000 --> 00:10:25.430
Well, if we take a look at
the array controller,

00:10:25.690 --> 00:10:29.180
you'll notice a couple of additional
features designed to integrate

00:10:29.230 --> 00:10:31.000
Cocoa bindings with core data.

00:10:31.000 --> 00:10:34.500
The first is instead of
naming a concrete class,

00:10:34.500 --> 00:10:38.500
we have the choice to pick an entity,
in this case a person,

00:10:38.500 --> 00:10:43.500
so that the array controller knows
what type of thing it's dealing with.

00:10:44.010 --> 00:10:46.440
If we look at the bindings
of the array controller,

00:10:46.540 --> 00:10:50.900
you'll notice a new binding
called "managed object context."

00:10:51.070 --> 00:10:56.070
And the managed object context,
Andreas will be talking about it later,

00:10:56.070 --> 00:10:58.770
but in essence,
it's the object that's providing and

00:10:58.770 --> 00:11:02.820
doing a lot of the heavy lifting for the
functionality that we're going to see in

00:11:02.820 --> 00:11:05.140
a moment when I build this application.

00:11:05.370 --> 00:11:10.500
So, one entity is kind of useful,
but very few applications

00:11:10.500 --> 00:11:14.300
deal with one kind of object
and one kind of object alone.

00:11:14.430 --> 00:11:18.180
Core Data is actually very good
at dealing with relationships

00:11:18.180 --> 00:11:19.990
between types of objects.

00:11:20.110 --> 00:11:22.990
So, a person is related to many tasks.

00:11:23.130 --> 00:11:28.940
Let's get a user interface for a task,
many tasks in fact.

00:11:32.070 --> 00:11:34.570
Let's clean this up a little.

00:11:34.610 --> 00:11:36.990
Again,
these are just plain old IB things,

00:11:36.990 --> 00:11:42.150
so we can get rid of them if we want to.

00:11:44.110 --> 00:11:46.860
Let's get that task field a
little bigger so we can read it,

00:11:46.860 --> 00:11:49.100
get rid of some stuff.

00:11:49.180 --> 00:11:50.220
Okay.

00:11:50.430 --> 00:11:53.100
Now let's take a look at
that task array controller.

00:11:53.100 --> 00:11:57.730
We do need to bind its content so it
knows where it's getting its tasks from.

00:11:57.810 --> 00:12:01.590
We're going to bind that
content to the person array,

00:12:01.720 --> 00:12:07.390
its selection, and within that selection,
the tasks of the selected person.

00:12:07.980 --> 00:12:13.140
Let's save our change and let's build
our happy little application here.

00:12:13.230 --> 00:12:16.940
While that's building,
let's just take a look at the types

00:12:16.940 --> 00:12:19.020
of documents that we can save to.

00:12:19.120 --> 00:12:23.540
Predefined is the binary archive format,
the SQLite document format,

00:12:23.620 --> 00:12:25.910
as well as the XML format.

00:12:26.050 --> 00:12:27.780
So our build has succeeded.

00:12:27.840 --> 00:12:29.460
Let's run.

00:12:31.090 --> 00:12:32.850
Hide a bunch of stuff.

00:12:32.930 --> 00:12:34.000
And here's our application.

00:12:34.000 --> 00:12:39.640
Let's open up that XML file
that we had seen earlier.

00:12:39.710 --> 00:12:44.080
And you'll notice that indeed as I jump
through the items in this table view,

00:12:44.120 --> 00:12:45.840
everything's updating.

00:12:45.880 --> 00:12:48.220
I'm seeing all of the
tasks that are related.

00:12:48.260 --> 00:12:51.990
It looks like Andreas has the
most to do out of everybody.

00:12:52.890 --> 00:12:58.150
We have all the common Cocoa bindings,
sorts of features such as sorting,

00:12:58.270 --> 00:13:02.800
such as multiple selection,
and some new goodies such as filtering.

00:13:02.890 --> 00:13:06.540
So if I type in some filtering there,
it will filter for me.

00:13:07.030 --> 00:13:11.840
And the UI has automatically built
in a menu so I can pick particular

00:13:11.920 --> 00:13:14.800
things that I want to filter upon.

00:13:14.930 --> 00:13:18.800
Now let's jump on over to our
new document and add some people.

00:13:18.800 --> 00:13:27.800
Let's add Bob Jones,
let's add Barry Bonds, and let's save.

00:13:28.400 --> 00:13:31.840
So I'm going to save,
again these file formats appear here.

00:13:31.840 --> 00:13:37.300
Let's do the SQL thing, call that test,
we'll save it.

00:13:37.420 --> 00:13:40.380
And on our desktop is
that SQLite document which

00:13:40.380 --> 00:13:42.460
represents the SQL database.

00:13:43.000 --> 00:13:45.300
And let's close the doc.

00:13:45.450 --> 00:13:49.330
Now let's open it up again,
thus proving beyond a shadow

00:13:49.330 --> 00:13:51.370
of a doubt that it persisted.

00:13:51.450 --> 00:13:52.290
And there it is.

00:13:52.290 --> 00:13:55.300
I think I forgot to type
in "bonds". There we go.

00:13:55.300 --> 00:13:56.960
So let's make it persist, eh?

00:13:56.960 --> 00:13:58.860
There we go.

00:14:03.070 --> 00:14:04.720
What did I do?

00:14:04.780 --> 00:14:08.740
I may have disconnected that
text field in Interface Builder.

00:14:08.820 --> 00:14:10.000
My apologies.

00:14:10.150 --> 00:14:14.830
Okay, with that, let's add a new person.

00:14:16.400 --> 00:14:23.180
Betty Brandt,
and let's change Bob to Robert.

00:14:23.540 --> 00:14:27.160
and let's remove Barry for legal reasons.

00:14:27.210 --> 00:14:31.770
Now, you'll notice looking at the
document that the window does

00:14:31.810 --> 00:14:33.090
know a change has occurred.

00:14:33.090 --> 00:14:36.750
It is dirty and if we go to
the edit menu we do have undo.

00:14:36.910 --> 00:14:38.040
So let's undo through this.

00:14:38.040 --> 00:14:41.760
We should get Barry back,
Robert should get back to Bob,

00:14:41.920 --> 00:14:46.880
and Betty should disappear,
and of course redo.

00:14:46.900 --> 00:14:49.990
And if we... Feel free.

00:14:53.510 --> 00:14:56.330
And if we quit, of course,
it knows the dock is dirty

00:14:56.330 --> 00:14:58.400
in Alaska if we want to save.

00:14:58.440 --> 00:15:00.200
We don't want to save.

00:15:00.250 --> 00:15:01.600
Okay.

00:15:01.660 --> 00:15:03.400
Let me close up this project.

00:15:03.470 --> 00:15:07.200
I'd like to show you one more
thing beyond that codeless demo,

00:15:07.240 --> 00:15:10.300
which is that that's a
very Cocoa-centric demo.

00:15:10.470 --> 00:15:14.990
This application here, the three bears,
is a Carbon application that's using

00:15:15.170 --> 00:15:18.400
Core Data underneath for its persistence.

00:15:18.440 --> 00:15:20.970
And in fact, this is the XML file
that it's writing to.

00:15:21.120 --> 00:15:23.790
Let me just open that up in TextEdit.

00:15:25.690 --> 00:15:32.540
And so, we'll add the baby bear
whose height is very small.

00:15:32.540 --> 00:15:37.100
We'll save and quit and restart,
and indeed it has persisted.

00:15:37.230 --> 00:15:40.700
And then if we get the
saved version from disk,

00:15:40.700 --> 00:15:44.840
you'll notice that that
XML document has updated.

00:15:45.010 --> 00:15:49.270
So, let's take a look at the project.

00:15:50.350 --> 00:15:56.050
and it's in Objective C++ and
it's the code here that is doing

00:15:56.050 --> 00:16:00.120
a bit of transition between
those Objective C objects from

00:16:00.120 --> 00:16:05.020
Core Data and Core Foundation types
that Carbon would be able to use.

00:16:05.100 --> 00:16:07.860
And so,
depending on which flavor you wish,

00:16:07.890 --> 00:16:10.070
you can use Core Data with both.

00:16:10.150 --> 00:16:13.790
So thank you very much
and now back to Andreas.

00:16:19.500 --> 00:16:21.890
Thank you, James.

00:16:21.940 --> 00:16:24.890
Now let's talk about models.

00:16:24.970 --> 00:16:28.880
Models are high-level
description of your data objects.

00:16:28.930 --> 00:16:31.860
They're essentially entity
relationship diagrams of your objects.

00:16:31.960 --> 00:16:35.310
And the model is what's needed by
Core Data to implement all these nice

00:16:35.390 --> 00:16:39.390
features like Android Redo and ultimately
read and write your data objects to disk.

00:16:39.420 --> 00:16:41.680
In fact,
the model is all that Core Data needs.

00:16:41.680 --> 00:16:44.790
As you saw in the demos before,
there was no additional code really

00:16:44.790 --> 00:16:46.520
necessary to do all this work.

00:16:46.520 --> 00:16:49.110
One thing that's important, though,
for you to keep in mind is

00:16:49.110 --> 00:16:51.020
that you and your models,
you would have to spend

00:16:51.020 --> 00:16:52.900
quality time together.

00:16:53.400 --> 00:16:56.880
The models need to be very
detailed for us to do a good job,

00:16:56.900 --> 00:16:59.410
so the more detailed
you make your models,

00:16:59.500 --> 00:17:02.320
the better of a job Core Data can do.

00:17:03.750 --> 00:17:06.120
One thing that's interesting in
this context is that we decided

00:17:06.130 --> 00:17:09.970
to separate the five formats for
the models you edit in Xcode and

00:17:09.970 --> 00:17:11.400
the models you load at runtime.

00:17:11.610 --> 00:17:16.110
The reason for that is that Xcode
manages additional information

00:17:16.110 --> 00:17:18.490
that you don't need at runtime,
like the layout information of

00:17:18.490 --> 00:17:21.400
your diagram and maybe the colors
you chose for the different boxes.

00:17:21.400 --> 00:17:23.240
And we didn't want to burden
the runtime with that.

00:17:23.460 --> 00:17:27.120
So while your project is building,
you're actually translating the model

00:17:27.190 --> 00:17:30.800
as it is written in Xcode and managed
in Xcode into a new file format

00:17:30.800 --> 00:17:35.980
that is then imported at runtime.

00:17:39.430 --> 00:17:43.480
Models essentially consist of two pieces:
entities and properties.

00:17:43.590 --> 00:17:47.590
Entities describe the types of objects,
and properties describe the

00:17:47.650 --> 00:17:51.900
individual object components,
the values inside those objects.

00:17:53.430 --> 00:17:56.050
For each entity,
you can specify a class name that is

00:17:56.050 --> 00:17:58.340
used to represent that entity at runtime.

00:17:58.450 --> 00:18:00.850
And specifying the class name
here will turn out to be the most

00:18:00.850 --> 00:18:05.200
important hook for you to plug
in your own application logic.

00:18:06.120 --> 00:18:08.370
Another thing that's interesting
about entities is that they can

00:18:08.370 --> 00:18:11.030
be organized in a hierarchy,
which is actually independent

00:18:11.030 --> 00:18:12.500
of the class hierarchy you use.

00:18:12.640 --> 00:18:15.660
So, for example,
if you have a person entity,

00:18:15.740 --> 00:18:19.690
you might have sub-entities
like employee and customer.

00:18:19.900 --> 00:18:23.150
and you can then map those entities
to either a class hierarchy that

00:18:23.150 --> 00:18:26.290
is the same or to classes that
have nothing to do with each other,

00:18:26.290 --> 00:18:29.950
or you can even map those three entities
to the same object class at runtime.

00:18:29.950 --> 00:18:31.300
That's actually fairly common.

00:18:31.400 --> 00:18:34.390
The advantage for you to use entity
inheritance that you model the

00:18:34.410 --> 00:18:37.530
types of data is that you can,
for example, define your queries on

00:18:37.660 --> 00:18:38.790
the abstract entity.

00:18:38.910 --> 00:18:42.860
You can still search for all persons and
then get back customers and employees.

00:18:42.950 --> 00:18:47.570
So there's a lot of flexibility for you
when you work with your data objects.

00:18:49.880 --> 00:18:51.880
For properties,
we support three different types:

00:18:52.020 --> 00:18:55.440
attributes, relationships,
and fetch properties.

00:18:55.490 --> 00:18:58.790
Attributes represent the simple
types of data in your object,

00:18:58.910 --> 00:19:04.190
like strings, numbers, dates,
and maybe binary data like images.

00:19:04.460 --> 00:19:07.340
And relationships represent
references of objects to each other,

00:19:07.340 --> 00:19:10.540
and they'll be distinguished between
"to one" and "to many" relationships.

00:19:10.540 --> 00:19:12.530
A "to one" relationship
is simply a pointer,

00:19:12.560 --> 00:19:14.160
a reference to another object.

00:19:14.160 --> 00:19:17.660
A "to many" relationship is a collection
of references to other objects.

00:19:17.660 --> 00:19:20.400
In this first release,
we're going to support only

00:19:20.400 --> 00:19:23.660
unordered relationships,
and the natural representation

00:19:23.660 --> 00:19:25.500
for that is actually an NSSet.

00:19:25.500 --> 00:19:28.140
Going forward,
we're probably going to add support

00:19:28.140 --> 00:19:30.660
for ordered relationships too,
and those will be

00:19:30.660 --> 00:19:32.130
represented by NSArrays.

00:19:32.140 --> 00:19:34.710
For NSArrays,
we will then also archive the

00:19:34.740 --> 00:19:37.990
order of the object in that
array in the data stores.

00:19:39.080 --> 00:19:40.750
Relations typically come in pairs.

00:19:40.770 --> 00:19:43.490
If you have a person
that points to a company,

00:19:43.600 --> 00:19:46.480
there's usually also a pointer back
from the company to the person.

00:19:46.550 --> 00:19:49.870
Those relationships are
called inverse relationships,

00:19:49.870 --> 00:19:51.260
and they make your
object graph very rich,

00:19:51.300 --> 00:19:51.760
actually.

00:19:51.760 --> 00:19:53.870
It makes it much easier to
navigate through your object graph.

00:19:53.910 --> 00:19:57.750
So we recommend that you typically enter
the inverse relationships in your model,

00:19:57.750 --> 00:19:58.130
too.

00:19:58.860 --> 00:20:01.780
Fetch properties are
similar to relationships,

00:20:01.880 --> 00:20:04.900
but they are much more loosely bound.

00:20:05.070 --> 00:20:07.800
You can think of them as smart groups.

00:20:07.810 --> 00:20:10.790
To make it more concrete for you,
in an SQL database,

00:20:10.810 --> 00:20:14.990
a relationship will actually result in
a join that is enforced in the database.

00:20:15.010 --> 00:20:18.190
A fetch property is much
more of a loose query.

00:20:19.720 --> 00:20:22.480
So for all these properties,
the model contains a

00:20:22.480 --> 00:20:25.710
wealth of information,
starting with validation rules.

00:20:25.750 --> 00:20:27.830
Those are the kind of
mechanical validation rules,

00:20:27.840 --> 00:20:30.800
like the length of a string,
or maybe the value of the

00:20:30.820 --> 00:20:35.050
expression a string has to match,
min and max values for numbers and dates,

00:20:35.050 --> 00:20:36.260
those kind of things.

00:20:36.270 --> 00:20:38.430
There are also delete
rules for relationships,

00:20:38.490 --> 00:20:41.170
and those delete rules tell
Core Data what to do if an object

00:20:41.170 --> 00:20:42.880
is removed from your object graph.

00:20:42.960 --> 00:20:44.720
Typically,
there's something like a ripple

00:20:44.720 --> 00:20:46.100
effect if you remove an object.

00:20:46.110 --> 00:20:49.540
Let's say you have a person object which
has addresses and contact information.

00:20:49.550 --> 00:20:51.540
If you delete that person,
you want to get rid of

00:20:51.540 --> 00:20:52.810
the other information too.

00:20:52.840 --> 00:20:55.330
And delete rules allow you to
specify that kind of behavior.

00:20:55.340 --> 00:20:56.370
And there are different choices.

00:20:56.380 --> 00:21:00.040
You can kind of cascade the delete,
so that's the ripple effect.

00:21:00.040 --> 00:21:01.980
You can deny a delete,
depending on the situation.

00:21:01.980 --> 00:21:05.210
So there's a lot of flexibility
in these delete rules.

00:21:05.260 --> 00:21:07.370
And also for attributes,
we store default values.

00:21:07.420 --> 00:21:11.920
Those are simply the values assigned
to your object when they are inserted.

00:21:14.050 --> 00:21:17.340
So, this table summarizes the kind
of mapping we do at runtime.

00:21:17.460 --> 00:21:20.980
An entity essentially maps to a class,
an attribute maps to a

00:21:20.980 --> 00:21:24.230
simple instance variable,
and a relationship maps

00:21:24.410 --> 00:21:28.650
to a managed reference or
collection of these references.

00:21:28.650 --> 00:21:28.650
They are pointers.

00:21:30.980 --> 00:21:34.400
There are some more things in the
model that I want to go over quickly.

00:21:34.400 --> 00:21:38.900
Startinging with predefined queries,
you can enter pretty much templates

00:21:38.900 --> 00:21:42.570
for the common queries you want to do,
you want to perform in your application.

00:21:42.570 --> 00:21:45.860
Again, something like a smart group
would be a good example here.

00:21:45.910 --> 00:21:47.810
Typically,
you would specify variable names

00:21:47.810 --> 00:21:50.840
within those queries and then
substitute concrete values at runtime.

00:21:50.880 --> 00:21:55.490
So those are very handy and it's actually
a huge convenience for you to specify

00:21:55.510 --> 00:21:57.900
those queries in the model upfront.

00:21:58.190 --> 00:22:00.460
There are also some that we call
"configurations" in the model.

00:22:00.460 --> 00:22:03.700
A configuration is pretty much
a named group of entities,

00:22:03.880 --> 00:22:06.860
and those configurations are used in
the more advanced cases when you talk

00:22:06.860 --> 00:22:08.800
to multiple data files at the same time.

00:22:08.880 --> 00:22:11.390
Each configuration then
maps to one data file,

00:22:11.450 --> 00:22:14.850
and you can pretty much predefine
the mapping to the different data

00:22:14.910 --> 00:22:19.340
files in the model by separating
those configurations and naming them.

00:22:19.420 --> 00:22:22.810
The last thing I want to mention is
that we also decided to give you some

00:22:22.850 --> 00:22:24.830
flexibility to customize the model.

00:22:24.830 --> 00:22:28.840
We added so-called "user info
dictionaries" to entities and properties.

00:22:28.840 --> 00:22:30.500
You can store your own
information in there.

00:22:30.500 --> 00:22:33.630
These are pretty much arbitrary key value
pairs you can enter in the modeling tool.

00:22:33.640 --> 00:22:36.870
The typical use case for that
is actually localization.

00:22:38.160 --> 00:22:40.880
So with that,
I'd like to ask Bill Bumgarner

00:22:40.880 --> 00:22:42.270
to come up on stage.

00:22:42.290 --> 00:22:43.100
There he is.

00:22:43.140 --> 00:22:48.590
And he will give you a more
detailed demo of the model.

00:22:49.700 --> 00:24:52.100
[Transcript missing]

00:24:52.580 --> 00:24:54.740
You'll see that this
arrow right here updated.

00:24:54.740 --> 00:24:56.750
That's because, of course,
the arrows indicate the

00:24:56.750 --> 00:24:58.860
ordinality of the relationship.

00:24:58.960 --> 00:25:02.610
Relationships are allowed to have
ordinality so that you can say

00:25:02.840 --> 00:25:05.800
a car can only have four tires,
that kind of thing.

00:25:05.860 --> 00:25:09.120
And upon save and upon manipulating
the objects at runtime,

00:25:09.120 --> 00:25:10.840
the system will validate that.

00:25:10.840 --> 00:25:12.960
Andreas will be getting
into that in more detail.

00:25:13.030 --> 00:25:17.810
Now, there's some other...we've learned
a lot about modeling tools.

00:25:18.020 --> 00:25:22.240
We, as some of you might know,
we've done some things

00:25:22.240 --> 00:25:23.660
wrong in the past and...

00:25:24.680 --> 00:25:27.170
Hopefully you'll find this
to be a refreshing change.

00:25:27.260 --> 00:25:31.980
So one of those is that it was tedious
and annoying to have to go through a

00:25:31.980 --> 00:25:37.000
model and edit a particular part of an
attribute over and over and over again.

00:25:37.060 --> 00:25:39.120
So what you can actually do is
you can come in here and you can

00:25:39.130 --> 00:25:42.360
multiple select in here and you'll
see that the inspectors over here

00:25:42.820 --> 00:25:49.400
update to only show you the items
that are relevant to those things.

00:25:50.460 --> 00:25:53.720
I can come in here and I can
select first name and last name,

00:25:53.770 --> 00:25:57.100
and I can change the validation rules
for both of those at the same time.

00:25:57.240 --> 00:26:00.010
But of course,
often times when you're modeling stuff,

00:26:00.120 --> 00:26:03.150
you'll have attributes across
many entities that will need

00:26:03.230 --> 00:26:05.060
to be changed at the same time.

00:26:05.200 --> 00:26:07.490
So I can come in here
and select them all,

00:26:07.630 --> 00:26:11.310
and then I can sort by entity,
or I can sort by property or kind,

00:26:11.320 --> 00:26:14.440
and then I can again select
multiple across multiple entities

00:26:14.440 --> 00:26:16.510
and edit them all at once.

00:26:16.900 --> 00:26:22.560
We also have the fetched request editor.

00:26:22.600 --> 00:26:25.260
So if I come in here,
I can build a new fetch request,

00:26:25.260 --> 00:26:27.560
and I can then actually
edit the predicate,

00:26:27.570 --> 00:26:30.240
and we give you a
graphical predicate editor.

00:26:30.290 --> 00:26:35.030
So we can come into here, and let's say,
we will say this is confirmed, yes,

00:26:35.100 --> 00:26:40.080
and we also want to make
sure that the date is,

00:26:40.080 --> 00:26:43.990
well, less than, you know,

00:26:44.870 --> 00:26:50.160
and we can say maybe we
want to add an "or" here,

00:26:50.160 --> 00:26:53.110
so we can say the date is greater than

00:26:57.700 --> 00:27:21.200
[Transcript missing]

00:27:21.780 --> 00:27:23.820
If I wanted to say, "Oh, well,
this really should be at the top

00:27:23.820 --> 00:27:27.360
level," I can just drag it up there,
and it'll restructure

00:27:27.360 --> 00:27:29.120
itself appropriately.

00:27:32.780 --> 00:27:38.610
And then of course, as Andreas mentioned,
there is the user info here.

00:27:38.610 --> 00:27:40.330
So it's just key value pairs.

00:27:40.330 --> 00:27:43.230
So we allow you to annotate your
models with whatever you need.

00:27:43.330 --> 00:27:44.660
Thank you.

00:27:53.260 --> 00:27:59.110
And then of course, as Andreas mentioned,
there is the user info here.

00:27:59.110 --> 00:28:00.830
So it's just key value pairs.

00:28:00.830 --> 00:28:03.430
So we allow you to annotate your
models with whatever you need.

00:28:03.430 --> 00:28:03.430
Thank you.

00:28:03.680 --> 00:28:06.570
As I mentioned before,
the most important hook for you

00:28:06.570 --> 00:28:10.600
for that is to specify your own
data object classes in the model.

00:28:10.600 --> 00:28:16.080
One requirement we have with Core Data is
that we require you to subclass a new

00:28:16.080 --> 00:28:18.600
class that we call NSManagedObject.

00:28:18.600 --> 00:28:21.600
NSManagedObject actually
is a generic data object,

00:28:21.600 --> 00:28:24.600
so you can use it with an
arbitrary entity in your model.

00:28:24.600 --> 00:28:26.600
That's what we did with the demos so far.

00:28:26.600 --> 00:28:28.690
There were no custom data
object classes in there,

00:28:28.730 --> 00:28:30.600
so we just used the NSManagedObject.

00:28:30.600 --> 00:28:34.310
It's not doing very smart things,
such as storing, getting,

00:28:34.310 --> 00:28:37.600
and setting values,
and it's performing the validation rules.

00:28:37.600 --> 00:28:41.350
But for your own custom logic,
you will subclass that and then

00:28:41.560 --> 00:28:46.600
add your own specific code for your
problem domain inside those subclasses.

00:28:46.600 --> 00:28:50.600
That said, NSManagedObjects are probably
sufficient for many cases.

00:28:50.600 --> 00:28:53.500
If you don't need anything special,
just stick with NSManagedObject.

00:28:53.590 --> 00:28:55.750
It's much more convenient.

00:28:56.850 --> 00:28:59.530
When you subclass,
you typically implement your own logic

00:28:59.650 --> 00:29:03.050
in the normal setters and getters
that are defined with QValue coding,

00:29:03.140 --> 00:29:06.340
the naming schemes we defined
with QValue coding observing.

00:29:06.340 --> 00:29:09.650
The same is true for validation,
and we also added a bunch of hooks

00:29:09.650 --> 00:29:12.840
notifications for you in your
objects where you have methods

00:29:12.840 --> 00:29:15.560
that you can override to react to
different kind of state changes.

00:29:15.640 --> 00:29:18.670
And I'd actually like to
walk you now through most of

00:29:18.670 --> 00:29:20.410
the API of NSManagedObject.

00:29:20.640 --> 00:29:22.500
The init method takes two arguments.

00:29:22.520 --> 00:29:25.230
First of all, the entity that the object
actually represents.

00:29:25.270 --> 00:29:28.490
The second argument is this
NSManagedObjectContext.

00:29:28.540 --> 00:29:31.660
James already referred to
it a little bit in his demo.

00:29:31.770 --> 00:29:34.740
And the ManagedObjectContext is the
object that does all the work for you.

00:29:34.740 --> 00:29:38.600
It triggers the undo and redo,
it triggers the validation.

00:29:38.830 --> 00:29:42.150
Every managed object obviously needs to
be assigned to a ManagedObjectContext.

00:29:42.220 --> 00:29:46.030
The first thing you should do if
you create a new object is insert

00:29:46.030 --> 00:29:48.140
it into a ManagedObjectContext.

00:29:49.100 --> 00:29:51.910
There's a get method for it,
and there's also a method to

00:29:51.910 --> 00:29:53.240
get the entity of the object.

00:29:53.410 --> 00:29:56.240
And getting the entity can be
very handy at runtime if you

00:29:56.240 --> 00:29:57.240
want to do some introspection.

00:29:57.240 --> 00:29:59.590
It's actually very similar to
using the class information

00:29:59.590 --> 00:30:01.500
stored in the Objective-C runtime.

00:30:01.500 --> 00:30:04.000
You can use the entity to get
more information of your objects:

00:30:04.000 --> 00:30:05.760
what properties are there,
what attributes,

00:30:05.760 --> 00:30:08.420
what relationships are there,
to what other entities can you

00:30:08.420 --> 00:30:11.590
navigate from a given object,
those kind of things.

00:30:12.170 --> 00:30:15.580
Managed objects also have an object ID.

00:30:15.830 --> 00:30:19.720
The object ID is pretty much a unique
reference that is created when your

00:30:19.790 --> 00:30:23.000
object is stored in the file system,
and it's guaranteed to stay the same

00:30:23.010 --> 00:30:25.000
throughout the lifetime of that object.

00:30:25.080 --> 00:30:28.430
So if you ever need to get a hold
of an object and then store it

00:30:28.430 --> 00:30:31.510
away and get back to it later,
that object ID is a good

00:30:31.510 --> 00:30:33.150
reference for you to use.

00:30:36.120 --> 00:30:37.930
To react to state changes,
there are a bunch of

00:30:37.930 --> 00:30:39.140
methods you can override.

00:30:39.160 --> 00:30:40.650
First of all, there are some get methods.

00:30:40.720 --> 00:30:43.200
The method just is inserted, is updated,
is deleted.

00:30:43.320 --> 00:30:45.100
They just tell you about
the state of the object.

00:30:45.100 --> 00:30:47.100
They are very handy in
the context of bindings.

00:30:47.100 --> 00:30:49.460
For example,
you can wire up the enabled binding

00:30:49.460 --> 00:30:52.290
of a text field to one of these
methods if you only want it to be

00:30:52.290 --> 00:30:54.100
editable in certain situations.

00:30:54.100 --> 00:30:58.100
There are methods that inform you if
the object was just fetched or inserted.

00:30:58.280 --> 00:31:01.100
Typically, you initialize your own
caches in those methods.

00:31:01.100 --> 00:31:03.540
And there are methods that
tell you that an object is

00:31:03.540 --> 00:31:05.100
about to be deleted or saved.

00:31:05.210 --> 00:31:07.100
And here you can
typically set some values,

00:31:07.100 --> 00:31:09.100
maybe a timestamp right
before it's saved,

00:31:09.100 --> 00:31:10.590
something like that.

00:31:12.880 --> 00:31:15.960
For key-value coding and observing,
we just follow the normal standards.

00:31:15.960 --> 00:31:18.910
The generic methods are
valueForKey and setValueForKey.

00:31:18.950 --> 00:31:21.130
You typically don't override
those methods directly,

00:31:21.280 --> 00:31:23.310
but instead you implement
your own accessors.

00:31:23.470 --> 00:31:28.230
Those generic methods call out into
custom versions of the key-value

00:31:28.240 --> 00:31:32.990
coding methods like setName and
name to get the name property.

00:31:33.090 --> 00:31:36.600
One thing that's new in this release
is that we also added support for set

00:31:36.600 --> 00:31:40.730
mutators if you want to modify too
many relationships since they are all

00:31:40.730 --> 00:31:42.600
represented by sets in this release.

00:31:42.690 --> 00:31:46.770
They work the same way as the array
mutators worked in the last release.

00:31:46.810 --> 00:31:50.100
You pretty much get a hold of a
mutable set for a given key and

00:31:50.100 --> 00:31:54.390
then you modify that set and that
modifies the relationship indirectly.

00:31:55.410 --> 00:31:57.070
There are two more things
that are interesting in the

00:31:57.070 --> 00:32:00.300
context of key-value coding and
observing with managed objects.

00:32:00.310 --> 00:32:04.150
Number one is that you typically
still want to access the generic data

00:32:04.230 --> 00:32:06.300
storage mechanism of managed objects.

00:32:06.300 --> 00:32:09.300
You don't need to add your own
IVARs to store your values.

00:32:09.300 --> 00:32:11.300
You can continue to use
the generic mechanism.

00:32:11.300 --> 00:32:14.650
And actually we recommend that you do
that because you can optimize the access

00:32:14.650 --> 00:32:18.290
to the values much better if you continue
using that generic storage mechanism.

00:32:18.300 --> 00:32:20.800
So to access the values,
we added the primitive

00:32:20.800 --> 00:32:23.400
key-value coding methods:
primitive_value_for_key and

00:32:23.400 --> 00:32:24.300
set_primitive_value_for_key.

00:32:24.300 --> 00:32:27.000
And again,
you use them in your own custom accesses

00:32:27.000 --> 00:32:31.300
like set_name and name to call out
into the generic storage mechanism.

00:32:31.910 --> 00:32:36.460
And then the accesses need to be wrapped
by "will change" and "did change" methods

00:32:36.540 --> 00:32:39.800
and also now "will access" and "did
access" methods and the "read" methods.

00:32:39.800 --> 00:32:43.140
Key-value observing actually
has this really nice behavior to

00:32:43.140 --> 00:32:44.930
do this automatically for you.

00:32:44.930 --> 00:32:46.890
We don't have that
implemented for NSObject yet.

00:32:46.970 --> 00:32:49.800
We hope to have that ready by the
end of the release when we ship.

00:32:49.800 --> 00:32:52.530
But at this time you will have
to explicitly call "will change"

00:32:52.530 --> 00:32:55.340
and "did change" in your "set"
methods and "will access" and "did

00:32:55.340 --> 00:32:56.800
access" in your "get" methods.

00:32:56.800 --> 00:32:58.060
So this would be an example.

00:32:58.060 --> 00:33:00.760
For example, if you have a social
security number property,

00:33:00.800 --> 00:33:05.630
the "set" method would jump out in the
first call "will change" then access

00:33:05.630 --> 00:33:10.920
the "set primitive value" for "key"
and then call the "did change" method.

00:33:10.920 --> 00:33:14.430
The "get" method would first call
"will access" then "primitive value"

00:33:14.440 --> 00:33:17.500
for "key" and then "did access".
And of course you can insert your

00:33:17.500 --> 00:33:20.950
own code in between here if you
want to do your own customizations.

00:33:23.310 --> 00:33:25.000
For validation, it's very similar.

00:33:25.000 --> 00:33:27.970
The generic method is
validate_value for key error.

00:33:27.980 --> 00:33:30.100
Again, you typically don't
overwrite that directly.

00:33:30.130 --> 00:33:32.530
Instead, you implement those
custom methods we call,

00:33:32.530 --> 00:33:34.200
something like validate_name error.

00:33:34.350 --> 00:33:37.430
And there are additional methods
for the state changes where you

00:33:37.440 --> 00:33:39.200
can validate the state changes.

00:33:39.310 --> 00:33:42.730
So, validate_for_delete,
insert_and_update, you can deny a delete,

00:33:42.730 --> 00:33:43.610
for example.

00:33:44.520 --> 00:33:45.890
Those would be two concrete examples.

00:33:45.900 --> 00:33:48.650
Again, that's a social security number.

00:33:48.690 --> 00:33:52.870
First check whether the value
is actually of a valid type,

00:33:52.870 --> 00:33:55.300
and then maybe check the length,
and if it's not the right one,

00:33:55.300 --> 00:33:56.940
you can create an error.

00:33:57.030 --> 00:33:59.090
And also you can deny an insert.

00:33:59.090 --> 00:34:03.370
You can pretty much intercept a save
and deny that save if the social

00:34:03.430 --> 00:34:05.610
security number isn't set yet.

00:34:09.250 --> 00:34:12.300
So let's look at the architecture
of Core Data and what actually

00:34:12.320 --> 00:34:14.440
happens to your managed objects.

00:34:14.500 --> 00:34:17.450
What we already heard is that the
managed objects are always assigned

00:34:17.560 --> 00:34:18.960
to a managed object context.

00:34:19.020 --> 00:34:22.190
That's the object that has
most of the work for you.

00:34:22.350 --> 00:34:24.460
To the UI side,
the managed object context

00:34:24.460 --> 00:34:27.390
is simply hooked up,
usually through Cocoa bindings to the UI.

00:34:27.460 --> 00:34:28.640
You don't have to use bindings.

00:34:28.710 --> 00:34:31.900
We saw an example with the Carbon UI,
for example.

00:34:31.980 --> 00:34:35.840
But it's the most convenient
way to handle managed objects.

00:34:36.170 --> 00:34:40.590
So you simply hook up a Cocoa bindings
controller to the managed object context.

00:34:40.610 --> 00:34:45.370
It will then go and filter the objects
out that need to be displayed in the UI.

00:34:45.460 --> 00:34:47.630
It will sort them,
prepare them for the UI,

00:34:47.630 --> 00:34:49.810
and then populate the user interface.

00:34:50.200 --> 00:34:52.320
To the other side,
to the persistent side,

00:34:52.320 --> 00:34:56.050
Managed Object Context is hooked
up to Persistent Store Coordinator.

00:34:56.160 --> 00:34:58.700
That coordinator is the one
that provides the model,

00:34:58.700 --> 00:35:02.310
so it tells the Managed Object Context
what types of entities are available.

00:35:02.310 --> 00:35:06.460
And it's also the object that
synchronizes the access to the different

00:35:06.460 --> 00:35:08.400
data files of your application.

00:35:09.320 --> 00:35:12.200
Let's take a step back
and summarize quickly.

00:35:12.200 --> 00:35:14.700
The managed object context is
the center of your new world.

00:35:14.730 --> 00:35:16.800
It's really the thing that
manages everything for you.

00:35:16.800 --> 00:35:20.250
It does undo and redo,
it triggers validation,

00:35:20.670 --> 00:35:23.750
maintains the inverse relationships
that I mentioned before.

00:35:23.860 --> 00:35:26.470
All that work happens in
the managed object context.

00:35:26.480 --> 00:35:29.880
It serves as the gateway to the
persistent store coordinator.

00:35:29.880 --> 00:35:32.960
If you want an analogy for it,
it's something like a scratch pad.

00:35:33.000 --> 00:35:36.720
It allows you to load objects into
memory from your external files,

00:35:36.720 --> 00:35:39.420
then modify them,
and then either save them back to the

00:35:39.420 --> 00:35:42.860
file system or just throw the changes
away if you don't need them anymore.

00:35:45.540 --> 00:35:50.140
Persistent Store Coordinator is the
instance that provides the model.

00:35:50.150 --> 00:35:53.140
It synchronizes the access
to the persistent stores.

00:35:53.180 --> 00:35:55.620
And the idea really is that
if you use multiple stores,

00:35:55.620 --> 00:35:58.580
multiple files at the same time,
it represents something

00:35:58.580 --> 00:35:59.700
like a unit of them.

00:35:59.800 --> 00:36:03.740
So it merges the content
of all the files together.

00:36:03.740 --> 00:36:06.870
And to the managed object context,
it just looks like it's talking

00:36:06.870 --> 00:36:08.460
to one single data source.

00:36:08.490 --> 00:36:11.310
What's important here for this first
release is that we only support

00:36:11.390 --> 00:36:12.620
striping in this first release.

00:36:12.620 --> 00:36:16.960
So you can merge the content of different
data files together in one context,

00:36:17.060 --> 00:36:19.160
but we don't support mirroring.

00:36:21.480 --> 00:36:27.410
I want to talk a little more
about memory management.

00:36:27.410 --> 00:36:27.410
I'd already mentioned that we

00:36:27.830 --> 00:36:31.490
We will give you good scalability by
only keeping the pieces of your object

00:36:31.490 --> 00:36:33.300
graph in memory that are actually needed.

00:36:33.420 --> 00:36:36.570
Needed means that the objects are
either changed or they are currently

00:36:36.600 --> 00:36:40.810
displayed by the UI or referenced by
any other part of your application.

00:36:41.220 --> 00:36:46.080
Core Data will make sure that your
object graph grows on demand if you

00:36:46.080 --> 00:36:49.100
go deeper into your object graph.

00:36:49.260 --> 00:36:54.090
One concept I want to mention
here is the concept of faulting.

00:36:54.380 --> 00:36:58.300
Most of the time, let's go back to the
example that we had before,

00:36:58.300 --> 00:37:01.900
the XML file that we
showed in the beginning,

00:37:01.900 --> 00:37:03.600
you have an event management system.

00:37:03.690 --> 00:37:07.600
It's common that you look
at a table of data objects,

00:37:07.650 --> 00:37:10.700
but if you drill down,
it's uncommon that you

00:37:10.760 --> 00:37:13.000
actually take a look at all
the objects in your data file.

00:37:13.000 --> 00:37:16.510
So, we will make sure that we
only fetch those objects

00:37:16.600 --> 00:37:18.680
into memory that are needed.

00:37:19.080 --> 00:37:20.990
But you as the developer,
you shouldn't have to worry

00:37:21.000 --> 00:37:23.740
about whether an object has
actually been fetched into memory,

00:37:23.740 --> 00:37:26.600
whether it has been
fully initialized or not.

00:37:26.730 --> 00:37:30.140
And so the concept that we use here is
a concept of little placeholder objects.

00:37:30.140 --> 00:37:32.300
Essentially,
when you fetch an object into memory,

00:37:32.410 --> 00:37:36.300
it's surrounded by little
placeholders that we call faults.

00:37:36.400 --> 00:37:38.200
And those faults are
not fully initialized,

00:37:38.200 --> 00:37:40.670
so we haven't done the work to
actually go to the persistent

00:37:40.670 --> 00:37:43.070
store and get the data from it,
so it saves a lot of

00:37:43.080 --> 00:37:44.500
time and memory there.

00:37:44.610 --> 00:37:48.200
But the placeholder object
is a valid reference.

00:37:48.330 --> 00:37:55.000
So let's say you have that event
object that has tasks assigned to it.

00:37:55.000 --> 00:37:56.900
The task objects can be referenced.

00:37:56.900 --> 00:37:58.690
Those placeholders are valid references.

00:37:58.710 --> 00:38:02.800
You don't have to worry about whether
those are fully initialized or not.

00:38:02.910 --> 00:38:04.870
And we do this pretty much
automatically for you.

00:38:04.960 --> 00:38:08.740
The good thing for you is that you don't
have to worry about whether the object

00:38:08.740 --> 00:38:10.620
has been fetched into memory or not.

00:38:10.780 --> 00:38:13.270
For you, it's completely transparent.

00:38:16.800 --> 00:38:20.330
In a typical document-based application,
you will use multiple stacks

00:38:20.330 --> 00:38:24.170
of Core Data in parallel,
stacks that are completely isolated.

00:38:24.170 --> 00:38:27.580
So each document will typically
have its own managed object context,

00:38:27.640 --> 00:38:31.130
its own persistent store coordinator,
and will typically talk

00:38:31.140 --> 00:38:32.310
to a single document.

00:38:33.190 --> 00:38:36.720
In a non-document-based application,
you usually have multiple

00:38:36.780 --> 00:38:38.100
stores that you want to combine.

00:38:38.100 --> 00:38:40.240
You might have a store in
the user's home directory,

00:38:40.370 --> 00:38:44.280
some additional ones in the network,
and maybe you even have removable media

00:38:44.280 --> 00:38:46.900
that contain additional data files,
additional stores.

00:38:46.980 --> 00:38:49.420
So then again,
the persistent store coordinator

00:38:49.420 --> 00:38:52.240
manages the access to all
these files at the same time,

00:38:52.240 --> 00:38:57.670
and it presents a unit of the stores
to the managed object context.

00:39:00.360 --> 00:39:02.800
Let's take a look at what happens
if you actually fetch objects,

00:39:02.800 --> 00:39:04.300
if you load objects into memory.

00:39:04.300 --> 00:39:08.490
Typically,
a request is triggered by the UI layer.

00:39:08.490 --> 00:39:11.300
For example, a Nib file is loaded that
contains a controller.

00:39:11.300 --> 00:39:13.300
That controller is hooked up
to a managed object context,

00:39:13.300 --> 00:39:17.970
and when it's trying to populate the UI,
it submits what we call a fetch

00:39:17.970 --> 00:39:20.300
request to the managed object context.

00:39:20.340 --> 00:39:22.290
So it's going down the stack.

00:39:22.290 --> 00:39:24.200
The managed object context will
forward that request to the

00:39:24.200 --> 00:39:26.930
persistent store coordinator,
which will take a look at the

00:39:26.930 --> 00:39:29.300
model and then decide what kind
of data file it needs to access.

00:39:29.310 --> 00:39:32.460
It will load the objects from
the data files and send the data

00:39:32.460 --> 00:39:36.570
to the managed object context,
which will then materialize

00:39:36.570 --> 00:39:38.300
that object graph.

00:39:38.300 --> 00:39:41.250
And then the controller...

00:39:41.970 --> 00:39:44.870
We'll filter out which ones actually
need to be displayed in the UI,

00:39:44.970 --> 00:39:49.890
we'll sort and prepare them,
and then populate the user interface.

00:39:50.370 --> 00:39:52.450
And then over time,
when you fetch more objects,

00:39:52.510 --> 00:39:54.330
if you have maybe loaded
additional Nib files,

00:39:54.330 --> 00:39:56.990
or if you look at different
master/detail relationships,

00:39:56.990 --> 00:39:59.770
the object graph will
simply grow over time.

00:40:03.850 --> 00:40:06.820
When changes happen,
those changes usually start in the UI,

00:40:06.820 --> 00:40:09.700
the user goes into the text
field and enters a new value.

00:40:09.710 --> 00:40:14.320
With the help of the controller,
it will then access the data objects.

00:40:16.360 --> 00:40:18.850
and we'll start applying new
values to the data objects.

00:40:18.920 --> 00:40:22.630
And that in turn will cause a key value
observing notification to be sent out,

00:40:22.680 --> 00:40:24.900
so the managed object context
will be notified of the

00:40:24.950 --> 00:40:26.600
changes in the object graph.

00:40:26.700 --> 00:40:29.800
And it will then start
tracking the changes,

00:40:29.800 --> 00:40:33.220
it will start undo and redo,
managing the undo manager,

00:40:33.330 --> 00:40:34.260
all these things.

00:40:34.320 --> 00:40:37.570
Essentially, managed object context will
observe all the changes to

00:40:37.580 --> 00:40:39.000
your object graph over time.

00:40:39.180 --> 00:40:42.000
So if additional objects change,
it will simply track all that.

00:40:42.070 --> 00:40:44.140
If objects are inserted,
if objects are deleted,

00:40:44.140 --> 00:40:46.300
it will keep track of all these changes.

00:40:48.160 --> 00:40:50.490
And then when you save,
that request usually

00:40:50.490 --> 00:40:54.600
again starts in the UI,
it ends up on the managed object context,

00:40:54.630 --> 00:40:57.750
and the managed object context will
then package up all the changes,

00:40:57.750 --> 00:41:00.600
all the deltas to your object graph,
send them to the persistent

00:41:00.600 --> 00:41:03.230
store coordinator,
which will again take a look at

00:41:03.370 --> 00:41:06.550
the model to find out which data
files the changes have to go,

00:41:06.640 --> 00:41:10.780
it will update the data files for you,
and then on success, it will notify the

00:41:10.780 --> 00:41:13.690
managed object context,
which will reset the object

00:41:13.690 --> 00:41:16.080
graph to a clean state,
and then everything

00:41:16.080 --> 00:41:16.410
starts from the beginning.

00:41:20.000 --> 00:41:22.050
I'd like to introduce you to
one more concept that is very

00:41:22.110 --> 00:41:25.600
fundamental to Core Data,
and that's the concept of predicates.

00:41:25.730 --> 00:41:27.090
Predicates define filters.

00:41:27.150 --> 00:41:29.160
They're used for queries.

00:41:29.200 --> 00:41:32.340
And typically,
you either pre-define them in the model,

00:41:32.340 --> 00:41:35.190
you use substitution variables
for which you can then substitute

00:41:35.190 --> 00:41:38.120
the concrete values at runtime,
or you create them programmatically,

00:41:38.120 --> 00:41:42.200
which is usually based on the user input,
for example, in a search field.

00:41:42.810 --> 00:41:45.380
You can evaluate
predicates both in memory,

00:41:45.380 --> 00:41:48.840
if you already have objects fetched,
you can filter them out in memory.

00:41:49.000 --> 00:41:52.620
And sometimes we decide to translate a
predicate into another query language.

00:41:52.640 --> 00:41:55.440
In the context of SQL,
we want to make use of the

00:41:55.440 --> 00:41:58.710
capabilities of the SQL database,
which can do the queries

00:41:58.750 --> 00:42:00.600
very optimised and very fast.

00:42:00.710 --> 00:42:05.290
So we will translate those predicates
into SQL and perform the fetch there.

00:42:06.180 --> 00:42:08.260
NSPredicates,
the classes that represent predicates,

00:42:08.260 --> 00:42:10.540
are also used outside of
the Core Data context.

00:42:10.540 --> 00:42:13.300
The new metadata API in
Cocoa uses predicates.

00:42:13.400 --> 00:42:17.100
We also use it to implement
filtering in the NSArrayController.

00:42:19.290 --> 00:42:23.500
These are some examples for
predicates you can write.

00:42:23.500 --> 00:42:28.410
It starts with simple comparisons
like "name = Tom". We support case

00:42:28.410 --> 00:42:30.310
and diacritic insensitive lookups.

00:42:30.310 --> 00:42:33.970
"Contains" is the operator,
and then you can have an additional flag,

00:42:34.020 --> 00:42:37.380
the "C" for case insensitive and
the "D" for diacritic insensitive.

00:42:37.460 --> 00:42:41.690
We support logical operations,
"and", "or", and "not". We allow

00:42:41.690 --> 00:42:43.280
you to look into relationships.

00:42:43.390 --> 00:42:46.510
For one relationship,
you simply just follow a key path,

00:42:46.510 --> 00:42:49.950
like "group.name". For too
many relationships,

00:42:49.950 --> 00:42:53.080
we give you additional operators,
like "all" and "any". So you

00:42:53.080 --> 00:42:57.400
can look up persons for which
all children are older than 12,

00:42:57.410 --> 00:42:58.750
or just some of them.

00:42:59.660 --> 00:43:03.690
and we even support things like simple
operations like computing the sum of

00:43:03.700 --> 00:43:06.440
all the prices of some items in a list.

00:43:06.490 --> 00:43:08.810
So as you can see,
there's a lot of flexibility here in

00:43:08.810 --> 00:43:14.060
Predicates to define the types of queries
you want to perform on your data objects.

00:43:17.780 --> 00:43:22.490
At runtime, predicates are represented as
a tree of NSPredicate objects.

00:43:22.570 --> 00:43:24.290
There are three classes
you will encounter.

00:43:24.430 --> 00:43:27.580
NSPredicate is the abstract superclass.

00:43:27.580 --> 00:43:32.230
NSCompoundPredicate is the class that
represents logical gates like AND,

00:43:32.270 --> 00:43:32.920
OR, NOT.

00:43:33.000 --> 00:43:35.520
And NSComparisonPredicate is
the predicate that performs

00:43:35.690 --> 00:43:39.170
all the different operators,
the different comparisons like less than,

00:43:39.170 --> 00:43:40.990
greater than, contains, matches.

00:43:41.070 --> 00:43:43.680
There's a list of operators we support.

00:43:44.110 --> 00:43:47.540
Comparison predicates use
NSExpression objects to provide

00:43:47.600 --> 00:43:49.240
the actual computation values.

00:43:49.240 --> 00:43:50.770
There are different types of expressions.

00:43:50.800 --> 00:43:53.000
Again, there are expressions
for constant values,

00:43:53.000 --> 00:43:54.730
expressions that follow key paths.

00:43:54.810 --> 00:43:57.590
Again, there's a list of different
types of expressions we support.

00:43:57.680 --> 00:44:00.350
What I think is really important
for you is that the predicate

00:44:00.410 --> 00:44:02.000
architecture is extensible.

00:44:02.000 --> 00:44:04.640
So you're not limited to
the data types we support.

00:44:04.700 --> 00:44:08.960
If you want to define special operators
that work on NSColors or on NSImages,

00:44:09.130 --> 00:44:12.350
you're free to do so with
the predicate architecture.

00:44:14.700 --> 00:44:16.600
And now I think we have
another demo for you.

00:44:16.620 --> 00:44:20.700
And Bill is going to just show
you some predicates in action.

00:44:20.710 --> 00:44:22.150
- Okay.

00:44:27.970 --> 00:44:32.840
So I'm first going to show you
just briefly a little application

00:44:33.100 --> 00:44:35.120
that I use to pull a bunch of data.

00:44:35.130 --> 00:44:36.990
And mostly I just wanted to
show the model briefly because

00:44:37.070 --> 00:44:40.260
this will be the model that will
be used for the other demos.

00:44:40.260 --> 00:44:43.620
This is actually an application that
will go out to Amazon through their

00:44:43.620 --> 00:44:47.340
public API and will pull a bunch of
information about books you search for,

00:44:47.470 --> 00:44:49.950
and then will populate
a core data database.

00:44:50.080 --> 00:44:52.470
So if I wanted to,
I could go out and say, you know,

00:44:52.470 --> 00:44:56.450
search for everything with Cocoa in it,
and it's going out making a WSDL-based

00:44:56.450 --> 00:45:00.120
web services SOAP call to Amazon,
pulling the data back,

00:45:00.120 --> 00:45:04.200
throwing it in a core data data store,
and then throwing it up in

00:45:04.200 --> 00:45:08.200
our default user interface,
including cover art.

00:45:08.270 --> 00:45:12.740
So that's just a simple little app,
a few lines of code.

00:45:12.740 --> 00:45:14.590
So that's our data model there.

00:45:14.590 --> 00:45:18.340
What we're going to be looking
at is products and manufacturers.

00:45:18.340 --> 00:45:21.090
Amazon uses manufacturers
because they make more than --

00:45:21.090 --> 00:45:22.620
or they sell more than books.

00:45:22.620 --> 00:45:23.910
So think of them as publishers.

00:45:23.980 --> 00:45:24.980
Okay.

00:45:25.700 --> 00:45:29.060
So let me close that
down and go to Booklist.

00:45:29.060 --> 00:45:32.780
So I decided I wanted a little
application that I could use to grab

00:45:32.780 --> 00:45:36.100
a bunch of books from Amazon and
start building up my wish list.

00:45:36.120 --> 00:45:41.370
So I wrote a little app and let
me go ahead and open some data.

00:45:43.340 --> 00:45:44.340
book data.

00:45:44.340 --> 00:45:47.610
As you can see,
I get a big list of books and

00:45:47.610 --> 00:45:50.060
their prices and et cetera.

00:45:50.060 --> 00:45:51.930
And now I can apply
some predicates to it.

00:45:52.040 --> 00:45:55.650
So the first predicate I'm going
to apply is just a very simple one.

00:45:55.650 --> 00:45:59.970
I want to find all the books or all
of the entities of type product that

00:45:59.970 --> 00:46:05.780
have the product name contains the word
"coco." So you can see it's executed,

00:46:05.780 --> 00:46:07.180
and there it is.

00:46:07.180 --> 00:46:09.480
Now, predicates can also do
some more complex things,

00:46:09.480 --> 00:46:13.300
like I can say, "Show me all of the books
at Amazon where the price is

00:46:13.300 --> 00:46:16.880
between $15 and $25." As well,
since predicates are all

00:46:16.880 --> 00:46:19.860
based on key value coding,
and it should be emphasized that they

00:46:19.990 --> 00:46:22.020
aren't limited to just managed objects.

00:46:22.100 --> 00:46:27.000
They will work with any object in the
system that's key value coding compliant.

00:46:27.250 --> 00:46:29.210
I can also follow key value paths.

00:46:29.360 --> 00:46:31.950
So in this case,
I'm going to ask all of my products

00:46:31.950 --> 00:46:35.890
for all of their manufacturers
and then ask for all manufacturer

00:46:35.890 --> 00:46:37.610
names that begin with O'Reilly.

00:46:37.610 --> 00:46:40.420
So as you can see there,
it's actually following the key paths.

00:46:40.420 --> 00:46:42.370
So I'm going to say,
"I'm looking for O'Reilly," and

00:46:42.370 --> 00:46:43.980
I get my list of books from O'Reilly.

00:46:44.000 --> 00:46:48.410
Now,
I can also do things where I'm testing

00:46:48.410 --> 00:46:55.200
if one object is in a set of objects that
are related to another set of objects.

00:46:55.200 --> 00:46:58.880
So in this case,
if I want to go in and find everything

00:46:58.880 --> 00:47:04.090
on Microsoft Press and McGraw-Hill
and Addison Wesley and Sam's,

00:47:04.090 --> 00:47:05.340
I can do that.

00:47:05.440 --> 00:47:10.420
Now I should actually show
you a little bit of code here.

00:47:10.420 --> 00:47:14.170
This is a simple little application.

00:47:15.530 --> 00:47:21.320
To apply the predicate
in the first place,

00:47:21.320 --> 00:47:21.320
that's not it.

00:47:22.710 --> 00:47:25.340
There it is.

00:47:25.370 --> 00:47:26.800
This is the line of code.

00:47:26.800 --> 00:47:29.800
Oh, I should scroll a little bit.

00:47:33.260 --> 00:47:36.060
These are the two lines of code
necessary to create a predicate

00:47:36.060 --> 00:47:37.200
and apply it to an array.

00:47:37.240 --> 00:47:39.320
The first line will actually
take that string that you

00:47:39.320 --> 00:47:41.200
saw in the user interface,
those were actual real

00:47:41.200 --> 00:47:43.740
live predicate expressions.

00:47:43.820 --> 00:47:46.980
It will evaluate it,
turn it into a predicate object,

00:47:46.980 --> 00:47:51.180
which you can then programmatically
query or take apart if you want to.

00:47:51.230 --> 00:47:53.680
And then it will apply it to
an array and return the array

00:47:53.680 --> 00:47:55.520
of objects that result from it.

00:47:55.550 --> 00:47:57.250
There's also a mutable
array version of this,

00:47:57.250 --> 00:48:00.330
so you can take a mutable array
full of objects and reduce it by

00:48:00.330 --> 00:48:02.700
whatever objects pass the predicate.

00:48:02.740 --> 00:48:07.580
The second example also shows
how to do custom predicates.

00:48:07.640 --> 00:48:13.360
So in the case of this user interface,
I needed to basically check to

00:48:13.360 --> 00:48:17.290
see if a particular product has
a manufacturer of this set of

00:48:17.290 --> 00:48:20.200
manufacturers I have selected in this UI.

00:48:20.280 --> 00:48:23.110
And in that case, in this line of code,
I'm actually creating

00:48:23.110 --> 00:48:25.350
a comparison predicate

00:48:25.600 --> 00:48:29.800
and comparison predicates always have a
left expression and a right expression.

00:48:29.800 --> 00:48:33.010
So in this case I'm saying the
left expression is the evaluated

00:48:33.010 --> 00:48:36.110
object and all that means is that
it's the object in the array of

00:48:36.220 --> 00:48:37.850
books that I'm trying to filter.

00:48:37.900 --> 00:48:39.740
It's the thing I want to filter.

00:48:39.850 --> 00:48:43.470
And the right expression in this
case is a constant value and

00:48:43.480 --> 00:48:45.250
it's my selected manufacturers.

00:48:45.260 --> 00:48:48.300
It's just whatever
I have selected in here.

00:48:48.380 --> 00:48:52.630
And in this case I said I want
to use a custom selector,

00:48:52.710 --> 00:48:54.700
which is member of array.

00:48:54.780 --> 00:48:58.060
And this is going to be a method that's
going to be invoked on objects from

00:48:58.060 --> 00:49:02.460
the left hand side and it will take
an argument from the right hand side

00:49:02.460 --> 00:49:04.460
will be the argument passed to it.

00:49:04.550 --> 00:49:08.850
So in a category on NSManagedObject,
because in this demo we're using

00:49:08.850 --> 00:49:12.520
nothing but managed objects,
I wrote the member of array method,

00:49:12.520 --> 00:49:14.380
which as you can see is
pretty straightforward.

00:49:14.480 --> 00:49:18.710
So using this, leveraging this,
you could, like Andrea said,

00:49:18.710 --> 00:49:20.850
you could qualify anything.

00:49:20.860 --> 00:49:23.900
You could predicate any object as
long as you have key values in it.

00:49:23.900 --> 00:49:33.660
So you could have a method that takes a
single argument and returns a Boolean.

00:49:33.660 --> 00:49:36.120
Now if you get into expressions,
which are more complex,

00:49:36.180 --> 00:49:37.920
then you could open it up even further.

00:49:38.220 --> 00:49:40.910
Now I have one more demo.

00:49:41.090 --> 00:49:43.750
We at Apple like to eat our own dog food.

00:49:44.000 --> 00:49:49.680
So this is actually the core data
predicates are being used by metadata

00:49:49.680 --> 00:49:52.920
in the Objective-C API to metadata.

00:49:53.590 --> 00:49:55.660
Let me go ahead and run this application.

00:49:55.720 --> 00:49:58.380
And it comes up and it gives you a
field and you can type a query into it,

00:49:58.400 --> 00:50:01.040
which is going to be a metadata query.

00:50:01.120 --> 00:50:02.850
And it will show a list
of files that result.

00:50:03.080 --> 00:50:08.730
So, for example, I can ask it,
"Show me all files

00:50:09.440 --> 00:50:12.520
Let's start with the word "app
delegate" in their file name.

00:50:12.520 --> 00:50:14.540
It takes a second, but there it comes.

00:50:14.540 --> 00:50:17.210
You can see that the results
are filling in as it goes.

00:50:17.290 --> 00:50:19.800
This is again because it's
all leveraging key value

00:50:19.800 --> 00:50:21.300
observing and key value binding.

00:50:21.300 --> 00:50:25.060
We can do some more complex queries,
like for example,

00:50:25.060 --> 00:50:28.930
I have a metadata importer
that grabs Objective-C metadata

00:50:29.080 --> 00:50:31.300
from Objective-C source files.

00:50:31.300 --> 00:50:33.960
In this case,
I'm going to find all files on

00:50:33.960 --> 00:50:37.300
my hard drive that implement
subclasses of NSView,

00:50:37.300 --> 00:50:41.300
which is pretty handy if you want
to find stuff in example code.

00:50:41.300 --> 00:50:45.300
Now, let's look at the code.

00:50:45.300 --> 00:50:50.570
The code for this is actually
quite straightforward.

00:50:51.440 --> 00:50:53.750
and you can ignore the
notification center stuff.

00:50:53.800 --> 00:50:56.950
That's an unfortunate hack necessary
to make the demo work right now.

00:50:57.060 --> 00:50:58.990
It goes away.

00:50:59.090 --> 00:50:59.740
It doesn't exist.

00:50:59.850 --> 00:51:01.420
Those lines are not there.

00:51:01.490 --> 00:51:07.180
So we simply create a query and then
we set the predicate on the query

00:51:07.180 --> 00:51:08.590
and again you see that line of code.

00:51:08.710 --> 00:51:11.400
Predicate will format argument array.

00:51:11.430 --> 00:51:12.740
And that's it.

00:51:12.770 --> 00:51:14.140
Start the query, you're done.

00:51:14.220 --> 00:51:16.480
So those are predicates.

00:51:26.600 --> 00:52:21.700
[Transcript missing]

00:52:24.090 --> 00:52:25.990
Of course,
the seat you have in your own hands

00:52:26.000 --> 00:52:29.890
right now is a very early bit,
so not everything is

00:52:29.890 --> 00:52:31.430
fully working right now.

00:52:31.450 --> 00:52:34.000
SQLite,
you already saw it working here on stage,

00:52:34.000 --> 00:52:37.960
but the access for you in the
seat is not available right now.

00:52:38.250 --> 00:52:41.210
The other two things worth mentioning
is that controllers aren't as live

00:52:41.210 --> 00:52:42.740
as we'd like them to be right now.

00:52:42.740 --> 00:52:44.890
We'd like them to react much
better to adding and removing

00:52:44.890 --> 00:52:48.300
persistent stores on the fly,
and then update the UI automatically.

00:52:48.300 --> 00:52:51.100
We don't have all that implemented yet,
and also fetch properties

00:52:51.100 --> 00:52:52.930
aren't supported at this time.

00:52:53.030 --> 00:52:56.590
Then of course,
the little things like localization,

00:52:56.590 --> 00:52:59.790
better error messages,
leaks optimizations,

00:52:59.790 --> 00:53:01.960
that all is still forthcoming.

00:53:01.960 --> 00:53:06.210
That said, the complete API can be
completely exercised with the

00:53:06.230 --> 00:53:10.250
XML store that actually works
fully in the seat that we have.

00:53:10.250 --> 00:53:12.700
So we would like you to...

00:53:15.000 --> 00:53:16.860
So, please try it out.

00:53:16.860 --> 00:53:19.000
We would like to get your feedback.

00:53:19.090 --> 00:53:23.000
You can send an email to
cocoafeedback@group.apple.com

00:53:23.000 --> 00:53:24.900
or you can submit bug reports.

00:53:24.900 --> 00:53:26.280
Actually,
submitting bug reports is probably

00:53:26.280 --> 00:53:29.430
the best way for you to communicate
feature requests and ideas and

00:53:29.430 --> 00:53:31.000
also the bugs you encounter.

00:53:31.000 --> 00:53:46.290
Thank you.

00:53:48.570 --> 00:53:52.140
So in summary,
Core Data is a model-driven framework.

00:53:52.210 --> 00:53:54.610
It manages your objects.

00:53:54.610 --> 00:53:56.100
It persists your objects.

00:53:56.100 --> 00:53:59.500
It automatically updates
your UI to Cocoa bindings.

00:53:59.550 --> 00:54:02.490
It solves some very difficult
problems like undo and redo.

00:54:02.560 --> 00:54:03.500
It gives you great scalability.

00:54:03.500 --> 00:54:05.480
It gives you choice in persistent stores.

00:54:05.530 --> 00:54:10.500
We support SQL databases, XML files,
and binary files.

00:54:10.500 --> 00:54:14.500
We have added some good
support in Xcode for modeling.

00:54:14.500 --> 00:54:15.500
There's a great modeling tool for you.

00:54:15.500 --> 00:54:18.500
And really the benefit for you
is that you will write a lot

00:54:18.500 --> 00:54:20.450
or significantly less code.

00:54:20.500 --> 00:54:24.500
You'll be a lot faster while
you develop your application.

00:54:24.500 --> 00:54:25.500
So that was my summary.

00:54:25.500 --> 00:54:29.390
The good news for you is that
there's going to be a second summary.

00:54:52.400 --> 00:54:56.770
So last year we had a little
song to go with Cocoa Bindings

00:54:56.770 --> 00:54:59.800
called Model View Controller.

00:54:59.800 --> 00:55:05.840
And this year,
with the focus on Core Data and

00:55:05.840 --> 00:55:09.140
building some data models,
since the songwriting tends to

00:55:09.140 --> 00:55:15.590
go where the technology leads me,
it's a little song about data modeling.

00:55:16.370 --> 00:55:20.640
So we need to switch over to the laptop.

00:55:20.640 --> 00:55:22.200
Excellent.

00:55:22.220 --> 00:55:24.100
So hope you like it.

00:55:47.200 --> 00:55:52.040
They say, "Are you in modeling?" I say,
"Oh yes I am." There's no catwalk

00:55:52.150 --> 00:55:54.810
involved in the modeling I do.

00:55:54.810 --> 00:55:59.100
There's no demand for me to
try that kind of modeling too.

00:56:02.000 --> 00:56:06.140
Some people want a data
model for a new application,

00:56:06.140 --> 00:56:10.760
don't want to write a lot of code,
simply use configuration to refine

00:56:10.760 --> 00:56:16.180
your data model with each new
iteration as you build a prototype

00:56:16.180 --> 00:56:19.150
with persistence automation.

00:56:24.650 --> 00:56:29.160
Some people want to date a model
but prefer one in fashion If you

00:56:29.160 --> 00:56:33.860
date a data model that's an interest
and passion You're a dreamer with

00:56:33.860 --> 00:56:38.190
a schema you can usually cash in
Though you ain't got the looks in your

00:56:38.320 --> 00:56:44.600
clothes they are clashing Modeling man,
I'm a modeling man Let me lay it

00:56:44.600 --> 00:56:49.190
all out so that you'll understand
You'll have the terminology and

00:56:49.190 --> 00:56:55.700
concepts at your command  So you
can also be a modeling woman or man 

00:56:59.000 --> 00:57:00.870
You design your data model as
pretty as you please by adding items

00:57:00.870 --> 00:57:01.900
to the model known as entities.

00:57:01.900 --> 00:57:03.880
And entities are right by me.

00:57:03.930 --> 00:57:04.890
It's what a thing's supposed to be.

00:57:04.890 --> 00:57:05.310
What type, what sort, what class,
what kind,

00:57:05.310 --> 00:57:05.700
whatever you might have in mind.

00:57:05.700 --> 00:57:07.660
You pick a name, map to a class.

00:57:07.660 --> 00:57:09.700
Now your model's growing fast.

00:57:09.700 --> 00:57:10.900
You work some more and come to grips
with attributes and relationships.

00:57:10.900 --> 00:57:12.790
You design your data model as
pretty as you please by adding items

00:57:12.790 --> 00:57:13.900
to the model known as entities.

00:57:13.900 --> 00:57:15.720
And entities are right by me.

00:57:15.720 --> 00:57:17.890
It's what a thing's supposed to be.

00:57:17.960 --> 00:57:19.620
What type, what sort, what class,
what kind,

00:57:19.620 --> 00:57:20.890
whatever you might have in mind.

00:57:20.900 --> 00:57:22.300
You pick a name, map to a class.

00:57:22.300 --> 00:57:23.620
Now your model's growing fast.

00:57:23.840 --> 00:57:26.900
You work some more and come to grips
with attributes and relationships.

00:57:26.900 --> 00:57:28.100
Now your model's growing fast.

00:57:28.100 --> 00:57:30.900
You work some more and come to grips
with attributes and relationships.

00:57:30.900 --> 00:57:35.030
Now baby, now you're modeling too.

00:57:36.600 --> 00:57:42.640
I said, "Baby,
what more for a mildly man to do?"

00:57:44.200 --> 00:58:01.000
[Transcript missing]

00:58:02.950 --> 00:58:07.240
I said I'm a modeling man,
I'm a modeling man.

00:58:07.320 --> 00:58:11.990
They say, "Are you in modeling?" I say,
"Oh yes I am." There's no photographers

00:58:11.990 --> 00:58:14.040
involved in the modeling I do.

00:58:14.080 --> 00:58:19.090
I got turned down by everyone
I gave my headshot to.

00:58:38.900 --> 00:58:54.700
[Transcript missing]

00:58:57.000 --> 00:59:00.730
The entities can be connected,
kinda joined at the hip.

00:59:00.730 --> 00:59:04.420
The formal name for this
arrangement is a relationship.

00:59:04.480 --> 00:59:08.580
One object references the other,
so it can't give it the slip.

00:59:08.580 --> 00:59:13.120
The inverse reference is maintained
for a convenient round trip.

00:59:14.860 --> 00:59:22.650
I said, I said, "I'm a modeling man,
yeah, I'm a modeling man." They say,

00:59:22.650 --> 00:59:26.740
"Are you in modeling?" I say, "Oh, yes,
I am." But don't come knocking if

00:59:26.740 --> 00:59:29.160
it's rocking in the back of the van.

00:59:29.220 --> 00:59:34.310
I'm probably wrestling with
relationships I don't quite understand.

00:59:42.900 --> 01:00:01.600
[Transcript missing]

01:00:34.400 --> 01:00:39.400
I have the boring task
to finish up the session,

01:00:39.400 --> 01:00:41.400
if you could switch back to the slides.

01:00:41.400 --> 01:00:44.640
There are a few more sessions
I'd like to point you to that

01:00:44.770 --> 01:00:46.400
are related to Core Data.

01:00:46.400 --> 01:00:49.480
Using and customizing Cocoa bindings
this afternoon at 5:00,

01:00:49.480 --> 01:00:52.400
we'll have a little piece
on the UI part of Core Data.

01:00:52.400 --> 01:00:55.400
Tomorrow morning at 10:30,
there's advanced Core Data.

01:00:55.400 --> 01:00:58.170
And on Friday morning at 9:00,
we have an overview of the

01:00:58.200 --> 01:01:02.400
modeling tool in depth,
modeling and design in Xcode.

01:01:02.440 --> 01:01:05.560
These are the usual people to contact.
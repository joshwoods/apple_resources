WEBVTT

00:00:12.170 --> 00:00:14.090
Good afternoon, everyone.

00:00:14.140 --> 00:00:19.570
Please welcome, from Apple Computer,
Manager of Text Input and Fonts,

00:00:19.630 --> 00:00:21.640
Giulia Pagallo.

00:00:27.140 --> 00:00:30.300
Welcome to session 425.

00:00:30.320 --> 00:00:34.700
I hope you guys are having an
excellent conference this year.

00:00:34.700 --> 00:00:36.840
When we were putting
the session together,

00:00:36.840 --> 00:00:41.030
we were wondering what percentage of the
developers attending the session would be

00:00:41.030 --> 00:00:45.600
new to the area of Carbon Text and what
percentage would be returning developers.

00:00:45.600 --> 00:00:49.290
So let me start by asking,
how many are new to this area?

00:00:49.290 --> 00:00:49.880
Any?

00:00:49.880 --> 00:00:50.830
Anybody?

00:00:50.830 --> 00:00:51.800
All right.

00:00:51.950 --> 00:00:52.530
Good.

00:00:52.530 --> 00:00:58.950
How many of you are already using some
of the Carbon Text APIs for Mac OS X?

00:00:59.180 --> 00:01:00.600
Excellent.

00:01:00.600 --> 00:01:04.560
We have a session that is packed
with information for both you,

00:01:04.560 --> 00:01:06.680
the new developers,
so that you can quickly

00:01:06.680 --> 00:01:09.440
orient yourself in this area,
and for you,

00:01:09.440 --> 00:01:14.390
the developers who have been using
our APIs release after release.

00:01:18.200 --> 00:01:20.770
In particular,
I'm going to start by giving

00:01:20.770 --> 00:01:25.460
you an overview of the
Carbon Text API landscape.

00:01:25.460 --> 00:01:28.440
And I'm going to talk about
the APIs for static text,

00:01:28.440 --> 00:01:31.520
as well as the APIs for editable text.

00:01:31.520 --> 00:01:34.260
After that,
I'm going to turn my attention

00:01:34.260 --> 00:01:40.220
to the HITextView APIs,
and the MLT APIs for editable text.

00:01:40.220 --> 00:01:43.060
And then I'm going to turn the
presentation to Tom Madden,

00:01:43.350 --> 00:01:45.620
one of the engineers in the ATSUI team.

00:01:45.620 --> 00:01:48.180
And he's going to talk
to you about ATSUI,

00:01:48.330 --> 00:01:53.140
which are the APIs you
use for laying out text.

00:01:55.040 --> 00:02:00.960
So say that a lot of the applications
have a need for static text,

00:02:00.960 --> 00:02:05.510
either for your labels and your controls,
for your text and your dialogues,

00:02:05.600 --> 00:02:08.290
or some bits and pieces
in general of text.

00:02:08.400 --> 00:02:12.480
And for static text,
there are basically four components

00:02:12.480 --> 00:02:14.930
that play a key role in this area.

00:02:15.120 --> 00:02:19.840
So at the bottom of my diagram is Quartz,
the Apple 2D drawing engine,

00:02:19.840 --> 00:02:24.850
which provides beautiful, crisp,
anti-aliased text on the screen.

00:02:25.000 --> 00:02:30.100
A client of Quartz is at
SUI Apple Type Services for Unicode,

00:02:30.100 --> 00:02:33.860
which is the component responsible
for positioning the glyphs

00:02:33.900 --> 00:02:35.660
correctly on your documents.

00:02:35.660 --> 00:02:40.420
And also breaking the
lines of text correctly.

00:02:40.420 --> 00:02:43.580
Whatever language you
are using at the time,

00:02:43.580 --> 00:02:47.480
whether it is Japanese, Chinese,
or Roman language,

00:02:47.480 --> 00:02:49.490
at SUI does the right job.

00:02:51.710 --> 00:02:55.830
The next level up is either
the Appearance Manager in the

00:02:55.830 --> 00:02:59.970
high-level toolbox or the MLTE APIs,
which stands for

00:02:59.970 --> 00:03:02.330
Multilingual Text Engine.

00:03:02.460 --> 00:03:08.310
In 95% of the cases, 99% of the cases,
the API that you should use for

00:03:08.360 --> 00:03:13.870
static text that we recommend
you use is the HITheme Text APIs.

00:03:14.400 --> 00:03:17.820
However,
there are situations in which you

00:03:17.820 --> 00:03:22.350
need control over rotated text,
in which you need control

00:03:22.350 --> 00:03:27.060
over the graphic context,
or you need to use fonts other than

00:03:27.060 --> 00:03:30.160
the ones the HI theme fonts provide.

00:03:30.160 --> 00:03:32.950
In that case,
we recommend you look at the two

00:03:33.110 --> 00:03:36.120
APIs that MLTE provides for static text.

00:03:36.120 --> 00:03:38.080
Is that not enough?

00:03:38.080 --> 00:03:40.800
You need additional control
for your static text?

00:03:40.800 --> 00:03:42.800
Then you should look at the ATSUI APIs.

00:03:49.340 --> 00:03:49.400
Tom is going to talk to you about them in
the second portion of this presentation.

00:03:51.000 --> 00:03:54.730
The same components that play
a role for static text play

00:03:54.800 --> 00:03:58.830
a role for editable text,
and you see them on the screen.

00:03:58.970 --> 00:04:05.510
Now, let's say that you have a mail-like
application where you have some small

00:04:05.510 --> 00:04:10.990
text fields on the top of your window,
say, for your recipient or

00:04:11.150 --> 00:04:15.750
your subject of the email,
and some large text areas for

00:04:15.750 --> 00:04:16.620
the content of your email.

00:04:16.620 --> 00:04:16.620
Which APIs should you use?

00:04:16.960 --> 00:04:19.640
So for the small text fields,
we recommend you use

00:04:19.640 --> 00:04:20.720
the Unicode controls.

00:04:20.720 --> 00:04:26.500
And those are being available
in the system since the

00:04:26.500 --> 00:04:28.740
first version of Mac OS X.

00:04:28.740 --> 00:04:31.820
For the large text area,
if you have an application

00:04:31.820 --> 00:04:36.060
currently running Mac OS and
you are using the system APIs,

00:04:36.160 --> 00:04:40.680
you're probably using MLT directly,
which is good.

00:04:40.690 --> 00:04:48.250
However, we recommend that for Tiger and
beyond you transition to use the

00:04:48.250 --> 00:04:52.480
HITextView APIs in conjunction with MLT.

00:04:52.480 --> 00:04:54.340
And I'm gonna tell you why in a second.

00:04:54.380 --> 00:04:58.740
But before I move on,
I also want to point out that if you

00:04:58.740 --> 00:05:02.600
are developing your own text engine,
in that case,

00:05:02.600 --> 00:05:06.880
you want to use the ATSUI APIs directly.

00:05:06.880 --> 00:05:10.140
And again,
Tom is gonna talk to you about that.

00:05:10.840 --> 00:05:15.800
In summary, if you have static text,
for most cases,

00:05:15.920 --> 00:05:20.100
take a look at the HIT theme
text box APIs if you need

00:05:20.100 --> 00:05:23.100
additional control over styles.

00:05:23.100 --> 00:05:27.750
The graphic context,
you need to rotate your text.

00:05:27.820 --> 00:05:34.340
Take a look at TXN draw CFString text
box API and those are in the MLT header.

00:05:34.340 --> 00:05:40.370
And if you need additional control
over how your text is rendered,

00:05:40.370 --> 00:05:42.090
please look at the

00:05:42.420 --> 00:05:48.720
For edited text, for text fields,
as I said, use the Unicode Control,

00:05:48.760 --> 00:05:54.350
and that the API that is on the
screen is the API create Unicode

00:05:54.350 --> 00:06:00.650
Edit Text Control is the API you
call to create one such text field.

00:06:00.650 --> 00:06:05.530
And for text areas, again,
for target and beyond,

00:06:05.530 --> 00:06:09.810
we recommend you start using
HITextView in conjunction with MLTE.

00:06:10.140 --> 00:06:13.980
Now, I'm hearing some of you
back in the room saying,

00:06:13.980 --> 00:06:15.460
I have an application.

00:06:15.550 --> 00:06:18.420
I'm using the MLT API for my text area.

00:06:18.420 --> 00:06:20.600
They work beautifully.

00:06:20.600 --> 00:06:25.620
Why should I move on and
transition to HITextView?

00:06:25.620 --> 00:06:27.150
And here are six reasons.

00:06:27.280 --> 00:06:29.860
And there will probably
be more in the future.

00:06:29.880 --> 00:06:38.030
So if you attended the high-level toolbox
session during the conference this year,

00:06:38.390 --> 00:06:41.400
you heard that the high-level
toolbox team is working hard,

00:06:41.440 --> 00:06:48.000
has been working hard in modernizing the
Carbon toolbox and being transitioning

00:06:48.010 --> 00:06:51.320
to a hierarchical view model.

00:06:51.320 --> 00:06:54.520
If you use HITextView,
your text area will

00:06:54.990 --> 00:06:56.860
belong to the hierarchy.

00:06:56.980 --> 00:07:00.910
And the advantage of that is
that then internally we can take

00:07:03.380 --> 00:07:07.450
We can use that information to optimize,
for instance,

00:07:07.450 --> 00:07:09.770
the rendering of your objects.

00:07:09.890 --> 00:07:18.780
In addition,
the order of the Carbon events

00:07:18.780 --> 00:07:18.780
is well defined if your
text area is an HITextView.

00:07:19.510 --> 00:07:24.100
Also, throughout the conference,
we've been pointing out the importance

00:07:24.100 --> 00:07:28.130
of supporting accessibility so
that your application is available

00:07:28.130 --> 00:07:29.860
to a wider set of customers.

00:07:29.970 --> 00:07:32.970
If you use HITextView,
accessibility is built

00:07:32.980 --> 00:07:34.380
in in your text area.

00:07:34.550 --> 00:07:40.680
There is no work that you need to do in
order to make your text area accessible.

00:07:40.990 --> 00:07:45.160
Compositing is also
supported in HITextView.

00:07:45.570 --> 00:07:55.810
And in addition, it's very easy to create
an HITextView using the

00:07:55.810 --> 00:07:55.810
tools that Apple provides.

00:07:55.810 --> 00:07:55.810
And I'm going to show you
how to do that in a minute.

00:07:56.800 --> 00:08:02.520
Last but not least,
if you have an HITextView,

00:08:02.520 --> 00:08:11.790
the MLTE object is available to you so
that you can extract that object from the

00:08:12.230 --> 00:08:16.210
HITextView and you can reuse all of that
code that you already have in customizing

00:08:16.210 --> 00:08:16.210
your text area using the MLTE APIs.

00:08:18.620 --> 00:08:24.070
Now, let me take a quick detour for
those of you who are new to the area

00:08:24.120 --> 00:08:28.580
of Carbon Text and tell you what
are the advantages of using MLTE.

00:08:28.580 --> 00:08:31.490
What does MLTE provide?

00:08:32.240 --> 00:08:36.340
So, MLT is a full Unicode
layout and edited engine.

00:08:36.350 --> 00:08:40.830
And what that does mean to you is that
your text area are gonna support all

00:08:40.830 --> 00:08:43.530
of the languages the Mac OS X supports.

00:08:43.650 --> 00:08:48.360
You don't need to worry about the
upgrades to the Unicode standard.

00:08:48.360 --> 00:08:52.600
You don't need to worry about learning
about how bidirectional text works.

00:08:52.620 --> 00:08:53.990
That is there for you.

00:08:54.020 --> 00:08:59.690
In addition, because we leveraged at ZUI,
we have advanced typography.

00:08:59.910 --> 00:09:08.570
I suggest you go and use the typography
panel in conjunction with MLT in Tiger to

00:09:08.640 --> 00:09:13.580
see how you can take advantage of all
the rich features that we have in the

00:09:13.580 --> 00:09:15.760
fonts to produce some beautiful text.

00:09:15.760 --> 00:09:19.480
Of course, we have anti-alias text.

00:09:19.480 --> 00:09:24.480
And MLT also provides built-in
support for multimedia,

00:09:24.680 --> 00:09:27.440
which is important because
these days it's very rare the

00:09:27.440 --> 00:09:29.460
document that contains text only.

00:09:31.450 --> 00:09:37.970
Another advantage of MLTE APIs is
that they provide support for

00:09:37.970 --> 00:09:42.320
the basic functionality without
requiring for you to write any code.

00:09:42.490 --> 00:09:46.470
So, for instance, you get input,
text input, from any of the input

00:09:46.470 --> 00:09:50.210
methods in the system,
whether they are character palettes,

00:09:50.210 --> 00:09:53.990
keyboard layouts, input methods, ink,
they just work.

00:09:54.000 --> 00:09:58.760
Selection, drag and drop are built in,
and we also added support

00:09:58.920 --> 00:10:04.360
for the document access,
which are new Carbon events

00:10:04.760 --> 00:10:07.870
that were introduced in Panther.

00:10:08.490 --> 00:10:15.790
Now, if that is not enough,
if you need customization

00:10:15.910 --> 00:10:22.590
for your text area,
MLTE provides a simple set of

00:10:22.590 --> 00:10:24.460
APIs that allow you to customize
the text area to your needs.

00:10:24.460 --> 00:10:24.460
And I'm going to show you
how to do that in a second.

00:10:27.000 --> 00:10:30.000
But most important, I think,
MLT is an evolving and

00:10:30.000 --> 00:10:31.220
growing set of APIs.

00:10:31.220 --> 00:10:34.860
We've been listening to your feedback,
and we really thank you for that,

00:10:34.920 --> 00:10:37.480
of what are the areas
that are important to you.

00:10:37.480 --> 00:10:41.590
What are the areas where you need
new APIs to customize your text area?

00:10:41.640 --> 00:10:48.120
And so, I like to think of the
improvement in MLT in two areas.

00:10:48.140 --> 00:10:52.310
On the one hand, we have the improvement
that we do under the hood.

00:10:53.280 --> 00:10:59.080
That's the work that we do at Apple,
so that your application provides richer

00:10:59.080 --> 00:11:03.670
and richer behavior without you making
any changes whatsoever to your code.

00:11:03.730 --> 00:11:05.660
And I'm going to give
you an example of that.

00:11:05.660 --> 00:11:09.660
On the other hand,
we have new APIs based on your

00:11:09.660 --> 00:11:13.970
feedback that allow you to customize
your application and deliver to your

00:11:13.970 --> 00:11:16.050
customers the functionality they need.

00:11:17.420 --> 00:11:20.530
So let's talk a little bit about
what we've been working on.

00:11:20.600 --> 00:11:26.260
What are the areas where you
can see enhancements in MRT?

00:11:26.260 --> 00:11:30.950
As there are more and more Carbon and
Cocoa applications in the system,

00:11:30.960 --> 00:11:35.480
we think it's important that the users
get a consistent behavior as they switch

00:11:35.580 --> 00:11:37.410
from one application to the other.

00:11:37.420 --> 00:11:40.900
So we've been working closely
with the Cocoa team to

00:11:41.260 --> 00:11:42.820
provide a consistent behavior.

00:11:43.110 --> 00:11:45.660
This is work in progress,
but you can notice that there has

00:11:45.780 --> 00:11:47.430
been some improvements in this area.

00:11:49.790 --> 00:11:56.980
the customers are there are
more and more multilingual.

00:11:57.190 --> 00:12:01.590
So we've been working on
improving the multilingual

00:12:01.820 --> 00:12:03.510
experience in your text areas.

00:12:03.580 --> 00:12:06.730
In particular,
I want to point out that we have added

00:12:06.820 --> 00:12:11.170
support for Glyph Variants in Tiger,
so that for instance,

00:12:11.170 --> 00:12:15.800
you can use the typography panel,
use one of the fonts that

00:12:15.800 --> 00:12:20.570
has Glyph Variants built in,
and you can choose the glyph that

00:12:20.760 --> 00:12:22.630
you want to represent your name.

00:12:22.670 --> 00:12:26.400
This is for instance,
important to our Japanese users.

00:12:26.400 --> 00:12:31.830
You can see on the second line on
my screen is three of the spellings

00:12:31.830 --> 00:12:36.190
for the last name Watanabe.

00:12:37.250 --> 00:12:41.820
The second character is different
in each of the ways they spell it,

00:12:41.870 --> 00:12:45.680
and this is important to Japanese users.

00:12:45.680 --> 00:12:48.160
In addition,
the Kotori team has been working

00:12:48.160 --> 00:12:52.590
on improving the conversion
accuracy of their input method,

00:12:52.590 --> 00:12:57.750
and the way they did that is by
leveraging some new Carbon events that

00:12:58.120 --> 00:13:02.980
allow the input method to get access
to the context in your text area.

00:13:02.980 --> 00:13:06.610
We added that support in MLTE so
that your text areas get better

00:13:06.610 --> 00:13:09.990
conversion accuracy for Japanese.

00:13:10.530 --> 00:13:14.750
At the feedback session yesterday,
we heard that it's important to many

00:13:14.750 --> 00:13:17.110
of you improvements in Arabic support.

00:13:17.290 --> 00:13:20.570
And I wanted to point out that
we've been working on improving

00:13:20.610 --> 00:13:22.460
our bidirectional text in MLTE.

00:13:22.710 --> 00:13:28.450
For instance, in Panther,
we improved how the character

00:13:28.910 --> 00:13:33.020
moves at the boundaries
between Roman and Arabic text.

00:13:33.020 --> 00:13:33.020
We're not there yet, we know,
but we are making progress.

00:13:33.540 --> 00:13:38.820
Also, as Mac OS X evolves,
we've been involved in

00:13:38.820 --> 00:13:41.100
the implementation of MLT.

00:13:41.100 --> 00:13:46.430
You heard at the conference that
Quick Draw APIs have been deprecated.

00:13:46.430 --> 00:13:52.000
We had removed that code path in MLT so
now that you get ATSUI and CG only.

00:13:52.000 --> 00:13:56.120
In addition,
we transitioned our implementation to use

00:13:56.120 --> 00:14:01.690
QuickTime importers so that now you have
a wider set of file formats that you can

00:14:01.690 --> 00:14:04.270
import into your the Maltese text area.

00:14:06.670 --> 00:14:08.840
And also we've been
working on performance.

00:14:09.030 --> 00:14:12.090
Performance, performance,
performance was our mantra

00:14:12.100 --> 00:14:13.760
during the Panther release.

00:14:13.920 --> 00:14:18.820
And what I show you on the screen
is some of the results that we

00:14:18.830 --> 00:14:24.000
have between improvements that
we have between 10.2 and 10.3.

00:14:24.050 --> 00:14:29.630
For instance, reading in a text document,
the performance of that

00:14:29.630 --> 00:14:32.200
operation is 400 times faster.

00:14:32.370 --> 00:14:35.420
Scrolling text is 250 times faster.

00:14:35.420 --> 00:14:39.990
And if you select all the text in
your document and change the style,

00:14:40.070 --> 00:14:42.260
it's 160 times faster.

00:14:42.260 --> 00:14:46.200
I want to point out that these
improvements are not only the result

00:14:46.260 --> 00:14:47.860
of the effort of the MLTE team.

00:14:47.970 --> 00:14:51.360
We work closely with the CG and
the ASUI folks and the rest

00:14:51.360 --> 00:14:53.300
of the engineers at Apple.

00:14:53.420 --> 00:14:56.080
So this is the result
of the combined effort.

00:14:56.080 --> 00:15:00.860
The performance improvement that you have
in the current Tiger build are very much

00:15:00.950 --> 00:15:03.860
comparable to the Panther GM results.

00:15:03.860 --> 00:15:06.260
And, and we've been working on that.

00:15:06.260 --> 00:15:08.840
So I do expect that by
the time we ship Tiger,

00:15:08.840 --> 00:15:11.040
those numbers are going
to look even better.

00:15:15.620 --> 00:15:17.260
That's old.

00:15:17.270 --> 00:15:18.100
What's new?

00:15:18.100 --> 00:15:19.500
What is new in Tiger?

00:15:19.500 --> 00:15:24.220
So I'm very happy to announce that
we were able to implement all of the

00:15:24.220 --> 00:15:27.660
commonly requested APIs in MLT for Tiger.

00:15:27.660 --> 00:15:29.940
So let me start on that list.

00:15:30.080 --> 00:15:33.080
First of all, we have undo groups.

00:15:33.190 --> 00:15:38.320
And what an undo group is basically
is a sequence of actions that are

00:15:38.320 --> 00:15:46.410
bracketed between a begin and an end
API so that you can give the illusion

00:15:46.410 --> 00:15:52.030
to your users when they go and click
on the undo item that all of those

00:15:52.030 --> 00:15:54.800
actions are undone as a single one.

00:15:54.940 --> 00:15:58.930
And the reason why that is
important to some of you is because

00:15:59.530 --> 00:16:03.210
some... There are situations
in which you want to initialize

00:16:03.210 --> 00:16:07.620
your text object with some text,
change the style, add some pictures,

00:16:07.710 --> 00:16:12.710
but then you want your user to undo
all of those operations as one.

00:16:12.960 --> 00:16:15.030
Take a look at the APIs that
are in the headers.

00:16:15.380 --> 00:16:24.650
There are also some related
APIs that are used so that you can

00:16:24.730 --> 00:16:27.900
correctly handle the undo menu or let
MLTE handle the undo menu correctly.

00:16:28.580 --> 00:16:30.740
Let's talk about scrolling.

00:16:30.790 --> 00:16:33.360
By default, MLTE scrolls.

00:16:33.420 --> 00:16:36.390
And some of you love it,
and some of you hate it.

00:16:36.490 --> 00:16:40.310
And the reason why some of you don't
like that default behavior is because

00:16:40.310 --> 00:16:42.840
it's not suited for your application.

00:16:42.880 --> 00:16:46.820
So let's say that you have an
application that writes status results

00:16:47.250 --> 00:16:50.100
to your text window as it runs.

00:16:50.160 --> 00:16:54.840
One of your users is looking at the
window and is reviewing the results.

00:16:54.850 --> 00:16:57.180
In the meantime,
the application is adding data

00:16:57.190 --> 00:16:59.360
to the bottom of your text area.

00:16:59.380 --> 00:17:01.020
Well, MLTE is going to scroll.

00:17:01.060 --> 00:17:04.730
And that might be a
disconcerting behavior.

00:17:05.010 --> 00:17:10.720
So for Tiger, we added some new tags that
you can control the scrolling

00:17:10.720 --> 00:17:12.100
behavior the way you like it.

00:17:12.220 --> 00:17:14.800
You can have it as it is by default.

00:17:14.910 --> 00:17:19.730
You can make MLTE behave like the
terminal in the scrolling behavior,

00:17:19.730 --> 00:17:25.000
or you can tell MLTE, don't scroll at all
until I ask you to do so.

00:17:25.750 --> 00:17:28.850
As I mentioned before,
if you're using HITextView,

00:17:28.850 --> 00:17:31.460
you get accessibility support for free.

00:17:31.500 --> 00:17:35.860
However, if you need to continue,
your application needs to

00:17:35.860 --> 00:17:41.410
work on back to Panther,
or for whatever other reason,

00:17:41.410 --> 00:17:46.500
and you want to continue
to use the MLTE API,

00:17:46.500 --> 00:17:48.350
we're providing you an API to add
accessibility support to your text areas.

00:17:49.690 --> 00:17:55.550
the TXN save and the TXN read
APIs were showing their age.

00:17:55.810 --> 00:17:58.120
They used some old data structures.

00:17:58.120 --> 00:18:04.120
On the one hand, on the other hand,
we wanted to add support for RTFD.

00:18:04.120 --> 00:18:07.990
We added support for RTF during
the bantered release.

00:18:08.120 --> 00:18:10.390
In JAGWARE,
we wanted to extend the support and

00:18:10.530 --> 00:18:14.250
be even more compatible with the
Cocoa stack and add RTFD support.

00:18:14.380 --> 00:18:17.440
In addition,
some of you have been asking for

00:18:17.440 --> 00:18:22.120
APIs that allow them to save and
retrieve information from memory.

00:18:22.200 --> 00:18:26.100
So for TIGER,
we added two APIs to read and

00:18:26.100 --> 00:18:31.190
write to CFData and two APIs to
read and write from CFURL.

00:18:31.320 --> 00:18:34.760
In addition,
there is an auxiliary API that allows you

00:18:34.760 --> 00:18:39.930
to decide what is the best file format
that you need to use in order to save

00:18:40.000 --> 00:18:42.880
your data without losing any information.

00:18:42.880 --> 00:18:46.260
And that is important, for instance,
if you want to decide whether to use

00:18:46.260 --> 00:18:49.720
RTF or whether to use RTF or plain text.

00:18:51.000 --> 00:18:56.260
Another API that we added, actually,
two APIs,

00:18:56.260 --> 00:19:00.540
we added to set and get the event target.

00:19:00.810 --> 00:19:04.520
There's been some confusion in
the past of where MLT installed

00:19:04.520 --> 00:19:08.930
their Carbon event handlers,
and so -- although I haven't seen

00:19:08.930 --> 00:19:14.050
any feedback on that area recently
-- there was an outstanding request

00:19:14.050 --> 00:19:19.150
for APIs that allow you to set
and get the target event -- the

00:19:19.150 --> 00:19:24.420
target for the Carbon events in MLT,
and those are there in MLT.

00:19:24.430 --> 00:19:28.810
We also added better ways for you
to turn on HI command handling,

00:19:28.960 --> 00:19:34.320
and I'm going to go in some detail on
the -- about those APIs in a minute.

00:19:36.930 --> 00:19:38.760
Two more things.

00:19:38.780 --> 00:19:44.640
We added support for spell checking,
and we added support for the font panel.

00:19:44.920 --> 00:19:49.760
So now, with very few lines of code,
spell checking is working

00:19:49.830 --> 00:19:51.480
in your text area.

00:19:51.630 --> 00:19:55.560
And with very few lines of code,
the font panel is also working.

00:19:55.700 --> 00:20:00.420
And not only the main font panel,
but the color subpanel,

00:20:00.420 --> 00:20:04.570
the character palette,
the typography panel.

00:20:04.770 --> 00:20:10.010
And if some of you have tried to do it,
that's quite a fair amount of work.

00:20:10.010 --> 00:20:10.010
So we have simplified
that implementation.

00:20:10.730 --> 00:20:11.540
All right.

00:20:11.540 --> 00:20:15.850
So two words of caution.

00:20:15.890 --> 00:20:19.900
One is as Steve mentioned,
we're showing you Tiger soon a

00:20:19.900 --> 00:20:22.180
lot earlier than other releases.

00:20:22.340 --> 00:20:26.240
So the APIs are there,
the basic implementation is there,

00:20:26.250 --> 00:20:27.710
but we're still working on that.

00:20:27.830 --> 00:20:32.700
So the second word that I wanna say is,
please give them a try.

00:20:32.980 --> 00:20:37.640
We've been implementing them
in response to your request.

00:20:37.680 --> 00:20:41.390
We love to hear what you have
to say and whether there are

00:20:41.390 --> 00:20:43.140
things that we need to tweak.

00:20:46.200 --> 00:20:51.200
So what I want now to do is
a more hands-on approach.

00:20:51.200 --> 00:20:54.200
I'm going to show you how to
build an HITex view to show you

00:20:54.240 --> 00:20:59.980
that even managers can do it,
and how to actually customize it,

00:20:59.980 --> 00:21:02.580
and then I'm going to move
on and give you some tips and

00:21:02.750 --> 00:21:06.040
tricks about optimization.

00:21:06.070 --> 00:21:08.640
So can I have the demo machine please?

00:21:08.720 --> 00:21:13.840
The other demo machine.

00:21:16.100 --> 00:21:19.220
Thank you.

00:21:19.380 --> 00:21:22.510
So I have Interface Builder running.

00:21:54.750 --> 00:21:55.800
Thank you.

00:21:56.040 --> 00:22:00.790
So I'm going to create a
Carbon app with the menu,

00:22:00.850 --> 00:22:02.460
made with the menu bar.

00:22:02.510 --> 00:22:07.690
And just for the purpose of this
demonstration so that you can

00:22:07.730 --> 00:22:12.850
see the contrast between the
background and the text area,

00:22:12.850 --> 00:22:15.290
I'm going to make it metal.

00:22:15.290 --> 00:22:21.550
And now I'm going to drag and drop
from the Carbon palette the text area.

00:22:21.550 --> 00:22:23.690
I'm going to resize it.

00:22:23.700 --> 00:22:23.880
Oops.

00:22:27.080 --> 00:22:28.940
Resize it.

00:22:28.960 --> 00:22:31.280
And I'm going to do one more thing.

00:22:31.310 --> 00:22:39.730
I'm going to give the TextView a
signature and an ID so that later on

00:22:39.730 --> 00:22:39.730
I can retrieve it in my application.

00:22:40.200 --> 00:22:44.660
I'm going to give it the signature text,
and the ID is 0.

00:22:44.690 --> 00:22:46.990
And I'm ready to go.

00:22:47.140 --> 00:22:54.590
So I have an HITextView with
an MLTE object inside it.

00:22:54.590 --> 00:22:54.590
And I can type.

00:22:54.710 --> 00:22:55.580
Maybe.

00:22:55.780 --> 00:23:01.770
I can switch to Japanese and
I can type Japanese,

00:23:02.140 --> 00:23:04.490
have written no line of code.

00:23:04.880 --> 00:23:12.680
I can bring up WordText and
I can copy and paste.

00:23:13.510 --> 00:23:19.920
So, all of that by just dragging
and dropping in a few clicks.

00:23:20.440 --> 00:23:23.680
So what, can I have these slides?

00:23:23.680 --> 00:23:24.820
Thanks.

00:23:24.840 --> 00:23:28.720
So that shows you how to
build your HITextView.

00:23:28.740 --> 00:23:32.260
But, and maybe the basic
functionality is all you need.

00:23:32.290 --> 00:23:34.640
But say that you need
to add some margins,

00:23:34.790 --> 00:23:38.310
you want to retrieve the text,
you want to add some

00:23:38.310 --> 00:23:40.620
text programmatically.

00:23:40.650 --> 00:23:45.730
Then in that case if you need
to customize your HITextView,

00:23:45.790 --> 00:23:48.560
you want to use the MLT APIs.

00:23:48.560 --> 00:23:52.800
And if you have been doing so,
that you can transition your creation

00:23:52.800 --> 00:23:57.100
of the text area to use HITextView and
then take advantage of all the

00:23:57.100 --> 00:23:59.310
other code that you already have.

00:24:01.300 --> 00:24:05.880
SO THIS IS MY DETOUR FOR THE FOLKS THAT
ARE NEW TO THIS AREA.

00:24:05.880 --> 00:24:09.800
SO LET ME -- I'M
GOING TO GIVE YOU SOME BASICS ABOUT MLT.

00:24:09.800 --> 00:24:11.200
IT IS VERY SIMPLE.

00:24:11.200 --> 00:24:16.530
MLT REPRESENTS YOUR TEXT AREA,
YOUR DOCUMENT WITH A TXN OBJECT,

00:24:16.530 --> 00:24:18.840
WHICH IS AN OPAQUE OBJECT.

00:24:18.840 --> 00:24:26.070
IT USES OBJECT-WIDE CONTROLS,
WHICH ARE CALLED OBJECT CONTROLS.

00:24:26.320 --> 00:24:32.820
AND MLT USES THE CONCEPT OF STYLE ATTRIB
UTES THAT ARE BY RAND.

00:24:32.820 --> 00:24:36.240
SO FOR INSTANCE,
YOU CAN HAVE YOUR TEXT IS DIVIDED IN CHUN

00:24:36.260 --> 00:24:36.560
KS.

00:24:36.620 --> 00:24:43.250
SO FOR OFFSET 0 TO OFFSET 10,
YOUR TEXT IS LUCIDA POINT SIZE 10 BLUE.

00:24:43.400 --> 00:24:49.030
FROM OFFSET 11 TO OFFSET 15
IS HOEFFLER TEXT POINT SIZE 18

00:24:49.160 --> 00:24:51.410
GREEN AND SO ON AND SO FORTH.

00:24:51.740 --> 00:24:55.900
Now another key concept to MLT is
Carbon Events and I wanted to

00:24:55.900 --> 00:24:58.080
say four things about that.

00:24:58.080 --> 00:25:03.160
The first one is if you're using an
HITax View MLT is going to install

00:25:03.160 --> 00:25:07.720
the Carbon event handlers on the
owning view and it's going to

00:25:07.880 --> 00:25:10.800
install all of them at creation time.

00:25:10.940 --> 00:25:13.760
Some of them are going to be turned on,
some are not going to

00:25:13.760 --> 00:25:15.400
be are going to be off.

00:25:15.600 --> 00:25:19.080
But the important point here is
they're all installed at the same time.

00:25:19.080 --> 00:25:22.730
The reason why that is important
so you have a good picture of where

00:25:22.730 --> 00:25:29.440
in the stack of your Carbon events
MLT has put its own event handlers.

00:25:29.560 --> 00:25:36.050
By default we turn on the input the
text input events so that you can type

00:25:36.090 --> 00:25:40.260
in using any of the input methods and
the document access events which are

00:25:40.310 --> 00:25:42.080
used by the input methods as well.

00:25:42.080 --> 00:25:46.620
In addition you can turn on
support for the HI commands

00:25:46.620 --> 00:25:50.860
whether it's for your edit menu,
for spell checking on the

00:25:50.860 --> 00:25:52.640
font or for the font panel.

00:25:52.680 --> 00:25:55.920
But those are off by default
and you can turn it on later.

00:25:55.920 --> 00:25:57.440
So that ends my detour.

00:25:57.440 --> 00:26:03.360
Now remember we had our HITax
View and I'm going to show you

00:26:03.360 --> 00:26:05.910
how to extract the MLT object.

00:26:06.080 --> 00:26:07.460
So here it is.

00:26:07.460 --> 00:26:12.110
First of all we have a constant
that allows us to identify that

00:26:12.220 --> 00:26:15.690
particular view in our hierarchy.

00:26:16.130 --> 00:26:19.300
After that,
I'm going to call some standard

00:26:19.300 --> 00:26:24.040
high-level toolbox APIs to find the
root of the hierarchy and extract the

00:26:24.150 --> 00:26:28.890
particular view that I'm interested in,
in this case, the HITextView.

00:26:28.940 --> 00:26:33.870
And once I have the HITextView,
I can call hiTextView getTxnObject,

00:26:33.870 --> 00:26:36.520
and that gives me the MLTE object.

00:26:36.540 --> 00:26:39.010
Now, I'm good to go.

00:26:39.920 --> 00:26:40.300
All right.

00:26:40.620 --> 00:26:46.100
So to show you how to use the MLTE APIs,
I'm going to--

00:26:47.720 --> 00:26:50.360
Demonstrate how you can
turn on spell checking.

00:26:50.450 --> 00:26:51.910
And it's going to be very simple.

00:26:52.030 --> 00:26:57.790
An MLT leverages the HICommand
support that we added for

00:26:58.190 --> 00:27:01.480
Tiger to turn on spell checking.

00:27:01.480 --> 00:27:04.500
So let me remind you
what are the HICommands.

00:27:04.500 --> 00:27:06.400
So we have two flavors of HICommands.

00:27:06.460 --> 00:27:11.410
HICommand process events,
which are the events that are

00:27:11.410 --> 00:27:16.560
sent when your user clicks on
a menu item or selects a menu

00:27:16.660 --> 00:27:19.240
item or clicks on a control.

00:27:19.240 --> 00:27:22.640
And then there are the
HIUpdate status events,

00:27:22.640 --> 00:27:26.810
which are the events that are
dispatched to your application

00:27:26.810 --> 00:27:29.280
when a UI element needs updating.

00:27:29.280 --> 00:27:33.600
For instance, before your menu comes up,
you get one of those events so that you

00:27:33.600 --> 00:27:40.590
have a chance to update the information
in the look of the items in your menu.

00:27:41.220 --> 00:27:46.890
We recommend that you handle all
of the HI commands for the menu,

00:27:47.100 --> 00:27:50.780
or none of them, to avoid compatibility
issues in the future.

00:27:50.880 --> 00:27:54.410
And that's actually the
way we did it for MLTE.

00:27:54.620 --> 00:27:59.890
So for Tiger, we are introducing the
TXN SetCommand event support,

00:27:59.890 --> 00:28:04.250
which allows you to turn on
and off support for basically

00:28:04.270 --> 00:28:09.220
three groups of HI commands:
for editing, for style checking,

00:28:09.300 --> 00:28:11.480
and for the font panel.

00:28:11.510 --> 00:28:18.090
And those three flavors work for
processing and update status.

00:28:18.240 --> 00:28:22.770
I'm not going to go through the
details that you see on the table,

00:28:22.800 --> 00:28:27.840
but suffice it to say that you have
three options that you can turn on,

00:28:27.840 --> 00:28:33.600
and those enable the handling
of the HI commands in MLTE.

00:28:33.930 --> 00:28:36.670
So for instance,
if you decide that you want

00:28:36.670 --> 00:28:40.780
MLTE to handle the edit
command processing events,

00:28:40.800 --> 00:28:45.390
MLTE will do so,
and it will handle the undo, redo,

00:28:45.390 --> 00:28:47.930
select all, and so on.

00:28:49.340 --> 00:28:51.340
Now, how do we turn spell checking on?

00:28:51.530 --> 00:28:52.960
Very simple.

00:28:53.070 --> 00:28:56.090
We set the options for the
HRI commands that we want,

00:28:56.090 --> 00:28:59.330
the spell checking in this case,
and then we call

00:28:59.330 --> 00:29:05.200
txnSetCommandEventSupport with the
MLTE object and the options that we set.

00:29:05.330 --> 00:29:06.200
And that's it.

00:29:06.200 --> 00:29:09.940
From that point on,
spell checking is going to work.

00:29:10.110 --> 00:29:14.120
Now, what is it going to--what is it that
you're going to see in your application

00:29:14.120 --> 00:29:15.960
when you turn spell checking on?

00:29:16.050 --> 00:29:18.140
So if you have misspells,
they're going to show up

00:29:18.140 --> 00:29:19.900
as red dotted underlines.

00:29:20.030 --> 00:29:22.780
In addition,
we provide a contextual support

00:29:22.780 --> 00:29:27.070
for the contextual menu,
and we added some APIs so that

00:29:27.130 --> 00:29:33.200
you can modify the content of that
contextual menu if you choose to.

00:29:33.370 --> 00:29:35.990
So MLTE is going to handle
the contextual menu,

00:29:36.140 --> 00:29:38.720
but we're going to give you a
choice to modify it as you need.

00:29:38.720 --> 00:29:43.620
And also, we provide support for
the spelling panel.

00:29:43.620 --> 00:29:48.210
So if the HRI command for
the spelling panel is sent,

00:29:48.210 --> 00:29:51.870
MLTE will react to that and show
the spelling panel so that your

00:29:52.000 --> 00:29:57.590
users can select the dictionary,
learn a new word, spelling, and so on.

00:29:57.600 --> 00:30:02.680
If that looks familiar to you,
that is because we implemented

00:30:02.680 --> 00:30:04.310
the same UI as Cocoa.

00:30:04.660 --> 00:30:07.930
So we were talking about the
consistency between Carbon and Cocoa,

00:30:07.930 --> 00:30:11.260
and we wanted to, you know, enrich that.

00:30:11.730 --> 00:30:18.280
So the UI is exactly the same.

00:30:18.330 --> 00:30:18.480
You use the same spell checking
engine and the same set of

00:30:18.610 --> 00:30:20.910
to be able to dictionize.

00:30:22.510 --> 00:30:23.240
All right.

00:30:23.350 --> 00:30:28.930
So with that, I showed you how to
create your HITextView,

00:30:29.150 --> 00:30:32.170
how to extract the MLTE object,
how to customize it.

00:30:32.490 --> 00:30:35.560
Now,
as important as that to use the APIs,

00:30:35.560 --> 00:30:39.270
it's important also that
you use them correctly.

00:30:39.330 --> 00:30:44.690
And I'm going to give you some tips that
we learned over the recent months by

00:30:44.690 --> 00:30:50.620
working with developers and analyzing
the performance of their application.

00:30:50.620 --> 00:30:50.620
So the first one is,

00:30:50.940 --> 00:30:54.760
There are cases in which you
don't need all of the rich

00:30:54.760 --> 00:30:57.160
style text that MLT supports.

00:30:57.370 --> 00:30:59.600
What you really need is mono style text.

00:30:59.600 --> 00:31:03.050
In that case we recommend you
use KTXN mono style text mask

00:31:03.240 --> 00:31:04.520
when you create your object.

00:31:04.730 --> 00:31:09.570
That allows us to optimize the break
line operations because the height,

00:31:09.670 --> 00:31:12.280
the height of the text is constant.

00:31:12.280 --> 00:31:17.540
For Tiger we introduced the
KTXN disable layout and draw tag,

00:31:17.540 --> 00:31:21.680
which is useful when you
do multiple sequential

00:31:21.680 --> 00:31:23.720
modifications to your MLT object.

00:31:23.860 --> 00:31:27.400
So basically what you want to do
is you want to set the mask on,

00:31:27.400 --> 00:31:30.080
modify your object, turn it off and draw.

00:31:30.240 --> 00:31:37.200
And that way MLT will not draw and
break lines in between operations.

00:31:37.200 --> 00:31:42.080
That is the same behavior
as the KTXN visibility tag.

00:31:42.080 --> 00:31:47.630
But the name was really confusing so
we decided to introduce a tag that

00:31:47.630 --> 00:31:50.480
has a name for what it really does.

00:31:50.480 --> 00:31:57.330
If your text ends with carriage returns
then you want to use the KTXN word

00:31:57.330 --> 00:32:00.840
wrap state tag and set it to not wrap.

00:32:01.080 --> 00:32:05.190
That way we can avoid doing
unnecessary line breaks,

00:32:05.240 --> 00:32:11.880
which could be an expensive operation
in the case of Unicode and text.

00:32:11.880 --> 00:32:17.220
As important as the do tips are
the things that you should not do.

00:32:17.480 --> 00:32:23.770
The model in MLT and HA TextView is
that MLT reacts to changes

00:32:23.970 --> 00:32:26.680
to the object by redrawing.

00:32:26.920 --> 00:32:32.760
So in most cases you do
not need to call TXN draw.

00:32:33.080 --> 00:32:40.110
One exception is if you use the
TXN disable layout and draw tag after

00:32:40.110 --> 00:32:41.680
you re-enable layout and draw tag.

00:32:41.680 --> 00:32:44.980
You want to call TXN draw.

00:32:44.980 --> 00:32:47.980
And that is because that was
implemented a long time ago that

00:32:48.280 --> 00:32:52.200
way and we didn't want to change
it to avoid performance impact.

00:32:52.780 --> 00:32:56.330
Also, unless you really do need it,
do not use the

00:32:56.330 --> 00:33:00.660
KTXN Always Rapid View Edge mask.

00:33:00.720 --> 00:33:04.710
What that mask does is keeps your
destination rectangle of your text

00:33:05.120 --> 00:33:07.180
pinned to the view rect of your window.

00:33:07.200 --> 00:33:11.150
So as you resize your window, your text,
we're crazily breaking lines

00:33:11.150 --> 00:33:13.170
and redrawing your text.

00:33:13.300 --> 00:33:15.620
And that, sometimes,
is not the behavior you want.

00:33:15.620 --> 00:33:16.850
So keep an eye on that.

00:33:16.860 --> 00:33:18.820
If you need it, feel free to use it.

00:33:18.820 --> 00:33:21.500
We improved the performance
of that operation quite a bit.

00:33:21.890 --> 00:33:24.580
But if you didn't need it, don't set it.

00:33:24.580 --> 00:33:25.580
All right.

00:33:25.620 --> 00:33:30.580
And with that, I'm going to give you a
quick demo of the KTXN.

00:33:35.570 --> 00:33:38.520
The new APIs working on Tiger.

00:33:38.620 --> 00:33:41.890
Let me clean up.

00:33:42.540 --> 00:33:45.840
So what I have here is MLTE Showcase.

00:33:45.950 --> 00:33:48.940
That's an application
that we put together.

00:33:48.940 --> 00:33:52.500
One of the engineers in
the team wrote for WWDC.

00:33:52.520 --> 00:33:54.380
You have it in your SDK.

00:33:54.550 --> 00:33:56.550
Feel free to play with
it and give us feedback.

00:33:56.790 --> 00:34:03.190
So what you see is the large text area
is an HITextView with an MLTE object.

00:34:03.430 --> 00:34:07.460
The small text area on top
of that is a Unicode control,

00:34:07.460 --> 00:34:11.830
and we put some radio buttons to control
the behavior because one of the feedbacks

00:34:11.930 --> 00:34:16.730
that we heard is that you want to be
able to manage the behavior of your

00:34:16.730 --> 00:34:21.480
text objects from any kinds of controls,
not only from menus.

00:34:21.480 --> 00:34:26.480
So the first thing I'm going to do is
I'm going to turn on spell checking,

00:34:26.800 --> 00:34:30.480
and I am going to start typing.

00:34:30.480 --> 00:34:35.430
And I have practiced this so well
that I cannot make a typing mistake.

00:34:35.480 --> 00:34:36.450
There you are.

00:34:36.450 --> 00:34:40.680
So as I type,
the red dotted underline comes up,

00:34:40.800 --> 00:34:44.620
and all of the lines, of course,
are the code that have been executed

00:34:44.620 --> 00:34:46.390
as the one that I showed you.

00:34:46.390 --> 00:34:51.460
We don't have contextual menus still
working yet in this application,

00:34:51.460 --> 00:34:53.470
but it will be there soon.

00:34:53.640 --> 00:34:57.460
And there it is.

00:34:57.490 --> 00:35:00.510
Okay, let me move on to the font panel.

00:35:01.460 --> 00:35:06.380
And I'm going to select this paragraph.

00:35:06.680 --> 00:35:10.190
I'm going to change the font.

00:35:11.500 --> 00:35:17.400
[Transcript missing]

00:35:33.600 --> 00:35:37.320
As you see,
I have all of the different options for

00:35:37.420 --> 00:35:42.820
changing the style from the font panel,
working with MLTE objects.

00:35:42.910 --> 00:35:51.770
I can even bring up the color
palette and change the color.

00:35:51.770 --> 00:35:51.770
I can

00:35:52.260 --> 00:35:53.620
Strike through?

00:35:53.780 --> 00:35:54.640
I can underline.

00:35:54.950 --> 00:35:57.400
So all of the different
palettes just work.

00:35:57.690 --> 00:36:04.780
And again, this is by turning off the
HI command event support in MLTE.

00:36:05.030 --> 00:36:11.560
We have here a way to show
you how the undo groups work,

00:36:11.560 --> 00:36:15.390
but I'm not going to have
time to go into that.

00:36:15.460 --> 00:36:20.060
And so let me just show you
the no scrolling in action.

00:36:20.060 --> 00:36:21.700
So let me copy, copy.

00:36:22.420 --> 00:36:23.530
All right.

00:36:23.600 --> 00:36:25.360
Never mind.

00:36:25.470 --> 00:36:27.600
As I said, this is work in progress.

00:36:27.730 --> 00:36:34.710
Let me copy the text,
and let me put my instruction

00:36:34.710 --> 00:36:34.710
point at the bottom.

00:36:35.400 --> 00:36:36.700
And now I'm going to paste it.

00:36:36.980 --> 00:36:41.030
And as you see, as I paste the text,
MLT is going to scroll.

00:36:41.220 --> 00:36:44.540
So now I'm going to turn no scrolling.

00:36:44.620 --> 00:36:46.680
And I'm going to start pasting.

00:36:46.700 --> 00:36:48.060
Nothing happens.

00:36:48.070 --> 00:36:52.820
As you see,
the scroll bar is getting smaller,

00:36:52.820 --> 00:36:56.750
because the size of my
text object is increasing.

00:36:57.000 --> 00:37:01.660
And actually, the text is being pasted at
the bottom of the object.

00:37:02.000 --> 00:37:05.280
But there is no scrolling, actually.

00:37:05.280 --> 00:37:08.140
Next to Write Your Buttons is
going to show you how to use

00:37:08.140 --> 00:37:10.520
reading and writing to a CFURL.

00:37:10.520 --> 00:37:14.040
And you can take a look at that and,
again, give us feedback.

00:37:14.070 --> 00:37:17.520
And with that,
I'm going to end up the MLT session.

00:37:17.520 --> 00:37:20.940
And I'm going to turn the
presentation to Tom Madden.

00:37:20.940 --> 00:37:22.680
Thank you.

00:37:23.300 --> 00:37:24.720
How's everybody doing?

00:37:24.720 --> 00:37:26.360
Good conference?

00:37:26.530 --> 00:37:27.840
So my name's Tom Madden.

00:37:27.840 --> 00:37:30.340
I'm an engineer.

00:37:30.340 --> 00:37:33.780
And I've been working at
SUI for a little while now.

00:37:33.780 --> 00:37:35.260
Well, let's get started.

00:37:36.120 --> 00:37:37.260
ATSUI is an acronym.

00:37:37.260 --> 00:37:41.100
It stands for Apple Type Services for
Unicode Imaging.

00:37:41.100 --> 00:37:45.320
Today I'm going to cover kind of
what it is and why you should use it.

00:37:45.410 --> 00:37:48.220
I'm going to cover some
basic ATSUI constructs,

00:37:48.220 --> 00:37:51.930
some things you would need to
know to get started using ATSUI.

00:37:51.940 --> 00:37:54.760
I'm going to cover how
to do some line breaking,

00:37:54.990 --> 00:37:55.470
drawing.

00:37:55.470 --> 00:37:58.360
Then I'm going to cover
some advanced features,

00:37:58.360 --> 00:38:01.800
and I'm going to give you some
performance tips for those of

00:38:01.800 --> 00:38:03.810
you who are considering using
ATSUI or have already adopted it.

00:38:04.070 --> 00:38:06.900
So without further ado, what is ATSUI?

00:38:07.010 --> 00:38:11.420
Well, ATSUI is the low-level
Unicode layout engine.

00:38:11.430 --> 00:38:17.350
ATSUI is used by all those things that
Giulia just showed to actually take

00:38:17.540 --> 00:38:23.520
the Unicode text that's used as an
input and display it on the screen.

00:38:23.540 --> 00:38:26.880
ATSUI provides layout
services for all those things,

00:38:26.930 --> 00:38:29.680
plus it provides some
services for AppKit.

00:38:29.680 --> 00:38:33.900
It provides services for Safari and
a whole bunch of other apps.

00:38:35.970 --> 00:38:38.010
So you might be asking yourself,
what is layout?

00:38:38.200 --> 00:38:40.350
We've been using the word
"layout" the whole presentation.

00:38:40.420 --> 00:38:42.480
Some of you may or may
not know what it is.

00:38:42.540 --> 00:38:45.810
Well, layout is simply the process
of taking the Unicode text and

00:38:46.250 --> 00:38:50.620
converting it to glyphs and positions,
which get then fed into the

00:38:50.620 --> 00:38:52.620
Quartz rendering engine.

00:38:52.660 --> 00:38:57.560
The glyphs and the positions
are determined by two things.

00:38:57.560 --> 00:39:00.840
First of all, the layout tables that
are embedded in the font.

00:39:00.860 --> 00:39:03.870
atsui supports OpenType
font layout tables,

00:39:04.000 --> 00:39:09.390
which are the gpos and the gsub table,
as well as the aatfont layout tables.

00:39:09.550 --> 00:39:11.680
It's always supported those.

00:39:11.720 --> 00:39:16.330
In addition to the layout tables,
it also requires character properties.

00:39:16.540 --> 00:39:20.390
Unicode has a great character properties
database where it can find all sorts

00:39:20.460 --> 00:39:22.410
of information about the characters.

00:39:22.520 --> 00:39:26.920
So it takes those two bits of data,
munches them together,

00:39:26.970 --> 00:39:29.720
and out come the glyphs
and the positions.

00:39:33.040 --> 00:39:35.450
Besides the standard
character to glyph mapping,

00:39:35.540 --> 00:39:38.990
reordering and stuff like that
that's required by layout,

00:39:39.000 --> 00:39:41.370
Atsui also does a couple other things.

00:39:41.500 --> 00:39:44.620
The first is automatic font substitution.

00:39:44.700 --> 00:39:51.190
Automatic font substitution allows
Atsui to substitute a new font should

00:39:51.200 --> 00:39:56.870
the font that you have selected
not be able to map the characters

00:39:57.180 --> 00:40:00.040
that the user has input into Atsui.

00:40:00.150 --> 00:40:04.550
So for instance,
let's say you have selected

00:40:04.710 --> 00:40:09.690
Times New Roman and then the
user has input a Japanese text.

00:40:10.760 --> 00:40:14.560
Times New Roman can't display Japanese,
so ATSUI will go out and

00:40:14.560 --> 00:40:18.760
substitute a new font for it,
most likely Hiragino.

00:40:20.300 --> 00:40:23.360
Additionally,
ATSUI provides API for style management.

00:40:23.360 --> 00:40:31.200
There's an ATSUI style object,
which I'll get into in a minute.

00:40:31.200 --> 00:40:38.370
It provides API for line breaking,
which can be pretty tricky

00:40:38.370 --> 00:40:38.370
in the case of Unicode.

00:40:38.370 --> 00:40:38.370
And it also provides API to help
you if you had an editable document.

00:40:40.820 --> 00:40:43.740
So you've seen all the
stuff that Julia has.

00:40:43.740 --> 00:40:47.320
You've seen the MLTE.

00:40:47.320 --> 00:40:48.980
You've seen the HITextView.

00:40:48.990 --> 00:40:52.460
You might be asking yourself,
why should you use ATSUI directly?

00:40:52.460 --> 00:40:57.220
Well, if you need the ultimate
control over the text,

00:40:57.220 --> 00:40:58.800
you would use ATSUI.

00:40:58.800 --> 00:41:01.400
With ATSUI,
you can control the line breaks.

00:41:01.400 --> 00:41:05.900
You can control the exact
position of the text.

00:41:05.900 --> 00:41:10.590
You can even go into the glyphs and
change their positions directly.

00:41:10.600 --> 00:41:13.930
In addition, ATSUI provides broader
options for tracking,

00:41:13.930 --> 00:41:18.080
justification, kerning, flushness,
and all this other stuff that

00:41:18.080 --> 00:41:19.980
you may want to control directly.

00:41:19.980 --> 00:41:22.720
In addition,
if you have custom rendering paths,

00:41:22.750 --> 00:41:28.850
such as you want to go out to, say,
an OpenGL context or something like that,

00:41:28.850 --> 00:41:31.120
you may want to use ATSUI as well.

00:41:31.120 --> 00:41:36.200
What ATSUI will also get you,
switching to ATSUI directly, is speed.

00:41:36.200 --> 00:41:39.430
In a sense,
those APIs that Julia mentioned and a

00:41:39.460 --> 00:41:42.670
lot of the other APIs in the system,
their whole purpose is to feed

00:41:42.680 --> 00:41:47.480
ATSUI Unicode text and to manage
the ATSUI objects for you.

00:41:47.540 --> 00:41:49.750
But if you can do a
better job at doing that,

00:41:49.760 --> 00:41:56.980
then you will get faster operations,
because these objects, in some cases,

00:41:57.070 --> 00:42:00.630
were designed for a more general case.

00:42:03.940 --> 00:42:07.180
So you've decided, OK,
I need to use ATSUI.

00:42:07.180 --> 00:42:15.570
So what do you need to
know to get started?

00:42:15.570 --> 00:42:15.570
Well, the first is you need
to know about Unicode.

00:42:17.060 --> 00:42:23.000
The Unicode text buffer that you provide
to ATSUI must be in the UTF-16 format.

00:42:23.020 --> 00:42:27.000
ATSUI doesn't accept UTF-8,
doesn't accept UTF-32,

00:42:27.050 --> 00:42:29.200
only accepts UTF-16.

00:42:29.230 --> 00:42:33.020
You can get your text in the
UTF-16 format using CFString or

00:42:33.020 --> 00:42:34.940
Text Encoding Converter,
whatever.

00:42:34.940 --> 00:42:38.440
It just has to be in UTF-16 format.

00:42:38.460 --> 00:42:43.430
The second thing that's very important
is that you own the text buffer.

00:42:43.790 --> 00:42:46.430
You can't free the text
buffer out from ATSUI.

00:42:46.800 --> 00:42:48.460
If you do that, bad things will happen.

00:42:48.460 --> 00:42:50.700
ATSUI does not retain the text buffer.

00:42:50.730 --> 00:42:52.410
ATSUI doesn't do anything like that.

00:42:52.540 --> 00:42:53.460
You manage it.

00:42:53.460 --> 00:42:54.100
You own it.

00:42:54.350 --> 00:43:00.520
And likewise, if you should change any of
the text in that text buffer,

00:43:00.580 --> 00:43:02.940
you have to notify ATSUI.

00:43:02.940 --> 00:43:07.500
So if you insert text, delete text,
move the buffer around,

00:43:07.500 --> 00:43:07.500
you have to call an API,
which I'll show you in a minute.

00:43:08.800 --> 00:43:12.160
Finally,
one important note that has tripped

00:43:12.160 --> 00:43:21.310
up more than one person is that
the character to glyph mapping

00:43:21.310 --> 00:43:22.710
is not necessarily one-to-one,
even in the case of simple

00:43:22.710 --> 00:43:22.710
ASCII English/Roman text.

00:43:22.830 --> 00:43:28.740
So, one of the most blatant
examples is the FI ligature.

00:43:28.740 --> 00:43:31.250
You have an F character
and an I character,

00:43:31.250 --> 00:43:33.580
which combine to form a single glyph.

00:43:33.600 --> 00:43:42.530
And so if your code makes
assumptions that there will be

00:43:42.530 --> 00:43:43.050
one character for one glyph,
it will break in a lot of cases.

00:43:44.380 --> 00:43:46.380
So you have your Unicode Text Buffer.

00:43:46.380 --> 00:43:47.620
It's in UTF-16.

00:43:47.620 --> 00:43:48.540
It's ready to go.

00:43:48.800 --> 00:43:50.630
You want to do something with it.

00:43:50.630 --> 00:43:52.300
So what do you do with it?

00:43:52.330 --> 00:43:58.720
The first thing you have to
do is tell ATSUI where it is.

00:43:58.720 --> 00:44:03.810
And you do that by creating
an ATSU Text Layout.

00:44:03.810 --> 00:44:03.810
The ATSU Text Layout is simply an object
that references your Unicode Text Buffer.

00:44:04.490 --> 00:44:10.930
Inside that ATSUI Text Layout,
it also tracks the style assignments.

00:44:11.290 --> 00:44:14.220
So you take a range of that buffer
and you assign it to Helvetica,

00:44:14.320 --> 00:44:17.440
you assign it to Times,
you assign it to different

00:44:17.440 --> 00:44:19.420
fonts or different styles.

00:44:19.420 --> 00:44:24.020
It also tracks the line breaks,
it tracks the font fallbacks,

00:44:24.020 --> 00:44:28.260
which allow you to customize
that font substitution behavior

00:44:28.380 --> 00:44:30.530
that I talked about earlier.

00:44:30.530 --> 00:44:34.130
And it also tracks the tab
rulers and the tab stops.

00:44:36.480 --> 00:44:40.550
You modify this Hatsutext layout by
setting layout and line controls on it,

00:44:40.550 --> 00:44:43.370
and there's a couple APIs that
allow you to do that.

00:44:43.400 --> 00:44:46.230
And finally,
and perhaps most importantly,

00:44:46.230 --> 00:44:49.770
the Hatsutext layout will store
the cached lines of glyphs.

00:44:49.860 --> 00:44:53.740
And so if you're constantly creating
these things and throwing them out,

00:44:53.740 --> 00:44:58.920
you're going to get rid of a lot of work,
and your application will run slower,

00:44:58.920 --> 00:45:03.090
because that whole layout process
that I had that graphic up there for,

00:45:03.120 --> 00:45:06.620
that can be an expensive process,
because it has to read in font

00:45:06.620 --> 00:45:08.880
tables and interpret the characters.

00:45:08.880 --> 00:45:12.530
If you throw that work out
and have to recreate it,

00:45:12.880 --> 00:45:15.710
your application is doing
a lot of extra work.

00:45:18.970 --> 00:45:22.180
So to create an ATSU text layout,
it's pretty simple.

00:45:22.210 --> 00:45:24.710
We have an API called
ATSU Create Text Layout.

00:45:24.770 --> 00:45:28.270
You just call ATSU Create Text Layout,
and you have a layout.

00:45:28.350 --> 00:45:28.860
It's empty.

00:45:29.060 --> 00:45:30.350
It doesn't do anything yet.

00:45:30.550 --> 00:45:32.760
So you have to assign some text to it.

00:45:32.810 --> 00:45:36.240
We have an API called
ATSU Set Text Pointer Location.

00:45:36.280 --> 00:45:39.960
You call that to set-- you
could assign the buffer to it.

00:45:40.000 --> 00:45:43.470
And then finally,
we always recommend that you call

00:45:43.470 --> 00:45:45.680
ATSU Set Transient Font Matching.

00:45:45.720 --> 00:45:48.180
This will turn on the font
substitution behavior,

00:45:48.180 --> 00:45:50.440
as I described before.

00:45:50.460 --> 00:45:52.810
It's off by default.

00:45:53.950 --> 00:45:56.640
If you don't turn this on,
what will happen is,

00:45:56.820 --> 00:46:00.110
if you should encounter some
text that your currently

00:46:00.240 --> 00:46:04.380
selected font can't render,
you'll get ugly little boxes,

00:46:04.380 --> 00:46:06.180
and that's not pretty.

00:46:08.010 --> 00:46:13.190
So you have your ATSU text layout,
it's kind of boring.

00:46:13.220 --> 00:46:14.680
It doesn't really do anything yet.

00:46:14.680 --> 00:46:18.300
In fact, if you try and pass it to a
draw API or a measurement API,

00:46:18.300 --> 00:46:21.720
you'll get an error because it
doesn't know what to do yet.

00:46:21.750 --> 00:46:26.000
So to make it much more useful,
you have to assign a font to it.

00:46:26.010 --> 00:46:27.860
You have to assign some style to it.

00:46:27.890 --> 00:46:30.040
And so you do that with
the ATSU style object,

00:46:30.040 --> 00:46:34.120
which is simply a collection
of the stylistic attributes.

00:46:34.130 --> 00:46:38.110
It's the font, the color, the point size,
all this stuff that you want to

00:46:38.490 --> 00:46:40.380
kind of stylize the text with.

00:46:40.420 --> 00:46:43.000
You take that ATSU style and
you assign it to a range of text

00:46:43.000 --> 00:46:45.180
within that ATSU text layout.

00:46:45.200 --> 00:46:50.170
Now an important point is that once
it's assigned to an ATSU text layout,

00:46:50.330 --> 00:46:53.900
you can go ahead and assign it to as
many other ATSU text layouts as you want.

00:46:53.910 --> 00:46:58.900
It's not tied to any
specific text layout.

00:46:59.110 --> 00:47:00.720
You can reuse it over and over again.

00:47:00.740 --> 00:47:07.700
In fact, that's recommended because
you'll be creating fewer objects.

00:47:09.000 --> 00:47:13.820
So to create an ATSU text style,
the first thing you do is

00:47:13.900 --> 00:47:17.020
you call @SU_CREATE_STYLE.

00:47:17.200 --> 00:47:18.890
and that creates a blank style.

00:47:18.900 --> 00:47:21.000
It's set up with all the defaults.

00:47:21.040 --> 00:47:22.720
In fact, you can use it right away.

00:47:22.720 --> 00:47:24.710
It's just maybe not what you want.

00:47:24.720 --> 00:47:30.800
I think it's set up with Helvetica,
12-point, and a couple other defaults.

00:47:30.930 --> 00:47:36.860
So to get it into a shape that you
would want to be able to use it in,

00:47:36.860 --> 00:47:39.860
you have to set some attributes to it.

00:47:39.920 --> 00:47:44.010
Here I'm setting the font tag,
which will set a font,

00:47:44.130 --> 00:47:49.250
a specific font to that style,
and a size tag, which will set a specific

00:47:49.250 --> 00:47:50.380
size to that style.

00:47:50.380 --> 00:47:53.830
Once I have the tag set up,
I call atsu set attributes

00:47:53.840 --> 00:47:58.190
with the tags and the values,
and that will set everything up,

00:47:58.420 --> 00:47:59.210
and it'll be ready to go.

00:48:01.850 --> 00:48:05.830
So once you have your ATSUI style set up,
you assign it to the text layout

00:48:06.370 --> 00:48:10.880
to arrange in the text layout
using ATSUI's set run style.

00:48:13.120 --> 00:48:15.620
So your text layout is all ready to go.

00:48:15.680 --> 00:48:20.400
You have the style set,
you have all the text in it,

00:48:20.420 --> 00:48:21.760
but there's one problem.

00:48:21.840 --> 00:48:23.940
It's all one line.

00:48:23.960 --> 00:48:29.600
And so for some folks that may be OK,
but if you have an application that

00:48:29.600 --> 00:48:34.760
requires line wrapping or line breaking,
you need to call Atsui to do

00:48:35.010 --> 00:48:36.840
the line breaking for you.

00:48:36.840 --> 00:48:39.880
Atsui has two line breaking APIs.

00:48:39.890 --> 00:48:45.320
One is called Atsui Batch Breaklines,
and that's an API that is optimized

00:48:46.110 --> 00:48:50.100
for breaking constant width lines.

00:48:50.120 --> 00:48:52.510
And so for instance,
if you were breaking inside a

00:48:52.510 --> 00:48:56.020
rectangle or if you were breaking
down a constant width barrier,

00:48:56.020 --> 00:48:58.420
you could use Atsui Batch Breaklines.

00:48:58.430 --> 00:49:05.380
Atsui Breakline could be used
for the situation pictured above,

00:49:05.660 --> 00:49:08.520
where you would want
to vary the line width.

00:49:09.200 --> 00:49:11.430
In this case,
we're trying to wrap around an object,

00:49:11.430 --> 00:49:16.400
so the line widths on this
side are a little shorter

00:49:16.400 --> 00:49:18.370
than the line widths below.

00:49:20.400 --> 00:49:24.130
So, ATSUI Batch Breaklines sets
multiple breaklines at once,

00:49:24.130 --> 00:49:26.780
and it requires that you
have a constant width,

00:49:26.780 --> 00:49:29.000
and so if you're breaking into a box.

00:49:30.370 --> 00:49:32.800
Atsu batch breaklines is used simple.

00:49:32.800 --> 00:49:36.340
The first thing we recommend is that
you set the width in the object.

00:49:36.610 --> 00:49:43.610
You can specify a width to
the batch breaklines API,

00:49:43.710 --> 00:49:48.410
but the problem is that width
is only used for line breaking.

00:49:48.410 --> 00:49:48.410
So if you go and apply a flushness
or a centering or some other

00:49:49.020 --> 00:49:53.140
"If you have an API that
requires a width,

00:49:53.210 --> 00:49:54.340
that width won't apply.

00:49:54.540 --> 00:49:56.900
So you would need to go
and set the width anyway.

00:49:56.900 --> 00:49:59.660
So we recommend you just do it before.

00:49:59.700 --> 00:50:05.040
So you do @susetlayoutcontrols
with that width,

00:50:05.090 --> 00:50:10.170
and then you simply
call @subatchbreaklines,

00:50:10.170 --> 00:50:10.590
and it'll go down and set all the line
breaks to that width you've specified."

00:50:13.760 --> 00:50:16.270
If you need to do
non-constant width breaking,

00:50:16.270 --> 00:50:26.060
if you need to vary the line width,
if you need to do other things like that,

00:50:26.060 --> 00:50:26.370
we have the ATSUI Breakline API,
and that will let you set the

00:50:26.370 --> 00:50:26.370
width for every operation.

00:50:26.680 --> 00:50:29.540
An important thing here is
to let ATSUI set the line

00:50:29.640 --> 00:50:31.260
break once it's found it.

00:50:31.330 --> 00:50:35.400
ATSU break line can be used in a mode
where it can just find the break for you,

00:50:35.400 --> 00:50:38.140
which may be what you want.

00:50:38.310 --> 00:50:41.570
But it's recommended that you let
ATSUI set the break once it's found it,

00:50:41.570 --> 00:50:44.180
and you do that by
passing in a parameter,

00:50:44.180 --> 00:50:46.250
which I'll show you in a minute.

00:50:46.280 --> 00:50:49.790
This is important because if you
don't let ATSUI set the break,

00:50:49.790 --> 00:50:55.780
it will have to go back and re-figure
out that break when you go and set it.

00:50:55.780 --> 00:50:57.100
So you'll throw out a little bit of work.

00:50:58.730 --> 00:51:03.230
So this code up here does the
same exact code as the batch break

00:51:03.230 --> 00:51:05.260
lines example that I showed you.

00:51:05.310 --> 00:51:07.670
It just uses the break line API.

00:51:07.810 --> 00:51:11.470
So like before, the first thing you do is
you set the line width.

00:51:11.570 --> 00:51:14.230
In this case,
we're using a constant width.

00:51:14.300 --> 00:51:18.440
The next thing you'll probably want to
do is get the character count so you

00:51:18.560 --> 00:51:20.950
know where to stop breaking the lines.

00:51:20.950 --> 00:51:23.610
You set the break to
start at the beginning.

00:51:23.610 --> 00:51:28.290
Then you call atsu break line in a loop
until it's consumed all the characters.

00:51:30.920 --> 00:51:32.520
So the next thing you'll
probably want to do is,

00:51:32.520 --> 00:51:35.490
now that you have your
nice ATSUI text layout,

00:51:35.490 --> 00:51:38.610
you have all the lines broken,
you have all the styles assigned,

00:51:38.610 --> 00:51:40.690
is that you'll probably want to draw it.

00:51:40.800 --> 00:51:45.500
AtSUI has a function called @SUDrawText,
and the important point here

00:51:45.500 --> 00:51:50.870
is it draws one line at a time.

00:51:50.870 --> 00:51:50.870
So you'll have to draw
those lines individually.

00:51:51.550 --> 00:51:56.540
You should always specify a CG context,
and you do that via a text or a line

00:51:56.540 --> 00:52:03.900
layout option or a line or a text
layout option in the ATSUI text layout.

00:52:04.220 --> 00:52:12.490
You do ATSUI set layout
attributes with the CG context,

00:52:12.490 --> 00:52:12.490
and then it'll be set in the text layout.

00:52:12.890 --> 00:52:17.700
The reason why you do that,
because if you don't set a text layout,

00:52:17.700 --> 00:52:20.590
ATSUI has a quick draw fallback mode.

00:52:20.940 --> 00:52:26.560
And so if you don't set a CG context,
it'll have to go through and

00:52:26.850 --> 00:52:32.280
look up a CG context for you
from the current quick draw port,

00:52:32.280 --> 00:52:35.640
which is a very expensive operation.

00:52:35.640 --> 00:52:35.640
So if you set that CG context beforehand,
you'll avoid all that work.

00:52:35.860 --> 00:52:39.420
Another important thing to remember
when you draw text is that you

00:52:39.480 --> 00:52:41.420
need to flush the CG context.

00:52:41.420 --> 00:52:45.970
If you don't flush the CG context,
you probably won't see anything.

00:52:46.490 --> 00:52:49.400
"But you should only flush it once.

00:52:49.400 --> 00:52:52.600
And so if you're drawing a
whole paragraph worth of text,

00:52:52.930 --> 00:52:57.150
you want to flush it after
you've drawn all the lines."

00:53:02.470 --> 00:53:04.380
So some of you have needs.

00:53:04.620 --> 00:53:08.320
You're writing a text editor,
you're writing an application

00:53:08.320 --> 00:53:10.040
that has editable text.

00:53:10.080 --> 00:53:13.040
You'll need to use some editing APIs.

00:53:13.040 --> 00:53:15.610
ATSUI has hit testing
and cursor handling APIs.

00:53:15.650 --> 00:53:17.670
I'm not going to go through those.

00:53:17.840 --> 00:53:22.880
We have highlighting APIs to handle the
highlighting and unhighlighting of text.

00:53:22.890 --> 00:53:26.030
And these are kind of useful
because in Unicode text,

00:53:26.030 --> 00:53:29.760
the highlighted areas can be
discontinuous depending on the

00:53:29.760 --> 00:53:32.400
directionality and such of the text.

00:53:32.930 --> 00:53:45.210
In addition, we have three APIs that will
be required should you ever

00:53:45.210 --> 00:53:45.210
insert or delete or move text,
and they're listed up

00:53:45.210 --> 00:53:45.210
there on the screen.

00:53:47.770 --> 00:53:51.030
Some advanced features that
ATSUI has that you may be interested

00:53:51.400 --> 00:53:55.800
in is we have the ATSU Glyph
Selector to specify a glyph variant.

00:53:56.000 --> 00:54:03.170
You specify this ATSU Glyph
Selector in the style,

00:54:03.170 --> 00:54:05.490
and that allows you to do the glyph
variant support that Giulia showed

00:54:05.490 --> 00:54:05.490
you that MLTE handles for you.

00:54:05.640 --> 00:54:08.720
ATSUI also has the
ATSU Direct Access calls,

00:54:08.720 --> 00:54:15.020
and these allow you to get exact
glyphs and glyph positions and all

00:54:15.700 --> 00:54:25.310
sorts of other information out of the
layout for those of you who want to

00:54:25.310 --> 00:54:25.310
do your own positional manipulations
or supply your own metrics.

00:54:25.970 --> 00:54:33.850
ATSUI also has some flattening
APIs for pasteboard exports.

00:54:33.850 --> 00:54:39.850
This will allow you to
take the ATSUI styles that

00:54:39.850 --> 00:54:42.920
you've set in the layout,
flatten them all to a binary format

00:54:42.920 --> 00:54:42.920
so you can put them all up on the
pasteboard or save them to disk.

00:54:43.910 --> 00:54:46.990
And finally,
ATSUI has some curve access APIs.

00:54:46.990 --> 00:54:50.070
And these are really cool because
they allow you to get at the

00:54:50.560 --> 00:54:54.410
curves that ATSUI is giving to the
graphics engine to draw the glyphs.

00:54:54.600 --> 00:55:00.180
So some applications, such as Motion,
have used these.

00:55:00.330 --> 00:55:03.410
"I'm going to show you how to
actually do animated text and other

00:55:03.410 --> 00:55:06.370
cool effects with those curves."

00:55:08.260 --> 00:55:12.150
So some folks have asked
for some performance tips,

00:55:12.160 --> 00:55:18.800
besides some of the ones that have
been given throughout the presentation.

00:55:18.850 --> 00:55:22.390
You should use the ATSU Git Glyph
Bounds API for measuring

00:55:22.390 --> 00:55:24.500
the text whenever possible.

00:55:24.570 --> 00:55:27.860
ATSUI provides several
APIs for measurement,

00:55:27.910 --> 00:55:30.580
and this is the only one
that's guaranteed not to

00:55:30.580 --> 00:55:33.320
upset any of the cached data.

00:55:33.410 --> 00:55:36.820
Some of the APIs require it to
do some extra processing work

00:55:36.890 --> 00:55:40.330
to get the correct measurement,
the measurement that you requested for.

00:55:40.480 --> 00:55:44.040
This will give you a typographic
bounds that's guaranteed to

00:55:44.050 --> 00:55:46.400
not upset the cached layout.

00:55:47.230 --> 00:55:49.260
Second thing,
if you are getting the curves,

00:55:49.310 --> 00:55:53.230
you should call atsu.getNativeCurveType
before accessing the curves

00:55:53.230 --> 00:55:57.650
and set up your curve callbacks
according to the result of that.

00:55:57.660 --> 00:56:03.690
Some fonts have curves stored in cubics.

00:56:04.120 --> 00:56:06.480
Some fonts have curves
stored in quadratics.

00:56:06.700 --> 00:56:10.640
And if you use the wrong type,
ATSUI has to convert the cubes

00:56:10.720 --> 00:56:13.720
to quads and the quads to cubes.

00:56:13.910 --> 00:56:17.470
And that's not an expensive process
and may give you some ugly looking

00:56:18.250 --> 00:56:21.730
text if you go to draw those curves.

00:56:21.760 --> 00:56:25.110
Finally,
if there's anything that you should take

00:56:25.110 --> 00:56:30.540
away from in terms of ATSUI performance,
is that you should maximize

00:56:30.960 --> 00:56:36.310
the object lifetimes,
meaning that you should not

00:56:36.310 --> 00:56:41.150
throw away these objects until
you're absolutely done with them.

00:56:41.150 --> 00:56:41.150
Keep the text layout objects around.

00:56:41.150 --> 00:56:41.150
Keep the ATSU style objects around.

00:56:41.790 --> 00:56:44.520
Following that,
you want to minimize the object creation.

00:56:44.660 --> 00:56:49.640
You want to create as few
ATSUI styles as possible,

00:56:49.640 --> 00:56:57.820
and you want to create as few ATSUI text
layouts as your application requires.

00:57:00.890 --> 00:57:06.510
So that wraps up the
ATSUI section of the session.

00:57:06.960 --> 00:57:09.940
And there's a couple things
that you should take away.

00:57:10.280 --> 00:57:14.950
First is that you should use the
HIThemeText API for static text.

00:57:15.220 --> 00:57:19.150
It makes things a lot easier.

00:57:19.220 --> 00:57:23.000
You can create these
things in Project Builder.

00:57:23.000 --> 00:57:23.000
Second, use the Unicode Control API.

00:57:23.170 --> 00:57:29.140
So that wraps up the
ATSUI section of the session.

00:57:29.250 --> 00:57:32.310
And there's a couple things
that you should take away.

00:57:32.380 --> 00:57:37.520
First is that you should use the
HIThemeText API for static text.

00:57:37.520 --> 00:57:41.450
It makes things a lot easier.

00:57:41.450 --> 00:57:47.800
You can create these
things in Project Builder.

00:57:47.800 --> 00:57:51.320
Second, use the Unicode Control API.

00:57:52.110 --> 00:57:56.150
Fifth, use the API optimally
for the best performance.

00:57:56.150 --> 00:58:00.980
That includes keeping objects around,
not throwing them out,

00:58:00.980 --> 00:58:06.160
creating as few objects as possible,
turning off visibility on your

00:58:06.200 --> 00:58:11.160
MLTE objects when you're doing
lots of edits and stuff like that.

00:58:11.270 --> 00:58:16.910
And finally, you need to file bug reports
should you see anything wrong.

00:58:16.910 --> 00:58:19.510
We're doing our best
to test these things,

00:58:19.510 --> 00:58:19.510
but every now and then,

00:58:20.000 --> 00:58:25.250
Well, I shouldn't say every now and then,
but we get very good bug reports

00:58:25.250 --> 00:58:28.790
from you guys from the field,
and we do fix those,

00:58:28.790 --> 00:58:31.050
and we do see those problems.

00:58:31.050 --> 00:58:40.500
So with that,
I'd like to bring up Xavier for

00:58:40.500 --> 00:58:40.500
the wrap-up and the Q&A.

00:58:40.500 --> 00:58:40.500
Thank you.
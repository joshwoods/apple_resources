WEBVTT

00:00:12.360 --> 00:00:14.000
Good afternoon.

00:00:14.000 --> 00:00:15.140
Happy Canada Day.

00:00:15.190 --> 00:00:15.870
Thank you for coming.

00:00:15.940 --> 00:00:23.230
I'm Tim Chernna, and I manage the
QuickTime Video Foundation team,

00:00:23.240 --> 00:00:25.820
and together with my team
and the QuartzFX team,

00:00:25.890 --> 00:00:28.380
we're going to talk about new
directions in QuickTime Performance,

00:00:28.380 --> 00:00:30.660
which is really talking about

00:00:31.050 --> 00:00:35.000
The integration of QuickTime and
Core Video on Tiger.

00:00:35.000 --> 00:00:38.500
We're going to talk about a new
video pipeline we've been working on.

00:00:38.630 --> 00:00:42.040
So, this lets you take advantage
of the GPU for video

00:00:42.040 --> 00:00:44.340
acceleration and video effects.

00:00:44.470 --> 00:00:47.920
And it will show you also how
to adopt Core Video for high

00:00:47.920 --> 00:00:49.860
performance rendering and timing.

00:00:50.000 --> 00:00:52.790
And we'll show you how to move away
from some of the QuickDraw data

00:00:52.890 --> 00:00:54.640
structures that QuickTime uses.

00:00:54.910 --> 00:00:59.150
So, today we're going to start out
talking about some simple ways to take

00:00:59.150 --> 00:01:01.800
advantage of the new pipeline using H.I.

00:01:01.800 --> 00:01:07.790
MovieView for Carbon developers and
Qt MovieView for Cocoa developers.

00:01:07.920 --> 00:01:11.500
We'll also show you how to make
your pipeline customized by using

00:01:11.500 --> 00:01:14.200
visual context and core video.

00:01:14.320 --> 00:01:17.140
And then finally,
how to integrate this with

00:01:17.140 --> 00:01:19.310
OpenGL and the new core image.

00:01:19.770 --> 00:01:22.280
So before I start,
I want to talk a little bit about how

00:01:22.280 --> 00:01:24.850
QuickTime did rendering before Tiger.

00:01:25.050 --> 00:01:28.460
So movies would render into
graph ports and G worlds.

00:01:28.460 --> 00:01:32.540
G worlds would be an off-screen memory,
and graph ports would

00:01:32.540 --> 00:01:34.480
be an on-screen windows.

00:01:34.640 --> 00:01:39.990
So, QuickTime could use a transfer
codec to go from an intermediate

00:01:40.030 --> 00:01:42.220
pixel format to a final one.

00:01:42.220 --> 00:01:45.330
And, for certain formats,
we could accelerate the

00:01:45.330 --> 00:01:47.450
decoding to hardware.

00:01:47.630 --> 00:01:50.600
But, it was important to note that if we
were going to an off-screen G world,

00:01:50.600 --> 00:01:51.600
the movie would always
play synchronously,

00:01:51.600 --> 00:01:55.510
so you wouldn't benefit from the
asynchronous scheduling of QuickTime.

00:01:55.600 --> 00:01:57.510
So, the stack kind of looks like this.

00:01:57.870 --> 00:02:02.460
You have the movie, and on top,
underneath that, it uses the image

00:02:02.460 --> 00:02:07.330
compression manager and,
say, a primary codec like DV or MPEG-4

00:02:07.330 --> 00:02:11.600
to either go to the destination
or it would use a transfer codec,

00:02:11.600 --> 00:02:13.630
and in some cases,
it would accelerate that going

00:02:13.630 --> 00:02:14.600
directly to the hardware.

00:02:14.600 --> 00:02:17.350
But, the one thing to note
is that entire stack,

00:02:17.350 --> 00:02:19.990
from the movie down to
the final destination,

00:02:19.990 --> 00:02:23.210
is owned by QuickTime,
and it wasn't really a layering.

00:02:23.600 --> 00:02:24.600
So, one of the things that we've learned
is that the movie is not a layer.

00:02:24.600 --> 00:02:25.600
So, one of the things that we've learned
is that the movie is not a layer.

00:02:25.600 --> 00:02:28.600
that we had in that architecture was it
was really hard to play a movie into GL.

00:02:28.600 --> 00:02:31.600
Well, it's easy to do a bad job.

00:02:31.600 --> 00:02:33.600
It wasn't that efficient.

00:02:33.600 --> 00:02:37.090
And about two years ago at WWDC,
we showed a solution to write your

00:02:37.450 --> 00:02:43.780
own custom transfer codec to get
the drawing notifications from a --

00:02:44.570 --> 00:02:48.280
from QuickTime so you could
synchronize it with OpenGL.

00:02:48.330 --> 00:02:49.700
But it only worked for certain movies.

00:02:49.700 --> 00:02:54.130
It worked for movies where
there was a single video track

00:02:54.220 --> 00:02:56.750
and certain specific codecs,
and it wasn't very efficient.

00:02:56.860 --> 00:02:58.760
So that didn't work so well.

00:02:58.870 --> 00:03:01.720
So we decided to build a
new video pipeline in Tiger.

00:03:01.780 --> 00:03:03.200
And we had some goals.

00:03:03.380 --> 00:03:06.160
The first goal was to have
good integration with OpenGL.

00:03:06.240 --> 00:03:09.600
We wanted to be able to support
multiple buffers in flight.

00:03:09.680 --> 00:03:12.830
We wanted to be able to separate
the decode and presentation logic.

00:03:12.940 --> 00:03:15.660
And we wanted to layer
this on top of Quartz.

00:03:15.730 --> 00:03:17.410
But basically,
this is the diagrams that we showed

00:03:17.410 --> 00:03:20.240
at the graphics media overview.

00:03:20.400 --> 00:03:22.900
And you know that Quartz
is basically core graphics,

00:03:22.900 --> 00:03:24.820
core image, and core video.

00:03:24.900 --> 00:03:26.850
And I wanted to show you how we're
going to build this pipeline,

00:03:26.850 --> 00:03:30.410
so we made a little bit more
of a colored version of this.

00:03:30.760 --> 00:03:32.570
So, how do we build a pipeline?

00:03:32.580 --> 00:03:35.170
We went this movie to get
to the graphics hardware.

00:03:35.170 --> 00:03:36.890
And the first thing we're going
to do is we're going to use

00:03:37.350 --> 00:03:41.600
QuickTime to source and decode the
data like we normally have done.

00:03:41.640 --> 00:03:46.050
We've chosen to use OpenGL to
do the rendering to the display.

00:03:47.380 --> 00:03:51.410
And we've created these visual contexts
as a structure to source textures from

00:03:51.410 --> 00:03:54.300
the movie for downstream rendering.

00:03:54.400 --> 00:03:59.010
And we use Core Video for
timing and buffering services.

00:03:59.650 --> 00:04:03.160
And we can also use additional
OpenGL functionality for transformations

00:04:03.160 --> 00:04:05.770
of the image as they go through.

00:04:05.860 --> 00:04:09.830
And of course we can add
Core Image for image-based effects.

00:04:09.990 --> 00:04:13.650
So these last two modules that I've shown
are basically where your application

00:04:13.790 --> 00:04:15.500
would customize the effects pipeline.

00:04:15.570 --> 00:04:17.610
And this is where you as
developers can take advantage

00:04:17.630 --> 00:04:19.490
and do whatever you want to do,
and we'll show you

00:04:19.690 --> 00:04:21.400
some of that coming up.

00:04:21.480 --> 00:04:24.530
So this is the architectural
stack that we've built.

00:04:24.620 --> 00:04:26.060
And once again,
this is the video pipeline.

00:04:26.060 --> 00:04:28.680
And to talk about this,
and we're going to have the other people

00:04:28.680 --> 00:04:31.290
on the team talk about the various parts,
but to start out with

00:04:31.290 --> 00:04:33.470
some simple solutions,
I'd like to bring up Sean to

00:04:33.560 --> 00:04:37.480
talk about simple solutions.

00:04:41.100 --> 00:04:43.120
Thank you.

00:04:43.340 --> 00:04:45.720
So you want to get video
in your application.

00:04:45.920 --> 00:04:48.000
Well,
what's the easiest thing you can do?

00:04:48.070 --> 00:04:52.680
Maybe you don't care about
QuickTime or OpenGL and textures,

00:04:52.750 --> 00:04:54.760
so you just want to get your
video playing in some window.

00:04:54.820 --> 00:04:56.160
What's the easiest thing?

00:04:56.230 --> 00:04:59.590
Well, Cocoa developers,
they can use QtKit.

00:04:59.770 --> 00:05:03.060
I mean, there was a whole session this
morning on how to use QtKit.

00:05:03.120 --> 00:05:05.810
And in that,
there's the QtMovie and QtMovieView.

00:05:05.960 --> 00:05:09.240
So if you use QtMovieView in
your applications,

00:05:09.320 --> 00:05:11.380
you get all the acceleration
and all the benefits of

00:05:11.540 --> 00:05:15.670
Core Video underneath without having
to deal with any of this new stuff.

00:05:15.900 --> 00:05:19.480
Similar with Carbon developers,
you can use the HIMovieView.

00:05:19.480 --> 00:05:23.660
Now, this is a replacement for the
CarbonMovieControl and also

00:05:23.660 --> 00:05:25.770
gives you all the benefits.

00:05:27.680 --> 00:05:31.590
So, here you can see the movie view
takes care of the visual context,

00:05:31.590 --> 00:05:34.700
it manages the OpenGL rendering,
and it deals with core video,

00:05:34.700 --> 00:05:36.600
doing all the timing and so forth.

00:05:36.810 --> 00:05:38.380
Same with H.I.

00:05:38.380 --> 00:05:39.500
MovieView.

00:05:40.600 --> 00:05:41.820
So, since the H.I.

00:05:41.820 --> 00:05:44.100
Movie wasn't talked in
depth in the other sessions,

00:05:44.100 --> 00:05:45.990
I'm going to go over it quickly here.

00:05:46.100 --> 00:05:50.200
So, this is now the preferred way to
put movies in your Carbon windows.

00:05:50.270 --> 00:05:51.940
It's now a full-featured H.I.

00:05:51.940 --> 00:05:54.900
View, unlike the Carbon Movie Control.

00:05:54.990 --> 00:05:57.100
So, it's going to work in
your composited windows.

00:05:57.210 --> 00:06:00.830
And, you can also use Interface Builder
and put this in your Nib files.

00:06:01.060 --> 00:06:03.560
And, of course,
it uses visual context to get all the

00:06:03.560 --> 00:06:06.300
live resizing and the GPU acceleration.

00:06:06.410 --> 00:06:10.060
Again, use this one instead of
Carbon Movie Control.

00:06:11.120 --> 00:06:13.120
So, here are some of the APIs.

00:06:13.340 --> 00:06:16.400
You create one of these
things with HIMovieViewCreate.

00:06:16.400 --> 00:06:21.410
You can also use HIObjectCreate and
pass it the class ID of the HIMovieView.

00:06:21.590 --> 00:06:26.360
Or, if you're using an interface builder,
you can create a custom HIView and use

00:06:26.360 --> 00:06:31.300
the class ID inside interface builder,
and you'll get that in your nib file.

00:06:31.400 --> 00:06:35.420
So, once you have one of these,
you can use the setMovieCall and

00:06:35.420 --> 00:06:39.270
the changeAttributes calls to
change the movie in the HIMovieView.

00:06:39.550 --> 00:06:42.960
Well, this is a slight difference
from the Carbon Movie Control,

00:06:43.040 --> 00:06:46.360
where it was the same movie
from the time you created it

00:06:46.420 --> 00:06:47.200
to the time you destroyed it.

00:06:47.200 --> 00:06:49.320
You couldn't change the movie,
and there were some attributes

00:06:49.320 --> 00:06:50.480
you couldn't change at runtime.

00:06:50.590 --> 00:06:53.450
So, you can turn on editing,
turn off editing,

00:06:53.450 --> 00:06:56.950
tell it to start listening
to copy/paste and so forth.

00:06:57.120 --> 00:06:58.460
So that's how you use it.

00:06:58.470 --> 00:07:02.020
And since it's HIView,
it makes heavy use of Carbon events.

00:07:02.110 --> 00:07:07.060
So for example,
you can listen for the control-- you can

00:07:07.120 --> 00:07:09.760
use the control get optimal bounds event.

00:07:09.770 --> 00:07:12.220
And that will tell you how
big this movie wants to be,

00:07:12.300 --> 00:07:15.300
taking into account the size of the
controller bar if that's visible.

00:07:15.320 --> 00:07:17.330
And sometimes these
movies may change size.

00:07:17.410 --> 00:07:21.860
So you can listen for a new event,
the movie view optimal bounds changed.

00:07:21.860 --> 00:07:23.820
And that will tell you
when you get that event,

00:07:23.830 --> 00:07:25.350
you know, OK, let's relay out the window.

00:07:25.580 --> 00:07:27.790
because the HMU view doesn't know
how you want your window laid out.

00:07:27.930 --> 00:07:29.150
It's not going to do that for you.

00:07:31.160 --> 00:07:33.070
All right, with that,
I hand it over to Jim Batson.

00:07:33.090 --> 00:07:35.940
He'll show us some of
these views in action.

00:07:35.950 --> 00:07:37.690
Thanks, Sean.

00:07:41.230 --> 00:07:42.940
So, can we have a demo machine?

00:07:43.090 --> 00:07:44.460
Great, thank you very much.

00:07:44.560 --> 00:07:46.830
I'm Jim,
and I'm going to show you some simple

00:07:46.830 --> 00:07:51.500
applications to show the simple
solutions for showing accelerated video.

00:07:51.660 --> 00:07:57.190
We'll start off by looking at Finder,
the canonical example that's been

00:07:57.190 --> 00:07:59.260
used for HM MovieView already.

00:07:59.370 --> 00:08:04.770
I want to navigate over in ColumnView,
over to some place where

00:08:04.780 --> 00:08:06.180
I've got some movies.

00:08:07.320 --> 00:08:12.680
And you'll see that as you're
used to seeing inside Finder,

00:08:12.840 --> 00:08:14.520
preview over here.

00:08:14.520 --> 00:08:15.920
And of course you can play the movie.

00:08:15.920 --> 00:08:20.420
I'm going to jump around so we can get
some of the place more interesting first.

00:08:20.440 --> 00:08:22.270
You can scrub.

00:08:23.180 --> 00:08:26.380
Now, one of the things to note here is
that there's a lot more information

00:08:26.390 --> 00:08:31.460
in "Tiger" than in "Panther" in terms
of metadata information about the

00:08:31.460 --> 00:08:33.500
movie being displayed in this panel.

00:08:33.550 --> 00:08:35.350
You see the duration,
the width and height,

00:08:35.430 --> 00:08:37.730
and even the codecs that are
being used and media types that

00:08:37.730 --> 00:08:38.940
are being used in the movie.

00:08:39.060 --> 00:08:44.210
So, it's just kind of a nice addition
in "Tiger". You can also grow.

00:08:47.700 --> 00:08:50.550
While even we play,
we can grow the movie.

00:08:50.600 --> 00:08:56.460
This is actually one of the HD movies,
so it gets pretty large.

00:08:57.320 --> 00:08:58.520
And this is, uh, H.I.

00:08:58.540 --> 00:09:01.130
MovieView is being used
inside Finder to handle this,

00:09:01.130 --> 00:09:03.370
and you can see it scrolling.

00:09:03.800 --> 00:09:09.620
and updating and doing all the
normal behavior you'd expect.

00:09:10.140 --> 00:09:12.000
And, of course,
this works for other movie types

00:09:12.000 --> 00:09:14.390
than just your normal audio/video.

00:09:14.500 --> 00:09:16.520
Bring up a VR movie.

00:09:17.610 --> 00:09:19.840
Let's see it here.

00:09:19.890 --> 00:09:21.110
Scroll over.

00:09:21.230 --> 00:09:22.860
And you can still control it.

00:09:22.880 --> 00:09:27.190
You have the normal VR controls.

00:09:27.750 --> 00:09:29.100
and all that works nicely.

00:09:29.220 --> 00:09:32.370
Another place in the finder where
you'll see HIMovieView being used

00:09:32.920 --> 00:09:38.980
is inside the preview pane itself.

00:09:41.660 --> 00:09:45.460
And you'll notice over here,
not only do you have,

00:09:45.520 --> 00:09:49.020
you also have the extra information
that I mentioned before in the

00:09:49.020 --> 00:09:51.350
preview pane in the general area.

00:09:51.760 --> 00:09:55.900
and you also have the movie
being previewed here and it

00:09:55.900 --> 00:09:58.600
plays well in there as well.

00:09:58.670 --> 00:10:02.280
Okay, next I'm going to show

00:10:04.090 --> 00:10:06.060
We're going to talk about
the new HIMovieView player,

00:10:06.060 --> 00:10:07.640
which is a very simple
player that's built on top of

00:10:07.680 --> 00:10:11.900
just... it's a Carbon player
built on top of HIMovieView.

00:10:11.900 --> 00:10:14.810
And, first I'm going to go
ahead and launch it.

00:10:15.980 --> 00:10:18.260
Open a movie.

00:10:18.270 --> 00:10:20.900
We'll start off with Harry Potter.

00:10:20.900 --> 00:10:24.360
Familiar movie,
you can just click around and

00:10:24.360 --> 00:10:26.390
see the controller comes up.

00:10:28.500 --> 00:10:30.720
"You can cook around and use it.

00:10:30.750 --> 00:10:36.100
Also, you can make the controller visible
or invisible while it's running.

00:10:36.100 --> 00:10:39.370
And,
you can make it editable if you want."

00:10:42.200 --> 00:10:45.180
I don't know if you can see,
but the thumb for displaying

00:10:45.190 --> 00:10:49.940
where you are in the movie has
changed to be the edit thumb.

00:10:49.950 --> 00:10:57.590
Also, added some other controls out here,
just using the normal HI technique

00:10:57.740 --> 00:11:01.480
for having a button and then
sending a message to the view to

00:11:01.480 --> 00:11:03.140
implement play and stop buttons.

00:11:03.270 --> 00:11:05.100
So, if you didn't want to
have the controller,

00:11:05.120 --> 00:11:11.310
you can implement your own
UI for controlling the movie.

00:11:14.680 --> 00:11:18.170
I want to show you a couple of,
something else that the H.I.

00:11:18.200 --> 00:11:21.940
MovieView does support is the
focus and tabbing within fields.

00:11:21.970 --> 00:11:25.510
I don't know if you can see it or not,
but when I tab between the text here,

00:11:25.510 --> 00:11:30.210
I'm going to blow it up a little bit,
and I'm using the Command Option + key.

00:11:31.600 --> 00:11:33.540
To be able to zoom in
and minus will zoom out.

00:11:33.570 --> 00:11:35.970
You can see that the text
field is highlighted.

00:11:36.010 --> 00:11:38.170
I can tab over.

00:11:38.170 --> 00:11:41.990
If I tab over the text
field and start typing,

00:11:41.990 --> 00:11:41.990
and I, you know,

00:11:43.080 --> 00:11:46.490
The space didn't do anything,
but if I come over, tab over to the movie

00:11:46.490 --> 00:11:49.440
window and I hit space,
it starts the movie as you'd expect.

00:11:49.460 --> 00:11:51.050
So, this supports focus.

00:11:51.210 --> 00:11:54.340
I'm going to
Command-Option-Minus to un-zoom.

00:11:54.420 --> 00:11:56.980
Now,
you might have noticed that the controls

00:11:56.980 --> 00:11:58.840
up here were not being tabbed to.

00:11:58.930 --> 00:12:04.430
Just in case you're trying to
do that and want to find out,

00:12:04.460 --> 00:12:05.860
you know, curious why it doesn't
work on your machine,

00:12:05.860 --> 00:12:09.230
I'm going to actually turn
it on now and go back.

00:12:09.330 --> 00:12:15.380
So, I can just come up here and find
where to turn on the tab keys.

00:12:15.380 --> 00:12:16.760
Let's see.

00:12:16.910 --> 00:12:20.140
I want to be able to tab between
all controls and windows.

00:12:20.210 --> 00:12:23.760
So, now I want to go back
to HMovieViewPlayer.

00:12:24.090 --> 00:12:28.000
If I tab over... It's hard to see,
isn't it?

00:12:28.130 --> 00:12:32.230
So if I tab over to, let's say,
the controller visible,

00:12:32.230 --> 00:12:34.000
I can turn that on.

00:12:34.080 --> 00:12:37.110
Wow.

00:12:38.270 --> 00:12:39.700
At least you can see the tab building.

00:12:39.700 --> 00:12:40.700
Okay.

00:12:40.700 --> 00:12:42.700
There's something moving out there.

00:12:42.700 --> 00:12:43.700
It was a Dementor.

00:12:43.700 --> 00:12:47.670
Now, one thing to realize is that
it's not just for playing movies

00:12:47.700 --> 00:12:52.480
and only for movie applications,
whose main purpose is

00:12:52.480 --> 00:12:53.640
to play video content.

00:12:53.710 --> 00:12:58.050
QuickTime also gets used a lot
for playing little animations.

00:12:58.200 --> 00:13:04.140
I'm going to bring up this alarm clock,
and you might recognize this alarm clock.

00:13:04.210 --> 00:13:11.790
It's the alarm clock from iCal,
and that animation is done as a

00:13:17.310 --> 00:13:19.540
is just a QuickTime movie.

00:13:19.970 --> 00:13:20.840
So now that you've got H.I.

00:13:20.840 --> 00:13:22.910
MovieView support,
it's really easy to add little

00:13:22.910 --> 00:13:25.900
animations into your Carbon apps.

00:13:28.900 --> 00:13:31.780
And finally,
I want to end this part of the

00:13:32.360 --> 00:13:37.340
demo with a kind of a classic
QuickTime movie to show that the

00:13:38.470 --> 00:13:42.950
There are other kinds of animations,
and they also still play.

00:13:43.050 --> 00:13:47.480
So it's not just the new
H.264 or video style movies.

00:13:52.840 --> 00:13:54.600
Is there any audio?

00:13:54.600 --> 00:13:56.510
Okay.

00:13:56.690 --> 00:13:59.160
Well, I'm gonna quit it now,
'cause the punchline is

00:13:59.170 --> 00:14:00.990
not as good without audio.

00:14:04.510 --> 00:14:08.900
So I'm now going to move over to,
we talked before about H.I.MovieView,

00:14:08.900 --> 00:14:09.900
but also QtPlayer.

00:14:09.900 --> 00:14:13.900
QtPlayer is built on top of QtKit.

00:14:13.920 --> 00:14:17.080
And I'm just going to show you,
just briefly,

00:14:17.360 --> 00:14:20.020
QuickTime Player by bringing up a movie.

00:14:20.170 --> 00:14:24.280
We've seen this QuickTime Player several
times this week already.

00:14:24.310 --> 00:14:27.920
I just want to show you some of the--
being able to animate up and down.

00:14:28.120 --> 00:14:33.650
And it's taking the power of the visual
context and exposing it through this.

00:14:33.770 --> 00:14:34.970
It can also go full screen.

00:14:35.000 --> 00:14:39.440
Full screen.

00:14:49.900 --> 00:14:52.400
I'll go for a sec.

00:14:52.400 --> 00:14:55.910
I've fought many wars in my time.

00:14:56.800 --> 00:14:58.880
"Some fault for that." Okay,
that's enough.

00:14:58.880 --> 00:15:00.960
I'm sure you've seen enough this week.

00:15:01.060 --> 00:15:03.890
So, one trick here is that if you
want to know whether Qt Movie Kit,

00:15:03.990 --> 00:15:10.960
or sorry, Qt Movie or Qt Movie View being
implemented by QtKit is in use,

00:15:10.960 --> 00:15:13.840
is you can control-click and
you get a little pop-up here.

00:15:13.860 --> 00:15:16.190
So, we can...

00:15:17.000 --> 00:15:25.700
[Transcript missing]

00:15:26.000 --> 00:15:31.500
[Transcript missing]

00:15:31.800 --> 00:15:35.080
Earlier this morning,
saw Adrian show the QuickTime plugin,

00:15:35.080 --> 00:15:39.190
a version of the QuickTime plugin
that he created very quickly,

00:15:39.190 --> 00:15:44.950
leveraging the new WebKit facility
to add JavaScript binding

00:15:44.960 --> 00:15:47.310
and the new Safari plugin.

00:15:48.170 --> 00:16:00.090
and other capabilities that you can
apply to your Objective-C class.

00:16:00.180 --> 00:16:00.770
And, he already went over the code,
but what I want to show you here

00:16:00.770 --> 00:16:00.770
is briefly inside the info.p list,

00:16:01.000 --> 00:16:51.900
[Transcript missing]

00:16:54.650 --> 00:16:59.000
And here we have the plugin being used.

00:16:59.170 --> 00:17:05.150
It supports these buttons down here,
just through some JavaScript.

00:17:08.000 --> 00:17:11.160
This is the stupid movie this
year that was shown yesterday.

00:17:11.170 --> 00:17:13.670
There'll be a full showing, I understand,
in the next session.

00:17:13.710 --> 00:17:15.000
Let me just skip around
here a little bit.

00:17:15.000 --> 00:17:20.500
And, the idea behind having,
being able to call QuickTime stuff

00:17:20.500 --> 00:17:24.000
directly inside a plugin is that you can
add additional features like full screen.

00:17:24.000 --> 00:17:28.980
So, directly from a plugin you
can go full screen your movie,

00:17:28.980 --> 00:17:31.000
which is kind of cool.

00:17:34.000 --> 00:17:38.520
So, oh, let's see.

00:17:44.720 --> 00:17:47.710
The last thing I want to show you is,
another reason I showed you the

00:17:47.730 --> 00:17:53.360
plug-in was that with Dashboard,
which you saw Monday,

00:17:53.690 --> 00:17:56.710
The last thing I want to show you is,
another reason I showed you the

00:17:56.710 --> 00:18:02.360
plug-in was that with Dashboard,
which you saw Monday,

00:18:11.800 --> 00:18:35.000
[Transcript missing]

00:18:35.100 --> 00:18:40.600
[Transcript missing]

00:18:40.950 --> 00:18:45.400
And just to prove that it's using QtKit,
here we've got... Look at that.

00:18:45.400 --> 00:18:47.260
All that good stuff works.

00:18:47.300 --> 00:18:52.190
And also just randomly support
full screen inside GAT,

00:18:52.190 --> 00:18:54.140
you know, dashboard.

00:18:57.440 --> 00:19:04.480
So, another reason I showed you
that with Gadget is that,

00:19:04.600 --> 00:19:07.240
with the dashboard,
is that if you go back,

00:19:07.290 --> 00:19:10.040
take your SDK back,
and you try to do this yourself,

00:19:10.070 --> 00:19:11.730
it won't work.

00:19:12.140 --> 00:19:13.710
Not with this version, anyway.

00:19:13.960 --> 00:19:18.820
The problem is that Dashboard,
with the new QuickTime,

00:19:18.820 --> 00:19:23.450
we're using OpenGL and
creating the surface,

00:19:23.450 --> 00:19:25.660
the GL surface, with that,
with the window from

00:19:25.660 --> 00:19:28.300
Dashboard fails right now,
so I had to kind of work around that.

00:19:28.390 --> 00:19:29.740
And, but of course, that'll be fixed.

00:19:29.980 --> 00:19:33.400
So, in case,
trying to save you some grief,

00:19:33.440 --> 00:19:35.300
don't try this at home.

00:19:35.420 --> 00:19:37.720
Okay, with that, I'm done.

00:19:37.860 --> 00:19:41.270
And, just as a final wrap up, you know,
one of the good things with these,

00:19:41.500 --> 00:19:42.100
the new H.I.

00:19:42.100 --> 00:19:44.990
MovieView and Qt MovieViews
is that it helps,

00:19:45.050 --> 00:19:50.940
it lets you add QuickTime technology,
QuickTime playback to the rest of the OS,

00:19:50.940 --> 00:19:58.090
where we're well integrated now with
Carbon and the nice new classes in Cocoa.

00:19:58.160 --> 00:19:59.930
Back to Sean.

00:20:05.260 --> 00:20:07.660
All right, enough of the easy stuff.

00:20:07.870 --> 00:20:10.250
So you want to customize your pipeline.

00:20:12.120 --> 00:20:15.650
Here's our diagram again of the pipeline.

00:20:15.650 --> 00:20:17.500
I'm going to be focusing on
the QuickTime side of it,

00:20:17.520 --> 00:20:20.290
and later I'll hand it over to
Ken and Frank to talk about the

00:20:20.350 --> 00:20:22.100
other pieces of the pipeline.

00:20:22.100 --> 00:20:25.100
So, why do you want to customize it?

00:20:25.100 --> 00:20:27.100
Maybe you want to perform
some image processing,

00:20:27.100 --> 00:20:29.100
you want to use that new
cool core image stuff.

00:20:29.100 --> 00:20:33.030
Or, you have some heads-up display,
you want to draw some FPS counter,

00:20:33.130 --> 00:20:36.210
or you want to put some cropping
boxes over it or something,

00:20:36.210 --> 00:20:37.100
I don't know.

00:20:37.100 --> 00:20:40.250
Maybe you have a game and you
want to have a movie playing

00:20:40.360 --> 00:20:42.100
inside the overall scene.

00:20:42.100 --> 00:20:46.100
Well, you can't use H-I Movie View or
Q-T Movie View to do these things.

00:20:46.100 --> 00:20:50.030
They're just designed to have
a single rectangular window

00:20:50.030 --> 00:20:52.100
or a view in a larger window.

00:20:52.100 --> 00:20:55.210
So, you're going to need to use OpenGL,
you're going to need to use

00:20:55.210 --> 00:20:57.100
Core Video and the visual contexts.

00:20:57.930 --> 00:21:00.360
So, how does this pipeline work?

00:21:00.390 --> 00:21:03.400
Well, not going to have the view.

00:21:04.680 --> 00:21:06.600
So you see the first thing
in here is the movie.

00:21:06.660 --> 00:21:08.110
First, you're going to need a movie.

00:21:08.340 --> 00:21:12.260
So you may be thinking, well,
I can just call a new movie,

00:21:12.300 --> 00:21:18.610
or a new movie from File,
or a new movie from Scrap,

00:21:18.630 --> 00:21:22.190
or a new movie from DataRef,
or a new movie from DataFork, or so on.

00:21:22.190 --> 00:21:22.190
You have 10 choices.

00:21:22.190 --> 00:21:22.190
Well, now you have 11.

00:21:23.000 --> 00:21:25.620
Think of this as new movie from anything.

00:21:25.700 --> 00:21:29.020
So, all the parameters are passed
in through a list of properties,

00:21:29.130 --> 00:21:30.870
and all the results are
returned through properties.

00:21:30.900 --> 00:21:33.900
So,
this is a super set of everything else.

00:21:33.900 --> 00:21:37.110
You can get the same functionality
of all those other new movie

00:21:37.110 --> 00:21:38.900
calls with this new one here.

00:21:38.900 --> 00:21:42.850
But, the biggest difference is that you
can now create a movie that does

00:21:42.900 --> 00:21:44.750
not inherit the current G world.

00:21:44.900 --> 00:21:47.900
This was a subtle semantic of
all the other new movie calls,

00:21:47.900 --> 00:21:49.970
is that whatever port
happened to be current,

00:21:49.970 --> 00:21:52.180
you know, last call to set port,
your movie would get that,

00:21:52.180 --> 00:21:53.900
and that's where it would render.

00:21:53.900 --> 00:21:56.260
So, if you just created a movie
and started playing it,

00:21:56.260 --> 00:21:58.830
it might go up all over
your screen or something.

00:21:58.900 --> 00:22:01.190
So, with this call,
you can specify a visual

00:22:01.190 --> 00:22:02.860
context to use upon creation.

00:22:02.870 --> 00:22:06.900
You could set it to nil
and have it render nowhere.

00:22:06.900 --> 00:22:10.830
So, this is the recommended
way to create all movies.

00:22:10.900 --> 00:22:12.850
And, in fact,
if you pass all zeros to this function,

00:22:13.070 --> 00:22:16.780
it behaves exactly as
calling new movie with zero.

00:22:17.910 --> 00:22:20.990
So the next piece is the visual context.

00:22:21.080 --> 00:22:21.760
So what is this thing?

00:22:21.960 --> 00:22:25.390
It's an abstraction of the
video rendering destination

00:22:25.400 --> 00:22:26.610
for QuickTime movies.

00:22:26.810 --> 00:22:29.260
It's a replacement for the G world.

00:22:29.430 --> 00:22:31.400
This is where we get our new
rendering performance from.

00:22:31.450 --> 00:22:33.920
We can take advantage of the GPU.

00:22:33.970 --> 00:22:36.370
We can have multiple
buffers going at once.

00:22:36.490 --> 00:22:38.690
You know,
we're not restricted to certain movies.

00:22:38.950 --> 00:22:43.390
So one of the fundamental
bottlenecks of the old QuickDraw

00:22:43.770 --> 00:22:48.240
rendering model was that everything
went through a single buffer.

00:22:48.300 --> 00:22:51.300
The decompressor would
decode into a buffer,

00:22:51.350 --> 00:22:54.620
and then the hardware would start
pulling out of that onto the screen.

00:22:54.680 --> 00:22:58.000
And the decompressor couldn't start
writing into that until the hardware

00:22:58.130 --> 00:22:59.360
was finished reading from it.

00:22:59.420 --> 00:23:02.340
So there was just a
fundamental bottleneck.

00:23:02.460 --> 00:23:03.910
So now we have multiple buffers.

00:23:03.920 --> 00:23:08.220
The decompressor can start decoding
into a completely different buffer while

00:23:08.220 --> 00:23:10.180
the hardware is using the other one.

00:23:10.260 --> 00:23:12.000
So we got rid of that restriction.

00:23:12.040 --> 00:23:14.620
And we're not restricted to movies
that have single video tracks

00:23:14.670 --> 00:23:17.520
with single codecs that support
the right pixel formats and

00:23:17.520 --> 00:23:19.080
aren't transformed or something.

00:23:19.230 --> 00:23:22.180
You can use any movie
with a visual context.

00:23:22.760 --> 00:23:25.700
And because we've decoupled the
decoding from the presentation,

00:23:25.700 --> 00:23:27.540
you get more asynchronous behavior.

00:23:27.700 --> 00:23:31.540
Like our video media handler will
actually be decoding ahead of time

00:23:31.680 --> 00:23:34.340
from what you're actually displaying.

00:23:35.730 --> 00:23:37.440
So how do you create this thing?

00:23:37.470 --> 00:23:42.600
Well, in "Tiger" we're shipping
an OpenGL texture context.

00:23:42.600 --> 00:23:45.360
Now the visual context is
actually an abstraction,

00:23:45.360 --> 00:23:48.040
an abstract base class in
the object-oriented terms.

00:23:48.200 --> 00:23:50.600
There could be many different
kinds of visual contexts.

00:23:50.660 --> 00:23:53.100
But for now we're shipping
the OpenGL texture context.

00:23:53.100 --> 00:23:58.100
And it gives you a stream of
OpenGL textures for your video frames.

00:23:58.200 --> 00:24:00.080
So you're going to need
to set up OpenGL first.

00:24:00.090 --> 00:24:04.100
And we use the core OpenGL objects
to create this thing.

00:24:04.100 --> 00:24:07.070
That's CGL context and CGL pixel format.

00:24:07.100 --> 00:24:10.050
And most of you probably don't
use core OpenGL directly,

00:24:10.050 --> 00:24:12.590
so you'll be using
Cocoa or Carbon to do that.

00:24:12.600 --> 00:24:16.760
And Cocoa developers can use
the NSOpenGL context and get

00:24:16.760 --> 00:24:18.100
the underlying CGL context.

00:24:18.100 --> 00:24:19.910
Same with Carbon using AGL.

00:24:20.070 --> 00:24:23.930
But the Carbon thing is new in "Tiger."
So there's a new function to get

00:24:23.970 --> 00:24:26.100
a CGL context from an AGL context.

00:24:26.100 --> 00:24:27.870
Same with pixel format.

00:24:28.100 --> 00:24:33.130
And here's a little example code
creating the texture context.

00:24:33.580 --> 00:24:38.320
Now, the textures that come out of this
thing can only be used with this

00:24:38.410 --> 00:24:42.000
CGL context that you pass into it,
unless you create a shared context,

00:24:42.000 --> 00:24:45.590
which is a more detailed OpenGL topic.

00:24:46.380 --> 00:24:49.710
So now you have these two pieces,
you want to connect them together.

00:24:49.840 --> 00:24:51.250
So you set movie visual context.

00:24:51.380 --> 00:24:54.300
This is a replacement
for set movie G world.

00:24:54.300 --> 00:24:57.300
And it's how you direct a movie
to use your visual context.

00:24:57.590 --> 00:25:00.430
And note,
you can't have two movies playing into

00:25:00.430 --> 00:25:03.090
the same visual context at the same time.

00:25:03.200 --> 00:25:05.980
So this call will fail if another
movie is already connected.

00:25:06.050 --> 00:25:08.360
If you want to play multiple movies,
you're going to have to do

00:25:08.360 --> 00:25:09.620
the compositing yourself.

00:25:09.670 --> 00:25:12.760
You have two separate texture contexts,
you'll get the textures and

00:25:12.760 --> 00:25:14.540
use OpenGL to composite them.

00:25:14.600 --> 00:25:19.380
Now this can also fail if your hardware
does not support the size of video,

00:25:19.380 --> 00:25:22.960
or it's just not
sufficient for this movie.

00:25:23.700 --> 00:25:25.300
More on that later.

00:25:25.460 --> 00:25:30.700
Okay, now calling setMovieVisualContext
with null is also a little special.

00:25:31.000 --> 00:25:35.250
Unlike setMovieGerold with null,
this will actually tell

00:25:35.250 --> 00:25:36.700
your movie to not draw.

00:25:36.700 --> 00:25:40.210
setMovieGerold actually,
when you pass null, it would tell it to

00:25:40.210 --> 00:25:43.190
get the current G-roll,
whatever that happened to be, you know,

00:25:43.190 --> 00:25:44.700
just like the new movie calls.

00:25:44.710 --> 00:25:47.700
But this is actually going
to tell it to not render.

00:25:47.850 --> 00:25:50.150
And one important note,
when you have a movie that's

00:25:50.150 --> 00:25:53.020
targeted at a visual context,
and for some reason you need to

00:25:53.300 --> 00:25:55.870
actually target it at a G-world,
first go through a null

00:25:55.870 --> 00:25:59.340
visual context to actually,
you know, make it stop using the visual

00:25:59.380 --> 00:26:00.700
context before switching.

00:26:00.700 --> 00:26:02.990
You know, important little detail here.

00:26:03.860 --> 00:26:07.380
Okay, the ICM can drive a visual
context new as well,

00:26:07.420 --> 00:26:09.140
not just a movie.

00:26:09.290 --> 00:26:13.700
So you can use ICM decompression
session create for visual context.

00:26:13.860 --> 00:26:16.190
And this gives you access to
the visual context at a lower

00:26:16.190 --> 00:26:17.700
level than the movie toolbox.

00:26:17.860 --> 00:26:22.840
And there'll be more on this ICM topic
tomorrow at 3:30 in next generation

00:26:22.920 --> 00:26:25.130
video formats for QuickTime.

00:26:25.540 --> 00:26:29.180
Okay, the ICM can drive a visual
context new as well,

00:26:29.410 --> 00:26:30.940
not just a movie.

00:26:30.940 --> 00:26:35.470
So you can use ICM decompression
session create for visual context.

00:26:35.540 --> 00:26:37.840
And this gives you access to
the visual context at a lower

00:26:37.990 --> 00:26:39.500
level than the movie toolbox.

00:26:39.500 --> 00:26:44.660
And there'll be more on this ICM topic
tomorrow at 3:30 in next generation

00:26:44.710 --> 00:26:46.910
video formats for QuickTime.

00:26:55.500 --> 00:26:59.640
Now this will pull out that texture,
give you a copy of it for

00:26:59.640 --> 00:27:02.810
that same timestamp that you
used in the previous function.

00:27:02.860 --> 00:27:07.470
Note that this uses the core foundation
retain and release semantics,

00:27:07.580 --> 00:27:10.360
so be sure to release those
textures when you're done with them.

00:27:10.430 --> 00:27:13.800
Otherwise, you'll chew through your video
card's memory in no time.

00:27:13.800 --> 00:27:17.900
The last one here,
Qt OpenGL Texture Context Task.

00:27:17.900 --> 00:27:20.850
This is used for giving the
texture context a little

00:27:21.010 --> 00:27:22.800
time to do some housekeeping.

00:27:22.800 --> 00:27:25.070
It's got to check all those textures,
see if they're ready to

00:27:25.280 --> 00:27:26.800
be reused or something.

00:27:26.940 --> 00:27:32.170
And, it's a non-thread-safe thing,
so more on thread safety later.

00:27:33.240 --> 00:27:35.750
With that,
I hand it over to Ken to talk about those

00:27:35.890 --> 00:27:38.210
textures that you get out of that thing.

00:27:39.160 --> 00:27:41.080
Thanks, Sean.

00:27:41.180 --> 00:27:42.860
All right,
so now we get into core video a

00:27:42.860 --> 00:27:46.580
little bit and give you guys a quick
overview of what that's all about.

00:27:46.780 --> 00:27:48.760
So, I've seen this diagram a
couple of times before.

00:27:48.760 --> 00:27:53.160
I'm mainly going to go over the core
video timing and buffering aspects.

00:27:54.030 --> 00:27:57.670
So, there's two main pieces
to core video today.

00:27:57.720 --> 00:27:59.700
There's buffer management.

00:27:59.710 --> 00:28:03.300
We wanted to have a common
data interchange format

00:28:03.300 --> 00:28:05.290
between QuickTime and OpenGL.

00:28:05.330 --> 00:28:06.540
That was always really tricky before.

00:28:06.540 --> 00:28:08.890
G-worlds were very non-optimal.

00:28:08.900 --> 00:28:11.900
You could get the bits out of a
G-world and get it into a texture,

00:28:11.900 --> 00:28:13.900
but it was kind of a pain in the butt.

00:28:13.900 --> 00:28:16.470
And, if you didn't write the drivers,
knowing how to do that

00:28:16.470 --> 00:28:17.900
correctly is kind of tricky.

00:28:17.900 --> 00:28:20.890
The other part of it is
display synchronization.

00:28:20.910 --> 00:28:23.700
In this whole scheme,
you want to know when

00:28:23.700 --> 00:28:25.690
to go and ask QuickTime,
"When should I ask for

00:28:25.720 --> 00:28:29.410
the next frame?" And,
I'll talk about that in a minute.

00:28:29.940 --> 00:28:34.530
So, first a little more detail
on the buffering model.

00:28:34.940 --> 00:28:37.240
All the buffer objects that
you get out of QuickTime,

00:28:37.240 --> 00:28:39.500
they're all core
foundation-based objects.

00:28:39.500 --> 00:28:43.330
So, as Sean said, you use CFRetain,
CFRelease on them.

00:28:43.400 --> 00:28:47.220
They're sort of an abstract base class,
if you will, that defines a couple of

00:28:47.400 --> 00:28:48.380
interesting behaviors.

00:28:48.840 --> 00:28:52.090
There's this concept of buffer
attachments for metadata,

00:28:52.540 --> 00:28:56.100
things like timestamps might go there,
color space information,

00:28:56.100 --> 00:28:56.850
that sort of thing.

00:28:56.960 --> 00:29:00.520
There aren't any ones really defined yet,
but we expect that there

00:29:00.780 --> 00:29:01.900
will be at some point.

00:29:01.920 --> 00:29:04.660
There's also then a couple of
concrete buffer types you'll

00:29:04.670 --> 00:29:06.340
run into in the Tiger timeframe.

00:29:06.430 --> 00:29:10.700
There's CVPixelBuffer
and CVOpenGLTexture.

00:29:10.700 --> 00:29:14.800
And again, diagram,
you can sort of see how that works.

00:29:14.840 --> 00:29:21.230
So, just real briefly on CVPixelBuffer,
this is how internally the ICM would

00:29:21.230 --> 00:29:22.890
like decode memory-based data.

00:29:22.900 --> 00:29:26.610
Like if it wanted to, you know,
for a codec, it needs to be able to put

00:29:26.730 --> 00:29:28.120
things into main memory.

00:29:28.500 --> 00:29:30.290
It just doesn't want to
put them right into VRAM,

00:29:30.290 --> 00:29:34.150
so it'll use a CVPixelBuffer for that.

00:29:35.060 --> 00:29:37.410
I guess that's all I had to say there,
sorry.

00:29:37.410 --> 00:29:41.230
Oh, and then this is the foundation
as well for the new ICM APIs.

00:29:41.240 --> 00:29:44.400
And again, tomorrow at 3:30,
Sam will talk about

00:29:44.400 --> 00:29:45.870
that a little bit more.

00:29:46.070 --> 00:29:48.850
But, here's the one that's
interesting for you guys,

00:29:48.910 --> 00:29:50.690
the CVO OpenGL Texture Object.

00:29:50.690 --> 00:29:54.400
So, this basically represents a
high-level abstraction wrapper,

00:29:54.400 --> 00:29:58.000
whatever you want to call it,
around an OpenGL texture.

00:29:58.170 --> 00:30:00.960
And,
its job is internally to deal with the

00:30:01.040 --> 00:30:06.090
details of how do I get texture data,
if it's YUV, is it 2VY, is it YUVS,

00:30:06.090 --> 00:30:09.930
is it RGBA, is it A, B, G, R, A, RGB,
whatever.

00:30:10.010 --> 00:30:12.000
So, it figures out how to
get that into OpenGL.

00:30:12.000 --> 00:30:15.000
It knows about all of our custom
extensions that we use in Quartz,

00:30:15.000 --> 00:30:20.000
you know, to avoid memory copies,
that whole thing.

00:30:20.000 --> 00:30:22.000
The API is pretty straightforward.

00:30:22.000 --> 00:30:24.000
You basically can get
back the texture target.

00:30:24.000 --> 00:30:26.800
These days, it's pretty much always going
to be texture rectangle.

00:30:27.000 --> 00:30:29.800
It'll give you back the size,
what the texture ID is,

00:30:29.870 --> 00:30:31.000
that sort of thing.

00:30:31.000 --> 00:30:33.590
And, you can use OpenGL to query
more additional internal

00:30:33.680 --> 00:30:35.000
information if you care.

00:30:35.000 --> 00:30:38.090
The one thing I want to point
out is you should really ask

00:30:38.090 --> 00:30:40.000
us for the texture coordinates.

00:30:40.040 --> 00:30:42.370
So, if you're using either
of these two calls here,

00:30:42.390 --> 00:30:46.000
if it's something like DV video,
the texture might be 720 by 480,

00:30:46.000 --> 00:30:48.520
but you might really only want
to use like a sub-region of that,

00:30:48.610 --> 00:30:51.110
because there's undefined
regions and you don't want to

00:30:51.150 --> 00:30:53.060
display garbage to your users.

00:30:54.530 --> 00:30:57.290
So, the next part of Core Video is
the Display Link,

00:30:57.290 --> 00:30:59.850
and this is sort of responsible
for driving the timing

00:30:59.850 --> 00:31:01.400
into the entire system.

00:31:01.400 --> 00:31:05.400
So, overall,
with this new visual context thing,

00:31:05.400 --> 00:31:07.400
it's kind of a pull model,
sort of like Core Audio.

00:31:07.400 --> 00:31:11.460
The idea is that every now and then
you basically go and ask QuickTime,

00:31:11.530 --> 00:31:14.740
"Hey, is there a new frame available for
some upcoming display time?" And,

00:31:14.800 --> 00:31:18.020
Display Link's job is to
basically tell you when you

00:31:18.640 --> 00:31:20.090
should go and make that call.

00:31:20.400 --> 00:31:24.900
It provides timestamp information as to
when the next sort of vertical blanking

00:31:24.900 --> 00:31:28.400
period on the monitor is going to
happen for whatever display you're on.

00:31:28.400 --> 00:31:32.400
Contrary to popular belief,
this does apply to flat panels as well.

00:31:32.400 --> 00:31:36.400
They really do have
VBL sort of timing idea,

00:31:36.400 --> 00:31:38.380
even if they don't really
have a blanking period.

00:31:38.400 --> 00:31:42.950
That timestamp that it will give you is
a little data structure that's actually

00:31:42.970 --> 00:31:45.850
required by the QuickTime visual context,
so it knows when the next

00:31:46.380 --> 00:31:47.360
display time is going to be.

00:31:47.400 --> 00:31:50.400
The interesting thing is that
it's not just a display time.

00:31:50.400 --> 00:31:53.400
It's not like the time right
now when the callback is made.

00:31:53.400 --> 00:31:55.360
We're actually trying to
estimate when the next display

00:31:55.360 --> 00:31:58.350
period on your display is,
so it's a little bit forward in time.

00:31:58.410 --> 00:32:00.980
But that gives you time to
do the OpenGL rendering,

00:32:00.980 --> 00:32:03.200
set up calls, core image,
whatever you want to do

00:32:03.250 --> 00:32:04.380
before the display happens.

00:32:04.510 --> 00:32:07.520
There are separate render and
display callbacks that are sort of

00:32:07.590 --> 00:32:09.400
happen one right after the other.

00:32:09.400 --> 00:32:11.400
You can kind of use
that however you'd like.

00:32:11.400 --> 00:32:14.300
We might define some more
behaviors there in the future,

00:32:14.560 --> 00:32:16.190
but it's pretty straightforward.

00:32:16.400 --> 00:32:20.400
And all of these callbacks happen
on a dedicated high priority thread.

00:32:20.400 --> 00:32:22.400
It's kind of like core audio.

00:32:22.440 --> 00:32:25.660
We're not so high that we'll bump
off the Windows Server or core audio

00:32:25.660 --> 00:32:28.400
or screw anything like that up,
so don't worry there.

00:32:28.400 --> 00:32:30.990
And it's similar to the same
high priority thread that

00:32:30.990 --> 00:32:32.400
we use in the DVD player.

00:32:32.400 --> 00:32:35.480
And you can create one of
these things from a CG direct

00:32:35.480 --> 00:32:37.400
display ID or multiple ones.

00:32:37.400 --> 00:32:39.770
And there's calls to switch
back and forth if you move

00:32:39.900 --> 00:32:41.350
from one display to the other.

00:32:41.400 --> 00:32:43.400
There's calls to do that.

00:32:44.270 --> 00:32:47.920
So just to give you a sort of
graphical idea of what goes on here,

00:32:47.920 --> 00:32:52.720
the thread that's running basically picks
up information from I/O Kit that says,

00:32:52.720 --> 00:32:55.090
hey, here's when the last VBL happened.

00:32:55.530 --> 00:32:57.460
Here's sort of the time
span from the last one.

00:32:57.460 --> 00:33:01.620
So we can sort of guesstimate or estimate
when the next one is going to happen

00:33:01.620 --> 00:33:03.380
and then feed that timestamp to you.

00:33:03.410 --> 00:33:06.480
That triggers the callbacks,
and then you can basically go all the

00:33:06.480 --> 00:33:09.520
way up through your custom pipeline,
ask QuickTime, hey,

00:33:09.520 --> 00:33:11.530
what's the next frame,
and then start pulling it back

00:33:11.640 --> 00:33:13.190
through all the other custom effects.

00:33:14.200 --> 00:33:16.280
With that,
we'll bring Sean back up and he'll give

00:33:16.300 --> 00:33:19.070
you a demo of how this stuff works.

00:33:25.800 --> 00:33:26.770
All right.

00:33:26.910 --> 00:33:31.900
So, now that you've seen all the pieces
for the pipeline that are required,

00:33:31.900 --> 00:33:34.700
visual context, the buffers,
the display link,

00:33:34.700 --> 00:33:37.850
I'll show you a little app that uses it.

00:33:38.460 --> 00:33:44.470
Some of you may have seen this in
an earlier session in the week.

00:33:44.910 --> 00:33:48.230
This is using the display link
to get its rendering callbacks,

00:33:48.230 --> 00:33:50.360
and is pulling the textures
out of the visual context,

00:33:50.360 --> 00:33:54.490
you know, like we talked about,
and rendering them with OpenGL.

00:33:54.570 --> 00:33:57.540
So, since we're using OpenGL,
it's pretty easy to do, you know,

00:33:57.540 --> 00:33:59.920
this kind of thing,
move the texture around,

00:34:00.060 --> 00:34:03.380
rotate it around, so forth.

00:34:03.380 --> 00:34:07.230
So, we thought, well,
why render one texture when

00:34:07.260 --> 00:34:07.980
you can hold on to them?

00:34:07.980 --> 00:34:09.180
Because we have multiple buffers now.

00:34:09.180 --> 00:34:11.820
You don't have to use that
buffer and get rid of it.

00:34:11.820 --> 00:34:12.680
You can just hold on to it.

00:34:12.750 --> 00:34:16.960
So, we have an array of these frames,
and so forth.

00:34:16.980 --> 00:34:17.950
That is the way I love Helen.

00:34:18.010 --> 00:34:20.710
So, you can see, we're rendering many,
many,

00:34:20.720 --> 00:34:25.090
many video frames every single pass.

00:34:26.400 --> 00:34:29.320
So we can see here,
here's the dimensions of this

00:34:29.320 --> 00:34:31.160
movie playing at full rate.

00:34:31.210 --> 00:34:35.840
And we're rendering 46
frames every single time.

00:34:35.840 --> 00:34:38.240
We're going to run that.

00:34:38.290 --> 00:34:40.300
Remember,
these are high-definition frames.

00:34:40.370 --> 00:34:43.140
So you can see, once you have the video
up on the graphics card,

00:34:43.140 --> 00:34:44.860
you can do a lot with it.

00:34:44.860 --> 00:34:50.590
And look at all the-- a
lot of horsepower there.

00:34:51.100 --> 00:34:53.100
"I've asked you to fight my war.

00:34:53.100 --> 00:34:59.680
You already have." "The loser will
burn before night falls." "Immortality!

00:34:59.680 --> 00:35:00.640
Take it!

00:35:00.640 --> 00:35:05.880
It's yours!" There's that.

00:35:09.690 --> 00:35:14.620
So that was showing the set movie
visual context APIs that we were using.

00:35:14.650 --> 00:35:19.260
We also added capabilities
to use the ICM APIs.

00:35:19.270 --> 00:35:21.180
Hey.

00:35:21.630 --> 00:35:24.570
So this is using a sequence grabber.

00:35:24.800 --> 00:35:27.540
and extracting the
frames off the DV camera,

00:35:27.540 --> 00:35:31.480
feeding them directly into the ICM,
which has been connected

00:35:31.480 --> 00:35:33.140
to the visual context.

00:35:33.250 --> 00:35:38.010
So,
here we can ignore the zero zero here.

00:35:43.200 --> 00:35:46.500
A few more.

00:35:47.620 --> 00:35:49.320
So look at that.

00:35:49.320 --> 00:35:51.320
Almost 300 frames here.

00:35:51.910 --> 00:35:53.760
This will be sample code.

00:35:53.910 --> 00:35:54.900
It's not on the DVD.

00:35:54.900 --> 00:35:56.930
It's not available yet,
but in a week or two

00:35:56.930 --> 00:35:58.900
we'll have it to you.

00:35:58.900 --> 00:36:00.900
So, there's that.

00:36:00.900 --> 00:36:07.900
Alright, so, there you go.

00:36:15.530 --> 00:36:16.400
Back to the slides.

00:36:16.400 --> 00:36:19.400
Okay, so now for Frank.

00:36:19.400 --> 00:36:23.400
He's going to show you how to use
OpenGL to do more interesting effects.

00:36:26.600 --> 00:36:29.450
Thank you, Sean.

00:36:29.700 --> 00:36:31.060
Good afternoon.

00:36:31.100 --> 00:36:33.780
I will talk a little bit more now
what benefits we can add to this

00:36:33.800 --> 00:36:36.000
new pipeline by customizing it.

00:36:36.010 --> 00:36:39.520
And for that,
we use the OpenGL processing.

00:36:40.100 --> 00:36:46.440
"You've seen that diagram,
I hope everybody has it now in his mind.

00:36:46.440 --> 00:36:48.500
And I will talk a little bit
more about the gray area here,

00:36:48.500 --> 00:36:53.280
so what can we do with OpenGL when
we use our new video pipeline?"

00:36:53.500 --> 00:36:56.450
So, the added benefits that we
bring in by using OpenGL is,

00:36:56.530 --> 00:36:57.890
first of all, we have blending.

00:36:57.990 --> 00:37:00.440
So, you can compose the stuff
on top of each other,

00:37:00.470 --> 00:37:03.360
and you can use the blending
effects that you have in OpenGL.

00:37:03.360 --> 00:37:05.800
I will show that a little
bit later on in the demo.

00:37:05.900 --> 00:37:07.160
And, the other part is geometry.

00:37:07.160 --> 00:37:10.180
So, if you think of like putting this
into like some games or some scenes

00:37:10.330 --> 00:37:12.630
that you want to play the stuff,
and you've seen it now

00:37:12.630 --> 00:37:15.590
nicely in Sean's demo,
like how he can twist things around and

00:37:15.670 --> 00:37:17.780
do all the funky kind of stuff with it.

00:37:18.830 --> 00:37:21.620
So, in an overview,
what is it really now about?

00:37:21.620 --> 00:37:23.230
So, the first part,
I want to take a little

00:37:23.230 --> 00:37:23.960
bit away the fear.

00:37:23.980 --> 00:37:26.880
So, you don't have to be an OpenGL guru
to really use our stuff.

00:37:26.890 --> 00:37:30.450
As Ken pointed out already earlier,
we take a lot of the pain away from

00:37:30.450 --> 00:37:33.760
you by using all the hard stuff with
all the texture management for you.

00:37:33.760 --> 00:37:35.880
So, this is really,
really easy for you to use.

00:37:35.920 --> 00:37:39.380
The other really important
thing to keep in mind is now,

00:37:39.380 --> 00:37:40.580
we free up the CPU.

00:37:40.630 --> 00:37:44.020
So, you can do additional processing
that's happening on the graphics card.

00:37:44.170 --> 00:37:46.900
The CPU is now more free
to decompress video,

00:37:46.930 --> 00:37:48.640
so you have less frame droppings.

00:37:48.670 --> 00:37:50.650
You can use more streams
at the same time.

00:37:50.660 --> 00:37:54.300
On the other hand, also, as we've seen,
like, with the resizing,

00:37:54.320 --> 00:37:55.700
your UI is more fluid.

00:37:55.720 --> 00:37:58.940
You have better feedback on this whole
stuff because the CPU has more cycles

00:37:58.960 --> 00:38:00.740
to run on your user interaction.

00:38:00.760 --> 00:38:05.770
So, that makes the live
resizing and zooming really,

00:38:05.770 --> 00:38:07.560
really easy for you to do.

00:38:08.180 --> 00:38:10.430
So for those who are new to OpenGL,
let me go a little bit

00:38:10.430 --> 00:38:13.040
into the terminology,
and this is down the, ready,

00:38:13.140 --> 00:38:15.100
five second overview of this whole part.

00:38:15.280 --> 00:38:20.770
OpenGL normally draws in like primitives,
it's like rectangles and that is the

00:38:20.770 --> 00:38:23.100
basic foundation what they draw with.

00:38:23.250 --> 00:38:27.430
So what we can do now with images,
it's what we call a texture, and that's,

00:38:27.480 --> 00:38:29.210
you heard this terminology
a couple of times already,

00:38:29.210 --> 00:38:32.130
and that's pretty much like we
skin these drawing primitives,

00:38:32.190 --> 00:38:34.080
and that's how they end up on the screen.

00:38:34.420 --> 00:38:37.240
There's, as you probably missed
now all the OpenGL talks,

00:38:37.240 --> 00:38:41.540
but there is a lab session later on in
which you can get a little bit more of

00:38:41.540 --> 00:38:44.380
your fingers on what OpenGL is all about.

00:38:45.030 --> 00:38:49.440
As Sean already pointed out,
thread safety is an important thing.

00:38:49.470 --> 00:38:52.850
Since OpenGL is not reentrant,
we have to make sure that

00:38:53.260 --> 00:38:54.400
we work with thread safety.

00:38:54.400 --> 00:38:57.200
And for that part,
we have to make sure that we

00:38:57.240 --> 00:39:00.510
use like Pthread mutex logs,
or we can use like an

00:39:00.510 --> 00:39:03.540
NS log from some part,
or we can use like a shared

00:39:03.540 --> 00:39:05.100
context that gets you around.

00:39:05.140 --> 00:39:07.090
You can use for multiple
threads and Core Video,

00:39:07.090 --> 00:39:09.840
as we already seen,
uses a separate thread to get

00:39:10.260 --> 00:39:14.780
around the thread safety issue
that you normally would run into.

00:39:14.820 --> 00:39:19.450
You have to use these logs
also when you use our new API,

00:39:19.450 --> 00:39:22.100
the QtOpenGL texture context.

00:39:22.100 --> 00:39:25.920
But there's at least one part,
the "Is new texture available?"

00:39:26.020 --> 00:39:26.720
that is thread safe.

00:39:26.810 --> 00:39:29.100
You can do that outside the logging part.

00:39:29.100 --> 00:39:31.600
And for those of you
who want to use AppKit,

00:39:31.600 --> 00:39:34.820
I want to point out that you
have to override the update

00:39:34.820 --> 00:39:39.000
call and wrap this with a log,
because otherwise,

00:39:39.000 --> 00:39:42.140
since AppKit will do some OpenGL calls,
you will run into some

00:39:42.140 --> 00:39:43.550
thread safety issues.

00:39:44.590 --> 00:39:46.410
So, getting now a little bit
into the deeper part,

00:39:46.410 --> 00:39:47.680
how does the whole thing work?

00:39:47.700 --> 00:39:51.200
So, you've seen all the pieces,
and I want to show you in a quick

00:39:51.200 --> 00:39:54.040
overview how we really get now
the whole thing to the screen.

00:39:54.110 --> 00:39:55.990
So, in the first part,
I'm setting up here a display link,

00:39:55.990 --> 00:39:59.760
and you can see I create one,
I set up my two callbacks for

00:39:59.860 --> 00:40:02.260
the render and the display part,
and after that,

00:40:02.260 --> 00:40:05.970
all I have to do is basically start it,
and now I have my timing service running,

00:40:05.970 --> 00:40:10.160
and I have the two callbacks
that will all the time be getting

00:40:10.240 --> 00:40:12.140
called from our display link.

00:40:13.590 --> 00:40:15.150
On the rendering part,
we see now the pieces

00:40:15.150 --> 00:40:16.250
here that come together.

00:40:16.270 --> 00:40:18.290
So this is now my render callback.

00:40:18.290 --> 00:40:22.650
And all what I'm doing here is I check
if there's a texture available.

00:40:22.650 --> 00:40:24.460
If yes, then I can throw away my old one.

00:40:24.460 --> 00:40:25.580
I don't need to keep on.

00:40:25.580 --> 00:40:27.910
I don't need the fancy
effect that Sean has shown.

00:40:28.040 --> 00:40:30.840
So I'll just throw the old texture away,
get the new one,

00:40:30.840 --> 00:40:34.420
and be ready now actually in the next
step to bring this up to the screen.

00:40:34.830 --> 00:40:36.140
So how do we bring it to the screen?

00:40:36.140 --> 00:40:38.210
It's a little bit more detailed here.

00:40:38.300 --> 00:40:41.030
The first part,
I have to make sure that I clear out

00:40:41.030 --> 00:40:43.020
whatever was there on the screen.

00:40:43.220 --> 00:40:44.560
I just give you an overview here.

00:40:44.560 --> 00:40:47.450
There's details that you
might have to look into,

00:40:47.450 --> 00:40:49.960
like,
depending on what you are doing there.

00:40:50.120 --> 00:40:52.360
And the second part
is I bind the texture.

00:40:52.460 --> 00:40:55.070
And what does that mean is, like,
OpenGL now knows this is the

00:40:55.080 --> 00:40:56.690
texture that I want to draw with.

00:40:56.720 --> 00:41:02.200
This is the one that I'm
skinning my whole rectangle with.

00:41:02.280 --> 00:41:03.560
And then I draw a rectangle.

00:41:03.580 --> 00:41:05.770
And this is simply a quad,
as you can see,

00:41:05.890 --> 00:41:08.320
with the coordinates and I'm
mapping the texture coordinates to

00:41:08.320 --> 00:41:10.270
my rectangle and that's all I need.

00:41:10.300 --> 00:41:14.150
And the last step, et voila,
I bring it with flush to the screen

00:41:14.150 --> 00:41:16.720
and we'll see the image on the screen.

00:41:16.890 --> 00:41:19.200
That is how simple it is for you to draw.

00:41:19.290 --> 00:41:21.020
And now I will show you
the whole thing on a demo.

00:41:21.200 --> 00:41:23.120
Please, demo application.

00:41:23.120 --> 00:41:28.630
Okay.

00:41:33.180 --> 00:41:34.860
So this is a little sample
application that I wrote.

00:41:34.860 --> 00:41:36.560
It's, I call it, Live Video Mixer.

00:41:36.560 --> 00:41:42.820
And what I will bring in now
is just three video files.

00:41:43.280 --> 00:41:46.690
Which are a little pool beard game
that we had and we just shot this

00:41:46.690 --> 00:41:49.960
with three cameras at the same time.

00:41:50.020 --> 00:41:53.440
So I'm trying to imitate
now his studio here.

00:41:53.520 --> 00:41:56.400
What I can do is now I play the
movies and I have the different

00:41:56.400 --> 00:41:59.320
camera angles at the bottom part here.

00:41:59.670 --> 00:42:02.200
And since OpenGL allows
me to compositing,

00:42:02.280 --> 00:42:07.210
so I can superimpose the
close-up of that shot.

00:42:07.750 --> 00:42:09.080
And say, well, actually, let me see.

00:42:09.080 --> 00:42:10.800
Like,
I want to see the other camera angle.

00:42:10.820 --> 00:42:12.520
See.

00:42:12.560 --> 00:42:14.470
Yeah, I see struggling with
this part a little bit.

00:42:14.480 --> 00:42:15.480
And I can do this fluently.

00:42:15.480 --> 00:42:19.510
And you see that's like no problem
to run this on any kind of CPU.

00:42:19.680 --> 00:42:22.360
And I can use funny stuff,
which what you call like multi-texturing.

00:42:22.360 --> 00:42:27.090
I can use masks and put this
video in some funky shapes.

00:42:27.730 --> 00:42:31.320
I can use this channel,
and I can actually say, well,

00:42:31.320 --> 00:42:32.720
now they're laying on top of each other.

00:42:32.720 --> 00:42:35.520
OK, let me take this one,
move this up in this corner.

00:42:35.520 --> 00:42:38.450
You see how nice and fluent this
runs while the movie is playing back.

00:42:38.460 --> 00:42:41.870
And I'm really playing back
like three streams here.

00:42:42.910 --> 00:42:46.750
I have like a
semi-transparent shape here,

00:42:46.750 --> 00:42:48.270
and let me position
this into this corner.

00:42:52.000 --> 00:42:54.620
And even for the background part,
I can do this all the time

00:42:54.650 --> 00:42:56.540
and play this up and down.

00:42:56.640 --> 00:43:00.140
And with that,
we would like to go back to the slides.

00:43:00.210 --> 00:43:02.170
Thank you.

00:43:05.680 --> 00:43:07.950
So to quickly summarize once
again what we've seen here,

00:43:07.960 --> 00:43:13.980
I've used the display link to have some
precise timing and that helped a lot.

00:43:13.980 --> 00:43:16.640
And I've done these kind of
applications before here and I can

00:43:16.640 --> 00:43:18.060
tell you it's worth tons of code.

00:43:18.060 --> 00:43:20.360
And here's like really
a few lines to do this.

00:43:20.420 --> 00:43:23.110
And then I use for the
compositing the GL blend part.

00:43:23.150 --> 00:43:26.000
So I mean, just throwing a little bit of
terminology for you so that you

00:43:26.000 --> 00:43:29.120
can find out later on in the books,
OK, what's this all about?

00:43:29.160 --> 00:43:32.000
I showed you how to use masking
by using multi-textures,

00:43:32.020 --> 00:43:32.960
which makes this really easy.

00:43:32.960 --> 00:43:35.490
It's been a pain to do that beforehand.

00:43:35.610 --> 00:43:39.000
Using for the resizing part,
we can do this simply with a GL viewport.

00:43:39.220 --> 00:43:41.740
I normalize the coordinates so that
makes it very easy for me to work

00:43:41.740 --> 00:43:43.520
in different coordinate spaces.

00:43:43.560 --> 00:43:46.890
And with these little ingredients,
I can create a really easy

00:43:46.890 --> 00:43:49.720
application that shows a little
bit more fun in this video.

00:43:49.770 --> 00:43:55.710
And with that part,
I will take the stage back to Ken.

00:43:58.100 --> 00:43:59.100
Thanks Frank.

00:43:59.100 --> 00:44:02.600
Alright, so this is sort of my
favorite part of this.

00:44:02.660 --> 00:44:04.780
So, yeah you can do all
this fun OpenGL stuff,

00:44:04.950 --> 00:44:06.720
but you know earlier in this week
there seemed to be a lot of interest in

00:44:06.760 --> 00:44:08.100
doing all this cool effects processing.

00:44:08.100 --> 00:44:12.030
So, how are we going to get this
into this whole new pipeline?

00:44:12.100 --> 00:44:16.100
So, integrating Core Image is
actually very straightforward.

00:44:16.140 --> 00:44:19.280
I'm just going to sort of briefly cover
a little bit of the Core Image API here

00:44:19.400 --> 00:44:21.100
in case you guys missed the session.

00:44:21.100 --> 00:44:24.300
In this case,
you just create a CI context with

00:44:24.300 --> 00:44:27.100
your OpenGL context in pixel format.

00:44:27.100 --> 00:44:31.390
And then,
once you've got that CV OpenGL texture

00:44:31.390 --> 00:44:35.000
object out of QuickTime's visual context,
you basically need to create

00:44:35.000 --> 00:44:36.100
a CI image to represent it.

00:44:36.100 --> 00:44:40.420
And, CI Core Image has a very nice
API for just creating a CI image

00:44:40.450 --> 00:44:43.100
out of an arbitrary OpenGL texture.

00:44:43.100 --> 00:44:45.550
So, in this case,
I basically fetch out the texture's name,

00:44:45.550 --> 00:44:49.030
its size, is it flipped,
that has to do with whether

00:44:49.030 --> 00:44:51.080
or not the origin is the
upper lower left hand corner.

00:44:51.230 --> 00:44:54.100
Most of the stuff coming out
of QuickTime will be flipped.

00:44:54.100 --> 00:44:58.250
And then, basically create the CI image
with all those parameters.

00:44:59.130 --> 00:45:02.700
So, once you've got that,
you can run it through a

00:45:02.810 --> 00:45:06.580
CI filter just like any other,
you know, core CI image.

00:45:06.670 --> 00:45:11.080
You basically set that CI image
that you created to the input,

00:45:11.270 --> 00:45:13.280
in this case just the
input image to the filter,

00:45:13.350 --> 00:45:16.200
and then you can basically
pull the result right back

00:45:16.200 --> 00:45:18.280
out again as another CI image.

00:45:18.360 --> 00:45:21.590
Then you basically use CI like
you would any other thing,

00:45:21.600 --> 00:45:25.190
and you call, in this case I'm using
drawImageAtPointFromRect,

00:45:25.210 --> 00:45:27.030
I think that's the
method name on that one.

00:45:27.040 --> 00:45:30.470
And again, you'll note that I'm using the
getCleanRect in this case to

00:45:30.520 --> 00:45:34.500
make sure that I'm only rendering
the sub-region that's defined

00:45:34.500 --> 00:45:37.520
by the original CVOpenGL texture.

00:45:38.960 --> 00:45:41.300
So, a couple of notes on this.

00:45:41.380 --> 00:45:44.580
Both the CI image,
well first the CI images are immutable,

00:45:44.580 --> 00:45:47.420
so every time you get a
new frame out of QuickTime,

00:45:47.420 --> 00:45:50.800
you're basically going to have
to create a new CI image for it.

00:45:50.990 --> 00:45:53.800
There's a little bit of
trickiness with that though.

00:45:53.800 --> 00:45:59.930
Both the CI image and the
CVOpenGL texture structure will

00:45:59.930 --> 00:46:03.120
basically have a reference,
if you will, not in the sort of CF retain

00:46:03.120 --> 00:46:06.410
or Objective-C reference sense,
but they'll both be referencing

00:46:06.470 --> 00:46:07.800
the OpenGL texture object.

00:46:07.800 --> 00:46:09.800
So, they sort of need to
come and go together.

00:46:09.800 --> 00:46:11.800
So, if you're going to keep
your CI image around,

00:46:11.800 --> 00:46:14.940
make sure you keep the underlying
texture that you've gotten from

00:46:14.980 --> 00:46:16.800
QuickTime around at the same time.

00:46:16.810 --> 00:46:19.590
One way you might simplify
that for yourself,

00:46:19.590 --> 00:46:23.370
if you're a Cocoa programmer,
is you could subclass CI image to

00:46:23.370 --> 00:46:25.800
basically do the CF retain for you.

00:46:25.800 --> 00:46:29.030
And then,
whenever you release the CI image,

00:46:29.040 --> 00:46:30.470
you can let it go away.

00:46:30.940 --> 00:46:33.750
So, we'll do a little demo of this.

00:46:33.840 --> 00:46:35.480
I was trying to think of
interesting demo ideas and

00:46:35.480 --> 00:46:36.800
something we tossed around a month.

00:46:36.800 --> 00:46:40.790
An idea we tossed around a month ago,
you know, not do CP or anything else,

00:46:40.790 --> 00:46:43.790
was do some underwater
video color correction.

00:46:43.800 --> 00:46:49.830
So, I happened to be on vacation a couple
weeks ago and shot some underwater video.

00:46:50.090 --> 00:46:53.660
And this is like a couple of sample
images that you can see out of it.

00:46:53.690 --> 00:46:57.600
These were taken,
the first image on your left is at about,

00:46:57.650 --> 00:47:00.920
I think it's like 17 feet or so,
and the one on the right is

00:47:00.920 --> 00:47:02.500
down around 50 feet or so.

00:47:02.500 --> 00:47:04.270
And you can see that
there's a color shift there.

00:47:04.520 --> 00:47:09.190
More and more the red
disappears as you go deeper.

00:47:09.190 --> 00:47:09.190
So,

00:47:09.670 --> 00:47:12.040
The other interesting thing is I need
some way to calibrate that though.

00:47:12.040 --> 00:47:13.550
It's like, well, for what depth am I at?

00:47:13.690 --> 00:47:15.020
How much correction am I going to do?

00:47:15.200 --> 00:47:18.870
So, for that, where is it?

00:47:18.950 --> 00:47:19.500
Here.

00:47:19.560 --> 00:47:21.520
Well, the red, oops.

00:47:21.590 --> 00:47:24.380
Go back to the slides real quick.

00:47:25.310 --> 00:47:27.100
Slides please.

00:47:27.120 --> 00:47:28.470
Thanks.

00:47:29.130 --> 00:47:32.270
The color matrix is a good match
for doing the color correction,

00:47:32.270 --> 00:47:33.790
but I still got to get
the depth information,

00:47:33.800 --> 00:47:36.560
so my little trusty dive computer here.

00:47:36.580 --> 00:47:40.240
The neat thing about it is that every
10 seconds it records what depth I'm at.

00:47:40.270 --> 00:47:44.710
I can, with a little serial cable,
pull that information back out

00:47:44.720 --> 00:47:46.950
and get a dive profile with it.

00:47:46.950 --> 00:47:46.950
Right.

00:47:47.240 --> 00:47:51.140
And I'll use OpenGL for a little
gratuitous heads up display in the demo.

00:47:51.290 --> 00:47:54.070
So, go to demo one please.

00:48:02.000 --> 00:48:04.830
Alright,
so I have this demo lovingly called

00:48:04.840 --> 00:48:08.860
"Coral Video." I think it was Tim's idea,
so you can blame him.

00:48:09.000 --> 00:48:11.390
So what this shows is this
is like a little video clip

00:48:11.530 --> 00:48:12.980
that I shot one of the days.

00:48:13.030 --> 00:48:16.130
I start out somewhat shallow,
again about 20 feet or so,

00:48:16.130 --> 00:48:20.350
and just sort of swim along the coral,
and then end up down here

00:48:20.350 --> 00:48:22.780
on the side a little bit.

00:48:23.910 --> 00:48:26.070
So, you know, I can play that.

00:48:26.420 --> 00:48:28.540
You can hear me breathe.

00:48:28.550 --> 00:48:29.940
Everybody thought I should
leave that in there,

00:48:29.940 --> 00:48:31.440
but I don't think it's that interesting.

00:48:31.440 --> 00:48:34.510
Anyway, all right, enough of that.

00:48:34.620 --> 00:48:34.970
So...

00:48:36.870 --> 00:48:39.840
So, down here on the right I've
got sort of dive profile.

00:48:39.840 --> 00:48:42.610
Here's where I basically got in the
water and then swam around a bit,

00:48:42.640 --> 00:48:44.140
up and down, all over the place.

00:48:44.280 --> 00:48:46.760
And then right here,
I put a couple of little bookmarks

00:48:46.760 --> 00:48:49.230
in the dive computer to show where
I was going to shoot the video

00:48:49.230 --> 00:48:50.820
clip so I could find it again.

00:48:50.860 --> 00:48:52.540
So,
I kind of need to do a little bit of a

00:48:52.600 --> 00:48:55.170
manual calibration step here and say,
"Well, okay,

00:48:55.170 --> 00:48:58.740
this is about the start point of the
clip." The dive computer's bookmarks

00:48:58.740 --> 00:49:01.440
are only accurate to 10 seconds,
so there's a fudge

00:49:01.570 --> 00:49:02.800
factor in here for sure.

00:49:02.990 --> 00:49:05.770
So, now that I've set the current time,
you can see as I move around,

00:49:05.780 --> 00:49:10.320
the depth sort of in the dive profile
display matches where I am on the clip.

00:49:10.550 --> 00:49:13.990
So, I can go to the beginning here
and I have all these little color

00:49:13.990 --> 00:49:15.900
correction controls I can use.

00:49:16.400 --> 00:50:38.400
[Transcript missing]

00:50:42.400 --> 00:50:43.170
Back to slides, please.

00:50:43.200 --> 00:50:47.090
All right.

00:50:47.100 --> 00:50:50.480
So the summary on that is, you know,
it's, as I've shown,

00:50:50.480 --> 00:50:52.630
it's pretty easy to get
this stuff into core image,

00:50:52.680 --> 00:50:54.190
you know, once you've got the
stuff out of QuickTime.

00:50:54.200 --> 00:50:58.370
All I was basically doing is
just feed the video and color

00:50:58.370 --> 00:51:00.400
correction data into core image.

00:51:00.400 --> 00:51:03.180
Really, really straightforward.

00:51:03.180 --> 00:51:06.700
And use OpenGL in this case to do
an additional heads-up display.

00:51:06.700 --> 00:51:08.300
Actually, there's one thing
I didn't mention before,

00:51:08.300 --> 00:51:12.150
and it'll be in the sample code,
is there's a, I wrote a cheesy little

00:51:12.150 --> 00:51:14.940
deinterlace filter in core image
as well that's in that app.

00:51:15.000 --> 00:51:18.980
Just as a little side note
I forgot to mention earlier.

00:51:18.980 --> 00:51:23.320
So a couple of caveats with this,
obviously, with this whole thing.

00:51:23.320 --> 00:51:25.980
So, you know, here's the bad news.

00:51:25.980 --> 00:51:30.800
So there are limitations to using
all this new pipeline stuff.

00:51:30.800 --> 00:51:34.570
To use sort of visual context at all,
you basically need to be on sort

00:51:34.580 --> 00:51:37.110
of Quartz Extreme class hardware,
and that's mainly because, again,

00:51:37.110 --> 00:51:38.180
we need texture rectangle.

00:51:38.180 --> 00:51:40.100
Very little video is 256.

00:51:40.140 --> 00:51:42.140
256 by 256 or whatever.

00:51:42.140 --> 00:51:45.240
There's also drawable
and size limitations.

00:51:45.270 --> 00:51:48.820
If you're on an older piece of hardware,
it might not either have enough

00:51:48.920 --> 00:51:53.030
memory or might not be able to support
texture resolution as big as the video

00:51:53.030 --> 00:51:54.400
you're trying to pump through it.

00:51:54.510 --> 00:51:56.420
So that's something
else to watch out for.

00:51:56.420 --> 00:51:59.950
For doing the core image stuff, again,
as been shown earlier this week,

00:52:00.060 --> 00:52:04.640
you basically need a Radeon 9600 or
higher or an NVIDIA GeForce FX or higher.

00:52:04.640 --> 00:52:07.460
One thing you can do, though,
is if the video coming out

00:52:07.460 --> 00:52:09.660
of QuickTime is going to
be too big for your VRAM,

00:52:11.000 --> 00:52:27.600
[Transcript missing]

00:52:34.540 --> 00:52:35.740
Wrong way.

00:52:35.740 --> 00:52:36.690
I want to see my name again.

00:52:36.780 --> 00:52:39.640
So we basically built this.

00:52:39.740 --> 00:52:42.810
This is the architectural
stack from in Tiger,

00:52:42.820 --> 00:52:46.960
and we built this pipeline,
which you've seen this diagram.

00:52:47.050 --> 00:52:50.660
The important thing is that you can
basically use the movie views for

00:52:50.660 --> 00:52:55.500
high-level access where you don't
need to actually get into the details.

00:52:55.530 --> 00:52:57.170
But if you want to
customize your application,

00:52:57.170 --> 00:53:02.390
you want to make a special application,
you can use the full pipeline to

00:53:02.390 --> 00:53:07.650
distinguish your app from another one and
take advantages of OpenGL and Core Image.

00:53:07.810 --> 00:53:08.850
Use the seed.

00:53:08.850 --> 00:53:11.700
Everything you've seen here is
basically working in the seed.

00:53:11.740 --> 00:53:12.500
A couple of notes.

00:53:12.500 --> 00:53:16.280
The HI movie view that's shipping,
the one the finder's using,

00:53:16.280 --> 00:53:19.990
the one that you can use is functional,
but it doesn't actually

00:53:20.000 --> 00:53:21.660
use visual context yet.

00:53:21.790 --> 00:53:25.170
We had a couple of integration issues
that we still needed to work through.

00:53:25.170 --> 00:53:26.440
We'll do that for Tiger.

00:53:27.220 --> 00:53:30.220
You'll find that some movies,
maybe if you rotate a

00:53:30.480 --> 00:53:33.710
movie using QuickTime,
it might not play exactly right,

00:53:33.710 --> 00:53:35.380
so that was an issue.

00:53:35.380 --> 00:53:40.910
And then the call that you need to
get CGL pixel format returns null,

00:53:40.930 --> 00:53:46.580
and we need that pixel format,
so that's currently not working.

00:53:46.580 --> 00:53:48.380
That's a little note.

00:53:52.470 --> 00:53:57.750
So, for more information, documentation,
you can get the information on visual

00:53:57.810 --> 00:54:02.900
context from the QuickTime documentation
that is in the Tiger docs on your CD,

00:54:02.900 --> 00:54:07.290
and then you'll be able to download the
sample applications that you've seen.

00:54:07.460 --> 00:54:10.400
Some of it's already up there
today in the 2.15 package,

00:54:10.400 --> 00:54:14.400
and some will be updated
as the weeks go on.

00:54:14.400 --> 00:54:17.370
So, the hands-on lab,
which is basically the back,

00:54:17.650 --> 00:54:20.400
the graphics and media lab,
tomorrow morning there's going to be

00:54:20.400 --> 00:54:22.880
a bunch of people from the GL team
who can help you now that you're

00:54:22.880 --> 00:54:24.400
all wanting to know how to do GL.

00:54:24.400 --> 00:54:27.120
And then, in the early afternoon,
there's going to be the

00:54:27.210 --> 00:54:28.590
people from the Core Video,
Core Image,

00:54:28.590 --> 00:54:32.400
and the QuickTime part team that's
been doing the visual context.

00:54:32.400 --> 00:54:36.720
And then, at the end of the day,
after the session on the new

00:54:36.720 --> 00:54:41.250
ICM APIs and IPP coding technologies,
there'll be more people from QuickTime.

00:54:41.400 --> 00:54:45.420
Upcoming sessions for you,
if you stay in this room,

00:54:45.490 --> 00:54:49.670
or come back into this room,
you're going to hear the update

00:54:49.740 --> 00:54:52.200
on audio and more information
about audio capture as well,

00:54:52.200 --> 00:54:57.770
sequence grabber changes,
and also tomorrow afternoon, again,

00:54:57.770 --> 00:54:59.400
next generation video formats.

00:54:59.400 --> 00:55:03.990
We'll be talking about H.264 and
changes to the movie toolbox and

00:55:03.990 --> 00:55:06.250
the ICM to support IPB coded video.

00:55:06.400 --> 00:55:11.020
If you're interested in being
seeded with QuickTime as we start

00:55:11.020 --> 00:55:16.340
seeding for the next version,
send your name, company, product,

00:55:16.450 --> 00:55:19.400
and technology interest to
QuickTimeSeed@apple.com.

00:55:19.400 --> 00:55:20.740
at apple.com.
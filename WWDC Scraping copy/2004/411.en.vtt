WEBVTT

00:00:12.070 --> 00:00:12.840
Good afternoon, everybody.

00:00:12.840 --> 00:00:15.600
Welcome to session 411,
Cocoa Tips and Tricks.

00:00:15.600 --> 00:00:18.140
So let's just jump right in,
if I can get this to work.

00:00:18.180 --> 00:00:19.350
There you go.

00:00:19.590 --> 00:00:21.460
Okay,
so today we're going to be showing you,

00:00:21.480 --> 00:00:23.140
well,
basically we're going to have a bunch

00:00:23.200 --> 00:00:26.950
of engineers from the Cocoa Frameworks
team up on stage answering the sort of

00:00:26.950 --> 00:00:30.300
questions you might have and showing you
how to put some cool features and some

00:00:30.300 --> 00:00:32.220
useful things into your applications.

00:00:32.220 --> 00:00:34.660
We're going to show lots of
source and lots of demos.

00:00:35.180 --> 00:00:38.540
And just like everything
else at the conference,

00:00:38.540 --> 00:00:42.620
it's going to be available for
download on the ADC website,

00:00:42.620 --> 00:00:44.100
all of the code that you see today.

00:00:45.730 --> 00:00:48.050
Last year,
we showed you lots of cool features,

00:00:48.060 --> 00:00:48.770
lots of useful things.

00:00:48.780 --> 00:00:49.930
I hope we had a lot of fun.

00:00:50.230 --> 00:00:52.780
This year,
we’ve got even more things to show you.

00:00:52.930 --> 00:00:55.300
You can see there’s a lot,
so let’s just jump right in.

00:00:55.300 --> 00:00:57.090
My name is Chuck Pisula.

00:00:57.110 --> 00:00:59.110
I’m an engineer on the
Cocoa Frameworks team.

00:00:59.550 --> 00:01:02.700
Let’s take a look at the first question.

00:01:02.700 --> 00:01:05.600
I have a table view,
and it doesn’t know how to sort, though.

00:01:05.750 --> 00:01:06.780
I’d like to add sorting.

00:01:07.090 --> 00:01:08.700
Can you tell me how hard that is?

00:01:08.960 --> 00:01:11.500
Well, it turns out it’s really
pretty easy to do.

00:01:11.970 --> 00:01:15.040
And what we need to do is two things.

00:01:15.200 --> 00:01:18.130
We need to define which
table columns are sortable,

00:01:18.130 --> 00:01:21.960
how those table columns are sortable,
and then we need to provide the

00:01:21.960 --> 00:01:23.690
code that actually does the sorting.

00:01:23.700 --> 00:01:26.200
But NS Table View is going to take
care of everything else for us.

00:01:26.200 --> 00:01:29.360
It’s going to handle the UI,
handle the clicks, and in fact,

00:01:29.360 --> 00:01:31.700
it’s going to tell us
when we need to sort.

00:01:31.750 --> 00:01:36.200
Now, if you want to be even lazier and do
even less glue code and less work,

00:01:36.200 --> 00:01:38.620
you could just switch to bindings,
and this would all just work.

00:01:38.700 --> 00:01:39.830
Thank you.

00:01:40.740 --> 00:01:43.610
Okay, so how do we do our first job,
which is defining the

00:01:43.660 --> 00:01:45.140
sortability of table columns?

00:01:45.280 --> 00:01:49.510
Well, what we need to do is provide a
sort descriptor prototype for each

00:01:49.510 --> 00:01:51.600
column that we want to be sortable.

00:01:51.640 --> 00:01:54.170
And in the sort descriptor prototype,
we’re going to provide

00:01:54.340 --> 00:01:55.930
three bits of information.

00:01:55.930 --> 00:01:59.740
We’re going to say what the
key is that we’re sorting on,

00:01:59.760 --> 00:02:04.280
what the initial sorting direction is,
and what the selector is to use when

00:02:04.280 --> 00:02:07.080
comparing two objects during the sort.

00:02:07.080 --> 00:02:09.980
Now, like many other things,
we can also set this in Interface

00:02:10.090 --> 00:02:15.410
Builder by inspecting the table column
and setting the three attributes.

00:02:16.380 --> 00:02:21.060
Okay, so our second job is to
actually do the sorting.

00:02:21.120 --> 00:02:23.580
As I said,
TableView is kind enough to tell us when

00:02:23.850 --> 00:02:26.240
we need to update our sort ordering.

00:02:26.270 --> 00:02:30.290
It’s going to send us the
TableView:sort descriptors did change:

00:02:30.310 --> 00:02:35.830
and the second parameter is going to
be the old list of sort descriptors

00:02:35.830 --> 00:02:39.640
in case we know that we can do
something more efficient by being

00:02:39.640 --> 00:02:40.800
given the old sort descriptors.

00:02:40.800 --> 00:02:44.950
If we want the current sort descriptors,
we just turn around to TableView and

00:02:44.950 --> 00:02:47.100
ask it for the sort descriptors.

00:02:47.100 --> 00:02:49.520
Now, for some reason,
if you want to manage

00:02:49.530 --> 00:02:52.570
all the sorting yourself,
TableView provides a routine to set

00:02:52.570 --> 00:02:55.270
the current list of sort descriptors.

00:02:55.280 --> 00:02:59.010
And another interesting note is that
the sort descriptors are persisted

00:02:59.020 --> 00:03:02.940
along with other information about
table columns that are persisted.

00:03:03.000 --> 00:03:09.710
So across running of your application,
TableView will remember what the last

00:03:09.710 --> 00:03:11.780
sort ordering was that the user was

00:03:12.660 --> 00:03:16.080
Okay, so now that we know when to sort,
we need to do the sorting.

00:03:16.390 --> 00:03:20.040
And we’re going to use some
conveniences provided by NSArray.

00:03:20.040 --> 00:03:23.010
NSArray knows how to take an
array of sort descriptors,

00:03:23.010 --> 00:03:26.300
which again we get from the table view,
and knows how to sort using the

00:03:26.350 --> 00:03:28.470
information in the sort descriptors.

00:03:28.470 --> 00:03:32.940
One of the things is the key,
which is going to do the sorting on.

00:03:32.940 --> 00:03:35.060
And finally,
you’ll see at the bottom an example

00:03:35.060 --> 00:03:39.320
of how we might sort an array of
things using a sort descriptor.

00:03:39.320 --> 00:03:42.800
We’re going to sort things in
this array based on the first

00:03:42.800 --> 00:03:45.490
name value of each object.

00:03:46.490 --> 00:03:49.150
Okay, before we go into this demo,
I wanted to do just a quick overview

00:03:49.150 --> 00:03:52.820
of what we’re going to be looking at,
since what we’re really going to

00:03:52.820 --> 00:03:56.400
be doing is extending an example
that exists on the system already.

00:03:56.400 --> 00:03:59.360
And that example lives in
Developer Examples app kit.

00:03:59.500 --> 00:04:01.400
It��s called drag-and-drop outline view.

00:04:01.400 --> 00:04:04.350
And what it does is display
some hierarchical data.

00:04:04.400 --> 00:04:10.740
And the data that it’s managing is sort
of a simple tree structure with nodes,

00:04:10.860 --> 00:04:14.400
and each node has a pointer to some data.

00:04:14.400 --> 00:04:18.910
So at this point,
I believe I want to go to the demos.

00:04:23.250 --> 00:04:28.150
Okay, let’s take a look at the
application running and see what

00:04:28.580 --> 00:04:31.090
we’re going to get in the end.

00:04:31.800 --> 00:04:33.140
Okay, what you'd expect.

00:04:33.260 --> 00:04:35.080
I click on a table column, it sorts.

00:04:35.170 --> 00:04:39.800
This actually, in the existing demo,
it already knows how to sort

00:04:39.950 --> 00:04:41.190
based on the name column.

00:04:41.490 --> 00:04:43.420
And in a second,
we'll see that it really was a hack,

00:04:43.540 --> 00:04:46.430
and we're going to do it a better way,
and we're going to do it in

00:04:46.450 --> 00:04:47.630
a completely generic way.

00:04:47.900 --> 00:04:50.960
Now, we're able to sort on each column.

00:04:53.090 --> 00:04:54.000
Okay.

00:04:54.000 --> 00:04:56.170
So,
let's first take a look at our first job,

00:04:56.380 --> 00:04:59.610
which is to set the sortability
of the table columns.

00:04:59.640 --> 00:05:02.370
We did this in Interface Builder.

00:05:02.640 --> 00:05:07.200
And the first column is going to sort
each object based on its name key.

00:05:07.200 --> 00:05:10.990
And it's going to use compare
colon to do its comparison.

00:05:11.000 --> 00:05:16.210
And it's going to sort its
initial direction as ascending.

00:05:16.220 --> 00:05:19.910
And we could have actually left
compare colon off because that's the

00:05:19.910 --> 00:05:22.280
default if you specify null or nothing.

00:05:23.000 --> 00:05:26.510
And then we'll see that we specified
some values for the other columns.

00:05:26.540 --> 00:05:29.700
The key will be is expandable
for the second column and is

00:05:29.820 --> 00:05:31.460
group for the last column.

00:05:40.270 --> 00:05:43.700
Okay, for this example,
I actually�� I'm going to show

00:05:43.700 --> 00:05:46.230
you the code a little bit of a
different way than you've probably

00:05:46.230 --> 00:05:47.600
seen in all of the sessions.

00:05:47.660 --> 00:05:50.310
I'm actually going to
bring up File Merge since,

00:05:50.430 --> 00:05:53.300
as I said, this is a demo on the system.

00:05:53.730 --> 00:05:56.440
What I want to show you
is what we've added to it.

00:05:56.570 --> 00:05:59.950
So it lives in�� the
original lives in Developer,

00:06:00.030 --> 00:06:02.020
Examples,

00:06:03.950 --> 00:06:08.670
AppKit drag and drop outline view.

00:06:08.720 --> 00:06:15.540
And we’re going to compare
it to this set of code.

00:06:19.700 --> 00:06:22.080
Okay, and let's see what we've added.

00:06:22.170 --> 00:06:24.390
Well,
we've changed the application controller,

00:06:24.390 --> 00:06:26.700
which is the data source
of the outline view,

00:06:26.730 --> 00:06:29.000
and there's one difference.

00:06:29.240 --> 00:06:34.120
We've added the sort descriptors
did change colon delegate method.

00:06:34.290 --> 00:06:37.820
And what we're going to do
is tell our data to sort,

00:06:37.980 --> 00:06:39.080
our tree data.

00:06:39.180 --> 00:06:42.500
We're going to add a sort
using descriptors method.

00:06:42.670 --> 00:06:45.320
And then since we probably
changed the order of things,

00:06:45.320 --> 00:06:47.990
we're going to tell the
TailView to reload the data and

00:06:48.030 --> 00:06:49.570
display it in its new order.

00:06:50.420 --> 00:06:54.190
So let's take a look at
simple tree node next,

00:06:54.320 --> 00:06:57.460
which is a subclass of tree node.

00:06:57.460 --> 00:07:02.500
And really all I want to show you here is
that we've removed our hack from before.

00:07:02.550 --> 00:07:09.810
We used to sort things by forcing
it to compare using the name.

00:07:10.200 --> 00:07:33.800
[Transcript missing]

00:07:37.030 --> 00:07:40.230
So first we go and we
tell our node children,

00:07:40.230 --> 00:07:43.600
which is an array,
we tell it to sort itself,

00:07:43.670 --> 00:07:46.500
to reorder itself based
on the sort descriptors.

00:07:46.510 --> 00:07:49.030
And then we recurse.

00:07:49.500 --> 00:07:52.940
And finally, since we want to sort
on keys in the data,

00:07:52.940 --> 00:07:55.820
and we have a pointer to our data,
but we don't actually respond

00:07:55.820 --> 00:07:58.720
to all the methods in the data,
we're going to do a little trick,

00:07:58.760 --> 00:08:01.060
and we're going to override
value for undefined key.

00:08:01.060 --> 00:08:04.540
So when we're trying to compare
based on a key in the node

00:08:04.540 --> 00:08:08.980
which it doesn't respond to,
like the nodes don't respond to name,

00:08:08.980 --> 00:08:13.550
it's going to go off to the data object
and ask it for the value for name.

00:08:13.560 --> 00:08:16.920
And so by doing this,
we're going to be able to sort

00:08:16.920 --> 00:08:19.190
based on keys in the data object.

00:08:19.400 --> 00:08:20.500
Thank you.

00:08:20.930 --> 00:08:26.100
and using those small set of changes,
not many changes there,

00:08:26.150 --> 00:08:31.040
we’re able to get sorting in our table
view or our outline view in this case.

00:08:31.040 --> 00:08:33.860
Okay, so if we could go back to slides,

00:08:40.460 --> 00:08:44.640
Okay, well, that's great, but, you know,
your parents out there are just going,

00:08:44.640 --> 00:08:45.640
"Sorting's not boring.

00:08:45.640 --> 00:08:46.630
I'm never going to sort anything.

00:08:46.630 --> 00:08:49.640
It's no fun." Can we make
it a little more fun?

00:08:49.710 --> 00:08:52.570
So,
could I add something like animation to

00:08:52.590 --> 00:08:55.280
the sorting so it's a little more whizzy,
a little more fun to do,

00:08:55.280 --> 00:09:00.490
a little bit more, you know, Mac OS X,
kind of sliding around, fun style?

00:09:00.600 --> 00:09:02.360
And, certainly, we can do that.

00:09:02.360 --> 00:09:06.780
And what we're going to do is make
a subclass event a style line view

00:09:06.800 --> 00:09:09.200
that knows how to do all of this.

00:09:09.240 --> 00:09:14.900
And what it's going to need to do is,
first, take a snapshot of the location

00:09:14.900 --> 00:09:18.260
of all the items in the outline
view before you do the reload.

00:09:18.320 --> 00:09:22.290
And that's so that we can map
index items from their old

00:09:22.330 --> 00:09:24.890
location to their new location.

00:09:25.120 --> 00:09:27.870
So, during the animation,
we're going to slide things from

00:09:28.090 --> 00:09:29.600
the old place to the new place.

00:09:29.680 --> 00:09:32.100
So, before we load, we make a snapshot.

00:09:32.150 --> 00:09:34.900
And after the data is
sorted by the data source,

00:09:34.930 --> 00:09:38.000
what we're going to do is reload in a
way such that we create an index mapping,

00:09:38.000 --> 00:09:38.000
which shows that we have a snapshot
of the items in the outline view.

00:09:38.000 --> 00:09:39.920
And after that,
we're going to get an index mapping,

00:09:40.150 --> 00:09:43.000
which shows where
things went from and to.

00:09:43.000 --> 00:09:45.600
And then we're going to do
some custom drawing because,

00:09:45.660 --> 00:09:48.600
well, we're not drawing things
at fixed locations.

00:09:48.600 --> 00:09:52.010
And, finally,
we're going to use NSAnimation to help

00:09:52.140 --> 00:09:56.750
us manage our timer and get the nice
smooth curve values so we get a nice,

00:09:56.750 --> 00:09:58.660
you know, fun, smooth animation.

00:10:00.270 --> 00:10:01.190
Okay.

00:10:01.200 --> 00:10:02.140
So as I said,
we're going to make a subclass,

00:10:02.180 --> 00:10:04.200
it's going to be called
animating outline view.

00:10:04.200 --> 00:10:06.770
And first we're gonna add
a method to it called.

00:10:07.280 --> 00:10:09.050
Well, I like long method names.

00:10:09.190 --> 00:10:11.710
For those of you who know me,
it's called prepare for

00:10:11.710 --> 00:10:13.200
reload movement animation.

00:10:13.200 --> 00:10:16.390
And this method is supposed to
be called by the data source

00:10:16.390 --> 00:10:18.170
before it reorders the data.

00:10:18.200 --> 00:10:21.500
And this is the chance for the
animating outline view to take

00:10:21.600 --> 00:10:25.200
a snapshot to take the snapshot
location where things currently live.

00:10:25.200 --> 00:10:28.810
Then after it sorts the data,
it's going to call a new method

00:10:28.810 --> 00:10:33.060
that is on the bottom called reload
data with movement animation.

00:10:33.200 --> 00:10:37.390
And this is basically a new kind
of reload that we're going to make,

00:10:37.390 --> 00:10:40.200
which knows how to
make the index mapping,

00:10:40.220 --> 00:10:41.930
start up a timer,
which fires and is going to

00:10:42.150 --> 00:10:43.200
control and run a reload.

00:10:43.200 --> 00:10:44.320
on our animation.

00:10:44.340 --> 00:10:47.040
And of course,
it's also going to reload the data.

00:10:48.530 --> 00:10:51.960
Okay, as I said, we don't draw rows at
fixed locations anymore,

00:10:51.960 --> 00:10:55.390
and we're going to override,
draw a row in ClipRect,

00:10:55.480 --> 00:11:00.260
and what we're going to do is, over time,
smoothly animate the

00:11:00.350 --> 00:11:03.830
rows at new locations,
and we're actually going to use a nice

00:11:04.020 --> 00:11:06.860
little trick by drawing these rows.

00:11:06.890 --> 00:11:09.240
Instead of into the table view,
we're going to draw

00:11:09.240 --> 00:11:11.060
the rows into an image,
and then we're going to

00:11:11.070 --> 00:11:12.420
blit the images onto screen.

00:11:12.420 --> 00:11:16.000
Because we're going to be doing this lots
and lots and lots of times very rapidly,

00:11:16.000 --> 00:11:19.240
this means we only have
to draw the row one time,

00:11:19.240 --> 00:11:22.800
and after that, we can always use these
images that we've cached away,

00:11:22.800 --> 00:11:23.970
and we can get better performance.

00:11:28.160 --> 00:11:30.480
Okay, so we're not drawing
rows into a table view.

00:11:30.480 --> 00:11:32.690
We're going to do a little trick,
and we're going to draw

00:11:33.180 --> 00:11:34.870
rows into an image.

00:11:34.900 --> 00:11:37.050
So to do this,
we're going to create an image,

00:11:37.050 --> 00:11:40.520
we're going to lock focus on it,
and then we're going to tell table view,

00:11:40.520 --> 00:11:42.230
go ahead and draw rows
like you normally did.

00:11:42.240 --> 00:11:45.740
But, say, row three, where does it draw?

00:11:45.740 --> 00:11:49.940
It probably draws at a
coordinate like y of 51.

00:11:49.940 --> 00:11:52.570
And our image,
we don't want to make every single image

00:11:52.570 --> 00:11:54.700
for every single row as big as the table.

00:11:55.000 --> 00:11:56.440
We just want to make
it the height of a row.

00:11:56.440 --> 00:12:01.310
So what we're going to do is trick the
table view into drawing everything during

00:12:01.400 --> 00:12:04.200
animation at a y coordinate of zero.

00:12:04.200 --> 00:12:07.980
And by doing this, we're going to be able
to draw into the image.

00:12:08.000 --> 00:12:09.900
And later on, we're going to use it,
we're just going to blitz

00:12:09.900 --> 00:12:11.030
screen over and over and over.

00:12:11.090 --> 00:12:14.270
Okay,
so if we could go to the demo machine,

00:12:14.270 --> 00:12:15.080
please.

00:12:19.680 --> 00:12:21.100
Now,
just so we see what we're going to get,

00:12:21.240 --> 00:12:24.590
let's take a look at this
one again before we start.

00:12:24.800 --> 00:12:28.600
And, well, we've got sort,
it's not very fun yet,

00:12:28.640 --> 00:12:31.600
but let's click the fun button.

00:12:31.830 --> 00:12:37.600
And let's make some more data so
it's a little more interesting.

00:12:37.600 --> 00:12:44.600
And we've got some nice fun
little animation going on.

00:12:44.710 --> 00:12:47.750
All right, so let's take a look
at the code for this.

00:12:55.810 --> 00:13:00.690
First thing I want to take a
look at is the Not That class.

00:13:08.750 --> 00:13:11.690
is the Animating Outline View,
our new class.

00:13:11.700 --> 00:13:14.510
It’s a subclass of NSOutlineView.

00:13:14.540 --> 00:13:18.490
It has some instance variables
that help it manage the animation.

00:13:18.860 --> 00:13:22.100
Now,
this example is a little more complex,

00:13:22.100 --> 00:13:25.190
has a little bit more code
than some of the other demos,

00:13:25.190 --> 00:13:28.690
so I’m going to kind of breeze
through it because you’re going

00:13:28.840 --> 00:13:30.590
to get to look at it on your own.

00:13:30.670 --> 00:13:34.040
And for the most part,
this is all some little�� lots of little

00:13:34.170 --> 00:13:35.190
details that need to be taken care of.

00:13:35.190 --> 00:13:35.190
It’s nothing too difficult.

00:13:35.490 --> 00:13:39.160
and we've added an interface
that our data source gets to use.

00:13:39.230 --> 00:13:41.990
Okay,
so let's take a look at the actual code.

00:13:44.610 --> 00:13:49.760
and jump down to prepare
for reload animation.

00:13:49.760 --> 00:13:52.930
And only if animation is enabled,
we’re going to do a couple things.

00:13:53.130 --> 00:13:55.900
First, if we’re animating before,
we happen to have some of

00:13:55.930 --> 00:13:57.950
the old stuff laying around,
we’re going to throw

00:13:57.950 --> 00:13:59.020
it out and start over.

00:13:59.280 --> 00:14:03.740
and what we're going to do is�� sorry,
I guess I want to jump down here��

00:14:03.830 --> 00:14:06.500
we're going to create a dictionary,
which we're going to keep

00:14:06.500 --> 00:14:08.100
as an instance variable.

00:14:08.100 --> 00:14:12.230
It's something that's going
to be used by the next reload.

00:14:12.230 --> 00:14:16.960
And it's going to be the snapshot of
the current order of all the items.

00:14:17.100 --> 00:14:19.610
Now, if you have a very, very,
very large outline view,

00:14:19.620 --> 00:14:21.970
you can imagine this
performance might not be great.

00:14:22.100 --> 00:14:25.710
So I'm going to leave it as an exercise
up to you guys to figure out a more

00:14:25.710 --> 00:14:28.100
efficient way to do that kind of a trick.

00:14:28.100 --> 00:14:31.100
And we marked some other information,
which is the current row selection,

00:14:31.100 --> 00:14:33.020
so we can fix it up later.

00:14:33.100 --> 00:14:36.530
Okay, so jumping ahead.

00:14:37.760 --> 00:14:41.200
We have our reload data
with movement animation.

00:14:41.250 --> 00:14:43.330
And as I said,
it’s a new kind of reload data.

00:14:43.420 --> 00:14:46.940
It’s going to do reload data
and a couple of other things.

00:14:46.990 --> 00:14:50.440
The first thing we want to
do is computer index mapping.

00:14:50.470 --> 00:14:54.300
I��ll let you guys take a look
at how that’s done offline.

00:14:54.460 --> 00:14:58.540
If we’re currently animating,
we finish the current animation.

00:14:58.590 --> 00:15:00.860
We just bail and start over.

00:15:02.360 --> 00:15:08.330
And then once we have an index mapping,
first we want to fix up the

00:15:08.710 --> 00:15:11.860
selections because things
have moved to new locations,

00:15:11.880 --> 00:15:15.860
so we're going to make sure
the selection matches that.

00:15:16.540 --> 00:15:19.170
We're done with the data
that we marked before,

00:15:19.440 --> 00:15:22.730
so let's free it, clear it out.

00:15:23.880 --> 00:15:27.960
And finally, jump ahead a little bit.

00:15:27.990 --> 00:15:32.310
We retain our index mapping so that we
can use it throughout the animation.

00:15:32.400 --> 00:16:00.800
[Transcript missing]

00:16:01.060 --> 00:16:04.100
We're going to use non-blocking mode.

00:16:04.170 --> 00:16:08.700
We're going to create a place that we
can store the images that we're going

00:16:08.700 --> 00:16:10.920
to use to draw during the animation.

00:16:11.030 --> 00:16:13.280
And then we start the animation.

00:16:13.500 --> 00:16:17.510
and it turns out that our subclass
of NSAnimation is going to tell

00:16:17.510 --> 00:16:19.840
us whenever we need to update.

00:16:19.840 --> 00:16:23.950
And it's going to tell us
by sending us this message:

00:16:23.960 --> 00:16:26.040
"Progress animation,
current progress did change."

00:16:26.060 --> 00:16:28.770
And when we get this,
well, we're either at a point where

00:16:28.770 --> 00:16:31.480
we're done with the animation,
so we'll finish it,

00:16:31.630 --> 00:16:33.370
or we'll force a re-display.

00:16:36.780 --> 00:16:42.060
And when we re-display,
I'm going to jump ahead a little,

00:16:42.060 --> 00:16:44.900
we eventually end up
getting into draw a row.

00:16:45.080 --> 00:16:49.570
And again, what draw a row is going to
do is draw using an image.

00:16:49.650 --> 00:16:51.120
So first thing it's going
to do is figure out,

00:16:51.120 --> 00:16:53.040
well, where do I need to draw?

00:16:53.080 --> 00:16:55.550
It's going to get the
nice smooth curve values,

00:16:55.640 --> 00:16:58.620
do a little bit of math in
this routine that I have,

00:16:58.680 --> 00:17:01.780
and it's going to figure out where
the row should be at this point.

00:17:02.230 --> 00:17:05.450
Then we're going to find out, well,
if it's not actually on screen,

00:17:05.630 --> 00:17:06.100
let's just bail.

00:17:06.100 --> 00:17:07.980
We don't want to draw.

00:17:08.830 --> 00:17:11.110
If we haven't generated
an image cache yet,

00:17:11.320 --> 00:17:15.200
let's generate an image by the
code I showed you in the slides.

00:17:15.200 --> 00:17:19.880
We're going to create an image,
draw into it, and then cache it away.

00:17:20.030 --> 00:17:23.800
And finally, we're going to just split
the image onto the screen.

00:17:25.230 --> 00:17:31.600
And again, here you see in Rect of Row,
here's our trick to get the drawing

00:17:31.600 --> 00:17:35.530
to draw at a y origin of zero.

00:17:36.410 --> 00:17:41.600
and the rest of the code I'm going to
let you guys take a look at online.

00:17:41.680 --> 00:17:44.500
These are just our helper teams
to compute the index mapping,

00:17:44.630 --> 00:17:48.200
figure out where we want to draw things,
and so on.

00:17:51.060 --> 00:17:57.270
Now let’s take a quick look
at our animation subclass.

00:18:01.200 --> 00:18:14.300
[Transcript missing]

00:18:14.670 --> 00:18:17.440
This message whenever
the animation updates.

00:18:17.500 --> 00:18:20.270
If we take a look at the code for this,
it’s really simple.

00:18:22.110 --> 00:18:24.500
We have a cover for a net,
stash away the delegate,

00:18:24.650 --> 00:18:27.680
and basically all it does is
whenever the progress changes,

00:18:27.730 --> 00:18:29.990
it tells the delegate that it
needs to update the animation,

00:18:30.100 --> 00:18:31.000
and that’s it.

00:18:31.000 --> 00:18:34.200
And it’s nice because this class
takes care of all the little

00:18:34.200 --> 00:18:38.000
dirty details of managing a timer,
creating it, getting it to fire,

00:18:38.000 --> 00:18:41.000
and it hides the details of
how it computes the ease in,

00:18:41.000 --> 00:18:44.000
ease out values, and things like that.

00:18:44.240 --> 00:18:52.000
All right, and again,
once we have all that,

00:18:52.000 --> 00:18:54.120
we’ve got our nice smooth animation.

00:18:58.220 --> 00:19:00.380
You'll see when you look at the code,
there's some other neat

00:19:00.440 --> 00:19:01.490
little tricks in there.

00:19:01.840 --> 00:19:05.670
We try and make sure that we never��
If the table had 10,000 things,

00:19:05.720 --> 00:19:08.850
you don't want to animate
something from 10,000 rows away.

00:19:09.210 --> 00:19:13.380
You sort of want to clamp it to two
times the visible height so that

00:19:13.380 --> 00:19:15.520
it's never too far away from visible.

00:19:15.690 --> 00:19:17.100
Because if you animate
from really far away,

00:19:17.240 --> 00:19:20.510
it wouldn't be on screen very
long during its animation.

00:19:20.590 --> 00:19:23.000
So there's some neat little tricks
in there like that that I'll let

00:19:23.000 --> 00:19:25.120
you guys take a look at offline.

00:19:25.300 --> 00:19:27.790
All right, if we go back to the slides,
please.

00:19:32.040 --> 00:19:35.680
Okay, well, we've got some really cool,
fun animations, but, you know,

00:19:35.680 --> 00:19:37.200
I'm sure this has never
happened to anyone out there,

00:19:37.200 --> 00:19:39.260
but it's the last minute,
we're about ready to ship, and HI's,

00:19:39.260 --> 00:19:40.780
they've changed their mind.

00:19:40.780 --> 00:19:43.100
They want something,
they want it to be in a table view now,

00:19:43.100 --> 00:19:43.960
not in an outline view.

00:19:43.960 --> 00:19:45.180
So what are you going to do?

00:19:45.180 --> 00:19:48.440
Are you going to change
everything to be a table view,

00:19:48.440 --> 00:19:51.780
and are you going to change the data
source to use different data source APIs?

00:19:51.780 --> 00:19:53.760
Well, here's a little trick.

00:19:53.840 --> 00:19:56.640
What we're going to do is
make NSOutlineView display

00:19:56.640 --> 00:19:59.040
looking more like a table view.

00:19:59.040 --> 00:20:01.590
We're going to trick
NSOutlineView to draw,

00:20:01.790 --> 00:20:02.980
like, a flat list.

00:20:03.040 --> 00:20:05.470
And one advantage to this is
that you only have to deal with

00:20:05.470 --> 00:20:07.280
one delegate and data source,
so you don't have to change

00:20:07.280 --> 00:20:07.980
anything in your nib.

00:20:07.980 --> 00:20:11.600
And for those of you who
want a unique identifier,

00:20:11.600 --> 00:20:15.230
outline views require
unique identifiers per item,

00:20:15.490 --> 00:20:15.920
per row.

00:20:15.920 --> 00:20:18.090
But, of course, for some people,
that's a drawback.

00:20:18.190 --> 00:20:20.650
So those are things you'll have to think
about if you want to try this trick.

00:20:22.820 --> 00:20:24.940
Okay,
so we're going to trick NSOutlineView,

00:20:24.940 --> 00:20:27.440
and what we're going to do is tell it,
set your indentation level

00:20:27.440 --> 00:20:28.490
to something like zero.

00:20:28.490 --> 00:20:31.250
Don't draw with a big indent,
because that's one difference

00:20:31.250 --> 00:20:32.540
between OutlineView and TableView.

00:20:32.540 --> 00:20:37.050
And if it turns out that for some
reason you're drawing a flat list,

00:20:37.050 --> 00:20:41.030
but you have some hierarchical data,
well, it would try and draw

00:20:41.030 --> 00:20:42.760
those turndown indicators.

00:20:42.760 --> 00:20:46.100
And we don't want to draw those,
so what we're going to do is override the

00:20:46.100 --> 00:20:48.450
WillDisplayOutlineCell delegate message.

00:20:49.130 --> 00:20:51.120
And when we get that,
we're going to effectively force

00:20:51.280 --> 00:20:52.720
the outline cell to be hidden.

00:20:52.720 --> 00:20:54.690
And that's what you
see down at the bottom.

00:20:54.720 --> 00:20:57.690
If we could go back to the demo machine,
please.

00:21:01.660 --> 00:21:05.790
I got a little overzealous and
closed things behind myself.

00:21:05.880 --> 00:21:06.840
Bring it up again.

00:21:06.900 --> 00:21:09.640
Now, I'm actually not going to show the
code for this because you just saw

00:21:09.710 --> 00:21:14.420
all of it on the slides other than
some little helper things I've added.

00:21:14.510 --> 00:21:19.960
And you'll see if you compare
this to what already exists on

00:21:20.570 --> 00:21:22.010
The system for
drag-and-drop outline view,

00:21:22.020 --> 00:21:24.660
if you compare it,
I've added the ability to change the

00:21:24.660 --> 00:21:25.900
data file that's being displayed.

00:21:25.900 --> 00:21:28.750
And what it's going to do,
if it detects that there's

00:21:28.800 --> 00:21:31.900
no hierarchical data,
it's going to switch to using

00:21:31.900 --> 00:21:34.390
a flat list type display,
using the code that

00:21:34.390 --> 00:21:35.230
you saw on the slides.

00:21:35.280 --> 00:21:39.510
And so all we do, I know data file one
happens to be a flat list.

00:21:39.570 --> 00:21:42.160
I click that,
and it looks more like a table view.

00:21:42.160 --> 00:21:44.490
And I didn't have to
change anything in my nib,

00:21:44.610 --> 00:21:48.270
and I didn't have to add any more code
than what you just saw on the slides.

00:21:50.500 --> 00:21:54.120
Okay, so if we go back to the slides,
please.

00:22:00.930 --> 00:22:01.870
Slides, please.

00:22:01.870 --> 00:22:03.740
Thank you.

00:22:03.750 --> 00:22:07.000
Okay, at this point,
I'd like to invite up on stage another

00:22:07.000 --> 00:22:08.740
one of the Cocoa Frameworks engineers,
Tina Huang.

00:22:08.740 --> 00:22:10.690
Tina?

00:22:13.500 --> 00:22:14.610
and Mrs.

00:22:14.610 --> 00:22:15.500
Ford.

00:22:15.500 --> 00:22:18.220
Thank you very much, Chuck.

00:22:18.260 --> 00:22:20.330
Once again,
my name is Tina Huang and I work

00:22:20.460 --> 00:22:21.780
with Chuck on the App Kit.

00:22:23.820 --> 00:22:27.690
So have you ever noticed that
applications such as Xcode provide easy

00:22:27.690 --> 00:22:33.200
access to commonly used functions such as
opening a file or creating a new project?

00:22:33.200 --> 00:22:35.660
And they do this by
having a menu in the dock.

00:22:35.660 --> 00:22:39.890
Well, how can you add a dock
menu to your application?

00:22:40.690 --> 00:22:46.290
Well, the very easy way and basically
no-code method is add an IB.

00:22:46.700 --> 00:22:49.210
To do this,
just drag a menu out into your

00:22:49.210 --> 00:22:53.320
nib file and connect it to your
application's doc menu outlet.

00:22:55.750 --> 00:22:59.360
But there are times where in your
doc menu you want the contents to

00:22:59.390 --> 00:23:02.930
vary dynamically depending on the
current state of your application.

00:23:03.150 --> 00:23:05.680
And so to do this,
you have to actually create

00:23:05.720 --> 00:23:07.410
the doc menu in code.

00:23:07.930 --> 00:23:13.840
And all you have to do is implement
in your application's delegate the

00:23:13.900 --> 00:23:19.590
application doc menu method and
have that return your doc menu.

00:23:20.370 --> 00:23:23.980
But there are times where in your
doc menu you want the contents to

00:23:24.090 --> 00:23:25.730
vary dynamically depending on the
current state of your application.

00:23:25.730 --> 00:23:25.730
And so to do this,
you have to actually create

00:23:25.730 --> 00:23:25.730
the doc menu in code.

00:23:25.730 --> 00:23:25.730
And all you have to do is implement
in your application's delegate the

00:23:25.730 --> 00:23:25.730
application doc menu method and
have that return your doc menu.

00:23:28.920 --> 00:23:30.930
So we're going to take
a look at this first.

00:23:31.100 --> 00:23:35.390
Notice that when I�� well, first of all,
I'd like to mention that DotView is

00:23:35.420 --> 00:23:38.330
another application that you
can get in your application��

00:23:38.420 --> 00:23:42.970
developer application examples,
and if you went to the

00:23:43.040 --> 00:23:47.570
Cocoa introduction talk,
I think Ali showed you basically

00:23:47.600 --> 00:23:49.440
how you can create DotView.

00:23:49.860 --> 00:23:53.550
But here we have in the dock menu red,
blue, and green.

00:23:53.680 --> 00:23:58.870
So we basically are allowing you to
change the color of the dot in the menu.

00:24:01.190 --> 00:24:06.720
However, to illustrate a dynamic menu,
it kind of seems silly to have

00:24:06.720 --> 00:24:11.440
red in your menu when your dot is
currently red since it’s meaningless.

00:24:11.440 --> 00:24:15.720
So we’re going to change it so that if
the dot is one of the current colors,

00:24:15.720 --> 00:24:17.760
then take it out of the menu.

00:24:17.760 --> 00:24:21.450
So say I select blue and
now that’s out of the menu.

00:24:21.710 --> 00:24:26.240
But if I were to change the
color to something like maroon,

00:24:26.450 --> 00:24:30.700
now I have all three options available.

00:24:30.700 --> 00:24:34.360
So to take a look at the
code���� And real quickly,

00:24:34.360 --> 00:24:40.450
I’m going to change the indentation here.

00:24:40.450 --> 00:24:40.450
So����

00:24:46.300 --> 00:24:50.940
Looks a little bit better.

00:24:50.940 --> 00:24:51.190
Okay.

00:24:51.190 --> 00:24:53.530
So taking a look at the code,
we’ve implemented the

00:24:53.550 --> 00:24:56.410
application doc menu method.

00:24:56.610 --> 00:25:01.140
Looks a little bit better.

00:25:01.140 --> 00:25:01.390
Okay.

00:25:01.390 --> 00:25:03.680
So taking a look at the code,
we’ve implemented the

00:25:03.680 --> 00:25:04.810
application doc menu method.

00:25:05.380 --> 00:25:08.740
Once we have that,
we're going to take a look at what

00:25:08.740 --> 00:25:11.940
the current color of the dot is.

00:25:11.940 --> 00:25:15.090
And basically, if it's red,
take red out of the menu and the

00:25:15.090 --> 00:25:16.880
same thing goes for blue and green.

00:25:19.530 --> 00:25:22.400
And then for each one of
the colors that remains,

00:25:22.530 --> 00:25:31.660
we create an NS menu item out of that
color and set a nil key equivalent.

00:25:31.700 --> 00:25:38.260
Add the item to the menu and at the
end return the menu we've just created.

00:25:38.270 --> 00:25:39.280
And that's it.

00:25:39.280 --> 00:25:40.310
If I can go back to slides, please.

00:25:45.220 --> 00:25:46.100
So that's great.

00:25:46.100 --> 00:25:49.700
We can now change color easily
in our dot using the menu.

00:25:49.740 --> 00:25:53.040
But let's say in addition we
want to have the ability to

00:25:53.240 --> 00:25:54.950
change the dot size as well.

00:25:55.490 --> 00:25:59.300
Now we could just add on top of red,
blue, and green the small, medium,

00:25:59.310 --> 00:26:02.620
and large size controls,
but then we're going to have

00:26:02.620 --> 00:26:04.100
a really cluttered dock menu.

00:26:04.250 --> 00:26:07.820
So what we really want to do
is have the ability so that

00:26:07.820 --> 00:26:11.190
when you hit the option key,
that red, blue,

00:26:11.190 --> 00:26:13.380
and green switches to small, medium,
and large.

00:26:15.660 --> 00:26:18.700
Well, again, you can create alternate
menu items in IBE.

00:26:18.760 --> 00:26:22.380
Now, alternate menu items are
not unique to doc menus.

00:26:22.480 --> 00:26:27.760
They apply to any NS menu you have,
but new in Tiger is alternate menu

00:26:27.760 --> 00:26:31.020
items are also available for the doc.

00:26:34.710 --> 00:26:38.080
So I'm sorry, back to the previous slide.

00:26:38.080 --> 00:26:42.030
The two general rules you have with
alternate menu items is that the key

00:26:42.170 --> 00:26:47.580
equivalents have to be the same and
the key modifiers have to be different.

00:26:47.600 --> 00:26:50.460
So looking at how we
would set this up in IB,

00:26:50.460 --> 00:26:53.780
remember that you always want
to work in pairs of menu items.

00:26:53.950 --> 00:26:59.160
So in this case, red is going to have the
alternate menu item small.

00:26:59.160 --> 00:27:05.780
And to do this, I have on my���� on your
left should be the red,

00:27:05.780 --> 00:27:09.020
the inspector for the red menu item,
and on your right should

00:27:09.020 --> 00:27:10.230
be the small menu item.

00:27:10.230 --> 00:27:14.100
We're going to first take a
look at the key equivalents.

00:27:14.100 --> 00:27:16.810
And notice here that
they are indeed the same,

00:27:16.840 --> 00:27:20.770
and having an empty string
for a key equivalents counts.

00:27:21.910 --> 00:27:26.010
Then we take a look at the key modifiers
and notice here that they are not unique.

00:27:26.190 --> 00:27:30.700
So let’s say for the small we are
going to have the option key checked.

00:27:30.810 --> 00:27:35.950
Once you do that,
notice that the treat as an alternate

00:27:36.290 --> 00:27:40.800
menu item check box becomes enabled
and all you have to do is check that.

00:27:40.950 --> 00:27:44.900
And now small is the
alternate menu item for red.

00:27:45.870 --> 00:27:48.000
And again,
you can do all of this in code by

00:27:48.000 --> 00:27:54.180
setting the key equivalent and the key
modifier mask using NS Menu Item APIs,

00:27:54.210 --> 00:27:57.550
as well as setting the alternate flag.

00:27:57.560 --> 00:28:02.300
And I have a quick demo
for you here as well.

00:28:02.300 --> 00:28:06.470
So first,
taking a look at the running application.

00:28:08.500 --> 00:28:10.020
We have here red, blue, and green.

00:28:10.140 --> 00:28:13.330
When I hit the Option key, I have small,
medium, and large.

00:28:13.530 --> 00:28:18.250
So when I hit it here,
it turns green with the Option.

00:28:18.460 --> 00:28:21.290
Notice here that if there are
only two colors available,

00:28:21.290 --> 00:28:25.370
we remove the middle size always,
because it would be weird

00:28:25.370 --> 00:28:27.800
to have small and medium.

00:28:29.800 --> 00:28:34.030
So that's what we're
trying to accomplish,

00:28:34.300 --> 00:28:36.350
looking at the code.

00:28:38.510 --> 00:28:41.600
And by the way,
when you look at your sample disk image,

00:28:41.690 --> 00:28:43.780
all these are the same file.

00:28:43.800 --> 00:28:48.310
They’re just slightly reordered for
demonstration purposes on stage.

00:28:50.510 --> 00:28:53.510
So notice that in addition
to creating the standard red,

00:28:53.510 --> 00:28:56.960
blue, and green colors,
for the alternates,

00:28:57.090 --> 00:29:00.510
I have the available sizes, small,
medium, and large.

00:29:01.920 --> 00:29:04.500
Right here I have the code
that basically says if I'm only

00:29:04.500 --> 00:29:10.370
displaying two color options,
remove that middle size.

00:29:11.310 --> 00:29:13.070
And here's the interesting part.

00:29:13.210 --> 00:29:16.380
So for every color I add,
and notice that once again

00:29:16.380 --> 00:29:18.680
the key equivalent is nil,

00:29:19.280 --> 00:29:24.000
I also create a menu item for the
size with the same key equivalent.

00:29:24.000 --> 00:29:27.780
And then I set the key equivalent
modifier mask to be something

00:29:27.780 --> 00:29:32.660
different than the color,
and then I set the alternate flag.

00:29:32.670 --> 00:29:34.680
And that’s it.

00:29:34.860 --> 00:29:36.600
If I can go back to slides, please.

00:29:39.930 --> 00:29:41.400
So that’s fun.

00:29:41.400 --> 00:29:43.830
But changing the color of
the dot is pretty boring and,

00:29:43.830 --> 00:29:47.760
you know, as Chuck said,
OS X is all about fun, whizzy animations.

00:29:47.800 --> 00:29:54.580
So let’s animate the dot color so
that it fades into the new color.

00:29:55.870 --> 00:29:59.300
Well, again,
new in Tiger is NSViewAnimation,

00:29:59.430 --> 00:30:04.880
which is the only current
public subclass of NSAnimation.

00:30:04.880 --> 00:30:09.300
To create an NSViewAnimation,
it takes an array of dictionaries

00:30:09.300 --> 00:30:10.900
with various properties set.

00:30:10.960 --> 00:30:14.280
The important properties that we
are going to focus on for this

00:30:14.280 --> 00:30:18.440
demonstration is the target key,
which should be the view or the

00:30:18.440 --> 00:30:22.440
window that you are trying to animate,
and the proper effect.

00:30:22.540 --> 00:30:26.140
And in this case,
we are going to use the fade-in effect.

00:30:26.140 --> 00:30:29.560
Once you set up your view animation,
all that's left to do is to run it.

00:30:29.560 --> 00:30:34.780
So this is a very easy way for you
to create animations in your app.

00:30:34.810 --> 00:30:37.390
And I'll show you the demo of that.

00:30:43.570 --> 00:30:47.740
So now,
rather than just having the color change,

00:30:47.740 --> 00:30:51.810
when I pick a different color,
it does one of those fun animations.

00:30:55.720 --> 00:31:01.640
And the code for this
is remarkably simple.

00:31:01.790 --> 00:31:05.180
So we have the original dot view,
which is the color that

00:31:05.180 --> 00:31:08.950
we're actually changing,
but we want the color to

00:31:09.100 --> 00:31:13.270
actually have the original dot
behind the fading in color.

00:31:13.270 --> 00:31:18.030
So what we're going to do to trick
it to do that is create a temporary

00:31:18.030 --> 00:31:21.280
dot view that has the same color,
origin,

00:31:21.280 --> 00:31:23.820
and radius as the actual dot view.

00:31:23.890 --> 00:31:28.910
And then we add it to our view hierarchy,
positioned above the actual dot.

00:31:30.510 --> 00:31:35.400
Next thing we do is create the
view animation with the temporary

00:31:35.870 --> 00:31:39.900
dot right here as the target.

00:31:39.900 --> 00:31:43.830
And once again, we’re going to use the
NSViewAnimationFadeIn effect

00:31:43.830 --> 00:31:45.900
for the effect key.

00:31:45.900 --> 00:31:51.320
We create a view animation with�� oops��

00:31:52.470 --> 00:31:55.300
With just that dictionary in it.

00:31:55.350 --> 00:31:58.720
And then we're going to set the
duration to one second just to

00:31:58.720 --> 00:32:01.100
make it last a little bit longer.

00:32:01.370 --> 00:32:06.300
Whereas Chuck used the non-blocking
animation for the table view sorting,

00:32:06.300 --> 00:32:10.460
we are going to run it in blocking mode
so that the actual dot's color doesn't

00:32:10.460 --> 00:32:13.700
change until the animation is complete.

00:32:13.700 --> 00:32:14.920
And then we call start animation.

00:32:16.700 --> 00:32:20.440
Notice that by the time
we reach this point here,

00:32:20.490 --> 00:32:23.510
since we are running in blocking mode,
the animation is done and so

00:32:23.510 --> 00:32:26.570
it's okay for us to release
the animation and remove the

00:32:26.670 --> 00:32:28.940
temporary dot from the super view.

00:32:28.940 --> 00:32:34.890
And that's it.

00:32:34.900 --> 00:32:34.900
If I can go back to slides.

00:32:40.600 --> 00:32:44.470
This animation is fun,
but what I really want is to

00:32:44.630 --> 00:32:50.250
be able to drag my view into a
file in a place such as Finder.

00:32:50.600 --> 00:32:55.620
But when I start that drag,
that location is unknown.

00:32:55.620 --> 00:32:57.580
So how do I create the file?

00:32:58.800 --> 00:33:01.800
Well, there are a few possible solutions.

00:33:01.800 --> 00:33:07.280
We could put the data onto the
pasteboard as an NSPDF pasteboard type.

00:33:07.410 --> 00:33:11.940
However, that’s going to leave the
responsibility to the destination

00:33:12.290 --> 00:33:15.270
to actually write that to a file.

00:33:17.080 --> 00:33:20.740
Or we can create the file at
some temporary location and

00:33:20.740 --> 00:33:26.080
once that drag is complete,
move that to the drop location.

00:33:27.470 --> 00:33:33.280
Or ideally, we’re going to delay the file
creation until the drop occurs.

00:33:33.280 --> 00:33:37.700
And to do this, we use something called
HFS file promises.

00:33:38.430 --> 00:33:41.160
In NSView,
we have a method that allows you

00:33:41.270 --> 00:33:44.200
to drag a promise file from Rect,
etc.

00:33:44.710 --> 00:33:47.640
And basically,
what you hand it here is an array

00:33:47.640 --> 00:33:52.690
of file types that you promise
to create once a drop occurs.

00:33:53.430 --> 00:33:57.140
Once the drop occurs,
we get a call to name a promise

00:33:57.350 --> 00:33:59.890
file dropped at destination.

00:34:00.030 --> 00:34:04.460
Here, you are handed a URL containing
the drop location and you lazily

00:34:04.460 --> 00:34:06.160
create the file in that spot.

00:34:06.160 --> 00:34:13.200
And to illustrate this,
we have a call to name a promise

00:34:13.200 --> 00:34:13.200
file dropped at destination.

00:34:17.830 --> 00:34:21.990
So let's say I want to be able
to drag this and have a dot in

00:34:21.990 --> 00:34:25.280
a PDF available on my desktop.

00:34:25.340 --> 00:34:28.180
And notice now that I open
in preview and look,

00:34:28.180 --> 00:34:29.210
I have my dot.

00:34:29.280 --> 00:34:32.250
So you can send Christmas cards
to all your friends with

00:34:32.270 --> 00:34:34.080
lots of dots you create.

00:34:38.450 --> 00:34:45.640
And so looking at the code here,
in the mouse drag method,

00:34:45.730 --> 00:34:49.530
here’s where we promise
the file type PDF.

00:34:51.620 --> 00:34:57.210
And then once the drop occurs,
we implement the names of promised

00:34:57.400 --> 00:34:59.500
files dropped at destination.

00:34:59.530 --> 00:35:03.560
And again, the drop destination is
handed to you as a URL.

00:35:04.590 --> 00:35:08.130
We have some clever code here
that basically computes the

00:35:08.210 --> 00:35:13.200
file name so that if we don't
overwrite a current existing file.

00:35:13.520 --> 00:35:15.150
For those of you who have
never seen this method,

00:35:15.150 --> 00:35:18.930
this is an NSView method
that basically allows you to

00:35:18.930 --> 00:35:23.140
create a PDF out of any view.

00:35:23.220 --> 00:35:25.750
So we create the data with that.

00:35:27.060 --> 00:35:31.350
And notice here that I create
the file URL and I root that file

00:35:31.350 --> 00:35:34.350
name to the drop destination.

00:35:34.830 --> 00:35:36.700
and a write to that file.

00:35:36.740 --> 00:35:41.930
What I return in this method is an
array of the file names I have written.

00:35:46.160 --> 00:35:47.860
And so that’s great.

00:35:47.910 --> 00:35:51.720
But let’s say I have this Finder window
and I’ve traversed this whole hierarchy

00:35:51.720 --> 00:35:53.510
for where I want to place a file.

00:35:53.720 --> 00:35:56.740
But notice that as soon
as I click to drag,

00:35:56.790 --> 00:36:03.500
I’ve now covered my Finder window and
I no longer know where to drag to.

00:36:03.500 --> 00:36:03.500
So what you really want

00:36:04.100 --> 00:36:06.400
The first step is to delay
that window ordering so that

00:36:06.400 --> 00:36:12.420
once I start drag operation,
the application is not ordered front.

00:36:12.420 --> 00:36:16.500
But if I click on the mouse up,
the window orders front.

00:36:16.500 --> 00:36:18.700
So that way it's really easy
if I have my finder window,

00:36:18.700 --> 00:36:25.500
I can drag and not block
that finder window.

00:36:25.500 --> 00:36:25.500
And if I go back to slides here.

00:36:30.750 --> 00:36:34.110
So how do I prevent my
application from blocking other

00:36:34.250 --> 00:36:36.600
windows during a drag operation?

00:36:36.600 --> 00:36:38.190
And this is very simple.

00:36:38.190 --> 00:36:42.330
In NSWindow, there's an NSView method
that you can override,

00:36:42.950 --> 00:36:46.530
should delay window ordering for event,
and if you return yes,

00:36:46.570 --> 00:36:53.380
the event���� the window will not be
ordered until your mouse-up event.

00:36:53.380 --> 00:36:56.790
And now at this point,
I'd like to invite up the next presenter,

00:36:56.790 --> 00:36:57.890
Hansen Hsu.

00:37:05.640 --> 00:37:07.500
Thank you, Tina.

00:37:07.550 --> 00:37:11.100
Hi, my name is Hansen Hsu,
and I’m an engineer in the Cocoa Group.

00:37:11.130 --> 00:37:14.740
And for the next ten minutes,
I’d like to show you how you can

00:37:14.740 --> 00:37:18.810
use child windows and Overlue
windows in your applications.

00:37:20.500 --> 00:37:27.570
So let’s say I have an application and
I have a main application window and

00:37:27.570 --> 00:37:34.790
I want to create a secondary window.

00:37:34.790 --> 00:37:34.790
Actually, go back to slides, please.

00:37:37.900 --> 00:37:44.100
Well actually, I'll just show you if
it's a... This is it...

00:37:49.140 --> 00:37:55.600
I have a main window here,
and here's my auxiliary window.

00:37:55.650 --> 00:38:02.360
This is useful for, say,
I have a utility window or a tool

00:38:02.360 --> 00:38:08.420
palette that I want to be stuck
to my main application window.

00:38:08.810 --> 00:38:16.240
Such that if I move the main window,
everything moves along with it.

00:38:16.240 --> 00:38:21.300
So, how do I do that?

00:38:21.300 --> 00:38:21.300
Back

00:38:25.690 --> 00:38:33.560
So we're going to do this by using
something called a child window.

00:38:33.560 --> 00:38:38.390
We're going to make our auxiliary window
a child window of our main window.

00:38:38.610 --> 00:38:41.290
So we do this by,
very simply by calling a

00:38:41.290 --> 00:38:46.330
method on NSWindow called,
surprisingly, addChildWindow.

00:38:46.690 --> 00:38:46.980
Ordered.

00:38:47.000 --> 00:38:50.020
And we're going to give it
one of two ordering modes,

00:38:50.170 --> 00:38:52.800
above or below.

00:38:52.800 --> 00:38:56.740
And so we can make our child
window either ordered above

00:38:56.810 --> 00:38:58.500
or below the main window.

00:38:58.710 --> 00:39:00.400
And that's pretty much it.

00:39:00.480 --> 00:39:01.810
That's all we need to do.

00:39:01.970 --> 00:39:06.190
So now let's take a look
at this in our actual code.

00:39:06.350 --> 00:39:07.400
Back to demo machine one, please.

00:39:13.190 --> 00:39:14.940
So here we are.

00:39:14.940 --> 00:39:19.170
We’re going to start with the
Dot View application again

00:39:19.330 --> 00:39:21.320
that we all know and love.

00:39:21.370 --> 00:39:26.150
And we have added a new
controller class to our Dot View.

00:39:27.620 --> 00:39:33.770
and we're going to set up our
child window in Awake from Nib.

00:39:34.510 --> 00:39:39.210
So we could have created our child
window either in Interface Builder,

00:39:39.260 --> 00:39:44.550
but today we're going to do it in code,
just to show you what it looks like.

00:39:44.550 --> 00:39:49.290
And here we're going to set up the
frame rectangle of our child window,

00:39:49.290 --> 00:39:55.190
and then we're going to
instantiate our child window here.

00:39:56.600 --> 00:40:02.500
Next, we're going to tell the main window

00:40:03.060 --> 00:40:07.860
To add our child window,
and we're going to order

00:40:07.860 --> 00:40:10.900
it above the main window.

00:40:12.370 --> 00:40:16.110
Now next, after that,
we’re going to order it

00:40:16.620 --> 00:40:18.840
above the main window again.

00:40:18.900 --> 00:40:21.260
That seems a little redundant.

00:40:21.260 --> 00:40:26.490
The reason why we’re going to order it
relative to the main window again is to

00:40:26.610 --> 00:40:32.840
work around a bug that I found when I was
writing this demo involving I wasn’t

00:40:32.840 --> 00:40:34.060
receiving mouse clicks correctly.

00:40:34.060 --> 00:40:40.440
So what turns out is we need to make
this call in order to tell the app kit

00:40:40.550 --> 00:40:42.860
to properly register itself for events.

00:40:42.860 --> 00:40:45.470
So without doing this,
the window doesn’t���� the

00:40:45.470 --> 00:40:47.940
app kit doesn’t know that
the window is actually there.

00:40:48.020 --> 00:40:51.590
So we’re going to do that.

00:40:52.010 --> 00:40:56.840
Next, we’re going to draw a dot
view in our child window.

00:40:56.840 --> 00:41:03.510
So we’re going to create a new dot view,
and we’re going to set the content view

00:41:03.510 --> 00:41:06.360
of our child window to the dot view.

00:41:06.360 --> 00:41:12.120
So as you can see,
going back to our����oops����we’re

00:41:13.940 --> 00:41:20.100
Going back to our�� I think
I may have recompiled it.

00:41:25.430 --> 00:41:31.690
Going back to our demo here,
that we can move the dot around.

00:41:32.620 --> 00:41:37.570
and we can move the dot around
the main window and I can move

00:41:37.580 --> 00:41:41.070
this child window anywhere I want.

00:41:42.070 --> 00:41:45.500
So I can move over here and
everything just works correctly.

00:41:45.500 --> 00:41:50.100
It will always stay in the same
relative position to the main window.

00:41:53.800 --> 00:41:55.800
Great.

00:41:55.800 --> 00:42:00.830
So now I've got two dots,
one in each window.

00:42:01.360 --> 00:42:06.640
So given that my brain sometimes
thinks like a three-year-old,

00:42:06.670 --> 00:42:10.950
I want to connect the dots.

00:42:10.950 --> 00:42:10.950
Go back to slides, please.

00:42:13.080 --> 00:42:17.800
So, like any three-year-old
who plays connect the dots,

00:42:17.840 --> 00:42:21.250
I'm probably going to
draw outside the lines.

00:42:21.690 --> 00:42:23.870
In this case,
I have to draw outside the lines

00:42:23.960 --> 00:42:28.680
because I'm going to be drawing a
guideline in between the two windows,

00:42:28.680 --> 00:42:32.760
from the dot in my main window
to the dot in my child window.

00:42:32.860 --> 00:42:37.320
So I have to draw outside
the bounds of my windows.

00:42:37.340 --> 00:42:39.390
How the heck do I do that?

00:42:39.590 --> 00:42:41.930
Well, the answer is you don't.

00:42:42.000 --> 00:42:43.990
I'm going to have to fake it.

00:42:44.130 --> 00:42:46.890
So I'm going to fake it
by creating a new window,

00:42:46.890 --> 00:42:51.260
a third window, and I'm going to make
that window invisible.

00:42:51.260 --> 00:42:56.260
And this window is
called an overlay window.

00:42:56.880 --> 00:43:00.300
Now, a number of things to remember
about overlay windows.

00:43:00.370 --> 00:43:02.790
An overlay window, number one,
and most importantly,

00:43:02.800 --> 00:43:04.990
is just another child window.

00:43:05.100 --> 00:43:08.570
So it’s exactly the same as
my previous child window.

00:43:09.080 --> 00:43:11.000
Except for one thing.

00:43:11.000 --> 00:43:11.990
Well, several things, actually.

00:43:11.990 --> 00:43:15.950
Two, we’re going to overlay it
above its parent window.

00:43:15.950 --> 00:43:19.860
And three, we’re going to make its
background transparent.

00:43:19.860 --> 00:43:22.310
This is probably the
most important thing.

00:43:22.310 --> 00:43:26.040
We want it to both appear transparent,
invisible to the user,

00:43:26.040 --> 00:43:29.130
and we want it to be
transparent to events,

00:43:29.130 --> 00:43:32.820
so that if you click anywhere
on the overlay window,

00:43:33.080 --> 00:43:36.240
mouse clicks pass through
to whatever is below it.

00:43:36.240 --> 00:43:39.640
And lastly, we want to make the
overlay window borderless.

00:43:39.640 --> 00:43:41.740
So that means we can’t create an IB.

00:43:41.760 --> 00:43:43.680
We have to do it in code.

00:43:44.750 --> 00:43:49.910
So let's go back to the
demo and take a look.

00:43:56.900 --> 00:44:03.800
[Transcript missing]

00:44:04.470 --> 00:44:08.240
Everything over here is
the same code as before,

00:44:08.910 --> 00:44:11.000
setting up our child window.

00:44:11.000 --> 00:44:13.260
Now we’re going to set up a new
window called an overlay window.

00:44:13.270 --> 00:44:15.820
We��re going to call
it an overlay window.

00:44:16.060 --> 00:44:19.910
Now, since an overlay window is
just another child window,

00:44:19.950 --> 00:44:21.230
if you take a close look,

00:44:21.510 --> 00:44:24.780
The code is almost exactly
the same as what we did when

00:44:24.810 --> 00:44:26.770
we set up our child window.

00:44:27.470 --> 00:44:29.790
Some differences.

00:44:29.850 --> 00:44:35.330
One, we want to draw on top of
both our previous two windows,

00:44:35.520 --> 00:44:40.580
so we want the size of our overlay window
to be the union of the other two windows.

00:44:40.980 --> 00:44:46.500
Next, we're going to programmatically
instantiate this.

00:44:46.560 --> 00:44:54.590
Note, we're going to give it a mask,
an NSWindow borderless window mask.

00:44:56.160 --> 00:45:01.500
Then, we're going to add it as a child
window on top of our main window.

00:45:04.450 --> 00:45:09.190
Here, most importantly,
these two lines were going to make

00:45:09.230 --> 00:45:11.300
the window background transparent.

00:45:11.300 --> 00:45:15.800
First, we’re going to set opaque
no so that events will pass

00:45:15.800 --> 00:45:18.300
through the window background.

00:45:18.300 --> 00:45:22.920
Then, we’re going to set its
background color to clear.

00:45:24.770 --> 00:45:31.930
Now we need to draw our guideline
into some view in our overlay window.

00:45:31.940 --> 00:45:36.580
So what I’ve done is I’ve created
a custom subclass of NSView that

00:45:36.620 --> 00:45:39.580
I��m going to draw into,
and I’m not going to show

00:45:39.710 --> 00:45:40.610
that code to you now.

00:45:40.610 --> 00:45:42.040
You can see that on the disk.

00:45:42.110 --> 00:45:46.500
But we’re going to instantiate that view,
and we’re going to set it as the

00:45:46.550 --> 00:45:48.550
content view of our overlay window.

00:45:50.600 --> 00:45:57.840
So, if we run this, you can see, voila,
we have a line drawn in

00:45:57.840 --> 00:46:00.710
between our two windows.

00:46:01.250 --> 00:46:05.620
And you can clearly see here
that whatever is below it

00:46:05.620 --> 00:46:08.060
is clearly showing through.

00:46:08.370 --> 00:46:14.080
And I can move this around over here.

00:46:17.370 --> 00:46:22.300
I can move the dot around,
everything just updates correctly.

00:46:22.300 --> 00:46:25.360
So, I can go to the

00:46:26.010 --> 00:46:32.180
Another thing I can do is I can resize
this window and everything will update.

00:46:32.280 --> 00:46:37.950
Now a couple of things need to be
done in order for this to work.

00:46:37.960 --> 00:46:41.510
So one thing is if we
move the child window

00:46:42.320 --> 00:46:47.340
We want to tell the overlay
view to redraw itself.

00:46:47.340 --> 00:46:52.440
And if we resize the main window,
we want it to do the same thing.

00:46:52.460 --> 00:46:55.270
And another thing we need to do
is we need to remember that since

00:46:55.270 --> 00:47:01.530
the overlay window's size is the
union of these other two windows,

00:47:01.560 --> 00:47:04.420
since it's dependent on
these other two windows,

00:47:04.420 --> 00:47:08.290
so if I move this around or if
I resize either of these two windows,

00:47:08.290 --> 00:47:12.940
I'm going to need also to tell the
overlay window to update its size.

00:47:13.200 --> 00:47:16.980
So we're going to do that
in our controller again.

00:47:18.360 --> 00:47:23.800
and we're going to implement two
delegate methods on NSWindow.

00:47:23.800 --> 00:47:26.590
Window did move and window did resize.

00:47:26.610 --> 00:47:32.460
We're going to listen to these
notifications and if the main window

00:47:32.460 --> 00:47:39.160
or the child window moves or resizes,
we're going to do two things.

00:47:39.160 --> 00:47:39.160
We're going to listen to

00:47:39.720 --> 00:47:42.770
Tell the Overlay View to update itself,
and we're going to tell the

00:47:42.770 --> 00:47:45.870
Overlay Window to resize itself.

00:47:46.490 --> 00:47:50.490
Of course,
there's one little extra detail

00:47:50.490 --> 00:47:55.900
is when we only want to do
this if the child window moves,

00:47:55.900 --> 00:47:58.340
we don't want to do it if
the parent window moves.

00:47:58.340 --> 00:48:01.560
And the reason for that is because
when we move the parent window,

00:48:01.560 --> 00:48:03.400
the child window always
moves along with it.

00:48:03.400 --> 00:48:04.520
So we'd be doing it twice.

00:48:04.520 --> 00:48:05.900
So we don't want to do that.

00:48:05.900 --> 00:48:12.780
So here, we're going to check explicitly
to see if the window that's

00:48:12.780 --> 00:48:14.810
being moved is the child window.

00:48:15.570 --> 00:48:17.070
So great.

00:48:17.080 --> 00:48:18.040
Everything just works.

00:48:18.040 --> 00:48:20.730
We can move this around.

00:48:20.730 --> 00:48:23.880
We can resize it at will.

00:48:24.990 --> 00:48:32.770
and we have our nice little guideline
drawn between these two dots.

00:48:32.770 --> 00:48:32.770
All right.

00:48:32.770 --> 00:48:32.770
Back to

00:48:34.060 --> 00:48:36.510
So there's a number of other
things that we can do now that we

00:48:36.510 --> 00:48:38.380
know how to use overlay windows.

00:48:38.490 --> 00:48:41.480
For instance,
we can draw controls in overlay windows.

00:48:41.610 --> 00:48:45.960
This allows us to do interesting
things such as draw controls on top

00:48:46.090 --> 00:48:49.260
of NSMovieViews and NSOpenGLViews.

00:48:49.260 --> 00:48:53.330
As you know, neither of these two views
can normally���� you can't

00:48:53.330 --> 00:48:55.430
normally embed controls in them.

00:48:55.580 --> 00:49:00.450
So this allows you to make it look
like you've got buttons sitting

00:49:00.830 --> 00:49:03.370
on top of your movies or on top of

00:49:04.440 --> 00:49:08.140
So that about wraps it up for
child windows and overlay windows.

00:49:08.140 --> 00:49:12.900
Next,
I would like to introduce Doug Davidson,

00:49:12.900 --> 00:49:15.810
our resident text expert.

00:49:22.000 --> 00:49:23.000
Thank you, Hansen.

00:49:23.000 --> 00:49:25.900
Let’s go to the next question.

00:49:25.910 --> 00:49:30.330
So this question here is
about text completion.

00:49:30.330 --> 00:49:35.660
Now, if you want the sort of completion
behavior where the user is typing

00:49:35.660 --> 00:49:40.010
along your application and hits
a key and is presented with a

00:49:40.040 --> 00:49:44.860
list of completions taken from
the standard system dictionary,

00:49:44.860 --> 00:49:47.920
then you have to do absolutely nothing.

00:49:47.980 --> 00:49:49.390
That behavior is built
into the text system.

00:49:49.390 --> 00:49:49.390
But

00:49:49.600 --> 00:49:53.330
There is a reasonable chance that
your application has a somewhat

00:49:53.410 --> 00:49:57.640
better idea than that of what
the user might be trying to type.

00:49:57.760 --> 00:50:02.540
So in that case,
you can customize this behavior.

00:50:02.540 --> 00:50:04.480
And how can you do that?

00:50:04.580 --> 00:50:09.030
Well, first and most obviously,
if you have a subclass of NS TextView,

00:50:09.320 --> 00:50:15.620
then you have complete control over
all aspects of the completion behavior.

00:50:15.620 --> 00:50:18.700
If any of you were here
last year in the text talk,

00:50:18.700 --> 00:50:20.940
I presented an example of this.

00:50:21.070 --> 00:50:24.220
Some of the methods you can use,
you can replace the completion

00:50:24.420 --> 00:50:29.020
behavior entirely by implementing
your own version of complete.

00:50:29.020 --> 00:50:33.280
Or you are allowed to control
the range in text that the user

00:50:33.300 --> 00:50:38.160
is presumed to be completing by
implementing range for user completion.

00:50:38.270 --> 00:50:41.940
Or you can supply a custom list
of completions by overriding

00:50:42.090 --> 00:50:44.980
completions for partial word range,
et cetera.

00:50:44.980 --> 00:50:50.680
And you can provide custom behavior
when the completion is inserted back

00:50:50.680 --> 00:50:56.390
into the text by overriding insert
completion for partial word range,

00:50:56.520 --> 00:50:58.120
et cetera, et cetera.

00:50:58.120 --> 00:51:00.880
But that's not really what
I want to talk about here today.

00:51:01.160 --> 00:51:04.130
What I want to talk about today
is what you can do if you're

00:51:04.140 --> 00:51:08.930
not a subclass of NS TextView,
but just the delegate of an NS TextView.

00:51:09.000 --> 00:51:13.590
And really, you can do quite a lot there.

00:51:13.780 --> 00:51:17.480
First and most obviously,
the delegate of the text view is

00:51:17.480 --> 00:51:27.120
given the opportunity to control
and alter and change and completely

00:51:28.220 --> 00:51:28.220
control the list of completions
that is presented to the user.

00:51:28.670 --> 00:51:34.430
Also, the TextViews delegate is notified
and given the opportunity to control

00:51:34.890 --> 00:51:38.900
any time the user changes the text.

00:51:39.130 --> 00:51:42.880
and the TextViews delegate is
notified and given the opportunity

00:51:42.880 --> 00:51:48.240
to control whenever the user
changes the selection in the text.

00:51:48.370 --> 00:51:51.970
And if you put these together,
you can combine them to produce

00:51:51.970 --> 00:51:54.100
a number of interesting effects.

00:51:54.230 --> 00:52:01.760
And if we can go over to demo number two,
I want to present a simple

00:52:01.760 --> 00:52:05.650
little example of that.

00:52:05.860 --> 00:52:08.950
So let's just run it.

00:52:13.000 --> 00:52:24.770
This application is what I like to
call my Macintosh writer's companion.

00:52:24.770 --> 00:52:24.770
When you're writing about the Macintosh,

00:52:26.310 --> 00:52:29.020
You're always saying
Mac this and Mac that.

00:52:29.170 --> 00:52:31.690
So when you're writing
in this application,

00:52:31.700 --> 00:52:34.580
let me make this a little bigger.

00:52:35.450 --> 00:52:37.420
Whenever you type Mac,
after a brief pause,

00:52:37.420 --> 00:52:39.960
it helpfully and automatically
offers to complete it to

00:52:39.960 --> 00:52:45.700
one of these standard forms:
Macintosh, Mac OS, Mac OS X.

00:52:50.300 --> 00:52:57.050
Mac, wait, there it is.

00:52:57.090 --> 00:53:00.120
So, how did we do that?

00:53:00.130 --> 00:53:02.200
Let’s take a look at the code.

00:53:08.400 --> 00:53:12.860
So the primary thing that we
have here is a little timer.

00:53:13.010 --> 00:53:16.180
And it’s the timer that
handles this brief pause.

00:53:16.430 --> 00:53:21.100
And when the timer fires,
it calls this method doCompletion.

00:53:21.190 --> 00:53:26.660
And really all that does is to
call complete on our text view.

00:53:26.700 --> 00:54:24.300
[Transcript missing]

00:54:24.810 --> 00:54:28.900
So we keep track of that and make
sure that we don't do it in that case.

00:54:29.090 --> 00:54:33.400
And then when that timer fires after
the brief pause and complete is called,

00:54:33.400 --> 00:54:37.100
then the TextViews delegate gets
called again to determine the list

00:54:37.100 --> 00:54:38.940
of completions to be presented.

00:54:38.940 --> 00:54:42.020
And so we implement the
delegate method for that.

00:54:42.020 --> 00:54:46.390
And there we just notice,
we check to see whether the

00:54:46.390 --> 00:54:49.460
string that we're being asked
to complete is actually Mac.

00:54:49.510 --> 00:54:51.950
And if it is,
then we offer to complete it with,

00:54:52.020 --> 00:54:55.670
in this case,
just this fixed list of Macintosh,

00:54:55.760 --> 00:54:57.210
Mac OS, Mac OS X.

00:54:57.890 --> 00:54:59.930
and that's all there is to it.

00:55:00.000 --> 00:55:02.980
So let's go back to the slides.

00:55:06.820 --> 00:55:10.500
And we can take a look
at the next question.

00:55:10.500 --> 00:55:18.020
So the next question here has to do with
mixing images and text in our cells.

00:55:18.150 --> 00:55:22.250
Now when we think about a text cell,
normally what we think

00:55:22.420 --> 00:55:23.840
of is just plain text.

00:55:23.980 --> 00:55:27.210
But what may not be entirely
obvious is that you have the

00:55:27.210 --> 00:55:31.760
full power of the Cocotext system
available to you whenever you use it.

00:55:31.950 --> 00:55:36.940
So if you can display it in TextEdit,
you can display it in a cell

00:55:36.940 --> 00:55:39.250
or using string drawing.

00:55:39.360 --> 00:55:41.690
And of course,
one of the things that you can do in

00:55:41.690 --> 00:55:47.780
TextEdit is to drag in images and have
them displayed in line in the text.

00:55:48.410 --> 00:55:53.300
So that's fine in TextEdit,
but how can you do that programmatically?

00:55:53.300 --> 00:55:59.320
Well, programmatically,
images are a case of what

00:55:59.320 --> 00:56:01.230
we call attached files.

00:56:01.230 --> 00:56:05.900
And the way that attached files
are represented in a distributed

00:56:06.740 --> 00:56:11.980
string is as a special character,
the attachment character,

00:56:11.990 --> 00:56:15.280
which has on it a special attribute,
the attachment attribute.

00:56:15.440 --> 00:56:18.980
And the value of that attachment
attribute is an instance of

00:56:19.080 --> 00:56:21.560
the class nsTextAttachment.

00:56:21.560 --> 00:56:25.950
nsTextAttachment models the
contents of the attached file.

00:56:26.000 --> 00:56:29.620
To do that, it uses an NSFileWrapper.

00:56:29.630 --> 00:56:30.090
That's optional.

00:56:30.100 --> 00:56:34.020
You don't absolutely have to
have that if you don't need it.

00:56:34.140 --> 00:56:36.890
And the other thing that it has
to do is that it has to provide

00:56:37.070 --> 00:56:41.180
some visual representation to be
displayed in line in the text.

00:56:41.180 --> 00:56:46.800
And to do this, naturally,
it uses a cell, an nsTextAttachment cell.

00:56:47.460 --> 00:56:51.690
and by default, NS Text Detachment will
automatically generate an

00:56:51.710 --> 00:56:53.610
appropriate text detachment cell.

00:56:53.700 --> 00:56:55.560
But you don't have to let it do that.

00:56:55.630 --> 00:56:58.950
If you know what you want your
visual representation to be,

00:56:59.000 --> 00:57:00.750
you can supply it.

00:57:00.800 --> 00:57:07.290
You can use a completely custom
NS Text Detachment cell subclass.

00:57:07.300 --> 00:57:10.950
If you want to see an example of that,
come to the Cocoa Text talk on Friday,

00:57:11.090 --> 00:57:12.380
session 437.

00:57:12.380 --> 00:57:14.030
I'll give an example of that.

00:57:14.200 --> 00:57:17.680
But what I'm going to talk about
now is that you can use a standard

00:57:17.680 --> 00:57:22.070
text detachment cell and just set
an arbitrary image on it to be

00:57:22.270 --> 00:57:24.120
displayed in line in the text.

00:57:26.130 --> 00:57:29.200
And here are some of the relevant APIs.

00:57:29.200 --> 00:57:32.540
The cells and controls and so forth
can have an attributed string value,

00:57:32.540 --> 00:57:35.320
not just a plain string value.

00:57:35.590 --> 00:57:39.120
You can create an attributed
string directly from an attachment.

00:57:39.120 --> 00:57:40.830
That's a convenience method.

00:57:40.870 --> 00:57:43.210
So you don't have to deal
with the attachment character

00:57:43.220 --> 00:57:45.700
and attribute and so forth.

00:57:45.760 --> 00:57:49.220
You create an attached attachment
with a file wrapper if you have one.

00:57:49.220 --> 00:57:51.260
You can query it for its attachment cell.

00:57:51.260 --> 00:57:53.280
You can set its attachment cell.

00:57:53.280 --> 00:57:57.880
And you can create this attachment
cell with an image of your choosing,

00:57:57.880 --> 00:57:59.020
if you like.

00:57:59.570 --> 00:58:12.340
So if we can go back to demo two,
let me give a little example of that.

00:58:12.340 --> 00:58:14.840
So let’s run it.

00:58:15.750 --> 00:58:15.750
Now what we have here

00:58:18.500 --> 00:58:19.260
Very simple.

00:58:19.450 --> 00:58:22.180
It’s nothing more than a list of colors.

00:58:22.210 --> 00:58:26.940
Each color has a name and a little
color swatch to show you what it is.

00:58:27.990 --> 00:58:33.050
and perfectly ordinary except that
what we have over here is just

00:58:33.050 --> 00:58:37.200
a stock one-column table view.

00:58:37.200 --> 00:58:38.900
No custom cell, no custom anything.

00:58:38.900 --> 00:58:41.280
It’s dragged directly
out of Interface Builder.

00:58:41.400 --> 00:58:45.370
The only code that’s written
here is in the data source.

00:58:45.410 --> 00:58:47.730
So let’s take a look at that code.

00:58:52.790 --> 00:58:54.970
I made this really simple.

00:58:54.970 --> 00:58:59.100
All I have to provide the data
is one array of colors and a

00:58:59.100 --> 00:59:03.420
parallel array of color names
that I set up at the beginning,

00:59:03.550 --> 00:59:05.140
just fixed and static.

00:59:05.230 --> 00:59:08.870
And so the number of rows in
TableView is always fixed as

00:59:08.870 --> 00:59:10.920
the count of those arrays.

00:59:11.010 --> 00:59:18.080
The really interesting code here is all
in the TableView object value column row.

00:59:18.190 --> 00:59:22.110
So what I'm going to do here is create
an appropriate attributed string that

00:59:22.110 --> 00:59:25.460
has in it both an image and the text.

00:59:26.070 --> 00:59:30.000
So I get my color and
the name of the color,

00:59:30.000 --> 00:59:32.680
and I'm going to create an attachment.

00:59:32.690 --> 00:59:35.000
I don't need a file wrapper here,
so I'll just use nil.

00:59:35.030 --> 00:59:38.790
And I'll create a text attachment cell.

00:59:39.440 --> 00:59:40.570
A blank one.

00:59:40.800 --> 00:59:45.100
And I'm going to create an
image that I will use to be

00:59:45.420 --> 00:59:48.080
an image for my color swatch.

00:59:48.080 --> 00:59:52.480
And then I'm going to create
a mutable attributed string.

00:59:52.850 --> 00:59:57.260
Now, when I create it to start off with,
I'll just have the color

00:59:57.690 --> 01:00:00.480
name string as its contents.

01:00:00.500 --> 01:00:02.200
That's not very interesting.

01:00:02.250 --> 01:00:08.690
Then what I want to do is to take
my text attachment and to insert it

01:00:08.690 --> 01:00:13.100
into the beginning of that string,
that attributed string.

01:00:13.100 --> 01:00:17.390
So I'll replace the beginning of that
attributed string with an attributed

01:00:17.710 --> 01:00:20.530
string created from my attachment.

01:00:20.600 --> 01:00:22.060
Very simple.

01:00:22.110 --> 01:00:26.240
And then�� oh, yes.

01:00:26.240 --> 01:00:29.740
Somebody was actually asking about
this on one of our mailings just today.

01:00:29.810 --> 01:00:33.200
I wanted to shift the
image down a little bit.

01:00:33.200 --> 01:00:38.360
So I'm going to go ahead and do that.

01:00:38.360 --> 01:00:44.160
And then I'm going to
go ahead and add a new

01:00:44.580 --> 01:00:47.370
Simple little shift,
moves it down so they

01:00:47.380 --> 01:00:49.280
line up nice and neatly.

01:00:49.300 --> 01:00:52.960
Now I need to make this image,
so I lock focus on my image,

01:00:52.960 --> 01:00:55.730
set my color, fill it up,
and I get a color swatch.

01:00:58.400 --> 01:01:03.110
Then all I have to do is
attach the image to the cell,

01:01:03.110 --> 01:01:07.000
assign the cell to the attachment,

01:01:07.500 --> 01:01:09.560
Now everything is held onto
by the attributed string,

01:01:09.560 --> 01:01:12.890
so I can release the image, the cell,
and the attachment,

01:01:12.960 --> 01:01:15.460
return my attributed string.

01:01:16.100 --> 01:01:17.040
And we are done.

01:01:17.100 --> 01:01:18.300
That is it.

01:01:18.410 --> 01:01:19.770
So that's our example.

01:01:19.870 --> 01:01:21.200
We can go back to the slides.

01:01:23.470 --> 01:01:27.110
and you can download this tonight,
use it tomorrow.

01:01:27.220 --> 01:01:30.360
And now,
I would like to invite Chuck back

01:01:30.360 --> 01:01:33.190
up to wrap things up here.

01:01:38.670 --> 01:01:40.600
Hi again, everybody.

01:01:40.600 --> 01:01:42.940
So I hope you have
enjoyed everything so far,

01:01:43.160 --> 01:01:46.110
but we saved the best,
most exciting thing for last.

01:01:46.260 --> 01:01:48.600
Hopefully we just blow you
out of the water with this.

01:01:48.620 --> 01:01:51.780
We're going to show you
some debugging tips.

01:01:52.440 --> 01:01:54.840
Well, it’s not very exciting maybe,
but it’s something that

01:01:54.840 --> 01:01:56.170
everybody here has to deal with.

01:01:56.280 --> 01:02:00.910
And our goal with this here is to show
you some tips specific to Cocoa which

01:02:01.000 --> 01:02:03.170
can help you in your daily work.

01:02:05.770 --> 01:02:07.920
Okay, so what are we going to talk
about for debugging-wise?

01:02:07.980 --> 01:02:11.530
We're going to show you some
debug settings that you can

01:02:11.530 --> 01:02:14.200
set up that will help you,
some GDB tips,

01:02:14.260 --> 01:02:18.240
and we've got some ideas for
helping you debug crashes.

01:02:18.990 --> 01:02:22.000
All right, so first,
what do I mean by debug defaults?

01:02:22.210 --> 01:02:24.660
Most of you probably know,
but I'm just going to review.

01:02:24.660 --> 01:02:28.060
You can set defaults that
apply either specifically to an

01:02:28.140 --> 01:02:30.870
application or to the entire system.

01:02:31.200 --> 01:02:35.110
And I have an example here
which shows how to set the

01:02:35.110 --> 01:02:37.620
NSFU default to some value.

01:02:37.620 --> 01:02:40.410
And I've done it in the command
line using defaults right.

01:02:40.440 --> 01:02:45.340
So this is a way to persistently
set a default that will live

01:02:45.450 --> 01:02:48.170
forever until you get rid of it.

01:02:48.170 --> 01:02:51.400
Or if you want to just set it for a
particular run of the application,

01:02:51.430 --> 01:02:52.140
there's two ways you can do it.

01:02:52.140 --> 01:02:55.800
You can launch the application
from the command line and specify

01:02:56.030 --> 01:02:58.150
-nsfu default and give the value.

01:02:58.240 --> 01:03:01.630
Or you could do it in Xcode
by finding the appropriate

01:03:01.630 --> 01:03:03.690
pane and setting the value.

01:03:04.390 --> 01:03:06.080
Okay,
so what are some interesting defaults

01:03:06.130 --> 01:03:07.740
that might help you during debugging?

01:03:07.740 --> 01:03:10.380
Now, the first thing I want to
mention with all of these things,

01:03:10.590 --> 01:03:12.530
these defaults,
these different tips we have,

01:03:12.540 --> 01:03:14.530
maybe some methods
we’re going to suggest,

01:03:14.720 --> 01:03:17.220
these are all meant
strictly for debugging.

01:03:17.220 --> 01:03:19.290
They’re not strictly supported.

01:03:19.290 --> 01:03:23.490
They may be documented somewhere, maybe,
but the idea is that these are

01:03:23.490 --> 01:03:27.020
to help you for debugging only
and help to save you some time,

01:03:27.070 --> 01:03:29.940
but they should never be
in a shipping application.

01:03:30.040 --> 01:03:32.120
Okay, so NSShowAllViews.

01:03:32.140 --> 01:03:36.940
With that said, sorry,
NSShowAllViews can be set to yes or no,

01:03:36.940 --> 01:03:39.140
and when you set it to yes,
it’s going to show you

01:03:39.140 --> 01:03:42.260
something really ugly,
but the really ugly thing might actually

01:03:42.370 --> 01:03:44.140
end up being pretty useful for you.

01:03:44.140 --> 01:03:46.870
What it’s going to do is show you where
everything in the view hierarchy lives.

01:03:46.870 --> 01:03:49.370
It��s going to outline everything
with a different color,

01:03:49.370 --> 01:03:52.400
and it might help you to discover that,
oh, I’ve got a blank view

01:03:52.400 --> 01:03:54.460
covering my other view,
and that’s why it’s not��

01:03:54.580 --> 01:03:58.140
why I don’t see my view,
or you know, they’re not lining up right

01:03:58.140 --> 01:03:59.960
because other views are lining up.

01:03:59.960 --> 01:04:03.780
It’s a useful thing, I find.

01:04:03.780 --> 01:04:07.300
The next thing I want to talk
about is NSShowAllDrawing.

01:04:07.300 --> 01:04:11.680
When you set that to yes,
it will sort of act like Quartz debug.

01:04:11.690 --> 01:04:14.270
Now,
one�� those of you who use Quartz debug,

01:04:14.280 --> 01:04:17.820
one disadvantage to Quartz debug,
it flashes the screen in yellow,

01:04:18.120 --> 01:04:22.240
but it flashes the buffer area
that’s being flushed to the screen,

01:04:22.240 --> 01:04:24.780
and the buffer area is
normally a coalesced area.

01:04:24.780 --> 01:04:27.650
So if I just drew an area up here
and I drew an area down here,

01:04:27.650 --> 01:04:29.830
I’m going to�� the whole
area is going to get flushed.

01:04:30.080 --> 01:04:34.180
And it might mistakenly convince
you that you’re drawing that entire

01:04:34.180 --> 01:04:35.940
region when you’re really not.

01:04:35.940 --> 01:04:40.350
So this is a little more targeted and
will help you see what draw rect code

01:04:40.360 --> 01:04:44.180
is actually being invoked and run.

01:04:44.180 --> 01:04:46.920
One other note is that this
works much better on Tiger.

01:04:46.920 --> 01:04:53.250
It doesn’t work quite as well on Panther,
so that’s just using it mostly on Tiger.

01:04:53.260 --> 01:04:55.400
The value can be set to yes,
or it can be set to an integer

01:04:55.400 --> 01:04:58.260
which specifies how long to delay
between the flashing of yellow.

01:04:58.260 --> 01:05:01.420
So in this example, in the open,
I’m going to go to the open panel here.

01:05:01.600 --> 01:05:03.970
Let’s say I click on, I guess, media.

01:05:03.970 --> 01:05:06.630
And when I click on media,
it’s going to show me that the pop-up

01:05:06.720 --> 01:05:09.980
has to draw because it now has to
show media instead of what it used to.

01:05:10.190 --> 01:05:13.190
And the new column that��s
being loaded is going to flash.

01:05:13.230 --> 01:05:14.430
And that’s where you are going to see it.

01:05:14.430 --> 01:05:15.710
It��s going to flash, delay, flash.

01:05:15.740 --> 01:05:17.860
It’s going to be really slow,
but it’s going to help you see

01:05:17.860 --> 01:05:19.090
exactly what’s being drawn.

01:05:19.140 --> 01:05:22.390
And it might help you discover that
you’re over-dirtying areas and drawing

01:05:22.390 --> 01:05:24.900
things that don’t need to be drawn.

01:05:25.270 --> 01:05:27.870
Two other interesting
defaults I want to mention:

01:05:27.900 --> 01:05:29.640
NSLessCoalescedViewDrawing.

01:05:29.650 --> 01:05:32.200
I know it's a long name,
but I didn't put it in there.

01:05:32.540 --> 01:05:39.200
What this will do is revert the
coalescing of dirty recs back to,

01:05:39.200 --> 01:05:42.200
I guess, pre-Panther behavior.

01:05:42.370 --> 01:05:45.310
And pre-Panther, what happened was,
if you dirtied an area up here

01:05:45.410 --> 01:05:48.370
and you dirtied an area down here,
Cocoa just happily coalesced

01:05:48.500 --> 01:05:51.200
them all together and told
everything in that region to draw.

01:05:51.200 --> 01:05:53.880
And in Panther,
a lot of hard work went into

01:05:53.880 --> 01:05:57.150
making sure that we didn't do that,
and now we don't coalesce

01:05:57.290 --> 01:05:58.200
those recs together.

01:05:58.200 --> 01:06:02.200
But because of that, you may have been
depending on that behavior,

01:06:02.230 --> 01:06:05.040
and things that used to get
drawn just because of coalescing

01:06:05.040 --> 01:06:06.200
may not be getting drawn.

01:06:06.200 --> 01:06:08.780
So this might help you discover why
your thing's not drawing if you're

01:06:08.780 --> 01:06:10.200
depending on that old behavior.

01:06:10.200 --> 01:06:14.130
And then finally, just a quick note about
NSTraceEvents at the bottom.

01:06:14.200 --> 01:06:17.200
If you're not receiving mouse events
or keyboard events like you expect,

01:06:17.200 --> 01:06:20.080
you can turn on TraceEvents
and see what the Cocoa event

01:06:20.140 --> 01:06:21.200
processing system is doing.

01:06:21.200 --> 01:06:22.600
doing.

01:06:23.960 --> 01:06:26.220
Okay, so how about some GDB tips?

01:06:26.220 --> 01:06:28.380
So one thing we can do
is we can PO an object.

01:06:28.500 --> 01:06:30.720
Now, we’re not making the object mad.

01:06:30.730 --> 01:06:33.930
What we’re doing is,
at shorthand for print object.

01:06:33.930 --> 01:06:35.790
I’m pretty sure.

01:06:35.850 --> 01:06:38.680
Print object,
and what it’s going to do is print to

01:06:38.950 --> 01:06:43.970
the screen what it gets back by invoking
the description method on your object.

01:06:43.970 --> 01:06:46.670
Now,
one thing that’s����I don’t know if this

01:06:46.670 --> 01:06:48.570
is actually declared in a public header,
and again,

01:06:48.570 --> 01:06:50.410
this is strictly for debugging.

01:06:50.410 --> 01:06:53.520
There’s a method called
debug description.

01:06:53.520 --> 01:06:57.070
I forgot to put it on the slides,
but it’s lower case debug,

01:06:57.070 --> 01:06:58.390
upper case description.

01:06:58.390 --> 01:07:02.460
You could override and provide a custom
debug-only description if you wanted to

01:07:02.460 --> 01:07:06.490
have PO print something different than it
would normally print when you’re doing,

01:07:06.730 --> 01:07:08.550
like, NS log of something.

01:07:08.550 --> 01:07:09.400
Okay?

01:07:09.400 --> 01:07:15.290
Some other interesting things
are hidden parameters to methods.

01:07:15.560 --> 01:07:16.710
This can be useful to know about.

01:07:16.870 --> 01:07:20.400
There’s����every method
has a self parameter,

01:07:20.760 --> 01:07:23.340
which is not explicitly
declared it’s hidden,

01:07:23.340 --> 01:07:24.480
but it’s there.

01:07:24.570 --> 01:07:28.520
And there’s an underscore CMD parameter,
which is the selector.

01:07:28.520 --> 01:07:30.080
It’s the name of the method.

01:07:30.120 --> 01:07:31.930
And really the interesting
thing that this����one of the

01:07:31.930 --> 01:07:34.770
interesting things about this
is that if I’m doing an NS log,

01:07:34.800 --> 01:07:37.960
I get tired of doing NS log,
type out the whole method name.

01:07:37.970 --> 01:07:38.410
I can just do NS log,
type out the whole method name,

01:07:38.520 --> 01:07:44.360
and I can say, you know,
you see at the next step there,

01:07:44.360 --> 01:07:47.540
NSString from selector.

01:07:47.540 --> 01:07:49.800
So if I just want to print
when I’m in a method,

01:07:49.800 --> 01:07:51.870
I can just copy and paste lots
of code and I don’t have to

01:07:51.870 --> 01:07:52.780
keep typing the method name.

01:07:52.780 --> 01:07:54.880
We’ll find out in a second.

01:07:54.880 --> 01:07:57.300
It’s also interesting other places.

01:07:57.300 --> 01:07:59.510
So if you wanted to print out
the selector without doing PO,

01:07:59.510 --> 01:08:02.670
you could actually
print char star of that.

01:08:02.670 --> 01:08:07.380
You find out it’s actually,
I think it’s null terminated, but

01:08:09.090 --> 01:08:13.610
Okay, so some of these things become
interesting when debugging crashes.

01:08:13.880 --> 01:08:17.800
ObjcMessageSend is the guy that
tries to dispatch a message.

01:08:17.890 --> 01:08:22.300
And if it was just about ready to
dispatch a method to your object,

01:08:22.410 --> 01:08:25.100
well, those hidden parameters
were all set up to be used.

01:08:25.240 --> 01:08:28.530
And I didn't point out
explicitly before in the slide,

01:08:28.550 --> 01:08:29.000
but it was there.

01:08:29.000 --> 01:08:34.490
It said $r3 is the hidden argument self,
$r4 is the hidden

01:08:34.490 --> 01:08:36.800
argument underscore cmd.

01:08:36.870 --> 01:08:39.690
So if you wanted to figure out, you know,
I crashed an ObjcMessageSend, well,

01:08:39.690 --> 01:08:42.030
it's not Objective-C's runtime's fault.

01:08:42.400 --> 01:08:44.390
It was, it probably,
what probably was trying to happen was

01:08:44.390 --> 01:08:49.100
that it was about to dispatch a message
to an object that was deallocated.

01:08:49.240 --> 01:08:53.100
And what you could do
is print char* of $r4,

01:08:53.100 --> 01:08:56.100
and you could see what it
was trying to dispatch.

01:08:56.180 --> 01:08:59.070
Or you can print the address
of the object that was about

01:08:59.100 --> 01:09:00.060
to receive the message.

01:09:00.200 --> 01:09:02.500
But of course, if you try and PO the
object at that point,

01:09:02.500 --> 01:09:05.600
it's probably dead,
and it will raise another exception.

01:09:05.660 --> 01:09:06.610
But this could be useful.

01:09:06.710 --> 01:09:08.880
It's useful when you're
debugging to see what object was

01:09:08.880 --> 01:09:12.350
about to receive the message,
you know, which object was dead, so on.

01:09:12.910 --> 01:09:14.700
And hopefully that's helpful.

01:09:14.820 --> 01:09:18.500
Normally, well,
lots of times your crashes may be

01:09:18.500 --> 01:09:21.200
due to over-releasing an object.

01:09:21.400 --> 01:09:25.200
And one useful tip that may not be
obvious that I just want to throw out

01:09:25.390 --> 01:09:30.200
is that you can use object alloc and
turn on its retain-release recording,

01:09:30.200 --> 01:09:32.680
and you could use that to actually
pair up your retains and releases

01:09:32.710 --> 01:09:36.600
to see if somebody's releasing
it that probably shouldn't be.

01:09:38.260 --> 01:09:42.940
Another idea for debugging
crashes is to enable zombies.

01:09:42.940 --> 01:09:45.100
This isn't something out of
Invasion of the Body Snatchers.

01:09:45.100 --> 01:09:51.100
It's actually a useful feature that
you can turn on in the command line.

01:09:51.130 --> 01:09:55.100
It's not a default like the
other defaults we talked about.

01:09:55.100 --> 01:09:57.100
It's an environment
variable that you'll set.

01:09:57.320 --> 01:10:02.100
What you'll do is set the environment
variable NSZombieEnabled to Yes.

01:10:02.200 --> 01:10:06.860
Then what happens is, for the most part,
deallocated objects don't go away.

01:10:07.170 --> 01:10:10.800
They just get kept around in a
state just enough that they can

01:10:10.870 --> 01:10:13.100
receive messages and raise errors.

01:10:13.420 --> 01:10:18.010
What's going to happen then is that
when you try and message a dead object,

01:10:18.080 --> 01:10:20.100
it's going to raise an exception
like you see at the bottom.

01:10:20.100 --> 01:10:23.780
In fact, it's going to be nice enough
to tell you where you could

01:10:23.920 --> 01:10:26.030
set a breakpoint to catch this.

01:10:26.230 --> 01:10:29.490
Now, one thing to note about this is
that it works really well for

01:10:29.490 --> 01:10:33.860
AppKit-level and GUI-level objects,
but it doesn't quite work so

01:10:33.860 --> 01:10:36.710
well for foundation objects,
mostly for things that

01:10:36.710 --> 01:10:38.640
are toll-free bridged.

01:10:40.490 --> 01:10:41.250
All right.

01:10:41.250 --> 01:10:45.560
And another thing that I wanted to
mention for debugging that I think

01:10:45.670 --> 01:10:48.450
it��-- I'm pretty sure it's new in Tiger.

01:10:48.450 --> 01:10:51.530
You can probably pretty
easily find this out.

01:10:51.530 --> 01:10:54.800
But it's a method called
_subtree_description.

01:10:54.800 --> 01:10:58.970
And again, remember,
these are methods for debugging only.

01:10:58.970 --> 01:11:02.570
They��-- they're meant to
help you out in debugging.

01:11:02.580 --> 01:11:05.760
We don't want us to have to
support these if we want to

01:11:05.850 --> 01:11:06.890
change them for some reason,
use them.

01:11:06.890 --> 01:11:06.890
Just disclaimer.

01:11:07.150 --> 01:11:12.310
This is very useful because it
prints information about an entire

01:11:12.820 --> 01:11:15.560
subtree in the view hierarchy.

01:11:15.560 --> 01:11:17.440
For example,
this is something I printed out

01:11:17.530 --> 01:11:20.620
from one of the earlier examples,
the animating outline view.

01:11:20.650 --> 01:11:24.170
It's showing me that at the top
level I have a scroll view which

01:11:24.170 --> 01:11:26.460
has a clip view as a subview,
it has an animating

01:11:26.460 --> 01:11:28.460
outline view as a subview,
and so on.

01:11:28.460 --> 01:11:31.060
There's a bunch of interesting
information associated with it.

01:11:31.060 --> 01:11:35.380
Don't worry about trying to write down
all this information really quick because

01:11:35.390 --> 01:11:37.600
this is also available on the download.

01:11:40.130 --> 01:11:44.540
Okay, so the first bit of information,
it shows you the frame and the bounds,

01:11:44.630 --> 01:11:49.690
shows you the horizontal and
vertical resize springs and flags,

01:11:50.480 --> 01:11:52.140
and it shows you a bunch of other flags.

01:11:52.180 --> 01:11:55.100
Again, go ahead and look at the DMG.

01:11:55.100 --> 01:11:59.100
Okay, again,
all this is available on the DMG.

01:11:59.100 --> 01:11:59.100
Yada, yada.
WEBVTT

00:00:13.100 --> 00:02:46.000
[Transcript missing]

00:02:46.200 --> 00:02:50.140
And we're also going to cover
things like when good apps go bad.

00:02:50.140 --> 00:02:52.410
It'll be a Fox special this fall.

00:02:55.310 --> 00:02:59.660
Like if you'll notice, if you deploy on,
say, your eight processor CPU,

00:02:59.660 --> 00:03:03.300
or eight CPU Solaris box,
you can see your CPU usage go

00:03:03.300 --> 00:03:06.700
to 800%. That's always fun.

00:03:06.700 --> 00:03:12.380
You can even see it go to 900%, and then
it takes down the machine next to it.

00:03:15.150 --> 00:03:17.570
There's also problems with
like when your working set gets

00:03:17.570 --> 00:03:20.670
larger than physical memory,
and then disk is obviously

00:03:20.670 --> 00:03:23.260
a lot slower than RAM,
and when you start hitting

00:03:23.270 --> 00:03:24.850
the disk for memory,
that's bad.

00:03:24.860 --> 00:03:28.650
Also, there's the situations that
a lot of people seem to miss,

00:03:28.650 --> 00:03:33.650
which is like network saturation when
packets or connections are being dropped.

00:03:34.160 --> 00:03:38.880
I know of one example of a very
large company who will remain unnamed

00:03:38.880 --> 00:03:42.230
who called the FBI because they
thought they were being hacked,

00:03:42.230 --> 00:03:44.540
and it turned out that
they had two Windows boxes,

00:03:44.540 --> 00:03:47.810
and their traffic rates were so high
that the TCP/IP stack was falling

00:03:47.880 --> 00:03:49.590
over and dropping connections.

00:03:49.640 --> 00:03:52.950
So, you know,
that gets back to the analysis thing,

00:03:53.050 --> 00:03:57.890
and calling the FBI to analyze
the performance problems of your

00:03:57.900 --> 00:04:00.650
apps is probably not a good idea.

00:04:00.860 --> 00:04:04.610
There's also just the basic
situation of like when your responses

00:04:04.610 --> 00:04:06.280
require too much computation.

00:04:06.280 --> 00:04:09.320
If you're going off and
calculating pi to 100,000 digits

00:04:09.320 --> 00:04:11.580
to bring up your welcome page,
that's going to be a problem.

00:04:11.580 --> 00:04:15.060
Your database can be
obviously overwhelmed.

00:04:15.060 --> 00:04:18.120
You're hitting it way too often or
you're just pulling too much data from

00:04:18.140 --> 00:04:19.840
it or pushing too much data into it.

00:04:19.890 --> 00:04:20.600
That can be bad.

00:04:20.600 --> 00:04:25.270
And a great one is external services
because no external service ever

00:04:25.270 --> 00:04:27.510
wants to admit they're wrong.

00:04:28.620 --> 00:04:30.890
So instrumenting your app
such that when they're wrong,

00:04:30.900 --> 00:04:33.080
you can prove it will make
your life a lot easier.

00:04:35.960 --> 00:04:37.440
So how can we fix these problems?

00:04:37.440 --> 00:04:40.630
Well, unfortunately,
dollars are always involved.

00:04:40.690 --> 00:04:45.580
The basic problem is you can just kind
of throw money at it and get more CPUs,

00:04:45.580 --> 00:04:48.650
get more memory, get more network,
get a faster database,

00:04:48.650 --> 00:04:49.880
that kind of thing.

00:04:50.800 --> 00:04:53.760
But that won't always work,
and that's what we're going to focus

00:04:53.760 --> 00:04:57.090
on is when that doesn't work and
you need to throw engineering at it.

00:04:57.100 --> 00:05:01.670
And what you're really looking to
do in that case is do less work to

00:05:01.680 --> 00:05:06.660
generate the response or to make
more efficient use of the database,

00:05:06.660 --> 00:05:09.130
or ideally,
don't hit the database at all.

00:05:09.160 --> 00:05:12.100
Or optimize your external
service integration,

00:05:12.100 --> 00:05:15.530
and that becomes especially
critical as your site grows in

00:05:15.530 --> 00:05:19.580
size and you need to start relying
on those services more and more.

00:05:21.820 --> 00:05:23.690
So good rules to code by.

00:05:23.800 --> 00:05:26.210
These are somewhat obvious,
but they bear repeating because when

00:05:26.230 --> 00:05:28.370
you get into the thick of things,
it's easy to forget.

00:05:28.380 --> 00:05:30.490
Test-driven development.

00:05:30.500 --> 00:05:33.320
Now this is something that's really
become popular in the recent years,

00:05:33.320 --> 00:05:37.480
and I can't emphasize
how valuable this is.

00:05:37.480 --> 00:05:39.860
Put the unit tests together.

00:05:39.860 --> 00:05:42.480
Do it before you write the code.

00:05:42.480 --> 00:05:46.460
Test the capabilities and
the requirements of the code,

00:05:46.460 --> 00:05:49.820
and then run them every
single time you build.

00:05:50.860 --> 00:05:54.720
And when you push to deployment,
run them there, and run many of them

00:05:54.720 --> 00:05:56.060
in parallel if you can.

00:05:56.060 --> 00:05:59.210
They will uncover so many
obvious problems and save

00:05:59.210 --> 00:06:00.970
you a huge amount of time.

00:06:02.230 --> 00:06:07.160
Another obvious one that everyone misses,
including myself, is make it work,

00:06:07.260 --> 00:06:08.440
make it right, make it fast.

00:06:08.440 --> 00:06:11.240
As developers,
we often like to make problems a

00:06:11.240 --> 00:06:15.490
lot harder than they really are,
because then our egos are boosted

00:06:15.490 --> 00:06:17.640
when we solve a hard problem.

00:06:17.660 --> 00:06:19.990
It's like, look,
I've sorted something 20 times

00:06:19.990 --> 00:06:21.240
faster than the next guy.

00:06:21.240 --> 00:06:23.220
Never mind it's only 10 elements.

00:06:23.220 --> 00:06:26.750
Don't optimize without analysis.

00:06:26.780 --> 00:06:29.640
And I can't say this enough times.

00:06:29.640 --> 00:06:33.970
I've walked into so many situations
where someone's got the world's most

00:06:33.970 --> 00:06:38.370
optimized means of writing out the
HTML page that's only used once when

00:06:38.370 --> 00:06:40.570
the user signs up the first time.

00:06:40.600 --> 00:06:42.810
It's like, come on, you know,
go fix the problems

00:06:42.860 --> 00:06:44.040
that are really there.

00:06:44.040 --> 00:06:46.740
And also,
optimize in small tests and test your

00:06:46.740 --> 00:06:48.940
results after each of those steps.

00:06:48.940 --> 00:06:50.900
And this gets back to unit testing.

00:06:50.900 --> 00:06:53.330
If you've got the unit tests in place,
then this makes

00:06:53.330 --> 00:06:55.500
optimization a lot easier,
because you can go off,

00:06:55.500 --> 00:06:57.520
you can do the optimization,
and know immediately if

00:06:57.610 --> 00:06:58.760
you've broken things.

00:06:59.340 --> 00:07:02.240
And, you know, the last point is just,
it's an obvious one,

00:07:02.240 --> 00:07:03.420
but everyone does it.

00:07:03.510 --> 00:07:07.390
If it ain't broke, don't fix it,
which as object-oriented developers,

00:07:07.390 --> 00:07:10.060
that means if it works now,
don't generalize it,

00:07:10.060 --> 00:07:12.500
because that's one that we commonly do.

00:07:15.160 --> 00:07:20.820
Also, there's a lot of optimization
that you can do at design time.

00:07:20.970 --> 00:07:25.060
If you understand your problem well,
and any optimizations you can do

00:07:25.060 --> 00:07:29.050
before the first lines of code
are written are always good,

00:07:29.050 --> 00:07:33.080
keeping in mind that you shouldn't
optimize things too prematurely.

00:07:33.100 --> 00:07:36.390
So you really want to understand the
usage patterns of your applications,

00:07:36.390 --> 00:07:39.920
know how users are going to use it,
know how it's going to be administrated.

00:07:39.920 --> 00:07:44.330
Now, clearly, you can't be omniscient,
but you can do a lot

00:07:44.340 --> 00:07:46.380
of upfront work there.

00:07:46.820 --> 00:07:49.860
And of course, make your entry page fast.

00:07:49.860 --> 00:07:53.640
I can't tell you the number of times
I walked into a client and I hit the

00:07:53.760 --> 00:07:56.440
entry page and it did 600 SQL queries.

00:07:56.440 --> 00:07:58.630
It's like, no, no, no, no.

00:07:58.640 --> 00:07:59.280
Make it static.

00:07:59.280 --> 00:08:02.550
Even if you have to have an entry
page that just comes up that's just

00:08:02.550 --> 00:08:05.270
long enough to get them into the site,
that's fine.

00:08:05.280 --> 00:08:06.710
But make that fast.

00:08:09.860 --> 00:08:14.020
Your business logic in your
application should be designed

00:08:14.020 --> 00:08:16.600
around the response generation.

00:08:16.600 --> 00:08:19.170
It should be designed around
what the customers are going to

00:08:19.180 --> 00:08:21.690
be doing with the application,
even if that makes the

00:08:21.690 --> 00:08:23.820
administrative tools less convenient.

00:08:23.820 --> 00:08:26.610
You know, the administrative tools,
they need to be powerful,

00:08:26.610 --> 00:08:29.760
they need to be intuitive,
but if they take a little bit of time,

00:08:29.760 --> 00:08:32.910
hey, that's okay,
because it's all about administrating the

00:08:32.980 --> 00:08:35.100
content for the purposes of the customer.

00:08:35.840 --> 00:08:39.070
And if your business is like
any business I've ever heard of,

00:08:39.130 --> 00:08:40.900
it's the customer that pays the bills.

00:08:40.900 --> 00:08:44.200
And, you know, I've seen a lot of people
that lose sight of that.

00:08:44.240 --> 00:08:48.460
You also want to make sure you're
retaining and reusing data.

00:08:49.820 --> 00:08:51.670
and know when it's out of date.

00:08:51.680 --> 00:08:54.740
This will come up again,
but it's something that bears repeating.

00:08:54.740 --> 00:08:57.750
You know,
if you go into the database to pull

00:08:57.750 --> 00:09:01.960
out the list of states in the country,
it's more likely not going to

00:09:01.960 --> 00:09:03.760
change in the next five minutes.

00:09:03.760 --> 00:09:05.620
So keep it around.

00:09:05.640 --> 00:09:09.520
That introduces some complexity in
working with enterprise objects because,

00:09:09.520 --> 00:09:12.630
of course, you can't create relationships
between entities that are in

00:09:12.630 --> 00:09:14.080
different editing contexts.

00:09:14.130 --> 00:09:15.360
So you have to be a little bit careful.

00:09:15.360 --> 00:09:18.300
And you want to manage
that cache data carefully.

00:09:18.770 --> 00:09:21.000
Because if you end up caching
everything all the time and

00:09:21.000 --> 00:09:22.820
just leaving it in memory,
then you're going to get back to the

00:09:22.900 --> 00:09:25.290
part where you run out of memory,
your machine starts swapping,

00:09:25.290 --> 00:09:26.740
and then your performance goes to hell.

00:09:28.260 --> 00:09:32.370
So you also want to let the
database server share in the work.

00:09:32.470 --> 00:09:36.490
Databases have been around a long time,
and they do things like

00:09:36.490 --> 00:09:38.000
sorting stuff really fast.

00:09:38.000 --> 00:09:40.620
They also do indexes and
all this other stuff,

00:09:40.620 --> 00:09:44.190
and you really want to leverage
those wherever possible.

00:09:45.230 --> 00:09:49.620
So, one of the optimizations is to
minimize your memory footprint.

00:09:49.620 --> 00:09:52.470
If you can minimize the
footprint of the application,

00:09:52.470 --> 00:09:54.910
then you can have more instances running.

00:09:54.910 --> 00:09:56.700
You can balance the
load more effectively.

00:09:56.700 --> 00:09:59.290
And this means sharing
data across sessions,

00:09:59.310 --> 00:10:03.140
which is not something WebObjects
does naturally out of the box.

00:10:03.140 --> 00:10:05.890
You're going to have to play some games
there to get that kind of thing to work.

00:10:05.960 --> 00:10:07.080
It's not hard.

00:10:07.080 --> 00:10:08.870
It is detail-oriented.

00:10:08.870 --> 00:10:11.150
You also want to clean up thoroughly.

00:10:13.320 --> 00:10:15.770
It annoys me to see a developer
make the statement that

00:10:15.770 --> 00:10:17.980
because of garbage collection,
they don't have to care

00:10:17.980 --> 00:10:19.180
about cleaning up their code.

00:10:19.200 --> 00:10:23.210
Okay, not every object that's going
to be collected by the garbage

00:10:23.210 --> 00:10:25.390
collector is just using memory.

00:10:25.400 --> 00:10:29.310
It may be using scarce resources
like connections to quote servers,

00:10:29.310 --> 00:10:31.770
or it may be keeping a
file descriptor open,

00:10:31.770 --> 00:10:33.360
or something like that.

00:10:33.420 --> 00:10:37.480
And you want to let the code know
that it's done and over with.

00:10:37.480 --> 00:10:41.630
Also, any nulled out reference,
the garbage collector doesn't have

00:10:41.630 --> 00:10:43.260
to traverse to deal with collecting.

00:10:43.320 --> 00:10:49.790
So that's another good way to
ensure cleaning up happens quickly.

00:10:50.330 --> 00:10:53.120
You want to also clear your
transient instance variables

00:10:53.120 --> 00:10:54.750
when they're no longer in use.

00:10:54.750 --> 00:10:56.680
And this is not just
an optimization issue,

00:10:56.680 --> 00:10:58.320
this is also a debugging issue.

00:10:58.320 --> 00:11:01.420
If you have stale state
in your object graph,

00:11:01.420 --> 00:11:05.290
and you don't clean up when you're done,
and then you come along at some later

00:11:05.290 --> 00:11:08.660
point in time through some code path
that you didn't really think about,

00:11:08.660 --> 00:11:11.550
and you run across that transient data,
and now it's out of date

00:11:11.550 --> 00:11:13.620
and you didn't know it,
you're hosed.

00:11:15.100 --> 00:11:18.350
Speaking from experience,
traders on trading desks get

00:11:18.350 --> 00:11:21.870
really irritated when they
start seeing the wrong prices.

00:11:25.340 --> 00:11:25.870
Some scars.

00:11:25.870 --> 00:11:30.700
You also want to do things like set
your right session timeout value.

00:11:30.700 --> 00:11:34.160
Sessions will stick around and
then they'll automatically go away.

00:11:34.160 --> 00:11:36.780
Unfortunately, on the web,
there's no quit button,

00:11:36.780 --> 00:11:39.480
so it's hard to know when
the session should go away.

00:11:39.480 --> 00:11:41.770
This gets back to looking
at the usage patterns.

00:11:41.770 --> 00:11:44.660
Look at the use patterns of your app,
understand how they are,

00:11:44.660 --> 00:11:47.510
and understand when it's safe
to make the session go away.

00:11:49.340 --> 00:11:52.290
Instrument Instrument your applications.

00:11:52.290 --> 00:11:56.480
We've got some wonderful tools
built in for instrumenting them,

00:11:56.480 --> 00:11:59.540
which Max is going to
demonstrate shortly.

00:11:59.540 --> 00:12:04.170
They do a great job of allowing you to
detect when resources are being used or

00:12:04.250 --> 00:12:06.730
when things are getting out of control.

00:12:06.820 --> 00:12:09.520
You want to review those results often.

00:12:09.520 --> 00:12:13.080
Ideally, you want the instrumentation
to be something you can turn on

00:12:13.120 --> 00:12:16.760
dynamically in production so that
if any customer calls up and goes,

00:12:16.760 --> 00:12:18.490
you know, your app's not working right.

00:12:19.480 --> 00:12:22.070
You can turn this stuff on and
figure out what's going on.

00:12:22.230 --> 00:12:26.820
And unfortunately,
because we're building applications

00:12:26.840 --> 00:12:30.180
where it's guaranteed that our
development environment is about

00:12:30.220 --> 00:12:33.700
as different from our deployment
environment as is possible,

00:12:33.700 --> 00:12:36.320
there's going to be a whole
series of problems that will

00:12:36.320 --> 00:12:39.560
only come up in production,
which makes life an adventure.

00:12:39.560 --> 00:12:43.120
So instrument and
collect and then analyze.

00:12:43.850 --> 00:12:47.230
Also,
you want to really plan the data access,

00:12:47.450 --> 00:12:51.390
plan when your queries, when your caches,
when your cache updating

00:12:51.390 --> 00:12:54.800
is going to happen,
and understand the data latency issues.

00:12:54.800 --> 00:12:58.860
Now, data latency is all about looking at
your application and understanding

00:12:58.860 --> 00:13:02.280
when the data becomes stale,
and how often do you really

00:13:02.280 --> 00:13:05.920
need to let app A know that
app B's state has updated.

00:13:05.920 --> 00:13:10.020
And a great example of this is
I ran into a client and a site,

00:13:10.020 --> 00:13:14.570
and they needed some optimization,
and their site would just grind to

00:13:14.570 --> 00:13:16.640
a halt when it had a bunch of users.

00:13:16.660 --> 00:13:19.960
And what was happening is they
had all this user-specific state,

00:13:19.960 --> 00:13:20.960
a shopping cart.

00:13:20.960 --> 00:13:24.740
And every time the shopping
cart got updated for user one,

00:13:24.740 --> 00:13:28.680
all other 30 app instances
got notified that that user's

00:13:28.680 --> 00:13:32.490
shopping cart was updated,
even though that user's shopping cart was

00:13:32.490 --> 00:13:34.460
only on one session in one app instance.

00:13:34.460 --> 00:13:35.900
You know, and there was a case.

00:13:35.920 --> 00:13:38.490
There was a case where they used
a generic notification method,

00:13:38.490 --> 00:13:41.130
and by simply removing that,
all of a sudden their app was stable,

00:13:41.130 --> 00:13:44.100
even under higher loads,
and they could have more shopping carts.

00:13:44.100 --> 00:13:44.940
That's always good.

00:13:44.940 --> 00:13:49.670
You also want to do things
in memory wherever possible,

00:13:49.670 --> 00:13:53.640
and to try to get zero
queries per response.

00:13:53.640 --> 00:13:56.040
I mean,
the fewer times you go to the database,

00:13:56.100 --> 00:13:58.990
the fewer times you go to disk,
the better off you are.

00:13:59.000 --> 00:14:01.890
And especially when you get
into the high-throughput

00:14:01.890 --> 00:14:04.120
sites like the music store,
you know,

00:14:04.120 --> 00:14:05.890
any database hit is going to be ordered.

00:14:05.900 --> 00:14:07.540
So you want to do things in memory.

00:14:07.540 --> 00:14:08.740
And that's why you want
to do things in memory.

00:14:08.740 --> 00:14:10.040
And that's why you want
to do things in memory.

00:14:10.040 --> 00:14:15.110
You want to manage your faulting and
manage your caching so that you can

00:14:15.220 --> 00:14:17.980
explicitly update your stale data.

00:14:17.980 --> 00:14:23.370
You generally want to avoid situations
where WebObjects is either deciding

00:14:23.430 --> 00:14:28.180
to populate relationships on its
own or populate caches on its own,

00:14:28.180 --> 00:14:32.660
because it will choose a very
general-purpose solution that is

00:14:32.660 --> 00:14:35.750
probably not optimized to your caching.

00:14:36.050 --> 00:14:38.350
actual use patterns.

00:14:38.660 --> 00:14:43.000
And you also want to
use a shared read-only,

00:14:43.020 --> 00:14:45.840
well, I say read-only shared,
it should just be really

00:14:45.840 --> 00:14:48.840
called a read-only editing
context for reference data.

00:14:48.840 --> 00:14:52.880
It's a little bit tricky because, again,
you get into the situation where you've

00:14:52.880 --> 00:14:56.130
got to be careful about how you make
relationships to and from objects that

00:14:56.130 --> 00:14:57.840
were fetched into that editing context.

00:14:57.840 --> 00:15:00.720
But, you know,
that way you can have that single shared

00:15:00.720 --> 00:15:04.820
editing context that's read-only so it
never pays the penalty of doing updates

00:15:04.820 --> 00:15:06.820
or inserts or anything like that.

00:15:08.820 --> 00:15:12.760
And then another one that's
really something that's more

00:15:12.760 --> 00:15:16.450
of a modern optimization,
this is something that's

00:15:16.450 --> 00:15:19.090
become much easier with
recent releases of WebObjects,

00:15:19.090 --> 00:15:22.370
is to partition your functionality
across multiple applications.

00:15:23.280 --> 00:15:25.620
And what that means
is that if you've got,

00:15:25.820 --> 00:15:28.870
say, a site where it has an
expensive search operation,

00:15:28.870 --> 00:15:33.060
plus shopping cart management, plus, say,
a library of information,

00:15:33.140 --> 00:15:37.340
plus a couple of other different things,
an administrative tool,

00:15:37.340 --> 00:15:41.740
then you partition those different
features into different applications,

00:15:41.740 --> 00:15:45.700
and then you can control the number
of application instances individually,

00:15:45.700 --> 00:15:49.500
and control the configuration of
those applications individually

00:15:49.500 --> 00:15:52.820
to optimize those particular
applications for the use they need.

00:15:53.400 --> 00:15:55.640
And that's very important.

00:15:55.640 --> 00:15:58.420
And with direct-to-actions,
and with putting the

00:15:58.470 --> 00:16:00.950
session ID in cookies,
and then being able to

00:16:00.950 --> 00:16:05.210
reconnect across different apps,
you can achieve a lot of efficiency.

00:16:05.220 --> 00:16:11.820
And what you can also do is use
optimized object models per application.

00:16:11.820 --> 00:16:14.010
So you can go into
Enterprise Objects Modeler,

00:16:14.010 --> 00:16:17.290
and you can bring up your object model,
and you can have your full object

00:16:17.290 --> 00:16:19.300
model for your administrative tool.

00:16:19.300 --> 00:16:21.100
It's got read, it's got write,
it's got everything.

00:16:21.100 --> 00:16:23.570
But then all those entities...
And that's really important.

00:16:23.570 --> 00:16:24.030
And with direct-to-actions,
and with putting the

00:16:24.030 --> 00:16:24.430
session ID in cookies,
and with putting the

00:16:24.430 --> 00:16:24.830
session ID in cookies,
you can create a very

00:16:24.830 --> 00:16:25.270
simple application model.

00:16:25.340 --> 00:16:32.150
And you can create a very simple
application model that's just the fields

00:16:32.470 --> 00:16:37.040
you need for that particular application.

00:16:37.040 --> 00:16:38.980
This will reduce the
memory footprint size,

00:16:38.980 --> 00:16:41.720
it'll reduce the amount of data
going to and from the database.

00:16:41.720 --> 00:16:43.540
It just overall will make the app faster.

00:16:43.540 --> 00:16:46.480
It can be a little tricky because,
of course, then you've got to keep

00:16:46.480 --> 00:16:47.530
the two things in sync.

00:16:47.530 --> 00:16:48.600
That's a pain.

00:16:48.600 --> 00:16:54.710
But if you're faced with this problem,
it can really help a lot.

00:16:54.900 --> 00:16:57.280
That course obviously maximizes
reuse through frameworks.

00:16:57.340 --> 00:17:00.740
Again, got to point it out because
some people forget about that.

00:17:00.740 --> 00:17:03.160
I've run into that a number of times.

00:17:03.160 --> 00:17:09.440
And you also want to partition between
sessionful and sessionless and threaded

00:17:09.440 --> 00:17:15.120
and non-threaded because threading
is always a very complex issue.

00:17:15.120 --> 00:17:18.250
There will be certain apps
where threading is an obvious

00:17:18.260 --> 00:17:22.040
optimization and certain other
apps where it's not so obvious.

00:17:22.640 --> 00:17:25.730
In particular,
things like where you have multiple

00:17:25.820 --> 00:17:29.870
writers to the same database,
you probably don't want to thread that

00:17:29.910 --> 00:17:35.590
because bad things can happen when you
cross commits or do partial transactions.

00:17:35.600 --> 00:17:39.390
Sessionful versus sessionless,
there may be a number of apps like

00:17:39.390 --> 00:17:43.510
search apps are often things that
don't need to have per user state.

00:17:43.520 --> 00:17:46.830
And so if you can get rid of the
session in a search app and then

00:17:46.830 --> 00:17:49.950
make it such that it's only caching,
has one big cache for

00:17:49.990 --> 00:17:52.610
all the search data,
you can make things extremely easy.

00:17:52.620 --> 00:17:53.110
And so you can get rid of the
session in a search app and then

00:17:53.110 --> 00:17:53.590
make it such that it's only caching,
has one big cache for

00:17:53.590 --> 00:17:58.890
all the search data,
you can make things extremely easy.

00:17:59.910 --> 00:18:03.960
Okay, so you've done all the right
things in development time.

00:18:03.960 --> 00:18:09.480
You know, it's been the world's most
perfect development schedule,

00:18:09.480 --> 00:18:11.270
and you even delivered early.

00:18:11.270 --> 00:18:14.930
And you got the app in production,
and now it's too slow,

00:18:14.930 --> 00:18:18.890
or it's using too much memory
and you're thrashing the disks,

00:18:18.890 --> 00:18:22.740
or, you know,
the CPUs are just like big space heaters.

00:18:22.740 --> 00:18:26.880
Or it's just occasionally just
crawls to its knees just really,

00:18:26.880 --> 00:18:27.940
really slow.

00:18:27.940 --> 00:18:29.160
So now what do you do?

00:18:31.490 --> 00:18:33.950
Well, the first thing is don't be silly.

00:18:33.950 --> 00:18:36.280
And this comes from years of experience.

00:18:36.280 --> 00:18:41.200
I've been very silly myself and have seen
many developers do really silly things.

00:18:41.200 --> 00:18:45.400
Turn on or off the obvious flags.

00:18:45.400 --> 00:18:48.880
Woe caching enabled, yeah,
that's a good one to have on.

00:18:48.880 --> 00:18:51.870
Woe debugging enabled is a
really good one to turn off.

00:18:54.000 --> 00:18:56.400
It'll bring an app to its knees,
go into production,

00:18:56.400 --> 00:19:01.700
all of a sudden 100,000 users hit it,
and it's trying to log every SQL query.

00:19:01.700 --> 00:19:03.070
Yeah, not a good idea.

00:19:03.080 --> 00:19:07.350
There's the built-in NSLog facility,
plus there's, of course, Log4J,

00:19:07.360 --> 00:19:12.580
which is wonderful because they can
both be dynamically configured such

00:19:12.760 --> 00:19:17.250
that you can hit a production server
and pay the penalty on logging on only

00:19:17.250 --> 00:19:19.460
the areas that you know are problematic.

00:19:19.460 --> 00:19:23.970
And that gets back to instrumenting
and making sure that you have...

00:19:24.070 --> 00:19:27.370
dynamic instrumentation so you can
actually catch problems in production.

00:19:27.380 --> 00:19:32.240
Put indices on your database tables.

00:19:32.240 --> 00:19:36.690
Sounds obvious, but, you know,
that's one that people often miss.

00:19:36.720 --> 00:19:39.660
And then they'll go into production,
their data sizes grow to a

00:19:39.670 --> 00:19:43.280
couple orders of magnitude bigger
than they are in development,

00:19:43.280 --> 00:19:45.410
and all of a sudden they're
left scratching their heads as

00:19:45.410 --> 00:19:47.830
to why the heck it's so slow
just to bring up a simple page.

00:19:47.970 --> 00:19:51.550
And this is another one that's funny.

00:19:51.560 --> 00:19:53.980
Minimize the size of
the generated content.

00:19:54.000 --> 00:19:58.870
We ran into a number of sites
where the initial page load,

00:19:58.870 --> 00:20:02.140
which is a nice big beautiful page with
a couple hundred images on it and a

00:20:02.140 --> 00:20:08.490
bunch of text and all this other stuff,
it was about 160K of HTML,

00:20:08.490 --> 00:20:13.200
which is way too much,
of which 40K of that was comments.

00:20:13.200 --> 00:20:18.510
And another 30K of that was because
the image URLs were all slash images

00:20:18.510 --> 00:20:23.900
slash clients slash sites slash
codenames slash foobar.jpeg or gif.

00:20:24.000 --> 00:20:28.880
And by simply erasing all of that and
making it slash i slash for the images,

00:20:28.880 --> 00:20:32.570
we were able to reduce the
page from 160K down to like 50,

00:20:32.590 --> 00:20:33.880
60, 70K.

00:20:33.880 --> 00:20:34.970
Still too much.

00:20:34.980 --> 00:20:42.980
And of course, again, analyze, analyze,
analyze.

00:20:43.920 --> 00:20:46.820
One of the challenges with building
a WebObjects-based app or other

00:20:46.830 --> 00:20:51.290
dynamic applications is that as
a user goes through the site,

00:20:51.300 --> 00:20:54.060
unless you specifically
do the engineering work,

00:20:54.130 --> 00:20:58.290
you're not going to get a good
record of what the heck they did.

00:20:58.300 --> 00:23:08.500
[Transcript missing]

00:23:08.800 --> 00:23:13.620
Now I'd like to bring Max up,
who's going to demonstrate

00:23:13.620 --> 00:23:15.290
some of this stuff.

00:23:22.000 --> 00:23:23.540
Thank you, Bill.

00:23:23.540 --> 00:23:28.200
So what I did here is built two
very simple little applications.

00:23:28.280 --> 00:23:37.480
One is a Cocoa Web Services app that
just makes a simple query to a WebObjects

00:23:37.480 --> 00:23:40.090
app I have also running on this machine.

00:23:40.990 --> 00:23:45.460
And it just brings back just a bunch
of SOAP objects and lists them here.

00:23:45.460 --> 00:23:48.770
And then you can click through
them and either choose to,

00:23:48.840 --> 00:23:53.800
and then if it's two Rs,
you can choose to update them.

00:23:53.910 --> 00:23:55.420
And that basically
makes the SOAP callback.

00:23:55.490 --> 00:23:58.070
So it's just a very
simple little Cocoa app.

00:23:58.080 --> 00:24:06.310
And on the server side,
we have a very simple WebObjects app

00:24:06.390 --> 00:24:09.110
that threw in a bit of direct web.

00:24:09.120 --> 00:24:12.270
So you can basically
see the current users.

00:24:12.280 --> 00:24:15.900
I mean, this is something that you
can do out of the box very,

00:24:15.900 --> 00:24:16.460
very quickly.

00:24:16.460 --> 00:24:20.950
So the question then becomes,
if things are slow, what do you do?

00:24:21.520 --> 00:24:27.840
So the first thing you can
look at is the stats page,

00:24:27.840 --> 00:24:33.340
which will kind of just look at your
overall statistics of your pages and say,

00:24:33.340 --> 00:24:35.350
you know, what am I doing wrong?

00:24:35.360 --> 00:24:39.400
And it also gives you a good idea of...

00:24:40.320 --> 00:24:43.140
Whoa, stats.

00:24:43.400 --> 00:24:45.720
Also can give you a really good
idea of just where the high

00:24:45.720 --> 00:24:49.310
traffic sites that you're hitting
or the pages that are coming up.

00:24:49.350 --> 00:24:55.330
So you can see that this has
had 66 pages rendered so far.

00:24:55.330 --> 00:25:00.630
And what you can see here is that
this will give me the number that has

00:25:00.630 --> 00:25:06.270
been served and the number and kind
of the averages and the outliers.

00:25:06.300 --> 00:25:10.280
So obviously, given this app,
I should optimize the event.

00:25:10.300 --> 00:25:11.620
So I'm going to go ahead and do that.

00:25:11.620 --> 00:25:16.580
And then I'm going to go ahead and
do the display page because this

00:25:16.580 --> 00:25:16.580
is what's getting hit the most.

00:25:17.400 --> 00:25:20.950
But it also can give you a good idea
that you can see that the first query

00:25:21.100 --> 00:25:26.990
is taking 1.2 seconds to come up,
and the first inspect

00:25:27.390 --> 00:25:29.460
page relatively quickly.

00:25:29.460 --> 00:25:33.140
And the list page, you can see that it's
rendered eight times,

00:25:33.140 --> 00:25:38.780
but the first time it took 3.66 seconds,
whereas the average is 0.6 seconds.

00:25:38.780 --> 00:25:41.840
So that can sometimes tell you
that you have something that's

00:25:41.840 --> 00:25:43.460
coming up that is rather slow.

00:25:45.640 --> 00:25:51.240
And so to then drill down and figure out
what exactly am I doing wrong with that,

00:25:51.270 --> 00:25:53.580
you can go over to
something called the events.

00:25:53.580 --> 00:25:58.870
So the stats basically just gives
you kind of an overall look.

00:25:58.880 --> 00:26:02.980
And with Music Store,
we'll log into various different apps

00:26:02.980 --> 00:26:07.740
and just kind of check out to see
what the current apps are looking like

00:26:07.800 --> 00:26:10.880
in terms of what their averages are,
what the outliers are,

00:26:10.880 --> 00:26:12.490
because sometimes we'll get
some very long ones that we'll

00:26:12.490 --> 00:26:13.420
need to start looking into.

00:26:13.880 --> 00:26:18.620
So for the events,
so this is -- it's actually already

00:26:18.660 --> 00:26:21.290
-- but let's just go to the setup.

00:26:21.440 --> 00:26:26.120
So this is all just stuff that's just,
you know, comes right with WebObjects.

00:26:26.120 --> 00:26:28.430
Very, very simple stuff.

00:26:28.540 --> 00:26:31.910
As long as you specify the password,
nothing worse than trying a

00:26:31.910 --> 00:26:34.040
million passwords and realizing,
oh,

00:26:34.040 --> 00:26:36.310
it's not quite in the properties file.

00:26:36.320 --> 00:26:39.890
And those are -- it's right there.

00:26:40.480 --> 00:26:44.070
So we're turning all of the events on,
so we're setting it to everything,

00:26:44.070 --> 00:26:47.600
and then we're going back to our app
and we're hitting the list all users.

00:26:47.620 --> 00:26:51.860
So that we can go right back
to this and show the event log.

00:26:54.030 --> 00:26:58.440
Now, this has many different options,
and it can somewhat be

00:26:58.450 --> 00:27:01.780
rather non-intuitive exactly
how these are organized.

00:27:01.780 --> 00:27:05.180
The one that I always like is I always
just like to look at the events group

00:27:05.250 --> 00:27:06.770
by the page and by the component.

00:27:06.780 --> 00:27:12.570
As this can show,
that off of the main page here, that...

00:27:14.500 --> 00:27:18.010
The main is obviously the
one that's hurting the most.

00:27:18.010 --> 00:27:22.940
And the query page is coming up slow
as well relative to everything else.

00:27:22.940 --> 00:27:27.760
So pretty much when you look at this,
you can say, well, geez, the main page,

00:27:27.830 --> 00:27:29.280
that's the pig.

00:27:30.100 --> 00:27:32.810
And so when you turn event logging on,
it pretty much just covers

00:27:32.810 --> 00:27:33.930
all your application.

00:27:33.940 --> 00:27:37.060
And so anything that's going on
is getting logged with events.

00:27:37.060 --> 00:27:40.340
So then you can say, well, geez, OK,
it's not the new list page.

00:27:40.340 --> 00:27:41.720
It must be something else.

00:27:41.720 --> 00:27:44.200
So it just kind of gives you
an ability to drill down.

00:27:44.200 --> 00:27:48.200
So you can see that this-- and voila,
list users.

00:27:48.550 --> 00:27:50.380
Well, what's going on here?

00:27:50.600 --> 00:27:52.450
Ah, objects with fetch specification.

00:27:52.490 --> 00:27:54.200
I think I've seen one of those before.

00:27:54.360 --> 00:27:56.180
So you can see it on list users.

00:27:56.230 --> 00:27:58.300
On the pull, that's the action.

00:27:58.300 --> 00:27:59.660
That's what I had bound
up to the action link.

00:27:59.660 --> 00:28:02.280
So when you're clicking on the link,
it says list my users.

00:28:02.280 --> 00:28:06.200
So you can see that what's
hurting here is the fetch.

00:28:06.230 --> 00:28:10.330
Right here is the fetch spec
of pulling up the users.

00:28:10.370 --> 00:28:13.060
So...

00:28:13.900 --> 00:28:16.200
Later on we'll come back and
basically show some more fine

00:28:16.200 --> 00:28:19.140
grained tools after we go through
some of the database optimization to

00:28:19.140 --> 00:28:21.500
then try to discover what's going on.

00:28:21.500 --> 00:28:26.210
So, if we can go back to the slides.

00:28:29.750 --> 00:28:32.720
So, as Bill mentioned,
my name is Max Muller.

00:28:32.720 --> 00:28:35.700
I am one of the lead engineers
in the iTunes Music Store,

00:28:35.700 --> 00:28:38.580
and I've been on this now
since the very beginning.

00:28:38.580 --> 00:28:43.600
So we worked very hard and came
across all the issues that Bill,

00:28:43.600 --> 00:28:47.740
that Pitt went over and
made some of the mistakes,

00:28:47.740 --> 00:28:50.480
even though we've all been, you know,
pretty much most of us on the

00:28:50.490 --> 00:28:52.060
team have been doing this for,
you know,

00:28:52.180 --> 00:28:53.560
since the WebObjects three days.

00:28:54.740 --> 00:28:58.370
So this is kind of just more
stuff that we've stumbled across,

00:28:58.390 --> 00:29:00.240
that we've had to optimize.

00:29:00.240 --> 00:29:04.730
Being one of the lead engineers,
I pretty much get to eat, breathe,

00:29:04.730 --> 00:29:07.800
and live optimizing these applications.

00:29:07.800 --> 00:29:11.520
When we launched in Europe,
the average from when we

00:29:11.520 --> 00:29:15.160
had launched to Europe,
we were selling on average

00:29:15.160 --> 00:29:17.720
5.86 songs per second.

00:29:17.720 --> 00:29:19.760
That's how many we had
since we had launched.

00:29:19.760 --> 00:29:22.240
So if you're doing many things
per second over an average,

00:29:22.240 --> 00:29:24.350
you know,
obviously the peak's much higher.

00:29:24.740 --> 00:29:25.700
The trough's lower.

00:29:25.700 --> 00:29:30.050
Small little problems can very
quickly turn into very large problems.

00:29:30.060 --> 00:29:32.620
And that's one thing
that we really found.

00:29:32.620 --> 00:29:37.820
You know, we had to spend a lot of time
tuning the database because

00:29:37.820 --> 00:29:40.680
WebObjects itself is very fast.

00:29:40.680 --> 00:29:44.420
If you've got just a pure WoW app,
it's not doing any database work,

00:29:44.420 --> 00:29:48.560
and you've somehow made it slow,
you've really done something wrong.

00:29:48.580 --> 00:29:51.040
Because out of the box, it's very fast.

00:29:51.040 --> 00:29:52.760
I mean, you're able to generate
responses very quickly.

00:29:52.760 --> 00:29:54.620
And the request response.

00:29:54.740 --> 00:29:57.440
very quickly.

00:29:57.850 --> 00:30:03.350
So in terms of getting
down to the database work,

00:30:03.410 --> 00:30:06.930
a lot of the stuff that you can
have happening in kind of your

00:30:06.930 --> 00:30:09.920
administration apps can also very
quickly affect things that are taking

00:30:10.080 --> 00:30:12.070
place in your production applications.

00:30:12.100 --> 00:30:15.460
So we had a content management
application that our content team

00:30:15.460 --> 00:30:19.080
is constantly in there working
on building the new storefronts.

00:30:20.420 --> 00:30:23.470
And we would notice that
sometimes during the day,

00:30:23.490 --> 00:30:25.200
the store would get slow.

00:30:25.200 --> 00:30:27.910
And it turns out that they're in there
just doing all these queries that are

00:30:27.960 --> 00:30:29.740
bringing back very large sets of results.

00:30:29.740 --> 00:30:33.860
And it's actually causing
the database a lot of pain.

00:30:33.860 --> 00:30:36.770
And so the store itself is starting
to get slow because the database is

00:30:36.810 --> 00:30:39.730
having to service all the content
requests rather than actually the

00:30:39.730 --> 00:30:44.850
requests of people wanting to buy music,
which is not a good thing.

00:30:44.860 --> 00:30:50.320
So putting in place fetch limits,
putting in place requiring.

00:30:50.420 --> 00:30:55.490
Certain queries can significantly
reduce the amount of database

00:30:55.490 --> 00:31:00.320
work that your database is doing,
which your users actually

00:31:00.320 --> 00:31:02.880
might not be seeing.

00:31:03.210 --> 00:31:06.580
So there's also a number of tools
from database vendors taking queries

00:31:06.580 --> 00:31:08.850
and handing them off to your DBAs.

00:31:08.850 --> 00:31:10.540
It can also be very handy.

00:31:10.540 --> 00:31:15.090
One bit that's out there that
we did was when we opened a

00:31:15.210 --> 00:31:19.370
new connection to our database,
there's actually a stored procedure

00:31:19.380 --> 00:31:23.220
that you can call in Oracle to put
in information about the connection.

00:31:23.220 --> 00:31:25.880
Because by default,
for all the JDBC stuff,

00:31:25.880 --> 00:31:29.100
when it connects in,
all that the DBA is going to be able

00:31:29.100 --> 00:31:31.340
to see is that it's a Java process.

00:31:32.240 --> 00:31:34.200
Yeah, well,
that doesn't really help you if

00:31:34.200 --> 00:31:37.240
you've got a whole heterogeneous
mix of back-end processing apps,

00:31:37.240 --> 00:31:42.050
store apps, and a very large environment
of Java applications.

00:31:42.070 --> 00:31:45.440
So you can put in information into
the connection so that if they see

00:31:45.440 --> 00:31:48.480
some query that's running amok,
they can actually look at the

00:31:48.620 --> 00:31:50.900
connection that's causing that query.

00:31:50.900 --> 00:31:53.350
So we put in the application name,
the host it's on,

00:31:53.410 --> 00:31:54.690
even when it started up.

00:31:54.780 --> 00:31:58.310
Because sometimes we found that
we'd forget to stop an instance and

00:31:58.310 --> 00:32:02.140
it would be off in la-la land when
we would have rolled a new version.

00:32:02.240 --> 00:32:03.180
So we'd go back to the
software and be like,

00:32:03.180 --> 00:32:03.930
"Wow, what's going on?

00:32:03.940 --> 00:32:06.330
I thought we fixed this
problem." And lo and behold,

00:32:06.370 --> 00:32:08.250
it's like, "Well,
that guy's actually been running

00:32:08.250 --> 00:32:09.370
for a week," kind of thing.

00:32:09.500 --> 00:32:14.460
So binary data in the database
is definitely a no-no,

00:32:14.620 --> 00:32:17.410
especially if you accidentally check
the locking column to where EOF thinks

00:32:17.450 --> 00:32:19.430
it needs to lock on that attribute.

00:32:19.480 --> 00:32:22.840
And so it'll issue the where clause.

00:32:22.820 --> 00:32:25.390
If you do,
moving down to a 2-1 relationship,

00:32:25.390 --> 00:32:29.520
also this goes back to what
Bill was saying about having

00:32:29.550 --> 00:32:34.460
certain models or certain attributes
only for what you're working on,

00:32:34.460 --> 00:32:37.340
for your administration work,
and different ones for

00:32:37.340 --> 00:32:38.660
maybe the consumers.

00:32:38.660 --> 00:32:42.440
So maybe you have a large clob field
that people enter in a bunch of

00:32:42.440 --> 00:32:47.060
notes about an album that shows up,
this came from this, blah, blah, blah,

00:32:47.060 --> 00:32:48.480
blah, blah, blah.

00:32:48.900 --> 00:32:50.920
Well, that clob,
which could get very large,

00:32:50.950 --> 00:32:53.400
we don't want the store
app pulling that thing up.

00:32:53.400 --> 00:32:57.520
I mean, so you can either take the
approach of creating a new model,

00:32:57.520 --> 00:33:00.960
or at runtime,
you can just turn off that attribute.

00:33:00.960 --> 00:33:03.930
Say, you know, really, UF,
you don't need to worry about that one.

00:33:03.940 --> 00:33:06.710
Leave that in the database when
we're in this kind of read-only mode,

00:33:06.710 --> 00:33:09.670
because nobody's going to be, you know,
you don't need the clob.

00:33:16.100 --> 00:33:20.860
So we use the shared editing context
for pretty much just reference data,

00:33:20.860 --> 00:33:26.100
kind of complete types,
in the sense that it's kind of like a,

00:33:26.100 --> 00:33:28.640
just a type safe enum that, um,

00:33:28.920 --> 00:33:33.470
- You know, where it says, you know,
key one is this key,

00:33:33.470 --> 00:33:36.310
and key two is this key,
instead of kind of having a lookup,

00:33:36.310 --> 00:33:38.310
that's pretty much what we use it for.

00:33:38.440 --> 00:33:41.880
So when your app starts up,
all the shared editing

00:33:41.900 --> 00:33:45.480
context information is loaded,
and then it doesn't have to be refetched.

00:33:45.570 --> 00:33:48.640
And likewise, when you trip the
relationships to the shared,

00:33:48.710 --> 00:33:52.820
information to the shared,
to EOs in the shared context, it's not,

00:33:52.820 --> 00:33:56.670
it doesn't require a database trip.

00:33:57.000 --> 00:33:59.180
So there is inter-app messaging.

00:33:59.250 --> 00:34:04.710
If you need to synchronize
states between applications for

00:34:04.870 --> 00:34:12.500
critical pieces of snapshots,
a lot of the times just

00:34:12.500 --> 00:34:18.110
telling it that it's no longer,
it's no longer a valid

00:34:18.110 --> 00:34:19.660
snapshot is good enough.

00:34:19.660 --> 00:34:22.720
So it's not that you really wanna move
all of the snapshots over and say,

00:34:22.740 --> 00:34:24.290
here's the new snapshot.

00:34:24.330 --> 00:34:27.390
It's more just along the lines of saying,
hey, you know,

00:34:27.400 --> 00:34:30.080
this snapshot for this guy,
it got updated by this one.

00:34:30.080 --> 00:34:35.070
So the next time you need it,
you better go get it from the database.

00:34:35.350 --> 00:34:45.570
Raw rows is a useful technique for
pulling back large content where

00:34:45.570 --> 00:34:47.470
you don't need all the snapshots,
stuff that you're not

00:34:47.540 --> 00:34:48.340
going to be editing.

00:34:48.340 --> 00:34:51.340
Within the store,
we have all these popularity

00:34:51.340 --> 00:34:53.630
caches that are getting rebuilt.

00:34:53.660 --> 00:34:56.240
It's like, if you like this,
you like that.

00:34:56.900 --> 00:35:01.660
Well, as the number of items
that you can buy expands,

00:35:01.660 --> 00:35:06.430
we'll pull that stuff in with a raw
fetch actually in a separate thread.

00:35:06.460 --> 00:35:09.030
So this thread can just kind of
sit in the background every so

00:35:09.060 --> 00:35:13.260
often and determines the needs to
go out to the database and pull

00:35:13.260 --> 00:35:19.620
in a new set of recommendations.

00:35:19.620 --> 00:35:22.850
So when we're rendering
some of the pages,

00:35:22.850 --> 00:35:24.260
it can sync it up.

00:35:24.360 --> 00:35:26.440
So it'll basically refresh this cache.

00:35:26.580 --> 00:35:29.870
You know, in the background,
in the background thread

00:35:29.870 --> 00:35:31.360
using the raw fetches.

00:35:31.360 --> 00:35:34.660
Caching and memory, it's good.

00:35:34.660 --> 00:35:38.940
A lot of the times, if you have kind of a
read-only application,

00:35:38.940 --> 00:35:41.330
you can look at,
instead of using one kind

00:35:41.340 --> 00:35:45.440
of shared editing context,
that you'll then pull stuff

00:35:45.440 --> 00:35:47.620
into and then hold on to.

00:35:47.620 --> 00:35:50.620
And so the application will
hold the reference to this.

00:35:50.630 --> 00:35:56.100
It's not a shared editing context,
but it's a shared editing context.

00:35:56.820 --> 00:36:00.090
So.

00:36:00.430 --> 00:36:03.260
Adapter debugging enabled, obviously.

00:36:03.260 --> 00:36:05.780
That's when you just
can turn it on and say,

00:36:05.780 --> 00:36:07.430
what SQL is going on here?

00:36:07.430 --> 00:36:11.690
This one, it's a godsend.

00:36:11.700 --> 00:36:13.290
Java length throwables.

00:36:13.290 --> 00:36:16.880
Being able to generate backtraces
anywhere is very handy.

00:36:16.880 --> 00:36:21.730
I'll show you how we can change the
logging pattern at runtime to start

00:36:21.760 --> 00:36:25.810
throwing in backtraces anywhere we want,
which can really help.

00:36:26.260 --> 00:36:28.210
A lot of the times,
if you're just looking at the SQL,

00:36:28.210 --> 00:36:30.960
you'll be like, whoa, hold on,
where's that coming from?

00:36:30.960 --> 00:36:34.700
One of the very common mistakes that
a lot of people will make is if they

00:36:34.710 --> 00:36:38.830
fetch an object and then they're like,
oh, they pre-fetch everything,

00:36:38.830 --> 00:36:41.420
and then on the next request,
they'll say, well,

00:36:41.420 --> 00:36:44.600
we need to go ahead and invalidate
the editing context here so we

00:36:44.600 --> 00:36:46.240
make sure we have fresh data.

00:36:46.240 --> 00:36:49.840
But the problem is you've
got the object graph there,

00:36:49.840 --> 00:36:53.580
and so you've got an object,
and you've spent the time to

00:36:53.640 --> 00:36:55.730
pre-fetch out all the stuff.

00:36:56.220 --> 00:36:58.380
You've got it in two or
three or four fetches,

00:36:58.380 --> 00:37:02.500
but then you've invalidated
all the data underneath you,

00:37:02.500 --> 00:37:03.770
and so all of a sudden,
you start to trip over

00:37:03.770 --> 00:37:05.670
these things again,
and it's like, oh, that's actually been

00:37:05.680 --> 00:37:06.520
turned back into a fault.

00:37:06.580 --> 00:37:07.860
I need to go out to the database again.

00:37:07.860 --> 00:37:10.250
And you're like, well, geez,
I pre-fetched everything,

00:37:10.250 --> 00:37:12.250
and now I've got SQL going
out the yin-yang.

00:37:12.280 --> 00:37:15.360
So turning on adapter
debugging can help you see it,

00:37:15.430 --> 00:37:20.220
but being able to actually see the
backtrace of where the faults are firing.

00:37:20.240 --> 00:37:23.710
So I'll show you in the demo a
trick that we use in the music store

00:37:23.710 --> 00:37:25.750
quite a bit where we can turn on.

00:37:26.240 --> 00:37:29.200
There's actually a delegate hook,
and we can throw backtraces

00:37:29.320 --> 00:37:30.690
whenever a fault is fired.

00:37:30.700 --> 00:37:34.700
So a lot of times we'll turn that on and
then go to render a page that has somehow

00:37:34.700 --> 00:37:36.870
started to get slow for some reason.

00:37:36.880 --> 00:37:39.780
And a lot of the times it isn't because
that page itself has gotten slow.

00:37:39.780 --> 00:37:43.940
It's because something else is
triggering something that's causing

00:37:43.940 --> 00:37:46.390
the snapshots to get old or wiped out.

00:37:46.400 --> 00:37:52.730
So, yeah, excess faulting,
that's a hot one.

00:37:52.740 --> 00:37:55.710
Also, another trick that you can do
with the Java length throwables.

00:37:56.290 --> 00:38:01.190
In a constructor of a Java object,
if you have debugging turned on,

00:38:01.190 --> 00:38:05.350
some debugging flag,
you can actually create a throwable

00:38:05.680 --> 00:38:09.910
object in the constructor and
stash that away in an iBar.

00:38:09.920 --> 00:38:12.480
At which point then,
at any point later on,

00:38:12.480 --> 00:38:15.620
you can always ask the object,
what's the stack trace

00:38:15.620 --> 00:38:17.160
where you were created?

00:38:17.160 --> 00:38:21.860
Which can be very handy in, say,
Woe Sessions, where sometimes we'll,

00:38:21.860 --> 00:38:25.560
you know, we have several apps that
are completely sessionless.

00:38:26.300 --> 00:38:28.790
And all of a sudden we'll start
to see sessions popping up.

00:38:28.800 --> 00:38:30.610
And we'll be like, well, what's going on?

00:38:30.620 --> 00:38:33.740
And so we'll set this
value and then we can,

00:38:33.880 --> 00:38:37.140
at a later point,
get the Woe Sessions store.

00:38:37.140 --> 00:38:39.700
Just basically we'll say,
dump out all your sessions

00:38:39.700 --> 00:38:40.940
and give me the back trace.

00:38:40.940 --> 00:38:42.500
Because there's somebody
who's doing something bad.

00:38:42.500 --> 00:38:45.120
And, you know, more often than not,
it's a Woe Active Image.

00:38:45.120 --> 00:38:47.000
Somebody put a Woe Active Image in.

00:38:47.000 --> 00:38:50.160
And if you don't bind it up correctly,
it'll go ahead and create a session

00:38:50.160 --> 00:38:51.660
and create a component action for you.

00:38:51.700 --> 00:38:54.460
Very handy, but, you know,
not what you want when somebody just

00:38:54.460 --> 00:38:56.100
accidentally forgot to do a binding.

00:38:56.100 --> 00:38:58.350
And then all of a sudden
you've got these pages that are

00:38:58.350 --> 00:38:59.780
generating lots of sessions.

00:38:59.780 --> 00:39:01.200
Because a lot of the times
they won't be referenced.

00:39:01.200 --> 00:39:03.400
And so you'll get a lot of them created.

00:39:03.400 --> 00:39:07.720
So you can get one request and you can
somehow get multiple sessions created.

00:39:07.780 --> 00:39:10.660
Which just causes all sorts of, you know,
nightmares.

00:39:10.660 --> 00:39:14.320
Fetching it from pop-ups, yes.

00:39:19.170 --> 00:39:20.600
Yeah, yeah.

00:39:20.600 --> 00:39:25.450
The local instance of object you
have to also be aware of is if

00:39:25.450 --> 00:39:30.440
your fetch timestamp lag is set,
the fetch timestamp lag is saying,

00:39:30.440 --> 00:39:32.670
you know,
how new snapshot do you care about?

00:39:32.700 --> 00:39:35.440
So oftentimes what people do is
they'll create a new editing context,

00:39:35.450 --> 00:39:37.590
they'll set the fetch
timestamp lag to right now.

00:39:37.590 --> 00:39:39.180
Say, I want everything fresh.

00:39:39.180 --> 00:39:41.690
And then they'll start doing
the local instance of object,

00:39:41.690 --> 00:39:43.740
and of course,
then when they touch the object,

00:39:43.740 --> 00:39:44.970
it goes to the database.

00:39:45.000 --> 00:39:47.650
So you could have fetched all this stuff,
and then you're like, oh,

00:39:47.650 --> 00:39:49.080
I need to do a local instance now.

00:39:49.100 --> 00:39:52.320
Let me create a fresh editing context.

00:39:52.320 --> 00:39:55.350
And so that usage pattern,
all of a sudden you'd be like, well,

00:39:55.350 --> 00:39:59.530
I thought I was doing something good,
but it turns out that local instance

00:39:59.550 --> 00:40:03.220
of object can actually cause a
lot of trips to the database.

00:40:06.860 --> 00:40:11.560
Simplified object model, if you can.

00:40:11.610 --> 00:40:14.520
We're at 300 or 400 entities
right now at the music store,

00:40:14.740 --> 00:40:19.630
and it's growing more each week.

00:40:19.860 --> 00:40:22.780
The deep inheritance,
the vertical inheritance is the only

00:40:22.790 --> 00:40:26.490
efficient form of inheritance in EOF.

00:40:26.500 --> 00:40:29.450
I've used it for many years now.

00:40:29.460 --> 00:40:30.260
It works rather well.

00:40:30.260 --> 00:40:36.760
It allows you to have a user and then
a person user and all these kind of

00:40:36.760 --> 00:40:40.040
things mapped onto the same table,
and you can still have relationships

00:40:40.040 --> 00:40:41.250
to the top abstract entity.

00:40:41.290 --> 00:40:44.420
So when you trip a relationship,
you could be getting all

00:40:44.420 --> 00:40:48.750
the different sub-entities,
but EOF handles that gracefully

00:40:49.000 --> 00:40:51.300
for you underneath the covers.

00:40:51.300 --> 00:40:57.220
The other form of inheritance
is across multiple hierarchy,

00:40:57.220 --> 00:41:00.670
across multiple tables,
and that one is rather inefficient

00:41:00.670 --> 00:41:03.540
because anytime you trip a fault,
it's going to be like,

00:41:03.540 --> 00:41:04.380
is it in this table?

00:41:04.380 --> 00:41:05.220
Is it in this table?

00:41:05.220 --> 00:41:06.100
Is it in this table?

00:41:06.200 --> 00:41:09.400
So if you do have to use
that type of inheritance,

00:41:09.400 --> 00:41:12.960
the best way is to always trip,
to always model the relationships

00:41:12.960 --> 00:41:14.270
down to all the sub-entities.

00:41:14.270 --> 00:41:20.340
Bill Bumgarner So the views
of the database queries,

00:41:20.340 --> 00:41:23.460
if you can get an efficient
one that has the bind that,

00:41:23.460 --> 00:41:26.890
a lot of the times if you don't
need all the bind variables

00:41:26.890 --> 00:41:30.810
coming through in a view,
it can be efficient.

00:41:30.870 --> 00:41:35.480
The access back pointers is a
really hot ticket one because a

00:41:35.480 --> 00:41:40.320
lot of the times you'll have a
situation where you'll have a user,

00:41:40.320 --> 00:41:44.490
you know, from a music store example,
so you have a user that's

00:41:44.500 --> 00:41:45.300
got many purchases.

00:41:45.300 --> 00:41:49.060
So when somebody clicks buy, you know,
you're going to be creating

00:41:49.060 --> 00:41:50.020
a purchase for them.

00:41:50.100 --> 00:41:53.700
And so the tendency might be just to say,
you know, create a purchase,

00:41:53.700 --> 00:41:56.230
add object to both sides
of the relationship,

00:41:56.230 --> 00:41:58.980
you know, to get the user on and save it.

00:41:58.980 --> 00:42:01.630
Well, if you recall Steve's
keynote a few while back,

00:42:01.630 --> 00:42:03.580
you know,
the number one person in the music store,

00:42:03.580 --> 00:42:07.680
27,115 songs at that point.

00:42:07.680 --> 00:42:09.620
That's a whole lot of purchases.

00:42:09.620 --> 00:42:12.800
And so what happens is when you add
object to both sides of the relationship,

00:42:12.820 --> 00:42:13.630
if that relationship
hasn't been fulfilled,

00:42:13.630 --> 00:42:14.750
you're going to have a lot of faulted.

00:42:14.750 --> 00:42:17.370
You're going to trip it,
which means you're going to be

00:42:17.370 --> 00:42:18.980
pulling in all those things.

00:42:18.980 --> 00:42:21.760
So all of a sudden you're like, well,
geez, why is a slow,

00:42:22.010 --> 00:42:24.470
why is my app getting
slow on random intervals?

00:42:24.470 --> 00:42:26.930
This buy took, you know,
three minutes in production.

00:42:26.950 --> 00:42:28.420
What the heck happened there?

00:42:28.420 --> 00:42:30.100
You know, not only that,
but the memory footprint

00:42:30.100 --> 00:42:30.980
went through the roof.

00:42:30.980 --> 00:42:33.970
Well, we just pulled in 27,000 things
just because they're trying

00:42:33.970 --> 00:42:35.130
to purchase one more thing.

00:42:35.130 --> 00:42:37.150
So if you don't have to
trip the relationships,

00:42:37.150 --> 00:42:39.540
whereas, you know,
if you just create the purchase,

00:42:39.790 --> 00:42:42.740
set the user, save it to the database,
that's fine.

00:42:44.100 --> 00:42:48.500
So the back relationships,
or you can just not model it, just,

00:42:48.500 --> 00:42:51.640
you know, remove the modeling in
the model completely.

00:42:51.640 --> 00:42:55.940
So, I mean, yeah,
hope this isn't too advanced.

00:42:55.940 --> 00:42:59.200
It's just trying to cover
a bunch of stuff that,

00:42:59.200 --> 00:43:02.370
you know, is we've found.

00:43:04.320 --> 00:43:05.300
That's right.

00:43:05.370 --> 00:43:08.780
That's a little known technique.

00:43:08.800 --> 00:43:13.570
Little known database technique.

00:43:13.570 --> 00:43:13.570
Sure.

00:43:14.650 --> 00:43:18.340
So, you can, you know, databases are,
you know,

00:43:18.340 --> 00:43:19.700
they're built for these kind of things.

00:43:19.700 --> 00:43:23.690
I mean, they're, you know,
that's what you pay the big bucks

00:43:23.690 --> 00:43:27.340
for the big tools is that they,
you know, they provide all the tools.

00:43:27.340 --> 00:43:30.840
And, you know, if you've got a good DBA,
you can get in there,

00:43:30.850 --> 00:43:33.480
or you can get in there
yourself and look.

00:43:33.480 --> 00:43:36.430
There's, you know,
if you can identify your top

00:43:36.430 --> 00:43:39.800
queries in your database,
then you can start to go back

00:43:39.850 --> 00:43:43.700
and look to see where they're
coming from in your applications.

00:43:44.420 --> 00:43:46.460
About once a month, you know,
our DBAs will send us a

00:43:46.460 --> 00:43:49.290
spreadsheet and be like,
all right, here's the top 10, go for it,

00:43:49.290 --> 00:43:50.160
kind of thing.

00:43:50.160 --> 00:43:52.950
So, you know,
then we start hunting around, like, okay,

00:43:52.950 --> 00:43:54.490
where's this one coming from?

00:43:54.500 --> 00:43:56.960
And, okay, who did this kind of thing?

00:43:56.960 --> 00:44:00.060
So, it's very useful.

00:44:04.260 --> 00:44:05.700
Yes.

00:44:05.700 --> 00:44:09.190
So, generated SQL is obviously one.

00:44:09.200 --> 00:44:17.380
We basically focus on optimizing the
parts that are getting hit the most.

00:44:17.420 --> 00:44:26.920
We don't optimize the copyright
page if the copyright page is slow.

00:44:26.920 --> 00:44:26.980
And stored procedures, they're

00:44:27.310 --> 00:44:31.240
They're useful for some things,
in some places where they're very useful,

00:44:31.240 --> 00:44:34.980
but other places where you are,
if you're using a stored procedure to

00:44:34.980 --> 00:44:41.630
update rows that you're also modeling,
you can really wind up in a state

00:44:41.630 --> 00:44:45.610
very quickly where you've just
executed a stored procedure call,

00:44:45.650 --> 00:44:50.220
it's updated something underneath,
and now your snapshot's out of date.

00:44:50.220 --> 00:44:54.660
And there are techniques that you can
use to keep your snapshots up to date,

00:44:54.660 --> 00:44:55.800
but it's, you know, it's a pain.

00:44:56.200 --> 00:45:01.890
So if we can go back over to demo four.

00:45:02.730 --> 00:45:04.080
So I'll just show a few bits here.

00:45:04.080 --> 00:45:08.440
We're doing OK on time.

00:45:08.480 --> 00:45:12.290
So coming back here,
we can see that the list

00:45:12.440 --> 00:45:14.820
users is inefficient.

00:45:14.820 --> 00:45:17.720
So then it's, well, what do we do?

00:45:17.720 --> 00:45:21.580
So the first thing is
you check your logs.

00:45:21.580 --> 00:45:26.370
OK, nothing in the logs.

00:45:27.050 --> 00:45:28.960
I'll bring up this,
and I'll show you just a

00:45:29.010 --> 00:45:30.000
few tricks that we use.

00:45:30.000 --> 00:45:34.180
And all this stuff is in
Project Wonder that we contributed back.

00:45:34.180 --> 00:45:39.190
So nothing I'm doing here is
proprietary or something like that.

00:45:39.220 --> 00:45:43.100
So the first thing we can start
to look at is we can be like,

00:45:43.460 --> 00:45:47.410
well, geez, let's look at our... So this
is without restarting the app,

00:45:47.410 --> 00:45:47.880
by the way.

00:45:47.880 --> 00:45:52.250
So I just... Let's start
looking at our database traffic.

00:45:52.290 --> 00:45:54.520
Let's see what's going on.

00:45:57.290 --> 00:45:59.060
for our little app.

00:46:02.020 --> 00:46:04.280
So list users.

00:46:04.280 --> 00:46:06.130
All right.

00:46:06.170 --> 00:46:11.680
Whoa, a whole lot of SQL there, huh?

00:46:11.790 --> 00:46:17.300
So we can see that we're fetching
stuff from the user table,

00:46:17.480 --> 00:46:22.000
but then all of a sudden we've
got user infos all over here.

00:46:22.000 --> 00:46:25.870
A whole lot of user info columns.

00:46:27.970 --> 00:46:31.180
So you're like, what's going on here?

00:46:31.260 --> 00:46:33.290
So has user infos.

00:46:33.320 --> 00:46:34.320
There's six there.

00:46:34.320 --> 00:46:39.590
Well, there's more than six queries.

00:46:39.610 --> 00:46:41.810
Actually, there is six queries.

00:46:41.810 --> 00:46:42.440
Sorry.

00:46:42.440 --> 00:46:47.930
So this is...

00:46:48.580 --> 00:46:50.140
So let's do one more thing.

00:46:50.140 --> 00:46:51.980
SQL's not really that useful here.

00:46:52.040 --> 00:46:55.250
So let's look at fault firing.

00:46:55.300 --> 00:46:58.030
Let's see when we're
actually firing faults.

00:47:01.460 --> 00:47:05.640
So all that this thing, so let's go here.

00:47:05.640 --> 00:47:09.690
Yeehaw.

00:47:13.450 --> 00:47:15.530
So then we can look down here,
and so here's main.

00:47:15.720 --> 00:47:17.880
Here's my list users method.

00:47:17.930 --> 00:47:22.100
So the set data source,
so let me just show you the code.

00:47:26.700 --> 00:47:31.700
Very, very simple.

00:47:31.700 --> 00:47:34.200
So I'm just creating a
database data source of users,

00:47:34.300 --> 00:47:36.810
setting the data source on a list page,
handing it off.

00:47:36.880 --> 00:47:39.400
That's all the code that's going on here.

00:47:39.420 --> 00:47:47.950
And we have one in services that the
other app is using to talk to it.

00:47:48.000 --> 00:47:51.400
It's just a -- and this
is just the plain vanilla.

00:47:52.200 --> 00:47:59.360
- Out of the box,
WebObjects handling all the services.

00:47:59.360 --> 00:47:59.360
So I wrote a bit of code here,
I did it myself so that I could

00:47:59.650 --> 00:48:04.050
This is a user service,
and so I exposed the find users method.

00:48:04.050 --> 00:48:07.990
I used the, if you saw Bob's talk on
the first part of web,

00:48:07.990 --> 00:48:13.490
on the introduction of WebObjects about,
you know, there's this WS make stubs

00:48:13.490 --> 00:48:16.300
command line app that you can run.

00:48:16.300 --> 00:48:20.110
So all I did was I wrote a
find users and an update user.

00:48:20.110 --> 00:48:25.320
Takes the user ID, the first name,
the last name, and the find user takes a

00:48:25.320 --> 00:48:27.420
first name and last name.

00:48:29.240 --> 00:48:35.610
And then in my application, I said, whoa,
web service register, register this guy.

00:48:37.110 --> 00:48:39.560
And I ran the make stubs on this.

00:48:39.750 --> 00:48:44.510
It generated for the
Cocoa side all these stubs,

00:48:44.570 --> 00:48:46.750
the WS generated object.

00:48:46.820 --> 00:48:49.930
And then I just wrapped it in
a little bit of user services.

00:48:50.170 --> 00:48:52.560
So I mean,
it took all of a few hours to do.

00:48:52.720 --> 00:48:55.360
Nothing complex here at all.

00:48:55.480 --> 00:49:00.360
Actually, not even a few hours,
half an hour.

00:49:00.450 --> 00:49:04.960
So going back here now, we can see--

00:49:06.730 --> 00:49:09.190
We can see basically the backtrace,
and so that's happening

00:49:09.220 --> 00:49:10.080
on a set data source.

00:49:10.260 --> 00:49:12.130
This is our fetch specification.

00:49:12.250 --> 00:49:19.640
So we can see that we're fetching users,
no qualifiers, no prefetching keys.

00:49:19.680 --> 00:49:24.100
Then, next we're fetching user info.

00:49:25.170 --> 00:49:27.680
So here's main, here's set data source,
here's fetch.

00:49:27.690 --> 00:49:29.740
Whoa, what's going on here?

00:49:29.890 --> 00:49:31.440
Awake from fetch.

00:49:31.510 --> 00:49:32.940
So you can see I'm just
walking up the tree.

00:49:33.080 --> 00:49:34.420
User line 33.

00:49:34.420 --> 00:49:38.500
So I say, well,
what's going on in user line 33?

00:49:38.500 --> 00:49:43.210
User line 33.

00:49:44.140 --> 00:49:48.520
Oh, if first name is Max and
I've got this test user info,

00:49:48.520 --> 00:49:51.540
then I'm fetching it 10 times.

00:49:51.540 --> 00:49:51.940
Not so good.

00:49:51.940 --> 00:49:58.170
So let me set this to false.

00:49:59.360 --> 00:50:02.340
left it on in production too.

00:50:02.360 --> 00:50:04.540
Oops.

00:50:04.990 --> 00:50:11.170
So I can clear out the console,
go back to the web app now.

00:50:13.500 --> 00:50:30.200
List Users.

00:50:30.200 --> 00:50:30.200
Go back to this guy.

00:50:30.200 --> 00:50:30.200
And lo and behold, a little bit better.

00:50:30.200 --> 00:50:30.200
So these are just a few techniques
that you can use to kind of

00:50:30.520 --> 00:50:32.390
- Quickly get your head around
kind of what's going on.

00:50:32.510 --> 00:50:35.810
I'll show you one more, which is,

00:50:36.040 --> 00:50:41.470
- So we use Log4j for pretty
much everything we do.

00:50:41.470 --> 00:50:50.360
And one of the nice features
that it has is you can see it,

00:50:50.360 --> 00:50:51.480
this current one right here,
I'm saying my conversion

00:50:51.480 --> 00:50:51.480
pattern I want to use,
I'm saying a date,

00:50:51.600 --> 00:50:53.880
- I wanna have my memory stats.

00:50:53.880 --> 00:50:56.650
Yeah, so this is used versus free memory.

00:50:56.830 --> 00:50:58.860
What category is logging?

00:50:58.890 --> 00:51:02.460
The line number that it's calling at,
the priority level, which, you know,

00:51:02.460 --> 00:51:05.340
this is all log4j stuff of, you know,
priority of, you know,

00:51:05.370 --> 00:51:13.010
debug or fatal or I forget what X is,
M is message, and then a new line.

00:51:13.020 --> 00:51:18.170
So when we go back and look at
when one of these gets called,

00:51:18.170 --> 00:51:19.410
let's see.

00:51:20.340 --> 00:51:23.150
So, sorry, I deleted all my stuff.

00:51:23.150 --> 00:51:26.630
So we're back here.

00:51:26.740 --> 00:51:29.490
So let's go back and look at
the first part of this line.

00:51:29.550 --> 00:51:31.280
Yeah, we have the date.

00:51:31.300 --> 00:51:34.880
So far this app is using 11
megabytes and it's got 22.95 free.

00:51:35.060 --> 00:51:41.320
This is being called from the method,
from the class,

00:51:41.320 --> 00:51:45.160
ERX Database Context Delegate, line 149.

00:51:45.170 --> 00:51:46.960
This is a debug.

00:51:46.960 --> 00:51:51.040
And then this is the message.

00:51:51.070 --> 00:51:53.400
So it's printing the stack trace itself.

00:51:55.000 --> 00:51:59.590
If I turn, trying to think,

00:52:00.720 --> 00:52:03.680
So if I go back to this,
if I turn the fault firing off,

00:52:03.680 --> 00:52:07.830
because that guy was going ahead and
putting its own stack trace in there.

00:52:08.020 --> 00:52:12.340
So save this, let's go back here.

00:52:14.040 --> 00:52:17.400
One more time back to the home page.

00:52:17.460 --> 00:52:19.180
So list users.

00:52:20.570 --> 00:52:23.810
So here we have the exact same,
all the same information coming in.

00:52:23.940 --> 00:52:29.440
This is the Log4j bridge
that's just capturing NSLog

00:52:29.440 --> 00:52:31.340
events and routing to Log4j.

00:52:31.340 --> 00:52:37.260
And so again, we're getting messages
coming through here.

00:52:38.080 --> 00:52:42.380
Now what happens is then, lo and behold,
in production, now, for some reason,

00:52:42.380 --> 00:52:43.800
there's something going wrong.

00:52:43.800 --> 00:52:47.150
You've got some random SQL coming
out from this application.

00:52:47.160 --> 00:52:52.500
So you connect in, and you change the
pattern to this pattern.

00:52:52.500 --> 00:52:54.580
So this gives you the WebObjects.

00:52:54.580 --> 00:52:55.260
It'll give you the name.

00:52:55.260 --> 00:52:57.690
It'll give you the number of sessions.

00:52:57.700 --> 00:52:59.190
It'll give you the WOPORT it's bound on.

00:52:59.200 --> 00:53:02.620
It'll give you the PID of the process.

00:53:03.180 --> 00:53:06.010
Date format, give you your VM stats.

00:53:06.010 --> 00:53:07.480
Oh, Control-Z.

00:53:07.480 --> 00:53:09.340
Priority.

00:53:09.340 --> 00:53:12.320
But then I also put %at at the end,
which says, you know,

00:53:12.320 --> 00:53:14.320
go ahead and dump that backtrace.

00:53:14.320 --> 00:53:15.500
I want to see where this is coming from.

00:53:15.500 --> 00:53:19.710
So now, when we turn the fire hose on...

00:53:23.660 --> 00:53:24.370
Get the firehose on.

00:53:24.380 --> 00:53:25.260
One more time.

00:53:25.260 --> 00:53:30.810
And lo and behold, lots and lots.

00:53:30.910 --> 00:53:32.700
Oh, update log.

00:53:32.710 --> 00:53:33.770
Oh, okay, I didn't.

00:53:33.780 --> 00:53:34.400
I turned it off.

00:53:34.440 --> 00:53:38.320
So you can see that this does
have all the information here.

00:53:38.320 --> 00:53:39.820
So it has the name of the application.

00:53:39.820 --> 00:53:41.120
That's the PID.

00:53:41.120 --> 00:53:41.990
That's the port.

00:53:42.000 --> 00:53:47.280
So far I've created 10 active sessions,
date, memory used,

00:53:47.310 --> 00:53:50.370
all this kind of stuff,
as well as stack trace of where

00:53:50.370 --> 00:53:51.580
that line message is coming.

00:53:52.350 --> 00:53:54.780
So these are just a few of the
techniques that we use to hunt down

00:53:54.780 --> 00:53:58.200
performance problems where looking
at where the faults are firing,

00:53:58.200 --> 00:54:00.200
where the database traffic is.

00:54:00.200 --> 00:54:04.220
And then you can also look at
the woe events if you want to

00:54:04.230 --> 00:54:07.080
get more fine-grained and look
at where your components are

00:54:07.210 --> 00:54:09.140
potentially causing you problems.

00:54:09.160 --> 00:54:10.510
So let's see.

00:54:10.520 --> 00:54:11.630
Back to slides.

00:54:11.640 --> 00:54:15.500
Thank you.

00:54:15.520 --> 00:54:16.600
Thank you, Max.

00:54:16.600 --> 00:54:18.300
So as you can see.

00:54:23.300 --> 00:57:34.800
[Transcript missing]

00:57:34.900 --> 01:00:07.500
[Transcript missing]

01:00:09.390 --> 01:00:15.080
There's another area of optimization
is if you generate crap HTML,

01:00:15.080 --> 01:00:17.920
it takes the browser longer to
figure out what it should do with it.

01:00:18.100 --> 01:00:21.780
So if you generate well-structured HTML,
the browsers render faster.

01:00:21.780 --> 01:00:26.020
And this is an interesting one because,
of course, in the early days of HTML,

01:00:26.020 --> 01:00:29.500
it didn't matter if you closed
your paragraph tags or your

01:00:29.500 --> 01:00:31.280
table tags or anything else.

01:00:31.280 --> 01:00:33.940
Because the browser would figure it out,
thanks Microsoft.

01:00:35.040 --> 01:00:38.810
And as things evolved,
it not only affects both the

01:00:38.950 --> 01:00:43.110
HTML processing and parsing
because now the browser has

01:00:43.110 --> 01:00:45.080
to look ahead and then go,
oh, well,

01:00:45.080 --> 01:00:48.240
that tag over there probably means
this one over here needs to be closed.

01:00:48.240 --> 01:00:51.150
But it also confuses things
on the WebObjects side.

01:00:51.300 --> 01:00:55.640
WebObjects components really want
to generate a hierarchy of tags that

01:00:55.650 --> 01:00:57.900
are nested in an insane fashion.

01:00:57.900 --> 01:01:01.850
So looking for things
like overlap problems,

01:01:01.880 --> 01:01:07.040
using an HTML tool like WebLint,
to check the generated content.

01:01:07.040 --> 01:01:10.960
And you really got to check
that generated content because,

01:01:10.960 --> 01:01:16.510
you know, WebObjects page is generated of
many components all spewing forth

01:01:16.510 --> 01:01:19.680
HTML that then gets serialized
and is one big response.

01:01:19.680 --> 01:01:24.180
And you need to check the content in
the context of that whole response.

01:01:24.180 --> 01:01:27.430
Because there can be overlap
problems that are caused by component

01:01:27.430 --> 01:01:29.280
mis-nestings and things like that.

01:01:29.380 --> 01:01:33.320
Simplifying table structures is
another great way to reduce content

01:01:33.320 --> 01:01:37.810
size and moving to CSS or having
a site-wide common CSS document,

01:01:37.810 --> 01:01:42.270
CSS being cascading style sheets,
which fortunately browsers seem

01:01:42.310 --> 01:01:46.160
to support though inconsistently,
is another great way to both

01:01:46.160 --> 01:01:49.360
reduce the content size,
speed up the rendering time,

01:01:49.360 --> 01:01:50.740
and make your site more flexible.

01:01:53.730 --> 01:01:56.040
So there's also optimizing Direct2.

01:01:56.040 --> 01:02:00.260
The Direct2 stack is incredibly powerful.

01:02:00.260 --> 01:02:04.430
The whole notion of having rule-based
content generation and data management

01:02:04.430 --> 01:02:08.220
and navigation management and user
management and everything else.

01:02:08.220 --> 01:02:10.730
I don't know of any other tool
out there that compares with

01:02:10.730 --> 01:02:12.380
WebObjects when it comes to this.

01:02:12.380 --> 01:02:15.460
But it is also overhead,
and there's a different

01:02:15.460 --> 01:02:17.350
approach to optimizing it.

01:02:17.460 --> 01:02:21.670
And Max can certainly answer
any questions in this regard.

01:02:23.700 --> 01:02:26.970
So in the context of Direct2,
the rules engine,

01:02:26.970 --> 01:02:30.840
it has this notion of significant
keys and unbounded keys.

01:02:30.840 --> 01:02:34.540
Significant keys are the ones
that are the focal points and

01:02:34.590 --> 01:02:37.440
then the ones that will be cached,
etc.

01:02:37.440 --> 01:02:40.380
The unbound keys are the ones that
will require calculation and a lot of

01:02:40.410 --> 01:02:43.600
faulting through the rule system to
figure out the values of those things.

01:02:43.600 --> 01:02:44.700
That's very expensive.

01:02:44.700 --> 01:02:46.040
So you want to avoid that.

01:02:46.200 --> 01:02:50.540
You also want to optimize the
data being accessed by property

01:02:50.540 --> 01:02:52.880
keys to a given task or page.

01:02:53.700 --> 01:02:57.110
So WebObjects,
the Direct2 stack has this very

01:02:57.110 --> 01:03:01.040
strong notion that the user
is doing something somewhere.

01:03:01.040 --> 01:03:04.210
And you can optimize all of your
data access around that notion.

01:03:04.210 --> 01:03:07.930
It gives you a lot of hints about what
the user is doing at any given time.

01:03:07.930 --> 01:03:12.680
There's a number of debugging hooks,
both in EO and Direct2 and

01:03:12.680 --> 01:03:16.650
also down at the lower layers,
and a lot of which you can

01:03:16.650 --> 01:03:18.760
find in Project Wonder.

01:03:18.760 --> 01:03:23.680
And there's warm-up techniques
you can do to cause the rule.

01:03:23.700 --> 01:03:28.420
So the rule caching system to warm up its
state such that subsequent evaluations of

01:03:28.420 --> 01:03:31.040
those rules will be much more efficient.

01:03:31.040 --> 01:03:34.920
Like one of the most common complaints
we see about Direct2 Web or Direct2

01:03:34.920 --> 01:03:38.280
Java client is the first hit always
takes a long time because it goes

01:03:38.280 --> 01:03:41.510
off and the rule cache is empty and
it has to go off and evaluate all

01:03:41.520 --> 01:03:43.420
these rules to fill the rule cache.

01:03:43.420 --> 01:03:46.130
Well, the rule cache,
most of it is actually

01:03:46.140 --> 01:03:48.020
going to be static results.

01:03:48.020 --> 01:03:50.770
So there's like entire huge sets
of rules that just never need to

01:03:50.770 --> 01:03:53.680
be evaluated again because the
results are going to be static.

01:03:53.680 --> 01:03:55.420
And the results never change.

01:03:55.420 --> 01:03:59.070
And so you don't want your first
user to have to pay that penalty.

01:03:59.380 --> 01:04:02.170
And when you're building
custom components,

01:04:02.170 --> 01:04:05.720
and this is true of both
DirectTo as well as everything else,

01:04:05.720 --> 01:04:06.720
go for stateless.

01:04:06.720 --> 01:04:10.000
Stateless means that there's
no session-specific data.

01:04:10.000 --> 01:04:12.140
It means the component can
be shared across the app.

01:04:12.270 --> 01:04:16.090
It doesn't have to be archived
and unarchived and reconstituted

01:04:16.090 --> 01:04:17.880
during request response.

01:04:17.920 --> 01:04:19.820
It's just a lot more efficient.

01:04:22.220 --> 01:04:25.920
Then, also, you've got to look beyond the
WebObjects application itself.

01:04:25.920 --> 01:04:29.600
Make sure your web server is
doing its share of the work.

01:04:29.600 --> 01:04:31.820
And that means tuning the configuration.

01:04:31.820 --> 01:04:34.520
Like, Apache has a mod status
and one other module,

01:04:34.600 --> 01:04:36.860
which I can't remember
the name of anyway,

01:04:36.860 --> 01:04:39.850
that out of the box can give
you a lot of information about

01:04:39.850 --> 01:04:41.820
what your web server is doing.

01:04:43.340 --> 01:04:45.860
Plus, look to your web server,
especially as your site grows.

01:04:45.860 --> 01:04:48.790
You'll want to look to your web
server to be able to farm out

01:04:48.850 --> 01:04:52.850
content across multiple web servers,
multiple boxes, and even up to the

01:04:53.000 --> 01:04:56.030
level of farming out to,
say, an Akamai or the other

01:04:56.120 --> 01:04:57.660
content aggregators.

01:04:57.660 --> 01:05:01.380
Because, of course, once you do that,
then any hit that doesn't hit your

01:05:01.380 --> 01:05:04.960
web server is more CPU cycles for
the primary content generation.

01:05:06.420 --> 01:05:09.150
Offloading all serving
of the content you can,

01:05:09.150 --> 01:05:12.290
like images, files,
multimedia to other servers,

01:05:12.290 --> 01:05:13.100
is a great thing.

01:05:13.100 --> 01:05:16.740
One of the challenges is always
if you have a site that's secure,

01:05:16.740 --> 01:05:20.930
as soon as you go into the HTTPS,
then that means all the

01:05:20.930 --> 01:05:24.460
images that are on that page
have to be encrypted as well,

01:05:24.460 --> 01:05:29.860
because web browsers don't like mixing
encrypted and unencrypted content.

01:05:29.860 --> 01:05:34.150
This gets back to security being the
antithesis of efficiency and convenience.

01:05:35.040 --> 01:05:37.590
So that makes for quite the adventure,
because now you're going to have

01:05:37.590 --> 01:05:40.040
to figure out how to pay the
price of encrypting the content

01:05:40.040 --> 01:05:42.830
that's related to that page,
including the static content.

01:05:42.840 --> 01:05:47.880
And of course,
encrypted downloads is a really bad idea.

01:05:47.880 --> 01:05:51.600
Nothing like encrypting, say,
45 megabyte download for one user,

01:05:51.600 --> 01:05:54.750
because everything has to be
encrypted per individual user.

01:05:54.760 --> 01:05:57.560
Caching proxy servers.

01:05:57.560 --> 01:05:59.300
This is a really neat technology.

01:05:59.300 --> 01:06:02.920
You can use something like Squid or
the caching proxy server in Apache,

01:06:03.820 --> 01:06:06.540
and the first user that hits
your site will pay the price

01:06:06.540 --> 01:06:09.860
of the dynamic generation,
but then that HTML page gets stuck

01:06:09.920 --> 01:06:13.780
in a caching proxy server that's in
between the web server front line

01:06:13.780 --> 01:06:15.070
and your WebOptics application.

01:06:15.190 --> 01:06:18.680
Once that item is in there,
you can then put timeouts on it,

01:06:18.680 --> 01:06:21.720
or you could have an external
interface for invalidating it,

01:06:21.750 --> 01:06:26.080
or the easiest thing to do is to
just simply have a dynamic page,

01:06:26.120 --> 01:06:29.640
which has the set of URLs that
lead to what will be cached,

01:06:29.640 --> 01:06:32.390
and just change those
URLs once it's invalidated.

01:06:32.520 --> 01:06:36.240
And that way, since it's an URL that
hasn't been cached yet,

01:06:36.310 --> 01:06:38.660
the caching proxy server will go, "Oh,
I got to go get it.

01:06:38.680 --> 01:06:39.320
Go get it.

01:06:39.470 --> 01:06:39.830
Cache it.

01:06:39.950 --> 01:06:42.550
Next user will be really fast."

01:06:43.900 --> 01:08:04.100
[Transcript missing]

01:08:04.240 --> 01:08:08.440
There's also tuning the adapter
timeout values and making sure

01:08:08.440 --> 01:08:12.400
your wool worker threads settings
are all set up correctly.

01:08:12.400 --> 01:08:18.590
Because as is the case with most things,
the generic out-of-the-box configuration

01:08:18.610 --> 01:08:22.100
is pretty much guaranteed to
be wrong for your application.

01:08:22.100 --> 01:08:24.760
This is also why WebObjects
doesn't do synchronization

01:08:24.770 --> 01:08:26.320
of data between instances.

01:08:26.320 --> 01:08:29.860
We could do a generic solution for that,
but it would be guaranteed that

01:08:29.860 --> 01:08:33.090
it would be inefficient for
your specific business problem.

01:08:36.110 --> 01:08:39.530
And you also want to determine
ahead of time how you're going to

01:08:39.530 --> 01:08:41.100
monitor the system for problems.

01:08:41.100 --> 01:08:43.330
I mean, every component in the system.

01:08:43.330 --> 01:08:46.210
As you add more machines,
as you add more complexities,

01:08:46.240 --> 01:08:49.720
you add firewalls and everything,
these things need to be monitored.

01:08:49.720 --> 01:08:53.430
And you need to plan
ahead for a catastrophe.

01:08:53.450 --> 01:08:56.070
And Max has got some
great anecdotes on that,

01:08:56.070 --> 01:08:56.800
I'm sure.

01:08:56.800 --> 01:09:04.020
And I'm going to turn it over to Max now
to talk about this particularly fun,

01:09:04.020 --> 01:09:05.440
fun issue.

01:09:05.720 --> 01:09:09.300
Yeah, so we just wanted to finish up with
the production quality deadlocks,

01:09:09.300 --> 01:09:11.590
which any of you who have
been in high traffic sites,

01:09:11.590 --> 01:09:14.330
it's always one of those things
that if you've got something,

01:09:14.330 --> 01:09:16.670
if you've got a recipe in it,
it's definitely going to

01:09:16.670 --> 01:09:18.580
get baked in production,
and you're going to

01:09:18.650 --> 01:09:20.070
find it in production.

01:09:20.070 --> 01:09:21.420
So just a few topics.

01:09:21.550 --> 01:09:25.140
One is that kill minus quit, you know,
within the Java world,

01:09:25.140 --> 01:09:28.100
that'll basically be full
stack traces to every,

01:09:28.100 --> 01:09:31.120
for the running app,
for all the different threads

01:09:31.290 --> 01:09:33.220
that are currently running.

01:09:41.570 --> 01:09:41.570
One of the most common places of is,
you know,

01:09:42.040 --> 01:09:45.770
- Is having initialization things that
are happening in your dispatch request,

01:09:45.770 --> 01:09:48.440
'cause dispatch request
is completely threaded,

01:09:48.510 --> 01:09:52.530
or is, will have multiple threads coming
through there at any given point.

01:09:52.570 --> 01:09:55.940
So even if you have your app set
in kind of single threaded mode,

01:09:56.040 --> 01:09:59.420
it's not doing concurrent requests,
your dispatch request has to be threaded.

01:09:59.530 --> 01:10:03.040
Likewise, any of the code in there,
if it's, if you have one method there,

01:10:03.040 --> 01:10:05.840
it's like, oh, let me go out,
fetch something from an editing context,

01:10:05.870 --> 01:10:09.880
cache that value, and then,
and that value will then be used

01:10:09.880 --> 01:10:12.000
for any request that comes in.

01:10:12.000 --> 01:10:16.140
You can guarantee that when you start,
you're gonna have two threads

01:10:16.140 --> 01:10:18.970
that are immediately gonna get in
there and start doing EOF stuff,

01:10:19.070 --> 01:10:20.590
which is, yeah.

01:10:20.820 --> 01:10:23.060
- Which you will run into
serious problems with.

01:10:23.060 --> 01:10:26.990
Most of the deadlocks we have to
track down are because of EOF,

01:10:26.990 --> 01:10:28.880
or we're not locking things correctly.

01:10:28.900 --> 01:10:32.040
Or the multiple EOF stacks in a
single shared editing context.

01:10:32.040 --> 01:10:34.040
That one will kill you every single time.

01:10:34.040 --> 01:10:37.860
So you have to,
if you want to use those full-blown

01:10:37.860 --> 01:10:40.780
EOs in multiple different EOF stacks,
you definitely have to create new

01:10:40.780 --> 01:10:44.200
shared editing contexts for each one
of the stacks that you want to use.

01:10:44.430 --> 01:10:46.360
If you, by default,
if you don't do anything,

01:10:46.360 --> 01:10:50.500
just new object store coordinator,
new EO editing context, fetch an EO,

01:10:50.510 --> 01:10:52.400
then you're gonna be dead in the water.

01:10:52.400 --> 01:10:57.700
So the monitoring to
detect wedged instances,

01:10:57.700 --> 01:11:02.200
that's a big one if you
are having this problem.

01:11:02.390 --> 01:11:05.310
And also, it's very important to start
your load testing before

01:11:05.310 --> 01:11:07.760
you start your applications.

01:11:07.810 --> 01:11:10.320
'Cause a lot of the times,
we ran into several issues

01:11:10.320 --> 01:11:13.470
where we didn't detect a certain
deadlock condition because we had

01:11:13.470 --> 01:11:15.940
all of our apps up and running,
and then we're like, all right,

01:11:15.940 --> 01:11:17.220
now turn on the load test.

01:11:17.250 --> 01:11:19.010
Whereas if we would've
had the load testing up,

01:11:19.030 --> 01:11:21.450
which is what you have in
production if you bounce your apps,

01:11:21.460 --> 01:11:23.860
'cause you constantly have users
in there clicking on everything,

01:11:23.880 --> 01:11:27.300
and then the app has some initialization
deadlock and it starts up and it's like,

01:11:27.300 --> 01:11:29.700
ugh, and it's wedged.

01:11:30.000 --> 01:11:35.100
And the dead time interval in
the adapters can be a killer.

01:11:35.100 --> 01:11:39.060
'Cause if you, 'cause if that interval,
that basically says how

01:11:39.060 --> 01:11:41.450
long should we wait for,
if we try an instance and

01:11:41.480 --> 01:11:44.240
it doesn't respond back,
how long should we wait

01:11:44.240 --> 01:11:45.640
until we try it again?

01:11:45.780 --> 01:11:48.640
And so you can get this nice
ripple effect where the wave will

01:11:48.640 --> 01:11:51.170
crash down and all your apps will
basically register themselves

01:11:51.200 --> 01:11:53.320
as dead if they're starting up.

01:11:53.400 --> 01:11:58.080
And so then it will basically
wedge all your web servers.

01:11:58.110 --> 01:12:00.300
And then your web servers
will finally come back,

01:12:00.300 --> 01:12:02.200
your apps will be like, now we're ready.

01:12:02.200 --> 01:12:04.000
And then the web servers will go, well,
here you go.

01:12:04.040 --> 01:12:06.800
And the wave will come sweeping
over and the apps are like,

01:12:06.800 --> 01:12:08.330
no, no, no, no, no more, no more.

01:12:08.390 --> 01:12:10.300
And so they'll wedge and
the dead timeouts will set.

01:12:10.300 --> 01:12:12.590
And so you get this nice seesaw
effect where all of a sudden

01:12:12.600 --> 01:12:14.540
things will be really fast and
things will be really slow.

01:12:14.560 --> 01:12:16.080
Really fast and really slow.

01:12:16.220 --> 01:12:19.600
So that's a, yeah,
so it was just one last slide.

01:12:19.600 --> 01:12:22.010
of these things.

01:12:24.020 --> 01:12:30.880
So, users are funny because
they pay your bills,

01:12:30.880 --> 01:12:31.640
but they hate you.

01:12:31.640 --> 01:12:34.180
Because as soon as your
app starts misbehaving,

01:12:34.180 --> 01:12:35.260
how do they respond?

01:12:35.260 --> 01:12:37.730
By clicking like spastic monkeys.

01:12:41.700 --> 01:12:42.700
Fun.

01:12:42.700 --> 01:12:44.990
So, you know, quick summary here.

01:12:44.990 --> 01:12:47.740
So start thinking fast
from the beginning,

01:12:47.740 --> 01:12:50.220
but don't overdo it.

01:12:50.350 --> 01:12:53.440
I mean, you want an instrument,
you want to analyze, you want to track,

01:12:53.440 --> 01:12:55.390
you want to track your
performance over time,

01:12:55.490 --> 01:12:57.300
but invariably you want to stay calm.

01:12:57.320 --> 01:13:00.800
And that's like a point that just, again,
stay calm.

01:13:00.900 --> 01:13:03.570
Because when things start going wrong,
the worst thing you can

01:13:03.570 --> 01:13:04.900
do is to start just,
you know,

01:13:04.900 --> 01:13:08.090
throw your hands up in the air and
start rebooting things at random without

01:13:08.090 --> 01:13:11.630
understanding the problem or getting
your analysis tools up and running.

01:13:11.710 --> 01:13:15.160
Or gathering metrics or gathering
evidence because simply,

01:13:15.160 --> 01:13:18.740
you know, doing the spastic monkey
routine on the reboot button

01:13:18.740 --> 01:13:20.460
is not going to fix anything.

01:13:20.460 --> 01:13:23.800
It's just going to make it
happen again sometime later.

01:13:25.240 --> 01:13:28.560
There's a tremendous
wealth of tools available.

01:13:28.560 --> 01:13:31.800
It's easy to forget exactly
how much stuff is out there,

01:13:31.800 --> 01:13:35.360
but the industry as a whole has
been doing web-based deployments

01:13:35.360 --> 01:13:38.510
now for more than a decade,
and web application

01:13:38.510 --> 01:13:41.400
deployments now for a decade,
too.

01:13:41.400 --> 01:13:46.550
So there's just a boatload of free
and commercial products out there to

01:13:46.550 --> 01:13:52.340
do a lot of management and analysis,
some of which are better than others.

01:13:54.330 --> 01:13:56.420
Always be aware of that
security implication.

01:13:56.420 --> 01:13:59.750
There's a lot of really obvious
optimizations that one can

01:13:59.750 --> 01:14:03.250
perform on a site that will
make it completely insecure.

01:14:03.260 --> 01:14:07.880
Like the direct actions thing
is one to watch out for.

01:14:07.880 --> 01:14:09.540
You've got these direct actions in place.

01:14:09.540 --> 01:14:11.880
If you carry too much state in that URL,
or the URLs,

01:14:11.880 --> 01:14:15.160
like there was one case where someone
decided to separate their shopping

01:14:15.160 --> 01:14:18.070
cart out from their main application,
and when they put the

01:14:18.070 --> 01:14:20.930
product in the shopping cart,
they put the price in the URL,

01:14:20.930 --> 01:14:22.060
and they believed it.

01:14:23.440 --> 01:14:26.060
Yeah, that wasn't good.

01:14:27.550 --> 01:14:31.050
Having done this for so long,
all of us having done this for so long,

01:14:31.050 --> 01:14:34.220
there's a tremendous number
of community resources.

01:14:34.220 --> 01:14:37.320
There's Google,
there's the Apple and the Omni list,

01:14:37.320 --> 01:14:39.640
there's again Google,
which searches a lot of those

01:14:39.640 --> 01:14:41.580
lists and indexes everything else.

01:14:41.580 --> 01:14:45.480
There's Project Wonder and other random
community projects that are out there,

01:14:45.480 --> 01:14:49.220
including a wealth of various random
free Java projects that you can leverage.

01:14:49.220 --> 01:14:51.160
And finally, again, Google.

01:14:52.200 --> 01:14:55.460
If you get an error message
that's coming back from something,

01:14:55.460 --> 01:14:59.340
almost always you can put that error
message into quote marks in Google,

01:14:59.340 --> 01:15:03.280
hit return, and find 10 other people that
are experiencing the same thing,

01:15:03.300 --> 01:15:04.860
one of which might have the answer.

01:15:06.270 --> 01:15:11.080
So with that, for more information,
that should have just said Google.

01:15:11.080 --> 01:15:14.980
There's sources of
documentation and sample code.

01:15:14.980 --> 01:15:16.620
The documentation has been updated.

01:15:16.620 --> 01:15:18.600
I was reminded of one other thing.

01:15:18.600 --> 01:15:21.330
As far as performance
analysis is concerned,

01:15:21.330 --> 01:15:24.050
Shark and the Chud tools
now do Java as well.

01:15:24.050 --> 01:15:25.620
That works with WebObjects.
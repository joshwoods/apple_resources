WEBVTT

00:00:17.530 --> 00:00:20.700
Good morning.

00:00:20.830 --> 00:00:23.900
So I am here-- I'm, of course,
here to talk about programming

00:00:23.900 --> 00:00:27.000
for the Mac OS X 64-bit API,
or more correctly,

00:00:27.000 --> 00:00:29.120
to talk a little bit about
Apple's direction with

00:00:29.190 --> 00:00:32.990
respect to 64-bit computing,
and then hand things over to

00:00:33.080 --> 00:00:35.740
our esteemed engineering team,
who is going to give us a

00:00:35.740 --> 00:00:37.620
lot more detail about this.

00:00:37.960 --> 00:00:41.020
First things first, why 64-bit?

00:00:41.100 --> 00:00:43.860
I think the key thing that we
see is access to more memory

00:00:44.030 --> 00:00:45.540
than you can imagine for now.

00:00:45.550 --> 00:00:47.080
That's always an embarrassing remark,
of course.

00:00:47.110 --> 00:00:49.930
640K used to be more memory
than some people could imagine,

00:00:49.950 --> 00:00:52.970
and 16 exabytes may seem
like that someday as well.

00:00:53.090 --> 00:00:56.900
I hope I'm not introducing
the 128-bit API session.

00:00:56.900 --> 00:00:59.900
But we do see a number
of reasons for this.

00:00:59.900 --> 00:01:01.990
In some cases,
you're going to see increased

00:01:02.100 --> 00:01:03.900
performance for memory-intensive tasks.

00:01:03.900 --> 00:01:06.530
Now,
I will say that all other things equal,

00:01:06.590 --> 00:01:08.630
your programs are likely
going to run slow in 64-bit,

00:01:08.630 --> 00:01:10.820
but all other things are
not always equal here.

00:01:10.920 --> 00:01:13.900
One of the great things is that you have
access to a lot more physical memory,

00:01:13.900 --> 00:01:16.250
a lot more virtual memory,
and we think there are

00:01:16.250 --> 00:01:16.900
some benefits of that.

00:01:16.900 --> 00:01:19.160
And obviously,
one of those is that physical memory

00:01:19.200 --> 00:01:20.900
is considerably faster than disk.

00:01:20.900 --> 00:01:24.080
I think the other one is that you can
be lazier programmers in some instances,

00:01:24.170 --> 00:01:27.170
because it's going to be a lot
easier to access this large

00:01:27.170 --> 00:01:29.290
amount of memory on the system.

00:01:32.690 --> 00:01:35.640
Our 64-bit goals are quite simple.

00:01:35.640 --> 00:01:39.470
We want to provide the key
benefits of 64-bit computing for

00:01:39.470 --> 00:01:42.960
the people who need it the most,
while making sure that we actually

00:01:42.960 --> 00:01:46.600
don't break any of these 12,000 native
applications that we have today.

00:01:46.600 --> 00:01:48.600
And we talk a lot about
this internally as a goal.

00:01:48.600 --> 00:01:51.160
We want to make sure that people
in scientific computing and high

00:01:51.160 --> 00:01:55.600
performance computing and media have
access to these benefits of 64-bit.

00:01:55.770 --> 00:01:59.250
But we don't want educational software
vendors with very simple titles for

00:01:59.250 --> 00:02:02.330
children to have to actually redo
everything because we've decided

00:02:02.330 --> 00:02:03.600
to move into the 64-bit world.

00:02:03.600 --> 00:02:06.490
So our objective is one that
really stresses compatibility

00:02:06.490 --> 00:02:09.580
and performance for the native
applications on the system.

00:02:09.600 --> 00:02:11.500
And 64-bit is an addition.

00:02:11.500 --> 00:02:14.010
And you'll hear more today
about why we're able to do that

00:02:14.010 --> 00:02:17.250
in our 64-bit architecture,
but I think it's a unique advantage

00:02:17.250 --> 00:02:18.600
that Apple has with Mac OS X.

00:02:18.600 --> 00:02:22.530
We started the 64-bit
journey already with Panther.

00:02:22.600 --> 00:02:25.600
We had actually system access.

00:02:25.600 --> 00:02:29.530
We had access to greater than 4 gigabytes
of physical memory in a machine.

00:02:29.600 --> 00:02:32.600
But all of the applications that
you could write were 32-bit.

00:02:32.600 --> 00:02:34.590
All of the user tasks were 32-bit.

00:02:34.660 --> 00:02:37.600
And that's the address
space you had as developers.

00:02:37.770 --> 00:02:40.510
All applications, however,
could in Panther actually use

00:02:40.600 --> 00:02:42.600
64-bit hardware math functions.

00:02:42.600 --> 00:02:44.600
There were 64-bit registers.

00:02:44.600 --> 00:02:48.630
You did have to recompile your binaries
to actually take specific advantage

00:02:48.630 --> 00:02:52.600
of the PowerPC G5 architecture,
but those were features you could get.

00:02:52.600 --> 00:02:54.450
And once again,
this is something that distinguishes

00:02:54.520 --> 00:02:54.600
Apple's 64-bit architecture
from other applications.

00:02:54.600 --> 00:02:55.600
So we're going to talk
about that in a little bit.

00:02:55.600 --> 00:02:58.540
But the 64-bit story from some
of the other platforms is that

00:02:58.590 --> 00:03:01.140
many of the performance benefits
of 64-bit computing are actually

00:03:01.140 --> 00:03:05.900
available to 32-bit applications
today on Mac OS X if you're going to

00:03:05.900 --> 00:03:10.480
bother to actually do the recompile
and optimization for PowerPC G5.

00:03:10.620 --> 00:03:12.490
But with Tiger, we actually want to take
it to another level,

00:03:12.610 --> 00:03:16.600
and we're actually adding 64-bit
addressing for user tasks.

00:03:16.700 --> 00:03:21.240
We're going to focus our 64-bit support
initially on the applications that we

00:03:21.330 --> 00:03:24.570
think are most likely and most urgently
need to benefit from 64-bit addressing.

00:03:24.700 --> 00:03:27.850
And so we think these are going
to be scientific applications,

00:03:27.900 --> 00:03:31.600
rendering and computational engines,
and server applications.

00:03:31.600 --> 00:03:35.020
And the infrastructure we're
providing to do that is actually

00:03:35.020 --> 00:03:39.580
based on a 64-bit lib system and
64-bit capabilities in the compiler.

00:03:39.600 --> 00:03:41.480
So that actually concludes,
briefly and mercifully,

00:03:41.510 --> 00:03:43.600
the marketing portion of
this morning's presentation.

00:03:43.600 --> 00:03:46.110
And I'm actually very pleased to
hand this over to Nick Kledzik,

00:03:46.110 --> 00:03:48.600
who's going to talk more
about 64-bit architecture.

00:03:48.600 --> 00:03:49.600
Thanks, Nick.

00:03:55.010 --> 00:03:55.820
Thank you, Wiley.

00:03:56.040 --> 00:03:59.480
One of the things Wiley mentioned
was that 64-bit computation

00:03:59.480 --> 00:04:02.780
was already available to 32-bit
applications on Panther today.

00:04:02.790 --> 00:04:06.160
And I want to start off by going
into detail on what that means.

00:04:06.420 --> 00:04:09.090
When you think about 32-bit,
64-bit computing,

00:04:09.390 --> 00:04:11.300
there are actually four aspects of that.

00:04:11.410 --> 00:04:14.180
So the first is you need a
processor with 64-bit registers.

00:04:14.310 --> 00:04:16.140
The second,
you need to be able to actually load

00:04:16.160 --> 00:04:20.560
and store the 64-bit registers to
main memory in single instructions.

00:04:20.640 --> 00:04:25.060
Next, you need a 64-bit ALU,
which is the computation unit of the CPU,

00:04:25.160 --> 00:04:28.370
so that you can do 64-bit
multipliers and shifts and so forth.

00:04:28.430 --> 00:04:30.420
And lastly,
if you happen to use one of those

00:04:30.500 --> 00:04:33.420
64-bit registers to access memory,
that you actually,

00:04:33.420 --> 00:04:36.030
the kernel has set up a
64-bit address space for you.

00:04:36.330 --> 00:04:40.540
Now, the first three of those four points
are already available in Panther today.

00:04:40.660 --> 00:04:45.940
You can take your 32-bit app and take
advantage of the full 64-bit registers.

00:04:46.030 --> 00:04:49.640
You can do 64-bit loads and stores in
the app to make them a little bit faster.

00:04:49.710 --> 00:04:51.880
And you can take advantage
of the 64-bit ALU.

00:04:51.880 --> 00:04:57.320
If your application happens to be
64-bit integer computation intensive,

00:04:57.380 --> 00:05:00.180
you can do all those things but
not have 64-bit address space

00:05:00.230 --> 00:05:02.010
and get a performance boost.

00:05:02.080 --> 00:05:04.530
Another way of looking at this
is all we're introducing in

00:05:04.550 --> 00:05:06.220
Tiger is 64-bit address spaces.

00:05:06.220 --> 00:05:06.460
Thank you.

00:05:09.230 --> 00:05:13.390
So next I'd like to talk a bit
about how 64-bit was implemented in

00:05:13.390 --> 00:05:17.040
PowerPC because it is a lot different
than how some other microprocessors

00:05:17.160 --> 00:05:21.830
have added 64-bitness to their line.

00:05:22.200 --> 00:05:26.510
PowerPC is kind of unique in that
PowerPC started out as a 64-bit

00:05:26.510 --> 00:05:30.440
architecture way over 15 years ago,
whenever it started.

00:05:30.480 --> 00:05:34.510
Only now we've finally seen the
fruition of the full 64-bitness.

00:05:35.210 --> 00:05:37.910
Another interesting thing about
it is that there is no mode.

00:05:38.160 --> 00:05:41.180
Some other processors,
you have a 32-bit mode and a 64-bit mode.

00:05:41.180 --> 00:05:43.340
And when you're in those different modes,
you have different sensor registers

00:05:43.340 --> 00:05:44.610
and different sensors of instructions.

00:05:44.660 --> 00:05:47.410
It's almost as if it's two
processors merged into one,

00:05:47.440 --> 00:05:50.250
and there's some big switch
as to which way you're doing.

00:05:50.350 --> 00:05:53.320
One of the downfalls of that
is that in the implementation

00:05:53.540 --> 00:05:56.120
of a process that model,
the implementers have to make

00:05:56.130 --> 00:05:58.740
the decision of how to microcode
each of those instructions.

00:05:58.740 --> 00:06:01.850
And they tend to make the 64-bit
one faster and the 32-bit one

00:06:01.960 --> 00:06:03.420
at the cost of the 32-bit.

00:06:03.540 --> 00:06:05.140
PowerPC does not have that problem.

00:06:05.250 --> 00:06:09.690
There is no mode on
PowerPC between 64-bit and 32-bit.

00:06:09.800 --> 00:06:14.770
It is completely a software convention,
whether you're doing 64-bit or 32-bit.

00:06:14.840 --> 00:06:17.460
And I want to go into some more details
on this because once you get this,

00:06:17.510 --> 00:06:20.650
the rest of the 64-bit talk and
how Apple is rolling out 64-bits

00:06:20.710 --> 00:06:22.840
will make a lot more sense.

00:06:23.990 --> 00:06:25.970
If you played around the
PowerPC instruction set,

00:06:25.980 --> 00:06:27.620
you'll know that this
being a risk processor,

00:06:27.640 --> 00:06:30.140
that there's basically two
categories of instructions.

00:06:30.310 --> 00:06:33.180
There's load and store
instructions and everything else.

00:06:33.310 --> 00:06:35.730
Now, load and store instructions
simply are the only instructions

00:06:35.730 --> 00:06:36.870
that can access main memory.

00:06:37.020 --> 00:06:39.820
All they do is move between
memory and registers.

00:06:39.980 --> 00:06:42.850
All other instructions
operate with registers.

00:06:42.860 --> 00:06:46.810
For instance,
add R3 to R4 and store it back in R3.

00:06:47.070 --> 00:06:49.640
If you look at those instructions
and what they do with registers,

00:06:49.690 --> 00:06:53.060
you notice there's no size
designation on those instructions.

00:06:53.060 --> 00:06:54.610
There's no add byte or add word.

00:06:54.640 --> 00:06:59.670
There's simply the add instruction,
which works on the entire register.

00:07:00.810 --> 00:07:04.000
So how that works is,
say you want to do 32-bit math

00:07:04.330 --> 00:07:06.970
or you are a 32-bit program.

00:07:07.060 --> 00:07:09.760
You only ever load the
32 bits of the register.

00:07:09.990 --> 00:07:12.410
You do your addition or whatever,
and you only ever look at the

00:07:12.510 --> 00:07:14.860
low 32 bits as the result.

00:07:15.210 --> 00:07:20.660
What that allows you to do is
that a program written to 32-bit

00:07:20.660 --> 00:07:25.740
conventions has no concept of whether
or not there's actually higher bits.

00:07:25.800 --> 00:07:27.630
What this means is when
the PowerPC came out,

00:07:27.700 --> 00:07:31.320
even though it was a 64-bit architecture,
the original silicon only supported

00:07:31.320 --> 00:07:33.440
the low 32 bits of registers.

00:07:33.490 --> 00:07:36.260
All the software written only
looked at the 32-bit registers,

00:07:36.410 --> 00:07:38.740
the low 32 bits,
because that's all there was.

00:07:38.790 --> 00:07:40.010
But they followed that convention.

00:07:40.180 --> 00:07:41.720
When the D5 came out,
there happened to be

00:07:41.720 --> 00:07:43.890
more bits of it there.

00:07:44.910 --> 00:07:46.520
The programs only load the low 32 bits.

00:07:46.560 --> 00:07:48.520
It doesn't really matter
what's in the high bits.

00:07:48.520 --> 00:07:49.600
They can be completely garbage.

00:07:49.600 --> 00:07:52.410
They still do the same add instruction,
and the result,

00:07:52.480 --> 00:07:54.520
they only look at the low 32 bits.

00:07:54.810 --> 00:07:59.820
So what this means is there
is no mode with PowerPC.

00:07:59.840 --> 00:08:04.500
It's only conventions that distinguish
64-bit from 32-bit processes.

00:08:04.520 --> 00:08:07.680
Another way of looking at this is
that there's no performance penalty

00:08:08.390 --> 00:08:10.720
for running as a 32-bit process.

00:08:10.720 --> 00:08:12.640
In fact, as we'll learn later,
there's a slight performance

00:08:12.770 --> 00:08:14.980
gain for running as a 32-bit.

00:08:15.910 --> 00:08:18.440
Now, those of you who have done assembly
programming also know that there's

00:08:18.450 --> 00:08:20.300
something called condition codes.

00:08:20.300 --> 00:08:24.240
So you've got this mental model
of how you can run within 32-bit

00:08:24.240 --> 00:08:27.000
conventions on 64-bit processor.

00:08:27.220 --> 00:08:31.480
But you may ask, "Well,
how are the condition codes set?" Now,

00:08:31.480 --> 00:08:34.600
condition codes are things like
the carry bit and the zero bit.

00:08:34.770 --> 00:08:36.790
They are set as a side
effect of some instructions.

00:08:36.800 --> 00:08:37.790
So you do the add.

00:08:37.800 --> 00:08:40.100
If there was a carry out from the add,
the carry bit will be set.

00:08:40.100 --> 00:08:42.900
Or if you do an add and
the result was zero,

00:08:42.900 --> 00:08:44.300
the z-bit is set.

00:08:44.540 --> 00:08:47.790
There is one tiny bit of
modiness in the PowerPC.

00:08:48.430 --> 00:08:51.240
And that is,
there's a mode of how the condition codes

00:08:51.240 --> 00:08:54.610
are set as a result of an instruction,
whether the processor looks at the

00:08:54.610 --> 00:08:57.720
full 64-bits or the low 32-bits.

00:08:57.850 --> 00:09:02.370
So when the kernel starts a process,
it looks at the code in the process

00:09:02.380 --> 00:09:05.230
and basically a flag on the header
and decides whether this piece

00:09:05.280 --> 00:09:09.620
of PowerPC code is using 30-bit
conventions or 64-bit conventions.

00:09:09.630 --> 00:09:13.000
If it's using 32-bit conventions,
it sets a little flag on the PowerPC.

00:09:13.000 --> 00:09:17.130
It says, when you set condition
codes for this thing,

00:09:17.240 --> 00:09:20.620
because it's using 32-bit conventions,
it's only looking at low 32-bits,

00:09:20.690 --> 00:09:23.980
so the condition code should only
look at the low 32-bits as well.

00:09:24.180 --> 00:09:28.380
The one other thing the kernel does
different when launching a 32-bit versus

00:09:28.480 --> 00:09:31.950
64-bit process is for a 32-bit process,
it also tells the MMU,

00:09:32.130 --> 00:09:35.210
the memory management unit,
to ignore the high 32-bit addresses

00:09:35.210 --> 00:09:38.980
because they're potentially garbage
and to only look at the low 32-bit.

00:09:39.110 --> 00:09:45.470
That gives a 32-bit process a
4-gig address space and a 64-bit

00:09:45.470 --> 00:09:45.470
process the full 16 exabytes.

00:09:48.380 --> 00:09:51.670
So what are some of the trade-offs
for compiling for 64-bits?

00:09:51.760 --> 00:09:53.820
Because now you have the choice
of whether to compile your same

00:09:53.820 --> 00:09:57.680
PowerPC instructions using 32-bit
conventions or 64-bit conventions.

00:09:57.710 --> 00:10:03.860
Well,
since we all know 32-bit conventions

00:10:04.300 --> 00:10:05.060
and what they mean today,
let's talk about the trade-offs

00:10:05.060 --> 00:10:05.060
of changing to 64-bit conventions.

00:10:06.520 --> 00:10:10.510
Well, there's the obvious advantage that
you now got a huge address space.

00:10:10.510 --> 00:10:14.010
And if you have lots of data
and you need that address space,

00:10:14.240 --> 00:10:16.800
then this is the advantage
you want to go for.

00:10:19.150 --> 00:10:24.370
Another advantage is if you
are using 64-bit computations,

00:10:24.480 --> 00:10:26.980
64-bit integer computations,
but you don't need the

00:10:26.980 --> 00:10:29.790
full address space,
one of the limitations of using

00:10:29.790 --> 00:10:37.590
the 32-bit calling conventions is
that none of the functions know

00:10:37.590 --> 00:10:37.590
about the high 32 bits of registers.

00:10:37.990 --> 00:10:41.730
What that means is when you compile
today and you tell our GCT compiler

00:10:41.750 --> 00:10:45.380
that you're building for the G5 and
you want to optimize for the G5,

00:10:45.700 --> 00:10:49.290
Whenever in any leaf function,
the compiler will basically make use of

00:10:49.290 --> 00:10:52.400
the full 64 bits within that function.

00:10:52.510 --> 00:10:55.480
The compiler cannot do that when
it crosses function boundaries.

00:10:55.680 --> 00:10:59.100
That is,
if a function calls another function,

00:10:59.430 --> 00:11:02.120
The compiler has to worry that function
may trash some upper bits of registers,

00:11:02.170 --> 00:11:07.000
so therefore it doesn't use 64-bit
conventions within that function.

00:11:07.000 --> 00:11:09.570
Now,
once you switch to 64-bit conventions,

00:11:09.570 --> 00:11:13.380
you know that it's safe to basically
use all bits of the registers.

00:11:13.460 --> 00:11:16.030
So there are a small
category of applications that

00:11:16.080 --> 00:11:18.580
don't need a lot of data,
don't need a large address space,

00:11:18.600 --> 00:11:21.410
but because they use a
lot of 64-bit arithmetic,

00:11:21.440 --> 00:11:24.290
can take advantage of
compiling for 64-bit mode.

00:11:25.040 --> 00:11:28.800
So what's the disadvantage
of compiling for 64-bit mode?

00:11:28.870 --> 00:11:32.420
As I said before, the instructions are
exactly the same on PowerPC,

00:11:32.430 --> 00:11:34.240
no matter which way you compile.

00:11:34.310 --> 00:11:37.330
But the difference is pointers
are bigger in 64 bits.

00:11:37.520 --> 00:11:39.510
They're 64 bits.

00:11:39.640 --> 00:11:42.770
But what that means is every
data structure you have that has

00:11:42.770 --> 00:11:44.620
a pointer in it is now bigger.

00:11:44.690 --> 00:11:47.890
Overall, that means the data in
the application is bigger.

00:11:48.020 --> 00:11:49.450
When the data in the
application is bigger,

00:11:49.530 --> 00:11:51.500
that means you need to
take up more address space,

00:11:51.570 --> 00:11:54.260
which means you need more pages
and RAM to run your process.

00:11:54.320 --> 00:11:56.050
On one hand,
you can put more RAM on the machine,

00:11:56.060 --> 00:11:57.460
that solves that problem.

00:11:57.530 --> 00:12:00.940
But there's also the L1 and
L2 caches in the processor.

00:12:01.000 --> 00:12:05.370
And they try to cache the most recently
used data from the entire address space.

00:12:05.480 --> 00:12:07.340
Well,
if your data set for your app is larger

00:12:07.340 --> 00:12:10.380
because your pointers are larger,
the chances of your data being

00:12:10.390 --> 00:12:12.080
in the cache is slightly less.

00:12:12.190 --> 00:12:16.220
So there will be a small decrease in
performance for compiling for 64 bits.

00:12:16.310 --> 00:12:18.820
So therefore,
it only makes sense to compile for 64

00:12:19.160 --> 00:12:22.550
bits if you actually find that you have,
you're running into limits

00:12:22.550 --> 00:12:23.620
of a 4-gig address space.

00:12:23.620 --> 00:12:24.120
Thanks.

00:12:25.870 --> 00:12:28.800
Another disadvantage is since
this is all conventions,

00:12:28.870 --> 00:12:31.580
is any libraries you depend
on also have to be available

00:12:31.770 --> 00:12:35.090
with the 64-bit conventions,
otherwise you can't call them.

00:12:35.110 --> 00:12:38.470
So you have to wait until everything
below you has been converted to

00:12:38.540 --> 00:12:40.200
64-bits before you can convert.

00:12:45.870 --> 00:12:47.870
Now that I've explained a
bit how the PowerPC works and

00:12:47.870 --> 00:12:51.410
how there's no 64-bit mode,
now I want to explain how we're

00:12:51.410 --> 00:12:53.600
going to actually roll out 64 bits.

00:12:54.540 --> 00:12:56.080
Let me explain what
we're not going to do.

00:12:56.260 --> 00:13:00.350
There is not going to be a 64-bit
Mac OS X and a 32-bit Mac OS X.

00:13:00.460 --> 00:13:03.390
There's only going to be Mac OS X.

00:13:03.500 --> 00:13:07.370
When you happen to run on a G5,
the kernel will recognize it and allow

00:13:08.290 --> 00:13:13.520
programs that are marked as using
64-bit conventions to be launched,

00:13:13.590 --> 00:13:16.730
and they'll be set up with
64-bit address spaces.

00:13:19.400 --> 00:13:22.940
For "Tiger," all Apple is committing
to at this point is that lib system

00:13:23.080 --> 00:13:25.220
will be available to 64-bit programs.

00:13:25.220 --> 00:13:29.080
Lib system is the standard C library
and most of the POSIX functionality,

00:13:29.080 --> 00:13:33.540
which means command line applications
and applications with no UI will be able

00:13:33.540 --> 00:13:37.060
to convert to 64 bits if they so choose.

00:13:37.060 --> 00:13:39.440
Over time,
Apple will be rolling out more libraries.

00:13:39.440 --> 00:13:41.540
And one of the things we want
to hear back from you is,

00:13:41.540 --> 00:13:43.000
what library should we do first?

00:13:43.010 --> 00:13:44.740
What are most important to you?

00:13:44.740 --> 00:13:48.290
You being the people first
converting to 64 bits.

00:13:50.140 --> 00:13:51.720
Now I want to go into
a little more detail.

00:13:51.720 --> 00:13:56.120
Now you've got the big picture of how
64-bit processing works with PowerPC.

00:13:56.180 --> 00:13:58.040
How we're actually
going to roll this out.

00:13:58.070 --> 00:14:00.960
The most interesting thing
is the last point here.

00:14:00.980 --> 00:14:03.110
We're going to have a single kernel.

00:14:03.570 --> 00:14:07.000
The single kernel is going
to be a 32-bit kernel.

00:14:07.030 --> 00:14:09.090
We can do this because of
the PowerPC architecture.

00:14:09.100 --> 00:14:10.290
It's just conventions.

00:14:10.380 --> 00:14:14.370
A 32-bit kernel can
launch a 64-bit process.

00:14:14.610 --> 00:14:17.280
The single kernel has
a number of advantages.

00:14:17.280 --> 00:14:19.310
First of all,
it means we can produce one disk

00:14:19.340 --> 00:14:21.570
that can boot on any machine.

00:14:22.020 --> 00:14:25.070
Second, it means all the existing kernel
extensions and device drivers

00:14:25.280 --> 00:14:28.870
that are all written to 32-bit
conventions will still run within it.

00:14:32.270 --> 00:14:36.070
Some of you may have heard
the term LP64 for data models.

00:14:36.120 --> 00:14:39.710
That is the convention that we
have chosen to adopt for 64-bit

00:14:39.940 --> 00:14:42.540
calling conventions on Mac OS X.

00:14:42.560 --> 00:14:44.960
Now, I want to go through a little
bit of history of where

00:14:44.970 --> 00:14:46.320
these acronyms came from.

00:14:46.350 --> 00:14:50.740
Let's go back in time to the early '90s
with the pioneers of 64-bit computing,

00:14:50.960 --> 00:14:52.550
or Cray and Alpha.

00:14:55.370 --> 00:14:57.250
Now once they got the hardware done,
they started looking at the

00:14:57.250 --> 00:14:59.830
C language and were like,
"Well, how big should an int

00:14:59.830 --> 00:15:02.590
and a long be?" Well,
they were gung-ho for 64-bit,

00:15:02.620 --> 00:15:04.450
so they said, "Well,
we're going to make an int and a long,

00:15:04.460 --> 00:15:07.130
all 64 bits, as well as pointers."

00:15:08.210 --> 00:15:10.000
I've actually had that rolled
out to more and more programmers,

00:15:10.000 --> 00:15:12.270
and more and more programmers
as they use that said,

00:15:12.330 --> 00:15:16.900
"Dang, this is hard to use,
because I've got this file format

00:15:16.900 --> 00:15:22.340
that has 32-bit values in it,
or I just got this network

00:15:22.880 --> 00:15:26.860
packet with 32-bit values in it.

00:15:26.860 --> 00:15:27.010
It's really hard to get to because
there's no 32-bit type in the

00:15:27.010 --> 00:15:27.010
C language." So when the next generation

00:15:28.650 --> 00:15:33.760
of 64-bit processors came out for Solaris
and SGI and eventually Linux and stuff.

00:15:33.760 --> 00:15:35.520
They all looked back at the
early pioneers and said,

00:15:35.530 --> 00:15:36.410
"We're not going to do that.

00:15:36.520 --> 00:15:41.260
We're going to use LP64." And LP64
longs and pointers are 64-bits,

00:15:41.420 --> 00:15:43.400
but integers remain 32-bits.

00:15:43.530 --> 00:15:48.410
Therefore, they have the base
types in C to have byte,

00:15:48.410 --> 00:15:54.960
short, I mean, 8-bit, 16-bit, 32-bit,
and 64-bit types are char short,

00:15:54.960 --> 00:15:54.960
int and long.

00:15:55.300 --> 00:15:57.120
So that was a much
easier programming model.

00:15:57.120 --> 00:15:59.850
And that's basically,
if you go searching for any 64-bit

00:15:59.960 --> 00:16:03.150
clean software out there today,
you're going to see all of it

00:16:03.170 --> 00:16:05.430
is written to the LP64 model.

00:16:05.890 --> 00:16:08.610
Now, the next thing that happens is
once all these acronyms came out,

00:16:08.690 --> 00:16:13.890
OP64, ILP64 and stuff, people said, well,
what do we call the old 32-bit model?

00:16:14.020 --> 00:16:16.700
So the old 32-bit model
got renamed as ILP64,

00:16:16.700 --> 00:16:19.810
which is integers, longs,
and pointers are all 32 bits.

00:16:20.150 --> 00:16:23.040
Well, then some of the 32-bit processors
got jealous of the 64-bit

00:16:23.050 --> 00:16:24.800
computation available and said,
well,

00:16:24.800 --> 00:16:26.860
we want a 64-bit type in the C language.

00:16:26.940 --> 00:16:29.090
So a bunch of different compiler
vendors added extensions,

00:16:29.160 --> 00:16:32.980
and eventually it got standardized
and ratified in C99 as long-long.

00:16:32.990 --> 00:16:35.260
Then they had the problem of, well,
what does long-long

00:16:35.350 --> 00:16:37.020
mean in LP64 and ILP64?

00:16:37.030 --> 00:16:39.180
Well, just to make it easy, they said,
well, it's just the same as long.

00:16:39.430 --> 00:16:44.350
So long-long is 64 bits
across all compilers.

00:16:44.720 --> 00:16:48.440
You also may have heard recently that
Windows has announced Windows 64.

00:16:48.530 --> 00:16:51.400
Now,
they decided to take a different path.

00:16:51.530 --> 00:16:54.620
After looking through the source code,
they decided that they had

00:16:54.620 --> 00:16:58.480
too many cases where they had
hard code along to be 32 bits.

00:16:58.570 --> 00:17:00.900
So rather than adopting
the industry standard LP64,

00:17:00.900 --> 00:17:03.400
they came up with a new
model they call P64,

00:17:03.450 --> 00:17:06.680
which only pointers change
in size to be 64 bits.

00:17:06.790 --> 00:17:09.260
All the other integer
types remain the same.

00:17:09.370 --> 00:17:12.820
So those of you who are investigating
64 bits and have code you need to

00:17:12.870 --> 00:17:17.340
compile both for Mac OS X or the
UNIX world and the Windows world,

00:17:17.440 --> 00:17:19.050
you have a bit of a conundrum.

00:17:19.210 --> 00:17:20.380
Turns out it's not that bad.

00:17:20.500 --> 00:17:23.280
If all you do is avoid
using the raw long type,

00:17:23.430 --> 00:17:27.030
you're fine, because ints are the same
between LP64 and P64,

00:17:27.280 --> 00:17:28.950
and long longs are the same.

00:17:29.040 --> 00:17:32.030
As you'll learn later in the talk,
using the raw types is kind

00:17:32.080 --> 00:17:33.810
of problematic to begin with.

00:17:36.500 --> 00:17:38.580
Now the ABI.

00:17:38.700 --> 00:17:41.650
We had a chance to re-examine
the PowerPC ABI for the 64-bit

00:17:41.830 --> 00:17:44.400
because we need to come up
with a new 64-bit convention.

00:17:44.400 --> 00:17:47.330
And there's no reason why we
had to be compatible anyway

00:17:47.330 --> 00:17:49.400
with the old 32-bit conventions.

00:17:49.400 --> 00:17:52.400
So we did as much analysis as we could on
how the old calling conventions worked,

00:17:52.400 --> 00:17:55.400
how parameters were passed
in registers and so forth.

00:17:55.400 --> 00:17:59.400
And we wanted to come up with the
optimal convention for 64-bits.

00:17:59.620 --> 00:18:02.110
What we decided was the
original 32-bit was pretty darn

00:18:02.120 --> 00:18:03.400
good and hard to improve on.

00:18:03.420 --> 00:18:05.320
found a few edge cases
where we could improve.

00:18:05.320 --> 00:18:07.500
So we did that for 64-bits.

00:18:07.770 --> 00:18:10.420
The first is when you pass
structs that contain floats.

00:18:10.420 --> 00:18:12.320
The old convention was
not very efficient.

00:18:12.320 --> 00:18:14.200
We've improved that for 64 bits.

00:18:14.200 --> 00:18:17.650
The second reason we made returns of
structs a little bit more efficient.

00:18:17.670 --> 00:18:19.910
And last thing is we
decided to dedicate R13,

00:18:19.910 --> 00:18:22.100
which was previously a
non-volatile register,

00:18:22.130 --> 00:18:24.990
to be owned by the OS and in fact
owned by the threading package.

00:18:25.120 --> 00:18:27.200
So R13 will be unique per thread.

00:18:27.210 --> 00:18:29.800
This allows faster Pthread access.

00:18:29.800 --> 00:18:34.030
In particular, thread local storage will
be faster on 64 bits.

00:18:36.110 --> 00:18:37.900
Next,
we need to update the file format we use.

00:18:37.900 --> 00:18:41.040
For those of you who've actually looked
at the details of the Mac OS file format,

00:18:41.040 --> 00:18:43.930
you'll see that it uses 32-bit
offsets everywhere in the file.

00:18:44.000 --> 00:18:50.190
We decided that in the long term,
people writing 64-bit code do so because

00:18:50.240 --> 00:18:53.090
they're going to have large amounts
of data and large amounts of code,

00:18:53.090 --> 00:18:57.000
and a 32-bit offset or 4-gig limitation
on the file size might be an issue.

00:18:57.000 --> 00:18:59.320
So we're going to be enhancing
the Mac OS file format to

00:18:59.320 --> 00:19:01.000
allow larger than 4-gig files.

00:19:03.030 --> 00:19:05.000
The key point to all this
is that it's going to be

00:19:05.000 --> 00:19:06.910
completely transparent to you.

00:19:09.170 --> 00:19:11.350
Next thing is,
some of you may be thinking, "Well,

00:19:11.430 --> 00:19:14.570
if there's no mode on the PowerPC,
I could be clever and write some function

00:19:14.850 --> 00:19:20.450
that happens to work both for 64-bit
callers and 32-bit callers." And yes,

00:19:20.450 --> 00:19:23.100
you can come up with some trivial
examples where that works,

00:19:23.140 --> 00:19:24.860
but as soon as you do
anything interesting,

00:19:25.000 --> 00:19:25.840
that breaks down.

00:19:25.970 --> 00:19:30.130
So we're recommending and we're
adding no support for mixing 32-bit

00:19:30.220 --> 00:19:33.930
and 64-bit code in the same process.

00:19:34.010 --> 00:19:36.770
And the way we do that is
our tools will mark all code,

00:19:36.770 --> 00:19:39.060
even though it's just
PowerPC instructions,

00:19:39.110 --> 00:19:43.330
will mark it with whether it's using
32-bit or 64-bit calling conventions.

00:19:49.480 --> 00:19:54.440
How we're going to do this is something
we call fat libraries or fat binaries.

00:19:54.490 --> 00:19:56.950
Some of you may have seen
different incantations of this

00:19:57.410 --> 00:19:59.680
concept of fatness before.

00:19:59.690 --> 00:20:04.000
I want to contrast this with some other
OSes that when they introduced 64-bit,

00:20:04.050 --> 00:20:06.360
say for instance,
you put all your libraries

00:20:06.420 --> 00:20:08.070
in /usr/lib as some OSes do.

00:20:08.080 --> 00:20:12.100
When 64-bit came out,
they had two libraries with the

00:20:12.100 --> 00:20:13.830
same names and they couldn't
put them in the same directory,

00:20:13.920 --> 00:20:16.320
so they came up with a new directory,
/usr/lib/64.

00:20:16.340 --> 00:20:18.840
And basically they kept all
the 64-bit and all the 32-bit

00:20:18.900 --> 00:20:21.880
binaries in separate directories,
and that's how they kept track of them.

00:20:21.880 --> 00:20:23.140
We're doing something different.

00:20:23.170 --> 00:20:26.760
We're leveraging the fat technology,
and this is how it works.

00:20:26.760 --> 00:20:29.540
On the right-hand side there,
you see a normal Mac OS file,

00:20:29.540 --> 00:20:32.440
which starts with a
small header which marks,

00:20:32.440 --> 00:20:35.680
in this case the calling conventions,
32-bit PowerPC is PPC,

00:20:35.680 --> 00:20:38.670
and then has the text and
data needed for that file.

00:20:39.350 --> 00:20:41.500
We also allow you to create
FAT files and our tools will

00:20:41.500 --> 00:20:42.900
do this for you automatically.

00:20:42.900 --> 00:20:46.860
Or you can use a lipo tool to
pack these things together.

00:20:46.860 --> 00:20:48.810
All it is,
at the beginning it has a table of

00:20:48.820 --> 00:20:52.550
contents that says here's all the sub
files or some images in this file and

00:20:52.550 --> 00:20:54.780
they're appended one after another.

00:20:55.310 --> 00:20:58.260
This allows you to chip one
file that has both 32-bit and

00:20:58.260 --> 00:21:02.810
a 64-bit implementation in it,
either a library or a main executable.

00:21:03.280 --> 00:21:05.470
If a user takes that and
runs it on a 32-bit system,

00:21:05.580 --> 00:21:08.410
well, the 32-bit version of the app
will be run and they'll be

00:21:08.410 --> 00:21:10.140
limited to the 4G address space.

00:21:10.220 --> 00:21:14.210
If they take that and run that
on a "Tiger" or later machine,

00:21:14.210 --> 00:21:18.200
on a G5 or greater machine,
the OS will automatically pick the

00:21:18.200 --> 00:21:22.510
64-bit version of the file and run that.

00:21:23.920 --> 00:21:27.040
I just want to have a little fun
here to talk about what does the

00:21:27.040 --> 00:21:28.760
64-bit address space really mean?

00:21:28.760 --> 00:21:31.830
It's pretty easy to say,
but how big is it?

00:21:34.290 --> 00:21:35.850
So imagine, if you will,
you took a tip of your

00:21:35.960 --> 00:21:37.630
pen and made a little dot.

00:21:37.700 --> 00:21:38.960
Let's call that one bit.

00:21:39.000 --> 00:21:41.190
So let's say right next to it
you tried to pack around seven

00:21:41.190 --> 00:21:43.060
other dots to make a byte.

00:21:43.180 --> 00:21:45.330
It's a few millimeters on the side.

00:21:46.330 --> 00:21:48.980
Now, if you extended that and
tried to draw actually four

00:21:48.980 --> 00:21:53.440
billion of these little bytes,
how big of a surface area would that be?

00:21:53.550 --> 00:21:57.010
Well, it turns out to be roughly
the surface of the roadway and

00:21:57.010 --> 00:22:00.360
sidewalks of the Golden Gate Bridge,
including the approaches.

00:22:00.480 --> 00:22:03.560
So we've spent our professional
career in the 32-bit world

00:22:03.670 --> 00:22:07.040
basically playing around an area
the size of the Golden Gate Bridge.

00:22:07.180 --> 00:22:10.500
So what does 64-bit means
with that same scale?

00:22:10.590 --> 00:22:14.100
Well, 64 bits is actually the
surface of the Earth.

00:22:14.300 --> 00:22:18.600
It's not quite, that would be 65 bits,
but it's actually twice the surface area

00:22:18.600 --> 00:22:20.430
of all the land masses on planet Earth.

00:22:20.550 --> 00:22:22.660
So basically,
you can get lost in 64 bits.

00:22:22.710 --> 00:22:24.500
It's big.

00:22:26.680 --> 00:22:29.960
Now, how are we going to divvy
up the 64-bit address space?

00:22:30.040 --> 00:22:33.400
Well, first thing to remember is
the kernel is going to set up,

00:22:33.550 --> 00:22:35.070
depending on which calling
conventions you work,

00:22:35.100 --> 00:22:37.700
which convention is 32-bit or 64-bit,
whether you have a 64-bit

00:22:37.790 --> 00:22:39.140
or 32-bit address space.

00:22:39.190 --> 00:22:45.030
All the existing binaries will load in
the 32-bit address space and still have

00:22:45.030 --> 00:22:45.030
the same restrictions they've always had.

00:22:46.510 --> 00:22:51.390
64-bit, you can load anywhere in that
64-bit address space and have

00:22:51.390 --> 00:22:54.010
access to the entire 64 bits.

00:22:54.640 --> 00:22:58.280
Now, one thing we're contemplating doing
is some of you may know that we

00:22:58.290 --> 00:23:01.280
currently have this thing called
the zero page where the first 4K

00:23:01.360 --> 00:23:05.340
of a 32-bit process is mapped to
be neither readable or writable.

00:23:05.350 --> 00:23:09.480
And that catches a lot of null pointer
or simple offsets off of null pointers.

00:23:09.560 --> 00:23:12.760
So we're considering doing the same
thing for the 64-bit address space,

00:23:12.800 --> 00:23:14.880
but instead we'll actually

00:23:15.200 --> 00:23:37.400
[Transcript missing]

00:23:39.420 --> 00:23:43.500
So let's get down into how you
actually compile for 64-bits.

00:23:43.600 --> 00:23:46.600
So in Xcode, in the inspector,
there's now a new attribute here.

00:23:46.610 --> 00:23:51.640
I'm not sure if it's big enough to read,
but it says "Architectures." That's

00:23:51.640 --> 00:23:54.620
new for the preview you have of Xcode.

00:23:54.640 --> 00:23:58.370
In the architecture fields,
you can type "PPC64." That is our

00:23:58.660 --> 00:24:03.170
token to denote that you're using the
64-bit calling conventions for PowerPC.

00:24:04.620 --> 00:24:07.540
If you're using GCC,
you can say -arc pbc64

00:24:07.540 --> 00:24:10.580
from the command line.

00:24:10.600 --> 00:24:14.470
Now I want to talk a bit about what
is actually in the 64-bit on the

00:24:14.580 --> 00:24:18.210
preview you guys received this week
and what we're going to have by

00:24:18.210 --> 00:24:21.710
the time Tiger is done for 64-bits.

00:24:21.890 --> 00:24:25.060
So first of all,
the kernel currently does not support

00:24:25.170 --> 00:24:27.360
the full 64-bit address space.

00:24:27.380 --> 00:24:31.000
It only supports basically 2 million
times the 4 gig address space.

00:24:31.130 --> 00:24:34.020
That's still-- you'll have
a hard time filling that up.

00:24:34.250 --> 00:24:37.280
The second is the only compiler we
have for 64-bit is the C compiler.

00:24:37.400 --> 00:24:39.540
When we should find it,
we'll also have the

00:24:39.540 --> 00:24:41.140
C++ compiler available.

00:24:41.140 --> 00:24:44.140
Some of you may ask, "Well,
what about Objective-C?"

00:24:45.060 --> 00:24:46.970
That's actually easy
to do in the compiler.

00:24:47.160 --> 00:24:49.660
The problem is, as I said earlier,
we're only committing to

00:24:49.660 --> 00:24:51.560
lib system being available.

00:24:51.600 --> 00:24:54.920
And our Objective-C runtime relies
heavily on the foundation frameworks,

00:24:54.920 --> 00:24:57.400
and we haven't committed yet to when
the foundation framework will be

00:24:57.400 --> 00:24:59.590
available using 64-bit conventions.

00:24:59.700 --> 00:25:02.850
So we're not going to release the
compiler yet until that's done.

00:25:03.720 --> 00:25:06.650
Next thing is GDB can
actually debug 64-bit programs

00:25:06.770 --> 00:25:08.480
already with this preview.

00:25:08.640 --> 00:25:11.480
The assembler and the static
linker can create them.

00:25:11.570 --> 00:25:15.470
But what it creates are static
versions of executables.

00:25:15.480 --> 00:25:17.930
These executables cannot
load any libraries.

00:25:18.060 --> 00:25:20.810
If just one image is loaded in,
that's it.

00:25:21.990 --> 00:25:24.490
For "Tiger" final,
we're no longer going to support

00:25:24.580 --> 00:25:29.380
these static executables and only
going to support dynamic executables.

00:25:31.430 --> 00:25:34.840
For this release,
the file format we're using is

00:25:34.840 --> 00:25:39.410
a standard Mac OS file format,
which means it's limited to 32 bits,

00:25:39.460 --> 00:25:43.900
and which means that your 64-bit
processors will load in the low 4 gig.

00:25:44.130 --> 00:25:46.720
We haven't done that trick
yet of mapping it out.

00:25:47.620 --> 00:25:51.720
By the time "Tiger" goes final,
we'll have an updated file format

00:25:51.800 --> 00:25:55.620
in which you can load your XCubeable
anywhere in the 4-gig address space.

00:25:56.560 --> 00:25:59.710
Lastly, because of the difference
between static and dynamic,

00:25:59.710 --> 00:26:05.360
Xcode is only going to support building
standalone static PPC64 executables,

00:26:05.360 --> 00:26:06.220
not FAT.

00:26:06.400 --> 00:26:09.800
And finally,
you'll be able to build FAT binaries.

00:26:09.800 --> 00:26:11.290
And of course,
the whole point of this preview is

00:26:11.420 --> 00:26:14.800
for you to evaluate 64-bit to start
playing with it and give us feedback.

00:26:15.030 --> 00:26:17.800
Once "Tiger" is final,
then the programs you make

00:26:17.800 --> 00:26:20.520
on the final "Tiger" you can
ship and Apple will support.

00:26:22.800 --> 00:26:25.200
Let me summarize here.

00:26:25.200 --> 00:26:27.200
G5 is a unique 64-bit processor.

00:26:27.200 --> 00:26:28.480
There is no mode.

00:26:28.650 --> 00:26:30.430
All the instructions
are exactly the same.

00:26:30.520 --> 00:26:32.940
The only difference between
32-bit and 64-bit executables

00:26:33.000 --> 00:26:35.430
is conventions they use.

00:26:38.300 --> 00:26:41.800
Again, because once you switch to 64-bit,
your data structures are bigger,

00:26:41.800 --> 00:26:44.180
you're going to have a
slight performance decrease.

00:26:44.250 --> 00:26:46.800
For that reason,
the only reason you should convert

00:26:46.980 --> 00:26:51.470
to using 64-bit calling conventions
is if you actually need more

00:26:51.470 --> 00:26:53.270
than 4 gig of address space.

00:26:53.780 --> 00:26:57.810
We're using the architecture part
of our FAT builds to enable a

00:26:57.970 --> 00:27:02.270
mixture of both 32-bit and 64-bit
calling conventions of PowerPC code,

00:27:02.270 --> 00:27:05.530
and we're calling the new thing PBC64.

00:27:05.830 --> 00:27:10.720
And lastly, we're only committing
to shipping LibSystem as

00:27:10.750 --> 00:27:13.380
available for 64-bit programs.

00:27:13.470 --> 00:27:15.420
So you need to work around that.

00:27:15.450 --> 00:27:19.880
And again, the programs you build on this
preview will not run on Tiger Final.

00:27:19.940 --> 00:27:22.800
It's purely for evaluation.

00:27:22.900 --> 00:27:24.610
So next,
I'd like to bring up Jeff Glasson,

00:27:24.610 --> 00:27:28.100
who's going to give you
a short demo of 64-bit.

00:27:28.870 --> 00:27:29.890
Thanks, Nick.

00:27:30.820 --> 00:27:35.570
What I wanted to show is I wanted to
go a little bit into how to build a

00:27:35.660 --> 00:27:38.300
64-bit service application using Xcode.

00:27:38.300 --> 00:27:40.950
And for those of you that
were at Ted's tools overview

00:27:41.110 --> 00:27:43.790
session on Monday afternoon,
you saw the Celestia app.

00:27:43.860 --> 00:27:47.990
What was going on behind the
scenes there was we had this 32-bit

00:27:48.090 --> 00:27:51.880
GUI application with a 64-bit service
application in the background.

00:27:51.880 --> 00:27:56.320
And that application actually was
mapping 6.5 gigabytes of terrain data,

00:27:56.320 --> 00:27:59.050
which I think we left out
that little statistic.

00:27:59.410 --> 00:28:02.160
So it really was making use
of the 64-bit address space.

00:28:02.180 --> 00:28:04.670
So I'm going to show that
actual service application,

00:28:04.750 --> 00:28:07.380
how you would build that in Xcode,
and then play some games and

00:28:07.380 --> 00:28:08.420
step through the debugger.

00:28:08.460 --> 00:28:10.660
So let me launch Xcode.

00:28:12.940 --> 00:28:16.050
And I'm going to do some cut and
paste to speed this up a little bit,

00:28:16.170 --> 00:28:18.770
but you'd be doing the
same thing but typing.

00:28:18.900 --> 00:28:20.800
So I'm going to create a new project.

00:28:20.800 --> 00:28:25.210
And just a standard C tool.

00:28:27.210 --> 00:28:31.910
Just call it TerraMapper,
because it's a good similar name.

00:28:32.060 --> 00:28:34.390
Give it a second.

00:28:39.330 --> 00:28:42.600
I think my disk spun down
while the machine was resting.

00:28:42.810 --> 00:28:44.760
So I'm going to do this quicker.

00:28:44.760 --> 00:28:46.680
Instead of me actually
typing in the text,

00:28:46.680 --> 00:28:51.390
I'm going to actually add the
source file to the project quickly.

00:28:52.890 --> 00:28:58.140
And copy it in and delete
that little template main that

00:28:58.140 --> 00:29:00.600
came with the temp project.

00:29:01.220 --> 00:29:05.880
Okay, so the first thing you need to do
when you're building a 64-bit app to

00:29:05.890 --> 00:29:11.330
make sure is you want to open up the
project inspector and as Nick mentioned,

00:29:11.510 --> 00:29:14.280
there's an architecture flag
setting and by default we

00:29:14.280 --> 00:29:17.990
build for 32-bit conventions,
so I'm just going to

00:29:18.750 --> 00:29:21.160
change this to PPC64.

00:29:22.600 --> 00:29:25.200
And then close that.

00:29:25.220 --> 00:29:28.360
And so now what I want to do,
I'm going to open up the source file,

00:29:28.360 --> 00:29:32.320
and I'm going to set a breakpoint
at the start of-- actually,

00:29:32.640 --> 00:29:34.170
before I do that,
I'm going to do something a little

00:29:34.330 --> 00:29:37.220
tricky to speed this demo up.

00:29:37.230 --> 00:29:43.010
I'm going to actually pre-allocate
three gigabytes of my address space.

00:29:44.180 --> 00:29:47.900
Let me count the right
number of zeros here.

00:29:47.900 --> 00:29:50.110
This is actually going to speed
things up some so we don't actually

00:29:50.110 --> 00:29:52.650
have to read four gigabytes of
data off the disk for this demo.

00:29:52.940 --> 00:29:59.770
Let me set a break and
then we'll build it.

00:30:00.260 --> 00:30:02.960
Actually, let's go into the debugger.

00:30:03.050 --> 00:30:10.560
So Nick mentioned GDB and the
Xcode UI all is 64-bit aware.

00:30:11.310 --> 00:30:14.530
Right now, this actually is not going
to be very interesting,

00:30:14.620 --> 00:30:17.340
so I'm going to step a couple steps.

00:30:19.600 --> 00:30:22.840
Okay, so now let's do something
a little more clever.

00:30:23.030 --> 00:30:26.600
So I've just pre-allocated three
gigabytes of address space.

00:30:26.600 --> 00:30:29.680
What I want to do is where we're
going to start mapping the data,

00:30:29.680 --> 00:30:32.400
I want to set a breakpoint there.

00:30:32.490 --> 00:30:38.710
And now I actually have to
drop to the Xcode console,

00:30:38.710 --> 00:30:41.670
or the GDB console here,
because I want to actually set

00:30:41.670 --> 00:30:41.670
a condition on that breakpoint.

00:30:42.420 --> 00:30:44.160
That is actually breakpoint two.

00:30:44.160 --> 00:30:49.420
So what I'm going to do is set
a condition so that breakpoint's

00:30:49.520 --> 00:30:54.360
only going to stop when my pointer
value gets above four gigabytes.

00:30:56.220 --> 00:30:59.190
Again, I have to make sure I type
enough zeros because it's

00:30:59.190 --> 00:31:01.280
more than I'm used to typing.

00:31:01.600 --> 00:31:03.560
and now I can continue running.

00:31:03.730 --> 00:31:08.090
So, the demo gods have not blessed me.

00:31:08.100 --> 00:31:09.620
Let me try that one more time.

00:31:09.800 --> 00:31:16.970
Sorry.

00:31:33.500 --> 00:31:38.500
One second.

00:31:38.500 --> 00:31:40.500
I'm going to quit and relaunch it in
case there was some stale data there.

00:31:40.500 --> 00:31:43.500
Remember, this is preview software.

00:31:43.500 --> 00:31:49.260
Ah, I remember what's wrong.

00:31:49.260 --> 00:31:52.250
I forgot to give it some
command line arguments.

00:31:55.750 --> 00:31:59.140
I actually need to go here and
actually tell it where the data is.

00:31:59.140 --> 00:32:01.340
It's my fault, not the software's fault.

00:32:01.340 --> 00:32:08.740
So I'm going to actually cut and
paste a whole bunch of stuff here.

00:32:08.740 --> 00:32:14.900
Okay.

00:32:29.690 --> 00:32:39.100
I'm just being paranoid with
ULL to make sure GDB knows that

00:32:39.100 --> 00:32:42.100
I'm typing a 64-bit constant.

00:32:42.100 --> 00:32:44.760
So, okay, so now we're actually reading,
reading, reading.

00:32:44.760 --> 00:32:51.670
So it's loading about a gigabyte
since I pre-allocated three gigabytes.

00:32:52.060 --> 00:32:53.540
Let's see.

00:32:53.610 --> 00:32:57.720
We actually have a pretty
big value for P right now.

00:32:58.050 --> 00:32:59.540
That's way up there in the address space.

00:32:59.640 --> 00:33:02.500
And actually,
you can use all the features of Xcode.

00:33:02.500 --> 00:33:04.690
You can actually look in, dereference it.

00:33:04.880 --> 00:33:10.810
You can bring up the memory viewer,
which is under here.

00:33:13.690 --> 00:33:16.600
Uh-oh.

00:33:16.600 --> 00:33:17.440
I can't type.

00:33:17.600 --> 00:33:22.600
So we actually can look at that memory.

00:33:22.600 --> 00:33:24.600
It's not very interesting
because this is actually mapped

00:33:24.600 --> 00:33:28.600
but hasn't been faulted in yet,
but the tools are all ready for 64 bits,

00:33:28.620 --> 00:33:32.590
and as we move more frameworks along
the line and as we make things dynamic,

00:33:32.600 --> 00:33:36.600
I think you'll be able to explore
and give us feedback right now.

00:33:36.600 --> 00:33:38.600
So that's all I actually had to show.

00:33:38.600 --> 00:33:41.600
It's not very interesting
since the GUI is not 64 bits,

00:33:41.640 --> 00:33:44.600
and you already saw that, but with that,
I'd like to introduce Stan Chebs,

00:33:44.610 --> 00:33:48.600
who's gonna talk a little bit
about some pitfalls with 64 bits.

00:33:56.340 --> 00:33:59.050
Hello everybody.

00:33:59.050 --> 00:34:01.990
So we're going to go into,
twist out and go into a little

00:34:02.100 --> 00:34:06.880
more detail into the pitfalls and
what actually happens when you

00:34:06.880 --> 00:34:09.200
try and do 64-bit programming.

00:34:09.360 --> 00:34:15.260
Jeff very narrowly skated several errors
and he's actually quite lucky the demo

00:34:15.260 --> 00:34:20.630
guys didn't ultimately smile on him
because he actually got 64-bit numbers

00:34:20.630 --> 00:34:23.390
back when he put 64-bit numbers in.

00:34:23.630 --> 00:34:28.950
So the kinds of things that can happen
is that the source code will need

00:34:28.950 --> 00:34:34.120
changes because integers remain 32
bits and there's a number of practices,

00:34:34.120 --> 00:34:37.940
long-standing practices,
that no longer work.

00:34:37.980 --> 00:34:40.780
For instance,
integers cannot hold pointers.

00:34:40.800 --> 00:34:44.910
That seems fairly obvious,
but in fact a lot of code will casually

00:34:45.040 --> 00:34:49.500
assign pointers to integers expecting to
get the pointer back later on somehow.

00:34:49.510 --> 00:34:51.400
That kind of practice won't work.

00:34:51.410 --> 00:34:57.050
Even something as innocuous as
using a %d in a printf will not

00:34:57.050 --> 00:34:59.300
actually show you the entire number.

00:34:59.310 --> 00:35:02.450
And that can be very confusing
if you don't use GDB and you

00:35:02.450 --> 00:35:04.580
try using printf for debugging.

00:35:04.600 --> 00:35:06.980
The other things we have to
do is that casting doesn't

00:35:06.980 --> 00:35:08.450
actually solve the problem.

00:35:08.450 --> 00:35:11.380
There's ways to get
tricked by sign extensions.

00:35:11.410 --> 00:35:15.780
There's ways to get
tricked by function calls.

00:35:16.980 --> 00:35:20.580
We'll start out by recalling Diogenes.

00:35:20.690 --> 00:35:24.800
And Diogenes, if you remember,
was a philosopher of ancient Greece,

00:35:24.800 --> 00:35:29.290
and one of his sticks was to wander
around with a lantern looking for

00:35:29.290 --> 00:35:32.180
honest people and never finding any.

00:35:32.320 --> 00:35:37.380
So since we're in the modern age,
we have a flashlight, LED flashlight,

00:35:37.560 --> 00:35:40.570
and we're going to be looking
for honest programmers.

00:35:40.970 --> 00:35:45.690
So, our first question:
How many programmers have

00:35:45.690 --> 00:35:49.090
assigned a pointer to an integer?

00:35:49.720 --> 00:35:51.600
Wow, we have a lot of honest programmers.

00:35:51.600 --> 00:35:53.880
That's very encouraging.

00:35:54.000 --> 00:35:56.290
But I know it's not
everybody raised their hand.

00:35:56.540 --> 00:35:59.310
Perhaps we have some Java people in here?

00:36:01.390 --> 00:36:05.050
So the key thing to know about
assigning the pointers to

00:36:05.050 --> 00:36:07.060
integers is it will lose data.

00:36:07.060 --> 00:36:12.420
It will just simply drop off the top half
of the pointer and it'll just be gone.

00:36:12.690 --> 00:36:14.410
This is half an instruction set level.

00:36:14.420 --> 00:36:17.800
There's no way to recover from it.

00:36:17.850 --> 00:36:19.750
Now you can assign to
a long or a long-long.

00:36:19.860 --> 00:36:22.610
Both of those are perfectly okay.

00:36:23.260 --> 00:36:26.410
So with the code example we have here,
we do the malloc.

00:36:26.520 --> 00:36:29.780
We'll assume the malloc came
back with a big pointer variable.

00:36:29.860 --> 00:36:31.100
We assign it.

00:36:31.200 --> 00:36:35.600
And GCC is helpful and it does
warn you that the assignment is

00:36:35.810 --> 00:36:39.030
making an integer from a pointer,
but it doesn't tell you

00:36:39.030 --> 00:36:40.100
that you're losing data.

00:36:40.100 --> 00:36:43.860
It just warns you that you're
doing this without a cast.

00:36:44.220 --> 00:36:46.100
We'll come back to casts in a moment.

00:36:46.100 --> 00:36:49.610
So if you look at the value of the
integer variable at that point,

00:36:49.730 --> 00:36:52.100
it's just the lower half of the pointer.

00:36:52.270 --> 00:36:55.100
Now if you do the same
thing to a long variable,

00:36:55.110 --> 00:36:57.090
you get the entire value.

00:36:57.100 --> 00:36:59.090
You can assign that back
to a pointer later on.

00:36:59.090 --> 00:37:01.050
That works.

00:37:04.620 --> 00:37:05.940
Now, printf.

00:37:05.960 --> 00:37:13.570
How many people use the correct
kind of printf directive for

00:37:13.570 --> 00:37:16.210
their longs and longlongs?

00:37:18.120 --> 00:37:24.700
So, most people will just
habitually tend to use %d,

00:37:24.700 --> 00:37:29.520
and %d has the fatal flaw that it will
only show you an integer-sized thing.

00:37:29.760 --> 00:37:31.460
Printf is not a magic function.

00:37:31.490 --> 00:37:36.680
You hand it all the arguments,
but it decides what to pull off the

00:37:36.880 --> 00:37:40.840
stack that you pass to it based on
what the printf directives tell it.

00:37:41.110 --> 00:37:45.330
The directive says pull four bytes,
it pulls four bytes and leaves

00:37:45.330 --> 00:37:49.410
the next four bytes for the next
thing that it's asked to print.

00:37:49.490 --> 00:37:52.560
So you can get some
interesting behaviors.

00:37:52.690 --> 00:37:56.580
And it can be very confusing because
if you use printf as your window into

00:37:56.580 --> 00:38:00.200
what's happening inside the program,
and printf is not telling

00:38:00.200 --> 00:38:03.290
you what's really happening,
you can have a situation

00:38:03.290 --> 00:38:06.310
where the program is more
or less working correctly,

00:38:06.310 --> 00:38:08.780
but printf says it has to be failing.

00:38:08.880 --> 00:38:09.990
So you've got to watch out for that.

00:38:10.150 --> 00:38:14.070
And so the directives to use,
they've always been there in C.

00:38:14.080 --> 00:38:15.430
They've been around.

00:38:15.530 --> 00:38:19.990
You can use %ld for a decimal printout,
or you can use %lx for the

00:38:19.990 --> 00:38:22.140
hexadecimal print for longs.

00:38:22.620 --> 00:38:28.150
And for long-longs,
it's always been available

00:38:28.150 --> 00:38:30.310
to do %lld and %llx.

00:38:30.790 --> 00:38:33.840
And then we also have %P for pointers.

00:38:33.890 --> 00:38:37.700
The standard actually does
not define what %P does.

00:38:37.800 --> 00:38:40.530
In our case,
it puts a 0x on the front and

00:38:40.660 --> 00:38:42.700
prints it out in hexadecimal.

00:38:42.700 --> 00:38:46.080
But that's actually not a
cross-platform expectation.

00:38:46.080 --> 00:38:51.880
%P may do something different on a
Linux or a Solaris or what have you.

00:38:55.380 --> 00:38:59.300
Now, how many people use casting?

00:38:59.300 --> 00:39:02.700
Good, that's good.

00:39:02.820 --> 00:39:09.050
So, casting unfortunately is not
a magical process that somehow

00:39:09.050 --> 00:39:10.490
makes the conversion work.

00:39:10.630 --> 00:39:13.280
All it does is tell the compiler
that you actually intended

00:39:13.660 --> 00:39:15.500
to assign one to the other.

00:39:15.580 --> 00:39:19.500
So, as our example here shows,
we can assign a pointer variable

00:39:19.500 --> 00:39:24.730
to an integer variable and voila,
it whacks the top off again.

00:39:25.050 --> 00:39:27.220
But except that this time,
the compiler hasn't

00:39:27.220 --> 00:39:28.620
actually said anything.

00:39:28.640 --> 00:39:32.000
It says, "Hey, hey,
you put in an int cast in there,

00:39:32.000 --> 00:39:35.960
the programmer must know what they're
doing." So it doesn't say anything.

00:39:35.990 --> 00:39:40.100
And again, you can do the same
thing with a long cast.

00:39:40.330 --> 00:39:42.320
The long cast will do the right thing.

00:39:42.440 --> 00:39:47.440
So the basic bottom line is that all
those casts you thought were going

00:39:47.440 --> 00:39:51.360
to fix the 64-bit problem actually
aren't doing you a bit of good.

00:39:55.990 --> 00:39:59.400
Now, signed extensions is a
little bit complicated here.

00:39:59.500 --> 00:40:06.070
The problem is that an unsigned
64-bit number may actually look

00:40:06.070 --> 00:40:07.900
like a signed 32-bit number.

00:40:07.900 --> 00:40:10.900
And it's a little bit messy to set it up,
but I did check this out in the code,

00:40:10.900 --> 00:40:14.050
so if you run back to the lab,
I'm reasonably certain that

00:40:14.060 --> 00:40:16.900
if you type all this in,
you'll get more or less the same result.

00:40:17.260 --> 00:40:19.260
However, we're destroying the
slides after this talk,

00:40:19.420 --> 00:40:21.900
so you won't actually--you'll
have to work from memory.

00:40:21.900 --> 00:40:27.490
So, to take an example,
let's take and assign 9 bajillion

00:40:27.550 --> 00:40:30.870
to an unsigned integer variable.

00:40:30.900 --> 00:40:34.130
So this is just above 2 gigabytes,
so if this is a signed value,

00:40:34.240 --> 00:40:36.900
it would actually come
out as a negative number.

00:40:36.900 --> 00:40:40.880
But we're cleaning our code,
we've made it an unsigned integer.

00:40:40.900 --> 00:40:43.900
We can take that,
we can assign it to an unsigned long,

00:40:43.900 --> 00:40:45.900
and the right thing happens.

00:40:45.900 --> 00:40:50.900
But then if we take that and we
assign it to an assigned integer,

00:40:51.080 --> 00:40:54.200
we end up with a value
that's less than zero.

00:40:55.070 --> 00:40:57.540
And the other thing that's
interesting about that,

00:40:57.540 --> 00:41:01.330
if you also take that less
than zero value and then

00:41:01.330 --> 00:41:04.330
assign it to assigned long,
it's still less than zero.

00:41:04.360 --> 00:41:09.010
So now we've taken our nice large
positive number and turned it

00:41:09.010 --> 00:41:10.820
into a large negative number.

00:41:12.590 --> 00:41:16.900
Now the juicy part about this is then
you go and do another assignment.

00:41:16.900 --> 00:41:19.780
You assign it back to an unsigned long.

00:41:19.950 --> 00:41:26.480
Okay, it now comes out as an
extremely large unsigned number.

00:41:26.560 --> 00:41:29.080
And so if you say we're
expecting this to be,

00:41:29.080 --> 00:41:32.620
say, a number of iterations, you know,
two billion iterations,

00:41:32.620 --> 00:41:35.500
that's sort of plausible.

00:41:35.620 --> 00:41:38.650
However large that number is,
that's an awful lot of iterations.

00:41:38.720 --> 00:41:43.020
Your machine will spend quite a bit
of time getting to the end of that.

00:41:43.410 --> 00:41:45.680
So that's kind of a
mysterious looking number,

00:41:45.680 --> 00:41:49.550
but what it really is,
is the nine bajillion you had originally,

00:41:49.740 --> 00:41:53.040
but it's had FFFs glued on the front.

00:41:53.420 --> 00:41:57.640
Essentially that's just being assigned,
extended, and choose complement.

00:41:57.740 --> 00:41:59.640
So that's where that
value really comes from.

00:41:59.720 --> 00:42:02.140
But after a set of
transformations like this,

00:42:02.140 --> 00:42:05.620
it's not obvious that that's where
the number really comes from.

00:42:05.700 --> 00:42:08.420
And what you want to do is when
you're sitting in debugger and the

00:42:08.420 --> 00:42:12.220
numbers aren't making any sense,
look at them in hexadecimal.

00:42:12.280 --> 00:42:15.030
In a lot of cases you'll see that,
in fact, there's this sign

00:42:15.030 --> 00:42:18.080
extension that's gone on,
the number's been turned

00:42:18.080 --> 00:42:20.290
into a large unsigned value.

00:42:25.130 --> 00:42:29.000
Now, another way to have bad stuff
happen is through function calls.

00:42:29.040 --> 00:42:31.800
Now, most of you have
probably done prototypes.

00:42:31.800 --> 00:42:32.300
Is that true?

00:42:32.300 --> 00:42:35.490
Has everybody done prototypes
for all their functions?

00:42:36.300 --> 00:42:36.690
How's this going?

00:42:36.810 --> 00:42:37.290
Okay, there we go.

00:42:37.420 --> 00:42:40.100
Everybody does prototypes
for all their functions?

00:42:40.100 --> 00:42:44.140
They add prototypes when the system
doesn't provide the prototypes?

00:42:44.210 --> 00:42:47.050
Fewer hands go up there.

00:42:47.200 --> 00:42:55.420
So, this time around for 64-bit,
the prototypes really, really matter.

00:42:55.420 --> 00:42:59.200
Because the rules of C are that
if you don't have a prototype,

00:42:59.200 --> 00:43:02.200
it'll fall back to its defaults,
which is to pass doubles for floats,

00:43:02.200 --> 00:43:06.090
which is usually okay,
but to pass integers for

00:43:06.250 --> 00:43:08.140
the integer arguments.

00:43:08.190 --> 00:43:11.200
And in particular, that's not longs.

00:43:11.200 --> 00:43:14.200
So, and the compiler may or may
not say something about this.

00:43:14.200 --> 00:43:18.200
So, we have here an example
of a function called fun,

00:43:18.200 --> 00:43:22.200
where it's declared as a function,
but it doesn't have a proper prototype.

00:43:22.200 --> 00:43:26.690
We can take a long value and
assign it to a long variable,

00:43:26.690 --> 00:43:27.880
and that works.

00:43:28.130 --> 00:43:31.200
And we can pass that into the function.

00:43:32.310 --> 00:43:34.610
So,
the function calling process truncates

00:43:34.800 --> 00:43:38.100
the integer again in a fashion
that should be familiar by now.

00:43:38.330 --> 00:43:42.300
And if you look at the value of
the variable inside the function,

00:43:42.300 --> 00:43:44.200
it's chopped off again.

00:43:44.200 --> 00:43:47.620
Now, if you pass the whole constant,
it'll do the same thing.

00:43:47.780 --> 00:43:49.200
It'll still chop it off.

00:43:49.300 --> 00:43:51.460
In that case,
the compiler will give you a

00:43:51.460 --> 00:43:55.200
warning that it's chopping it off,
which is a small consolation.

00:44:00.590 --> 00:44:04.860
Okay, so we've got all these ways of
losing by getting the values cut

00:44:04.860 --> 00:44:06.890
up in ways that you don't want.

00:44:07.030 --> 00:44:08.680
So, how do you do it right?

00:44:08.740 --> 00:44:11.500
I mean, what do you do?

00:44:11.650 --> 00:44:14.950
You have often a very situation,
for instance, you have to send something

00:44:14.950 --> 00:44:17.450
out over the wire,
you have to send something

00:44:17.450 --> 00:44:20.920
to a 32-bit process,
and you need to preserve both

00:44:21.050 --> 00:44:23.020
halves of your big pointer.

00:44:23.470 --> 00:44:25.910
There's a couple different ways
to do it and I won't try and

00:44:25.910 --> 00:44:29.480
recommend a single way because it
really depends on your situation,

00:44:29.480 --> 00:44:30.400
your application.

00:44:30.400 --> 00:44:34.400
One way that works reasonably
well is to use a union.

00:44:34.490 --> 00:44:37.370
In this case we have a union
that exists only for the purpose

00:44:37.490 --> 00:44:38.400
of splitting up a big value.

00:44:38.400 --> 00:44:42.400
Now we have two fields union,
a long and an array of two ints.

00:44:42.400 --> 00:44:47.490
We can assign it to the,
we can assign it, take a long variable,

00:44:47.870 --> 00:44:50.590
assign it to the union,
and then if you look at the two

00:44:50.720 --> 00:44:53.400
halves of the union they come out
as the two halves of the integer.

00:44:53.400 --> 00:44:58.400
Now a downside, a hazard of this,
this is NDE-independent.

00:44:58.400 --> 00:45:02.800
So if you're just transmitting within,
from one processor to the

00:45:02.800 --> 00:45:06.150
same kind of processor,
this will work, or if you're doing it

00:45:06.260 --> 00:45:07.400
within a single program.

00:45:07.450 --> 00:45:10.360
But if you're splitting in
half and sending the two

00:45:10.360 --> 00:45:13.970
halves over the wire to say,
"An x86 machine,

00:45:14.180 --> 00:45:17.780
chances are the two halves
will go out wrong." And so

00:45:17.890 --> 00:45:21.400
you need to be aware of that,
which half is which.

00:45:22.270 --> 00:45:25.540
Because again, in traditional fashion,
you send it out over the wire,

00:45:25.540 --> 00:45:26.900
it comes out wrong.

00:45:27.010 --> 00:45:32.400
You sent two over the wire and
the x86 receives it as 2 times

00:45:32.400 --> 00:45:34.980
4 gigabytes or 8 gigabytes.

00:45:35.130 --> 00:45:38.430
And for instance,
in the header of a packet and

00:45:38.480 --> 00:45:41.620
it's expecting 8 gigabytes of
data when you only sent two,

00:45:41.760 --> 00:45:45.620
the x86 machine is going to be
waiting for a very long time.

00:45:45.720 --> 00:45:48.430
On the plus side,
you can then say that's a Windows bug

00:45:48.440 --> 00:45:50.190
and everybody will believe you.

00:45:53.010 --> 00:45:56.070
So the other way to do that that's
more reliable if you have to pay

00:45:56.080 --> 00:46:02.900
attention to any of this is to write
out manually the cutting up operation.

00:46:03.010 --> 00:46:05.900
And I've written it out here
and I've tested this one too.

00:46:05.900 --> 00:46:10.000
So again, you know,
do it from memory on a lab machine,

00:46:10.090 --> 00:46:12.900
see if it really works and
come tell me if I got it wrong.

00:46:13.070 --> 00:46:18.660
The game here is we need to mask off,
we want to mask off the low and

00:46:18.660 --> 00:46:21.840
high halves of the long number.

00:46:21.900 --> 00:46:27.520
Now to mask off the low half,
you can and it with lots of Fs.

00:46:27.900 --> 00:46:33.900
The trick here is you need to and it with
lots of Fs with lots of leading zeros.

00:46:33.900 --> 00:46:39.770
Okay, if I just said 0x and then 8Fs,
that would get sign extended to 0x

00:46:39.770 --> 00:46:45.520
and 16Fs and the ampersand then would
yield a big number and then it would

00:46:45.520 --> 00:46:47.680
be cut off to get the wrong half.

00:46:47.900 --> 00:46:49.540
Sorry, no,
it would actually get the right half but

00:46:49.540 --> 00:46:50.890
it would get it for the wrong reasons.

00:46:50.900 --> 00:46:55.900
So I recommend doing it this way.

00:46:56.100 --> 00:46:59.670
They don't have a slide actually
for this but you can actually get

00:46:59.820 --> 00:47:03.900
into trouble if you don't add the
Ls onto the ends of your constants.

00:47:03.900 --> 00:47:07.350
So I recommend you do that
everywhere now that you're doing,

00:47:07.350 --> 00:47:09.900
working with 64-bit programming.

00:47:09.900 --> 00:47:13.720
To get the high half of the number,
since we're working in a signed regime,

00:47:13.720 --> 00:47:15.850
the correct thing to do is to do a shift.

00:47:16.080 --> 00:47:19.320
You can shift down by 32 and in this
case we don't have to put an L on

00:47:19.320 --> 00:47:24.950
the 32 because it's just a shift
and that will make the sign extended

00:47:24.950 --> 00:47:27.900
correctly if you have a negative
number that you're cutting up.

00:47:27.900 --> 00:47:31.430
And if we print F it,
we see that it's cut up in

00:47:31.430 --> 00:47:33.890
the two halves correctly.

00:47:39.670 --> 00:47:44.000
So what kind of assistance do we actually
give you to write compatible code?

00:47:44.010 --> 00:47:46.600
So we have all these problems,
all these different ways to lose,

00:47:46.600 --> 00:47:48.550
you know, what do you do?

00:47:48.840 --> 00:47:53.120
So at the language level,
we give you some standard

00:47:53.120 --> 00:47:54.180
types and macros.

00:47:54.190 --> 00:47:55.780
Some of these have been
around for a long time.

00:47:55.780 --> 00:48:02.330
We have size T, we have int PTRT,
which is an integer type that is

00:48:02.330 --> 00:48:05.470
large enough to hold a pointer,
and that'll have the correct

00:48:05.630 --> 00:48:09.680
type whether you're doing either
32- or 64-bit programming.

00:48:09.680 --> 00:48:15.960
We have uint PTRT,
the corresponding type for unsigned.

00:48:16.510 --> 00:48:21.900
There's also an N32T and an
N64T types that you can use.

00:48:22.180 --> 00:48:25.570
For the Unix side of the world,
there's additional types

00:48:25.680 --> 00:48:27.040
that are specific to Unix.

00:48:27.160 --> 00:48:29.200
They're not a standard C-type.

00:48:29.280 --> 00:48:33.120
We have things like C-Adder T,
which is the size of a Core Adder,

00:48:33.200 --> 00:48:37.080
which is just a euphemism for
a pointer into main memory.

00:48:37.200 --> 00:48:40.620
So that's going to be a 64-bit
type in the 64-bit world.

00:48:40.750 --> 00:48:45.500
So we have process IDs,
Off T is for file offsets, and so forth.

00:48:45.670 --> 00:48:48.960
If you look in the user include,
you'll see there's quite

00:48:48.960 --> 00:48:50.410
a few of these headers.

00:48:50.560 --> 00:48:52.720
In fact,
if you compare the Panther headers

00:48:52.820 --> 00:48:56.780
and the Tiger headers,
you'll see a whole bunch of changes.

00:48:56.830 --> 00:49:00.280
Those places where Panther only
had 32-bit headers.

00:49:00.400 --> 00:49:03.860
So the obvious implication is
beware of compiling this stuff

00:49:03.960 --> 00:49:09.380
on Panther because if you can,
if Panther didn't give

00:49:09.390 --> 00:49:11.660
you any complaints,
the headers are different on Tiger,

00:49:11.660 --> 00:49:16.110
and so you may see things in Tiger that
you didn't get out of Panther.

00:49:16.530 --> 00:49:19.640
Another thing that's actually
very common for programs is that

00:49:19.830 --> 00:49:22.000
programs have been ported to 32-bit.

00:49:22.000 --> 00:49:25.440
Say they were on Unix systems already,
they will have their own

00:49:25.770 --> 00:49:27.400
local definitions for types.

00:49:27.400 --> 00:49:31.400
And there's any number of different
conventions that people use.

00:49:31.400 --> 00:49:35.400
They'll have macros all uppercase,
they'll have funny names for them.

00:49:35.400 --> 00:49:38.260
You'll see all kinds of
different things out there.

00:49:38.410 --> 00:49:42.260
One source I'll recommend
is GNU software itself.

00:49:42.260 --> 00:49:44.690
GNU has been ported
everywhere in the universe,

00:49:44.800 --> 00:49:47.370
has been ported as native tools,
cross-compiler tools,

00:49:47.370 --> 00:49:48.320
all that kind of stuff.

00:49:48.440 --> 00:49:52.310
So every combination of 64 and
32-bit you can think of has

00:49:52.310 --> 00:49:56.700
actually had to have been handled,
and there are a set of definitions in

00:49:56.840 --> 00:50:01.390
there that have been proven over time
to work well for this kind of thing.

00:50:02.220 --> 00:50:05.130
One of the special things that's come up,
and several people

00:50:05.190 --> 00:50:07.480
have had to solve this,
is what to do about

00:50:07.480 --> 00:50:09.100
these printf directives.

00:50:09.100 --> 00:50:12.100
It turns out there's not
standard macros for these,

00:50:12.100 --> 00:50:15.100
although it seems like
a really good idea.

00:50:15.100 --> 00:50:21.090
So you'll see some programs will actually
define macros for the printf directives.

00:50:21.100 --> 00:50:23.100
So I have an example here.

00:50:23.100 --> 00:50:27.560
If you want %lld to do the right thing,
and you don't want to say

00:50:27.660 --> 00:50:31.580
pass an integer to %lld,
because then that will grab the four

00:50:31.580 --> 00:50:38.640
bytes of your integer and the four bytes
of the next data item passed to printf,

00:50:39.210 --> 00:50:42.200
So you want it to
encapsulate this somehow.

00:50:42.260 --> 00:50:46.730
And so you can do something that
amounts to using string concatenation,

00:50:46.780 --> 00:50:48.110
which is a capability of C.

00:50:48.680 --> 00:50:51.620
And you have part of your string,
you have the macro with

00:50:51.620 --> 00:50:55.610
the directive in it,
and then you have the rest of the string.

00:50:55.760 --> 00:50:59.450
And this way you can get something
so that the compiler won't give you

00:50:59.450 --> 00:51:03.700
warnings about the printf directives
not matching up with the data types.

00:51:10.810 --> 00:51:13.900
So, further API changes we have.

00:51:13.930 --> 00:51:19.900
We give you a LP64 macro,
double underscores on the front

00:51:19.980 --> 00:51:23.420
and back because it's something
predefined by the compiler.

00:51:23.460 --> 00:51:33.030
And LP64, the value of it is 1 for 64-bit
compilation and 0 for 32-bit compilation.

00:51:34.000 --> 00:51:41.570
We also give you a PPC64 that's defined
when you're compiling for 64-bit

00:51:41.670 --> 00:51:45.090
PPC and is not defined for 32-bit PPC.

00:51:45.380 --> 00:51:49.690
And there was the existing macro,
double underscore PPC,

00:51:49.710 --> 00:51:54.340
is not defined when you're doing
64-bit PowerPC compilation.

00:51:54.440 --> 00:51:59.170
And we had a little debate on that
and we looked at the uses in practice

00:51:59.640 --> 00:52:01.100
and they were pretty much either/or.

00:52:01.100 --> 00:52:05.530
It was like either you're doing 32-bit
or you're doing 64-bit and if you

00:52:05.530 --> 00:52:09.980
turn on PPC and PPC64 at the same time
it would confuse a lot of headers.

00:52:10.040 --> 00:52:12.730
So we decided to make
them mutually exclusive.

00:52:12.970 --> 00:52:17.030
In practice,
you should almost never use PPC64

00:52:17.030 --> 00:52:21.230
directly because that's going to wire
in an architecture dependency unless

00:52:21.270 --> 00:52:25.100
you're actually literally writing
PowerPC code slipped into the middle

00:52:25.100 --> 00:52:26.780
of C code or something like that.

00:52:26.810 --> 00:52:29.980
You probably want to use
LP64 instead or else,

00:52:29.980 --> 00:52:35.650
if at all possible,
write the code to be 3264 independent.

00:52:37.970 --> 00:52:41.170
One of the things you'll see is, again,
if you look at the "Tiger" headers,

00:52:41.190 --> 00:52:44.150
you'll see we've made a bunch
of API changes where we had

00:52:44.150 --> 00:52:49.460
to choose whether an argument
was a long or an integer.

00:52:49.490 --> 00:52:53.550
And so I just thumbed through and found
this little bit out of a header file

00:52:53.550 --> 00:52:57.670
whose name I forgot to write down,
so I don't remember which one it is.

00:52:57.810 --> 00:53:00.760
The functions get at
our list and in the old,

00:53:00.770 --> 00:53:05.300
in the Panther headers,
the argument for them is said unsigned

00:53:05.300 --> 00:53:12.290
long and that would have an undesirable
consequence in the 64-bit world,

00:53:12.440 --> 00:53:14.440
so the header has been
changed to say unsigned int.

00:53:15.720 --> 00:53:23.550
However, the programs that have their own
declarations of the same system function,

00:53:23.690 --> 00:53:28.970
which happens,
would be inconsistent if they continue

00:53:28.970 --> 00:53:34.600
to say unsigned long and you had
unsigned int in the system header,

00:53:34.780 --> 00:53:38.600
so those are mostly
conditionalized on LP64.

00:53:38.600 --> 00:53:42.520
And this way we get backwards
compatibility with Panther code that

00:53:42.520 --> 00:53:44.600
may refer to the same prototype.

00:53:48.960 --> 00:53:52.090
We have one little API change
for assembly language,

00:53:52.190 --> 00:54:00.740
which is a new directive to allocate an
8-byte object and just call it ".quad".

00:54:01.060 --> 00:54:03.290
It's not the greatest name in the world,
but it's consistent with

00:54:03.310 --> 00:54:06.620
other assemblers that do this,
so that's why we chose it.

00:54:06.920 --> 00:54:10.220
The dot quad here,
I'm just feeding it a large constant,

00:54:10.220 --> 00:54:13.600
but it also works to
feed it a relocation.

00:54:13.770 --> 00:54:18.080
That's not very interesting right now,
but when the full 64-bit

00:54:18.180 --> 00:54:23.080
Mac OS file format is available,
you may end up wanting to

00:54:23.080 --> 00:54:25.480
use this in assembly code.

00:54:28.520 --> 00:54:31.500
So, I've alluded to warnings
a number of times.

00:54:31.570 --> 00:54:35.330
Now this time, you really have to pay
attention to the warnings.

00:54:35.430 --> 00:54:38.400
If you're getting a warning and it's
telling you about loss of precision

00:54:38.400 --> 00:54:42.900
or casting integers to pointers,
this time around it's not just for show.

00:54:43.050 --> 00:54:46.890
You really are going to lose
data and bad things will happen.

00:54:48.450 --> 00:54:51.340
One of the things you can do is
to add additional compiler options

00:54:51.840 --> 00:54:53.900
just to be on the safe side.

00:54:53.930 --> 00:54:57.550
In Xcode, you can say,
ask for other warning flags,

00:54:57.550 --> 00:55:02.300
which is the equivalent
of -w all for GCC users,

00:55:02.320 --> 00:55:05.320
and that will turn on lots
of additional warnings.

00:55:05.550 --> 00:55:07.350
And people are often annoyed.

00:55:07.360 --> 00:55:10.280
They say, well, W-Wall,
it turns on too many warnings.

00:55:10.280 --> 00:55:13.740
But actually,
in doing 64-bit programming,

00:55:13.740 --> 00:55:16.480
W-Wall is actually not all,
doesn't even list all the bad

00:55:16.480 --> 00:55:18.070
things that can happen to your code.

00:55:18.100 --> 00:55:22.070
So we have an additional option,
the -W conversion,

00:55:22.110 --> 00:55:25.500
which gives additional warnings
about conversions that might

00:55:25.670 --> 00:55:28.300
possibly lose data precision.

00:55:28.300 --> 00:55:32.100
And 64-bit,
if it says you might lose data precision,

00:55:32.100 --> 00:55:33.630
you probably are losing data.

00:55:33.640 --> 00:55:37.820
So we recommend using W conversion.

00:55:37.860 --> 00:55:40.530
You can also ask for
-W require prototypes,

00:55:40.560 --> 00:55:43.480
and there's not an Xcode
flag for it that I could see,

00:55:43.480 --> 00:55:45.640
so send in a radar for that.

00:55:45.640 --> 00:55:50.100
And what it does is it actually insists
that all your functions have prototypes.

00:55:50.100 --> 00:55:55.390
So if you have a forgotten piece of code
that was always quietly taking integers

00:55:55.390 --> 00:55:59.320
and assuming everything was okay,
-W require prototypes will

00:55:59.320 --> 00:56:03.440
flag them for you and say,
hey, you need prototypes there.

00:56:07.000 --> 00:56:10.960
Take a moment to talk about what
we do at Tools and Utilities.

00:56:11.030 --> 00:56:17.110
We have an extended set of APIs and
a few new APIs to handle tools that

00:56:17.120 --> 00:56:21.280
want to manipulate 64-bit processes,
but don't necessarily want

00:56:21.280 --> 00:56:22.790
to be 64-bit themselves.

00:56:22.900 --> 00:56:25.500
An obvious example is GDB.

00:56:25.950 --> 00:56:30.900
When you run GDB in Xcode,
it's actually a 32-bit program still,

00:56:30.900 --> 00:56:35.860
but it is manipulating a 64-bit process,
which is the program you're debugging.

00:56:37.340 --> 00:56:42.950
So the way we do that is we have
things like a type vm_address_t in

00:56:42.950 --> 00:56:52.110
the system headers and it's set to
a 64-bit type if PPC64 is enabled.

00:56:52.720 --> 00:56:55.940
We also have extended
APIs such as VM Read,

00:56:56.060 --> 00:57:01.150
which will read 64-bit addresses,
or will read data out

00:57:01.230 --> 00:57:03.600
of the 64-bit process.

00:57:04.220 --> 00:57:09.380
The OS guys have been slaving away
hard on this over the past few

00:57:09.790 --> 00:57:12.990
weeks to get all that to work.

00:57:16.070 --> 00:57:21.580
Now device drivers are running
in a 32-bit environment.

00:57:21.580 --> 00:57:27.460
We have a 32-bit kernel and this
is partly for efficiency and partly

00:57:27.460 --> 00:57:34.360
for to sort of have a single kernel
that runs in all types of systems.

00:57:34.430 --> 00:57:39.740
And we can do this actually because
the representation of memory,

00:57:39.740 --> 00:57:42.280
as you saw from the previous slide,
the representation of memory

00:57:42.390 --> 00:57:43.960
is as data structures.

00:57:44.080 --> 00:57:50.680
So a 32-bit compiled text can
actually manipulate the memory

00:57:50.680 --> 00:57:53.690
going into a 64-bit task.

00:57:54.190 --> 00:57:57.680
So specific names of the functions,
we have a prepare method that

00:57:57.680 --> 00:58:01.220
establishes I/O mappings,
and then we have specific

00:58:01.220 --> 00:58:06.330
routines both for use with
DMA and parallel I/O situations.

00:58:06.470 --> 00:58:13.030
Actually, it's probably not parallel I/O,
that just shows, but I'll let it,

00:58:13.030 --> 00:58:15.210
what's that?

00:58:15.590 --> 00:58:17.660
Programmed I/O, thank you God for it,
yes.

00:58:17.690 --> 00:58:19.340
I looked at it and it says, you know,
parallel I/O,

00:58:19.340 --> 00:58:21.330
that's like 8-bit microcomputers.

00:58:21.340 --> 00:58:23.990
That's probably not what
they meant in I/O Kit land.

00:58:24.230 --> 00:58:27.670
Okay, so yeah, so programmed I/O,
we have read bytes and

00:58:27.730 --> 00:58:29.250
write byte methods.

00:58:30.210 --> 00:58:34.100
So at least for now,
and there is a possibility we may have to

00:58:34.100 --> 00:58:39.120
do something with 64-bit device drivers,
and you have OS guys over on that side

00:58:39.120 --> 00:58:44.560
of the room that you can buttonhole
in the Q&A period to ask about that.

00:58:46.860 --> 00:58:53.860
Now if you're actually doing
64-bit I/O from a 64-bit process,

00:58:54.060 --> 00:58:57.450
the same POSIX APIs work as always.

00:58:57.580 --> 00:59:03.370
They've been essentially recompiled
to take 64-bit addresses and

00:59:03.370 --> 00:59:05.380
all that stuff has been done.

00:59:06.080 --> 00:59:10.130
If people have questions about
I/O KitLive and I/O User-Client

00:59:10.130 --> 00:59:16.750
plugins which are not available,
let's bring it up in the Q&A session.

00:59:18.840 --> 00:59:23.290
So I'd like to pop back up a little
bit and talk about the design issues

00:59:23.650 --> 00:59:27.720
that you might want to think about.

00:59:28.020 --> 00:59:32.260
One of the classic uses of
64-bit applications that have

00:59:32.260 --> 00:59:38.900
become prevalent in recent years
is to use them for servers.

00:59:38.950 --> 00:59:43.220
And servers are actually a
very interesting use because

00:59:44.140 --> 00:59:47.760
the classic model now,
what we've seen with Internet-type

00:59:47.930 --> 00:59:51.430
servers as the Internet's become popular,
is that they need to handle

00:59:51.560 --> 00:59:54.940
large numbers of clients,
in some cases maybe thousands

00:59:54.940 --> 00:59:56.900
of clients simultaneously.

00:59:56.900 --> 01:00:01.900
And it's very convenient to actually be
able to have a very large address space

01:00:01.900 --> 01:00:05.900
because then what you can do is have,
say, one thread per client,

01:00:05.900 --> 01:00:09.870
and have access to a single
large shared data space.

01:00:09.980 --> 01:00:11.900
So, for instance,
you're serving out images,

01:00:11.900 --> 01:00:14.970
you load every last one of
your images into memory so

01:00:14.970 --> 01:00:17.680
that it's readily available,
and you can serve it out to

01:00:18.090 --> 01:00:20.120
clients as they ask for them.

01:00:20.340 --> 01:00:24.410
This can actually be a very effective
approach for things like databases

01:00:24.950 --> 01:00:30.310
where you can lock on individual data
elements and you can have a single

01:00:30.310 --> 01:00:34.210
server managing all of those rather than
trying to do something with multiple

01:00:34.210 --> 01:00:37.570
server processes managing shared files.

01:00:37.910 --> 01:00:41.520
So the internet server is
a really interesting area

01:00:41.680 --> 01:00:43.840
to do 64-bit programming.

01:00:46.380 --> 01:00:50.190
We can generalize that a little bit and
talk about compute engines in general.

01:00:50.410 --> 01:00:56.240
And the TerraVision demo that you saw
yesterday that Steve Peters did is

01:00:56.240 --> 01:00:59.250
actually a classic example of that.

01:00:59.410 --> 01:01:02.140
We have a 32-bit GUI front end.

01:01:02.190 --> 01:01:06.310
We use inter-process communication
in one form or another going

01:01:06.310 --> 01:01:09.580
back to the compute engine,
which is handling the

01:01:09.580 --> 01:01:12.470
very large address space.

01:01:13.050 --> 01:01:18.400
What this does is essentially it
can shift the burden from your

01:01:18.570 --> 01:01:21.420
application code to the system.

01:01:21.750 --> 01:01:25.140
A lot of programs actually
already have mechanisms to

01:01:25.140 --> 01:01:28.000
handle large amounts of data.

01:01:28.180 --> 01:01:31.960
What they'll do is they'll manually
page in data as needed and then page

01:01:31.960 --> 01:01:34.370
it out and then page in different data.

01:01:34.820 --> 01:01:38.980
And with the 64-bit capability,
you actually wouldn't

01:01:39.030 --> 01:01:40.000
have to do that anymore.

01:01:40.070 --> 01:01:45.500
You could just allocate large amounts
of memory and suck it in and use it and

01:01:45.500 --> 01:01:46.890
never have to worry about running out.

01:01:47.060 --> 01:01:51.970
And if you have a piece of data
that's not being used at the moment,

01:01:51.970 --> 01:01:56.300
you can essentially rely on the virtual
memory system to page it out for you.

01:01:56.440 --> 01:01:59.160
So in a sense,
what it's doing is it's replacing

01:01:59.160 --> 01:02:00.940
your code with a system code.

01:02:01.080 --> 01:02:03.730
And that can be a great advantage
because now it's not you having to

01:02:03.730 --> 01:02:08.380
write all this stuff and play computer
scientist and read about VM memory items.

01:02:08.800 --> 01:02:13.090
You can let the friendly experts
at Apple take care of that for you.

01:02:13.750 --> 01:02:17.420
Now it may be that you know something
about your application's memory

01:02:18.000 --> 01:02:22.640
usage that will be actually more
efficient than the generic OS can do.

01:02:22.660 --> 01:02:26.460
And you basically have to reevaluate
that for your own application.

01:02:26.460 --> 01:02:28.460
Do you have a usage pattern?

01:02:28.500 --> 01:02:30.650
Do you always have something
that's always first in,

01:02:30.760 --> 01:02:34.380
first out, and that doesn't necessarily
play nicely with the last in,

01:02:34.480 --> 01:02:36.810
first out in the VM system?

01:02:36.930 --> 01:02:39.580
And that's just going to depend
on you with your application.

01:02:39.600 --> 01:02:44.730
If you already have a memory management
algorithm that you know is more efficient

01:02:44.740 --> 01:02:48.320
than anybody else in the world can do,
then you probably want to stick

01:02:48.320 --> 01:02:52.320
with it and maybe even stick
with using a 32-bit program and

01:02:52.400 --> 01:02:54.850
continue to exploit your algorithm.

01:02:55.380 --> 01:02:58.000
But it's the kind of thing you
want to actually stop a moment,

01:02:58.120 --> 01:03:01.580
take a look at and say, you know,
is this the best algorithm or

01:03:01.580 --> 01:03:06.560
can I leverage Apple's VM system
and get something better?

01:03:09.890 --> 01:03:18.590
So, what 64-bit does for us is that it
really opens up a lot of new vistas.

01:03:18.590 --> 01:03:21.800
And I've talked about a couple
of very specific things,

01:03:21.830 --> 01:03:24.800
but they're things we already know about.

01:03:24.800 --> 01:03:28.020
There's actually all kinds
of opportunities that we

01:03:28.020 --> 01:03:29.800
really don't know about.

01:03:29.800 --> 01:03:33.880
I was actually talking with one of
our guys last night and thinking about

01:03:33.880 --> 01:03:35.800
that surface of the earth analogy.

01:03:35.800 --> 01:03:40.660
And in fact, if you think about it,
every point on the surface of the earth

01:03:40.680 --> 01:03:43.800
is identifiable with a 64-bit number.

01:03:43.920 --> 01:03:46.380
So you could write an application,
for instance,

01:03:46.380 --> 01:03:49.460
in which instead of maintaining, say,
a linked list of locations

01:03:49.910 --> 01:03:54.290
stored as 64-bit values,
you record data about a point on

01:03:54.290 --> 01:03:56.780
the earth at that memory address.

01:03:56.800 --> 01:03:59.800
So essentially,
you're storing data on the earth.

01:03:59.800 --> 01:04:02.800
You use the entire 64-bit address space.

01:04:02.870 --> 01:04:05.720
The point under my feed, you know,
is 4589.

01:04:05.800 --> 01:04:09.800
And you record the color of
the carpet at that location.

01:04:09.800 --> 01:04:13.700
And you just record it directly
at that memory location.

01:04:13.800 --> 01:04:17.230
And as you read and write that data,
the VM system will handle

01:04:17.230 --> 01:04:18.800
the paging of that blob.

01:04:18.800 --> 01:04:20.770
So, that's kind of exotic, right?

01:04:20.860 --> 01:04:21.800
You know, you think about, well,
that's kind of silly.

01:04:21.800 --> 01:04:22.800
Who would do that?

01:04:22.800 --> 01:04:25.540
But the thing is,
that's actually something you can do and

01:04:26.040 --> 01:04:27.700
something you couldn't do previously.

01:04:27.800 --> 01:04:30.800
So, you know, maybe it's a good idea,
maybe it's not.

01:04:30.800 --> 01:04:32.500
So the real bottom line in all
this is that these kinds of

01:04:32.500 --> 01:04:34.800
applications are actually only
limited by a single application.

01:04:34.800 --> 01:04:37.800
They're actually only
limited by your imagination.

01:04:37.800 --> 01:04:40.070
In the final tiger,
we're going to give you the

01:04:40.180 --> 01:04:41.800
full 64-bit address space.

01:04:41.930 --> 01:04:44.800
And most other systems
don't give you that much.

01:04:44.800 --> 01:04:45.800
They give you somewhat less than that.

01:04:45.800 --> 01:04:48.800
So they give you the whole thing,
and we're actually very excited

01:04:48.800 --> 01:04:52.800
to see what you'll think of
to do with it in the future.

01:04:53.900 --> 01:04:59.550
So that's my part,
and I'd like to bring up Matt Formica to

01:04:59.560 --> 01:05:03.340
do the wrap up and do the Q&A session.

01:05:03.360 --> 01:05:05.380
And thank you very much.

01:05:11.060 --> 01:05:15.170
So you've seen a lot of
information about 64-bit today.

01:05:15.250 --> 01:05:19.600
There is further documentation
information available for you.

01:05:19.650 --> 01:05:23.900
The main thing right now is the 64-bit
transition guide that's been written.

01:05:23.900 --> 01:05:27.540
It provides kind of the state of
the world right now in Tiger with

01:05:27.660 --> 01:05:29.660
the preview DVD that you have.

01:05:29.660 --> 01:05:34.380
So that's the best place to get
information about what we're doing.

01:05:35.370 --> 01:05:38.000
We're now going to
bring up our Q&A panel.

01:05:38.000 --> 01:05:40.080
We have a bunch of engineers
who are going to come up.

01:05:40.360 --> 01:05:44.300
You can certainly talk with us,
ask questions this week.

01:05:44.300 --> 01:05:47.490
Beyond this week,
feel free to send me an email.

01:05:47.490 --> 01:05:50.300
I'm the developer tools
evangelist here at Apple.

01:05:50.300 --> 01:05:52.600
My email is mformica@apple.com.

01:05:52.610 --> 01:05:57.000
I'd love to communicate
with you via email about the

01:05:57.070 --> 01:05:59.300
64-bit tool set on Mac OS X.
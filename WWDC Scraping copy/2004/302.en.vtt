WEBVTT

00:00:14.200 --> 00:00:18.930
This is what we're
going to explore today.

00:00:19.760 --> 00:00:22.570
I'd like to give you some
context for this language

00:00:22.660 --> 00:00:27.040
because I feel it's important for
understanding the design decisions,

00:00:27.050 --> 00:00:33.700
the trade-offs we made, and in fact,
the roots of both of these languages.

00:00:33.890 --> 00:00:37.700
If you look at when C++
and Objective-C were born,

00:00:37.700 --> 00:00:41.700
they were both born in the mid-80s,
roughly speaking,

00:00:41.960 --> 00:00:46.960
and C++ drew inspiration from
Simula and Objective-C drew

00:00:46.960 --> 00:00:48.700
inspiration from Smalltalk.

00:00:48.790 --> 00:00:51.850
And some of the terminology
features and mindsets and,

00:00:51.850 --> 00:00:54.530
in fact,
culture that surround these languages

00:00:54.620 --> 00:00:59.700
I hope to expose to give you some sense
for why one language works one way,

00:00:59.700 --> 00:01:02.290
why another language solves
a different set of problems,

00:01:02.360 --> 00:01:06.280
and why the combination of them
is actually pretty exciting.

00:01:10.870 --> 00:01:15.080
I also want to give you many examples
because if we just talk in the abstract,

00:01:15.080 --> 00:01:17.260
you're not going to get a
good feel for the language.

00:01:17.260 --> 00:01:19.810
The best way to learn the
language is through examples.

00:01:19.810 --> 00:01:23.100
So the examples I'm going to be
giving are from WebKit Safari.

00:01:23.100 --> 00:01:27.450
There are some examples from the
Celestia application that you've seen.

00:01:27.730 --> 00:01:31.350
There are some examples
from our developer examples.

00:01:31.350 --> 00:01:33.490
So if you want to try some
of these when you get home,

00:01:33.650 --> 00:01:37.400
you can go and look at the code that
in fact we'll be presenting here.

00:01:37.400 --> 00:01:39.910
And lastly,
I want to talk about some gotchas.

00:01:39.990 --> 00:01:43.100
It's a very complex language,
and there are a few gotchas.

00:01:43.100 --> 00:01:45.640
I don't think they
affect too many people,

00:01:45.640 --> 00:01:48.120
but it's still relevant in
the context of this talk.

00:01:48.230 --> 00:01:50.150
And lastly,
I don't have this on the slide,

00:01:50.160 --> 00:01:52.710
but I'd love to interact
with you folks for about 15,

00:01:52.710 --> 00:01:55.300
20 minutes,
so I'm hoping I could zoom through

00:01:55.300 --> 00:01:59.950
the presentation and customize it to
what you guys want to know afterwards.

00:02:00.880 --> 00:02:05.260
So, to cut to the chase,
why isn't Cocoa written in C++?

00:02:05.320 --> 00:02:08.460
We wouldn't be here talking
about the combined languages if,

00:02:08.460 --> 00:02:10.630
in fact, Cocoa was written in C++.

00:02:10.740 --> 00:02:14.700
And the simple answer is it
doesn't meet Coco's needs.

00:02:14.700 --> 00:02:17.700
So before I explain why it
doesn't meet Coco's needs,

00:02:17.700 --> 00:02:20.700
I'm going to try and go
through what are Coco's needs,

00:02:20.700 --> 00:02:24.700
what are the language requirements,
what are the runtime requirements

00:02:24.700 --> 00:02:29.750
that we have for Cocoa to set the
stage for understanding the language.

00:02:30.410 --> 00:02:32.530
Number one: easy to learn.

00:02:32.890 --> 00:02:33.710
Less is more.

00:02:33.890 --> 00:02:36.860
We want to be able to teach
someone the language that

00:02:36.860 --> 00:02:39.300
Coco's written in in a week,
max.

00:02:39.300 --> 00:02:42.100
I think we're going to cover most
of the language here fairly well,

00:02:42.100 --> 00:02:47.260
and I think you'll get a good feel
for Objective-C in a couple of hours,

00:02:47.260 --> 00:02:48.300
roughly.

00:02:48.370 --> 00:02:54.450
But we want people to focus on the API,
so we want to take the spotlight from the

00:02:54.450 --> 00:02:56.300
language and move it to the frameworks.

00:02:56.300 --> 00:02:59.300
That's one of the bigger reasons
we wanted it to be easy to learn.

00:02:59.300 --> 00:03:03.770
We don't want you to focus or
struggle with the language.

00:03:04.160 --> 00:03:06.500
We want to embrace existing code.

00:03:06.550 --> 00:03:09.500
This has been part of the
mindset for many years.

00:03:09.500 --> 00:03:13.820
That is, this isn't Java where we're
trying to basically give you a

00:03:13.860 --> 00:03:18.180
clean new world that you have to
conform to in a homogeneous way.

00:03:18.180 --> 00:03:23.840
We want you to be able to
bring over your C code,

00:03:23.840 --> 00:03:25.790
your C++ code,
and leverage it in the context

00:03:25.790 --> 00:03:25.790
of this very dynamic environment.

00:03:26.690 --> 00:03:31.260
And lastly, and most importantly,
we want a dynamic object model.

00:03:31.390 --> 00:03:35.200
The dynamic object model is what
enables many of the cool features

00:03:35.200 --> 00:03:37.700
that you see in these presentations,
whether it be

00:03:37.700 --> 00:03:39.870
Cocoa Bindings or Automator.

00:03:40.120 --> 00:03:43.120
Many of these very cool features
are because we have dynamic

00:03:43.120 --> 00:03:47.110
plumbing underneath the covers that
actually allows us to do some very,

00:03:47.110 --> 00:03:48.700
very interesting things.

00:03:48.860 --> 00:03:51.500
And if you don't write
frameworks for a living,

00:03:51.500 --> 00:03:53.780
you don't sometimes think about it.

00:03:53.850 --> 00:03:57.720
So if you're an application programmer,
I'm hoping that if you haven't

00:03:57.780 --> 00:04:00.900
thought about some of these features,
we're going to put them in a

00:04:00.940 --> 00:04:03.600
context that's going to make them
much more interesting to you.

00:04:03.690 --> 00:04:08.070
So it's very important that we serve the
frameworks and the interactive tools.

00:04:08.370 --> 00:04:11.070
What are the runtime requirements?

00:04:11.460 --> 00:04:15.290
As most of you know, in the mid-80s,
we weren't dealing with machines

00:04:15.290 --> 00:04:19.400
and memory models that were vast,
as vast as today.

00:04:19.400 --> 00:04:26.120
For instance, Objective-C ran fairly well
on two-megabyte workstations.

00:04:26.400 --> 00:04:29.680
And today, as you know,
most workstations ship

00:04:29.680 --> 00:04:34.320
with 256 megabytes,
512, whatever, quite a bit more than

00:04:34.320 --> 00:04:35.400
it was designed for.

00:04:35.530 --> 00:04:40.380
So it's very clear that Objective-C,
having been born in that age,

00:04:40.380 --> 00:04:44.350
scales nicely to today's machines.

00:04:45.400 --> 00:04:51.280
It's very critical that when we ship new
features that we don't break your code.

00:04:51.390 --> 00:04:56.940
Now, if you look at how many releases of
Cocoa we've made and lots of frameworks,

00:04:57.030 --> 00:04:58.160
we've been very successful.

00:04:58.300 --> 00:05:03.220
In fact, I think we're the only operating
system that I know of that is

00:05:03.220 --> 00:05:06.980
fairly object-oriented and hasn't,
in fact,

00:05:06.980 --> 00:05:09.960
broken people with some regularity.

00:05:09.980 --> 00:05:14.530
So everything's shared,
and we try not to break people.

00:05:14.770 --> 00:05:19.550
We have a C-based API, and this, again,
doesn't really affect you directly,

00:05:19.680 --> 00:05:20.340
but indirectly.

00:05:20.340 --> 00:05:22.750
That is,
we feel strongly that Objective-C has

00:05:22.750 --> 00:05:24.660
to interact with other languages.

00:05:24.740 --> 00:05:28.080
So, for instance, the first two up there:
Cocoa Java is a bridge

00:05:28.120 --> 00:05:29.700
that Apple supports.

00:05:29.700 --> 00:05:32.290
AppleScript Studio is another
product that allows you from

00:05:32.290 --> 00:05:34.550
AppleScript to do Cocoa programming.

00:05:34.780 --> 00:05:38.120
And then there's a whole bunch of
third-party scripting languages:

00:05:38.290 --> 00:05:40.700
Python for Objective-C, Ruby, Cocoa,
Perl.

00:05:40.700 --> 00:05:44.550
In fact, C# is being added to the list
of languages that are going to

00:05:44.550 --> 00:05:48.700
be available to interact with
Cocoa and bind with Objective-C.

00:05:48.700 --> 00:05:51.770
So, we're really excited
to see third parties,

00:05:51.780 --> 00:05:56.870
in fact, integrate with this runtime,
which we consider fairly flexible.

00:05:58.640 --> 00:06:01.540
So to wrap it up,
it's designed to serve the dynamic

00:06:01.540 --> 00:06:06.140
frameworks and tools and enables you
to integrate your C code with Cocoa.

00:06:06.140 --> 00:06:08.590
But what this talk is
about is Objective-C++,

00:06:08.730 --> 00:06:12.320
which is the same exact design point.

00:06:12.570 --> 00:06:15.130
It just enables you
to integrate C++ code.

00:06:15.140 --> 00:06:22.300
So it's not as if the object
modules are there to compete.

00:06:22.300 --> 00:06:22.300
They're there to work together.

00:06:23.290 --> 00:06:27.500
So now let's get back to why
C++ doesn't meet Coco's needs.

00:06:27.560 --> 00:06:31.540
It's a strongly-typed
static object model.

00:06:31.570 --> 00:06:37.270
This is one of the properties that makes
it hard to evolve systems over time.

00:06:38.510 --> 00:06:41.200
There's no runtime support for
dynamic loading or reflection.

00:06:41.200 --> 00:06:45.580
Again, many features that we provide in
our tools would not be possible

00:06:45.580 --> 00:06:49.310
with the standard C++ definition
as many of you use it today.

00:06:49.670 --> 00:06:58.430
It is possible to expand the definition,
but we view C++ as a standard

00:06:58.430 --> 00:06:58.430
language which we try not to extend.

00:06:58.730 --> 00:07:01.940
And runtime model is fragile
and compiler-dependent.

00:07:01.990 --> 00:07:04.700
This is a feature which
has hurt C++ significantly.

00:07:04.700 --> 00:07:09.070
One of the reasons Java is
so popular today is because

00:07:09.150 --> 00:07:12.100
it doesn't suffer from this.

00:07:12.100 --> 00:07:14.840
Shared libraries are
critical for deploying code,

00:07:14.940 --> 00:07:18.700
and it contributes to this
culture of code copying,

00:07:18.700 --> 00:07:21.130
where if you can't share
something and not break it,

00:07:21.290 --> 00:07:21.980
you want to own it.

00:07:22.080 --> 00:07:25.190
You want to copy it in yourself so,
in fact, you won't break.

00:07:25.280 --> 00:07:27.860
And, in fact,
if you have many applications using many

00:07:27.900 --> 00:07:31.930
large frameworks and they're all copied,
you can imagine what the memory

00:07:31.930 --> 00:07:34.150
footprint of your system would be like.

00:07:35.030 --> 00:07:38.800
So, Objective-C++ design points.

00:07:39.130 --> 00:07:40.970
Peaceful coexistence, right?

00:07:41.220 --> 00:07:45.840
We want to use C++ as the base,
and the parser has been modified

00:07:45.840 --> 00:07:48.390
to layer Objective-C atop C++.

00:07:48.480 --> 00:07:51.110
One of the smartest
things I think we did was,

00:07:51.310 --> 00:07:55.150
many years ago, was we implemented
Objective-C in the GNU compiler,

00:07:55.220 --> 00:07:59.600
and that work happened in '88, roughly.

00:07:59.820 --> 00:08:07.690
That work, along with the C++
work that was going on,

00:08:07.690 --> 00:08:07.690
enabled us to marry them
with fairly low effort.

00:08:09.430 --> 00:08:11.780
Both runtime systems are unchanged.

00:08:11.990 --> 00:08:15.440
Okay, the native ABI, the semantics,
and the performance that you

00:08:15.440 --> 00:08:17.130
expect from C++ is what you get.

00:08:17.300 --> 00:08:20.600
It's not like we're changing
the way you do virtual function

00:08:20.600 --> 00:08:22.690
dispatch or any other things in C++.

00:08:22.800 --> 00:08:27.260
We are letting C++ have its own turf
and Objective-C have its own turf,

00:08:27.310 --> 00:08:30.090
and we think that works very nicely.

00:08:32.160 --> 00:08:42.110
Now, subclassing across object
models is not supported.

00:08:42.110 --> 00:08:42.110
Aggregation, we think,
works great for this.

00:08:42.710 --> 00:08:47.070
In the early days when we
used to present this language,

00:08:47.170 --> 00:08:48.760
people got really freaked out by that.

00:08:48.880 --> 00:08:50.740
They said, "God, you can't subclass?

00:08:50.800 --> 00:08:53.700
Is it really useful if
you can't subclass?" Well,

00:08:53.700 --> 00:08:57.300
I think what's happened over time is
people actually have learned through

00:08:57.300 --> 00:09:01.810
many iterations of designing object
systems that inheritance is often not

00:09:01.990 --> 00:09:04.360
the best tool for performing something.

00:09:04.360 --> 00:09:07.150
So one of the things I'm
going to talk about is how,

00:09:07.150 --> 00:09:12.020
in fact, Cocoa uses delegation,
composition, aggregation as programming

00:09:12.020 --> 00:09:14.600
idioms and tools,
which, in fact, again,

00:09:14.600 --> 00:09:18.430
make it a natural marriage because
we don't require subclassing

00:09:18.430 --> 00:09:20.800
just by virtue of our dynamism.

00:09:21.300 --> 00:09:26.920
So, subclassing isn't supported,
so why don't we unify the object models?

00:09:27.090 --> 00:09:30.830
People sometimes ask,
who haven't carefully considered

00:09:30.830 --> 00:09:35.350
some of the implications,
"Why don't we just change C++

00:09:35.350 --> 00:09:39.840
to work like Objective-C?" Well,
there are systems that

00:09:39.900 --> 00:09:41.600
have been tried over time.

00:09:41.600 --> 00:09:44.250
SOM is one of them,
the system object model that

00:09:44.250 --> 00:09:49.200
Apple and IBM worked on years ago,
and even COM to some extent by Microsoft,

00:09:49.220 --> 00:09:53.650
that are actually systems designed
to try and fix some of the problems

00:09:53.750 --> 00:09:58.100
with deploying C++ shared objects
and the static object model.

00:09:58.310 --> 00:10:01.300
It turns out that because
they were unsuccessful,

00:10:01.370 --> 00:10:05.780
we chose not to go that path,
rather marry Objective-C and

00:10:05.780 --> 00:10:07.590
C++ as we've done.

00:10:07.900 --> 00:10:09.290
So, let's go through the benefits.

00:10:09.540 --> 00:10:11.400
It's portable.

00:10:11.450 --> 00:10:16.370
It's amazing how even changing
initialization order of the order

00:10:16.370 --> 00:10:19.470
in which constructors are run,
that that breaks some

00:10:19.470 --> 00:10:20.790
of you guys out there.

00:10:20.800 --> 00:10:24.140
I work in the tools team where
we're constantly looking at

00:10:24.580 --> 00:10:27.950
easier ways to port your apps
and what headbutts you bump into,

00:10:28.150 --> 00:10:32.800
and initialization order isn't
something that the standard dictates.

00:10:32.800 --> 00:10:35.790
That is, it says each system can
do it however it wants.

00:10:36.020 --> 00:10:38.800
Well, in fact, by the letter of the law,
we work just fine.

00:10:38.910 --> 00:10:42.770
However, we, again,
break some of your code because we

00:10:42.770 --> 00:10:47.800
don't do it in a specific way that,
let's say, was born on Windows or Linux.

00:10:47.800 --> 00:10:50.300
So, again,
we want to make things portable,

00:10:50.430 --> 00:10:53.780
and if initialization order is a problem,
if we change the way dispatch work,

00:10:53.900 --> 00:10:55.740
believe me, we'd break all of you.

00:10:55.800 --> 00:10:57.540
So, performance.

00:10:57.850 --> 00:11:01.100
The performance of an
application is often dictated

00:11:01.100 --> 00:11:02.800
by the way it does dispatch.

00:11:02.800 --> 00:11:04.620
The fine-grain model,
coarse-grain model of

00:11:04.620 --> 00:11:05.710
the object orientation.

00:11:05.800 --> 00:11:09.530
And Objective-C is just
designed for more coarse-grain,

00:11:09.530 --> 00:11:14.770
mid-grain dynamism and not the very
fine-grain stuff that people use C++ for.

00:11:14.930 --> 00:11:18.770
So, it would be naive to think that
the same performance considerations

00:11:18.820 --> 00:11:22.010
that we apply to a dynamic,
more coarse-grain object model

00:11:22.170 --> 00:11:23.540
apply to a fine-grain one.

00:11:23.800 --> 00:11:27.800
And thirdly, we want to be pragmatic.

00:11:27.800 --> 00:11:30.800
Someone said to me outside the other
day how one of the beauties of coming

00:11:30.800 --> 00:11:30.800
to this conference is that we're not
just trying to make things portable.

00:11:30.800 --> 00:11:31.800
We're trying to make
things more practical.

00:11:31.800 --> 00:11:35.230
And I think that's the key to the
success of coming to this conference

00:11:35.340 --> 00:11:38.600
and seeing what Apple does and
seeing Steve's keynote is how we're

00:11:38.720 --> 00:11:40.800
very good at finding the sweet spot.

00:11:40.800 --> 00:11:44.080
And that's why we're able to
make releases on a yearly basis

00:11:44.080 --> 00:11:47.800
and show you guys cool stuff is
because we find the sweet spot.

00:11:47.800 --> 00:11:50.800
And I think Objective-C C++
is a good example of that.

00:11:50.800 --> 00:11:52.690
It's pragmatic and it works.

00:11:53.320 --> 00:11:55.900
So now let's go into the
code section of the talk.

00:11:56.050 --> 00:12:00.190
Here is Hello World in four dialects.

00:12:00.240 --> 00:12:03.740
You have the first header file, std::io.

00:12:03.860 --> 00:12:05.040
You guys are all familiar with that.

00:12:05.040 --> 00:12:07.040
There's iostream,
and then there's foundation.

00:12:07.120 --> 00:12:10.040
So you can see the standard
printf::hello-world.

00:12:10.070 --> 00:12:11.790
You can see the C++ version.

00:12:11.790 --> 00:12:13.630
It's in all the C++ books.

00:12:13.740 --> 00:12:18.200
Then there's a couple more statements
that give you the Objective-C version.

00:12:18.200 --> 00:12:20.670
Now, that string constant,
for those of you who

00:12:20.670 --> 00:12:24.700
haven't seen Objective-C,
a string constant preceded by an @

00:12:24.700 --> 00:12:29.200
sign is a constant string object.

00:12:29.400 --> 00:12:31.810
The compiler is responsible
for creating it,

00:12:31.810 --> 00:12:33.990
and you can see it's initialized there.

00:12:34.200 --> 00:12:38.200
And then there's the combination of them,
which is pretty seamless.

00:12:38.200 --> 00:12:43.550
So you have standard out taking
as output the C string coming from

00:12:43.550 --> 00:12:48.200
the Objective-C string object,
and then outputting the ++.

00:12:48.200 --> 00:12:54.200
So you can see that that's
fairly easy to program.

00:12:54.200 --> 00:12:58.200
So here's just how you compile it,
just to show you that the file,

00:12:58.200 --> 00:13:00.200
the suffix is .mm.

00:13:00.200 --> 00:13:04.180
We don't have to get into the
details of why it's called .mm,

00:13:04.300 --> 00:13:07.600
but it contains the mixed languages,
and it's linking against

00:13:07.600 --> 00:13:10.200
the standard C++ library,
which is a static library,

00:13:10.200 --> 00:13:13.920
not a shared library,
and it's linking against the frameworks,

00:13:13.920 --> 00:13:15.200
the foundation framework.

00:13:15.200 --> 00:13:17.200
So pretty easy stuff.

00:13:17.200 --> 00:13:19.200
Now, again, one detail.

00:13:19.200 --> 00:13:22.690
Right now we're shipping the
standard C++ library as what

00:13:22.690 --> 00:13:25.150
we call an archive library,
a non-shared library.

00:13:25.240 --> 00:13:29.180
So if you look at that executable,
it's actually fairly big.

00:13:29.270 --> 00:13:36.200
It contains the whole standard C++
library contained within the Hello world.

00:13:36.200 --> 00:13:39.160
In a future release,
we're going to be releasing

00:13:39.370 --> 00:13:41.200
a shared version of that.

00:13:42.680 --> 00:13:48.260
Now I want to go through
some just syntactic idioms,

00:13:48.260 --> 00:13:50.310
and I also want to go
through some terminology.

00:13:50.320 --> 00:13:52.520
Here's what a class looks like,
at interface.

00:13:52.520 --> 00:13:54.880
So let's get the at stuff out of the way.

00:13:54.880 --> 00:13:55.680
Why do we use at?

00:13:55.720 --> 00:14:00.740
The reason we prefix our keywords with at
is we didn't want to break existing code.

00:14:00.760 --> 00:14:01.620
It's that simple.

00:14:01.620 --> 00:14:04.200
You know, some people get freaked
out by the at sign,

00:14:04.200 --> 00:14:05.250
but that is the reason.

00:14:05.260 --> 00:14:08.360
It's we don't want to break code,
because code contains interface.

00:14:08.360 --> 00:14:10.100
Code contains end.

00:14:10.640 --> 00:14:14.420
And code contains other keywords
that we wanted to publish.

00:14:14.420 --> 00:14:16.790
So that's why we use at.

00:14:16.800 --> 00:14:19.140
And it's a single inheritance model.

00:14:19.140 --> 00:14:22.310
So right there, the class is my class.

00:14:22.430 --> 00:14:23.910
The superclass is NSObject.

00:14:23.980 --> 00:14:29.460
For purposes of this discussion,
Objective-C is single-rooted.

00:14:29.460 --> 00:14:32.030
It turns out that you can
provide your own root class,

00:14:32.080 --> 00:14:36.580
but that's something for an advanced
session that is a topic for another day.

00:14:36.580 --> 00:14:39.960
Oh, just briefly.

00:14:39.960 --> 00:14:40.620
Instance version.

00:14:40.620 --> 00:14:45.470
The term instance variable is a
small talk jargon or terminology.

00:14:45.480 --> 00:14:50.540
In C++, if, in fact,
some of you have just programmed in C++,

00:14:50.540 --> 00:14:53.390
you would know that as data members,
right?

00:14:53.430 --> 00:14:55.870
So members, data members,
instance variables map

00:14:56.290 --> 00:14:58.400
into the same concept.

00:14:58.400 --> 00:15:03.840
So here we have a C type, an int,
named X.

00:15:03.840 --> 00:15:05.980
We have an NSView named Y.

00:15:05.980 --> 00:15:08.140
And we have an Iostream named S.

00:15:08.140 --> 00:15:10.500
So you can see we have three
different declarations here.

00:15:11.000 --> 00:15:14.540
That all contain different types.

00:15:16.300 --> 00:15:17.200
Here are some methods.

00:15:17.200 --> 00:15:20.800
There are instance methods, and again,
the term "method" comes from small talk.

00:15:20.820 --> 00:15:23.180
Instance method, class method.

00:15:23.300 --> 00:15:30.030
In C++, this would be member functions,
and -- well, non-static member functions

00:15:30.040 --> 00:15:31.200
and member functions.

00:15:31.250 --> 00:15:35.200
And here we have a set-target
method and a set-action method.

00:15:35.210 --> 00:15:37.200
Now, notice the colons.

00:15:37.200 --> 00:15:39.200
The colons would separate the
key -- what's called the keyword

00:15:39.200 --> 00:15:43.200
argument from the actual type
and the name of the argument.

00:15:43.350 --> 00:15:47.200
If you leave out the type in Objective-C,
it means it's an ID.

00:15:47.200 --> 00:15:50.200
We'll get into what
ID means in a little while.

00:15:50.200 --> 00:15:53.200
So here we have a set-cell class.

00:15:53.200 --> 00:15:55.200
That's actually a class object.

00:15:55.330 --> 00:15:57.170
We'll get into that as well later.

00:15:57.250 --> 00:15:58.200
And selectors.

00:15:58.310 --> 00:16:01.190
Selectors are a unique name for a method.

00:16:01.330 --> 00:16:04.200
Okay,
so they're like pointers to functions,

00:16:04.200 --> 00:16:08.200
except they represent the name,
and they're unique per process.

00:16:08.200 --> 00:16:10.980
And we'll talk a little
bit later about that.

00:16:11.980 --> 00:16:14.760
So, so far we have a class interface,
we have instance variables,

00:16:14.820 --> 00:16:15.470
we have methods.

00:16:15.820 --> 00:16:17.490
Here's an abstract type declaration.

00:16:17.560 --> 00:16:23.990
Objective-C decided to formalize the
notion of abstract types years ago,

00:16:24.050 --> 00:16:26.300
and it's been something that's
worked really well for us.

00:16:26.310 --> 00:16:32.300
So an abstract type is a type where you
don't specify the instance variables,

00:16:32.300 --> 00:16:38.410
you don't specify the superclass,
you just specify what the operations

00:16:38.410 --> 00:16:40.770
that are expected of the type are.

00:16:40.900 --> 00:16:44.360
So here's the NSDraggingInfo protocol.

00:16:44.660 --> 00:16:50.370
This is a set of methods which
will all be given to the AppKit,

00:16:50.370 --> 00:16:53.430
and they will delegate to your object.

00:16:54.150 --> 00:16:55.760
Here's an abstract type implementation.

00:16:55.760 --> 00:16:57.070
So you can see NSString.

00:16:57.280 --> 00:17:01.200
It inherits from NSObject,
and it conforms to three protocols.

00:17:01.200 --> 00:17:04.370
So here's an example where
Objective-C has single

00:17:04.370 --> 00:17:09.000
inheritance of implementation,
but multiple inheritance of interface,

00:17:09.000 --> 00:17:12.710
which is a very common metaphor
that we use in Cocoa and

00:17:12.710 --> 00:17:14.470
that works very well for us.

00:17:14.520 --> 00:17:19.140
So here, again,
we have three different interfaces or

00:17:19.150 --> 00:17:22.600
protocols and a couple methods there.

00:17:24.960 --> 00:17:28.160
So here is three different
object declarations.

00:17:28.300 --> 00:17:31.290
In C++, you've probably never
seen anything like ID.

00:17:31.390 --> 00:17:35.100
It's an object-oriented void star,
pretty much.

00:17:35.250 --> 00:17:40.660
And it says, "Here is any object." Now,
the difference is that object

00:17:40.660 --> 00:17:42.780
has metadata associated with it.

00:17:42.850 --> 00:17:46.350
So in fact, it's not as bad as a void
star in that a void star,

00:17:46.350 --> 00:17:49.800
you know nothing about it except
by looking at the source code.

00:17:49.800 --> 00:17:54.800
At runtime, you could actually infer
what the type of object is.

00:17:57.440 --> 00:18:02.380
Now, the second statement declaration
there is an NSBrowser*.

00:18:02.820 --> 00:18:07.880
In Objective-C, when you type an object,
that's there just for documentation.

00:18:08.230 --> 00:18:09.100
Okay?

00:18:09.100 --> 00:18:13.250
It tells the reader that
that--any browser is an NSBrowser.

00:18:13.300 --> 00:18:16.540
It doesn't affect how the
compiler will do binding.

00:18:16.600 --> 00:18:19.400
So dynamic dispatch,
all the dynamic properties still

00:18:19.400 --> 00:18:22.510
apply even though it's been typed.

00:18:23.060 --> 00:18:26.480
And the third declaration there says,
"I have any object that conforms to the

00:18:26.480 --> 00:18:30.710
ns-dragging-info protocol," which is
what I just showed in the previous slide.

00:18:30.900 --> 00:18:36.000
So that means any class that can
conform to that protocol will

00:18:36.280 --> 00:18:38.890
be accepted by the compiler.

00:18:39.040 --> 00:18:42.490
What's really neat about this, again,
is you don't have to know

00:18:42.600 --> 00:18:44.310
what type of object it is.

00:18:44.400 --> 00:18:45.900
Now, you could even provide a list there.

00:18:45.900 --> 00:18:50.400
It's fairly uncommon,
but just as you had a list within

00:18:50.400 --> 00:18:53.900
the class declaration context,
you could have a list here as well.

00:18:54.180 --> 00:18:58.900
Another point, as contrast to Java,
is Java integrates the abstract type

00:18:58.900 --> 00:19:00.890
namespace in with the class namespace.

00:19:00.900 --> 00:19:02.870
In Objective-C, they're separate.

00:19:03.030 --> 00:19:06.340
So you could have an NSObject
class and an NSObject protocol

00:19:06.400 --> 00:19:07.900
and so on and so forth.

00:19:07.920 --> 00:19:09.900
So they're in separate namespaces.

00:19:13.070 --> 00:19:15.010
Here we're going to go
through message expressions.

00:19:15.110 --> 00:19:18.600
This is what you see the most of when
you look at an Objective-C program.

00:19:18.750 --> 00:19:19.960
Here's the most simple one.

00:19:20.150 --> 00:19:22.810
We have my view, which is an object,
and it's sending the

00:19:22.900 --> 00:19:23.840
timer update message.

00:19:24.010 --> 00:19:26.440
There's no arguments there.

00:19:26.580 --> 00:19:31.840
The second message expression
there is any browser sent the

00:19:31.840 --> 00:19:34.650
set delegate object message.

00:19:34.830 --> 00:19:35.770
That takes one argument.

00:19:35.870 --> 00:19:38.990
Notice the colon separates the
name from the actual argument,

00:19:39.000 --> 00:19:40.990
in this case obj.

00:19:41.110 --> 00:19:45.710
The third one, a common idiom,
is where the receiver is

00:19:45.710 --> 00:19:47.960
derived from a message.

00:19:48.030 --> 00:19:51.400
Here self is,
I think the first time we've seen self,

00:19:51.400 --> 00:19:55.760
self is equivalent to this in C++,
and it's sending the

00:19:55.760 --> 00:19:57.470
flush window message.

00:19:59.490 --> 00:20:03.160
So now let's look at some
hybrid message expressions.

00:20:03.180 --> 00:20:05.910
This first one is out of WebCore.

00:20:06.180 --> 00:20:09.100
It's sending the message keyboard UI.

00:20:09.130 --> 00:20:13.150
And you can see that it's
accessing a static member function,

00:20:13.240 --> 00:20:14.580
bridge for widget.

00:20:14.610 --> 00:20:17.470
And in this case, this is active.

00:20:17.570 --> 00:20:21.190
So this is just a message expression
I pulled out of WebCore to show

00:20:21.190 --> 00:20:25.660
you how easy it is to mix the two
languages in message expressions.

00:20:25.690 --> 00:20:29.280
The second one is a bit more complicated.

00:20:29.930 --> 00:20:34.700
There we have the adapter sending the set
cookies for URL policy-based URL message,

00:20:34.700 --> 00:20:37.400
and you can see it's interspersed
with arguments that are,

00:20:37.400 --> 00:20:40.260
in fact, member function calls.

00:20:41.500 --> 00:20:42.990
So fairly easy stuff.

00:20:43.270 --> 00:20:46.020
Again,
a message expression is an expression.

00:20:46.130 --> 00:20:49.600
So just as you call in a function
and you could provide expressions

00:20:49.600 --> 00:20:52.280
to each argument of the function,
the same thing's true here.

00:20:52.280 --> 00:20:54.840
That's why the nesting works so nicely.

00:20:55.040 --> 00:20:57.330
There's nothing special about it.

00:20:59.920 --> 00:21:01.560
There we go.

00:21:01.570 --> 00:21:07.280
So here are some more hybrid
message expressions from Celestia.

00:21:07.280 --> 00:21:07.280
Here we have

00:21:07.890 --> 00:21:10.300
We're sending the star message to self.

00:21:10.410 --> 00:21:14.100
We're then dereferencing it,
calling the setLuminosity

00:21:14.100 --> 00:21:16.000
member function.

00:21:16.110 --> 00:21:20.220
And we're passing it the float value
from an Objective-C message expression.

00:21:20.340 --> 00:21:23.090
Again, you could see how natural
the given play is.

00:21:23.100 --> 00:21:25.920
There's nothing really magic going on.

00:21:26.020 --> 00:21:30.240
And you could really
see the two languages

00:21:30.590 --> 00:21:34.400
is collaborating and
working well together here.

00:21:34.620 --> 00:21:39.520
So the second one, we have NSNumber,
and you can see the self star,

00:21:39.520 --> 00:21:44.000
and it's sending the getTemperature
member function call.

00:21:44.080 --> 00:21:48.790
And the third one,
we have simply a namespace named Astro,

00:21:49.060 --> 00:21:54.060
and there's just a standard C++ function
that's embedded within the namespace

00:21:54.080 --> 00:21:59.040
Astro called lightYearsToParsecs,
and it's being passed the float value.

00:22:03.440 --> 00:22:03.680
Okay.

00:22:03.680 --> 00:22:07.080
Next thing I'd like to talk
about is some dynamic idioms.

00:22:07.080 --> 00:22:07.920
Okay.

00:22:07.920 --> 00:22:12.290
Method categories are something
we use pretty extensively

00:22:12.360 --> 00:22:13.780
in the application kit.

00:22:13.780 --> 00:22:16.160
It allows us to augment existing classes.

00:22:16.160 --> 00:22:18.310
It's something you don't
see very commonly in other

00:22:18.310 --> 00:22:19.740
object-oriented languages.

00:22:19.740 --> 00:22:23.660
If you look at Common Lisp or you look
at some other more dynamic languages,

00:22:23.660 --> 00:22:27.560
they're not called categories,
but they allow you to do the same thing.

00:22:27.570 --> 00:22:31.720
What they allow you to do is add
operations to an existing class.

00:22:31.790 --> 00:22:35.980
So here's an example where on the
app kit is adding some string drawing

00:22:36.070 --> 00:22:38.380
methods to the foundation string object.

00:22:39.940 --> 00:22:43.560
Likewise,
here's an Objective-C++ category that

00:22:43.560 --> 00:22:50.800
Celestia adds to convert NSStrings to
and from the standard strings.

00:22:53.080 --> 00:22:55.450
So I want to show you
briefly how it works,

00:22:55.520 --> 00:22:58.790
because I think many people who
are new to some of the dynamic

00:22:58.790 --> 00:23:01.760
properties that Objective-C has,
they get confused.

00:23:01.760 --> 00:23:04.330
So here are our three bodies of code.

00:23:04.340 --> 00:23:07.740
We have the foundation,
where NSString lives.

00:23:07.770 --> 00:23:11.700
We have AppKit with a
category that you just saw.

00:23:11.710 --> 00:23:16.600
We have Celestia with that
category with the two methods.

00:23:16.640 --> 00:23:21.800
What happens is, at runtime,
the runtime links things up.

00:23:21.800 --> 00:23:25.520
And actually,
when it loads the shared library,

00:23:25.520 --> 00:23:27.210
it says, oh, a category.

00:23:27.330 --> 00:23:28.920
Who are you associated with?

00:23:28.940 --> 00:23:31.340
And then it goes and looks
up the class dynamically,

00:23:31.350 --> 00:23:35.920
and it sets the method tables accordingly
so that you can basically extend the

00:23:35.920 --> 00:23:38.880
class methods in a fairly seamless way.

00:23:38.950 --> 00:23:41.990
Here you see the NSString method
table points to the string

00:23:41.990 --> 00:23:44.150
drawing method table,
which points to-- so

00:23:44.150 --> 00:23:48.160
anything in the AppKit,
all your applications get for free.

00:23:48.170 --> 00:23:51.770
If you want to have a private category,
as Celestia does,

00:23:52.110 --> 00:23:55.390
that's a category that would
be embodied with the actual

00:23:55.410 --> 00:23:57.260
executable for the application.

00:23:57.280 --> 00:24:01.540
That would obviously not be
shared with other executables.

00:24:02.290 --> 00:24:08.030
And what this allows is you to
associate methods with other

00:24:08.030 --> 00:24:10.020
objects that work on their behalf.

00:24:10.150 --> 00:24:13.200
So for instance, these method tables
aren't a part of NSView.

00:24:13.200 --> 00:24:15.180
They're not a part of
the Celestial Galaxy.

00:24:15.420 --> 00:24:19.360
But they're methods that the
Galaxy and the View would like to

00:24:19.360 --> 00:24:22.800
call on behalf of the string object.

00:24:22.920 --> 00:24:25.590
So why is all this interesting?

00:24:25.590 --> 00:24:29.660
It's because you don't have control of
who instantiates objects all the time,

00:24:29.850 --> 00:24:30.040
right?

00:24:30.290 --> 00:24:34.250
One of the things that frameworks are
really good at is doing work on your

00:24:34.250 --> 00:24:39.700
behalf where you actually don't know what
class is going to be sent the message.

00:24:39.700 --> 00:24:43.260
So we think this works really well,
and in fact,

00:24:43.260 --> 00:24:48.660
people have used it in very interesting
ways in various applications.

00:24:49.700 --> 00:24:53.810
So another dynamic idiom,
we have the setCellClass method.

00:24:53.890 --> 00:24:57.100
Basically, classes are first-class
objects in Objective-C.

00:24:57.130 --> 00:24:58.200
You can reason about them.

00:24:58.200 --> 00:25:02.500
If you dynamically load code,
you can find out what classes are a part

00:25:02.500 --> 00:25:05.110
of that code and invoke methods on them.

00:25:05.520 --> 00:25:07.780
setCellClass,
you could reason about the superclass.

00:25:07.900 --> 00:25:12.680
These are all small talk idioms that
we carried over into Objective-C.

00:25:12.740 --> 00:25:16.560
And the is kind of
predicate to basically ask,

00:25:16.590 --> 00:25:18.080
is this class a kind of another class?

00:25:18.180 --> 00:25:20.080
Now, notice the function there.

00:25:20.390 --> 00:25:25.070
The function allows you to take a
string and convert it into an object.

00:25:25.220 --> 00:25:25.560
OK?

00:25:25.980 --> 00:25:28.370
That's another metaphor
we use quite heavily,

00:25:28.370 --> 00:25:32.360
because the compiler can't always
know or be told what class.

00:25:32.520 --> 00:25:35.670
Often, it's reading those things
from external files,

00:25:35.670 --> 00:25:36.950
like your NIV file.

00:25:38.720 --> 00:25:44.230
So here are methods of
first-class objects as well.

00:25:45.090 --> 00:25:47.460
Here's a selector, the unique code.

00:25:47.560 --> 00:25:53.500
So if you want to compare selectors,
you need to convert them.

00:25:53.770 --> 00:25:55.800
If you want to get a method signature,
you need a selector.

00:25:55.800 --> 00:25:58.000
So in this case,
it's already been converted.

00:25:58.070 --> 00:25:59.370
We send that message.

00:25:59.640 --> 00:26:01.080
Signatures contain the type.

00:26:01.220 --> 00:26:08.050
So if you're writing a tool or you're
writing a framework and you want to

00:26:08.050 --> 00:26:09.380
know what types the method takes,
the signature is really handy.

00:26:09.790 --> 00:26:11.940
And here's an @Selector directive.

00:26:11.940 --> 00:26:15.330
@Selector is the equivalent
of the function in this slide.

00:26:15.590 --> 00:26:18.130
The only difference is you're
telling the compiler to do it,

00:26:18.200 --> 00:26:20.680
so it's a little more optimal
because you know the name.

00:26:20.930 --> 00:26:24.800
In this case, it's alloc,
so the compiler will get the

00:26:24.800 --> 00:26:27.420
unique code for the alloc method.

00:26:30.530 --> 00:26:31.260
Delegation.

00:26:31.460 --> 00:26:34.200
Okay, this is something that
we use in notifications.

00:26:34.200 --> 00:26:38.390
We use it in the target action
paradigm in the application kit.

00:26:38.540 --> 00:26:42.400
We do things like, "Oh,
if your object responds to this selector,

00:26:42.400 --> 00:26:47.250
well, send the windowDidMove message."
The windowDidMove message is part

00:26:47.250 --> 00:26:52.400
of a protocol that we publish
for tracking window operations.

00:26:52.660 --> 00:26:58.400
And this is a perfect example of
code that you don't often write,

00:26:58.400 --> 00:27:00.500
but is written all the
time in the framework to

00:27:00.670 --> 00:27:02.380
collaborate with your objects.

00:27:02.400 --> 00:27:05.500
So, again,
it's an interesting case where,

00:27:05.870 --> 00:27:08.400
until you see some of these
idioms and metaphors and patterns,

00:27:08.400 --> 00:27:10.400
you don't appreciate them.

00:27:10.400 --> 00:27:15.400
And, again, this is one of the reasons
when you write Cocoa programs,

00:27:15.400 --> 00:27:18.270
you don't find you're
overwhelmed with subclassing,

00:27:18.590 --> 00:27:22.340
writing lots of different classes, and,
in fact, ending up with some very

00:27:22.380 --> 00:27:26.270
highly structured or overly
structured class hierarchy.

00:27:26.400 --> 00:27:27.740
It's fairly free-informed.

00:27:27.740 --> 00:27:31.190
It's more free-flowing.

00:27:33.310 --> 00:27:34.900
So here's set target, set action.

00:27:34.900 --> 00:27:38.270
This is code from the
interface builder paradigm,

00:27:38.270 --> 00:27:41.470
and this is in all of our controls.

00:27:41.900 --> 00:27:44.660
And then later on,
once you have the target and the action,

00:27:44.680 --> 00:27:47.160
you can send the set
action method accordingly.

00:27:47.210 --> 00:27:54.950
So this is the dynamic code that we
find all over our frameworks that,

00:27:54.950 --> 00:27:54.950
again, simplifies your life.

00:27:55.890 --> 00:27:57.080
Reflection.

00:27:57.080 --> 00:28:02.100
This is the hooks that support outlets,
bindings, key-value coding, again,

00:28:02.100 --> 00:28:04.260
Cocoa bindings,
which have been featured in

00:28:04.260 --> 00:28:05.800
many of the presentations.

00:28:05.800 --> 00:28:10.510
This is the low-level code that, in fact,
supports those metaphors.

00:28:10.880 --> 00:28:14.780
So in this case,
we have selector from string.

00:28:14.850 --> 00:28:17.800
It gets the selector,
and then it asks response to.

00:28:17.800 --> 00:28:20.780
If it does respond to it,
it performs the selector.

00:28:20.890 --> 00:28:27.110
If no setter method has been found,
a lower-level hook is provided to,

00:28:27.110 --> 00:28:29.980
in fact,
look up the instance variable and

00:28:30.000 --> 00:28:31.770
set it directly in the object.

00:28:31.800 --> 00:28:34.830
So the simplification for
the programmer is you don't

00:28:34.840 --> 00:28:36.790
have to write setter methods.

00:28:36.800 --> 00:28:40.040
The introspection,
reflection that's provided with

00:28:40.040 --> 00:28:44.800
the runtime enables the tools
to basically poke at your object

00:28:44.800 --> 00:28:47.800
and set up the connection,
set up the binding

00:28:47.800 --> 00:28:49.790
without your intervention.

00:28:49.800 --> 00:28:52.690
It's nice to have the
opportunity to write the setter,

00:28:52.800 --> 00:28:54.800
but that's not required.

00:28:59.130 --> 00:29:01.430
So let's see,
how are we doing on time here?

00:29:01.610 --> 00:29:03.400
So here are some examples.

00:29:03.400 --> 00:29:05.840
From OpenGL,
this is on the developer disk.

00:29:06.000 --> 00:29:09.970
Here's an example of a more
complete set of code where we

00:29:10.000 --> 00:29:14.990
have a value object that's a
Q matrix there that's highlighted.

00:29:15.100 --> 00:29:23.120
And it's surrounded by an outlet
right there from interface builder,

00:29:23.120 --> 00:29:23.120
mode, alpha.

00:29:23.120 --> 00:29:23.120
Again, this is on your disk.

00:29:24.590 --> 00:29:27.720
Now, just because you're
writing in Objective-C++,

00:29:27.720 --> 00:29:30.890
don't assume that all the
classes have to be mixed.

00:29:31.000 --> 00:29:31.100
Right?

00:29:31.100 --> 00:29:34.000
Here's an example where,
even though we saw some hybrid

00:29:34.000 --> 00:29:37.930
code in the previous slide,
this class is pure C++.

00:29:38.280 --> 00:29:39.980
There's not any Objective-C in it.

00:29:40.120 --> 00:29:44.000
So a very,
very common thing we see out there

00:29:44.000 --> 00:29:49.410
is people keeping a lot of their C++,
let's say, portable and standard and not

00:29:49.410 --> 00:29:52.820
mixing the models everywhere,
but in fact just doing it in

00:29:52.820 --> 00:29:54.420
very special control points.

00:29:54.960 --> 00:29:55.410
Right?

00:29:55.510 --> 00:29:59.500
It's very common to want to do
a native interface in Cocoa and

00:29:59.510 --> 00:30:02.430
bring over your C++ engine,
so to speak.

00:30:02.520 --> 00:30:05.000
And in fact, iChat's a good example.

00:30:05.000 --> 00:30:11.430
iChat is a wonderful Cocoa interface
that the chat engine is actually in C++,

00:30:11.570 --> 00:30:15.310
and they work together via Objective-C++.

00:30:17.730 --> 00:30:20.740
So here is just an
example rotating the cube.

00:30:20.740 --> 00:30:25.370
You can see the one statement there that
does the multiplication and then the

00:30:25.370 --> 00:30:31.370
extra Objective-C statements there to
do the graphics and update the scene.

00:30:31.710 --> 00:30:34.110
Fairly straightforward stuff.

00:30:35.860 --> 00:30:37.400
Now, here's an interesting one.

00:30:37.470 --> 00:30:42.140
There was a class in this
example that was largely C++,

00:30:42.140 --> 00:30:46.030
but there's a couple pure
member functions there that

00:30:46.150 --> 00:30:49.800
were taking Objective-C objects,
selectors, and, in fact, events.

00:30:49.800 --> 00:30:51.640
So I've highlighted them for you.

00:30:51.640 --> 00:30:56.970
And you could see that these
arguments are passed around as

00:30:56.970 --> 00:31:00.800
naturally as other arguments would be.

00:31:00.890 --> 00:31:02.280
So here's the handle event method.

00:31:02.330 --> 00:31:05.220
So you could see that it
checks the event type,

00:31:05.440 --> 00:31:10.560
checks if it's a scroll wheel,
and does the appropriate operations.

00:31:10.620 --> 00:31:13.170
Again, very, very straightforward.

00:31:13.810 --> 00:31:18.200
Okay, so let's go to the next example,
which is Core Audio.

00:31:18.400 --> 00:31:21.510
This is a little bit more complicated.

00:31:21.820 --> 00:31:25.880
This example,
what's in orange are the C++ objects,

00:31:25.880 --> 00:31:30.070
and what's in blue are
the Objective-C objects.

00:31:30.260 --> 00:31:37.170
So here we have a few vectors and
a map that are C++ vectors and map

00:31:37.300 --> 00:31:43.580
from the standard C++ library that
point off to Objective-C objects.

00:31:43.700 --> 00:31:48.510
So they're C++ containers that
point off to Objective-C objects.

00:31:50.610 --> 00:31:52.090
Here's the allocation method.

00:31:52.130 --> 00:31:57.190
So you can see that there's
a couple Objective-C objects

00:31:57.230 --> 00:32:01.500
being allocated and initialized
with the application delegate.

00:32:01.500 --> 00:32:05.480
And then there are several news,
which are the vectors being instantiated.

00:32:05.500 --> 00:32:09.160
This is a good time to
note that in Objective-C,

00:32:09.160 --> 00:32:14.360
all objects are dynamically allocated,
okay, or by reference.

00:32:14.530 --> 00:32:18.500
The only special object is NSString,
which the compiler knows about.

00:32:18.500 --> 00:32:21.500
So it knows how to create
static string constants.

00:32:21.500 --> 00:32:25.500
But all other Objective-C objects that
you create are dynamically allocated.

00:32:25.500 --> 00:32:28.500
In C++,
it's very common to use value objects,

00:32:28.500 --> 00:32:31.240
and we're going to talk a little
bit more about that in a bit.

00:32:31.630 --> 00:32:34.530
But here,
it so happens that the new is being used,

00:32:34.530 --> 00:32:36.480
and they're dynamic as well.

00:32:36.500 --> 00:32:40.500
So all the objects in
this method are dynamic.

00:32:43.460 --> 00:32:50.370
So here's a simple little method that
basically sends the pushback call.

00:32:50.500 --> 00:34:00.900
[Transcript missing]

00:34:05.780 --> 00:34:08.700
So we just looked at C++
containers of Cocoa objects.

00:34:08.700 --> 00:34:13.140
I was alluding to the gotcha,
which is it's a little bit

00:34:13.140 --> 00:34:18.450
sticky right now mixing the
retain-release metaphor with C++.

00:34:18.700 --> 00:34:22.220
When the vector classes were developed,
they obviously didn't

00:34:22.220 --> 00:34:23.700
know about Objective-C,
right?

00:34:23.810 --> 00:34:29.700
So it's hard to expect them
to know how to do this.

00:34:29.700 --> 00:34:34.060
And again, as I said before,
both runtimes, both libraries don't

00:34:34.180 --> 00:34:35.700
know about each other.

00:34:36.130 --> 00:34:39.650
Fortunately,
C++ provides some interesting hooks

00:34:39.700 --> 00:34:42.690
to be able to solve this problem.

00:34:45.240 --> 00:34:47.100
I don't know if you were
able to read the comments,

00:34:47.260 --> 00:34:52.580
but basically what's happening here
is it's considered a no-no in Cocoa to

00:34:52.580 --> 00:34:55.380
transfer ownership across calls.

00:34:55.480 --> 00:34:59.650
So what I expected to-- when
I was reading this method,

00:34:59.670 --> 00:35:05.140
I was expecting to see
a release at the end.

00:35:05.140 --> 00:35:06.330
But it doesn't do a release.

00:35:06.520 --> 00:35:08.610
It passes the object on.

00:35:09.050 --> 00:35:12.760
And for purposes of this talk,
if you're not familiar

00:35:12.760 --> 00:35:15.380
with retain-release,
this is probably more

00:35:15.380 --> 00:35:16.140
than you need to know.

00:35:16.140 --> 00:35:21.800
But here, there's a manual release.

00:35:21.960 --> 00:35:23.200
So you saw that.

00:35:23.300 --> 00:35:26.250
And it's just confusing.

00:35:26.690 --> 00:35:30.260
And I've talked to people
who use the language,

00:35:30.320 --> 00:35:31.880
and they want to see this fixed.

00:35:31.880 --> 00:35:35.650
So one of the things that we're going
to be doing is adding a smart pointer

00:35:35.650 --> 00:35:38.600
class to automate the retain-release.

00:35:38.970 --> 00:35:43.090
So for any of you who've tried to do
this and have been confused by it,

00:35:43.090 --> 00:35:46.980
fortunately,
C++ provides templates which allow you

00:35:47.190 --> 00:35:49.710
to customize the behavior of the vector.

00:35:49.770 --> 00:35:54.840
So for instance,
by providing an ID pointer template,

00:35:54.900 --> 00:35:59.310
it allows us to solve this problem and
write that code much more naturally

00:35:59.700 --> 00:36:02.680
and in a much less error-prone fashion.

00:36:02.750 --> 00:36:06.680
So this is a feature that we
expect to provide for Tiger.

00:36:06.750 --> 00:36:10.540
If not, it's actually fairly easy for
you to implement this yourself.

00:36:10.540 --> 00:36:13.620
And it's not going to be a
problem for you to do it yourself,

00:36:13.620 --> 00:36:17.420
if you need to do so in the short term.

00:36:17.520 --> 00:36:20.310
As I say in the slide,
Boost Shared Pointer might even

00:36:20.400 --> 00:36:22.280
work for you off the shelf.

00:36:22.280 --> 00:36:24.590
If it doesn't,
then you could adapt it to your needs.

00:36:25.220 --> 00:36:33.320
The next "gotcha" is exception handling.

00:36:33.320 --> 00:36:33.320
Exception handling

00:36:34.500 --> 00:36:36.400
is supported in both languages.

00:36:36.400 --> 00:36:39.900
In C++, it's try-catch.

00:36:39.900 --> 00:36:41.850
In Objective-C, it's at-try, at-catch.

00:36:41.850 --> 00:36:50.960
But one of the confusing things here
is if you look at these two calls here,

00:36:50.960 --> 00:36:53.590
one is sending the process message,
and the other is timer update.

00:36:53.920 --> 00:36:57.660
You don't know whether
these two calls are truly,

00:36:57.660 --> 00:37:02.880
like the first one, you don't know,
is it C++ pure or is it hybrid, right?

00:37:02.880 --> 00:37:06.940
The second one, you don't know,
is this pure Objective-C message send?

00:37:06.940 --> 00:37:08.460
That is the method on the other end.

00:37:08.560 --> 00:37:11.300
Is it pure Objective-C or not, right?

00:37:11.300 --> 00:37:14.380
If you know that,
then life's a little bit simpler.

00:37:14.380 --> 00:37:19.600
You can just wrap your C++
call with the try-catch and

00:37:19.680 --> 00:37:22.460
wrap your Objective-C message
send with that try-catch.

00:37:23.260 --> 00:37:25.250
Unfortunately, in this case,
they're hybrid,

00:37:25.260 --> 00:37:27.100
which is why I used it as an example.

00:37:27.100 --> 00:37:31.220
So to solve this problem,
it's straightforward,

00:37:31.220 --> 00:37:35.140
maybe initially non-obvious,
but you basically wrap the

00:37:35.300 --> 00:37:41.000
first two calls in try-catch,
and that's the C++ catch right there,

00:37:41.260 --> 00:37:44.060
and then you would wrap
with that try-catch,

00:37:44.060 --> 00:37:44.700
okay?

00:37:44.700 --> 00:37:51.330
Now, fortunately, the way exceptions are
used in Cocoa and C++,

00:37:51.500 --> 00:37:55.170
they're really used for
exceptional conditions as errors,

00:37:55.170 --> 00:37:55.800
right?

00:37:55.800 --> 00:38:00.290
So you don't find yourself having to
write this type of code very often.

00:38:00.320 --> 00:38:05.070
Usually in Cocoa, in particular,
you inherit an exception

00:38:05.070 --> 00:38:09.340
handler from NSApplication,
and even if you decide to implement

00:38:09.340 --> 00:38:13.750
your own exception handling,
you usually do it at a very

00:38:13.750 --> 00:38:15.650
high level of the application.

00:38:15.660 --> 00:38:19.380
Again, it's not handled for
things like file not found.

00:38:21.840 --> 00:38:25.360
So what I just talked about
was sort of education.

00:38:25.360 --> 00:38:27.340
It isn't really a big gotcha.

00:38:27.340 --> 00:38:29.200
It's just something that
you have to think about,

00:38:29.200 --> 00:38:30.050
more of a speed bump.

00:38:30.360 --> 00:38:31.190
This is a gotcha.

00:38:31.440 --> 00:38:35.390
This init method does something very bad.

00:38:35.830 --> 00:38:39.840
Basically, there's a value stack object
that I've declared here.

00:38:39.840 --> 00:38:44.360
And as the comment says,
the destructor for stack object

00:38:44.360 --> 00:38:48.560
will not be called automatically
when that at throw happens.

00:38:49.240 --> 00:38:55.380
The reason for this, unfortunately,
is related to the fact that we're trying

00:38:55.380 --> 00:38:57.140
very hard to be binary compatible.

00:38:57.140 --> 00:39:00.400
So that when we added at try,
at catch last year,

00:39:00.400 --> 00:39:04.880
we actually used set jump and long jump,
which is what we had been using in Cocoa.

00:39:04.880 --> 00:39:08.960
And set jump and long jump do
not know about the C++ runtime.

00:39:08.960 --> 00:39:14.800
So in fact, this is a gotcha by design,
unfortunately.

00:39:17.190 --> 00:39:19.220
So what's the workaround?

00:39:19.280 --> 00:39:21.940
The workaround, fortunately,
is pretty straightforward.

00:39:21.970 --> 00:39:26.400
The workaround is fairly simple.

00:39:26.400 --> 00:39:32.080
All you do is call the
destructor manually.

00:39:32.420 --> 00:39:35.770
Not the prettiest thing,
but C++ allows you to do that,

00:39:35.810 --> 00:39:36.810
and it's possible.

00:39:37.000 --> 00:39:39.320
Again,
hopefully you won't be dealing with this.

00:39:39.350 --> 00:39:43.410
This is more a matter of completeness
and me being entirely upfront on

00:39:43.470 --> 00:39:45.990
some of the little things that exist.

00:39:46.160 --> 00:39:49.240
Again, I don't think this really will
affect your life day to day.

00:39:53.490 --> 00:39:54.240
Errors and warnings.

00:39:54.300 --> 00:40:02.040
This is probably the biggest gotcha
that I hear complaints about,

00:40:02.040 --> 00:40:07.570
and it's because in C++,
value objects are extremely common.

00:40:07.580 --> 00:40:12.570
And if you want to have a value
object or an embedded object that's

00:40:12.700 --> 00:40:16.780
part of an Objective-C object,
you get some really bad errors and

00:40:16.780 --> 00:40:21.850
warnings that basically tell you crazy
things like the Vtable has virtual

00:40:21.850 --> 00:40:27.290
member functions and all kinds of crazy
stuff that just doesn't make sense.

00:40:27.320 --> 00:40:30.170
And it's because, again,
the object runtimes,

00:40:30.260 --> 00:40:34.750
the two object runtimes,
don't collaborate when

00:40:34.750 --> 00:40:37.700
dealing with this construct,
mainly because at the time,

00:40:37.700 --> 00:40:42.110
we couldn't figure out how do we
maintain the design point of keeping the

00:40:42.110 --> 00:40:44.780
runtimes distinct and solve this problem.

00:40:44.780 --> 00:40:48.050
We had incorrectly assumed
that it was impossible.

00:40:49.080 --> 00:40:51.500
Fortunately,
we've figured out how to do it,

00:40:51.620 --> 00:40:54.780
and we'll be providing
it in a future release.

00:40:54.900 --> 00:40:58.750
For now, there's a workaround.

00:40:58.880 --> 00:41:03.230
Right now,
if you declare them reference and

00:41:03.230 --> 00:41:07.370
you instantiate them directly,
it won't cause you any grief.

00:41:07.440 --> 00:41:11.910
Again,
because new will do the correct thing.

00:41:13.820 --> 00:41:17.750
And as I said,
this limitation is going to be removed

00:41:17.750 --> 00:41:21.220
and it'll just work as expected.

00:41:21.220 --> 00:41:25.170
So there are several people
anxiously waiting for this one,

00:41:25.170 --> 00:41:29.180
I know, and hopefully it'll
make their lives easier.

00:41:31.010 --> 00:41:34.390
So I don't know if I went too fast here.

00:41:34.390 --> 00:41:38.370
We're going to fortunately
have some nice about 20,

00:41:38.470 --> 00:41:42.580
25 minutes left for Q&A,
which I really value.

00:41:42.580 --> 00:41:45.230
And given the number of people here,
I'm sure there's plenty of

00:41:45.230 --> 00:41:46.490
questions to ask about this.

00:41:46.620 --> 00:41:50.350
But here are some take-home points.

00:41:50.960 --> 00:41:54.650
I think it's fairly clear that doing
this stuff is fairly straightforward.

00:41:54.760 --> 00:41:58.600
The learning curve,
if you're already a C++ programmer,

00:41:58.600 --> 00:41:59.790
is very low.

00:42:00.500 --> 00:42:04.950
Now, if you're not a C++ programmer and
you're not an Objective-C programmer,

00:42:05.100 --> 00:42:07.440
this isn't the language for you, right?

00:42:07.480 --> 00:42:13.580
This is-- this-- you know, yeah, so.

00:42:18.800 --> 00:42:24.280
Apple is using this extensively in
almost every part of the company,

00:42:24.280 --> 00:42:29.290
whether it be our iApps, ProApps, iChat,
Safari,

00:42:29.290 --> 00:42:35.920
and many third-party apps I've seen,
and many that aren't public.

00:42:36.040 --> 00:42:39.890
They're using this extensively,
and it's proven itself.

00:42:40.150 --> 00:42:43.400
So I feel really confident in
advising you guys to use this,

00:42:43.420 --> 00:42:46.300
because I think it's
going to save you time.

00:42:46.340 --> 00:42:51.620
And I think it's also going
to expose people from the C++

00:42:51.750 --> 00:42:56.840
language culture to new metaphors,
new ways of building systems that

00:42:56.940 --> 00:43:01.930
I think will also benefit you.

00:43:02.840 --> 00:43:07.210
I think both languages
complement each other.

00:43:07.210 --> 00:43:12.400
I am constantly amazed at how they
really don't get in each other's way.

00:43:12.400 --> 00:43:14.870
This wasn't clear when we did it many,
many years ago.

00:43:15.170 --> 00:43:20.020
And, in fact, we were concerned about
creating a monster.

00:43:20.440 --> 00:43:23.120
And I don't think we've done so.

00:43:23.120 --> 00:43:26.130
I think this is a very expressive tool.

00:43:26.290 --> 00:43:29.690
And I think if C++ would
have become the next C,

00:43:29.690 --> 00:43:34.690
which is what I thought 15 years
ago when C++ was being developed,

00:43:34.790 --> 00:43:39.390
I was fairly convinced that it was
going to be the next iteration of C,

00:43:39.390 --> 00:43:42.080
then this would seem even more natural.

00:43:42.130 --> 00:43:47.210
I think the only reason that
it even seems to be a little

00:43:47.700 --> 00:43:52.920
controversial is because C++
didn't become formally the next C,

00:43:52.920 --> 00:43:56.710
even though it's the de
facto next iteration of C.

00:43:56.710 --> 00:43:59.420
And I find most people doing
serious applications of C++.

00:43:59.420 --> 00:44:00.070
And I think that's the reason why people
who are doing this kind of application

00:44:00.390 --> 00:44:03.980
development are using it in some way.

00:44:03.980 --> 00:44:10.480
So documentation.

00:44:10.480 --> 00:44:13.600
And Matt Formica,
he's our tools evangelist.
---
Title:  Introduction to Sun Java Studio Creator
Year:   2004
Web:    https://nonstrict.eu/wwdcindex/wwdc2004/637/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Good morning. I'm Wiley Hodges. I'm the Senior Product Line Manager for Developer Products at Apple. And one of the many things that I'm responsible for at Apple is product marketing for Java on Mac OS X. You know, we're really excited about what we've been doing with Java, but I'm also extremely excited about what many of our partners have been doing with Java.

And in particular, a very important Java partner is Sun. And I'm very pleased that this morning I can introduce Bob Brewin and Carl Quinn, who will be talking about Java Studio Creator on Mac OS X, which we're extremely pleased to see coming to our platform. So, with no further ado. Thanks, Wiley.

Thank you very much. So we're going to be talking about iChat on the PDP-4. Oh, sorry. So I'm Robert Brewin. I'm a distinguished engineer at Sun, chief architect for Project Rave, which is now called Sun Java Studio Creator. Carl Quinn is one of our senior engineers responsible for some of the core technology inside of it. So he's going to be giving a little demo a little later.

And so what we're going to talk about is, so why did we do Creator? What things were we interested in targeting? What kind of customers were we looking at? What kind of developers? We'll talk about the project creator itself, give us an idea of what kind of quality measures we had for it, what kind of features we wanted, what kind of capabilities we thought we could offer developers.

We'll talk about Java development on Mac OS X. By the way, if I say Mac OS X, just throw something at me. Preferably a G4 PowerBook because I need a new one. Thank you. Then we'll do a product demo and we'll let Carl fly with that. Then I'll talk a little bit about the roadmap, where we're going, the kinds of things we're trying to do in the Sun Java Studio Creator product.

So let's take a look at market segmentation. One of the things that we wanted to do was try to understand what sort of developers are out there, what kind of applications are they trying to create. And so one can create any kind of arbitrary diagram or spreadsheet or something to try to capture it. And what we did is we came up with a quadrant.

And the quadrant is pretty self-explanatory. If we take a look along the bottom, the bottom axis talks about application complexity. How complex is that application? Going up in the vertical axis, we talk about code, how much coding is actually required. And we divided this into four quadrants. And for this diverse group, we looked at, for instance, the technologist base. So these are people that do a lot of coding and they love to code, but the applications they create are not necessarily that complex.

Technologists love the latest thing. They love to go to java.sun.com, play with the latest APIs. They love open source. They like free stuff. These are the kinds of people that create a lot of the innovative technologies and products that we see coming out on java.com and other places, including some of the java.net sources. Enterprise architects, on the other hand.

I have a lot of code in their applications. They're very knowledgeable, but the applications are incredibly complex. For those kinds of applications, we're looking at industrial strength. These are the kinds of applications that run Wall Street. These are the kind of applications that run the telephone services, the things that make your mobile phones work. They need architectural tools. They need UML modeling. They need things to go ahead and allow them to performance tune and scale the applications for the enterprise and so that the dial tone never stops on your phone.

The integrators are people who take potentially very complex applications and assemble them together. So these are people that take existing applications and they're doing the, there's a lot of technology that is just emerging in terms of business process modeling and so on, where people are taking pre-built components, some of them very large scale, putting them together to create end user solutions.

Corporate developer space is all about productivity. These are the people who are doing maybe not so much code. They're reusing existing infrastructure and artifacts. And the application complexity is not necessarily that high either. Again, these are people who are primarily building applications that a lot of you see within your IT infrastructure. So people that are doing travel accounting, people that are doing payroll management, things like that.

For them, a lot of times complete solutions are extremely important. They may not be experts in the sense of programming experts, they may not have PhDs in computer science, what they would like to do is they would like to be at one CD, install it and have everything they need, all the tools, all the run times, everything they need to actually get productive and develop applications. Simplified development. We talk about the corporate developer space. One of the things are that they're not necessarily your typical developers.

They could be domain experts. If we take a look at the spectrum, and we'll take a look at that quadrant again, if we take a look at the spectrum of what corporate developers do, they may range from people that are doing spreadsheet macros, all the way up to people who are using 4G languages, Delphi, Visual Basic and other code languages. So they could be domain experts. They may be people that understand, for instance, the mortgage business. They may be people that understand HR. They may be people that understand the financial system. understand finance, but they may not be typical developers.

The applications they create typically are not producers of business logic. They are in fact consumers of them. So they consume a lot of data. They consume business services. They consume a lot of the application artifacts that the enterprise developers create or the technologists create. Typically, you'll take a look at a corporate developer and if we contrast that to the way an enterprise developer works, an enterprise developer works typically from the back to the front.

So I've done enterprise development. So I've sat down with UML modeling tools and I've devised this really large and complex architecture, inspected all out and then built this huge thing and then started grafting UIs on top of it. Corporate developers typically work in the reverse. They have an idea in their mind about how this application is going to look and behave, they design the user interface and then they wire all the pieces in beneath it.

And usually what they're trying to get is a rich UI because again, they're visualizing this thing as this is what I want my end users to see and that end user may be only them, could be a department, could be a work group, but generally it's a smaller group of people.

The problem when we take a look at the application space today is that the bar to enter to Java with most IDEs is too high. So if I take a look at a technologist or I take a look at an enterprise architect, the value they get is richness and flexibility.

While for the corporate developer, it's simplicity and understandability. One of the examples that I like to use is the difference between a Cessna plane and a 747. Both of them will get me from point A to point B. Both of them have a small subset of controls that's the same. But the amount of experience, the amount of understanding of all the way that these systems work together has to be a lot higher to get a 747 to fly from, let's say, LA to New York. But a Cessna will work just the same way.

Again, you know, the idea here is to provide a simple interface and a set of abstractions that the corporate developer can work with to develop their applications. And again, like I said, they need a complete solution. So one of the things we're looking for is a one-stop shop.

So like we're talking about with a plane, if we're going to develop an application or a tool in a runtime infrastructure that is simple, all that power still needs to be available. One of the things that we've run into is it's not just corporate developers that are using tools like this. Enterprise developers and technologists are using them as well. Why? Well, if I'm tasked with creating a large J2E infrastructure, you know, I'm spending 40% of my time developing JSP front ends. Well, I'm wasting my time.

I should be spending all my brain power working on the hard problems and solving those. So the richness of the platform needs to be available. I need to be able to get underneath the covers if I know what I'm doing. And if I'm going to take that application and move it from a corporate developer space into somebody who really understands what they're doing, I need to be able to get to the code and I'm able to dive down and then tweak it. But the use of the complex APIs should not be required. I shouldn't have to be able to understand, for instance, what a Java server face's lifecycle is in order to actually develop an application. I shouldn't have to know it. all the platform APIs are either.

The resulting code should be obvious. I should be able to look at the code and understand intuitively what it's supposed to be doing. If I'm setting a property or if I'm responding to an event, I should be able to have a basic understanding of how that's going to work. For people that are transitioning from languages like Visual Basic or coming from Delphi, they should be able to look at the code that we generate and have that same understanding of what that thing is supposed to be doing.

Understanding higher-order concept is not required. I shouldn't have to know what a visitor pattern is in order to be productive. Again, when I talked about upfront design, it's important to understand that I'm going to design the interfaces and then I'm going to configure properties and set the attributes as I'm moving forward and then plug in the logic.

So simplified coding doesn't mean no code. One of the things that we're really looking at is when we generate code, that code is exactly what you expected to do. We're not going to be hidden anything or there's no proprietary XML layer which is driving this entire system. One of the things that we did when we first started this project is we took a look at the entire spectrum of all developer products out there, specifically ones which were targeting the corporate developer space.

When we did that, we saw a lot of companies which were of the ilk where you would design some interface or specify some attributes for a system, and it would generate this huge meta model in XML that you could never move forward. You could never update. You could never manage. What the developers were telling us were also that, well, they want the code.

So I may be able to quickly prototype an application, but I want to be able to get to the Java code. I want to be able to get to the XML descriptors if I know what I'm doing and if I need to migrate this and scale it to the enterprise.

So one of the things and the general tenets that we have for Creator is we just generate pure Java code. If we need XML descriptors, they're there. We might hide them behind really pretty veneers, which are our visual tools, but they're all there so I can take that application and then I can move it, scale it to somewhere else. So let's talk about Creator. Excuse me.

So Sun Java Studio Creator, which used to be called Project Raive, is designed for corporate developers. It's designed for people who want to be immediately productive, people who are going to be developing applications or people who are experiencing going to be prototyping applications, but they don't necessarily want to learn the plumbing. They don't necessarily have to learn and read the multi-hundred page JSF spec, JSP, JSTL, servlets, J2EE and Java to understand what they're doing.

It's the first IDE that's completely built from bottom to top on Java, 100%. It's designed to be around the idea of what you see, what you get, highly productive, drag and drop. Everything when you see what you see on the screen is what you'll see in the end application.

The other thing is that we, as I described, people design applications in terms of the front, the user interface, and they wire it in behind. So one of the things that we had to do was make sure that you can get to data, you can get to services and easily drag them and drop them and put them and wire them into your application.

The other thing is that unless you're building just a single page, you need to understand how that page is going to interact with some other page. How am I going to get from point A to point B? And so, again, we could just throw the XML descriptors at them, but we thought the visual page navigation would be a much better way to go. Again, the idea being is that this whole environment is visual.

So Java standards, one of the things that Sun of course is really key on is everything should be standard. I should be able to take this application. I should be able to run it on any server that you have that's J2EE compliant. And that's something that we've done. So you can take a Java Studio Creator application. Not only can I take that code and move it into any development environment that supports Java, I can take the resulting application and deploy it to any J2EE compliant server and have it run.

So for that we use Java Server Faces. If you're also going to the Java 1 conference, you'll see there's a lot of hype and a lot of conference material about JSF. JSF provides a simplified component model and runtime that allows people to create web applications easier. We use JDBC ROSATS. JDBC ROSATS is a new JSR that just went final, which holds the promise of a simplified JDBC access through a ROSAT model that allows things like the supports web applications to support data caching.

So when we talked about our quadrant, obviously Sun Java Studio Creator targets the lower left, corporate developers. And again, it's a range, so it doesn't necessarily mean these are all going to be people who are doing scripting and spreadsheets, but it does include people that are doing enterprise work. It does include people doing technology work. But the idea is to make them as productive as possible and to make people develop applications in Java. So Sun Java Studio Creator is what we're going to go ahead and demo today.

And what it has is it's based on NetBeans 3.6. One of the advantages of NetBeans is it provides us a mature product. A lot of the people that are using our product are people who are in fact experienced developers. Once they develop that application, they're going to want to have the same sort of capabilities they can get with any standard Java IDE. By building on NetBeans, we get a mature product that performs as our base.

Again, what I talked about before, it's just Java. So take the application, deploy it to any J2E app server. It's open in any Java development environment. So I can open this thing in JBuilder, I can open it in Xcode, I can open it in WebSphere Developer, any of those products. And if you have any kind of Java programming skill, it works everywhere.

And the other thing, of course, is it's perfect for the Apple developer. So an interesting characteristic of our team is we started out a priori thinking of the Mac platforms. So a third of our developers are all building and developing and testing this application on the Mac. So rather than building it on, well, I don't know, Solaris, and then porting it to all the various platforms, we are in fact building it every day and testing it every day on Mac OS X as well as Windows as well as Solaris and Linux.

The other thing is that we've leveraged the latest platforms that the Apple engineers have put together. In fact, you're going to watch Carl crash and burn here in a few minutes because being an engineer, he decided to download what? DP3 DP3 last night for the demo. So we'll see how that works.

So he is the last surviving member of the Flying Wallenda, if you remember them. So one of the other things we talked about is complete solutions. You've got to be able to develop, you have to be able to deploy right out of the box. You can't expect people to go hunting around and determining what the right platform is to run on, the right tool, the right JDK. So in the box, when you get Studio Creator, you get Sun Java Studio Creator, you get the Java Application Server Platform Edition 8, which is the latest version of the J2E1.4 runtime.

You get a lightweight test DBMS which allows you to go ahead and very quickly prototype and develop applications against the database. However, we include a number of data direct drivers in the box for you for Oracle, Sybase which I know run on the Mac platform, DB2 and SQL Server if you're daring. Full developer productivity. One of the things you get when you buy Creator and you join the Software Developer Network program is you get a website, you get tutorials, you get forums, code samples, support, and that support will be growing over time. Excuse me.

So it's a complete package. Now a number of you are going here to the Apple conference, but one of the things you can do is next door at Java 1, we're offering a deal. And kind of fortunate for you is you don't need a badge to get the deal, because if you walk into the south entrance, you can get "SunJava Studio Creator Field Guide," which is the first book to come out for Creator in it, you get the full package of Creator based on the Software Developer Network subscription program, which includes everything you see there. Now normally, the subscription program for Creator will be $99. Today, if you buy this book, which is about $40, you get that $99 subscription as well as the book for $49.95.

So if you have a chance during lunch, run over there and pick up the book. Now we'll talk about the release plans for the Mac, but the interesting thing about the way we've done this is that any license key you get with this product when the Mac version is available in terms of an FCS product for final release, that same license key you get with this will work with that product. So again, you save yourself a few bucks here if you go out and get this. And not only that, you get a pretty good book to describe what the system's about. So let's talk about Java development on Mac OS X.

So Java is a core component of the Mac OS X platform environment, obviously. I mean, you've been hearing about a lot of the conference. I was at the keynote yesterday. So it's a full version of Java 2. He's building it on DP3, as you heard a little earlier. It's optimized for the platform. And Java applications are first-class citizen. And we've actually taken that and proven that by building Creator on the Mac OS X platform.

Obviously, we have a bunch of Unix hacks in our group, and so they really enjoy the fact that Mac OS X is built on Unix. So all of those tools and the capabilities you get and the portability and scalability you get with Unix is all available to them, as well as the full complement of the J2E stuff. And what can you say about ease of development? I think you guys have it. Something that we've tried to aspire to.

So this particular development environment provides a rich set of development tools Obviously, if you shop around, you'll find out you get Apple X code. There's Java Studio Creator. Sun has a number of products. NetBeans and IBM and others have products for the Mac platform. And as I described earlier, any application you create with Creator, if you wanted to, you could develop it in those codes. And we've done that. We've actually moved our code, and we have some people that have done development on the Mac and taken Creator code in there.

So what I'm going to do is I'm going to turn it over to Carl, and we're going to watch him fly. And he's going to go ahead and show you a little bit about Creator. He's going to talk you a little through the system, talk about the environment, talk about the applications we can create, and give you sort of a general run-through of what we can expect. Okay. Hi. I'm going to first start out by showing a partial application that we've built with Creator, and I'll just kind of walk you through the functionality and the look and feel of this application. So this is kind of a media zone.

The resolution looks pretty good up there. It's sort of a website where you can go and log in and purchase things, sort of an iTunes for poor man's iTunes, I guess. So we start out with a page with some sort of featured media on the front page. And on the right, there is a tree control that lets you browse different categories of content, artwork, images.

Service a little slow right now. There we go. So we can browse through photographs. Preview some of the content. If anybody was at last year's Java one, they can't forget Taurus Victory, saving the demo. So at this point we can't purchase any content we haven't logged in, it doesn't know who we are. So up on the top there's a little panel where we can log in and use the ubiquitous FUBAR login.

We can see that the panel is actually now switched. It's switched from the login panel to the panel that shows that we're already logged in. It's given us a little message at the bottom that shows hello FUBAR, shows who we are, our user identity, our person ID. And now I'm able to check off and purchase, potentially purchase some of this content.

So one thing is this particular application is not yet finished. There's pages that aren't there, some things that are missing. So why don't we go ahead and take a look at how the application is assembled. So I'll pull up Java Studio Creator and then we'll try to fill in some of the missing functionality.

So actually what I'm going to do is create a brand new project based on the template that I saved which contained the media application. So we had opened that original incomplete application and saved it as a template so that we can then reuse it and add on to it so we can kind of, in a workflow environment, we can just keep building on the project that we had sort of set up as a skeleton. So at this point it's actually copying lots of media files and parsing all of the Java code and the JSP code.

So again, we're building an application that's based on Java Server Faces and David P. No, this is just lots of media files. There's a lot of files in here. This is actually a rather complex demo that one of our engineers who joined our architect, Craig McClanahan, which is created for Java 1, so it really is loading a tremendous amount of files. One of the things, of course, it's doing is it is in fact loading every single file, parsing them all, generating a bunch of information that we'll need to go ahead and do the actual demo. Either that or DP3 was a mistake. David P. Yeah, that could be.

We also tried to make it even more complicated by booting my system. We're running this on the G5 here. That's booted off the target mode PowerBook. So we're going over the FireWire cable and... So we thought it would be a little bit too easy to just put it on the machine itself. Okay.

There we go. There we go. Okay. So, what we have here, the first page is the welcome page that we saw in the application. It's really just kind of a highlight showing some of the various, you know, selected content for the day. Let me refresh a little bit, get that guy to paint. You can see the various components that we have here.

So this is the visual designer. So it's a WYSIWYG editor. It lets you lay out the Java Server Faces components, drag and drop onto the screen, position them. Using CSS2 style sheets, you can actually set up backgrounds and styles, configure the positions and look and feel of all of the components using that.

So let's go walk through some of the components here. So for instance we have on the left there is an application outline which shows you sort of the breakdown detailed view of the components on your page. Then we see the various, we have some image components here, some of them just for look. Some of them are actually bound to information that's coming from the program. So this particular cover image here is going to be filled in at runtime with data from the database that will actually contain pointer to the cover art itself.

Now if I can interject, one thing that the design preset behind what we've done is that again truth and code, everything here is real Java, real XML and it's all there or JSP in this case. But what we're doing is essentially we're prying a model view to a tool. So what you're looking here is just one view of what is in fact a JSP. On the bottom of the page, on any number of pages, you'll see that we have design and source views.

If you're more comfortable writing in raw JSP, have at it. One of the other things that maybe Carl will get into it, later on is that everything we do is kept in sync. So if I make changes either in the visual representation of any view you see, or the raw JSP, or if we're looking at a Java code file, we make a change there. Or if we take a look at the navigation view and change the navigation configuration in an XML file.

Those changes get reflected throughout your entire application, which Carl knows well about because that's his baby. So I'll let you go on. Okay. So we're going to show a few more things on this first welcome page. We actually have a couple of reusable components here. We've created some fragments.

So at the top of every page in our application, we're going to want to have this little login bar that shows the user whether they're logged in or that they need to log in. So we've actually put this in a separate page, so it's actually a page fragment using JSP fragments. And on this page, we've laid out this sort of multiple card layout combination of components, which I'll come back and show you a little bit later.

But you can see that it's just dropped directly into the JSP. And so that's the first component that we've created. And then we've also created a little bit of a new component that's just dropped directly into the welcome page and placed as if it were sort of a composite component on its own.

And so then that can be reused on every page. And so that's the first component. So let me see. And also over here we have the same kind of thing we did with the little menu control that we saw on the right. I hit the right part of it. It's actually inside of a div over here.

Now, this particular component is a custom component that Craig actually wrote for this application. And he didn't implement any design time visualization. So what we're seeing here, this component at design time is just a white box. It's not very interesting. But all of the components that are added in to create are just Java server-facing standard components.

And they can be dropped in, just imported in, dropped in. And as the market matures for the JSF components, the vendors are going to know that they want to supply design time visualization. So fake data maybe just to show what the components, the example of what the component will look like when it's displayed.

Okay, yeah. This particular page that comes up at the beginning is populated from information that's just written in Java code. So I'm going to switch over. So for every page that you see, there's the JSP source that we saw a little while ago. There's also a backing bean.

So there's a Java bean behind it that controls all the logic and the flow of the page. Now in here, there's a bunch of code that Creator generates and manages for the user. And you can go in and look at it if you want, but what we've done is we use code folding to fold up a lot of these blocks of code.

Just by default so that it doesn't clutter up. So when the user drops back in here to add in their event handlers and things, they just see a couple methods, just the things they need to look at. So in this case, you can see the components on the page have been dropped in here, and they're built as Java beans. So they become properties of the page, and so there's a getter and a setter for each one. There's also potential initialization code in the constructor.

hit that guy in this case there aren't any java site beans that need to be initialized and actually when craig set up this part of the application he went ahead and added his own code folding so that he can wrap up all of the configuration methods into a big block that he can turn on and off and take a look at now one of the interesting things to note here is is that if you take a look at other tools which are providing a sort of a multi-way capability in a tool or code generation facilities one of the things you'll see frequently is guarded blocks don't touch this you touch this you die third rail of a product application in this case there are no such entities in creator of generated code you can check and change anything and the system will track it modify those changes and if something gets reflected elsewhere for instance one of the things you'll note is there's this this is binary relationship between those elements on a page those things in code and one of those is the ability to easily visualize and for instance modify a property in code or handle an event it's pretty easy for instance if i have a button i want to do something with the button it's much easier for you actually to write a small little one-line piece of code in the java bean that's backing the page rather than hunt through the markup and try to find out where i can send an attribute and so one of the the key points of that of course is that once you start doing that you're talking about making changes in multiple places and so when we when one of the things we did when we implemented the technology behind creators to make sure that you can do that safely and without the requirement for having guarded blocks that if you took into some other tool for instance would blow away either deliberately or accidentally and so your application will continue to run as expected okay I was going to show in this one. So in this particular, this is the main page that comes up in the application and what Craig chose to do was just write some straight old Java code to set up the various little thumbnails on that starting page. So he pulls out some of these.

The list of the thumbnails from the application being itself and then just starts populating by setting properties on these components. So it's just very straightforward kind of boilerplate Java code that he wrote at this point to configure the first page. The first page is a little bit more complicated than the first one. So it's a little bit more complicated than the first one.

So it's a little bit more complicated than the first one. But you can see here he's actually accessing an application being so get application being so in a normal create a project which we give the user an application being which lives in application scope. So that same being is shared by all the users of the application.

So all the user sessions will have access to it. And this is a good place to put shared information. In this case, all of the daily hits are just put into a row set there and they just are shared by all the applications. And so every being then has a quick access or to get to the application being.

So that you can write code very simply like this. Also, over here on the left where we saw we had the application outline, you can see all the beans in the application. And there again is the application being which we were just seeing the reference to is available by accessing through the application outline there. You can just open it up and take a look at the code for that guy there. The same goes for the session being. So for every time a user logs in, the user gets a unique session being. And that being can be used to track information.

So in our case, we'll use that to keep track of whether the user's logged in, what's their person ID in effect, and all the information about them, maybe their purchases and things will be stored in that. So that session will live across multiple page requests and be available for the UI to display things and to do the transactions that we want to do.

Okay, I think that's pretty good now. So once we logged in and we went over to the browse page in the application, we were then doing some more things where we could browse through the content and look at some of that. So I'm going to switch over to that page in the designer.

So I default, we just pop over to the visual view here. We can again see we have the fragment up on top for the login navigation. But the main component here this time is a big data table. So it turns out the data table is one column. But it's bound to a row set and the row set contains a particular set of products that match a certain media type that you've selected on the right. So you can see how the data table is organized here.

It contains Sort of a layout of images and text information there. And we can actually go in here and... take a look at the data table layout. So this is one of the nice customizers for some of the more complex components, is you can actually control data binding and property binding of the components to the backend data.

In this case, we're binding to a database, a row set, so it knows all about the columns and all the information available from the row set that we bound it to. So in this case, all these columns are available, product names and components and dates and all the sorts of serial numbers and things, And we chose to just grab basic product column and have that available.

And then kind of a neat trick is done inside of there is all the components that are embedded into the particular row of the table are nested into panels sort of laid out in different orders there. And each of those is individually bound to different parts of the information from the row set. So we can show the title and we can show the author and we can show the thumbnail and lay that out how we want it and bind each one to a different thing individually.

So let me see one here that's interesting. It's like the artist's name. Property Bindings. It's actually able to show the, so you can either bind to a kind of an object property or you can bind to a database and that's more of a tailored type of binding dialogue. So here we can see that.

We're bound to the product's row set and this particular control is bound to the artist's name. So that ends up just creating an expression in the JSF/JSP code that binds it directly to that data and that's evaluated at runtime. So you really don't have to write any code to populate these controls in this kind of fashion. You're just pointing and clicking and selecting things to bind to.

Now all of those on this page are bound to a single row set that we've set up here. And this was dropped from the server navigator so we actually have a set of data sources running on a local database here. And in the data sources there's a number of tables for the media data source. And these are all the tables that are used by the application list of artists, the list of hits and items and medias and persons that can log in, purchases, things like that.

And we've actually created a product row set here. So this was dropped on there. And we can edit the query and take a look at how that was actually gathered. So we took basically the product row set itself and then also joined it with the artist row set so that we can come up and instead of showing the artist ID, we can show the name of the artist and a little more information about the artist. So we'll have the combination of these two tables available to bind to. See there. Okay, so we can go back to that page.

Now there's a few more components on here that are interesting. There's a little navigation guide up here. So these are just buttons that have images as part of their display. One of these is for going forward in the list, one of them is for going back. Double click on those will take you back to the Java code to basically an event handler method.

In this case, buttons produce an action event, and the action event can be used to navigate between pages or just perform some operation on the page and stay on the same page. And in our case, we're using the navigation buttons, previous action, next action, to just adjust the row set position within the table and then just repaint the table. So in this case, we're just calculating how far to go backwards and then resetting the position of the row set of the data table.

And for going forward for next, we do the same thing going forward and just set the first index position of the data table. In this case, for navigating, we want to stay on the same page, so we're returning null. Otherwise, we could return an outcome name, which will tell us what next page to go to, which we can take a look at in a little while.

Any other comments, Bob? No, you're doing fine. Okay. So I'm presuming that, so he's showing you a number of the features behind a pre-generated application. Obviously we're looking at those artifacts which have been generated by the application, the tool itself. What we'll, I'm guessing we're doing next is we're going to show you some of the visual drag and drop and how you actually design things in a visual manner to show you how the actual experience can be easy, not just looking at something that's already been done.

So when we were looking at the app, we realized there was a number of features that obviously were missing in the app. So one of those might be nice to see, a list of all the purchases. So when you've logged into the app and you're looking at what you bought, what you're going to buy, you might want to say, "Oh, how much have I already spent?

Should I, let's take a look at what I've already bought." So we need to add a page to do that. So this is our navigation editor which gives us an overview of all the pages in the application and all of the resources. And it routes the links between the pages. So JSF uses kind of a layer of indirection for managing navigation.

It creates an XML file that has a list of outcomes and navigation cases so that if you do decide later on to change your page names, there's only one file that has to be updated. And Creator will take care of that automatically. So when you rename things and move things around and move links around, the XML file is managed for you. You're on the source file now. Yeah. In this case, there's the source file. It's really just a snippet of the Faces config file with the navigation rules in it.

And so this is all we're looking at here. So this particular visualizer is showing that XML configuration file and also looking at all of the pages themselves, the model for those, to know what's inside of them. So within each page, you can see all of the components that create command action events that could cause navigation. And all of these in this case are handled by code. So this little code icon.

I think in all of this application, they're all handled by code. In this case, this one is directly linked to another case. I think it's just back to the browser page. So it's a very simple kind of navigation. So you can either navigate with kind of a hardwired link or you can navigate with code that you write in your event handler. So we'll go ahead and add a new page. And it's as simple as just saying-- New page. What we want to do is add it to the browse page. We'll put a button on this page.

that we're going to use to navigate us over to the purchases page and so I'll just do basically let's just add that guy simple navigation So we give a name to the link so that we have a name that we can understand. If we decide later on to change the purchases page to some other kind of web or combination of pages, we can easily do that later.

So now we want to actually go do something nice with the button because it's up here in the corner and has the wrong name. So we'll make sure we have it where we want it. I double clicked. Let's go back. I think I need a little more room to get down to the bottom corner. I'm going to put them down over here.

There's some space there for them. So it handles the z-axis and layering and everything too. So in this case the background was in front of the button which wasn't very good. So I'm going to change a few things about the button. Let's give it a better name. Let's give it a better title.

At that point, it should be functional. So now the action for this particular button is just a hardwired string which takes us to... the purchases page. So now we go to that page and take a look. So this is the page we created when we were in the navigation editor.

It just created an empty page for us. In this case the project template populates it with a default style sheet. So we've created a style sheet for the whole app and all the pages we want them to look the same. So it's inheriting the background and some of the layout and coloring information.

There's a bunch of styles too so the controls will have the right colors and look and feel. And we can go ahead and play around. There's a few custom components that were written for this application that we can just drag and drop and they will give us some nice look and feel. So this particular one is kind of a background grid thing with images and it's just configured by how many rows and columns you want.

It automatically attaches to some of the background images in the style sheet. So there we go. There's our look and feel in a couple of clicks. Few other things. Maybe we want to have some text output for the page. Let's say, let's My purchases. I hate my. Let's call it something else.

Let's call it product purchases. And that's pretty small, so we'll use one of the standard classes, style sheet classes called prompt. I have to learn how to spell. There we go. A nicer size. And now for the actual purchases, what we're going to do is drop in a data table and this will then customize to show us the purchases for this particular user, this particular person that's logged in.

So I'll grab the data table, drop it here. So it starts out with some empty dummy data. So the primarily thing that we're going to put in there is purchases. So there's a big table that's available for all the purchases from all of the people. So we'll go ahead and drop that guy. I keep double-clicking.

[Robert Brewin]
Nice preview. Yeah. So this was actually a preview of the table contents. Where was I? People, people. So there's a number of different ways to get back to where you were. So the table picks up the schema information for all the columns in the row set table and actually gathers the column headers and all the data types for the columns and just basically sets up a default layout for it.

We can go ahead and customize it a little bit more, but actually want to do something a little nicer than showing the person ID, the product ID. We want to show a little bit more information to the user about what the product is that they purchased. So I'm going to actually adjust the row set by going back to the query editor that we saw before.

In addition to looking at the purchases table, we'll add in the products table so we can give them a better description of the products that they purchased. So we see it's automatically joined because the keys match there. And we can go and look at all of the various columns that are available from the query and turn off ones that we definitely know we're not going to need.

You'll notice that the SQL in the bottom is changing every single time you check the box. Again, this is one of the other areas where we're tracking all the changes you're making in the system and making sure that everything remains in sync. So at this point, we're actually controlling what columns are returned in the query itself. And so turning off stuff we don't need just makes the transaction with the database a little bit smaller.

Now, when we look at the particular purchases for this user, we don't want to see them for all the users. So we're going to change the person ID in this and make it a criteria for the query so we can provide it as a parameter. And then we will only get back the purchases that match the particular person. So we've parameterized it by doing that. So now we need to add a little bit of code. So we'll go back to the purchases JSP.

Actually let's customize the look and feel a little bit now. So the layout of the table is still sort of based on when we first dropped the Roset onto it. So let's go back to the layout dialog and clean it up a little bit. So we just have the original Roset columns in there.

So we'll go back through and change and put in some things that might look a little better. So what is the user going to want to see? Probably the purchase date and the name of the product and maybe a description in case they forget what it's called. And we can also shorten up what we're putting in the actual column display.

Now depending on what you're doing, if you're doing something more complex, you can actually change the component type that's used in each column. So you can have drop-downs in the column to get information back. You can have buttons to perform actions. You can use input text fields within the column. So you can mix and match depending on what you're doing. In this case, we're just going to be doing all output.

And we can also set up some paging. So we want to say, well, our screen's kind of small, and maybe these descriptions are going to be big. So let's limit the number of purchases shown to three per page and go ahead and turn on some navigation controls so the user can step through. And we'll just put those on the bottom.

So Creator then inserts the code automatically and sets up the components for this particular process the way we want. So we're going to see date, name, description of the products. So there's a little bit of code we're going to have to write, so we'll go back to the Java file. So the Java Bean that's behind this page This is all the code that's handling the navigation for the buttons that I just inserted.

There's one little bit of code that we're going to need to initialize the ROSEC query for the criteria. We want to tell it what person ID that we're going to put in there. We have this capability of code clips, so you can actually take code that you use commonly and just save it up on the pallet there. It's just a drag and drop clipboard.

In this case, it's really good for demos because you don't have to sit and type and make typos while everybody's watching you. One thing I found that I had trouble with with DP3 in this app is sometimes drag and drop was causing me trouble. I'm going to actually not try to do drag and drop today. I'm going to do it the hard way. Let me go back.

I'm just going So it's a couple lines of really one actual functioning line of code here is grab the data table model which is sort of the model side adapter for the table itself. Set object one to be the session being so the person ID from the session being.

So again remember the session is tracking the user and we have a property on the session which is the person's ID when they're logged in. And so we're just grabbing that integer property, popping it into the model so that it can be used as part of the query to the ROSA.

And at that point we should have an application that's ready to go. So why don't we go ahead and run it and see how it looks. So we're building it. At this point it's compiling all the Java files using Ant as a built-in compile engine. It's going to deploy the whole WAR file to the built-in application server.

So Java's So there we go. So we head on the browse page. That's where we put it, so let's go over to there. So there's our view purchases. Although in order for us to look at our purchases, we have to log in. We'll go ahead and log in first.

Um, probably would have, yeah. And what we can do is actually, when we show that this works, we'll go back in and we'll add some functionality so that we can hide the button when the user's not logged in. So I just popped it on there without doing any kind of checking so we can do something a little smarter with that. So now that we're logged in, it knows that we're Mr. Fubar. We can go to view purchases.

And there we go. We see we have three purchases or three or more. Some CDs we bought, various things there. This one I didn't set up the size of the table very well so we didn't fit into our box but there's the four so we're scrolling around through our purchase, take a look at that. So as this gentleman pointed out there, why don't we fix that functionality a little bit so instead of... ...losing track of where I am... ...instead of just always showing... ...I clicked on something I shouldn't have. Okay, so we're back.

You got rid of the leading comment, the opening comment. It's gone. Yeah. Don't know how you did that. I think I dragged and dropped a bunch of code up to the top. So let's see. Let's go to the browse page. That's where our button was. Get rid of this guy, get some more room.

We can take a look at almost all of the Java Server Faces components. There's an advanced property called rendered and this determines whether that the particular component is going to be rendered for that page rendering. So what you can actually do is have some logic in your back end beam that turns off certain components depending on things, depending on conditions or states, so you can actually have a page, a single page that's defined with different personalities depending on various settings and flags and things.

So we'll go ahead and turn that off and we'll do some behind the scenes work in this particular case. Let's see if I can find that guy. This is the top. So there's the button that we had just added. And one of the properties on the button that's actually managed normally by the UI is the rendered flag.

I'm sorry, actually I'm looking at the wrong button there. I'm trying to find the purchases. I should probably use the search feature. I'm going to go ahead and do that. I'm going While he's doing that. - He did. - So one of the things that we're looking at is it is a highly visual environment and as you can see, you also have code if you really are comfortable working there, which Carl is not right now.

And again, a lot of the things that we're trying to do is we're trying to make things as easy as possible for developers, so a lot of the things you'll see when you use the environment is, there's a lot of consistent gestures you do in the UI, which regardless of the type of action you're trying to perform are consistent. So you notice that while this may be a very western thing, everything you're trying to do in terms of drag and drop is from the left to the right.

So you drag components on from the left to the right, you drag services, you drag data, you drag, do everything from left to the right. Code clips, which you didn't show, and maybe we'll do it at the end to see if it works. Again, you drag and drop those. Those are parameterized, so for instance, you can in fact create reusable code clips and code snippets that you can use or you can provide other developers so they can create applications of this type.

And then everything on the right are things, are properties and attributes you control in terms of application, component properties, display properties, and so on. The other thing that the environment has is, we know that screen real estate can be quite limiting, so there's a number of capabilities in terms of auto hiding, and you can dock windows and different kinds of things like that. Did you find it?

What I'm gonna do is type this in now. Now somehow I ended up bound to something else which was surprising me, but I think this is the right place. So what we really wanna do is control this particular button's rendered property based on whether the user is logged on, logged in, logged on.

So on the session being itself, There is a property called logged on. So what we're doing here is using a feature of JSF which is called expression language EL and we're doing value binding. So we can just reference beans in our application by name and reference their properties.

So basically binding some particular behavior or look of the component to some data that's in the beans in the back end. So just by binding that. A lot of the properties in the tool have the UI

[Transcript missing]

So now we see that the button's not displayed here and we can go ahead and try to run that again.

So one of the things that we was talking about, you can create custom components for this. Everything that runs in the system are standard JSF components, so if you know how to write a JSF component, all of those you can easily drag and drop and put into applications that people can use.

There are a number of third parties which are creating components that work with Creator. I'd rather not mention them just because I'll probably miss one and they'll get upset at me, but companies like iLog and ChartFX and so on will do this. And they've created a number of components which work in Creator, And you can use them and design them and use them in applications every day.

So now we see we're back to the browse page and the button is hidden. So hopefully when I log in, The button will be enabled and there we go. So now it won't let us even navigate to the purchases page until we've got the logged in status true. So that didn't really require any code, just going in and typing a little expression. So go in under the covers if you need to and that's perfectly fine with Creator. It won't mess with your changes and it will respect everything you've done.

That's about all I had. Okay, so let's just try the drag and drop clip. Okay. We're at the end. Okay. It was just scaring me last night because it did really bad things. Then worked perfectly fine this morning. It was, you know how it goes. Pick a clip, any clip.

"It's not locked up. Oh yes it is. Okay. Anyway, it is amazing actually if you think about it. So the Apple engineers have actually built a new release of the JDK. He downloaded it last night and the whole thing is running on that JDK. So just that one little oopsie could be caused by us too. So the fact that, I mean, this is really cool stuff." "We're running the app server and the database and the IDE all on…" "Java database, Java application server and the tool all running on DP3." "Yeah." "Downloaded last night. Yeah, brave guy. Okay." "Yeah."

So let's talk a little bit about roadmap. The first thing that's interesting is that the early access available now and I know that various Mac people have found it because I'm seeing downloads. So what we're doing today is the hammerhead release is what we announced yesterday at Java 1, primarily for a number of platforms, not all of them, including a Mac, unfortunately, but it is designed to create dynamic web applications based on JSF. The Mac OS X, did it? Throw something at me. Steve isn't in the room, is he? Mac OS X release will be available within 90 days of our initial release.

Right now, you can get the initial release. If you go to a site you'll see on the slide here in a moment, you can download the EA, you can try it out, you can provide feedback. Part of that is you get into the forums, and if there's things that you believe need to be added, you can tell us now, and hopefully we can address them by the time we actually release the Mac OS X release.

Again, also, think about the book, and no, I didn't write it, so I'm not getting royalties, but you can get the book, and that will give you some discount when the final release comes out. You're going to save yourself. about 50 bucks and get the year subscription which gives you all the content that goes with this.

Thresher is an update that's primarily going to be based on customer feedback. So this is a release we're looking at roughly the end of the year. The main goal there is to take customer input and apply it to the product, fix some quality issues, improve the ease of use, and essentially increase the breadth of whatever coverage. So the number of app servers, number of databases, talking more to J2AE artifacts like EJBs and so on, easier for our customers.

When we get to the MAKO, which is a release we're targeting for next year, we're talking about broadening the client coverage. So richer clients, whether they're web or non-web, mobile devices, and again, simplified modeling. So one of the things that we really didn't show is we showed page navigation. We really didn't show application modeling. So how is this piece of logic talking, for instance, to a piece of logic on my app server?

So for more information, obviously you can contact us. So I'm Robert Brewin. Dan Roberts is in the Hawaiian shirt over there because I think he's going on vacation soon. And Jim Inscore who I don't think is here. Go to www.sun.com/jscreator. Follow the links, download the EA. You can take a look at some of the form samples and examples that are out there. Obviously, the Apple reference library will give you access to that stuff.

WEBVTT

00:00:12.150 --> 00:00:14.360
Good morning.

00:00:14.360 --> 00:00:17.280
How's everybody doing this morning?

00:00:18.250 --> 00:00:19.200
That's very exciting.

00:00:19.200 --> 00:00:22.700
Actually, after that party last night,
I'd say that's a good

00:00:22.700 --> 00:00:23.800
energy level to have.

00:00:24.000 --> 00:00:26.700
Everybody enjoy the party last night?

00:00:28.200 --> 00:01:07.900
[Transcript missing]

00:01:08.060 --> 00:01:11.200
Before we get started,
let me just do the old poll thing.

00:01:11.240 --> 00:01:15.490
How many folks in the
room are brand new to EOF?

00:01:15.810 --> 00:01:17.030
Okay, so we got a few folks.

00:01:17.160 --> 00:01:17.540
Excellent.

00:01:17.670 --> 00:01:21.180
And how many folks would
say you're intermediate?

00:01:21.710 --> 00:01:22.490
Okay, great.

00:01:22.500 --> 00:01:25.710
And how many of your advanced folks
are just here to make trouble?

00:01:25.720 --> 00:01:27.840
Oh, yeah!

00:01:31.600 --> 00:01:33.580
Great.

00:01:33.580 --> 00:01:35.160
Excellent!

00:01:35.160 --> 00:01:35.610
OK.

00:01:36.140 --> 00:01:39.480
So what we're going to
be doing in this session,

00:01:39.480 --> 00:01:43.460
to get rolling, is we're going to do,
for folks who are brand new,

00:01:43.460 --> 00:01:44.440
a bit of the basics.

00:01:44.440 --> 00:01:48.540
So you get your mind around a
little bit about what EOF is about.

00:01:48.630 --> 00:01:52.530
And then we're going to
cover some advanced topics.

00:01:52.870 --> 00:01:55.080
We're also going to do
an architecture review,

00:01:55.210 --> 00:01:56.680
which is helpful for the new folks.

00:01:56.790 --> 00:02:00.440
But also I find that when you're
talking about advanced topics,

00:02:00.460 --> 00:02:03.840
it's really good to have kind of
the picture of what's going on in

00:02:03.990 --> 00:02:07.720
EOF clearly and freshly in your head.

00:02:07.750 --> 00:02:10.760
So first, let's do the basics review.

00:02:11.670 --> 00:02:13.980
So the Enterprise Objects Framework.

00:02:14.140 --> 00:02:16.270
What is this thing?

00:02:16.450 --> 00:02:20.240
So the basic idea,
it's an object persistence framework.

00:02:20.240 --> 00:02:23.570
Largely, the goal here is that you can
look at it one of two ways.

00:02:23.610 --> 00:02:27.100
Either you have this lovely
object-oriented WebObjects application,

00:02:27.100 --> 00:02:30.810
and then you need some place over
the network for the information

00:02:31.160 --> 00:02:34.590
that you've collected from users
or want to display to users.

00:02:34.590 --> 00:02:38.020
You need a spot for that to persist,
and a relational database

00:02:38.020 --> 00:02:39.250
is a very good spot.

00:02:39.300 --> 00:02:43.280
Or the other way is usually more
often you already have a database,

00:02:43.360 --> 00:02:47.180
and you want to pull the information out,
but you'd like to deal with it

00:02:47.250 --> 00:02:50.520
in a nice object-oriented manner
in a WebObjects application,

00:02:50.520 --> 00:02:53.520
and EOF fits the bill.

00:02:53.520 --> 00:02:56.000
So it uses object-relational mapping.

00:02:56.000 --> 00:02:59.120
Mapping we'll see in a moment
from an object model to a

00:02:59.120 --> 00:03:01.120
relational database model.

00:03:01.120 --> 00:03:06.240
And the goal, or a goal,
is that rather than thinking a lot

00:03:06.240 --> 00:03:09.280
about what SQL joins am I doing?

00:03:09.280 --> 00:03:10.850
And what foreign keys?

00:03:10.860 --> 00:03:14.810
And all this kind of
database-specific stuff,

00:03:14.810 --> 00:03:19.570
to try to use objects that
you've gotten from the database

00:03:19.570 --> 00:03:22.250
in as OO a manner as possible.

00:03:25.360 --> 00:03:28.130
So in a nutshell,
we're going from a row in

00:03:28.130 --> 00:03:33.140
the database to an object,
and then make some changes to it maybe,

00:03:33.200 --> 00:03:36.180
and then make sure it gets
back in the correct state.

00:03:36.180 --> 00:03:40.790
That, in a nutshell,
is the crux of what EOF is doing.

00:03:40.790 --> 00:03:44.240
Should be easy, right?

00:03:44.880 --> 00:03:49.700
All right,
so let's talk about some terms.

00:03:49.700 --> 00:03:50.800
Entities and attributes.

00:03:50.880 --> 00:03:56.380
So an entity refers to essentially a
class in your object model which will

00:03:56.570 --> 00:04:00.040
map to a table or view in the database.

00:04:00.170 --> 00:04:05.550
An attribute is mapping a column in the
table to a property or think of it as an

00:04:05.550 --> 00:04:09.310
instance variable in the object model.

00:04:10.100 --> 00:04:15.190
And then relationships in an object
model are typically done by reference.

00:04:15.200 --> 00:04:18.920
In this case, an employee is referring
to one department.

00:04:19.000 --> 00:04:22.450
But of course,
when we go to a database model,

00:04:22.660 --> 00:04:24.000
we're using a join.

00:04:24.000 --> 00:04:26.990
So a foreign key,
in this case in the employee table,

00:04:27.000 --> 00:04:30.000
is mapping to the primary
key of the department.

00:04:31.000 --> 00:04:36.000
And it's EOF's job to allow you to work
with objects largely in this fashion,

00:04:36.000 --> 00:04:40.000
where you're setting the
department of that employee.

00:04:40.260 --> 00:04:45.210
And then when you save those changes,
of course you want it to translate

00:04:45.210 --> 00:04:47.870
to the proper join in the database.

00:04:50.220 --> 00:04:52.780
So what are Enterprise Objects?

00:04:52.830 --> 00:04:55.440
We talked about what the framework is.

00:04:55.440 --> 00:05:00.520
Well, you'll hear them referred
to all the time as EOs.

00:05:00.520 --> 00:05:03.460
All that that means largely
is that they implement the

00:05:03.460 --> 00:05:05.960
EO Enterprise Object Interface.

00:05:06.270 --> 00:05:10.420
Typically, you don't implement
that interface yourself.

00:05:10.420 --> 00:05:13.970
Any of you troublemakers,
have you ever implemented the

00:05:14.040 --> 00:05:16.880
EO Enterprise Object Interface yourself?

00:05:17.260 --> 00:05:18.740
No, nobody.

00:05:18.810 --> 00:05:20.490
Nobody ever has.

00:05:20.800 --> 00:05:21.580
It comes with the framework.

00:05:21.660 --> 00:05:23.250
You don't need to do so.

00:05:23.670 --> 00:05:28.940
Typically, you subclass EO generic record
and put your own custom logic

00:05:28.940 --> 00:05:31.040
in there if you need to.

00:05:31.040 --> 00:05:36.190
But largely,
you can think of an Enterprise Object as

00:05:36.190 --> 00:05:41.170
just an object like any other,
except having all the

00:05:41.170 --> 00:05:42.280
additional functionality to
have built-in persistence.

00:05:44.750 --> 00:05:48.570
Now, especially when you first
start working with EOF,

00:05:48.730 --> 00:05:53.160
the first thing you're going to encounter
is defining a model to map between that

00:05:53.160 --> 00:05:56.600
object model and the relational database.

00:05:56.820 --> 00:05:59.270
And we do that in a
tool called EO Modeler,

00:05:59.270 --> 00:06:01.870
and we'll see a demo of it in a moment.

00:06:02.670 --> 00:06:04.490
Actually, we will see it in a moment.

00:06:04.590 --> 00:06:07.060
Where did my demo slide go?

00:06:07.380 --> 00:06:09.810
Well, regardless,
it seems to have disappeared.

00:06:09.890 --> 00:06:13.220
Let's cut over to demo one, if we could.

00:06:19.770 --> 00:06:20.560
All right.

00:06:20.670 --> 00:06:27.890
We're going to build a model from
scratch in a tool called EOModeler.

00:06:28.770 --> 00:06:34.970
We're going to use an existing database
that a few of you might be familiar with.

00:06:36.670 --> 00:06:43.120
So we connect using JDBC to
a wide range of databases.

00:06:45.150 --> 00:06:47.980
We just need a JDBC URL, which I have.

00:06:48.040 --> 00:06:50.920
Let me click in the field there.

00:06:54.800 --> 00:06:58.780
We're using an open-based
database which has some examples,

00:06:58.780 --> 00:07:01.710
including one that contains some movies.

00:07:04.200 --> 00:07:11.040
And as we pick that URL,
EOModeler takes a peek into the database,

00:07:11.080 --> 00:07:14.890
asks us a few things,
and we're just concerned about

00:07:14.890 --> 00:07:19.300
assigning primary keys to
everything that gets pulled in.

00:07:19.530 --> 00:07:22.150
And then we get a list of all the tables.

00:07:22.150 --> 00:07:25.390
We're going to choose
Movie as one of the tables.

00:07:25.390 --> 00:07:28.660
But as, I don't know,
can anybody tell me what a

00:07:28.660 --> 00:07:30.370
movie might be related to?

00:07:31.630 --> 00:07:34.960
That's right, a studio.

00:07:35.020 --> 00:07:37.100
Every movie is related to a studio.

00:07:37.100 --> 00:07:39.900
So we're going to pull
in these two tables.

00:07:39.900 --> 00:07:44.610
As we hit next and dismiss the wizard,

00:07:44.870 --> 00:07:49.170
EOModeler has read the schema and
reverse engineered the database and

00:07:49.170 --> 00:07:52.920
given us the beginnings of a model.

00:07:53.330 --> 00:07:55.760
So if we take a look
first at the model itself,

00:07:55.810 --> 00:08:00.650
you'll notice that it is mapping
a table name to a class name,

00:08:00.730 --> 00:08:05.200
in this case, a generic record,
which is a generic class that can

00:08:05.650 --> 00:08:10.800
be any type of entity as long as you
don't need to add any custom behavior.

00:08:10.910 --> 00:08:12.300
So we have a movie and a studio.

00:08:12.300 --> 00:08:15.660
If we take a look at a movie,
you'll notice that a movie

00:08:15.660 --> 00:08:17.220
has various items here.

00:08:17.520 --> 00:08:20.910
Let's pick one, such as the title.

00:08:21.400 --> 00:08:25.410
If we inspect it,
you'll notice that this attribute is

00:08:25.410 --> 00:08:30.990
mapping the name of this attribute to
a particular column in the database.

00:08:31.010 --> 00:08:36.100
In the database,
it's a car with a width of 255.

00:08:36.530 --> 00:08:40.160
Internally, we'll be using a string
to represent this item.

00:08:40.450 --> 00:08:46.030
The same is true if we take a look at,
say, a number or a date.

00:08:46.040 --> 00:08:50.530
It's just a mapping between a column
in the database and its data type

00:08:50.530 --> 00:08:55.210
and a name of an attribute in our
object model and its data type.

00:08:55.560 --> 00:08:59.800
And then finally,
we can take a look at a relationship.

00:08:59.850 --> 00:09:02.280
Looking at the foreign
keys and primary keys,

00:09:02.280 --> 00:09:07.160
EO Modeler has figured out that
a movie is related to a studio.

00:09:07.320 --> 00:09:10.020
In this case, it has a 2-1 relationship.

00:09:10.040 --> 00:09:12.280
And if we take a look,
you'll notice that it

00:09:12.280 --> 00:09:15.040
has already chosen a 2-1.

00:09:15.060 --> 00:09:16.940
It's related to a studio.

00:09:16.980 --> 00:09:21.350
And it is mapping the foreign key,
the studio ID,

00:09:23.080 --> 00:09:27.600
To the studio ID of the studio.

00:09:27.600 --> 00:09:32.110
And once we set that join
information up in EO Modeler,

00:09:32.280 --> 00:09:34.510
At that point,
we no longer have to worry about

00:09:34.590 --> 00:09:40.000
those foreign keys and primary keys,
as EOF will take care of that.

00:09:40.110 --> 00:09:43.970
We'll save that as movies,
put it on the desktop.

00:09:44.930 --> 00:09:45.740
Now we'll close the model.

00:09:45.740 --> 00:09:48.490
Actually, let's look at one other thing.

00:09:48.580 --> 00:09:51.680
The fact that right here from EOModeler,
I can make sure that I do

00:09:51.680 --> 00:09:55.020
have a good connection to the
database by browsing the model.

00:09:55.020 --> 00:10:01.100
And I'm taking a look now at all of
the movies that are in our database.

00:10:04.460 --> 00:10:05.370
Great.

00:10:05.510 --> 00:10:06.420
Okay.

00:10:06.710 --> 00:10:09.800
Now, that's interesting,
but you're not going to give you

00:10:09.800 --> 00:10:13.390
a modeler out to everybody who
wants to look in your database.

00:10:13.500 --> 00:10:15.380
You're going to build a web application.

00:10:15.490 --> 00:10:16.780
So let's go to Xcode.

00:10:16.780 --> 00:10:19.820
We'll make a small, quick project.

00:10:22.380 --> 00:10:25.500
We'll use a display group
application since it'll quickly

00:10:25.500 --> 00:10:29.360
build a user interface for us,
and walk through the wizard.

00:10:29.470 --> 00:10:31.830
We'll call it Demo Woe.

00:10:32.300 --> 00:10:34.740
We're not going to
deploy it in a servlet.

00:10:34.870 --> 00:10:37.910
We're not going to use web services.

00:10:37.920 --> 00:10:40.170
But we are going to use JDBC.

00:10:40.390 --> 00:10:44.480
So that is the adapter we'll
choose to connect to the database.

00:10:44.800 --> 00:10:48.140
We don't need any additional frameworks,
but we do need to choose

00:10:48.510 --> 00:10:50.970
the model we just created.

00:10:51.380 --> 00:10:54.600
Pick that model, choose it,
and now it'll ask us some

00:10:54.650 --> 00:10:57.650
questions regarding the first
page of this application as

00:10:57.650 --> 00:10:59.560
we build its user interface.

00:10:59.680 --> 00:11:02.710
So, the movie entity.

00:11:03.580 --> 00:11:07.800
Let's get a table and matching
records so we can do a search,

00:11:07.820 --> 00:11:10.280
so we don't get them all at once.

00:11:11.290 --> 00:11:12.940
What attributes do we want to display?

00:11:12.940 --> 00:11:14.170
Let's display a couple.

00:11:14.170 --> 00:11:15.350
First, the title.

00:11:15.490 --> 00:11:18.730
Let's do the category,
what date it was released,

00:11:18.860 --> 00:11:21.740
as well as how much revenue it took in.

00:11:21.910 --> 00:11:24.980
And finally,
let's traverse that relationship

00:11:24.980 --> 00:11:29.010
to the related studio and
display the studio's name.

00:11:31.370 --> 00:11:33.100
What attributes do we want to display?

00:11:33.130 --> 00:11:34.370
Let's display a couple.

00:11:34.370 --> 00:11:35.660
First, the title.

00:11:35.660 --> 00:11:38.980
Let's do the category,
what date it was released,

00:11:38.980 --> 00:11:40.700
as well as how much revenue it took in.

00:11:40.700 --> 00:11:40.700
And finally,
let's traverse that relationship

00:11:40.700 --> 00:11:40.700
to the related studio and
display the studio's name.

00:11:46.480 --> 00:11:47.240
There we go.

00:11:47.300 --> 00:11:49.380
Okay.

00:11:49.500 --> 00:11:51.770
If we take a peek at this.

00:11:54.800 --> 00:11:56.800
will bring up the editor.

00:11:56.800 --> 00:12:01.130
You'll notice that we really
have no code going on here.

00:12:03.850 --> 00:12:06.370
Take a look at the application file.

00:12:06.490 --> 00:12:08.080
A user session file.

00:12:08.080 --> 00:12:10.100
It's just a constructor.

00:12:10.300 --> 00:12:16.300
And then in a WebObjects application,
we use components to represent pages.

00:12:16.320 --> 00:12:19.100
And in the main component,
which is the first one that's

00:12:19.200 --> 00:12:23.250
displayed in a WebObjects application,
we do not have any additional

00:12:23.340 --> 00:12:26.470
code except for some variables
to hold a display group,

00:12:26.470 --> 00:12:30.890
which displays the array of objects,
and the movie itself.

00:12:31.560 --> 00:12:36.020
Let's open up the component
in WebObjects Builder where

00:12:36.110 --> 00:12:38.200
we define the user interface.

00:12:38.200 --> 00:12:41.530
And you'll notice that it's created
for us a user interface with a search

00:12:41.540 --> 00:12:46.840
field as well as a table view to display
all of the movies that it's found.

00:12:46.840 --> 00:12:50.560
Let's clean up some of these names.

00:12:50.560 --> 00:12:55.460
That's the one that bothers me the most
because it's got that dot in there.

00:12:55.460 --> 00:12:57.520
Let's center everything.

00:12:57.520 --> 00:12:58.520
That wasn't center.

00:12:58.520 --> 00:13:00.100
There we go.

00:13:01.690 --> 00:13:04.400
And let's run this application.

00:13:04.750 --> 00:13:07.600
So it's building and
running the application.

00:13:07.600 --> 00:13:09.600
And what we're going to see
is a web page displayed,

00:13:09.600 --> 00:13:14.600
and we'll be able to search and display
the information from within the database,

00:13:14.700 --> 00:13:20.530
primarily using the information that was
generated and put into that model file.

00:13:20.670 --> 00:13:21.600
So we can search for movies.

00:13:21.600 --> 00:13:25.600
Okay, I guess I didn't center that puppy.

00:13:25.600 --> 00:13:28.100
Let's go back and center it.

00:13:28.170 --> 00:13:30.600
There we go.

00:13:30.600 --> 00:13:32.850
And let's look for action movies.

00:13:37.080 --> 00:13:38.350
There are all of our action movies.

00:13:38.360 --> 00:13:42.140
You'll notice that we have the title,
the category,

00:13:42.250 --> 00:13:46.530
the date released using a date formatter,
so you can easily format that to

00:13:46.530 --> 00:13:49.020
whatever display string you wish.

00:13:49.070 --> 00:13:52.620
Revenue using a number formatter,
so you can automatically format that

00:13:52.770 --> 00:13:55.040
to whatever number format you wish.

00:13:55.200 --> 00:13:59.970
And then traversing the relationship
from a movie table over to studios

00:13:59.970 --> 00:14:02.720
and getting the related studio name.

00:14:03.130 --> 00:14:06.800
And if we type in nothing,
we should get all of the movies,

00:14:06.900 --> 00:14:09.590
of which we have a number.

00:14:10.060 --> 00:14:14.500
That's an introduction of
how you can begin using EOF,

00:14:14.800 --> 00:14:19.450
primarily starting by generating
a model and then building a simple

00:14:19.450 --> 00:14:23.780
project to get your feet wet with
using the model and seeing how

00:14:23.780 --> 00:14:25.000
it interacts with the database.

00:14:25.000 --> 00:14:26.180
Thanks.

00:14:26.180 --> 00:14:27.660
That's it for that demo.

00:14:33.400 --> 00:14:34.130
Okay.

00:14:34.330 --> 00:14:39.540
So now we've got the
introduction out of the way.

00:14:39.540 --> 00:14:42.780
Let's talk a little bit about
the architecture of EOF and

00:14:42.890 --> 00:14:44.830
how it's doing all that stuff.

00:14:44.830 --> 00:14:48.510
Because that does look like there's
a lot of heavy lifting being done

00:14:48.530 --> 00:14:51.760
behind the scenes that obviously
I did not have to do in that demo.

00:14:51.760 --> 00:14:55.100
A lot of it does have to
do with this configuration.

00:14:57.220 --> 00:15:00.900
Andreas likes to say that you need to
spend quality time with your model.

00:15:01.100 --> 00:15:01.900
And that is true.

00:15:02.140 --> 00:15:08.220
Because a lot of what EOF is
doing is based on what that

00:15:08.260 --> 00:15:12.840
model is configured to do,
how that mapping is configured,

00:15:12.840 --> 00:15:14.960
and the details of that model.

00:15:17.480 --> 00:15:22.240
So let's take a look at this,
what we call the EOF stack,

00:15:22.400 --> 00:15:27.950
starting with a database,
pre-existing quite often, and the model.

00:15:29.340 --> 00:15:31.150
Now the model you think
if it's so important,

00:15:31.150 --> 00:15:32.530
why isn't it in the middle?

00:15:32.700 --> 00:15:35.600
Well really the model is
configuration information.

00:15:35.850 --> 00:15:41.010
And it's being used as a reference so
the rest of the stack knows what to do.

00:15:41.200 --> 00:15:44.580
In fact, you could potentially
have multiple models,

00:15:44.690 --> 00:15:48.160
each model referring to
a different data source.

00:15:48.390 --> 00:15:53.920
So you could have one looking up
directory information using JNDI and

00:15:53.920 --> 00:15:57.200
another using JDBC to hit a database.

00:15:57.290 --> 00:16:02.020
Actually,
I have an app that does such a thing.

00:16:02.310 --> 00:16:06.030
Since you can have multiple models,
there's a class called the Model Group,

00:16:06.070 --> 00:16:08.970
which we won't talk about much,
but its main purpose in life is

00:16:09.120 --> 00:16:12.660
to manage the fact that there are
more than one models potentially.

00:16:14.120 --> 00:16:19.600
That model group is referred to
by the Object Store Coordinator.

00:16:19.730 --> 00:16:24.680
And as we'll see as we talk,
the Object Store Coordinator is,

00:16:25.070 --> 00:16:27.750
you can refer to it as the root object,
or it's kind of the

00:16:27.750 --> 00:16:29.130
center of an EOF stack.

00:16:29.460 --> 00:16:33.100
It's got some stuff going on above
it and some stuff going on below it,

00:16:33.100 --> 00:16:35.590
but it's really doing a
lot of the coordination,

00:16:35.920 --> 00:16:36.700
thus its name.

00:16:36.700 --> 00:16:40.490
It's also kind of the choke
point for doing things like

00:16:40.490 --> 00:16:43.700
multi-threading and concurrent access.

00:16:43.700 --> 00:16:46.570
Essentially,
that Object Store Coordinator is

00:16:46.570 --> 00:16:48.560
the centerpiece of an EOF stack.

00:16:50.380 --> 00:16:53.670
Now going up the stack,
because this is the object

00:16:53.890 --> 00:16:58.240
that as in using EOF you will
most often interact with,

00:16:58.310 --> 00:17:00.300
is the editing context.

00:17:00.390 --> 00:17:04.140
And the editing context
is the go-to object.

00:17:04.340 --> 00:17:07.890
If EOF were a movie,
the editing context would

00:17:07.890 --> 00:17:10.290
be the leading man or woman.

00:17:10.300 --> 00:17:11.300
I don't know which.

00:17:11.300 --> 00:17:15.300
We've never established the
gender of the editing context.

00:17:15.300 --> 00:17:17.300
Andreas, any?

00:17:17.300 --> 00:17:19.990
No preference.

00:17:21.500 --> 00:17:23.540
So the editing context is your go-to.

00:17:23.540 --> 00:17:25.030
You ask it to fetch.

00:17:25.030 --> 00:17:27.900
It's the object that you,
when you create a new enterprise object,

00:17:27.900 --> 00:17:32.030
you insert it into the editing context
so it'll be ready to get inserted

00:17:32.030 --> 00:17:35.860
in the database the next time you
tell the editing context to save.

00:17:36.020 --> 00:17:39.480
When you delete an object,
you have to tell the editing context.

00:17:39.860 --> 00:17:42.900
When you have a bunch of changes
and you want to revert them,

00:17:43.210 --> 00:17:44.730
you tell the editing context.

00:17:45.030 --> 00:17:47.920
And whenever you change
an enterprise object,

00:17:47.920 --> 00:17:52.490
the editing context is observing,
and so it notices those changes,

00:17:52.820 --> 00:17:56.710
keeps track of that fact so it knows
to save those changes to the database.

00:17:56.800 --> 00:18:02.230
So the editing context is
really your go-to object in EOF.

00:18:02.790 --> 00:18:05.920
Now when you do ask an
editing context to fetch,

00:18:05.920 --> 00:18:09.520
and that is essentially what
we did when we typed in action

00:18:09.520 --> 00:18:13.360
and hit the submit button,
the editing context was asked, "Hey,

00:18:13.360 --> 00:18:17.860
go get things that have
action as their category."

00:18:18.500 --> 00:18:22.090
Coming down the stack,
the object store coordinator finds

00:18:22.090 --> 00:18:24.060
out there's a fetch going on.

00:18:24.060 --> 00:18:26.170
On the fly,
it actually creates these next

00:18:26.170 --> 00:18:28.500
objects if they weren't there already.

00:18:28.520 --> 00:18:29.860
We'll talk about what
they do in a moment.

00:18:29.880 --> 00:18:35.300
Then the adapter is what
actually talks to the database.

00:18:35.300 --> 00:18:42.260
So let's say that fetch category we
want action heads all the way down.

00:18:43.080 --> 00:18:46.750
The JDBC adapter is going to
generate the SQL that actually

00:18:46.750 --> 00:18:50.000
gets sent to the database,
and what it's going to get

00:18:50.150 --> 00:18:51.720
back are called raw rows.

00:18:51.720 --> 00:18:52.960
They're not fancy.

00:18:52.960 --> 00:18:54.960
They're not enterprise objects.

00:18:55.020 --> 00:18:58.300
They're just dictionaries
full of key-value pairs.

00:18:58.300 --> 00:19:03.300
There's nothing particularly
special about them.

00:19:03.300 --> 00:19:05.350
They're just raw data containers.

00:19:05.350 --> 00:19:08.690
They also don't take advantage
of a lot of the nice features

00:19:08.690 --> 00:19:10.360
and functionality of EOF.

00:19:10.460 --> 00:19:12.580
That happens at the next layer up.

00:19:13.280 --> 00:19:17.520
Those raw rows are handed from the
adapter layer up to the database layer

00:19:17.850 --> 00:19:20.360
where a raw row is turned into an EO.

00:19:20.360 --> 00:19:22.750
It's kind of like Pinocchio
becoming a real boy.

00:19:22.760 --> 00:19:24.900
That's essentially what it is.

00:19:25.070 --> 00:19:28.120
Instead of a wooden raw row,
you get a full-fledged object

00:19:28.180 --> 00:19:30.200
with an object graph and the like.

00:19:30.280 --> 00:19:33.660
At that time,
a very specific thing happens.

00:19:33.660 --> 00:19:38.760
A snapshot is taken of that row.

00:19:38.760 --> 00:19:42.880
That snapshot, as we'll see in a moment,
is maintained.

00:19:43.140 --> 00:19:45.080
It's a very simple way to do that.

00:19:45.080 --> 00:19:49.560
We'll see that snapshot is very important
when we talk about data freshness,

00:19:49.560 --> 00:20:06.070
which we will do today.

00:20:08.230 --> 00:20:11.760
So that snapshot occurs,
and at the same time,

00:20:11.830 --> 00:20:15.890
that raw row is turned into an EO,
an enterprise object of the

00:20:15.890 --> 00:20:20.010
correct class that you specified
in the model is created.

00:20:20.310 --> 00:20:22.180
The data is populated.

00:20:22.220 --> 00:20:24.750
Any related-- well,
we'll get to that in a moment,

00:20:24.770 --> 00:20:26.720
because there's the EO.

00:20:26.960 --> 00:20:32.210
And finally, besides that EO,
any relationships, a little object is

00:20:32.210 --> 00:20:34.300
created called a fault.

00:20:34.300 --> 00:20:38.820
It's a little placeholder that says,
well, you don't necessarily

00:20:38.950 --> 00:20:43.240
need the studio right now,
or you don't necessarily need the list

00:20:43.280 --> 00:20:48.220
of every time I've logged in that's
a related to many array right now.

00:20:48.320 --> 00:20:50.090
Just put a little placeholder there.

00:20:50.090 --> 00:20:53.480
When you ask for it, I'll go get it then.

00:20:54.100 --> 00:20:55.100
Okay.

00:20:55.100 --> 00:20:56.860
I'm going to go forward, but I forget.

00:20:57.010 --> 00:20:58.310
That might take me too far.

00:20:58.450 --> 00:20:59.440
Yes, it did.

00:20:59.600 --> 00:21:00.060
Oh, no.

00:21:00.060 --> 00:21:00.870
I've got to build it again.

00:21:00.920 --> 00:21:01.160
Okay.

00:21:04.700 --> 00:21:05.940
Quick review.

00:21:06.010 --> 00:21:08.220
As they go by, remember what I said.

00:21:08.260 --> 00:21:11.510
Everybody with me?

00:21:11.510 --> 00:21:13.600
Excellent.

00:21:14.010 --> 00:21:17.450
So looking at this,
when we talk about advanced topics,

00:21:17.450 --> 00:21:20.200
it's good to have this
picture in your head.

00:21:20.290 --> 00:21:23.320
It can be, you know,
you can use circles instead of

00:21:23.320 --> 00:21:25.810
boxes in your head if you want.

00:21:25.810 --> 00:21:27.880
It's your head.

00:21:27.880 --> 00:21:30.620
But the basic structure
should remain the same.

00:21:30.620 --> 00:21:34.420
And the things to think about are
the things that you often need to

00:21:34.480 --> 00:21:38.220
think about are what's going on,
that relationship between

00:21:38.220 --> 00:21:42.090
the EO and its snapshot,
what's going on with these faults,

00:21:42.210 --> 00:21:45.720
when are they getting triggered.

00:21:45.720 --> 00:21:50.250
Those tend to be very important control
points when talking about things like

00:21:50.250 --> 00:21:58.020
memory management or data freshness of
your things that are in your EOF stack.

00:21:58.020 --> 00:22:01.080
Now let's talk about a couple
of common configurations of EOF.

00:22:01.080 --> 00:22:06.040
The first of which is
multiple editing contexts.

00:22:06.040 --> 00:22:09.900
And so in addition to one editing
context on top of this stack,

00:22:10.050 --> 00:22:10.950
we can have many.

00:22:10.950 --> 00:22:14.370
And in fact,
this is the default configuration

00:22:14.430 --> 00:22:16.940
of a WebObjects application.

00:22:16.940 --> 00:22:21.860
Every user that shows up to
the site gets a new session.

00:22:21.860 --> 00:22:26.940
Every session has a new default
editing context which sits on top of

00:22:27.010 --> 00:22:30.880
the same object store coordinator.

00:22:30.880 --> 00:22:30.880
What that means is that every session
has a new default editing context.

00:22:30.880 --> 00:22:34.320
So what that means is that they
all share the same snapshot.

00:22:34.320 --> 00:22:38.190
And so this is where some of
that caching comes into play,

00:22:38.330 --> 00:22:42.320
where just because somebody
just showed up to your site,

00:22:42.320 --> 00:22:46.890
doesn't necessarily mean that we have
to fetch everything once again for them,

00:22:47.290 --> 00:22:51.270
because a snapshot from somebody else's
session might have already grabbed

00:22:51.600 --> 00:22:54.870
that information and kept it in memory.

00:22:55.530 --> 00:22:59.400
And so we can have that
same row in the database,

00:22:59.490 --> 00:23:04.040
have a snapshot for it,
and have... I'm going to... Yeah,

00:23:04.250 --> 00:23:04.660
there we go.

00:23:08.140 --> 00:23:10.850
I'm having some clicker problems.

00:23:11.000 --> 00:23:11.860
Okay.

00:23:11.980 --> 00:23:15.580
So in this case,
these EOs could both be the same

00:23:15.580 --> 00:23:19.000
row underneath in the database,
but they're in different

00:23:19.000 --> 00:23:21.940
editing contexts,
which means that one user can

00:23:21.940 --> 00:23:25.740
make some edits to it and then
decide not to save those edits.

00:23:25.740 --> 00:23:30.140
The other could do the same,
but underneath both of

00:23:30.560 --> 00:23:33.180
these EOs is a snapshot.

00:23:33.410 --> 00:23:36.140
I'm having some clicker problems.

00:23:36.140 --> 00:23:37.040
Okay.

00:23:37.130 --> 00:23:40.780
So in this case,
these EOs could both be the same

00:23:40.780 --> 00:23:44.210
row underneath in the database,
but they're in different

00:23:44.210 --> 00:23:45.580
editing contexts,
which means

00:23:45.770 --> 00:23:48.000
And we'll add two stacks.

00:23:48.130 --> 00:23:51.840
Now, you say, well, wow, multiple stacks.

00:23:51.840 --> 00:23:53.900
That sounds kind of out there.

00:23:53.910 --> 00:23:56.700
But really,
as soon as you launch a second instance

00:23:56.700 --> 00:24:00.260
of your WebObjects application,
you have a situation where

00:24:00.260 --> 00:24:01.920
you have multiple stacks.

00:24:02.080 --> 00:24:03.620
One app has one stack.

00:24:03.620 --> 00:24:05.570
One app has the other stack.

00:24:05.640 --> 00:24:09.610
And as we'll see here,
they can both deal with the

00:24:09.610 --> 00:24:13.990
same row from the database,
but they have a different

00:24:13.990 --> 00:24:15.580
set of snapshots.

00:24:15.600 --> 00:24:18.860
One stack does not know
about the other stack.

00:24:18.860 --> 00:24:24.500
And what essentially defines creating a
stack is that object store coordinator,

00:24:24.500 --> 00:24:26.600
that middle center piece.

00:24:26.600 --> 00:24:29.550
Okay.

00:24:32.850 --> 00:24:36.020
That said, everybody, well, actually,
let's go back one.

00:24:36.020 --> 00:24:37.880
Everybody have that clear in your mind.

00:24:37.880 --> 00:24:40.940
So now we're going to talk about
memory management and then a

00:24:40.940 --> 00:24:42.980
little bit about data freshness.

00:24:42.980 --> 00:24:44.180
So memory management.

00:24:46.880 --> 00:24:51.890
As I looked at this material,
I realized that I was using EOF circa

00:24:51.890 --> 00:24:57.340
4.5 in my head rather than 5.2.3.

00:24:58.850 --> 00:25:01.710
So, things to note:
the editing context is

00:25:01.710 --> 00:25:05.280
using weak references,
so only things that it

00:25:05.360 --> 00:25:08.900
actually needs to hold onto,
things that are pending inserts, deletes,

00:25:08.900 --> 00:25:11.700
or edits, or updates,
need to be retained.

00:25:11.750 --> 00:25:16.700
But the EO itself has a strong
reference back to its editing context.

00:25:16.700 --> 00:25:19.690
This has a couple of caveats.

00:25:19.700 --> 00:25:23.700
The first is that if you ask for
all the registered objects in an EO,

00:25:23.700 --> 00:25:29.690
it's not particularly useful as some of
them may have been garbage collected.

00:25:29.700 --> 00:25:35.250
You can, if you want the old behavior,
set retains registered objects,

00:25:35.540 --> 00:25:38.620
which will do that on
the editing context.

00:25:38.860 --> 00:25:42.620
The editing context subclass,
shared editing context,

00:25:42.620 --> 00:25:46.180
always does use strong references,
I should say.

00:25:46.520 --> 00:25:47.240
So faulting.

00:25:47.240 --> 00:25:51.090
I talked a little bit before about that
kind of ghost object called a fault.

00:25:51.120 --> 00:25:55.710
What that is, in essence,
is an empty shell of a

00:25:55.710 --> 00:25:58.090
particular type of object.

00:25:58.290 --> 00:26:01.920
So as this says, the size of the fault
is the size of the EO.

00:26:01.920 --> 00:26:05.710
It's essentially created
using the constructor,

00:26:05.710 --> 00:26:10.610
but not initialized with values to
defer the fetching of that value

00:26:10.610 --> 00:26:13.570
until you need to access the object.

00:26:13.890 --> 00:26:18.670
But what this means is that when
we fetched in that original movie,

00:26:18.670 --> 00:26:22.580
there was a fault of a studio
kind of hanging out there,

00:26:22.580 --> 00:26:25.060
taking up as much size as a studio.

00:26:25.060 --> 00:26:29.980
Deferred faults allows a setting
that essentially allows that creation

00:26:30.010 --> 00:26:34.470
of the fault even to be deferred,
so that there's this single shared

00:26:34.870 --> 00:26:40.200
object that's standing in for the fault,
which is a stand-in for the real object,

00:26:40.200 --> 00:26:42.720
that is more memory efficient.

00:26:44.350 --> 00:26:48.490
So if you are extending
EO generic record,

00:26:48.490 --> 00:26:51.690
you'll automatically
have deferred faulting.

00:26:51.860 --> 00:26:57.500
Otherwise, you will want to-- if you're
using EO custom object,

00:26:57.700 --> 00:27:03.660
you will want to override a method which
seems to have disappeared from the slide.

00:27:03.660 --> 00:27:08.560
I think something like
uses deferred faulting.

00:27:08.560 --> 00:27:11.490
You want to return true to that.

00:27:11.750 --> 00:27:14.620
The reason why Awake from Fetch
and Awake from Insertion is up

00:27:14.790 --> 00:27:17.910
here is that those two methods,
essentially if you look at the

00:27:18.090 --> 00:27:21.720
process of creating a fault,
a constructor is called.

00:27:21.720 --> 00:27:25.480
If you put your initialization
logic in that constructor,

00:27:25.480 --> 00:27:28.720
well,
when that object is finally initialized,

00:27:28.720 --> 00:27:32.600
it's going to pull information up from
perhaps a snapshot or the database,

00:27:32.600 --> 00:27:35.720
and all the work you've
done might get overridden.

00:27:36.680 --> 00:27:40.890
The appropriate place to put
initialization information is by

00:27:40.890 --> 00:27:44.890
subclassing generic record and
then putting it in Awake from

00:27:45.030 --> 00:27:47.410
Fetch or Awake from Insertion.

00:27:50.420 --> 00:27:54.660
Some other notes, some good tips,
a blob of data.

00:27:54.660 --> 00:27:57.800
You may want to factor that
out into its own table.

00:27:57.860 --> 00:28:02.050
I think the canonical example is an
employee and their employee photo.

00:28:02.110 --> 00:28:05.700
If you have some little app and you're
always just searching for first names

00:28:05.700 --> 00:28:08.880
and email addresses and phone numbers,
you don't want to have to

00:28:08.950 --> 00:28:12.080
bring their whole image in
because it's part of that row.

00:28:12.080 --> 00:28:17.010
A better thing to do is to have a
2-1 relationship to another table

00:28:17.010 --> 00:28:20.280
that stores the blob of data so that
you only have to bring in the image.

00:28:20.300 --> 00:28:23.700
You only have to access it over
a relationship when you need it.

00:28:23.700 --> 00:28:29.130
Some blobs might be better just to
store them in the file system and store

00:28:29.180 --> 00:28:31.940
a path to the blob in your database.

00:28:31.940 --> 00:28:34.190
Some other optimizations.

00:28:34.190 --> 00:28:38.170
Sometimes you never use a
too-many class property,

00:28:38.170 --> 00:28:42.780
so maybe you know that the
employee belongs to a department,

00:28:42.780 --> 00:28:47.030
but in your particular app,
your department never needs

00:28:47.180 --> 00:28:49.580
a list of all the employees.

00:28:49.580 --> 00:28:53.780
By turning off that reverse too-many,
it can save that fault from being

00:28:53.780 --> 00:28:55.940
created and save you some memory.

00:28:55.940 --> 00:29:00.330
Also, some rarely used attributes,
like you might have that employee where

00:29:00.330 --> 00:29:04.830
you're always looking up first name,
last name, email, but then they have all

00:29:04.910 --> 00:29:08.120
this other chunk of data,
like their social security number

00:29:08.270 --> 00:29:10.180
and all kinds of crazy stuff.

00:29:10.240 --> 00:29:13.930
You might have just the employee
and then a join to a table that

00:29:13.930 --> 00:29:17.960
has a lot more in the other table,
but that's used more rarely.

00:29:18.860 --> 00:29:23.180
Another thing is you can actually
hard code a fetch that will do

00:29:23.180 --> 00:29:27.840
the too-many relationship for you
so that it's not doing a join,

00:29:27.840 --> 00:29:33.320
you're just using a fetch to
grab the objects that you need.

00:29:33.320 --> 00:29:36.890
If you're using key-value coding,
the name of that method,

00:29:36.890 --> 00:29:39.790
you can bind that up as
if it's a relationship.

00:29:39.800 --> 00:29:43.280
Key-value coding won't know
how that array was provided,

00:29:43.300 --> 00:29:48.350
it just knows there's a method name that
it finds and calls to return that array.

00:29:50.910 --> 00:29:53.460
The shared editing context.

00:29:53.510 --> 00:29:56.400
So the purpose of the
shared editing context is,

00:29:56.400 --> 00:29:59.220
if we go back to that picture
of the stack in our head,

00:29:59.320 --> 00:30:03.960
is that I mentioned that multiple
editing contexts can all deal with

00:30:03.960 --> 00:30:07.760
the same exact row as a separate
EO in each editing context.

00:30:08.600 --> 00:30:11.860
So there's memory used
for each EO in each row,

00:30:11.860 --> 00:30:14.720
excuse me, in each editing context.

00:30:14.720 --> 00:30:19.450
A shared editing context allows you
to fetch things into this shared

00:30:19.450 --> 00:30:25.700
editing context that conceptually those
EOs are part of every other editing

00:30:25.720 --> 00:30:28.890
context sitting on that EOF stack.

00:30:28.960 --> 00:30:32.300
And so the memory is shared
not only for the snapshots,

00:30:32.430 --> 00:30:33.750
but also for the EO.

00:30:33.760 --> 00:30:38.160
There are some caveats to using this.

00:30:38.600 --> 00:30:41.880
The first is that with that
shared editing context,

00:30:41.890 --> 00:30:46.690
you cannot have any relationships
that go out of the EOs in that.

00:30:46.760 --> 00:30:49.930
You can have things that point in,
but nothing going out.

00:30:50.040 --> 00:30:51.820
Otherwise, you will hit trouble.

00:30:51.820 --> 00:30:53.460
Let's see.

00:30:53.460 --> 00:30:57.680
And you can't use it across stacks,
right?

00:30:57.700 --> 00:31:02.510
It's sharing the same snapshot,
and it's only dealing with items

00:31:02.510 --> 00:31:05.960
that are on the same EOF stack,
which means the same

00:31:05.960 --> 00:31:07.540
object store coordinator.

00:31:10.880 --> 00:31:15.290
Now what if you got tons and tons
and tons and tons and tons and tons

00:31:15.490 --> 00:31:21.160
and tons and tons and tons of EOs?

00:31:21.440 --> 00:31:24.700
Well, we've got a million EOs batching,
right?

00:31:24.700 --> 00:31:26.180
You want to batch things up.

00:31:26.320 --> 00:31:27.700
There are a few things that you can do.

00:31:27.700 --> 00:31:32.180
One is you could use raw rows
because when you're using raw rows,

00:31:32.180 --> 00:31:33.400
it's quicker.

00:31:33.400 --> 00:31:35.960
You're not generating snapshots or EOs.

00:31:35.960 --> 00:31:38.550
You're just getting those
raw dictionaries back,

00:31:38.600 --> 00:31:40.220
which you can use to display.

00:31:40.220 --> 00:31:42.920
Actually,
they're probably much more handy for

00:31:42.920 --> 00:31:45.440
display purposes than for edit purposes.

00:31:46.360 --> 00:31:51.410
Project Wonder also has
some nice reusable stuff,

00:31:51.540 --> 00:31:55.060
such as a fetch
specification batch iterator,

00:31:55.060 --> 00:31:57.200
which will let you fetch
things in by batch,

00:31:57.200 --> 00:32:02.060
and also a way to get an object
count with a particular qualifier.

00:32:02.060 --> 00:32:05.770
It's easy for you to build
that user interface that says,

00:32:05.770 --> 00:32:09.610
now showing 1 through 10 of 7.2 million.

00:32:09.610 --> 00:32:13.460
Has anybody here ever...

00:32:14.780 --> 00:32:19.880
gone through 1 through 10 all the
way up to a million on a website.

00:32:20.470 --> 00:32:22.680
You have?

00:32:22.720 --> 00:32:24.490
That's a lot of time
you have on your hands.

00:32:25.290 --> 00:32:31.070
Because most users won't go through
a million records on a website,

00:32:31.260 --> 00:32:35.880
so often you want to give the
impression that you grabbed them all,

00:32:35.880 --> 00:32:37.100
but not do so.

00:32:38.790 --> 00:32:43.190
And then sort of the lowest level you
can possibly get is you can actually

00:32:43.340 --> 00:32:50.700
go down to the very JDBC adapter,
the JDBC channel, and override fetchRow,

00:32:50.700 --> 00:32:54.820
which is the kind of atomic
method that's fetching in every

00:32:54.820 --> 00:32:56.600
single row from the result set.

00:32:56.600 --> 00:32:59.900
You can override that method,
call the super so the

00:32:59.900 --> 00:33:03.820
fetching happens for you,
and then you do something with the

00:33:03.820 --> 00:33:06.420
data and return null for the method.

00:33:06.760 --> 00:33:09.320
So EOF thinks nothing
came back for that row,

00:33:09.320 --> 00:33:11.880
yet you've already
grabbed the information,

00:33:11.880 --> 00:33:14.920
done something like aggregated
it or something of that nature,

00:33:14.920 --> 00:33:18.170
and you get back all these results,
and the rest of EOF thinks

00:33:18.260 --> 00:33:19.590
you got nothing back.

00:33:19.600 --> 00:33:22.640
It's kind of tricky,
but it definitely works.

00:33:25.010 --> 00:33:27.620
Okay,
that's some memory management stuff.

00:33:27.670 --> 00:33:29.830
Now let's talk about data freshness.

00:33:29.840 --> 00:33:33.090
So data freshness,

00:33:33.290 --> 00:33:35.320
EOF is a big, big cache.

00:33:35.320 --> 00:33:39.390
So those snapshots are caching.

00:33:39.390 --> 00:33:44.000
And any time you have caching,
no matter the environment,

00:33:44.250 --> 00:33:46.950
you have a data freshness

00:33:48.150 --> 00:33:56.630
So, there are a lot of techniques and
features within EOF that deal with data

00:33:56.760 --> 00:34:00.250
freshness and keeping your data fresh.

00:34:01.040 --> 00:34:06.890
What I'm going to do now is rather
than go through them in slides,

00:34:07.010 --> 00:34:07.880
let's go to a demo.

00:34:07.880 --> 00:34:09.220
Let's go to the demo machine.

00:34:09.280 --> 00:34:14.340
Let's get rid of this demo.

00:34:14.490 --> 00:34:15.800
Boom.

00:34:20.400 --> 00:34:27.170
So one thing I've found is that although
I have been through what refaulting is,

00:34:27.210 --> 00:34:32.920
refreshing is, invalidating,
all of these various

00:34:32.920 --> 00:34:35.400
things that deal with EOs,

00:34:35.660 --> 00:34:38.500
That over time as I'm
developing with EOF,

00:34:38.500 --> 00:34:41.370
their definitions get a
little fuzzy in my head,

00:34:41.480 --> 00:34:44.590
especially when I have an app
that's running and working,

00:34:44.670 --> 00:34:46.500
and then I have to rethink
through everything.

00:34:46.500 --> 00:34:49.720
Okay, now,
this one's getting rid of the snapshot.

00:34:49.800 --> 00:34:50.500
What's this doing?

00:34:50.500 --> 00:34:54.000
What I did was I wrote a little app
that I call the Freshness Explorer.

00:34:54.000 --> 00:34:58.440
It's a WebObjects app that
I think helps to illustrate,

00:34:58.760 --> 00:35:03.720
much more than slides can,
what's going on with the EOF stack.

00:35:07.000 --> 00:35:08.720
Great for this to pop on up.

00:35:08.720 --> 00:35:23.590
Can't find server.

00:35:24.240 --> 00:35:24.590
Let's see if we do the
old -- what was it?

00:35:24.590 --> 00:35:24.590
Oh, okay.

00:35:24.590 --> 00:35:24.590
Let's hit it once again.

00:35:48.010 --> 00:35:48.900
Great.

00:35:48.940 --> 00:35:49.540
Okay.

00:35:49.540 --> 00:35:51.890
So this I call the Freshness Explorer.

00:35:51.990 --> 00:35:57.250
It's essentially what we're
seeing here are two EOF stacks,

00:35:57.330 --> 00:36:00.200
each one sitting on top of
an object store coordinator.

00:36:00.410 --> 00:36:03.760
Then within each stack
is an editing context,

00:36:03.760 --> 00:36:08.990
or two editing contexts,
both sitting on top of the same one,

00:36:08.990 --> 00:36:12.730
displaying some pertinent information
about the editing context that

00:36:12.730 --> 00:36:12.730
we'll chat about in a moment.

00:36:12.810 --> 00:36:15.660
The related snapshot, if there is any.

00:36:15.730 --> 00:36:20.260
Any SQL that that stack had sent to
the database in the last transaction.

00:36:20.390 --> 00:36:24.960
And then finally,
doing a raw row fetch to get the actual

00:36:25.310 --> 00:36:29.460
database row that we'll be talking about.

00:36:29.750 --> 00:36:34.930
Let's fetch into this editing context,
as well as this editing context.

00:36:35.140 --> 00:36:41.470
And so the first thing to talk
about is the idea of refaulting.

00:36:41.850 --> 00:36:43.400
So we have fetched these objects in.

00:36:43.400 --> 00:36:47.380
You'll notice that we have two EOs,
one in each editing context.

00:36:47.830 --> 00:36:52.260
Here's the underlying snapshot,
which is holding onto this information.

00:36:52.390 --> 00:36:55.690
And since we did a fetch,
there's a SQL transaction that occurred,

00:36:55.690 --> 00:36:58.260
and here's the database underneath.

00:36:58.520 --> 00:37:01.020
We can do some things to this EO.

00:37:01.360 --> 00:37:04.360
The first thing we'll do is
something called refaulting.

00:37:04.380 --> 00:37:08.160
And the behavior when you refault,
as you'll see, is...

00:37:08.770 --> 00:37:11.570
That item is turned into a fault.

00:37:11.660 --> 00:37:13.040
It's a fault.

00:37:13.070 --> 00:37:16.820
The snapshot hangs around,
and nothing else is affected

00:37:16.830 --> 00:37:19.100
in any other editing context.

00:37:19.210 --> 00:37:21.520
If we touch the fault,

00:37:22.100 --> 00:37:23.820
No SQL is generated.

00:37:24.080 --> 00:37:27.840
The fault notices that
there's a snapshot and says,

00:37:27.900 --> 00:37:33.430
"Okay, I'll use that information." Now,
if I have a pending edit with a fault,

00:37:33.560 --> 00:37:37.670
so instead of Bob Jones,
let's say we're going to Robert Jones,

00:37:38.280 --> 00:37:41.200
I'll submit but not save that change.

00:37:41.200 --> 00:37:45.620
So that change is hanging out in that
Enterprise Object in the editing context.

00:37:45.980 --> 00:37:48.310
Now if I refault,

00:37:49.400 --> 00:37:50.730
It's turned into a fault.

00:37:50.850 --> 00:37:51.810
I touch the fault.

00:37:51.980 --> 00:37:56.590
Notice that refaulting loses
all of my pending edits.

00:37:56.950 --> 00:38:00.640
So that is the behavior of refaulting.

00:38:00.640 --> 00:38:04.250
You get that behavior by telling
an editing context to refault

00:38:04.250 --> 00:38:07.800
an object and handing it the
object you wish to refault.

00:38:07.800 --> 00:38:12.770
A smarter version of refaulting
is called refreshing.

00:38:12.770 --> 00:38:16.630
So let's edit Robert once again.

00:38:19.350 --> 00:38:23.100
And by refreshing, actually,
let's do two things.

00:38:23.170 --> 00:38:24.110
Yeah, let's do that.

00:38:24.390 --> 00:38:26.810
Now if I hit refresh,

00:38:27.460 --> 00:38:32.000
A fault was created and then basically
refreshed from the snapshot with

00:38:32.000 --> 00:38:34.950
the changes applied on top of it.

00:38:35.610 --> 00:38:39.370
The granddaddy of all
data freshness things,

00:38:39.440 --> 00:38:43.590
the sledgehammer is invalidate.

00:38:43.860 --> 00:38:45.510
Okay.

00:38:45.510 --> 00:38:48.450
Somebody likes the sledgehammer analogy.

00:38:48.560 --> 00:38:52.870
So when you invalidate,
all sorts of things happen.

00:38:53.270 --> 00:38:55.120
This object is turned into a fault.

00:38:55.340 --> 00:38:57.380
The snapshot is discarded.

00:38:57.430 --> 00:39:01.180
All other editing contexts
that have that row within it

00:39:01.220 --> 00:39:05.900
also get turned into a fault,
and all pending edits are discarded.

00:39:06.000 --> 00:39:11.360
So it's a very,
very draconian way to refresh things.

00:39:11.390 --> 00:39:13.480
Let's fetch things back.

00:39:14.040 --> 00:39:17.800
Here's one that I wasn't expecting,
which is when I refault,

00:39:17.940 --> 00:39:21.500
the snapshot hangs around and
the thing turns into a fault.

00:39:21.580 --> 00:39:28.540
But notice if I refault with
one EO and one editing context,

00:39:28.570 --> 00:39:29.720
my snapshot disappears.

00:39:30.460 --> 00:39:33.740
This is due to something called
snapshot reference counting,

00:39:33.740 --> 00:39:35.540
which happens automatically.

00:39:35.540 --> 00:39:41.120
When no EO is referring to that snapshot,
it goes away.

00:39:41.120 --> 00:39:44.920
Now, I knew that in my head,
and I had always thought of that as

00:39:44.920 --> 00:39:47.180
a memory management sort of thing.

00:39:47.180 --> 00:39:48.250
Okay, we don't need it.

00:39:48.400 --> 00:39:49.700
We can get rid of that memory.

00:39:49.700 --> 00:39:53.570
But as I was building that,
that interaction was not apparent to

00:39:53.570 --> 00:39:55.870
me until I was playing with this app.

00:39:55.970 --> 00:40:00.210
So, that's kind of cool.

00:40:01.710 --> 00:40:05.060
So let's fetch some things in and
talk about a couple of other items.

00:40:05.180 --> 00:40:07.800
Let's go to this other stack.

00:40:08.930 --> 00:40:13.140
You'll notice that if
I make a change over here,

00:40:13.140 --> 00:40:15.930
like Robert Jones,

00:40:16.400 --> 00:40:28.360
Submit that.

00:40:28.360 --> 00:40:28.360
When I save the change,
I should have just submitted it.

00:40:28.360 --> 00:40:28.360
No SQL got sent.

00:40:28.360 --> 00:40:28.360
The database is the same.

00:40:28.360 --> 00:40:28.360
Let's save the change.

00:40:29.540 --> 00:40:32.170
You'll notice that what happens
when I save that change is

00:40:32.380 --> 00:40:35.370
the snapshot gets updated,
some SQL gets sent,

00:40:35.460 --> 00:40:39.760
so the database row is updated,
and in addition,

00:40:40.150 --> 00:40:42.860
The other EO is turned into a fault.

00:40:43.020 --> 00:40:47.220
As soon as it gets touched,
it has the latest values.

00:40:47.340 --> 00:40:50.840
So now we have a data
freshness conundrum.

00:40:50.900 --> 00:40:55.540
One stack has made a change,
and so Robert Jones is here,

00:40:55.640 --> 00:40:57.500
but we still have Bob Jones.

00:40:57.570 --> 00:41:01.460
And as long as I refault and touch
the fault and refault and touch the

00:41:01.460 --> 00:41:07.810
fault and refresh and touch the fault,
I'm not getting Robert Jones.

00:41:08.100 --> 00:41:10.460
So I'd fetch.

00:41:10.530 --> 00:41:14.590
Well, if I fetch,
I still don't have Robert Jones.

00:41:15.370 --> 00:41:20.650
When you fetch, EOF is, as I said before,
a big old cache.

00:41:20.940 --> 00:41:25.090
And it is an aggressive big old cache.

00:41:25.170 --> 00:41:27.540
So when you fetch,
the main reason it's hitting the

00:41:27.540 --> 00:41:31.730
database is not because it's concerned
about the stuff you already have.

00:41:31.900 --> 00:41:34.700
It's concerned because there
might be rows in there that

00:41:34.700 --> 00:41:37.900
meet the fetch criteria that
you haven't already grabbed.

00:41:38.190 --> 00:41:43.420
So anything you already have, by default,
if you have a snapshot, it'll say, "Okay,

00:41:43.420 --> 00:41:44.030
I got that.

00:41:44.130 --> 00:41:47.540
I don't have to look at it."
The key toggle there is on

00:41:47.540 --> 00:41:52.930
that fetch specification to
refresh the refetched objects.

00:41:53.290 --> 00:41:55.420
So check that off.

00:41:55.670 --> 00:41:57.610
And now we'll get Robert coming in.

00:41:57.740 --> 00:42:02.460
Since the snapshot has changed,
any other EOs in other editing

00:42:02.460 --> 00:42:04.600
contexts are turned into a fault.

00:42:04.780 --> 00:42:06.990
So we'll touch the fault.

00:42:07.380 --> 00:42:14.230
Often using a fetch with refreshing
refetched objects is the most

00:42:14.370 --> 00:42:18.170
direct and efficient way to refetch

00:42:18.340 --> 00:42:21.780
Fresh,
a large amount of items at the same time,

00:42:21.790 --> 00:42:26.390
especially if it's a well-known
group of data or set of data that

00:42:26.530 --> 00:42:29.010
you can fit into a qualifier.

00:42:30.200 --> 00:42:32.740
All right,
so everybody's now Robert Jones.

00:42:32.740 --> 00:42:35.150
Yes, yes.

00:42:35.520 --> 00:42:38.970
Now let's make the EOF stack number two.

00:42:39.250 --> 00:42:43.700
Let's say it's Robert Cray.

00:42:45.250 --> 00:42:47.000
Touch the fault there.

00:42:47.030 --> 00:42:50.760
And so now we have a data
freshness issue over here.

00:42:51.200 --> 00:42:59.800
[Transcript missing]

00:43:00.530 --> 00:43:03.320
can be a source of confusion sometimes.

00:43:03.400 --> 00:43:06.390
Has anybody found it to be a
source of confusion at times?

00:43:06.490 --> 00:43:08.460
Some nodding heads.

00:43:08.530 --> 00:43:10.770
What's going on with the
fetch timestamp is this.

00:43:10.920 --> 00:43:14.730
When you create an editing context,

00:43:15.020 --> 00:43:18.430
By default,
a timestamp is put on it that's an

00:43:18.430 --> 00:43:21.190
hour previous to when it was created.

00:43:21.300 --> 00:43:25.900
So we showed up here and started
running this at about 9:15.

00:43:25.900 --> 00:43:29.840
Excuse me, at about 11:15.

00:43:29.900 --> 00:43:36.470
And so the timestamp on all of these
editing contexts is at about 10:15,

00:43:36.470 --> 00:43:39.560
an hour before this thing was created.

00:43:39.900 --> 00:43:44.160
And that will never, ever, ever,
ever change on that editing context

00:43:44.600 --> 00:43:46.590
unless you change it yourself.

00:43:46.900 --> 00:43:52.640
What this means is that any time that
editing context looks at a snapshot,

00:43:53.040 --> 00:43:57.900
it's going to say, or 10:15,
if it's later than 10:15,

00:43:57.900 --> 00:43:59.900
it's fine with me.

00:43:59.900 --> 00:44:01.900
It's fresh enough.

00:44:01.900 --> 00:44:04.900
So you'll notice that here
we have a fetch timestamp.

00:44:04.900 --> 00:44:07.890
Every time a snapshot is created,
it gets a timestamp.

00:44:07.900 --> 00:44:09.900
In this case, 11:19:08.

00:44:09.900 --> 00:44:14.560
So no matter what we do,
without changing the

00:44:14.560 --> 00:44:19.900
editing context timestamp,
things that are fetched in by that

00:44:19.900 --> 00:44:24.900
editing context are going to have a
timestamp later than its timestamp.

00:44:24.900 --> 00:44:28.300
Which means that if I refault,

00:44:29.060 --> 00:44:32.500
Touch the fault, refault,
touch the fault.

00:44:32.520 --> 00:44:35.500
I keep using that snapshot.

00:44:35.500 --> 00:44:41.170
One mechanism for data freshness
is to update the fetch timestamp

00:44:41.170 --> 00:44:42.630
in the editing context.

00:44:42.770 --> 00:44:46.150
In this case, we'll update it to now.

00:44:47.490 --> 00:44:49.560
Now it's 11:24.

00:44:49.740 --> 00:44:54.730
Now 11:24 is later than 11:19.

00:44:54.770 --> 00:44:59.300
So now if I refault,
when I touch that fault,

00:45:00.730 --> 00:45:05.000
It's going to notice
11.24 is later than 11.19.

00:45:05.120 --> 00:45:08.710
It will hit the database,
pull back the freshest values,

00:45:08.790 --> 00:45:12.300
make a new snapshot, and there you go.

00:45:12.970 --> 00:45:17.190
Okay, is there any other items that
I wanted to chat about here?

00:45:17.190 --> 00:45:19.410
That's about it.

00:45:19.570 --> 00:45:21.850
Let's go back to slides.

00:45:27.250 --> 00:45:31.520
So I intend to have that available.

00:45:31.830 --> 00:45:34.900
I find it -- oh, cool.

00:45:38.240 --> 00:45:42.360
Just in building it and playing with it,
I know I learned some things.

00:45:42.400 --> 00:45:48.200
The other thing is that
I think that often we get,

00:45:48.240 --> 00:45:50.960
I'm refaulting or I'm
doing this one thing,

00:45:50.960 --> 00:45:54.500
and we think about it in isolation.

00:45:55.160 --> 00:45:58.940
What I like about playing with that,
because that's essentially what

00:45:58.940 --> 00:46:03.400
we're doing is playing with it,
is that you see interactions between

00:46:03.400 --> 00:46:07.590
these different techniques that you may
not have noticed or thought about before,

00:46:07.700 --> 00:46:10.280
but they're very obvious to you
when you see them graphically.

00:46:10.280 --> 00:46:15.010
I think I'll be using that a
lot now that I've built it.

00:46:15.140 --> 00:46:16.400
Great.

00:46:16.470 --> 00:46:17.620
Data freshness.

00:46:17.680 --> 00:46:20.050
Now, since... Oh, there's my slide.

00:46:22.650 --> 00:46:30.660
So since we don't have kind of a way for
that demo to get to everybody else who

00:46:30.790 --> 00:46:34.500
might not be seeing this session live,
we're going to have some

00:46:34.500 --> 00:46:35.550
slides so they'll see it.

00:46:35.670 --> 00:46:38.530
But I'm going to crank through these
because we've already talked about

00:46:38.600 --> 00:46:40.500
most of this stuff in the demo.

00:46:40.550 --> 00:46:43.930
So refaulting, again,
affects that one editing context.

00:46:44.060 --> 00:46:45.630
We saw that it turned into a fault.

00:46:45.700 --> 00:46:46.840
We touched the fault.

00:46:47.060 --> 00:46:50.000
It uses the snapshot
if it is fresh enough.

00:46:50.100 --> 00:46:53.100
It doesn't affect any
other editing contexts.

00:46:53.110 --> 00:46:56.860
And there's no database round
trip unless for some reason,

00:46:56.860 --> 00:47:01.700
for example,
that snapshot isn't fresh enough.

00:47:01.710 --> 00:47:05.240
We can't use that existing snapshot.

00:47:05.250 --> 00:47:07.780
Invalidating is that--

00:47:08.220 --> 00:47:11.070
Sledgehammer approach.

00:47:11.190 --> 00:47:15.160
All editing contexts
lose all pending edits.

00:47:15.190 --> 00:47:20.200
The snapshot's thrown out,
and then the database is hit.

00:47:20.250 --> 00:47:24.140
Now, invalidating is pretty heavy-handed.

00:47:24.140 --> 00:47:26.580
There are some things you can do.

00:47:26.580 --> 00:47:28.300
You can imagine we had one object.

00:47:28.460 --> 00:47:31.630
So, okay, I invalidate,
and then I touch the fault,

00:47:31.630 --> 00:47:34.260
and then I get one fetch to the database.

00:47:34.260 --> 00:47:37.700
But imagine, you know,
you're displaying that million records.

00:47:37.720 --> 00:47:40.410
Well, let's say a couple thousand
records that you have,

00:47:40.440 --> 00:47:42.700
and you say, invalidate all objects.

00:47:42.700 --> 00:47:45.700
Now, every time you touch
one of those objects,

00:47:45.700 --> 00:47:49.240
it's a separate transaction,
a separate fetch to the

00:47:49.240 --> 00:47:50.790
database by default.

00:47:50.790 --> 00:47:52.560
So, get that one.

00:47:52.560 --> 00:47:55.000
You have some repetition
you're displaying on a page,

00:47:55.000 --> 00:47:56.580
and it's like, hit the database.

00:47:56.580 --> 00:47:57.720
Oh, I need another one.

00:47:57.720 --> 00:47:58.680
Hit the database.

00:47:58.890 --> 00:47:59.950
Oh, I need another one.

00:47:59.950 --> 00:48:00.860
Hit the database.

00:48:00.890 --> 00:48:01.060
Oh.

00:48:01.160 --> 00:48:04.680
And it does that thousands of times,
which is obviously a performance hit.

00:48:04.760 --> 00:48:09.480
One thing that you can do to prevent
that is to set batch faulting,

00:48:09.480 --> 00:48:12.280
which is set in that very
important model file.

00:48:12.280 --> 00:48:16.070
And the idea behind batch faulting
is you set a batch number,

00:48:16.070 --> 00:48:19.780
and it's sort of like when you're at
home and somebody else is up at the

00:48:19.880 --> 00:48:22.280
refrigerator while you're watching TV.

00:48:22.280 --> 00:48:24.590
And you say, while you're up...

00:48:27.340 --> 00:48:29.150
Why don't you get me something too?

00:48:29.150 --> 00:48:32.770
So batch faulting essentially saying,
while you're going to the

00:48:32.780 --> 00:48:38.120
database to get one studio,
you might as well bring back 10 or 100

00:48:38.120 --> 00:48:43.720
or whatever number as you go through
this seems to make sense for your

00:48:43.720 --> 00:48:46.800
data set and the size of your data.

00:48:46.800 --> 00:48:49.400
That will definitely
increase the performance.

00:48:51.480 --> 00:48:55.730
Manually fetching to restore
snapshots using refreshes,

00:48:55.730 --> 00:49:00.490
refetched objects is potentially
even better because you're not

00:49:00.490 --> 00:49:02.870
relying on the infrastructure.

00:49:03.120 --> 00:49:06.780
You're specifically saying,
I want these particular objects

00:49:06.780 --> 00:49:10.070
that match this particular
criteria to get fetched at

00:49:10.140 --> 00:49:14.640
this particular moment in time,
returned to me and refreshed.

00:49:14.770 --> 00:49:17.540
So that's very precise control.

00:49:17.700 --> 00:49:21.200
And while you're doing that,
you can use prefetching.

00:49:21.200 --> 00:49:26.380
Which are key paths that you specify
along with the fetch that say,

00:49:26.380 --> 00:49:29.800
while you're down there
getting all these,

00:49:29.800 --> 00:49:34.300
in this case, movies,
bring back the related studio.

00:49:34.440 --> 00:49:38.480
And so you will get not only a
fresh version of all the movies,

00:49:38.480 --> 00:49:41.580
but a fresh version of
all the related studios,

00:49:41.670 --> 00:49:44.790
all within the same database transaction.

00:49:49.030 --> 00:49:50.660
Refresh Objects.

00:49:50.670 --> 00:49:52.100
We hit on that briefly.

00:49:52.100 --> 00:49:56.130
It's like Refault Object,
except it is not going to throw

00:49:56.130 --> 00:50:00.320
away pending updates or inserts,
and it will use that

00:50:00.320 --> 00:50:02.000
existing row snapshot.

00:50:02.000 --> 00:50:05.890
Playing with this,
the behavior is that if there are no

00:50:06.070 --> 00:50:11.330
changes to the object that you refresh,
it actually turns it into a fault.

00:50:12.020 --> 00:50:16.610
If there are pending changes
within the request-response loop,

00:50:16.720 --> 00:50:20.400
it seems to turn it into a fault,
unfault it, and apply the changes.

00:50:22.860 --> 00:50:24.100
Data freshness.

00:50:24.300 --> 00:50:28.980
This is one that, again,
I think is much easier to see the results

00:50:29.060 --> 00:50:31.740
of it than to explain the results of it.

00:50:31.960 --> 00:50:35.180
But again,
you make a new editing context,

00:50:35.370 --> 00:50:38.450
it gets a timestamp of an hour ago.

00:50:38.840 --> 00:50:44.760
So you show up at 10:00 AM, a user does,
it gets a 9:00 AM timestamp.

00:50:45.300 --> 00:50:48.380
It's an absolute time,
and unless you do something,

00:50:48.380 --> 00:50:50.460
that timestamp never changes.

00:50:50.460 --> 00:50:53.780
Anytime a snapshot is created,
it gets a timestamp.

00:50:53.780 --> 00:50:55.380
Those two are compared.

00:50:55.380 --> 00:50:59.530
If the snapshot is too old,
then that snapshot will not be

00:50:59.570 --> 00:51:04.910
used the next time that editing
context is trying to use it.

00:51:06.420 --> 00:51:09.180
What you might do,
and what I do in the source code,

00:51:09.180 --> 00:51:14.400
is I just tell that editing context to
set its timestamp to something else.

00:51:14.400 --> 00:51:17.200
You know, make a new NS timestamp.

00:51:17.370 --> 00:51:19.900
You can do that perhaps
when the session wakes up,

00:51:20.010 --> 00:51:22.760
so that every time that
user has a new transaction,

00:51:22.760 --> 00:51:24.460
you update the timestamp.

00:51:24.480 --> 00:51:27.850
And that then turns it into
more of a rolling window,

00:51:27.850 --> 00:51:32.600
so that every time a transaction occurs,
and then some faulting occurs,

00:51:32.600 --> 00:51:34.990
you can make sure that it updates.

00:51:36.300 --> 00:51:40.130
And then again,
the set refreshes refetched objects,

00:51:40.130 --> 00:51:41.850
and the prefetching.

00:51:44.100 --> 00:51:49.740
Now, if you want to go just crazy,
you can go to the EO database,

00:51:49.890 --> 00:51:51.800
which was on our model.

00:51:51.800 --> 00:51:55.600
It's the object that's actually
maintaining all of those snapshots,

00:51:55.600 --> 00:51:58.390
and you can mess with them directly.

00:51:59.010 --> 00:52:03.920
So an EO Global ID for you new folks,
it's simply an object that is a unique

00:52:03.920 --> 00:52:06.820
identifier for an enterprise object.

00:52:06.820 --> 00:52:10.560
And it's how you basically map up
what snapshots go with what EOs.

00:52:10.560 --> 00:52:13.680
For database folks,
it's basically the name of the entity

00:52:13.680 --> 00:52:15.240
and the primary key information.

00:52:15.240 --> 00:52:17.560
Shh, don't tell anybody I told you.

00:52:17.920 --> 00:52:19.330
Cheating at faulting.

00:52:19.330 --> 00:52:22.300
Essentially,
you can record your own snapshots.

00:52:22.300 --> 00:52:25.520
You get the global ID and you say,
here's the snapshot for

00:52:25.520 --> 00:52:27.300
that particular object.

00:52:27.300 --> 00:52:30.180
So if you happen to have
gotten it from some raw row

00:52:30.190 --> 00:52:33.520
fetching or some other means,
you can just provide it,

00:52:33.560 --> 00:52:36.460
potentially saving a
fetch to the database.

00:52:36.460 --> 00:52:39.220
Pre-flighting too many relationships.

00:52:39.320 --> 00:52:42.590
So sometimes you have a
new enterprise object and,

00:52:42.590 --> 00:52:47.480
you know, a department that's brand new
does not have any employees.

00:52:47.920 --> 00:52:53.700
Yet, EOF doesn't know that necessarily
there are no employees in the database.

00:52:53.700 --> 00:52:58.790
So if you go to touch that relationship,
it is going to automatically do

00:52:58.790 --> 00:53:01.160
a fetch to look for employees.

00:53:01.160 --> 00:53:04.670
You know that there aren't any
because you just made the department.

00:53:04.680 --> 00:53:09.170
So you can use this method,
record snapshot for source global ID,

00:53:09.170 --> 00:53:12.770
to hand it an empty array so
that it thinks that it has,

00:53:12.770 --> 00:53:17.900
well, it will have a snapshot that says
there's nothing related to it.

00:53:17.900 --> 00:53:21.670
Therefore,
it's not going to hit the database

00:53:22.040 --> 00:53:27.790
if you access the too many arrays
of that newly inserted object.

00:53:28.090 --> 00:53:31.720
And if you want to just blow away
the snapshot for a too many so

00:53:31.720 --> 00:53:36.320
that the next time it's accessed,
it is absolutely positively refreshed,

00:53:36.320 --> 00:53:41.660
you can use that same method and
hand in null instead of an array,

00:53:41.660 --> 00:53:44.140
which will get rid of
that too many snapshot.

00:53:44.140 --> 00:53:47.900
And so the next time that
object with that GID and that

00:53:47.900 --> 00:53:53.200
relationship name is accessed,
it'll say, I don't have a snapshot.

00:53:53.200 --> 00:53:56.340
Better go get fresh
information from the database.

00:53:57.040 --> 00:54:00.440
Again, this is very low level stuff.

00:54:00.710 --> 00:54:05.790
More likely you would want to use, say,
a fetch specification with

00:54:05.930 --> 00:54:10.560
prefetching necessarily before
having to revert to this.

00:54:10.600 --> 00:54:14.440
And then when you're doing this
stuff at the EO database level,

00:54:14.510 --> 00:54:16.320
we'll talk about
multi-threading in a moment,

00:54:16.370 --> 00:54:20.060
you want to lock and unlock
the object store coordinator.

00:54:20.120 --> 00:54:22.360
That multi-threading.

00:54:22.410 --> 00:54:26.530
I can't go through all of
concurrent programming right now.

00:54:26.740 --> 00:54:29.210
We have only six minutes left.

00:54:29.310 --> 00:54:31.250
So there are a lot of good books.

00:54:31.550 --> 00:54:34.430
As we talk,
I'm assuming that you have some knowledge

00:54:34.430 --> 00:54:39.440
of concurrent programming in Java and
concurrent programming in general.

00:54:39.500 --> 00:54:44.450
There's some good docs on this in the
What's New in WebObjects 5.2 docs.

00:54:44.700 --> 00:54:46.730
Java apps, always multi-threaded.

00:54:46.940 --> 00:54:49.300
Here are some examples
of multi-threading.

00:54:49.490 --> 00:54:54.090
Finalization, timers, session timeouts,
if you do your own threads,

00:54:54.090 --> 00:54:55.120
notifications.

00:54:55.480 --> 00:54:57.880
So you cannot,
it is impossible to write an

00:54:57.880 --> 00:54:57.880
EOF application in WebObjects.

00:54:57.880 --> 00:55:02.060
So you cannot write an EOF application
that is completely unmulti-threaded,

00:55:02.240 --> 00:55:04.240
which means we need to deal with it.

00:55:04.330 --> 00:55:05.480
Use try finally.

00:55:05.480 --> 00:55:08.630
So try to do something
like locking a resource.

00:55:08.780 --> 00:55:11.030
We'll tell you in a moment
what you need to lock.

00:55:11.120 --> 00:55:13.260
Then in the finally block, unlock it.

00:55:13.400 --> 00:55:18.120
So if any problems occur,
that finally block is always called and

00:55:18.120 --> 00:55:21.360
you don't deadlock your application.

00:55:21.600 --> 00:55:25.510
Essentially,
if an object in EOF or WebObjects

00:55:25.510 --> 00:55:30.440
Foundation does not have a lock on it,
you need to protect it.

00:55:30.810 --> 00:55:35.750
Either with a synchronized block or using
your own lock or some way of doing it.

00:55:35.830 --> 00:55:37.330
So that's arrays and dictionaries.

00:55:37.330 --> 00:55:41.040
You need to lock those or deal with
the concurrent issues yourself.

00:55:41.040 --> 00:55:45.530
For things like editing contexts,
the object store coordinator,

00:55:45.530 --> 00:55:46.960
you can lock those.

00:55:47.430 --> 00:55:48.940
It has the API to do so.

00:55:49.140 --> 00:55:54.350
You can also use try lock on an
NS recurring lock or an editing

00:55:54.360 --> 00:55:59.030
context so that you won't block as you
see is this thing able to lock for me

00:55:59.190 --> 00:56:01.680
or does somebody else have the lock.

00:56:01.780 --> 00:56:05.540
As you're debugging,
you can use control slash or kill

00:56:05.640 --> 00:56:10.870
quit with the PID to produce a stack
trace by thread as to what's going on.

00:56:11.040 --> 00:56:14.790
The commercial products optimize
it in JProbe are also very,

00:56:15.100 --> 00:56:15.920
very handy.

00:56:15.920 --> 00:56:21.600
As you're using an editing context,
if you're using a nested editing context,

00:56:21.600 --> 00:56:24.990
you need to lock the
nested editing context.

00:56:25.040 --> 00:56:27.610
Even though it is using
its parent's lock,

00:56:27.720 --> 00:56:32.660
you still do need to lock
that child editing context.

00:56:33.100 --> 00:56:35.720
The shared editing context locks itself.

00:56:35.820 --> 00:56:40.610
So it's the one exception
that proves the rule.

00:56:40.650 --> 00:56:42.070
That's the one that locks itself.

00:56:42.330 --> 00:56:44.000
Everything else you need to do yourself.

00:56:44.000 --> 00:56:48.940
You need to always lock the editing
context whenever you're using any of

00:56:48.940 --> 00:56:51.950
its Enterprise Objects in your own code.

00:56:52.040 --> 00:56:54.970
So even if you're doing
some read-only stuff,

00:56:55.230 --> 00:56:59.000
you still need to lock the EO--excuse me,
lock the editing context,

00:56:59.000 --> 00:57:05.180
do whatever stuff you're doing in code,
and then unlock the editing context.

00:57:08.300 --> 00:57:12.080
If you're operating at a lower level
than your EOs in editing context,

00:57:12.180 --> 00:57:16.340
you'll want to lock the object
store coordinator instead,

00:57:16.450 --> 00:57:19.780
as we talked about
with EO database stuff.

00:57:20.010 --> 00:57:23.540
So that is showing us that that
object store coordinator is,

00:57:23.670 --> 00:57:24.950
in essence, that root object.

00:57:25.070 --> 00:57:29.150
It is the thing that,
around which all this locking is based,

00:57:29.150 --> 00:57:31.390
is that object store coordinator.

00:57:32.920 --> 00:57:38.090
So remaining things to be careful
of as you're bopping around EOF,

00:57:38.090 --> 00:57:41.340
locking around the model,
notification center, and entity.

00:57:41.340 --> 00:57:44.270
In WebObjects,
they have a method that allows

00:57:44.280 --> 00:57:48.460
concurrent request handling,
which has nothing whatsoever

00:57:48.460 --> 00:57:50.380
to do with EOF multi-threading.

00:57:50.380 --> 00:57:54.400
It has to do with whether WebObjects
applications are handling incoming

00:57:54.660 --> 00:57:56.940
requests in a multi-threaded manner.

00:57:56.940 --> 00:58:00.590
That doesn't have anything to
do with whether you've turned

00:58:00.590 --> 00:58:02.410
on multi-threading in EOF.

00:58:02.800 --> 00:58:07.420
As we've just said, it's always to some
degree multi-threaded.

00:58:08.240 --> 00:58:10.410
So, some things to watch out for.

00:58:10.600 --> 00:58:15.650
Intersecting locks where you need to have
this lock and this lock to be able to

00:58:15.650 --> 00:58:18.100
do something and then release this lock.

00:58:18.230 --> 00:58:20.450
There's more possibility for deadlock.

00:58:20.780 --> 00:58:25.070
Keeping things as dead,
awful simple as possible to solve

00:58:25.280 --> 00:58:28.170
the problem is the best bet.

00:58:28.660 --> 00:58:32.850
When you synchronize some methods,
they're not just fancy keywords,

00:58:32.940 --> 00:58:35.300
there's an object lock going on there.

00:58:35.300 --> 00:58:38.470
And so when you're in a synchronized
block and then you lock something

00:58:38.470 --> 00:58:43.280
else or do a blocking operation,
nothing else is able to get into the

00:58:43.280 --> 00:58:48.750
synchronized block of that object,
any synchronized method of that object,

00:58:48.750 --> 00:58:51.100
until that code is released.

00:58:51.100 --> 00:58:55.380
So, try to keep your blocking code locked
by out of the synchronized blocks,

00:58:55.380 --> 00:58:58.630
but possibly using wait and
notify or recursive locks.

00:58:58.660 --> 00:59:05.120
Concurrent database access.

00:59:05.120 --> 00:59:05.120
So, this is

00:59:05.500 --> 00:59:07.520
pretty fun.

00:59:07.520 --> 00:59:10.360
Concurrent database access,
the general idea is you

00:59:10.360 --> 00:59:11.960
have multiple EOF stacks.

00:59:11.960 --> 00:59:16.440
Each stack, again, with an object store
coordinator of its own,

00:59:16.450 --> 00:59:19.440
is able to have concurrent
access to the database.

00:59:19.870 --> 00:59:23.210
So you want two things
hitting the database,

00:59:23.210 --> 00:59:24.690
make two stacks.

00:59:24.960 --> 00:59:26.940
That's the takeaway, basically.

00:59:27.100 --> 00:59:29.610
Each of those stacks has
its own set of locks,

00:59:29.610 --> 00:59:31.920
database channels, snapshot cache.

00:59:33.150 --> 00:59:36.260
Since you do potentially
have the overhead of multiple

00:59:36.260 --> 00:59:40.150
snapshots for each of those,
this is especially handy if

00:59:40.160 --> 00:59:44.610
you're fetching raw rows,
because there's no overhead

00:59:44.660 --> 00:59:47.880
with snapshots or EOs or
notifications going on.

00:59:47.880 --> 00:59:50.860
You're just getting back an
array of dictionaries that

00:59:50.860 --> 00:59:53.720
you can do with what you will,
which can be very handy if

00:59:53.720 --> 00:59:56.630
potentially you're doing an
app where you're doing a lot of

00:59:56.630 --> 01:00:00.160
fetching in and displaying of stuff,
potentially with a little

01:00:00.160 --> 01:00:01.580
less editing going on.

01:00:03.140 --> 01:00:05.920
To make one is dirt simple.

01:00:05.920 --> 01:00:10.450
You make an object store
coordinator that takes no arguments.

01:00:10.530 --> 01:00:15.000
At that point, you've just made the
basis of a new EOF stack.

01:00:15.160 --> 01:00:19.310
Then make a new editing context and
hand in that object store coordinator

01:00:19.310 --> 01:00:22.460
as the argument to the constructor,
and then start using

01:00:22.460 --> 01:00:23.630
that editing context.

01:00:23.920 --> 01:00:27.140
All of the objects beneath
the scenes that are doing the

01:00:27.150 --> 01:00:31.150
SQL generation that I'd like are
created for you automatically the

01:00:31.150 --> 01:00:33.520
first time you touch the database.

01:00:33.520 --> 01:00:35.220
I mentioned raw rows already.

01:00:35.220 --> 01:00:37.930
And the actual concurrency,
it should be noted,

01:00:37.930 --> 01:00:40.880
depends on how you have
your database configured.

01:00:40.880 --> 01:00:43.620
Sometimes it's a configuration
issue with the database.

01:00:43.620 --> 01:00:47.650
Sometimes it's a money issue with the
database where you can only have so many

01:00:47.650 --> 01:00:49.920
connections because of your license.

01:00:49.920 --> 01:00:53.860
But oftentimes the reason why
you might not have a database is

01:00:53.860 --> 01:00:53.860
because you don't have a database.

01:00:53.860 --> 01:00:56.980
The reason why you might not be
seeing concurrency is that you

01:00:56.980 --> 01:01:00.190
haven't configured the database
right or you haven't paid the

01:01:00.190 --> 01:01:02.190
database company enough money.

01:01:03.950 --> 01:01:08.400
Okay, so we've reviewed some basics,
some memory management, data freshness,

01:01:08.540 --> 01:01:12.470
multi-threading,
and concurrent database access.

01:01:12.880 --> 01:01:19.390
For more info, there's documentation up
in the reference library.

01:01:20.230 --> 01:01:23.120
There's who to contact.

01:01:23.130 --> 01:01:26.200
Andreas, Bob, Catherine Wentz.

01:01:26.240 --> 01:01:29.670
And enterprise-level WebObjects
support and consulting.

01:01:30.240 --> 01:01:32.000
I don't see anybody jotting down,
so I'll go on.

01:01:32.290 --> 01:01:34.060
The reference library.

01:01:34.060 --> 01:01:38.090
And now let's have some folks up for Q&A.

01:01:38.090 --> 01:01:39.100
Thank you.
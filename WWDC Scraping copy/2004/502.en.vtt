WEBVTT

00:00:13.150 --> 00:00:14.100
Good morning.

00:00:14.100 --> 00:00:16.540
Thanks for coming, everybody.

00:00:16.610 --> 00:00:19.740
I am Eric Brown,
the Bluetooth Software Manager at Apple,

00:00:19.740 --> 00:00:24.290
and I'm here to talk to you a little bit
about developing Bluetooth applications.

00:00:25.810 --> 00:00:28.610
So let's go ahead and start off
talking about Bluetooth industry

00:00:28.640 --> 00:00:32.320
developments in the past year and kind
of look to the future a little bit.

00:00:32.370 --> 00:00:35.860
In the past year,
we've seen Bluetooth version 1.2

00:00:35.870 --> 00:00:38.140
introduced by the Bluetooth SIG.

00:00:38.140 --> 00:00:40.340
A couple of notes about 1.2.

00:00:40.350 --> 00:00:43.420
It is fully backwards compatible
with previous versions,

00:00:43.420 --> 00:00:48.770
so it should be fully interoperable with
all of the Bluetooth hardware out there.

00:00:49.140 --> 00:00:53.430
They've introduced a new function
called Adaptive Frequency Hopping,

00:00:53.430 --> 00:00:54.540
or AFH for short.

00:00:54.540 --> 00:00:57.780
You might have seen it in
some of the Apple literature.

00:00:57.830 --> 00:01:01.910
But what it does is it allows
Bluetooth to avoid interfering with other

00:01:01.910 --> 00:01:04.840
2.4 gigahertz wireless technologies.

00:01:04.870 --> 00:01:08.160
So the way that it works,
it actually pays attention to where it

00:01:08.160 --> 00:01:12.620
notices interference and then just avoids
communicating over those frequencies.

00:01:12.620 --> 00:01:17.000
So technologies like airports, your --

00:01:17.230 --> 00:01:23.620
and his team will be sharing
the latest updates on the latest

00:01:23.620 --> 00:01:23.620
features and features that

00:01:23.760 --> 00:01:28.690
Also in Bluetooth 1.2 is a new
Fast Connect capability which between

00:01:29.130 --> 00:01:33.650
two devices that are both 1.2 compliant,
it allows greatly reduced connection

00:01:33.650 --> 00:01:38.080
times to speed up communicating
between the two devices.

00:01:38.110 --> 00:01:43.430
We've also added a new enhanced
SCO capability which improves the voice

00:01:43.430 --> 00:01:46.540
quality when talking with headsets.

00:01:47.360 --> 00:01:50.710
In the past year,
we've introduced Bluetooth firmware

00:01:50.710 --> 00:01:56.250
update 1.1 that adds support
for the Bluetooth 1.2 spec,

00:01:56.250 --> 00:02:01.580
and we definitely encourage developers of
new hardware to adhere to the 1.2 spec.

00:02:01.720 --> 00:02:04.890
We're definitely focused
on that going forward.

00:02:13.900 --> 00:02:17.880
Now there's a number of new hardware
features coming in the next year.

00:02:17.880 --> 00:02:21.820
I can only talk about one of them,
but we think it's going

00:02:21.820 --> 00:02:23.580
to be a pretty big,
pretty important feature,

00:02:23.580 --> 00:02:26.520
and that's what the Bluetooth SIG is
calling Enhanced Data Rate.

00:02:26.550 --> 00:02:30.160
They announced it earlier this month,
and it actually improves

00:02:30.160 --> 00:02:34.300
transfer speed three times,
so upwards of 2.1 megabits per second

00:02:34.370 --> 00:02:36.460
over the Bluetooth wireless link.

00:02:37.290 --> 00:02:39.800
In addition,
the Enhanced Data Rate actually

00:02:39.800 --> 00:02:42.820
allows for lower power
consumption between devices,

00:02:42.820 --> 00:02:47.190
so that should improve battery life
of your battery-powered devices.

00:02:47.200 --> 00:02:50.310
Unfortunately,
because it is a new design and

00:02:50.400 --> 00:02:54.960
enhancement over the way that
Bluetooth communicates over the air,

00:02:54.960 --> 00:02:57.190
it will require new hardware.

00:02:57.200 --> 00:03:00.320
So hopefully later this year
we'll see this new Enhanced

00:03:00.760 --> 00:03:04.840
Data Rate ratified by the Bluetooth SIG,
and we'll definitely be looking

00:03:04.870 --> 00:03:07.020
to see exactly where that goes.

00:03:07.280 --> 00:03:08.290
Okay.

00:03:08.700 --> 00:03:11.200
Back in January,
the Bluetooth SIG announced

00:03:11.200 --> 00:03:18.000
that at that point,
other companies were selling more than

00:03:18.000 --> 00:03:19.830
1 million Bluetooth devices each week.

00:03:19.840 --> 00:03:23.030
Well, as it turns out...

00:03:23.660 --> 00:03:40.990
Thank you for joining us.

00:03:41.070 --> 00:03:41.070
I'm Eric Brown, CEO of Apple.

00:03:41.070 --> 00:03:41.070
I'm here to talk about the
latest technology that's

00:03:41.070 --> 00:03:41.070
been coming out in the world.

00:03:41.070 --> 00:03:41.070
It's a new technology that's
finally getting out to the masses.

00:03:43.450 --> 00:03:46.320
So now let's take a look at
over the past year we've added a

00:03:46.320 --> 00:03:49.920
number of new features to Panther.

00:03:50.100 --> 00:03:51.960
We've added support
for Bluetooth headsets,

00:03:52.010 --> 00:03:55.000
Bluetooth printing,
and as I just mentioned, the 1.2 spec.

00:03:55.040 --> 00:03:57.820
I'm going to talk a little bit in
detail about exactly what these

00:03:57.830 --> 00:03:59.790
features are and how they work.

00:04:01.330 --> 00:04:05.360
In February, we released a Bluetooth 1.5
software update,

00:04:05.400 --> 00:04:09.440
which was later rolled
into Mac OS X 10.3.3.

00:04:09.440 --> 00:04:15.000
The headset support is implemented
pretty straightforward.

00:04:15.000 --> 00:04:17.390
Set up a headset with a
Bluetooth setup assistant,

00:04:17.390 --> 00:04:20.890
and it shows up as any other
audio device on the system.

00:04:20.900 --> 00:04:26.110
Any application that does audio input or
audio output can take advantage of it.

00:04:28.100 --> 00:04:30.840
As part of the headset profile
and the Bluetooth spec,

00:04:30.840 --> 00:04:32.770
they define two different roles.

00:04:32.810 --> 00:04:34.980
There's the headset role
and the gateway role.

00:04:35.000 --> 00:04:38.000
Headset role obviously
applies to headset devices.

00:04:38.000 --> 00:04:42.960
Gateway applies to things
like your phone and the Mac.

00:04:43.000 --> 00:04:48.000
In our case, we've only implemented the
gateway portion of the profile.

00:04:48.000 --> 00:04:51.140
So what that means is with
the existing headset support,

00:04:51.140 --> 00:04:53.780
for example,
your phone can't communicate with the

00:04:53.890 --> 00:04:57.370
Mac because both are gateway devices.

00:04:58.180 --> 00:05:05.040
As well, the headset support is actually
integrated into a SCO audio driver.

00:05:05.040 --> 00:05:08.660
So it isn't really generic
SCO support per se,

00:05:08.820 --> 00:05:11.530
but rather all integrated together.

00:05:14.620 --> 00:05:18.540
At the same time that we introduced
the 1.5 Bluetooth update,

00:05:18.540 --> 00:05:24.570
there was an iChat beta release of 2.1
that supported the Bluetooth headsets.

00:05:25.070 --> 00:05:28.590
Additionally,
a couple things to note about the

00:05:28.590 --> 00:05:33.060
way that the SCO links work is
that currently hardware limitations

00:05:33.370 --> 00:05:35.620
restrict us to one SCO link at a time.

00:05:35.620 --> 00:05:41.120
So just as a little bit of background,
the SCO link is the type of connection

00:05:41.120 --> 00:05:46.510
used between the headset and your
Mac to communicate the audio data.

00:05:48.000 --> 00:05:51.110
However, again, since only one link is
supported at a time,

00:05:51.110 --> 00:05:55.130
that restricts our ability to support
things like multiple headsets at

00:05:55.130 --> 00:05:58.240
once or looking in the future,
maybe using your Mac,

00:05:58.340 --> 00:06:00.520
talking to your phone and
your headset at the same time.

00:06:02.220 --> 00:06:05.130
An additional limitation is
that speech recognition isn't

00:06:05.130 --> 00:06:07.110
supported for Bluetooth headsets.

00:06:07.230 --> 00:06:10.900
Unfortunately,
it requires 22 kilohertz 16-bit audio,

00:06:10.900 --> 00:06:14.880
whereas the Bluetooth SCO audio
support only provides for

00:06:14.950 --> 00:06:17.460
8 kilohertz 16-bit audio.

00:06:17.460 --> 00:06:20.010
Unfortunately,
it's just a limitation in the technology.

00:06:24.900 --> 00:06:27.600
In the same software update,
the Bluetooth 1.5 update,

00:06:27.600 --> 00:06:29.480
we added support for Bluetooth printing.

00:06:29.480 --> 00:06:33.860
Now,
this was done through what's called HCRP,

00:06:33.860 --> 00:06:35.680
or the Hard Cable Replacement Profile.

00:06:37.010 --> 00:06:40.690
Again, in addition to being able to
configure new printers with

00:06:40.690 --> 00:06:44.350
the Bluetooth Setup Assistant,
Bluetooth support is integrated

00:06:44.370 --> 00:06:47.740
into the print panel and
the printer setup utility.

00:06:49.680 --> 00:06:52.780
Now the way that the support was added,
it's just a straightforward

00:06:52.880 --> 00:06:55.800
CUPS backend that talks
Bluetooth to the Bluetooth hardware.

00:06:55.800 --> 00:06:59.300
We definitely recommend that
printer manufacturers that are

00:06:59.310 --> 00:07:03.620
looking to add Bluetooth support
to their printers do so using HCRP.

00:07:03.620 --> 00:07:07.390
It should just be plug-and-play with,
or rather unplug-and-play

00:07:07.390 --> 00:07:11.100
with the Bluetooth wireless
technology with our support.

00:07:12.180 --> 00:07:16.760
One thing to note is that in order to
guarantee that a particular printer

00:07:16.760 --> 00:07:20.440
works properly over Bluetooth,
the printer manufacturers must

00:07:20.440 --> 00:07:22.080
provide a Bluetooth-certified driver.

00:07:22.080 --> 00:07:26.600
So typically that just means testing
it and providing the driver with the

00:07:26.650 --> 00:07:31.700
necessary information embedded in it
saying that it is Bluetooth-certified,

00:07:31.700 --> 00:07:37.040
but that just avoids cases where
printers might appear to work but don't.

00:07:49.790 --> 00:07:53.700
Finally, as I mentioned,
over the past year we added

00:07:53.700 --> 00:07:58.150
support for the Bluetooth 1.2
specification in the hardware.

00:07:58.150 --> 00:08:01.790
There was a Bluetooth firmware
update version 1.1.

00:08:02.210 --> 00:08:07.000
That supports both Apple built-in modules
as well as the external D-Link modules.

00:08:07.020 --> 00:08:09.750
Now, one thing to be aware of,
there have been several different

00:08:09.910 --> 00:08:11.700
revisions of the D-Link modules.

00:08:11.700 --> 00:08:17.600
So it only supports the dbt120
with revision B2 or later.

00:08:17.720 --> 00:08:22.650
So you definitely want to make sure of
that before trying the firmware update.

00:08:22.710 --> 00:08:28.750
The new firmware adds support for
the 1.2 baseband specification.

00:08:31.540 --> 00:08:33.510
So now let's move on to Tiger.

00:08:33.620 --> 00:08:37.860
It's what you're all here to see about.

00:08:37.910 --> 00:08:41.080
We've added a number of new APIs and
developer applications that should

00:08:41.610 --> 00:08:44.480
hopefully be of interest to a lot of you.

00:08:45.060 --> 00:08:47.270
As far as APIs go,
we've added a new device

00:08:47.390 --> 00:08:52.000
inquiry API in the form of
IO Bluetooth Device Inquiry Object.

00:08:52.020 --> 00:08:55.150
We've added a new
OBEX Transfer Services Object to

00:08:55.150 --> 00:08:58.000
provide some generic
OBEX file transfer capabilities,

00:08:58.000 --> 00:09:03.540
as well as then a set of SCO audio
services to enable third parties to use

00:09:03.840 --> 00:09:07.970
the SCO capabilities that we've built in.

00:09:09.310 --> 00:09:13.240
That Bluetooth device inquiry
object performs two basic services.

00:09:13.320 --> 00:09:17.280
It will perform the inquiries
and notify you about devices that

00:09:17.280 --> 00:09:21.040
are in range and discoverable,
as well as part of the process,

00:09:21.040 --> 00:09:25.000
it will fetch the names of
the newly discovered devices.

00:09:25.410 --> 00:09:28.740
Now one big warning here,
and this is the primary reason

00:09:28.740 --> 00:09:33.220
why this is the first time we've
introduced a Bluetooth inquiry API,

00:09:33.220 --> 00:09:36.600
is that inquiries are
definitely expensive.

00:09:36.600 --> 00:09:40.240
They take bandwidth away from
other Bluetooth connections,

00:09:40.240 --> 00:09:45.700
and they have the potential to degrade
802.11 performance as well as interfere

00:09:45.700 --> 00:09:48.920
with other 2.4 GHz wireless technologies.

00:09:49.490 --> 00:09:53.010
So it's really not something that's
designed to run all of the time and

00:09:53.230 --> 00:09:57.140
just continuously look for other
devices because it will have a negative

00:09:57.140 --> 00:10:00.940
impact on other things going on.

00:10:01.200 --> 00:10:04.660
Now as a result of this,
we've actually implemented throttling

00:10:04.660 --> 00:10:08.520
support so that inquiries will be
throttled if they are tempted to be

00:10:08.520 --> 00:10:10.880
performed for too long a period of time.

00:10:11.060 --> 00:10:14.870
Now typically if you just need to
perform one or two to present the user

00:10:14.870 --> 00:10:19.860
with a list of devices in the area,
you won't be affected by the throttling.

00:10:19.920 --> 00:10:22.920
But if you do try to just perform
inquiry over and over again,

00:10:22.920 --> 00:10:25.800
over time,
the amount of time that you'll be able to

00:10:25.890 --> 00:10:28.740
perform an inquiry for will be decreased.

00:10:29.400 --> 00:10:34.000
Now the Bluetooth device inquiry object
is fully asynchronous as well with

00:10:34.000 --> 00:10:38.000
full C versions of the API available.

00:10:38.210 --> 00:10:42.550
There's a new header file that this
API is now available in the TigerSeed.

00:10:42.560 --> 00:10:46.260
There's a new header file,
bluetootdeviceinquiry.h,

00:10:46.260 --> 00:10:47.300
that has the full API.

00:10:49.050 --> 00:10:52.280
So basically what the device
inquiry gives you is more or less

00:10:52.280 --> 00:10:56.070
the full functionality of the
Bluetooth device selector minus the UI,

00:10:56.130 --> 00:10:56.880
of course.

00:10:56.880 --> 00:11:00.170
So you should be able to do everything
that the Bluetooth device selector

00:11:00.270 --> 00:11:01.980
does but embed it in your own code.

00:11:02.000 --> 00:11:06.770
Now, we still highly recommend if you
need to allow the user to select

00:11:06.770 --> 00:11:10.340
a device or to provide the user
with a list of devices in range

00:11:10.340 --> 00:11:13.690
that you actually use the built-in
Bluetooth device selector because

00:11:13.850 --> 00:11:17.560
it really provides a consistent user
experience across multiple applications.

00:11:30.310 --> 00:11:33.940
Let's take a quick
look at the API itself.

00:11:34.260 --> 00:11:37.100
It's a class method to
create a new inquiry object.

00:11:37.110 --> 00:11:39.970
Now, a delegate is required.

00:11:40.030 --> 00:11:45.100
Because the API is fully asynchronous,
the delegate is needed to provide

00:11:45.100 --> 00:11:51.930
the callbacks of when the different
phases of the inquiry are taking place.

00:11:52.210 --> 00:11:55.830
You can control the length of the
inquiry through set inquiry length.

00:11:55.910 --> 00:11:59.100
You can control whether the
inquiry process will update

00:11:59.170 --> 00:12:00.640
the device names or not.

00:12:00.650 --> 00:12:03.880
Now, if you're presenting them
the list to the users,

00:12:03.910 --> 00:12:07.780
you will very likely want the inquiry
object to fetch the names for you.

00:12:07.800 --> 00:12:11.080
There are some restrictions depending
on what hardware you're running on,

00:12:11.110 --> 00:12:15.600
on exactly when the names can be fetched
compared to when the inquiry can run.

00:12:15.610 --> 00:12:17.660
So we've actually embedded
all of that logic,

00:12:17.660 --> 00:12:20.450
knowing about what the
hardware capabilities are,

00:12:20.480 --> 00:12:21.600
into this object.

00:12:21.600 --> 00:12:26.780
So if you use the capability,
or if you use the name update facility,

00:12:26.790 --> 00:12:30.850
you'll automatically take advantage
of all that knowledge built in.

00:12:31.300 --> 00:12:34.300
Then you also have the expected
start and stop routines to

00:12:34.300 --> 00:12:36.000
start and stop the inquiry.

00:12:36.000 --> 00:12:38.830
Now the inquiry will stop on its
own when the length of time that

00:12:38.830 --> 00:12:42.200
it's supposed to be running has hit.

00:12:42.200 --> 00:12:45.920
Additionally, once you call start,
the inquiry might not

00:12:45.920 --> 00:12:47.650
actually start immediately.

00:12:47.780 --> 00:12:52.120
If the throttling code has been engaged,
it may take some amount of time before

00:12:52.120 --> 00:12:54.680
the inquiry will actually begin.

00:12:58.720 --> 00:13:01.170
Because there's a delegate
and the API is asynchronous,

00:13:01.170 --> 00:13:04.110
there are a number of delegate
methods that get called during

00:13:04.110 --> 00:13:05.860
various stages of the inquiry.

00:13:05.860 --> 00:13:08.160
So you get notified when
the inquiry is started.

00:13:08.160 --> 00:13:11.240
That way you can know the
amount of time between you call

00:13:11.620 --> 00:13:13.460
start and it actually starts.

00:13:13.460 --> 00:13:16.840
Now if it can start right away,
you might get the inquiry started

00:13:16.920 --> 00:13:18.420
routine called immediately.

00:13:20.170 --> 00:13:23.610
There's a notification when
a new device gets found,

00:13:23.690 --> 00:13:27.480
there's a notification when
the name update process begins,

00:13:27.480 --> 00:13:31.540
notification when each
name is actually fetched,

00:13:31.540 --> 00:13:33.660
and then a notification once
the inquiry is completed.

00:13:42.580 --> 00:13:46.530
So let's go ahead and take a
look at kind of a sample timeline

00:13:46.530 --> 00:13:50.690
and what's going to go on when
using the device inquiry object.

00:13:50.880 --> 00:13:52.660
So your application is
going to create a new one.

00:13:52.870 --> 00:13:54.800
It's going to go ahead and call
start to start the inquiry.

00:13:54.800 --> 00:13:58.240
Maybe immediately,
maybe sometime in the future,

00:13:58.240 --> 00:14:00.820
you'll get the device
inquiry started notification.

00:14:04.600 --> 00:14:07.700
At that point,
the discovery process is ongoing.

00:14:07.820 --> 00:14:11.540
So for each device found,
you get a result, device inquiry,

00:14:11.620 --> 00:14:14.860
device found,
that tells you the device address,

00:14:14.860 --> 00:14:18.560
the class of device so you know,
are you talking with a keyboard,

00:14:18.600 --> 00:14:20.180
are you talking with a phone, etc.

00:14:20.180 --> 00:14:22.410
But at that point,
you won't have the name unless

00:14:22.410 --> 00:14:25.200
the system has previously
fetched it and cached the name.

00:14:27.790 --> 00:14:30.170
Once the actual discovery
process completes,

00:14:30.170 --> 00:14:31.890
it will begin the name discovery.

00:14:32.100 --> 00:14:35.610
So at that point you
get update device names,

00:14:35.610 --> 00:14:40.800
tells you how many devices are
left to have their names fetched.

00:14:41.800 --> 00:14:44.060
And then during the
name discovery process,

00:14:44.060 --> 00:14:48.460
you go ahead and get notified each
time a device name has been fetched.

00:14:48.460 --> 00:14:51.510
So that way, one by one,
you'll know exactly what the

00:14:51.510 --> 00:14:54.090
names are for each device
that have been discovered.

00:14:54.280 --> 00:14:56.670
And then finally,
you get the inquiry complete

00:14:56.700 --> 00:14:58.050
when that's finished.

00:15:01.080 --> 00:15:05.860
Another new API we've added in Tiger is
a new OBEX file transfer services.

00:15:06.030 --> 00:15:09.420
That's the name of an
Objective-C object in,

00:15:09.850 --> 00:15:14.500
again, in Tiger, in the Tiger seed,
new header file for it.

00:15:14.590 --> 00:15:19.140
What it does is it provides a simplified
API on top of OBEX for kind of the

00:15:19.150 --> 00:15:21.300
generic object exchange functionality.

00:15:21.440 --> 00:15:25.290
Basically provides a raw implementation
of the object push profile

00:15:25.290 --> 00:15:28.580
and the file transfer profile.

00:15:28.850 --> 00:15:33.700
provides all the basic low-level file
manipulation primitives you'd expect:

00:15:33.700 --> 00:15:38.200
put and get, change directories,
folder listings,

00:15:38.200 --> 00:15:42.500
manipulate the remote file system by
adding and removing folders and files.

00:15:42.700 --> 00:15:47.220
As with the device inquiry object,
the file transfer services

00:15:47.220 --> 00:15:51.030
object is fully asynchronous
with C versions available.

00:15:51.300 --> 00:15:54.890
So basically with this new API,
outside of the UI,

00:15:54.890 --> 00:15:57.600
you get the full functionality
of the Bluetooth file exchange,

00:15:57.600 --> 00:16:01.690
including the object push
and file transfer services.

00:16:13.910 --> 00:16:16.360
So let's just take a
quick run through the API.

00:16:16.360 --> 00:16:17.980
I'm not going to spend a
whole lot of time on it.

00:16:18.050 --> 00:16:21.610
It's a little more detailed
than the device inquiry,

00:16:21.610 --> 00:16:24.470
but you have the basic
methods for creating a new

00:16:24.470 --> 00:16:25.760
object with an OBEX session.

00:16:25.760 --> 00:16:29.130
Again, as with the inquiry object,
it takes a delegate

00:16:29.130 --> 00:16:30.740
for all the callbacks.

00:16:30.740 --> 00:16:34.440
There's methods for accessing the
current stake and the current path,

00:16:34.570 --> 00:16:38.300
notifying whether the
connection is busy or not,

00:16:38.300 --> 00:16:39.120
whether it's connected.

00:16:40.990 --> 00:16:43.620
API for connecting/disconnecting,
depending on what type

00:16:43.620 --> 00:16:46.270
of service you're using,
connect to FTP or connect

00:16:46.370 --> 00:16:51.120
to object push services,
as well as then the disconnect operation.

00:16:51.220 --> 00:16:54.780
API for sending and receiving files.

00:16:56.210 --> 00:17:01.180
as well as then the remote manipulation,
adding, removing folders and files,

00:17:01.250 --> 00:17:04.500
changing directories,
as well as then the capability to abort

00:17:04.500 --> 00:17:10.340
an operation that's in progress and
retrieve the current folder listings.

00:17:12.370 --> 00:17:14.480
Delegate methods, again,
there's quite a number of them.

00:17:14.480 --> 00:17:18.400
There's basically a completion for
each action that can be performed.

00:17:18.400 --> 00:17:23.420
So, for example, when you tell the API to
connect to a service,

00:17:23.420 --> 00:17:25.720
it's going to go ahead and
call the connection complete

00:17:26.130 --> 00:17:27.030
method when it's done.

00:17:27.040 --> 00:17:29.880
Pretty much the same for all of these,
although there are a couple

00:17:29.970 --> 00:17:31.180
of things to note here.

00:17:31.180 --> 00:17:34.670
There are two APIs for
actually transferring files

00:17:34.670 --> 00:17:36.760
for sending and receiving.

00:17:36.760 --> 00:17:41.370
Each one of those contains a transfer
progress method as delegate method as

00:17:41.410 --> 00:17:43.800
well as a transfer complete method.

00:17:43.800 --> 00:17:48.080
Now, the progress includes a number
of useful bits of information.

00:17:48.080 --> 00:17:50.770
In addition to just the
amount of data that's been

00:17:50.770 --> 00:17:55.360
transferred and how much is left,
it includes the elapsed time as

00:17:55.360 --> 00:18:00.700
well as estimated time remaining and
instantaneous transfer rate calculations.

00:18:00.700 --> 00:18:03.840
So,
that should actually make it pretty easy

00:18:03.840 --> 00:18:08.420
to wire that information into your... UI.

00:18:11.590 --> 00:18:16.460
So let's just take a quick run through
a sample object push operation.

00:18:16.560 --> 00:18:19.820
You're going to create the new
OBEX File Transfer Services object,

00:18:19.820 --> 00:18:22.640
and then call, in this case,
connect to object push service.

00:18:22.820 --> 00:18:24.820
That's going to go ahead,
send a message to the

00:18:24.820 --> 00:18:26.300
remote device to connect up.

00:18:26.440 --> 00:18:29.280
Once that completes,
you get the connection complete message.

00:18:29.370 --> 00:18:32.610
If there was an error,
you'll be notified at that point.

00:18:34.640 --> 00:18:36.900
Once the connection is complete,
it's okay to perform

00:18:36.900 --> 00:18:37.940
any of the operations.

00:18:38.050 --> 00:18:40.770
In this case,
since we're only using Object Push,

00:18:41.060 --> 00:18:44.730
Send File is the only facility
that we have available to us.

00:18:44.900 --> 00:18:47.320
So we're going to go
ahead and call Send File.

00:18:47.360 --> 00:18:51.080
Then as the file transfers,
you'll continuously,

00:18:51.130 --> 00:18:54.340
at regular intervals,
get the Send File progress with the

00:18:54.390 --> 00:19:00.770
transfer progress so you can know exactly
how far the transfer is completed.

00:19:01.310 --> 00:19:03.560
Once that's finished,
you go ahead and get a send file

00:19:03.640 --> 00:19:05.610
complete with the error code as well.

00:19:05.660 --> 00:19:10.280
So if an error occurred during the time,
this is the notification that you'll get.

00:19:10.370 --> 00:19:13.000
Once the transfer is complete,
you actually have the option of

00:19:13.000 --> 00:19:17.020
you can perform another operation
or go ahead and disconnect.

00:19:17.020 --> 00:19:20.290
Once the disconnection is finished,
you'll get disconnection complete method.

00:19:30.970 --> 00:19:36.080
So now let's move on to the new Skull
Audio API that we've added in Tiger.

00:19:36.280 --> 00:19:39.020
Now, in Panther,
we really had limited SCO support.

00:19:39.200 --> 00:19:41.700
We did have built-in support
for Bluetooth headsets,

00:19:41.800 --> 00:19:46.120
but there was really no API to
customize the SCO behavior or to

00:19:46.120 --> 00:19:49.570
tap into the SCO functionality.

00:19:50.630 --> 00:19:54.040
Additionally, core audio was the only
means to access that data,

00:19:54.040 --> 00:19:59.560
so that was the only communication that
any external developer had with a Sko,

00:19:59.560 --> 00:20:03.070
with a headset or other Sko audio device.

00:20:04.520 --> 00:20:08.130
In Tiger now, we're adding this new
SCO Audio API that really provides

00:20:08.410 --> 00:20:10.270
full control over the SCO link.

00:20:10.280 --> 00:20:13.700
So you control exactly when
the SCO link is created.

00:20:13.700 --> 00:20:19.060
It provides an audio driver
and the ability to configure

00:20:19.060 --> 00:20:20.760
exactly how that driver appears.

00:20:20.760 --> 00:20:25.320
So you can say exactly how many
audio controls are created.

00:20:25.320 --> 00:20:27.180
Does it have a volume control?

00:20:27.180 --> 00:20:28.340
Does it have a mute control?

00:20:28.340 --> 00:20:30.270
What is the volume range, et cetera?

00:20:32.810 --> 00:20:35.600
The new API supports both
incoming and outgoing connections,

00:20:35.600 --> 00:20:39.490
so again, which you have control over,
so depending on exactly what

00:20:39.490 --> 00:20:43.200
type of device you're talking to,
what profile you're using,

00:20:43.200 --> 00:20:47.280
you can implement it exactly
the way that's intended.

00:20:49.500 --> 00:20:52.630
As part of the API,
a SCO Audio driver is created,

00:20:52.720 --> 00:20:57.740
but instead of having, as with Panther,
all of the support for communicating

00:20:57.740 --> 00:21:00.660
with headsets built in,
it just provides audio I.O.

00:21:00.660 --> 00:21:01.360
services.

00:21:04.000 --> 00:21:07.720
As far as the API goes,
we've actually split it here.

00:21:07.720 --> 00:21:11.540
You have the iBluetooth framework for
all the standard Bluetooth services.

00:21:11.540 --> 00:21:14.640
So, for example,
in the case of the headset profile,

00:21:14.640 --> 00:21:18.550
it needs to use an RFCOM channel
to communicate with the headset

00:21:18.560 --> 00:21:22.970
to indicate things like ring,
button press, volume changes, etc.

00:21:23.020 --> 00:21:26.420
So, again,
the Bluetooth framework is where

00:21:26.420 --> 00:21:29.620
you're going to communicate over any
of the standard Bluetooth services.

00:21:30.780 --> 00:21:35.590
Then Core Audio is the API to
be used both for audio I.O.

00:21:35.600 --> 00:21:40.220
as well as to communicate with the
driver in terms of being notified

00:21:40.220 --> 00:21:45.140
about applications on the system
wanting to create an audio connection

00:21:45.140 --> 00:21:49.080
and being able to control exactly when
those Go links get created and being

00:21:49.080 --> 00:21:50.900
informed of any audio-related errors.

00:21:59.420 --> 00:22:02.490
The API itself on the surface
appears pretty simple.

00:22:02.500 --> 00:22:06.360
There's just two functions,
although it does get a bit

00:22:06.660 --> 00:22:07.910
more complex than that.

00:22:07.980 --> 00:22:10.180
There's the basic two functions.

00:22:10.180 --> 00:22:11.760
I have Bluetooth Add SCO Audio Device.

00:22:11.790 --> 00:22:13.560
I have Bluetooth Remove SCO Audio Device.

00:22:13.560 --> 00:22:18.920
The Add function basically will create
a SCO Audio driver for your device.

00:22:20.530 --> 00:22:22.850
As part of the API,
a configuration dictionary

00:22:22.970 --> 00:22:26.570
parameter is provided,
and that's really what provides

00:22:26.630 --> 00:22:31.740
the core of the customizable
features in the audio API.

00:22:31.850 --> 00:22:36.120
So it's that configuration dictionary
that allows you to specify exactly

00:22:36.240 --> 00:22:40.000
what audio controls are created
and how they appear in the system,

00:22:40.000 --> 00:22:44.780
specify behavior on new connections,
among others.

00:22:45.080 --> 00:22:49.890
Now the caller of this API is
responsible basically to create

00:22:49.890 --> 00:22:51.510
any new Bluetooth services.

00:22:51.630 --> 00:22:55.110
So for example,
if the audio support you're

00:22:55.110 --> 00:22:58.740
adding allows the device to
connect back up to the host,

00:22:58.850 --> 00:23:02.660
you'll very likely need to add a
Bluetooth SDP service record that

00:23:02.730 --> 00:23:06.750
matches the service that you're providing
so the device knows exactly how to

00:23:06.750 --> 00:23:09.380
connect up and how to talk to you.

00:23:09.800 --> 00:23:14.960
Additionally, any non-SCO data, again,
like L2CAP, RFCOM, needs to be handled by

00:23:14.960 --> 00:23:16.580
the client in this case.

00:23:16.580 --> 00:23:18.090
The system will not do it for you.

00:23:20.650 --> 00:23:23.440
The iBluetooth
Remove SCO Audio Device API simply will

00:23:23.440 --> 00:23:25.000
remove that driver from the system.

00:23:25.000 --> 00:23:28.150
So the add functionality adds it,
remove removes it.

00:23:28.270 --> 00:23:30.700
It's basically up to the
client to do everything else.

00:23:40.160 --> 00:23:43.970
In addition to those new APIs,
we've created a couple of new

00:23:43.970 --> 00:23:46.960
applications that should help
you develop applications for

00:23:47.070 --> 00:23:48.920
Bluetooth applications for Mac OS X.

00:23:48.920 --> 00:23:53.340
We've added a new packet logger
tool and Bluetooth Explorer utility.

00:23:55.610 --> 00:23:58.850
PacketLogger is pretty much a
completely rebuilt version of the

00:23:58.850 --> 00:24:03.590
previous PacketCoder 2 application
with a lot of new functionality.

00:24:03.680 --> 00:24:04.800
It's actually really nice.

00:24:04.800 --> 00:24:07.090
It helps a lot when
developing applications.

00:24:07.220 --> 00:24:09.600
So it supports multiple
PacketLog windows.

00:24:09.600 --> 00:24:11.990
The previous application had only
a single window where you could

00:24:11.990 --> 00:24:16.100
either view the current log of
the system or one loaded in file,

00:24:16.150 --> 00:24:20.490
where the new one allows as
many open documents as you want.

00:24:20.680 --> 00:24:24.040
We've added improved decoding
and searching support so that

00:24:24.160 --> 00:24:27.590
what you see in the packet log
is a little bit more verbose.

00:24:27.590 --> 00:24:30.890
It provides a little more of the
information that you're likely to need.

00:24:31.010 --> 00:24:35.410
And then the searching capabilities
allows you to quickly type

00:24:35.410 --> 00:24:39.150
in a particular block of
data that you're looking for,

00:24:39.150 --> 00:24:41.520
whether textually or using hex.

00:24:41.730 --> 00:24:43.400
There's also a couple of new data views.

00:24:43.400 --> 00:24:47.100
In addition to the decoded view,
like you're used to seeing,

00:24:47.100 --> 00:24:50.640
there's a raw view that provides
just the basic raw data.

00:24:50.640 --> 00:24:52.360
If that's the way that
you want to look at it,

00:24:52.360 --> 00:24:55.510
if that's what you're used to seeing,
you can go ahead and see exactly

00:24:55.510 --> 00:24:58.460
what's being sent and received
over the Bluetooth link.

00:24:58.500 --> 00:25:01.600
And it also provides
a new flow data view,

00:25:01.630 --> 00:25:06.110
which kind of provides a summary
by connection of exactly what

00:25:06.360 --> 00:25:08.470
packets are on the system.

00:25:08.570 --> 00:25:17.560
So basically, all of the connection and
disconnection events are summarized,

00:25:17.560 --> 00:25:20.030
and so you can choose what
connection you're interested in,

00:25:20.030 --> 00:25:24.140
what L2CAP channel, what RFCOM channel,
and it will just then restrict

00:25:24.140 --> 00:25:28.010
the packets that it lists to those
associated with that channel.

00:25:29.780 --> 00:25:33.270
We've added support for data markers,
so if there are certain parts

00:25:33.270 --> 00:25:36.200
of the log that you want to
mark and come back to later,

00:25:36.200 --> 00:25:36.900
you can do that.

00:25:38.440 --> 00:25:41.000
We provided some additional
auto backup support.

00:25:41.050 --> 00:25:43.800
Previously in the Packet
Decoder 2 application,

00:25:43.800 --> 00:25:46.730
it would automatically,
assuming you choose to do so,

00:25:46.840 --> 00:25:50.080
it will automatically save the
current packet log to disk.

00:25:50.340 --> 00:25:53.330
But every time you started
and stopped the decoder,

00:25:53.330 --> 00:25:57.620
it would overwrite the previous log,
so it's real easy to accidentally

00:25:57.690 --> 00:25:59.370
lose an important log.

00:26:00.560 --> 00:26:03.950
So this new Packet Logger
application will actually

00:26:03.950 --> 00:26:07.760
support multiple backup files and
won't overwrite the previous one.

00:26:07.760 --> 00:26:10.200
Instead, it will create a new one.

00:26:10.520 --> 00:26:14.210
And then finally, this hopefully would be
helpful for a lot of people,

00:26:14.210 --> 00:26:17.240
is that there's no SDK required in
order to run the packet logger tool.

00:26:17.240 --> 00:26:19.830
Before,
you had to install an SDK with a custom

00:26:19.830 --> 00:26:23.960
build of the Bluetooth family text,
where now it's just built in.

00:26:23.960 --> 00:26:26.900
The logger tool itself will
just require authentication.

00:26:26.900 --> 00:26:29.690
Then once you've authenticated,
you can go ahead and capture

00:26:30.050 --> 00:26:31.620
Bluetooth data on any system.

00:26:41.530 --> 00:26:44.570
The other application we've added
is a new Bluetooth Explorer utility,

00:26:44.570 --> 00:26:47.890
which provides kind of a
snapshot of the Bluetooth stack

00:26:47.890 --> 00:26:50.100
and the Bluetooth hardware.

00:26:50.180 --> 00:26:53.760
provides active inquiry information,
so if there's an ongoing inquiry,

00:26:53.810 --> 00:26:56.820
it will show exactly what
devices are in the area and the

00:26:56.820 --> 00:26:58.870
relevant information about them.

00:26:58.960 --> 00:27:02.240
It provides detailed information
about the hardware on your system,

00:27:02.240 --> 00:27:05.040
including all of the
Bluetooth features that it supports,

00:27:05.040 --> 00:27:09.100
the device address,
specific versions of the

00:27:09.100 --> 00:27:13.180
various Bluetooth technologies
that it implements,

00:27:13.180 --> 00:27:14.290
etc.

00:27:14.520 --> 00:27:18.350
We've added new support for
the device cache being managed.

00:27:18.430 --> 00:27:21.920
So you can actually view the
current cache devices on the

00:27:22.500 --> 00:27:25.180
system as well as delete them.

00:27:26.300 --> 00:27:30.500
There's also a panel that allows you
to switch between multiple controllers.

00:27:30.600 --> 00:27:33.750
So if you have a built-in
Bluetooth module and say you have an

00:27:33.750 --> 00:27:37.700
external one that you want to test out
to make sure it works with your hardware,

00:27:37.700 --> 00:27:44.170
for example, you can simply insert that,
go to the Bluetooth controller setup,

00:27:44.400 --> 00:27:49.110
and switch to that module and the
system will just automatically

00:27:49.110 --> 00:27:49.110
switch over to using it.

00:27:49.310 --> 00:27:52.280
Then finally,
there's Connection Monitor functionality,

00:27:52.280 --> 00:27:56.440
which basically is the old
Bluetooth monitor application

00:27:56.440 --> 00:27:59.560
just integrated into the
new Bluetooth Explorer.

00:28:01.360 --> 00:28:03.930
So now I'd like to invite one of
the Bluetooth software engineers,

00:28:03.930 --> 00:28:07.380
Jason Giles,
up here to go ahead and demo some

00:28:07.380 --> 00:28:09.360
of the new applications for you.

00:28:12.770 --> 00:28:15.240
Thanks, Eric.

00:28:15.300 --> 00:28:19.460
So let's check out these applications
that Eric just talked about.

00:28:19.460 --> 00:28:21.450
Can I get demo one?

00:28:23.370 --> 00:28:24.960
Okay,
so the first one I'd like to show is

00:28:24.990 --> 00:28:28.250
the Bluetooth Explorer application.

00:28:28.390 --> 00:28:32.160
This application, as Eric mentioned,
is the reworked Bluetooth monitor,

00:28:32.170 --> 00:28:35.240
and we've added a whole bunch of
new features that we think will help

00:28:35.420 --> 00:28:37.160
make your developing lives easier.

00:28:37.300 --> 00:28:41.300
So, the first thing I'd like to show is
the local device information panel.

00:28:41.390 --> 00:28:43.540
And as you can see here,
you get a snapshot of the

00:28:43.540 --> 00:28:46.300
hardware that is currently in
use in the Bluetooth system.

00:28:46.300 --> 00:28:49.550
And as you can see,
it has the general hardware information,

00:28:49.550 --> 00:28:53.290
including the device address,
the manufacturer of the part,

00:28:53.290 --> 00:28:58.660
HCI and LMP version information,
as well as the Bluetooth specification

00:28:58.680 --> 00:29:02.300
hardware features,
such as three-slot packets, etc.

00:29:02.300 --> 00:29:05.130
So, as you can see,
the ones in black are the ones that are

00:29:05.310 --> 00:29:07.280
supported on this particular dongle.

00:29:07.320 --> 00:29:09.300
The ones in gray are not supported.

00:29:09.300 --> 00:29:11.960
If we had a different dongle,
we would probably see different

00:29:11.960 --> 00:29:13.300
attributes highlighted.

00:29:13.300 --> 00:29:15.290
We also have the version.

00:29:15.310 --> 00:29:18.300
We have the version
easily accessible for you.

00:29:18.300 --> 00:29:20.290
So,
if you're going to send us a bug report,

00:29:20.290 --> 00:29:22.300
we highly recommend that you
send us the stack version,

00:29:22.370 --> 00:29:27.300
because that really helps us determine
what exactly is going on in the system.

00:29:27.480 --> 00:29:31.300
This panel, or this tab,
is the Class of Device tab.

00:29:31.300 --> 00:29:35.160
This is a representation of how
other devices sees your computer.

00:29:35.340 --> 00:29:44.300
So, other devices can see what services
it has or what device class it shows.

00:29:44.300 --> 00:29:48.300
So, the system automatically determines
what major and minor device class

00:29:48.300 --> 00:29:51.300
and services are on your system.

00:29:51.300 --> 00:29:56.300
But if you had a need to spoof a
different kind of device on a computer,

00:29:56.300 --> 00:29:59.280
like let's say you wanted this
computer to be a cellular phone,

00:29:59.390 --> 00:30:04.300
you could just select phone and choose
what type of phone for the minor class.

00:30:04.300 --> 00:30:07.300
Now, if you set that class
of device on the system,

00:30:07.300 --> 00:30:09.420
all other devices, your phones,
other computers,

00:30:09.420 --> 00:30:11.210
would see this computer as a phone.

00:30:11.300 --> 00:30:13.300
So, that's an interesting
thing that might be useful.

00:30:13.300 --> 00:30:18.300
So, that's something that might be
useful to you if you had that need.

00:30:18.790 --> 00:30:22.020
Finally, there's a Services tab that
shows you the installed services

00:30:22.020 --> 00:30:23.300
on the Bluetooth system.

00:30:23.300 --> 00:30:27.110
So, on this system,
we have the Bluetooth PDA sync service

00:30:27.180 --> 00:30:30.300
as well as the OBEX object push service.

00:30:30.300 --> 00:30:33.200
If you're installing your
own service on the system,

00:30:33.200 --> 00:30:35.180
it would show up in this panel.

00:30:35.300 --> 00:30:38.300
If it does not show up here,
it's probably not installed correctly,

00:30:38.300 --> 00:30:42.300
and the system, the Bluetooth system is
not seeing that service,

00:30:42.300 --> 00:30:44.860
code and check for errors.

00:30:46.450 --> 00:30:50.600
So the next thing we've added
is the HCI controller selector.

00:30:50.630 --> 00:30:54.170
And this allows you to actually
have multiple Bluetooth hardware

00:30:54.200 --> 00:30:55.720
dongles installed on your machine.

00:30:55.720 --> 00:30:58.990
And you could use different ones if
you wanted to test your software out

00:30:59.090 --> 00:31:01.360
with different vendors' hardware.

00:31:01.380 --> 00:31:04.930
So on this particular system,
I have set up a Broadcom

00:31:05.050 --> 00:31:07.780
dongle as well as a CSR dongle.

00:31:07.790 --> 00:31:10.250
As you can see over here,
we're currently using

00:31:10.250 --> 00:31:12.080
the Broadcom dongle.

00:31:12.200 --> 00:31:15.500
If we switch to the CSR one
and make that active,

00:31:15.610 --> 00:31:20.980
this is an administration operation,
so it requests or asks for your password.

00:31:20.980 --> 00:31:22.810
Type that in.

00:31:22.890 --> 00:31:24.450
Go over to refresh.

00:31:24.550 --> 00:31:26.690
And as you can see now,
we're using the CSR part

00:31:26.900 --> 00:31:29.220
to do Bluetooth activity.

00:31:29.360 --> 00:31:30.820
This is not persistent.

00:31:30.820 --> 00:31:33.610
If you restart your machine,
it will reset itself to

00:31:33.620 --> 00:31:36.260
the default HCI controller,
and you will have to go back

00:31:36.270 --> 00:31:38.530
here to select a different one.

00:31:38.930 --> 00:31:42.290
So there's other things that
the Bluetooth Explorer offers.

00:31:42.300 --> 00:31:48.170
We invite you to check
it out on the tiger seed.

00:31:48.220 --> 00:31:50.630
So the next one I'd like to
show is the packet logger.

00:31:50.630 --> 00:31:53.880
And you'll notice on launch the first
thing it asks you is to authenticate.

00:31:53.920 --> 00:31:57.120
And that is because it doesn't
require the SDK anymore,

00:31:57.120 --> 00:32:01.550
but it does require administration
access to get to the data.

00:32:02.490 --> 00:32:06.400
So here we have a live
packet decoder window.

00:32:06.440 --> 00:32:08.970
And if we go over to
the preferences file,

00:32:08.970 --> 00:32:11.340
system preferences panel,
it generates some

00:32:11.340 --> 00:32:13.100
Bluetooth traffic there you see.

00:32:13.150 --> 00:32:15.230
And so here we have 13 packets.

00:32:15.270 --> 00:32:16.900
And there we go.

00:32:16.900 --> 00:32:22.490
No SDK build and we've
received Bluetooth packets.

00:32:25.830 --> 00:32:30.500
So the next thing I'd like to show
you is a file that I've recorded

00:32:30.500 --> 00:32:35.840
doing an FTP transfer from a
mobile phone to our computer.

00:32:37.450 --> 00:32:40.400
And as Eric pointed out,
there's three views to the

00:32:40.400 --> 00:32:41.770
packet logger window now.

00:32:41.780 --> 00:32:45.200
There's the Dakota view, the Flow view,
and the Raw view.

00:32:45.260 --> 00:32:50.550
So if we were interested in seeing,
let's say, this SDP packet here,

00:32:50.550 --> 00:32:52.630
as it relates to other
pieces of the system,

00:32:52.640 --> 00:32:58.720
we could go over to the Flow view and
see that here's the SDP information

00:32:58.720 --> 00:33:00.620
packets that have been sent and received.

00:33:00.790 --> 00:33:02.270
This is the one that I selected.

00:33:02.300 --> 00:33:07.520
And here it shows its
relation to the L2CAP layer.

00:33:07.520 --> 00:33:10.810
So these packets were generated
based on this connection response

00:33:10.820 --> 00:33:12.780
and this connection in L2CAP.

00:33:12.790 --> 00:33:15.320
And then we can keep going back
further and see that all of

00:33:15.320 --> 00:33:19.880
this L2CAP traffic was generated
based on this HCI connection.

00:33:20.030 --> 00:33:23.940
This is great when you have multiple
connections to different devices in the

00:33:23.940 --> 00:33:26.810
same packet or even the same device.

00:33:26.930 --> 00:33:28.980
For example, in this case,
we have on this device,

00:33:29.030 --> 00:33:33.070
we've requested SDP information,
but we've also

00:33:33.160 --> 00:33:36.470
and a different connection
done RF-COM traffic.

00:33:36.470 --> 00:33:38.340
And then you can even go
into this RF-COM connection,

00:33:38.340 --> 00:33:40.700
for example,
on channel 7 and note that these

00:33:40.700 --> 00:33:43.330
are all the packets that were
transferred over this channel.

00:33:46.010 --> 00:33:47.240
And then finally we have the raw view.

00:33:47.240 --> 00:33:50.900
So if I was interested in this
packet here and seeing what the

00:33:50.900 --> 00:33:54.370
raw bytes were sent over received
to and from the Bluetooth hardware,

00:33:54.540 --> 00:34:00.390
I can switch to the raw view and
see the actual bytes that were sent.

00:34:02.850 --> 00:34:06.780
So now I'd like to demonstrate the
markers capability that we've added.

00:34:06.870 --> 00:34:10.030
Clicking the M button
brings up the markers panel.

00:34:10.530 --> 00:34:14.830
And as you can see here,
I've already established

00:34:14.830 --> 00:34:16.580
two markers in this file.

00:34:16.710 --> 00:34:20.310
The first FTP folder listing,
we can go to that.

00:34:20.600 --> 00:35:01.300
[Transcript missing]

00:35:01.620 --> 00:35:06.490
And if we go back to our marker,
we can see that the packet that we were

00:35:06.490 --> 00:35:10.290
showing before is now decoded in OBEX.

00:35:10.320 --> 00:35:13.830
And if we twist that down,
we can see that we see the type

00:35:13.830 --> 00:35:16.600
header and the connection ID header.

00:35:18.340 --> 00:35:22.970
The next marker I have set is the
first get JPEG command that we

00:35:22.970 --> 00:35:27.160
send to actually receive a file,
to request a file from the

00:35:27.160 --> 00:35:28.900
FTP server that we've connected to.

00:35:28.900 --> 00:35:33.300
So if, for example,
you received a connection refused or

00:35:33.320 --> 00:35:37.130
request refused or bad request error,
you could actually

00:35:37.230 --> 00:35:40.080
twist this down and see,
okay, here's my request that

00:35:40.080 --> 00:35:41.460
I actually sent out.

00:35:41.480 --> 00:35:45.480
Here's the picture 3 file that we
requested and the connection ID.

00:35:45.880 --> 00:35:48.120
If something was wrong,
we could see that, oh, you know,

00:35:48.120 --> 00:35:50.340
we didn't send the name
properly or something like that.

00:35:50.360 --> 00:35:56.720
We can also see that the data is embedded
throughout the whole Bluetooth stack.

00:35:56.720 --> 00:35:59.980
So, for example, this is an OBEX packet.

00:35:59.980 --> 00:36:03.010
Now we can see that the
RFCOM packet is right here.

00:36:03.020 --> 00:36:05.780
And we can look at the
details of that RFCOM packet.

00:36:05.780 --> 00:36:09.170
And then from there,
we can go into the L2CAP.

00:36:09.950 --> 00:36:13.940
All the way down to the ACL layer.

00:36:13.990 --> 00:36:18.410
So you can see all of the data
top to bottom really quickly.

00:36:21.980 --> 00:36:25.900
Another thing that we've
added is a find panel.

00:36:26.030 --> 00:36:30.540
So if you're interested in a
particular command that you've sent,

00:36:30.540 --> 00:36:35.530
like let's say an OBEX command
disconnect because you suspect there's

00:36:35.530 --> 00:36:37.890
something wrong with the disconnect.

00:36:39.120 --> 00:36:41.440
This will bring up all the
packets that are related or

00:36:41.440 --> 00:36:44.240
that have the search keywords.

00:36:44.240 --> 00:36:47.440
You can do operator
keyword characters as well.

00:36:47.440 --> 00:36:49.840
If you put in an or character
or an and character,

00:36:49.840 --> 00:36:52.660
you can actually do and/or searches.

00:36:52.660 --> 00:36:55.470
So if we click on this,
we are quickly taken to

00:36:55.650 --> 00:36:57.510
the appropriate packet.

00:36:57.590 --> 00:37:01.320
If we wanted to add a marker
to that particular packet

00:37:01.320 --> 00:37:03.060
for someone else to see,

00:37:03.500 --> 00:37:05.560
This is a description field.

00:37:05.560 --> 00:37:07.200
We can put in a description.

00:37:07.200 --> 00:37:08.680
This is the...

00:37:12.290 --> 00:37:14.440
We're going to add that marker.

00:37:14.520 --> 00:37:17.770
And now once we save the
changes into our document,

00:37:17.770 --> 00:37:20.790
you can go quickly back,
refer quickly back to

00:37:20.790 --> 00:37:22.560
that spot at any time.

00:37:23.930 --> 00:37:28.040
Last thing I'd like to show
you is the Inspector Panel.

00:37:28.230 --> 00:37:30.930
This is a very simple way

00:37:31.820 --> 00:37:37.200
For you to look at the top-down
data structure as well.

00:37:37.200 --> 00:38:13.800
[Transcript missing]

00:38:21.860 --> 00:38:23.840
Let's go ahead and move
on to the next topic.

00:38:23.930 --> 00:38:28.060
I want to talk about
asynchronous application design.

00:38:28.140 --> 00:38:30.690
It's kind of a mouthful, and it--

00:38:31.200 --> 00:38:46.600
[Transcript missing]

00:38:47.290 --> 00:38:49.420
The asynchronous API basics.

00:38:49.420 --> 00:38:54.620
So all asynchronous
operations use callbacks.

00:38:54.620 --> 00:38:58.580
Typically, the callback will be made
when the operation completes.

00:38:58.580 --> 00:39:00.890
Seems pretty obvious,
but it isn't always,

00:39:00.890 --> 00:39:04.210
and the documentation isn't
always totally clear about that.

00:39:05.670 --> 00:39:08.520
Additionally,
the callback that gets made as a result

00:39:08.520 --> 00:39:13.700
of a particular operation may actually
be called after that operation returns.

00:39:13.700 --> 00:39:17.470
That's what actually causes a lot
of the trouble when developing an

00:39:17.540 --> 00:39:19.880
application using these type of APIs.

00:39:19.880 --> 00:39:23.130
A lot of times you want to
execute a number of operations

00:39:23.180 --> 00:39:27.390
synchronously that typically you
just go execute them one right after

00:39:27.400 --> 00:39:29.640
another on the same block of code.

00:39:29.690 --> 00:39:32.800
Unfortunately,
now that the first operation

00:39:32.800 --> 00:39:34.940
might not complete until after.

00:39:35.420 --> 00:39:39.770
The initial function returns,
you now have to go and move that second

00:39:39.770 --> 00:39:43.770
call into the callback for the first
and then maybe move the third call

00:39:43.770 --> 00:39:45.690
into the callback from the second.

00:39:46.440 --> 00:39:51.300
All of the Bluetooth operations
have asynchronous versions.

00:39:51.330 --> 00:39:54.270
Additionally, some of our APIs,
especially just a couple of

00:39:54.270 --> 00:39:57.280
new ones that we saw today,
the device inquiry and

00:39:57.280 --> 00:40:00.720
OBEX file transfer services,
are only asynchronous.

00:40:00.720 --> 00:40:05.910
So you're pretty much forced to actually
develop your application that way.

00:40:06.580 --> 00:40:09.600
An additional note here is that
the OWL Bluetooth framework

00:40:09.600 --> 00:40:12.870
is not thread safe,
so you can't just simply fire off

00:40:12.870 --> 00:40:16.080
another thread to go ahead and
perform the asynchronous operation,

00:40:16.080 --> 00:40:17.720
do 1, 2, 3, etc.

00:40:17.720 --> 00:40:23.330
because all of the Bluetooth calls
must be made from the same thread.

00:40:25.110 --> 00:40:29.220
So why do we even create
these asynchronous APIs and

00:40:29.220 --> 00:40:30.580
why should you use them?

00:40:30.600 --> 00:40:35.320
Well, primarily,
Bluetooth itself is asynchronous.

00:40:35.340 --> 00:40:36.810
We send a command,
then we have to wait for

00:40:36.890 --> 00:40:39.980
the device to respond,
both the local hardware

00:40:39.980 --> 00:40:41.520
and the remote device.

00:40:41.520 --> 00:40:44.230
So our implementation really
is based on that design.

00:40:44.230 --> 00:40:45.420
That's how it works.

00:40:47.030 --> 00:40:49.900
Additionally, and many times,
it can be less complex than

00:40:49.900 --> 00:40:51.270
using multiple threads.

00:40:51.300 --> 00:40:52.730
There's no locking to worry about.

00:40:52.740 --> 00:40:55.500
You don't have to deal with
multi-thread issues like that.

00:40:55.560 --> 00:40:59.180
And it's really similar to
the Cocoa Delegate model.

00:40:59.180 --> 00:41:01.610
So a lot of you that
have done Cocoa work,

00:41:01.610 --> 00:41:03.500
it should be very familiar.

00:41:11.710 --> 00:41:15.300
So there's definitely a number of
pros and cons associated with it.

00:41:15.300 --> 00:41:17.650
On the pro side,
the operations don't block.

00:41:17.930 --> 00:41:19.950
So your UI doesn't lock up.

00:41:20.000 --> 00:41:25.150
It provides for a much better user
experience when doing those things.

00:41:25.170 --> 00:41:27.400
The user doesn't click
a button and then wait,

00:41:27.400 --> 00:41:29.640
wait, wait,
watching the cursor spin as some

00:41:29.640 --> 00:41:31.840
long-running operation takes place.

00:41:33.140 --> 00:41:43.890
It also provides the developer with
the ability to implement UI that

00:41:43.890 --> 00:41:43.890
allows a user to cancel the operations.

00:41:43.890 --> 00:41:43.890
So it's a lot more
user-friendly in that way.

00:41:44.140 --> 00:41:48.840
Unfortunately,
while asynchronous design can

00:41:48.840 --> 00:41:52.500
make it simpler in that you don't
have the multiple thread issues,

00:41:52.550 --> 00:41:57.660
it also can be more complicated
because the sequential operations

00:41:57.700 --> 00:42:01.180
that you might want to do can't
be all implemented at once.

00:42:03.120 --> 00:42:07.000
So let's take a look at basically
some sample asynchronous behavior,

00:42:07.000 --> 00:42:10.610
kind of what goes on
within the Bluetooth stack.

00:42:11.320 --> 00:42:17.300
So what first happens is based on the
first call into the Bluetooth framework,

00:42:17.300 --> 00:42:20.640
the Bluetooth framework itself will
create a number of run-loop event sources

00:42:20.640 --> 00:42:24.340
to handle the asynchronous callbacks
from the various parts of the system,

00:42:24.420 --> 00:42:28.200
the kernel and the daemon,
the BlueD process.

00:42:28.290 --> 00:42:32.700
So go ahead, it'll create those
run-loop event sources.

00:42:34.530 --> 00:42:39.580
Now, one thing to note here is that
the run loop for the thread that

00:42:39.580 --> 00:42:44.370
first calls into the stack is the
run loop that will be used for

00:42:44.400 --> 00:42:46.560
all of the asynchronous callbacks.

00:42:46.580 --> 00:42:53.760
So that thread has to have a run loop run
on it after the Bluetooth calls are made.

00:42:53.790 --> 00:43:00.590
And from that point on is the
only thread that you can make

00:43:00.670 --> 00:43:03.490
calls into the Bluetooth stack.

00:43:05.100 --> 00:43:07.560
So none of the other threads
can actually make the calls.

00:43:07.560 --> 00:43:11.520
Now, you might try it and it might work,
but it's not guaranteed to work.

00:43:11.640 --> 00:43:13.100
There's no locking in there.

00:43:13.100 --> 00:43:18.060
It's very easy for multiple threads
to step on one another and have

00:43:18.060 --> 00:43:20.770
really unpredictable results.

00:43:21.180 --> 00:43:24.140
An additional note is that if
you're performing UI operations

00:43:24.140 --> 00:43:28.150
through the Bluetooth UI framework,
that only the main thread can be

00:43:28.360 --> 00:43:30.140
used to make the Bluetooth calls.

00:43:31.900 --> 00:43:35.690
Now that's because typically
all the UI operations have

00:43:35.740 --> 00:43:37.870
to occur on the main thread.

00:43:43.070 --> 00:43:47.980
So let's take a look a little more
detail about how a Bluetooth connection

00:43:47.980 --> 00:43:51.050
operation will work within this model.

00:43:51.700 --> 00:43:54.150
So the first thing that happens is
your application is just going to

00:43:54.260 --> 00:43:56.680
call Bluetooth device open connection.

00:43:56.780 --> 00:43:59.720
It's going to pass in
itself the callback.

00:43:59.890 --> 00:44:01.830
So that's going to go into
the Bluetooth framework.

00:44:01.890 --> 00:44:04.740
At that point,
the framework is going to turn around and

00:44:04.740 --> 00:44:08.860
make a call into the kernel to go ahead
and perform that connection operation.

00:44:08.860 --> 00:44:11.200
So it makes a call down into the kernel.

00:44:11.200 --> 00:44:15.040
Now we're still on the original thread,
although it's executing in the kernel.

00:44:15.040 --> 00:44:18.390
The kernel is going to go ahead
and take a look at the callback

00:44:18.390 --> 00:44:20.800
information provided by your client.

00:44:21.060 --> 00:44:24.480
It's going to go ahead and then
store that away so that when the

00:44:24.480 --> 00:44:28.150
operation actually completes,
it knows who made the call

00:44:28.300 --> 00:44:30.500
and who needs to get notified.

00:44:32.980 --> 00:44:35.890
At that point,
depending on the state of the system,

00:44:35.890 --> 00:44:39.990
the kernel may actually send the
HCI command to create the connection,

00:44:40.080 --> 00:44:42.560
or it might queue it up for later,
depending on if the

00:44:42.560 --> 00:44:44.290
hardware is busy or not.

00:44:45.030 --> 00:44:49.800
So in this case,
we'll go see it sends the command.

00:44:49.800 --> 00:44:53.180
And then at that point,
this particular operation is done.

00:44:53.180 --> 00:44:54.820
The client thread's going to return.

00:44:54.860 --> 00:44:58.070
Your run loop's going to be free to run,
process user events, et cetera.

00:44:58.070 --> 00:45:01.860
So the system is just now waiting
for this operation to complete.

00:45:01.860 --> 00:45:06.020
If you have a UI application,
the user is free to go ahead

00:45:06.120 --> 00:45:08.290
and perform other tasks.

00:45:09.680 --> 00:45:14.410
Once the operation is complete,
we'll actually see the command complete

00:45:14.410 --> 00:45:16.300
event coming in from the device.

00:45:16.300 --> 00:45:17.670
This gets run.

00:45:17.670 --> 00:45:21.330
The callback into the kernel
is done on a kernel thread.

00:45:21.340 --> 00:45:24.460
So I'll see the hardware notify the
kernel with the command complete event.

00:45:26.860 --> 00:45:30.470
At that point, the kernel says, "Okay,
let me try and find to see if

00:45:30.470 --> 00:45:35.330
there was an asynchronous call
that did the original connection."

00:45:35.500 --> 00:45:38.040
So it's going to go ahead,
look up the callback information.

00:45:38.060 --> 00:45:39.800
In this case,
it finds information about our

00:45:39.930 --> 00:45:43.400
client application so it knows
exactly which application made the

00:45:43.400 --> 00:45:45.870
call and which needs the callback.

00:45:46.470 --> 00:45:48.940
At that point,
the kernel will then just send a

00:45:48.940 --> 00:45:53.350
message to the framework in the
application using that RunLoop

00:45:53.350 --> 00:45:55.990
event source that was created.

00:45:56.920 --> 00:45:58.900
At this point, the kernel is done.

00:45:58.900 --> 00:46:02.040
The kernel thread is finished
and is off doing other things.

00:46:02.210 --> 00:46:04.970
The application thread now,
the RunLoop event source will go

00:46:04.970 --> 00:46:06.980
ahead and receive the kernel message.

00:46:06.980 --> 00:46:10.650
The framework will extract the
callback information and then

00:46:10.650 --> 00:46:13.810
just call the original caller,
notifying it that the

00:46:13.810 --> 00:46:15.500
command has completed.

00:46:20.060 --> 00:46:23.580
Now, that seems pretty simple,
but there are definitely a

00:46:23.580 --> 00:46:26.850
number of design considerations
that I need to keep in mind.

00:46:26.860 --> 00:46:31.520
So, for example, when you have multiple
operations to perform,

00:46:31.520 --> 00:46:33.490
your application really
is to keep track of.

00:46:33.620 --> 00:46:35.480
It may do multiple things at once.

00:46:35.480 --> 00:46:37.600
It needs to know exactly
what's outstanding,

00:46:37.600 --> 00:46:40.440
be able to deal with errors
that come up at any time.

00:46:40.440 --> 00:46:43.010
If there are future operations
that it needs to perform

00:46:43.090 --> 00:46:45.810
once certain events complete,
it needs to keep track of

00:46:45.810 --> 00:46:47.480
exactly what it needs to do next.

00:46:47.480 --> 00:46:49.980
So,
depending on exactly what you're doing,

00:46:50.060 --> 00:46:53.770
you may need to implement some
kind of queuing mechanism or state

00:46:53.770 --> 00:46:57.020
machine to keep track of what's going
on and what should be done next.

00:46:57.020 --> 00:46:59.170
That's really where the
complexity comes in.

00:47:01.740 --> 00:47:05.850
An additional point to note
is that your UI will be active

00:47:06.130 --> 00:47:08.140
while the operation is pending.

00:47:08.170 --> 00:47:12.130
So the user is free to go
ahead and perform any operation

00:47:12.140 --> 00:47:13.470
that's available to them.

00:47:13.640 --> 00:47:16.800
As a result, it's really recommended that
you disable any controls that

00:47:17.100 --> 00:47:20.840
shouldn't be accessed while this
particular operation is outstanding.

00:47:20.980 --> 00:47:25.680
We also really recommend that you provide
some kind of status and potentially

00:47:25.830 --> 00:47:30.750
a progress notification that a
particular operation is going on as well.

00:47:31.170 --> 00:47:34.450
and then as much as possible,
providing UI to be able to cancel an

00:47:34.450 --> 00:47:39.800
operation that may be long running really
is a lot more friendly to the end user.

00:47:41.650 --> 00:47:44.920
And then lastly,
really pay attention to the error codes.

00:47:44.970 --> 00:47:46.700
They are definitely there for a reason.

00:47:46.830 --> 00:47:49.600
All of the Bluetooth API returns
error codes.

00:47:49.650 --> 00:47:52.600
All of the callbacks include error codes.

00:47:52.600 --> 00:47:56.540
Typically, if an error is returned
from an API call itself,

00:47:56.540 --> 00:48:00.100
it means that the operation,
that the callback itself

00:48:00.100 --> 00:48:02.880
will not be called,
that the operation failed

00:48:02.900 --> 00:48:04.700
during the initial phase.

00:48:04.890 --> 00:48:07.820
If you get an error in the callback,
again, it usually means that that

00:48:07.890 --> 00:48:09.360
operation failed to complete.

00:48:09.450 --> 00:48:12.460
So if you had the next operation
that depended on the first

00:48:12.460 --> 00:48:16.310
one completing successfully,
you don't want to call that

00:48:16.310 --> 00:48:19.130
because it won't succeed either.

00:48:19.410 --> 00:48:21.180
Now,
there may be some exceptions to those.

00:48:21.180 --> 00:48:25.020
There are a couple of error codes
that actually indicate success,

00:48:25.130 --> 00:48:28.540
but the system may be in a state
other than what was expected.

00:48:28.540 --> 00:48:33.310
In those cases,
those codes will be documented.

00:48:36.300 --> 00:48:41.260
So now we've got a number of avenues
that you can go to for more information.

00:48:42.670 --> 00:48:46.330
Our IO Technology Evangelist
is Craig Keithley,

00:48:46.330 --> 00:48:50.540
and he is pretty much the main
contact for any developer relations

00:48:50.540 --> 00:48:54.740
issues as well as going through
just the standard developer support.

00:48:54.740 --> 00:48:59.760
We've also provided a Bluetooth developer
mailing list that you can get to.

00:48:59.760 --> 00:49:07.340
I believe any ADC member is free
to join the developer mail list.

00:49:07.340 --> 00:49:08.110
Is that right, Craig?

00:49:09.920 --> 00:49:11.820
Okay, well,
anybody can join the mailing list.

00:49:11.820 --> 00:49:16.460
And it's kind of the
traffic comes and goes,

00:49:16.460 --> 00:49:17.660
but feel free to join.

00:49:17.660 --> 00:49:19.680
Look at the traffic going on.

00:49:19.680 --> 00:49:21.400
See what kind of questions
people are asking.

00:49:21.400 --> 00:49:22.660
Feel free to ask your own.

00:49:22.660 --> 00:49:26.040
The Bluetooth engineers at Apple,
we do monitor that list regularly.

00:49:26.040 --> 00:49:28.710
We don't always have,
we can't guarantee that we're going to

00:49:28.710 --> 00:49:31.650
be able to respond to every question,
but we do try to pay attention

00:49:31.650 --> 00:49:33.040
and answer where we can.

00:49:37.280 --> 00:49:41.540
I've also got sample code and
documentation written as well.

00:49:41.590 --> 00:49:45.240
So there's working with
Bluetooth devices documentation,

00:49:45.300 --> 00:49:48.920
Bluetooth device access,
and Bluetooth user interface that are

00:49:48.920 --> 00:49:51.720
all in the installed Tiger documentation.
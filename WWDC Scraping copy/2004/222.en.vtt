WEBVTT

00:00:11.910 --> 00:00:13.680
Good morning, everybody.

00:00:13.730 --> 00:00:14.490
9:00 a.m.

00:00:14.570 --> 00:00:15.230
after the party.

00:00:15.520 --> 00:00:17.300
Not too bad.

00:00:17.840 --> 00:00:19.660
I'm sure we'll get some
stragglers coming in.

00:00:19.700 --> 00:00:22.160
Anyway, I want to make one program note.

00:00:22.170 --> 00:00:26.040
If you had to choose between this session
and the GL shading language session,

00:00:26.040 --> 00:00:29.860
which unfortunately is at the same time
because we had a last minute scramble,

00:00:29.860 --> 00:00:32.230
after both sessions,
after this session and

00:00:32.230 --> 00:00:35.070
the GL one upstairs,
everyone's going to be back in the

00:00:35.080 --> 00:00:39.010
graphics and media lab if you had
questions about that and had to pick.

00:00:39.200 --> 00:00:43.960
Anyway, I'm really excited about what
we have for you this morning.

00:00:43.960 --> 00:00:46.120
We're going to be talking
about Quartz Composer,

00:00:46.340 --> 00:00:49.720
which is a new tool on the developer DVD.

00:00:49.940 --> 00:00:54.390
Pretty exciting way to play around
with all the technology we'll have.

00:00:54.480 --> 00:01:00.660
So without further ado,
I'll bring up Pierre-Olivié Latour.

00:01:02.700 --> 00:01:03.600
Good morning everyone.

00:01:03.600 --> 00:01:08.290
Welcome to the Quartz
Composer WWDC session.

00:01:08.600 --> 00:01:10.880
So the first thing we are
going to look at is obviously,

00:01:10.880 --> 00:01:11.960
what is Quartz Composer?

00:01:11.980 --> 00:01:14.880
So it's a brand new tool
we're introducing in Tiger,

00:01:14.890 --> 00:01:19.100
a developer tool,
an exciting visual programming tool.

00:01:19.120 --> 00:01:21.770
And what you do with it is
you create compositions,

00:01:21.980 --> 00:01:25.320
which basically are little
programs that somehow process

00:01:25.350 --> 00:01:27.460
and render graphical data.

00:01:27.470 --> 00:01:31.340
Quartz Composer is able to actually
package a bunch of technologies

00:01:31.340 --> 00:01:32.760
into one single environment.

00:01:32.760 --> 00:01:37.470
And you have technologies like
OpenGL Quartz 2D or brand new

00:01:37.530 --> 00:01:42.610
technologies we're introducing in Tiger,
like Core Video or Core Image,

00:01:42.880 --> 00:01:46.940
everything in real time, from editing,
preview, to debugging.

00:01:46.960 --> 00:01:49.750
And the compositions you create
are really easy to integrate

00:01:49.750 --> 00:01:50.870
into your applications.

00:01:50.880 --> 00:01:55.090
We provide an IB palette,
and the system is completely

00:01:55.150 --> 00:01:57.900
compatible with the Cocoa bindings.

00:01:58.850 --> 00:02:03.760
The first thing I'm going to show you
are some simple examples of compositions.

00:02:03.800 --> 00:02:07.370
Can we see demo machine number two,
please?

00:02:15.740 --> 00:02:21.170
Thank you.

00:02:21.170 --> 00:02:24.780
So here we have simple
but typical compositions.

00:02:24.930 --> 00:02:28.130
It contains a mix of 2D and 3D elements.

00:02:28.240 --> 00:02:30.400
Like in that case,
we have a 3D cube that is

00:02:30.400 --> 00:02:32.130
rotating with some text on it.

00:02:32.280 --> 00:02:34.670
And in the background,
we have some simple text that

00:02:34.670 --> 00:02:37.720
is being blurred in real time
using some core image filters.

00:02:37.720 --> 00:02:44.170
Okay, I'm going to let you read to the
end of the text if you are able to.

00:02:45.920 --> 00:02:51.090
This composition is actually-- at
the foundation of it is a simple

00:02:51.130 --> 00:02:54.530
2D image that was-- to which
were applied a bunch of filters,

00:02:54.600 --> 00:02:59.100
and at the end you opted that completely
different result from the original image,

00:02:59.100 --> 00:03:00.970
which is animated with the time.

00:03:01.080 --> 00:03:04.540
And it's interesting to see that
the quality of what you generate

00:03:04.660 --> 00:03:08.010
with Squares Composer using the
underlying technologies we have--

00:03:08.010 --> 00:03:10.870
graphic technologies we have in
your printing system-- is very,

00:03:10.930 --> 00:03:12.300
very, very good.

00:03:12.450 --> 00:03:14.310
And it's running very fast.

00:03:14.420 --> 00:03:16.110
You might not see it,
but at the bottom left corner

00:03:16.110 --> 00:03:18.700
we got a frame rate counter,
and we're running at 60 frames

00:03:18.700 --> 00:03:22.090
per second right now because
we're syncing to the display.

00:03:22.420 --> 00:03:25.090
But it would actually run even faster.

00:03:27.520 --> 00:03:33.610
This composition is interesting because
we don't have any image as its source.

00:03:33.960 --> 00:03:38.390
It's basically generated from scratch
using Core Image filters that are

00:03:38.390 --> 00:03:40.580
assembled and animated with time.

00:03:40.620 --> 00:03:43.730
And once again, you can see that the
quality is very good,

00:03:43.760 --> 00:03:46.180
and it's completely per-pixel computed.

00:03:49.280 --> 00:03:52.970
This release of Quartz Composer
also allows you to do some simple

00:03:53.000 --> 00:03:57.000
3D animations which could be
interactive and respond to the mouse.

00:03:57.000 --> 00:04:01.990
I'm using the mouse right now to
actually move around in the 3D world.

00:04:05.630 --> 00:04:13.500
This other composition is actually a
slideshow where we have a folder full of

00:04:13.580 --> 00:04:18.880
images and the composition is responsible
for putting them on screen and computing

00:04:19.230 --> 00:04:21.620
the transition between the images.

00:04:23.320 --> 00:04:26.090
The last composition I want to
show you is a composition that

00:04:26.190 --> 00:04:31.960
gets data from the outside world,
namely the Internet.

00:04:31.960 --> 00:04:36.740
So this composition is getting the
RSS feed from the Apple website

00:04:36.860 --> 00:04:43.660
and showing the hot news
with a simple text animation.

00:04:43.730 --> 00:04:45.570
Back to slides, please.

00:04:49.520 --> 00:04:51.150
So what are we going to learn today?

00:04:51.300 --> 00:04:52.640
Basically five points.

00:04:52.700 --> 00:04:55.030
We're going to have some
theory at the beginning,

00:04:55.140 --> 00:04:57.530
basically the Quartz Composer concepts.

00:04:57.670 --> 00:05:00.360
Then we're going to look
at the application itself.

00:05:00.420 --> 00:05:06.750
We're going to go through a tutorial
so that you can see a typical

00:05:06.870 --> 00:05:10.000
example of building a composition.

00:05:10.000 --> 00:05:10.000
And obviously we'll look at how to play
back compositions in your applications.

00:05:11.650 --> 00:05:13.550
At the base of the
Quartz Composer concept,

00:05:13.700 --> 00:05:14.790
we have what we call patches.

00:05:15.000 --> 00:05:18.300
Patches are basic,
simple processing units.

00:05:18.340 --> 00:05:21.880
Their role in life is simply to
execute and produce some results.

00:05:21.920 --> 00:05:25.480
This result can be sent
to their output ports,

00:05:25.480 --> 00:05:27.850
which we are simply
going to call outputs,

00:05:27.960 --> 00:05:29.900
or to some rendering destinations.

00:05:30.120 --> 00:05:33.950
Then to control these patches,
you pass parameters-- input parameters,

00:05:33.950 --> 00:05:37.040
actually-- through their
input ports of the patches.

00:05:37.040 --> 00:05:40.180
We're going to call input
ports simply inputs.

00:05:40.300 --> 00:05:43.760
So we can say that patches are a
little function that produce some

00:05:43.760 --> 00:05:48.140
result according to a bunch of
parameters and the current time.

00:05:49.460 --> 00:05:52.130
The ports,
the input ports and output ports

00:05:52.130 --> 00:05:55.610
of the patches are actually typed,
which means the kind of

00:05:55.610 --> 00:05:57.170
data you pass does matter.

00:05:57.230 --> 00:06:00.670
We can pass some values
like simple numbers,

00:06:00.800 --> 00:06:04.210
Boolean values, or strings, even colors.

00:06:04.330 --> 00:06:08.090
And we can also pass around
complex objects like bitmaps,

00:06:08.100 --> 00:06:11.160
OpenGL textures, or Core Image images.

00:06:11.270 --> 00:06:13.970
Let's look at some example patches.

00:06:14.200 --> 00:06:17.320
The first one we're going
to look at is the LFO patch,

00:06:17.320 --> 00:06:20.840
which stands for low
frequency oscillator.

00:06:21.240 --> 00:06:27.370
The goal of this patch is actually
to produce a wave on its output,

00:06:27.390 --> 00:06:30.990
which is determined by the current time,
the period of the wave,

00:06:31.180 --> 00:06:34.030
the wave type – so that would be,
for example,

00:06:34.030 --> 00:06:37.580
a square wave or a sinusoidal
wave – and it's sampled.

00:06:38.670 --> 00:06:41.800
This other patch we have here
does not have any input parameter.

00:06:41.850 --> 00:06:43.060
It doesn't need any.

00:06:43.380 --> 00:06:47.860
Its simple role is to produce on its
outputs the current mouse position,

00:06:47.980 --> 00:06:49.680
the X and Y coordinates.

00:06:50.030 --> 00:06:55.880
And the last patch, the sprite patch,
does not have any output ports because

00:06:55.880 --> 00:06:57.450
it is rendering to a destination.

00:06:57.460 --> 00:07:00.390
And in that case,
this patch is actually drawing a

00:07:00.620 --> 00:07:06.750
quad at a given X and Y position and
with a given color and texture on it.

00:07:07.280 --> 00:07:08.820
So how do we put everything together?

00:07:08.920 --> 00:07:13.520
Well, let's say we have kind of workspace
and we put all the patches on it,

00:07:13.620 --> 00:07:15.080
patches we want to use.

00:07:15.110 --> 00:07:19.060
These patches are going to
have some inputs and outputs.

00:07:19.170 --> 00:07:23.450
We can build some connections between
the inputs and outputs so that,

00:07:23.450 --> 00:07:27.410
for example, the patch in the middle
is retrieving the data,

00:07:27.410 --> 00:07:30.490
its input data from the
other patches on the left.

00:07:30.660 --> 00:07:36.180
So we can say that the patch on the
further right is actually pulling the

00:07:36.180 --> 00:07:38.020
data from the patches on the left.

00:07:38.110 --> 00:07:41.290
So what we build here is a
kind of simple data flow model.

00:07:41.400 --> 00:07:46.120
And this is at the core of
the Quartz Composer concept.

00:07:46.260 --> 00:07:50.390
We're going to put these patches
into actually a kind of macro patch.

00:07:51.260 --> 00:07:55.360
And when it becomes interesting is that,
for example, the patch we have at the

00:07:55.360 --> 00:07:57.500
middle of the macro patch,
the big one,

00:07:57.580 --> 00:08:03.460
could actually be itself another
macro patch made of several patches.

00:08:03.570 --> 00:08:07.860
And some of these patches may themselves
be other macro patches and so on.

00:08:07.980 --> 00:08:11.490
So what you end up with is
a hierarchical patch tree.

00:08:11.720 --> 00:08:14.830
Now, if we call the top patch,
the top macro patch,

00:08:14.990 --> 00:08:19.010
at the top of the tree the root patch,
then the entire patch tree and the

00:08:19.070 --> 00:08:25.560
entire data flow it describes is what
we call the Quartz Composer composition.

00:08:26.020 --> 00:08:30.470
Now I'm going to show you
the application itself,

00:08:30.510 --> 00:08:32.930
because that's enough theory for now.

00:08:36.280 --> 00:08:44.900
So you will find the application
into the developer folder,

00:08:44.900 --> 00:08:49.510
applications, graphic tools,
Quartz Composer.

00:08:50.080 --> 00:08:54.080
So it's a kind of standard Cocoa looking
application where you can work on

00:08:54.080 --> 00:08:56.240
multiple compositions at the same time.

00:08:56.240 --> 00:08:59.690
And in that case,
we have one document per composition.

00:08:59.820 --> 00:09:02.770
So let's look in detail
at this document window.

00:09:02.980 --> 00:09:06.280
What we have here is the workspace
where actually we put the

00:09:06.280 --> 00:09:08.550
patches and we interconnect them.

00:09:09.150 --> 00:09:12.800
On the right, we have the list of patches
we can actually use.

00:09:13.420 --> 00:09:17.320
They are pre-sorted by categories
so that it's easier to find them.

00:09:17.450 --> 00:09:21.980
For example, some of them are going to be
controlling the objects by

00:09:21.980 --> 00:09:25.130
sending data for their position,
for example.

00:09:25.400 --> 00:09:28.420
Some other patches are going
to be used to import data,

00:09:28.440 --> 00:09:32.680
like images from files
or from a video camera.

00:09:33.060 --> 00:09:37.500
Then we have several numeric
patches that are used to perform

00:09:37.500 --> 00:09:40.080
some mathematical operations.

00:09:40.190 --> 00:09:44.420
And then we also have rendering patches,
because we want to render

00:09:44.420 --> 00:09:46.090
something eventually.

00:09:46.450 --> 00:09:50.550
At the bottom of the list you will find
several categories that start with a dot.

00:09:50.890 --> 00:09:54.380
And these are all the
Core Image filters which are natively

00:09:54.380 --> 00:09:56.710
supported by Quartz Composer.

00:09:56.790 --> 00:09:59.840
So you can find here all
the compositing filters,

00:09:59.840 --> 00:10:02.710
distortion effects, generators,
and so on.

00:10:03.900 --> 00:11:34.300
[Transcript missing]

00:11:34.920 --> 00:11:37.300
But you will notice that
I don't see my sprite anymore.

00:11:37.300 --> 00:11:40.540
The reason is that since we're
performing drawing operations,

00:11:40.540 --> 00:11:44.270
we need to define which order
the operations are performed.

00:11:44.590 --> 00:11:46.970
And in that case,
you will notice on the top right

00:11:47.090 --> 00:11:50.110
corner of this kind of patches
that they have a number indicating

00:11:50.110 --> 00:11:51.980
in which order they are executed.

00:11:52.190 --> 00:11:53.790
We have number one here,
number two there,

00:11:53.800 --> 00:11:58.390
and obviously we want to do the inverse,
which is rendering first – I mean,

00:11:58.510 --> 00:12:01.370
clearing first the rendering
area and then drawing a sprite.

00:12:01.480 --> 00:12:03.450
For that,
you display the contextual menu on

00:12:03.550 --> 00:12:07.500
the sprite you're interested in,
and you can change its rendering layer,

00:12:07.680 --> 00:12:09.690
which basically defines the order.

00:12:09.780 --> 00:12:12.120
And now it's working fine.

00:12:12.200 --> 00:12:16.420
The next step, I'm going to use the third
patch we introduced earlier,

00:12:16.450 --> 00:12:18.080
which is the LFO patch.

00:12:18.900 --> 00:12:21.700
So the LFO is outputting a
wave according to the time,

00:12:21.700 --> 00:12:26.640
and I'm going to drive the width
of the sprite with that wave.

00:12:26.740 --> 00:12:30.310
So now we can see
something that is animated.

00:12:30.570 --> 00:12:35.090
I might want to also drive the
height of the sprite with that wave,

00:12:35.130 --> 00:12:36.960
but do some other operations on it.

00:12:37.000 --> 00:12:41.820
The way you would do it, for example,
is use a mat patch.

00:12:42.310 --> 00:12:46.840
And I'm going to take the value
from the output of the LFO,

00:12:46.860 --> 00:12:52.010
send it through the MAT patch,
and get the next result and connect

00:12:52.010 --> 00:12:54.940
it to the height of the sprite.

00:12:54.940 --> 00:12:58.960
Now, we've seen so far how you connect
patches and have values being

00:12:58.960 --> 00:13:02.310
transmitted dynamically through patches,
between patches.

00:13:02.310 --> 00:13:04.770
But, of course,
you might not want to always do that

00:13:04.770 --> 00:13:07.510
and have some values defined statically.

00:13:07.510 --> 00:13:09.000
So how do you do that?

00:13:09.170 --> 00:13:12.760
Well, you can simply double-click
on an input input,

00:13:12.770 --> 00:13:16.510
which is going to bring up an editor,
and then you can set

00:13:16.520 --> 00:13:18.300
the value on the input.

00:13:18.300 --> 00:13:21.730
So in that case, that's a color input,
so we get a color well,

00:13:21.730 --> 00:13:25.040
and I can then pick up some green color,
for example.

00:13:25.050 --> 00:13:28.930
Then another way to edit the parameters
is to show the inspector there and

00:13:28.930 --> 00:13:32.070
go to the input parameters pane,
where you can see all

00:13:32.080 --> 00:13:33.490
the parameters at once.

00:13:33.490 --> 00:13:37.760
You will notice that parameters that are
defined by -- because they are connected

00:13:37.760 --> 00:13:42.100
to some outputs are not editable,
obviously.

00:13:42.100 --> 00:13:44.440
And what I might want
to do there is simply,

00:13:44.440 --> 00:13:48.690
I don't know,
define -- take the -- force the sprite

00:13:48.700 --> 00:13:55.600
not to go below 0.5 for its width,
for example.

00:13:55.600 --> 00:13:56.590
For its height, I mean.

00:13:56.960 --> 00:13:59.160
And to go above 0.5.

00:13:59.160 --> 00:14:02.480
And now we've got something like this.

00:14:02.540 --> 00:14:05.300
Let's go back to the slides, please.

00:14:11.110 --> 00:14:15.560
Okay,
we still have some theory to look at.

00:14:15.560 --> 00:14:17.860
Can we go back to the slides, please?

00:14:20.900 --> 00:14:23.000
Thanks.

00:14:23.360 --> 00:14:27.890
So we've seen earlier that we have
what we call a hierarchical patch tree.

00:14:27.900 --> 00:14:31.820
Now we are going to have a rough
look of-- regarding how exactly it

00:14:31.820 --> 00:14:33.480
is being evaluated by the system.

00:14:33.590 --> 00:14:36.150
So at the top of the tree,
we have a macro patch,

00:14:36.160 --> 00:14:39.040
which is basically like the root patch.

00:14:39.110 --> 00:14:42.980
And then, during evaluation,
this patch is being traversed.

00:14:43.150 --> 00:14:47.480
And each time-- and the system is
going to execute the sub-patches that

00:14:47.480 --> 00:14:50.180
are contained into this macro patch.

00:14:50.470 --> 00:14:53.790
And each time one of these
sub-patches is a macro patch itself,

00:14:53.870 --> 00:14:56.160
it's going to be traversed.

00:14:56.210 --> 00:14:58.270
And all its sub-patches
are being executed,

00:14:58.270 --> 00:15:01.800
and so on and so on,
so the tree is traversed upside down.

00:15:02.050 --> 00:15:06.340
Now what exactly happens when we
are inside a macro patch and we

00:15:06.500 --> 00:15:08.890
need to execute the sub-patches?

00:15:09.470 --> 00:15:14.310
The first thing to know is that not
all patches are kind of born equal.

00:15:14.310 --> 00:15:15.630
We have consumer patches.

00:15:15.710 --> 00:15:18.600
These are the essential,
the most important patches.

00:15:18.660 --> 00:15:21.190
They are the ones which render something.

00:15:21.380 --> 00:15:27.310
For right now,
they're all rendering something

00:15:27.310 --> 00:15:27.950
to the destination area,
which is going to be like a screen

00:15:27.950 --> 00:15:27.950
or a preview rendering window.

00:15:28.230 --> 00:15:30.240
Each time you render a
frame of the compositions,

00:15:30.350 --> 00:15:31.700
they're going to be executed.

00:15:31.740 --> 00:15:34.890
They're executed in a defined order,
as we've seen earlier,

00:15:34.890 --> 00:15:40.100
and you can look at the order by looking
at the number on the top right corner.

00:15:40.940 --> 00:15:45.440
And they actually are the one which
pull the data from the other patches.

00:15:45.570 --> 00:15:47.290
What kind of other patches do we have?

00:15:47.370 --> 00:15:51.460
Well, we have the processor patches,
which are kind of slave patches.

00:15:51.840 --> 00:15:56.000
They run on demand,
and they simply execute to

00:15:56.000 --> 00:16:00.710
when their inputs have changed,
and they need their

00:16:00.850 --> 00:16:02.190
outputs to be updated.

00:16:02.200 --> 00:16:07.740
The system only executes
them kind of in a lazy mode.

00:16:08.390 --> 00:16:11.110
The third type of patches
we have are providers,

00:16:11.110 --> 00:16:14.010
and this one's – their role
is to get data from outside

00:16:14.070 --> 00:16:15.630
sources into the system.

00:16:15.790 --> 00:16:18.770
In that example,
it would be a mouse patch.

00:16:18.940 --> 00:16:22.020
And they also run on demand,
which means only when the

00:16:22.020 --> 00:16:24.490
– their outputs are needed.

00:16:24.670 --> 00:16:29.910
Okay, so now, how is that simple example
going to actually execute?

00:16:30.490 --> 00:16:33.460
As we said earlier,
the consumer patches are

00:16:33.510 --> 00:16:36.870
the most important patches,
and they're the one driving everything.

00:16:36.970 --> 00:16:40.960
So they get executed first, and first,
we have the clear patch that executes.

00:16:41.070 --> 00:16:43.160
Then we have the sprite patch
that's going to execute.

00:16:43.290 --> 00:16:48.660
But this one is interesting because some
of its inputs are actually defined by the

00:16:48.660 --> 00:16:54.110
fact they are connected to other outputs,
to some outputs of other patches.

00:16:54.210 --> 00:16:57.800
So before running the sprite patch,
the system must make sure

00:16:57.800 --> 00:17:01.980
that all the inputs that are
connected have up-to-date values.

00:17:02.040 --> 00:17:05.220
So first,
it's going to execute the mouse patch so

00:17:05.220 --> 00:17:10.160
that it's updating its outputs that get
copies to the inputs of the sprite patch.

00:17:10.410 --> 00:17:12.590
And then we have the
LFO patch that is executing,

00:17:12.600 --> 00:17:14.140
and eventually the MAT patch.

00:17:14.160 --> 00:17:17.850
Now all the values on the
sprite are up-to-date,

00:17:17.850 --> 00:17:21.900
and we can execute the sprite patch.

00:17:22.020 --> 00:17:24.540
Let's go back to the demo, please.

00:17:25.930 --> 00:17:30.120
So I'm going to show you a little more
about the evaluation system and how you

00:17:30.120 --> 00:17:32.770
can look at it inside the application.

00:17:35.000 --> 00:17:39.820
So here we have a composition
that is far more advanced than

00:17:39.820 --> 00:17:42.160
the one we looked at earlier.

00:17:42.170 --> 00:17:45.200
Let's look at it for
a second full screen.

00:17:45.740 --> 00:17:52.350
So it's a kind of DVD sim, if you want,
that was built using Quartz Composer.

00:17:52.630 --> 00:17:56.190
And we have live video playing,
being masked in real time,

00:17:56.190 --> 00:18:01.910
some real time Core Image filters also,
and some flying hearts and everything.

00:18:02.680 --> 00:18:04.830
And everything is mostly
completely editable.

00:18:04.980 --> 00:18:06.700
For example,
if I want to change the title,

00:18:06.730 --> 00:18:09.850
I just double click on a
string input and I say,

00:18:10.060 --> 00:18:12.600
um, now, WWDC 2004.

00:18:12.890 --> 00:18:16.100
Okay, now it's very good.

00:18:17.330 --> 00:18:21.540
As we said earlier,
we have some – it's a patch tree.

00:18:21.540 --> 00:18:23.660
The entire composition is a patch tree.

00:18:23.780 --> 00:18:26.240
The way you can look at it
is by displaying the browser.

00:18:26.420 --> 00:18:28.520
And here you can see
we have the root patch,

00:18:28.610 --> 00:18:32.740
and I can look at the background patch,
the flying heart patch, title and menu.

00:18:33.140 --> 00:18:37.430
Some of them are going to contain
other sub-patches and so on.

00:18:37.440 --> 00:18:40.440
Back to the root patch.

00:18:40.440 --> 00:18:44.710
And let's look at the background patch,
which is a macro that was created

00:18:44.710 --> 00:18:47.830
to simplify the – so that you
don't end up with thousands

00:18:47.830 --> 00:18:49.610
of patches at the root level.

00:18:49.660 --> 00:18:54.400
You can create macros and put them
in order to clean up your workspace.

00:18:54.720 --> 00:18:58.030
We're going to see that
later in the tutorial.

00:18:58.390 --> 00:19:02.300
So let's look at the exact
evaluation of the system.

00:19:02.300 --> 00:19:06.130
In that case,
we would have some movie coming in,

00:19:06.290 --> 00:19:10.670
which is our standard
DV progressive 24 frames per second.

00:19:10.880 --> 00:19:13.430
It's going through this patch here,
the movie positioning,

00:19:13.650 --> 00:19:16.630
which actually it's not the real name,
but I renamed it,

00:19:16.630 --> 00:19:20.400
in order simply to put the movie
at the correct position on screen.

00:19:20.460 --> 00:19:25.780
Then it goes through a series of filters
to display – to correct the gamma,

00:19:25.780 --> 00:19:26.900
to adjust the color controls.

00:19:27.000 --> 00:19:51.300
[Transcript missing]

00:19:53.080 --> 00:19:57.340
And on top of that,
we add a kind of white mask

00:19:57.340 --> 00:20:02.790
that is going to be used to
generate a hello inside the ring.

00:20:02.990 --> 00:20:06.920
And eventually,
when we combine everything,

00:20:07.070 --> 00:20:10.740
we end up with our
final background image.

00:20:10.800 --> 00:20:13.990
Now, you can see that this is a very –
the tooltip system is very powerful

00:20:14.000 --> 00:20:18.250
because it allows you to see exactly
what's happening inside the data flow.

00:20:18.760 --> 00:20:19.860
But we can even do better.

00:20:19.860 --> 00:20:24.240
If you press the debug button here,
what's going to happen is that it's going

00:20:24.240 --> 00:20:29.450
to colorize the patches depending on the
way they are currently being executed.

00:20:29.880 --> 00:20:31.660
We have three colors.

00:20:31.940 --> 00:20:37.790
Green means the patch is currently
activated and is running.

00:20:37.850 --> 00:20:41.600
"Red" means a patch is not even being
activated or running or anything at all.

00:20:41.600 --> 00:20:43.890
For example,
if I just drag and drop a patch here,

00:20:44.120 --> 00:20:44.960
nobody's using it.

00:20:44.960 --> 00:20:45.970
So it's just red.

00:20:46.210 --> 00:20:47.910
It's useless.

00:20:48.530 --> 00:20:52.020
Then orange patches are the
ones that are being activated,

00:20:52.020 --> 00:20:53.260
but they're not running.

00:20:53.370 --> 00:20:53.850
Why is that?

00:20:53.860 --> 00:20:57.230
Because the data here is never changing.

00:20:57.260 --> 00:21:01.000
So the system is obviously smart
enough to only re-execute the parts

00:21:01.000 --> 00:21:03.680
of the data flow that are changing.

00:21:03.790 --> 00:21:07.360
Which is the case here,
because the movie images that

00:21:07.360 --> 00:21:12.390
arrives at the entry of the
patch is changing every frame.

00:21:12.510 --> 00:21:15.750
So this enter a pipe here
needs to be re-evaluated.

00:21:15.860 --> 00:21:19.500
Now, let's look at what happens
if I change the color here.

00:21:20.100 --> 00:21:36.800
[Transcript missing]

00:21:42.700 --> 00:21:44.960
So up to the tutorial.

00:21:44.980 --> 00:21:47.220
This simple tutorial is going
to take us through building

00:21:47.220 --> 00:21:48.900
a composition from scratch.

00:21:49.050 --> 00:21:52.230
And what we are going to build
is a composition that's rendered

00:21:52.580 --> 00:21:54.950
a simple real-time glow effect.

00:21:55.170 --> 00:21:57.870
And we're going to learn through
that how to build such a glow

00:21:57.950 --> 00:22:02.300
effect using Core Image Filters,
and also how to render a simple

00:22:02.300 --> 00:22:05.630
animated cube that we're going
to feed through that glow effect,

00:22:05.940 --> 00:22:09.160
because we're going to be rendering
and create a texture out of it.

00:22:09.180 --> 00:22:11.880
And we're going to obtain the result
that you see at the bottom of the

00:22:11.880 --> 00:22:15.350
screen with the original cube,
and then the cube with the

00:22:15.440 --> 00:22:17.280
glow effect on top of it.

00:22:18.120 --> 00:22:20.160
So how would we do a simple glow effect?

00:22:20.160 --> 00:22:21.540
It's only a two-step process.

00:22:21.540 --> 00:22:24.270
We have the original image,
and then on top of it,

00:22:24.410 --> 00:22:25.690
we put a blurred version.

00:22:25.940 --> 00:22:26.970
We add a blurred version.

00:22:27.210 --> 00:22:31.240
So we obtain this nice glowing effect.

00:22:31.370 --> 00:22:34.060
So let's get started.

00:22:35.610 --> 00:22:40.220
So I'm going to launch Quartz Composer,
a startup with a brand new composition.

00:22:40.360 --> 00:22:43.590
First thing I'm going to do is
import an image to work with.

00:22:43.930 --> 00:22:47.480
So I go to the generators
and I use bitmap with file.

00:22:47.530 --> 00:22:51.900
There in the inspector,
if I go to the settings pane,

00:22:51.910 --> 00:22:58.570
I can click on the import file
button and pick up an image file.

00:22:59.690 --> 00:23:01.560
In that case, this one.

00:23:01.610 --> 00:23:05.200
Then the next thing I want to do is
actually render this image on screen.

00:23:05.220 --> 00:23:06.290
We can get started.

00:23:06.420 --> 00:23:07.270
Here we go.

00:23:07.690 --> 00:23:09.440
For that,
I'm going to use the image renderer,

00:23:09.490 --> 00:23:14.950
which gives us extensive control over
rendering a simple image on screen.

00:23:15.420 --> 00:23:19.610
And I'm simply going to connect
the bitmap output to the image

00:23:19.620 --> 00:23:21.670
input of the image renderer.

00:23:21.750 --> 00:23:24.720
The connection is red,
meaning there is some conversion going

00:23:24.720 --> 00:23:29.860
on because the bitmap with file is
generating kind of a bitmap object.

00:23:29.870 --> 00:23:32.380
And the image renderer
accepts the core image image.

00:23:32.670 --> 00:23:35.940
But the system is smart enough to
do conversions between the objects

00:23:35.940 --> 00:23:39.800
or the various types you may be
transmitting whenever it's possible.

00:23:39.870 --> 00:23:43.220
So the red is just to indicate
that a conversion is occurring,

00:23:43.220 --> 00:23:44.240
is happening.

00:23:44.240 --> 00:23:47.880
Otherwise,
you would get like a green connection.

00:23:47.880 --> 00:23:50.940
We're not displaying the entire image
because the image renderer gives

00:23:50.940 --> 00:23:53.980
us specific control over which part
of the image we want to display.

00:23:54.020 --> 00:23:58.800
The reason is that because
it's rendering core images,

00:23:58.910 --> 00:24:00.210
core images may be infinite.

00:24:00.320 --> 00:24:04.280
And you might often end up with infinite
images when you apply some filters.

00:24:04.340 --> 00:24:05.980
So in that case,
you really need to specify,

00:24:05.980 --> 00:24:08.960
I want to render this area of the image.

00:24:09.490 --> 00:24:13.240
So we could specify manually
here in input parameters

00:24:13.350 --> 00:24:16.310
that our original image is

00:24:16.500 --> 00:24:21.770
"1024 by 768, so that will do for now."

00:24:21.940 --> 00:24:25.300
Then to achieve our blur effect,
we said we needed to use a

00:24:25.300 --> 00:24:29.210
blur and to add that on top
of the original rendering.

00:24:29.450 --> 00:24:31.300
So for that,
I'm going to use the Gaussian Blur,

00:24:31.310 --> 00:24:37.060
which is into the Core Image filters,
and the Addition Compositing Patch.

00:24:37.230 --> 00:24:41.860
All I have to do is connect the bitmap
to the input of the Gaussian Blur.

00:24:42.600 --> 00:24:55.900
[Transcript missing]

00:24:57.900 --> 00:25:02.800
Okay, and once I'm done with my blur,
I want to add it to the original image.

00:25:02.830 --> 00:25:05.190
Now we got our nice glow effect.

00:25:05.900 --> 00:25:12.300
But it's if we look at it full
screen what I notice is that it's

00:25:12.300 --> 00:25:18.750
very bright and one way to fix
that is simply to insert a color

00:25:18.830 --> 00:25:26.600
adjustment and cheat by playing on
the gamma before we apply the blur.

00:25:26.600 --> 00:25:30.240
So I'm going to insert a gamma
adjust before the blur and

00:25:30.240 --> 00:25:30.240
then I can play with the okay

00:25:30.870 --> 00:25:34.430
"The power on the gamma correction
to actually kind of fix the

00:25:34.590 --> 00:25:37.980
brightness of the glow effect.

00:25:38.010 --> 00:25:39.820
Now it's much better."

00:25:40.040 --> 00:25:45.140
So that will be our first
part of this tutorial.

00:25:45.990 --> 00:25:49.200
Second part is going to be to create
some animated background because

00:25:49.220 --> 00:25:53.060
it's obviously more interesting to
have our glow effect being applied

00:25:53.060 --> 00:25:55.580
to something that is animating,
that's something that

00:25:55.620 --> 00:25:57.290
is completely static.

00:25:59.670 --> 00:26:01.960
So first thing we want to do
is we're going to just create

00:26:01.960 --> 00:26:05.500
a brand new composition,
as usual clear the screen,

00:26:05.500 --> 00:26:07.940
and then render a cube on top of it.

00:26:08.010 --> 00:26:12.120
The cube has several parameters,
and you can control position

00:26:12.120 --> 00:26:18.060
orientations and the width,
the dimensions of every axis and so on.

00:26:18.060 --> 00:26:21.440
First thing we are going to do
is simply change the dimensions

00:26:21.500 --> 00:26:23.020
to make it a little smaller.

00:26:23.250 --> 00:26:27.970
"So, 0.75, we do the trick,
and then we want to have this

00:26:27.970 --> 00:26:30.960
cube simply animate with time.

00:26:30.960 --> 00:26:34.390
One way to do that is,
would be to use the, let's see,

00:26:34.390 --> 00:26:38.300
interpolation patch,
which simply interpolates between

00:26:38.300 --> 00:26:40.520
two values on a given duration.

00:26:40.930 --> 00:26:45.590
And I'm going to control with
that the X and Y rotation.

00:26:57.700 --> 00:26:57.720
Okay.

00:26:57.720 --> 00:26:57.790
I want the interpolation
to start at zero.

00:26:57.800 --> 00:26:57.860
In that case,
we're going to be in degrees.

00:26:57.870 --> 00:26:58.020
Finish at 360 degrees over, let's say,
10 seconds.

00:26:58.020 --> 00:26:58.300
And I want interpolation to loop.

00:26:58.340 --> 00:27:00.600
Now we got our nice rotating cube.

00:27:00.910 --> 00:27:07.650
Next step is to obviously add a
texture on the faces of the cube.

00:27:07.650 --> 00:27:11.770
So I'm going to go back to generators and
use bitmap with file and import an image.

00:27:12.160 --> 00:27:14.300
So I should have one for this.

00:27:14.300 --> 00:27:15.060
Here we go.

00:27:15.060 --> 00:27:17.210
Nice brick texture.

00:27:17.530 --> 00:27:21.420
And to display this kind of brand
new image on the faces of the cube,

00:27:21.430 --> 00:27:29.110
I simply have to connect the bitmap
to the various faces of the cube.

00:27:33.100 --> 00:27:44.400
[Transcript missing]

00:27:44.620 --> 00:27:46.070
So it's not very realistic.

00:27:46.090 --> 00:27:49.830
So let's look at the environment
patches we have here.

00:27:49.860 --> 00:27:53.170
And one of them is the lighting.

00:27:53.520 --> 00:27:56.060
So we're going to drag and drop it there.

00:27:56.130 --> 00:27:58.210
We don't see any difference yet.

00:27:58.230 --> 00:28:02.560
The reason is that you need to
specify how the lighting is going

00:28:02.700 --> 00:28:04.600
to influence the patch tree.

00:28:04.600 --> 00:28:08.320
Which patches on the workspace here are
going to be influenced by the lighting.

00:28:08.320 --> 00:28:10.620
You might not want all the
patches to be specified,

00:28:10.680 --> 00:28:16.090
to be affected,
so the way we do it is by using

00:28:16.090 --> 00:28:19.560
the fact that the lighting
patch is a macro patch itself.

00:28:19.610 --> 00:28:24.780
And it's only going to affect the
patches that are inside this macro patch.

00:28:24.850 --> 00:28:28.010
One way to navigate through the
patch tree we've seen earlier

00:28:28.040 --> 00:28:29.460
is to use the browser there.

00:28:29.520 --> 00:28:33.980
Another way is simply to double
click on a title bar on a patch.

00:28:34.050 --> 00:28:35.640
And then you can go inside it.

00:28:35.680 --> 00:28:38.790
And if you want to go up one level,
you just click on the Edit Parent button.

00:28:39.040 --> 00:28:40.670
So what we're going to
do is just cut this.

00:28:41.030 --> 00:28:43.320
Go into the lighting patch and patch it.

00:28:43.400 --> 00:28:44.320
I mean, past it.

00:28:44.440 --> 00:28:45.460
Here we go.

00:28:45.640 --> 00:28:48.330
So now we've got our cube,
which is lighter than

00:28:48.340 --> 00:28:50.000
rotating and everything.

00:28:50.020 --> 00:28:52.210
That's going to be part two.

00:28:53.880 --> 00:28:59.170
All right, now how do we put these
two compositions together?

00:29:04.380 --> 00:29:08.230
What we need to do is produce
some kind of image with the

00:29:08.230 --> 00:29:12.810
rotating cube that we're going
to feed through the glow effect.

00:29:14.050 --> 00:29:16.910
And it's convenient because we
have a patch specifically for that,

00:29:17.050 --> 00:29:19.280
which is called – which
is a generator patch,

00:29:19.280 --> 00:29:24.520
and which generates a texture
with what is inside itself.

00:29:24.900 --> 00:29:42.500
[Transcript missing]

00:29:42.870 --> 00:29:45.290
So it's important to
notice that this tool,

00:29:45.300 --> 00:29:49.470
even if it's attempting to abstract all
the various technologies it encompasses,

00:29:49.600 --> 00:29:51.800
it's not hiding everything.

00:29:51.820 --> 00:29:55.660
So you can still have access to the
low-level settings most of the time.

00:29:56.600 --> 00:29:58.740
So in that case,
I'm going to use a rectangle

00:29:58.790 --> 00:30:01.870
texture and I also want

00:30:02.300 --> 00:30:35.500
[Transcript missing]

00:30:35.860 --> 00:30:41.070
So now, onto this texture,
I'm going to have my rotating cube.

00:30:41.070 --> 00:30:46.350
And the next step is obviously to
fit that texture through the glow

00:30:46.350 --> 00:30:50.800
effect instead of the original image.

00:30:52.800 --> 00:31:09.600
[Transcript missing]

00:31:09.880 --> 00:31:12.040
You might want to have these
values to be defined automatically.

00:31:12.040 --> 00:31:16.060
One way to do that is to use
a tool we have around here,

00:31:16.060 --> 00:31:19.910
which is the, for example,
texture dimensions.

00:31:20.090 --> 00:31:22.590
As the name implies,
you simply pass in a texture

00:31:22.600 --> 00:31:27.350
and you can get the width and
height in pixels of that texture.

00:31:30.800 --> 00:31:33.730
So now it's set automatically and
we have our nice glowing effect

00:31:33.910 --> 00:31:35.570
that is applied on the cube.

00:31:35.700 --> 00:31:39.240
And by playing with
the power of the gamma,

00:31:39.260 --> 00:31:41.470
you can see the effect of the glow.

00:31:41.590 --> 00:31:43.640
If I go full screen,
you're going to notice it's

00:31:43.640 --> 00:31:45.140
not running extremely smooth.

00:31:45.230 --> 00:31:48.380
The reason is that, remember,
our original texture on which

00:31:48.400 --> 00:31:52.100
we applied the Gaussian blur
is the same size as the screen.

00:31:52.100 --> 00:31:56.600
So in that case, that's going to be 1290
by 960 or something.

00:31:56.660 --> 00:32:00.590
And it's a lot of data to
be processed by the GPU.

00:32:00.610 --> 00:32:03.380
Because computing a blur is
a very expensive operation.

00:32:03.500 --> 00:32:04.840
So there are ways to optimize that.

00:32:04.840 --> 00:32:07.880
I'm not going to go into
details for this example.

00:32:07.900 --> 00:32:13.000
I'm simply going to show you the
end result of that optimization.

00:32:14.840 --> 00:32:16.800
This is the version you're
actually going to find in the

00:32:16.870 --> 00:32:21.730
examples provided on the Tiger DVD,
the example compositions.

00:32:23.220 --> 00:32:26.320
So this one is the final result.

00:32:26.340 --> 00:32:29.000
And it's very smooth,
and we got a nice glow effect.

00:32:29.040 --> 00:32:35.040
Basically, the difference with what we
just built is after the texture,

00:32:35.060 --> 00:32:38.420
after the step where we generate
the texture with the cube,

00:32:38.520 --> 00:32:45.080
we basically downsample the texture
to one that is always 256 x 256.

00:32:45.310 --> 00:32:49.750
And we feed that downsampled
version of the texture through the

00:32:50.010 --> 00:32:53.100
Gaussian blur and the glow effect.

00:32:53.100 --> 00:32:56.470
And because it's only 256 by 256,
it's going to be very

00:32:56.510 --> 00:32:57.930
fast to be computed.

00:32:58.300 --> 00:33:00.360
Back to the slides, please.

00:33:05.690 --> 00:33:10.800
So now it's time to look at how we
are going to play the compositions.

00:33:10.810 --> 00:33:13.150
There are three possibilities.

00:33:13.160 --> 00:33:17.820
You can use the QC view,
which is a customized NSView we

00:33:17.820 --> 00:33:19.560
provide with Quartz Composer.

00:33:19.560 --> 00:33:22.240
And you can use it directly
in Interface Builder.

00:33:22.330 --> 00:33:26.440
You can do kind of advanced playback,
still in Interface Builder,

00:33:26.440 --> 00:33:30.120
using the QC Patch Controller,
to use the bindings.

00:33:30.360 --> 00:33:33.420
And then the final way of playing
back a composition is kind of

00:33:33.470 --> 00:33:36.840
the hard way where you have more
control over the composition.

00:33:36.880 --> 00:33:39.300
And that's going to be using
the low-level QC renderer class.

00:33:39.370 --> 00:33:40.630
And you have to use
that programmatically.

00:33:43.150 --> 00:33:45.670
Back to Dima Mashin, please.

00:33:52.910 --> 00:33:55.300
So let's launch Interface Builder.

00:33:55.360 --> 00:33:58.480
The first time you launch it,
you're going to have to add

00:33:58.520 --> 00:34:02.560
the Quartz Composer palette,
which is not loaded by default.

00:34:05.490 --> 00:34:08.500
So for that you show the
preferences of Interface Builder.

00:34:08.580 --> 00:34:15.050
You go to the palette area and you
simply click on add and you will find the

00:34:15.050 --> 00:34:21.700
Quartz Composer palette into developer,
extras, palettes,

00:34:21.750 --> 00:34:23.890
and then Quartz Composer.

00:34:23.920 --> 00:34:26.760
Okay, now we're up and running.

00:34:26.760 --> 00:34:29.200
So let's create an empty application.

00:34:30.910 --> 00:34:35.260
And I'm simply going to drag and drop
an instance of the Quartz Composer

00:34:35.260 --> 00:34:40.160
view onto my window and then display
the interface builder inspector.

00:34:40.270 --> 00:34:42.630
In the attributes pane,
you're going to find a load

00:34:42.630 --> 00:34:45.850
button which allows us to
obviously specify the compositions

00:34:45.850 --> 00:34:47.750
we're going to be playing back.

00:34:48.670 --> 00:34:50.880
So I'm going to take the
optimized version of the

00:34:50.880 --> 00:34:53.280
glow effect we just created.

00:34:53.280 --> 00:34:58.710
And now I can just go directly to test
interface and it's up and running.

00:34:59.630 --> 00:35:03.430
So, so far we haven't even typed a single
line of code to do all of this.

00:35:03.680 --> 00:35:06.890
It's worth noticing it.

00:35:08.110 --> 00:35:09.750
Okay.

00:35:09.750 --> 00:35:11.220
That was for very simple playback.

00:35:11.350 --> 00:35:13.710
Now, we're going to do something
that is a little more advanced

00:35:13.810 --> 00:35:16.480
and use the Cocoa bindings.

00:35:16.830 --> 00:35:20.180
So let's go back for a minute to
the Quartz Composer application.

00:35:20.200 --> 00:35:23.990
And I'm going to hide Interface Builder.

00:35:23.990 --> 00:35:23.990
Here we go.

00:35:24.210 --> 00:35:29.340
Let's open our optimized glow.

00:35:29.340 --> 00:35:29.340
So that's this one.

00:35:30.570 --> 00:35:33.150
So we said at the very beginning
that the system was completely

00:35:33.150 --> 00:35:34.710
compliant with the Cocoa bindings.

00:35:34.740 --> 00:35:38.120
That means key value coding
and key value observing.

00:35:38.210 --> 00:35:44.570
And to use bindings, you need to use,
obviously, keys to specify the objects.

00:35:45.820 --> 00:35:48.780
When you look at the tooltips,
you will notice that you may not

00:35:48.780 --> 00:35:53.100
actually see it clearly on the screen,
but the third item is the key.

00:35:53.170 --> 00:35:55.900
Because each patch in the system,
in the patch tree,

00:35:56.090 --> 00:35:58.120
has a unique key to identify it.

00:35:58.150 --> 00:36:01.980
And then each input port or
output port also has a key.

00:36:02.000 --> 00:36:04.920
And you can see these keys by
simply displaying the tooltips.

00:36:05.100 --> 00:36:11.580
So in that case, the key for the patch is
rendering texture underscore one.

00:36:11.610 --> 00:36:14.930
And the key for its
outputs is output texture.

00:36:15.080 --> 00:36:21.470
So we have a way to identify
ports and patches in a tree.

00:36:22.620 --> 00:36:24.940
What we're going to do now is,
in order to use that

00:36:25.070 --> 00:36:28.790
composition with bindings,
we're going to transform it into

00:36:28.790 --> 00:36:32.090
some parametrized composition.

00:36:33.960 --> 00:36:36.100
Pierre-Olivié Latour: Okay,
let's hide this.

00:36:36.100 --> 00:36:39.520
For example,
we might want to have to parameterize

00:36:39.520 --> 00:36:42.830
the background color or the
intensity of the glow effect.

00:36:42.970 --> 00:36:44.700
How would we do that?

00:36:44.820 --> 00:36:49.530
Well,
let's go inside the rendering texture,

00:36:49.530 --> 00:36:56.920
and the color we're interested to
change is defined by the clear patch.

00:36:57.020 --> 00:36:58.530
So what we're going to do is bring
that input to its parent patch.

00:36:59.400 --> 00:37:01.990
So for that, I display the contextual
menu on the patch,

00:37:01.990 --> 00:37:03.690
and I have an option Publish Inputs.

00:37:04.040 --> 00:37:06.450
And I can select the
inputs I'm interested in,

00:37:06.580 --> 00:37:11.220
which in that case is Clear Color,
and specify a name for the new input,

00:37:11.500 --> 00:37:12.900
simply Color.

00:37:13.030 --> 00:37:18.400
Now, if I go back to the parent patch,
you will notice it now has a Color input,

00:37:18.660 --> 00:37:25.820
which corresponds to the
Clear Color input of the Clear patch

00:37:25.830 --> 00:37:28.090
that is inside this macro patch.

00:37:28.520 --> 00:37:30.890
So that is called
publishing inputs/outputs.

00:37:31.030 --> 00:37:34.540
You know an input is published
to its upper level by – because

00:37:34.540 --> 00:37:39.980
it's going to be like a full – a
filled dot instead of an empty dot.

00:37:41.660 --> 00:37:45.400
Let's publish-- but remember,
we said at the beginning

00:37:45.400 --> 00:37:46.320
we have a patch tree.

00:37:46.320 --> 00:37:49.940
And at the top of the patch tree we have
a macro patch like any other macro patch,

00:37:49.940 --> 00:37:54.600
which means we can also publish inputs
and outputs to this macro patch.

00:37:54.690 --> 00:37:56.240
So let's do it.

00:37:56.380 --> 00:37:59.180
We're going to publish the
new color input we just

00:37:59.180 --> 00:38:02.970
created to its parent patch,
which is the root patch.

00:38:03.040 --> 00:38:04.680
We're going to keep the same name.

00:38:04.760 --> 00:38:08.470
And now I have an input that
is at the very top level.

00:38:08.580 --> 00:38:11.290
And it's kind of an
input of the composition.

00:38:11.370 --> 00:38:13.620
And it's the color input.

00:38:15.000 --> 00:38:19.740
So you can use the display pane
here to actually see all the top

00:38:19.740 --> 00:38:23.590
level inputs of the compositions,
which can be considered like the

00:38:23.590 --> 00:38:25.900
parameters of the composition itself.

00:38:25.900 --> 00:38:31.530
Let's publish another input like
the intensity of the glow effect.

00:38:31.970 --> 00:38:37.810
Let's save the result as our part 4.

00:38:39.260 --> 00:38:42.030
Now I'm going to go back to IB.

00:38:42.030 --> 00:38:45.980
And this time we're going to
do playback using bindings.

00:38:52.790 --> 00:38:55.190
To use bindings, we need a controller,
and we provide one,

00:38:55.190 --> 00:39:00.800
which is the QC patch controller,
which you instantiate simply by dragging

00:39:00.800 --> 00:39:04.470
and dropping it onto the document window.

00:39:05.000 --> 00:39:07.660
Remember, the way binding works is
that you have a model.

00:39:07.750 --> 00:39:09.620
In that case,
that's going to be the composition.

00:39:09.760 --> 00:39:12.420
Then you have several views
that are displaying – that are

00:39:12.500 --> 00:39:13.740
interacting with that model.

00:39:13.880 --> 00:39:17.280
And interaction is met through the
controller that is standing in the

00:39:17.280 --> 00:39:19.360
middle and doing the intermediate.

00:39:19.810 --> 00:39:22.400
On the controller,
I can obviously load a composition,

00:39:22.520 --> 00:39:25.200
and I'm going to load
the one I just created.

00:39:26.310 --> 00:39:31.380
Then I'm going to go back to my QC view,
just unload the composition

00:39:31.380 --> 00:39:34.390
that I did on it,
and use now bindings.

00:39:35.110 --> 00:39:41.390
So I displayed the bindings
area of the attribute inspector.

00:39:41.590 --> 00:39:44.110
And then we have a
property that is patch,

00:39:44.240 --> 00:39:48.530
which obviously determines the
patch that is displayed by the view.

00:39:48.910 --> 00:39:52.030
So I'm going to bind that to the
patch controller I just created.

00:39:52.030 --> 00:39:54.800
And I want to retrieve the
root patch of the composition

00:39:54.800 --> 00:39:56.040
and display it on the view.

00:39:56.040 --> 00:39:58.650
And the way you do that is simply
by using the patch controller key,

00:39:58.970 --> 00:40:01.890
which is going to return
the root patch object.

00:40:02.030 --> 00:40:07.100
So remember the top patch at the
top level of the composition.

00:40:07.340 --> 00:40:10.300
So now I can test the interface
and it's the same result as before,

00:40:10.300 --> 00:40:12.640
nothing has changed,
except we're going through bindings,

00:40:12.640 --> 00:40:14.300
which give us a lot of flexibility.

00:40:14.300 --> 00:40:17.570
Because what I can do now is,
for example,

00:40:17.570 --> 00:40:21.290
pick up a slider and use that
to control our power input we

00:40:21.290 --> 00:40:23.310
just created on the composition.

00:40:23.430 --> 00:40:27.390
Remember, it's this one.

00:40:30.050 --> 00:40:34.620
Okay, so the way I would do that is
simply by binding the value on the

00:40:34.620 --> 00:40:41.650
slider to the patch controller,
then retrieve the root patch object,

00:40:41.650 --> 00:40:48.620
and then we need to specify the key
pass to access that color input.

00:40:48.720 --> 00:40:53.300
If we look at the Quartz Composer,
we can see that the color input,

00:40:53.420 --> 00:40:56.590
if you look at the tooltips,
you can look at the key and you

00:40:56.660 --> 00:41:00.600
can look also at the key for the
published version of the input.

00:41:00.630 --> 00:41:03.540
And in that case,
it is automatically computed by the name.

00:41:03.590 --> 00:41:07.540
So because I used the name color,
the key is conveniently set to color.

00:41:07.560 --> 00:41:11.670
It's always going to be the case
unless you already have a color input.

00:41:11.920 --> 00:41:15.380
And then the system is going to have
to pick up another name for you.

00:41:15.550 --> 00:41:18.660
So we know that that input
is identified with color.

00:41:18.690 --> 00:41:20.260
So now that gives me the input.

00:41:20.260 --> 00:41:23.360
And what I'm interested in on
the input is the value itself.

00:41:23.360 --> 00:41:24.240
Oh, I'm sorry.

00:41:24.240 --> 00:41:25.700
It's not actually color.

00:41:25.720 --> 00:41:27.710
It's power in that case.

00:41:27.800 --> 00:41:28.530
So it's power.

00:41:28.540 --> 00:41:30.940
And what I'm interested in is
the value on the power input.

00:41:30.950 --> 00:41:33.940
So I add .value.

00:41:33.940 --> 00:41:36.500
OK, now I can run the--

00:41:36.940 --> 00:41:41.920
Oh, I need to fix the attributes of the
slider so that it goes from zero to one

00:41:41.940 --> 00:41:44.980
only and that it is in continuous mode.

00:41:45.050 --> 00:41:46.880
Okay, that's better.

00:41:47.430 --> 00:41:51.510
So now I got live interaction without
typing a single line of code still

00:41:51.980 --> 00:41:58.810
of the composition we created and
control views I have in my window.

00:41:59.010 --> 00:42:03.120
Let's go a step further
and drive the color now.

00:42:03.270 --> 00:42:05.060
So same principle.

00:42:05.140 --> 00:42:06.930
You go to the Bindings area.

00:42:07.230 --> 00:42:09.900
You bind the value to
the PatchController.

00:42:09.990 --> 00:42:11.390
Here we go.

00:42:11.530 --> 00:42:15.800
You retrieve the Patch object itself,
and then we say color,

00:42:15.890 --> 00:42:20.360
to retrieve the color input, .value,
to retrieve the value on that input.

00:42:20.410 --> 00:42:21.580
OK.

00:42:21.750 --> 00:42:23.140
We can do better than that.

00:42:23.140 --> 00:42:28.290
If we go back to Composition,
I can even-- There you go.

00:42:28.350 --> 00:42:30.130
Let's get it running.

00:42:30.430 --> 00:42:35.700
I might want to change the images,
the image I use as a texture on the cube.

00:42:35.790 --> 00:42:39.930
So the way to do that would
be to go back to the cube.

00:42:40.620 --> 00:42:42.960
And we would like to have
the same texture be put on

00:42:42.960 --> 00:42:44.740
all the faces on the cube.

00:42:44.820 --> 00:42:47.620
And here we have six
connections going on.

00:42:47.690 --> 00:42:51.170
If you want to simplify your life--
and this happens quite often when you

00:42:51.170 --> 00:42:54.500
want to have the same value be set
on several inputs at the same time.

00:42:54.700 --> 00:42:58.400
And when you change one of these values,
you don't want to change, for example,

00:42:58.410 --> 00:42:59.710
six of them each time.

00:42:59.910 --> 00:43:03.750
For that, we provide a little tool,
which is the little utility patch,

00:43:03.750 --> 00:43:06.380
I should say,
which is the Input Splitter.

00:43:06.460 --> 00:43:11.970
If you display the inspector,
you can select the type

00:43:11.970 --> 00:43:13.520
of data it's transmitting.

00:43:13.520 --> 00:43:15.190
So the Input Splitter
is-- so in that case,

00:43:15.200 --> 00:43:17.060
we want to transmit a texture.

00:43:17.080 --> 00:43:20.080
And the Input Splitter is simply
transmitting the value that

00:43:20.190 --> 00:43:23.690
arrives on its input to its output.

00:43:29.260 --> 00:43:33.100
So I'm going to connect the six
faces to that single output,

00:43:33.110 --> 00:43:37.000
and now I can set that value
from one single entry point

00:43:37.000 --> 00:43:38.900
instead of setting it for six.

00:43:39.220 --> 00:43:43.340
Obviously, I can do this,
and I get the same result as before.

00:43:44.030 --> 00:43:49.420
But I'm going to publish that
input and name it texture.

00:43:49.420 --> 00:43:50.650
Go back to the parent patch.

00:43:50.660 --> 00:43:52.740
Get rid of that one,
which is useless now.

00:43:52.780 --> 00:43:54.120
Go back to the parent patch.

00:43:54.140 --> 00:43:57.720
It's right there,
the texture input we just created.

00:43:57.780 --> 00:44:01.010
Publish it again to the top
level – to the upper level,

00:44:01.010 --> 00:44:01.540
I mean.

00:44:01.610 --> 00:44:06.170
And publishing it one last
time to the very – oops,

00:44:06.240 --> 00:44:09.370
I published the output instead.

00:44:09.370 --> 00:44:09.370
Here we go.

00:44:10.490 --> 00:44:12.400
texture and keep the same name.

00:44:12.610 --> 00:44:15.300
Now our composition has
three input parameters,

00:44:15.300 --> 00:44:18.580
the background color,
the power of the glow effect,

00:44:18.640 --> 00:44:20.510
and the texture on the cube.

00:44:20.560 --> 00:44:23.160
I'm going to save that and stop it.

00:44:23.280 --> 00:44:26.240
Go back to IB,
reload the composition on the controller.

00:44:26.330 --> 00:44:29.300
So the composition is actually
stored inside the controller

00:44:29.300 --> 00:44:31.580
and saved with the Nib file,
so you need to reload

00:44:31.580 --> 00:44:33.280
it when you change it.

00:44:33.280 --> 00:44:37.840
Now I've got my brand-new
composition still working the same.

00:44:37.890 --> 00:44:38.550
Okay.

00:44:38.730 --> 00:44:43.670
And in that because I'm
going to draw an NSImageView.

00:44:45.600 --> 00:45:08.500
[Transcript missing]

00:45:09.980 --> 00:45:13.650
So now it's up and running
and what I can do is just drop

00:45:13.760 --> 00:45:16.740
any kind of image file there,
you know, and

00:45:25.920 --> 00:45:30.800
We'll see our starting image,
the glow effect, you know.

00:45:30.990 --> 00:45:33.030
Back to the slides, please.

00:45:39.110 --> 00:45:41.500
All right, so that was playing back
a composition without even

00:45:41.500 --> 00:45:42.700
typing a single line of code.

00:45:42.810 --> 00:45:44.930
But what if you really
want to type some code?

00:45:45.090 --> 00:45:48.270
Well,
you got to use the QCRenderer class.

00:45:48.410 --> 00:45:51.460
Unfortunately,
it's still very simple to do.

00:45:51.460 --> 00:45:52.590
So only three steps.

00:45:52.790 --> 00:45:55.670
You need to have an NSOpenGL context
around because this entire system,

00:45:55.730 --> 00:45:58.010
of course, Composer,
is basically running on top of

00:45:58.260 --> 00:46:00.570
OpenGL as the primary backbone.

00:46:00.740 --> 00:46:04.340
And then we need to have
a QCRenderer instance.

00:46:04.420 --> 00:46:08.650
And we simply render frames
using the renderAtTime method.

00:46:08.880 --> 00:46:10.030
Let's look at some sample code.

00:46:10.200 --> 00:46:12.020
So what does it look like?

00:46:12.160 --> 00:46:15.510
Well, I'm going to assume I have an
NSOpenGL view standing around,

00:46:15.840 --> 00:46:17.780
which is called my NSOpenGL view.

00:46:17.780 --> 00:46:21.160
And I retrieve its
NSOpenGL context from it.

00:46:21.250 --> 00:46:27.060
Then you create an instance of the
QCRenderer using that context and

00:46:27.060 --> 00:46:32.460
using the pass to a composition
file somewhere on your hard drive.

00:46:32.570 --> 00:46:36.780
Now, if I want to render 10 seconds
of that composition with like 25

00:46:36.930 --> 00:46:41.100
frames each second for one second,
you can do it in a very ugly

00:46:41.100 --> 00:46:44.040
manner in that simple for loop.

00:46:44.150 --> 00:46:45.540
All you have to do is call renderer.

00:46:45.540 --> 00:46:47.990
You pass the appropriate time.

00:46:48.200 --> 00:46:51.690
And then you need to flush the
buffers on the OpenGL context to

00:46:51.690 --> 00:46:55.360
display what was just drawn on screen.

00:46:55.360 --> 00:46:57.560
More in a minute about
why we need to do that.

00:46:57.680 --> 00:47:00.030
And eventually, when you're done,
you just release the renderer,

00:47:00.030 --> 00:47:03.030
and all the cleanup is going
to be done automatically.

00:47:03.500 --> 00:47:09.450
Now why exactly is the renderer not
flushing the OpenGL buffers itself so

00:47:09.450 --> 00:47:12.770
that just after a frame is rendered
you immediately see it on screen?

00:47:12.990 --> 00:47:17.090
Well, the goal is that this allows
a lot of flexibility where you

00:47:17.090 --> 00:47:21.200
can interleave the composition
rendering with your own OpenGL code.

00:47:21.610 --> 00:47:25.390
And in that case,
I can do some OpenGL drawing before,

00:47:25.480 --> 00:47:30.060
then render the composition and do
more OpenGL drawing afterwards to

00:47:30.060 --> 00:47:32.550
create kind of underlay overlay.

00:47:32.580 --> 00:47:38.060
So it's very easy to integrate the Quartz
Composer system into your application,

00:47:38.090 --> 00:47:41.240
into your already existing
OpenGL application.

00:47:41.240 --> 00:47:44.660
If you want to add some examples,
some flying logos all around

00:47:44.660 --> 00:47:47.600
the screen or stuff like that,
you can design them easily as

00:47:47.650 --> 00:47:51.780
compositions and then import
them into your application.

00:47:53.280 --> 00:47:56.260
We've seen that one way to
communicate with the composition

00:47:56.350 --> 00:48:00.020
is by doing everything using
bindings in Interface Builder.

00:48:00.170 --> 00:48:02.780
Now you can also do
that programmatically,

00:48:02.800 --> 00:48:06.670
and the equivalent calls would be
set value for input key or value

00:48:06.670 --> 00:48:11.180
for output key to retrieve data
from an output of the composition.

00:48:11.500 --> 00:48:17.880
And the way you would be doing that is
simply you pass an object corresponding

00:48:17.880 --> 00:48:21.100
to the value and you specify the key
corresponding to the input part of

00:48:21.160 --> 00:48:24.560
the composition or the output part.

00:48:24.560 --> 00:48:29.100
You may have noticed earlier
that the render at time takes an

00:48:29.100 --> 00:48:31.020
optional dictionary of arguments.

00:48:31.020 --> 00:48:34.900
And what we are passing here,
or what we may pass here, actually,

00:48:34.970 --> 00:48:38.180
because this is completely optional,
is the current NS event that is

00:48:38.180 --> 00:48:40.580
being processed by the application.

00:48:40.650 --> 00:48:43.620
And you can also pass the mouse
location in normalized coordinates.

00:48:43.620 --> 00:48:50.240
You'll find more details into the header
corresponding to this QC renderer class.

00:48:50.240 --> 00:48:54.360
You may wonder why you have
to actually pass this NS event

00:48:54.360 --> 00:48:56.570
stuff and the mouse location.

00:48:56.680 --> 00:48:58.030
Well, once again, it's optional.

00:48:58.140 --> 00:49:02.370
But the real reason is that you might
want to have the QC renderer system

00:49:02.380 --> 00:49:07.050
running into a command line tool or some
application where you don't have any UI.

00:49:07.490 --> 00:49:09.160
So it's not even there.

00:49:09.160 --> 00:49:11.940
I mean, this data is not available,
so the system cannot retrieve it.

00:49:11.970 --> 00:49:15.190
Another reason might be that you're
running that into your application,

00:49:15.190 --> 00:49:19.020
but you don't want the QC renderer to
actually steal events from your system.

00:49:19.070 --> 00:49:21.760
So that's the downside of using
a low-level API like this,

00:49:21.770 --> 00:49:24.670
is that if you're playing back
a composition that expects

00:49:25.050 --> 00:49:29.930
user events-- and in that case,
only the mouse patch, I think,

00:49:29.930 --> 00:49:36.400
is actually using them to obviously
detect mouse up and mouse down-- You will

00:49:36.490 --> 00:49:38.880
need to pass these events manually.

00:49:40.310 --> 00:49:44.430
So what kind of value should you pass
when you use set value for input key?

00:49:44.540 --> 00:49:48.150
Well, to each type of port,
there is a corresponding

00:49:48.430 --> 00:49:49.660
NS object you can pass.

00:49:49.940 --> 00:49:53.600
If it's a Boolean, index, or number port,
you simply pass an NSNumber.

00:49:53.600 --> 00:49:56.630
You obviously pass NS color
object for color port,

00:49:56.750 --> 00:49:57.270
and so on.

00:49:57.570 --> 00:50:00.350
What you need to pass
for now for the texture,

00:50:00.430 --> 00:50:03.500
bitmap,
or image port is you can pass NS images,

00:50:03.500 --> 00:50:07.350
or in the case of the image port,
you can directly pass a CI image

00:50:07.350 --> 00:50:08.480
you obtained from some other place.

00:50:09.520 --> 00:50:11.760
So what if I want to
control programmatically

00:50:11.760 --> 00:50:13.990
the power of my glow effect?

00:50:14.110 --> 00:50:16.010
Well,
the way you would do it is by simply

00:50:16.350 --> 00:50:18.930
adding a call renderer set value.

00:50:19.040 --> 00:50:22.010
And the power input is a number input,
so as we said earlier,

00:50:22.010 --> 00:50:24.800
we're going to use a
simple NSNumber for that.

00:50:24.890 --> 00:50:27.940
So we back up an NSNumber with
the value we're interested in,

00:50:27.940 --> 00:50:31.010
and we pass that to the renderer
for the correct input key.

00:50:31.280 --> 00:50:33.490
The system is kind of smart enough.

00:50:33.570 --> 00:50:36.720
So you might-- actually,
you don't even need to pass an NSNumber.

00:50:36.720 --> 00:50:40.150
Anything that will-- any
Objective-C object that is

00:50:40.150 --> 00:50:44.620
going to respond to float value,
or double value, or int value,

00:50:44.620 --> 00:50:48.110
this kind of stuff, is going to work.

00:50:50.900 --> 00:50:53.320
So, back to the demo please.

00:50:53.320 --> 00:50:59.110
I'm only going to show you a very simple
application of the QCWanderer class.

00:50:59.530 --> 00:51:03.830
That is going to be the simple playback
application you've seen at the very

00:51:03.830 --> 00:51:06.730
beginning of this presentation.

00:51:10.270 --> 00:51:13.840
So this simple application is basically
playing full screen a composition.

00:51:13.850 --> 00:51:16.970
So it's creating a full
screen in S/OPENGL context,

00:51:16.970 --> 00:51:19.900
create a QC renderer on it,
load the composition,

00:51:19.930 --> 00:51:22.100
and play continuously.

00:51:22.950 --> 00:51:26.150
And it's like two pages of
code and 90% of it is actually

00:51:26.360 --> 00:51:29.500
setting up the OpenGL context,
capturing the screen,

00:51:29.550 --> 00:51:32.900
detecting the fact that the user
is drawing and dropping a file on

00:51:32.900 --> 00:51:34.460
the application icon and so on.

00:51:34.500 --> 00:51:38.240
The Quartz Composer part is
like a couple of lines of code.

00:51:38.300 --> 00:51:45.360
Another example is this screen saver
that is now provided with Tiger.

00:51:47.480 --> 00:51:49.960
You might have seen
during Bertrand's keynote,

00:51:49.960 --> 00:51:53.100
I think.

00:51:53.170 --> 00:51:55.300
So what exactly is inside a screen saver?

00:51:55.300 --> 00:51:58.240
Well, let's have a look at it.

00:51:58.310 --> 00:52:00.440
So I can show the original there,
which is somewhere

00:52:00.440 --> 00:52:01.940
into the system folder.

00:52:02.010 --> 00:52:07.860
And if you look at the package content,
go to Resources, you will find,

00:52:07.860 --> 00:52:10.190
guess what, a composition file.

00:52:10.270 --> 00:52:12.100
And it's right there.

00:52:14.640 --> 00:52:20.980
So all that animation was done – oops,
it's changed the color or something.

00:52:20.980 --> 00:52:27.480
All that kind of complex-looking screen
server was done without typing a line

00:52:27.480 --> 00:52:34.020
of code except for the simple playback
part into the screen server bundle.

00:52:34.020 --> 00:52:36.100
Back to the slides, please.

00:52:47.800 --> 00:52:59.900
[Transcript missing]

00:53:01.640 --> 00:53:05.430
The last thing I would like to show
you is kind of open some doors of

00:53:05.430 --> 00:53:09.550
what exactly you can do with Quartz
Composer and really on the point

00:53:09.690 --> 00:53:12.730
that it's really an open system.

00:53:12.740 --> 00:53:15.490
And you can bring data from many,
many places.

00:53:15.490 --> 00:53:19.940
You've seen earlier that there
were some interactive compositions,

00:53:20.000 --> 00:53:24.510
retrieving data from the mouse,
for example, or from an RSS feed.

00:53:24.560 --> 00:53:27.250
But we can also use
MIDI controlling devices,

00:53:27.330 --> 00:53:32.670
video cameras, and even more,
the compositions we built

00:53:32.880 --> 00:53:36.260
can also respond to their
execution environment somehow.

00:53:36.410 --> 00:53:39.870
So that would be the capabilities
of the OpenGL renderer or the

00:53:39.960 --> 00:53:42.060
dimensions of the rendering area.

00:53:42.140 --> 00:53:49.430
So demo machine, please.

00:53:53.820 --> 00:54:00.220
For the last demo, I'm going to still
modify our composition.

00:54:00.740 --> 00:54:07.990
Now famous glow effect composition
and add more interactivity to it.

00:54:08.730 --> 00:54:18.420
Okay, so let's see,
let's get a picture first.

00:54:18.420 --> 00:54:18.420
It's not there anymore.

00:54:29.550 --> 00:54:32.020
So, for example,
here I have a MIDI device

00:54:32.020 --> 00:54:36.830
controller which is simply – has
a bunch of sliders and knobs,

00:54:36.830 --> 00:54:40.340
and on each of this knob
and each of this slider,

00:54:40.380 --> 00:54:42.480
there is a corresponding
MIDI controller ID,

00:54:42.570 --> 00:54:46.080
and when you touch them,
it's simply sending the current value

00:54:46.080 --> 00:54:48.630
of that control to the MIDI system.

00:54:49.760 --> 00:54:54.320
And we have here a MIDI controller
patch I can drag and drop.

00:54:54.660 --> 00:54:58.040
And by looking in the inspector,
specifically at the settings panel,

00:54:58.040 --> 00:54:59.860
you can configure it completely.

00:55:00.020 --> 00:55:03.130
And I want to listen
to my MIDI input here.

00:55:03.430 --> 00:55:05.620
You can select several sources.

00:55:05.620 --> 00:55:08.420
You can filter the MIDI channels
you want to listen to,

00:55:08.440 --> 00:55:11.050
and obviously select the
controllers you want to observe.

00:55:11.150 --> 00:55:14.180
In that case,
I want to observe controller 32 actually,

00:55:14.180 --> 00:55:16.380
so I'm going to select 32 in the list.

00:55:16.520 --> 00:55:22.460
And now we have a new output that
was generated with the 32 controller,

00:55:22.460 --> 00:55:25.880
and I'm going to delete
the controller number 1.

00:55:25.970 --> 00:55:28.260
It's opening a value that is
normalized between 0 and 1,

00:55:28.300 --> 00:55:31.940
because it's more convenient than the 0,
1, 27 values that you usually

00:55:31.940 --> 00:55:34.020
get from MIDI equipment.

00:55:34.170 --> 00:55:36.630
So all I have to do is connect it there.

00:55:37.140 --> 00:55:42.280
And now I can use my slider here,
and as you can see I control the

00:55:42.410 --> 00:55:45.990
glow effect simply with this slider.

00:55:52.330 --> 00:55:53.230
All right.

00:55:53.230 --> 00:55:54.790
Let's do a little more.

00:55:54.970 --> 00:55:59.110
So instead of using static image
or something that is generated

00:55:59.330 --> 00:56:03.340
from some other compositions,
let's get some video in.

00:56:03.400 --> 00:56:06.790
So I just used the
texture with video patch.

00:56:09.300 --> 00:56:10.240
Here we go.

00:56:10.240 --> 00:56:14.770
And I'm going to feed that on the,
let's say -- well, the cube,

00:56:14.770 --> 00:56:16.480
the faces of the cube.

00:56:16.480 --> 00:56:22.050
So what I have to do is connect this,
connect the texture output to the texture

00:56:22.050 --> 00:56:27.070
input of the -- which was eventually
going to end up on my cube itself.

00:56:27.130 --> 00:56:32.200
You can see there are several settings
you can set for video captures.

00:56:32.300 --> 00:56:33.480
And I need to turn on the video camera,
I guess.

00:56:33.480 --> 00:56:33.480
Let's try this.

00:56:36.930 --> 00:56:41.640
Okay,
I might have to restart the composition.

00:56:41.740 --> 00:56:44.830
So it detects the video input.

00:56:44.980 --> 00:56:47.230
Okay, so now I have...

00:56:47.960 --> 00:56:54.000
Pierre-Olivié Latour: Yeah, okay.

00:56:54.000 --> 00:56:54.000
My last video input there
uncontrolled with the slider.

00:56:58.610 --> 00:56:59.660
Yeah, OK.

00:56:59.660 --> 00:57:04.670
Mine has video input there and
controlled with the slider.

00:57:28.500 --> 00:57:29.900
I'm not sure if the camera
is connected or not,

00:57:29.940 --> 00:57:34.860
is by the fact some object
is defined on the output.

00:57:35.030 --> 00:57:38.280
For that, we could use a tool
that is the multiplexer.

00:57:38.350 --> 00:57:42.140
The multiplexer is simply
a number of inputs.

00:57:42.210 --> 00:57:45.340
And you select,
by using the source index input,

00:57:45.470 --> 00:57:49.690
you select which one of these inputs
is going to be forwarded to the output.

00:57:50.190 --> 00:57:52.090
So in that case,
I'm going to set the multiplexer

00:57:52.210 --> 00:57:57.200
to manipulate texture objects,
reduce the number of inputs to only two,

00:57:57.920 --> 00:58:04.320
Connect the output of the Mixiplexer to
the input of my rendering textures thing,

00:58:04.320 --> 00:58:04.320
Macro.

00:58:04.600 --> 00:58:15.800
[Transcript missing]

00:58:16.250 --> 00:58:25.790
"So, I'm going to connect it there.

00:58:26.060 --> 00:58:26.630
Okay.

00:58:27.780 --> 00:58:30.980
And I can change the text, like no video.

00:58:31.360 --> 00:58:33.420
I have no video on my Q.

00:58:33.420 --> 00:58:36.840
How would I – so it's easy, you know,
you just – if I turn on

00:58:36.850 --> 00:58:39.060
back the video camera there.

00:58:39.060 --> 00:58:44.140
Is it running?

00:58:44.510 --> 00:58:44.540
Okay.

00:58:46.100 --> 00:58:46.850
And I restart.

00:58:47.020 --> 00:58:51.690
Now, by changing the input,
I'm going to get either the

00:58:51.690 --> 00:58:53.600
video input or the text.

00:58:53.650 --> 00:58:56.880
Now, we would like, obviously,
that to be done automatically.

00:58:56.880 --> 00:59:00.240
There is one little hack
you can use to do that.

00:59:00.240 --> 00:59:05.630
It's simply using – let's see.

00:59:05.630 --> 00:59:10.380
It is conditional or logic.

00:59:10.380 --> 00:59:10.380
Here we go.

00:59:10.870 --> 00:59:14.120
Because you can actually
connect an object,

00:59:14.130 --> 00:59:16.350
like a texture or something like that,
to a Boolean input.

00:59:16.380 --> 00:59:19.380
And basically if there is an object,
the Boolean input is going to be set

00:59:19.380 --> 00:59:22.230
to true and if there is no object,
it's going to be set to false.

00:59:22.350 --> 00:59:26.760
So here I have a simple patch which is
doing a logic comparison between two

00:59:26.870 --> 00:59:29.160
Booleans and I'm going to use that.

00:59:29.280 --> 00:59:33.820
So I'm going to set it to OR comparison,
set the second input to true.

00:59:34.200 --> 00:59:39.830
So it always pass and connect the
texture object to the input there.

00:59:39.920 --> 00:59:42.370
So what we have now is

00:59:42.820 --> 00:59:46.790
On that output, I'm going to have true if
there is a texture coming,

00:59:46.790 --> 00:59:49.090
or false if there is no texture.

00:59:49.230 --> 00:59:52.380
And I can take that Boolean and
connect it to an index input,

00:59:52.380 --> 00:59:54.400
and true is simply
going to translate to 1,

00:59:54.470 --> 00:59:59.080
and false is going to translate to 0,
which is exactly what I need.

00:59:59.790 --> 01:00:02.400
So now I've got a system that
is automatically defined,

01:00:02.400 --> 01:00:06.750
and if I have a video camera connected,
I'm going to get the video camera image.

01:00:06.890 --> 01:00:12.230
If I don't have a video camera connected,
I'm going to get the video picture.

01:00:12.410 --> 01:00:22.450
Here we go.

01:00:22.470 --> 01:00:22.480
Oops.

01:00:22.480 --> 01:00:22.480
I kind of accelerated the thing.

01:00:22.480 --> 01:00:22.480
Oh, I did it wrong.

01:00:28.060 --> 01:00:30.010
Oh, that's right, that's right.

01:00:30.010 --> 01:00:34.010
What did I do there?

01:00:38.240 --> 01:00:40.590
"True, that is correct.

01:00:40.590 --> 01:00:42.200
And there we go.

01:00:42.200 --> 01:00:45.200
Oh, that's right.

01:00:45.200 --> 01:00:49.200
You didn't pay attention there.

01:00:49.330 --> 01:00:51.500
Here we go.

01:00:51.510 --> 01:00:51.510
That's better."

01:00:56.650 --> 01:00:59.640
So that was kind of an
interactive compositions.

01:00:59.640 --> 01:01:03.020
And we can do the last thing
I'm going to show you is how to

01:01:03.020 --> 01:01:07.990
have that composition respond to
the OpenGL render capabilities.

01:01:08.280 --> 01:01:12.340
Because all that part here is
basically using Core Image.

01:01:12.340 --> 01:01:14.520
And it's using it in hardware,
so it's only going to work if

01:01:14.580 --> 01:01:18.370
you have a video card that is
supporting the proper extension set.

01:01:18.680 --> 01:01:20.320
So what if the composition
is going to run on it?

01:01:20.470 --> 01:01:22.120
Well,
it's not going to crash or anything,

01:01:22.720 --> 01:01:25.960
but all this part here is
going to do strictly nothing.

01:01:26.050 --> 01:01:29.040
So you might want to display
something else instead.

01:01:29.320 --> 01:01:32.370
So let's go back to the tools,
and I have a convenient

01:01:32.450 --> 01:01:35.640
OpenGL info patch,
which is returning me, for example,

01:01:35.640 --> 01:01:41.060
the renderer vendor or renderer
name of the current renderer,

01:01:41.110 --> 01:01:43.440
the version,
and can check also for the existence

01:01:43.540 --> 01:01:45.940
of various OpenGL extensions.

01:01:45.990 --> 01:01:49.800
The way you use it is that
you display the settings pane,

01:01:49.800 --> 01:01:52.690
and you can add some fancy
extensions names here.

01:01:52.700 --> 01:01:56.740
For example, I don't know,
my fancy extension.

01:02:22.820 --> 01:02:22.820
OK, add it there.

01:02:22.820 --> 01:02:22.820
And now you get a Boolean.

01:02:22.820 --> 01:02:22.820
It's a Boolean output.

01:02:22.820 --> 01:02:22.820
So if the extension is supported,
you get true.

01:02:22.820 --> 01:02:22.820
If it's not supported, you get false.

01:02:22.820 --> 01:02:22.820
So obviously GLARP vertex program
is supported on this computer.

01:02:22.820 --> 01:02:22.820
Fragment program is also supported.

01:02:22.820 --> 01:02:22.820
But my fancy extension, well,
is not supported for some reason.

01:02:22.820 --> 01:02:22.820
So OK.

01:02:22.820 --> 01:02:22.820
Now what I'm going to do is do a simple
comparison on the renderer version.

01:02:23.280 --> 01:02:27.070
So that would be numeric
and then conditional.

01:02:27.140 --> 01:02:30.400
So the renderer version is a number,
and in that case,

01:02:30.420 --> 01:02:34.440
I think it's OpenGL 1.4.

01:02:34.850 --> 01:02:39.290
And what I want to test is,
do we have an OpenGL renderer

01:02:39.290 --> 01:02:42.550
that supports OpenGL 1.4 or later?

01:02:42.880 --> 01:02:47.190
So I just do is greater
or equal than 1.4.

01:02:48.890 --> 01:02:53.190
And you may have noticed that all the
consumer patches automatically have

01:02:53.190 --> 01:02:56.680
an enable input added by the system,
which is a simple Boolean,

01:02:56.680 --> 01:03:00.820
and you can turn on/turn off the
consumer patches from that input so that

01:03:00.990 --> 01:03:02.880
enable input is at the top of the patch.

01:03:03.020 --> 01:03:08.380
Now what I'm going to do is connect
my results to this enable input.

01:03:09.480 --> 01:03:11.450
So as we can see,
it doesn't change anything because if you

01:03:11.450 --> 01:03:13.850
see this video card support OpenGL 1.4.

01:03:13.850 --> 01:03:18.780
Now what if for some reason I wanted
to test for the support of OpenGL 1.5?

01:03:18.780 --> 01:03:23.890
Well, I would simply set 1.5 – oops,
I didn't even put the 1.4 there.

01:03:24.030 --> 01:03:24.640
Here we go.

01:03:24.750 --> 01:03:29.550
I would simply put 1.5 instead of 1.4.

01:03:34.980 --> 01:03:40.190
"Greater or equal than." Okay,
and I must have done

01:03:40.200 --> 01:03:42.320
something wrong here.

01:03:43.440 --> 01:03:45.340
Oh, that's right.

01:03:45.430 --> 01:03:46.120
That's pretty bad.

01:03:46.150 --> 01:03:46.800
Here we go.

01:03:47.060 --> 01:03:51.200
So now you can see that simply changing

01:03:53.180 --> 01:03:55.820
The version you want to detect
for is going to turn off

01:03:55.940 --> 01:03:58.390
dynamically parts of the data flow.

01:03:58.400 --> 01:04:00.930
So it's important to – I'm
going to conclude on that,

01:04:00.940 --> 01:04:04.430
that compositions you create are
absolutely not something that is closed.

01:04:04.500 --> 01:04:05.760
You can really interact with them.

01:04:05.760 --> 01:04:06.860
You can feed data in.

01:04:06.860 --> 01:04:08.470
You can retrieve data from them.

01:04:08.570 --> 01:04:12.550
They can be dynamically
responding to the environment.

01:04:12.920 --> 01:04:14.800
And it's a great,
great system where you can

01:04:14.800 --> 01:04:17.350
experiment with the brand new
technologies we are adding in

01:04:17.350 --> 01:04:19.540
Tiger without typing a line of code.

01:04:19.540 --> 01:04:23.980
And you can add them easily
to your applications.

01:04:24.010 --> 01:04:26.040
Back to the slides, please.

01:04:32.130 --> 01:04:34.100
So who you might want
to contact about this,

01:04:34.100 --> 01:04:37.190
there is Travis Brown who
is our graphics and imaging

01:04:37.190 --> 01:04:40.410
evangelist or possibly myself.

01:04:44.990 --> 01:04:47.310
For more information,
you may want to look at

01:04:47.440 --> 01:04:51.390
two documentations we have,
Visual Computing with Quartz Composer,

01:04:51.950 --> 01:04:56.610
which is a simple introduction
followed by a tutorial,

01:04:56.610 --> 01:05:00.120
which is pretty much the
tutorial we just did right there.

01:05:00.190 --> 01:05:02.310
And the other documentation
is Image Processing with

01:05:02.310 --> 01:05:05.040
a Core Image Framework,
and it actually contains an

01:05:05.040 --> 01:05:08.790
extensive description of all the
filters provided by Core Image,

01:05:08.790 --> 01:05:12.980
which are natively supported
by the Quartz Composer system.

01:05:13.020 --> 01:05:15.950
You will also find the sample
code for the Quartz Composer

01:05:16.060 --> 01:05:20.220
Player I demoed today,
which is going to be on the ADC website.

01:05:20.400 --> 01:05:24.520
And you will also find some
demo compositions located into

01:05:24.520 --> 01:05:28.180
developer examples Quartz Composer,
and you may obviously

01:05:28.180 --> 01:05:29.090
look at the screen server.
WEBVTT

00:00:13.610 --> 00:00:17.180
Ladies and gentlemen,
please welcome Vice President,

00:00:17.180 --> 00:00:21.110
Interactive Media Group, Tim Schaaf.

00:00:25.300 --> 00:04:55.600
[Transcript missing]

00:04:55.950 --> 00:05:01.260
So, as we've mentioned earlier today,
there's a lot more happening

00:05:01.260 --> 00:05:04.070
inside that box than just what's
going on in the microprocessor.

00:05:04.100 --> 00:05:07.810
The chips that we ship
in our current systems,

00:05:07.820 --> 00:05:10.930
the Radeon systems,
are already up at about

00:05:11.010 --> 00:05:13.300
115 million transistors.

00:05:13.300 --> 00:05:17.430
This is about double the
complexity of the microprocessor.

00:05:17.440 --> 00:05:20.580
The system that
Steve introduced this morning,

00:05:20.580 --> 00:05:24.820
the new NVIDIA GeForce
6800 Ultra processors,

00:05:24.880 --> 00:05:27.230
have 222 million transistors.

00:05:27.240 --> 00:05:30.260
Four times the complexity of the G5.

00:05:30.280 --> 00:05:35.040
That's an incredible opportunity for
all of us to be able to enhance the

00:05:35.040 --> 00:05:37.820
functionality of our applications.

00:05:37.820 --> 00:05:41.380
But unfortunately,
it doesn't happen automatically.

00:05:41.460 --> 00:05:44.140
And the question we're going
to try to address today is

00:05:44.140 --> 00:05:45.500
how to unlock this stuff.

00:05:45.880 --> 00:05:47.380
There are many, many obstacles.

00:05:47.440 --> 00:05:54.930
So, in 1984, this was the statement that
Apple made about the importance

00:05:54.940 --> 00:05:58.700
of rich graphics interface,
WYSIWYG, and interactive UI.

00:05:58.700 --> 00:06:01.690
This was really a dramatic statement.

00:06:01.700 --> 00:06:05.590
This brought into the mainstream
concepts which had not been seen

00:06:05.700 --> 00:06:07.650
in a personal computer before.

00:06:07.700 --> 00:06:11.660
Spin forward 20 years to this year,
Apple's introduced this

00:06:11.660 --> 00:06:12.700
product called Motion.

00:06:12.700 --> 00:06:15.890
And I think it's a very good
example of the way the expectations

00:06:15.980 --> 00:06:16.700
have evolved over the 20 years.

00:06:17.440 --> 00:06:22.440
Still rich graphics, still essentially a
WYSIWYG kind of an experience.

00:06:22.550 --> 00:06:24.440
Very much an interactive UI.

00:06:24.450 --> 00:06:26.770
But obviously,
the kind of software required to

00:06:26.770 --> 00:06:30.150
build this interface is incredibly
more complicated than the software

00:06:30.250 --> 00:06:32.320
required to build the app of 1984.

00:06:32.440 --> 00:06:37.440
Let's look at the operating systems
that you have to learn and understand.

00:06:37.440 --> 00:06:41.710
Apple has, you know, roughly speaking,
every single year,

00:06:41.710 --> 00:06:46.440
we're introducing another thousand
man years worth of software.

00:06:46.440 --> 00:06:47.360
Every single year.

00:06:47.470 --> 00:06:51.900
And you can see this in this sort of
very simplistic view of the size of the

00:06:51.900 --> 00:06:55.440
disks that we have to ship to you in
order to deliver the operating system.

00:06:55.440 --> 00:06:59.430
We've moved to a DVD this year because,
yes, it's growing again.

00:06:59.440 --> 00:07:02.440
How are you going to manage
all of those toolboxes?

00:07:02.440 --> 00:07:04.430
It's just so much stuff to learn.

00:07:04.440 --> 00:07:10.440
As we introduce more and more systems
with more and more diversity of hardware

00:07:10.440 --> 00:07:13.440
with fancier and fancier architectures,
the question becomes,

00:07:13.440 --> 00:07:16.400
how the heck do you get all
this performance out of the box?

00:07:16.490 --> 00:07:19.440
It used to be that you could sit down
and you'd learn the instruction set.

00:07:19.440 --> 00:07:22.100
You'd write some programs and
you'd learn what was fast and then

00:07:22.100 --> 00:07:23.440
you'd write that in your code.

00:07:23.440 --> 00:07:25.440
And you'd have the
fastest app on the planet.

00:07:25.440 --> 00:07:27.440
It doesn't work like that anymore.

00:07:27.440 --> 00:07:29.230
It's really, really complex.

00:07:29.440 --> 00:07:33.330
And the performance decisions that you
would make for a G3 will be different,

00:07:33.520 --> 00:07:35.440
very different than what
you're going to do on a G5.

00:07:35.440 --> 00:07:37.430
How can you do that automatically?

00:07:37.440 --> 00:07:41.430
This is not a puzzle you probably want to
spend all of your time trying to solve.

00:07:41.440 --> 00:07:45.440
When we sat down to think about what
would be most profound in our contract,

00:07:45.440 --> 00:07:48.750
in our contribution to Tiger,
in the graphics and

00:07:48.750 --> 00:07:51.580
media team that I run,
we wanted to look at

00:07:51.690 --> 00:07:54.420
these issues and say,
how can we unlock this power for you,

00:07:54.540 --> 00:07:58.440
protect your software investment,
and give you tools to build beautiful UI?

00:07:58.440 --> 00:08:00.410
And this was our goal.

00:08:01.860 --> 00:08:05.970
So we want to build the technologies
that are going to allow you

00:08:05.980 --> 00:08:07.380
to build the next killer app.

00:08:07.460 --> 00:08:09.870
Because we believe,
as cool as these demos

00:08:10.250 --> 00:08:12.930
that you've seen today are,
we believe that you folks are the

00:08:13.110 --> 00:08:16.540
ones who are going to have the really,
really exciting ideas.

00:08:16.540 --> 00:08:20.020
I mean, it's neat to see
Core Image processing these images.

00:08:20.070 --> 00:08:22.100
And we're going to show
you some more of it today.

00:08:22.100 --> 00:08:27.750
But we are absolutely positive that your
inventions are going to blow us away,

00:08:27.750 --> 00:08:31.810
amaze and delight your customers,
and just baffle the world.

00:08:31.910 --> 00:08:33.090
How do they do that?

00:08:33.280 --> 00:08:37.900
So here's the architecture of the
graphics and media layer as a panther.

00:08:37.900 --> 00:08:41.020
Basically,
very familiar block diagram here.

00:08:41.170 --> 00:08:46.320
We've got Quartz 2D, we've got QuickTime,
we've got OpenGL, all layered on top of

00:08:46.450 --> 00:08:48.090
the graphics hardware.

00:08:48.090 --> 00:08:52.030
This has been a very,
very powerful architecture for Apple.

00:08:52.120 --> 00:08:54.170
There's only one problem here.

00:08:54.170 --> 00:08:59.510
You could look at this another way as
three stove-piped technology stacks.

00:08:59.620 --> 00:09:01.830
And any of these are going to
be As many of you will know,

00:09:01.830 --> 00:09:04.390
if you start to try to
combine these technologies,

00:09:04.490 --> 00:09:07.900
drawing the lines from left to right,
right to left, more horizontally,

00:09:07.970 --> 00:09:10.760
you start to run into
some real challenges.

00:09:10.770 --> 00:09:12.990
So in Tiger,
one of the most important changes

00:09:12.990 --> 00:09:16.350
we are making is we're kind of
turning this diagram on its side

00:09:16.680 --> 00:09:20.910
in order to give a much better,
much more powerfully layered

00:09:20.910 --> 00:09:22.460
system for you to work with.

00:09:22.670 --> 00:09:26.260
Now,
the APIs aren't all different in Tiger.

00:09:26.260 --> 00:09:28.440
Your applications are still
going to be compatible.

00:09:28.440 --> 00:09:32.500
But we're working down in the lower
layers to reorient this architecture in

00:09:32.560 --> 00:09:36.590
order to maximize the kind of performance
and the kind of data interoperability

00:09:36.670 --> 00:09:40.770
that we'll be able to provide through
the APIs so that your apps will be able

00:09:40.770 --> 00:09:46.080
to combine all these technologies and
still have a high performance result.

00:09:46.450 --> 00:09:48.380
I've broken this up a
little bit more detail.

00:09:48.380 --> 00:09:50.760
You see the Quartz stack,
you see the Core Audio stack.

00:09:50.880 --> 00:09:54.000
They've both got their hardware
abstraction layer conceptually.

00:09:54.000 --> 00:09:57.430
And so what I want to do for the rest
of this talk is we're going to dive

00:09:57.430 --> 00:10:01.120
in and look at what's going on in each
of the individual technology areas

00:10:01.120 --> 00:10:04.620
and tell you some of the highlights
of what's new and hopefully plant

00:10:04.620 --> 00:10:08.560
some seeds for how you might be able
to take advantage of these things.

00:10:08.620 --> 00:10:10.420
Our first area is Core Audio.

00:10:10.420 --> 00:10:15.630
As we've expressed earlier today,
this is a very profound technology

00:10:15.720 --> 00:10:17.800
for processing of audio.

00:10:17.800 --> 00:10:21.770
This is the most advanced
audio subsystem built into any

00:10:21.770 --> 00:10:24.310
operating system anywhere else.

00:10:24.420 --> 00:10:28.570
When you look at other operating systems,
if you want to achieve the kind

00:10:28.570 --> 00:10:32.050
of performance that we're able
to achieve inside of Mac OS X,

00:10:32.160 --> 00:10:35.860
you always end up having to
build special things into the OS.

00:10:35.880 --> 00:10:38.600
You have to add special extensions
in order to achieve performance.

00:10:38.710 --> 00:10:40.800
So you have to build special
extensions in order to achieve

00:10:40.800 --> 00:10:43.180
the kind of performance that you
get with Mac OS X out of the box.

00:10:43.180 --> 00:10:44.210
What does that look like?

00:10:44.210 --> 00:10:47.040
Well, it's the ultra-low latency that
allows you to do demos like the guitar

00:10:47.070 --> 00:10:48.590
demo you saw earlier this morning.

00:10:48.770 --> 00:10:50.930
It's playing live into the system.

00:10:50.930 --> 00:10:55.990
It's processing the audio in real time,
sending it back out the audio outputs.

00:10:55.990 --> 00:10:59.540
And it feels like he's playing
it live as if it were a piece of

00:10:59.680 --> 00:11:01.980
hardware in a music studio rack.

00:11:03.070 --> 00:11:04.090
We've got HiDef.

00:11:04.520 --> 00:11:09.300
This was the first media processing
stack to build in a full floating

00:11:09.300 --> 00:11:10.680
point processing pipeline.

00:11:10.680 --> 00:11:13.030
And it's worked tremendously well for us.

00:11:13.270 --> 00:11:16.880
Not only does it allow us to
support current state-of-the-art

00:11:16.880 --> 00:11:20.780
processing 24-bit type samples,
we can go way beyond that

00:11:20.780 --> 00:11:22.230
as the industry evolves.

00:11:22.290 --> 00:11:25.440
We support a very,
very wide range of sample rates and

00:11:25.450 --> 00:11:26.800
there's no constraints on the channels.

00:11:27.420 --> 00:11:31.530
We have beautiful,
robust plug-and-play compatibility across

00:11:31.530 --> 00:11:34.020
a wide range of connectivity protocols.

00:11:34.140 --> 00:11:38.470
We've got built-in native,
built-in MIDI support,

00:11:38.510 --> 00:11:41.240
very low latency just
like the audio support.

00:11:41.260 --> 00:11:46.430
And then we have this very important
architecture for extending the system.

00:11:46.440 --> 00:11:50.540
One of the most important parts of an
audio subsystem is the set of customized

00:11:50.540 --> 00:11:55.590
audio plug-ins that you can bring to bear
to provide your audio a unique kind of

00:11:55.590 --> 00:11:57.320
a sound or a unique kind of processing.

00:11:57.320 --> 00:12:00.080
Now,
we've had a tremendous amount of success

00:12:00.080 --> 00:12:04.160
with our audio units and this is a
small sampling of the developers who

00:12:04.160 --> 00:12:06.690
have gotten on board with audio units.

00:12:06.800 --> 00:12:09.200
Now, of course,
the universe of developers who

00:12:09.200 --> 00:12:11.530
are using core audio is much,
much larger.

00:12:11.540 --> 00:12:14.140
But here's a really important
collection of developers who are

00:12:14.360 --> 00:12:15.990
focused on audio unit development.

00:12:16.040 --> 00:12:19.620
This success has brought some
very interesting new challenges

00:12:19.620 --> 00:12:21.330
and some new opportunities.

00:12:21.440 --> 00:12:25.280
As the community of developers
who are centered around core

00:12:25.280 --> 00:12:29.030
audio continues to grow,
one of the things that we've been very

00:12:29.030 --> 00:12:32.700
concerned to be able to provide is a
very high level of compatibility between

00:12:32.820 --> 00:12:34.300
all these different kinds of plug-ins.

00:12:34.340 --> 00:12:40.040
And so earlier this year,
we introduced a program and a piece

00:12:40.040 --> 00:12:45.140
of software that would help audio unit
developers ensure that their audio

00:12:45.140 --> 00:12:49.260
unit plug-ins were going to be robust,
compatible as they went from one

00:12:49.260 --> 00:12:51.230
app to the next and to the next.

00:12:51.240 --> 00:12:55.840
We're introducing today a
new product called AU Lab,

00:12:55.840 --> 00:12:56.340
which is a part of the
developer program called AU Lab.

00:12:56.340 --> 00:12:56.840
AU Lab is a part of the
developer program called AU Lab,

00:12:56.840 --> 00:12:57.130
which is a part of the
developer program called AU Lab,

00:12:57.150 --> 00:12:57.240
which is a part of the
developer program called AU Lab,

00:12:57.340 --> 00:13:01.610
the developer tool set that's going
to take this one step further and

00:13:01.620 --> 00:13:05.310
I'd like to give you a chance to
take a look at that in just a second.

00:13:05.600 --> 00:13:08.670
And what this is going to allow you
to do is it's going to help--help

00:13:08.900 --> 00:13:13.190
the audio unit developer develop
an even more robust audio unit

00:13:13.190 --> 00:13:18.310
that can be plugged into the ever
increasingly complex and sophisticated

00:13:18.350 --> 00:13:20.530
range of audio applications.

00:13:20.690 --> 00:13:24.370
So why don't we come over and
take a quick look at this.

00:13:33.200 --> 00:13:36.620
So we have this little
application called AU Lab.

00:13:36.620 --> 00:13:41.730
And basically,
the model of AU Lab is it's a mixer.

00:13:41.870 --> 00:13:45.000
And the first thing we're going to
do is we're going to come in here

00:13:45.000 --> 00:13:47.840
and we're going to add a generator.

00:13:47.910 --> 00:13:50.640
And we've built into this tool
a generator that's capable of

00:13:51.030 --> 00:13:52.290
bringing in audio from a file.

00:13:52.300 --> 00:13:55.200
Now, of course,
it can also process audio in real time,

00:13:55.260 --> 00:13:58.540
coming in through the different
kinds of inputs that you can support.

00:13:58.870 --> 00:14:00.580
So the first thing we're going to
do is we're going to open up the

00:14:00.580 --> 00:14:04.510
little configuration panel for this,
bring in an audio file.

00:14:04.870 --> 00:14:05.930
And we can play it.

00:14:05.950 --> 00:14:08.670
It's just like an audio playback system.

00:14:08.850 --> 00:14:10.120
Great.

00:14:10.250 --> 00:14:14.900
Now, what you can do is you can bring
in your audio unit plug-in and

00:14:14.900 --> 00:14:19.880
load it into this little mixer,
and it's now been inserted

00:14:19.880 --> 00:14:22.910
into the processing chain.

00:14:23.330 --> 00:14:26.390
And what we've got here is we've
got a new audio unit that we're

00:14:26.390 --> 00:14:28.320
providing in Tiger called TimePitch.

00:14:28.320 --> 00:14:31.280
And what it has the ability to do,
it's a very sophisticated

00:14:31.280 --> 00:14:35.520
DSP algorithm that allows you to
alter the timing of a piece of

00:14:35.520 --> 00:14:38.060
audio without altering the pitch,
or you can alter the pitch

00:14:38.060 --> 00:14:39.060
without altering the timing.

00:14:39.060 --> 00:14:43.020
And I'll give you a very quick example
of what this might be useful for.

00:14:43.020 --> 00:14:46.240
So this is a piece of music
by a couple of guitar players,

00:14:46.500 --> 00:14:50.110
John McLaughlin, Al DiMila,
two of the fastest guitar players

00:14:50.200 --> 00:14:52.390
I've ever seen in the universe.

00:14:52.880 --> 00:14:57.650
And what you encounter with
this kind of guitar playing is

00:14:57.650 --> 00:14:59.770
that they start playing really,
really fast.

00:14:59.880 --> 00:15:02.640
My son is a guitar player
and he's always asking,

00:15:02.640 --> 00:15:04.850
"How can I learn how to learn this music?

00:15:04.980 --> 00:15:13.150
It's going too fast." This little plug-in
basically allows you to take these files

00:15:15.450 --> 00:15:20.460
You can dramatically slow them
down without altering the pitch.

00:15:20.500 --> 00:15:22.880
You can go faster.

00:15:24.030 --> 00:15:30.810
And again,
it sounds just like the original audio.

00:15:31.470 --> 00:15:36.760
So there's a very simple demo of
how AU Lab can be used to validate

00:15:36.760 --> 00:15:39.460
and test out your audio units.

00:15:39.470 --> 00:15:43.740
And we think it's going to be a very
important part of our overall strategy

00:15:43.850 --> 00:15:50.500
for ensuring broad adoption of audio
units and being able to help facilitate

00:15:50.660 --> 00:15:54.080
a very powerful community in the
audio world relying on Core Audio.

00:15:54.720 --> 00:15:58.000
So here's another situation
that's coming up more and more

00:15:58.000 --> 00:16:01.480
as these Core Audio applications
are being enhanced.

00:16:01.480 --> 00:16:05.680
Typical kind of a studio setup,
you've got multiple audio devices.

00:16:05.680 --> 00:16:09.360
Today in Core Audio,
we can handle these devices just fine,

00:16:09.360 --> 00:16:12.110
but when it comes to
managing those devices,

00:16:12.110 --> 00:16:16.050
all the burden of managing which
channels are going where and the

00:16:16.050 --> 00:16:20.600
inter-device synchronization,
the burden is on the application.

00:16:20.600 --> 00:16:24.550
We're going to be introducing a
new technology that allows you

00:16:24.550 --> 00:16:24.700
to add and remove audio units.

00:16:24.720 --> 00:16:28.600
We're going to be integrating these
devices into one logical unit,

00:16:28.600 --> 00:16:32.660
and we think it's going to make the
process of developing applications

00:16:32.660 --> 00:16:36.100
for sophisticated studio setups much,
much easier.

00:16:36.630 --> 00:16:39.400
Last of all, I want to talk about OpenAL.

00:16:39.640 --> 00:16:43.740
OpenAL is an industry-standard
API for managing spatialized audio.

00:16:43.740 --> 00:16:45.940
It's used all over the place in games.

00:16:45.940 --> 00:16:48.980
It's a technology
developed by Creative Labs,

00:16:48.980 --> 00:16:52.760
and we have been working with them
and other developers to build a

00:16:52.770 --> 00:16:55.160
highly optimized version of OpenAL.

00:16:55.160 --> 00:16:59.450
It's capable of supporting
not only super high quality

00:16:59.450 --> 00:17:03.890
spatialized audio processing,
but it's also got a variety of modes to

00:17:04.010 --> 00:17:07.560
be able to do lower complexity modes so
you can get lots and lots of channels.

00:17:07.700 --> 00:17:11.650
We're going to build this into Tiger,
and we think it's going to be a great

00:17:11.710 --> 00:17:16.490
addition to the OpenGL technology for a
complete solution for game development.

00:17:17.210 --> 00:17:20.760
So this is the story about what's
happening with Quartz Audio.

00:17:21.020 --> 00:17:23.710
What I want to do next is
I want to ask Peter Grafagnino,

00:17:23.710 --> 00:17:26.540
our Quartz extremist,
to come over and tell you

00:17:26.540 --> 00:17:30.260
about everything that's
going on in the Quartz world.

00:17:30.290 --> 00:17:32.770
And it's a very large world.

00:17:49.200 --> 00:17:50.040
I guess I can go to the podium.

00:17:50.040 --> 00:17:50.700
Oh, there we are.

00:17:50.700 --> 00:17:51.960
Okay.

00:17:51.960 --> 00:17:56.500
So I'm going to walk you through the
technologies in the graphics stack.

00:17:56.590 --> 00:18:01.960
I'm going to basically walk you
up the stack from the hardware,

00:18:02.110 --> 00:18:06.730
talk a little bit more about that,
OpenGL, and then talking about Quartz.

00:18:06.770 --> 00:18:09.560
And then Tim's going to come
back and talk about QuickTime.

00:18:11.420 --> 00:18:14.650
So on the hardware side,
you've seen this graph many times.

00:18:14.890 --> 00:18:17.640
This is pixels processed per second.

00:18:17.670 --> 00:18:22.350
And if you look at also memory fill rate,
the current generation of graphics

00:18:22.530 --> 00:18:26.480
chips are about 35 gigabytes
per second of memory bandwidth,

00:18:26.610 --> 00:18:28.510
which is pretty incredible.

00:18:28.690 --> 00:18:32.310
And as you've heard a
couple of times already,

00:18:32.310 --> 00:18:34.970
this is kind of an inflection
point in computer graphics.

00:18:35.070 --> 00:18:37.240
We now have programmability
at the pixel level,

00:18:37.290 --> 00:18:40.210
it's a floating point,
it's accurate enough for high-end

00:18:40.210 --> 00:18:44.380
work and high dynamic range,
and enables a lot of applications beyond

00:18:44.740 --> 00:18:46.360
just the traditional gaming stuff.

00:18:46.500 --> 00:18:51.830
So we're seeing a convergence of graphics
and media processing together in the GPU.

00:18:51.870 --> 00:18:53.380
And there's some new
programming paradigms.

00:18:53.380 --> 00:18:56.820
You heard me and Bertrand's talk
about the Stream Computing Model that

00:18:56.820 --> 00:18:58.360
we're using for Core Image.

00:18:58.360 --> 00:19:01.730
And Tiger will advance the state
of the art here and bring a lot

00:19:01.730 --> 00:19:06.070
of ways to bring the power of
the GPU into your applications.

00:19:08.340 --> 00:19:13.640
So there's a bunch of things you can
do in Tiger as far as GPU programming.

00:19:13.880 --> 00:19:16.380
There's low-level access via OpenGL.

00:19:16.380 --> 00:19:22.320
There's accelerated 2D graphics
we have with Core graphics,

00:19:22.320 --> 00:19:24.100
which we'll talk about in a second.

00:19:24.100 --> 00:19:27.760
We have accelerated image
processing with Core Image.

00:19:27.780 --> 00:19:30.920
We have Core Video,
which we were also talking about.

00:19:30.930 --> 00:19:33.140
Basically,
we've got a bunch of ways to leverage

00:19:33.240 --> 00:19:35.170
the power of the graphics processor.

00:19:35.180 --> 00:19:37.500
And the trick for your apps
is to try to use the highest

00:19:37.500 --> 00:19:39.780
level of abstraction you can,
which allows us to do

00:19:39.780 --> 00:19:41.100
more of the heavy lifting.

00:19:41.100 --> 00:19:43.820
There's nothing wrong with going
down to the OpenGL layer if you

00:19:43.820 --> 00:19:45.660
need to do that or want to do that.

00:19:45.660 --> 00:19:48.150
But we've got these
higher-level services as well,

00:19:48.150 --> 00:19:52.360
which you can take advantage of
and let the platform do the rest.

00:19:52.390 --> 00:19:58.620
So the Tiger Quartz layer is optimized
to take advantage of programmable GPUs.

00:19:58.620 --> 00:20:00.960
Now, it's not necessarily
required to run Tiger,

00:20:00.960 --> 00:20:05.890
obviously, on a programmable part,
but it's optimized in that way.

00:20:07.010 --> 00:20:10.020
And by programmable GPU, what do I mean?

00:20:10.020 --> 00:20:15.190
I mean on the ATI product line,
any part that's an

00:20:15.210 --> 00:20:19.800
ATI Radeon 9600 or higher,
or on the NVIDIA side,

00:20:19.800 --> 00:20:22.890
the GeForce FX or higher,
or the new card that we

00:20:22.890 --> 00:20:24.040
just announced today.

00:20:24.040 --> 00:20:26.870
By technology,
I mean ARB Fragment Program,

00:20:26.960 --> 00:20:30.310
if you're an OpenGL programmer,
or on the Windows side,

00:20:30.310 --> 00:20:33.320
you sometimes hear it called
DirectX 9 capable hardware.

00:20:33.320 --> 00:20:35.320
That's the basic class of hardware.

00:20:38.010 --> 00:20:41.220
Now, interestingly enough,
if you look at the GPU versus the CPU,

00:20:41.220 --> 00:20:46.110
the GPU is not necessarily always faster.

00:20:46.120 --> 00:20:48.750
So it's something to keep in mind
that you really need to treat it as a

00:20:48.820 --> 00:20:50.340
kind of a co-processing environment.

00:20:50.380 --> 00:20:55.210
The high-end CPU,
if you put dual gigahertz,

00:20:55.310 --> 00:21:04.060
2.5 gigahertz G5s in a computer with a
low-end but programmable graphics part,

00:21:04.080 --> 00:21:08.620
the CPUs will be able to
easily beat the low-end GPUs.

00:21:08.740 --> 00:21:11.660
So you always have to be aware of
the trade-off and really view the

00:21:11.800 --> 00:21:16.360
GPU as kind of a co-processor and also
understand if you're flexible about

00:21:16.360 --> 00:21:20.940
using GPU or CPU that your app will
scale to a much greater level with

00:21:20.940 --> 00:21:24.540
the GPU scaling factors that we're
seeing that are exceeding Moore's Law.

00:21:24.540 --> 00:21:26.740
So that's all I'm going
to say about hardware.

00:21:26.740 --> 00:21:30.320
Just to motivate you guys to learn
more about what's going on there,

00:21:30.320 --> 00:21:32.260
talk a little bit about OpenGL.

00:21:33.580 --> 00:21:38.540
OpenGL is the foundation and
sort of the hardware abstraction

00:21:38.540 --> 00:21:41.600
layer for our graphics hardware,
as Tim mentioned.

00:21:41.600 --> 00:21:44.340
And there's a bunch of
things going on in Tiger.

00:21:44.340 --> 00:21:47.260
There's the OpenGL shading language,
which we'll be supporting.

00:21:47.260 --> 00:21:49.240
There's floating-point pixel support.

00:21:49.240 --> 00:21:51.300
Some of this made its way into Panther.

00:21:51.300 --> 00:21:55.660
There's major enhancements
to the OpenGL profiler tool,

00:21:55.660 --> 00:22:01.180
which is a really popular developer tool
for analyzing your OpenGL performance.

00:22:03.080 --> 00:22:04.540
New resource management improvements.

00:22:04.540 --> 00:22:07.480
We're probably on our third or
fourth generation of kind of treating

00:22:07.480 --> 00:22:11.240
the GPU as a full-fledged resource
to be managed within the kernel.

00:22:11.240 --> 00:22:14.310
There's a lot of new stuff to support
many of the things you've seen today

00:22:14.310 --> 00:22:16.290
and will see throughout the conference.

00:22:16.300 --> 00:22:21.040
And I did want to mention one session
that was not in the show guide here,

00:22:21.040 --> 00:22:23.250
which is the introduction
to OpenGL shading language,

00:22:23.250 --> 00:22:24.600
which is going to be on Friday.

00:22:24.600 --> 00:22:26.950
So be sure to check that out.

00:22:27.860 --> 00:22:28.550
That's OpenGL.

00:22:28.560 --> 00:22:29.860
Let's move up to the Quartz layer.

00:22:30.110 --> 00:22:33.700
This year, we're dividing the Quartz
layer into three things.

00:22:33.760 --> 00:22:36.410
There's Core Graphics, of course,
which is our 2D graphics

00:22:36.410 --> 00:22:37.720
and windowing system.

00:22:37.720 --> 00:22:41.200
Then there's Core Image and Core Video,
which are new this year.

00:22:41.420 --> 00:22:43.240
Core Image is our image
processing engine,

00:22:43.270 --> 00:22:46.180
and Core Video is our
video processing engine.

00:22:46.180 --> 00:22:49.690
On the Core Graphics side,
we're not staying still here either.

00:22:50.060 --> 00:22:52.310
So let me talk about that.

00:22:52.780 --> 00:22:56.480
The big news in core graphics land
is that Quartz 2D goes extreme.

00:22:56.480 --> 00:23:01.380
So we talked a little bit last year
about having Quartz 2D on OpenGL,

00:23:01.380 --> 00:23:03.930
and this year it's going
to be the default in Tiger.

00:23:03.940 --> 00:23:09.440
So we have quality with the 2D
rendering through OpenGL that's

00:23:09.440 --> 00:23:11.650
virtually identical to software quality.

00:23:11.660 --> 00:23:15.930
And any of you guys who know
about how GPUs make different

00:23:16.010 --> 00:23:19.730
trade-offs about 2D graphics,
it's actually pretty tricky

00:23:19.730 --> 00:23:22.690
to do this in all cases,
to get really high-quality text

00:23:22.720 --> 00:23:24.450
with OpenGL is kind of a pain.

00:23:24.460 --> 00:23:26.030
But we've taken care of all of that.

00:23:26.040 --> 00:23:30.070
We cache even LCD-quality sub-pixel
position glyphs and can render

00:23:30.070 --> 00:23:32.940
them and blit them onto the screen
with all the proper blending

00:23:32.940 --> 00:23:34.130
you need to do to do that.

00:23:34.290 --> 00:23:37.010
So this acceleration of Quartz 2D,
however,

00:23:37.050 --> 00:23:39.900
does require programmable hardware
to be able to do the LCD blitting

00:23:39.900 --> 00:23:41.570
and all the programmable blend modes.

00:23:41.620 --> 00:23:46.470
The low-level benchmarks when
you put Quartz 2D on top of

00:23:46.470 --> 00:23:49.150
GL increase by 2 to 100 times.

00:23:49.180 --> 00:23:53.180
So there's some real impressive
performance gains to be had.

00:23:53.180 --> 00:23:56.180
But the key to getting those
are to reuse your resources.

00:23:56.180 --> 00:24:00.300
So if you have CG image
refs or CG pattern refs,

00:24:00.300 --> 00:24:02.200
things like that,
and you're going to draw

00:24:02.200 --> 00:24:05.310
them more than once,
just be sure to hold onto that and it

00:24:05.400 --> 00:24:06.180
will get cached up in video memory.

00:24:06.180 --> 00:24:10.180
The other thing,
since we can't accelerate Quick Draw,

00:24:10.180 --> 00:24:14.180
if you use Quick Draw within a window
and you're using Quartz 2D Extreme,

00:24:14.180 --> 00:24:17.170
we fall everything back to software.

00:24:19.170 --> 00:24:21.790
So the core primitive
benchmarks with Quartz 2D,

00:24:21.790 --> 00:24:25.970
you can see the increases here,
pretty striking.

00:24:25.980 --> 00:24:27.860
Obviously,
GPUs are great at filling memory,

00:24:27.960 --> 00:24:32.080
so an 800 by 800 rectangle
is 236 times faster.

00:24:32.080 --> 00:24:35.960
It could probably even go faster if
we could figure out how to feed it.

00:24:35.970 --> 00:24:38.980
Line drawing, for example, eight times.

00:24:39.040 --> 00:24:40.640
Text strings.

00:24:40.640 --> 00:24:44.220
Our software text path is
actually pretty tuned at 1 and

00:24:44.260 --> 00:24:48.790
1/2 million glyphs per second,
but we're getting almost 5 million

00:24:48.840 --> 00:24:53.200
glyphs per second with the hardware,
which is really good.

00:24:55.260 --> 00:24:59.680
So we didn't turn it on by
default in the WWDC build,

00:24:59.680 --> 00:25:02.380
but for those of you who know
about the Quartz debug tool,

00:25:02.420 --> 00:25:04.200
you can go in and turn it on.

00:25:04.280 --> 00:25:05.480
It works pretty well.

00:25:05.480 --> 00:25:07.230
It works a little bit
better on ATI hardware than

00:25:07.240 --> 00:25:09.260
NVIDIA hardware right now.

00:25:09.280 --> 00:25:10.740
But you can turn it on.

00:25:10.740 --> 00:25:12.020
We know that there are
a few bugs in there,

00:25:12.020 --> 00:25:15.440
but if you want to try out your
app and see if things get faster,

00:25:15.540 --> 00:25:18.820
if not, go catch your pattern
refs and image refs,

00:25:18.840 --> 00:25:22.590
and you'll probably see quite
a performance difference.

00:25:23.470 --> 00:25:27.410
The other thing to look at in Quartz
Debug is you'll notice a show user

00:25:27.410 --> 00:25:31.540
interface resolution menu item.

00:25:31.610 --> 00:25:36.720
And what we're talking about this
year at WWDC is getting ready for

00:25:36.720 --> 00:25:40.260
a resolution independence in the
user interface in the tool kit.

00:25:40.320 --> 00:25:43.750
And I think this is-- thanks.

00:25:44.400 --> 00:28:17.900
[Transcript missing]

00:28:20.170 --> 00:28:22.910
Just to show you Quartz Debug,
if you don't know Quartz Debug,

00:28:22.910 --> 00:28:24.530
you can find it in the developer tools.

00:28:24.540 --> 00:28:25.920
It's under the performance tools.

00:28:25.920 --> 00:28:30.190
You can see I've got Quartz
2D Extreme enabled here.

00:28:30.200 --> 00:28:34.650
I'm going to go up to that tools menu and
bring up the user interface resolution.

00:28:34.700 --> 00:28:38.800
And let's crank up things a
little bit and give us kind of a

00:28:38.950 --> 00:28:44.640
virtual scaling factor of about,
let's do something big like 1.75.

00:28:46.860 --> 00:28:51.750
And now any app I launch is
going to get a 1.75 scale factor.

00:28:51.830 --> 00:28:53.040
So let's launch Safari.

00:28:53.040 --> 00:28:56.640
You can see I get a huge menu bar and
I'm not connected to the Internet.

00:28:56.640 --> 00:28:58.260
Well, that's too bad.

00:29:03.580 --> 00:29:06.570
But you can see how the
app is drawn much larger.

00:29:06.580 --> 00:29:08.840
The menus are high resolution rendered.

00:29:08.840 --> 00:29:11.840
You can see the rest of the--
if I switch to another app,

00:29:11.840 --> 00:29:13.720
for example, it'll make it clear.

00:29:13.750 --> 00:29:14.940
Here's Quartz Debugs menus.

00:29:14.960 --> 00:29:19.700
They're still small,
whereas Safari's menus are big.

00:29:19.720 --> 00:29:22.280
And so you can see that there's
going to be some drawing bugs,

00:29:22.290 --> 00:29:25.710
like over here by the Google Search menu,
which we're-- we're working through

00:29:25.710 --> 00:29:27.130
with the apps and the frameworks.

00:29:27.200 --> 00:29:31.650
But you should use this tool on the
developer CD and test out your app

00:29:31.660 --> 00:29:34.680
with the resolution independence.

00:29:34.690 --> 00:29:36.970
So back to slides, please.

00:29:40.490 --> 00:29:44.600
The next thing we're doing in Quartz
2D is floating point pixel support.

00:29:44.770 --> 00:29:46.420
So yes, thanks.

00:29:46.860 --> 00:29:48.000
What comes after millions?

00:29:48.000 --> 00:29:50.500
It's jillions, I don't know.

00:29:50.600 --> 00:29:54.000
But it's full floating point
pixel processing pipeline.

00:29:54.090 --> 00:29:56.460
Floating point both on the
source and destination,

00:29:56.530 --> 00:30:00.630
so CG image refs can be floating point,
as well as CG bitmap context,

00:30:00.650 --> 00:30:02.800
the destination for drawing.

00:30:02.890 --> 00:30:06.180
We used unclamped colors processed
all throughout the pipeline.

00:30:06.210 --> 00:30:12.060
And we're going to have a floating point
CMM based on ColorSync in the Tiger GM.

00:30:12.080 --> 00:30:13.280
So that's pretty exciting.

00:30:13.310 --> 00:30:15.250
And to go with that,
we have a new framework in

00:30:15.250 --> 00:30:19.320
Quartz Graphics called ImageIO,
which is a thread-safe image

00:30:19.710 --> 00:30:23.040
handling library for FileIO.

00:30:23.040 --> 00:30:26.100
And it includes new HDR,
or high dynamic range,

00:30:26.100 --> 00:30:29.700
floating point formats,
such as OpenEXR from ILM,

00:30:29.700 --> 00:30:33.900
and various flavors of floating
point TIFF that are out there.

00:30:35.560 --> 00:30:36.770
Next up is PDFKit.

00:30:37.000 --> 00:30:40.220
PDFKit is a high-level
framework for dealing with PDFs.

00:30:40.220 --> 00:30:44.660
It's an Objective-C framework
up at the AppKit layer.

00:30:44.660 --> 00:30:47.020
You can think of it as
preview on a palette.

00:30:47.060 --> 00:30:50.520
And much in the way that WebKit is
sort of Safari on a palette,

00:30:50.580 --> 00:30:55.480
PDFKit is the PDF sort of half
of preview running on a palette,

00:30:55.520 --> 00:31:00.540
complete with link traversal
and printing and fit to page

00:31:00.540 --> 00:31:02.820
and all that sort of stuff.

00:31:04.000 --> 00:32:15.900
[Transcript missing]

00:32:18.190 --> 00:32:21.290
Quartz 2D in Tiger will fill in the
last of the big holes that we've

00:32:21.360 --> 00:32:22.780
definitely gotten feedback on.

00:32:22.780 --> 00:32:26.040
The headers are still available,
but they'll be marked deprecated if

00:32:26.040 --> 00:32:29.250
you compile against the Tiger target.

00:32:29.260 --> 00:32:34.220
Binary compatibility, of course,
will continue to exist, at least for now.

00:32:34.220 --> 00:32:38.420
And you should definitely budget
time in your next revision of

00:32:38.420 --> 00:32:40.800
your app to move to Core Graphics.

00:32:41.010 --> 00:32:42.930
And we really want to
make it work for you,

00:32:42.930 --> 00:32:44.980
so we're definitely open to feedback.

00:32:45.440 --> 00:32:48.010
And we have a whole session
about transitioning to Quartz

00:32:48.170 --> 00:32:50.660
2D that's specifically targeted
for QuickDraw developers.

00:32:50.660 --> 00:32:53.760
And we've got a lot of new stuff
that should make it easier,

00:32:53.760 --> 00:32:55.780
and we want to hear about
more things you might need.

00:32:57.640 --> 00:33:03.190
So to help motivate that a little bit,
let me do a quick demo.

00:33:05.810 --> 00:33:08.970
of line drawing performance.

00:33:08.970 --> 00:33:13.130
So this is one thing we got
feedback on as being much faster in

00:33:13.130 --> 00:33:15.700
QuickDraw than it was in Quartz 2D.

00:33:16.010 --> 00:33:20.470
Quartz 2D would lovingly anti-alias
all of your intersecting polygons

00:33:20.470 --> 00:33:23.680
and some N squared algorithm
and would just be really slow.

00:33:23.680 --> 00:33:26.140
So people would use QuickDraw
for stuff like this.

00:33:26.860 --> 00:33:32.180
Well, we've improved Quartz 2D such that
it's now 1.5 million and this is

00:33:32.180 --> 00:33:33.440
actually the software renderer.

00:33:33.780 --> 00:33:36.850
And once we go on top of GL,
we're actually up at 11

00:33:36.850 --> 00:33:38.240
million lines per second.

00:33:40.400 --> 00:33:40.700
Great.

00:33:40.860 --> 00:33:43.140
And this is still only
immediate mode in OpenGL.

00:33:43.140 --> 00:33:45.380
If you know anything about OpenGL,
there might be another 5,

00:33:45.380 --> 00:33:46.960
10x on top of this as well.

00:33:46.960 --> 00:33:50.070
But clearly, GL is the way to draw lines.

00:33:50.070 --> 00:33:53.140
And so just to drive it home,
we're looking at, you know, 41.

00:33:53.140 --> 00:33:55.470
We didn't draw the initial
Quartz 2D software,

00:33:55.470 --> 00:33:58.620
which is somewhat less than 1.0,
as some of you might know.

00:33:58.650 --> 00:34:01.940
But getting on to Quartz 2D is
clearly what you want to do here.

00:34:01.940 --> 00:34:03.890
So back to slides, please.

00:34:06.710 --> 00:34:13.270
So some bonus sessions
in the 2D graphics path.

00:34:13.750 --> 00:34:16.200
The high dynamic range is going
to be talked about together

00:34:16.200 --> 00:34:17.900
with the Image.io framework.

00:34:17.980 --> 00:34:21.400
That session is going to be on Wednesday,
and then we have a session

00:34:21.520 --> 00:34:22.980
on PDF kit tomorrow.

00:34:22.980 --> 00:34:25.380
So please attend those.

00:34:25.850 --> 00:34:27.300
Let's talk a little bit about Core Image.

00:34:27.300 --> 00:34:29.940
You've heard about it in the
keynotes and other talks.

00:34:29.940 --> 00:34:32.000
Again,
it's a framework for GPU-focused image

00:34:32.160 --> 00:34:37.040
processing with a rich set of built-in
filters and our plugin architecture.

00:34:37.040 --> 00:34:40.040
The great thing is that you don't have
to know about OpenGL to use Core Image,

00:34:40.040 --> 00:34:45.000
which is a nice feature for those
of you coming from the 2D world.

00:34:45.020 --> 00:34:47.600
Core Image actually
is an Objective-C API.

00:34:47.600 --> 00:34:50.760
It's based on a stream-based
processing model.

00:34:50.790 --> 00:34:53.370
The number of abstractions is very few.

00:34:53.380 --> 00:34:56.580
There's images and there's kernels,
which are the processing units.

00:34:56.580 --> 00:34:59.590
And then there's samplers,
which basically kernels use to

00:34:59.590 --> 00:35:02.020
access data from within images.

00:35:02.050 --> 00:35:04.990
Kernels are described in a
runtime compiled language,

00:35:05.040 --> 00:35:07.160
high-level C-like language.

00:35:07.160 --> 00:35:08.520
The parallelism is implicit.

00:35:08.520 --> 00:35:11.780
As I said before in the other talk,
there's no explicit loops or threads.

00:35:11.780 --> 00:35:17.060
You just use the image unit or program
the image unit to do what you want.

00:35:17.060 --> 00:35:21.460
And the evaluation model,
since it's implicit, is mappable to GPUs,

00:35:21.460 --> 00:35:24.830
symmetric multi-threaded CPUs,
or other parallel architectures.

00:35:24.990 --> 00:35:27.320
You might imagine.

00:35:27.320 --> 00:35:30.390
We have a software fallback that's
actually quite good as well.

00:35:30.400 --> 00:35:33.080
It uses the Velocity Engine and
a just-in-time compiler

00:35:33.080 --> 00:35:36.260
that's custom for Core Image.

00:35:36.260 --> 00:35:39.260
And it generates auto-vectorized
code optimized either for G4

00:35:39.260 --> 00:35:45.860
or G5 or even dual G5 with
multi-threading if that's available.

00:35:46.080 --> 00:35:51.240
And the evaluation engine does a number
of sort of compiler techniques at the

00:35:51.250 --> 00:35:55.900
graph level as you construct image
units together to minimize the number of

00:35:55.910 --> 00:35:59.070
passes and handle the temporary buffers,
pbuffers and caching

00:35:59.070 --> 00:36:00.080
and things like that.

00:36:00.120 --> 00:36:02.600
So it does a lot of
heavy lifting for you,

00:36:02.600 --> 00:36:06.150
and let me give you a demo of that.

00:36:13.240 --> 00:36:16.750
So when we were preparing
for the keynote,

00:36:16.750 --> 00:36:24.460
we did a lot of sort of experimentation
with core image and some imagery that

00:36:24.470 --> 00:36:26.880
we didn't use in the keynote I thought
it would be fun to show you guys here.

00:36:26.880 --> 00:36:30.360
So here's a couple of
interesting filters.

00:36:30.360 --> 00:36:33.770
Here's a circular half-tone
screen on this image.

00:36:33.770 --> 00:36:35.440
I can change the width.

00:36:35.520 --> 00:36:38.180
It's all getting computed on GPU.

00:36:38.180 --> 00:36:41.270
This is a Radeon 9800 XT card.

00:36:43.100 --> 00:36:45.370
Some other ones that are kind of fun.

00:36:45.500 --> 00:36:48.900
The surfer wave.

00:36:48.900 --> 00:36:52.500
Reset back and let's
do a zoom blur on him.

00:36:52.500 --> 00:36:56.420
Oops, not white point adjust.

00:37:00.870 --> 00:37:02.400
So that's kind of cool.

00:37:02.400 --> 00:37:03.670
You can change the amount.

00:37:03.740 --> 00:37:09.820
What else did I have?

00:37:10.610 --> 00:37:12.160
Let's do a layer effect.

00:37:12.340 --> 00:37:15.070
So I'm going to bring a water
droplet background image.

00:37:15.080 --> 00:37:18.180
Let's turn off Zoom Blur.

00:37:18.180 --> 00:37:20.610
Let me add another filter.

00:37:21.550 --> 00:37:23.800
which is a piece of water artwork.

00:37:23.800 --> 00:37:30.450
Let me add a rounded 3D effect on that,
and you can see what that looks like.

00:37:30.550 --> 00:37:32.890
That's pretty neat.

00:37:33.210 --> 00:37:38.600
The other thing I wanted to
show was kind of a build of

00:37:38.750 --> 00:37:43.900
One of the stacking effects,
Phil did the electric zebra this morning,

00:37:43.900 --> 00:37:46.710
and I'm going to show
you a different one,

00:37:46.710 --> 00:37:51.490
which is kind of also in the 60s theme.

00:37:51.610 --> 00:37:58.340
So let's, we're going to try to go for
some kind of a silkscreen look,

00:37:58.340 --> 00:37:58.340
so we're going to,

00:37:59.260 --> 00:38:02.690
Color posterize the image a little bit.

00:38:02.690 --> 00:38:05.720
Then I'm going to oversaturate it using a

00:38:06.610 --> 00:38:08.900
Over saturate filter.

00:38:08.910 --> 00:38:10.110
I'm going to use a false color.

00:38:10.210 --> 00:38:13.560
A false color just converts
the image to gray scale and

00:38:13.560 --> 00:38:14.900
then maps it through a ramp.

00:38:14.900 --> 00:38:19.390
And I've got a couple of colors
here that I'm going to use.

00:38:19.730 --> 00:38:22.600
So yeah,
so now it's looking pretty psychedelic.

00:38:22.600 --> 00:38:30.930
Then the next thing I add in is every
60s poster needs a lenticular halo.

00:38:31.370 --> 00:38:33.540
There we go.

00:38:35.020 --> 00:38:39.200
Which, this is doing a,
it's a generator that generates kind

00:38:39.200 --> 00:38:42.160
of a sun striation sort of a thing.

00:38:42.160 --> 00:38:43.640
Let's do that.

00:38:43.640 --> 00:38:45.730
Okay, let's bring in some line art.

00:38:45.730 --> 00:38:47.960
Oops, well, that's okay.

00:38:49.800 --> 00:38:55.700
The 60s album, which is the type,
and we'll insert a bump map in

00:38:55.700 --> 00:38:59.710
there to do our bump distortion.

00:38:59.770 --> 00:39:05.650
And then, lastly,
I think I have a crop in here.

00:39:05.660 --> 00:39:07.160
Yeah, so you can crop out the edges.

00:39:07.160 --> 00:39:09.670
So, but the great thing is
the whole stack is live.

00:39:09.670 --> 00:39:11.840
I can, it's totally non-destructive.

00:39:11.840 --> 00:39:15.390
It's just sort of remembering
the recipe to create the image,

00:39:15.390 --> 00:39:19.410
and you can kind of turn off the layers
and see how each one is doing or go back.

00:39:19.490 --> 00:39:21.900
I can change the posterization
level on the fly.

00:39:21.900 --> 00:39:24.960
I can even go back and
change the image on the fly.

00:39:24.990 --> 00:39:27.730
I could do it to, you know,
the water image if I, you know,

00:39:27.730 --> 00:39:30.190
my band changed.

00:39:30.330 --> 00:39:36.110
Or I can even run video
through the background.

00:39:37.300 --> 00:39:41.160
So, you know,
you get your album cover and

00:39:41.160 --> 00:39:43.260
your video at the same time.

00:39:43.260 --> 00:39:47.430
And it's all still live.

00:39:47.440 --> 00:39:49.000
I can find the bump.

00:39:59.320 --> 00:40:07.360
Let me add the bump back in,
I lost where it was.

00:40:08.900 --> 00:40:18.400
[Transcript missing]

00:40:25.590 --> 00:40:27.690
So you definitely want to go
to the core image session.

00:40:27.700 --> 00:40:29.660
Hopefully we've teased you
enough by showing it in

00:40:29.690 --> 00:40:32.560
every single keynote session.

00:40:32.600 --> 00:40:36.890
And it's tomorrow afternoon at 5 o'clock,
so you'll definitely want to see that.

00:40:37.060 --> 00:40:37.540
Core Video.

00:40:37.540 --> 00:40:41.670
Core Video is, one way to think about
Core Video is it takes the output of

00:40:41.680 --> 00:40:43.760
QuickTime and maps it into the GPU.

00:40:43.760 --> 00:40:48.200
And so it basically, new for QuickTime,
is separating the decoding logic

00:40:48.200 --> 00:40:49.700
from the presentation logic.

00:40:49.700 --> 00:40:51.990
So it solves the video
on a texture problem,

00:40:52.000 --> 00:40:53.700
which we know a lot of
our internal developers,

00:40:53.700 --> 00:40:56.110
and I know a lot of you guys as well,
have had.

00:40:56.120 --> 00:40:58.520
We've had like four or five
different examples on the website

00:40:58.520 --> 00:40:59.860
of how to do video on a texture.

00:40:59.860 --> 00:41:01.560
None of them were actually optimal.

00:41:02.060 --> 00:41:04.870
And we're just solving that in
Tiger in a great way where you get

00:41:05.020 --> 00:41:09.960
total asynchronous behavior and data
flow between the GPU and the CPU.

00:41:09.960 --> 00:41:13.210
And that's really what allows
us to do some of these demos

00:41:13.420 --> 00:41:15.980
like 6DP high definition H.264.

00:41:16.020 --> 00:41:20.070
It allows also, once you get the video
frames up in the GPU,

00:41:20.070 --> 00:41:23.570
you can use Core Image on
them for video effects.

00:41:23.680 --> 00:41:26.630
So bonus session on that, of course,
the Core Image effect,

00:41:26.770 --> 00:41:30.690
the Core Image talk,
as well as new directions

00:41:30.800 --> 00:41:31.950
for QuickTime performance.

00:41:32.070 --> 00:41:34.850
where you're going to see a
lot of this stuff in action.

00:41:35.550 --> 00:41:36.500
So that's Core Video.

00:41:36.610 --> 00:41:40.180
So we have a whole stack of
technologies we call Quartz at the

00:41:40.330 --> 00:41:42.200
core level of the operating system.

00:41:42.230 --> 00:41:45.300
And we think it's a great substrate
for you guys to build apps on.

00:41:45.320 --> 00:41:47.760
And I'm going to show you
Quartz Composer one more time.

00:41:47.760 --> 00:41:49.860
I had a quick demo of it before.

00:41:49.860 --> 00:41:52.560
I spent a little bit
more time on it here.

00:41:52.610 --> 00:41:55.720
Quartz Composer is an application
that harnesses the power of the

00:41:55.870 --> 00:42:00.100
Quartz layer using Core Graphics,
OpenGL, Core Video,

00:42:00.100 --> 00:42:02.700
and all of the technologies.

00:42:02.800 --> 00:42:05.830
Compositions can be saved in files,
kind of like-- you can

00:42:05.840 --> 00:42:06.980
think of them as meta files.

00:42:06.980 --> 00:42:11.220
And they can have OpenGL, info,
Core Graphics, et cetera.

00:42:11.220 --> 00:42:13.880
And there's a simple playback
API that's a framework.

00:42:13.880 --> 00:42:15.680
The engine's built into the OS.

00:42:15.700 --> 00:42:18.140
So you can load a
composition and play it.

00:42:18.140 --> 00:42:19.810
And it creates a procedural animation.

00:42:19.820 --> 00:42:24.060
You can actually expose the variables
outside of your animation to the

00:42:24.160 --> 00:42:27.890
key value coding system in Cocoa and
set parameters like images or

00:42:27.980 --> 00:42:30.320
text strings into the animation.

00:42:30.320 --> 00:42:34.950
So let me give you a demo
of that real quick here.

00:42:45.100 --> 00:42:51.200
[Transcript missing]

00:42:52.730 --> 00:43:01.060
nd I'm going to show you a
couple of things this time

00:43:01.060 --> 00:43:05.170
that I didn't show last time,
like masks, slideshows, kind of neat.

00:43:07.920 --> 00:43:10.950
Basically, it takes some of the images
from the screen saver and

00:43:11.020 --> 00:43:12.720
puts them through a mask.

00:43:12.720 --> 00:43:18.760
It generates a mask with OpenGL and then
does a blit using the graphics hardware.

00:43:18.760 --> 00:43:21.960
I think this one pretty
much is straight up OpenGL.

00:43:21.960 --> 00:43:25.110
It doesn't use any core image,
just uses blending modes in the hardware.

00:43:25.120 --> 00:43:29.640
So that one's, that's pretty interesting.

00:43:33.800 --> 00:43:39.490
Let me switch back to Finder
and show you Distortion FX.

00:43:42.360 --> 00:43:44.650
Distortion FX is an interesting one.

00:43:44.800 --> 00:43:48.800
So here's something you hadn't seen
before with the other composer demo.

00:43:48.860 --> 00:43:52.400
It says drag and drop an input
file into the input parameters.

00:43:52.440 --> 00:43:56.160
And so what this composition
does is it's all this wiring and

00:43:56.160 --> 00:43:59.300
in the details of the plumbing,
but it exposes two variables,

00:43:59.300 --> 00:44:00.980
an image and a duration.

00:44:00.990 --> 00:44:02.480
And so it's waiting for input.

00:44:02.480 --> 00:44:07.360
And so let's drag Copenhagen,
just an image of Copenhagen Harbor there.

00:44:07.490 --> 00:44:12.100
And let's look at that full screen.

00:44:12.180 --> 00:44:15.160
It's using some core image effects,
the optile and the bump

00:44:15.300 --> 00:44:17.010
distortion to do that.

00:44:17.200 --> 00:44:19.350
So you can see how if you
had an application and you

00:44:19.360 --> 00:44:21.960
wanted to do that to an image,
you could just actually create

00:44:21.960 --> 00:44:25.380
a Quartz Composer composition,
load it up, and then just key value

00:44:25.420 --> 00:44:29.440
those couple of variables,
and you've got it going.

00:44:29.460 --> 00:44:36.180
So to drive that home a little bit more,
let me show you...

00:44:36.430 --> 00:44:41.290
Another one we have, which is a,
we have engrave your iPods, well,

00:44:41.350 --> 00:44:43.440
we have engrave your G5, so.

00:44:43.440 --> 00:44:46.660
Let's look at the input.

00:44:47.050 --> 00:44:54.660
I'll show it to you down here, I can say,
Peter's G5.

00:44:55.240 --> 00:44:56.200
And you can see it now.

00:44:56.200 --> 00:44:57.440
It says Peter's G5.

00:44:57.440 --> 00:44:58.900
You can't really see it too well.

00:44:58.900 --> 00:45:03.360
So let's actually build an app
based out of this composition.

00:45:03.420 --> 00:45:04.680
So I actually have a nib file.

00:45:04.680 --> 00:45:06.660
There's a nib file in the
example directory there.

00:45:06.710 --> 00:45:07.550
You can see.

00:45:07.560 --> 00:45:11.340
And we have a palette,
the Quartz Composer palette,

00:45:11.340 --> 00:45:13.180
which is one of these, I think.

00:45:13.180 --> 00:45:14.490
There it is.

00:45:14.500 --> 00:45:18.600
Which has a controller,
which is the green thing, and a view,

00:45:18.690 --> 00:45:20.500
which is the Quartz Composer view.

00:45:20.500 --> 00:45:23.970
And what's happening is I have a
patch controller that I brought

00:45:23.970 --> 00:45:28.190
into my project down here,
which is controlling the patch,

00:45:28.190 --> 00:45:29.520
the G5 engraving patch.

00:45:29.520 --> 00:45:30.800
And I have a view.

00:45:30.810 --> 00:45:34.810
And if we look at the
parameters on the view,

00:45:35.970 --> 00:45:39.580
By bringing up the inspector,
I'll look at the bindings.

00:45:39.600 --> 00:45:44.940
You can see that the view is
bound to the patch controller,

00:45:44.940 --> 00:45:46.900
which is this guy here
who's controlling the patch.

00:45:46.900 --> 00:45:51.510
Now, if I look at this text field,
its value--

00:45:52.020 --> 00:45:55.900
The mouse is a little twitchy,
sorry about that.

00:45:55.900 --> 00:46:00.640
The value of the text field is
bound to the patch and to a variable

00:46:01.010 --> 00:46:05.700
in the patch called text.value,
which is that thing that was

00:46:05.700 --> 00:46:07.780
exported in the composer.

00:46:08.040 --> 00:46:12.800
So now, if I run this,
I have a simple application

00:46:13.290 --> 00:46:18.900
and if I can just type in this
text field and say Peters G5,

00:46:20.400 --> 00:46:22.410
Let's see, I can label my own G5.

00:46:22.540 --> 00:46:25.960
So you see it's pretty easy to go
into Quartz Composer and create a

00:46:26.000 --> 00:46:30.000
procedural definition of either an
animation or a still thing like this

00:46:30.000 --> 00:46:33.470
and then just wire it up and drive
data into it with Cocoa Binding.

00:46:33.470 --> 00:46:37.480
So we think that's kind of a pretty
powerful integration technology there.

00:46:45.350 --> 00:46:48.810
So back to slides.

00:46:49.180 --> 00:46:52.190
So we're going to have a session
on the Quartz Composer called

00:46:52.200 --> 00:46:53.800
Discovering the Quartz Composer.

00:46:53.880 --> 00:46:56.140
It's 9:00 AM on Friday.

00:46:56.430 --> 00:47:00.240
But if you want to stop by the hands-on
lab and get going with this stuff,

00:47:00.410 --> 00:47:03.800
tomorrow morning a bunch of us are going
to be in there to help you with that,

00:47:03.800 --> 00:47:07.900
if you want to just look at the examples
and get up and running on the tool.

00:47:07.960 --> 00:47:10.370
So anyway,
so that's our platform of all the

00:47:10.380 --> 00:47:11.820
new stuff we're doing in Quartz.

00:47:11.820 --> 00:47:13.600
And I just highlighted
a lot of the new stuff.

00:47:13.680 --> 00:47:14.620
There's tons of sessions.

00:47:14.620 --> 00:47:18.800
I think there's about 15 sessions
just on the graphics side of stuff

00:47:19.310 --> 00:47:22.400
that you want to talk and a bunch
more on the QuickTime and audio stuff.

00:47:22.620 --> 00:47:25.020
So have a great conference.

00:47:25.040 --> 00:47:27.620
And we will see you at the sessions.

00:47:27.620 --> 00:47:29.480
And back to Tim.

00:47:35.760 --> 00:47:37.460
Thanks a lot, Peter.

00:47:37.490 --> 00:47:40.410
OK, so we've covered audio,
we've covered graphics,

00:47:40.470 --> 00:47:45.160
now it's time for the video stuff,
and of course that means QuickTime.

00:47:45.200 --> 00:47:48.750
This year I'm not going to spend any time
at all talking about marketing stuff.

00:47:48.870 --> 00:47:51.960
We've got a tremendous amount
of good news to share with you,

00:47:51.960 --> 00:47:55.470
but tomorrow morning Frank Casanova
and his team are going to put on

00:47:55.470 --> 00:47:59.200
a big extravaganza here talking
about what's going on with the

00:47:59.200 --> 00:48:01.550
marketing side of QuickTime,
the business side,

00:48:01.600 --> 00:48:03.920
how we're doing out in the marketplace.

00:48:03.970 --> 00:48:05.420
Fantastic story.

00:48:05.440 --> 00:48:08.180
Going to tell you an awful
lot about our 3G strategy,

00:48:08.180 --> 00:48:10.840
which is a tremendous
success in the marketplace.

00:48:10.840 --> 00:48:16.070
We have by far the best system for
supporting mobile media in the world.

00:48:16.080 --> 00:48:18.960
We support all the global
standards at this point,

00:48:18.960 --> 00:48:23.760
and we've got just a fantastic end-to-end
story and I think you'll like it.

00:48:23.760 --> 00:48:28.620
We're going to focus today on
the technical side of QuickTime.

00:48:28.650 --> 00:48:32.070
This is the architecture
of QuickTime circa 1995,

00:48:32.070 --> 00:48:35.140
obviously very simplified,
but the basic point here is that--

00:48:35.140 --> 00:48:40.380
QuickTime is a very modular,
very componentized architecture,

00:48:40.380 --> 00:48:44.650
but the components tend to be
oriented towards supporting QuickTime,

00:48:44.770 --> 00:48:46.960
so they're kind of inwardly focused.

00:48:46.960 --> 00:48:49.930
We had video processing components,
we have audio processing components,

00:48:49.930 --> 00:48:52.160
and all of that was layered
on top of QuickDraw and on

00:48:52.190 --> 00:48:53.410
top of the sound manager.

00:48:55.020 --> 00:49:00.720
If we spin forward to look at what
we're doing in Tiger this year,

00:49:00.720 --> 00:49:03.390
you're going to see some
dramatic changes taking place

00:49:03.390 --> 00:49:05.870
down in the core of QuickTime.

00:49:05.880 --> 00:49:08.330
And we're going to be layering
QuickTime on top of Quartz,

00:49:08.350 --> 00:49:10.440
we're going to be putting
it on top of Core Audio,

00:49:10.440 --> 00:49:12.520
and there's going to be some
tremendous features here.

00:49:12.520 --> 00:49:15.350
We're going to take advantage
of all these technologies,

00:49:15.350 --> 00:49:19.420
and I think you're going to really enjoy
what starts to happen with QuickTime.

00:49:20.300 --> 00:49:23.930
Today I'm going to talk about
four details that were four very,

00:49:23.930 --> 00:49:28.290
very important happenings in the world
of QuickTime that I think are going to

00:49:28.290 --> 00:49:32.420
have profound impact on your applications
and on the ways that QuickTime starts

00:49:32.560 --> 00:49:34.260
to proliferate around the world.

00:49:34.280 --> 00:49:37.780
So the first thing I want
to talk about is H.264.

00:49:37.780 --> 00:49:39.380
You saw some demos of this earlier.

00:49:39.380 --> 00:49:41.720
Let's look at what this is really about.

00:49:41.720 --> 00:49:43.770
So you all know what MPEG is.

00:49:43.770 --> 00:49:47.220
These are the guys who make DVDs,
digital TV.

00:49:47.220 --> 00:49:49.940
It's actually this compression.

00:49:50.000 --> 00:49:52.620
It's actually a collaborative
effort between MPEG and a

00:49:52.620 --> 00:49:56.500
lesser-known organization called ITU,
the International Telecommunications

00:49:56.590 --> 00:49:57.120
Union.

00:49:57.120 --> 00:50:05.180
These are the guys who back in the 1860s,
the 1860s, first set up interoperability,

00:50:05.180 --> 00:50:09.910
an interoperability organization to
ensure that people would be able to

00:50:09.910 --> 00:50:12.790
telegraph across national boundaries.

00:50:12.800 --> 00:50:15.520
They then applied that
kind of mindset to radio,

00:50:15.640 --> 00:50:18.870
and more recently they do
it with telecommunications.

00:50:18.880 --> 00:50:19.880
And they're really wonderful.

00:50:19.980 --> 00:50:22.300
They're one of the premier
organizations for advanced

00:50:22.300 --> 00:50:26.380
technology in the area of compression
as it applies to communications.

00:50:26.380 --> 00:50:29.340
The goal is very simple.

00:50:29.340 --> 00:50:31.380
Build the best codec
that anybody's ever seen.

00:50:31.380 --> 00:50:33.570
It supports a lot of different modes.

00:50:33.570 --> 00:50:35.120
We'll talk about that
some more in a second.

00:50:35.120 --> 00:50:37.720
What you may not know is that
Apple's been involved in this

00:50:37.760 --> 00:50:40.280
standard for a long time,
and we've actually got a whole

00:50:40.280 --> 00:50:43.360
bunch of patented technology built
into the core of the standard.

00:50:43.360 --> 00:50:45.810
And the format is built on
the QuickTime file format,

00:50:45.810 --> 00:50:47.660
of course, so that's a great thing.

00:50:47.660 --> 00:50:53.740
Here's a little bit of a... a timeline
chart showing you kind of how the video

00:50:53.740 --> 00:50:56.810
compression efficiency story has evolved.

00:50:56.980 --> 00:51:00.090
The upper line shows you
the story for MPEG-2,

00:51:00.250 --> 00:51:02.180
and the lower lines are showing
you what's been happening with

00:51:02.270 --> 00:51:03.430
some of the more modern codecs.

00:51:03.480 --> 00:51:06.980
And the orange piece, obviously,
is the 264.

00:51:06.980 --> 00:51:08.480
A couple things to notice.

00:51:08.480 --> 00:51:11.980
We learned an awful lot about video
compression over the last 10 years.

00:51:12.190 --> 00:51:15.950
And a lot of that was able to be
played out in the MPEG-2 standard.

00:51:16.040 --> 00:51:18.880
So even though the standard
was established in 1994,

00:51:19.010 --> 00:51:19.820
So even though the standard
was established in 1994,

00:51:19.820 --> 00:51:22.640
for the next 10 years,
we saw dramatic improvements

00:51:22.640 --> 00:51:25.820
in the efficiencies of MPEG-2.

00:51:25.920 --> 00:51:29.820
So you sometimes hear a story which says,
"Well, your codec isn't good enough.

00:51:29.820 --> 00:51:32.440
You don't have the right standard."
The thing you gotta separate

00:51:32.440 --> 00:51:35.820
out here is the politics from
the reality of the technologies.

00:51:36.000 --> 00:51:38.640
And what we know is that with
each successive generation

00:51:38.640 --> 00:51:41.340
of these technologies,
there are an incredible number

00:51:41.470 --> 00:51:44.190
of tools that are built into
these little algorithms that we

00:51:44.220 --> 00:51:45.700
all have to learn how to use.

00:51:45.830 --> 00:51:49.260
And this shows you,
in a very graphic way, what happened with

00:51:49.270 --> 00:51:49.660
MPEG over the last 10 years.

00:51:49.660 --> 00:51:50.660
I mean, this is dramatic.

00:51:50.660 --> 00:51:55.710
They went from almost 6 megabits
down to just under 2 megabits to

00:51:55.920 --> 00:51:56.660
achieve the same level of quality.

00:51:56.660 --> 00:52:00.760
And what we're gonna
see with MPEG-4 Part 10,

00:52:00.770 --> 00:52:03.660
H.264, ABC,
it goes by a billion different names.

00:52:03.660 --> 00:52:06.180
We're gonna see, again,
a continuing evolution as we

00:52:06.200 --> 00:52:07.660
learn how to use this codec.

00:52:07.660 --> 00:52:10.570
Let me give an example of the kinds
of stuff that we're working through.

00:52:10.660 --> 00:52:12.660
So this is MPEG-4 Part 2.

00:52:12.660 --> 00:52:16.660
This is the version of MPEG-4
that we ship in QuickTime 6 today.

00:52:16.820 --> 00:52:19.500
That we've distributed literally hundreds
and hundreds of millions of copies of.

00:52:19.500 --> 00:52:25.590
This is sort of a summary of the various
algorithms that are combined together to

00:52:25.590 --> 00:52:27.430
create the overall compression effect.

00:52:27.560 --> 00:52:32.380
H.264 offers this vocabulary of tools.

00:52:32.500 --> 00:52:36.500
So you might imagine that a software
developer trying to build these kinds

00:52:36.500 --> 00:52:40.500
of technologies is gonna take quite a
while to learn how to use them optimally.

00:52:40.500 --> 00:52:42.450
We've been working on
this for a long time.

00:52:42.510 --> 00:52:45.500
We think we have a fantastic
implementation already.

00:52:45.500 --> 00:52:49.340
But it's gonna get a whole
lot better as the years go on.

00:52:49.340 --> 00:52:51.340
So we're really, really excited about it.

00:52:51.340 --> 00:52:54.340
What I want to show you now... Oops.

00:52:54.340 --> 00:52:55.280
Nope.

00:52:55.390 --> 00:52:56.340
There we go.

00:52:56.340 --> 00:52:58.040
I'll show you a little demo
of something we've never been

00:52:58.040 --> 00:52:59.340
able to do in QuickTime before.

00:52:59.380 --> 00:53:02.760
And I'm gonna do it in H.264,
which you would think would

00:53:02.760 --> 00:53:04.340
be the hardest place to do it.

00:53:04.550 --> 00:53:09.340
We've been talking about
high-def content a lot today.

00:53:09.340 --> 00:53:14.050
And as you can tell, Apple's very,
very interested in high def.

00:53:14.340 --> 00:53:19.180
We have... We can support high def
at the standard for a long time.

00:53:19.320 --> 00:53:22.180
We can do it at frame rates--30 frames,
24 frames per second.

00:53:22.180 --> 00:53:25.130
We can do amazing things
with large frame sizes.

00:53:25.230 --> 00:53:30.180
But there's another flavor of high
def that's often referred to as 60p.

00:53:30.200 --> 00:53:32.150
And this is actually
60 frames per second.

00:53:32.230 --> 00:53:35.990
I'm gonna show you a little
demo of QuickTime playing this

00:53:35.990 --> 00:53:42.310
content... at 60 frames per second.

00:53:42.940 --> 00:53:44.300
First thing you notice,
I pulled down the menu

00:53:44.300 --> 00:53:45.060
and it didn't stutter.

00:53:45.060 --> 00:53:46.650
Pretty good.

00:53:46.980 --> 00:53:47.220
Pretty good.

00:53:47.400 --> 00:53:50.240
Now, so, what's interesting here,
this is, you know,

00:53:50.240 --> 00:53:53.180
the video itself's not terribly dramatic.

00:53:53.180 --> 00:53:55.500
You saw a different
clip of it this morning,

00:53:55.560 --> 00:53:58.420
but it's playing at 60
full frames per second.

00:53:58.420 --> 00:54:01.440
Now, you would think, well, this is,
yeah, this is a computational problem.

00:54:01.440 --> 00:54:02.960
You've got a really fast computer.

00:54:02.960 --> 00:54:07.060
Actually, it's not that heavy duty
of a compute problem.

00:54:07.060 --> 00:54:11.570
We're not using that much of the CPU,
but what the problem has always been,

00:54:12.070 --> 00:54:15.070
has been that, you know,
you can't get the frames to the card

00:54:15.160 --> 00:54:17.450
fast enough to be able to keep up.

00:54:17.960 --> 00:54:22.000
Because of the fact that we're now
layering QuickTime on top of Core Video,

00:54:22.000 --> 00:54:25.050
we're able to do this perfectly.

00:54:25.050 --> 00:54:30.440
So, Core Video combined with QuickTime is
not only providing us access to these

00:54:30.720 --> 00:54:35.250
amazing image processing capabilities
that are built into the GPU,

00:54:35.380 --> 00:54:39.350
it's also providing some
absolutely outrageous abilities

00:54:39.350 --> 00:54:42.780
to transfer data over to the card,
which is obviously the other

00:54:42.780 --> 00:54:42.780
thing that we're able to do.

00:54:42.800 --> 00:54:44.060
So, that's another half of the problem.

00:54:44.130 --> 00:54:45.600
If you can't get the stuff
to the card fast enough,

00:54:45.670 --> 00:54:47.360
you're not going to be able
to do anything with it.

00:54:47.420 --> 00:54:53.150
We're working with the Core Video guys as
well to come up with very highly optimal

00:54:53.150 --> 00:54:55.860
methods for pulling the data back.

00:54:55.940 --> 00:54:58.250
If you can't pull it back out,
then you're not really going

00:54:58.260 --> 00:55:00.360
to be able to get it out,
firewire it to your cameras,

00:55:00.410 --> 00:55:02.670
or wherever else you want
to go very effectively.

00:55:02.680 --> 00:55:05.030
And so, we're working on a lot
of problems in this area,

00:55:05.120 --> 00:55:08.140
and it's very exciting that we're
relayering this stuff the way we are.

00:55:08.140 --> 00:55:12.490
So, that's QuickTime playing 60p content,
something that's going to be

00:55:12.500 --> 00:55:12.780
able to do a lot of things.

00:55:12.990 --> 00:55:15.400
we've never seen before.

00:55:18.170 --> 00:55:20.130
Peter referred to this session earlier.

00:55:20.130 --> 00:55:23.280
There's a whole bunch of
information available about what

00:55:23.280 --> 00:55:25.480
we're doing in the area of 264.

00:55:25.480 --> 00:55:29.080
In particular, the underlying format
is outrageously complex,

00:55:29.180 --> 00:55:32.860
and we're introducing some new
capabilities in QuickTime to be able

00:55:32.860 --> 00:55:36.780
to manipulate these formats in the
ways you're accustomed to being able

00:55:36.780 --> 00:55:41.090
to manipulate video today in QuickTime,
even though when you learn the facts,

00:55:41.350 --> 00:55:45.000
you would think it would be
impossible to edit this stuff ever.

00:55:45.320 --> 00:55:48.960
And we're going to make it very,
very easy so that your applications have

00:55:49.150 --> 00:55:52.960
no changes in the vast majority of cases,
and if you do extremely

00:55:52.960 --> 00:55:55.960
sophisticated stuff,
you'll have to make a few changes,

00:55:55.960 --> 00:55:57.600
and it's going to be very exciting.

00:56:01.050 --> 00:56:02.880
Okay,
so the next thing I want to talk about

00:56:02.950 --> 00:56:06.530
is some of the specifics about what
happens when you put QuickTime on

00:56:06.530 --> 00:56:08.000
top of these Quartz technologies.

00:56:08.030 --> 00:56:10.930
I showed you some data transfer
optimizations that are pretty

00:56:11.020 --> 00:56:13.300
exciting for a bunch of people
who are focused on video.

00:56:13.340 --> 00:56:16.230
Let me show you some other things
that we can do now that are very cool.

00:56:16.480 --> 00:56:18.910
Now, I'm not going to,
I don't have slides with words.

00:56:18.940 --> 00:56:22.310
I think the demo will say it all.

00:56:25.500 --> 00:56:27.660
Here we go.

00:56:27.660 --> 00:56:33.380
This is a little test app that we
developed in the last couple of days.

00:56:33.410 --> 00:56:35.320
That's another very important point.

00:56:35.330 --> 00:56:39.400
This stuff has gotten so easy
to program because we're really

00:56:39.400 --> 00:56:40.580
working all in Cocoa now.

00:56:40.580 --> 00:56:43.720
And it's just, it's amazing how fast
these things come together.

00:56:43.760 --> 00:56:46.490
And you're not really making,
you're not making performance

00:56:46.490 --> 00:56:49.160
compromises by going down the easy path.

00:56:49.210 --> 00:56:51.140
It's incredibly important.

00:56:51.210 --> 00:56:55.000
So here we have a video, iRobot trailer.

00:56:55.510 --> 00:56:59.560
And the first thing you'll see-- OK,
I'll turn the volume

00:56:59.560 --> 00:57:01.470
down just a little bit.

00:57:01.690 --> 00:57:04.030
The first thing that you can
see is it's just like a lot of

00:57:04.030 --> 00:57:05.640
the apps that we're making now.

00:57:05.660 --> 00:57:07.670
Live resize.

00:57:07.950 --> 00:57:11.480
Very smooth, moves like butter.

00:57:11.690 --> 00:57:14.380
But there's a lot more going
on here than meets the eye.

00:57:14.380 --> 00:57:18.980
So I'm going to zoom back
from the video a little bit,

00:57:18.980 --> 00:57:21.520
and what you can see is I can just
grab this video and move it around.

00:57:21.520 --> 00:57:24.260
Again, I'm not losing frames
or anything like that.

00:57:24.330 --> 00:57:25.190
That's kind of neat.

00:57:25.200 --> 00:57:28.030
What you can also see is that
actually what we're doing is we're

00:57:28.030 --> 00:57:29.550
playing video onto a surface.

00:57:29.620 --> 00:57:33.010
Okay, well that's...

00:57:34.420 --> 00:57:35.860
That's pretty cool.

00:57:35.900 --> 00:57:39.350
This is sort of the infamous, gee,
if I could only play to a GL surface,

00:57:39.450 --> 00:57:41.100
then I could do all these
wild and crazy things.

00:57:41.100 --> 00:57:43.360
But that's always been
virtually impossible.

00:57:43.360 --> 00:57:46.110
We've made that really,
really simple now.

00:57:46.120 --> 00:57:49.250
So the next thing we're going
to do is we'll just do a little

00:57:49.250 --> 00:57:50.860
fade back here to normal.

00:57:50.860 --> 00:57:53.880
And I'm going to show you,
we built some presets into the

00:57:53.880 --> 00:57:58.180
application to allow me to talk and
make things change at the same time.

00:57:58.180 --> 00:58:00.360
And let me show you a couple of them.

00:58:00.360 --> 00:58:02.580
So this first one is just going to
take the video and we're going to

00:58:02.580 --> 00:58:04.000
just slide it down into the corner.

00:58:04.720 --> 00:58:06.170
Now,

00:58:06.410 --> 00:58:09.440
We have all these frames flying
through Quartz Video and we want

00:58:09.440 --> 00:58:11.740
to be able to kind of visualize
what that might look like.

00:58:11.800 --> 00:58:14.360
So we built this groovy...

00:58:14.790 --> 00:58:20.520
Oops, groovy little feature to
let me spit the frames out.

00:58:21.430 --> 00:58:22.290
Now, let me show you.

00:58:22.300 --> 00:58:23.960
This is not, like, rendered.

00:58:23.960 --> 00:58:24.760
It's not faked up.

00:58:24.840 --> 00:58:26.010
I mean, this is all live.

00:58:26.060 --> 00:58:26.760
This is live.

00:58:26.760 --> 00:58:31.580
I can do all the same kind of 3D
stuff that we were doing when it

00:58:31.660 --> 00:58:33.540
was just on the single surface.

00:58:33.640 --> 00:58:34.800
Let me go back to normal.

00:58:34.850 --> 00:58:37.700
So we do an animated-- We can
do a little slow-mo thing,

00:58:37.700 --> 00:58:41.330
'cause it's just the way
these things have to work.

00:58:43.990 --> 00:58:45.090
So we've got another one here.

00:58:45.250 --> 00:58:47.380
This one will take it and put
it over in the other corner.

00:58:47.380 --> 00:58:49.840
So now the frames are
coming back out this way.

00:58:49.840 --> 00:58:53.340
You know,
that's kind of fun to go back and forth.

00:58:53.340 --> 00:58:56.970
We've got another little effect
we can do here where we just start

00:58:56.970 --> 00:58:59.190
taking the frames and twirling them.

00:58:59.190 --> 00:59:00.540
That's kind of fun.

00:59:01.640 --> 00:59:03.380
This is one I always wanted to see.

00:59:03.380 --> 00:59:06.080
It's sort of our matrix effect here.

00:59:06.080 --> 00:59:07.610
We'll take the video.

00:59:07.610 --> 00:59:10.360
I'll put it back in the
straight-ahead mode.

00:59:10.360 --> 00:59:12.680
So now we're looking into the frames.

00:59:12.680 --> 00:59:14.290
We can zoom back it out.

00:59:15.010 --> 00:59:16.290
It's kind of cool.

00:59:16.290 --> 00:59:17.940
And then we can go back.

00:59:18.010 --> 00:59:19.560
Go back to normal.

00:59:19.690 --> 00:59:23.820
So this is obviously a very small example
of the kinds of things that you're going

00:59:23.820 --> 00:59:31.660
to be able to do with QuickTime layered
on top of the Quartz technology.

00:59:34.200 --> 00:59:35.390
It's really fun.

00:59:35.420 --> 00:59:38.700
It's really fun.

00:59:38.770 --> 00:59:40.160
So that's QuickTime on Quartz.

00:59:40.190 --> 00:59:44.690
Whoops,
I'm going the wrong way in the world.

00:59:51.580 --> 00:59:52.500
Thank you.

00:59:52.500 --> 00:59:53.500
Okay, QuickTime and Core Audio.

00:59:53.570 --> 00:59:57.340
So we've been talking a lot about
QuickTime on the image stack side.

00:59:57.340 --> 00:59:59.230
Talk a little bit more
about what's happening with

00:59:59.230 --> 01:00:00.460
QuickTime on the audio side.

01:00:00.490 --> 01:00:07.490
So we've basically re-layered
QuickTime entirely on top of Core Audio.

01:00:07.490 --> 01:00:07.490
It has some very...

01:00:07.810 --> 01:00:08.890
Very obvious benefits.

01:00:08.960 --> 01:00:12.170
We're going to be able to support all
the same high-def audio formats that

01:00:12.240 --> 01:00:14.100
you can support in Core Audio today.

01:00:14.100 --> 01:00:16.080
We'll support including
surround audio formats.

01:00:16.200 --> 01:00:18.870
And when you go to some of the other
QuickTime sessions where they'll

01:00:18.870 --> 01:00:21.640
be talking about this in detail,
you'll see some amazing demos.

01:00:22.370 --> 01:00:28.290
This also has an incredibly important
but perhaps lesser known effect,

01:00:28.380 --> 01:00:31.080
which is that the quality of the
synchronization across tracks

01:00:31.080 --> 01:00:32.440
is going to be rock solid.

01:00:32.440 --> 01:00:34.930
We're going to be down to
sample level accuracy in the

01:00:35.020 --> 01:00:38.790
synchronization part of the system,
which is fantastically important.

01:00:38.800 --> 01:00:42.070
And you'll be able to leverage
the DSP capabilities that

01:00:42.150 --> 01:00:43.890
are present in audio units.

01:00:43.960 --> 01:00:46.330
So I think I have a little
demo of that as well.

01:00:46.360 --> 01:00:51.980
Yeah, okay,
so I showed you a very simple time scale.

01:00:52.000 --> 01:00:56.990
I showed you a very simple scaling
demo in the AU Lab application.

01:00:57.000 --> 01:01:01.820
I want to show you what you can
do with this applied to more

01:01:01.900 --> 01:01:03.320
of a real-world application.

01:01:03.390 --> 01:01:06.560
So we have a little movie here,
Harry Potter trailer.

01:01:06.660 --> 01:01:10.610
This is what happens when
you normally go fast forward.

01:01:13.000 --> 01:01:16.000
So you get the kind of chipmunk thing.

01:01:16.000 --> 01:01:20.900
Okay, well, that's cute,
but not a lot of fun.

01:01:24.550 --> 01:01:26.620
- Change the modes that
QuickTime's running in.

01:01:26.620 --> 01:01:28.680
Let me start the movie up again.

01:01:28.710 --> 01:01:30.180
This time, let's get it going.

01:01:30.180 --> 01:01:32.340
Now listen to what happens.

01:01:32.340 --> 01:01:35.460
- On page 394.

01:01:35.460 --> 01:01:38.770
- Is that working?

01:01:43.560 --> 01:01:46.130
You almost can't tell that it's been
sped up because you can actually

01:01:46.130 --> 01:01:48.270
understand what's happening now.

01:01:48.680 --> 01:01:53.270
So we've taken this one step further,
and we actually added

01:01:53.360 --> 01:01:54.890
a little menu in here.

01:01:55.130 --> 01:01:58.370
To be able to access the controls
a little bit more directly since

01:01:58.460 --> 01:02:01.830
the fast forward is sort of more
constrained and I can play it along.

01:02:01.840 --> 01:02:05.430
So now I've got the
ability to speed it up.

01:02:07.300 --> 01:02:14.500
[Transcript missing]

01:02:27.000 --> 01:02:42.800
[Transcript missing]

01:02:47.200 --> 01:02:54.380
Anyway, so you get the idea.

01:02:54.380 --> 01:02:59.100
You can modify the pitch and the tempo,
and we're going to try and come

01:02:59.160 --> 01:03:01.190
up with some clever ways to be
able to integrate this into more

01:03:01.190 --> 01:03:03.220
of the products that we build,
but we think it's a very

01:03:03.330 --> 01:03:05.730
interesting technology,
and I just wanted you to get a

01:03:05.780 --> 01:03:08.580
quick glimpse of what would be
possible as we start to leverage

01:03:08.630 --> 01:03:10.230
these inside of the whole stack.

01:03:11.060 --> 01:03:18.300
So, the last thing I want to talk
about is something we call QtKit.

01:03:18.530 --> 01:03:21.300
We have gotten a lot of
feedback about what it's like to

01:03:21.430 --> 01:03:26.300
program QuickTime on Mac OS X,
and I've heard loud and clear,

01:03:26.300 --> 01:03:27.490
"QuickTime's very hard to learn.

01:03:27.490 --> 01:03:29.000
There's 2,400 APIs.

01:03:29.000 --> 01:03:31.000
How am I ever supposed
to figure this out?

01:03:31.100 --> 01:03:33.190
You use data types that I don't like.

01:03:33.440 --> 01:03:34.800
I don't understand what they are.

01:03:34.800 --> 01:03:36.110
I don't want to have to create them.

01:03:36.310 --> 01:03:37.240
You're messing up my life.

01:03:37.420 --> 01:03:43.740
Why do I have to do this?" So,
I heard it.

01:03:44.750 --> 01:03:45.950
I've heard it.

01:03:46.330 --> 01:03:49.300
So I'm very,
very happy to report that we're

01:03:49.300 --> 01:03:52.890
introducing a whole new framework
to be able to work with QuickTime.

01:03:52.900 --> 01:03:55.550
And it's going to give you
a very rich set of services,

01:03:55.820 --> 01:03:59.190
but like a lot of the other services
that you find in the system these days,

01:03:59.200 --> 01:04:01.230
it's going to be really,
really straightforward to use,

01:04:01.640 --> 01:04:04.020
fantastic impedance match with Cocoa,
of course,

01:04:04.050 --> 01:04:06.880
and it's going to be able to take
advantage of all the other advancements

01:04:06.960 --> 01:04:08.200
we've been talking about today.

01:04:08.200 --> 01:04:10.480
It'll be able to be combined
with all the other toolkits,

01:04:10.480 --> 01:04:12.700
and you're going to be
able to do amazing things.

01:04:12.700 --> 01:04:16.200
To help me illustrate some of
the very basic elements of this,

01:04:16.200 --> 01:04:19.190
I want to ask...

01:04:19.430 --> 01:04:20.740
Oh, yep, there we go.

01:04:20.800 --> 01:04:24.300
Ask Tim Monroe to come up and
show you a very simple demo.

01:04:24.390 --> 01:04:28.740
Tim's one of the designers of QtKit,
and it's very cool.

01:04:28.780 --> 01:04:29.440
Hi, Tim.

01:04:29.490 --> 01:04:30.090
TIM MONROE: Hi.

01:04:30.100 --> 01:04:31.770
Thank you.

01:04:34.460 --> 01:04:36.490
So one of the first things
people ask when they get a

01:04:36.610 --> 01:04:38.900
new framework in Cocoa is,
what can I do for free?

01:04:38.900 --> 01:04:41.230
Show me the zero lines of code demo.

01:04:41.330 --> 01:04:43.800
And that's what I want
to show you here now.

01:04:44.000 --> 01:04:47.020
So what I'm going to do is to show,
to emphasize that there

01:04:47.020 --> 01:04:47.980
are zero lines of code.

01:04:48.350 --> 01:04:53.620
Actually,
first I'm going to clean up here.

01:04:53.620 --> 01:04:53.620
Okay.

01:04:54.550 --> 01:04:56.880
I'm going to do everything
inside of Interface Builder.

01:04:57.030 --> 01:04:58.950
So you can't write any
code in Interface Builder.

01:04:58.970 --> 01:05:02.130
So this will prove it.

01:05:02.200 --> 01:05:06.430
So here's a new palette for
the QuickTime movie view,

01:05:06.430 --> 01:05:09.900
the Qt movie view,
which is the central view

01:05:09.900 --> 01:05:11.860
aspect of the new kit.

01:05:12.890 --> 01:05:30.230
What I'm going to do is ask
for a new Cocoa application.

01:05:31.290 --> 01:05:31.290
So now I've just got a window here.

01:05:31.290 --> 01:05:31.290
And I will drag the palette
item into the window.

01:05:31.290 --> 01:05:31.290
And there you can see it already
looks a little bit like a movie.

01:05:31.290 --> 01:05:31.290
Let me resize this to fit the window.

01:05:32.160 --> 01:05:34.900
And then I want to set a
few attributes for this.

01:05:34.970 --> 01:05:40.350
First, I want to set the size so that
when I resize the movie window,

01:05:40.350 --> 01:05:44.060
the Qt Movie View will
resize automatically.

01:05:45.050 --> 01:05:47.800
And then let's look back
at the Attributes pane.

01:05:47.830 --> 01:05:51.230
You can see I've got sort of a
handful of things I can control here.

01:05:51.530 --> 01:05:54.040
I can show or hide the controller bar.

01:05:54.150 --> 01:05:57.060
I can make the movie
editable or not editable.

01:05:57.090 --> 01:06:00.000
And let's just stick it with that.

01:06:00.060 --> 01:06:06.260
The last thing I can do here is
attach a movie to this Qt Movie View.

01:06:06.580 --> 01:06:09.830
And I'm just going to
grab the Harry Potter.

01:06:10.690 --> 01:06:13.860
And now I can go ahead and run
this inside of Interface Builder.

01:06:14.110 --> 01:06:16.170
I'll test Interface.

01:06:16.210 --> 01:06:21.070
And I've got a QuickTime movie that
I can run with zero lines of code.

01:06:21.080 --> 01:06:24.770
This is using the
accelerated visual context.

01:06:24.870 --> 01:06:27.010
I've got all the goodies in Cocoa.

01:06:27.010 --> 01:06:29.180
Let me just illustrate that briefly.

01:06:29.180 --> 01:06:33.830
One thing you like to get with a view is
if I hold down the control key and click,

01:06:33.830 --> 01:06:35.490
I get a contextual menu.

01:06:35.640 --> 01:06:39.500
So we've got a nice contextual menu here
that allows me to control the movie.

01:06:41.030 --> 01:06:44.880
Another thing I can do here,
totally with zero lines of code,

01:06:44.890 --> 01:06:47.520
is make some selections.

01:06:49.140 --> 01:06:55.380
I can come up here and cut,
perhaps go over here and paste that.

01:06:55.410 --> 01:06:59.580
That was such a good section,
I'll paste it over here.

01:07:00.000 --> 01:07:02.980
Maybe I'll come in here and cut this out.

01:07:04.650 --> 01:07:08.630
And because we're built on top of Cocoa,
I can undo all of this

01:07:08.630 --> 01:07:10.060
up to the very top.

01:07:10.120 --> 01:07:13.140
I can undo the cut,
undo the second paste,

01:07:13.150 --> 01:07:16.590
undo the first paste,
undo the original cut,

01:07:16.670 --> 01:07:21.280
and now I'm back to where I can't undo
anymore because I'm back to the movie.

01:07:21.440 --> 01:07:23.030
Let me show you one more thing.

01:07:23.110 --> 01:07:24.440
I'll start it playing.

01:07:24.440 --> 01:07:27.350
And again, Tim sort of talked a
little bit about this,

01:07:27.350 --> 01:07:31.290
but I can resize this and you'll
notice that I'm getting full frame

01:07:31.290 --> 01:07:33.540
playback while I'm resizing it.

01:07:33.640 --> 01:07:37.950
So that's your basic live resizing
handled automatically for you

01:07:37.960 --> 01:07:40.000
by our new QtKit framework.

01:07:40.000 --> 01:07:42.100
And that's what I've got to show.

01:07:49.630 --> 01:07:50.970
Thank you.

01:07:51.130 --> 01:07:52.660
So that's really exciting.

01:07:52.660 --> 01:07:55.620
You know, this stuff is very powerful.

01:07:55.620 --> 01:07:59.280
We're actually building
QuickTime Player on top of QtKit now.

01:07:59.280 --> 01:08:01.810
So the QuickTime Player that's
in your seeds,

01:08:01.810 --> 01:08:05.190
in the developer seed that
we've handed out today,

01:08:05.190 --> 01:08:07.640
is actually built on top of QtKit.

01:08:07.640 --> 01:08:09.380
It's a very powerful toolkit.

01:08:09.900 --> 01:08:13.010
There's a session that will cover
this in great detail coming up on

01:08:13.010 --> 01:08:14.460
Thursday and you should check it out.

01:08:14.460 --> 01:08:15.170
It's very cool.

01:08:15.180 --> 01:08:19.280
So here are four really big
developments that we're making,

01:08:19.280 --> 01:08:21.400
advancements we're making in QuickTime.

01:08:21.400 --> 01:08:24.590
This is probably the most profound set
of changes we've made to QuickTime since

01:08:24.920 --> 01:08:26.820
it was introduced back in 1991.

01:08:26.820 --> 01:08:28.320
It's very, very exciting.

01:08:28.320 --> 01:08:30.690
We've got a whole new architecture.

01:08:30.840 --> 01:08:34.740
We're working very closely across
all the different layers within

01:08:34.990 --> 01:08:39.810
the team to be able to build
highly optimized implementations.

01:08:39.900 --> 01:08:42.540
We're working very closely across
all the different layers within

01:08:42.880 --> 01:08:45.750
the team to be able to build
highly optimized implementations.

01:08:45.870 --> 01:08:47.860
And so that's QuickTime.

01:08:47.930 --> 01:08:49.620
So we're just about at the end here.

01:08:49.620 --> 01:08:52.060
I wanted to tell you one reminder.

01:08:52.110 --> 01:08:53.780
There is this Graphics and Media Lab.

01:08:53.780 --> 01:08:56.780
It's a hands-on lab
running all week long.

01:08:56.780 --> 01:09:00.980
I'm not sure if you know where it is,
but it's downstairs in the back.

01:09:01.010 --> 01:09:04.850
And there's a lot of engineers
hanging out down there waiting to

01:09:04.920 --> 01:09:07.370
help you with your applications,
help you tune them,

01:09:07.430 --> 01:09:10.060
help you figure out how to do things,
tell you about the new stuff.

01:09:10.060 --> 01:09:14.080
And I hope you have a chance
to go down and see this.

01:09:14.800 --> 01:09:18.940
I told you at the beginning of the talk,
we wanted to focus on some very valuable

01:09:18.940 --> 01:09:22.550
technologies that would help you improve
the quality of your user interface,

01:09:22.590 --> 01:09:25.500
would help you unlock
some amazing performance,

01:09:25.500 --> 01:09:29.100
and would help you build
applications and tools that were

01:09:29.100 --> 01:09:30.320
going to stand the test of time.

01:09:30.320 --> 01:09:32.830
And I hope you can see
that with this stack,

01:09:32.930 --> 01:09:36.830
QuickTime, Quartz, OpenGL,
on top of the great Apple hardware,

01:09:36.830 --> 01:09:40.340
we think we've got a great
platform for innovation here.

01:09:40.340 --> 01:09:42.540
And I just want to say thanks.

01:09:42.540 --> 01:09:43.830
I hope you have a great time with it.

01:09:44.360 --> 01:09:46.220
Thank you.
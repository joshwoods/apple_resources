WEBVTT

00:00:12.260 --> 00:00:17.380
Today we're going to talk about how
to move your application to Unicode.

00:00:19.600 --> 00:02:08.500
[Transcript missing]

00:02:10.040 --> 00:02:14.550
So today we're going to cover in detail
what's required to move your world

00:02:14.590 --> 00:02:18.300
script based application to Unicode.

00:02:18.300 --> 00:02:23.230
And we're going to do a lightening tour
of all the aspects of an application,

00:02:23.230 --> 00:02:28.850
how to store text, your human interface
and your localization,

00:02:28.850 --> 00:02:34.310
drawing, editing, and input, sorting,
doing transformations on

00:02:34.310 --> 00:02:37.290
text and analyzing it,
and also formatting

00:02:37.290 --> 00:02:40.120
and scanning of dates,
times, and numbers,

00:02:40.180 --> 00:02:42.300
and also calendar manipulations.

00:02:42.320 --> 00:02:47.200
So we're not going to go into
incredible detail on any of those areas,

00:02:47.200 --> 00:02:51.480
but to sort of give you a tour
so you know which APIs to use to

00:02:51.760 --> 00:02:54.860
convert your application to Unicode.

00:02:57.360 --> 00:03:00.840
And all of the APIs we're going to
talk about today are in the core

00:03:00.840 --> 00:03:05.220
foundation and Carbon areas of Mac OS X.

00:03:05.220 --> 00:03:08.130
And we're going to show how to
map from the older technologies,

00:03:08.130 --> 00:03:13.490
the Script Manager, text utilities,
and so on, to these newer APIs.

00:03:15.420 --> 00:03:18.610
But before we do that,
I'd like to just spend a couple of

00:03:18.610 --> 00:03:22.560
slides talking about what's new in
Tiger in the international area.

00:03:22.560 --> 00:03:24.900
And we do have some new features.

00:03:24.900 --> 00:03:28.340
And the first one is something
that people have been

00:03:28.340 --> 00:03:30.280
asking for for a long time.

00:03:30.280 --> 00:03:33.530
In Tiger,
we have the first stage of our support

00:03:33.530 --> 00:03:36.060
for OpenType font layout tables.

00:03:36.800 --> 00:03:43.300
So this allows OpenType fonts
to work in Unicode applications.

00:03:43.300 --> 00:03:45.900
If you're using our
standard Unicode APIs,

00:03:46.000 --> 00:03:48.340
you don't have to do anything
special in your application.

00:03:48.340 --> 00:03:50.370
OpenType fonts will just work.

00:03:50.380 --> 00:03:53.930
So we're supporting features
like ligatures and language

00:03:54.360 --> 00:03:56.140
shaping in certain cases.

00:03:56.140 --> 00:04:01.030
And you'll see the support
for OpenType layout increase

00:04:01.060 --> 00:04:03.870
more and more as time goes on.

00:04:05.870 --> 00:04:08.510
Something that was missing
from our Unicode API suite

00:04:08.510 --> 00:04:10.170
was string transliteration.

00:04:10.280 --> 00:04:12.000
This is something you could
do in the Script Manager.

00:04:12.000 --> 00:04:13.990
There was an API in the
text utilities to do it,

00:04:14.070 --> 00:04:18.460
but there was no Unicode equivalent,
and we've now got that in Tiger.

00:04:21.080 --> 00:04:24.960
We have even more locale data available,
and as with Panther,

00:04:24.960 --> 00:04:28.940
much of that locale data is only
available through Unicode APIs.

00:04:28.940 --> 00:04:33.100
So it's very important to move your
application to Unicode so you can take

00:04:33.100 --> 00:04:37.010
advantage of all the languages and all
the locales that Mac OS X supports.

00:04:39.630 --> 00:04:42.300
Just as a side note,
this is a Carbon session,

00:04:42.300 --> 00:04:45.500
but there has been a Carbon date
control for a long time,

00:04:45.500 --> 00:04:49.600
and new in Tiger is
equivalent Cocoa date control,

00:04:49.600 --> 00:04:51.590
so that's available.

00:04:53.290 --> 00:04:56.840
We had some support for
non-Gregorian calendars in Panther,

00:04:56.840 --> 00:04:59.800
and we're improving
that support in Tiger.

00:04:59.800 --> 00:05:04.230
So in addition to the Japanese and
Thai Buddhist calendars,

00:05:04.230 --> 00:05:07.830
which we had in Panther,
we're adding Islamic and

00:05:07.890 --> 00:05:09.380
Hebrew calendar support.

00:05:09.380 --> 00:05:12.670
And in addition, in Panther,
you could only use one of the

00:05:12.670 --> 00:05:16.560
non-Gregorian calendars if you
were using the date and time

00:05:16.560 --> 00:05:18.580
formats that went with it.

00:05:18.580 --> 00:05:21.310
So for example,
you could only use the Japanese calendar

00:05:21.310 --> 00:05:23.750
with the Japanese locale or
the Thai Buddhist calendar

00:05:23.760 --> 00:05:24.710
with the Thai locale.

00:05:24.720 --> 00:05:29.980
In Tiger, you can select the calendar
separately from the date/time formats.

00:05:29.980 --> 00:05:33.490
So here you see examples
of the Islamic calendar

00:05:33.850 --> 00:05:36.340
and the Japanese calendar
being used with the U.S.

00:05:36.370 --> 00:05:37.270
English locale.

00:05:44.140 --> 00:05:48.070
We've also added more control
over number and date formatting.

00:05:48.210 --> 00:05:52.540
So we introduced CFDate Formatter
and CFNumber Formatter in Panther,

00:05:52.570 --> 00:05:55.160
but now you have more control
over how they operate.

00:05:55.160 --> 00:05:56.160
There are more options.

00:05:56.160 --> 00:05:59.710
There's also a new option
for number spell-out.

00:05:59.720 --> 00:06:03.950
So in addition to all the
formatting options we had before,

00:06:03.950 --> 00:06:06.140
you can spell out numbers.

00:06:06.140 --> 00:06:09.100
There's an example there, 123.45.

00:06:10.080 --> 00:06:11.770
And this is not just for English.

00:06:11.770 --> 00:06:16.570
It works with any of the
locales that Mac OS X supports.

00:06:16.570 --> 00:06:18.260
So that's a new feature.

00:06:20.980 --> 00:06:23.670
Every release,
we try to extend our Unicode

00:06:23.670 --> 00:06:25.050
coverage a little bit.

00:06:25.390 --> 00:06:30.390
And so this time,
we're moving more Roman and Greek and

00:06:30.390 --> 00:06:33.340
Cyrillic support into our core fonts.

00:06:33.340 --> 00:06:36.600
So we used to have separate fonts,
for example, for Cyrillic support.

00:06:36.600 --> 00:06:41.090
And we're extending our core fonts,
and that's Times, Helvetica, and Courier,

00:06:41.170 --> 00:06:44.700
to support a wider variety
of Roman and Greek characters

00:06:44.760 --> 00:06:46.550
and also adding Cyrillic.

00:06:47.410 --> 00:06:50.480
In addition,
we're covering some new Unicode blocks,

00:06:50.560 --> 00:06:54.680
and that's Tamil, Braille,
Yijing hexagram symbols, Taishuanjing,

00:06:54.680 --> 00:06:56.650
and Taishuanjing symbols.

00:06:56.660 --> 00:07:00.520
And not all of this is in the preview
release that you have in your hands,

00:07:00.520 --> 00:07:02.010
but it will be showing up.

00:07:02.130 --> 00:07:04.990
And there are possibly more
blocks we might be covering

00:07:04.990 --> 00:07:08.300
that aren't listed here that are
still a little bit up in the air,

00:07:08.410 --> 00:07:11.260
but every release,
we try to add a little bit more.

00:07:11.260 --> 00:07:15.270
So, oh, and one last thing.

00:07:15.280 --> 00:07:16.300
Okay.

00:07:17.380 --> 00:07:20.320
So some of the language IDs that
we've used in Mac OS X up till

00:07:20.320 --> 00:07:23.300
now have not exactly followed
the standards in the area.

00:07:23.300 --> 00:07:28.080
So, for example, we use ZH underscore
TW for traditional Chinese.

00:07:28.080 --> 00:07:31.350
And in Tiger,
we're adding support to move

00:07:31.790 --> 00:07:34.200
to canonical language IDs.

00:07:34.200 --> 00:07:35.220
There are some examples.

00:07:35.220 --> 00:07:39.420
And there are new APIs that have
been added to CFLocale that can

00:07:39.960 --> 00:07:42.540
help you canonicalize language IDs.

00:07:42.540 --> 00:07:45.440
So that if you have...

00:07:46.870 --> 00:07:50.820
A localization for your application
that uses an old ID and you need

00:07:50.820 --> 00:07:54.560
to compare it against a new ID,
these APIs can help you make sure you

00:07:54.640 --> 00:07:57.130
do the comparison in a canonical way.

00:07:57.140 --> 00:08:02.260
So in order to show some of
the new features in Tiger,

00:08:02.260 --> 00:08:04.710
I'd like to ask John Jenkins to
come up on stage,

00:08:04.710 --> 00:08:09.130
and he'll give us a short
demonstration of what's new in Tiger.

00:08:11.280 --> 00:08:13.200
All right.

00:08:13.200 --> 00:08:15.380
As Deborah says,
there's an awful lot that's new in Tiger,

00:08:15.380 --> 00:08:18.780
and we don't really have time to
go over anywhere near all of it,

00:08:18.780 --> 00:08:20.590
so I'm just going to hit
some of the highlights,

00:08:20.590 --> 00:08:22.700
some of the really exciting things.

00:08:22.700 --> 00:08:25.980
And we'll start out
with an exciting thing,

00:08:26.230 --> 00:08:28.540
which is the transliteration APIs.

00:08:28.540 --> 00:08:33.080
So here we have a sentence or a word,
I guess, which is in Latin,

00:08:33.080 --> 00:08:35.460
and I want to know what
this would look like,

00:08:35.460 --> 00:08:37.990
for example, in Greek,
and I can change it.

00:08:38.020 --> 00:08:41.630
Or I want to know what it
would look like in Katakana,

00:08:41.630 --> 00:08:43.190
and I can change it.

00:08:43.250 --> 00:08:46.120
Although I'm not quite
sure that the accent works,

00:08:46.120 --> 00:08:49.760
or the upside-down exclamation
point really works in Japanese,

00:08:49.780 --> 00:08:50.960
but that's okay.

00:08:52.600 --> 00:08:56.160
Also useful is turning it to XML hex.

00:08:56.160 --> 00:08:57.700
This is very handy.

00:08:57.700 --> 00:09:02.370
This goes through and takes all of
the non-ASCII letters and converts

00:09:02.370 --> 00:09:07.400
them into the numeric entities that
you would use on a web page or in XML.

00:09:07.400 --> 00:09:10.350
Or if you really want
to know what's going on,

00:09:10.350 --> 00:09:15.080
you can always get the Unicode name
of the character that's not in ASCII,

00:09:15.080 --> 00:09:16.820
which is also handy.

00:09:16.820 --> 00:09:18.720
And of course, we can go the other way.

00:09:18.720 --> 00:09:21.650
We have a lot of things that
will let us transform to Latin.

00:09:21.980 --> 00:09:25.450
If I get a sentence here, for example,
this is the beginning,

00:09:25.450 --> 00:09:30.540
the first line of the Iliad for all the
people who are fans of the movie Troy,

00:09:30.540 --> 00:09:33.230
I can turn it into Latin.

00:09:33.240 --> 00:09:36.790
I could also strip it of its
combining marks if I wanted to,

00:09:36.790 --> 00:09:38.280
remove all of those.

00:09:38.280 --> 00:09:42.530
I can take other examples
and turn them into Latin.

00:09:42.530 --> 00:09:47.770
So I have an Arabic sentence, I hope,
and I can turn that into Latin,

00:09:47.770 --> 00:09:51.320
or I can take something
that's in Japanese.

00:09:51.620 --> 00:09:53.000
And again, I can turn it into Latin.

00:09:53.000 --> 00:09:55.480
So I can get a first
approximation transliteration.

00:09:55.480 --> 00:10:00.110
One thing that's useful for Chinese,
here I have an instance of a

00:10:00.360 --> 00:10:04.660
sentence which is partly in Cyrillic,
partly in Chinese.

00:10:04.660 --> 00:10:08.170
I can turn the whole thing
into Latin if I want,

00:10:08.270 --> 00:10:12.680
or I can just take the Chinese part
and turn it into Latin.

00:10:12.680 --> 00:10:17.900
So a lot of useful transliteration
APIs are available now.

00:10:17.940 --> 00:10:21.020
Now, Deborah also mentioned that
we have a lot more locales.

00:10:21.290 --> 00:10:23.120
Let's just bring up a
list of our locales.

00:10:23.120 --> 00:10:27.020
These are the locales that are
available on the system in Tiger,

00:10:27.060 --> 00:10:31.000
together with some of the
information you can get about them.

00:10:31.060 --> 00:10:33.780
This is pretty useful information, too.

00:10:33.780 --> 00:10:37.150
The one thing which I don't
think is wildly useful is metric,

00:10:37.270 --> 00:10:40.660
that is, whether or not this locale
uses the metric system,

00:10:40.660 --> 00:10:43.920
because it amounts to whether or
not you are in the United States,

00:10:43.960 --> 00:10:45.010
but that's okay.

00:10:45.020 --> 00:10:50.900
Currently, it defaults to showing
them in the global locale.

00:10:50.900 --> 00:10:54.720
But we can switch back and forth so
I can see what each of these looks like.

00:10:54.780 --> 00:10:57.650
And you'll notice that some of these
are showing up in the last resort font.

00:10:57.660 --> 00:11:00.760
These are locales that we
don't have system support for,

00:11:00.760 --> 00:11:01.520
but that's okay.

00:11:01.610 --> 00:11:05.680
On Mac OS X, it's very easy for third
parties to add support.

00:11:05.720 --> 00:11:08.560
So if I want to take one of
these and I want to see a date,

00:11:08.560 --> 00:11:16.000
say, in the Islamic calendar,
let's not use an unsupported locale.

00:11:16.000 --> 00:11:17.420
Okay, German.

00:11:17.420 --> 00:11:19.710
So I want to see what today's date is.

00:11:19.720 --> 00:11:20.880
This is today.

00:11:20.880 --> 00:11:24.890
Today's date in the Islamic calendar
as shown in Latin letters

00:11:24.890 --> 00:11:26.510
in the German locale.

00:11:26.520 --> 00:11:29.910
So we have a great deal of flexibility
for date and time formatting

00:11:29.960 --> 00:11:31.590
that we didn't used to have.

00:11:31.640 --> 00:11:32.670
All right.

00:11:32.760 --> 00:11:34.280
So that covers two.

00:11:34.280 --> 00:11:37.840
The third is the really exciting thing,
I think.

00:11:37.900 --> 00:11:41.150
This is something, as Debra says,
that people have been desperately

00:11:41.150 --> 00:11:44.330
asking us for for a long time,
and that's open type support.

00:11:44.440 --> 00:11:47.380
So it's not fully wired up yet,
but it is enough there

00:11:47.860 --> 00:11:49.660
that we can show it to you.

00:11:49.660 --> 00:11:49.760
Okay.

00:11:50.320 --> 00:11:52.480
So I'm going to take
-- this is World Text,

00:11:52.540 --> 00:11:56.820
which is a standard application
that comes with the developer tools.

00:11:56.820 --> 00:11:59.180
And I'm going to switch
to Adobe Caslon Pro.

00:11:59.180 --> 00:12:05.360
This is unaltered, nothing up my sleeves,
straight out of the box Adobe Caslon.

00:12:05.360 --> 00:12:07.300
And I can start typing.

00:12:07.300 --> 00:12:08.560
Let's see.

00:12:08.560 --> 00:12:09.820
Let's come up with something here.

00:12:09.820 --> 00:12:10.820
Okay.

00:12:10.820 --> 00:12:13.980
And you'll notice that as I typed,
the ligature formed automatically.

00:12:13.980 --> 00:12:17.500
FL formed automatically.

00:12:17.500 --> 00:12:19.900
FI formed automatically.

00:12:20.300 --> 00:12:36.600
[Transcript missing]

00:12:37.430 --> 00:12:38.230
I always get the code name.

00:12:38.250 --> 00:12:41.080
Intend 3, there we go.

00:12:41.140 --> 00:12:44.730
You can see more of what's
available in the font.

00:12:44.910 --> 00:12:46.780
For example,
I can turn on rare ligatures.

00:12:46.780 --> 00:12:49.470
And as the system does
now with AET fonts,

00:12:49.470 --> 00:12:52.240
it does with OpenType fonts and Tiger.

00:12:52.240 --> 00:12:53.390
It scans through.

00:12:53.390 --> 00:12:55.050
It sees what is in the font.

00:12:55.080 --> 00:12:57.800
It gives us support for
all of these things.

00:12:57.800 --> 00:13:00.210
I can turn on lining figures.

00:13:00.210 --> 00:13:02.300
I can turn on superiors.

00:13:02.300 --> 00:13:03.240
Let me see if that works.

00:13:03.240 --> 00:13:04.640
Yeah, well, that's kind of cool.

00:13:06.790 --> 00:13:07.310
And so on.

00:13:07.310 --> 00:13:10.840
So there's a lot of flexibility
here that's available.

00:13:10.940 --> 00:13:12.590
The font has it built in.

00:13:12.600 --> 00:13:14.090
The system just picks it up.

00:13:14.140 --> 00:13:16.200
So look forward to it.

00:13:16.200 --> 00:13:17.300
Thank you.

00:13:17.320 --> 00:13:18.760
Thank you, John.

00:13:24.190 --> 00:13:26.930
Okay, so now that we've seen
what's new in Tiger,

00:13:26.960 --> 00:13:30.930
let's start moving into the
detailed part of the presentation.

00:13:31.060 --> 00:13:35.350
We're going to go on our whirlwind
tour of the WorldScript APIs and

00:13:35.350 --> 00:13:37.400
what to replace them with.

00:13:37.490 --> 00:13:40.800
So before we start talking about
things that you can do with text,

00:13:40.800 --> 00:13:44.200
we have to talk about how you
store your text in the first place.

00:13:44.250 --> 00:13:46.560
So that's our first topic.

00:13:47.740 --> 00:13:50.550
Before we do that,
let's have a quick refresher

00:13:50.620 --> 00:13:53.600
on what's different about
Unicode compared to WorldScript.

00:13:53.600 --> 00:13:59.210
The Uni in UniCode means one,
and the most important thing about

00:13:59.220 --> 00:14:02.210
UniCode is there's only one character
set you have to worry about,

00:14:02.270 --> 00:14:04.350
unlike WorldScript,
where there were many.

00:14:05.820 --> 00:14:11.360
Unicode stores characters in
16-bit units in the UTF-16 form,

00:14:11.360 --> 00:14:14.620
which is what we use in
Mac OS X in Cocoa and Carbon,

00:14:14.620 --> 00:14:19.460
but since Unicode has more
than 96,000 characters,

00:14:19.460 --> 00:14:21.530
how do you fit that in a 16-bit unit?

00:14:21.540 --> 00:14:25.900
Well, the answer is you can't,
and some characters need more

00:14:25.900 --> 00:14:30.860
than one unit to be stored,
and there's an example right there.

00:14:32.340 --> 00:14:37.540
The Unicode character 2000B,
which is from the plane

00:14:37.760 --> 00:14:42.040
to Han characters,
is actually stored as two 16-bit

00:14:42.040 --> 00:14:43.660
units called a surrogate pair.

00:14:43.660 --> 00:14:48.080
Now, when I talk about a character here,
a Unicode character,

00:14:48.080 --> 00:14:50.460
that's the programmer's
concept of a character.

00:14:50.460 --> 00:14:55.400
What the user thinks of as a character
can actually be larger than that.

00:14:55.400 --> 00:14:59.600
What the user thinks of as a character
we call a grapheme or a cluster,

00:14:59.680 --> 00:15:02.320
and it can consist of one Unicode
character or two Unicode characters.

00:15:02.340 --> 00:15:06.220
So here's a couple of examples.

00:15:06.220 --> 00:15:11.260
We have the word resume,
but the accented E's are represented

00:15:11.260 --> 00:15:16.320
by base letter E plus what's
called a combining acute accent.

00:15:16.320 --> 00:15:20.560
So you have two Unicode characters,
the E and the accent,

00:15:20.560 --> 00:15:23.540
that represent one user character.

00:15:23.540 --> 00:15:26.480
In the next example, there's even more.

00:15:26.480 --> 00:15:29.000
This is the Vietnamese word
for Vietnamese,

00:15:29.000 --> 00:15:32.000
and you can see that we have
an E with two combinators,

00:15:32.340 --> 00:15:36.510
two combining accents,
a dot below and a circumflex above.

00:15:36.530 --> 00:15:40.340
So this is three Unicode characters
that represent what the user

00:15:40.340 --> 00:15:42.440
thinks of as a single character.

00:15:42.520 --> 00:15:47.220
To make life a little more interesting,
there's actually multiple

00:15:47.220 --> 00:15:48.520
ways to do this in Unicode.

00:15:48.520 --> 00:15:51.520
In addition to the base
letter and combining marks

00:15:51.520 --> 00:15:54.880
that we used in this example,
there are also pre-composed

00:15:54.880 --> 00:15:56.470
versions of these characters.

00:15:56.520 --> 00:16:00.520
So there is an E with an acute accent
that's a single Unicode character,

00:16:00.750 --> 00:16:03.990
and there is an E with a dot below,
and a circumflex above that's

00:16:03.990 --> 00:16:05.090
a single Unicode character.

00:16:05.200 --> 00:16:11.120
But you can't always represent every
character in a totally pre-composed form,

00:16:11.120 --> 00:16:14.540
and conversely,
you can't always represent a given

00:16:14.540 --> 00:16:17.110
character in a totally decomposed form.

00:16:17.120 --> 00:16:20.640
So even though there are
versions of Unicode that we call

00:16:20.640 --> 00:16:24.430
pre-composed and decomposed,
they really mean as pre-composed as

00:16:24.430 --> 00:16:29.190
possible and as decomposed as possible.

00:16:29.780 --> 00:16:32.700
So even in pre-composed Unicode,
you do have to worry about

00:16:32.700 --> 00:16:36.670
things like combining marks,
because they can be present.

00:16:38.880 --> 00:16:43.760
Okay, so in the world script world,
the way you stored your text was in

00:16:43.760 --> 00:16:45.550
a Pascal string or in a C string.

00:16:45.560 --> 00:16:48.940
Those don't support Unicode,
or at least not in the form that

00:16:48.940 --> 00:16:52.380
we needed for Carbon and Cocoa,
so what do you do in the new world?

00:16:53.720 --> 00:16:57.400
Well, if you're using Core Foundation,
you can use CFString or

00:16:57.400 --> 00:17:01.560
CF mutable string,
or new in Tiger is CF attributed string.

00:17:01.560 --> 00:17:05.370
If you need to work at a lower level,
you can just store Unicode

00:17:05.370 --> 00:17:09.110
text as arrays of Unicar,
which is a type defined in Carbon,

00:17:09.110 --> 00:17:11.370
or actually at a very low level.

00:17:11.380 --> 00:17:14.590
So there are a lot of
APIs for CFString and friends,

00:17:14.590 --> 00:17:17.350
and I don't have time
to go through them all,

00:17:17.350 --> 00:17:20.400
but just to give you a
flavor of how the API works,

00:17:20.400 --> 00:17:22.220
here's a few examples.

00:17:22.720 --> 00:17:27.710
You can create a CFString using
an array of Unicars.

00:17:27.710 --> 00:17:31.490
In this example, we pass null,
which indicates the default storage

00:17:31.520 --> 00:17:33.100
allocator for Core Foundation.

00:17:33.210 --> 00:17:36.940
We pass an array of Unicars,
and we pass their number,

00:17:36.940 --> 00:17:40.260
and that will give us
back a CFString object.

00:17:40.330 --> 00:17:46.190
You can also get characters
back from a CFString.

00:17:46.330 --> 00:17:49.420
In order to get the best performance,
you can use an inline buffer.

00:17:49.420 --> 00:17:53.660
And the way you do that is you set
up an inline buffer on a CFString,

00:17:53.660 --> 00:17:56.680
and then you can ask to get
a character at any index,

00:17:56.680 --> 00:18:00.850
and the inline buffer will take care
of batching access to the string so you

00:18:00.850 --> 00:18:03.520
get the most efficient access possible.

00:18:03.520 --> 00:18:06.650
Nguyen Tiger is
attributed string support,

00:18:06.650 --> 00:18:11.170
and an attributed string wraps an
existing CFString as opposed to

00:18:11.220 --> 00:18:16.090
you putting the characters into
the attributed string directly.

00:18:16.300 --> 00:18:20.770
So you can create an attributed
string by passing a CFString and

00:18:20.790 --> 00:18:22.860
a dictionary of attributes.

00:18:22.860 --> 00:18:27.130
They can be totally arbitrary
attributes that's not just a fixed set,

00:18:27.790 --> 00:18:30.120
although there are a predefined set.

00:18:30.140 --> 00:18:36.020
And you can also get the attributes at a
particular point of an attributed string.

00:18:36.020 --> 00:18:39.910
So you pass the attributed string,
the index where you

00:18:39.940 --> 00:18:44.040
want to get attributes,
and also a pointer to a range.

00:18:44.040 --> 00:18:46.280
The range gets set to the run.

00:18:46.300 --> 00:18:48.950
of the attributes so you know.

00:18:49.170 --> 00:18:52.640
How big a stretch of text has
those particular attributes?

00:18:52.640 --> 00:18:55.160
And then the function call returns
the dictionary of attributes

00:18:55.180 --> 00:18:56.300
that apply to that range.

00:19:01.470 --> 00:19:05.080
Now, something that those of you who've
programmed in WorldScript know

00:19:05.080 --> 00:19:07.900
is that when you're dealing
with double-byte character sets,

00:19:07.900 --> 00:19:12.490
you can't just break a string at an
arbitrary byte offset because it might be

00:19:12.570 --> 00:19:13.960
in the middle of a double-byte character.

00:19:13.960 --> 00:19:17.160
And you used character byte
type to determine if there

00:19:17.160 --> 00:19:18.820
was a safe place to break.

00:19:20.320 --> 00:19:23.240
We can't use character byte
type in a Unicode application,

00:19:23.240 --> 00:19:25.580
but there's a similar
issue to worry about,

00:19:25.580 --> 00:19:28.860
and that is the user characters
that I talked about earlier,

00:19:28.860 --> 00:19:31.160
or what's called a cluster or a grapheme.

00:19:31.160 --> 00:19:35.130
You don't want to break in the
middle of that because if you do,

00:19:35.130 --> 00:19:39.000
and then you only display the
first part before the break,

00:19:39.000 --> 00:19:42.300
you'll actually mangle what the
user thinks of as their character

00:19:42.380 --> 00:19:44.000
and display the wrong thing.

00:19:44.000 --> 00:19:48.660
So there are APIs available to help
you find a safe place to break.

00:19:49.320 --> 00:19:52.450
If you're using a CFString,
you can use CFString get range

00:19:52.460 --> 00:19:56.630
of composed characters at index,
and that will find a safe place to break.

00:19:56.700 --> 00:20:00.290
If you're using a Unicar array,
then you can use the Unicode

00:20:00.400 --> 00:20:04.290
utilities find text break API and
look for a cluster boundary,

00:20:04.290 --> 00:20:07.530
and that will also tell
you a safe place to break.

00:20:07.590 --> 00:20:09.060
So here's an example.

00:20:09.060 --> 00:20:13.660
We have a string and an offset,
and we want to figure out

00:20:13.660 --> 00:20:15.630
a safe place to break.

00:20:15.730 --> 00:20:19.300
So we call CFString get range
of composed characters at index.

00:20:19.300 --> 00:20:22.550
We pass our string,
and we pass the index, that is,

00:20:22.550 --> 00:20:25.090
the place where we would like to break.

00:20:25.160 --> 00:20:29.860
And what the API returns is a range,
which is the beginning and the end

00:20:29.860 --> 00:20:34.910
of the user character or the cluster
that corresponds to that offset.

00:20:34.940 --> 00:20:39.840
So in this case, we take that range,
and we go to the end of it.

00:20:39.880 --> 00:20:42.470
We take the beginning location
and add the length in,

00:20:42.470 --> 00:20:44.540
and that's the place where we can break.

00:20:44.600 --> 00:20:49.090
We could also just use the beginning
part of the range instead of the end.

00:20:49.440 --> 00:20:53.070
That depends on how you want
your application to work.

00:20:56.940 --> 00:20:59.620
Another thing you need to do
is to figure out what kind of

00:20:59.780 --> 00:21:01.480
character a given character is.

00:21:01.680 --> 00:21:02.360
Is it a letter?

00:21:02.390 --> 00:21:03.600
Is it a digit?

00:21:03.600 --> 00:21:05.010
So forth.

00:21:05.230 --> 00:21:08.740
In the WorldScript world,
you used character type for that,

00:21:08.740 --> 00:21:11.580
but that doesn't work with Unicode,
so we can't use it anymore.

00:21:12.880 --> 00:21:15.760
In the Unicode world,
there's two ways to do this.

00:21:16.000 --> 00:21:19.380
There's a CF character set, APIs,
and core foundation.

00:21:19.380 --> 00:21:22.900
And at a lower level,
there's UC get car property.

00:21:22.900 --> 00:21:27.180
So here's an example to determine
whether a character is a decimal digit.

00:21:27.180 --> 00:21:30.430
Now, you might think to determine whether
something is a decimal digit,

00:21:30.430 --> 00:21:32.980
you can just say, well,
is it ASCII 0 through 9?

00:21:32.980 --> 00:21:35.650
But it turns out in Unicode,
there are lots more decimal

00:21:35.650 --> 00:21:37.070
digits than just those.

00:21:37.080 --> 00:21:39.890
There are decimal digits
for Indic languages,

00:21:39.890 --> 00:21:42.860
for Arabic,
and all of those are just as valid.

00:21:42.860 --> 00:21:47.490
So we can call it as decimal digits as
the ASCII versions that we're used to.

00:21:47.490 --> 00:21:50.710
So to test whether any
character is a decimal digit,

00:21:50.710 --> 00:21:52.750
we can use CF character set.

00:21:52.800 --> 00:21:55.950
So first,
we get a predefined CF character set,

00:21:55.950 --> 00:21:58.720
in this case, the set of decimal digits.

00:21:58.720 --> 00:22:02.970
And then we can call CF character
set is long character member in order

00:22:02.970 --> 00:22:08.750
to determine whether a given Unicode
character is a member of that set or not.

00:22:08.800 --> 00:22:12.860
And then we can branch
one way or the other.

00:22:12.880 --> 00:22:15.260
depending on the answer.

00:22:17.860 --> 00:22:20.140
Well,
it would be wonderful if your application

00:22:20.370 --> 00:22:23.740
could deal only with Unicode and never
have to think about anything else,

00:22:23.740 --> 00:22:27.400
but there's still a lot of data
out there that's not in Unicode.

00:22:27.400 --> 00:22:30.790
There's documents that users have.

00:22:30.860 --> 00:22:34.380
I have documents on my system
that date back almost to the

00:22:34.490 --> 00:22:37.780
time the Mac was introduced,
and those are definitely not

00:22:37.780 --> 00:22:40.520
in Unicode because it hadn't
even been invented then.

00:22:41.200 --> 00:22:45.680
There are protocols on the Internet that
still require non-Unicode character sets.

00:22:45.680 --> 00:22:47.430
The Web is a big example.

00:22:47.530 --> 00:22:51.160
You can use Unicode on the Web, but many,
many Web pages are not in Unicode.

00:22:51.160 --> 00:22:54.010
So you need to be able to
move between the Unicode world

00:22:54.050 --> 00:22:57.380
and the non-Unicode world,
and we've had support in Mac OS X for

00:22:57.380 --> 00:23:00.960
this for a long time in the form
of the Text Encoding Converter,

00:23:00.960 --> 00:23:03.060
which is a fairly low-level API.

00:23:03.060 --> 00:23:06.770
That even actually
dates back to Mac OS 9,

00:23:06.770 --> 00:23:11.100
but there's easier ways
to do it using CFString.

00:23:11.100 --> 00:23:14.980
And again, there's a wide variety of
APIs that you can use to do this,

00:23:15.050 --> 00:23:18.050
and we're only going to go
through a couple of them.

00:23:18.140 --> 00:23:22.700
In the first example, you can create a
CFString using a C string,

00:23:22.930 --> 00:23:25.880
and all you need to do
is pass the C string,

00:23:25.880 --> 00:23:30.110
which is null terminated,
and a text encoding to use.

00:23:30.150 --> 00:23:33.910
And that will give you back a CFString,
which is in UniCode.

00:23:33.940 --> 00:23:24.480
If you want a little bit more control,
for example,

00:23:24.480 --> 00:23:12.030
your string isn't null terminated,
you want to control what happens

00:23:12.030 --> 00:23:26.380
if the data is not in the C string,
then you can pass the C string,

00:23:26.380 --> 00:23:41.180
which is null terminated,
and a text encoding to use.

00:23:41.190 --> 00:23:43.480
If the data can't be
converted completely,

00:23:43.730 --> 00:23:45.840
then you can use
CFString create with bytes,

00:23:45.840 --> 00:23:47.500
which gives you finer control.

00:23:47.700 --> 00:23:52.790
So one question you might have is,
what do I pass for that text encoding?

00:23:52.790 --> 00:23:56.090
And that's actually a
non-trivial question.

00:23:56.200 --> 00:23:59.600
It depends a lot on where
the data is coming from.

00:23:59.700 --> 00:24:03.990
If you're lucky and the data is coming,
say, from an internet protocol and it's

00:24:03.990 --> 00:24:07.750
tagged with its character set,
then you know what encoding to pass.

00:24:07.900 --> 00:24:10.080
But sometimes you have to guess.

00:24:10.700 --> 00:24:14.720
And two good guesses are the
encoding that corresponds to your

00:24:14.720 --> 00:24:16.910
application's human interface.

00:24:16.980 --> 00:24:20.040
So if, for example,
if your application is running

00:24:20.040 --> 00:24:23.400
in Japanese and you call get
application text encoding,

00:24:23.400 --> 00:24:26.190
you'll get Mac Japanese back
as the encoding.

00:24:26.290 --> 00:24:29.860
A different encoding is
CFString get system encoding,

00:24:29.860 --> 00:24:33.720
and that's the text encoding
that corresponds to the user's

00:24:33.720 --> 00:24:35.680
most preferred language.

00:24:36.420 --> 00:24:38.890
Now,
the user's most preferred language is

00:24:38.890 --> 00:24:42.740
not always the same as the language
that your application is running in.

00:24:42.740 --> 00:24:46.370
And the reason for that is
that the user's most preferred

00:24:46.400 --> 00:24:50.340
language may be one that your
application is not localized into.

00:24:50.340 --> 00:24:54.000
So, for example,
if the user's most preferred language is

00:24:54.000 --> 00:24:58.500
Inuktitut and you don't have an Inuktitut
localization in your application,

00:24:58.500 --> 00:25:00.570
then you're not going to
be running in Inuktitut.

00:25:00.590 --> 00:25:04.640
In that case,
the application text encoding

00:25:04.640 --> 00:25:07.440
and the user's text encoding
are not going to match.

00:25:07.440 --> 00:25:10.280
So which one of these you call
depends on your application.

00:25:10.280 --> 00:25:14.580
And where the data is coming from.

00:25:16.170 --> 00:25:19.930
Another thing you have to worry about
on the Internet or when sending Unicode

00:25:19.930 --> 00:25:24.900
to Windows is that other systems do
not deal with the decomposed form of

00:25:25.000 --> 00:25:27.860
Unicode quite as well as Mac OS X does.

00:25:27.930 --> 00:25:33.200
And so it's better to convert Unicode
to what's called Normalization Form C,

00:25:33.250 --> 00:25:38.100
which is the as pre-composed as possible
form before you send it to those systems,

00:25:38.100 --> 00:25:41.560
and you can use
CFString Normalize to do that.

00:25:41.790 --> 00:25:45.750
And a new feature in Tiger is
that you can determine the

00:25:45.750 --> 00:25:48.010
text encoding used by MLTE.

00:25:48.130 --> 00:25:50.940
So if you're using the
multilingual text engine,

00:25:50.940 --> 00:25:56.500
which is the Carbon-Unicode text engine,
you can now specify the text

00:25:56.540 --> 00:26:00.680
encoding to use when opening
or saving to plain text files.

00:26:00.790 --> 00:26:03.390
And that's a new feature in Tiger.

00:26:07.040 --> 00:26:11.750
Okay, so we've covered the basics of how
to store your text and how to get

00:26:11.750 --> 00:26:16.020
it in and out of your application,
but there's more text to your application

00:26:16.110 --> 00:26:18.430
than just what's in the user's document.

00:26:18.440 --> 00:26:22.020
There's also the text that you create
yourself for your human interface,

00:26:22.020 --> 00:26:24.590
and let's spend a little
time talking about that.

00:26:27.300 --> 00:26:30.540
Well, in the old world,
you used the Resource Manager to store

00:26:30.640 --> 00:26:33.390
the localized pieces of your application.

00:26:33.480 --> 00:26:37.530
I used resources like D-log or Menu,
or if you're using Power Plant,

00:26:37.540 --> 00:26:39.640
maybe you're using PPOB resources.

00:26:39.640 --> 00:26:43.090
Well, those resources are all based
on the old-world script world,

00:26:43.150 --> 00:26:44.910
and they can't support Unicode.

00:26:44.920 --> 00:26:47.960
So the modern equivalence
for a Unicode application,

00:26:47.960 --> 00:26:52.180
or indeed any modern application,
is the bundle, which I'm sure you've all

00:26:52.210 --> 00:26:56.020
heard of about already,
but I'll just give a very brief review.

00:26:56.700 --> 00:27:01.370
An application bundle is a directory tree
in the file system that's made to look

00:27:01.370 --> 00:27:03.530
to the end user as if it's a single file.

00:27:03.540 --> 00:27:09.100
You can store non-localized files,
localized files, files of any type,

00:27:09.240 --> 00:27:10.260
actually.

00:27:10.260 --> 00:27:11.700
It's totally up to you.

00:27:11.700 --> 00:27:14.390
Movies, strings, what have you.

00:27:14.400 --> 00:27:18.280
Localized files are stored
in an LPROJ directory,

00:27:18.280 --> 00:27:23.070
and the LPROJ directory is tagged
with the ISO language code for

00:27:23.070 --> 00:27:27.190
the particular language that
that localization corresponds to.

00:27:27.190 --> 00:27:30.200
So, for example, EN for English,
JA for Japanese.

00:27:30.200 --> 00:27:35.810
One of the most important kinds of
things you can store in your application

00:27:35.810 --> 00:27:38.770
bundle are interface builder files,
or NIB files.

00:27:38.800 --> 00:27:42.430
And those are the files that
contain UI elements and replace

00:27:42.620 --> 00:27:46.580
the old resources that were used
with the Control Manager and

00:27:46.600 --> 00:27:50.100
the Dialog Manager and so forth,
the ones that didn't support UniCode.

00:27:50.100 --> 00:27:55.700
And there's a small set of APIs you can
use for NIBs with Carbon applications.

00:27:55.700 --> 00:27:59.300
You can create a NIB reference
from your application bundle,

00:27:59.300 --> 00:28:02.200
and once you have that,
you can get your menu bar out,

00:28:02.200 --> 00:28:04.990
you can get menus out,
you can get windows out

00:28:05.050 --> 00:28:06.700
with HIView hierarchies.

00:28:06.700 --> 00:28:09.140
It's very straightforward to use.

00:28:11.900 --> 00:29:44.900
[Transcript missing]

00:29:48.200 --> 00:29:50.790
Okay, well,
a big part of any application that

00:29:50.790 --> 00:29:55.100
deals with text is drawing it,
editing it, and inputting it.

00:29:55.100 --> 00:29:58.000
And there are several
APIs available to do that.

00:29:58.020 --> 00:30:00.700
Now, when you talk about drawing text,
you can sort of partition

00:30:00.700 --> 00:30:04.920
applications into two classes,
or at least you can partition

00:30:04.920 --> 00:30:06.730
text drawing into two classes.

00:30:07.060 --> 00:30:09.890
First is drawing short strings.

00:30:10.230 --> 00:30:14.730
And in the WorldScript world,
namely Quickdraw text,

00:30:14.730 --> 00:30:17.670
you did that with either
DrawString or TextBox.

00:30:17.670 --> 00:30:21.930
The UniCode equivalents
are DrawThemeTextBox,

00:30:21.930 --> 00:30:23.380
which is very straightforward.

00:30:23.380 --> 00:30:24.780
It just takes a CFString.

00:30:24.780 --> 00:30:30.100
And you can use that when you're happy to
just use one of the standard theme fonts.

00:30:30.100 --> 00:30:36.420
If you need more control,
you can call one of two MLTE APIs,

00:30:36.420 --> 00:30:42.030
either TXN DrawCFStringTextBox or
TXN DrawUnicodeTextBox.

00:30:42.120 --> 00:30:45.640
And the only difference between
them is one takes a CFString and

00:30:45.640 --> 00:30:50.100
the other takes a Unicar*,
so depending on how your text is stored.

00:30:50.100 --> 00:30:52.770
And that gives you actually
a lot more control,

00:30:52.840 --> 00:30:56.080
not just fonts,
but also you can specify a CG context.

00:30:56.110 --> 00:30:59.090
You can control things
like rotation and so on.

00:30:59.100 --> 00:31:00.590
and so on.

00:31:03.330 --> 00:31:07.430
Now, sometimes an application has
to draw large amounts of text,

00:31:07.550 --> 00:31:12.220
and by that I mean drawing a document,
implementing a text editing engine,

00:31:12.720 --> 00:31:16.560
implementing a web browser where you
have to paint large amounts of text,

00:31:16.560 --> 00:31:20.160
and the APIs on the previous
slide are not really appropriate

00:31:20.160 --> 00:31:21.880
for those kinds of tasks.

00:31:21.930 --> 00:31:23.760
Also,
sometimes you need a lot more control

00:31:23.760 --> 00:31:27.310
over the way text is rendered,
and again, the previous APIs are

00:31:27.310 --> 00:31:28.740
a little too simple.

00:31:28.780 --> 00:31:32.620
Well, in the Quick Draw text world,
we use things like Draw Text,

00:31:32.620 --> 00:31:35.950
Measure Text,
a few supported bidirectional texts

00:31:35.950 --> 00:31:38.150
you had to call Get Format Order.

00:31:38.310 --> 00:31:43.430
There are a whole bunch of APIs to call,
and it's too complicated to

00:31:43.480 --> 00:31:46.520
go into in a talk like this.

00:31:46.520 --> 00:31:51.040
The equivalent set of APIs to use in
the UniCode world for Carbon is Atsui,

00:31:51.040 --> 00:31:57.860
Apple-type services for UniCode imaging,
and again, that's a rather large API set.

00:31:57.860 --> 00:32:01.650
And rendering complex text is a
sufficiently difficult problem that

00:32:01.650 --> 00:32:05.090
I'm not going to get into it in
the two or three minutes I would

00:32:05.090 --> 00:32:07.300
have to cover it in this session.

00:32:07.300 --> 00:32:11.620
So there's a great online reference,
Rendering UniCode Text with Atsui.

00:32:11.620 --> 00:32:16.440
I strongly recommend you start
there if Atsui is new to you.

00:32:16.440 --> 00:32:19.460
In addition, there's a session on Friday,
Session 425,

00:32:19.460 --> 00:32:22.820
Modern Text Layout and Editing
for Carbon Applications,

00:32:22.820 --> 00:32:26.660
where you can go to hear all
about Atsui and MLTE and to talk

00:32:26.750 --> 00:32:29.570
to the engineers who work on it.

00:32:33.200 --> 00:32:37.500
Now, a much more ideal way of dealing
with text is not to have to render

00:32:37.500 --> 00:32:39.830
large amounts of it yourself,
but to use one of the

00:32:39.840 --> 00:32:41.410
built-in text editing engines.

00:32:41.420 --> 00:32:44.130
That's a lot easier
than building your own.

00:32:44.140 --> 00:32:48.790
The text editing engine in the
WorldScript world was called TextEdit,

00:32:48.790 --> 00:32:51.790
and there's also a control
to go along with it,

00:32:51.790 --> 00:32:56.670
the EditText control, but unfortunately,
they can't support Unicode,

00:32:56.670 --> 00:32:59.030
and they're now deprecated.

00:32:59.440 --> 00:33:05.540
So the modern UniCode equivalent is MLTE,
the Multilingual Text Engine, and again,

00:33:05.540 --> 00:33:09.570
I'm not going to go into
the details of the MLTE.

00:33:09.810 --> 00:33:12.600
Whoops, oh, it's up there,
but it's not down here.

00:33:12.680 --> 00:33:15.940
I'm not going to go into
the details of the MLTE API,

00:33:15.940 --> 00:33:21.310
but there's a very nice online
reference that you can read.

00:33:21.880 --> 00:33:26.270
And a new option that was introduced,
I think, in--was it Panther?--for

00:33:26.310 --> 00:33:31.670
HITextView was HITextView,
which makes it even easier to use MLTE.

00:33:31.800 --> 00:33:37.570
It wraps it up in an HIView object,
so it can be part of an HIView hierarchy.

00:33:40.490 --> 00:33:44.040
And could I... My monitor
picture has disappeared,

00:33:44.040 --> 00:33:48.340
so it would be nice to
get some support for that.

00:33:48.340 --> 00:33:53.400
In addition to HITextView,
there's also a Unicode version

00:33:53.400 --> 00:33:58.830
of the EditText control,
so that basically gives equivalent

00:33:58.830 --> 00:34:01.320
functionality but supports Unicode.

00:34:02.070 --> 00:34:06.960
And I have here a few API examples
just to give you a flavor.

00:34:06.960 --> 00:34:12.030
You call HITextViewCreate,
and that will create a new HITextView for

00:34:12.040 --> 00:34:14.130
you that wraps up an MLTE object.

00:34:14.200 --> 00:34:21.200
And the nice thing about
HITextView is it's not totally opaque.

00:34:21.200 --> 00:34:27.300
You can get at the underlying
MLTE object so that you can do

00:34:27.300 --> 00:34:28.900
more advanced operations with it.

00:34:29.000 --> 00:34:32.340
You can save and open documents
and so forth and so on,

00:34:32.340 --> 00:34:36.750
and you just call
HITextViewGetTxnObject to get that out.

00:34:37.590 --> 00:34:40.400
And UniCode Text Control is
very easy to create.

00:34:40.540 --> 00:34:46.390
You just call Create,
Edit UniCode Text Control.

00:34:47.800 --> 00:34:50.140
You'll have to forgive me as my
head swivels around for a while

00:34:50.140 --> 00:34:51.600
as I've lost my monitor here.

00:34:51.600 --> 00:34:55.700
Maybe I'll move over here so
I can see the podium monitor

00:34:55.870 --> 00:34:58.190
while they're taking care of that.

00:34:59.170 --> 00:35:03.470
Okay, another problem,
if you are implementing your own text

00:35:03.930 --> 00:35:10.340
editing engine or for some other reason
you have to handle text input directly,

00:35:10.760 --> 00:35:16.050
then in the very, very, very old world,
you might have called wait next event,

00:35:16.110 --> 00:35:18.900
or in the ancient world,
even get next event.

00:35:18.900 --> 00:35:20.820
Hopefully nobody's calling that anymore.

00:35:21.680 --> 00:35:25.060
If you are supporting languages
like Japanese or Chinese,

00:35:25.060 --> 00:35:30.020
hopefully your application is already
using TSM and you are calling new

00:35:30.150 --> 00:35:34.950
TSM document and specifying a text
service document interface type.

00:35:35.300 --> 00:35:38.850
Well, unfortunately,
that doesn't support Unicode,

00:35:38.850 --> 00:35:43.310
but there is a new document type,
Unicode document interface type,

00:35:43.310 --> 00:35:46.840
that you can call new TSM document with,
and that will create a

00:35:46.840 --> 00:35:48.890
TSM document that supports Unicode.

00:35:48.900 --> 00:35:54.850
In the old version of the OS,
that was done with Apple events,

00:35:54.950 --> 00:35:58.700
but for the last several releases,
it's been done with Carbon events.

00:35:58.700 --> 00:36:03.180
And you want to avoid the
keyboard class Carbon events,

00:36:03.180 --> 00:36:07.530
because those are raw keyboard events,
and if you look at those,

00:36:07.690 --> 00:36:11.450
that will be before the input
method has a chance to work on them.

00:36:11.460 --> 00:36:15.130
So you want to look at the text after
the input method has processed it,

00:36:15.130 --> 00:36:21.380
and the two Carbon events for that are
the text input UniCode for key event,

00:36:21.380 --> 00:36:24.590
and that's what comes from input
methods or keyboard layouts.

00:36:24.650 --> 00:36:27.740
And then there's the text
input UniCode text event,

00:36:27.740 --> 00:36:31.260
and that's what comes from
non-keyboard entry methods such

00:36:31.260 --> 00:36:33.340
as the character palette or ink.

00:36:33.340 --> 00:36:36.460
And you can basically handle
those pretty much the same way.

00:36:36.460 --> 00:36:41.220
Now, if you're a TSM aware application,
there's several more Carbon events

00:36:41.220 --> 00:36:43.980
you have to deal with,
but those are the same between

00:36:43.980 --> 00:36:46.850
UniCode and non-Unicode applications,
and so we're not going

00:36:46.930 --> 00:36:49.810
to talk about them today.

00:36:52.550 --> 00:36:54.600
Okay,
so we know how we're storing our text,

00:36:54.600 --> 00:36:58.200
we know how we're getting it
into and out of our application,

00:36:58.200 --> 00:37:00.380
we know how we're
drawing and inputting it,

00:37:00.500 --> 00:37:04.300
but there's also operations
on the text itself.

00:37:07.940 --> 00:37:12.760
Something that's important in a lot of
applications is sorting and searching.

00:37:13.040 --> 00:37:16.590
In the old WorldScript world,
we only supported sorting,

00:37:16.590 --> 00:37:19.610
and you would call string order
or text order in order to do

00:37:19.610 --> 00:37:21.340
a comparison of two strings.

00:37:21.340 --> 00:37:24.480
And of course, that depended on what the
current script system was.

00:37:26.180 --> 00:37:30.880
In the UniCode world,
there are several APIs available.

00:37:30.920 --> 00:37:34.510
The easiest one to use
is CFStringCompare,

00:37:34.510 --> 00:37:38.480
and you just give it two
CFStrings and some options on how

00:37:38.480 --> 00:37:41.630
you want the strings compared,
and it will tell you whether

00:37:41.630 --> 00:37:44.860
they're the same or one is less
than or greater than the other.

00:37:44.860 --> 00:37:49.100
If you're working with arrays of Unicars,
you can call the lower-level

00:37:49.100 --> 00:37:50.560
API UCCompareText.

00:37:52.670 --> 00:37:57.200
Now, if you're going to be doing sorting,
you're going to be doing a lot

00:37:57.200 --> 00:38:00.120
of key comparisons in your sort,
and you may be comparing

00:38:00.120 --> 00:38:01.780
the same key multiple times.

00:38:01.800 --> 00:38:05.130
There is some overhead involved
in doing a language and

00:38:05.160 --> 00:38:09.120
Unicode-sensitive comparison,
so if you're going to be doing something

00:38:09.120 --> 00:38:12.270
like sorting a large amount of data,
it's more efficient to get something

00:38:12.270 --> 00:38:13.820
that's called a collation key.

00:38:13.820 --> 00:38:19.850
And a collation key is a string of bytes
that does a binary compare the same way

00:38:20.010 --> 00:38:25.430
that the underlying string would do a
language and Unicode-sensitive compare.

00:38:25.560 --> 00:38:31.940
So what you can do is call the Unicode
utilities get collation key for a given

00:38:32.000 --> 00:38:36.980
text collator and a string of unicars,
and you'll get back a binary key that you

00:38:36.980 --> 00:38:41.480
can just compare using binary ordering,
and that can make your sort

00:38:41.480 --> 00:38:43.430
go significantly faster.

00:38:43.570 --> 00:38:47.450
If you're something that you
couldn't do in the WorldScript world

00:38:47.610 --> 00:38:51.500
but you can do in the UniCode
world is search for substrings.

00:38:51.500 --> 00:38:54.040
And again, CFString makes it very easy.

00:38:54.230 --> 00:38:55.430
There's CFString find.

00:38:55.570 --> 00:38:59.400
You give your target string and a
substring that you want to look for in

00:38:59.400 --> 00:39:03.810
that target string and search options,
and it will find the instances.

00:39:03.840 --> 00:39:04.770
You can step through them.

00:39:04.770 --> 00:39:09.000
You can also look for more
than just a substring.

00:39:09.000 --> 00:39:12.820
You can also find instances of
characters in a CF character set.

00:39:16.110 --> 00:39:18.920
And again, this is just a sample of
the APIs that are available.

00:39:18.960 --> 00:39:22.330
There are a lot more APIs available
for sorting and searching,

00:39:22.350 --> 00:39:26.140
and I urge you to check out
the documentation for CFString.

00:39:26.140 --> 00:39:27.600
It has a lot of capabilities.

00:39:31.270 --> 00:39:34.200
Sometimes you need to change
the case of something,

00:39:34.200 --> 00:39:38.230
and we have uppercase text and
lowercase text available in the

00:39:38.230 --> 00:39:41.840
text utilities for doing that,
but they don't work with Unicode.

00:39:41.840 --> 00:39:46.240
The modern equivalent for a
Unicode application is in CFString,

00:39:46.240 --> 00:39:50.340
and there's CFStringUppercase,
which converts everything to uppercase.

00:39:50.470 --> 00:39:53.080
You'll notice that it
takes two parameters,

00:39:53.150 --> 00:39:54.540
a string and a locale.

00:39:54.540 --> 00:39:58.700
The reason for that is that
the rules about how to convert

00:39:58.770 --> 00:40:02.130
uppercase to lowercase or
lowercase to uppercase differ a

00:40:02.580 --> 00:40:04.610
little from language to language.

00:40:04.620 --> 00:40:08.370
For example, in Turkish,
the rules are different from English,

00:40:08.410 --> 00:40:12.440
and so you need to pass a locale if you
want the case conversion to be done in

00:40:12.440 --> 00:40:15.070
a correct language-sensitive fashion.

00:40:15.080 --> 00:40:18.500
Something that you can do with
CFString that you couldn't do in

00:40:18.500 --> 00:40:20.420
the Script Manager is caching.

00:40:20.420 --> 00:40:22.500
If you want to be able to do that,
you need to use a C-file.

00:40:22.640 --> 00:40:24.240
You can use a C-file if
you want to use a C-file,

00:40:24.250 --> 00:40:26.470
but you can't use a C-file
if you want to use a C-file.

00:40:26.570 --> 00:40:27.850
You can use a C-file if
you want to use a C-file,

00:40:27.850 --> 00:40:29.480
but you can't use a C-file
if you want to use a C-file.

00:40:29.970 --> 00:40:34.390
You can use a C-file if you want to use
a C-file if you want to use a C-file.

00:40:34.530 --> 00:40:39.610
You can use a C-file if you want to use
a C-file if you want to use a C-file.

00:40:43.600 --> 00:42:58.000
[Transcript missing]

00:42:58.570 --> 00:43:03.920
And again, this is new in Tiger,
and this is in the WWDC preview

00:43:03.920 --> 00:43:08.090
release that you've received,
so you can experiment with it.

00:43:10.860 --> 00:43:12.940
There's also other
manipulations on strings,

00:43:12.940 --> 00:43:16.020
just basically moving
parts of strings around.

00:43:16.020 --> 00:43:18.800
And in the WorldScript world,
we had Munger.

00:43:18.830 --> 00:43:20.880
Munger just works on bytes.

00:43:21.120 --> 00:43:24.340
In addition, it requires that your
text be in a handle.

00:43:24.340 --> 00:43:27.070
There are several options
available to replace Munger if

00:43:27.070 --> 00:43:28.700
you're working with Unicode.

00:43:28.700 --> 00:43:30.940
CFStringReplace is very easy to use.

00:43:30.940 --> 00:43:33.500
You take a mutable string,
a range of that string

00:43:33.700 --> 00:43:36.920
that you want to replace,
and what to replace it with.

00:43:36.990 --> 00:43:38.700
Very straightforward.

00:43:38.700 --> 00:43:43.700
There's also CFStringCreateWithFormat
and CFStringAppendWithFormat,

00:43:43.700 --> 00:43:45.700
which work a lot like Printf.

00:43:45.700 --> 00:43:49.700
And again,
those are fully UniCode compatible.

00:43:49.700 --> 00:43:54.270
There's also CFStringTrim,
which will remove constant strings from

00:43:54.270 --> 00:43:58.700
the beginning or end of a CFString,
a mutable string, that is.

00:43:58.700 --> 00:44:03.580
And also CFStringTrimWhitespace,
which will remove whitespace characters.

00:44:03.630 --> 00:44:06.700
And if you really need to
just move bytes around,

00:44:06.700 --> 00:44:06.700
then there's the standard
C library routine.

00:44:06.700 --> 00:44:10.420
And there's the standard
C library routine memmove,

00:44:10.420 --> 00:44:14.710
which handles arbitrary byte
moves and deals with issues like

00:44:14.740 --> 00:44:17.700
overlapping source and destination.

00:44:23.040 --> 00:44:26.200
If you have an application
that displays text in a list,

00:44:26.210 --> 00:44:30.840
or presents text in a fixed size space,
if you have a string that's

00:44:30.840 --> 00:44:33.410
too large for that space,
or in a list if it's too

00:44:33.410 --> 00:44:36.900
large for the column,
then you need to truncate the string.

00:44:37.050 --> 00:44:41.800
And that needs to be done in a
unicode and language sensitive way.

00:44:41.820 --> 00:44:45.530
In the script manager world,
we had trunk string and

00:44:45.530 --> 00:44:47.300
trunk text to do that.

00:44:47.520 --> 00:44:50.580
There's two ways to do
that in the unicode world.

00:44:50.580 --> 00:44:54.910
One very nice option if you're
using ATSUI directly is to use

00:44:54.910 --> 00:44:57.360
ATSUI's line truncation tag.

00:44:57.590 --> 00:45:00.430
And what that will actually
do is truncate the string

00:45:00.470 --> 00:45:02.050
while it's being drawn.

00:45:02.050 --> 00:45:05.870
So you don't actually have to
modify the string itself in memory.

00:45:06.440 --> 00:45:11.600
What you can do is tell ATSUI that you
need to draw the string in a fixed width,

00:45:11.600 --> 00:45:14.910
and if you specify the
line truncation tag,

00:45:15.300 --> 00:45:17.590
if it fits by itself, that's fine.

00:45:17.700 --> 00:45:21.480
If it's a little too big,
ATSUI will try to squish it down a little

00:45:21.480 --> 00:45:23.540
bit first so it can draw the whole thing.

00:45:23.540 --> 00:45:27.180
And if it still doesn't fit,
then ATSUI will truncate the

00:45:27.280 --> 00:45:29.540
string and insert an ellipsis.

00:45:29.540 --> 00:45:33.320
If you want to actually
truncate the data itself,

00:45:33.550 --> 00:45:36.060
which is the way that trunk
string and trunk text worked,

00:45:36.250 --> 00:45:40.530
then you can call truncate theme text,
which is a unicode equivalent.

00:45:44.670 --> 00:45:48.830
Something that's very important for
applications that deal with text

00:45:48.830 --> 00:45:50.860
is finding appropriate boundaries.

00:45:50.860 --> 00:45:53.330
So we already talked
about a cluster boundary,

00:45:53.350 --> 00:45:56.610
which corresponds to what the
user thinks of as a character.

00:45:56.610 --> 00:45:58.670
But there are other boundaries as well.

00:45:58.670 --> 00:46:00.650
So let's take a look at this slide.

00:46:00.660 --> 00:46:04.660
There's an example at the bottom
that illustrates line and word break.

00:46:04.860 --> 00:46:08.290
And you'll see that line break and
word break are not the same thing,

00:46:08.290 --> 00:46:11.680
although they're often thought
of as being the same thing.

00:46:11.810 --> 00:46:14.420
So, for example,
if I'm doing line breaking,

00:46:14.420 --> 00:46:16.800
it's acceptable to
break after the hyphen.

00:46:16.800 --> 00:46:19.840
But if I'm doing word breaking,
that is determining

00:46:20.140 --> 00:46:24.000
what constitutes a word,
either for double-clicking or

00:46:24.000 --> 00:46:28.350
for doing whole word searching,
then breaking in the middle

00:46:28.350 --> 00:46:30.350
of that is not acceptable.

00:46:31.080 --> 00:46:34.400
So line breaking and word
breaking are different.

00:46:34.450 --> 00:46:37.200
At the moment,
the only APIs that are available

00:46:37.200 --> 00:46:42.360
for doing this kind of breaking
operate at the Unicar array level,

00:46:42.360 --> 00:46:44.080
so that's the Unicode utilities.

00:46:44.080 --> 00:46:48.990
The first step is to create a
text break locator by calling

00:46:48.990 --> 00:46:52.990
uccreateTextBreakLocator,
and you specify when you

00:46:53.110 --> 00:46:56.720
create it which kinds of text
boundaries you're interested in,

00:46:56.720 --> 00:47:00.720
whether it's a cluster boundary or
a word boundary or a line boundary.

00:47:01.000 --> 00:47:05.940
And then you can call ucfindTextBreak to
iterate through the breaks in your text,

00:47:06.010 --> 00:47:09.200
either in a forward
or backward direction.

00:47:09.260 --> 00:47:11.280
If you're interested
in cluster boundaries,

00:47:11.280 --> 00:47:15.150
then as I mentioned earlier in the talk,
there's CFString, get range of composed

00:47:15.150 --> 00:47:18.380
characters at index,
which works at the CFString level.

00:47:18.380 --> 00:47:21.720
But if you need line or word breaks,
then you need to call

00:47:21.760 --> 00:47:23.400
the UniCode utilities.

00:47:26.600 --> 00:47:29.840
Okay, the last topic that we're
going to cover is dates,

00:47:29.840 --> 00:47:33.700
times, and numbers.

00:47:33.780 --> 00:47:38.000
So there are several things you
need to be able to do with dates,

00:47:38.000 --> 00:47:39.340
times, and numbers.

00:47:39.380 --> 00:47:43.750
One is to convert a date that's in
a binary format or a time into a

00:47:43.750 --> 00:47:47.780
string to display it to the end user,
or the user might have typed a date

00:47:47.780 --> 00:47:51.010
or a time into a text entry field,
and you need to convert it back

00:47:51.010 --> 00:47:54.800
to a binary number so you can
perform an operation on it.

00:47:54.840 --> 00:47:58.760
And in the old world, there were several
APIs available for that.

00:47:58.760 --> 00:48:02.480
I'm not going to read them all off,
but they're all deprecated now.

00:48:02.480 --> 00:48:05.440
In Panther,
we introduced CFDateFormatter,

00:48:05.440 --> 00:48:09.420
which is a new set of APIs in
Core Foundation that do

00:48:09.690 --> 00:48:11.870
this in the UniCode world.

00:48:12.490 --> 00:48:16.240
And so we'll go through
a small example here.

00:48:16.240 --> 00:48:22.180
Again, CFDateFormatter has a fair number
of APIs that we don't have time

00:48:22.230 --> 00:48:25.760
to go into detail on all of them,
so I'll just go through a short example.

00:48:25.760 --> 00:48:32.430
You can use CFDateFormatter
createStringWithAbsoluteTime to use

00:48:32.430 --> 00:48:38.060
a CFDateFormatter and convert time,
a binary number, into a string.

00:48:38.700 --> 00:48:41.770
If you're going in the other direction,
you use CFDateFormatter

00:48:41.860 --> 00:48:43.460
getAbsoluteTime from string.

00:48:43.460 --> 00:48:46.790
Again, you pass a CFDateFormatter
and the string,

00:48:46.790 --> 00:48:49.180
and you'll get back a binary time.

00:48:52.130 --> 00:48:54.820
Thirdly,
CFDate formatters have properties

00:48:54.820 --> 00:48:58.540
that you can set on them that
control how the formatting is done.

00:48:58.540 --> 00:49:03.040
And you can use CFDate formatter
set property to set a particular

00:49:03.040 --> 00:49:04.380
property on the date formatter.

00:49:04.380 --> 00:49:07.700
So here's a complete
example we'll go through.

00:49:07.700 --> 00:49:10.320
First, we create our date formatter.

00:49:10.320 --> 00:49:12.490
Again,
we pass null to indicate the standard

00:49:12.660 --> 00:49:14.920
storage allocator for core foundation.

00:49:15.800 --> 00:49:19.720
We need to pass a locale to specify what
kind of date formatting we're doing,

00:49:19.720 --> 00:49:22.420
because the date formatting for, say,
U.S.

00:49:22.420 --> 00:49:25.790
English is very different from
that for Japanese or German or

00:49:25.790 --> 00:49:27.040
Dutch or what have you.

00:49:27.040 --> 00:49:31.560
So we call CFLocale copy current,
which gives us back the

00:49:31.560 --> 00:49:33.700
user's current locale.

00:49:33.700 --> 00:49:35.840
Now, if you were doing this
in a real application,

00:49:35.840 --> 00:49:38.610
you'd want to save the user's
current locale so that you

00:49:38.610 --> 00:49:42.010
don't keep calling CFLocale copy
current over and over again.

00:49:42.020 --> 00:49:44.440
Because, first of all,
you'd get a lot of copies.

00:49:45.000 --> 00:49:47.500
And second of all,
you want to take a snapshot of

00:49:47.600 --> 00:49:51.160
the user's current locale so
that you get consistent results.

00:49:52.820 --> 00:49:57.780
The other thing we need to specify when
we're creating our CFDate formatter is

00:49:57.780 --> 00:49:59.740
what style of date and time we want.

00:49:59.740 --> 00:50:03.230
In this case,
we're saying we want the long date

00:50:03.230 --> 00:50:05.620
style and the long time style.

00:50:07.960 --> 00:50:13.000
And the next thing we're going to do is,
since in this example we're

00:50:13.080 --> 00:50:17.280
going to convert a date entered
by the user into a binary time,

00:50:17.280 --> 00:50:21.900
we're going to set the lenient
property on the date-time formatter.

00:50:21.900 --> 00:50:25.780
And we do that by calling
CFDateFormatterSetProperty,

00:50:25.780 --> 00:50:31.680
passing the formatter and the key for the
lenient property and setting it to true.

00:50:32.510 --> 00:50:37.020
Now, what that's used for is,
if you don't set this property,

00:50:37.020 --> 00:50:41.240
when you try to convert a date or
time string to a binary number,

00:50:41.240 --> 00:50:46.360
CFDateFormatter will try to match
it exactly against the template

00:50:46.360 --> 00:50:49.630
that's used for formatting dates,
for converting a date from

00:50:49.720 --> 00:50:51.060
a binary number to a string.

00:50:51.060 --> 00:50:53.320
And if it doesn't exactly
match that template,

00:50:53.320 --> 00:50:54.760
the conversion will fail.

00:50:54.760 --> 00:50:59.380
What the lenient property does is it
sets the date formatter so that it will

00:50:59.380 --> 00:51:01.900
try as hard as possible to interpret.

00:51:02.320 --> 00:51:06.480
The input string as a date or time,
even if it doesn't match the

00:51:06.480 --> 00:51:08.740
template that it's expecting.

00:51:08.740 --> 00:51:12.730
So you pretty much always
want to set this unless you're

00:51:12.730 --> 00:51:15.220
doing some kind of validation.

00:51:16.960 --> 00:51:19.730
And the final call we
make is get absolute,

00:51:19.730 --> 00:51:23.360
CFDate formatter get
absolute time from string.

00:51:23.360 --> 00:51:27.710
We pass our CFDate formatter, the string,
that's the input.

00:51:27.750 --> 00:51:31.020
You have the ability
to pass some options,

00:51:31.020 --> 00:51:32.980
but we're passing null in this case.

00:51:32.980 --> 00:51:38.810
And finally, you pass a pointer to the
CF absolute time to be filled in.

00:51:42.630 --> 00:51:46.610
Now, sometimes you have to do
operations on dates that,

00:51:46.720 --> 00:51:49.700
other than converting them to
strings or converting them back

00:51:49.700 --> 00:51:52.990
from strings to a binary number,
sometimes you need to

00:51:52.990 --> 00:51:54.900
do calendar operations.

00:51:54.900 --> 00:51:58.440
An example might be,
take this date and add one month,

00:51:58.440 --> 00:52:00.840
or take this date and add one year.

00:52:02.180 --> 00:52:06.920
And so in the Script Manager world,
there were APIs like toggle date and

00:52:06.920 --> 00:52:12.850
validate and long date to seconds and
long seconds to date that converted

00:52:13.600 --> 00:52:19.740
between the binary form of time and
a structure which specified the year,

00:52:19.740 --> 00:52:21.600
month, day, et cetera, separately.

00:52:21.600 --> 00:52:27.180
So the time for new APIs,
the time type for new

00:52:27.180 --> 00:52:30.660
APIs is CF absolute time.

00:52:31.440 --> 00:52:34.460
And for a while,
there's been a set of APIs for

00:52:34.560 --> 00:52:38.440
CF absolute time for doing computations
with the Gregorian calendar.

00:52:38.440 --> 00:52:42.860
And those were, I don't know what release
they were introduced in,

00:52:42.860 --> 00:52:44.810
but they've been in for
a couple of releases now.

00:52:44.820 --> 00:52:48.310
But those APIs can't handle
non-Gregorian calendars,

00:52:48.310 --> 00:52:51.400
which we're adding more
support for in Tiger.

00:52:51.400 --> 00:52:54.690
And so we're introducing a new type,
CF calendar.

00:52:54.720 --> 00:52:56.760
It's a new core foundation type.

00:52:57.000 --> 00:53:00.700
And it's a set of APIs that will
work with any kind of calendar.

00:53:00.700 --> 00:53:03.730
And so we're using the new type,
CF calendar, to do calendar computations

00:53:03.740 --> 00:53:05.700
such as toggling dates,
validating dates,

00:53:05.700 --> 00:53:07.880
and getting components of dates.

00:53:07.910 --> 00:53:12.220
And this API did not
make the preview release,

00:53:12.330 --> 00:53:16.290
the WWDC preview release,
but it is something we're

00:53:16.290 --> 00:53:17.610
working on for Tiger.

00:53:17.810 --> 00:53:21.510
So I'm just going to tell you a
little bit about it today since

00:53:21.510 --> 00:53:23.490
you can't work with it yet.

00:53:23.850 --> 00:53:27.650
CF Calendar can do things
like create a set of calendar

00:53:27.650 --> 00:53:29.740
values to an absolute time.

00:53:29.740 --> 00:53:32.900
So, for example, if you give it a year,
a month, and a day,

00:53:32.900 --> 00:53:35.770
you can convert that to an absolute time.

00:53:35.780 --> 00:53:38.090
It can also go in the other direction.

00:53:38.090 --> 00:53:41.170
It can take an absolute time
and pick out the calendar

00:53:41.170 --> 00:53:43.340
components that correspond to it.

00:53:44.160 --> 00:53:47.740
And finally,
it can do toggling operations,

00:53:47.740 --> 00:53:52.960
such as taking an absolute time
and adding a fixed quantity to it,

00:53:53.100 --> 00:53:55.040
such as a year, a month, or a day.

00:53:55.040 --> 00:54:00.000
So this is the multi-calendar
replacement for the Gregorian calendar

00:54:00.000 --> 00:54:03.600
APIs that are in there right now,
and look for it in a

00:54:03.710 --> 00:54:05.700
Tiger release coming soon.

00:54:10.330 --> 00:54:13.930
Well, very similar to dates and times,
we also need to be able to convert

00:54:14.000 --> 00:54:18.850
numbers between a binary format and
a string that a user can understand.

00:54:18.970 --> 00:54:23.130
So, and again, that needs to be done in a
locale-sensitive way because different

00:54:23.130 --> 00:54:28.660
countries have different conventions
for the way that numbers are formatted.

00:54:28.660 --> 00:54:33.610
In the WorldText world,
there were APIs available for doing that.

00:54:33.750 --> 00:54:36.760
In Panther,
we introduced CFNumber Formatter,

00:54:36.760 --> 00:54:39.060
which is the UniCode equivalent.

00:54:40.270 --> 00:54:41.820
And again,
we'll go through a short example.

00:54:41.820 --> 00:54:47.190
CFNumberFormatter has several APIs that
we don't have time to go into.

00:54:47.560 --> 00:54:51.440
You can create a string with a
value using CFNumberFormatter,

00:54:51.440 --> 00:54:53.480
and you just pass the formatter.

00:54:53.600 --> 00:54:58.020
You have to specify the type of
the value because it could be,

00:54:58.100 --> 00:55:03.040
say, a floating point number, a double,
a long, what have you.

00:55:03.040 --> 00:55:03.040
So you need to specify what type it is.

00:55:03.290 --> 00:55:05.490
You can also go in the other direction.

00:55:05.610 --> 00:55:10.180
You can take a string and
interpret it as a number using

00:55:10.180 --> 00:55:13.400
CFNumberFormat or GetValueFromString.

00:55:13.730 --> 00:55:16.430
And again, you pass the format or the
string and some other options,

00:55:16.430 --> 00:55:17.590
and you'll get a number out.

00:55:19.470 --> 00:55:21.960
Finally,
you can also set the format that's

00:55:22.000 --> 00:55:23.880
used for a number formatter.

00:55:23.940 --> 00:55:26.350
If you create a number
formatter with a locale,

00:55:26.440 --> 00:55:28.900
you'll get the default
format for that locale.

00:55:28.900 --> 00:55:33.020
But number formatters use a formatting
string that is very similar to the

00:55:33.020 --> 00:55:37.460
pattern string that you might see in
a spreadsheet program such as Excel.

00:55:37.860 --> 00:55:42.940
You can set your own format strings
to format numbers in a particular way.

00:55:43.020 --> 00:55:47.070
You do that by calling
CFNumber.formatter.set.format and

00:55:47.070 --> 00:55:50.740
passing a string that represents
the format pattern to use.

00:55:50.740 --> 00:55:53.140
Here's an example.

00:55:53.140 --> 00:55:54.960
We'll format a number.

00:55:54.960 --> 00:56:00.900
We create our number formatter using,
again, the default storage allocator.

00:56:00.900 --> 00:56:04.580
Again, we pass a copy of the
user's current locale.

00:56:04.580 --> 00:56:07.780
And again,
you want to save that away as opposed to,

00:56:07.780 --> 00:56:10.150
getting it every time
you make this API call.

00:56:10.200 --> 00:56:12.670
And in this case,
we're saying we want a number formatter

00:56:12.670 --> 00:56:16.080
that uses the currency style because
we're going to be formatting currency.

00:56:16.240 --> 00:56:18.840
We have a double,
which stores the currency

00:56:18.840 --> 00:56:20.450
amount we want to format.

00:56:20.450 --> 00:56:22.690
It's a floating point number 42.

00:56:22.900 --> 00:56:27.110
We call
CFNumber.formatter.createStringWithValue.

00:56:27.280 --> 00:56:30.040
Again, the default storage allocator.

00:56:30.040 --> 00:56:34.370
We pass the number formatter
that we created two lines back.

00:56:34.520 --> 00:56:37.380
We specify that we're passing a double.

00:56:37.860 --> 00:56:39.860
And then we pass the
address of the variable.

00:56:39.860 --> 00:56:45.070
And this API will then return a
string with that number formatted as

00:56:45.070 --> 00:56:48.620
currency according to the conventions
of the user's current locale.

00:56:53.150 --> 00:56:58.060
So that has been our whirlwind
tour of the Unicode APIs that

00:56:58.090 --> 00:56:59.660
are replacements for WorldScript.

00:56:59.660 --> 00:57:04.430
Again, we did not have time to go into
detail on all of them because

00:57:04.430 --> 00:57:06.710
there are a lot of APIs out there.

00:57:06.720 --> 00:57:11.680
But the goal of this presentation
was to help you to understand how

00:57:11.680 --> 00:57:16.270
to translate a particular piece of
your existing WorldScript application

00:57:16.270 --> 00:57:17.670
to the Unicode world.

00:57:18.080 --> 00:57:21.320
So hopefully this application,
this presentation,

00:57:21.320 --> 00:57:24.260
gave you the pointers you
need to know where to go in

00:57:24.260 --> 00:57:26.210
the documentation to do that.

00:57:29.360 --> 00:57:32.300
If you have further questions,
the first person you should

00:57:32.460 --> 00:57:36.000
contact is Xavier Legault,
who is the representative

00:57:36.000 --> 00:57:38.860
for these technologies in
worldwide developer relations.

00:57:38.860 --> 00:57:43.380
You can also contact me,
but please do try Xavier first.

00:57:47.460 --> 00:57:51.560
Rather than give you a long
list of URLs to go to for

00:57:51.560 --> 00:57:56.330
information on Unicode APIs,
there's a one-stop shopping page,

00:57:56.330 --> 00:57:57.770
and this is the URL.

00:57:58.030 --> 00:58:01.230
If you go to our Unicode
Reference Library page,

00:58:01.350 --> 00:58:05.480
you'll find links to all the API sets
and all the documentation you need to

00:58:05.580 --> 00:58:07.810
convert your application to Unicode.
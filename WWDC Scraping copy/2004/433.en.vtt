WEBVTT

00:00:12.430 --> 00:00:16.040
Good morning everyone,
welcome to session 433.

00:00:16.040 --> 00:00:20.170
Please welcome software
engineer David McLeod.

00:00:26.140 --> 00:00:26.510
Good morning.

00:00:26.690 --> 00:00:28.530
Thank you for coming out.

00:00:28.620 --> 00:00:31.900
I'm glad to see there's people here
interested in making custom HIViews.

00:00:31.940 --> 00:00:36.060
That means you're getting our message
that HIView is the way to go forward

00:00:36.210 --> 00:00:39.530
and you're ready to do it with us.

00:00:50.300 --> 00:00:56.300
[Transcript missing]

00:00:56.920 --> 00:01:01.570
You make them special by doing
whatever things you do on

00:01:01.570 --> 00:01:03.000
the inside that we don't do.

00:01:03.140 --> 00:01:07.280
And you present that specialty
through your user interface.

00:01:07.380 --> 00:01:10.490
So almost everyone here has some
kind of custom user interface,

00:01:10.490 --> 00:01:16.500
whether you're drawing directly into a
window or you're using a custom control,

00:01:16.500 --> 00:01:19.960
you're using some other view system.

00:01:24.290 --> 00:01:25.320
Like Power Plant, for example.

00:01:25.320 --> 00:01:27.030
I'm trying to find a
nice way of saying that.

00:01:27.220 --> 00:01:29.640
So people are going to
be moving to HIViews.

00:01:29.860 --> 00:01:33.030
And you might have some
custom content already.

00:01:36.590 --> 00:01:40.790
As you go forward,
you're going to need to have HIView.

00:01:40.890 --> 00:01:44.040
HIView is the technology we're going
to use to move forward as we do

00:01:44.040 --> 00:01:47.600
things like resolution independence,
as we add new features to the toolbox.

00:01:47.860 --> 00:01:50.890
And you need to be there
with us to move forward.

00:01:52.890 --> 00:01:55.670
Basically, today I'm going to go over
how to make a custom HIView.

00:01:55.680 --> 00:01:59.320
It's going to be a primer
on how to make HIViews.

00:01:59.810 --> 00:02:02.200
So we're going to learn how
to subclass an HIVobject,

00:02:02.280 --> 00:02:05.360
how to create a custom HIView,
and just how to implement the

00:02:05.360 --> 00:02:09.240
basic behaviors that make a view.

00:02:09.390 --> 00:02:12.370
First, I'm going to give you a
little bit of background.

00:02:14.550 --> 00:02:18.700
The whole HIV toolbox on the
inside is object oriented.

00:02:18.700 --> 00:02:22.220
And HIViews are a subclass
of the main object,

00:02:22.220 --> 00:02:23.900
the HI object.

00:02:24.790 --> 00:02:29.340
All of the APIs associated with HIView
and HIObjects are object-oriented.

00:02:29.420 --> 00:02:35.720
They use C interfaces and
Carbon events to do the communication

00:02:35.750 --> 00:02:38.330
where the HIViews or HIObjects

00:02:39.240 --> 00:02:45.080
are the classes and the Carbon Events are
the methods or messages.

00:02:45.740 --> 00:02:49.160
And with those messages,
we put in Carbon Event parameters.

00:02:49.160 --> 00:02:54.080
And that's how you pass parameters
to and from your subclasses.

00:02:54.830 --> 00:02:57.340
So here it is.

00:02:57.380 --> 00:02:59.040
HIObject is really our base class.

00:02:59.170 --> 00:03:01.930
Everything's based off an HIObject.

00:03:02.550 --> 00:03:05.270
And like I said,
there's some messages that

00:03:05.270 --> 00:03:08.530
are associated with the class.

00:03:08.840 --> 00:03:11.010
There's also some properties.

00:03:15.360 --> 00:03:19.700
From that base class,
we have subclasses-- HIViews, windows,

00:03:19.700 --> 00:03:20.150
menus.

00:03:20.200 --> 00:03:21.920
There's a few other ones
I don't have up there,

00:03:21.920 --> 00:03:23.140
like toolbars, et cetera.

00:03:23.190 --> 00:03:27.290
But that's just to show that, you know,
HIobjects are the base class that

00:03:27.290 --> 00:03:31.660
we use to inherit from to produce
different objects within the toolbox.

00:03:31.790 --> 00:03:34.910
We're going to focus in on HIViews.

00:03:36.440 --> 00:03:42.430
So, HIViews are the subclasses-- HIViews,
like I said, with all of our classes,

00:03:42.790 --> 00:03:47.150
messages are the Carbon events,
and there's a few properties

00:03:47.360 --> 00:03:49.990
associated with the subclass.

00:03:52.260 --> 00:03:57.720
We use HIView to subclass to
make all of the views that

00:03:57.750 --> 00:04:01.560
you associate with the system,
so like pop-up buttons, radio buttons,

00:04:01.670 --> 00:04:02.620
check boxes, all of that.

00:04:02.660 --> 00:04:06.760
And this is where you would
subclass to make your custom HIView.

00:04:06.810 --> 00:04:11.280
Notably, you can also subclass an
existing subclass of an HIView.

00:04:11.610 --> 00:04:15.420
So in this example,
I would subclass a push button and just

00:04:15.420 --> 00:04:18.830
override some of the extra behaviors,
make my own custom kind of

00:04:19.000 --> 00:04:21.180
push button that inherits
from the existing push button.

00:04:23.180 --> 00:04:28.240
But I'm just going to focus on
subclassing HIView directly.

00:04:28.360 --> 00:04:31.350
So a custom HIView.

00:04:32.720 --> 00:04:35.690
is a subclass of HIObject
where you handle a few messages

00:04:35.920 --> 00:04:38.160
associated with construction.

00:04:40.100 --> 00:04:44.850
And it's also a subclass of HIView where
you handle a few messages that actually

00:04:44.850 --> 00:04:47.700
produce the behaviors of your HIView.

00:04:47.700 --> 00:04:51.740
And that's all that
makes up a custom HIView.

00:04:51.800 --> 00:04:54.730
Understanding these concepts is sort
of key in understanding how to subclass

00:04:54.760 --> 00:04:57.540
and make your own custom HIView.

00:04:57.640 --> 00:05:02.200
So next I'm going to get into just how
to go about doing that subclassing.

00:05:05.790 --> 00:05:08.540
First thing you're going to need
to do is register your subclass.

00:05:08.710 --> 00:05:12.480
And that means handling those events

00:05:12.670 --> 00:05:17.390
That are messages for the HI object
associated with doing construction,

00:05:17.450 --> 00:05:19.870
doing destruction when we're
finished with the object,

00:05:19.970 --> 00:05:21.680
and doing initialization.

00:05:21.730 --> 00:05:23.150
After that, you're ready to instantiate.

00:05:23.280 --> 00:05:25.190
That's all there is to it.

00:05:25.940 --> 00:05:28.920
So here's an example of how to
register your subclass using the

00:05:28.920 --> 00:05:34.150
HIObjectRegisterSubclass API.

00:05:35.350 --> 00:05:38.210
The first parameter that's
really important is the

00:05:38.370 --> 00:05:42.400
class ID of your subclass.

00:05:42.500 --> 00:05:50.330
And that's a reverse domain string
that you send to HIToolbox to tell it,

00:05:50.550 --> 00:05:53.260
To tell it how to identify your subclass.

00:05:53.270 --> 00:05:55.520
And throughout the process,
that is how you identify

00:05:55.520 --> 00:05:57.400
your subclass to HIToolbox.

00:05:57.510 --> 00:06:00.480
That's how we know what
we're talking about.

00:06:00.810 --> 00:06:03.550
Next, you want to tell it the base
class ID from which you're

00:06:03.550 --> 00:06:04.940
going to be subclassing.

00:06:04.940 --> 00:06:07.730
In today's examples where
I'm subclassing an HIView,

00:06:07.860 --> 00:06:11.200
I'll be passing in the
base class ID of an HIView.

00:06:11.200 --> 00:06:15.810
You can also use this to subclass
with the pop-up button's class

00:06:15.810 --> 00:06:18.540
ID or directly from an HI object.

00:06:18.640 --> 00:06:23.000
Notably, if you're subclassing
directly from an HI object,

00:06:23.170 --> 00:06:27.890
you can leave this blank because
that's the base subclass.

00:06:30.200 --> 00:06:32.660
And the last one I'm going to draw
attention to is the construct proc.

00:06:32.730 --> 00:06:36.760
This is the event handler that's
going to be handling the events,

00:06:36.800 --> 00:06:41.640
the construction events, the kEvent,
hIObject, construct, destruct,

00:06:41.740 --> 00:06:43.850
and initialize events.

00:06:44.780 --> 00:06:46.560
Here's an example in code of using it.

00:06:46.810 --> 00:06:51.520
So it's just like any other Carbon event
handler that you've used before.

00:06:51.870 --> 00:06:55.420
You set up a list of Carbon events
that you're interested in.

00:06:55.420 --> 00:06:58.030
It's just a set of class event pairs.

00:06:58.210 --> 00:07:00.390
In this case,
I'm interested in the KEvent

00:07:00.400 --> 00:07:03.530
class HIObject class of events,
and I'm interested in

00:07:03.740 --> 00:07:07.410
KEvent HIObject construct,
initialize, and destruct.

00:07:10.660 --> 00:07:16.050
Next, you call hiobjectregister subclass,
and this is where the reverse domain

00:07:16.050 --> 00:07:18.600
name class ID identifier comes into play.

00:07:18.690 --> 00:07:23.320
It identifies uniquely
my subclass by this ID.

00:07:23.560 --> 00:07:28.860
And you can see here in this example
that I'm subclassing from HIView

00:07:28.950 --> 00:07:32.350
using the public K HIView class ID.

00:07:33.920 --> 00:07:37.100
And I specify which handler is
going to be receiving these three

00:07:37.160 --> 00:07:38.690
events that I'm interested in.

00:07:38.800 --> 00:07:41.800
It's going to receive
them and handle them,

00:07:41.800 --> 00:07:44.670
dispatch them out appropriately.

00:07:45.180 --> 00:07:51.090
So here's an example of the meat of
what that event handler would look like.

00:07:51.290 --> 00:07:54.340
I handle those three events
that I've registered for.

00:07:54.370 --> 00:07:57.590
When I get the construct event,
I do something to handle construction.

00:07:57.670 --> 00:08:00.200
Similarly,
with initialization and destruction,

00:08:00.270 --> 00:08:01.990
I do something to handle those.

00:08:03.200 --> 00:08:07.570
So I want to get into exactly what
you would do in those three cases

00:08:07.570 --> 00:08:09.880
where you're handling those events.

00:08:13.470 --> 00:08:15.310
First, construction.

00:08:15.620 --> 00:08:17.360
It's very notable.

00:08:17.590 --> 00:08:23.250
It's called directly by the
instantiation mechanism of HIObject.

00:08:23.540 --> 00:08:24.760
It's not from an event handler stack.

00:08:24.850 --> 00:08:27.900
And this is really important
because under normal circumstances

00:08:27.900 --> 00:08:30.900
with Carbon event handlers,
you can call next event handler and let

00:08:30.900 --> 00:08:32.340
some of the default behavior happen.

00:08:32.340 --> 00:08:34.730
But there's no event
handler stack in place,

00:08:34.730 --> 00:08:36.170
so you just can't do that.

00:08:36.170 --> 00:08:38.100
Really bad things will happen.

00:08:38.850 --> 00:08:42.240
When you get the construction event,
that's the time when your

00:08:42.240 --> 00:08:46.920
subclass does its allocation or
instantiates maybe a C++ class.

00:08:46.960 --> 00:08:50.060
Any of the allocation that's
going to occur happens here.

00:08:50.150 --> 00:08:54.180
It's not time to do initialization
yet because things might

00:08:54.180 --> 00:08:55.440
not be set up sufficiently.

00:08:55.440 --> 00:08:57.290
You do that later on.

00:09:01.160 --> 00:09:04.900
And the really-- I think this
is the only tricky concept in

00:09:04.900 --> 00:09:08.230
the whole subclassing mechanism.

00:09:08.310 --> 00:09:12.970
The keventparam
HIObjectInstance parameter

00:09:13.530 --> 00:09:16.640
During the construction handling,
on the way in,

00:09:16.760 --> 00:09:19.910
what you get is a base HIObjectRef.

00:09:19.970 --> 00:09:24.560
That's what's been constructed so far
by the HIObject subclassing mechanism.

00:09:24.560 --> 00:09:28.900
That's the ObjectRef that you're going
to have for the rest of the life of

00:09:28.900 --> 00:09:31.440
the instantiation of your subclass.

00:09:31.870 --> 00:09:35.040
During the construction handling,
on the way in,

00:09:35.040 --> 00:09:38.360
what you get is a base HIObjectRef.

00:09:38.360 --> 00:09:38.710
That's what's been constructed so far
by the HIObject subclassing mechanism.

00:09:38.710 --> 00:09:38.710
That's the ObjectRef that you're going
to have for the rest of the life of

00:09:38.710 --> 00:09:38.710
the instantiation of your subclass.

00:09:38.860 --> 00:09:41.420
So on the way in,
it's that HI object ref.

00:09:41.460 --> 00:09:43.620
On the way out,
you want to set the parameter

00:09:43.950 --> 00:09:46.900
to whatever the instance data
is that you've allocated.

00:09:46.960 --> 00:09:54.620
And that's important because from now on,
whenever your subclass is called,

00:09:54.680 --> 00:09:57.100
that instance data is going
to be passed in as the user

00:09:57.100 --> 00:09:58.620
data to your event handler.

00:09:58.750 --> 00:10:01.780
And that's how you can get
the reference to what your

00:10:02.000 --> 00:10:03.880
instance is in your subclass.

00:10:05.510 --> 00:10:11.280
So here's an example of handling a
k-event HI object construction event.

00:10:11.590 --> 00:10:13.840
Just a little reminder,
don't call Next Event Handler.

00:10:13.990 --> 00:10:14.500
Bad stuff.

00:10:14.660 --> 00:10:16.440
Bad stuff's going to happen.

00:10:16.520 --> 00:10:17.640
I do some allocation.

00:10:17.800 --> 00:10:19.600
I have a little data structure.

00:10:19.600 --> 00:10:20.760
It's not really important what's in it.

00:10:20.860 --> 00:10:22.010
I call it my view data.

00:10:22.180 --> 00:10:25.790
The only important thing to note
is that I have a spot in there to

00:10:26.170 --> 00:10:33.370
remember my HI object ref that I get
on the way in from construction.

00:10:34.700 --> 00:10:41.050
I get that HIObjectRef from
KEVENT_PARAM HIObjectInstance,

00:10:41.050 --> 00:10:45.100
and I store it in my allocation space,
the space that I've allocated.

00:10:45.100 --> 00:10:49.840
And on the way out,
you can see that I've stored

00:10:49.840 --> 00:10:52.860
that allocated instance data
back in and overwritten the

00:10:52.920 --> 00:10:54.400
KEVENT_PARAM HIObjectInstance.

00:10:54.520 --> 00:10:56.770
From now on,
whenever my event handler gets called,

00:10:56.770 --> 00:11:00.040
I'm going to get that instance data,
and I can use it to

00:11:00.480 --> 00:11:02.820
implement my subclass.

00:11:06.200 --> 00:11:10.990
I like to talk about destruction first,
but I just kind of reordered a bit.

00:11:11.100 --> 00:11:12.430
The destruction is going
to happen way at the end.

00:11:12.470 --> 00:11:15.720
So before the destruction happens,
you're going to do initialization.

00:11:15.720 --> 00:11:18.660
When you get a K event,
HIobject initialized event,

00:11:18.930 --> 00:11:21.980
that means that construction
happened successfully.

00:11:21.980 --> 00:11:22.730
The allocation is okay.

00:11:22.830 --> 00:11:23.710
Everything is ready to go.

00:11:23.710 --> 00:11:24.650
It's time to set things up.

00:11:29.000 --> 00:11:31.500
When the initialization
event comes to you,

00:11:31.580 --> 00:11:35.340
all of the initialization parameters
are set as Carbon Event parameters

00:11:35.550 --> 00:11:36.450
in the incoming event.

00:11:36.540 --> 00:11:38.750
So you can just extract those,
if there are any,

00:11:38.940 --> 00:11:40.500
and do whatever you want with them.

00:11:40.500 --> 00:11:43.770
Store them into your instance data or
set up things or do whatever you want.

00:11:44.910 --> 00:11:46.600
This phase is optional.

00:11:46.600 --> 00:11:51.380
Not everybody's going to
have instance initialization,

00:11:51.380 --> 00:11:53.510
but actually I think it
would be pretty common.

00:11:53.680 --> 00:11:54.820
You don't have to do it.

00:11:54.850 --> 00:11:56.360
Nothing bad will happen.

00:11:56.430 --> 00:11:59.010
I think I forgot to mention
with a construction event,

00:11:59.010 --> 00:12:00.540
it's absolutely required.

00:12:00.540 --> 00:12:02.720
If you don't do it,
no construction is going to

00:12:02.720 --> 00:12:05.880
happen and the rest of the
presentation is not going to happen.

00:12:05.880 --> 00:12:09.080
So you definitely have
to handle construction.

00:12:11.130 --> 00:12:15.080
So here's an example of handling
the initialization event.

00:12:15.200 --> 00:12:16.800
First of all,
you want to call next event handler.

00:12:16.800 --> 00:12:20.690
That's important because it gives your
superclasses a chance to initialize.

00:12:20.700 --> 00:12:24.070
If you're familiar with C++,
that's just like passing on

00:12:24.070 --> 00:12:27.970
your constructor up to the
other superclass constructor.

00:12:28.070 --> 00:12:33.250
So you've got to give your superclass
a chance to initialize itself as well.

00:12:34.180 --> 00:12:37.840
You check the return value from the call
next event handler and make sure that

00:12:37.840 --> 00:12:43.410
your superclass initialized successfully,
because if it didn't,

00:12:43.410 --> 00:12:47.730
you certainly aren't
really going to need to.

00:12:48.080 --> 00:12:49.840
And then it's time to handle
your own initialization.

00:12:49.840 --> 00:12:53.120
Like I said,
you just use the incoming event,

00:12:53.170 --> 00:12:57.770
you extract parameters from
it using GetEventParameter,

00:12:57.770 --> 00:12:58.870
and do whatever you want with them.

00:12:59.000 --> 00:13:02.180
And this is also a time when you
can modify the initialization

00:13:02.220 --> 00:13:05.990
event and set things like your
feature bits and that sort of thing.

00:13:05.990 --> 00:13:08.730
Example of it here.

00:13:10.200 --> 00:13:12.870
Lastly, after everything's done and
everything's being torn down,

00:13:12.870 --> 00:13:14.200
you'll get a destruction event.

00:13:14.200 --> 00:13:19.780
Again, this is not being called
from the normal event stack,

00:13:19.880 --> 00:13:21.800
so don't call NextEventHandler.

00:13:21.800 --> 00:13:25.510
Even if we did do that and we
allowed you to tell your parents to

00:13:25.550 --> 00:13:30.030
destruct themselves before you did,
that would be a very bad thing.

00:13:30.030 --> 00:13:35.340
It's like calling delete parent
in your C++ destruct method.

00:13:35.340 --> 00:13:36.910
It's a bad idea.

00:13:37.520 --> 00:13:38.340
This is not optional.

00:13:38.340 --> 00:13:40.750
You have to handle your destruction.

00:13:41.110 --> 00:13:43.120
To get rid of any allocated data.

00:13:43.120 --> 00:13:46.500
If you don't handle this event,

00:13:47.290 --> 00:13:49.360
Destruction will fail.

00:13:49.360 --> 00:13:53.280
And when you do destruction,
that's your time to deallocate

00:13:53.380 --> 00:13:55.190
anything you allocated during
the construction phase.

00:13:55.200 --> 00:14:01.160
If you allocated some memory or if
you instantiated a C++ subclass,

00:14:01.160 --> 00:14:10.230
it's time for you to either free the
memory or delete the C++ subclass.

00:14:10.540 --> 00:14:13.130
Again, emphasizing don't call
Next Event Handler.

00:14:13.370 --> 00:14:14.340
I say it lots in here.

00:14:14.340 --> 00:14:16.300
It's going to be in the
sample code that you see.

00:14:16.300 --> 00:14:17.680
It's going to be in Curt's demo.

00:14:17.860 --> 00:14:18.600
You just don't want to do it.

00:14:18.600 --> 00:14:19.580
It's also in the header docs.

00:14:19.670 --> 00:14:21.320
Just don't call Next Event Handler
when you're doing

00:14:21.390 --> 00:14:23.550
construction and destruction.

00:14:24.960 --> 00:14:27.060
And as you can see,
this is just my time to

00:14:27.160 --> 00:14:28.320
clean up my allocated data.

00:14:28.480 --> 00:14:33.400
One important note here is that
you will get a destruct event if

00:14:33.400 --> 00:14:35.060
initialization was unsuccessful.

00:14:35.090 --> 00:14:39.920
So you have to be able to handle
destroying a partially initialized

00:14:39.920 --> 00:14:42.590
or an uninitialized subclass.

00:14:42.760 --> 00:14:46.350
So if construction went okay
but initialization didn't,

00:14:46.570 --> 00:14:48.950
you'll still get a destruct event,
so you have that

00:14:49.020 --> 00:14:51.130
opportunity to deallocate.

00:14:53.950 --> 00:14:54.630
That's pretty much it.

00:14:54.780 --> 00:15:00.490
So after you install that event handler,
you're ready to instantiate.

00:15:01.190 --> 00:15:04.680
So you have to register the subclass
using that API I mentioned previously.

00:15:04.720 --> 00:15:07.700
And to do that,
you create an initialization event.

00:15:07.770 --> 00:15:10.850
To actually instantiate,
you create an initialization event,

00:15:10.920 --> 00:15:14.670
stuff any parameters in that
you want to end up being passed

00:15:14.670 --> 00:15:18.540
to your subclass instantiation,
and then call hi object create

00:15:18.820 --> 00:15:22.790
using that initialization
event that you just created.

00:15:23.740 --> 00:15:24.740
Here's an example of that.

00:15:24.740 --> 00:15:25.820
I create an event.

00:15:25.920 --> 00:15:30.690
It's a kEvent class HIObject,
kEvent HIObject initialize event.

00:15:30.700 --> 00:15:34.440
It's a real standard
way of making an event.

00:15:34.610 --> 00:15:39.440
I made up a fake value here
to stuff into the event.

00:15:39.730 --> 00:15:43.600
The initialization event has a parameter.

00:15:43.600 --> 00:15:46.100
It's just a float I push in there.

00:15:46.110 --> 00:15:47.830
And I call hiObjectCreate.

00:15:47.840 --> 00:15:52.680
And you'll note here that hiObjectCreate
takes the reverse domain class

00:15:52.680 --> 00:15:54.420
ID that I registered my class with.

00:15:54.540 --> 00:15:57.240
That's how you tell Toolbox, hey,
that's the thing I registered.

00:15:57.240 --> 00:15:59.630
That's how I want you to
instantiate right now.

00:15:59.740 --> 00:16:05.190
So that's how you get your subclass
instance to be the one you want.

00:16:06.970 --> 00:16:08.160
I'd show you a demo.

00:16:08.200 --> 00:16:09.070
There's not much to demo yet.

00:16:09.140 --> 00:16:11.460
You've just made an instance
that doesn't do anything.

00:16:11.460 --> 00:16:15.520
It's not--that's just how to
make--that's just how to make

00:16:15.660 --> 00:16:16.870
a subclass of an HI object.

00:16:16.970 --> 00:16:18.140
It's not in anything.

00:16:18.140 --> 00:16:18.760
It doesn't draw.

00:16:18.760 --> 00:16:20.330
It doesn't have any behavior
or anything like that.

00:16:20.360 --> 00:16:22.830
So I'm not going to show you anything.

00:16:23.680 --> 00:16:25.890
To give you something to show,
you probably want to implement

00:16:25.890 --> 00:16:27.000
the simple view behavior.

00:16:27.130 --> 00:16:35.520
Simple view behaviors are drawing,
hit testing, clicking, keyboard handling,

00:16:35.590 --> 00:16:36.600
and definitely accessibility.

00:16:36.600 --> 00:16:39.970
These are the simple basic
behaviors that you're going to

00:16:39.970 --> 00:16:41.900
want in almost every HIView.

00:16:43.370 --> 00:16:47.800
And really, they just all map onto either
directly onto a Carbon event or

00:16:47.800 --> 00:16:49.740
onto a class of Carbon events.

00:16:49.770 --> 00:16:51.800
Really straightforward.

00:16:53.220 --> 00:16:56.180
So say you wanted to add some
drawing to your HIView subclass.

00:16:56.190 --> 00:16:59.810
You want to handle the
K event control draw event.

00:17:00.680 --> 00:17:05.780
Really important concept with HIView
drawing is getting this event,

00:17:05.890 --> 00:17:07.410
that's the only place you ever draw.

00:17:07.670 --> 00:17:09.140
You don't draw willy-nilly.

00:17:09.490 --> 00:17:15.060
You invalidate your views,
and then when the appropriate time comes,

00:17:15.090 --> 00:17:16.800
the view system will ask you to draw.

00:17:17.040 --> 00:17:23.510
And that's how we achieve the
compositing and the efficient drawing.

00:17:23.980 --> 00:17:26.780
So like I said up here,
validation is your friend.

00:17:26.780 --> 00:17:30.880
You want to invalidate and
then let the toolbox tell you

00:17:30.900 --> 00:17:33.110
when a good time to draw is.

00:17:33.170 --> 00:17:36.370
When you get the draw event,
inside the event there's a CGContextRef,

00:17:36.450 --> 00:17:39.640
so you can extract that as
a parameter of the event.

00:17:39.700 --> 00:17:42.210
And the nice thing
about the CGContextRef,

00:17:42.220 --> 00:17:43.080
it's all set up for you.

00:17:43.080 --> 00:17:43.990
It's all clipped.

00:17:44.100 --> 00:17:47.500
It's transformed properly.

00:17:47.630 --> 00:17:51.300
It might be scaled if we're in
the future sometime and we're

00:17:51.300 --> 00:17:53.700
doing resolution independence.

00:17:54.230 --> 00:17:57.540
You don't have to worry about anything
like the Z order and you definitely

00:17:57.540 --> 00:18:01.530
don't have to erase behind like you did
with QuickDraw because painting is all

00:18:01.530 --> 00:18:04.010
happening in a nice composited stack.

00:18:05.840 --> 00:18:12.680
This concept also gives you
a context that is top left.

00:18:12.840 --> 00:18:14.910
Sorry, this list is left for me up here.

00:18:15.040 --> 00:18:15.730
It's all top left.

00:18:15.890 --> 00:18:19.090
You might not be used to that if
you've been making your own context

00:18:19.150 --> 00:18:22.590
in an event handler so far with a
user pane or that kind of thing.

00:18:22.590 --> 00:18:26.590
So the context is
already top left for you.

00:18:26.720 --> 00:18:28.510
And then you just go ahead and
do whatever kind of drawing you

00:18:28.520 --> 00:18:33.660
want in there with Quartz and
get your cool rendering effects.

00:18:36.100 --> 00:18:38.860
Adding a draw event handler is very easy.

00:18:38.860 --> 00:18:44.940
You just extend the -- this is the
class event list that I had before.

00:18:44.940 --> 00:18:47.580
I've just extended it by
putting a kEvent class control,

00:18:47.580 --> 00:18:50.370
kEvent control draw event onto it.

00:18:50.690 --> 00:18:55.440
And I register the handler
the same as I did before.

00:18:55.500 --> 00:18:58.510
And then you change your handler so
that it handles the KFN class control,

00:18:58.510 --> 00:18:59.440
KFN control draw.

00:18:59.450 --> 00:19:01.920
And then you do your drawing there.

00:19:02.100 --> 00:19:05.950
Here's the meat of what a
draw handler would look like.

00:19:06.230 --> 00:19:10.410
So basically,
extract the CG context ref out of

00:19:10.420 --> 00:19:13.390
the event using GetEventParameter.

00:19:16.640 --> 00:19:18.830
I have the reference to my HIView
that gets passed every time

00:19:18.870 --> 00:19:21.550
the event handler is called,
so I use that to get my view

00:19:21.550 --> 00:19:24.560
ref and I get the bounds of it,
and I just do some drawing.

00:19:24.560 --> 00:19:30.030
This simple drawing here does
a translucent red rectangle,

00:19:30.030 --> 00:19:31.200
I think.

00:19:31.260 --> 00:19:31.700
That's it.

00:19:31.760 --> 00:19:36.110
You know, you'd have a nice simple
HIView that draws a rectangle.

00:19:37.160 --> 00:19:38.700
You wouldn't actually see it though.

00:19:38.740 --> 00:19:39.860
I stuck this in here.

00:19:39.860 --> 00:19:41.560
This is an important step.

00:19:41.610 --> 00:19:45.460
If you were to just instantiate now,
you wouldn't see anything because

00:19:45.460 --> 00:19:47.370
that HIView has no parent.

00:19:47.410 --> 00:19:51.050
It's just off in ether somewhere.

00:19:52.250 --> 00:19:57.660
You need to add it to a window or add
it as a subview of a view in a window.

00:19:57.740 --> 00:20:00.300
So you want to either add it
to the content view of a window

00:20:00.800 --> 00:20:02.280
or some kind of parent view.

00:20:02.280 --> 00:20:04.410
And you also need to make it visible.

00:20:04.420 --> 00:20:06.670
It's made initially
invisible for efficiency.

00:20:06.730 --> 00:20:09.560
If you create it and then
after you create it you want

00:20:09.650 --> 00:20:12.510
to set a bunch of things,
you don't want something to happen

00:20:12.510 --> 00:20:15.420
to it and make it redraw over and
over while you're setting it up.

00:20:15.510 --> 00:20:17.390
So it's created initially invisible.

00:20:17.640 --> 00:20:20.400
You set it up, you know,
set the control value or whatever

00:20:20.400 --> 00:20:21.660
you're going to do on it.

00:20:21.820 --> 00:20:22.770
And then you make it visible.

00:20:22.900 --> 00:20:25.300
And only after you make it
visible are you going to see it.

00:20:25.570 --> 00:20:28.010
This is really one of the big
hurdles that people hit when

00:20:28.010 --> 00:20:29.370
they first make an HIView.

00:20:29.370 --> 00:20:30.490
It's like, I made it.

00:20:30.490 --> 00:20:31.560
It's not showing up.

00:20:31.560 --> 00:20:32.320
Where is it?

00:20:32.380 --> 00:20:33.390
You have to take these steps.

00:20:33.470 --> 00:20:34.310
They're very important.

00:20:34.400 --> 00:20:35.920
It's very common that they're forgotten.

00:20:35.920 --> 00:20:39.160
It's one of the questions we
answer or you guys help us answer

00:20:39.160 --> 00:20:40.980
on the Carbon Dev List often.

00:20:44.070 --> 00:20:46.630
So I'd like to ask Curt to come
up and just go through some of

00:20:46.630 --> 00:20:52.440
the things I showed to instantiate
a simple HIView subclass.

00:20:52.460 --> 00:20:53.300
Curt?

00:20:53.950 --> 00:20:55.070
Thank you, David.

00:20:59.280 --> 00:21:00.600
So if we could switch
to the demo machine,

00:21:00.650 --> 00:21:00.970
please.

00:21:01.040 --> 00:21:08.960
So basically what we're going to look at
here is just the HIView test application.

00:21:08.960 --> 00:21:10.320
Now this is just a sample code.

00:21:10.320 --> 00:21:13.910
It's available in
developer examples Carbon.

00:21:14.320 --> 00:21:20.180
But I want to walk through just making
a very simple subclass of HIView

00:21:20.450 --> 00:21:22.770
that does just a simple drawing.

00:21:24.040 --> 00:21:27.760
So let's go about looking how we do this.

00:21:27.760 --> 00:21:30.460
We're going to define HITestViewRegister.

00:21:30.460 --> 00:21:35.910
And during application initialization,
this function will be called because

00:21:35.920 --> 00:21:40.190
we need to register this subclass
with the HIObject subclassing system.

00:21:40.680 --> 00:21:43.530
And then we need to specify
that we're going to handle

00:21:43.540 --> 00:21:47.910
these HI object specific events.

00:21:47.910 --> 00:21:50.100
So, construct, initialize, and destruct.

00:21:50.150 --> 00:21:52.940
Now, as David mentioned,
construct and destruct are required.

00:21:53.190 --> 00:21:57.600
If you don't specify these,
registration will actually fail.

00:21:57.830 --> 00:22:01.140
And then,
HI object initialization is optional,

00:22:01.260 --> 00:22:04.850
but as David also mentioned,
that's probably where you'll

00:22:04.850 --> 00:22:07.350
handle most of your initialization.

00:22:08.030 --> 00:22:14.060
So you can see how the HIObject
specific events and the control,

00:22:14.060 --> 00:22:16.960
which are the view of specific events,
are kind of globbed together.

00:22:16.960 --> 00:22:20.170
This is all in the event list
that we're going to pass into the

00:22:20.220 --> 00:22:24.160
HIObject register subclass API.

00:22:24.320 --> 00:22:26.820
And for now,
we're just going to be looking

00:22:26.870 --> 00:22:28.760
at the KEventControl draw.

00:22:29.250 --> 00:22:33.330
Next, we register the subclass.

00:22:33.330 --> 00:22:39.560
As David mentioned,
we pass in our class ID,

00:22:39.560 --> 00:22:39.560
which we defined as "HIV"

00:22:44.800 --> 00:22:49.230
Next, we register the subclass.

00:22:49.250 --> 00:22:55.140
As David mentioned,
we pass in our class ID,

00:22:55.150 --> 00:22:59.190
which we defined as "HIV"

00:22:59.410 --> 00:23:01.400
We give it its construct practice.

00:23:01.400 --> 00:23:02.890
This is going to be our event handler.

00:23:02.900 --> 00:23:06.860
We're basically telling the event system
that these are the events that we're

00:23:06.890 --> 00:23:09.320
interested in with this event list.

00:23:09.320 --> 00:23:12.560
And when one of these events happens,
to call our callback,

00:23:12.640 --> 00:23:14.370
which is the view handler.

00:23:15.280 --> 00:23:19.530
And basically, this whole section is
in a one-shot section.

00:23:19.680 --> 00:23:23.130
And what we're doing there is
we define a static class ref.

00:23:23.190 --> 00:23:25.950
And so if you call this
particular function,

00:23:25.950 --> 00:23:29.510
if the application were to call this
particular function more than once,

00:23:29.510 --> 00:23:32.000
the registration would
happen multiple times.

00:23:32.050 --> 00:23:34.650
So basically, we just turn that one shot.

00:23:38.970 --> 00:23:46.510
Then, after it's registered and the
application wants to instantiate

00:23:46.510 --> 00:23:46.510
an instance of this class,

00:23:46.890 --> 00:23:49.140
Our handler is then called.

00:23:49.160 --> 00:23:52.260
Basically, as David mentioned,
we need to handle, deconstruct,

00:23:52.420 --> 00:23:54.410
and destruct events.

00:23:54.500 --> 00:23:57.880
and as you know, it's don't call,
call next event handler here.

00:23:57.880 --> 00:24:01.090
And then we'll also be
handling initialized as well.

00:24:01.480 --> 00:24:05.230
So when the instance is
to be constructed-- oh,

00:24:05.300 --> 00:24:08.330
and I should also mention that
we're going to be handling the draw.

00:24:08.400 --> 00:24:13.440
So after the instance is constructed
and then embedded into a view hierarchy,

00:24:13.440 --> 00:24:15.580
we'll also get this draw event as well.

00:24:15.610 --> 00:24:20.040
And since we're doing this as a
C interface-based method of doing this,

00:24:20.110 --> 00:24:25.730
first all of the data is going to
be allocated in the construct event.

00:24:25.770 --> 00:24:29.680
And then we'll just operate
on that data as well later on.

00:24:29.680 --> 00:24:32.460
Here, and this is where it is.

00:24:32.490 --> 00:24:36.640
So when we construct the instance,
we go ahead and malloc our data.

00:24:36.640 --> 00:24:39.390
Now, as David mentioned,
it doesn't really matter for the purposes

00:24:39.470 --> 00:24:42.860
of this example what that data is,
other than that we're going to be

00:24:42.860 --> 00:24:47.350
grabbing the HI object instance
and stuffing it into our data.

00:24:47.430 --> 00:24:51.450
And then finally, before returning,
we stuff a void pointer

00:24:51.640 --> 00:24:53.240
argument into the event.

00:24:53.400 --> 00:24:59.600
And this is how we'll reference or grab
our data out of the events as always.

00:24:59.690 --> 00:25:04.240
our draw and tracking and other
types of event handlers are called.

00:25:08.050 --> 00:25:11.000
After construction has
successfully happened,

00:25:11.000 --> 00:25:13.200
we'll get called to initialize.

00:25:13.220 --> 00:25:15.430
And so in our event handler,
we'll get the

00:25:15.430 --> 00:25:20.410
KEventHIObjectInitializeEvent,
which we then call this function for.

00:25:21.090 --> 00:25:25.170
And whoever's called us has set
up some parameters in the event.

00:25:25.180 --> 00:25:30.140
And so we grab those parameters out,
and we stuff them into our data store.

00:25:30.140 --> 00:25:32.540
And basically, for this example,
we're just going to be

00:25:32.550 --> 00:25:35.270
drawing a rectangle,
and we want to know the RGB values.

00:25:35.280 --> 00:25:38.110
So somebody stuffed
RGB values into the event.

00:25:38.180 --> 00:25:41.920
We're grabbing them out here and
stuffing them into our instance data.

00:25:43.520 --> 00:25:46.840
And then after we use this instance,
it's going to be drawing,

00:25:46.840 --> 00:25:49.380
the user's going to be tracking,
all this stuff is going to happen.

00:25:49.380 --> 00:25:53.220
When we need to tear it down,
we get an HIObject destruct event.

00:25:53.230 --> 00:25:57.230
And in that case,
we just call our function to destruct it,

00:25:57.230 --> 00:26:01.540
and we just free our data store
for this particular object.

00:26:03.780 --> 00:26:08.100
Once it's correctly instantiated,
you can embed it into your view

00:26:08.400 --> 00:26:11.390
hierarchy and make it visible.

00:26:11.390 --> 00:26:15.060
And at that point,
the draw message is going to

00:26:15.060 --> 00:26:16.930
get sent to your instance.

00:26:17.010 --> 00:26:21.110
And so here,
we're doing some very simple operation.

00:26:21.220 --> 00:26:24.150
We're going to set up to
draw a particular rectangle.

00:26:24.380 --> 00:26:28.790
And this is all basically
designed to have different colors,

00:26:28.790 --> 00:26:31.320
whether it's selected or whether
we're tracking or anything

00:26:31.320 --> 00:26:32.960
at that particular point.

00:26:33.010 --> 00:26:35.820
then we just draw that rectangle.

00:26:36.520 --> 00:26:39.300
So let's actually see this in action.

00:26:39.400 --> 00:26:40.480
It's very simple.

00:26:40.610 --> 00:26:46.320
So what we did in our main function
was we registered this subclass.

00:26:46.720 --> 00:26:51.600
We created a construct event
and then called hiObjectCreate,

00:26:51.630 --> 00:26:53.010
the instantiated object.

00:26:53.170 --> 00:26:55.420
We embedded that into this window.

00:26:55.460 --> 00:26:58.720
And the subclassing
system tells us to draw.

00:26:58.720 --> 00:27:01.420
And that's where we draw with
the context that it's given us.

00:27:01.480 --> 00:27:04.660
That's basically it for
this particular example.

00:27:04.710 --> 00:27:06.070
Thank you, Curt.

00:27:06.130 --> 00:27:08.520
If we can switch back to the slides.

00:27:09.320 --> 00:27:10.620
Well, that's just a simple HIView.

00:27:10.840 --> 00:27:12.200
All of our examples today are simple.

00:27:12.200 --> 00:27:15.200
You know, we could have written some
demo to do some fancy stuff,

00:27:15.240 --> 00:27:18.200
but all the focus would have been
on how we did the fancy drawing,

00:27:18.200 --> 00:27:20.200
how we did the fancy tracking.

00:27:20.200 --> 00:27:23.510
What we chose to do instead is use
the simple test HIView stuff that's

00:27:23.510 --> 00:27:25.200
available as sample code right now.

00:27:25.200 --> 00:27:28.200
You probably even have it on your
machine if you have a machine here.

00:27:28.270 --> 00:27:31.200
It's in Developer Examples something
something.

00:27:31.200 --> 00:27:35.310
If you search for
"HITestView," you'll find it.

00:27:37.530 --> 00:27:40.880
So Curt went through that,
but handling events like

00:27:40.970 --> 00:27:42.690
that and registering them,
you're doing the same

00:27:42.690 --> 00:27:43.520
thing over and over.

00:27:43.520 --> 00:27:45.230
It's just, you know,
we put some events in a list,

00:27:45.330 --> 00:27:47.600
and then you've got to handle
the event and dispatch it

00:27:47.640 --> 00:27:50.360
and take the parameters out,
and you're just going to be doing

00:27:50.370 --> 00:27:51.930
the same things over and over.

00:27:51.940 --> 00:27:54.020
Especially for event,
for HIobject subclassing,

00:27:54.020 --> 00:27:55.590
all those events are always the same.

00:27:55.590 --> 00:27:57.670
You're always going to be
doing the very same thing,

00:27:57.670 --> 00:27:59.070
so it's just a boilerplate.

00:27:59.100 --> 00:28:00.730
And that's kind of boring.

00:28:00.730 --> 00:28:03.980
You're just going to be, like I said,
doing the same things over and over.

00:28:05.180 --> 00:28:07.090
We don't do that on the
inside of HIToolbox.

00:28:07.190 --> 00:28:10.800
We actually have a C++ framework,
because this is no fun.

00:28:14.090 --> 00:28:15.570
And that's why we made HIFramework.

00:28:15.720 --> 00:28:22.790
So HIFramework is a lightweight
C++ framework for doing the

00:28:22.840 --> 00:28:25.390
subclassing of HI objects.

00:28:25.550 --> 00:28:27.920
and making custom HIViews.

00:28:27.970 --> 00:28:33.110
And it's really just a subset of what
we use internally to make our own

00:28:33.390 --> 00:28:35.290
Custom HIViews like,
well they're not custom for you

00:28:35.290 --> 00:28:38.540
as they're system HIViews like
the push button for example.

00:28:38.570 --> 00:28:41.490
We use a very similar
framework internally.

00:28:43.780 --> 00:28:48.170
T-Object wraps the HIObject class.

00:28:48.470 --> 00:28:53.250
Something notable about that is T-Object
doesn't exist in the public HI framework.

00:28:53.390 --> 00:28:55.050
We're going to be revving that next week.

00:28:55.220 --> 00:28:58.700
And it's just something we added in,
and I'll show you why in a minute.

00:28:58.950 --> 00:29:02.630
T-View wraps HIView.

00:29:03.210 --> 00:29:07.760
T-Object wraps the HIObject class.

00:29:07.760 --> 00:29:12.740
Something notable about that is T-Object
doesn't exist in the public HI framework.

00:29:12.740 --> 00:29:14.540
We're going to be revving that next week.

00:29:14.540 --> 00:29:18.330
And it's just something we added in,
and I'll show you why in a minute.

00:29:18.330 --> 00:29:20.500
T-View wraps HIView.

00:29:21.310 --> 00:29:24.820
And basically, all you have to do is
override a few methods,

00:29:24.840 --> 00:29:27.710
a few base methods,
and you will be able to

00:29:27.720 --> 00:29:30.130
subclass very quickly.

00:29:30.230 --> 00:29:33.250
So there's a register class method,
which I'll show.

00:29:33.600 --> 00:29:37.040
There's a static construct method,
which you'll have to make.

00:29:37.040 --> 00:29:42.200
And that's so that you can
specifically make your subclass

00:29:42.200 --> 00:29:45.320
instantiation statically.

00:29:46.100 --> 00:29:48.570
And you also have to override getKind.

00:29:48.580 --> 00:29:54.570
It's a pure virtual method so that
we can identify what kind it is.

00:29:54.910 --> 00:29:56.380
And then after that,
you only have to handle

00:29:56.380 --> 00:29:57.560
what is interesting to you.

00:29:57.560 --> 00:29:58.950
You don't have to worry
about the Carbon events,

00:29:59.000 --> 00:30:02.160
you just go override certain methods,
like a draw method,

00:30:02.360 --> 00:30:07.020
or some kind of accessibility method,
or keyboard handling, or whatever.

00:30:09.490 --> 00:30:16.110
So here's an example of
overriding tObjectRegister class.

00:30:16.360 --> 00:30:21.050
You can see here this only happens once,
so there's a static that's stored.

00:30:21.160 --> 00:30:25.130
This is a static route--
this is a static--

00:30:25.320 --> 00:30:28.140
So that you don't re-register
it over and over and over.

00:30:28.140 --> 00:30:29.700
You only need to register with it once.

00:30:29.840 --> 00:30:33.980
Again, you see that reverse domain name
class ID that I talked about before.

00:30:34.150 --> 00:30:40.620
And you have to specify what the static
construct method is for your subclass.

00:30:40.870 --> 00:30:46.490
In this case, it's almost always going
to be called construct,

00:30:46.490 --> 00:30:50.270
and it's a static method
in your C++ subclass.

00:30:51.290 --> 00:30:55.800
Here's an example of overriding
the Draw Event Handler.

00:30:55.800 --> 00:30:58.000
You can see that there's a
couple of parameters coming in.

00:30:58.000 --> 00:31:03.160
Those have been conveniently extracted
from you from the Carbon Events.

00:31:03.160 --> 00:31:07.570
Here you get the nicely clipped,
transformed CG context.

00:31:07.920 --> 00:31:10.710
This is the exact same drawing
as happened in my previous

00:31:10.900 --> 00:31:12.390
sample code I put up here.

00:31:12.490 --> 00:31:16.410
There's a bounds
accesser because I have a

00:31:16.560 --> 00:31:19.500
I clearly have a reference
to my tview instance.

00:31:19.500 --> 00:31:23.150
I just get its bounds and I draw it.

00:31:23.820 --> 00:31:27.030
So Curt's going to come back up and
he's going to show you that same class,

00:31:27.030 --> 00:31:29.900
re-implemented using HIFramework.

00:31:30.260 --> 00:31:31.890
Curt?

00:31:32.410 --> 00:31:33.910
Thank you.

00:31:34.090 --> 00:31:35.540
So basically, yeah,
we're just going to re-implement

00:31:35.610 --> 00:31:38.420
this using the HI framework,
which is so much easier.

00:31:38.420 --> 00:31:41.030
I mean,
you probably saw some of the demos

00:31:41.070 --> 00:31:42.460
that we did in our sessions yesterday.

00:31:42.460 --> 00:31:47.110
And we always use the HI framework
just because it's quick,

00:31:47.170 --> 00:31:48.430
right?

00:31:49.210 --> 00:31:53.060
So here, we define our class ID,
which is--this is the ID that

00:31:53.060 --> 00:31:59.780
indicates or identifies our class
to the HIObject subclassing system.

00:32:01.400 --> 00:32:04.600
Then we also implement the
GitKind as he mentioned.

00:32:04.600 --> 00:32:10.530
It's a pure virtual method that we have
to override and that's so the system can

00:32:10.530 --> 00:32:13.770
identify what kind of instance you are.

00:32:16.360 --> 00:32:17.160
And then register class.

00:32:17.220 --> 00:32:20.300
Now, if you remember when we called
hiobject register subclass,

00:32:20.300 --> 00:32:21.440
there was this huge function.

00:32:21.440 --> 00:32:23.580
We had to add the whole parameter list.

00:32:23.600 --> 00:32:25.950
And then we called
hiobject register subclass.

00:32:26.170 --> 00:32:30.300
This is just the same concept,
but much simpler.

00:32:30.310 --> 00:32:32.050
Like I mentioned, we had the one shot.

00:32:32.060 --> 00:32:34.060
This is now all it is.

00:32:34.070 --> 00:32:37.540
We specify the class ID,
which we defined at the top of this file.

00:32:37.550 --> 00:32:40.380
And then we specify a construct proc.

00:32:40.380 --> 00:32:43.740
Now, this is important because
when the application needs

00:32:43.790 --> 00:32:46.180
to instantiate your object,
it needs to call something

00:32:46.210 --> 00:32:49.060
to do that instantiation,
and that's this construct proc,

00:32:49.060 --> 00:32:49.640
which will get called.

00:32:51.370 --> 00:32:55.080
So when someone calls HIObject,
construct,

00:32:55.250 --> 00:33:01.500
or create using your class ID and
it needs to instantiate your object,

00:33:01.500 --> 00:33:01.500
this--

00:33:01.960 --> 00:33:03.300
This handler is going to get called.

00:33:03.320 --> 00:33:06.210
And this is a class method.

00:33:06.310 --> 00:33:07.620
So it's depending on your method.

00:33:07.620 --> 00:33:10.020
So you need to create an
instance of your class.

00:33:10.050 --> 00:33:11.280
And this is really important.

00:33:11.280 --> 00:33:17.060
This is where you actually instantiate
your object by calling new on your view.

00:33:20.100 --> 00:33:22.690
After that,
once you embed it into your view

00:33:22.690 --> 00:33:26.710
hierarchy and make it visible,
your draw method is called.

00:33:27.050 --> 00:33:31.270
This is the same thing that we did
in the previous example using C,

00:33:31.310 --> 00:33:35.290
but we don't have to do all the
extraction from the Carbon event

00:33:35.300 --> 00:33:38.270
in order to get the context and the
region that we should be drawing into.

00:33:38.300 --> 00:33:40.210
It's all passed into us,
and then we go ahead

00:33:40.230 --> 00:33:42.480
and we do our switching,
and we can change the color

00:33:42.520 --> 00:33:45.420
based on active state or
whatever at that particular time.

00:33:45.620 --> 00:33:49.920
And as David mentioned, drawing,
regardless of whether you're doing

00:33:49.930 --> 00:33:53.360
it in HIFrame or C++ or in C,
should only be done in your draw handler.

00:33:53.360 --> 00:33:56.080
And if you need to force
drawing in some other place,

00:33:56.120 --> 00:33:59.150
like you're tracking the control,
you wouldn't draw at

00:33:59.360 --> 00:34:00.640
those particular points.

00:34:00.650 --> 00:34:01.440
You would invalidate.

00:34:01.490 --> 00:34:04.840
So the next time through the event
system where it's going to draw,

00:34:04.840 --> 00:34:07.470
it will call this function
to do all your drawing.

00:34:07.470 --> 00:34:08.550
So only draw here.

00:34:08.560 --> 00:34:11.030
That's it.

00:34:11.100 --> 00:34:13.500
So if we want to go ahead and run that.

00:34:16.570 --> 00:34:19.160
We can see that this
is our old C-based one,

00:34:19.160 --> 00:34:22.280
and this is our C++ based
one using HIFramework.

00:34:22.660 --> 00:34:27.540
It was a lot less code,
really easy setup, and boom, it's there.

00:34:27.600 --> 00:34:28.260
Thanks, Dave.

00:34:28.350 --> 00:34:30.130
DAVID MOLEN: Thank you, Curt.

00:34:35.880 --> 00:34:38.590
So hopefully that shows some of
the simplicity of the HI Framework.

00:34:38.600 --> 00:34:42.080
I really highly recommend using it.

00:34:42.080 --> 00:34:45.400
Even if you make one first
in C and then try one using

00:34:45.400 --> 00:34:47.650
the HI Framework afterwards,
it will really help you

00:34:47.650 --> 00:34:48.800
understand the concepts.

00:34:48.840 --> 00:34:52.660
And once you understand the concepts,
you'll just love them and

00:34:52.670 --> 00:34:54.600
you'll really want to use them.

00:34:57.070 --> 00:35:01.740
So let's go over a bit more of the basic
behavior that's available to override,

00:35:01.930 --> 00:35:03.720
like click handling.

00:35:03.910 --> 00:35:06.380
Click handling has a few
events associated with it.

00:35:06.550 --> 00:35:07.760
First, you want to hit Test.

00:35:08.010 --> 00:35:12.030
That determines if a point is within
a part or within your whole view.

00:35:12.160 --> 00:35:13.250
Depends how many parts.

00:35:13.260 --> 00:35:18.180
Maybe if you only have one part,
it might be your whole view.

00:35:18.830 --> 00:35:20.800
This is not time to handle click.

00:35:20.800 --> 00:35:26.700
You get asked for hit testing just to
see if a point is within your view.

00:35:26.700 --> 00:35:28.120
It could be used for other things.

00:35:28.230 --> 00:35:29.760
It's not time to do
any click handling yet.

00:35:29.820 --> 00:35:35.540
One really important and nice point
about doing k-event control hit tests,

00:35:35.540 --> 00:35:38.260
if you contrast it to
doing hit testing with,

00:35:38.260 --> 00:35:40.730
say, a control definition,
is that the hit testing

00:35:40.730 --> 00:35:42.300
can have multiple parts.

00:35:42.300 --> 00:35:45.180
This doesn't just say hit or not hit.

00:35:45.320 --> 00:35:51.560
And that means that the default
tracking can track individual

00:35:51.560 --> 00:35:54.160
parts of your control easily,
your custom HIView easily.

00:35:54.160 --> 00:35:58.120
And it was a little harder to do with

00:35:58.570 --> 00:36:04.500
You can still do custom
tracking if you want.

00:36:04.500 --> 00:36:08.700
You just handle the
Cave-In Control Track event and

00:36:08.700 --> 00:36:12.130
do your custom tracking there
and validate to do redrawing,

00:36:12.130 --> 00:36:13.500
whatever you want.

00:36:13.500 --> 00:36:16.520
Another important part of doing
click handling is if the value

00:36:16.600 --> 00:36:19.500
changes or the highlight changes,
you probably want to handle that.

00:36:19.500 --> 00:36:22.060
You'll get a message that says
that they have changed and you will

00:36:22.200 --> 00:36:24.960
probably want to invalidate so that
you appear different when you're

00:36:24.960 --> 00:36:27.400
being clicked or when you're being
tracked or if your highlight changes.

00:36:27.500 --> 00:36:30.220
And eventually,
when someone does do a mouse-up

00:36:30.450 --> 00:36:34.500
and they do click on your view,
you'll get a Cave-In Control Hit event.

00:36:34.500 --> 00:36:35.470
That means you've been clicked.

00:36:35.680 --> 00:36:37.500
Then it's time to handle a click.

00:36:40.660 --> 00:36:43.140
HI Framework Click Handling.

00:36:43.180 --> 00:36:47.260
All it does is take those Carbon events,
take out a few Carbon event parameters,

00:36:47.410 --> 00:36:49.560
and to do the Click Handling,
all you have to do then

00:36:49.560 --> 00:36:50.720
is override a few methods.

00:36:50.720 --> 00:36:52.550
If you're interested in
overriding the hit testing,

00:36:52.590 --> 00:36:53.560
you do the hit testing.

00:36:53.560 --> 00:36:54.690
Tracking is available.

00:36:54.690 --> 00:36:57.400
You can do the highlight change
or value change overriding to do

00:36:57.410 --> 00:37:00.300
whatever you want when those change,
as well as Control Hit.

00:37:03.500 --> 00:37:06.360
Here's an example of
overriding a hit test in TView.

00:37:06.530 --> 00:37:12.470
Tried to make a little more
interesting code snippet.

00:37:12.620 --> 00:37:17.630
This one here, it goes and it gets
the bounds of my view,

00:37:17.860 --> 00:37:19.720
divides it into four,
and it tells you which one

00:37:19.720 --> 00:37:23.740
of the four quadrants gets
clicked and returns that part.

00:37:23.900 --> 00:37:25.470
Everything else is
handled by HIFramework.

00:37:25.540 --> 00:37:29.170
It puts the part back into--
it does a set event parameter,

00:37:29.170 --> 00:37:33.090
and it goes back into the
view system just fine.

00:37:33.730 --> 00:37:35.910
Here's an example of
overriding Control Hit.

00:37:36.080 --> 00:37:38.440
What do you do when someone
clicks on your control?

00:37:38.480 --> 00:37:42.920
If it's a simple control,
generally you'll just want to set your

00:37:42.920 --> 00:37:44.600
value to whatever the incoming part was.

00:37:44.600 --> 00:37:47.100
Say I had that four quadrant
view I just mentioned.

00:37:47.230 --> 00:37:49.810
My value would be maybe one, two, three,
four,

00:37:49.870 --> 00:37:52.090
depending on which quadrant was hit.

00:37:52.300 --> 00:37:53.990
Interestingly here,
you always want to return

00:37:53.990 --> 00:37:55.110
event not handled error.

00:37:55.260 --> 00:38:01.920
And that's so that you can let the
rest of the system handle the event.

00:38:01.930 --> 00:38:03.870
And that does things like
sending out the command ID.

00:38:03.890 --> 00:38:07.690
So if you have a command ID associated
with your view or some other client

00:38:07.690 --> 00:38:11.290
of your custom view is using it
and associates a command ID for

00:38:11.290 --> 00:38:15.480
it and is expecting to receive it,
you have to return event not

00:38:15.490 --> 00:38:19.560
handled error so that the system
knows that it's got to keep on

00:38:19.590 --> 00:38:21.060
processing it and do that for you.

00:38:23.950 --> 00:38:25.960
You can also override
the change handlers.

00:38:26.020 --> 00:38:27.130
They're generally very simple.

00:38:27.130 --> 00:38:29.340
If your value changes,
you want to invalidate so

00:38:29.400 --> 00:38:32.400
that you draw later to reflect
how your value has changed.

00:38:32.510 --> 00:38:36.110
Similarly with the highlight change,
you want to invalidate so later on

00:38:36.300 --> 00:38:40.400
when it's the appropriate time to draw,
you can draw a highlight differently.

00:38:40.420 --> 00:38:41.820
That's really quite common.

00:38:42.120 --> 00:38:45.400
There's actually a couple of
auto-invalidation convenience

00:38:45.480 --> 00:38:48.470
bits that you can set on a
view in the HI framework.

00:38:48.770 --> 00:38:52.030
To tell it that you automatically
want to invalidate when the value

00:38:52.030 --> 00:38:53.940
changes or when the highlight changes.

00:38:54.060 --> 00:38:58.860
Similarly, there's also a few bits for
automatic invalidation when

00:38:58.860 --> 00:39:03.300
your activation changes,
enable state changes,

00:39:03.410 --> 00:39:07.640
or if someone changes your title.

00:39:07.700 --> 00:39:11.800
Next kind of basic behavior,
keyboard handling, someone starts typing.

00:39:13.870 --> 00:39:20.590
This is all done through the KEVENT class
text input class of Carbon events,

00:39:20.590 --> 00:39:24.590
and most specifically the KEVENT text
input Unicode for key event.

00:39:24.670 --> 00:39:30.060
You'll get a Unicode value that
indicates which key has been pressed.

00:39:30.210 --> 00:39:34.590
Previously you might have been doing
some raw event handling and doing a

00:39:35.220 --> 00:39:37.200
Keydown or RawKeydown or whatever.

00:39:37.200 --> 00:39:40.400
I don't even remember anymore,
but this is what I use.

00:39:40.410 --> 00:39:44.280
To use that in an HI framework,
you just got to override

00:39:44.360 --> 00:39:46.180
the text input method.

00:39:46.180 --> 00:39:48.740
One important note here is that you
probably want to deal with special keys.

00:39:48.740 --> 00:39:52.260
So if someone presses Command period,
you might want to pass that off

00:39:52.260 --> 00:39:54.460
so the cancel happens properly.

00:39:54.510 --> 00:39:58.850
Or if someone presses Enter or Return,
you might want to pass it off so that

00:39:58.910 --> 00:40:02.390
the default button gets handled properly.

00:40:05.480 --> 00:40:08.560
Here's an example of
overriding text input.

00:40:08.560 --> 00:40:09.390
It's quite simple.

00:40:09.400 --> 00:40:11.850
It's a little bit different than the
other ones because you're actually

00:40:11.850 --> 00:40:13.000
getting a whole class of events here.

00:40:13.000 --> 00:40:19.600
So you have to extract the event
kind out of the incoming event.

00:40:19.820 --> 00:40:26.500
Make sure it's a KEvent text input
Unicode for KEvent that you extract,

00:40:26.500 --> 00:40:29.700
that's coming in so
that you can act on it.

00:40:29.740 --> 00:40:34.090
And then you just get
the parameter out of it.

00:40:34.410 --> 00:40:38.130
This example here looks a little
bit different than GetEventParameter

00:40:38.130 --> 00:40:41.300
because it's using the tcarbon
event convenience functions.

00:40:41.430 --> 00:40:45.230
So you get the
keventparam_text_input_send_text

00:40:45.230 --> 00:40:48.510
out of the event and
then you do whatever with it.

00:40:48.530 --> 00:40:52.340
And remembering to handle those
special keys if you need to.

00:40:54.520 --> 00:40:59.130
And the last basic behavior
you want your control to have,

00:40:59.370 --> 00:41:03.230
your custom view to have,
is to be accessible.

00:41:03.950 --> 00:41:08.360
It allows an external application
like VoiceOver to control your app.

00:41:08.360 --> 00:41:11.610
And it really is as important as
the other ways of manipulating your

00:41:11.610 --> 00:41:15.500
view because someone that can't use
a mouse or can't use a keyboard,

00:41:15.560 --> 00:41:18.730
this is the way they're going
to be using your application

00:41:18.730 --> 00:41:20.980
through this accessibility layer.

00:41:21.170 --> 00:41:24.540
It's all implemented like Carbon events,
just like everything else.

00:41:24.570 --> 00:41:28.780
And there are a few events,
and they look a little daunting at first,

00:41:28.780 --> 00:41:31.170
because Guy likes to write
really long event names.

00:41:31.310 --> 00:41:35.690
But other than that,
it's just setting a few attributes,

00:41:35.690 --> 00:41:39.160
like what the role is
and that sort of thing.

00:41:39.160 --> 00:41:44.850
And it's just generally describing your
view so that it can be presented to

00:41:44.850 --> 00:41:49.000
a user that's not using a keyboard or
not being able to visually perceive it.

00:41:49.740 --> 00:41:52.290
A guy covered this yesterday morning
in an excellent session that hopefully

00:41:52.390 --> 00:41:57.550
you can review somehow through the...
I don't know how you guys get the

00:41:57.550 --> 00:41:59.300
sessions after they've already run.

00:41:59.300 --> 00:42:01.180
I think there's DVDs or whatever coming.

00:42:01.180 --> 00:42:02.590
I saw a video camera on him.

00:42:02.660 --> 00:42:05.410
So if you can get at that content,
it's really, really good.

00:42:05.410 --> 00:42:07.530
And it's really quite key
to have the basic behavior

00:42:07.610 --> 00:42:09.020
of being an accessible view.

00:42:10.750 --> 00:42:13.360
So like I said,
there's a class of events,

00:42:13.360 --> 00:42:18.060
K of N class accessibility,
K of N accessible, get child at point,

00:42:18.110 --> 00:42:20.360
get all attribute names,
get named attributes.

00:42:20.410 --> 00:42:22.420
Those are all just
describing what your view is.

00:42:22.550 --> 00:42:27.810
And it's just really taking some CF types
and pushing them into a CFDictionary,

00:42:27.900 --> 00:42:28.900
a CFArray.

00:42:29.690 --> 00:42:32.300
And KVN, Accessible Perform Named Action.

00:42:32.300 --> 00:42:36.680
That's how the external application
can tell your view to do its thing.

00:42:38.770 --> 00:42:42.140
All of those map directly on-- look,
it's just like a one-to-one

00:42:42.140 --> 00:42:47.080
mapping-- directly on to some
methods that we have in tObject.

00:42:47.670 --> 00:42:48.690
The names are very similar.

00:42:48.760 --> 00:42:51.120
You'll be able to find them easily.

00:42:51.120 --> 00:42:54.920
This is where earlier on I mentioned
that we added tObject to hiframework.

00:42:55.060 --> 00:42:58.920
And the reason we added a tObject
class is because the accessibility

00:42:59.160 --> 00:43:00.680
doesn't just apply to HIViews.

00:43:00.770 --> 00:43:03.520
It applies more generally to hIobjects.

00:43:03.630 --> 00:43:07.930
So we put them in tObject because
accessibility applies to windows

00:43:07.930 --> 00:43:12.900
and menus and toolbars and whatever
other subclasses of hIobject.

00:43:16.000 --> 00:43:19.080
And that's the layer that
we have to provide it at.

00:43:20.180 --> 00:43:23.060
So here's an example of overriding
one of the accessibility methods,

00:43:23.110 --> 00:43:26.080
getAccessibleAttributeNames.

00:43:26.210 --> 00:43:30.590
There's a lot of
dependency on your parent

00:43:31.100 --> 00:43:42.100
[Transcript missing]

00:43:43.520 --> 00:43:46.390
You can allow your parent a
chance to fill in some of the

00:43:46.440 --> 00:43:48.700
accessibility information for you.

00:43:48.750 --> 00:43:51.670
And what you do is you call
Next Event Handler to let your parent

00:43:52.380 --> 00:43:54.680
event fill in as much as it can.

00:43:54.790 --> 00:43:58.670
After that comes back successfully,
that's your turn to fill in some

00:43:58.670 --> 00:44:03.960
parameters to describe the value
attribute or the role attribute.

00:44:03.990 --> 00:44:09.480
This is the time that your
view gets to describe itself.

00:44:11.150 --> 00:44:14.660
And overall,
that's a basic Custom HIView.

00:44:14.690 --> 00:44:16.520
You just have those five basic behaviors.

00:44:16.570 --> 00:44:18.930
Some of them, you know,
you might not have mouse handling.

00:44:18.940 --> 00:44:22.080
You might just be displaying
a bar graph or something.

00:44:22.090 --> 00:44:25.340
You might not have keyboard handling
because there's no text input.

00:44:25.340 --> 00:44:27.930
But you're probably
going to have drawing,

00:44:27.930 --> 00:44:31.000
and I'd highly recommend
having accessibility.

00:44:32.520 --> 00:44:36.900
You probably want to add a few more
things to it just to make it fancy.

00:44:36.950 --> 00:44:40.810
Before I get into that,
I'd just like to go over some

00:44:41.050 --> 00:44:45.450
key areas so that you can
make a good custom HIView.

00:44:46.060 --> 00:44:48.550
So I'm going to cover opaque region,
what that means as far as

00:44:48.550 --> 00:44:52.840
drawing performance goes,
as well as doing some limited drawing.

00:44:53.010 --> 00:44:57.290
Opaque region, I'll show in a minute,
lets you describe what parts of

00:44:57.340 --> 00:45:00.020
your view are completely opaque.

00:45:00.020 --> 00:45:03.720
And limited drawing lets the view system
tell you to only draw parts of your

00:45:03.780 --> 00:45:07.200
view so you don't have to draw as much,
maybe not do as many calculations,

00:45:07.360 --> 00:45:11.020
and in so doing be a
little bit more efficient.

00:45:11.210 --> 00:45:14.240
And actually there's a feature bit,
KHIView does not draw.

00:45:14.420 --> 00:45:17.810
If your view is just some
kind of containment view

00:45:17.920 --> 00:45:20.100
and it doesn't draw at all,
if we have this bit,

00:45:20.100 --> 00:45:24.660
we can be ultimately efficient as
far as drawing goes and just never,

00:45:24.660 --> 00:45:26.200
ever tell you to draw.

00:45:27.440 --> 00:45:29.160
So the opaque region.

00:45:29.390 --> 00:45:33.510
That's your chance to describe to
the view subsystem and tell it which

00:45:33.610 --> 00:45:34.960
part of you is completely opaque.

00:45:35.080 --> 00:45:37.130
That means you can't see any
of the pixels behind you.

00:45:37.260 --> 00:45:40.580
And since none of the pixels
behind you can be seen,

00:45:40.620 --> 00:45:42.680
we shouldn't bother drawing them.

00:45:42.730 --> 00:45:44.560
So that lets everything
behind you be more efficient,

00:45:44.580 --> 00:45:46.790
it lets everything be more efficient,
and it lets your whole

00:45:46.850 --> 00:45:48.320
application be more efficient.

00:45:49.110 --> 00:45:52.840
It could be some subpart of your HIView.

00:45:52.840 --> 00:45:55.670
In the example I mentioned earlier
where I had some quadrants with 1,

00:45:55.670 --> 00:46:00.090
2, 3, 4, maybe the highlight changed
from quadrant 2 to quadrant 3,

00:46:00.200 --> 00:46:03.270
and I just have to redraw
quadrant 2 and quadrant 3 because

00:46:03.270 --> 00:46:05.000
1 and 4 are still the same.

00:46:05.120 --> 00:46:08.240
It could be your whole view,
like in the square we were drawing,

00:46:08.240 --> 00:46:10.750
or if you're drawing a
bar graph or something.

00:46:12.520 --> 00:46:16.670
And the performance gain, like I said,
is that nobody behind you has to

00:46:16.670 --> 00:46:18.340
draw if you're obscuring them.

00:46:18.360 --> 00:46:22.510
None of the obscured content has to draw.

00:46:24.500 --> 00:46:27.290
I think I mixed in something
when I said the quadrants there.

00:46:27.300 --> 00:46:30.400
I'll cover that in a second
with the limited drawing.

00:46:30.540 --> 00:46:32.430
Sorry.

00:46:35.060 --> 00:46:38.670
So to feedback about what
your opaque region is,

00:46:38.810 --> 00:46:41.400
you've got the
KEventControlGetRegion event.

00:46:41.460 --> 00:46:43.640
And I can do the compare and contrast.

00:46:43.650 --> 00:46:49.120
You just override the getRegion
method in HIFramework.

00:46:49.160 --> 00:46:52.160
And watch for the request
for the opaque part.

00:46:52.400 --> 00:46:56.110
All you have to do is report
that region that's fully opaque.

00:46:57.370 --> 00:46:58.800
Here's an example of doing it.

00:46:58.800 --> 00:46:59.890
You see the incoming part.

00:46:59.900 --> 00:47:02.990
It's already been extracted
out for you by HIView.

00:47:02.990 --> 00:47:05.530
And you look for the opaque meta part.

00:47:05.870 --> 00:47:08.680
In this case, it's just a full rectangle
of the whole view.

00:47:08.680 --> 00:47:11.260
That means anything that's behind
the view doesn't have to be drawn.

00:47:11.260 --> 00:47:16.750
Anything that doesn't have to draw
makes your application more efficient.

00:47:19.450 --> 00:47:20.600
Limited drawing.

00:47:20.670 --> 00:47:24.790
Caveman Control Draw on the way in
has a parameter which is a region

00:47:24.790 --> 00:47:27.600
that describes which is the dirty
area that needs to be redrawn.

00:47:27.720 --> 00:47:30.800
So you don't have to redraw everything,
you just have to draw that dirty area.

00:47:30.880 --> 00:47:32.910
Now is when my quadrant example applies.

00:47:33.030 --> 00:47:35.760
If the highlight changes
from one quadrant to another,

00:47:35.760 --> 00:47:38.980
you don't have to draw all of them,
just the two that changed.

00:47:39.390 --> 00:47:45.180
So you just extract out the region
using the k-event-param region handle.

00:47:45.440 --> 00:47:47.800
And you just limit your drawing to that.

00:47:47.840 --> 00:47:49.840
Nice thing is,
TViewDraw already does that for you.

00:47:49.970 --> 00:47:53.180
It takes that limit region out,
and it passes it in.

00:47:53.180 --> 00:47:56.690
So here's an example of using
the incoming limit region.

00:47:57.240 --> 00:48:00.090
I tried to write some sample code,
but you run out of space pretty

00:48:00.200 --> 00:48:01.720
fast when the font is that big.

00:48:01.890 --> 00:48:05.330
So basically,
you would just cycle through your parts,

00:48:05.470 --> 00:48:09.320
check to see if that limit
region intersects the parts,

00:48:09.360 --> 00:48:12.020
and you only draw the
ones that intersect.

00:48:12.290 --> 00:48:15.100
In that quadrant example,
I would just go through them and check.

00:48:15.780 --> 00:48:19.520
The important caveat here is that
if all the machinery of checking

00:48:19.590 --> 00:48:23.340
to see if this intersects and
that intersects takes too long,

00:48:23.430 --> 00:48:26.640
you might just want to draw
entirely and not do this.

00:48:26.640 --> 00:48:29.870
It might be more efficient just
to draw everything and the clip

00:48:30.100 --> 00:48:33.670
will take care of it and not
worry about doing this machinery.

00:48:35.900 --> 00:48:38.050
Next thing you'll probably want to
do is add some kind of animation.

00:48:38.060 --> 00:48:39.530
Everybody wants animation in their views.

00:48:39.570 --> 00:48:41.810
They always look nice that way.

00:48:42.140 --> 00:48:45.580
Because everybody loves
pulsing push buttons,

00:48:45.640 --> 00:48:46.320
right?

00:48:46.320 --> 00:48:50.820
So the way you do that,
you don't install any sort of idle

00:48:50.820 --> 00:48:51.810
loops or do anything like that.

00:48:51.820 --> 00:48:56.130
All you have to do is install a
CarbonEvent timer that calls a timer

00:48:56.130 --> 00:49:00.560
function in your view subclass and does
an invalidation of some sort to tell your

00:49:00.560 --> 00:49:06.190
view when it's appropriate time to draw,
draw in that newly animated state.

00:49:07.780 --> 00:49:10.230
It's important to remember to remove
that timer when you destroy your

00:49:10.280 --> 00:49:13.830
view because there will be a timer
in place that's maybe got a reference

00:49:13.830 --> 00:49:16.870
to your view and if it destroys it,
the timer doesn't stop firing

00:49:16.960 --> 00:49:18.860
and it will try and reference
a view that's destroyed.

00:49:18.860 --> 00:49:22.800
So you want to keep track of
that Carbon Event Timer and

00:49:22.800 --> 00:49:28.300
when your view gets destroyed,
you want to remove that Event Timer.

00:49:29.370 --> 00:49:31.290
And just to be efficient,
you don't ever want to animate

00:49:31.720 --> 00:49:32.980
when your view is invisible.

00:49:33.030 --> 00:49:34.670
What's the point?

00:49:36.820 --> 00:49:38.690
Here's a full animation sample.

00:49:38.790 --> 00:49:39.860
Well, most of it.

00:49:39.920 --> 00:49:43.340
You can see here that I installed
an event loop timer during

00:49:43.340 --> 00:49:46.930
the initialization phase
of my HIView instantiation.

00:49:47.190 --> 00:49:52.450
I installed an event loop timer
that draws 30 times a second.

00:49:52.590 --> 00:49:56.390
You don't want to do this too
often if the user's not going

00:49:56.450 --> 00:49:58.490
to be able to perceive it.

00:50:00.280 --> 00:50:06.260
And that event loop timer,
I tell it what the static callback is,

00:50:06.260 --> 00:50:09.620
and that's my event handler,
and also pass an instance so

00:50:09.620 --> 00:50:13.460
it can identify which of the
view subclass instantiations

00:50:13.800 --> 00:50:15.940
is actually being animated.

00:50:16.980 --> 00:50:20.710
Later on,
when the event handler gets called,

00:50:20.740 --> 00:50:24.060
it's going to be past that
instance so that it knows.

00:50:28.650 --> 00:50:35.220
So here's the,
this does the actual animation.

00:50:35.420 --> 00:50:38.740
That's a static timer,
static call that gets called.

00:50:38.870 --> 00:50:41.860
This is a static entry
point into your class,

00:50:41.900 --> 00:50:45.480
so you have to extract your
instantiation and then access it.

00:50:45.500 --> 00:50:49.810
So that's what the casting of my
view does there with the user data.

00:50:50.000 --> 00:50:51.900
And then you do whatever
changed in your animation.

00:50:51.900 --> 00:50:53.820
You know,
you advanced one frame or you moved

00:50:53.830 --> 00:51:00.840
something in your implementation,
however you're doing your animation.

00:51:01.000 --> 00:51:02.790
And then you invalidate the view.

00:51:02.920 --> 00:51:06.390
So that just calls an
API underneath an HIView framework

00:51:06.500 --> 00:51:08.890
called HIViewSetNeedsDisplay.

00:51:08.900 --> 00:51:11.450
And it lets the view system
know that at the appropriate

00:51:11.510 --> 00:51:14.260
time in the event loop cycle,
when it's time to draw,

00:51:14.290 --> 00:51:16.520
that view needs to be redrawn.

00:51:19.520 --> 00:51:22.800
It's also very easy to add any other
additional behaviors that you want,

00:51:22.800 --> 00:51:24.140
like drag and drop.

00:51:24.140 --> 00:51:27.920
It's just overriding some Carbon events,
and there's facilities for

00:51:27.920 --> 00:51:30.480
using that in the HI framework.

00:51:30.500 --> 00:51:36.460
Focus handling, scroll to here,
other parts and bounds, size reporting,

00:51:36.460 --> 00:51:38.480
and size constraints.

00:51:38.480 --> 00:51:41.620
Size constraints are what you use to
describe what the size of your view

00:51:41.650 --> 00:51:43.340
is when you're using it in a toolbar.

00:51:43.500 --> 00:51:46.910
All of that is just a matter
of handling some Carbon events,

00:51:47.000 --> 00:51:50.520
returning the appropriate parameters,
and they're all wrapped

00:51:50.520 --> 00:51:53.420
up in the HI framework,
and you can just override the appropriate

00:51:53.690 --> 00:51:55.500
method to get these additional behaviors.

00:51:58.800 --> 00:52:03.880
Lastly,
you probably want to instantiate from

00:52:04.180 --> 00:52:06.820
A nib, one of these custom HIViews.

00:52:07.050 --> 00:52:09.850
You don't want to make it
programmatically every time.

00:52:09.900 --> 00:52:12.010
It's really easy to do that.

00:52:12.050 --> 00:52:15.480
The only important part is that you have
to register your view before you actually

00:52:15.480 --> 00:52:17.150
do the instantiation of your nib.

00:52:18.570 --> 00:52:21.980
So you just use the HIView widget in IB.

00:52:21.980 --> 00:52:25.280
In the widget panel,
the orange box says HIView in it.

00:52:25.470 --> 00:52:26.400
Drag it into your window.

00:52:26.400 --> 00:52:30.020
You bring up the info panel and
the attributes pane of that.

00:52:30.020 --> 00:52:35.110
You just set the class ID to that string
that we've been using over and over

00:52:35.110 --> 00:52:37.050
when we registered our HIView subclass.

00:52:37.130 --> 00:52:42.880
That's the unique identifier that tells
HIToolbox which subclass to instantiate.

00:52:42.950 --> 00:52:44.650
You just go set that in there.

00:52:44.810 --> 00:52:47.960
And when the Nib is loaded,
all the construction routines are called.

00:52:47.960 --> 00:52:50.070
And it's just like you
created programmatically.

00:52:50.180 --> 00:52:55.500
The really important part there is that
you must register before you instantiate

00:52:55.500 --> 00:52:57.060
or else nothing's going to happen.

00:52:57.060 --> 00:53:02.140
It's not a recognizable subclass
to HIToolbox until you register.

00:53:05.230 --> 00:53:08.770
So I've shown you, custom HIViews are
really easy to implement.

00:53:08.860 --> 00:53:11.390
It's just some HIobject subclassing.

00:53:11.520 --> 00:53:13.820
And it all uses Carbon events,
which you're familiar with.

00:53:14.030 --> 00:53:16.120
You just install Carbon event handlers.

00:53:16.320 --> 00:53:20.720
And if you use HIFramework,
it makes it very simple.

00:53:20.720 --> 00:53:23.900
I can pop out a custom view really,
really fast,

00:53:23.900 --> 00:53:27.500
making the sample code or making
any custom pieces for myself.

00:53:27.500 --> 00:53:30.480
Much easier than doing really,
really custom UI and

00:53:30.480 --> 00:53:32.100
drawing into the window.

00:53:32.100 --> 00:53:35.050
Or it's even easier than doing
a custom control definition.

00:53:35.160 --> 00:53:41.250
It's extremely easy to make a subclass
using HIFramework and HIView subclassing.

00:53:41.910 --> 00:53:44.710
So what I recommend you do is go
make a custom HIView right now.

00:53:45.010 --> 00:53:49.980
Go download the HIFramework
sample code and just make one

00:53:50.050 --> 00:53:52.480
independently of your application.

00:53:53.050 --> 00:53:55.380
Make something fun for yourself
just so you can get a feel for it.

00:53:55.380 --> 00:53:58.620
You might want to go through a
HITestView sample code so you can

00:53:58.620 --> 00:54:01.480
compare the C APIs to the C++ ones.

00:54:01.680 --> 00:54:04.560
But I guarantee you won't want to do that
boilerplate stuff over and over and over.

00:54:04.560 --> 00:54:07.080
If you don't have to,
you can just override a few methods.

00:54:07.240 --> 00:54:09.020
And once you see that,
you're going to see how easy

00:54:09.020 --> 00:54:13.930
it is to take different pieces
of your application's UI,

00:54:13.950 --> 00:54:19.180
make them into custom HIViews,
and make your whole application use

00:54:19.230 --> 00:54:23.210
the HIView and compositing and do all
the new whizbang features that you need

00:54:23.210 --> 00:54:27.320
to do to come with us into the future,
bring your application into the

00:54:27.320 --> 00:54:28.980
future and not get left behind.

00:54:29.000 --> 00:54:30.290
I heard one comment yesterday.

00:54:30.300 --> 00:54:32.390
Someone said, well,
I'm not going to use HIView because

00:54:32.430 --> 00:54:36.500
Apple comes out with these new
technologies and I get worried about it.

00:54:36.500 --> 00:54:37.580
And I'm going to wait.

00:54:37.600 --> 00:54:38.820
It's time to stop waiting.

00:54:38.820 --> 00:54:44.780
We introduced this so you
could do it in Jaguar.

00:54:44.780 --> 00:54:47.010
In Panther, all of our views are HIView.

00:54:47.060 --> 00:54:49.010
Like, you're using HIView already.

00:54:49.010 --> 00:54:51.220
Every single system
UI widget is an HIView.

00:54:51.220 --> 00:54:52.100
Everything is HIView.

00:54:52.610 --> 00:54:57.780
Even the closed boxes in the windows.

00:54:57.780 --> 00:54:59.660
It's not like we're saying
we're going to do it.

00:54:59.660 --> 00:55:01.280
We've done it and you
have to come with us.

00:55:01.280 --> 00:55:03.460
And it's time to come now
by making a custom HIView.

00:55:05.850 --> 00:55:07.260
A little bit more information.

00:55:07.280 --> 00:55:12.250
You can hit the documents
in the reference library.

00:55:12.340 --> 00:55:15.240
There's upgrading to the
MacOSX tool--HI Toolbox.

00:55:15.380 --> 00:55:19.030
It's got some great information
there to bring you forward with us.

00:55:19.170 --> 00:55:25.570
Introducing HIView goes into detail
some of the concepts I went over today.

00:55:26.470 --> 00:55:29.710
TechNote 2074 is really good if
you're used to the Control Manager and

00:55:29.710 --> 00:55:33.290
you want to get used to some of
these new HIView APIs that we have.

00:55:33.480 --> 00:55:37.320
And I definitely recommend
going over the HIView sample

00:55:37.320 --> 00:55:38.380
code that's available up there.

00:55:38.480 --> 00:55:40.010
Go over HIFramework.

00:55:40.090 --> 00:55:45.400
Check out some of the sample subclasses
that the engineers have written

00:55:45.410 --> 00:55:46.400
and that are available to you.

00:55:46.480 --> 00:55:51.740
It will really enlighten you
about what you need to do next.

00:55:53.110 --> 00:55:56.060
You can send Xavier an email
directly if you want to.

00:55:56.060 --> 00:55:57.000
There's his email address.
WEBVTT

00:00:13.920 --> 00:00:14.800
- All right, hello.

00:00:14.820 --> 00:00:17.170
Welcome to Inside Network Authentication.

00:00:17.180 --> 00:00:20.400
My name's Jason Townsen.

00:00:20.920 --> 00:00:24.970
I work on Open Directory in
various capacities.

00:00:26.620 --> 00:00:30.310
So today we're going to talk about
first giving an introduction to what

00:00:30.310 --> 00:00:34.800
we mean by network authentication and
then go through the feature set that

00:00:34.800 --> 00:00:40.990
we have in Panther both in password
server and Kerbero just to review.

00:00:41.380 --> 00:00:46.340
Then talk about all the new
features we're adding in Tiger.

00:00:46.620 --> 00:00:50.190
Go through some of the command
line tools you might use.

00:00:50.290 --> 00:00:54.360
And also some examples of how you
could use Kerbero in your application.

00:00:54.450 --> 00:00:57.490
And then finish up with
questions and answers.

00:00:58.250 --> 00:00:59.950
So what is network authentication?

00:00:59.960 --> 00:01:04.360
Well,
authentication is proof of identity.

00:01:04.360 --> 00:01:10.240
So you can think of, for example,
if you have a badge where you work,

00:01:10.250 --> 00:01:13.960
when you present that badge to a reader,
that's a form of authentication because

00:01:14.120 --> 00:01:18.450
you're proving that you are who the
badge indicates that you are because

00:01:18.540 --> 00:01:20.660
you have possession of that badge.

00:01:22.850 --> 00:01:26.430
So we need to keep in mind that this
is not the same thing as authorization.

00:01:26.440 --> 00:01:31.380
It sounds very similar,
but authorization is actually whether you

00:01:31.380 --> 00:01:33.440
can access a particular service or not.

00:01:33.490 --> 00:01:38.530
So in the case of the badge,
it could be that I have an Apple badge,

00:01:38.630 --> 00:01:43.190
but I still don't have access to
the super secret hardware lab where

00:01:43.190 --> 00:01:47.180
all the new prototypes are because
I'm just a lowly software engineer.

00:01:48.230 --> 00:01:51.010
So I can successfully authenticate,
but I'm not authorized

00:01:51.070 --> 00:01:53.310
for particular services.

00:01:53.910 --> 00:01:56.460
Another thing,
once we think about this on the network,

00:01:56.510 --> 00:02:00.580
the first thing you may think of
doing is just sending the username and

00:02:00.660 --> 00:02:04.580
password that the user types in into
your dialog directly across the network.

00:02:04.580 --> 00:02:09.780
But that's kind of a bad idea because
you can't trust the network in general.

00:02:09.780 --> 00:02:12.830
There could be, you know,
the server that you're connecting

00:02:12.830 --> 00:02:14.640
to may not be what you think it is.

00:02:14.640 --> 00:02:16.910
There could be someone interposing
between you and the actual

00:02:16.960 --> 00:02:18.180
service that you're using.

00:02:18.180 --> 00:02:21.850
Or, you know, just using TCP dump to
sniff your network traffic.

00:02:22.900 --> 00:02:26.020
TCP dump is part of
every Mac OS X machine.

00:02:26.020 --> 00:02:30.070
And they could have a hardware
sniffer on the network.

00:02:30.080 --> 00:02:33.260
So you have to assume that
the network is insecure.

00:02:35.620 --> 00:02:38.770
And there's three main
problems that we want to solve

00:02:39.560 --> 00:02:40.680
with network authentication.

00:02:40.770 --> 00:02:46.940
First of all, we need to prove the user's
identity to the service securely.

00:02:46.940 --> 00:02:50.360
And then we also need to prove
the server's identity to the user.

00:02:50.360 --> 00:02:53.150
That goes back to what I was talking
about where you're not sure if

00:02:53.150 --> 00:02:56.000
the server that you're connecting
to is what you think it is.

00:02:57.200 --> 00:03:01.650
So if you have some way independent
of the network stack to prove

00:03:01.650 --> 00:03:04.550
to the client what it is,
that gives you a lot more

00:03:04.550 --> 00:03:06.200
confidence in using that service.

00:03:06.200 --> 00:03:10.220
And finally, when you're dealing with
network authentication,

00:03:10.220 --> 00:03:13.810
you want to avoid asking the
user to enter their password

00:03:13.810 --> 00:03:15.880
over and over and over again.

00:03:15.880 --> 00:03:19.300
But also, you don't want to necessarily
always store it somewhere

00:03:19.300 --> 00:03:21.150
because that could be insecure.

00:03:21.170 --> 00:03:23.610
So we need a better solution to that.

00:03:26.360 --> 00:03:30.010
So the next step beyond just sending
the password in the clear would be to

00:03:30.010 --> 00:03:32.690
do a challenge response authentication.

00:03:33.280 --> 00:03:35.360
So the sequence goes something like this.

00:03:35.360 --> 00:03:39.400
Here we have a client and a server.

00:03:39.680 --> 00:03:44.920
And first, the client could send the
username to the server.

00:03:44.980 --> 00:03:48.550
The server would respond
with a random challenge.

00:03:48.820 --> 00:03:52.540
And finally,
the client sends back a response.

00:03:52.650 --> 00:03:57.430
The response is a function of
the challenge and the password,

00:03:57.430 --> 00:03:59.200
and it could also
incorporate the username,

00:03:59.200 --> 00:04:01.800
maybe other information.

00:04:01.800 --> 00:04:05.510
The other thing to keep in mind here is
actually in some authentication methods,

00:04:05.660 --> 00:04:08.790
the challenge is actually
sent before the username.

00:04:08.830 --> 00:04:11.680
So depending upon what auth
method we're talking about,

00:04:11.680 --> 00:04:14.810
it might be a little different,
but that's the basic idea.

00:04:15.460 --> 00:04:20.390
And Apple has something
called Password Server,

00:04:20.400 --> 00:04:25.140
which we've had in
Mac OS X Server since 10.2,

00:04:25.140 --> 00:04:28.320
and that is our solution for
challenge response authentication.

00:04:28.320 --> 00:04:31.850
It supports a wide variety
of authentication methods.

00:04:32.060 --> 00:04:35.680
It's based on the Simple Authentication
and Security Layer,

00:04:35.680 --> 00:04:42.460
or SASL, developed by Carnegie Mellon,
which is a library that allows you to

00:04:42.460 --> 00:04:48.040
abstract these various challenge response
authentication methods and provides a lot

00:04:48.120 --> 00:04:51.360
of code to do that and make it easier.

00:04:52.900 --> 00:04:57.030
It's based on the Simple Authentication
and Security Layer,

00:04:57.030 --> 00:05:02.970
or SASSL, developed by Carnegie Mellon,
which is a library that allows you to

00:05:02.970 --> 00:05:09.200
abstract these various challenge response
authentication methods and provides a lot

00:05:09.200 --> 00:05:11.930
of code to do that and make it easier.

00:05:13.120 --> 00:05:17.160
And the final point here,
we call the password server

00:05:17.160 --> 00:05:19.270
the Roach Motel of passwords.

00:05:19.400 --> 00:05:21.250
So passwords check in,
but they don't check out.

00:05:21.340 --> 00:05:25.450
There's no way to,
using that password server protocol,

00:05:25.450 --> 00:05:27.280
to harvest the passwords back.

00:05:27.300 --> 00:05:32.120
All you can do is do an authentication
through some secure challenge response

00:05:32.120 --> 00:05:36.770
authentication method or change the
password or set various options.

00:05:38.410 --> 00:05:40.800
So the authentication methods
I was talking about here,

00:05:40.800 --> 00:05:41.880
here's some examples.

00:05:41.880 --> 00:05:47.220
We have MD5 Digest, CRAM MD5,
NT Land Manager, and so on.

00:05:47.250 --> 00:05:49.330
You may have seen these before,
but depending upon which

00:05:49.350 --> 00:05:52.880
service you're talking about,
there may be one or two auth methods

00:05:52.880 --> 00:05:55.980
that are typically used by that service.

00:05:56.010 --> 00:05:58.160
And these sort of came up over the years.

00:05:58.160 --> 00:06:00.540
So we just put all of
them into Password Server.

00:06:00.570 --> 00:06:02.480
So all these things are
supported in Password Server,

00:06:02.480 --> 00:06:05.470
and we can work with a single
password across all these

00:06:05.470 --> 00:06:08.280
services on Mac OS X Server.

00:06:10.080 --> 00:06:13.970
So let's look at an example
password server authentication,

00:06:14.060 --> 00:06:16.740
the sequence that we would go through.

00:06:16.810 --> 00:06:18.140
You have four machines here.

00:06:18.140 --> 00:06:23.290
There's the client, the Panther server,
directory server, and a password server.

00:06:23.440 --> 00:06:26.480
And in some cases,
maybe the directory server

00:06:26.480 --> 00:06:28.080
and the password server
might be the same machine.

00:06:28.080 --> 00:06:30.710
That's the typical configuration,
but it could be different.

00:06:30.760 --> 00:06:35.150
So for purposes of this illustration,
we're going to keep them separate.

00:06:35.630 --> 00:06:38.970
So first,
the client's going to contact the service

00:06:39.440 --> 00:06:44.920
and send the various information about
what user they're doing and potentially

00:06:44.980 --> 00:06:47.900
the response to the challenge and so on.

00:06:47.940 --> 00:06:53.500
Then once the server has the user name,
it's going to-- oh, wait.

00:06:53.500 --> 00:06:54.110
OK.

00:06:54.140 --> 00:06:55.180
The arrow's going the wrong way.

00:06:55.320 --> 00:06:59.060
So the server looks up the user
record in the directory server

00:06:59.740 --> 00:07:01.470
and then gets a response back.

00:07:01.710 --> 00:07:04.140
So it finds the user record.

00:07:04.180 --> 00:07:07.390
And the user record will have an
authentication authority attribute that

00:07:07.390 --> 00:07:10.010
indicates it's a password server user.

00:07:10.100 --> 00:07:16.640
So at that point,
the server conducts authentication,

00:07:16.640 --> 00:07:19.510
sort of a pass-through authentication
against the password server.

00:07:19.610 --> 00:07:22.330
From the perspective of the client,
none of this is really important.

00:07:22.400 --> 00:07:24.300
But that's the sequence of steps.

00:07:24.300 --> 00:07:30.220
So once that password server
authentication from the service happens,

00:07:30.220 --> 00:07:33.580
then you have access to the service.

00:07:36.400 --> 00:07:39.070
Okay, so what is Kerbero?

00:07:39.150 --> 00:07:41.040
How many people here know about Kerbero?

00:07:41.040 --> 00:07:44.030
Okay, everybody almost.

00:07:44.030 --> 00:07:47.020
But I'll go through this anyway
for those of you who are new to

00:07:47.020 --> 00:07:48.860
Kerbero because it's important.

00:07:48.890 --> 00:07:52.780
So Kerbero is a secure network
authentication protocol.

00:07:52.780 --> 00:07:56.470
It doesn't deal with authorization,
which we talked about before,

00:07:56.540 --> 00:07:58.370
but it's for authentication.

00:07:59.350 --> 00:08:02.950
It was developed at MIT in the 1980s,
and there's actually a

00:08:03.060 --> 00:08:04.540
couple of versions in use.

00:08:04.540 --> 00:08:07.000
There's Kerbero V4,
which was the initial version,

00:08:07.000 --> 00:08:12.770
and that has some issues,
some security issues

00:08:12.770 --> 00:08:14.540
and problems with it.

00:08:14.540 --> 00:08:19.140
So Kerbero V5 was the solution to
the various issues with Kerbero V4,

00:08:19.140 --> 00:08:22.270
and that's really what Apple is
encouraging everyone to go with.

00:08:22.340 --> 00:08:25.680
V4 is primarily around
for legacy deployments,

00:08:25.680 --> 00:08:30.250
and in most cases, anything that's using
V4 is also using V5.

00:08:30.260 --> 00:08:34.090
So they just have a few
applications that are still on V4,

00:08:34.140 --> 00:08:36.740
and the rest of the stuff runs on V5.

00:08:36.800 --> 00:08:39.420
So when you set up an
open directory master,

00:08:39.470 --> 00:08:42.690
for example,
we're just setting up Kerbero V5,

00:08:42.710 --> 00:08:44.380
and we're doing everything
with Kerbero V5.

00:08:44.540 --> 00:08:45.540
Thank you.

00:08:46.970 --> 00:08:50.100
There's implementations
available on various platforms

00:08:50.660 --> 00:08:51.720
throughout the industry.

00:08:51.720 --> 00:08:59.820
So it's not just one vendor,
it's a standard, which is important.

00:09:00.570 --> 00:09:03.830
And it provides solutions to those three
problems that I talked about earlier.

00:09:03.870 --> 00:09:07.710
It proves the user's identity
to the server securely.

00:09:07.810 --> 00:09:12.080
It also proves the server's
identity to the client.

00:09:12.440 --> 00:09:15.420
And it provides what
we call single sign-on.

00:09:15.510 --> 00:09:19.460
So a single password dialogue
when you log in at the beginning

00:09:19.460 --> 00:09:23.350
of the day can unlock everything
for that entire day's session.

00:09:23.360 --> 00:09:28.320
Anything that's using Kerbero can take
advantage of that and still be secure,

00:09:28.570 --> 00:09:32.760
not just replaying the password
constantly to get that feature.

00:09:35.040 --> 00:09:39.060
So given all of these strengths,
Apple is adopting Kerbero

00:09:39.060 --> 00:09:40.690
throughout Mac OS X.

00:09:43.680 --> 00:09:47.100
So I know a lot of this is review for
most of you who know about Kerbero,

00:09:47.100 --> 00:09:49.490
but I'll just go through it quickly.

00:09:49.720 --> 00:09:50.470
Some definitions.

00:09:50.480 --> 00:09:54.830
So a Realm is a Kerbero namespace.

00:09:54.910 --> 00:09:57.990
It's sort of the Kerbero
version of a domain or...

00:09:58.310 --> 00:10:05.750
and I will be talking about the
different versions of Kerbero.

00:10:06.630 --> 00:10:07.880
Then we have a principle.

00:10:08.110 --> 00:10:09.920
There's actually two kinds of principles.

00:10:09.970 --> 00:10:13.350
So there could be a user
principle or a service principle.

00:10:13.380 --> 00:10:15.980
These are entities in
the Kerberoos database.

00:10:15.980 --> 00:10:18.020
So a user principle
corresponds to a user,

00:10:18.020 --> 00:10:20.440
a service principle
corresponds to a service.

00:10:20.440 --> 00:10:25.310
You can also have a host principle for
a particular machine on the network.

00:10:25.820 --> 00:10:30.730
and you have either user at the realm
or service type slash host name at

00:10:30.730 --> 00:10:33.570
the realm as the style of name there.

00:10:34.060 --> 00:10:35.540
And we have the Key Distribution Center.

00:10:35.540 --> 00:10:41.700
This is the server that provides the,
this is the Kerbero server.

00:10:41.700 --> 00:10:47.260
So it handles all of the
transactions for sending the various

00:10:47.260 --> 00:10:50.570
authentication tokens around.

00:10:52.240 --> 00:10:53.560
We actually call those tickets.

00:10:53.560 --> 00:10:58.970
So we have a ticket as the name for
an authentication token or credential.

00:10:58.970 --> 00:11:00.560
And this is used instead of a password.

00:11:00.560 --> 00:11:05.910
So when you first connect to a service,
all you're handed is the ticket

00:11:05.910 --> 00:11:07.880
and then it verifies the ticket.

00:11:07.880 --> 00:11:11.440
And it has an expiration date,
so any ticket that you get can only

00:11:11.790 --> 00:11:15.630
potentially be compromised for a finite
amount of time and then it's expired

00:11:15.820 --> 00:11:18.110
and no one's going to honor it anymore.

00:11:19.000 --> 00:11:22.690
The ticket granting ticket
is a special kind of ticket,

00:11:22.690 --> 00:11:24.780
which is what provides single sign-on.

00:11:24.800 --> 00:11:28.180
So when you first log in
at the Kerbero dialogue,

00:11:28.440 --> 00:11:34.510
you get a TGT and then that
TGT is used to later get other

00:11:34.510 --> 00:11:36.720
tickets for various services.

00:11:36.800 --> 00:11:40.590
And that can be done transparently
as long as the TGT is still valid.

00:11:42.280 --> 00:11:44.630
And the service ticket,
which I mentioned already,

00:11:44.630 --> 00:11:48.820
authenticates the user to a service,
and that's granted as long as you

00:11:48.920 --> 00:11:55.190
have a valid TGT and the service
principal name provided from the client.

00:11:56.500 --> 00:12:01.040
So, here's another example diagram.

00:12:01.040 --> 00:12:06.380
We've got the client and the KDC in
the middle and then the server.

00:12:07.300 --> 00:12:09.460
So first, the client requests a TGT.

00:12:09.500 --> 00:12:14.140
This is assuming that you're coming to
the machine and you don't yet have a TGT.

00:12:14.390 --> 00:12:21.920
And then the TGT is returned with a
client key and the client has a TGT.

00:12:21.920 --> 00:12:27.160
And then some point later,
the client wants to access a service.

00:12:27.580 --> 00:12:32.810
sends the TGT and a request for
a service ticket to the KDC.

00:12:32.810 --> 00:12:35.440
It gets back the service ticket.

00:12:35.510 --> 00:12:38.140
So now it has the TGT and
the service ticket.

00:12:38.140 --> 00:12:40.840
At this point, it can contact the server.

00:12:40.840 --> 00:12:44.460
So it sends the service
ticket to the server,

00:12:44.460 --> 00:12:48.780
and then the server verifies
that and responds and allows

00:12:48.780 --> 00:12:50.690
access to the service.

00:12:51.500 --> 00:12:54.980
One thing to note here is that the
server actually doesn't have to

00:12:55.080 --> 00:12:59.250
contact the KDC to verify the ticket
because it has a service principle,

00:12:59.270 --> 00:13:03.140
which is a shared secret
between the KDC and the server.

00:13:03.140 --> 00:13:07.540
So that means there's part of the
ticket which is encrypted by that

00:13:07.540 --> 00:13:11.620
service key or the service principle,
and then it can verify

00:13:11.620 --> 00:13:13.700
that it decrypts properly.

00:13:18.090 --> 00:13:20.500
So with all of these great
things about Kerbero,

00:13:20.560 --> 00:13:26.390
you have to wonder why hasn't it caught
on in more than the areas that it has?

00:13:26.440 --> 00:13:28.950
Why is it not used everywhere?

00:13:29.130 --> 00:13:31.080
There's a few barriers
to Kerbero adoption,

00:13:31.080 --> 00:13:34.780
and we tried to address
all of these in Panther.

00:13:34.850 --> 00:13:38.490
The first one,
it requires you to deploy KDC.

00:13:38.580 --> 00:13:45.030
So that usually meant a lot of work,
and it wasn't really easy to do.

00:13:45.090 --> 00:13:49.440
In Panther, we ship with a full KDC.

00:13:49.440 --> 00:13:52.970
It's set up by default whenever you
set up an Open Directory master,

00:13:52.970 --> 00:13:57.790
and it's just a matter of picking
one menu item in server admin

00:13:57.790 --> 00:14:00.940
to do it and entering a username
and password to set it up.

00:14:01.010 --> 00:14:03.620
So it's really simple.

00:14:04.730 --> 00:14:10.100
Another issue with Kerbero is how do you
integrate it with the directory server?

00:14:10.200 --> 00:14:14.740
And there's a lot of times that
would be a site-specific decision.

00:14:14.820 --> 00:14:19.380
But in Panther,
we've integrated all the open directory

00:14:19.380 --> 00:14:23.450
tools with it and we've used the
authentication authority attribute

00:14:23.660 --> 00:14:28.860
and come up with a standard way of
integrating Kerbero into the directory

00:14:28.860 --> 00:14:32.240
and doing that mapping between the two.

00:14:33.550 --> 00:14:36.050
Another problem is a lack of
integrated user account management.

00:14:36.070 --> 00:14:39.730
What this means is,
let's say that you're deploying

00:14:39.730 --> 00:14:41.440
Kerbero and LDAP together.

00:14:41.480 --> 00:14:43.790
What would you do when you set that up?

00:14:43.890 --> 00:14:46.830
Well,
every time you create a record in LDAP,

00:14:46.840 --> 00:14:49.800
you also need a user
principle to go with it.

00:14:49.860 --> 00:14:52.620
But the tools that you use to do
that might be completely different.

00:14:52.730 --> 00:14:57.440
And so it would be kind of a difficult
thing to do and you'd have to go back

00:14:57.440 --> 00:14:59.860
and forth between different tools.

00:15:00.290 --> 00:15:03.870
Well, in Panther,
Workgroup Manager automatically

00:15:03.870 --> 00:15:06.490
creates the user principles
as you create user records.

00:15:06.570 --> 00:15:08.900
So as long as you have
Open Directory set up,

00:15:08.900 --> 00:15:11.930
whenever you create a user,
it's going to get a Kerbero's

00:15:11.930 --> 00:15:14.270
principle created for it.

00:15:15.870 --> 00:15:20.540
Another problem is the service
and host principles are

00:15:20.540 --> 00:15:21.940
kind of difficult to manage.

00:15:21.940 --> 00:15:25.570
You have to have all of the servers
that are in your network be registered

00:15:25.570 --> 00:15:29.310
in the KDC so that they have that
shared secret for the system to work.

00:15:29.310 --> 00:15:34.190
And that could be potentially
a difficult thing to manage.

00:15:34.570 --> 00:15:39.820
So we compose those in
Panther Server Configuration Tools.

00:15:39.820 --> 00:15:43.900
And another thing that we've done
is we actually allow you to put that

00:15:43.900 --> 00:15:48.750
information encrypted into the directory
and use the directory as a mechanism

00:15:48.770 --> 00:15:51.020
to distribute those service principles.

00:15:51.020 --> 00:15:56.240
So you can have potentially the directory
administrator create that record and

00:15:56.240 --> 00:15:59.490
then a completely different person
who's the administrator of your file

00:15:59.490 --> 00:16:04.200
server can later grab that record,
enter a password, their password in order

00:16:04.200 --> 00:16:05.700
to decrypt that record.

00:16:05.700 --> 00:16:10.780
And that's all they need to do
to set up Kerbero on that server.

00:16:12.610 --> 00:16:16.170
Another problem is you'd have to do
command line level configuration of

00:16:16.180 --> 00:16:19.370
the Kerbero clients or potentially
make an installer package that

00:16:19.370 --> 00:16:23.430
has your config file in it to
distribute out to all of your users.

00:16:23.440 --> 00:16:26.650
And then you have to go through the
trouble of installing that everywhere,

00:16:26.650 --> 00:16:28.840
copying the file,
which is kind of a problem.

00:16:28.840 --> 00:16:33.240
In Panther, we auto-configure Kerbero.

00:16:33.240 --> 00:16:35.960
All we do is we just put
a record in the directory,

00:16:35.960 --> 00:16:39.530
and the Panther and later clients
are going to look for that.

00:16:39.710 --> 00:16:42.050
So if they see that
Kerbero's client record,

00:16:42.050 --> 00:16:46.230
they'll just generate the
Edge UMIT Kerbero's file from it.

00:16:46.320 --> 00:16:49.850
And so you can centrally configure
how you want the clients to be

00:16:49.850 --> 00:16:54.060
using Kerbero's rather than having
to do it over and over again.

00:16:56.660 --> 00:17:02.630
Another problem which you have,
which is very important,

00:17:02.630 --> 00:17:06.120
is in a traditional Kerbero set up,
you would have no support for

00:17:06.120 --> 00:17:07.830
legacy network authentication.

00:17:08.010 --> 00:17:11.040
What I mean by legacy network
authentication is at the beginning

00:17:11.140 --> 00:17:13.780
I was talking about all these
challenge response protocols,

00:17:13.870 --> 00:17:18.140
authentication methods that
are used by various protocols.

00:17:18.200 --> 00:17:22.030
And normally you'd have to have
all of your network services be

00:17:22.030 --> 00:17:24.250
on Kerbero in order to integrate.

00:17:24.410 --> 00:17:27.510
Well, what we've done

00:17:28.110 --> 00:17:31.800
So, the idea in Panther is to actually
integrate Kerbero with password server.

00:17:31.800 --> 00:17:37.000
So, there's one password between
Kerbero and password server.

00:17:37.000 --> 00:17:39.000
Whenever you change one,
it syncs to the other.

00:17:39.000 --> 00:17:41.930
So,
you have access to all the great features

00:17:41.930 --> 00:17:47.120
of Kerbero as well as continue to support
the legacy network authentication,

00:17:47.120 --> 00:17:50.480
which is important if you have, say,
a remote worker that's not

00:17:50.490 --> 00:17:54.440
going to be set up for Kerbero,
but they do have -- they need

00:17:54.440 --> 00:17:56.000
to have access to a file server.

00:17:56.000 --> 00:17:58.450
So,
you might want to just allow them to do

00:17:58.450 --> 00:18:00.770
a traditional authentication for that.

00:18:00.990 --> 00:18:04.840
Or if they have an older platform
that they can't upgrade to

00:18:04.970 --> 00:18:08.850
be able to support Kerbero,
they can still do the older

00:18:08.850 --> 00:18:10.940
authentication methods.

00:18:11.980 --> 00:18:15.140
So going back through the benefits again,
we have single sign-on,

00:18:15.140 --> 00:18:19.000
which is very convenient,
but it's still secure.

00:18:19.070 --> 00:18:20.690
We're not just replaying passwords.

00:18:20.790 --> 00:18:24.320
We have mutual authentication,
so you can trust when you're

00:18:24.320 --> 00:18:28.110
using a Kerberized service that
you are getting the same server

00:18:28.120 --> 00:18:30.390
that you thought it was before.

00:18:30.840 --> 00:18:34.450
And another very important thing is
client and server programs are out of

00:18:34.450 --> 00:18:36.440
the business of dealing with passwords.

00:18:36.560 --> 00:18:39.100
So they're just passing tickets around.

00:18:39.110 --> 00:18:44.650
And all of the prompting for passwords
is handled by the Kerberoes framework.

00:18:44.710 --> 00:18:47.100
So your application doesn't
have to care about that.

00:18:47.170 --> 00:18:50.610
And at some point in the future,
it may not be prompting for

00:18:50.690 --> 00:18:52.860
a password or it might be a
password plus something else.

00:18:52.860 --> 00:18:57.420
There might be a smart card or some
biometric data that's being used.

00:18:57.740 --> 00:19:02.830
As long as that process gets a TGT,
everything after that that's Kerberized

00:19:02.990 --> 00:19:06.700
will pick up that new non-password
based authentication for free.

00:19:06.770 --> 00:19:09.630
So we really wanna get everything
onto Kerberoes so we have this kind

00:19:09.680 --> 00:19:12.150
of flexibility to expand in that area.

00:19:12.260 --> 00:19:17.580
As I said before, Kerberoes is secure and
it's cross-platform.

00:19:20.170 --> 00:19:22.780
So some more features
that we have in Panther.

00:19:22.790 --> 00:19:27.690
Once we had Kerbero and password
server to really make this

00:19:27.690 --> 00:19:32.120
something useful to deploy,
we added secure multi-master

00:19:32.170 --> 00:19:33.850
replication support.

00:19:33.920 --> 00:19:39.500
So what that means is you can have
a bunch of machines all with the

00:19:39.500 --> 00:19:42.000
same password data and you can
authenticate against any one of them.

00:19:42.000 --> 00:19:45.840
You can change your password against
any one of them and that change will

00:19:45.880 --> 00:19:47.940
propagate throughout the system.

00:19:48.020 --> 00:19:53.060
So there's no single point of failure
there and the clients were also updated

00:19:53.500 --> 00:19:57.660
so that they would automatically
fail over to whatever's available.

00:19:57.730 --> 00:20:02.000
So the client, you know,
the user won't even necessarily know that

00:20:02.060 --> 00:20:05.380
the password server they were talking to
before happens to be down at the moment

00:20:05.380 --> 00:20:08.090
and used a different one this time.

00:20:09.630 --> 00:20:14.450
There's support for password policies,
so you can force people to change

00:20:14.490 --> 00:20:19.020
their password or specify what
the minimum length is and so on.

00:20:19.030 --> 00:20:23.380
And that can be done globally
and on a per-user basis.

00:20:24.810 --> 00:20:27.400
We added the PW Policy command line tool.

00:20:27.400 --> 00:20:30.400
And this is just providing the
same functionality that we had

00:20:30.410 --> 00:20:35.370
in Workgroup Manager and the
Server Admin Open Directory plugin,

00:20:35.370 --> 00:20:36.440
but at the command line level.

00:20:36.440 --> 00:20:40.140
So you can take advantage of
that from a script or if you're

00:20:40.140 --> 00:20:44.730
administering through SSH,
you can do everything you need to do.

00:20:45.730 --> 00:20:47.860
And don't forget, Crypt is dead.

00:20:47.860 --> 00:20:53.180
Okay, no applause, but anyway,
Crypt is still dead.

00:20:53.220 --> 00:20:56.850
And that was accomplished in Panther.

00:20:56.910 --> 00:20:58.680
We actually already had
password server in Jaguar,

00:20:58.680 --> 00:21:02.980
but in Panther,
we replaced the local users with

00:21:02.980 --> 00:21:05.660
their Crypt passwords with ShadowHash.

00:21:05.690 --> 00:21:09.180
And then we used Kerbero and
password server for network users.

00:21:10.360 --> 00:21:12.970
So here's a screenshot of what
the global password policy

00:21:12.970 --> 00:21:15.610
looks like in server admin.

00:21:16.340 --> 00:21:19.830
So there's all kinds of
things you can set there.

00:21:19.830 --> 00:21:23.520
And then we have the per
user password policy,

00:21:23.530 --> 00:21:26.470
which is in Workgroup Manager.

00:21:29.800 --> 00:21:32.970
So the message we want you
to get here is that Apple's

00:21:32.970 --> 00:21:35.000
providing a complete solution.

00:21:35.000 --> 00:21:38.080
We have Kerbero for security,
mutual authentication,

00:21:38.080 --> 00:21:39.200
and single sign-on support.

00:21:39.200 --> 00:21:43.160
Password server supports
your legacy needs.

00:21:43.190 --> 00:21:47.860
All of this is done with replication
and client-side failover.

00:21:47.860 --> 00:21:53.200
We've got the administration tools
both at the GUI level and command line.

00:21:53.200 --> 00:21:56.730
And we're doing a lot of
auto-configuration for you

00:21:56.850 --> 00:22:01.200
so that it's really easy to
add a system to use Kerbero.

00:22:01.200 --> 00:22:05.160
You get the Kerbero for free as long
as you can connect to the LDAP server.

00:22:05.200 --> 00:22:09.200
So whatever you need to do to get
LDAP is all you need to use Kerbero.

00:22:09.200 --> 00:22:13.100
Which if you're using DHCP,
it might be nothing at all.

00:22:13.200 --> 00:22:18.320
So at this point,
I'd like to bring up Leland Wallace to

00:22:18.330 --> 00:22:21.700
talk about our changes in Tiger.

00:22:27.570 --> 00:22:28.820
Thanks, Jason.

00:22:29.070 --> 00:22:33.190
I'd like to talk about what we've done
with authentication in Tiger here.

00:22:33.770 --> 00:22:37.050
First thing we've done is,
as many people have said before,

00:22:37.050 --> 00:22:40.650
added password server support,
or actually added Intel MV2

00:22:40.650 --> 00:22:42.530
support to password server.

00:22:42.700 --> 00:22:45.540
We've added some password
policy enforcement between the

00:22:45.540 --> 00:22:47.640
password server and the KDC.

00:22:47.690 --> 00:22:50.760
Added Spanago for
Active Directory support with

00:22:50.760 --> 00:22:56.100
SMB and also with... It was a pain.

00:22:56.160 --> 00:22:58.130
And we've added some
new Kerberized services,

00:22:58.130 --> 00:23:03.200
so we're continuing upon our
drive to Kerberize the entire OS.

00:23:05.050 --> 00:23:09.250
So every open directory server has,
or every password server has a

00:23:09.250 --> 00:23:14.020
Kerbero's principle and it's used
to sync up password changes between

00:23:14.020 --> 00:23:17.200
both the KDC and the password server.

00:23:17.280 --> 00:23:20.080
And we've added for Tiger,
we've added password policies

00:23:20.420 --> 00:23:24.020
in the password server are
now honored by the KDC as our

00:23:24.100 --> 00:23:26.690
password and account expirations.

00:23:28.240 --> 00:23:32.080
Some of the new services that we've got,
and I'll start with the old services,

00:23:32.080 --> 00:23:36.440
the existing services, AFP, FTP,
the mail troika there,

00:23:36.440 --> 00:23:40.240
and SSH and login window are the
old ones that we've got in Panther.

00:23:40.240 --> 00:23:49.350
We've added LDAP, Espanago for the web,
both client and server side,

00:23:49.350 --> 00:23:53.280
and the SMB stuff for Tiger.

00:23:54.510 --> 00:23:56.350
I'd like to talk,
just give a quick overview

00:23:56.350 --> 00:24:00.380
of what kind of command line
tools we have for Kerbero now.

00:24:01.100 --> 00:24:03.910
Starting out,
these are the things that our single

00:24:03.910 --> 00:24:05.650
sign-on solutions are built on.

00:24:05.660 --> 00:24:12.090
MIT's got, you know, KADMIN, KDB5 UTIL,
and KT UTIL.

00:24:12.130 --> 00:24:16.260
Well, the Apple, we've got SLAP Config,
SSO UTIL, and a bunch of others there.

00:24:16.260 --> 00:24:20.470
They've all got man pages.

00:24:20.470 --> 00:24:25.800
They're all at least
reasonably intelligible,

00:24:25.800 --> 00:24:25.800
I think.

00:24:25.800 --> 00:24:25.800
They are.

00:24:27.150 --> 00:24:29.780
The MIT tools,
KAdmin is used to deal with

00:24:29.780 --> 00:24:33.940
server principles and user
principles and policies.

00:24:34.020 --> 00:24:38.110
KDB5 Util looks at the Kerbero
database just as a database,

00:24:38.180 --> 00:24:40.500
dumping it, restoring it,
things like that.

00:24:40.530 --> 00:24:45.210
KT Util manages the key tabs
that you need on the servers.

00:24:45.920 --> 00:24:49.040
There are other tools like KNet, K-List,
K-Destroy.

00:24:49.040 --> 00:24:52.750
Those are user level things to be
able to manage your ticket cash

00:24:52.750 --> 00:24:54.880
and stuff from the command line.

00:24:55.760 --> 00:24:57.650
The Apple tools,
slap config is sort of the

00:24:57.660 --> 00:24:59.350
high level front end of it all.

00:24:59.360 --> 00:25:02.190
It works with setting
up the open directory,

00:25:02.190 --> 00:25:05.560
setting up the KDC and doing
a bunch of other things.

00:25:05.640 --> 00:25:08.590
A lot of good stuff is
in the slap config log.

00:25:08.600 --> 00:25:16.520
If you are having trouble with things,
slap config log is one of

00:25:16.520 --> 00:25:16.520
the first places to look.

00:25:16.520 --> 00:25:16.520
Let's see.

00:25:17.120 --> 00:25:22.390
Kerbero auto-config,
this is the command line tool which

00:25:22.390 --> 00:25:26.360
is run whenever the search policy
changes on the clients and that

00:25:26.380 --> 00:25:28.780
provides our client auto-config stuff.

00:25:28.860 --> 00:25:33.030
That's where it writes the
edu.mit.kerbero file out.

00:25:33.730 --> 00:25:39.260
KDC setup creates the
Kerbero's client records in the

00:25:39.260 --> 00:25:39.260
directory and sets up the KDC.

00:25:40.770 --> 00:25:47.410
Kerberos Service Setup sets up
the Kerbero services and SSO Util

00:25:48.270 --> 00:25:53.600
It's another high-level tool,
and it allows you to do a lot of things

00:25:53.630 --> 00:25:59.390
in configuring servers this way and
also generating the stored config that

00:25:59.390 --> 00:26:04.900
Jason was alluding to earlier to allow
the network administrator to delegate

00:26:05.670 --> 00:26:09.160
to delegate the responsibility
of Kerberizing a specific server

00:26:09.240 --> 00:26:15.320
to a server admin rather than
having to do it all on themselves.

00:26:15.800 --> 00:26:20.360
Setting it up, we prefer you to use the
GUI to set up Kerbero.

00:26:20.470 --> 00:26:23.190
It's just selecting the
Open Directory master

00:26:23.190 --> 00:26:24.610
from the pop-up menu.

00:26:24.670 --> 00:26:26.220
You can also use command line tools.

00:26:26.260 --> 00:26:30.180
The folks at AFP 548,
you know you're out there someplace,

00:26:30.180 --> 00:26:31.950
have done an excellent job.

00:26:31.960 --> 00:26:35.440
There's nothing I can
add to what you've said.

00:26:36.100 --> 00:26:38.710
You can do it by hand,
looking at the instructions

00:26:38.710 --> 00:26:40.010
in the Kerbero admin guide.

00:26:40.110 --> 00:26:41.100
It's a little bit painful.

00:26:41.100 --> 00:26:43.160
That's why we're doing all of this.

00:26:43.200 --> 00:26:49.470
And when you want to integrate it
into an existing Kerbero setup,

00:26:50.000 --> 00:26:53.680
There are some things that you
can do to an existing LDAP server,

00:26:53.680 --> 00:26:57.180
adding a Kerbero client record,
to be able to get some of the

00:26:57.180 --> 00:26:59.630
benefits of our single sign-on stuff.

00:26:59.760 --> 00:27:02.700
You can add the Kerbero client record
that all your Panther clients will

00:27:02.700 --> 00:27:05.820
automatically configure for Kerbero,
create Kerbero auth

00:27:05.900 --> 00:27:10.180
authorities for your users,
and they'll all get TGTs on login.

00:27:12.080 --> 00:27:15.230
Setting up a Kerberoz server.

00:27:15.310 --> 00:27:18.100
You know,
you've got just one network admin,

00:27:18.100 --> 00:27:24.750
one person who knows the master
password for the KDC database and such,

00:27:24.820 --> 00:27:27.000
and lots of servers.

00:27:27.040 --> 00:27:32.330
It's a real pain if you have to go out
to each server and set it up manually.

00:27:32.330 --> 00:27:36.730
So what we've done is we've allowed
the network administrator to

00:27:36.790 --> 00:27:39.450
delegate part of that setup to you.

00:27:39.810 --> 00:27:43.400
Network Administrator has got to
create a computer record and then

00:27:43.400 --> 00:27:48.340
attaches a Kerbero record to that,
or a secure config record we call it.

00:27:48.340 --> 00:27:54.200
And that contains the key tab file,
a list of authorized users,

00:27:54.210 --> 00:27:55.260
and some other stuff.

00:27:55.260 --> 00:28:01.330
And it's encrypted all to a set of
admins that you've delegated to.

00:28:01.680 --> 00:28:06.010
The delegated admin then grabs
that record and decrypts it and

00:28:06.010 --> 00:28:10.960
then that installs the key tab
file and Kerberizes the services.

00:28:11.040 --> 00:28:16.830
This will also work now
with Active Directory.

00:28:17.630 --> 00:28:22.010
The delegated admin then grabs
that record and decrypts it and

00:28:22.010 --> 00:28:23.930
then that installs the key tab
file and Kerberizes the services.

00:28:23.930 --> 00:28:23.930
This will also work now
with Active Directory.

00:28:25.160 --> 00:28:29.400
KDC setup is the thing that creates the
Kerbero client and Kerbero KDC records.

00:28:29.480 --> 00:28:32.390
Kerbero client record is
again used for client setup,

00:28:32.390 --> 00:28:37.790
whereas the Kerbero KDC record
is used when you are replicating,

00:28:37.790 --> 00:28:40.880
setting up replicated KDCs.

00:28:40.960 --> 00:28:43.920
Kerbero auto-config pulls that data
out of the Kerbero client record

00:28:43.920 --> 00:28:47.280
and puts it onto your desk there.

00:28:47.360 --> 00:28:55.390
Then the SSO util is used to create
the secure config records that,

00:28:55.390 --> 00:28:58.500
or the SSO util generate
config command creates the

00:28:58.540 --> 00:29:03.920
secure config records for the,
which allow the network administrator

00:29:03.920 --> 00:29:10.090
to delegate to the server administrator
and then SSO util use config takes that

00:29:10.130 --> 00:29:15.590
same configuration and then installs
it in a server and Kerberos the server.

00:29:17.140 --> 00:29:20.500
The Kerbero's client record,
I don't know if everyone can see that,

00:29:20.500 --> 00:29:25.120
is a pretty straightforward
XML translation of the

00:29:25.120 --> 00:29:28.100
edu.mid.kerberos file.

00:29:28.100 --> 00:29:33.100
If you need to edit this by hand,
it's not all that difficult.

00:29:33.100 --> 00:29:38.920
You add domain realm mappings,
the various defaults, realms,

00:29:39.150 --> 00:29:45.100
and all of the other major tags in the
edu.mid.kerberos file are supported

00:29:45.100 --> 00:29:50.310
and will be read out just fine.

00:29:50.770 --> 00:29:55.720
The Kerbero KDC record is,
since we don't edit this at all,

00:29:55.800 --> 00:30:01.120
is just a more literal translation of
the KDC.conf record that you find down

00:30:01.150 --> 00:30:07.080
next to the Kerbero database stuff.

00:30:07.910 --> 00:30:13.380
And another useful,
useful record type or actually

00:30:13.380 --> 00:30:16.660
it's a property I think,
isn't it?

00:30:16.910 --> 00:30:18.040
It's an attribute type.

00:30:18.040 --> 00:30:20.400
It's the Kerbero's auth authority.

00:30:20.470 --> 00:30:30.020
It's used by login window to
determine whether or not this user

00:30:30.020 --> 00:30:30.360
is Kerberized and that helps it get
the TGT and also when you're changing

00:30:30.360 --> 00:30:30.360
a password through system prefs.

00:30:31.060 --> 00:30:31.970
It looks like this.

00:30:32.050 --> 00:30:35.870
It starts with the Kerbero 5 and
there's some optional fields,

00:30:35.880 --> 00:30:37.560
the GUID, the principal name.

00:30:37.600 --> 00:30:41.550
The Realm name is not optional
and the Realm key is optional.

00:30:42.390 --> 00:30:46.630
At minimum, we want to see Kerbero's
5 and then the Realm.

00:30:46.630 --> 00:30:50.410
And from that,
our code can figure out that the user's

00:30:50.600 --> 00:30:56.440
principal name is going to be used,
the first short name at the Realm name.

00:30:56.650 --> 00:30:59.650
Ideally,
we would like to see the actual user

00:30:59.650 --> 00:31:02.290
principle in that auth authority.

00:31:02.290 --> 00:31:05.880
It would be a good idea if
you're creating these on your

00:31:05.880 --> 00:31:08.790
own to add the principle name
as an additional short name.

00:31:08.790 --> 00:31:13.810
It will make some things
easier in the future.

00:31:15.020 --> 00:31:20.450
I'd like to talk now about
using Kerbero in your apps.

00:31:20.580 --> 00:31:23.960
Things you need for
Kerbero development are,

00:31:24.020 --> 00:31:25.490
of course, a KDC.

00:31:25.560 --> 00:31:29.390
In this case, we would like you to
use a Mac OS X Server,

00:31:29.450 --> 00:31:36.080
a Mac OS X client,
your server processes and

00:31:36.080 --> 00:31:36.080
your client processes.

00:31:36.160 --> 00:31:40.690
I'd like to talk about what you need to
do when you have an existing protocol.

00:31:40.710 --> 00:31:44.410
If you're writing a new FTP client, say,
or a new mail client,

00:31:44.410 --> 00:31:46.480
you'd need to think about this.

00:31:46.480 --> 00:31:49.150
If you're writing a
completely new protocol,

00:31:49.280 --> 00:31:52.360
there are some other things
you need to think about.

00:31:52.360 --> 00:31:53.820
They're just stuff you need to decide.

00:31:53.820 --> 00:31:57.890
I'd like to give you a demo of how,
or not a demo,

00:31:57.890 --> 00:32:04.800
but an explanation of how you use GSS,
which is Generic Security Services API,

00:32:04.810 --> 00:32:07.890
to do a Kerbero authentication,
and then talk about things that you

00:32:07.890 --> 00:32:12.000
no longer need to worry about once
you've Kerberized your authentication.

00:32:12.700 --> 00:32:18.220
So if you've got an existing protocol,
if it's HTTP based, use what we've got in

00:32:18.220 --> 00:32:20.360
Foundation and CF Network.

00:32:20.450 --> 00:32:21.960
Some of that's
automatically done for you.

00:32:21.960 --> 00:32:27.670
You'll automatically get Espanago support
without having to do anything at all,

00:32:27.670 --> 00:32:28.760
as I recall.

00:32:28.980 --> 00:32:31.270
If not, then look into SASL.

00:32:31.360 --> 00:32:37.090
There's a good RFC on it,
and it's fairly widely supported.

00:32:37.270 --> 00:32:42.550
For other protocols, FTP, POP, IMAP, SSH,
there's all RFCs and standards on how

00:32:42.550 --> 00:32:44.540
you are supposed to do those things.

00:32:44.540 --> 00:32:46.200
Don't invent anything you don't have to.

00:32:46.200 --> 00:32:49.480
It's not worth the trouble.

00:32:50.330 --> 00:32:54.600
For new protocol, again,
if you're HTTP based, use CF Network.

00:32:54.680 --> 00:32:57.080
You'll get what you need for free.

00:32:57.170 --> 00:33:02.400
Use SASL with a GSS mechanism
if HTTP doesn't work for you.

00:33:02.470 --> 00:33:05.750
If you need to roll your own,
use the GSS APIs.

00:33:05.750 --> 00:33:07.100
They make things very easy.

00:33:07.100 --> 00:33:15.860
And if that winds up being too limiting,
go with the Curb 5 APIs there.

00:33:19.000 --> 00:33:22.990
One of the things you need to decide
if you're creating a new protocol,

00:33:22.990 --> 00:33:25.130
you need to decide on the service type.

00:33:25.180 --> 00:33:29.550
Here, in this case, it's webcam.

00:33:30.680 --> 00:33:33.800
And the rest of that is just
the service principal name.

00:33:33.850 --> 00:33:39.110
Then you need to find a way for the
client to construct the principal name.

00:33:39.310 --> 00:33:43.570
It needs, you know,
it can either get it implicitly

00:33:43.570 --> 00:33:49.310
from the DNS address of the server,
like in the way FTP or SSH does.

00:33:49.300 --> 00:33:53.540
Yeah, that leaves you dependent upon DNS,
which can either be a

00:33:53.540 --> 00:33:55.400
good thing or a bad thing.

00:33:55.500 --> 00:33:58.910
Or you can do it explicitly,
getting it from a secure

00:33:58.920 --> 00:34:01.040
source such as the directory.

00:34:01.140 --> 00:34:03.020
And that's typically a
little bit more friendly,

00:34:03.020 --> 00:34:04.860
but there's more infrastructure required.

00:34:04.860 --> 00:34:06.220
You've got to actually work at things.

00:34:08.450 --> 00:34:13.060
So here's a simple Kerbero
authentication using GSS,

00:34:13.100 --> 00:34:15.590
and this is after the
user's gotten their TGT.

00:34:15.610 --> 00:34:19.520
So the first thing's first,
the client needs to figure out

00:34:19.520 --> 00:34:23.620
what the service principle is,
and then it calls

00:34:23.660 --> 00:34:26.720
GSS import name on that.

00:34:27.610 --> 00:34:31.100
After that,
it calls GSS and its security context.

00:34:31.290 --> 00:34:35.850
That goes and talks to the KDC,
asks for a service ticket.

00:34:36.540 --> 00:34:37.690
Service ticket comes back.

00:34:37.760 --> 00:34:41.690
The client then sends that
service ticket off to the server.

00:34:41.730 --> 00:34:45.580
Server calls GSS Accept Security Context.

00:34:45.910 --> 00:34:51.460
And that pulls the server's
key out of the key tab file.

00:34:52.340 --> 00:34:55.500
Server returns the GSS token.

00:34:55.500 --> 00:34:58.070
At this point,
the client and the server have both

00:34:58.110 --> 00:34:59.800
been authenticated to one another.

00:34:59.850 --> 00:35:03.540
Note that the server has only had
to make one call and the client has

00:35:03.540 --> 00:35:07.110
only had to make three calls now
because the token is passed back

00:35:07.110 --> 00:35:09.290
into GSS in its security context.

00:35:09.300 --> 00:35:15.700
The server then needs to do an additional
step of checking the authorization.

00:35:15.700 --> 00:35:19.630
That would be checking the client
principal against an ACL or something

00:35:19.630 --> 00:35:24.580
like that and checking to see that the
service principal that you sent was

00:35:24.670 --> 00:35:30.570
indeed the service principal of the
server you actually are talking to.

00:35:31.190 --> 00:35:34.380
And then to get an encrypted
data stream between the two,

00:35:34.440 --> 00:35:37.160
between the client and the server,
you can use the gsswrap

00:35:37.160 --> 00:35:41.080
and gssunwrap commands,
gsswrap encrypts, gssunwrap decrypts.

00:35:41.080 --> 00:35:43.720
It's pretty much just that simple.

00:35:45.370 --> 00:35:49.830
So in review here, on the client side,
you call GSS import name and

00:35:49.860 --> 00:35:51.640
GSS in its security context.

00:35:51.640 --> 00:35:54.220
On the server side,
you accept that context.

00:35:54.220 --> 00:35:58.510
And then on the client side,
you pass the token that comes back

00:35:58.510 --> 00:36:01.100
into GSS in its security context.

00:36:01.100 --> 00:36:05.050
You can actually go around
this loop several times if

00:36:05.220 --> 00:36:09.930
there's an authentication
mechanism that actually needs it.

00:36:09.990 --> 00:36:12.000
Kerbero does not at this point.

00:36:12.000 --> 00:36:16.780
Then the server side needs
to check the authorization

00:36:16.840 --> 00:36:19.850
against an ACL or what have you.

00:36:19.980 --> 00:36:27.900
And then GSS wrap and unwrap to
provide your encrypted data transfer.

00:36:27.900 --> 00:36:30.950
So that's pretty much
all there is for GSS API.

00:36:31.000 --> 00:36:32.400
API.

00:36:32.790 --> 00:36:34.040
And we've got sample code.

00:36:34.040 --> 00:36:36.480
It will be available for download.

00:36:36.480 --> 00:36:38.720
And it shows exactly
how to do this stuff.

00:36:38.790 --> 00:36:43.450
And it's rather simple.

00:36:44.210 --> 00:36:48.080
A fair number of things that you
no longer need to worry about,

00:36:48.370 --> 00:36:50.650
Jason alluded to some of them earlier.

00:36:50.700 --> 00:36:53.200
You're out of the business
of caring about the password.

00:36:53.200 --> 00:36:56.840
If the user doesn't have the TGT,
the library will prompt for it.

00:36:56.840 --> 00:37:00.340
If new auth methods are available,
those will be taken care of

00:37:00.350 --> 00:37:02.110
before you even get called.

00:37:02.190 --> 00:37:07.860
Don't have to worry
about tickets expiring.

00:37:07.860 --> 00:37:07.870
The expiring tickets are
handled by the library.

00:37:08.820 --> 00:37:13.620
If you're worried about single points
of failure and you've set up your,

00:37:13.740 --> 00:37:16.900
you know, as an app developer,
you don't need to worry that

00:37:16.900 --> 00:37:18.470
there may be only one KDC.

00:37:18.480 --> 00:37:21.280
That's all taken care of in the...

00:37:23.460 --> 00:37:26.480
In the infrastructure there,
Kerbero does failover very

00:37:26.480 --> 00:37:30.560
well and Open Directory does
replication very well.

00:37:31.200 --> 00:37:34.300
In summary,
Apple's investing heavily in Kerbero.

00:37:34.380 --> 00:37:36.100
This is the way we're going.

00:37:36.100 --> 00:37:38.190
We ship the MIT KDC and Kerbero client.

00:37:38.200 --> 00:37:44.780
We are committed to keeping that open,
not taking anything proprietary here.

00:37:44.780 --> 00:37:48.800
If you're writing a new
authentication method,

00:37:48.800 --> 00:37:54.160
talk to the Kerbero folks,
work with it through that community,

00:37:54.160 --> 00:37:56.220
get it put into Kerbero, and then

00:37:56.520 --> 00:37:58.790
Everybody will be able
to take advantage of it.

00:37:58.790 --> 00:38:02.980
As a client developer,
any new auth methods that are available,

00:38:02.980 --> 00:38:06.020
you get for free because
you've Kerberized.

00:38:06.020 --> 00:38:08.960
And Kerbero is an
Apple's future in yours.

00:38:08.960 --> 00:38:10.390
That's it.

00:38:10.390 --> 00:38:11.120
That's what we're doing.

00:38:11.680 --> 00:38:18.670
So we've got some very good things
there on more information on Kerberoes,

00:38:18.670 --> 00:38:23.690
more information on Kerberoes protocols,
and there's the URL for the

00:38:23.690 --> 00:38:28.830
AFP548's bit of information there.
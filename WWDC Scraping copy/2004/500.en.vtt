WEBVTT

00:00:12.250 --> 00:00:13.680
Welcome.

00:00:13.690 --> 00:00:17.200
So I was thinking about this
session over the weekend,

00:00:17.370 --> 00:00:21.600
and it occurs to me that I've been
speaking at the USB session since 1998,

00:00:21.670 --> 00:00:23.200
when I had more hair.

00:00:23.200 --> 00:00:28.300
And what was notable about 1998
for me was that that was probably

00:00:28.300 --> 00:00:32.200
the last year that Mac Week was
published in print form.

00:00:32.200 --> 00:00:35.530
And Mac the Knife wrote
an article that said,

00:00:35.530 --> 00:00:40.200
"Coming up to WWDC,
the session you've got to go to is USB."

00:00:40.200 --> 00:00:43.190
And the room was absolutely packed.

00:00:43.390 --> 00:00:45.190
Now, the room's not packed today.

00:00:45.230 --> 00:00:48.960
And actually, I think that's okay,
because it really refers or relates

00:00:49.080 --> 00:00:51.140
a lot to the maturity of the product.

00:00:51.200 --> 00:00:54.010
Now, we're going to talk a lot
about where we're going.

00:00:54.010 --> 00:00:56.200
We're going to talk about
some new things that we have.

00:00:56.200 --> 00:00:59.780
But let's look at where
we've come since 1998,

00:00:59.860 --> 00:01:03.730
at the dawn of USB,
when USB really only had two major

00:01:03.730 --> 00:01:07.170
devices that were well-supported,
well-engineered,

00:01:07.190 --> 00:01:08.170
and there were many of them.

00:01:08.200 --> 00:01:08.200
You know what they were?

00:01:08.200 --> 00:01:08.200
Keyboard devices.

00:01:08.200 --> 00:01:13.240
So since then,
we've come up with mass storage devices,

00:01:13.340 --> 00:01:20.170
modems, printers, networking devices,
cameras, digital steel cameras,

00:01:20.290 --> 00:01:22.150
video cameras, and so forth.

00:01:22.250 --> 00:01:26.000
So just as an overview for today,
I want to give you a progress

00:01:26.000 --> 00:01:29.200
report on what we've been doing,
what's ahead.

00:01:29.200 --> 00:01:33.190
We're going to have some
presentation on remote USB.

00:01:33.200 --> 00:01:36.180
We have an I/O lab tomorrow.

00:01:36.200 --> 00:01:39.630
The only thing that I would say about
this I/O lab is that it will be all

00:01:39.660 --> 00:01:44.510
day long in the developer relations,
developer technical support lab,

00:01:44.720 --> 00:01:47.200
except for the USB and
FireWire feedback form.

00:01:47.200 --> 00:01:50.910
It wouldn't make much sense to
have you go to the lab when you

00:01:50.910 --> 00:01:53.020
could come and give us feedback.

00:01:53.250 --> 00:01:55.970
And then the beginning
of the day on Thursday,

00:01:55.970 --> 00:01:58.740
Thursday night, we have the USB,
FireWire,

00:01:58.740 --> 00:02:03.200
Bluetooth rendezvous plugfest at
the campus during the campus bash.

00:02:03.200 --> 00:02:04.200
It's on top of the cafeteria in I/O lab.

00:02:04.200 --> 00:02:07.780
the cafeteria in aisle four.

00:02:09.080 --> 00:02:12.130
So what you'll learn today,
we will focus on what we've been

00:02:12.130 --> 00:02:14.360
doing over the past year in Jaguar.

00:02:14.360 --> 00:02:18.500
We're going to talk about the issues
that affect you as developers,

00:02:18.500 --> 00:02:20.630
and of course we want your
feedback at the end of the

00:02:20.640 --> 00:02:22.040
session to learn even more.

00:02:22.040 --> 00:02:26.000
And really the most important thing
is the right way to write code,

00:02:26.010 --> 00:02:29.770
the right way to write drivers,
the right way to design devices that

00:02:29.770 --> 00:02:31.800
are going to get you the best behavior.

00:02:31.800 --> 00:02:36.280
But there are some techniques that
you can use to match your devices to

00:02:36.280 --> 00:02:39.140
drivers without writing any code at all.

00:02:39.160 --> 00:02:43.670
These code-less texts just allow you
to put in the vendor and product ID and

00:02:43.740 --> 00:02:46.110
match up to a device automatically.

00:02:47.210 --> 00:02:51.680
So as you know, right now,
every single CPU we ship comes with

00:02:51.860 --> 00:02:59.220
high-speed USB 2.0 – the Emacs,
the iMacs, the Powerbooks, PowerMacs,

00:02:59.260 --> 00:02:59.980
etc.

00:02:59.980 --> 00:03:05.250
The notable thing is that we've
added EHCI host controller support.

00:03:05.250 --> 00:03:07.800
That's how we get high-speed USB.

00:03:08.310 --> 00:03:11.940
They'll talk later on in what we're doing
to add even more controller support,

00:03:11.940 --> 00:03:14.220
so I'll leave that surprise for them.

00:03:14.220 --> 00:03:18.940
There are a number of robustness
fixes that we put in the 10.3 update.

00:03:18.940 --> 00:03:22.500
And one thing that's very cool for us
is that if you remember where we got to

00:03:22.500 --> 00:03:28.400
in the very final days of Mac OS 9.1,
9.2, 9.2.2, is we added its support

00:03:28.400 --> 00:03:32.680
for USB UPS devices so that
you would automatically see

00:03:32.680 --> 00:03:35.120
them on a desktop machine.

00:03:35.210 --> 00:03:40.420
If you plug in a USB device,
a USB enabled UPS, it would automatically

00:03:40.420 --> 00:03:42.400
appear as a battery device.

00:03:42.400 --> 00:03:47.200
And that kind of support
is now present as well.

00:03:47.220 --> 00:03:50.200
So with that,
let me bring up Fernando Urbino.

00:04:04.690 --> 00:04:11.840
I will be talking about some new
APIs that we have added to our family,

00:04:11.840 --> 00:04:15.130
some changes that we have made
to existing class drivers,

00:04:15.130 --> 00:04:19.900
some of them based on feedback that we
got at last year's developers conference,

00:04:19.940 --> 00:04:23.070
and finally I'm going to give
you an overview of new class

00:04:23.210 --> 00:04:27.010
drivers that we have added,
especially we've added support to

00:04:27.010 --> 00:04:31.960
the video device class specification,
the CDC Ethernet devices are

00:04:31.960 --> 00:04:37.500
now supported and there are some
changes that we made there as well,

00:04:37.890 --> 00:04:42.990
and finally we've added
support for UHCI controllers.

00:04:43.610 --> 00:04:47.700
One of the new APIs that
we have implemented is the

00:04:47.960 --> 00:04:50.940
timestamping of USB reads.

00:04:51.010 --> 00:04:57.480
As most of you may know,
the callbacks from your drivers

00:04:57.980 --> 00:05:00.470
are issued on the USB work loop.

00:05:00.580 --> 00:05:06.010
This work loop can be delayed depending
on whether other high priority

00:05:06.360 --> 00:05:09.200
threads are running in the system.

00:05:09.330 --> 00:05:16.290
So if the USB transaction completes
on the bus and the hardware

00:05:16.290 --> 00:05:21.500
notifies us at a certain time,
there could be a latency or some

00:05:21.500 --> 00:05:25.200
amount of milliseconds before
your driver gets that callback.

00:05:25.200 --> 00:05:29.190
This is what we call the
work loop latency issue.

00:05:29.570 --> 00:05:33.920
We discovered that some clients,
including our head driver,

00:05:34.140 --> 00:05:41.230
would sometimes like to know at what time
the hardware issued the interrupt and our

00:05:41.230 --> 00:05:47.750
filter interrupt process that interrupt,
so that it could take care

00:05:47.750 --> 00:05:53.170
of any delays that happened
before its callback was issued.

00:05:53.190 --> 00:05:55.410
So we went ahead and added this new API.

00:05:55.480 --> 00:05:59.790
It's very similar to one of the
existing IOUSB pipe read APIs.

00:05:59.790 --> 00:06:03.500
The only difference is,
as it's highlighted,

00:06:03.560 --> 00:06:09.200
is that we now have a IOUSB completion
with timestamp parameter instead

00:06:09.350 --> 00:06:12.190
of just a regular IOUSB completion.

00:06:16.050 --> 00:06:19.930
This timestamping is currently
implemented in your TigerSeed,

00:06:20.230 --> 00:06:25.280
and it's only implemented
for interrupt and bulk reads.

00:06:25.280 --> 00:06:28.700
We saw no reason to
implement it for writes,

00:06:28.970 --> 00:06:32.310
but if you have a good or
invalid reason to do it,

00:06:32.710 --> 00:06:37.160
let us know through the USB list or
at the feedback forum or down at the

00:06:37.160 --> 00:06:43.990
Hardware I/O Lab tomorrow and Thursday,
and we'll consider and we might add it.

00:06:44.350 --> 00:06:50.560
The I/O USB completion with
timestamp looks as so in the screen.

00:06:50.560 --> 00:06:55.370
The action is the
different parameter there,

00:06:55.380 --> 00:07:00.920
and it is an I/O USB completion
action with timestamp.

00:07:00.920 --> 00:07:03.770
The way it works is that
your action routine,

00:07:03.770 --> 00:07:07.320
or your callback essentially,
gets a new parameter.

00:07:07.320 --> 00:07:11.400
In the past you've gotten, of course,
the status, the buffer size remaining,

00:07:11.570 --> 00:07:15.080
and now you're going
to get the timestamp.

00:07:15.540 --> 00:07:18.400
Again,
the timestamp is the time not when the

00:07:18.400 --> 00:07:22.810
controller completed the transaction,
but where our filter interrupt routine,

00:07:22.810 --> 00:07:27.210
which is our primary interrupt routine,
actually received that interrupt.

00:07:27.240 --> 00:07:31.430
So there's a little delay there
between the hardware and the

00:07:31.430 --> 00:07:34.310
filter interrupt routine running.

00:07:36.250 --> 00:07:42.920
We now have an iOSB composite driver
instead of an Apple USB composite driver.

00:07:42.920 --> 00:07:45.850
It is the same code,
however we've changed the name

00:07:45.850 --> 00:07:51.280
because now we guarantee binary
compatibility in the future.

00:07:51.280 --> 00:07:54.870
So we had recommended in the past
that if you needed the behavior

00:07:54.880 --> 00:07:59.320
of the Apple USB composite driver,
that you go ahead and download

00:07:59.320 --> 00:08:03.930
the family sources from Darwin and
do a copy and paste and generate

00:08:04.140 --> 00:08:06.140
your own kernel extension.

00:08:06.140 --> 00:08:10.700
Now we're allowing you to subclass
that driver so you have to write

00:08:10.830 --> 00:08:15.010
less code and any bugs that we fix,
even though it's a fairly

00:08:15.170 --> 00:08:17.880
straightforward driver,
you'll just get by default

00:08:17.880 --> 00:08:21.180
instead of having stale code.

00:08:21.180 --> 00:08:25.170
You would use this driver
if you need to customize the

00:08:25.170 --> 00:08:27.130
startup behavior of your device.

00:08:27.260 --> 00:08:30.360
The composite device,
the composite driver,

00:08:30.360 --> 00:08:34.430
all it does is essentially generate
a set configuration on the bus and

00:08:34.430 --> 00:08:40.760
the family actually instantiates
the USB interfaces for your device.

00:08:40.760 --> 00:08:43.120
However,
sometimes the set configuration is not

00:08:43.120 --> 00:08:46.200
enough and you want to do something else.

00:08:46.200 --> 00:08:52.040
So you go ahead and subclass this
driver and add your code and that's it.

00:08:52.180 --> 00:08:56.510
It is also,
or it also can be used to solve what we

00:08:56.510 --> 00:09:00.980
call that root driver dependency problem.

00:09:00.980 --> 00:09:04.740
And Rhodes will talk about
this in a little bit.

00:09:04.740 --> 00:09:09.630
But essentially by overriding the set
configuration method of the driver,

00:09:09.790 --> 00:09:13.140
you'll be able to solve this problem.

00:09:15.500 --> 00:11:00.500
[Transcript missing]

00:11:00.800 --> 00:12:44.300
[Transcript missing]

00:12:44.690 --> 00:12:49.590
I have an example here of subclassing
the interface user-client,

00:12:49.670 --> 00:12:52.560
a class declaration for it.

00:12:52.560 --> 00:12:54.520
It's very straightforward.

00:12:54.520 --> 00:13:00.820
In this case, for this example,
I'm just going to override the

00:13:01.240 --> 00:13:05.880
control request in method of
the interface user-client class.

00:13:06.020 --> 00:13:09.720
This is a method used
when you want to read,

00:13:09.720 --> 00:13:13.290
issue a device request to the device.

00:13:13.560 --> 00:13:16.340
So it's from device to host.

00:13:19.070 --> 00:13:23.840
This implementation of that
method shows how I go ahead

00:13:23.840 --> 00:13:26.690
and intercept the USB stream.

00:13:26.740 --> 00:13:30.800
First of all, at the top,
I need to decode the parameters of

00:13:30.800 --> 00:13:34.080
the method into device request fields.

00:13:34.080 --> 00:13:38.200
You can look at the USB family
sources to see how we did it,

00:13:38.210 --> 00:13:41.060
but it's just like that.

00:13:41.060 --> 00:13:45.110
All the different fields are
packed and encoded into UN32s.

00:13:45.110 --> 00:13:49.940
Then, since it's a request from
the device to the host,

00:13:50.070 --> 00:13:53.760
we first issue the
call to our superclass,

00:13:53.760 --> 00:13:58.940
and that will cause the
transaction to go out on the bus.

00:13:58.940 --> 00:14:06.100
Since it's a synchronous transaction,
it will return when that has completed.

00:14:06.190 --> 00:14:10.790
Once it has completed, in this example,
I want to know whether the control

00:14:11.350 --> 00:14:18.150
request was a printer class specific
get device ID request to interface zero,

00:14:18.150 --> 00:14:20.060
alternate setting zero.

00:14:20.060 --> 00:14:22.490
I go ahead and check those parameters.

00:14:22.520 --> 00:14:25.820
If it is,
then I can do something with it.

00:14:25.820 --> 00:14:30.350
In this example, I don't do anything,
but I could examine the buffer value

00:14:30.350 --> 00:14:35.340
and see what the device returned
and do something to it again.

00:14:35.520 --> 00:14:38.920
At the end, of course,
you've got to remember to return the

00:14:38.920 --> 00:14:41.490
error that your superclass returned.

00:14:43.680 --> 00:14:50.290
In the past, the user clients were called
actually I/O USB device user client

00:14:50.340 --> 00:14:52.300
and I/O USB interface user client.

00:14:52.760 --> 00:14:55.580
However, they were not subclassable,
and this goes against everything

00:14:55.580 --> 00:14:59.260
that we've told since the beginning,
that if it was I/O USB,

00:14:59.260 --> 00:15:01.500
it means it was subclassable.

00:15:01.500 --> 00:15:04.620
Of course,
the headers were not available for you,

00:15:04.620 --> 00:15:06.310
so you really couldn't subclass it.

00:15:06.490 --> 00:15:09.350
And even if you copied the headers,
they said right there,

00:15:09.350 --> 00:15:11.120
this is not intended to be subclassed.

00:15:11.450 --> 00:15:14.380
Anyways, we're fixing that now.

00:15:14.500 --> 00:15:18.180
What that means is that we're going to
guarantee binary compatibility in the

00:15:18.180 --> 00:15:21.660
future if you subclass the user clients.

00:15:21.820 --> 00:15:26.840
And there is sample code available
that is a complete example that

00:15:26.850 --> 00:15:30.090
I just showed that compiles and works.

00:15:31.550 --> 00:15:37.170
Couple of miscellaneous updates in
developing the video digitizer to support

00:15:37.230 --> 00:15:40.320
the USB video class specification.

00:15:40.320 --> 00:15:45.460
I realized that there were some
APIs that were exposed in the kernel,

00:15:45.460 --> 00:15:47.980
but were not exposed to user space.

00:15:47.980 --> 00:15:51.160
And so I went ahead and
implemented Find Next,

00:15:51.160 --> 00:15:55.900
associated descriptor and
Find Next Alt Interface.

00:15:55.900 --> 00:16:01.660
And those of you doing isochronous
drivers from user space might

00:16:01.660 --> 00:16:05.920
find it handy to use those to
decode the descriptors instead

00:16:05.920 --> 00:16:07.080
of having to do it all by hand.

00:16:07.120 --> 00:16:11.820
One part that is really
not an external API change,

00:16:11.820 --> 00:16:14.660
but it's an internal
implementation in the family,

00:16:14.660 --> 00:16:21.660
is that the family now uses the command
sleep and command wake up IOK functions.

00:16:21.660 --> 00:16:25.540
In the past,
those of you who have seen the sources,

00:16:25.540 --> 00:16:32.740
we, we simulated synchronous commands to
the USB synchronous transactions by

00:16:32.740 --> 00:16:37.240
using the IO Sync object from IO Kid.

00:16:37.240 --> 00:16:43.680
And that allowed us to send a
command to the USB bus and sit

00:16:43.730 --> 00:16:49.520
and wait for that command to
complete and then call our client.

00:16:49.520 --> 00:16:54.340
That's how we simulated a synchronous
command on an asynchronous bus.

00:16:54.340 --> 00:16:54.840
Buzz.

00:16:55.900 --> 00:17:01.680
IO Sync has now been deprecated in
favor of command sleep and command wake.

00:17:01.710 --> 00:17:04.080
This is a lot friendlier to the system.

00:17:04.080 --> 00:17:05.440
It uses less resources.

00:17:05.440 --> 00:17:11.420
It allows other things to
run in when you're command,

00:17:11.420 --> 00:17:14.170
when you issue that command sleep,
which essentially puts

00:17:14.170 --> 00:17:15.490
the thread to sleep.

00:17:15.630 --> 00:17:19.290
And it also solves a bug that
we see every so often and that

00:17:19.470 --> 00:17:24.800
we've talked in previous WWDCs,
and that is the problem that

00:17:25.010 --> 00:17:30.930
you cannot issue a synchronous
command from your callback,

00:17:30.930 --> 00:17:34.480
because you're on the I/O USB work loop,
and if you do,

00:17:34.480 --> 00:17:38.200
you'll deadlock the bus and
nothing will work from there on.

00:17:38.200 --> 00:17:41.920
There was no – you could do
that in previous versions and

00:17:41.920 --> 00:17:43.960
you get no error or anything.

00:17:43.960 --> 00:17:46.250
By using command sleep,

00:17:46.470 --> 00:17:56.150
We will issue an error right away,
an immediate error,

00:17:56.150 --> 00:18:01.700
of KIO USB sync request on
work loop thread to you,

00:18:01.700 --> 00:18:06.010
so you'll know that your
synchronous requests did not work

00:18:06.390 --> 00:18:10.780
and you won't deadlock the bus,
and it'll save us all some time.

00:18:12.190 --> 00:18:16.900
Through the open source
process this past year,

00:18:16.900 --> 00:18:22.330
we received a submission to
support the UHCI controller.

00:18:22.440 --> 00:18:25.250
As you know,
we support OHCI from way back then,

00:18:25.260 --> 00:18:28.540
and last year we added EHCI controllers.

00:18:28.540 --> 00:18:32.800
But we've never added support for
UHCI controllers because Apple has never

00:18:32.800 --> 00:18:36.580
shipped a machine with such a controller.

00:18:36.580 --> 00:18:40.250
We received the submission,
we tweaked it a little

00:18:40.260 --> 00:18:43.530
bit here and there,
and added it to our project.

00:18:43.860 --> 00:18:48.540
And it is actually shipping and
available in your TigerSeed.

00:18:48.580 --> 00:18:52.370
The purpose of this slide is just
to show you that the open source

00:18:52.970 --> 00:18:55.400
submission really does work,
and that we take all

00:18:55.490 --> 00:18:56.570
submissions seriously.

00:18:56.580 --> 00:19:01.780
So we again encourage you
to download our sources,

00:19:01.780 --> 00:19:05.580
and if you use them for something
that other people can use,

00:19:05.580 --> 00:19:10.580
send it back to us and
we'll take it from there.

00:19:13.540 --> 00:19:17.280
In terms of new device class support,
as I mentioned,

00:19:17.280 --> 00:19:20.630
we have several or a couple
of new device class drivers.

00:19:20.630 --> 00:19:24.360
Actually,
the 10.3.3 update included support

00:19:24.360 --> 00:19:26.400
for USB-CDC Ethernet devices.

00:19:26.400 --> 00:19:28.840
In the past,
this was just sample code that

00:19:28.840 --> 00:19:32.730
was available on request from DTS,
but with 10.3.3,

00:19:32.840 --> 00:19:34.900
it became part of the system.

00:19:35.840 --> 00:19:39.820
However, as I'm going to mention
in a couple of slides,

00:19:39.820 --> 00:19:43.440
for Tiger,
we now have a new USB-CDC driver that

00:19:43.440 --> 00:19:46.800
supports modem and Ethernet-CDC devices.

00:19:46.980 --> 00:19:51.660
And as some of you know,
last August the USB Implementers

00:19:51.660 --> 00:19:58.450
Forum approved version 1.0 of the
USB Video Class Device specification,

00:19:58.450 --> 00:20:03.260
and Tiger is going to add support
for some of that specification.

00:20:06.050 --> 00:20:08.470
CDC class devices.

00:20:08.560 --> 00:20:12.180
We've had support for
them since the beginning.

00:20:12.370 --> 00:20:18.500
The driver in Mac OS X was essentially
ported from our Mac OS 9 driver.

00:20:18.570 --> 00:20:19.730
It has worked well.

00:20:20.150 --> 00:20:23.960
It's a device driver as
opposed to an interface driver.

00:20:24.140 --> 00:20:29.520
It uses a fairly simple buffering model,
and it worked well for

00:20:29.520 --> 00:20:31.930
low bandwidth CDC devices.

00:20:32.830 --> 00:20:36.300
However,
new devices with higher bandwidth

00:20:36.300 --> 00:20:41.860
and with multiple interfaces have
come into the market recently,

00:20:41.860 --> 00:20:43.380
all of them CDC compliant.

00:20:43.380 --> 00:20:47.640
And we realized that there was
a need to revamp this driver.

00:20:47.640 --> 00:20:52.670
So we've gone and created this new
driver that is in your TigerSeed.

00:20:52.680 --> 00:20:56.650
It supports devices that
have multiple interfaces,

00:20:56.740 --> 00:21:02.150
not just the data interfaces,
but maybe mass storage and others.

00:21:02.420 --> 00:21:07.830
It also has a multiple buffering
model to allow us to better

00:21:07.830 --> 00:21:11.170
support the high bandwidth devices.

00:21:11.300 --> 00:21:16.260
The new driver architecture
essentially looks like this.

00:21:16.340 --> 00:21:19.490
At the device driver level,
we still have a device driver,

00:21:19.490 --> 00:21:25.530
but it's a very simple device
driver that is essentially just the

00:21:25.530 --> 00:21:27.240
equivalent of the composite driver.

00:21:27.320 --> 00:21:33.680
It creates the interfaces and then
it causes either the ACM driver

00:21:33.680 --> 00:21:40.440
for low bandwidth devices to be
instantiated for those interfaces,

00:21:40.570 --> 00:21:45.270
or the ECM driver for the
high bandwidth devices.

00:21:45.310 --> 00:21:47.930
So that works really well.

00:21:47.930 --> 00:21:52.290
An example of how the CDC's
devices have changed is,

00:21:52.290 --> 00:21:56.200
for example,
the third generation cell phones.

00:21:56.320 --> 00:22:01.300
That can have a whole
series of USB interfaces,

00:22:01.300 --> 00:22:06.500
and having the old driver that assumed
that all the interfaces were the

00:22:06.500 --> 00:22:11.300
data communication interface would
certainly not work in this case.

00:22:11.300 --> 00:22:14.130
You could have a hidden
interface for the keypad,

00:22:14.140 --> 00:22:17.190
you can have mass storage
interface to access the card

00:22:17.190 --> 00:22:19.300
where the pictures are stored.

00:22:19.300 --> 00:22:23.260
Of course,
you can have the data interfaces,

00:22:23.370 --> 00:22:25.300
you can have the Bluetooth interfaces.

00:22:25.300 --> 00:22:30.300
And perhaps even audio
interfaces in there.

00:22:30.500 --> 00:22:34.810
So you can see that CDC devices
have come a long ways,

00:22:34.810 --> 00:22:38.100
and that is the reason for our change.

00:22:40.160 --> 00:22:43.070
The USB video class was approved,
like I said, last August,

00:22:43.190 --> 00:22:48.230
and I've been working with the device
working group for way before that.

00:22:48.230 --> 00:22:52.730
The base specification itself is

00:22:53.090 --> 00:22:55.900
Video format agnostic.

00:22:55.900 --> 00:23:00.090
It just tells you what kind of
interfaces or what kind of functions,

00:23:00.090 --> 00:23:04.860
video functions, that device supports,
how still image is supported,

00:23:04.930 --> 00:23:11.250
whether it's bulk stream or
ISOC streams that are supported,

00:23:11.250 --> 00:23:16.100
how the host and the device negotiate.

00:23:16.330 --> 00:23:20.170
What kind of stream to
send and at what bandwidth?

00:23:20.200 --> 00:23:22.670
It's very general in those terms.

00:23:22.830 --> 00:23:28.340
The base spec itself is followed by
several payload specifications that

00:23:28.550 --> 00:23:34.880
tell the driver/writer what the format
of the data that is encapsulated in

00:23:34.890 --> 00:23:42.200
those streams looks like and how all the
information in there is to be decoded.

00:23:42.550 --> 00:23:48.360
There's payload description
specifications for YUV 422,

00:23:48.470 --> 00:23:53.200
a flavor of YUV 422,
and a flavor of Motion JPEG,

00:23:53.200 --> 00:23:57.200
and those are mainly for
web camera situations.

00:23:57.200 --> 00:24:03.200
DV is over USB spec in there,
MPEG-1 and MPEG-2.

00:24:03.200 --> 00:24:06.280
So I encourage you,
if you're thinking about

00:24:06.280 --> 00:24:09.200
video class devices,
to go and make a video

00:24:09.200 --> 00:24:11.190
class compliant device.

00:24:11.200 --> 00:24:12.710
device.

00:24:13.740 --> 00:24:19.010
Tiger will have support for the
USB video class specification by using

00:24:19.010 --> 00:24:29.100
a video digitizer that lives at library
QuickTime USB VDC digitizer component.

00:24:29.100 --> 00:24:34.710
The software will support web cameras,
either in the motion

00:24:34.710 --> 00:24:38.040
JPEG or the YUV 422 format.

00:24:38.040 --> 00:24:45.150
It supports bulk and isochronous streams,
and right now cameras are shipping

00:24:45.320 --> 00:24:49.690
with both kinds of streams,
even though the manufacturers actually

00:24:49.690 --> 00:24:53.250
don't make a big deal that they
are VDC class compliant devices,

00:24:53.370 --> 00:24:57.800
but they are shipping there,
as we'll show you in a little bit.

00:24:57.800 --> 00:25:03.940
The still image support will be provided
through the image capture framework,

00:25:03.940 --> 00:25:05.940
so that it is seamless to the user.

00:25:05.940 --> 00:25:07.940
It will just look like another.

00:25:07.940 --> 00:25:11.960
source of still pictures.

00:25:12.230 --> 00:25:19.220
The spec actually is going
through some ongoing revisions to

00:25:19.340 --> 00:25:26.390
further clarify the DV support,
so there is no DV support for

00:25:26.390 --> 00:25:30.780
USB video class devices in Tiger.

00:25:36.430 --> 00:25:41.240
Describing a video class device can be
a little tricky because they can have,

00:25:41.240 --> 00:25:44.560
in this example of a digital
camera or a video camera,

00:25:44.560 --> 00:25:48.810
you can have the video class interfaces,
you could have audio

00:25:48.810 --> 00:25:54.650
interfaces for the microphone,
you can have mass storage interfaces for

00:25:54.650 --> 00:25:57.610
the picture card that is in the machine.

00:25:57.620 --> 00:26:01.840
So,
they needed a way to describe in terms

00:26:02.460 --> 00:26:10.010
of the USB device descriptor how this
device looks so that host software

00:26:10.160 --> 00:26:16.340
could readily find the particular
interfaces that are of its concern

00:26:16.340 --> 00:26:21.330
and use them instead of having to
go through every single interface

00:26:21.330 --> 00:26:23.380
and see what kind of interface it is.

00:26:23.440 --> 00:26:27.430
So, the USB IEF came up with the
Interface Association Description.

00:26:27.630 --> 00:26:32.750
This descriptor tells us at
the device level that it is a

00:26:33.020 --> 00:26:38.520
miscellaneous class device with a
common subclass and an interface

00:26:38.520 --> 00:26:40.550
association descriptor protocol.

00:26:40.660 --> 00:26:46.630
This just tells the device driver that
you need to look into the configuration

00:26:46.630 --> 00:26:53.750
descriptor for the interface
association descriptor that follows,

00:26:53.760 --> 00:26:57.620
which is going to group the
different functional interfaces.

00:26:57.620 --> 00:26:57.920
This just tells the device driver that
you need to look into the configuration

00:26:57.920 --> 00:26:58.220
descriptor for the interface
association descriptor that follows,

00:26:58.220 --> 00:26:58.620
which is going to group the
different functional interfaces.

00:26:58.620 --> 00:26:58.620
And if we can go to the demo machine,
I will show you how the device

00:26:58.620 --> 00:26:58.700
will be able to do this.

00:26:58.930 --> 00:27:02.780
And if we can go to the demo machine,
I will show you how the device

00:27:02.830 --> 00:27:04.460
will be able to do this.

00:27:04.830 --> 00:27:12.850
Here we have a Panasonic video
class-specific compliant device.

00:27:12.850 --> 00:27:19.310
I'm going to turn it on and
start USB Prover and look

00:27:19.900 --> 00:27:23.960
at the camera right here.

00:27:23.960 --> 00:27:26.460
You can see that the device is
a miscellaneous common class

00:27:26.460 --> 00:27:28.080
interface association descriptor.

00:27:28.080 --> 00:27:34.140
Here on the configuration descriptor,
we see that there are one and two

00:27:34.150 --> 00:27:37.420
interface association descriptors.

00:27:37.420 --> 00:27:43.840
One for the video interface collection
and one for the audio collection.

00:27:43.840 --> 00:27:48.020
If we disclose one of those,
it just tells us that the first

00:27:48.050 --> 00:27:52.800
interface is interface number zero,
and there are two interfaces,

00:27:52.800 --> 00:27:57.040
and furthermore, then it tells us that it
is the video subclass.

00:27:58.210 --> 00:28:02.420
We go down here and now
look at the audio control.

00:28:02.580 --> 00:28:06.800
The first interface is 2,
and there's again two interfaces for the

00:28:06.800 --> 00:28:12.060
audio control and the audio streaming,
and the class is the audio class.

00:28:12.420 --> 00:28:21.370
So this is just a way for the device
to tell us what functions it supports,

00:28:21.370 --> 00:28:22.800
and our drivers can then match.

00:28:22.890 --> 00:28:28.860
And in fact, for this camera,
we can see that

00:28:30.920 --> 00:28:38.120
The driver has the video
control interface and the

00:28:38.120 --> 00:28:41.770
video streaming interface,
and then there's the audio,

00:28:42.340 --> 00:28:47.500
Apple USB audio device and
engine matching to the device.

00:28:47.600 --> 00:28:59.100
[Transcript missing]

00:28:59.810 --> 00:29:02.540
And this one is right down here.

00:29:02.540 --> 00:29:06.700
And in this case,
it doesn't have a microphone,

00:29:06.700 --> 00:29:11.470
so there will only be one
video interface collection.

00:29:11.470 --> 00:29:15.410
But we can start a video
capture application,

00:29:15.420 --> 00:29:17.550
and you can see that...

00:29:18.850 --> 00:29:26.060
That support is real and it's there.

00:29:26.100 --> 00:29:26.100
And we are continuing to... Oh,
I didn't want to do that.

00:29:27.940 --> 00:29:33.970
We're continuing to support all the
cameras that we can get a hold of.

00:29:34.310 --> 00:29:38.040
The support now is such that
new cameras that have come in,

00:29:38.040 --> 00:29:40.510
I haven't had to change
the driver at all,

00:29:40.610 --> 00:29:42.190
so we're getting there.

00:29:42.270 --> 00:29:46.150
I believe that that is
the end of the demo,

00:29:46.330 --> 00:29:53.320
and if we can go to the – Rhoaads
will now come and talk to you

00:29:53.320 --> 00:29:57.230
about some other USB issues.

00:30:04.660 --> 00:30:07.240
I want to talk to you about
some of the issues that have

00:30:07.240 --> 00:30:08.590
come up in the last year.

00:30:08.740 --> 00:30:12.160
These are issues that have come up in
our own internal driver development

00:30:12.190 --> 00:30:16.600
and on the USB developer mailing list.

00:30:16.600 --> 00:30:18.570
I'm going to talk about
three specific things.

00:30:18.650 --> 00:30:22.860
One is what I call the split
transaction error problem.

00:30:23.160 --> 00:30:29.140
These are USB errors with full speed
or low speed devices attached through

00:30:29.140 --> 00:30:32.240
a high speed hub to a high speed bus.

00:30:32.440 --> 00:30:35.400
Then another issue that's
more of an I/O Kit issue,

00:30:35.530 --> 00:30:38.800
but we call it Apple USB Composite
Stole My Device.

00:30:38.800 --> 00:30:43.000
This is an issue that has come up quite
frequently with third-party developers.

00:30:43.050 --> 00:30:47.410
And then another one called
My Device Gets the Wrong Config,

00:30:47.410 --> 00:30:52.430
which is more rare,
but an interesting solution.

00:30:52.610 --> 00:30:54.720
So first we're going to talk about
the split transaction errors.

00:30:54.810 --> 00:30:58.240
So what you have here is a
picture that's sort of adapted

00:30:58.250 --> 00:31:04.200
from the USB 2.0 specification,
Appendix A, Table A-12.

00:31:04.230 --> 00:31:08.570
Here is a – what we're going to go
through here is a split transaction

00:31:08.880 --> 00:31:11.650
between the high-speed host,
a high-speed hub,

00:31:11.690 --> 00:31:15.640
and then a full-speed or low-speed
device attached to that hub.

00:31:15.800 --> 00:31:21.530
So let's say the host needs to send some
data out to the classic speed device.

00:31:21.950 --> 00:31:24.800
So it first sends a start split
token to the high-speed host.

00:31:24.800 --> 00:31:27.630
So it sends a start split token to
the high-speed hub saying I have a

00:31:27.630 --> 00:31:30.940
command for a classic speed device,
followed by the out or setup packet.

00:31:31.060 --> 00:31:35.700
That's what the Table A-12 will show you,
followed by the data.

00:31:35.750 --> 00:31:39.200
And the high-speed hub
acknowledges that data transfer.

00:31:39.250 --> 00:31:42.600
Now the high-speed hub needs
to send the data to the device.

00:31:42.600 --> 00:31:48.390
So first it sends the out setup packet,
followed by the data.

00:31:48.690 --> 00:31:52.250
But in this example,
the device either ignores the data,

00:31:52.270 --> 00:31:54.400
does not respond to it in any way,
or it sends the data to the device,

00:31:54.400 --> 00:31:54.400
and then the device ignores the data.

00:31:54.400 --> 00:31:54.400
So it sends the data to the device,
and then the device ignores the data,

00:31:54.400 --> 00:31:54.400
or it sends the data to the device,
and then the device ignores the data,

00:31:54.400 --> 00:31:54.400
or it sends the data to the device,
and then the device ignores the data,

00:31:54.460 --> 00:31:57.600
or never gets the data
for an electrical problem,

00:31:57.600 --> 00:32:03.980
or because it is physically disconnected,
or for some other reason.

00:32:04.150 --> 00:32:06.870
And that happens three times in a row.

00:32:06.970 --> 00:32:08.730
So finally,
the host wants to find out what

00:32:08.760 --> 00:32:12.540
happened to that data packet,
so it sends a complete

00:32:12.700 --> 00:32:16.510
split command to the hub,
identifies which complete

00:32:16.570 --> 00:32:21.010
split it's looking for,
and gets a response of stall

00:32:21.010 --> 00:32:23.550
from the high-speed hub.

00:32:23.680 --> 00:32:24.760
So that's one example.

00:32:24.840 --> 00:32:27.540
Now we're going to go to another
example and compare them.

00:32:27.670 --> 00:32:30.400
So in this example,
this is table A-23 from

00:32:30.400 --> 00:32:32.600
the USB 2.0 specification.

00:32:32.600 --> 00:32:35.840
And in this example,
the same situation – the

00:32:35.840 --> 00:32:39.600
host sends the start split,
followed by the out or setup packet,

00:32:39.600 --> 00:32:42.590
followed by the data,
and gets acknowledged.

00:32:42.600 --> 00:32:45.680
The high speed hub then sends
the out setup packet and

00:32:45.740 --> 00:32:47.600
sends the data to the device.

00:32:47.600 --> 00:32:51.980
This time, the device gets the data,
but it doesn't like it,

00:32:52.070 --> 00:32:54.120
so it returns a stall PID.

00:32:54.700 --> 00:32:56.940
Later on,
the host wants to find out what happened.

00:32:56.940 --> 00:32:59.670
It sends the complete split,
it identifies the complete split,

00:32:59.910 --> 00:33:02.540
and it gets a stall back
from the high-speed hub.

00:33:02.700 --> 00:33:05.690
Now I'm going to show you the
other table here on the next slide.

00:33:05.730 --> 00:33:08.970
I want you to pay close attention
to the information on the

00:33:09.010 --> 00:33:10.700
left-hand side of the screen.

00:33:10.700 --> 00:33:13.630
When we go back to Table A-12,
you'll notice that the

00:33:13.830 --> 00:33:15.680
left-hand side did not change.

00:33:15.680 --> 00:33:17.670
Let's go back to the other one again.

00:33:17.680 --> 00:33:19.700
It didn't change.

00:33:19.700 --> 00:33:23.650
What this means is that from a
controller point of view in the host,

00:33:23.770 --> 00:33:28.020
we can't tell the difference between
the situation where the device did not

00:33:28.020 --> 00:33:33.990
get the data and the situation where the
device got the data but didn't like it.

00:33:35.070 --> 00:33:37.680
So, what does your driver need to do?

00:33:37.760 --> 00:33:40.580
Well, first of all,
you need to realize that "stall" does

00:33:40.580 --> 00:33:44.920
not always mean "stall." It may mean
that the device stalled the data,

00:33:45.080 --> 00:33:49.310
and it may mean that the
device didn't respond at all,

00:33:49.420 --> 00:33:52.980
so the high-speed hub stalls the command.

00:33:53.300 --> 00:34:00.040
What we have done with this in the
USB family is when this situation occurs,

00:34:00.040 --> 00:34:04.380
we will return an error of
KIOUSB pipe stall the first time

00:34:04.380 --> 00:34:08.100
we see it on a particular pipe,
and the third time, and the fifth time,

00:34:08.160 --> 00:34:09.400
and all the odd times.

00:34:09.510 --> 00:34:12.360
But on the even times,
we will return a different error

00:34:12.360 --> 00:34:14.240
– KIO return not responding.

00:34:14.350 --> 00:34:17.300
So that hopefully if you issue
the command twice in a row,

00:34:17.300 --> 00:34:20.630
one of the two errors will
cause your driver to know

00:34:20.670 --> 00:34:22.890
what to do with the situation.

00:34:23.090 --> 00:34:28.760
When this happens, no matter which of the
two situations occurs,

00:34:28.760 --> 00:34:32.030
the endpoint is halted
inside the host controller.

00:34:32.030 --> 00:34:35.990
It needs to be cleared,
at least in the host end,

00:34:36.330 --> 00:34:39.700
and possibly in the device end,
but we don't know that.

00:34:39.780 --> 00:34:43.170
The device may or may not
have a halted endpoint,

00:34:43.170 --> 00:34:46.120
and your driver needs to figure it out.

00:34:46.120 --> 00:34:48.800
It needs to ask the device,
it needs to reset the device,

00:34:48.800 --> 00:34:51.690
it needs to do something to
deal with this situation.

00:34:52.020 --> 00:34:58.540
But you need to realize that this is
something that is different between

00:34:58.540 --> 00:35:05.660
classic speed USB on an OHCI bus and
classic speed USB on a high speed bus.

00:35:05.920 --> 00:35:08.690
And you need to deal
with it appropriately.

00:35:08.970 --> 00:35:12.790
Okay, another issue that has come up
and we wanted to talk about,

00:35:12.800 --> 00:35:16.990
and this is more of an I/O Kit thing,
but we've done some stuff

00:35:16.990 --> 00:35:22.080
to help solve it here,
is the – we call it

00:35:22.080 --> 00:35:24.290
Apple USB Composite Stole My Device.

00:35:24.300 --> 00:35:25.300
Now what does this mean?

00:35:25.300 --> 00:35:30.400
This is when you have a device
driver for an I/O USB device nub,

00:35:30.610 --> 00:35:32.200
as opposed to an interface driver.

00:35:32.630 --> 00:35:34.850
Again,
this is something we encourage people to

00:35:35.010 --> 00:35:39.030
use the composite driver when they can,
but let's say you have your own

00:35:39.150 --> 00:35:42.300
device driver for some reason,
and you need that.

00:35:42.320 --> 00:35:45.630
And so you create a personality
for your I/O USB device,

00:35:45.630 --> 00:35:48.780
and it's specified here,
and you plug in your device

00:35:48.780 --> 00:35:51.420
and you open up USB Prober,
and sure enough, there's your driver,

00:35:51.420 --> 00:35:53.720
instantiated, controlling this device.

00:35:53.800 --> 00:35:54.540
And that's great.

00:35:54.770 --> 00:35:55.620
Everything's wonderful.

00:35:55.800 --> 00:35:59.800
But then, when you reboot the machine,
you open up Prober again,

00:35:59.800 --> 00:36:01.800
and this time the Apple USB Composite
driver is installed.

00:36:01.840 --> 00:36:04.320
So the composite driver is
now controlling your device

00:36:04.330 --> 00:36:05.590
instead of your own driver.

00:36:05.820 --> 00:36:07.780
And if you unplug the
device and plug it back in,

00:36:07.860 --> 00:36:10.800
you'll see that your own
driver is controlling it again.

00:36:10.800 --> 00:36:14.620
So you ask yourself, well,
why did the Apple USB Composite

00:36:14.620 --> 00:36:16.950
driver match against my device?

00:36:17.150 --> 00:36:20.860
So you download the family
sources from Darwin,

00:36:20.900 --> 00:36:24.440
and you open up the
Apple USB Composite target,

00:36:24.440 --> 00:36:28.330
and you notice this property:
OS bundle required of root.

00:36:28.690 --> 00:36:32.920
And you ask us on the list,
or the I/O Kit list, "Well,

00:36:33.020 --> 00:36:34.950
what does that mean?"

00:36:35.510 --> 00:36:39.850
In the system,
there are certain kernel extensions and

00:36:39.980 --> 00:36:45.770
the kernel itself that are listed with
an OS bundle required property of root.

00:36:46.060 --> 00:36:48.280
There are a few other
OS bundle required properties,

00:36:48.280 --> 00:36:50.390
but this is sort of the main one.

00:36:50.400 --> 00:36:53.560
These are kernel extensions
that are required to run very,

00:36:53.680 --> 00:36:57.750
very, very early in the system,
to do things like enable you to go

00:36:57.750 --> 00:37:02.200
into single user mode or verbose mode,
that kind of thing.

00:37:02.450 --> 00:37:06.400
We want to be able to type on a keyboard,
for example, in single user mode.

00:37:06.400 --> 00:37:11.130
So these kernel extensions are things
like the Mach text itself and the

00:37:11.130 --> 00:37:16.400
I/O Kit and the USB family and the
various controller drivers and so forth.

00:37:16.400 --> 00:37:20.580
And one of them is Apple USB Composite.

00:37:21.290 --> 00:37:24.520
So this is a root driver,
it loads very early in the system.

00:37:24.520 --> 00:37:27.180
But then there are other kernel
extensions that are not root drivers.

00:37:27.200 --> 00:37:31.050
For example, the I/O Serial family,
or the I/O Audio family,

00:37:31.360 --> 00:37:36.260
or some other family that your kernel
extension needs to link against

00:37:36.490 --> 00:37:38.920
in order to be resolved and load.

00:37:39.300 --> 00:37:41.900
So what that means, of course,
is that if you have to link against a

00:37:41.900 --> 00:37:45.530
driver that's not available at root time,
you can't be available at root time.

00:37:45.930 --> 00:37:47.710
So what do you do?

00:37:48.280 --> 00:37:53.000
What we came up with was a clever
solution that we call the poison pill.

00:37:53.090 --> 00:37:55.500
And in this solution,
you create an interface driver

00:37:55.500 --> 00:37:58.600
for your I/O USB interface object.

00:37:58.750 --> 00:38:01.500
And here is a personality
for that driver.

00:38:01.800 --> 00:38:06.800
And then inside that interface
driver in the start method,

00:38:06.800 --> 00:38:10.540
you just call re-enumerate device,
which causes your device to

00:38:10.540 --> 00:38:15.330
get essentially disconnected
and reconnected from the bus.

00:38:15.940 --> 00:38:18.740
Your interface driver,
not being a root driver,

00:38:18.740 --> 00:38:21.320
will load once the
system is fully booted,

00:38:21.320 --> 00:38:23.880
and when it causes the
device re-enumeration,

00:38:23.930 --> 00:38:26.830
again, it's like physically disconnecting
and reconnecting the device,

00:38:26.830 --> 00:38:30.820
and now your device driver,
which has a higher matching priority

00:38:30.820 --> 00:38:34.240
than the composite device driver,
will win the matching process.

00:38:34.240 --> 00:38:39.740
Now, this solution does have
a couple of caveats,

00:38:39.740 --> 00:38:46.190
one of which is that your device driver,
which might be a subclass of the

00:38:46.290 --> 00:38:48.950
new I/O USB composite driver,
for example,

00:38:49.270 --> 00:38:53.070
needs to call set configuration
with a parameter of false to

00:38:53.210 --> 00:38:56.760
prevent I/O Kit from matching
drivers against the interface nubs,

00:38:56.770 --> 00:38:59.870
or else you get into a loop
where it's just constantly

00:38:59.870 --> 00:39:01.810
re-enumerating the device.

00:39:02.160 --> 00:39:05.760
However, preventing I/O Kit from matching
the interface nubs will also

00:39:06.280 --> 00:39:09.800
prevent I/O USB interface
user-client from matching,

00:39:09.910 --> 00:39:12.480
which means that if you need
a user-client for your device,

00:39:12.820 --> 00:39:15.430
you need to do a little more work.

00:39:16.980 --> 00:39:20.000
Finally, I'm going to talk about a
situation that has come up.

00:39:20.000 --> 00:39:25.720
We call it "my device gets the wrong
config." This is where you have a device,

00:39:25.720 --> 00:39:31.890
an I/O USB device, that has more than one
configuration descriptor.

00:39:32.060 --> 00:39:34.890
And the composite driver
does everything you want.

00:39:34.890 --> 00:39:37.920
It's a composite device, i.e.

00:39:37.940 --> 00:39:40.900
the device class and device
subclass are both zero.

00:39:40.900 --> 00:39:44.060
And the Apple USB composite
driver does a good job,

00:39:44.070 --> 00:39:46.990
except for it picks the
wrong configuration,

00:39:46.990 --> 00:39:49.870
because the composite driver always
picks the first configuration.

00:39:49.900 --> 00:39:55.380
And you want an alternate configuration
to be instantiated for your device

00:39:55.380 --> 00:39:57.890
under certain circumstances.

00:39:58.280 --> 00:39:59.710
Well,

00:40:01.120 --> 00:40:03.580
You don't need to write
any code to do this.

00:40:03.580 --> 00:40:06.100
You can create a codeless
kernel extension,

00:40:06.220 --> 00:40:10.460
where all you need is a file
with a personality in it,

00:40:10.460 --> 00:40:11.700
a property list.

00:40:11.920 --> 00:40:16.600
And this property list specifies your
device by vendor ID and product ID,

00:40:16.600 --> 00:40:20.690
as you can see,
and specifies that you want to load

00:40:20.820 --> 00:40:28.070
the Apple USB Composite bundle and
instantiate the Apple USB Composite

00:40:28.280 --> 00:40:29.950
class to match against your device.

00:40:30.310 --> 00:40:33.860
You then add one more property,
in blue at the bottom of the list,

00:40:34.010 --> 00:40:38.430
called preferred configuration,
and you specify the configuration number

00:40:38.430 --> 00:40:42.610
of the configuration that you want,
and the Apple USB Composite driver

00:40:42.610 --> 00:40:45.100
will then load that configuration.

00:40:45.370 --> 00:40:48.960
This same technique of creating a
codeless KEXT can be used if you

00:40:48.960 --> 00:40:51.710
have a vendor-specific device,
i.e.

00:40:51.710 --> 00:40:55.190
the device class and
subclass are FF instead of 0,

00:40:55.330 --> 00:40:57.600
but other than that,
the device really will behave

00:40:57.600 --> 00:41:02.610
just like a composite device,
and you want the Apple USB Composite

00:41:02.610 --> 00:41:05.990
driver to load against this device.

00:41:07.910 --> 00:41:10.830
And with that,
I'm going to bring up Barry Twycross

00:41:10.960 --> 00:41:13.360
to talk about remote USB.

00:41:18.300 --> 00:41:19.760
Thanks Rhos.

00:41:20.050 --> 00:41:25.760
Okay,
so I'm going to talk about remote USB.

00:41:25.760 --> 00:41:26.760
What is it?

00:41:26.760 --> 00:41:29.140
Why you would want to do this?

00:41:29.140 --> 00:41:30.300
How it's done?

00:41:30.300 --> 00:41:34.170
And then the interesting part,
what it actually means to you.

00:41:34.850 --> 00:41:36.630
Remote USB – what is it?

00:41:36.820 --> 00:41:41.800
It's when you use a device which is
not actually attached to your computer.

00:41:41.800 --> 00:41:44.240
Ah, but you say, this is not USB, is it?

00:41:44.370 --> 00:41:46.760
Well, no, it's pretending to be USB.

00:41:47.310 --> 00:41:51.950
However, users do it anyway,
so you might as well be prepared for it.

00:41:52.630 --> 00:41:53.640
Remote USB.

00:41:53.640 --> 00:41:54.830
Why would you want to do this?

00:41:54.950 --> 00:41:56.640
Well, there is user demand.

00:41:56.680 --> 00:41:59.430
Users like to share their peripherals.

00:41:59.550 --> 00:42:03.440
A classic example is...

00:42:03.570 --> 00:42:03.960
is a printer.

00:42:03.960 --> 00:42:07.340
They want one in the household,
everyone in the household

00:42:07.340 --> 00:42:09.110
can print to the one printer.

00:42:09.160 --> 00:42:12.070
They also like to unwire,
so they can be sitting comfortably

00:42:12.070 --> 00:42:15.370
on their couch in the living room,
print something off to their printer,

00:42:15.510 --> 00:42:18.030
and never have to get up at all,
except when they actually go to

00:42:18.030 --> 00:42:19.970
get the print out from the printer.

00:42:20.060 --> 00:42:22.140
It's also a business opportunity.

00:42:22.180 --> 00:42:25.440
You can sell devices which
implement remote USB.

00:42:25.440 --> 00:42:27.510
Users will buy them from you.

00:42:27.620 --> 00:42:31.900
And it's actually quite a
common developer question.

00:42:32.040 --> 00:42:37.000
And here's an example from
the USBIF's mailing list,

00:42:37.030 --> 00:42:40.620
where this guy says, I'm a student,
I have a project,

00:42:40.620 --> 00:42:44.070
I want to cut the wire on my USB,
put radio transceivers at both ends,

00:42:44.070 --> 00:42:44.910
and will it work?

00:42:44.910 --> 00:42:47.020
Well,
the answer to that was basically no.

00:42:51.670 --> 00:42:54.360
Let's think about the problem
a little more rationally.

00:42:54.410 --> 00:42:57.880
Let's try using networking concepts.

00:42:57.880 --> 00:43:01.070
Networking is the standard way of
getting data from here to there,

00:43:01.070 --> 00:43:04.780
and we want to get data
from here to there.

00:43:04.800 --> 00:43:09.750
Also, decouple the transport of the
data from the data itself.

00:43:09.770 --> 00:43:12.540
So if you want to do it wirelessly,
don't worry that you

00:43:12.760 --> 00:43:14.280
want to do it wirelessly.

00:43:14.280 --> 00:43:18.140
Do it with a network,
and then use a wireless network.

00:43:18.140 --> 00:43:19.760
It can be wireless this way.

00:43:19.760 --> 00:43:22.930
So we'll use TCP/IP,
it being the commonly

00:43:22.930 --> 00:43:25.200
available networking.

00:43:25.200 --> 00:43:28.150
It's built into all our machines.

00:43:28.300 --> 00:43:30.200
Everyone knows and loves it.

00:43:30.200 --> 00:43:33.440
So we need to think about the
data flow that's involved in USB,

00:43:33.440 --> 00:43:37.720
intercept it at some point,
and then send it across the network

00:43:37.890 --> 00:43:42.990
to a device which takes it and then
sends it on to the actual USB device.

00:43:43.500 --> 00:43:45.300
So, the data flow.

00:43:45.300 --> 00:43:47.310
And you start off at the
top with the application.

00:43:47.330 --> 00:43:49.780
Here's an example of printing again.

00:43:49.780 --> 00:43:53.160
You start off with the application,
it sends data to the print driver,

00:43:53.220 --> 00:43:56.890
it bubbles down through the user client,
and eventually ends up with a controller,

00:43:56.890 --> 00:43:58.990
and actually then ends
up on the USB bus itself,

00:43:59.010 --> 00:44:00.440
and finally with a device.

00:44:00.440 --> 00:44:03.240
We thought of three interesting
places where you could

00:44:03.240 --> 00:44:06.500
actually intercept this data,
basically at a very high level,

00:44:06.510 --> 00:44:09.180
at a very low level,
and somewhere in between.

00:44:11.200 --> 00:44:14.060
So, let's think about high level.

00:44:14.060 --> 00:44:16.700
An example is, in fact,
airport extreme printing.

00:44:16.700 --> 00:44:22.560
The application in this case is, in fact,
the print manager,

00:44:22.560 --> 00:44:28.300
and the print driver's I/O module,
instead of sending it to USB,

00:44:28.390 --> 00:44:31.810
sends it across the network
to the device – well,

00:44:31.840 --> 00:44:34.450
in this case,
an airport extreme base station,

00:44:34.580 --> 00:44:38.940
which sends it down through its own
USB stack to the printer itself.

00:44:39.020 --> 00:44:43.840
Now, doing this at a high level has
a big disadvantage in that the

00:44:43.840 --> 00:44:47.890
application itself is required
to know what it's doing.

00:44:47.900 --> 00:44:51.020
It needs to know that it's
talking to a network service.

00:44:51.100 --> 00:44:56.460
So, it's incompatible with most
solutions which are out there.

00:44:56.580 --> 00:44:59.430
However,
it has a very big advantage in that

00:44:59.530 --> 00:45:01.830
protocols exist to do this already.

00:45:02.230 --> 00:45:05.030
In particular,
the two big issues here are

00:45:05.030 --> 00:45:07.650
discovery and session management.

00:45:07.760 --> 00:45:12.380
You want to find out what devices
or what services are available

00:45:12.460 --> 00:45:14.780
to actually use out there.

00:45:14.780 --> 00:45:15.730
That's discovery.

00:45:15.730 --> 00:45:18.060
We have lots of interesting protocols,
including Rendezvous,

00:45:18.060 --> 00:45:20.390
which they always like
us to plug for you.

00:45:20.560 --> 00:45:24.190
And the other problem
is session management.

00:45:24.450 --> 00:45:27.350
You only want one person
talking to your device at once,

00:45:27.400 --> 00:45:30.300
otherwise your device
gets mightily confused.

00:45:30.470 --> 00:45:32.750
Thank you.

00:45:33.770 --> 00:45:37.780
So, as you don't want to get your
device mightily confused,

00:45:37.780 --> 00:45:43.410
you have to have some way of managing
who talks to the device at one time.

00:45:43.420 --> 00:45:49.860
The person talking to the device is
in fact a session in networking speak,

00:45:49.860 --> 00:45:52.120
and you just need to manage this.

00:45:52.120 --> 00:45:53.170
That's session management.

00:45:53.180 --> 00:45:56.880
So, we were thinking, okay,
let's do Airport Extreme,

00:45:56.880 --> 00:45:59.920
let's do remote printing
with a USB printer.

00:45:59.920 --> 00:46:02.230
We thought it was the
perfect application.

00:46:03.700 --> 00:46:08.210
We actually own the application,
so we can put the knowledge of how

00:46:08.210 --> 00:46:11.840
to do this into the application,
the application being the

00:46:11.960 --> 00:46:12.930
printer driver itself.

00:46:12.980 --> 00:46:17.890
And we also own the networking,
we own the base station,

00:46:17.890 --> 00:46:21.860
so it seemed like the
perfect application.

00:46:21.860 --> 00:46:26.100
So, we went ahead,
we added a host controller,

00:46:26.180 --> 00:46:30.140
we added a USB stack, we added a...

00:46:30.600 --> 00:46:40.100
[Transcript missing]

00:46:40.640 --> 00:46:41.560
Fine.

00:46:41.690 --> 00:46:50.560
But we found that the feature set of this
protocol was not actually rich enough.

00:46:50.620 --> 00:46:55.150
Print drivers wanted to do
things such as soft reset,

00:46:55.430 --> 00:46:59.260
getting of the printer ID string,
and in fact getting the entronic status,

00:46:59.260 --> 00:47:02.070
which the protocol didn't allow for.

00:47:02.080 --> 00:47:10.170
The printer module was faked to
actually help with this to some extent,

00:47:10.170 --> 00:47:13.310
and then there's a new print module in
Panther which does an even better job,

00:47:13.610 --> 00:47:17.860
but still, in all circumstances,
it doesn't work.

00:47:17.970 --> 00:47:20.080
There'll be more about that later.

00:47:21.010 --> 00:47:25.690
Another idea we had,
let's try an intermediate level.

00:47:25.860 --> 00:47:27.640
In fact, the user client.

00:47:27.690 --> 00:47:31.400
With the user client,
you're already passing messages

00:47:31.400 --> 00:47:33.750
across a hard boundary,
which is from user

00:47:33.750 --> 00:47:36.770
space into kernel space,
so why not instead just pass

00:47:37.100 --> 00:47:40.150
those messages across the network
to a device which can receive

00:47:40.150 --> 00:47:43.850
them and do exactly what the user
client on your local Mac would do.

00:47:43.900 --> 00:47:46.560
In this case,
send data down to the printer.

00:47:46.560 --> 00:47:48.140
Sounds like a very good idea.

00:47:49.840 --> 00:47:52.040
To some extent,
discovery and session management

00:47:52.040 --> 00:47:53.440
are already built into this.

00:47:53.440 --> 00:47:57.550
When you iterate through
available user clients,

00:47:57.550 --> 00:48:01.800
or when you iterate through
available interfaces,

00:48:01.840 --> 00:48:04.800
you're actually doing
discovery of some description.

00:48:04.800 --> 00:48:09.890
And when you open a device, use a device,
close a device, that is in fact a crude

00:48:09.980 --> 00:48:12.170
form of session management.

00:48:14.090 --> 00:48:16.550
Sounds like a good idea,
and it still is only an

00:48:16.550 --> 00:48:17.980
idea as far as we know.

00:48:17.980 --> 00:48:20.010
No one has ever done this.

00:48:22.450 --> 00:48:26.260
At the other end of the
scale is at a low level.

00:48:26.260 --> 00:48:32.030
An example of this is the
Keyspan remote USB server.

00:48:32.220 --> 00:48:33.920
I was very surprised in January.

00:48:33.920 --> 00:48:37.850
I walked into Macworld,
came up to the Keyspan booth and thought,

00:48:37.950 --> 00:48:46.250
"Oh, that was interesting." They had
in fact made a device which had a

00:48:46.250 --> 00:48:47.800
USB controller attached to the network.

00:48:47.960 --> 00:48:52.200
And indeed, the data bubbled down
through the system as usual.

00:48:52.390 --> 00:48:55.180
The host controller driver said, "Here,
Mr.

00:48:55.180 --> 00:48:59.480
Wim, please send this data to
the USB." And in fact,

00:48:59.520 --> 00:49:04.600
that Wim does send the data to the USB,
but the USB happens to be somewhere else.

00:49:04.910 --> 00:49:08.000
At this very low level,
it's actually quite a

00:49:08.000 --> 00:49:09.170
lot more compatible.

00:49:09.340 --> 00:49:12.960
Nothing in the system
actually has to be aware that

00:49:13.770 --> 00:49:16.800
At this very low level,
it's actually quite a

00:49:16.850 --> 00:49:18.100
lot more compatible.

00:49:18.100 --> 00:49:22.780
Nothing in the system
actually has to be aware that

00:49:23.870 --> 00:49:26.900
At this very low level,
it's actually quite a

00:49:26.900 --> 00:49:28.100
lot more compatible.

00:49:28.100 --> 00:49:54.360
Nothing in the system actually
has to be aware that it searches

00:49:54.360 --> 00:49:57.180
for all the devices on them and
makes them available on the list.

00:49:57.180 --> 00:50:00.680
The user can click on one and say,
"I want to use this now."

00:50:00.680 --> 00:50:03.820
And they also had to add some
session management to this.

00:50:04.230 --> 00:50:09.460
They have various methods,
some of which work for some applications,

00:50:09.460 --> 00:50:13.640
like the open, print, close,
some of which don't.

00:50:13.640 --> 00:50:16.600
Like if you have a mass storage device,
it's always attached.

00:50:16.600 --> 00:50:19.110
The mass storage driver doesn't open,
print, and close.

00:50:19.200 --> 00:50:21.300
It opens and uses forever.

00:50:21.310 --> 00:50:23.780
So there's various methods of doing that.

00:50:23.780 --> 00:50:25.110
that.

00:50:25.640 --> 00:50:29.300
This means that the user experience
is not exactly as seamless

00:50:29.300 --> 00:50:31.500
as you might want it to be.

00:50:31.500 --> 00:50:35.500
So they're actually looking at putting
in some higher-level protocols,

00:50:35.500 --> 00:50:45.320
say add a print server to the USB server,
or a mass storage file server,

00:50:45.360 --> 00:50:51.620
something like that,
just to overcome the disadvantage

00:50:51.800 --> 00:50:51.800
of being at such a low level.

00:50:54.620 --> 00:50:58.100
So what does this all mean to you?

00:50:58.100 --> 00:51:05.160
There are two very big issues
with any implementation like this:

00:51:05.210 --> 00:51:07.600
latency and throughput.

00:51:07.600 --> 00:51:13.070
These are quite tightly coupled,
in that when your latency increases,

00:51:13.070 --> 00:51:15.960
your throughput tends to decrease.

00:51:16.140 --> 00:51:23.100
Some protocols we find are
very sensitive to latency,

00:51:23.100 --> 00:51:27.200
specifically ones where
you do actions serially,

00:51:27.200 --> 00:51:29.630
you ask the device something,
wait for a reply before you

00:51:29.630 --> 00:51:31.340
ask the device something again.

00:51:31.430 --> 00:51:34.190
An example is, say,
the mass storage protocol.

00:51:34.310 --> 00:51:37.360
You send it a command,
you wait for that to be acknowledged,

00:51:37.360 --> 00:51:39.710
you send it some data,
you wait for the data to be acknowledged,

00:51:39.820 --> 00:51:42.120
then you ask it for the status,
and the status comes back to you.

00:51:42.130 --> 00:51:45.560
At each stage you're
waiting for something,

00:51:45.560 --> 00:51:48.670
if there is latency in the system,
that just

00:51:48.800 --> 00:52:31.600
[Transcript missing]

00:52:31.960 --> 00:52:36.280
We find that in some cases,
driver timeouts are too aggressive.

00:52:36.280 --> 00:52:38.580
One printer driver was found
to have a two-second timeout.

00:52:38.580 --> 00:52:42.480
Locally, it didn't tend to time out,
but across a network,

00:52:42.480 --> 00:52:44.640
it was timing out all the time.

00:52:46.950 --> 00:52:50.880
If you have such an aggressive timeout,
you could find that it

00:52:50.940 --> 00:52:52.730
could happen to you locally.

00:52:52.730 --> 00:52:54.640
So this is not actually a good idea.

00:52:54.640 --> 00:52:57.710
If your bus was heavily loaded,
if Nano's webcam was turned

00:52:57.710 --> 00:53:00.840
on using 90% of the bus,
the 10% you have left works a

00:53:00.910 --> 00:53:03.700
hell of a lot slower than you
thought it was going to be,

00:53:03.700 --> 00:53:07.940
your data doesn't go out and come back,
you time out, the user isn't happy.

00:53:07.940 --> 00:53:13.490
So timeouts which are set too
aggressive are not a good thing.

00:53:14.960 --> 00:53:19.420
Another thing:
Do use a standard component

00:53:19.420 --> 00:53:21.890
if it's available.

00:53:21.900 --> 00:53:25.930
For example,
using the Apple-supplied printer module,

00:53:26.020 --> 00:53:29.460
so that it can then take the
data and send it across the

00:53:29.460 --> 00:53:31.980
network and everything's happy.

00:53:32.290 --> 00:53:34.990
In general,
if you're using a standard component,

00:53:34.990 --> 00:53:37.140
we can fix it, you don't have to.

00:53:37.140 --> 00:53:41.360
But in the case of the printer,
we found that the feature

00:53:41.450 --> 00:53:45.660
set wasn't rich enough,
and in particular for printer utilities.

00:53:45.660 --> 00:53:50.430
They're very picky about what they do,
and they don't tend to work, say,

00:53:50.430 --> 00:53:53.100
with the airport extreme printing.

00:53:53.100 --> 00:53:55.530
So if you want to declog
the head on your printer,

00:53:55.660 --> 00:53:58.120
you actually have to
go and plug in locally.

00:54:00.400 --> 00:54:02.550
There's actually not a
lot we can do about this,

00:54:02.550 --> 00:54:05.700
except we can ask you
to provide feedback.

00:54:05.700 --> 00:54:08.600
If you find that any component we
supply doesn't actually meet your need,

00:54:08.600 --> 00:54:12.370
then we can actually rev it at some time,
and eventually it will meet your need,

00:54:12.370 --> 00:54:13.620
and then everything will be happy.

00:54:15.680 --> 00:54:22.120
So, some things you want to do:
Be standard.

00:54:22.250 --> 00:54:25.080
to a standard,
not to any particular implementation.

00:54:25.150 --> 00:54:28.300
Don't say it works on that system
so it should work on your system.

00:54:28.300 --> 00:54:31.770
If you design to a standard,
it should work on any system.

00:54:31.770 --> 00:54:34.950
And if you did design to a standard
and it doesn't work on a system,

00:54:34.950 --> 00:54:39.800
then the system vendor will probably
be motivated to actually fix it.

00:54:39.800 --> 00:54:41.090
And have a standard.

00:54:41.090 --> 00:54:42.380
That's a very good one.

00:54:42.550 --> 00:54:45.370
Or even have a well-defined standard.

00:54:45.370 --> 00:54:50.520
Some of the problems we're having is
that there is no standard for this or

00:54:50.740 --> 00:54:55.830
that the standard does not define what
a device should do in this circumstance

00:54:55.830 --> 00:54:59.600
so it does something quite unexpected.

00:54:59.600 --> 00:55:03.960
For example,
don't overload a standard that exists.

00:55:04.370 --> 00:55:11.060
Like we found that some printers,
in fact, would change their device

00:55:11.110 --> 00:55:13.330
ID string to provide status.

00:55:13.330 --> 00:55:17.460
We were expecting the device ID string
to be static so we'd read it once,

00:55:17.460 --> 00:55:19.160
send it over,
and never bother sending it over again.

00:55:19.160 --> 00:55:22.820
and some printers just refused to print
because they were getting stale status.

00:55:24.990 --> 00:55:26.870
We fix that.

00:55:26.970 --> 00:55:30.660
Don't expect everything.

00:55:30.690 --> 00:55:34.060
Say if you have a compound
or composite device,

00:55:34.060 --> 00:55:36.800
don't expect to get all of
the interfaces or all of the

00:55:36.810 --> 00:55:39.060
devices in that compound device.

00:55:39.060 --> 00:55:41.240
Just use the one that you actually need.

00:55:41.260 --> 00:55:43.840
For example, you say you had a device
which was a printer,

00:55:43.870 --> 00:55:46.740
a scanner, and a modem,
but you wanted to print something.

00:55:47.820 --> 00:55:52.310
If the printer either freaked out,
if it found the scanner wasn't there,

00:55:52.310 --> 00:55:55.100
even if it only wanted to print,

00:55:56.170 --> 00:56:00.020
That could be embarrassing if you
just told your remote USB to actually

00:56:00.050 --> 00:56:04.540
just attach to the printer and not
to the scanner and the modem as well.

00:56:05.970 --> 00:56:13.280
And also,
be optimal locally in your data transfer.

00:56:13.280 --> 00:56:20.360
If you transfer data optimally,
even just locally, well that's good,

00:56:20.370 --> 00:56:23.900
and then when you get into a situation
where the network adds its latencies,

00:56:23.900 --> 00:56:26.470
you'll find that you'll be
in a much better position.

00:56:26.480 --> 00:56:31.850
For example, using multiple reads
or multiple transfers,

00:56:31.850 --> 00:56:34.660
and using larger transfers.

00:56:34.660 --> 00:56:38.330
Let the system do the work of
actually getting the data there,

00:56:38.330 --> 00:56:41.110
rather than your driver
trying to do all the work.

00:56:41.180 --> 00:56:43.840
And one final point,
which I'm not sure if

00:56:43.840 --> 00:56:47.840
it's a good thing or not,
is whether you should post a read.

00:56:47.870 --> 00:56:50.040
If you have a readout
standing on a device,

00:56:50.040 --> 00:56:53.440
you'll know as soon as it tells
you that it has something to say.

00:56:53.440 --> 00:57:01.170
However, on some of the earlier systems,
some of the slower systems,

00:57:01.450 --> 00:57:03.480
having a readout standing like that,
doing nothing,

00:57:03.480 --> 00:57:06.410
uses up a lot of the bus bandwidth,
and the entire system

00:57:06.460 --> 00:57:08.820
can actually slow down,
which is not a good thing.

00:57:08.820 --> 00:57:12.680
So, whether this is a good thing or
not is left to your conscience.

00:57:14.620 --> 00:57:18.900
So, with this,
where should you go for more information?

00:57:18.910 --> 00:57:23.330
Well, Craig is a good person to talk to,
at least ask him who

00:57:23.550 --> 00:57:29.330
else he should talk to,
or indeed send stuff to our mailing list.

00:57:29.370 --> 00:57:34.780
We like to hear from you.

00:57:34.780 --> 00:57:34.780
Yeah, we like to hear from you.

00:57:36.830 --> 00:57:41.870
And some pointers to documentation
on the web page you might

00:57:41.870 --> 00:57:42.820
be interested in seeing.

00:57:42.820 --> 00:57:48.320
This reference is available somewhere,
I'm not quite sure where.
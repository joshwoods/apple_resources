WEBVTT

00:00:12.270 --> 00:00:15.870
Session 220,
which is OpenGL Shading Language.

00:00:15.880 --> 00:00:19.800
And we're pretty excited about
being able to have for Tiger the

00:00:19.840 --> 00:00:24.800
OpenGL Shading Language available
to our developers because Apple's

00:00:24.870 --> 00:00:28.630
extremely excited about the fact
that we have programmable hardware,

00:00:28.640 --> 00:00:32.200
these fantastic GPUs that we
can do incredible things with,

00:00:32.200 --> 00:00:35.720
many of which you've seen particularly
this year and even starting last year

00:00:36.120 --> 00:00:42.260
with some of our demonstrations and also
sessions on programmability with GPUs.

00:00:42.260 --> 00:00:47.720
The interesting thing is that previously,
working with these GPUs has been

00:00:48.220 --> 00:00:52.340
basically almost a step back to
the past in terms of the way you

00:00:52.430 --> 00:00:56.380
program these GPUs was often in sort
of like the assembly language level,

00:00:56.390 --> 00:00:59.400
which isn't approachable
to a lot of developers.

00:00:59.660 --> 00:01:03.510
So what's been happening in both
GPU development-- and that's

00:01:03.510 --> 00:01:06.700
also been driving how these
functionalities are exposed to

00:01:06.700 --> 00:01:10.350
the developers-- is the evolution
of higher level shading languages.

00:01:10.360 --> 00:01:12.920
And that's exactly what
OpenGL Shading Language is.

00:01:12.920 --> 00:01:16.870
And it's an approachable way
for developers experienced with

00:01:16.870 --> 00:01:20.290
languages such as C to be able to
really look at leveraging the power

00:01:20.350 --> 00:01:22.000
of the GPU in their application.

00:01:22.000 --> 00:01:24.670
And it's also important for you
to realize that there's been some

00:01:24.670 --> 00:01:27.690
confusion that we've had at this
WWDC because we've talked about

00:01:27.770 --> 00:01:30.420
OpenGL Shading Language in two contexts.

00:01:30.490 --> 00:01:33.040
One is obviously in its
relationship to Core Image,

00:01:33.040 --> 00:01:36.810
where Core Image has sort of a subset of
OpenGL Shading Language that supports,

00:01:37.030 --> 00:01:37.440
that enables you to do a lot of things.

00:01:37.440 --> 00:01:37.530
So we've been working on that.

00:01:37.560 --> 00:01:37.580
And we've been working
on that for a while now.

00:01:37.600 --> 00:01:40.300
And we're going to do all the interesting
effects that Core Image supports.

00:01:40.340 --> 00:01:43.240
But I also want to be clear that the
purpose of this session is to communicate

00:01:43.240 --> 00:01:49.890
about the full OpenGL Shading Language,
which will be part of OpenGL in Tiger.

00:01:50.010 --> 00:01:54.230
So that's going to give you all the
capabilities of the language and

00:01:54.230 --> 00:01:58.780
that will expose all the capabilities
of current and future hardware,

00:01:58.840 --> 00:02:01.800
GPU hardware that
supports programmability.

00:02:01.890 --> 00:02:04.100
So on that note,
I'd like to actually invite our speaker,

00:02:04.180 --> 00:02:06.410
James McComb,
to stage to take you through the session.

00:02:06.430 --> 00:02:07.540
Thank you.

00:02:07.540 --> 00:02:09.540
Thank you.

00:02:14.090 --> 00:02:17.990
Good morning and thanks
for coming to this session.

00:02:18.150 --> 00:02:22.220
I guess quite a lot of people make
it back from Cupertino last night,

00:02:22.290 --> 00:02:23.860
but thanks for coming along.

00:02:24.000 --> 00:02:28.020
Yeah, we're pretty excited about
this shading language stuff

00:02:28.020 --> 00:02:30.000
that we've been working on.

00:02:30.000 --> 00:02:35.000
I guess I want to sort of start
off with looking at where we were.

00:02:35.190 --> 00:02:38.640
Two years ago,
we came here and hardware was coming

00:02:38.950 --> 00:02:45.190
out that had a programmable vertex unit,
and we talked about our vertex program,

00:02:45.300 --> 00:02:51.000
which was a language to allow, well,
reprogramming of the vertex unit.

00:02:51.000 --> 00:02:54.390
And last year,
we talked about our fragment program,

00:02:54.390 --> 00:02:58.150
which allowed you to reprogram
the sort of fragment lookup,

00:02:58.150 --> 00:02:59.980
the per fragment lookup.

00:03:00.000 --> 00:03:03.060
And some of the visual effects
that you can do with this really

00:03:03.060 --> 00:03:05.000
are very powerful and incredible.

00:03:05.000 --> 00:03:08.250
And increasingly, more and more,
your games are showing up and

00:03:08.250 --> 00:03:10.000
various things are using this.

00:03:10.000 --> 00:03:13.180
It's becoming clear that you
can do some very powerful

00:03:13.960 --> 00:03:15.990
real-time effects with that.

00:03:16.000 --> 00:03:19.510
However, those languages were
designed -- suddenly,

00:03:19.510 --> 00:03:22.000
you know, we were handed with
this fancy new hardware.

00:03:22.000 --> 00:03:25.000
We needed to come up with
a language to program it.

00:03:25.000 --> 00:03:30.000
The languages that were created were
very -- quite close to the hardware.

00:03:30.000 --> 00:03:33.000
They were assembly-like in nature.

00:03:33.170 --> 00:03:34.850
Well, now we've had some time.

00:03:35.000 --> 00:03:39.000
We've had some time in the
OpenGL community to sit down

00:03:39.000 --> 00:03:45.000
and discuss a way to expose that
hardware and also future hardware

00:03:45.000 --> 00:03:47.710
as new capabilities appear.

00:03:48.000 --> 00:03:52.210
We want a language that can expose that,
be as portable as possible in the

00:03:52.210 --> 00:03:57.000
sense that the same program can
run on various pieces of hardware.

00:03:57.140 --> 00:03:59.000
Hardware supports new operations.

00:03:59.000 --> 00:03:59.970
The language will expose that.

00:04:00.010 --> 00:04:02.000
And we don't want to be revising
the language every year.

00:04:02.000 --> 00:04:04.000
We want something that we can nail down.

00:04:04.000 --> 00:04:08.320
And there's been a language now
for a very long time that's proven

00:04:08.320 --> 00:04:11.000
itself to be very good at this,
and that's the C programming language.

00:04:11.000 --> 00:04:16.260
For the general-purpose processor,
C got people away from programming

00:04:16.350 --> 00:04:18.000
in assembly all the time.

00:04:18.000 --> 00:04:20.940
And I guess the fact that we're
still programming in C today

00:04:20.940 --> 00:04:24.000
is a good sign that it's a
pretty well-designed language.

00:04:24.000 --> 00:04:31.000
So the OpenGL ARB got together and pretty
much took the C programming language

00:04:31.000 --> 00:04:33.000
and added some slightly new stuff.

00:04:33.000 --> 00:04:36.400
And it's got some slightly new
syntax to it that's required to,

00:04:36.490 --> 00:04:38.820
I guess, make it appropriate for shading.

00:04:39.000 --> 00:04:43.910
So let's take a look at
the support for this.

00:04:44.000 --> 00:04:48.990
If you want to check in your
application if it's there,

00:04:49.000 --> 00:04:51.300
these are the four extensions
that are going to be on an

00:04:51.440 --> 00:04:54.000
OpenGL implementation that support this.

00:04:54.000 --> 00:04:56.690
As I go through the presentation,
you'll see why really

00:04:56.690 --> 00:04:57.990
there are four of them.

00:04:58.000 --> 00:05:00.270
But the most important one
really to check for is the

00:05:00.450 --> 00:05:02.000
one that's highlighted there,
ARB shading language.

00:05:02.010 --> 00:05:07.510
If you check for that and that's there,
you should have at least some

00:05:07.510 --> 00:05:15.000
level of support for the shading
language on your implementation.

00:05:15.360 --> 00:05:20.000
Also, hardware support for this.

00:05:20.000 --> 00:05:25.120
Really, any hardware that has support
for ARB fragment program

00:05:25.120 --> 00:05:30.270
and ARB vertex program,
that hardware can support

00:05:31.000 --> 00:05:31.000
the OpenGL program.

00:05:31.170 --> 00:05:36.000
So the OpenGL shading language,
or at least varying amounts of it.

00:05:36.000 --> 00:05:39.720
The shading language being C,
it has looping, branching,

00:05:39.720 --> 00:05:40.740
function calls.

00:05:41.230 --> 00:05:45.600
And also it has a lot of
built-in functions for generating

00:05:45.610 --> 00:05:48.000
noise and various things.

00:05:48.000 --> 00:05:51.930
Well, it turns out that a lot of
current hardware simply doesn't

00:05:51.950 --> 00:05:56.000
have the actual machine code
instructions that will do that.

00:05:56.000 --> 00:05:58.510
So there could be programs that
you'll submit that simply won't

00:05:58.510 --> 00:05:59.880
run on the hardware at this time.

00:06:00.000 --> 00:06:03.000
However,
this is a forward-thinking language.

00:06:03.000 --> 00:06:08.990
And as hardware keeps coming out,
soon it will be fully supported.

00:06:09.800 --> 00:06:14.810
But that leads me to my next point,
which is that current hardware resources,

00:06:14.900 --> 00:06:18.670
they're limited either in terms of the
range of instructions that are available

00:06:18.670 --> 00:06:23.990
or in terms of how many registers it has.

00:06:24.370 --> 00:06:27.500
Therefore,
I want to talk about software rendering.

00:06:27.500 --> 00:06:30.400
Now, here we are at the cutting
edge of technology.

00:06:30.400 --> 00:06:33.700
There's fancy new hardware, and well,
we're back to software rendering again.

00:06:33.700 --> 00:06:37.380
Well,
let's think about really why that is.

00:06:37.420 --> 00:06:42.680
In the past, OpenGL really has sort of
been used mainly for sort of

00:06:42.680 --> 00:06:44.920
non-photorealistic rendering.

00:06:44.920 --> 00:06:48.680
It's been used for either previews in
an application like a CAD application.

00:06:48.730 --> 00:06:51.600
It's been used as a preview,
but for the actual final rendering,

00:06:51.990 --> 00:06:54.940
typically applications have had to
use their own software renderer.

00:06:55.120 --> 00:06:57.390
Or in the movies,
people have used RenderMan and

00:06:57.390 --> 00:06:59.050
various things for that.

00:06:59.460 --> 00:07:03.080
Well, OpenGL is developing,
and now with these shading languages,

00:07:03.120 --> 00:07:07.170
photorealistic rendering
is becoming a possibility.

00:07:07.440 --> 00:07:14.240
So a software renderer becomes
necessary because we want

00:07:14.240 --> 00:07:23.590
something that is high-precision,
has real 32-bit floats.

00:07:23.700 --> 00:08:25.000
[Transcript missing]

00:08:25.410 --> 00:08:29.990
Let's have a demo here of the software
renderer in action just to show

00:08:29.990 --> 00:08:34.700
you sort of what we've got here.

00:08:35.130 --> 00:08:37.690
So,
for any of you who were here last year,

00:08:37.820 --> 00:08:41.990
you might recall this
particular image here.

00:08:42.000 --> 00:08:45.400
This is actually just an arb vertex
and fragment program in ShaderBuilder.

00:08:45.400 --> 00:08:48.590
This isn't even high-level shading
language I'm showing right now.

00:08:48.750 --> 00:08:53.540
But this is really merely just to prove
the point of our software renderer.

00:08:53.540 --> 00:08:58.000
Here you can see the
scene being rendered.

00:08:58.020 --> 00:09:02.470
This is running on a
Radeon 9800 in hardware.

00:09:02.470 --> 00:09:05.830
So it's obviously pretty quick here.

00:09:05.860 --> 00:09:09.490
And if I can move the light around.

00:09:09.880 --> 00:09:16.360
"Now if we click this button here,
you can see now we're

00:09:16.360 --> 00:09:17.800
running in software.

00:09:17.830 --> 00:09:20.140
This is a fragment program
running in software.

00:09:20.140 --> 00:09:25.220
Now yes, it's obviously slower,
but it's not bad.

00:09:26.810 --> 00:09:31.690
So that's an example of our
software renderer right there.

00:09:33.440 --> 00:09:38.100
So let's take another look at
another example of this in action.

00:09:38.100 --> 00:09:42.130
Let's see here.

00:09:50.360 --> 00:09:53.790
This is another one that if there's any
medical imaging folks in the audience,

00:09:53.840 --> 00:09:57.490
they might find this
somewhat interesting.

00:09:57.600 --> 00:12:18.200
[Transcript missing]

00:12:18.540 --> 00:12:22.030
There's a program object,
and inside a program object you have

00:12:22.190 --> 00:12:24.220
a vertex shader and a fragment shader.

00:12:24.980 --> 00:12:31.970
The intent of a vertex shader is
that it generates a transformed

00:12:32.070 --> 00:12:36.370
vertex with an untransformed
vertex and OpenGL state as inputs.

00:12:36.450 --> 00:12:37.400
That's its goal.

00:12:37.400 --> 00:12:40.400
It takes vertices that have been
submitted from your application

00:12:40.400 --> 00:12:44.360
and performs some operation to
put them into window coordinates.

00:12:44.400 --> 00:12:52.250
A fragment shader is similar,
except it's dealing with pixels.

00:12:52.400 --> 00:12:58.100
It generates a pixel on the frame
buffer with the vertex attributes

00:12:58.170 --> 00:13:01.620
interpolated across the scan line,
passed into it,

00:13:01.620 --> 00:13:04.400
and also it has access to OpenGL state.

00:13:04.400 --> 00:13:07.800
Obviously,
it can sample from the texture units.

00:13:08.790 --> 00:13:10.220
Where do they fit in the pipeline?

00:13:10.470 --> 00:13:13.780
So let's look at that.

00:13:13.780 --> 00:13:16.650
You have your vertex data coming
from your application and then you

00:13:16.660 --> 00:13:20.860
have the pixel data handed in through
your text image calls or whatever.

00:13:20.910 --> 00:13:24.700
And also this can all obviously
come from display lists.

00:13:24.700 --> 00:13:28.070
Normally the vertex data gets
through a fixed function gets

00:13:28.100 --> 00:13:32.740
multiplied by a model view matrix,
it gets transformed and it gets

00:13:32.740 --> 00:13:35.790
clipped by the clipping planes on
the sides of the screen or even user

00:13:35.800 --> 00:13:38.080
clipping planes if you have any.

00:13:38.080 --> 00:13:42.750
And also the vertex color gets
set by a very basic lighting

00:13:42.750 --> 00:13:47.220
model that's built into OpenGL.

00:13:47.220 --> 00:13:52.220
And then basically you end up with a
bunch of triangles and then it goes down

00:13:52.280 --> 00:13:56.230
to the graphics driver or the software
renderer which takes those triangles and

00:13:56.230 --> 00:14:01.970
breaks them up into sort of trapezoids
with a flat top and bottom and goes

00:14:01.970 --> 00:14:05.360
through them scan line by scan line.

00:14:05.360 --> 00:14:08.150
And basically stamps these
pixels into the frame buffer

00:14:08.210 --> 00:14:10.340
and it's a very fixed operation.

00:14:10.340 --> 00:14:14.350
If you've got multi-texturing turned on
it will pick a textile from one texture

00:14:14.360 --> 00:14:17.100
unit then another and maybe modulate
them together or something like that.

00:14:20.140 --> 00:14:25.610
Well, the programmability part comes in
whenever you start to pull those out,

00:14:25.610 --> 00:14:28.470
and you're going to then have
the ability to replace these

00:14:28.560 --> 00:14:29.940
two parts of the pipeline.

00:14:29.940 --> 00:14:31.520
That's what you're doing, essentially.

00:14:31.520 --> 00:14:36.200
So, take a look at some terminology here.

00:14:36.200 --> 00:14:41.840
A primitive is really a series of
vertices with a connection rule.

00:14:42.020 --> 00:14:44.720
So, in a sense,
if you're in immediate mode,

00:14:44.720 --> 00:14:47.780
everything between your GL begin and end,
in the begin call,

00:14:47.780 --> 00:14:50.700
you specify the connection rule,
and everything in between

00:14:50.700 --> 00:14:53.010
that is your vertices,
and you can specify

00:14:53.010 --> 00:14:54.990
vertex attributes there,
too.

00:14:58.600 --> 00:15:00.840
Shaders are applied on
a per-primitive basis.

00:15:00.840 --> 00:15:03.310
You can't switch shader
halfway through a primitive.

00:15:03.320 --> 00:15:11.500
So it's important to note that the shader
remains sort of constant throughout that.

00:15:11.500 --> 00:15:17.490
Also, OpenGL state, it can only change on
a per-primitive basis.

00:15:17.500 --> 00:15:21.280
You know, you can only enable or disable
something outside of a begin-end.

00:15:21.280 --> 00:15:24.950
So that's going to be -- the state
is going to be uniform throughout

00:15:24.950 --> 00:15:26.500
the execution of that shader.

00:15:26.610 --> 00:15:29.400
And that term uniform is
important because it's actually

00:15:29.540 --> 00:15:31.490
going to be a keyword in this
-- in this shading language.

00:15:31.500 --> 00:15:36.500
And I'm just trying to
explain where they come from.

00:15:36.610 --> 00:15:39.740
Also, looking at a vertex,
obviously it's a 3D point

00:15:39.890 --> 00:15:41.360
comprising a primitive.

00:15:41.600 --> 00:15:44.450
The vertex shaders are
ran once for every vertex.

00:15:44.510 --> 00:15:47.260
Now, in hardware they could
be ran in parallel,

00:15:47.260 --> 00:15:51.180
but still there's one execution
for every one of those vertices.

00:15:51.570 --> 00:15:54.500
They're independent from one another for
that -- for the purpose of parallelism.

00:15:54.570 --> 00:15:59.180
So therefore,
you cannot have communication between

00:15:59.180 --> 00:16:02.490
subsequent executions of a shader.

00:16:02.500 --> 00:16:04.500
They're discrete from one another.

00:16:04.500 --> 00:16:10.470
Also, vertices, they have attributes
associated with them.

00:16:10.550 --> 00:16:14.180
You know, mainly their position,
the color, they could have a normal

00:16:14.190 --> 00:16:17.660
texture coordinates,
and a bunch of other user-defined

00:16:17.660 --> 00:16:20.950
attributes that you might want,
weights or whatever

00:16:20.950 --> 00:16:22.350
else you might be using.

00:16:22.500 --> 00:16:26.660
And then a fragment is really
-- it's a pixel on your frame

00:16:26.800 --> 00:16:32.500
buffer that comprises a scanline
during the triangle rasterization.

00:16:32.500 --> 00:16:34.560
So, that's the first thing.

00:16:34.860 --> 00:16:38.790
The Fragment Shader determines its color.

00:16:38.880 --> 00:16:42.790
The Fragment Shader has
access to data that's varying

00:16:42.790 --> 00:16:46.710
coming from the Vertex Shader,
and it's varying because for every

00:16:46.720 --> 00:16:52.090
execution of that Fragment Shader,
those attributes are interpolated

00:16:52.090 --> 00:16:54.610
across that scan line.

00:16:57.800 --> 00:17:00.800
So let's take a look at the current
languages that are available today.

00:17:00.800 --> 00:17:03.800
The ARB approved languages are
Vertex and Fragment Program.

00:17:03.800 --> 00:17:09.210
Again, as I said, they're assembly-like,
except they've no bitwise operations.

00:17:09.260 --> 00:17:10.790
They're all kind of
high-level instructions,

00:17:11.100 --> 00:17:15.640
somewhat high-level,
mainly sort of mathematical operations.

00:17:16.650 --> 00:17:20.800
They all deal in floating point,
and it's a SIMD instruction set.

00:17:20.800 --> 00:17:24.800
An ADD is going to do an ADD on
four components in a register.

00:17:26.800 --> 00:17:26.800
All the registers are four components.

00:17:27.440 --> 00:17:29.690
And also the instructions
are a fairly close mapping

00:17:29.840 --> 00:17:32.890
of the hardware instructions,
which is actually the very thing that

00:17:33.000 --> 00:17:34.800
we are trying to get away from now.

00:17:35.550 --> 00:17:38.480
And the language has enforced
resource limitations,

00:17:38.490 --> 00:17:41.020
which can be annoying,
but the upside of that,

00:17:41.090 --> 00:17:44.770
the good side of enforced resource
limitations is that you know if it's

00:17:44.770 --> 00:17:46.680
going to run on hardware or not.

00:17:47.440 --> 00:17:48.180
You know that.

00:17:48.280 --> 00:17:50.220
You can query it,
and as long as your program is

00:17:50.220 --> 00:17:53.800
within those well-defined bounds,
it will run on the graphics hardware.

00:17:54.370 --> 00:17:55.800
This is just a look at the hardware.

00:17:56.530 --> 00:17:59.100
So this is the instruction
set that was available.

00:17:59.230 --> 00:18:00.900
I broke it into four sections.

00:18:00.910 --> 00:18:03.670
This is the ARB fragment
program instruction set.

00:18:04.840 --> 00:18:08.400
You can see, you know,
assembly-like names.

00:18:08.400 --> 00:18:11.580
This is an example of
an ARB vertex program,

00:18:11.670 --> 00:18:15.750
a very simple one that merely
transforms a vertex and moves

00:18:15.790 --> 00:18:18.470
the texture coordinate through.

00:18:18.470 --> 00:18:20.750
Pretty straightforward.

00:18:21.740 --> 00:18:25.640
And this is a fragment program
that basically samples a text line.

00:18:26.500 --> 00:18:29.800
So this is a sample of a texel from
texture unit 0 and texture unit 1,

00:18:29.800 --> 00:18:33.770
and then it multiplies them together
and writes it to the output fragment.

00:18:34.210 --> 00:18:35.820
That's what those languages
look like at this point.

00:18:35.990 --> 00:18:36.770
Pretty straightforward.

00:18:36.870 --> 00:18:41.250
But it can get pretty complicated
if you want to express large

00:18:41.250 --> 00:18:43.800
programs and complex effects.

00:18:45.310 --> 00:18:51.270
So let's take a look at the high-level
shading language at this point.

00:18:51.620 --> 00:18:53.490
Why do you want to use this?

00:18:53.700 --> 00:18:55.980
Potentially less code to write.

00:18:55.980 --> 00:18:58.840
You can express it in terms
that you're more familiar with.

00:18:58.870 --> 00:19:01.520
I'm sure some of you are familiar
with writing assembly code,

00:19:01.610 --> 00:19:04.010
but no matter what,
you're really only writing

00:19:04.010 --> 00:19:05.360
it in your inner loops.

00:19:05.360 --> 00:19:07.160
You're not writing it
every day with your code,

00:19:07.280 --> 00:19:10.940
so being able to write
in C could be convenient.

00:19:10.940 --> 00:19:14.000
You no longer need to deal with
specific registers anymore.

00:19:14.100 --> 00:19:15.220
That's all virtualized.

00:19:15.350 --> 00:19:18.040
Just declare variables and
use them as you please.

00:19:18.040 --> 00:19:24.420
You can depend on the compiler to some
extent to take care of that for you.

00:19:24.420 --> 00:19:26.940
Also is the goal of
hardware independence.

00:19:27.250 --> 00:19:31.510
This language doesn't tie itself
to any one piece of hardware,

00:19:31.550 --> 00:19:36.290
which I think is a good
thing in the long run.

00:19:36.580 --> 00:19:42.260
And also is the nice intent of
being able to have code reuse.

00:19:42.260 --> 00:19:46.040
The ability to have function calls and
also to be able to draw in multiple files

00:19:46.040 --> 00:19:48.320
comprising one shader is very useful.

00:19:48.630 --> 00:19:52.590
You could have like a file,
like a library almost full of like useful

00:19:52.590 --> 00:19:55.800
chunks of shader code that you use,
and you can function call into

00:19:55.910 --> 00:19:57.490
that from the shading language.

00:19:57.640 --> 00:19:59.590
So that code reuse is pretty nice.

00:20:01.460 --> 00:20:07.340
Here's just a comparison of sort of what
the two things look like side by side.

00:20:07.880 --> 00:20:11.160
You can see there's the arb vertex
program that transforms a vertex

00:20:11.280 --> 00:20:12.830
and passes its color through.

00:20:12.950 --> 00:20:17.340
And then you can see the GL shading
language version of the same thing.

00:20:17.340 --> 00:20:20.410
It's a more natural form
of expressing it really.

00:20:20.500 --> 00:20:23.020
It just looks like C really.

00:20:23.020 --> 00:20:25.870
It has a main entry point and so forth.

00:20:26.710 --> 00:20:29.930
So,

00:20:30.170 --> 00:20:35.850
The object model here,
the way the API kind of works is

00:20:36.150 --> 00:20:39.600
And to make a vertex shader
object you basically need,

00:20:39.660 --> 00:20:43.190
you can have one or more strings,
which are the strings of the C code

00:20:43.190 --> 00:20:44.500
that you basically want to put in.

00:20:44.500 --> 00:20:47.880
And there can be more than
one of these strings and

00:20:47.880 --> 00:20:50.440
they're concatenated together.

00:20:50.440 --> 00:20:52.430
And you can function
call in between them.

00:20:52.440 --> 00:20:55.810
So you need a vertex shader object,
and then also it's the exact same

00:20:55.980 --> 00:20:59.120
thing except for the fragment shader.

00:20:59.120 --> 00:21:03.670
When you have these two objects created,
you basically pass each of

00:21:03.940 --> 00:21:07.810
those through a compile stage,
which compiles it down

00:21:07.830 --> 00:21:12.190
to the machine code,
which then gets passed into a linker.

00:21:12.490 --> 00:21:21.990
This is a linker that builds
a final program object.

00:21:22.010 --> 00:21:26.550
That is what you then use that program
object and start drawing primitives and

00:21:26.550 --> 00:21:31.120
the shader will be applied to those.

00:21:31.120 --> 00:21:33.790
The language is C-inspired.

00:21:33.990 --> 00:21:37.080
It's got the usual main entry point.

00:21:37.080 --> 00:21:40.510
The language supports looping
and branching and all those other

00:21:40.510 --> 00:21:45.080
things just like you'd expect.

00:21:45.080 --> 00:21:48.120
There are no pointers.

00:21:48.190 --> 00:21:51.340
Since really you're not
accessing memory directly,

00:21:51.340 --> 00:21:54.440
there's no real concept of
accessing memory in this,

00:21:54.440 --> 00:21:57.860
the idea of having pointers doesn't
really make sense in this language.

00:21:57.860 --> 00:21:59.940
So that syntax you will not see.

00:22:01.360 --> 00:22:10.140
There are new data types since the
hardware registers are all vectors.

00:22:10.140 --> 00:22:12.300
There are new data types to support that.

00:22:12.650 --> 00:22:17.810
And also there's a
matrix data type as well.

00:22:18.290 --> 00:22:20.810
Since we're introducing
vector data types,

00:22:20.810 --> 00:22:24.100
what happens if you want to
pick a scalar out of that?

00:22:24.180 --> 00:22:27.080
You want to get access to a
scalar or you want to reorder the

00:22:27.250 --> 00:22:29.100
scalar components in a vector.

00:22:29.100 --> 00:22:31.860
Well,
there's new syntax for swizzling now.

00:22:32.080 --> 00:22:36.530
We can pick out a certain
component or reorder them.

00:22:36.790 --> 00:22:38.680
There are new qualifiers.

00:22:38.710 --> 00:22:42.830
You know, you've got the C program for a
vertex shader and then you have a

00:22:42.830 --> 00:22:43.700
C program for a fragment shader.

00:22:43.700 --> 00:22:44.670
They're separate.

00:22:44.860 --> 00:22:46.600
How do you get communication
in between them?

00:22:46.600 --> 00:22:49.190
Well,
the way that's done is via declaring a

00:22:49.190 --> 00:22:53.260
variable with a particular qualifier in
both programs and having the names match.

00:22:53.260 --> 00:22:56.740
That's what the linker stage does
is it ties up those loose ends.

00:22:59.160 --> 00:23:02.460
And then we have a,
there are a bunch of intrinsic variables,

00:23:02.460 --> 00:23:07.880
just predefined variables that are there,
and either they allow you to access

00:23:07.880 --> 00:23:13.490
OpenGL state or you write your value
into these predefined variables.

00:23:13.870 --> 00:23:21.470
So let's take a look at the qualifiers,
the type qualifiers that exist.

00:23:22.260 --> 00:23:25.990
The first stage is an attribute.

00:23:25.990 --> 00:23:31.130
Inside your vertex shader,
to access the vertex attributes,

00:23:31.180 --> 00:23:33.970
you basically just declare something
with the attribute qualifier.

00:23:34.100 --> 00:23:38.100
They only make sense to be
declared in a vertex shader.

00:23:38.100 --> 00:23:42.100
And attributes,
they change at most once per vertex.

00:23:42.430 --> 00:23:46.290
And they're read-only.

00:23:46.290 --> 00:23:46.290
You can't write to them.

00:23:46.930 --> 00:23:51.730
The variables that are declared
with the uniform qualifier,

00:23:51.770 --> 00:23:55.840
basically those are things that
are set outside the shader,

00:23:55.840 --> 00:23:59.300
and they're uniform throughout
execution of that shader.

00:23:59.300 --> 00:24:02.640
So they're read-only,
and their frequency of change

00:24:02.750 --> 00:24:06.800
is at most once per primitive,
things like the OpenGL state.

00:24:06.800 --> 00:24:13.120
And even in fragment programming,
the texture data is

00:24:13.120 --> 00:24:13.930
considered uniform as well.

00:24:14.290 --> 00:24:16.350
The other thing, just like C,
you've obviously got a const,

00:24:16.390 --> 00:24:19.360
which is just inline constants that
you want to declare in your program,

00:24:19.360 --> 00:24:20.400
obviously read-only.

00:24:20.400 --> 00:24:23.840
If you don't put a qualifier in,
you're just declaring, really,

00:24:23.840 --> 00:24:26.600
a temporary variable,
just for scratch space.

00:24:26.780 --> 00:24:29.440
And it's important to note,
like I said earlier,

00:24:29.440 --> 00:24:33.600
the data in those will not persist
between executions of the shader.

00:24:33.600 --> 00:24:36.910
You can't write something into a temp
and expect it to be there on the next,

00:24:37.030 --> 00:24:38.180
when it processes the next vertex.

00:24:38.280 --> 00:24:39.220
That isn't going to happen.

00:24:39.220 --> 00:24:41.980
They are read-write access.

00:24:44.180 --> 00:24:46.920
And then there's the qualifier varying.

00:24:46.920 --> 00:24:50.610
Basically,
variables declared with a varying

00:24:50.610 --> 00:24:55.310
type are basically your pipeline
of communication between the vertex

00:24:55.350 --> 00:24:56.710
shader and the fragment shader.

00:24:56.720 --> 00:24:59.860
Declare something as varying,
the rasterizer is going to take

00:24:59.860 --> 00:25:02.600
that value from the vertex shader
and it's going to interpolate it,

00:25:02.600 --> 00:25:05.190
and the fragment program
will get that value as it's

00:25:05.190 --> 00:25:07.200
interpolated across the scanline.

00:25:07.200 --> 00:25:11.520
So...

00:25:12.850 --> 00:25:16.340
Let's take a look at some
of these new data types.

00:25:16.340 --> 00:25:19.460
You basically have three
main classes of data type.

00:25:19.460 --> 00:25:22.740
You have floating point types,
there's an integer type,

00:25:22.740 --> 00:25:24.550
and there's even a Boolean type.

00:25:24.800 --> 00:25:28.820
Now, you can't expect that that
integer is actually going to be

00:25:28.820 --> 00:25:32.650
stored in a fixed-width register,
so there's still no shifting

00:25:32.800 --> 00:25:38.490
or bitwise operations,
but the type still exists because some

00:25:38.600 --> 00:25:40.800
of the functions expect it to be there.

00:25:40.800 --> 00:25:44.800
Also, these are the vector types,
and there can be two-component,

00:25:44.800 --> 00:25:46.690
three-component,
and four-component vectors.

00:25:46.770 --> 00:25:51.580
And again, use swizzling to pick
out scalar components.

00:25:51.820 --> 00:25:56.470
Also, they can be accessed
as a zero-based array.

00:25:56.600 --> 00:25:59.390
So if you have a vector and
you want the second scalar,

00:25:59.390 --> 00:26:02.690
you could do, you know, variable,
open the square bracket,

00:26:02.690 --> 00:26:03.700
and actually pick it out like that.

00:26:03.700 --> 00:26:06.700
So it's the two ways to access it.

00:26:06.700 --> 00:26:09.680
Obviously, there are scalar types now.

00:26:09.780 --> 00:26:15.040
If you declare something as a float,
it's just going to have

00:26:15.040 --> 00:26:17.170
one scalar in there.

00:26:17.370 --> 00:26:23.300
And of course the flow control
constructs in this language,

00:26:23.300 --> 00:26:29.900
they will only accept a
Boolean type to branch on.

00:26:30.420 --> 00:26:32.290
There's also a bunch of matrix types.

00:26:32.300 --> 00:26:35.440
You'll probably want to use these
for getting the transformation matrix

00:26:35.620 --> 00:26:39.500
from OpenGL and store stuff in there,
or you might have your own matrices

00:26:39.900 --> 00:26:43.300
within your application that you
want to pass in as parameters.

00:26:43.300 --> 00:26:46.360
Stored column major,
which is compatible with the

00:26:46.360 --> 00:26:48.300
way the rest of OpenGL works.

00:26:48.490 --> 00:26:53.280
And again, you can access these as an
array of column vectors.

00:26:53.400 --> 00:26:58.300
If you take a matrix and, I guess,
take the first element of that,

00:26:58.300 --> 00:27:00.300
that will return a vector type.

00:27:00.300 --> 00:27:04.160
And then with that vector,
you could access the first

00:27:04.170 --> 00:27:06.200
element and get a scalar.

00:27:06.200 --> 00:27:06.200
That's how it'll work.

00:27:06.500 --> 00:27:09.520
The last data type is a sampler.

00:27:09.550 --> 00:27:13.390
Basically, it's a handle to
encapsulate a texture unit.

00:27:13.400 --> 00:27:19.110
There are function calls in
this language for getting out

00:27:19.110 --> 00:27:22.270
a text from a texture unit,
and a sampler

00:27:22.460 --> 00:27:25.260
You need to pass that in as the
first argument and then outside

00:27:25.260 --> 00:27:28.440
of the shader in your application,
you then sort of attach a

00:27:28.440 --> 00:27:30.270
texture unit to a sampler.

00:27:30.380 --> 00:27:30.780
That's how they work.

00:27:30.850 --> 00:27:32.300
It's just a handle.

00:27:32.420 --> 00:27:35.560
And again,
they're always declared with a uniform

00:27:35.560 --> 00:27:41.300
qualifier because texture units don't
change between executions of the shader

00:27:41.300 --> 00:27:44.300
or during execution of the shader.

00:27:44.540 --> 00:27:48.300
Data from these is of course read-only.

00:27:48.300 --> 00:27:53.920
So here is another sort of deviation
from the C programming language.

00:27:54.800 --> 00:28:00.300
Because we now have, I guess,
aggregate data types in a sense,

00:28:00.300 --> 00:28:06.290
basically things that are non-scalar,
we need these constructors.

00:28:06.320 --> 00:28:09.180
Not so much constructors
in the C++ sense,

00:28:09.180 --> 00:28:12.300
but it's probably
perhaps similar in idea.

00:28:12.380 --> 00:28:14.300
Anyhow, they're used to initialize
an aggregate type.

00:28:14.300 --> 00:28:19.840
And of course in C you had this concept
you could just declare a variable

00:28:20.040 --> 00:28:24.300
v= and then you could open braces
and fill in each of the components.

00:28:24.300 --> 00:28:29.290
What a constructor is,
is basically when you declare a variable,

00:28:29.300 --> 00:28:32.390
if you want to assign something,
if you want to put something into it,

00:28:32.420 --> 00:28:36.260
you basically make a function call
which is the same as the type,

00:28:36.320 --> 00:28:37.300
as the name of the type.

00:28:37.420 --> 00:28:40.280
And then in those brackets
you fill in the values.

00:28:40.300 --> 00:28:41.210
That's how it works.

00:28:41.300 --> 00:28:43.300
So I've shown you a couple
of examples of that.

00:28:43.300 --> 00:28:44.300
You can see there.

00:28:44.300 --> 00:28:46.300
I'm declaring a four
component vector type.

00:28:46.300 --> 00:28:49.390
I then have to call a function
vec4 with four scalars

00:28:49.580 --> 00:28:51.860
inside of that to fill it in.

00:28:52.300 --> 00:28:56.300
And then you can see the similar
example filling in an actual structure.

00:28:56.300 --> 00:29:00.300
You make a call which is the same name as
the structure and you pass in the values

00:29:00.300 --> 00:29:03.300
and you can see how they actually nest.

00:29:03.300 --> 00:29:05.300
These constructors nest.

00:29:05.300 --> 00:29:07.130
That's one thing that's
a little different that

00:29:07.240 --> 00:29:10.110
you'll need to get used to,
but it's not hard to figure out.

00:29:10.300 --> 00:29:16.180
In terms of the operators you have,
there's nothing really new here.

00:29:16.430 --> 00:29:20.300
The only thing that you'll see
missing is the bitwise operations.

00:29:20.360 --> 00:29:22.490
There's the logical and
and or and so forth,

00:29:22.490 --> 00:29:24.150
but not the bitwise.

00:29:24.760 --> 00:29:30.940
So, swizzling, just to give an example
of how that works,

00:29:30.940 --> 00:29:39.470
you can see here I declare v0 and
construct it with four scalers.

00:29:39.860 --> 00:29:43.990
And you can see then,
I'm assigning v0 to v1,

00:29:44.070 --> 00:29:45.520
but v0 has a swizzle on it.

00:29:45.920 --> 00:29:48.360
And you can see what
that's actually doing.

00:29:48.360 --> 00:29:52.160
It's actually reordered the components
within the scalers within that.

00:29:53.910 --> 00:29:57.160
These swizzles, they can either be x, y,
z, w.

00:29:57.350 --> 00:29:59.990
They have, I guess,
they have convenient names.

00:29:59.990 --> 00:30:03.200
x, y, z, w you would probably use
if it's positional data.

00:30:03.290 --> 00:30:05.800
RGBA if it's color space data.

00:30:06.010 --> 00:30:09.320
And there's even an strq if it's
used for storing texture units.

00:30:09.490 --> 00:30:12.360
You can use them interchangeably,
but to make your code more readable,

00:30:12.360 --> 00:30:14.150
you might want to take advantage of that.

00:30:16.910 --> 00:30:22.100
Also, as a result of a swizzle,
you can actually change the data type.

00:30:22.110 --> 00:30:25.890
You can see that when
I'm assigning V0 to V3,

00:30:26.000 --> 00:30:29.250
V3 is only a VEC2,
so it has only two components.

00:30:29.400 --> 00:30:32.210
So you're going to need to
pick the two components that

00:30:32.310 --> 00:30:35.780
you're going to assign to that,
which is why I'm picking Q and S.

00:30:36.020 --> 00:30:43.110
And also you can see that type
conversion can be used to just

00:30:43.110 --> 00:30:43.390
produce one single scalar.

00:30:43.660 --> 00:30:51.620
In terms of the operators, in a sense,
they're overloaded in the sense

00:30:51.710 --> 00:30:53.730
that depending on the type
that they're working with,

00:30:53.830 --> 00:30:55.840
they'll have a different behavior.

00:30:55.840 --> 00:30:57.290
No, it's not.

00:30:57.370 --> 00:30:58.610
Don't get too scared of that.

00:30:58.620 --> 00:31:00.200
It's pretty simple, the behavior,
actually.

00:31:00.200 --> 00:31:02.970
For all the operations,
apart from the multiply,

00:31:02.980 --> 00:31:04.750
the behavior is very obvious.

00:31:04.820 --> 00:31:06.390
It simply applies.

00:31:06.390 --> 00:31:10.370
If you do an add A equals B plus C,
it's going to perform that add

00:31:10.380 --> 00:31:12.050
for all the scalers within that.

00:31:12.430 --> 00:31:14.020
If it's a vector,
it's going to do four adds.

00:31:14.110 --> 00:31:16.130
If it's a matrix,
it's going to do 16 of them.

00:31:16.430 --> 00:31:21.040
The reason multiply is a
little different is that if you

00:31:21.330 --> 00:31:25.430
multiply a vector times a matrix,
it does a linear algebraic

00:31:25.430 --> 00:31:29.290
multiply where it's actually
going to be four dot products.

00:31:29.380 --> 00:31:31.440
That's what it's actually
going to break down into,

00:31:31.440 --> 00:31:34.760
which is really convenient because at
the beginning of your vertex programs,

00:31:34.760 --> 00:31:40.610
you're always having to do these four
dot products to transform your vertex.

00:31:40.740 --> 00:31:41.820
Well, now it's just a one-liner.

00:31:42.360 --> 00:31:45.270
Position equals vertex
times model view matrix.

00:31:45.360 --> 00:31:46.400
It's pretty convenient.

00:31:46.400 --> 00:31:50.490
Matrix times matrix also works that way.

00:31:50.640 --> 00:31:55.440
I talked about these
predefined variables.

00:31:57.040 --> 00:32:03.970
You can see that we have predefined ones,
one for the vertex color, normal,

00:32:04.050 --> 00:32:07.690
and access to the texture units.

00:32:07.760 --> 00:32:12.000
Varying types to communicate
from vertex to fragment.

00:32:12.000 --> 00:32:14.700
Again,
texture coordinates in the front color.

00:32:14.700 --> 00:32:18.650
And outputs in the fragment shader.

00:32:18.740 --> 00:32:21.910
When you write your final
color into GLFragColor,

00:32:22.380 --> 00:32:24.040
and that's what will get
written to the frame buffer.

00:32:24.040 --> 00:32:29.240
And then there's a bunch of uniforms that
are declared in your model view matrix,

00:32:29.370 --> 00:32:34.940
and access to the lighting
information from the GL state.

00:32:35.690 --> 00:32:38.880
So, let's take a look at,
we've talked a little

00:32:38.880 --> 00:32:40.600
about the language here.

00:32:40.600 --> 00:32:43.830
Let's look at how to,
I've shown you the program strings,

00:32:43.950 --> 00:32:47.740
how do you actually load these
into your GL and actually make

00:32:47.750 --> 00:32:50.060
use of them in your application.

00:32:50.680 --> 00:32:57.250
Well, the first thing you want to do
is acquire the program strings,

00:32:57.330 --> 00:32:59.520
load them from a file,
do whatever you need to do,

00:32:59.590 --> 00:33:03.600
but load them into two strings.

00:33:03.600 --> 00:33:07.780
We've got a type declared for that,
GLCharR pointer.

00:33:07.780 --> 00:33:11.270
Load them in,
and then you want to actually

00:33:11.380 --> 00:33:14.770
put them in an array of strings,
and the reason for that is what I said,

00:33:14.780 --> 00:33:17.900
you can actually have multiple
strings that comprise a shader

00:33:17.900 --> 00:33:19.750
with function calls between them.

00:33:20.600 --> 00:33:23.100
So in this case, I just have one string.

00:33:23.100 --> 00:33:26.150
So I'm obviously setting the
array size to be just one,

00:33:26.260 --> 00:33:28.290
but that could be any number.

00:33:28.810 --> 00:33:31.500
The second step,
you need to declare three handles,

00:33:31.670 --> 00:33:36.290
one for the vertex shader object,
one for the fragment shader object,

00:33:36.420 --> 00:33:38.910
and then one for the final
program object that these are

00:33:38.910 --> 00:33:42.900
both going to be attached to.

00:33:43.920 --> 00:33:47.800
So you have those declared and then
other two variables that are useful

00:33:48.020 --> 00:33:53.940
is basically a status variable and
also the length of a log because when

00:33:53.940 --> 00:33:58.220
you perform compiles and links you're
actually going to get information

00:33:58.240 --> 00:34:01.130
back from the compiler that you might
want to check or if there's errors

00:34:01.130 --> 00:34:02.720
you're going to want to see them.

00:34:02.720 --> 00:34:06.510
So yes,
there's now a log that comes back.

00:34:07.320 --> 00:34:11.700
Your next stage,
let's create the vertex shader object.

00:34:11.700 --> 00:34:14.000
You can see from the code
I've got here how to do it.

00:34:14.000 --> 00:34:16.050
It's not very hard.

00:34:16.300 --> 00:34:19.450
You basically create shader
object and you tell it,

00:34:19.650 --> 00:34:21.700
you know, it's a vertex shader.

00:34:21.840 --> 00:34:27.420
GL shader source arb allows me
basically to attach the string to that.

00:34:27.630 --> 00:34:30.200
Compile shader arb will
actually perform the,

00:34:30.320 --> 00:34:33.420
will start the compiler going,
generating the machine code for this.

00:34:33.420 --> 00:34:38.820
And at that point,
you want to get back the status of the

00:34:38.820 --> 00:34:41.500
compile to see if it succeeded or not.

00:34:41.690 --> 00:34:44.500
And also you want to get back
the length of an info log.

00:34:44.500 --> 00:34:52.450
And you need that length because
you'll need to allocate some

00:34:52.770 --> 00:34:53.480
memory to store your log into.

00:34:54.190 --> 00:34:59.440
So, you will repeat that step
for the fragment shader.

00:34:59.440 --> 00:35:01.730
It's exactly the same thing
except with vertex pretty much

00:35:01.880 --> 00:35:03.260
replaced with the word fragment.

00:35:03.260 --> 00:35:06.630
So, you're going to end up with these
vertex and fragment shader objects.

00:35:06.690 --> 00:35:09.200
At that point,
you create a program object,

00:35:09.200 --> 00:35:12.100
you attach the vertex and
fragment shader to that,

00:35:12.420 --> 00:35:14.840
and then you call link program.

00:35:14.840 --> 00:35:19.970
And that's basically going to tie up
varying variables that you declared

00:35:19.970 --> 00:35:22.660
in the vertex and fragment shader.

00:35:22.740 --> 00:35:25.220
It does a name match on those
and connects them together.

00:35:25.220 --> 00:35:28.260
And the linker,
you also need to check for errors

00:35:28.300 --> 00:35:33.620
as well because the link stage,
like C programming can feel,

00:35:33.620 --> 00:35:34.850
and you need to check that.

00:35:36.450 --> 00:35:39.420
So,
assuming that that all succeeded and you

00:35:39.420 --> 00:35:43.500
have your program object ready to go,
if you're ready to start drawing

00:35:43.500 --> 00:35:49.570
geometry with that program object,
you make a call to useProgramObject,

00:35:49.590 --> 00:35:52.110
and then you just put it in there
and it will start to draw with that.

00:35:52.300 --> 00:35:58.290
Unlike our vertex and fragment program,
there's no glEnableDisable.

00:35:58.500 --> 00:36:00.050
You don't enable and disable it.

00:36:00.340 --> 00:36:03.520
Rather, you use a program object,
and then if you want

00:36:03.640 --> 00:36:07.100
to turn off the shader,
you call it with null,

00:36:07.100 --> 00:36:11.430
and that will switch you
back to the fixed function.

00:36:11.790 --> 00:36:13.560
pipeline.

00:36:13.560 --> 00:36:16.660
So I mentioned that
inside these languages,

00:36:16.660 --> 00:36:19.270
you can declare variables
with a uniform type.

00:36:19.280 --> 00:36:27.040
They basically are your way of
passing parameters into your program.

00:36:27.040 --> 00:36:30.180
For those familiar with our
vertex and fragment program,

00:36:30.180 --> 00:36:33.650
these environment parameters
and local parameters,

00:36:33.720 --> 00:36:36.790
well, they're all environment
parameters at this point,

00:36:36.790 --> 00:36:39.540
and this is how you set them.

00:36:39.540 --> 00:36:42.750
You basically,
there's two calls required.

00:36:42.980 --> 00:36:45.430
The first one is, you need to get, like,
an index back,

00:36:45.430 --> 00:36:50.090
which is the position of that uniform,
and the thing you pass in is the actual

00:36:50.100 --> 00:36:54.040
string that you declared in your program.

00:36:54.040 --> 00:36:56.990
It gives you an index back,
and then you make a call to GL uniform,

00:36:57.490 --> 00:37:01.690
and there's several variants of that for,
you know, passing in an array or some

00:37:01.690 --> 00:37:08.140
immediate inline floating point
values to pass in your uniform data.

00:37:08.320 --> 00:37:11.780
The same thing is true
for vertex attributes.

00:37:11.800 --> 00:37:14.100
You basically get the name.

00:37:14.100 --> 00:37:17.840
You get an index from the
name of the attribute,

00:37:18.020 --> 00:37:19.970
and you just set the values.

00:37:20.490 --> 00:37:24.710
Um, to take a look at, uh,
there are a bunch of built-in

00:37:24.760 --> 00:37:26.400
functions that are really nice.

00:37:26.400 --> 00:37:29.800
There's a kind of a library of
functions that come along with this.

00:37:29.810 --> 00:37:34.150
Um, I would encourage you to,
if you're interested in this,

00:37:34.150 --> 00:37:38.680
in this language, to go and get the,
the official, the orange book on the

00:37:38.680 --> 00:37:42.890
shader language because the,
the, the range of these functions is, is,

00:37:42.900 --> 00:37:45.510
is too much really for
me to go through today.

00:37:45.600 --> 00:37:47.770
Um,
but you should look through them because

00:37:47.770 --> 00:37:49.480
there are a lot of very interesting ones.

00:37:49.590 --> 00:37:52.350
Some of the ones that I,
I've been finding quite interesting

00:37:52.350 --> 00:37:55.230
are the noise generation functions,
um, which are really good

00:37:55.230 --> 00:37:56.700
for image processing.

00:37:56.800 --> 00:37:59.300
Uh, basically random number generators,
but there's a,

00:37:59.300 --> 00:38:01.540
there's a lot of variations in them.

00:38:01.630 --> 00:38:05.430
Um, there's other things like, you know,
like a, a, like a,

00:38:05.430 --> 00:38:09.390
a mix function for doing a linear
interpolation between two values,

00:38:09.470 --> 00:38:10.780
which is convenient.

00:38:10.860 --> 00:38:16.480
And, uh, also the, uh, the, the,
the texture access functions.

00:38:17.400 --> 00:38:19.140
Um, and actually I want to take a look
at some of those because those I,

00:38:19.140 --> 00:38:22.200
I,
I feel are probably the most important.

00:38:22.200 --> 00:38:27.130
Um, one thing that's really pretty nice
about this language is we've always

00:38:27.130 --> 00:38:32.020
thought of texture access being available
in fragment programs because obviously

00:38:32.020 --> 00:38:33.880
you want to texture map your surface.

00:38:33.880 --> 00:38:38.360
Well, the shading language allows
you to do texture sampling

00:38:38.360 --> 00:38:40.550
in vertex programs as well.

00:38:40.560 --> 00:38:43.660
This has some pretty powerful, um,
side effects.

00:38:43.730 --> 00:38:48.240
You can imagine passing just a,
a bunch of vertices into OpenGL and

00:38:48.260 --> 00:38:52.820
in the vertex program displacing
them based on a texture map,

00:38:53.060 --> 00:38:55.350
suddenly, you know,
you could have a live video

00:38:55.350 --> 00:38:58.370
stream going into your GL,
have a bunch of vertices and have like,

00:38:58.400 --> 00:39:01.900
you know, like the, the three,
like a 3D face almost showing up.

00:39:02.000 --> 00:39:06.280
Um, there, there's a lot of,
a lot of possibilities there.

00:39:06.280 --> 00:39:09.090
Um, or,
or you could even just store generic

00:39:09.100 --> 00:39:11.360
vertex data in your texture units.

00:39:11.440 --> 00:39:14.790
It's, it's kind of, kind of mind bending,
but the things you can do there are, are,

00:39:14.850 --> 00:39:15.680
are, are large.

00:39:16.400 --> 00:39:21.800
Um, in terms of, uh, of texture access,
basically it's just a function call

00:39:21.800 --> 00:39:24.870
and you pass in a texture coordinate,
a sampler,

00:39:24.870 --> 00:39:28.950
and basically it gives you back, um,
a four component value which is

00:39:28.950 --> 00:39:31.600
the RGBA value at that point.

00:39:31.710 --> 00:39:35.670
Um, the, really the,
the functionality here is,

00:39:35.750 --> 00:39:37.540
is the same as our fragment program.

00:39:37.540 --> 00:39:41.740
Like, obviously with the addition that
you can do it in the vertex program.

00:39:41.740 --> 00:39:46.090
Um, it does add support for depth
textures where it can get a text on,

00:39:46.100 --> 00:39:48.830
automatically do a comparison
against a depth buffer,

00:39:48.960 --> 00:39:51.880
which is useful for shadowing effects.

00:39:52.020 --> 00:39:57.950
Um, so now actually I, I would like to,
uh, switch over to show you a

00:39:57.950 --> 00:40:00.320
bit of a demonstration here.

00:40:00.320 --> 00:40:06.210
Now, it's important to note that this
is really the bleeding edge here.

00:40:06.270 --> 00:40:10.480
Um, so it's not done yet,
but I want to give you an,

00:40:10.480 --> 00:40:14.720
an example of sort of to show you
how far along we are with this.

00:40:14.720 --> 00:40:19.850
Um, so hopefully things will
go according to plan here.

00:40:21.230 --> 00:40:29.290
So I went ahead and did a little
work here to get this integrated

00:40:29.290 --> 00:40:32.820
into Shader Builder so that
I could show you what we have.

00:40:32.930 --> 00:40:38.750
Let me first show you,
just typing this in.

00:40:38.800 --> 00:40:44.630
I'm going to make the font here
a little bigger so that you

00:40:44.630 --> 00:40:48.270
can see a little more clearly.

00:40:49.220 --> 00:40:54.100
So let's go to the fragment program
here and write a simple one.

00:40:54.100 --> 00:41:00.550
Just declaring my main
function right here.

00:41:02.970 --> 00:41:05.270
And then basically in
my fragment program,

00:41:05.270 --> 00:41:09.910
I'm merely going to pass through the
interpolated color data coming from

00:41:09.920 --> 00:41:14.220
the vertex shader to the output.

00:41:14.220 --> 00:41:14.220
So,

00:41:14.450 --> 00:41:16.980
This is the predefined
variable GL_FragColor.

00:41:16.980 --> 00:41:20.800
And you can see as I'm typing here,
again, as is common in ShaderBuilder,

00:41:20.800 --> 00:41:22.300
it'll do the real-time
sign text checking.

00:41:22.300 --> 00:41:25.320
And even though this is C,
we're still able to do that,

00:41:25.340 --> 00:41:27.300
which is kind of nice.

00:41:27.430 --> 00:41:30.300
So that's the fragment shader done.

00:41:30.300 --> 00:41:31.800
That's a very simple one.

00:41:32.040 --> 00:41:37.910
And then in the vertex shader,
let's pick OpenGL's shading language.

00:41:40.610 --> 00:41:47.740
Let's try that again.

00:41:47.850 --> 00:41:50.600
Let me just show you what I've got here.

00:41:50.600 --> 00:41:55.440
As I said, this is very recent code.

00:41:55.700 --> 00:42:00.540
Here you can see the high-level
shading language being used to express

00:42:00.540 --> 00:42:01.790
a pretty simple lighting model.

00:42:01.790 --> 00:42:04.600
It's just done in the vertex program,
in the vertex shader space.

00:42:04.610 --> 00:42:10.250
The fragment shader is merely
passing through the color.

00:42:10.600 --> 00:42:15.180
Let me make the code a little bigger.

00:42:18.660 --> 00:42:20.810
Hopefully everyone's
able to see that okay.

00:42:21.030 --> 00:42:22.480
But you can see the kind
of stuff we're doing.

00:42:22.480 --> 00:42:26.140
This is common in C, you know,
basically able to nest

00:42:26.140 --> 00:42:27.350
brackets and so forth.

00:42:27.360 --> 00:42:32.450
Basically you can express these
things in a lot less lines of code.

00:42:32.510 --> 00:42:35.600
If I want,
you can see on this line I declare F1,

00:42:35.960 --> 00:42:37.660
and here I use it again.

00:42:37.660 --> 00:42:41.700
Well, I can go ahead and, like,
move it inside.

00:42:45.550 --> 00:42:46.430
"Delete that line.

00:42:46.570 --> 00:42:48.700
So it's... We're getting there.

00:42:48.700 --> 00:42:49.430
We're not done yet.

00:42:49.760 --> 00:42:54.450
But this feature is slated for Tiger.

00:42:54.490 --> 00:42:58.500
But we really want to get
it to you as fast as we can.

00:42:58.500 --> 00:43:00.500
So we're doing our best.

00:43:00.500 --> 00:43:03.350
It's a difficult spec to implement.

00:43:03.440 --> 00:43:08.470
So we'll keep you posted on that.

00:43:08.570 --> 00:43:11.360
So I guess I want to
wrap up at this point.

00:43:11.480 --> 00:43:14.500
I hope you enjoyed hearing
about this at least.

00:43:14.500 --> 00:43:16.890
And I hope that when
it becomes available,

00:43:17.030 --> 00:43:18.450
you'll start to use it.

00:43:18.510 --> 00:43:22.660
And yeah, I guess at this point,
I'd like to invite Travis up if... I'm

00:43:22.660 --> 00:43:24.500
sure there'll be a lot of questions.
WEBVTT

00:00:12.270 --> 00:00:16.080
Welcome to session 436,
Advanced Core Data Features.

00:00:16.570 --> 00:00:18.660
Like the slide said,
this is a confidential session,

00:00:18.660 --> 00:00:24.630
so please refrain from taking pictures,
camera phones, filming, microphones,

00:00:24.630 --> 00:00:25.910
that kind of stuff.

00:00:26.050 --> 00:00:28.710
I am...

00:00:30.660 --> 00:00:33.500
Melissa Turner,
I'll be joined on stage later by

00:00:33.500 --> 00:00:38.000
some of my co-conspirators in the
code that we're about to show you,

00:00:38.040 --> 00:00:41.280
Ben Trumbull and Chris Hansen.

00:00:42.720 --> 00:00:43.960
So what is Core Data?

00:00:44.150 --> 00:00:46.050
For those of you who didn't
make yesterday's session,

00:00:46.140 --> 00:00:50.250
Core Data is a model-driven object graph
management and persistency framework.

00:00:50.440 --> 00:00:51.500
What does that mean?

00:00:51.520 --> 00:00:53.760
Basically,
it's a framework that gives you

00:00:54.120 --> 00:01:00.560
scalable object lifecycle management,
gives you automatic undo, redo,

00:01:00.720 --> 00:01:03.020
tracks changes in your object graph.

00:01:03.020 --> 00:01:06.270
I suppose I should say at this point,
object graph is a fancy way for

00:01:06.270 --> 00:01:10.810
saying collection of objects that
actually have pointers to each other.

00:01:10.860 --> 00:01:13.680
It gives you-- ensures data
consistency and correctness.

00:01:13.690 --> 00:01:16.680
And the persistence part will
allow you to read or write

00:01:16.680 --> 00:01:17.990
to various types of files.

00:01:18.210 --> 00:01:21.340
And we're integrated with the
Cocoa bindings to give you

00:01:21.340 --> 00:01:23.590
user interface synchronization.

00:01:24.880 --> 00:01:27.360
Why should you use Core Data?

00:01:27.370 --> 00:01:30.740
Well, it relieves you from having
to reinvent the wheel.

00:01:30.740 --> 00:01:32.760
There's a lot of persistence
frameworks out there.

00:01:32.760 --> 00:01:35.700
I'm sure many of you have
actually written one.

00:01:35.700 --> 00:01:38.610
You don't need to redo
it over and over again.

00:01:38.610 --> 00:01:41.980
There's nothing terribly
app-specific about it.

00:01:42.030 --> 00:01:44.200
We give you a choice
of persistent stores,

00:01:44.200 --> 00:01:48.240
so you can pick the one that best suits
the type of application you're writing.

00:01:49.020 --> 00:01:51.290
One of the big advantages is
it prefers your application

00:01:51.490 --> 00:01:52.890
for future features in Cocoa.

00:01:52.950 --> 00:01:55.870
If we're going to add new stuff,
it's most likely going to be tied in

00:01:55.870 --> 00:01:58.560
with the stuff we've already written,
so if you're using the

00:01:58.560 --> 00:02:01.110
stuff we've already written,
you'll probably get those

00:02:01.110 --> 00:02:02.540
new features for free.

00:02:02.540 --> 00:02:04.840
It gives you a faster
development lifecycle.

00:02:04.840 --> 00:02:07.310
Writing an object graph
management or persistence

00:02:07.410 --> 00:02:08.990
framework is not a simple thing.

00:02:08.990 --> 00:02:11.540
Trust us,
we've been working on it for months.

00:02:11.540 --> 00:02:15.240
We'd like to spare you that and
let you concentrate on writing

00:02:15.240 --> 00:02:17.130
the stuff you want to write.

00:02:19.170 --> 00:02:21.930
Because it's there,
it's used by a number of other people,

00:02:22.050 --> 00:02:24.650
it's a lot more likely to be robust.

00:02:24.790 --> 00:02:26.630
Other people are going to find the bugs.

00:02:26.770 --> 00:02:28.600
You don't have to do it yourself.

00:02:29.090 --> 00:02:31.580
In this session, we're going to sort of
give you an overview of the

00:02:31.710 --> 00:02:34.510
architecture of the system,
talk about the individual components.

00:02:34.590 --> 00:02:36.920
We're going to talk about
how they're all put together.

00:02:36.960 --> 00:02:39.720
We're going to talk about some
of the stuff you want to do,

00:02:39.770 --> 00:02:42.080
or if you're advanced,
you're going to want

00:02:42.080 --> 00:02:42.760
to do with the stack.

00:02:42.860 --> 00:02:45.010
And we're going to give you a few,
as we go through, tips and tricks,

00:02:45.100 --> 00:02:49.150
things you should know,
things you should know not to do.

00:02:50.970 --> 00:02:53.560
So what are the pieces of
the Core Data architecture?

00:02:53.690 --> 00:02:56.230
Well, we're built-- there's
four basic components.

00:02:56.460 --> 00:03:00.380
There's predicates, models,
managed objects in the

00:03:00.380 --> 00:03:03.030
managed object context,
and there's object stores

00:03:03.060 --> 00:03:04.100
with the store coordinator.

00:03:04.270 --> 00:03:06.050
And like I said,
we have some integration with the

00:03:06.080 --> 00:03:08.370
Cocoa documents and controllers.

00:03:08.740 --> 00:03:13.740
Core Data Xcode UI can be used
to graphically create models and

00:03:13.820 --> 00:03:17.010
configure how Core Data is going
to work in your application.

00:03:19.400 --> 00:03:21.240
Here's the basic architecture.

00:03:21.280 --> 00:03:23.700
Up at the top, which we're not going to
talk about in this session,

00:03:23.760 --> 00:03:28.340
is the user interface, which is connected
with the binding stuff.

00:03:28.340 --> 00:03:30.500
Below that,
we've got the controller layer.

00:03:30.500 --> 00:03:33.410
Again,
we're not going to talk much about that.

00:03:33.750 --> 00:03:35.400
Middle part's where we
start getting interesting.

00:03:35.400 --> 00:03:37.440
That's the Managed Object Context.

00:03:37.470 --> 00:03:42.030
That is sort of the core of the object
graph management part of the system.

00:03:42.110 --> 00:03:44.640
It manages the managed objects.

00:03:44.780 --> 00:03:47.600
We've got a persistent store
coordinator living below that,

00:03:47.600 --> 00:03:50.390
which talks to a model and a data file.

00:03:52.820 --> 00:03:55.560
Well,
I've mentioned models several times.

00:03:55.600 --> 00:03:59.180
They're sort of really the most
important part of the system.

00:03:59.180 --> 00:03:59.780
They're the blueprint.

00:03:59.890 --> 00:04:03.830
They're the thing that describes what
data exists in your application and how

00:04:03.990 --> 00:04:06.650
those objects are related to each other.

00:04:06.650 --> 00:04:08.760
It tells you what
interactions you've got going,

00:04:08.840 --> 00:04:11.110
what needs to be updated if
something else is updated,

00:04:11.110 --> 00:04:12.260
all that kind of stuff.

00:04:12.400 --> 00:04:14.600
The model is really
sort of the description.

00:04:14.600 --> 00:04:19.700
It contains all the really important
application logic of your system.

00:04:20.140 --> 00:04:23.420
It's the foundation for managed objects,
and you can create it from

00:04:23.420 --> 00:04:25.090
Xcode or programmatically.

00:04:25.090 --> 00:04:27.640
Xcode gives you the
basic development tools,

00:04:27.860 --> 00:04:29.180
the thing you use up front.

00:04:29.280 --> 00:04:32.460
It's nice, it's spiffy, it's graphical,
it's visual.

00:04:32.630 --> 00:04:35.020
You can see what you're actually doing.

00:04:35.020 --> 00:04:37.660
Often that's not quite enough,
and you want to make some minor

00:04:37.660 --> 00:04:39.870
runtime tweaks to the model,
so we let you create them

00:04:40.260 --> 00:04:42.240
programmatically or modify
them programmatically if

00:04:42.350 --> 00:04:43.860
you've already created them.

00:04:45.440 --> 00:04:46.240
Why do we use a model?

00:04:46.240 --> 00:04:48.360
It's a foundation for
data-driven development.

00:04:48.360 --> 00:04:52.280
What that means is you can concentrate on
the data architecture of your application

00:04:52.280 --> 00:04:54.310
rather than the control flow through it.

00:04:54.380 --> 00:04:58.640
You think about what objects you have,
how they interact with each other,

00:04:58.640 --> 00:05:01.520
as opposed to, well,
if I click this button here,

00:05:01.520 --> 00:05:05.190
then I need to do this in this object,
and if that then, or while,

00:05:05.190 --> 00:05:07.190
don't need to think of any of that.

00:05:07.270 --> 00:05:09.430
You just concentrate on the objects.

00:05:09.430 --> 00:05:11.630
We take care of the rest of it.

00:05:11.940 --> 00:05:14.720
The model, as I said,
defines this data architecture,

00:05:14.720 --> 00:05:17.790
and what this allows you to do,
as some of you saw in yesterday's

00:05:17.790 --> 00:05:21.680
session or Bertrand's keynote,
is get behavior without writing code.

00:05:24.390 --> 00:05:25.640
What's in a model?

00:05:25.740 --> 00:05:28.480
Some of these terms are going to be
familiar to those of you who are familiar

00:05:28.480 --> 00:05:32.040
with entity relationship modeling,
but a model contains entities

00:05:32.220 --> 00:05:36.040
which have attributes,
relationships, and fetch properties.

00:05:36.160 --> 00:05:39.220
It also contains templates
of fetch requests,

00:05:39.300 --> 00:05:42.790
which I'll talk about all of this later,
and it contains

00:05:42.870 --> 00:05:45.160
configuration information.

00:05:46.040 --> 00:05:48.570
This is the classes these things map to.

00:05:48.720 --> 00:05:53.260
This is what you should be looking for
in the API headers you've got on disk.

00:05:53.300 --> 00:05:56.640
Entities map to instances
of NSEntityDescription,

00:05:56.660 --> 00:05:59.720
attributes to NSAttributeDescription,
relationships are

00:05:59.830 --> 00:06:03.620
NSRelationshipDescription,
fetched properties are NSFetchedProperty,

00:06:03.620 --> 00:06:06.660
and fetched request templates
are NSFetchedRequest.

00:06:06.810 --> 00:06:09.540
Configurations, well,
those are just strings usually

00:06:09.660 --> 00:06:12.750
with sets associated with them.

00:06:14.780 --> 00:06:19.870
NSNC description is loosely analogous
to class definition for data type.

00:06:21.210 --> 00:06:23.450
It supports inheritance,
which means you can

00:06:23.450 --> 00:06:26.370
have abstract entities,
things that are never actually

00:06:26.530 --> 00:06:29.160
instantiated in your application.

00:06:29.160 --> 00:06:38.080
Entity inheritance is not necessarily
the same as class inheritance.

00:06:38.160 --> 00:06:42.670
You can have an entity inheritance
hierarchy that does not map one-to-one

00:06:42.670 --> 00:06:44.600
with a class inheritance hierarchy.

00:06:45.480 --> 00:06:48.150
As a matter of fact,
you can map everything to

00:06:48.150 --> 00:06:52.540
NSManagedObject if you want and skip
having a class hierarchy entirely.

00:06:52.540 --> 00:06:55.370
It has multiple property types,
the two most important of which

00:06:55.370 --> 00:06:57.140
are attributes and relationships.

00:06:57.140 --> 00:07:01.410
And they're editable
only until first use.

00:07:01.460 --> 00:07:03.160
This is something important to remember.

00:07:03.160 --> 00:07:06.740
Once you fetch data into an application
using an NSEntity description,

00:07:06.750 --> 00:07:09.160
you can no longer change
that NSEntity description.

00:07:09.160 --> 00:07:12.790
It gets too complicated trying to figure
out what we're supposed to do with that

00:07:12.870 --> 00:07:15.200
extra pieces of data and new stuff,
old stuff.

00:07:15.480 --> 00:07:16.580
You can't do it.

00:07:16.740 --> 00:07:18.620
You'll basically have exceptions thrown.

00:07:18.620 --> 00:07:21.230
And by the way,
that's true of all the classes I'm going

00:07:21.230 --> 00:07:23.190
to talk about in the model section.

00:07:25.300 --> 00:07:30.660
NSAttributeDescription is analogous
to a field containing an NSValueType.

00:07:30.660 --> 00:07:35.160
We support all the standard NSValueTypes,
or standard NSDataValueTypes.

00:07:35.160 --> 00:07:39.380
You can provide a default value
using an NSAttributeDescription,

00:07:39.380 --> 00:07:41.720
and you can set validation rules.

00:07:41.720 --> 00:07:44.920
This attribute has a
minimum value of this,

00:07:45.000 --> 00:07:48.990
has a maximum value of that, must have,
for strings,

00:07:49.040 --> 00:07:53.260
can set a wildcarded pattern,
can set a maximum string length,

00:07:53.260 --> 00:07:54.400
that kind of thing.

00:07:54.820 --> 00:07:56.840
Attributes can be optional,
which means they don't

00:07:56.840 --> 00:07:58.140
necessarily have to appear.

00:07:58.140 --> 00:08:00.710
And they can be transient,
which is a concept that makes

00:08:00.840 --> 00:08:03.470
a lot more sense when you think
about it in the context of

00:08:03.470 --> 00:08:05.400
there being a persistent layer.

00:08:05.400 --> 00:08:08.130
But a transient attribute is
one which is managed by the

00:08:08.130 --> 00:08:11.880
object graph management layer,
but which is not actually persistent.

00:08:11.880 --> 00:08:14.980
This is the kind of attribute you'd
use for storing caching information,

00:08:14.980 --> 00:08:17.400
stuff that's derived at
runtime and can be recomputed,

00:08:17.400 --> 00:08:22.760
but that you just want to keep around
for convenience and speed purposes.

00:08:22.760 --> 00:08:24.000
It's pretty much a scratch pad.

00:08:26.730 --> 00:08:27.870
Relationship descriptions.

00:08:27.980 --> 00:08:30.530
Relationship descriptions, well,
those are pointers to one

00:08:30.530 --> 00:08:33.100
or more managed objects.

00:08:33.230 --> 00:08:36.320
They can be one-to-one,
they can be one-to-many.

00:08:36.540 --> 00:08:38.360
They support minimum and maximum counts.

00:08:38.420 --> 00:08:41.240
This bicycle has two wheels.

00:08:41.270 --> 00:08:43.380
This vehicle has at most 18 wheels.

00:08:43.380 --> 00:08:46.510
You can specify both of these values.

00:08:47.150 --> 00:08:49.820
A relationship usually defines
an inverse relationship.

00:08:49.870 --> 00:08:52.340
There's some rare contexts
in which it doesn't,

00:08:52.340 --> 00:08:55.230
and if you don't know the specifics,
you want to define an

00:08:55.420 --> 00:08:56.500
inverse relationship.

00:08:56.500 --> 00:08:59.190
It specifies a delete rule,
what should happen when

00:08:59.220 --> 00:09:00.540
an object is deleted.

00:09:00.540 --> 00:09:03.380
The options are nullify,
when this object is deleted,

00:09:03.800 --> 00:09:07.740
delete the objects in
all of its relationships.

00:09:07.740 --> 00:09:09.760
Cascade?

00:09:09.810 --> 00:09:09.810
No.

00:09:09.980 --> 00:09:14.760
Nullify is when this object is deleted,
just null out the back pointers

00:09:14.920 --> 00:09:16.480
in all of the relationships.

00:09:16.590 --> 00:09:20.370
Cascade is delete all of the
children in its relationships.

00:09:20.670 --> 00:09:23.730
Deny, if this object has any
objects in its relationships,

00:09:23.870 --> 00:09:25.260
you're not allowed to delete it.

00:09:25.500 --> 00:09:28.690
No action means don't bother
touching anything on the other

00:09:28.690 --> 00:09:30.500
end of the relationships.

00:09:31.390 --> 00:09:35.440
It also allows validation
rules like the attributes.

00:09:35.490 --> 00:09:37.830
And like the attributes,
it can be optional or

00:09:37.830 --> 00:09:39.680
it can be transient.

00:09:40.380 --> 00:09:42.320
NSFetch property is
kind of a special beast.

00:09:42.320 --> 00:09:46.080
It allows you to make a unidirectional
link between an entity and a query.

00:09:46.080 --> 00:09:49.990
This allows a single managed object
to have a loose relationship with

00:09:49.990 --> 00:09:54.090
a collection of other objects,
and that relationship is not managed.

00:09:54.220 --> 00:09:57.120
It's always too many because we
can never tell how many objects

00:09:57.120 --> 00:09:58.740
the fetch is going to bring back.

00:09:58.820 --> 00:10:02.750
And it uses an NSFetch request,
which we'll talk about next,

00:10:02.820 --> 00:10:04.470
to specify the query.

00:10:04.470 --> 00:10:08.400
The concepts of optional and transient
don't really apply here since,

00:10:08.400 --> 00:10:09.720
well, it's a query.

00:10:13.710 --> 00:10:19.130
NSFetchRequest is an object-oriented
representation of a query operation.

00:10:19.380 --> 00:10:21.650
It specifies a query that
you want to search for,

00:10:21.690 --> 00:10:24.970
or an entity that you want to search for,
a predicate that you're going to

00:10:24.970 --> 00:10:27.740
use to define which instances of
that entity you're looking for,

00:10:27.740 --> 00:10:31.470
a sort descriptor that tells you what
order you want them to come back in.

00:10:32.420 --> 00:10:34.880
Fetch requests in the
model are named templates,

00:10:34.960 --> 00:10:37.430
which means that they contain
predicates that can have

00:10:37.670 --> 00:10:39.370
variable expressions in them.

00:10:39.500 --> 00:10:42.960
If it has a variable expression,
you need to do a variable substitution

00:10:43.010 --> 00:10:44.610
at runtime before you use it.

00:10:44.880 --> 00:10:48.440
And you get an instance of a fetch
request from the template from the

00:10:48.440 --> 00:10:53.250
model using fetch request from template
with name set substitution variables.

00:10:53.260 --> 00:10:56.700
And one thing to note is
that these fetch requests,

00:10:56.700 --> 00:11:01.060
the predicates will be evaluated
in the store where possible.

00:11:01.060 --> 00:11:02.400
So if you have an SQL light,
you can do that.

00:11:02.400 --> 00:11:05.100
If you have a SQL light store,
the predicate will actually be

00:11:05.100 --> 00:11:08.630
translated down into a where clause,
which SQL light will actually run.

00:11:08.640 --> 00:11:10.910
Some of the other stores
actually do in-memory queries.

00:11:13.770 --> 00:11:19.510
Configuration is essentially a named
collection of NSEntity descriptions.

00:11:19.540 --> 00:11:22.100
It's typically mapped to
a single persistent store.

00:11:22.260 --> 00:11:25.000
This collection of entities
is mapped to this store.

00:11:25.020 --> 00:11:27.740
This other collection of
entities is mapped to this store.

00:11:27.740 --> 00:11:33.120
Something to note is that a single entity
can belong to multiple configurations.

00:11:33.120 --> 00:11:36.510
So you can get instances,
managed objects of a given

00:11:36.510 --> 00:11:38.780
entity from multiple stores.

00:11:38.780 --> 00:11:41.750
I can pull an address from
LDAP or from AddressBook.

00:11:41.760 --> 00:11:46.580
I can get a song in my playlist
from my local repository,

00:11:46.680 --> 00:11:52.990
or it can be something I pulled
from a rendezvous store.

00:11:54.800 --> 00:11:57.100
The programmatic interaction with
models is actually pretty simple.

00:11:57.100 --> 00:12:01.080
If you want to load a model,
we have NSManagedObjectModel

00:12:01.600 --> 00:12:03.940
init with contents of URL.

00:12:03.940 --> 00:12:08.360
Sometimes you want to merge multiple
models that exist in multiple frameworks.

00:12:08.460 --> 00:12:13.450
We have init with contents of
URL and then model by merging models.

00:12:13.520 --> 00:12:17.430
Something to note is that this will
get a little bit upset if you have

00:12:17.870 --> 00:12:19.510
multiple entities with the same name.

00:12:19.510 --> 00:12:25.400
But if you have configurations
with the same name in each model,

00:12:25.400 --> 00:12:31.070
the entities in those configurations will
be merged into one uber configuration.

00:12:32.500 --> 00:12:35.740
Programatically creating
a model is very simple.

00:12:35.740 --> 00:12:38.190
It just takes a lot of steps.

00:12:39.310 --> 00:12:43.280
First thing you're going to want to do
probably is create an entity description.

00:12:43.350 --> 00:12:45.720
Here we're creating an album.

00:12:45.750 --> 00:12:48.220
You set the name on it to album.

00:12:48.720 --> 00:12:51.880
Most albums have attributes,
so we're going to give this one a title.

00:12:52.010 --> 00:12:55.590
Just create an attribute description,
set its name to title,

00:12:55.700 --> 00:12:57.870
set its type to string.

00:13:00.400 --> 00:13:03.200
Create a song,
since albums usually have songs.

00:13:03.500 --> 00:13:05.120
It's another entity.

00:13:05.120 --> 00:13:08.180
Just give it a name.

00:13:08.260 --> 00:13:10.150
Create a relationship.

00:13:12.210 --> 00:13:19.660
The entity comes from the entity album
and sets the destination entity songs.

00:13:19.660 --> 00:13:22.690
This means that we're creating a
relationship from the album to songs.

00:13:22.690 --> 00:13:25.040
An album has multiple songs.

00:13:25.040 --> 00:13:28.200
Set the relationship.

00:13:28.200 --> 00:13:32.740
Set the properties on the album.

00:13:35.420 --> 00:13:40.340
Set the entities in the model,
and now you've got a really simple model.

00:13:40.350 --> 00:13:43.840
Has two entities, couple of attributes,
doesn't do much.

00:13:43.840 --> 00:13:46.610
And it's actually a lot of code,
even though none of it's

00:13:46.640 --> 00:13:47.580
terribly complicated.

00:13:47.580 --> 00:13:51.220
So we're going to bring
Chris Hansen up on stage to show

00:13:51.220 --> 00:13:53.930
you why it's not actually as
scary as you might think it is.

00:13:54.020 --> 00:14:04.510
CHRIS HANSEN: Can we go to demo one?

00:14:14.250 --> 00:14:15.160
Can we go to demo?

00:14:15.160 --> 00:14:17.190
There we go.

00:14:17.240 --> 00:14:18.500
Thanks, Melissa.

00:14:18.780 --> 00:14:23.950
So what I'm going to show you is a
conversion of an existing application,

00:14:23.970 --> 00:14:26.720
an existing Cocoa document-based
application,

00:14:26.760 --> 00:14:28.300
to use Core Data.

00:14:28.320 --> 00:14:31.210
I'm going to show you how it's
actually pretty easy to take

00:14:31.260 --> 00:14:35.440
your existing software and bring
it forward to the new world.

00:14:35.760 --> 00:14:39.460
So I have a lot of books,
and I like to lend them to my friends.

00:14:39.480 --> 00:14:44.380
But I need to keep track of what I lend,
because otherwise I'll just forget.

00:14:44.430 --> 00:14:47.210
And then my library will get smaller.

00:14:47.980 --> 00:14:50.360
So I have this little
lending library application,

00:14:50.360 --> 00:14:53.000
as soon as X comes up here.

00:14:53.040 --> 00:14:55.380
And it's very simple.

00:14:55.410 --> 00:14:58.630
I'll just start it building
now and walk through the code.

00:14:58.650 --> 00:15:03.080
It's a simple Cocoa document-based
application that has just a couple

00:15:03.080 --> 00:15:10.170
of very simple model objects,
book and friend, and the document itself.

00:15:12.150 --> 00:15:15.380
persists using data
representation of type and load

00:15:15.500 --> 00:15:20.630
data representation of type,
just using NSKey to archiving.

00:15:22.290 --> 00:15:23.220
Bigger font size.

00:15:23.410 --> 00:15:25.960
Got it.

00:15:25.980 --> 00:15:27.760
Text editing.

00:15:35.930 --> 00:15:38.040
Sorry about that.

00:15:38.130 --> 00:15:39.450
Syntax coloring.

00:15:39.450 --> 00:15:43.200
Monaco, what do we say, 14.

00:15:43.200 --> 00:15:45.850
Bigger than that?

00:15:45.890 --> 00:15:48.220
Bigger?

00:15:48.850 --> 00:15:50.060
Okay.

00:15:50.060 --> 00:15:53.580
That was 18.

00:15:58.130 --> 00:16:01.370
There we go.

00:16:01.600 --> 00:16:04.040
So its persistence is
really simple right now.

00:16:04.040 --> 00:16:07.180
We're just adding a couple--
we're just adding our objects,

00:16:07.180 --> 00:16:11.560
our two arrays of books and
friends to a dictionary,

00:16:11.560 --> 00:16:15.530
and then writing that dictionary
out using keyed archiving.

00:16:17.040 --> 00:16:19.160
The first step in
bringing this forward is,

00:16:19.160 --> 00:16:21.880
of course, to duplicate the project.

00:16:21.940 --> 00:16:26.790
So I'll just make a copy of this
and open up the new project.

00:16:27.150 --> 00:16:30.670
And then I need to actually make a
model for Core Data to work from.

00:16:30.760 --> 00:16:35.830
So what I'm going to do is
add a new group called Models.

00:16:36.490 --> 00:16:38.640
And then add a new file to that group.

00:16:38.720 --> 00:16:44.840
And that new file is going
to be a design data model.

00:16:44.920 --> 00:16:47.910
I'm just going to name
it Lending Library.

00:16:49.340 --> 00:16:53.180
And here I get to pick
classes to add to that model.

00:16:53.360 --> 00:16:57.280
So I'm just going to pick book
and friend and add all the classes

00:16:57.310 --> 00:16:58.760
that are in those header files.

00:16:58.820 --> 00:17:04.230
And I get a model.

00:17:08.460 --> 00:17:12.360
And if I show the class browser here,
or the model browser,

00:17:12.430 --> 00:17:15.990
I just went to Design,
chose Show Model Browser.

00:17:16.080 --> 00:17:19.080
And let's see,
I'll kick this up for you too.

00:17:21.690 --> 00:17:27.640
We can see that it picked up the
actual types of the attributes and

00:17:27.640 --> 00:17:31.260
even the type of the relationship
by picking the destination.

00:17:31.290 --> 00:17:35.200
However,
that relationship is named toFriend,

00:17:35.200 --> 00:17:37.340
and in the actual file here,

00:17:37.820 --> 00:17:41.350
It's called Lent2,
so I'm just going to go back here,

00:17:41.550 --> 00:17:45.110
and I'm going to change this to Lent2.

00:17:49.240 --> 00:17:55.820
Now,
we also can see that here it's actually

00:17:55.840 --> 00:17:58.690
set the class names appropriately.

00:17:58.800 --> 00:18:05.390
So these model objects will be backed
up by instances of these classes.

00:18:05.680 --> 00:18:07.680
However,
right now these classes just descend

00:18:07.760 --> 00:18:10.460
from NSObject and implement NSCoding.

00:18:10.580 --> 00:18:12.950
Since Core Data is going to manage
all of our persistence and all

00:18:12.950 --> 00:18:15.260
of our change tracking for us,
we don't really want to

00:18:15.260 --> 00:18:16.500
descend from NSObject anymore.

00:18:16.500 --> 00:18:20.500
We want to descend from NSManagedObject.

00:18:20.550 --> 00:18:23.500
And since ManagedObject handles
all of our persistence for us,

00:18:23.500 --> 00:18:25.500
we don't need to use
NSCoding anymore either.

00:18:25.500 --> 00:18:29.500
So we can actually get
rid of these attributes,

00:18:29.660 --> 00:18:32.630
and we can even get rid
of this relationship,

00:18:33.120 --> 00:18:35.390
I'm going to get rid of
a couple of accessors,

00:18:35.390 --> 00:18:37.490
and I can even get rid of
that relationship accessor,

00:18:37.500 --> 00:18:39.780
because everything in our interface
is going to be done through

00:18:39.780 --> 00:18:40.760
bindings and key value coding.

00:18:40.780 --> 00:18:46.250
Now I can also get rid of my DLX method,
because I have no more

00:18:46.250 --> 00:18:47.910
storage to manage myself.

00:18:48.250 --> 00:18:50.690
Core Data manages all that for you.

00:18:51.160 --> 00:18:56.360
I'm going to convert my setAuthor method
to show you how you might want to do

00:18:56.360 --> 00:19:01.190
this in your own applications to use
what we call primitive key value coding.

00:19:01.370 --> 00:19:05.600
So the first thing I need to do is,
in setAuthor,

00:19:05.630 --> 00:19:11.860
I need to inform the rest of the system
that we're going to change the object.

00:19:11.960 --> 00:19:18.610
So I'm going to just say self will
change value for key of author.

00:19:20.680 --> 00:19:26.990
Then I'm going to actually do a self-set
primitive... didn't complete for me...

00:19:34.130 --> 00:19:39.270
Set primitive value for key will actually
call into our superclass implementation,

00:19:39.290 --> 00:19:42.950
which manages all the storage for us,
and do the right thing for both

00:19:42.950 --> 00:19:44.120
attributes and relationships.

00:19:44.140 --> 00:19:45.370
It checks against the entity.

00:19:45.380 --> 00:19:47.560
And finally,
I'm going to tell the system that

00:19:47.640 --> 00:19:49.380
we did change the value for key.

00:19:54.140 --> 00:19:58.290
And this way, if your application uses
your accessor methods,

00:19:58.440 --> 00:20:01.080
you don't have to get rid of them
and just go through key value coding.

00:20:01.300 --> 00:20:02.680
You can still use your accessor methods.

00:20:02.680 --> 00:20:09.330
You can just make them a lot simpler
and act as covers for primitive KVC.

00:20:09.730 --> 00:20:11.750
And I need to do the
same thing in author.

00:20:12.030 --> 00:20:15.990
I just need to say a string author.

00:20:18.600 --> 00:20:21.840
will access ValueForKey.

00:20:21.840 --> 00:20:28.760
This tells the framework that we're
going to start accessing that key,

00:20:28.760 --> 00:20:30.780
so if it needs to pull
anything into memory,

00:20:30.780 --> 00:20:33.570
if it needs to fire any faults,
that will happen.

00:20:35.230 --> 00:20:41.110
Then we say author equals
self primitive value for key.

00:20:42.680 --> 00:20:45.360
to actually get the data.

00:20:45.410 --> 00:20:48.750
Then we say self did
access value for key.

00:20:48.960 --> 00:20:51.490
There's a lot of symmetry
in this framework.

00:20:57.260 --> 00:21:00.080
and finally we return the
value that we retrieved.

00:21:00.140 --> 00:21:03.230
But if you're just
using key value coding,

00:21:03.230 --> 00:21:05.100
key value coding will
do all of this for you.

00:21:05.170 --> 00:21:08.490
So you don't need to actually
even have these accessors.

00:21:08.490 --> 00:21:10.800
If your entire interface is
built through bindings and

00:21:10.800 --> 00:21:12.970
you're using key value coding,
you're fine.

00:21:12.970 --> 00:21:17.430
And this works both for
attributes and for relationships.

00:21:19.360 --> 00:21:23.210
And finally, we also don't need our
NS coding support anymore,

00:21:23.210 --> 00:21:27.740
because all of our persistence
is being handled by Core Data.

00:21:27.820 --> 00:21:30.020
And we can do the same
thing to our friend object.

00:21:30.060 --> 00:21:32.670
We can just convert it to superclass.

00:21:35.210 --> 00:21:36.880
Get rid of its IVARs.

00:21:37.010 --> 00:21:39.900
Get rid of its accessors.

00:21:40.000 --> 00:21:43.540
And, well, let's see.

00:21:43.540 --> 00:21:46.100
Pretty much get rid
of all the code in it.

00:21:55.250 --> 00:21:57.390
Now we only have a
couple more things to do.

00:21:57.440 --> 00:21:58.910
I think three more things.

00:21:58.920 --> 00:22:02.760
First, we need-- since Core Data is
managing our persistence,

00:22:02.810 --> 00:22:06.550
we can also get rid of the instance
variables that we're using to store

00:22:06.860 --> 00:22:10.110
our collections of books and friends.

00:22:10.530 --> 00:22:13.260
In our document,
we just need to tell it that

00:22:13.310 --> 00:22:17.980
it's not an NS document anymore,
it's an NS persistent document.

00:22:19.880 --> 00:22:21.940
We don't need these anymore
because everything's going to be

00:22:21.940 --> 00:22:24.440
accessed via key-value coding,
and same with these.

00:22:24.440 --> 00:22:31.420
And of course,
we can delete the implementations, too.

00:22:31.420 --> 00:22:32.590
So...

00:22:38.620 --> 00:22:41.420
We don't need to actually handle
our own persistence anymore,

00:22:41.420 --> 00:22:43.800
so we can delete these.

00:22:43.850 --> 00:22:48.600
And finally, since we don't have any
more IVARs to memory manage,

00:22:48.610 --> 00:22:51.940
we can delete init and dialog, too.

00:22:51.970 --> 00:22:54.790
So this is our new document subclass.

00:23:00.900 --> 00:23:03.060
Now we only have two more steps.

00:23:03.160 --> 00:23:06.530
Our first step is to go in and--

00:23:06.600 --> 00:23:08.210
Change the type of
document that we handle.

00:23:08.370 --> 00:23:10.720
Right now, I'm just handling a document
type of lending lib.

00:23:10.720 --> 00:23:14.920
I'm going to change that
to XML so Core Data knows

00:23:15.010 --> 00:23:17.470
to use the XML persistence.

00:23:19.240 --> 00:23:21.180
And then I'm going to go
and make a couple minor

00:23:21.180 --> 00:23:23.760
modifications to my nib file.

00:23:23.990 --> 00:23:27.640
Our nib file still has some knowledge
about the classes that we were using,

00:23:27.640 --> 00:23:28.880
and we need to update it.

00:23:28.980 --> 00:23:30.530
So our nib file is very simple.

00:23:30.610 --> 00:23:33.960
It's just a simple two-tab interface
with a couple of table views,

00:23:33.970 --> 00:23:35.580
all set up using bindings.

00:23:35.580 --> 00:23:40.580
This application would run fine on
Panther before moving it to Core Data.

00:23:42.850 --> 00:23:45.300
We don't actually need to do
anything with the table views.

00:23:45.310 --> 00:23:48.800
All we need to do is modify
our array controllers.

00:23:49.070 --> 00:23:54.560
So our array controllers right now
point to a class and a class name.

00:23:54.880 --> 00:24:00.390
We're going to change them to point
to an entity and an entity name.

00:24:02.110 --> 00:24:08.460
So friends points to the friend entity,
and books points to the book entity.

00:24:10.050 --> 00:24:13.160
And then we're going to set
one additional binding on

00:24:13.160 --> 00:24:14.860
each of the array controllers.

00:24:14.880 --> 00:24:16.790
This binding-- well,
and we're going to remove

00:24:16.820 --> 00:24:18.840
the content array binding,
because we're not actually getting

00:24:18.840 --> 00:24:20.600
the content from the document anymore.

00:24:20.640 --> 00:24:23.570
Instead,
we're going to connect the binding

00:24:23.850 --> 00:24:27.850
on each of the array controllers
for its managed object context.

00:24:31.320 --> 00:24:34.520
And that comes from our document.

00:24:34.530 --> 00:24:39.210
Every persistent document has a managed
object context and actually also has

00:24:39.220 --> 00:24:41.000
its own persistent store coordinator.

00:24:41.050 --> 00:24:44.640
So that handles all of your change
tracking for you automatically.

00:24:44.640 --> 00:24:47.570
So I just did that for books.

00:24:47.680 --> 00:24:49.920
Let me go do that for friends.

00:24:50.010 --> 00:24:54.140
Actually, just object context.

00:24:55.200 --> 00:25:02.250
Context, bind, get rid of content array,
save.

00:25:06.050 --> 00:25:07.890
And we're set.

00:25:07.990 --> 00:25:10.250
So now I'll just build and run this one.

00:25:10.350 --> 00:25:12.610
Actually, while I'm building this,

00:25:15.230 --> 00:25:15.980
I'll run the original.

00:25:16.040 --> 00:25:22.280
And as you can see,
it's just a very simple

00:25:22.330 --> 00:25:23.660
document-based app.

00:25:23.910 --> 00:25:31.450
Can add an author of a book I have,
say John Brenner, the shockwave writer.

00:25:33.440 --> 00:25:38.770
I can add another book that I have,
Douglas Adams.

00:25:40.940 --> 00:25:43.460
The Hitchhiker's Guide.

00:25:43.500 --> 00:25:48.150
And I can add a couple of my friends,
Ben and their phone numbers in

00:25:48.240 --> 00:25:51.710
case I need to contact them because
I need a book back really quickly.

00:25:53.210 --> 00:25:54.710
and Melissa.

00:25:54.810 --> 00:25:55.900
These aren't their real phone numbers.

00:25:55.950 --> 00:25:58.240
Don't try them.

00:25:58.240 --> 00:26:01.480
And I can see that in my Lent 2 pop-up,
I can set, oh,

00:26:01.480 --> 00:26:05.850
while I lent Ben the Shockwave writer,
I lent Melissa Hitchhiker's

00:26:06.010 --> 00:26:07.490
Guide to the Galaxy.

00:26:08.980 --> 00:26:10.940
And notice what we don't get.

00:26:10.940 --> 00:26:17.280
If I add another book, say, Weinberger,
The Clue Train,

00:26:18.040 --> 00:26:20.490
Manifesto, and I want to undo that.

00:26:20.810 --> 00:26:24.730
I can undo the typing in there because
that's handled by the text subsystem.

00:26:24.730 --> 00:26:29.220
But I can't undo anything in the actual
document because I haven't written

00:26:29.290 --> 00:26:31.730
any undo code for this application.

00:26:33.150 --> 00:26:35.460
But this is the old version.

00:26:35.490 --> 00:26:37.860
Notice also that I don't
get any document dirtying.

00:26:37.860 --> 00:26:40.700
Again,
I would have had to write code for that.

00:26:40.700 --> 00:26:45.060
I still can save and load documents,
though.

00:26:45.090 --> 00:26:46.700
But let's check the new version.

00:26:46.730 --> 00:26:48.580
If I run this--

00:26:52.400 --> 00:26:59.060
I can start out, I can say John Brunner,
the Shockwave writer.

00:26:59.080 --> 00:27:04.300
I can say Douglas Adams.

00:27:07.340 --> 00:27:20.950
Hitchhiker's Guide.

00:27:20.950 --> 00:27:20.950
I can see that I get all the
same table view behaviors.

00:27:20.950 --> 00:27:20.950
I haven't touched this
part of the interface.

00:27:20.950 --> 00:27:20.950
There's no value for these pop-up menus
because I haven't added any friends yet.

00:27:20.950 --> 00:27:20.950
I can add a couple of friends.

00:27:25.370 --> 00:27:27.770
and they show up in the pop-ups.

00:27:27.860 --> 00:27:32.220
And all of this relationship management,
all of the persistence that's

00:27:32.220 --> 00:27:35.460
going to happen when I hit Save is
going to be handled by Core Data.

00:27:35.690 --> 00:27:37.320
But notice what we also got.

00:27:37.390 --> 00:27:39.580
We also got dirtying.

00:27:39.650 --> 00:27:42.220
The document is now marked as modified.

00:27:42.290 --> 00:27:44.910
So if I just try to close it,
it automatically comes up and

00:27:45.040 --> 00:27:46.990
asks me if I want to save.

00:27:48.020 --> 00:27:49.840
So I'm just going to
save this on the desktop.

00:27:49.840 --> 00:27:54.710
I'll just call it My Library.

00:28:00.500 --> 00:28:03.180
I rerun the app.

00:28:03.180 --> 00:28:04.070
I choose Open.

00:28:04.080 --> 00:28:06.820
I go to the desktop.

00:28:06.830 --> 00:28:09.320
I open that up,
and everything's in there.

00:28:09.330 --> 00:28:12.530
So it's just round
trip through Core Data.

00:28:19.200 --> 00:28:22.320
Now I'm going to try adding
Weinberger's book again,

00:28:22.320 --> 00:28:28.760
Weinberger, the Kluetrain Manifesto.

00:28:28.760 --> 00:28:29.840
But I lost that book.

00:28:29.840 --> 00:28:31.360
It's not in my library anymore.

00:28:31.360 --> 00:28:33.590
So I'm just going to undo.

00:28:34.190 --> 00:28:36.980
I can undo that, and I can undo that.

00:28:37.160 --> 00:28:41.460
And then I can go up here, and I can see,
oh, I can redo those insertions.

00:28:41.600 --> 00:28:45.610
So I just redid the add of that record.

00:28:46.200 --> 00:28:49.000
Now I redid the update of that record,
and now I redid the

00:28:49.000 --> 00:28:49.800
update of that record.

00:28:49.820 --> 00:28:51.860
And that all came for free
just by using Core Data.

00:28:51.860 --> 00:29:00.250
So now I'm going to turn it over to Ben,
who's going to tell

00:29:00.250 --> 00:29:01.240
you a little bit more.

00:29:11.200 --> 00:29:11.760
Good morning.

00:29:11.800 --> 00:29:13.960
My name is Ben Trumbull,
and I'm one of the senior engineers

00:29:13.960 --> 00:29:16.600
with Chris and Melissa in the
Development Technologies Group at Apple.

00:29:16.600 --> 00:29:19.110
And I'm going to talk to you
today about the two classes that

00:29:19.110 --> 00:29:22.220
you'll probably interact with the
most in the Core Data framework.

00:29:22.430 --> 00:29:24.200
And the first is NSManagedObject.

00:29:24.300 --> 00:29:26.280
If you take something
away from this session,

00:29:26.280 --> 00:29:29.460
if you're looking for a noun
to work with from Core Data,

00:29:29.460 --> 00:29:30.860
you'll probably find it here.

00:29:32.660 --> 00:29:36.480
So NSMagic objects are
instances of an entity.

00:29:36.530 --> 00:29:39.560
And they always have an entity
description in the same way that

00:29:39.640 --> 00:29:41.320
a Cocoa object always has a class.

00:29:41.530 --> 00:29:44.190
So it's the data equivalent.

00:29:44.340 --> 00:29:45.540
They're a generic data object.

00:29:45.540 --> 00:29:47.850
So as Chris showed you,
you don't need to use storage.

00:29:48.120 --> 00:29:51.550
You can just have it go through and
magically will manage the memory for you.

00:29:51.580 --> 00:29:55.200
You can use key value coding to access
those fields and get back the values.

00:29:55.270 --> 00:29:57.500
It's a basic unit that you're
going to be working with.

00:29:57.500 --> 00:29:59.580
These are the objects
that you push around.

00:29:59.610 --> 00:30:03.020
You fetch, insert, change, save,
et cetera.

00:30:03.060 --> 00:30:07.350
And they all implement key value
coding and key value observing for you.

00:30:08.670 --> 00:30:11.320
The fundamentals is each instance
is described by a single entity

00:30:11.390 --> 00:30:12.760
and has a reference to it.

00:30:12.760 --> 00:30:16.190
Each one has a unique object ID,
and each one is associated with

00:30:16.190 --> 00:30:21.140
a single managed object context,
which we'll get more to later.

00:30:21.140 --> 00:30:24.060
It's important to note that each managed
object can only be used by a single

00:30:24.070 --> 00:30:26.130
managed object context at a time.

00:30:26.180 --> 00:30:28.400
And subclasses can
implement custom logic.

00:30:28.400 --> 00:30:32.120
As you saw in the demo that Chris did,
a lot of times you don't really need

00:30:32.120 --> 00:30:34.110
any custom logic in your subclasses.

00:30:34.110 --> 00:30:36.130
You don't have to have the subclass.

00:30:36.210 --> 00:30:39.500
You can just say in your nib or whatnot
that you're going to use the entity,

00:30:39.500 --> 00:30:42.450
and we'll automatically just
use the generic superclass,

00:30:42.480 --> 00:30:45.590
and it'll get all the behavior
for you as long as you don't need

00:30:45.590 --> 00:30:47.950
any accessors or anything custom.

00:30:48.700 --> 00:30:51.870
So to take a brief tangent,
it's interesting to note that the

00:30:51.870 --> 00:30:56.090
IDs that are unique for each managed
object are objects in and of themselves.

00:30:56.200 --> 00:30:59.440
And they're an instance
of NSManagedObjectID.

00:30:59.500 --> 00:31:04.380
And one useful feature of this is that
different managed objects with the same

00:31:04.380 --> 00:31:06.580
ID refer to the same persistent data.

00:31:06.670 --> 00:31:09.540
So if you have two objects and
they have equivalent object IDs,

00:31:09.590 --> 00:31:12.690
then they refer to the same
XML node and an XML file or the

00:31:12.700 --> 00:31:15.670
same row in an SQLite database.

00:31:17.200 --> 00:31:19.550
So one of the things that you
can implement either in the model

00:31:19.600 --> 00:31:21.390
or in a subclass is validation.

00:31:21.490 --> 00:31:24.450
And the managed objects do
validation upon themselves.

00:31:24.630 --> 00:31:27.820
These validation callbacks
are invoked at save time.

00:31:27.920 --> 00:31:32.460
So you'll get a callback for deletion,
insertion, or updates.

00:31:32.550 --> 00:31:37.590
And you can also validate
on individual properties.

00:31:37.680 --> 00:31:39.100
I have lost my formatting.

00:31:39.250 --> 00:31:42.000
But at the very bottom there,
you'll see Validate Key.

00:31:42.080 --> 00:31:45.330
And key here is not the method name,
but the name of the property

00:31:45.400 --> 00:31:46.150
that you're validating.

00:31:46.160 --> 00:31:48.880
So in the previous example,
you might have Validate

00:31:48.930 --> 00:31:51.100
Book or Validate Friend.

00:31:51.160 --> 00:31:53.700
And you can just go through
in your subclass to validate

00:31:53.700 --> 00:31:55.810
on an individual property.

00:31:57.070 --> 00:32:01.530
Other useful managed object callbacks are
Awake from Fetch and Awake from Insert.

00:32:01.720 --> 00:32:05.600
Here's a great place for you to
initialize transient properties or to set

00:32:05.680 --> 00:32:11.210
up any caches or do any calculations that
you want to set aside for the object.

00:32:11.370 --> 00:32:14.440
And two other callbacks for
you are WillSave and DidSave.

00:32:14.510 --> 00:32:17.340
And a subclass can do
something interesting here.

00:32:17.620 --> 00:32:20.920
The Awake methods are
generally more useful,

00:32:20.920 --> 00:32:23.170
just to set up initialization.

00:32:23.900 --> 00:32:26.550
So to talk a little bit more
about primitive key value coding,

00:32:26.550 --> 00:32:29.440
these are the methods you use
to implement custom accessors,

00:32:29.440 --> 00:32:30.540
setters and getters.

00:32:30.540 --> 00:32:33.920
There's a primitive value for key
and a set primitive value for key.

00:32:33.920 --> 00:32:38.140
They're only for your use in the
implementation of an accessor method.

00:32:38.140 --> 00:32:41.110
The framework uses them to
do low-level initialization,

00:32:41.110 --> 00:32:43.390
to do bit shuffling, and stuff like that.

00:32:43.760 --> 00:32:46.000
They don't go through the
regular key value coding,

00:32:46.230 --> 00:32:48.170
and they don't perform
any kind of validation,

00:32:48.170 --> 00:32:49.760
any kind of argument checking.

00:32:49.760 --> 00:32:51.710
They assume you kind of
know what you're doing.

00:32:51.720 --> 00:32:54.940
So they're fairly low-level,
and they don't manage any of

00:32:54.940 --> 00:32:57.060
the integrity for relationships.

00:33:02.500 --> 00:33:06.770
To create a managed object,
typically you'll just do a fetch.

00:33:06.820 --> 00:33:10.330
As you saw in Chris's example,

00:33:10.480 --> 00:33:13.250
When he opened up the document,
they just come up for you,

00:33:13.250 --> 00:33:16.420
and they're automatically created for
you and registered with their context.

00:33:16.550 --> 00:33:20.620
If you want to create a new one,
you just alloc insertWithEntity

00:33:20.800 --> 00:33:22.430
and give it an entity.

00:33:22.590 --> 00:33:25.630
And after that,
you pass it to its context,

00:33:25.630 --> 00:33:27.220
and you say insert object.

00:33:27.350 --> 00:33:30.070
One other thing you can do is if
you decide to use Core Data without

00:33:30.200 --> 00:33:33.810
its native persistence mechanism,
you can use your own persistence

00:33:33.880 --> 00:33:37.290
mechanism or use the NSCoding
behavior you already have,

00:33:37.300 --> 00:33:41.780
and just use the context to do
change tracking and do the undo/redo,

00:33:42.010 --> 00:33:44.300
and you can do the saving yourself.

00:33:44.330 --> 00:33:47.800
In this case, you can use registered
object to tell the context,

00:33:47.810 --> 00:33:48.960
this isn't a new object.

00:33:48.960 --> 00:33:50.760
It doesn't need to be
inserted into the data file.

00:33:50.840 --> 00:33:53.520
You've pulled it off from some
other data store somewhere,

00:33:53.530 --> 00:33:57.110
and you just want it to know
about the object to track changes.

00:34:00.620 --> 00:34:04.150
So the NSManage objects
have all the nouns.

00:34:04.210 --> 00:34:05.500
They have the entity description.

00:34:05.500 --> 00:34:06.700
They have the object ID.

00:34:06.740 --> 00:34:09.320
They have all the data
from the data store.

00:34:09.580 --> 00:34:13.490
The verbs live here in the
NSManage object context.

00:34:15.040 --> 00:34:17.450
So this section, a lot goes on here.

00:34:17.530 --> 00:34:19.600
So we have a little preview.

00:34:19.790 --> 00:34:21.240
So we're going to talk
about fundamentals.

00:34:21.380 --> 00:34:25.990
I have a slide on fetching, inserting,
deleting, updating, saving, reverting,

00:34:26.150 --> 00:34:29.700
notifications, memory management,
and threading.

00:34:29.740 --> 00:34:33.200
Like I said, a lot of verbs with the
Manage Object context.

00:34:33.910 --> 00:34:38.630
So this is the primary center
of the framework for your use.

00:34:38.640 --> 00:34:41.380
It initiates all the actions,
and it does all the heavy

00:34:41.510 --> 00:34:43.280
lifting for the change tracking.

00:34:43.350 --> 00:34:46.130
It performs retrieval of the
objects from the external store.

00:34:46.200 --> 00:34:48.140
It does the saving and
the reverting of changes.

00:34:48.140 --> 00:34:49.660
It implements undo and redo.

00:34:49.710 --> 00:34:52.490
It propagates the deletes
and maintains the inverses.

00:34:52.660 --> 00:34:55.790
And the exact behavior of the delete
propagation and whatnot happens

00:34:55.960 --> 00:34:59.700
based on what you've set in your
model in the energy description.

00:34:59.780 --> 00:35:02.520
And it also is involved at the
center of all the activities.

00:35:02.590 --> 00:35:06.900
So it's the one that posts the
notifications and does the callbacks.

00:35:06.940 --> 00:35:08.540
For fetching--

00:35:08.760 --> 00:35:10.450
It's a little small,
but there's an execute

00:35:10.550 --> 00:35:11.830
fetch request method.

00:35:11.910 --> 00:35:15.280
And you just pass it a fetch request,
and the managed object context goes

00:35:15.390 --> 00:35:19.300
off and figures out who to pass that
request to to have it fulfilled.

00:35:19.330 --> 00:35:22.780
The only mandatory part of a
fetch request is the entity,

00:35:22.800 --> 00:35:24.880
and everything else will
do a useful default.

00:35:24.920 --> 00:35:27.760
One important feature to note
is that the context will merge

00:35:27.760 --> 00:35:30.370
in changes that are pending,
that haven't been saved out,

00:35:30.370 --> 00:35:31.920
into the results of the fetch.

00:35:32.020 --> 00:35:34.950
So if you have a bunch of inserted
objects and a bunch of deleted objects,

00:35:34.960 --> 00:35:37.930
and you execute a fetch,
if the predicate that describes

00:35:37.940 --> 00:35:40.630
the search you're doing
matches the insert objects,

00:35:40.680 --> 00:35:43.060
those will get included in
the results you get back.

00:35:43.070 --> 00:35:45.040
And the deleted objects will be excluded.

00:35:45.050 --> 00:35:49.360
And changed objects will
be included if they match.

00:35:49.400 --> 00:35:53.170
But if you change an
object so it's no longer

00:35:53.300 --> 00:35:57.350
True, when it values to the predicate,
then it will be excluded as well.

00:35:57.370 --> 00:36:00.870
And you can always create a
new managed context and do

00:36:00.940 --> 00:36:04.750
the fetch directly with that,
or you can do a reset.

00:36:05.610 --> 00:36:09.600
So walk through a little
bit the fetch control flow.

00:36:09.740 --> 00:36:13.680
In this diagram here,
A is the fetch request.

00:36:13.790 --> 00:36:17.970
Turns out graphic artists are very,
very literal.

00:36:18.070 --> 00:36:18.670
Yes.

00:36:18.760 --> 00:36:22.660
So you create the fetch request,
and you pass it to the

00:36:22.760 --> 00:36:24.500
NSManageObject context.

00:36:24.560 --> 00:36:27.140
It takes the fetch request,
it does some work with it,

00:36:27.200 --> 00:36:30.520
and then it passes it to its
persistent store coordinator.

00:36:30.670 --> 00:36:32.560
Then the Persistent
Store Coordinator figures out

00:36:32.610 --> 00:36:38.080
which object stores have the
relevant data and passes it off.

00:36:38.610 --> 00:36:40.910
So you can have multiple stores.

00:36:40.940 --> 00:36:42.190
You'll get back some results.

00:36:42.210 --> 00:36:45.160
Each of the stores does the fetch
with its own native mechanism,

00:36:45.260 --> 00:36:51.000
whether it's an SQL query for SQLite or
walking through the XML for an XML file.

00:36:51.010 --> 00:36:53.420
And then the results come back,
and they get collated,

00:36:53.420 --> 00:36:55.640
and it brings them back.

00:36:55.640 --> 00:36:57.680
And they're sorted.

00:36:57.690 --> 00:37:00.710
And the NSManagedObjectContext
merges in the change set so that

00:37:00.900 --> 00:37:05.150
the fetch accurately reflects what
it knows as the state of the world.

00:37:08.570 --> 00:37:10.670
OK, so we've talked a little
bit about inserting.

00:37:10.830 --> 00:37:13.970
All you do is invoke insert object
with your new managed object that

00:37:14.240 --> 00:37:15.930
you alloc and hit it with entity.

00:37:16.080 --> 00:37:20.040
It's best to define the initial values
after you've performed the insertion.

00:37:20.100 --> 00:37:23.660
The reason for this is context only track
changes after they know about objects.

00:37:23.840 --> 00:37:26.020
And they only know about objects
after you've called insert

00:37:26.020 --> 00:37:27.710
object or register object.

00:37:27.870 --> 00:37:31.290
And you won't get the correct undo redo
behavior if you set a whole bunch of

00:37:31.290 --> 00:37:34.490
initial values and then you insert it,
because the managed object context will

00:37:34.500 --> 00:37:37.150
assume that that was the initial state.

00:37:37.490 --> 00:37:41.540
So as you saw in the demo,
you can undo the text edits that way.

00:37:41.610 --> 00:37:44.910
And when you're done,
you'll just have a blank row.

00:37:47.160 --> 00:37:49.530
Deleting an object,
you just pass the managed object

00:37:49.530 --> 00:37:51.240
to delete object on the context.

00:37:51.240 --> 00:37:57.170
The deletes will be propagated through
the relationships that that object has.

00:37:57.330 --> 00:38:00.320
And the exact behavior will depend
on which delete rule you've set.

00:38:00.320 --> 00:38:02.040
We also talked about the
different delete rules,

00:38:02.410 --> 00:38:04.480
nullify, cascade, deny, or no action.

00:38:04.570 --> 00:38:07.170
It's important to note
that if you use no action,

00:38:07.170 --> 00:38:09.940
this means you have assumed
responsibility for maintaining the

00:38:09.940 --> 00:38:11.680
integrity of those relationships.

00:38:11.680 --> 00:38:14.210
So if you've got objects
with pointers to each other,

00:38:14.430 --> 00:38:16.270
and you say no action
when you delete one,

00:38:16.270 --> 00:38:18.630
you're going to get dangling pointers,
and you've promised that

00:38:18.730 --> 00:38:19.530
you will clean that up.

00:38:19.590 --> 00:38:23.140
Another important thing to note is
just because you've deleted an object,

00:38:23.220 --> 00:38:23.780
it's pending.

00:38:23.780 --> 00:38:25.590
This doesn't take effect until you save.

00:38:25.590 --> 00:38:27.160
So this is a perfectly good object.

00:38:27.160 --> 00:38:29.360
You can keep working with it,
asking for data.

00:38:29.540 --> 00:38:30.080
It's valid.

00:38:30.080 --> 00:38:31.430
And you can undo the delete.

00:38:31.430 --> 00:38:33.440
So it's really a pending of a delete.

00:38:35.650 --> 00:38:37.760
A lot of things happen
when the objects change.

00:38:37.760 --> 00:38:40.660
And this is really an overview of
what's going on behind the scenes.

00:38:40.660 --> 00:38:42.650
You don't really have to
worry much about this,

00:38:42.740 --> 00:38:45.450
but this is what the
context is doing for you.

00:38:47.060 --> 00:38:50.530
A key value coding observation
notification gets posted

00:38:50.530 --> 00:38:52.280
by the object itself.

00:38:52.280 --> 00:38:55.060
And the managed object context
receives an internal callback.

00:38:55.060 --> 00:38:58.170
At this time, if it's necessary,
it takes a snapshot of that

00:38:58.170 --> 00:39:01.420
object so it can maintain the
correct undo/redo behavior.

00:39:01.560 --> 00:39:04.540
And then,
it makes sure that the bidirectional

00:39:04.600 --> 00:39:06.830
relationships are maintained.

00:39:06.830 --> 00:39:09.630
And it flags the object as
updated and queues it up.

00:39:09.750 --> 00:39:11.870
It also queues up an end
of event notification.

00:39:12.090 --> 00:39:14.920
So, it tries to minimize the amount
of work it does for each change.

00:39:14.920 --> 00:39:17.310
So if you do a whole bunch
of sets with key value coding

00:39:17.310 --> 00:39:20.570
or with an accessor method,
it doesn't want to take up too much time.

00:39:20.970 --> 00:39:24.170
And it will coalesce things
later at the end of the event.

00:39:24.180 --> 00:39:27.170
So at the end of the run loop,
we get our callback back to ourselves.

00:39:27.170 --> 00:39:29.200
We coalesce all the changes together.

00:39:29.320 --> 00:39:32.200
We push an action,
a single action for each object,

00:39:32.280 --> 00:39:33.860
onto the undo manager stack.

00:39:33.990 --> 00:39:37.920
And we pass up a notification for
you if you want to know about it.

00:39:37.920 --> 00:39:41.530
And that's the point where the bindings
receive some of the notifications.

00:39:41.530 --> 00:39:44.480
And it's one of the points of
integration with the Cocoa bindings.

00:39:44.480 --> 00:39:45.320
Thanks.

00:39:47.010 --> 00:39:49.060
For saving changes,
there's just a save method.

00:39:49.060 --> 00:39:51.460
You can pass in an NSError if
you want to find out what

00:39:51.460 --> 00:39:55.300
happens when things go wrong,
if things go wrong.

00:39:55.340 --> 00:39:58.120
And this is the same
control flow as the fetch,

00:39:58.130 --> 00:40:00.010
except you don't get any results back.

00:40:00.050 --> 00:40:03.160
We group all the insertions together
and the deletions and the updates.

00:40:03.220 --> 00:40:05.280
We pass it to the persistent
store coordinator,

00:40:05.390 --> 00:40:08.330
and the persistent store coordinator
figures out where everything goes.

00:40:08.460 --> 00:40:10.570
And then each store writes it out.

00:40:11.380 --> 00:40:14.740
So reverting changes,
you can use the rollback method.

00:40:14.740 --> 00:40:18.370
This just does a simple revert and
restores all the objects to their

00:40:18.410 --> 00:40:21.380
state before they were-- sorry,
the same state they had

00:40:21.380 --> 00:40:22.670
when they were last saved.

00:40:22.740 --> 00:40:24.410
So this will throw away insertions.

00:40:24.540 --> 00:40:25.940
It'll undo changes.

00:40:26.210 --> 00:40:30.240
And deleted objects will now go
back to their previous normal state.

00:40:30.410 --> 00:40:32.590
You can also do a reset.

00:40:32.670 --> 00:40:35.390
So the reset will basically take
this context and flush it and

00:40:35.630 --> 00:40:37.020
restore it to its initial state.

00:40:37.220 --> 00:40:39.380
It'll forget about all
the objects it's seen.

00:40:39.450 --> 00:40:41.570
And you can just reuse it.

00:40:41.820 --> 00:40:44.210
It's useful if the context belongs
to something else like the nib.

00:40:44.400 --> 00:40:46.210
And you don't want to
replace it with a new one.

00:40:46.340 --> 00:40:48.720
But it's a similar effect
to just creating a new one.

00:40:48.740 --> 00:40:52.040
And it also has the
undo and redo methods.

00:40:52.070 --> 00:40:53.520
These use the NSUndoManager.

00:40:53.670 --> 00:40:56.560
You can get a hold of the Manage
Object Context UndoManager and

00:40:56.560 --> 00:40:59.620
customize its own behavior,
like set levels of undo or

00:40:59.620 --> 00:41:03.370
throw away all the actions,
remove all actions.

00:41:03.720 --> 00:41:08.000
So it's just integration with the
default foundation NSUndoManager.

00:41:09.140 --> 00:41:10.640
notifications.

00:41:10.740 --> 00:41:12.760
The one that's most
useful is the first one,

00:41:12.790 --> 00:41:15.720
the objects changed in managing context.

00:41:15.770 --> 00:41:17.620
And this happens at the end of the event.

00:41:17.670 --> 00:41:20.680
After we've done all the changes and
we've coalesced everything together,

00:41:20.680 --> 00:41:25.480
you can find out what other people
have done to your soup of objects.

00:41:25.730 --> 00:41:28.540
Then when you do a save,
after the save operation is successful,

00:41:28.540 --> 00:41:29.940
we post this notification.

00:41:30.030 --> 00:41:32.880
The Managed Context did
save changes notification.

00:41:32.880 --> 00:41:35.450
And that might be useful if
you want to know who's been

00:41:35.450 --> 00:41:37.340
committing changes to the file.

00:41:37.360 --> 00:41:40.510
The User Info Dictionary has the same
structure for both these notifications.

00:41:40.600 --> 00:41:45.680
There's an inserted key, lowercase i,
updated and deleted keys.

00:41:45.690 --> 00:41:48.480
And both these keys map to a value,
which is an NSSet.

00:41:48.520 --> 00:41:51.940
And the set contains all of the
managed objects that are inserted,

00:41:52.040 --> 00:41:53.460
updated, or deleted.

00:41:53.490 --> 00:41:55.950
And it's also important to note
that the managed object makes

00:41:55.950 --> 00:41:59.110
themselves individually post key
value observing notifications with

00:41:59.110 --> 00:42:01.150
the normal foundation mechanism.

00:42:02.530 --> 00:42:06.300
So just a brief overview on this.

00:42:06.300 --> 00:42:10.720
We touched briefly in the demo
about faulting and why you have to

00:42:10.720 --> 00:42:14.820
call will access or will change,
followed by did access or did change.

00:42:14.900 --> 00:42:17.590
And that's so that we can do faulting,
where we basically prune

00:42:17.590 --> 00:42:19.400
objects that you're not using.

00:42:19.450 --> 00:42:23.070
And then if there's a relationship
and you want to do something,

00:42:23.150 --> 00:42:26.100
we'll go and we'll fetch it for
you to try to reduce the amount

00:42:26.100 --> 00:42:27.480
of stuff you have in memory.

00:42:27.650 --> 00:42:31.030
This is particularly useful
with the SQLite database.

00:42:31.310 --> 00:42:33.470
So this is analogous to
kind of virtual memory.

00:42:33.620 --> 00:42:34.900
So it's that kind of faulting.

00:42:34.900 --> 00:42:37.460
When we talk about faulting,
it's at a higher level

00:42:37.460 --> 00:42:41.240
than page faulting,
but it's basically the same sense there.

00:42:41.240 --> 00:42:42.790
You don't really have to worry about it.

00:42:42.830 --> 00:42:43.920
It's fairly transparent.

00:42:43.980 --> 00:42:46.740
You touch something,
and we'll bring it into memory.

00:42:46.790 --> 00:42:50.920
And then Core Data, for the most part,
is a big cache of things.

00:42:50.990 --> 00:42:54.100
And faulting is adding or
replacing the cache lines.

00:42:54.180 --> 00:42:56.720
So your working set is
mostly the changed objects.

00:42:57.010 --> 00:42:59.740
And you may have fetched other
objects to work with them or whatnot.

00:42:59.800 --> 00:43:01.950
But once you're done with them,
then we're going to keep

00:43:02.220 --> 00:43:03.770
little shells of them around.

00:43:03.980 --> 00:43:07.800
But we don't need all the
data because it's still there.

00:43:08.500 --> 00:43:10.920
And this could probably be
a session in its own right,

00:43:10.920 --> 00:43:13.540
so I'm not going to say much about it,
so I don't say anything wrong.

00:43:13.540 --> 00:43:18.120
But locking and unlocking the managed
object context is pretty useful.

00:43:18.120 --> 00:43:21.420
It implements an NS recursive lock,
so you can use it that way.

00:43:21.440 --> 00:43:23.280
But it's not just for thread safety.

00:43:23.280 --> 00:43:26.710
It's important to signal to the
framework that you're using this context,

00:43:26.710 --> 00:43:28.780
and it's basically
wrapping a transaction.

00:43:28.780 --> 00:43:32.760
So this prevents other threads
from interspersing their changes,

00:43:32.760 --> 00:43:35.490
mixing up the undo stack,
or you save a bunch of

00:43:35.490 --> 00:43:36.920
threads changes together.

00:43:37.410 --> 00:43:42.670
This is why it's not enough to just
lock in between an insert operation and

00:43:42.670 --> 00:43:44.430
then unlock after the insert operation.

00:43:44.460 --> 00:43:46.920
You want to group a whole
bunch of things together,

00:43:47.030 --> 00:43:48.370
and this is how you do that.

00:43:48.550 --> 00:43:51.870
It also prevents the framework
from processing notifications

00:43:51.870 --> 00:43:53.880
that might interrupt your state.

00:43:54.020 --> 00:43:56.350
So basically,
it's a signal that you're using

00:43:56.350 --> 00:43:58.970
this managed object context,
and then you unlock it when

00:43:59.030 --> 00:44:00.270
you're done with your transaction.

00:44:03.550 --> 00:44:04.220
Great.

00:44:04.230 --> 00:44:07.260
And now Melissa's going to come on,
and she's going to tell you about the

00:44:07.260 --> 00:44:09.170
rest of the framework underneath it.

00:44:09.180 --> 00:44:11.320
Just a pretty quick
section to wrap up on.

00:44:11.350 --> 00:44:12.900
Thank you.

00:44:17.310 --> 00:44:18.330
Thanks, Ben.

00:44:18.660 --> 00:44:22.900
So the stuff Ben and I have talked about
so far is pretty much the stuff you're

00:44:22.900 --> 00:44:25.060
most likely to have to interact with.

00:44:25.170 --> 00:44:27.170
But there are lower
levels in this framework,

00:44:27.210 --> 00:44:30.860
and this is sort of a quick overview for
those who like to know how things work.

00:44:31.050 --> 00:44:34.190
You probably won't have to
do much coding at this level,

00:44:34.340 --> 00:44:38.000
but if you do, or if you're just curious,
this is how it works.

00:44:39.140 --> 00:44:42.210
Each managed object context has
a persistent store coordinator.

00:44:42.210 --> 00:44:45.380
The persistent store coordinator is
pretty much the bridge between the

00:44:45.530 --> 00:44:49.300
object lifecycle management part of our
stack and the persistence mechanisms.

00:44:49.300 --> 00:44:51.720
In many ways,
it's like the managed object

00:44:51.720 --> 00:44:55.310
context and the managed objects
are the center of your world.

00:44:55.310 --> 00:44:59.790
The persistent store coordinator is
the center of the framework's world.

00:44:59.800 --> 00:45:03.940
You have one persistent store
coordinator per stack and only one,

00:45:04.020 --> 00:45:06.060
but you can have many contexts.

00:45:06.140 --> 00:45:09.110
You can have many stores using
that persistent store coordinator.

00:45:09.150 --> 00:45:12.370
It's really the thing
in the middle that does,

00:45:12.640 --> 00:45:14.210
well, coordination.

00:45:14.780 --> 00:45:17.820
The really important part about
it is that it provides a facade

00:45:17.820 --> 00:45:20.460
of a single object stored in
the managed object context.

00:45:20.500 --> 00:45:23.820
The managed object context knows
that it has to talk to one thing.

00:45:23.890 --> 00:45:27.490
It doesn't care what that thing is,
it has to talk to one thing.

00:45:28.120 --> 00:45:29.960
And we initialize it with
a managed object model.

00:45:29.970 --> 00:45:33.540
That's important because this is where
the managed object context and the

00:45:33.540 --> 00:45:36.120
underlying stores get their model.

00:45:37.940 --> 00:45:42.460
I mentioned that a persistent store
coordinator can have multiple stores.

00:45:42.520 --> 00:45:47.100
Object stores are things you interact
with in this release only through

00:45:47.100 --> 00:45:50.800
the NS Persistent Store Coordinator,
but so you know,

00:45:50.800 --> 00:45:53.640
they're the actual persistent
backing store mechanism.

00:45:53.640 --> 00:45:57.080
We have three stores that
we provide this release,

00:45:57.080 --> 00:45:59.160
XML, SQLite, and Binary.

00:45:59.160 --> 00:46:02.500
Each store type has its own
advantages and disadvantages,

00:46:02.500 --> 00:46:05.490
and you can move data
between stores transparently,

00:46:05.550 --> 00:46:07.160
or almost transparently.

00:46:09.500 --> 00:46:11.780
They said we provide three
stores and they each have

00:46:11.780 --> 00:46:13.400
advantages and disadvantages.

00:46:13.480 --> 00:46:17.090
The binary store is fast,
but it only operates on

00:46:17.340 --> 00:46:19.400
the whole object graph.

00:46:19.400 --> 00:46:23.040
Your entire collection of objects
that you're persisting comes into

00:46:23.390 --> 00:46:25.320
memory and is saved as one unit.

00:46:25.320 --> 00:46:28.820
This is fine if you've got a small
application but can get unwieldy if

00:46:28.820 --> 00:46:33.520
you've got something with thousands
or hundreds of thousands of objects.

00:46:33.800 --> 00:46:36.760
The XML file is very much
like the Binary Object Store,

00:46:36.790 --> 00:46:38.900
only it's XML.

00:46:39.420 --> 00:46:41.640
It's a bit slower,
but it is externally parsable.

00:46:41.640 --> 00:46:44.440
So if you're building an
application whose data you want

00:46:44.450 --> 00:46:47.880
to share with other applications,
this might be the way you want to go.

00:46:47.930 --> 00:46:51.170
And then we have the SQLite store.

00:46:52.000 --> 00:46:52.840
Scalable.

00:46:52.840 --> 00:46:54.490
It's easily the fastest store.

00:46:54.550 --> 00:46:57.010
And most importantly,
it gives you the partial

00:46:57.010 --> 00:46:58.100
object graph management.

00:46:58.100 --> 00:47:02.880
This is the only one of the stores
that gives you faulting out of the box.

00:47:02.900 --> 00:47:06.720
You don't need to worry about
which objects get read into memory.

00:47:06.720 --> 00:47:12.600
As long as you're doing the will
access and did access methods,

00:47:12.840 --> 00:47:16.080
The object graph management context
will take care of pulling everything

00:47:16.250 --> 00:47:19.610
in and out of the SQLite store for you.

00:47:21.280 --> 00:47:24.920
So now we're going to talk a little
bit about how you initialize a stack.

00:47:25.010 --> 00:47:29.440
It's actually-- that covers
most of what you need to know.

00:47:29.460 --> 00:47:34.070
You create the URL for the location
of where you're going to find

00:47:34.090 --> 00:47:36.530
your model and create a model.

00:47:36.640 --> 00:47:40.200
Initialize the persistent store
coordinator with the model.

00:47:41.660 --> 00:47:44.340
Tell the persistent store coordinator,
add persistent store with type.

00:47:44.340 --> 00:47:46.520
In this case, we're using an NSXML store.

00:47:46.520 --> 00:47:49.240
And the URL where you want
that data to be stored.

00:47:51.110 --> 00:47:55.000
We create a managed object context and
set its persistent store coordinator.

00:47:55.110 --> 00:47:57.300
At this point,
you have a stack that's fully ready to

00:47:57.300 --> 00:48:01.550
have managed objects pushed into it,
managed objects pulled out of it.

00:48:04.420 --> 00:48:07.200
Of course,
as Chris showed you in the demo earlier,

00:48:07.200 --> 00:48:09.940
that's how much initialization
you've got to do if you're using

00:48:09.970 --> 00:48:11.040
a document-based application.

00:48:11.040 --> 00:48:12.080
We do it all for you.

00:48:18.270 --> 00:48:21.580
Some more details about
working with stores.

00:48:21.620 --> 00:48:23.520
There's a few other things
you might want to do.

00:48:23.610 --> 00:48:26.280
Here we're doing the same kind
of creation and adding of a store

00:48:26.280 --> 00:48:28.560
that we did in the previous slide.

00:48:29.010 --> 00:48:31.190
But we're also showing
you how to migrate.

00:48:31.200 --> 00:48:31.950
It's pretty simple.

00:48:32.230 --> 00:48:36.120
Create a URL and tell the persistent
store coordinator to migrate

00:48:36.250 --> 00:48:41.790
data from store one to another
store created at that new URL.

00:48:41.880 --> 00:48:46.560
Once you've done that,
you might want to remove the old store.

00:48:46.680 --> 00:48:47.840
Again, it's simple.

00:48:47.930 --> 00:48:50.110
Tell the persistent store
coordinator to remove it.

00:48:50.280 --> 00:48:52.940
But once you've done that,
it's really important for you to do this.

00:48:52.940 --> 00:48:55.440
You have to reset the
managed object context.

00:48:55.530 --> 00:48:57.140
Object graphs can be complicated.

00:48:57.140 --> 00:49:01.590
And if you remove a store,
you've essentially removed the underlying

00:49:01.590 --> 00:49:03.700
backing for a part of your context.

00:49:03.740 --> 00:49:07.200
You need to reset the context so
that all the objects that were in

00:49:07.200 --> 00:49:09.470
that store will get flushed out.

00:49:10.150 --> 00:49:12.140
Don't forget,
if you see confusing behavior,

00:49:12.140 --> 00:49:14.060
you might have forgotten.

00:49:14.090 --> 00:49:16.940
Now we're going to bring Chris back up,
and he's going to show you a demo of how

00:49:16.940 --> 00:49:23.980
you can use the Core Data frameworks to
stripe objects across multiple stores.

00:49:26.160 --> 00:49:28.360
Thanks, Melissa.

00:49:28.420 --> 00:49:32.180
I'd just like to point out one
other thing with the document-based

00:49:32.180 --> 00:49:34.540
application that I showed.

00:49:34.630 --> 00:49:36.300
In here--

00:49:39.600 --> 00:49:44.420
I forgot to mention that we don't
implement any storage methods.

00:49:44.430 --> 00:49:48.630
But if you have a legacy application
that already has a file format,

00:49:48.630 --> 00:49:54.200
you can override the main entry points
for the document loading and saving

00:49:54.610 --> 00:49:56.560
and still handle your own file format.

00:49:56.560 --> 00:50:02.590
So you can just get objects into memory
from your file format and insert them

00:50:02.590 --> 00:50:08.780
into your document's context and then
use Core Data to save them out again.

00:50:12.150 --> 00:50:19.770
But here, I've built a little application
for looking at the WWDC schedule.

00:50:19.850 --> 00:50:24.860
I just got an XML version of the
schedule for a couple of days.

00:50:24.900 --> 00:50:29.550
And I actually built just a
standard Cocoa application.

00:50:29.630 --> 00:50:33.300
I didn't build a Core Data application.

00:50:33.420 --> 00:50:37.090
So I just created a basic
application delegate,

00:50:37.090 --> 00:50:40.530
just like you would see
in any Cocoa example.

00:50:40.630 --> 00:50:44.520
And in its init method,
for when it's instantiated

00:50:44.590 --> 00:50:48.070
in the Nib file,
I have the initialization

00:50:48.140 --> 00:50:52.640
of its managed object model,
its persistent store coordinator,

00:50:52.720 --> 00:50:55.820
and a managed object context
to use for the application.

00:50:55.950 --> 00:51:00.540
So here,
I'm just getting a model from our bundle.

00:51:02.360 --> 00:51:04.410
are getting the Path to
a Model from our bundle.

00:51:04.580 --> 00:51:07.440
I'm actually instantiating that model.

00:51:08.260 --> 00:51:12.140
I'm creating a persistent store
coordinator that refers to that model.

00:51:12.170 --> 00:51:14.540
And finally,
I'm creating a managed object

00:51:14.640 --> 00:51:20.780
context that is attached to that
persistent store coordinator.

00:51:20.860 --> 00:51:23.810
And let's start this
building and running.

00:51:29.140 --> 00:51:32.400
Now here I just have a basic
table view all done with bindings,

00:51:32.400 --> 00:51:33.540
and I have a button.

00:51:33.580 --> 00:51:41.310
This button has one action method,
and that action method is AddStore.

00:51:41.360 --> 00:51:45.910
And what this does is it brings
up an open panel and grabs a

00:51:45.910 --> 00:51:48.870
store from a file and adds it.

00:51:50.790 --> 00:51:53.340
So I can go in here.

00:51:53.460 --> 00:51:55.840
I can pick Monday's schedule.

00:51:55.940 --> 00:51:59.270
And I see all of the sessions that
were on Monday and their day and

00:51:59.270 --> 00:52:01.000
time and the room they were in.

00:52:03.180 --> 00:52:07.680
But notice that this is fairly generic.

00:52:07.770 --> 00:52:12.310
I just get the first URL that
I've selected in my OpenPanel,

00:52:13.150 --> 00:52:14.580
and add it.

00:52:14.600 --> 00:52:20.150
This means-- oh, and then I tell my array
controller that's connected

00:52:20.150 --> 00:52:22.700
to the table view to fetch.

00:52:22.740 --> 00:52:26.800
And the new fetch method on array
controller will actually go out to its

00:52:27.390 --> 00:52:31.400
managed object context and run a fetch.

00:52:31.730 --> 00:52:36.780
So if I click Add Store again,
it goes through the same steps.

00:52:37.610 --> 00:52:40.520
And I can pick Tuesday's schedule,
and Tuesday's schedule

00:52:40.560 --> 00:52:42.660
shows up in my table view.

00:52:42.840 --> 00:52:47.750
But if I sort this by day and time,
I see that Tuesday's sessions

00:52:49.220 --> 00:52:51.420
were added to Monday's sessions.

00:52:51.450 --> 00:52:55.520
This is actually a managed object,
one managed object context connected

00:52:55.520 --> 00:53:00.900
to one persistent store coordinator
that's now connected to two stores.

00:53:00.930 --> 00:53:04.020
Both of these are XML stores,
but they don't have to be.

00:53:04.020 --> 00:53:07.590
One could be an XML store and
one could be an SQL store.

00:53:09.930 --> 00:53:11.060
And that's it.

00:53:11.090 --> 00:53:17.310
This is a very simple code,
barely any in fact, and it lets you work

00:53:17.410 --> 00:53:20.190
with multiple stores,
all from one context.

00:53:20.260 --> 00:53:30.760
So I guess I'm going back to Melissa.

00:53:38.330 --> 00:53:39.370
There's some random other stuff.

00:53:39.530 --> 00:53:41.890
Didn't really fit anywhere
else in the presentation,

00:53:41.890 --> 00:53:43.800
so this is the other stuff section.

00:53:45.190 --> 00:53:47.230
We've mentioned,
Chris mentioned during the demo,

00:53:47.230 --> 00:53:49.440
and it's sort of been
alluded to a few other times,

00:53:49.440 --> 00:53:51.160
we have a NS persistent document.

00:53:51.160 --> 00:53:53.670
It's a subclass of NS document
that integrates with the

00:53:53.670 --> 00:53:57.170
Core Database persistence and object
management stuff automatically.

00:53:57.240 --> 00:54:00.070
You don't need to think about it,
just create it,

00:54:00.070 --> 00:54:01.980
we do everything else for you.

00:54:01.980 --> 00:54:04.740
It's got full undo redo support,
document dirtying,

00:54:04.740 --> 00:54:07.620
and it does provide hooks for
configuring the stack if you

00:54:07.620 --> 00:54:09.340
want to do something special.

00:54:09.340 --> 00:54:12.440
If you want to create a
document-based application using

00:54:12.440 --> 00:54:15.080
models for multiple frameworks,
we provide hooks for that.

00:54:15.100 --> 00:54:17.350
that let you do that.

00:54:17.860 --> 00:54:20.160
We've got, as we said,
Cocoa Bindings integration.

00:54:20.200 --> 00:54:22.980
The big takeaway message
here is it just works.

00:54:23.000 --> 00:54:25.320
Managed object can be bound
like any other object that

00:54:25.320 --> 00:54:26.960
supports key value coding.

00:54:27.000 --> 00:54:30.640
You get undo,
reduce support through the context.

00:54:30.700 --> 00:54:34.500
And as you saw in Chris's demo,
the controllers are now model aware,

00:54:34.500 --> 00:54:37.820
so you can drive it all using the models.

00:54:37.920 --> 00:54:41.670
And the array controller actually
has a field that will allow you to

00:54:41.670 --> 00:54:45.900
configure an NSFetchRequest to fetch
context from the object context.

00:54:45.900 --> 00:54:49.380
So if you want an array controller
that only contains a subset of

00:54:49.380 --> 00:54:52.420
the objects in your context,
you can build an NS predicate

00:54:52.940 --> 00:54:55.360
that fetches only those objects.

00:55:00.630 --> 00:55:03.120
Well, that's actually about all
we've got to talk about.

00:55:03.140 --> 00:55:10.380
You're going to get, in the WWDC CD,
you've all got a seed.

00:55:10.380 --> 00:55:12.940
It's already got a fair
amount of documentation for

00:55:12.970 --> 00:55:14.600
which we thank our doc team.

00:55:14.600 --> 00:55:17.640
Some pieces aren't
quite fully functional.

00:55:17.640 --> 00:55:21.060
The SQLite support only supports
basic fetching and updating.

00:55:21.060 --> 00:55:24.540
The live controllers aren't as
live as we'd like them to be,

00:55:24.540 --> 00:55:26.370
and the fetch properties
don't fully work.

00:55:26.440 --> 00:55:29.160
There isn't any localization,
and there's no optimization,

00:55:29.160 --> 00:55:31.680
but please try it out,
and if you find something,

00:55:31.680 --> 00:55:32.800
submit bug reports.

00:55:32.800 --> 00:55:33.900
We like bug reports.

00:55:33.960 --> 00:55:36.860
They tell us what parts of
the stack people are using,

00:55:36.860 --> 00:55:40.520
what parts they don't really care about,
what problems they're having with things.

00:55:40.520 --> 00:55:44.980
So, things you should remember.

00:55:44.980 --> 00:55:46.160
Core Data is model-driven.

00:55:46.160 --> 00:55:51.170
It gives you object graph management,
object graph persistency, Cocoa bindings,

00:55:51.170 --> 00:55:54.340
and some additions to Cocoa bindings.

00:55:54.340 --> 00:55:56.790
It helps you solve difficult problems.

00:55:56.960 --> 00:55:58.940
Things like undo, redo, and scalability.

00:55:59.160 --> 00:56:01.160
Both of these are
actually relatively hard,

00:56:01.160 --> 00:56:04.160
as many of you know who've had
to solve these problems before.

00:56:04.160 --> 00:56:06.020
We do it for you.

00:56:06.160 --> 00:56:08.160
We support a variety
of persistent stores.

00:56:08.160 --> 00:56:13.770
You pick which particular
storage mechanism you want.

00:56:14.230 --> 00:56:17.750
We have support in Xcode and
Interface Builder at the user

00:56:17.900 --> 00:56:22.570
interface level for allowing you to
build applications using Core Data.

00:56:22.940 --> 00:56:27.100
And you'll write a lot less code,
as Chris showed you in his demo, a lot,

00:56:27.310 --> 00:56:28.300
lot less code.

00:56:28.300 --> 00:56:29.940
You don't even need classes.

00:56:29.940 --> 00:56:32.650
You can just use NSManagedObject.

00:56:33.840 --> 00:56:36.490
Before we go to the question and answer,
I want to point out this slide.

00:56:36.490 --> 00:56:39.330
Big slide.

00:56:41.370 --> 00:56:43.260
Report bugs.

00:56:43.340 --> 00:56:46.700
Griping on the list, talking on the list,
that's all well and good, but you know,

00:56:46.700 --> 00:56:49.400
Apple engineering is bug driven.

00:56:49.690 --> 00:56:51.800
Submit bugs if you want us to fix things.
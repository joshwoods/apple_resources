WEBVTT

00:00:12.200 --> 00:00:13.200
Good afternoon.

00:00:13.200 --> 00:00:14.200
Is everybody ready to go home?

00:00:14.200 --> 00:00:16.200
No?

00:00:16.200 --> 00:00:16.690
Okay.

00:00:16.690 --> 00:00:19.170
Well, then make yourselves comfortable.

00:00:20.240 --> 00:00:22.380
So hello yet again.

00:00:22.390 --> 00:00:24.240
In case you don't know, I'm Matt Drance.

00:00:24.240 --> 00:00:27.680
I work in DTS,
and I can't stay off the stage.

00:00:27.750 --> 00:00:29.300
I can't help it.

00:00:29.310 --> 00:00:30.820
I've been on stage every day this week.

00:00:30.900 --> 00:00:33.020
I think that might be a record, actually.

00:00:33.060 --> 00:00:36.760
So I kind of adopted this
talk at the last minute.

00:00:36.760 --> 00:00:40.040
Some of you may have been
expecting to see Gerard Ziemski,

00:00:40.070 --> 00:00:42.080
who's our resident graphics guru.

00:00:42.130 --> 00:00:46.960
But he had a small incident
come up Tuesday night.

00:00:47.040 --> 00:00:48.610
So--

00:00:50.750 --> 00:00:52.480
So Gerard won't be joining us.

00:00:52.510 --> 00:00:55.480
I'm going to do the best I can
to sound as authoritative

00:00:55.480 --> 00:00:57.040
as he would on this topic.

00:00:57.040 --> 00:00:58.880
So what are we going to be talking about?

00:00:58.880 --> 00:01:02.940
We're going to talk about the changes
that we've made in Java 1.4.2 Update 1.

00:01:02.940 --> 00:01:06.640
You've got Developer Preview 3
available to you as of this week.

00:01:06.640 --> 00:01:09.030
We're going to talk about
the architectural changes

00:01:09.030 --> 00:01:11.650
we made specifically to
on-screen Java 2D drawing.

00:01:11.660 --> 00:01:16.510
And we're going to talk about
improvements not only in correctness

00:01:16.510 --> 00:01:19.420
and hopefully eliminating a lot of the
bugs that some of you have reported,

00:01:19.420 --> 00:01:21.960
but as well the performance
improvements that we've seen

00:01:21.960 --> 00:01:23.400
as a result of these changes.

00:01:23.400 --> 00:01:27.210
We're going to talk very briefly
about Quartz 2D and its relationship

00:01:27.250 --> 00:01:31.010
with Java and how that story has
changed with the announcements that

00:01:31.010 --> 00:01:33.060
have come in with Tiger this week.

00:01:33.060 --> 00:01:36.880
And we're going to talk a little
bit about the third-party APIs that

00:01:36.880 --> 00:01:40.100
are new to Mac OS X as of the last
time we talked here last year,

00:01:40.100 --> 00:01:43.820
specifically Java Advanced Imaging,
Java 3D, and JOGL,

00:01:43.820 --> 00:01:46.350
which we affectionately know as jogl.

00:01:48.480 --> 00:01:50.320
So Java2D on Mac OS X.

00:01:50.320 --> 00:01:54.300
Like I said earlier,
we have a bunch of improvements

00:01:54.300 --> 00:01:57.780
and some new features that we've
made available to you with DP3.

00:01:57.780 --> 00:02:00.980
Among them is graphics
context management,

00:02:00.980 --> 00:02:03.930
and I'm going to be saying
context a lot in this talk,

00:02:04.000 --> 00:02:07.160
and within the context
of this presentation.

00:02:07.210 --> 00:02:10.620
By context, I mean just a standard
Java graphics object,

00:02:10.630 --> 00:02:12.580
the Java AWT graphics object.

00:02:12.800 --> 00:02:14.340
We're going to talk
about state management,

00:02:14.340 --> 00:02:18.530
the state of a Java graphics object,
and how we've worked around

00:02:18.610 --> 00:02:20.550
a lot of problems that we've
had with that in the past.

00:02:20.580 --> 00:02:23.920
We're going to talk about how
these changes affect and improve

00:02:23.920 --> 00:02:26.280
multi-threaded drawing in Update 1.

00:02:26.280 --> 00:02:30.110
We're going to talk about the
intelligent screen update mechanism

00:02:30.110 --> 00:02:32.360
that we've introduced with DP3.

00:02:32.360 --> 00:02:34.050
I believe that's new with DP3, right?

00:02:34.590 --> 00:02:35.100
Okay.

00:02:35.100 --> 00:02:39.270
And we're going to talk about some
improvements to full screen mode

00:02:39.280 --> 00:02:41.510
drawing and XOR drawing as well.

00:02:42.190 --> 00:02:44.500
So let's go right into it and
talk about context management.

00:02:44.500 --> 00:02:47.400
Like I said,
it's a new mechanism in Update 1,

00:02:47.400 --> 00:02:51.200
and it's completely independent
of the Cocoa drawing

00:02:51.230 --> 00:02:53.640
context that we use beneath.

00:02:53.730 --> 00:02:57.430
As you know,
the AWT in 1.4.2 and Java 1.4 is

00:02:57.430 --> 00:02:59.670
built on top of the Cocoa App Kit.

00:02:59.680 --> 00:03:03.140
Now, in the past, we used to share our
graphics contexts with Cocoa,

00:03:03.160 --> 00:03:06.530
and it created a number of
problems or issues that we

00:03:06.530 --> 00:03:08.610
needed to be delicate with.

00:03:08.690 --> 00:03:13.220
And the most problematic one was
that sometimes Cocoa would prevent

00:03:13.270 --> 00:03:15.580
Java from drawing altogether.

00:03:15.580 --> 00:03:19.600
So if there was some painting things that
needed to be sent through the context,

00:03:19.600 --> 00:03:22.150
Cocoa would sometimes deny
us the shared context,

00:03:22.200 --> 00:03:25.840
and it would cause us to either skip
frames or paint methods altogether,

00:03:25.840 --> 00:03:29.480
or at least delay the visual
appearance of painting on the screen.

00:03:29.680 --> 00:03:35.310
So the new system improves performance
in addition to correctness and the

00:03:35.310 --> 00:03:38.110
perceived quickness by the user.

00:03:38.140 --> 00:03:41.730
Before, not only could the context
have been denied by Cocoa,

00:03:41.730 --> 00:03:44.660
but it could have been
modified by Cocoa as well,

00:03:44.660 --> 00:03:46.790
and we didn't necessarily know
what we were getting back.

00:03:46.880 --> 00:03:50.660
And we needed time to reconcile those
states and make sure that the state

00:03:50.660 --> 00:03:54.680
that you expected your Java Graphics 2D
object to be in was the same as the state

00:03:54.750 --> 00:03:57.200
that we were using behind the scenes.

00:03:57.200 --> 00:04:00.670
So now, because the contexts are
independent... ...we always know

00:04:00.670 --> 00:04:03.490
the state of your Java context,
and we can start drawing

00:04:03.490 --> 00:04:04.910
that much sooner.

00:04:05.890 --> 00:04:09.720
And when I say state changes,
I mean things like color, clip,

00:04:09.760 --> 00:04:12.090
anti-aliasing font,
all the set methods that you would

00:04:12.170 --> 00:04:13.570
call on a Graphics 2D object.

00:04:13.610 --> 00:04:17.440
All of those things we know at all
times now what those states are from

00:04:17.570 --> 00:04:19.880
what you're setting in your Java code.

00:04:19.980 --> 00:04:23.000
Before, we had to make sure whatever we
got back from Cocoa was synced with

00:04:23.000 --> 00:04:24.660
what your Java code was expecting.

00:04:24.660 --> 00:04:26.820
And now that we have
an independent context,

00:04:26.870 --> 00:04:28.820
we no longer have to worry about that.

00:04:28.870 --> 00:04:32.160
And that, obviously,
is less execution time and more

00:04:32.160 --> 00:04:34.690
time devoted to painting operations.

00:04:35.980 --> 00:04:37.860
Here's a visualization of
what I'm talking about.

00:04:37.860 --> 00:04:39.250
It might sound a little confusing.

00:04:39.600 --> 00:04:42.490
What you see here is,
we're having a little fun with it,

00:04:42.490 --> 00:04:42.940
I guess.

00:04:42.940 --> 00:04:45.620
You see Java and Cocoa basically
fighting over the same context.

00:04:45.620 --> 00:04:49.870
And that checkered blue and
orange there is basically kind of

00:04:50.030 --> 00:04:54.200
illustrating the unknown state that
a given shared context would be in,

00:04:54.280 --> 00:04:56.300
in the original 1.4.2 release.

00:04:56.340 --> 00:04:58.680
And whenever Java got it,
we needed to make sure it

00:04:58.730 --> 00:05:00.070
wasn't in Cocoa's state.

00:05:00.080 --> 00:05:02.500
We needed to make sure
it was in our state.

00:05:03.080 --> 00:05:06.250
So now in 1.4.2 Update 1,
because we have our own contest

00:05:06.310 --> 00:05:08.920
exclusively available to Java,
available to you,

00:05:08.920 --> 00:05:12.080
we no longer have to worry about
any of that reconciliation.

00:05:12.080 --> 00:05:14.660
Cocoa can do what it wants,
and Java can do what it wants.

00:05:17.200 --> 00:05:19.880
This particularly is good
for multi-threaded drawing.

00:05:19.920 --> 00:05:23.100
The improved context management
that I was just talking about

00:05:23.240 --> 00:05:25.910
basically allows us to draw
correctly from multiple threads.

00:05:26.000 --> 00:05:28.570
We don't have to worry about locking
or contention or anything like that.

00:05:28.640 --> 00:05:30.770
It allows us to cache
graphics 2D objects.

00:05:30.830 --> 00:05:34.310
Now that we don't have to worry about
state validity or anything like that,

00:05:34.310 --> 00:05:37.800
you can safely cache a graphics 2D
object where in the past it was really,

00:05:37.810 --> 00:05:39.180
really not a good idea.

00:05:39.920 --> 00:05:41.660
And not only does this
make things more correct,

00:05:41.770 --> 00:05:43.840
but it makes it very, very much faster.

00:05:43.840 --> 00:05:47.340
And this is a huge benefit,
particularly to old applets from

00:05:47.340 --> 00:05:51.740
the 1.0 and 1.1 days that maybe had
been doing a lot of multi-threaded

00:05:51.740 --> 00:05:53.370
work from inside the browser.

00:05:54.920 --> 00:05:56.430
And here's another illustration of that.

00:05:56.450 --> 00:06:01.280
You can see this huge heavyweight
master lock that's basically blocking

00:06:01.280 --> 00:06:06.680
or barring the entrance into all
these contexts from all the threads.

00:06:06.680 --> 00:06:09.980
And in the past, you had Cocoa,
the main Cocoa drawing thread,

00:06:09.980 --> 00:06:12.870
and all of your Java threads,
if you had multi-threaded drawing,

00:06:13.230 --> 00:06:15.960
trying to go through the same locks,
through the same area.

00:06:16.500 --> 00:06:19.980
Now with update one,
it's just the Java threads.

00:06:20.210 --> 00:06:23.420
Because we have our own context and
because we have our management down,

00:06:23.480 --> 00:06:23.940
much better.

00:06:23.940 --> 00:06:28.690
It's a lot less work to go through from
multiple threads and draw to the screen.

00:06:28.700 --> 00:06:32.710
And I'd like to invite Caroline up to
show us just what we're talking about.

00:06:38.340 --> 00:06:39.370
Thanks, Matt.

00:06:39.510 --> 00:06:41.660
So this demo is going to show
you the huge improvements we've

00:06:41.660 --> 00:06:45.540
made in multi-threaded drawing
support in 1.4.2 Update 1.

00:06:45.630 --> 00:06:51.320
First, I'll show you a demo of 1.4.2
doing some multi-threaded drawing,

00:06:51.390 --> 00:06:53.570
or trying to.

00:06:53.780 --> 00:06:56.060
The first square is actually
the normal repainting mechanism,

00:06:56.060 --> 00:06:59.510
not multi-threaded,
where you make your paint method and

00:06:59.820 --> 00:07:02.710
the events get posted to the AWT thread.

00:07:03.260 --> 00:07:07.200
and the second square,
let me open this up again

00:07:07.200 --> 00:07:09.120
so you can see it again.

00:07:09.160 --> 00:07:13.230
The second square is using a
separate thread and calling

00:07:13.240 --> 00:07:15.430
get graphics on each repaint.

00:07:15.560 --> 00:07:18.920
The third and fourth squares are
each using two drawing threads,

00:07:18.960 --> 00:07:20.110
but they're not working very well.

00:07:20.180 --> 00:07:26.990
So if we go to 1.4.2 update 1 on demo 2.

00:07:27.060 --> 00:07:28.990
On demo 2, please.

00:07:33.520 --> 00:07:37.760
You can see that it looks a lot better,
and it's considerably

00:07:37.770 --> 00:07:38.900
faster in all cases.

00:07:39.150 --> 00:07:43.610
So these bottom two squares,
the third one is using two threads.

00:07:43.690 --> 00:07:46.040
One's drawing in black and
one's drawing in yellow,

00:07:46.060 --> 00:07:49.270
and it's using one cache
graphics object to draw into.

00:07:49.430 --> 00:07:51.840
And the fourth square,
the green and black one,

00:07:51.870 --> 00:07:53.410
there's a green thread
and a black thread,

00:07:53.410 --> 00:07:55.940
basically,
each drawing a green or a black line,

00:07:55.960 --> 00:07:59.300
and they're drawing into two
separate cache graphics objects.

00:07:59.320 --> 00:08:01.660
So if you need to use
multi-threaded drawing,

00:08:01.670 --> 00:08:05.040
it's now a real option for
you in using 1.4.2 Update 1.

00:08:05.240 --> 00:08:07.030
All right, I'll hand it back to Matt.

00:08:07.040 --> 00:08:11.700
- Thank you, Caroline.

00:08:14.620 --> 00:08:17.140
You sure those were both
running the same hardware?

00:08:17.180 --> 00:08:17.660
Same hardware.

00:08:17.660 --> 00:08:18.160
OK.

00:08:18.160 --> 00:08:19.600
Same demo.

00:08:19.660 --> 00:08:21.190
You sure?

00:08:22.980 --> 00:08:25.080
Okay,
so we just showed you that multi-threaded

00:08:25.170 --> 00:08:28.550
drawing works a lot better in Update 1,
but we want to mention a few

00:08:28.550 --> 00:08:33.710
things just for general advice.

00:08:34.100 --> 00:09:56.400
[Transcript missing]

00:09:56.690 --> 00:09:59.290
So the next thing we want to talk
about is intelligent screen updates.

00:09:59.350 --> 00:10:01.400
And this is kind of the marketing term.

00:10:01.400 --> 00:10:04.520
You may know it more
commonly as flushing.

00:10:04.520 --> 00:10:08.380
So the thing that we were talking
about when we were coming up

00:10:08.390 --> 00:10:12.600
with this mechanism is that
hardware is getting faster,

00:10:12.600 --> 00:10:14.680
software optimizations
are always happening,

00:10:14.680 --> 00:10:18.780
but displays are still fixed at
a relatively pretty slow rate.

00:10:19.040 --> 00:10:23.160
Your application can usually draw
at 100 frames per second or more,

00:10:23.470 --> 00:10:27.060
and the display is chugging along at 60,
70 hertz.

00:10:27.060 --> 00:10:30.700
And so it seems like a waste of
time trying to push all this stuff

00:10:30.700 --> 00:10:34.760
up to the screen when it's not
going to refresh anyway physically.

00:10:34.760 --> 00:10:39.140
So what update one does now is it only
updates the screen when it's necessary,

00:10:39.190 --> 00:10:41.040
when we know it's possible.

00:10:41.040 --> 00:10:44.440
You can see the thing on the screen here.

00:10:44.440 --> 00:10:46.060
It says 100 Java updates.

00:10:46.060 --> 00:10:48.000
There's more than 60 screen updates.

00:10:48.160 --> 00:10:50.520
There's no point in actually
performing that flush operation

00:10:50.520 --> 00:10:51.690
if you're not going to see it.

00:10:51.780 --> 00:10:54.370
Now, this might sound a little scary,
but we've done a lot of work

00:10:54.380 --> 00:10:56.990
to make sure it's correct,
and we're not skipping

00:10:56.990 --> 00:11:00.470
any paints or dropping any
frames or anything like that.

00:11:00.550 --> 00:11:01.900
There shouldn't be any
visible difference.

00:11:01.900 --> 00:11:04.710
Well, there should be something
of a visible difference,

00:11:04.710 --> 00:11:07.820
and that's that drawing should
actually be faster as a result.

00:11:07.880 --> 00:11:11.580
Much to the tune of the state
management and the state reconciliation

00:11:11.580 --> 00:11:14.500
I was talking about earlier,
we're spending less time

00:11:14.500 --> 00:11:16.320
waiting for screen updates.

00:11:16.320 --> 00:11:17.460
So we're wasting less time doing that.

00:11:17.460 --> 00:11:19.740
We're wasting less time doing
that when it's redundant anyway,

00:11:19.740 --> 00:11:23.310
and that gives us more time to
process your next paint event.

00:11:25.230 --> 00:11:26.230
Also, full screen mode.

00:11:26.310 --> 00:11:29.150
This is a place where
we've gotten a lot of,

00:11:29.300 --> 00:11:30.780
I'll call it, feedback on.

00:11:30.780 --> 00:11:34.220
We've re-implemented it
primarily for correctness,

00:11:34.220 --> 00:11:38.060
and in doing so, we also did a lot in
the speed department.

00:11:38.060 --> 00:11:41.080
And actually, it wasn't that complicated
a re-architecture.

00:11:41.080 --> 00:11:43.430
We basically changed from
a blip buffer strategy,

00:11:43.500 --> 00:11:46.170
which is basically copying the
bits directly from the back

00:11:46.170 --> 00:11:48.990
buffer into the front buffer,
which is a particularly

00:11:49.020 --> 00:11:50.270
expensive operation.

00:11:50.300 --> 00:11:51.800
We changed that into a
flip buffer strategy,

00:11:51.890 --> 00:11:54.980
where you have a front and back buffer,
and then just flip those from one

00:11:54.980 --> 00:11:56.800
to the other back on the screen.

00:11:56.800 --> 00:11:58.640
The former front buffer
is now your back buffer,

00:11:58.640 --> 00:12:00.550
where you do your next
frame worth of drawing.

00:12:00.560 --> 00:12:04.040
And I think Caroline's going to
show us what that looks like.

00:12:07.220 --> 00:12:10.940
So I've got one more,
another before and after demo.

00:12:11.120 --> 00:12:15.660
Here we have a full screen
application running in 1.4.2.

00:12:15.700 --> 00:12:19.230
And what this is trying to do is it's
trying to maintain 30 frames per second.

00:12:19.240 --> 00:12:22.640
But since we're only getting
10 frames per second,

00:12:22.860 --> 00:12:23.880
there's only going to be one ball.

00:12:23.910 --> 00:12:29.180
The more, it continues to add balls until
it reaches 30 frames per second.

00:12:29.180 --> 00:12:30.220
So one ball.

00:12:30.240 --> 00:12:34.880
But if we move to 1.4.2
update 1 on demo 2,

00:12:34.880 --> 00:12:35.890
please.

00:12:40.290 --> 00:12:45.400
You can see it keeps on putting in balls
until it reaches 30 frames per second.

00:12:45.560 --> 00:12:47.870
How high are we going to get?

00:12:57.190 --> 00:12:58.470
This is a pretty fabulous improvement.

00:12:58.530 --> 00:13:01.910
Full screen is now a really
good option for you if you

00:13:01.910 --> 00:13:03.460
want to use it on Mac OS X.

00:13:03.460 --> 00:13:05.710
All right, back to Matt.

00:13:05.720 --> 00:13:07.840
Thank you very much, Caroline.

00:13:07.840 --> 00:13:11.960
I don't know if you had seen,
had any of you used Puzzle

00:13:11.960 --> 00:13:16.600
Pirates before when you had seen
Scott's deploying demo earlier?

00:13:16.600 --> 00:13:19.600
Puzzle Pirates did not used
to do too well in full screen,

00:13:19.600 --> 00:13:23.820
and obviously Scott was demoing
it in DP3 the other day.

00:13:24.980 --> 00:13:27.430
But yeah,
one ball at 10 frames per second,

00:13:27.470 --> 00:13:29.060
600 balls at 30.

00:13:29.060 --> 00:13:32.420
That's 1800x, I think.

00:13:32.470 --> 00:13:36.300
And that's all software changes,
so Gerard did a good job there.

00:13:37.760 --> 00:13:40.380
So we also want to
talk about XOR drawing.

00:13:40.410 --> 00:13:42.770
Last but not least, well,
maybe it is least,

00:13:42.770 --> 00:13:46.170
we did a lot of work to improve
the correctness of XOR drawing.

00:13:46.180 --> 00:13:48.460
And this has been a
perpetual thorn in our side.

00:13:48.460 --> 00:13:52.050
And the main reason being is that Quartz,
which is what our Java2D drawing

00:13:52.130 --> 00:13:55.400
mechanism is built on top of,
doesn't support XOR natively.

00:13:55.410 --> 00:13:57.320
And if you've been to any
of the Quartz sessions,

00:13:57.320 --> 00:13:59.940
you may have heard this from
the Quartz engineers themselves.

00:14:00.720 --> 00:14:03.700
So we've had to implement
it for you on our own.

00:14:03.700 --> 00:14:07.010
And the correctness should be there now,
but obviously there's going

00:14:07.010 --> 00:14:09.750
to be a cost because we've
implemented it all on our own.

00:14:09.790 --> 00:14:11.820
So the performance may
not be what you expect.

00:14:11.910 --> 00:14:14.510
And it probably never will
be because Quartz simply

00:14:14.570 --> 00:14:16.270
doesn't support it natively.

00:14:16.280 --> 00:14:18.980
And so what that means is
that you should probably,

00:14:19.020 --> 00:14:22.110
if you feel like you need to
use XOR drawing for some reason,

00:14:22.110 --> 00:14:25.170
you should probably talk to us
to see what you really need to

00:14:25.220 --> 00:14:28.760
do and see if we can offer some
kind of alternatives for you.

00:14:28.760 --> 00:14:28.760
So we've had to implement
it for you on our own.

00:14:28.760 --> 00:14:28.760
And so what that means is
that you should probably,

00:14:28.760 --> 00:14:28.760
if you feel like you need to
use XOR drawing for some reason,

00:14:28.760 --> 00:14:28.760
you should probably talk to us
to see what you really need to

00:14:28.760 --> 00:14:28.760
do and see if we can offer some
kind of alternatives for you.

00:14:28.760 --> 00:14:31.590
Things like alpha composites,
if you need to do, blending operations.

00:14:31.640 --> 00:14:35.200
And the other thing that Barry and
Tom mentioned already on Wednesday is

00:14:35.560 --> 00:14:39.180
that if you're doing XOR to erase things,
you're doing a double

00:14:39.220 --> 00:14:41.400
draw to erase some text,
for example,

00:14:41.400 --> 00:14:44.730
anti-aliased text is not going to
be erased by XOR drawing because

00:14:44.730 --> 00:14:46.750
of the anti-aliasing operations.

00:14:46.750 --> 00:14:50.020
Those are not taken into account
when you do an XOR operation.

00:14:50.020 --> 00:14:52.750
So even if that was your
real reason for using XOR,

00:14:52.750 --> 00:14:54.590
it's not going to work anyway.

00:14:54.620 --> 00:14:58.240
And if you need to do an erase operation,
the best thing to do is to

00:14:58.240 --> 00:15:00.400
keep your static scenes,
the before,

00:15:00.720 --> 00:15:03.690
the before modification scenes
in something like an off-screen

00:15:03.730 --> 00:15:06.110
buffered image and then push
that to the screen when you need

00:15:06.110 --> 00:15:07.300
to do your erase or your undo.

00:15:09.850 --> 00:15:12.630
So what are all the performance
gains as a result of all these

00:15:12.630 --> 00:15:13.530
things we're talking about?

00:15:13.540 --> 00:15:16.480
Well, I mentioned the context
management changes.

00:15:16.480 --> 00:15:19.040
We're no longer waiting for
Cocoa's permission to draw.

00:15:19.040 --> 00:15:22.640
We don't have to do any guesswork
on the state from when Cocoa may

00:15:22.640 --> 00:15:23.920
or may not have modified it.

00:15:24.000 --> 00:15:26.580
And we've got safe context
caching for multi-threaded

00:15:26.580 --> 00:15:28.190
drawing if you want to do that.

00:15:28.200 --> 00:15:31.920
The intelligent update mechanism
means we spend less time waiting

00:15:31.920 --> 00:15:35.340
for the screen and more time
actually executing your paint code.

00:15:35.360 --> 00:15:40.520
And the full-screen drawing change
from a blip buffer to a flip buffer,

00:15:40.520 --> 00:15:44.680
that's almost a tongue twister,
that change is really, as you saw,

00:15:44.680 --> 00:15:46.120
quite an improvement in performance.

00:15:46.170 --> 00:15:50.610
And here's just a quick graph of some
of our internal benchmarks as well as

00:15:50.680 --> 00:15:55.000
the standard ones like the Java2D demo
and the SwingMark benchmark in Aqua.

00:15:55.000 --> 00:15:58.880
We've seen anywhere between 20%
and 50% improvement just with

00:15:58.880 --> 00:16:00.660
these software changes in DP3.

00:16:02.420 --> 00:16:06.540
And I think Caroline's going to give us
one more demo of the overall changes.

00:16:06.600 --> 00:16:07.750
All right.

00:16:07.870 --> 00:16:10.490
This is the last before and after demo.

00:16:10.580 --> 00:16:14.000
This is really similar to what you may
have seen in the Java State of the Union,

00:16:14.050 --> 00:16:16.890
except in Java State of the Union,
we compared ourselves to Windows.

00:16:16.920 --> 00:16:19.560
And here, since we've been talking
about the graphics changes,

00:16:19.600 --> 00:16:22.180
we're comparing ourselves to ourselves.

00:16:22.180 --> 00:16:26.320
So this is the Java 2D demo
running in 1.4.2.

00:16:26.560 --> 00:16:28.680
And the important point to
notice is that we're getting

00:16:28.680 --> 00:16:33.140
around 115 frames per second.

00:16:33.720 --> 00:16:44.350
Alright, so in 1.4.2 update 1 on demo 2,
getting more than twice that, around 200,

00:16:44.480 --> 00:16:46.540
250 sometimes.

00:16:46.610 --> 00:16:47.850
So these are significant improvements.

00:16:47.860 --> 00:16:50.020
I think you're really going to like them.

00:16:50.070 --> 00:16:51.410
All right.

00:16:51.600 --> 00:16:53.200
Back over to Matt.

00:16:53.200 --> 00:16:55.020
Matt Draance: Thank you, Caroline.

00:16:58.540 --> 00:17:01.300
So I think you can see we've been doing
a lot of work to speed things up for you.

00:17:01.300 --> 00:17:03.580
And also, you know,
it's hard to demonstrate correctness.

00:17:03.600 --> 00:17:05.710
The multi-threaded drawing
demo did a good job at that.

00:17:05.770 --> 00:17:07.950
But hopefully you guys will
see this in your applications.

00:17:07.950 --> 00:17:10.460
And we'd like to hear your
feedback if it is or if it is not.

00:17:10.460 --> 00:17:13.290
Either way, we want to make sure we're
doing the right thing before

00:17:13.410 --> 00:17:14.690
we release this update.

00:17:17.480 --> 00:17:18.840
So let's talk a little bit about Tiger.

00:17:18.840 --> 00:17:21.720
I don't have a demo for you,
but as you probably heard,

00:17:21.730 --> 00:17:27.020
Quartz 2D is going to be hardware
accelerated using OpenGL in 10.4.

00:17:27.020 --> 00:17:30.670
And because we're built on top
of Quartz to do our 2D drawing,

00:17:31.010 --> 00:17:34.440
this is just going to be faster
Java graphics for free without any

00:17:34.440 --> 00:17:37.320
work that you need to do or even
much that the Java team needs to do.

00:17:37.320 --> 00:17:40.560
And I have again on there is
because some of you from the 1.3

00:17:40.560 --> 00:17:44.050
days may remember that we had an
OpenGL pipeline of our own in Java.

00:17:44.060 --> 00:17:45.880
And you might wonder why that went away.

00:17:45.880 --> 00:17:49.820
Well, that's because the gentleman
who was working on that for

00:17:49.820 --> 00:17:51.920
Java is now working on Quartz.

00:17:51.920 --> 00:17:55.140
And if you're wondering why hardware
acceleration went away from Java,

00:17:55.140 --> 00:17:57.480
it's because it went to
the whole system instead.

00:17:57.480 --> 00:18:01.220
And thank you for waiting,
and you should have it very soon now.

00:18:01.300 --> 00:18:04.780
And the difference between the
Tiger hardware acceleration and what

00:18:04.780 --> 00:18:08.670
you may have been used to in 1.3 is
that it really does look like Quartz.

00:18:08.760 --> 00:18:11.560
In 1.3, the hardware acceleration
looked like OpenGL.

00:18:11.560 --> 00:18:13.980
And in Tiger,
it's going to look like Quartz.

00:18:14.060 --> 00:18:17.390
It's going to have the anti-aliasing
and all the things that you

00:18:17.390 --> 00:18:19.150
expect from Quartz drawing.

00:18:20.790 --> 00:18:22.530
So we've been talking
about what we've done.

00:18:22.530 --> 00:18:24.690
I wanted to talk a little bit
about what you guys can do.

00:18:25.180 --> 00:18:28.890
This is kind of a repeat of
things that we said last year,

00:18:28.940 --> 00:18:31.670
but they're still very important tips,
so I wanted to put them on here.

00:18:31.820 --> 00:18:35.630
The big thing with images in particular
is that you need to make sure

00:18:35.630 --> 00:18:39.810
that you are using an image format
that's compatible to the system.

00:18:39.860 --> 00:18:42.950
And when I say when you're using images,
I'm talking about creating new

00:18:42.950 --> 00:18:46.170
images that you're going to draw
into to paint onto the screen later.

00:18:47.160 --> 00:18:50.410
Using methods like toolkit create image,
graphics configuration

00:18:50.410 --> 00:18:53.520
create compatible image,
that line's actually a lot longer.

00:18:53.520 --> 00:18:56.140
You need to do about three or four
other static getters before you

00:18:56.230 --> 00:18:57.820
get to a graphics configuration.

00:18:57.820 --> 00:19:01.790
But static images,
meaning things that you've loaded

00:19:02.240 --> 00:19:08.070
from a JPEG file using imageio.read,
new image icons, so on and so forth,

00:19:08.160 --> 00:19:09.020
those things will be fine.

00:19:09.020 --> 00:19:11.300
We will optimize those for
you once they're decoded.

00:19:11.300 --> 00:19:14.580
As far as new images that you're
going to do drawing operations into,

00:19:14.580 --> 00:19:17.040
make sure you use these
compatible image APIs.

00:19:17.040 --> 00:19:21.080
Things like particularly the index
color formats that are very popular

00:19:21.080 --> 00:19:23.520
on Windows because they're low memory.

00:19:23.520 --> 00:19:26.400
That image format is not
compatible on Mac OS X,

00:19:26.400 --> 00:19:29.370
and we're going to need
to do pixel conversion for

00:19:29.370 --> 00:19:31.400
every operation that you do.

00:19:31.400 --> 00:19:34.310
And that brings me to that third
bullet there that says if you

00:19:34.410 --> 00:19:37.220
must use a non-native image,
please avoid doing direct

00:19:37.220 --> 00:19:38.500
pixel manipulation.

00:19:38.500 --> 00:19:42.480
Because every time you have to go get
the data buffer and get the raster,

00:19:42.550 --> 00:19:45.780
we'll need to convert those
pixels from whatever the image

00:19:45.920 --> 00:19:47.040
format is to a new image format.

00:19:47.060 --> 00:19:49.060
So if you're going to do something
that Quartz can actually read,

00:19:49.060 --> 00:19:51.420
we'll need to do that every single time.

00:19:51.530 --> 00:19:55.670
If you use general Java drawing
methods like draw string,

00:19:55.680 --> 00:19:58.220
draw line,
we can fake that and not worry about

00:19:58.220 --> 00:20:00.420
doing the conversion every single time.

00:20:00.420 --> 00:20:04.000
And obviously that on-the-fly
conversion is going to be expensive.

00:20:04.000 --> 00:20:09.230
So if you can, please use the compatible
image formats and try to avoid

00:20:09.660 --> 00:20:11.990
using something non-native.

00:20:12.760 --> 00:20:14.660
So let's talk about
some of the new things.

00:20:14.790 --> 00:20:16.410
It's not exactly new anymore.

00:20:16.420 --> 00:20:18.410
We announced it, I believe,
in December or so.

00:20:18.630 --> 00:20:20.370
But we haven't talked
about it on stage yet.

00:20:20.430 --> 00:20:24.920
So I wanted to mention that
Java AI is now available on Mac OS X.

00:20:24.960 --> 00:20:27.790
You saw a demo this Monday night
with the Mars Rover,

00:20:27.820 --> 00:20:32.790
the gentleman from the
JPL labs in Pasadena.

00:20:33.140 --> 00:20:36.960
and you know, it basically brings high
performance image processing,

00:20:36.960 --> 00:20:40.500
a number of new formats that are not
available in the standard Java AWT.

00:20:40.500 --> 00:20:45.500
You can do image
processing over a network.

00:20:45.500 --> 00:20:49.900
We did implement the native media
libcode from Sun and brought it over to

00:20:49.920 --> 00:20:53.400
Mac OS X so you can get the performance
that you would expect from JAI.

00:20:53.420 --> 00:20:54.900
And it's going to be included with Tiger.

00:20:54.900 --> 00:20:59.360
It's currently a download for you and
more importantly for your users if

00:20:59.390 --> 00:21:02.680
you're writing in JAI for Panther.

00:21:02.710 --> 00:21:03.960
It's available as a download.

00:21:03.980 --> 00:21:07.460
In Tiger, it will be pre-installed,
and you won't have to worry about it.

00:21:08.480 --> 00:21:12.050
And to the same tune,
Java3D was made available

00:21:12.110 --> 00:21:13.120
at the same time.

00:21:13.240 --> 00:21:14.660
It's a higher level 3D model.

00:21:14.660 --> 00:21:17.760
It's not really a direct
3D programming API.

00:21:17.760 --> 00:21:20.860
It's intended for higher level
scene graphing and things like that.

00:21:21.010 --> 00:21:23.420
It is platform independent,
so you can write applets

00:21:23.420 --> 00:21:24.840
and applications in 3D.

00:21:24.840 --> 00:21:27.790
We implemented...

00:21:27.910 --> 00:21:32.260
We implemented Java3D with
OpenGL and Core Audio for the audio.

00:21:32.520 --> 00:21:35.900
And like Java AI,
it'll be available in Tiger and

00:21:35.920 --> 00:21:39.280
currently available for
Panther as a separate download.

00:21:39.280 --> 00:21:41.460
And there's one other
thing to talk about,

00:21:41.480 --> 00:21:42.400
which is JOGL.

00:21:42.400 --> 00:21:45.540
I'd like to bring Ken Russell up
to talk to you about that.

00:21:52.250 --> 00:21:53.790
Good afternoon.

00:21:53.940 --> 00:21:55.000
So my name is Ken Russell.

00:21:55.000 --> 00:21:56.920
I'm at Sun Microsystems,
and I'm one of the authors

00:21:56.920 --> 00:21:59.450
of the JOGL package that you
may or may not have used.

00:21:59.490 --> 00:22:03.890
And Gerard and I worked a
bit on the JOGL port to OS X.

00:22:03.890 --> 00:22:05.310
So what is this package?

00:22:05.390 --> 00:22:09.500
It's a binding,
a Java binding for the OpenGL 3D API that

00:22:09.500 --> 00:22:13.470
works on as many platforms
as we could make it work on.

00:22:13.530 --> 00:22:17.300
In particular, OS X, it works on Linux,
it works on Solaris, it works on, yeah,

00:22:17.300 --> 00:22:17.960
Windows.

00:22:17.960 --> 00:22:21.760
And the intent here is to
let you write portable,

00:22:22.200 --> 00:22:24.540
fast 3D applications in Java.

00:22:24.540 --> 00:22:27.930
The binding is open source.

00:22:27.940 --> 00:22:29.720
It's part of Sun's
Java gaming initiative.

00:22:29.720 --> 00:22:31.360
You can get the source code on java.net.

00:22:31.370 --> 00:22:33.490
It's one of the core gaming API projects.

00:22:33.540 --> 00:22:37.280
We've got bindings to JOAL,
the open audio library.

00:22:37.280 --> 00:22:41.620
We've got an input device
binding called JInput,

00:22:41.620 --> 00:22:44.550
which lets you get inputs from, you know,
joysticks and keypads

00:22:44.550 --> 00:22:45.760
and stuff like that.

00:22:45.880 --> 00:22:50.970
Some of the features of this
OpenGL binding versus some of

00:22:50.970 --> 00:22:53.240
the others that are out there are
first of all that it supports all

00:22:53.240 --> 00:22:55.000
the stuff that's in OpenGL 1.5.

00:22:55.030 --> 00:22:57.250
So you use this,
you get all the latest stuff,

00:22:57.340 --> 00:22:58.460
all the latest vendor extensions.

00:22:58.460 --> 00:23:03.540
You can do vertex programs,
fragment programs, shader objects,

00:23:03.580 --> 00:23:04.100
all this stuff.

00:23:04.100 --> 00:23:06.660
It's got portable support for P buffers.

00:23:06.660 --> 00:23:09.420
So you can do hardware
accelerated off-screen

00:23:09.420 --> 00:23:22.160
rendering in a portable fashion,
get the results on screen very quickly.

00:23:22.160 --> 00:23:22.160
And where necessary,
you can actually dive down to

00:23:22.160 --> 00:23:22.160
the vendor-specific extensions.

00:23:22.160 --> 00:23:22.160
So it's like if you actually had to
use the wiggle APIs for some things,

00:23:22.160 --> 00:23:22.160
you could do that.

00:23:22.250 --> 00:23:26.390
You can sort of test to see what
platform you're on and then dive

00:23:26.390 --> 00:23:28.830
down into those APIs if necessary.

00:23:28.860 --> 00:23:32.700
We are working on
standardizing this binding.

00:23:32.700 --> 00:23:37.300
And the real reason for this is so
that we can get some amount of sort

00:23:37.300 --> 00:23:41.370
of compatibility guarantee for you,
the developer, on all the platforms that

00:23:41.370 --> 00:23:43.250
you're going to be deploying on.

00:23:43.280 --> 00:23:47.440
And another intent here is to try
to get the mobile device space

00:23:47.440 --> 00:23:51.880
and the desktop device space where
J2ME and SE have a bit of a rift.

00:23:52.140 --> 00:23:55.680
We're trying to make the OpenGL bindings
for these two platforms as similar

00:23:55.700 --> 00:23:59.140
as possible so that you'll be able
to effectively write a desktop app.

00:23:59.220 --> 00:24:02.280
And maybe when the cell phone
market and hardware acceleration

00:24:02.280 --> 00:24:04.660
down there catches up,
you'll actually be able to

00:24:04.720 --> 00:24:07.010
deploy basically the same
app on a mobile device,

00:24:07.220 --> 00:24:09.200
which would be really, really cool.

00:24:09.200 --> 00:24:14.190
So as I mentioned before,
JOGL supports multiple platforms.

00:24:14.200 --> 00:24:15.940
And what I'd like to point
out here are two things.

00:24:15.940 --> 00:24:18.180
First of all,
even if you're not using the

00:24:18.180 --> 00:24:21.940
AWT and that sort of framework and
you're using the Cocoa framework,

00:24:22.210 --> 00:24:24.120
you can use the
Java bindings for Mac OS X.

00:24:24.120 --> 00:24:26.120
JOGL actually supports that
configuration explicitly.

00:24:26.120 --> 00:24:32.460
So you can instantiate a little
Mac OS X GL Impel object and then

00:24:32.460 --> 00:24:37.890
treat it in exactly the same way as
you would in an AWT-based JOGL app.

00:24:38.400 --> 00:24:40.110
And it works.

00:24:40.120 --> 00:24:43.440
And we've got -- unfortunately,
we don't have a demo

00:24:43.440 --> 00:24:45.610
today showing this off,
but there have been demos developed in

00:24:45.720 --> 00:24:49.990
the past which have stressed this out.

00:24:50.300 --> 00:24:52.100
Another thing to mention is, again,
the fact that we're working on

00:24:52.100 --> 00:24:52.100
a lot of things in the future.

00:24:52.100 --> 00:24:53.340
So we're going to show you a
little bit of the full screen

00:24:53.340 --> 00:24:55.100
support that was just shown that's
working great with JOGL and OS X.

00:24:55.100 --> 00:24:59.040
So you can write full screen,
fully hardware accelerated

00:24:59.240 --> 00:25:00.100
games and apps.

00:25:00.100 --> 00:25:03.100
And we're going to actually show
one today that's pretty cool.

00:25:03.100 --> 00:25:05.100
And I see a point here on the
slide that I did not know,

00:25:05.100 --> 00:25:09.100
which is that this works well with
the new OpenGL profiler on -- oh,

00:25:09.100 --> 00:25:09.100
wait.

00:25:09.100 --> 00:25:12.100
Is this Shark or is this -- okay.

00:25:12.100 --> 00:25:14.100
So, well, it's working with the
OpenGL profiler on OS X,

00:25:14.100 --> 00:25:17.420
so it looks like you can get
fairly detailed information about

00:25:17.420 --> 00:25:19.100
what's going on in your apps.

00:25:19.220 --> 00:25:22.080
There are also a couple of -- I'm sorry.

00:25:22.080 --> 00:25:26.080
There are pipelines available
for the JOGL binding.

00:25:26.080 --> 00:25:29.060
And these let you get debugging
and tracing information.

00:25:29.080 --> 00:25:30.940
And this is sort of a
Java-specific feature,

00:25:30.940 --> 00:25:33.580
but it's extremely useful when
you're trying to debug something

00:25:33.580 --> 00:25:35.070
that's going wrong in your app.

00:25:35.080 --> 00:25:39.180
It will basically stop at the point
of failure at the actual OpenGL call

00:25:39.260 --> 00:25:44.080
that made the error state in the state
machine and give you a backtrace,

00:25:44.080 --> 00:25:45.070
which is pretty helpful.

00:25:45.080 --> 00:25:49.300
So what I'd like to show you is a really
cool demo done by a couple of crazy guys

00:25:49.380 --> 00:25:52.040
over in Germany called Bytonic Software.

00:25:52.090 --> 00:25:55.820
I assume that this is a play on
words of bionic versus bytonic.

00:25:56.430 --> 00:26:02.060
But so if we could go to
the demo 2 machine -- oh,

00:26:02.060 --> 00:26:02.060
wait.

00:26:02.350 --> 00:26:03.060
Aha.

00:26:03.060 --> 00:26:04.060
Wrong machine.

00:26:04.060 --> 00:26:04.930
Okay.

00:26:05.060 --> 00:26:09.060
What we're going to see
here is a full-screen app.

00:26:10.520 --> 00:26:13.430
Full screen little game that
you guys may have seen before.

00:26:13.640 --> 00:26:20.890
This is Quake 2.

00:26:24.400 --> 00:26:27.750
Now, what are you looking at here?

00:26:27.810 --> 00:26:32.840
This is not a new engine written in Java.

00:26:32.840 --> 00:26:36.870
Turn the sound down just a tad.

00:26:37.600 --> 00:26:41.840
Um, okay, so what you're looking at
here is not a new engine.

00:26:41.840 --> 00:26:45.840
Let me kill some guys here,
maybe they'll shut up a bit.

00:26:45.840 --> 00:26:47.760
Mute.

00:26:48.020 --> 00:26:50.070
On the keyboard, huh?

00:26:51.400 --> 00:26:52.150
Ah, nifty.

00:26:52.380 --> 00:26:53.420
Okay, thank you.

00:26:53.740 --> 00:26:57.750
All right,
so what we're looking at here is it's not

00:26:58.260 --> 00:27:04.670
a pure Java new sort of engine that is
written to use the Quake 2 file format.

00:27:04.680 --> 00:27:08.860
This is a port to the
Java programming language of the

00:27:08.860 --> 00:27:10.560
original C source for Quake 2.

00:27:10.560 --> 00:27:10.860
Whoa.

00:27:10.860 --> 00:27:14.120
Hold on a sec,
I'm going to kill some bad guys.

00:27:17.970 --> 00:27:19.220
Yeah, I got to take care of
some business first.

00:27:19.220 --> 00:27:19.460
Okay.

00:27:19.460 --> 00:27:20.380
All right.

00:27:20.380 --> 00:27:21.720
Yeah.

00:27:21.720 --> 00:27:22.480
Okay.

00:27:22.480 --> 00:27:26.900
So this is a port,
a straight transliteration of the

00:27:26.980 --> 00:27:31.740
C sources for Quake 2 that were
available via the GPL on id's website

00:27:31.740 --> 00:27:33.480
to the Java programming language.

00:27:33.480 --> 00:27:34.440
All right.

00:27:34.730 --> 00:27:38.290
They used jogl at the bottom layer
to get to the graphics subsystem,

00:27:38.290 --> 00:27:41.290
and they did whatever data
structure conversion was

00:27:41.290 --> 00:27:44.780
necessary from C to Java to be
able to use the pack file format,

00:27:44.780 --> 00:27:47.880
the original data files
from the game in this port.

00:27:47.900 --> 00:27:49.060
support.

00:27:49.520 --> 00:27:55.790
This is running at over 85% of the
speed of the original C sources.

00:28:02.260 --> 00:28:05.320
At this point,
there is no reason to not write

00:28:05.330 --> 00:28:07.050
your next game in the Java language.

00:28:07.070 --> 00:28:09.870
This binary runs on multiple platforms.

00:28:09.880 --> 00:28:13.720
It runs on OS X, it runs on Linux,
it runs on Windows, it runs on Solaris.

00:28:13.720 --> 00:28:16.020
Okay, no porting necessary.

00:28:16.480 --> 00:28:19.090
And now you can do even more cool
stuff because you're in Java.

00:28:19.120 --> 00:28:21.750
You can ship bytecodes around
the net and it's all safe.

00:28:21.840 --> 00:28:23.620
You can load new stuff in,
new functionality,

00:28:23.620 --> 00:28:24.780
download it to the client.

00:28:24.780 --> 00:28:28.160
You don't have to worry about, you know,
oh gee, did I just open up the door

00:28:28.210 --> 00:28:30.090
for the next Sasser virus,
for example,

00:28:30.090 --> 00:28:33.340
because you've got a security manager
in place and the access is all safe

00:28:33.340 --> 00:28:35.370
to the underlying hardware features.

00:28:35.380 --> 00:28:38.490
So this is actually an
open source project.

00:28:38.490 --> 00:28:43.760
You can go to the Bytonic software
website and the demo is called Jake2 for,

00:28:43.760 --> 00:28:46.100
you know, Quake 2 to Java.

00:28:46.580 --> 00:28:48.950
So what you can do is just
Google for Jake2 and they are,

00:28:49.010 --> 00:28:50.270
I think, the first hit.

00:28:50.570 --> 00:28:51.870
There are websites out there.

00:28:51.920 --> 00:28:54.480
You can get the binaries,
you can get the source code,

00:28:54.490 --> 00:28:57.430
and I would encourage you to send
them feedback because I think

00:28:57.520 --> 00:28:59.240
that this is just awesome stuff.

00:28:59.500 --> 00:29:03.050
They did what a lot of us have been
talking about doing for a long time,

00:29:03.330 --> 00:29:05.410
which is, gee,
what would happen if we had the

00:29:05.800 --> 00:29:08.410
huge commercial apps side by side,
C and Java?

00:29:08.420 --> 00:29:09.320
How fast would it be?

00:29:09.320 --> 00:29:11.890
This is showing that
it's pretty darn fast.

00:29:11.940 --> 00:29:14.570
I think that's pretty much it.

00:29:19.410 --> 00:29:19.960
Thanks a lot, Ken.

00:29:19.960 --> 00:29:20.500
Awesome.

00:29:20.500 --> 00:29:24.160
Well, thanks, Ken.

00:29:24.160 --> 00:29:28.210
I kind of hijacked Ken with
that OpenGL profiler bullet.

00:29:28.220 --> 00:29:30.740
At the last minute,
we decided he was going

00:29:30.740 --> 00:29:31.960
to say this slide.

00:29:32.000 --> 00:29:33.620
So, yeah, he didn't know about that.

00:29:33.720 --> 00:29:37.330
I was talking to some of the OpenGL guys,
as well as Gerard,

00:29:37.330 --> 00:29:40.300
about the fact that you can
use the OpenGL profiler to

00:29:40.600 --> 00:29:42.850
profile a jogl application.

00:29:42.940 --> 00:29:46.760
Now, it's not going to give you, I mean,
it is a C-based profiler.

00:29:47.130 --> 00:29:51.380
But because jogl, or J-O-G-L,
is a wrapper, it's pretty straightforward

00:29:51.380 --> 00:29:53.420
as to what it's talking about.

00:29:53.420 --> 00:29:55.500
And you get a list of functions,
and they may be C functions.

00:29:55.500 --> 00:29:57.780
But, you know,
the names are very similar,

00:29:57.780 --> 00:30:01.610
and it's usually pretty easy to tell
what's going on in your jogl app versus

00:30:01.660 --> 00:30:03.940
what the OpenGL profiler is reporting.

00:30:06.330 --> 00:30:07.600
And again, we demoed JAG 2.

00:30:07.600 --> 00:30:12.190
That's the bitonic.de, as in Germany,
link if you want to check it out.

00:30:12.190 --> 00:30:13.740
And yeah, it's pretty cool.

00:30:13.740 --> 00:30:15.930
We've been playing it quite a bit.

00:30:18.580 --> 00:30:20.250
So in conclusion,
we're going to let you guys out

00:30:20.250 --> 00:30:23.510
early today because it's Friday,
but we're working on it.

00:30:23.510 --> 00:30:25.970
We've heard a lot of your feedback,
and we know that we've

00:30:25.980 --> 00:30:28.210
had a lot of work to do,
and we've done a lot of it.

00:30:28.250 --> 00:30:30.530
We've done a lot to improve
correctness in drawing.

00:30:30.530 --> 00:30:34.280
We've done a lot to improve
drawing performance.

00:30:34.280 --> 00:30:37.180
We've done a lot with system integration,
especially we've been working

00:30:37.180 --> 00:30:39.610
very closely with the Quartz
team to make sure that everything

00:30:39.650 --> 00:30:41.640
in Tiger is working smoothly,
not only for Quartz,

00:30:41.680 --> 00:30:42.760
but for Java as well.

00:30:42.760 --> 00:30:45.470
And we've got these new
APIs available to you,

00:30:45.530 --> 00:30:48.360
Java3D, JavaAI, and of course, JOGL.

00:30:48.500 --> 00:30:49.660
Thank you.

00:30:49.870 --> 00:30:52.500
We want to make sure that you
do use your images wisely.

00:30:52.730 --> 00:30:55.810
Use the Java APIs to
create a compatible format.

00:30:55.810 --> 00:31:00.720
And try not to manipulate pixels directly
if you don't know what kind of format

00:31:00.720 --> 00:31:02.200
you're using or what you need to use.

00:31:02.200 --> 00:31:03.220
And check out jogl.

00:31:03.220 --> 00:31:04.820
And write your games in Java.

00:31:04.820 --> 00:31:06.240
You really can do it now.

00:31:06.240 --> 00:31:08.010
There's really nothing stopping you.

00:31:10.200 --> 00:31:12.240
So for more information,
obviously we gave you

00:31:12.240 --> 00:31:13.460
the Bitonic link earlier.

00:31:13.460 --> 00:31:17.260
We've got a DMG, of course,
with every session.

00:31:17.260 --> 00:31:21.680
The reference library is available
to you for all the Java items.

00:31:21.710 --> 00:31:24.250
We should have a tech note
coming out for image performance

00:31:24.280 --> 00:31:27.320
tips and the kind of things that
I talked very much in brief today.

00:31:27.780 --> 00:31:30.650
And there's a great article,
which is not new at all,

00:31:30.650 --> 00:31:34.400
about painting in AWT and Swing and
what the expected behavior should

00:31:34.400 --> 00:31:36.550
be on a standard Java2 platform.

00:31:36.550 --> 00:31:39.780
And these are the kind of rules
or guidelines that you should

00:31:39.780 --> 00:31:43.280
keep in mind when you start to do
a lot of heavy drawing in Java.

00:31:43.280 --> 00:31:46.170
This is a really priceless article,
and it's very similar to some of

00:31:46.170 --> 00:31:47.740
the stuff I talked about today.

00:31:47.740 --> 00:31:50.420
I took a lot of my
information from that article.

00:31:50.420 --> 00:31:53.500
The JOGL homepage is off java.net.

00:31:53.700 --> 00:31:55.840
And, of course,
you can go to java.sun.com for

00:31:55.870 --> 00:31:57.760
anything else you're interested in.

00:31:57.780 --> 00:31:58.770
in that's not listed here.
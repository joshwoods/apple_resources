WEBVTT

00:00:12.250 --> 00:00:15.200
Ladies and gentlemen,
please welcome our first presenter,

00:00:15.200 --> 00:00:18.720
Senior Networking Engineer,
Laurent Dumont.

00:00:25.080 --> 00:00:27.360
Good morning, everybody,
and welcome to the

00:00:27.400 --> 00:00:28.940
Core Networking Update.

00:00:29.160 --> 00:00:35.000
So this morning we'll talk
about the goal of this session

00:00:35.000 --> 00:00:36.880
for the Core Networking Update.

00:00:37.260 --> 00:00:40.850
We want to do an overview of
Mac OS X networking and the

00:00:41.180 --> 00:00:46.120
different components that are
involved in networking for Mac OS X.

00:00:46.120 --> 00:00:50.450
And of course, we'll also talk about
what is new in Tiger,

00:00:50.560 --> 00:00:53.940
because Tiger is a big
theme for this WWDC.

00:00:55.000 --> 00:00:58.140
And also,
in the second part of the session,

00:00:58.180 --> 00:01:01.000
we'll have a networking API overview.

00:01:01.000 --> 00:01:06.140
We'll go through the different level of
APIs that we have in Mac OS X for—which

00:01:06.140 --> 00:01:11.850
are related to networking and try to see,
you know, which API belong for you as

00:01:11.850 --> 00:01:17.760
an application or a developer,
which API to use best fit, you know,

00:01:17.760 --> 00:01:18.340
what you're doing.

00:01:18.340 --> 00:01:21.380
So we'll look at that.

00:01:21.700 --> 00:03:19.700
[Transcript missing]

00:03:20.380 --> 00:03:27.290
All the problems that are found
are fixed as rapidly as we can.

00:03:27.300 --> 00:03:29.200
So that's another goal.

00:03:29.200 --> 00:03:32.180
Extensibility,
we'll talk about some new things that

00:03:32.180 --> 00:03:36.960
we've done this year for Tiger to
extend the networking in different ways

00:03:36.960 --> 00:03:42.300
for you guys to be able to create your
own KEXTs and those kind of things.

00:03:42.300 --> 00:03:43.320
So we'll go in detail into that.

00:03:44.550 --> 00:03:46.700
Another, of course,
ongoing goal is standards.

00:03:46.700 --> 00:03:50.550
We're very, very close to standards.

00:03:50.640 --> 00:03:54.010
We're trying to make sure that we
follow all the standards and we're a

00:03:54.010 --> 00:03:58.770
good citizen in terms of a networking
world where different nodes are coming

00:03:58.770 --> 00:04:03.510
from different vendors and different,
you know, vision of the world.

00:04:03.520 --> 00:04:07.310
We're trying to make sure that
we not only follow standards,

00:04:07.430 --> 00:04:11.080
but we also give some room to
interpretation when some usage

00:04:11.080 --> 00:04:13.920
things are closer to the realities
and the needs of the world.

00:04:14.670 --> 00:04:16.140
And closer to the standards.

00:04:16.140 --> 00:04:18.870
So that's one big focus for us
also in the core networking,

00:04:18.870 --> 00:04:21.210
making sure that we
follow all the standards.

00:04:23.980 --> 00:04:27.790
So here we got a little
graphic trying to explain,

00:04:27.790 --> 00:04:36.260
remind you probably for most of you,
how networking in Mac OS X is structured.

00:04:36.260 --> 00:04:40.190
So if we look at the lower part,
the kernel part,

00:04:40.330 --> 00:04:45.980
one of the big components of the
Mac OS X networking is in the kernel.

00:04:45.980 --> 00:04:49.550
Just as a reminder, the downwind kernel,
which is open source,

00:04:49.590 --> 00:04:53.760
so you guys can check out the sources
and check all the code in the kernel.

00:04:53.800 --> 00:04:54.800
So the kernel is there.

00:04:54.800 --> 00:04:58.350
It's made pretty much of
the BSD part of the kernel,

00:04:58.400 --> 00:05:03.250
which has a networking part on your left,
which is a little bit highlighted,

00:05:03.250 --> 00:05:04.680
and the file system.

00:05:04.680 --> 00:05:08.850
Also in the downwind kernel,
we have the Mac kernel part,

00:05:08.900 --> 00:05:12.870
which provides the basic OS services,
scheduling, memory,

00:05:12.870 --> 00:05:14.910
all those kind of neat stuff.

00:05:14.920 --> 00:05:22.050
Underneath that, we have the IOCit layer,
which, as driver developers know,

00:05:22.180 --> 00:05:24.880
is what provides the
interface with your driver,

00:05:24.880 --> 00:05:28.750
hardware driver, for a networking card
or something like that.

00:05:28.750 --> 00:05:33.920
So if we focus a little
bit inside that part,

00:05:33.920 --> 00:05:39.130
which is the networking,
we're based on a BSD stack.

00:05:39.150 --> 00:05:44.640
So we have, of course, you probably know,
the socket layer on top of that,

00:05:44.750 --> 00:05:47.600
which mirrors a
BSD socket from user land.

00:05:47.870 --> 00:05:52.570
Underneath that, we got TCP, UDP, IPv6,
IPv4, IPsec.

00:05:52.570 --> 00:05:56.030
All those are part of the kernel,
and we have,

00:05:56.180 --> 00:06:02.220
and this is part of what you'll find
in a standard of BSD-like system,

00:06:02.460 --> 00:06:06.190
and we have a little difference here,
which somehow mirror the

00:06:06.210 --> 00:06:10.560
IOCit layer for driver,
which is the data link interface layer,

00:06:10.600 --> 00:06:14.260
which is something specific
that we have for you to hook up,

00:06:14.490 --> 00:06:18.460
you know, pseudo drivers or drivers
in the networking stack.

00:06:18.610 --> 00:06:21.110
So that's how the system is structured.

00:06:21.110 --> 00:06:27.410
On top of that, on user land,
we have the BSD socket, which provide us,

00:06:27.460 --> 00:06:31.720
you know,
basically the POSIX-like and all the

00:06:31.720 --> 00:06:37.100
Unix-like socket interface that most
of our other layers are based on,

00:06:37.100 --> 00:06:40.500
the layers using networking.

00:06:40.530 --> 00:06:43.910
And on top of BSD socket,
we get core services,

00:06:43.980 --> 00:06:48.330
which we'll go into more detail
about the API for that level,

00:06:48.330 --> 00:06:51.940
which are based,
CF networks and all those guys,

00:06:51.960 --> 00:06:53.720
which are based on the BSD socket.

00:06:53.720 --> 00:06:56.410
So that's how we get the BSD sockets,
or client of the BSD sockets.

00:06:56.610 --> 00:07:00.670
And of course, on top of that,
we have probably your application,

00:07:00.730 --> 00:07:04.080
which may talk directly to
the core services through

00:07:04.080 --> 00:07:07.870
CF network or some other layer,
or directly to BSD socket,

00:07:07.870 --> 00:07:12.030
or maybe a combination of both,
or could also talk directly to the

00:07:12.030 --> 00:07:17.290
kernel through some other means that
we'll talk about during the session.

00:07:17.300 --> 00:07:18.510
So,

00:07:19.380 --> 00:07:22.750
So, yeah,
this is a little bit of a highlight

00:07:22.750 --> 00:07:28.300
about what we're going to be
talking about here in this session.

00:07:28.300 --> 00:07:36.060
We're focusing on the networking
part of the kernel and the BSD socket

00:07:36.060 --> 00:07:36.060
and the other layers on top of that.

00:07:37.100 --> 00:11:42.000
[Transcript missing]

00:11:43.700 --> 00:13:29.000
[Transcript missing]

00:13:30.200 --> 00:13:33.430
Final kernel fine-grain locking, OK.

00:13:33.710 --> 00:13:36.570
So why do we need?

00:13:36.660 --> 00:13:42.480
Well, to have a little recap here,
we said we're using the

00:13:42.480 --> 00:13:45.750
BSD side of the networking,
the stack and everything.

00:13:45.850 --> 00:13:49.980
BSD historically has one in the kernel.

00:13:49.980 --> 00:13:52.000
You get one thing that's
going on at a time.

00:13:52.170 --> 00:13:57.460
So what we did previously in
Mac OS X is that we had the

00:13:57.460 --> 00:14:02.830
mechanism which we called funnel,
which means that we were trying-- because

00:14:02.900 --> 00:14:06.820
we have a lot of machines that are SMP,
so we got XSERVs,

00:14:06.880 --> 00:14:10.280
but even your G5 and everything,
most of them have two

00:14:10.510 --> 00:14:12.100
processors nowadays.

00:14:12.320 --> 00:14:18.540
So in order to not be completely locked
into the kernel where one thing can go at

00:14:18.560 --> 00:14:22.240
a time and everything is waiting for it,
we used to have this

00:14:22.310 --> 00:14:27.460
mechanism we called funnel,
which basically let us do on the

00:14:27.460 --> 00:14:30.560
one processor some networking
operation while the other

00:14:30.670 --> 00:14:35.000
processor might be doing userland
operation or file system operation.

00:14:35.110 --> 00:14:38.290
So we had this kind of split
personality in the kernel where

00:14:38.720 --> 00:14:42.820
only two things could go at a time,
but two different things,

00:14:42.820 --> 00:14:45.890
so we couldn't have two
networking operation going on.

00:14:46.030 --> 00:14:50.010
So the problem with that is this model,
we've lived with it for a while,

00:14:50.100 --> 00:14:52.840
and it's been working pretty well,
but it's got some

00:14:52.970 --> 00:14:54.660
fundamental issue with it.

00:14:54.690 --> 00:14:57.220
And one of them is not really scalable.

00:14:57.220 --> 00:15:00.070
When you're a server, like an XSERV,
and you're trying to do just

00:15:00.210 --> 00:15:04.260
net traffic and everything
is going through your cache,

00:15:04.260 --> 00:15:07.110
you don't do any file system operation.

00:15:07.370 --> 00:15:10.900
And basically,
you have one CPU which is really loaded,

00:15:10.900 --> 00:15:12.660
and the other one is kind of idle.

00:15:12.790 --> 00:15:17.050
So because everything is
going for the networking,

00:15:17.050 --> 00:15:21.630
and so there's this big funnel
which blocks everything.

00:15:21.760 --> 00:15:27.060
So what we did in Tiger is that we
changed the underpinning of all this.

00:15:27.060 --> 00:15:28.230
So we changed the
underpinning of all this by,

00:15:28.230 --> 00:15:34.830
instead of having those two big locks,
having finer grain locking at different

00:15:34.830 --> 00:15:38.500
level in the networking stack and
in the rest of the kernel so that

00:15:38.500 --> 00:15:43.870
we can have simultaneous operation
going on for different operation,

00:15:43.880 --> 00:15:47.130
both in the file system
and in the networking.

00:15:47.280 --> 00:15:52.120
So another thing that we added here
is-- and that was part of our previous

00:15:52.120 --> 00:15:55.730
model issues-- is that we didn't
have reference counting for objects.

00:15:55.900 --> 00:15:57.900
So if you add a number of objects,
you're going to have a lot of problems.

00:15:57.900 --> 00:16:01.330
So if you added multicast addresses,
let's say, we didn't really keep track of

00:16:01.440 --> 00:16:02.900
who added multicast addresses.

00:16:02.900 --> 00:16:03.620
We removed it.

00:16:03.620 --> 00:16:07.620
And in some corner cases,
we might have some issue

00:16:07.620 --> 00:16:13.070
where we lost reference,
and so that multicast address was leaked.

00:16:13.180 --> 00:16:16.850
So we had some problem with some
objects that might leak or might

00:16:16.850 --> 00:16:19.290
not be in the right situation.

00:16:19.410 --> 00:16:26.740
So we're fixing that with a fine grain
locking in the kernel and by having new--

00:16:26.740 --> 00:16:32.100
new ref counting for most of the objects
that we're using in the networking.

00:16:32.140 --> 00:16:36.660
And one other thing about this is
that it's transparent to application.

00:16:36.660 --> 00:16:38.800
It's really only in the
kernel that we're changing.

00:16:38.930 --> 00:16:43.680
The socket layer and all the
programming model for applications

00:16:43.680 --> 00:16:46.350
that are in user land doesn't change.

00:16:46.450 --> 00:16:49.910
However,
this is a new model for kernel extensions

00:16:50.250 --> 00:16:54.390
because we're changing so many things
in the way the stack is structured that

00:16:54.390 --> 00:16:56.580
kernel extension will have to change.

00:16:56.580 --> 00:16:58.120
We'll talk about that.

00:16:58.270 --> 00:17:03.540
So the biggest reason for
going with finer grain locking,

00:17:03.610 --> 00:17:06.480
symmetric multiprocessing
is getting a big thing.

00:17:06.660 --> 00:17:12.240
So arrays of XSERVs and everything,
we're trying to get maximum

00:17:12.240 --> 00:17:14.550
power out of those machines.

00:17:14.780 --> 00:17:18.640
And to do that,
we had to do some changes.

00:17:18.630 --> 00:17:24.690
So the SMP improvements that we've done,
this is those finer grain looking,

00:17:24.740 --> 00:17:28.070
you know,
networking and file systems will be

00:17:28.070 --> 00:17:31.180
better because we get some parallelism.

00:17:31.180 --> 00:17:34.290
We optimize the data layout
in the kernel by having,

00:17:34.340 --> 00:17:37.310
you know,
those locks by finer objects instead of

00:17:37.320 --> 00:17:42.390
having one big lock that gets everything,
reference counting, and also provide,

00:17:42.550 --> 00:17:46.380
because we're changing all this,
at the same time we're providing

00:17:46.380 --> 00:17:48.580
new stable kernel interface.

00:17:48.600 --> 00:17:52.580
That go beyond I/O Kit.

00:17:52.580 --> 00:17:57.270
So as a kernel extension writer,
you'll be able to use some

00:17:57.280 --> 00:17:59.600
more stable interfaces.

00:17:59.600 --> 00:18:05.600
So I've been talking about all this,
but anyways, just as a reminder,

00:18:05.600 --> 00:18:10.600
this is what kernel locking
is for the BSD sign in Pantor.

00:18:10.650 --> 00:18:16.380
So we see on the left,
networking stack in the file system,

00:18:16.380 --> 00:18:20.330
and both of them are just, you know,
funneled by those big locks where

00:18:20.720 --> 00:18:25.580
everything coming in or out is all,
you know, stopped by this lock.

00:18:25.580 --> 00:18:29.880
So you need to acquire that lock
before you can do any networking

00:18:29.880 --> 00:18:30.960
operation or file system operation.

00:18:30.960 --> 00:18:34.920
So now if we zoom in into the
networking stack in Tiger,

00:18:34.920 --> 00:18:40.830
we see at the socket layer,
we get some smaller locks here.

00:18:40.960 --> 00:18:44.560
At the protocol layer, same thing,
and the interface layer, same thing.

00:18:44.560 --> 00:18:50.250
So what it means is that if, let's say,
one application is doing

00:18:50.250 --> 00:18:55.980
a socket operation on,
let's say, socket A on TCP, it will be,

00:18:55.980 --> 00:18:58.160
at the same time,
we'll be able to perform another

00:18:58.180 --> 00:19:01.660
operation in another socket without,
you know,

00:19:01.660 --> 00:19:04.940
contending for that one lock and
serializing all those operations.

00:19:04.940 --> 00:19:09.000
So we're getting this more
parallelism I was talking about.

00:19:09.000 --> 00:19:10.760
So that's going to be a big win.

00:19:10.760 --> 00:19:12.420
This is our new model.

00:19:12.420 --> 00:19:15.670
It's still an evolving model,
but pretty much this is the direction

00:19:15.740 --> 00:19:21.950
we're going on where we're going to get,
you know, finer locks and finer,

00:19:22.140 --> 00:19:27.810
you know, entities that get, yeah,
get locked.

00:19:30.690 --> 00:19:34.040
So we can have more parallelism
on different sockets.

00:19:34.040 --> 00:19:39.870
And they're doing the same
thing for the file system.

00:19:39.870 --> 00:19:39.870
And there's a session this afternoon
that will explain all that.

00:19:40.170 --> 00:19:44.250
So the other big change that we
have in the kernel part this year,

00:19:44.370 --> 00:19:48.070
which is related to the change
for the final grain locking,

00:19:48.140 --> 00:19:50.850
is the kernel programming interfaces.

00:19:50.910 --> 00:19:55.300
For about three, four years I think now,
we've been telling people

00:19:55.300 --> 00:19:59.520
we're writing kernel extension,
network kernel extension.

00:19:59.520 --> 00:20:01.820
Next year we're going to break you.

00:20:02.060 --> 00:20:03.680
We're changing all this.

00:20:03.690 --> 00:20:05.730
Well, this is a year.

00:20:05.780 --> 00:20:09.950
So there is a full session
about this this afternoon.

00:20:09.950 --> 00:20:13.600
But what happened is that because
we had to change all those

00:20:13.600 --> 00:20:17.220
kernel structures for locking,
for ref counting and everything,

00:20:17.300 --> 00:20:25.110
it was the right time to provide a new
API for you guys who are writing kernel

00:20:25.110 --> 00:20:30.850
extensions that kind of isolates from the
implementation of the networking stacks

00:20:30.850 --> 00:20:33.140
and of the internal of what we're doing.

00:20:34.130 --> 00:20:37.600
So we have more way to improve
it or change it or fix bug.

00:20:37.600 --> 00:20:40.180
We had a lot of problems
in the past few years.

00:20:40.190 --> 00:20:44.000
We're trying to fix bugs and
we needed a new field in one

00:20:44.090 --> 00:20:46.260
of the structure in the kernel.

00:20:46.280 --> 00:20:50.550
And we've never been able to do
the right fix because some kernel

00:20:51.170 --> 00:20:56.480
extension which was linked against the
kernel was using that field or that

00:20:56.480 --> 00:21:01.220
structure and by adding a new field,
we were just breaking them.

00:21:01.220 --> 00:21:03.080
So that's not a sustainable model.

00:21:04.140 --> 00:21:05.440
So we have a lot of problems in
the long run and where to scramble

00:21:05.440 --> 00:21:08.260
and find ways to get around that.

00:21:08.260 --> 00:21:13.000
With this new model that we're
introducing for the final grain locking

00:21:13.000 --> 00:21:17.060
and the new kernel programming interface,
you will not be able to get

00:21:17.060 --> 00:21:18.640
through the structure directly.

00:21:18.640 --> 00:21:24.640
There won't be an intimate knowledge
of the kernel implementation.

00:21:24.740 --> 00:21:28.900
That way we can change your live
accessors and those kind of things.

00:21:28.900 --> 00:21:31.030
And that way we can change
the implementation without

00:21:31.030 --> 00:21:32.030
disturbing the text.

00:21:32.330 --> 00:21:33.040
So we have a lot of
problems in the long run.

00:21:33.040 --> 00:21:35.740
And we had to scramble and you know,
itself.

00:21:36.100 --> 00:21:39.960
That issue with the NKs today is
that they have an intimate knowledge

00:21:39.980 --> 00:21:41.120
of the kernel implementation.

00:21:41.120 --> 00:21:46.490
Basically, they need to be relinked each
time we're changing something.

00:21:46.590 --> 00:21:50.120
And there is some confusion
with those interfaces and some

00:21:50.120 --> 00:21:51.570
missing functionality also.

00:21:51.730 --> 00:21:52.680
So we're addressing that.

00:21:52.770 --> 00:21:54.540
There's new KPIs.

00:21:54.540 --> 00:21:58.810
The kernel structures are opaque now.

00:21:59.060 --> 00:22:03.090
And there is accessor functions to
do all those things that you used

00:22:03.440 --> 00:22:09.110
to do by directly calling into or
directly accessing those structures.

00:22:09.450 --> 00:22:12.780
One other thing, we just talked about
the new locking model.

00:22:12.840 --> 00:22:15.700
The locking and the reference
counting are implicit.

00:22:15.840 --> 00:22:19.640
So when you're doing one operation,

00:22:19.970 --> 00:22:22.500
with your NKE on a socket
or something like that,

00:22:22.630 --> 00:22:27.310
will take care of locking that
socket for you and ref counting it.

00:22:27.320 --> 00:22:30.600
But, you know,
we're not doing the wall job.

00:22:30.660 --> 00:22:35.900
You will now be responsible for doing
your own locking of your own structures.

00:22:35.900 --> 00:22:38.880
Because before,
you were protected by those funnels

00:22:38.880 --> 00:22:42.040
where nobody else could get into your
structure when you were in there.

00:22:42.040 --> 00:22:44.860
Now,
because of the simultaneous operation

00:22:44.880 --> 00:22:49.400
we can get with the finer-grain locking,
it's really possible that, you know,

00:22:49.400 --> 00:22:53.600
multiple threads will be, or your KEXT,
you know, globals,

00:22:53.660 --> 00:22:55.990
will be accessed by multiple
threads for all we know.

00:22:56.000 --> 00:22:58.740
So you need to,
and we'll provide primitive for that,

00:22:58.740 --> 00:23:01.260
you need to lock your own structure also.

00:23:01.260 --> 00:23:06.100
So one of the other things with
those kernel programming interfaces

00:23:06.230 --> 00:23:09.480
is that we're providing a more
consistent behavior across API.

00:23:09.480 --> 00:23:10.630
So there was some confusion.

00:23:10.740 --> 00:23:12.540
We're trying to address that.

00:23:12.620 --> 00:23:17.620
And the drawback of all this, as I said,
for years we said,

00:23:17.660 --> 00:23:18.300
we're going to break you.

00:23:18.700 --> 00:23:24.340
The Panther NKEs that you have right now,
the kernel extensions, well,

00:23:24.340 --> 00:23:26.640
they will need to be
reworked to work on Tiger.

00:23:26.640 --> 00:23:29.390
Because there is no way,
by doing the extensive changes

00:23:29.390 --> 00:23:32.300
we've done in the kernel,
we can provide compatibility

00:23:32.300 --> 00:23:36.830
with those NKEs that were,
you know, basically fetching stuff out of

00:23:36.890 --> 00:23:38.680
structures and linking directly.

00:23:38.680 --> 00:23:40.930
So there is no way for that.

00:23:42.610 --> 00:23:46.560
So just a little overview here
about the networking KPI levels

00:23:46.560 --> 00:23:49.120
that we introduced this year.

00:23:49.120 --> 00:23:57.100
We got in dark blue here, we got socket,
you know, socket—well, we got socket KPI,

00:23:57.100 --> 00:24:01.280
socket filter, IP filter,
plumber functions, interface filter,

00:24:01.280 --> 00:24:02.350
and interface.

00:24:02.360 --> 00:24:09.620
And so there is a full session
this afternoon at 3:30 talking

00:24:09.730 --> 00:24:13.300
about those new networking KPI.

00:24:13.300 --> 00:24:17.310
So if you're interested in this,
I highly recommend to go and see all the

00:24:17.310 --> 00:24:19.250
glory details about what's going on here.

00:24:19.350 --> 00:24:24.570
But I just—for people who are, you know,
just new to networking here and

00:24:24.630 --> 00:24:29.790
so just want to make sure that
you understand that KPI— I mean,

00:24:29.790 --> 00:24:32.300
the NKs are really a
large number of things.

00:24:32.300 --> 00:24:37.300
So I think it's really important to use
them as far as a last resort solution

00:24:37.300 --> 00:24:41.230
as a networking developer to do some
things that you cannot do in user land.

00:24:41.350 --> 00:24:44.240
It's good for doing things
like content inspection.

00:24:44.240 --> 00:24:45.610
You know,
you're trying to see what's going

00:24:45.610 --> 00:24:48.150
on in all the packets coming
in from one interface or on one

00:24:48.490 --> 00:24:50.240
socket to do pseudo interfaces.

00:24:50.240 --> 00:24:52.240
It's very specific things.

00:24:52.240 --> 00:24:56.240
Packet filtering or you're trying
to do a network file system.

00:24:56.240 --> 00:25:02.240
So those are good cases
where you can use NKs.

00:25:02.360 --> 00:25:06.240
But I would like first to see if you
cannot do that in user land because

00:25:06.240 --> 00:25:08.830
working in user land is way with,
you know,

00:25:08.830 --> 00:25:10.240
easier than working in the kernel.

00:25:10.240 --> 00:25:12.240
In the kernel, you can panic and now we
introduce a new thing.

00:25:12.240 --> 00:25:14.240
You can deadlock, you know.

00:25:14.240 --> 00:25:19.750
So—and those things are not really
easy to debug for your user if your

00:25:19.750 --> 00:25:22.240
program doesn't work very well.

00:25:22.240 --> 00:25:24.240
You know, it will panic.

00:25:24.240 --> 00:25:26.240
It will give a bad experience.

00:25:26.250 --> 00:25:30.040
So the performance advantage of
working in the kernel for most

00:25:30.360 --> 00:25:32.180
things is really negligible.

00:25:32.180 --> 00:25:36.860
So unless you have a, you know,
really good reason, you know,

00:25:36.860 --> 00:25:39.180
do what you have to do in user land.

00:25:39.180 --> 00:25:44.170
We provide and we'll go through
this a bunch of other way to access

00:25:44.170 --> 00:25:48.160
APIs and access some of the kernel
functionality from user land.

00:25:48.240 --> 00:25:54.070
So as much as you can,
it's recommended that you use that.

00:25:54.180 --> 00:25:56.180
So yeah,
programming in the kernel is dangerous.

00:25:56.180 --> 00:25:59.410
And, you know,
go see the session this afternoon

00:25:59.410 --> 00:26:02.120
at 3:30 to get all the information.

00:26:02.120 --> 00:26:09.280
All the detail about—we'll go through all
those APIs and see what they're doing and

00:26:09.280 --> 00:26:11.120
exactly what you have to do with that.

00:26:12.200 --> 00:28:05.400
[Transcript missing]

00:28:05.740 --> 00:28:09.270
So VPN improvements,
so the VPN was introduced

00:28:09.420 --> 00:28:14.300
last year for Tiger,
for Panther, and for Tiger we were

00:28:14.300 --> 00:28:17.190
introducing a side-to-side VPN.

00:28:17.350 --> 00:28:21.630
It's based on the IPsec tunnel mode,
something that was requested by some

00:28:21.630 --> 00:28:27.210
organization where they want to have
a VPN between two XSERVs in between

00:28:27.210 --> 00:28:33.480
here and somewhere else in the world,
and they want to have a side-to-side VPN,

00:28:33.480 --> 00:28:37.780
not just a VPN where you connect
to one server as a client.

00:28:37.780 --> 00:28:39.820
Both sites are connected to the VPN.

00:28:39.900 --> 00:28:44.280
So we're introducing this in Tiger.

00:28:44.290 --> 00:28:48.860
We also have one new thing here,
which is VPN support for

00:28:48.900 --> 00:28:51.810
something that we call split DNS.

00:28:51.940 --> 00:28:59.660
So a little word of explanation here
is that at Apple we're using our own

00:28:59.660 --> 00:29:02.200
VPN solution to connect from here.

00:29:02.200 --> 00:29:04.270
I see people-- my manager.

00:29:04.370 --> 00:29:06.870
He's connected through
VPN to the Apple network,

00:29:06.940 --> 00:29:08.370
checking his email, I'm sure.

00:29:08.450 --> 00:29:13.950
And so he's using our technology
here to get to the Apple campus,

00:29:13.950 --> 00:29:15.100
to the Apple network.

00:29:15.210 --> 00:29:19.010
And what happened is that
right now we have only one DNS.

00:29:19.140 --> 00:29:26.030
So every DNS request that you're doing,
even if he's trying to go to yahoo.com,

00:29:26.030 --> 00:29:30.610
it's going to go through the
Apple DNS to get that request.

00:29:30.710 --> 00:29:33.610
With the split DNS,
what it does is that instead of--

00:29:34.280 --> 00:29:38.520
of going-- having all the requests
going through the Apple DNS,

00:29:38.520 --> 00:29:44.300
if we see it's not an Apple related,
it's a VPN related request,

00:29:44.300 --> 00:29:47.460
we're going to go to
whatever your provider is,

00:29:47.460 --> 00:29:53.280
your sbc.com DNS server,
instead of going all the

00:29:53.280 --> 00:29:54.680
way through the Apple DNS.

00:29:54.680 --> 00:29:59.230
That means that there is less
traffic on your VPN for traffic,

00:29:59.430 --> 00:30:04.160
which doesn't really belong to the
secure network you're trying to access.

00:30:04.160 --> 00:30:09.160
So-- so that's one thing that we're
introducing in the VPN support for Tiger.

00:30:09.720 --> 00:30:15.430
Also, something that was really asked for
is support for user certificates.

00:30:15.500 --> 00:30:18.210
So we're using AAPTLS for that.

00:30:18.220 --> 00:30:22.870
So now the VPN will support certificates.

00:30:23.700 --> 00:30:28.340
Um,
another thing that is pretty new is VLAN,

00:30:28.340 --> 00:30:32.560
so 802.1Q tagging support.

00:30:32.560 --> 00:30:35.900
Right now it's for server only.

00:30:36.340 --> 00:30:40.280
So you probably are familiar
with what VLAN does,

00:30:40.720 --> 00:30:43.640
but what we did there is that we
have the support for the VLAN.

00:30:43.640 --> 00:30:47.540
It's integrated in the
network preferences.

00:30:47.540 --> 00:30:49.640
You can also do that
through the command line,

00:30:49.640 --> 00:30:55.300
but you can create your VLAN interface,
and, you know,

00:30:55.300 --> 00:31:00.100
manage it from the network preferences
or the command line as you want.

00:31:00.100 --> 00:31:02.900
It's for--at this point,
it's for Ethernet drivers

00:31:02.900 --> 00:31:06.450
supporting the hardware VLAN,
so one of the big things is, like,

00:31:06.450 --> 00:31:08.900
the tagging for the VLAN is
done through the hardware,

00:31:08.900 --> 00:31:12.150
so there is almost no overhead there.

00:31:12.610 --> 00:31:16.600
And right now, the XSERVs,
the new G5 XSERV,

00:31:16.600 --> 00:31:23.000
supports that on both built-in cards,
or you can have add-on cards also

00:31:23.000 --> 00:31:26.190
that-- that support VLAN tagging.

00:31:26.210 --> 00:31:30.170
So this is for the server side
of the VLAN where you can,

00:31:30.170 --> 00:31:33.380
you know,
basically deal with multiple tags

00:31:33.400 --> 00:31:36.790
and multiple VLAN at the same time.

00:31:36.800 --> 00:31:41.900
The future direction for servers
and what we're looking at,

00:31:41.920 --> 00:31:44.400
and it's a link aggregation.

00:31:44.430 --> 00:31:48.880
That seems to be something
that is on our path.

00:31:48.930 --> 00:31:56.700
So the IEEE 802.3ad link aggregation is
something that we're really considering.

00:31:56.860 --> 00:32:00.160
And also failover,
which is another feature for

00:32:00.160 --> 00:32:03.880
those guys for the XSERVs.

00:32:04.230 --> 00:32:05.930
Let's see.

00:32:06.450 --> 00:32:10.450
802.1X,
so that's another thing which is present.

00:32:10.720 --> 00:32:18.920
I mean, we introduced that in Mac OS X.

00:32:19.120 --> 00:32:20.770
I think it was after—yeah,
it's been in some of the Panther updates.

00:32:20.990 --> 00:32:24.840
It's essential for wireless
LAN and for the security.

00:32:24.960 --> 00:32:32.960
It's also used on wired LAN for Ethernet.

00:32:32.960 --> 00:32:39.430
We have a wide range of authentication
methods that we support for 802.1X.

00:32:39.980 --> 00:32:45.100
You can read them at TLS, TLS, Leap, MD5,
Peep.

00:32:45.100 --> 00:32:49.750
A lot of things there for 802.1X.

00:32:49.930 --> 00:32:55.460
And some of the new things we
introduced in—we're introducing in

00:32:55.460 --> 00:32:58.210
Tiger is the WPA enterprise support.

00:32:58.260 --> 00:33:00.140
So that's something that was requested.

00:33:00.140 --> 00:33:05.930
And also EAP TLS and we have some
improved certificate support in there.

00:33:05.930 --> 00:33:07.880
That's new in Tiger.

00:33:09.760 --> 00:33:14.690
IP configuration,
we talked in one of the first slides

00:33:14.750 --> 00:33:20.990
about our ease of use mobility goals
there that are ongoing goal for the

00:33:20.990 --> 00:33:24.020
core networking in Apple for Mac OS X.

00:33:24.020 --> 00:33:30.680
And the IP configuration is something
where we added a lot of things.

00:33:30.690 --> 00:33:35.600
So we have something that you might
know of which is called configd which

00:33:35.670 --> 00:33:39.490
is a central demon which take care
and listen to all those events I was

00:33:39.600 --> 00:33:43.900
talking about coming from the kernel
or coming from user lens changes from

00:33:43.900 --> 00:33:48.900
configuration and basically reconfigures
the stack kind of dynamically

00:33:48.900 --> 00:33:51.560
and figure out what's going on.

00:33:51.560 --> 00:33:56.540
So the IP configuration is a big
part of what we're doing here to

00:33:56.590 --> 00:33:59.610
provide that mobility side of things.

00:33:59.620 --> 00:34:03.980
And some of the new things that
we're introducing in Tiger is

00:34:03.980 --> 00:34:09.280
that we change quite a bit the way
the DHCP works as a client when

00:34:09.370 --> 00:34:13.510
we use the remaining list time,
you know,

00:34:13.510 --> 00:34:17.910
if there's no DHCP server around,
so we're going to be a little bit

00:34:18.030 --> 00:34:22.760
smarter about trying to figure out,
hey, can we reuse this address?

00:34:22.760 --> 00:34:28.220
We also use ARP, you know,
we do an ARP probing to make sure that,

00:34:28.220 --> 00:34:32.090
okay, if the router is here, we can,
you know, kind of shave off a couple of

00:34:32.090 --> 00:34:35.180
seconds and make your PowerBook,
you know, come up faster.

00:34:35.180 --> 00:34:37.620
When you wake it up,
it's going to be on the network,

00:34:37.620 --> 00:34:39.220
those kind of things.

00:34:39.220 --> 00:34:43.090
We're also doing--a lot of
people have multiple interfaces

00:34:43.150 --> 00:34:44.480
and multiple addresses.

00:34:44.480 --> 00:34:47.420
So now in Tigers,
there's a concurrent ARP that are

00:34:47.420 --> 00:34:51.680
being sent out on all the interfaces,
so we are not waiting

00:34:51.680 --> 00:34:55.410
sequentially to get,
you know, all the information

00:34:55.480 --> 00:34:56.990
for all the interfaces.

00:34:57.000 --> 00:34:59.760
So there is more parallelism going there.

00:34:59.760 --> 00:35:03.730
And we also have support for
dynamic proxy configurations and,

00:35:03.730 --> 00:35:08.980
you know, which is known by the--this is
something that was asked for by a

00:35:08.980 --> 00:35:12.520
bunch of people for the .Pack support.

00:35:12.520 --> 00:35:14.300
And we talked about the split DNS.

00:35:14.340 --> 00:35:17.360
Now we got the split DNS that
we're using for the VPN,

00:35:17.360 --> 00:35:21.810
but we also have this split
DNS mechanism that can be used

00:35:21.870 --> 00:35:24.060
on a bunch of other ways also.

00:35:24.060 --> 00:35:25.690
It's part of the base of the system.

00:35:27.660 --> 00:35:32.080
Another thing that we
introduced in Tiger at different

00:35:32.200 --> 00:35:34.660
level of configuration,
more higher level,

00:35:34.680 --> 00:35:39.430
this is more geared toward people
that are ISPs and things like that

00:35:39.470 --> 00:35:43.730
that need to configure a machine
for you because you're just,

00:35:43.730 --> 00:35:47.560
you know, getting a new DSL,
something like that.

00:35:47.560 --> 00:35:52.180
So, until now, those people had to do a
bunch of things to figure out

00:35:52.180 --> 00:35:56.840
what was your configuration,
your services, you know.

00:35:56.840 --> 00:36:02.340
Now we're introducing the
high level preference API.

00:36:02.400 --> 00:36:05.640
It's kind of an aggregate of
code that were in different

00:36:05.640 --> 00:36:07.460
places all over the system.

00:36:07.460 --> 00:36:11.190
So things like the network preference
panel or the network config framework,

00:36:11.190 --> 00:36:14.250
you had to dig in and get
some of the information there,

00:36:14.280 --> 00:36:19.290
some of the information from the
admin framework which is private and,

00:36:19.290 --> 00:36:24.230
you know,
things like the more SCF from Quinn that,

00:36:24.280 --> 00:36:26.080
you know,
give you some information about the code.

00:36:26.080 --> 00:36:28.310
You can get some information
about how to get this.

00:36:28.430 --> 00:36:32.250
But now with this new API,
we'll let you manipulate a

00:36:32.340 --> 00:36:36.900
lot of different entities,
you know, network location, you know,

00:36:36.930 --> 00:36:41.220
you can have location home, work,
you know, whatever.

00:36:41.320 --> 00:36:44.640
Network services you can
manipulate with this API.

00:36:44.640 --> 00:36:48.020
So your Ethernet seen as an
interface can be manipulated,

00:36:48.050 --> 00:36:52.410
created, deleted, you know,
changed as an entity here by

00:36:52.470 --> 00:36:55.320
some high level primitives.

00:36:55.320 --> 00:36:58.550
And also the network entities,
your configuration for V4,

00:36:58.560 --> 00:37:05.150
for configuration for DNS, for IPv6,
you know, all those kind of things can be

00:37:05.150 --> 00:37:08.820
seen instead of like parsing the
XML or going through different

00:37:08.820 --> 00:37:10.460
frameworks to get through those.

00:37:10.460 --> 00:37:14.410
Now you get some higher
level way of doing that.

00:37:15.420 --> 00:37:22.210
I talk in the highlight about the
changes that we have for IPFW2.

00:37:22.260 --> 00:37:28.510
So IPFW2 is one thing that we
ported and put into our core.

00:37:28.510 --> 00:37:31.840
It gives us a bunch of new things.

00:37:31.840 --> 00:37:33.880
So it's faster.

00:37:33.880 --> 00:37:38.030
It's more complete and more features.

00:37:38.260 --> 00:37:41.480
So it's a lot of things there.

00:37:42.700 --> 00:37:45.830
So more complete because
it's got rule sets.

00:37:45.930 --> 00:37:49.620
And so you can have a different
rule sets for your firewalls that

00:37:49.620 --> 00:37:51.760
you can turn on and off instantly.

00:37:51.760 --> 00:37:56.150
So depending on your location,
depending on a bunch of other, you know,

00:37:56.410 --> 00:37:59.700
sets that you decide,
you can turn on and off those

00:37:59.710 --> 00:38:04.290
sets and have different behavior
for your firewall on the fly.

00:38:04.450 --> 00:38:10.100
So that's something that is
much easier to do with IPFW2.

00:38:10.100 --> 00:38:13.340
So yeah,
you can have address sets and lists.

00:38:13.340 --> 00:38:17.100
So you can have your address list and
build that and use that and create,

00:38:17.100 --> 00:38:20.080
you know, your rule sets that way.

00:38:20.080 --> 00:38:22.310
So much more flexibility.

00:38:22.320 --> 00:38:23.810
It's also have a big feature.

00:38:23.810 --> 00:38:25.660
It's got keep alive for dynamic rules.

00:38:25.830 --> 00:38:31.130
So it will do a much better job getting,
you know, whatever the content is that

00:38:31.250 --> 00:38:35.410
gets filtered by the firewall,
you know, will get keep alive on those

00:38:35.410 --> 00:38:36.810
connection and everything.

00:38:36.810 --> 00:38:38.110
So we'll know what's going on.

00:38:38.110 --> 00:38:38.360
So that's something we get.

00:38:38.360 --> 00:38:38.500
So yeah.

00:38:38.500 --> 00:38:42.320
So that's something we get from IPFW2.

00:38:42.330 --> 00:38:47.500
It's also backward compatible
with IPFW with the previous one.

00:38:47.510 --> 00:38:50.220
But if you're doing, you know,
an application which is a

00:38:50.220 --> 00:38:55.610
firewall and you're based on IPFW,
what we will ask you for Tiger is to use

00:38:55.610 --> 00:39:00.260
a new rule set because a new rule set
is more rich and we're still compatible

00:39:00.260 --> 00:39:04.320
with the old one but we're asking you to
move on and use a new rule set so we can,

00:39:04.390 --> 00:39:07.460
you know,
at some point deprecate the old one.

00:39:07.590 --> 00:39:08.460
So, yeah.

00:39:08.460 --> 00:39:09.980
So--

00:39:10.210 --> 00:39:15.880
Following this,
what you'll see in the Control Panel,

00:39:15.880 --> 00:39:18.320
in the Preference Panel,
is that there's a bunch of

00:39:18.350 --> 00:39:21.960
changes that have been done
here and that are leveraging on

00:39:21.960 --> 00:39:24.530
the fact that we have now IPFW2.

00:39:24.730 --> 00:39:28.540
One other thing we added
in Tiger is UDP filtering.

00:39:28.540 --> 00:39:36.120
So now you can do UDP filtering
from the UI in the Control Panel.

00:39:36.120 --> 00:39:37.180
We got better logging.

00:39:37.330 --> 00:39:40.490
That was one of the problems
of the previous firewall,

00:39:40.500 --> 00:39:45.840
is that it was spewing all
its log to the main log file.

00:39:45.840 --> 00:39:52.120
Now IPFW has its own log file,
so we have more control about this.

00:39:52.270 --> 00:39:58.680
And also we added a mode in there,
which is a stealth mode,

00:39:58.680 --> 00:40:02.430
which basically lets your
computer be invisible,

00:40:02.430 --> 00:40:06.070
if you want,
on the network if you choose to do so.

00:40:06.160 --> 00:40:10.660
And what it does is,
even if right now somebody's trying to,

00:40:10.660 --> 00:40:14.970
let's say,
to do a connect to a TCP connect

00:40:14.970 --> 00:40:19.820
and sending a SYN trying
to get to your port 22,

00:40:19.830 --> 00:40:23.890
to your SSH, and SSH is off,
if you don't have the stealth mode,

00:40:23.890 --> 00:40:26.450
what's going to happen is that
we're going to send a reset saying,

00:40:26.480 --> 00:40:28.170
no, there's no service there.

00:40:28.470 --> 00:40:31.800
Turning on stealth mode,
we're just going to ignore that

00:40:31.800 --> 00:40:33.920
we're going to log that request,
but we're not going

00:40:33.920 --> 00:40:34.940
to send anything back.

00:40:34.940 --> 00:40:34.940
So if that's the case,
we're going to log that request.

00:40:34.940 --> 00:40:34.980
And we're going to send a reset.

00:40:35.020 --> 00:40:35.100
And we're going to log that request,
but we're not going

00:40:35.100 --> 00:40:35.160
to send anything back.

00:40:35.160 --> 00:40:35.160
So if that's the case,
we're going to log that request,

00:40:35.160 --> 00:40:35.220
but we're not going
to send anything back.

00:40:35.220 --> 00:40:35.630
So if that's the case,
we're going to log that request,

00:40:35.630 --> 00:40:35.830
but we're not going
to send anything back.

00:40:35.840 --> 00:40:41.420
If that port is not in use,
we won't even say we're here.

00:40:41.470 --> 00:40:44.790
So if you scan or something
like that may help.

00:40:44.900 --> 00:40:49.590
But the drawback is somebody's
trying to really connect to you.

00:40:49.650 --> 00:40:52.200
They won't know if it's because
you're not there or because

00:40:52.200 --> 00:40:53.950
you're just playing silent.

00:40:54.100 --> 00:40:58.250
But it's a stealth mode.

00:40:59.320 --> 00:41:00.800
Okay.

00:41:00.800 --> 00:41:04.590
So one of the things—there's
a lot of changes in Rendezvous

00:41:04.590 --> 00:41:06.250
also this year in Tiger.

00:41:06.330 --> 00:41:11.330
I'm not going to talk into detail about
those because there's a full Rendezvous

00:41:11.330 --> 00:41:14.570
update session on Friday at 10:30 a.m.

00:41:14.940 --> 00:41:21.130
So there's a lot of things that
are going to get announced or

00:41:21.580 --> 00:41:24.640
have been announced actually.

00:41:25.140 --> 00:41:26.880
So new in Tiger, the text record API.

00:41:27.250 --> 00:41:32.650
It's available from Java and I think
we announced at rendezvous now all the,

00:41:32.650 --> 00:41:36.280
you know, there's much more than that.

00:41:36.280 --> 00:41:41.480
I think we announced that everything
is on the different platforms.

00:41:41.480 --> 00:41:43.560
You get access to the
same API and everything.

00:41:43.560 --> 00:41:51.810
So I encourage you to go see the
rendezvous session to get all the detail

00:41:51.810 --> 00:41:52.310
about what's new in Tiger for rendezvous.

00:41:53.970 --> 00:41:58.530
I'd like to make a little ploy
here and just trying to get

00:41:58.560 --> 00:42:00.870
people to be aware of IPv6.

00:42:00.900 --> 00:42:04.990
I've been at Apple for a while
and I've been working on IPv6 for,

00:42:04.990 --> 00:42:11.180
I don't know, many years now trying to
get IPv6 around and things.

00:42:11.250 --> 00:42:14.640
And I think it's time for
developers to kind of try to be

00:42:14.650 --> 00:42:19.300
aware of IPv6 and try to make sure,
you know, we've been saying IPv6

00:42:19.300 --> 00:42:21.300
is coming and everything.

00:42:21.300 --> 00:42:24.930
But, you know,
it's really ultimately we've done

00:42:25.010 --> 00:42:29.580
a lot of things inside the OS to
make sure that we're ready for IPv6.

00:42:29.580 --> 00:42:34.290
But until some of you guys come up
with a killer app that is using IPv6,

00:42:34.290 --> 00:42:37.940
you know, it's not really going to,
you know, fly very high.

00:42:37.940 --> 00:42:41.110
So this is like my few
slides trying to do,

00:42:41.110 --> 00:42:45.290
to like get you,
to encourage you to go with IPv6.

00:42:45.300 --> 00:42:49.200
So what's going on with IPv6 in Mac OS X?

00:42:50.740 --> 00:42:54.030
So every single interface on
Mac OS X has a link local address.

00:42:54.030 --> 00:42:58.400
So since Jaguar now,
we've been having IPv6, you know,

00:42:58.400 --> 00:43:00.240
turned on in Mac OS X.

00:43:00.240 --> 00:43:04.370
And one of the things you probably
noticed is those FE80 addresses

00:43:04.370 --> 00:43:06.500
that you get on every interface.

00:43:06.500 --> 00:43:08.590
So those are great.

00:43:08.630 --> 00:43:11.820
That's a great integration
with Rendezvous because every

00:43:11.820 --> 00:43:15.430
single machine on that network,
if they're, you know, Mac OS X,

00:43:15.430 --> 00:43:18.110
will have a link local address
so they can communicate

00:43:18.360 --> 00:43:20.180
without any configuration.

00:43:20.180 --> 00:43:21.610
Using those addresses.

00:43:21.700 --> 00:43:24.790
So it's a good,
it's a good way to leverage with

00:43:25.130 --> 00:43:29.180
Rendezvous because you don't
really care about the address.

00:43:29.180 --> 00:43:31.990
And the IPv6 addresses are, you know,
bigger and like hard

00:43:32.020 --> 00:43:33.300
to type and everything.

00:43:33.300 --> 00:43:35.320
But with something like Rendezvous,
you just don't care.

00:43:35.320 --> 00:43:40.180
You just use names and you
use higher level form of,

00:43:40.180 --> 00:43:42.520
you know, services.

00:43:42.520 --> 00:43:44.960
So you don't really care
what the underlying address

00:43:44.960 --> 00:43:46.800
is really 128-bit or not.

00:43:46.800 --> 00:43:48.990
So that's a great integration with that.

00:43:49.620 --> 00:43:50.120
So that's a great integration with that.

00:43:50.120 --> 00:43:53.570
And the ease of configuration,
it's a stateless configuration.

00:43:53.580 --> 00:43:55.990
So you have a router,
it's going to pick it up.

00:43:55.990 --> 00:43:58.620
You don't,
you're using a link local on that link.

00:43:58.620 --> 00:44:01.050
So that's really,
really easy for you to use.

00:44:01.050 --> 00:44:04.960
You know, there's nothing, you know,
to be worried about too much.

00:44:04.990 --> 00:44:07.940
And as I said,
Mac OS X since Jaguar has it and

00:44:08.030 --> 00:44:12.200
every release we're adding new,
you know, new features.

00:44:12.200 --> 00:44:12.200
So that's a great integration.

00:44:12.320 --> 00:44:15.990
level of support for it,
so we got support in the BSD sockets,

00:44:16.030 --> 00:44:17.600
you know, of course.

00:44:17.600 --> 00:44:22.520
We got the configuration since
Penter is -- you can configure in

00:44:22.520 --> 00:44:25.130
the network configuration panel.

00:44:25.290 --> 00:44:28.270
We can configure IPv6 or make
it auto-configured manually.

00:44:28.280 --> 00:44:30.600
All these kinds of
things are always there.

00:44:30.840 --> 00:44:34.020
We got a bunch of services that are IPv6.

00:44:34.020 --> 00:44:39.560
You may not even know, but, you know,
Apple shares IPv6-aware.

00:44:39.560 --> 00:44:43.860
You can do over FireWire, you know,
it's IPv6.

00:44:43.860 --> 00:44:47.140
A lot of things in the system
are already IPv6-ready.

00:44:47.140 --> 00:44:50.850
And all the frameworks that we'll
talk about later when we'll overview

00:44:50.850 --> 00:44:53.580
the APIs are all ready for IPv6.

00:44:53.670 --> 00:44:59.010
CF Network has been doing a lot of
work to make sure IPv6 is present

00:44:59.020 --> 00:45:01.700
in there and that works with it.

00:45:01.700 --> 00:45:05.440
So DNS, all those kind of things
are all IPv6-aware.

00:45:05.440 --> 00:45:08.380
So I encourage you to
-- So for those points,

00:45:08.400 --> 00:45:09.980
you know, it's the future.

00:45:10.090 --> 00:45:12.460
You know,
it may not be something that we need,

00:45:12.460 --> 00:45:15.730
you know, in the next two weeks,
but it's slowly -- it's

00:45:15.780 --> 00:45:17.320
getting some ground there.

00:45:17.320 --> 00:45:19.020
You know, IRD is asking for it.

00:45:19.020 --> 00:45:21.050
Internet 2, it's mandated there.

00:45:21.050 --> 00:45:24.220
DoD has made it something
that they require also.

00:45:24.300 --> 00:45:26.420
And it's pretty big in Japan.

00:45:26.420 --> 00:45:32.550
So the point is here is like your
application should be IPv6-aware.

00:45:32.600 --> 00:45:38.930
You may not be able to or want to take,
you know, stuff from IPv6 at this point,

00:45:38.930 --> 00:45:40.860
but at least be IPv6-aware.

00:45:40.880 --> 00:45:43.830
And for doing this,
one of the things that you need to

00:45:43.830 --> 00:45:49.380
do is just make sure that your model,
your application is address-independent.

00:45:49.380 --> 00:45:52.620
And we'll see pretty
much how easy it is or,

00:45:52.640 --> 00:45:56.880
you know, of course, you know,
it's lying with slides.

00:45:56.980 --> 00:46:01.060
But, you know,
a little example here is showing you

00:46:01.060 --> 00:46:06.460
how taking a BSD kind of application
where we're just doing here,

00:46:07.070 --> 00:46:10.200
what we're doing is we're
doing a connect and,

00:46:10.200 --> 00:46:14.210
you know,
get us by name from www.apple.com

00:46:14.260 --> 00:46:20.740
and then we're trying to,
you know, to connect to that server here.

00:46:20.740 --> 00:46:25.040
So this is like standard
BSD normal Unix code.

00:46:25.590 --> 00:46:30.280
However, there is a couple of
things that are wrong here.

00:46:30.280 --> 00:46:33.740
All those things that
are highlighted in red,

00:46:33.750 --> 00:46:38.230
I'm not sure if you can see, yeah,
if I'm doing this,

00:46:38.230 --> 00:46:40.640
all those things are highlighted in
red here are really address-dependent.

00:46:40.710 --> 00:46:41.630
They are v4-dependent.

00:46:41.690 --> 00:46:42.180
Why?

00:46:42.180 --> 00:46:46.230
Because the structs like adder, well,
it's dependent of the

00:46:46.340 --> 00:46:49.520
size of an IPv4 address.

00:46:49.520 --> 00:46:52.970
Something like if I net, of course,
you know, it's IPv4.

00:46:52.990 --> 00:46:56.480
Get us by name, well,
get us by name is the old

00:46:56.520 --> 00:46:59.290
legacy way to get the resolver.

00:46:59.290 --> 00:47:00.880
It's address-dependent.

00:47:00.890 --> 00:47:03.060
And all those things
where we do a size of,

00:47:03.210 --> 00:47:06.700
you know, that structure which is v4,
all this is going to break if you're

00:47:06.700 --> 00:47:09.560
trying to-- to get with a v6 address.

00:47:09.560 --> 00:47:11.840
So don't do that.

00:47:11.840 --> 00:47:16.150
So instead of doing this,
there's--to do the same thing

00:47:16.260 --> 00:47:20.080
to be able to have something
which is address-independent,

00:47:20.120 --> 00:47:22.760
in this version here,
we're doing the same thing.

00:47:22.880 --> 00:47:26.080
We're just trying to create
a socket and--actually,

00:47:26.080 --> 00:47:29.380
here we're just trying to do
a--to resolve and get the socket

00:47:29.470 --> 00:47:33.590
and connect--and connect to it,
you know, completely--in a completely

00:47:33.590 --> 00:47:34.780
address-independent.

00:47:34.960 --> 00:47:37.980
So if you have a v6 address,
it will work with v6.

00:47:37.990 --> 00:47:40.500
If you just have a v4 address,
it doesn't change anything

00:47:40.500 --> 00:47:43.010
which is probably the case from,
you know,

00:47:43.020 --> 00:47:45.460
still for the few weeks to come.

00:47:45.510 --> 00:47:46.820
It will work with IPv6.

00:47:46.820 --> 00:47:50.630
So here, what's going on is
that instead of saying,

00:47:50.690 --> 00:47:55.840
you know, pfinet, we're saying unspec,
which means I don't care.

00:47:55.840 --> 00:48:00.950
It could be afinet, afinet6,
I'm ready for it.

00:48:01.050 --> 00:48:05.900
And so we are using also
get-adder-info which is a much

00:48:05.970 --> 00:48:07.990
richer API than--than the other API,
which is a much richer

00:48:07.990 --> 00:48:09.130
API than get-us-by-name.

00:48:09.180 --> 00:48:13.770
And here we're saying, "Hey, okay,
we want, you know, www.apple.com and,

00:48:13.770 --> 00:48:19.100
you know, HTTP and we want the hints back
and the result back." And here,

00:48:19.100 --> 00:48:23.360
depending of what we're getting
back in this for loop here,

00:48:23.500 --> 00:48:27.780
you know, we don't even look at the
fact it's an IPv4 and IPv6.

00:48:27.880 --> 00:48:30.690
We just, "Okay,
can I connect with what I get

00:48:30.780 --> 00:48:33.280
in the result from my DNS query?

00:48:33.330 --> 00:48:37.150
If I can, you know,
I don't care which protocol I use,

00:48:37.150 --> 00:48:40.230
I'm going to connect with that."
So I know this is not really,

00:48:40.230 --> 00:48:43.700
you know, it's not really a real-life
application and everything.

00:48:43.740 --> 00:48:48.320
But from a developer point of view
and most of you here are developers,

00:48:48.320 --> 00:48:52.800
the fact that it's v4 or v6
doesn't really matter once you get,

00:48:53.040 --> 00:48:55.870
you know,
you get to your application because

00:48:55.920 --> 00:49:01.330
you're just trying to deal with TCP,
right, or UDP, whatever you're doing.

00:49:01.330 --> 00:49:06.180
If you--by just restructuring
your code a little bit and making,

00:49:06.180 --> 00:49:09.860
you know-- So, you know,
you're aware of like, "Okay, you know,

00:49:09.860 --> 00:49:13.520
my--the address I'm getting may
be more than four bytes because

00:49:13.520 --> 00:49:17.160
it could be an IPv6 address
and it's going to be 128 bits,

00:49:17.160 --> 00:49:22.720
you know." By taking some simple steps,
you can make sure that your

00:49:22.720 --> 00:49:25.910
application is v6 and what
it means here is this code,

00:49:25.910 --> 00:49:30.360
the day you turn off IPv4 or in Japan,
you know, device has those little

00:49:30.400 --> 00:49:33.600
thermometer that just do IP,
you know, v6,

00:49:33.600 --> 00:49:36.400
they have no v4 stack at all.

00:49:36.400 --> 00:49:36.900
You try to connect to that device.

00:49:36.900 --> 00:49:39.240
So, you know, if you have a device here,
you'll connect,

00:49:39.320 --> 00:49:42.980
you'll try first in v4 or if the
DNS doesn't give you a v4 address,

00:49:43.100 --> 00:49:45.980
you know, back,
it will give you back a v6 address,

00:49:46.080 --> 00:49:49.400
a link local address much, you know,
probably.

00:49:49.490 --> 00:49:51.440
And so,
you'll connect to that address here

00:49:51.440 --> 00:49:55.110
and your code will work no matter what,
you know, if it's v4 or v6,

00:49:55.110 --> 00:49:55.920
you don't care.

00:49:55.920 --> 00:50:01.160
So, that's just a little, you know,
a little bit of information.

00:50:02.140 --> 00:50:07.070
"It's a really cool thing to try to get
you guys aware of IPv6 and how it doesn't

00:50:07.120 --> 00:50:21.040
add a lot to do that and it's easy to
just change your code to get to IPv6.

00:50:21.040 --> 00:50:21.040
Sorry."

00:50:21.160 --> 00:50:25.100
That was my little IPv6 talk.

00:50:25.100 --> 00:50:29.770
So now what we're going to do
here in this session is we talked

00:50:29.790 --> 00:50:33.940
about what's new in Tiger for
the core networking in Mac OS X.

00:50:33.940 --> 00:50:38.510
Now we'll go back a little bit
and do a review of the different

00:50:38.540 --> 00:50:43.140
level of API we have available
for you guys and which level,

00:50:43.140 --> 00:50:46.400
you know,
may make more sense than another

00:50:46.460 --> 00:50:51.100
to do your application and to
get the most of the system.

00:50:52.540 --> 00:50:58.170
So we're going to this diagram
here showing at the bottom,

00:50:58.200 --> 00:51:01.220
here's a kernel where we just
put the networking stack,

00:51:01.270 --> 00:51:03.820
because we don't really
care about the rest.

00:51:03.980 --> 00:51:08.530
So in the kernel we talked about
the fact that you can do KPI,

00:51:08.550 --> 00:51:10.750
and there's a full session about this.

00:51:10.860 --> 00:51:16.620
But for most people on user space,
we think about the BSD socket,

00:51:16.620 --> 00:51:21.210
because we're Unix-based and
BSD socket is like the model there.

00:51:21.540 --> 00:51:25.060
But there is a lot of more things
that are based on the socket API,

00:51:25.190 --> 00:51:28.980
or also things that we
see here on the side,

00:51:28.980 --> 00:51:33.710
like the DNS service discovery,
or the stem configuration, or lookupd,

00:51:33.710 --> 00:51:38.480
which does the name resolution,
that you can use and

00:51:38.530 --> 00:51:41.150
they have API provided.

00:51:41.360 --> 00:51:43.500
So we'll go through those.

00:51:44.470 --> 00:51:51.130
So as a reminder here,
so the BSD socket that we talked about,

00:51:51.130 --> 00:51:55.220
the DNS service discovery,
the system configuration when

00:51:55.220 --> 00:51:59.120
you can do network setup,
network reachability,

00:51:59.120 --> 00:52:04.740
the connection dialup,
and also at a higher level,

00:52:04.910 --> 00:52:10.830
the framework networking APIs,
which go with CF sockets, CF networks,

00:52:10.830 --> 00:52:14.060
the proxy SSL,
and the network diagnostics,

00:52:14.540 --> 00:52:17.270
foundation URL, and ultimately at the
top of the stack here,

00:52:17.330 --> 00:52:17.780
WebKit.

00:52:17.950 --> 00:52:23.590
So we'll go and have a little
talk about every single of those.

00:52:24.090 --> 00:52:28.130
BSD socket,
so that's a core programming interface.

00:52:28.330 --> 00:52:31.070
Everything in user lane is
pretty much based on that.

00:52:31.510 --> 00:52:39.320
That's a main, raw interface,
and the native interface of the system.

00:52:39.320 --> 00:52:42.770
What it provides,
its fundamental networking API.

00:52:42.780 --> 00:52:47.130
I highly recommend reading the
Stevens book if you want to go through

00:52:47.130 --> 00:52:49.110
all the details of the socket API.

00:52:49.210 --> 00:52:53.220
It's a very rich API,
a lot of things in there.

00:52:53.280 --> 00:52:56.780
It can be complicated,
but this is how you get

00:52:56.780 --> 00:52:58.640
the most out of the system.

00:52:58.670 --> 00:53:01.450
You do that when you want
performance and total control.

00:53:01.580 --> 00:53:05.260
If you're doing a server
application and you don't really

00:53:05.260 --> 00:53:09.960
care about all nice UI sync,
and you just want to have raw power,

00:53:09.960 --> 00:53:15.850
I would recommend using sockets,
because sockets is the closest

00:53:15.990 --> 00:53:19.190
you can get to the networking.

00:53:19.280 --> 00:53:22.520
So performance, total control.

00:53:22.520 --> 00:53:27.400
You still can use things like select or
KQs for doing asynchronous operation.

00:53:27.400 --> 00:53:30.270
One of the things that people
tend to think that socket is like,

00:53:30.270 --> 00:53:32.490
oh, OK, well,
I'm doing a socket operation,

00:53:32.490 --> 00:53:35.700
I'm doing a read, I'm blocked,
and my thread is blocked

00:53:35.700 --> 00:53:37.660
until data come back.

00:53:37.720 --> 00:53:42.240
Well, that's one way of using sockets,
but you can also use it

00:53:42.240 --> 00:53:45.280
in an asynchronous way,
and there is some way to do that.

00:53:45.290 --> 00:53:49.680
But you have a lot of control,
a lot of things in the socket,

00:53:49.680 --> 00:53:52.360
and there's plenty of books
explaining what to do.

00:53:52.360 --> 00:53:55.820
But it can be a little bit complicated.

00:53:55.940 --> 00:53:59.960
Also, from the socket layer,
what we do is we provide low

00:53:59.960 --> 00:54:03.880
level access to some of the--
I was talking earlier when we were

00:54:03.970 --> 00:54:06.960
talking about kernel extensions,
network kernel extension,

00:54:06.960 --> 00:54:11.370
that we would like you
to avoid to all possible,

00:54:11.580 --> 00:54:14.280
as much as possible,
to go into the kernel and get

00:54:14.280 --> 00:54:17.670
your own kernel extension,
because it's messy, and it's dangerous,

00:54:17.670 --> 00:54:18.360
and everything.

00:54:18.500 --> 00:54:22.720
So we provide low level access
to a bunch of stuff from the API,

00:54:23.100 --> 00:54:26.670
things like IPsec, or we got PFNDRV,
which is a way to get

00:54:26.860 --> 00:54:27.920
directly to the interface.

00:54:28.020 --> 00:54:29.860
I think I have a slide on that.

00:54:29.890 --> 00:54:33.160
And that's where you want to use socket.

00:54:33.530 --> 00:54:37.950
Also, a good way to use socket,
BSD compatibility and portability.

00:54:38.070 --> 00:54:40.600
We said before we're based on free BSD.

00:54:40.620 --> 00:54:49.060
Pretty much any tool that is using
some BSD-ism in terms of the networking

00:54:49.410 --> 00:54:55.570
is going to compile and be working
pretty much without any touching it

00:54:56.000 --> 00:55:01.120
on Mac OS X because of the BSD sockets,
and they're using sockets,

00:55:01.140 --> 00:55:04.420
and we respect that paradigm here.

00:55:04.450 --> 00:55:08.680
So BSD socket, really low level,
but gives you full control.

00:55:08.680 --> 00:55:10.700
That's where you want to use it.

00:55:10.750 --> 00:55:12.530
So the resolver library.

00:55:12.660 --> 00:55:15.790
So what it does,
it does name to address resolution,

00:55:15.940 --> 00:55:16.820
of course.

00:55:16.820 --> 00:55:18.900
That's the thing it's known for.

00:55:18.900 --> 00:55:22.790
Goes on the network to your DNS server
and get all the all those A,

00:55:23.120 --> 00:55:25.780
quad A, whatever,
all those records that you're

00:55:25.780 --> 00:55:27.060
getting and getting that.

00:55:27.060 --> 00:55:30.360
It does also service location
and a bunch of other stuff,

00:55:30.360 --> 00:55:32.120
actually, for the resolver library.

00:55:32.120 --> 00:55:38.940
Like the service and it can
get things from ETC host and

00:55:38.940 --> 00:55:41.630
all those kind of things.

00:55:42.000 --> 00:55:43.870
So it goes hand in hand
with the Socket API.

00:55:43.920 --> 00:55:46.090
So this is kind of the same level.

00:55:46.240 --> 00:55:53.660
It's using the Socket API,
but it's pretty low level kind of access

00:55:53.660 --> 00:55:56.880
to the network and the configuration.

00:55:56.880 --> 00:55:59.890
As we said before,
it's got full IPv6 support.

00:56:00.100 --> 00:56:05.340
So you can do query for Quade,
or you can-- everything

00:56:05.380 --> 00:56:06.110
is ready for IPv6.

00:56:06.220 --> 00:56:09.040
We did a lot of work last
year to get that done.

00:56:09.040 --> 00:56:13.500
It used bind9, which is, of course,
a big standard.

00:56:13.510 --> 00:56:16.620
And we do have the split DNS support.

00:56:16.870 --> 00:56:20.440
So that means that as a developer here,
you can have several resolvers.

00:56:20.440 --> 00:56:22.590
You can make it have several resolvers.

00:56:22.680 --> 00:56:26.540
So for one part of the things,
you can say, hey,

00:56:26.540 --> 00:56:29.880
I want to resolve use this
resolver to get the information,

00:56:29.880 --> 00:56:32.240
because I'm on some internal network.

00:56:32.240 --> 00:56:37.620
And I know that in my closed LAN here,
I want to use this resolver that's going

00:56:37.620 --> 00:56:42.040
to resolve the address of . So I can send
my coworker two cubes down the line here,

00:56:42.220 --> 00:56:44.900
and that DNS is not public out there.

00:56:45.280 --> 00:56:48.840
So I want to use that resolver.

00:56:48.850 --> 00:56:52.040
So the query can be dispatched
to the appropriate server,

00:56:52.040 --> 00:56:54.260
depending on the type of the query.

00:56:54.260 --> 00:56:59.240
So that's one of the things that we
get in the split DNS support here.

00:56:59.310 --> 00:57:02.960
Another level of API,
which was kind of on the side here,

00:57:02.960 --> 00:57:05.480
is the network reachability API.

00:57:05.610 --> 00:57:09.000
So you can check what it's used for.

00:57:09.000 --> 00:57:14.430
So you can check the name,
or the address, or an address pair,

00:57:14.430 --> 00:57:17.660
and basically be notified when
the reachability has changed.

00:57:17.820 --> 00:57:21.040
So you're on the road, on your powerbook.

00:57:21.070 --> 00:57:25.270
You don't get any network access,
because you're far from Starbucks.

00:57:25.390 --> 00:57:28.700
And now you're getting reach,
and now your network

00:57:28.830 --> 00:57:30.760
reachability changed,
because you have

00:57:30.850 --> 00:57:32.740
connectivity and everything.

00:57:32.890 --> 00:57:35.270
And so this API will
tell your application,

00:57:35.270 --> 00:57:38.620
your mail application,
or some higher level application, hey,

00:57:38.750 --> 00:57:45.990
now is a good time to send some data,
because that host that you're trying

00:57:46.040 --> 00:57:47.830
to reach is there at this point.

00:57:47.840 --> 00:57:48.560
I can see it.

00:57:48.560 --> 00:57:50.170
I can go through it.

00:57:50.290 --> 00:57:55.480
So yeah, it's unified a set of disparate
information that are kind of piecemeal

00:57:55.480 --> 00:57:59.690
information all over the place.

00:57:59.920 --> 00:58:01.960
It gives you a connection status also.

00:58:02.110 --> 00:58:07.350
So it ends get both synchronous
and asynchronous mode to use.

00:58:07.550 --> 00:58:12.820
So DNS service discovery,
so multicast DNS to discover services.

00:58:12.880 --> 00:58:16.730
I'm sure you're all aware with
those rendezvous functionalities,

00:58:16.770 --> 00:58:19.000
so I'm not going to go
into detail on this.

00:58:19.200 --> 00:58:22.140
But you get the rendezvous API, you know,
where you can name and

00:58:22.140 --> 00:58:23.500
register your services.

00:58:23.510 --> 00:58:29.500
You can browse for services and you can,
you know, resolve the service to address.

00:58:29.500 --> 00:58:34.250
So for more things about rendezvous,
go to the rendezvous session Friday.

00:58:34.740 --> 00:58:37.330
PFNDRV socket, I'll go through it.

00:58:37.370 --> 00:58:42.610
So from user space, you have some kind of
very low level access.

00:58:42.740 --> 00:58:48.290
So we're using it in the 802.1.x
implementation where basically we're

00:58:48.290 --> 00:58:51.500
going directly to the interface
through this level without being

00:58:51.500 --> 00:58:56.500
encumbered by being in the kernel
and being a kernel extension.

00:58:56.500 --> 00:59:00.990
If you're trying to do, let's say,
a stack in user space

00:59:00.990 --> 00:59:03.740
or something like that,
you can use that too for something

00:59:03.740 --> 00:59:05.930
like DECnet or IPX or everything.

00:59:06.010 --> 00:59:06.810
It's a good way.

00:59:06.950 --> 00:59:12.750
You're getting really direct access to
the interface while being in user space.

00:59:12.760 --> 00:59:15.100
There's some other solution
to do that also that we're

00:59:15.100 --> 00:59:16.010
not going to talk too much.

00:59:16.060 --> 00:59:19.060
The diverged sockets,
which are used by the NATs.

00:59:19.130 --> 00:59:23.970
So that's another way to get packets
from a different level in user space.

00:59:24.320 --> 00:59:27.540
And yeah,
it's preferred over the kernel extension.

00:59:27.570 --> 00:59:30.920
So we talked about all the
things kind of in blue here.

00:59:30.920 --> 00:59:36.920
And now we'll talk really briefly
on the things that are built on top

00:59:36.960 --> 00:59:41.010
of the socket and all the services
that are probably for a lot of

00:59:41.010 --> 00:59:45.150
developers the right solution to use,
because they provide some higher level.

00:59:45.300 --> 00:59:50.400
They hide some of the complexity of the
implementation underneath of the socket.

00:59:50.540 --> 00:59:53.890
And sometimes you just want to get
a URL you don't really care about

00:59:53.890 --> 00:59:58.700
how it gets there and managing
all the networking side of it.

00:59:58.790 --> 00:59:59.890
So we have this.

01:00:00.000 --> 01:00:04.440
So the higher level frameworks here,
it's pretty much the kind of glue,

01:00:04.440 --> 01:00:07.340
the big glue,
which is in between an application

01:00:07.340 --> 01:00:13.090
like Safari and the raw BSD socket,
which are what we're based on.

01:00:13.740 --> 01:00:19.030
So building the stack
from the bottom here,

01:00:19.280 --> 01:00:21.860
the first level is core foundation.

01:00:21.860 --> 01:00:25.160
So core foundation is
really close to socket.

01:00:25.160 --> 01:00:30.730
And core foundation,
this is just an overview

01:00:30.830 --> 01:00:32.080
of what it does here.

01:00:32.080 --> 01:00:35.840
But basically, the big thing is that it's
based on the CF run loop.

01:00:35.840 --> 01:00:40.670
And the CF run loop, if your application
is using the run loop,

01:00:40.670 --> 01:00:42.120
you know that.

01:00:42.130 --> 01:00:45.930
It basically provides a basic
asynchronous mechanism where

01:00:46.040 --> 01:00:48.270
all the network operation,
instead of dealing with

01:00:48.270 --> 01:00:51.870
the socket directly,
are kind of integrated in the run loop.

01:00:51.940 --> 01:00:54.280
So yeah, it underlies the NS run loop.

01:00:54.300 --> 01:00:59.360
And the Carbon events are also
based on the CF network run loop.

01:00:59.510 --> 01:01:06.120
So the CF socket,
it's still very low level.

01:01:06.220 --> 01:01:08.830
And it basically connects
the socket to the run loop.

01:01:08.920 --> 01:01:10.040
So you can create your own socket.

01:01:10.040 --> 01:01:13.360
And then put them in the run
loop or do some operations.

01:01:13.380 --> 01:01:16.110
Still, you have a lot of control
in the socket at this point,

01:01:16.110 --> 01:01:19.730
but kind of integrate it
with the CF run loop model.

01:01:19.740 --> 01:01:23.900
So yeah, it literally handles any socket.

01:01:24.010 --> 01:01:29.820
The CF stream,
that's a basic stream abstraction here.

01:01:29.860 --> 01:01:34.170
It signals the client via the
run loop when the bytes come in.

01:01:34.240 --> 01:01:36.540
So again,
if you're trying to be still close to

01:01:36.580 --> 01:01:40.190
the socket and kind of have some control,
but you want to take advantage of

01:01:40.190 --> 01:01:44.160
some of the run loop functionality,
CF streams might be a

01:01:44.160 --> 01:01:46.360
good way to do that.

01:01:46.360 --> 01:01:50.840
And for things that are using stream,
of course, like TCP.

01:01:50.840 --> 01:01:56.120
Or yeah, also client side sockets are a
good way to use the CF stream.

01:01:56.120 --> 01:01:59.840
Building on top of that,
we have CF network.

01:01:59.850 --> 01:02:03.530
So CF network,
what it does is it provides

01:02:03.670 --> 01:02:05.020
some protocol implementation.

01:02:05.020 --> 01:02:08.150
So here,
you don't really care about dealing

01:02:08.300 --> 01:02:10.000
with your own socket or your own socket.

01:02:10.000 --> 01:02:12.000
You can do it with your
own protocol or something.

01:02:12.000 --> 01:02:16.700
All you want is HTTP service to your
application or FTP or using SSL,

01:02:16.700 --> 01:02:17.900
things like that.

01:02:17.960 --> 01:02:21.480
Or even things like rendezvous
are using the CF network or

01:02:21.550 --> 01:02:23.190
doing some DNS host resolution.

01:02:23.390 --> 01:02:28.490
You get access to that through
the CF network framework.

01:02:28.590 --> 01:02:30.570
Give you full control still.

01:02:30.830 --> 01:02:33.820
All the protocol details
are exposed of HTTP.

01:02:33.820 --> 01:02:36.510
You really have to understand
what's going on and what kind of

01:02:36.590 --> 01:02:40.660
requests you're going to create or
what kind of response you might get

01:02:40.820 --> 01:02:42.880
when you're using the CF network.

01:02:42.880 --> 01:02:46.310
So it's still very, very, very core.

01:02:46.630 --> 01:02:51.890
But you don't need to have all the
detail and do your own implementation

01:02:51.890 --> 01:02:54.180
of HTTP if you want or FTP.

01:02:54.570 --> 01:02:57.100
So you control each read and write.

01:02:57.200 --> 01:02:58.760
And you also control
the threading policy,

01:02:58.760 --> 01:03:01.460
which might be important depending on
what you're doing in your application.

01:03:01.500 --> 01:03:05.030
So that's a good level when you
want to have control but not

01:03:05.030 --> 01:03:07.240
too much going into the detail.

01:03:07.390 --> 01:03:09.960
CF network is a good layer
to base your application on.

01:03:09.960 --> 01:03:11.740
application on.

01:03:12.320 --> 01:03:15.960
So if you continue building
up here on what's going on

01:03:15.960 --> 01:03:21.940
between BSD Socket and Safari,
we see the foundation URL API.

01:03:22.230 --> 01:03:27.670
So that provides more
higher level things here.

01:03:27.730 --> 01:03:30.960
So full feature set of URL loading.

01:03:31.130 --> 01:03:32.540
So there, you really don't care.

01:03:32.540 --> 01:03:34.700
It just gives the URL,
and you get the result back.

01:03:34.800 --> 01:03:37.360
You don't care what's going
on on the network side.

01:03:37.360 --> 01:03:41.160
All the layers underneath you
are going to take care of that.

01:03:41.160 --> 01:03:43.120
You know,
it makes most of the choices for you.

01:03:43.120 --> 01:03:46.150
You don't have to give a lot of details,
a lot of, you know,

01:03:46.190 --> 01:03:47.030
option and everything.

01:03:47.090 --> 01:03:48.220
It's going to do the right thing.

01:03:48.220 --> 01:03:51.900
Asynchronous, it's based on callbacks,
you know, API.

01:03:52.030 --> 01:03:54.330
So for somebody who
just want to get a file,

01:03:54.380 --> 01:03:57.850
get a URL,
that's probably the right answer here.

01:03:57.960 --> 01:04:02.790
And also, one of the good things about
this foundation and SURL is that

01:04:02.960 --> 01:04:04.900
it's extensible by subclassing.

01:04:04.920 --> 01:04:09.820
So you can subclass one of the, you know,
one of the primitive

01:04:09.820 --> 01:04:14.170
here and get your own,
you know, version of it, you know,

01:04:14.220 --> 01:04:15.780
depending on what you're doing.

01:04:15.800 --> 01:04:19.740
Gives, you know, advanced features,
authentication, caching,

01:04:19.740 --> 01:04:23.300
and cookie storage and
management also at this level.

01:04:23.830 --> 01:04:28.180
And when we get on top of that, you know,
ultimately, you know, pretty much Safari,

01:04:28.180 --> 01:04:29.380
you get to the WebKit.

01:04:29.380 --> 01:04:32.870
So the WebKit is the last layer we
introduced last year and it gives,

01:04:32.980 --> 01:04:34.670
you know, very little control.

01:04:34.670 --> 01:04:37.100
But, you know,
we do everything for you there.

01:04:37.220 --> 01:04:40.430
So it's really, really,
it's far away from the networking,

01:04:40.430 --> 01:04:44.010
you know, as the core we were talking
about earlier in the session.

01:04:44.010 --> 01:04:46.710
But, you know,
it gives pluggable architecture,

01:04:46.710 --> 01:04:49.890
new document type, you know,
a lot of things and, you know,

01:04:49.890 --> 01:04:53.240
this is really so far
away from what I'm doing.

01:04:53.240 --> 01:04:56.630
So I'm not going to go
into too much details.

01:04:57.020 --> 01:05:00.930
If you want to know about more about the
CF network and all those layers here,

01:05:00.930 --> 01:05:05.230
I highly recommend probably looking at
the CD at this point because that was

01:05:05.290 --> 01:05:09.480
yesterday to go to Becky's session,
the Modern Networking Using CF Networks.

01:05:09.480 --> 01:05:15.310
So that's, that will talk about all those
layers on top of BSD in much,

01:05:15.340 --> 01:05:21.100
much greater detail than I can do here
because we're running out of time.

01:05:21.500 --> 01:05:27.070
After this, I'd just like a goodbye slide
here for some of the deprecated

01:05:27.070 --> 01:05:29.560
APIs that we have in Mac OS X.

01:05:29.560 --> 01:05:38.050
First thing, the NKE PDF,
the old programming information about

01:05:38.140 --> 01:05:40.510
what to do for network extension,
it's gone.

01:05:40.510 --> 01:05:42.680
We talked about we're changing all that.

01:05:42.750 --> 01:05:44.070
Go to the session this afternoon.

01:05:44.070 --> 01:05:45.180
We'll go into more detail.

01:05:45.180 --> 01:05:46.620
But don't use that anymore.

01:05:46.620 --> 01:05:48.860
Don't use the old KPI there.

01:05:48.860 --> 01:05:52.630
The old network NKE APIs, they're gone.

01:05:53.150 --> 01:05:54.350
They won't.

01:05:54.470 --> 01:05:59.860
Open transport API, well, you know,
CF network or the sockets

01:05:59.860 --> 01:06:01.100
provide more flexibility.

01:06:01.100 --> 01:06:02.320
They've been there for a while.

01:06:02.320 --> 01:06:04.860
We're deprecating them.

01:06:04.860 --> 01:06:08.530
So if you can, you know,
stop using it in your new application

01:06:08.530 --> 01:06:10.200
and all those kind of things.

01:06:10.200 --> 01:06:12.460
Apple Talk API, same thing.

01:06:12.510 --> 01:06:16.860
We've kept, you know, Apple Talk lumping,
you know,

01:06:17.340 --> 01:06:18.840
around in Mac OS X for a long time.

01:06:18.840 --> 01:06:21.350
It's still there,
but the Apple Talk APIs are

01:06:21.350 --> 01:06:22.490
deprecated now.

01:06:22.490 --> 01:06:28.280
We think we have like a good solution now
with rendezvous for service discoveries.

01:06:28.280 --> 01:06:31.900
There's no more need for doing
any new things on Apple Talk.

01:06:31.900 --> 01:06:34.540
So Apple Talk APIs are
getting deprecated.

01:06:36.490 --> 01:06:39.630
And with that,
I'd like to point you to some

01:06:39.630 --> 01:06:42.640
more information-- who to contact.

01:06:42.640 --> 01:06:46.960
Craig Keasley is our
I/O technology evangelist,

01:06:47.030 --> 01:06:48.660
so use him as a contact point.

01:06:48.740 --> 01:06:52.120
And also,
there is a Mac network programming

01:06:52.120 --> 01:06:55.490
mailing list that you can access.

01:06:55.710 --> 01:07:02.380
And there is a bunch of things,
reference documentation here,

01:07:02.480 --> 01:07:04.830
all on the ADC website.

01:07:04.980 --> 01:07:08.060
So I'm not going to go
into detail on that slide,

01:07:08.060 --> 01:07:10.670
but pretty much you go
to the ADC networking,

01:07:10.670 --> 01:07:12.000
and you'll see all that.
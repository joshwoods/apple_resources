WEBVTT

00:00:12.310 --> 00:00:17.660
And please welcome
Cocoa Fire Frameworks Engineer,

00:00:17.720 --> 00:00:19.680
Douglas Davidson.

00:00:26.340 --> 00:00:27.460
Good afternoon, everyone.

00:00:27.660 --> 00:00:28.800
Thank you all for coming.

00:00:28.840 --> 00:00:30.540
My name is Douglas Davidson.

00:00:30.540 --> 00:00:34.230
I'm here to talk to you
about the Cocoa Text system.

00:00:34.440 --> 00:00:39.060
The text system, in some senses,
is at the heart of Cocoa.

00:00:39.060 --> 00:00:42.740
Almost everything in the app kit makes
use of text in one way or another and

00:00:42.840 --> 00:00:45.510
generally uses the text system to do so.

00:00:45.520 --> 00:00:50.040
The Cocoa text system is very
powerful and very flexible.

00:00:50.040 --> 00:00:53.740
It has lots of features,
and there are quite a few

00:00:53.740 --> 00:00:55.880
new features for Tiger.

00:00:57.400 --> 00:01:01.020
So what I'd like to do today is,
first of all, go over briefly what we

00:01:01.020 --> 00:01:02.840
have that's new for Tiger.

00:01:02.840 --> 00:01:07.450
And then I'm going to dive into some
of the inner workings of the text

00:01:07.460 --> 00:01:11.220
system so that by the end of the talk,
I can really give you a

00:01:11.220 --> 00:01:14.000
detailed description of some
of the most significant new

00:01:14.010 --> 00:01:15.600
features and how they work.

00:01:17.240 --> 00:01:21.330
So what do we have that's new for Tiger?

00:01:21.570 --> 00:01:25.590
Those of you who were here last
year may remember I talked about,

00:01:25.640 --> 00:01:28.960
among other things,
our support for Word documents,

00:01:28.960 --> 00:01:31.610
and that was pretty well received.

00:01:31.640 --> 00:01:31.660
But

00:01:31.920 --> 00:01:37.140
Some people would ask me why we didn't
really handle tables in Word documents,

00:01:37.140 --> 00:01:42.200
and I had to tell them the
Cocoa Text system doesn't support tables.

00:01:42.200 --> 00:01:46.250
So, when I got my task list for Tiger,
you can guess what the

00:01:46.250 --> 00:01:47.920
first thing on it was.

00:01:47.950 --> 00:01:49.430
Support tables in the Cocoa Text system.

00:01:49.480 --> 00:01:55.600
So, I'm glad to say that for Tiger,
the Cocoa Text system

00:01:55.600 --> 00:01:55.600
will support tables.

00:01:59.840 --> 00:02:03.170
We thought about this a bit though,
and we realized that while

00:02:03.300 --> 00:02:07.630
tables are important for RTF and
Word documents and so forth,

00:02:07.760 --> 00:02:11.040
what they're really critical for is HTML.

00:02:11.040 --> 00:02:14.830
So for Tiger,
we've also put a lot of effort into our

00:02:14.830 --> 00:02:18.040
HTML support using that table support.

00:02:18.040 --> 00:02:23.030
And in addition, entirely new for Tiger,
the Cocoa Text system

00:02:23.030 --> 00:02:24.950
will now export HTML.

00:02:29.350 --> 00:02:31.380
So let me talk about this.

00:02:31.690 --> 00:02:35.790
Now, I've been speaking of this as
text table support for short,

00:02:35.790 --> 00:02:37.540
because everyone understands that.

00:02:37.610 --> 00:02:41.930
But what we really have here is
something that's a lot more general.

00:02:42.300 --> 00:02:47.160
What we have is a flexible,
extensible mechanism for sizing and

00:02:47.160 --> 00:02:53.760
positioning text blocks of all sorts,
the first application of which is to

00:02:53.760 --> 00:03:04.300
the representation of tables from RTF or
Word documents or HTML or HTML and CSS.

00:03:04.700 --> 00:03:07.630
Now, when I get to the end of the talk,
I'm going to be describing how

00:03:07.630 --> 00:03:09.280
this works in great detail.

00:03:09.550 --> 00:03:14.090
I just want to say that it is a very
general mechanism of text blocks,

00:03:14.090 --> 00:03:20.470
and our intent is to use it for all sorts
of complex layout we might encounter.

00:03:21.500 --> 00:03:26.780
For HTML import,
you may recall that in Panther,

00:03:26.920 --> 00:03:32.360
we have two different
kinds of HTML import.

00:03:32.360 --> 00:03:38.670
There is an older style that has some
support for sophisticated layout,

00:03:38.670 --> 00:03:42.720
but that is rather out of
date and limited in the kinds

00:03:42.720 --> 00:03:44.700
of HTML that it can parse.

00:03:44.700 --> 00:03:47.420
And then there's a second kind,
new for Panther,

00:03:47.420 --> 00:03:51.350
that used WebKit for parsing and
so could handle arbitrary HTML,

00:03:51.350 --> 00:03:54.770
but was rather limited
in its layout support.

00:03:54.790 --> 00:03:56.620
So for Tiger, all of that is gone.

00:03:56.620 --> 00:03:59.440
We have a completely new
HTML import mechanism.

00:03:59.440 --> 00:04:02.670
It uses WebKit for parsing,
so it can handle any

00:04:02.670 --> 00:04:04.840
HTML you're likely to find.

00:04:04.840 --> 00:04:08.880
And it uses the new text
block and text table mechanism

00:04:08.900 --> 00:04:11.310
for complex layout support.

00:04:15.800 --> 00:04:19.860
For HTML export,
whenever you talk about generating HTML,

00:04:19.920 --> 00:04:23.780
the question always comes up,
"What kind of HTML is it that

00:04:23.780 --> 00:04:27.520
you're going to generate?" So when
we were planning this feature,

00:04:27.520 --> 00:04:31.270
we took a little informal survey
of some of the groups at Apple that

00:04:31.270 --> 00:04:33.000
we thought might want to use it.

00:04:33.050 --> 00:04:35.150
And the results were unanimous.

00:04:35.480 --> 00:04:38.980
Every group wanted a
different kind of HTML.

00:04:39.230 --> 00:04:42.910
So we decided we'd just
have to satisfy all of them.

00:04:43.060 --> 00:04:47.490
And what we have is a mechanism
that gives you control over this.

00:04:47.490 --> 00:04:52.440
It allows you to specify exactly
which HTML tags should be generated.

00:04:52.440 --> 00:04:53.940
This gives you a lot of control.

00:04:53.940 --> 00:04:56.200
You can generate HTML.

00:04:56.200 --> 00:05:01.060
You can generate XHTML,
strict or transitional.

00:05:01.060 --> 00:05:04.170
Of course, it's automatically going to
be valid and well-formed.

00:05:05.360 --> 00:05:08.980
You can use CSS in a variety of ways,
or you can use no CSS.

00:05:08.980 --> 00:05:12.860
You could generate a complete
HTML document or just a fragment

00:05:12.860 --> 00:05:14.930
and all sorts of other options.

00:05:14.930 --> 00:05:17.080
Take a look at the release notes.

00:05:17.080 --> 00:05:19.410
I think you're going to like it.

00:05:21.490 --> 00:05:26.400
Now, we're only about halfway through
the Tiger development cycle,

00:05:26.400 --> 00:05:29.700
so these things are not
finished by any means,

00:05:29.700 --> 00:05:35.610
but if we'll go over to the demo machine,
I'll give you a brief look at some

00:05:35.610 --> 00:05:36.610
of the things that are working.

00:05:36.620 --> 00:05:40.880
So,
I have a little demo application here,

00:05:40.880 --> 00:05:43.730
so let me just type into it.

00:05:47.400 --> 00:05:48.400
Thank you, Doug.

00:05:48.400 --> 00:05:48.400
Thank you, Doug.

00:05:48.400 --> 00:05:49.400
So, I'm going to go ahead and save this.

00:05:49.400 --> 00:05:50.550
Maybe make this bold.

00:05:50.550 --> 00:05:52.800
And let me go and save it.

00:05:52.800 --> 00:05:56.940
And I have several -- I've added
several options here for saving this.

00:05:56.960 --> 00:05:59.930
I could save it as rich text or HTML,
Word format.

00:05:59.930 --> 00:06:04.700
We've also added support for
saving this Word's XML format,

00:06:04.700 --> 00:06:05.950
WordML.

00:06:05.960 --> 00:06:08.750
Let me save it as HTML.

00:06:08.760 --> 00:06:13.200
Let me choose to save it
as HTML 4.01 transitional.

00:06:13.200 --> 00:06:17.700
For CSS, I'm going to choose to use
CSS inline for the encoding.

00:06:17.700 --> 00:06:23.210
Well, let me leave it as UTF-8 because,
you know, that's the right thing to do.

00:06:23.210 --> 00:06:29.690
And let me give it a
name and save it out.

00:06:32.600 --> 00:06:36.150
Let's see what kind
of thing we generated.

00:06:36.360 --> 00:06:39.250
Open it to show the source.

00:06:39.490 --> 00:06:43.410
And we have an HTML document.

00:06:53.000 --> 00:06:59.780
Let me bring up,
I have a little Excel spreadsheet here.

00:07:01.000 --> 00:07:05.080
Select it, copy, paste it in here,
and I get a real table.

00:07:07.130 --> 00:07:12.590
Let me just select that and bump up the
size a little so you can see it better.

00:07:12.590 --> 00:07:14.070
Let me make it bold.

00:07:20.370 --> 00:07:23.500
Well, that's working pretty well so far.

00:07:23.500 --> 00:07:28.100
Let me try something a little harder.

00:07:29.460 --> 00:07:33.100
So in Safari, I brought up a possibly
recognizable website.

00:07:33.100 --> 00:07:38.550
Let's just take a look
at the source for that.

00:07:38.930 --> 00:07:47.110
This thing usually has about 50
tables nested four or five deep.

00:07:47.630 --> 00:07:50.650
So let me take this and save it.

00:07:50.670 --> 00:07:54.700
I'll save it using WebKit's
new Web Archive format,

00:07:54.700 --> 00:07:57.190
which of course we now support.

00:08:00.920 --> 00:08:06.850
And then let me go back and
see if I can open that up.

00:08:11.600 --> 00:08:16.700
[Transcript missing]

00:08:21.500 --> 00:08:26.650
"Select it all, maybe make it bold,
and then save it back out.

00:08:26.650 --> 00:08:28.600
Yes, override it."

00:08:29.800 --> 00:08:31.520
And so here it is.

00:08:31.530 --> 00:08:36.600
Let me see if I can open
it back up in Safari.

00:08:36.690 --> 00:08:38.230
And there it is.

00:08:38.270 --> 00:08:41.490
I can see a few glitches
that I'll have to work on,

00:08:41.550 --> 00:08:45.180
but recognizably the same website,
only all bold.

00:08:51.400 --> 00:08:55.820
So, let me emphasize that this is
an import and export mechanism.

00:08:55.820 --> 00:09:01.400
The HTML that we're producing is rather
different from the HTML that went in.

00:09:01.890 --> 00:09:06.300
You'll notice, for one thing,
it's valid and well-formed

00:09:06.300 --> 00:09:10.270
and nicely formatted,
which the original certainly wasn't.

00:09:16.470 --> 00:09:22.790
So while I'm here, there's one more thing
I wanted to show you.

00:09:24.000 --> 00:09:29.370
will be joining us in a few minutes.

00:09:30.170 --> 00:09:33.180
Maybe I want to find
all of the tigers in it.

00:09:33.280 --> 00:09:38.990
So I could just find the tigers, but

00:09:40.090 --> 00:09:45.360
Now we have the possibility
to select all of them as a

00:09:45.360 --> 00:09:47.840
multiple discontinuous selection.

00:09:47.850 --> 00:09:53.180
Maybe make them a little bigger.

00:09:53.180 --> 00:09:57.910
Make it bold, italic, underline,
and so forth.

00:10:00.420 --> 00:10:07.980
Okay, let's go back to the slides and
I can talk a little about that.

00:10:07.980 --> 00:10:10.020
Multiple selection, how does this work?

00:10:10.260 --> 00:10:15.650
Well, there are a variety of methods
in NSTextView that act upon

00:10:15.650 --> 00:10:18.290
or take a selected range.

00:10:18.300 --> 00:10:21.280
So now for Tiger,
all those will have a counterpart

00:10:21.690 --> 00:10:25.040
that works on selected ranges,
which is going to be an

00:10:25.040 --> 00:10:28.080
array of range values.

00:10:28.290 --> 00:10:30.870
The precise details you'll
find in the release notes as

00:10:30.870 --> 00:10:32.300
to exactly what they take.

00:10:32.620 --> 00:10:35.490
What about compatibility?

00:10:35.820 --> 00:10:40.630
Any method that isn't multiple
selection savvy will still continue to

00:10:40.630 --> 00:10:45.400
work just fine on the selected range,
which will just be the first

00:10:45.960 --> 00:10:48.840
selected sub-range if there
is a multiple selection.

00:10:48.860 --> 00:10:52.510
And this turns out to be
a pretty good default.

00:10:52.510 --> 00:10:54.660
Works just fine in most cases.

00:10:54.660 --> 00:10:58.790
In fact, there are still some methods
in the C that you have.

00:10:58.820 --> 00:11:01.160
There are still some methods in the
app kit that haven't been updated.

00:11:01.160 --> 00:11:03.770
And they continue to work
just fine operating on the

00:11:03.770 --> 00:11:05.400
first selected sub-range.

00:11:07.110 --> 00:11:09.570
So what else is new for Tiger?

00:11:09.650 --> 00:11:13.320
Well, now that we're reading and
writing so many different

00:11:13.360 --> 00:11:19.910
formats for import and export,
we've stopped adding a new

00:11:19.920 --> 00:11:21.820
method for each format.

00:11:21.930 --> 00:11:25.590
Instead,
we provided a set of generic methods that

00:11:25.590 --> 00:11:30.610
take the document type as a parameter,
an option, or attribute.

00:11:30.800 --> 00:11:51.100
[Transcript missing]

00:11:51.480 --> 00:11:56.430
And some new document attributes
specifically for HTML export,

00:11:56.520 --> 00:11:59.690
including those that provide the
control that I mentioned over the

00:11:59.690 --> 00:12:04.040
kind of HTML that's being generated,
the tags and the encoding.

00:12:04.430 --> 00:12:07.860
And finally, we have a new document
option for HTML import,

00:12:07.860 --> 00:12:09.490
the Text Size Multiplier.

00:12:09.670 --> 00:12:14.780
This corresponds to the
little buttons in Safari that,

00:12:14.780 --> 00:12:19.110
say,
make the text size larger or smaller.

00:12:20.400 --> 00:12:21.280
What else do we have?

00:12:21.360 --> 00:12:22.230
Text lists.

00:12:22.350 --> 00:12:24.840
I'm going to be talking more
about text lists later on.

00:12:24.840 --> 00:12:32.430
Let me say that our intent is that the
text list feature should be used to

00:12:32.490 --> 00:12:37.340
enable NS TextView to automatically
generate the markers for text lists,

00:12:37.340 --> 00:12:38.840
that is, the numbers of the bullets.

00:12:39.980 --> 00:12:43.830
That is not implemented
in the seed that you have.

00:12:43.830 --> 00:12:49.030
What we have currently is that we
are using this for designating lists

00:12:49.030 --> 00:12:51.590
in HTML import and HTML export.

00:12:53.020 --> 00:12:56.500
We have some additions
to NS paragraph style.

00:12:56.500 --> 00:12:59.700
First of all,
this is where the text blocks and tables

00:12:59.700 --> 00:13:03.600
and text lists are attached to the text,
as I'll be talking about later on.

00:13:03.600 --> 00:13:07.080
We also have the hyphenation factor.

00:13:07.080 --> 00:13:10.490
Previously, this was set up only
globally per layout manager.

00:13:10.490 --> 00:13:16.090
Now, we actually allow you to set it
individually on an individual paragraph.

00:13:17.130 --> 00:13:20.770
We have another factor now,
the tightening factor for truncation.

00:13:20.860 --> 00:13:25.580
If you request truncation with ellipses,
we will first try to tighten up the

00:13:25.580 --> 00:13:30.270
text before truncating it with ellipses,
and this controls how much

00:13:30.270 --> 00:13:31.970
we will try to do that.

00:13:32.310 --> 00:13:37.210
And also, just for support of HTML,
we have a header level on Paragraphs

00:13:37.210 --> 00:13:41.870
that allows us to distinguish
the text that is an HTML header

00:13:41.890 --> 00:13:44.580
from ordinary paragraph text.

00:13:45.660 --> 00:13:50.280
String Drawing We have some
new methods for string drawing.

00:13:50.280 --> 00:13:55.480
They are much like the old ones,
but they have additional options.

00:13:55.480 --> 00:13:59.950
One common request is to be
able to do string drawing with

00:13:59.950 --> 00:14:02.420
the origin at the baseline.

00:14:02.430 --> 00:14:05.310
That is now the default
with these new methods.

00:14:09.900 --> 00:14:12.780
We also have the option of
measuring using either the

00:14:12.780 --> 00:14:18.090
typographic bounds as usual or the
actual image bounds of the glyphs.

00:14:22.600 --> 00:14:26.130
Previously,
the primary method for specifying

00:14:26.130 --> 00:14:29.840
a font has been by name,
by the PostScript name.

00:14:29.840 --> 00:14:33.230
For Tiger,
we are promoting NSFontDescriptor as the

00:14:33.230 --> 00:14:36.120
standard means for specifying a font.

00:14:36.120 --> 00:14:38.600
It has a lot more capabilities.

00:14:38.600 --> 00:14:42.170
It can specify by name, by size,
by traits,

00:14:42.310 --> 00:14:44.010
by the stylistic type of the font.

00:14:44.010 --> 00:14:49.320
It can even group together multiple
fonts to serve as a cascade.

00:14:49.320 --> 00:14:52.000
If you went to the font
talk earlier this week,

00:14:52.050 --> 00:14:56.580
there was a considerable
discussion about NSFontDescriptor.

00:14:57.540 --> 00:15:00.160
There have been some
changes to NS-Typesetter.

00:15:00.160 --> 00:15:02.760
We're deprecating now NS-Simple
Horizontal Typesetter,

00:15:02.760 --> 00:15:05.890
although it will still be there
for backward compatibility.

00:15:06.000 --> 00:15:09.500
We have taken a lot of the
functionality from NS-ATS Typesetter

00:15:09.500 --> 00:15:15.090
that wasn't really ATS-specific
and moved it up into NS-Typesetter.

00:15:15.220 --> 00:15:20.800
This makes it easier to create a
whole new custom typesetting engine

00:15:20.800 --> 00:15:24.020
and hook it up into the text system.

00:15:25.470 --> 00:15:28.520
In addition,
we've added one new method here

00:15:28.680 --> 00:15:36.350
for the typesetter when it wishes
to obtain a rectangle for a line.

00:15:36.400 --> 00:15:37.640
I won't read out the method name.

00:15:37.640 --> 00:15:40.700
We're not trying here to compete
for the longest method name.

00:15:40.700 --> 00:15:43.870
I think Bitmap Binge
Wrap has that all sewn up.

00:15:44.110 --> 00:15:48.140
But actually, all of these parameters are
really necessary and useful,

00:15:48.140 --> 00:15:52.590
as we will see when we
come to the table layout.

00:15:53.940 --> 00:15:56.800
And finally,
some more miscellaneous additions.

00:15:56.840 --> 00:16:01.030
We have a couple of new responder methods
that are implemented in NSTextView.

00:16:01.230 --> 00:16:04.110
One to insert a line break, that is,
a line break as opposed

00:16:04.120 --> 00:16:05.170
to a paragraph break.

00:16:05.210 --> 00:16:09.020
And one to insert a container break,
usually a page break.

00:16:09.020 --> 00:16:13.100
We have a new delegate
method in NSTextView.

00:16:13.100 --> 00:16:18.180
It allows the delegate to control
any changes to the typing attributes.

00:16:18.180 --> 00:16:20.120
This is in addition to
our previous notification.

00:16:21.440 --> 00:16:25.380
NSLayoutManager now has a getter
and setter for its glyph generator.

00:16:25.380 --> 00:16:29.720
There are a number of new
convenience methods for manipulating

00:16:29.720 --> 00:16:33.070
the base writing direction for
right-to-left and left-to-right text

00:16:33.460 --> 00:16:35.820
on attributed strings in TextView.

00:16:35.820 --> 00:16:38.380
And finally,
we have a number of new panels that are

00:16:38.480 --> 00:16:41.860
not yet implemented in the new seed,
but are planned for inspecting

00:16:41.860 --> 00:16:44.410
and modifying links,
lists, and tables in text,

00:16:44.460 --> 00:16:47.260
and they have methods for
bringing them forward.

00:16:50.800 --> 00:16:53.400
So, we've seen what's new.

00:16:53.400 --> 00:16:55.180
Now I'm going to move into
the heart of the talk.

00:16:55.180 --> 00:17:01.110
My aim is, by the end of the talk,
I can discuss in detail exactly how the

00:17:01.110 --> 00:17:03.980
new block and table mechanism works.

00:17:03.980 --> 00:17:07.090
But in order to get there,
first I'm going to talk,

00:17:07.100 --> 00:17:12.160
I'm going to review a bit about how the
layout process works in the text system.

00:17:12.160 --> 00:17:17.060
And then I'm going to discuss some of the
existing classes that are most relevant

00:17:17.060 --> 00:17:19.540
and analogous to the new mechanism.

00:17:20.220 --> 00:17:23.120
Fortunately,
these are classes that I haven't really

00:17:23.180 --> 00:17:27.800
discussed in detail in previous years,
NSTextContainer and NSTextAttachment.

00:17:31.800 --> 00:17:36.170
will review the NS Text List class,
and then I'll get to the

00:17:36.250 --> 00:17:38.260
text blocks and tables.

00:17:38.560 --> 00:17:45.400
So, to review, let's talk about the major
players in the text system.

00:17:45.400 --> 00:17:48.720
At the model level,
the main class is NSTextStorage,

00:17:48.740 --> 00:17:50.830
which stores the text of the document.

00:17:50.870 --> 00:17:53.460
Direct subclass of
NSMutableAttributedString,

00:17:53.490 --> 00:17:56.090
so it holds the characters
and their attributes.

00:17:56.100 --> 00:18:01.640
Then we have the classes that typically
serve as values for attributes,

00:18:01.640 --> 00:18:04.540
and as font for fonts,
and as paragraph style for

00:18:04.540 --> 00:18:07.300
paragraph-level attributes,
and as text attachment

00:18:07.300 --> 00:18:08.900
for attached files.

00:18:08.900 --> 00:18:13.910
And there's NSTextContainer,
which models the geometry of a region

00:18:13.970 --> 00:18:18.170
within which text is to be laid out,
typically a page.

00:18:18.740 --> 00:18:22.690
At the controller level,
the central class of the text system,

00:18:22.690 --> 00:18:25.610
NSLayoutManager,
that manages the whole process and

00:18:25.610 --> 00:18:30.160
calls on a couple of other classes,
NSLiftGenerator and NSTypeSetter,

00:18:30.160 --> 00:18:32.390
to do some work for it.

00:18:32.700 --> 00:18:35.210
And at the view level,
there's a visible face of the

00:18:35.210 --> 00:18:37.810
text system and its text view.

00:18:39.290 --> 00:18:45.340
Now, the job of the text system really is
to go from the characters and their

00:18:45.340 --> 00:18:50.130
attributes in the text storage to
the bits that you see on the screen.

00:18:50.400 --> 00:18:54.170
And to do this, to make this happen,
there are four basic

00:18:54.180 --> 00:18:55.870
processes that occur.

00:18:56.000 --> 00:18:59.100
First of all, attribute fixing.

00:18:59.240 --> 00:19:01.780
This is where the text storage
does this and makes sure that

00:19:01.780 --> 00:19:03.260
the attributes are consistent.

00:19:03.340 --> 00:19:06.080
That is,
that the fonts can actually represent

00:19:06.080 --> 00:19:08.100
the characters to which they're attached.

00:19:08.100 --> 00:19:14.520
And the paragraph level attributes
actually apply to whole paragraphs.

00:19:14.920 --> 00:19:16.740
Then comes glyph generation.

00:19:16.800 --> 00:19:18.400
This is controlled by the Layout Manager.

00:19:18.400 --> 00:19:21.450
The Layout Manager calls on
the glyph generator to do this.

00:19:21.660 --> 00:19:25.370
This is where the characters
and their fonts are converted

00:19:25.410 --> 00:19:27.400
into a sequence of glyphs.

00:19:28.240 --> 00:19:31.010
Then comes layout,
again controlled by the Layout Manager,

00:19:31.030 --> 00:19:33.100
and calls upon the typesetter to do it.

00:19:33.250 --> 00:19:37.590
The typesetter takes these
glyphs and assembles them into

00:19:37.590 --> 00:19:40.550
lines positioned on the page.

00:19:40.940 --> 00:19:44.850
And then comes Display, again,
done by the Layout Manager.

00:19:44.860 --> 00:19:47.830
It takes these glyphs
and their positions,

00:19:47.830 --> 00:19:52.120
and it sends them on down to
Quartz to be rendered on a screen.

00:19:52.790 --> 00:19:56.180
We have a little diagram
of how this occurs.

00:19:56.180 --> 00:19:58.090
On the one side,
we have the glyphs that are

00:19:58.130 --> 00:19:59.770
generated by the glyph generator.

00:19:59.940 --> 00:20:08.880
And as they are assembled into lines
by the typesetter within the geometry

00:20:08.880 --> 00:20:12.340
that's determined by the text container,
they are then displayed in the text view,

00:20:12.340 --> 00:20:12.340
which sits in the window.

00:20:16.000 --> 00:20:19.000
I want to focus particularly on
layout because that's the most

00:20:19.000 --> 00:20:23.340
important process in the new
text block and table mechanism.

00:20:23.380 --> 00:20:28.120
And the way that this occurs in
detail is that the layout manager

00:20:28.120 --> 00:20:33.060
decides that a particular range
of lists needs to be laid out.

00:20:33.100 --> 00:20:37.620
Then it calls on the typesetter
and asks it to lay them out.

00:20:37.720 --> 00:20:40.430
The typesetter then
contacts the text container.

00:20:40.680 --> 00:20:44.140
Remember, the text container models the
geometry of the region within

00:20:44.140 --> 00:20:45.580
which the text is being laid out.

00:20:45.600 --> 00:20:50.810
So the typesetter calls on the text
container to ask it about that geometry,

00:20:50.810 --> 00:20:56.600
to determine the rectangles for
the lines of text on the page.

00:20:56.720 --> 00:21:02.810
Then the typesetter takes its glyphs and
it fills up these lines with the glyphs.

00:21:02.810 --> 00:21:06.600
It figures out exactly where each
glyph should go in each line.

00:21:06.620 --> 00:21:10.520
And then the typesetter calls back
to the layout manager to tell the

00:21:10.520 --> 00:21:14.560
layout manager what it has done,
where each line sits on the page,

00:21:14.560 --> 00:21:18.600
which glyphs go in it,
and exactly where they go in each line.

00:21:18.600 --> 00:21:23.260
And the layout manager stores
this information because it will

00:21:23.270 --> 00:21:28.600
need it later on for display and
interaction and all other purposes.

00:21:29.420 --> 00:21:33.400
So let me talk a little bit
more about NSTextContainer.

00:21:33.450 --> 00:21:38.170
It models the geometry of the region
within which text is to be laid out,

00:21:38.170 --> 00:21:41.800
typically a page,
although it could be other things.

00:21:42.000 --> 00:21:46.120
The stock NSTextContainer object
that you'll get from the app kit

00:21:46.120 --> 00:21:48.690
represents just a simple rectangle.

00:21:49.530 --> 00:21:53.440
You can create a custom NS Text Container
subclass that can represent

00:21:53.440 --> 00:21:56.500
essentially an arbitrary region.

00:21:57.160 --> 00:22:00.730
It will still have a rectangle
that is this bounding rectangle,

00:22:00.730 --> 00:22:05.690
but within that, it gets to control where
the text will be laid out.

00:22:05.700 --> 00:22:08.440
And the way that works is that,
as I said, the typesetter,

00:22:08.440 --> 00:22:11.800
when it's laying out,
calls on the text container,

00:22:11.800 --> 00:22:17.380
and it asks the text container,
it proposes a rectangle for a line,

00:22:17.380 --> 00:22:19.980
and the text container
gets to modify that,

00:22:19.980 --> 00:22:24.140
and return whatever rectangle
for the line it likes.

00:22:24.140 --> 00:22:29.160
Here's a little diagram of that,
showing a possible custom text

00:22:29.160 --> 00:22:33.900
container with some of the rectangles
for the lines that it might

00:22:33.900 --> 00:22:36.330
have returned to the typesetter.

00:22:44.620 --> 00:22:45.860
That's a conceptual overview.

00:22:45.860 --> 00:22:49.210
Let's go back over to the
demo machine and see if I can

00:22:49.220 --> 00:22:51.700
show it to you in action.

00:22:55.450 --> 00:23:04.800
So let me bring up -- let's see
this and start it and run it.

00:23:16.000 --> 00:23:23.560
This is just some text,
but I have set a custom text

00:23:23.560 --> 00:23:27.240
container here on this text view.

00:23:27.240 --> 00:23:31.070
And this text container has a parameter,
and as I modify the parameter,

00:23:31.070 --> 00:23:34.580
the region within which the
text is laid out will change.

00:23:34.580 --> 00:23:38.970
So it will go one way or the other.

00:23:39.780 --> 00:23:44.940
Let me just select it all so you can see
what the actual line rects look like.

00:23:48.130 --> 00:23:51.000
So I modify that.

00:23:51.000 --> 00:23:55.770
Let's take a look at the code.

00:24:07.140 --> 00:24:10.880
There's really only one main method
that has to be implemented here.

00:24:10.880 --> 00:24:14.170
This class has some parameters,
but they just control what

00:24:14.230 --> 00:24:16.080
happens in this method.

00:24:16.170 --> 00:24:21.660
The typesetter is going to
propose a line fragment rectangle,

00:24:21.820 --> 00:24:23.950
and then we are going
to get to modify it.

00:24:24.150 --> 00:24:27.900
And in this case,
what we do is we trim it based

00:24:27.900 --> 00:24:33.090
on this sinusoidal curve that is
the shape of this text container.

00:24:33.100 --> 00:24:38.100
So we figure out where
we are on our sine wave,

00:24:38.100 --> 00:24:45.490
and in one case,
we're going to trim it on the left side.

00:24:45.720 --> 00:24:48.520
And the other case,
we just trim it on the right side,

00:24:48.520 --> 00:24:51.800
and then we just return
our modified rectangle.

00:24:51.800 --> 00:24:52.820
And that's all there is to it.

00:24:52.900 --> 00:24:54.990
There is one more little detail.

00:24:55.150 --> 00:25:00.880
We do have to implement this method to
notify the Layout Manager that we are not

00:25:00.930 --> 00:25:05.880
just a simple rectangular text container,
so that it can turn off

00:25:06.060 --> 00:25:08.080
certain optimizations.

00:25:08.360 --> 00:25:12.140
And that is all that it takes, really,
to implement a custom text container.

00:25:12.210 --> 00:25:14.690
Let's go back to the slides.

00:25:21.400 --> 00:25:26.640
We talk about another
class for text attachments.

00:25:26.640 --> 00:25:28.800
In TextEdit,
you may have dragged in an image

00:25:28.800 --> 00:25:32.960
or some other file into the text,
and it gets attached to the

00:25:32.960 --> 00:25:38.500
text at a specific location,
and it's represented by an image or some

00:25:38.500 --> 00:25:42.090
icon that's drawn inline in the text.

00:25:42.090 --> 00:25:46.170
And the class,
the way that this appears in the text

00:25:46.270 --> 00:25:50.780
storage is as a special character,
the attachment character,

00:25:50.780 --> 00:25:54.360
with a special attribute,
the attachment attribute.

00:25:54.520 --> 00:25:59.780
And the value of the attribute is an
instance of the class NSTextAttachment.

00:25:59.780 --> 00:26:01.500
NSTextAttachment does two things.

00:26:01.670 --> 00:26:05.170
First of all,
it represents the contents of the

00:26:05.180 --> 00:26:08.420
attached file as an NSFileWrapper.

00:26:08.420 --> 00:26:12.880
And second, it has to provide some sort
of visual representation to

00:26:13.040 --> 00:26:15.220
be drawn inline in the text.

00:26:15.300 --> 00:26:20.680
And to do that drawing, it uses a cell,
an NSTextAttachment cell, to be specific.

00:26:20.680 --> 00:26:24.420
Now, by default, if you're dragging
something into TextEdit,

00:26:24.420 --> 00:26:29.710
the NSTextAttachment will automatically
generate an appropriate cell and

00:26:29.720 --> 00:26:34.560
image or other representation,
depending on the contents of the file.

00:26:34.560 --> 00:26:37.970
But as developers,
you don't have to let it do that.

00:26:37.980 --> 00:26:43.570
You can assign your text attachment
a custom text attachment cell,

00:26:43.870 --> 00:26:49.900
either one of a standard class with
perhaps a custom image attached to it.

00:26:49.940 --> 00:26:52.830
If you were at the tips and
tricks talk the other day,

00:26:52.840 --> 00:26:54.460
I gave an example of that.

00:26:54.460 --> 00:27:01.860
Or you can give it an instance of a
custom subclass of NSTextAttachment cell.

00:27:01.860 --> 00:27:04.540
With a custom subclass
of NSTextAttachment cell,

00:27:04.540 --> 00:27:07.960
you can do essentially arbitrary
drawing inline in the text.

00:27:07.980 --> 00:27:09.940
How does this work?

00:27:09.990 --> 00:27:14.980
Well, during glyph generation,
the glyph generator will notice,

00:27:14.980 --> 00:27:19.250
it'll come across the attachment and
not try to generate a glyph because

00:27:19.250 --> 00:27:20.480
there's no glyph to represent it.

00:27:20.480 --> 00:27:24.460
It just puts in a null glyph as a
placeholder for it in the glyph stream.

00:27:24.690 --> 00:27:28.420
Then at layout time,
a typesetter will come across it.

00:27:28.510 --> 00:27:33.610
Notice that there is an attachment there.

00:27:34.470 --> 00:27:38.930
What it needs to know about it
is what space that attachment

00:27:38.990 --> 00:27:42.640
will take up in the text so that
it can position it in the line.

00:27:42.640 --> 00:27:45.950
So it actually calls to
the text attachment cell,

00:27:46.250 --> 00:27:49.990
passing it as arguments,
the position in the text and

00:27:49.990 --> 00:27:53.350
line fragment and so forth,
where it is being laid out.

00:27:53.350 --> 00:27:57.490
And the text attachment cell gets
to decide how big it should be there

00:27:57.490 --> 00:27:59.660
and return that to the typesetter.

00:27:59.660 --> 00:28:03.070
And the typesetter then
reserves that space for it.

00:28:04.240 --> 00:28:06.010
during layout.

00:28:06.530 --> 00:28:11.010
Then when it comes along to display time,
the Layout Manager, as I said,

00:28:11.010 --> 00:28:13.800
the Layout Manager handles the display.

00:28:13.820 --> 00:28:16.560
The Layout Manager notices that
it's not an ordinary glyph,

00:28:16.600 --> 00:28:25.160
it's a text attachment,
and it calls on the text attachment

00:28:25.790 --> 00:28:26.040
cell to do the drawing in the
space that was reserved for it.

00:28:27.600 --> 00:28:32.000
So that a custom text attachment cell
can do more or less arbitrary drawing in

00:28:32.010 --> 00:28:33.890
an arbitrary space inline in the text.

00:28:33.910 --> 00:28:38.520
But there's also one more thing,
and that is that the text view will

00:28:38.520 --> 00:28:43.380
notice where there is a text attachment,
and it will give the text attachment

00:28:43.380 --> 00:28:48.250
cell the opportunity to handle
mouse clicks in that region.

00:28:48.260 --> 00:28:51.740
So you can even do some interaction
with a custom text attachment cell.

00:28:54.160 --> 00:28:58.950
If we go back to the demo machine,
I want to give a tiny little demo.

00:29:03.200 --> 00:29:08.800
So this is the same application,
but if I click on this box,

00:29:08.800 --> 00:29:11.950
I will put in some
custom text attachments.

00:29:11.970 --> 00:29:13.190
And these are just here.

00:29:13.190 --> 00:29:15.190
This example is just a horizontal line.

00:29:15.190 --> 00:29:19.190
I put a few of them in here.

00:29:19.300 --> 00:29:34.600
[Transcript missing]

00:29:35.530 --> 00:29:37.330
That's pretty short.

00:29:37.330 --> 00:29:41.530
As I said, the methods that you
have to implement are,

00:29:41.540 --> 00:29:45.180
first of all,
when the typesetter asks the text

00:29:45.180 --> 00:29:50.580
detachment cell how big it is,
here we're returning a rectangle whose

00:29:50.580 --> 00:29:55.820
size and position is just determined
by the size of the line fragment

00:29:55.820 --> 00:30:00.500
within which we're being laid out,
just a third of it.

00:30:01.380 --> 00:30:05.920
And then when it comes time to draw,
we get a chance to do our own drawing,

00:30:05.920 --> 00:30:07.720
called upon by the layout manager.

00:30:07.720 --> 00:30:10.810
And here I'm just doing
something very simple,

00:30:10.830 --> 00:30:13.250
setting black and filling that rect.

00:30:13.900 --> 00:30:25.900
[Transcript missing]

00:30:33.530 --> 00:30:38.240
We're gonna talk about a new class,
NSTextList.

00:30:38.240 --> 00:30:43.860
The basic principle of our
text list support is that

00:30:43.860 --> 00:30:49.260
all of the text of the list,
including the marker,

00:30:49.260 --> 00:30:54.400
the bullet or numbering,
will appear in the text as usual.

00:30:54.400 --> 00:31:00.930
The NSTextList object itself will
appear as an attribute on the text,

00:31:00.930 --> 00:31:04.440
and it will do primarily two things.

00:31:04.460 --> 00:31:09.010
First of all,
it will specify which portions of the

00:31:09.050 --> 00:31:14.020
text lie within which part of the list,
of which list,

00:31:14.340 --> 00:31:20.660
and it will also determine what the
formatting of the markers will be.

00:31:21.600 --> 00:31:25.170
And as I said,
our intent is that this should

00:31:25.170 --> 00:31:30.040
be used by NS TextView for
automatic generation of markers,

00:31:30.150 --> 00:31:32.600
be they bullets or
numbers or what have you,

00:31:32.600 --> 00:31:34.380
that is not yet implemented in your seed.

00:31:34.380 --> 00:31:38.650
Currently,
we use this for specifying lists

00:31:38.880 --> 00:31:42.140
for HTML import and HTML export.

00:31:43.340 --> 00:31:46.350
Now, how does this actually
appear in the text?

00:31:46.670 --> 00:31:50.800
The text list,
the NSTextList object is intended

00:31:50.800 --> 00:31:54.800
to be a paragraph-level attribute,
so it appears as part

00:31:54.800 --> 00:31:57.250
of NSParagraphStyle.

00:31:57.250 --> 00:31:57.250
But

00:31:58.470 --> 00:31:59.800
Lists can be nested.

00:31:59.930 --> 00:32:02.200
So a given region of text
may not just be in one list,

00:32:02.240 --> 00:32:04.210
it may be in multiple lists.

00:32:04.340 --> 00:32:07.330
So NSParagraphStyle doesn't
have just one NSTextList,

00:32:07.370 --> 00:32:14.360
it has an array of NSTextLists listed in
order from outermost to the innermost.

00:32:14.530 --> 00:32:19.230
That's how we specify which portion
of the text lies in which lists.

00:32:19.490 --> 00:32:23.030
And we have a couple of convenience
methods now in NSIntributedString

00:32:23.030 --> 00:32:28.220
for determining the entire range of
a particular list or the location

00:32:28.220 --> 00:32:31.340
in a list of a particular item.

00:32:31.400 --> 00:32:34.940
And the text list,
NSTextList object itself,

00:32:34.940 --> 00:32:39.590
has some methods for specifying
the format of its markers.

00:32:39.590 --> 00:32:41.730
I'm not going to describe that now.

00:32:41.890 --> 00:32:43.090
You can look at the release notes.

00:32:43.100 --> 00:32:44.100
It's fairly standard.

00:32:44.100 --> 00:32:49.400
We support a number of basic
list formatting options.

00:32:49.400 --> 00:32:52.340
with possibly more to come in the future.

00:32:52.400 --> 00:32:55.740
Now here I have a little
diagram to show how this works.

00:32:55.740 --> 00:33:00.300
Here we have two nested lists,
an outer list and an inner list.

00:33:00.420 --> 00:33:02.540
Some of the text is
only in the outer list.

00:33:02.610 --> 00:33:07.040
In that case, the text lists array just
has the outer list in it.

00:33:07.360 --> 00:33:10.970
And some of the text is in both lists,
the outer and the inner.

00:33:11.160 --> 00:33:17.890
And for those, the text lists array would
have the outer list first,

00:33:17.890 --> 00:33:17.890
then the inner list.

00:33:24.960 --> 00:33:30.470
So now we have all the ingredients
to understand how our text block

00:33:30.520 --> 00:33:34.190
and text table support works.

00:33:34.320 --> 00:33:38.810
I've said that NSTextContainer
represents the geometry within

00:33:38.810 --> 00:33:42.040
which the text is laid out,
and it's quite general and

00:33:42.040 --> 00:33:43.400
flexible at doing that.

00:33:43.400 --> 00:33:45.450
But it's essentially static.

00:33:45.480 --> 00:33:49.700
It doesn't depend on the text
that's being laid out in it.

00:33:49.700 --> 00:33:53.280
The point of the new
mechanism and the new class,

00:33:53.280 --> 00:33:58.400
NSTextBlock, is to allow the text,
attributes on the text,

00:33:58.400 --> 00:34:01.180
to affect how it is laid out.

00:34:01.710 --> 00:34:05.700
So,
an NSText block is going to be attached

00:34:05.940 --> 00:34:11.440
to the text much like an NSText list is,
as an attribute,

00:34:11.500 --> 00:34:16.210
and it's going to participate
in the layout process somewhat

00:34:16.290 --> 00:34:18.440
as an NSText attachment does.

00:34:20.440 --> 00:34:24.150
The contents,
the text in the text blocks,

00:34:24.150 --> 00:34:29.270
will all appear in the text as normal,
and it will all be laid out

00:34:29.290 --> 00:34:33.400
perfectly normally and laid out and
displayed with one little change,

00:34:33.400 --> 00:34:39.450
and that is that the text block is
allowed to affect the line rectangles

00:34:39.450 --> 00:34:43.130
within which the text is being laid out.

00:34:45.410 --> 00:34:49.230
So, the way that the text blocks appear
in the text is very similar to

00:34:49.230 --> 00:34:54.280
that in which text lists appear,
because blocks, again, are going to be

00:34:54.280 --> 00:34:57.640
paragraph-level attributes,
so they appear on the paragraph style,

00:34:57.690 --> 00:35:00.080
and they, too, can be nested.

00:35:00.080 --> 00:35:04.470
So, a given section of text can
be in more than one block.

00:35:05.800 --> 00:35:09.400
And so, in its paragraph style,
in addition to the text lists array,

00:35:09.400 --> 00:35:11.470
it also has an array of text blocks,
again,

00:35:11.470 --> 00:35:13.450
in order from outermost to innermost.

00:35:13.610 --> 00:35:15.760
And again,
we have a couple of convenience

00:35:15.760 --> 00:35:19.930
methods on this attributed string
for determining the entire range

00:35:19.930 --> 00:35:22.600
of a particular block or table.

00:35:22.600 --> 00:35:24.870
I'll get to tables in a minute.

00:35:25.980 --> 00:35:31.080
So how is this treated
when it comes to layout?

00:35:31.080 --> 00:35:34.000
During the layout process,
we are going to define two

00:35:34.270 --> 00:35:37.610
rectangles for a given text block.

00:35:37.730 --> 00:35:40.880
The first one is the layout rectangle.

00:35:40.880 --> 00:35:43.730
That is the rectangle within
which the text of the block is

00:35:43.730 --> 00:35:45.540
actually going to be laid out.

00:35:46.040 --> 00:35:51.280
And then there is the bounds rectangle,
which is a rectangle around

00:35:51.280 --> 00:35:57.020
the text of the block that
also includes space for margin,

00:35:57.070 --> 00:36:00.190
borders, padding,
any additional region around

00:36:00.210 --> 00:36:04.110
the text that is not available
for the layout of other text.

00:36:04.310 --> 00:36:08.430
The layout rect for a block has
to be determined just as layout

00:36:08.430 --> 00:36:12.590
for the block is starting,
immediately before the block is laid out.

00:36:12.690 --> 00:36:15.610
And the way this happens is that
the typesetter notices that it's

00:36:15.610 --> 00:36:21.090
starting to lay out a block of text,
and it calls on its text block and

00:36:21.090 --> 00:36:23.560
asks it what its layout rect should be.

00:36:23.560 --> 00:36:27.690
It passes in the location at
which it's starting to lay out

00:36:27.740 --> 00:36:34.180
text and a containing rectangle,
which for the outermost rectangle,

00:36:34.200 --> 00:36:36.950
would be a bounding rect
for the text container,

00:36:36.950 --> 00:36:39.770
but for inner blocks,
would be the rect of the

00:36:39.830 --> 00:36:42.080
immediately enclosing block.

00:36:43.350 --> 00:36:46.990
And then the bounds rect has
to be determined at the end of

00:36:46.990 --> 00:36:50.910
layout for the block immediately,
as soon as the block has

00:36:50.910 --> 00:36:55.520
finished being laid out,
because the bounds rect generally

00:36:55.520 --> 00:36:58.700
is affected by the length
of the text in the block.

00:36:58.740 --> 00:37:01.680
And again,
the typesetter notices that it's

00:37:01.680 --> 00:37:05.340
finished laying out a block,
and calls on the block,

00:37:05.340 --> 00:37:08.140
and asks it for its bounds rect.

00:37:09.140 --> 00:37:11.890
And the NSText block gets to
determine that rect and pass

00:37:11.890 --> 00:37:13.500
it back to the typesetter.

00:37:13.500 --> 00:37:19.260
And the typesetter then, as usual,
calls out to the layout manager and tells

00:37:19.260 --> 00:37:24.780
the layout manager what it has found out,
stores these two rects for the

00:37:24.780 --> 00:37:29.030
block in the layout manager,
and the layout manager keeps that

00:37:29.030 --> 00:37:30.950
information and maintains it.

00:37:33.520 --> 00:37:35.180
Here's a little diagram.

00:37:35.190 --> 00:37:40.050
So when this block is being laid out,
it's laid out in this layout rectangle,

00:37:40.270 --> 00:37:45.890
which is typically a long
rectangle when we're allowing the

00:37:45.890 --> 00:37:48.690
block to be of arbitrary height.

00:37:48.910 --> 00:37:52.890
Then after the block has been laid out,
then the bounds rectangle is

00:37:52.890 --> 00:37:57.530
sort of wrapped around the text
with any extra space needed for,

00:37:57.810 --> 00:38:02.930
say, margins, border, padding,
whatever the block wants to put there.

00:38:05.050 --> 00:38:08.530
Then when it comes time for display,
again,

00:38:08.540 --> 00:38:11.490
the Layout Manager manages the display.

00:38:11.710 --> 00:38:13.760
The Layout Manager actually
has two methods for display,

00:38:13.760 --> 00:38:18.290
one to draw background and
one to draw the glyphs.

00:38:18.380 --> 00:38:22.340
So when its method is called
for drawing background,

00:38:22.630 --> 00:38:25.220
There's one addition,
and that is that it notices if

00:38:25.240 --> 00:38:28.790
there are text blocks to be drawn,
and it calls upon those text

00:38:28.790 --> 00:38:31.630
blocks in order from outermost
to innermost and asks them to

00:38:31.690 --> 00:38:33.470
do any drawing they need to do.

00:38:33.480 --> 00:38:36.110
And in that case,
they can draw backgrounds,

00:38:36.110 --> 00:38:39.960
they can draw borders,
any sort of decoration that they need.

00:38:39.960 --> 00:38:45.500
And then the usual glyph
background is drawn on top of that.

00:38:46.270 --> 00:38:49.100
And then when the Layout Manager's
method for drawing glyphs is called,

00:38:49.100 --> 00:38:52.090
the glyphs are simply drawn on
top of all this background and

00:38:52.310 --> 00:38:53.690
show up in the right places.

00:38:57.880 --> 00:39:03.080
Now, all that is a general
text block mechanism.

00:39:03.080 --> 00:39:07.920
There is also a specific
version for text tables.

00:39:07.920 --> 00:39:12.260
And we have a subclass of
NSTextBlock called NSTextTableBlock.

00:39:12.280 --> 00:39:20.490
NSTextTableBlock represents a block that
appears as a single cell within a table.

00:39:20.600 --> 00:39:23.990
The distinguishing feature of the
table layout is that the different

00:39:24.280 --> 00:39:27.740
cells in the table have to coordinate
their layout with each other.

00:39:27.820 --> 00:39:33.220
So there is another object, NSTextTable,
that represents the table as a whole.

00:39:33.350 --> 00:39:39.040
And each text table block, each cell,
has a reference to the table as a whole.

00:39:39.080 --> 00:39:43.200
And when it comes time
for layout or for display,

00:39:43.320 --> 00:39:45.780
as I've said,
the layout manager calls upon the block,

00:39:45.780 --> 00:39:48.380
in this case, the NSTextTableBlock.

00:39:48.740 --> 00:39:50.560
And NSTextTableBlock is the block
that represents the table as a whole.

00:39:50.560 --> 00:39:53.260
And when NSTextTableBlock as a
subclass does something special,

00:39:53.280 --> 00:39:59.000
it passes those requests
on to its NSTextTable,

00:39:59.010 --> 00:40:02.860
which coordinates them with all
the other cells of the table and

00:40:02.860 --> 00:40:07.170
returns the appropriate results
or does the appropriate display.

00:40:10.030 --> 00:40:13.640
Now, all this is the general mechanism.

00:40:13.900 --> 00:40:18.730
The standard text block and text
tables and text table block classes

00:40:18.730 --> 00:40:24.680
in the kit have a number of parameters
that determine how they actually

00:40:24.680 --> 00:40:28.200
do size and position themselves.

00:40:29.020 --> 00:40:33.220
These are things like margin, border,
and padding widths on each side,

00:40:33.220 --> 00:40:36.470
content width, and so forth.

00:40:36.470 --> 00:40:40.590
They can be specified either as
an absolute point value or as a

00:40:40.590 --> 00:40:42.880
percentage of the enclosing block.

00:40:42.880 --> 00:40:49.620
And text blocks will draw a
background color if specified.

00:40:49.620 --> 00:40:53.000
They can also specify border colors,
if you like,

00:40:53.000 --> 00:40:54.850
a separate one for each side.

00:40:56.620 --> 00:40:58.620
You can look at the details.

00:40:58.620 --> 00:40:59.620
They're all in the release notes.

00:40:59.620 --> 00:41:03.220
It should be not terribly surprising.

00:41:07.190 --> 00:41:12.540
What I want to emphasize here
is that these do not limit you.

00:41:12.540 --> 00:41:14.720
The mechanism is very general.

00:41:14.890 --> 00:41:19.770
If you have a custom
subclass of an as-text block,

00:41:19.890 --> 00:41:26.870
you can do any sort of sizing and
positioning and decoration that you like.

00:41:28.470 --> 00:41:34.820
So let's go back to the demo machine and
I'll give a little demonstration of this.

00:41:37.560 --> 00:41:44.550
Now, I said that the custom,
that the standard text block class in

00:41:44.850 --> 00:41:47.320
the kit will do a background color.

00:41:47.320 --> 00:41:51.740
It doesn't, at least not yet, support,
for example, background images.

00:41:51.820 --> 00:41:55.460
But there's nothing to prevent
you from writing your own text

00:41:55.460 --> 00:41:57.490
block class that will do that.

00:41:57.540 --> 00:42:01.900
And I've written this tiny little sample
here that does a background image.

00:42:01.900 --> 00:42:04.440
And in addition,
it does some custom sizing.

00:42:04.440 --> 00:42:07.520
It sizes the block to
the size of the image.

00:42:07.520 --> 00:42:11.890
Now, let me turn that on.

00:42:14.900 --> 00:42:19.040
Notice that here is the
text up here in the block.

00:42:19.070 --> 00:42:29.390
And I can select it, make it bigger,
make it bigger if we like, and so forth.

00:42:34.100 --> 00:42:44.200
[Transcript missing]

00:42:44.360 --> 00:42:48.670
The methods that we need
to implement for this are,

00:42:48.670 --> 00:42:52.620
first of all,
when we start the layout of the block,

00:42:52.730 --> 00:42:54.540
we need to get the layout rect.

00:42:54.540 --> 00:42:57.850
And the typesetter will call
upon this custom subclass and

00:42:57.850 --> 00:42:59.620
ask it for the layout rect.

00:42:59.620 --> 00:43:03.990
And here all that I'm doing is
determining the layout rect based

00:43:03.990 --> 00:43:09.300
upon -- determining its width
based upon the size of the image.

00:43:09.300 --> 00:43:11.990
And to be nice,
I've made it centered horizontally

00:43:12.090 --> 00:43:14.490
in the containing rect,
so there's a little bit

00:43:14.550 --> 00:43:15.900
of calculation here.

00:43:15.900 --> 00:43:19.920
But it's pretty straightforward.

00:43:19.920 --> 00:43:23.270
Then when we're called upon
to generate the bounds rect --

00:43:24.120 --> 00:43:28.120
What I'm, although I'm doing here,
is trying to make the bounce

00:43:28.120 --> 00:43:32.300
rect equal to the size,
defined by the size of the image.

00:43:32.370 --> 00:43:35.600
Of course,
it might be that our container is

00:43:35.610 --> 00:43:37.840
not quite big enough for the image,
or it might be that it's bigger

00:43:37.840 --> 00:43:39.310
and we need to center it.

00:43:39.460 --> 00:43:44.040
So there's a little bit of
calculation here to determine

00:43:44.110 --> 00:43:48.090
the bounce rect in those cases,
and we return that.

00:43:48.320 --> 00:43:51.190
And then when it comes time to draw,

00:43:51.320 --> 00:43:55.880
All that we're going to do is
just draw this background image.

00:43:56.190 --> 00:44:00.820
But again, the rect might be smaller
than we actually wanted,

00:44:00.860 --> 00:44:02.310
or it might be bigger
than we actually wanted.

00:44:02.360 --> 00:44:08.690
So we're going to adjust for that
trim or center one way or the other.

00:44:08.690 --> 00:44:10.740
And then so there's a little
more calculation here.

00:44:10.760 --> 00:44:12.920
But again, quite straightforward.

00:44:12.920 --> 00:44:15.360
And then we just draw
the image in the rect.

00:44:19.200 --> 00:44:26.520
That is what is necessary to make
a custom subclass of NS Text Block.

00:44:26.520 --> 00:44:28.790
Now let's go back to the slides.

00:44:31.400 --> 00:44:33.660
and finish up.

00:44:33.660 --> 00:44:35.150
That's what I have to
present to you today.

00:44:35.200 --> 00:44:37.050
If you want to see more,
the first place to go

00:44:37.050 --> 00:44:38.970
is the release notes,
which has detailed

00:44:38.980 --> 00:44:42.740
descriptions of all this.

00:44:42.740 --> 00:44:52.060
For the pre-Tiger features,
there is extensive documentation.

00:44:52.060 --> 00:44:55.580
Actually some of the nice diagrams
I showed you here were taken

00:44:55.580 --> 00:45:00.480
directly from that documentation,
and the samples that I showed

00:45:00.480 --> 00:45:05.480
you here should be available
for download on the ADC website,

00:45:05.480 --> 00:45:07.250
the disk image for this session.

00:45:08.960 --> 00:45:15.710
and contact person,
Matthew Formica and formica@apple.com.
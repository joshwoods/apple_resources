WEBVTT

00:00:12.330 --> 00:00:14.620
Welcome to Wednesday at WWDC.

00:00:14.980 --> 00:00:19.200
This is session 209,
Mac OS X OpenGL in Depth.

00:00:19.240 --> 00:00:21.870
I'm Geoff Staahl,
and we're going to be going into

00:00:21.870 --> 00:00:24.020
OpenGL on the Macintosh today.

00:00:24.020 --> 00:00:29.280
So that's me.

00:00:32.750 --> 00:00:36.010
So, first let's talk about a little
bit what we will and won't

00:00:36.020 --> 00:00:37.920
talk about at this session.

00:00:37.950 --> 00:00:41.180
This session will not be
like an OpenGL 101 session.

00:00:41.210 --> 00:00:45.440
A lot of references for that on the web,
and there's a lot of references

00:00:45.440 --> 00:00:47.730
in books and those kind of things.

00:00:47.730 --> 00:00:47.730
It really

00:00:47.920 --> 00:00:50.610
At WWDC,
we want to take the time to go through

00:00:50.610 --> 00:00:53.780
what differentiates the Mac OS,
what's important for you

00:00:53.780 --> 00:00:56.550
to know about the Mac OS,
and not particularly try and

00:00:56.580 --> 00:00:59.400
teach you exactly how to use
OpenGL in a day or in an hour,

00:00:59.400 --> 00:01:01.400
which is probably a difficult task.

00:01:01.460 --> 00:01:03.800
So if you are interested in,
like you just heard about

00:01:03.940 --> 00:01:07.100
some of the uses of OpenGL,
you've seen the keynote, you say, hey,

00:01:07.190 --> 00:01:09.380
wow, that's a great technology
I want to talk about.

00:01:09.640 --> 00:01:12.190
One thing you can do is you
can go to the OpenGL.org site.

00:01:12.230 --> 00:01:15.630
Great reference,
has a lot of documentation on there,

00:01:15.630 --> 00:01:20.710
has news of what's going on with OpenGL,
and has links to all the specifications

00:01:20.790 --> 00:01:25.600
and all the extension registry
with the extension specifications.

00:01:25.600 --> 00:01:28.840
And this is a key reference for you
when you're working with OpenGL,

00:01:28.900 --> 00:01:31.620
working with an extension,
or working with the API.

00:01:31.620 --> 00:01:33.670
Also, again,
if you're a beginner and you want

00:01:33.670 --> 00:01:36.690
to learn a little bit about OpenGL,
Google's a great reference.

00:01:36.740 --> 00:01:38.320
OpenGL tutorial,
I went and did that the other day,

00:01:38.320 --> 00:01:39.620
and there's some great stuff there.

00:01:39.620 --> 00:01:41.630
Really,
really well put together tutorials

00:01:41.630 --> 00:01:44.960
for just starting out with OpenGL,
which will show you how to get going.

00:01:44.960 --> 00:01:48.240
And a lot of them actually
have Mac OS implementations

00:01:48.240 --> 00:01:51.650
or Mac OS code for you to use,
so you can just immediately

00:01:51.650 --> 00:01:53.310
get going with the Mac.

00:01:53.360 --> 00:01:55.830
Also, again,
if you're starting with OpenGL,

00:01:55.840 --> 00:01:58.280
the programming guide,
which is the Red Book,

00:01:58.280 --> 00:02:00.660
which is affectionately
called the Red Book,

00:02:00.660 --> 00:02:03.810
and that's basically kind of
the step-by-step tutorial about

00:02:03.810 --> 00:02:05.680
what basically is in OpenGL.

00:02:05.680 --> 00:02:07.750
There's also things you should
use for your references,

00:02:07.750 --> 00:02:09.120
like the OpenGL specification.

00:02:09.800 --> 00:02:12.370
And the Blue Book,
which is actually a reference guide.

00:02:12.380 --> 00:02:14.610
Would not recommend that
as kind of a learning tool,

00:02:14.780 --> 00:02:17.090
but definitely while you're using OpenGL,
that's something you should

00:02:17.170 --> 00:02:19.520
have on your desk or on your
computer in kind of PDF form.

00:02:19.520 --> 00:02:21.880
So now, what will we cover?

00:02:21.880 --> 00:02:25.750
What we will cover is
OpenGL on the Mac OS.

00:02:25.760 --> 00:02:29.000
First, I'm going to give an update and
talk about what on the Mac OS is

00:02:29.030 --> 00:02:31.780
new since we talked last,
since we talked last year.

00:02:31.780 --> 00:02:34.750
Then I'm going to move into
OpenGL on the Mac OS and talk a

00:02:34.750 --> 00:02:37.870
little bit about architecture,
talk a little bit about

00:02:37.880 --> 00:02:39.560
OS-dependent data,
which is something kind of new to me.

00:02:39.620 --> 00:02:44.400
This is kind of this mystic data
that you need to understand,

00:02:44.400 --> 00:02:47.590
things like virtual screens and
pixel formats that you may be

00:02:47.590 --> 00:02:51.260
using in your OpenGL applications,
but you may not quite understand

00:02:51.320 --> 00:02:54.330
exactly how they fit in and exactly
how you can best use them to your

00:02:54.630 --> 00:02:55.890
advantage to write great apps.

00:02:56.000 --> 00:02:59.890
And finally, we'll talk about interfaces,
and that'll go kind of a review of

00:02:59.900 --> 00:03:03.050
some of the interfaces you can use,
depending on where you're coming from

00:03:03.050 --> 00:03:04.450
and what kind of application you have.

00:03:04.500 --> 00:03:06.450
Finally,
I'll wrap up with a few techniques

00:03:06.450 --> 00:03:09.600
to take advantage of some of the
great things you can do with Mac OS.

00:03:09.600 --> 00:03:11.990
OpenGL and the Macintosh.

00:03:13.380 --> 00:03:15.460
So let's start again
with the OpenGL update,

00:03:15.490 --> 00:03:16.490
where we've been and where we're going.

00:03:16.500 --> 00:03:19.940
One thing that, if you're familiar with
OpenGL and the Macintosh,

00:03:19.940 --> 00:03:23.630
one thing you'll notice is our
updates are slightly different

00:03:23.630 --> 00:03:25.580
than kind of the regular OS update.

00:03:25.580 --> 00:03:29.490
For some regular OS component,
you may see a major feature

00:03:29.580 --> 00:03:32.490
increase at Panther,
and then if there's a bug or two,

00:03:32.490 --> 00:03:34.470
they'll fix it in the software updates.

00:03:34.970 --> 00:03:37.270
Well,
because of the GPU and because of the

00:03:37.270 --> 00:03:41.660
driver vendors and because of the rate
of increase of hardware capabilities,

00:03:41.660 --> 00:03:45.440
we're continuously trying to rev OpenGL,
trying to get the features that

00:03:45.440 --> 00:03:47.100
you guys need as soon as possible.

00:03:47.100 --> 00:03:50.330
And what this means is you'll
see our update cycle has been

00:03:50.330 --> 00:03:53.790
used software updates an awful
lot to get features to you.

00:03:53.910 --> 00:03:58.150
Just recently, Mac OS X Panther 10.3.4
was a software update,

00:03:58.160 --> 00:04:01.930
and it was a major OpenGL update there,
and you'll continue to see,

00:04:01.930 --> 00:04:04.320
as we move forward, OpenGL updates.

00:04:04.420 --> 00:04:08.410
So what you have right now with
you on the disk that you have on

00:04:08.420 --> 00:04:13.060
the Tiger seed is actually the
current kind of snapshot of OpenGL.

00:04:13.060 --> 00:04:15.670
As we move forward,
we'll try and get more snapshots,

00:04:15.670 --> 00:04:18.230
more seeds, more updates,
and those kind of things as

00:04:18.290 --> 00:04:19.920
we move forward to our Tiger.

00:04:19.920 --> 00:04:22.800
So expect some of the features
I'm going to talk about will

00:04:22.800 --> 00:04:26.220
start rolling out as we move
forward and moving closer to Tiger.

00:04:26.220 --> 00:04:29.310
So what have we been
doing in the past year?

00:04:29.720 --> 00:04:30.850
Well, a lot.

00:04:30.940 --> 00:04:33.490
There's a couple things
that we've been busy with.

00:04:33.880 --> 00:04:37.700
And so since you can't probably
read all this and take it in,

00:04:37.700 --> 00:04:41.090
let's break it down and talk about
in three different categories.

00:04:41.100 --> 00:04:43.710
We'll talk about new features,
talk about performance,

00:04:43.850 --> 00:04:45.960
and we'll talk about
some of the bug fixes.

00:04:45.960 --> 00:04:47.640
And at the end,
we'll talk about looking forward

00:04:47.640 --> 00:04:48.920
and where we're looking to go with.

00:04:50.770 --> 00:04:54.040
So, in Panther,
a couple key features were added,

00:04:54.370 --> 00:04:55.640
which you can take advantage of.

00:04:55.760 --> 00:04:56.650
First, the pixel buffers.

00:04:56.780 --> 00:05:02.460
Pixel buffers basically adapted kind
of the industry standard off-screen

00:05:02.460 --> 00:05:06.310
accelerated rendering API with
a little bit of Mac OS flavor

00:05:06.390 --> 00:05:10.100
to fit into our API as well,
since it is a windowing system API.

00:05:10.100 --> 00:05:11.220
It has to do with the windowing system.

00:05:11.220 --> 00:05:13.420
It allows you to do things
that you couldn't do before

00:05:13.540 --> 00:05:15.040
with off-screen rendering.

00:05:15.040 --> 00:05:18.070
So what this means is you do
not have to bring a window up.

00:05:18.150 --> 00:05:19.950
You can do all your
calculations off-screen,

00:05:20.270 --> 00:05:20.580
and you can do all your
calculations off-screen.

00:05:20.600 --> 00:05:21.900
then look at the contents.

00:05:21.940 --> 00:05:25.030
Things like Core Image can use
pixel buffers to a great advantage,

00:05:25.150 --> 00:05:28.400
do all the calculations off screen,
get the acceleration of the GPU,

00:05:28.520 --> 00:05:31.720
and then get the result and display it
in any way or use it in any way you need,

00:05:31.770 --> 00:05:35.580
from a texture for a different image or
to just displaying it or saving it off

00:05:35.590 --> 00:05:38.060
as maybe a movie or something like that.

00:05:38.110 --> 00:05:40.790
Other things we added were
floating point pixels.

00:05:40.890 --> 00:05:43.340
We didn't make a really
large deal about them.

00:05:43.340 --> 00:05:45.370
It's on our web page that we
have the extension support,

00:05:45.380 --> 00:05:48.060
and you'll notice in some of the pixel
formats that I'll talk about later,

00:05:48.120 --> 00:05:49.560
you can add floating point pixels.

00:05:49.600 --> 00:05:52.220
What this means is you can actually
do calculations and have the

00:05:52.220 --> 00:05:55.320
result be floating point numbers
instead of just RGB coordinates.

00:05:55.320 --> 00:05:58.620
This means you can render a data set.

00:05:58.620 --> 00:05:59.870
We're going to talk about shading later.

00:05:59.990 --> 00:06:02.050
You could take a vertex
or a fragment shader,

00:06:02.290 --> 00:06:04.920
take the results of a rendering,
it might be in floating point pixels,

00:06:05.070 --> 00:06:07.000
and use that as some kind of data set.

00:06:07.120 --> 00:06:11.440
So you could render a procedural
bump map or something like that.

00:06:11.660 --> 00:06:14.370
It's kind of sky's the limit as far
as using the floating point pixels

00:06:14.430 --> 00:06:16.200
and the precision you can use there.

00:06:16.230 --> 00:06:18.520
Also in Panther,
we add a lot of glut enhancements,

00:06:18.520 --> 00:06:20.760
which I'll go over a little bit later,
which for folks,

00:06:20.760 --> 00:06:24.080
especially in the scientific community,
allows people to take advantage of some

00:06:24.080 --> 00:06:27.930
of the unique capabilities of Mac OS,
some of the desktop capabilities,

00:06:28.030 --> 00:06:32.000
some of the capabilities with
integration with other peripherals.

00:06:32.050 --> 00:06:36.650
Since Panther, we've had a lot of work
in the software updates.

00:06:36.680 --> 00:06:39.550
You can see a list of some of
the extensions we've added,

00:06:39.560 --> 00:06:40.480
some of the features we've added.

00:06:40.480 --> 00:06:41.700
This is just the features,
not even talking about

00:06:41.780 --> 00:06:44.000
performance updates.

00:06:44.260 --> 00:06:46.700
What we're trying to do is
we're trying to roll out these

00:06:46.830 --> 00:06:49.780
features as the Arbor proves them,
as they're available in drivers,

00:06:49.780 --> 00:06:53.580
and as we're able to implement them
and get them out to you and as wide

00:06:53.580 --> 00:06:57.900
for a wider audience of users as
possible and as soon as possible.

00:06:57.900 --> 00:07:02.320
So what that means is you'll see things
like this continue on as we move forward.

00:07:02.320 --> 00:07:06.920
Things were added in software updates,
occlusion query, vertex buffer objects,

00:07:07.040 --> 00:07:09.910
much-requested additional
to vertex array range,

00:07:09.920 --> 00:07:12.710
much-requested way of
optimizing transport of vertices

00:07:12.710 --> 00:07:14.100
up to the graphics card.

00:07:14.210 --> 00:07:17.530
And as I go through the presentation,
I'll note some other presentations

00:07:17.600 --> 00:07:18.990
you might be interested in.

00:07:19.460 --> 00:07:22.160
Tomorrow at 10.30,
and I'm not sure the room,

00:07:22.160 --> 00:07:25.310
I believe it might be Nob Hill,
but I'm actually not sure,

00:07:25.350 --> 00:07:27.500
is an OpenGL optimization session.

00:07:27.500 --> 00:07:30.430
And then followed in the afternoon,
there's a session about actually showing

00:07:30.430 --> 00:07:31.780
you how to use some of our tools.

00:07:31.780 --> 00:07:34.650
We'll talk specifically about some
vertex buffer object topics and talk

00:07:34.650 --> 00:07:37.410
about how to use that and how you
can use that in your application.

00:07:37.420 --> 00:07:40.710
Things like point sprite,
non-power of two textures,

00:07:40.710 --> 00:07:43.720
depth balance test,
blend equation separate.

00:07:44.200 --> 00:07:45.050
And texture mirror clamp.

00:07:45.130 --> 00:07:47.420
These are all extensions that were added,
features that were added to

00:07:47.420 --> 00:07:48.610
OpenGL since Panther is shipped.

00:07:48.690 --> 00:07:50.850
In Tiger,
one of the main things in Tiger,

00:07:50.850 --> 00:07:55.250
which we've kind of already announced,
but will be the OpenGL shading language.

00:07:55.260 --> 00:07:57.900
We're working really hard on
OpenGL shading language support.

00:07:57.900 --> 00:08:01.360
You should see it coming soon to you
guys so you can start working with it and

00:08:01.440 --> 00:08:03.620
start working with the shading language.

00:08:03.620 --> 00:08:05.820
And that will be full
support for shading language,

00:08:05.820 --> 00:08:07.700
depending, of course,
on whatever hardware

00:08:07.800 --> 00:08:08.830
you have supporting it.

00:08:09.010 --> 00:08:10.990
But we're also hardware and
software paths for that.

00:08:11.130 --> 00:08:14.130
So you should be able to support
the full API for your application.

00:08:14.200 --> 00:08:15.590
education.

00:08:16.900 --> 00:08:18.060
So performance.

00:08:18.090 --> 00:08:19.140
Again, we've been really busy.

00:08:19.140 --> 00:08:22.050
One of the key things we've heard
is that we really want as much

00:08:22.170 --> 00:08:23.720
performance as possible out of the API.

00:08:23.720 --> 00:08:26.300
So things like, for Panther,
were things like static geometry

00:08:26.300 --> 00:08:27.530
optimizations with DisplayList.

00:08:27.660 --> 00:08:30.990
Since we're the largest
Unix vendor out there,

00:08:31.050 --> 00:08:35.830
a lot of scientific applications
have come to the Mac OS and said,

00:08:35.890 --> 00:08:38.720
hey, I really need to be used
a lot of static geometry,

00:08:38.810 --> 00:08:40.880
molecular modelers, for example.

00:08:40.880 --> 00:08:44.680
So we've optimized the DisplayList
to process into vertex array ranges,

00:08:44.680 --> 00:08:48.140
and this allows you to use static
geometry in the optimal form.

00:08:48.140 --> 00:08:51.240
Improved hardware acceleration
for texture copying.

00:08:51.240 --> 00:08:55.260
GL copy text image,
VRAM to VRAM stays on the card,

00:08:55.260 --> 00:08:56.960
improved speed there.

00:08:56.960 --> 00:09:00.080
Optimized color conversion
and texture compression.

00:09:00.120 --> 00:09:03.690
Things like texture compression,
which many people look at and think, oh,

00:09:03.690 --> 00:09:05.660
I don't want to use texture compression.

00:09:05.660 --> 00:09:08.270
That's that ugly thing that
you get poor textures out of,

00:09:08.280 --> 00:09:10.480
and it really won't
make my app look good.

00:09:10.480 --> 00:09:13.640
Well, it turns out that some of the
texture compression schemes now are

00:09:13.640 --> 00:09:16.600
good enough that you can have less
data and higher quality images by

00:09:16.610 --> 00:09:19.630
allowing you to use larger images
in your app than you could before,

00:09:19.660 --> 00:09:21.510
given your data size constraints.

00:09:21.520 --> 00:09:23.400
So texture compression,
something to look at,

00:09:23.540 --> 00:09:26.000
especially if you're dealing
with large amounts of image data.

00:09:26.020 --> 00:09:27.560
Streamline MIP app generation.

00:09:27.560 --> 00:09:29.100
Again, let's accelerate that.

00:09:29.100 --> 00:09:32.380
Let's get it as fast as possible so
you can get the highest quality images,

00:09:32.380 --> 00:09:34.880
highest quality texture
handling for you guys.

00:09:34.880 --> 00:09:36.050
Panther software updates.

00:09:36.050 --> 00:09:37.640
So since Panther shipped
in the past year,

00:09:37.710 --> 00:09:40.240
we've done things like more
immediate mode optimizations.

00:09:40.240 --> 00:09:40.460
Again, we've done things like more
immediate mode optimizations.

00:09:40.460 --> 00:09:40.460
So again, we've done things like more
immediate mode optimizations.

00:09:40.460 --> 00:09:43.270
Again, scientific applications
coming to the platform,

00:09:43.460 --> 00:09:46.350
needing to use immediate mode,
having a cross-platform

00:09:46.350 --> 00:09:50.400
source-compatible data,
instead of being cross-platform

00:09:50.400 --> 00:09:53.300
source-compatible,
thus they don't have options

00:09:53.300 --> 00:09:56.090
sometimes to change to a vertex
array range or display list.

00:09:56.180 --> 00:09:57.450
They may want to stay in immediate mode.

00:09:57.570 --> 00:09:58.610
So we've optimized that.

00:09:58.710 --> 00:10:00.950
We've improved handling of pixel
data throughout the system,

00:10:01.030 --> 00:10:03.360
working very hard to ensure that
we have an optimum pipeline for

00:10:03.360 --> 00:10:05.010
getting the pixel data through there.

00:10:05.020 --> 00:10:08.960
We also have vertex program emulation,
robustness, and speed enhancement.

00:10:08.960 --> 00:10:11.820
What that means is,
we understand that some of you

00:10:12.250 --> 00:10:15.670
want to run vertex programs and you
don't have the hardware support,

00:10:15.670 --> 00:10:17.790
but you want that to be your only path.

00:10:17.860 --> 00:10:18.850
We understand that.

00:10:18.930 --> 00:10:22.370
We're working to improve that as
much as possible to get you the best

00:10:22.370 --> 00:10:24.570
CPU support for running vertex programs.

00:10:24.910 --> 00:10:27.740
And then obviously,
one thing we always look at is bandwidth

00:10:27.740 --> 00:10:29.440
improvements throughout the whole system.

00:10:29.440 --> 00:10:32.690
And lastly, but not least,
is the adding of asynchronous

00:10:32.710 --> 00:10:34.550
texture fetching as a feature.

00:10:34.680 --> 00:10:38.350
John, in a session tomorrow,
will talk about options for getting

00:10:38.350 --> 00:10:40.140
textures back from the card.

00:10:40.140 --> 00:10:43.400
So, GPU being your coprocessor,
being there's a second

00:10:43.400 --> 00:10:44.380
processor on the system.

00:10:44.380 --> 00:10:45.380
You have a CPU and GPU.

00:10:45.380 --> 00:10:46.840
You want to load balance those.

00:10:47.020 --> 00:10:48.850
And to do that,
you need to be able to get

00:10:48.850 --> 00:10:51.970
the data that you process with
the GPU back off the card.

00:10:52.160 --> 00:10:56.530
Asynchronous texture fetching,
similar to OpenGL as an asynchronous API,

00:10:56.560 --> 00:11:00.410
will allow you to start the retrieval,
use the GPU to push the data

00:11:00.420 --> 00:11:02.790
without using the CPU power,
and then later get the

00:11:03.030 --> 00:11:04.380
data once it's retrieved.

00:11:04.380 --> 00:11:06.760
So that means your application
does not have to block,

00:11:06.930 --> 00:11:09.980
and block at the point where it's
trying to copy the data back.

00:11:09.980 --> 00:11:13.500
if you're moving large amounts
of data back and forth.

00:11:19.580 --> 00:11:21.260
So Tiger and future software updates.

00:11:21.390 --> 00:11:23.410
So what we're looking
for as we move forward,

00:11:23.410 --> 00:11:26.900
we're going to obviously continue
to improve the resource handling.

00:11:26.900 --> 00:11:31.090
What you may have gotten from all the
talks that we've done is that there's

00:11:31.230 --> 00:11:33.460
a lot of clients of OpenGL right now.

00:11:33.460 --> 00:11:37.630
We have tons of people who are
using OpenGL on the system from your

00:11:37.630 --> 00:11:42.120
applications to the Windows server
to core image to core video.

00:11:42.120 --> 00:11:44.220
So, you know,
lots of things you see on the screen

00:11:44.220 --> 00:11:45.780
are now running through OpenGL.

00:11:45.950 --> 00:11:49.780
So it's really important to us,
working from an OS standpoint,

00:11:49.780 --> 00:11:51.520
to make sure the resource
handling is optimized,

00:11:51.520 --> 00:11:52.810
which benefits you guys.

00:11:52.820 --> 00:11:55.110
Because that means you have an optimal
resource handling for your application.

00:11:55.170 --> 00:11:56.400
You gain those same benefits.

00:11:56.400 --> 00:11:58.910
And we're going to also look
to optimize Vertex and Fragment

00:11:58.910 --> 00:12:00.660
Program and Shader implementation.

00:12:00.660 --> 00:12:03.900
So as we move forward with the GLSL,
the OpenGL Shading Language,

00:12:04.040 --> 00:12:06.580
and with Vertex Programs and
Fragment Programs,

00:12:06.580 --> 00:12:09.290
the Assembly Language versions of that,
we're going to look to optimize

00:12:09.370 --> 00:12:12.450
that pipeline and ensure that we
have software support for those and

00:12:12.450 --> 00:12:14.370
optimize software support for those.

00:12:15.270 --> 00:12:19.740
And then the announcement that we
made the other day with new GPUs,

00:12:19.790 --> 00:12:25.280
the NVIDIA G4 6800 Ultra is a
great card to have on the platform.

00:12:25.280 --> 00:12:28.620
And we'll continue to work with both
ATI and NVIDIA as their new products

00:12:28.620 --> 00:12:31.890
come out and get them to the Macintosh
as fast as we can for you guys.

00:12:33.900 --> 00:12:35.030
So, always bugs.

00:12:35.260 --> 00:12:36.660
There's always bugs
that you guys run into.

00:12:36.660 --> 00:12:38.250
Corner case,
something that you may be doing

00:12:38.250 --> 00:12:39.480
differently than what we're doing.

00:12:39.480 --> 00:12:40.980
We want to hear about that.

00:12:41.110 --> 00:12:44.080
We've fixed hundreds of bugs in
Panther since the software update,

00:12:44.300 --> 00:12:46.610
but one thing we want to do is
we want to make sure that we

00:12:46.610 --> 00:12:48.110
know what problems you have.

00:12:48.170 --> 00:12:50.580
So this is my call-out
to you guys to say,

00:12:50.580 --> 00:12:53.600
hey, if you have a bug,
make sure it's in Radar.

00:12:53.600 --> 00:12:57.080
Make sure you file it in the
bug reporter on the ADC website

00:12:57.160 --> 00:12:58.890
and that we know about it.

00:12:58.960 --> 00:13:02.770
If you have questions on it,
you've probably seen our

00:13:02.770 --> 00:13:03.780
emails on the website.

00:13:03.800 --> 00:13:07.800
So you always can obviously query us
either through the website or directly

00:13:07.800 --> 00:13:09.540
and see what the status of things are.

00:13:09.540 --> 00:13:12.060
We want to know what the problems
you're having is so we can correctly

00:13:12.290 --> 00:13:15.310
prioritize and make sure we're covering
the things that are causing you problems.

00:13:17.700 --> 00:13:18.680
So let's look forward.

00:13:18.680 --> 00:13:21.890
So looking forward from today on toward
the shipping of Tiger and beyond,

00:13:21.890 --> 00:13:24.910
one thing that we really want to do
and one thing we feel like we've now,

00:13:24.910 --> 00:13:27.850
we have a mature system,
we're going to continue adding features,

00:13:27.850 --> 00:13:31.160
adding hardware support,
but we really want to focus on quality.

00:13:31.160 --> 00:13:33.550
We have new test suites that
we're implementing on our end.

00:13:33.550 --> 00:13:35.830
We have unprecedented use in Tiger,
as I've talked about,

00:13:35.980 --> 00:13:38.460
things like Core Image, Core Video,
Quartz Extreme, iChat AV,

00:13:38.460 --> 00:13:39.940
those are all built on top of OpenGL.

00:13:39.940 --> 00:13:41.010
We can't build these apps.

00:13:41.080 --> 00:13:43.190
These apps can't be reliable
unless we have a quality,

00:13:43.190 --> 00:13:44.200
bug-free OpenGL stack.

00:13:44.210 --> 00:13:46.070
So it's really important
that we have a quality,

00:13:46.200 --> 00:13:47.580
bug-free OpenGL stack.

00:13:47.600 --> 00:13:48.450
It's really important to us.

00:13:48.510 --> 00:13:49.600
We're working really hard on it.

00:13:49.600 --> 00:13:52.720
And I just want to make sure that you
guys know that's what our focus is.

00:13:52.760 --> 00:13:54.450
And get us the information
and we'll start,

00:13:54.460 --> 00:13:56.700
we'll continue to try and
fix any problems you have.

00:13:58.100 --> 00:13:58.820
So new features.

00:13:58.820 --> 00:14:01.010
We're participating in
the ARB working groups.

00:14:01.010 --> 00:14:04.450
So you're seeing things like what,
I'm not even sure what the

00:14:04.450 --> 00:14:07.950
spec final name will be,
but like render targets or Uber buffers.

00:14:07.960 --> 00:14:10.740
We're working very strongly
with those working groups to

00:14:10.740 --> 00:14:14.410
ensure the spec is a good spec,
good spec for developers to develop on.

00:14:14.620 --> 00:14:16.770
And as soon as things
like that are ratified,

00:14:16.770 --> 00:14:20.090
we're going to start implementing
them as the request and need is

00:14:20.090 --> 00:14:22.220
for the different specifications.

00:14:22.220 --> 00:14:25.800
If you have specifications or
extensions that you're particularly

00:14:25.810 --> 00:14:28.880
interested or particularly
beneficial to your application,

00:14:29.260 --> 00:14:29.900
please let us know.

00:14:30.280 --> 00:14:34.590
File a feature, go to the bug reporter,
file a feature request bug,

00:14:34.590 --> 00:14:37.640
and it will let us know that your
application is either blocked by this

00:14:37.670 --> 00:14:40.320
feature or that you're interested
in using this in the future.

00:14:40.320 --> 00:14:41.540
One thing about the future.

00:14:41.540 --> 00:14:43.220
When is the future for an application?

00:14:43.220 --> 00:14:45.340
You may all be working on
applications right now.

00:14:45.340 --> 00:14:46.100
That's great.

00:14:46.190 --> 00:14:46.900
We want to hear about bugs.

00:14:47.020 --> 00:14:48.110
We want to hear about features.

00:14:48.110 --> 00:14:51.060
But obviously there's some lead
time for us to implement things.

00:14:51.060 --> 00:14:52.160
So thank you.

00:14:52.260 --> 00:14:52.680
Think ahead.

00:14:52.680 --> 00:14:54.000
Think about your next application.

00:14:54.000 --> 00:14:54.610
Hey, cool.

00:14:54.610 --> 00:14:55.890
I'm going to use that thing.

00:14:55.890 --> 00:14:57.480
I'm going to use shading language.

00:14:57.480 --> 00:15:00.060
I'm going to use render
targets in my next application.

00:15:00.110 --> 00:15:01.380
It's really important to me.

00:15:01.380 --> 00:15:02.820
I need that on the system.

00:15:02.820 --> 00:15:04.040
Let us know ahead of time.

00:15:04.260 --> 00:15:07.710
That will give us time to implement
things and get us time to get caught

00:15:07.710 --> 00:15:10.770
up with where you guys are and
where you guys want to be in the,

00:15:10.770 --> 00:15:13.040
what you guys want to use in the Mac OS.

00:15:14.970 --> 00:15:16.040
So now that's the end of the update.

00:15:16.130 --> 00:15:17.040
So that's kind of where we are.

00:15:17.040 --> 00:15:20.160
We brought everyone up to speed so we
know where we came from from last year.

00:15:20.160 --> 00:15:22.690
Let's talk a little bit,
step back and talk a little

00:15:22.690 --> 00:15:23.990
bit about the system itself.

00:15:23.990 --> 00:15:26.770
So one thing that we haven't
really covered before,

00:15:26.770 --> 00:15:29.160
I've kind of talked
about in previous years,

00:15:29.160 --> 00:15:32.910
talking about interfaces and how to
do a few techniques here and there,

00:15:32.980 --> 00:15:37.120
but we really haven't talked about the
architecture of OpenGL and Macintosh,

00:15:37.120 --> 00:15:41.110
what makes it great and what makes it
different than maybe our architecture

00:15:41.110 --> 00:15:43.050
is used to dealing with and how
you can take advantage of that.

00:15:45.150 --> 00:15:47.860
So this is my big sentence here.

00:15:47.860 --> 00:15:52.020
It's a multi-client, multi-threaded,
multi-headed, high-performance graphics

00:15:52.050 --> 00:15:53.460
API with virtualized resources.

00:15:53.460 --> 00:15:59.320
So it's not your parents' graphics API,
nor is it our competitors' graphics API.

00:15:59.320 --> 00:16:04.550
The key here is that there
is a ton of clients using it.

00:16:04.700 --> 00:16:06.780
It has multi-threading capabilities.

00:16:06.780 --> 00:16:08.990
We're trying to eat all the
performance we can out of it,

00:16:08.990 --> 00:16:11.140
and there are things that you
can do and you can do in your

00:16:11.140 --> 00:16:15.080
application to improve your app,
make your app run great on OpenGL.

00:16:15.100 --> 00:16:17.690
So we're going to talk about
the OpenGL driver model,

00:16:17.740 --> 00:16:20.820
talk about how it's architected and
how that matters to your application.

00:16:20.850 --> 00:16:23.070
And then we're going to go into
a little bit about the framework

00:16:23.070 --> 00:16:25.440
model and how the framework model
will fit with your application.

00:16:25.470 --> 00:16:27.630
So even if you're not using OpenGL,
it gives you an idea of

00:16:27.630 --> 00:16:28.720
where you need to start.

00:16:30.650 --> 00:16:32.780
So first thing I want to talk about
is a little bit about the framework

00:16:32.780 --> 00:16:36.110
interface and then the interface of
how this fits into the driver model.

00:16:36.120 --> 00:16:43.860
So the way you read this particular
slide is your application will always use

00:16:43.860 --> 00:16:45.830
OpenGL if you're an OpenGL application.

00:16:45.870 --> 00:16:46.810
That's kind of by definition.

00:16:46.820 --> 00:16:52.630
The second part on your left side is what
interface are you actually accessing,

00:16:52.670 --> 00:16:54.040
what windowing
system-dependent interface.

00:16:54.040 --> 00:16:56.960
And the reason I have stacked
it like this is to show you,

00:16:57.150 --> 00:17:00.480
just for your information,
kind of where things are,

00:17:00.480 --> 00:17:02.640
what things are built on what things.

00:17:02.640 --> 00:17:05.620
So at the bottom layer, we have CGL.

00:17:05.620 --> 00:17:07.920
CGL is kind of the core OpenGL interface.

00:17:07.920 --> 00:17:09.960
It's the base windowing system interface.

00:17:09.960 --> 00:17:12.060
And applications can use this directly.

00:17:12.060 --> 00:17:15.500
The applications like a full-screen
application might use this directly.

00:17:15.500 --> 00:17:19.960
Built on top of that is both AGL and
the NSOpenGL implementations,

00:17:19.960 --> 00:17:22.880
both for NSOpenGL context
and NSOpenGL pixel format.

00:17:22.880 --> 00:17:24.790
And so if you're in a...
If you're in a Cocoa application,

00:17:25.010 --> 00:17:26.900
you want to look at the NS classes there.

00:17:26.900 --> 00:17:29.670
If you're a Carbon application,
AGL is where you want to go.

00:17:29.760 --> 00:17:32.720
But it also says you
don't need to use CGL.

00:17:32.720 --> 00:17:34.510
It's not required that
you use the lowest level.

00:17:34.520 --> 00:17:35.730
You can use that next level up.

00:17:35.870 --> 00:17:39.480
Or further,
if you're an NSOpen... NS... NS...

00:17:39.500 --> 00:17:42.140
If you're an AppKit application,
a Cocoa application,

00:17:42.350 --> 00:17:44.910
and you really want to use OpenGL,
but you don't really want to get

00:17:44.910 --> 00:17:48.080
into the context and pixel format,
you can use the NSOpenGL view directly.

00:17:48.100 --> 00:17:50.940
And what that allows you
to do is it allows you to,

00:17:50.940 --> 00:17:54.020
you know, skip the fact that you need
to handle pixel format.

00:17:54.020 --> 00:17:54.990
Or context.

00:17:55.050 --> 00:17:56.770
You can use the interface
builder interface.

00:17:56.780 --> 00:17:59.320
Use the OpenGL kind of widget.

00:17:59.320 --> 00:18:01.520
And just directly...
NSOpenGL view widget.

00:18:01.520 --> 00:18:04.140
And just directly use that and
link that into your application.

00:18:04.140 --> 00:18:06.170
So it simplifies the process
of getting up and running.

00:18:06.180 --> 00:18:08.130
So that's something you should look
at if you're the Cocoa application.

00:18:08.140 --> 00:18:10.100
And you don't have a lot
of special constraints.

00:18:10.120 --> 00:18:13.400
Above that, actually,
GLUT was built on top of the

00:18:13.480 --> 00:18:16.000
Cocoa Our Cocoa interface.

00:18:16.000 --> 00:18:18.360
And so GLUT is actually...
It's a framework,

00:18:18.380 --> 00:18:22.560
but it's really kind of an
application or a client of NS.

00:18:22.560 --> 00:18:25.270
So one... One thing... One thing
I want to mention about GLUT right

00:18:25.270 --> 00:18:27.390
now is our full GLUT implementation.

00:18:27.430 --> 00:18:30.710
Besides for being a framework,
we also have the sample code

00:18:30.710 --> 00:18:32.120
up on the sample code site.

00:18:32.120 --> 00:18:33.760
So we've released all our code for GLUT.

00:18:33.760 --> 00:18:36.420
So if you ever want to see how
we do things or how things are

00:18:36.430 --> 00:18:38.800
done in the GLUT application,
you always can download

00:18:38.800 --> 00:18:39.480
that and look at it.

00:18:39.570 --> 00:18:41.550
So again,
your application will... What it

00:18:41.550 --> 00:18:43.620
will do is it will reference
some windowing system API.

00:18:43.620 --> 00:18:48.720
GLUT, NSOpenGL view,
some of the NSOpenGL pixel format,

00:18:48.720 --> 00:18:52.780
NSOpenGL context, AGL, or CGL directly.

00:18:52.780 --> 00:18:53.510
It will reference that.

00:18:53.980 --> 00:18:58.950
it'll also reference OpenGL when
it hooks into the system.

00:18:59.200 --> 00:20:47.100
[Transcript missing]

00:20:47.520 --> 00:20:51.520
These then hook into the rasterizers,
and the rasterizers directly

00:20:51.590 --> 00:20:52.340
hook into the hardware.

00:20:52.340 --> 00:20:55.160
It's interesting to note I have
hardware down here on the bottom,

00:20:55.160 --> 00:20:57.460
and you might say, well,
the software renderer is not hardware.

00:20:57.460 --> 00:20:59.960
Well, the software renderer obviously
has a CPU as its hardware.

00:20:59.960 --> 00:21:02.900
So, again,
we're talking about GPUs and CPUs being

00:21:02.900 --> 00:21:05.190
kind of first-class citizens here.

00:21:05.200 --> 00:21:07.940
ATI and NVIDIA renderers work
particularly with their GPUs.

00:21:07.940 --> 00:21:09.460
Our software renderer works with a CPU.

00:21:09.460 --> 00:21:12.100
It might not be the best thing for
all applications because you're using

00:21:12.110 --> 00:21:14.260
a lot of CPU resources up rendering,
but in some cases,

00:21:14.260 --> 00:21:15.500
that may be what you want to do.

00:21:15.560 --> 00:21:19.590
You may want to use a software renderer
either for capabilities that it has

00:21:19.660 --> 00:21:22.320
that some other renderer may not have,
or as your fallback,

00:21:22.410 --> 00:21:24.860
and it will just move
seamlessly onto the CPU.

00:21:28.410 --> 00:21:30.250
So I've talked,
I've thrown out some terms

00:21:30.250 --> 00:21:33.120
here like pixel format,
I've talked about context,

00:21:33.120 --> 00:21:36.640
I've talked about screens
and moving between monitors.

00:21:36.640 --> 00:21:39.150
Those things are based
on OS-dependent data.

00:21:39.160 --> 00:21:41.100
These are things you won't
find on other platforms.

00:21:41.100 --> 00:21:43.180
Particularly,
you may find there are versions of them,

00:21:43.180 --> 00:21:45.960
but you won't find these particular
definitions and these particular

00:21:45.960 --> 00:21:51.820
definitions have a little bit of,
they're a little Mac-specific.

00:21:51.910 --> 00:21:54.720
I mean, while context may exist on
a Windows platform or may

00:21:54.720 --> 00:21:58.170
exist on a Unix platform,
the context has some specific things

00:21:58.170 --> 00:22:00.060
you can do on the Mac platform.

00:22:00.060 --> 00:22:02.910
So what kind of things
are we talking about here?

00:22:02.920 --> 00:22:04.440
Well,
we talk about virtual screens first.

00:22:04.490 --> 00:22:07.600
Virtual screens are a great thing because
you mention virtual screens to someone

00:22:07.680 --> 00:22:09.130
and you see a lot of heads nodding.

00:22:09.140 --> 00:22:10.610
Oh, yeah, virtual screens.

00:22:10.610 --> 00:22:13.610
No one understands what you're
talking about because virtual

00:22:13.610 --> 00:22:15.560
screens are this mysterious bucket.

00:22:15.560 --> 00:22:17.400
It's a parameter for like
choosing a pixel format,

00:22:17.400 --> 00:22:20.170
but I just throw null in there all the
time because I don't know what I'm doing,

00:22:20.170 --> 00:22:21.540
you know, that kind of thing.

00:22:21.540 --> 00:22:23.760
And you're not alone
because everyone does it.

00:22:23.840 --> 00:22:25.320
You know,
this is some of the things when I'm

00:22:25.320 --> 00:22:27.580
putting this presentation together,
I have to go back and look at the

00:22:27.580 --> 00:22:31.340
reference material and ensure that
I have it correct for the presentation.

00:22:31.340 --> 00:22:33.420
Because it's something that,
it's one of those things you use

00:22:33.420 --> 00:22:34.500
once and you don't care about.

00:22:34.590 --> 00:22:36.670
But there are some powerful things
you can do with virtual screens and

00:22:36.670 --> 00:22:37.770
I'll talk about those in a minute.

00:22:37.910 --> 00:22:40.610
Pixel formats,
I think anyone who's used OpenGL knows

00:22:40.810 --> 00:22:42.850
what I understand as a pixel format.

00:22:42.920 --> 00:22:45.800
But we'll talk a little bit about what
really is the pixel format and how you

00:22:45.800 --> 00:22:48.770
can think about it and how you can use
it to your advantage in your application.

00:22:48.780 --> 00:22:49.960
Context.

00:22:50.190 --> 00:22:52.420
Context, basically, again,
the state bucket for OpenGL,

00:22:52.500 --> 00:22:54.650
if you used OpenGL,
you understand about context

00:22:54.720 --> 00:22:56.320
and controlling the rendering.

00:22:56.330 --> 00:22:57.830
And finally,
we'll talk about drawables and

00:22:57.830 --> 00:22:58.630
how to think about drawables.

00:22:58.740 --> 00:23:03.640
So these four things are the only real
OS dependent data you need to know.

00:23:04.490 --> 00:23:09.660
Virtual screen talks about hardware
and what renderer you're using on.

00:23:10.110 --> 00:23:13.270
Pixel format is a specification list,
basically,

00:23:13.510 --> 00:23:16.770
for your application to say what
you want as far as capability.

00:23:16.820 --> 00:23:20.400
Context is OpenGL state
or your rendering target.

00:23:20.880 --> 00:23:24.000
And a drawable is going to be where
you're actually drawing the pixels to.

00:23:24.230 --> 00:23:25.820
That's really the top level.

00:23:25.820 --> 00:23:26.940
That's all you really need to know.

00:23:26.940 --> 00:23:29.140
But let's talk about the details
so you can pick up some more.

00:23:29.210 --> 00:23:31.020
So if you don't remember nothing
else from the presentation,

00:23:31.020 --> 00:23:31.700
remember that.

00:23:31.700 --> 00:23:34.570
And I think when you look at the APIs,
you'll understand more about

00:23:34.590 --> 00:23:37.200
how they work and how they fit
together and it'll make more sense.

00:23:37.240 --> 00:23:38.740
Just one note on this.

00:23:38.740 --> 00:23:41.160
I'm going to use CGL calls
for the presentation,

00:23:41.270 --> 00:23:44.260
just for consistency's sake,
so I didn't have to list

00:23:44.260 --> 00:23:46.320
multiple API versions up here.

00:23:46.320 --> 00:23:49.560
But you don't,
this applies to AGL or NSOpenGL equally.

00:23:49.560 --> 00:23:50.460
It's just I chose to use a CGL.

00:23:50.560 --> 00:23:53.420
I chose to use a CGL once for
consistency in the presentation.

00:23:53.520 --> 00:23:55.520
So let's talk about
OS dependent data flow.

00:23:55.520 --> 00:23:57.450
Again,
something that people may not understand.

00:23:57.600 --> 00:23:59.460
So you, again,
we'll start with the application.

00:23:59.530 --> 00:24:01.630
In this case, we have a slightly
different color application,

00:24:01.760 --> 00:24:03.520
but it's still the same application.

00:24:03.520 --> 00:24:06.520
So it actually, what is it first going to
do when it uses OpenGL?

00:24:06.520 --> 00:24:08.610
It's going to create a pixel format.

00:24:08.730 --> 00:24:10.860
Pixel Format's this thing you give
a little list of attributes for,

00:24:10.860 --> 00:24:12.410
you give it some virtual
screen specifications,

00:24:12.450 --> 00:24:13.130
and you're done, right?

00:24:13.140 --> 00:24:14.270
You don't need to worry about it.

00:24:14.330 --> 00:24:15.590
Well, what does that do?

00:24:15.600 --> 00:24:18.170
That has two pieces of
information that are important.

00:24:18.170 --> 00:24:22.020
One piece of information that's
important is your renderer attributes,

00:24:22.060 --> 00:24:24.690
and that determines your
virtual screen list.

00:24:24.740 --> 00:24:27.970
And then the second piece of
information is your buffer attributes,

00:24:28.020 --> 00:24:30.280
which determines your surface definition.

00:24:30.340 --> 00:24:32.420
So buffer attributes are things,
do I want a depth buffer?

00:24:32.420 --> 00:24:34.590
How deep is my color buffers?

00:24:34.620 --> 00:24:38.560
And that basically makes a definition
of what you'll accept for a surface.

00:24:38.650 --> 00:24:41.040
So, for example,
if you say I want a depth buffer,

00:24:41.040 --> 00:24:43.430
if a renderer didn't happen
to have a depth buffer,

00:24:43.430 --> 00:24:45.280
that's going to prevent
it from being selected.

00:24:45.280 --> 00:24:48.020
For your renderer definition list,
you can do things

00:24:48.020 --> 00:24:51.070
simply like accelerated,
software renderer, you know,

00:24:51.070 --> 00:24:54.780
you can say generic renderer,
or you can pick a particular vendor.

00:24:54.780 --> 00:24:57.280
If, for example,
you know that your application

00:24:57.330 --> 00:25:00.960
only runs on an ATI system,
you can pick ATI, or the same for NVIDIA.

00:25:00.960 --> 00:25:04.230
If it only ran on an NVIDIA system,
you could actually specify in your

00:25:04.230 --> 00:25:07.800
pixel format that I'm only going to
accept an NVIDIA or an ATI renderer.

00:25:07.900 --> 00:25:08.580
So those are renderer attributes.

00:25:08.600 --> 00:25:09.220
So renderer definitions.

00:25:09.220 --> 00:25:13.570
What that'll do is it builds
a list of possible renderers,

00:25:13.670 --> 00:25:15.460
which are basically
possible virtual screens.

00:25:18.600 --> 00:25:19.340
Then you build the context.

00:25:19.340 --> 00:25:20.950
You need the pixel format
to build the context,

00:25:21.000 --> 00:25:24.600
so the context basically kind of
is attached to the pixel format.

00:25:24.600 --> 00:25:26.740
And what the pixel format is
going to do is basically transfer

00:25:26.830 --> 00:25:28.070
this information to the context.

00:25:28.130 --> 00:25:31.230
So this, when you think about it,
you can say, ha-ha,

00:25:31.380 --> 00:25:34.040
now I understand why when
you share attributes and

00:25:34.130 --> 00:25:37.480
share things between context,
they have to basically have

00:25:37.490 --> 00:25:39.530
the same virtual screen list.

00:25:39.560 --> 00:25:42.250
But the virtual screen list,
that pixel format thing,

00:25:42.430 --> 00:25:44.070
defines what renders can be used.

00:25:44.190 --> 00:25:45.730
So for example,
if you want to share textures,

00:25:45.730 --> 00:25:47.440
you have to have renders
that are compatible.

00:25:47.680 --> 00:25:49.440
You have to have, you know,
a list of renders that

00:25:49.450 --> 00:25:51.600
basically kind of have this,
can, texture can be rendered

00:25:51.600 --> 00:25:52.390
in the same places.

00:25:52.400 --> 00:25:55.560
Moving forward,
you have this drawable comes in.

00:25:55.560 --> 00:25:56.520
And drawable can be anything.

00:25:56.520 --> 00:25:58.020
It can be a window,
it can be an off-screen,

00:25:58.020 --> 00:25:59.780
it can be a P-buffer,
it can be a full-screen.

00:25:59.780 --> 00:26:01.780
It doesn't, you know,
drawables aren't special.

00:26:01.780 --> 00:26:04.600
You know, set P-buffer, set drawable,
those are basically

00:26:04.610 --> 00:26:05.840
the same kind of call.

00:26:05.840 --> 00:26:10.160
It's basically setting the information
that the drawable has into,

00:26:10.310 --> 00:26:12.630
when you attach it to the context.

00:26:12.720 --> 00:26:15.330
And what happens when you attach it,
the drawable contains surface

00:26:15.410 --> 00:26:16.580
dimension information.

00:26:17.020 --> 00:26:19.830
And what happens is,
now instead of having a list,

00:26:19.930 --> 00:26:21.760
you still have the list,
but now instead of looking at the

00:26:21.760 --> 00:26:26.560
list of possible virtual screens,
and surfaces as definitions of surfaces,

00:26:26.560 --> 00:26:27.680
you actually create surfaces.

00:26:27.680 --> 00:26:30.570
We actually create, when you attach,
hardware surfaces are created.

00:26:30.680 --> 00:26:33.350
And that surfaces are created both
from the pixel format information,

00:26:33.400 --> 00:26:34.480
and from the drawable size.

00:26:34.480 --> 00:26:35.900
So you then allocated your buffers.

00:26:35.990 --> 00:26:40.970
The, when you actually set the drawable,
you also set a current renderer.

00:26:40.980 --> 00:26:43.920
And so that takes a virtual screen list,
looks at what the characteristics

00:26:43.920 --> 00:26:46.040
of the drawable are,
whether it's on a screen, off-screen,

00:26:46.040 --> 00:26:46.040
or whatever.

00:26:46.120 --> 00:26:48.040
And then selects an appropriate renderer.

00:26:48.040 --> 00:26:49.960
So for example,
if you attach to an off-screen,

00:26:50.050 --> 00:26:51.460
you're going to select
a software renderer,

00:26:51.460 --> 00:26:52.040
for example.

00:26:52.040 --> 00:26:54.380
Or if you attach to something
that's on a monitor that's powered,

00:26:54.380 --> 00:26:56.040
or a screen that's
powered by an ATI card,

00:26:56.040 --> 00:26:58.040
you're going to select an ATI renderer.

00:26:58.040 --> 00:26:58.990
So that's that process.

00:26:59.080 --> 00:27:02.040
So attaching the drawable
does that for you.

00:27:02.040 --> 00:27:04.400
And then finally,
let's just look at the actual

00:27:04.660 --> 00:27:06.040
flow of data through it.

00:27:06.040 --> 00:27:08.970
You take the application,
you're going to issue an OpenGL call.

00:27:09.090 --> 00:27:10.030
It's going to go to the context.

00:27:10.080 --> 00:27:12.010
The context is the OpenGL state.

00:27:12.080 --> 00:27:14.490
It's going to apply that state to it,
and it's also,

00:27:14.490 --> 00:27:15.220
the context knows what runs it.

00:27:15.220 --> 00:27:17.210
It knows what renderer
it's going to have.

00:27:17.290 --> 00:27:19.120
So it then sends the commands
to a specific renderer,

00:27:19.440 --> 00:27:22.220
which then draws into the target surface,
and you see it on the drawable.

00:27:22.400 --> 00:27:24.220
This is kind of a
logical definition of it.

00:27:24.220 --> 00:27:27.220
It's not quite the actual data
flow is not quite like this.

00:27:27.220 --> 00:27:30.570
But you can see logically how it
works and how you can take advantage

00:27:30.580 --> 00:27:32.220
of this in your applications.

00:27:32.220 --> 00:27:35.220
So let's go back and talk about
specifics of things we just showed.

00:27:35.220 --> 00:27:36.220
Virtual screens.

00:27:36.220 --> 00:27:39.220
Is a renderer associated
with a pixel format?

00:27:39.220 --> 00:27:41.040
The reason I say it's associated
with a pixel format is virtual

00:27:41.040 --> 00:27:42.220
screen numbers aren't absolute.

00:27:42.220 --> 00:27:44.220
A pixel format just has a list of them,
0, 1, 2, 3, 4, or 1.

00:27:45.220 --> 00:27:49.090
If you have another pixel format,
you also have a list 0, 1, 2, 3, 4.

00:27:49.320 --> 00:27:52.220
It doesn't mean that 0 and
0 are always the same one.

00:27:52.220 --> 00:27:55.940
This may be an error that someone
can easily make because probably

00:27:55.940 --> 00:27:57.220
they will likely be the same one.

00:27:57.220 --> 00:28:00.770
But there's no guarantee between
two pixel formats that a virtual

00:28:00.930 --> 00:28:04.210
screen of a certain number is
exactly the same virtual screen.

00:28:04.220 --> 00:28:07.220
So a pixel format may have
multiple virtual screens.

00:28:07.220 --> 00:28:09.090
You can get this by virtual screen count.

00:28:09.230 --> 00:28:11.710
So you can actually find out how
many virtual screens or how many

00:28:11.710 --> 00:28:14.220
renderers that pixel format has
through virtual screen count.

00:28:14.510 --> 00:28:16.220
Normally,
anyone out here with a PowerBook,

00:28:16.220 --> 00:28:18.220
they want to run their
OpenGL application.

00:28:18.230 --> 00:28:21.660
What they'll see is when they call choose
pixel format and they look at the list,

00:28:21.660 --> 00:28:22.220
they'll get two probably.

00:28:22.220 --> 00:28:24.220
They'll probably get a software
renderer and they'll probably

00:28:24.220 --> 00:28:25.210
get a hardware renderer.

00:28:25.220 --> 00:28:27.210
We're going to prefer to
use the hardware renderer,

00:28:27.280 --> 00:28:28.220
but you'll also have the
software renderer in the list.

00:28:28.220 --> 00:28:31.220
They're all probably
likely two in most cases.

00:28:32.270 --> 00:28:35.800
So the context current virtual screen,
the screen that is actually current,

00:28:35.800 --> 00:28:38.440
which is get virtual screen call,
we'll give you that,

00:28:38.450 --> 00:28:41.560
is actually associated
with the current renderer.

00:28:41.750 --> 00:28:43.780
So if your current
virtual screen changes,

00:28:43.780 --> 00:28:45.270
your renderer has changed.

00:28:45.300 --> 00:28:47.060
That's a key point here.

00:28:47.060 --> 00:28:49.180
Let's think about this.

00:28:49.460 --> 00:28:54.320
So if you're on an app and you have a
window on one screen and you drag it

00:28:54.400 --> 00:28:56.910
across the other screen and you look
at the virtual screen as you drag it

00:28:56.910 --> 00:28:59.820
and you see a virtual screen change,
that means you actually

00:28:59.820 --> 00:29:00.830
changed renderers.

00:29:01.150 --> 00:29:04.130
That means your capabilities
changed and you should handle that.

00:29:04.130 --> 00:29:07.460
But it also means there's only
one renderer at a certain time.

00:29:07.460 --> 00:29:10.470
So you're only in reference
to one certain renderer.

00:29:11.550 --> 00:29:15.070
And the last kind of caveat there
is obviously with dual-headed cards,

00:29:15.090 --> 00:29:19.540
you could have two 30-inch
monitors hooked to two G4 6800s,

00:29:19.540 --> 00:29:22.570
and both of those will be
on the same virtual screen.

00:29:22.580 --> 00:29:24.870
So dragging between those two windows,
you'll never see a change.

00:29:24.880 --> 00:29:26.030
Your application doesn't
have to do anything.

00:29:26.040 --> 00:29:28.460
Everything's seamless, works perfectly.

00:29:28.460 --> 00:29:30.920
No work required on your end.

00:29:33.280 --> 00:29:35.360
So let's talk about a little bit
of developer notes about this.

00:29:35.360 --> 00:29:38.600
I kind of put some things together
which may be used in your application,

00:29:38.660 --> 00:29:39.840
may be useful to you.

00:29:39.930 --> 00:29:41.980
Virtual screen change, as I said,
equals a renderer change.

00:29:42.000 --> 00:29:42.980
So respond to this.

00:29:43.120 --> 00:29:44.090
Check settings.

00:29:44.090 --> 00:29:45.240
Check capabilities.

00:29:45.240 --> 00:29:48.840
You may have just lost the fact that
you have GLSL shading language on one

00:29:48.840 --> 00:29:50.940
card and didn't have it on another card.

00:29:50.940 --> 00:29:53.160
And you may have just
lost that capability,

00:29:53.160 --> 00:29:57.070
which would actually change the path
you want to take in your application.

00:29:57.410 --> 00:29:58.110
Sharing context.

00:29:58.170 --> 00:30:01.500
There's a tech note on,
or there's a Q&A on this,

00:30:01.600 --> 00:30:04.880
and you might want to look at that if
you're sharing context capabilities.

00:30:04.880 --> 00:30:07.700
But they must have the same,
let me get this right,

00:30:07.940 --> 00:30:10.800
must have pixel formats with the
identical virtual screen list.

00:30:10.800 --> 00:30:12.080
So what does that mean?

00:30:12.140 --> 00:30:15.970
You can create multiple pixel formats
and create context from different

00:30:16.100 --> 00:30:19.470
pixel formats and share them,
but they better end up with

00:30:19.470 --> 00:30:21.470
the same virtual screen list.

00:30:21.480 --> 00:30:23.450
The best way to do this
is one of two ways.

00:30:23.550 --> 00:30:25.790
Either use the same pixel format,
which you guarantee has

00:30:25.840 --> 00:30:29.750
identical to itself,
or the second way is to actually

00:30:29.750 --> 00:30:32.580
specify all the things that are
controlling virtual screens,

00:30:32.580 --> 00:30:36.360
like render ID,
software renderer accelerated,

00:30:36.380 --> 00:30:38.800
no recovery, those kind of things
in your pixel format.

00:30:38.800 --> 00:30:41.320
Make sure they're the same between
the two pixel formats you're using.

00:30:41.320 --> 00:30:43.550
So you can do that as another
way of getting an identical list.

00:30:45.000 --> 00:30:48.050
One thing you might want to do is,
how do you get a current renderer ID?

00:30:48.080 --> 00:30:49.860
Some people want to look at
their application and say,

00:30:49.860 --> 00:30:52.000
hey, I want to display it,
or I want to know what it is,

00:30:52.040 --> 00:30:57.720
or I want to give the user some feedback
they're rendering on the ATI 9800 card.

00:30:57.720 --> 00:30:59.960
And so for this way,
you can get the virtual screen.

00:30:59.960 --> 00:31:04.090
And if you keep the pixel format around,
you can then do a described pixel format,

00:31:04.290 --> 00:31:05.200
get renderer ID.

00:31:05.200 --> 00:31:09.070
And then the renderer ID will then
feed back into our renderer list

00:31:09.070 --> 00:31:11.160
that are listed in our headers.

00:31:11.500 --> 00:31:12.560
They'll tell you the renderer ID.

00:31:12.560 --> 00:31:14.850
So you can actually,
if you wanted to specially

00:31:14.900 --> 00:31:17.480
code some handling of your
app for different renderers,

00:31:17.530 --> 00:31:18.530
you can even just use this.

00:31:18.530 --> 00:31:22.630
Check the renderer ID and understand
what renderer ID you have.

00:31:22.700 --> 00:31:25.350
Caveat here is you need to
keep the pixel format around.

00:31:27.280 --> 00:31:28.570
So let's move to pixel formats now.

00:31:28.720 --> 00:31:30.700
So now we've talked about screens,
we've talked about pixel formats.

00:31:30.720 --> 00:31:34.060
Pixel formats are basically
the OpenGL renderer capability,

00:31:34.060 --> 00:31:36.570
buffer, and buffer depth specification.

00:31:36.630 --> 00:31:37.560
We've talked about that already.

00:31:37.560 --> 00:31:40.010
I've covered a lot of this stuff,
so I'm not going to spend a whole

00:31:40.010 --> 00:31:41.380
pile of time on these slides.

00:31:41.380 --> 00:31:43.940
More to spend on specific
things you can do in your apps.

00:31:44.720 --> 00:31:47.950
So let's go on some tips
to selection of attributes.

00:31:47.960 --> 00:31:51.110
You want to require an
accelerated renderer.

00:31:51.210 --> 00:31:53.060
So applications who want to say,
I don't want a software renderer,

00:31:53.060 --> 00:31:53.880
what do you need to do?

00:31:53.880 --> 00:31:56.140
You need to do accelerated,
you need to do no recovery.

00:31:56.140 --> 00:31:58.490
What this says is get
an accelerated renderer.

00:31:58.830 --> 00:32:02.260
Secondly,
don't give me a software fallback.

00:32:02.340 --> 00:32:04.510
This succeeds,
you have an accelerated renderer,

00:32:04.510 --> 00:32:07.140
there's no case that you ever go
back to software in this case.

00:32:07.140 --> 00:32:08.290
You'll stop rendering.

00:32:08.300 --> 00:32:10.030
So if you only want an
accelerated renderer,

00:32:10.030 --> 00:32:10.530
use this.

00:32:10.530 --> 00:32:11.980
You want to force a software renderer.

00:32:11.980 --> 00:32:14.700
For example, if you want to do a test,
that's a good test for DB.

00:32:14.720 --> 00:32:16.330
Is it a renderer problem?

00:32:16.330 --> 00:32:19.270
Is it a problem with an
ATI card or an NVIDIA card?

00:32:19.270 --> 00:32:23.140
Or is it our problem in the
OpenGL kind of stack and framework?

00:32:23.140 --> 00:32:25.290
Well, in this case,
what you can do is you can

00:32:25.290 --> 00:32:27.940
set the renderer ID and set
for the generic renderer.

00:32:28.150 --> 00:32:30.410
And that allows you to
force a software renderer,

00:32:30.410 --> 00:32:33.660
force on the software path,
great test for your application to make

00:32:33.710 --> 00:32:37.750
sure that where a problem lies maybe
lies with your application and with us.

00:32:39.460 --> 00:32:40.840
Renders to system memory.

00:32:40.840 --> 00:32:42.440
So there's a little
bit of confusion about,

00:32:42.440 --> 00:32:44.600
we talked about P-buffers a
little bit at the beginning,

00:32:44.600 --> 00:32:47.020
I'll talk about P-buffers again,
but there's a little confusion

00:32:47.020 --> 00:32:48.830
about off-screen versus P-buffers.

00:32:48.860 --> 00:32:51.290
Off-screen has been around
forever in the attribute list,

00:32:51.290 --> 00:32:55.000
and I think it's probably been around in
other people's attribute list forever,

00:32:55.040 --> 00:32:56.420
other operating systems.

00:32:56.420 --> 00:33:00.810
But off-screen, you can just say,
in your mind, equals software renderer,

00:33:00.810 --> 00:33:01.940
system memory.

00:33:01.940 --> 00:33:04.000
Well, it's going to be software renderer,
but it's going to be system memory.

00:33:04.000 --> 00:33:05.920
So if you want to
render to system memory,

00:33:05.920 --> 00:33:07.320
not to VRAM, off-screen.

00:33:07.540 --> 00:33:10.400
So think of rendering
off-the-screen into RAM,

00:33:10.400 --> 00:33:13.090
not off-the-screen as
accelerated off-screens.

00:33:17.100 --> 00:36:39.200
[Transcript missing]

00:36:39.810 --> 00:36:42.800
So let's talk about something
new for context parameters.

00:36:42.800 --> 00:36:47.270
One thing we've added for
Tiger is back buffer size control.

00:36:47.430 --> 00:36:49.830
And what this will allow you
to do is people who have,

00:36:49.830 --> 00:36:52.620
especially a video application,
where they know the content

00:36:52.620 --> 00:36:54.020
is only a certain size.

00:36:54.050 --> 00:36:57.160
I know that in this case
I have 720 by 480 content.

00:36:57.170 --> 00:36:58.300
Never going to change.

00:36:58.330 --> 00:36:59.780
Doesn't matter what
the window system does.

00:36:59.780 --> 00:37:01.980
Doesn't matter how big the
person drags the window.

00:37:02.020 --> 00:37:03.140
720 by 480 content.

00:37:03.140 --> 00:37:05.890
There are a lot of applications
who may have an image or something

00:37:05.890 --> 00:37:11.760
in the back buffer who is
centric to the source material,

00:37:11.760 --> 00:37:13.880
not centric to what the
application is doing.

00:37:13.910 --> 00:37:17.200
You can use this parameter,
surface backing size,

00:37:17.250 --> 00:37:18.150
and you can enable it.

00:37:18.160 --> 00:37:20.580
And what this allows you to
do is it allows you to take

00:37:20.580 --> 00:37:23.290
a fixed size back buffer,
will scale the image

00:37:23.290 --> 00:37:25.770
on swap automatically,
and then a variable

00:37:25.770 --> 00:37:27.040
size frame buffer image.

00:37:27.040 --> 00:37:29.280
So when you drag something
larger in the frame buffer,

00:37:29.320 --> 00:37:31.560
it doesn't mean all your buffers
in the back are changing.

00:37:31.610 --> 00:37:33.940
Could be real helpful,
especially in a video application

00:37:33.940 --> 00:37:36.210
or when you're source centric.

00:37:38.400 --> 00:37:39.380
Some more context parameters.

00:37:39.380 --> 00:37:40.900
I'm just going to walk
through this fairly quickly.

00:37:40.900 --> 00:37:42.670
Retrace synchronization, swap limit.

00:37:42.680 --> 00:37:45.230
So if you need to sync to retrace,
swap limit's your key.

00:37:45.240 --> 00:37:47.340
Surface opacity transparency control.

00:37:47.340 --> 00:37:48.160
We've shown this before.

00:37:48.160 --> 00:37:52.050
I think there's a Boeing X demo
on the sample site,

00:37:52.060 --> 00:37:55.180
and this shows you surface
opacity and transparency control.

00:37:55.180 --> 00:37:57.750
You can make OpenGL render
above some on the desktop.

00:37:57.760 --> 00:38:00.620
You render above things so you
actually have a window there,

00:38:00.620 --> 00:38:03.120
but you're not seeing
the actual window itself.

00:38:03.300 --> 00:38:04.310
So that's something you can use there.

00:38:04.540 --> 00:38:05.450
And drawing order.

00:38:05.700 --> 00:38:09.360
You can order the drawing above or
below the actual kind of window surface.

00:38:09.360 --> 00:38:13.070
So you can use that for combining
OpenGL with some other OS features.

00:38:15.600 --> 00:38:16.070
Drawables.

00:38:16.290 --> 00:38:17.460
So let's talk about drawables.

00:38:17.550 --> 00:38:19.630
Drawables are actually
pixels in RAM or VRAM.

00:38:19.730 --> 00:38:22.590
So drawable is actually
going to be the window,

00:38:22.930 --> 00:38:26.300
the P buffer, the off screen, whatever.

00:38:26.570 --> 00:38:27.760
Full screens also.

00:38:27.840 --> 00:38:31.160
And so again, think about this as one
kind of common thing.

00:38:31.160 --> 00:38:33.200
They're all kind of behave the same way.

00:38:33.370 --> 00:38:35.260
Couple different routines
you need to use for them,

00:38:35.260 --> 00:38:37.250
but they're all basically
the same behavior.

00:38:37.380 --> 00:38:41.010
So one thing I wanted to highlight here
is actually using drawables in the splay.

00:38:41.020 --> 00:38:42.540
So in this case,
this little code snippet,

00:38:42.590 --> 00:38:47.910
what it's going to do here,
we use the CG call, OpenGL display mask.

00:38:47.980 --> 00:38:50.240
And that gives us for
the main display ID,

00:38:50.320 --> 00:38:51.110
for example, in this case.

00:38:51.130 --> 00:38:53.590
So what we're doing is we're going,
what is the OpenGL display

00:38:53.590 --> 00:38:55.540
mask for our main display?

00:38:55.910 --> 00:38:59.380
We then use that in our pixel
format attributes to basically say,

00:38:59.380 --> 00:39:01.320
that's the display we want to render on.

00:39:01.320 --> 00:39:05.560
You can see I used display mask here
and the display mask that I got from

00:39:05.680 --> 00:39:07.150
the return on that function call.

00:39:07.360 --> 00:39:08.660
And then I used choose pixel formats.

00:39:08.760 --> 00:39:13.260
But that basically is saying it's
going to set that as your display.

00:39:13.260 --> 00:39:14.870
So you can control display as that way.

00:39:15.160 --> 00:39:17.010
And for example,
you can use this little trick to

00:39:17.010 --> 00:39:20.020
actually get information about a
display before even showing a window.

00:39:20.020 --> 00:39:21.200
No windows created here.

00:39:21.200 --> 00:39:24.500
You can create a context,
set the context current,

00:39:24.500 --> 00:39:27.920
and you can make OpenGL calls like
get string and those kind of things.

00:39:27.920 --> 00:39:34.090
And they'll actually get you valid data
without actually having to draw a window.

00:39:34.970 --> 00:39:35.960
So let's talk on the interfaces.

00:39:35.960 --> 00:39:39.980
And the good news about interfaces this
year is that we've covered it before.

00:39:39.980 --> 00:39:43.400
You can look at the previous sessions,
and we have some documentation

00:39:43.400 --> 00:39:44.330
on the web for that.

00:39:44.350 --> 00:39:47.560
We have the Q&A 1269 interfaces,
and I'm not going to spend a

00:39:47.560 --> 00:39:48.990
half an hour on interfaces.

00:39:50.440 --> 00:39:52.140
So CGL,
we've talked about that a little bit.

00:39:52.140 --> 00:39:52.830
It's core OpenGL.

00:39:52.900 --> 00:39:54.380
It's the lowest-level interface.

00:39:54.380 --> 00:39:55.820
It's low-level.

00:39:55.820 --> 00:39:58.720
It's the basis for AGL and NSOpenGL.

00:39:58.720 --> 00:39:59.960
It's full-screen only.

00:39:59.990 --> 00:40:03.060
No windowing system connections there.

00:40:03.060 --> 00:40:04.900
You can't draw a window
attached to a window.

00:40:04.900 --> 00:40:07.700
But you can do things
like P buffers with CGL.

00:40:07.700 --> 00:40:10.900
And for context setup,
you can see last year's presentation,

00:40:10.900 --> 00:40:12.770
there's a lot of samples on the web.

00:40:12.770 --> 00:40:15.890
And in this case, I have the
GL Carbon CGL full-screen sample.

00:40:16.050 --> 00:40:17.390
It's on the web right now.

00:40:17.390 --> 00:40:18.870
You can download that.

00:40:19.030 --> 00:40:23.790
It goes through all the setup
for CGL for our CGL application.

00:40:24.120 --> 00:40:24.580
AGL.

00:40:24.580 --> 00:40:25.820
AGL is the Carbon Interface.

00:40:25.820 --> 00:40:28.960
No reason to think of
AGL as some strange thing.

00:40:28.960 --> 00:40:30.650
And how does AGL fit to everything else?

00:40:30.780 --> 00:40:32.400
AGL, Carbon, good.

00:40:32.400 --> 00:40:37.400
So,
it has windowing and full-screen support.

00:40:37.400 --> 00:40:40.420
So you can do windows, obviously, Carbon,
you want to attach to a window.

00:40:40.420 --> 00:40:43.780
Or you can use the AGL full-screen,
which will do a full-screen and

00:40:43.780 --> 00:40:45.940
basically capture the screen for you.

00:40:46.840 --> 00:40:47.760
Again, same thing.

00:40:47.760 --> 00:40:53.310
See last year's presentation or
GL Carbon AGL window as an example

00:40:53.310 --> 00:40:56.050
of how to do AGL system setup.

00:40:56.060 --> 00:40:58.550
I don't want to spend a half an
hour going through things here

00:40:58.560 --> 00:41:01.560
that I think you all can work
through and ask questions about

00:41:01.560 --> 00:41:03.490
and read the documentation we have.

00:41:03.500 --> 00:41:05.820
I think that stuff we've
covered previously.

00:41:05.820 --> 00:41:06.570
NS OpenGL.

00:41:06.590 --> 00:41:08.410
A little bit more depth here.

00:41:08.410 --> 00:41:10.700
There's two ways to handle NS OpenGL.

00:41:10.790 --> 00:41:13.600
There's one way is kind
of the NS OpenGL view.

00:41:13.600 --> 00:41:16.500
And one way is more
using the pick-up line.

00:41:16.520 --> 00:41:18.220
So, there's a pixel format and context.

00:41:18.230 --> 00:41:19.020
Why do you do what?

00:41:19.020 --> 00:41:21.340
That's one of the things that
people may not understand.

00:41:21.340 --> 00:41:23.900
You're in an interface builder
and you have the NS OpenGL view.

00:41:23.900 --> 00:41:25.350
Well, do I really want to use that?

00:41:25.350 --> 00:41:26.320
Not sure.

00:41:26.320 --> 00:41:30.310
What you do is you look at what you
need to do with the relationship

00:41:30.360 --> 00:41:32.850
between a context and a pixel format.

00:41:32.850 --> 00:41:36.870
For NS OpenGL view,
there's one pixel format and one context.

00:41:36.870 --> 00:41:38.780
That's set behind the scenes.

00:41:39.080 --> 00:41:40.530
You can't control that.

00:41:40.620 --> 00:41:42.570
If you have a different
kind of relationship,

00:41:42.570 --> 00:41:44.870
you need multiple context,
multiple pixel formats,

00:41:44.870 --> 00:41:46.320
you need to change some things up.

00:41:46.710 --> 00:41:49.230
You may want to do a
custom subclass of NS view.

00:41:49.360 --> 00:41:52.360
The good news again is there are samples
on the web to do both of these things.

00:41:52.360 --> 00:41:54.440
So, you can see how to
make a custom subclass.

00:41:54.440 --> 00:41:56.560
It should be basically
skeletoned out for you.

00:41:56.700 --> 00:41:58.440
And so,
you can use that just as easily as

00:41:58.520 --> 00:42:00.360
you would do in an NS OpenGL view.

00:42:00.360 --> 00:42:02.360
And if you look at
that particular sample,

00:42:02.360 --> 00:42:06.960
the custom Cocoa OpenGL sample,
there's a file in there that basically

00:42:06.960 --> 00:42:12.290
is the equivalent functionality for
NS OpenGL view in one particular .m file.

00:42:12.410 --> 00:42:16.360
And what that you can do is modify that
as you would need for your custom class.

00:42:16.380 --> 00:42:18.200
So basically,
it brings you back to the point

00:42:18.200 --> 00:42:20.730
where you got with NSOpenGL view.

00:42:22.120 --> 00:42:23.270
Let's talk about GLUT for a minute.

00:42:23.270 --> 00:42:24.860
Excuse me.

00:42:24.860 --> 00:42:28.140
So GLUT is for cross-platform
source compatibility.

00:42:28.140 --> 00:42:30.890
So if you want a full app
that runs without having to

00:42:30.890 --> 00:42:36.460
do anything between the OI,
between Windows, Junix, Mac OS,

00:42:36.500 --> 00:42:38.150
and also Linux.

00:42:38.160 --> 00:42:39.250
I shouldn't leave out Linux there.

00:42:39.500 --> 00:42:40.530
You can use GLUT.

00:42:40.670 --> 00:42:43.420
And GLUT contains a Windows system
and an event system.

00:42:43.420 --> 00:42:44.650
That's the good news.

00:42:44.740 --> 00:42:47.920
The bad news about GLUT is
it's fairly old in design.

00:42:47.920 --> 00:42:49.270
It's a number of years old now.

00:42:49.270 --> 00:42:52.620
And it actually is fairly
limited in what you can do.

00:42:52.620 --> 00:42:54.570
There's some amazing apps
that have been done with GLUT.

00:42:54.570 --> 00:42:58.130
But I think if you talk to those authors,
at some point you become,

00:42:58.130 --> 00:43:01.950
you're almost fighting upstream
against what GLUT wants you to do.

00:43:01.980 --> 00:43:03.490
Great for prototyping.

00:43:03.560 --> 00:43:08.080
Great for an application that can work
within the constraints of the API.

00:43:08.080 --> 00:43:14.620
Probably not great for a fully,
I'm sorry, an application.

00:43:14.680 --> 00:43:17.280
But it's a full GUI that wants
to do some user interactions

00:43:17.280 --> 00:43:18.920
that may be fairly complicated.

00:43:18.920 --> 00:43:22.770
Things that are specific for Mac OS,
which is why I want to talk here.

00:43:23.050 --> 00:43:24.740
There's GLUT sample code, as I mentioned.

00:43:24.740 --> 00:43:26.970
And the GLUT sample code,
you can go to the readme in there,

00:43:26.970 --> 00:43:29.760
and they go through all the things
we've added to GLUT that are Mac OS.

00:43:29.760 --> 00:43:33.930
Some of the highlights are use extended
desktop on startup for an application.

00:43:33.970 --> 00:43:37.640
So that means what you can actually
do is you can actually have a window

00:43:37.640 --> 00:43:39.420
that expands the full desktop.

00:43:39.420 --> 00:43:42.340
And you can do that for
like GLUT with full screen.

00:43:42.340 --> 00:43:44.610
We have a developer who's
doing stereo applications.

00:43:44.660 --> 00:43:47.350
By having a window that's
stretched across two displays,

00:43:47.370 --> 00:43:49.750
using two projectors,
and putting two screens up,

00:43:50.160 --> 00:43:52.190
putting one frame of the
stereo image on one screen,

00:43:52.190 --> 00:43:54.780
one frame of the stereo
image on the other screen.

00:43:54.780 --> 00:44:09.390
So the video card, as far as it's seen,
is seeing the image rendered

00:44:09.390 --> 00:44:14.640
into two projectors.

00:44:14.640 --> 00:44:14.640
So from the user standpoint,
it looks like two separate projectors,

00:44:14.640 --> 00:44:14.640
stereo image, works great.

00:44:14.640 --> 00:44:14.640
From the development standpoint,
it's just one big image with two

00:44:14.640 --> 00:44:14.640
frames rendered side by side.

00:44:14.640 --> 00:44:14.640
Use Mac OS coordinates.

00:44:14.640 --> 00:44:14.640
You can use negative coordinates
as far as specifying windows.

00:44:14.640 --> 00:44:14.640
Otherwise,
GLUT normally would clamp to 0, 0.

00:44:14.640 --> 00:44:15.980
So it allows you to move windows on
a desktop with negative coordinates.

00:44:16.000 --> 00:44:17.580
Capture things single display.

00:44:17.750 --> 00:44:19.710
If you have a GLUT application
that you only want to have

00:44:19.720 --> 00:44:22.200
one display full screen,
you can use that.

00:44:22.210 --> 00:44:25.250
And GLUT stereo,
so stereo support is in GLUT.

00:44:25.250 --> 00:44:28.860
We have UTF-8 string
support for both inputs.

00:44:28.990 --> 00:44:30.040
So you get foreign keyboards.

00:44:30.310 --> 00:44:31.240
And we have it internally.

00:44:31.240 --> 00:44:32.680
And we have an add exit handler.

00:44:32.720 --> 00:44:35.230
So if you have to do cleanup on GLUT,
GLUT normally exits without

00:44:35.230 --> 00:44:36.180
telling you about it.

00:44:36.180 --> 00:44:39.490
You can set up the add exit handler so
it calls your code prior to GLUT exiting

00:44:39.490 --> 00:44:41.170
so you can clean up what you're doing.

00:44:42.500 --> 00:44:44.770
Again,
Glut Basics sample code is on the web,

00:44:44.870 --> 00:44:48.220
so you can look at that
for basics of using Glut.

00:44:48.390 --> 00:44:50.630
So the final session I'll talk
about here is actually talking about

00:44:50.660 --> 00:44:53.720
some techniques in using Mac OS,
some things, again,

00:44:53.720 --> 00:44:55.820
that may not be obvious,
may not be clear,

00:44:55.820 --> 00:45:00.180
and talks actually about a few
new things that we have for Tiger.

00:45:01.900 --> 00:45:04.160
So I'm going to talk about
detection of functionality,

00:45:04.180 --> 00:45:06.890
OpenGL macros,
some texture loading stuff,

00:45:07.050 --> 00:45:10.150
context sharing, and finally,
I'm going to talk about pixel

00:45:10.150 --> 00:45:12.610
buffers and some remote rendering.

00:45:12.890 --> 00:45:13.620
Detecting functionality.

00:45:13.620 --> 00:45:20.500
I think I've gone through this before,
and there's some great samples for this,

00:45:20.510 --> 00:45:23.820
and there's a tech note
specifically on this.

00:45:23.860 --> 00:45:27.850
The key for detecting functionality,
kind of my soapbox for this,

00:45:27.850 --> 00:45:29.100
is don't ignore it.

00:45:29.160 --> 00:45:33.370
The fact that you normally
see texture rectangle,

00:45:33.370 --> 00:45:34.710
for example.

00:45:34.720 --> 00:45:38.000
Most cards, other than the Rage 128,
have support for texture rectangle.

00:45:38.000 --> 00:45:40.090
Don't ignore the fact that
some user might be running

00:45:40.090 --> 00:45:41.850
your application on a Rage 128.

00:45:42.610 --> 00:45:43.760
So check for that functionality.

00:45:43.760 --> 00:45:45.060
Look at the extension string.

00:45:45.060 --> 00:45:47.630
Use GLU check extension to
make sure it's supported.

00:45:47.640 --> 00:45:51.920
Understand what functionality
needs to be supported for your

00:45:51.920 --> 00:45:53.300
extension to be supported.

00:45:53.300 --> 00:45:55.790
For example,
we talked about OpenGL shading language.

00:45:55.820 --> 00:46:00.710
Arb Shader Language 1.00, but it's 100,
is the name of the extension.

00:46:00.760 --> 00:46:03.760
And if that extension is not available,
then the shading language

00:46:03.760 --> 00:46:04.710
will not be available yet.

00:46:04.800 --> 00:46:06.820
So once you see that extension,
you can expect the shading

00:46:06.820 --> 00:46:07.920
language to be available.

00:46:07.920 --> 00:46:09.410
Same for all of the new functionality.

00:46:09.420 --> 00:46:12.360
You can check it before
you use the functionality.

00:46:12.360 --> 00:46:15.000
should be not a problem for you.

00:46:15.710 --> 00:46:16.530
So OpenGL macros.

00:46:16.550 --> 00:46:18.820
Again, something that some
people are not aware of.

00:46:19.180 --> 00:46:25.550
So the Mac OS, not the Mac OS,
PowerPC architecture has a slightly

00:46:25.580 --> 00:46:30.740
higher overhead per function
call than an Intel architecture.

00:46:30.740 --> 00:46:32.800
So does that really matter to you?

00:46:32.800 --> 00:46:36.630
Well, for most applications,
probably not from the OpenGL standpoint.

00:46:36.740 --> 00:46:39.750
But if you're using immediate mode,
you're really pounding the

00:46:39.750 --> 00:46:43.140
application hard and you're millions
of function calls per second,

00:46:43.140 --> 00:46:45.580
this may be a significant
part of the problem.

00:46:45.610 --> 00:46:47.770
So OpenGL can be a significant
part of your overhead.

00:46:47.770 --> 00:46:50.080
We provided you with the CGL macros,
which eliminates one

00:46:50.080 --> 00:46:51.130
level of function calls.

00:46:51.180 --> 00:46:54.440
And for applications that are really in
immediate mode that are actually sending

00:46:54.440 --> 00:46:57.660
a lot of function calls to OpenGL,
this can be a significant speed-up.

00:46:57.970 --> 00:46:59.750
Other folks who are
using vertex array range,

00:46:59.850 --> 00:47:01.850
display list,
and actually don't have a high

00:47:01.850 --> 00:47:04.530
call frequency may not see
any speed-up at all from this.

00:47:04.530 --> 00:47:07.870
But basically,
we'll discuss more specifics

00:47:07.870 --> 00:47:12.340
about that and show how to use
it in the optimization session.

00:47:12.340 --> 00:47:16.600
A couple things you need to know here,
though, as far as just user use.

00:47:16.600 --> 00:47:18.400
So if you're using it
in your application,

00:47:18.400 --> 00:47:19.840
you now need to track current context.

00:47:19.840 --> 00:47:23.030
We were eliminating the idea of
current context if you use the macros.

00:47:23.170 --> 00:47:26.040
So you need to track it yourself to
understand what your current context is.

00:47:26.470 --> 00:47:29.710
And that means you have to ensure
your threading issues are handled.

00:47:30.040 --> 00:47:32.760
You can use the CGL or AGL macro header.

00:47:32.760 --> 00:47:34.680
You can use the CGL header for NS.

00:47:34.870 --> 00:47:37.570
You can use the AGL header for Carbon.

00:47:37.580 --> 00:47:40.260
And the key to
understanding this is very,

00:47:40.390 --> 00:47:41.420
very simple.

00:47:41.420 --> 00:47:45.170
There are two, one for AGL, one for CGL,
variables that are defined

00:47:45.290 --> 00:47:46.600
in the macro header.

00:47:46.600 --> 00:47:50.210
One's AGL underscore CTX and
one's CGL underscore CTX.

00:47:50.240 --> 00:47:52.870
You define these to be equal
to your current context.

00:47:52.880 --> 00:47:55.180
What the macro header does,
if you look at it,

00:47:55.200 --> 00:47:58.270
it then substitutes these
into an indirection and will

00:47:58.270 --> 00:47:59.740
directly use that lookup.

00:47:59.900 --> 00:48:02.080
And a dispatch table to
call into the function,

00:48:02.080 --> 00:48:03.230
the OpenGL function.

00:48:03.240 --> 00:48:07.060
So once you include the header,
and once you include, set that variable,

00:48:07.150 --> 00:48:09.360
you don't need to do anything different.

00:48:09.360 --> 00:48:12.900
So what that means is,
you include AGL macro dot H here.

00:48:12.900 --> 00:48:15.320
You've now set this
AGL CTX to be my context,

00:48:15.320 --> 00:48:17.210
which is your current context.

00:48:17.480 --> 00:48:20.900
And amazingly enough,
the rest of your code is the same.

00:48:20.940 --> 00:48:24.650
So you, everyone here, if they wanted to,
not saying you should do this,

00:48:24.650 --> 00:48:27.420
but if you wanted to,
you could probably put this in some of

00:48:27.420 --> 00:48:28.950
your OpenGL code within a few minutes.

00:48:29.040 --> 00:48:29.680
Again.

00:48:29.920 --> 00:48:32.600
Understand what your current context is.

00:48:32.660 --> 00:48:34.750
Because we normally track
current context for you,

00:48:34.910 --> 00:48:36.360
and when you change it,
you need to make sure

00:48:36.410 --> 00:48:37.240
you update the variable.

00:48:37.240 --> 00:48:40.040
Let's talk a little bit
about texture loading now.

00:48:41.850 --> 00:48:46.490
So in Cocoa, one thing we've talked about
is how you need a bitmap

00:48:46.490 --> 00:48:47.500
representation of a texture.

00:48:47.500 --> 00:48:49.140
It may not be obvious how
to do that from Cocoa.

00:48:49.140 --> 00:48:52.310
So I'm going to go through getting
a bitmap image wrap from a view and

00:48:52.310 --> 00:48:54.000
then texturing the bitmap image wrap.

00:48:54.200 --> 00:48:57.600
And then at the end, after that,
I'm going to talk about ImageIO.

00:48:57.600 --> 00:49:01.090
ImageIO is a new thing for Tiger and
allows you to do some really cool things.

00:49:03.120 --> 00:49:06.670
So basically, to walk through this,
I'm going to talk about the top bullets

00:49:06.790 --> 00:49:08.260
and the bottom is the code for reference.

00:49:08.630 --> 00:49:13.920
And by the way, there's a Q&A on this,
so no need to actually jot down

00:49:13.920 --> 00:49:15.760
all the code instantaneously.

00:49:15.850 --> 00:49:19.860
Just listen up here and look at the Q&A,
which is on the web after the session.

00:49:19.860 --> 00:49:22.700
If you have an NS OpenGL,
if you have an NS View Contents

00:49:22.700 --> 00:49:25.390
and you want to use it,
anything you want as a View Contents,

00:49:25.400 --> 00:49:27.760
what you can do is you can
allocate an NS Bitmap Image Rep.

00:49:28.040 --> 00:49:32.170
You can then initialize it,
initialize with a Focus View Rep,

00:49:32.270 --> 00:49:35.770
so you have your view focused and you
initialize it and you provide the bounds.

00:49:35.780 --> 00:49:38.630
And what that does basically is
give you a bitmap representation

00:49:38.630 --> 00:49:39.670
of that image source.

00:49:39.740 --> 00:49:42.860
You then move that along and
you're going to texture with that.

00:49:42.880 --> 00:49:45.140
To texture with that,
you need to set your pixel store data.

00:49:45.140 --> 00:49:47.540
You need to ensure that the row
length of the texture is handled,

00:49:47.540 --> 00:49:48.490
so I use the row length.

00:49:48.540 --> 00:49:50.760
And also you need to ensure
the alignment is handled.

00:49:50.760 --> 00:49:53.890
A lot of times you may have RGB data,
for example,

00:49:53.890 --> 00:49:56.260
so it's just RGB without the RGBA.

00:49:56.820 --> 00:50:01.180
And you want to make sure that you don't
have a 4-byte alignment implied there.

00:50:01.180 --> 00:50:02.650
Then you're going to
generate some textures,

00:50:02.760 --> 00:50:05.430
you're going to bind that texture,
and then the texture parameter I'm

00:50:05.430 --> 00:50:08.400
going to set here is I'm going to
set the MIP mapping to be linear.

00:50:08.400 --> 00:50:11.050
In this case, for the texture range,
it's kind of superfluous

00:50:11.050 --> 00:50:13.420
in this particular case,
but realize that we're dealing with

00:50:13.420 --> 00:50:15.720
a single image without MIP maps,
so you always want to make sure you

00:50:15.790 --> 00:50:17.240
don't have a MIP map filtering parameter.

00:50:17.240 --> 00:50:19.740
And then finally, I do one thing.

00:50:19.740 --> 00:50:22.080
I use a bitmap to get the
samples for the pixel,

00:50:22.080 --> 00:50:24.440
so it tells me how many samples, 3 or 4.

00:50:25.840 --> 00:50:30.220
Basically, in this case,
I'm handling an RGB or RGBA image,

00:50:30.360 --> 00:50:31.580
and I'm just going to texture from it.

00:50:31.710 --> 00:50:34.140
It looks a little bit complicated,
but basically all we're saying

00:50:34.140 --> 00:50:39.760
is either use RGBA8 or RGB8,
and either use RGBA or RGB for

00:50:39.760 --> 00:50:41.590
your texturing parameters.

00:50:41.600 --> 00:50:42.300
It's pretty simple.

00:50:42.300 --> 00:50:45.500
So this is about maybe
15 lines of code total.

00:50:45.500 --> 00:50:48.600
It's written up in the Q&A,
and you can just drop this into an

00:50:48.600 --> 00:50:52.440
NS app to grab a texture from almost
any NS view or any bitmap image wrap,

00:50:52.440 --> 00:50:55.690
so a really real strong way to
simply get that information.

00:50:55.840 --> 00:50:59.090
from an AppKit app.

00:50:59.320 --> 00:50:59.880
Image I.O.

00:50:59.880 --> 00:51:00.900
New for Tiger.

00:51:00.900 --> 00:51:01.660
There's an Image I.O.

00:51:01.800 --> 00:51:04.040
session directly following this session.

00:51:04.140 --> 00:51:06.260
I'm not sure exactly what room it's in,
but look at it.

00:51:06.510 --> 00:51:07.160
Image I.O.

00:51:07.160 --> 00:51:08.130
is pretty cool.

00:51:08.140 --> 00:51:10.140
There are some things that Image I.O.

00:51:10.140 --> 00:51:16.300
handles floating-point images,
high-DPI images,

00:51:16.550 --> 00:51:20.450
high-dynamic range images.

00:51:20.460 --> 00:51:26.190
And what that allows you to do is allows
you to have one single source in Cocoa or

00:51:26.190 --> 00:51:29.580
Carbon to get images that you may not
have been able to handle otherwise.

00:51:29.580 --> 00:51:32.410
This kind of replaces the
QuickTime image importer,

00:51:32.410 --> 00:51:35.300
if you want to think about it that way,
and allows even a

00:51:35.300 --> 00:51:36.940
larger subset of images.

00:51:36.940 --> 00:51:40.440
So, for example,
you can do things like load

00:51:40.570 --> 00:51:45.330
a floating-point image into a
floating-point texture and use

00:51:45.340 --> 00:51:50.220
that to draw into a floating-point
back buffer with a shader.

00:51:50.560 --> 00:51:55.600
And you have a floating-point path
from image to your final destination

00:51:55.600 --> 00:52:00.520
without ever having an RGB,
you know, integer, interstep in there.

00:52:00.560 --> 00:52:03.020
So, I mean,
this is a really powerful thing.

00:52:03.020 --> 00:52:04.910
So it allows you to do great
manipulation with data sets,

00:52:04.940 --> 00:52:07.900
great manipulation with high-dynamic
range images and those kind of things.

00:52:07.900 --> 00:52:11.010
So what you're going to do here is,
these are some new APIs, and again,

00:52:11.010 --> 00:52:13.160
I'm going to cover this
reasonably quickly.

00:52:13.180 --> 00:52:17.770
I have a sample that's on your,
tonight there'll be a DMG available

00:52:17.770 --> 00:52:20.440
for the session and a sample using.

00:52:20.460 --> 00:52:22.800
It will be on there,
so you can look at the sample.

00:52:22.800 --> 00:52:25.220
And you can see,
you can grab and look at the code then.

00:52:25.220 --> 00:52:28.380
But basically what you're going to do
is you're going to create an image at,

00:52:28.380 --> 00:52:30.760
you're going to basically
use an URL to get an image.

00:52:30.780 --> 00:52:34.480
You're going to create an image
at an index zero in this case.

00:52:34.480 --> 00:52:38.090
So basically we're going to get an
image ref for the first image in that,

00:52:38.090 --> 00:52:39.040
from that URL.

00:52:39.040 --> 00:52:40.610
We're going to get some
information about it,

00:52:40.620 --> 00:52:41.910
so that's the width and the height.

00:52:41.980 --> 00:52:43.660
Set a rectangle.

00:52:43.660 --> 00:52:46.260
And also we're going to allocate
some data based on this rectangle.

00:52:46.260 --> 00:52:47.840
So now what we have,
we have the image ref,

00:52:47.860 --> 00:52:49.060
we have information about it.

00:52:49.110 --> 00:52:50.440
We've allocated a rectangle big enough.

00:52:50.460 --> 00:52:53.920
And now what we're going to do is
make sure we cover color match,

00:52:53.960 --> 00:52:55.460
which is another great
thing Image.io does.

00:52:55.460 --> 00:52:57.650
It maintains color
information for that image,

00:52:57.780 --> 00:52:59.930
so you can make sure your images
are color correct coming in.

00:53:00.450 --> 00:53:02.460
Excuse me.

00:53:02.460 --> 00:53:04.420
We're going to create the bitmap context.

00:53:04.460 --> 00:53:06.420
We're going to draw the
image into the context,

00:53:06.550 --> 00:53:08.450
and then we're going
to release the context.

00:53:08.460 --> 00:53:11.600
So now we have the bitmap context,
and if you look at this,

00:53:11.600 --> 00:53:14.560
all the way down to the
end of the texture 2D,

00:53:14.740 --> 00:53:16.460
there's that data parameter I created.

00:53:16.460 --> 00:53:19.460
And what that means for you is all
you need to do is allocate the data.

00:53:19.460 --> 00:53:20.400
You basically get the data.

00:53:20.470 --> 00:53:22.440
You get the information from the URL.

00:53:22.520 --> 00:53:23.460
Set up a few things.

00:53:23.460 --> 00:53:24.430
Draw it.

00:53:24.500 --> 00:53:26.460
And then you can texture from it,
just like we did before.

00:53:26.460 --> 00:53:29.460
So this is basically exactly the same
kind of texturing code you saw before.

00:53:29.530 --> 00:53:31.460
Real simple.

00:53:31.460 --> 00:53:32.460
What do we got?

00:53:32.460 --> 00:53:35.350
Eight lines of code from Image.io,
and then the texturing

00:53:35.350 --> 00:53:36.460
code is six lines of code.

00:53:36.460 --> 00:53:39.460
So this supports things like
OpenEXR and those kind of things.

00:53:39.510 --> 00:53:42.580
So it supports those images that you
would have to spend a lot of time

00:53:42.620 --> 00:53:44.430
to make sure you correctly handle.

00:53:44.530 --> 00:53:45.460
It's a great thing to look at.

00:53:45.460 --> 00:53:48.460
I encourage you to go to the
session after this session.

00:53:48.490 --> 00:53:49.460
Context sharing.

00:53:49.460 --> 00:53:52.250
I think is one of the
final sections here.

00:53:52.440 --> 00:53:54.060
A couple things about context sharing.

00:53:54.060 --> 00:53:54.940
We talked about it before.

00:53:54.940 --> 00:53:57.220
Remember, this is where you have to have
virtual screen lists are the same.

00:53:57.220 --> 00:54:00.560
You have to be using the same set
of renderers to share context.

00:54:00.560 --> 00:54:02.560
You share objects in that context.

00:54:02.560 --> 00:54:05.730
Texture objects, vertex programs,
fragment programs, display lists,

00:54:05.880 --> 00:54:07.930
vertex array objects,
vertex buffer objects.

00:54:07.930 --> 00:54:10.100
Those kind of things are
the things you share.

00:54:10.100 --> 00:54:12.600
The state of the context
itself is not shared.

00:54:12.600 --> 00:54:15.340
You're not sharing whether
your current color is.

00:54:15.340 --> 00:54:18.460
You're not sharing what your
texture coordinates settings

00:54:18.560 --> 00:54:20.230
are and those kind of things.

00:54:20.240 --> 00:54:22.200
You're only sharing the
actual state of the context.

00:54:22.610 --> 00:54:25.380
The actual objects and
their state parameters.

00:54:25.380 --> 00:54:27.120
Same virtual screen configuration.

00:54:27.120 --> 00:54:27.830
We talked about that.

00:54:27.840 --> 00:54:30.900
One thing you can do is use a
single pixel format to create your

00:54:30.900 --> 00:54:35.430
context or create a single shared
context initially and build all

00:54:35.430 --> 00:54:37.850
your other context out of that.

00:54:37.900 --> 00:54:39.340
So you have one you've captured back.

00:54:39.370 --> 00:54:40.430
Build everything else out.

00:54:40.500 --> 00:54:41.420
Those can be thrown away.

00:54:41.530 --> 00:54:42.660
It's peer-to-peer sharing.

00:54:42.690 --> 00:54:44.360
Those can be thrown away, changed around.

00:54:44.450 --> 00:54:46.550
The last thing you do in your
application is throw away that

00:54:46.690 --> 00:54:48.140
initial context you created.

00:54:51.480 --> 00:54:53.240
And this is a simple code example.

00:54:53.290 --> 00:54:55.380
We create a pixel format of contacts.

00:54:55.400 --> 00:54:58.860
We create a second pixel
format using the same display.

00:54:58.860 --> 00:55:02.640
And in this case,
you can see we have the AGL contacts.

00:55:02.640 --> 00:55:06.950
We create the contacts,
the second one shared with that.

00:55:07.290 --> 00:55:08.200
Pretty simple.

00:55:08.240 --> 00:55:10.850
Context sharing tips,
Q&A covers all this.

00:55:11.350 --> 00:55:12.950
Good reference.

00:55:14.240 --> 00:55:17.030
So last thing,
I think we're just on time here,

00:55:17.050 --> 00:55:19.310
is pixel buffers.

00:55:19.400 --> 00:55:23.380
So pixel buffers,
Apple Pixel Buffers extension string,

00:55:23.380 --> 00:55:26.420
it works very much like
Windows Pixel Buffers with some slight

00:55:26.420 --> 00:55:30.340
changes because the Windows operating
system obviously is not

00:55:30.350 --> 00:55:33.940
the same as the Mac operating system,
and some of their pieces,

00:55:33.940 --> 00:55:36.700
their HDCs and those things,
don't fit quite with our

00:55:36.780 --> 00:55:38.400
concepts in Pixel Buffers.

00:55:38.400 --> 00:55:41.660
So we modified it,
but have the basic same logical setup,

00:55:41.870 --> 00:55:44.180
but just have some
different data calls out.

00:55:44.180 --> 00:55:47.360
Basically, it's hardware accelerated
off-screen rendering.

00:55:47.360 --> 00:55:48.290
We've talked about that already.

00:55:48.300 --> 00:55:51.210
Remember I talked about drawables,
it's all the same.

00:55:51.230 --> 00:55:52.720
You're attaching it just like a drawable.

00:55:52.720 --> 00:55:54.410
So in this case,
you're going to use setPbuffer.

00:55:54.540 --> 00:55:58.480
You can use setPbuffer as your call,
and that's just like setDrawable.

00:56:00.280 --> 00:56:03.700
Also, one thing that's new here is the
support for remote rendering.

00:56:03.800 --> 00:56:08.100
You can actually use pixel
buffers remotely and render

00:56:08.100 --> 00:56:09.080
to a different machine.

00:56:09.090 --> 00:56:10.780
So, for example,
let's say you have an application

00:56:10.860 --> 00:56:13.260
that wants to do a render farm or
wants to render on multiple machines

00:56:13.260 --> 00:56:14.710
and gather the information back up.

00:56:14.800 --> 00:56:17.110
What you can do is you can
attach to a different machine,

00:56:17.130 --> 00:56:18.890
SSH in, run an application over there.

00:56:18.890 --> 00:56:20.140
No one needs to be logged in.

00:56:20.140 --> 00:56:22.470
Doesn't need to be a monitor
attached to the machine.

00:56:22.470 --> 00:56:24.510
You can render using the
hardware acceleration,

00:56:24.620 --> 00:56:27.820
and then you can retrieve the image
and do whatever you'd like with it.

00:56:27.930 --> 00:56:29.100
I'll demonstrate that in a minute.

00:56:29.100 --> 00:56:32.080
But moving on, finishing this out,
basically,

00:56:32.090 --> 00:56:35.700
the pixel buffer's going to allow you
to do is to render to something and

00:56:35.700 --> 00:56:40.050
directly texture from that without
having any extraneous copies in there.

00:56:40.060 --> 00:56:42.520
So we'll call what you used there.

00:56:42.540 --> 00:56:47.160
GL text image 2D, well, in this case,
a CGL text image P buffer.

00:56:47.160 --> 00:56:48.340
Same kind of call.

00:56:48.340 --> 00:56:49.870
If you look at them,
they're almost exactly the same.

00:56:49.870 --> 00:56:53.400
Set a drawable, texture from it just like
you'd texture from a texture.

00:56:53.400 --> 00:56:56.480
And talk about sharing object
resources and state can be

00:56:56.560 --> 00:56:58.140
shared with the P buffer.

00:56:59.110 --> 00:57:01.050
It can be shared with a
context and a window drawable.

00:57:01.170 --> 00:57:05.090
Full screen drawables can't be
shared with P buffers at this time.

00:57:05.100 --> 00:57:08.430
We have a CGL reference and also on,
again,

00:57:08.440 --> 00:57:11.960
on the disk image that's going to be
up on the seed site for WWDC tonight,

00:57:12.300 --> 00:57:15.730
there'll be preliminary documentation
for how to set up P buffers

00:57:15.750 --> 00:57:18.090
that covers all the setup,
covers all the API,

00:57:18.100 --> 00:57:21.990
and covers some pseudo code
that I'm about to go through.

00:57:22.680 --> 00:57:24.680
So I'm just going to walk
through this pixel buffer usage.

00:57:24.720 --> 00:57:26.360
Again,
this is covered in the documentation

00:57:26.360 --> 00:57:28.130
that you can readily access.

00:57:28.190 --> 00:57:30.500
But basically, you're going to create a
context in pixel format.

00:57:30.550 --> 00:57:31.800
We've talked about that.

00:57:31.860 --> 00:57:34.870
You're going to create the pbuffer,
which is just like creating a window.

00:57:34.880 --> 00:57:38.720
Then you're going to set the pbuffer
as a drawable using CGL set pbuffer.

00:57:38.780 --> 00:57:41.480
That's, again, setting a drawable,
same as everything else.

00:57:41.550 --> 00:57:42.300
Draw on the pbuffer.

00:57:42.300 --> 00:57:45.150
You set current context
with the pbuffer's context,

00:57:45.160 --> 00:57:46.840
same thing you'd do
normally for rendering.

00:57:46.900 --> 00:57:49.220
Then you draw with OpenGL.

00:57:49.460 --> 00:57:52.270
So to set up the texturing, again,
you're going to create a texture object.

00:57:52.360 --> 00:57:54.680
You're going to bind
to the texture object,

00:57:54.680 --> 00:57:55.670
standard texturing stuff.

00:57:55.670 --> 00:57:57.220
You're going to set
the texture parameters.

00:57:57.220 --> 00:57:59.840
And then you're going to
create the pbuffer texture,

00:57:59.920 --> 00:58:01.880
which is create text image pbuffer.

00:58:01.880 --> 00:58:06.710
Again, it creates GL text image 2D,
CGL text image pbuffer.

00:58:06.740 --> 00:58:08.770
So again, create, bind, set parameters.

00:58:09.010 --> 00:58:12.050
And that's the only call that's
really different for here from normal

00:58:12.050 --> 00:58:15.660
texturing is you're actually going to
use the pbuffer as a texture source.

00:58:15.930 --> 00:58:18.350
Then you're going to draw
in with the pbuffer texture.

00:58:18.490 --> 00:58:19.380
You're going to bind to the texture.

00:58:19.440 --> 00:58:19.960
You're going to bind to it, obviously.

00:58:19.960 --> 00:58:22.730
You're going to bind to
the pbuffer texture object.

00:58:22.920 --> 00:58:26.320
Enable appropriate texture
target with the GL enable.

00:58:26.320 --> 00:58:29.430
And draw primitives appropriate
with texture coordinates.

00:58:29.450 --> 00:58:31.660
So again,
you're going to set your drawable,

00:58:31.760 --> 00:58:33.340
and then you're going to draw.

00:58:34.840 --> 00:58:37.000
And the destruction is pretty
much opposite of creation.

00:58:37.000 --> 00:58:39.430
We're going to delete the texture object,
set current context,

00:58:39.540 --> 00:58:41.190
we're going to destroy the P buffer,
destroy the context,

00:58:41.350 --> 00:58:44.640
destroy the pixel format,
and finally set the context to null.

00:58:44.640 --> 00:58:45.980
One thing in here is interesting.

00:58:46.030 --> 00:58:50.140
The fact that I'm destroying
the texture object first.

00:58:50.140 --> 00:58:51.390
Not required, but a good idea.

00:58:51.390 --> 00:58:54.030
If you don't destroy the texture
object first and you've actually

00:58:54.180 --> 00:58:57.680
destroyed data that the texture object
references by destroying the P buffer,

00:58:57.680 --> 00:58:59.320
can cause crashes in your application.

00:58:59.320 --> 00:59:02.080
It would be illegal to use a texture
once you destroy the P buffer.

00:59:02.160 --> 00:59:04.920
But I do it this way just to, you know,
it's kind of a safety thing.

00:59:04.920 --> 00:59:07.450
There's no reason that that
texture object should persist after

00:59:07.770 --> 00:59:09.060
you've destroyed the P buffer.

00:59:09.060 --> 00:59:09.960
So do it in this way.

00:59:09.960 --> 00:59:11.610
It'll save you some trouble later on.

00:59:13.890 --> 00:59:17.600
So I've talked about headless
and remote rendering a bit.

00:59:17.610 --> 00:59:22.180
Remote PBuffer is an additional
new pixel format attribute.

00:59:22.300 --> 00:59:23.560
Pixel buffer drawable.

00:59:23.580 --> 00:59:25.620
What you're going to do
in the remote machine,

00:59:25.620 --> 00:59:26.920
not log in is not required.

00:59:26.980 --> 00:59:28.560
Monitor is not required.

00:59:28.630 --> 00:59:30.150
You're going to SSH through
the remote machine.

00:59:30.160 --> 00:59:34.460
The reason we have the SSH in
place is we maintain security.

00:59:34.520 --> 00:59:36.370
We just don't want someone to be
able to render to your machine

00:59:36.460 --> 00:59:39.460
or use a copy of pixels to get
information from the machine.

00:59:39.540 --> 00:59:41.040
This is actually,
you have to authenticate

00:59:41.060 --> 00:59:42.280
like you would normally.

00:59:42.360 --> 00:59:46.050
And then run application on target
machine using the remote P buffers.

00:59:46.290 --> 00:59:47.570
And finally,
you're going to retrieve the content

00:59:47.580 --> 00:59:49.080
however you see is appropriate.

00:59:49.360 --> 00:59:51.510
And we're going to do a demo.

00:59:52.230 --> 00:59:56.320
So we're going to bring up demo two,
I believe.

00:59:56.320 --> 00:59:57.360
See if I got the right one.

00:59:57.360 --> 00:59:58.780
Yes, demo two.

00:59:58.820 --> 01:00:03.760
So the only reason I'm showing you this
is because this is the images folder.

01:00:03.770 --> 01:00:05.400
And you notice the
images folder is empty.

01:00:05.470 --> 01:00:06.600
So this is my target machine.

01:00:06.600 --> 01:00:09.520
I'm just going to log
out of this machine.

01:00:09.530 --> 01:00:11.020
And I'm going to go over to demo one.

01:00:11.020 --> 01:00:12.760
Let's wait for it to log out.

01:00:12.810 --> 01:00:13.520
So I'm logged out.

01:00:13.520 --> 01:00:14.510
No users on there.

01:00:14.520 --> 01:00:16.640
I wouldn't even need a display attached,
actually.

01:00:16.650 --> 01:00:21.250
Log into demo one machine,
or switch over to demo one machine here.

01:00:25.100 --> 01:00:27.540
Okay, so now we're on demo one,
and what you see, I have a terminal here,

01:00:27.540 --> 01:00:30.340
and I'm going to SSH into
that machine here.

01:00:39.320 --> 01:00:46.140
And so now I am-- that's the home,
the base of the other

01:00:46.140 --> 01:00:47.260
machine's directory.

01:00:47.310 --> 01:00:50.920
And what you'll notice,
the piece that I care about is an

01:00:50.920 --> 01:00:53.020
application called Remote Renderer,
which you'll notice in

01:00:53.020 --> 01:00:54.020
the application list.

01:00:54.020 --> 01:00:55.240
So I'm just going to run that.

01:00:55.290 --> 01:00:57.830
It's a little application
that you have in sample code.

01:00:57.900 --> 01:01:04.230
Oh, I can do that.

01:01:11.400 --> 01:01:17.400
[Transcript missing]

01:01:19.800 --> 01:01:22.430
So I'm just going to
run that application,

01:01:22.430 --> 01:01:24.260
Remote Renderer, on this remote machine.

01:01:24.260 --> 01:01:28.780
So now I've logged into it,
run the application, created the pbuffer.

01:01:29.040 --> 01:01:30.340
It's starting the rendering.

01:01:30.380 --> 01:01:31.640
I'm running a number of frames.

01:01:31.700 --> 01:01:32.520
I'm waiting for it to render.

01:01:32.580 --> 01:01:33.700
Render is complete.

01:01:33.760 --> 01:01:36.340
And now I'm going to
exit from that machine.

01:01:36.480 --> 01:01:38.160
So I've run my application.

01:01:38.210 --> 01:01:41.980
I go over to the other machine,
back to Demo 2.

01:01:42.080 --> 01:01:42.730
Still logged out.

01:01:42.970 --> 01:01:45.680
So let me log back in and
see what happened here.

01:01:49.260 --> 01:01:50.500
So now this was the images folder.

01:01:50.500 --> 01:01:51.300
This is where I started out.

01:01:51.300 --> 01:01:56.300
And you notice I've rendered
about 120 images here.

01:01:56.300 --> 01:02:01.740
And no exciting content,
but you'll see the

01:02:01.740 --> 01:02:03.470
results of this rendering.

01:02:12.540 --> 01:02:14.700
So basically,
I just rendered the kind of standard

01:02:14.700 --> 01:02:16.900
spinning cube thing remotely.

01:02:16.900 --> 01:02:18.680
Nothing on the display was touched.

01:02:18.690 --> 01:02:21.320
No windows needed to appear.

01:02:21.320 --> 01:02:22.260
You can just do this.

01:02:22.260 --> 01:02:24.680
So you could set up a render
form of a number of machines,

01:02:24.680 --> 01:02:27.980
and you can just render content to those
machines and then retrieve it back,

01:02:28.000 --> 01:02:29.900
put it into a movie,
put it as image processing,

01:02:29.900 --> 01:02:31.810
all through the remote rendering API.

01:02:32.080 --> 01:02:34.420
It's a really good API to extend
your rendering capabilities

01:02:34.420 --> 01:02:37.860
beyond the machine that you have.

01:02:37.860 --> 01:02:39.890
Now we can go back to slides.

01:02:46.200 --> 01:02:47.500
And we're ready to wrap up.

01:02:47.640 --> 01:02:50.160
So what did we talk about?

01:02:50.210 --> 01:02:52.300
We talked about an update, OpenGL.

01:02:52.300 --> 01:02:54.700
Continuous improvement in OpenGL.

01:02:54.700 --> 01:02:56.960
We're continuously trying
to get updates to you.

01:02:56.960 --> 01:02:58.310
You'll see them in software updates.

01:02:58.320 --> 01:02:59.170
You'll see new features.

01:02:59.730 --> 01:03:03.050
Really want to focus on
quality going forward.

01:03:03.060 --> 01:03:03.990
Architecture.

01:03:04.000 --> 01:03:07.440
Multi-client, multi-headed,
virtualized resources.

01:03:07.440 --> 01:03:09.050
A lot of folks are using it.

01:03:09.170 --> 01:03:10.740
We're stressing the system pretty hard.

01:03:10.740 --> 01:03:11.650
That's good for us.

01:03:11.740 --> 01:03:13.500
That's the quality bar pretty high.

01:03:14.260 --> 01:03:16.290
And you guys,
if you take advantage of this,

01:03:16.360 --> 01:03:19.430
can take advantage of the fact that
we have this virtualized system.

01:03:19.440 --> 01:03:20.600
OS-dependent data.

01:03:20.600 --> 01:03:21.730
We talked about some specific things.

01:03:21.840 --> 01:03:23.600
Virtual screens, which are renders.

01:03:23.640 --> 01:03:25.410
Pixel formats, context, and drawables.

01:03:25.810 --> 01:03:27.990
Four things you need to know.

01:03:28.000 --> 01:03:29.360
Four things you need to know.

01:03:29.360 --> 01:03:34.340
And finally, in that section,
we talked about interfaces, CGL,

01:03:34.340 --> 01:03:36.400
NSOpenGL, GLUT, AGL.

01:03:36.400 --> 01:03:38.450
The interfaces you need
for writing applications.

01:03:38.490 --> 01:03:40.810
And we talked about some functionality,
some things that might help

01:03:40.810 --> 01:03:42.390
you write applications,
some things that are new.

01:03:45.590 --> 01:03:49.130
So, new, should be new on the WWCCs,
I believe,

01:03:49.130 --> 01:03:53.410
is a new updated CGL reference,
which covers pixel buffer things.

01:03:53.420 --> 01:03:58.020
There's also the session disk image,
which has information for you.

01:03:58.020 --> 01:04:00.320
Also, I want to point you to
some things for tomorrow,

01:04:00.320 --> 01:04:00.880
for later.

01:04:00.880 --> 01:04:05.340
There's the HDR image session,
which is following this today.

01:04:05.340 --> 01:04:07.720
Tomorrow at 10.30 is the
optimization session.

01:04:07.720 --> 01:04:11.100
Tomorrow in the afternoon
session after lunch is a second

01:04:11.530 --> 01:04:14.110
optimization session where we're
talking about using our tools,

01:04:14.120 --> 01:04:16.190
which is really great for folks
who haven't used our tools.

01:04:16.200 --> 01:04:22.160
And Friday in the morning is the
GLSL OpenGL shading language session,

01:04:22.160 --> 01:04:25.360
talking about OpenGL shading
language on Mac OS X.
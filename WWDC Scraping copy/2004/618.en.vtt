WEBVTT

00:00:12.140 --> 00:00:13.820
Good afternoon.

00:00:13.880 --> 00:00:17.060
This is 618 Distributed
Computing Made Easy with Xgrid.

00:00:17.060 --> 00:00:19.600
And I am David Kramer.

00:00:19.600 --> 00:00:21.420
I'm the engineering manager
for the Xgrid group.

00:00:21.510 --> 00:00:24.800
We're having a little bit of fun
with the names down at the bottom.

00:00:24.800 --> 00:00:28.080
There are two of us in the Xgrid group,
David Kramer and David Kramer.

00:00:28.080 --> 00:00:30.520
There will be a test at the end.

00:00:30.650 --> 00:00:31.350
Don't get us confused.

00:00:33.140 --> 00:00:35.620
So this is the first session after lunch.

00:00:35.640 --> 00:00:37.050
We're going to do a
little bit of an exercise.

00:00:37.100 --> 00:00:41.060
How many folks here have downloaded
and/or played with Xgrid?

00:00:41.160 --> 00:00:43.130
Raise your hand.

00:00:43.860 --> 00:00:46.960
How many folks have not
downloaded or placed XGrid?

00:00:46.960 --> 00:00:49.900
OK, so we've all just done a
distributed computing problem,

00:00:49.900 --> 00:00:52.100
an embarrassingly parallel one,
and we'll get to that.

00:00:52.100 --> 00:00:53.690
Thank you very much for the input.

00:00:53.830 --> 00:00:56.620
So what we're going to talk
about today-- XGrid is Apple's

00:00:56.710 --> 00:00:58.840
solution for cluster computing.

00:00:58.980 --> 00:01:01.680
And we believe that it helps
make distributed computing easy,

00:01:01.680 --> 00:01:03.940
although full disclosure,
"easy" is a little bit

00:01:03.940 --> 00:01:07.080
of a relative term,
of course, but significantly easier

00:01:07.080 --> 00:01:09.120
than it's been in the past.

00:01:09.280 --> 00:01:12.180
And most importantly,
you can today start using the

00:01:12.180 --> 00:01:15.040
technology preview of XGrid,
as well as what is going

00:01:15.050 --> 00:01:17.900
to be coming with Tiger,
to start grid enabling your

00:01:17.900 --> 00:01:20.980
applications and your workflows,
whether you're an engineer

00:01:20.980 --> 00:01:22.610
or a user of the technology.

00:01:22.740 --> 00:01:24.660
Today we're going to talk
about the system architecture

00:01:25.070 --> 00:01:28.160
and a general overview of the
capabilities and how XGrid works.

00:01:28.340 --> 00:01:31.850
We'll talk about some new APIs that
we'll be introducing with Tiger,

00:01:31.910 --> 00:01:35.060
the Grid Foundation APIs,
and then discuss how you can

00:01:35.060 --> 00:01:38.530
use those in your applications,
as well as some of the other components

00:01:38.560 --> 00:01:40.990
of XGrid to grid enable your workflow.

00:01:41.300 --> 00:01:45.170
So let's get started with the overview.

00:01:48.560 --> 00:01:50.980
We had a couple of goals with Xgrid.

00:01:51.270 --> 00:01:54.570
So we wanted to make distributed
computing painless and easy.

00:01:54.660 --> 00:01:58.110
And by easy, we mean easy to install,
configure, use.

00:01:58.440 --> 00:02:01.840
You obviously have to have enough of a
brain to understand some of the concepts,

00:02:01.850 --> 00:02:04.490
but you shouldn't have to have
that much brain and fingers to

00:02:04.490 --> 00:02:07.880
go through all of the pain of
setting up 10 different computers,

00:02:07.880 --> 00:02:09.310
1,000 different computers.

00:02:09.380 --> 00:02:12.300
We want to take care of
the hard things for you.

00:02:12.320 --> 00:02:13.850
Secondly, it should be non-intrusive.

00:02:13.850 --> 00:02:15.760
One of the goals we have with
Xgrid is to be able to do

00:02:15.760 --> 00:02:17.320
what we call desktop recovery.

00:02:17.510 --> 00:02:20.690
That is to take advantage of some
of the unused CPU resources that

00:02:20.760 --> 00:02:23.180
are sitting around your environment.

00:02:23.180 --> 00:02:27.060
And if that caused your friend or
colleague or student's computer to crash,

00:02:27.060 --> 00:02:29.440
or if they noticed that there was
something wrong or the behavior

00:02:29.440 --> 00:02:30.970
was a little bit different,
that would be a bad thing.

00:02:30.970 --> 00:02:32.940
So we want to make sure
we don't mess that up,

00:02:33.540 --> 00:02:33.780
obviously.

00:02:33.780 --> 00:02:37.080
And we want to solve a range of
problems with a range of architectures.

00:02:37.080 --> 00:02:39.970
We sort of glibly say from
Beowulf to SETI at home.

00:02:39.980 --> 00:02:42.880
That is from pretty massively
parallel kinds of problems to

00:02:42.880 --> 00:02:44.830
very highly distributed problems.

00:02:44.890 --> 00:02:47.550
And we'll We'll go through a
couple of examples of that.

00:02:47.750 --> 00:02:51.640
Our target customers for these
products are really scientists,

00:02:51.640 --> 00:02:53.320
engineers, and creative professionals.

00:02:53.320 --> 00:02:55.640
Those are the people who really
can take advantage because those

00:02:55.640 --> 00:02:57.850
are the people who have the kinds
of problems that take a long,

00:02:57.850 --> 00:03:01.280
long, long time to execute and tend
to be somewhat parallelizable.

00:03:01.280 --> 00:03:03.100
And again, we'll talk about those
problems in a moment.

00:03:03.100 --> 00:03:06.730
In support of those folks are
typically the software developers and

00:03:06.730 --> 00:03:10.700
system administrators who need tools
to help them solve their problems.

00:03:11.000 --> 00:03:14.600
So hopefully you fit into one
or perhaps more of those camps.

00:03:14.600 --> 00:03:17.540
If not, hopefully you'll learn something
here that will be just fun

00:03:17.540 --> 00:03:19.090
and interesting to use anyway.

00:03:19.100 --> 00:03:23.280
So we solve two primary
classes of problems with Xgrid.

00:03:23.280 --> 00:03:27.070
First of all, what we call embarrassingly
parallel problems,

00:03:27.090 --> 00:03:31.690
problems that are fairly easy to visible
where I have the same executable that

00:03:31.690 --> 00:03:35.160
I just want to run on lots of different
machines with slightly different

00:03:35.160 --> 00:03:37.140
or maybe vastly different inputs.

00:03:37.140 --> 00:03:39.080
And then I want to collect
together the outputs.

00:03:39.210 --> 00:03:40.590
Maybe I'm looking for a single output.

00:03:41.080 --> 00:03:42.980
Sort of a needle in the
haystack kind of problem.

00:03:43.080 --> 00:03:44.930
Or I want to collapse together
all the different outputs.

00:03:45.000 --> 00:03:49.000
Or I just want to go off and process
something and get the result back.

00:03:49.030 --> 00:03:51.000
A good example of that is like
I have a batch image filter

00:03:51.000 --> 00:03:53.000
and thousands of images I want
to apply that same filter to.

00:03:53.000 --> 00:03:54.960
Maybe I want to make a thumbnail,
for example, or something like that.

00:03:55.040 --> 00:03:58.630
I can use the services of Xgrid to
distribute that work across a large

00:03:58.630 --> 00:04:03.000
number of computers so that I don't
have to sit and wait for it to get done.

00:04:03.000 --> 00:04:07.000
So that's what we call embarrassingly
parallel or embarrallel problems.

00:04:07.000 --> 00:04:08.960
A second class of problems that Xgrid is
good for are tightly coupled problems.

00:04:09.060 --> 00:04:10.970
So that's what we call embarrassingly
parallel or embarrallel problems.

00:04:11.070 --> 00:04:12.970
These tend to be more
in the science domains,

00:04:13.000 --> 00:04:15.910
physics and simulation kinds of problems.

00:04:16.000 --> 00:04:19.020
These are problems that you have
to think really hard about and

00:04:19.240 --> 00:04:21.000
how to parallelize your algorithm.

00:04:21.000 --> 00:04:24.440
And then use tools, things like MPI,
we'll talk a little bit

00:04:24.440 --> 00:04:27.080
about that later as well,
to enable these massively

00:04:27.080 --> 00:04:29.970
parallel communications between
different nodes in the cluster.

00:04:30.040 --> 00:04:33.000
So this is not sort of I have an
image and I want to just transform it.

00:04:33.000 --> 00:04:36.570
This is I have a simulation
problem where this proton is

00:04:36.830 --> 00:04:39.000
hitting that proton is hitting
this proton is hitting that proton.

00:04:39.000 --> 00:04:40.940
And I want to make sure
that I get that right.

00:04:41.010 --> 00:04:43.020
the math right across a
large number of computers.

00:04:43.170 --> 00:04:43.990
We can help you there too.

00:04:44.080 --> 00:04:45.900
That's the message.

00:04:48.380 --> 00:04:49.340
So how do we accomplish that?

00:04:49.340 --> 00:04:51.580
What's the basic functionality
that you'll get as part of Xgrid

00:04:51.650 --> 00:04:53.110
or that you do get now in the TP2?

00:04:53.120 --> 00:04:57.300
First and foremost,
we collect all the nodes and group

00:04:57.470 --> 00:05:00.100
them together into a cluster.

00:05:00.100 --> 00:05:02.260
We should back up for a second.

00:05:02.260 --> 00:05:05.300
We use the term grid and cluster
somewhat interchangeably.

00:05:05.300 --> 00:05:08.170
In the sort of more
in-depth grid cluster world,

00:05:08.170 --> 00:05:12.260
there are slightly different definitions
that may be important to you.

00:05:12.260 --> 00:05:14.250
In this case,
we're just talking about perhaps

00:05:14.250 --> 00:05:15.700
different kinds of computers.

00:05:15.770 --> 00:05:18.160
In any case, we gather them all up
together and identify them,

00:05:18.170 --> 00:05:20.770
bring them together in one spot
so that you can start adding

00:05:20.780 --> 00:05:22.180
work to each of those computers.

00:05:22.180 --> 00:05:26.430
And then we identify a queue of
jobs and perhaps subtasks of each

00:05:26.440 --> 00:05:31.020
job that we're going to be doling
out to each of those computers.

00:05:31.020 --> 00:05:34.800
We manage and monitor the availability
of those computers and then,

00:05:34.800 --> 00:05:37.130
of course,
dole out the tasks to each of them

00:05:37.270 --> 00:05:39.600
as the fastest one becomes available.

00:05:39.600 --> 00:05:41.440
David will talk a little
bit more about scheduling.

00:05:41.440 --> 00:05:45.650
And we make sure that the right
executables are on the right nodes.

00:05:45.700 --> 00:05:49.090
So that's an important task
that's often overlooked.

00:05:49.100 --> 00:05:52.270
It's interesting if you actually
step back and look at what

00:05:52.270 --> 00:05:53.870
people who run clusters do.

00:05:53.990 --> 00:05:56.840
A very relatively small percentage
of their time is spent doing the

00:05:56.840 --> 00:05:58.460
interesting parallel cluster work.

00:05:58.460 --> 00:06:01.090
And a very large percentage of
their time is doing just almost

00:06:01.240 --> 00:06:04.230
mind-numbing system administration
because I got to do it on node one and

00:06:04.230 --> 00:06:05.430
node two and node three and node four.

00:06:05.490 --> 00:06:07.380
So we really want to help you with that.

00:06:07.470 --> 00:06:09.780
And one concrete thing we
do right now is distribute,

00:06:09.910 --> 00:06:12.410
if you want it to,
the executables around and the data

00:06:12.410 --> 00:06:15.370
sets around to all of the nodes that
are going to be doing the computation.

00:06:16.670 --> 00:06:19.850
And then of course we gather up
the output from the results from

00:06:19.860 --> 00:06:22.600
each of those nodes and bring
it back to the client machine.

00:06:22.600 --> 00:06:25.550
And we'll talk a little bit
more about how that works too.

00:06:26.590 --> 00:06:30.100
So history of how we got to this point.

00:06:30.160 --> 00:06:32.910
As you can see here,
we released a technology preview one,

00:06:32.910 --> 00:06:35.880
and then fairly recently,
a technology preview two of this.

00:06:35.940 --> 00:06:38.980
We've been trying to develop this
project somewhat in the open and

00:06:38.980 --> 00:06:42.900
gather feedback from the community,
because many of our customers have

00:06:43.030 --> 00:06:46.450
very specialized kinds of tasks,
and we want to make sure that the

00:06:46.450 --> 00:06:48.510
tool is applicable to those tasks.

00:06:48.560 --> 00:06:51.420
Today we're at WWDC,
and we'll be talking about

00:06:51.430 --> 00:06:55.390
features of the Xgrid that will
be part of Tiger and Tiger Server,

00:06:55.390 --> 00:06:56.500
especially.

00:06:58.900 --> 00:08:22.800
[Transcript missing]

00:08:29.380 --> 00:08:30.840
Hi, so I'm David Kraemer.

00:08:30.860 --> 00:08:33.740
I'm Xgrid engineer.

00:08:33.740 --> 00:08:36.330
So the Xgrid system
architecture has three tiers.

00:08:36.510 --> 00:08:40.800
There's a client, a controller,
and agents.

00:08:40.920 --> 00:08:43.450
And the agents are the
ones that do the work.

00:08:43.640 --> 00:08:45.810
The client is the one that
has the work to be done.

00:08:45.810 --> 00:08:48.820
The controllers are in the middle
to make sure everything's going

00:08:48.820 --> 00:08:50.180
the way it's supposed to go.

00:08:50.360 --> 00:08:54.890
So the way it works is the client
submits a job to the controller.

00:08:55.090 --> 00:08:57.460
The controller takes this job,
splits it up into tasks.

00:08:57.520 --> 00:09:00.460
This isn't really that fancy or exciting.

00:09:00.460 --> 00:09:03.260
What's happening is that a
job is just a list of tasks.

00:09:03.350 --> 00:09:09.910
So it splits it up and starts
scheduling it on the available

00:09:09.910 --> 00:09:09.910
computational resources,
the agents.

00:09:10.140 --> 00:09:14.040
So the agents start to compute the tasks,
and as they finish,

00:09:14.040 --> 00:09:16.960
the results go back to the controller.

00:09:16.960 --> 00:09:21.150
And the controller collects
them all and sends them back as

00:09:21.160 --> 00:09:23.630
the job results to the client.

00:09:25.770 --> 00:09:29.650
So why have three tiers?

00:09:29.750 --> 00:09:31.580
Traditionally you might
imagine having two tiers,

00:09:31.580 --> 00:09:34.560
where you have a client and then
you have the computational agents.

00:09:34.560 --> 00:09:37.070
And you send out the work
and you get the results.

00:09:37.170 --> 00:09:42.470
But there's situations in which that's
not the way you want it to work,

00:09:42.470 --> 00:09:45.920
especially if you have clients
that aren't always online,

00:09:46.010 --> 00:09:49.070
for example laptops,
and you want to submit a job and

00:09:49.070 --> 00:09:50.540
it's going to take a day to run.

00:09:50.560 --> 00:09:51.930
You don't want to have to
leave your laptop plugged in,

00:09:51.940 --> 00:09:52.890
you want to take it home.

00:09:53.030 --> 00:09:55.920
So the controller is there to
keep track of what's going on to

00:09:55.920 --> 00:09:58.640
make sure it all gets done and
to collect the results for you.

00:09:58.680 --> 00:10:02.780
When you come back the next day,
you can get the results.

00:10:03.000 --> 00:10:05.050
It also allows you to
have multiple agents,

00:10:05.050 --> 00:10:07.830
multiple clients,
and they all confine each

00:10:07.830 --> 00:10:10.170
other by way of the controller.

00:10:10.600 --> 00:10:13.840
It also supports a variety of
distributed computing styles.

00:10:13.840 --> 00:10:16.600
So in one case, you could have a
dedicated rack of XSERVs,

00:10:16.600 --> 00:10:19.340
and they just sit in the closet,
and they're always being

00:10:19.380 --> 00:10:21.050
used for computational tasks.

00:10:21.440 --> 00:10:25.500
Or you might just have some iMacs
and some laptops sitting around

00:10:25.610 --> 00:10:29.210
that sometimes are plugged in,
and sometimes they're

00:10:29.350 --> 00:10:32.180
used by their users,
and sometimes they're

00:10:32.280 --> 00:10:33.940
just sitting there idle.

00:10:34.130 --> 00:10:36.770
And so you can recover these
resources at night or at lunch or

00:10:36.770 --> 00:10:36.770
whenever they're not being used.

00:10:38.680 --> 00:10:42.820
So the first tier is the client tier.

00:10:42.820 --> 00:10:45.830
You can either create an application
using the Cocoa framework

00:10:46.310 --> 00:10:50.380
and have that be a client,
and with TP2 there is an application

00:10:50.390 --> 00:10:53.370
called Xgrid that is that kind of client.

00:10:53.370 --> 00:10:59.680
Or you can use the command line tool,
Xgrid, to submit jobs, monitor the grid,

00:10:59.680 --> 00:11:01.360
and get your results.

00:11:01.360 --> 00:11:07.070
So that's basically all there is to it,
submitting, monitoring, and retrieving.

00:11:07.880 --> 00:11:11.830
The agent on the other side of the
three tiers is a background daemon.

00:11:11.930 --> 00:11:14.390
It is configured with preferences.

00:11:14.400 --> 00:11:15.820
There's a plist file.

00:11:15.910 --> 00:11:19.540
There's some scripts to
start and stop the agent.

00:11:19.540 --> 00:11:24.850
You can run it in dedicated mode,
like on the XSERVs,

00:11:24.850 --> 00:11:29.020
or you can run it in screensaver mode.

00:11:29.090 --> 00:11:32.110
In that mode,
it only accepts computational

00:11:32.110 --> 00:11:32.110
tasks when the computer is idle.

00:11:33.610 --> 00:11:37.380
So the controller in the middle
is also a background daemon.

00:11:37.380 --> 00:11:38.380
It's a server.

00:11:38.560 --> 00:11:42.250
It listens on a socket and accepts
connections from agents and clients.

00:11:42.250 --> 00:11:45.050
It handles all the resource
management and scheduling,

00:11:45.480 --> 00:11:47.840
monitors the agents, accepts the jobs,
splits them up,

00:11:47.970 --> 00:11:50.400
submits them to the agents,
collects the results,

00:11:50.400 --> 00:11:52.430
and returns them to the client.

00:11:53.280 --> 00:11:57.100
There's also a limited controller
built into the client framework.

00:11:57.100 --> 00:12:00.440
This means you don't get the
benefits of three tiers now.

00:12:00.440 --> 00:12:02.320
You've just reduced it
down to a two-tier system,

00:12:02.320 --> 00:12:04.960
but what you gain is you don't
need a dedicated controller.

00:12:04.960 --> 00:12:09.150
So you can just walk up to a network
that has some agents on it and start

00:12:09.150 --> 00:12:11.770
submitting jobs and getting results.

00:12:11.770 --> 00:12:15.320
But again, if you need to go home and
take your laptop home with you,

00:12:15.320 --> 00:12:18.500
you're not going to be able to
continue doing the work because

00:12:18.500 --> 00:12:20.590
there's no dedicated controller.

00:12:23.040 --> 00:12:25.580
So the controller does
all the scheduling,

00:12:25.670 --> 00:12:26.380
as I said.

00:12:26.390 --> 00:12:31.340
And so the scheduler knows about files,
jobs, tasks, and nodes.

00:12:31.340 --> 00:12:35.760
It schedules the jobs as they come in,
they're in a queue.

00:12:35.760 --> 00:12:38.660
And it takes the one off
the top of the queue,

00:12:38.660 --> 00:12:43.290
looks at what tasks it has to be done,
and sends them off to the

00:12:43.390 --> 00:12:45.400
fastest available computer.

00:12:45.570 --> 00:12:49.390
It's also fault tolerant,
which means that if one of the agents

00:12:49.480 --> 00:12:53.840
goes offline while it's doing the work,
the controller will notice this

00:12:53.880 --> 00:12:57.390
and will reschedule the work
on the next available agent.

00:12:59.450 --> 00:13:04.780
The scheduler also handles dependencies,
which means that jobs or tasks

00:13:04.780 --> 00:13:09.720
can depend on arbitrary URIs,
universal resource identifiers.

00:13:09.860 --> 00:13:13.530
Each job, and each task,
and each data set is given a

00:13:13.920 --> 00:13:15.880
unique resource identifier.

00:13:15.880 --> 00:13:21.310
And so in the first example here,
you can have a job depend on another job.

00:13:21.410 --> 00:13:24.410
So you have a second
job here with two tasks,

00:13:24.570 --> 00:13:29.380
and none of those tasks will
run until all three tasks open.

00:13:29.400 --> 00:13:35.010
In the second case, you have one job,
but it has these five tasks,

00:13:35.080 --> 00:13:37.030
and the first task runs.

00:13:37.030 --> 00:13:39.310
This might be a preprocessing task.

00:13:39.310 --> 00:13:43.060
And then the next three tasks
will run once that one completes,

00:13:43.140 --> 00:13:45.010
and those are doing the work.

00:13:45.070 --> 00:13:47.950
And then the final task won't run until
all of the rest of the tasks finish,

00:13:47.990 --> 00:13:50.020
and that could be your
post-processing stage.

00:13:52.420 --> 00:13:55.170
So the Xgrid software
architecture looks like this.

00:13:55.230 --> 00:13:59.150
You've got the daemons and
the applications up top,

00:13:59.150 --> 00:14:03.060
and they're all built on the
XG framework and the XG protocol.

00:14:03.090 --> 00:14:06.150
And that, in turn,
is built upon the Blocks

00:14:06.220 --> 00:14:10.210
Extensible Exchange Protocol,
RFC 3080.

00:14:10.220 --> 00:14:15.020
And all of this is built
on top of BSD sockets,

00:14:15.020 --> 00:14:16.680
the core foundation libraries,
and the foundation framework.

00:14:19.110 --> 00:14:23.840
So in Xgrid,
various aspects of the communication

00:14:23.840 --> 00:14:29.550
that are important to note are that the
controller advertises via rendezvous.

00:14:29.550 --> 00:14:35.500
And the controller is the only tier
that actually accepts connections.

00:14:35.570 --> 00:14:36.740
It's the server.

00:14:36.740 --> 00:14:41.480
So the agents and the clients
sit around browsing for services,

00:14:41.480 --> 00:14:46.660
and when they find a controller,
the agent automatically connects to

00:14:46.660 --> 00:14:49.070
the controller that it's configured.

00:14:49.100 --> 00:14:50.040
to connect to.

00:14:52.030 --> 00:14:57.240
So the agent and the client can
be configured to either connect

00:14:57.400 --> 00:15:00.340
to a Rendezvous service name,
or you can just use standard

00:15:00.340 --> 00:15:01.860
host names or IP addresses.

00:15:01.900 --> 00:15:05.660
And so you can do this on a
local subnet with Rendezvous,

00:15:05.660 --> 00:15:08.420
or you can do this across the Internet.

00:15:08.420 --> 00:15:12.920
Another thing to note is the
agents and the clients leave the

00:15:12.920 --> 00:15:16.220
connection open after they've
connected to the controller,

00:15:16.220 --> 00:15:18.880
and this allows for asynchronous
peer-to-peer communication.

00:15:19.970 --> 00:15:25.040
So any time an event occurs to the job,
when the job completes,

00:15:25.090 --> 00:15:27.080
the client is immediately notified.

00:15:27.080 --> 00:15:28.230
There's no polling.

00:15:30.750 --> 00:15:36.830
So the controller stores and streams the
data from the agent and to the client.

00:15:37.250 --> 00:15:42.310
So this means that as the agent is
running the task and generating output,

00:15:42.310 --> 00:15:47.750
that gets streamed back to the controller
while the task is still running.

00:15:47.820 --> 00:15:53.540
And that is then, in turn,
streamed back to the client.

00:15:53.540 --> 00:15:56.170
So you can start getting results
before your tasks have completed.

00:15:56.580 --> 00:16:02.460
And then one more note about MPI that
is a little bit tricky is that

00:16:02.460 --> 00:16:06.700
when we run an MPI task with XGrid,
you don't know ahead of time which

00:16:06.700 --> 00:16:10.010
computers you are going to run on
because that's managed by the controller.

00:16:10.140 --> 00:16:11.880
So you just submit the job.

00:16:11.940 --> 00:16:13.740
And then the controller schedules it.

00:16:13.740 --> 00:16:17.840
And there's some communication
that occurs between the nodes at

00:16:17.920 --> 00:16:20.060
this point to find each other.

00:16:20.060 --> 00:16:24.840
And the master node collects all the
IP addresses and saves it to disk and

00:16:24.940 --> 00:16:29.650
then runs the actual MPI executable
which uses that configuration file to

00:16:30.040 --> 00:16:34.380
connect to all the rest of the processes
that are running on the other agents.

00:16:36.050 --> 00:16:39.660
So there's two models
for security in Xgrid.

00:16:39.710 --> 00:16:42.490
The first is the ad hoc model,
and this is what you see in

00:16:42.590 --> 00:16:44.770
the technical preview two.

00:16:44.980 --> 00:16:46.700
It's password-based
mutual authentication.

00:16:46.700 --> 00:16:49.890
So if you want to have
someone join your grid,

00:16:49.930 --> 00:16:52.870
you can tell them,
or they can tell you the

00:16:53.030 --> 00:16:56.710
password for their agent,
and then you can allow your

00:16:56.710 --> 00:16:59.110
controller to connect to it.

00:17:00.260 --> 00:17:03.590
There's also,
the second model is the managed security,

00:17:03.600 --> 00:17:07.580
and this is where all of the components,
the client controller and the agent,

00:17:07.580 --> 00:17:10.190
are bound to an open directory
administrative domain.

00:17:10.190 --> 00:17:13.660
So there's the same set of
users on all these computers.

00:17:13.660 --> 00:17:16.180
In both of these models,
the agent and controller

00:17:16.180 --> 00:17:17.200
can be protected.

00:17:17.200 --> 00:17:19.660
What that means,
what we're protecting against

00:17:19.660 --> 00:17:21.120
here is unauthorized use.

00:17:21.120 --> 00:17:24.720
So the agent can be configured
to only allow connections

00:17:24.720 --> 00:17:27.460
from trusted controllers,
and the controller can be

00:17:27.530 --> 00:17:29.990
configured to only allow connections
from trusted controllers.

00:17:30.020 --> 00:17:30.130
So the agent can be configured
to only allow connections

00:17:30.140 --> 00:17:30.250
from trusted controllers,
and the controller can be

00:17:30.250 --> 00:17:30.550
configured to only allow connections
from trusted controllers.

00:17:30.560 --> 00:17:33.760
And in that way,
you are assured that you're not

00:17:33.760 --> 00:17:38.420
doing work for someone who's not
authorized to use the resources.

00:17:38.920 --> 00:17:42.450
So in the ad hoc security,
the communication occurs in the clear,

00:17:42.580 --> 00:17:44.850
although it may be encrypted in SSL.

00:17:44.880 --> 00:17:47.350
But at no point are
passwords sent in the clear.

00:17:47.350 --> 00:17:51.940
There's a two-way random protocol
used to make sure that it's

00:17:51.940 --> 00:17:54.940
unintelligible to packet snippers.

00:17:56.200 --> 00:18:00.060
The agent runs tasks as an
unprivileged user because there's

00:18:00.070 --> 00:18:01.600
no sense of shared users here.

00:18:01.680 --> 00:18:06.000
So what this means is that if you're
running a computational task on this

00:18:06.000 --> 00:18:08.960
agent in an ad hoc security mode,
that you don't get any

00:18:08.960 --> 00:18:12.820
connections to the Windows server,
you don't have a home directory,

00:18:12.820 --> 00:18:16.820
and so you only get world
access to the files on the disk.

00:18:16.840 --> 00:18:19.920
So this means you can
write into slash TMP,

00:18:20.010 --> 00:18:24.840
you can read some various public
system configuration files,

00:18:25.530 --> 00:18:30.630
but you don't have the ability to read
private files in home directories.

00:18:32.440 --> 00:18:35.380
In the managed security case,
all the components, as I said,

00:18:35.380 --> 00:18:38.630
are bound to open directory,
and so the agent can run

00:18:38.630 --> 00:18:42.440
tasks as a privileged user,
and this would be useful to

00:18:42.630 --> 00:18:46.460
run the tasks as the person
who initially submitted them.

00:18:46.460 --> 00:18:50.140
So this requires
delegation of credentials,

00:18:50.280 --> 00:18:53.520
but it allows you to access
home and network directories

00:18:53.520 --> 00:18:57.420
as the user who submitted them,
so you don't have to make all

00:18:57.420 --> 00:19:01.690
of your files world readable and
world writable to have them be

00:19:01.690 --> 00:19:04.780
used in a distributed computation.

00:19:05.510 --> 00:19:08.590
So next,
I would like to talk to you about how to

00:19:08.590 --> 00:19:12.430
actually develop using the Xgrid APIs.

00:19:12.940 --> 00:19:16.560
So first, there's the Xgrid command
line tool that you can use.

00:19:16.560 --> 00:19:22.360
And you can use this from shell scripts.

00:19:22.660 --> 00:19:25.270
You can use this from your
applications in Cocoa using nstask,

00:19:25.270 --> 00:19:25.270
any way you want to do it.

00:19:26.580 --> 00:19:29.210
What you do is you factor
your computational code into

00:19:29.210 --> 00:19:32.080
a command line executable,
and then you use Xgrid to

00:19:32.080 --> 00:19:34.860
submit this--to submit a job.

00:19:34.860 --> 00:19:37.680
You can include the executable
with the job if it's not already

00:19:37.680 --> 00:19:39.840
installed on the remote computers.

00:19:39.840 --> 00:19:41.960
And then you can collect the results.

00:19:41.960 --> 00:19:44.120
And you can do all this
with the command line tool,

00:19:44.120 --> 00:19:46.060
and I'll show you an example in a moment.

00:19:46.060 --> 00:19:51.680
And so that is how the Blender example
that David talked about was done.

00:19:51.680 --> 00:19:55.660
You can also integrate
Xgrid with your application,

00:19:55.740 --> 00:20:00.890
so you don't have to write a new
application or write a shell script.

00:20:00.990 --> 00:20:04.780
You can just link in the Cocoa framework
and then use it to distribute the

00:20:04.780 --> 00:20:07.280
tasks when the grid's available
and monitor the status of your

00:20:07.400 --> 00:20:09.820
work and retrieve the results.

00:20:10.750 --> 00:20:15.920
So as you've probably caught on to now,
the lifecycle of job

00:20:15.920 --> 00:20:20.100
is that you submit it,
you monitor it, and you get the results.

00:20:20.100 --> 00:20:22.300
And that's the theme
of the talk here today.

00:20:23.740 --> 00:20:26.600
So the command line example here.

00:20:26.730 --> 00:20:29.720
First, you submit the job.

00:20:29.790 --> 00:20:32.670
And so in this case,
we're running the CAL program,

00:20:32.670 --> 00:20:34.370
which prints out a calendar.

00:20:34.670 --> 00:20:38.250
And we're saying we want June 2004.

00:20:38.410 --> 00:20:41.360
And so you submit it,
and what gets returned

00:20:41.370 --> 00:20:42.990
is a job identifier.

00:20:43.860 --> 00:20:48.330
And with that job identifier,
you can retrieve the status of the job.

00:20:48.340 --> 00:20:51.040
So in this case,
we're getting back the status

00:20:51.040 --> 00:20:54.880
and we see when the job started,
when it was submitted

00:20:55.520 --> 00:20:56.910
and what its status is.

00:20:56.910 --> 00:20:59.130
In this case,
the job has already finished.

00:20:59.130 --> 00:21:00.430
It didn't take very long.

00:21:00.440 --> 00:21:03.130
It is just putting out
a calendar after all.

00:21:03.250 --> 00:21:09.120
And so we'd like to retrieve the
results which we do like this.

00:21:09.120 --> 00:21:11.420
And so again,
you use that same identifier that

00:21:11.420 --> 00:21:14.650
was returned in the submission
and it just prints out the

00:21:14.720 --> 00:21:16.760
results to send it out here.

00:21:16.830 --> 00:21:20.220
And then you delete the job because
the job sticks around in case there's

00:21:20.330 --> 00:21:21.860
an error retrieving the results.

00:21:21.880 --> 00:21:24.470
The job doesn't get
automatically deleted.

00:21:24.470 --> 00:21:26.990
You have to explicitly
delete it yourself.

00:21:28.450 --> 00:21:32.470
So the Grid Foundation APIs contain
a number of classes,

00:21:32.470 --> 00:21:35.060
and I'll talk about them
in detail in a minute.

00:21:35.060 --> 00:21:36.970
But this is the big list.

00:21:36.970 --> 00:21:42.020
The one you notice here is XGResource,
which is the base class for a

00:21:42.020 --> 00:21:44.630
lot of these other classes here.

00:21:44.630 --> 00:21:49.610
The XGResource classes all represent
a remote resource that you're

00:21:49.610 --> 00:21:52.260
monitoring with your application.

00:21:52.280 --> 00:21:54.450
So they act as proxy objects.

00:21:54.540 --> 00:21:59.230
So they aren't the actual job,
they aren't the actual node

00:21:59.230 --> 00:22:01.740
that lives in the controller.

00:22:02.060 --> 00:22:04.630
They are your sort of
view onto those things.

00:22:07.400 --> 00:22:14.390
So, using the client APIs,
what you begin with is you connect

00:22:14.550 --> 00:22:18.780
using the XG connection object,
and you authenticate using

00:22:18.780 --> 00:22:20.800
the XG authenticator object.

00:22:20.800 --> 00:22:23.800
And then you create a job first
by creating a specification

00:22:23.800 --> 00:22:27.700
of what that job entails,
and that would be the command and the

00:22:27.700 --> 00:22:30.070
arguments and what files it depends on.

00:22:30.070 --> 00:22:33.400
And then you create a submission
using that specification

00:22:33.880 --> 00:22:35.830
and submit the submission.

00:22:35.830 --> 00:22:39.640
And then as that -- if
that submission succeeds,

00:22:39.720 --> 00:22:43.820
you receive back an XG job object.

00:22:43.820 --> 00:22:49.190
You then can monitor the job using
action monitors and the related object,

00:22:49.190 --> 00:22:50.580
the update monitor.

00:22:50.580 --> 00:22:54.760
And so you use these to get your
asynchronous callback to find out when

00:22:54.840 --> 00:22:56.940
the status of the job has changed.

00:22:57.040 --> 00:22:59.860
And then finally, when you're ready to
download the results,

00:22:59.860 --> 00:23:02.000
you use the XG file download object.

00:23:02.000 --> 00:23:05.890
which allows you to retrieve the results.

00:23:06.640 --> 00:23:10.040
So first of all,
you want to connect and authenticate.

00:23:10.040 --> 00:23:14.590
So use the connection,
and we use a subclass of XG Authenticator

00:23:14.590 --> 00:23:19.680
in the technical preview called
the Two-Way Random Authenticator.

00:23:20.370 --> 00:23:23.960
So first you create the connection.

00:23:23.960 --> 00:23:26.080
In this case, we're using a host
name and a port number,

00:23:26.080 --> 00:23:28.400
and zero means use the
default port number.

00:23:28.430 --> 00:23:32.660
You can also use an NSNet service
if you're using rendezvous and

00:23:32.660 --> 00:23:34.930
you've browsed for a service.

00:23:35.030 --> 00:23:41.180
And then you create an authenticator,
set the username and set the password.

00:23:41.180 --> 00:23:43.870
You may get these from Keychain.

00:23:43.870 --> 00:23:46.980
And then you set the
authenticator on the connection,

00:23:46.980 --> 00:23:46.980
and you tell it to open.

00:23:47.930 --> 00:23:49.460
Which we do right here.

00:23:49.510 --> 00:23:53.250
And so before you do that,
you create a grid controller,

00:23:53.250 --> 00:23:55.280
which is a subclass of XGResource.

00:23:55.380 --> 00:24:02.260
So it's your view into the controller
that's running on another computer.

00:24:02.420 --> 00:24:06.670
And so you create the controller object,
you set yourself as the delegate

00:24:06.670 --> 00:24:09.600
so you can get callbacks when
interesting events occur,

00:24:09.600 --> 00:24:14.180
and then you set the connection on
the controller when you initialize it,

00:24:14.180 --> 00:24:16.200
and you open the connection.

00:24:16.200 --> 00:24:20.130
Then you'd like to know when
you've actually found out what

00:24:20.380 --> 00:24:24.330
the grid controller is doing,
what tasks it's running,

00:24:24.480 --> 00:24:28.280
what jobs it's running,
what file sets it's aware of,

00:24:28.320 --> 00:24:30.320
which nodes it's aware of.

00:24:30.620 --> 00:24:32.690
And so you ask the grid
controller to update,

00:24:32.690 --> 00:24:34.730
and you get back an
update monitor object.

00:24:34.760 --> 00:24:39.110
And then when you'd like to know when
that update has succeeded or failed,

00:24:39.110 --> 00:24:41.420
your delegate will get a callback.

00:24:43.820 --> 00:24:46.510
So here's the callback,
the update monitor,

00:24:46.510 --> 00:24:50.560
resource did update method that
your delegate should implement.

00:24:50.560 --> 00:24:53.190
And so in this case,
we check to see that the

00:24:53.240 --> 00:24:56.950
resource is the grid controller,
and if so, we see if the grid

00:24:57.130 --> 00:24:58.940
controller is available.

00:24:58.940 --> 00:25:05.070
And again, if it is, we call a method,
which I'll describe in a minute,

00:25:05.070 --> 00:25:06.240
submit job.

00:25:06.370 --> 00:25:08.980
And that isn't part of the API.

00:25:08.980 --> 00:25:09.740
This is a method that you
would implement yourself.

00:25:09.890 --> 00:25:13.170
So when you submit a job,
you use the specification object,

00:25:13.230 --> 00:25:16.470
XG specification, and use XG submission,
and again,

00:25:16.470 --> 00:25:18.650
you use XG controller many times.

00:25:20.160 --> 00:25:25.220
So to create a specification,
first you need the job info.

00:25:25.220 --> 00:25:28.120
And so rather than showing you some
code on how to create this dictionary,

00:25:28.120 --> 00:25:30.760
I'm showing you the
actual property list here.

00:25:30.760 --> 00:25:34.080
So info dictionary
contains a job dictionary,

00:25:34.080 --> 00:25:37.260
contains information
about the default task.

00:25:37.450 --> 00:25:41.600
And so these are parameters
that apply to all the tasks.

00:25:41.650 --> 00:25:43.660
And then you actually
have a list of your tasks.

00:25:43.700 --> 00:25:46.980
So in this case,
we want all of the tasks to

00:25:46.990 --> 00:25:50.220
use cal as the executable,
but each task should have a

00:25:50.220 --> 00:25:51.370
different set of arguments.

00:25:51.410 --> 00:25:56.870
And in this case,
we're getting June 2004 and June 2005.

00:25:56.950 --> 00:25:59.710
And then the type of this
job is unordered tasks.

00:25:59.790 --> 00:26:04.190
The scheduler is free to run
these in any order simultaneously,

00:26:04.190 --> 00:26:07.060
sequentially,
whatever it needs to do to make

00:26:07.060 --> 00:26:08.140
the best use of the resources.

00:26:10.440 --> 00:26:13.560
So with this job info,
we create a job specification.

00:26:13.770 --> 00:26:18.110
So you can imagine that that info
dictionary would be returned by

00:26:18.160 --> 00:26:22.680
the job specification info method
in the second line of this method.

00:26:22.680 --> 00:26:28.050
So you create the specification
object using a type,

00:26:28.180 --> 00:26:33.020
the info, an application identifier,
and application info.

00:26:33.020 --> 00:26:37.880
The application identifier and info
are completely uninterpreted by Xgrid.

00:26:37.880 --> 00:26:40.280
They're just there so you can sort them.

00:26:41.300 --> 00:26:42.270
So with this job information,
you can filter out jobs so that

00:26:42.270 --> 00:26:45.800
you only look at jobs that you've
submitted and that you don't have

00:26:45.800 --> 00:26:49.600
to worry about jobs that have
been submitted by other clients.

00:26:49.600 --> 00:26:53.270
And the application info would be sort
of information about the job that's

00:26:53.290 --> 00:26:57.290
not relevant to how Xgrid uses it,
but is relevant to how you might

00:26:57.300 --> 00:26:59.700
want to process it when it's done.

00:27:01.430 --> 00:27:04.950
So using that job specification
that we created in that method,

00:27:04.990 --> 00:27:10.830
you then create a job submission
and a job submission monitor.

00:27:11.210 --> 00:27:14.940
And so you set yourself
as a delegate on this,

00:27:15.000 --> 00:27:18.640
and when the submission
succeeds or fails,

00:27:18.640 --> 00:27:20.940
you will get a callback.

00:27:22.250 --> 00:27:24.050
So here we see the callback.

00:27:24.230 --> 00:27:27.910
Again, it's the submission monitor
resource did submit.

00:27:27.910 --> 00:27:30.240
And we check to see that it's the
submission monitor we're expecting.

00:27:30.240 --> 00:27:34.380
And we take the resource,
which we expect to be a job in this case,

00:27:34.420 --> 00:27:38.600
because we're submitting a
specification with a type of job.

00:27:38.600 --> 00:27:43.480
And with this job,
we tell it to update continuously.

00:27:43.630 --> 00:27:46.480
We don't want to just find
out what it's doing right now.

00:27:46.480 --> 00:27:49.030
We want to know everything
that happens to it from now

00:27:49.130 --> 00:27:52.010
until we don't care anymore,
until the job is done.

00:27:52.100 --> 00:27:57.100
So, we get a job update monitor object
and we set ourselves as the delegate.

00:27:57.800 --> 00:28:01.780
So we've now submitted the job,
and it's time to monitor

00:28:01.780 --> 00:28:03.740
it to see what happens.

00:28:03.740 --> 00:28:06.550
So we're going to use the
action monitor classes.

00:28:06.660 --> 00:28:15.740
We're going to use the job, task, node,
and node list objects to

00:28:15.740 --> 00:28:15.740
monitor what's going on with
the grid while this is running.

00:28:16.750 --> 00:28:20.150
So the XG Grid Controller object
can be used to get a list of

00:28:20.150 --> 00:28:22.600
all these other resources.

00:28:22.600 --> 00:28:26.370
The NodeList object is used
to get a list of the nodes.

00:28:26.580 --> 00:28:30.750
So NodeList is you might consider
is kind of like a virtual cluster.

00:28:30.750 --> 00:28:35.890
It's just a collection of nodes that
are meaningfully grouped together.

00:28:35.890 --> 00:28:39.840
So you can submit jobs to run on
specific NodeLists or you can submit

00:28:39.840 --> 00:28:41.910
jobs to just run on all of the nodes.

00:28:41.910 --> 00:28:45.620
And then the nodes actually the
XG Node object actually contains

00:28:45.620 --> 00:28:49.160
the information about the node
such as how many processors it has,

00:28:49.230 --> 00:28:51.790
how fast it is, that kind of thing.

00:28:52.570 --> 00:28:56.330
So when you're monitoring a job,
you of course use the submission

00:28:56.340 --> 00:29:00.330
object to first get the job,
and then you use the job object

00:29:00.360 --> 00:29:02.380
to get a list of the tasks.

00:29:02.400 --> 00:29:05.740
And that is available once
the job has started running.

00:29:05.760 --> 00:29:11.090
And then with these XG task objects,
you wait until they're done executing,

00:29:11.210 --> 00:29:14.050
and then you can retrieve the results.

00:29:16.950 --> 00:29:20.560
So, first thing,
it's waiting for the job to update.

00:29:20.560 --> 00:29:24.960
And again, we use this update monitor,
resource that update method.

00:29:24.960 --> 00:29:27.800
And here we check to see
if the resource is the job.

00:29:27.830 --> 00:29:30.700
And if the job is finished,
we retrieve the tasks.

00:29:32.600 --> 00:29:34.530
So this is what retrieving
the tasks looks like.

00:29:34.640 --> 00:29:39.270
You ask the job for a list of tasks,
and then you walk through that

00:29:39.550 --> 00:29:42.420
list and ask each task to update,
and you would want to

00:29:42.420 --> 00:29:44.490
set the delegate on that,
too.

00:29:47.270 --> 00:29:49.840
So when you get the callback,
you're going to want to

00:29:49.840 --> 00:29:51.190
retrieve the results.

00:29:51.290 --> 00:29:53.980
And to do that,
you're going to use XG file

00:29:54.030 --> 00:29:55.510
and XG file download.

00:29:57.210 --> 00:30:00.780
So as I mentioned before,
you get the standard output and

00:30:00.780 --> 00:30:02.700
the error streams from a task.

00:30:02.940 --> 00:30:05.950
And these are treated as files,
special files,

00:30:06.040 --> 00:30:08.170
files that have no attributes.

00:30:08.300 --> 00:30:12.520
So you still use the XG file
object to retrieve these streams.

00:30:13.230 --> 00:30:16.700
An XG file is a reference to a
file's attributes and content.

00:30:16.700 --> 00:30:18.870
It's not the actual content itself.

00:30:19.080 --> 00:30:22.150
To get the content,
you use the XG file download object.

00:30:22.290 --> 00:30:24.970
And this lets you do an
asynchronous download of the file

00:30:25.170 --> 00:30:26.730
from the controller to the client.

00:30:26.760 --> 00:30:29.910
And you can download either
into memory or onto disk.

00:30:29.910 --> 00:30:34.230
You might want to download into
memory if you wanted to do some

00:30:34.230 --> 00:30:38.400
further processing on this data
immediately display to the user.

00:30:38.400 --> 00:30:41.730
And you might want to save it
to disk if it's really large.

00:30:41.830 --> 00:30:44.570
If you're downloading
four gigabytes of output,

00:30:44.570 --> 00:30:47.620
clearly, you probably don't want to load
it all into memory just so that

00:30:47.630 --> 00:30:48.940
you can save it to disk later.

00:30:49.100 --> 00:30:50.790
So you can download directly to disk.

00:30:52.170 --> 00:30:54.910
And the XG file download object
can also be used to begin

00:30:55.040 --> 00:30:58.280
downloading standard output of a
task that hasn't completed yet.

00:30:58.620 --> 00:31:02.720
It will just continue downloading,
and if there's no more output ready

00:31:03.110 --> 00:31:06.960
but the task is still running,
it'll just wait for more output.

00:31:09.390 --> 00:31:12.100
So here's an example of how
to start downloading files.

00:31:12.130 --> 00:31:14.650
First,
you get the output files from the task,

00:31:14.660 --> 00:31:19.610
and then you enumerate them,
and we'll walk through them.

00:31:19.620 --> 00:31:22.070
But before we do that,
we create a base path,

00:31:22.070 --> 00:31:25.610
and this is where we're going
to be saving all the results.

00:31:25.610 --> 00:31:25.610
So

00:31:25.920 --> 00:31:29.950
For each file, we create a file path by
using the path of the file,

00:31:29.970 --> 00:31:33.040
which is probably in most
cases just a file name,

00:31:33.040 --> 00:31:35.990
just one file name,
and we append that to the end

00:31:36.220 --> 00:31:38.390
of the results directory path.

00:31:38.520 --> 00:31:45.330
And then we create a file download
object with the output file,

00:31:45.510 --> 00:31:50.690
and we set a delegate,
and then we set a destination for

00:31:50.690 --> 00:31:50.690
where we want this file download to go.

00:31:51.050 --> 00:31:55.280
And finally, we need to retain this
file download object.

00:31:55.490 --> 00:31:58.530
So we have a set here,
and we just add the file download

00:31:58.580 --> 00:32:00.280
to the file download set.

00:32:00.350 --> 00:32:04.110
And we properly manage our memory.

00:32:05.090 --> 00:32:10.440
So when the file download finishes,
the delegate gets this callback.

00:32:10.550 --> 00:32:15.760
And so we make sure it's one of the file
downloads that we're paying attention to.

00:32:15.810 --> 00:32:17.480
And we remove it from our set.

00:32:17.710 --> 00:32:21.880
And then if there's no
more file downloads left,

00:32:22.110 --> 00:32:27.730
we know that we've successfully
downloaded all of the files.

00:32:27.730 --> 00:32:29.190
And so we're ready to notify the user
that the job results have all been saved.

00:32:30.340 --> 00:32:33.310
And at this point,
I would like to turn over to

00:32:33.350 --> 00:32:39.090
Charles Parnot to talk about actually
using Xgrid to fit biochemical models.

00:32:52.460 --> 00:32:56.960
I would like to thank David to give
me the opportunity to talk here.

00:32:57.040 --> 00:33:00.230
So I want to present to you
today some of the work that

00:33:00.230 --> 00:33:04.590
I'm doing in Brian Kobilka's
lab in Stanford University.

00:33:04.700 --> 00:33:09.650
And I will start with a short
introduction with quite a bit of

00:33:09.650 --> 00:33:14.520
biology to explain to you our scientific
goal and the kind of biophysical studies

00:33:14.520 --> 00:33:17.610
we're doing to achieve these goals.

00:33:19.050 --> 00:33:22.340
And then I'll turn to the challenge
that we're now facing in terms of

00:33:22.590 --> 00:33:28.660
data analysis and how we use Xgrid
to try to deal with this challenge.

00:33:31.330 --> 00:33:35.730
You probably all know that the
brain regulates the heart activity

00:33:35.730 --> 00:33:39.770
by releasing adrenaline to it,
particularly when you're

00:33:39.790 --> 00:33:42.670
a little stressed,
like I am right now.

00:33:42.900 --> 00:33:46.910
But what you probably don't
know is that the adrenaline is

00:33:46.910 --> 00:33:51.840
actually released by the neurons
at the surface of the heart cells.

00:33:51.840 --> 00:33:57.520
And the adrenaline is recognized there
by the beta-2 adrenergic receptor.

00:33:57.520 --> 00:33:59.610
And this is the receptor
we are interested in.

00:34:00.030 --> 00:34:04.890
This receptor is a protein
with a very precise 3D shape,

00:34:04.890 --> 00:34:06.590
and here's a schematic of it.

00:34:06.670 --> 00:34:08.580
So on the top is the outside of the cell.

00:34:08.580 --> 00:34:09.980
That's where the adrenaline comes from.

00:34:09.980 --> 00:34:14.470
And when the adrenaline binds,
the receptor goes through a series

00:34:14.960 --> 00:34:19.800
of changes in shape in 3D structure
through a series of states.

00:34:20.400 --> 00:34:24.490
And we want to really understand
this process because this is what

00:34:24.510 --> 00:34:26.680
ultimately regulates the heart rate.

00:34:26.740 --> 00:34:29.220
And if we understand these changes,
we'll be able to develop

00:34:29.330 --> 00:34:30.720
new drugs for heart disease.

00:34:33.330 --> 00:34:38.380
So the question we're
asking are quite simple.

00:34:38.380 --> 00:34:39.420
Is this model true?

00:34:39.500 --> 00:34:42.320
And if it is true,
how many states do we have?

00:34:42.320 --> 00:34:44.040
And how fast are the transitions?

00:34:44.250 --> 00:34:47.960
And the way we try to answer this
question is by using fluorescent

00:34:47.990 --> 00:34:53.010
probes that we can attach at a very
precise location in the receptor.

00:34:53.100 --> 00:34:56.040
And then the nice thing with
these probes is that each state

00:34:56.040 --> 00:34:58.940
then has different brightness.

00:34:58.940 --> 00:35:00.290
One state, one brightness.

00:35:00.290 --> 00:35:03.520
And we can monitor the transitions.

00:35:03.520 --> 00:35:07.850
And I imagine you put several
trillions of these molecules in a tube,

00:35:07.890 --> 00:35:11.230
and you're measuring the
average fluorescence of all

00:35:11.230 --> 00:35:13.320
this population of receptor.

00:35:13.520 --> 00:35:17.090
And here is some real data
obtained in the lab where you have

00:35:17.190 --> 00:35:21.420
fluorescence as a function of time
where you add the drug at time zero,

00:35:21.420 --> 00:35:24.800
and you can generate more data
by using different concentration.

00:35:26.600 --> 00:35:30.100
So now back to the model.

00:35:30.100 --> 00:35:31.280
This is the model I showed you before.

00:35:31.280 --> 00:35:36.080
What we really want to do is
take this data in green and try

00:35:36.100 --> 00:35:39.620
to fit it with the model in red.

00:35:39.650 --> 00:35:43.840
For that, we have an OSDN application
that we have written to do the

00:35:43.840 --> 00:35:45.860
simulation and the fitting.

00:35:45.860 --> 00:35:49.280
But the problem that we
rapidly faced is that we have

00:35:49.340 --> 00:35:51.650
really many parameters to fit.

00:35:51.730 --> 00:35:54.860
So for each state, as I told you,
we have a different brightness.

00:35:54.860 --> 00:35:59.430
And then for each reaction,
back and forth, we have a different rate.

00:35:59.440 --> 00:36:00.880
So here's the problem.

00:36:00.880 --> 00:36:02.790
We have many parameters to fit.

00:36:02.790 --> 00:36:06.030
And then when you do a fit like this,
you want to give the

00:36:06.030 --> 00:36:10.020
computer an initial guess,
an initial values that's not too far from

00:36:10.020 --> 00:36:12.460
the actual best fit that you can find.

00:36:12.460 --> 00:36:14.520
And this is very difficult
with so many parameters.

00:36:15.460 --> 00:36:18.710
So it boils down to one simple problem.

00:36:18.920 --> 00:36:23.830
We have a very large parameter
space that somehow we need to scan.

00:36:23.860 --> 00:36:29.700
And this means a lot of computer time.

00:36:30.110 --> 00:36:35.900
To address this problem, of course,
we opted for Xgrid to dispatch the work,

00:36:36.070 --> 00:36:39.630
the load, onto several computers.

00:36:39.670 --> 00:36:41.480
And the reason why we
turned to Xgrid was,

00:36:41.480 --> 00:36:44.580
first of all,
because we're no cluster experts.

00:36:44.580 --> 00:36:47.140
So that saved us a lot of time,
because Xgrid is really

00:36:47.140 --> 00:36:48.680
easy to install and to use.

00:36:48.680 --> 00:36:52.410
And then we have a typically,
embarrassingly problem,

00:36:52.410 --> 00:36:55.610
because we just want to
run many independent fits,

00:36:55.610 --> 00:36:57.840
each with different starting values.

00:36:58.610 --> 00:37:01.740
And finally, we already had a
Mac OS X application written,

00:37:01.740 --> 00:37:06.900
so that meant very little additional
code to write with some familiar APIs.

00:37:06.900 --> 00:37:11.840
This application, Biokin,
has a Cocoa-based graphical front-end,

00:37:11.840 --> 00:37:14.990
and there's also a common
version of it that we bundled

00:37:15.070 --> 00:37:16.930
into the application package.

00:37:18.600 --> 00:37:25.600
So here is how the tasks were
designed to run in Xgrid.

00:37:26.110 --> 00:37:31.440
Each parameter was sampled over
a reasonable range of values.

00:37:31.440 --> 00:37:35.750
Then each combination of the
parameters constitutes a set

00:37:35.750 --> 00:37:38.400
of starting values for one fit.

00:37:38.570 --> 00:37:47.470
Then each one task, so one Xgrid agent,
typically consists of about 100 fits.

00:37:47.470 --> 00:37:51.590
And the positive results can be selected
based on the threshold set by the user.

00:37:52.940 --> 00:37:58.180
We first implemented this
using the technology preview 2

00:37:58.180 --> 00:38:00.250
with the plugin architecture.

00:38:00.310 --> 00:38:05.990
So we had to use a different format for
the jobs that could be created inside

00:38:06.030 --> 00:38:12.140
a main application that could then
be read and processed by the plugin,

00:38:12.140 --> 00:38:15.620
saved back to the file,
and then could be displayed and analyzed

00:38:15.630 --> 00:38:17.690
further on the main application.

00:38:18.260 --> 00:38:23.050
Now we are implementing the new
version of it with the Xgrid framework,

00:38:23.050 --> 00:38:27.070
which makes a much simpler and
much better integration of the

00:38:27.190 --> 00:38:31.170
Biokin code with the Xgrid code.

00:38:31.380 --> 00:38:37.650
We have this command line tool that is
on the application package that we can

00:38:37.650 --> 00:38:44.250
use to submit a job that contains this
executable together with a temporary

00:38:44.250 --> 00:38:49.490
file that contains the description
of the fits that we want to run.

00:38:49.500 --> 00:38:52.590
Of course, that's just one job,
and what we do is we send several

00:38:52.830 --> 00:38:57.510
hundreds of these jobs to xGrid that
then takes care of dispatching the jobs

00:38:57.650 --> 00:39:00.360
to all the agents as David showed you.

00:39:00.460 --> 00:39:04.910
And xGrid also takes care of retrieving
the successful jobs and sends them

00:39:04.970 --> 00:39:09.760
back to the application for further
analysis and to display the results.

00:39:10.400 --> 00:39:13.100
So far, using XGrid,
we've been able to test really

00:39:13.100 --> 00:39:15.990
extensively those two models
that we call the three-states

00:39:15.990 --> 00:39:18.090
model and the four-states model.

00:39:18.180 --> 00:39:22.940
And it was a big surprise for us,
because we were not able to fit the data.

00:39:23.030 --> 00:39:26.480
But because we used XGrid and
we did all this computation,

00:39:26.480 --> 00:39:31.060
we're really sure that
those models don't fit.

00:39:31.060 --> 00:39:34.900
We have scanned the
parameter space extensively.

00:39:35.060 --> 00:39:37.460
So we can now dismiss those models.

00:39:37.460 --> 00:39:40.520
And this is already a very
important result for us,

00:39:40.520 --> 00:39:42.980
a surprising result,
but an important result.

00:39:43.140 --> 00:39:46.580
And of course,
now we are testing other models.

00:39:46.980 --> 00:39:50.310
So I want to thank the people in my lab,
particularly Brian, Gayatri, Xavier,

00:39:50.310 --> 00:39:52.790
and Aaron,
which were very helpful for this project.

00:39:52.950 --> 00:39:56.320
But I also want to thank all
the people in Stanford that have

00:39:56.410 --> 00:40:01.220
contributed-- they are listed here--
that contributed the CPU to the cluster.

00:40:01.220 --> 00:40:04.520
And finally I want to thank all
the people around the world that

00:40:04.520 --> 00:40:06.540
have contributed to this project.

00:40:06.540 --> 00:40:08.520
And this has been really amazing.

00:40:08.520 --> 00:40:11.220
Now we're reaching 40 gigahertz,
actually.

00:40:11.220 --> 00:40:14.840
And so I want to thank them all,
and maybe some of you are in the room.

00:40:14.850 --> 00:40:17.260
And I want to encourage
you to join the cluster,

00:40:17.280 --> 00:40:18.520
send me an email.

00:40:18.560 --> 00:40:21.900
And finally, all of this wouldn't have
been possible without XGrid.

00:40:21.920 --> 00:40:23.340
So thank you, Apple.

00:40:23.370 --> 00:40:23.930
Thank you, David.

00:40:23.940 --> 00:40:25.680
And thank you, David.

00:40:32.730 --> 00:40:37.080
So, I just wanted to, I love this slide,
I absolutely love this slide.

00:40:37.080 --> 00:40:39.200
The first time when
Charles sent me his slides,

00:40:39.250 --> 00:40:40.040
I saw this one.

00:40:40.040 --> 00:40:42.430
I knew right away,
and I forwarded it off to

00:40:42.430 --> 00:40:44.740
David and to Richard Crandall,
who was sort of the

00:40:44.740 --> 00:40:47.470
originator of this thinking,
that we had essentially achieved the,

00:40:47.570 --> 00:40:49.260
if you will,
SETI at home for the rest of us.

00:40:49.320 --> 00:40:52.560
This is something that Charles,
who as you can tell is a scientist,

00:40:52.560 --> 00:40:54.540
he has a task he's trying to get done.

00:40:54.540 --> 00:40:58.030
He is not interested in doing
distributed computation from the inside.

00:40:58.040 --> 00:41:00.190
He's interested in using the
capabilities of doing distributed

00:41:00.200 --> 00:41:02.060
computation to solve his task.

00:41:02.060 --> 00:41:05.130
He managed to assemble this amazing
grid of people through a bunch of

00:41:05.130 --> 00:41:07.780
essentially social engineering,
sending out a really nice email

00:41:07.780 --> 00:41:10.900
message to his friends and their
friends and their friends and so on,

00:41:10.900 --> 00:41:15.800
and built himself a 40 gigahertz
cluster just by being a nice guy.

00:41:15.800 --> 00:41:15.800
So.

00:41:17.530 --> 00:41:17.950
Here we are.

00:41:18.170 --> 00:41:19.460
Key issues and takeaways.

00:41:19.460 --> 00:41:22.090
So, Technology Preview 2
is available right now.

00:41:22.090 --> 00:41:24.020
You can download it off of the website.

00:41:24.020 --> 00:41:25.490
There's some URLs at the end.

00:41:25.490 --> 00:41:29.220
And, of course, you can always just go to
apple.com slash acg slash xgrid,

00:41:29.270 --> 00:41:31.330
and that URL is coming, and get it.

00:41:31.380 --> 00:41:33.040
This is part of Tiger Server.

00:41:33.160 --> 00:41:37.000
There will be enhanced functionality
that is part of Tiger Server,

00:41:37.000 --> 00:41:39.830
as well as some components
will be part of Tiger.

00:41:39.830 --> 00:41:42.710
So stay tuned to see sort
of how we package this up.

00:41:42.710 --> 00:41:45.660
But Xgrid is part of Tiger, Tiger Server.

00:41:46.760 --> 00:41:49.380
The agents themselves,
because we realize that a

00:41:49.380 --> 00:41:52.390
lot of us especially have
Panther clients out there running,

00:41:52.390 --> 00:41:55.670
and it's not feasible to imagine
that every single Panther client

00:41:55.740 --> 00:41:58.360
will be updated instantly to Tiger,
although we certainly

00:41:58.410 --> 00:41:59.120
hope that's the case.

00:41:59.120 --> 00:42:02.880
If you're doing desktop recovery,
the agents will run on Panther as well.

00:42:02.880 --> 00:42:04.420
And we really, really,
really want your feedback.

00:42:04.420 --> 00:42:09.520
That's why we put TP2,
TP1 and TP2 out to the whole community.

00:42:09.520 --> 00:42:10.060
Use it.

00:42:10.350 --> 00:42:11.690
There's bugs that we know about.

00:42:11.750 --> 00:42:13.570
I'm sure there's bugs
we don't know about,

00:42:13.580 --> 00:42:16.220
and we want to fix those and
get this to be great quality.

00:42:16.560 --> 00:42:20.380
So first of all, download TP2,
Xgrid right now, or take the information

00:42:20.910 --> 00:42:24.570
you've learned today,
think about it, send your feedback to the

00:42:24.570 --> 00:42:29.640
addresses that are shown here.

00:42:29.640 --> 00:42:31.280
If you're a user of Xgrid,
there's a great user list in

00:42:31.280 --> 00:42:33.240
an archive through our email
system that you can look through,

00:42:33.240 --> 00:42:35.350
lots of posts from Charles and
others on things that they found out,

00:42:35.350 --> 00:42:37.470
as well as just the generic
feedback that David and I read.

00:42:37.480 --> 00:42:38.670
So, first of all, download TP2, TP1, TP2,
and TP2 out to the whole community.

00:42:38.670 --> 00:42:38.670
Use it.

00:42:38.670 --> 00:42:38.670
There's bugs that we know about,
and we certainly hope that's the case.

00:42:38.830 --> 00:42:41.200
And if you need more information,
of course, go to the website.

00:42:41.200 --> 00:42:43.560
This is obviously in your
kits and on the web page.

00:42:43.560 --> 00:42:46.420
And give us a call.

00:42:46.420 --> 00:42:50.980
Lastly, I want to also thank and bring up
here for the QA James Reynolds from

00:42:50.980 --> 00:42:54.260
the University of Utah,
who has kindly worked with us to

00:42:54.440 --> 00:42:58.010
put together the demonstration
that you can see running right

00:42:58.010 --> 00:42:59.950
now in the Enterprise IT Lab.

00:43:01.300 --> 00:43:02.970
And we have harvested the
power of a number of machines

00:43:02.970 --> 00:43:04.600
running around WWDC right now.

00:43:04.600 --> 00:43:07.260
And we've built a grid that's
roughly plus or minus 10,

00:43:07.260 --> 00:43:09.640
depending on whether these machines
are being used by someone else or not,

00:43:09.640 --> 00:43:11.020
roughly about 100 gigahertz.

00:43:11.100 --> 00:43:12.570
And actually,
it's a little bit more than that.

00:43:12.640 --> 00:43:15.790
And what James has done is provide
us with a number of scripts

00:43:15.790 --> 00:43:17.610
and some interesting models.

00:43:17.610 --> 00:43:23.250
And he's doing a massively distributed
Povray render of a 3300-frame movie,

00:43:23.250 --> 00:43:24.070
I think.

00:43:24.080 --> 00:43:25.960
And as the show has been going on,
that movie has been

00:43:25.960 --> 00:43:27.040
getting longer and longer.

00:43:27.050 --> 00:43:28.360
It's really quite beautiful.

00:43:28.360 --> 00:43:30.200
So check that out in the Enterprise IT.

00:43:30.300 --> 00:43:30.600
Lab.
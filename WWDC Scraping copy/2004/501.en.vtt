WEBVTT

00:00:16.460 --> 00:00:21.450
Welcome to session 501, FireWire.

00:00:21.450 --> 00:00:21.450
Thank you.

00:00:21.730 --> 00:00:25.450
Okay, every year we see new FireWire
products and applications,

00:00:25.450 --> 00:00:27.320
all sorts of areas.

00:00:27.320 --> 00:00:29.080
The technology just keeps going further.

00:00:29.080 --> 00:00:32.450
The main reason is because of you,
our developers.

00:00:32.450 --> 00:00:35.890
You keep innovating with this technology,
finding new ways to use it,

00:00:35.890 --> 00:00:36.860
and that's great.

00:00:36.910 --> 00:00:38.600
That's exactly why we're here.

00:00:41.260 --> 00:00:42.400
We're trying to keep up with you.

00:00:42.400 --> 00:00:47.370
We've got a lot of new services,
new features, new APIs, new sample code,

00:00:47.370 --> 00:00:50.280
new tools, even a few bug fixes.

00:00:50.580 --> 00:00:53.940
This year, we're back at WWDC,
just like every year,

00:00:54.110 --> 00:00:55.750
to bring all that to you.

00:00:56.090 --> 00:00:58.410
For those of you who are already
developing with FireWire,

00:00:58.490 --> 00:01:01.700
we have a lot of new material this year,
especially as relates to Tiger.

00:01:01.700 --> 00:01:04.110
And for everybody,
we have a quick introduction to

00:01:04.110 --> 00:01:06.640
the hardware and the software,
so that you'll all get

00:01:06.640 --> 00:01:08.080
the complete big picture.

00:01:09.770 --> 00:01:12.020
So we're going to start by
recapping where the FireWire

00:01:12.170 --> 00:01:14.700
ports are and why they're there,
because that's where

00:01:14.700 --> 00:01:17.630
your device plugs in,
that's where the opportunities exist.

00:01:17.780 --> 00:01:20.320
Then we'll quickly look at the software,
how that works from

00:01:20.390 --> 00:01:21.700
drivers up to application.

00:01:21.700 --> 00:01:25.620
Again, where can you hook in,
what's your part going to do?

00:01:25.700 --> 00:01:27.890
The bulk of the presentation
is on what's new,

00:01:27.930 --> 00:01:30.530
what's new in Tiger,
and what's new since last year.

00:01:30.700 --> 00:01:34.690
And then we'll wrap up with a quick
look at some of the great resources

00:01:34.690 --> 00:01:38.690
that we have for you as developers
to help you develop on FireWire.

00:01:39.160 --> 00:01:40.360
First, the hardware.

00:01:40.360 --> 00:01:41.840
Where are the FireWire ports?

00:01:41.840 --> 00:01:44.600
This part is easy because
they're pretty much everywhere.

00:01:44.600 --> 00:01:48.200
Every product that we make,
every CPU from the iBook up to

00:01:48.300 --> 00:01:50.620
the XServe has FireWire ports.

00:01:50.620 --> 00:01:52.340
Built in, we've been doing it for years.

00:01:52.340 --> 00:01:55.540
Every iPod that we make
has FireWire ports.

00:01:55.920 --> 00:01:58.150
And there's two more
products that have FireWire.

00:01:58.150 --> 00:02:01.960
One is the EyeSight camera,
used with iChat AV.

00:02:01.960 --> 00:02:06.050
And the other, only introduced yesterday,
is our new line of flat panel monitors,

00:02:06.050 --> 00:02:08.020
which have built-in FireWire hubs.

00:02:08.060 --> 00:02:13.260
So there are lots and lots of ports for
your customer to plug your device into.

00:02:13.260 --> 00:02:13.740
Why?

00:02:13.740 --> 00:02:16.380
Why do we have so many FireWire ports?

00:02:16.440 --> 00:02:18.720
What's so great about FireWire?

00:02:20.190 --> 00:02:22.730
In years past,
we could get up here and say, well,

00:02:22.730 --> 00:02:28.220
it's hot-pluggable, auto-configuring,
no terminators, no SCSI IDs, thin,

00:02:28.220 --> 00:02:29.620
friendly cables.

00:02:29.620 --> 00:02:32.830
These days,
that's true of pretty much every I.O.

00:02:32.840 --> 00:02:35.560
Anything left in FireWire
that makes it special?

00:02:35.560 --> 00:02:37.120
Well, there's a few things.

00:02:39.720 --> 00:02:42.230
FireWire is really fast.

00:02:42.340 --> 00:02:47.600
FireWire 800, 800 megabits per second,
that's 100 megabytes per second.

00:02:47.600 --> 00:02:50.510
It's the fastest general-purpose
interface on the box.

00:02:50.510 --> 00:02:53.460
If you want to get data
in or out in a hurry,

00:02:53.460 --> 00:02:55.590
we've got the speed for you.

00:02:56.200 --> 00:02:57.800
Multi-speed.

00:02:57.880 --> 00:03:02.120
FireWire devices shipped starting at
100 megabits and then moved up to 800.

00:03:02.120 --> 00:03:05.180
You can freely mix and match
these on a FireWire bus.

00:03:05.250 --> 00:03:08.210
The slow devices go slow,
the fast devices go fast,

00:03:08.260 --> 00:03:11.940
but FireWire can change speed
on a packet-by-packet basis,

00:03:11.950 --> 00:03:15.850
so the fast devices don't get slowed
down by having to speak at a common,

00:03:15.850 --> 00:03:16.850
slower speed.

00:03:21.130 --> 00:03:24.250
FireWire can cover really long distances,
longer than the other

00:03:24.250 --> 00:03:25.600
general-purpose I/Os.

00:03:25.740 --> 00:03:27.900
FireWire can go up to 100 meters.

00:03:28.220 --> 00:03:29.820
That's longer than a football field.

00:03:30.000 --> 00:03:33.110
If you want to get your device
really far away from the user,

00:03:33.110 --> 00:03:35.070
FireWire is the way to do it.

00:03:37.220 --> 00:03:39.760
FireWire provides a lot more
power than any other bus,

00:03:39.820 --> 00:03:40.220
too.

00:03:40.220 --> 00:03:41.980
Maybe that's why you want
to get the device far away.

00:03:41.980 --> 00:03:45.390
FireWire can provide 45 watts of power.

00:03:45.390 --> 00:03:49.300
Our machines provide less,
but plenty to run an iSight or an iPod.

00:03:49.300 --> 00:03:52.060
But if you have a custom application,
the cables, the sockets,

00:03:52.170 --> 00:03:53.730
they're all rated for 45 watts.

00:03:53.730 --> 00:03:56.170
You can do some really
innovative things with that.

00:03:56.210 --> 00:03:57.400
And customers love it.

00:03:57.400 --> 00:04:00.040
There's no extra power
supply for the iSight camera.

00:04:00.040 --> 00:04:02.620
The iPod charges when it's
plugged in on FireWire,

00:04:02.620 --> 00:04:03.980
and it charges quickly.

00:04:03.980 --> 00:04:06.280
Big advantage for FireWire.

00:04:07.980 --> 00:04:09.300
isochronous.

00:04:09.480 --> 00:04:13.310
Some other interfaces have this,
but FireWire does this really well.

00:04:13.620 --> 00:04:18.120
Isochronous moves streaming data, audio,
video, data that has to go in real time.

00:04:18.120 --> 00:04:22.720
FireWire has very low latency and
guaranteed bandwidth for isochronous,

00:04:22.780 --> 00:04:25.880
so it works very well for
delivering your media data.

00:04:26.520 --> 00:04:27.900
FireWire is peer-to-peer.

00:04:27.900 --> 00:04:30.200
FireWire has been
peer-to-peer from day one.

00:04:30.200 --> 00:04:35.010
The very first FireWire product was
a digital video camcorder in 1995.

00:04:35.100 --> 00:04:38.570
There was only one other thing you
could plug into it on FireWire,

00:04:38.570 --> 00:04:40.610
another digital video camcorder.

00:04:40.670 --> 00:04:42.850
You can't get more
peer-to-peer than that,

00:04:43.000 --> 00:04:43.830
but it worked.

00:04:43.940 --> 00:04:46.290
You could copy one tape
from one camera to another.

00:04:46.290 --> 00:04:47.210
You could edit DV.

00:04:47.210 --> 00:04:48.510
It was kind of cumbersome.

00:04:48.510 --> 00:04:51.610
We didn't have Final Cut back then,
but you could do it peer-to-peer

00:04:51.790 --> 00:04:53.170
between those two cameras.

00:04:53.180 --> 00:04:55.660
Everything about
FireWire is peer-to-peer.

00:04:55.660 --> 00:04:58.120
The host, the devices from day one.

00:04:58.120 --> 00:05:01.650
Some other interfaces,
this may be cobbled on years later.

00:05:01.980 --> 00:05:04.550
It may kind of work,
especially if you only have two peers.

00:05:04.550 --> 00:05:06.240
It may work some of the time.

00:05:06.240 --> 00:05:07.090
Not in FireWire.

00:05:07.090 --> 00:05:08.130
It's been there from day one.

00:05:08.200 --> 00:05:09.580
It gives you tremendous flexibility.

00:05:09.580 --> 00:05:13.190
And all those together,
that's really what FireWire is about,

00:05:13.190 --> 00:05:14.010
flexible.

00:05:14.010 --> 00:05:17.700
If you choose FireWire as the
interface for your product,

00:05:17.890 --> 00:05:20.340
you won't get boxed in
by design constraints.

00:05:20.470 --> 00:05:23.840
As your product grows,
as you add new features, capabilities,

00:05:23.840 --> 00:05:27.480
speed, performance,
FireWire continues to take you there.

00:05:27.490 --> 00:05:30.290
FireWire has so many different ways
of meeting your product's needs.

00:05:30.290 --> 00:05:31.670
It's open-ended.

00:05:31.670 --> 00:05:35.600
You won't get stuck on the
limitations of the bus.

00:05:35.600 --> 00:05:37.460
And it's efficient.

00:05:37.460 --> 00:05:39.730
When you have lots of
devices on a FireWire bus,

00:05:39.730 --> 00:05:44.400
the bus can run nearly 100%.
There's no collisions in FireWire.

00:05:44.400 --> 00:05:45.890
There's no back-off.

00:05:46.060 --> 00:05:47.620
There's no lost packets.

00:05:47.690 --> 00:05:52.040
FireWire operates very efficiently,
even under stress.

00:05:52.040 --> 00:05:55.580
So let's take a closer look
at some of these key concepts.

00:05:56.100 --> 00:05:59.760
One thing that makes FireWire
really fast is the physical DMA.

00:05:59.830 --> 00:06:03.790
This is a feature in our products in the
host controller that allows a FireWire

00:06:03.790 --> 00:06:07.740
device to directly read and write
memory without getting the CPU involved.

00:06:07.740 --> 00:06:09.510
That speeds things up a lot.

00:06:09.610 --> 00:06:10.660
Let's look at how that works.

00:06:10.660 --> 00:06:14.230
Suppose we have a PowerMac G5
tower and the new iPod Mini.

00:06:14.230 --> 00:06:16.820
Of course, it's plugged in by FireWire.

00:06:16.820 --> 00:06:20.540
Let's look inside the G5 tower and
look at just a high-level view of

00:06:20.590 --> 00:06:22.680
some of the system parts in there.

00:06:23.590 --> 00:06:25.120
On the left, you see the CPU.

00:06:25.120 --> 00:06:28.790
In the center is the north bridge,
and it connects the CPU to the memory,

00:06:28.790 --> 00:06:30.770
which is on the right, and the I.O.

00:06:30.770 --> 00:06:32.250
controller down below.

00:06:32.270 --> 00:06:34.820
The FireWire interface is in that I.O.

00:06:34.820 --> 00:06:35.830
controller.

00:06:35.830 --> 00:06:38.940
When the iPod has been
directed to move data,

00:06:38.940 --> 00:06:42.450
it's going to copy data
into or out of the system.

00:06:42.470 --> 00:06:44.680
So let's have a buffer here in memory.

00:06:44.680 --> 00:06:45.910
Let's have a buffer here in memory.

00:06:46.130 --> 00:06:50.400
The iPod requests -- the transfer
is initiated by the iPod.

00:06:50.450 --> 00:06:53.500
It tells the Mac,
"I want to read the buffer," or

00:06:53.500 --> 00:06:56.680
"I want to write the buffer here,
here, here, and here."

00:06:56.950 --> 00:06:59.360
This transfer goes through
the I/O controller,

00:06:59.370 --> 00:07:02.480
which receives the
requests over FireWire,

00:07:02.530 --> 00:07:05.340
and goes directly to
DRAM to service them.

00:07:05.380 --> 00:07:07.860
The CPU is simply not involved.

00:07:07.920 --> 00:07:12.340
There are no interrupts,
there's no polling, no PIO, no handshake,

00:07:12.340 --> 00:07:13.150
nothing.

00:07:13.440 --> 00:07:16.870
It goes as fast as it possibly can,
and the CPU is available

00:07:16.870 --> 00:07:18.850
to do other important work.

00:07:18.920 --> 00:07:21.550
Of course, when the transfer is done,
we send a special packet

00:07:21.550 --> 00:07:23.730
that does cause an interrupt,
because we do want to

00:07:23.730 --> 00:07:25.900
know the date it made it,
where it's trying to go.

00:07:25.900 --> 00:07:28.600
But this makes FireWire extremely fast.

00:07:28.640 --> 00:07:32.100
Also,
the pacing is under control of the iPod.

00:07:32.130 --> 00:07:33.590
This is a very unequal system.

00:07:33.610 --> 00:07:35.360
The iPod has a very small disk.

00:07:35.430 --> 00:07:38.900
It's just not quite as fast
as the G5's memory system.

00:07:38.900 --> 00:07:40.990
The iPod controls the pacing.

00:07:40.990 --> 00:07:43.500
I want to read data now, now, now.

00:07:43.520 --> 00:07:47.030
Everything goes exactly at its speed,
so there's little need for flow

00:07:47.030 --> 00:07:48.900
control or congestion with the iPod.

00:07:48.900 --> 00:07:49.280
driving.

00:07:49.280 --> 00:07:51.440
It can do absolutely
the best that it can.

00:07:54.010 --> 00:07:57.400
Another important feature is the
guaranteed isochronous bandwidth.

00:07:57.690 --> 00:07:59.500
This is for real-time services.

00:07:59.530 --> 00:08:01.820
If you want to connect a
camera or a microphone,

00:08:01.900 --> 00:08:06.220
a device that streams media,
FireWire gives it guaranteed

00:08:06.220 --> 00:08:07.200
access to the bus.

00:08:07.200 --> 00:08:10.130
Its packets will get through,
they'll get through on time,

00:08:10.130 --> 00:08:13.600
even if someone else is trying
to drive the bus to 100%. Let's

00:08:13.730 --> 00:08:15.080
take a look at how that works.

00:08:15.260 --> 00:08:17.430
We'll start with the iSight camera.

00:08:17.770 --> 00:08:20.610
This camera, made by Apple,
sends video and audio

00:08:20.610 --> 00:08:24.540
over FireWire into a Mac,
and is commonly used with iChat AV.

00:08:24.540 --> 00:08:31.080
If we look at a graph of the activity
on a FireWire bus from an iSight camera,

00:08:31.080 --> 00:08:32.710
it's very flat.

00:08:32.740 --> 00:08:35.840
Let's suppose the camera is
set to a very high-resolution,

00:08:35.840 --> 00:08:37.420
high-quality video mode.

00:08:37.420 --> 00:08:40.380
The camera might be using
50% of the FireWire bus.

00:08:40.380 --> 00:08:43.890
If it's the only device on there,
nothing magic is happening.

00:08:43.890 --> 00:08:47.330
Of course, it can get 50%. It's all
about the location of the bus.

00:08:47.330 --> 00:08:49.550
Let's consider a more complicated case.

00:08:49.610 --> 00:08:52.470
Let's take a non-real-time
device like a hard drive.

00:08:52.470 --> 00:08:56.150
A hard drive has a lot of moving parts,
so the rate at which it can transfer

00:08:56.280 --> 00:08:59.820
data is going to vary over time,
especially if you're doing complex

00:08:59.820 --> 00:09:02.070
transfers like directory copies.

00:09:02.070 --> 00:09:04.980
If we look at the access pattern
of a hard drive on FireWire,

00:09:04.980 --> 00:09:06.510
we'll see it's all over the map.

00:09:06.590 --> 00:09:08.760
If it gets going,
it may go up to 100% and

00:09:08.770 --> 00:09:11.450
saturate the FireWire bus,
but then it may drop off while

00:09:11.460 --> 00:09:15.120
it waits for the media to rotate
around and grab some new data.

00:09:15.140 --> 00:09:18.280
If it gets going,
it may drop off while it

00:09:18.520 --> 00:09:23.170
waits for the media to rotate
around and grab some new data.

00:09:23.360 --> 00:09:25.350
on the same FireWire bus.

00:09:25.430 --> 00:09:29.060
Well, the bandwidth for the
iSight is guaranteed.

00:09:29.060 --> 00:09:33.520
The iSight's going to get its 50%
all across time perfectly smoothly,

00:09:33.520 --> 00:09:37.440
and the hard drive is going to
get everything that's left over.

00:09:37.520 --> 00:09:41.690
The hard drive doesn't have to
back off or moderate its requests.

00:09:41.780 --> 00:09:43.870
It can go out and say,
"I want to move data,

00:09:43.880 --> 00:09:47.130
and I want to move it now," and
the hardware in FireWire makes

00:09:47.210 --> 00:09:51.380
sure that as soon as the iSight is
done moving its isochronous data,

00:09:51.380 --> 00:09:54.380
the hard drive can get every
little bit that's left over.

00:09:54.380 --> 00:09:57.660
So in this combination,
the bus efficiency can be pushed

00:09:57.890 --> 00:10:01.250
basically to 100%. The hard
drive can just go full bore.

00:10:01.250 --> 00:10:05.290
It'll take a little longer because
the iSight is also on the bus,

00:10:05.290 --> 00:10:07.960
but there's no impact
at all on the iSight.

00:10:07.960 --> 00:10:11.200
The audio and video keep
flowing completely smoothly.

00:10:11.270 --> 00:10:14.020
This guarantee is provided in hardware,
so you can't mess it up.

00:10:15.950 --> 00:10:18.430
Finally, I said FireWire can go
really long distances,

00:10:18.430 --> 00:10:22.010
but you may have noticed that we don't
have long-distance ports on our products.

00:10:22.090 --> 00:10:23.350
Why is this?

00:10:23.350 --> 00:10:24.390
Does this really work?

00:10:24.480 --> 00:10:27.260
Well,
most of the devices our customers connect

00:10:27.260 --> 00:10:31.490
are things they want to use nearby,
because they're probably interacting

00:10:31.590 --> 00:10:36.140
with the device as well as with the Mac,
such as an iSight camera, an iPod,

00:10:36.140 --> 00:10:38.970
a DV camera where they
may be changing the tape.

00:10:39.550 --> 00:10:43.790
But there are some kinds of devices that
are very interesting at long distances,

00:10:43.790 --> 00:10:47.110
such as a security camera,
or a music studio application,

00:10:47.150 --> 00:10:49.950
or an industrial application where
you want to put some distance

00:10:49.950 --> 00:10:51.190
between yourself and the device.

00:10:51.200 --> 00:10:53.150
So, we can do that.

00:10:53.230 --> 00:10:56.610
What you do is get a 1394B hub.

00:10:56.610 --> 00:11:00.440
This is a very simple device because
it's just one piece of silicon.

00:11:01.860 --> 00:11:05.360
The Hub has regular FireWire
400 ports on one side,

00:11:05.360 --> 00:11:10.700
which you can connect, say, to our iBook,
as shown here, and it has long-haul 1394B

00:11:10.700 --> 00:11:14.380
ports on the other side,
such as plastic optical fiber,

00:11:14.380 --> 00:11:18.310
glass optical fiber,
or Category 5 unshielded twisted pair.

00:11:18.320 --> 00:11:22.020
You can choose the media that's most
appropriate to your application.

00:11:22.020 --> 00:11:24.580
This way,
we don't have to pick between those

00:11:24.690 --> 00:11:27.810
three for the port on our computer,
and you can still get the long distance.

00:11:28.480 --> 00:11:32.040
Now, if your device is something
that's always going to be used,

00:11:32.040 --> 00:11:34.360
or often going to be
used at long distance,

00:11:34.370 --> 00:11:38.660
it may make sense for you to incorporate
the long-haul connector directly.

00:11:38.660 --> 00:11:41.540
Then the customer doesn't need two hubs,
they only need one.

00:11:43.250 --> 00:11:45.590
Other important thing to
note about this picture,

00:11:45.680 --> 00:11:48.960
the two devices at either end, the iBook,
the iSight camera,

00:11:48.960 --> 00:11:51.480
those are not 1394B devices.

00:11:51.480 --> 00:11:52.540
They're FireWire 400.

00:11:52.540 --> 00:11:54.720
Can they work with this long distance?

00:11:54.730 --> 00:11:55.800
Sure.

00:11:55.800 --> 00:11:58.810
1394B is completely backwards compatible.

00:11:58.820 --> 00:12:02.240
The hubs understand how to talk to
a FireWire 400 device and how to

00:12:02.240 --> 00:12:05.380
talk to the long-haul connection,
and the data flows seamlessly

00:12:05.470 --> 00:12:07.280
through from one end to another.

00:12:07.770 --> 00:12:10.920
So this means if you want to put
some distance between the devices,

00:12:10.930 --> 00:12:13.770
you're not limited to our latest
models like the G5 and the

00:12:13.770 --> 00:12:15.980
PowerBook that have FireWire 800.

00:12:15.990 --> 00:12:19.090
Your customers can use this with
all of our products that ever had

00:12:19.090 --> 00:12:21.140
FireWire ports going back many years.

00:12:21.140 --> 00:12:23.280
So this is very flexible technology.

00:12:29.660 --> 00:12:31.210
Let's move on into the software.

00:12:31.400 --> 00:12:34.850
You've seen where the ports are,
why they present unique opportunities.

00:12:34.980 --> 00:12:38.110
Where do you hook in if
you're writing software?

00:12:39.610 --> 00:12:41.510
Consider the Macintosh.

00:12:41.610 --> 00:12:45.450
Suppose you have some FireWire
devices that you'd like to use.

00:12:45.930 --> 00:12:48.800
You're going to have some
applications that launch when

00:12:48.800 --> 00:12:51.000
you want to use these devices.

00:12:51.140 --> 00:12:53.640
Now, as I explained earlier in
the diagram with the iPod,

00:12:53.640 --> 00:12:57.040
every Macintosh has one
built-in FireWire controller.

00:12:57.040 --> 00:13:03.780
It's the industry standard 1394 OpenHCI,
Open Host Controller Interface.

00:13:04.930 --> 00:13:07.980
All of these devices are
going to have to share.

00:13:08.000 --> 00:13:09.390
They all want to use it at once.

00:13:09.390 --> 00:13:11.460
Someone's going to have to mediate this.

00:13:11.460 --> 00:13:15.730
So you've got different applications,
different drivers, different devices,

00:13:15.730 --> 00:13:19.100
each doing their own different
thing on a single controller.

00:13:19.100 --> 00:13:22.030
That's the main job for
the FireWire family.

00:13:22.030 --> 00:13:24.840
The family steps in,
takes ownership of the controller,

00:13:24.840 --> 00:13:27.880
and moderates so that everybody
can do their thing without even

00:13:27.900 --> 00:13:29.890
worrying about what else is going on.

00:13:29.890 --> 00:13:32.370
That's the main function
that the family provides.

00:13:33.790 --> 00:13:37.270
Now, you may not see it,
but consider the two devices on the left,

00:13:37.390 --> 00:13:39.200
the still camera, the iPod Mini.

00:13:39.200 --> 00:13:41.000
They actually have a lot in common.

00:13:41.000 --> 00:13:43.700
They both use a mass
storage-oriented protocol.

00:13:43.700 --> 00:13:47.030
They use the FireWire
transport called SBP2,

00:13:47.130 --> 00:13:50.740
Serial Bus Protocol 2,
and they communicate using a

00:13:50.750 --> 00:13:53.340
SCSI architecture on top of that.

00:13:53.380 --> 00:13:56.160
So we provide a standard software layer.

00:13:58.500 --> 00:14:02.140
is the director of the FireWire
software development team.

00:14:02.140 --> 00:14:04.200
He's been working with
Apple for a long time,

00:14:04.200 --> 00:14:06.410
and he's been working with
FireWire for a long time.

00:14:06.540 --> 00:14:10.160
He's been working with
Apple for a long time,

00:14:10.160 --> 00:14:13.500
and he's been working with
FireWire for a long time.

00:14:13.500 --> 00:14:15.980
He's been working with
Apple for a long time,

00:14:16.000 --> 00:14:19.500
and he's been working with
FireWire for a long time.

00:14:19.500 --> 00:14:21.980
He's been working with
Apple for a long time,

00:14:21.980 --> 00:14:24.480
and he's been working with
FireWire for a long time.

00:14:24.570 --> 00:14:27.210
He's been working with
Apple for a long time,

00:14:27.210 --> 00:14:30.330
and he's been working with
Apple for a long time.

00:14:30.330 --> 00:14:31.500
He's been working with
Apple for a long time.

00:14:31.500 --> 00:14:35.300
He's been working with
Apple for a long time.

00:14:35.380 --> 00:14:38.500
He's been working with
Apple for a long time.

00:14:38.500 --> 00:14:40.020
He's been working with
Apple for a long time.

00:14:40.120 --> 00:14:42.560
He's been working with
Apple for a long time.

00:14:42.710 --> 00:14:43.470
He's been working

00:14:44.170 --> 00:14:49.980
or a IO FireWire IP can
provide networking services.

00:14:50.000 --> 00:14:52.290
Those are both kernel services,
so FireWire has to be in the

00:14:52.300 --> 00:14:53.520
kernel to make those possible.

00:14:53.560 --> 00:14:57.510
But we've gone out of our way to make
everything in FireWire available in

00:14:57.510 --> 00:14:59.480
user space as well as in the kernel.

00:14:59.480 --> 00:15:01.780
So odds are,
you can write an application or

00:15:01.910 --> 00:15:03.590
a plug-in for an application.

00:15:03.590 --> 00:15:05.760
You can run it and
debug it in user space,

00:15:05.770 --> 00:15:10.200
which is much more pleasant than trying
to do your development in the kernel.

00:15:11.710 --> 00:15:13.640
Now that you've seen the basics,
let's look a little more at

00:15:13.740 --> 00:15:15.270
the details of the layers.

00:15:15.580 --> 00:15:17.000
Here's the items from before.

00:15:17.040 --> 00:15:19.290
At the bottom,
we have the hardware interface.

00:15:19.470 --> 00:15:23.980
Apple FW-OHCI is a system kernel
extension that effectively is the

00:15:23.980 --> 00:15:26.960
device driver for that interface,
and it has sole control,

00:15:27.070 --> 00:15:29.590
sole direct access to the hardware.

00:15:29.700 --> 00:15:33.200
Above it is IO FireWire family,
also a kernel extension,

00:15:33.250 --> 00:15:36.940
and it has sole ownership
of the OHCI driver.

00:15:37.760 --> 00:15:40.020
Above the family,
first we find protocols,

00:15:40.020 --> 00:15:44.270
such as you saw on the previous slide,
such as AVC or SPP2.

00:15:44.280 --> 00:15:47.510
Above protocols,
we have drivers for particular

00:15:47.600 --> 00:15:49.770
devices or classes of devices.

00:15:49.780 --> 00:15:54.240
For example, a mass storage device uses
the IO FireWire Serial

00:15:54.240 --> 00:15:57.820
Bus Protocol Transport Driver as
its gateway up into mass

00:15:57.910 --> 00:16:01.240
storage and the file system,
whereas the DV Camera uses

00:16:01.240 --> 00:16:04.930
IO FWDV components as its
gateway up into QuickTime.

00:16:05.890 --> 00:16:09.870
Other drivers are more specific,
like Apple EyeSight or IO FireWire IP.

00:16:10.010 --> 00:16:13.500
In fact, these drivers don't use a
separate protocol layer.

00:16:13.500 --> 00:16:16.620
They really are a protocol and
driver all wrapped up in one,

00:16:16.630 --> 00:16:20.190
so drivers can also hook in
directly to the FireWire family.

00:16:22.620 --> 00:16:26.190
Above this layer,
we have what I call everything else.

00:16:26.310 --> 00:16:29.100
Once you move above this layer,
you're not in FireWire anymore.

00:16:29.220 --> 00:16:30.490
You're in QuickTime.

00:16:30.510 --> 00:16:31.500
You're in Final Cut.

00:16:31.500 --> 00:16:32.560
You're in the file system.

00:16:32.560 --> 00:16:33.650
Somewhere else.

00:16:33.650 --> 00:16:34.710
Not my problem.

00:16:34.720 --> 00:16:39.750
So, say, iTunes, Final Cut Pro,
QuickTime, they're good places to be.

00:16:39.750 --> 00:16:41.730
They're above FireWire.

00:16:41.730 --> 00:16:43.690
These could be applications,
or they could be

00:16:43.690 --> 00:16:44.980
additional kernel layers.

00:16:46.980 --> 00:16:50.770
So this is the basics of how the
FireWire software hooks together.

00:16:50.800 --> 00:16:54.790
I mentioned that in applications,
you can access all the FireWire services.

00:16:54.790 --> 00:16:57.680
So of course, applications can talk
directly to drivers,

00:16:57.680 --> 00:16:59.600
but there's two other paths as well.

00:16:59.630 --> 00:17:03.360
We provide what's formally
known as a device interface,

00:17:03.560 --> 00:17:05.860
and is often called a user client.

00:17:05.860 --> 00:17:09.840
This is a library API that lets
you talk directly to a protocol,

00:17:09.840 --> 00:17:14.420
or even directly to the FireWire
family itself from an application.

00:17:14.420 --> 00:17:16.160
So we're very flexible.

00:17:16.190 --> 00:17:20.090
You can hook in anywhere you need,
in the kernel, in application space.

00:17:20.170 --> 00:17:21.930
We provide lots of ways to do it.

00:17:23.440 --> 00:17:25.540
Now, I mentioned IO FireWire IP.

00:17:25.640 --> 00:17:28.280
What's that doing here in FireWire?

00:17:28.280 --> 00:17:31.470
IP is a protocol that's
designed to span the globe.

00:17:31.470 --> 00:17:35.440
It works well on slow,
comparatively slow, unreliable links.

00:17:35.440 --> 00:17:37.260
Doesn't sound like FireWire.

00:17:37.260 --> 00:17:39.820
Well,
turns out it works great on FireWire.

00:17:39.820 --> 00:17:42.680
It doesn't depend on
anybody dropping packets.

00:17:42.680 --> 00:17:46.570
But a lot of devices already have
IP in them for one reason or another,

00:17:46.580 --> 00:17:49.000
generally because it's ubiquitous.

00:17:49.000 --> 00:17:52.520
A lot of printers today have a little
web server inside that lets you

00:17:52.590 --> 00:17:53.370
browse the status of your device.

00:17:53.400 --> 00:17:56.430
Or configure the device,
even if the main data is sent

00:17:56.430 --> 00:17:59.760
over some more native protocol,
say SBP2.

00:17:59.760 --> 00:18:02.580
So if you already have
IP capabilities in your device,

00:18:02.590 --> 00:18:04.990
you can carry these into
your FireWire device,

00:18:05.080 --> 00:18:08.020
and the user will have full
access to these services.

00:18:08.020 --> 00:18:13.420
In Mac OS X,
we implement IPv4 and IPv6 in FireWire.

00:18:13.420 --> 00:18:15.020
It fully supports Rendezvous.

00:18:15.020 --> 00:18:18.590
If you have a surfable device,
you can get to it through FireWire.

00:18:18.690 --> 00:18:20.390
No special effort is needed.

00:18:20.390 --> 00:18:22.060
So we're very flexible there.

00:18:22.060 --> 00:18:23.380
Please think about
taking advantage of it.

00:18:23.400 --> 00:18:24.770
that.

00:18:25.990 --> 00:18:27.060
The FireWire family.

00:18:27.060 --> 00:18:29.810
This was the master control layer
that provides all the services.

00:18:29.830 --> 00:18:31.600
Just what are those services?

00:18:31.600 --> 00:18:35.240
First and most important,
when your device gets plugged in,

00:18:35.240 --> 00:18:36.380
we have to find it.

00:18:36.460 --> 00:18:39.660
The family knows how to notice
that a new device is on the bus,

00:18:39.660 --> 00:18:42.790
and the family will ask the device, hey,
what are you?

00:18:42.790 --> 00:18:43.850
Why are you here?

00:18:43.850 --> 00:18:47.220
The family takes these answers
and puts them in the I.O.

00:18:47.220 --> 00:18:49.330
registry,
which is not a FireWire structure.

00:18:49.330 --> 00:18:50.340
It's a general I.O.

00:18:50.340 --> 00:18:51.160
kit service.

00:18:51.160 --> 00:18:51.720
I.O.

00:18:51.930 --> 00:18:57.020
kit then comes along and matches drivers
or protocols to your device based on

00:18:57.020 --> 00:19:00.280
the information that FireWire provided.

00:19:00.280 --> 00:19:02.140
And this process may be iterative.

00:19:02.320 --> 00:19:05.330
Your device might say, well,
I speak the AVC protocol.

00:19:05.330 --> 00:19:09.120
So we would match the AVC layer,
which would then ask your

00:19:09.120 --> 00:19:13.000
device further questions saying,
okay, what kind of subunits do you have?

00:19:13.040 --> 00:19:16.520
Your device might say,
I have a tape subunit, an audio subunit.

00:19:16.520 --> 00:19:18.580
We put that information in the I.O.

00:19:18.580 --> 00:19:21.220
registry as well and then match
further so we can get just the

00:19:21.220 --> 00:19:22.730
right driver for your device.

00:19:24.980 --> 00:19:27.820
On a FireWire bus,
the node IDs may change.

00:19:27.820 --> 00:19:29.010
They're assigned randomly.

00:19:29.190 --> 00:19:31.480
As devices come and go, they may change.

00:19:31.480 --> 00:19:33.830
It's the last thing your
driver wants to deal with.

00:19:33.830 --> 00:19:34.970
No problem.

00:19:34.970 --> 00:19:40.610
Every FireWire device that we can talk to
has a unique serial number called a GUID,

00:19:40.610 --> 00:19:42.140
Global Unique ID.

00:19:42.140 --> 00:19:46.200
The family will track this down,
and it'll follow it around the bus,

00:19:46.200 --> 00:19:49.680
so the family always knows
what node ID your device is on.

00:19:49.680 --> 00:19:52.530
It will automatically send your
driver's packets to your device,

00:19:52.530 --> 00:19:54.310
so you don't have to worry about this.

00:19:57.260 --> 00:20:00.240
On a FireWire bus,
I mentioned you can have mixed speeds.

00:20:00.420 --> 00:20:04.790
Maybe your device does FireWire 800,
but your customer plugged it into

00:20:04.790 --> 00:20:07.100
an iBook that has FireWire 400.

00:20:07.140 --> 00:20:09.300
We don't want your driver
to have to figure that out.

00:20:09.350 --> 00:20:10.480
The family figures that out.

00:20:10.620 --> 00:20:13.050
The family looks at
who's connected to who,

00:20:13.050 --> 00:20:17.600
finds the fastest path between devices,
and automatically routes your traffic

00:20:17.600 --> 00:20:19.590
at the best speed that it can do.

00:20:19.870 --> 00:20:22.680
Also, the family,
having looked at the bus topology,

00:20:22.680 --> 00:20:25.870
can perform an optimization
to tune the bus to make it

00:20:25.890 --> 00:20:27.560
operate as fast as possible.

00:20:27.560 --> 00:20:30.990
Again, something your driver
won't have to worry about.

00:20:31.990 --> 00:20:33.800
Okay, so your device has been discovered.

00:20:33.800 --> 00:20:34.500
It's on the bus.

00:20:34.520 --> 00:20:36.440
We're keeping track of it.

00:20:36.500 --> 00:20:38.500
Now you want to talk to your device.

00:20:40.290 --> 00:20:45.020
The most basic communication on
FireWire is an asynchronous request,

00:20:45.060 --> 00:20:49.540
a read or a write directed at a
memory location in your device.

00:20:49.770 --> 00:20:51.590
The family will do this for you.

00:20:51.680 --> 00:20:54.720
It'll send the packet to your device,
and if your device is

00:20:54.740 --> 00:20:57.620
so kind as to respond,
the family will fish the response

00:20:57.620 --> 00:21:00.180
out from all the traffic on
the bus and hand just that

00:21:00.270 --> 00:21:01.970
response back up to your driver.

00:21:02.150 --> 00:21:06.690
So you don't have to worry about the
other devices that are on the bus.

00:21:08.280 --> 00:21:09.500
You may want to do the reverse.

00:21:09.500 --> 00:21:12.600
Maybe your device will
initiate the communication.

00:21:12.810 --> 00:21:16.620
If so, it needs an address that it
can talk to in the Macintosh.

00:21:16.620 --> 00:21:19.590
So the family will allocate
an address space for you,

00:21:19.590 --> 00:21:21.950
and as packets come in
to that address space,

00:21:21.950 --> 00:21:25.770
it will hand them to your driver and say,
here, do something with this.

00:21:25.770 --> 00:21:27.260
So you can go either way.

00:21:28.950 --> 00:21:34.850
You may want to communicate in real time.

00:21:34.850 --> 00:21:34.850
We'll get to that in a moment.

00:21:35.220 --> 00:21:37.560
The family also publishes
a configuration ROM.

00:21:37.810 --> 00:21:40.990
This is the structure that tells
every device on the bus what you do.

00:21:40.990 --> 00:21:44.740
For a device like an iPod or an iSight,
that function is probably

00:21:44.740 --> 00:21:47.180
locked in at the factory,
so this may truly be a ROM.

00:21:47.200 --> 00:21:50.670
But for a device like a Macintosh,
its capabilities may change as

00:21:50.670 --> 00:21:54.020
new applications are loaded,
new drivers are installed.

00:21:54.020 --> 00:21:56.390
So that's why I put quotes around ROM.

00:22:14.950 --> 00:22:15.090
On the Macintosh,
the configuration ROM really

00:22:15.090 --> 00:22:15.090
comes out of RAM and is
managed by the FireWire family.

00:22:15.090 --> 00:22:15.090
For example, when IO FireWire IP loads,
it says, "Please tell everybody that

00:22:15.090 --> 00:22:15.090
IP services are now available on
this node." So the family puts that

00:22:15.090 --> 00:22:15.090
information in its configuration
ROM and announces it on the bus.

00:22:16.280 --> 00:22:19.800
If you want to communicate in real
time to send or receive streaming data,

00:22:19.850 --> 00:22:22.180
the family manages that for you,
and we'll go into a lot more

00:22:22.230 --> 00:22:23.440
detail about how that works.

00:22:23.440 --> 00:22:27.880
Additionally, the family can get you your
reservations on the bus.

00:22:27.880 --> 00:22:30.610
If you want to reserve bandwidth
for your real-time communication,

00:22:30.620 --> 00:22:32.040
just ask the family.

00:22:32.040 --> 00:22:34.860
It will get the reservation,
and it will keep the reservation

00:22:34.860 --> 00:22:36.640
valid for as long as you're using it.

00:22:39.350 --> 00:22:43.200
Now, there's a second completely
independent implementation

00:22:43.200 --> 00:22:46.280
of FireWire in the Macintosh,
and that's in the boot ROM.

00:22:46.280 --> 00:22:47.130
Why?

00:22:47.130 --> 00:22:50.460
Well, you can boot the computer
from a FireWire disk.

00:22:50.490 --> 00:22:54.070
So somebody has to load
Mac OS X from the disk over FireWire.

00:22:54.150 --> 00:22:55.540
It can't load itself.

00:22:55.540 --> 00:22:57.170
The boot ROM does that.

00:22:57.720 --> 00:22:59.330
You may not do this every day.

00:22:59.450 --> 00:22:59.840
I do.

00:22:59.840 --> 00:23:01.720
But this is very helpful.

00:23:01.720 --> 00:23:05.730
You might need to install Mac OS X on
a lot of different computers,

00:23:05.760 --> 00:23:08.230
say,
in a laboratory or classroom environment.

00:23:08.240 --> 00:23:10.500
Installing from a hard
drive is a lot faster than

00:23:10.500 --> 00:23:12.240
installing from optical media.

00:23:12.240 --> 00:23:16.130
Or you may need to install Mac OS X over
and over and over again if you're testing

00:23:16.170 --> 00:23:20.120
or debugging or checking different
versions and you only have one system.

00:23:20.120 --> 00:23:22.040
FireWire booting is great for this.

00:23:22.040 --> 00:23:23.520
It really speeds things up.

00:23:25.010 --> 00:23:29.300
The other thing that the boot ROM can
do is a service called Target Disk Mode.

00:23:29.610 --> 00:23:32.600
This is where FireWire's peer-to-peer
capability really shines.

00:23:32.600 --> 00:23:36.280
In Target Disk Mode,
the Macintosh will emulate a FireWire

00:23:36.410 --> 00:23:38.740
hard drive completely in software.

00:23:38.740 --> 00:23:41.500
You can then plug it
into a second Macintosh,

00:23:41.500 --> 00:23:45.280
and it will show up on the
desktop as a FireWire hard drive.

00:23:45.920 --> 00:23:48.260
Here, too, you may be wondering,
why would I do this?

00:23:48.260 --> 00:23:51.720
Well, it's a real easy way to move
data quickly between systems.

00:23:51.720 --> 00:23:55.560
It's also a great way to fix up a
system if it's not booting properly.

00:23:55.560 --> 00:23:59.020
If you're developing kernel drivers,
and you've installed a new

00:23:59.020 --> 00:24:02.080
KEXT and rebooted the system,
there is a chance the system

00:24:02.080 --> 00:24:03.600
will crash in your KEXT.

00:24:03.620 --> 00:24:06.440
Well, that makes it very hard to
get your system working again,

00:24:06.440 --> 00:24:09.150
because you can't boot to
Finder and get rid of that KEXT.

00:24:09.180 --> 00:24:09.900
No problem.

00:24:09.960 --> 00:24:13.120
Put the system in Target Disk Mode,
plug it into your other Mac,

00:24:13.120 --> 00:24:15.900
go delete the offending KEXT,
take it out of Target Disk Mode,

00:24:15.900 --> 00:24:15.900
and you're good to go.

00:24:15.900 --> 00:24:16.870
Now it'll boot fine.

00:24:16.870 --> 00:24:18.080
It's a very quick recovery.

00:24:18.180 --> 00:24:20.230
It's a lot better than
reinstalling the OS.

00:24:20.240 --> 00:24:23.550
So two capabilities in the boot
ROM that you may find useful.

00:24:25.010 --> 00:24:29.660
We also have a third completely
independent implementation of FireWire,

00:24:29.660 --> 00:24:32.220
and that's called the
FireWire Reference Platform.

00:24:32.220 --> 00:24:36.560
You may recall that we purchased a
company called Zyante a few years ago,

00:24:36.560 --> 00:24:39.610
and they had a product called TNF1394.

00:24:39.710 --> 00:24:41.460
That's what this is.

00:24:41.460 --> 00:24:46.350
This is software that's designed for
pretty much anything except a computer,

00:24:46.430 --> 00:24:49.640
a peripheral device,
a multifunction device.

00:24:49.640 --> 00:24:52.480
It's a rich,
modular software stack designed

00:24:52.490 --> 00:24:54.820
to run within the limitations
of a real-time software.

00:24:54.920 --> 00:24:57.900
It's a very simple software
that can run on a single device,

00:24:57.900 --> 00:24:59.280
and it's very easy to use.

00:24:59.280 --> 00:25:02.210
You can download the entire
TNF sources from our website.

00:25:02.210 --> 00:25:04.230
They're posted for everyone to use.

00:25:04.230 --> 00:25:07.000
If you want to incorporate
the source in your product,

00:25:07.000 --> 00:25:10.440
you need to sign a license from Apple,
but it's free, no problem.

00:25:11.880 --> 00:25:13.960
The TNF has very rich services.

00:25:13.960 --> 00:25:16.700
It has lots of examples,
what it calls applications,

00:25:16.700 --> 00:25:18.820
which is sort of the heart of
whatever your product does.

00:25:18.820 --> 00:25:21.800
It especially has good AVC services.

00:25:21.800 --> 00:25:25.730
So if you're doing an audio or video
device using the AVC command set,

00:25:25.730 --> 00:25:28.970
there's really rich capabilities here
that could give you a huge head start.

00:25:29.000 --> 00:25:30.450
It's available on the web.

00:25:30.450 --> 00:25:33.320
You can take a look at it and
see if it meets your needs.

00:25:35.300 --> 00:25:37.340
Okay, now that everyone's
well-versed in FireWire,

00:25:37.340 --> 00:25:38.580
let's move on to what's new.

00:25:38.580 --> 00:25:42.980
First, and most importantly, what's new,
you guys have been great.

00:25:42.980 --> 00:25:44.710
You've shipped a ton
of products this year,

00:25:44.710 --> 00:25:46.140
all sorts of innovative things.

00:25:46.140 --> 00:25:48.880
So a big thank you to our developers,
really happy with all

00:25:48.880 --> 00:25:50.020
the stuff we've seen.

00:25:50.060 --> 00:25:53.270
New product I'm sure you've
seen is the iPod Mini,

00:25:53.270 --> 00:25:55.960
but maybe you didn't know it has SPP3.

00:25:55.960 --> 00:25:57.080
What is that?

00:25:57.130 --> 00:26:01.040
It's the same SPP2 that we
use for mass storage devices,

00:26:01.220 --> 00:26:04.480
but it has a new feature
that makes it go faster.

00:26:05.310 --> 00:26:09.620
Let's look at what happens with an
older iPod and a Power Mac as we try to

00:26:09.620 --> 00:26:14.630
read 2K of data from the device using
an operation that has a page table.

00:26:16.950 --> 00:26:18.220
Here's the two devices.

00:26:18.410 --> 00:26:21.280
There's going to be seven packets
exchanged on the FireWire bus

00:26:21.280 --> 00:26:24.840
to complete this operation,
to signal it, to move the data,

00:26:24.840 --> 00:26:26.410
and to indicate that it's done.

00:26:26.420 --> 00:26:28.710
The packets are very efficient,
so this isn't bad.

00:26:28.740 --> 00:26:30.460
We get good performance from this.

00:26:30.460 --> 00:26:32.560
But Fast Start makes
it a little bit better.

00:26:32.560 --> 00:26:35.250
With the new iPod Mini,
that same operation

00:26:35.250 --> 00:26:38.680
takes just three packets,
a 57% improvement.

00:26:38.680 --> 00:26:42.280
This gave us a good performance
improvement we were very happy to have.

00:26:43.060 --> 00:26:46.940
Fast Start in SPP3 has been
supported since Mac OS 10.2.5.

00:26:46.980 --> 00:26:50.580
We encourage you to try it out
in your products if you use SPP2.

00:26:52.960 --> 00:26:55.230
AVC, the Audio Video Command Set.

00:26:55.380 --> 00:26:57.960
We've had support for AVC since day one,
because that first

00:26:58.100 --> 00:26:59.040
product was a camcorder.

00:26:59.050 --> 00:27:01.280
But there's one thing we've
never done quite right,

00:27:01.310 --> 00:27:04.100
and that's a kind of
command called notify.

00:27:04.100 --> 00:27:08.840
The notify command in AVC is
something that may complete later.

00:27:08.840 --> 00:27:11.010
It may complete a lot later.

00:27:11.010 --> 00:27:13.430
You're telling the device,
I expect something to

00:27:13.510 --> 00:27:14.590
happen in the future.

00:27:14.600 --> 00:27:16.040
Please tell me when it does.

00:27:16.040 --> 00:27:20.470
But our API for sending this
kind of command is synchronous.

00:27:20.470 --> 00:27:24.550
So you call this API, saying, hey,
tell me what's going to happen.

00:27:24.550 --> 00:27:26.600
It may be days later
before it returns and says,

00:27:26.600 --> 00:27:27.560
okay, it happened.

00:27:27.560 --> 00:27:29.190
That doesn't really work.

00:27:29.190 --> 00:27:33.740
So we still have the old API,
no change at all there, AVC command,

00:27:33.740 --> 00:27:37.200
lets you send a device out,
send a command out to your device.

00:27:37.200 --> 00:27:39.900
But we have a new service
that's also available.

00:27:39.970 --> 00:27:45.250
You can create an AVC asynchronous
command and assign to it a callback.

00:27:45.330 --> 00:27:48.330
When you submit the command,
it returns right away.

00:27:48.330 --> 00:27:52.080
Later, when the device completes the
notify or sends the status,

00:27:52.080 --> 00:27:53.530
your callback will be called.

00:27:53.540 --> 00:27:55.760
So this is perfect for use
with the notify command.

00:27:55.760 --> 00:27:57.890
You can also use this with
other types of commands,

00:27:57.900 --> 00:27:59.650
but they'll generally
complete right away.

00:28:02.390 --> 00:28:04.430
If you're familiar with our
software development kit,

00:28:04.510 --> 00:28:06.150
you may have seen our MPEG framework.

00:28:06.220 --> 00:28:09.610
It's a pretty rich collection of
services that allow you to stream

00:28:09.630 --> 00:28:11.620
MPEG on FireWire on a Macintosh.

00:28:11.620 --> 00:28:13.690
Well, we've taken that a lot further.

00:28:13.690 --> 00:28:15.700
That was in SDK 19.

00:28:15.730 --> 00:28:18.630
We've extended it and renamed it,
and now it's the

00:28:18.680 --> 00:28:20.620
AVC Video Services Framework.

00:28:21.000 --> 00:28:25.680
What we've done is added DV,
the completely second video format,

00:28:25.680 --> 00:28:29.190
and we've integrated all of
the AVC commands and control

00:28:29.190 --> 00:28:31.670
that are necessary to set up,
discover,

00:28:31.670 --> 00:28:33.690
and maintain these streaming connections.

00:28:33.700 --> 00:28:37.120
So your device, your driver,
doesn't have to worry with these details.

00:28:37.120 --> 00:28:40.080
All in all,
it provides better support than our older

00:28:40.090 --> 00:28:42.530
APIs like the Isochronous Data Handler.

00:28:42.540 --> 00:28:46.440
For example, only with the new framework
can you do DVC Pro HD.

00:28:48.430 --> 00:28:53.390
In writing your applications,
keep in mind this is still a very

00:28:53.410 --> 00:28:55.910
low-level way of talking to your devices.

00:28:55.910 --> 00:28:58.570
Depending on what you're doing,
this may be appropriate.

00:28:58.570 --> 00:29:02.840
However, application software may want
to use higher-level APIs,

00:29:02.880 --> 00:29:04.030
such as QuickTime.

00:29:04.060 --> 00:29:06.310
If you use QuickTime,
you can talk to any kind of video

00:29:06.310 --> 00:29:09.800
device without worrying about whether
it's on FireWire or something else.

00:29:09.800 --> 00:29:12.600
But if it's appropriate,
you can use this framework.

00:29:12.600 --> 00:29:15.300
We know several developers are
already shipping products based on

00:29:15.300 --> 00:29:16.780
the framework that's in the SDK.

00:29:16.810 --> 00:29:19.950
In Tiger,
this will be a private framework,

00:29:19.950 --> 00:29:23.600
but it will continue to be in the SDK,
and you can pick it up there

00:29:23.600 --> 00:29:24.720
and build it into your products.

00:29:24.780 --> 00:29:27.900
We would like to consider
making it a public framework,

00:29:27.900 --> 00:29:29.480
so you can just count on it being there.

00:29:29.480 --> 00:29:31.120
We need to hear from you.

00:29:31.120 --> 00:29:32.720
We want to hear how
you're going to use it,

00:29:32.720 --> 00:29:35.430
how it's going to help your product,
and what you're doing with it.

00:29:35.500 --> 00:29:38.920
That kind of feedback will help us
to take this into a public framework.

00:29:38.940 --> 00:29:41.700
So please take a look at this,
evaluate it for your needs,

00:29:41.710 --> 00:29:42.870
and then let us know.

00:29:46.150 --> 00:29:47.090
Isochronous data.

00:29:47.090 --> 00:29:49.560
We've talked about sending
real-time data on the bus.

00:29:49.560 --> 00:29:52.500
How do you receive this
data in your driver?

00:29:52.500 --> 00:29:55.940
We have a new capability
called Buffer Fill IsocReceive,

00:29:55.940 --> 00:29:58.450
but I haven't really described
how to receive any data,

00:29:58.450 --> 00:30:00.560
or even really said what isochronous is.

00:30:00.560 --> 00:30:01.880
Let's do all three.

00:30:03.220 --> 00:30:06.760
Isochronous literally means equal time.

00:30:06.860 --> 00:30:10.720
So if we take a timeline and
divide it up into equal chunks,

00:30:10.750 --> 00:30:12.220
that's isochronous.

00:30:12.360 --> 00:30:16.440
Then we send the packets on the
bus in these equally spaced cycles.

00:30:16.440 --> 00:30:20.390
Here's six packets going across
the bus at regular intervals.

00:30:21.470 --> 00:30:26.610
The FireWire bus provides these
cycles 8,000 times per second.

00:30:26.880 --> 00:30:30.360
If you're receiving isochronous data,
you probably don't want us calling

00:30:30.360 --> 00:30:33.560
you 8,000 times per second to say,
hey, a new packet arrived.

00:30:33.560 --> 00:30:35.590
Quick, better do something,
because there's another one

00:30:35.590 --> 00:30:36.950
coming in 100 microseconds.

00:30:36.960 --> 00:30:39.830
Isochronous,
whether you're sending or receiving,

00:30:39.830 --> 00:30:41.450
it's about planning ahead.

00:30:41.480 --> 00:30:45.480
What you do is you make a list
of instructions for us in memory

00:30:45.480 --> 00:30:49.870
using an abstract structure
called a data stream control list.

00:30:50.180 --> 00:30:54.110
You give this list to FireWire and say,
here's a plan.

00:30:54.120 --> 00:30:57.420
I want to receive the
next 100 packets as so.

00:30:57.450 --> 00:31:00.310
It might look like this,
a series of instructions,

00:31:00.310 --> 00:31:03.880
each of which says receive one packet,
and here's a little buffer

00:31:03.880 --> 00:31:05.370
to put the packet into.

00:31:05.380 --> 00:31:09.190
Then, when you run this program and
start the isochronous stream,

00:31:09.190 --> 00:31:12.640
the packets flow into the
buffers just like you'd expect.

00:31:12.710 --> 00:31:14.470
This is what we've had all along.

00:31:14.470 --> 00:31:17.520
This can serve any kind of
isochronous reception need.

00:31:17.560 --> 00:31:19.600
But this is not always what you want.

00:31:20.910 --> 00:31:25.360
The particular stream shown here has
packets that are not all the same size.

00:31:25.360 --> 00:31:27.540
This depends on your kind of device.

00:31:27.580 --> 00:31:29.940
Some devices always send
a single size of packet.

00:31:30.190 --> 00:31:31.480
Others may be all over the map.

00:31:31.550 --> 00:31:34.020
In the later case,
you may waste a lot of memory,

00:31:34.020 --> 00:31:36.720
a lot of buffer space,
because if you don't know which

00:31:36.720 --> 00:31:39.840
packet's going to come when,
every buffer has to be big enough

00:31:39.840 --> 00:31:42.060
to hold the largest possible packet.

00:31:43.220 --> 00:31:47.190
The hardware in the industry
standard OHCI provides a way to

00:31:47.190 --> 00:31:50.590
pack the packets together neatly,
and this may be what you want,

00:31:50.590 --> 00:31:52.920
depending on the kind
of data that you have.

00:31:52.920 --> 00:31:55.840
So,
while maintaining the existing services,

00:31:55.840 --> 00:31:58.360
in Tiger,
we're adding a new way to receive

00:31:58.360 --> 00:32:02.000
isochronous data called buffer fill,
which is simpler.

00:32:02.000 --> 00:32:04.920
Here,
we simply have a list of buffer pointers

00:32:04.920 --> 00:32:07.570
and some significantly larger buffers.

00:32:08.320 --> 00:32:08.500
The hardware in the industry
standard OHCI provides a way to

00:32:08.500 --> 00:32:08.660
pack the packets together neatly,
and this may be what you want,

00:32:08.660 --> 00:32:08.760
depending on the kind
of data that you have.

00:32:08.770 --> 00:32:09.460
So,
while maintaining the existing services,

00:32:09.540 --> 00:32:10.720
in Tiger,
we're adding a new way to receive

00:32:10.720 --> 00:32:12.580
isochronous data called buffer fill,
which is simpler.

00:32:12.580 --> 00:32:12.580
Here,
we simply have a list of buffer pointers

00:32:12.580 --> 00:32:12.580
and some significantly larger buffers.

00:32:13.690 --> 00:32:18.270
The hardware in the industry
standard OHCI provides a way to

00:32:18.270 --> 00:32:23.300
pack the packets together neatly,
and this may be what you want,

00:32:23.730 --> 00:32:26.780
depending on the kind
of data that you have.

00:32:26.780 --> 00:32:30.530
So,
while maintaining the existing services,

00:32:30.540 --> 00:32:34.390
in Tiger,
we simply have a list of buffer pointers

00:32:34.390 --> 00:32:37.980
and some significantly larger buffers.

00:32:40.240 --> 00:32:43.190
speaking of DCLs, which is the
Data Stream Control Language for

00:32:43.190 --> 00:32:47.750
sending or receiving packets,
we've made some improvements in Tiger.

00:32:50.410 --> 00:32:53.370
We've cleaned up what happens
when the computer sleeps.

00:32:53.450 --> 00:32:55.310
Isochronous means real time.

00:32:55.510 --> 00:32:58.410
But if you're sending packets
and the computer goes to sleep,

00:32:58.410 --> 00:33:00.060
that's not real time anymore.

00:33:00.120 --> 00:33:02.420
When the computer wakes up,
any packets that you had

00:33:02.560 --> 00:33:03.800
prepared are way out of date.

00:33:04.100 --> 00:33:05.310
Nobody's listening.

00:33:05.310 --> 00:33:06.260
Nobody cares.

00:33:06.270 --> 00:33:09.550
So we used to try to keep sending,
and that was a mistake.

00:33:09.670 --> 00:33:10.670
We've cleaned it up.

00:33:10.680 --> 00:33:12.190
Now we stop your program.

00:33:12.290 --> 00:33:15.620
When the computer wakes up,
we send you a message saying, "Hey,

00:33:15.620 --> 00:33:18.470
your program stopped because
the computer went to sleep.

00:33:18.470 --> 00:33:20.020
You want to start it up again?

00:33:20.020 --> 00:33:23.740
Go right ahead." You should check and
see if your device is still on the bus,

00:33:23.810 --> 00:33:26.180
see if there's anyone listening,
but then go ahead and

00:33:26.200 --> 00:33:27.410
start your program up.

00:33:27.730 --> 00:33:31.420
Every DCL has a callback
known as the force stop proc.

00:33:31.450 --> 00:33:35.120
It gets called if your program is stopped
against your will for some reason,

00:33:35.120 --> 00:33:37.990
such as the computer went to sleep,
or such as you lost your

00:33:38.060 --> 00:33:41.610
isochronous reservation,
which is very rare, but there's a special

00:33:41.630 --> 00:33:43.180
case where it can happen.

00:33:43.180 --> 00:33:46.370
So be sure you hook up this callback,
pay attention to the

00:33:46.380 --> 00:33:49.370
hardware slept message,
then just call stop and start

00:33:49.480 --> 00:33:51.450
to get your stream going again.

00:33:51.460 --> 00:33:54.310
You don't have to tear down your DCL,
just make sure it makes sense,

00:33:54.470 --> 00:33:56.670
fill it in with fresh data,
and get it started again.

00:34:02.000 --> 00:34:04.490
Some kinds of isochronous,
since it's real-time,

00:34:04.490 --> 00:34:07.720
the system may be trying to meet
various real-time deadlines.

00:34:07.740 --> 00:34:11.140
Especially in the case of
receiving audio on FireWire,

00:34:11.140 --> 00:34:13.290
there may be very
high-priority threads running,

00:34:13.290 --> 00:34:15.930
trying to do everything with
the lowest possible latency.

00:34:15.930 --> 00:34:18.530
This may work at
cross-purposes to FireWire,

00:34:18.530 --> 00:34:22.480
because it may hold off the execution
of FireWire's processing of your

00:34:22.480 --> 00:34:24.580
packets that are going in or out.

00:34:24.620 --> 00:34:27.740
So we've added a method you can
call that will directly force

00:34:27.910 --> 00:34:31.320
the update of your program,
regardless of the priority.

00:34:31.680 --> 00:34:34.200
So if you are running on
a high-priority thread,

00:34:34.200 --> 00:34:37.040
and you want FireWire up-to-date,
call this method,

00:34:37.130 --> 00:34:39.730
FireWire will run even if
it's being held off otherwise,

00:34:39.730 --> 00:34:41.430
and your data will be up-to-date.

00:34:41.430 --> 00:34:43.660
The typical case to
do this is with audio.

00:34:43.700 --> 00:34:46.910
We've made further changes.

00:34:51.030 --> 00:34:54.400
If you have a transmit program,
it's common to make changes to

00:34:54.400 --> 00:34:56.000
the program while it's running.

00:34:56.010 --> 00:34:59.930
You can change the size
of the packets on the fly.

00:34:59.930 --> 00:35:03.330
You can change the buffers the
packets come from on the fly.

00:35:03.330 --> 00:35:06.400
You can even rearrange the
program order on the fly.

00:35:06.400 --> 00:35:10.550
This is often done because the programs
typically run either in a loop or in

00:35:10.550 --> 00:35:15.100
a sort of open loop that's constantly
being refreshed with additional data.

00:35:16.410 --> 00:35:18.570
Previously,
if you changed either the length

00:35:18.570 --> 00:35:21.430
or the pointer to a buffer,
it was very inefficient as we

00:35:21.430 --> 00:35:25.220
went through and updated that,
and we've greatly streamlined that.

00:35:25.280 --> 00:35:28.880
So it's much more practical now,
especially if you have a big program,

00:35:28.880 --> 00:35:30.090
to use this technique.

00:35:33.240 --> 00:35:36.900
I mentioned that the callbacks
for audio processing,

00:35:36.900 --> 00:35:39.320
you can have priority problems.

00:35:39.320 --> 00:35:42.970
In addition to the direct service
method you saw on the last slide,

00:35:42.970 --> 00:35:47.040
we have a new capability to assign
a dedicated thread to your DCL.

00:35:47.040 --> 00:35:50.770
If you have multiple DCLs,
this will let you prioritize them

00:35:50.770 --> 00:35:53.160
or prevent deadlocks between them.

00:35:53.160 --> 00:35:56.070
If you're running in the kernel,
you can allocate and create the

00:35:56.110 --> 00:35:59.360
thread of your choosing and set all
the parameters just the way you like,

00:35:59.420 --> 00:36:00.720
then assign it to your DCL.

00:36:00.720 --> 00:36:03.140
On the other hand,
if you're running in user space,

00:36:03.230 --> 00:36:06.820
you can simply set a flag saying
that your DCL should be processed

00:36:06.820 --> 00:36:11.270
on a separate thread so it
doesn't depend on anybody else.

00:36:12.730 --> 00:36:15.600
More isochronous, in a way,
the EyeSight camera.

00:36:15.600 --> 00:36:19.680
It sends audio and video on FireWire,
but no one really knows how the audio

00:36:19.680 --> 00:36:23.010
works because that's not in the spec
that it otherwise complies with.

00:36:23.010 --> 00:36:27.400
The camera complies with
the 1394 Trade Association,

00:36:27.400 --> 00:36:29.680
IIDC, camera specification.

00:36:29.680 --> 00:36:34.060
Apple extended that a little so this
camera would work well with iChat AV.

00:36:34.060 --> 00:36:37.890
We added some video formats that
work well with internet chat,

00:36:37.890 --> 00:36:40.160
and we added an audio capability.

00:36:41.100 --> 00:36:44.710
We have prepared a developer technical
note that explains how these work,

00:36:44.710 --> 00:36:46.830
and some of the other
subtleties of the device,

00:36:46.830 --> 00:36:48.620
like how to find out
if the shutter is open,

00:36:48.640 --> 00:36:51.880
and what's in the config ROM,
and what all those unit directories mean.

00:36:51.910 --> 00:36:54.040
This tech note's about 90% done.

00:36:54.060 --> 00:36:57.780
We hope to have it out to you in the SDK,
or post it on Apple's developer

00:36:57.780 --> 00:37:00.030
support site in the very near future.

00:37:02.550 --> 00:37:04.790
Let's talk about some changes to tools.

00:37:04.850 --> 00:37:07.360
Color Firebug.

00:37:07.360 --> 00:37:08.740
You may be saying, "Hey, I like color.

00:37:08.740 --> 00:37:11.390
That sounds good, but what's Firebug?"

00:37:11.660 --> 00:37:13.960
FireBug is Apple's packet analyzer.

00:37:13.960 --> 00:37:14.800
It's a snooper.

00:37:14.800 --> 00:37:17.840
It requires a special
PCI card or card bus card,

00:37:17.840 --> 00:37:21.300
but it lets you see every
packet on the FireWire bus,

00:37:21.300 --> 00:37:25.100
and this can be tremendously useful
in trying to debug your device.

00:37:25.100 --> 00:37:28.250
FireBug is the poster child
for crude but effective.

00:37:28.340 --> 00:37:31.420
You can see the user
interface is somewhat lacking,

00:37:31.420 --> 00:37:34.850
but it shows you every packet on
the bus and has lots of options

00:37:34.850 --> 00:37:36.910
for how to arrange the data.

00:37:37.840 --> 00:37:41.190
Here, if you're a FireBug whiz,
you can see that it's showing

00:37:41.190 --> 00:37:44.550
operations to an iPod as we read
and write data from the disk,

00:37:44.620 --> 00:37:47.660
but some of you may still not
really see that so clearly.

00:37:47.660 --> 00:37:49.380
Does that help?

00:37:51.020 --> 00:37:55.500
ColorFirebug can colorize the packets
based on various different criteria.

00:37:55.520 --> 00:37:58.700
The goal is to help you quickly
identify what you're looking for.

00:37:58.900 --> 00:38:01.300
Here the packets are
colored based on their type:

00:38:01.380 --> 00:38:04.900
reads, writes, blocks, quadlets,
requests, responses.

00:38:04.900 --> 00:38:07.200
Each one has a different color.

00:38:07.200 --> 00:38:13.000
You can color based on the packet speed,
based on the sender ID, the target ID,

00:38:13.100 --> 00:38:16.490
the isochronous channel,
the acknowledge code.

00:38:16.650 --> 00:38:19.360
Depending on what you're looking for,
this may make it jump out.

00:38:19.360 --> 00:38:21.690
If you've got one packet
that's at the wrong speed,

00:38:21.690 --> 00:38:24.350
it's real easy to spot one
red line in a field of blue,

00:38:24.350 --> 00:38:27.200
then it goes through trying to read
all of the digits and the speed codes.

00:38:27.200 --> 00:38:30.600
So if you use Firebug,
download the latest SDK.

00:38:30.600 --> 00:38:32.660
This is in Firebug 1.9.

00:38:32.710 --> 00:38:33.760
Try it out.

00:38:35.670 --> 00:38:38.120
We've also enhanced our FireStarter tool.

00:38:38.200 --> 00:38:41.420
This is a tool that was designed
primarily for FireWire plug fests,

00:38:41.480 --> 00:38:44.200
or anywhere that you have a lot
of FireWire devices connected

00:38:44.200 --> 00:38:45.820
together on one FireWire bus.

00:38:45.820 --> 00:38:50.430
It uses the same code as FireBug
for displaying the bus topology

00:38:50.430 --> 00:38:54.020
there on the right-hand side
in a simple ASCII rendition

00:38:54.020 --> 00:38:55.860
showing what's connected to what.

00:38:55.900 --> 00:38:59.380
This is based on receiving the self IDs,
and no special hardware

00:38:59.380 --> 00:39:01.600
is required for that,
so this tool can run

00:39:01.680 --> 00:39:03.120
on any of our products.

00:39:04.290 --> 00:39:07.320
FireStarter also sorts all the self
IDs and tells you things like how

00:39:07.320 --> 00:39:09.130
many nodes are running at each speed.

00:39:09.200 --> 00:39:12.580
FireStarter 1.4 has some improvements.

00:39:12.620 --> 00:39:15.360
In particular,
there's an options menu that lets

00:39:15.360 --> 00:39:16.870
you select several different things.

00:39:16.900 --> 00:39:21.020
You can configure some subtle details
about the role FireStarter will

00:39:21.070 --> 00:39:23.270
play on the bus in bus management.

00:39:23.300 --> 00:39:27.900
You can ask FireStarter to announce
itself to FireBug by sending a

00:39:27.980 --> 00:39:30.300
packet after every bus reset to say,
"Hey, I'm here.

00:39:30.300 --> 00:39:32.360
I'm on node 7."

00:39:32.800 --> 00:39:36.540
You can even ask FireStarter to play the
system beep sound on every bus reset if

00:39:36.540 --> 00:39:38.140
you need to know these are happening.

00:39:38.140 --> 00:39:42.220
And finally, there's a new display mode
that shows the raw self IDs.

00:39:42.220 --> 00:39:43.940
When would you use this?

00:39:43.940 --> 00:39:47.440
Well, if you have a really
low-level problem in FireWire,

00:39:47.440 --> 00:39:50.100
the self ID sequence may
not complete properly.

00:39:50.100 --> 00:39:53.840
A defective hub or an out-of-spec
cable may cause some kind of problem

00:39:53.840 --> 00:39:55.780
where the self IDs get messed up.

00:39:55.880 --> 00:39:58.660
In which case,
FireStarter can't make sense of them,

00:39:58.670 --> 00:40:00.800
and it won't even try to draw the tree.

00:40:00.800 --> 00:40:02.560
It'll just show you a blank page.

00:40:02.560 --> 00:40:05.900
So select this new option,
and the page changes to show

00:40:05.900 --> 00:40:09.960
the hex values of all the self
ID packets exactly as they came in.

00:40:10.000 --> 00:40:12.490
This will help you figure
out what's going on.

00:40:12.520 --> 00:40:15.480
Also, we like color so much,
we added some here, too.

00:40:15.480 --> 00:40:18.110
If there's a bus reset,
FireStarter will tell you about that,

00:40:18.210 --> 00:40:19.150
too, just like that.

00:40:21.380 --> 00:40:22.720
Some other tool updates.

00:40:22.760 --> 00:40:26.330
We have a tool called FiTool that we
described in great detail last year.

00:40:26.470 --> 00:40:30.440
It lets you view and edit the
registers in the Fi in the Macintosh,

00:40:30.440 --> 00:40:33.820
and you can view these registers
on other nodes on the FireWire bus.

00:40:33.820 --> 00:40:36.960
FiTool 1.7 has some
important new features.

00:40:36.960 --> 00:40:39.720
Among other things,
it properly supports Panther and Tiger.

00:40:39.730 --> 00:40:41.520
There's no user interface problems.

00:40:41.520 --> 00:40:44.880
And it has some important bug fixes,
especially if you were

00:40:44.880 --> 00:40:46.450
changing Fi registers.

00:40:46.470 --> 00:40:49.230
The earlier versions would
change a little bit too much,

00:40:49.340 --> 00:40:50.880
so you might get confused.

00:40:50.980 --> 00:40:52.550
It won't break anything,
but you might really

00:40:52.550 --> 00:40:53.480
wonder what's going on.

00:40:53.520 --> 00:40:56.580
If you're using FiTool,
please be sure to get version 1.7.

00:40:58.060 --> 00:41:00.040
Vigilante is a new tool in our SDK.

00:41:00.040 --> 00:41:02.400
It really doesn't have
anything to do with FireWire,

00:41:02.400 --> 00:41:05.300
but it tracks memory allocations
for objects in the kernel,

00:41:05.300 --> 00:41:08.060
and we used it recently to
track down a big memory leak in

00:41:08.060 --> 00:41:09.800
the Tiger version of FireWire.

00:41:09.800 --> 00:41:12.060
It was so effective, we said, hey,
this is great.

00:41:12.060 --> 00:41:13.100
Let's put it in the SDK.

00:41:13.100 --> 00:41:14.370
We'll let everybody use it.

00:41:14.370 --> 00:41:15.220
So give this a try.

00:41:15.220 --> 00:41:16.480
It's another good tool.

00:41:19.560 --> 00:41:23.170
Another capability we've never talked
about before is the ability to put

00:41:23.320 --> 00:41:27.940
debug information in the I/O registry
when you're working with FireWire.

00:41:28.060 --> 00:41:29.000
What is this?

00:41:29.000 --> 00:41:31.440
This is kind of like a dynamic printf.

00:41:31.610 --> 00:41:34.400
Rather than logging out
information constantly,

00:41:34.450 --> 00:41:37.300
you can arrange to grab
information from your driver at

00:41:37.300 --> 00:41:39.000
exactly the moment of interest.

00:41:39.120 --> 00:41:41.570
This is really flexible,
although it's a little

00:41:41.570 --> 00:41:43.000
complicated to set up.

00:41:43.010 --> 00:41:46.500
If you get FireWire
SDK 19 and you install it,

00:41:46.500 --> 00:41:49.500
you can then navigate down
through the folders as shown here.

00:41:49.670 --> 00:41:52.180
And for the different
versions of FireWire,

00:41:52.180 --> 00:41:55.790
there are installer packages
that will install new FireWire

00:41:55.790 --> 00:41:57.500
KEXTs into your system.

00:41:57.510 --> 00:42:00.350
Choose the package that
has "debug" in the name,

00:42:00.400 --> 00:42:02.500
and it has a few special tricks.

00:42:02.500 --> 00:42:05.040
After you've installed
this package and rebooted,

00:42:05.040 --> 00:42:08.450
you'll be running with a slightly
different version of FireWire.

00:42:08.660 --> 00:42:11.590
Look in the Applications
folder in the SDK,

00:42:11.590 --> 00:42:14.680
and you'll find a tool called MrRegistry.

00:42:14.680 --> 00:42:18.040
This is a browser that our
team produced that can look at

00:42:18.040 --> 00:42:20.440
properties in the I/O registry.

00:42:20.440 --> 00:42:22.800
If you look down towards the bottom,
as marked in orange,

00:42:22.800 --> 00:42:24.460
you find the FireWire controller.

00:42:24.510 --> 00:42:28.600
Pick that and show the properties,
and you'll notice something new.

00:42:28.870 --> 00:42:32.320
Marked in orange on the right
is a property called DebugInfo.

00:42:32.420 --> 00:42:34.010
That's not usually there.

00:42:34.120 --> 00:42:37.210
That's added by the debug
build of the extensions.

00:42:37.350 --> 00:42:38.110
So open that up.

00:42:38.110 --> 00:42:41.880
It has some information about
the isochronous DMA contexts.

00:42:41.950 --> 00:42:43.940
This is pretty low-level stuff.

00:42:44.190 --> 00:42:45.840
Why would you use this?

00:42:45.940 --> 00:42:48.490
Suppose you're transmitting
isochronous on FireWire.

00:42:48.490 --> 00:42:52.430
It's pretty easy to use FireBug to see
the packets are going out across the bus.

00:42:52.490 --> 00:42:54.360
You know your transmitter is working.

00:42:54.410 --> 00:42:55.700
Receive is another story.

00:42:55.700 --> 00:42:58.710
Your device may be sending packets in,
FireBug shows them,

00:42:58.710 --> 00:43:01.200
but they don't seem to be
making it to your driver.

00:43:01.320 --> 00:43:03.360
You don't even know if
the Mac is listening.

00:43:03.410 --> 00:43:05.000
Here's a technique that can
give you a bit of a hint.

00:43:05.000 --> 00:43:05.500
a clue.

00:43:06.710 --> 00:43:10.220
I just happen to know that my
receiver is running on context 2,

00:43:10.490 --> 00:43:14.050
but there's only 8, so it shouldn't take
you too long to find.

00:43:17.280 --> 00:43:20.040
Open up Context 2,
and you can see direct information

00:43:20.040 --> 00:43:23.640
about the OHCI controller,
its command pointer,

00:43:23.870 --> 00:43:25.010
and its command state.

00:43:25.060 --> 00:43:29.470
If you refer to the OHCI spec,
you can see that that state, 8431,

00:43:29.470 --> 00:43:32.600
indicates the DMA is running,
it's active,

00:43:32.600 --> 00:43:35.770
and it records event complete,
meaning it has received

00:43:35.770 --> 00:43:36.850
at least one packet.

00:43:36.860 --> 00:43:38.120
So that's a good sign.

00:43:38.140 --> 00:43:38.840
We're getting somewhere.

00:43:40.180 --> 00:43:41.400
But maybe that's all that happened.

00:43:41.400 --> 00:43:43.740
It received one packet, it stopped,
and now your application

00:43:43.740 --> 00:43:45.360
is not getting anything.

00:43:45.440 --> 00:43:47.010
What more can we learn?

00:43:47.280 --> 00:43:48.680
Look at the part marked in orange.

00:43:48.950 --> 00:43:50.700
That's the command pointer.

00:43:50.700 --> 00:43:54.460
This shows where in the
DMA program the DMA is executing.

00:43:54.720 --> 00:43:57.890
Well, press the refresh button,
and it changed.

00:43:57.890 --> 00:43:59.230
Another good sign.

00:43:59.230 --> 00:44:01.910
This means the DMA right
now is still running,

00:44:01.970 --> 00:44:05.020
it's receiving packets,
it's doing something with them.

00:44:05.090 --> 00:44:07.740
So everything looks
very good at this point.

00:44:08.440 --> 00:44:09.740
This is pretty esoteric stuff.

00:44:09.840 --> 00:44:12.050
Not everybody's going to need
to dig down in here to see if

00:44:12.160 --> 00:44:13.280
their DMA is running or not.

00:44:13.340 --> 00:44:17.250
But the point is,
this gave you a real-time printf.

00:44:17.280 --> 00:44:20.730
Rather than constantly logging
information about what it's doing,

00:44:20.730 --> 00:44:23.570
you were able to reach in and
look just when you wanted to and

00:44:23.570 --> 00:44:25.440
see a key piece of information.

00:44:25.820 --> 00:44:30.480
The way this works is that
the property that's created in

00:44:30.480 --> 00:44:34.770
IO Registry has a callback that says,
when you need the value for this,

00:44:34.770 --> 00:44:36.050
just call me and I'll tell you.

00:44:36.050 --> 00:44:36.910
When Mr.

00:44:36.910 --> 00:44:41.420
Registry asks,
up-to-date information is provided.

00:44:41.420 --> 00:44:45.340
You can do this in your driver to
see almost any kind of information.

00:44:45.340 --> 00:44:47.700
There's examples in our source code.

00:44:47.700 --> 00:44:50.980
Get the SDK and look in the
source code for the IP driver

00:44:50.980 --> 00:44:54.760
or the SPP2 service layer,
and you can see how to do this.

00:44:58.150 --> 00:45:01.520
Another capability we
haven't talked about before:

00:45:01.520 --> 00:45:03.380
debugging with FireLog.

00:45:03.380 --> 00:45:05.800
This is not new,
but we've never explained how it works,

00:45:05.890 --> 00:45:07.440
and we'd like you to give it a try.

00:45:07.440 --> 00:45:09.730
This is one of the oldest
techniques in the book.

00:45:09.730 --> 00:45:12.020
You take two systems,
you run on one of them,

00:45:12.210 --> 00:45:14.700
you use the other to look
and see what's going on.

00:45:14.700 --> 00:45:17.510
So your driver is running on the G5.

00:45:17.790 --> 00:45:22.120
FireLog creates a buffer in memory
where your driver can log some messages.

00:45:22.120 --> 00:45:24.510
The other system is
connected by FireWire,

00:45:24.570 --> 00:45:27.570
and it runs an application
that can view these messages.

00:45:27.590 --> 00:45:31.270
So your driver runs along,
recording information.

00:45:31.310 --> 00:45:33.820
This all shows up in the other Mac.

00:45:33.820 --> 00:45:34.600
Pretty basic stuff.

00:45:34.810 --> 00:45:37.600
You could do this with a serial port,
you could do this with Ethernet.

00:45:37.600 --> 00:45:39.360
Why do this with FireWire?

00:45:39.480 --> 00:45:41.800
Well, there's a difference.

00:45:42.220 --> 00:45:46.420
This system uses the physical DMA,
just like the iPod that you saw before.

00:45:46.420 --> 00:45:47.970
What does that mean?

00:45:47.970 --> 00:45:53.270
When your driver logs a message,
it's nothing but a sprint F into memory.

00:45:53.270 --> 00:45:54.790
There's no I.O.

00:45:54.800 --> 00:45:57.060
You don't have to call
the Ethernet driver,

00:45:57.060 --> 00:45:58.500
the serial port driver.

00:45:58.500 --> 00:46:00.580
No interrupts, no context switches.

00:46:00.580 --> 00:46:02.300
It's extremely lightweight.

00:46:02.300 --> 00:46:05.610
Going through other I.O.s could add
variables to what's happening on the

00:46:05.610 --> 00:46:07.360
system that you're trying to debug.

00:46:07.360 --> 00:46:10.910
This is not likely to change very
much on the system you're debugging.

00:46:13.040 --> 00:46:15.470
Suppose your driver is in the kernel.

00:46:15.530 --> 00:46:17.080
Suppose your driver panics.

00:46:17.080 --> 00:46:18.460
It happens.

00:46:18.460 --> 00:46:21.810
Even worse, suppose your driver hangs and
doesn't have the good grace to panic.

00:46:21.840 --> 00:46:26.400
Well, you may not be able to get the very
last message that it wanted to log.

00:46:26.410 --> 00:46:29.480
If you're logging in the system log
or on a serial port or Ethernet,

00:46:29.480 --> 00:46:32.830
you may have panicked before that
message really got all the way out.

00:46:33.540 --> 00:46:35.150
No problem with FireLog.

00:46:35.150 --> 00:46:38.340
The physical DMA does
not depend on the CPU.

00:46:38.340 --> 00:46:41.810
Even if the machine has panicked,
the remote machine can reach in,

00:46:41.830 --> 00:46:44.260
look at the buffer,
and see what's there and get

00:46:44.260 --> 00:46:47.760
the very last message that your
driver logged before it died.

00:46:47.760 --> 00:46:49.800
And odds are,
that's the one you want to see.

00:46:49.800 --> 00:46:52.900
So this is a really unique
capability on FireWire.

00:46:52.900 --> 00:46:54.020
Give this a try.

00:46:54.020 --> 00:46:55.970
This is a bit tricky to set up.

00:46:55.970 --> 00:46:57.730
There's two ways to do it.

00:46:57.790 --> 00:47:01.480
You can rebuild the FireWire
family to turn on FireLog,

00:47:01.480 --> 00:47:03.520
or you can install the debug.

00:47:03.520 --> 00:47:07.220
Like you saw on the previous slide,
where this should already be turned on.

00:47:07.220 --> 00:47:09.090
But we're trying to make this easier.

00:47:09.090 --> 00:47:11.860
We hope to provide a KEXT that
you can drop into any version of

00:47:11.990 --> 00:47:14.890
FireWire that will automatically
make FireLog available.

00:47:14.890 --> 00:47:15.930
Take a look in the SDK.

00:47:16.070 --> 00:47:18.670
There's instructions for
how to get this set up.

00:47:20.860 --> 00:47:22.960
Okay,
let's quickly review FireWire resources.

00:47:23.030 --> 00:47:25.660
We've got a lot of great stuff for
you developers in addition to the

00:47:25.660 --> 00:47:27.660
tools and code that you saw here.

00:47:27.740 --> 00:47:30.680
I keep mentioning the SDK,
our software development kit.

00:47:30.700 --> 00:47:33.060
It's available on the
web for free download.

00:47:33.060 --> 00:47:35.360
We've made 19 of these since
we started on Mac OS X,

00:47:35.360 --> 00:47:37.620
and of course we're hard
at work on number 20.

00:47:37.620 --> 00:47:42.410
SDK has lots of source code, sample code,
application stuff, kernel stuff,

00:47:42.420 --> 00:47:44.310
great place to get started.

00:47:45.750 --> 00:47:49.920
Often, the SDK has advanced versions
of FireWire software.

00:47:49.920 --> 00:47:52.520
If we've made some fixes
or added some features,

00:47:52.520 --> 00:47:55.810
we can use the SDK to get those
out to you so you can try them

00:47:55.810 --> 00:47:57.780
out before your customers do.

00:47:57.780 --> 00:47:59.040
You can let us know if they work.

00:47:59.160 --> 00:48:01.040
You can let us know
what we need to change.

00:48:01.040 --> 00:48:03.840
All of the tools that you saw
are all built into the SDK,

00:48:03.840 --> 00:48:06.380
and there's various
notes and documentation.

00:48:06.380 --> 00:48:07.660
There's a lot of stuff.

00:48:07.660 --> 00:48:09.240
We've had 19 spins on it.

00:48:09.240 --> 00:48:11.270
We've really put a lot in there.

00:48:11.270 --> 00:48:12.060
Pick this up.

00:48:12.060 --> 00:48:13.380
It's on our SDK website.

00:48:13.380 --> 00:48:14.730
It's really easy to get.

00:48:17.010 --> 00:48:19.000
We have some public mailing lists.

00:48:19.140 --> 00:48:21.360
There's a main list for FireWire.

00:48:21.470 --> 00:48:24.770
Any kind of Mac OS X FireWire
development questions are welcome.

00:48:24.770 --> 00:48:27.060
We will try to answer,
and often developers answer

00:48:27.060 --> 00:48:29.130
each other's questions,
which is great.

00:48:29.160 --> 00:48:32.190
There's a second mailing list
for the reference platform,

00:48:32.190 --> 00:48:35.820
where there's some very specific
discussion about porting to specific

00:48:35.820 --> 00:48:39.350
real-time operating systems,
specific hardware interfaces.

00:48:39.350 --> 00:48:41.450
That's another active list.

00:48:42.310 --> 00:48:45.170
There's a third list a lot
of you may want to visit,

00:48:45.170 --> 00:48:47.180
which is the ATA and SCSI list.

00:48:47.220 --> 00:48:48.810
Why would you go there?

00:48:48.820 --> 00:48:52.940
A lot of FireWire devices that
use SPP2 have a SCSI architecture

00:48:53.290 --> 00:48:56.480
in their command set,
even though they may have

00:48:56.480 --> 00:48:58.510
no actual SCSI hardware.

00:48:58.520 --> 00:49:02.780
If you're talking to that kind of device,
most likely the easiest way to do it

00:49:02.780 --> 00:49:06.920
is through the SCSI task user client
provided by our mass storage team.

00:49:07.000 --> 00:49:10.800
Support for that interface is
discussed on this mailing list.

00:49:11.580 --> 00:49:13.500
For all of these,
you can subscribe at one common

00:49:13.500 --> 00:49:15.030
place on Apple's developer site.

00:49:15.060 --> 00:49:16.080
It's very easy to do.

00:49:19.280 --> 00:49:22.340
Apple owns the FireWire trademark,
but we're not very selfish about it.

00:49:22.410 --> 00:49:24.140
Use this on your products.

00:49:24.150 --> 00:49:26.650
Your customer wants to know
the product has FireWire.

00:49:26.650 --> 00:49:28.780
Put this on the product,
put this on the box,

00:49:28.780 --> 00:49:30.980
put this in the marketing,
on the web page.

00:49:30.980 --> 00:49:32.030
Go nuts.

00:49:32.100 --> 00:49:35.330
Just license it from us,
and do be sure to use it correctly.

00:49:35.330 --> 00:49:37.930
If you license it from us,
you'll get high-quality artwork,

00:49:37.960 --> 00:49:38.930
so you won't mess it up.

00:49:39.860 --> 00:49:43.050
There's another logo that shows your
product has passed the compliance

00:49:43.050 --> 00:49:45.540
testing from the 1394 Trade Association.

00:49:45.540 --> 00:49:48.700
This one you can't get from
Apple because we don't run those tests.

00:49:48.700 --> 00:49:52.330
Attend one of the 1394 TA events,
or send your products in

00:49:52.330 --> 00:49:55.040
to one of their vendors,
and have them tested.

00:49:55.040 --> 00:49:57.720
You can get tremendously
useful information about your

00:49:57.720 --> 00:50:00.840
product from this testing,
and we send a lot of our products in.

00:50:00.840 --> 00:50:02.420
We always learn something new.

00:50:02.420 --> 00:50:04.090
This is a really good program.

00:50:06.430 --> 00:50:07.340
Okay, a little bit more.

00:50:07.340 --> 00:50:09.940
If you'd like to talk
to Apple about FireWire,

00:50:09.940 --> 00:50:12.420
Craig Keithley,
who will be up here for Q&A,

00:50:12.480 --> 00:50:15.210
our main contact,
or if you're located in Asia,

00:50:15.210 --> 00:50:19.200
you're welcome to contact
Stephen Chick in our Japan office.

00:50:19.200 --> 00:50:22.550
Or if you're not sure who to talk to,
just write to FireWire at Apple.com,

00:50:22.550 --> 00:50:23.920
and we'll find somebody.

00:50:26.000 --> 00:50:29.140
In the reference library
on Apple's ADC website,

00:50:29.300 --> 00:50:31.270
FireWire itself,
we have some basic information

00:50:31.310 --> 00:50:33.060
about the technology.

00:50:33.110 --> 00:50:36.500
There's a substantial document for
working with FireWire device interfaces.

00:50:36.500 --> 00:50:39.940
This is the user client I talked
about earlier that lets you talk

00:50:39.940 --> 00:50:43.430
to FireWire from an application
or from a plug-in that's running

00:50:43.440 --> 00:50:45.610
in the context of an application.

00:50:46.280 --> 00:50:49.300
Apple publishes developer notes
for each of our CPU platforms.

00:50:49.310 --> 00:50:50.680
They're quite detailed.

00:50:50.750 --> 00:50:53.180
They will tell you how many
FireWire ports there are,

00:50:53.180 --> 00:50:56.920
if it's FireWire 400 or 800,
how much power is provided,

00:50:57.050 --> 00:51:00.270
what's the internal
architecture of that system.

00:51:00.460 --> 00:51:03.360
Lots of valuable information there,
so please take a look.

00:51:03.360 --> 00:51:06.180
Finally,
if you do have to write in the kernel,

00:51:06.240 --> 00:51:09.060
there's a starter document,
Device Driver Fundamentals.

00:51:09.060 --> 00:51:10.940
It's not specific to FireWire.

00:51:11.080 --> 00:51:12.280
Take a look at that.

00:51:12.280 --> 00:51:14.550
That should get you up and running.

00:51:15.320 --> 00:51:17.630
We have a good tech note on DCL programs.

00:51:17.800 --> 00:51:20.000
If you're going to be sending
or receiving isochronous data,

00:51:20.000 --> 00:51:22.430
take a look at this technical note.

00:51:22.600 --> 00:51:25.440
For sample code, there's some basic
sample code for FireWire,

00:51:25.440 --> 00:51:29.240
SCSI, and general mass storage posted
on the ADC website independently,

00:51:29.330 --> 00:51:32.040
and then there's a good deal
more in our FireWire SDK,

00:51:32.050 --> 00:51:33.440
as I discussed before.

00:51:35.620 --> 00:51:38.000
Since you're here at WWDC,
there's two more things

00:51:38.000 --> 00:51:38.810
you should know about.

00:51:38.860 --> 00:51:43.140
Tomorrow and Thursday,
we will have Firewire engineers

00:51:43.140 --> 00:51:45.570
in the IO Technology Lab.

00:51:45.580 --> 00:51:49.880
If you go out these doors, turn left,
it's right down the hall at the end.

00:51:49.880 --> 00:51:52.460
We'll be happy to take
your walk-in questions.

00:51:52.460 --> 00:51:53.950
We can demonstrate the tools.

00:51:53.960 --> 00:51:55.260
We'll try to debug your code.

00:51:55.260 --> 00:51:56.720
Come on by and see us.

00:51:56.730 --> 00:51:58.450
Tomorrow, we'll be there from 9 a.m.

00:51:58.450 --> 00:52:02.360
to 6.30, except during the Firewire
feedback forum in the afternoon.

00:52:03.020 --> 00:52:04.820
And on Thursday,
we'll be there from 9 a.m.

00:52:04.820 --> 00:52:07.250
to 5, and then we'll all leave
for the other event,

00:52:07.260 --> 00:52:11.040
which is the ADC Plugfest
at the Apple Campus Bash.

00:52:11.040 --> 00:52:14.100
So on Thursday,
we will have a bunch of Firewire

00:52:14.100 --> 00:52:17.130
devices that you all brought,
and we'll connect them

00:52:17.130 --> 00:52:18.260
together in one big bus.

00:52:18.260 --> 00:52:22.090
And you'll get to see, for example,
Firestarter in operation and see

00:52:22.120 --> 00:52:24.960
what happens when there's lots
of devices all sharing the bus.

00:52:24.960 --> 00:52:27.780
A lot of the devices we already have,
but you're still welcome

00:52:27.870 --> 00:52:29.620
to walk in with more,
and we'll plug them in

00:52:29.620 --> 00:52:30.520
and see what happens.

00:52:30.520 --> 00:52:32.950
We'll have more engineers,
more opportunity to try.

00:52:33.000 --> 00:52:34.530
Try the tools or ask questions.

00:52:34.580 --> 00:52:38.310
That's Thursday evening from the start
of the Campus Bash until the close.
WEBVTT

00:00:13.610 --> 00:00:15.300
Good afternoon.

00:00:15.380 --> 00:00:22.340
Welcome to the second day of WWDC.

00:00:22.340 --> 00:00:24.820
My name is Derek Clegg,
and I'm a Quartz engineer.

00:00:24.820 --> 00:00:28.000
I've been working in Quartz
for quite some time now,

00:00:28.120 --> 00:00:29.180
hence my title.

00:00:29.180 --> 00:00:34.340
Today I'm going to talk about the new
things that we've added to Tiger to help

00:00:34.340 --> 00:00:37.090
you as a developer do more cool stuff.

00:00:37.090 --> 00:00:40.030
In addition,
we're going to have my colleague

00:00:40.030 --> 00:00:44.450
John Burkey come up for the second
half to show you more about Quartz

00:00:44.500 --> 00:00:48.220
2D and how it's actually leveraging
the Quartz Extreme part of the

00:00:48.220 --> 00:00:49.740
system to do even more cool stuff.

00:00:49.740 --> 00:00:52.280
And then along the way we're
going to have a number of demos.

00:00:54.000 --> 00:00:57.910
So the first thing that you, of course,
need to remember, as we've emphasized

00:00:57.910 --> 00:01:00.960
already in other sessions,
is that our focus in

00:01:00.960 --> 00:01:02.920
Mac OS X is Quartz 2D.

00:01:02.920 --> 00:01:04.100
It's no longer Quick Draw.

00:01:04.100 --> 00:01:08.200
Quick Draw is a great technology,
served us really well for 20 years.

00:01:08.200 --> 00:01:09.390
It's crystals going dark.

00:01:09.530 --> 00:01:11.580
It's time to sort of move to Quartz 2D.

00:01:11.580 --> 00:01:15.920
And so we really want you to think
toward doing that if you haven't already.

00:01:15.920 --> 00:01:18.330
And of course, if you have done that,
we certainly want to continue supporting

00:01:18.330 --> 00:01:21.990
you and making more and more stuff
part of Quartz 2D to help you out.

00:01:22.680 --> 00:01:26.920
There's a special session on Friday at 2,
transitioning to Quartz 2D,

00:01:26.920 --> 00:01:28.940
which will go into this in more
depth and help those of you

00:01:29.050 --> 00:01:31.620
who haven't already started the
transition make the transition.

00:01:33.380 --> 00:01:37.120
Now, I'm also not going to talk today too
much about the details of Quartz2D,

00:01:37.120 --> 00:01:40.080
the architecture, the basic types,
how all that fits together.

00:01:40.080 --> 00:01:43.070
There's a session that I gave
last year at WWDC that talks a

00:01:43.070 --> 00:01:46.600
lot about all of that information,
so you can certainly pick up

00:01:46.600 --> 00:01:48.200
the DVD and check that out.

00:01:48.260 --> 00:01:50.410
And in addition,
perhaps more importantly,

00:01:50.410 --> 00:01:53.030
this year we've added a lot
of really great documentation.

00:01:53.040 --> 00:01:56.620
There's some brand new stuff that's
all about drawing with Quartz2D,

00:01:56.620 --> 00:02:00.070
the transition to Quartz2D,
there's a full reference of all the APIs,

00:02:00.160 --> 00:02:01.310
and there's a lot more.

00:02:01.520 --> 00:02:05.270
So if you have any issues like that,
sort of basic understanding,

00:02:05.270 --> 00:02:07.820
I really urge you to go
to the documentation,

00:02:08.000 --> 00:02:11.360
it's great, and of course,
check out the DVD last year as well.

00:02:11.360 --> 00:02:15.020
So my focus today is going to be all
the new APIs that we've added in Tiger,

00:02:15.020 --> 00:02:18.200
sort of the new things that
are coming down the road that

00:02:18.200 --> 00:02:20.170
you can expect to start using.

00:02:20.180 --> 00:02:24.050
Now just though,
to give you some context,

00:02:24.050 --> 00:02:28.210
we have a CG context,
is the basic type in Quartz2D,

00:02:28.210 --> 00:02:30.040
that's what everything
uses to do drawing.

00:02:30.040 --> 00:02:32.420
So CG context is sort of... I'm
going to go back to the coin

00:02:32.450 --> 00:02:33.520
of the realm in a certain way.

00:02:33.520 --> 00:02:39.020
It's by nature, by its architecture,
device independent.

00:02:39.020 --> 00:02:41.430
What that means is that
you use a CG context if

00:02:41.520 --> 00:02:44.870
you're talking to a printer,
or to the screen, or to a bitmap,

00:02:44.870 --> 00:02:47.400
sort of the same basic type
for all of those things.

00:02:47.420 --> 00:02:49.570
So it sort of abstracts the
drawing environment for you.

00:02:49.580 --> 00:02:52.170
In addition, very importantly,
it's resolution independent.

00:02:52.180 --> 00:02:56.640
Use a CG context with the
same APIs to draw to a 100

00:02:56.770 --> 00:03:00.550
DPI screen or a 1600 DPI printer.

00:03:01.520 --> 00:03:03.460
And in addition, it's stateful.

00:03:03.460 --> 00:03:04.500
It maintains state for you.

00:03:04.500 --> 00:03:07.950
It has what we call the graphic state,
which is things like the color,

00:03:08.070 --> 00:03:12.120
what color you're going to fill shape in,
or whether your line is dashed or not,

00:03:12.120 --> 00:03:13.190
things like that.

00:03:13.280 --> 00:03:16.390
And most of the APIs in Quartz take
a CG context and work with that.

00:03:18.280 --> 00:03:20.860
So what are the new APIs that
we're going to be adding for Tiger?

00:03:20.930 --> 00:03:23.440
Well,
there are going to be some new drawing

00:03:23.440 --> 00:03:27.200
APIs that work with CG context directly,
a new thing, a layer API,

00:03:27.200 --> 00:03:30.450
which is sort of a more
efficient representation of

00:03:30.450 --> 00:03:34.250
off-screen bitmap drawing,
and some new PDF input and

00:03:34.250 --> 00:03:38.420
output APIs for those of you
who are used to using those.

00:03:38.570 --> 00:03:39.850
Okay,
so this is sort of the list of what I'm

00:03:39.850 --> 00:03:41.630
going to cover for the drawing APIs.

00:03:41.660 --> 00:03:43.690
There's a lot of things,
so let's just go into

00:03:43.930 --> 00:03:46.050
each one independently.

00:03:46.280 --> 00:03:48.690
So the first is a new clipping API.

00:03:48.720 --> 00:03:52.440
The idea here,
very straightforward concept.

00:03:52.440 --> 00:03:54.240
You have a mask,
a soft mask of some sort,

00:03:54.240 --> 00:03:55.900
and you want to use that
as a clipping region.

00:03:55.900 --> 00:04:00.450
In the past, in Panther,
clipping was always sort of path based.

00:04:00.570 --> 00:04:03.280
You could clip to a circle
or clip to rectangles or to

00:04:03.280 --> 00:04:05.970
a much more complex path,
but it wasn't very easy to

00:04:05.980 --> 00:04:07.700
do a clip directly to a mask.

00:04:07.730 --> 00:04:11.250
So we've added API in Tiger to
let you clip to a mask.

00:04:11.250 --> 00:04:14.430
And it works just like
every other clipping region,

00:04:14.450 --> 00:04:15.800
clipping in Quartz.

00:04:16.280 --> 00:04:18.160
It's intersected with the
current clipping region.

00:04:18.160 --> 00:04:20.120
It obeys G-save-G-restore semantics.

00:04:20.260 --> 00:04:21.920
So in that respect, it's identical.

00:04:22.200 --> 00:04:25.330
It's just that now you sort of get
the power of a soft mask for your

00:04:25.340 --> 00:04:29.510
drawing operations in addition
to sort of the standard clip path

00:04:30.090 --> 00:04:31.250
concept that we've already had.

00:04:31.250 --> 00:04:35.440
So we think this will be very useful
for certain people who need to be

00:04:35.440 --> 00:04:37.710
able to do this type of operation.

00:04:37.920 --> 00:04:40.830
We've also added some new path APIs.

00:04:40.830 --> 00:04:43.800
And the idea,
the sort of the overarching theme of some

00:04:43.800 --> 00:04:46.470
of the things we're going to be talking
about is make simple things simple.

00:04:46.470 --> 00:04:48.860
Quartz is a very, very powerful API.

00:04:48.860 --> 00:04:51.300
It has lots of things available in it.

00:04:51.330 --> 00:04:53.390
But the problem is that
sometimes a little bit,

00:04:53.430 --> 00:04:54.890
the water gets deep really fast.

00:04:54.890 --> 00:04:56.980
It's hard to know where
to start sometimes.

00:04:56.980 --> 00:04:59.020
We've had people say, well,
if I want to draw a circle,

00:04:59.020 --> 00:05:01.090
I have to learn about Bezier
paths and cubic equations.

00:05:01.170 --> 00:05:02.700
And I don't know what to do about that.

00:05:02.870 --> 00:05:04.080
So that's a bad thing.

00:05:04.080 --> 00:05:07.330
We want to make it easy for
people to do simple things.

00:05:07.340 --> 00:05:10.310
So one of the goals for some
of the APIs we've added is make

00:05:10.370 --> 00:05:11.850
simple things even simpler.

00:05:11.860 --> 00:05:15.440
So for Tiger,
we're adding APIs to let you do circles

00:05:15.440 --> 00:05:19.470
just directly without having to sort
of worry about Bezier paths and so on.

00:05:19.470 --> 00:05:22.280
Of course, ellipses are just a
variation of a circle.

00:05:22.280 --> 00:05:25.620
We've also added APIs to let you
do lots of lines stroked very,

00:05:25.620 --> 00:05:26.520
very rapidly.

00:05:26.520 --> 00:05:30.010
And you'll see a very good demo
of how that's used a little bit

00:05:30.010 --> 00:05:31.870
later when John comes up to talk.

00:05:31.910 --> 00:05:35.190
But of course,
we want to keep simple things simple.

00:05:35.190 --> 00:05:37.730
But we also don't want to neglect
people who have more advanced needs.

00:05:37.740 --> 00:05:40.890
And so one of the things we've
added for paths is hit testing.

00:05:40.890 --> 00:05:43.890
So you can find out if a
point is inside a path.

00:05:43.890 --> 00:05:47.080
So you can do, you know,
you want to drag.

00:05:47.080 --> 00:05:47.810
Oh, yay.

00:05:48.030 --> 00:05:51.600
And also, those are some of the
advanced developers.

00:05:51.600 --> 00:05:55.460
And also, we want to be able to allow you
to replace the current path with

00:05:55.550 --> 00:05:57.170
a stroked version of the path,
again,

00:05:57.260 --> 00:05:59.790
for hit testing or for special shading,
stuff like that.

00:06:02.250 --> 00:06:06.100
Now again, along the same theme of
keeping simple things simple,

00:06:06.100 --> 00:06:09.800
we've added some APIs to let you
get access to some of the basic

00:06:09.980 --> 00:06:12.130
fundamental color sync color spaces.

00:06:12.140 --> 00:06:15.660
Color sync has sort of three
fundamental color spaces,

00:06:15.750 --> 00:06:18.420
the generic gray, generic RGB,
generic CMYK.

00:06:18.420 --> 00:06:22.760
And it used to be in Panther sort
of difficult to get access to these.

00:06:22.760 --> 00:06:25.680
You'd have to sort of go to color
sync and muck around in color sync,

00:06:25.680 --> 00:06:27.870
come back to core graphics,
muck around in core graphics,

00:06:27.870 --> 00:06:29.470
and after you've done
all that mucking around,

00:06:29.470 --> 00:06:30.950
you finally, oh look,
you've got a color space.

00:06:30.950 --> 00:06:33.940
So what we've done is made it very,
very simple to get access to the

00:06:34.040 --> 00:06:38.240
color space without having to go
through all of that sort of gyration.

00:06:38.240 --> 00:06:43.490
And that way you can guarantee that you
can easily get a color space that gives

00:06:43.490 --> 00:06:45.700
you high fidelity color everywhere.

00:06:51.990 --> 00:06:57.800
Now that's important because our
future direction is high quality color,

00:06:58.030 --> 00:07:00.860
high fidelity color
everywhere across all devices.

00:07:00.860 --> 00:07:05.580
We are no longer trying to model sort
of the device idea where you get a

00:07:05.580 --> 00:07:10.260
different color if you're printing versus
a different color versus on your monitor.

00:07:10.260 --> 00:07:14.150
We want to make sure that you get a high
quality match color everywhere you go.

00:07:14.180 --> 00:07:16.870
To that end,
we want you to avoid using device

00:07:16.870 --> 00:07:22.050
color spaces and to help you with that,
we're actually going to replace the use

00:07:22.070 --> 00:07:25.700
of device color spaces automatically
for you with the generic RGB,

00:07:25.750 --> 00:07:27.000
generic gray, and so on.

00:07:27.260 --> 00:07:29.600
So that even if you don't
care too much about color,

00:07:29.600 --> 00:07:32.650
and a lot of people sort of are
willing to sort of let the system

00:07:32.650 --> 00:07:35.280
handle a lot of that for them,
you'll still get the same

00:07:35.280 --> 00:07:37.300
results on all monitors,
on all printers,

00:07:37.300 --> 00:07:40.020
without actually having to do
anything very difficult yourself.

00:07:40.020 --> 00:07:44.850
Now an example of how easy it is
though to transition to use the sort

00:07:44.900 --> 00:07:51.090
of not used device color but instead
use the more specific color spaces.

00:07:51.280 --> 00:07:52.790
In the case of the
CIGI ColorSpace Create,

00:07:52.790 --> 00:07:54.990
you might use the function
CIGI ColorSpace Create Device RGB by

00:07:54.990 --> 00:07:55.690
its name.

00:07:55.690 --> 00:07:57.300
It's a device color space.

00:07:57.400 --> 00:07:59.750
The results will look different
on different output devices.

00:07:59.750 --> 00:08:00.570
That's a bad way.

00:08:00.570 --> 00:08:01.590
Don't do that anymore.

00:08:01.750 --> 00:08:05.350
The good way, the tiger way,
is to call CIGI ColorSpace Create with

00:08:05.350 --> 00:08:07.240
name and you pass in the
name of the color space,

00:08:07.240 --> 00:08:09.040
in this case generic RGB.

00:08:09.090 --> 00:08:09.900
So it's very simple.

00:08:09.910 --> 00:08:12.330
Not a lot of code changes,
not much difference,

00:08:12.340 --> 00:08:16.510
and what you end up with is a color that
will look the same across all platforms.

00:08:17.890 --> 00:08:19.930
So this is definitely the
direction we're headed,

00:08:19.930 --> 00:08:22.500
and so we want you to be able
to come along with us in that.

00:08:22.540 --> 00:08:27.610
For image APIs,
we've added a number of new ways to

00:08:27.740 --> 00:08:31.910
do image drawing and work with images,
and so I'll go into each

00:08:31.910 --> 00:08:33.430
one of these independently.

00:08:33.440 --> 00:08:35.600
So the first is chroma key masking.

00:08:35.600 --> 00:08:37.920
This is, you know,
some people call this blue screen.

00:08:37.920 --> 00:08:39.060
It's a very straightforward idea.

00:08:39.060 --> 00:08:41.890
You have someone stand in
front of a blue screen,

00:08:41.950 --> 00:08:44.430
and here we have two men shaking hands.

00:08:44.940 --> 00:08:47.840
And then when you display it,
you subtract out the blue color,

00:08:47.840 --> 00:08:49.960
and everything that was
blue becomes transparent.

00:08:49.960 --> 00:08:53.050
So this is something that, you know,
everybody sort of is familiar

00:08:53.140 --> 00:08:54.250
with from TV and so on.

00:08:54.260 --> 00:08:59.540
And so what we've added in
Tiger is a simple way to create

00:08:59.540 --> 00:09:04.480
an image and specify a key color,
the color you want to make transparent,

00:09:04.480 --> 00:09:07.520
and end up with an image that
works just like every other image,

00:09:07.520 --> 00:09:09.480
which has those parts transparent.

00:09:09.480 --> 00:09:11.860
The function of CG image
create with masking colors,

00:09:11.860 --> 00:09:14.910
and it's a very easy way
to get chroma key masking.

00:09:14.940 --> 00:09:17.380
for your images, if you will.

00:09:17.600 --> 00:09:20.170
In addition,
this is something that falls in the

00:09:20.240 --> 00:09:21.600
category of making simple things simple.

00:09:21.600 --> 00:09:22.820
It's a very obvious idea.

00:09:22.820 --> 00:09:25.160
It fits into the previous
example we had with clipping.

00:09:25.160 --> 00:09:29.750
CG image create with mask lets you
take an image and apply a mask to it,

00:09:29.750 --> 00:09:34.390
a soft mask, any depth that's currently
supported with image masks,

00:09:34.390 --> 00:09:37.130
and what you get out is a masked image.

00:09:37.240 --> 00:09:41.270
This is something that maybe some
people are familiar with from QuickDraw.

00:09:41.320 --> 00:09:44.030
It's definitely something
that took a lot more code,

00:09:44.230 --> 00:09:46.000
too much code to do in Panther.

00:09:46.520 --> 00:09:49.410
So for Tiger,
we've added a single function, one shot,

00:09:49.410 --> 00:09:52.690
CG image create with mask,
and you get exactly this effect.

00:09:52.820 --> 00:09:56.020
Very powerful, but very simple as well.

00:09:56.830 --> 00:09:57.010
Good.

00:09:57.050 --> 00:09:58.720
We're adding it for you.

00:09:58.730 --> 00:10:07.010
Another API to help work
with images in certain cases,

00:10:07.020 --> 00:10:10.510
particular cases,
is the idea of a sub-image of an image.

00:10:10.510 --> 00:10:14.120
This is a pretty common idea if you
maybe have cached some complicated

00:10:14.180 --> 00:10:16.860
drawing in a single bitmap,
and perhaps you want to use

00:10:16.860 --> 00:10:20.270
that different regions of that
bitmap for different drawing

00:10:20.270 --> 00:10:21.690
as you're doing your work.

00:10:21.760 --> 00:10:24.350
And here we imagine an example
where someone's drawing a font,

00:10:24.670 --> 00:10:28.070
maybe it's for their cache,
and they have nine letters,

00:10:28.090 --> 00:10:32.060
and what they want to do is sort
of pick out each one independently.

00:10:32.060 --> 00:10:35.030
So there's a now new function,
cgImageCreate with image in rect.

00:10:35.090 --> 00:10:37.560
You start out with an image,
and you choose a rectangle,

00:10:37.560 --> 00:10:40.070
and what you end up with is
an image that works just like

00:10:40.130 --> 00:10:41.490
every other image in Quartz.

00:10:41.630 --> 00:10:43.680
It's just a piece of that parent image.

00:10:43.680 --> 00:10:47.280
The nice thing is that all of these
sub-images sort of share the same parent,

00:10:47.280 --> 00:10:49.420
so you're not making
copies of all the data.

00:10:49.420 --> 00:10:50.990
You can keep it all in one place.

00:10:50.990 --> 00:10:54.760
So that's a very powerful
API for those cases.

00:10:54.960 --> 00:10:56.090
Thank you.

00:10:57.130 --> 00:11:01.870
And then finally with images,
again this is something that we

00:11:02.430 --> 00:11:05.550
really want to make much easier.

00:11:05.650 --> 00:11:07.620
Bitmap context,
we've told people in Quartz 2D,

00:11:07.700 --> 00:11:09.500
if you want to do off screen drawing,
if you want to do some

00:11:09.650 --> 00:11:11.780
sort of caching like that,
use a bitmap context.

00:11:11.810 --> 00:11:14.520
Later we'll tell you about something new
that's even better than bitmap context,

00:11:14.550 --> 00:11:17.980
but there are still cases where it's
appropriate to use a bitmap context.

00:11:17.980 --> 00:11:20.540
And you do your drawing in the
bitmap context and we just sort of,

00:11:20.550 --> 00:11:23.510
you know, blithely say, "Oh,
and then create an image from it

00:11:23.520 --> 00:11:26.590
and draw with that image." And it
turns out that's a lot of code.

00:11:26.590 --> 00:11:27.680
It's not so simple.

00:11:27.730 --> 00:11:29.870
And particularly it's not so simple
to sort of make sure the color

00:11:29.870 --> 00:11:32.300
spaces match your destination
and all that sort of stuff.

00:11:32.350 --> 00:11:36.810
So what we've done for Tiger is added one
function that does all that work for you,

00:11:36.810 --> 00:11:38.440
CG bitmap context create image.

00:11:38.440 --> 00:11:42.000
You pass in a bitmap context
and out pops an image from it.

00:11:42.060 --> 00:11:44.860
So it's very simple now to sort
of do what we've always just

00:11:44.950 --> 00:11:47.620
waved our hands about in the past.

00:11:47.620 --> 00:11:51.030
This is a very powerful function,
but the thing you need to remember

00:11:51.030 --> 00:11:52.970
is that it is a copy operation.

00:11:53.110 --> 00:11:55.180
Now that's not as bad as it sounds,
but it's a copy operation because

00:11:55.280 --> 00:11:57.140
CG images must be immutable.

00:11:57.140 --> 00:12:04.800
We expect that an image
will be reused -- or rather,

00:12:04.920 --> 00:12:09.410
excuse me, we expect that a CG image will
be uploaded to video RAM once.

00:12:09.410 --> 00:12:12.510
And then every time that
image is drawn multiple times,

00:12:12.510 --> 00:12:14.000
we don't reupload it.

00:12:14.000 --> 00:12:19.800
That saves a huge amount of traffic
through the bus to the video card.

00:12:19.800 --> 00:12:22.090
If your image is changed,
then we can't do that.

00:12:22.150 --> 00:12:23.760
We have to reupload every time.

00:12:23.760 --> 00:12:28.180
So we're enforcing -- it's
always been true in the past,

00:12:28.290 --> 00:12:32.580
but we're enforcing now the concept
that a CG image must be immutable.

00:12:32.670 --> 00:12:36.000
So that's something that's very important
for you to check out in your application.

00:12:36.030 --> 00:12:37.760
Make sure that you're not doing
something where you're changing

00:12:37.760 --> 00:12:39.500
the context of an image.

00:12:39.610 --> 00:12:42.230
Because if you start doing that,
then your hardware acceleration

00:12:42.240 --> 00:12:43.240
will really suffer.

00:12:43.240 --> 00:12:48.750
Now, when I say it's a copy operation,
it's not really a copy.

00:12:48.760 --> 00:12:50.440
It's a copy and write.

00:12:50.540 --> 00:12:54.720
It uses the, you know,
VM magic of Mach to copy and write.

00:12:54.720 --> 00:12:57.140
So you don't actually really make a copy.

00:12:57.140 --> 00:12:59.510
Instead,
you have two things that point to

00:12:59.510 --> 00:13:01.780
the same in-memory destination.

00:13:01.880 --> 00:13:04.390
And if anybody writes on one of them,
then a copy happens.

00:13:04.480 --> 00:13:07.940
But until something is written,
then nothing -- you don't get a copy.

00:13:07.940 --> 00:13:11.950
You both share the same
underlying data structures.

00:13:12.060 --> 00:13:14.540
So that's really useful because
you can sort of create an

00:13:14.540 --> 00:13:17.900
image from a bitmap context,
draw it somewhere, release it,

00:13:17.900 --> 00:13:20.090
and you actually have
never made a true copy.

00:13:23.170 --> 00:13:26.100
Another thing that
we're adding for images,

00:13:26.100 --> 00:13:28.480
this is again sort of more
of in the advanced category,

00:13:28.480 --> 00:13:32.020
is what we call deep pixel support.

00:13:36.300 --> 00:13:43.350
This is deep in the sense that it's
now floating point pixels for both

00:13:43.350 --> 00:13:46.230
image content and for bitmap context.

00:13:46.310 --> 00:13:50.050
So we already support in Panther the
standard integer formats,

00:13:50.110 --> 00:13:55.140
you know, one to, well actually up to 32,
one to 32 bits per pixel, sorry,

00:13:55.270 --> 00:13:56.540
bits per component.

00:13:56.540 --> 00:13:59.160
For Panther,
we're now letting you specify

00:13:59.160 --> 00:14:03.570
a 32-bit floating point value,
and the floating point value can be,

00:14:03.570 --> 00:14:07.550
you know, you can have red, green, blue,
alpha as your floating point values,

00:14:07.580 --> 00:14:09.380
you can see in YK floating point.

00:14:09.430 --> 00:14:12.010
Pretty much anything that we
currently support in integer,

00:14:12.010 --> 00:14:13.250
we also support in floating point.

00:14:13.360 --> 00:14:14.190
Same thing for output.

00:14:14.190 --> 00:14:16.170
For bitmap contexts,
you can create a floating point

00:14:16.440 --> 00:14:18.690
bitmap context that you might use.

00:14:19.460 --> 00:14:22.940
Now the--excuse me.

00:14:22.960 --> 00:14:22.980
The--the

00:14:23.310 --> 00:14:27.290
The advantage to this is that now for
image formats that are starting to come

00:14:27.290 --> 00:14:29.270
online where you're actually bringing in,
you know,

00:14:29.270 --> 00:14:33.290
more of these higher resolution images,
we now can support those natively.

00:14:33.300 --> 00:14:36.340
Now, the other thing that's important
to note is that this is not sort

00:14:36.340 --> 00:14:38.060
of high dynamic range imaging.

00:14:38.060 --> 00:14:39.840
That's a very specialized thing.

00:14:39.840 --> 00:14:42.360
It's used in,
it's sort of more a color sync,

00:14:42.360 --> 00:14:45.840
color science type thing to sort
of figure out how to map your big

00:14:46.280 --> 00:14:48.500
floating point range to sort of visible.

00:14:48.500 --> 00:14:51.190
That's a problem that's best
left to the color sync guys.

00:14:51.190 --> 00:14:52.970
There's a special session on that.

00:14:53.390 --> 00:14:55.260
Where they talk about that more in depth.

00:14:55.490 --> 00:14:56.880
What we do is something very simple.

00:14:56.880 --> 00:14:59.090
We just take the values
between zero and one,

00:14:59.090 --> 00:15:00.370
and that becomes the image.

00:15:00.450 --> 00:15:01.960
Anything less than zero,
we clamp to zero.

00:15:01.960 --> 00:15:03.760
Anything greater than one,
we clamp to one.

00:15:03.760 --> 00:15:06.610
So we're not actually mucking
around with the data ourselves.

00:15:06.610 --> 00:15:09.420
We let you do that or color sync do that,
other parts of the system

00:15:09.420 --> 00:15:10.620
that are more capable.

00:15:13.100 --> 00:15:13.840
Excuse me.

00:15:14.070 --> 00:15:19.390
Now another thing that we have had sort
of missing in the past is image I/O,

00:15:19.440 --> 00:15:21.940
input and output of image data.

00:15:21.950 --> 00:15:25.440
As you know, some of you we've been
able to support as input,

00:15:25.510 --> 00:15:28.720
JPEG natively, PNG natively,
into Quartz 2D.

00:15:28.720 --> 00:15:30.760
Raw image data is sort
of a big buffer of red,

00:15:30.840 --> 00:15:32.940
green, blue alpha data,
not encoded in any

00:15:32.940 --> 00:15:34.160
particular file format.

00:15:34.590 --> 00:15:37.800
For output, we haven't had a way to
do any image outputs.

00:15:37.800 --> 00:15:39.980
Of course,
we've been able to output PDF files,

00:15:40.070 --> 00:15:42.420
which are tremendously
rich and complicated.

00:15:42.460 --> 00:15:45.110
But for something like
a simple JPEG output,

00:15:45.110 --> 00:15:45.820
nothing.

00:15:45.940 --> 00:15:48.250
So for Tiger, we want to remedy that.

00:15:48.450 --> 00:15:52.470
In Tiger,
we're going to add support for JPEG, PNG,

00:15:52.470 --> 00:15:55.650
TIFF, GIF, JPEG 2000,
a bunch of other formats supported by

00:15:55.650 --> 00:15:58.090
QuickTime and other formats as we need.

00:15:58.100 --> 00:16:02.000
Of course, obviously as well,
the floating point types, excuse me,

00:16:02.000 --> 00:16:04.100
the floating point formats such
as OpenEXR and the floating

00:16:04.160 --> 00:16:06.280
point version of TIFF for output.

00:16:06.290 --> 00:16:10.060
In the WWDC build,
we support JPEG and TIFF output,

00:16:10.060 --> 00:16:12.380
and we're going to certainly
add more of those to come

00:16:12.400 --> 00:16:15.370
for the final Tiger release.

00:16:16.470 --> 00:16:19.460
There's going to be a session
that talks about some of this

00:16:19.460 --> 00:16:22.850
and combines it with the previous
topic of high dynamic range on,

00:16:22.850 --> 00:16:24.340
looks like on Wednesday.

00:16:24.340 --> 00:16:27.710
So if you're interested in
more details about that,

00:16:27.850 --> 00:16:29.090
certainly go to that session.

00:16:29.140 --> 00:16:32.730
I'm going to go a little bit
into sort of an overview of the

00:16:32.730 --> 00:16:34.890
APIs and cover them briefly.

00:16:35.430 --> 00:16:36.740
So there are two types.

00:16:36.860 --> 00:16:38.880
There's a way to get images in,
a way to get images out.

00:16:39.050 --> 00:16:41.200
The way to get images
in is a CG image source.

00:16:41.200 --> 00:16:45.080
That brings data into the system
and in some particular file format

00:16:45.080 --> 00:16:46.290
we decode it for you and draw it.

00:16:46.370 --> 00:16:50.360
So you can bring images, obviously files,
if you have a JPEG file, a URL,

00:16:50.480 --> 00:16:53.320
a raw data buffer similar
to what we already support,

00:16:53.320 --> 00:16:55.890
just a big wad of JPEG or
TIFF or whatever that you

00:16:55.890 --> 00:16:57.900
might have mapped into memory.

00:16:57.900 --> 00:17:00.720
And of course we support the
standard CG data provider,

00:17:00.720 --> 00:17:04.120
which is the way you get information
into Quartz 2D typically.

00:17:04.980 --> 00:17:07.240
What an image source does
is it creates CG images.

00:17:07.240 --> 00:17:10.470
So you create an image source from
a file and out pops a CG image.

00:17:10.470 --> 00:17:15.220
Now not all image file formats
are just single images.

00:17:15.220 --> 00:17:17.550
Some are multiple like
JIF files have animations.

00:17:17.550 --> 00:17:19.610
We'll have multiple images for that.

00:17:19.650 --> 00:17:21.920
JIF files may have different
images for different resolutions.

00:17:22.020 --> 00:17:24.580
So we support,
from an image source you can

00:17:24.580 --> 00:17:27.780
also sort of get all of the
images in the image itself,

00:17:27.780 --> 00:17:30.380
in the file format, the file data itself.

00:17:30.420 --> 00:17:33.140
Plus you can get access to the metadata.

00:17:33.140 --> 00:17:38.160
So if your camera,
were to embed its make in the file,

00:17:38.210 --> 00:17:41.160
then we would be able to return, oh,
this is a Canon camera.

00:17:41.160 --> 00:17:43.750
Or if it had longitude and latitude,
we could return that.

00:17:43.860 --> 00:17:46.380
So you can get access to the
metadata very easily as well.

00:17:46.530 --> 00:17:50.830
But the most important point about the
CG image source and what it creates is

00:17:50.830 --> 00:17:55.100
that this will be the best and fastest
and the primary way we're going to be

00:17:55.100 --> 00:17:56.650
supporting to draw images in Tiger.

00:17:56.650 --> 00:17:59.920
That means all parts of the system
are going to go through this.

00:17:59.920 --> 00:18:03.540
We're putting lots and lots
of emphasis on optimizing,

00:18:03.660 --> 00:18:05.650
doing all the vectrics and so on.

00:18:05.710 --> 00:18:10.360
And so it's very important that this
be the primary way we get images drawn

00:18:10.360 --> 00:18:12.660
and that we have the best and fastest.

00:18:12.710 --> 00:18:14.960
And so it's worth looking
at from that perspective.

00:18:14.980 --> 00:18:17.140
Of course the higher level
frameworks will also adopt this

00:18:17.480 --> 00:18:19.540
and sort of use it indirectly.

00:18:19.540 --> 00:18:21.280
But if you're sort of
working at the core 2D level,

00:18:21.300 --> 00:18:23.580
it's definitely worth looking into.

00:18:23.580 --> 00:18:25.610
For output, sort of the opposite.

00:18:25.670 --> 00:18:26.950
Basically the same.

00:18:26.950 --> 00:18:30.490
You can output to a file, to a URL,
to raw data buffer memory.

00:18:30.550 --> 00:18:33.090
You can output to CG data consumer,
which is a standard way

00:18:33.370 --> 00:18:34.020
that you can output.

00:18:34.020 --> 00:18:36.740
You can output to things in Quartz 2D.

00:18:36.900 --> 00:18:40.270
And similarly to the input,
when you create an image destination,

00:18:40.270 --> 00:18:42.910
you supply CG images and
you can supply metadata.

00:18:43.000 --> 00:18:45.710
And of course, if your image format
supports multiple images,

00:18:45.840 --> 00:18:48.240
you can supply multiple images
and write out the result.

00:18:48.240 --> 00:18:50.320
So then you can write out a
TIFF file from CG or you can

00:18:50.320 --> 00:18:55.120
write out -- or Quartz 2D,
you can write out a JPEG and so on.

00:18:55.120 --> 00:18:57.500
So just to give you a quick demo,
I'm going to

00:18:59.680 --> 00:19:04.790
I have to say up front that this demo,
like all types of demos like this,

00:19:04.790 --> 00:19:09.950
is a little bit trivial because
we're supporting a new file format.

00:19:09.960 --> 00:19:13.640
Hard to demo that tremendously well,
but I'll do what I can.

00:19:13.640 --> 00:19:16.280
We have a simple app here.

00:19:16.280 --> 00:19:20.120
And notice that here we have a TIFF file.

00:19:20.300 --> 00:19:23.010
And uh-oh, this is Panther.

00:19:23.010 --> 00:19:28.980
We can't drop it in because
Quartz 2D doesn't support TIFF.

00:19:29.690 --> 00:19:33.000
So now we're going to turn on Image.io.

00:19:33.000 --> 00:19:35.660
And now the TIFF file is accepted.

00:19:35.680 --> 00:19:37.030
Hooray!

00:19:37.130 --> 00:19:39.830
So that's very important.

00:19:39.950 --> 00:19:41.910
The power of Image.io.

00:19:42.230 --> 00:19:45.870
Now just as an additional thing,
this is a simple example of pulling

00:19:45.950 --> 00:19:47.620
up the metadata from this file.

00:19:47.620 --> 00:19:50.380
In this case, it has a bunch of fields,
things like the height

00:19:50.380 --> 00:19:53.940
and pixels and so on,
the file size, the color model and so on.

00:19:53.940 --> 00:19:57.080
There's a lot of information
like that that will be embedded

00:19:57.080 --> 00:19:58.710
in images that you can pull out.

00:19:58.990 --> 00:20:03.440
Again, a very trivial example
of getting the metadata.

00:20:03.480 --> 00:20:08.520
Then just to tie it into the
previous topic about color spaces,

00:20:08.540 --> 00:20:13.560
notice that this image doesn't actually
have a color space associated with it.

00:20:13.600 --> 00:20:15.050
We're not using a color space.

00:20:15.130 --> 00:20:19.760
But when we start using generic RGB,
it doesn't change.

00:20:19.790 --> 00:20:20.150
Why?

00:20:20.330 --> 00:20:23.700
Because in Tiger,
we're automatically making sure

00:20:23.700 --> 00:20:26.420
that anything that's untagged
gets tagged with generic RGB.

00:20:26.530 --> 00:20:28.360
So you get the same fidelity
across all platforms.

00:20:28.420 --> 00:20:31.390
And then just as a simple
example to prove that there

00:20:31.390 --> 00:20:34.740
really is something going on,
this is a specialized color

00:20:34.740 --> 00:20:36.520
space which swaps blue and red.

00:20:36.530 --> 00:20:38.840
And as you can see,
now you have a very odd,

00:20:39.040 --> 00:20:40.350
maybe sick ladybug.

00:20:40.360 --> 00:20:42.190
Okay.

00:20:42.510 --> 00:20:45.390
So that's the demo of that.

00:20:48.600 --> 00:20:50.490
Okay, so what else have we added?

00:20:50.710 --> 00:20:55.340
Let me get some water and I'll tell you.

00:20:59.160 --> 00:21:02.570
Okay, another thing that's very
important and is very powerful is,

00:21:02.580 --> 00:21:05.180
of course,
the resolution independence in Quartz 2D.

00:21:05.180 --> 00:21:08.530
The fact that, you know, any resolution,
any output,

00:21:08.620 --> 00:21:11.900
any scale factor looks just the same,
looks just as good as

00:21:11.980 --> 00:21:13.540
other scale factors.

00:21:14.380 --> 00:21:17.240
Now, it's not surprising that, of course,
you know,

00:21:17.380 --> 00:21:20.470
down the road we expect monitors
to change in resolution.

00:21:20.510 --> 00:21:25.460
And we also know that people who are
currently disabled use resolution,

00:21:25.460 --> 00:21:28.740
the scale factors to do,
to zoom up their UI so they

00:21:28.870 --> 00:21:32.900
get some better ability to
look at the content and so on.

00:21:32.980 --> 00:21:36.580
And the thing that we are very,
very focused on is making sure that in

00:21:36.660 --> 00:21:40.140
all those cases it still looks great,
so that your app still looks

00:21:40.140 --> 00:21:43.650
just as beautiful as it does
today on the current monitors.

00:21:44.220 --> 00:21:45.580
That's an very important thing.

00:21:45.580 --> 00:21:50.040
Now, that means that you need to actually
sort of play with the idea that

00:21:50.070 --> 00:21:54.150
your application may be scaled,
may need to zoom up and so on.

00:21:54.180 --> 00:21:57.230
What that means sort of on a
technical level is that we'll

00:21:57.330 --> 00:21:59.020
set up the context for you.

00:21:59.020 --> 00:22:04.160
The CTM will be set up so that the scale
factor will be built in to the context.

00:22:04.240 --> 00:22:06.570
So you don't actually have
to worry about that too much.

00:22:06.580 --> 00:22:10.580
But that means you do have to worry
about it in that you can't undo that.

00:22:10.660 --> 00:22:11.980
If you undo it,
then suddenly you're not drawing

00:22:11.980 --> 00:22:13.860
at the right scale factor,
you're drawing at some other scale.

00:22:13.860 --> 00:22:18.000
And everything's going to look like,
you know, bad things on the screen.

00:22:18.020 --> 00:22:22.500
So what that means is that we don't want
you to sort of undo the transformation

00:22:22.510 --> 00:22:25.400
by -- this is a little bit technical
-- but taking the CTM and inverting

00:22:25.400 --> 00:22:28.070
it and concatenating it back to
pretend like you're an identity.

00:22:28.100 --> 00:22:30.500
Don't do that,
if you understand what I'm saying.

00:22:30.670 --> 00:22:31.950
If you don't, good.

00:22:32.020 --> 00:22:35.150
And instead,
we really think that it's important

00:22:35.150 --> 00:22:37.800
to consistently use gsave,
grestore.

00:22:38.030 --> 00:22:39.950
That's a standard way to
save the graphic state,

00:22:40.000 --> 00:22:41.340
restore the graphic state.

00:22:41.440 --> 00:22:43.600
We spent a lot of effort in Tiger.

00:22:43.600 --> 00:22:47.640
We're optimizing the gsave,
grestore operation, so it's very cheap.

00:22:47.640 --> 00:22:49.500
And so we think that that's
the right way to do it.

00:22:49.500 --> 00:22:53.130
And it sort of will save you once we
do get down to the road where we are

00:22:53.130 --> 00:22:56.280
going to start scaling the applications.

00:22:56.580 --> 00:23:00.160
All that said, there are still some cases
where you really do need to

00:23:00.270 --> 00:23:02.080
know what pixels am I touching.

00:23:02.080 --> 00:23:05.810
If you want to draw a thin line,
for example, and you don't want it to

00:23:05.810 --> 00:23:09.070
straddle a pixel boundary,
or you need something to exactly

00:23:09.180 --> 00:23:12.130
abut against something else,
those things do happen

00:23:12.130 --> 00:23:13.650
where you sort of need that.

00:23:13.790 --> 00:23:17.970
And to help you with those cases when
you may have a scaled up user interface,

00:23:17.970 --> 00:23:23.080
we have sort of a big workhorse function,
CGContext.getUserSpace.DueDeviceSpace.

00:23:23.080 --> 00:23:24.400
Transform.

00:23:24.580 --> 00:23:28.210
That is the full transform from the
current user space that you're drawing

00:23:28.210 --> 00:23:30.960
in all the way down to the pixels,
to the actual pixels

00:23:30.960 --> 00:23:33.300
that you're working with,
the device space.

00:23:33.300 --> 00:23:36.170
Now, often you don't need
something so heavy weight,

00:23:36.170 --> 00:23:38.450
so we have some key
convenience functions,

00:23:38.470 --> 00:23:40.980
a function that will take
a point in user space,

00:23:41.200 --> 00:23:45.100
convert it to device space, to pixels,
take that point in pixel space,

00:23:45.100 --> 00:23:47.470
convert it back to user space.

00:23:47.500 --> 00:23:51.000
And we have similar functions
for sizes and rectangles.

00:23:51.300 --> 00:23:54.300
As an example, a simple example of
how you might use this,

00:23:54.300 --> 00:23:56.990
here we have somebody who wants
to do some sort of specialized

00:23:56.990 --> 00:24:00.120
rounding in device space,
where they really want to round to the

00:24:00.120 --> 00:24:02.200
middle of a pixel or something like that.

00:24:02.260 --> 00:24:04.440
So they have a point in user space,
they call

00:24:04.540 --> 00:24:08.350
CGContext.ConvertPointToDeviceSpace,
that converts that point through

00:24:08.350 --> 00:24:11.190
the current transformation matrix
all the way down to pixels.

00:24:11.200 --> 00:24:13.050
They do their alignment
the way they want,

00:24:13.270 --> 00:24:15.610
and then they take that point,
convert it back to user space,

00:24:15.710 --> 00:24:18.280
and now when they draw with it,
they know that what will come

00:24:18.280 --> 00:24:20.200
out will be precisely aligned.

00:24:20.200 --> 00:24:22.200
So for those special cases
where it's important,

00:24:22.200 --> 00:24:24.200
this is a very powerful API.

00:24:24.200 --> 00:24:25.600
In general, though,
we think that you'll be

00:24:25.700 --> 00:24:28.100
just fine using the standard
Quartz2D things for scalable UI,

00:24:28.100 --> 00:24:30.100
but in the certain cases
where it's necessary,

00:24:30.100 --> 00:24:32.100
this will help you out.

00:24:32.100 --> 00:24:39.090
Now, let me give you a quick demo of
scalable UI and how it works with apps.

00:24:45.880 --> 00:24:49.510
Some of you may have seen this
yesterday in Peter's talk.

00:24:49.870 --> 00:24:52.980
So we have-- many of you are
familiar with Quartz Debug,

00:24:53.030 --> 00:24:56.260
very powerful tool for development.

00:24:56.280 --> 00:24:59.160
And we have now a user
interface resolution slider.

00:24:59.320 --> 00:25:02.240
So you can change the slider,
and you'll get a different

00:25:02.370 --> 00:25:05.130
resolution for your application.

00:25:05.140 --> 00:25:09.200
So for example, here we might-- let's say
we'll go up to two times,

00:25:09.200 --> 00:25:11.590
and let's launch Safari.

00:25:13.960 --> 00:25:15.250
You see Safari is twice as big.

00:25:15.290 --> 00:25:18.660
Now you can do this with your app too.

00:25:18.660 --> 00:25:22.390
You can take your app, change the slider,
and see what happens when you show up,

00:25:22.490 --> 00:25:23.780
when you bring it up on screen.

00:25:23.780 --> 00:25:25.210
It should have brought up Apple.com.

00:25:25.210 --> 00:25:26.780
Maybe they're announcing something else.

00:25:26.780 --> 00:25:27.320
Who knows?

00:25:30.260 --> 00:25:33.850
But the point here is that notice
how Safari looks really good.

00:25:33.850 --> 00:25:37.260
It's still as high quality as it was
when it was at a lower resolution.

00:25:37.260 --> 00:25:38.260
The text looks great.

00:25:38.260 --> 00:25:40.250
All of the drawing and so on looks great.

00:25:40.260 --> 00:25:43.930
So this is something that will help you
out to make sure that your application

00:25:43.930 --> 00:25:46.260
doesn't have any problems with rendering.

00:25:46.260 --> 00:25:49.500
As you can see, there are some issues,
like up in the upper right-hand corner.

00:25:49.500 --> 00:25:52.450
Clearly I've changed the resolution,
but nobody told the

00:25:52.450 --> 00:25:53.800
clock or the sound bar.

00:25:53.800 --> 00:25:59.240
And I would show you some other apps
where it doesn't look this good at all.

00:25:59.260 --> 00:26:01.260
But that would be embarrassing,
so I won't.

00:26:01.260 --> 00:26:03.260
So make sure your app
is not one of those.

00:26:03.260 --> 00:26:04.760
Whoops.

00:26:04.800 --> 00:26:05.260
Let's see.

00:26:05.260 --> 00:26:07.260
Safari is not quitting.

00:26:07.260 --> 00:26:09.260
I'll put it here.

00:26:09.260 --> 00:26:14.890
And the other thing to remember
is to make sure that you quit the

00:26:15.910 --> 00:26:18.040
OK, we can switch back.

00:26:18.130 --> 00:26:21.360
Make sure you quit that app,
otherwise everything will launch too

00:26:21.360 --> 00:26:24.280
big and that's difficult to read.

00:26:25.700 --> 00:26:27.770
Okay,
so that's sort of a lot of the things

00:26:27.820 --> 00:26:31.520
we've added so far for drawing,
for new ways to do drawing,

00:26:31.520 --> 00:26:34.060
better ways to work with CG context,
better ways to work with

00:26:34.070 --> 00:26:35.360
images and paths and so on.

00:26:35.490 --> 00:26:39.620
So now we're going to talk about a layer,
which is a new thing we're

00:26:39.760 --> 00:26:41.810
adding for Tiger to help out.

00:26:41.960 --> 00:26:46.270
It's really designed to sort of help
optimize the traditional case of where

00:26:46.300 --> 00:26:49.850
you want to do off-screen rendering,
but you still want it to

00:26:49.850 --> 00:26:51.720
be hardware accelerated.

00:26:52.100 --> 00:26:54.680
In the past, what we've done is said, oh,
if you want to do some sort

00:26:54.760 --> 00:26:57.030
of off-screen rendering,
just create a bitmap context,

00:26:57.050 --> 00:26:58.850
draw into that,
and then take the result and

00:26:58.850 --> 00:27:00.170
composite it to your destination.

00:27:00.220 --> 00:27:02.200
It's a good way to do caching,
and it's a very powerful and

00:27:02.200 --> 00:27:03.700
very straightforward thing to do.

00:27:03.700 --> 00:27:07.050
The one problem, though,
is that the data always lives

00:27:07.060 --> 00:27:10.130
on your side of the bus,
essentially, right?

00:27:10.150 --> 00:27:11.560
It's all sort of in your address space.

00:27:11.560 --> 00:27:15.220
So any drawing you do there,
which you then try to draw onto, say,

00:27:15.460 --> 00:27:18.000
the video card, will have to be uploaded.

00:27:18.000 --> 00:27:19.010
That's not efficient.

00:27:19.020 --> 00:27:21.920
And by design,
by the bitmap context design,

00:27:21.920 --> 00:27:22.040
it's not efficient.

00:27:22.090 --> 00:27:22.880
It's sort of limited to that.

00:27:22.920 --> 00:27:26.420
So CG layers are sort
of an optimized version,

00:27:26.520 --> 00:27:30.380
sort of a better way to work
with sort of do this type of

00:27:30.430 --> 00:27:33.040
bitmap context type caching.

00:27:33.040 --> 00:27:37.760
Now, the key thing, too,
is that in addition to just sort

00:27:38.200 --> 00:27:43.270
of being a convenient way to
sort of do off-screen rendering,

00:27:43.270 --> 00:27:47.020
when you create it,
you specify a reference

00:27:47.020 --> 00:27:49.110
to another context.

00:27:49.210 --> 00:27:51.890
And what we'll do is we'll sort of
set up the layer that we created.

00:27:52.100 --> 00:27:52.600
So that's what we'll do.

00:27:52.640 --> 00:27:53.220
So we'll create a reference
to another context.

00:27:53.220 --> 00:27:53.430
So we'll create a reference
to another context.

00:27:53.480 --> 00:27:55.380
So that sort of matches
the destination context.

00:27:55.450 --> 00:27:57.340
For example,
it will match the color space.

00:27:57.340 --> 00:27:59.660
So that means you don't really need
to know about the color space of

00:27:59.710 --> 00:28:01.410
the context you're working with,
for example,

00:28:01.410 --> 00:28:02.730
the screen color space or so on.

00:28:03.020 --> 00:28:05.520
Instead, we'll sort of create that,
set that up for you.

00:28:05.520 --> 00:28:08.710
So when you draw onto the layer,
what will happen is that it will

00:28:08.710 --> 00:28:10.900
already be matched to that color space.

00:28:11.040 --> 00:28:14.770
So when it's actually finally used,
you don't have to do a separate match.

00:28:14.880 --> 00:28:18.300
So it makes sure that things
stay highly efficient.

00:28:18.770 --> 00:28:21.280
And you can sort of think of it,
it's really in many ways sort of like,

00:28:21.450 --> 00:28:25.220
you know, as this example shows,
just like a rubber stamp in some sense.

00:28:25.220 --> 00:28:28.940
You can take the layer, you draw into it,
and then you can sort of use

00:28:29.130 --> 00:28:30.900
that over and over and over.

00:28:30.900 --> 00:28:33.700
Here, for example, we've created a layer,
we've drawn the butterfly into it,

00:28:33.700 --> 00:28:34.820
and now we can just use that.

00:28:35.080 --> 00:28:38.720
And what's great is if the layer
is hardware accelerated so that

00:28:38.720 --> 00:28:42.040
it's already up on the card,
when that stamp happens,

00:28:42.040 --> 00:28:44.360
none of that comes back over to the CPU.

00:28:44.360 --> 00:28:45.440
Instead, that's all done on the GPU.

00:28:45.630 --> 00:28:48.100
So that's very,
very efficient and very high powered

00:28:48.100 --> 00:28:51.420
for those types of cases where you
need to do sort of off-screen caching

00:28:51.420 --> 00:28:55.410
and you don't want to have things
sort of live on your side of the bus,

00:28:55.560 --> 00:28:56.390
as it were.

00:28:59.710 --> 00:29:02.630
So like I mentioned,
we sort of imagine that one common use,

00:29:02.750 --> 00:29:05.200
probably the majority, will be caching.

00:29:05.240 --> 00:29:09.560
So you would use a layer instead of a
bitmap context for off-screen caching.

00:29:09.560 --> 00:29:12.230
Another one,
which may be a little bit less likely,

00:29:12.230 --> 00:29:15.000
is sort of a buffering where
you might be in the middle of

00:29:15.000 --> 00:29:17.890
a screen update on this side,
so you can go ahead and start

00:29:17.960 --> 00:29:20.860
drawing into a layer so that the
next time you get a chance to

00:29:20.860 --> 00:29:23.940
composite to the destination,
you're ready to go.

00:29:23.940 --> 00:29:26.700
That might be a little
bit less common use.

00:29:26.700 --> 00:29:29.160
So short demo.

00:29:29.600 --> 00:29:35.880
We'll go back to my little app.

00:29:38.720 --> 00:29:41.220
So here we have our app again.

00:29:41.230 --> 00:29:44.100
And here's a PDF file.

00:29:44.440 --> 00:29:47.720
Very nice PDF file,
but it's got a lot of data and

00:29:47.720 --> 00:29:49.110
it's a slow thing to render.

00:29:49.360 --> 00:29:52.070
Now, if I wanted to animate that,

00:29:53.650 --> 00:29:56.330
I would be fired because
this is not really animation.

00:29:56.330 --> 00:29:59.960
This is sort of chunky blobbyness.

00:29:59.960 --> 00:30:02.520
So instead, of course,
obviously what you want to do,

00:30:02.620 --> 00:30:05.120
in Panther we would have said, oh, well,
to solve this problem,

00:30:05.220 --> 00:30:06.250
create a bitmap context.

00:30:06.350 --> 00:30:06.900
Very good.

00:30:06.930 --> 00:30:08.980
Solves the problem for Panther.

00:30:08.980 --> 00:30:10.150
The problem, though,
is of course that's not

00:30:10.150 --> 00:30:10.880
hardware accelerated.

00:30:11.060 --> 00:30:14.360
For Tiger, you can create a layer.

00:30:14.400 --> 00:30:17.780
And what this does is it will
draw the PDF file into the layer,

00:30:17.780 --> 00:30:19.410
and then the layer is
now hardware accelerated.

00:30:19.410 --> 00:30:22.740
So when we do animation,
it's going to be completely smooth.

00:30:22.860 --> 00:30:24.450
It's all hardware accelerated.

00:30:24.450 --> 00:30:26.120
Everything looks beautiful.

00:30:26.120 --> 00:30:30.240
Now the thing to remember, of course,
is that it's still in some sense bits.

00:30:30.490 --> 00:30:35.170
So if you think about it,
it's not the original high resolution

00:30:35.170 --> 00:30:38.440
PDF file that if you scale up,
you'll get perfectly beautiful

00:30:38.440 --> 00:30:39.940
results at any scale factor.

00:30:39.940 --> 00:30:43.810
You will start seeing perhaps
some sort of image artifacts

00:30:44.030 --> 00:30:48.590
if you were to scale up this
particular layer because it is bits.

00:30:48.790 --> 00:30:50.220
But in many cases,
for something like this,

00:30:50.220 --> 00:30:51.340
that doesn't make any difference.

00:30:51.380 --> 00:30:52.780
You don't care about that so much.

00:30:52.840 --> 00:30:54.810
You just simply want
to have high quality,

00:30:54.820 --> 00:30:56.110
fast, efficient rendering.

00:30:56.160 --> 00:30:58.100
There's Safari still.

00:30:58.160 --> 00:30:59.920
OK.

00:30:59.990 --> 00:31:00.710
So that's that demo.

00:31:04.180 --> 00:31:08.300
So that's a lot of the
APIs for both drawing content,

00:31:08.300 --> 00:31:14.070
for high efficiency off-screen rendering,
and now we wanted to also add

00:31:14.390 --> 00:31:16.980
some stuff for PDF support.

00:31:16.980 --> 00:31:24.640
As you know, PDF is the metadata
file format in Mac OS X.

00:31:24.640 --> 00:31:29.100
It's our high fidelity
rendering of drawn content.

00:31:29.100 --> 00:31:30.160
It's a great format.

00:31:30.160 --> 00:31:31.590
It works really well for us.

00:31:31.590 --> 00:31:34.400
The problem is that sometimes people
have trouble sort of both in the

00:31:34.590 --> 00:31:38.290
creation side they want to do more
things and on the sort of input side

00:31:38.300 --> 00:31:40.940
where they want to really look and
introspect more into the PDF itself.

00:31:40.960 --> 00:31:43.400
So we've added some APIs to help do that.

00:31:43.460 --> 00:31:44.780
So let's go through those.

00:31:44.880 --> 00:31:48.860
The first is links and anchors,
very comparable to HTML.

00:31:48.860 --> 00:31:51.410
Again,
it works just with a PDF context that

00:31:51.550 --> 00:31:53.660
is able to record this information.

00:31:53.710 --> 00:31:57.580
And you can do sort of the basic stuff
you can do with links and anchors.

00:31:57.580 --> 00:32:00.190
You can specify a URL and say, well,
when somebody clicks on that

00:32:00.360 --> 00:32:04.800
point in the PDF page 17,
I want you to open up this URL in Safari.

00:32:04.800 --> 00:32:05.930
So you can do that.

00:32:06.000 --> 00:32:09.680
And then, of course,
the anchor type model where you can say,

00:32:09.680 --> 00:32:12.710
well, if I click here on page 47,
go back to page 8 or

00:32:12.830 --> 00:32:14.490
go forward to page 75.

00:32:14.500 --> 00:32:17.800
So you can sort of do forward
and backward references.

00:32:17.800 --> 00:32:20.200
And it's a very simple API.

00:32:20.200 --> 00:32:21.970
It's very easy to use,
but it gives you a lot of

00:32:22.060 --> 00:32:23.480
power to sort of preserve that.

00:32:23.480 --> 00:32:26.240
And, of course,
Safari will be using this in Tiger to

00:32:26.240 --> 00:32:31.280
preserve links and anchors when they
actually go to print from Safari.

00:32:36.460 --> 00:32:39.150
In addition, for creation,
a lot of times people have

00:32:39.270 --> 00:32:40.920
wanted to create encrypted PDF.

00:32:40.920 --> 00:32:44.600
This follows the PDF specification
published by Adobe,

00:32:44.970 --> 00:32:47.770
works with a PDF context,
and at creation time,

00:32:47.820 --> 00:32:50.750
you specify a password,
or more than one password,

00:32:50.790 --> 00:32:53.680
and the permissions
associated with the passwords.

00:32:53.700 --> 00:32:55.360
So you can sort of say, "Well,
for this password,

00:32:55.360 --> 00:33:00.090
don't let them print the file,
or don't let them copy anything

00:33:00.090 --> 00:33:05.670
from the file." For the WWDC world,
we support 40-bit encryption,

00:33:05.670 --> 00:33:08.980
and of course,
we expect to extend that up to, I think,

00:33:09.030 --> 00:33:14.920
128, which is part of the
standard in PDF for Tiger.

00:33:15.730 --> 00:33:18.000
Okay, so that's sort of output,
so new things you can do with output.

00:33:18.000 --> 00:33:21.620
For input,
what we've added for Panther was

00:33:21.620 --> 00:33:22.800
something really powerful.

00:33:22.800 --> 00:33:24.960
It lets you sort of introspect
about the document structure.

00:33:24.960 --> 00:33:28.550
A PDF file, you can think about it as
a giant tree of objects.

00:33:28.630 --> 00:33:31.430
And you can use the APIs that
are available in Panther to

00:33:31.560 --> 00:33:34.800
sort of walk through that tree
and look at all the content.

00:33:34.800 --> 00:33:37.140
The one problem is that
the real meat of the file,

00:33:37.140 --> 00:33:40.240
the actual content stream for the page,
which said, you know,

00:33:40.240 --> 00:33:43.270
draw this circle here and put this
text here and draw this circle

00:33:43.300 --> 00:33:45.270
here and put this text over here.

00:33:45.680 --> 00:33:48.220
It was just sort of a big black box.

00:33:48.380 --> 00:33:50.660
You could look at the content,
you could print it out,

00:33:50.660 --> 00:33:52.990
but you couldn't actually
interpret all the pieces of it,

00:33:52.990 --> 00:33:54.340
unless you wrote a parse yourself.

00:33:54.530 --> 00:33:56.800
A little bit less, I don't know,
a little bit less

00:33:56.800 --> 00:33:58.240
attractive for most people.

00:33:58.240 --> 00:34:00.400
And in fact,
it's not something you can just

00:34:00.480 --> 00:34:04.010
sort of read either and sort of
figure out exactly what it all meant.

00:34:04.020 --> 00:34:08.310
So for Tiger,
what we've added is a new way to take

00:34:08.390 --> 00:34:13.820
the content stream itself and parse
through it and call your functions back

00:34:13.820 --> 00:34:15.580
for each operator you're interested in.

00:34:15.590 --> 00:34:18.460
So that way you can
really take for this page,

00:34:18.460 --> 00:34:21.350
look at all the pieces
of the PDF file and get,

00:34:21.350 --> 00:34:25.060
essentially sort of blow up in
the whole file so you can look

00:34:25.060 --> 00:34:27.400
at every bit in the file itself.

00:34:28.120 --> 00:34:30.110
Oh good, glad you like it.

00:34:30.260 --> 00:34:33.160
It's very easy to use.

00:34:33.310 --> 00:34:35.860
The idea here is that for each
operator you're interested in,

00:34:35.860 --> 00:34:37.040
you supply a callback function.

00:34:37.040 --> 00:34:39.620
You can do it for none,
you can do it for all of them,

00:34:39.620 --> 00:34:43.800
and we'll just run through it through the
content stream itself and call you back.

00:34:43.960 --> 00:34:44.560
Here's an example.

00:34:44.560 --> 00:34:46.620
Again, a very simple example.

00:34:46.620 --> 00:34:49.300
The idea here is you create an
operator table where you specify

00:34:49.300 --> 00:34:52.440
both the callback function and
the operator you're interested in.

00:34:52.440 --> 00:34:54.540
In this case,
we're imagining that someone

00:34:54.540 --> 00:34:58.100
wants to look at the BMC operator,
the begin marked content operator.

00:34:58.100 --> 00:35:00.060
Who knows why, they just want to do that.

00:35:00.120 --> 00:35:03.160
You create the content stream, of course,
from the page.

00:35:03.200 --> 00:35:06.000
That's new as well,
where you can get the content stream out

00:35:06.000 --> 00:35:08.000
of the page and create a CG PDF scanner.

00:35:08.000 --> 00:35:10.950
That takes a content stream
that you're interested in,

00:35:10.960 --> 00:35:14.920
the operator table with your callbacks
and an optional info parameter,

00:35:14.920 --> 00:35:17.180
and you call CG PDF scanner scan.

00:35:17.180 --> 00:35:21.120
That will parse through all the PDF,
do all the mucky work inside,

00:35:21.120 --> 00:35:23.390
parsing and so on,
and call back your function.

00:35:23.460 --> 00:35:26.770
So each time it sees a BMC operator,
it calls you with the arguments

00:35:26.770 --> 00:35:30.520
on the stack for the BMC op,
for the sort of the BMC op

00:35:30.640 --> 00:35:32.150
that you're looking at.

00:35:32.220 --> 00:35:33.360
You can do what you might want to do.

00:35:33.360 --> 00:35:35.770
Maybe you're counting the number of
times they appear or something like that.

00:35:35.850 --> 00:35:39.000
When that function returns,
when CG PDF scanner scan returns,

00:35:39.040 --> 00:35:41.040
the full content stream has been parsed.

00:35:41.120 --> 00:35:41.940
So now you're done.

00:35:42.190 --> 00:35:46.280
You release the scanner,
you clean up after yourself,

00:35:46.280 --> 00:35:48.040
and you now have the
information you want.

00:35:48.160 --> 00:35:50.610
So it's actually very simple to use,
doesn't require a lot of work,

00:35:50.690 --> 00:35:52.380
and you can do really
powerful things with it.

00:35:52.690 --> 00:35:55.400
For example,
this is what we use inside of

00:35:55.610 --> 00:36:00.690
Quartz 2D to do both all of our
PDF rendering and the text extraction

00:36:00.770 --> 00:36:01.840
and so on that's part of preview.

00:36:01.840 --> 00:36:04.190
So we use this in two
very different ways,

00:36:04.190 --> 00:36:07.740
but again, it's very powerful with
just very simple API.

00:36:10.050 --> 00:36:18.570
In addition for Tiger,
we now have a new thing called PDF Kit.

00:36:18.600 --> 00:36:20.400
There's a special session devoted to it.

00:36:20.700 --> 00:36:22.390
This is a little bit higher level.

00:36:22.390 --> 00:36:28.960
It's actually what Preview uses
now to do all of its PDF rendering.

00:36:29.140 --> 00:36:32.570
It lets you do things
like do two-up drawing,

00:36:32.570 --> 00:36:37.230
do one-up drawing, do text selection,
and so on, all in your own application.

00:36:37.290 --> 00:36:40.330
It's a cover for a lot of
complicated functions that Preview

00:36:40.330 --> 00:36:42.570
used to only be able to do,
but now you'll be able

00:36:42.600 --> 00:36:43.640
to do with PDF Kit.

00:36:43.900 --> 00:36:46.180
That is something you want
to do if you want to bring

00:36:46.180 --> 00:36:47.860
PDF into your own application.

00:36:47.860 --> 00:36:51.300
A lot of people do text selection,
searching, all that type of thing

00:36:51.390 --> 00:36:54.490
within your own application,
and it's definitely worth attending

00:36:54.880 --> 00:36:57.890
the session right after this
session in a different room.

00:36:59.860 --> 00:37:02.960
Okay, so this is a lot of stuff
that we've added for Tiger.

00:37:02.960 --> 00:37:07.920
We've added some both easy to
use and some advanced path APIs.

00:37:07.920 --> 00:37:10.960
Of course, some new color space APIs,
lots of image support,

00:37:10.960 --> 00:37:14.420
various ways to work with images,
floating point images, of course,

00:37:14.420 --> 00:37:17.070
as well,
and floating point bitmap contexts.

00:37:17.070 --> 00:37:21.620
A better way to get image
data in and out of Quartz 2D.

00:37:21.620 --> 00:37:27.190
New layer support for high efficiency,
high quality off-screen rendering,

00:37:27.190 --> 00:37:29.680
and also a bunch of functions for PDFs.

00:37:29.700 --> 00:37:34.380
So that's sort of the new APIs in Tiger,
the new things you can work with.

00:37:34.380 --> 00:37:39.300
And now John Burkey is going to come
up here and talk about Quartz 2D going

00:37:39.410 --> 00:37:41.800
extreme and what that means for you.

00:37:47.400 --> 00:37:52.240
Hi everybody.

00:37:52.950 --> 00:37:53.880
I'm John Burkey.

00:37:53.880 --> 00:37:58.320
I'm here to talk to you about
Quartz 2D and Quartz Extreme.

00:37:58.320 --> 00:38:00.590
So before I start,
I want to sort of give you an idea of

00:38:00.700 --> 00:38:03.280
what we're going to be talking about.

00:38:03.800 --> 00:38:07.550
I want to talk about the architecture
enough that you get an idea of what

00:38:07.550 --> 00:38:11.440
we're doing so you sort of know what to
watch for when you're doing your apps.

00:38:11.440 --> 00:38:14.760
And then we're going to do some demos
so you'll see that it's real in a

00:38:14.760 --> 00:38:17.560
lot of interesting different ways.

00:38:17.560 --> 00:38:20.100
And then finally we'll be
talking about rules of the road.

00:38:20.100 --> 00:38:23.170
We're ending with that because there's
a lot of very specific things we need

00:38:23.170 --> 00:38:25.800
you to do so that your apps really,
really rock.

00:38:25.830 --> 00:38:28.100
So let's get to it.

00:38:30.070 --> 00:38:31.840
So Quartz Extreme for Tiger.

00:38:31.840 --> 00:38:36.440
The big change is that 2D
is now hardware accelerated.

00:38:36.440 --> 00:38:43.880
The thing for us that was important was
that we needed to maintain Quartz's very,

00:38:43.880 --> 00:38:47.680
very high quality,
but we wanted to speed things up a lot.

00:38:47.680 --> 00:38:52.390
We used the GPU when we can,
we used the CPU when we need to.

00:38:53.640 --> 00:38:59.610
The big thing that we did to start
with before we began this project was

00:38:59.680 --> 00:39:02.190
we analyzed a lot of applications.

00:39:02.200 --> 00:39:05.140
What we did was we made sure
that the things that the

00:39:05.140 --> 00:39:07.380
applications do we worked on first.

00:39:07.460 --> 00:39:11.140
What you'll find as you get your apps
going is that basically all the things

00:39:11.140 --> 00:39:15.850
that your typical application does
are all in hardware and all in GPU,

00:39:15.850 --> 00:39:17.900
so you'll see a lot of speed.

00:39:18.010 --> 00:39:21.800
That's where it will be calling out
as we talk about specific operations.

00:39:21.800 --> 00:39:26.440
Then the less common operations,
things like stroke lines with dashes,

00:39:26.440 --> 00:39:30.610
things like that that are less
common will be accelerating later,

00:39:30.610 --> 00:39:34.580
if at all, because those things
will be coming up very,

00:39:34.830 --> 00:39:35.960
very rarely.

00:39:36.380 --> 00:39:40.980
Importantly, when I say accelerated,
I'm talking about on hardware.

00:39:40.980 --> 00:39:43.740
The other thing we're doing though,
which I think is really exciting,

00:39:43.830 --> 00:39:46.570
is you'll find that software
performance is actually quite

00:39:46.570 --> 00:39:48.100
a bit higher in Tiger as well.

00:39:48.100 --> 00:39:51.540
The reason for that is that as we've
optimized the pipeline for hardware,

00:39:51.540 --> 00:39:54.110
we found a lot of opportunities
to continue to optimize

00:39:54.110 --> 00:39:55.790
the software pipeline too.

00:39:55.800 --> 00:39:58.330
I'm pretty excited about that.

00:39:58.580 --> 00:40:01.860
And worth noting about that,
all the numbers you'll

00:40:01.900 --> 00:40:06.140
have on screen here will be
Tiger software versus hardware.

00:40:06.140 --> 00:40:07.670
You'll find that even
these software numbers,

00:40:07.680 --> 00:40:10.780
as I'm saying,
they're quite a bit higher.

00:40:12.610 --> 00:40:15.800
So here's our Quartz
Extreme architectural diagram.

00:40:15.820 --> 00:40:19.770
And I want to just point out a
couple things just to sort of set

00:40:19.850 --> 00:40:22.860
the idea of what we're talking about.

00:40:22.860 --> 00:40:27.120
We remember that the three big things we
do in the Quartz Extreme engine are we

00:40:27.120 --> 00:40:31.860
deliver 2D video and 3D to the screen.

00:40:31.860 --> 00:40:35.490
We use the GPU and then we see this
word "surfaces," so we use hardware

00:40:35.490 --> 00:40:39.570
surfaces to deliver video and 3D.

00:40:41.300 --> 00:40:47.670
So focusing in on 2D,
there's just a few main concepts.

00:40:47.750 --> 00:40:51.080
So first of all, the application,
as you know, renders into the window.

00:40:51.080 --> 00:40:56.230
We call it the backing store,
the bitmap for the window.

00:40:56.230 --> 00:40:56.230
And then,

00:40:56.420 --> 00:40:57.060
it says flush.

00:40:57.060 --> 00:41:01.710
So when we say flush what we mean
is we talk to Quartz Extreme,

00:41:01.730 --> 00:41:06.580
the Quartz compositor,
and it flushes the content to the screen.

00:41:06.650 --> 00:41:11.710
So what that does is it actually
talks to OpenGL and OpenGL executes

00:41:11.710 --> 00:41:14.780
a flush in behalf of Quartz Extreme.

00:41:14.780 --> 00:41:18.610
So focusing in then,
this is the key point here,

00:41:18.610 --> 00:41:22.560
is that Quartz 2D up until
Tiger was using software,

00:41:22.690 --> 00:41:24.610
it was running with the CPU.

00:41:25.100 --> 00:41:27.750
So we were fill rate limited
by the CPU's performance.

00:41:27.760 --> 00:41:30.830
Our CPUs are really, really great today,
we all know that,

00:41:31.160 --> 00:41:35.020
but still compared to the
GPUs they're more limited.

00:41:35.540 --> 00:41:38.830
Then the great thing about Quartz
Extreme was that we used the

00:41:38.830 --> 00:41:43.320
DMA engine on the graphics cards
to do an asynchronous DMA pull

00:41:43.760 --> 00:41:46.500
of the bits across to the GPU.

00:41:46.560 --> 00:41:49.190
And that's been great because
we get asynchronous behavior and

00:41:49.190 --> 00:41:50.830
the GPU is really good at this.

00:41:50.950 --> 00:41:53.990
So we get a lot of speed as
you know with Quartz Extreme.

00:41:54.990 --> 00:41:57.200
So, that was awesome.

00:41:57.280 --> 00:41:59.990
But there was more to do.

00:42:00.190 --> 00:42:03.730
The first thing that Peter alluded
to in his presentation is that

00:42:03.860 --> 00:42:05.660
GPUs have become this other animal.

00:42:05.660 --> 00:42:10.300
GPUs are now these amazing things
that can do these core image effects,

00:42:10.300 --> 00:42:11.860
you know, blurs,
all these different things.

00:42:11.860 --> 00:42:16.340
And 2D has been isolated from that
part of the capability because we've

00:42:16.340 --> 00:42:20.430
been using it as a blitter to get
our content to the video screen.

00:42:21.160 --> 00:42:24.450
And the other thing is that window
back and stores are very big.

00:42:24.450 --> 00:42:28.310
So, even if the CPU was capable of
writing those pixels into this

00:42:28.310 --> 00:42:31.060
window back and store very,
very quickly,

00:42:31.060 --> 00:42:34.560
we still have to shovel those bits
across the bus to this screen.

00:42:34.560 --> 00:42:36.380
So,
there's still a lot of work to be done.

00:42:36.380 --> 00:42:40.390
And then the last thing is that the
window actually is a synchronization

00:42:40.420 --> 00:42:44.510
bottleneck because while the CPU is
shoveling the bits into the window,

00:42:44.510 --> 00:42:48.500
remember we're DMA flushing from
that same bucket to the screen.

00:42:48.500 --> 00:42:50.480
And so, we don't have tearing.

00:42:50.480 --> 00:42:51.050
They have to work.

00:42:51.160 --> 00:42:51.950
They have to wait for each other.

00:42:51.960 --> 00:42:53.970
And that's what we talk about
when we talk about over flushing.

00:42:53.980 --> 00:42:57.130
So, you'll see that in each of
these cases we have solutions.

00:42:59.720 --> 00:43:02.990
So as I've been saying,
it's all about bytes and bandwidth.

00:43:03.240 --> 00:43:06.330
We're software rendering here,
and this is a great number.

00:43:06.520 --> 00:43:08.520
The G5s really, really rock.

00:43:08.550 --> 00:43:13.000
But it's five gigabytes per second,
and as we know,

00:43:13.020 --> 00:43:15.760
there are other things for
the CPU to do on the system.

00:43:15.760 --> 00:43:17.550
And also,
I'm using these big blocks because

00:43:17.580 --> 00:43:19.040
we're talking about a lot of data.

00:43:19.050 --> 00:43:21.080
Window back stores are huge,
and when you're using

00:43:21.080 --> 00:43:23.260
a software renderer,
there's a lot to do.

00:43:23.270 --> 00:43:25.730
And here we are with the
hardware DMA flushing.

00:43:25.780 --> 00:43:29.500
It's 2.1 gigabytes per second,
but still we're shoveling big boxes,

00:43:29.550 --> 00:43:31.650
you know, there's a lot to do here.

00:43:31.850 --> 00:43:35.600
and finally the bottleneck
in the window back in store.

00:43:35.650 --> 00:43:36.440
Here's the key point.

00:43:36.440 --> 00:43:38.900
Look at that,
30 gigabytes per second and climbing.

00:43:38.920 --> 00:43:41.380
The charts are all pointing
the same direction here.

00:43:41.380 --> 00:43:43.560
You've seen those in
previous presentations.

00:43:43.680 --> 00:43:44.910
So this is our key.

00:43:44.930 --> 00:43:46.200
We want to focus on that.

00:43:46.200 --> 00:43:48.690
That's our deliverer.

00:43:49.940 --> 00:43:52.860
So, here's the punchline then.

00:43:52.860 --> 00:43:53.950
This is our plan, right?

00:43:54.020 --> 00:43:58.970
We want to stop using the CPU and we
want to move towards using the GPU.

00:43:58.980 --> 00:44:01.140
The GPU,
as Peter showed in his presentation,

00:44:01.230 --> 00:44:02.170
has a lot of pipes.

00:44:02.170 --> 00:44:03.040
It's very, very wide.

00:44:03.050 --> 00:44:03.950
It's very good at this.

00:44:03.950 --> 00:44:07.100
And importantly,
by using the two together,

00:44:07.250 --> 00:44:09.860
we can keep the GPU as busy as possible.

00:44:09.860 --> 00:44:14.140
The GPU is a single purpose piece
of equipment for doing graphics.

00:44:14.140 --> 00:44:18.660
So, by keeping the CPU as its pipeline,
we can keep it really busy.

00:44:20.540 --> 00:44:23.090
So, what does this mean?

00:44:23.200 --> 00:44:27.160
It means the backing store
is no longer in DRAM.

00:44:27.300 --> 00:44:29.160
So where does it go?

00:44:29.260 --> 00:44:31.340
It goes to the graphics chip.

00:44:32.990 --> 00:44:44.860
OpenGL, we work with OpenGL to deliver
things to the hardware.

00:44:44.860 --> 00:44:44.860
And this gets pretty interesting here.

00:44:46.730 --> 00:44:48.800
I'm not good at clicking.

00:44:48.820 --> 00:44:52.020
OpenGL commands are very small,
hence the small purple boxes.

00:44:52.040 --> 00:44:54.730
That's the key point here for this
part is that we're delivering a

00:44:54.730 --> 00:44:58.460
lot less bytes across the bus,
and this is a very optimal stream.

00:44:58.460 --> 00:45:00.160
The OpenGL guys have worked very hard.

00:45:00.160 --> 00:45:03.780
As you know, our gaming engines today
deliver millions of polygons,

00:45:03.940 --> 00:45:06.100
so that's what we're talking about here.

00:45:06.190 --> 00:45:07.810
We're using a very tight stream.

00:45:09.600 --> 00:45:11.000
And then uploads, and this is important.

00:45:11.000 --> 00:45:14.940
We'll be focusing on this issue a lot
as we go forward in the presentation.

00:45:14.980 --> 00:45:17.980
Uploads are very infrequent,
and we will be working

00:45:17.980 --> 00:45:19.930
together to ensure that.

00:45:20.320 --> 00:45:22.160
They're much smaller than
window backing stores,

00:45:22.300 --> 00:45:23.340
very key point, right?

00:45:23.340 --> 00:45:27.750
The Aqua artwork, and some would fill a
quarter of a screen,

00:45:27.750 --> 00:45:31.140
but we fill the whole
backing store with it.

00:45:31.200 --> 00:45:32.380
So that's the point.

00:45:32.380 --> 00:45:34.750
As we upload the artwork
across and reuse it,

00:45:34.750 --> 00:45:36.230
we have less to do there.

00:45:37.810 --> 00:45:43.940
Then finally, this is great,
back to the flushing bottleneck, with the

00:45:44.980 --> 00:45:47.920
The window back in store on the GPU,
the flushes are occurring

00:45:47.920 --> 00:45:48.730
all on hardware.

00:45:48.930 --> 00:45:52.670
We're running two hardware with
the small commands and then all

00:45:52.670 --> 00:45:53.790
the flushes are all on hardware.

00:45:53.890 --> 00:45:56.740
So that whole flushing
bottleneck just goes puff.

00:45:56.810 --> 00:45:57.900
So that's really, really great.

00:45:57.900 --> 00:45:59.900
It's a key to our performance.

00:45:59.900 --> 00:46:03.070
So, how does it look like?

00:46:03.880 --> 00:46:04.560
looks pretty good.

00:46:04.560 --> 00:46:07.040
This is pretty amazing to me.

00:46:07.040 --> 00:46:10.080
I work with this stuff every day,
but I'm always astounded by how much

00:46:10.080 --> 00:46:12.030
performance you can get from the system.

00:46:12.040 --> 00:46:14.510
What's amazing is this
is still CPU limited.

00:46:14.510 --> 00:46:17.610
As fast as I can shovel
stuff with present-day CPUs,

00:46:17.710 --> 00:46:20.280
I can still shovel it
faster in the future.

00:46:20.430 --> 00:46:23.430
And what you'll see then as you
test it yourselves is you'll see

00:46:23.550 --> 00:46:28.420
that performance will scale more in
hardware as your CPU gets faster.

00:46:28.420 --> 00:46:33.030
So we have numbers where the alliance
performance scaled between my

00:46:33.050 --> 00:46:36.780
PowerBook and the G5 number that's here,
it scaled by like 3 or

00:46:36.890 --> 00:46:40.370
4x when I went to the G5,
and it only scaled by 2x,

00:46:40.370 --> 00:46:42.620
the sort of the CPU normal number.

00:46:42.620 --> 00:46:44.200
So I think it's really interesting.

00:46:46.360 --> 00:46:47.980
I want to call it a couple things.

00:46:48.120 --> 00:46:49.590
This is about fill rate here.

00:46:49.660 --> 00:46:51.940
The point here is that
with the big rectangle,

00:46:51.940 --> 00:46:55.600
we're not limited by fill rates still,
so we're really, really fast.

00:46:55.600 --> 00:46:59.380
That's important because this is what
we do first when we render a window.

00:46:59.380 --> 00:47:00.580
We fill it with stuff.

00:47:00.580 --> 00:47:01.780
So that's important.

00:47:01.780 --> 00:47:03.570
Text rendering is very important.

00:47:03.670 --> 00:47:06.390
There's been a lot of discussion
on the net about that,

00:47:06.400 --> 00:47:08.080
and I just wanted to call it out.

00:47:08.080 --> 00:47:09.880
We're really working hard on this.

00:47:09.930 --> 00:47:12.880
We actually spent a lot of man
months on making this great,

00:47:12.880 --> 00:47:16.270
and we're basically almost
breaking 5 million here.

00:47:16.300 --> 00:47:18.490
here, so that's really great.

00:47:18.930 --> 00:47:21.170
And then lines,
this is something we'll be

00:47:21.230 --> 00:47:22.270
talking about today in detail.

00:47:22.280 --> 00:47:25.660
We have a new API to really make
that easier for you to deliver a lot

00:47:25.660 --> 00:47:28.650
of line performance on your machine.

00:47:30.940 --> 00:47:34.640
So, sort of defocusing here,
stepping back one step,

00:47:34.790 --> 00:47:39.230
here's PDF rendering,
which is a user of the core primitives.

00:47:39.250 --> 00:47:44.660
And what you see here is that there's
two documents here and two different

00:47:44.670 --> 00:47:46.140
ways of rendering the same documents.

00:47:46.140 --> 00:47:50.020
On the top of the screen is
a core graphics benchmark,

00:47:50.020 --> 00:47:53.500
and we're getting about 2x,
2.2x with that.

00:47:53.500 --> 00:47:56.920
We're getting the same values below,
they're about twice as fast,

00:47:56.930 --> 00:48:00.340
a little bit less, but quite a bit slower
when it's in preview.

00:48:00.800 --> 00:48:03.880
And that's okay because preview
is an application that has

00:48:03.930 --> 00:48:05.660
to do annotations and stuff.

00:48:05.660 --> 00:48:08.680
You know, some of us are speed freaks,
but there's a lot of really great value

00:48:08.680 --> 00:48:11.930
that's delivered by the higher end apps,
so it's not always about that.

00:48:12.160 --> 00:48:16.110
Also, I wanted to point out that,

00:48:17.000 --> 00:48:18.880
I'll move on, I don't remember.

00:48:18.960 --> 00:48:22.780
So anyway, application resizing,
this is a very interesting

00:48:22.780 --> 00:48:25.330
slide for those of you who are
focusing in on the numbers.

00:48:25.500 --> 00:48:28.880
So see the red,
this is something that we're using

00:48:28.880 --> 00:48:32.360
as a reminder for you when we go
into the rules of the road section.

00:48:32.520 --> 00:48:35.800
So we have lots of speed here,
but it's sort of varying,

00:48:35.820 --> 00:48:38.900
and sometimes the blue line
is the hardware number.

00:48:38.900 --> 00:48:40.700
It's actually slower.

00:48:40.950 --> 00:48:43.290
So this is the thing,
is some of these applications aren't

00:48:43.290 --> 00:48:44.620
caching their image refs still.

00:48:44.660 --> 00:48:47.820
We all work together at Apple,
but we're all still pitching in.

00:48:47.820 --> 00:48:49.110
We're not shipping Tiger yet.

00:48:49.300 --> 00:48:52.540
So we thought it was great to
show you some of these cases

00:48:52.770 --> 00:48:55.260
where our apps are slower too,
and to call this out.

00:48:55.270 --> 00:48:57.620
And I'll have a demo
that explains this too.

00:48:57.750 --> 00:48:59.920
So again,
you see the number on the bottom,

00:48:59.940 --> 00:49:01.730
text edit is crazy fast.

00:49:01.750 --> 00:49:03.180
That's frames per second.

00:49:03.190 --> 00:49:05.220
You actually have to turn off
beam sync on your monitors to

00:49:05.220 --> 00:49:07.640
even take this measurement,
'cause it's just a big

00:49:07.640 --> 00:49:08.800
flickery craziness.

00:49:08.800 --> 00:49:10.510
I'll show you that in a minute,
it's pretty neat.

00:49:10.660 --> 00:49:15.460
So the key is, is as we move forward,
you'll start to experience more

00:49:15.460 --> 00:49:18.240
and more of this performance,
because as I showed you, the benchmarks,

00:49:18.240 --> 00:49:21.890
the core primitives you're
actually using are fast.

00:49:22.950 --> 00:49:24.630
So this is great, I think.

00:49:24.700 --> 00:49:27.580
This means we can deliver,
and this is my experience in bringing

00:49:27.580 --> 00:49:31.120
apps up and looking around the system
and what they're bottlenecked on.

00:49:31.120 --> 00:49:35.780
We should experience 2X across the
board with GUI performance for Tiger.

00:49:42.690 --> 00:49:44.240
So, yeah, can I have demo machine?

00:49:44.260 --> 00:49:47.960
Not that one.

00:49:47.980 --> 00:49:52.390
Okay, so.

00:49:52.940 --> 00:49:54.360
For the first one,
I'm just going to show you

00:49:54.360 --> 00:49:56.820
a little finder performance.

00:49:56.970 --> 00:49:57.400
That's pretty fast.

00:49:57.540 --> 00:49:58.370
It looks good.

00:49:58.520 --> 00:50:03.290
And then here's a little-- make sure,
yeah, good.

00:50:04.930 --> 00:50:08.240
Here's a little even faster.

00:50:08.380 --> 00:50:10.140
So that's all good.

00:50:10.140 --> 00:50:11.840
There's a lot of light little demos.

00:50:11.880 --> 00:50:14.650
Just started to give you a flavor
for what we're talking about.

00:50:14.850 --> 00:50:16.610
Here's Safari.

00:50:19.890 --> 00:50:22.780
So it's getting pretty fast.

00:50:22.780 --> 00:50:28.180
I'll show you here with it off.

00:50:31.230 --> 00:50:34.410
You'll see that it's still fast,
but it's a little slower.

00:50:34.470 --> 00:50:38.430
This number is about 1.5x,
and so we're pretty happy

00:50:38.510 --> 00:50:41.110
with that for where we are.

00:50:41.110 --> 00:50:44.620
Here's one of the flickery crazy ones.

00:50:44.620 --> 00:50:47.350
Let me make sure I'm set here.

00:50:52.590 --> 00:50:54.950
So that number,
you can actually-- one of the

00:50:54.950 --> 00:50:55.780
guys on the team taught me this.

00:50:55.880 --> 00:50:58.780
You can measure by the amount of
tears you see what the frame rate is.

00:50:58.820 --> 00:51:01.130
But we're looking at around 200 here,
so that's really great.

00:51:01.260 --> 00:51:08.560
This is an interesting one.

00:51:14.110 --> 00:51:15.440
Actually, did I do that right?

00:51:15.480 --> 00:51:24.400
So here's a Java app,
which is cool because--

00:51:25.700 --> 00:51:27.690
They just told me they were
doing this little demo,

00:51:27.690 --> 00:51:29.750
and so we grabbed it to
see what it looked like.

00:51:29.750 --> 00:51:30.430
It's kind of cute.

00:51:30.520 --> 00:51:33.620
What it does is it tries to render as
many balls and keep the frame rate at 30.

00:51:33.620 --> 00:51:37.180
So you can see...

00:51:38.190 --> 00:51:42.220
With hardware, with this great G5,
we can do 432 balls per second.

00:51:42.220 --> 00:51:44.220
It's a new benchmark
number of balls per second.

00:51:44.220 --> 00:51:48.060
Great.

00:51:48.060 --> 00:51:50.510
But now when we turn on hardware,

00:51:52.020 --> 00:51:54.640
This is actually with no
code changes from them.

00:51:54.660 --> 00:51:58.730
They're still-- I'm working with them to
crank up their pipe a little bit more.

00:51:58.790 --> 00:52:01.480
I still got beam sync off,
so that's why it's a little hairy.

00:52:01.500 --> 00:52:04.890
But anyway, we'll keep going.

00:52:06.790 --> 00:52:09.090
So it should float up there
about 3x of what software was.

00:52:09.220 --> 00:52:10.480
That's really great.

00:52:10.490 --> 00:52:12.770
Is there quite a-- there's quite
a deep pipeline here to get the

00:52:12.860 --> 00:52:14.450
code from Java all the way down.

00:52:14.490 --> 00:52:16.230
That's pretty sweet.

00:52:21.950 --> 00:52:24.770
So here's our friend the wireframe.

00:52:25.060 --> 00:52:28.030
This is an important demo to us because
this is something Joseph Marr has been

00:52:28.030 --> 00:52:32.280
using for quite a few years to talk about
performance in Quick Draw and Mac OS 9.

00:52:32.280 --> 00:52:35.370
And part of our message to you is
we take this very seriously when

00:52:35.470 --> 00:52:38.750
you tell us that you need better
performance in these areas so that

00:52:38.760 --> 00:52:40.450
you can switch over to Quartz.

00:52:40.500 --> 00:52:42.180
So this is a big deal for us.

00:52:42.180 --> 00:52:46.220
So you can see already with
Quartz software performance,

00:52:46.220 --> 00:52:48.190
things are looking great.

00:52:48.190 --> 00:52:50.820
1.3 million on a G5,
that's pretty damn amazing.

00:52:52.180 --> 00:52:53.030
And then...

00:52:54.700 --> 00:53:20.600
[Transcript missing]

00:53:22.140 --> 00:53:26.320
Okay, so this is sort of
back to kind of pseudo,

00:53:26.400 --> 00:53:29.640
this is going to get us
into the rules of the road,

00:53:29.770 --> 00:53:32.650
so pay attention to this one
in sort of a different way.

00:53:32.660 --> 00:53:35.530
Let me make sure I do this right.

00:53:40.340 --> 00:53:43.960
Okay, so software, hardware, really,
really great.

00:53:43.960 --> 00:53:45.160
That number's like 20x.

00:53:48.480 --> 00:53:52.120
And then, oops.

00:53:52.120 --> 00:53:54.020
Now, so what about this?

00:53:54.020 --> 00:53:56.160
This is strange behavior.

00:53:56.160 --> 00:53:57.960
This is hardware with no caching.

00:53:58.000 --> 00:54:00.230
Look at that frame rate.

00:54:00.230 --> 00:54:00.230
Woo!

00:54:00.270 --> 00:54:05.430
So this is our first example of how
we need to be compliant with our API.

00:54:05.640 --> 00:54:07.280
The good news is there's
not a new message here,

00:54:07.280 --> 00:54:11.770
just we actually need you to be
compliant now so your app rocks.

00:54:13.610 --> 00:54:16.410
So here's scaling performance.

00:54:16.430 --> 00:54:17.920
G5s do great.

00:54:17.920 --> 00:54:19.130
That's three times
higher than my PowerBook.

00:54:19.180 --> 00:54:20.040
That's nice.

00:54:20.070 --> 00:54:21.780
So here's hardware.

00:54:21.780 --> 00:54:23.360
Woo!

00:54:23.440 --> 00:54:29.320
So-- all right.

00:54:29.320 --> 00:54:31.030
Back to slides.

00:54:35.800 --> 00:54:41.900
[Transcript missing]

00:54:44.010 --> 00:54:45.740
Caching.

00:54:45.770 --> 00:54:48.580
This is the important thing.

00:54:48.740 --> 00:54:50.880
This is sort of a typical command
stream you just saw go by.

00:54:51.140 --> 00:54:54.550
It contains some commands and contains
some resources to be uploaded.

00:54:54.720 --> 00:54:58.930
We're just showing this cute little
picture of a resource being cached.

00:54:59.860 --> 00:55:03.120
So now we light it up because
we're going to reuse the resource

00:55:03.120 --> 00:55:05.560
and see it was all little blocks.

00:55:05.640 --> 00:55:07.040
That's the technical term.

00:55:07.050 --> 00:55:11.160
And what we want to focus on is
making lots of little blocks.

00:55:11.260 --> 00:55:13.960
So we want our resources to be cached.

00:55:13.960 --> 00:55:16.370
We want to reuse our resources.

00:55:16.780 --> 00:55:19.400
And here's another one.

00:55:19.400 --> 00:55:23.010
So, you know, the point is,
this is the kind of behavior you'll see.

00:55:23.010 --> 00:55:25.880
A lot of the things you'll be doing,
there'll be a nice clean command pipe,

00:55:25.960 --> 00:55:29.650
and then the idea is that rarely
you'll be also doing resource uploads.

00:55:32.130 --> 00:55:36.630
So using vramdiv room.

00:55:36.680 --> 00:55:40.360
This is actually, I think,
a nice simple story for you.

00:55:40.520 --> 00:55:42.300
Everything is automatic.

00:55:42.300 --> 00:55:45.630
All you need to do is use
the retain release semantic

00:55:45.720 --> 00:55:47.420
that's in core foundation.

00:55:47.430 --> 00:55:49.940
And if you do that,
what you're doing is volunteering to

00:55:49.940 --> 00:55:51.860
be a part of our caching strategy.

00:55:51.860 --> 00:55:54.190
Importantly,
what you're not doing is volunteering

00:55:54.230 --> 00:55:57.680
to have all of your images
put on the card all the time.

00:55:57.690 --> 00:56:01.130
What we'll do for you behind the
scenes is dynamically take care of that

00:56:01.250 --> 00:56:04.510
to make sure that we're not putting
too much up there or too little.

00:56:04.650 --> 00:56:07.080
So that takes away that
worry that you have of,

00:56:07.080 --> 00:56:10.600
oh, I've got to retain just the right
amount so that my app doesn't freak out.

00:56:10.620 --> 00:56:12.450
What you need to do is just
retain all your image refs,

00:56:12.480 --> 00:56:13.940
all your pattern refs,
all your color refs,

00:56:13.940 --> 00:56:15.280
all the things you're using.

00:56:15.300 --> 00:56:17.720
And again, that's how we know,
because we can see that.

00:56:17.740 --> 00:56:19.380
And we can see the hardware you're on.

00:56:19.400 --> 00:56:22.360
And what we'll do is
take care of the rest.

00:56:23.960 --> 00:56:26.810
So in a typical picture, here's Finder.

00:56:26.960 --> 00:56:29.300
We have images and patterns.

00:56:30.410 --> 00:56:33.980
Text, lines, rectangles,
these are the primitives

00:56:33.980 --> 00:56:35.700
that I gave the numbers on.

00:56:35.950 --> 00:56:39.020
In a typical case,
that will be everything on the screen.

00:56:39.020 --> 00:56:40.540
We'll take care of everything there.

00:56:40.540 --> 00:56:41.900
We refer to that as a visual working set.

00:56:41.900 --> 00:56:48.980
The idea here is that you have this
set of resources you'll be using and

00:56:48.980 --> 00:56:48.980
those will sort of stay cached for you.

00:56:51.330 --> 00:56:53.020
So, rules of the road.

00:56:53.020 --> 00:56:56.200
This is the big one, cache your refs.

00:56:56.200 --> 00:56:57.800
This isn't exactly how
it would look for you,

00:56:57.800 --> 00:56:59.980
but you get the point, right?

00:56:59.980 --> 00:57:02.140
Here in the first top part,
we have a loop,

00:57:02.140 --> 00:57:04.600
and every time through the
loop we do the cheesy thing,

00:57:04.600 --> 00:57:08.380
bad thing, which is make an image ref,
render it, and then release it.

00:57:08.380 --> 00:57:09.380
Don't do that.

00:57:09.480 --> 00:57:12.760
Instead, some port in your code where
you're loading your images,

00:57:12.760 --> 00:57:15.280
whatever you're doing,
create your images, hold onto 'em.

00:57:15.400 --> 00:57:16.300
That's your cache.

00:57:16.300 --> 00:57:18.060
Your cache is to hold refs.

00:57:18.060 --> 00:57:20.080
Your cache is not to hold bits.

00:57:20.080 --> 00:57:21.380
If you want to hold bits, that's fine.

00:57:21.470 --> 00:57:23.710
Just hold the rest with them.

00:57:24.190 --> 00:57:26.730
And then, as many times you want
to render the image,

00:57:26.740 --> 00:57:27.670
render the image.

00:57:27.710 --> 00:57:31.070
Just don't do what you
did up above there.

00:57:31.510 --> 00:57:35.100
So layers, great new strategy.

00:57:35.230 --> 00:57:39.640
They're hardware accelerated
bitmaps and bitmap contexts.

00:57:39.640 --> 00:57:40.330
They're very easy to use.

00:57:40.440 --> 00:57:42.440
The key point is, again, they're dynamic.

00:57:42.480 --> 00:57:44.530
We'll make as many of them
hardware accelerated as we can

00:57:44.530 --> 00:57:48.580
based on the card you have,
what you're asking us to do otherwise.

00:57:48.580 --> 00:57:50.640
And they're really easy to use.

00:57:50.640 --> 00:57:56.310
I really like how the guys did this
because they're actually easier to use

00:57:56.380 --> 00:57:58.660
than the old bitmap context anyway.

00:57:58.660 --> 00:57:58.660
So these are great.

00:57:58.870 --> 00:58:01.170
Importantly, right,
bitmap contexts always have to

00:58:01.230 --> 00:58:07.560
go across the bus and layers will
be in hardware whenever possible.

00:58:08.400 --> 00:58:12.340
So here's one of our
new performance APIs.

00:58:12.340 --> 00:58:15.620
The key point here is
you see the top here,

00:58:15.630 --> 00:58:16.960
good and bad.

00:58:16.960 --> 00:58:20.610
This looks like nice clean code,
just that by iterating a loop like

00:58:20.610 --> 00:58:23.420
that and giving us one line at a time,
we have to create a lot of

00:58:23.600 --> 00:58:27.300
temporary storage to handle
anything you might give us.

00:58:27.300 --> 00:58:30.740
With the second one here,
you tell us how big your storage is

00:58:30.740 --> 00:58:32.200
and you give it to us all at once.

00:58:32.200 --> 00:58:35.410
So in actuality,
with the hardware renderer,

00:58:35.420 --> 00:58:38.340
it basically doesn't get touched
until we're ready to talk to GL.

00:58:38.370 --> 00:58:40.290
So that's very powerful.

00:58:41.680 --> 00:58:42.900
Here's a Rex case.

00:58:42.970 --> 00:58:48.400
This API has existed for a while,
but we're encouraging to use it more.

00:58:48.400 --> 00:58:49.680
Same thing, right?

00:58:49.800 --> 00:58:53.280
Store it all at once, tell us the number,
it travels all the way

00:58:53.280 --> 00:58:55.030
through the system.

00:58:56.010 --> 00:58:57.530
Don't cache your caches.

00:58:57.600 --> 00:59:00.800
This is another thing that we found
working with the operating system people.

00:59:00.980 --> 00:59:04.980
We'll find there's a lot of caches
around for different reasons.

00:59:05.170 --> 00:59:07.400
Rendering has changed a
lot in the last few years,

00:59:07.510 --> 00:59:09.660
so some things are faster
than they used to be.

00:59:09.660 --> 00:59:11.930
This is the key point.

00:59:12.000 --> 00:59:12.730
Check your caches.

00:59:12.870 --> 00:59:14.840
We've all got them.

00:59:14.840 --> 00:59:19.530
And try turning them off
and see if they still help.

00:59:19.640 --> 00:59:20.600
They might not anymore.

00:59:20.600 --> 00:59:20.600
So that's what I'm talking about here.

00:59:23.150 --> 00:59:25.240
Also very important,
this is an awesome session.

00:59:25.240 --> 00:59:30.160
The Shark technology we have is one
of the best technologies that's come

00:59:30.160 --> 00:59:32.530
out of Apple in the last five years.

00:59:33.180 --> 00:59:35.590
This might sound silly, but really,
really,

00:59:35.590 --> 00:59:39.340
really measure your app before you
think you know what it's doing.

00:59:39.340 --> 00:59:41.060
It will look very different
with hardware acceleration,

00:59:41.060 --> 00:59:41.940
number one.

00:59:41.970 --> 00:59:44.970
And number two, as you know,
the scale of applications has

00:59:44.970 --> 00:59:46.930
really grown in the last 10 years.

00:59:47.170 --> 00:59:49.680
So we need to measure our stuff
and then simplify the scenario

00:59:49.680 --> 00:59:52.180
that you're measuring until
you're sure you understand it.

00:59:52.440 --> 00:59:53.400
Then you know what to do.

00:59:53.400 --> 00:59:55.490
That way you're working
on the right stuff.

00:59:57.220 --> 00:59:58.620
So this one's important to me.

00:59:58.850 --> 01:00:04.820
I used Quickdraw for a long part of
my career and I really appreciated

01:00:04.820 --> 01:00:10.420
Joseph Mara and Mike Brinkovich working
hard to make this run great on 10.

01:00:10.490 --> 01:00:14.590
But here's the deal, Quickdraw,
as we're saying here,

01:00:14.590 --> 01:00:19.080
it's too fragile and undocumented.

01:00:19.110 --> 01:00:22.100
It's just got a lot of funny
stuff about it from the past.

01:00:22.100 --> 01:00:24.280
Now's the time where we
all have to say goodbye.

01:00:24.280 --> 01:00:26.280
This is the key point for us.

01:00:27.190 --> 01:00:28.100
We're faced with this.

01:00:28.100 --> 01:00:31.100
So if Quickdraw is rendered in a window,
we're going to turn off

01:00:31.200 --> 01:00:32.620
hard work celebration.

01:00:32.620 --> 01:00:36.530
So that's what we ended up with.

01:00:38.690 --> 01:00:40.600
So, more good news.

01:00:40.620 --> 01:00:43.060
It's really easy to turn on.

01:00:43.060 --> 01:00:44.110
You've seen a bunch of demos here.

01:00:44.250 --> 01:00:45.470
You have the stuff in your computer.

01:00:46.010 --> 01:00:49.360
Command D.

01:00:49.360 --> 01:00:51.550
It's right here and you
see that it's listed there.

01:00:51.550 --> 01:00:57.050
Also, importantly,
only some of our products

01:00:57.050 --> 01:01:00.020
support Quartz Extreme with 2D.

01:01:00.020 --> 01:01:01.710
These are the ones.

01:01:01.740 --> 01:01:03.580
The key is this fragment program stuff.

01:01:03.670 --> 01:01:06.680
We have a very modern new
graphics pipeline and we're taking

01:01:06.680 --> 01:01:08.580
advantage of these new features.

01:01:08.720 --> 01:01:11.100
so we actually do need them.

01:01:15.630 --> 01:01:17.290
So final thoughts.

01:01:17.360 --> 01:01:18.560
First, core imaging.

01:01:18.560 --> 01:01:19.840
It's a great new technology.

01:01:19.840 --> 01:01:22.600
It works with us very well.

01:01:22.600 --> 01:01:24.490
We support it as a real image.

01:01:24.500 --> 01:01:25.250
This is the link.

01:01:25.350 --> 01:01:28.140
It was one of those top secret sessions,
so I wanted to make sure you

01:01:28.140 --> 01:01:29.540
saw where it was when it was.

01:01:29.630 --> 01:01:32.560
It's actually very soon now.

01:01:32.560 --> 01:01:33.720
This is really great, though.

01:01:33.720 --> 01:01:36.830
You can make an image using their APIs,
and it'll be clipped with

01:01:36.830 --> 01:01:38.390
our clipping and everything.

01:01:38.500 --> 01:01:39.370
So it's really great.

01:01:39.460 --> 01:01:41.000
It fits right in.

01:01:41.540 --> 01:01:43.070
And then here's the rest.

01:01:43.230 --> 01:01:48.750
So the whole system is now
hardware accelerated and

01:01:49.070 --> 01:01:52.380
This enables us to do a lot
of really amazing things.

01:01:52.380 --> 01:01:58.760
So there's going to be a lot
of great things in the future.

01:01:58.760 --> 01:02:00.380
Here's our mailing list.

01:02:00.380 --> 01:02:02.880
We love discussion.

01:02:07.100 --> 01:02:10.220
And we've got documentation
from the Quartz team.

01:02:10.520 --> 01:02:11.400
Amazing.

01:02:11.400 --> 01:02:14.020
So we have two different documents.

01:02:14.100 --> 01:02:18.680
A lot of people are working
really hard on these.

01:02:18.680 --> 01:02:20.340
And this is where you can find them.

01:02:20.340 --> 01:02:24.080
They're actually on your computers.

01:02:24.080 --> 01:02:24.790
And I'd like to bring up Travis.

01:02:24.790 --> 01:02:25.860
He's going to lead Q&A.
WEBVTT

00:00:12.300 --> 00:00:14.950
Ladies and gentlemen,
please welcome Quartz

00:00:14.950 --> 00:00:19.140
Engineering Manager,
Haroon Sheikh.

00:00:23.510 --> 00:00:27.300
Welcome to the last day of WWDC.

00:00:27.300 --> 00:00:29.930
It's almost over.

00:00:29.940 --> 00:00:35.590
We've got a really important
session for you today.

00:00:35.590 --> 00:00:37.700
It's really going to be important if
you're using QuickDraw on Mac OS X.

00:00:37.900 --> 00:00:41.000
So if you haven't heard already,
let me go right to the point.

00:00:41.060 --> 00:00:48.600
We are officially deprecating QuickDraw
and we are replacing it with Quartz 2D.

00:00:48.650 --> 00:00:52.710
Now, QuickDraw has served us quite
well for the last 20 plus years.

00:00:53.460 --> 00:00:58.300
It has been instrumental in
the GUI revolution in the 80s.

00:00:58.300 --> 00:01:00.090
It was really innovative for its time.

00:01:00.090 --> 00:01:07.280
It introduced many interesting
ideas and features such as regions,

00:01:07.420 --> 00:01:08.070
patterns.

00:01:08.070 --> 00:01:12.920
We introduced PIX with it,
with the display manager.

00:01:12.980 --> 00:01:17.290
We introduced seamless
multi-monitor support.

00:01:18.330 --> 00:01:20.730
And with Color QuickDraw,
we actually introduced a

00:01:20.730 --> 00:01:23.200
seamless transition to color.

00:01:23.250 --> 00:01:26.000
One of the other important
things with QuickDraw was that

00:01:26.000 --> 00:01:28.240
it was fast and efficient.

00:01:29.840 --> 00:01:34.130
But unfortunately, it is no longer a
competitive 2D graphics API.

00:01:34.220 --> 00:01:39.100
And our applications,
our users expect a really rich

00:01:39.100 --> 00:01:41.700
graphics API on the platform.

00:01:41.900 --> 00:01:46.940
And so some of the things that are
missing from it are Bezier curve support,

00:01:46.990 --> 00:01:49.710
alpha support, built-in color management.

00:01:49.750 --> 00:01:52.620
We've got color sync,
but it's not built in.

00:01:52.840 --> 00:01:54.790
It's not thread safe.

00:01:55.590 --> 00:01:59.330
Some of the assumptions
that QuickDraw was built on,

00:01:59.330 --> 00:02:01.080
or some of the design
goals that it was built on,

00:02:01.120 --> 00:02:04.290
are now starting to show up as
limitations in your application.

00:02:04.380 --> 00:02:10.160
So the coordinate system is
limited to 16-bit integers.

00:02:10.180 --> 00:02:15.010
The resolution itself
is limited to 72 DPI.

00:02:15.370 --> 00:02:20.410
and going forward with resolution
independence in the future,

00:02:20.590 --> 00:02:24.420
that's going to become a
real bottleneck for us.

00:02:24.440 --> 00:02:29.820
And one of the signs that it is no
longer competitive is you'll notice

00:02:29.910 --> 00:02:34.550
that applications are using QuickDraw
as nothing more than a blit engine

00:02:35.060 --> 00:02:39.830
because they've got their own graphics
engine doing their own rendering and

00:02:39.840 --> 00:02:43.450
at the end of it they just end up using
QuickDraw for blitting to the screen.

00:02:45.670 --> 00:02:51.420
In our development of Mac OS X and
bringing QuickDraw over to Mac OS X,

00:02:51.510 --> 00:02:56.200
Since Jaguar, Panther, we've noticed,
you know,

00:02:56.200 --> 00:03:01.740
we've been fixing bugs inside of
QuickDraw for a particular application.

00:03:01.750 --> 00:03:07.530
But just fixing that one bug would end up
breaking potentially other applications.

00:03:07.640 --> 00:03:10.530
So we recognize that QuickDraw
has now become fragile.

00:03:10.540 --> 00:03:13.060
And for us,
maintaining binary compatibility

00:03:13.390 --> 00:03:18.180
with your applications has become
quite a bit of a challenge.

00:03:18.390 --> 00:03:22.740
So even though bug fixing
is a problem for us,

00:03:22.740 --> 00:03:25.450
we can't really add some of the
features that I talked about earlier

00:03:25.650 --> 00:03:27.530
on the previous slide into QuickDraw.

00:03:27.610 --> 00:03:30.050
So we really can't extend it anymore.

00:03:30.100 --> 00:03:33.000
And we've decided we're no
longer going to be working on it.

00:03:33.000 --> 00:03:36.550
We may fix a bug here or there,
but there's no active development on it

00:03:36.550 --> 00:03:38.930
in terms of adding new features to it.

00:03:39.030 --> 00:03:43.770
So it's no longer feature-proof,
implying that we'll no longer integrate

00:03:43.770 --> 00:03:47.480
it with new features in the system.

00:03:48.050 --> 00:03:50.050
It will continue to
function the way it is,

00:03:50.140 --> 00:03:53.860
as you've expected to,
but it will not be integrated with the

00:03:53.860 --> 00:03:55.790
rest of the new innovative technologies.

00:03:58.180 --> 00:04:01.090
On the Converse side,
you've got Quartz 2D,

00:04:01.090 --> 00:04:05.100
where it is a very rich graphics API.

00:04:05.560 --> 00:04:09.290
It is based on an
industry-proven imaging model.

00:04:10.100 --> 00:04:13.170
By design, it is actually resolution
and device independent.

00:04:13.320 --> 00:04:17.610
And we've got built-in support for alpha,
alpha channels on images.

00:04:17.670 --> 00:04:19.990
And for rector art,
we've got transparency

00:04:20.070 --> 00:04:23.280
support and alpha there also.

00:04:23.340 --> 00:04:25.180
It is designed to be thread safe.

00:04:25.240 --> 00:04:26.800
It has a really rich feature set.

00:04:26.880 --> 00:04:28.150
I list many of those things.

00:04:28.160 --> 00:04:31.980
And if you've been at any of the Quartz
2D sessions this year or in past WWDCs,

00:04:31.980 --> 00:04:34.030
you know what I'm talking about.

00:04:34.140 --> 00:04:37.900
And it also has a floating
point coordinate system.

00:04:38.930 --> 00:04:42.400
It integrates very well
with other technologies.

00:04:42.460 --> 00:04:47.800
For example, we've got ColorSync's color
management built into Quartz 2D.

00:04:48.200 --> 00:04:53.000
And this year with Core Image,
you can actually take advantage

00:04:53.000 --> 00:04:54.630
of Core Image with Quartz 2D.

00:04:54.710 --> 00:04:57.770
It's directly integrated
with that new technology.

00:04:59.840 --> 00:05:03.690
Quartz 2D is also now, you know,
hardware accelerated

00:05:03.700 --> 00:05:06.190
through Quartz Extreme.

00:05:06.190 --> 00:05:09.310
And all of these points
come up with one conclusion.

00:05:09.320 --> 00:05:13.600
This is the API that you want to be using
if you want to be feature compatible.

00:05:15.190 --> 00:05:17.530
So I just want to show you this graph.

00:05:17.540 --> 00:05:20.280
You may have seen it
in the previous WWDCs.

00:05:20.300 --> 00:05:23.160
But the concept here,
I just want to get one

00:05:23.160 --> 00:05:25.120
major point out of this.

00:05:25.280 --> 00:05:28.280
The numbers are not necessarily accurate,
but they are there to give

00:05:28.420 --> 00:05:29.740
you a particular point.

00:05:29.740 --> 00:05:32.110
And that is,
you want to be on the Quartz curve

00:05:32.200 --> 00:05:33.510
and not on the QuickDraw curve.

00:05:33.610 --> 00:05:35.400
QuickDraw is deprecated.

00:05:35.450 --> 00:05:40.490
You want to showcase your application on
Mac OS X by taking advantage of Quartz.

00:05:40.680 --> 00:05:47.660
And that's really where, if you don't,
your competitor probably will.

00:05:47.720 --> 00:05:49.780
So what does it mean for you?

00:05:50.970 --> 00:05:52.310
This deprecation concept.

00:05:52.380 --> 00:05:55.180
It means that we will
maintain binary compatibility,

00:05:55.180 --> 00:05:57.210
so we're not actually removing
the QuickDraw library from

00:05:57.210 --> 00:06:00.220
the platform in Tiger yet.

00:06:00.260 --> 00:06:02.490
I'm not sure when we'll
make that decision,

00:06:02.490 --> 00:06:04.460
but it's definitely not for Tiger.

00:06:04.460 --> 00:06:09.940
If you are building for
Tiger as your build target,

00:06:09.940 --> 00:06:13.650
you'll start getting warnings.

00:06:13.650 --> 00:06:16.810
That's just to help you to know
which APIs you need to move off of.

00:06:17.220 --> 00:06:19.630
and at some future stage we will
also consider removing the headers

00:06:19.720 --> 00:06:25.600
so you won't actually be able to
build using the QuickDraw headers.

00:06:25.600 --> 00:06:27.100
Now what is being deprecated?

00:06:27.100 --> 00:06:30.670
It's the headers that I list here.

00:06:30.700 --> 00:06:37.250
The main important one
is really QuickDraw.h.

00:06:37.250 --> 00:06:37.250
All of the APIs in them
are being deprecated.

00:06:40.200 --> 00:06:44.230
At previous WWDCs,
we've actually talked about adopting

00:06:44.230 --> 00:06:48.240
Quartz in your Carbon application,
and we've talked about a

00:06:48.330 --> 00:06:53.800
piecemeal or incremental approach,
take pieces out of your rendering

00:06:53.800 --> 00:06:59.330
and replace QuickDraw calls with
Core graphics or Quartz 2D calls.

00:06:59.540 --> 00:07:02.520
But going forward,
that's no longer an optimal solution.

00:07:04.270 --> 00:07:06.690
And so this year,
we're actually asking you

00:07:06.780 --> 00:07:08.720
to fully adopt Quartz 2D.

00:07:08.720 --> 00:07:12.200
And you want to leverage that in
all aspects of your graphics usage,

00:07:12.360 --> 00:07:18.790
be it for display, printing,
metafile generation, PDF generation.

00:07:20.180 --> 00:07:27.580
Many applications out there
are architected on Quickdraw,

00:07:27.580 --> 00:07:31.660
and some of the limitations
inside of Quickdraw may also

00:07:31.660 --> 00:07:33.710
show up in your architecture.

00:07:33.860 --> 00:07:38.180
So what we would like you to do is,
if that is the case,

00:07:38.200 --> 00:07:42.070
think of the new features
that the Quartz provides,

00:07:42.190 --> 00:07:46.020
or Quartz 2D provides,
and re-architect your application

00:07:46.020 --> 00:07:47.600
with Quartz 2D in mind.

00:07:48.310 --> 00:07:52.130
Take some time in your design cycle for
the next version of your application,

00:07:52.290 --> 00:07:54.420
and really understand
what you need to do,

00:07:54.670 --> 00:07:57.280
because it's not necessarily
an easy transition.

00:07:58.820 --> 00:08:01.700
And to that end,
we're also moving all of our

00:08:01.800 --> 00:08:04.770
internal code over to Quartz already.

00:08:07.920 --> 00:08:10.980
Now, as I mentioned earlier,
Quartz 2D is being hardware

00:08:11.080 --> 00:08:15.480
accelerated through Quartz Xtreme,
but QuickDraw is not being

00:08:15.480 --> 00:08:17.520
hardware accelerated in Tiger.

00:08:17.870 --> 00:08:21.880
The main point here is if you end up
using QuickDraw in your application,

00:08:21.880 --> 00:08:26.340
that window where you end up
drawing to with QuickDraw,

00:08:26.350 --> 00:08:28.130
it will no longer be accelerated.

00:08:30.830 --> 00:08:34.100
And the reason for that is QuickDraw,
not being accelerated,

00:08:34.140 --> 00:08:35.620
has to draw through the CPU.

00:08:35.700 --> 00:08:38.150
And for us,
what that means is you have to pull

00:08:38.150 --> 00:08:41.780
the window back and store back from
the VRAM over to system memory.

00:08:41.860 --> 00:08:44.380
You start drawing into
it through QuickDraw.

00:08:44.400 --> 00:08:46.750
We don't want to go ping
pong back and forth,

00:08:46.780 --> 00:08:49.940
accelerate, decelerate, accelerate,
decelerate.

00:08:49.940 --> 00:08:53.090
So our policy is that as soon
as you end up using QuickDraw,

00:08:53.090 --> 00:08:54.500
we will decelerate you.

00:08:54.500 --> 00:08:58.250
Because just that ping ponging itself
is actually going to be much more

00:08:58.360 --> 00:09:00.680
of a performance issue than it is.

00:09:00.700 --> 00:09:04.680
and any hardware acceleration
that you might benefit from.

00:09:06.060 --> 00:09:11.750
So Quartz 2D is accelerated
through Quartz Extreme,

00:09:11.750 --> 00:09:12.860
and you want to enable it.

00:09:12.880 --> 00:09:15.760
It's currently not enabled
in your build at WWDC.

00:09:16.070 --> 00:09:18.260
Enable it through Quartz Debug.

00:09:18.270 --> 00:09:22.080
It's a familiar tool for those who
are already working with Quartz.

00:09:22.150 --> 00:09:24.890
In general,
it also has all sorts of other

00:09:24.890 --> 00:09:29.340
performance features that you
can use to determine what are the

00:09:29.380 --> 00:09:30.480
bottlenecks in your application.

00:09:30.490 --> 00:09:34.150
But enable it through Quartz Debug.

00:09:34.390 --> 00:09:39.000
And there's another feature in here,
which is the show window list that will

00:09:39.500 --> 00:09:42.180
list all the windows in the system.

00:09:42.220 --> 00:09:45.080
And those windows which are accelerated
will be color coded as green.

00:09:45.080 --> 00:09:51.280
So you can find out whether your window
is actually being accelerated or not,

00:09:51.280 --> 00:09:55.720
where it is in terms of what the
window server thinks it is doing,

00:09:55.780 --> 00:09:58.780
or what the Quartz
compositor has decided,

00:09:58.780 --> 00:10:02.710
whether it's on the graphics card in
terms of it being accelerated or not.

00:10:03.920 --> 00:10:07.700
Now as you start making this transition,
you'll come to the conclusion that

00:10:07.840 --> 00:10:11.010
these are two different imaging models,
if you haven't already.

00:10:11.250 --> 00:10:15.310
QuickDraw is fundamentally pixel-based,
whereas Quartz 2D was designed to be

00:10:15.400 --> 00:10:17.640
resolution and device independent.

00:10:17.640 --> 00:10:22.440
So as a result, Quartz 2D is not going to
be a superset of QuickDraw.

00:10:22.440 --> 00:10:25.650
So there are going to be
features in QuickDraw,

00:10:25.650 --> 00:10:30.640
and primarily those are pixel-based
manipulation utilities that are not

00:10:30.760 --> 00:10:33.780
going to be provided through QuickDraw.

00:10:33.800 --> 00:10:34.620
So as you start making these transitions,
you'll come to the conclusion that

00:10:34.620 --> 00:10:36.710
these are two different imaging models,
if you haven't already.

00:10:36.710 --> 00:10:39.550
QuickDraw is fundamentally pixel-based,
whereas Quartz 2D was designed to be

00:10:39.560 --> 00:10:40.930
resolution and device independent.

00:10:40.960 --> 00:10:43.550
So as you start making these transitions,
you'll come to the conclusion that

00:10:43.550 --> 00:10:46.160
these are two different imaging models,
if you haven't already.

00:10:47.530 --> 00:10:50.300
In some cases,
we may add similar features.

00:10:50.380 --> 00:10:52.620
For example,
the transfer modes in QuickDraw.

00:10:52.640 --> 00:10:55.980
We've got PDF blend modes
inside of Quartz 2D.

00:10:56.000 --> 00:11:00.310
They don't match one to one,
but you could probably use

00:11:00.310 --> 00:11:02.360
some of them if necessary.

00:11:02.390 --> 00:11:08.260
You may want to also re-evaluate
the usage of those APIs.

00:11:08.280 --> 00:11:12.120
A perfect example that
comes out is XR drawing.

00:11:12.120 --> 00:11:16.140
Yes, we've got a transfer mode for it,
but if you look at Mac OS X,

00:11:16.150 --> 00:11:20.150
many applications can get
away without XR drawing.

00:11:20.440 --> 00:11:24.780
And you want to re-evaluate and think
differently in terms of how you want

00:11:24.780 --> 00:11:28.320
to use that API that you're used to,
but how you could do that

00:11:28.320 --> 00:11:30.660
equivalent thing in Quartz 2D.

00:11:30.710 --> 00:11:34.400
And so in some of those cases,
we've decided the OS is no longer

00:11:34.400 --> 00:11:39.780
going to be providing those
APIs as a system level service.

00:11:40.820 --> 00:11:44.560
We realize the transition is not easy,
so we've done quite a

00:11:44.560 --> 00:11:46.340
bit of things for Tiger.

00:11:46.510 --> 00:11:48.860
Specifically,
we've added many new APIs in

00:11:48.860 --> 00:11:52.790
Tiger in the Quartz 2D API,
and those are focused primarily

00:11:52.790 --> 00:11:55.600
for people who are going to
be moving over from Quartz,

00:11:55.600 --> 00:11:57.500
from QuickDraw to Quartz 2D.

00:11:59.330 --> 00:12:01.170
A common complaint has
been the documentation.

00:12:01.240 --> 00:12:03.280
So we've improved the
documentation significantly.

00:12:03.390 --> 00:12:05.760
We've got the drawing
with Quartz2D document.

00:12:05.760 --> 00:12:07.700
We've got the reference document.

00:12:07.730 --> 00:12:09.250
Those have been updated.

00:12:09.370 --> 00:12:13.100
Plus we've got this new document,
which is the transitioning to Quartz2D.

00:12:13.100 --> 00:12:15.440
It's a new series of articles.

00:12:15.440 --> 00:12:17.930
You should have access to them already.

00:12:17.960 --> 00:12:19.480
There'll be many more coming.

00:12:19.480 --> 00:12:22.460
It's going to mimic the
contents of this session,

00:12:22.460 --> 00:12:25.430
and we'll go into more detail
about some of the problems that you

00:12:25.720 --> 00:12:28.140
will run into in this transition.

00:12:28.140 --> 00:12:29.240
We've got new sample code.

00:12:29.420 --> 00:12:33.620
We'll have more sample code available,
maybe even technos,

00:12:33.620 --> 00:12:39.170
depending on what problems people come
up with and what the solutions are.

00:12:39.520 --> 00:12:41.750
We've got a Quartz step mailing list.

00:12:41.750 --> 00:12:45.540
If you're not on it,
it's a great list to be on because

00:12:45.540 --> 00:12:50.170
you've got other Carbon developers and
other Quartz 2D developers who can help

00:12:50.230 --> 00:12:54.800
answer questions and we've also got some
of the engineers on our team that are

00:12:54.800 --> 00:12:58.050
helping out with those questions also.

00:12:58.550 --> 00:13:01.630
And right after the session,
we've got the Graphics and

00:13:01.630 --> 00:13:05.980
Media Lab where you can
drop by until 5:00 PM today.

00:13:06.020 --> 00:13:08.440
And we will be there to
answer questions for you.

00:13:08.440 --> 00:13:09.420
So we'll do the Q&A.

00:13:09.430 --> 00:13:11.710
But after that,
we can also move to the Graphics

00:13:11.710 --> 00:13:15.270
and Media Lab and focus in on
specific questions that you may have.

00:13:15.340 --> 00:13:17.740
And finally,
we actually need your feedback.

00:13:17.800 --> 00:13:22.290
We've tried hard to make this transition
easy or fill in some of the holes.

00:13:22.470 --> 00:13:26.150
But as you move your application
over and you recognize problems

00:13:26.160 --> 00:13:28.680
in your application-- are
you missing a functionality?

00:13:28.680 --> 00:13:29.660
Let us know.

00:13:29.660 --> 00:13:31.900
There's many ways that you can do that.

00:13:31.900 --> 00:13:36.710
And I've listed the mailing list,
contacts that we'll list at the end.

00:13:36.770 --> 00:13:37.920
But let us know.

00:13:37.920 --> 00:13:41.370
It's a really good opportunity
for you to try it out and

00:13:41.370 --> 00:13:44.640
help us ease your transition.

00:13:46.210 --> 00:13:48.990
There are a few other technologies that
are being deprecated that we're not going

00:13:48.990 --> 00:13:51.780
to be talking about in this session,
but I wanted to list them here.

00:13:51.780 --> 00:13:55.160
The Display Manager and Draw Sprockets
are being deprecated also.

00:13:55.160 --> 00:13:58.530
And for those two technologies,
what you want to do is use

00:13:58.530 --> 00:14:00.520
the Quartz display services.

00:14:00.520 --> 00:14:04.280
Those technologies were actually built
on top of the Quartz display services,

00:14:04.280 --> 00:14:06.580
so now you should actually
go directly to that.

00:14:06.690 --> 00:14:08.560
It's a better API for you to be using.

00:14:08.560 --> 00:14:11.240
And QuickDraw Text is
also being deprecated.

00:14:11.240 --> 00:14:14.380
It was discussed in another
session earlier this week,

00:14:14.520 --> 00:14:16.100
so we won't talk about it.

00:14:16.980 --> 00:14:19.300
And from this point,
I'll actually like to

00:14:19.300 --> 00:14:23.240
bring up Joseph Maurer,
our QuickDraw expert,

00:14:23.240 --> 00:14:26.900
who can actually help you see
the common problems and help

00:14:26.900 --> 00:14:29.380
you move over to Quartz 2D.

00:14:29.380 --> 00:14:30.920
So, there you go.

00:14:31.300 --> 00:14:32.240
Thank you, Haroon.

00:14:41.050 --> 00:14:45.380
They deprecated my nickname.

00:14:45.420 --> 00:14:46.880
But it's okay.

00:14:46.940 --> 00:14:48.420
I actually like it.

00:14:48.550 --> 00:14:50.790
Feels like a promotion.

00:14:53.440 --> 00:15:00.460
I still should let you know that
where I come from we say Quartz.

00:15:00.530 --> 00:15:06.150
So don't laugh if my pronunciation
of Quartz is not as you

00:15:06.290 --> 00:15:07.580
hear it all over the place.

00:15:07.610 --> 00:15:15.840
From now on, each time you read about,
hear about, learn about Quartz,

00:15:15.970 --> 00:15:19.190
you will think of me in
the way I say Quartz.

00:15:27.820 --> 00:15:31.220
You know,
I had to learn this new word this year.

00:15:31.360 --> 00:15:33.260
Deprecated.

00:15:33.900 --> 00:15:39.680
looked it up in the dictionary,
comes from Latin, "deprecare."

00:15:39.900 --> 00:15:44.980
And it means to ward off by prayer.

00:15:49.750 --> 00:15:51.810
I'm not making this up.

00:15:51.810 --> 00:15:54.040
You can Google it for yourself.

00:15:54.150 --> 00:15:58.410
So can you picture Haroon and
Peter Graffagnino praying to defend

00:15:58.410 --> 00:16:01.530
themselves against the evil of QuickDraw?

00:16:02.850 --> 00:16:05.700
talking about evil.

00:16:05.720 --> 00:16:07.910
You are a wonderful audience.

00:16:08.580 --> 00:16:11.760
You fit, you are the perfect
audience for this afternoon.

00:16:11.760 --> 00:16:13.840
You are,
I assume you are a Carbon developer,

00:16:13.840 --> 00:16:16.200
so you can relate to
the quote in the title.

00:16:16.290 --> 00:16:19.970
I assume you know QuickDraw,
so I don't have to explain

00:16:20.160 --> 00:16:21.720
anything about it anymore.

00:16:21.720 --> 00:16:25.220
I assume you know enough about
Quartz that I don't have to

00:16:25.220 --> 00:16:27.220
explain much about it either.

00:16:27.220 --> 00:16:31.980
And of course you want to transition
your graphics programming to Quartz.

00:16:34.250 --> 00:16:35.540
Yeah?

00:16:35.620 --> 00:16:37.090
Okay.

00:16:37.090 --> 00:16:40.340
I know there is some
obstacle to overcome.

00:16:40.340 --> 00:16:43.320
You need to let loose of
some sentimental attachment.

00:16:43.320 --> 00:16:46.120
And I know what I'm talking about.

00:16:46.120 --> 00:16:51.070
I've been sentimentally
attached for 21 years.

00:16:54.300 --> 00:16:59.080
See, over the last weeks or so,
sometimes I felt like standing

00:16:59.080 --> 00:17:04.070
out there on the corner,
the Ansa Mariani, in the morning,

00:17:04.070 --> 00:17:08.920
watching all the fellow
Apple employees drive by to work.

00:17:09.040 --> 00:17:12.490
And I was there with
my big sign that read,

00:17:12.600 --> 00:17:15.210
hunk, if you like QuickDraw.

00:17:17.940 --> 00:17:23.230
Well, with the exception of two or three
bodies from the QuickTime group,

00:17:23.230 --> 00:17:24.120
nobody honked.

00:17:26.870 --> 00:17:28.640
So I brought my own hunking device.

00:17:28.770 --> 00:17:31.900
QuickDraw, QuickDraw.

00:17:31.900 --> 00:17:36.120
It's Friday afternoon after all, huh?

00:17:43.970 --> 00:17:49.010
I don't have a musical
instrument for Quartz.

00:17:49.580 --> 00:17:52.330
Quartz doesn't need,
it would have to be something big,

00:17:52.500 --> 00:17:55.140
you know, shiny and splendid.

00:17:55.170 --> 00:17:56.620
I'm thinking of a trombone.

00:17:56.920 --> 00:18:00.700
No way I could fit
this in my cargo pants.

00:18:00.880 --> 00:18:03.310
Quartz has something else.

00:18:03.490 --> 00:18:06.710
Quartz has Tailwind.

00:18:06.710 --> 00:18:06.710
Tailwind is a new technology.

00:18:06.710 --> 00:18:06.710
Tailwind is a new technology.

00:18:07.300 --> 00:18:09.190
and as somebody who
likes to ride a bicycle,

00:18:09.190 --> 00:18:12.760
I can tell you that Tailwind
is a very good thing.

00:18:13.910 --> 00:18:16.620
All of us know, however,
that in order to take

00:18:16.790 --> 00:18:21.560
advantage of Tailwind,
you need to go in the right direction.

00:18:21.560 --> 00:18:25.780
So I invite you to come along with
me and we make a big turn and we

00:18:25.810 --> 00:18:28.260
turn into the right direction.

00:18:28.300 --> 00:18:31.400
We go to transition.

00:18:31.500 --> 00:18:35.460
They told me it would work.

00:18:35.460 --> 00:18:35.460
Yeah.

00:18:35.600 --> 00:18:44.300
[Transcript missing]

00:18:44.710 --> 00:18:47.760
Take the first three bullet
items as introduction,

00:18:47.760 --> 00:18:51.510
as things we need to think about
before we even get started.

00:18:51.580 --> 00:18:54.200
And then,
thinking about the program here,

00:18:54.200 --> 00:18:59.820
I thought I would isolate two concepts
that need more discussion in depth,

00:18:59.820 --> 00:19:02.180
region handles and copy bits.

00:19:03.750 --> 00:19:07.840
Then I regroup some more
issues and concerns.

00:19:07.840 --> 00:19:12.340
At the end,
think about pictures versus PDF or

00:19:12.450 --> 00:19:16.140
performance or this color space thing
and everything that's new there.

00:19:16.140 --> 00:19:18.740
And I even have examples and demos.

00:19:18.750 --> 00:19:23.470
Why don't we start with sample code?

00:19:23.680 --> 00:19:27.740
Then I regroup some more
issues and concerns.

00:19:27.740 --> 00:19:30.950
At the end,
think about pictures versus PDF or

00:19:30.950 --> 00:19:30.950
performance or this color space thing
and everything that's new there.

00:19:30.950 --> 00:19:30.950
And I even have examples and demos.

00:19:30.950 --> 00:19:30.950
Why don't we start with sample code?

00:19:31.450 --> 00:19:35.260
Many of you may remember from
three or four years ago CarbonDraw,

00:19:35.260 --> 00:19:37.260
which was the first proof of concept.

00:19:37.260 --> 00:19:42.900
You actually can call Quartz
APIs from a Carbon application.

00:19:42.970 --> 00:19:46.300
This time, it's the real thing.

00:19:46.300 --> 00:19:48.220
There is no QuickDraw at all.

00:19:48.220 --> 00:19:49.670
It can be done.

00:19:49.670 --> 00:19:53.880
You don't use XOR for drag
selection and matching answer,

00:19:53.880 --> 00:19:54.880
whatever.

00:19:54.880 --> 00:19:57.230
You use overlay windows.

00:19:57.900 --> 00:20:00.680
Hit testing, there is no point in region.

00:20:00.680 --> 00:20:01.600
We don't need it.

00:20:01.710 --> 00:20:06.590
There are other ways around it,
and the sample code shows it.

00:20:07.230 --> 00:20:12.800
We have copy-pasting, PDF data,
the generic color space usage,

00:20:12.890 --> 00:20:13.640
and some more.

00:20:13.880 --> 00:20:17.320
And it's available,
I didn't find it today, this morning yet,

00:20:17.520 --> 00:20:20.000
but it should come up anytime real soon.

00:20:20.000 --> 00:20:22.180
And it's there to grow.

00:20:22.180 --> 00:20:24.830
I think I want to demo it now.

00:20:37.000 --> 00:20:41.630
So it's your regular drawing application,
nothing spectacular.

00:20:41.940 --> 00:20:45.000
You draw lines, move them around.

00:20:45.010 --> 00:20:50.690
Now each time you do hit testing,
you use a one pixel bitmap context

00:20:51.370 --> 00:20:54.000
that you transform appropriately.

00:20:54.020 --> 00:20:56.450
You can scale the drawing.

00:20:57.140 --> 00:21:01.180
and HitTesting also
works in the scaled way.

00:21:01.180 --> 00:21:06.220
What's going on behind the scenes is
there is one generic transform that

00:21:06.220 --> 00:21:15.510
transforms from document coordinates in
the list of shapes to the window content.

00:21:15.520 --> 00:21:19.250
Now I'm emphasizing this because
if ever you get your hands

00:21:19.460 --> 00:21:23.750
on the copy that's uploaded,
this might not work.

00:21:23.850 --> 00:21:26.200
I fixed the bug just over last weekend.

00:21:27.060 --> 00:21:30.270
And I will later come back,
remind me to talk about this bug.

00:21:30.280 --> 00:21:30.800
It's helpful.

00:21:30.800 --> 00:21:37.830
And of course you do set
fill colors or whatever.

00:21:40.400 --> 00:21:42.080
No, I meant full blue.

00:21:42.160 --> 00:21:54.270
And I mentioned before that it does take
advantage of built-in color matching.

00:21:55.060 --> 00:21:56.780
I don't know if you can see this.

00:21:56.910 --> 00:22:03.910
If you look closely,
this digital color meter tells us that

00:22:03.910 --> 00:22:05.110
the real color I'm pointing at here

00:22:05.280 --> 00:22:06.860
is not the blue that we set.

00:22:06.860 --> 00:22:10.160
It has got an additional
red component in there.

00:22:10.160 --> 00:22:12.330
I don't know why.

00:22:12.330 --> 00:22:14.300
The color thing people can explain you.

00:22:14.310 --> 00:22:18.230
But that's just a demonstration
that color matching works,

00:22:18.300 --> 00:22:19.770
is there, is alive.

00:22:19.790 --> 00:22:23.270
And of course, on top of it,
color matching wouldn't make much

00:22:23.270 --> 00:22:27.390
sense without calibrating to begin
with and with projectors and so on.

00:22:27.390 --> 00:22:31.530
It's just something to point out.

00:22:31.620 --> 00:22:35.040
I said we have copy and paste.

00:22:35.290 --> 00:22:41.670
Before we can save as a PDF file,
that's no big surprise.

00:22:48.500 --> 00:23:00.700
[Transcript missing]

00:23:03.900 --> 00:23:11.300
[Transcript missing]

00:23:18.410 --> 00:23:22.480
I don't know how we made
it work just before.

00:23:22.480 --> 00:23:23.310
Okay.

00:23:23.610 --> 00:23:29.020
What if I open a new project?

00:23:30.900 --> 00:23:33.990
PDF we just created, now it's in preview.

00:23:33.990 --> 00:23:37.940
And I close Carbon, sketch a new window.

00:23:37.990 --> 00:23:44.300
And here I ask preview
to copy this stuff.

00:23:45.780 --> 00:23:47.940
In two.

00:23:48.000 --> 00:23:49.340
Oh, here we go.

00:23:49.390 --> 00:23:51.600
So this should have worked before.

00:23:51.620 --> 00:23:57.540
This is one of those miracles in demos.

00:23:57.540 --> 00:23:58.200
I don't know.

00:23:58.200 --> 00:24:02.210
Oh, actually I do.

00:24:06.300 --> 00:24:14.300
[Transcript missing]

00:24:18.100 --> 00:24:22.160
In case you want to know too,
there are two different copies

00:24:22.160 --> 00:24:23.400
of preview on this machine.

00:24:23.400 --> 00:24:27.620
And the copy that works best for
this demo is the one from Panther.

00:24:33.400 --> 00:24:37.000
So now I'm back in Carbon Sketch,
I can do whatever I want,

00:24:37.040 --> 00:24:40.500
like our QuickDraw rounded rectangle.

00:24:41.110 --> 00:24:44.160
Let's make it half transparent or so.

00:24:44.190 --> 00:24:49.300
And now I go back and say,
I want to copy this whole page

00:24:49.420 --> 00:24:52.000
in my Carbon Sketch thing.

00:24:53.480 --> 00:24:58.550
and if this is the right copy of preview,
then I can say new from

00:24:58.620 --> 00:25:00.940
clipboard and here it is.

00:25:00.940 --> 00:25:04.790
I have a new PDF that
has our drawing added.

00:25:05.670 --> 00:25:11.640
I don't know what I forgot now to
show about this Carbon sketch thing.

00:25:11.680 --> 00:25:15.540
The interesting part for you should be,
I'm in the following referring to it

00:25:16.030 --> 00:25:19.800
and inviting you to take the code,
the source code,

00:25:19.900 --> 00:25:23.650
Copy-paste from there those things
that you better copy-paste from

00:25:23.650 --> 00:25:25.360
somewhere where they already work.

00:25:25.360 --> 00:25:30.990
And then toy around and
make experiences with...

00:25:31.580 --> 00:25:35.910
Getting some experience with
Quartz drawing yourself.

00:25:37.720 --> 00:25:40.770
So we can go on with the slides.

00:25:42.920 --> 00:25:44.740
Now we get into the meat.

00:25:44.820 --> 00:25:47.700
Haroon has already pointed
out all the differences.

00:25:47.700 --> 00:25:51.370
I don't need to repeat all the details,
but

00:25:51.960 --> 00:25:57.260
In this slide, you should start with
reading the last line.

00:25:57.330 --> 00:26:00.360
The last line says,
don't try to translate the usual

00:26:00.450 --> 00:26:05.940
QuickDraw idioms that we got used to
over so many years into Quartz as is,

00:26:06.330 --> 00:26:09.300
because the differences are just too big.

00:26:09.700 --> 00:26:14.860
In this slide, you should start with
reading the last line.

00:26:14.970 --> 00:26:16.950
The last line says,
don't try to translate the usual

00:26:16.950 --> 00:26:16.950
QuickDraw idioms that we got used to
over so many years into Quartz as is,

00:26:16.950 --> 00:26:16.950
because the differences are just too big.

00:26:17.110 --> 00:26:18.060
This comes twice.

00:26:18.190 --> 00:26:23.070
It comes next to the changes
of coordinate systems.

00:26:23.300 --> 00:26:28.150
and the current transformation matrix
and it comes with clipping and it would

00:26:28.150 --> 00:26:34.420
have to do with all other calls that you
make in Quartz to change the behavior

00:26:34.460 --> 00:26:38.810
of the stroking and filling operations,
the colors and many other

00:26:39.030 --> 00:26:40.650
settings and details.

00:26:40.700 --> 00:26:43.610
In QuickDraw,
we had the model that the state was

00:26:43.610 --> 00:26:45.940
mainly preserved in the graph port.

00:26:46.020 --> 00:26:52.070
We could have accesses and
then get and set the values.

00:26:53.120 --> 00:26:55.170
In Quartz, the model is different.

00:26:56.380 --> 00:27:00.210
Everything is combined in
this opaque graphic state,

00:27:00.210 --> 00:27:03.470
which you can push and pull back.

00:27:03.670 --> 00:27:07.060
You save it on the stack and
you restore it from the stack.

00:27:07.150 --> 00:27:11.120
This makes for a nice bracketing
thinking in all your drawing.

00:27:11.120 --> 00:27:14.390
And after the first couple
hours when you get used to it,

00:27:14.430 --> 00:27:15.700
you really like it.

00:27:15.920 --> 00:27:19.120
It's a much better approach to
keep your drawing code clean.

00:27:19.120 --> 00:27:22.930
And we have to come
back to that more often.

00:27:23.040 --> 00:27:26.430
Now coordinates, the CTM,
the current transformation

00:27:26.430 --> 00:27:28.040
matrix and transforms.

00:27:28.040 --> 00:27:31.420
This gives us an extra slide.

00:27:33.580 --> 00:27:38.350
I remember when I encountered
QuickDraw and the first time saw a

00:27:38.480 --> 00:27:44.330
coordinate system where by default
the vertical coordinate went top down.

00:27:44.330 --> 00:27:45.590
I found it odd.

00:27:45.590 --> 00:27:48.330
It took me a while to get used to it.

00:27:48.330 --> 00:27:50.340
I didn't really like it.

00:27:50.340 --> 00:27:54.280
Of course, all of us,
we learned very rapidly that

00:27:54.430 --> 00:27:59.540
this was the convenient way of
addressing pixels in a window.

00:27:59.540 --> 00:28:00.500
It's natural.

00:28:00.770 --> 00:28:03.480
It follows the order of the system.

00:28:03.500 --> 00:28:06.490
It's in memory and it has so many
other benefits because we are used

00:28:06.680 --> 00:28:10.100
for resizing windows to resize from
the bottom right and the top left.

00:28:10.190 --> 00:28:13.240
The content stays
anchored to the top left.

00:28:13.390 --> 00:28:14.460
So this was the right thing.

00:28:14.460 --> 00:28:17.390
And over the years,
we got completely brainwashed into

00:28:17.390 --> 00:28:21.000
believing that coordinate systems
have to go vertically top down.

00:28:21.000 --> 00:28:24.050
Well, now they are again back
up in Quartz by default.

00:28:24.100 --> 00:28:26.550
But...

00:28:26.670 --> 00:28:34.910
There is this general model whereby the
CTM can be changed to whatever you want.

00:28:35.620 --> 00:28:38.900
Not that you will get everything right,
right away.

00:28:38.900 --> 00:28:44.880
It often requires some experimentation
or some additional thinking.

00:28:44.880 --> 00:28:48.220
But it gives you the power to,
for example,

00:28:48.220 --> 00:28:52.530
flip the coordinate system and
shift it such that you can continue

00:28:52.650 --> 00:28:57.010
working as you did in your mental
model of the QuickDraw coordinates.

00:28:57.600 --> 00:29:01.750
And HIViews, they do have their
origin at the top left.

00:29:01.920 --> 00:29:06.180
They have set up the CG context that
you get back in your draw control

00:29:06.180 --> 00:29:09.520
event such that you can just use this.

00:29:09.600 --> 00:29:13.600
They have had good reasons
to set it up that way.

00:29:17.580 --> 00:29:22.330
Still, it's one of those obstacles on
the way to transition to Quartz,

00:29:22.480 --> 00:29:26.030
and I should point this out that
you should not be surprised to

00:29:26.030 --> 00:29:29.080
spend some extra time just figuring
out where the coordinates go and

00:29:29.710 --> 00:29:35.940
converting back and forth between a
window position that vertically you

00:29:36.070 --> 00:29:40.820
have to count from top down in the
QuickDraw model or the HIV model,

00:29:40.820 --> 00:29:45.770
and that in the default Quartz model,
you have to introduce

00:29:45.770 --> 00:29:47.480
the height of the window.

00:29:47.500 --> 00:29:53.330
The current height so you can subtract
it and get the distance from the bottom.

00:29:53.830 --> 00:29:55.650
And this is a joke, math is hard.

00:29:55.710 --> 00:29:57.080
Math is not hard.

00:29:57.160 --> 00:30:00.570
It's just hard to get everything
right when you use these transforms.

00:30:00.580 --> 00:30:06.540
I referred to it when I showed you
the hit testing in Carbon Sketch,

00:30:06.540 --> 00:30:09.390
and I said there was this bug.

00:30:09.470 --> 00:30:14.990
I didn't notice because I hadn't
tested hit testing under scaling up.

00:30:15.180 --> 00:30:18.740
Or when I tested it,
it just happened to work by accident.

00:30:18.740 --> 00:30:20.750
And then I noticed that it didn't work.

00:30:20.860 --> 00:30:23.390
And it tracked it down to the following.

00:30:24.880 --> 00:30:30.660
There is a one pixel bitmap
context which I set up.

00:30:30.660 --> 00:30:32.610
And once you click in
the window at some point,

00:30:32.730 --> 00:30:34.340
I move it to this point.

00:30:34.400 --> 00:30:39.140
And then I redraw the whole content of
the window and check whether this point

00:30:39.140 --> 00:30:41.310
in this bitmap context has been touched.

00:30:41.350 --> 00:30:42.350
Very easy.

00:30:42.360 --> 00:30:45.200
I set it to zero before and
afterwards if it has been touched,

00:30:45.290 --> 00:30:46.720
it won't be zero anymore.

00:30:48.250 --> 00:30:52.540
Well, the problem was I applied-- and
in order to draw window content,

00:30:52.540 --> 00:30:56.410
of course, I always have to
concatenate this generic,

00:30:56.520 --> 00:30:59.440
affine transform that
converts from the document,

00:30:59.520 --> 00:31:06.940
document, the document coordinates to
the window content coordinates,

00:31:07.280 --> 00:31:08.100
depending on the position of
the scroll bars and so on.

00:31:10.030 --> 00:31:13.100
Tricky part was I got the order wrong.

00:31:13.160 --> 00:31:17.360
I applied this transform and shifted
the bitmap context to where it belongs.

00:31:17.410 --> 00:31:18.760
Well, this is the wrong order.

00:31:18.760 --> 00:31:21.380
First I have to shift there
and then apply the transform.

00:31:21.430 --> 00:31:25.180
It doesn't matter if you don't scale,
but as soon as you scale,

00:31:25.230 --> 00:31:29.740
the transforms are not...
It depends on the order.

00:31:29.800 --> 00:31:32.170
So this is just an example.

00:31:32.330 --> 00:31:37.540
of the type of obstacle you
are likely to encounter.

00:31:38.000 --> 00:31:43.010
This is a very generic slide just
to tell you in order to get started.

00:31:43.310 --> 00:31:49.220
The CG context is more or less
something in parallel to a graph port.

00:31:49.560 --> 00:31:54.740
We need something to draw into
nearly all the Quartz APIs.

00:31:54.830 --> 00:31:58.620
Take a CG context as first parameter.

00:31:59.110 --> 00:32:01.830
And the question is,
where do we get it from in our first

00:32:02.000 --> 00:32:05.270
examples of experimentation with it?

00:32:05.400 --> 00:32:07.460
Well,
you have learned over this week and for

00:32:07.490 --> 00:32:13.600
two years already that the direction
for Carbon developers in the HI toolbox

00:32:13.600 --> 00:32:17.020
is to adopt the HI view architecture.

00:32:17.020 --> 00:32:22.610
And there you draw in this K event
control draw event and the event record

00:32:23.050 --> 00:32:27.010
brings you the CG context ready set up,
clipped with the coordinates

00:32:27.010 --> 00:32:28.030
as you like it and so on.

00:32:28.230 --> 00:32:32.250
So that's the most convenient solution,
the most convenient

00:32:32.250 --> 00:32:33.320
answer to the question.

00:32:33.320 --> 00:32:37.570
For everybody else, in the meantime...

00:32:38.940 --> 00:32:45.400
You have the window port coming back from
get window port and you fill it into the

00:32:45.460 --> 00:32:50.840
QDBeginCGContext call and this gives you
the CG context as you have always had.

00:32:51.160 --> 00:32:53.450
This context,
each time you make this call,

00:32:53.630 --> 00:32:54.860
is a default context.

00:32:54.900 --> 00:33:00.870
It's a fresh reset context as if
you created it from scratch new.

00:33:02.110 --> 00:33:04.260
But of course,
now that we promise not to use any

00:33:04.260 --> 00:33:08.950
QuickDraw in our window drawing,
we do it just once at the beginning,

00:33:09.020 --> 00:33:13.580
and then it's always our context.

00:33:13.870 --> 00:33:20.690
I mentioned the bitmap context in the
case of using a one pixel wide bitmap

00:33:20.830 --> 00:33:22.430
context for this hit testing business.

00:33:22.520 --> 00:33:27.630
And we created PDF data in Carbon Sketch,
so we need to create a PDF context.

00:33:27.680 --> 00:33:31.620
The equivalent in QuickDraw
was to call open picture,

00:33:31.620 --> 00:33:35.660
then do some drawing that gets recorded,
and say close picture to

00:33:35.760 --> 00:33:37.760
get back the picture handle.

00:33:37.760 --> 00:33:42.070
Well, in Quartz,
we just draw into a PDF context.

00:33:44.990 --> 00:33:48.830
And for printing, well,
this bracket of begin-cig context

00:33:48.830 --> 00:33:50.140
and end-cig context works.

00:33:50.250 --> 00:33:55.360
David Gelbman here has done everything
that needed to be done for that.

00:33:55.370 --> 00:33:59.680
But preferably,
it's better to let the printing

00:33:59.680 --> 00:34:02.890
system know right away that
we only use Quartz drawing.

00:34:02.890 --> 00:34:08.910
And up to Tiger, it was a little bit,
I found it unintuitive how to do it.

00:34:08.910 --> 00:34:13.700
I couldn't figure it out by myself,
had to go back to David and ask him.

00:34:13.700 --> 00:34:16.010
And so in Tiger,
we get something that's much

00:34:16.410 --> 00:34:18.220
more clean and intuitive.

00:34:18.220 --> 00:34:20.580
And before Tiger,
you go to Carbon Sketch and copy-paste

00:34:20.580 --> 00:34:22.210
it out there for your printing.

00:34:24.420 --> 00:34:29.180
So, the first major chapter,
what do we do with all

00:34:29.180 --> 00:34:30.980
those region handles?

00:34:31.070 --> 00:34:37.980
You have heard probably some references
to region handles being bad in the

00:34:37.980 --> 00:34:40.080
HIToolbox presentations already.

00:34:40.080 --> 00:34:46.370
One thing is a given,
there are no region handles in Quartz.

00:34:46.920 --> 00:34:53.900
Regions in QuickDraw are being
used either as very general shapes

00:34:54.330 --> 00:34:58.980
that can be drawn and filled
and painted and what have you,

00:34:58.980 --> 00:35:01.960
or they are used as masks.

00:35:02.700 --> 00:35:06.900
For example,
its last parameter in a copy bits call,

00:35:06.900 --> 00:35:09.160
a mask region handle.

00:35:09.250 --> 00:35:13.980
When moving to Quartz,
these two different usages are

00:35:14.070 --> 00:35:18.770
being addressed by different ways.

00:35:18.990 --> 00:35:22.020
The generic shape,
very naturally in Quartz,

00:35:22.090 --> 00:35:27.530
is described by its contours, so a path.

00:35:27.670 --> 00:35:32.160
And for masks,
Quartz has the alpha channel.

00:35:32.750 --> 00:35:34.750
The question is, how do we put this in?

00:35:34.890 --> 00:35:36.390
I will come back to that.

00:35:36.760 --> 00:35:39.800
And the other bullet points are going
to have their own slides as well,

00:35:39.800 --> 00:35:41.560
so we just flip over.

00:35:44.030 --> 00:35:46.640
The major,
the first time a QuickDraw developer

00:35:46.710 --> 00:35:50.000
encounters regions probably
is to clip as a clip region,

00:35:50.000 --> 00:35:52.280
set the clip to something.

00:35:52.520 --> 00:35:56.130
And in QuickDraw, these functions,
clip to the rectangle or set the clip,

00:35:56.360 --> 00:36:02.000
of course, replace whatever was there
as previous clip in the port.

00:36:02.840 --> 00:36:06.730
Whereas in Quartz,
the corresponding called CG context

00:36:06.950 --> 00:36:11.760
clip that takes implicitly the
current path intersects with

00:36:12.050 --> 00:36:14.800
whatever the previous clip was.

00:36:15.660 --> 00:36:19.330
The first time I learned about
this from my new co-workers

00:36:19.440 --> 00:36:23.170
when I joined the group,
I said, huh, I don't like this.

00:36:23.170 --> 00:36:26.190
Well, of course,
it's easy to get used to it.

00:36:26.190 --> 00:36:30.000
And again, once more,
CG context save G-State,

00:36:30.000 --> 00:36:34.010
then you clip to what you need,
and you come back with the

00:36:34.200 --> 00:36:37.050
closing bracket restore G-State.

00:36:37.120 --> 00:36:39.980
And so you're always
in a clean situation.

00:36:39.980 --> 00:36:44.160
Still,
in the first hours of experimentation

00:36:44.320 --> 00:36:49.780
with Quartz 3D... If you are like me,
sometimes your drawing won't show up.

00:36:49.780 --> 00:36:53.710
The first reason is you've
got the coordinates wrong.

00:36:53.710 --> 00:36:58.320
The second reason could be that you
clipped and that your drawing is

00:36:58.370 --> 00:37:01.160
away from what you want to clip out.

00:37:01.230 --> 00:37:04.890
And then, so I was wondering,
how can I debug this?

00:37:05.230 --> 00:37:07.880
How can I determine if this is the case?

00:37:07.940 --> 00:37:11.580
And there is this call that
I just wanted to point out.

00:37:11.730 --> 00:37:14.420
CG context get clip bounding box.

00:37:14.650 --> 00:37:15.400
This helps in most cases.

00:37:15.660 --> 00:37:21.810
Because there is no way to get
the current clip back as a path.

00:37:21.900 --> 00:37:23.900
And while we're at it,
here's another hint.

00:37:23.900 --> 00:37:28.630
I discovered this only during
development of CarbonSketch.

00:37:28.900 --> 00:37:34.260
I needed to clip the drawing
to the portion of the window

00:37:34.260 --> 00:37:39.840
content outside of other controls.

00:37:40.060 --> 00:37:42.800
The scroll bars and this
pop-up for the scale.

00:37:42.900 --> 00:37:45.020
So I said, well,
nothing easier than that.

00:37:45.020 --> 00:37:50.780
You just take the path for the
whole window content rectangle

00:37:50.780 --> 00:37:55.400
and then you subtract the paths
that describe the contour of

00:37:55.530 --> 00:37:58.090
the scroll bars and the pop-ups.

00:37:58.440 --> 00:38:04.060
Problem is,
the CG context clip uses the winding

00:38:04.060 --> 00:38:07.560
number rule to determine what's
inside and outside of the area.

00:38:07.560 --> 00:38:11.320
Which means,
as the little arrows should indicate,

00:38:11.320 --> 00:38:15.790
the rectangle that gets subtracted
from the area should have the

00:38:16.030 --> 00:38:18.480
opposite orientation in the contour.

00:38:18.480 --> 00:38:21.800
Now that's a little annoying when
you have to write the code because

00:38:21.800 --> 00:38:25.090
you have to write at least four
lines instead of just one line

00:38:25.090 --> 00:38:26.980
to add the rectangle to the path.

00:38:27.580 --> 00:38:31.680
Unfortunately then,
I learned that there was the

00:38:31.820 --> 00:38:34.390
CG context even-odd clip.

00:38:34.440 --> 00:38:37.540
And so now you can just add
the rectangles as they come,

00:38:37.540 --> 00:38:41.110
and the even-odd rule does the right
things and you can clip as you want.

00:38:42.830 --> 00:38:44.800
Here's another subject.

00:38:44.870 --> 00:38:51.810
If you never bothered about understanding
really what happened in begin update

00:38:52.070 --> 00:38:57.100
and end update when you redraw your
window in response to an update event,

00:38:57.190 --> 00:39:01.720
you don't have to listen now and
come back for the next slide.

00:39:01.790 --> 00:39:04.260
The story is that

00:39:05.090 --> 00:39:08.860
Originally, in the Mac Inters toolbox,
there was this concept of

00:39:08.860 --> 00:39:12.760
invalidating little regions in
the area that needed updating,

00:39:12.840 --> 00:39:17.090
and by the time you got
called with an update event,

00:39:17.280 --> 00:39:22.640
You didn't have to bother clipping your
drawing to whatever needed to be redrawn.

00:39:22.640 --> 00:39:25.440
It happened behind the scenes,
automatically.

00:39:25.440 --> 00:39:32.030
The HI Toolbox keeps track of
whatever needs to be redrawn.

00:39:32.040 --> 00:39:34.420
It keeps track of the update region.

00:39:34.420 --> 00:39:38.680
And this trick with begin
update used the visual region,

00:39:38.680 --> 00:39:41.060
this region in the graph port,
to achieve this.

00:39:41.080 --> 00:39:43.930
Because Quickdraw obviously
has to clip to all this.

00:39:44.560 --> 00:39:48.870
Now, if you carry this model over,
just to fix the ideas,

00:39:48.880 --> 00:39:52.920
assume the window content
is mirrored in a G-World.

00:39:52.920 --> 00:39:57.170
And what you are doing is you update
the little areas in the G-World as

00:39:57.170 --> 00:40:00.100
the need comes up in your application.

00:40:00.220 --> 00:40:05.700
And then each time you need to refresh,
every so often you just blast

00:40:05.700 --> 00:40:08.680
with a big copy of it the
whole G-World onto the screen.

00:40:08.680 --> 00:40:14.380
And you rely on the benefit that
automatically this big copy,

00:40:14.380 --> 00:40:17.050
every little bit of operation
is clipped out to what really

00:40:17.050 --> 00:40:18.380
needs to be transferred.

00:40:18.380 --> 00:40:22.380
If you would do this in
the same way with Quartz,

00:40:22.870 --> 00:40:26.380
then you might have a bad experience,
performance-wise,

00:40:26.720 --> 00:40:30.380
because this begin update mechanism,
Quartz doesn't know anything about it.

00:40:30.380 --> 00:40:34.380
There is no visual region in the
port and it just doesn't come in.

00:40:34.380 --> 00:40:40.910
So each time you would redraw the whole
content and that's not what you want.

00:40:42.230 --> 00:40:45.230
Well, of course, HIV use,
they address this.

00:40:45.400 --> 00:40:49.340
As soon as you adopt HIV use, again,
you don't have to worry about anything

00:40:49.340 --> 00:40:51.140
at all anymore in this matter.

00:40:51.140 --> 00:40:57.390
And in other cases,
it's one of those examples where...

00:40:57.630 --> 00:41:02.080
We need to rethink the approach
and replace existing code or

00:41:02.200 --> 00:41:07.320
the existing model by some
optimizations for this purpose.

00:41:07.330 --> 00:41:10.080
Now we come to regions as masks.

00:41:10.130 --> 00:41:12.090
Here is the

00:41:12.890 --> 00:41:16.060
Traditional QuickDraw
model to create a mask.

00:41:16.090 --> 00:41:19.690
You copy bits into a one-bit off-screen,
and if you're not happy with the way

00:41:19.820 --> 00:41:23.420
colors get mapped to black or white,
you put in a search proc,

00:41:23.420 --> 00:41:26.920
and you get precisely the region
that you want to obtain as a mask

00:41:26.920 --> 00:41:29.180
when you call bitmap to region.

00:41:29.840 --> 00:41:33.400
That's not how you can do it in Quartz.

00:41:33.400 --> 00:41:38.720
And to begin with,
masks are by design meant

00:41:39.020 --> 00:41:41.200
to be in the alpha channel.

00:41:41.280 --> 00:41:46.240
So how do you get these mask
bits into the alpha channel?

00:41:46.600 --> 00:41:50.710
It all depends, of course,
on what your specific application and

00:41:50.710 --> 00:41:53.660
your specific goals and needs are there.

00:41:54.040 --> 00:41:57.990
If it's something that you can
do ahead of time and then store,

00:41:58.040 --> 00:42:00.640
the proposition is just
do it once and for all,

00:42:00.640 --> 00:42:03.520
keep the alpha mask up to
date with what you want,

00:42:03.600 --> 00:42:06.360
and you have a picture
that you can use as is,

00:42:06.530 --> 00:42:09.650
and no need for mask region
handles at all anymore.

00:42:10.300 --> 00:42:13.590
The other proposal is to
tinker around with the pixels

00:42:13.590 --> 00:42:15.620
directly in a bitmap context.

00:42:15.750 --> 00:42:18.500
The bitmap context gives
you the base address,

00:42:18.500 --> 00:42:22.290
gives you the row bytes,
and you can basically work with it as you

00:42:22.290 --> 00:42:25.660
are used to with the pixels in a G-World,
in a Pixmap.

00:42:25.700 --> 00:42:31.370
This is not really a
satisfactory answer either,

00:42:31.370 --> 00:42:32.520
I know.

00:42:32.520 --> 00:42:37.730
And that's why for Tiger,
the API has been extended

00:42:37.730 --> 00:42:40.270
in this perspective.

00:42:40.360 --> 00:42:44.770
And now you can call CGImage,
create with mask, and CGContext,

00:42:45.050 --> 00:42:48.720
clip to mask, and in both cases the
mask is a deep mask.

00:42:48.900 --> 00:42:50.790
So this should help.

00:42:50.860 --> 00:42:56.100
Hit testing,
I mentioned it several times already.

00:42:56.280 --> 00:43:01.320
Often QuickDraw would set up the region
where it wants the point to compare

00:43:01.320 --> 00:43:03.450
against if it's contained or not.

00:43:03.580 --> 00:43:08.530
But the trick with drawing the
content and clipping it to the point

00:43:08.650 --> 00:43:12.050
where you want to check whether this
point gets drawn has been around

00:43:12.050 --> 00:43:13.540
since the beginning of QuickDraw.

00:43:13.540 --> 00:43:17.580
It was one of the first tricks
that I learned back in 84.

00:43:18.300 --> 00:43:19.440
So it's still good.

00:43:19.500 --> 00:43:25.780
And as long as in Quartz we don't have
the CG path contains point for a G-matrix

00:43:25.780 --> 00:43:31.830
solution and some accompanying utility
functions there to make this useful,

00:43:31.980 --> 00:43:35.560
really,
and it's there starting with Tiger only,

00:43:35.560 --> 00:43:41.220
you would have to look at the way
CarbonSketch does hit testing.

00:43:43.740 --> 00:43:46.440
Now would be a good time for a break.

00:43:46.470 --> 00:43:51.600
We are switching to a new chapter,
but Travis is scared,

00:43:51.600 --> 00:43:54.030
so I better continue.

00:43:56.160 --> 00:43:58.240
We are going to copy bits.

00:43:58.280 --> 00:44:07.720
I think some of you came to us long
ago already when QuickDraw and Quartz

00:44:08.330 --> 00:44:14.330
were opposed and compared and when
you were invited to embrace Quartz.

00:44:14.440 --> 00:44:18.690
And one of the first reactions was,
what do I do with all my copy bits calls?

00:44:18.830 --> 00:44:20.770
There is no copy bits in Quartz.

00:44:22.080 --> 00:44:27.170
Really, there is CG context draw
image and it will have to do.

00:44:27.690 --> 00:44:29.690
That's all we have got.

00:44:29.890 --> 00:44:33.270
Originally,
the general functionality is not there.

00:44:33.290 --> 00:44:36.720
And for good reasons, again,
if you think about the fundamental

00:44:37.210 --> 00:44:38.850
differences in the imaging model.

00:44:38.860 --> 00:44:42.830
So the first comment is,
maybe you don't need so many copy

00:44:42.830 --> 00:44:45.330
bits calls anymore to begin with.

00:44:45.460 --> 00:44:48.870
For one,
very often the usage of copy bits out

00:44:48.950 --> 00:44:54.620
from off-screen keywords and so on was
to work around the fact on System 9,

00:44:54.720 --> 00:44:58.120
on pre-System 10,
that Windows were not buffered and

00:44:58.120 --> 00:44:59.730
just wanted to avoid flickering.

00:44:59.740 --> 00:45:04.110
We wanted to composite things
one by one before they could

00:45:04.290 --> 00:45:06.530
be brought to the screen.

00:45:06.820 --> 00:45:10.160
Well, now with more experience about
how everything works on X,

00:45:10.160 --> 00:45:14.640
in many cases,
we have still code that is not necessary.

00:45:14.640 --> 00:45:20.970
We can use the compositing feature
in the Windows to our advantage and

00:45:20.970 --> 00:45:25.200
throw away much code and many keywords.

00:45:27.180 --> 00:45:31.630
ImageRefs also,
they stay around if you leave

00:45:31.630 --> 00:45:38.080
them around and if you learn
about the rules of using them,

00:45:38.080 --> 00:45:40.000
they are much more convenient.

00:45:40.000 --> 00:45:42.060
You don't have to set up and
juggle around with so many

00:45:42.060 --> 00:45:43.560
offscreens in general anymore.

00:45:43.560 --> 00:45:49.390
But in principle it's true,
the tandem of a G-World with the

00:45:49.390 --> 00:45:57.080
copy bits in terms of a cached
content to be brought to display

00:45:57.080 --> 00:46:03.710
corresponds to a CG bitmap context and
a corresponding CG context draw image.

00:46:03.800 --> 00:46:06.710
There's a link in between,
you need to set up a data

00:46:06.800 --> 00:46:08.240
provider for the image.

00:46:08.340 --> 00:46:13.540
It's not really as easy as it could be.

00:46:13.730 --> 00:46:17.910
It takes probably more than
half an hour to really learn it,

00:46:18.040 --> 00:46:20.560
how to use it the first time.

00:46:20.560 --> 00:46:22.560
And there are still some restrictions.

00:46:22.560 --> 00:46:25.770
We should never forget that
here the source pixels of

00:46:25.770 --> 00:46:27.560
an ImageRef are immutable.

00:46:27.560 --> 00:46:30.540
You cannot change them
once you have this.

00:46:30.650 --> 00:46:34.740
You can, but you might not be
happy with the results.

00:46:34.910 --> 00:46:37.450
And there are some other
missing conveniences,

00:46:37.450 --> 00:46:40.300
at least up to Tiger.

00:46:41.110 --> 00:46:44.600
Now we can create an image
with a sub-rectangle.

00:46:44.630 --> 00:46:47.950
And if you have been on Tuesday at
the session where all the new Quartz

00:46:48.150 --> 00:46:50.930
features have been introduced,
then this is just a way of

00:46:50.930 --> 00:46:53.730
repeating it and hammering it in.

00:46:54.010 --> 00:46:57.620
The image can be created
directly from the bitmap context,

00:46:57.620 --> 00:47:02.940
no intermediate tinkering around
with data providers anymore.

00:47:03.120 --> 00:47:06.570
And for Tiger,
because of the motivation and the needs

00:47:06.810 --> 00:47:13.540
that came up with hardware acceleration,
a new concept, the CG layer ref,

00:47:13.660 --> 00:47:18.670
that is particularly favorable
to cache drawing that then

00:47:18.740 --> 00:47:22.690
gets brought to the screen.

00:47:23.420 --> 00:47:27.880
The missing transfer modes,
Haroon has mentioned it.

00:47:28.000 --> 00:47:30.330
We don't have a precise
equivalent for the arithmetic

00:47:30.500 --> 00:47:32.770
transfer modes and everything,
but there are new features,

00:47:32.860 --> 00:47:37.840
new facilities,
new possibilities in the PDF blend modes,

00:47:37.860 --> 00:47:40.140
again starting with Tiger.

00:47:41.660 --> 00:47:47.260
And also, because going forward and
inviting all you Carbon developers

00:47:47.950 --> 00:47:51.150
to transition to Quartz,
we are going to cooperate

00:47:51.250 --> 00:47:56.040
much closer with HIToolbox and
make all this blend together.

00:47:56.110 --> 00:47:58.000
And one of the functions that's there,
for example,

00:47:58.000 --> 00:48:00.300
is HIView create off-screen image.

00:48:00.330 --> 00:48:03.590
In many cases,
you need to have your view and keep

00:48:03.640 --> 00:48:06.020
the content as is in an image ready.

00:48:06.140 --> 00:48:07.890
So there it is.

00:48:10.550 --> 00:48:11.330
Oh, yeah.

00:48:11.340 --> 00:48:13.690
Progressing nicely.

00:48:14.910 --> 00:48:16.460
Picts.

00:48:16.520 --> 00:48:17.920
QuickDraw had Picts.

00:48:17.980 --> 00:48:20.480
Quartz has PDF.

00:48:21.370 --> 00:48:26.660
It really doesn't make sense to
hang on to the picts when you

00:48:26.660 --> 00:48:29.040
move your drawing to Quartz.

00:48:29.940 --> 00:48:33.500
And as I brought up here
in the second bullet point,

00:48:33.510 --> 00:48:36.300
we need to start
supporting copy and paste.

00:48:36.310 --> 00:48:42.270
Only the PDF format really
captures all the details,

00:48:42.350 --> 00:48:46.850
all the finesse of Quartz drawing.

00:48:47.310 --> 00:48:53.080
There is, has been,
the call QDPickDraw to CG Context.

00:48:53.520 --> 00:48:58.900
It draws a pict into a CG context,
whatever the CG context is.

00:49:00.620 --> 00:49:05.890
Well, this code has to convert,
has to translate from the QuickDraw

00:49:06.030 --> 00:49:09.230
drawing model into the PDF drawing model.

00:49:09.240 --> 00:49:15.120
And that's potentially a lot of work,
which means it might be a performance

00:49:15.120 --> 00:49:19.520
problem if you call this many
times with many pictures and so on.

00:49:19.520 --> 00:49:22.380
In this case,
the workaround we recommend is, well,

00:49:22.540 --> 00:49:26.150
just draw it into a PDF context,
hang on to the PDF data,

00:49:26.280 --> 00:49:28.570
and use those from then on.

00:49:28.600 --> 00:49:31.920
And one step further,
if you have hundreds of pictures,

00:49:31.920 --> 00:49:36.210
I know it's not trivial,
but consider moving them

00:49:36.210 --> 00:49:37.470
over in the same process.

00:49:37.480 --> 00:49:42.350
In particular, if you know that...

00:49:42.670 --> 00:49:49.030
As in the last line,
that the picture that came out compressed

00:49:49.030 --> 00:49:54.980
from Photoshop actually is just a wrapper
around JPEG data that get decompressed

00:49:55.070 --> 00:49:57.640
by QuickTime through a QuickTime opcode.

00:49:57.660 --> 00:50:01.280
Think about all the machinery that
has to be put in place to get through.

00:50:01.280 --> 00:50:05.370
It really doesn't make sense
anymore when you approach the Quartz

00:50:05.590 --> 00:50:09.950
API where you have CG image create
with JPEG data provider right away.

00:50:10.570 --> 00:50:13.460
So just keep them,
the JPEG data themselves.

00:50:13.680 --> 00:50:17.750
Before there is this line that says
some pictures don't convert well.

00:50:17.800 --> 00:50:21.690
Of course,
we know they don't print well either.

00:50:21.800 --> 00:50:26.560
There are some of them are still around
and you need to convert them anyway.

00:50:26.580 --> 00:50:32.670
Probably the trick is to just draw
them into a PIX map and then create a

00:50:32.740 --> 00:50:35.980
new picture that's just plain pixels.

00:50:37.940 --> 00:50:42.950
So back to the copy-paste business.

00:50:43.290 --> 00:50:46.600
I hate bringing up
source code on a slide.

00:50:46.630 --> 00:50:48.400
This is just a list of some of the calls.

00:50:48.410 --> 00:50:51.470
They're all a little
bit lengthy in spelling.

00:50:51.580 --> 00:50:56.860
You have to set up the PDF context
to draw your content that has

00:50:56.920 --> 00:51:00.780
to go on the pasteboard into
it to capture the PDF data,

00:51:00.900 --> 00:51:02.660
and then you can bring them up.

00:51:02.680 --> 00:51:09.050
And the other comment is there
is this com.adobe.pdf literal.

00:51:09.280 --> 00:51:11.610
Finally, in Tiger,
we get the symbolic constant for that.

00:51:12.520 --> 00:51:15.980
It's not too early in
the universal types.

00:51:16.560 --> 00:51:21.210
and pasting is a little bit longer
too than this just single call.

00:51:21.210 --> 00:51:25.920
The recommendation is,
that's why it's there, CarbonSketch,

00:51:25.960 --> 00:51:30.670
look at it and go through and
probably you can copy paste

00:51:30.700 --> 00:51:34.680
a lot of the source code,
but please start adopting

00:51:34.680 --> 00:51:37.840
copying and pasting PDF data.

00:51:37.840 --> 00:51:40.710
We need to get there.

00:51:42.340 --> 00:51:49.040
Another chapter in the story of
transition into Quartz is color spaces.

00:51:50.360 --> 00:51:55.000
You start coding with the Quartz API,
don't know yet how many calls

00:51:55.000 --> 00:51:57.340
are there and which calls are
there and what you have to do.

00:51:57.380 --> 00:52:00.420
You set the bitmap context and you
look through the parameters that

00:52:00.540 --> 00:52:03.960
you need to provide and suddenly
you need to provide a color space.

00:52:03.990 --> 00:52:06.530
We didn't have color spaces in QuickDraw,
we don't know what it is,

00:52:06.690 --> 00:52:11.420
so we look at the file color space dot
h and we search for a way to get the

00:52:11.420 --> 00:52:14.240
color space to plug it in as parameter.

00:52:14.270 --> 00:52:16.300
And my first

00:52:17.170 --> 00:52:23.020
The solution was to just grab the
CG Color Space Create Device RGB because

00:52:23.020 --> 00:52:25.730
it was the simplest one and
it sounded plausible enough

00:52:25.850 --> 00:52:26.980
that that's what I wanted.

00:52:27.000 --> 00:52:31.690
And then comes one day
David Gelfman again and says,

00:52:31.800 --> 00:52:32.670
oh, don't do that.

00:52:32.790 --> 00:52:35.140
I will show you,
I will give you all the code.

00:52:35.360 --> 00:52:38.760
That's how you have to do
it to use generic RGB color.

00:52:38.760 --> 00:52:42.700
And remember when I showed you
the blue pixel that actually,

00:52:42.870 --> 00:52:47.200
by the time it got to the screen,
was slightly modified with some

00:52:47.220 --> 00:52:49.840
other component added in to
do the right color matching?

00:52:49.840 --> 00:52:50.940
You get it for free.

00:52:50.940 --> 00:52:55.650
And because in such an application
we would copy-paste content with

00:52:55.740 --> 00:53:00.300
colors or save to a PDF file,
we are really interested in getting

00:53:00.300 --> 00:53:03.140
the correct colors all over the place.

00:53:05.690 --> 00:53:07.580
So that's the model,
that's the recommendation.

00:53:07.680 --> 00:53:12.760
Unfortunately, again,
we had to wait until Tiger to

00:53:12.840 --> 00:53:18.690
get the real easy call that gives
us this generic color space.

00:53:18.880 --> 00:53:22.630
Before,
it required several lines of code,

00:53:22.640 --> 00:53:24.670
which I haven't brought up here.

00:53:24.670 --> 00:53:26.490
No point.

00:53:26.580 --> 00:53:29.350
I invite you to look at it
in Carbon Sketch and to just

00:53:29.350 --> 00:53:32.630
copy-paste it out again,
and then you get the generic color

00:53:32.630 --> 00:53:34.490
space for all your RGB needs.

00:53:36.410 --> 00:53:40.690
Um, yeah, there's this last point,
and we have had some

00:53:40.800 --> 00:53:41.830
discussions about it.

00:53:41.940 --> 00:53:46.570
Of course,
color matching takes CPU cycles,

00:53:46.570 --> 00:53:51.980
and there are situations when you
cannot afford it or when you really

00:53:51.980 --> 00:53:54.890
are hurting because of this fact.

00:53:55.000 --> 00:53:57.900
In some extreme cases,
you only go to display,

00:53:57.900 --> 00:54:00.170
you only have some specific needs.

00:54:02.060 --> 00:54:06.600
We are not really perfectly
well prepared for the situation,

00:54:06.600 --> 00:54:09.580
and that's why we promised a
tech note sometime soon that

00:54:09.580 --> 00:54:13.220
addresses all these questions.

00:54:13.470 --> 00:54:16.300
to bring in this new
concept of color spaces.

00:54:16.370 --> 00:54:20.740
Probably I should have also pointed
out that as it's written on the slide,

00:54:20.840 --> 00:54:24.860
for Tiger the behavior is bound to
change the behavior of device RGB.

00:54:24.890 --> 00:54:27.470
The device RGB color space

00:54:27.820 --> 00:54:32.860
So you're going to get different behavior
between Pantheon and Tiger if you

00:54:32.860 --> 00:54:35.250
already use the device RGB color space.

00:54:35.750 --> 00:54:40.970
From Tiger on,
it's likely to be color matched.

00:54:41.000 --> 00:54:43.130
So in summary...

00:54:44.530 --> 00:54:51.310
There is stuff that gets left on
the way during this transition.

00:54:51.830 --> 00:54:56.630
Those infamous QuickDraw transfer modes,
all 173 of them,

00:54:56.640 --> 00:54:58.540
or I don't know how many.

00:55:00.010 --> 00:55:07.420
Well, we cannot pixel by pixel reproduce
everything that QuickDraw did.

00:55:07.520 --> 00:55:08.890
It just doesn't make sense.

00:55:09.070 --> 00:55:09.900
Time goes on.

00:55:09.910 --> 00:55:12.960
And as you can see on the
user interface of Mac OS X,

00:55:12.960 --> 00:55:16.290
all those applications that
don't use any QuickDraw,

00:55:16.300 --> 00:55:18.380
you can't live without those.

00:55:18.760 --> 00:55:19.860
It looks different.

00:55:19.860 --> 00:55:23.180
We have new ways of selecting,
of drag-selecting something by using

00:55:23.180 --> 00:55:26.890
a grayish transparent overlay window,
for example, if you like that.

00:55:26.980 --> 00:55:30.610
And if not, in Carbon Sketch,
I still use the marching ants

00:55:30.780 --> 00:55:32.720
frame for drag selection.

00:55:32.720 --> 00:55:36.850
With overlay windows,
it's really nice how you can achieve

00:55:37.010 --> 00:55:42.560
effects which would have been extremely
difficult to reproduce in QuickDraw.

00:55:42.580 --> 00:55:48.420
If you remember playing around in
Carbon Sketch and creating objects

00:55:48.610 --> 00:55:51.920
and... resizing them and so on,
it looks pretty good by taking

00:55:51.980 --> 00:55:56.230
advantage of overlay windows,
which you could conceivably even stack

00:55:56.240 --> 00:56:00.810
for special purposes and special needs,
and using transparency when you're

00:56:01.130 --> 00:56:06.080
drawing into the overlay window so you
can still compare with what's underneath.

00:56:07.790 --> 00:56:10.170
And then we have this PDF blend modes.

00:56:10.270 --> 00:56:12.780
I haven't looked closer
at them myself yet.

00:56:12.940 --> 00:56:14.020
We will see what we can do.

00:56:14.410 --> 00:56:21.620
The possibilities are richer than
whatever we had known in QuickDraw.

00:56:21.660 --> 00:56:26.250
The Graphport has this bottleneck

00:56:27.110 --> 00:56:33.100
Prox Concept and every QuickDraw
developer was proud when he first hooked

00:56:33.210 --> 00:56:36.140
in there and achieved special effects.

00:56:36.270 --> 00:56:38.310
and we got used to it.

00:56:38.310 --> 00:56:41.660
They are not there anymore,
there are no bottlenecks in Quartz.

00:56:41.700 --> 00:56:45.410
In Tiger,
we have this new feature of being

00:56:45.410 --> 00:56:53.030
able to scan and get called back
for each opcode in a content stream,

00:56:53.030 --> 00:56:54.260
a PDF content stream.

00:56:54.310 --> 00:57:00.000
This is in... it's not equivalent,
it's much richer.

00:57:00.950 --> 00:57:04.900
It depends all on what you try to achieve
when you're hooked in the bottlenecks.

00:57:04.940 --> 00:57:10.660
In most cases you don't need to begin
with anymore in the Quartz drawing model.

00:57:10.680 --> 00:57:15.750
But if you really want to get very
close control of everything that's going

00:57:15.880 --> 00:57:19.740
on drawing-wise in your application,
that's the way to go.

00:57:19.780 --> 00:57:26.370
And as Haroon pointed out, some pieces,
they are lost forever.

00:57:27.930 --> 00:57:32.490
In exchange, I thought I should point
out how much you win.

00:57:32.490 --> 00:57:34.670
Again, so that's a little bit
of propaganda thing,

00:57:34.670 --> 00:57:39.800
but just right after the
downer of what you are losing.

00:57:39.910 --> 00:57:43.540
There's so much more excitement
in this new graphics model.

00:57:43.830 --> 00:57:48.880
You can do things that would
have been extremely difficult

00:57:48.880 --> 00:57:50.510
to achieve them in QuickDraw.

00:57:50.790 --> 00:57:57.050
And you can see how often we refer to
Tiger with new APIs that are there to

00:57:57.200 --> 00:58:02.210
make the transition easy and comfortable.

00:58:02.390 --> 00:58:04.750
We have finally a lot
of new documentation,

00:58:04.820 --> 00:58:08.300
we have the new sample code,
more is to come,

00:58:08.300 --> 00:58:13.140
and I'm personally ambitious to make
Carbon Sketch into something that

00:58:13.290 --> 00:58:14.720
should respond to all your questions.

00:58:14.720 --> 00:58:18.380
So bring the feedback,
bring the requests, bring the criticisms.

00:58:21.760 --> 00:58:25.600
Performance, of course,
has been an issue from the beginning.

00:58:25.640 --> 00:58:29.690
If you set out and set up a

00:58:31.050 --> 00:58:34.900
Performance, of course,
has been an issue from the beginning.

00:58:34.900 --> 00:58:39.380
If you set out and set up a

00:58:39.700 --> 00:58:46.100
You will find still today cases
where Quartz is slower and

00:58:46.200 --> 00:58:47.490
sometimes quite substantially.

00:58:47.600 --> 00:58:51.390
On the other hand,
if you measure your time in

00:58:51.500 --> 00:58:57.220
your application percentage-wise
of the whole processing time,

00:58:57.220 --> 00:59:00.370
which percentage is used for drawing,
for display,

00:59:00.370 --> 00:59:04.240
and which percentage is used for
everything else in the system.

00:59:05.230 --> 00:59:10.530
And if it turns out that you spend about
10% of your processor time in drawing,

00:59:10.540 --> 00:59:13.120
then you can put it in perspective.

00:59:13.120 --> 00:59:19.810
It's in many cases where you think it's,
the performance is a problem,

00:59:19.810 --> 00:59:21.160
it actually isn't.

00:59:21.420 --> 00:59:22.730
And then there are cases where it is.

00:59:26.080 --> 00:59:30.080
And I will come back to
that in a couple of minutes.

00:59:30.460 --> 00:59:35.340
So the message here, which we repeat,
QuickDraw is an obstacle

00:59:35.910 --> 00:59:38.180
against hardware acceleration.

00:59:38.190 --> 00:59:43.220
And we want to take advantage
of it in the future as it comes.

00:59:43.300 --> 00:59:48.640
So QuickDraw really isn't a good
citizen anymore on the system.

00:59:48.650 --> 00:59:50.740
And then there are some
other recommendations.

00:59:50.740 --> 00:59:52.830
I don't even need to comment on them.

00:59:52.920 --> 00:59:56.630
You know, I just copied them over
from the documentation that

00:59:56.710 --> 00:59:59.900
we have about performance.

00:59:59.900 --> 01:00:04.280
And the concept of CG layers
in particular bears repeating.

01:00:04.280 --> 01:00:07.880
It's something new,
and we want to just emphasize

01:00:07.880 --> 01:00:12.140
it that for the future,
that's really something to--

01:00:12.320 --> 01:00:13.030
Look at.

01:00:13.030 --> 01:00:16.240
Yeah, here's the time when I come back
to the performance question.

01:00:16.240 --> 01:00:20.060
Can we flip to the demo machine, please?

01:00:27.500 --> 01:00:32.160
I think most of you have seen
it already over this week,

01:00:32.160 --> 01:00:34.920
and I'm entitled to show it once more,
one last time.

01:00:34.920 --> 01:00:37.780
Some of you may remember who
have been here two years ago

01:00:37.780 --> 01:00:39.840
that I showed it two years ago.

01:00:41.150 --> 01:00:44.760
These are 88,000 line segments.

01:00:44.780 --> 01:00:46.790
They come from

01:00:47.300 --> 01:00:52.300
Jean-Paul Armand,
developer of CAD program.

01:00:52.420 --> 01:00:56.660
He had trouble on Mac OS X with
QuickDraw because QuickDraw line drawing

01:00:56.660 --> 01:00:58.560
was so much slower than on Mac OS 9.

01:00:58.560 --> 01:01:03.050
So two years ago for Jaguar,
I compared what you can do and

01:01:03.050 --> 01:01:07.360
explained what you can do to make
it competitive with Mac OS 9.

01:01:07.400 --> 01:01:09.790
And I was proud of it.

01:01:10.080 --> 01:01:14.730
And nowadays,
it's just pathetic if you flip

01:01:15.770 --> 01:01:20.810
to software rendering in Quartz.

01:01:21.830 --> 01:01:25.180
You might ask, why didn't I show Quartz
2D two years ago already?

01:01:25.180 --> 01:01:28.940
Well,
because two years ago it wasn't so fast.

01:01:29.100 --> 01:01:31.380
It was still slower than QuickDraw.

01:01:32.890 --> 01:01:37.910
And this is only progress that has been
made within Quartz in software rendering.

01:01:38.030 --> 01:01:41.150
And you probably have seen
the hardware rendering case.

01:01:41.500 --> 01:01:45.520
And it becomes, it's not even funny.

01:01:49.570 --> 01:01:51.410
I mentioned some other things.

01:01:51.490 --> 01:01:58.390
Again, I think two years ago I had
something similar to this.

01:02:00.300 --> 01:02:29.700
[Transcript missing]

01:02:30.100 --> 01:02:35.680
The way I set this up is I install
a timer and measure the time

01:02:35.680 --> 01:02:37.280
that's used for actual drawing.

01:02:37.340 --> 01:02:40.090
And then everything else,
so here in this case,

01:02:40.090 --> 01:02:44.130
drawing time in the system
is 7.5%. With Quartz,

01:02:44.130 --> 01:02:47.300
what if I do QuickDraw?

01:02:47.300 --> 01:02:53.090
It's 7.7%. And of course it would
fluctuate if we would repeat.

01:02:53.230 --> 01:02:56.340
So this is nearly the same,
it's practically the same.

01:02:56.350 --> 01:02:56.700
Why?

01:02:56.700 --> 01:02:59.680
Because this is just
copy bits on QuickDraw,

01:02:59.680 --> 01:03:03.720
and on the Quartz side, it's just

01:03:03.780 --> 01:03:08.850
CgContext Draw Image because I set
up this image ref with the pixels

01:03:09.000 --> 01:03:12.100
from the off-screen G-World.

01:03:12.290 --> 01:03:20.800
Copy bits in QuickDraw as often as it can
just passes the job off to Core Graphics

01:03:20.800 --> 01:03:23.400
and it ends up resizing the same code.

01:03:23.440 --> 01:03:27.960
So no wonder they are
about the same performance.

01:03:27.990 --> 01:03:30.770
Then I tried to bump up

01:03:31.570 --> 01:03:33.780
The percentage of drawing time.

01:03:34.020 --> 01:03:36.100
Each frame I just repeat it.

01:03:36.110 --> 01:03:40.030
I repeat it to saturate the machine
such that it gets more work to do.

01:03:40.030 --> 01:03:43.500
And you notice it gets already slower.

01:03:43.500 --> 01:03:44.940
It's already suffering a little bit.

01:03:45.290 --> 01:03:48.120
The priorities in scheduling kick in.

01:03:48.120 --> 01:03:51.910
And I could bring it up to
about 90% and then the system

01:03:52.050 --> 01:03:54.360
refuses to let me take more CPU.

01:03:56.510 --> 01:04:04.340
So I get 16 repetitions per frame,
drawing time between 50 and

01:04:04.340 --> 01:04:07.720
60%. If now I flip to Quartz--

01:04:09.140 --> 01:04:15.510
55%. The behavior is
not always reproducible.

01:04:15.590 --> 01:04:18.290
What I meant to show
was that in many cases,

01:04:18.290 --> 01:04:22.630
and maybe I just went too far,
it turns out that

01:04:23.790 --> 01:04:28.380
Drawing time in Quartz becomes
more favorable as you put

01:04:28.380 --> 01:04:32.030
more load on the machine.

01:04:32.200 --> 01:04:35.980
Well, as it happens,
it's just not so spectacular

01:04:35.980 --> 01:04:35.980
anymore now in this case.

01:04:37.730 --> 01:04:42.580
which means I don't have to
explain or to comment about it.

01:04:42.610 --> 01:04:47.060
And then comes another case,
again which is purely artificial.

01:04:47.060 --> 01:04:51.770
It goes back to this idea that you do
a big copy bits from your off screen,

01:04:51.870 --> 01:04:54.490
but you clip out only little areas.

01:04:54.920 --> 01:04:57.490
What I'm doing here is,
it's the same model as

01:04:57.550 --> 01:05:00.810
in the bull's eye before,
but I'm clipping each one to

01:05:00.810 --> 01:05:03.280
the nine little rectangles.

01:05:03.280 --> 01:05:07.110
And in between each frame,
I change the content of

01:05:07.110 --> 01:05:09.700
these nine little rectangles.

01:05:09.760 --> 01:05:15.840
The idea is that you say you have
some window content that reflects

01:05:15.840 --> 01:05:21.040
some hardware input in real time and
you want to display how it changes.

01:05:21.040 --> 01:05:24.020
So that's how you would
do it in QuickDraw.

01:05:24.800 --> 01:05:27.580
You have this off screen,
you twiggle around whatever

01:05:27.650 --> 01:05:30.420
needs to be updated,
you do one big copy bits call

01:05:30.560 --> 01:05:32.280
to bring it back on screen.

01:05:32.480 --> 01:05:37.970
And same thing,
I wanted to see how this compares

01:05:38.070 --> 01:05:41.000
with using Quartz and QuickDraw.

01:05:43.170 --> 01:05:47.800
And it turns out that Quartz
looks a little bit unfavorable

01:05:47.800 --> 01:05:50.130
in comparison to QuickDraw.

01:05:50.330 --> 01:05:55.780
And maybe this was the case
which I remembered where bumping

01:05:55.790 --> 01:06:00.550
up the repetitions suddenly
made Quartz look much better.

01:06:00.850 --> 01:06:01.740
See?

01:06:01.850 --> 01:06:04.620
Quartz takes 9% drawing
time by 16 repetitions.

01:06:04.650 --> 01:06:07.320
QuickDraw takes nearly twice as much.

01:06:13.010 --> 01:06:17.740
So here we can comment about
what's going on and how come that

01:06:18.260 --> 01:06:22.720
as soon as you put more load,
more graphics load on the system,

01:06:22.720 --> 01:06:24.300
Quartz starts looking better.

01:06:24.300 --> 01:06:26.940
The previous example probably
was just too trivial.

01:06:26.940 --> 01:06:30.090
There wasn't much to be gained.

01:06:30.100 --> 01:06:33.190
And here it turns out that internally
the architecture of Quartz,

01:06:33.350 --> 01:06:36.200
the way it's designed and
implemented is just so much

01:06:36.380 --> 01:06:40.230
more advanced than QuickDraw,
which is tied to a

01:06:40.230 --> 01:06:44.600
design that had to match,
that corresponded to hardware

01:06:45.040 --> 01:06:47.080
reality of more than 20 years ago.

01:06:50.520 --> 01:06:52.050
I think I should stop at this time.

01:06:52.200 --> 01:06:54.570
Let's go back to the slides once more,
please.

01:07:02.970 --> 01:07:05.400
I come to the conclusions.

01:07:05.400 --> 01:07:06.420
Of course, it's not trivial.

01:07:06.420 --> 01:07:09.220
Of course, it will take work.

01:07:09.220 --> 01:07:13.520
And we need to learn something new,
and we need to rethink certain things.

01:07:13.650 --> 01:07:15.240
I feel it's a good thing.

01:07:15.310 --> 01:07:19.620
I feel rejuvenated since
I started learning something new.

01:07:19.670 --> 01:07:22.660
Maybe this can entice
some of you as well.

01:07:22.660 --> 01:07:27.350
And above all,
it's really the right thing to do.

01:07:27.610 --> 01:07:29.980
Think about the tailwind.

01:07:29.980 --> 01:07:30.730
It's good karma.

01:07:30.730 --> 01:07:30.730
Trust me.

01:07:31.080 --> 01:07:33.380
and I'm repeating what Haroon offered.

01:07:33.480 --> 01:07:35.080
We are here to help.

01:07:35.080 --> 01:07:37.730
In particular myself,
who has a background in

01:07:37.730 --> 01:07:38.940
developer technical support.

01:07:39.040 --> 01:07:41.580
Long ago, I just cannot help it.

01:07:41.750 --> 01:07:44.990
So, see you in the lab afterwards.

01:07:44.990 --> 01:07:51.500
I will be there together
with the other members of the

01:07:51.500 --> 01:07:54.990
group and we want to help you,
bring you over to Quartz.

01:07:55.680 --> 01:08:00.350
Travis Brown is the man to
talk to with everything,

01:08:00.350 --> 01:08:03.790
bring all your feedback,
all your requests.

01:08:05.250 --> 01:08:07.750
As I mentioned,
we are proud of all the new

01:08:07.750 --> 01:08:09.460
documentation we have now.

01:08:09.800 --> 01:08:12.200
You will find everything down
from the reference library,

01:08:12.250 --> 01:08:13.340
graphics and imaging.

01:08:18.720 --> 01:08:22.910
There is sample code and
unfortunately I don't have the

01:08:22.910 --> 01:08:27.980
precise path to Carbon Sketch,
but Carbon Sketch is not alone and we

01:08:27.980 --> 01:08:33.630
are working on making it richer and
we have the Quartz dev mailing list.
WEBVTT

00:00:07.516 --> 00:00:16.500
[ Music ]

00:00:22.516 --> 00:00:29.036
[ Applause ]

00:00:29.536 --> 00:00:30.556
>> Hi, I'm Alex.

00:00:30.676 --> 00:00:31.886
I work for a group at Apple

00:00:31.886 --> 00:00:33.206
called Tools Foundation.

00:00:33.336 --> 00:00:34.576
Normally we get to do fun stuff

00:00:34.576 --> 00:00:35.726
like operating systems and

00:00:35.726 --> 00:00:36.286
compilers.

00:00:36.826 --> 00:00:37.776
But this year we got to do

00:00:37.776 --> 00:00:38.656
something a little different.

00:00:38.986 --> 00:00:40.036
We built a game called

00:00:40.036 --> 00:00:40.596
SwiftShot.

00:00:41.116 --> 00:00:42.246
Some of you may have seen it

00:00:42.246 --> 00:00:44.056
earlier today and you might have

00:00:44.056 --> 00:00:45.116
played it downstairs.

00:00:45.866 --> 00:00:48.036
But the important part is that

00:00:48.386 --> 00:00:50.176
SwiftShot is a showcase of some

00:00:50.176 --> 00:00:51.676
of the new functionality in

00:00:51.676 --> 00:00:52.136
ARKit.

00:00:52.906 --> 00:00:55.646
ARKit 2 is now available on

00:00:55.646 --> 00:00:57.006
hundreds of millions of devices,

00:00:57.376 --> 00:00:58.856
providing a platform for

00:00:59.176 --> 00:01:00.756
engaging AR experiences.

00:01:01.216 --> 00:01:02.576
And you are able to reach the

00:01:02.576 --> 00:01:03.786
widest possible audience with

00:01:03.786 --> 00:01:04.025
that.

00:01:04.916 --> 00:01:06.756
There is no special setup, just

00:01:06.756 --> 00:01:08.546
point the device's camera at a

00:01:08.666 --> 00:01:09.916
surface and start playing.

00:01:11.506 --> 00:01:13.896
It's integrated into iOS.

00:01:14.666 --> 00:01:16.206
First-party and third-party

00:01:16.206 --> 00:01:17.346
engines like SceneKit and

00:01:17.346 --> 00:01:19.826
SpriteKit as well as third-party

00:01:19.826 --> 00:01:22.396
ones like Unreal and Unity have

00:01:22.476 --> 00:01:23.486
a full integration at this

00:01:23.486 --> 00:01:24.000
point.

00:01:28.536 --> 00:01:29.686
A little agenda for you.

00:01:29.866 --> 00:01:30.976
First we're going to talk some

00:01:31.376 --> 00:01:32.896
game design principles for

00:01:32.896 --> 00:01:34.216
augmented reality, a few of the

00:01:34.216 --> 00:01:35.666
things we learned along the way.

00:01:36.886 --> 00:01:38.336
We are going to go deep into the

00:01:38.336 --> 00:01:40.186
internals of the game and in

00:01:40.186 --> 00:01:40.976
particular, we are going to

00:01:40.976 --> 00:01:42.426
cover WorldMap sharing which is

00:01:42.426 --> 00:01:43.676
a new feature in ARKit 2.

00:01:43.676 --> 00:01:45.556
And we will also talk about

00:01:45.556 --> 00:01:46.816
networking and physics and how

00:01:46.816 --> 00:01:47.726
we made that work.

00:01:48.726 --> 00:01:51.006
First, let's, you know, take a

00:01:51.576 --> 00:01:54.426
deep look at the game.

00:01:55.516 --> 00:02:29.500
[ Music ]

00:02:34.296 --> 00:02:35.496
So, let's talk a little bit

00:02:35.496 --> 00:02:37.246
about designing games for

00:02:37.246 --> 00:02:39.626
augmented reality.

00:02:40.486 --> 00:02:42.656
Above all else, gameplay comes

00:02:42.656 --> 00:02:42.976
first.

00:02:42.976 --> 00:02:46.086
You should ask yourself if you

00:02:46.086 --> 00:02:47.386
are designing a game, would this

00:02:47.386 --> 00:02:50.116
game be fun and enjoyable if it

00:02:50.116 --> 00:02:52.376
were just 1970s graphics or

00:02:52.636 --> 00:02:55.466
plain, flat-shaded grey cubes.

00:02:56.336 --> 00:02:58.166
It is worth prototyping with

00:02:58.166 --> 00:03:00.996
those kinds of artwork and get

00:03:00.996 --> 00:03:02.026
that gameplay down.

00:03:02.216 --> 00:03:03.416
Because if it's fun with those

00:03:03.416 --> 00:03:05.136
boring grey boxes, it's going to

00:03:05.136 --> 00:03:06.126
be fun when you add all the

00:03:06.126 --> 00:03:07.246
graphics and sound later.

00:03:08.446 --> 00:03:10.376
You should spend time refining

00:03:10.376 --> 00:03:12.306
that and don't convince yourself

00:03:12.306 --> 00:03:14.216
that if I just add another 5%

00:03:14.216 --> 00:03:15.546
better graphics, or that one

00:03:15.546 --> 00:03:16.776
feature, that the game is

00:03:16.776 --> 00:03:17.746
suddenly going to be fun.

00:03:18.496 --> 00:03:19.746
Because, you know, there's a

00:03:19.746 --> 00:03:20.796
wasteland of games out there

00:03:20.796 --> 00:03:22.316
that were never fun from the

00:03:22.316 --> 00:03:22.756
get-go.

00:03:22.926 --> 00:03:24.916
So, try not to fool yourself.

00:03:25.396 --> 00:03:28.186
Let's start with the gameplay.

00:03:31.476 --> 00:03:32.456
Keep games short.

00:03:34.046 --> 00:03:35.476
You are looking for a typical

00:03:35.476 --> 00:03:37.606
mobile experience still - easy

00:03:37.606 --> 00:03:38.526
in, easy out.

00:03:39.926 --> 00:03:43.196
You want to keep a variety of

00:03:43.246 --> 00:03:44.906
content so that it is fresh,

00:03:45.096 --> 00:03:46.836
avoid mental fatigue on the part

00:03:46.866 --> 00:03:47.816
of the player of repeating the

00:03:47.816 --> 00:03:51.776
same thing over and over again.

00:03:51.846 --> 00:03:53.276
One of the things we learned is

00:03:53.276 --> 00:03:54.726
that spectating the game turned

00:03:54.726 --> 00:03:55.986
out to be just as fun as playing

00:03:55.986 --> 00:03:56.076
it.

00:03:56.546 --> 00:03:57.596
Sitting there on the sidelines

00:03:57.596 --> 00:03:58.436
and watching like it is a

00:03:58.436 --> 00:03:59.736
sporting match going side to

00:03:59.736 --> 00:04:02.426
side, that is just a really

00:04:02.426 --> 00:04:03.446
enjoyable experience.

00:04:03.996 --> 00:04:04.866
It's something to think about.

00:04:07.666 --> 00:04:09.536
Games are a key form of social

00:04:09.536 --> 00:04:10.586
and personal interaction.

00:04:12.336 --> 00:04:14.136
Augmented reality can offer a

00:04:14.336 --> 00:04:16.716
kind of personal touch that you

00:04:16.716 --> 00:04:18.646
might have had before playing

00:04:18.646 --> 00:04:19.935
like a traditional card game

00:04:19.935 --> 00:04:20.875
around the table with older

00:04:20.875 --> 00:04:21.565
relatives.

00:04:22.065 --> 00:04:24.696
But now you have technology to

00:04:24.696 --> 00:04:25.516
help along the way.

00:04:27.226 --> 00:04:31.146
It isn't enough to just take a

00:04:31.146 --> 00:04:33.196
3D game and put it on a table in

00:04:33.196 --> 00:04:33.616
front of you.

00:04:34.406 --> 00:04:35.736
With augmented reality, you know

00:04:35.736 --> 00:04:36.966
how the device is positioned.

00:04:37.686 --> 00:04:39.416
You also know a little bit about

00:04:39.416 --> 00:04:41.566
the user's environment and you

00:04:41.566 --> 00:04:42.526
should try to take advantage of

00:04:42.526 --> 00:04:43.676
that in the game and make

00:04:43.676 --> 00:04:45.246
experiences that are really for

00:04:45.246 --> 00:04:46.536
augmented reality first.

00:04:51.036 --> 00:04:53.076
Your device can be used as a

00:04:53.076 --> 00:04:54.956
camera to look inward at an

00:04:54.956 --> 00:04:56.116
object of focus.

00:04:56.916 --> 00:04:59.116
In this case, this is a 3D

00:04:59.116 --> 00:05:00.686
puzzle game where we're looking

00:05:00.686 --> 00:05:01.986
to repair a broken vase.

00:05:02.206 --> 00:05:03.186
We can look all around it,

00:05:03.676 --> 00:05:04.706
figure out what piece goes

00:05:04.706 --> 00:05:06.066
where, and do our best on the

00:05:06.066 --> 00:05:06.566
repairs.

00:05:07.626 --> 00:05:08.996
In SwiftShot, we took a similar

00:05:08.996 --> 00:05:09.506
concept.

00:05:10.036 --> 00:05:11.246
The focus is the table you're

00:05:11.246 --> 00:05:12.876
playing on and you can walk

00:05:12.876 --> 00:05:13.366
around it.

00:05:14.006 --> 00:05:15.606
But the table isn't just a

00:05:15.606 --> 00:05:16.866
tracking surface for augmented

00:05:16.866 --> 00:05:17.226
reality.

00:05:17.526 --> 00:05:18.346
It's an integral part of the

00:05:18.346 --> 00:05:18.786
gameplay.

00:05:19.706 --> 00:05:21.176
The height of the table is

00:05:21.256 --> 00:05:23.666
actually significant and as a

00:05:23.666 --> 00:05:24.886
result, you'll see in the game

00:05:24.886 --> 00:05:26.396
that there are slingshots at

00:05:26.396 --> 00:05:27.646
different heights on tops of

00:05:27.646 --> 00:05:29.956
stacks of blocks in order to

00:05:30.536 --> 00:05:32.196
give you better shots or take

00:05:32.196 --> 00:05:33.686
advantage of the player dodging

00:05:33.686 --> 00:05:36.976
and weaving a little bit.

00:05:37.816 --> 00:05:39.006
Another possible principle is

00:05:39.006 --> 00:05:40.296
your device is a camera you use

00:05:40.296 --> 00:05:41.336
to look around you.

00:05:41.906 --> 00:05:47.026
In this case, we're looking for

00:05:47.256 --> 00:05:49.156
unicorns hiding out in the

00:05:49.156 --> 00:05:50.266
wilderness and we're taking

00:05:50.266 --> 00:05:50.896
pictures of them.

00:05:53.046 --> 00:05:54.576
It's just around you, not

00:05:55.136 --> 00:05:55.516
inward.

00:05:56.736 --> 00:06:01.576
The device can also be a portal

00:06:01.576 --> 00:06:02.726
into an alternate universe.

00:06:02.976 --> 00:06:04.056
You don't need to see what the

00:06:04.056 --> 00:06:05.186
camera sees directly.

00:06:06.376 --> 00:06:07.376
The environment can be entirely

00:06:07.376 --> 00:06:07.976
replaced.

00:06:08.556 --> 00:06:10.286
Laws of physics can be bent or

00:06:10.456 --> 00:06:11.446
completely changed.

00:06:12.326 --> 00:06:13.226
Whatever you need to do to make

00:06:13.226 --> 00:06:13.636
it fun.

00:06:14.226 --> 00:06:15.196
In this case, we're able to see

00:06:15.196 --> 00:06:16.156
the stars, even though it's

00:06:16.186 --> 00:06:16.796
bright daylight.

00:06:17.946 --> 00:06:22.316
Also, your device can be the

00:06:22.316 --> 00:06:23.966
controller itself.

00:06:25.716 --> 00:06:27.296
You're able to fuse yourself

00:06:27.296 --> 00:06:29.386
with the virtual world using the

00:06:29.386 --> 00:06:30.376
device as the controller.

00:06:30.956 --> 00:06:32.736
In this example, we're sort of

00:06:32.736 --> 00:06:34.376
magnetically levitating blocks

00:06:34.376 --> 00:06:35.556
and placing them in the sorting

00:06:35.556 --> 00:06:35.886
cube.

00:06:36.706 --> 00:06:37.526
That's the focus of the

00:06:37.526 --> 00:06:38.586
interaction in SwiftShot.

00:06:39.796 --> 00:06:40.996
You want to encourage slow

00:06:40.996 --> 00:06:41.996
movement of the device.

00:06:42.966 --> 00:06:44.106
That gives the best images to

00:06:44.106 --> 00:06:45.426
the camera without motion blur

00:06:45.696 --> 00:06:46.686
and it can do the best job at

00:06:46.686 --> 00:06:47.136
tracking.

00:06:48.186 --> 00:06:50.256
And despite how thin and light

00:06:50.256 --> 00:06:52.386
these devices are, waving them

00:06:52.386 --> 00:06:53.676
all around at arm's length turns

00:06:53.676 --> 00:06:54.616
out to be a little bit tiring.

00:06:54.786 --> 00:06:55.886
So, you're looking for slow and

00:06:55.886 --> 00:06:56.876
deliberate movements.

00:06:57.146 --> 00:07:00.696
You want to encourage the player

00:07:00.696 --> 00:07:02.516
to move around the play field In

00:07:02.636 --> 00:07:05.006
this case, our shot of the enemy

00:07:05.136 --> 00:07:06.856
slingshot is blocked by those

00:07:06.856 --> 00:07:07.366
blocks.

00:07:08.026 --> 00:07:09.276
So, we have to move over to

00:07:09.276 --> 00:07:11.156
another slingshot to clear the

00:07:11.156 --> 00:07:12.000
obstruction.

00:07:19.326 --> 00:07:20.646
Control feedback is important

00:07:20.646 --> 00:07:21.136
for immersion.

00:07:22.146 --> 00:07:24.826
In SwiftShot, we give feedback

00:07:24.826 --> 00:07:26.506
using both audio and haptics.

00:07:27.576 --> 00:07:29.716
There's a variety of dynamic

00:07:29.756 --> 00:07:31.396
behavior in the stretching band

00:07:31.396 --> 00:07:35.056
sound and haptics on the phones

00:07:35.056 --> 00:07:36.316
to give you that feel that

00:07:36.316 --> 00:07:36.826
you're doing it.

00:07:37.406 --> 00:07:38.876
We'll talk a lot more later

00:07:38.876 --> 00:07:40.036
about the dynamic audio.

00:07:42.956 --> 00:07:44.196
So, next I'd like to bring up

00:07:44.196 --> 00:07:46.096
David Paschich, who will go deep

00:07:46.096 --> 00:07:47.376
into the details of SwiftShot.

00:07:47.786 --> 00:07:48.666
Thank you.

00:07:50.286 --> 00:07:50.486
David?

00:07:53.756 --> 00:07:55.086
>> Thank you Alex, and hello,

00:07:55.086 --> 00:07:55.536
everybody.

00:07:55.536 --> 00:07:58.256
I just want to echo what Alex

00:07:58.256 --> 00:07:58.546
said.

00:07:58.546 --> 00:08:00.056
The response that we've seen

00:08:00.056 --> 00:08:01.136
from people here at the show to

00:08:01.136 --> 00:08:02.596
SwiftShot has been really

00:08:02.596 --> 00:08:04.196
amazing and it's been gratifying

00:08:04.196 --> 00:08:05.496
to see some people already

00:08:05.846 --> 00:08:07.106
downloading it, building it and

00:08:07.106 --> 00:08:08.266
altering it from the sample

00:08:08.266 --> 00:08:08.606
code.

00:08:08.606 --> 00:08:09.746
So, I thank you for that.

00:08:09.746 --> 00:08:10.966
We're really excited about that.

00:08:10.966 --> 00:08:13.476
I want to talk by talking first

00:08:13.476 --> 00:08:15.246
about the technologies we used

00:08:15.246 --> 00:08:16.126
in building SwiftShot.

00:08:16.516 --> 00:08:18.736
The first and foremost is ARKit,

00:08:19.166 --> 00:08:20.766
which lets us render the content

00:08:20.916 --> 00:08:22.416
into the physical world around

00:08:22.416 --> 00:08:23.656
the players, immersing them in

00:08:23.656 --> 00:08:24.396
the experience.

00:08:26.336 --> 00:08:28.636
We use SceneKit to manage and

00:08:28.636 --> 00:08:30.096
draw that content, using

00:08:30.096 --> 00:08:31.896
advanced 3D rendering and

00:08:31.896 --> 00:08:33.106
realistic physics for fun

00:08:33.106 --> 00:08:33.466
gameplay.

00:08:35.186 --> 00:08:36.686
Metal lets us harness the power

00:08:36.686 --> 00:08:39.686
of the GPU devices.

00:08:39.686 --> 00:08:41.655
It came into play both within

00:08:41.655 --> 00:08:43.256
SceneKit for the shading and

00:08:43.256 --> 00:08:45.346
rendering and also for the flag

00:08:45.346 --> 00:08:46.346
simulation, which I'll talk

00:08:46.346 --> 00:08:48.166
about a little later on.

00:08:48.856 --> 00:08:50.406
GameplayKit provides an entity

00:08:50.406 --> 00:08:52.046
component architecture for our

00:08:52.046 --> 00:08:52.666
game object.

00:08:52.786 --> 00:08:54.526
It let us easily share behaviors

00:08:54.526 --> 00:08:57.506
between objects in the game.

00:08:57.716 --> 00:08:59.566
Multi-peer connectivity provides

00:08:59.566 --> 00:09:01.676
the networking layer, including

00:09:01.676 --> 00:09:03.426
discovery of nearby devices and

00:09:03.426 --> 00:09:05.716
synchronization, and encryption

00:09:05.716 --> 00:09:05.976
as well.

00:09:07.396 --> 00:09:09.206
AV Foundation controls both the

00:09:09.206 --> 00:09:11.056
music for atmosphere and the

00:09:11.056 --> 00:09:13.186
sound effects for the devices,

00:09:13.186 --> 00:09:14.236
really giving you that immersive

00:09:14.236 --> 00:09:14.846
experience.

00:09:16.026 --> 00:09:17.706
And lastly, we built the entire

00:09:17.706 --> 00:09:18.806
application in Swift.

00:09:19.426 --> 00:09:22.216
Swift's type safety, performance

00:09:22.696 --> 00:09:25.196
and advanced features like

00:09:25.196 --> 00:09:27.366
protocol extensions let us focus

00:09:27.366 --> 00:09:28.756
more on the gameplay and worry

00:09:28.756 --> 00:09:30.196
less about crashes and

00:09:30.196 --> 00:09:31.536
mismatched interfaces between

00:09:31.536 --> 00:09:32.136
code layers.

00:09:32.626 --> 00:09:36.716
Those are the iOS technologies

00:09:36.716 --> 00:09:37.176
we use.

00:09:37.576 --> 00:09:39.026
I'll talk about how we use those

00:09:39.026 --> 00:09:40.406
as we implemented several of the

00:09:40.406 --> 00:09:41.266
features of the game.

00:09:41.836 --> 00:09:43.206
Establishing the shared

00:09:43.206 --> 00:09:43.996
coordinate space.

00:09:44.796 --> 00:09:45.366
Networking.

00:09:46.096 --> 00:09:48.546
Physics. Asset important and

00:09:48.546 --> 00:09:48.896
management.

00:09:49.696 --> 00:09:50.656
Flag simulation.

00:09:51.086 --> 00:09:52.006
And the dynamic audio.

00:09:52.006 --> 00:09:56.226
We'll start by talking about

00:09:56.226 --> 00:09:57.556
setting up a shared coordinate

00:09:57.556 --> 00:09:58.036
space.

00:09:58.376 --> 00:10:00.926
The key in the experience is

00:10:00.926 --> 00:10:02.196
having the player see the same

00:10:02.196 --> 00:10:03.636
object in the same places on

00:10:03.636 --> 00:10:04.406
both devices.

00:10:04.876 --> 00:10:06.186
To do that, we have to have a

00:10:06.186 --> 00:10:07.216
shared coordinate space,

00:10:07.796 --> 00:10:09.386
allowing them to talk about

00:10:09.386 --> 00:10:10.896
locations in the world in the

00:10:10.896 --> 00:10:12.000
same way.

00:10:14.046 --> 00:10:15.076
ARKit provides a number of

00:10:15.076 --> 00:10:16.406
features you can use to set this

00:10:16.406 --> 00:10:16.606
up.

00:10:17.126 --> 00:10:20.056
In iOS 11.3, we introduced image

00:10:20.056 --> 00:10:21.596
recognition, allowing your apps

00:10:21.596 --> 00:10:22.926
to recognize images in the world

00:10:22.926 --> 00:10:23.366
around you.

00:10:24.796 --> 00:10:27.036
Now in iOS 12, we're adding two

00:10:27.036 --> 00:10:28.926
additional technologies - object

00:10:28.926 --> 00:10:30.966
detection and world map sharing.

00:10:32.356 --> 00:10:34.046
Both image detection and object

00:10:34.046 --> 00:10:35.896
detection let you add content to

00:10:35.896 --> 00:10:37.116
things the user sees in the real

00:10:37.116 --> 00:10:38.836
world but they require you to

00:10:38.836 --> 00:10:40.106
have pre-recorded those objects

00:10:40.106 --> 00:10:41.086
for later recognition.

00:10:41.696 --> 00:10:42.656
You saw that in the keynote

00:10:42.656 --> 00:10:43.616
during the Lego demo,

00:10:43.866 --> 00:10:45.196
recognizing built models and

00:10:45.196 --> 00:10:45.936
adding content.

00:10:46.446 --> 00:10:48.966
For this game, we wanted to

00:10:48.966 --> 00:10:50.316
enable users to play anywhere

00:10:50.316 --> 00:10:51.556
with a table such as a café,

00:10:51.556 --> 00:10:52.816
their kitchen and so forth.

00:10:53.166 --> 00:10:54.286
WorldMap sharing is how we did

00:10:55.186 --> 00:10:55.306
that.

00:10:55.716 --> 00:10:56.556
You can also apply this

00:10:56.556 --> 00:10:57.566
technique to applications

00:10:57.566 --> 00:10:59.086
besides games, like a fixed

00:10:59.086 --> 00:11:00.236
installation in a retail

00:11:00.236 --> 00:11:01.636
environment or a museum.

00:11:02.486 --> 00:11:04.856
In the game room downstairs, we

00:11:04.856 --> 00:11:06.326
use iBeacons so devices know

00:11:06.326 --> 00:11:09.436
which table they're next to and

00:11:09.436 --> 00:11:10.666
can load the correct WorldMap

00:11:10.986 --> 00:11:11.636
for that area.

00:11:12.236 --> 00:11:13.436
That really makes the experience

00:11:13.436 --> 00:11:13.786
magical.

00:11:14.326 --> 00:11:17.946
One of the features of SwiftShot

00:11:17.996 --> 00:11:18.866
you may have used if you built

00:11:18.866 --> 00:11:20.476
your app yourself is the ability

00:11:20.476 --> 00:11:23.036
to, ability for players to place

00:11:23.036 --> 00:11:23.956
the game board in the virtual

00:11:23.956 --> 00:11:24.326
world.

00:11:24.706 --> 00:11:26.136
At the tables downstairs, we're

00:11:26.136 --> 00:11:27.326
using preloaded maps.

00:11:27.456 --> 00:11:28.766
But here's an example of

00:11:28.766 --> 00:11:30.046
building your own board and

00:11:30.046 --> 00:11:31.866
placing it in the virtual world.

00:11:32.716 --> 00:11:34.986
This is how that works.

00:11:36.046 --> 00:11:37.316
As you saw in the video, you

00:11:37.316 --> 00:11:38.836
start by scanning the surface,

00:11:38.916 --> 00:11:40.366
letting ARKit build up a map of

00:11:40.366 --> 00:11:40.766
the area.

00:11:41.376 --> 00:11:43.916
You can then serialize that map

00:11:43.916 --> 00:11:45.726
out as data and transfer it to

00:11:45.726 --> 00:11:46.436
another device.

00:11:47.716 --> 00:11:49.236
The target device then loads the

00:11:49.236 --> 00:11:51.386
map into ARKit and uses it to

00:11:51.386 --> 00:11:52.816
recognize the same surface.

00:11:53.346 --> 00:11:54.396
At that point, we now have a

00:11:54.396 --> 00:11:55.626
shared reference point in the

00:11:55.626 --> 00:11:57.926
real world, and both devices can

00:11:57.926 --> 00:11:58.986
render the game board into the

00:11:58.986 --> 00:12:00.446
same place in that world.

00:12:02.576 --> 00:12:03.566
The first step in the

00:12:03.566 --> 00:12:05.036
implementation is getting the

00:12:05.036 --> 00:12:06.386
World Map from the ARSession on

00:12:06.386 --> 00:12:07.236
the first device.

00:12:08.186 --> 00:12:09.786
That's the call to a new API in

00:12:09.876 --> 00:12:11.776
iOS 12 in ARSession,

00:12:11.956 --> 00:12:12.836
getCurrentWorldMap.

00:12:13.376 --> 00:12:15.006
It builds an ARWorldMap object

00:12:15.196 --> 00:12:16.236
from the session's current

00:12:16.236 --> 00:12:17.196
understanding of the world

00:12:17.196 --> 00:12:19.036
around you and then returns it

00:12:19.036 --> 00:12:20.226
in an asynchronous callback.

00:12:20.976 --> 00:12:23.876
We then use NSKeyedArchiver to

00:12:23.876 --> 00:12:25.116
serialize that out to a data

00:12:25.116 --> 00:12:25.666
object.

00:12:26.396 --> 00:12:27.846
You can then save the data or

00:12:27.846 --> 00:12:28.746
send it over the network.

00:12:31.316 --> 00:12:32.906
Once you have that data object,

00:12:33.546 --> 00:12:34.616
you next have to decide how to

00:12:34.616 --> 00:12:35.636
get it from one device to

00:12:35.636 --> 00:12:35.956
another.

00:12:36.456 --> 00:12:38.286
For ad hoc gaming like you saw

00:12:38.376 --> 00:12:40.286
in the videoing, SwiftShot uses

00:12:40.286 --> 00:12:41.086
a peer-to-peer network

00:12:41.086 --> 00:12:42.466
connection which we'll get into

00:12:42.466 --> 00:12:43.436
more detail on shortly.

00:12:43.976 --> 00:12:45.716
When the second device joins the

00:12:45.716 --> 00:12:47.376
network session, the first

00:12:47.376 --> 00:12:48.776
device serialized the WorldMap

00:12:48.776 --> 00:12:50.076
and sent it over the network.

00:12:50.826 --> 00:12:52.126
This is great for casual gaming

00:12:52.126 --> 00:12:53.696
situations, allowing users to

00:12:53.696 --> 00:12:55.346
set up anywhere they can find a

00:12:55.346 --> 00:12:56.756
surface to play on.

00:12:58.536 --> 00:12:59.596
For the gaming tables

00:12:59.596 --> 00:13:00.886
downstairs, we used a different

00:13:00.886 --> 00:13:01.306
approach.

00:13:01.676 --> 00:13:03.316
We spent some time during setup

00:13:03.316 --> 00:13:04.966
for the conference recording

00:13:04.966 --> 00:13:05.966
WorldMaps for each of the

00:13:05.966 --> 00:13:07.776
tables, ensuring that we could

00:13:07.776 --> 00:13:09.186
localize that shared coordinate

00:13:09.186 --> 00:13:10.486
space from multiple angles.

00:13:11.236 --> 00:13:12.456
Each table has its own unique

00:13:12.456 --> 00:13:13.856
characteristics as well as

00:13:13.856 --> 00:13:15.386
slightly different lighting and

00:13:15.386 --> 00:13:15.826
positioning.

00:13:16.286 --> 00:13:18.586
We then saved the files to local

00:13:18.586 --> 00:13:19.726
sstorage on each device.

00:13:20.666 --> 00:13:21.946
Since the devices in use are

00:13:21.946 --> 00:13:23.116
managed by our conference team,

00:13:23.346 --> 00:13:24.616
we're able to use mobile device

00:13:24.616 --> 00:13:26.116
management to make sure that the

00:13:26.116 --> 00:13:27.626
same files are present on every

00:13:27.626 --> 00:13:29.026
device in the game.

00:13:29.846 --> 00:13:33.676
To make the solution even more

00:13:33.676 --> 00:13:35.506
seamless, you can use iBeacons

00:13:35.646 --> 00:13:36.256
on each table.

00:13:36.746 --> 00:13:38.826
By correlating the identifier of

00:13:38.826 --> 00:13:39.866
the iBeacon with particular

00:13:39.866 --> 00:13:41.796
WorldMaps, each instance of the

00:13:41.796 --> 00:13:43.316
SwiftShot application can load

00:13:43.316 --> 00:13:44.076
the correct WorldMap

00:13:44.076 --> 00:13:44.676
automatically.

00:13:45.266 --> 00:13:46.386
Now, if you're building a

00:13:46.386 --> 00:13:48.626
consumer application, you can

00:13:48.626 --> 00:13:50.736
also use things like iOS's

00:13:50.736 --> 00:13:53.516
on-demand resources or your own

00:13:53.516 --> 00:13:55.236
cloud-sharing solution to share

00:13:55.236 --> 00:13:56.606
WorldMaps between devices.

00:13:57.196 --> 00:13:58.276
This would allow you to for

00:13:58.276 --> 00:13:59.806
instance select the correct

00:13:59.806 --> 00:14:01.566
WorldMap for a particular retail

00:14:01.566 --> 00:14:02.996
location somewhere out in the

00:14:02.996 --> 00:14:03.246
world.

00:14:04.326 --> 00:14:05.086
There's really a lot

00:14:05.086 --> 00:14:06.866
possibilities here to tailor

00:14:06.866 --> 00:14:08.146
users' experience and really

00:14:08.146 --> 00:14:08.836
build something great.

00:14:09.336 --> 00:14:12.746
So, those are a couple of the

00:14:12.746 --> 00:14:14.426
ways to get that WorldMap data

00:14:14.576 --> 00:14:15.726
from one device to another.

00:14:16.386 --> 00:14:17.746
Let's talk about how you then

00:14:17.746 --> 00:14:19.106
load it on the second device.

00:14:19.386 --> 00:14:20.796
In this case, we use

00:14:20.846 --> 00:14:24.336
NSKeyUnarchiveder to blow up

00:14:24.336 --> 00:14:25.746
that WorldMap again from the

00:14:25.746 --> 00:14:26.956
data that we received.

00:14:27.836 --> 00:14:29.926
We then build an ARWorldTracking

00:14:29.926 --> 00:14:31.696
configuration and add the

00:14:31.696 --> 00:14:33.456
WorldMap to that configuration

00:14:33.456 --> 00:14:35.236
object, setting up the way we

00:14:35.236 --> 00:14:35.386
want.

00:14:36.246 --> 00:14:38.606
And then lastly, we ask the

00:14:38.606 --> 00:14:39.646
ARSession to run that

00:14:39.646 --> 00:14:41.736
configuration, resetting any

00:14:41.736 --> 00:14:45.116
existing anchors and tracking.

00:14:45.116 --> 00:14:47.016
ARKit on the target device then

00:14:47.016 --> 00:14:48.366
starts scanning the world around

00:14:48.366 --> 00:14:50.366
you, correlating those feature

00:14:50.366 --> 00:14:52.706
points from the original map

00:14:52.706 --> 00:14:53.776
with those that it sees there.

00:14:54.166 --> 00:14:55.396
Once it's able to do that,

00:14:55.656 --> 00:14:56.456
you've got that shared

00:14:56.456 --> 00:14:57.276
coordinate space.

00:14:57.696 --> 00:14:59.966
Both devices have 000 in the

00:14:59.966 --> 00:15:01.096
same place in the real world.

00:15:01.396 --> 00:15:05.446
So, a quick word about privacy

00:15:05.446 --> 00:15:06.196
with WorldMaps.

00:15:06.826 --> 00:15:07.916
In the process of recording the

00:15:07.916 --> 00:15:09.926
WorldMap, we take into account

00:15:10.076 --> 00:15:11.226
features of the world around

00:15:11.226 --> 00:15:12.386
you, physical arrangements of

00:15:12.386 --> 00:15:13.616
objects and so forth.

00:15:15.016 --> 00:15:16.746
While it does include geographic

00:15:16.746 --> 00:15:18.036
information like latitude and

00:15:18.036 --> 00:15:19.366
longitude and thus your

00:15:19.366 --> 00:15:20.756
application doesn't need to ask

00:15:20.756 --> 00:15:22.296
for location permission to use

00:15:22.296 --> 00:15:25.046
ARKit, it may include personally

00:15:25.046 --> 00:15:26.726
identifiable information about

00:15:26.726 --> 00:15:27.736
the user's environment.

00:15:28.686 --> 00:15:29.976
So, we recommend that you treat

00:15:30.046 --> 00:15:32.086
a serialized WorldMap the same

00:15:32.156 --> 00:15:33.266
way that you would any other

00:15:33.266 --> 00:15:35.866
user-created private data.

00:15:36.156 --> 00:15:38.686
This means that you want to make

00:15:38.686 --> 00:15:39.846
sure that you're encrypting it

00:15:40.616 --> 00:15:41.976
both at rest and when moving

00:15:41.976 --> 00:15:42.746
across the network.

00:15:43.666 --> 00:15:44.676
You may also want to let your

00:15:44.676 --> 00:15:46.406
users know if you're planning to

00:15:46.636 --> 00:15:48.156
save that WorldMap information

00:15:48.156 --> 00:15:49.586
for an extended period of time,

00:15:49.896 --> 00:15:51.316
past a single session of your

00:15:51.316 --> 00:15:51.856
application.

00:15:53.296 --> 00:15:54.766
In SwiftShot, we're able to take

00:15:54.766 --> 00:15:56.806
advantage of iOS's built-in

00:15:56.986 --> 00:15:59.596
encryption for encrypting the

00:15:59.596 --> 00:16:00.606
data while at rest.

00:16:01.376 --> 00:16:03.496
I'll talk next about how we did

00:16:03.496 --> 00:16:05.246
the networking for encryption,

00:16:05.546 --> 00:16:06.526
on the networking.

00:16:07.066 --> 00:16:10.496
Now, in addition to setting up

00:16:10.496 --> 00:16:12.616
shared coordinate space for

00:16:12.616 --> 00:16:14.006
SwiftShot, we needed to tell the

00:16:14.006 --> 00:16:15.416
other device where the user has

00:16:15.416 --> 00:16:16.716
chosen to locate the board.

00:16:17.236 --> 00:16:19.266
We use an ARAnchor to do this.

00:16:19.676 --> 00:16:21.666
When you create an ARAnchor, you

00:16:21.666 --> 00:16:23.536
provide a name as well as

00:16:23.536 --> 00:16:24.736
position and rotation

00:16:24.736 --> 00:16:26.386
information as a 4 x 4

00:16:26.386 --> 00:16:26.836
transform.

00:16:27.306 --> 00:16:30.236
ARKit can then include the

00:16:30.236 --> 00:16:32.176
Anchor in the ARWorldMap we

00:16:32.176 --> 00:16:34.386
generate and serialize out, and

00:16:34.386 --> 00:16:35.476
then, so we can transfer that

00:16:35.476 --> 00:16:36.936
board information to the other

00:16:36.936 --> 00:16:37.496
device.

00:16:38.106 --> 00:16:40.906
Now, the system ARAnchor class

00:16:40.906 --> 00:16:42.576
just has the name and the

00:16:42.576 --> 00:16:43.836
orientation we created.

00:16:44.196 --> 00:16:45.656
We can look up the anchor that

00:16:45.656 --> 00:16:46.846
we're interested in by name on

00:16:46.846 --> 00:16:47.406
the other side.

00:16:48.036 --> 00:16:49.286
For our application though, we

00:16:49.286 --> 00:16:50.596
need to include some additional

00:16:50.596 --> 00:16:51.946
information for the other

00:16:51.946 --> 00:16:53.946
device, and that's the size that

00:16:53.996 --> 00:16:55.976
the user chose for that board,

00:16:56.306 --> 00:16:57.456
deciding whether they're playing

00:16:57.456 --> 00:16:59.356
on a, you know, a small table

00:16:59.356 --> 00:17:00.936
top and surface, or they want to

00:17:00.936 --> 00:17:02.576
blow the board up to be the size

00:17:02.576 --> 00:17:03.646
of a basketball court.

00:17:04.106 --> 00:17:07.656
We thought about, you know,

00:17:07.656 --> 00:17:08.646
adding that to our network

00:17:08.646 --> 00:17:10.435
protocol alongside the WorldMap,

00:17:10.826 --> 00:17:11.536
but then we came up with a

00:17:11.536 --> 00:17:12.126
better solution.

00:17:13.415 --> 00:17:15.455
We created a custom subclass of

00:17:15.455 --> 00:17:16.836
ARAnchor that we called board

00:17:16.836 --> 00:17:18.546
anchor and added that

00:17:18.546 --> 00:17:20.165
information to that class, the

00:17:20.165 --> 00:17:20.935
size of the board.

00:17:22.236 --> 00:17:24.796
We then made sure that we

00:17:24.796 --> 00:17:27.026
implemented the NSCoding

00:17:27.026 --> 00:17:28.546
required classes or override

00:17:28.546 --> 00:17:30.546
them to include that information

00:17:30.866 --> 00:17:32.486
when the object is serialized

00:17:32.486 --> 00:17:32.696
out.

00:17:33.376 --> 00:17:35.076
Now, the information is included

00:17:35.076 --> 00:17:36.476
directly within the WorldMap

00:17:36.836 --> 00:17:38.066
when we transfer it over to the

00:17:38.066 --> 00:17:38.776
other device.

00:17:39.146 --> 00:17:40.166
It makes it very easy and

00:17:40.166 --> 00:17:40.766
straightforward.

00:17:42.116 --> 00:17:43.236
One thing to keep in mind, and

00:17:43.236 --> 00:17:44.986
this bit us for a little bit.

00:17:45.476 --> 00:17:47.996
When you use Swift to make a

00:17:47.996 --> 00:17:50.036
subclass like this, when you

00:17:50.036 --> 00:17:52.136
serialize it out, the name of

00:17:52.136 --> 00:17:53.416
the module or the name of your

00:17:53.416 --> 00:17:54.856
application is included in the

00:17:54.856 --> 00:17:55.356
class name.

00:17:56.016 --> 00:17:57.296
This is something to be aware of

00:17:57.336 --> 00:17:58.406
if you're planning to move

00:17:58.406 --> 00:17:59.786
WorldMaps between different

00:17:59.786 --> 00:18:00.556
applications.

00:18:01.016 --> 00:18:02.556
NSKeyedArchiver can help you

00:18:02.666 --> 00:18:03.906
accommodate that.

00:18:04.676 --> 00:18:06.306
So, that's WorldMap sharing.

00:18:06.756 --> 00:18:08.976
It's a new feature in iOS 12.

00:18:09.136 --> 00:18:10.156
We're really looking forward to

00:18:10.156 --> 00:18:11.716
seeing what everyone can build

00:18:12.376 --> 00:18:14.336
with that.

00:18:14.536 --> 00:18:15.376
Next, let's talk about the

00:18:15.376 --> 00:18:17.466
networking we built into the

00:18:17.826 --> 00:18:17.936
game.

00:18:17.936 --> 00:18:19.566
We used iOS's multi-peer

00:18:19.566 --> 00:18:21.236
connectivity API which has been

00:18:21.236 --> 00:18:22.906
in the system since iOS 7 in

00:18:22.906 --> 00:18:23.746
order to do this.

00:18:24.636 --> 00:18:25.856
Multi-peer connectivity.

00:18:26.106 --> 00:18:27.146
Allows us to set up a

00:18:27.146 --> 00:18:28.626
peer-to-peer session on a local

00:18:28.626 --> 00:18:30.776
network, allowing devices in the

00:18:30.776 --> 00:18:32.246
session to communicate without

00:18:32.246 --> 00:18:33.206
going through a dedicated

00:18:33.206 --> 00:18:33.516
server.

00:18:34.506 --> 00:18:35.616
Now, in our application, we

00:18:35.616 --> 00:18:37.126
designate one of the devices as

00:18:37.126 --> 00:18:39.026
the server but that's something

00:18:39.026 --> 00:18:40.286
that we did for our application.

00:18:40.286 --> 00:18:41.146
It's not inherent in the

00:18:41.146 --> 00:18:41.516
protocol.

00:18:43.046 --> 00:18:44.346
Encryption and authentication

00:18:44.346 --> 00:18:45.536
are built into multi-peer

00:18:45.536 --> 00:18:46.146
connectivity.

00:18:46.866 --> 00:18:48.006
In our case, we didn't use

00:18:48.006 --> 00:18:49.436
authentication because we wanted

00:18:49.436 --> 00:18:50.506
a very quick in-and-out

00:18:50.506 --> 00:18:52.336
experience but we did use

00:18:52.396 --> 00:18:52.966
encryption.

00:18:53.516 --> 00:18:54.596
We found that turning on

00:18:54.596 --> 00:18:56.276
encryption really provided no

00:18:56.276 --> 00:18:58.016
performance penalty, so there's

00:18:58.376 --> 00:19:00.936
either in network data size or

00:19:00.936 --> 00:19:01.536
computation.

00:19:01.646 --> 00:19:02.666
So there's really no reason not

00:19:02.666 --> 00:19:04.306
to use it.

00:19:05.126 --> 00:19:06.616
Multi-peer connectivity also

00:19:06.616 --> 00:19:08.596
provides APIs for advertisements

00:19:08.696 --> 00:19:09.316
and discovery.

00:19:09.846 --> 00:19:11.256
We use this to broadcast

00:19:11.256 --> 00:19:12.476
available games and allow

00:19:12.536 --> 00:19:13.596
players to select a game to

00:19:14.226 --> 00:19:14.316
join.

00:19:14.956 --> 00:19:16.056
So, here's how we get that

00:19:16.056 --> 00:19:16.616
session set up.

00:19:17.486 --> 00:19:19.116
First, on one device, the user

00:19:19.116 --> 00:19:20.906
decides to set themselves up as

00:19:20.906 --> 00:19:21.936
hosts for the application.

00:19:23.356 --> 00:19:24.746
They scan the world, place the

00:19:24.746 --> 00:19:27.456
gameboard within that world, and

00:19:27.456 --> 00:19:29.026
then the device starts a new

00:19:29.026 --> 00:19:30.516
session, a multi-peer

00:19:30.516 --> 00:19:31.966
connectivity session, and starts

00:19:31.966 --> 00:19:33.486
advertising it to other devices

00:19:33.486 --> 00:19:34.806
on the local network.

00:19:35.476 --> 00:19:37.866
A user on the other device sees

00:19:37.866 --> 00:19:39.036
a list of available games.

00:19:39.546 --> 00:19:41.856
When he selects one, his device

00:19:41.856 --> 00:19:42.916
sends a request to join the

00:19:42.916 --> 00:19:43.716
existing session.

00:19:45.276 --> 00:19:47.186
Once the first device accepts

00:19:47.186 --> 00:19:48.346
the request, multi-peer

00:19:48.346 --> 00:19:49.686
connectivity sets up a true

00:19:49.686 --> 00:19:50.526
peer-to-peer network.

00:19:51.086 --> 00:19:53.226
Any device in the network can

00:19:53.226 --> 00:19:54.266
send a message to any other

00:19:54.266 --> 00:19:55.126
device in the network.

00:19:55.976 --> 00:19:58.246
In SwiftShot, we designate the

00:19:58.246 --> 00:19:59.576
device that started the session

00:19:59.576 --> 00:20:00.796
as the source of truth for the

00:20:00.796 --> 00:20:01.336
game state.

00:20:01.736 --> 00:20:03.226
But again, that's the decision

00:20:03.226 --> 00:20:04.166
we layered on top of the

00:20:04.166 --> 00:20:05.636
networking protocol; it's not

00:20:05.636 --> 00:20:06.566
inherent in multi-peer

00:20:06.566 --> 00:20:07.116
connectivity.

00:20:07.536 --> 00:20:11.696
Once the session is set up,

00:20:11.696 --> 00:20:13.366
multi-peer connectivity lets us

00:20:13.366 --> 00:20:15.006
send data between peers in three

00:20:15.006 --> 00:20:15.416
ways.

00:20:15.946 --> 00:20:17.096
As data packets.

00:20:17.716 --> 00:20:19.906
As resources, file URLs on the

00:20:19.906 --> 00:20:20.636
local storage.

00:20:21.096 --> 00:20:21.946
And as streams.

00:20:22.716 --> 00:20:23.986
Data objects can be sent,

00:20:23.986 --> 00:20:25.216
broadcast to all peers in the

00:20:25.216 --> 00:20:27.366
network whereas resources and

00:20:27.366 --> 00:20:28.766
streams are device to device.

00:20:29.026 --> 00:20:32.196
In SwiftShot, we use the data

00:20:32.196 --> 00:20:33.816
packets primarily as a way to

00:20:33.816 --> 00:20:35.676
share game events and also the

00:20:35.676 --> 00:20:36.256
physics state.

00:20:36.566 --> 00:20:38.886
We'll talk about that later on.

00:20:38.886 --> 00:20:40.206
And then we used the resources

00:20:40.206 --> 00:20:41.186
to transfer the WorldMap.

00:20:41.186 --> 00:20:43.146
It ended up we didn't need

00:20:43.146 --> 00:20:44.176
streams for our application.

00:20:44.656 --> 00:20:47.456
Under the covers, multi-peer

00:20:47.456 --> 00:20:49.326
connectivity relies on UDP for

00:20:49.326 --> 00:20:50.736
the transfer between devices.

00:20:51.366 --> 00:20:53.726
This gives a low latency for,

00:20:53.896 --> 00:20:55.156
great for applications like

00:20:55.156 --> 00:20:55.506
games.

00:20:56.536 --> 00:20:57.926
Now, UDP inherently doesn't

00:20:57.926 --> 00:20:59.436
guarantee delivery, so

00:20:59.436 --> 00:21:00.886
multi-peer connectivity lets you

00:21:00.886 --> 00:21:02.786
make that decision and specify

00:21:02.786 --> 00:21:04.206
whether a particular data packet

00:21:04.206 --> 00:21:06.016
is to be sent reliably or

00:21:06.016 --> 00:21:06.626
unreliably.

00:21:07.556 --> 00:21:08.716
If you choose reliably,

00:21:09.246 --> 00:21:10.606
multi-peer connectivity takes

00:21:10.606 --> 00:21:12.046
care of the retries for you, so

00:21:12.176 --> 00:21:13.316
you don't have to worry about

00:21:13.346 --> 00:21:15.876
that in your code.

00:21:15.876 --> 00:21:17.426
Even when you're broadcasting to

00:21:17.426 --> 00:21:18.676
all members of the session.

00:21:18.676 --> 00:21:22.686
Now that we have a networking

00:21:22.686 --> 00:21:24.106
layer, we need to build our

00:21:24.106 --> 00:21:25.446
application protocol on top of

00:21:26.166 --> 00:21:26.236
it.

00:21:26.456 --> 00:21:28.456
SwiftEnums with associated types

00:21:28.736 --> 00:21:29.756
make this very easy.

00:21:30.736 --> 00:21:32.416
Each case has a data structure

00:21:32.416 --> 00:21:34.356
around it, ensuring type safety

00:21:34.606 --> 00:21:35.896
as information moves around the

00:21:35.896 --> 00:21:36.266
system.

00:21:37.496 --> 00:21:39.056
Some of those can be further

00:21:39.056 --> 00:21:39.496
enums.

00:21:39.866 --> 00:21:40.766
So, for instance, in this

00:21:40.766 --> 00:21:42.446
example, gameAction includes

00:21:42.446 --> 00:21:43.806
things like a player grabbed a

00:21:43.806 --> 00:21:44.386
catapult.

00:21:44.386 --> 00:21:46.076
A projectile launched, and so

00:21:46.076 --> 00:21:46.386
forth.

00:21:47.166 --> 00:21:48.966
The PhysicsSyncData is a strut

00:21:49.096 --> 00:21:50.476
and we'll talk more about how we

00:21:50.476 --> 00:21:52.336
encoded that later on.

00:21:53.316 --> 00:21:55.046
Again, Swift makes this very

00:21:55.046 --> 00:21:55.276
easy.

00:21:55.576 --> 00:21:57.206
For struts, if all the members

00:21:57.206 --> 00:21:59.136
of the struct are codable, then

00:21:59.136 --> 00:22:00.756
all you need to do is mark that

00:22:00.756 --> 00:22:02.406
struct as codable and the Swift

00:22:02.406 --> 00:22:03.646
compiler takes care of the rest,

00:22:04.096 --> 00:22:05.286
building all the infrastructure

00:22:05.286 --> 00:22:06.596
needed for the serialization.

00:22:07.006 --> 00:22:09.706
Swift doesn't do that for enums

00:22:09.936 --> 00:22:11.456
and so we ended up implementing

00:22:11.456 --> 00:22:14.226
that ourselves, implementing the

00:22:14.226 --> 00:22:16.806
init and then coding method from

00:22:16.806 --> 00:22:18.766
the codable protocol to make

00:22:19.196 --> 00:22:20.716
that work.

00:22:20.906 --> 00:22:22.596
Serialization then is very easy.

00:22:22.806 --> 00:22:23.926
Just build a property listing

00:22:23.926 --> 00:22:25.426
coder and have it encode the

00:22:25.426 --> 00:22:26.146
object out for you.

00:22:26.786 --> 00:22:28.986
We can then send a data packet

00:22:29.246 --> 00:22:30.056
within the multi-peer

00:22:30.056 --> 00:22:30.986
connectivity session.

00:22:32.026 --> 00:22:33.466
Now, a reasonable question here

00:22:33.466 --> 00:22:35.206
might be how's this going to do

00:22:35.206 --> 00:22:37.166
in size and performance?

00:22:38.626 --> 00:22:39.956
Property-- binary property lists

00:22:39.956 --> 00:22:41.116
are pretty compact and the

00:22:41.116 --> 00:22:42.506
encoder's pretty fast.

00:22:43.496 --> 00:22:45.466
But sometimes, you know, the

00:22:45.466 --> 00:22:47.216
soft implementation in many ways

00:22:47.216 --> 00:22:49.256
is optimized for developer time,

00:22:49.356 --> 00:22:50.406
which is sometimes your most

00:22:50.406 --> 00:22:51.756
precious resource on a project.

00:22:52.646 --> 00:22:55.146
Now, we ran up against some of

00:22:55.146 --> 00:22:56.426
those limitations as we started

00:22:56.426 --> 00:22:57.836
to build the next feature, and

00:22:57.836 --> 00:22:59.026
we'll talk about how we overcame

00:22:59.746 --> 00:22:59.866
this.

00:23:01.576 --> 00:23:03.046
So, let's talk next about the

00:23:03.046 --> 00:23:04.326
physics simulation in the game.

00:23:04.616 --> 00:23:06.106
For a game like SwiftShot,

00:23:06.726 --> 00:23:08.156
physics is really key to create

00:23:08.156 --> 00:23:10.206
a fun interaction that comes

00:23:10.206 --> 00:23:11.296
from the realistic interaction

00:23:11.296 --> 00:23:12.316
between objects and the game.

00:23:12.816 --> 00:23:14.146
It's a really great experience

00:23:14.146 --> 00:23:16.106
to take that shot and bounce it

00:23:16.106 --> 00:23:17.556
off an object in a game and take

00:23:17.556 --> 00:23:18.526
out the opponent's slingshot.

00:23:19.346 --> 00:23:20.676
And that really comes from the

00:23:20.676 --> 00:23:21.466
physics simulation.

00:23:23.716 --> 00:23:25.066
We use SceneKit's built-in

00:23:25.066 --> 00:23:25.656
physics engine.

00:23:25.986 --> 00:23:26.886
It's integrated with the

00:23:26.886 --> 00:23:28.336
rendering engine, updating

00:23:28.386 --> 00:23:29.476
positions of the object and

00:23:29.526 --> 00:23:30.996
scene automatically, and

00:23:30.996 --> 00:23:32.676
informing us of collisions using

00:23:32.676 --> 00:23:33.196
delegation.

00:23:34.616 --> 00:23:35.966
In our implementation, we

00:23:35.966 --> 00:23:37.286
decided that the best approach

00:23:37.356 --> 00:23:39.426
was for one device in the

00:23:39.426 --> 00:23:40.516
session to act as a source of

00:23:40.546 --> 00:23:41.576
truth or server.

00:23:42.296 --> 00:23:44.306
It sends periodic updates about

00:23:44.306 --> 00:23:45.846
the physics state to the other

00:23:45.846 --> 00:23:47.596
devices in the network using

00:23:47.596 --> 00:23:49.026
that multi-peer connectivity

00:23:49.296 --> 00:23:50.876
broadcast method.

00:23:52.706 --> 00:23:55.716
Now, the other devices also have

00:23:55.756 --> 00:23:56.986
the physics simulation on.

00:23:57.736 --> 00:23:58.856
That's because we don't send

00:23:58.856 --> 00:24:00.436
information about every object

00:24:00.436 --> 00:24:02.246
in the game, only those objects

00:24:02.246 --> 00:24:03.156
that are relevant to the

00:24:03.156 --> 00:24:04.606
gameplay such as the box,

00:24:04.606 --> 00:24:06.066
projectile and catapult.

00:24:06.666 --> 00:24:09.216
Things like simulating the

00:24:09.216 --> 00:24:10.286
swinging of the rope and the

00:24:10.286 --> 00:24:13.136
sling, particles and so forth,

00:24:13.656 --> 00:24:15.446
those are just done locally on

00:24:15.446 --> 00:24:16.726
each device since it's not

00:24:16.726 --> 00:24:18.166
critical to the game that they

00:24:18.166 --> 00:24:19.166
be in the same place on every

00:24:19.166 --> 00:24:19.646
device.

00:24:20.526 --> 00:24:24.886
Now, one of the things that we

00:24:24.886 --> 00:24:26.016
discovered was when we were

00:24:26.016 --> 00:24:28.366
doing this was that the physics

00:24:28.366 --> 00:24:29.336
engine responded very

00:24:29.336 --> 00:24:30.466
differently depending on the

00:24:30.466 --> 00:24:31.616
scale of the objects.

00:24:32.246 --> 00:24:33.966
And so the physics simulation

00:24:33.966 --> 00:24:35.466
thinks the objects are about 10

00:24:35.466 --> 00:24:36.876
times the size as you would see

00:24:36.876 --> 00:24:37.676
them in the real world.

00:24:38.316 --> 00:24:39.386
We found that gave the best

00:24:39.466 --> 00:24:41.756
gameplay experience and the best

00:24:41.756 --> 00:24:42.336
performance.

00:24:42.936 --> 00:24:44.516
We had to tweak some of the laws

00:24:44.516 --> 00:24:45.766
of physics to make that look

00:24:45.766 --> 00:24:47.216
right but, you know, when you're

00:24:47.216 --> 00:24:48.616
building a game, if it looks

00:24:48.616 --> 00:24:49.966
right and feels right and it's

00:24:49.966 --> 00:24:53.616
fun, then it is right.

00:24:53.856 --> 00:24:55.426
Now, to share that physics state

00:24:55.586 --> 00:24:56.546
and make sure everything looked

00:24:56.546 --> 00:24:57.996
right, we need to share four

00:24:57.996 --> 00:24:59.056
pieces of information.

00:24:59.646 --> 00:25:00.336
The position.

00:25:01.956 --> 00:25:03.026
The velocity.

00:25:04.356 --> 00:25:05.856
The angular velocity.

00:25:05.856 --> 00:25:07.486
And the orientation.

00:25:07.936 --> 00:25:09.566
That's a lot of information

00:25:09.566 --> 00:25:10.666
about every object in the game,

00:25:11.056 --> 00:25:12.846
so it was vital that we minimize

00:25:12.846 --> 00:25:13.886
the number of bits actually

00:25:13.886 --> 00:25:14.256
used.

00:25:15.006 --> 00:25:16.266
I'll walk you through that using

00:25:16.266 --> 00:25:18.946
position as an example.

00:25:18.946 --> 00:25:20.556
SceneKit represents position as

00:25:20.556 --> 00:25:21.926
a vector of three floating point

00:25:21.926 --> 00:25:22.406
values.

00:25:22.766 --> 00:25:24.996
This is the native format and

00:25:24.996 --> 00:25:26.646
gives the best performance for

00:25:26.646 --> 00:25:27.896
calculations at run time.

00:25:28.346 --> 00:25:31.416
However, there are really more

00:25:31.416 --> 00:25:33.416
bits than necessary to specify

00:25:33.416 --> 00:25:34.366
the object's location.

00:25:35.226 --> 00:25:37.256
A 30-bit float has 8-bits of

00:25:37.256 --> 00:25:38.686
exponent and 23 bits of

00:25:38.686 --> 00:25:39.256
mantissa.

00:25:39.366 --> 00:25:41.386
For a range of plus or minus 10

00:25:41.386 --> 00:25:42.656
to the 38th meters.

00:25:42.976 --> 00:25:44.566
It's way more than we need for

00:25:44.566 --> 00:25:47.166
this game.

00:25:47.366 --> 00:25:48.506
So, because the physics

00:25:48.506 --> 00:25:50.026
simulation thinks our table is

00:25:50.126 --> 00:25:52.486
28 meters long, we said you

00:25:52.486 --> 00:25:54.006
know, 80 meters is going to give

00:25:54.006 --> 00:25:55.506
us plenty of buffer space around

00:25:55.506 --> 00:25:56.506
that on either side.

00:25:57.816 --> 00:25:59.876
When we're coding that then,

00:26:00.876 --> 00:26:02.856
we're able to eliminate the sign

00:26:02.856 --> 00:26:05.666
bit by normalizing that between

00:26:05.666 --> 00:26:07.206
0 and 80 meters, even though our

00:26:07.206 --> 00:26:08.356
origin is at the center of the

00:26:08.356 --> 00:26:08.646
table.

00:26:09.446 --> 00:26:10.556
Now all values are positive.

00:26:11.196 --> 00:26:13.966
We then scale that value to be

00:26:13.966 --> 00:26:15.096
in a range of 0 to 1.

00:26:15.696 --> 00:26:16.636
That way we don't need the

00:26:16.636 --> 00:26:17.866
exponent information that's

00:26:17.866 --> 00:26:20.626
inherent in the protocol.

00:26:21.176 --> 00:26:24.366
And then lastly, we take that

00:26:24.366 --> 00:26:25.786
and we scale it to the number of

00:26:25.786 --> 00:26:29.136
bits available so that all 1s is

00:26:29.266 --> 00:26:31.876
a floating point 1 and all 0s is

00:26:31.876 --> 00:26:32.806
the floating point 0.

00:26:34.126 --> 00:26:35.356
This gave us millimeter scale

00:26:35.356 --> 00:26:37.376
precision which, as we

00:26:37.376 --> 00:26:39.296
discovered, was really enough to

00:26:39.296 --> 00:26:40.716
achieve that smooth synchronous

00:26:40.906 --> 00:26:43.296
appearance in the game.

00:26:43.436 --> 00:26:44.816
Now, we did a similar technique

00:26:44.816 --> 00:26:46.026
for all the other values that

00:26:46.026 --> 00:26:46.546
you saw.

00:26:46.716 --> 00:26:48.526
The velocity, angular velocity

00:26:48.666 --> 00:26:49.466
and orientation.

00:26:50.336 --> 00:26:52.326
Tailing the ranges and the

00:26:52.326 --> 00:26:53.906
number of bits for each to

00:26:53.906 --> 00:26:54.806
really make sure that we

00:26:55.226 --> 00:26:56.526
transmit the information using

00:26:56.526 --> 00:26:57.436
the minimal amount of data.

00:26:58.096 --> 00:27:00.356
Overall, we reduce the number of

00:27:00.356 --> 00:27:02.126
bits for each object by more

00:27:02.916 --> 00:27:04.706
than half.

00:27:04.706 --> 00:27:05.656
Now, even though we've

00:27:05.706 --> 00:27:08.106
compressed the numbers, property

00:27:08.106 --> 00:27:09.616
lists still have a fair amount

00:27:09.616 --> 00:27:11.526
of overhead for the metadata

00:27:11.526 --> 00:27:13.466
around it, sending each field by

00:27:13.466 --> 00:27:13.686
name.

00:27:14.796 --> 00:27:16.226
We said there's no reason for

00:27:16.226 --> 00:27:16.436
that.

00:27:16.866 --> 00:27:17.886
We all know what these objects

00:27:17.886 --> 00:27:18.106
are.

00:27:18.106 --> 00:27:19.786
That's not information we need.

00:27:20.446 --> 00:27:24.456
So, to do this, we implemented a

00:27:24.456 --> 00:27:26.386
new serialization strategy which

00:27:26.386 --> 00:27:27.136
we call a BitStream.

00:27:28.416 --> 00:27:29.826
BitStreams are designed to pack

00:27:29.876 --> 00:27:31.066
the information into as few

00:27:31.066 --> 00:27:32.926
bytes as possible by providing

00:27:32.926 --> 00:27:34.216
fast serialization and

00:27:34.216 --> 00:27:34.986
deserialization.

00:27:34.986 --> 00:27:36.966
Now, our implementation is

00:27:36.996 --> 00:27:38.716
purpose-built for communicating

00:27:38.716 --> 00:27:40.956
binary data with low latency in

00:27:40.956 --> 00:27:42.056
an application like this.

00:27:42.916 --> 00:27:44.706
Strategies like this wouldn't

00:27:44.706 --> 00:27:47.036
work well for data that needs to

00:27:47.036 --> 00:27:48.946
persist or data that, where you

00:27:48.946 --> 00:27:50.256
need to keep track of the schema

00:27:50.476 --> 00:27:51.626
and watch it changing over time.

00:27:52.526 --> 00:27:54.376
But for an ephemeral application

00:27:54.376 --> 00:27:55.576
like this, it was just the

00:27:55.986 --> 00:27:56.096
thing.

00:27:57.896 --> 00:27:59.316
To help implement this, we

00:27:59.316 --> 00:28:01.606
created two protocols, BitStream

00:28:01.606 --> 00:28:03.216
Encodable and BitStream

00:28:03.216 --> 00:28:03.796
Decodable.

00:28:04.576 --> 00:28:05.616
Combine those and you get

00:28:05.616 --> 00:28:06.376
BitStream Codable.

00:28:07.266 --> 00:28:09.186
Then we took that and marked all

00:28:09.186 --> 00:28:10.416
the objects that we needed to

00:28:10.416 --> 00:28:12.176
serialize, using that protocol,

00:28:12.176 --> 00:28:12.926
helping us to get the

00:28:12.926 --> 00:28:13.576
implementation.

00:28:14.106 --> 00:28:16.006
That includes both our own data

00:28:16.006 --> 00:28:17.266
objects and the object we use

00:28:17.266 --> 00:28:19.916
from the system such as the simD

00:28:20.226 --> 00:28:22.886
floating point vector type.

00:28:24.936 --> 00:28:26.556
So, here's the implementation of

00:28:26.556 --> 00:28:27.856
compressing floats.

00:28:28.526 --> 00:28:30.006
The compressors, configured with

00:28:30.006 --> 00:28:31.436
the minimum and maximum range,

00:28:31.656 --> 00:28:32.866
and the number of bits we wanted

00:28:32.866 --> 00:28:33.326
to use.

00:28:34.646 --> 00:28:36.786
It clamps the value to the range

00:28:37.036 --> 00:28:37.996
and then converts it to an

00:28:37.996 --> 00:28:40.396
integer value for encoding using

00:28:40.396 --> 00:28:42.326
the specified number of bits.

00:28:42.836 --> 00:28:44.326
Each component for each object

00:28:44.326 --> 00:28:45.406
in the scene is compressed in

00:28:45.406 --> 00:28:45.716
this way.

00:28:46.616 --> 00:28:48.316
We also use an additional bit at

00:28:48.316 --> 00:28:49.766
the front to tell if an object

00:28:49.766 --> 00:28:51.306
has moved since the last update.

00:28:52.026 --> 00:28:53.716
If it hasn't moved, we don't

00:28:53.716 --> 00:28:54.716
resend that information.

00:28:56.696 --> 00:28:58.746
So, let's go back to our action

00:28:58.746 --> 00:28:59.716
enum, with the three different

00:28:59.716 --> 00:29:00.816
actions to talk about how we

00:29:00.816 --> 00:29:03.726
apply BitStream to do this.

00:29:03.866 --> 00:29:05.886
For regular codable, if you're

00:29:05.886 --> 00:29:07.636
doing your own serialization,

00:29:07.636 --> 00:29:09.606
you specify encoding keys for

00:29:09.606 --> 00:29:10.896
enums for the different cases in

00:29:10.896 --> 00:29:11.246
the enum.

00:29:12.106 --> 00:29:13.766
For BitStream, we used integer

00:29:13.766 --> 00:29:15.496
values for this rather than

00:29:15.706 --> 00:29:16.746
string values.

00:29:17.296 --> 00:29:19.926
And then in our encoding method,

00:29:20.426 --> 00:29:22.486
we're able to then append that

00:29:22.486 --> 00:29:24.326
value first followed by the data

00:29:24.326 --> 00:29:26.346
structure associated with that

00:29:26.536 --> 00:29:27.426
case of the enum.

00:29:27.916 --> 00:29:29.416
Now, if you look at this code

00:29:29.416 --> 00:29:30.706
though, there's kind of a pit

00:29:30.706 --> 00:29:31.096
fall here.

00:29:31.836 --> 00:29:33.646
We know that this one has, this

00:29:33.766 --> 00:29:36.466
case has three different cases.

00:29:37.256 --> 00:29:38.746
And so we only need two bits to

00:29:38.746 --> 00:29:39.766
encode it.

00:29:40.376 --> 00:29:42.326
But what happens when we add

00:29:42.506 --> 00:29:44.236
another case, 4 bits with 4

00:29:44.236 --> 00:29:45.366
cases, we'll still find.

00:29:45.806 --> 00:29:47.506
We add that fifth case and now

00:29:47.506 --> 00:29:49.676
we need to go through and change

00:29:49.676 --> 00:29:51.416
that so that every time we do

00:29:51.416 --> 00:29:52.716
this, we're using three bits

00:29:52.716 --> 00:29:53.336
instead of two.

00:29:54.086 --> 00:29:55.486
Now, that's kind of tedious.

00:29:55.486 --> 00:29:56.266
This code's a little bit

00:29:56.266 --> 00:29:58.286
repetitive and, you know,

00:29:58.416 --> 00:29:59.366
there's stuff that could go

00:29:59.366 --> 00:29:59.726
wrong there.

00:29:59.726 --> 00:30:00.996
We really, if we don't remember

00:30:00.996 --> 00:30:01.866
this, we're just going to end up

00:30:01.866 --> 00:30:02.576
in a bad place.

00:30:03.836 --> 00:30:05.706
So, we took a look at this and

00:30:05.706 --> 00:30:07.116
figured out that there was a way

00:30:07.116 --> 00:30:10.896
that Swift can help us do this.

00:30:11.096 --> 00:30:12.406
So, we used a new feature in

00:30:12.406 --> 00:30:14.956
Swift 4.2, which is case

00:30:14.956 --> 00:30:15.386
iterable.

00:30:16.336 --> 00:30:19.386
We added that protocol

00:30:19.816 --> 00:30:21.606
compliance to our enum type.

00:30:22.536 --> 00:30:24.696
When you do that, Swift adds a

00:30:24.696 --> 00:30:26.596
new static member of the type

00:30:26.886 --> 00:30:28.336
called all cases, containing

00:30:28.336 --> 00:30:29.856
each of the cases in the enum.

00:30:30.676 --> 00:30:32.216
That lets us automatically get a

00:30:32.216 --> 00:30:33.826
count of the number of cases.

00:30:34.976 --> 00:30:36.436
We then added another extension,

00:30:36.816 --> 00:30:37.706
this time on the raw

00:30:37.706 --> 00:30:39.426
representable type which all

00:30:39.426 --> 00:30:41.146
enums with number types like

00:30:41.146 --> 00:30:42.466
that conform to.

00:30:43.106 --> 00:30:44.726
Where it's case iterable and

00:30:44.726 --> 00:30:45.736
where that number is affixed

00:30:45.736 --> 00:30:46.256
with integer.

00:30:47.036 --> 00:30:47.876
And to this, we get to

00:30:47.876 --> 00:30:49.616
automatically take those number

00:30:49.616 --> 00:30:51.176
of cases and figure out how many

00:30:51.176 --> 00:30:53.246
bits it takes to represent all

00:30:53.246 --> 00:30:56.176
those cases on the wire.

00:30:56.376 --> 00:30:58.386
Lastly, we added a generic

00:30:58.386 --> 00:31:00.606
method on the writable BitStream

00:31:00.606 --> 00:31:02.526
type allowing us to encode that

00:31:02.526 --> 00:31:02.756
enum.

00:31:03.436 --> 00:31:04.696
It appends things of that type

00:31:04.696 --> 00:31:06.306
and it uses that new static

00:31:06.306 --> 00:31:07.656
property to figure out the

00:31:07.656 --> 00:31:09.306
number of bits that are needed

00:31:09.966 --> 00:31:11.536
to use.

00:31:11.736 --> 00:31:13.336
Now, our encode method is much

00:31:13.336 --> 00:31:13.716
simpler.

00:31:14.246 --> 00:31:16.566
We just used append enum on the

00:31:16.566 --> 00:31:18.086
proper coding key for each and

00:31:18.086 --> 00:31:19.256
Swift takes care of the rest.

00:31:19.576 --> 00:31:21.186
When we add more cases to the

00:31:21.186 --> 00:31:22.996
enum, the BitField expands

00:31:22.996 --> 00:31:23.576
automatically.

00:31:24.016 --> 00:31:25.656
If we remove cases, it contracts

00:31:25.656 --> 00:31:26.266
automatically.

00:31:26.546 --> 00:31:28.246
We don't have to worry about it.

00:31:31.356 --> 00:31:32.676
So, how much faster and more

00:31:32.676 --> 00:31:34.466
compact is BitStreamCodable?

00:31:35.066 --> 00:31:36.976
We ran some tests using XE test

00:31:36.976 --> 00:31:38.286
support for performance testing

00:31:38.706 --> 00:31:40.106
using a representative message

00:31:40.106 --> 00:31:41.356
in which we send information

00:31:41.356 --> 00:31:42.366
about object movement.

00:31:43.716 --> 00:31:44.826
The results were pretty

00:31:44.826 --> 00:31:46.666
impressive - 1/10 the size,

00:31:46.666 --> 00:31:48.436
twice as fast to code, 10 times

00:31:48.436 --> 00:31:49.276
as fast to decode.

00:31:50.196 --> 00:31:51.536
Now when we talk about going

00:31:51.536 --> 00:31:53.906
from 75 microseconds down to 6

00:31:53.906 --> 00:31:55.246
microseconds, that seems like

00:31:55.246 --> 00:31:56.056
small potatoes.

00:31:56.186 --> 00:31:58.206
But there's around 200 objects

00:31:58.206 --> 00:31:59.436
in the game and we want to do

00:31:59.436 --> 00:32:00.626
this very frequently to make

00:32:00.626 --> 00:32:02.046
sure the game remains smooth for

00:32:02.046 --> 00:32:02.946
all participants.

00:32:03.546 --> 00:32:04.926
By using this encoding format,

00:32:05.066 --> 00:32:06.466
we were able to do those physics

00:32:06.466 --> 00:32:09.266
updates at 60 fps, ensuring that

00:32:09.266 --> 00:32:10.416
you get a smooth experience for

00:32:10.416 --> 00:32:12.746
everyone in the game.

00:32:13.456 --> 00:32:15.326
Now, I've talked about this.

00:32:15.326 --> 00:32:16.826
We did some things with codable

00:32:16.826 --> 00:32:17.896
and some things with BitStream

00:32:17.896 --> 00:32:19.606
Codable that, you could have a

00:32:19.606 --> 00:32:20.556
problem there because we're

00:32:20.556 --> 00:32:21.586
encoding things two different

00:32:21.586 --> 00:32:21.886
ways.

00:32:22.306 --> 00:32:23.246
And that means now we need to

00:32:23.246 --> 00:32:24.176
have two different code paths

00:32:24.176 --> 00:32:24.956
through our application.

00:32:26.146 --> 00:32:27.736
Swift helps us out again and

00:32:27.736 --> 00:32:28.476
lets us figure out how to

00:32:28.476 --> 00:32:29.626
combine them.

00:32:30.166 --> 00:32:32.156
We then added constrained

00:32:32.156 --> 00:32:34.416
extensions so that anything that

00:32:34.416 --> 00:32:36.346
is codable in BitStream Codable,

00:32:36.666 --> 00:32:37.646
we provide default

00:32:37.646 --> 00:32:39.346
implementation of the BitStream

00:32:39.346 --> 00:32:39.766
encoding.

00:32:39.766 --> 00:32:42.816
And then we just go ahead and

00:32:42.816 --> 00:32:45.166
use a binary [inaudible] encoder

00:32:45.876 --> 00:32:47.506
to encode the data and stuff it

00:32:47.506 --> 00:32:48.056
into BitStream.

00:32:48.866 --> 00:32:51.576
And then anything, any struct

00:32:51.576 --> 00:32:52.766
that is codable, we just add

00:32:52.766 --> 00:32:53.896
that by marking it BitStream

00:32:53.896 --> 00:32:54.226
Codable.

00:32:54.956 --> 00:32:56.796
Now, this implementation then is

00:32:56.796 --> 00:32:58.596
not as fast and compact as if we

00:32:58.596 --> 00:32:59.936
went forward and made everything

00:32:59.936 --> 00:33:01.156
BitStream Codable directly.

00:33:01.876 --> 00:33:02.976
But we discovered we didn't need

00:33:02.976 --> 00:33:04.206
to do that for every object in

00:33:04.206 --> 00:33:05.746
the game, only the most frequent

00:33:05.746 --> 00:33:06.306
messages.

00:33:06.906 --> 00:33:08.396
This let us really move quickly

00:33:08.396 --> 00:33:10.586
and keep better rna on the game.

00:33:11.716 --> 00:33:13.216
So, that's how we did the

00:33:13.216 --> 00:33:13.936
physics.

00:33:14.266 --> 00:33:15.606
Next I want to talk about how we

00:33:15.696 --> 00:33:16.686
dealt with the assets on the

00:33:16.686 --> 00:33:17.576
game levels and this is the

00:33:17.576 --> 00:33:18.586
question that a lot of people

00:33:18.586 --> 00:33:19.916
asked us downstairs.

00:33:20.646 --> 00:33:23.016
You know, the assets include the

00:33:23.016 --> 00:33:24.576
3D modules, the textures, the

00:33:24.576 --> 00:33:25.696
animations and so forth.

00:33:26.136 --> 00:33:27.356
So, we have some text angle

00:33:27.356 --> 00:33:28.876
artists here in Apple and they

00:33:28.876 --> 00:33:30.246
used some commercial tools to

00:33:30.246 --> 00:33:31.546
build the visuals for the games.

00:33:31.546 --> 00:33:32.886
The blocks, the catapults and so

00:33:32.886 --> 00:33:33.236
forth.

00:33:34.086 --> 00:33:36.416
They then exported those assets

00:33:36.416 --> 00:33:37.926
in the common DAE file format.

00:33:38.286 --> 00:33:39.156
We're looking forward to the

00:33:39.156 --> 00:33:40.876
commercial tools supporting USDZ

00:33:41.276 --> 00:33:42.096
but for this game they weren't

00:33:42.096 --> 00:33:42.626
quite there yet.

00:33:43.126 --> 00:33:45.616
We then built a command line

00:33:45.616 --> 00:33:47.576
tool in Swift that converts the

00:33:47.576 --> 00:33:49.986
object from DAE into SceneKit

00:33:49.986 --> 00:33:52.196
files using the SceneKit API.

00:33:53.166 --> 00:33:54.346
Because SceneKit provides the

00:33:54.346 --> 00:33:56.856
same APIs on both iOS and macOS,

00:33:57.336 --> 00:33:58.976
we're able to run this tool as

00:33:58.976 --> 00:34:00.306
part of our build process on

00:34:00.306 --> 00:34:02.336
macOS and include the SceneKit

00:34:02.336 --> 00:34:04.016
files directly in our iOS build

00:34:04.016 --> 00:34:04.776
in the application.

00:34:06.496 --> 00:34:08.315
We structured the data so that

00:34:08.315 --> 00:34:10.346
each individual type of block is

00:34:10.346 --> 00:34:12.646
its own file and then for each

00:34:12.646 --> 00:34:14.106
levels, we combine those blocks

00:34:14.106 --> 00:34:14.466
together.

00:34:15.476 --> 00:34:17.186
This let us iterate on the

00:34:17.186 --> 00:34:18.636
appearance and physics behavior

00:34:18.636 --> 00:34:20.396
of each individual block and

00:34:20.396 --> 00:34:21.896
then pull them all together for

00:34:21.896 --> 00:34:23.295
those levels and iterate on

00:34:23.295 --> 00:34:24.036
gameplay design.

00:34:24.346 --> 00:34:25.335
Try out some of the different

00:34:25.335 --> 00:34:26.306
levels that you'll see if you

00:34:26.306 --> 00:34:27.466
look in the source code to the

00:34:27.466 --> 00:34:28.025
application.

00:34:30.116 --> 00:34:32.275
To optimize, further optimize

00:34:32.275 --> 00:34:33.576
for different distances,

00:34:33.926 --> 00:34:35.206
SceneKit supports varying the

00:34:35.206 --> 00:34:37.116
assets used based on the level

00:34:37.116 --> 00:34:37.946
of detail required.

00:34:39.116 --> 00:34:40.806
Nearby objects use more polygons

00:34:40.806 --> 00:34:42.446
and more detailed textures while

00:34:42.446 --> 00:34:43.735
far away objects use fewer

00:34:43.735 --> 00:34:45.005
polygons and less detailed

00:34:45.005 --> 00:34:45.466
textures.

00:34:46.005 --> 00:34:47.216
This really optimizes the

00:34:47.216 --> 00:34:50.996
rendering of the scene.

00:34:51.156 --> 00:34:52.806
However, we still want the

00:34:52.806 --> 00:34:54.096
gameplay to stay consistent.

00:34:54.466 --> 00:34:55.876
And so we specified the physics

00:34:55.876 --> 00:34:56.775
body separately.

00:34:57.886 --> 00:34:58.966
SceneKit provides a number of

00:34:58.966 --> 00:35:00.556
built-in physics body types such

00:35:00.556 --> 00:35:02.556
as cube, sphere, cylinder.

00:35:03.356 --> 00:35:04.796
And if you use those, you really

00:35:04.796 --> 00:35:05.946
get the best performance.

00:35:06.676 --> 00:35:08.136
If you don't specify one,

00:35:08.576 --> 00:35:09.966
SceneKit will build a convex

00:35:09.966 --> 00:35:11.826
hull automatically for you and

00:35:11.826 --> 00:35:12.516
that works.

00:35:12.946 --> 00:35:14.366
But it is a lower, can be a

00:35:14.366 --> 00:35:16.796
lower performance implementation

00:35:17.276 --> 00:35:19.376
by adding these objects where

00:35:19.376 --> 00:35:20.306
they were available and where

00:35:20.306 --> 00:35:21.996
they made sense, we really sped

00:35:21.996 --> 00:35:25.786
up the performance of the game.

00:35:25.826 --> 00:35:26.996
So, here's some examples of the

00:35:26.996 --> 00:35:29.356
physics finished product.

00:35:29.356 --> 00:35:30.466
First one is one of the blocks

00:35:30.466 --> 00:35:30.996
from the game.

00:35:30.996 --> 00:35:32.356
In this case, a cylinder with

00:35:32.356 --> 00:35:33.686
textures for a great wood grain

00:35:33.686 --> 00:35:33.876
look.

00:35:35.116 --> 00:35:36.456
Next is the slingshot with the

00:35:36.456 --> 00:35:37.136
sling head idle.

00:35:37.946 --> 00:35:39.016
We add the [inaudible] colors at

00:35:39.016 --> 00:35:40.856
RunTime using shaders and built

00:35:40.856 --> 00:35:42.086
some custom animation for the

00:35:42.086 --> 00:35:43.326
sling's motion during gameplay.

00:35:44.946 --> 00:35:46.416
Lastly, we included some extra

00:35:46.416 --> 00:35:47.736
assets that didn't get included

00:35:47.736 --> 00:35:48.286
in the gameplay.

00:35:48.776 --> 00:35:50.036
Even though we had to sacrifice

00:35:50.036 --> 00:35:51.416
them, we want you to have them

00:35:51.416 --> 00:35:53.006
and use them in your own sample

00:35:53.546 --> 00:35:53.646
code.

00:35:55.876 --> 00:35:57.606
So, one of the other fun things

00:35:57.606 --> 00:35:58.916
we included is this flag

00:35:58.916 --> 00:35:59.406
animation.

00:35:59.696 --> 00:36:00.956
It really improves the immersion

00:36:00.956 --> 00:36:01.866
in the game environment.

00:36:02.626 --> 00:36:04.076
We wanted a realistic wind

00:36:04.076 --> 00:36:04.896
effect on this.

00:36:05.156 --> 00:36:06.296
Now, we could've used a cloth

00:36:06.386 --> 00:36:07.656
simulation out of the physics

00:36:07.656 --> 00:36:07.976
engine.

00:36:09.506 --> 00:36:11.026
But instead, we decided to use

00:36:11.026 --> 00:36:12.846
the GPU and do it with Metal.

00:36:14.736 --> 00:36:16.626
We started with a SceneKit asset

00:36:16.626 --> 00:36:17.976
built by our technical artist.

00:36:18.516 --> 00:36:19.566
To get the Apple logo on the

00:36:19.566 --> 00:36:21.946
flag, we applied a texture at

00:36:21.946 --> 00:36:22.336
RunTime.

00:36:23.716 --> 00:36:25.026
Then we built a Swift class

00:36:25.026 --> 00:36:26.136
around the Metal device.

00:36:26.806 --> 00:36:28.506
Swift code builds a metal

00:36:28.506 --> 00:36:29.746
command queue and inserts

00:36:29.746 --> 00:36:31.126
information from the state of

00:36:31.126 --> 00:36:32.736
the game, such as the direction

00:36:32.736 --> 00:36:34.466
the wind is blowing.

00:36:34.586 --> 00:36:35.706
That command queue is running a

00:36:35.706 --> 00:36:37.016
custom Metal compute shader.

00:36:37.826 --> 00:36:39.046
That comes from a legacy code

00:36:39.046 --> 00:36:39.816
built in C.

00:36:40.176 --> 00:36:41.536
But because Metal is based on

00:36:41.536 --> 00:36:43.916
modern C++, it was a very easy

00:36:43.916 --> 00:36:44.726
conversion to make.

00:36:45.826 --> 00:36:47.486
We then also run another compute

00:36:47.486 --> 00:36:49.226
shader to compute normal for the

00:36:49.226 --> 00:36:50.966
surface, so we can get a great,

00:36:50.966 --> 00:36:53.426
smooth flag look without a huge

00:36:53.426 --> 00:36:54.716
number of polygons in the scene.

00:36:55.196 --> 00:36:56.646
And it really makes the flag

00:36:56.646 --> 00:36:57.156
look amazing.

00:36:58.296 --> 00:37:00.586
Each frame, the shader updates

00:37:00.586 --> 00:37:02.056
the geometry of the match to its

00:37:02.056 --> 00:37:02.586
new position.

00:37:03.296 --> 00:37:04.776
By taking advantage of the GPU

00:37:04.776 --> 00:37:06.316
in this way, we get a great

00:37:06.316 --> 00:37:08.936
effect without it impacting the

00:37:08.936 --> 00:37:09.646
main CPU.

00:37:12.056 --> 00:37:13.936
So, lastly I'd like to talk

00:37:13.936 --> 00:37:15.186
about the audio implementation

00:37:15.186 --> 00:37:15.746
in SwiftShot.

00:37:16.586 --> 00:37:18.156
Audio can make any game even

00:37:18.156 --> 00:37:19.726
more immersive and engaging.

00:37:20.756 --> 00:37:22.096
We knew we wanted to provide

00:37:22.096 --> 00:37:23.346
realistic sound effects

00:37:23.536 --> 00:37:25.006
positioned properly in the world

00:37:25.286 --> 00:37:26.366
for that really immersive

00:37:26.366 --> 00:37:26.896
experience.

00:37:26.896 --> 00:37:28.046
And giving the user great

00:37:28.046 --> 00:37:28.866
feedback on how they're

00:37:28.866 --> 00:37:29.816
interacting with that world.

00:37:30.926 --> 00:37:31.946
We also wanted to make sure it

00:37:31.946 --> 00:37:33.626
was fast and pay attention to

00:37:33.626 --> 00:37:35.096
how much adding the audio would

00:37:35.176 --> 00:37:37.046
add to the size of our app.

00:37:37.046 --> 00:37:38.356
So, we came up with what we

00:37:38.356 --> 00:37:39.256
think is a great solution.

00:37:40.336 --> 00:37:42.156
We created a few representative

00:37:42.156 --> 00:37:44.036
sound samples using some toys we

00:37:44.036 --> 00:37:45.626
borrowed from children of people

00:37:45.626 --> 00:37:47.406
on the team.

00:37:47.406 --> 00:37:49.246
We then recorded those and used

00:37:49.246 --> 00:37:51.656
those to combine them into an AU

00:37:51.656 --> 00:37:53.516
preset file and use those to

00:37:53.516 --> 00:37:55.256
build a custom Midi instrument

00:37:55.496 --> 00:37:57.506
in AV Foundation using AV Audio

00:37:57.506 --> 00:37:58.636
Unit Midi Instrument.

00:37:59.486 --> 00:38:00.746
That made it easy to quickly

00:38:00.746 --> 00:38:01.796
play the right sound at the

00:38:01.796 --> 00:38:03.146
right time in response to user

00:38:03.146 --> 00:38:04.266
inputs and collisions in the

00:38:04.266 --> 00:38:04.486
game.

00:38:05.016 --> 00:38:08.046
We didn't just play the sounds

00:38:08.046 --> 00:38:08.536
as is.

00:38:09.186 --> 00:38:10.316
To give good feedback to the

00:38:10.316 --> 00:38:11.316
user, we pull back on the

00:38:11.316 --> 00:38:11.806
slingshot.

00:38:12.146 --> 00:38:13.776
We vary the sound in a couple of

00:38:13.776 --> 00:38:14.146
ways.

00:38:14.856 --> 00:38:16.536
We change the pitch based on how

00:38:16.536 --> 00:38:17.866
far back they've pulled the

00:38:17.866 --> 00:38:18.396
slingshot.

00:38:19.456 --> 00:38:23.546
And we vary the volume based on

00:38:23.546 --> 00:38:24.796
the speed as you pull back.

00:38:24.796 --> 00:38:26.406
And we do that at RunTime by

00:38:26.406 --> 00:38:27.546
selecting the right Midi note

00:38:27.546 --> 00:38:29.656
and then using some additional

00:38:29.656 --> 00:38:30.946
Midi commands to alter that

00:38:30.946 --> 00:38:31.876
sound before we play it.

00:38:32.386 --> 00:38:33.746
So, let's take a listen and this

00:38:33.746 --> 00:38:35.000
is, we'll play it.

00:38:38.516 --> 00:38:53.246
[ Sound effects ]

00:38:53.746 --> 00:38:55.896
Now, we also wanted to make sure

00:38:55.896 --> 00:38:56.816
that when you're using the

00:38:56.816 --> 00:38:59.086
slingshot, we also give users

00:38:59.496 --> 00:39:01.496
some audio feedback as to

00:39:01.496 --> 00:39:02.486
whether or not they're within

00:39:02.486 --> 00:39:03.646
range of the slingshot and

00:39:03.646 --> 00:39:04.616
whether or not they've grabbed

00:39:04.616 --> 00:39:04.846
that.

00:39:04.846 --> 00:39:05.976
And those are the little beeps

00:39:05.976 --> 00:39:06.716
you heard at the start.

00:39:07.456 --> 00:39:08.906
Because those are UI feedback

00:39:08.906 --> 00:39:11.056
for the users, those sounds only

00:39:11.056 --> 00:39:12.466
come out of the device that the

00:39:12.466 --> 00:39:13.896
user is using to interact with

00:39:13.896 --> 00:39:14.466
the slingshot.

00:39:14.936 --> 00:39:16.406
However, we also want everybody

00:39:16.406 --> 00:39:18.466
else in the game to know what's

00:39:18.466 --> 00:39:19.576
going on with the slingshot,

00:39:19.576 --> 00:39:20.586
whether someone else is pulling

00:39:20.586 --> 00:39:21.646
something or something like

00:39:21.646 --> 00:39:21.886
that.

00:39:22.076 --> 00:39:22.946
But we want one of those to be

00:39:22.946 --> 00:39:23.416
quieter.

00:39:23.856 --> 00:39:25.896
So, we use positional audio so

00:39:25.896 --> 00:39:27.176
that if my opponent across the

00:39:27.176 --> 00:39:27.916
table is pulling their

00:39:27.916 --> 00:39:29.556
slingshot, I still hear that

00:39:29.556 --> 00:39:30.766
sound from my device but it's

00:39:30.766 --> 00:39:32.296
quieter and positioned correctly

00:39:32.296 --> 00:39:32.666
in the world.

00:39:34.926 --> 00:39:36.526
For colliding blocks, we took a

00:39:37.046 --> 00:39:38.176
similar approach but slightly

00:39:38.176 --> 00:39:38.526
different.

00:39:39.146 --> 00:39:40.886
We really wanted a cacophonous

00:39:41.076 --> 00:39:41.496
effect.

00:39:41.996 --> 00:39:45.066
And the blocks are generally not

00:39:45.066 --> 00:39:46.936
near any one player so again,

00:39:47.006 --> 00:39:48.416
using the positional support

00:39:48.596 --> 00:39:50.356
from SceneKit really made this

00:39:50.396 --> 00:39:50.946
sound great.

00:39:52.106 --> 00:39:53.156
Each device makes sounds

00:39:53.156 --> 00:39:55.256
separately without worrying

00:39:55.256 --> 00:39:56.386
about synchronizing across

00:39:56.386 --> 00:39:57.926
devices because we want it to be

00:39:58.036 --> 00:39:59.386
cacophonous, blocks smashing

00:39:59.386 --> 00:39:59.656
about.

00:40:00.486 --> 00:40:02.206
Again, we use a custom Midi

00:40:02.206 --> 00:40:03.676
instrument to take a small

00:40:03.676 --> 00:40:04.996
number of sounds and vary them.

00:40:05.376 --> 00:40:06.636
In this case, varying the attack

00:40:06.636 --> 00:40:08.226
rate based on the strength of

00:40:08.226 --> 00:40:09.636
the collision impulse coming

00:40:09.636 --> 00:40:10.656
from the SceneKit physics

00:40:10.656 --> 00:40:10.886
engine.

00:40:13.316 --> 00:40:15.086
These sounds again are localized

00:40:15.086 --> 00:40:16.386
in 3D coordinates based on the

00:40:16.386 --> 00:40:17.806
device's position in the scene.

00:40:17.976 --> 00:40:19.176
So, collisions in the far end of

00:40:19.176 --> 00:40:20.586
the table are quieter than those

00:40:20.586 --> 00:40:20.996
at your end.

00:40:21.616 --> 00:40:24.000
Let's take a listen to this.

00:40:25.516 --> 00:40:37.886
[ Sound effects ]

00:40:38.386 --> 00:40:39.136
One more shot.

00:40:39.676 --> 00:40:41.116
There we go.

00:40:42.496 --> 00:40:42.676
Right.

00:40:43.266 --> 00:40:47.366
So we wanted to share one more

00:40:47.366 --> 00:40:48.426
little trick that we discovered

00:40:48.426 --> 00:40:50.836
as we were working on this.

00:40:50.836 --> 00:40:51.956
In the process of setting up the

00:40:51.956 --> 00:40:53.206
sounds, we discovered that we

00:40:53.206 --> 00:40:54.686
needed to have a script run at

00:40:54.686 --> 00:40:56.376
RunTime to do some file name

00:40:56.376 --> 00:40:57.746
path conversions on the property

00:40:57.746 --> 00:40:59.246
list for the DAU preset.

00:40:59.926 --> 00:41:01.076
We found that we're able to

00:41:01.076 --> 00:41:03.056
build that tool using Swift but

00:41:03.056 --> 00:41:04.336
set it up as a command line

00:41:04.336 --> 00:41:04.596
tool.

00:41:05.196 --> 00:41:06.706
Do you notice at the top of

00:41:06.706 --> 00:41:07.996
this, the traditional Unix

00:41:07.996 --> 00:41:09.566
shebang-style statement at the

00:41:09.566 --> 00:41:10.266
top of the script.

00:41:10.706 --> 00:41:13.156
That tells your shell to fire up

00:41:13.156 --> 00:41:15.436
Swift to run this.

00:41:15.536 --> 00:41:17.076
By doing this, we can then treat

00:41:17.076 --> 00:41:18.526
Swift as a scripting language.

00:41:19.976 --> 00:41:21.226
You can develop one of these by

00:41:21.226 --> 00:41:23.316
using a Swift playground to work

00:41:23.316 --> 00:41:24.726
with your code interactively and

00:41:24.726 --> 00:41:25.696
make sure that you've gotten it

00:41:25.696 --> 00:41:25.866
right.

00:41:26.966 --> 00:41:28.556
Once it's ready, just save it

00:41:28.556 --> 00:41:30.286
out to a file, add the shebang

00:41:30.286 --> 00:41:31.906
line to the top and make the

00:41:31.906 --> 00:41:33.886
file executable in the file

00:41:33.886 --> 00:41:34.236
system.

00:41:35.246 --> 00:41:36.546
Now you've got a command line

00:41:36.546 --> 00:41:38.736
tool that you can use either,

00:41:38.736 --> 00:41:39.496
you know, outside the

00:41:39.496 --> 00:41:41.876
application or in Xcode using a

00:41:41.876 --> 00:41:42.666
RunScript phase.

00:41:43.486 --> 00:41:45.866
It's very easy and it really

00:41:45.866 --> 00:41:47.216
gives you access to all the

00:41:47.216 --> 00:41:48.056
system frameworks.

00:41:48.316 --> 00:41:49.456
In this case, we're able to edit

00:41:49.456 --> 00:41:50.386
the P list directly.

00:41:51.036 --> 00:41:52.076
It's a really great technique

00:41:52.076 --> 00:41:53.586
and we hope that you'll be able

00:41:53.586 --> 00:41:54.986
to take advantage of it.

00:41:57.116 --> 00:41:59.016
So, today I hope you've seen how

00:41:59.096 --> 00:42:00.226
AR provides really new

00:42:00.226 --> 00:42:01.626
opportunities for engaging games

00:42:01.626 --> 00:42:02.706
and other experiences.

00:42:03.746 --> 00:42:04.986
We encourage you to design with

00:42:04.986 --> 00:42:06.006
AR in mind from the start.

00:42:06.346 --> 00:42:07.866
And remember that for games, the

00:42:07.866 --> 00:42:08.606
play is the thing.

00:42:08.776 --> 00:42:10.856
You can't sprinkle fun on top at

00:42:10.976 --> 00:42:12.000
the end.

00:42:13.146 --> 00:42:14.056
We really hope that you'll

00:42:14.056 --> 00:42:15.966
download the SwiftShot available

00:42:15.966 --> 00:42:17.456
as sample code and use it to

00:42:17.456 --> 00:42:18.696
guide you as you build your own

00:42:18.696 --> 00:42:20.316
apps and we're planning to

00:42:20.316 --> 00:42:21.826
update that with each subsequent

00:42:21.826 --> 00:42:23.976
seed of iOS 12 as we go to the

00:42:23.976 --> 00:42:24.306
release.

00:42:24.906 --> 00:42:27.316
And finally, if you haven't had

00:42:27.316 --> 00:42:28.636
a chance yet, we hope you'll

00:42:28.636 --> 00:42:29.596
play SwiftShot with us

00:42:29.786 --> 00:42:32.326
downstairs in the game room.

00:42:32.456 --> 00:42:34.136
For more information, there's an

00:42:34.136 --> 00:42:35.536
ARKit lab immediately after this

00:42:35.536 --> 00:42:36.656
session and the get together

00:42:36.656 --> 00:42:37.176
this evening.

00:42:37.836 --> 00:42:39.406
I'm also happy to announce that

00:42:39.406 --> 00:42:40.196
for those of you here at the

00:42:40.196 --> 00:42:41.536
conference, we're going to have

00:42:41.536 --> 00:42:42.696
a SwiftShot tournament this

00:42:42.696 --> 00:42:44.566
Friday from noon to 2, so we

00:42:44.566 --> 00:42:45.586
hope you'll join us for that.

00:42:46.496 --> 00:42:47.186
Thank you very much.

00:42:48.338 --> 00:42:50.338
[ Applause ]
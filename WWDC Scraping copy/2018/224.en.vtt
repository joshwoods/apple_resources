WEBVTT

00:00:07.016 --> 00:00:15.500
[ Music ]

00:00:21.416 --> 00:00:21.976
>> Good afternoon, everyone.

00:00:22.516 --> 00:00:27.406
[ Applause ]

00:00:27.906 --> 00:00:29.096
Welcome to Core Data Best

00:00:29.096 --> 00:00:29.806
Practices.

00:00:29.926 --> 00:00:30.886
My name is Scott Perry.

00:00:30.886 --> 00:00:32.016
I work on Core Data.

00:00:32.466 --> 00:00:33.776
And we'll be joined later by my

00:00:33.776 --> 00:00:35.016
teammate, Nick Gillett.

00:00:36.516 --> 00:00:39.286
The plan for today, first, we'll

00:00:39.286 --> 00:00:40.886
talk a bit about how the process

00:00:40.886 --> 00:00:41.866
of getting started with Core

00:00:41.866 --> 00:00:43.216
Data has evolved over time.

00:00:43.956 --> 00:00:45.946
Then, we will cover ways we can

00:00:45.946 --> 00:00:47.346
evolve our application more

00:00:47.346 --> 00:00:48.706
easily by taking advantage of

00:00:48.706 --> 00:00:49.886
extension points in the

00:00:49.886 --> 00:00:50.836
persistent container.

00:00:51.486 --> 00:00:53.556
We'll follow that with how we

00:00:53.556 --> 00:00:55.026
can evolve our model as our apps

00:00:55.026 --> 00:00:56.676
requirements change and our data

00:00:56.676 --> 00:00:57.236
grows.

00:00:59.106 --> 00:01:00.666
Then, Nick is going to talk

00:01:00.666 --> 00:01:01.946
about a few ways our app can

00:01:01.946 --> 00:01:03.226
maintain its performance, even

00:01:03.226 --> 00:01:04.726
as it scales beyond our wildest

00:01:04.726 --> 00:01:07.666
dreams, and we'll wrap up with

00:01:08.406 --> 00:01:09.196
some good stuff about

00:01:09.196 --> 00:01:10.646
transformers, debugging, and

00:01:10.646 --> 00:01:11.046
testing.

00:01:11.586 --> 00:01:15.976
But first, let's build an app.

00:01:15.976 --> 00:01:17.716
I like to take photos, so we're

00:01:17.716 --> 00:01:18.416
going to build something that

00:01:18.416 --> 00:01:19.486
allows me to share photos with

00:01:19.486 --> 00:01:21.746
friends and get comments from

00:01:21.746 --> 00:01:22.946
them, even if it's just Nick

00:01:22.946 --> 00:01:25.316
asking how my slides are going.

00:01:26.236 --> 00:01:28.026
Where should we keep our app's

00:01:28.026 --> 00:01:28.406
data?

00:01:28.586 --> 00:01:30.016
Well, we could keep it all

00:01:30.016 --> 00:01:31.456
online, but I usually take

00:01:31.456 --> 00:01:32.776
photos when I'm traveling, and

00:01:32.776 --> 00:01:33.696
the connection can be kind of

00:01:33.696 --> 00:01:35.756
spotty, so we should keep it

00:01:35.756 --> 00:01:37.046
locally, organized into some

00:01:37.046 --> 00:01:37.736
kind of store.

00:01:40.296 --> 00:01:42.596
So, we have posts and comments

00:01:42.596 --> 00:01:44.006
and their instances and the

00:01:44.006 --> 00:01:45.606
relationships between them form

00:01:45.606 --> 00:01:47.386
an object graph and we've

00:01:47.386 --> 00:01:48.846
decided we need to persist these

00:01:48.846 --> 00:01:52.316
things on disk, so that's what

00:01:52.316 --> 00:01:53.096
Core Data is for.

00:01:56.006 --> 00:01:57.236
So, we'll use that and we'll

00:01:57.236 --> 00:01:59.166
start by translating our mock

00:01:59.216 --> 00:02:01.006
here into something a store can

00:02:01.006 --> 00:02:02.306
understand, a managed object

00:02:02.306 --> 00:02:02.606
model.

00:02:03.616 --> 00:02:04.276
We'll need fields for

00:02:04.276 --> 00:02:05.816
everything, with attributes for

00:02:05.816 --> 00:02:07.406
things like the image's data as

00:02:07.406 --> 00:02:08.606
well as the time it was posted,

00:02:09.076 --> 00:02:11.266
and we'll need relationships for

00:02:11.266 --> 00:02:12.236
posts and comments.

00:02:12.596 --> 00:02:14.066
We've also defined a need for a

00:02:14.066 --> 00:02:15.446
store, but there's a lot

00:02:15.446 --> 00:02:17.366
involved in maintaining data on

00:02:17.366 --> 00:02:18.156
disk over time.

00:02:19.056 --> 00:02:20.386
Luckily, Core Data provides a

00:02:20.386 --> 00:02:21.956
persistent store coordinator to

00:02:21.956 --> 00:02:22.546
manage that.

00:02:22.986 --> 00:02:24.836
The coordinator can do things

00:02:24.836 --> 00:02:26.246
like compare the app's model

00:02:26.246 --> 00:02:27.806
with the store's version and

00:02:27.806 --> 00:02:29.276
automatically migrate it forward

00:02:29.276 --> 00:02:30.306
as our app evolves.

00:02:30.786 --> 00:02:32.916
Finally, managed object context

00:02:32.916 --> 00:02:34.436
provide safe, fast, and

00:02:34.436 --> 00:02:35.936
predictable access to our data,

00:02:36.616 --> 00:02:37.826
even when we're using many at

00:02:37.826 --> 00:02:39.426
the same time through features

00:02:39.426 --> 00:02:40.636
like query generations,

00:02:40.716 --> 00:02:41.896
connection pooling, and history

00:02:41.896 --> 00:02:42.376
tracking.

00:02:44.236 --> 00:02:46.486
Setting this all up requires

00:02:46.566 --> 00:02:47.736
finding the model and loading it

00:02:47.736 --> 00:02:49.236
and deciding where to keep the

00:02:49.236 --> 00:02:51.186
store, but a lot of these error

00:02:51.186 --> 00:02:53.026
paths can't actually fail once

00:02:53.026 --> 00:02:54.816
you've shipped your app, so Core

00:02:54.816 --> 00:02:56.246
Data provides a container type

00:02:56.576 --> 00:02:57.716
that dramatically reduces the

00:02:57.716 --> 00:02:58.946
amount of boilerplate required

00:02:58.946 --> 00:03:00.736
to set up your stack, just refer

00:03:00.736 --> 00:03:02.056
to the model by name, and the

00:03:02.056 --> 00:03:03.486
persistent container will load

00:03:03.486 --> 00:03:05.046
it out of the main bundle and

00:03:05.046 --> 00:03:06.276
keep a stored in a consistent

00:03:06.276 --> 00:03:06.766
location.

00:03:07.306 --> 00:03:10.386
This persistent container type

00:03:10.386 --> 00:03:11.926
encapsulates a whole stack and

00:03:11.926 --> 00:03:13.526
includes conveniences for a

00:03:13.526 --> 00:03:15.256
shared main queue view context

00:03:15.806 --> 00:03:17.926
as well as factory methods for

00:03:18.246 --> 00:03:20.286
generating background contexts

00:03:20.286 --> 00:03:21.396
as well as performing background

00:03:21.396 --> 00:03:21.676
work.

00:03:22.426 --> 00:03:23.796
It's also designed to be easy to

00:03:23.796 --> 00:03:25.366
work with as our app grows.

00:03:25.776 --> 00:03:27.706
For example, let's say we want

00:03:27.706 --> 00:03:29.176
to factor our model layer into

00:03:29.176 --> 00:03:29.956
its own framework.

00:03:30.836 --> 00:03:31.856
We can do that by creating a new

00:03:31.856 --> 00:03:33.166
framework target in Xcode and

00:03:33.166 --> 00:03:34.116
moving our code into it.

00:03:34.446 --> 00:03:36.166
It's all super easy, but when we

00:03:36.166 --> 00:03:37.116
move our model into the new

00:03:37.116 --> 00:03:38.836
target, in the built product,

00:03:38.836 --> 00:03:40.836
targets move from the app into

00:03:40.836 --> 00:03:42.736
the new framework, which is

00:03:42.736 --> 00:03:43.806
what's supposed to happen, but

00:03:43.806 --> 00:03:45.246
now NSPersistentContainer

00:03:45.436 --> 00:03:46.196
doesn't know where to find our

00:03:46.196 --> 00:03:46.896
model anymore.

00:03:47.476 --> 00:03:48.566
This is because it only checks

00:03:48.566 --> 00:03:49.846
the main bundle by default.

00:03:50.416 --> 00:03:51.056
Why stop there?

00:03:51.806 --> 00:03:53.296
Well, searching all of the app's

00:03:53.296 --> 00:03:54.826
bundles could get really slow

00:03:54.826 --> 00:03:56.526
for a complicated app and it's

00:03:56.526 --> 00:03:57.816
not a cost you want to pay every

00:03:57.816 --> 00:03:58.866
time you spin up a stack.

00:04:00.206 --> 00:04:01.506
How do we fix this?

00:04:02.666 --> 00:04:03.926
Well, we could resuscitate the

00:04:03.926 --> 00:04:05.206
model out of the framework

00:04:05.206 --> 00:04:06.766
bundle ourselves and use one of

00:04:06.766 --> 00:04:07.456
the container's other

00:04:07.456 --> 00:04:08.666
initializers, like one that

00:04:08.736 --> 00:04:10.606
takes an explicit managed object

00:04:10.606 --> 00:04:12.986
model, but NSPersistentContainer

00:04:12.986 --> 00:04:14.486
actually has a way for you to

00:04:14.486 --> 00:04:16.036
change which bundle it searches.

00:04:17.856 --> 00:04:19.856
See, NSPersistentContainer knows

00:04:19.856 --> 00:04:21.086
when it's been subclassed and

00:04:21.086 --> 00:04:21.906
will use the type of the

00:04:21.906 --> 00:04:24.106
subclass as a hint when it looks

00:04:24.106 --> 00:04:24.666
for the model.

00:04:25.156 --> 00:04:26.256
All we need to do to take

00:04:26.256 --> 00:04:27.566
advantage of this is to create a

00:04:27.566 --> 00:04:28.236
subclass.

00:04:28.756 --> 00:04:29.826
It doesn't even need to have

00:04:29.826 --> 00:04:30.466
anything in it.

00:04:31.916 --> 00:04:33.026
Then, any code setting up

00:04:33.026 --> 00:04:33.976
through the container that wants

00:04:33.976 --> 00:04:35.816
to use our model can just adopt

00:04:35.816 --> 00:04:37.466
that subclass and the persistent

00:04:37.466 --> 00:04:38.646
container will check in our

00:04:38.646 --> 00:04:40.106
frameworks bundle for our model

00:04:40.106 --> 00:04:40.586
instead.

00:04:41.196 --> 00:04:45.126
So, that's fun, but since we're

00:04:45.126 --> 00:04:45.856
going through the effort of

00:04:45.856 --> 00:04:47.286
factoring our app's resources,

00:04:47.436 --> 00:04:48.486
wouldn't it be nice if we also

00:04:48.486 --> 00:04:49.696
improved the organization of our

00:04:49.696 --> 00:04:50.426
data on disk?

00:04:51.146 --> 00:04:53.306
By default, new persistent

00:04:53.306 --> 00:04:54.276
containers come with a store

00:04:54.276 --> 00:04:55.986
description for an SQLite store

00:04:56.116 --> 00:04:58.136
with automatic migration that on

00:04:58.136 --> 00:04:59.926
iOS lives in our app's documents

00:04:59.926 --> 00:05:00.366
directory.

00:05:00.796 --> 00:05:02.056
That was great when our model

00:05:02.056 --> 00:05:04.066
code was part of the app, but we

00:05:04.066 --> 00:05:04.876
should try to keep our new

00:05:04.876 --> 00:05:06.116
frameworks files from mingling

00:05:06.116 --> 00:05:07.286
too much with the apps.

00:05:08.376 --> 00:05:09.566
Since we already subclassed

00:05:09.566 --> 00:05:10.976
NSPersistentContainer to make

00:05:10.976 --> 00:05:12.706
finding the model easier, let's

00:05:12.706 --> 00:05:14.086
build on that to improve this.

00:05:16.476 --> 00:05:18.456
The brute force way to change a

00:05:18.456 --> 00:05:20.786
store's location is to directly

00:05:20.786 --> 00:05:22.156
modify the URL in the

00:05:22.156 --> 00:05:23.446
persistentStoreDescription

00:05:23.446 --> 00:05:24.586
before loading the store.

00:05:25.556 --> 00:05:26.716
Sometimes that's what you want

00:05:26.716 --> 00:05:27.826
and we could use that pattern

00:05:27.826 --> 00:05:29.406
here, but we don't have to

00:05:29.716 --> 00:05:31.516
because NSPersistentContainer

00:05:31.516 --> 00:05:33.996
calls its own default directory

00:05:33.996 --> 00:05:35.816
URL method when creating

00:05:35.816 --> 00:05:37.086
persistent store descriptions.

00:05:37.286 --> 00:05:38.626
And it's made to be overridden.

00:05:39.166 --> 00:05:40.516
In this case, we can just append

00:05:40.516 --> 00:05:42.066
a path component, but this is

00:05:42.066 --> 00:05:43.076
also a good way to set up

00:05:43.076 --> 00:05:45.776
containers for caches or other

00:05:45.776 --> 00:05:46.826
kinds of stacks that need to

00:05:46.826 --> 00:05:47.926
keep their stores in different

00:05:47.926 --> 00:05:49.756
locations, like your tasks.

00:05:50.306 --> 00:05:53.046
So, now that we've got our Core

00:05:53.046 --> 00:05:54.256
Data stock all figured out,

00:05:54.386 --> 00:05:55.686
let's have a look at our app and

00:05:55.686 --> 00:05:57.116
some of the view controllers

00:05:57.116 --> 00:05:57.706
that we've written.

00:05:58.376 --> 00:05:59.926
It looks like we've got some

00:05:59.926 --> 00:06:00.896
pretty specialized view

00:06:00.896 --> 00:06:01.606
controllers here.

00:06:02.296 --> 00:06:03.386
Here's one that shows all of my

00:06:03.386 --> 00:06:04.826
posts as well as another that

00:06:04.826 --> 00:06:06.746
shows all posts by all authors.

00:06:07.226 --> 00:06:08.226
Even the detail views are

00:06:08.346 --> 00:06:09.166
duplicated.

00:06:09.306 --> 00:06:10.796
It feels a lot like we could

00:06:10.796 --> 00:06:13.386
have written half the code.

00:06:13.776 --> 00:06:15.656
All we should really need is one

00:06:15.656 --> 00:06:16.916
view controller for displaying a

00:06:16.916 --> 00:06:18.556
list of posts and another for

00:06:18.556 --> 00:06:19.926
displaying a single post.

00:06:20.626 --> 00:06:21.656
We can accomplish this by

00:06:21.656 --> 00:06:23.526
defining good boundaries in

00:06:23.526 --> 00:06:25.516
between our view controllers in

00:06:25.516 --> 00:06:26.916
the form of interfaces that take

00:06:26.916 --> 00:06:27.786
model objects.

00:06:29.286 --> 00:06:30.576
Each controller gets configured

00:06:30.576 --> 00:06:33.026
by its model parameters and then

00:06:33.026 --> 00:06:34.136
they can customize their views

00:06:34.136 --> 00:06:35.306
in cells based on whether

00:06:35.306 --> 00:06:36.626
they're showing my posts or

00:06:36.626 --> 00:06:37.386
someone else's.

00:06:37.906 --> 00:06:40.936
When drafting view controllers

00:06:40.936 --> 00:06:42.566
using Core Data, list views

00:06:42.566 --> 00:06:44.016
should get fetch requests and

00:06:44.016 --> 00:06:45.406
detail views should get managed

00:06:45.406 --> 00:06:46.096
objects.

00:06:47.506 --> 00:06:48.776
View controllers also need a

00:06:48.776 --> 00:06:50.446
managed object context, either

00:06:50.446 --> 00:06:52.076
the container's view context or

00:06:52.076 --> 00:06:53.886
some other main queue context.

00:06:54.046 --> 00:06:55.536
And this pattern for

00:06:55.536 --> 00:06:56.806
generalizing view controllers

00:06:56.806 --> 00:06:58.176
with Core Data isn't just for

00:06:58.176 --> 00:06:59.596
UIs; it works really well for

00:06:59.596 --> 00:07:00.836
utility types as well.

00:07:01.806 --> 00:07:02.926
Instead of passing Core Data

00:07:02.926 --> 00:07:05.006
types for presentation, we can

00:07:05.006 --> 00:07:06.446
pass things like URLs or

00:07:06.446 --> 00:07:08.106
serialized data into background

00:07:08.106 --> 00:07:10.496
work controllers and turn those

00:07:10.496 --> 00:07:11.896
into new and updated managed

00:07:11.896 --> 00:07:13.446
objects using a background

00:07:13.506 --> 00:07:14.876
context instead of a view

00:07:14.876 --> 00:07:16.476
context to do our work.

00:07:18.016 --> 00:07:19.136
Adopting this kind of interface

00:07:19.136 --> 00:07:20.616
and utility type is super easy

00:07:20.616 --> 00:07:22.146
since we own the initializer, so

00:07:22.146 --> 00:07:22.956
we can just require the

00:07:22.956 --> 00:07:23.936
parameters to create the

00:07:23.936 --> 00:07:24.466
controller.

00:07:24.566 --> 00:07:26.316
But how do we get our boundary

00:07:26.316 --> 00:07:27.416
variables into our view

00:07:27.416 --> 00:07:28.086
controllers?

00:07:28.676 --> 00:07:31.946
Well, if we're using segues, we

00:07:31.946 --> 00:07:33.226
can override the prepare method

00:07:34.636 --> 00:07:35.706
and get a reference to the

00:07:35.706 --> 00:07:37.086
destinationViewController and

00:07:37.086 --> 00:07:38.186
then configure it there.

00:07:38.806 --> 00:07:40.636
If we're using storyboards or

00:07:40.636 --> 00:07:42.656
nibs, then we already have code

00:07:42.656 --> 00:07:43.576
that has to cons up a

00:07:43.576 --> 00:07:45.676
destinationViewController, so

00:07:45.676 --> 00:07:46.516
all we need to do is set the

00:07:46.516 --> 00:07:47.976
properties before presentation.

00:07:48.506 --> 00:07:50.586
And, if we're driving stick, we

00:07:50.586 --> 00:07:51.676
can just write an initializer

00:07:51.676 --> 00:07:52.826
that explicitly defines the

00:07:52.826 --> 00:07:54.256
boundary conditions, just like

00:07:54.256 --> 00:07:55.676
we do with our utility types.

00:07:56.276 --> 00:07:59.656
OK. So, now we've got a fetch

00:07:59.656 --> 00:08:01.056
request and a context for our

00:08:01.056 --> 00:08:02.656
view controller, but before we

00:08:02.656 --> 00:08:04.136
smash them together to get our

00:08:04.136 --> 00:08:05.486
results, we should configure the

00:08:05.486 --> 00:08:06.746
fetch request a little bit more

00:08:06.746 --> 00:08:07.986
to make sure that our controller

00:08:07.986 --> 00:08:09.136
will have great performance.

00:08:10.856 --> 00:08:12.276
Sometimes it makes sense to set

00:08:12.276 --> 00:08:13.806
a fetch limit, but in the case

00:08:13.806 --> 00:08:15.036
of our list view, batching makes

00:08:15.036 --> 00:08:16.036
more sense because we want to

00:08:16.036 --> 00:08:18.596
show all the data and we know

00:08:18.596 --> 00:08:20.126
exactly how many cells our view

00:08:20.126 --> 00:08:21.296
controller can fit on the screen

00:08:21.296 --> 00:08:21.806
at once.

00:08:22.546 --> 00:08:24.306
In general, at least one of

00:08:24.306 --> 00:08:25.886
these options should always be

00:08:25.886 --> 00:08:27.156
set for fetch requests that

00:08:27.156 --> 00:08:28.586
might return an unbounded number

00:08:28.586 --> 00:08:29.276
of results.

00:08:29.956 --> 00:08:32.346
So, at this point, we could turn

00:08:32.346 --> 00:08:33.676
our fetch request into objects

00:08:33.676 --> 00:08:35.025
and populate a list view with

00:08:35.056 --> 00:08:37.196
the results, but what if we want

00:08:37.196 --> 00:08:39.155
to keep the UI up to date with

00:08:39.155 --> 00:08:40.366
changes as they happen?

00:08:41.666 --> 00:08:42.846
Core Data has us covered here as

00:08:42.846 --> 00:08:43.756
well with the fetched results

00:08:43.756 --> 00:08:44.246
controller.

00:08:44.726 --> 00:08:46.356
Available on all platforms since

00:08:46.356 --> 00:08:47.976
Sierra, adopting the fetched

00:08:47.976 --> 00:08:49.366
results controller just requires

00:08:49.366 --> 00:08:50.556
writing an adaptor between the

00:08:50.556 --> 00:08:51.886
delegate protocol and the view

00:08:51.886 --> 00:08:52.536
it's driving.

00:08:53.136 --> 00:08:54.556
And to create one, all we need

00:08:54.556 --> 00:08:55.296
is a fetch request and a

00:08:55.296 --> 00:08:55.836
context.

00:08:57.176 --> 00:08:58.136
The fetched results controller

00:08:58.136 --> 00:08:59.276
even supports driving more

00:08:59.276 --> 00:09:01.316
advanced list view concepts such

00:09:01.316 --> 00:09:02.026
as sections.

00:09:03.066 --> 00:09:05.066
If we wanted to group posts into

00:09:05.066 --> 00:09:06.206
sections by the day they were

00:09:06.206 --> 00:09:07.596
posted, we could do it by

00:09:07.596 --> 00:09:09.046
extending the post type that's

00:09:09.046 --> 00:09:10.696
generated by Xcode with the

00:09:10.696 --> 00:09:12.436
computed property and passing

00:09:12.436 --> 00:09:13.686
the name of it to the fetched

00:09:13.686 --> 00:09:14.436
results controller's

00:09:14.436 --> 00:09:15.076
initializer.

00:09:16.336 --> 00:09:18.156
This works well, but what if we

00:09:18.156 --> 00:09:19.226
have a view controller more

00:09:19.226 --> 00:09:20.596
complicated than just a list of

00:09:20.596 --> 00:09:21.656
our objects?

00:09:21.806 --> 00:09:22.786
What if we want to show

00:09:22.786 --> 00:09:24.686
something like a chart of the

00:09:24.686 --> 00:09:25.966
posts per day on our app?

00:09:27.556 --> 00:09:28.776
Well, the first thing we should

00:09:28.776 --> 00:09:29.976
do is not underestimate the

00:09:29.976 --> 00:09:31.266
power of fetched requests.

00:09:31.816 --> 00:09:33.126
I'm just one person, so in the

00:09:33.126 --> 00:09:34.326
last month, I haven't managed to

00:09:34.326 --> 00:09:36.576
post more than 40 pictures per

00:09:36.576 --> 00:09:36.926
day.

00:09:37.706 --> 00:09:39.196
Over the course of 30 days,

00:09:39.336 --> 00:09:40.646
that's still a fairly reasonable

00:09:40.646 --> 00:09:41.706
amount of data to pull out of

00:09:41.706 --> 00:09:42.566
the store at once.

00:09:43.446 --> 00:09:45.466
If the day property that we

00:09:45.466 --> 00:09:46.856
defined earlier was actually

00:09:46.856 --> 00:09:48.236
part of the entity in the model,

00:09:48.646 --> 00:09:49.386
then we could write a fetch

00:09:49.386 --> 00:09:50.506
request that counts up the

00:09:50.506 --> 00:09:52.046
number of posts grouped by the

00:09:52.046 --> 00:09:52.916
day they were posted.

00:09:53.456 --> 00:09:54.696
There's three parts to this

00:09:54.696 --> 00:09:55.236
request.

00:09:55.616 --> 00:09:56.986
The first one is just setting

00:09:56.986 --> 00:09:57.426
the range.

00:09:57.596 --> 00:09:58.966
We want the last 30 days of

00:09:58.966 --> 00:09:59.316
data.

00:09:59.316 --> 00:10:02.316
Next, we want to group together

00:10:02.316 --> 00:10:04.536
all results whose day attributes

00:10:04.536 --> 00:10:05.716
share the same value.

00:10:06.316 --> 00:10:07.076
Since we're now fetching

00:10:07.076 --> 00:10:08.566
aggregates instead of individual

00:10:08.566 --> 00:10:09.796
objects, we have to change the

00:10:09.796 --> 00:10:10.876
result type to something more

00:10:10.876 --> 00:10:12.576
sensible as well, in this case,

00:10:12.576 --> 00:10:13.066
a dictionary.

00:10:14.726 --> 00:10:16.266
Finally, we define an expression

00:10:16.266 --> 00:10:17.346
that represents the number of

00:10:17.346 --> 00:10:19.316
objects in each group and tell

00:10:19.316 --> 00:10:20.976
the fetch requests to return

00:10:20.976 --> 00:10:22.936
that count along with the day it

00:10:22.936 --> 00:10:23.616
represents.

00:10:24.926 --> 00:10:26.996
This fetch request returns 30

00:10:26.996 --> 00:10:28.416
results, each of which is one

00:10:28.416 --> 00:10:29.876
point on our chart.

00:10:31.216 --> 00:10:34.466
If you're into databases, this

00:10:34.466 --> 00:10:35.546
is the SQLite query that Core

00:10:35.546 --> 00:10:36.686
Data generates from that fetch

00:10:36.686 --> 00:10:37.186
request.

00:10:37.646 --> 00:10:38.846
It's exactly what you do if

00:10:38.846 --> 00:10:39.516
you're writing the query

00:10:39.516 --> 00:10:40.046
yourself.

00:10:40.496 --> 00:10:41.816
Core Data understands how to

00:10:41.816 --> 00:10:43.226
convert many expression

00:10:43.226 --> 00:10:44.716
functions into optimal database

00:10:44.716 --> 00:10:45.196
queries.

00:10:45.776 --> 00:10:46.856
A group by query can use

00:10:46.856 --> 00:10:48.066
aggregate functions such as

00:10:48.066 --> 00:10:50.076
average and sum and scalar

00:10:50.076 --> 00:10:51.736
queries, like a normal fetch

00:10:51.736 --> 00:10:53.336
request, can use scalar math and

00:10:53.336 --> 00:10:54.926
date functions, like abs for the

00:10:54.926 --> 00:10:56.416
absolute value and now for the

00:10:56.416 --> 00:10:57.026
current time.

00:10:57.156 --> 00:10:59.366
If you want to know more about

00:10:59.366 --> 00:11:00.236
what you can do with

00:11:00.266 --> 00:11:01.306
NSExpression, check out the

00:11:01.306 --> 00:11:02.626
documentation for its list of

00:11:02.626 --> 00:11:03.286
functions.

00:11:03.356 --> 00:11:04.366
Many of them are supported by

00:11:04.366 --> 00:11:07.336
fetch requests in Core Data.

00:11:08.366 --> 00:11:10.586
OK. So, fetch requests can

00:11:10.586 --> 00:11:12.566
accomplish a lot through the use

00:11:12.566 --> 00:11:14.606
of expressions, but SQLite still

00:11:14.606 --> 00:11:16.286
reads every one of our posts

00:11:16.286 --> 00:11:17.406
through memory when computing

00:11:17.406 --> 00:11:18.636
the counts for our graph here.

00:11:19.126 --> 00:11:20.976
That works fine for charts

00:11:20.976 --> 00:11:23.566
showing the amount of posts

00:11:23.566 --> 00:11:24.586
generated by one human in a

00:11:24.586 --> 00:11:25.796
month, but what if we want to

00:11:25.796 --> 00:11:26.746
chart something bigger?

00:11:27.086 --> 00:11:28.676
What if we want to show a whole

00:11:28.676 --> 00:11:30.536
year or what if our little app

00:11:30.536 --> 00:11:32.136
starts handling orders of

00:11:32.136 --> 00:11:33.386
magnitude more data?

00:11:34.706 --> 00:11:35.686
Now the fetch request would be

00:11:35.686 --> 00:11:37.566
counting at least 50,000 posts

00:11:37.566 --> 00:11:39.226
one by one just to show 30 data

00:11:39.226 --> 00:11:41.226
points and that's not going to

00:11:41.226 --> 00:11:41.956
be fast enough.

00:11:42.436 --> 00:11:44.076
The mismatch between our views

00:11:44.076 --> 00:11:45.436
and our model has gotten to the

00:11:45.436 --> 00:11:46.316
point where we need to start

00:11:46.316 --> 00:11:47.596
doing some denormalization.

00:11:50.226 --> 00:11:52.266
Denormalization is when we add

00:11:52.266 --> 00:11:53.596
redundant copies of data or

00:11:53.596 --> 00:11:55.266
metadata to improve read

00:11:55.266 --> 00:11:56.556
performance at the expense of

00:11:56.556 --> 00:11:57.576
some additional bookkeeping.

00:11:58.156 --> 00:11:59.546
Database indexes are a good

00:11:59.546 --> 00:12:00.466
example of this.

00:12:01.396 --> 00:12:02.766
Adding count metadata to our

00:12:02.766 --> 00:12:04.526
store is exactly the kind of

00:12:04.526 --> 00:12:06.476
compromise we need to get our

00:12:06.546 --> 00:12:07.866
chart's performance again.

00:12:08.666 --> 00:12:10.676
So, let's look at how our model

00:12:10.676 --> 00:12:12.366
can group posts into counts by

00:12:12.366 --> 00:12:12.736
day.

00:12:13.626 --> 00:12:15.556
We'll need a new entity with two

00:12:15.556 --> 00:12:17.246
attributes, plus a bit of extra

00:12:17.246 --> 00:12:17.896
maintenance to keep them

00:12:17.896 --> 00:12:18.316
accurate.

00:12:19.186 --> 00:12:20.796
Grouping by day improves our

00:12:20.796 --> 00:12:22.396
fetch request so much that it

00:12:22.396 --> 00:12:23.756
guarantees good performance for

00:12:23.756 --> 00:12:25.386
charts covering years of data,

00:12:25.766 --> 00:12:26.776
so we only have to create this

00:12:26.776 --> 00:12:29.376
one level of denormalization and

00:12:29.376 --> 00:12:30.516
the fetch request that we passed

00:12:30.516 --> 00:12:31.496
to the chart view controller?

00:12:32.386 --> 00:12:33.446
It's super simple.

00:12:34.416 --> 00:12:35.256
It's really not that much

00:12:35.256 --> 00:12:36.336
different than the fetch request

00:12:36.336 --> 00:12:37.576
that we'd pass off to any other

00:12:37.576 --> 00:12:39.386
list view, which is actually

00:12:39.506 --> 00:12:40.636
kind of sort of what a chart

00:12:40.636 --> 00:12:41.826
view is if you squint hard

00:12:41.826 --> 00:12:42.176
enough.

00:12:43.766 --> 00:12:44.866
But what about that extra

00:12:44.866 --> 00:12:45.396
maintenance?

00:12:46.186 --> 00:12:47.656
We've got to increment the count

00:12:47.656 --> 00:12:48.986
whenever a post gets published

00:12:48.986 --> 00:12:50.236
and decrement it whenever a post

00:12:50.236 --> 00:12:50.846
is removed.

00:12:51.556 --> 00:12:53.016
We could do this in the methods

00:12:53.016 --> 00:12:54.296
that change the post object's

00:12:54.296 --> 00:12:55.836
relevant state, but a more

00:12:55.836 --> 00:12:56.886
foolproof solution is to update

00:12:56.886 --> 00:12:58.046
our counts in response to the

00:12:58.046 --> 00:12:58.796
context saving.

00:12:59.356 --> 00:13:04.546
We could just register for the

00:13:04.976 --> 00:13:07.156
managed object contextWillSave

00:13:07.156 --> 00:13:08.866
notification with a function

00:13:09.296 --> 00:13:10.286
that goes through all of the

00:13:10.286 --> 00:13:11.406
posts that have been inserted,

00:13:11.696 --> 00:13:13.136
incrementing the count for each

00:13:13.136 --> 00:13:15.626
day that's relevant, and another

00:13:16.066 --> 00:13:16.946
loop going through all of the

00:13:16.946 --> 00:13:18.186
deleted objects, decrementing

00:13:18.186 --> 00:13:18.956
the count for each day.

00:13:19.646 --> 00:13:20.656
And that affects the state of

00:13:20.656 --> 00:13:22.106
the context before it commits to

00:13:22.106 --> 00:13:23.516
the database, so it all winds up

00:13:23.516 --> 00:13:25.166
happening in one transaction, so

00:13:25.166 --> 00:13:27.236
this scales really well, which

00:13:27.236 --> 00:13:28.916
is useful because my teammate

00:13:28.916 --> 00:13:30.366
Nick Gillett is here to talk

00:13:30.366 --> 00:13:31.676
about how Core Data can help us

00:13:31.676 --> 00:13:33.296
as our little app scales beyond

00:13:33.296 --> 00:13:34.186
our wildest dreams.

00:13:34.846 --> 00:13:34.976
Nick.

00:13:35.271 --> 00:13:37.271
[ Applause ]

00:13:37.526 --> 00:13:37.976
>> Thanks, Scott.

00:13:38.416 --> 00:13:40.416
[ Applause ]

00:13:40.816 --> 00:13:42.296
So, as Scott said, as your

00:13:42.296 --> 00:13:43.876
applications grow, they get more

00:13:43.876 --> 00:13:46.606
and more complex and at Core

00:13:46.606 --> 00:13:48.196
Data it's really important to us

00:13:48.196 --> 00:13:50.656
that your applications do grow.

00:13:50.656 --> 00:13:51.746
In fact, we want this.

00:13:51.746 --> 00:13:53.336
That's the whole reason we exist

00:13:53.426 --> 00:13:54.626
is to help you manage this

00:13:54.626 --> 00:13:56.166
growth, make it efficient for

00:13:56.166 --> 00:13:58.026
you to work with, and help you

00:13:58.026 --> 00:13:59.106
give more value to your

00:13:59.106 --> 00:13:59.656
customers.

00:14:00.306 --> 00:14:03.046
But this happens in ways that

00:14:03.046 --> 00:14:04.216
are very specific to your

00:14:04.216 --> 00:14:04.936
application.

00:14:05.416 --> 00:14:06.976
It's also highly aligned with

00:14:06.976 --> 00:14:08.696
your customer experience or the

00:14:08.696 --> 00:14:09.936
way that you want them to

00:14:09.936 --> 00:14:11.266
experience your application.

00:14:12.056 --> 00:14:13.816
Unfortunately, like all complex

00:14:13.816 --> 00:14:15.696
systems, as it grows and becomes

00:14:15.696 --> 00:14:17.646
more complex, it also tends

00:14:17.646 --> 00:14:18.516
toward chaos.

00:14:19.376 --> 00:14:20.716
So, today we're going to talk

00:14:20.716 --> 00:14:22.136
about ways that Core Data can

00:14:22.136 --> 00:14:23.876
help you manage this chaos and

00:14:23.876 --> 00:14:24.896
give it some structure.

00:14:25.466 --> 00:14:26.536
We'll talk about building

00:14:26.536 --> 00:14:28.996
predictable behaviors and

00:14:28.996 --> 00:14:30.436
helping you build tunable

00:14:30.436 --> 00:14:31.826
containers that you can align

00:14:31.826 --> 00:14:32.976
with your experience metrics.

00:14:36.236 --> 00:14:37.346
What does that mean?

00:14:38.246 --> 00:14:39.996
Well, when we think of metrics,

00:14:39.996 --> 00:14:40.996
there's a couple of different

00:14:40.996 --> 00:14:42.646
ways that we can think about

00:14:42.646 --> 00:14:42.946
them.

00:14:43.396 --> 00:14:44.906
The first is in alignment with

00:14:44.906 --> 00:14:45.696
our customers.

00:14:46.326 --> 00:14:48.586
And usually we define these as

00:14:48.586 --> 00:14:49.836
things that they experience,

00:14:49.836 --> 00:14:51.176
like having a consistent user

00:14:51.176 --> 00:14:53.536
interface or a responsive scroll

00:14:53.536 --> 00:14:57.786
view, and also as delight.

00:14:58.486 --> 00:15:01.106
But those are really hard for us

00:15:01.106 --> 00:15:02.476
to capture as engineers.

00:15:03.256 --> 00:15:04.326
So, we translate them into

00:15:04.326 --> 00:15:06.186
engineering metrics, things like

00:15:06.296 --> 00:15:08.276
peak memory consumption, how

00:15:08.276 --> 00:15:09.836
much battery drains during a

00:15:09.836 --> 00:15:12.056
given task or how much CPU time

00:15:12.436 --> 00:15:13.896
is burned during a given task.

00:15:14.316 --> 00:15:16.206
And, finally, how much IO we do

00:15:16.816 --> 00:15:17.906
during a given task.

00:15:18.806 --> 00:15:19.656
To make this a little more

00:15:19.656 --> 00:15:20.886
concrete, we'll use this

00:15:20.886 --> 00:15:21.626
application.

00:15:22.286 --> 00:15:23.236
Some of you may remember the

00:15:23.236 --> 00:15:24.736
history demo application that

00:15:24.836 --> 00:15:26.886
was introduced last year at WWDC

00:15:27.306 --> 00:15:28.536
and I've modified it for the

00:15:28.536 --> 00:15:29.676
purposes of this talk.

00:15:30.506 --> 00:15:32.156
There are a few actions here

00:15:32.156 --> 00:15:33.466
that a customer can take while

00:15:33.466 --> 00:15:34.526
using our application.

00:15:35.036 --> 00:15:36.676
The first is they can add a

00:15:36.676 --> 00:15:38.826
single post to our database by

00:15:38.826 --> 00:15:39.746
hitting the + button.

00:15:40.786 --> 00:15:42.256
They can also download any

00:15:42.256 --> 00:15:44.546
pending data from the server by

00:15:44.546 --> 00:15:45.406
tapping Download.

00:15:50.716 --> 00:15:52.796
And, finally, for anything that

00:15:52.796 --> 00:15:53.966
hasn't yet been uploaded to a

00:15:53.966 --> 00:15:55.636
server, they can tap Post All.

00:15:56.596 --> 00:15:58.466
Now, this application has a

00:15:58.466 --> 00:16:00.416
fairly small set of interactions

00:16:00.416 --> 00:16:02.366
that a customer can take, and

00:16:02.366 --> 00:16:04.156
yet, as these happen

00:16:04.156 --> 00:16:06.936
concurrently, it tends towards

00:16:06.936 --> 00:16:07.516
chaos.

00:16:08.306 --> 00:16:11.536
So, we can see that even with

00:16:11.536 --> 00:16:12.936
this small set of actions,

00:16:13.596 --> 00:16:14.806
things that go on concurrently

00:16:14.806 --> 00:16:15.676
could cause a number of

00:16:15.676 --> 00:16:16.756
different state changes in the

00:16:16.756 --> 00:16:18.776
application and the worst thing

00:16:18.776 --> 00:16:20.436
for us is to end up with a user

00:16:20.436 --> 00:16:21.826
experience that looks like this.

00:16:22.696 --> 00:16:23.666
This notion of partial

00:16:23.666 --> 00:16:25.336
completeness doesn't make sense

00:16:25.336 --> 00:16:26.196
to our customers.

00:16:26.196 --> 00:16:27.466
In fact, it doesn't make sense

00:16:27.466 --> 00:16:28.156
to us either.

00:16:29.816 --> 00:16:30.836
Core Data is here to help with

00:16:30.886 --> 00:16:32.676
that with query generations.

00:16:33.066 --> 00:16:33.946
Query generations were

00:16:33.946 --> 00:16:36.556
introduced in 2016 in our What's

00:16:36.556 --> 00:16:37.656
New in Core Data session.

00:16:38.116 --> 00:16:39.076
So, if you're not yet familiar

00:16:39.076 --> 00:16:40.286
with them, I highly recommend

00:16:40.286 --> 00:16:41.516
that you check out that session

00:16:41.516 --> 00:16:42.806
for more information about how

00:16:42.806 --> 00:16:43.356
they work.

00:16:43.996 --> 00:16:45.626
What you do need to know is that

00:16:45.886 --> 00:16:47.506
they require wall journal mode

00:16:47.606 --> 00:16:48.786
and only work with SQLite.

00:16:49.906 --> 00:16:51.746
The goal of query generations is

00:16:51.746 --> 00:16:53.186
to isolate your managed object

00:16:53.186 --> 00:16:54.896
contexts from competing work.

00:16:55.346 --> 00:16:56.406
This could be rights to the

00:16:56.406 --> 00:16:58.566
background or actions that the

00:16:58.566 --> 00:17:00.176
user is taking that you're not

00:17:00.176 --> 00:17:02.326
yet ready to manifest in a given

00:17:02.326 --> 00:17:03.006
context.

00:17:04.026 --> 00:17:05.286
Query generations provide a

00:17:05.286 --> 00:17:07.026
consistent, durable view of the

00:17:07.026 --> 00:17:08.806
database that will return the

00:17:08.806 --> 00:17:10.435
same results for fetches

00:17:10.435 --> 00:17:11.606
regardless of what other

00:17:11.606 --> 00:17:12.806
contexts are writing to the

00:17:12.806 --> 00:17:14.165
database at a given time.

00:17:17.415 --> 00:17:19.695
The best part is we can adopt

00:17:19.695 --> 00:17:20.816
them in one line of code.

00:17:21.715 --> 00:17:23.116
This is a typical change for

00:17:23.116 --> 00:17:24.256
reloading a table view.

00:17:24.675 --> 00:17:26.626
We would just have to insert a

00:17:26.626 --> 00:17:28.496
call to NSManagedObjectContext

00:17:28.496 --> 00:17:30.256
setQueryGenerationFrom token

00:17:30.336 --> 00:17:31.276
with the current query

00:17:31.276 --> 00:17:31.966
generation.

00:17:33.456 --> 00:17:34.746
And when it comes time to update

00:17:34.746 --> 00:17:37.206
them, we can update them as we

00:17:37.206 --> 00:17:38.296
normally do by using

00:17:38.366 --> 00:17:40.056
NSMangedObjectContextDidSave

00:17:40.056 --> 00:17:40.766
notification.

00:17:41.236 --> 00:17:44.226
And this allows us to manifest

00:17:44.226 --> 00:17:45.806
changes to the application's

00:17:45.806 --> 00:17:47.866
data in the UI at the right

00:17:48.786 --> 00:17:48.876
time.

00:17:52.096 --> 00:17:53.536
But what if the data that we're

00:17:53.536 --> 00:17:54.986
writing isn't related to the UI,

00:17:55.676 --> 00:17:56.716
such as downloading some

00:17:56.716 --> 00:17:57.986
comments that Scott mentioned

00:17:57.986 --> 00:17:58.466
earlier?

00:17:59.556 --> 00:18:02.046
In this case, we don't want that

00:18:02.046 --> 00:18:03.406
data to manifest in the user

00:18:03.406 --> 00:18:05.716
interface or cause changes to it

00:18:05.716 --> 00:18:06.776
because none of the change will

00:18:06.776 --> 00:18:07.996
be visible to the user.

00:18:08.526 --> 00:18:09.876
So, we can actually filter out

00:18:09.876 --> 00:18:11.516
these updates by using history

00:18:11.516 --> 00:18:11.976
tracking.

00:18:12.786 --> 00:18:14.276
Persistent history tracking was

00:18:14.276 --> 00:18:17.456
new in iOS 11 and macOS 10.13.

00:18:18.206 --> 00:18:19.996
We introduced it in our session,

00:18:19.996 --> 00:18:22.036
What's New in Core Data, last

00:18:22.116 --> 00:18:23.526
year at WWDC, and for more

00:18:23.526 --> 00:18:24.866
information about how it works

00:18:24.866 --> 00:18:26.626
and what the underlying features

00:18:26.626 --> 00:18:27.866
are of it, you can use that

00:18:28.516 --> 00:18:29.566
session as a reference.

00:18:31.966 --> 00:18:33.406
Persistent history tracking is a

00:18:33.406 --> 00:18:35.526
great way to get a persistent

00:18:35.526 --> 00:18:37.086
record of each transaction that

00:18:37.086 --> 00:18:38.926
connects to the database and

00:18:38.926 --> 00:18:40.026
this is useful to us for a

00:18:40.026 --> 00:18:41.186
couple of different reasons.

00:18:41.756 --> 00:18:43.506
For the purposes of this talk,

00:18:43.506 --> 00:18:45.626
though, we'll be considering

00:18:45.796 --> 00:18:47.926
NSPersistentHistoryChange, which

00:18:48.576 --> 00:18:51.276
gives us a changedObjectID and a

00:18:51.276 --> 00:18:52.546
set of updatedProperties.

00:18:53.036 --> 00:18:53.176
And

00:18:53.296 --> 00:18:55.036
NSPersistentHistoryTransaction

00:18:55.686 --> 00:18:57.246
which gives us a set of changes

00:18:57.426 --> 00:18:59.136
and an objectIDNotification.

00:19:01.396 --> 00:19:05.176
So, let's consider the following

00:19:05.176 --> 00:19:06.036
set of changes.

00:19:06.776 --> 00:19:08.236
As you can see, these are posts

00:19:08.236 --> 00:19:09.376
that are being inserted to our

00:19:09.376 --> 00:19:12.436
database and when this happens,

00:19:12.806 --> 00:19:14.206
given our table view, we would

00:19:14.206 --> 00:19:17.046
want to refresh the UI, which we

00:19:17.046 --> 00:19:18.346
can do by using the

00:19:18.346 --> 00:19:19.726
objectIDNotification.

00:19:20.296 --> 00:19:21.356
These are analogous to

00:19:21.486 --> 00:19:23.316
NSManageObjectContextDidSave

00:19:23.316 --> 00:19:25.076
notifications and can be merged

00:19:25.076 --> 00:19:26.586
in using the same API.

00:19:29.756 --> 00:19:31.186
But if we downloaded a list of

00:19:31.186 --> 00:19:33.516
comments that we don't want to

00:19:33.516 --> 00:19:35.406
manifest in a user update for,

00:19:35.976 --> 00:19:39.936
we can filter them.

00:19:40.146 --> 00:19:41.556
Using this small amount of code,

00:19:41.616 --> 00:19:42.826
we can filter out the changes

00:19:42.826 --> 00:19:44.046
from a given transaction to

00:19:44.046 --> 00:19:45.086
decide if any of them were

00:19:45.086 --> 00:19:47.306
relevant to the post entity and

00:19:48.876 --> 00:19:50.916
in that way we won't refresh the

00:19:50.916 --> 00:19:53.876
UI and cause an unnecessary blip

00:19:53.976 --> 00:19:55.276
or stutter to the user.

00:19:56.256 --> 00:19:57.436
But as you can see here, we're

00:19:57.436 --> 00:19:58.906
actually only using a small

00:19:58.906 --> 00:20:00.496
amount of the post content.

00:20:01.246 --> 00:20:03.276
In fact, we're only using two

00:20:03.276 --> 00:20:05.536
properties, the image and the

00:20:05.536 --> 00:20:05.906
title.

00:20:07.406 --> 00:20:08.606
And so we can do better than

00:20:08.606 --> 00:20:10.126
just filtering out by entity.

00:20:10.416 --> 00:20:12.216
We can actually filter out by

00:20:12.216 --> 00:20:13.606
updated properties using the

00:20:13.606 --> 00:20:15.756
history changes and in this way

00:20:15.756 --> 00:20:17.416
we can create highly-targeted

00:20:17.416 --> 00:20:19.026
updates to our user experience

00:20:19.476 --> 00:20:20.666
that align with changes that

00:20:20.666 --> 00:20:21.916
will be visible to them.

00:20:22.546 --> 00:20:27.526
But Core Data can also help you

00:20:28.146 --> 00:20:29.846
support new interactions for

00:20:29.846 --> 00:20:30.446
your users.

00:20:31.336 --> 00:20:32.446
As your data becomes more

00:20:32.446 --> 00:20:35.216
complex and grows in scale, some

00:20:35.216 --> 00:20:36.756
editing operations can get more

00:20:36.756 --> 00:20:37.346
expensive.

00:20:37.346 --> 00:20:39.546
For example, consider a simple

00:20:39.546 --> 00:20:40.466
photos browser.

00:20:41.206 --> 00:20:42.796
Typically, when our applications

00:20:42.796 --> 00:20:44.386
grow, we want to -- we want to

00:20:44.386 --> 00:20:45.976
introduce new functionality that

00:20:45.976 --> 00:20:47.276
makes it easier to perform

00:20:47.276 --> 00:20:49.036
repetitive tasks, such as

00:20:49.116 --> 00:20:50.136
multiple selection.

00:20:50.506 --> 00:20:53.236
And Core Data can support this

00:20:53.266 --> 00:20:54.826
by using batch operations.

00:20:55.976 --> 00:20:57.946
In fact, in just a couple lines

00:20:57.946 --> 00:20:59.436
of code we can mark an entire

00:20:59.436 --> 00:21:01.946
set of photos as a favorite or

00:21:02.726 --> 00:21:02.826
not.

00:21:03.596 --> 00:21:05.376
And in just one line of code, we

00:21:05.376 --> 00:21:07.046
can purge or delete a set of

00:21:07.046 --> 00:21:08.416
records from the database using

00:21:08.416 --> 00:21:09.706
a batch delete operation.

00:21:09.976 --> 00:21:12.256
And these operations scale in

00:21:12.256 --> 00:21:13.646
ways that aren't possible by

00:21:13.646 --> 00:21:14.716
faulting the objects into

00:21:14.716 --> 00:21:15.096
memory.

00:21:15.886 --> 00:21:18.116
For example, during a delete, a

00:21:18.116 --> 00:21:19.556
traditional delete by calling

00:21:19.556 --> 00:21:22.306
NSManagedObject.delete will grow

00:21:22.446 --> 00:21:23.776
with the size of the records in

00:21:23.776 --> 00:21:24.836
the database.

00:21:24.906 --> 00:21:26.116
And as you delete objects and

00:21:26.116 --> 00:21:27.336
their memory gets faulted into

00:21:27.336 --> 00:21:29.436
the context, this gets more and

00:21:29.436 --> 00:21:31.136
more expensive the larger your

00:21:31.136 --> 00:21:32.086
database gets.

00:21:32.716 --> 00:21:34.036
But with batch operations, we

00:21:34.036 --> 00:21:36.106
can perform the same mutations

00:21:36.106 --> 00:21:37.196
in just a fraction of the

00:21:37.196 --> 00:21:37.706
memory.

00:21:38.276 --> 00:21:39.716
And this has the curve that we

00:21:39.716 --> 00:21:42.756
want as data increases, where

00:21:42.756 --> 00:21:44.626
the larger the data set is, the

00:21:44.626 --> 00:21:46.976
less memory we use, using up to

00:21:46.976 --> 00:21:48.696
about 7% of the memory of a

00:21:48.696 --> 00:21:50.606
traditional delete at 10 million

00:21:50.606 --> 00:21:51.156
rows.

00:21:52.556 --> 00:21:54.076
So, this is a very powerful way

00:21:54.076 --> 00:21:55.296
to save resources on your

00:21:55.296 --> 00:21:57.066
customer's device.

00:21:57.956 --> 00:21:59.176
But one of the traditional

00:21:59.176 --> 00:22:00.976
problems with batch operations

00:22:01.596 --> 00:22:02.776
is that they were difficult to

00:22:02.776 --> 00:22:03.926
work with because they don't

00:22:03.926 --> 00:22:05.606
generate save notifications.

00:22:06.376 --> 00:22:07.426
That's where history tracking

00:22:07.426 --> 00:22:08.176
comes back in.

00:22:09.026 --> 00:22:10.016
With persistent history

00:22:10.016 --> 00:22:11.306
tracking, we can fetch out the

00:22:11.306 --> 00:22:12.846
transactions from the database

00:22:13.286 --> 00:22:14.266
that occurred as part of the

00:22:14.266 --> 00:22:17.156
batch delete or update and we

00:22:17.156 --> 00:22:18.996
can use the objectIDNotification

00:22:18.996 --> 00:22:20.276
method to generate a

00:22:20.276 --> 00:22:21.676
notification that works like a

00:22:21.676 --> 00:22:22.866
save notification.

00:22:23.386 --> 00:22:24.786
In this way, the fetched results

00:22:24.786 --> 00:22:26.666
controller or any other context

00:22:26.666 --> 00:22:28.846
in your application can update

00:22:28.846 --> 00:22:29.846
to those notifications

00:22:29.846 --> 00:22:30.656
incrementally.

00:22:31.226 --> 00:22:35.546
And so those are some ways you

00:22:35.546 --> 00:22:37.016
can manage growing data with

00:22:37.016 --> 00:22:39.456
Core Data, but how about your

00:22:39.456 --> 00:22:40.586
workflow itself?

00:22:40.966 --> 00:22:43.396
What can Core Data do for you as

00:22:43.396 --> 00:22:45.426
a developer and engineer to make

00:22:45.426 --> 00:22:46.886
it easier to build and test your

00:22:46.886 --> 00:22:47.726
applications?

00:22:49.166 --> 00:22:51.136
The first thing is that we can

00:22:51.136 --> 00:22:52.286
help future you today.

00:22:53.856 --> 00:22:55.576
As you may know, NSKeyedArchiver

00:22:55.576 --> 00:22:56.326
is changing.

00:22:57.056 --> 00:22:58.416
We're adopting secure coding

00:22:58.416 --> 00:23:00.926
across the entire platform and

00:23:01.016 --> 00:23:03.146
the KeyedArchiver API has

00:23:03.146 --> 00:23:04.596
changed significantly this year

00:23:04.596 --> 00:23:05.436
in support of that.

00:23:06.496 --> 00:23:07.786
For Core Data, this means that

00:23:07.786 --> 00:23:09.586
value transformers are changing,

00:23:09.586 --> 00:23:11.066
so if you have a transformable

00:23:11.066 --> 00:23:13.086
property in your managed object

00:23:13.086 --> 00:23:14.916
model and you're not sending a

00:23:14.916 --> 00:23:16.876
value transformer today, you

00:23:16.876 --> 00:23:17.836
used to be getting

00:23:18.036 --> 00:23:18.946
NSKeyedUnarchive

00:23:18.946 --> 00:23:20.696
FromDataTransformer as your

00:23:20.936 --> 00:23:22.316
default value transformer.

00:23:22.916 --> 00:23:24.446
In the future, you'll be getting

00:23:24.676 --> 00:23:25.616
NSSecureUnarchive

00:23:25.736 --> 00:23:28.196
FromDataTransformer and this

00:23:28.196 --> 00:23:29.496
implements secure coding under

00:23:29.496 --> 00:23:31.016
the covers and you should adopt

00:23:31.016 --> 00:23:31.576
it today.

00:23:32.176 --> 00:23:33.416
There was a great talk this

00:23:33.416 --> 00:23:35.496
morning about exactly this topic

00:23:36.976 --> 00:23:38.216
called the Data You Can Trust

00:23:38.636 --> 00:23:40.006
and I highly recommend that you

00:23:40.006 --> 00:23:41.666
view it to get more information

00:23:41.666 --> 00:23:43.496
about secure coding and how to

00:23:43.496 --> 00:23:44.706
make your applications more

00:23:44.706 --> 00:23:45.146
resilient.

00:23:48.246 --> 00:23:49.356
You can specify this in the

00:23:49.356 --> 00:23:50.266
model editor with a

00:23:50.266 --> 00:23:52.976
transformable property by the

00:23:52.976 --> 00:23:54.766
value transformer name field.

00:23:55.716 --> 00:23:57.486
And today, we want you to

00:23:57.486 --> 00:23:59.676
implement this on your own.

00:24:00.146 --> 00:24:01.566
This will become the default in

00:24:01.566 --> 00:24:03.506
a future release and in a future

00:24:03.506 --> 00:24:04.986
release Xcode will also start

00:24:04.986 --> 00:24:06.266
emitting a warning for anyone

00:24:06.266 --> 00:24:07.886
that's using the default value

00:24:07.886 --> 00:24:08.706
transformer name.

00:24:10.036 --> 00:24:10.956
If you're building your models

00:24:10.956 --> 00:24:13.056
in code, you can set it by using

00:24:13.056 --> 00:24:14.146
the valueTransformerName

00:24:14.146 --> 00:24:15.996
property on NSAttribute

00:24:15.996 --> 00:24:16.416
description.

00:24:17.726 --> 00:24:19.046
This should be transparent for

00:24:19.046 --> 00:24:21.176
you if you're not encoding

00:24:21.176 --> 00:24:22.256
custom class types.

00:24:22.296 --> 00:24:23.926
So, for plist types, this is a

00:24:23.926 --> 00:24:24.306
no op.

00:24:24.756 --> 00:24:25.806
You simply change the value

00:24:25.806 --> 00:24:27.336
transformer name and you'll get

00:24:27.336 --> 00:24:28.726
the new secure coding behavior.

00:24:29.286 --> 00:24:30.856
However, if you are implementing

00:24:30.856 --> 00:24:32.456
custom classes, those classes

00:24:32.456 --> 00:24:34.786
need to adopt secure coding and

00:24:34.846 --> 00:24:36.276
you can come see us in the labs

00:24:36.276 --> 00:24:37.616
for help with that.

00:24:38.296 --> 00:24:40.486
But we can help you more.

00:24:41.286 --> 00:24:42.866
At Core Data, we've spent time

00:24:43.066 --> 00:24:44.726
building in new debugging tools

00:24:45.026 --> 00:24:46.566
over the years that can help you

00:24:46.566 --> 00:24:47.796
understand what's going on under

00:24:47.796 --> 00:24:48.236
the stack.

00:24:49.026 --> 00:24:50.216
So, this is a picture of our

00:24:50.216 --> 00:24:51.666
preferred default scheme

00:24:51.666 --> 00:24:52.536
configuration.

00:24:52.866 --> 00:24:54.686
We have a couple of process

00:24:54.686 --> 00:24:56.396
arguments that we have that can

00:24:56.396 --> 00:24:57.386
help you get more debugging

00:24:57.386 --> 00:24:59.416
information about SQLite, but

00:24:59.416 --> 00:25:00.746
the big one you should always

00:25:00.746 --> 00:25:02.566
run with is com.apple.Core

00:25:02.566 --> 00:25:04.066
Data.ConcurrencyDebug.

00:25:04.616 --> 00:25:06.266
And this will catch any queue

00:25:06.266 --> 00:25:07.746
exceptions in your applications,

00:25:07.746 --> 00:25:09.396
so areas that you may be

00:25:09.396 --> 00:25:10.766
transferring objects between

00:25:10.766 --> 00:25:11.926
main and background queue

00:25:11.926 --> 00:25:14.066
contexts or areas that you may

00:25:14.066 --> 00:25:15.566
not be obeying a managed

00:25:15.566 --> 00:25:18.666
object's actual context.

00:25:18.746 --> 00:25:20.466
SQLite also has a number of

00:25:20.466 --> 00:25:21.506
interesting environment

00:25:21.506 --> 00:25:23.206
variables, so their threading

00:25:23.206 --> 00:25:24.756
and file assertions are a great

00:25:24.756 --> 00:25:25.836
way to ensure you have

00:25:25.836 --> 00:25:27.286
correctness in your application

00:25:27.286 --> 00:25:29.016
around their API as well as the

00:25:29.016 --> 00:25:29.746
file system.

00:25:30.576 --> 00:25:32.386
And auto tracing is a great way

00:25:32.386 --> 00:25:33.496
for you to see what's going on

00:25:33.496 --> 00:25:34.826
under the covers, an additional

00:25:34.826 --> 00:25:36.046
tour on debug logging.

00:25:36.856 --> 00:25:39.646
com.apple.Core Data.SQLDebug has

00:25:39.646 --> 00:25:40.676
four levels.

00:25:41.106 --> 00:25:43.206
The first level is the most

00:25:43.206 --> 00:25:44.636
interesting and the least of a

00:25:44.636 --> 00:25:45.466
performance hit.

00:25:45.466 --> 00:25:47.826
The fourth level is the most

00:25:47.826 --> 00:25:49.126
verbose, but does cause

00:25:49.126 --> 00:25:51.006
significant performance hit when

00:25:51.006 --> 00:25:53.726
you run with it.

00:25:53.996 --> 00:25:55.696
When you enable SQL debugging

00:25:55.806 --> 00:25:57.146
and our multi-threading

00:25:57.146 --> 00:25:58.476
assertions, you'll see a couple

00:25:58.506 --> 00:26:00.456
of logs in the console and these

00:26:00.456 --> 00:26:01.356
are the indication that the

00:26:01.356 --> 00:26:02.526
assertions are enabled and

00:26:02.526 --> 00:26:03.366
running correctly.

00:26:04.636 --> 00:26:06.076
With our SQL debugging on,

00:26:06.076 --> 00:26:07.456
you'll be able to see things

00:26:07.456 --> 00:26:08.656
like select statements for our

00:26:08.656 --> 00:26:10.156
fetch requests as well as how

00:26:10.156 --> 00:26:10.866
long they took.

00:26:11.706 --> 00:26:13.016
And, if you're set to level

00:26:13.016 --> 00:26:14.766
four, you'll even get explain,

00:26:15.026 --> 00:26:16.056
which will show you the query

00:26:16.056 --> 00:26:17.836
plan for a given select

00:26:18.186 --> 00:26:19.016
statement.

00:26:19.586 --> 00:26:20.936
And here we can see that our

00:26:20.936 --> 00:26:23.786
table view is selected via table

00:26:23.786 --> 00:26:25.856
scan and then using a temporary

00:26:25.856 --> 00:26:27.866
B-tree in memory for the order

00:26:27.866 --> 00:26:29.646
by, which is on the timestamp.

00:26:30.536 --> 00:26:31.876
This is a potential performance

00:26:31.876 --> 00:26:33.766
problem and as you're running

00:26:33.766 --> 00:26:35.006
your application you can use

00:26:35.006 --> 00:26:37.116
messages like this to see where

00:26:37.116 --> 00:26:38.506
you may be doing more work than

00:26:38.506 --> 00:26:39.086
you need to.

00:26:40.346 --> 00:26:41.496
So, how would we fix this?

00:26:42.946 --> 00:26:45.816
Well, turns out SQLite 3 can

00:26:45.816 --> 00:26:46.776
actually tell us.

00:26:47.476 --> 00:26:49.166
If we open a database and hand

00:26:49.166 --> 00:26:50.696
it the select query from our SQL

00:26:50.696 --> 00:26:52.926
logs, we can enable a mode

00:26:52.926 --> 00:26:54.616
called Expert, which will

00:26:54.616 --> 00:26:56.396
analyze the query and give us

00:26:56.436 --> 00:26:58.616
the ideal solution of optimizing

00:26:58.616 --> 00:27:00.366
it by creating a covering index.

00:27:01.366 --> 00:27:02.606
And we can do this in the model

00:27:02.606 --> 00:27:05.256
editor by adding a fetch index

00:27:05.576 --> 00:27:06.416
to our post entity.

00:27:07.066 --> 00:27:08.416
Here I've configured it to run

00:27:08.416 --> 00:27:10.216
on the timestamp and fetch them

00:27:10.216 --> 00:27:12.676
out in descending order because

00:27:12.676 --> 00:27:13.786
we're showing the most recent

00:27:13.786 --> 00:27:15.306
posts at the top of the table

00:27:15.306 --> 00:27:15.526
view.

00:27:17.676 --> 00:27:19.106
When we run the application

00:27:19.106 --> 00:27:20.586
again, we see the same select

00:27:20.586 --> 00:27:20.976
logs.

00:27:24.386 --> 00:27:26.546
Except that this time we see

00:27:26.546 --> 00:27:27.876
that the select query hits the

00:27:27.876 --> 00:27:29.616
covering index during the query.

00:27:30.126 --> 00:27:31.726
Explain shows us that the query

00:27:31.726 --> 00:27:33.746
will use the covering index for

00:27:33.746 --> 00:27:38.296
its order by.

00:27:38.536 --> 00:27:39.966
Core Data supports many types of

00:27:39.966 --> 00:27:41.696
indexing, including compound

00:27:41.696 --> 00:27:43.356
indexes using R-trees.

00:27:43.906 --> 00:27:45.646
And these are great for creating

00:27:45.646 --> 00:27:47.346
any kind of query or optimizing

00:27:47.346 --> 00:27:49.806
a query that uses a bounding box

00:27:50.406 --> 00:27:51.536
in its select statement.

00:27:52.196 --> 00:27:53.386
This is most commonly done with

00:27:53.426 --> 00:27:55.216
locations and we can set this up

00:27:55.216 --> 00:27:57.396
by adding another index to our

00:27:57.396 --> 00:27:58.876
post entity, which works in the

00:27:58.876 --> 00:28:00.396
latitude and longitude property

00:28:00.396 --> 00:28:02.046
that I added for the purposes of

00:28:02.046 --> 00:28:02.536
this slide.

00:28:04.816 --> 00:28:06.836
We change the query type in this

00:28:06.836 --> 00:28:08.246
box by selecting R-tree.

00:28:08.796 --> 00:28:10.836
And then we can set up our

00:28:10.836 --> 00:28:12.556
predicate on the fetch request

00:28:13.206 --> 00:28:14.906
to say get all of the posts that

00:28:14.906 --> 00:28:16.136
happen inside of continental

00:28:16.136 --> 00:28:16.516
China.

00:28:18.406 --> 00:28:20.186
This predicate is a little more

00:28:20.186 --> 00:28:21.656
advanced because it uses

00:28:21.716 --> 00:28:24.306
functions inside the actual

00:28:24.306 --> 00:28:26.256
select statement to hit the

00:28:26.256 --> 00:28:27.676
index that we created in the

00:28:27.676 --> 00:28:28.676
managed object model.

00:28:31.556 --> 00:28:33.266
When we run our application

00:28:33.266 --> 00:28:35.016
without this predicate and

00:28:35.016 --> 00:28:36.596
without this index, we see the

00:28:36.596 --> 00:28:38.266
same results that we saw before

00:28:38.726 --> 00:28:40.696
where we're hitting only the

00:28:40.696 --> 00:28:41.826
timestamp index.

00:28:42.366 --> 00:28:44.956
But when we run it with our new

00:28:44.956 --> 00:28:47.196
index and predicate, we see that

00:28:47.196 --> 00:28:48.956
SQLite is using the index to

00:28:48.956 --> 00:28:51.626
generate faster results for both

00:28:51.626 --> 00:28:53.056
of the between statements.

00:28:55.026 --> 00:28:56.806
Unfortunately, because our

00:28:56.806 --> 00:28:58.446
timestamp index doesn't have any

00:28:58.446 --> 00:28:59.656
bounding predicates on it,

00:28:59.976 --> 00:29:01.566
SQLite can't use it for the

00:29:01.566 --> 00:29:02.006
sort.

00:29:02.556 --> 00:29:04.776
So, the optimization that we've

00:29:04.776 --> 00:29:07.216
chosen here is to use a compound

00:29:07.216 --> 00:29:08.636
index to first filter out the

00:29:08.636 --> 00:29:10.166
result set to a smaller set of

00:29:10.166 --> 00:29:11.676
objects and then we'll do an

00:29:11.676 --> 00:29:13.276
in-memory B-tree sort for the

00:29:13.276 --> 00:29:13.736
order by.

00:29:14.336 --> 00:29:18.536
As you can see, this index

00:29:18.536 --> 00:29:20.186
increases the performance of our

00:29:20.186 --> 00:29:22.286
fetch by about 25%.

00:29:23.986 --> 00:29:25.256
In this case, my performance

00:29:25.256 --> 00:29:27.066
test was run over a size of

00:29:27.066 --> 00:29:29.726
about 100,000 rows and we saw

00:29:29.726 --> 00:29:31.616
around 130 milliseconds of

00:29:31.616 --> 00:29:33.036
improvement for just the fetch.

00:29:34.476 --> 00:29:35.876
Which brings me to my next topic

00:29:36.196 --> 00:29:37.466
of testing with Core Data.

00:29:38.646 --> 00:29:40.716
As you may know, we really like

00:29:40.716 --> 00:29:41.086
tests.

00:29:41.656 --> 00:29:42.476
Tests are awesome.

00:29:43.026 --> 00:29:45.156
And, at Core Data, we use them

00:29:45.156 --> 00:29:46.686
internally for both correctness

00:29:46.686 --> 00:29:48.476
as well as learning.

00:29:48.906 --> 00:29:49.826
They're a great way to learn

00:29:49.826 --> 00:29:51.026
about the functionality of Core

00:29:51.026 --> 00:29:52.846
Data and how our API behaves

00:29:52.846 --> 00:29:54.406
under a given set of conditions.

00:29:55.316 --> 00:29:56.326
They're also a great way to

00:29:56.326 --> 00:29:58.876
verify your assumptions about

00:29:58.986 --> 00:30:00.806
how Core Data works and how it's

00:30:00.806 --> 00:30:01.856
going to help your customers

00:30:01.856 --> 00:30:02.916
have a better experience with

00:30:02.916 --> 00:30:03.716
your application.

00:30:04.266 --> 00:30:05.316
As you saw in the previous

00:30:05.316 --> 00:30:06.916
example, we can verify that our

00:30:06.916 --> 00:30:08.966
R-tree index actually does give

00:30:08.966 --> 00:30:10.456
us a performance benefit even

00:30:10.456 --> 00:30:11.466
though it's using an in-memory

00:30:11.466 --> 00:30:12.186
B-tree sort.

00:30:14.276 --> 00:30:16.136
They also capture your product

00:30:16.136 --> 00:30:17.686
requirements, and this is really

00:30:17.686 --> 00:30:19.456
important to us at Core Data

00:30:19.456 --> 00:30:20.896
because it helps us communicate

00:30:20.896 --> 00:30:22.296
around your expectations.

00:30:22.786 --> 00:30:24.026
With tests, we can see what

00:30:24.026 --> 00:30:25.566
you're doing in code and how you

00:30:25.566 --> 00:30:27.296
expect those lines of code to

00:30:27.296 --> 00:30:28.546
behave for your customers.

00:30:29.686 --> 00:30:30.816
There are some important things

00:30:30.816 --> 00:30:31.976
that you can set up to make this

00:30:31.976 --> 00:30:34.166
easy for yourself, such as a

00:30:34.166 --> 00:30:36.196
base class that generates a

00:30:36.196 --> 00:30:37.236
persistent container.

00:30:38.406 --> 00:30:39.926
This base class on the screen

00:30:39.926 --> 00:30:41.856
happens to use a file URL of

00:30:41.856 --> 00:30:43.426
/dev/null for the persistent

00:30:43.426 --> 00:30:45.316
store and this is a great way of

00:30:45.316 --> 00:30:46.636
making tests that operate on a

00:30:46.636 --> 00:30:48.506
small set of managed objects run

00:30:48.506 --> 00:30:50.446
very, very quickly because

00:30:50.446 --> 00:30:52.076
they'll run entirely in memory.

00:30:52.776 --> 00:30:54.726
When you do this, SQLite

00:30:54.726 --> 00:30:56.306
materializes an in-memory store

00:30:56.306 --> 00:30:57.866
for you that can be very

00:30:57.866 --> 00:30:59.596
efficient, but because it's in

00:30:59.596 --> 00:31:00.756
memory, if you have a lot of

00:31:00.756 --> 00:31:02.186
data, this will cause a lot of

00:31:02.186 --> 00:31:03.536
memory growth in your test

00:31:03.976 --> 00:31:04.146
suite.

00:31:07.616 --> 00:31:09.476
You should have at least one

00:31:10.076 --> 00:31:11.676
test, though, that actually

00:31:11.676 --> 00:31:13.146
materializes your store file on

00:31:13.146 --> 00:31:13.506
disk.

00:31:14.026 --> 00:31:15.746
And this is because if you can't

00:31:15.746 --> 00:31:16.806
open your store for your test

00:31:16.806 --> 00:31:18.316
suite, it's highly likely that

00:31:18.316 --> 00:31:19.436
your customer can't either.

00:31:21.076 --> 00:31:22.546
If your persistent container is

00:31:22.546 --> 00:31:24.156
in the application delegate, you

00:31:24.156 --> 00:31:25.506
can have a test base class that

00:31:25.506 --> 00:31:26.866
grabs the container out and

00:31:26.866 --> 00:31:28.506
writes directly to that store.

00:31:29.296 --> 00:31:31.496
But I must caution you to take

00:31:31.496 --> 00:31:33.086
care when you do this, because

00:31:33.086 --> 00:31:34.106
that means that you're writing

00:31:34.106 --> 00:31:35.566
to the store file that's in use

00:31:35.566 --> 00:31:37.776
by the application, so if you

00:31:37.776 --> 00:31:38.916
run your test on a personal

00:31:38.916 --> 00:31:40.646
device, you'll see the effects

00:31:40.646 --> 00:31:42.006
of the unit test when you open

00:31:42.006 --> 00:31:47.316
your application the next time.

00:31:47.536 --> 00:31:48.446
What if I told you I could

00:31:48.446 --> 00:31:50.316
insert 100,000 records in just

00:31:50.316 --> 00:31:51.236
seven lines of code?

00:31:53.806 --> 00:31:55.036
I'm cheating a little bit.

00:31:55.036 --> 00:31:56.356
I was going to leave this as an

00:31:56.356 --> 00:31:58.556
exercise to the reader, but this

00:31:58.556 --> 00:31:59.946
type of scaffolding is a great

00:31:59.946 --> 00:32:01.306
way to help you build a test

00:32:01.306 --> 00:32:02.556
suite that evaluates your

00:32:02.556 --> 00:32:04.016
invariance around your data.

00:32:04.976 --> 00:32:06.386
By building these methods ahead

00:32:06.386 --> 00:32:08.496
of time, as your data changes or

00:32:08.496 --> 00:32:09.876
you become aware of new use

00:32:09.876 --> 00:32:11.626
cases for your application, you

00:32:11.626 --> 00:32:13.486
can iterate on these to build

00:32:13.486 --> 00:32:14.756
new edge cases, build new

00:32:14.756 --> 00:32:15.826
structures for your object

00:32:15.826 --> 00:32:17.946
graph, or evaluate the behavior

00:32:17.946 --> 00:32:19.186
of certain functionality under

00:32:19.186 --> 00:32:21.776
the covers, such as performance.

00:32:22.146 --> 00:32:25.606
This is the unit test scaffold

00:32:25.606 --> 00:32:26.566
that I used to build a

00:32:26.566 --> 00:32:28.046
performance test for the R-tree

00:32:28.046 --> 00:32:28.466
query.

00:32:29.176 --> 00:32:30.496
In just a handful of lines of

00:32:30.496 --> 00:32:32.456
code, we get high confidence on

00:32:32.456 --> 00:32:33.886
the performance of our fetch.

00:32:34.836 --> 00:32:36.286
And these types of tests are

00:32:36.286 --> 00:32:37.466
very informative when you're

00:32:37.466 --> 00:32:38.996
trying to evaluate tradeoffs

00:32:38.996 --> 00:32:40.386
between different features and

00:32:40.386 --> 00:32:44.896
functionality in Core Data.

00:32:45.316 --> 00:32:46.576
These three lines of code

00:32:46.576 --> 00:32:47.936
generate a new managed object

00:32:47.936 --> 00:32:49.976
context and container for us for

00:32:49.976 --> 00:32:50.946
our test to use.

00:32:51.756 --> 00:32:54.206
Now, this is important primarily

00:32:54.206 --> 00:32:55.606
because the setup and teardown

00:32:55.606 --> 00:32:57.786
logic in tests can sometimes

00:32:57.786 --> 00:32:59.066
affect their performance.

00:32:59.696 --> 00:33:01.196
So, you'll need to take care to

00:33:01.196 --> 00:33:02.836
analyze whether or not you're

00:33:02.836 --> 00:33:04.226
actually testing the teardown

00:33:04.226 --> 00:33:05.256
performance or the setup

00:33:05.256 --> 00:33:06.946
performance or the actual

00:33:06.946 --> 00:33:08.216
runtime performance of the

00:33:08.216 --> 00:33:09.626
queries you're evaluating.

00:33:10.556 --> 00:33:11.546
And after you've run these

00:33:11.546 --> 00:33:14.046
tests, you can file good bugs.

00:33:15.526 --> 00:33:17.346
We love bugs, especially from

00:33:17.346 --> 00:33:18.546
you guys because we're building

00:33:18.546 --> 00:33:19.796
a product to help you build your

00:33:19.796 --> 00:33:20.606
applications.

00:33:21.206 --> 00:33:24.176
But, bug reports without tests

00:33:24.176 --> 00:33:25.426
or without a sample application

00:33:25.426 --> 00:33:26.486
are very hard for us to

00:33:26.486 --> 00:33:28.126
communicate around because, as I

00:33:28.126 --> 00:33:29.906
mentioned earlier, they don't

00:33:29.906 --> 00:33:30.696
capture your product

00:33:30.696 --> 00:33:32.196
requirements and expectations in

00:33:32.196 --> 00:33:33.046
the same way that

00:33:33.046 --> 00:33:34.396
well-structured tests do.

00:33:35.206 --> 00:33:37.366
In fact, in an application

00:33:37.956 --> 00:33:39.716
attached to our radar that has a

00:33:39.716 --> 00:33:41.756
test suite or even just a bare

00:33:41.756 --> 00:33:43.526
sample application with some UI

00:33:44.086 --> 00:33:46.186
that explains your constraints

00:33:46.406 --> 00:33:48.436
and concerns to us, we can get

00:33:48.436 --> 00:33:50.076
back to you much more rapidly

00:33:50.236 --> 00:33:51.886
about what's going on and what

00:33:51.886 --> 00:33:52.706
you should do about it.

00:33:53.596 --> 00:33:55.106
They also help us verify the

00:33:55.106 --> 00:33:56.616
correctness of our fixes later.

00:33:57.066 --> 00:33:58.226
So, if you're going to file a

00:33:58.226 --> 00:34:00.806
bug, please take some time and

00:34:00.806 --> 00:34:02.266
write a test for us.

00:34:04.296 --> 00:34:05.476
That's all I have today.

00:34:05.956 --> 00:34:08.156
Come see us at lab tomorrow.

00:34:08.335 --> 00:34:10.946
We are here from 1:30 on in

00:34:10.946 --> 00:34:13.315
Technology Lab 7 and I highly

00:34:13.315 --> 00:34:14.286
recommend that you check out

00:34:14.286 --> 00:34:15.826
Testing Tips and Tricks tomorrow

00:34:15.826 --> 00:34:17.585
in Hall 2 at 3:20.

00:34:18.896 --> 00:34:19.906
Thanks.

00:34:20.507 --> 00:34:22.507
[ Applause ]
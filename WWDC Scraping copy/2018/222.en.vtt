WEBVTT

00:00:07.516 --> 00:00:14.500
[ Music ]

00:00:22.516 --> 00:00:27.876
[ Applause ]

00:00:28.376 --> 00:00:29.146
>> Good morning, everyone.

00:00:30.056 --> 00:00:30.976
Thank you all for joining me,

00:00:31.116 --> 00:00:32.256
even before the coffee's kicked

00:00:32.256 --> 00:00:32.466
in.

00:00:33.286 --> 00:00:34.696
My name is Itai and I work on

00:00:34.696 --> 00:00:35.456
the foundation team.

00:00:36.676 --> 00:00:37.556
In this session, I'd like to

00:00:37.556 --> 00:00:39.106
talk to you about how the data

00:00:39.106 --> 00:00:40.246
that flows through your app can

00:00:40.246 --> 00:00:41.916
affect it, and how you can

00:00:41.916 --> 00:00:43.336
better protect your customers by

00:00:43.336 --> 00:00:44.806
building trust in that data.

00:00:45.926 --> 00:00:46.526
Let's get started.

00:00:47.116 --> 00:00:49.696
Apps don't live in a vacuum.

00:00:50.536 --> 00:00:51.546
In order for your apps to do

00:00:51.546 --> 00:00:52.946
something useful, they have to

00:00:52.946 --> 00:00:54.286
draw in data from external

00:00:54.286 --> 00:00:55.686
sources, like the disc, or the

00:00:55.686 --> 00:00:56.846
network, or your customers

00:00:56.846 --> 00:00:57.416
themselves.

00:00:57.956 --> 00:00:59.156
And then do something meaningful

00:00:59.156 --> 00:01:00.656
with that data, and then present

00:01:00.656 --> 00:01:01.466
it to your customers.

00:01:02.886 --> 00:01:04.006
In order for that data to be

00:01:04.226 --> 00:01:05.856
consumable, it has to come in

00:01:05.856 --> 00:01:07.416
some known format or structure.

00:01:08.756 --> 00:01:11.796
What happens when it doesn't?

00:01:11.886 --> 00:01:13.776
Usually, this means the data is

00:01:13.776 --> 00:01:15.326
corrupted, or invalid in some

00:01:15.326 --> 00:01:16.196
way and can be ignored.

00:01:17.566 --> 00:01:19.486
But sometimes, this data can

00:01:19.856 --> 00:01:21.296
invalidate assumptions that your

00:01:21.296 --> 00:01:23.346
app makes, and it can cause your

00:01:23.346 --> 00:01:25.326
app to misbehave, or maybe even

00:01:25.326 --> 00:01:25.746
crash.

00:01:26.386 --> 00:01:29.126
This can be a bad experience for

00:01:29.126 --> 00:01:30.506
your customers who might have to

00:01:30.506 --> 00:01:32.056
wait for your app to get updated

00:01:32.056 --> 00:01:32.706
in the app store.

00:01:33.566 --> 00:01:34.556
And it's an even worse

00:01:34.556 --> 00:01:36.076
experience if it's a crash on

00:01:36.076 --> 00:01:37.436
launch, because they can't even

00:01:37.436 --> 00:01:38.076
use the app.

00:01:38.666 --> 00:01:39.896
And, in the meantime, while

00:01:39.896 --> 00:01:41.176
you're waiting, you'll get a

00:01:41.176 --> 00:01:42.386
wave of one-star reviews.

00:01:43.126 --> 00:01:43.996
It's a bad experience for

00:01:43.996 --> 00:01:44.306
everyone.

00:01:46.136 --> 00:01:47.386
This is something to be even

00:01:47.386 --> 00:01:48.736
more cognizant of, if you're a

00:01:48.736 --> 00:01:49.486
framework author.

00:01:50.056 --> 00:01:51.356
Because it's not just one app

00:01:51.486 --> 00:01:52.706
that could possibly be affected,

00:01:53.026 --> 00:01:54.776
but maybe many apps.

00:01:56.416 --> 00:01:57.626
Today, we're going to be talking

00:01:57.626 --> 00:01:58.276
about trust.

00:01:59.186 --> 00:02:00.236
And specifically, we're going to

00:02:00.236 --> 00:02:02.026
be talking about how to build

00:02:02.026 --> 00:02:03.886
trust in data, by making sure of

00:02:03.886 --> 00:02:04.406
two things.

00:02:05.796 --> 00:02:07.026
One, that the data that we're

00:02:07.026 --> 00:02:08.166
going to be using, hasn't been

00:02:08.166 --> 00:02:10.726
modified from underneath us, and

00:02:10.726 --> 00:02:12.266
two that it contains what we

00:02:12.266 --> 00:02:14.236
expect it to in the format and

00:02:14.236 --> 00:02:15.066
structure that we want.

00:02:16.676 --> 00:02:19.266
So, we'll do just that by taking

00:02:19.266 --> 00:02:20.816
a look at the lifecycle of our

00:02:20.816 --> 00:02:22.786
data, and what we can validate

00:02:22.786 --> 00:02:24.526
about that data at every stage

00:02:24.526 --> 00:02:25.146
in the lifecycle.

00:02:26.726 --> 00:02:28.836
Then, we'll see what sort of

00:02:28.836 --> 00:02:30.286
type-level validation we can

00:02:30.286 --> 00:02:31.606
apply with the NS Secure coding

00:02:31.606 --> 00:02:32.016
protocol.

00:02:32.096 --> 00:02:33.986
And then apply those same

00:02:33.986 --> 00:02:35.626
concepts to codable types.

00:02:37.116 --> 00:02:40.256
Let's get started.

00:02:40.366 --> 00:02:41.536
In order to talk about data,

00:02:41.656 --> 00:02:42.576
we're going to want to build a

00:02:42.576 --> 00:02:44.426
mental model of the forms that

00:02:44.426 --> 00:02:46.426
data can take within our app.

00:02:47.566 --> 00:02:49.626
At the most basic level, data

00:02:49.626 --> 00:02:51.786
makes its way into our app as a

00:02:51.786 --> 00:02:52.756
stream of bites.

00:02:54.336 --> 00:02:55.396
There's not much we can tell

00:02:55.396 --> 00:02:56.426
about this data at this stage

00:02:56.426 --> 00:02:58.156
without looking at it, but this

00:02:58.156 --> 00:03:00.976
we'll call raw data.

00:03:01.646 --> 00:03:03.416
Now, to get working with that

00:03:03.416 --> 00:03:04.466
data, we need to make sure it

00:03:04.536 --> 00:03:06.276
conforms to that known format or

00:03:06.276 --> 00:03:06.756
structure.

00:03:07.406 --> 00:03:08.946
And in this case, each of those

00:03:08.946 --> 00:03:10.906
code points correspond into a

00:03:11.006 --> 00:03:13.426
UTF code point, and sorry, one

00:03:13.426 --> 00:03:14.186
moment, let me make that a

00:03:14.186 --> 00:03:14.876
little bit more readable.

00:03:15.416 --> 00:03:16.496
It looks like this is JSON.

00:03:17.036 --> 00:03:18.946
And so, once we've made sure

00:03:18.946 --> 00:03:20.336
that that data conforms to some

00:03:20.336 --> 00:03:21.266
format that we want to work

00:03:21.266 --> 00:03:23.106
with, we'll call this formatted

00:03:24.506 --> 00:03:24.626
data.

00:03:24.976 --> 00:03:26.536
Now, formatted data, on its own

00:03:26.896 --> 00:03:28.176
doesn't mean much, until we

00:03:28.286 --> 00:03:29.836
create primitive values out of

00:03:29.836 --> 00:03:31.366
it, strings, and arrays, and

00:03:31.366 --> 00:03:32.676
dictionaries that we can then

00:03:32.676 --> 00:03:34.246
use as building blocks for

00:03:34.246 --> 00:03:35.036
further algorithms.

00:03:35.556 --> 00:03:36.816
So, this we'll call our

00:03:36.816 --> 00:03:38.076
primitive data.

00:03:39.086 --> 00:03:40.696
Now, there's building blocks we

00:03:40.696 --> 00:03:41.876
most often want to work with,

00:03:41.946 --> 00:03:43.566
not as just primitive values,

00:03:43.936 --> 00:03:45.296
but as our own model types.

00:03:46.546 --> 00:03:47.996
So, once we do that, we'll make

00:03:48.056 --> 00:03:49.456
use of this as we're going to

00:03:49.456 --> 00:03:51.376
call, structure data.

00:03:52.016 --> 00:03:54.166
Now, these forms of data in our

00:03:54.316 --> 00:03:56.876
apps, form an abstraction

00:03:57.346 --> 00:03:57.826
timeline.

00:03:59.076 --> 00:04:00.826
Raw data is the least abstract

00:04:00.826 --> 00:04:01.846
data that we're going to work

00:04:01.846 --> 00:04:03.306
with, and our own structured

00:04:03.306 --> 00:04:04.386
model types are the most

00:04:04.386 --> 00:04:04.916
abstract.

00:04:05.476 --> 00:04:07.266
So, our goal for today is to

00:04:07.266 --> 00:04:08.736
take that data as far along the

00:04:08.736 --> 00:04:09.916
spectrum as we can.

00:04:10.546 --> 00:04:12.096
Now, our apps can stop at any

00:04:12.096 --> 00:04:13.256
point, make use of the data,

00:04:13.296 --> 00:04:14.156
however, we see fit.

00:04:14.256 --> 00:04:15.566
But we really want to work with

00:04:15.566 --> 00:04:16.846
our own model types wherever

00:04:16.846 --> 00:04:17.286
possible.

00:04:18.356 --> 00:04:19.995
Now, the goal for today is to

00:04:19.995 --> 00:04:21.696
not just go as far along the

00:04:21.696 --> 00:04:23.076
abstraction spectrum as we can,

00:04:23.316 --> 00:04:25.546
but to build trust as we do so.

00:04:26.466 --> 00:04:27.516
At every stage, the data is

00:04:27.516 --> 00:04:28.716
going to get more complicated,

00:04:28.786 --> 00:04:30.216
and there's going to be more

00:04:30.216 --> 00:04:31.346
that we need to validate about

00:04:31.346 --> 00:04:31.413
it.

00:04:31.413 --> 00:04:32.966
But once we do that, there's

00:04:32.966 --> 00:04:33.836
also going to be more that we

00:04:33.836 --> 00:04:35.696
can trust about it.

00:04:36.116 --> 00:04:37.686
Now, for our use case today,

00:04:37.686 --> 00:04:38.596
we're not really going to be

00:04:38.596 --> 00:04:39.696
talking about formatted data.

00:04:40.046 --> 00:04:41.626
Very often it's just a stepping

00:04:41.626 --> 00:04:42.956
stone between raw and primitive

00:04:42.956 --> 00:04:43.916
data, and you don't work with it

00:04:43.916 --> 00:04:44.326
directly.

00:04:45.256 --> 00:04:47.606
For instance, given raw data,

00:04:47.746 --> 00:04:49.256
foundations JSON serialization

00:04:49.256 --> 00:04:50.256
will give you primitive data

00:04:50.256 --> 00:04:50.516
back.

00:04:50.876 --> 00:04:52.276
You don't see just the formatted

00:04:52.276 --> 00:04:53.206
date directly, and you won't

00:04:53.206 --> 00:04:54.766
make use of it.

00:04:54.976 --> 00:04:56.066
So, today we'll just be talking

00:04:56.066 --> 00:04:57.676
about raw, primitive, and

00:04:57.676 --> 00:04:58.256
structured data.

00:05:00.186 --> 00:05:01.186
Now, let's start by talking

00:05:01.186 --> 00:05:01.776
about raw data.

00:05:02.836 --> 00:05:04.996
Again, as we mentioned, raw data

00:05:04.996 --> 00:05:06.486
is just a stream of bytes that's

00:05:06.486 --> 00:05:08.496
made its way into your app.

00:05:08.496 --> 00:05:10.296
Until you inspect that data and

00:05:10.296 --> 00:05:11.586
you give it meaning, there's not

00:05:11.586 --> 00:05:13.266
much you can do with it.

00:05:13.766 --> 00:05:15.686
Now, we might care to know what

00:05:15.716 --> 00:05:17.316
we can take a look at about that

00:05:17.316 --> 00:05:18.296
data before we start

00:05:18.296 --> 00:05:18.906
interpreting it.

00:05:19.366 --> 00:05:20.466
Is it even safe to do that?

00:05:22.016 --> 00:05:23.106
One thing we can validate about

00:05:23.106 --> 00:05:24.476
this data before making use of

00:05:24.476 --> 00:05:25.146
it is its length.

00:05:26.306 --> 00:05:27.776
Say your app expects to load a

00:05:27.776 --> 00:05:29.396
1-kilobyte file from disc, but

00:05:29.396 --> 00:05:31.096
finds a 1-gigabyte file in disc.

00:05:32.226 --> 00:05:33.376
Does it make sense to even load

00:05:33.376 --> 00:05:34.436
that data in the first place,

00:05:34.436 --> 00:05:35.176
and start reading it?

00:05:36.016 --> 00:05:38.366
Almost certainly not.

00:05:38.666 --> 00:05:39.736
Now, sometimes we might not be

00:05:39.736 --> 00:05:41.216
able to have length expectations

00:05:41.216 --> 00:05:41.796
about the data.

00:05:42.286 --> 00:05:43.476
Maybe it's external data we

00:05:43.476 --> 00:05:43.956
don't own.

00:05:43.956 --> 00:05:44.906
We don't' know how much data

00:05:44.906 --> 00:05:45.426
there could be.

00:05:46.366 --> 00:05:48.336
But in some cases, we might also

00:05:48.336 --> 00:05:49.966
be able to verify a checksum, or

00:05:49.966 --> 00:05:51.436
a cryptographic signature that

00:05:51.716 --> 00:05:53.336
represents what the data might

00:05:53.336 --> 00:05:54.346
look like, even if we don't know

00:05:54.346 --> 00:05:54.956
what's inside.

00:05:56.046 --> 00:05:57.516
Checksum is built by hashing all

00:05:57.516 --> 00:05:57.956
of the data.

00:05:58.056 --> 00:05:59.836
And if any bit in the data

00:05:59.836 --> 00:06:01.196
changes, either due to a

00:06:01.196 --> 00:06:02.726
potential malicious third party,

00:06:03.166 --> 00:06:04.796
or just regular data corruption,

00:06:04.796 --> 00:06:06.196
bad blocks on disc, a bad

00:06:06.196 --> 00:06:06.946
network connection.

00:06:07.306 --> 00:06:08.996
If any one of the bits flips in

00:06:08.996 --> 00:06:10.906
that data, it will invalidate

00:06:10.906 --> 00:06:12.216
the checksum, or the signature.

00:06:12.556 --> 00:06:13.516
And we'll know before even

00:06:13.516 --> 00:06:15.016
reading any of those bytes, that

00:06:15.016 --> 00:06:16.456
the data is incorrect, and you

00:06:16.456 --> 00:06:18.746
shouldn't trust it.

00:06:19.396 --> 00:06:21.106
Now, we also don't always have a

00:06:21.106 --> 00:06:21.576
checksum.

00:06:21.576 --> 00:06:22.706
Maybe it's data we don't own,

00:06:22.706 --> 00:06:23.606
where you can't get that ahead

00:06:23.606 --> 00:06:23.986
of time.

00:06:23.986 --> 00:06:25.706
So, at this stage, there isn't

00:06:25.706 --> 00:06:27.146
much we can do with this data,

00:06:27.826 --> 00:06:29.186
besides read it and inspect it.

00:06:29.186 --> 00:06:32.346
And so, once we do that, we can

00:06:32.346 --> 00:06:34.376
get primitive data out.

00:06:34.736 --> 00:06:36.286
Now, as we've mentioned, we can

00:06:36.286 --> 00:06:38.036
take that raw data and pass it

00:06:38.036 --> 00:06:39.576
through, usually deserialize it,

00:06:39.636 --> 00:06:40.616
like foundations JSON

00:06:40.616 --> 00:06:41.316
serialization.

00:06:42.856 --> 00:06:44.156
When we do that, we'll get inert

00:06:44.156 --> 00:06:45.556
strings and dictionaries and

00:06:45.556 --> 00:06:46.846
arrays of numbers back out that

00:06:46.846 --> 00:06:47.456
we can use.

00:06:47.666 --> 00:06:49.406
And if this process exceeds, we

00:06:49.406 --> 00:06:50.596
know two things about that data.

00:06:52.316 --> 00:06:53.716
One, that the data was indeed in

00:06:53.716 --> 00:06:54.656
the correct format that we

00:06:54.656 --> 00:06:55.126
expected.

00:06:55.306 --> 00:06:56.696
For instance, XML data won't

00:06:56.696 --> 00:06:58.096
pass through JSON serialization.

00:06:58.736 --> 00:07:00.936
And two, if we trust the

00:07:00.936 --> 00:07:03.386
deserializer, we know that the

00:07:03.386 --> 00:07:04.966
run-time objects we get back out

00:07:04.966 --> 00:07:05.806
are going to be valid.

00:07:06.476 --> 00:07:07.746
Again, foundations JSON

00:07:07.746 --> 00:07:08.906
serialization will always give

00:07:08.906 --> 00:07:09.976
you strings and numbers and

00:07:09.976 --> 00:07:11.186
arrays that you can actually

00:07:11.186 --> 00:07:11.436
work with.

00:07:12.156 --> 00:07:13.586
It's individual values that we

00:07:13.586 --> 00:07:14.076
can trust.

00:07:14.596 --> 00:07:16.746
But at this stage, we might

00:07:16.746 --> 00:07:18.796
wonder okay how can we make use

00:07:18.796 --> 00:07:19.826
of this data, or what can we

00:07:19.826 --> 00:07:21.106
trust about it, and what

00:07:21.106 --> 00:07:22.416
validation do we still need to

00:07:23.746 --> 00:07:23.813
do?

00:07:24.736 --> 00:07:26.376
Well, we don't actually know

00:07:26.646 --> 00:07:28.006
much about the contents of this

00:07:28.006 --> 00:07:29.486
data yet until we start looking

00:07:29.486 --> 00:07:29.696
at it.

00:07:29.696 --> 00:07:31.506
And in fact, we might not know

00:07:31.506 --> 00:07:32.706
anything about the structure of

00:07:32.706 --> 00:07:33.966
the data until we start

00:07:33.966 --> 00:07:34.556
inspecting it.

00:07:34.956 --> 00:07:36.066
If you've ever worked with

00:07:36.066 --> 00:07:37.496
dynamic deserialization in this

00:07:37.496 --> 00:07:38.216
way, you'll know that there's a

00:07:38.216 --> 00:07:39.666
lot of downcasting from anys.

00:07:40.466 --> 00:07:41.946
There's no upfront expectation

00:07:41.946 --> 00:07:42.866
what the data can be because

00:07:42.866 --> 00:07:43.796
it's very generalized.

00:07:44.326 --> 00:07:45.396
And so, we'll want to check to

00:07:45.396 --> 00:07:47.256
see what the data contains and

00:07:47.256 --> 00:07:47.906
how we can work with it.

00:07:49.166 --> 00:07:50.586
So, let's motivate this with an

00:07:50.586 --> 00:07:50.966
example.

00:07:51.896 --> 00:07:52.896
I've been working with an app

00:07:52.896 --> 00:07:54.406
lately called Sell My Old Junk,

00:07:54.826 --> 00:07:56.686
which allows me to sell my old

00:07:56.686 --> 00:07:57.946
junk to some friends and family.

00:07:58.396 --> 00:07:59.986
And when one of them opens up my

00:08:00.106 --> 00:08:02.716
app, my app makes a request to

00:08:02.716 --> 00:08:03.256
my server.

00:08:03.966 --> 00:08:05.876
Which requests a list of

00:08:05.926 --> 00:08:06.986
products that are currently

00:08:06.986 --> 00:08:08.166
available for sale to my friends

00:08:08.166 --> 00:08:08.546
and family.

00:08:09.646 --> 00:08:11.156
When the server receives this

00:08:11.156 --> 00:08:12.636
request, it responses with JSON,

00:08:13.026 --> 00:08:13.986
that indicates here are the

00:08:13.986 --> 00:08:16.576
products available to sell.

00:08:17.296 --> 00:08:18.956
Now, this is what an API

00:08:18.956 --> 00:08:20.186
response from my server might

00:08:20.186 --> 00:08:20.576
look like.

00:08:21.576 --> 00:08:22.606
It's an array of product

00:08:22.606 --> 00:08:23.836
listings, which have some

00:08:23.836 --> 00:08:24.716
interesting fields that you

00:08:24.716 --> 00:08:25.516
might care to look at.

00:08:26.766 --> 00:08:29.116
For instance, each listing has a

00:08:29.366 --> 00:08:29.986
product ID.

00:08:30.166 --> 00:08:31.776
A positive integer that uniquely

00:08:31.776 --> 00:08:32.686
identifies the product.

00:08:33.076 --> 00:08:34.275
And in my case, these are

00:08:34.275 --> 00:08:35.986
sequential integer IDs.

00:08:37.346 --> 00:08:38.905
Every listing also has a name

00:08:38.905 --> 00:08:39.706
and a description which are

00:08:39.706 --> 00:08:40.196
strings.

00:08:40.196 --> 00:08:41.306
And there are a few other type

00:08:41.306 --> 00:08:42.366
fields here that we might care

00:08:42.366 --> 00:08:42.756
to look at.

00:08:43.846 --> 00:08:45.216
For instance, there's a field

00:08:45.386 --> 00:08:46.506
that's a Boolean that indicates

00:08:46.506 --> 00:08:47.586
whether or not this listing has

00:08:47.586 --> 00:08:48.236
already been sold.

00:08:48.796 --> 00:08:50.716
And there's some internal

00:08:50.716 --> 00:08:51.386
structure here.

00:08:51.476 --> 00:08:52.626
This list of tags, which are

00:08:52.626 --> 00:08:53.726
strings, which we might care to

00:08:53.726 --> 00:08:54.066
use.

00:08:55.496 --> 00:08:57.216
There are also a few fields

00:08:57.216 --> 00:08:58.256
here, which come to us as

00:08:58.256 --> 00:08:59.736
strings, but really represent

00:08:59.806 --> 00:09:01.026
other forms of data that we

00:09:01.026 --> 00:09:01.676
might care to look at.

00:09:02.136 --> 00:09:04.376
For instance, URLs and dates.

00:09:05.116 --> 00:09:06.736
So, let's make use of this data.

00:09:07.856 --> 00:09:09.876
In my app, I can fetch that data

00:09:09.876 --> 00:09:11.156
from the network say with URL

00:09:11.156 --> 00:09:12.776
session, and wherever possible

00:09:12.776 --> 00:09:13.716
I'll validate the length.

00:09:13.716 --> 00:09:15.026
Maybe my server can produce a

00:09:15.056 --> 00:09:16.136
checksum that I can validate.

00:09:16.196 --> 00:09:17.416
Or a cryptographic signature.

00:09:17.986 --> 00:09:21.236
Once I've done that, I can take

00:09:21.266 --> 00:09:22.906
the data and pass it off JSON

00:09:22.906 --> 00:09:23.586
serialization.

00:09:24.626 --> 00:09:26.286
If deserializing the data fails,

00:09:26.546 --> 00:09:27.816
JSON serialization will throw an

00:09:27.816 --> 00:09:28.086
error.

00:09:28.196 --> 00:09:29.316
Will check and then catch and

00:09:29.316 --> 00:09:29.616
handle.

00:09:30.026 --> 00:09:31.216
May display dialogue to my

00:09:31.216 --> 00:09:31.726
customers.

00:09:32.936 --> 00:09:34.876
Again, in our purlins of the

00:09:34.876 --> 00:09:36.536
day, we've just taken raw data

00:09:37.076 --> 00:09:38.116
and carried along it the

00:09:38.116 --> 00:09:39.486
abstraction spectrum to

00:09:39.486 --> 00:09:40.056
primitive data.

00:09:40.746 --> 00:09:41.786
And if anything went wrong, we

00:09:41.786 --> 00:09:42.696
can handle that failure.

00:09:44.016 --> 00:09:45.576
So, now we need to make use of

00:09:45.576 --> 00:09:45.936
this data.

00:09:46.106 --> 00:09:47.026
How can we consume it?

00:09:47.786 --> 00:09:49.856
Well, JSON is an any variable

00:09:49.856 --> 00:09:51.246
that contains the actual values.

00:09:52.006 --> 00:09:53.586
So, I can downcast it to the

00:09:53.586 --> 00:09:54.566
array of dictionaries that I

00:09:54.566 --> 00:09:55.306
expect it to be.

00:09:56.556 --> 00:09:57.866
Now, this part of my app cares

00:09:57.866 --> 00:09:58.956
only about product listings that

00:09:58.956 --> 00:09:59.706
are related to music.

00:10:00.446 --> 00:10:02.126
So, will filter out any products

00:10:02.126 --> 00:10:03.246
that don't contain the music

00:10:03.246 --> 00:10:03.546
tag.

00:10:03.546 --> 00:10:04.676
And here, I have that

00:10:04.676 --> 00:10:05.316
substructure.

00:10:05.316 --> 00:10:06.416
That list of tags, which will

00:10:06.416 --> 00:10:08.256
downcast an array of strings and

00:10:08.256 --> 00:10:11.386
make use of it, right.

00:10:11.596 --> 00:10:14.696
Whoops. Each of those forced

00:10:14.696 --> 00:10:16.176
downcasts, actually contains a

00:10:16.176 --> 00:10:17.146
hidden fatal error.

00:10:18.236 --> 00:10:19.736
If either of those casts fails

00:10:20.046 --> 00:10:21.996
because the API changed or the

00:10:21.996 --> 00:10:23.326
data changed along the way

00:10:23.326 --> 00:10:24.506
before it made into my app,

00:10:24.586 --> 00:10:26.266
again due to data corruption or

00:10:26.266 --> 00:10:28.496
malicious changing, those

00:10:28.496 --> 00:10:29.486
downcasts will fail.

00:10:29.516 --> 00:10:31.566
And when they do fail, they'll

00:10:31.876 --> 00:10:33.136
abort, and they'll crash my app.

00:10:33.206 --> 00:10:34.006
And again, that's a bad

00:10:34.006 --> 00:10:35.226
experience for my customers.

00:10:35.656 --> 00:10:37.526
Let's take a look at how this

00:10:37.526 --> 00:10:37.976
could happen.

00:10:38.986 --> 00:10:40.266
So, here again is that sample

00:10:40.476 --> 00:10:41.336
API response.

00:10:42.166 --> 00:10:43.466
And we'll take a look at the

00:10:43.466 --> 00:10:44.466
list of tags here.

00:10:45.216 --> 00:10:47.616
And say that second tag in there

00:10:48.146 --> 00:10:48.806
is modified.

00:10:49.506 --> 00:10:50.966
Instead of a string, we have a

00:10:50.966 --> 00:10:51.346
number.

00:10:51.636 --> 00:10:52.796
It's maliciously changed by a

00:10:52.796 --> 00:10:54.146
third-party, or maybe again due

00:10:54.146 --> 00:10:55.206
to regular data corruption.

00:10:55.206 --> 00:10:57.666
We can't always tell.

00:10:57.876 --> 00:10:59.836
Downcasting this list of tags

00:11:00.126 --> 00:11:01.646
will fail because they're not

00:11:01.646 --> 00:11:03.246
strings and we never checked to

00:11:03.376 --> 00:11:04.516
make sure they work before we

00:11:04.516 --> 00:11:04.846
cast.

00:11:06.706 --> 00:11:08.206
So, to avoid this, our main

00:11:08.206 --> 00:11:09.476
tenant for the day will always

00:11:09.476 --> 00:11:11.616
be validate first, execute

00:11:11.616 --> 00:11:11.886
later.

00:11:13.186 --> 00:11:14.216
Instead of asserting that you

00:11:14.216 --> 00:11:15.206
know what the structure of the

00:11:15.206 --> 00:11:16.776
data is, check first.

00:11:17.436 --> 00:11:18.436
Don't blindly assume.

00:11:19.426 --> 00:11:20.246
So, let's see how we can do

00:11:20.246 --> 00:11:21.316
that.

00:11:21.646 --> 00:11:22.926
So, here again is that first

00:11:22.926 --> 00:11:23.926
forced downcast.

00:11:24.266 --> 00:11:25.376
And instead of forcibly

00:11:25.376 --> 00:11:27.646
downcasting these values, I can

00:11:27.646 --> 00:11:29.466
conditionally downcast.

00:11:32.336 --> 00:11:35.756
This allows me to validate that

00:11:35.756 --> 00:11:37.366
the data actually contains what

00:11:37.366 --> 00:11:39.696
I want and if that cast fails,

00:11:40.716 --> 00:11:41.936
well I can handle that error

00:11:41.936 --> 00:11:42.966
instead of fatally erroring.

00:11:44.486 --> 00:11:45.666
Now, similarly, later

00:11:46.306 --> 00:11:47.476
downcasting that list of

00:11:47.476 --> 00:11:49.136
strings, instead of forcibly

00:11:49.136 --> 00:11:50.766
downcasting, again I can

00:11:50.766 --> 00:11:52.106
conditionally downcast.

00:11:52.536 --> 00:11:53.596
And in this case, instead of

00:11:53.666 --> 00:11:55.396
throwing an error, I can give a

00:11:55.396 --> 00:11:56.606
default value that allows

00:11:56.606 --> 00:11:57.696
execution to continue.

00:11:57.846 --> 00:11:59.526
In this case, I'll simply ignore

00:11:59.526 --> 00:12:01.046
any product listings that don't

00:12:01.046 --> 00:12:02.416
have a valid list of tags.

00:12:03.226 --> 00:12:04.336
I could throw an error, but in

00:12:04.336 --> 00:12:07.356
this case, I chose not to.

00:12:07.876 --> 00:12:09.456
Now, type validation isn't the

00:12:09.456 --> 00:12:10.986
only form of validation that you

00:12:10.986 --> 00:12:12.546
want to perform at this stage.

00:12:13.106 --> 00:12:14.986
For instance, if that had been

00:12:14.986 --> 00:12:16.266
replaced by null, which is

00:12:16.266 --> 00:12:18.856
totally valid in JSON, I

00:12:19.096 --> 00:12:20.556
would've seen a similar crash.

00:12:21.876 --> 00:12:23.876
In Swift strong static type

00:12:23.876 --> 00:12:25.176
system nullability is part of

00:12:25.176 --> 00:12:25.556
the type.

00:12:25.556 --> 00:12:27.346
And indeed, you can't downcast

00:12:27.346 --> 00:12:28.166
null to a string.

00:12:28.616 --> 00:12:30.416
And so, again, this cast would

00:12:30.806 --> 00:12:32.356
have failed.

00:12:32.896 --> 00:12:34.696
Now, even if all of these values

00:12:34.696 --> 00:12:35.746
are of the correct type and

00:12:35.746 --> 00:12:37.186
nullability, there's other forms

00:12:37.186 --> 00:12:38.136
of validations that we should

00:12:38.136 --> 00:12:38.786
care about here.

00:12:39.626 --> 00:12:41.236
For instance, I said that each

00:12:41.296 --> 00:12:42.666
product listing has a positive

00:12:42.666 --> 00:12:43.196
integer ID.

00:12:43.196 --> 00:12:44.246
In my case, they're all

00:12:44.246 --> 00:12:45.296
sequential integers.

00:12:45.966 --> 00:12:47.076
Does it make sense for one of

00:12:47.076 --> 00:12:48.216
these IDs to be negative?

00:12:49.206 --> 00:12:49.926
No, it doesn't.

00:12:49.926 --> 00:12:51.366
But even if it is always

00:12:51.366 --> 00:12:53.026
positive, does it make sense for

00:12:53.026 --> 00:12:54.486
it to be such a large positive

00:12:54.486 --> 00:12:55.176
integer value?

00:12:55.976 --> 00:12:57.406
I'm not selling that many

00:12:57.406 --> 00:12:57.776
things.

00:12:58.036 --> 00:12:58.786
So, no it doesn't.

00:12:58.786 --> 00:12:59.886
and in this case, this might be

00:12:59.886 --> 00:13:01.376
due to somebody trying to cause

00:13:01.376 --> 00:13:02.986
overflow in my app.

00:13:03.586 --> 00:13:04.426
This is something you need to

00:13:04.426 --> 00:13:05.066
watch out for.

00:13:07.026 --> 00:13:08.526
Now similar to range validation

00:13:08.526 --> 00:13:09.486
is length validation.

00:13:10.146 --> 00:13:12.176
Again, every product listing has

00:13:12.176 --> 00:13:12.786
a description.

00:13:12.786 --> 00:13:14.466
Does it make sense for that

00:13:14.466 --> 00:13:15.496
description to be empty?

00:13:16.876 --> 00:13:18.096
Well, in my case, I know that

00:13:18.096 --> 00:13:19.456
anytime I upload a product

00:13:19.456 --> 00:13:21.456
listing, I'm always going to put

00:13:21.456 --> 00:13:22.206
a description in there.

00:13:22.206 --> 00:13:23.456
So, in my case, no it doesn't

00:13:23.456 --> 00:13:26.266
make sense for it to be empty.

00:13:26.326 --> 00:13:27.556
But even if it's not empty, does

00:13:27.556 --> 00:13:28.496
it make sense for it to be the

00:13:28.496 --> 00:13:29.706
full length and contents of

00:13:29.706 --> 00:13:30.516
"Romeo and Juliet?"

00:13:31.286 --> 00:13:32.786
Also no, it doesn't make sense.

00:13:32.786 --> 00:13:34.326
Something here's gone wrong and

00:13:34.326 --> 00:13:37.596
I need to look for that.

00:13:38.056 --> 00:13:39.166
Now, there's additional forms of

00:13:39.166 --> 00:13:40.166
validation that we really do

00:13:40.166 --> 00:13:40.806
care about here.

00:13:40.966 --> 00:13:42.286
Even if all of these fields are

00:13:42.286 --> 00:13:44.366
right type, nullability, and fit

00:13:44.366 --> 00:13:45.286
within the range and length that

00:13:45.286 --> 00:13:47.266
we expect, their values and

00:13:47.266 --> 00:13:48.596
contents are also equally

00:13:48.596 --> 00:13:48.986
important.

00:13:50.136 --> 00:13:51.836
Every product listing has a URL

00:13:51.836 --> 00:13:53.096
that I can send a customer to

00:13:53.096 --> 00:13:54.346
see more information about that

00:13:54.346 --> 00:13:54.986
product listing.

00:13:56.036 --> 00:13:57.306
This comes to me as a string,

00:13:57.866 --> 00:13:59.376
but it actually has to contain a

00:13:59.376 --> 00:13:59.596
URL.

00:13:59.596 --> 00:14:00.966
Does it make sense for it to be

00:14:01.356 --> 00:14:02.406
any arbitrary string?

00:14:02.896 --> 00:14:04.916
No, and in my case, I want to

00:14:04.916 --> 00:14:05.876
make sure that it actually

00:14:05.876 --> 00:14:06.706
represents a URL.

00:14:07.646 --> 00:14:09.366
But more importantly, just

00:14:09.366 --> 00:14:10.646
because it looks like a URL,

00:14:10.646 --> 00:14:11.956
doesn't mean it will point to my

00:14:11.956 --> 00:14:12.426
domain.

00:14:12.916 --> 00:14:13.916
And this is something I care

00:14:13.916 --> 00:14:14.866
very deeply about.

00:14:14.866 --> 00:14:16.976
I really, really want to keep my

00:14:16.976 --> 00:14:17.736
customers safe.

00:14:17.736 --> 00:14:19.466
I don't want to possibly send

00:14:19.466 --> 00:14:21.266
them to a phishing domain, which

00:14:21.266 --> 00:14:23.056
could look like mine, but not

00:14:23.056 --> 00:14:23.936
really be my site.

00:14:25.426 --> 00:14:26.476
So, this is something that I

00:14:26.476 --> 00:14:29.046
care about watching out for.

00:14:29.546 --> 00:14:30.986
Now, lastly, even if each of

00:14:30.986 --> 00:14:32.656
these fields is valid on its

00:14:32.656 --> 00:14:34.126
own, sometimes the relationships

00:14:34.126 --> 00:14:35.376
between fields that matters.

00:14:36.956 --> 00:14:38.026
For instance, each product

00:14:38.026 --> 00:14:39.186
listing has a date when it was

00:14:39.186 --> 00:14:40.446
created, and a date when it was

00:14:40.446 --> 00:14:41.126
last updated.

00:14:42.226 --> 00:14:43.276
Each of these can be valid on

00:14:43.276 --> 00:14:44.486
their own, but does it make

00:14:44.486 --> 00:14:45.566
sense for the date that it was

00:14:45.566 --> 00:14:47.256
last updated to come before when

00:14:47.256 --> 00:14:47.936
it was created?

00:14:49.106 --> 00:14:50.716
No. And in my case, this might

00:14:50.716 --> 00:14:51.636
not open a security

00:14:51.636 --> 00:14:52.406
vulnerability in my app.

00:14:52.406 --> 00:14:54.436
But this is something that maybe

00:14:54.436 --> 00:14:55.536
you watch out for because it's a

00:14:55.536 --> 00:14:56.946
good indicator that something's

00:14:56.946 --> 00:14:57.946
gone wrong, and maybe I

00:14:57.946 --> 00:14:58.966
shouldn't trust this data.

00:14:58.966 --> 00:15:01.736
So, let's take a look at how we

00:15:01.736 --> 00:15:03.216
can start doing that.

00:15:03.656 --> 00:15:04.726
Here, I've started writing a

00:15:04.726 --> 00:15:05.836
function which will take one

00:15:05.836 --> 00:15:07.106
such listing and start

00:15:07.106 --> 00:15:08.366
validating all of the contents.

00:15:09.476 --> 00:15:10.836
So, I'll take a listing, and

00:15:10.836 --> 00:15:12.056
I'll start pulling out the

00:15:12.056 --> 00:15:12.666
product ID.

00:15:13.386 --> 00:15:15.436
And we've learned here not to

00:15:15.436 --> 00:15:17.136
forcibly downcast this ID to an

00:15:17.166 --> 00:15:18.836
Int, but conditionally downcast.

00:15:19.166 --> 00:15:20.766
And if the cast fails the guard

00:15:20.766 --> 00:15:21.876
will fail and will throw an

00:15:21.876 --> 00:15:22.126
error.

00:15:22.216 --> 00:15:24.676
Now I don't want to stop there,

00:15:24.676 --> 00:15:25.746
I want to perform the range

00:15:25.746 --> 00:15:27.266
validation that ensures that

00:15:27.266 --> 00:15:28.626
product ID is also valid.

00:15:28.626 --> 00:15:30.066
That it's positive and not too

00:15:30.066 --> 00:15:30.466
large.

00:15:30.606 --> 00:15:31.616
And again, if something goes

00:15:31.616 --> 00:15:36.386
wrong, I'll throw an error.

00:15:37.006 --> 00:15:38.636
Now, later on I might care to

00:15:38.636 --> 00:15:39.706
check out that URL.

00:15:39.766 --> 00:15:41.466
And again, I'll downcast it to a

00:15:41.466 --> 00:15:42.916
string, instead of forcibly

00:15:42.916 --> 00:15:43.466
downcast.

00:15:44.236 --> 00:15:45.436
And here, I can check the link.

00:15:45.626 --> 00:15:46.836
In this case, I know my server

00:15:46.836 --> 00:15:48.276
will never produce URLs that are

00:15:48.276 --> 00:15:48.806
too long.

00:15:49.156 --> 00:15:50.966
So, if I find a really long URL,

00:15:50.966 --> 00:15:52.296
I'll know that it's invalid.

00:15:54.096 --> 00:15:55.726
Once I've validated that, I can

00:15:55.726 --> 00:15:57.206
send it off to the URL type to

00:15:57.206 --> 00:15:58.376
perform that domain-specific

00:15:58.376 --> 00:15:59.276
validation to make sure it

00:15:59.276 --> 00:16:00.816
actually is a URL, and not just

00:16:00.816 --> 00:16:01.486
a garbage string.

00:16:01.786 --> 00:16:02.846
And again, if anything goes

00:16:02.916 --> 00:16:04.006
wrong, I'll throw an error.

00:16:04.586 --> 00:16:06.806
But, again, I don't want to stop

00:16:06.806 --> 00:16:08.456
there, once I have an actual

00:16:08.456 --> 00:16:09.926
URL, I want to make sure it

00:16:09.926 --> 00:16:11.376
points to my domain and not a

00:16:11.376 --> 00:16:13.016
phishing domain, so I'll keep

00:16:13.016 --> 00:16:15.206
working with that.

00:16:15.406 --> 00:16:16.736
Now, at this point, I can apply

00:16:16.736 --> 00:16:17.886
the same types of validation to

00:16:17.886 --> 00:16:18.716
the other fields here.

00:16:18.966 --> 00:16:20.096
And again, if anything goes

00:16:20.096 --> 00:16:20.936
wrong, I'll throw an error.

00:16:21.466 --> 00:16:22.936
But once I have this function, I

00:16:22.936 --> 00:16:24.686
can apply it to all the product

00:16:24.686 --> 00:16:25.866
listings that I've loaded from

00:16:25.866 --> 00:16:26.256
the payload.

00:16:26.466 --> 00:16:29.436
And again, I'll stop executing

00:16:29.886 --> 00:16:33.716
if anything goes wrong.

00:16:33.916 --> 00:16:35.426
Now, this is how we can work to

00:16:35.426 --> 00:16:36.476
validate primitive data.

00:16:37.256 --> 00:16:38.256
But as we just saw, primitive

00:16:38.256 --> 00:16:39.306
data can be very general.

00:16:40.706 --> 00:16:43.906
A string can be a string, but it

00:16:43.906 --> 00:16:45.416
can also be a date.

00:16:45.756 --> 00:16:48.376
And it can also be a URL.

00:16:50.236 --> 00:16:52.086
Sometimes we care to work with

00:16:52.126 --> 00:16:53.466
data with the semantics that

00:16:53.556 --> 00:16:54.356
matter to us.

00:16:54.796 --> 00:16:55.986
We wanted to make sure that the

00:16:55.986 --> 00:16:57.866
host of that URL was our domain,

00:16:57.866 --> 00:16:59.116
and we can't do that with just a

00:16:59.116 --> 00:16:59.796
regular string.

00:17:01.536 --> 00:17:03.026
Similarly, a dictionary can

00:17:03.026 --> 00:17:04.846
represent a model like a listing

00:17:04.846 --> 00:17:06.616
here, or it can represent

00:17:06.616 --> 00:17:07.976
arbitrary customer data that we

00:17:07.976 --> 00:17:08.746
know nothing about.

00:17:10.136 --> 00:17:11.366
Instead of performing the same

00:17:11.366 --> 00:17:12.726
validations everywhere to make

00:17:12.726 --> 00:17:13.896
sure all the fields that we care

00:17:13.896 --> 00:17:15.665
about are there, isn't it nicer

00:17:15.665 --> 00:17:16.476
to work with our own model

00:17:16.476 --> 00:17:18.386
types, where that guarantee is

00:17:18.386 --> 00:17:19.016
always present?

00:17:19.556 --> 00:17:23.326
It is. And in our case, we want

00:17:23.326 --> 00:17:24.665
to work with structured data

00:17:24.705 --> 00:17:25.776
wherever possible.

00:17:25.876 --> 00:17:27.165
We can use primitive date as a

00:17:27.165 --> 00:17:28.356
building block to get there.

00:17:28.356 --> 00:17:29.516
But we want to work with that

00:17:29.516 --> 00:17:30.046
form of data.

00:17:31.286 --> 00:17:32.116
So, let's take a look at how we

00:17:32.116 --> 00:17:35.506
can do that.

00:17:35.506 --> 00:17:37.366
Elsewhere in my app, I have a

00:17:37.366 --> 00:17:38.836
purchase type, which does just

00:17:38.836 --> 00:17:39.166
this.

00:17:40.556 --> 00:17:41.436
When a customer makes a

00:17:41.436 --> 00:17:43.416
purchase, I store that data to

00:17:43.416 --> 00:17:44.866
disc, so that later, when they

00:17:44.866 --> 00:17:46.016
open the app, even if they're

00:17:46.016 --> 00:17:47.176
not connected to the network,

00:17:47.496 --> 00:17:48.426
they can view their purchase

00:17:48.426 --> 00:17:48.796
history.

00:17:50.096 --> 00:17:51.576
Each purchase keeps track of the

00:17:51.576 --> 00:17:52.446
product listing it was

00:17:52.446 --> 00:17:54.846
associated with, and when the

00:17:54.846 --> 00:17:55.946
purchase was made, and a

00:17:55.946 --> 00:17:56.386
receipt.

00:17:57.366 --> 00:17:59.476
I can save it to disc in this

00:17:59.476 --> 00:18:01.496
way using NS coding and NS key

00:18:01.496 --> 00:18:02.076
to archiver.

00:18:02.106 --> 00:18:03.026
And I'll archive it.

00:18:04.076 --> 00:18:05.876
But as we saw, when we unarchive

00:18:05.876 --> 00:18:07.506
data, and we handle raw and

00:18:07.506 --> 00:18:09.106
primitive data, we want to

00:18:09.106 --> 00:18:09.566
validate it.

00:18:10.746 --> 00:18:12.036
So, let's do that by taking a

00:18:12.036 --> 00:18:13.186
look at how doing it with coder

00:18:13.246 --> 00:18:13.756
here could work.

00:18:14.276 --> 00:18:15.416
If you've ever written in a note

00:18:15.416 --> 00:18:16.306
with coder, this might look

00:18:16.306 --> 00:18:16.956
familiar to you.

00:18:17.746 --> 00:18:19.396
We'll start by decoding the

00:18:19.396 --> 00:18:20.206
product listing.

00:18:20.426 --> 00:18:21.296
And again, we've learned to

00:18:21.296 --> 00:18:23.086
conditionally downcast, instead

00:18:23.086 --> 00:18:24.216
of forcibly downcasting.

00:18:25.106 --> 00:18:26.346
And if something goes wrong,

00:18:26.396 --> 00:18:27.446
well this is a fail-able

00:18:27.446 --> 00:18:28.746
initializer, we'll simply return

00:18:28.746 --> 00:18:29.306
nil, right?

00:18:30.686 --> 00:18:32.526
if decoding succeeds, I'll

00:18:32.526 --> 00:18:33.996
assign this to my property, and

00:18:34.246 --> 00:18:34.836
I'll keep going.

00:18:35.686 --> 00:18:36.766
I'll do the same thing with the

00:18:36.766 --> 00:18:37.696
purchase data, and again,

00:18:37.746 --> 00:18:38.886
conditionally downcast to a

00:18:38.886 --> 00:18:39.176
date.

00:18:39.286 --> 00:18:40.456
If something goes wrong, I'll

00:18:40.516 --> 00:18:41.776
fail, and so on.

00:18:41.776 --> 00:18:43.216
And repeat this for each of the

00:18:43.216 --> 00:18:44.546
fields in my type.

00:18:45.396 --> 00:18:47.056
When I want to save one of these

00:18:47.096 --> 00:18:49.116
purchases to the history, well I

00:18:49.116 --> 00:18:50.136
have a function, which does

00:18:50.136 --> 00:18:50.516
this.

00:18:50.906 --> 00:18:53.806
It archives a purchase to binary

00:18:53.806 --> 00:18:54.086
data.

00:18:54.226 --> 00:18:56.556
And then, I can save it out to

00:18:56.556 --> 00:18:57.956
disc, or shrill that data off

00:18:57.956 --> 00:18:59.106
into database or similar.

00:18:59.226 --> 00:19:02.176
When I want to load that data

00:19:02.176 --> 00:19:03.736
back, well I can do the same

00:19:03.736 --> 00:19:03.996
thing.

00:19:03.996 --> 00:19:06.226
I can get that raw data and then

00:19:06.226 --> 00:19:06.976
pass it along to

00:19:06.976 --> 00:19:08.476
KeyedUnarchiver, to get an

00:19:08.476 --> 00:19:10.786
object back out.

00:19:11.436 --> 00:19:12.506
Now, as we've said, at every

00:19:12.586 --> 00:19:14.046
point here, the data is getting

00:19:14.046 --> 00:19:14.856
more complicated.

00:19:15.346 --> 00:19:16.426
There might be more to validate

00:19:16.426 --> 00:19:17.756
about it before we can trust it,

00:19:17.866 --> 00:19:18.466
just as well.

00:19:18.466 --> 00:19:20.466
So, you might wonder, okay,

00:19:20.466 --> 00:19:21.226
what's the catch here?

00:19:21.776 --> 00:19:22.596
What else is there left to

00:19:22.596 --> 00:19:22.986
validate?

00:19:22.986 --> 00:19:25.486
And this downcast, here is a

00:19:25.486 --> 00:19:25.986
good hint.

00:19:26.646 --> 00:19:29.436
Note that this downcast happens

00:19:29.686 --> 00:19:31.166
after we've unarchived an

00:19:31.166 --> 00:19:31.566
object.

00:19:32.636 --> 00:19:33.866
How could this ever fail?

00:19:35.196 --> 00:19:36.076
It's a good indicator that

00:19:36.076 --> 00:19:37.206
something else might be going on

00:19:37.206 --> 00:19:37.326
here.

00:19:37.676 --> 00:19:40.696
So, let's take a look at that.

00:19:40.696 --> 00:19:41.726
This is an abstract

00:19:41.726 --> 00:19:42.776
representation of what these

00:19:42.776 --> 00:19:44.336
model objects might look like in

00:19:44.336 --> 00:19:44.866
my archive.

00:19:46.246 --> 00:19:47.706
Here we have all the fields that

00:19:47.706 --> 00:19:48.666
we cared about in coding.

00:19:49.106 --> 00:19:50.216
And each of them contains their

00:19:50.216 --> 00:19:51.636
own structure, and substructure,

00:19:51.636 --> 00:19:53.256
and contents, and so on.

00:19:53.796 --> 00:19:55.846
But, interestingly here this

00:19:55.846 --> 00:19:57.766
representation also contains the

00:19:57.766 --> 00:19:59.576
name of the class of this

00:19:59.576 --> 00:19:59.976
object.

00:20:01.136 --> 00:20:02.156
Let's take a look at how

00:20:02.156 --> 00:20:03.546
KeyedUnarchiver can make use of

00:20:03.546 --> 00:20:04.216
this information.

00:20:05.346 --> 00:20:07.136
So, we have a decode call we're

00:20:07.136 --> 00:20:07.876
currently making.

00:20:08.486 --> 00:20:09.876
And this under the hood creates

00:20:09.876 --> 00:20:11.126
a KeyedUnarchiver, and decodes

00:20:11.126 --> 00:20:13.346
an object for the object key.

00:20:14.196 --> 00:20:15.666
When you perform this in

00:20:15.666 --> 00:20:17.086
KeyedUnarchiver, KeyedUnarchiver

00:20:17.086 --> 00:20:18.596
finds that class name in the

00:20:18.596 --> 00:20:20.636
object in the archive and pulls

00:20:20.636 --> 00:20:20.926
it out.

00:20:21.666 --> 00:20:23.396
And dynamically finds a class

00:20:23.396 --> 00:20:25.506
with that same name in your app.

00:20:26.046 --> 00:20:28.896
It then allocates an instance of

00:20:28.896 --> 00:20:30.756
that class and then initializes

00:20:30.756 --> 00:20:32.726
it to allow it to decode its own

00:20:32.726 --> 00:20:33.236
contents.

00:20:34.416 --> 00:20:36.026
Afterwards, it awakens the

00:20:36.026 --> 00:20:37.186
object to give it a chance to

00:20:37.186 --> 00:20:38.746
finalize its state.

00:20:40.336 --> 00:20:42.336
Now, this works great for our

00:20:42.336 --> 00:20:42.906
objects.

00:20:43.336 --> 00:20:45.096
But now, we might wonder what

00:20:45.096 --> 00:20:46.176
happens if the data is

00:20:46.176 --> 00:20:47.776
maliciously changed to contain

00:20:47.776 --> 00:20:50.226
an object of a class that we

00:20:50.956 --> 00:20:51.486
didn't expect?

00:20:51.486 --> 00:20:52.656
Well, this whole process that we

00:20:52.656 --> 00:20:54.656
just performed happened on a

00:20:54.656 --> 00:20:55.256
different type.

00:20:56.486 --> 00:20:58.616
We just allocated, initialized

00:20:58.616 --> 00:21:00.746
and awoke an object of a class

00:21:00.746 --> 00:21:01.546
that we didn't expect.

00:21:02.896 --> 00:21:03.906
What kind of effect can this

00:21:03.906 --> 00:21:05.826
have in our app?

00:21:06.106 --> 00:21:07.326
Well, as we saw before, the

00:21:07.326 --> 00:21:08.626
conditional downcast here,

00:21:08.896 --> 00:21:10.006
prevents us from accidentally

00:21:10.086 --> 00:21:11.216
using an object of this

00:21:11.216 --> 00:21:12.246
unexpected class.

00:21:12.696 --> 00:21:13.796
We're only going to work with

00:21:13.796 --> 00:21:15.146
objects of the types that we did

00:21:15.146 --> 00:21:15.566
expect.

00:21:15.976 --> 00:21:17.636
The downcast fails, well we'll

00:21:17.636 --> 00:21:17.936
fail.

00:21:20.476 --> 00:21:22.516
But decoding one such object can

00:21:22.516 --> 00:21:23.846
have a lasting impact in our

00:21:24.136 --> 00:21:24.476
app.

00:21:24.686 --> 00:21:27.036
Say that class has an alloc

00:21:27.036 --> 00:21:28.306
method, which changes global

00:21:28.306 --> 00:21:28.626
state.

00:21:28.696 --> 00:21:30.146
Maybe it allocates a singleton

00:21:30.146 --> 00:21:33.306
or changes some global data.

00:21:33.476 --> 00:21:34.796
Even though we throw the object

00:21:34.796 --> 00:21:36.346
away, if this fails, this can

00:21:36.346 --> 00:21:37.686
have a lasting impact in our

00:21:37.936 --> 00:21:38.006
app.

00:21:38.006 --> 00:21:39.716
And can cause differing behavior

00:21:39.846 --> 00:21:41.196
somewhere else and an archive

00:21:41.196 --> 00:21:43.076
can be maliciously constructed

00:21:43.076 --> 00:21:44.506
in this way to cause this to

00:21:44.506 --> 00:21:45.416
happen in our apps.

00:21:46.246 --> 00:21:47.806
So, how can we validate the data

00:21:47.806 --> 00:21:48.796
to prevent this from happening?

00:21:49.946 --> 00:21:51.196
This is exactly where the

00:21:51.196 --> 00:21:52.416
NSSecureCoding protocol comes

00:21:52.416 --> 00:21:52.516
in.

00:21:53.886 --> 00:21:55.566
NSSecureCoding is a protocol

00:21:55.966 --> 00:21:58.126
inheriting from NSCoding, whose

00:21:58.126 --> 00:22:00.536
goal is to prevent exactly this

00:22:00.536 --> 00:22:02.256
sort of attack.

00:22:02.966 --> 00:22:04.756
By allowing you to pass in type

00:22:04.756 --> 00:22:07.546
information upfront, it prevents

00:22:07.546 --> 00:22:08.926
arbitrary code execution by

00:22:08.926 --> 00:22:10.296
validating the contents of the

00:22:10.296 --> 00:22:11.966
archive to make sure it only

00:22:11.966 --> 00:22:13.246
contains the types that you

00:22:13.926 --> 00:22:14.166
expect.

00:22:15.356 --> 00:22:17.126
The hallmark introduction of

00:22:17.126 --> 00:22:18.666
NSSecureCoding were two

00:22:18.666 --> 00:22:20.136
alternative methods to decode

00:22:20.136 --> 00:22:22.016
object for key, which allow you

00:22:22.016 --> 00:22:23.356
to pass that type information

00:22:23.356 --> 00:22:23.786
upfront.

00:22:24.586 --> 00:22:26.056
And using that type information,

00:22:26.056 --> 00:22:27.276
NSKeyedUnarchiver can keep you

00:22:27.276 --> 00:22:27.636
safe.

00:22:29.016 --> 00:22:29.806
So, let's take a look at the

00:22:29.806 --> 00:22:31.016
current decode object for key

00:22:31.016 --> 00:22:31.666
call that we have.

00:22:32.136 --> 00:22:34.506
This top level decode.

00:22:34.756 --> 00:22:36.176
Now, here, if instead we use the

00:22:36.176 --> 00:22:37.806
variant that allows us to pass

00:22:37.806 --> 00:22:39.136
in the class upfront, in this

00:22:39.136 --> 00:22:39.986
case, we want to decode a

00:22:39.986 --> 00:22:42.566
purchase, instead of performing

00:22:42.566 --> 00:22:43.716
this whole process and whatever

00:22:43.796 --> 00:22:46.256
is in the archive, you can first

00:22:46.336 --> 00:22:47.666
gate it on a class check.

00:22:49.196 --> 00:22:50.276
Let's examine this class check

00:22:50.276 --> 00:22:50.746
for a moment.

00:22:51.236 --> 00:22:54.506
At every stage in decoding, if

00:22:54.506 --> 00:22:55.466
secure coding is on,

00:22:55.736 --> 00:22:57.106
NSKeyedUnarchiver maintains a

00:22:57.106 --> 00:22:58.676
list of classes, which are valid

00:22:58.676 --> 00:22:59.206
to decode.

00:22:59.786 --> 00:23:02.246
When we make such a call,

00:23:02.636 --> 00:23:04.456
NSKeyedUnarchiver, takes the

00:23:04.456 --> 00:23:06.606
object that we used, this class,

00:23:07.056 --> 00:23:08.516
and constructs an allowed class

00:23:08.516 --> 00:23:09.706
list from it.

00:23:10.296 --> 00:23:12.626
When we go ahead and decode an

00:23:12.626 --> 00:23:14.306
object from an archive, it's

00:23:14.306 --> 00:23:16.016
class is first checked against

00:23:16.016 --> 00:23:16.936
the allowed class list.

00:23:17.286 --> 00:23:19.626
And if it isn't present, the

00:23:19.626 --> 00:23:20.886
decode call will be rejected.

00:23:21.556 --> 00:23:24.436
Now, if the class of the object

00:23:24.436 --> 00:23:25.906
that we find in the archive is

00:23:25.906 --> 00:23:26.966
in the allowed class list,

00:23:27.556 --> 00:23:28.566
there's a few checks that we

00:23:28.566 --> 00:23:29.196
need to perform.

00:23:30.246 --> 00:23:31.726
Specifically, we'll need to make

00:23:31.726 --> 00:23:33.276
sure that this class itself also

00:23:33.276 --> 00:23:34.596
conforms to NSSecureCoding.

00:23:35.906 --> 00:23:37.666
If it doesn't, we can't be sure

00:23:37.666 --> 00:23:38.896
that it itself will be able to

00:23:38.896 --> 00:23:40.546
further securely decode its own

00:23:40.546 --> 00:23:41.146
contents.

00:23:41.496 --> 00:23:43.086
And so, we can't safely decode

00:23:43.086 --> 00:23:43.996
one of these objects.

00:23:44.996 --> 00:23:46.256
In our case, the purchase class

00:23:46.316 --> 00:23:46.506
will.

00:23:46.776 --> 00:23:47.976
And so, it's safe to decode and

00:23:47.976 --> 00:23:48.706
keep track of it.

00:23:49.746 --> 00:23:51.086
Now, there's two other checks

00:23:51.086 --> 00:23:51.716
that are related to

00:23:51.716 --> 00:23:52.856
superclass-subclass

00:23:53.256 --> 00:23:54.006
relationships.

00:23:54.576 --> 00:23:56.906
If you have two classes, one of

00:23:56.906 --> 00:23:58.226
which is a subclass of another,

00:23:58.586 --> 00:24:00.636
both conforming to NSCoding, and

00:24:00.636 --> 00:24:01.846
the superclass adopts

00:24:01.846 --> 00:24:04.066
NSSecureCoding conformance, the

00:24:04.066 --> 00:24:05.516
subclass will inherit that

00:24:05.516 --> 00:24:06.176
conformance.

00:24:06.786 --> 00:24:09.436
Now, the subclass may never have

00:24:09.436 --> 00:24:11.406
had a chance to rewrite its init

00:24:11.406 --> 00:24:12.656
with coder to do the secure

00:24:12.656 --> 00:24:12.986
thing.

00:24:13.756 --> 00:24:14.956
And so, we have an escape hatch

00:24:15.586 --> 00:24:15.676
here.

00:24:16.816 --> 00:24:18.126
The support secure coding

00:24:18.126 --> 00:24:19.386
method, allows you to say,

00:24:19.386 --> 00:24:21.226
actually I don't really support

00:24:21.226 --> 00:24:22.936
secure coding, and you can turn

00:24:22.936 --> 00:24:25.136
this off to say, I'm not ready

00:24:26.456 --> 00:24:26.566
yet.

00:24:26.776 --> 00:24:28.826
Alternatively, if you still say

00:24:28.826 --> 00:24:30.466
yes, we have to make sure that

00:24:30.466 --> 00:24:32.736
you either inherited the full

00:24:32.736 --> 00:24:34.276
conformance to NSSecureCoding

00:24:34.276 --> 00:24:36.256
from the superclass, or that you

00:24:36.256 --> 00:24:38.086
overrode both of the methods to

00:24:38.086 --> 00:24:40.126
indicate yes I really do support

00:24:40.126 --> 00:24:40.796
secure coding.

00:24:40.986 --> 00:24:43.696
There isn't a mismatch here.

00:24:44.166 --> 00:24:45.716
In our case, purchase meets both

00:24:45.716 --> 00:24:47.106
of these requirements and so we

00:24:47.106 --> 00:24:49.186
can safely decode it from the

00:24:49.756 --> 00:24:49.986
archive.

00:24:50.946 --> 00:24:52.826
Now, we go ahead and decode a

00:24:52.886 --> 00:24:54.976
purchase, it itself decodes a

00:24:54.976 --> 00:24:55.416
listing.

00:24:55.416 --> 00:24:56.806
And it can make use of the same

00:24:56.806 --> 00:24:58.206
type of call to indicate that it

00:24:58.206 --> 00:24:58.906
wants a listing.

00:24:59.486 --> 00:25:01.786
When it does that

00:25:02.076 --> 00:25:03.536
NSKeyedUnarchiver uses that

00:25:03.536 --> 00:25:05.146
class to build a new allowed

00:25:05.146 --> 00:25:05.826
class list.

00:25:06.236 --> 00:25:07.226
And everything is checked

00:25:07.226 --> 00:25:08.286
against this new version of the

00:25:08.286 --> 00:25:08.606
list.

00:25:09.916 --> 00:25:10.946
We go ahead and decode an

00:25:10.946 --> 00:25:12.316
object, the same checks are

00:25:12.316 --> 00:25:13.476
performed and in this case a

00:25:13.476 --> 00:25:14.876
listing is still valid to

00:25:15.426 --> 00:25:15.586
decode.

00:25:17.236 --> 00:25:19.816
But again, if we try to decode

00:25:19.816 --> 00:25:21.506
an object of an unexpected class

00:25:21.566 --> 00:25:22.656
that's not in the list, it will

00:25:22.656 --> 00:25:23.226
be rejected.

00:25:23.796 --> 00:25:27.186
Let's take a look at what that

00:25:27.186 --> 00:25:28.286
rejection might look like.

00:25:28.506 --> 00:25:30.256
And this is called decoding

00:25:30.256 --> 00:25:31.046
failure and there are a few

00:25:31.046 --> 00:25:32.356
other types of failures that we

00:25:32.356 --> 00:25:33.576
might care to look at.

00:25:33.746 --> 00:25:35.176
So, when secure coding is on, we

00:25:35.176 --> 00:25:36.276
might be able to see secure

00:25:36.276 --> 00:25:37.726
coding violations in cases like

00:25:37.726 --> 00:25:37.986
this.

00:25:37.986 --> 00:25:39.016
But there's other forms of

00:25:39.016 --> 00:25:39.716
failure here, too.

00:25:40.916 --> 00:25:42.956
For example, a type mismatch can

00:25:42.956 --> 00:25:44.556
happen if you try to decode an

00:25:44.556 --> 00:25:45.696
object and instead there's a

00:25:45.696 --> 00:25:47.066
primitive value, like an integer

00:25:47.066 --> 00:25:48.466
in the archive at that location.

00:25:49.116 --> 00:25:50.356
Or, you try to decode a

00:25:50.356 --> 00:25:52.396
primitive, like an integer, and

00:25:52.396 --> 00:25:54.146
instead we find an object or a

00:25:54.146 --> 00:25:55.376
primitive of an incompatible

00:25:55.476 --> 00:25:56.126
type like double.

00:25:57.026 --> 00:25:58.006
These can cause decoding

00:25:58.006 --> 00:25:58.456
failures.

00:25:59.996 --> 00:26:01.936
There's another form of failure

00:26:01.936 --> 00:26:02.606
that can happen here.

00:26:02.956 --> 00:26:04.106
And that's archive corruption.

00:26:04.106 --> 00:26:05.436
If the archive itself is too

00:26:05.436 --> 00:26:07.356
corrupted and doesn't follow the

00:26:07.356 --> 00:26:08.336
expected format for

00:26:08.336 --> 00:26:09.866
NSKeyedUnarchiver, well we won't

00:26:09.866 --> 00:26:11.256
be able to decode anything, and

00:26:11.256 --> 00:26:13.246
so you'll get that same sort of

00:26:13.976 --> 00:26:14.166
failure.

00:26:14.906 --> 00:26:17.166
Now, what happens on failure is

00:26:17.166 --> 00:26:18.666
decided by the decoding failure

00:26:18.666 --> 00:26:20.286
policy on the Unarchiver.

00:26:20.786 --> 00:26:21.606
There's two options here.

00:26:22.886 --> 00:26:23.946
On failure, we can either raise

00:26:23.946 --> 00:26:26.586
an exception or store

00:26:26.586 --> 00:26:27.836
information about what happened

00:26:27.836 --> 00:26:28.976
and continue execution.

00:26:29.926 --> 00:26:31.456
Raising exceptions is currently

00:26:31.456 --> 00:26:31.916
the default.

00:26:32.466 --> 00:26:35.766
So, if we have a call, again

00:26:35.766 --> 00:26:36.776
this is our call from earlier,

00:26:36.776 --> 00:26:37.846
trying to decode a listing.

00:26:38.116 --> 00:26:39.826
And we find an object of an

00:26:39.826 --> 00:26:41.296
unexpected class in the archive,

00:26:42.146 --> 00:26:43.256
under the hood this calls the

00:26:43.256 --> 00:26:44.816
failWithError method, on the

00:26:44.816 --> 00:26:47.036
Unarchiver and passes in an

00:26:47.036 --> 00:26:48.466
error that indicates what went

00:26:48.466 --> 00:26:49.046
wrong and where.

00:26:50.246 --> 00:26:51.146
Now, under the hood,

00:26:51.146 --> 00:26:52.946
failWithError has a decision to

00:26:52.946 --> 00:26:53.136
make.

00:26:54.056 --> 00:26:55.566
If the decoding failure policy

00:26:55.566 --> 00:26:57.256
is to raise exceptions, it will

00:26:57.706 --> 00:26:58.476
raise exceptions.

00:26:59.336 --> 00:27:00.326
If you're writing a Swift app,

00:27:00.326 --> 00:27:01.156
this is something you have to be

00:27:01.156 --> 00:27:01.656
mindful of.

00:27:02.406 --> 00:27:03.956
Swift can't catch Objective-C or

00:27:03.956 --> 00:27:06.046
C++ exceptions, and so this can

00:27:06.046 --> 00:27:07.146
lead to a fatal error in your

00:27:07.146 --> 00:27:07.296
app.

00:27:07.296 --> 00:27:08.946
Now again, this can lead to a

00:27:08.946 --> 00:27:10.936
crash and a bad experience our

00:27:10.936 --> 00:27:11.426
customers.

00:27:11.976 --> 00:27:14.946
If the decoding failure policy

00:27:14.946 --> 00:27:16.526
to set error and return, the

00:27:16.526 --> 00:27:17.596
error will be assigned to the

00:27:17.596 --> 00:27:18.886
Unarchiver's error property.

00:27:19.436 --> 00:27:20.906
And execution has to continue.

00:27:21.556 --> 00:27:22.666
And in this case, because

00:27:22.666 --> 00:27:24.296
execution does continue, the

00:27:24.296 --> 00:27:25.526
decode call has to return

00:27:25.966 --> 00:27:27.376
something, and so it will return

00:27:27.376 --> 00:27:29.086
nil to indicate that nothing

00:27:29.086 --> 00:27:29.726
could be decoded.

00:27:30.096 --> 00:27:32.666
And as mentioned, if you're

00:27:32.666 --> 00:27:33.996
decoding a primitive type, here

00:27:33.996 --> 00:27:35.876
and we find an object or a

00:27:35.876 --> 00:27:36.896
primitive type that's

00:27:36.896 --> 00:27:38.996
incompatible, the same series of

00:27:38.996 --> 00:27:39.966
steps has to happened.

00:27:39.966 --> 00:27:41.006
And in this case, instead of

00:27:41.006 --> 00:27:42.356
returning nil, we'll simply

00:27:42.356 --> 00:27:43.606
return 0.

00:27:44.236 --> 00:27:49.116
Now failWithError is API on

00:27:49.146 --> 00:27:50.716
NSKeyedUnarchiver, and we urge

00:27:50.716 --> 00:27:52.296
you to use in your own code to

00:27:52.296 --> 00:27:53.616
indicate when failures happen

00:27:53.726 --> 00:27:54.806
and what went wrong.

00:27:55.636 --> 00:27:56.966
Instead of simply returning nil,

00:27:57.216 --> 00:27:58.976
failWithError first to record

00:27:58.976 --> 00:27:59.686
that information.

00:28:00.256 --> 00:28:02.156
If you do, there are a few

00:28:02.156 --> 00:28:03.066
things to keep in mind.

00:28:04.466 --> 00:28:05.716
If the decoding failure policy

00:28:05.716 --> 00:28:07.166
is to set an error, and return,

00:28:07.536 --> 00:28:08.546
you have to keep in mind, that

00:28:08.546 --> 00:28:09.826
once an error is set on

00:28:09.826 --> 00:28:11.186
Unarchiver, it won't later be

00:28:11.186 --> 00:28:11.596
reset.

00:28:11.746 --> 00:28:14.616
And that's because one decoding

00:28:14.616 --> 00:28:16.366
failure often leads to a cascade

00:28:16.366 --> 00:28:17.306
of decoding failures.

00:28:17.406 --> 00:28:18.516
And we don't want to lose sight

00:28:18.516 --> 00:28:21.796
of what originally went wrong.

00:28:22.356 --> 00:28:24.226
Second, keep in mind that any

00:28:24.226 --> 00:28:25.776
given failWithError call, can

00:28:25.776 --> 00:28:26.976
either throw an exception or

00:28:26.976 --> 00:28:29.026
continue execution, so you have

00:28:29.026 --> 00:28:30.276
to keep both of those options in

00:28:30.276 --> 00:28:30.526
mind.

00:28:30.686 --> 00:28:31.666
Especially if you're working

00:28:31.666 --> 00:28:32.286
Objective-C.

00:28:32.286 --> 00:28:33.206
Maybe you can catch the

00:28:33.206 --> 00:28:33.656
exception.

00:28:34.266 --> 00:28:35.146
So, there's things to handle

00:28:35.146 --> 00:28:35.266
there.

00:28:35.886 --> 00:28:38.206
And lastly, keeping an eye out

00:28:38.326 --> 00:28:40.176
for nil, or 0 return values.

00:28:40.456 --> 00:28:41.806
This could either happen because

00:28:41.806 --> 00:28:43.106
of a decoding failure, if the

00:28:43.226 --> 00:28:44.406
decoding failure policy is to

00:28:44.406 --> 00:28:45.486
set an error and return.

00:28:46.006 --> 00:28:47.276
Or, the data could have just

00:28:47.276 --> 00:28:47.806
been missing.

00:28:48.166 --> 00:28:50.266
Or, even encoded as nil or 0.

00:28:51.056 --> 00:28:52.566
So, to disambiguate between

00:28:52.566 --> 00:28:53.706
these cases, check the error

00:28:53.706 --> 00:28:54.786
property on the Unarchiver.

00:28:54.856 --> 00:28:58.636
All right, so that was a lot of

00:28:58.636 --> 00:28:59.196
information.

00:28:59.926 --> 00:29:01.116
Let's distill this down into a

00:29:01.116 --> 00:29:02.326
checklist to see how we can

00:29:02.326 --> 00:29:03.826
adopt NSSecureCoding on our own

00:29:03.826 --> 00:29:04.206
types.

00:29:05.406 --> 00:29:06.726
We'll start by converting all

00:29:06.726 --> 00:29:08.516
decode object for key calls to

00:29:08.516 --> 00:29:09.466
the variant which allows us to

00:29:09.466 --> 00:29:10.906
pass in that type information up

00:29:10.906 --> 00:29:11.196
front.

00:29:11.196 --> 00:29:13.516
And then, if something goes

00:29:13.516 --> 00:29:14.846
wrong instead of just returning

00:29:14.846 --> 00:29:16.176
nil, let's failWithError to

00:29:16.176 --> 00:29:17.006
indicate what happened.

00:29:17.736 --> 00:29:19.466
And lastly, this is a great

00:29:19.466 --> 00:29:21.006
opportunity to audit for further

00:29:21.006 --> 00:29:22.356
points of failure, where we

00:29:22.356 --> 00:29:23.576
weren't performing validation

00:29:23.576 --> 00:29:23.916
before.

00:29:24.826 --> 00:29:26.506
So, let's do just that.

00:29:27.036 --> 00:29:29.076
So, here again is a decode call

00:29:29.186 --> 00:29:30.026
to decode a listing.

00:29:30.426 --> 00:29:31.366
And you'll notice that if we

00:29:31.426 --> 00:29:32.946
pass in that type information up

00:29:32.946 --> 00:29:34.746
front, the conditional downcast

00:29:34.746 --> 00:29:35.496
later can go away.

00:29:36.926 --> 00:29:38.056
There's a generic overload of

00:29:38.056 --> 00:29:39.626
this method, which when given

00:29:39.626 --> 00:29:40.946
the type information statically

00:29:41.176 --> 00:29:42.776
causes you to not have to

00:29:42.776 --> 00:29:44.066
conditionally downcast anymore.

00:29:44.146 --> 00:29:45.376
You'll always get an object of

00:29:45.376 --> 00:29:47.316
that class.

00:29:47.586 --> 00:29:49.416
Now, again, as we said, instead

00:29:49.416 --> 00:29:50.756
of returning nil on failure, we

00:29:50.756 --> 00:29:51.986
want to fail meaningfully.

00:29:52.536 --> 00:29:53.876
So, here we can fail with an

00:29:53.876 --> 00:29:55.536
error to indicate what went

00:29:55.536 --> 00:29:56.086
wrong and where.

00:29:56.086 --> 00:29:58.656
And in this case, we can use one

00:29:58.656 --> 00:29:59.676
of the conveniences on

00:29:59.676 --> 00:30:01.126
CocoaError to return a

00:30:01.126 --> 00:30:02.346
meaningful error that has a good

00:30:02.346 --> 00:30:03.496
localized description for our

00:30:03.496 --> 00:30:04.566
customers and that indicates

00:30:04.566 --> 00:30:06.976
what went wrong.

00:30:07.046 --> 00:30:07.766
We can always add a debug

00:30:07.766 --> 00:30:09.406
description for ourselves, to

00:30:09.406 --> 00:30:10.646
later log if we care to.

00:30:10.766 --> 00:30:11.846
But this is the core.

00:30:12.126 --> 00:30:13.606
We want to failWithError before

00:30:13.606 --> 00:30:14.136
returning nil.

00:30:14.676 --> 00:30:18.526
And then, later on, again, we

00:30:18.526 --> 00:30:19.826
were decoding the purchase date.

00:30:20.306 --> 00:30:22.206
And here, there is a great

00:30:22.206 --> 00:30:23.726
opportunity to add further

00:30:23.726 --> 00:30:24.826
validation where we weren't

00:30:24.826 --> 00:30:25.216
before.

00:30:26.616 --> 00:30:28.056
Here, if we can decode a date,

00:30:28.056 --> 00:30:29.276
well, I was simply storing the

00:30:29.276 --> 00:30:29.756
property.

00:30:30.516 --> 00:30:31.806
But instead, I want to make sure

00:30:31.806 --> 00:30:32.926
that that date is valid.

00:30:33.406 --> 00:30:34.356
For instance, a purchase

00:30:34.356 --> 00:30:35.686
couldn't possibly had been made

00:30:35.736 --> 00:30:37.026
before my app went live on the

00:30:37.026 --> 00:30:37.516
app store.

00:30:37.516 --> 00:30:38.676
So, this is something you could

00:30:38.676 --> 00:30:38.936
check.

00:30:39.286 --> 00:30:40.266
And again, if something goes

00:30:40.266 --> 00:30:42.286
wrong here, we want to fail with

00:30:42.286 --> 00:30:43.096
a meaningful error.

00:30:44.236 --> 00:30:45.256
In this case, it wasn't that the

00:30:45.256 --> 00:30:46.656
data was missing, it was that

00:30:46.656 --> 00:30:47.786
the data was corrupted or

00:30:47.786 --> 00:30:48.656
invalid in some way.

00:30:48.656 --> 00:30:49.736
And so, we'll indicate just

00:30:49.736 --> 00:30:49.926
that.

00:30:49.966 --> 00:30:54.786
Now, that we've gone ahead and

00:30:54.786 --> 00:30:56.136
done exactly this on our type,

00:30:56.796 --> 00:30:58.716
we can go ahead and claim that

00:30:58.716 --> 00:30:59.836
it supports secure coding.

00:31:00.576 --> 00:31:02.266
And lastly, conform to the

00:31:02.266 --> 00:31:03.976
NSSecureCoding protocol instead

00:31:03.976 --> 00:31:05.536
to indicate to the runtime that

00:31:05.536 --> 00:31:06.506
this is what we intended.

00:31:06.506 --> 00:31:07.846
It really does support secure

00:31:07.846 --> 00:31:08.126
coding.

00:31:08.836 --> 00:31:11.526
And after that, well,

00:31:12.146 --> 00:31:13.006
congratulations.

00:31:13.006 --> 00:31:14.366
We've earned our NSSecureCoding

00:31:14.366 --> 00:31:14.666
badge.

00:31:15.026 --> 00:31:15.876
Physical badge is sold

00:31:15.876 --> 00:31:16.276
separately.

00:31:18.046 --> 00:31:20.606
Now, we think it's so important

00:31:20.606 --> 00:31:21.856
for you to earn your own

00:31:21.856 --> 00:31:23.276
NSSecureCoding badges and use

00:31:23.276 --> 00:31:25.036
them that this year, we've added

00:31:25.086 --> 00:31:26.776
new API and NSKeyedUnarchiver to

00:31:26.776 --> 00:31:28.426
make sure that NSSecureCoding is

00:31:28.426 --> 00:31:29.506
done wherever possible.

00:31:31.276 --> 00:31:32.456
This new initializer and

00:31:32.456 --> 00:31:33.936
convenience methods, turns on

00:31:33.936 --> 00:31:35.746
secure coding by default and

00:31:35.746 --> 00:31:37.126
sets the default decoding

00:31:37.126 --> 00:31:38.516
failure policy to set error in

00:31:38.516 --> 00:31:38.866
return.

00:31:39.346 --> 00:31:40.236
So, unless you change the

00:31:40.236 --> 00:31:41.536
decoding failure policy on your

00:31:41.536 --> 00:31:42.576
own, you don't have to worry

00:31:42.576 --> 00:31:43.736
about exceptions in Swift.

00:31:43.736 --> 00:31:47.316
And indeed, the old initializer

00:31:47.316 --> 00:31:48.776
and convenience methods are

00:31:48.776 --> 00:31:50.186
deprecated in favor of these

00:31:50.186 --> 00:31:50.736
versions.

00:31:50.956 --> 00:31:51.996
So, we really want you to use

00:31:51.996 --> 00:31:52.146
them.

00:31:53.726 --> 00:31:55.106
And similarly, we've introduced

00:31:55.106 --> 00:31:56.066
the same APIs on

00:31:56.096 --> 00:31:58.066
NSKeyedUnarchiver, to make it

00:31:58.066 --> 00:31:58.996
easier for you to turn

00:31:58.996 --> 00:32:00.426
SecureCoding on when archiving.

00:32:00.426 --> 00:32:01.636
And this is equally important

00:32:02.116 --> 00:32:03.386
because it makes sure you can't

00:32:03.386 --> 00:32:05.026
accidentally archive an object

00:32:05.336 --> 00:32:06.336
which doesn't conform to

00:32:06.336 --> 00:32:07.136
NSSecureCoding.

00:32:07.406 --> 00:32:08.616
And you wouldn't later able to

00:32:08.616 --> 00:32:09.096
decode it.

00:32:10.096 --> 00:32:11.786
And again, the old initializer

00:32:11.786 --> 00:32:12.816
and convenience methods are

00:32:12.816 --> 00:32:13.386
deprecated.

00:32:13.896 --> 00:32:14.856
And so, this means that if you

00:32:14.856 --> 00:32:15.996
have old code that looks like

00:32:16.036 --> 00:32:19.026
this, well turn on SecureCoding

00:32:19.026 --> 00:32:19.716
when archiving.

00:32:20.446 --> 00:32:21.716
And switch to the convenience

00:32:21.716 --> 00:32:22.986
methods that allow you to pass

00:32:22.986 --> 00:32:23.946
in that type information

00:32:23.946 --> 00:32:24.346
upfront.

00:32:25.606 --> 00:32:26.826
This way, you can actually make

00:32:26.826 --> 00:32:28.166
use of your SecureCoding badge.

00:32:28.676 --> 00:32:29.486
Make sure you've earned it.

00:32:31.116 --> 00:32:32.636
Now, if you can't yet support

00:32:32.636 --> 00:32:33.956
SecureCoding, because your types

00:32:33.956 --> 00:32:35.876
can't conform, or they,

00:32:35.876 --> 00:32:37.226
themselves depend on types which

00:32:37.226 --> 00:32:38.596
don't yet conform, that's okay.

00:32:38.706 --> 00:32:39.996
You can still use these methods.

00:32:40.756 --> 00:32:42.666
On nCode, simply turn off the

00:32:42.666 --> 00:32:43.756
secure coding requirement.

00:32:44.226 --> 00:32:45.396
And on decode, these

00:32:45.396 --> 00:32:46.666
conveniences always have

00:32:46.666 --> 00:32:47.586
SecureCoding enabled.

00:32:48.836 --> 00:32:50.096
So, instead use the new

00:32:50.096 --> 00:32:51.196
initializer to create a

00:32:51.196 --> 00:32:52.816
KeyedUnarchiver, and then turn

00:32:52.816 --> 00:32:54.476
SecureCoding off, manually.

00:32:55.776 --> 00:32:56.536
This also gives you the

00:32:56.536 --> 00:32:58.026
opportunity to reset the

00:32:58.026 --> 00:32:59.456
decoding failure policy back to

00:32:59.456 --> 00:33:01.586
the old default in case you need

00:33:02.386 --> 00:33:02.466
it.

00:33:02.966 --> 00:33:03.806
Once you have such an

00:33:03.806 --> 00:33:05.416
Unarchiver, well you can decode

00:33:05.416 --> 00:33:06.026
as usual.

00:33:06.686 --> 00:33:09.916
Now, if you're working on a

00:33:09.916 --> 00:33:11.976
Swift app, NSSecureCoding isn't

00:33:11.976 --> 00:33:13.306
the only way for you to convert

00:33:13.306 --> 00:33:14.836
your own model types to external

00:33:14.836 --> 00:33:17.016
representations and back.

00:33:17.726 --> 00:33:18.906
Last year with Swift 4, we

00:33:18.906 --> 00:33:20.246
introduced the Codable protocols

00:33:20.246 --> 00:33:21.636
which make it easier to do just

00:33:21.636 --> 00:33:21.836
that.

00:33:21.836 --> 00:33:24.696
And importantly, all the design

00:33:24.696 --> 00:33:26.026
decisions that made their way

00:33:26.186 --> 00:33:28.126
into NSSecureCoding were also

00:33:28.126 --> 00:33:29.646
present in Codable from day one.

00:33:30.796 --> 00:33:32.956
Specifically, Codable never

00:33:32.956 --> 00:33:34.166
writes type information into

00:33:34.166 --> 00:33:34.806
archives.

00:33:35.096 --> 00:33:36.146
So, there's nothing to trust

00:33:36.146 --> 00:33:36.576
later on.

00:33:36.576 --> 00:33:38.796
By requiring you to pass in

00:33:38.796 --> 00:33:40.446
static type information upfront

00:33:40.446 --> 00:33:41.976
about what you expect to decode,

00:33:42.376 --> 00:33:43.696
you can prevent exactly this

00:33:43.696 --> 00:33:44.966
sort of attack.

00:33:45.776 --> 00:33:47.396
Now, Codable also comes with

00:33:47.426 --> 00:33:48.196
conveniences.

00:33:48.196 --> 00:33:49.626
If you have a type whose fields

00:33:49.626 --> 00:33:51.366
are all themselves codable, well

00:33:51.366 --> 00:33:52.406
you'll get a synthesized

00:33:52.406 --> 00:33:53.706
implementation of the init from

00:33:53.706 --> 00:33:54.886
and encode to requirements.

00:33:55.806 --> 00:33:56.716
And the synthesized

00:33:56.716 --> 00:33:58.086
implementation gives you type

00:33:58.086 --> 00:33:59.236
and nullability checking for

00:33:59.236 --> 00:33:59.546
free.

00:34:00.236 --> 00:34:01.696
But as we saw, most types

00:34:01.696 --> 00:34:03.276
require additional validation if

00:34:03.276 --> 00:34:04.596
they come from external sources,

00:34:04.626 --> 00:34:05.446
just like ours do.

00:34:06.586 --> 00:34:07.896
So, we need to further validate

00:34:07.896 --> 00:34:08.156
those.

00:34:09.366 --> 00:34:11.585
So, we can do that for our own

00:34:11.585 --> 00:34:12.856
types by overwriting in it with

00:34:13.085 --> 00:34:13.916
init from decoder.

00:34:13.996 --> 00:34:15.985
And in this case, again, here's

00:34:15.985 --> 00:34:17.466
that JSON response from earlier.

00:34:17.656 --> 00:34:18.996
And I can trivially turn it into

00:34:18.996 --> 00:34:20.386
a Codable type by simply

00:34:20.386 --> 00:34:21.376
creating a type with all the

00:34:21.376 --> 00:34:22.366
same name fields.

00:34:23.726 --> 00:34:24.606
Because all these fields are

00:34:24.606 --> 00:34:26.216
codable, I get that free

00:34:26.216 --> 00:34:27.545
implementation of init from and

00:34:27.545 --> 00:34:27.996
encode to.

00:34:28.886 --> 00:34:30.005
But, I want to override init

00:34:30.005 --> 00:34:31.436
from to make sure I'm performing

00:34:31.436 --> 00:34:32.596
the same validation that I was

00:34:32.596 --> 00:34:33.516
before with the primitive

00:34:33.516 --> 00:34:33.936
values.

00:34:34.676 --> 00:34:36.716
So, I can do that here, the same

00:34:36.716 --> 00:34:36.886
way.

00:34:38.536 --> 00:34:40.926
Where my old code decoded the ID

00:34:41.016 --> 00:34:42.866
from the payload by downcasting

00:34:42.866 --> 00:34:44.846
to an int, I can do similarly

00:34:44.896 --> 00:34:46.646
here by decoding an int from the

00:34:46.646 --> 00:34:47.025
decoder.

00:34:48.496 --> 00:34:50.366
If the type found in the payload

00:34:50.676 --> 00:34:52.226
is of a different type or is

00:34:52.226 --> 00:34:53.315
missing, this will throw an

00:34:53.315 --> 00:34:54.295
error that indicates what

00:34:54.295 --> 00:34:54.656
happened.

00:34:55.246 --> 00:34:58.866
Now, more important than that is

00:34:58.866 --> 00:35:00.166
my own validation that I added

00:35:00.166 --> 00:35:01.186
in that validate method.

00:35:01.926 --> 00:35:03.406
Here, I want to make sure I keep

00:35:03.406 --> 00:35:04.816
performing that same validation

00:35:04.816 --> 00:35:06.336
to make sure the ID is valid.

00:35:06.546 --> 00:35:07.336
And here, I can use a

00:35:07.336 --> 00:35:08.616
convenience method to throw a

00:35:08.616 --> 00:35:10.096
meaningful error that indicates

00:35:10.976 --> 00:35:12.946
what happened.

00:35:13.476 --> 00:35:14.866
Now, later in that validate

00:35:14.866 --> 00:35:16.316
function I might've pulled that

00:35:16.316 --> 00:35:18.026
creation date out as a string

00:35:18.026 --> 00:35:19.616
and then had to pass it along to

00:35:19.616 --> 00:35:22.586
a date formatter to get a valid

00:35:22.586 --> 00:35:25.186
date back out.

00:35:25.396 --> 00:35:26.836
Here, because we can use JSON

00:35:26.836 --> 00:35:29.156
decoder, we can simply decode a

00:35:29.156 --> 00:35:30.336
date directly, we don't have to

00:35:30.336 --> 00:35:31.416
worry about that type

00:35:31.446 --> 00:35:31.926
conversion.

00:35:32.766 --> 00:35:34.266
We can use JSON decoders date

00:35:34.296 --> 00:35:36.556
decoding policy to indicate what

00:35:36.556 --> 00:35:37.816
sort of conversion can happen

00:35:37.816 --> 00:35:37.936
here.

00:35:38.186 --> 00:35:40.386
And this is nice because this

00:35:40.386 --> 00:35:41.636
conversion became a one-liner.

00:35:42.796 --> 00:35:44.626
And, the other decode call is

00:35:44.626 --> 00:35:46.156
also a one-liner, which makes it

00:35:46.156 --> 00:35:47.496
easy for me to focus on the

00:35:47.496 --> 00:35:48.946
types of validation that I care

00:35:49.536 --> 00:35:49.726
about.

00:35:51.056 --> 00:35:52.706
Now, later on in the validate

00:35:52.706 --> 00:35:53.786
function, I might have also

00:35:53.786 --> 00:35:55.316
pulled out that substructure of

00:35:55.316 --> 00:35:57.126
tags out as an array of strings,

00:35:57.336 --> 00:35:58.876
and later had to map those

00:35:58.876 --> 00:36:00.496
strings to my own type, maybe

00:36:00.586 --> 00:36:02.026
for further validation later on.

00:36:04.026 --> 00:36:05.736
Here, again with Codable, I have

00:36:05.736 --> 00:36:07.286
the benefit of tag conforming to

00:36:07.286 --> 00:36:08.126
Codable itself.

00:36:08.126 --> 00:36:09.806
And so, I can just decode an

00:36:09.806 --> 00:36:10.816
array of tags directly.

00:36:11.726 --> 00:36:12.846
This happens automatically.

00:36:12.846 --> 00:36:14.356
And instead of focusing on the

00:36:14.356 --> 00:36:15.456
type conversion, allows me to

00:36:15.456 --> 00:36:16.776
focus on the validation that

00:36:16.776 --> 00:36:17.386
matters to me.

00:36:18.236 --> 00:36:19.416
This lets me make sure that this

00:36:19.466 --> 00:36:20.686
data is data I can trust.

00:36:24.156 --> 00:36:25.966
We talked about a lot today.

00:36:27.196 --> 00:36:28.636
We started with raw data and

00:36:28.636 --> 00:36:30.326
carried it all away across the

00:36:30.326 --> 00:36:31.776
abstraction spectrum to our own

00:36:31.776 --> 00:36:32.476
model types.

00:36:32.716 --> 00:36:34.486
And along the way we saw how to

00:36:34.486 --> 00:36:38.456
build trust into that data by

00:36:38.676 --> 00:36:40.496
validating a checksum, or the

00:36:40.496 --> 00:36:42.056
length on that raw data, we made

00:36:42.056 --> 00:36:43.366
sure that it was valid to work

00:36:43.366 --> 00:36:45.226
with an inspect, and even check

00:36:45.716 --> 00:36:46.666
whether it conforms to some

00:36:46.666 --> 00:36:47.046
format.

00:36:47.356 --> 00:36:48.556
Once we've made sure that it

00:36:48.556 --> 00:36:50.746
conforms to a known format, we

00:36:50.746 --> 00:36:52.636
knew that that formatted data

00:36:52.636 --> 00:36:54.376
was valid to work with and pull

00:36:54.446 --> 00:36:55.466
primitive values out of.

00:36:57.196 --> 00:36:59.106
By validating the contents and

00:36:59.106 --> 00:37:00.476
structure of those primitive

00:37:00.476 --> 00:37:02.006
values, we made sure that it was

00:37:02.006 --> 00:37:03.346
valid to work with them to turn

00:37:03.346 --> 00:37:05.026
them into our own model types.

00:37:06.476 --> 00:37:07.966
By validating the semantics and

00:37:07.966 --> 00:37:09.216
relationships between those

00:37:09.216 --> 00:37:10.846
model types, we made sure that

00:37:10.846 --> 00:37:12.166
they were valid to work with and

00:37:12.166 --> 00:37:13.076
that they were data we could

00:37:13.766 --> 00:37:13.946
trust.

00:37:15.216 --> 00:37:16.746
So, where to go from here?

00:37:18.116 --> 00:37:19.136
Well, now that you know all of

00:37:19.136 --> 00:37:20.346
this, I encourage you to go and

00:37:20.346 --> 00:37:21.926
look at your code and do just

00:37:21.926 --> 00:37:22.286
this.

00:37:23.386 --> 00:37:26.426
Validate data at every stage in

00:37:26.426 --> 00:37:27.476
the lifecycle of that data.

00:37:28.046 --> 00:37:29.406
Check for types and nullability.

00:37:29.646 --> 00:37:30.916
But more importantly, range, and

00:37:30.916 --> 00:37:32.186
length, and domain-specific

00:37:32.186 --> 00:37:32.926
applications.

00:37:33.516 --> 00:37:35.956
If you have NSCoding types,

00:37:36.246 --> 00:37:37.736
audit those types and earn your

00:37:37.796 --> 00:37:38.816
NSSecureCoding badge.

00:37:38.936 --> 00:37:40.186
And don't just earn it, use it.

00:37:40.286 --> 00:37:41.786
Turn on secure coding wherever

00:37:41.786 --> 00:37:42.146
you can.

00:37:43.656 --> 00:37:45.596
And lastly, for new data types,

00:37:45.666 --> 00:37:47.556
adopt Codable where possible and

00:37:47.556 --> 00:37:48.826
make sure to perform that

00:37:48.826 --> 00:37:49.456
validation.

00:37:50.246 --> 00:37:51.556
Make sure you're only ever

00:37:51.556 --> 00:37:53.826
working with data you can trust.

00:37:54.936 --> 00:37:56.026
For more information about

00:37:56.026 --> 00:37:57.926
Codable, specifically, see last

00:37:57.926 --> 00:37:58.976
year's talk about What's New in

00:37:58.976 --> 00:37:59.486
Foundation.

00:37:59.716 --> 00:38:01.076
But if you have more questions

00:38:01.076 --> 00:38:02.346
about this topic or want to come

00:38:02.346 --> 00:38:04.136
to us for help on how to apply

00:38:04.136 --> 00:38:05.626
this in your own apps, come to

00:38:05.626 --> 00:38:06.766
our lab later today, we have a

00:38:06.766 --> 00:38:07.816
foundation lab, where we can

00:38:07.816 --> 00:38:09.446
help you do just that.

00:38:10.096 --> 00:38:11.636
With that, I'd like to say thank

00:38:11.636 --> 00:38:12.066
you very much.

00:38:13.266 --> 00:38:13.716
Have a great day.

00:38:14.516 --> 00:38:17.500
[ Applause ]
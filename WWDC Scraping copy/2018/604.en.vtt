WEBVTT

00:00:07.516 --> 00:00:15.500
[ Music ]

00:00:21.516 --> 00:00:27.776
[ Applause ]

00:00:28.276 --> 00:00:28.666
>> Thank you.

00:00:29.326 --> 00:00:30.746
My name is Dan Omachi, I'm an

00:00:30.746 --> 00:00:32.036
engineer in Apple's Metal

00:00:32.086 --> 00:00:32.946
Ecosystem Team.

00:00:33.606 --> 00:00:35.536
Now my main role on that team is

00:00:35.536 --> 00:00:37.136
to help developers learn Metal

00:00:37.136 --> 00:00:38.346
and have a great experience

00:00:38.346 --> 00:00:38.766
using it.

00:00:39.476 --> 00:00:41.326
But prior to this I worked on

00:00:41.326 --> 00:00:43.456
Apple's OpenGL and OpenGL ES

00:00:43.636 --> 00:00:44.686
frameworks for many years.

00:00:45.086 --> 00:00:46.716
And even before joining Apple I

00:00:46.716 --> 00:00:47.746
worked on a couple of other

00:00:47.746 --> 00:00:48.936
OpenGL implementations.

00:00:50.926 --> 00:00:53.286
So I'm really proud of what

00:00:53.446 --> 00:00:55.576
we've accomplished with OpenGL

00:00:55.736 --> 00:00:57.866
over the past years, but I'm

00:00:57.866 --> 00:00:59.976
also really excited about the

00:00:59.976 --> 00:01:02.166
direction Metal's taking us.

00:01:02.936 --> 00:01:04.726
Today my colleague Sukanya

00:01:04.726 --> 00:01:05.906
Sudugu and I are going to give

00:01:05.906 --> 00:01:07.556
you a brief introduction to

00:01:07.556 --> 00:01:10.066
Metal and provide some guidance

00:01:10.456 --> 00:01:12.526
about how you can easily port

00:01:12.526 --> 00:01:15.156
your OpenGL apps over.

00:01:15.386 --> 00:01:16.906
Now this is particularly

00:01:16.906 --> 00:01:19.016
important this year because as

00:01:19.016 --> 00:01:20.876
announced in yesterday's state

00:01:20.876 --> 00:01:23.466
of the union OpenGL, openGL ES

00:01:23.676 --> 00:01:25.366
and OpenCL are deprecated.

00:01:26.336 --> 00:01:28.206
Now existing and soon-to-be

00:01:28.206 --> 00:01:30.346
launched apps can still use

00:01:30.716 --> 00:01:35.006
OpenGL ES on tvOS and iOS12 and

00:01:35.636 --> 00:01:40.706
OpenGL and OpenCL on macOS 10.14

00:01:40.706 --> 00:01:43.326
Mojave and this will remain so

00:01:43.926 --> 00:01:44.626
for some time.

00:01:45.476 --> 00:01:48.286
However, new projects should

00:01:48.286 --> 00:01:49.906
target Metal from their

00:01:49.906 --> 00:01:50.486
inception.

00:01:51.026 --> 00:01:51.886
So if you're not already

00:01:51.886 --> 00:01:53.446
familiar with Metal, then it's

00:01:53.446 --> 00:01:54.156
time to get started.

00:01:55.806 --> 00:01:56.886
Before you rip out all of your

00:01:56.886 --> 00:01:58.416
OpenGL code and start porting it

00:01:58.416 --> 00:01:59.526
all to Metal you've got a few

00:01:59.526 --> 00:02:00.446
options to consider.

00:02:01.376 --> 00:02:03.156
Apple offers several high-level

00:02:03.226 --> 00:02:04.906
frameworks that do rendering,

00:02:05.466 --> 00:02:06.446
different kinds of rendering,

00:02:06.836 --> 00:02:08.846
SpriteKit for 2D games, SceneKit

00:02:08.846 --> 00:02:10.756
for some 3D, Core Image for

00:02:10.756 --> 00:02:11.966
great effects.

00:02:13.526 --> 00:02:15.456
Also, each of the major

00:02:15.566 --> 00:02:17.366
third-party game engines already

00:02:17.366 --> 00:02:19.176
use Metal as their primary

00:02:19.176 --> 00:02:19.596
renderer.

00:02:20.776 --> 00:02:22.886
But you may decide that these

00:02:22.886 --> 00:02:24.426
approaches just aren't for you

00:02:24.756 --> 00:02:25.866
and the path forward is to do it

00:02:25.866 --> 00:02:28.086
yourself in Metal, that's what

00:02:28.086 --> 00:02:30.416
we'll talk about today.

00:02:30.566 --> 00:02:31.746
So let's start out with Metal

00:02:31.746 --> 00:02:33.416
design and some fundamental

00:02:33.416 --> 00:02:33.966
concepts.

00:02:35.536 --> 00:02:37.246
So OpenGL was originally

00:02:37.246 --> 00:02:39.326
designed 25 years ago and its

00:02:39.366 --> 00:02:41.286
core reflects the origins of

00:02:41.286 --> 00:02:42.736
hardware accelerated 3D

00:02:42.736 --> 00:02:43.226
graphics.

00:02:44.696 --> 00:02:46.676
So updates with new versions and

00:02:46.676 --> 00:02:48.266
extensions have really served us

00:02:48.266 --> 00:02:49.766
well by exposing new GPU

00:02:49.836 --> 00:02:51.146
features and performance

00:02:51.146 --> 00:02:51.666
techniques.

00:02:52.806 --> 00:02:54.436
However, there are still some

00:02:54.436 --> 00:02:56.276
fundamental design choices that

00:02:56.276 --> 00:02:58.016
no longer apply to current

00:02:58.016 --> 00:02:58.396
hardware.

00:03:00.856 --> 00:03:02.326
The OpenGL pipeline was

00:03:02.326 --> 00:03:03.826
originally an entirely fixed

00:03:03.826 --> 00:03:05.746
function and although today

00:03:05.746 --> 00:03:07.526
OpenGL supports a programmable

00:03:07.526 --> 00:03:09.726
pipeline it doesn't neatly match

00:03:09.786 --> 00:03:12.826
that of modern GPUs.

00:03:13.036 --> 00:03:15.356
Also, asynchronous processing is

00:03:15.356 --> 00:03:16.726
not a core feature of the API,

00:03:17.476 --> 00:03:18.436
there are a number of features

00:03:18.436 --> 00:03:19.576
which allude to the fact that

00:03:19.576 --> 00:03:20.656
the GPU works in parallel with

00:03:20.656 --> 00:03:22.076
your app but much of this is

00:03:22.076 --> 00:03:22.586
implicit.

00:03:23.046 --> 00:03:26.586
And 25 years ago only the most

00:03:26.586 --> 00:03:27.766
expensive workstations and

00:03:27.766 --> 00:03:29.186
servers had multiple cores.

00:03:29.676 --> 00:03:30.956
So designing an efficient

00:03:30.956 --> 00:03:32.716
multithreading model wasn't a

00:03:32.716 --> 00:03:33.216
priority.

00:03:33.216 --> 00:03:37.516
So back in 2014, it was clear to

00:03:37.516 --> 00:03:39.116
us that a new application

00:03:39.116 --> 00:03:40.286
interface for the GPU was

00:03:40.286 --> 00:03:40.836
necessary.

00:03:41.696 --> 00:03:42.856
Obviously, we needed an

00:03:42.856 --> 00:03:44.176
interface that could efficiently

00:03:44.176 --> 00:03:45.406
harness the GPU's power.

00:03:46.576 --> 00:03:48.076
To do that the app needed the

00:03:48.076 --> 00:03:49.826
CPU out of the way so the GPU

00:03:49.826 --> 00:03:51.946
could do its thing.

00:03:52.146 --> 00:03:53.836
But when an app needs the CPU

00:03:53.836 --> 00:03:54.976
for rendering it needs to be

00:03:54.976 --> 00:03:56.466
able to use all of the CPU,

00:03:56.906 --> 00:03:58.176
including its multiple cores.

00:03:59.626 --> 00:04:01.146
If the interface needed to be

00:04:01.146 --> 00:04:02.416
predictable to prevent

00:04:02.716 --> 00:04:04.056
developers from falling into

00:04:04.136 --> 00:04:08.586
hidden pitfalls in the API every

00:04:08.586 --> 00:04:09.926
call should have an obvious

00:04:09.926 --> 00:04:12.146
consequence and few operations

00:04:12.206 --> 00:04:13.846
should be performed implicitly.

00:04:14.336 --> 00:04:16.476
Part of this predictability

00:04:16.576 --> 00:04:17.805
would be the need to control

00:04:17.805 --> 00:04:19.916
where resources were placed and

00:04:19.956 --> 00:04:21.826
if and when synchronization was

00:04:21.826 --> 00:04:22.376
necessary.

00:04:22.966 --> 00:04:26.156
Now Apple had a few other

00:04:26.156 --> 00:04:26.686
requirements.

00:04:27.896 --> 00:04:29.456
We wanted this interface to be

00:04:29.456 --> 00:04:31.416
approachable, it needed to have

00:04:31.416 --> 00:04:32.536
the right balance between

00:04:32.536 --> 00:04:34.306
low-level control and clear

00:04:34.306 --> 00:04:36.436
usage because the easier it is

00:04:36.436 --> 00:04:37.556
for you to understand something

00:04:37.876 --> 00:04:39.156
the more effectively and

00:04:39.206 --> 00:04:40.566
efficiently you can use it.

00:04:41.976 --> 00:04:43.766
And of course, we designed Metal

00:04:43.766 --> 00:04:46.516
to map well to all modern GPUs.

00:04:46.516 --> 00:04:49.486
In particular, we knew that

00:04:49.486 --> 00:04:50.446
hardware coming down the

00:04:50.496 --> 00:04:52.666
pipeline needed software that

00:04:52.666 --> 00:04:53.216
could push it.

00:04:53.906 --> 00:04:55.556
This included the Apple designed

00:04:55.696 --> 00:04:58.486
GPU of the A11 bionic.

00:04:59.956 --> 00:05:01.326
So how is Metal different than

00:05:01.326 --> 00:05:01.736
OpenGL?

00:05:02.196 --> 00:05:03.556
Well you perform the most

00:05:03.626 --> 00:05:06.036
expensive operations less often.

00:05:07.046 --> 00:05:08.236
Objects are designed in such a

00:05:08.236 --> 00:05:09.916
way that API state can be

00:05:09.916 --> 00:05:12.226
translated and prepackaged into

00:05:12.226 --> 00:05:13.926
GPU commands at creation.

00:05:15.726 --> 00:05:17.406
This way, there's much less cost

00:05:17.406 --> 00:05:18.556
to use them later on when

00:05:18.556 --> 00:05:19.266
actually rendering.

00:05:20.576 --> 00:05:21.656
The graphics pipeline with

00:05:21.686 --> 00:05:23.286
Vertex and fragment shaders also

00:05:23.286 --> 00:05:24.756
reflects the modern GPU.

00:05:25.716 --> 00:05:27.396
So it's less costly to translate

00:05:27.516 --> 00:05:29.526
the API's configuration to GP

00:05:29.526 --> 00:05:29.986
commands.

00:05:31.236 --> 00:05:32.926
This doesn't mean the pipeline

00:05:32.926 --> 00:05:34.296
is entirely different or

00:05:34.296 --> 00:05:35.666
requires some whole new way of

00:05:35.666 --> 00:05:36.026
thinking.

00:05:36.946 --> 00:05:38.256
The main difference in Metal is

00:05:38.256 --> 00:05:39.406
that the grouping of the

00:05:39.436 --> 00:05:41.686
pipeline stages into objects is

00:05:41.686 --> 00:05:43.326
more efficient, not that the

00:05:43.326 --> 00:05:45.396
pipeline itself is changed.

00:05:46.816 --> 00:05:49.366
Metal also has a clear model for

00:05:49.366 --> 00:05:50.616
multithreaded execution.

00:05:51.496 --> 00:05:52.356
There are a number of different

00:05:52.356 --> 00:05:53.976
ways for applications to drive

00:05:53.976 --> 00:05:55.796
the GPU from different threads,

00:05:56.286 --> 00:05:57.906
but for each there are explicit

00:05:57.996 --> 00:05:59.456
but unconstraining rules to do

00:05:59.456 --> 00:05:59.686
this.

00:06:01.036 --> 00:06:02.546
Additionally, the most commonly

00:06:02.546 --> 00:06:03.836
used objects like textures,

00:06:03.936 --> 00:06:05.936
buffers and shaders can safely

00:06:05.936 --> 00:06:07.346
and efficiently be used across

00:06:07.406 --> 00:06:07.726
threads.

00:06:08.526 --> 00:06:10.156
Metal does not need to perform

00:06:10.326 --> 00:06:11.776
any expensive internal logging

00:06:11.776 --> 00:06:13.306
operations to prevent these

00:06:13.306 --> 00:06:14.546
objects from getting into some

00:06:14.546 --> 00:06:15.456
invalid state.

00:06:17.516 --> 00:06:19.616
Finally, the execution model

00:06:19.616 --> 00:06:21.036
reflects what really goes on

00:06:21.076 --> 00:06:22.696
between software and the GPU.

00:06:23.266 --> 00:06:24.926
Many of the implicit operations

00:06:25.046 --> 00:06:26.406
performed by OpenGL are

00:06:26.406 --> 00:06:28.116
explicitly performed by an

00:06:28.116 --> 00:06:29.886
application using Metal.

00:06:30.636 --> 00:06:31.836
This allows you to make

00:06:31.836 --> 00:06:33.666
intelligent decisions as to when

00:06:33.666 --> 00:06:35.966
and how your app uses the GPU.

00:06:36.946 --> 00:06:37.966
It also means there's less

00:06:37.966 --> 00:06:39.036
software between your

00:06:39.036 --> 00:06:40.586
application and the GPU.

00:06:41.216 --> 00:06:43.286
Most Metal calls go directly to

00:06:43.286 --> 00:06:45.096
the GPU driver and that driver

00:06:45.096 --> 00:06:46.726
also needs to do less processing

00:06:46.726 --> 00:06:48.746
to translate from API calls to

00:06:48.746 --> 00:06:49.526
GPU commands.

00:06:51.216 --> 00:06:52.216
So let's dive in and see how

00:06:52.216 --> 00:06:52.636
this works.

00:06:53.256 --> 00:06:56.466
All GL calls are performed on an

00:06:56.466 --> 00:06:57.506
OpenGL context.

00:06:57.916 --> 00:06:59.846
The context does a ton of

00:06:59.846 --> 00:07:01.966
things, it tracks API state, it

00:07:02.166 --> 00:07:03.766
manages OpenGL objects and other

00:07:03.766 --> 00:07:05.246
memory, and translates and

00:07:05.246 --> 00:07:06.506
submits GPU commands.

00:07:07.366 --> 00:07:09.066
Metal splits all of these jobs

00:07:09.066 --> 00:07:10.626
of an OpenGL context into a

00:07:10.626 --> 00:07:12.956
number of smaller objects.

00:07:14.056 --> 00:07:16.336
The first object that creates is

00:07:16.336 --> 00:07:18.616
a Metal device which is an

00:07:18.716 --> 00:07:20.626
abstract representation of a

00:07:20.776 --> 00:07:21.686
physical GPU.

00:07:22.256 --> 00:07:26.286
The device creates objects such

00:07:26.286 --> 00:07:27.646
as textures, buffers and

00:07:27.646 --> 00:07:29.216
pipeline objects which contain

00:07:29.216 --> 00:07:29.906
shaders.

00:07:31.026 --> 00:07:32.886
It also creates a key object

00:07:33.136 --> 00:07:34.636
called a Metal command queue.

00:07:35.196 --> 00:07:37.816
The command queue really only

00:07:37.816 --> 00:07:39.796
has one job, to create a

00:07:39.796 --> 00:07:41.176
sequence of command buffers.

00:07:41.956 --> 00:07:43.506
Here we've created one command

00:07:43.506 --> 00:07:44.856
buffer and a command buffer is

00:07:44.856 --> 00:07:46.706
simply a list of GPU commands

00:07:46.956 --> 00:07:48.956
that your app will fill and send

00:07:48.956 --> 00:07:50.146
to the GPU for execution.

00:07:51.166 --> 00:07:52.836
Typically your app will create a

00:07:52.836 --> 00:07:54.926
single command buffer per frame,

00:07:55.016 --> 00:07:55.866
however, there are some

00:07:55.866 --> 00:07:57.566
situations where it makes sense

00:07:57.696 --> 00:08:00.166
to create two or three in a

00:08:00.696 --> 00:08:00.886
frame.

00:08:01.026 --> 00:08:02.256
But an app doesn't write these

00:08:02.256 --> 00:08:03.606
commands directly to the command

00:08:03.606 --> 00:08:05.216
buffer, instead it creates a

00:08:05.216 --> 00:08:06.586
Metal command encoder.

00:08:07.886 --> 00:08:09.356
The command encoder translates

00:08:09.446 --> 00:08:11.686
API calls into GPU instructions

00:08:11.906 --> 00:08:13.006
and writes them to the command

00:08:13.006 --> 00:08:13.266
buffer.

00:08:14.336 --> 00:08:15.666
After a series of commands have

00:08:15.666 --> 00:08:17.426
been encoded your app will end

00:08:17.426 --> 00:08:18.916
encoding and release the encoder

00:08:18.916 --> 00:08:19.336
object.

00:08:20.536 --> 00:08:21.586
There are actually a couple

00:08:21.586 --> 00:08:22.756
different kind of encoders and

00:08:22.756 --> 00:08:24.146
your app can create new encoders

00:08:24.146 --> 00:08:25.106
from the command buffer to

00:08:25.146 --> 00:08:25.876
encode more commands.

00:08:31.156 --> 00:08:32.616
Now it's important to note that

00:08:32.616 --> 00:08:34.346
up until now on this diagram the

00:08:34.346 --> 00:08:36.186
GPU hasn't done any work.

00:08:37.106 --> 00:08:38.666
Metal has created objects and

00:08:38.666 --> 00:08:40.726
encoded commands all with the

00:08:40.775 --> 00:08:41.145
CPU.

00:08:41.876 --> 00:08:43.166
It's only after your app has

00:08:43.216 --> 00:08:45.356
finished encoding commands and

00:08:45.356 --> 00:08:46.356
committed the command buffer

00:08:47.446 --> 00:08:49.226
that the GPU begins to work and

00:08:49.226 --> 00:08:51.376
executes those commands.

00:08:52.576 --> 00:08:54.566
You can also encode commands to

00:08:54.566 --> 00:08:56.226
multiple command buffers in

00:08:56.266 --> 00:08:57.816
parallel on separate threads.

00:08:58.466 --> 00:09:02.056
Now I've already spoken about

00:09:02.056 --> 00:09:03.876
how the command queue produces a

00:09:03.876 --> 00:09:06.276
sequence of command buffers and

00:09:06.276 --> 00:09:07.606
that you create a command

00:09:07.606 --> 00:09:09.286
encoder from a command buffer.

00:09:10.196 --> 00:09:11.216
Let's take a closer look at

00:09:11.216 --> 00:09:13.096
these encoder objects used to

00:09:13.096 --> 00:09:14.466
write to our command buffers.

00:09:15.726 --> 00:09:17.036
There are three main types.

00:09:18.096 --> 00:09:18.986
There's the Render Command

00:09:18.986 --> 00:09:20.606
Encoder whose commands resemble

00:09:20.606 --> 00:09:22.266
that of an OpenGL command string

00:09:22.356 --> 00:09:23.776
where you set state, bind

00:09:23.776 --> 00:09:25.316
objects, and issue draw calls.

00:09:26.446 --> 00:09:27.736
There's the Blit Command Encoder

00:09:27.906 --> 00:09:29.306
with which you can issue texture

00:09:29.306 --> 00:09:31.246
and buffer copy operations.

00:09:31.576 --> 00:09:32.786
You can also use it to generate

00:09:32.786 --> 00:09:34.526
Mipmap for textures and transfer

00:09:34.566 --> 00:09:36.156
pixel data from buffers similar

00:09:36.156 --> 00:09:38.076
to how glReadPixels operates

00:09:38.076 --> 00:09:39.656
with OpenGL's pixel buffer

00:09:39.656 --> 00:09:40.266
objects.

00:09:40.806 --> 00:09:43.496
And then there's the Compute

00:09:43.756 --> 00:09:46.076
Command Encoder which allows you

00:09:46.076 --> 00:09:48.466
to dispatch commute kernels.

00:09:49.316 --> 00:09:50.826
The Render Command Encoder is

00:09:50.826 --> 00:09:51.746
probably the encoder you'll

00:09:51.746 --> 00:09:53.356
become most familiar with as

00:09:53.356 --> 00:09:54.346
it's responsible for the

00:09:54.346 --> 00:09:56.206
majority of operations that a

00:09:56.206 --> 00:09:57.976
graphic centric app needs.

00:09:59.306 --> 00:10:00.816
The set of commands encoded into

00:10:00.816 --> 00:10:01.966
a Render Command Encoder is

00:10:02.006 --> 00:10:03.686
often referred to as a Render

00:10:03.686 --> 00:10:03.836
Pass.

00:10:05.406 --> 00:10:06.576
In a Render Pass you set up

00:10:06.576 --> 00:10:08.016
render objects for the graphics

00:10:08.016 --> 00:10:10.236
pipeline and issue draw commands

00:10:10.676 --> 00:10:11.586
with those objects.

00:10:12.226 --> 00:10:13.726
This includes operations similar

00:10:13.726 --> 00:10:15.946
to glDrawArrays and

00:10:15.946 --> 00:10:18.696
glDrawElements and other OpenGL

00:10:18.816 --> 00:10:19.566
draw commands.

00:10:21.006 --> 00:10:22.416
Each Render Command Encoder is

00:10:22.416 --> 00:10:24.156
strongly associated with a set

00:10:24.306 --> 00:10:25.126
of render targets.

00:10:26.976 --> 00:10:28.806
And the render target is simply

00:10:28.806 --> 00:10:30.306
a texture that can be drawn to.

00:10:30.846 --> 00:10:32.636
This includes color, depth and

00:10:32.666 --> 00:10:34.166
stencil textures, as well as

00:10:34.166 --> 00:10:35.356
multi-sample textures.

00:10:36.436 --> 00:10:37.606
You specify a set of render

00:10:37.606 --> 00:10:38.976
targets when you create a render

00:10:38.976 --> 00:10:40.686
command encoder from a command

00:10:42.196 --> 00:10:42.336
buffer.

00:10:42.516 --> 00:10:43.906
And all draw commands are

00:10:43.906 --> 00:10:45.596
directed to these targets for

00:10:45.596 --> 00:10:47.036
the lifetime of the encoder.

00:10:48.506 --> 00:10:49.826
To direct commands to a new set

00:10:49.826 --> 00:10:51.396
of targets you end encoding with

00:10:51.396 --> 00:10:52.886
a current render command encoder

00:10:53.116 --> 00:10:55.536
and create a new encoder with

00:10:55.536 --> 00:10:56.256
new targets.

00:10:57.216 --> 00:10:58.836
This creates a very clear

00:10:58.836 --> 00:11:01.076
delineation between commands

00:11:01.126 --> 00:11:02.916
directed to different sets of

00:11:02.916 --> 00:11:03.506
render targets.

00:11:04.186 --> 00:11:06.196
Let's talk a little bit about

00:11:06.506 --> 00:11:07.896
the object you'll use for

00:11:07.896 --> 00:11:08.256
rendering.

00:11:09.446 --> 00:11:10.476
Metal has a number of similar

00:11:10.476 --> 00:11:11.276
objects to OpenGL.

00:11:11.276 --> 00:11:14.346
There are textures, buffers,

00:11:15.136 --> 00:11:17.846
samplers and pipeline state

00:11:17.846 --> 00:11:19.666
objects which resemble OpenGL's

00:11:19.696 --> 00:11:22.086
program objects, and also depth

00:11:22.206 --> 00:11:23.766
stencil state objects which

00:11:23.766 --> 00:11:24.966
don't really exists in OpenGL

00:11:25.176 --> 00:11:26.706
but are just the containers for

00:11:26.706 --> 00:11:28.156
the same depth and stencil state

00:11:28.396 --> 00:11:29.346
that OpenGL's got.

00:11:31.496 --> 00:11:32.996
One significant difference

00:11:33.076 --> 00:11:35.556
between OpenGL and Metal objects

00:11:35.906 --> 00:11:37.616
are how they are created and

00:11:37.616 --> 00:11:37.866
managed.

00:11:39.176 --> 00:11:40.336
The objects are all created from

00:11:40.336 --> 00:11:41.756
a device object so they're

00:11:41.756 --> 00:11:43.426
associated with a single GPU.

00:11:44.716 --> 00:11:46.156
You set most of an object state

00:11:46.276 --> 00:11:48.316
when you create it by specifying

00:11:48.646 --> 00:11:50.186
properties in a descriptor

00:11:50.186 --> 00:11:50.656
object.

00:11:51.936 --> 00:11:53.656
All states set when the object

00:11:53.656 --> 00:11:55.166
is created is fixed and

00:11:55.166 --> 00:11:55.596
immutable.

00:11:56.946 --> 00:11:58.306
Although the state of textures

00:11:58.306 --> 00:11:59.856
and buffers are fixed upon

00:11:59.856 --> 00:12:02.226
creation, data contained by

00:12:02.226 --> 00:12:03.976
these objects can be changed.

00:12:04.626 --> 00:12:07.296
Metal can do all the expensive

00:12:07.446 --> 00:12:09.016
setup for an object once when

00:12:09.016 --> 00:12:09.596
it's created.

00:12:10.396 --> 00:12:12.146
OpenGL's mutable model makes it

00:12:12.176 --> 00:12:13.766
completely possible that if your

00:12:13.766 --> 00:12:15.186
app touches a little piece of

00:12:15.186 --> 00:12:18.176
state the recompilation of that

00:12:18.176 --> 00:12:19.206
object may occur.

00:12:19.946 --> 00:12:21.256
And even if your app doesn't

00:12:21.256 --> 00:12:23.846
change an object state OpenGL

00:12:23.846 --> 00:12:25.176
needs to check a hierarchy of

00:12:25.226 --> 00:12:26.856
flags to confirm this before

00:12:26.856 --> 00:12:27.326
drawing.

00:12:28.186 --> 00:12:30.596
So with this immutable model

00:12:30.596 --> 00:12:32.176
Metal never needs to check for

00:12:32.176 --> 00:12:34.106
object state changes make draw

00:12:34.106 --> 00:12:36.016
calls much faster.

00:12:37.556 --> 00:12:39.166
Additionally, objects can be

00:12:39.256 --> 00:12:41.106
efficiently used across threads,

00:12:41.516 --> 00:12:42.756
Metal never needs to lock an

00:12:42.756 --> 00:12:43.746
object to prevent it from

00:12:43.746 --> 00:12:44.996
getting into an invalid state

00:12:45.146 --> 00:12:45.956
from a change on another thread.

00:12:51.306 --> 00:12:52.826
So let's talk about porting.

00:12:52.826 --> 00:12:57.256
Here is the typical phase, here

00:12:57.256 --> 00:12:59.286
are typical phases of a

00:12:59.286 --> 00:13:00.226
rendering application.

00:13:01.046 --> 00:13:02.166
You build the app compiling

00:13:02.166 --> 00:13:03.746
source and bundling your assets.

00:13:04.696 --> 00:13:05.926
Start up and initializing it.

00:13:06.306 --> 00:13:07.796
Loading the assets and

00:13:07.796 --> 00:13:09.666
initializing objects that will

00:13:09.666 --> 00:13:11.386
persist for the lifetime of your

00:13:11.386 --> 00:13:11.986
application.

00:13:13.236 --> 00:13:14.966
And you repeatedly render

00:13:15.456 --> 00:13:16.976
setting up state, issuing many

00:13:16.976 --> 00:13:19.336
draw calls, and presenting frame

00:13:19.486 --> 00:13:19.986
after frame.

00:13:20.676 --> 00:13:23.816
I'll talk about developing for

00:13:23.816 --> 00:13:25.686
Metal in the earlier stages of

00:13:25.686 --> 00:13:26.796
the application's lifetime,

00:13:28.316 --> 00:13:29.806
including building shaders

00:13:29.806 --> 00:13:31.176
offline and creating object's

00:13:31.176 --> 00:13:32.136
initialization.

00:13:33.256 --> 00:13:34.666
And Sukanya will describe how to

00:13:34.666 --> 00:13:36.396
port your per frame rendering

00:13:36.396 --> 00:13:36.656
code.

00:13:38.676 --> 00:13:39.936
So let's start out with

00:13:39.936 --> 00:13:41.706
application build time which is

00:13:41.706 --> 00:13:43.166
where shaders are typically

00:13:43.226 --> 00:13:43.736
compiled.

00:13:44.896 --> 00:13:46.246
We'll begin with a look at the

00:13:46.246 --> 00:13:47.006
shading language.

00:13:47.866 --> 00:13:49.006
The Metal shading language is

00:13:49.126 --> 00:13:50.476
based on C++.

00:13:50.936 --> 00:13:53.316
So just like C++ you can create

00:13:53.386 --> 00:13:55.206
classes, templates, structures,

00:13:55.606 --> 00:13:57.336
define enums and namespaces.

00:13:58.466 --> 00:14:00.156
Like GLSL there are built-in

00:14:00.156 --> 00:14:02.796
vector and matrix types, and

00:14:02.796 --> 00:14:04.176
numerous built-in functions and

00:14:04.176 --> 00:14:05.856
operators commonly used for

00:14:05.856 --> 00:14:06.436
graphics.

00:14:06.486 --> 00:14:09.236
And there are classes to specify

00:14:09.316 --> 00:14:11.006
sampler state and operate on

00:14:11.006 --> 00:14:11.426
textures.

00:14:12.966 --> 00:14:13.986
The best way to describe the

00:14:13.986 --> 00:14:15.166
language is just to show you.

00:14:15.396 --> 00:14:17.166
So here is a vertex and fragment

00:14:17.166 --> 00:14:17.846
shader pair.

00:14:19.336 --> 00:14:20.966
The vertex keyword at the

00:14:20.966 --> 00:14:22.516
function at the top specifies

00:14:22.586 --> 00:14:24.196
that that function is a vertex

00:14:24.196 --> 00:14:25.886
shader, likewise for the

00:14:25.886 --> 00:14:27.496
fragment keyword for the

00:14:27.496 --> 00:14:28.306
function at the bottom.

00:14:29.706 --> 00:14:31.366
Note that they have custom names

00:14:31.426 --> 00:14:33.226
unlike GLSL where every shader

00:14:33.266 --> 00:14:34.116
is just called main.

00:14:34.756 --> 00:14:35.726
This is important because it

00:14:35.726 --> 00:14:37.166
allows you to build large

00:14:37.166 --> 00:14:38.976
libraries of unique shaders

00:14:39.206 --> 00:14:40.966
using names to indicate what

00:14:41.026 --> 00:14:41.506
they do.

00:14:41.936 --> 00:14:44.446
Anything passed from your

00:14:44.446 --> 00:14:46.176
application is an argument to

00:14:46.176 --> 00:14:47.266
one of these shaders.

00:14:48.026 --> 00:14:49.316
There aren't any loose variables

00:14:49.316 --> 00:14:50.486
outside of functions as there

00:14:50.486 --> 00:14:51.416
are with GLSL.

00:14:52.486 --> 00:14:53.786
As you can see, there are these

00:14:53.846 --> 00:14:55.216
bracketed symbols next to each

00:14:55.216 --> 00:14:55.646
parameter.

00:14:56.226 --> 00:14:58.136
These are attribute specifiers

00:14:58.386 --> 00:14:59.946
which extend upon the C++

00:14:59.946 --> 00:15:01.656
language to indicate special

00:15:01.656 --> 00:15:02.236
variables.

00:15:03.456 --> 00:15:05.666
So this vertex ID attribute

00:15:05.746 --> 00:15:07.446
indicates that this VID

00:15:07.446 --> 00:15:08.576
parameter should contain the

00:15:08.666 --> 00:15:11.126
index of the current vertex when

00:15:11.126 --> 00:15:12.826
this vertex executes.

00:15:13.196 --> 00:15:14.906
It's used down here in two

00:15:14.906 --> 00:15:17.166
places to index into an array of

00:15:17.166 --> 00:15:17.676
vertices.

00:15:18.226 --> 00:15:20.636
These parameters here with a

00:15:20.636 --> 00:15:22.866
buffer attribute specifier these

00:15:22.866 --> 00:15:24.186
indicate that these variables

00:15:24.226 --> 00:15:26.106
are filled by buffer's objects

00:15:26.246 --> 00:15:27.436
set in the Metal API.

00:15:27.436 --> 00:15:29.596
I'll talk more about how the

00:15:29.596 --> 00:15:31.106
Metal API relates to these in

00:15:31.106 --> 00:15:31.596
just a minute.

00:15:32.266 --> 00:15:33.626
But first let's take a closer

00:15:33.626 --> 00:15:34.926
look at some of the types used

00:15:34.926 --> 00:15:35.136
here.

00:15:36.056 --> 00:15:37.776
Now these are all custom types

00:15:38.366 --> 00:15:39.386
that you would define.

00:15:40.406 --> 00:15:41.656
The vertices parameter here is

00:15:41.656 --> 00:15:43.606
defined as a pointer to a vertex

00:15:43.606 --> 00:15:45.656
type and its definition is right

00:15:45.656 --> 00:15:45.886
here.

00:15:46.706 --> 00:15:48.836
The structure has two members, a

00:15:48.836 --> 00:15:50.586
model position member and a

00:15:50.586 --> 00:15:51.736
texture coordinate member.

00:15:52.446 --> 00:15:54.116
It defines the layout and memory

00:15:54.146 --> 00:15:56.186
of each vertex in a vertex array

00:15:56.526 --> 00:15:58.096
passed into this vertex shader.

00:15:59.836 --> 00:16:01.336
Let's look at this vertex output

00:16:01.336 --> 00:16:02.946
type returned by our vertex

00:16:02.946 --> 00:16:03.186
shader.

00:16:03.776 --> 00:16:06.506
Its definition here specifies

00:16:06.506 --> 00:16:07.736
what's passed down for the

00:16:07.736 --> 00:16:09.186
rasterization stage and

00:16:09.186 --> 00:16:10.466
eventually to the fragment

00:16:10.466 --> 00:16:10.806
program.

00:16:11.336 --> 00:16:13.756
The four-component

00:16:13.756 --> 00:16:15.146
floating-point member named

00:16:15.186 --> 00:16:17.396
clipPos has this position

00:16:17.396 --> 00:16:18.766
attribute specifier next to it.

00:16:19.336 --> 00:16:20.756
This indicates that this member

00:16:20.756 --> 00:16:22.096
will serve as the output

00:16:22.136 --> 00:16:23.746
position of our vertex shader.

00:16:25.116 --> 00:16:26.376
This texCoord member which

00:16:26.376 --> 00:16:27.326
doesn't have an attribute

00:16:27.326 --> 00:16:30.096
specifier defaults to a variable

00:16:30.306 --> 00:16:31.656
that will be interpolated with

00:16:31.656 --> 00:16:34.986
the texture coordinate values of

00:16:34.986 --> 00:16:36.726
other vertices defining the

00:16:36.726 --> 00:16:38.616
rasterized triangle much like a

00:16:38.616 --> 00:16:39.986
varying in GLSL.

00:16:41.616 --> 00:16:42.616
Let's take a look at some of the

00:16:42.616 --> 00:16:43.786
parameters of our fragment

00:16:43.786 --> 00:16:44.046
shader.

00:16:45.146 --> 00:16:46.796
So we're using this vertexOutput

00:16:46.796 --> 00:16:48.966
struct that we just looked at

00:16:49.406 --> 00:16:50.846
down here as an input to our

00:16:51.076 --> 00:16:51.716
fragment shader.

00:16:52.336 --> 00:16:53.966
And it gives us the interpolated

00:16:54.006 --> 00:16:55.446
texture coordinate that we

00:16:55.716 --> 00:16:57.346
constructed in the vertex shader

00:16:58.486 --> 00:17:00.206
and we use it here to sample

00:17:00.366 --> 00:17:02.966
from a texture.

00:17:03.086 --> 00:17:04.586
In our application code which is

00:17:04.586 --> 00:17:06.486
written in Objective-C we use a

00:17:06.486 --> 00:17:08.316
Render Command Encoder to map

00:17:08.406 --> 00:17:10.226
objects to shader parameters.

00:17:12.915 --> 00:17:15.016
The index argument with each of

00:17:15.016 --> 00:17:16.396
these calls are similar to

00:17:16.396 --> 00:17:18.316
OpenGL's attribute indices,

00:17:18.366 --> 00:17:19.935
vertex attribute indices, and

00:17:19.935 --> 00:17:20.715
textured units.

00:17:21.336 --> 00:17:23.415
They specify indices which map

00:17:23.526 --> 00:17:25.296
to indices in our shader

00:17:25.296 --> 00:17:25.836
parameters.

00:17:27.026 --> 00:17:29.056
So by calling the encoder's set

00:17:29.106 --> 00:17:30.526
fragment buffer method with an

00:17:30.526 --> 00:17:33.046
index of three we map this my

00:17:33.046 --> 00:17:35.346
uniform buffer object to the

00:17:35.346 --> 00:17:37.446
uniform's parameter of our

00:17:37.446 --> 00:17:38.936
encoder, of our shader.

00:17:39.536 --> 00:17:42.326
We make similar calls to set our

00:17:42.326 --> 00:17:44.836
texture and sampler objects.

00:17:50.396 --> 00:17:52.096
Now I want to talk about one

00:17:52.096 --> 00:17:53.996
library that's incredibly useful

00:17:54.106 --> 00:17:55.606
for shader development.

00:17:57.236 --> 00:17:58.576
This is called SIMD.

00:17:58.896 --> 00:18:00.666
Now SIMD is actually a library

00:18:00.966 --> 00:18:02.616
that's separate from Metal and

00:18:03.126 --> 00:18:04.656
is used in many orthogonal

00:18:04.716 --> 00:18:05.246
frameworks.

00:18:05.836 --> 00:18:07.366
But it was built with Metal in

00:18:07.366 --> 00:18:07.686
mind.

00:18:08.936 --> 00:18:10.886
SIMD defines vector and matrix

00:18:10.886 --> 00:18:12.786
types commonly used to implement

00:18:13.286 --> 00:18:15.056
graphics algorithms, so this

00:18:15.056 --> 00:18:16.036
includes three and four

00:18:16.036 --> 00:18:17.846
component vector types and three

00:18:17.846 --> 00:18:19.796
by three and four by four matrix

00:18:19.796 --> 00:18:19.976
types.

00:18:24.046 --> 00:18:24.906
One of the nicest features of

00:18:24.906 --> 00:18:26.676
this library is that you can use

00:18:26.676 --> 00:18:30.496
it to share code between your

00:18:30.496 --> 00:18:33.306
application code and your

00:18:33.306 --> 00:18:34.966
shading language code.

00:18:35.596 --> 00:18:37.216
This is really useful because

00:18:37.216 --> 00:18:38.856
you can define the layout of

00:18:38.926 --> 00:18:39.986
data passed from your

00:18:39.986 --> 00:18:42.066
application to your shaders with

00:18:42.066 --> 00:18:43.426
structures using these types.

00:18:44.046 --> 00:18:44.766
Here's how it works.

00:18:45.996 --> 00:18:47.276
You create a structure with data

00:18:47.346 --> 00:18:48.216
you'd like to pass from your

00:18:48.216 --> 00:18:49.516
application to your shaders.

00:18:49.836 --> 00:18:51.396
So for instance, if you want to

00:18:51.396 --> 00:18:52.536
pass down a model view

00:18:52.536 --> 00:18:55.206
projection matrix to the and the

00:18:55.206 --> 00:18:56.646
position of the SIMD primary

00:18:56.646 --> 00:18:58.696
light source you can use SIMD

00:18:58.696 --> 00:19:00.856
types in your structure to do

00:19:01.376 --> 00:19:01.546
this.

00:19:01.976 --> 00:19:02.746
You put the structure's

00:19:02.746 --> 00:19:05.106
definition and a header which

00:19:05.106 --> 00:19:06.366
you would include in both your

00:19:06.366 --> 00:19:08.466
application code and Metal

00:19:08.466 --> 00:19:08.796
files.

00:19:09.116 --> 00:19:10.756
This way the data layout used by

00:19:10.756 --> 00:19:12.566
your shaders matches what you've

00:19:12.566 --> 00:19:14.036
set in your code because they're

00:19:14.036 --> 00:19:15.286
using the same types.

00:19:16.686 --> 00:19:18.296
This makes bugs due to layout

00:19:18.296 --> 00:19:19.976
mismatches much less common.

00:19:24.046 --> 00:19:25.556
One of the key ways in which

00:19:25.556 --> 00:19:27.716
Metal achieves its efficiency is

00:19:27.716 --> 00:19:29.976
by doing work earlier and less

00:19:30.026 --> 00:19:30.456
frequently.

00:19:31.376 --> 00:19:33.426
So you'll use Xcode to compile

00:19:33.426 --> 00:19:34.896
Metal shader files when you

00:19:34.896 --> 00:19:35.856
build your application.

00:19:36.986 --> 00:19:38.206
This runs a front-end

00:19:38.206 --> 00:19:39.866
compilation performing string

00:19:39.866 --> 00:19:41.826
parsing, shader analysis, and

00:19:41.826 --> 00:19:43.226
some basic optimizations.

00:19:43.986 --> 00:19:45.526
It converts your code into a

00:19:45.526 --> 00:19:46.796
binary intermediate

00:19:46.796 --> 00:19:48.856
representation that is usable on

00:19:48.856 --> 00:19:49.456
any hardware.

00:19:50.456 --> 00:19:52.566
Actual GPU machine code isn't

00:19:52.566 --> 00:19:54.156
built until your app runs on the

00:19:54.156 --> 00:19:54.976
user's system.

00:19:55.516 --> 00:19:56.726
But this removes half the

00:19:56.726 --> 00:19:58.796
compiled time needed when your

00:19:58.796 --> 00:19:58.976
app runs.

00:19:59.996 --> 00:20:02.886
The built intermediate

00:20:02.886 --> 00:20:05.286
representation binary is

00:20:05.376 --> 00:20:07.656
archived into a Metal library

00:20:07.656 --> 00:20:07.926
file.

00:20:08.576 --> 00:20:10.376
Xcode will compile all the Metal

00:20:10.376 --> 00:20:11.656
shader source files into a

00:20:11.776 --> 00:20:13.856
default Metal library, placing

00:20:13.856 --> 00:20:16.256
it into your app bundle for

00:20:16.256 --> 00:20:17.276
retrieval at runtime.

00:20:17.936 --> 00:20:20.686
In addition to having Xcode

00:20:20.686 --> 00:20:23.286
built shaders you also can build

00:20:23.286 --> 00:20:24.266
shaders during your app's

00:20:24.266 --> 00:20:24.726
runtime.

00:20:26.126 --> 00:20:27.436
Some OpenGL apps construct

00:20:27.436 --> 00:20:28.446
shaders at runtime by

00:20:28.546 --> 00:20:30.096
concatenating strings or running

00:20:30.096 --> 00:20:31.286
a source code generator of some

00:20:31.286 --> 00:20:31.616
kind.

00:20:32.646 --> 00:20:33.846
For those gathering all of the

00:20:33.846 --> 00:20:35.376
shaders at build time can be a

00:20:35.376 --> 00:20:35.826
challenge.

00:20:36.846 --> 00:20:38.756
But for bring up purposes or if

00:20:38.856 --> 00:20:40.476
built time compilation just

00:20:40.476 --> 00:20:41.486
isn't possible for your app

00:20:41.876 --> 00:20:43.486
Metal is able to compile shaders

00:20:43.486 --> 00:20:45.326
from source at runtime just like

00:20:45.326 --> 00:20:45.836
OpenGL.

00:20:46.386 --> 00:20:49.346
However, there are a number of

00:20:49.346 --> 00:20:50.896
disadvantages to this, most

00:20:50.896 --> 00:20:52.416
obviously you give up on the

00:20:52.416 --> 00:20:53.636
performance savings of keeping

00:20:53.636 --> 00:20:54.986
this work off the user's system.

00:20:56.216 --> 00:20:57.206
You won't see any shader

00:20:57.206 --> 00:20:58.546
compilation errors at built time

00:20:58.546 --> 00:20:59.716
so you'll only find out about

00:20:59.716 --> 00:21:00.776
them when you run your app.

00:21:01.896 --> 00:21:03.436
Finally, if you compile at

00:21:03.436 --> 00:21:04.766
runtime you can't include

00:21:04.766 --> 00:21:06.246
headers in your shaders, so you

00:21:06.246 --> 00:21:07.526
can't share types between your

00:21:07.526 --> 00:21:09.396
shaders or your application

00:21:09.396 --> 00:21:09.686
code.

00:21:10.236 --> 00:21:12.776
If you use runtime share

00:21:12.776 --> 00:21:14.546
compilation to get your app up

00:21:14.546 --> 00:21:16.066
and running quickly I strongly

00:21:16.066 --> 00:21:18.146
encourage you to spend some time

00:21:18.146 --> 00:21:19.086
getting your shaders to build

00:21:19.086 --> 00:21:19.966
within Xcode.

00:21:20.586 --> 00:21:21.676
This way you can benefit from

00:21:21.676 --> 00:21:23.056
not only the runtime performance

00:21:23.056 --> 00:21:24.246
savings but also these

00:21:24.246 --> 00:21:25.546
conveniences in shader

00:21:25.546 --> 00:21:26.046
development.

00:21:26.526 --> 00:21:29.426
Let's move onto the steps your

00:21:29.426 --> 00:21:30.646
app will need to take to

00:21:30.646 --> 00:21:31.946
initialize your Metal renderer,

00:21:32.186 --> 00:21:33.376
so this includes creating a

00:21:33.376 --> 00:21:34.246
number of objects.

00:21:34.746 --> 00:21:36.286
I'll start out with the devices

00:21:36.286 --> 00:21:37.666
and command queues and then I'll

00:21:37.666 --> 00:21:39.826
describe how to create objects

00:21:39.826 --> 00:21:40.966
for your assets, including

00:21:40.966 --> 00:21:42.936
textures, buffers and pipeline

00:21:42.936 --> 00:21:43.426
objects.

00:21:45.046 --> 00:21:47.566
So devices and queues.

00:21:47.726 --> 00:21:49.246
These are the first objects

00:21:49.366 --> 00:21:50.016
you'll create.

00:21:50.636 --> 00:21:53.506
The device is an abstract

00:21:53.506 --> 00:21:54.866
representation of a GPU.

00:21:56.226 --> 00:21:57.346
It's responsible for creating

00:21:57.346 --> 00:21:58.436
objects that are used for

00:21:58.436 --> 00:21:59.416
rendering including these

00:21:59.456 --> 00:22:00.956
textures, buffers and pipeline

00:22:00.956 --> 00:22:01.386
objects.

00:22:02.846 --> 00:22:04.506
In iOS since there's only ever

00:22:04.506 --> 00:22:06.826
one GPU there's only one device

00:22:06.826 --> 00:22:08.626
you can get, but on macOS

00:22:08.916 --> 00:22:10.356
systems can have multiple

00:22:10.356 --> 00:22:12.216
devices since there may be both

00:22:12.216 --> 00:22:14.126
an integrated and discrete GPU

00:22:14.126 --> 00:22:16.026
and even multiple eGPUs.

00:22:17.236 --> 00:22:18.286
Usually though, getting the

00:22:18.286 --> 00:22:20.146
default device is sufficient for

00:22:20.146 --> 00:22:21.126
most applications.

00:22:21.886 --> 00:22:23.776
And getting this device is

00:22:23.826 --> 00:22:25.216
really simple, you call

00:22:25.276 --> 00:22:26.876
MTLCreateSystem

00:22:26.876 --> 00:22:27.616
DefaultDevice.

00:22:28.296 --> 00:22:31.136
One of the first things you'll

00:22:31.136 --> 00:22:33.396
do with this device is create a

00:22:33.396 --> 00:22:33.966
command queue.

00:22:35.746 --> 00:22:37.416
The queue is used mostly in your

00:22:37.416 --> 00:22:38.736
applications render loop to

00:22:38.736 --> 00:22:40.036
obtain command buffers each

00:22:40.086 --> 00:22:41.536
frame, but you want to create

00:22:41.536 --> 00:22:42.836
the command queue at

00:22:42.996 --> 00:22:43.826
initialization.

00:22:45.036 --> 00:22:46.176
Typically, a single queue is

00:22:46.176 --> 00:22:48.006
sufficient but more complex apps

00:22:48.276 --> 00:22:49.926
that execute many tasks in

00:22:49.926 --> 00:22:51.566
parallel may need multiple

00:22:51.596 --> 00:22:51.986
queues.

00:22:53.206 --> 00:22:54.696
Creating a queue is also really

00:22:54.696 --> 00:22:56.666
simple, you call newCommandQueue

00:22:56.906 --> 00:22:57.936
with the device you just

00:22:57.936 --> 00:22:58.336
created.

00:22:58.956 --> 00:22:59.996
And once you've got your queue

00:23:00.276 --> 00:23:01.716
you can get command buffers for

00:23:01.716 --> 00:23:02.306
your render loop.

00:23:02.806 --> 00:23:06.846
Let's move on building your

00:23:06.846 --> 00:23:07.546
render objects.

00:23:08.216 --> 00:23:10.546
I'm going to talk about creating

00:23:10.736 --> 00:23:12.106
three types of objects used for

00:23:12.106 --> 00:23:13.936
rendering, textures, buffers and

00:23:13.936 --> 00:23:14.426
pipelines.

00:23:15.496 --> 00:23:17.846
Let's start with textures.

00:23:18.106 --> 00:23:19.466
As mentioned earlier, you create

00:23:19.466 --> 00:23:20.726
render objects from a device

00:23:20.726 --> 00:23:21.066
object.

00:23:22.416 --> 00:23:23.756
You'll use a descriptor object

00:23:23.756 --> 00:23:24.836
to create most of these.

00:23:25.546 --> 00:23:26.916
Descriptors are really simple

00:23:26.916 --> 00:23:28.356
objects without any true

00:23:28.356 --> 00:23:28.756
methods.

00:23:29.296 --> 00:23:30.586
They only contain properties

00:23:30.586 --> 00:23:31.856
needed for object setup.

00:23:33.146 --> 00:23:34.526
So for example, to create a

00:23:34.526 --> 00:23:35.836
texture you'd use a texture

00:23:35.836 --> 00:23:36.326
descriptor.

00:23:37.076 --> 00:23:38.306
You specify the properties that

00:23:38.306 --> 00:23:39.386
you'd like the created texture

00:23:39.386 --> 00:23:39.666
to have.

00:23:40.186 --> 00:23:41.406
So things like the type of

00:23:41.436 --> 00:23:43.396
texture, 2D, 3D, cubeMap.

00:23:44.146 --> 00:23:45.296
The texture's dimensions and the

00:23:45.296 --> 00:23:46.486
number of Mipmaps you'd like it

00:23:46.486 --> 00:23:47.286
to have.

00:23:47.286 --> 00:23:49.746
And the pixel format of data in

00:23:50.676 --> 00:23:51.576
the texture.

00:23:51.706 --> 00:23:53.416
Once you've set the desired

00:23:53.416 --> 00:23:54.346
values for each of the

00:23:54.346 --> 00:23:56.076
properties you call a method on

00:23:56.076 --> 00:23:58.026
the device to create a usable

00:23:58.026 --> 00:23:58.856
texture object.

00:24:00.816 --> 00:24:03.156
This also allocates the memory

00:24:03.266 --> 00:24:04.726
backing the texture image.

00:24:06.086 --> 00:24:07.166
Once you've created the object

00:24:07.166 --> 00:24:07.946
you no longer need the

00:24:07.946 --> 00:24:09.286
descriptor as it's only used for

00:24:09.286 --> 00:24:10.126
object creation.

00:24:11.256 --> 00:24:12.296
And properties you set in the

00:24:12.296 --> 00:24:13.506
descriptor are locked and can no

00:24:13.506 --> 00:24:14.396
longer be changed.

00:24:15.766 --> 00:24:17.056
However, the contents of the

00:24:17.056 --> 00:24:18.726
texture image can be modified.

00:24:18.756 --> 00:24:21.816
So I want to talk about one

00:24:21.816 --> 00:24:22.816
property you'll set in the

00:24:22.816 --> 00:24:24.096
texture descriptor and you'll

00:24:24.096 --> 00:24:25.876
also use when creating a buffer.

00:24:26.626 --> 00:24:28.166
This is called the storage mode.

00:24:29.286 --> 00:24:30.366
As mentioned, when you create a

00:24:30.366 --> 00:24:31.966
texture object Metal allocates

00:24:31.966 --> 00:24:33.366
memory for it right then and

00:24:33.366 --> 00:24:33.596
there.

00:24:34.106 --> 00:24:35.276
The storage mode property tells

00:24:35.276 --> 00:24:36.696
Metal in which pool memory it

00:24:36.696 --> 00:24:37.406
should be allocated.

00:24:38.576 --> 00:24:40.056
The simplest option shared

00:24:40.056 --> 00:24:42.436
storage mode gives both the CPU

00:24:42.876 --> 00:24:44.046
and the GPU access.

00:24:44.656 --> 00:24:46.076
For buffers this means you get a

00:24:46.076 --> 00:24:47.666
pointer to the memory backing

00:24:47.666 --> 00:24:48.156
the object.

00:24:48.996 --> 00:24:50.166
Protectors, this means you can

00:24:50.166 --> 00:24:51.926
call certain easy-to-use methods

00:24:52.196 --> 00:24:53.806
to set and retrieve data from

00:24:53.806 --> 00:24:54.196
the texture.

00:24:54.736 --> 00:24:57.246
You can use private storage mode

00:24:57.246 --> 00:24:58.836
which only gives the GPU access

00:24:58.926 --> 00:25:00.486
to the data, this allows the

00:25:00.486 --> 00:25:01.356
Metal to apply some

00:25:01.356 --> 00:25:03.906
optimizations it would be unable

00:25:03.906 --> 00:25:05.786
to if the CPU also had access to

00:25:05.786 --> 00:25:06.206
that data.

00:25:06.896 --> 00:25:08.776
But only the GPU can directly

00:25:08.886 --> 00:25:10.636
fill the contents of this type

00:25:10.636 --> 00:25:11.096
of texture.

00:25:12.606 --> 00:25:14.016
You can indirectly fill data

00:25:14.206 --> 00:25:15.996
from the CPU using a blit

00:25:15.996 --> 00:25:17.786
encoder to copy from a second

00:25:18.076 --> 00:25:19.526
intermediate resource using

00:25:19.526 --> 00:25:21.026
shared storage.

00:25:22.446 --> 00:25:23.966
On devices with dedicated video

00:25:23.966 --> 00:25:25.656
memory setting the resource to

00:25:25.656 --> 00:25:27.306
use private storage allocates it

00:25:27.306 --> 00:25:28.396
in video memory only.

00:25:30.396 --> 00:25:32.776
Finally, on macOS you can use a

00:25:32.866 --> 00:25:34.056
third storage mode called

00:25:34.056 --> 00:25:34.756
managed storage.

00:25:35.696 --> 00:25:37.796
This allows both the GPU and CPU

00:25:37.826 --> 00:25:39.066
to access the object data.

00:25:39.776 --> 00:25:40.946
And on systems with dedicated

00:25:40.946 --> 00:25:43.226
video memory Metal may create a

00:25:43.226 --> 00:25:44.476
mirrored memory backing for

00:25:44.476 --> 00:25:46.056
efficient access by both

00:25:46.056 --> 00:25:46.696
processors.

00:25:47.926 --> 00:25:49.396
Because of this, explicit calls

00:25:49.396 --> 00:25:51.166
are necessary to ensure data is

00:25:51.236 --> 00:25:53.476
synchronized for GPU and CPU

00:25:53.476 --> 00:25:53.876
access.

00:25:58.126 --> 00:25:59.486
Here's an example of creating a

00:25:59.486 --> 00:26:00.376
texture object.

00:26:00.816 --> 00:26:04.256
First you create a texture

00:26:04.256 --> 00:26:06.126
descriptor and set a number of

00:26:06.126 --> 00:26:07.966
properties in it, including the

00:26:07.966 --> 00:26:08.586
storage mode.

00:26:09.106 --> 00:26:12.836
And then we create a texture

00:26:13.586 --> 00:26:14.556
using the device.

00:26:15.916 --> 00:26:17.166
To fill a texture's image data

00:26:17.316 --> 00:26:18.936
we calculate the bytes per row

00:26:19.886 --> 00:26:21.336
and just like with GLText

00:26:21.336 --> 00:26:23.056
[inaudible] we specify a region

00:26:23.056 --> 00:26:23.466
to load.

00:26:26.196 --> 00:26:27.536
And then we call the texture

00:26:27.536 --> 00:26:29.506
object's replace region method

00:26:29.756 --> 00:26:31.596
which copies the data into the

00:26:31.596 --> 00:26:32.676
texture from a pointer we

00:26:32.676 --> 00:26:32.926
supply.

00:26:37.046 --> 00:26:38.266
Now there are a few notable

00:26:38.266 --> 00:26:39.396
differences between OpenGL and

00:26:39.396 --> 00:26:40.446
Metal texture objects.

00:26:40.816 --> 00:26:42.556
While OpenGL does have a sampler

00:26:42.556 --> 00:26:43.886
object they are optional.

00:26:44.406 --> 00:26:45.576
Wrap modes and filters can be

00:26:45.576 --> 00:26:46.826
set in the texture's object

00:26:46.826 --> 00:26:47.886
itself in OpenGL.

00:26:48.276 --> 00:26:49.736
In Metal you need to create a

00:26:49.816 --> 00:26:51.376
separate sampler object or

00:26:51.376 --> 00:26:53.576
specify sampler parameters in

00:26:54.206 --> 00:26:55.096
your shaders.

00:26:55.786 --> 00:26:57.336
Texture image data is not

00:26:57.416 --> 00:26:57.946
flipped in Metal.

00:26:58.496 --> 00:27:00.996
OpenGL uses a bottom-left origin

00:27:01.306 --> 00:27:02.826
while Metal uses a top-left

00:27:02.826 --> 00:27:03.196
origin.

00:27:03.196 --> 00:27:04.426
So make sure you're aware of the

00:27:04.426 --> 00:27:05.736
difference when loading your

00:27:05.736 --> 00:27:06.266
textures.

00:27:06.686 --> 00:27:09.696
Desktop OpenGL also performs

00:27:09.796 --> 00:27:10.866
conversions when the data

00:27:10.916 --> 00:27:13.376
supplied is in a different

00:27:13.376 --> 00:27:15.016
format than the internal format.

00:27:16.456 --> 00:27:18.106
However Metal similar to OpenGL

00:27:18.206 --> 00:27:20.346
ES does not, so you'll need to

00:27:20.346 --> 00:27:21.406
make sure your assets are

00:27:21.436 --> 00:27:23.436
already in the proper format or

00:27:23.696 --> 00:27:25.146
implement paths to perform

00:27:25.176 --> 00:27:25.696
conversions.

00:27:29.066 --> 00:27:32.316
Let's move on to buffers.

00:27:32.456 --> 00:27:34.266
Metal uses buffers for all

00:27:34.266 --> 00:27:34.976
unstructured data.

00:27:41.456 --> 00:27:42.406
They're really similar to

00:27:42.406 --> 00:27:44.716
OpenGL's vertex, element and

00:27:44.816 --> 00:27:45.646
uniform buffers.

00:27:45.926 --> 00:27:47.076
So if you're already using these

00:27:47.076 --> 00:27:48.456
buffers in OpenGL you'll have an

00:27:48.506 --> 00:27:50.126
easier time with your port.

00:27:51.506 --> 00:27:52.686
Creating a buffer is pretty

00:27:52.686 --> 00:27:54.456
simple with a device you call

00:27:54.516 --> 00:27:55.986
newBufferWithLength specifying

00:27:55.986 --> 00:27:57.146
the size of the buffer you want.

00:27:57.826 --> 00:27:59.626
You also specify a storage mode.

00:28:00.986 --> 00:28:01.996
You load a buffer through the

00:28:02.036 --> 00:28:03.506
contents property, which is

00:28:03.506 --> 00:28:05.026
simply a void pointer to the

00:28:05.026 --> 00:28:06.186
memory backing the buffer.

00:28:07.276 --> 00:28:08.706
To Metal's core the data is

00:28:08.706 --> 00:28:10.076
completely unstructured, so it's

00:28:10.076 --> 00:28:11.896
up to you to define the layout

00:28:12.196 --> 00:28:14.066
in your application and share

00:28:14.066 --> 00:28:14.296
your code.

00:28:15.086 --> 00:28:16.746
Here we're casting the contents

00:28:16.826 --> 00:28:18.486
pointer to a structure which

00:28:18.486 --> 00:28:20.546
uses some of the SIMD types I

00:28:20.546 --> 00:28:21.236
mentioned earlier.

00:28:21.236 --> 00:28:23.796
We set the members of the

00:28:23.796 --> 00:28:25.466
structure which fills in the

00:28:25.466 --> 00:28:26.936
buffer's data using the layout

00:28:26.936 --> 00:28:28.286
or application as is defined

00:28:28.606 --> 00:28:29.816
with the structure's definition.

00:28:31.306 --> 00:28:32.506
As mentioned earlier, you can

00:28:32.506 --> 00:28:34.026
share a structure's definition

00:28:34.276 --> 00:28:35.406
between your application and

00:28:35.406 --> 00:28:36.736
share code which ensures the

00:28:36.736 --> 00:28:38.216
layouts match between these two

00:28:38.216 --> 00:28:38.886
components.

00:28:39.466 --> 00:28:44.846
A common mistake is a mismatch

00:28:44.886 --> 00:28:46.456
between buffer data and how it's

00:28:46.456 --> 00:28:48.226
interpreted in the shader due to

00:28:48.356 --> 00:28:49.556
an assumption or due to

00:28:49.556 --> 00:28:51.196
assumptions about alignment.

00:28:52.136 --> 00:28:53.476
For instance, you might assume

00:28:53.476 --> 00:28:54.496
that the shading language's

00:28:54.826 --> 00:28:57.256
float3 type consumes only 12

00:28:57.296 --> 00:28:57.576
bytes.

00:28:58.266 --> 00:29:00.506
Three 4 byte components is 12

00:29:00.506 --> 00:29:01.096
bytes right.

00:29:01.936 --> 00:29:03.436
Well if you pack your data that

00:29:03.436 --> 00:29:04.716
way you'll run into trouble

00:29:05.356 --> 00:29:06.586
because the shading language

00:29:06.666 --> 00:29:08.296
actually interprets a float3 as

00:29:08.296 --> 00:29:09.586
consuming 16 bytes.

00:29:10.336 --> 00:29:11.236
That's because the types are

00:29:11.236 --> 00:29:12.936
kept as stricter alignments for

00:29:12.936 --> 00:29:16.366
CPU and GPU optimal CPU and GPU

00:29:16.366 --> 00:29:16.816
usage.

00:29:18.026 --> 00:29:19.626
Similar problems often occur

00:29:19.996 --> 00:29:21.176
with three by three matrices.

00:29:22.316 --> 00:29:23.936
If you really want to tack, if

00:29:23.936 --> 00:29:26.046
you really want to pack data

00:29:26.186 --> 00:29:28.996
tightly there are pack types

00:29:28.996 --> 00:29:30.416
available in the Metal shading

00:29:30.416 --> 00:29:30.776
language.

00:29:31.246 --> 00:29:33.126
After passing a pack data in a

00:29:33.126 --> 00:29:34.596
buffer your shader code would

00:29:34.596 --> 00:29:37.356
need to pack data, would you

00:29:37.356 --> 00:29:38.846
need to pass that packed data to

00:29:38.846 --> 00:29:40.686
a regular vector before it can

00:29:40.686 --> 00:29:42.236
perform operations on that data.

00:29:43.716 --> 00:29:45.436
So when you're bringing up your

00:29:45.436 --> 00:29:48.446
application I recommend using

00:29:48.756 --> 00:29:49.956
the most convenient storage

00:29:49.956 --> 00:29:50.376
modes.

00:29:51.396 --> 00:29:53.436
This makes it more easy to

00:29:53.466 --> 00:29:55.486
access the data in those

00:29:55.486 --> 00:29:55.976
resources.

00:29:57.006 --> 00:29:58.676
So in iOS create all textures

00:29:58.676 --> 00:29:59.696
and buffers with

00:30:00.086 --> 00:30:00.976
StorageModeShared.

00:30:02.386 --> 00:30:03.726
On macOS you can't use

00:30:03.726 --> 00:30:05.076
StorageModeShared with textures,

00:30:05.246 --> 00:30:07.146
but StorageModeManaged does make

00:30:07.146 --> 00:30:08.526
image data access easier,

00:30:08.856 --> 00:30:10.426
although private storage is most

00:30:10.426 --> 00:30:10.846
optimal.

00:30:16.046 --> 00:30:16.996
You can use StorageModeShared

00:30:16.996 --> 00:30:19.216
with buffers on macOS, but be

00:30:19.216 --> 00:30:19.906
careful with this.

00:30:20.526 --> 00:30:22.456
If you mix data that both the

00:30:22.576 --> 00:30:26.066
CPU and GPU needs access to with

00:30:26.066 --> 00:30:28.336
data only the GPU needs access

00:30:28.376 --> 00:30:29.456
to it can be difficult to

00:30:29.456 --> 00:30:31.246
detangle these two types of data

00:30:31.246 --> 00:30:33.046
later on and put them in

00:30:33.046 --> 00:30:34.286
separate memory pools.

00:30:34.906 --> 00:30:37.816
Now that I've described a little

00:30:37.816 --> 00:30:39.166
bit about creating textures and

00:30:39.166 --> 00:30:41.186
buffer objects directly I'd like

00:30:41.186 --> 00:30:42.106
to mention the MetalKit

00:30:42.156 --> 00:30:43.526
framework which can easily

00:30:43.526 --> 00:30:44.676
create textures and vertex

00:30:44.676 --> 00:30:46.156
buffers from common file

00:30:46.216 --> 00:30:46.606
formats.

00:30:47.146 --> 00:30:48.336
There's a texture loading class

00:30:48.626 --> 00:30:50.286
and some functionality to create

00:30:50.286 --> 00:30:52.216
Metal buffer backed meshes

00:30:52.376 --> 00:30:53.936
loaded by Model I/O.

00:30:58.046 --> 00:30:59.106
Let's talk about shaders and the

00:30:59.106 --> 00:31:00.506
render pipeline objects that

00:31:00.506 --> 00:31:02.036
contain them.

00:31:02.776 --> 00:31:04.046
You create one of these pipeline

00:31:04.046 --> 00:31:05.766
state objects using a render

00:31:05.766 --> 00:31:07.096
pipeline descriptor object.

00:31:08.466 --> 00:31:10.116
The object contains a vertex and

00:31:10.116 --> 00:31:11.066
fragment shader pair.

00:31:12.446 --> 00:31:13.886
It also specifies the layout of

00:31:13.886 --> 00:31:15.516
vertices feeding the vertex

00:31:16.286 --> 00:31:16.416
shader.

00:31:17.066 --> 00:31:19.506
And also blend state and the

00:31:19.586 --> 00:31:21.586
pixel formats of render targets

00:31:21.866 --> 00:31:23.706
that the fragment and shader can

00:31:23.706 --> 00:31:24.136
render to.

00:31:25.666 --> 00:31:27.206
Just like with the texture

00:31:27.206 --> 00:31:28.556
object you call method on the

00:31:28.556 --> 00:31:30.136
device which will produce an

00:31:30.136 --> 00:31:31.996
immutable render state pipeline

00:31:31.996 --> 00:31:32.406
object.

00:31:33.706 --> 00:31:34.926
And also like a texture object

00:31:35.056 --> 00:31:36.306
you only need the descriptor to

00:31:36.306 --> 00:31:37.546
create that object.

00:31:38.156 --> 00:31:40.456
Here's some code showing how to

00:31:40.456 --> 00:31:41.726
build these pipeline state

00:31:41.726 --> 00:31:42.226
objects.

00:31:43.536 --> 00:31:44.916
Before you create the pipeline,

00:31:45.096 --> 00:31:47.456
you'll need to get the shaders

00:31:47.456 --> 00:31:48.686
out of a Metal library.

00:31:49.256 --> 00:31:51.446
This line here loads the default

00:31:51.446 --> 00:31:53.816
Metal library that we built in

00:31:54.416 --> 00:31:54.586
Xcode.

00:31:54.726 --> 00:31:56.616
For this library you can obtain

00:31:56.616 --> 00:31:58.316
your vertex and fragment shader

00:31:59.116 --> 00:32:00.726
using their function names.

00:32:01.906 --> 00:32:03.146
You create a render pipeline

00:32:03.146 --> 00:32:05.316
descriptor object where you set

00:32:05.316 --> 00:32:06.866
these shading functions and also

00:32:06.866 --> 00:32:08.826
specify render target pixel

00:32:08.826 --> 00:32:09.356
formats.

00:32:10.306 --> 00:32:12.336
Finally, you use the device with

00:32:12.336 --> 00:32:13.726
the descriptor object we've set

00:32:13.726 --> 00:32:16.176
up to produce a pipeline state

00:32:16.826 --> 00:32:17.026
object.

00:32:18.136 --> 00:32:19.836
The most significant difference

00:32:19.866 --> 00:32:21.906
between the OpenGL and Metal

00:32:21.936 --> 00:32:25.316
graphics pipelines is that while

00:32:25.316 --> 00:32:26.856
an OpenGL program object

00:32:26.896 --> 00:32:28.196
contains just a vertex and

00:32:28.226 --> 00:32:29.906
fragment shader pair Metal

00:32:29.946 --> 00:32:31.816
pipeline objects also include a

00:32:31.816 --> 00:32:33.536
vertex layout, blend state, and

00:32:33.536 --> 00:32:34.726
render target pixel format.

00:32:35.566 --> 00:32:36.776
So you need to know all of these

00:32:36.816 --> 00:32:38.886
things before you build a

00:32:39.696 --> 00:32:39.896
pipeline.

00:32:40.016 --> 00:32:41.576
Having these extra pieces of

00:32:41.646 --> 00:32:43.166
state in the pipeline enables

00:32:43.166 --> 00:32:44.886
Metal to fully compile shaders

00:32:44.886 --> 00:32:46.746
into GPU machine code upon

00:32:46.816 --> 00:32:47.576
object creation.

00:32:48.116 --> 00:32:49.006
This is something that's not

00:32:49.006 --> 00:32:50.326
possible with OpenGL's program

00:32:50.326 --> 00:32:50.836
objects.

00:32:51.706 --> 00:32:52.796
Now you'll need to build a

00:32:52.796 --> 00:32:54.146
system that allows you to create

00:32:54.146 --> 00:32:55.896
pipelines when you initialize

00:32:55.896 --> 00:32:56.086
your app.

00:32:57.266 --> 00:32:58.236
It helps if you can choose a

00:32:58.236 --> 00:32:59.816
canonical vertex layout and a

00:32:59.816 --> 00:33:01.546
limited set of render targets.

00:33:02.156 --> 00:33:03.766
This reduces the combinations of

00:33:03.766 --> 00:33:05.486
state your app uses and the

00:33:05.486 --> 00:33:07.116
number of pipeline objects

00:33:07.556 --> 00:33:07.706
needed.

00:33:08.976 --> 00:33:10.786
However, not everyone knows up

00:33:10.846 --> 00:33:12.286
front which pipelines their app

00:33:12.286 --> 00:33:12.656
will need.

00:33:13.286 --> 00:33:14.666
A common first step in porting

00:33:14.666 --> 00:33:16.306
an app to Metal is to keep a

00:33:16.306 --> 00:33:17.786
dictionary of pipelines you've

00:33:17.786 --> 00:33:18.396
already made.

00:33:19.326 --> 00:33:20.566
As your app encounters new

00:33:20.566 --> 00:33:22.196
combinations of state it can

00:33:22.196 --> 00:33:23.836
build and store pipelines using

00:33:23.836 --> 00:33:25.326
the descriptors as keys.

00:33:26.626 --> 00:33:28.206
Keep in mind this solution I

00:33:28.206 --> 00:33:30.326
mentioned is kind of a hack and

00:33:30.326 --> 00:33:31.406
you want to avoid shipping your

00:33:31.406 --> 00:33:31.856
app with it.

00:33:32.426 --> 00:33:33.856
This is because creating any of

00:33:33.856 --> 00:33:35.316
these objects is expensive.

00:33:36.346 --> 00:33:37.196
When you create a pipeline

00:33:37.196 --> 00:33:39.336
object the GPU compiler kicks in

00:33:39.336 --> 00:33:41.396
and translates and optimizes the

00:33:41.396 --> 00:33:42.786
shader's binary intermediate

00:33:42.786 --> 00:33:44.636
representation to machine code.

00:33:45.386 --> 00:33:46.356
If your app creates these

00:33:46.386 --> 00:33:47.986
just-in-time during its render

00:33:47.986 --> 00:33:51.046
loop you're likely to see stalls

00:33:51.356 --> 00:33:53.046
and a reduced frame rate for a

00:33:53.046 --> 00:33:55.786
short period of time.

00:33:55.986 --> 00:33:57.366
Allocating memory for textures

00:33:57.366 --> 00:33:58.906
and buffers is also an expensive

00:33:58.906 --> 00:34:00.526
operation, that's not even

00:34:00.526 --> 00:34:01.586
accounting for the processing

00:34:01.586 --> 00:34:02.896
required to fill in these

00:34:02.896 --> 00:34:03.726
resources with data.

00:34:04.946 --> 00:34:06.076
However, once you've created

00:34:06.076 --> 00:34:07.866
these objects using them in your

00:34:07.866 --> 00:34:09.646
render loop requires very little

00:34:09.746 --> 00:34:11.045
CPU over [inaudible] since so

00:34:11.045 --> 00:34:12.966
much is done up front.

00:34:14.176 --> 00:34:15.485
With that I'd like to hand it

00:34:15.485 --> 00:34:16.716
over to Sukanya who will talk

00:34:16.716 --> 00:34:17.735
about porting your render loop.

00:34:18.516 --> 00:34:22.545
[ Applause ]

00:34:23.045 --> 00:34:24.065
>> Good evening everyone, I am

00:34:24.065 --> 00:34:25.886
Sukanya Sudugu, GPU software

00:34:25.886 --> 00:34:26.856
engineer at Apple.

00:34:27.646 --> 00:34:29.696
I am super excited to share some

00:34:29.696 --> 00:34:31.496
of our porting experience with

00:34:31.496 --> 00:34:32.976
you, so let's continue porting.

00:34:35.876 --> 00:34:37.096
Dan already talked about

00:34:37.096 --> 00:34:39.496
application setup, so by now you

00:34:39.496 --> 00:34:40.795
would have built all your

00:34:40.795 --> 00:34:43.596
shaders and also created all

00:34:43.596 --> 00:34:45.216
persistent objects needed for

00:34:45.216 --> 00:34:46.275
frame generation.

00:34:47.196 --> 00:34:48.656
So now let's dive into your

00:34:48.656 --> 00:34:50.795
application's render loop which

00:34:50.795 --> 00:34:52.516
is the code that runs for every

00:34:52.516 --> 00:34:52.926
frame.

00:34:53.186 --> 00:34:55.996
With Metal you will explicitly

00:34:55.996 --> 00:34:57.616
manage the asynchronous nature

00:34:57.616 --> 00:34:59.556
of GPU's execution in your

00:34:59.556 --> 00:35:00.196
render loop.

00:35:00.876 --> 00:35:03.156
So this includes obtaining and

00:35:03.206 --> 00:35:04.826
submitting command buffers to

00:35:04.826 --> 00:35:06.426
GPU with the list of GPU

00:35:06.426 --> 00:35:06.736
commands.

00:35:06.736 --> 00:35:10.046
And updating your resources in

00:35:10.046 --> 00:35:12.206
such a way that allows the GPU

00:35:12.206 --> 00:35:13.926
to asynchronously read from it

00:35:14.566 --> 00:35:16.086
which you have written in your

00:35:16.176 --> 00:35:16.726
render loop.

00:35:17.266 --> 00:35:19.526
And encoding render passes by

00:35:19.526 --> 00:35:20.686
creating render command

00:35:20.686 --> 00:35:21.326
encoders.

00:35:21.936 --> 00:35:24.636
And finally, presenting your

00:35:24.636 --> 00:35:25.776
frames to the display.

00:35:25.776 --> 00:35:29.196
So let's first talk about this

00:35:29.196 --> 00:35:30.356
command buffer object.

00:35:32.396 --> 00:35:34.066
One of the key changes from

00:35:34.066 --> 00:35:36.536
OpenGL is that Metal provides

00:35:36.606 --> 00:35:38.196
explicit control over command

00:35:38.196 --> 00:35:40.366
buffers, which means it's up to

00:35:40.366 --> 00:35:42.396
you to create these command

00:35:42.396 --> 00:35:44.106
buffers and you can decide when

00:35:44.106 --> 00:35:45.766
to commit them to GPU for its

00:35:45.766 --> 00:35:46.486
execution.

00:35:47.306 --> 00:35:49.496
So the straightforward thing to

00:35:49.496 --> 00:35:51.056
do is to create one command

00:35:51.056 --> 00:35:52.476
buffer which will render your

00:35:52.476 --> 00:35:53.236
whole frame.

00:35:53.946 --> 00:35:55.796
And once your application is up

00:35:55.796 --> 00:35:57.916
and running and if you perhaps

00:35:57.916 --> 00:35:59.816
see some idle time on GPU, then

00:35:59.816 --> 00:36:01.976
you might want to consider

00:36:02.146 --> 00:36:03.396
splitting your frame across

00:36:03.396 --> 00:36:04.606
multiple command buffers.

00:36:05.006 --> 00:36:08.086
And then the GPU can get started

00:36:08.086 --> 00:36:09.796
executing one command buffer

00:36:10.086 --> 00:36:11.486
while CPU is encoding the

00:36:11.486 --> 00:36:11.886
others.

00:36:13.346 --> 00:36:15.106
Alternatively, splitting your

00:36:15.106 --> 00:36:17.386
frame encoding across multiple

00:36:17.386 --> 00:36:19.136
threads requires you to create

00:36:19.136 --> 00:36:20.436
one command buffer per thread.

00:36:20.436 --> 00:36:23.196
But keep in mind that there is

00:36:23.196 --> 00:36:25.056
some additional CPU cost

00:36:25.056 --> 00:36:26.666
associated with each command

00:36:26.666 --> 00:36:27.056
buffer.

00:36:27.496 --> 00:36:29.446
So you should be using as few as

00:36:29.516 --> 00:36:30.066
possible.

00:36:32.216 --> 00:36:34.306
Metal also provides an API to

00:36:34.356 --> 00:36:36.436
register a completion callback,

00:36:37.136 --> 00:36:38.846
which will be involved when GPU

00:36:38.846 --> 00:36:41.006
completes executing this command

00:36:41.006 --> 00:36:41.386
buffer.

00:36:41.986 --> 00:36:43.686
So let me show you all these

00:36:43.686 --> 00:36:44.766
APIs in action.

00:36:45.216 --> 00:36:48.316
So you will have created command

00:36:48.316 --> 00:36:49.516
queue in your application

00:36:49.516 --> 00:36:50.856
initialization method.

00:36:51.356 --> 00:36:53.246
Now in render loop you will use

00:36:53.246 --> 00:36:55.676
it to obtain command buffer by

00:36:55.676 --> 00:36:56.876
calling its command buffer

00:36:56.876 --> 00:36:57.386
method.

00:36:57.946 --> 00:37:00.156
Now you will encode commands

00:37:00.156 --> 00:37:01.156
into this command buffer.

00:37:01.156 --> 00:37:03.086
I'll talk more about this

00:37:03.146 --> 00:37:04.616
encoder shortly.

00:37:05.936 --> 00:37:06.936
But when you are finished

00:37:06.936 --> 00:37:08.846
encoding you will call commit

00:37:08.846 --> 00:37:11.446
method so that this command

00:37:11.446 --> 00:37:13.136
buffer will be submitted to GPU

00:37:13.386 --> 00:37:14.366
for its execution.

00:37:14.366 --> 00:37:17.846
Now you have two options for

00:37:17.916 --> 00:37:19.686
what to do while this command

00:37:19.686 --> 00:37:21.806
buffer is being executed on GPU.

00:37:22.316 --> 00:37:25.526
You can wait by calling this

00:37:25.526 --> 00:37:27.436
waitUntilCompleted method which

00:37:27.436 --> 00:37:29.256
is similar to glFinish in

00:37:29.256 --> 00:37:29.956
OpenGL.

00:37:30.896 --> 00:37:33.026
This method will synchronously

00:37:33.026 --> 00:37:35.456
wait and only returns when all

00:37:35.456 --> 00:37:36.636
the commands in the command

00:37:36.636 --> 00:37:38.296
buffer has been executed by the

00:37:38.296 --> 00:37:38.806
GPU.

00:37:40.916 --> 00:37:44.816
Alternatively, before you commit

00:37:44.816 --> 00:37:46.206
this command buffer to GPU you

00:37:46.206 --> 00:37:48.566
can add a completion handler,

00:37:49.406 --> 00:37:51.286
which will be invoked when GPU

00:37:51.286 --> 00:37:52.916
is done executing this command

00:37:52.916 --> 00:37:53.296
buffer.

00:37:53.946 --> 00:37:56.476
This allows CPU and GPU to

00:37:56.476 --> 00:37:57.576
execute in parallel.

00:37:58.456 --> 00:38:00.486
Also this allows us to track and

00:38:00.486 --> 00:38:02.116
efficiently update shared

00:38:02.116 --> 00:38:04.236
resources whose data is changing

00:38:04.236 --> 00:38:05.076
every frame.

00:38:05.556 --> 00:38:08.676
Since we are here let's talk

00:38:08.676 --> 00:38:09.876
more about these resource

00:38:09.876 --> 00:38:12.486
updates and see how we can make

00:38:12.486 --> 00:38:13.796
them efficient using this

00:38:13.796 --> 00:38:14.656
completion handler.

00:38:14.656 --> 00:38:18.626
So almost all applications will

00:38:18.626 --> 00:38:21.066
be pushing new data to GPU every

00:38:21.066 --> 00:38:21.436
frame.

00:38:21.926 --> 00:38:24.206
For example, new shaded uniforms

00:38:24.316 --> 00:38:25.716
needed for animations.

00:38:26.256 --> 00:38:29.146
In Metal CPU can write to this

00:38:29.146 --> 00:38:31.776
shared resources anytime even if

00:38:31.886 --> 00:38:33.966
GP is accessing the same memory

00:38:35.206 --> 00:38:36.276
at the same time.

00:38:37.376 --> 00:38:38.876
Metal does not protect you

00:38:38.876 --> 00:38:40.456
against these data-races.

00:38:41.256 --> 00:38:44.176
This compares to OpenGL which by

00:38:44.176 --> 00:38:45.666
default prevents these

00:38:45.666 --> 00:38:48.056
data-races either by waiting for

00:38:48.056 --> 00:38:50.676
the GPU workloads to finish or

00:38:50.676 --> 00:38:53.166
by doing extra copies, which may

00:38:53.166 --> 00:38:54.586
not be optimal for your

00:38:54.586 --> 00:38:55.376
application.

00:38:56.256 --> 00:38:58.756
With Metal you can implement any

00:38:58.756 --> 00:39:01.546
optimal synchronization strategy

00:39:01.546 --> 00:39:02.566
which suits best for your

00:39:02.566 --> 00:39:03.376
applications.

00:39:04.256 --> 00:39:06.966
So in most cases, best approach

00:39:07.026 --> 00:39:08.686
is to multi-buffer your shared

00:39:08.686 --> 00:39:11.706
resources so that CPU and GPU

00:39:11.706 --> 00:39:13.286
are never trying to access the

00:39:13.286 --> 00:39:15.136
same buffer simultaneously.

00:39:17.436 --> 00:39:19.916
So let's see an example, you

00:39:19.916 --> 00:39:22.126
have an OpenGL application and

00:39:22.126 --> 00:39:24.676
you just ported it to Metal and

00:39:24.736 --> 00:39:26.296
it is using single buffer for

00:39:26.296 --> 00:39:28.956
these dynamic data updates and

00:39:28.956 --> 00:39:30.386
you did not implement any

00:39:30.386 --> 00:39:32.766
synchronization method yet in

00:39:32.766 --> 00:39:34.306
your application, then here's

00:39:34.306 --> 00:39:36.356
what will happen.

00:39:36.906 --> 00:39:38.316
Your application will write to

00:39:38.316 --> 00:39:39.956
that buffer while generating

00:39:39.956 --> 00:39:41.866
commands for the first frame and

00:39:41.866 --> 00:39:43.336
then submits this command buffer

00:39:43.336 --> 00:39:45.426
to GPU.

00:39:45.426 --> 00:39:47.406
Then GPU when it is executing

00:39:47.406 --> 00:39:48.876
this command buffer will try to

00:39:48.876 --> 00:39:49.896
read from this buffer.

00:39:50.436 --> 00:39:53.796
And while you're updating the

00:39:53.796 --> 00:39:55.446
same buffer for the next frame

00:39:55.686 --> 00:39:57.486
GPU is still reading from this

00:39:57.486 --> 00:39:57.816
buffer.

00:39:58.076 --> 00:40:01.266
So this is clearly a race

00:40:01.266 --> 00:40:03.236
condition and the results are

00:40:03.236 --> 00:40:03.806
undefined.

00:40:03.806 --> 00:40:06.826
There are a few potential fixes

00:40:07.356 --> 00:40:09.066
which you can implement in your

00:40:09.066 --> 00:40:09.806
application.

00:40:10.396 --> 00:40:13.386
The simplest is to call the

00:40:13.386 --> 00:40:14.396
command buffer's

00:40:14.396 --> 00:40:16.736
waitUntilCompleted method after

00:40:16.736 --> 00:40:17.306
every frame.

00:40:18.516 --> 00:40:22.556
But this waits for the GPU to

00:40:22.556 --> 00:40:24.246
finish reading before you

00:40:24.246 --> 00:40:25.706
override this buffer for the

00:40:25.706 --> 00:40:26.296
next frame.

00:40:27.096 --> 00:40:30.936
But as you can see, here this is

00:40:30.936 --> 00:40:32.866
a very poor utilization of both

00:40:33.036 --> 00:40:35.606
CPU and GPU, so this is not

00:40:35.606 --> 00:40:37.376
something you want to do in your

00:40:37.466 --> 00:40:38.166
shipping code.

00:40:38.936 --> 00:40:40.756
But it is very useful to get

00:40:40.756 --> 00:40:42.426
your Metal application up and

00:40:42.426 --> 00:40:42.856
running.

00:40:43.746 --> 00:40:45.976
And even to detect that if your

00:40:45.976 --> 00:40:47.766
application really indeed has

00:40:47.766 --> 00:40:49.716
these kind of data conflicts.

00:40:51.756 --> 00:40:54.366
The efficient way to synchronize

00:40:54.366 --> 00:40:55.926
your resource updates is to use

00:40:55.926 --> 00:40:56.826
multiple buffers.

00:40:57.546 --> 00:40:58.906
So in this case we will use

00:40:58.956 --> 00:41:00.526
three buffers to triple buffer

00:41:00.526 --> 00:41:02.126
our dynamic data updates.

00:41:02.816 --> 00:41:04.756
So in frame 1 we will write to a

00:41:04.756 --> 00:41:06.846
buffer and then the GPU will

00:41:06.846 --> 00:41:07.516
read from it.

00:41:08.206 --> 00:41:10.166
And in frame 2 we will write to

00:41:10.166 --> 00:41:11.856
another buffer avoiding this

00:41:11.856 --> 00:41:12.666
race condition.

00:41:13.326 --> 00:41:15.246
Similarly, in frame 3 we will

00:41:15.246 --> 00:41:18.146
write the third buffer.

00:41:18.346 --> 00:41:20.176
But now we have used up all

00:41:20.176 --> 00:41:21.836
three buffers and exhausted our

00:41:21.836 --> 00:41:22.406
buffer pool.

00:41:23.526 --> 00:41:25.246
We need to wait for the GPU to

00:41:25.246 --> 00:41:27.166
finish the frame 1 so that we

00:41:27.166 --> 00:41:28.616
can reuse it for frame 4.

00:41:29.186 --> 00:41:33.736
Now this completion handler will

00:41:33.736 --> 00:41:35.906
come handy, it will let us know

00:41:35.906 --> 00:41:38.046
when GPU has done executing this

00:41:38.096 --> 00:41:38.406
frame.

00:41:39.096 --> 00:41:41.396
So when frame 1 is done we can

00:41:41.396 --> 00:41:43.586
reuse its buffer for frame 4 and

00:41:44.396 --> 00:41:44.916
so on.

00:41:44.916 --> 00:41:48.696
So let's look at a sample.

00:41:49.226 --> 00:41:52.916
For triple buffer implementation

00:41:53.326 --> 00:41:55.316
outside your render loop first

00:41:55.316 --> 00:41:56.996
we will create a FIFO queue of

00:41:57.086 --> 00:41:57.726
three buffers.

00:41:58.286 --> 00:42:01.006
And we also need a

00:42:01.006 --> 00:42:02.616
frameBoundarySemaphore which is

00:42:02.616 --> 00:42:04.466
initialized to start value as 3.

00:42:05.096 --> 00:42:06.906
So this says semaphore will be

00:42:06.906 --> 00:42:09.276
signaled at each frame boundary,

00:42:09.576 --> 00:42:11.246
that is when GPU finishes

00:42:11.246 --> 00:42:14.046
executing a frame allowing the

00:42:14.046 --> 00:42:17.466
CPU to reuse its buffer.

00:42:17.466 --> 00:42:19.826
Also initialize buffer index to

00:42:19.826 --> 00:42:22.706
point to the current frame's

00:42:23.336 --> 00:42:23.466
buffer.

00:42:23.806 --> 00:42:26.386
And in our render loop before we

00:42:26.386 --> 00:42:28.006
write to a buffer we need to

00:42:28.006 --> 00:42:30.006
first ensure that its

00:42:30.006 --> 00:42:31.276
corresponding frame has

00:42:31.326 --> 00:42:33.176
completed its execution on the

00:42:33.376 --> 00:42:33.926
GPU.

00:42:34.366 --> 00:42:35.836
So at the beginning of the frame

00:42:36.236 --> 00:42:37.386
we wait on our

00:42:37.386 --> 00:42:38.656
frameBoundarySemaphore.

00:42:39.696 --> 00:42:41.386
Once the semaphore is signaled

00:42:41.506 --> 00:42:42.786
indicating that the current

00:42:42.786 --> 00:42:44.166
frame has completed its

00:42:44.166 --> 00:42:46.126
execution on GPU now it's safe

00:42:47.536 --> 00:42:50.846
to grab its buffer and reuse for

00:42:50.846 --> 00:42:51.716
new frame data.

00:42:52.406 --> 00:42:55.426
And we will now encode some

00:42:55.426 --> 00:42:57.846
commands to bind this buffer to

00:42:58.886 --> 00:42:59.176
GPU.

00:42:59.176 --> 00:43:01.186
And before we commit this

00:43:01.186 --> 00:43:03.066
command buffer to GPU we will

00:43:03.066 --> 00:43:05.156
add a completion handler to this

00:43:05.156 --> 00:43:06.556
command buffer for this frame.

00:43:07.186 --> 00:43:10.066
After adding completion handler

00:43:10.066 --> 00:43:11.166
we will commit this command

00:43:11.166 --> 00:43:12.026
buffer to GPU.

00:43:12.926 --> 00:43:16.036
Now once GPU finishes executing

00:43:16.036 --> 00:43:17.806
this frame our completion

00:43:17.806 --> 00:43:19.846
handler will be invoked which

00:43:19.846 --> 00:43:21.486
will then signal this frame

00:43:21.486 --> 00:43:22.006
semaphore.

00:43:23.766 --> 00:43:26.156
This allows CPU to reuse its

00:43:26.186 --> 00:43:27.986
buffer for new frame encoding.

00:43:28.786 --> 00:43:30.666
So this was a simple triple

00:43:30.666 --> 00:43:32.196
buffer implementation which you

00:43:32.196 --> 00:43:33.846
can adopt for handling any

00:43:33.846 --> 00:43:35.996
dynamic data resource updates.

00:43:36.476 --> 00:43:39.376
Now that we have our command

00:43:39.376 --> 00:43:41.426
buffer and also, we have handled

00:43:41.726 --> 00:43:44.246
our resource updates let's talk

00:43:44.246 --> 00:43:46.136
more about render pass encoders

00:43:46.626 --> 00:43:48.306
which you will use to encode

00:43:48.306 --> 00:43:49.796
your draw calls.

00:43:50.276 --> 00:43:52.496
As Dan mentioned earlier,

00:43:52.496 --> 00:43:56.906
command encoders translate API

00:43:57.146 --> 00:43:59.046
calls into GPU hardware commands

00:43:59.046 --> 00:43:59.926
in a command buffer.

00:43:59.926 --> 00:44:02.936
I will be talking about render

00:44:02.936 --> 00:44:04.626
command encoders which provides

00:44:04.626 --> 00:44:06.656
APIs for typical graphics,

00:44:06.816 --> 00:44:08.216
operations like setting your

00:44:08.216 --> 00:44:10.186
pipelines, texture buffer

00:44:10.186 --> 00:44:11.696
objects, and also issuing the

00:44:11.696 --> 00:44:12.276
draw calls.

00:44:12.786 --> 00:44:16.816
So when creating your encoder

00:44:16.966 --> 00:44:18.336
you need to first set the render

00:44:18.336 --> 00:44:18.906
targets.

00:44:18.936 --> 00:44:20.756
So here is a render pass

00:44:20.756 --> 00:44:22.396
descriptor where you will set

00:44:22.396 --> 00:44:24.746
the render targets and then ask

00:44:24.746 --> 00:44:26.586
the command buffer to create a

00:44:26.586 --> 00:44:28.256
new encoder for this render

00:44:28.256 --> 00:44:28.706
pass.

00:44:29.366 --> 00:44:31.186
And now you can use this encoder

00:44:31.186 --> 00:44:33.256
to encode your draw calls.

00:44:35.136 --> 00:44:37.946
One key change from OpenGL is in

00:44:38.106 --> 00:44:40.666
Metal once the encoder is

00:44:40.666 --> 00:44:42.736
created you cannot change its

00:44:42.736 --> 00:44:45.606
render targets because GPU

00:44:45.696 --> 00:44:47.646
performs much better when it

00:44:47.646 --> 00:44:49.776
sees a largest span of draw

00:44:49.776 --> 00:44:51.436
calls which are rendering to the

00:44:51.436 --> 00:44:53.106
same set of render targets.

00:44:54.046 --> 00:44:56.906
So Metal API reflects this by

00:44:57.246 --> 00:44:59.876
giving an explicit start and end

00:44:59.956 --> 00:45:00.906
to a render pass.

00:45:01.316 --> 00:45:03.636
Now all the draws issued by this

00:45:03.636 --> 00:45:05.596
encoder will be rendering to

00:45:05.596 --> 00:45:06.936
these render targets.

00:45:08.566 --> 00:45:09.816
When you want to draw to a

00:45:09.816 --> 00:45:11.406
different set of render targets

00:45:11.576 --> 00:45:13.246
then you end this render pass

00:45:13.246 --> 00:45:14.226
and start a new one.

00:45:14.756 --> 00:45:18.936
And here is where we are

00:45:18.936 --> 00:45:20.286
creating a render pass

00:45:20.286 --> 00:45:22.916
descriptor and binding color and

00:45:22.916 --> 00:45:23.876
depth attachments.

00:45:25.166 --> 00:45:27.036
Now you can use that descriptor

00:45:27.086 --> 00:45:29.026
and create a render command

00:45:29.026 --> 00:45:29.716
encoder.

00:45:30.436 --> 00:45:33.116
Now all the draws issued by this

00:45:33.116 --> 00:45:34.506
encoder will be rendering to

00:45:34.506 --> 00:45:34.966
these targets.

00:45:37.216 --> 00:45:39.426
Additionally, in Metal you can

00:45:39.426 --> 00:45:41.856
also provide load and store

00:45:41.856 --> 00:45:43.546
actions for these attachments

00:45:43.786 --> 00:45:45.526
for optional GPU bandwidth

00:45:45.526 --> 00:45:46.126
usage.

00:45:48.236 --> 00:45:50.076
So these load and store actions

00:45:50.076 --> 00:45:52.086
allow you to control how the

00:45:52.086 --> 00:45:53.796
texture contents will be handled

00:45:53.956 --> 00:45:55.486
before and after a rendered

00:45:55.526 --> 00:45:55.876
pass.

00:45:56.266 --> 00:45:59.016
So here we have color and depth

00:45:59.016 --> 00:46:01.856
attachments for a render pass.

00:46:02.066 --> 00:46:03.856
If it specified the load action

00:46:03.856 --> 00:46:05.906
as clear for both of these

00:46:05.906 --> 00:46:08.346
render targets the GPU will

00:46:08.386 --> 00:46:09.836
first clear their contents.

00:46:10.266 --> 00:46:13.246
Then the GPU will execute

00:46:13.246 --> 00:46:14.556
commands in this encoder

00:46:14.556 --> 00:46:15.686
rendering to these render

00:46:15.686 --> 00:46:16.346
targets.

00:46:16.886 --> 00:46:19.616
Now you can specify the store

00:46:19.616 --> 00:46:21.026
actions to be performed at the

00:46:21.136 --> 00:46:22.176
end of the render pass.

00:46:22.536 --> 00:46:24.486
Here for the color buffer since

00:46:24.486 --> 00:46:25.996
the store action is store it

00:46:25.996 --> 00:46:28.656
will preserve the contents of

00:46:28.686 --> 00:46:30.256
this color buffer at the end of

00:46:30.256 --> 00:46:30.966
the render pass.

00:46:31.576 --> 00:46:33.006
And for the depth attachment,

00:46:33.006 --> 00:46:35.286
since we said store action as

00:46:35.286 --> 00:46:37.176
don't care it will discard its

00:46:37.176 --> 00:46:37.786
contents.

00:46:39.006 --> 00:46:40.876
So these texture load and stores

00:46:40.876 --> 00:46:42.806
are expensive GPU operations

00:46:42.806 --> 00:46:44.376
that consumes memory bandwidth.

00:46:44.946 --> 00:46:47.346
So choose clear and don't care

00:46:47.346 --> 00:46:48.416
wherever possible.

00:46:48.976 --> 00:46:51.816
And here is how you set your

00:46:51.896 --> 00:46:52.246
action.

00:46:52.526 --> 00:46:54.876
In this example we specify clear

00:46:54.876 --> 00:46:57.246
as a load action and set the

00:46:57.286 --> 00:46:57.966
clear color.

00:46:59.186 --> 00:47:00.806
And here we specify store action

00:47:00.806 --> 00:47:01.236
as store.

00:47:01.806 --> 00:47:03.656
Similarly, you can specify load

00:47:03.656 --> 00:47:05.636
and store action for each of the

00:47:05.636 --> 00:47:07.196
render targets you set in this

00:47:07.196 --> 00:47:08.326
render pass descriptor.

00:47:08.926 --> 00:47:11.936
So that's how we configured our

00:47:11.936 --> 00:47:12.896
render targets.

00:47:12.946 --> 00:47:16.596
Now you can create the encoder

00:47:16.596 --> 00:47:19.076
from this descriptor and we can

00:47:19.076 --> 00:47:20.526
start encoding draw calls.

00:47:21.886 --> 00:47:23.606
But before that I want to show

00:47:23.606 --> 00:47:25.756
you some OpenGL commands and

00:47:25.756 --> 00:47:27.326
they will show you their Metal

00:47:27.326 --> 00:47:28.146
equivalents.

00:47:28.686 --> 00:47:31.976
So this is a typical OpenGL draw

00:47:31.976 --> 00:47:32.626
sequence.

00:47:33.156 --> 00:47:36.526
In this segment first we bind a

00:47:36.526 --> 00:47:38.776
frame buffer which will set all

00:47:38.776 --> 00:47:39.826
the render targets.

00:47:41.096 --> 00:47:42.966
Then we bind our program which

00:47:42.966 --> 00:47:45.056
contains vertex and fragment

00:47:45.536 --> 00:47:45.676
shader.

00:47:46.226 --> 00:47:48.206
And we bind vertex buffer

00:47:48.206 --> 00:47:49.676
containing vertex data.

00:47:50.136 --> 00:47:53.036
And then we bind another buffer

00:47:53.036 --> 00:47:54.576
containing all the uniforms.

00:47:55.416 --> 00:47:57.686
And then we'll set a texture to

00:47:57.686 --> 00:47:58.536
sample from.

00:47:59.776 --> 00:48:00.916
And finally, we draw.

00:48:01.546 --> 00:48:03.956
So here is the Metal equivalent,

00:48:04.566 --> 00:48:05.956
it's a few more lines of code

00:48:05.996 --> 00:48:07.936
since it's explicit but it's

00:48:07.936 --> 00:48:09.766
actually very similar to OpenGL.

00:48:10.586 --> 00:48:11.866
First, we create a render

00:48:11.866 --> 00:48:13.336
command encoder using render

00:48:13.336 --> 00:48:15.456
pass descriptor which has our

00:48:15.456 --> 00:48:16.346
render targets.

00:48:17.696 --> 00:48:19.296
Then we set a pipeline object

00:48:19.296 --> 00:48:20.506
which has our shaders.

00:48:21.836 --> 00:48:24.606
Then we set a buffer for

00:48:24.606 --> 00:48:26.276
accessing our vertex shader and

00:48:26.676 --> 00:48:27.836
this happens to contain the

00:48:27.836 --> 00:48:29.226
vertices we will draw with.

00:48:30.436 --> 00:48:32.316
Note that the Metal doesn't

00:48:32.316 --> 00:48:33.846
distinguish between buffers

00:48:33.846 --> 00:48:36.026
containing uniforms or those

00:48:36.026 --> 00:48:37.176
containing vertices.

00:48:37.816 --> 00:48:40.276
So we will use the same API to

00:48:40.276 --> 00:48:41.386
set uniform buffer.

00:48:41.386 --> 00:48:44.026
So here the first call will give

00:48:44.026 --> 00:48:46.026
buffer access to vertex shader

00:48:46.026 --> 00:48:47.236
while the second call will give

00:48:47.236 --> 00:48:48.746
access to the fragment shader.

00:48:49.286 --> 00:48:52.166
Next, we set a texture for our

00:48:52.166 --> 00:48:54.026
fragment shader to sample from.

00:48:54.516 --> 00:48:56.556
And then we draw.

00:48:57.076 --> 00:48:59.846
And once we are done encoding

00:48:59.846 --> 00:49:01.456
commands we will indicate this

00:49:01.456 --> 00:49:03.396
to Metal by calling endEncoding

00:49:03.396 --> 00:49:05.376
on the encoder object.

00:49:06.196 --> 00:49:07.916
So this was a simple example of

00:49:07.916 --> 00:49:09.406
a metal render pass.

00:49:09.926 --> 00:49:12.926
Now that we have a complete

00:49:12.926 --> 00:49:14.696
render pass let's see how to get

00:49:14.696 --> 00:49:16.286
these renderings onto the

00:49:16.286 --> 00:49:16.806
display.

00:49:17.336 --> 00:49:21.526
With OpenGL you present your

00:49:21.526 --> 00:49:23.156
rendered frame onto the screen

00:49:23.436 --> 00:49:25.336
but you don't explicitly manage

00:49:25.336 --> 00:49:27.996
the system's render buffers also

00:49:27.996 --> 00:49:29.006
known as drawables.

00:49:30.336 --> 00:49:32.126
But with Metal to get your

00:49:32.126 --> 00:49:34.476
content displayed on the screen

00:49:34.906 --> 00:49:36.186
first you need to obtain the

00:49:36.186 --> 00:49:37.516
special textures called

00:49:37.516 --> 00:49:39.116
drawables from the system.

00:49:39.746 --> 00:49:41.676
So you can use a MetalKit view

00:49:41.816 --> 00:49:42.756
which will provide you a

00:49:42.756 --> 00:49:44.846
drawable texture for each frame.

00:49:45.426 --> 00:49:46.886
And once you obtain this

00:49:46.886 --> 00:49:49.276
drawable you can encode render

00:49:49.276 --> 00:49:51.226
passes and render to these

00:49:51.226 --> 00:49:53.096
drawables just like you would

00:49:53.096 --> 00:49:54.586
render to any other texture.

00:49:55.126 --> 00:49:57.766
However, unlike other textures

00:49:57.766 --> 00:49:59.236
now you can present this

00:49:59.236 --> 00:49:59.976
drawable to your view.

00:50:00.096 --> 00:50:02.506
So let me show you a code

00:50:02.506 --> 00:50:02.996
sample.

00:50:03.516 --> 00:50:06.196
First, I want to mention that

00:50:06.196 --> 00:50:07.886
these drawables are limited

00:50:08.166 --> 00:50:10.696
shade system resources, so you

00:50:10.696 --> 00:50:12.206
should hold on to them as

00:50:12.206 --> 00:50:13.536
briefly as possible.

00:50:14.236 --> 00:50:15.776
This means that you should

00:50:15.776 --> 00:50:18.096
encode all your offscreen render

00:50:18.126 --> 00:50:20.016
passes before you acquire a

00:50:20.016 --> 00:50:20.606
drawable.

00:50:21.906 --> 00:50:23.626
Then you can create a MetalKit

00:50:23.626 --> 00:50:26.856
view for either a fully

00:50:26.856 --> 00:50:29.206
populated render pass descriptor

00:50:29.466 --> 00:50:30.926
which you can directly use to

00:50:30.926 --> 00:50:33.836
create encoders, which is what

00:50:33.836 --> 00:50:36.336
you see here or you can ask for

00:50:36.336 --> 00:50:37.746
a specific texture using

00:50:37.976 --> 00:50:41.626
view.currentDrawable property.

00:50:41.626 --> 00:50:42.706
And then you can build your own

00:50:42.706 --> 00:50:44.276
render pass descriptor around

00:50:45.016 --> 00:50:45.086
it.

00:50:47.136 --> 00:50:48.846
Once you are finished encoding

00:50:48.846 --> 00:50:50.496
your frame you can call the

00:50:50.496 --> 00:50:51.896
command buffer's present

00:50:51.896 --> 00:50:53.456
drawable method which puts your

00:50:53.456 --> 00:50:55.626
drawable onto the screen when

00:50:55.626 --> 00:50:57.466
GPU finishes executing this

00:50:57.466 --> 00:50:58.166
command buffer.

00:50:58.986 --> 00:51:00.946
So now once GPU is done

00:51:00.946 --> 00:51:02.586
executing this frame you should

00:51:02.586 --> 00:51:04.116
see your frame on the display.

00:51:04.646 --> 00:51:07.606
So that was our quick tour to

00:51:07.606 --> 00:51:09.286
get your renderings onto the

00:51:09.286 --> 00:51:10.596
display with Metal.

00:51:11.156 --> 00:51:13.856
But I have a few more tips to

00:51:13.856 --> 00:51:14.166
share.

00:51:15.366 --> 00:51:17.296
It is possible to port one

00:51:17.966 --> 00:51:19.596
render pass at a time into

00:51:19.596 --> 00:51:19.936
Metal.

00:51:19.936 --> 00:51:21.436
The IOSurface and CVPixelBuffer

00:51:21.436 --> 00:51:25.696
APIs can be used to create a

00:51:25.726 --> 00:51:27.596
texture which can be shared

00:51:27.596 --> 00:51:29.266
between OpenGL and Metal.

00:51:30.376 --> 00:51:32.586
This will allow you to render to

00:51:32.586 --> 00:51:34.596
a texture in OpenGL and then

00:51:34.596 --> 00:51:36.746
read from it in Metal or vice

00:51:36.746 --> 00:51:36.926
versa.

00:51:36.926 --> 00:51:39.876
So some of the applications can

00:51:39.876 --> 00:51:41.616
leverage this to port

00:51:41.616 --> 00:51:43.476
incrementally, especially with

00:51:43.756 --> 00:51:45.076
plugin architectures which are

00:51:45.076 --> 00:51:46.466
built around OpenGL.

00:51:47.206 --> 00:51:49.546
So there is a sample code linked

00:51:49.686 --> 00:51:51.796
to this session showing exactly

00:51:51.796 --> 00:51:52.846
on how to do this.

00:51:55.416 --> 00:51:56.796
Now that you have a Metal

00:51:56.796 --> 00:51:58.806
application you can adopt all

00:51:58.806 --> 00:51:59.906
new Metal features.

00:52:01.076 --> 00:52:03.046
If your application is CPU bound

00:52:03.046 --> 00:52:05.436
then multithreading your CPU

00:52:05.436 --> 00:52:07.006
encoding work can help.

00:52:07.746 --> 00:52:09.636
You can encode multiple command

00:52:09.636 --> 00:52:11.316
buffers simultaneously on

00:52:11.316 --> 00:52:12.346
separate threads.

00:52:12.926 --> 00:52:14.776
You can even split single

00:52:14.776 --> 00:52:16.556
command buffer encoding across

00:52:16.556 --> 00:52:18.346
multiple threads using parallel

00:52:18.346 --> 00:52:18.976
render command encoder.

00:52:25.046 --> 00:52:26.926
Also, GPUs compute by planned

00:52:26.926 --> 00:52:29.236
processing APIs is built right

00:52:29.236 --> 00:52:30.186
into Metal.

00:52:30.776 --> 00:52:32.946
You can use GPU in whole new

00:52:32.946 --> 00:52:33.536
ways.

00:52:34.046 --> 00:52:36.666
To start with instead of CPU you

00:52:36.666 --> 00:52:38.976
can leverage compute pipeline to

00:52:38.976 --> 00:52:40.746
generate graphics GPU data.

00:52:41.336 --> 00:52:43.616
By letting GPU to generate its

00:52:43.616 --> 00:52:45.346
own data you're not only

00:52:45.346 --> 00:52:47.846
reducing the CPU utilization and

00:52:47.846 --> 00:52:49.776
synchronization points now you

00:52:49.776 --> 00:52:50.796
are freeing up the data

00:52:50.796 --> 00:52:52.106
bandwidth to GPU.

00:52:53.176 --> 00:52:54.946
Now with this high bandwidth

00:52:55.246 --> 00:52:56.846
compute processor you can

00:52:56.846 --> 00:52:58.456
implement many more complex

00:52:58.456 --> 00:52:58.966
algorithms like these.

00:53:03.356 --> 00:53:05.256
Metal supports many more great

00:53:05.296 --> 00:53:07.216
features which you can adopt in

00:53:07.216 --> 00:53:08.886
your application to improve its

00:53:08.886 --> 00:53:09.706
performance.

00:53:10.256 --> 00:53:13.556
In addition, as part of your

00:53:13.596 --> 00:53:15.186
porting process we highly

00:53:15.186 --> 00:53:17.406
encourage to use our Metal

00:53:17.406 --> 00:53:19.096
powerful debugging and

00:53:19.096 --> 00:53:21.226
optimization tools which are

00:53:21.256 --> 00:53:23.456
integrated right into Xcode.

00:53:24.446 --> 00:53:26.476
So Metal has a great API

00:53:26.476 --> 00:53:28.536
validation layer that will print

00:53:28.796 --> 00:53:30.816
detailed information about any

00:53:30.816 --> 00:53:33.176
improper API usage and also

00:53:33.176 --> 00:53:34.756
suggests some potential fixes.

00:53:36.316 --> 00:53:38.826
This is a GPU debugger which

00:53:38.826 --> 00:53:40.536
gives you a capability to step

00:53:40.596 --> 00:53:42.706
through your Metal calls and

00:53:42.706 --> 00:53:44.466
view how your frame is being

00:53:44.466 --> 00:53:45.816
rendered step-by-step.

00:53:46.726 --> 00:53:48.796
You can view all the resources

00:53:48.796 --> 00:53:50.246
associated with your frame.

00:53:50.926 --> 00:53:53.116
It also provides the GPU expert

00:53:53.166 --> 00:53:54.436
tips based on your resource

00:53:54.436 --> 00:53:55.036
usage.

00:53:55.586 --> 00:53:58.916
For this year we have also added

00:53:58.916 --> 00:54:00.556
shader debugging capability

00:54:00.916 --> 00:54:02.326
where you can debug your shader

00:54:02.326 --> 00:54:03.486
functions just like other

00:54:03.486 --> 00:54:04.006
functions.

00:54:04.516 --> 00:54:07.686
We also added a shader profiler

00:54:07.956 --> 00:54:09.646
which showing a rich set of

00:54:09.646 --> 00:54:11.266
performance metrics related to

00:54:11.266 --> 00:54:11.936
your shaders.

00:54:12.046 --> 00:54:15.556
And also, a dependency viewer

00:54:15.556 --> 00:54:17.156
which allows you to evaluate

00:54:17.156 --> 00:54:18.626
dependencies between the render

00:54:18.626 --> 00:54:22.096
passes and you can potentially

00:54:22.096 --> 00:54:24.336
merge any redundant render

00:54:24.336 --> 00:54:26.726
passes to improve your

00:54:26.726 --> 00:54:27.976
application's performance.

00:54:30.216 --> 00:54:32.166
And finally, the Metal system

00:54:32.166 --> 00:54:33.966
trace tool in instruments will

00:54:33.966 --> 00:54:36.696
give you a complete view of your

00:54:36.736 --> 00:54:38.486
application's behavior and

00:54:38.486 --> 00:54:40.276
performance so we highly

00:54:40.276 --> 00:54:42.396
recommend using these tools to

00:54:42.396 --> 00:54:44.146
ease your porting effort.

00:54:45.296 --> 00:54:47.906
Wrapping it up, OpenGL and

00:54:47.906 --> 00:54:49.536
OpenCL are deprecated.

00:54:49.536 --> 00:54:52.656
They are still around but we are

00:54:52.656 --> 00:54:54.466
discouraging their future use.

00:54:54.826 --> 00:54:56.526
It is time to adopt Metal.

00:54:57.216 --> 00:54:59.106
We have full suite of developer

00:54:59.106 --> 00:55:00.806
tools, a lot of experience

00:55:00.806 --> 00:55:02.896
helping many teams successfully

00:55:02.896 --> 00:55:04.616
go through this effort and come

00:55:04.616 --> 00:55:06.376
out with substantially improved

00:55:06.376 --> 00:55:07.006
performance.

00:55:07.736 --> 00:55:09.236
I'm hoping the information we

00:55:09.236 --> 00:55:10.846
shared today will give you

00:55:10.846 --> 00:55:12.356
smooth porting experience.

00:55:12.866 --> 00:55:15.846
And we are very happy to talk to

00:55:15.846 --> 00:55:17.376
you about your applications and

00:55:17.376 --> 00:55:18.836
how to get them up and running

00:55:18.836 --> 00:55:19.406
with Metal.

00:55:20.006 --> 00:55:21.776
So we will be available tomorrow

00:55:21.776 --> 00:55:23.506
afternoon at OpenGL to Metal

00:55:23.666 --> 00:55:25.736
porting lab and there are many

00:55:25.736 --> 00:55:27.696
upcoming sessions on Metal.

00:55:28.006 --> 00:55:29.426
I recommend attending these

00:55:29.426 --> 00:55:31.546
sessions to learn more about how

00:55:31.546 --> 00:55:33.106
to debug and optimize your

00:55:33.106 --> 00:55:34.466
applications with Metal.

00:55:36.106 --> 00:55:37.866
With that I thank you all for

00:55:37.866 --> 00:55:39.706
attending and I hope you enjoy

00:55:39.706 --> 00:55:40.716
the rest of your week.

00:55:41.516 --> 00:55:44.500
[ Applause ]
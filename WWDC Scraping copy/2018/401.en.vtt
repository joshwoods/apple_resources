WEBVTT

00:00:07.016 --> 00:00:15.500
[ Music ]

00:00:25.516 --> 00:00:28.586
[ Applause ]

00:00:29.086 --> 00:00:31.526
>> Good morning and welcome to

00:00:31.526 --> 00:00:32.836
What's New in Swift.

00:00:33.546 --> 00:00:35.316
This has been an exciting year

00:00:35.396 --> 00:00:36.986
for Swift and the Swift

00:00:37.046 --> 00:00:37.596
Community.

00:00:37.966 --> 00:00:39.076
And over the next 40 minutes

00:00:39.136 --> 00:00:40.606
Slava and I are thrilled to give

00:00:40.606 --> 00:00:41.746
you an update on the major

00:00:41.746 --> 00:00:42.526
developments there.

00:00:43.696 --> 00:00:44.956
The session is roughly broken in

00:00:44.956 --> 00:00:45.346
to two parts.

00:00:46.126 --> 00:00:47.296
First I'm going to give an

00:00:47.296 --> 00:00:48.606
update on the Swift open source

00:00:48.646 --> 00:00:51.006
project and the community around

00:00:51.006 --> 00:00:51.126
it.

00:00:51.606 --> 00:00:52.796
And then we'll dive into Swift

00:00:52.796 --> 00:00:54.666
4.2, which is available as a

00:00:54.666 --> 00:00:56.646
preview today in the Xcode 10

00:00:58.046 --> 00:00:58.206
beta.

00:00:58.756 --> 00:01:00.786
Since late 2015, Swift has been

00:01:00.786 --> 00:01:02.476
an open source project on

00:01:02.476 --> 00:01:02.946
GitHub.

00:01:04.546 --> 00:01:06.476
With a vibrant community of

00:01:06.476 --> 00:01:10.226
users who discuss, propose, and

00:01:10.226 --> 00:01:11.556
review all changes to the

00:01:11.556 --> 00:01:13.366
language and standard library.

00:01:15.726 --> 00:01:17.476
In that time over 600

00:01:17.476 --> 00:01:18.776
individuals have contributed

00:01:18.776 --> 00:01:20.926
code to GitHub as Swift open

00:01:20.926 --> 00:01:21.706
source project.

00:01:22.576 --> 00:01:23.686
And together they have merged

00:01:23.686 --> 00:01:26.046
over 18,000 pull requests.

00:01:27.316 --> 00:01:29.386
Since Swift.org was launched

00:01:29.386 --> 00:01:31.326
Swift has been available for

00:01:31.326 --> 00:01:33.966
download on Swift.org both for

00:01:33.966 --> 00:01:35.136
downloadable tool chains for

00:01:35.166 --> 00:01:36.956
Xcode, as well as various

00:01:36.996 --> 00:01:38.216
version of Ubuntu.

00:01:38.646 --> 00:01:39.536
These are both development

00:01:39.536 --> 00:01:43.536
snapshots and official releases.

00:01:45.016 --> 00:01:46.106
Now we want Swift to be

00:01:46.106 --> 00:01:48.646
supported on all platforms so

00:01:48.796 --> 00:01:50.396
everyone can use it.

00:01:50.396 --> 00:01:53.086
And a critical part of that is

00:01:53.086 --> 00:01:54.766
extending the testing support

00:01:55.116 --> 00:01:56.586
provided to the community.

00:01:57.046 --> 00:01:58.476
Various folks in the open source

00:01:58.506 --> 00:02:00.336
project are working on bringing

00:02:00.376 --> 00:02:01.506
Swift support to other

00:02:01.506 --> 00:02:02.106
platforms.

00:02:02.476 --> 00:02:03.786
And we'd like to support those

00:02:03.786 --> 00:02:04.166
efforts.

00:02:05.396 --> 00:02:07.726
About a month ago we extended

00:02:07.726 --> 00:02:08.545
the public continuous

00:02:08.545 --> 00:02:10.006
integration systems to support

00:02:10.006 --> 00:02:12.066
community hosted CI notes.

00:02:12.566 --> 00:02:13.576
So if you are a member of the

00:02:13.576 --> 00:02:14.796
community interested in bringing

00:02:14.796 --> 00:02:16.386
Swift to another platform or

00:02:16.436 --> 00:02:18.046
effort, you can now seamlessly

00:02:18.046 --> 00:02:19.266
plug in your own hardware

00:02:19.266 --> 00:02:20.726
support to bring testing there.

00:02:21.146 --> 00:02:22.776
This is a nice prerequisite for

00:02:22.776 --> 00:02:23.956
supporting Swift in other

00:02:23.956 --> 00:02:24.566
places.

00:02:26.826 --> 00:02:28.816
We've also invested tremendously

00:02:29.056 --> 00:02:31.056
in the community around the

00:02:31.106 --> 00:02:32.716
Swift open source project.

00:02:33.056 --> 00:02:34.036
This is the community that

00:02:34.036 --> 00:02:35.476
discusses all changes to the

00:02:35.476 --> 00:02:35.966
language.

00:02:36.966 --> 00:02:38.936
About six months ago we moved

00:02:38.936 --> 00:02:40.196
from using mailing lists, which

00:02:40.196 --> 00:02:42.016
were very high traffic to

00:02:42.146 --> 00:02:42.556
forums.

00:02:42.986 --> 00:02:44.096
This was at the behest of the

00:02:44.096 --> 00:02:44.746
community.

00:02:45.366 --> 00:02:47.046
Various people were concerned

00:02:47.046 --> 00:02:48.776
that they wanted to be able to

00:02:48.776 --> 00:02:50.446
engage in the project at a level

00:02:50.446 --> 00:02:52.386
that worked well for them but

00:02:52.386 --> 00:02:54.126
found it difficult to do so.

00:02:54.666 --> 00:02:55.586
With the forums you can now

00:02:55.586 --> 00:02:57.656
engage the level that works well

00:02:57.656 --> 00:02:58.066
for you.

00:02:59.496 --> 00:03:00.926
The forums have also worked so

00:03:00.926 --> 00:03:02.476
well that we wanted to extend

00:03:02.476 --> 00:03:04.586
their utility out to supporting

00:03:04.586 --> 00:03:06.746
the general open source project.

00:03:07.476 --> 00:03:10.196
If you maintain a Swift open

00:03:10.196 --> 00:03:11.696
source project such as a popular

00:03:11.696 --> 00:03:13.526
Swift library, you can now use

00:03:13.526 --> 00:03:14.906
the forums for use to discuss

00:03:15.186 --> 00:03:16.436
things on that project such as

00:03:16.436 --> 00:03:18.506
discussions with your users or

00:03:18.506 --> 00:03:19.286
development.

00:03:20.986 --> 00:03:22.376
We've also looked at ways to

00:03:22.376 --> 00:03:24.386
continue to extend Swift.org to

00:03:24.426 --> 00:03:26.016
be of general use the community.

00:03:26.566 --> 00:03:27.876
This week we've moved to hosting

00:03:27.876 --> 00:03:28.936
the Swift programming language

00:03:29.006 --> 00:03:30.486
book to swift.org.

00:03:31.486 --> 00:03:33.706
Located at docs.swift.org, this

00:03:33.706 --> 00:03:35.146
will be a natural place for us

00:03:35.186 --> 00:03:37.716
to extend more documentation for

00:03:37.716 --> 00:03:39.026
use by the community.

00:03:39.606 --> 00:03:42.876
Now the really exciting thing

00:03:42.876 --> 00:03:45.006
about Swift is that people are

00:03:45.006 --> 00:03:46.776
really thrilled about using it.

00:03:46.776 --> 00:03:48.406
And they're talking about it in

00:03:48.406 --> 00:03:49.376
a variety of places.

00:03:49.606 --> 00:03:51.246
At Podcasts, Meetups,

00:03:51.696 --> 00:03:52.556
conferences.

00:03:53.126 --> 00:03:54.916
And we, Apple, thought it was

00:03:54.916 --> 00:03:56.726
very important for us to engage

00:03:56.996 --> 00:03:58.166
in those places because that's

00:03:58.196 --> 00:03:59.496
where a lot of the discussion is

00:03:59.496 --> 00:03:59.966
happening.

00:04:00.736 --> 00:04:02.696
Over the last year we have made

00:04:02.696 --> 00:04:04.116
a very conscious effort to

00:04:04.116 --> 00:04:06.046
engage in those conferences and

00:04:06.046 --> 00:04:09.016
present technical presentations

00:04:09.406 --> 00:04:10.826
on things that we're doing with

00:04:10.826 --> 00:04:13.026
Swift, or how does Swift work,

00:04:13.026 --> 00:04:14.386
or how you can get involved in

00:04:14.386 --> 00:04:15.376
the open source project.

00:04:16.375 --> 00:04:17.576
And this is something we're very

00:04:17.576 --> 00:04:19.156
committed to continuing going

00:04:19.245 --> 00:04:19.616
forward.

00:04:21.466 --> 00:04:22.466
One of these efforts I'd like to

00:04:22.466 --> 00:04:25.096
talk about is a event co-located

00:04:25.166 --> 00:04:26.896
next to WWDC on Friday and that

00:04:26.896 --> 00:04:27.266
is the try!

00:04:27.336 --> 00:04:29.226
Swift San Jose Conference.

00:04:29.866 --> 00:04:31.596
There there will be a workshop

00:04:31.836 --> 00:04:33.256
with members from the community

00:04:33.256 --> 00:04:34.806
to help on board people who are

00:04:34.806 --> 00:04:36.326
interested in contributing to

00:04:36.326 --> 00:04:38.196
the Swift open source project.

00:04:38.626 --> 00:04:39.916
And there will be members from

00:04:39.916 --> 00:04:41.836
Apple's compiler team there to

00:04:42.046 --> 00:04:43.646
also facilitate those

00:04:43.696 --> 00:04:44.416
conversations.

00:04:45.146 --> 00:04:47.896
So that's all about the

00:04:47.896 --> 00:04:48.446
community update.

00:04:49.066 --> 00:04:50.166
Let's talk about Swift 4.2.

00:04:50.166 --> 00:04:52.086
I think the natural place to

00:04:52.126 --> 00:04:53.346
start is well, what is this

00:04:53.346 --> 00:04:54.536
release about and how does it

00:04:54.536 --> 00:04:55.466
fit into the bigger picture?

00:04:58.276 --> 00:04:59.786
Swift updates occur -- some

00:04:59.856 --> 00:05:01.906
major updates occur about twice

00:05:01.906 --> 00:05:02.386
a year.

00:05:02.996 --> 00:05:04.926
And Swift 4.2 is a major update

00:05:04.956 --> 00:05:07.026
over Swift 4.1 and 4.0.

00:05:08.246 --> 00:05:10.116
Now there are in broad strokes

00:05:10.216 --> 00:05:11.736
two themes to this release.

00:05:12.316 --> 00:05:14.686
One is a huge focus on developer

00:05:14.686 --> 00:05:15.386
productivity.

00:05:15.826 --> 00:05:16.946
You can see this in a variety of

00:05:16.946 --> 00:05:17.136
ways.

00:05:17.686 --> 00:05:19.186
The faster builds for projects.

00:05:19.546 --> 00:05:20.826
But also just through and

00:05:20.826 --> 00:05:22.876
through massive improvement to

00:05:22.876 --> 00:05:24.676
the core tooling experience from

00:05:24.676 --> 00:05:26.106
the Debugger through the Editor.

00:05:26.186 --> 00:05:28.306
And the community has also

00:05:28.306 --> 00:05:30.216
focused on language improvements

00:05:30.616 --> 00:05:32.206
that aim to improve common

00:05:32.206 --> 00:05:33.796
developer workflows, remove

00:05:33.796 --> 00:05:34.386
boilerplate.

00:05:34.926 --> 00:05:36.936
And Apple has continued invested

00:05:36.936 --> 00:05:39.406
improvements to the SDK so that

00:05:39.406 --> 00:05:41.646
the Objective-C APIs better

00:05:41.686 --> 00:05:44.226
reflect into Swift making better

00:05:44.386 --> 00:05:45.456
use of the language and

00:05:45.456 --> 00:05:47.006
improving your use of our APIs.

00:05:48.266 --> 00:05:49.626
And the other side there's been

00:05:49.626 --> 00:05:51.766
a massive effort on under the

00:05:51.846 --> 00:05:53.736
hood improvements and changes to

00:05:53.736 --> 00:05:55.636
the runtime towards this binary

00:05:55.636 --> 00:05:58.156
compatibility goal, which

00:05:58.156 --> 00:06:01.946
culminates in Swift 5, which

00:06:01.946 --> 00:06:04.916
will be released in early 2019.

00:06:05.926 --> 00:06:07.486
So what is binary compatibility?

00:06:08.406 --> 00:06:09.806
Binary compatibility means that

00:06:09.806 --> 00:06:11.536
you can build your Swift code

00:06:11.576 --> 00:06:12.996
with the Swift 5 compiler and

00:06:12.996 --> 00:06:13.286
layer.

00:06:13.286 --> 00:06:15.036
And at the binary level it will

00:06:15.036 --> 00:06:16.626
be able to interoperate with

00:06:16.696 --> 00:06:17.866
other code built with that

00:06:17.866 --> 00:06:19.686
compiler or any other compiler

00:06:19.686 --> 00:06:20.016
layer.

00:06:20.496 --> 00:06:22.266
This is a very important

00:06:22.266 --> 00:06:23.966
milestone for the maturity of

00:06:23.966 --> 00:06:24.506
the language.

00:06:25.146 --> 00:06:26.606
And what this will enable is

00:06:26.606 --> 00:06:28.436
Apple to shift the Swift runtime

00:06:28.586 --> 00:06:30.746
in the operating system, which

00:06:30.746 --> 00:06:32.156
means apps can directly use it,

00:06:32.576 --> 00:06:33.496
meaning that they no longer need

00:06:33.496 --> 00:06:34.666
it included in the application

00:06:34.666 --> 00:06:34.976
bundle.

00:06:35.346 --> 00:06:37.446
So this is a code size win but

00:06:37.446 --> 00:06:38.966
it's also important that it

00:06:38.966 --> 00:06:40.146
impacts things like startup

00:06:40.146 --> 00:06:42.286
time, memory usage, it's an

00:06:42.286 --> 00:06:43.646
overall huge win for the

00:06:43.646 --> 00:06:44.056
community.

00:06:44.056 --> 00:06:46.876
If you're -- we've been very

00:06:46.876 --> 00:06:48.046
transparent on the progress

00:06:48.286 --> 00:06:50.196
towards ABI stability or binary

00:06:50.196 --> 00:06:50.906
compatibility.

00:06:51.286 --> 00:06:52.826
You can follow along on the ABI

00:06:52.826 --> 00:06:54.366
stability dashboard on

00:06:54.406 --> 00:06:55.806
Swift.org.

00:06:57.696 --> 00:07:00.186
Today's focus is on Swift 4.2,

00:07:00.186 --> 00:07:01.596
which is an important waypoint

00:07:01.916 --> 00:07:02.696
toward Swift 5.

00:07:03.426 --> 00:07:05.446
Let's talk about source

00:07:05.446 --> 00:07:06.166
compatibility.

00:07:07.526 --> 00:07:10.106
So just like in Xcode 9, Xcode

00:07:10.166 --> 00:07:12.026
10 shifts with one Swift

00:07:12.226 --> 00:07:12.696
compiler.

00:07:13.686 --> 00:07:15.086
So if you're using Xcode 10, you

00:07:15.086 --> 00:07:16.256
are using Swift 4.2.

00:07:17.226 --> 00:07:19.716
However, just like in Xcode 9,

00:07:20.276 --> 00:07:21.746
the compiler also supports

00:07:22.236 --> 00:07:23.896
multiple language compatibility

00:07:23.896 --> 00:07:24.366
modes.

00:07:25.256 --> 00:07:27.026
Now in all the modes you can use

00:07:27.116 --> 00:07:27.906
all the new APIs.

00:07:28.676 --> 00:07:29.926
You can use all the new language

00:07:29.926 --> 00:07:30.476
features.

00:07:30.856 --> 00:07:31.676
What these gate are

00:07:31.676 --> 00:07:33.476
source-impacting changes.

00:07:34.036 --> 00:07:37.286
The first two are ones that

00:07:37.286 --> 00:07:39.026
existed previously in Xcode 9.

00:07:39.426 --> 00:07:40.676
They're there to provide an out

00:07:40.676 --> 00:07:41.776
of the box experience that you

00:07:41.776 --> 00:07:43.046
can build your Swift 3 and Swift

00:07:43.046 --> 00:07:44.926
4 code without modifications.

00:07:45.656 --> 00:07:47.206
The Swift 4.2 mode is almost

00:07:47.206 --> 00:07:49.586
identical to the 4 mode except

00:07:49.586 --> 00:07:51.216
it gates those SDK improvements

00:07:51.476 --> 00:07:52.266
that are talked about.

00:07:53.426 --> 00:07:54.346
That's it.

00:07:54.976 --> 00:07:57.026
Just some previous versions of

00:07:57.086 --> 00:07:58.526
Xcode, there's Migrator Support

00:07:58.526 --> 00:07:59.436
that you can find in the edit

00:07:59.436 --> 00:08:01.116
menu to mechanize most of your

00:08:01.116 --> 00:08:01.556
changes.

00:08:02.806 --> 00:08:03.876
I want to give an important

00:08:03.876 --> 00:08:06.166
disclaimer about the Swift 4.2

00:08:06.306 --> 00:08:07.146
SDK changes.

00:08:07.496 --> 00:08:09.436
Later Xcode 10 betas will likely

00:08:09.436 --> 00:08:11.036
have further SDK improvements.

00:08:11.416 --> 00:08:13.206
This is to provide opportunities

00:08:13.206 --> 00:08:14.916
to incorporate you feedback from

00:08:14.916 --> 00:08:16.976
the betas of how these APIs

00:08:16.976 --> 00:08:18.676
should be improved and how they

00:08:18.676 --> 00:08:19.626
reflect into Swift.

00:08:20.236 --> 00:08:22.246
This means if you migrate to 4.2

00:08:22.416 --> 00:08:23.926
early, you should expect there

00:08:23.926 --> 00:08:24.806
are going to be some changes

00:08:24.806 --> 00:08:25.096
later.

00:08:25.576 --> 00:08:27.166
Or you can hold off and migrate

00:08:27.196 --> 00:08:27.446
later.

00:08:27.836 --> 00:08:28.816
It's completely up to you.

00:08:30.616 --> 00:08:32.176
Now with Swift 4.2 we think we

00:08:32.176 --> 00:08:34.126
are rapidly converging on what

00:08:34.166 --> 00:08:35.476
Swift code is going to look like

00:08:35.876 --> 00:08:36.635
going forward.

00:08:36.666 --> 00:08:39.155
This is an important phase in

00:08:39.155 --> 00:08:40.716
the maturation of the language.

00:08:41.506 --> 00:08:43.046
And thus we really think it's

00:08:43.046 --> 00:08:44.596
important for everyone to move

00:08:44.596 --> 00:08:47.486
off of Swift 3 and embrace using

00:08:47.486 --> 00:08:48.086
Swift 4.2.

00:08:48.086 --> 00:08:49.216
There are important code size

00:08:49.216 --> 00:08:50.456
improvements there and just

00:08:50.456 --> 00:08:51.396
overall improvements to the

00:08:51.396 --> 00:08:52.006
language.

00:08:52.836 --> 00:08:54.106
And this is Xcode 10 is going to

00:08:54.156 --> 00:08:55.636
be the last release to support

00:08:55.636 --> 00:08:58.916
that Swift 3 compatibility mode.

00:08:59.586 --> 00:09:00.506
So let's talk about some

00:09:00.506 --> 00:09:01.446
improvements to the tooling.

00:09:02.536 --> 00:09:04.076
In the State of the Union we

00:09:04.076 --> 00:09:05.006
mentioned that there are some

00:09:05.106 --> 00:09:06.206
significant improvements to

00:09:06.206 --> 00:09:07.416
build improvement for Swift

00:09:07.416 --> 00:09:09.366
projects over Xcode 9.

00:09:10.176 --> 00:09:12.176
And so these numbers are run on

00:09:12.176 --> 00:09:13.516
a 4-Core MacBook Pro i7.

00:09:13.516 --> 00:09:16.946
Let's look a little bit closer

00:09:16.946 --> 00:09:17.416
at one of them.

00:09:18.896 --> 00:09:20.456
This project is a mix and match

00:09:20.456 --> 00:09:21.776
of Objective-C in Swift.

00:09:22.066 --> 00:09:23.406
It started out as an Objective-C

00:09:23.406 --> 00:09:24.666
project and started

00:09:24.666 --> 00:09:25.526
incorporating Swift.

00:09:26.216 --> 00:09:27.786
This is a very common scenario.

00:09:28.756 --> 00:09:29.576
Now what this Build time

00:09:29.576 --> 00:09:32.156
improvement doesn't really

00:09:32.156 --> 00:09:33.826
underscore is how much faster

00:09:33.876 --> 00:09:34.736
building this Swift Code

00:09:34.736 --> 00:09:35.536
actually became.

00:09:36.356 --> 00:09:37.526
So if we just focus on how much

00:09:37.526 --> 00:09:39.826
faster the Swift code built, it

00:09:39.826 --> 00:09:41.146
actually builds three times

00:09:41.226 --> 00:09:42.896
faster than it did before.

00:09:43.386 --> 00:09:44.776
And so that's why the project

00:09:45.046 --> 00:09:47.086
has that more modest 1.6x

00:09:47.186 --> 00:09:47.536
speedup.

00:09:49.656 --> 00:09:51.096
And what you will see is that

00:09:51.096 --> 00:09:52.216
the overall build improvements

00:09:52.216 --> 00:09:53.706
will depend on the nature of

00:09:53.706 --> 00:09:54.766
your project, how much Swift

00:09:54.766 --> 00:09:56.816
code it's using, the number of

00:09:56.816 --> 00:09:58.606
cores on your machine, but we've

00:09:58.766 --> 00:10:00.146
in practice have seen from many

00:10:00.146 --> 00:10:01.476
projects it's a 2x speedup.

00:10:02.416 --> 00:10:04.366
And the win comes from observing

00:10:04.366 --> 00:10:06.326
that because within a Swift

00:10:06.326 --> 00:10:08.286
target you have cross-file

00:10:08.286 --> 00:10:09.846
visibility, right, that's one of

00:10:09.846 --> 00:10:10.896
the great features of Swift

00:10:10.896 --> 00:10:11.626
where you don't need header

00:10:11.696 --> 00:10:11.946
files.

00:10:12.606 --> 00:10:13.976
There was a lot of redundant

00:10:13.976 --> 00:10:15.586
work being done by the compiler.

00:10:15.586 --> 00:10:17.056
And what we've done is we've

00:10:17.056 --> 00:10:18.346
retooled the compilation

00:10:18.346 --> 00:10:20.136
pipeline to reduce a lot of this

00:10:20.136 --> 00:10:21.626
redundant work and make better

00:10:21.626 --> 00:10:22.516
use of the cores on your

00:10:22.516 --> 00:10:22.936
machine.

00:10:23.096 --> 00:10:23.996
And that's where these speedups

00:10:24.076 --> 00:10:24.466
come from.

00:10:25.206 --> 00:10:26.116
If you're interested in more

00:10:26.116 --> 00:10:27.616
details there's these two great

00:10:27.616 --> 00:10:28.886
talks later this week that dive

00:10:28.886 --> 00:10:30.346
into how the build process works

00:10:30.396 --> 00:10:31.846
under the book including more

00:10:31.846 --> 00:10:32.906
details about where this

00:10:32.946 --> 00:10:34.146
performance win comes from.

00:10:36.356 --> 00:10:37.906
Now this big win comes from

00:10:38.606 --> 00:10:40.526
debug builds.

00:10:41.566 --> 00:10:44.776
I want to focus on how this is

00:10:44.776 --> 00:10:47.336
surfacing in the Xcode build

00:10:47.396 --> 00:10:47.846
settings.

00:10:48.746 --> 00:10:49.926
Recently we separated out

00:10:49.926 --> 00:10:51.386
compilation mode from

00:10:51.386 --> 00:10:52.506
optimization level.

00:10:53.206 --> 00:10:55.286
Compilation mode is how your

00:10:55.286 --> 00:10:56.726
project builds.

00:10:57.256 --> 00:10:58.566
So for release builds the

00:10:58.566 --> 00:10:59.566
default is whole module

00:10:59.566 --> 00:11:01.446
compilation that means all the

00:11:01.446 --> 00:11:02.906
files within your target are

00:11:02.906 --> 00:11:04.226
always built together.

00:11:04.386 --> 00:11:05.836
This is to enable maximum

00:11:05.836 --> 00:11:07.326
opportunities for optimization.

00:11:07.326 --> 00:11:08.676
It's not the amount of

00:11:08.676 --> 00:11:09.756
optimization done but the

00:11:09.756 --> 00:11:11.366
opportunities for optimization.

00:11:12.166 --> 00:11:14.146
And for Debug builds the default

00:11:14.146 --> 00:11:15.176
is incremental.

00:11:15.386 --> 00:11:16.486
That means not all the files are

00:11:16.486 --> 00:11:18.256
all built, re-built always all

00:11:18.256 --> 00:11:18.626
together.

00:11:19.616 --> 00:11:20.506
So this is a tradeoff in

00:11:20.506 --> 00:11:22.536
performance for build times.

00:11:23.516 --> 00:11:24.826
Optimization level for Debug

00:11:24.826 --> 00:11:25.746
builds continues to be no

00:11:25.746 --> 00:11:26.966
optimization by default.

00:11:26.966 --> 00:11:27.946
This is for faster builds and

00:11:27.946 --> 00:11:29.806
better Debug information and the

00:11:29.806 --> 00:11:31.816
release builds are optimized for

00:11:31.816 --> 00:11:32.096
speed.

00:11:32.636 --> 00:11:33.186
We'll get back to the

00:11:33.186 --> 00:11:35.076
optimization level in a few

00:11:35.076 --> 00:11:35.306
minutes.

00:11:38.436 --> 00:11:41.886
All right so this separation of

00:11:41.886 --> 00:11:42.696
compilation mode and

00:11:42.696 --> 00:11:45.296
optimization level nicely

00:11:45.356 --> 00:11:46.516
highlights and interesting

00:11:46.516 --> 00:11:48.096
stopgap measure that various

00:11:48.096 --> 00:11:50.176
folds discovered that when they

00:11:50.176 --> 00:11:51.126
combined whole module

00:11:51.126 --> 00:11:53.946
compilation with no optimization

00:11:53.946 --> 00:11:54.876
that they sometimes would get

00:11:55.036 --> 00:11:56.026
faster Debug builds.

00:11:56.966 --> 00:11:58.786
And this is because that

00:11:58.786 --> 00:12:00.756
combination reduces a lot of

00:12:00.756 --> 00:12:02.246
that redundant work that I

00:12:02.246 --> 00:12:04.136
talked about before that we have

00:12:04.136 --> 00:12:05.986
no made great efforts to

00:12:06.126 --> 00:12:08.336
eliminate or significantly

00:12:08.336 --> 00:12:08.666
reduce.

00:12:10.036 --> 00:12:10.926
The problem with this

00:12:10.926 --> 00:12:12.496
combination is, is it impedes

00:12:12.496 --> 00:12:13.296
incremental builds.

00:12:13.506 --> 00:12:14.716
So anytime you touch a file

00:12:14.716 --> 00:12:16.206
within a target the whole target

00:12:16.206 --> 00:12:16.806
gets rebuilt.

00:12:17.496 --> 00:12:18.836
Now with the improvements in

00:12:18.836 --> 00:12:20.406
Xcode 10 to Debug builds, we

00:12:20.406 --> 00:12:21.936
feel you no longer need to use

00:12:21.986 --> 00:12:24.416
the stopgap measure and we have

00:12:24.416 --> 00:12:25.626
observed that the default

00:12:25.626 --> 00:12:27.316
incremental builds are at least

00:12:27.316 --> 00:12:29.036
as good as this combination or

00:12:29.036 --> 00:12:29.356
better.

00:12:29.356 --> 00:12:30.406
Especially since they support

00:12:30.406 --> 00:12:30.976
incremental builds.

00:12:34.696 --> 00:12:35.826
Let's talk about some important

00:12:35.826 --> 00:12:37.006
under the hood runtime

00:12:37.006 --> 00:12:38.256
optimizations and this is all

00:12:38.256 --> 00:12:39.356
part of that march towards

00:12:39.406 --> 00:12:40.586
binary compatibility.

00:12:43.436 --> 00:12:45.126
Swift uses automatic memory

00:12:45.126 --> 00:12:47.726
management and it uses reference

00:12:47.726 --> 00:12:49.236
counting just like Objective-C

00:12:49.386 --> 00:12:51.026
for managing object instances.

00:12:51.916 --> 00:12:53.526
On this slide I've illustrated

00:12:53.526 --> 00:12:54.786
in comments where the compiler

00:12:54.786 --> 00:12:56.426
inserts, retains, and releases.

00:12:57.516 --> 00:12:58.786
This is how it behaved in Swift

00:12:58.786 --> 00:13:02.116
4.1.

00:13:02.316 --> 00:13:03.276
When an object is created

00:13:03.276 --> 00:13:04.716
there's a +1 reference account

00:13:04.716 --> 00:13:05.896
associated with it.

00:13:05.896 --> 00:13:08.176
What the convention was if the

00:13:08.176 --> 00:13:09.596
object is passed off as an

00:13:09.596 --> 00:13:10.806
argument to another function,

00:13:11.286 --> 00:13:12.406
it's the obligation of that

00:13:12.466 --> 00:13:14.046
function call to release the

00:13:14.046 --> 00:13:14.526
object.

00:13:14.986 --> 00:13:16.626
So it's basically you're passing

00:13:16.626 --> 00:13:18.036
off the responsibility to the

00:13:18.036 --> 00:13:19.406
call to release it.

00:13:20.376 --> 00:13:21.556
This provided some performance

00:13:21.556 --> 00:13:22.926
opportunities to shrink the

00:13:22.926 --> 00:13:25.156
lifetime of some objects to like

00:13:25.156 --> 00:13:26.936
their smallest range of use.

00:13:27.806 --> 00:13:29.976
However, code often looks more

00:13:30.056 --> 00:13:32.076
like this where you're passing

00:13:32.076 --> 00:13:33.886
the object off several times to

00:13:34.276 --> 00:13:35.236
different APIs.

00:13:35.906 --> 00:13:37.096
And because you have this

00:13:37.136 --> 00:13:38.856
calling convention, you still

00:13:38.856 --> 00:13:40.226
have this dance where the

00:13:40.226 --> 00:13:41.316
initial reference count is

00:13:41.366 --> 00:13:42.466
balanced out with the final

00:13:42.516 --> 00:13:43.066
call.

00:13:43.466 --> 00:13:44.666
But the intermediate calls are

00:13:44.666 --> 00:13:45.776
expected to have these extra

00:13:45.776 --> 00:13:48.246
retains and releases because

00:13:48.246 --> 00:13:49.956
that's what a convention is.

00:13:50.876 --> 00:13:52.406
This is really wasteful because

00:13:52.626 --> 00:13:53.886
the object is really just going

00:13:53.886 --> 00:13:55.156
to be alive during the entire

00:13:55.156 --> 00:13:57.106
duration of this function.

00:13:57.816 --> 00:13:59.876
So in Swift 4.2 we changed the

00:13:59.876 --> 00:14:01.396
calling convention so that it

00:14:01.396 --> 00:14:02.606
was no longer the callee's

00:14:02.606 --> 00:14:04.296
obligation to release the

00:14:04.296 --> 00:14:04.806
object.

00:14:05.206 --> 00:14:06.526
This means all these retains and

00:14:06.526 --> 00:14:10.366
releases go away, which is a

00:14:10.606 --> 00:14:12.066
significant reduction in

00:14:12.066 --> 00:14:13.016
retained release traffic.

00:14:13.936 --> 00:14:15.076
This has two implications.

00:14:15.546 --> 00:14:16.916
It's both a code size win

00:14:16.986 --> 00:14:19.026
because those calls are gone and

00:14:19.026 --> 00:14:20.336
it has a runtime improvement.

00:14:21.776 --> 00:14:24.746
Another important optimization

00:14:24.746 --> 00:14:25.746
we did was to string.

00:14:26.186 --> 00:14:28.506
And Swift 4.2 string is now 16

00:14:28.506 --> 00:14:29.746
bytes big where it as previously

00:14:29.746 --> 00:14:30.316
24.

00:14:30.756 --> 00:14:31.976
We feel this is a good tradeoff

00:14:31.976 --> 00:14:33.266
between memory usage and

00:14:33.266 --> 00:14:33.936
performance.

00:14:35.346 --> 00:14:37.356
It's also, however, still large

00:14:37.356 --> 00:14:38.936
enough to do an important small

00:14:38.936 --> 00:14:40.026
string optimization.

00:14:40.706 --> 00:14:42.746
If the string fits within 15

00:14:42.746 --> 00:14:45.226
bytes then the actual string is

00:14:45.226 --> 00:14:46.636
represented directly in the

00:14:46.636 --> 00:14:48.246
string type without going to the

00:14:48.246 --> 00:14:49.306
heap to allocate a separate

00:14:49.306 --> 00:14:50.806
buffer to represent the string.

00:14:51.436 --> 00:14:53.456
This is obviously also a memory

00:14:53.456 --> 00:14:55.066
win and a performance win.

00:14:55.716 --> 00:14:56.546
This is as similar to an

00:14:56.546 --> 00:14:57.866
optimization that exists within

00:14:57.866 --> 00:14:58.286
a string.

00:14:58.586 --> 00:14:59.986
We can actually represent larger

00:14:59.986 --> 00:15:00.516
strings.

00:15:03.396 --> 00:15:05.096
Finally before I hand it off to

00:15:05.156 --> 00:15:06.126
Slava we'll talk about the

00:15:06.126 --> 00:15:07.086
language improvements.

00:15:07.086 --> 00:15:08.576
I want to talk a little bit more

00:15:08.576 --> 00:15:10.216
about the efforts to reduce code

00:15:10.216 --> 00:15:10.636
size.

00:15:12.176 --> 00:15:13.146
I talked a little bit about that

00:15:13.146 --> 00:15:14.586
calling convention change, which

00:15:14.586 --> 00:15:15.826
reduces code size.

00:15:15.826 --> 00:15:17.546
But we've also introduced a new

00:15:17.546 --> 00:15:19.936
optimization level, Optimize for

00:15:19.936 --> 00:15:20.256
Size.

00:15:21.466 --> 00:15:22.366
This can be useful for

00:15:22.366 --> 00:15:23.986
applications that care very much

00:15:24.056 --> 00:15:25.966
about app size limits such as

00:15:25.966 --> 00:15:27.216
from cellular over the air

00:15:27.216 --> 00:15:28.056
download limits.

00:15:29.146 --> 00:15:30.626
Swift is a very powerful

00:15:30.696 --> 00:15:33.656
language with static knowledge

00:15:33.656 --> 00:15:34.846
about what your program does.

00:15:35.306 --> 00:15:36.306
And so compiler has many

00:15:36.306 --> 00:15:38.626
opportunities to do performance

00:15:38.626 --> 00:15:40.016
optimizations such as function

00:15:40.016 --> 00:15:41.596
call inlining, speculative

00:15:41.596 --> 00:15:43.126
devirtualization, which trade

00:15:43.126 --> 00:15:44.326
off a little bit of code size

00:15:44.326 --> 00:15:45.846
for more performance, but

00:15:45.846 --> 00:15:46.936
sometimes that more performance

00:15:47.226 --> 00:15:49.346
isn't really needed in practice.

00:15:49.956 --> 00:15:51.726
This is the result of applying

00:15:51.786 --> 00:15:52.846
Osize to the Swift Source

00:15:52.846 --> 00:15:54.466
Compatibility Suite, which

00:15:54.466 --> 00:15:55.546
contains an assortment of

00:15:55.546 --> 00:15:57.446
projects from GitHub, frameworks

00:15:57.446 --> 00:15:58.266
and applications.

00:15:59.156 --> 00:16:00.176
And what you'll see is a wide

00:16:00.176 --> 00:16:01.626
range depending on what language

00:16:01.626 --> 00:16:03.456
features are used about 10% to

00:16:03.456 --> 00:16:05.136
30% reduction in code size.

00:16:05.826 --> 00:16:07.206
Now this, when I talk about code

00:16:07.206 --> 00:16:07.896
size I'm talking about the

00:16:07.896 --> 00:16:09.636
machine code that is generated

00:16:09.636 --> 00:16:11.046
as a result of compiling your

00:16:11.046 --> 00:16:12.316
Swift code, not the overall app

00:16:12.386 --> 00:16:12.676
size.

00:16:12.906 --> 00:16:14.206
The overall app size depends on

00:16:14.206 --> 00:16:15.466
assets and all sorts of other

00:16:15.466 --> 00:16:15.766
stuff.

00:16:17.576 --> 00:16:19.416
In practice we observe that

00:16:19.416 --> 00:16:20.626
runtime performance is usually

00:16:20.626 --> 00:16:21.836
about 5% slower.

00:16:21.836 --> 00:16:23.056
So you're trading off for a

00:16:23.056 --> 00:16:23.776
little bit of performance.

00:16:24.336 --> 00:16:25.766
For many applications this is

00:16:25.766 --> 00:16:26.496
totally fine.

00:16:26.926 --> 00:16:28.406
So it really depends on your use

00:16:28.466 --> 00:16:28.716
case.

00:16:29.216 --> 00:16:30.096
But if this is something you're

00:16:30.096 --> 00:16:31.516
interested in we encourage you

00:16:31.516 --> 00:16:33.956
to give it a try.

00:16:34.456 --> 00:16:35.476
With that I'd like to hand it

00:16:35.476 --> 00:16:36.916
off to Slava who will talk about

00:16:36.916 --> 00:16:37.806
all the great language and

00:16:37.806 --> 00:16:39.826
improvements with Swift 4.2

00:16:40.516 --> 00:16:45.546
[ Applause ]

00:16:46.046 --> 00:16:47.356
>> Hey everybody, I'm Slava

00:16:47.356 --> 00:16:47.856
Pestov.

00:16:47.896 --> 00:16:49.586
I work on the Swift Compiler and

00:16:49.586 --> 00:16:50.886
today I'm going to talk about

00:16:50.886 --> 00:16:52.366
how the new language features in

00:16:52.366 --> 00:16:54.216
Swift 4.2 allow you to write

00:16:54.216 --> 00:16:55.666
simpler and more maintainable

00:16:55.666 --> 00:16:55.956
code.

00:16:57.556 --> 00:16:59.156
So before we start talking about

00:16:59.196 --> 00:17:00.766
the new language changes, let's

00:17:00.766 --> 00:17:02.576
review the process for making

00:17:02.576 --> 00:17:03.886
improvements to the language.

00:17:04.516 --> 00:17:06.506
So as Ted mentioned, Swift is an

00:17:06.506 --> 00:17:08.506
open source project, but it also

00:17:08.506 --> 00:17:09.556
has an open design.

00:17:10.165 --> 00:17:11.435
This means that if you have an

00:17:11.435 --> 00:17:13.066
idea for improving the language,

00:17:13.386 --> 00:17:14.636
you can go and pitch it on the

00:17:14.715 --> 00:17:16.826
forums and if the idea gains

00:17:16.826 --> 00:17:18.536
enough traction and crystalizes

00:17:18.606 --> 00:17:20.465
into draft proposal, you can

00:17:20.465 --> 00:17:21.606
submit it together with

00:17:21.606 --> 00:17:23.435
implementation to the core team

00:17:23.506 --> 00:17:24.286
for review.

00:17:24.626 --> 00:17:26.165
At this point a formal review

00:17:26.165 --> 00:17:27.596
period allows members of the

00:17:27.626 --> 00:17:28.946
community to give additional

00:17:29.016 --> 00:17:30.726
feedback and then the core team

00:17:30.726 --> 00:17:32.486
makes a decision as to whether

00:17:32.486 --> 00:17:33.606
to accept the proposal.

00:17:34.796 --> 00:17:36.196
If you go to the Swift Evolution

00:17:36.196 --> 00:17:38.346
website, you can see a list of

00:17:38.346 --> 00:17:39.596
all the proposals that were

00:17:39.596 --> 00:17:41.286
accepted and implemented in

00:17:41.286 --> 00:17:42.406
Swift 4.2.

00:17:43.396 --> 00:17:44.976
And if you look at this list of

00:17:44.976 --> 00:17:46.646
proposals there's a lot here.

00:17:46.646 --> 00:17:47.946
There's more than I can cover

00:17:47.946 --> 00:17:48.316
today.

00:17:48.776 --> 00:17:50.046
But one thing I really wanted to

00:17:50.046 --> 00:17:51.776
emphasize was the large number

00:17:51.776 --> 00:17:53.086
of proposals that were both

00:17:53.086 --> 00:17:55.476
designed and implemented by the

00:17:55.476 --> 00:17:56.136
community.

00:17:56.566 --> 00:17:58.066
What this means is that these

00:17:58.066 --> 00:17:59.626
proposals address common

00:17:59.666 --> 00:18:01.406
pinpoints in the language that

00:18:01.406 --> 00:18:03.276
came up in the real world and

00:18:03.276 --> 00:18:05.756
you came up with the idea for

00:18:05.756 --> 00:18:07.636
fixing these pinpoints and you

00:18:07.636 --> 00:18:09.246
contributed these improvements

00:18:09.286 --> 00:18:11.126
back to Swift so that everybody

00:18:11.126 --> 00:18:11.766
benefits.

00:18:12.166 --> 00:18:12.516
Thank you.

00:18:14.516 --> 00:18:19.016
[ Applause ]

00:18:19.516 --> 00:18:20.936
So for the first improvement

00:18:21.126 --> 00:18:22.226
we're going to see how to

00:18:22.226 --> 00:18:23.636
eliminate a common source of

00:18:23.636 --> 00:18:25.226
boilerplate when working with

00:18:25.226 --> 00:18:25.486
enum's.

00:18:26.566 --> 00:18:27.896
So let's say I have to find an

00:18:27.896 --> 00:18:28.196
enum.

00:18:28.616 --> 00:18:30.486
And I want to print every

00:18:30.486 --> 00:18:32.096
possible value that this data

00:18:32.096 --> 00:18:32.846
type can have.

00:18:33.376 --> 00:18:36.286
So in Swift 4, I had to define a

00:18:36.286 --> 00:18:38.636
property perhaps with a list of

00:18:39.026 --> 00:18:40.386
all the possible cases.

00:18:41.056 --> 00:18:44.656
And if I add a new case then I

00:18:44.656 --> 00:18:46.016
have to remember to update that

00:18:46.086 --> 00:18:48.376
property, otherwise I just get

00:18:48.376 --> 00:18:49.706
incorrect behavior or runtime.

00:18:50.976 --> 00:18:53.536
And this is just not very good

00:18:53.536 --> 00:18:54.936
because you're repeating

00:18:54.936 --> 00:18:56.406
yourself to the compiler.

00:18:56.986 --> 00:18:59.296
So in Swift 4.2 we've added a

00:18:59.296 --> 00:19:01.966
new CaseIterable protocol and if

00:19:01.966 --> 00:19:03.346
you state a conformance to this

00:19:03.406 --> 00:19:04.726
protocol, the compiler will

00:19:04.726 --> 00:19:06.676
synthesize an all cases property

00:19:06.676 --> 00:19:07.096
for you.

00:19:07.096 --> 00:19:08.976
OK, that was short and sweet.

00:19:09.516 --> 00:19:12.546
[ Applause ]

00:19:13.046 --> 00:19:15.216
For the next improvement we're

00:19:15.216 --> 00:19:16.476
going to see how to eliminate

00:19:16.476 --> 00:19:17.806
another source of boilerplate.

00:19:18.016 --> 00:19:19.216
This time it's when you're

00:19:19.306 --> 00:19:20.436
unable to make your code

00:19:20.626 --> 00:19:21.786
sufficiently generic.

00:19:22.726 --> 00:19:24.916
So in Swift 4 we have this

00:19:24.956 --> 00:19:26.596
contains method on sequence.

00:19:27.006 --> 00:19:28.506
And this requires that the

00:19:28.506 --> 00:19:30.106
element type of the sequence is

00:19:30.106 --> 00:19:32.186
Equatable so that it can find

00:19:32.186 --> 00:19:33.376
the element that it's looking

00:19:33.446 --> 00:19:33.666
for.

00:19:34.636 --> 00:19:36.736
And of course I could call this

00:19:36.736 --> 00:19:37.966
within an array of strings

00:19:38.236 --> 00:19:39.616
because string is Equatable.

00:19:39.616 --> 00:19:41.516
But what if I call it within an

00:19:41.516 --> 00:19:42.346
array of arrays.

00:19:43.226 --> 00:19:45.736
Well array of Int, the element

00:19:45.736 --> 00:19:47.756
type here is not equitable,

00:19:48.126 --> 00:19:49.486
which meant that I would just

00:19:49.486 --> 00:19:50.596
get a compile time error.

00:19:51.796 --> 00:19:53.796
And you might ask, well why

00:19:53.796 --> 00:19:55.106
doesn't the standard library

00:19:55.196 --> 00:19:56.796
make all arrays Equatable.

00:19:57.136 --> 00:19:58.316
But that doesn't make sense

00:19:58.316 --> 00:20:00.666
either because if the element

00:20:00.666 --> 00:20:01.836
type of the array is not

00:20:01.836 --> 00:20:03.366
Equatable, like a function

00:20:03.396 --> 00:20:05.056
perhaps, then you can't really

00:20:05.056 --> 00:20:06.566
make the array Equatable either.

00:20:07.956 --> 00:20:09.286
But certainly if the element

00:20:09.326 --> 00:20:10.846
type of the array is Equatable

00:20:10.846 --> 00:20:12.726
then I can define an equality

00:20:12.726 --> 00:20:14.516
operation on arrays that just

00:20:14.516 --> 00:20:16.376
compares the elements pair wise.

00:20:17.116 --> 00:20:18.516
And this is what conditional

00:20:18.516 --> 00:20:20.116
conformance allows a standard

00:20:20.116 --> 00:20:21.286
library to do.

00:20:21.376 --> 00:20:23.076
So now array gets an

00:20:23.076 --> 00:20:24.916
implementation of Equatable for

00:20:24.916 --> 00:20:26.246
the case where the element type

00:20:26.246 --> 00:20:27.056
is equitable.

00:20:27.416 --> 00:20:29.776
And in Swift 4.2 this example we

00:20:29.776 --> 00:20:31.366
saw earlier now works.

00:20:31.856 --> 00:20:34.776
And in addition to arrays being

00:20:34.776 --> 00:20:36.146
Equatable the standard library

00:20:36.146 --> 00:20:37.636
defines a number of other

00:20:37.636 --> 00:20:38.896
conditional conformance.

00:20:39.436 --> 00:20:41.026
For example, optional and

00:20:41.026 --> 00:20:42.726
dictionaries are now Equatable

00:20:42.726 --> 00:20:44.126
when their element type is

00:20:44.126 --> 00:20:46.486
Equatable and the same works for

00:20:46.536 --> 00:20:49.576
Hashable, Encodable, and

00:20:49.576 --> 00:20:51.306
Decodable conformances.

00:20:52.516 --> 00:20:57.576
[ Applause ]

00:20:58.076 --> 00:20:59.746
And this allows you to compose

00:20:59.746 --> 00:21:01.156
collections in ways that were

00:21:01.156 --> 00:21:02.256
not possible before.

00:21:02.986 --> 00:21:05.886
So here I have a set of arrays

00:21:05.886 --> 00:21:08.166
of optional integers and

00:21:09.176 --> 00:21:10.366
everything just works.

00:21:10.916 --> 00:21:13.416
If you want to learn more

00:21:13.416 --> 00:21:14.656
there's a session later this

00:21:14.656 --> 00:21:17.026
week where you can learn about

00:21:17.026 --> 00:21:18.476
conditional conformance and some

00:21:18.476 --> 00:21:19.946
other generics improvements in

00:21:19.946 --> 00:21:21.256
Swift 4.2 that I won't be

00:21:21.256 --> 00:21:22.536
covering today.

00:21:23.896 --> 00:21:25.756
So what about defining your own

00:21:25.756 --> 00:21:26.776
Equatable and Hashable

00:21:26.776 --> 00:21:27.606
conformances.

00:21:28.596 --> 00:21:30.376
Well, a common pattern in Swift

00:21:30.446 --> 00:21:32.446
is that I have a struct with a

00:21:32.446 --> 00:21:34.516
bunch of stored properties and

00:21:34.516 --> 00:21:36.006
all those stored properties are

00:21:36.006 --> 00:21:37.096
themselves Equatable.

00:21:37.436 --> 00:21:38.546
And then I want to make the

00:21:38.546 --> 00:21:40.656
struct Equatable just by

00:21:40.656 --> 00:21:42.156
comparing those properties of

00:21:42.156 --> 00:21:43.056
the two values.

00:21:43.516 --> 00:21:45.616
In Swift 4 previously you had to

00:21:45.616 --> 00:21:46.726
write this out by hand.

00:21:47.166 --> 00:21:48.486
And this is just boilerplate.

00:21:48.706 --> 00:21:50.276
If I add a new stored property

00:21:50.276 --> 00:21:51.836
to my struct, I have to remember

00:21:51.836 --> 00:21:53.286
to update this implementation of

00:21:53.286 --> 00:21:54.926
Equatable and it's easy to make

00:21:54.926 --> 00:21:56.466
a copy and paste error or some

00:21:56.466 --> 00:21:57.166
other mistake.

00:21:57.796 --> 00:21:59.676
So in Swift 4.1 we introduce

00:21:59.676 --> 00:22:01.536
this ability to synthesize the

00:22:01.536 --> 00:22:02.926
implementation of equality.

00:22:03.386 --> 00:22:04.966
If you emit the implementation

00:22:05.186 --> 00:22:06.326
than the compiler will fill it

00:22:06.326 --> 00:22:08.046
in for you as long as all those

00:22:08.046 --> 00:22:09.556
stored properties are themselves

00:22:09.556 --> 00:22:10.036
Equatable.

00:22:11.076 --> 00:22:12.626
This also works for Hashable.

00:22:13.996 --> 00:22:15.726
Now what about generic types?

00:22:16.266 --> 00:22:17.986
So here I have a data type whose

00:22:17.986 --> 00:22:19.556
values are either instances of

00:22:19.556 --> 00:22:21.706
the left type or instances of

00:22:21.706 --> 00:22:22.316
the right type.

00:22:22.936 --> 00:22:24.586
And I might now want to make

00:22:24.586 --> 00:22:26.216
left and right constrained to

00:22:26.216 --> 00:22:27.776
Equatable because again, I want

00:22:27.776 --> 00:22:28.876
to be able to use this either

00:22:28.876 --> 00:22:31.046
type with functions, errors, and

00:22:31.046 --> 00:22:32.446
other non Equatable types.

00:22:32.916 --> 00:22:34.326
But certainly I can define a

00:22:34.326 --> 00:22:36.226
conditional conformance so that

00:22:36.226 --> 00:22:37.506
if left and right are both

00:22:37.506 --> 00:22:39.146
Equatable then either is

00:22:39.146 --> 00:22:39.726
Equatable.

00:22:40.116 --> 00:22:41.386
But I can do even better than

00:22:41.386 --> 00:22:41.696
this.

00:22:42.166 --> 00:22:43.666
Notice how the implementation of

00:22:43.666 --> 00:22:45.576
equality here there's only

00:22:45.576 --> 00:22:47.206
really one obviously correct way

00:22:47.206 --> 00:22:47.616
to do it.

00:22:47.946 --> 00:22:49.186
You have to check that both

00:22:49.186 --> 00:22:51.416
values have the same case and if

00:22:51.416 --> 00:22:53.286
they do you check their payloads

00:22:53.286 --> 00:22:53.996
for equality.

00:22:54.776 --> 00:22:56.396
So you might guess, well the

00:22:56.396 --> 00:22:57.426
compiler should be able to

00:22:57.426 --> 00:22:58.926
synthesize this for you and it

00:22:58.926 --> 00:23:00.256
can in Swift 4.2.

00:23:01.176 --> 00:23:02.666
And this also works for

00:23:02.666 --> 00:23:03.186
Hashable.

00:23:04.676 --> 00:23:07.166
So now I can have a set of

00:23:07.356 --> 00:23:09.256
either Int's or strings as one

00:23:09.256 --> 00:23:09.786
example.

00:23:11.546 --> 00:23:11.656
OK.

00:23:12.516 --> 00:23:15.676
[ Applause ]

00:23:16.176 --> 00:23:18.146
Now, there are cases where you

00:23:18.146 --> 00:23:19.526
really do have to implement

00:23:19.586 --> 00:23:22.766
equality and Hashing by hand.

00:23:23.436 --> 00:23:25.216
So let's look at one example of

00:23:25.216 --> 00:23:25.456
that.

00:23:26.616 --> 00:23:27.866
Let's say I have a data type

00:23:28.006 --> 00:23:30.796
that represents a city and it's

00:23:30.796 --> 00:23:32.166
got a name, it's got the state

00:23:32.166 --> 00:23:33.456
that it's located in, and it has

00:23:33.456 --> 00:23:34.296
the population.

00:23:34.706 --> 00:23:35.556
And let's say that for the

00:23:35.556 --> 00:23:38.006
purposes of this example I only

00:23:38.006 --> 00:23:39.536
have to compare the name and the

00:23:39.536 --> 00:23:41.456
state for equality and if I know

00:23:41.456 --> 00:23:42.826
those are equal I don't have to

00:23:42.826 --> 00:23:43.926
check the population.

00:23:44.616 --> 00:23:46.446
So if I let the compiler

00:23:46.446 --> 00:23:48.056
synthesize the implementation of

00:23:48.056 --> 00:23:49.706
equality here it's going to do

00:23:49.706 --> 00:23:51.046
unnecessary work because it's

00:23:51.046 --> 00:23:52.006
going to be comparing that

00:23:52.006 --> 00:23:53.046
population field.

00:23:53.776 --> 00:23:55.436
But I certainly write it out by

00:23:55.436 --> 00:23:56.976
hand and maybe in this case it's

00:23:56.976 --> 00:23:57.636
not too bad.

00:23:58.556 --> 00:23:59.796
But what about Hashable?

00:24:01.286 --> 00:24:02.796
So if I want to calculate the

00:24:02.836 --> 00:24:04.566
Hash code of the city object,

00:24:05.066 --> 00:24:06.986
then I'm going to calculate the

00:24:07.016 --> 00:24:08.336
Hash code of the name and the

00:24:08.336 --> 00:24:09.636
Hash code of the state and I

00:24:09.636 --> 00:24:11.086
have to combine them somehow.

00:24:11.646 --> 00:24:12.686
But how do I do that?

00:24:13.296 --> 00:24:15.286
Well, I can use an exclusive or

00:24:15.286 --> 00:24:18.246
operation or I could use some

00:24:18.246 --> 00:24:20.196
random math formula that I found

00:24:20.196 --> 00:24:21.866
on the Internet or just came up

00:24:21.866 --> 00:24:22.656
with myself.

00:24:23.246 --> 00:24:24.976
But neither one of these is very

00:24:24.976 --> 00:24:27.306
satisfying and it feels like

00:24:27.306 --> 00:24:28.896
these Hash combining functions

00:24:29.176 --> 00:24:30.556
have a lot of magic to them.

00:24:30.876 --> 00:24:32.336
And the cost of getting it wrong

00:24:32.336 --> 00:24:34.376
is pretty high because the

00:24:34.376 --> 00:24:35.846
performance properties that you

00:24:35.846 --> 00:24:37.526
expect to get from a dictionary

00:24:37.526 --> 00:24:39.716
or a set really rely on having a

00:24:39.716 --> 00:24:41.416
good high-quality Hash function.

00:24:42.146 --> 00:24:43.956
There's also a security angle

00:24:44.016 --> 00:24:44.266
here.

00:24:44.636 --> 00:24:46.966
So if an attacker is able to

00:24:46.966 --> 00:24:49.336
craft inputs that all Hash to

00:24:49.336 --> 00:24:51.086
the same value and send them to

00:24:51.086 --> 00:24:52.336
your app over the Internet

00:24:52.396 --> 00:24:54.286
somehow, then it might slow your

00:24:54.286 --> 00:24:55.466
app down to the point where it

00:24:55.466 --> 00:24:56.906
becomes unusable creating a

00:24:56.906 --> 00:24:58.056
denial of service attack.

00:24:58.536 --> 00:25:01.066
So in Swift 4.2 we've added a

00:25:01.066 --> 00:25:02.476
better API for this.

00:25:03.316 --> 00:25:05.396
Now recall the Hashable protocol

00:25:05.396 --> 00:25:06.896
in Swift 4 and 4.1.

00:25:07.486 --> 00:25:09.076
It has a single Hash value

00:25:09.076 --> 00:25:10.446
requirement that produces a

00:25:10.446 --> 00:25:11.696
single integer value.

00:25:12.446 --> 00:25:14.676
In Swift 4.2 we've redesigned

00:25:14.676 --> 00:25:16.936
the Hashable protocol so now

00:25:17.296 --> 00:25:19.116
there's a different Hash into

00:25:19.116 --> 00:25:19.746
requirement.

00:25:20.126 --> 00:25:21.346
And instead of producing a

00:25:21.346 --> 00:25:23.466
single Hash code value, Hash

00:25:23.466 --> 00:25:26.146
into takes a Hasher instance and

00:25:26.146 --> 00:25:27.636
then you can feed multiple

00:25:27.636 --> 00:25:29.616
values into the Hasher, which

00:25:29.616 --> 00:25:31.126
will combine them into one Hash

00:25:31.126 --> 00:25:31.376
code.

00:25:32.306 --> 00:25:34.096
So going back to our example of

00:25:34.096 --> 00:25:36.076
the city data type, all we have

00:25:36.076 --> 00:25:38.226
to do is implement Hash into by

00:25:38.226 --> 00:25:40.546
recursively calling Hash into on

00:25:40.546 --> 00:25:42.576
the name and the state passing

00:25:42.576 --> 00:25:44.596
in the Hasher object instance

00:25:44.596 --> 00:25:45.316
that we were given.

00:25:46.486 --> 00:25:49.786
And the Hash combining algorithm

00:25:49.786 --> 00:25:51.726
in the Hasher, it does a good

00:25:51.726 --> 00:25:53.526
job of balancing the quality of

00:25:53.526 --> 00:25:55.146
the Hash code with performance

00:25:55.476 --> 00:25:56.556
and as an added layer of

00:25:56.606 --> 00:25:57.816
protection against denial of

00:25:57.816 --> 00:25:59.686
service attacks, it uses a

00:25:59.686 --> 00:26:01.616
random preprocess seed, which is

00:26:01.616 --> 00:26:03.346
generated when your app starts.

00:26:05.136 --> 00:26:07.236
And we think that it should be

00:26:07.316 --> 00:26:09.136
pretty easy to migrate your code

00:26:09.136 --> 00:26:10.746
to using the new Hashable

00:26:10.746 --> 00:26:12.256
protocol and we encourage you to

00:26:12.256 --> 00:26:12.756
do so.

00:26:13.206 --> 00:26:15.016
The one caveat to watch out for

00:26:15.016 --> 00:26:16.936
is you might have some code

00:26:16.936 --> 00:26:18.746
where you're expecting that Hash

00:26:18.746 --> 00:26:20.426
values remain constant from

00:26:20.426 --> 00:26:22.296
different runs of your app or

00:26:22.296 --> 00:26:23.566
that if you iterate over a

00:26:23.566 --> 00:26:25.416
dictionary or a set you're going

00:26:25.416 --> 00:26:26.636
to get the elements in the same

00:26:26.636 --> 00:26:26.976
order.

00:26:27.256 --> 00:26:28.726
And this is no longer the case

00:26:28.726 --> 00:26:29.656
because of that random

00:26:29.656 --> 00:26:30.676
preprocess seed.

00:26:30.746 --> 00:26:31.816
So you will need to fix your

00:26:31.816 --> 00:26:32.116
code.

00:26:32.916 --> 00:26:35.096
And to make this easier we've

00:26:35.096 --> 00:26:37.336
added a build setting, the Swift

00:26:37.336 --> 00:26:38.426
Deterministic Hashing

00:26:38.426 --> 00:26:39.996
Environment Variable, which you

00:26:39.996 --> 00:26:41.666
can enable in the scheme editor

00:26:42.246 --> 00:26:43.736
to temporarily disable that

00:26:43.786 --> 00:26:45.256
preprocess random seed.

00:26:45.796 --> 00:26:49.466
OK, so let's talk about

00:26:49.606 --> 00:26:51.096
generating random numbers.

00:26:52.396 --> 00:26:53.656
So how do you generate random

00:26:53.656 --> 00:26:54.706
numbers in Swift today?

00:26:55.356 --> 00:26:57.916
Well, you have to use imported C

00:26:57.916 --> 00:26:58.376
APIs.

00:26:58.446 --> 00:26:59.876
And this is really not ideal

00:26:59.876 --> 00:27:01.446
because they are different

00:27:01.446 --> 00:27:03.866
between platforms and they have

00:27:03.866 --> 00:27:04.876
different names, different

00:27:04.876 --> 00:27:06.586
behavior, so you have to use

00:27:06.666 --> 00:27:08.156
build configuration checks.

00:27:08.566 --> 00:27:10.486
But also they're quite low level

00:27:10.486 --> 00:27:12.806
and these common operations that

00:27:12.806 --> 00:27:14.156
are not quite so obvious to

00:27:14.156 --> 00:27:14.566
implement.

00:27:15.316 --> 00:27:16.886
For example, if I want to get a

00:27:16.886 --> 00:27:19.016
random number between 1 and 6,

00:27:19.406 --> 00:27:21.446
then I might think to just call

00:27:21.446 --> 00:27:23.716
this Darwin arc4random function

00:27:23.826 --> 00:27:25.366
and then calculate the remainder

00:27:25.366 --> 00:27:26.556
of dividing by 6.

00:27:26.836 --> 00:27:27.916
But that actually gives you a

00:27:27.916 --> 00:27:29.476
result that is not uniformly

00:27:29.476 --> 00:27:31.566
distributed between 1 and 6.

00:27:32.346 --> 00:27:35.386
So in Swift 4.2 we've added a

00:27:35.386 --> 00:27:37.236
new set of APIs to make this

00:27:37.236 --> 00:27:38.086
kind of thing easier.

00:27:39.146 --> 00:27:41.186
First of all, all the numeric

00:27:41.186 --> 00:27:43.296
types now define a random method

00:27:43.486 --> 00:27:45.576
that takes a range and returns a

00:27:45.576 --> 00:27:47.326
number uniformly distributed in

00:27:47.326 --> 00:27:47.986
that range.

00:27:48.196 --> 00:27:49.816
This uses the correct algorithm

00:27:49.816 --> 00:27:51.316
and it even works for floats.

00:27:52.516 --> 00:27:58.596
[ Applause ]

00:27:59.096 --> 00:28:00.676
For higher level code we've

00:28:00.676 --> 00:28:03.076
added a random element method to

00:28:03.076 --> 00:28:04.196
the collection protocol.

00:28:04.786 --> 00:28:07.026
And just like min and max this

00:28:07.026 --> 00:28:08.636
returns an optional so that if

00:28:08.636 --> 00:28:10.376
you pass in an empty collection

00:28:10.526 --> 00:28:11.506
you get back no.

00:28:12.596 --> 00:28:14.326
And finally there's a shuffled

00:28:14.326 --> 00:28:17.116
method on collection where this

00:28:17.116 --> 00:28:18.926
gives you an array with a random

00:28:18.926 --> 00:28:20.876
permutation of the elements of

00:28:20.876 --> 00:28:21.616
that collection.

00:28:22.146 --> 00:28:25.216
And we think the default Random

00:28:25.216 --> 00:28:26.636
Number Generator is a good

00:28:26.636 --> 00:28:27.996
choice for most apps.

00:28:28.296 --> 00:28:29.816
But you can also implement your

00:28:29.816 --> 00:28:29.883
own.

00:28:30.676 --> 00:28:31.836
So there's a random number

00:28:31.836 --> 00:28:34.206
generator protocol and once you

00:28:34.206 --> 00:28:35.606
write a type that conforms to

00:28:35.606 --> 00:28:37.826
this protocol you can pass it to

00:28:37.826 --> 00:28:39.326
all these APIs that I talked

00:28:39.326 --> 00:28:40.846
about which have an additional

00:28:40.846 --> 00:28:43.416
overload with a using parameter

00:28:43.576 --> 00:28:44.706
that takes a random number

00:28:44.706 --> 00:28:45.236
generator.

00:28:46.746 --> 00:28:49.456
OK, so we saw these build

00:28:49.456 --> 00:28:51.446
configuration checks earlier.

00:28:51.526 --> 00:28:54.346
Let's talk some more about them.

00:28:54.566 --> 00:28:55.896
Well, this is a pretty common

00:28:55.896 --> 00:28:56.806
pattern in Swift.

00:28:57.026 --> 00:28:58.356
You have a little piece of Swift

00:28:58.356 --> 00:29:00.796
code that is shared between iOS

00:29:00.796 --> 00:29:03.836
and macOS and on iOS you want to

00:29:03.836 --> 00:29:05.206
do something with UIKit.

00:29:05.586 --> 00:29:06.776
On macOS you want to do

00:29:06.776 --> 00:29:08.156
something similar in AppKit.

00:29:08.896 --> 00:29:10.466
So if you want to do this today

00:29:10.466 --> 00:29:11.816
you're going to write a #if

00:29:12.236 --> 00:29:14.186
compile time condition check and

00:29:14.186 --> 00:29:15.386
then you have to list out those

00:29:15.386 --> 00:29:17.216
operating systems where UIKit is

00:29:17.216 --> 00:29:17.736
available.

00:29:18.566 --> 00:29:20.046
So but what you really care

00:29:20.046 --> 00:29:21.836
about is not that you're running

00:29:21.836 --> 00:29:23.016
on this particular operating

00:29:23.016 --> 00:29:24.606
system, but that you can import

00:29:24.606 --> 00:29:25.096
UIKit.

00:29:25.626 --> 00:29:27.956
So on Swift 4.2 we've added a

00:29:27.956 --> 00:29:30.086
has import Build Configuration

00:29:30.086 --> 00:29:32.486
Directive so you can better

00:29:32.486 --> 00:29:33.476
express your intent.

00:29:34.171 --> 00:29:36.171
[ Applause ]

00:29:36.326 --> 00:29:38.026
And with the new features of

00:29:38.026 --> 00:29:39.686
Swift 4.2, I can actually

00:29:39.686 --> 00:29:40.766
improve this code further.

00:29:41.246 --> 00:29:43.326
So let's say that I'm also going

00:29:43.326 --> 00:29:44.966
to explicitly check for AppKit

00:29:45.306 --> 00:29:47.036
and then if neither UIKit nor

00:29:47.036 --> 00:29:48.866
AppKit is available, for example

00:29:48.866 --> 00:29:50.576
if I'm building on Linux, I'm

00:29:50.576 --> 00:29:52.356
going to use the new #error

00:29:52.546 --> 00:29:53.916
build directive to produce a

00:29:53.916 --> 00:29:55.306
friendly compile time error

00:29:55.306 --> 00:29:55.796
message.

00:29:57.206 --> 00:29:59.376
OK, now here's another similar

00:29:59.376 --> 00:30:00.416
source of boilerplate.

00:30:01.616 --> 00:30:03.126
So if I want to compile

00:30:03.126 --> 00:30:05.066
something conditionally when I'm

00:30:05.066 --> 00:30:06.476
in the simulator environment,

00:30:06.776 --> 00:30:09.266
then today in Swift 4 I have to

00:30:09.266 --> 00:30:11.546
copy and paste this ugly thing

00:30:11.546 --> 00:30:12.686
everywhere I want to perform

00:30:12.686 --> 00:30:13.176
that check.

00:30:14.056 --> 00:30:16.456
In Swift 4.2 you can use the new

00:30:16.456 --> 00:30:18.596
hasTargetEnvironment condition,

00:30:18.906 --> 00:30:21.216
to again better state your

00:30:21.216 --> 00:30:23.006
intent and just explicitly ask

00:30:23.006 --> 00:30:25.026
the compiler, am I compiling for

00:30:25.026 --> 00:30:26.106
the simulator or not?

00:30:26.876 --> 00:30:28.826
And while we're at it, let's

00:30:28.826 --> 00:30:30.566
replace that FIXME with a

00:30:30.656 --> 00:30:32.036
#warning build directive to

00:30:32.076 --> 00:30:33.986
produce a message or compile

00:30:34.046 --> 00:30:35.856
time so that I don't forget to

00:30:35.856 --> 00:30:38.126
fix my FIXME.

00:30:38.126 --> 00:30:40.916
OK, so that about wraps up all

00:30:40.916 --> 00:30:42.306
the features that I'm going to

00:30:42.306 --> 00:30:43.516
discuss today, but I have a

00:30:43.516 --> 00:30:44.656
couple more things to talk

00:30:44.656 --> 00:30:44.936
about.

00:30:46.026 --> 00:30:47.646
Let's unwrap, Implicitly

00:30:47.646 --> 00:30:48.586
Unwrapped Optionals.

00:30:48.806 --> 00:30:49.646
That's a horrible pun.

00:30:50.296 --> 00:30:52.986
OK, so Implicitly Unwrapped

00:30:52.986 --> 00:30:54.326
Optionals can be a little bit

00:30:54.326 --> 00:30:57.686
confusing and let's first review

00:30:57.686 --> 00:30:59.246
the mental model for Implicitly

00:30:59.246 --> 00:31:00.196
Unwrapped Optionals.

00:31:00.196 --> 00:31:01.266
How do I think about them?

00:31:01.966 --> 00:31:04.426
Well, so since Swift 3 they're

00:31:04.426 --> 00:31:06.326
not the type of an expression.

00:31:06.816 --> 00:31:08.006
Don't think of it as a type.

00:31:08.446 --> 00:31:09.856
Instead, think of Implicitly

00:31:09.856 --> 00:31:11.256
Unwrapped Optionals as an

00:31:11.256 --> 00:31:13.096
attribute of a declaration.

00:31:13.996 --> 00:31:15.756
And what the compiler does when

00:31:15.756 --> 00:31:17.526
you reference such a declaration

00:31:17.846 --> 00:31:19.186
is it will first try to type

00:31:19.186 --> 00:31:21.536
check it as a plain optional and

00:31:21.536 --> 00:31:23.006
then if that doesn't make sense

00:31:23.006 --> 00:31:24.556
in the context where it's used,

00:31:24.746 --> 00:31:26.916
it goes ahead and unwraps it and

00:31:26.916 --> 00:31:28.096
then type checks it as the

00:31:28.096 --> 00:31:28.876
underlined type.

00:31:30.296 --> 00:31:31.746
So let's look at an example of

00:31:31.746 --> 00:31:32.506
the first case.

00:31:33.236 --> 00:31:34.886
So here I have two functions,

00:31:34.966 --> 00:31:36.596
the first of which produces and

00:31:36.596 --> 00:31:37.906
implicitly unwrapped optional

00:31:37.906 --> 00:31:39.656
integer and the second of which

00:31:39.656 --> 00:31:41.226
takes a value of any type.

00:31:41.836 --> 00:31:43.306
And I'm going to call the second

00:31:43.306 --> 00:31:44.516
function with the result of the

00:31:44.516 --> 00:31:45.256
first function.

00:31:45.916 --> 00:31:47.966
Now in this case I can store an

00:31:47.966 --> 00:31:50.506
optional Int inside of an Any

00:31:50.856 --> 00:31:52.696
and so no forced unwrapping is

00:31:52.696 --> 00:31:53.206
performed.

00:31:53.466 --> 00:31:55.456
The value simply becomes a plain

00:31:55.456 --> 00:31:55.896
optional.

00:31:55.896 --> 00:31:59.156
Let's look at an example of the

00:31:59.156 --> 00:31:59.966
second case now.

00:32:00.876 --> 00:32:02.856
Here, the first function now

00:32:02.856 --> 00:32:05.486
produces -- sorry, the second

00:32:05.486 --> 00:32:07.086
function now takes an integer.

00:32:07.516 --> 00:32:09.066
So when I call the second

00:32:09.066 --> 00:32:10.646
function with the result of the

00:32:10.706 --> 00:32:13.006
first function then I cannot

00:32:13.086 --> 00:32:14.986
pass an optional Int where an

00:32:14.986 --> 00:32:16.126
Int was expected.

00:32:16.596 --> 00:32:18.246
So the compiler has to insert a

00:32:18.246 --> 00:32:21.296
force unwrap and then it all

00:32:21.296 --> 00:32:22.656
works because now I have an Int

00:32:22.836 --> 00:32:26.266
and an Int And this mental model

00:32:26.346 --> 00:32:27.626
makes Implicitly Unwrapped

00:32:27.626 --> 00:32:29.176
Optionals very easy to reason

00:32:29.176 --> 00:32:29.506
about.

00:32:30.206 --> 00:32:32.566
But until recently the compiler

00:32:32.776 --> 00:32:34.166
had some edge cases where it did

00:32:34.166 --> 00:32:35.636
not always follow this model.

00:32:36.316 --> 00:32:38.956
So recall that you cannot have

00:32:38.956 --> 00:32:40.386
an implicitly unwrapped optional

00:32:40.386 --> 00:32:41.696
that is part of another type.

00:32:42.416 --> 00:32:43.706
And this is still the case in

00:32:43.706 --> 00:32:44.646
Swift 4.2.

00:32:44.816 --> 00:32:46.616
I cannot have an array of

00:32:46.676 --> 00:32:48.296
implicitly unwrapped Int's.

00:32:49.136 --> 00:32:51.566
However, in Swift 4 previously,

00:32:51.876 --> 00:32:53.136
there is some edge cases like

00:32:53.186 --> 00:32:53.536
this.

00:32:53.536 --> 00:32:55.606
I could define a type alias

00:32:55.796 --> 00:32:57.596
where the underlying type was

00:32:57.776 --> 00:32:59.606
implicitly unwrapped Int and

00:32:59.606 --> 00:33:00.956
then I could make an array of

00:33:01.016 --> 00:33:03.166
this type alias and I would get

00:33:03.166 --> 00:33:04.756
very confusing behavior from the

00:33:04.756 --> 00:33:06.296
compiler that made code hard to

00:33:06.296 --> 00:33:06.906
understand.

00:33:07.596 --> 00:33:09.516
So in Swift 4.2 we've

00:33:09.516 --> 00:33:10.816
re-implemented Implicitly

00:33:10.816 --> 00:33:12.556
Unwrapped Optional so that it

00:33:12.666 --> 00:33:14.736
exactly matches the mental model

00:33:14.736 --> 00:33:17.186
I outlined earlier and this

00:33:17.386 --> 00:33:19.226
confusing code example now

00:33:19.226 --> 00:33:20.986
generates a compile time warning

00:33:21.306 --> 00:33:23.586
and the compiler parses that as

00:33:23.946 --> 00:33:25.816
if it was just a plain array of

00:33:25.816 --> 00:33:27.576
integers, of optional integers.

00:33:28.546 --> 00:33:30.836
Now, most code will not be

00:33:30.836 --> 00:33:32.266
affected by this change to

00:33:32.266 --> 00:33:33.626
Implicitly Unwrapped Optional,

00:33:34.036 --> 00:33:35.436
but if you were accidentally

00:33:35.436 --> 00:33:37.426
relying on these edge cases I

00:33:37.426 --> 00:33:38.696
encourage you to check out this

00:33:38.746 --> 00:33:41.096
blog post on Swift.org that goes

00:33:41.096 --> 00:33:42.486
into a lot of detail and has a

00:33:42.486 --> 00:33:44.736
lot of examples about what

00:33:44.736 --> 00:33:47.136
changed and how.

00:33:47.376 --> 00:33:49.756
OK, now there's only one more

00:33:49.756 --> 00:33:50.566
thing here today.

00:33:50.986 --> 00:33:52.566
Let's talk about memory

00:33:52.566 --> 00:33:53.866
exclusivity checking.

00:33:55.196 --> 00:33:57.946
So if you recall, in Swift 4 we

00:33:57.946 --> 00:33:59.896
introduced something called

00:33:59.896 --> 00:34:01.386
Memory Exclusivity Checking,

00:34:01.646 --> 00:34:02.896
which was a combination of

00:34:02.956 --> 00:34:05.186
compile time and runtime checks

00:34:05.436 --> 00:34:06.696
that restricted certain

00:34:06.696 --> 00:34:08.856
operations from being performed.

00:34:09.315 --> 00:34:10.976
In particular we banned

00:34:11.286 --> 00:34:13.376
overlapping access to the same

00:34:13.376 --> 00:34:14.356
memory location.

00:34:14.856 --> 00:34:15.656
What does this mean?

00:34:15.815 --> 00:34:17.096
Well, let's look at an example.

00:34:17.666 --> 00:34:20.085
So here's a piece of code that

00:34:20.085 --> 00:34:21.706
implements a data type for

00:34:21.896 --> 00:34:23.246
operating system paths.

00:34:23.766 --> 00:34:25.446
And this is represented as an

00:34:25.565 --> 00:34:27.005
array of path components.

00:34:27.576 --> 00:34:28.815
And there's a withAppended

00:34:28.815 --> 00:34:29.206
method.

00:34:30.216 --> 00:34:31.946
This method adds an element to

00:34:31.946 --> 00:34:33.735
the array, then in calls a

00:34:33.735 --> 00:34:35.806
closure that you pass in and

00:34:35.806 --> 00:34:37.036
then it removes that element

00:34:37.076 --> 00:34:37.626
from the array.

00:34:38.295 --> 00:34:40.036
And this code is totally fine,

00:34:40.036 --> 00:34:41.726
it's a valid Swift 4 code.

00:34:42.755 --> 00:34:44.505
But let's look at this usage of

00:34:44.505 --> 00:34:45.536
our path data type.

00:34:46.545 --> 00:34:47.976
So here I have a path that's

00:34:47.976 --> 00:34:49.746
stored and a local variable and

00:34:50.056 --> 00:34:51.806
then I call withAppended on it

00:34:52.295 --> 00:34:54.856
and inside the closure I access

00:34:54.856 --> 00:34:56.306
that local variable again

00:34:56.536 --> 00:34:57.056
printing it.

00:34:57.556 --> 00:34:58.696
So what the problem here?

00:34:59.436 --> 00:35:01.076
Well, it turns out this code is

00:35:01.076 --> 00:35:03.756
actually ambiguous because when

00:35:03.756 --> 00:35:05.866
I access that local variable

00:35:06.136 --> 00:35:08.436
inside the closure, it's already

00:35:08.436 --> 00:35:10.086
being modified by this

00:35:10.086 --> 00:35:11.686
withAppended method, which is a

00:35:11.686 --> 00:35:12.586
mutating method.

00:35:13.306 --> 00:35:16.136
So the ambiguity is that do I

00:35:16.136 --> 00:35:18.466
mean the original value of path

00:35:18.806 --> 00:35:20.556
as it was before I called

00:35:20.556 --> 00:35:22.706
withAppended or do I mean the

00:35:22.706 --> 00:35:24.106
current value that is being

00:35:24.106 --> 00:35:25.926
modified whatever that means.

00:35:26.756 --> 00:35:28.636
Well, in Swift 4 this was a

00:35:28.636 --> 00:35:30.396
compile time error because it

00:35:30.396 --> 00:35:32.226
was an exclusivity violation.

00:35:32.756 --> 00:35:34.716
And one way to address this is

00:35:34.716 --> 00:35:35.976
to resolve the ambiguity by

00:35:35.976 --> 00:35:37.926
telling the complier, hey I

00:35:37.926 --> 00:35:40.496
really want the new value so I'm

00:35:40.496 --> 00:35:41.766
going to just pass it in as a

00:35:41.766 --> 00:35:43.636
parameter to the closure instead

00:35:43.636 --> 00:35:44.986
of capturing it.

00:35:45.586 --> 00:35:47.366
OK, but now look at this

00:35:47.366 --> 00:35:47.936
example.

00:35:48.266 --> 00:35:49.586
So this is almost the same

00:35:49.586 --> 00:35:51.376
function except that it's

00:35:51.376 --> 00:35:53.326
generic, it's prioritized by the

00:35:53.326 --> 00:35:54.646
return type of the closure.

00:35:55.306 --> 00:35:57.436
And in this case we can have the

00:35:57.436 --> 00:35:59.286
same kind of ambiguity by

00:35:59.286 --> 00:36:01.246
accessing the path value from

00:36:01.246 --> 00:36:02.166
inside the closure.

00:36:02.496 --> 00:36:04.766
But previously Swift 4 did not

00:36:04.766 --> 00:36:06.556
catch this error at compile

00:36:06.616 --> 00:36:06.866
time.

00:36:08.286 --> 00:36:10.436
In Swift 4.2 we've improved the

00:36:10.436 --> 00:36:12.526
static exclusivity checking to

00:36:12.526 --> 00:36:14.446
catch ambiguities like this in

00:36:14.446 --> 00:36:15.256
more cases.

00:36:16.386 --> 00:36:18.546
And in addition to improving --

00:36:19.146 --> 00:36:20.526
OK, and you can also fix the

00:36:20.526 --> 00:36:22.236
ambiguity in the same way by

00:36:22.236 --> 00:36:23.566
passing it as a parameter to the

00:36:23.566 --> 00:36:24.026
closure.

00:36:24.576 --> 00:36:26.876
In addition to improving the

00:36:26.876 --> 00:36:28.986
static checks, we've also added

00:36:28.986 --> 00:36:30.796
the ability to use the runtime

00:36:30.796 --> 00:36:32.456
exclusivity checks and release

00:36:32.456 --> 00:36:32.906
builds.

00:36:33.336 --> 00:36:35.166
And this has some overhead but

00:36:35.166 --> 00:36:36.606
if your app is not performance

00:36:36.606 --> 00:36:38.096
critical, we encourage you to

00:36:38.096 --> 00:36:39.746
try this out and leave it on all

00:36:39.746 --> 00:36:40.216
the time.

00:36:40.686 --> 00:36:42.386
In the future, we will get the

00:36:42.386 --> 00:36:44.236
overhead of these dynamic checks

00:36:44.306 --> 00:36:46.276
down to the point where we can

00:36:46.276 --> 00:36:48.126
leave this enabled all the time

00:36:48.186 --> 00:36:49.226
and it will give you an extra

00:36:49.226 --> 00:36:50.846
level of protection just like

00:36:50.896 --> 00:36:53.296
array bounce checking or integer

00:36:53.296 --> 00:36:54.596
overflow checking today.

00:36:55.166 --> 00:36:58.316
And there's a lot more in Swift

00:36:58.316 --> 00:37:00.426
4.2 that I didn't talk about

00:37:01.236 --> 00:37:01.576
today.

00:37:02.096 --> 00:37:03.716
And we encourage you to try it

00:37:03.716 --> 00:37:05.496
out on your existing apps.

00:37:05.546 --> 00:37:06.776
We also want you to try out the

00:37:06.776 --> 00:37:08.536
new features and if you have any

00:37:08.536 --> 00:37:10.056
questions please come to the

00:37:10.056 --> 00:37:11.966
labs and ask us.

00:37:12.556 --> 00:37:12.956
Thank you.

00:37:14.516 --> 00:37:19.500
[ Applause ]
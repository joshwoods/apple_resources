WEBVTT

00:00:06.516 --> 00:00:15.500
[ Music ]

00:00:22.346 --> 00:00:22.996
>> Good morning.

00:00:23.426 --> 00:00:24.156
How is everybody?

00:00:24.756 --> 00:00:24.846
>> Good.

00:00:25.516 --> 00:00:28.886
[ Applause ]

00:00:29.386 --> 00:00:30.816
>> My name is Matthew Badin, and

00:00:30.816 --> 00:00:31.706
I'm an engineer at Apple.

00:00:32.526 --> 00:00:33.646
Welcome to the Using Accelerate

00:00:33.646 --> 00:00:34.376
and simd session.

00:00:37.026 --> 00:00:38.096
So my colleague Luke Chang and I

00:00:38.096 --> 00:00:39.046
are pretty excited today.

00:00:39.046 --> 00:00:40.756
We get to talk to you about all

00:00:40.756 --> 00:00:41.716
the great APIs that are

00:00:41.716 --> 00:00:43.206
available in Accelerate and its

00:00:43.206 --> 00:00:44.656
associated frameworks, and we're

00:00:45.426 --> 00:00:46.386
going to start by taking a

00:00:46.386 --> 00:00:47.716
high-level overview of

00:00:47.716 --> 00:00:48.696
Accelerate and some of the

00:00:48.696 --> 00:00:49.596
high-performance libraries that

00:00:49.596 --> 00:00:51.216
are contained inside it.

00:00:51.576 --> 00:00:52.516
We're then going to take a deep

00:00:52.516 --> 00:00:54.196
dive into a few of libraries,

00:00:54.756 --> 00:00:56.346
and we're going to start by

00:00:56.346 --> 00:00:57.196
taking a look at vDSP.

00:00:57.196 --> 00:00:59.766
We have two examples for you.

00:01:00.996 --> 00:01:01.826
The first one, we're going to

00:01:01.826 --> 00:01:03.036
show you how to extract signal

00:01:03.036 --> 00:01:04.686
from noise, and then we're going

00:01:04.686 --> 00:01:06.346
to show you how you can remove

00:01:06.466 --> 00:01:07.666
certain types of artifacts from

00:01:07.666 --> 00:01:07.996
an image.

00:01:09.426 --> 00:01:10.696
We're then going to take a look

00:01:10.696 --> 00:01:12.406
at simd, and we're going to show

00:01:12.406 --> 00:01:13.656
you how you can use quaternions

00:01:13.656 --> 00:01:14.986
to represent rotations in three

00:01:14.986 --> 00:01:15.446
dimensions.

00:01:16.056 --> 00:01:19.526
I'm then going to pass off the

00:01:19.526 --> 00:01:20.646
presentation to my colleague,

00:01:20.646 --> 00:01:21.926
Luke Cheng, who's going to show

00:01:21.926 --> 00:01:22.726
you some of the interesting

00:01:22.726 --> 00:01:23.646
things that you can do with

00:01:23.646 --> 00:01:24.116
vImage.

00:01:25.256 --> 00:01:27.116
So with that, let's get started.

00:01:27.736 --> 00:01:30.226
So you're probably asking

00:01:30.226 --> 00:01:31.266
yourself exactly this.

00:01:31.656 --> 00:01:33.026
What on Earth is Accelerate?

00:01:33.596 --> 00:01:37.276
So the primary purpose of

00:01:37.276 --> 00:01:38.616
Accelerate is to provide

00:01:38.906 --> 00:01:40.236
thousands of low-level math

00:01:40.236 --> 00:01:42.146
primitives, and we provide these

00:01:42.146 --> 00:01:43.606
primitives across all of Apple's

00:01:43.606 --> 00:01:44.186
platforms.

00:01:44.846 --> 00:01:46.376
So this includes not only iOS

00:01:46.376 --> 00:01:48.436
and macOS but watchOS and tvOS

00:01:48.436 --> 00:01:48.796
as well.

00:01:51.536 --> 00:01:52.796
Most of these primitives are

00:01:52.796 --> 00:01:53.546
hand-tuned to the

00:01:53.546 --> 00:01:54.846
microarchitecture of the

00:01:54.846 --> 00:01:55.316
processor.

00:01:56.156 --> 00:01:57.596
So this means we get excellent

00:01:57.596 --> 00:01:58.276
performance.

00:01:58.766 --> 00:02:01.536
And this performance translates

00:02:01.536 --> 00:02:02.956
directly into energy savings.

00:02:03.756 --> 00:02:05.646
So if you're an app developer

00:02:05.816 --> 00:02:06.696
and you use the Accelerate

00:02:06.696 --> 00:02:08.276
framework, not only will your

00:02:08.276 --> 00:02:09.876
application run faster, but

00:02:09.876 --> 00:02:10.816
you'll also use less battery

00:02:10.816 --> 00:02:11.146
life.

00:02:11.846 --> 00:02:12.776
This means your users are going

00:02:12.776 --> 00:02:13.676
to have an overall better

00:02:13.676 --> 00:02:13.976
experience.

00:02:18.446 --> 00:02:20.416
Now, because we provide so many

00:02:20.416 --> 00:02:22.496
primitives, we find it useful to

00:02:22.496 --> 00:02:24.186
organize or group them into

00:02:24.186 --> 00:02:25.406
domain-specific libraries.

00:02:26.706 --> 00:02:28.676
So, for instance, we group all

00:02:28.676 --> 00:02:29.926
the signal processing primitives

00:02:29.996 --> 00:02:31.026
under vDSP.

00:02:32.156 --> 00:02:33.256
So, for instance, this would be

00:02:33.256 --> 00:02:35.196
your FFTs or your DFTs and your

00:02:35.196 --> 00:02:36.636
DCTs, your fast Fourier

00:02:36.636 --> 00:02:37.956
transforms, your discrete cosine

00:02:37.956 --> 00:02:38.516
transforms.

00:02:40.186 --> 00:02:42.786
VImage contains the image

00:02:42.786 --> 00:02:43.586
processing primitives.

00:02:44.306 --> 00:02:45.506
If you're doing color space

00:02:45.506 --> 00:02:46.976
conversions, this is the library

00:02:48.296 --> 00:02:49.836
for you.

00:02:49.836 --> 00:02:51.056
VForce contains vector versions

00:02:51.056 --> 00:02:52.196
of the transcendental functions.

00:02:52.466 --> 00:02:55.906
So for instance sine and cosine.

00:02:56.616 --> 00:02:57.906
We also have support for dense

00:02:57.906 --> 00:03:00.596
linear algebra as well as sparse

00:03:00.596 --> 00:03:03.336
linear algebra, and we have a

00:03:03.336 --> 00:03:05.176
specialized library for neural

00:03:05.176 --> 00:03:06.626
networks called BNNS.

00:03:06.626 --> 00:03:07.896
It stands for Basic Neural

00:03:07.896 --> 00:03:08.726
Network Subroutines.

00:03:09.766 --> 00:03:10.916
Not strictly part of the

00:03:10.916 --> 00:03:12.596
Accelerate framework but very

00:03:12.596 --> 00:03:13.716
closely related, and we find

00:03:13.716 --> 00:03:14.796
these libraries very useful,

00:03:15.126 --> 00:03:16.656
include libraries like simd,

00:03:17.406 --> 00:03:18.336
which is a vector programming

00:03:18.336 --> 00:03:20.636
aid for the CPU, and

00:03:20.636 --> 00:03:21.956
Compression, which contains

00:03:22.036 --> 00:03:23.386
several different lossless data

00:03:23.386 --> 00:03:24.136
compression algorithms.

00:03:24.136 --> 00:03:27.116
So let's take a look at our

00:03:27.116 --> 00:03:27.766
first library.

00:03:28.266 --> 00:03:30.646
We're going to take a look at

00:03:31.366 --> 00:03:31.776
vDSP.

00:03:31.916 --> 00:03:33.186
VDSP is a state-of-the-art

00:03:33.186 --> 00:03:34.346
signal processing library, and

00:03:34.516 --> 00:03:35.556
it contains a wide range of

00:03:35.556 --> 00:03:36.606
signal processing primitives.

00:03:37.706 --> 00:03:39.016
These range from basic

00:03:39.016 --> 00:03:40.456
arithmetic operations on arrays

00:03:40.766 --> 00:03:43.396
such as add and subtract as well

00:03:43.396 --> 00:03:44.806
as more complicated operations

00:03:44.996 --> 00:03:47.716
like convolution and FFTs.

00:03:47.716 --> 00:03:50.306
If you're a successful app

00:03:50.306 --> 00:03:51.846
developer and maybe in the past

00:03:51.846 --> 00:03:54.196
you have avoided FFTs, I want to

00:03:54.196 --> 00:03:55.156
show you how we make that easy

00:03:55.156 --> 00:03:55.776
with Accelerate.

00:03:56.286 --> 00:03:57.326
With just a few lines of code,

00:03:57.486 --> 00:03:58.286
you can make that work.

00:03:59.206 --> 00:03:59.946
And I have an example.

00:03:59.946 --> 00:04:00.696
I'm going to show you how to

00:04:00.726 --> 00:04:01.976
extract signal from noise.

00:04:15.046 --> 00:04:15.936
So what we have here is an audio

00:04:15.936 --> 00:04:16.315
signal.

00:04:16.706 --> 00:04:18.005
This is the base signal.

00:04:18.116 --> 00:04:19.346
We haven't added any noise to it

00:04:19.346 --> 00:04:20.926
yet, and you'll notice I have

00:04:20.926 --> 00:04:21.946
two sliders at the bottom.

00:04:22.506 --> 00:04:24.196
In the lower left I have a

00:04:24.196 --> 00:04:27.236
slider that lets me add noise,

00:04:27.966 --> 00:04:30.316
and you can see that.

00:04:30.506 --> 00:04:31.976
And I also have a second slider

00:04:31.976 --> 00:04:33.196
that let's me remove this noise

00:04:34.666 --> 00:04:35.366
called Threshold.

00:04:37.316 --> 00:04:38.216
You'll also notice I have a

00:04:38.216 --> 00:04:39.306
toggle switch in the lower

00:04:39.306 --> 00:04:39.566
right.

00:04:40.946 --> 00:04:42.596
This lets me look at this under

00:04:42.596 --> 00:04:43.276
a different domain.

00:04:43.436 --> 00:04:45.456
So currently we're looking at

00:04:45.456 --> 00:04:46.696
this signal under the time

00:04:46.696 --> 00:04:47.026
domain.

00:04:47.026 --> 00:04:48.276
We're going to do some analysis

00:04:49.226 --> 00:04:50.416
and see this signal in the

00:04:50.416 --> 00:04:51.056
frequency domain.

00:04:51.606 --> 00:04:54.396
You can see all the spikes on

00:04:54.396 --> 00:04:54.836
the left.

00:04:55.416 --> 00:04:56.296
Those are the frequency

00:04:56.296 --> 00:04:59.806
components of the signal.

00:04:59.986 --> 00:05:01.626
You'll also notice the blue bar.

00:05:02.496 --> 00:05:04.396
The blue bar is the threshold

00:05:04.396 --> 00:05:05.416
slider, so you can see I can

00:05:05.416 --> 00:05:06.266
move it.

00:05:07.596 --> 00:05:10.026
So what I'm going to do now is

00:05:10.516 --> 00:05:11.386
add some more noise to the

00:05:11.386 --> 00:05:11.746
signal.

00:05:12.706 --> 00:05:13.656
Actually, let's add quite a bit

00:05:13.656 --> 00:05:13.976
of noise.

00:05:18.466 --> 00:05:19.526
So you can see the signal that

00:05:19.526 --> 00:05:21.286
I'm still interested in is

00:05:21.426 --> 00:05:22.896
represented by the spikes on the

00:05:22.896 --> 00:05:24.896
left or another way of looking

00:05:24.896 --> 00:05:26.036
at it is the spikes with the

00:05:26.106 --> 00:05:28.326
tallest height, and what we've

00:05:28.326 --> 00:05:29.366
added, the type of noise we're

00:05:29.366 --> 00:05:30.406
adding to this, is background

00:05:30.406 --> 00:05:30.726
noise.

00:05:31.406 --> 00:05:32.176
So it's kind of evenly

00:05:32.176 --> 00:05:34.026
distributed spikes everywhere,

00:05:34.026 --> 00:05:36.746
but they're low-level spikes.

00:05:37.126 --> 00:05:38.876
So now I'm going to remove this

00:05:38.876 --> 00:05:40.276
noise, and the way I'm going to

00:05:40.276 --> 00:05:41.196
do this is I'm going to move

00:05:41.196 --> 00:05:42.436
this threshold slightly higher.

00:05:44.146 --> 00:05:45.956
As I do this, what's happening

00:05:45.956 --> 00:05:47.816
is, behind the scenes, is we're

00:05:47.816 --> 00:05:50.246
identifying any frequency

00:05:50.246 --> 00:05:51.146
component less than this

00:05:51.146 --> 00:05:52.466
threshold and removing it.

00:05:52.646 --> 00:05:54.166
We're saying effectively if

00:05:54.166 --> 00:05:55.876
there is any spike with a height

00:05:55.876 --> 00:05:57.056
less than this blue bar, we're

00:05:57.416 --> 00:05:58.586
going to pretend it's noise and

00:05:58.586 --> 00:05:59.726
remove it.

00:06:00.996 --> 00:06:02.186
So if I keep sliding this

00:06:02.186 --> 00:06:02.566
higher,

00:06:05.976 --> 00:06:07.276
eventually I've removed all the

00:06:07.276 --> 00:06:07.616
noise.

00:06:07.946 --> 00:06:12.186
And if I go back to the time

00:06:12.186 --> 00:06:12.866
domain, you can see that I

00:06:12.866 --> 00:06:13.636
removed the noise.

00:06:14.066 --> 00:06:14.916
And in case you don't believe

00:06:14.946 --> 00:06:17.166
me, we can remove the threshold,

00:06:17.976 --> 00:06:19.096
and this is what this looks like

00:06:19.496 --> 00:06:21.096
with all the noise still added.

00:06:21.666 --> 00:06:23.606
So let me show you how we do

00:06:23.606 --> 00:06:23.856
that.

00:06:30.046 --> 00:06:30.876
At a high level what we're going

00:06:30.876 --> 00:06:32.146
to do is first perform an

00:06:32.146 --> 00:06:33.256
analysis on a signal.

00:06:33.656 --> 00:06:34.686
That's what the switch let me

00:06:34.686 --> 00:06:34.846
do.

00:06:36.246 --> 00:06:37.936
We're then going to identify the

00:06:37.936 --> 00:06:38.956
frequency components that

00:06:38.956 --> 00:06:40.426
represent the noise and remove

00:06:40.426 --> 00:06:40.616
them.

00:06:41.926 --> 00:06:43.016
After we have done that, we're

00:06:43.016 --> 00:06:44.366
going to reconstruct the audio

00:06:44.366 --> 00:06:44.686
signal.

00:06:44.686 --> 00:06:45.966
So let me show you some code.

00:06:50.176 --> 00:06:51.446
What we're going to use here is

00:06:51.446 --> 00:06:53.296
a discrete cosine transform or a

00:06:53.296 --> 00:06:53.786
DCT.

00:06:55.496 --> 00:06:56.666
You can see here the DCT

00:06:56.666 --> 00:06:57.476
CreateSetup.

00:06:58.516 --> 00:07:01.046
This context is going to

00:07:01.586 --> 00:07:02.576
describe the type of work we're

00:07:02.576 --> 00:07:03.746
going to do as well as give us

00:07:03.746 --> 00:07:04.896
space to perform this work.

00:07:06.396 --> 00:07:08.276
In this case, we're going to use

00:07:08.276 --> 00:07:09.986
a type 2 DCT.

00:07:10.596 --> 00:07:11.476
We're then going to pass this

00:07:11.476 --> 00:07:13.506
context to an execute function.

00:07:16.016 --> 00:07:18.026
This will actually perform the

00:07:18.026 --> 00:07:18.316
work.

00:07:21.466 --> 00:07:22.756
Once we've performed the

00:07:22.756 --> 00:07:23.996
analysis, we want to remove the

00:07:23.996 --> 00:07:24.356
noise.

00:07:24.746 --> 00:07:25.616
This right here is where the

00:07:25.616 --> 00:07:26.296
magic happens.

00:07:27.326 --> 00:07:28.496
This routine is going to

00:07:28.496 --> 00:07:30.396
identify any frequency component

00:07:30.396 --> 00:07:32.516
less than that threshold and

00:07:32.586 --> 00:07:33.256
make it zero.

00:07:33.616 --> 00:07:36.486
It's going to zero it out.

00:07:36.756 --> 00:07:37.736
After we've done that, we want

00:07:37.736 --> 00:07:38.916
to reconstruct the audio signal.

00:07:43.406 --> 00:07:44.156
Again, we're going to need to

00:07:44.156 --> 00:07:45.336
use CreateSetup to create

00:07:45.336 --> 00:07:45.976
context.

00:07:47.456 --> 00:07:49.996
In this case, we're going to use

00:07:49.996 --> 00:07:52.736
a type 3 DCT to reconstruct the

00:07:52.736 --> 00:07:52.976
signal.

00:07:56.436 --> 00:07:58.926
We're then going to pass this

00:07:58.926 --> 00:08:00.676
context DCT execute, and this

00:08:00.676 --> 00:08:02.036
will actually perform the work

00:08:02.036 --> 00:08:02.886
of reconstructing the audio

00:08:02.886 --> 00:08:03.216
signal.

00:08:05.316 --> 00:08:08.356
So what we've shown you is an

00:08:08.356 --> 00:08:09.546
example of how you can remove

00:08:09.546 --> 00:08:11.026
certain types of noise from an

00:08:11.026 --> 00:08:11.966
audio signal using vDSP.

00:08:11.966 --> 00:08:14.436
I want to show you an example of

00:08:14.436 --> 00:08:15.396
how we can remove certain types

00:08:15.396 --> 00:08:17.126
of noise from an image also

00:08:17.126 --> 00:08:17.836
using vDSP.

00:08:18.496 --> 00:08:22.496
In this case, we're going to

00:08:22.566 --> 00:08:23.596
restore an old newspaper

00:08:23.596 --> 00:08:23.966
photograph.

00:08:32.086 --> 00:08:32.816
So what we've done is we've

00:08:32.816 --> 00:08:35.916
taken this image, and we've

00:08:36.275 --> 00:08:38.525
applied a two-tone screen to it.

00:08:39.296 --> 00:08:40.796
So this could represent an old

00:08:40.796 --> 00:08:41.716
newspaper photograph.

00:08:41.916 --> 00:08:42.746
And what we're going to try to

00:08:42.746 --> 00:08:45.236
do is remove this screen.

00:08:45.236 --> 00:08:46.086
We're going to try to remove the

00:08:46.086 --> 00:08:47.456
artifacts that you see.

00:08:48.296 --> 00:08:49.636
Currently, we're in off, so

00:08:49.636 --> 00:08:50.506
we're not doing anything.

00:08:51.126 --> 00:08:52.476
What we're going to do is

00:08:52.476 --> 00:08:53.586
actually take a sample of this

00:08:53.586 --> 00:08:55.196
screen, and we're going to

00:08:55.196 --> 00:08:56.796
create a mask from that sample

00:08:56.796 --> 00:08:58.076
and then apply that to the image

00:08:58.076 --> 00:08:58.796
to try to remove it.

00:08:58.796 --> 00:09:00.576
So let me show you the first

00:09:00.576 --> 00:09:00.956
attempt.

00:09:05.066 --> 00:09:06.346
So what we're doing is we are

00:09:06.346 --> 00:09:08.306
identifying a frequency

00:09:08.306 --> 00:09:09.366
component at a certain

00:09:09.366 --> 00:09:11.276
threshold, and any frequency

00:09:11.276 --> 00:09:13.286
component higher than that

00:09:13.286 --> 00:09:16.496
threshold we're going to remove.

00:09:17.066 --> 00:09:17.866
And you see, if we set the

00:09:17.866 --> 00:09:20.486
threshold too low, not only do

00:09:20.486 --> 00:09:22.466
we remove the artifacts, but we

00:09:22.466 --> 00:09:23.326
also remove quite a bit of the

00:09:23.326 --> 00:09:23.896
image as well.

00:09:27.716 --> 00:09:29.336
If we set it too high, you can

00:09:29.756 --> 00:09:34.486
see that we didn't do much of

00:09:37.756 --> 00:09:37.976
anything.

00:09:38.986 --> 00:09:39.976
Medium seems about right.

00:09:40.836 --> 00:09:42.386
Medium seems too correctly

00:09:42.386 --> 00:09:45.136
identify the artifacts in the

00:09:45.136 --> 00:09:47.316
image without damaging too much

00:09:47.316 --> 00:09:47.726
of the image.

00:09:48.366 --> 00:09:49.626
So let me show you how we do

00:09:49.626 --> 00:09:49.876
that.

00:09:55.316 --> 00:09:56.346
At a high level what we're going

00:09:56.346 --> 00:09:57.986
to do is we're going to perform

00:09:57.986 --> 00:09:59.626
an FFT on the image and the

00:09:59.626 --> 00:09:59.976
sample.

00:10:01.296 --> 00:10:02.276
We're then going to create a

00:10:02.276 --> 00:10:04.516
mask from that sample and apply

00:10:04.626 --> 00:10:06.956
it to the image.

00:10:07.436 --> 00:10:08.336
Once we've done that, we're

00:10:08.336 --> 00:10:09.576
going to reconstruct the

00:10:09.576 --> 00:10:10.176
original image.

00:10:10.516 --> 00:10:11.826
So let me walk you through some

00:10:11.826 --> 00:10:11.976
code.

00:10:14.736 --> 00:10:18.396
We're going to do an FFT.

00:10:18.516 --> 00:10:19.306
This means it needs to be a

00:10:19.306 --> 00:10:19.936
power of 2.

00:10:20.306 --> 00:10:21.236
That's why you see the log2

00:10:21.236 --> 00:10:21.496
call.

00:10:21.496 --> 00:10:24.796
The 1024 x 1024 is the size of

00:10:24.796 --> 00:10:25.226
the image.

00:10:28.646 --> 00:10:30.106
We're then going to pass it to

00:10:30.106 --> 00:10:30.846
fft2d zrop.

00:10:31.226 --> 00:10:32.076
This is quite a mouthful.

00:10:32.506 --> 00:10:33.976
The important part here is the

00:10:33.976 --> 00:10:35.616
op stands for out of place.

00:10:35.616 --> 00:10:36.746
So we're going to have to create

00:10:36.746 --> 00:10:38.346
some temporary space just for

00:10:38.346 --> 00:10:38.756
the result.

00:10:39.256 --> 00:10:42.876
We're going to store in this

00:10:42.876 --> 00:10:44.346
complex structure, and

00:10:44.486 --> 00:10:45.226
effectively this says we're

00:10:45.226 --> 00:10:46.176
going to store the complex

00:10:46.176 --> 00:10:48.526
number in two arrays with the

00:10:48.526 --> 00:10:49.926
real component in one array and

00:10:49.956 --> 00:10:51.366
the imaginary component in the

00:10:51.686 --> 00:10:51.866
second.

00:10:52.856 --> 00:10:53.816
We also need to specify a

00:10:53.816 --> 00:10:54.296
direction.

00:10:54.746 --> 00:10:55.596
In this case we're going to do a

00:10:55.596 --> 00:10:56.406
forward FFT.

00:11:01.636 --> 00:11:04.736
Now the artifact removal is a

00:11:04.736 --> 00:11:06.886
little bit more advanced, so I'm

00:11:06.886 --> 00:11:07.646
only going to go through this at

00:11:07.646 --> 00:11:08.736
a very high level.

00:11:09.116 --> 00:11:10.056
I recommend you download the

00:11:10.056 --> 00:11:11.126
sample application that's

00:11:11.126 --> 00:11:13.066
available online right now, and

00:11:13.066 --> 00:11:14.666
each one of these routines is

00:11:14.946 --> 00:11:16.726
also documented under vDSP, and

00:11:16.726 --> 00:11:17.536
we have excellent online

00:11:17.536 --> 00:11:18.176
documentation.

00:11:18.766 --> 00:11:21.726
A high level what we're going to

00:11:21.726 --> 00:11:22.926
do is we're going to identify

00:11:22.926 --> 00:11:24.346
the magnitude of the frequency

00:11:24.346 --> 00:11:25.686
components, in this case with

00:11:25.686 --> 00:11:26.166
the sample.

00:11:27.116 --> 00:11:28.956
We're then going to identify the

00:11:28.956 --> 00:11:30.046
components we want to remove.

00:11:31.316 --> 00:11:33.806
We're then going to create a

00:11:33.806 --> 00:11:35.916
mask from that.

00:11:36.436 --> 00:11:37.936
And once we've done that, we're

00:11:37.936 --> 00:11:39.136
going to apply that mask to the

00:11:39.136 --> 00:11:39.506
image.

00:11:40.856 --> 00:11:42.196
Effectively what we're doing is

00:11:42.196 --> 00:11:44.066
we're multiplying by 0 the

00:11:44.066 --> 00:11:45.446
components we want to remove and

00:11:45.446 --> 00:11:46.796
by 1 the components we want to

00:11:46.796 --> 00:11:46.976
keep.

00:11:52.336 --> 00:11:53.756
We're going to use zrop again to

00:11:53.756 --> 00:11:54.636
reconstruct the image.

00:11:55.066 --> 00:11:56.306
Because this is an FFT, we get

00:11:56.306 --> 00:11:57.376
to reuse the context.

00:12:01.076 --> 00:12:03.876
In this case, one key detail is

00:12:03.916 --> 00:12:05.266
we're going to store the image

00:12:05.316 --> 00:12:06.896
in two arrays because this is a

00:12:06.896 --> 00:12:07.646
complex structure.

00:12:08.136 --> 00:12:09.366
So the even pixels are going to

00:12:09.366 --> 00:12:10.496
be in the real array, and the

00:12:10.496 --> 00:12:11.576
odd pixels are going to be in

00:12:11.576 --> 00:12:12.086
the imaginary.

00:12:12.656 --> 00:12:16.136
And again we're going to specify

00:12:16.136 --> 00:12:16.596
a direction.

00:12:16.596 --> 00:12:17.436
In this case, we're going to use

00:12:17.436 --> 00:12:18.576
an inverse FFT.

00:12:18.726 --> 00:12:21.066
So now I want to shift gears for

00:12:21.066 --> 00:12:21.536
a moment.

00:12:22.096 --> 00:12:23.536
Previously we showed you two

00:12:23.536 --> 00:12:27.616
examples, and we had two working

00:12:27.616 --> 00:12:29.616
examples for vDSP, and then we

00:12:29.616 --> 00:12:30.876
worked backwards, and we showed

00:12:30.876 --> 00:12:33.786
you how we constructed these

00:12:34.116 --> 00:12:34.706
examples.

00:12:34.706 --> 00:12:35.576
We worked backwards and showed

00:12:35.576 --> 00:12:36.756
you the moving pieces.

00:12:37.586 --> 00:12:39.086
For this next library, what I

00:12:39.086 --> 00:12:40.286
want to do is start at the basic

00:12:40.286 --> 00:12:40.816
components.

00:12:41.256 --> 00:12:42.636
I want to build up to a result.

00:12:42.636 --> 00:12:44.066
So we're going to take a look at

00:12:44.066 --> 00:12:46.066
simd, and we're going to start

00:12:46.066 --> 00:12:46.956
at the basic low-level

00:12:46.956 --> 00:12:48.246
primitives, and we're going to

00:12:48.246 --> 00:12:50.116
build up to rotations.

00:12:50.116 --> 00:12:51.336
In this case, rotations of 3D

00:12:51.336 --> 00:12:51.836
objects.

00:12:52.896 --> 00:12:57.556
At a high level, simd is an

00:12:57.556 --> 00:12:58.776
abstraction for the vector

00:12:58.776 --> 00:12:59.476
processing unit.

00:13:00.556 --> 00:13:02.306
So what this lets you do is

00:13:02.716 --> 00:13:04.156
declare vector and matrix

00:13:04.156 --> 00:13:06.256
objects, and you get to perform

00:13:06.256 --> 00:13:08.046
operations on these objects, and

00:13:08.046 --> 00:13:09.256
this will map directly to the

00:13:09.256 --> 00:13:10.056
vector hardware of the

00:13:10.056 --> 00:13:10.506
processor.

00:13:11.626 --> 00:13:12.866
So let me show you a coding

00:13:12.866 --> 00:13:13.296
example.

00:13:13.296 --> 00:13:16.866
So what we're going to do here

00:13:16.866 --> 00:13:17.886
is we're going to take two

00:13:17.886 --> 00:13:18.716
arrays, and we're going to

00:13:18.716 --> 00:13:19.896
average the components.

00:13:19.896 --> 00:13:21.916
So we're going to iteratively go

00:13:21.916 --> 00:13:23.146
through each of the scaler

00:13:23.146 --> 00:13:24.526
components, add them together,

00:13:24.526 --> 00:13:25.186
and divide by 2.

00:13:25.366 --> 00:13:28.636
This is going to be really slow.

00:13:30.816 --> 00:13:32.486
Instead, you can declare these

00:13:32.486 --> 00:13:34.366
arrays as simd float4 vector

00:13:34.366 --> 00:13:34.796
types.

00:13:36.116 --> 00:13:38.606
So then we can perform basic

00:13:38.606 --> 00:13:40.906
arithmetic operations on these

00:13:40.906 --> 00:13:41.436
objects.

00:13:42.086 --> 00:13:44.516
So not only can you express the

00:13:44.516 --> 00:13:45.996
computation more naturally, but

00:13:45.996 --> 00:13:47.916
this will also run about as fast

00:13:47.916 --> 00:13:48.356
as it can.

00:13:49.036 --> 00:13:51.056
And this will work across all of

00:13:51.056 --> 00:13:51.826
Apple's platforms.

00:13:56.066 --> 00:13:57.276
Simd has a tremendous amount of

00:13:57.276 --> 00:13:57.846
functionality.

00:13:58.906 --> 00:14:00.686
In addition to vector and matrix

00:14:00.686 --> 00:14:03.696
objects and allowing you to

00:14:03.696 --> 00:14:06.016
perform arithmetic operations on

00:14:06.016 --> 00:14:06.636
these objects.

00:14:07.236 --> 00:14:09.896
It has extensions.

00:14:09.896 --> 00:14:11.886
So for instance, dot products

00:14:12.766 --> 00:14:13.826
and clamp.

00:14:14.286 --> 00:14:15.176
It also has support for the

00:14:15.176 --> 00:14:16.346
transcendental functions, so for

00:14:16.346 --> 00:14:20.096
instance sine and cosine as well

00:14:20.096 --> 00:14:20.816
as quaternions.

00:14:21.536 --> 00:14:23.116
Quaternions are very useful for

00:14:23.116 --> 00:14:24.416
representing rotations in three

00:14:24.416 --> 00:14:25.996
dimensions, and I actually want

00:14:25.996 --> 00:14:27.076
to talk a little bit more about

00:14:27.116 --> 00:14:27.346
those.

00:14:27.346 --> 00:14:30.836
So I'm going to walk you through

00:14:30.946 --> 00:14:31.856
a coding example.

00:14:32.376 --> 00:14:34.666
There's quite a bit to unpack

00:14:34.666 --> 00:14:34.836
here.

00:14:35.416 --> 00:14:36.566
So we're going to start on the

00:14:36.566 --> 00:14:36.826
right.

00:14:37.596 --> 00:14:38.416
We have a unit sphere.

00:14:38.486 --> 00:14:39.696
That's what this gray sphere is.

00:14:39.956 --> 00:14:41.526
And you'll notice this red dot.

00:14:42.136 --> 00:14:44.206
And that's actually the tip of

00:14:44.206 --> 00:14:44.686
this vector.

00:14:45.976 --> 00:14:47.576
We've declared a simd float3

00:14:47.576 --> 00:14:47.986
vector.

00:14:48.166 --> 00:14:49.656
We've set the x and y components

00:14:49.656 --> 00:14:51.576
to 0 and the z component to 1.

00:14:52.176 --> 00:14:53.156
So it's coming out at us.

00:14:53.656 --> 00:14:55.696
And that red dot is represented

00:14:55.696 --> 00:14:56.946
by the tip of that vector.

00:14:58.926 --> 00:14:59.796
We're now going to perform a

00:14:59.796 --> 00:15:01.406
rotation on this vector using a

00:15:01.406 --> 00:15:01.896
quaternion.

00:15:03.136 --> 00:15:04.836
Technically, we're rotating the

00:15:04.836 --> 00:15:06.176
entire scene, but for purposes

00:15:06.176 --> 00:15:07.066
of illustration, we're going to

00:15:07.066 --> 00:15:08.256
say we're rotating this vector.

00:15:10.066 --> 00:15:11.116
When using a quaternion for

00:15:11.116 --> 00:15:12.896
rotations, you need to specify

00:15:12.896 --> 00:15:14.406
an axis and angle of rotation.

00:15:14.666 --> 00:15:16.716
Or to put it another way, what

00:15:17.006 --> 00:15:18.386
are you rotating about and by

00:15:18.386 --> 00:15:18.956
how much.

00:15:19.696 --> 00:15:21.126
So we're going to rotate about

00:15:21.126 --> 00:15:22.506
the x axis, and we're going to

00:15:22.506 --> 00:15:26.426
rotate pi over 3 radians up.

00:15:27.706 --> 00:15:28.736
You apply the rotation by

00:15:28.736 --> 00:15:30.046
calling the simd act function.

00:15:31.476 --> 00:15:33.256
This applies the action of the

00:15:33.256 --> 00:15:34.326
quaternion on that vector and

00:15:34.326 --> 00:15:35.646
returns a rotated vector.

00:15:36.106 --> 00:15:37.786
So let's take a look at that

00:15:37.786 --> 00:15:37.946
now.

00:15:47.256 --> 00:15:48.566
So normally you're not

00:15:48.566 --> 00:15:49.846
interested in rotating along a

00:15:49.846 --> 00:15:50.626
single axis.

00:15:50.676 --> 00:15:51.856
You usually want to rotate along

00:15:51.856 --> 00:15:54.906
multiple axes, and if you're

00:15:54.906 --> 00:15:55.856
already familiar with rotation

00:15:55.856 --> 00:15:56.996
matrices, this is going to seem

00:15:56.996 --> 00:15:57.566
very natural.

00:16:00.186 --> 00:16:01.376
Like rotation matrices, you can

00:16:01.376 --> 00:16:02.426
combine the rotations using

00:16:02.426 --> 00:16:03.826
multiplication, and also like

00:16:03.826 --> 00:16:04.876
rotation matrices, the

00:16:04.876 --> 00:16:05.826
multiplication is not

00:16:05.866 --> 00:16:06.406
commutative.

00:16:06.936 --> 00:16:08.406
So this means if you change the

00:16:08.406 --> 00:16:09.366
order of the operands, you will

00:16:09.476 --> 00:16:10.206
change the order of the

00:16:10.206 --> 00:16:10.706
rotations.

00:16:11.846 --> 00:16:14.406
So effectively what we're going

00:16:14.406 --> 00:16:15.766
to do here is rotate pi over 3

00:16:15.766 --> 00:16:17.996
radians up, and then pi over 3

00:16:17.996 --> 00:16:18.826
radians to the right.

00:16:19.016 --> 00:16:19.906
And we're going to combine that

00:16:19.906 --> 00:16:20.916
into a single rotation.

00:16:26.136 --> 00:16:27.766
Some of the more interesting

00:16:27.766 --> 00:16:28.876
things you can actually do with

00:16:28.876 --> 00:16:30.136
quaternions and simd is

00:16:30.136 --> 00:16:31.756
interpolation, and we support

00:16:31.756 --> 00:16:33.186
two types of interpolation.

00:16:34.936 --> 00:16:35.876
The first is Slerp.

00:16:36.516 --> 00:16:39.106
It stands for Spherical Linear

00:16:39.106 --> 00:16:42.326
Interpolation, and there are

00:16:42.326 --> 00:16:44.206
actually two variants of it.

00:16:45.476 --> 00:16:48.926
We have simd slerp, which will

00:16:48.926 --> 00:16:49.886
find the shortest arc between

00:16:49.886 --> 00:16:51.266
these two points, in this case

00:16:51.306 --> 00:16:52.296
between the blue and the green,

00:16:53.276 --> 00:16:55.096
and we have simd slerp longest,

00:16:55.096 --> 00:16:56.196
which will find the longest arc.

00:16:56.196 --> 00:16:57.156
So you'll actually see it go

00:16:57.156 --> 00:16:57.976
behind the unit sphere.

00:17:07.195 --> 00:17:08.546
The second variant is Spline.

00:17:09.826 --> 00:17:11.126
Spline is really more useful if

00:17:11.126 --> 00:17:12.396
you have more than two

00:17:12.396 --> 00:17:12.996
rotations.

00:17:13.116 --> 00:17:14.066
So, for instance, here we're

00:17:14.066 --> 00:17:16.205
going to interpolate between an

00:17:16.205 --> 00:17:18.226
array of rotations, and there's

00:17:18.226 --> 00:17:19.256
quite a bit of boilerplate code

00:17:19.256 --> 00:17:20.526
here, so I want you to focus

00:17:20.526 --> 00:17:21.476
just on the Spline call.

00:17:23.695 --> 00:17:25.695
Effectively what we're doing is

00:17:25.695 --> 00:17:27.175
just iterating through all the

00:17:27.175 --> 00:17:28.465
individual rotations and

00:17:28.465 --> 00:17:28.946
applying Spline.

00:17:34.546 --> 00:17:35.516
So the thing you have to specify

00:17:35.516 --> 00:17:37.426
with Spline is not only the two

00:17:38.086 --> 00:17:39.136
rotations that you wish to

00:17:39.136 --> 00:17:40.696
interpolate between but also the

00:17:40.696 --> 00:17:42.176
previous and the next as well.

00:17:42.296 --> 00:17:44.856
And this is what this looks

00:17:44.856 --> 00:17:44.976
like.

00:17:52.076 --> 00:17:53.056
So if you're a game developer,

00:17:53.056 --> 00:17:54.146
you're probably not interested

00:17:54.146 --> 00:17:55.476
in rotating individual vectors.

00:17:55.476 --> 00:17:56.486
You're probably interested in

00:17:56.486 --> 00:17:57.286
rotating objects.

00:17:57.976 --> 00:17:58.766
So we have that for you.

00:17:58.906 --> 00:17:59.936
We have a cube.

00:18:00.396 --> 00:18:02.376
It's represented by multiple

00:18:02.376 --> 00:18:03.676
vectors, and it's going to go

00:18:03.676 --> 00:18:04.286
through a series of eight

00:18:04.286 --> 00:18:04.886
rotations.

00:18:05.486 --> 00:18:06.546
On the left, we're going to

00:18:06.546 --> 00:18:07.766
trace those rotations using

00:18:07.836 --> 00:18:09.166
Slerp, and on the right we're

00:18:09.166 --> 00:18:09.996
going to use Spline.

00:18:10.316 --> 00:18:11.406
So let me show you what Slerp

00:18:11.406 --> 00:18:11.836
looks like.

00:18:20.066 --> 00:18:20.676
And you can see because it's a

00:18:20.676 --> 00:18:21.826
linear interpolation, every

00:18:21.826 --> 00:18:23.306
single time it changes direction

00:18:23.356 --> 00:18:24.616
you get these sharp corners.

00:18:25.346 --> 00:18:26.576
Whereas if we look at Spline --

00:18:35.156 --> 00:18:35.846
Because it's aware of the

00:18:35.846 --> 00:18:37.446
previous and next rotation as

00:18:37.446 --> 00:18:38.426
well, you end up with these

00:18:38.426 --> 00:18:39.146
rounded corners.

00:18:39.736 --> 00:18:40.506
So let's see that again.

00:18:52.726 --> 00:18:53.466
So now I went through all those

00:18:53.466 --> 00:18:55.846
topics pretty quickly, so as a

00:18:55.846 --> 00:18:58.866
quick recap, we started by

00:18:58.866 --> 00:19:00.566
taking a look at vDSP, and we

00:19:00.566 --> 00:19:01.546
showed you two examples.

00:19:01.746 --> 00:19:02.786
The first was how to extract a

00:19:02.786 --> 00:19:04.776
signal from noise, and the

00:19:04.776 --> 00:19:06.136
second was how to remove certain

00:19:06.136 --> 00:19:07.276
types of artifacts from an

00:19:07.276 --> 00:19:07.586
image.

00:19:08.996 --> 00:19:10.606
We then took a look at simd, and

00:19:10.606 --> 00:19:11.456
I showed you how you can

00:19:11.456 --> 00:19:12.776
represent rotations in three

00:19:12.776 --> 00:19:13.996
dimensions using quaternions.

00:19:14.466 --> 00:19:16.196
I'm now going to pass off the

00:19:16.196 --> 00:19:17.216
presentation to my colleague,

00:19:17.216 --> 00:19:18.686
Luke Chang, who's going to show

00:19:18.686 --> 00:19:19.376
you some of the interesting

00:19:19.376 --> 00:19:20.376
things you can do with vImage.

00:19:21.516 --> 00:19:26.246
[ Applause ]

00:19:26.746 --> 00:19:27.356
>> Thank you, Matthew.

00:19:30.206 --> 00:19:30.916
Hello everyone.

00:19:31.276 --> 00:19:32.546
My name is Luke Chang.

00:19:32.546 --> 00:19:33.786
I'm an engineer in Vector and

00:19:33.786 --> 00:19:34.456
Numerics group.

00:19:35.226 --> 00:19:36.576
Today, I'm going to talk about

00:19:36.576 --> 00:19:39.176
vImage, what vImage offers, and

00:19:39.176 --> 00:19:41.086
how easy it is to use vImage in

00:19:41.086 --> 00:19:41.626
your apps.

00:19:41.816 --> 00:19:43.796
With just a few lines of code,

00:19:43.796 --> 00:19:45.836
you can create engaging video

00:19:45.836 --> 00:19:46.906
effects in your app.

00:19:47.446 --> 00:19:49.636
Let's get right to it.

00:19:50.876 --> 00:19:52.856
VImage is our image processing

00:19:52.856 --> 00:19:53.346
library.

00:19:53.816 --> 00:19:55.886
It has several components.

00:19:56.146 --> 00:19:58.386
The first component is the

00:19:58.386 --> 00:19:59.216
conversion function.

00:20:00.206 --> 00:20:01.746
Conversion function help you

00:20:02.636 --> 00:20:04.536
move image between different

00:20:04.536 --> 00:20:05.416
image formats.

00:20:06.486 --> 00:20:08.746
Different image formats have

00:20:08.746 --> 00:20:09.826
different advantages.

00:20:10.176 --> 00:20:13.296
For example, RGV format matches

00:20:13.296 --> 00:20:15.266
the pixels on your display, so

00:20:15.266 --> 00:20:16.216
it's best for the display.

00:20:17.166 --> 00:20:19.406
On the other hand, we have YCbCr

00:20:19.406 --> 00:20:21.946
image, which is similar to how

00:20:21.946 --> 00:20:23.396
human perceive the image.

00:20:24.026 --> 00:20:25.876
Human eyes recognize brightness,

00:20:26.286 --> 00:20:27.696
which is the luminance channel.

00:20:28.526 --> 00:20:30.096
Also, the color, which is the

00:20:30.096 --> 00:20:30.926
chrominance channel.

00:20:32.156 --> 00:20:35.196
Also, camera uses YCbCr format

00:20:35.196 --> 00:20:36.346
to capture images.

00:20:37.066 --> 00:20:39.426
So converging function helps you

00:20:39.426 --> 00:20:41.156
easily move images between these

00:20:41.156 --> 00:20:41.636
formats.

00:20:43.726 --> 00:20:45.586
Next, we have geometry function.

00:20:46.956 --> 00:20:48.676
Geometry function changes the

00:20:48.676 --> 00:20:50.966
size or orientation of the

00:20:50.966 --> 00:20:51.466
image.

00:20:52.176 --> 00:20:54.936
We have vImage scale that can do

00:20:54.936 --> 00:20:56.756
enlarge or shrink the image.

00:20:57.476 --> 00:20:59.466
We use Lanczos algorithm, so

00:20:59.606 --> 00:21:01.416
we'll have high-quality output

00:21:01.606 --> 00:21:02.666
after the operation.

00:21:03.366 --> 00:21:06.186
We also have vImage rotate that

00:21:06.186 --> 00:21:07.826
can rotate image clockwise or

00:21:07.826 --> 00:21:08.906
counterclockwise.

00:21:09.346 --> 00:21:13.016
Next, convolution function.

00:21:13.486 --> 00:21:15.616
The most notable effect of

00:21:15.616 --> 00:21:17.576
convolution function is the blur

00:21:17.576 --> 00:21:17.846
effect.

00:21:18.836 --> 00:21:20.296
You see blur effect all the

00:21:20.296 --> 00:21:23.116
time, in UI, in photography.

00:21:23.326 --> 00:21:25.086
If you want to phase something

00:21:25.086 --> 00:21:26.656
into the background, you can

00:21:26.656 --> 00:21:28.576
apply the blur function, blur

00:21:29.986 --> 00:21:30.156
effect.

00:21:31.126 --> 00:21:32.786
Next, transform function.

00:21:33.796 --> 00:21:35.616
Transform function is basically

00:21:35.616 --> 00:21:36.786
a matrix multiply.

00:21:37.446 --> 00:21:39.346
It lets you operate on the data

00:21:39.346 --> 00:21:40.586
channel of each pixel.

00:21:41.256 --> 00:21:42.576
Let's say you want to increase

00:21:42.576 --> 00:21:44.736
red or increase green, you can

00:21:44.736 --> 00:21:46.016
do that with transform

00:21:46.016 --> 00:21:46.566
functions.

00:21:48.196 --> 00:21:49.426
Morphology.

00:21:50.456 --> 00:21:52.926
Morphology changes the size or

00:21:52.926 --> 00:21:54.866
shape of the objects in the

00:21:54.866 --> 00:21:56.926
image, not the image itself.

00:21:57.916 --> 00:22:00.646
We have vImage erode, vImage

00:22:00.646 --> 00:22:02.566
dilate to make the object

00:22:02.566 --> 00:22:04.016
smaller and bigger.

00:22:04.856 --> 00:22:06.996
If you're feeling adventurous,

00:22:06.996 --> 00:22:08.506
you can actually provide a

00:22:08.506 --> 00:22:10.336
custom shape of kernels to these

00:22:10.336 --> 00:22:13.126
functions, and vImage erode and

00:22:13.126 --> 00:22:15.436
dilate will make the object

00:22:15.436 --> 00:22:17.246
smaller or bigger according to

00:22:17.246 --> 00:22:18.396
the kernel you provided.

00:22:20.406 --> 00:22:21.986
Those are the five things in

00:22:21.986 --> 00:22:22.576
vImage.

00:22:22.786 --> 00:22:24.626
Now, I want to show you a demo

00:22:24.626 --> 00:22:26.256
app that we wrote based on

00:22:26.256 --> 00:22:28.096
vImage and show you what kind of

00:22:28.096 --> 00:22:28.976
effect you can get from vImage.

00:22:34.046 --> 00:22:35.566
What I have here is a lab that

00:22:35.606 --> 00:22:37.496
captures images using the back

00:22:37.496 --> 00:22:40.936
camera and put the image onto

00:22:40.936 --> 00:22:41.456
the screen.

00:22:42.466 --> 00:22:44.656
And we're doing in real-time.

00:22:44.656 --> 00:22:45.956
This is a live stream, so you

00:22:45.956 --> 00:22:47.666
can see the drinking bird doing

00:22:47.666 --> 00:22:49.696
its motion next to the roses.

00:22:50.656 --> 00:22:51.806
All right, the first effect I

00:22:51.806 --> 00:22:53.206
want to show you is the color

00:22:53.206 --> 00:22:54.256
saturation effect.

00:22:54.856 --> 00:22:57.246
You can see this effect in a lot

00:22:57.246 --> 00:22:59.406
of photo editing software.

00:23:00.136 --> 00:23:01.676
So I want to bring out the

00:23:01.676 --> 00:23:02.316
color.

00:23:02.586 --> 00:23:04.826
What I can do is move this

00:23:04.826 --> 00:23:09.576
slider to the right to make the

00:23:09.576 --> 00:23:11.586
red really red and green really

00:23:11.586 --> 00:23:11.866
green.

00:23:13.646 --> 00:23:15.706
And on the other side, I have

00:23:15.706 --> 00:23:16.666
white roses.

00:23:17.366 --> 00:23:20.066
I feel that the color of white

00:23:20.066 --> 00:23:21.346
roses is not that interesting to

00:23:21.346 --> 00:23:21.636
me.

00:23:21.636 --> 00:23:23.136
I would like to direct the focus

00:23:23.136 --> 00:23:24.916
of my audience to the

00:23:24.916 --> 00:23:27.426
composition and the contrast of

00:23:27.426 --> 00:23:28.056
this image.

00:23:28.996 --> 00:23:32.386
I can slide to the left to

00:23:32.386 --> 00:23:36.376
desaturate the image to the

00:23:36.376 --> 00:23:38.586
point that this becomes a black

00:23:38.586 --> 00:23:39.406
and white image.

00:23:39.906 --> 00:23:41.636
So now color is no more

00:23:41.636 --> 00:23:43.596
distraction in this image, and

00:23:43.696 --> 00:23:45.126
the viewer can focus on the

00:23:45.126 --> 00:23:46.826
composition and contrast.

00:23:48.266 --> 00:23:50.976
Okay. So, how do we do this?

00:23:56.046 --> 00:23:57.116
There are several steps we need

00:23:57.116 --> 00:23:57.536
to take.

00:23:57.876 --> 00:24:00.246
First, of course, we have to get

00:24:00.306 --> 00:24:02.186
the image from the camera, and

00:24:03.476 --> 00:24:05.836
then we want to use vImage to

00:24:05.836 --> 00:24:08.746
process, to apply the effect, so

00:24:08.746 --> 00:24:10.436
we have to prepare the input and

00:24:10.436 --> 00:24:12.036
output buffer for vImage.

00:24:13.456 --> 00:24:15.576
Then we actually calling vImage

00:24:15.576 --> 00:24:16.756
functions to apply these

00:24:16.756 --> 00:24:19.936
effects, and we display the

00:24:19.936 --> 00:24:21.186
output to the screen.

00:24:22.046 --> 00:24:25.286
Let me jump ahead and talk about

00:24:25.286 --> 00:24:27.006
how do we apply effects using

00:24:27.006 --> 00:24:27.956
vImage functions.

00:24:29.076 --> 00:24:32.096
The effect I show you is a color

00:24:32.096 --> 00:24:34.306
saturation effect, and here is

00:24:34.306 --> 00:24:35.966
the formula to do color

00:24:35.966 --> 00:24:36.616
saturation.

00:24:37.426 --> 00:24:38.886
Basically, we want to remove the

00:24:38.886 --> 00:24:41.886
bias from the pixel, and using

00:24:41.886 --> 00:24:43.376
multiplication to apply the

00:24:43.376 --> 00:24:46.746
saturation effects, and then we

00:24:46.746 --> 00:24:48.326
put the bias back to the pixel.

00:24:49.686 --> 00:24:51.786
VImage has exactly the function

00:24:51.786 --> 00:24:54.116
to do this operation, which is

00:24:54.496 --> 00:24:55.956
vImage matrix multiply.

00:24:58.246 --> 00:25:00.206
VImage matrix multiply takes the

00:25:00.206 --> 00:25:03.476
preBias, in this case minus 128,

00:25:03.766 --> 00:25:06.786
to remove the bias, and because

00:25:06.786 --> 00:25:08.276
the saturation is [inaudible]

00:25:08.276 --> 00:25:10.466
point and the image is an

00:25:10.466 --> 00:25:13.046
integer, we want to convert this

00:25:13.046 --> 00:25:14.746
saturation value first into

00:25:14.746 --> 00:25:15.806
fixed point format.

00:25:16.366 --> 00:25:18.256
We chose Q12 as the fixed point

00:25:18.256 --> 00:25:20.026
format, hence a divisor of

00:25:20.026 --> 00:25:21.236
0x100.

00:25:21.776 --> 00:25:24.086
And then we have the postBias

00:25:24.086 --> 00:25:26.336
128 times the divisor, just to

00:25:26.336 --> 00:25:27.796
put the bias back to the pixel.

00:25:28.336 --> 00:25:32.036
And the matrix itself is really,

00:25:32.036 --> 00:25:32.626
really simple.

00:25:33.136 --> 00:25:35.006
All we want to do is just doing

00:25:35.006 --> 00:25:37.246
a scaling of CbCr channel.

00:25:37.546 --> 00:25:39.016
So the matrix itself is just a

00:25:39.016 --> 00:25:42.026
scaler, want to multiply CbCr

00:25:42.026 --> 00:25:43.966
channel with this scaler.

00:25:44.836 --> 00:25:47.126
We have all the information, so

00:25:47.126 --> 00:25:49.026
let's call vImageMatrixMultiply,

00:25:49.906 --> 00:25:51.906
and with just one line of code,

00:25:51.906 --> 00:25:53.606
one function call, you can

00:25:53.666 --> 00:25:56.126
achieve the saturation effect.

00:25:56.906 --> 00:25:58.616
Now let me come back to other

00:25:58.616 --> 00:25:59.746
steps that we need to take.

00:26:01.226 --> 00:26:03.256
We need to take the image from

00:26:03.256 --> 00:26:03.726
the camera.

00:26:04.036 --> 00:26:06.516
How do we do that?

00:26:06.556 --> 00:26:07.546
We need to write a delegate

00:26:07.546 --> 00:26:10.616
method, and what camera gives us

00:26:10.616 --> 00:26:12.246
is a CV image buffer.

00:26:13.376 --> 00:26:14.806
So we get the buffer.

00:26:14.806 --> 00:26:17.706
We have to make sure this buffer

00:26:17.706 --> 00:26:19.586
is accessible to CPU.

00:26:19.956 --> 00:26:21.186
That's where vImage lives.

00:26:21.806 --> 00:26:24.196
After we apply the effects,

00:26:24.676 --> 00:26:26.026
whatever effects that may be,

00:26:26.426 --> 00:26:28.416
and we have to unlock the base

00:26:28.416 --> 00:26:31.066
address of this pixel buffer so

00:26:31.066 --> 00:26:32.736
that the camera can reuse this

00:26:32.736 --> 00:26:33.386
piece of memory.

00:26:36.556 --> 00:26:38.236
The second step, we have to

00:26:38.236 --> 00:26:40.116
prepare the vImage input and

00:26:40.116 --> 00:26:40.706
output buffer.

00:26:43.276 --> 00:26:45.486
We already have this image in CV

00:26:45.546 --> 00:26:46.616
image buffer.

00:26:46.736 --> 00:26:48.676
All we need to do is just get

00:26:48.676 --> 00:26:50.696
the information such as height

00:26:51.336 --> 00:26:54.206
and width, and then we can

00:26:54.366 --> 00:26:55.856
package this into a vImage

00:26:55.856 --> 00:26:57.906
buffer object so it can be

00:26:57.906 --> 00:26:59.376
consumed by vImage library.

00:26:59.806 --> 00:27:01.346
We do this for luminance and

00:27:01.346 --> 00:27:02.046
chrominance channel.

00:27:03.586 --> 00:27:05.256
Now we need to prepare an output

00:27:05.256 --> 00:27:05.566
buffer.

00:27:06.596 --> 00:27:08.496
Remember, we don't have a piece

00:27:08.496 --> 00:27:09.796
of memory allocated to the

00:27:09.796 --> 00:27:11.736
output image yet, so we need to

00:27:11.736 --> 00:27:13.776
do that, and vImage has a

00:27:13.776 --> 00:27:15.446
convenience function, vImage

00:27:15.446 --> 00:27:18.116
buffer in it, to do just that.

00:27:18.756 --> 00:27:21.196
Given this height, width, and

00:27:21.646 --> 00:27:24.906
bits per pixel, vImage buffer in

00:27:24.906 --> 00:27:26.626
it will allocate a memory that's

00:27:26.626 --> 00:27:27.936
large enough to hold this image

00:27:28.016 --> 00:27:29.516
and then also create a vImage

00:27:29.556 --> 00:27:31.486
buffer object so it can be

00:27:31.486 --> 00:27:33.286
consumed by the vImage library.

00:27:33.756 --> 00:27:38.466
Last step is put this process

00:27:38.856 --> 00:27:40.076
image to the screen.

00:27:40.556 --> 00:27:46.596
Like I said before, RGB is

00:27:46.596 --> 00:27:47.656
really the best format for

00:27:47.656 --> 00:27:49.456
display, so let's use the

00:27:49.456 --> 00:27:51.296
conversion function to convert

00:27:51.296 --> 00:27:54.016
YCbCr image into a RGB image.

00:27:54.316 --> 00:27:56.906
And then because the UI expect

00:27:56.906 --> 00:27:59.196
the cgImage object, we have to

00:27:59.196 --> 00:27:59.856
create one.

00:28:00.206 --> 00:28:02.776
There is a convenience function

00:28:02.776 --> 00:28:03.296
in vImage.

00:28:03.356 --> 00:28:06.606
vImageCreatesCGImage FromBuffer

00:28:07.566 --> 00:28:09.606
that helps you to create a

00:28:09.606 --> 00:28:11.286
cgImage based on the buffer you

00:28:11.286 --> 00:28:12.596
already have in vImage.

00:28:13.896 --> 00:28:15.566
One thing to note is that we're

00:28:15.566 --> 00:28:17.706
not actually copying the large

00:28:17.706 --> 00:28:19.636
data buffer in the image from

00:28:19.636 --> 00:28:20.726
one place to another.

00:28:21.206 --> 00:28:23.426
We're simply creating a cgImage

00:28:23.426 --> 00:28:25.956
object that adds a container to

00:28:25.956 --> 00:28:27.306
this image buffer.

00:28:28.216 --> 00:28:29.876
So we are only filling in the

00:28:29.876 --> 00:28:31.716
information that cgImage needs,

00:28:31.716 --> 00:28:33.576
create a cgImage objects,

00:28:33.716 --> 00:28:35.966
instead of copying data around.

00:28:36.556 --> 00:28:39.136
Once we have that, we can send

00:28:39.136 --> 00:28:41.456
the cgImage object to the image

00:28:41.456 --> 00:28:43.616
view, and it will be displayed

00:28:43.706 --> 00:28:44.406
on the screen.

00:28:45.016 --> 00:28:45.796
So it's that simple.

00:28:46.286 --> 00:28:48.146
Four steps and you can create

00:28:48.146 --> 00:28:50.626
your own effects, we show you

00:28:50.626 --> 00:28:51.656
the saturation effects.

00:28:52.026 --> 00:28:54.736
Now, there are other effects we

00:28:54.736 --> 00:28:56.166
can do with vImage.

00:28:56.816 --> 00:28:59.116
We can do a rotation, like I

00:28:59.116 --> 00:29:00.716
said before, rotate the image

00:29:00.916 --> 00:29:02.946
clockwise, counterclockwise.

00:29:03.336 --> 00:29:05.736
We can do blur or phase

00:29:05.736 --> 00:29:07.026
something into the background.

00:29:07.536 --> 00:29:10.966
And you feel, if you feel like

00:29:10.966 --> 00:29:12.136
you want to add some retro

00:29:12.136 --> 00:29:13.716
feeling to your images, you can

00:29:13.716 --> 00:29:15.376
do dithering for black and white

00:29:15.376 --> 00:29:18.026
images, and color quantization

00:29:18.206 --> 00:29:19.226
for color images.

00:29:20.066 --> 00:29:21.436
Let me show you how they look

00:29:21.436 --> 00:29:22.976
like in the app.

00:29:36.536 --> 00:29:38.346
So, again, I have the slider

00:29:38.346 --> 00:29:40.156
here to control the rotation.

00:29:40.916 --> 00:29:44.346
I can do rotate counterclockwise

00:29:45.976 --> 00:29:48.586
or rotate clockwise.

00:29:49.146 --> 00:29:52.866
Now I want to try the blurring

00:29:52.866 --> 00:29:53.206
effect.

00:29:53.556 --> 00:29:55.016
Let me click on the one here.

00:29:56.026 --> 00:30:01.246
And I can apply more blurring or

00:30:01.856 --> 00:30:04.116
slide to the left, bring the

00:30:04.116 --> 00:30:05.796
roses back to the foreground.

00:30:07.756 --> 00:30:10.726
For black and white, I can use

00:30:11.596 --> 00:30:11.796
dithering.

00:30:12.316 --> 00:30:14.916
Now this black and white image,

00:30:15.066 --> 00:30:16.846
the gray scale is represented

00:30:16.846 --> 00:30:18.666
now by the density of the dots,

00:30:18.886 --> 00:30:19.976
that's the dithering effect.

00:30:20.156 --> 00:30:21.766
And we use the accents and

00:30:21.916 --> 00:30:24.146
dithering algorithm for this,

00:30:24.206 --> 00:30:25.326
and I will show you how to do it

00:30:25.326 --> 00:30:28.076
later, and for color

00:30:28.076 --> 00:30:29.766
quantization, we have lookup

00:30:29.766 --> 00:30:30.126
table.

00:30:30.446 --> 00:30:32.626
And I can move this slider to

00:30:32.626 --> 00:30:34.186
increase the quantization level.

00:30:34.426 --> 00:30:35.996
As I move the slider to the

00:30:35.996 --> 00:30:39.006
right, fewer and fewer color is

00:30:39.006 --> 00:30:40.646
available in this image.

00:30:41.386 --> 00:30:44.766
That's sort of creative, that's

00:30:44.766 --> 00:30:46.616
how your computer screen looks

00:30:46.616 --> 00:30:49.706
like in the '90's or in the

00:30:49.886 --> 00:30:49.996
'80's.

00:30:50.486 --> 00:30:50.936
All right.

00:30:51.286 --> 00:30:54.306
So let me show you how we do

00:30:54.306 --> 00:30:54.516
that.

00:30:58.536 --> 00:30:59.836
For rotation effect, you can

00:30:59.836 --> 00:31:03.036
call vImageRotate and given the

00:31:03.036 --> 00:31:05.006
angle of rotation, it will do

00:31:05.006 --> 00:31:06.726
counterclockwise or clockwise to

00:31:06.726 --> 00:31:07.956
better align your images.

00:31:09.276 --> 00:31:11.766
For the blur effect, we use

00:31:11.846 --> 00:31:12.536
TentConvolve.

00:31:13.676 --> 00:31:15.066
The blur effect is controlled by

00:31:15.066 --> 00:31:15.976
the size of the kernel.

00:31:16.446 --> 00:31:18.086
The larger the kernel, the more

00:31:18.086 --> 00:31:19.746
blur you'll get.

00:31:20.916 --> 00:31:22.996
Dither effect is basically

00:31:22.996 --> 00:31:25.276
converting an 8-bit image into a

00:31:25.276 --> 00:31:26.116
1-bit image.

00:31:26.306 --> 00:31:27.446
At the same time, you can

00:31:27.446 --> 00:31:29.146
specify a dithering algorithm.

00:31:29.736 --> 00:31:30.886
In this case, we used the

00:31:30.966 --> 00:31:32.526
Atkinson dithering algorithm.

00:31:33.016 --> 00:31:37.646
Color quantization, we used the

00:31:37.646 --> 00:31:39.706
quantization level to create a

00:31:39.706 --> 00:31:41.536
lookup table for the RGB

00:31:41.536 --> 00:31:43.976
channel, and we call

00:31:44.076 --> 00:31:46.596
vImageTableLookUp to apply this

00:31:46.596 --> 00:31:48.806
table lookup to RGB channels to

00:31:48.966 --> 00:31:50.476
limit the number of colors on

00:31:50.476 --> 00:31:50.816
the screen.

00:31:52.106 --> 00:31:55.606
Those are the four additional

00:31:55.606 --> 00:31:56.796
effects I wanted to show you,

00:31:57.106 --> 00:31:59.416
and I think now is a good time

00:31:59.416 --> 00:32:00.986
to move onto the next topic.

00:32:01.616 --> 00:32:05.446
LINPACK Benchmark.

00:32:06.076 --> 00:32:07.866
We talked about the

00:32:07.866 --> 00:32:09.426
functionality of Accelerate.

00:32:09.986 --> 00:32:12.026
We talk about how easy it is to

00:32:12.026 --> 00:32:13.616
use in Accelerate in your apps.

00:32:14.456 --> 00:32:16.456
We haven't talked about how fast

00:32:16.456 --> 00:32:17.766
Accelerate really is.

00:32:18.676 --> 00:32:20.026
And LINPACK Benchmark is a

00:32:20.026 --> 00:32:23.326
perfect tool to do that.

00:32:23.526 --> 00:32:24.706
What is LINPACK Benchmark?

00:32:25.796 --> 00:32:26.826
Basically, it's trying to

00:32:26.826 --> 00:32:28.956
measure how fast you can solve a

00:32:28.956 --> 00:32:30.446
linear system on your machine.

00:32:31.816 --> 00:32:32.586
There are actually three

00:32:32.586 --> 00:32:34.526
different LINPACK Benchmarks.

00:32:34.686 --> 00:32:36.136
The first one is solving a

00:32:36.136 --> 00:32:37.916
100-by-100 linear system.

00:32:38.516 --> 00:32:40.086
The second one is solving a

00:32:40.086 --> 00:32:41.356
1000-by-1000.

00:32:41.706 --> 00:32:44.526
The last one, which is the most

00:32:44.526 --> 00:32:46.286
interesting one, that's the one

00:32:46.286 --> 00:32:48.236
we're going to use today, is no

00:32:48.236 --> 00:32:48.776
holds barred.

00:32:49.216 --> 00:32:50.856
You can solve as large a system

00:32:50.856 --> 00:32:53.486
you want to fully utilize every

00:32:53.486 --> 00:32:54.906
last bit of the computational

00:32:54.906 --> 00:32:55.996
power on your machine.

00:32:56.496 --> 00:32:59.136
Let's see the performance of

00:32:59.436 --> 00:33:01.646
iPhone X using Accelerate.

00:33:02.816 --> 00:33:04.376
The performance is measured in

00:33:04.376 --> 00:33:08.226
gigaflops, for double precisions

00:33:08.226 --> 00:33:11.696
catch up with iPhone 5S, iPhone

00:33:11.696 --> 00:33:18.906
6, iPhone 6S, iPhone 7, iPhone X

00:33:18.906 --> 00:33:21.786
comes in around 28.7 gigaflops.

00:33:22.346 --> 00:33:23.456
That's double precision.

00:33:23.906 --> 00:33:25.346
Let's look at single precision.

00:33:26.776 --> 00:33:32.086
Again, we run out of space, we

00:33:32.086 --> 00:33:33.646
have to shrink to try to make it

00:33:33.686 --> 00:33:34.736
come closer.

00:33:36.226 --> 00:33:40.796
IPhone X comes in at 68

00:33:40.796 --> 00:33:41.526
gigaflops.

00:33:42.776 --> 00:33:44.936
Now you might be thinking, this

00:33:44.936 --> 00:33:46.416
is not that surprising.

00:33:47.246 --> 00:33:48.826
However, it improves over time,

00:33:48.826 --> 00:33:50.816
so the performance improves over

00:33:50.816 --> 00:33:53.296
time as well, but in fact,

00:33:53.756 --> 00:33:55.156
that's only half of the story.

00:33:55.586 --> 00:33:57.496
When there is a micro

00:33:57.496 --> 00:33:58.676
architecture change to have

00:33:58.676 --> 00:34:00.316
additional computational power

00:34:00.316 --> 00:34:02.146
into a machine, you need the

00:34:02.146 --> 00:34:03.456
matching [inaudible] to fully

00:34:03.456 --> 00:34:05.086
utilize this additional

00:34:05.086 --> 00:34:05.956
computational power.

00:34:06.726 --> 00:34:07.936
And that is where we come in.

00:34:09.016 --> 00:34:11.056
Remember, this is the same

00:34:11.056 --> 00:34:12.786
LINPACK Benchmark executable

00:34:13.275 --> 00:34:15.076
running on all five generations

00:34:15.076 --> 00:34:15.976
of iPhones.

00:34:16.505 --> 00:34:17.496
They all got the best

00:34:17.496 --> 00:34:19.005
performance using Accelerate

00:34:20.326 --> 00:34:22.806
without changing a bit.

00:34:23.386 --> 00:34:24.656
The same is also true for your

00:34:24.656 --> 00:34:25.076
apps.

00:34:25.636 --> 00:34:27.545
If you use Accelerate in your

00:34:27.545 --> 00:34:29.315
apps, you'll get the best

00:34:29.315 --> 00:34:32.795
performance automatically on all

00:34:32.795 --> 00:34:34.096
the architectures we support.

00:34:35.416 --> 00:34:38.786
Moreover, Accelerate supports

00:34:39.016 --> 00:34:40.386
across platforms.

00:34:41.065 --> 00:34:43.525
Accelerate works on macOS, iOS,

00:34:43.806 --> 00:34:45.456
tvOS, watchOS.

00:34:47.315 --> 00:34:48.996
So let's say if tomorrow Apple

00:34:48.996 --> 00:34:49.946
comes out with a new

00:34:49.946 --> 00:34:51.996
architecture or new platform,

00:34:52.485 --> 00:34:53.436
you don't have to worry about

00:34:53.436 --> 00:34:53.636
it.

00:34:54.505 --> 00:34:56.606
All you need to do, the most

00:34:56.606 --> 00:34:58.596
you'll ever need to do is just

00:34:58.596 --> 00:35:00.256
to rebuild your apps, link

00:35:00.256 --> 00:35:01.406
against Accelerate.

00:35:01.806 --> 00:35:03.306
You will automatically get the

00:35:03.306 --> 00:35:05.706
best performance on the latest

00:35:05.776 --> 00:35:07.036
release platform or

00:35:07.036 --> 00:35:07.606
architecture.

00:35:08.096 --> 00:35:14.866
Just as a summary, we talk about

00:35:14.866 --> 00:35:16.446
Accelerate supports a wide

00:35:16.446 --> 00:35:18.026
variety of functionalities.

00:35:18.816 --> 00:35:20.166
More than likely, you will find

00:35:20.226 --> 00:35:21.036
something you need in

00:35:21.036 --> 00:35:21.706
Accelerate.

00:35:22.106 --> 00:35:23.936
If you need something that's not

00:35:23.936 --> 00:35:25.616
available, please feel free to

00:35:25.616 --> 00:35:27.036
file feature requests.

00:35:27.426 --> 00:35:29.126
We constantly look at this

00:35:29.126 --> 00:35:31.056
feature request, evaluate them,

00:35:31.136 --> 00:35:32.246
and then put into builds.

00:35:32.846 --> 00:35:34.666
Actually, some of our best

00:35:34.666 --> 00:35:36.696
features come from feature

00:35:36.696 --> 00:35:37.286
requests.

00:35:38.716 --> 00:35:40.576
Accelerate is easy to use.

00:35:40.986 --> 00:35:42.646
Most of the time it's just one

00:35:42.646 --> 00:35:43.916
function call and the job is

00:35:43.916 --> 00:35:44.106
done.

00:35:45.516 --> 00:35:47.566
It's fast and energy efficient,

00:35:48.216 --> 00:35:50.226
so your app is more responsive

00:35:50.506 --> 00:35:52.516
and the battery life is longer.

00:35:53.866 --> 00:35:55.486
Accelerate is portable across

00:35:55.486 --> 00:35:57.336
platforms and architectures.

00:35:57.636 --> 00:35:59.196
You get the best performance on

00:35:59.196 --> 00:36:01.676
all the platforms we support and

00:36:01.716 --> 00:36:02.906
all the architectures we

00:36:02.906 --> 00:36:05.326
support, and the best part is,

00:36:05.476 --> 00:36:07.776
you don't have to change your

00:36:08.676 --> 00:36:08.796
code.

00:36:09.126 --> 00:36:10.526
For more information, you can go

00:36:10.526 --> 00:36:12.376
to our online documentation at

00:36:12.376 --> 00:36:15.266
developer.apple.com, and all our

00:36:15.706 --> 00:36:17.506
demo apps, simple code, and

00:36:17.536 --> 00:36:18.556
session material will be

00:36:18.556 --> 00:36:19.616
available online.

00:36:20.646 --> 00:36:22.266
We have a lab session tomorrow

00:36:22.266 --> 00:36:23.486
afternoon at 2.

00:36:24.236 --> 00:36:25.196
I look forward to seeing you

00:36:25.196 --> 00:36:26.036
guys there.

00:36:26.036 --> 00:36:27.956
If you have any questions or you

00:36:27.956 --> 00:36:28.956
want to learn more about

00:36:28.956 --> 00:36:31.106
Accelerate, I'd love to see you

00:36:31.106 --> 00:36:31.286
there.

00:36:33.116 --> 00:36:34.716
That's all for our presentation

00:36:34.716 --> 00:36:35.096
today.

00:36:35.096 --> 00:36:36.176
Thank you all for coming.

00:36:36.376 --> 00:36:36.976
Have a great day.

00:36:37.516 --> 00:36:40.500
[ Applause ]
WEBVTT

00:00:07.516 --> 00:00:20.516
[ Music ]

00:00:21.516 --> 00:00:27.546
[ Applause ]

00:00:28.046 --> 00:00:29.076
>> Good morning, welcome to

00:00:29.116 --> 00:00:30.116
What's New in LLVM.

00:00:31.136 --> 00:00:32.406
I'm Jim Grosbach, your friendly

00:00:32.406 --> 00:00:33.766
neighborhood pointy hair boss.

00:00:34.036 --> 00:00:35.536
I'm here to tell you a little

00:00:35.536 --> 00:00:37.966
bit of background about the LLVM

00:00:37.966 --> 00:00:40.066
project before we dive into the

00:00:40.066 --> 00:00:41.296
deep technical details of all

00:00:41.296 --> 00:00:43.296
the exciting new things that we

00:00:43.296 --> 00:00:44.306
have for you today.

00:00:45.426 --> 00:00:48.276
Start off, LLVM is more than

00:00:48.276 --> 00:00:50.916
just the compiler, it is the

00:00:50.916 --> 00:00:52.736
background for the Clang

00:00:52.736 --> 00:00:54.096
compiler, for the C family of

00:00:54.096 --> 00:00:55.706
languages that we all use every

00:00:55.706 --> 00:00:57.596
day, but it also powers the

00:00:57.596 --> 00:01:00.316
Static Analyzer, the sanitizers,

00:01:00.316 --> 00:01:03.216
the LLDB debugger, and is the

00:01:03.216 --> 00:01:04.726
optimization code generation

00:01:04.726 --> 00:01:06.616
framework underneath the GPU

00:01:06.616 --> 00:01:08.576
shader compilers for all of

00:01:08.576 --> 00:01:11.166
Apple's mobile platforms.

00:01:12.016 --> 00:01:13.396
In addition to this, it also

00:01:13.396 --> 00:01:15.806
powers one additional little

00:01:15.806 --> 00:01:17.726
project that you may have heard

00:01:17.726 --> 00:01:19.036
of from time to time called

00:01:19.036 --> 00:01:19.676
Swift.

00:01:21.016 --> 00:01:23.906
And like Swift LLVM is an open

00:01:23.906 --> 00:01:24.906
source project.

00:01:26.456 --> 00:01:27.696
We all operate under the

00:01:27.696 --> 00:01:30.276
watchful eye of our LLVM wyvern

00:01:30.276 --> 00:01:31.916
here, he's normally a very

00:01:31.916 --> 00:01:33.586
friendly fellow, though I do

00:01:33.586 --> 00:01:34.776
have to caution you he gets a

00:01:34.776 --> 00:01:36.456
little bit cranky if you call

00:01:36.456 --> 00:01:38.176
him a dragon so don't do that.

00:01:39.596 --> 00:01:42.296
As an open source project LLVM

00:01:42.296 --> 00:01:44.996
is a partnership, we work with

00:01:44.996 --> 00:01:47.186
industry partners, academics,

00:01:47.246 --> 00:01:49.356
researchers and hobbyists from

00:01:49.596 --> 00:01:51.166
all over the world and in

00:01:51.166 --> 00:01:53.106
different parts of the industry

00:01:53.756 --> 00:01:55.826
and many more all over the

00:01:55.866 --> 00:01:56.396
place.

00:01:56.646 --> 00:01:58.036
This is really fantastic, we

00:01:58.396 --> 00:01:59.576
work together to build the

00:01:59.576 --> 00:02:01.646
greatest tools that we possibly

00:02:01.646 --> 00:02:03.806
can to move technology forward.

00:02:04.906 --> 00:02:07.686
And if you ever have a compiler

00:02:07.686 --> 00:02:08.895
itch that you would like to

00:02:08.895 --> 00:02:10.735
scratch we would like to invite

00:02:10.735 --> 00:02:13.396
you to participate with us and

00:02:13.396 --> 00:02:15.146
go to the LLVM website here at

00:02:15.146 --> 00:02:17.986
llvm.org or you can come talk to

00:02:17.986 --> 00:02:19.716
us later today later today in

00:02:19.716 --> 00:02:21.906
the LLVM labs and many of our

00:02:21.906 --> 00:02:23.446
compiler engineers from Apple

00:02:23.446 --> 00:02:25.066
will be there and I'm sure will

00:02:25.066 --> 00:02:27.506
be more than happy to talk your

00:02:27.506 --> 00:02:28.786
ear off about anything and

00:02:28.786 --> 00:02:30.136
everything compiler related

00:02:30.476 --> 00:02:31.646
you've ever wanted to know.

00:02:32.666 --> 00:02:36.096
So for today we have a great set

00:02:36.096 --> 00:02:37.306
of things that we want to share

00:02:37.306 --> 00:02:37.656
with you.

00:02:37.656 --> 00:02:39.476
We have updates on automated

00:02:39.476 --> 00:02:40.766
reference counting that makes it

00:02:40.766 --> 00:02:42.826
even easier for the compiler to

00:02:42.826 --> 00:02:43.876
help you with your memory

00:02:43.876 --> 00:02:44.466
management.

00:02:44.786 --> 00:02:47.146
We have new diagnostics in Xcode

00:02:47.206 --> 00:02:49.266
10 and new checks in the Static

00:02:49.266 --> 00:02:51.536
Analyzer to help catch bugs in

00:02:51.536 --> 00:02:53.536
your project sooner at build

00:02:53.536 --> 00:02:55.646
time to improve the quality of

00:02:55.646 --> 00:02:56.376
your code.

00:02:56.786 --> 00:02:58.116
We have compiler features that

00:02:58.116 --> 00:02:59.526
improve security, both of

00:02:59.526 --> 00:03:01.446
Apple's platforms and of your

00:03:01.446 --> 00:03:01.966
apps.

00:03:02.336 --> 00:03:04.506
And new features to allow you to

00:03:04.506 --> 00:03:06.446
take advantage of all of the

00:03:06.446 --> 00:03:08.186
really great new things on the

00:03:08.186 --> 00:03:09.866
hardware architectures to get

00:03:09.866 --> 00:03:11.696
the performance that we all want

00:03:12.026 --> 00:03:13.276
out of our platforms and

00:03:13.276 --> 00:03:14.016
architectures.

00:03:14.786 --> 00:03:16.126
So with that I would like to

00:03:16.126 --> 00:03:18.366
invite my colleague Alex up to

00:03:18.646 --> 00:03:19.806
talk about ARC.

00:03:20.476 --> 00:03:20.886
Alex.

00:03:21.516 --> 00:03:27.546
[ Applause ]

00:03:28.046 --> 00:03:28.676
>> Thank you, Jim.

00:03:29.696 --> 00:03:31.736
Automatic reference counting has

00:03:31.736 --> 00:03:33.956
greatly simplified Objective-C

00:03:33.956 --> 00:03:36.196
program since we introduced it a

00:03:36.196 --> 00:03:37.216
couple of years ago.

00:03:38.106 --> 00:03:40.016
A couple of restrictions made it

00:03:40.016 --> 00:03:42.066
harder to migrate from the old

00:03:42.376 --> 00:03:44.416
manual retain release mode over

00:03:44.416 --> 00:03:44.926
to ARC.

00:03:45.576 --> 00:03:46.866
I'm happy to say that we've now

00:03:46.866 --> 00:03:48.416
lifted one such restriction.

00:03:49.056 --> 00:03:50.496
Xcode 10 has support for ARC

00:03:50.536 --> 00:03:51.706
object pointer fields in C

00:03:51.736 --> 00:03:51.976
structures.

00:03:52.516 --> 00:04:00.616
[ Applause ]

00:04:01.116 --> 00:04:02.166
Let's take a look at an example

00:04:02.336 --> 00:04:03.506
let's say we'd like to write a

00:04:03.506 --> 00:04:05.846
food ordering app and we'd like

00:04:05.876 --> 00:04:07.676
to create a data structure which

00:04:07.676 --> 00:04:09.176
represents a menu item.

00:04:09.736 --> 00:04:13.226
In Xcode 9 and earlier it would

00:04:13.226 --> 00:04:14.716
have been impossible for us to

00:04:14.716 --> 00:04:17.055
actually use a C structure with

00:04:17.055 --> 00:04:19.505
ARC object pointer fields, so we

00:04:19.536 --> 00:04:21.546
would have had to use a C, an

00:04:21.546 --> 00:04:24.506
Objective-C class here.

00:04:24.506 --> 00:04:26.516
Xcode 10 now allows us to

00:04:26.516 --> 00:04:27.926
actually create a C structure

00:04:27.926 --> 00:04:29.616
that has ARC object pointer

00:04:29.726 --> 00:04:29.976
fields.

00:04:35.066 --> 00:04:35.906
Let's keep going and keep

00:04:35.906 --> 00:04:38.176
writing our food ordering app.

00:04:38.176 --> 00:04:39.546
Let's create a function that

00:04:39.606 --> 00:04:41.236
orders free food for us.

00:04:41.696 --> 00:04:43.246
In the function let's create a

00:04:43.246 --> 00:04:45.736
variable item of type menu item

00:04:45.976 --> 00:04:46.996
with a price of zero.

00:04:48.416 --> 00:04:50.436
Then let's pass this item into

00:04:50.436 --> 00:04:52.096
another function that actually

00:04:52.376 --> 00:04:53.416
orders the food for us.

00:04:54.846 --> 00:04:57.276
When the item is created the

00:04:57.276 --> 00:04:59.716
compiler has to synthesize code

00:05:00.086 --> 00:05:02.096
which retains the ARC object

00:05:02.176 --> 00:05:03.796
pointer fields in the item.

00:05:05.066 --> 00:05:06.766
The code comments on the slide

00:05:07.106 --> 00:05:08.936
demonstrate the code that the

00:05:08.936 --> 00:05:10.306
compiler synthesizes.

00:05:11.056 --> 00:05:13.386
This code ensures the name and

00:05:13.386 --> 00:05:15.586
the price of the item are not

00:05:15.586 --> 00:05:17.346
released prematurely before the

00:05:17.346 --> 00:05:18.726
item is actually used.

00:05:18.726 --> 00:05:23.076
Now at the end of the function

00:05:23.286 --> 00:05:25.706
item goes out of scope and is

00:05:25.706 --> 00:05:27.666
deallocated from the stack so

00:05:27.666 --> 00:05:30.256
the compiler has to synthesize

00:05:30.256 --> 00:05:32.686
code which releases the ARC

00:05:32.686 --> 00:05:34.116
object pointer fields in the

00:05:34.116 --> 00:05:34.536
item.

00:05:35.596 --> 00:05:37.306
This ensures that the name and

00:05:37.306 --> 00:05:39.536
the price are not leaked when

00:05:39.536 --> 00:05:40.756
the item is released.

00:05:42.986 --> 00:05:44.676
Previously it was possible to

00:05:44.676 --> 00:05:46.546
use Objective-C object pointer

00:05:46.546 --> 00:05:48.916
fields when using manual

00:05:48.976 --> 00:05:51.076
retained release mode, but you

00:05:51.076 --> 00:05:53.246
had to write the retains and

00:05:53.276 --> 00:05:54.506
releases yourself.

00:05:55.206 --> 00:05:57.856
With ARC the compiler hides all

00:05:57.856 --> 00:05:59.826
of this complexity for you and

00:05:59.826 --> 00:06:01.646
synthesizes code that retains

00:06:01.646 --> 00:06:02.826
and releases the fields.

00:06:03.676 --> 00:06:04.956
So the compiler is really your

00:06:04.956 --> 00:06:07.056
friend here and it does the

00:06:07.056 --> 00:06:09.116
correct job of managing memory

00:06:09.286 --> 00:06:12.056
for variables on the stack and

00:06:12.056 --> 00:06:13.846
also for fields in other

00:06:13.846 --> 00:06:16.156
structures, and also instance

00:06:16.156 --> 00:06:17.916
variables inside Objective-C

00:06:17.916 --> 00:06:18.436
classes.

00:06:19.686 --> 00:06:21.756
But there is one place we have

00:06:21.816 --> 00:06:23.346
to put in a little bit of extra

00:06:23.346 --> 00:06:25.126
work to support structures with

00:06:25.126 --> 00:06:27.996
ARC object pointer fields and

00:06:27.996 --> 00:06:29.386
that place is heap.

00:06:30.656 --> 00:06:31.926
Let's go back to our structure,

00:06:32.216 --> 00:06:33.126
let's say you would like to

00:06:33.126 --> 00:06:35.366
allocate an array of menu items

00:06:35.366 --> 00:06:36.046
on the heap.

00:06:36.796 --> 00:06:38.526
Now if this was an Objective-C

00:06:38.526 --> 00:06:40.836
interface we could have used an

00:06:40.946 --> 00:06:43.366
NSArray here, but it's not so

00:06:43.366 --> 00:06:45.196
let's use malloc and free.

00:06:46.166 --> 00:06:48.416
Now this code actually has two

00:06:48.596 --> 00:06:49.176
issues.

00:06:49.766 --> 00:06:52.176
First issue, the memory is not

00:06:52.176 --> 00:06:53.956
zero initialized when it's

00:06:53.956 --> 00:06:56.146
allocated, which means that

00:06:56.146 --> 00:06:58.106
their pointers will be invalid

00:06:58.646 --> 00:07:00.396
which will cause undesired

00:07:00.696 --> 00:07:02.156
runtime behavior for your

00:07:02.156 --> 00:07:03.316
program at runtime.

00:07:04.896 --> 00:07:07.996
The second issue is that the ARC

00:07:07.996 --> 00:07:09.406
object pointer fields are not

00:07:09.516 --> 00:07:11.116
cleared before the memory is

00:07:11.166 --> 00:07:14.666
deallocated which will cause

00:07:14.876 --> 00:07:16.496
runtime memory leaks in your

00:07:16.496 --> 00:07:17.076
program.

00:07:17.656 --> 00:07:21.916
Now to fix the first issue you

00:07:21.916 --> 00:07:23.916
can replace the call to malloc

00:07:23.976 --> 00:07:25.106
with a call to calloc.

00:07:25.816 --> 00:07:27.526
This will ensure that your

00:07:27.526 --> 00:07:29.346
memory is zero initialized,

00:07:30.126 --> 00:07:32.386
which will remove all of those

00:07:32.546 --> 00:07:34.666
nasty unexpected runtime issues.

00:07:35.796 --> 00:07:38.076
To fix the second issue you can

00:07:38.076 --> 00:07:40.516
write a loop before it's

00:07:40.516 --> 00:07:42.086
allocated in your memory to

00:07:42.086 --> 00:07:43.976
clear out all of the ARC object

00:07:44.036 --> 00:07:45.396
pointer fields in your items.

00:07:46.326 --> 00:07:48.226
This will ensure that the name

00:07:48.226 --> 00:07:50.076
and the price in the items are

00:07:50.076 --> 00:07:51.836
not leaked when the items are

00:07:51.836 --> 00:07:51.976
freed.

00:07:56.086 --> 00:07:57.836
Now this is an exciting new

00:07:57.906 --> 00:08:00.586
feature and if any of you were

00:08:00.586 --> 00:08:02.896
put off from migrates over to

00:08:02.896 --> 00:08:05.746
ARC because of lack of features

00:08:05.746 --> 00:08:07.906
like that I hope that support

00:08:07.906 --> 00:08:09.486
from ARC object pointer fields

00:08:09.486 --> 00:08:11.596
in Xcode 10 will help you

00:08:11.596 --> 00:08:12.816
reconsider your choice.

00:08:14.076 --> 00:08:15.526
Now let's take a look at

00:08:16.356 --> 00:08:17.636
Objective-C pointers and

00:08:17.636 --> 00:08:19.476
structures in general and see

00:08:19.856 --> 00:08:22.646
where and how can the structures

00:08:22.686 --> 00:08:25.066
be used in different language

00:08:25.066 --> 00:08:26.286
modes in Xcode 10.

00:08:27.506 --> 00:08:30.966
So in Xcode 10 you can use

00:08:31.146 --> 00:08:33.056
structures that have Objective-C

00:08:33.056 --> 00:08:35.015
object pointer fields across

00:08:35.015 --> 00:08:36.086
different language modes.

00:08:36.576 --> 00:08:38.426
For example, you can use the

00:08:38.496 --> 00:08:41.785
same structure in C Objective-C

00:08:41.926 --> 00:08:43.796
or even Objective-C++.

00:08:44.806 --> 00:08:47.046
And it will work correctly even

00:08:47.246 --> 00:08:49.316
when you're compiling your code

00:08:49.646 --> 00:08:51.956
in ARC or in the manual retain

00:08:51.956 --> 00:08:52.606
release mode.

00:08:54.176 --> 00:08:56.446
In Xcode 10 we actually unified

00:08:56.796 --> 00:08:59.746
the Objective-C++ ABI between

00:08:59.746 --> 00:09:02.596
calls to functions that took in

00:09:02.666 --> 00:09:05.126
or returned structures that had

00:09:05.126 --> 00:09:06.676
ARC object pointer fields in

00:09:06.676 --> 00:09:07.916
Objective-C++.

00:09:08.316 --> 00:09:10.756
And this was done through an ABI

00:09:11.056 --> 00:09:14.046
change in Xcode 10 and ABI

00:09:14.226 --> 00:09:16.016
change affects functions in

00:09:16.016 --> 00:09:19.166
Objective C++ which return or

00:09:19.166 --> 00:09:21.206
take in a structure by value

00:09:21.606 --> 00:09:23.516
that has ARC object pointer

00:09:23.516 --> 00:09:26.006
fields and no special member

00:09:26.006 --> 00:09:27.726
functions like constructors or

00:09:27.726 --> 00:09:28.626
destructors.

00:09:30.126 --> 00:09:31.776
Now if you are not sure what

00:09:31.896 --> 00:09:33.656
this means for you or whether

00:09:33.946 --> 00:09:35.676
your code is affected by this

00:09:35.716 --> 00:09:38.146
ABI change please take a look at

00:09:38.276 --> 00:09:40.286
Xcode's release notes where we

00:09:40.286 --> 00:09:42.526
describe in more details the

00:09:42.526 --> 00:09:44.296
effects and the impact of this

00:09:44.296 --> 00:09:44.886
ABI change.

00:09:49.046 --> 00:09:50.676
Now there is one caveat when it

00:09:50.676 --> 00:09:53.176
comes to the ARC object pointer

00:09:53.176 --> 00:09:55.866
fields and C structures, they're

00:09:55.866 --> 00:09:56.976
not supported in Swift.

00:09:57.766 --> 00:09:59.546
So if you try to use a structure

00:10:00.046 --> 00:10:01.386
that has ARC object pointer

00:10:01.386 --> 00:10:03.766
fields from Swift you will just

00:10:03.766 --> 00:10:05.346
get a compilation error because

00:10:05.676 --> 00:10:06.976
the structure will not be found.

00:10:14.046 --> 00:10:16.286
In addition to new features like

00:10:16.696 --> 00:10:18.356
support for ARC object pointer

00:10:18.356 --> 00:10:22.306
fields Xcode 10 comes with a lot

00:10:22.306 --> 00:10:24.356
of new compiler diagnostics.

00:10:24.896 --> 00:10:26.426
We actually have over a hundred

00:10:26.556 --> 00:10:28.986
new warnings in Xcode 10 and

00:10:28.986 --> 00:10:30.566
today I'd like to talk about two

00:10:30.566 --> 00:10:30.846
of them.

00:10:31.986 --> 00:10:33.326
The first warning might be of

00:10:33.556 --> 00:10:36.036
interest to those of you who

00:10:36.036 --> 00:10:38.676
have mixed Swift and Objective-C

00:10:38.676 --> 00:10:39.036
code.

00:10:39.906 --> 00:10:42.466
So as you know Swift code can be

00:10:42.466 --> 00:10:45.786
imported into Objective-C and

00:10:46.316 --> 00:10:48.586
Xcode allows you to do that by

00:10:48.586 --> 00:10:50.356
generating a header file that

00:10:50.356 --> 00:10:52.826
describes the Swift interface

00:10:53.086 --> 00:10:54.836
using Objective-C declarations.

00:10:55.266 --> 00:10:57.856
And you can import this header

00:10:57.856 --> 00:10:59.476
file into your own Objective-C

00:10:59.476 --> 00:11:01.736
code to get access to the

00:11:01.736 --> 00:11:03.816
underlying Swift declarations.

00:11:04.756 --> 00:11:06.546
Now let's get more specific and

00:11:06.546 --> 00:11:08.396
let's talk about how Swift's

00:11:08.546 --> 00:11:10.486
closure parameters are important

00:11:10.486 --> 00:11:11.436
to Objective-C.

00:11:12.226 --> 00:11:14.296
So right now on the screen you

00:11:14.296 --> 00:11:16.186
see an example of a Swift

00:11:16.356 --> 00:11:17.846
protocol called Executor.

00:11:18.796 --> 00:11:20.796
This protocol defines a function

00:11:20.796 --> 00:11:22.726
member called performOperation

00:11:22.976 --> 00:11:24.536
which takes in a closure

00:11:24.536 --> 00:11:25.926
parameter called handler.

00:11:27.246 --> 00:11:29.506
Now in Swift closure parameters

00:11:29.506 --> 00:11:31.236
are non-escaping by default,

00:11:31.576 --> 00:11:33.496
which means that they should not

00:11:33.496 --> 00:11:35.896
be retained or called after the

00:11:35.896 --> 00:11:37.056
function returns.

00:11:38.596 --> 00:11:40.366
Now it can be easy for the

00:11:40.366 --> 00:11:42.486
program and to forget that this

00:11:42.486 --> 00:11:44.826
contract exists when conforming

00:11:44.826 --> 00:11:46.446
to the executive protocol in

00:11:46.446 --> 00:11:47.356
Objective-C.

00:11:48.156 --> 00:11:50.316
For example, as you see right

00:11:50.316 --> 00:11:52.096
now on the slide we have a

00:11:52.096 --> 00:11:54.406
dispatch Executor interface in

00:11:54.406 --> 00:11:56.566
Objective-C and conforms to the

00:11:56.566 --> 00:11:58.676
Executor protocol, so it

00:11:58.676 --> 00:12:00.416
provides the performOperation

00:12:00.416 --> 00:12:02.146
method which takes in the

00:12:02.146 --> 00:12:03.616
handler block parameter that

00:12:03.656 --> 00:12:05.726
corresponds to Swift's handler

00:12:05.726 --> 00:12:06.766
closure parameter.

00:12:07.516 --> 00:12:08.736
But just by looking at the

00:12:08.736 --> 00:12:11.406
Objective-C code we have no way

00:12:11.406 --> 00:12:12.786
of knowing whether the handler

00:12:12.786 --> 00:12:14.486
parameter can escape or not.

00:12:15.986 --> 00:12:19.046
Xcode 10 now provides a warning

00:12:19.366 --> 00:12:21.976
that helps us to remember that

00:12:21.976 --> 00:12:23.656
this parameter is actually

00:12:23.926 --> 00:12:24.866
non-escaping.

00:12:25.456 --> 00:12:29.346
To fix this this warning you can

00:12:29.486 --> 00:12:31.196
annotate your block parameter

00:12:31.196 --> 00:12:33.596
with the NS NOESCAPE annotation.

00:12:34.676 --> 00:12:36.056
You should also annotate the

00:12:36.056 --> 00:12:38.416
implementation of the method or

00:12:38.416 --> 00:12:39.456
the parameter in the

00:12:39.456 --> 00:12:40.716
implementation of the method

00:12:40.786 --> 00:12:42.816
with NS NOESCAPE annotation.

00:12:44.246 --> 00:12:46.466
Now the NS NOESCAPE annotation

00:12:46.636 --> 00:12:48.976
is simply a reminder for you the

00:12:48.976 --> 00:12:51.656
programmer to ensure that you

00:12:51.656 --> 00:12:54.516
don't store or call the handler

00:12:54.516 --> 00:12:55.756
block after they perform

00:12:55.756 --> 00:12:57.466
operation method returns.

00:12:58.756 --> 00:13:01.866
So it's there for you to help

00:13:01.866 --> 00:13:03.196
you remember that there is this

00:13:03.196 --> 00:13:05.686
contract that exists between

00:13:05.686 --> 00:13:09.926
your Swift and Objective-C code.

00:13:10.146 --> 00:13:11.616
Now the second warning might be

00:13:11.616 --> 00:13:14.326
of interest to those of you who

00:13:14.326 --> 00:13:16.056
work with more low-level code

00:13:16.056 --> 00:13:18.296
and who care about the way that

00:13:18.296 --> 00:13:20.156
structures are laid out in

00:13:20.156 --> 00:13:20.566
memory.

00:13:21.846 --> 00:13:22.886
Let's take a look at one

00:13:22.886 --> 00:13:23.406
structure.

00:13:23.866 --> 00:13:25.776
So in C structures have to

00:13:25.776 --> 00:13:27.766
follow strict layout and

00:13:27.766 --> 00:13:28.816
alignment rules.

00:13:29.866 --> 00:13:31.126
In this particular structure

00:13:31.126 --> 00:13:32.096
that you see right now on the

00:13:32.096 --> 00:13:34.606
slide the compiler has to insert

00:13:34.646 --> 00:13:36.706
a 2-byte pattern between the

00:13:36.706 --> 00:13:38.666
second and the third field of

00:13:38.666 --> 00:13:39.246
the structure.

00:13:40.776 --> 00:13:42.066
Sometimes you might want to

00:13:42.066 --> 00:13:44.386
relax these rules and the

00:13:44.386 --> 00:13:46.956
compiler provides a pragma pack

00:13:47.066 --> 00:13:48.906
directive that you can use to

00:13:48.906 --> 00:13:50.446
control the layout and the

00:13:50.446 --> 00:13:51.846
alignment of your structures.

00:13:54.196 --> 00:13:56.956
Now in this example we use the

00:13:56.956 --> 00:13:59.906
pragma pack push, 1 directive to

00:13:59.906 --> 00:14:03.556
remove this fixated layout and

00:14:03.556 --> 00:14:05.346
to ensure that our structure is

00:14:05.436 --> 00:14:05.956
tightly packed.

00:14:07.436 --> 00:14:08.766
This can be useful when

00:14:09.446 --> 00:14:11.146
serializing your structures or

00:14:11.146 --> 00:14:12.296
when transferring your

00:14:12.296 --> 00:14:13.576
structures over the network.

00:14:14.836 --> 00:14:16.976
Now pragma pack is typically

00:14:16.976 --> 00:14:19.036
used with a push and a pop

00:14:19.136 --> 00:14:21.386
directive, but it can be easy

00:14:21.386 --> 00:14:23.526
for the programmer to forget to

00:14:23.526 --> 00:14:25.416
insert the pop into the code.

00:14:27.246 --> 00:14:29.346
Xcode 10 will now warn about

00:14:29.376 --> 00:14:31.526
code that doesn't have a

00:14:31.526 --> 00:14:33.526
corresponding pragma pack pop

00:14:33.526 --> 00:14:36.036
directive and to point you to

00:14:36.036 --> 00:14:37.516
the location of the push.

00:14:38.146 --> 00:14:41.426
So to fix this warning you

00:14:41.426 --> 00:14:42.866
should take a look at the

00:14:42.866 --> 00:14:44.586
location of your push directive

00:14:45.156 --> 00:14:47.716
and insert the pop directive at

00:14:47.716 --> 00:14:49.706
the corresponding location in

00:14:49.706 --> 00:14:50.376
your code.

00:14:51.806 --> 00:14:53.426
So in our case we can insert the

00:14:53.426 --> 00:14:55.296
pop directly after the packed

00:14:55.376 --> 00:14:55.836
structure.

00:14:57.186 --> 00:15:00.986
Once we do that the new layout

00:15:00.986 --> 00:15:02.546
rules will apply only to the

00:15:02.546 --> 00:15:05.006
packed structure so they won't

00:15:05.296 --> 00:15:06.676
affect any other structures in

00:15:06.676 --> 00:15:06.976
our program.

00:15:12.046 --> 00:15:13.596
These two new warnings that I

00:15:13.596 --> 00:15:16.026
mentioned are enabled by default

00:15:16.026 --> 00:15:18.936
in Xcode 10 and they are there

00:15:18.936 --> 00:15:21.186
to help you write more correct

00:15:21.346 --> 00:15:22.606
and more robust code.

00:15:23.306 --> 00:15:24.766
And to talk more about more

00:15:24.766 --> 00:15:27.066
correct and more robust code I'd

00:15:27.066 --> 00:15:28.646
like to invite George up on

00:15:28.646 --> 00:15:30.126
stage who will talk about the

00:15:30.126 --> 00:15:31.556
new static analyzing

00:15:31.556 --> 00:15:33.126
improvements in Xcode 10.

00:15:33.376 --> 00:15:33.536
George.

00:15:34.516 --> 00:15:39.500
[ Applause ]

00:15:42.056 --> 00:15:43.426
>> Thanks Alex, so I would like

00:15:43.426 --> 00:15:44.836
to tell you about some of the

00:15:44.836 --> 00:15:46.706
improvements we have done for

00:15:46.986 --> 00:15:48.896
Xcode 10 for the Clang Static

00:15:48.896 --> 00:15:49.456
Analyzer.

00:15:50.356 --> 00:15:52.086
So the Clang Static Analyzer is

00:15:52.086 --> 00:15:53.566
a great tool for finding HK

00:15:53.566 --> 00:15:55.936
hard-to-reproduce bugs in your

00:15:55.936 --> 00:15:56.486
program.

00:15:56.736 --> 00:15:58.656
And not only the Static Analyzer

00:15:58.656 --> 00:16:00.726
finds the bug for you it also

00:16:00.726 --> 00:16:02.416
displays the visualization in

00:16:02.496 --> 00:16:04.336
Xcode of the paths which

00:16:04.386 --> 00:16:04.936
[inaudible] the bug.

00:16:05.636 --> 00:16:07.546
So here nil is added to

00:16:07.636 --> 00:16:09.566
NSMutableArray which can cause a

00:16:09.566 --> 00:16:10.596
crash later on.

00:16:10.636 --> 00:16:12.626
And Static Analyzer shows you

00:16:12.626 --> 00:16:14.566
the path for this crash so you

00:16:14.566 --> 00:16:16.026
can see how the application can

00:16:16.026 --> 00:16:16.516
be fixed.

00:16:17.686 --> 00:16:19.536
And I would like to tell you

00:16:19.536 --> 00:16:20.916
about three of the new

00:16:20.916 --> 00:16:22.166
improvements we have done.

00:16:22.816 --> 00:16:25.346
Firstly, we have a new check for

00:16:25.346 --> 00:16:27.266
detecting Grand Central Dispatch

00:16:27.266 --> 00:16:29.146
anti-patterning, which can cause

00:16:29.146 --> 00:16:30.876
poor performance and hangs of

00:16:30.876 --> 00:16:31.666
your replication.

00:16:32.346 --> 00:16:34.286
Secondly, we have a new check

00:16:34.286 --> 00:16:36.066
for detecting a misuse of

00:16:36.066 --> 00:16:38.146
autoreleasing variables inside

00:16:38.146 --> 00:16:39.866
autorelease pools which can

00:16:39.866 --> 00:16:41.136
cause crashes with [inaudible].

00:16:41.136 --> 00:16:44.876
And finally, we have improved

00:16:44.916 --> 00:16:46.556
performance and visualizations

00:16:46.556 --> 00:16:47.916
for the Clang Static Analyzer.

00:16:49.116 --> 00:16:51.486
So let's start with a new check

00:16:51.486 --> 00:16:52.836
for detecting Grand Central

00:16:52.836 --> 00:16:54.086
Dispatch anti-pattern.

00:16:54.986 --> 00:16:57.226
So many APIs on our platforms

00:16:57.656 --> 00:17:00.076
are asynchronous, but sometimes

00:17:00.076 --> 00:17:01.606
developers would like to use

00:17:01.606 --> 00:17:03.296
them in a synchronous way for

00:17:03.296 --> 00:17:04.476
one reason or another.

00:17:05.526 --> 00:17:06.796
Maybe because their code is

00:17:06.796 --> 00:17:07.796
already running on the

00:17:07.796 --> 00:17:09.915
background queue or maybe

00:17:09.915 --> 00:17:11.036
because the function cannot

00:17:11.036 --> 00:17:12.415
proceed at all until the

00:17:12.415 --> 00:17:13.915
required value is available.

00:17:14.306 --> 00:17:16.415
And the tempting solution there

00:17:16.415 --> 00:17:18.606
is to use a semaphore to ensure

00:17:18.606 --> 00:17:19.486
synchronization.

00:17:20.536 --> 00:17:21.965
So that's what's happening in

00:17:21.965 --> 00:17:24.685
this example, so here there is

00:17:24.906 --> 00:17:27.336
an SXPC object self.connection

00:17:27.826 --> 00:17:29.186
and we use its property

00:17:29.186 --> 00:17:32.046
remoteObjectProxy to call, to

00:17:32.046 --> 00:17:33.846
get the current task name

00:17:33.996 --> 00:17:35.866
asynchronously from a different

00:17:35.866 --> 00:17:36.606
process.

00:17:37.566 --> 00:17:39.506
And then we wait on a semaphore

00:17:40.076 --> 00:17:41.666
which is signal to inside the

00:17:41.926 --> 00:17:42.546
callback.

00:17:43.286 --> 00:17:45.126
And that helps to ensure that by

00:17:45.126 --> 00:17:46.696
the time the function returns

00:17:47.376 --> 00:17:48.996
the task name is available.

00:17:49.256 --> 00:17:51.966
So this approach works but has

00:17:51.966 --> 00:17:53.566
known performance implications.

00:17:54.466 --> 00:17:56.536
So the main problem here is when

00:17:56.536 --> 00:17:58.956
you wait using a semaphore on

00:17:58.956 --> 00:18:01.016
some asynchronous process you

00:18:01.016 --> 00:18:02.736
might be waiting on a queue with

00:18:02.736 --> 00:18:04.776
a much lower priority than yours

00:18:05.156 --> 00:18:07.256
costing prior inversion which

00:18:07.756 --> 00:18:08.516
[inaudible] performance and

00:18:08.516 --> 00:18:09.176
cause hangs.

00:18:09.816 --> 00:18:12.876
And moreover using a semaphore

00:18:12.876 --> 00:18:14.956
in such a way also spawns

00:18:14.956 --> 00:18:16.426
useless threads which further

00:18:16.426 --> 00:18:17.616
degrades the performance.

00:18:18.426 --> 00:18:20.706
And to help you address this

00:18:20.706 --> 00:18:23.016
issue now Static Analyzer warns

00:18:23.386 --> 00:18:27.966
on such cases helping to see

00:18:27.966 --> 00:18:29.096
where the issue occurs.

00:18:29.096 --> 00:18:32.846
Now let's see how the issue can

00:18:32.846 --> 00:18:33.446
be fixed.

00:18:34.066 --> 00:18:35.776
In the best-case scenario there

00:18:35.836 --> 00:18:38.406
is a synchronous API available

00:18:38.446 --> 00:18:39.646
which can be used in stat.

00:18:40.286 --> 00:18:42.966
So for an SXPC connection there

00:18:42.966 --> 00:18:44.146
is an [inaudible] API

00:18:44.576 --> 00:18:47.116
synchronousRemoteObjectProxy

00:18:47.736 --> 00:18:49.526
which when used in start

00:18:49.526 --> 00:18:50.536
eliminates the need for the

00:18:50.536 --> 00:18:53.016
semaphore and runs much foster.

00:18:55.196 --> 00:18:57.306
Alternatively, if no such

00:18:57.306 --> 00:18:59.976
synchronous API is available you

00:18:59.976 --> 00:19:00.836
could restructure your

00:19:00.836 --> 00:19:02.586
application to use continuations

00:19:02.586 --> 00:19:04.176
in stat and just calls the

00:19:04.176 --> 00:19:05.586
required function inside the

00:19:05.586 --> 00:19:06.176
callback.

00:19:08.876 --> 00:19:10.706
So this check is not enabled by

00:19:10.706 --> 00:19:12.516
default but we encourage you to

00:19:12.516 --> 00:19:14.576
enable it in build settings in

00:19:14.576 --> 00:19:16.276
order to make sure no such

00:19:16.316 --> 00:19:17.256
problem securing your

00:19:17.256 --> 00:19:18.956
application and it runs as fast

00:19:18.956 --> 00:19:19.526
as possible.

00:19:19.526 --> 00:19:23.076
Now let's talk about the second

00:19:23.076 --> 00:19:24.746
check for detecting the

00:19:24.746 --> 00:19:25.976
autoreleasing variables

00:19:25.976 --> 00:19:27.646
outliving the lifetime of the

00:19:27.646 --> 00:19:28.566
autorelease pool.

00:19:29.166 --> 00:19:32.336
So the autoreleasing qualifier

00:19:32.626 --> 00:19:34.526
specifies that the value has to

00:19:34.526 --> 00:19:36.356
be released once the control

00:19:36.356 --> 00:19:37.886
exits the autorelease pool.

00:19:38.606 --> 00:19:41.156
So here we have an example where

00:19:41.216 --> 00:19:42.786
we create an error variable

00:19:43.076 --> 00:19:44.956
inside the autorelease pool and

00:19:44.956 --> 00:19:46.326
once the control is outside of

00:19:46.326 --> 00:19:47.596
the autorelease pool the

00:19:47.596 --> 00:19:49.336
variable is released and

00:19:49.336 --> 00:19:50.456
subsequently destroyed.

00:19:51.176 --> 00:19:53.516
And autoreleasing pools are a

00:19:53.516 --> 00:19:55.556
useful feature of Objective-C to

00:19:55.556 --> 00:19:56.976
help contain the big memory

00:19:56.976 --> 00:19:58.586
footprint of your applications

00:19:58.586 --> 00:19:59.986
and to ensure that thumbprints

00:19:59.986 --> 00:20:00.946
are destroyed where necessary.

00:20:02.756 --> 00:20:05.576
However, it can cause unexpected

00:20:05.576 --> 00:20:08.276
crashes and they're even more

00:20:08.276 --> 00:20:10.096
unexpected because you don't

00:20:10.096 --> 00:20:11.546
even need to write the word

00:20:11.626 --> 00:20:12.756
autoreleasing in your

00:20:12.756 --> 00:20:14.036
application to have those

00:20:14.036 --> 00:20:14.576
crashes.

00:20:15.126 --> 00:20:16.896
So for instance, there is a

00:20:16.896 --> 00:20:19.336
validation function here and it

00:20:19.336 --> 00:20:21.586
takes in out parameter NSError.

00:20:22.336 --> 00:20:24.366
And out parameters are actually

00:20:24.366 --> 00:20:25.996
autoreleasing in Objective-C

00:20:25.996 --> 00:20:27.436
under ARC by default.

00:20:28.126 --> 00:20:30.456
So when we write to this out

00:20:30.506 --> 00:20:32.326
parameter inside the autorelease

00:20:32.326 --> 00:20:36.956
pool and then the function exits

00:20:37.206 --> 00:20:38.706
the error value is actually

00:20:38.706 --> 00:20:39.196
released.

00:20:39.926 --> 00:20:41.556
And then if the caller tries to

00:20:41.556 --> 00:20:42.966
read the value of this error

00:20:42.966 --> 00:20:45.086
variable they might crash with

00:20:45.086 --> 00:20:45.976
use-after-free.

00:20:51.046 --> 00:20:53.046
That pattern is already hard to

00:20:53.046 --> 00:20:54.936
detect, but it actually gets

00:20:54.996 --> 00:20:56.896
even worse when you don't even

00:20:56.896 --> 00:20:57.986
control the part of the

00:20:57.986 --> 00:20:59.106
application which has the

00:20:59.106 --> 00:21:00.016
autorelease pool.

00:21:00.776 --> 00:21:02.416
So here is a similar function

00:21:02.666 --> 00:21:04.676
which [inaudible] and out

00:21:04.676 --> 00:21:06.696
parameter error and then it

00:21:06.696 --> 00:21:07.176
calls an

00:21:07.176 --> 00:21:10.236
enumerateObjectsUsingBlock which

00:21:10.236 --> 00:21:12.476
is a popular foundation API

00:21:12.616 --> 00:21:14.126
which calls a block on every

00:21:14.126 --> 00:21:15.676
element of a collection.

00:21:16.486 --> 00:21:17.046
However

00:21:17.316 --> 00:21:19.246
enumerateObjectsUsingBlock

00:21:19.476 --> 00:21:21.156
actually calls [inaudible] given

00:21:21.156 --> 00:21:22.576
block inside the autorelease

00:21:22.576 --> 00:21:23.486
pool of return.

00:21:24.096 --> 00:21:25.906
So a similar problem occurs here

00:21:26.386 --> 00:21:28.066
that when we create an error

00:21:28.066 --> 00:21:30.726
value inside the block and write

00:21:30.726 --> 00:21:32.916
it to the out parameter it will

00:21:32.916 --> 00:21:34.666
actually get released by the

00:21:34.666 --> 00:21:36.386
time the control reaches out of

00:21:36.436 --> 00:21:38.126
enumerateObjectsUsingBlock.

00:21:39.356 --> 00:21:41.106
And then when the caller tries

00:21:41.816 --> 00:21:44.126
to read it they also can crash

00:21:44.126 --> 00:21:45.186
with the use-after-free.

00:21:45.666 --> 00:21:49.416
And previously we have

00:21:49.416 --> 00:21:51.056
introduced the compiler warning

00:21:51.456 --> 00:21:53.436
which warns when an implicitly

00:21:53.436 --> 00:21:55.376
autoreleasing out parameter is

00:21:55.376 --> 00:21:56.466
captured in the block.

00:21:57.046 --> 00:21:58.206
And the compiler warning

00:21:58.206 --> 00:21:59.436
suggested to make such

00:21:59.476 --> 00:22:00.636
parameters explicitly

00:22:00.636 --> 00:22:01.346
autoreleasing.

00:22:02.156 --> 00:22:03.486
But we have noticed that such

00:22:03.486 --> 00:22:06.486
issue kept occurring, so in

00:22:06.486 --> 00:22:08.026
Xcode 10 we introduced a more

00:22:08.026 --> 00:22:10.356
powerful Clang Static Analyzer

00:22:10.356 --> 00:22:13.906
warning which knows which APIs

00:22:14.956 --> 00:22:16.866
call the provided block inside

00:22:16.866 --> 00:22:18.846
the autorelease pool and warns

00:22:18.846 --> 00:22:19.966
about such cases.

00:22:24.066 --> 00:22:24.956
So now let's see how this issue

00:22:24.956 --> 00:22:25.676
can be fixed.

00:22:26.286 --> 00:22:28.316
And the simplest fix here is

00:22:28.316 --> 00:22:29.796
just to introduce a strong local

00:22:29.796 --> 00:22:32.376
variable and then when you're

00:22:32.376 --> 00:22:34.836
inside the block write a value

00:22:34.836 --> 00:22:36.296
into the strong variable in

00:22:36.296 --> 00:22:36.806
stat.

00:22:37.646 --> 00:22:39.456
And then only copy to the out

00:22:39.516 --> 00:22:41.646
parameter once the control is

00:22:41.646 --> 00:22:43.286
outside of the block and you

00:22:43.286 --> 00:22:44.666
know it's not inside the

00:22:44.666 --> 00:22:46.216
autorelease pool and it's safe

00:22:46.276 --> 00:22:47.696
to write into the autoreleasing

00:22:47.696 --> 00:22:47.976
variable.

00:22:53.236 --> 00:22:55.206
And finally, we also have

00:22:55.206 --> 00:22:56.306
improved performance and

00:22:56.306 --> 00:22:57.706
visualizations of the Clang

00:22:57.706 --> 00:22:58.566
Static Analyzer.

00:22:59.676 --> 00:23:02.736
So in Xcode 10 we have improved

00:23:02.736 --> 00:23:03.966
the analyzer to explore your

00:23:03.966 --> 00:23:05.536
program in a more efficient way

00:23:05.766 --> 00:23:08.386
so now it finds up to 15% more

00:23:09.096 --> 00:23:10.666
bugs during the same analysis

00:23:10.666 --> 00:23:11.006
time.

00:23:11.896 --> 00:23:14.226
And not only it finds more bugs

00:23:14.786 --> 00:23:16.556
the bug report it now generates

00:23:17.006 --> 00:23:19.116
tend to be smaller and more

00:23:19.116 --> 00:23:19.906
understandable.

00:23:20.116 --> 00:23:22.006
And what I mean by that is

00:23:22.006 --> 00:23:25.026
sometimes in Xcode 10 you would

00:23:25.026 --> 00:23:26.646
get examples which have a lot of

00:23:26.646 --> 00:23:28.866
steps and a lot of arrows and

00:23:28.866 --> 00:23:30.016
which would be somewhat hard to

00:23:30.016 --> 00:23:30.686
comprehend.

00:23:31.246 --> 00:23:33.976
And in many of those examples in

00:23:33.976 --> 00:23:36.256
your version of Xcode we give

00:23:36.256 --> 00:23:38.196
you a much smaller error path

00:23:38.196 --> 00:23:40.116
which is much easier to see and

00:23:40.116 --> 00:23:41.146
you can see the issue much

00:23:41.146 --> 00:23:41.656
faster.

00:23:43.116 --> 00:23:45.346
So in order to use Static

00:23:45.346 --> 00:23:47.566
Analyzer on your projects you

00:23:47.566 --> 00:23:51.256
can use Product, Analyze or you

00:23:51.256 --> 00:23:53.396
can even enable Analyze During

00:23:53.396 --> 00:23:55.456
Build to make sure no analyzer

00:23:55.456 --> 00:23:56.626
issue gets unnoticed.

00:23:56.666 --> 00:23:58.676
So I encourage you to use the

00:23:58.676 --> 00:24:00.336
Static Analyzer, it's a great

00:24:00.336 --> 00:24:01.726
tool to find your bugs before

00:24:01.726 --> 00:24:02.366
users do.

00:24:02.706 --> 00:24:04.996
And now my colleague Ahmed will

00:24:04.996 --> 00:24:06.376
talk about low-level

00:24:06.376 --> 00:24:07.026
improvements.

00:24:07.936 --> 00:24:10.916
>> Thank you George.

00:24:11.016 --> 00:24:13.000
[ Applause ]

00:24:15.046 --> 00:24:16.176
So as Alex and George told you,

00:24:16.176 --> 00:24:18.486
we have lots of warnings and

00:24:18.776 --> 00:24:20.326
Static Analyzer checks in the

00:24:20.326 --> 00:24:22.496
compiler, but you also have the

00:24:22.496 --> 00:24:24.186
sanitizer and all of these tools

00:24:24.186 --> 00:24:25.476
help you find lots of bugs,

00:24:25.576 --> 00:24:26.586
including security bugs.

00:24:27.146 --> 00:24:29.606
So I'm sure you all have lots of

00:24:29.606 --> 00:24:30.866
tests and use all these great

00:24:30.866 --> 00:24:33.766
tools to find all the bugs in

00:24:33.766 --> 00:24:34.366
these tests.

00:24:35.066 --> 00:24:36.126
But for some of the most

00:24:36.126 --> 00:24:38.496
egregious security bugs we want

00:24:38.496 --> 00:24:39.546
to make sure that they don't

00:24:39.546 --> 00:24:41.566
happen in release builds if

00:24:41.566 --> 00:24:43.126
somehow they snuck past all the

00:24:43.126 --> 00:24:43.516
testing.

00:24:44.116 --> 00:24:48.246
So for those we have mitigations

00:24:48.246 --> 00:24:49.516
in the code generator that are

00:24:49.516 --> 00:24:50.856
always emitted even in release

00:24:50.886 --> 00:24:51.216
builds.

00:24:52.146 --> 00:24:54.326
So I'm Ahmed, I work on the code

00:24:54.326 --> 00:24:55.616
generator and today I'm going to

00:24:55.616 --> 00:24:57.486
tell you about a new mitigation

00:24:57.486 --> 00:24:58.316
in Xcode 10.

00:24:58.906 --> 00:25:01.226
So to see how that works we need

00:25:01.226 --> 00:25:02.536
to understand how the stack

00:25:02.536 --> 00:25:02.936
works.

00:25:03.546 --> 00:25:06.896
So here I have a simple C

00:25:06.896 --> 00:25:09.706
function called dlog and I use

00:25:09.706 --> 00:25:11.196
it to print a string that I'm

00:25:11.196 --> 00:25:13.666
passed into a dlog bug.

00:25:14.496 --> 00:25:16.306
So in this case it's called with

00:25:16.306 --> 00:25:17.286
a string hello.

00:25:17.376 --> 00:25:20.016
And the way this works is we

00:25:20.016 --> 00:25:22.646
need to allocate some memory to

00:25:22.646 --> 00:25:23.976
keep track of this call.

00:25:25.816 --> 00:25:27.766
So we allocate that into a

00:25:27.766 --> 00:25:28.936
region called the stack.

00:25:29.776 --> 00:25:31.946
So the stack grows down towards

00:25:31.946 --> 00:25:33.146
the null pointer or address

00:25:33.146 --> 00:25:33.436
zero.

00:25:34.066 --> 00:25:37.746
So when we do our dlog hello

00:25:37.746 --> 00:25:39.586
call this allocates what's

00:25:39.586 --> 00:25:41.566
called the stack frame and the

00:25:41.566 --> 00:25:43.166
stack frame contains things like

00:25:43.166 --> 00:25:44.626
the return address so that we

00:25:44.626 --> 00:25:46.486
know to go back to main.

00:25:47.306 --> 00:25:48.746
But it also contains other

00:25:48.746 --> 00:25:50.286
things like parameters and local

00:25:50.286 --> 00:25:50.876
variables.

00:25:51.746 --> 00:25:53.686
So for instance if I have a log

00:25:53.686 --> 00:25:55.076
file [inaudible] local variable

00:25:56.106 --> 00:25:57.606
that lives in the stack frame.

00:25:58.206 --> 00:26:01.846
So now if I try to make another

00:26:01.846 --> 00:26:03.796
function call to this dlog file

00:26:03.796 --> 00:26:06.636
function that in turn will

00:26:06.636 --> 00:26:07.846
allocate its own stack frame.

00:26:08.226 --> 00:26:11.226
And when it's done it's going to

00:26:11.226 --> 00:26:12.856
deallocate the stack frame and

00:26:12.856 --> 00:26:14.056
return back to the caller.

00:26:14.666 --> 00:26:18.766
So now let's look at this stack

00:26:18.766 --> 00:26:20.006
frame in more details.

00:26:21.256 --> 00:26:23.046
So let's say I change my

00:26:23.046 --> 00:26:25.436
function to have a local buffer,

00:26:25.436 --> 00:26:27.336
so it's a 4 bytes character

00:26:27.916 --> 00:26:28.006
array.

00:26:29.556 --> 00:26:31.136
And I'm trying to prepare my

00:26:31.136 --> 00:26:34.166
debug string by first doing a

00:26:34.166 --> 00:26:35.466
strcpy of the string that I'm

00:26:35.466 --> 00:26:38.466
passed into that buffer.

00:26:38.596 --> 00:26:40.696
So this does the obvious copy by

00:26:40.916 --> 00:26:44.546
[inaudible], so it does H-E-L-L.

00:26:44.546 --> 00:26:47.496
But then there's a problem at

00:26:47.496 --> 00:26:48.866
this point we already wrote 4

00:26:48.866 --> 00:26:50.786
bytes and that we already

00:26:50.786 --> 00:26:52.766
exhausted all 4 bytes available

00:26:52.766 --> 00:26:53.276
in our buffer.

00:26:54.206 --> 00:26:56.066
So if we keep going which is

00:26:56.066 --> 00:26:57.876
what strcpy will do then we're

00:26:57.876 --> 00:26:59.276
going to override the return

00:26:59.276 --> 00:27:01.536
address and this is a big

00:27:01.536 --> 00:27:02.386
security problem.

00:27:02.956 --> 00:27:04.826
So if an attacker controls the

00:27:04.826 --> 00:27:06.446
string that I'm copying which is

00:27:06.716 --> 00:27:08.496
not that hard, then it can

00:27:08.496 --> 00:27:09.776
control the return address.

00:27:10.276 --> 00:27:11.496
If it can control the return

00:27:11.496 --> 00:27:12.626
address then they control

00:27:12.626 --> 00:27:13.806
basically what the program does

00:27:13.806 --> 00:27:14.706
next, so it's a big security

00:27:14.706 --> 00:27:14.976
problem.

00:27:19.076 --> 00:27:21.446
So if you had a test that caught

00:27:21.506 --> 00:27:23.586
this and you ran the address

00:27:23.586 --> 00:27:26.376
sanitizer, then you will have

00:27:26.446 --> 00:27:27.886
had an easy way to fix this.

00:27:28.436 --> 00:27:29.266
And really what I should have

00:27:29.266 --> 00:27:32.686
done here is strncpy that knows

00:27:32.686 --> 00:27:34.546
about the size or even better

00:27:34.546 --> 00:27:35.876
use a higher-level API like

00:27:35.876 --> 00:27:36.886
NSString or [inaudible] string.

00:27:37.406 --> 00:27:40.736
But still sometimes these bugs

00:27:40.736 --> 00:27:42.236
can survive into release builds

00:27:43.156 --> 00:27:46.566
and we avoid these by using

00:27:46.566 --> 00:27:48.366
what's called the Stack

00:27:49.496 --> 00:27:49.766
Protector.

00:27:49.766 --> 00:27:51.086
So the Stack Protector changes

00:27:51.086 --> 00:27:52.176
the layout of the stack frame to

00:27:52.176 --> 00:27:54.716
add a new field the canary so

00:27:55.416 --> 00:27:58.616
that when we do our write we

00:27:58.616 --> 00:28:00.136
have a little bit of code right

00:28:00.136 --> 00:28:01.256
before the return of the

00:28:01.256 --> 00:28:02.796
function that checks whether the

00:28:02.796 --> 00:28:04.406
canary is still valid.

00:28:05.916 --> 00:28:07.676
So if we keep writing in strcpy

00:28:07.676 --> 00:28:08.826
we're going to override the

00:28:08.826 --> 00:28:12.666
canary first and then we're

00:28:12.666 --> 00:28:14.126
going to check the canary first

00:28:14.126 --> 00:28:16.246
before returning and that's

00:28:16.246 --> 00:28:16.866
going to abort.

00:28:17.686 --> 00:28:19.076
So we turned ad potentially

00:28:19.076 --> 00:28:20.276
exploitable security

00:28:20.426 --> 00:28:22.516
vulnerability into a reliable

00:28:22.516 --> 00:28:24.366
crash and that's not good for an

00:28:24.366 --> 00:28:24.766
attacker.

00:28:25.386 --> 00:28:27.506
So this is what's called the

00:28:27.506 --> 00:28:27.966
Stack Protector.

00:28:33.416 --> 00:28:34.896
It defects certain kinds of

00:28:34.896 --> 00:28:36.306
stack buffer overflows, which is

00:28:36.306 --> 00:28:37.346
the attack that we just saw.

00:28:37.406 --> 00:28:39.466
And it's already enabled by

00:28:39.466 --> 00:28:41.096
default in many versions of

00:28:41.096 --> 00:28:41.416
Xcode.

00:28:41.976 --> 00:28:45.856
So next I'm going to talk about

00:28:45.856 --> 00:28:47.596
a trickier case where we

00:28:47.676 --> 00:28:48.866
introduced a new mitigation.

00:28:48.986 --> 00:28:52.346
So let's say I took my function,

00:28:52.986 --> 00:28:55.346
again my dlog function and I

00:28:55.346 --> 00:28:56.616
changed the buffer so that now

00:28:56.616 --> 00:28:57.776
it's a variable length array.

00:28:58.856 --> 00:29:00.426
And the length comes from a

00:29:00.426 --> 00:29:02.186
parameter called len.

00:29:03.756 --> 00:29:07.186
So let's say len in a specific

00:29:07.186 --> 00:29:09.046
call is something big like

00:29:09.046 --> 00:29:12.006
15,000, so now the stack frame

00:29:12.006 --> 00:29:13.826
has to be at least 15,000 bytes

00:29:13.826 --> 00:29:14.056
long.

00:29:16.696 --> 00:29:18.816
But memory is not all

00:29:18.816 --> 00:29:20.636
immediately available, so memory

00:29:20.636 --> 00:29:23.216
is split into pages and the

00:29:23.216 --> 00:29:25.696
stack grows only when necessary.

00:29:26.656 --> 00:29:28.176
So for instance, when we try to

00:29:28.176 --> 00:29:30.866
access by 10,000 of the buffer

00:29:30.926 --> 00:29:32.136
that's in the next page of the

00:29:32.136 --> 00:29:35.066
stack that's not yet available

00:29:35.566 --> 00:29:36.716
so it's going to do a page fault

00:29:36.716 --> 00:29:37.966
in the CPU that talks to the

00:29:37.966 --> 00:29:39.556
opening system, the operating

00:29:39.556 --> 00:29:40.586
system sees that we have the

00:29:40.586 --> 00:29:42.306
right to grow the stack, and it

00:29:42.306 --> 00:29:43.706
grows it and we can continue

00:29:43.706 --> 00:29:44.016
writing.

00:29:44.936 --> 00:29:46.926
So this all happens under the

00:29:48.816 --> 00:29:48.926
hood.

00:29:49.146 --> 00:29:51.736
But say an attacker controls the

00:29:51.736 --> 00:29:54.296
length and it makes it huge, big

00:29:54.296 --> 00:29:56.256
enough that it spans many pages.

00:29:57.556 --> 00:29:58.876
So now there's a new problem,

00:29:59.896 --> 00:30:02.626
the memory is not infinite so if

00:30:02.626 --> 00:30:04.176
we keep allocating in this stack

00:30:04.366 --> 00:30:05.906
eventually we'll hit another

00:30:05.906 --> 00:30:07.026
region of memory that's already

00:30:07.026 --> 00:30:10.646
allocated and usually that's the

00:30:10.646 --> 00:30:10.736
heap.

00:30:10.736 --> 00:30:12.116
And when we do that then we're

00:30:12.116 --> 00:30:13.226
going to clash with the heap,

00:30:13.806 --> 00:30:15.256
with whatever is already used in

00:30:15.256 --> 00:30:16.316
there, so that's usually things

00:30:16.316 --> 00:30:17.776
like malloc and new.

00:30:20.276 --> 00:30:22.016
So if we try to see what would

00:30:22.016 --> 00:30:23.816
happen with our strcpy example

00:30:24.616 --> 00:30:26.826
then we will try to write the

00:30:26.826 --> 00:30:27.696
bytes one by one.

00:30:28.406 --> 00:30:32.766
So we do H-E-L, etcetera.

00:30:32.816 --> 00:30:34.616
And from the standpoint of the

00:30:34.616 --> 00:30:37.026
CPU, the code that's generated

00:30:37.026 --> 00:30:38.156
and the operating system this is

00:30:38.156 --> 00:30:39.856
all fine because we're just

00:30:39.856 --> 00:30:41.586
writing into a page that's

00:30:41.586 --> 00:30:43.526
already available and allocated.

00:30:44.556 --> 00:30:47.006
But it really isn't because this

00:30:47.006 --> 00:30:48.216
is part of the heap, this is not

00:30:48.216 --> 00:30:50.046
part of our local stack

00:30:50.046 --> 00:30:50.796
allocated array.

00:30:51.186 --> 00:30:52.606
So when we do our writes we're

00:30:52.606 --> 00:30:53.576
actually overriding some

00:30:53.576 --> 00:30:55.586
completely unrelated piece of

00:30:55.586 --> 00:30:57.416
information like I don't know a

00:30:57.416 --> 00:30:58.496
Boolean that checks whether we

00:30:58.496 --> 00:30:59.356
should check a password.

00:31:00.126 --> 00:31:01.496
So this is another important

00:31:01.496 --> 00:31:01.926
security flaw.

00:31:07.046 --> 00:31:08.346
So this is something that we

00:31:08.346 --> 00:31:11.026
mitigated with a new feature and

00:31:11.026 --> 00:31:13.056
the future works by emitting

00:31:13.056 --> 00:31:15.196
some new codes at the entry of

00:31:15.196 --> 00:31:17.926
the function that checks whether

00:31:17.926 --> 00:31:20.056
it's okay to have the stack

00:31:20.056 --> 00:31:20.286
frame.

00:31:21.446 --> 00:31:22.806
So it asks the operating system

00:31:22.806 --> 00:31:23.976
above the maximum size of the

00:31:23.976 --> 00:31:26.146
stack and if you try to make an

00:31:26.146 --> 00:31:27.256
allocation that's bigger than

00:31:27.256 --> 00:31:29.456
that then it actually aborts.

00:31:29.836 --> 00:31:33.106
And again, this turns a

00:31:33.106 --> 00:31:34.726
potentially exploitable security

00:31:34.726 --> 00:31:37.586
bug into a reliable crash and

00:31:37.586 --> 00:31:41.176
that's no good for an attacker.

00:31:41.176 --> 00:31:43.076
So this is Stack Checking, it

00:31:43.076 --> 00:31:44.116
detects something that you might

00:31:44.116 --> 00:31:46.206
have heard of called Stack Clash

00:31:46.806 --> 00:31:48.226
and it's enabled by default in

00:31:48.226 --> 00:31:48.806
Xcode 10.

00:31:53.056 --> 00:31:55.246
So next I want to talk about a

00:31:55.246 --> 00:31:56.836
new set of features we added in

00:31:56.836 --> 00:31:58.906
Xcode 10 and that's support for

00:31:58.906 --> 00:32:00.796
new extension, sect extensions.

00:32:01.646 --> 00:32:04.386
So as you all know we have lots

00:32:04.386 --> 00:32:07.046
of great Apple devices and one

00:32:07.046 --> 00:32:08.536
of the great things about Xcode

00:32:08.536 --> 00:32:10.326
is that with just a few build

00:32:10.326 --> 00:32:11.856
settings you can target your

00:32:11.856 --> 00:32:13.596
code for each of these devices.

00:32:13.966 --> 00:32:17.356
And so under the hood in macOS,

00:32:17.356 --> 00:32:20.456
iOS, watchOS, etcetera we tweak

00:32:20.826 --> 00:32:22.966
every OS so that it uses

00:32:22.966 --> 00:32:24.766
everything that's available on a

00:32:24.766 --> 00:32:25.986
specific piece of hardware.

00:32:26.476 --> 00:32:27.516
So it guarantees maximum

00:32:27.516 --> 00:32:29.146
performance no matter where we

00:32:29.146 --> 00:32:29.436
run.

00:32:29.796 --> 00:32:32.856
And so if you an app with

00:32:33.206 --> 00:32:34.736
extremely high-performance

00:32:34.736 --> 00:32:35.966
requirements that's something

00:32:35.966 --> 00:32:37.156
that you might want to do as

00:32:37.156 --> 00:32:37.356
well.

00:32:39.516 --> 00:32:41.146
So we have three features to

00:32:41.146 --> 00:32:42.916
talk about that are available in

00:32:42.916 --> 00:32:44.656
the iMac Pro and the iPhone 8

00:32:44.696 --> 00:32:45.946
Plus and X.

00:32:46.836 --> 00:32:49.046
And let's start with the iMac

00:32:50.996 --> 00:32:51.106
Pro.

00:32:51.316 --> 00:32:53.186
So the iMac Pro has the Intel

00:32:53.186 --> 00:32:58.006
Xeon CPU which has a set of new

00:32:58.006 --> 00:32:59.886
features called AVX-512.

00:32:59.886 --> 00:33:03.536
So AVX-512 is a set of new

00:33:03.536 --> 00:33:05.326
instructions with vector

00:33:05.326 --> 00:33:05.846
registers.

00:33:08.476 --> 00:33:12.106
And these provide benefits over

00:33:12.386 --> 00:33:16.466
X86-64, so in X86-64 we can only

00:33:16.466 --> 00:33:18.546
assume that we have 128-bit

00:33:18.546 --> 00:33:20.536
vectors available, so that's

00:33:20.536 --> 00:33:21.976
guaranteed on any Mac ever

00:33:22.036 --> 00:33:23.836
that's Intel powered.

00:33:25.156 --> 00:33:26.886
Now it happens that any new Mac

00:33:26.886 --> 00:33:28.946
today has more than that, but

00:33:28.946 --> 00:33:30.366
the iMac Pro is the first that

00:33:30.366 --> 00:33:32.836
has 512-bit registers.

00:33:35.456 --> 00:33:37.246
And with the Auto-Vectorizer

00:33:37.246 --> 00:33:39.136
that's enabled in the Xcode

00:33:39.136 --> 00:33:41.826
Clang this is great because it

00:33:41.826 --> 00:33:43.736
means that we can have many more

00:33:43.736 --> 00:33:45.186
elements in the vector.

00:33:46.136 --> 00:33:47.676
So this can greatly improve

00:33:47.676 --> 00:33:48.246
throughputs.

00:33:48.786 --> 00:33:52.346
But there are other benefits

00:33:52.346 --> 00:33:55.826
with AVX-512, so for instance we

00:33:55.916 --> 00:33:58.086
not only have bigger vectors we

00:33:58.086 --> 00:33:59.326
also have more of them.

00:33:59.916 --> 00:34:02.546
So on X86-64 we only have 16 now

00:34:02.546 --> 00:34:04.526
we have 32, so this is a lot of

00:34:04.526 --> 00:34:07.196
data to process.

00:34:07.326 --> 00:34:09.085
And even if for some reason the

00:34:09.085 --> 00:34:10.735
auto-vectorizer is not able to

00:34:11.176 --> 00:34:13.786
make use of these vectors then

00:34:13.786 --> 00:34:15.806
we still have ore skill

00:34:15.806 --> 00:34:17.235
registers or even for code that

00:34:17.235 --> 00:34:18.696
just does float or double.

00:34:19.556 --> 00:34:21.166
There are lots of performance

00:34:21.166 --> 00:34:22.985
benefits in AVX-512.

00:34:23.916 --> 00:34:25.636
So let's look at how we can

00:34:26.246 --> 00:34:28.206
exploit it in my compute

00:34:28.235 --> 00:34:29.525
[inaudible] expensive function.

00:34:30.106 --> 00:34:32.886
So the first thing I'm going to

00:34:32.886 --> 00:34:35.065
do is to keep around my existing

00:34:35.065 --> 00:34:36.676
function because that's going to

00:34:36.676 --> 00:34:38.646
be the fallback that I have that

00:34:38.646 --> 00:34:39.896
runs on all Macs.

00:34:40.326 --> 00:34:43.275
Next, I can try to specialize my

00:34:43.275 --> 00:34:43.696
function.

00:34:44.025 --> 00:34:45.815
So one way to do that is using

00:34:45.815 --> 00:34:46.806
the target attributes.

00:34:47.306 --> 00:34:50.826
And that tells the compiler that

00:34:50.826 --> 00:34:52.666
it's okay to assume that this

00:34:52.666 --> 00:34:54.516
function has AVX-512, so it only

00:34:54.516 --> 00:34:57.206
runs on an iMac Pro.

00:34:57.416 --> 00:34:58.926
So if you use simd.h, for

00:34:58.926 --> 00:35:01.126
instance the simd float4 128-bit

00:35:01.126 --> 00:35:03.336
vector type then now we might

00:35:03.336 --> 00:35:04.696
have better performance than the

00:35:04.696 --> 00:35:06.466
AVX-512 version using the same

00:35:06.466 --> 00:35:06.716
code.

00:35:07.216 --> 00:35:10.906
And if you use the even larger

00:35:10.906 --> 00:35:12.026
vector types, so for instance

00:35:12.026 --> 00:35:14.336
simd float16, then now you have

00:35:14.366 --> 00:35:15.606
much better performance than the

00:35:15.606 --> 00:35:17.506
AVX-512 version where the

00:35:17.506 --> 00:35:19.406
512-bit vector is actually

00:35:19.996 --> 00:35:20.146
native.

00:35:21.776 --> 00:35:23.146
And if you go all the way down

00:35:23.146 --> 00:35:25.206
to X86 intrinsics, then now you

00:35:25.206 --> 00:35:27.256
can start using the new AVX-512

00:35:27.256 --> 00:35:29.636
variance, as well as the M512

00:35:30.306 --> 00:35:30.436
types.

00:35:32.536 --> 00:35:34.316
So if you want to specialize

00:35:34.496 --> 00:35:35.836
larger units of codes, so not

00:35:35.836 --> 00:35:37.166
just individual functions but

00:35:37.836 --> 00:35:40.706
files, targets, libraries, then

00:35:40.706 --> 00:35:42.936
you can use the new AVX-512

00:35:42.936 --> 00:35:45.156
value of the additional vector

00:35:45.156 --> 00:35:46.116
extensions build setting.

00:35:46.666 --> 00:35:50.236
So when you do that there are

00:35:50.236 --> 00:35:52.176
some things to keep in mind and

00:35:52.176 --> 00:35:53.776
if you're familiar with AVX-1

00:35:53.776 --> 00:35:56.246
and AVX-2 these are very similar

00:35:56.386 --> 00:35:56.816
issues.

00:35:58.516 --> 00:36:00.286
So you can only pass large

00:36:00.286 --> 00:36:03.666
vectors, so 256 bits and up from

00:36:03.666 --> 00:36:05.296
and to AVX-512 functions.

00:36:05.626 --> 00:36:07.766
So the ABI is different from the

00:36:07.766 --> 00:36:09.016
generic and a specialized

00:36:09.016 --> 00:36:10.516
variance, so you cannot pass

00:36:10.516 --> 00:36:13.966
them between those.

00:36:14.166 --> 00:36:16.376
Additionally, these vectors are

00:36:16.376 --> 00:36:18.236
large and they're large enough

00:36:18.236 --> 00:36:19.856
that their natural alignment is

00:36:20.106 --> 00:36:21.966
too big for what's guaranteed by

00:36:21.966 --> 00:36:22.746
things like malloc.

00:36:22.746 --> 00:36:24.216
So you have to take that into

00:36:24.216 --> 00:36:25.596
account when allocating these

00:36:26.526 --> 00:36:30.316
anywhere other than the stack.

00:36:30.316 --> 00:36:31.876
And so in general all of these

00:36:31.956 --> 00:36:33.406
things are things that we are

00:36:33.406 --> 00:36:34.396
already go through lots of

00:36:34.536 --> 00:36:36.056
things in the opening system.

00:36:36.536 --> 00:36:37.936
So for instance, if you can at

00:36:37.936 --> 00:36:40.056
all use accelerate.framework and

00:36:40.056 --> 00:36:41.326
it's much easier to do so

00:36:41.656 --> 00:36:42.976
because we already specialized

00:36:42.976 --> 00:36:44.506
all the functions for every

00:36:44.506 --> 00:36:45.696
single microarchitecture.

00:36:46.346 --> 00:36:49.806
So this is AVX-512.

00:36:50.406 --> 00:36:53.576
Now we also have new features on

00:36:53.576 --> 00:36:56.936
the iPhone 8, 8 Plus and X.

00:36:59.016 --> 00:37:01.716
So one of the first feature is

00:37:02.196 --> 00:37:05.476
ARM v8.1 Atomics and that's

00:37:05.626 --> 00:37:07.066
thanks to one of the great

00:37:07.066 --> 00:37:09.566
things about the iPhone X and

00:37:09.706 --> 00:37:11.976
that's the A11 Bionic chip.

00:37:16.426 --> 00:37:19.786
So the A11 Bionic chip has one

00:37:20.176 --> 00:37:22.426
great new feature compared to

00:37:22.466 --> 00:37:24.616
the A10 which is its support for

00:37:24.956 --> 00:37:27.636
six CPUs, six cores running all

00:37:27.636 --> 00:37:29.326
at the same time and that's a

00:37:29.326 --> 00:37:30.786
first in iOS.

00:37:32.196 --> 00:37:34.386
And since you have more cores

00:37:34.386 --> 00:37:35.326
than you probably have more

00:37:35.326 --> 00:37:37.376
threads all at the same time and

00:37:37.376 --> 00:37:38.616
with more threads you might need

00:37:38.616 --> 00:37:40.376
more synchronization to make

00:37:40.376 --> 00:37:41.326
these threads cooperate.

00:37:42.256 --> 00:37:43.876
And that's implemented using

00:37:43.876 --> 00:37:44.426
atomics.

00:37:45.756 --> 00:37:47.636
So the A11 chip also introduces

00:37:47.636 --> 00:37:48.826
a new family of atomic

00:37:48.826 --> 00:37:51.116
instructions that are better

00:37:51.116 --> 00:37:54.346
optimized for the new extra

00:37:54.346 --> 00:37:54.796
cores.

00:37:55.366 --> 00:37:58.386
So let's look at how that works.

00:37:58.386 --> 00:38:02.536
So the way atomics work is

00:38:03.546 --> 00:38:04.746
through a small sequence of

00:38:04.796 --> 00:38:05.096
codes.

00:38:05.776 --> 00:38:08.116
So suppose I have a thread and

00:38:08.116 --> 00:38:09.156
it's trying to access main

00:38:09.156 --> 00:38:11.856
memory, so it has an atomic

00:38:11.856 --> 00:38:13.826
shared variable in there and

00:38:13.826 --> 00:38:14.996
it's just trying to increment

00:38:15.656 --> 00:38:15.726
it.

00:38:17.216 --> 00:38:18.716
So under the hood the code

00:38:18.716 --> 00:38:20.176
generator will emit a small

00:38:20.176 --> 00:38:23.026
sequence of codes that first

00:38:23.276 --> 00:38:24.946
takes exclusive excess of a

00:38:24.946 --> 00:38:26.816
cache line and that's a small

00:38:26.816 --> 00:38:28.766
region of memory that contains

00:38:28.766 --> 00:38:30.836
completely this atomic variable.

00:38:31.426 --> 00:38:34.816
Now that we have exclusive

00:38:34.816 --> 00:38:36.186
access we can load from the

00:38:36.186 --> 00:38:38.046
variable, then we can do our

00:38:38.046 --> 00:38:39.326
increment on the temporary

00:38:39.436 --> 00:38:41.756
loaded value and store the

00:38:41.756 --> 00:38:43.026
result back.

00:38:44.636 --> 00:38:46.186
And we know that this is safe

00:38:46.186 --> 00:38:47.066
because we have exclusive

00:38:47.066 --> 00:38:48.766
access, so no other thread could

00:38:48.766 --> 00:38:50.376
have changed the value while

00:38:50.376 --> 00:38:51.936
we're computing our temporary

00:38:51.936 --> 00:38:52.346
results.

00:38:53.696 --> 00:38:55.496
But now suppose another thread

00:38:55.496 --> 00:38:57.446
does access either the same

00:38:57.446 --> 00:38:58.906
variable or another variable in

00:38:58.906 --> 00:39:02.536
the same cache line.

00:39:02.776 --> 00:39:04.366
So both are going to try to have

00:39:04.366 --> 00:39:05.876
exclusive access over this

00:39:06.126 --> 00:39:08.616
variable and that is not

00:39:08.616 --> 00:39:09.846
possible, that's what it means

00:39:09.886 --> 00:39:12.196
to be exclusive.

00:39:12.246 --> 00:39:14.346
So both of them are going to

00:39:14.346 --> 00:39:16.636
fail their exclusive access and

00:39:16.636 --> 00:39:17.726
they're going to have to try

00:39:17.726 --> 00:39:18.656
again until one of them

00:39:18.656 --> 00:39:19.146
succeeds.

00:39:19.796 --> 00:39:23.086
And this is not ideal for

00:39:23.086 --> 00:39:23.706
performance.

00:39:24.286 --> 00:39:27.896
So in ARM v8.1 which is the

00:39:28.536 --> 00:39:31.546
architecture in the A10 CPU we

00:39:31.546 --> 00:39:32.636
have new instructions that do

00:39:32.636 --> 00:39:34.626
this all in a single step and in

00:39:34.626 --> 00:39:35.756
some cases, that can greatly

00:39:35.756 --> 00:39:36.566
improve performance.

00:39:37.126 --> 00:39:39.676
So again, this is something that

00:39:39.676 --> 00:39:41.216
you can specialize code for

00:39:41.526 --> 00:39:43.796
using the per function

00:39:43.796 --> 00:39:45.426
specialization or for entire

00:39:45.426 --> 00:39:45.996
targets.

00:39:46.246 --> 00:39:48.086
And this is something that's

00:39:48.086 --> 00:39:49.606
only really useful when you have

00:39:49.606 --> 00:39:52.106
your own C11 or C++ 11 atomics.

00:39:53.086 --> 00:39:54.486
So in general, it's much easier

00:39:54.486 --> 00:39:55.736
to use the higher-level

00:39:56.146 --> 00:39:58.376
libraries like GCD or PThread or

00:39:58.376 --> 00:39:58.976
os unfair lock, etcetera.

00:39:59.106 --> 00:40:02.096
So these are already tweaked for

00:40:02.096 --> 00:40:03.976
ARM v8.1, but they also

00:40:03.976 --> 00:40:04.976
cooperate to the operating

00:40:04.976 --> 00:40:06.236
system to have even better

00:40:06.236 --> 00:40:06.856
performance.

00:40:11.216 --> 00:40:13.446
So another feature in the A11

00:40:13.506 --> 00:40:15.356
CPU is 16-bit floating points.

00:40:16.346 --> 00:40:18.186
So you are all familiar with the

00:40:18.616 --> 00:40:20.366
two standard floating point

00:40:20.366 --> 00:40:21.966
types, so we have double which

00:40:21.966 --> 00:40:24.596
is 64 bits and float which is 32

00:40:24.596 --> 00:40:24.956
bits.

00:40:26.186 --> 00:40:27.456
So on A11 we also have the

00:40:27.456 --> 00:40:31.756
16-bit float16, this has much

00:40:31.756 --> 00:40:34.436
less range and precision so it's

00:40:34.966 --> 00:40:37.126
not as useful for as many cases.

00:40:37.916 --> 00:40:39.066
But in some cases like machine

00:40:39.066 --> 00:40:39.856
learning or when you're trying

00:40:39.856 --> 00:40:41.986
to talk to GPU via Metal this is

00:40:41.986 --> 00:40:43.236
great because it's smaller and

00:40:43.236 --> 00:40:44.176
it's faster to compute.

00:40:45.256 --> 00:40:46.726
And that's even more true if you

00:40:46.726 --> 00:40:48.166
put them in vectors where you

00:40:48.166 --> 00:40:49.626
can put more of them in the same

00:40:49.866 --> 00:40:50.456
ARM vector.

00:40:51.086 --> 00:40:54.476
So this is also something that

00:40:54.476 --> 00:40:56.966
you can specialize code for and

00:40:56.966 --> 00:40:58.426
in general something to keep in

00:40:58.426 --> 00:40:59.966
mind with all of these features

00:41:00.586 --> 00:41:01.716
is that they're not available

00:41:01.716 --> 00:41:02.106
everywhere.

00:41:03.516 --> 00:41:05.166
So when you want to use them you

00:41:05.166 --> 00:41:06.666
have to always make sure that

00:41:06.666 --> 00:41:08.246
they're actually dynamically

00:41:08.246 --> 00:41:09.246
available on the device you're

00:41:09.246 --> 00:41:11.096
running and you can do that

00:41:11.096 --> 00:41:12.236
using sysctlbyname.

00:41:12.436 --> 00:41:15.326
And so in general we already do

00:41:15.326 --> 00:41:16.736
all this in system framework, so

00:41:16.736 --> 00:41:18.546
it's much easier to just rely on

00:41:18.546 --> 00:41:18.966
those.

00:41:19.546 --> 00:41:22.776
So these are three new

00:41:22.776 --> 00:41:24.666
instruction set extensions, we

00:41:24.666 --> 00:41:26.786
have on the iMac Pro AVX-512 and

00:41:26.856 --> 00:41:28.606
on iPhone X, 8, and 8 Plus we

00:41:28.606 --> 00:41:30.526
have Atomics and 16-bit floating

00:41:30.526 --> 00:41:30.836
points.

00:41:31.256 --> 00:41:35.306
So that's just part of all the

00:41:35.306 --> 00:41:36.556
new features in Xcode.

00:41:37.306 --> 00:41:39.356
So from ARC object pointers in C

00:41:39.356 --> 00:41:41.026
Structs to the improved static

00:41:41.026 --> 00:41:42.756
analyzer there are lots of great

00:41:42.796 --> 00:41:43.696
things in Xcode 10.

00:41:44.286 --> 00:41:45.986
And there are also some things

00:41:45.986 --> 00:41:47.176
that we didn't even talk about

00:41:47.516 --> 00:41:48.616
like for instance, over a

00:41:48.616 --> 00:41:50.446
hundred new warnings and support

00:41:50.446 --> 00:41:53.186
for C++ 17 standard library

00:41:53.186 --> 00:41:53.586
function.

00:41:55.496 --> 00:41:57.636
So if you want to learn more we

00:41:57.636 --> 00:41:59.226
have the video and the slides

00:41:59.226 --> 00:42:00.466
available on the website soon.

00:42:01.006 --> 00:42:01.826
And if you're here at the

00:42:01.826 --> 00:42:03.296
conference come join us at the

00:42:03.296 --> 00:42:04.146
lab this afternoon.

00:42:04.146 --> 00:42:04.756
Thank you.

00:42:05.516 --> 00:42:11.500
[ Applause ]
WEBVTT

00:00:07.516 --> 00:00:15.516
[ Music ]

00:00:16.516 --> 00:00:21.576
[ Applause ]

00:00:22.076 --> 00:00:22.436
>> Good morning.

00:00:24.016 --> 00:00:25.346
My name is Michael LeHew, and I

00:00:25.346 --> 00:00:26.436
worked on the collections for

00:00:26.436 --> 00:00:27.726
the foundations team at Apple.

00:00:27.726 --> 00:00:30.876
And today, I want to talk about

00:00:30.876 --> 00:00:31.946
specific things that you should

00:00:31.946 --> 00:00:33.036
know about to ensure that your

00:00:33.036 --> 00:00:34.526
use of collections in Swift is

00:00:34.526 --> 00:00:35.656
as effective as possible.

00:00:36.156 --> 00:00:38.276
I'm going to cover a lot of

00:00:38.276 --> 00:00:39.856
territory today about details

00:00:39.926 --> 00:00:42.046
and all aspects of collections

00:00:42.046 --> 00:00:43.136
available for use in Swift.

00:00:43.416 --> 00:00:44.596
We're going to explore some

00:00:44.646 --> 00:00:46.616
common pitfalls and how to avoid

00:00:46.616 --> 00:00:47.506
them including performance

00:00:47.506 --> 00:00:48.756
issues, and I'm also going to

00:00:48.756 --> 00:00:50.676
offer very specific advice about

00:00:50.676 --> 00:00:51.936
when to choose to use specific

00:00:51.936 --> 00:00:52.366
collections.

00:00:53.306 --> 00:00:53.996
So let's begin.

00:00:54.136 --> 00:00:57.336
I want you to imagine a world, a

00:00:57.696 --> 00:00:59.176
world without collections.

00:00:59.846 --> 00:01:03.146
And in this world, we may not

00:01:03.146 --> 00:01:04.816
have arrays, but it still has

00:01:04.926 --> 00:01:07.796
bears, but every time we need

00:01:07.796 --> 00:01:10.136
another bear, we're going to

00:01:10.136 --> 00:01:11.436
need to define another variable,

00:01:12.026 --> 00:01:13.296
and we want to do things with

00:01:13.296 --> 00:01:13.726
these bears.

00:01:13.726 --> 00:01:14.666
We're going to need to repeat

00:01:14.666 --> 00:01:15.266
ourselves.

00:01:16.306 --> 00:01:17.106
Pretty scary, right?

00:01:18.546 --> 00:01:19.236
It gets worse though.

00:01:19.236 --> 00:01:20.596
This world also doesn't have

00:01:20.636 --> 00:01:23.196
dictionaries, but thankfully

00:01:23.336 --> 00:01:25.016
being clever developers, we can

00:01:25.016 --> 00:01:25.766
work around that with the

00:01:25.766 --> 00:01:27.936
function, where we painstakingly

00:01:27.936 --> 00:01:29.246
define each case that we care

00:01:29.246 --> 00:01:31.586
about, and using this function

00:01:31.586 --> 00:01:32.546
is very similar to using a

00:01:32.546 --> 00:01:34.716
dictionary, except none of those

00:01:34.716 --> 00:01:35.926
dynamic capabilities that we

00:01:35.926 --> 00:01:36.136
need.

00:01:36.666 --> 00:01:37.676
But who likes a mutable state,

00:01:37.676 --> 00:01:37.906
right?

00:01:38.976 --> 00:01:40.536
Fortunately for us though, we

00:01:40.536 --> 00:01:41.356
don't live in this world.

00:01:42.146 --> 00:01:43.816
Thankfully our world has bears

00:01:43.946 --> 00:01:45.586
and collections along with a

00:01:45.646 --> 00:01:47.016
rich first-class syntax for

00:01:47.016 --> 00:01:47.546
defining them.

00:01:48.076 --> 00:01:51.086
And APIs that help us not repeat

00:01:51.086 --> 00:01:53.666
ourselves when we iterate or

00:01:53.926 --> 00:01:55.316
retrieve the elements that they

00:01:55.316 --> 00:01:55.886
may store.

00:01:57.336 --> 00:01:58.916
Collections are so pervasive and

00:01:58.916 --> 00:02:00.506
share so many common features

00:02:00.506 --> 00:02:01.686
and algorithms that in Swift

00:02:01.686 --> 00:02:03.036
they all conform to a common

00:02:03.036 --> 00:02:03.476
protocol.

00:02:04.036 --> 00:02:06.446
Not surprisingly, it's called

00:02:06.446 --> 00:02:06.876
collection.

00:02:06.876 --> 00:02:09.186
And in Swift, collections are

00:02:09.186 --> 00:02:10.675
sequences whose elements can be

00:02:10.675 --> 00:02:12.196
traversed multiple times,

00:02:12.426 --> 00:02:13.806
nondestructively, and whose

00:02:13.806 --> 00:02:15.106
elements can be accessed via a

00:02:15.106 --> 00:02:15.606
subscript.

00:02:17.576 --> 00:02:19.106
Let's see, look at how they do

00:02:19.106 --> 00:02:20.446
that but considering an abstract

00:02:20.446 --> 00:02:21.736
representation of a collection.

00:02:23.026 --> 00:02:24.456
This could be an array defined

00:02:24.456 --> 00:02:26.006
contiguously in memory, a hash

00:02:26.076 --> 00:02:29.246
table, a red black tree, a link

00:02:29.246 --> 00:02:30.266
list or anything else that you

00:02:30.266 --> 00:02:30.776
can imagine.

00:02:31.516 --> 00:02:32.636
What matters is that it supports

00:02:32.636 --> 00:02:34.296
the concept of an initial index

00:02:34.296 --> 00:02:35.386
called start index.

00:02:36.796 --> 00:02:38.426
It can be used to access the

00:02:38.426 --> 00:02:39.306
initial element of the

00:02:39.306 --> 00:02:39.806
collection.

00:02:40.556 --> 00:02:41.736
It has an end index, which

00:02:41.736 --> 00:02:42.646
identifies the end of the

00:02:42.646 --> 00:02:44.746
collection, and collections

00:02:44.746 --> 00:02:46.166
support the ability to iterate

00:02:46.166 --> 00:02:47.546
from their start index to their

00:02:47.546 --> 00:02:48.286
end index.

00:02:49.476 --> 00:02:51.056
They can do this multiple times,

00:02:51.426 --> 00:02:52.396
and they also support a

00:02:52.396 --> 00:02:54.646
subscript to retrieve elements

00:02:54.676 --> 00:02:55.876
from the collection itself.

00:02:56.456 --> 00:02:58.336
Let's see what this looks like

00:02:58.336 --> 00:02:58.746
in code.

00:02:59.736 --> 00:03:00.606
Indeed, if we look at the

00:03:00.606 --> 00:03:02.326
definition of collection, it's

00:03:02.326 --> 00:03:03.256
declared as a sequence of

00:03:03.256 --> 00:03:03.716
elements.

00:03:04.836 --> 00:03:05.916
It also has an additional

00:03:05.916 --> 00:03:07.736
associated type called index,

00:03:07.836 --> 00:03:08.936
which must be comparable.

00:03:10.216 --> 00:03:11.656
It offers a subscript to

00:03:11.656 --> 00:03:13.316
retrieve elements from, or using

00:03:13.316 --> 00:03:15.196
that index, and we define a

00:03:15.196 --> 00:03:16.306
start and an end index

00:03:16.456 --> 00:03:18.076
identifying the bounds of our

00:03:18.076 --> 00:03:18.576
collection.

00:03:18.926 --> 00:03:21.076
And finally, we have a function

00:03:21.136 --> 00:03:22.766
called index after, which lets

00:03:22.766 --> 00:03:24.366
us get from one index to

00:03:24.366 --> 00:03:24.656
another.

00:03:24.706 --> 00:03:27.096
And this last function is so

00:03:27.096 --> 00:03:28.656
important because it allows the

00:03:28.656 --> 00:03:30.756
standard library to define many

00:03:30.756 --> 00:03:32.136
useful and powerful default

00:03:32.136 --> 00:03:33.596
behaviors with the incredible

00:03:33.596 --> 00:03:35.006
power of protocol extensions.

00:03:35.476 --> 00:03:38.266
Let's look at some of these.

00:03:38.426 --> 00:03:39.956
When you conform to collection,

00:03:39.956 --> 00:03:41.566
you gain access to an incredible

00:03:41.566 --> 00:03:42.916
range of functionality with

00:03:42.916 --> 00:03:44.966
properties that let you get the

00:03:44.966 --> 00:03:46.296
first and the last element or

00:03:46.426 --> 00:03:48.636
identify the count or check to

00:03:48.636 --> 00:03:49.706
see if a collection is empty.

00:03:50.466 --> 00:03:51.626
You also gain API that lets you

00:03:51.626 --> 00:03:52.676
iterate through a Collection

00:03:52.776 --> 00:03:54.216
using 4N syntax.

00:03:55.216 --> 00:03:56.886
And super useful functions like

00:03:56.886 --> 00:03:58.226
map, filter, and reduce.

00:03:59.256 --> 00:03:59.976
Now let's go ahead and make

00:03:59.976 --> 00:04:01.356
Collection even more powerful by

00:04:01.356 --> 00:04:02.426
adding our own extension.

00:04:03.736 --> 00:04:05.026
Collection already provides a

00:04:05.026 --> 00:04:06.236
way to iterate through every

00:04:06.236 --> 00:04:08.786
element, but I want a function

00:04:08.786 --> 00:04:09.646
that will let me iterate through

00:04:09.646 --> 00:04:11.066
every other element, skipping

00:04:11.066 --> 00:04:12.266
some of the values along the way

00:04:13.496 --> 00:04:14.616
and will do this by adding an

00:04:14.616 --> 00:04:15.626
extension to Collection.

00:04:16.036 --> 00:04:16.935
Let's start with the methods

00:04:16.935 --> 00:04:17.375
signature.

00:04:18.136 --> 00:04:19.136
We're going to call our function

00:04:19.266 --> 00:04:20.305
every other, and it's going to

00:04:20.305 --> 00:04:21.555
take a closure that will call on

00:04:21.555 --> 00:04:23.126
each element that we care about.

00:04:24.126 --> 00:04:25.016
We'll get the bounds of our

00:04:25.016 --> 00:04:27.486
iteration, and to find another

00:04:27.486 --> 00:04:29.236
variable, that starts at the

00:04:29.236 --> 00:04:30.326
start, which will mutate along

00:04:30.326 --> 00:04:30.826
as we go.

00:04:32.106 --> 00:04:33.506
We'll call the closure on the

00:04:33.506 --> 00:04:36.016
current element and advance our

00:04:36.016 --> 00:04:37.266
current index to the next one.

00:04:37.866 --> 00:04:39.076
And we may have invalidated our

00:04:39.076 --> 00:04:40.086
index at this point, we may have

00:04:40.086 --> 00:04:40.576
reached the end of the

00:04:40.576 --> 00:04:41.536
collection, so we need to make

00:04:41.536 --> 00:04:43.626
sure that we did that, and if we

00:04:43.626 --> 00:04:44.906
did, we can then advance our

00:04:44.906 --> 00:04:46.716
index one more time and thus

00:04:46.716 --> 00:04:47.886
skip every other element.

00:04:48.326 --> 00:04:49.726
And if we call this we see, if

00:04:49.726 --> 00:04:50.976
we call this on the close range

00:04:51.136 --> 00:04:53.066
from one to ten, we see that we

00:04:53.066 --> 00:04:54.236
skip the even elements.

00:04:54.646 --> 00:04:56.926
And so we see that Collections

00:04:56.926 --> 00:04:58.236
let us describe some really

00:04:58.236 --> 00:05:00.616
powerful behavior, but it turns

00:05:00.616 --> 00:05:02.216
out collections aren't alone.

00:05:02.296 --> 00:05:03.136
In fact, Collection is not the

00:05:03.136 --> 00:05:04.086
only protocol that we have.

00:05:04.086 --> 00:05:05.526
In Swift, we have access to a

00:05:05.636 --> 00:05:07.286
rich hierarchy of collection

00:05:07.286 --> 00:05:08.356
protocols, each greatly

00:05:08.356 --> 00:05:09.286
improving on the kinds of

00:05:09.286 --> 00:05:10.276
assumptions that we can make

00:05:10.276 --> 00:05:11.076
about our types.

00:05:11.706 --> 00:05:12.576
Let's go ahead and talk about a

00:05:12.576 --> 00:05:13.226
couple of these.

00:05:13.546 --> 00:05:15.896
We've already established that

00:05:15.896 --> 00:05:17.356
Collection lets you go forward

00:05:17.356 --> 00:05:19.866
from a given index, but there

00:05:19.866 --> 00:05:20.886
are also bidirectional

00:05:20.886 --> 00:05:22.406
collections, which let you go in

00:05:22.406 --> 00:05:24.826
the other direction.

00:05:24.896 --> 00:05:26.086
Now, of course, bidirectional

00:05:26.086 --> 00:05:27.196
collections are collections

00:05:27.246 --> 00:05:28.636
themselves, and so we can still

00:05:28.636 --> 00:05:29.726
iterate forward as well.

00:05:31.336 --> 00:05:32.836
The next most flexible form of

00:05:32.836 --> 00:05:34.086
collection is what's known as a

00:05:34.086 --> 00:05:35.506
random access collection, and

00:05:35.506 --> 00:05:36.926
with these, these add the

00:05:36.926 --> 00:05:38.266
requirement that it would be

00:05:38.266 --> 00:05:40.386
constant time to compute, or

00:05:40.386 --> 00:05:41.646
compute another index from

00:05:41.646 --> 00:05:42.606
another or to compute the

00:05:42.606 --> 00:05:43.886
distance between two indexes.

00:05:44.456 --> 00:05:45.856
The compiler cannot enforce

00:05:45.926 --> 00:05:47.486
this, and so when you conform to

00:05:47.486 --> 00:05:48.466
random acts as a collection,

00:05:48.646 --> 00:05:49.756
you're making a promise.

00:05:49.996 --> 00:05:51.796
But if you satisfy this promise,

00:05:51.796 --> 00:05:52.516
if you can deliver on this

00:05:52.516 --> 00:05:53.806
promise, the protocol gives you

00:05:53.806 --> 00:05:55.386
the power to access any index in

00:05:55.386 --> 00:05:57.186
the collection in constant time.

00:05:57.966 --> 00:05:59.046
And of course, random access

00:05:59.046 --> 00:06:00.426
collections remain collections,

00:06:00.426 --> 00:06:01.316
and so you can still iterate

00:06:01.316 --> 00:06:02.536
forward and backward.

00:06:02.606 --> 00:06:05.796
Now as Swift developers, we have

00:06:05.796 --> 00:06:06.896
access to many useful

00:06:06.896 --> 00:06:08.046
collections that conform to

00:06:08.046 --> 00:06:10.626
these protocols, collections

00:06:10.626 --> 00:06:11.666
such as array, set, and

00:06:11.666 --> 00:06:12.186
dictionary.

00:06:12.656 --> 00:06:14.836
But thanks to the general

00:06:14.836 --> 00:06:15.746
purpose utility of these

00:06:15.746 --> 00:06:17.006
protocols, many other types

00:06:17.196 --> 00:06:18.696
conform to these collection

00:06:18.696 --> 00:06:20.186
protocols as well, such as data,

00:06:20.476 --> 00:06:21.416
range, and string.

00:06:22.566 --> 00:06:24.356
Or the index collections, and

00:06:24.356 --> 00:06:25.546
they all gain access to all of

00:06:25.546 --> 00:06:26.816
this rich functionality by

00:06:26.816 --> 00:06:28.216
simply conforming to Collection

00:06:28.216 --> 00:06:29.036
in their own fashion.

00:06:29.346 --> 00:06:31.006
Indeed, once you know how any

00:06:31.006 --> 00:06:32.246
one of these types works, you

00:06:32.246 --> 00:06:33.616
can apply that knowledge to any

00:06:33.616 --> 00:06:35.326
of the others, and there are

00:06:35.326 --> 00:06:35.886
quite a few.

00:06:35.916 --> 00:06:38.006
So I'm going to talk about the

00:06:38.006 --> 00:06:39.586
details about how a type

00:06:39.586 --> 00:06:41.166
conforms to Collection, and it

00:06:41.166 --> 00:06:43.456
all begins with describing how

00:06:43.666 --> 00:06:46.376
it is indexed.

00:06:46.446 --> 00:06:47.746
Each collection has its own kind

00:06:47.746 --> 00:06:48.336
of index.

00:06:48.856 --> 00:06:50.766
And that index must be

00:06:50.766 --> 00:06:51.306
comparable.

00:06:52.286 --> 00:06:54.306
In some cases, the indices can

00:06:54.306 --> 00:06:56.446
look like integers, like arrays,

00:06:56.716 --> 00:06:57.566
but just because an index

00:06:57.566 --> 00:06:58.736
happens to look like an integer

00:06:58.896 --> 00:06:59.956
doesn't mean that you should use

00:06:59.956 --> 00:07:00.456
it like one.

00:07:01.436 --> 00:07:02.186
Now I want to ask a few

00:07:02.186 --> 00:07:03.396
questions that might have

00:07:03.396 --> 00:07:04.386
surprising answers.

00:07:05.056 --> 00:07:06.116
The first is how do we get the

00:07:06.116 --> 00:07:08.926
first element of an array, and

00:07:08.996 --> 00:07:10.496
instantly you probably all

00:07:10.566 --> 00:07:11.786
thought, well I'll just call

00:07:11.786 --> 00:07:12.456
array subzero.

00:07:12.526 --> 00:07:14.196
An array's index happens to be

00:07:14.196 --> 00:07:14.386
it.

00:07:14.766 --> 00:07:16.236
So you can sometimes say this

00:07:16.366 --> 00:07:17.586
and get exactly what you intend.

00:07:18.036 --> 00:07:19.106
But it isn't the best way to do

00:07:19.106 --> 00:07:19.446
this.

00:07:19.636 --> 00:07:20.636
I'm going to go ahead and ask

00:07:20.676 --> 00:07:22.026
the same question, but this time

00:07:22.196 --> 00:07:23.166
about a different collection.

00:07:23.666 --> 00:07:26.056
What's the first element of a

00:07:26.056 --> 00:07:26.246
set?

00:07:26.986 --> 00:07:27.856
Now this might seem like a

00:07:27.856 --> 00:07:29.276
really weird question, right?

00:07:29.576 --> 00:07:30.356
Sets are unordered.

00:07:31.016 --> 00:07:32.236
However, they are collections,

00:07:32.376 --> 00:07:33.286
and being collections, you can

00:07:33.286 --> 00:07:34.706
iterate through them, and when

00:07:34.706 --> 00:07:35.576
you iterate through a set,

00:07:35.636 --> 00:07:36.886
you're going to iterate through

00:07:36.886 --> 00:07:38.156
one element first, and so that's

00:07:38.156 --> 00:07:39.326
really the question we're asking

00:07:39.396 --> 00:07:39.586
here.

00:07:40.896 --> 00:07:42.026
So can I say set subzero?

00:07:42.856 --> 00:07:44.306
Happily, the compiler will say

00:07:44.306 --> 00:07:46.986
no, and that's because set's

00:07:46.986 --> 00:07:49.346
index type is an int, the type

00:07:49.346 --> 00:07:50.446
system wants us to use the

00:07:50.446 --> 00:07:52.816
correct index type.

00:07:52.996 --> 00:07:54.016
Lucky for us we already know how

00:07:54.016 --> 00:07:54.486
to do that.

00:07:54.796 --> 00:07:55.796
We know the collection protocol

00:07:55.796 --> 00:07:56.856
tells us that all collections

00:07:56.856 --> 00:07:58.266
have a start index, so let's go

00:07:58.266 --> 00:07:59.286
ahead and use that, and if we do

00:07:59.286 --> 00:08:00.496
this, this will actually work

00:08:00.496 --> 00:08:01.326
with all collections.

00:08:01.496 --> 00:08:03.076
Start index is always going to

00:08:03.076 --> 00:08:05.246
be the element of the first item

00:08:05.246 --> 00:08:05.966
that you would see when you

00:08:05.966 --> 00:08:06.336
iterate.

00:08:06.986 --> 00:08:08.056
But there's a nuance to watch

00:08:08.056 --> 00:08:09.626
out for when using indices to

00:08:09.626 --> 00:08:10.896
directly subscript into any

00:08:10.896 --> 00:08:11.356
collection.

00:08:11.636 --> 00:08:14.966
And that is, it can crash.

00:08:15.216 --> 00:08:17.146
I haven't actually asserted that

00:08:17.146 --> 00:08:18.356
these collections have contents

00:08:18.356 --> 00:08:20.056
in them, and so when you're, I'm

00:08:20.216 --> 00:08:21.276
just using start index, and

00:08:21.276 --> 00:08:22.126
these collections could be

00:08:22.126 --> 00:08:22.426
empty.

00:08:23.636 --> 00:08:24.416
It turns out though that

00:08:24.416 --> 00:08:25.616
accessing the first element in a

00:08:25.616 --> 00:08:27.996
collection is such a common task

00:08:28.206 --> 00:08:30.866
that there's an even better way.

00:08:31.076 --> 00:08:32.236
Simply call first.

00:08:32.885 --> 00:08:34.346
And if you call first, this is a

00:08:34.346 --> 00:08:35.756
lot safer, because the return

00:08:35.756 --> 00:08:37.056
time of this is optional,

00:08:37.326 --> 00:08:38.676
reflecting the fact that not all

00:08:38.676 --> 00:08:39.606
collections have a first

00:08:39.606 --> 00:08:39.956
element.

00:08:39.956 --> 00:08:43.285
So I have another question.

00:08:44.526 --> 00:08:45.696
It's the second element of a

00:08:45.696 --> 00:08:46.796
collection, and I want to

00:08:46.796 --> 00:08:48.116
emphasize collection here.

00:08:48.306 --> 00:08:49.606
It could be any collection, an

00:08:49.606 --> 00:08:50.626
array, a set, or something that

00:08:50.626 --> 00:08:51.626
doesn't even exist yet.

00:08:52.026 --> 00:08:53.796
Let's go ahead and add a new

00:08:53.876 --> 00:08:55.106
property to collection via

00:08:55.106 --> 00:08:55.976
protocol extension, and we'll

00:08:55.976 --> 00:08:57.566
call it second, and just like

00:08:57.636 --> 00:08:58.436
first, it's going to return

00:08:58.436 --> 00:08:59.556
optional, because not all

00:08:59.556 --> 00:09:00.936
collections have two elements.

00:09:02.216 --> 00:09:05.806
So, let's try writing this by

00:09:05.806 --> 00:09:06.496
subscripting 1.

00:09:06.846 --> 00:09:08.636
But here our zero-based indexing

00:09:08.636 --> 00:09:09.596
instincts are going to lead us

00:09:09.596 --> 00:09:11.056
astray, and then we'll be caught

00:09:11.056 --> 00:09:12.716
by the compiler again.

00:09:13.596 --> 00:09:14.906
We want this code to work with

00:09:14.906 --> 00:09:16.366
every collection, and not all

00:09:16.366 --> 00:09:17.636
collections use integers to

00:09:17.636 --> 00:09:18.156
index.

00:09:18.636 --> 00:09:19.946
So let's try a different

00:09:19.946 --> 00:09:20.336
approach.

00:09:21.226 --> 00:09:22.456
What I really want is one

00:09:22.456 --> 00:09:24.526
greater than the start index.

00:09:25.396 --> 00:09:26.806
But lucky here, the compiler

00:09:26.806 --> 00:09:27.886
will catch this as well.

00:09:29.126 --> 00:09:30.956
You can't add 1 to an arbitrary

00:09:30.956 --> 00:09:31.496
index type.

00:09:31.666 --> 00:09:32.826
Index types are supposed to be

00:09:32.826 --> 00:09:34.056
opaque or can be opaque.

00:09:34.056 --> 00:09:36.496
And what we really need to be

00:09:36.496 --> 00:09:37.836
doing here is we need to be

00:09:37.836 --> 00:09:38.826
using the API provided by the

00:09:38.826 --> 00:09:40.126
collection protocol to do this.

00:09:40.126 --> 00:09:41.456
So let's go ahead and do this.

00:09:42.746 --> 00:09:44.626
I commented out a sketch of the

00:09:44.626 --> 00:09:45.436
things that we're going to need

00:09:45.436 --> 00:09:46.216
to do to find the second

00:09:46.216 --> 00:09:46.596
element.

00:09:47.246 --> 00:09:48.066
The very first thing that we

00:09:48.066 --> 00:09:48.966
need to do is we need to check

00:09:48.966 --> 00:09:49.866
to see if the collection is

00:09:49.906 --> 00:09:50.226
empty.

00:09:51.076 --> 00:09:52.056
Collections are empty when their

00:09:52.056 --> 00:09:53.236
start index is exactly

00:09:53.236 --> 00:09:54.616
equivalent to their end index.

00:09:54.906 --> 00:09:56.106
So let's check for that and

00:09:56.106 --> 00:09:57.796
return nil, because such a

00:09:57.796 --> 00:10:00.536
collection doesn't have a second

00:10:00.536 --> 00:10:00.866
element.

00:10:01.486 --> 00:10:04.166
Oh, and so now we can assume

00:10:04.166 --> 00:10:05.486
that our collection has one

00:10:05.486 --> 00:10:06.156
element in it.

00:10:06.596 --> 00:10:09.356
We can use index after to get

00:10:09.356 --> 00:10:10.666
the second element or the second

00:10:10.666 --> 00:10:12.316
index, but we need to make sure

00:10:12.316 --> 00:10:14.286
that that index is valid, and

00:10:14.286 --> 00:10:15.206
let's see this visually.

00:10:15.326 --> 00:10:16.506
We advance after, but if the

00:10:16.506 --> 00:10:17.646
collection only had one element

00:10:17.646 --> 00:10:18.856
in it, we have now actually

00:10:18.856 --> 00:10:19.966
produced an invalid index, and

00:10:19.966 --> 00:10:20.886
if we tried to subscript with

00:10:20.886 --> 00:10:22.076
that index, we'd get that fatal

00:10:22.076 --> 00:10:23.056
error that we saw just a moment

00:10:23.056 --> 00:10:23.246
ago.

00:10:23.696 --> 00:10:24.786
So we check for it to be valid,

00:10:24.786 --> 00:10:25.796
and this is very similar to the

00:10:25.796 --> 00:10:26.066
empty [inaudible].

00:10:26.296 --> 00:10:27.756
We just make sure that our index

00:10:28.096 --> 00:10:29.376
is not equal to the end index

00:10:29.516 --> 00:10:30.096
returning nil.

00:10:30.626 --> 00:10:31.786
Again, because two-element

00:10:31.786 --> 00:10:33.276
collections don't have a, or

00:10:33.276 --> 00:10:34.336
one-element collections don't

00:10:34.336 --> 00:10:35.196
have a second element.

00:10:35.996 --> 00:10:36.956
At this point, we have all the

00:10:36.956 --> 00:10:38.296
assumptions we need to know that

00:10:38.296 --> 00:10:39.386
our collection has at least two

00:10:39.386 --> 00:10:40.746
elements in it, and so we're

00:10:40.746 --> 00:10:41.696
safe to use the subscript

00:10:41.696 --> 00:10:42.696
operator with that index,

00:10:43.906 --> 00:10:44.856
retrieving the value that we

00:10:44.856 --> 00:10:45.236
desire.

00:10:45.236 --> 00:10:48.736
Now, it turns out, or that looks

00:10:48.736 --> 00:10:50.436
like a lot of code, but it's

00:10:50.506 --> 00:10:51.576
worth pointing out that this

00:10:51.576 --> 00:10:53.016
general purpose index math will

00:10:53.016 --> 00:10:54.546
work with any collection, which

00:10:54.546 --> 00:10:56.266
is pretty awesome, and it turns

00:10:56.266 --> 00:10:57.786
out Swift has a better way to do

00:10:57.786 --> 00:10:58.106
this though.

00:10:58.856 --> 00:11:00.216
There's something called slices,

00:11:00.606 --> 00:11:01.716
but before I show how to do it

00:11:01.756 --> 00:11:02.946
with slices, I want to talk

00:11:02.946 --> 00:11:04.826
about what slices are and how

00:11:04.826 --> 00:11:05.000
they work.

00:11:08.266 --> 00:11:10.946
Slices are a type that describe

00:11:10.946 --> 00:11:11.946
only part of a collection.

00:11:13.176 --> 00:11:14.476
And every slice has their own

00:11:14.476 --> 00:11:17.606
start and end index, and slices

00:11:17.606 --> 00:11:18.556
exist separately from the

00:11:18.556 --> 00:11:19.956
collections, from their

00:11:19.986 --> 00:11:20.916
originating collection.

00:11:21.336 --> 00:11:22.526
And what makes slices so

00:11:22.526 --> 00:11:23.746
efficient is they occupy no

00:11:23.746 --> 00:11:24.406
extra storage.

00:11:24.536 --> 00:11:25.806
They simply refer back to the

00:11:25.806 --> 00:11:28.856
original collection, and when

00:11:28.856 --> 00:11:30.416
slices are subscripted, they

00:11:30.416 --> 00:11:31.586
read out of the original buffer.

00:11:32.806 --> 00:11:33.736
And they can do this because

00:11:34.796 --> 00:11:36.046
they share the same indices as

00:11:36.046 --> 00:11:37.016
their underlying collection.

00:11:37.466 --> 00:11:38.286
And let's take a look at how

00:11:38.286 --> 00:11:38.706
that works.

00:11:38.706 --> 00:11:39.806
We can prove this to ourselves.

00:11:40.136 --> 00:11:41.976
We'll start with an array, and

00:11:41.976 --> 00:11:43.296
we'll ask that array to drop its

00:11:43.296 --> 00:11:45.356
first element, producing a slice

00:11:45.386 --> 00:11:46.286
that's one element shorter.

00:11:46.636 --> 00:11:47.916
And because we care about

00:11:48.116 --> 00:11:49.546
proving about the indices, we'll

00:11:49.546 --> 00:11:50.926
actually get the second index of

00:11:50.926 --> 00:11:52.836
the array by asking to advance

00:11:53.046 --> 00:11:54.576
one after the start index, and

00:11:54.576 --> 00:11:55.426
then we'll compare those.

00:11:55.466 --> 00:11:58.446
And indeed, they are the same.

00:11:58.546 --> 00:11:59.696
Now this dropfirst function

00:11:59.696 --> 00:12:00.836
looks exactly like we need to

00:12:00.836 --> 00:12:01.836
succinctly get the second

00:12:01.836 --> 00:12:02.816
element of our collection.

00:12:03.796 --> 00:12:04.816
So let's go back to our previous

00:12:04.816 --> 00:12:05.806
solution, and see how much more

00:12:05.806 --> 00:12:06.616
expressive we can be with

00:12:06.616 --> 00:12:07.146
slices.

00:12:08.396 --> 00:12:10.536
Remember all that fancy index

00:12:10.536 --> 00:12:11.166
[inaudible] code we had to write

00:12:11.166 --> 00:12:11.516
earlier?

00:12:12.806 --> 00:12:14.166
Well, by using dropfirst, we're

00:12:14.166 --> 00:12:15.326
going to let slices take care of

00:12:15.326 --> 00:12:16.686
all that fancy index bounds

00:12:16.686 --> 00:12:17.386
checking for us.

00:12:17.736 --> 00:12:19.156
And since first returns an

00:12:19.156 --> 00:12:21.606
optional, this will work as

00:12:21.606 --> 00:12:23.556
expected with empty and single

00:12:23.556 --> 00:12:24.486
element collections.

00:12:25.116 --> 00:12:26.206
Let's visualize what's happening

00:12:26.206 --> 00:12:26.376
here.

00:12:27.686 --> 00:12:29.156
We start with an array, and we

00:12:29.156 --> 00:12:30.496
form a slice by dropping the

00:12:30.496 --> 00:12:31.096
first element.

00:12:32.386 --> 00:12:34.906
We then use the first property

00:12:35.696 --> 00:12:37.626
to subscript into the slice,

00:12:37.776 --> 00:12:38.716
retrieving the element from the

00:12:38.716 --> 00:12:39.416
original collection.

00:12:39.536 --> 00:12:40.826
Now I don't know about you, but

00:12:40.826 --> 00:12:42.996
I'd much rather maintain this

00:12:43.616 --> 00:12:44.126
code.

00:12:44.946 --> 00:12:46.026
Now every type is free to

00:12:46.026 --> 00:12:47.446
describe its own slice type, and

00:12:47.446 --> 00:12:48.046
many do.

00:12:48.596 --> 00:12:50.076
For instance, arrays define

00:12:50.486 --> 00:12:51.766
array slices that are especially

00:12:51.766 --> 00:12:52.846
attuned to the most common use

00:12:52.846 --> 00:12:54.446
cases that arrays work with.

00:12:54.976 --> 00:12:57.396
Similarly, string defines a

00:12:57.396 --> 00:12:59.096
substring slice type, and

00:12:59.096 --> 00:13:00.706
substrings, again, are tuned to

00:13:00.706 --> 00:13:01.806
the special cases that are most

00:13:01.806 --> 00:13:02.396
common with strings.

00:13:03.406 --> 00:13:06.196
Some types, like set, will make

00:13:06.196 --> 00:13:07.746
use of the generalized slice

00:13:07.846 --> 00:13:08.766
type defined in the standard

00:13:08.766 --> 00:13:09.106
library.

00:13:09.256 --> 00:13:10.096
That's because sets are

00:13:10.096 --> 00:13:10.516
unordered.

00:13:10.516 --> 00:13:11.506
There's not very much else that

00:13:11.506 --> 00:13:11.886
they can do.

00:13:11.886 --> 00:13:12.806
They just basically need to

00:13:12.806 --> 00:13:13.976
maintain a start and an end

00:13:13.976 --> 00:13:14.906
index [inaudible] to the

00:13:14.906 --> 00:13:15.896
original collection.

00:13:16.906 --> 00:13:18.576
Data and range on the other hand

00:13:18.576 --> 00:13:20.426
are their own slice types, and

00:13:20.426 --> 00:13:21.736
so there's a lot of options that

00:13:21.736 --> 00:13:22.326
you have here.

00:13:22.756 --> 00:13:24.106
And there's one more thing about

00:13:24.106 --> 00:13:25.166
slices that I want to talk about

00:13:25.166 --> 00:13:25.846
before we move on.

00:13:26.366 --> 00:13:28.576
Let's suppose that we had a

00:13:28.716 --> 00:13:29.986
really large collection, like

00:13:30.176 --> 00:13:31.276
thousands and thousands and

00:13:31.276 --> 00:13:32.166
thousands of elements.

00:13:32.806 --> 00:13:34.016
And we add a couple of small

00:13:34.016 --> 00:13:34.976
slices to parts of that

00:13:34.976 --> 00:13:35.476
collection.

00:13:36.666 --> 00:13:37.746
It's important to remember that

00:13:37.746 --> 00:13:39.586
the slice keeps the entirety of

00:13:39.586 --> 00:13:41.506
the originating collection alive

00:13:41.506 --> 00:13:43.206
as long as the slice is around.

00:13:43.286 --> 00:13:44.506
And this can lead to surprising

00:13:44.506 --> 00:13:44.996
problems.

00:13:45.226 --> 00:13:46.426
Let see how this works in code.

00:13:47.836 --> 00:13:49.296
Let's suppose I have an

00:13:49.296 --> 00:13:50.196
extension on an array that

00:13:50.196 --> 00:13:51.226
allows me to return the first

00:13:51.226 --> 00:13:53.816
half, and I'm using the droplast

00:13:53.816 --> 00:13:55.236
function here to do so.

00:13:55.806 --> 00:13:56.806
And we have an array of eight

00:13:56.806 --> 00:13:58.096
numbers, and we call our

00:13:58.096 --> 00:14:00.526
extension, producing the slice,

00:14:00.976 --> 00:14:01.986
and then to try to get rid of

00:14:01.986 --> 00:14:03.326
that original storage of eight

00:14:03.386 --> 00:14:05.006
numbers, I go ahead and assign

00:14:05.006 --> 00:14:06.026
that array to an empty array.

00:14:06.546 --> 00:14:08.786
Our first clue that something

00:14:09.296 --> 00:14:11.096
interesting is happening occurs

00:14:11.096 --> 00:14:12.246
when we ask our slice for its

00:14:12.246 --> 00:14:12.816
first element.

00:14:13.536 --> 00:14:14.636
We're somehow able to return

00:14:14.636 --> 00:14:16.576
one, even though we threw away

00:14:16.576 --> 00:14:18.876
the storage for the original

00:14:18.876 --> 00:14:19.086
array.

00:14:19.596 --> 00:14:20.906
Either there was a copy or

00:14:20.906 --> 00:14:22.336
something magical is going on.

00:14:23.356 --> 00:14:25.946
And so if we wanted to eliminate

00:14:25.946 --> 00:14:27.566
that buffer though, and oh the

00:14:27.566 --> 00:14:28.646
magic that's actually going on

00:14:28.646 --> 00:14:29.466
is that we're holding onto the

00:14:29.466 --> 00:14:29.796
buffer.

00:14:30.166 --> 00:14:31.196
And so if we wanted to eliminate

00:14:31.196 --> 00:14:32.196
that, what we could do is we

00:14:32.196 --> 00:14:34.136
could form an actual copy of the

00:14:34.136 --> 00:14:36.166
array from the slice, and then

00:14:36.166 --> 00:14:37.826
if we set that slice to an empty

00:14:37.826 --> 00:14:39.666
array itself, that copy would

00:14:39.666 --> 00:14:40.306
still be valid.

00:14:41.466 --> 00:14:42.346
Let's visualize what just

00:14:42.346 --> 00:14:42.606
happened.

00:14:43.106 --> 00:14:44.546
We started with an array.

00:14:45.096 --> 00:14:46.346
We then formed a slice on the

00:14:46.346 --> 00:14:47.886
first half of that array.

00:14:49.576 --> 00:14:52.146
We then created a copy of that,

00:14:52.506 --> 00:14:53.586
setting the array to be empty

00:14:53.906 --> 00:14:54.816
and setting that slice to be

00:14:54.816 --> 00:14:55.176
empty.

00:14:55.176 --> 00:14:57.936
And only after we did that did

00:14:57.936 --> 00:14:59.046
the underlying storage go away.

00:14:59.046 --> 00:15:02.716
So in this matter, slices sort

00:15:02.716 --> 00:15:03.876
of work like lazy copies.

00:15:04.256 --> 00:15:05.966
You get to choose when you make

00:15:05.966 --> 00:15:07.416
a copy of the elements yourself,

00:15:08.246 --> 00:15:09.016
and it turns out that this

00:15:09.016 --> 00:15:10.646
concept of being lazy and doing

00:15:10.646 --> 00:15:12.946
something later is really useful

00:15:12.946 --> 00:15:14.156
in other contexts too.

00:15:15.566 --> 00:15:17.386
One such context is function

00:15:17.386 --> 00:15:17.746
calls.

00:15:18.816 --> 00:15:20.316
Now function calls in Swift are

00:15:20.316 --> 00:15:21.216
eager by default.

00:15:22.056 --> 00:15:23.326
That is, they consume their

00:15:23.326 --> 00:15:25.626
input and return their output as

00:15:25.696 --> 00:15:26.156
demanded.

00:15:27.056 --> 00:15:28.236
Consider this example.

00:15:28.596 --> 00:15:29.776
We start with a range from one

00:15:29.776 --> 00:15:31.506
to 4000, and ranges are a really

00:15:31.556 --> 00:15:32.836
succinct way of representing a

00:15:32.836 --> 00:15:33.516
lot of numbers.

00:15:33.906 --> 00:15:35.266
It's just a start and an end,

00:15:35.266 --> 00:15:36.586
and it knows how to produce

00:15:36.846 --> 00:15:36.936
them.

00:15:37.336 --> 00:15:38.516
We then map this though

00:15:38.516 --> 00:15:39.836
multiplying each value by two,

00:15:39.836 --> 00:15:40.916
and so we've now actually

00:15:40.916 --> 00:15:42.026
allocated an array of 4000

00:15:42.026 --> 00:15:43.536
elements and performed our

00:15:43.536 --> 00:15:45.456
mapping function on each of

00:15:45.456 --> 00:15:45.626
them.

00:15:46.396 --> 00:15:47.676
We then filter that down to four

00:15:47.676 --> 00:15:48.126
elements.

00:15:48.746 --> 00:15:49.586
And so at this point, we've

00:15:49.586 --> 00:15:50.476
actually gone ahead and

00:15:50.476 --> 00:15:53.746
allocated 4004, you know, space

00:15:53.746 --> 00:15:56.636
for 4004 elements, but we only

00:15:56.636 --> 00:15:57.696
really needed the final four.

00:15:58.216 --> 00:16:01.256
And that's an awful lot of

00:16:01.256 --> 00:16:02.786
intermediate computation that

00:16:02.786 --> 00:16:03.936
maybe we don't always desire.

00:16:04.546 --> 00:16:05.586
It would be great if there was a

00:16:05.586 --> 00:16:06.636
way just to not do any of it,

00:16:07.066 --> 00:16:08.246
unless it was absolutely needed.

00:16:08.736 --> 00:16:11.316
And Swift's answer for that is

00:16:11.316 --> 00:16:12.616
called being lazy, just like in

00:16:12.616 --> 00:16:12.966
real life.

00:16:14.756 --> 00:16:15.736
We'll start as we did before

00:16:15.736 --> 00:16:18.296
with the range, and then we'll

00:16:18.296 --> 00:16:19.706
tell that range to be lazy.

00:16:19.706 --> 00:16:20.746
And when we do this, what

00:16:20.746 --> 00:16:23.076
happens is we wrap the original

00:16:23.076 --> 00:16:25.026
collection with a lazy

00:16:25.026 --> 00:16:26.586
collection, and when we perform

00:16:26.586 --> 00:16:27.996
operations on this lazy

00:16:27.996 --> 00:16:29.036
collection, what's going to

00:16:29.036 --> 00:16:30.276
happen is we're going to wrap it

00:16:30.276 --> 00:16:30.566
again.

00:16:30.566 --> 00:16:32.176
And so when we wrap the, when we

00:16:32.176 --> 00:16:33.236
call map on it, we actually

00:16:33.536 --> 00:16:34.096
aren't mapping.

00:16:34.346 --> 00:16:35.166
We're not doing anything with

00:16:35.166 --> 00:16:36.156
that closure other than storing

00:16:36.156 --> 00:16:37.306
it for later should we ever need

00:16:37.306 --> 00:16:37.746
to use it.

00:16:38.566 --> 00:16:40.396
Further, if I filter that lazy

00:16:40.396 --> 00:16:41.806
map collection, the filter

00:16:41.806 --> 00:16:43.546
simply wraps the map collection,

00:16:43.806 --> 00:16:44.816
noting that it's going to filter

00:16:44.816 --> 00:16:46.236
later on demand, but not right

00:16:46.236 --> 00:16:46.476
now.

00:16:47.896 --> 00:16:49.426
Now let's go ahead and ask our

00:16:49.426 --> 00:16:50.696
lazy filter collection for it's

00:16:50.696 --> 00:16:51.326
first element.

00:16:55.236 --> 00:16:58.056
When we do this, we'll start by

00:16:58.056 --> 00:16:59.006
asking the lazy filter

00:16:59.006 --> 00:16:59.776
collection for it's first

00:16:59.776 --> 00:17:01.406
element, but the lazy filter

00:17:01.406 --> 00:17:02.286
collection doesn't know.

00:17:02.996 --> 00:17:04.175
It wraps something that might

00:17:04.256 --> 00:17:04.435
know.

00:17:05.026 --> 00:17:06.006
And so it'll defer to the map

00:17:06.086 --> 00:17:06.536
collection.

00:17:06.596 --> 00:17:08.356
And the map collection also

00:17:08.596 --> 00:17:09.756
doesn't know it's first element,

00:17:10.205 --> 00:17:11.326
but it wraps a collection that

00:17:11.326 --> 00:17:12.876
might, and indeed, the range

00:17:12.876 --> 00:17:13.756
knows it's first element.

00:17:14.925 --> 00:17:16.296
The first element of the range

00:17:16.356 --> 00:17:17.816
is the value one, which it

00:17:17.816 --> 00:17:18.826
returns to the lazy map

00:17:18.876 --> 00:17:21.226
collection where now the lazy

00:17:21.226 --> 00:17:22.215
map collection can actually

00:17:22.215 --> 00:17:24.296
perform it's closure, computing

00:17:24.296 --> 00:17:26.126
the value 2, which it returns to

00:17:26.126 --> 00:17:27.506
the lazy filter collection as a

00:17:27.656 --> 00:17:28.716
candidatefirst element.

00:17:29.346 --> 00:17:31.096
Now lucky for us in this case, 2

00:17:31.096 --> 00:17:32.586
happens to be less than 10, and

00:17:32.586 --> 00:17:33.696
so the lazy filter collection

00:17:33.696 --> 00:17:35.076
finds it first element on the

00:17:35.076 --> 00:17:37.006
first try, which it returns back

00:17:37.006 --> 00:17:37.506
to its caller.

00:17:38.056 --> 00:17:40.096
Now that's a lot of different

00:17:40.096 --> 00:17:40.736
computation.

00:17:41.426 --> 00:17:43.346
And I mentioned that lazy aims

00:17:43.346 --> 00:17:44.906
to only do calculation as needed

00:17:44.906 --> 00:17:46.626
on demand, but another thing

00:17:46.626 --> 00:17:47.716
that it avoids is creating

00:17:47.716 --> 00:17:48.586
intermediate storage.

00:17:49.446 --> 00:17:51.216
So I want to show an example of

00:17:52.096 --> 00:17:52.236
that.

00:17:52.286 --> 00:17:53.426
Let's suppose we had an array of

00:17:53.426 --> 00:17:54.406
different kind of bears.

00:17:55.296 --> 00:17:57.206
However, I want to point out

00:17:57.206 --> 00:17:58.196
that some of these bears are

00:17:58.196 --> 00:17:58.636
redundant.

00:17:59.416 --> 00:18:00.176
We already know that they're

00:18:00.176 --> 00:18:00.706
bears.

00:18:01.016 --> 00:18:01.796
They don't need to tell us

00:18:01.796 --> 00:18:02.336
again.

00:18:03.376 --> 00:18:04.576
So let's write some code to find

00:18:04.576 --> 00:18:05.756
those silly, redundant bears,

00:18:05.756 --> 00:18:07.356
and we'll do this using a lazy

00:18:07.356 --> 00:18:08.366
filter, as before.

00:18:08.366 --> 00:18:11.996
And in this case, producing a

00:18:11.996 --> 00:18:13.206
lazy filter is going to be a

00:18:13.206 --> 00:18:14.676
lazy filter collection that

00:18:14.746 --> 00:18:16.156
wraps an array of strings.

00:18:16.716 --> 00:18:17.946
In our closer here, were going

00:18:17.946 --> 00:18:19.396
to print out which bear we're

00:18:19.396 --> 00:18:21.056
currently iterating on before we

00:18:21.056 --> 00:18:21.836
do our predicate check.

00:18:21.836 --> 00:18:23.006
And we're doing this because I

00:18:23.006 --> 00:18:24.146
want to understand how filter

00:18:24.146 --> 00:18:25.096
works a little better, and then

00:18:25.096 --> 00:18:26.806
we'll call first, and when we do

00:18:26.806 --> 00:18:28.116
this, we'll defer to the lazy

00:18:28.116 --> 00:18:31.446
filter collection, and then the

00:18:31.446 --> 00:18:32.726
lazy filter collection will in

00:18:32.776 --> 00:18:33.966
turn defer to the original

00:18:33.966 --> 00:18:37.226
storage where we'll print out

00:18:37.326 --> 00:18:41.476
Grizzly, check the predicate,

00:18:42.016 --> 00:18:43.496
which in this case is false,

00:18:43.496 --> 00:18:44.406
Grizzly does not contain the

00:18:44.406 --> 00:18:45.636
word bear, and advance on to

00:18:45.636 --> 00:18:45.976
panda.

00:18:47.336 --> 00:18:51.046
When we get to panda, when we

00:18:51.046 --> 00:18:52.456
get to panda, we'll again print

00:18:52.746 --> 00:18:54.596
out panda, check to see if it

00:18:54.596 --> 00:18:55.936
contains the word bear, and

00:18:55.936 --> 00:18:56.926
advance on to spectacle.

00:18:57.996 --> 00:19:00.006
Spectacle gets printed, also

00:19:00.006 --> 00:19:00.996
doesn't contain the word bear,

00:19:01.146 --> 00:19:02.346
and we advance finally to gummy

00:19:02.346 --> 00:19:04.936
bears, which mercifully has the

00:19:04.936 --> 00:19:07.046
word bear in it, and which the

00:19:07.046 --> 00:19:08.316
lazy filter collection can now

00:19:08.346 --> 00:19:10.666
return to its caller.

00:19:12.046 --> 00:19:12.976
Now what would happen if we

00:19:12.976 --> 00:19:14.106
called first again?

00:19:15.196 --> 00:19:18.476
Well, it's the same story.

00:19:18.906 --> 00:19:19.896
We ask the lazy filter

00:19:19.896 --> 00:19:21.536
collection, which defers to the

00:19:21.536 --> 00:19:22.676
underlying collection, which

00:19:22.676 --> 00:19:23.926
repeats that calculation,

00:19:24.796 --> 00:19:25.836
returning it to its caller.

00:19:26.066 --> 00:19:29.046
Now this might not typically be

00:19:29.046 --> 00:19:30.626
what you want, and so if you

00:19:30.626 --> 00:19:31.506
find yourself needing to

00:19:31.506 --> 00:19:32.586
repeatedly ask the lazy

00:19:32.586 --> 00:19:33.576
collection to calculate its

00:19:33.576 --> 00:19:35.066
result, there's a way to make

00:19:35.066 --> 00:19:35.976
sure that that happens just

00:19:35.976 --> 00:19:36.356
once.

00:19:36.876 --> 00:19:38.836
We can ensure that the lazy

00:19:38.836 --> 00:19:40.176
collection is iterated exactly

00:19:40.176 --> 00:19:42.116
once by creating a new nonlazy

00:19:42.176 --> 00:19:44.466
collection from the lazy, and

00:19:44.466 --> 00:19:46.156
when you do this, it will still

00:19:46.156 --> 00:19:47.306
defer to the lazy collection,

00:19:47.786 --> 00:19:48.586
but now the iteration will

00:19:48.586 --> 00:19:50.466
proceed through the entirety of

00:19:50.466 --> 00:19:51.686
your underlying collection,

00:19:53.536 --> 00:19:55.116
producing essentially, you know,

00:19:55.116 --> 00:19:56.706
the nonlazy version of that lazy

00:19:56.706 --> 00:19:57.376
calculation.

00:19:57.446 --> 00:19:59.096
And so in this case, we get an

00:19:59.096 --> 00:20:00.266
array containing the string

00:20:00.266 --> 00:20:00.776
gummy bears.

00:20:01.466 --> 00:20:02.646
And if we print the first

00:20:02.646 --> 00:20:03.976
element of that ray, we don't

00:20:03.976 --> 00:20:05.176
need to consult the closure at

00:20:05.176 --> 00:20:06.106
all or the lazy collection at

00:20:06.106 --> 00:20:06.246
all.

00:20:06.246 --> 00:20:07.376
We basically stamped out the

00:20:07.376 --> 00:20:08.986
laziness and now have an eager

00:20:08.986 --> 00:20:09.226
array.

00:20:11.676 --> 00:20:13.156
So when should we be lazy?

00:20:14.156 --> 00:20:15.586
Well, lazy collections are a

00:20:15.586 --> 00:20:16.616
really great way to eliminate

00:20:16.616 --> 00:20:17.896
the overhead of chained maps and

00:20:17.896 --> 00:20:18.406
filters.

00:20:18.686 --> 00:20:19.566
They excel when you find

00:20:19.566 --> 00:20:20.826
yourself only needing part of

00:20:20.826 --> 00:20:21.666
the result of a collection

00:20:21.666 --> 00:20:24.116
calculation, or we should avoid

00:20:24.116 --> 00:20:26.006
using lazy if your closures have

00:20:26.276 --> 00:20:27.726
side effects, and your closures

00:20:27.726 --> 00:20:28.946
should rarely have side effects.

00:20:29.686 --> 00:20:31.406
And be sure to reify back, or I

00:20:31.406 --> 00:20:32.526
should say, be sure to consider

00:20:32.526 --> 00:20:33.856
reifying back into a regular

00:20:33.856 --> 00:20:35.146
collection when you cross API

00:20:35.146 --> 00:20:35.586
boundaries.

00:20:36.196 --> 00:20:37.046
Lazy should often be an

00:20:37.046 --> 00:20:38.026
implementation detail.

00:20:38.546 --> 00:20:40.996
Now up until now, we've been

00:20:40.996 --> 00:20:42.226
able to do a lot of cool things

00:20:42.336 --> 00:20:43.616
with just mutable collections,

00:20:44.926 --> 00:20:46.426
but of course Swift lets us

00:20:46.426 --> 00:20:47.696
mutate our collections as well.

00:20:49.106 --> 00:20:50.036
Let's talk about the two kinds

00:20:50.036 --> 00:20:51.206
of collections that we haven't

00:20:51.206 --> 00:20:52.386
talked about yet.

00:20:52.936 --> 00:20:54.556
The first of these is mutable

00:20:54.556 --> 00:20:54.976
collection.

00:20:56.036 --> 00:20:56.856
This adds a setter to the

00:20:56.856 --> 00:20:58.006
subscript so that you can change

00:20:58.006 --> 00:20:59.316
the contents of a collection but

00:20:59.316 --> 00:20:59.866
not its length.

00:21:00.476 --> 00:21:01.146
And you have to be able to do

00:21:01.146 --> 00:21:01.976
this in constant time.

00:21:05.356 --> 00:21:07.846
The next is called a Range

00:21:07.846 --> 00:21:08.856
Replaceable Collection, and this

00:21:08.856 --> 00:21:09.726
is the kind of collection that

00:21:09.726 --> 00:21:11.196
you get when you can remove

00:21:11.196 --> 00:21:13.596
elements from a collection or

00:21:13.596 --> 00:21:14.196
insert them.

00:21:14.326 --> 00:21:16.916
And now I want to talk about one

00:21:16.916 --> 00:21:18.326
of the questions I get asked all

00:21:19.176 --> 00:21:20.206
the time.

00:21:20.416 --> 00:21:21.806
Why does my perfectly reasonable

00:21:21.806 --> 00:21:22.646
collection code crash?

00:21:23.736 --> 00:21:24.796
And like all good question

00:21:24.796 --> 00:21:26.066
answers, I almost always follow

00:21:26.066 --> 00:21:26.986
up with a few questions of my

00:21:26.986 --> 00:21:27.206
own.

00:21:28.436 --> 00:21:29.246
Sometimes I start with the

00:21:29.246 --> 00:21:30.186
classic, well what are you

00:21:30.186 --> 00:21:30.706
trying to do?

00:21:30.896 --> 00:21:32.986
And I usually quickly follow up

00:21:32.986 --> 00:21:34.026
with, well how are you using

00:21:34.026 --> 00:21:34.756
your collections?

00:21:35.156 --> 00:21:36.056
Are you mutating them?

00:21:36.236 --> 00:21:36.786
Are you sure you aren't

00:21:36.786 --> 00:21:37.806
accessing your collections for

00:21:37.806 --> 00:21:38.366
multiple threads?

00:21:38.976 --> 00:21:40.366
And I ask these questions

00:21:40.366 --> 00:21:42.836
because their answers often lead

00:21:42.836 --> 00:21:44.186
to the root cause of the

00:21:44.456 --> 00:21:44.776
problem.

00:21:44.776 --> 00:21:46.696
Well, let's begin with the

00:21:46.696 --> 00:21:47.556
assumption that threads aren't

00:21:47.556 --> 00:21:47.866
involved.

00:21:48.276 --> 00:21:49.146
I'm not ready to think about

00:21:49.146 --> 00:21:49.516
threads yet.

00:21:49.516 --> 00:21:51.996
It's not even 9:30.

00:21:52.176 --> 00:21:54.026
Suppose we had an array, and we

00:21:54.026 --> 00:21:55.716
get the index of an element that

00:21:55.716 --> 00:21:57.576
we know is there, in this case

00:21:57.576 --> 00:21:58.076
the value e.

00:21:58.346 --> 00:21:59.396
And then we mutate the

00:21:59.396 --> 00:22:00.546
collection, say by removing its

00:22:00.546 --> 00:22:03.146
first element, and we go ahead

00:22:03.146 --> 00:22:04.796
and print the element associated

00:22:04.796 --> 00:22:05.576
with that index.

00:22:06.206 --> 00:22:07.076
Well when we do this,

00:22:07.076 --> 00:22:09.526
unfortunately this will produce

00:22:09.526 --> 00:22:10.366
a fatal error.

00:22:11.796 --> 00:22:13.226
The index is no longer valid.

00:22:13.326 --> 00:22:14.826
In fact, the index became

00:22:14.826 --> 00:22:16.306
invalid the moment we mutated

00:22:16.306 --> 00:22:16.946
our collection.

00:22:17.466 --> 00:22:20.676
A far safer approach would be to

00:22:20.676 --> 00:22:22.586
mutate our collection first and

00:22:22.586 --> 00:22:24.196
then calculate the index.

00:22:24.196 --> 00:22:27.356
It's worth pointing out that

00:22:27.356 --> 00:22:28.566
mutation always invalidates

00:22:28.566 --> 00:22:29.006
indices.

00:22:29.066 --> 00:22:30.116
This doesn't just apply to

00:22:30.116 --> 00:22:30.496
arrays.

00:22:31.146 --> 00:22:32.206
Let's take a look at how this

00:22:32.376 --> 00:22:33.266
problem could manifest with

00:22:33.266 --> 00:22:33.866
dictionaries.

00:22:35.036 --> 00:22:35.816
Let's suppose that we have a

00:22:35.816 --> 00:22:36.936
dictionary showing a few of a

00:22:36.936 --> 00:22:37.966
bear's favorite things.

00:22:39.096 --> 00:22:40.056
We'll grab the index of our

00:22:40.056 --> 00:22:41.586
bear's favorite food and print

00:22:41.586 --> 00:22:43.316
it out, confirming that, indeed,

00:22:43.316 --> 00:22:43.706
it's salmon.

00:22:45.036 --> 00:22:46.486
Next, we'll add a couple more

00:22:46.486 --> 00:22:47.466
favorite things that this bear

00:22:47.466 --> 00:22:49.226
has, and then we'll make sure

00:22:49.226 --> 00:22:50.106
that our favorite food is still

00:22:50.106 --> 00:22:50.376
salmon.

00:22:50.376 --> 00:22:52.446
And we'll see that, wait a

00:22:52.446 --> 00:22:53.836
minute, our favorite good isn't

00:22:53.886 --> 00:22:55.136
hibernation, it's salmon.

00:22:55.436 --> 00:22:58.076
And just like arrays, we

00:22:58.076 --> 00:22:59.576
invalidated our index the moment

00:22:59.576 --> 00:23:00.646
we mutated the dictionary.

00:23:01.466 --> 00:23:02.446
It's also worth pointing out

00:23:02.736 --> 00:23:03.726
that this code can crash.

00:23:05.146 --> 00:23:06.186
So how do we go about fixing

00:23:06.186 --> 00:23:06.516
this?

00:23:07.606 --> 00:23:08.926
Well, it turns out it's the same

00:23:08.926 --> 00:23:10.266
exact fix that we used with the

00:23:10.266 --> 00:23:10.496
array.

00:23:11.276 --> 00:23:12.286
We just simply recompute the

00:23:12.286 --> 00:23:13.256
index after we mutate.

00:23:13.696 --> 00:23:15.386
Well, one thing to keep in mind

00:23:15.626 --> 00:23:16.486
that when you're recomputing

00:23:16.486 --> 00:23:17.896
indices this is something that

00:23:17.896 --> 00:23:18.916
can sometimes be expensive.

00:23:18.916 --> 00:23:20.896
Some index search methods take

00:23:20.976 --> 00:23:21.676
linear time.

00:23:22.226 --> 00:23:23.496
And so you want to take care to

00:23:23.496 --> 00:23:24.766
only find the indices that you

00:23:25.206 --> 00:23:25.306
need.

00:23:26.596 --> 00:23:27.936
So here's my advice if you want

00:23:27.936 --> 00:23:28.866
to avoid finding yourself in

00:23:28.866 --> 00:23:30.046
these kinds of situations.

00:23:30.456 --> 00:23:32.196
Remember that mutation almost

00:23:32.196 --> 00:23:33.546
always invalidates your indices.

00:23:33.986 --> 00:23:35.586
You might get away with it

00:23:35.586 --> 00:23:36.986
sometimes, but it's really best

00:23:36.986 --> 00:23:38.066
to just treat this as a hard

00:23:38.066 --> 00:23:38.346
rule.

00:23:38.636 --> 00:23:39.936
You'll be much happier for it.

00:23:40.926 --> 00:23:42.256
Also remember that slices hold

00:23:42.256 --> 00:23:44.136
on to the underlying original

00:23:44.276 --> 00:23:45.416
state of the collection even

00:23:45.416 --> 00:23:46.976
after it was mutated, and

00:23:46.976 --> 00:23:48.586
because of that, really think

00:23:48.586 --> 00:23:50.136
twice about holding onto indices

00:23:50.136 --> 00:23:51.786
or slices when the underlying

00:23:51.786 --> 00:23:52.626
collection is mutable.

00:23:53.776 --> 00:23:54.816
And keep in mind that index

00:23:54.816 --> 00:23:56.556
computation can sometimes take a

00:23:56.556 --> 00:23:57.756
nontrivial amount of time.

00:23:59.246 --> 00:24:00.516
So take care to only calculate

00:24:00.516 --> 00:24:01.446
indices as needed.

00:24:01.956 --> 00:24:04.146
So a little bit later, let's

00:24:04.176 --> 00:24:04.816
bring threads into the

00:24:04.816 --> 00:24:05.296
discussion.

00:24:05.786 --> 00:24:06.576
I mentioned that one of the

00:24:06.576 --> 00:24:07.966
questions that I ask is are your

00:24:08.046 --> 00:24:09.866
threads accessible for multiple

00:24:09.866 --> 00:24:10.166
threads?

00:24:10.456 --> 00:24:13.256
And the reason why I ask this is

00:24:13.256 --> 00:24:14.646
because our collections assume

00:24:14.646 --> 00:24:15.686
that you will access them from a

00:24:15.686 --> 00:24:16.416
single thread.

00:24:17.156 --> 00:24:18.746
And this is a really good thing

00:24:18.746 --> 00:24:19.916
for reasons of performance.

00:24:20.516 --> 00:24:21.376
It makes it so that all

00:24:21.376 --> 00:24:22.696
single-threaded use cases don't

00:24:22.696 --> 00:24:24.716
have to pay the tax of locks or

00:24:24.716 --> 00:24:26.416
any of those other primitives

00:24:26.416 --> 00:24:27.386
that you could use to ensure

00:24:27.386 --> 00:24:29.076
mutual exclusion.

00:24:30.226 --> 00:24:31.196
And when threads are involved,

00:24:31.356 --> 00:24:32.746
only developers using the

00:24:32.746 --> 00:24:33.786
collections will have all the

00:24:33.786 --> 00:24:35.066
information needed to restrict

00:24:35.066 --> 00:24:36.556
access with the appropriate lock

00:24:36.556 --> 00:24:38.056
or a serial queue at a much

00:24:38.106 --> 00:24:39.346
higher level abstraction than us

00:24:39.346 --> 00:24:40.466
lowly framework developers could

00:24:40.466 --> 00:24:40.956
ever offer.

00:24:40.956 --> 00:24:43.596
So let's see what these kinds of

00:24:43.596 --> 00:24:44.356
problems could look like.

00:24:45.536 --> 00:24:46.546
Let's suppose we have an array

00:24:46.546 --> 00:24:47.596
that we aim to fill up with

00:24:47.596 --> 00:24:49.896
sleeping bears, and to simulate

00:24:49.896 --> 00:24:52.026
each bear being their own bear

00:24:52.026 --> 00:24:52.926
and in charge of themselves,

00:24:52.926 --> 00:24:53.796
we're going to get access to a

00:24:53.886 --> 00:24:56.356
concurrent dispatch queue that

00:24:56.356 --> 00:24:57.496
we'll use to tell each bear to

00:24:57.496 --> 00:24:58.036
go to sleep.

00:24:58.156 --> 00:24:59.936
And because this is a concurrent

00:24:59.936 --> 00:25:01.196
dispatch queue, it's some time

00:25:01.196 --> 00:25:02.456
helpful to like imagine the code

00:25:02.456 --> 00:25:04.086
running at the same time, which

00:25:04.086 --> 00:25:05.466
I'll simulate by putting them on

00:25:05.466 --> 00:25:06.176
the same line.

00:25:06.986 --> 00:25:08.086
And later in our application,

00:25:08.086 --> 00:25:09.036
let's go ahead and check in on

00:25:09.036 --> 00:25:11.376
those sleeping bears, and

00:25:11.376 --> 00:25:13.506
sometimes we'll see grandpa and

00:25:13.556 --> 00:25:14.476
cubs snoozing happily.

00:25:15.136 --> 00:25:17.086
Other times, cub will go to

00:25:17.086 --> 00:25:18.276
sleep first, and then it'll be

00:25:18.276 --> 00:25:18.636
grandpa.

00:25:19.516 --> 00:25:20.936
Sometimes, quite mysteriously,

00:25:21.166 --> 00:25:22.966
only grandpa is sleeping in.

00:25:23.506 --> 00:25:25.166
And other times, it'll be the

00:25:25.226 --> 00:25:28.226
cub, and sometimes our program

00:25:28.226 --> 00:25:29.986
just up and crashes, and nobody

00:25:30.086 --> 00:25:32.046
bear's getting any sleep.

00:25:32.216 --> 00:25:33.246
All of these possibilities

00:25:33.246 --> 00:25:34.356
suggest that there's a possible

00:25:34.356 --> 00:25:36.306
race condition, and indeed, it

00:25:36.356 --> 00:25:37.336
seems likely given all the

00:25:37.336 --> 00:25:39.326
potential threads involved in

00:25:39.326 --> 00:25:40.146
this example.

00:25:41.116 --> 00:25:41.946
And we can prove this to

00:25:41.946 --> 00:25:42.916
ourselves using the thread

00:25:42.916 --> 00:25:44.196
sanitizer or TSAN that's

00:25:44.196 --> 00:25:45.106
included within Xcode.

00:25:45.606 --> 00:25:47.406
And if we were to do so, we'd

00:25:47.406 --> 00:25:48.376
get output that kind of looks

00:25:48.376 --> 00:25:50.836
like this, and indeed, TSAN

00:25:50.836 --> 00:25:51.676
would catch the race.

00:25:51.676 --> 00:25:53.586
It would tell us there's a Swift

00:25:53.586 --> 00:25:54.066
access race.

00:25:54.626 --> 00:25:55.796
It would tell us which threads

00:25:55.796 --> 00:25:58.016
are involved and give us a

00:25:58.016 --> 00:25:59.076
summary at the end telling us

00:25:59.126 --> 00:26:00.346
which line to actually go start

00:26:00.346 --> 00:26:01.256
looking for our problem.

00:26:02.336 --> 00:26:03.336
And all that evidence is

00:26:03.336 --> 00:26:04.226
actually going to be really

00:26:04.226 --> 00:26:06.946
helpful to find the bug.

00:26:06.946 --> 00:26:07.746
So we've proven that there's a

00:26:07.746 --> 00:26:08.156
bug here.

00:26:08.416 --> 00:26:10.376
TSAN has never lied in my

00:26:10.376 --> 00:26:11.256
experience with them.

00:26:12.616 --> 00:26:14.036
So we can fix this by

00:26:14.036 --> 00:26:15.446
eliminating the bears' ability

00:26:15.446 --> 00:26:16.466
to go to sleep at the same time,

00:26:16.846 --> 00:26:17.826
and we'll do that with a serial

00:26:17.826 --> 00:26:18.456
dispatch queue.

00:26:19.736 --> 00:26:20.846
And now only one bear can go to

00:26:20.846 --> 00:26:21.446
sleep at a time.

00:26:21.946 --> 00:26:22.846
And so if we peek in on our

00:26:22.846 --> 00:26:25.236
sleeping bears again now, taking

00:26:25.236 --> 00:26:26.516
care to do so on the appropriate

00:26:26.516 --> 00:26:28.926
queue, we see that sure enough

00:26:29.226 --> 00:26:30.496
grandpa and cub are snoozing

00:26:30.496 --> 00:26:31.586
away peacefully like we

00:26:31.586 --> 00:26:32.006
expected.

00:26:33.936 --> 00:26:35.306
So my advice for working with

00:26:35.306 --> 00:26:36.526
collections for multiple threads

00:26:36.976 --> 00:26:38.336
is try to isolate your data so

00:26:38.336 --> 00:26:39.296
that it can only be seen from a

00:26:39.296 --> 00:26:40.856
single thread, and when you

00:26:40.856 --> 00:26:42.906
can't do that, make sure that

00:26:42.906 --> 00:26:43.766
you have an appropriate form in

00:26:43.766 --> 00:26:45.126
mutual exclusion, such as a

00:26:45.126 --> 00:26:46.726
serial dispatch queue or locks.

00:26:47.816 --> 00:26:49.016
And always use the thread

00:26:49.016 --> 00:26:50.226
sanitizer to double check your

00:26:50.226 --> 00:26:50.476
work.

00:26:50.876 --> 00:26:52.376
It's far better to catch bugs

00:26:52.406 --> 00:26:53.426
before they ship in your app

00:26:53.816 --> 00:26:54.236
than after.

00:26:54.236 --> 00:26:56.496
And I have a little bit more

00:26:56.496 --> 00:26:57.496
advice for working with mutable

00:26:57.496 --> 00:26:58.046
collections.

00:26:59.476 --> 00:27:01.166
The first of which is if you can

00:27:01.166 --> 00:27:02.676
avoid it, don't use mutable

00:27:02.676 --> 00:27:03.366
state at all.

00:27:04.456 --> 00:27:05.706
So far all the difficulties that

00:27:05.706 --> 00:27:06.906
I've described have come about

00:27:06.906 --> 00:27:07.916
because we've been working with

00:27:07.916 --> 00:27:08.526
mutable state.

00:27:08.926 --> 00:27:10.066
You can avoid all the potential

00:27:10.066 --> 00:27:11.356
for this complexity by avoiding

00:27:11.356 --> 00:27:12.686
mutable collections in the first

00:27:12.686 --> 00:27:13.096
place.

00:27:13.866 --> 00:27:14.976
Many times you can actually

00:27:14.976 --> 00:27:16.116
emulate the mutations that you

00:27:16.116 --> 00:27:18.026
want to perform by using a slice

00:27:18.766 --> 00:27:20.676
or using a lazy wrapper, and

00:27:20.676 --> 00:27:21.666
it's almost always easier to

00:27:21.666 --> 00:27:22.796
understand data that cannot

00:27:22.856 --> 00:27:23.316
change.

00:27:23.626 --> 00:27:25.416
And thanks to mutability being

00:27:25.576 --> 00:27:27.066
built into Swift, the compiler

00:27:27.066 --> 00:27:28.196
will help you if you're leaving

00:27:28.196 --> 00:27:29.276
a state mutable when you're not

00:27:29.276 --> 00:27:30.726
actually mutating it.

00:27:32.436 --> 00:27:33.756
Now I have one more piece of

00:27:33.756 --> 00:27:35.486
advice that actually concerns

00:27:35.486 --> 00:27:36.746
how best to use mutable state

00:27:36.746 --> 00:27:38.656
when you have to.

00:27:38.856 --> 00:27:39.656
And that's when you're forming

00:27:39.656 --> 00:27:40.396
new collections.

00:27:40.606 --> 00:27:41.606
You can help performance if

00:27:41.606 --> 00:27:42.786
you're lucky enough to know an

00:27:42.786 --> 00:27:45.246
exact count or a really good

00:27:45.246 --> 00:27:46.156
approximation of how many

00:27:46.156 --> 00:27:47.056
elements you're actually going

00:27:47.056 --> 00:27:47.226
to need.

00:27:47.776 --> 00:27:49.326
Most collection APIs have a way

00:27:49.326 --> 00:27:50.466
of being able to provide this

00:27:50.536 --> 00:27:51.756
hint, and when you do this, you

00:27:51.756 --> 00:27:53.136
get exactly the size you need

00:27:53.136 --> 00:27:53.846
with no overhead.

00:27:54.496 --> 00:27:56.146
If you don't, our collections

00:27:56.146 --> 00:27:57.286
are general purpose tools.

00:27:58.106 --> 00:27:59.036
They're meant to work on a wide

00:27:59.036 --> 00:28:00.126
variety of cases, and as you

00:28:00.126 --> 00:28:01.656
incrementally add elements, you

00:28:01.656 --> 00:28:03.736
may actually end up over

00:28:03.736 --> 00:28:04.816
allocating the amount of storage

00:28:04.816 --> 00:28:06.706
that you need, but taking care

00:28:06.706 --> 00:28:07.726
that you don't over estimate

00:28:07.726 --> 00:28:09.226
when providing such hints,

00:28:09.446 --> 00:28:10.186
because otherwise you'll find

00:28:10.186 --> 00:28:11.156
yourself in the same exactly

00:28:11.156 --> 00:28:12.116
situation where you're using up

00:28:12.116 --> 00:28:13.366
more storage than you actually

00:28:13.876 --> 00:28:13.966
need.

00:28:14.756 --> 00:28:16.216
And now, I want to move on to my

00:28:16.216 --> 00:28:17.266
final topic for today.

00:28:17.266 --> 00:28:20.196
And that's the wide range of

00:28:20.196 --> 00:28:20.986
collections that become

00:28:20.986 --> 00:28:22.876
available for you when you

00:28:22.876 --> 00:28:24.166
import Foundation and when you

00:28:24.166 --> 00:28:25.756
should consider using them.

00:28:26.456 --> 00:28:28.286
In addition to the standard

00:28:28.286 --> 00:28:29.266
library collections, when you

00:28:29.266 --> 00:28:30.606
import Foundation, you gain

00:28:30.606 --> 00:28:31.546
access to the great

00:28:31.546 --> 00:28:32.806
reference-type collections that

00:28:32.806 --> 00:28:34.216
objective C developers have been

00:28:34.216 --> 00:28:35.076
using for decades.

00:28:35.076 --> 00:28:37.636
And many of these also gain

00:28:37.636 --> 00:28:39.636
conformance in Swift and thus

00:28:39.636 --> 00:28:40.816
behave just the collections that

00:28:40.816 --> 00:28:41.636
we've been talking about.

00:28:42.356 --> 00:28:43.246
That said, there are a couple

00:28:43.246 --> 00:28:44.136
important things to keep in

00:28:44.136 --> 00:28:44.426
mind.

00:28:44.906 --> 00:28:48.046
First thing to keep in mind is

00:28:48.046 --> 00:28:48.676
that these NS [inaudible]

00:28:48.726 --> 00:28:50.376
collections are reference types.

00:28:50.556 --> 00:28:51.616
And this is best examined by

00:28:51.616 --> 00:28:52.696
considering an example.

00:28:53.636 --> 00:28:54.546
We're going to define value

00:28:54.636 --> 00:28:55.596
types and reference types and do

00:28:55.596 --> 00:28:57.196
the same things with them on two

00:28:57.196 --> 00:28:57.476
sides.

00:28:58.406 --> 00:28:59.536
So with our value type, we'll

00:28:59.536 --> 00:29:00.196
call it x.

00:29:00.196 --> 00:29:01.456
It will be an array of strings.

00:29:02.476 --> 00:29:04.466
We get an empty array called x.

00:29:05.076 --> 00:29:06.206
With a reference type, we get an

00:29:06.206 --> 00:29:08.306
empty array, but x is pointing

00:29:08.306 --> 00:29:08.606
to it.

00:29:10.036 --> 00:29:12.086
We then mutate that array with

00:29:12.086 --> 00:29:12.656
the value type.

00:29:12.656 --> 00:29:14.086
That array is mutated in line.

00:29:14.736 --> 00:29:16.326
With the reference type, that

00:29:16.486 --> 00:29:17.786
array is, the reference, the

00:29:17.786 --> 00:29:19.646
array that is being referenced

00:29:19.696 --> 00:29:20.816
is mutated in line.

00:29:21.406 --> 00:29:22.286
We add another variable.

00:29:22.556 --> 00:29:24.376
With the value type, something

00:29:24.376 --> 00:29:25.276
really special happens.

00:29:25.546 --> 00:29:26.316
We actually don't copy the

00:29:26.316 --> 00:29:27.156
storage at this point.

00:29:27.396 --> 00:29:29.766
Why is an array that knows that

00:29:29.766 --> 00:29:30.926
its storage is actually owned by

00:29:30.926 --> 00:29:31.056
x?

00:29:31.056 --> 00:29:33.366
And why is that actually going

00:29:33.436 --> 00:29:34.666
to perform that copy until

00:29:34.666 --> 00:29:35.536
either of those collections is

00:29:35.536 --> 00:29:35.916
mutated.

00:29:36.676 --> 00:29:37.456
The reference type is a little

00:29:37.456 --> 00:29:37.956
bit different.

00:29:38.946 --> 00:29:40.616
Y is just another pointer to the

00:29:40.616 --> 00:29:41.666
same underlying array.

00:29:43.096 --> 00:29:44.516
So let's go ahead and mutate y.

00:29:44.656 --> 00:29:45.516
We'll put another bear in that

00:29:45.516 --> 00:29:45.786
array.

00:29:46.126 --> 00:29:47.266
With the value type what happens

00:29:47.546 --> 00:29:48.786
is first we invoke that copy on

00:29:48.786 --> 00:29:49.336
write machinery.

00:29:49.486 --> 00:29:51.256
We're writing to a y, so we need

00:29:51.256 --> 00:29:53.816
to copy it, and then we can

00:29:53.816 --> 00:29:54.966
insert the next bear.

00:29:55.146 --> 00:29:57.106
With the reference, it's a

00:29:57.106 --> 00:29:57.826
little bit simpler.

00:29:58.056 --> 00:29:58.846
There's only one array.

00:29:59.216 --> 00:30:00.756
We simply put the panda in the

00:30:00.756 --> 00:30:00.946
array.

00:30:01.576 --> 00:30:04.006
There's a second thing that you

00:30:04.006 --> 00:30:05.306
need to keep in mind when

00:30:05.306 --> 00:30:07.466
working with the foundation

00:30:07.466 --> 00:30:08.586
collections in Swift.

00:30:08.816 --> 00:30:11.696
And that is, all objective-C

00:30:11.696 --> 00:30:13.416
APIs in Swift appear as Swift

00:30:13.546 --> 00:30:14.616
native value types.

00:30:14.926 --> 00:30:15.856
And this is actually really

00:30:15.856 --> 00:30:16.986
wonderful because it let's code

00:30:16.986 --> 00:30:18.706
in each language speak naturally

00:30:18.706 --> 00:30:19.596
with the types that they work

00:30:19.596 --> 00:30:19.926
with best.

00:30:21.046 --> 00:30:21.846
But how can this work?

00:30:22.216 --> 00:30:22.946
The two languages have

00:30:22.946 --> 00:30:23.526
completely different

00:30:23.526 --> 00:30:24.426
implementations for these

00:30:24.426 --> 00:30:24.866
collections.

00:30:25.976 --> 00:30:27.986
And the reason why it works is

00:30:27.986 --> 00:30:28.886
something known as bridging.

00:30:29.566 --> 00:30:30.526
Bridging is how we convert

00:30:30.526 --> 00:30:31.416
between the two different

00:30:31.776 --> 00:30:33.266
runtime representations, and

00:30:33.266 --> 00:30:33.886
this is something that's

00:30:33.926 --> 00:30:35.036
necessary because Swift and

00:30:35.036 --> 00:30:36.736
objective-C, I'm sure you've

00:30:36.736 --> 00:30:37.946
noticed, are very different

00:30:37.946 --> 00:30:39.686
languages with very different

00:30:39.686 --> 00:30:41.236
compile and runtime features.

00:30:42.326 --> 00:30:43.436
And while we've optimized

00:30:43.436 --> 00:30:44.976
bridging to be as fast as it can

00:30:44.976 --> 00:30:46.186
be, it's not free.

00:30:46.546 --> 00:30:48.146
There will always be a cost when

00:30:48.146 --> 00:30:48.886
bridging between the two

00:30:48.886 --> 00:30:49.466
languages.

00:30:50.656 --> 00:30:52.066
So what happens when we bridge?

00:30:52.836 --> 00:30:54.206
Well, when we bridge between the

00:30:54.206 --> 00:30:55.606
language, we have dispersed set

00:30:55.606 --> 00:30:57.166
up new storage, equivalent

00:30:57.166 --> 00:30:58.376
storage, so if you're taking n

00:30:58.376 --> 00:30:59.246
things in one language, you'll

00:30:59.246 --> 00:31:00.806
take up n space in the next one.

00:31:01.206 --> 00:31:02.296
Then we need to go element by

00:31:02.296 --> 00:31:04.806
element and convert potentially

00:31:04.806 --> 00:31:05.376
between them, and this

00:31:05.436 --> 00:31:06.276
per-element bridging can

00:31:06.276 --> 00:31:06.976
sometimes be recursive.

00:31:07.076 --> 00:31:08.886
For instance, if I have an array

00:31:08.886 --> 00:31:10.226
of strings, first we'll bridge

00:31:10.226 --> 00:31:11.406
the array, and then we'll bridge

00:31:11.446 --> 00:31:12.786
each individual string.

00:31:12.966 --> 00:31:14.746
And when this happens at the

00:31:14.746 --> 00:31:15.606
boundary between the two

00:31:15.606 --> 00:31:16.996
languages, we call it eager

00:31:16.996 --> 00:31:17.366
bridging.

00:31:17.836 --> 00:31:19.996
And collections will always be

00:31:19.996 --> 00:31:21.036
bridged eagerly when the

00:31:21.036 --> 00:31:22.846
elements of the collection need

00:31:22.846 --> 00:31:23.536
bridging as well.

00:31:23.536 --> 00:31:25.506
And this arises most often with

00:31:25.536 --> 00:31:27.316
dictionaries keyed by strings.

00:31:27.846 --> 00:31:29.926
When collection bridging is not

00:31:29.966 --> 00:31:31.446
eager, we call it lazy.

00:31:31.526 --> 00:31:32.416
And this happens when the

00:31:32.416 --> 00:31:33.636
element types of the collection

00:31:33.776 --> 00:31:35.296
aren't bridged themselves, such

00:31:35.376 --> 00:31:36.016
as NSViews.

00:31:36.526 --> 00:31:37.816
In this case, bridging will be

00:31:38.056 --> 00:31:39.566
deferred until the collection is

00:31:39.566 --> 00:31:40.746
actually first used.

00:31:40.966 --> 00:31:42.276
Let's make this concrete with

00:31:42.276 --> 00:31:42.826
some examples.

00:31:43.596 --> 00:31:44.356
We'll first consider an

00:31:44.356 --> 00:31:45.896
objective-C API describing an

00:31:45.896 --> 00:31:46.926
NSArray of NSDatas.

00:31:47.866 --> 00:31:49.566
Now NSArray is bridged to array,

00:31:49.566 --> 00:31:51.076
and NSData is bridged to

00:31:51.076 --> 00:31:51.856
value-type data.

00:31:52.086 --> 00:31:53.606
And so such a collection would

00:31:53.606 --> 00:31:54.396
be bridged eagerly.

00:31:54.616 --> 00:31:57.016
I mentioned a moment ago that

00:31:57.016 --> 00:31:58.126
NSViews are not bridged in

00:31:58.126 --> 00:31:58.466
Swift.

00:31:58.466 --> 00:32:00.206
They remain reference types in

00:32:00.206 --> 00:32:00.516
Swift.

00:32:00.516 --> 00:32:02.556
And so an NSArray of NSViews

00:32:03.186 --> 00:32:04.186
will be lazily bridged.

00:32:04.406 --> 00:32:05.436
The bridging won't happen until

00:32:05.436 --> 00:32:07.626
you first access or try to use

00:32:07.626 --> 00:32:08.806
that array.

00:32:10.556 --> 00:32:13.066
And finally, an NSDictionary

00:32:13.066 --> 00:32:15.336
with keys that are NS strings

00:32:15.336 --> 00:32:17.666
will be bridged eagerly because

00:32:17.666 --> 00:32:18.756
the strings need to come across

00:32:18.846 --> 00:32:21.346
in Swift as value-type strings.

00:32:22.336 --> 00:32:22.996
So now that we know what

00:32:22.996 --> 00:32:24.616
bridging is, how it works, and

00:32:24.616 --> 00:32:26.166
when it happens, we can move on

00:32:26.166 --> 00:32:27.146
to the most important question

00:32:27.146 --> 00:32:28.956
of all, which is when should you

00:32:28.956 --> 00:32:29.586
care about it.

00:32:29.736 --> 00:32:30.506
And the answer is really

00:32:30.506 --> 00:32:31.116
straightforward.

00:32:31.416 --> 00:32:32.466
When you measure it negatively

00:32:32.466 --> 00:32:33.966
impacting your app.

00:32:35.676 --> 00:32:36.906
Specifically, when you take a

00:32:37.026 --> 00:32:37.856
time profile or trace an

00:32:37.856 --> 00:32:39.206
instrument, pay special

00:32:39.206 --> 00:32:40.416
attention to where your code

00:32:40.416 --> 00:32:41.736
crosses between the languages,

00:32:41.946 --> 00:32:42.956
especially when this happens

00:32:42.956 --> 00:32:44.236
inside a loop.

00:32:44.956 --> 00:32:45.736
Some bridging is going to

00:32:45.736 --> 00:32:47.196
happen, and that's totally okay.

00:32:47.596 --> 00:32:48.586
What you're looking for though

00:32:48.976 --> 00:32:50.456
is a disproportionate amount of

00:32:50.526 --> 00:32:51.626
time or a surprising amount of

00:32:51.696 --> 00:32:53.106
time spent in code that you

00:32:53.106 --> 00:32:54.486
didn't write that has the word

00:32:54.486 --> 00:32:55.026
bridge in it.

00:32:56.556 --> 00:32:57.346
Let's look at a concrete

00:32:57.406 --> 00:32:58.376
example.

00:32:58.886 --> 00:33:00.186
Suppose I have a manuscript for

00:33:00.186 --> 00:33:01.746
a great children's story that

00:33:01.746 --> 00:33:02.646
I'm working on, but it's really

00:33:02.646 --> 00:33:03.516
long, so I'm only going to show

00:33:03.516 --> 00:33:05.086
a little bit here, but to really

00:33:05.086 --> 00:33:07.486
make it pop, I want to make

00:33:07.756 --> 00:33:09.646
every word or every instance of

00:33:09.646 --> 00:33:11.006
the word brown actually be the

00:33:11.006 --> 00:33:12.596
color brown, and in the interest

00:33:12.596 --> 00:33:13.636
of space, I'm only going to show

00:33:13.636 --> 00:33:14.636
highlighting the first word.

00:33:14.846 --> 00:33:17.386
To do this, I'm going to use an

00:33:17.386 --> 00:33:18.486
NS mutable attributed string.

00:33:18.806 --> 00:33:21.666
I'll pass my story in there.

00:33:21.926 --> 00:33:23.566
And then using the attributed

00:33:23.566 --> 00:33:25.266
strings string property, I'll

00:33:25.266 --> 00:33:26.416
ask for the range of the Swift

00:33:26.416 --> 00:33:28.206
string brown, which will produce

00:33:28.206 --> 00:33:29.886
a range of strings native index

00:33:29.886 --> 00:33:30.086
type.

00:33:30.656 --> 00:33:32.466
And as mutable string works with

00:33:32.556 --> 00:33:33.626
NS ranges, and so I'll use the

00:33:33.626 --> 00:33:34.916
convenience initializer that we

00:33:34.916 --> 00:33:37.526
introduced last year to convert

00:33:37.586 --> 00:33:39.626
to an NS range, and this, I'm

00:33:39.626 --> 00:33:41.756
calling again attributed strings

00:33:41.926 --> 00:33:43.606
string property to do the

00:33:43.606 --> 00:33:44.006
conversion.

00:33:44.296 --> 00:33:45.296
And then we'll color the first

00:33:45.466 --> 00:33:46.396
instance of the word brown.

00:33:47.156 --> 00:33:48.206
And when I go to run this code,

00:33:48.206 --> 00:33:49.636
I notice it's a little slow.

00:33:50.916 --> 00:33:52.526
So I profile it.

00:33:52.526 --> 00:33:54.516
And I see that, to my surprise,

00:33:54.516 --> 00:33:55.296
I thought all the time would be

00:33:55.296 --> 00:33:56.436
spent coloring the word brown,

00:33:56.436 --> 00:33:57.306
but indeed, it's actually

00:33:57.306 --> 00:33:58.366
computing the indices, and why

00:33:58.366 --> 00:33:58.676
is that?

00:33:59.306 --> 00:34:01.416
And the reason for that is that

00:34:01.416 --> 00:34:02.256
we're actually bridging our

00:34:02.256 --> 00:34:03.766
string multiple times across

00:34:03.766 --> 00:34:04.306
languages.

00:34:04.576 --> 00:34:05.976
Mutable attributed string is an

00:34:05.976 --> 00:34:08.295
objective-C reference type, and

00:34:08.295 --> 00:34:09.766
so when we're asking for the

00:34:09.766 --> 00:34:10.826
string property, we're actually

00:34:10.826 --> 00:34:11.646
having to convert from an

00:34:11.646 --> 00:34:12.366
NSString to a string.

00:34:12.585 --> 00:34:15.326
And we're doing it once here

00:34:15.326 --> 00:34:16.335
when we calculated the first

00:34:16.335 --> 00:34:17.505
range, and we're doing it a

00:34:17.505 --> 00:34:18.466
second time when we convert for

00:34:18.466 --> 00:34:19.166
the NSRange.

00:34:19.516 --> 00:34:21.726
You can imagine how expensive

00:34:21.766 --> 00:34:22.996
this would be if we did this in

00:34:22.996 --> 00:34:24.505
a loop looking for all the text

00:34:24.505 --> 00:34:24.886
to color.

00:34:24.886 --> 00:34:26.556
Now let's look into why this is

00:34:26.556 --> 00:34:26.946
happening.

00:34:27.556 --> 00:34:28.876
Every time I call text.string,

00:34:29.206 --> 00:34:30.545
we start in a Swift execution

00:34:30.585 --> 00:34:31.106
context.

00:34:31.795 --> 00:34:33.025
However, the implementation of

00:34:33.025 --> 00:34:34.056
NSMutableAttributedString is

00:34:34.056 --> 00:34:35.496
objective-C, and so in order to

00:34:35.496 --> 00:34:37.076
provide the result, we actually

00:34:37.076 --> 00:34:38.466
have to consult the original

00:34:38.466 --> 00:34:39.085
implementation.

00:34:40.436 --> 00:34:41.716
The original implementation

00:34:41.716 --> 00:34:43.596
returns an NSString, which is

00:34:43.596 --> 00:34:44.856
the reference type, and so when

00:34:44.856 --> 00:34:46.606
return to string, it needs to be

00:34:47.565 --> 00:34:48.996
bridged, graphing cluster by

00:34:48.996 --> 00:34:51.295
graphing cluster, character by

00:34:51.295 --> 00:34:51.775
character.

00:34:51.775 --> 00:34:55.085
And bridging happens whether

00:34:55.646 --> 00:34:57.596
it's a return type or a

00:34:57.596 --> 00:34:58.000
parameter.

00:35:01.246 --> 00:35:02.336
So now that we know those

00:35:02.456 --> 00:35:04.706
details, we can make, now we can

00:35:04.706 --> 00:35:06.176
actually make this a little bit

00:35:06.176 --> 00:35:06.366
better.

00:35:06.466 --> 00:35:07.526
Let's just bridge once.

00:35:07.836 --> 00:35:11.116
And let's remeasure our code and

00:35:11.116 --> 00:35:12.256
see that indeed we've improved

00:35:12.256 --> 00:35:13.126
our performance by half.

00:35:13.696 --> 00:35:14.996
But it turns out this year we

00:35:14.996 --> 00:35:15.676
can do a little better.

00:35:16.676 --> 00:35:18.286
Oh, and also, now we're not

00:35:18.286 --> 00:35:19.076
bridging where we do that.

00:35:19.546 --> 00:35:20.626
But this year we can do a little

00:35:20.626 --> 00:35:21.036
bit better.

00:35:21.616 --> 00:35:23.126
This year, if we actually

00:35:23.266 --> 00:35:24.256
[inaudible] to an NSString when

00:35:24.256 --> 00:35:25.436
we ask for the text.string's

00:35:25.466 --> 00:35:26.356
property, when we get the

00:35:26.356 --> 00:35:28.246
variable out, no bridging is

00:35:28.246 --> 00:35:29.176
actually going to occur.

00:35:30.656 --> 00:35:32.486
And further, by doing so, now

00:35:32.486 --> 00:35:35.216
that string is an NSString, when

00:35:35.216 --> 00:35:36.356
we call the range of property,

00:35:36.436 --> 00:35:37.406
we're actually going to get an

00:35:37.406 --> 00:35:39.996
NSRange out of it automatically.

00:35:39.996 --> 00:35:40.956
We won't need to do any of the

00:35:40.956 --> 00:35:42.116
range conversion between Swift

00:35:42.116 --> 00:35:44.896
native types and the NS ranges,

00:35:44.896 --> 00:35:46.466
which is pretty excellent.

00:35:46.646 --> 00:35:47.526
So let's measure this code and

00:35:47.526 --> 00:35:48.966
see how it is, and sure enough,

00:35:49.206 --> 00:35:49.936
this looks pretty good.

00:35:50.156 --> 00:35:51.226
Much, much faster than the, you

00:35:51.226 --> 00:35:52.816
know, almost 800 milliseconds

00:35:52.816 --> 00:35:53.516
that we were consuming

00:35:53.516 --> 00:35:54.126
previously.

00:35:54.346 --> 00:35:56.396
However, I do want to point out

00:35:56.396 --> 00:35:57.366
that we're still bridging here.

00:35:57.656 --> 00:35:58.896
And it's a teeny, tiny bridge,

00:35:59.616 --> 00:36:00.346
but we're still bridging.

00:36:01.406 --> 00:36:03.456
Brown here is a Swift value type

00:36:03.456 --> 00:36:03.786
string.

00:36:04.956 --> 00:36:07.976
And every time we call into the

00:36:07.976 --> 00:36:09.526
objective-C API range of

00:36:09.606 --> 00:36:10.376
[inaudible] NSString, we're

00:36:10.376 --> 00:36:11.896
actually going to bridge that

00:36:11.896 --> 00:36:13.236
teeny, tiny string back to an

00:36:13.236 --> 00:36:13.686
NSString.

00:36:14.966 --> 00:36:15.886
This is inexpensive in this

00:36:15.886 --> 00:36:16.066
case.

00:36:16.066 --> 00:36:17.546
I'm only doing it once, but you

00:36:17.606 --> 00:36:18.696
can imagine, if this was in a

00:36:18.696 --> 00:36:20.206
loop, that small amount would

00:36:20.206 --> 00:36:21.006
add up over time.

00:36:21.156 --> 00:36:23.246
And so you want to take care to

00:36:23.476 --> 00:36:24.486
avoid bridging the same small

00:36:24.486 --> 00:36:25.246
strings repeatedly.

00:36:25.546 --> 00:36:26.446
However, before you do such

00:36:26.446 --> 00:36:28.056
optimizations, always measure.

00:36:29.476 --> 00:36:30.516
And so now that we've seen the

00:36:30.516 --> 00:36:31.406
details of bridging, I want to

00:36:31.406 --> 00:36:32.346
offer a little bit of advice

00:36:32.346 --> 00:36:33.616
about when to use Foundation

00:36:33.616 --> 00:36:34.196
collections.

00:36:34.686 --> 00:36:36.836
You should consider using them

00:36:36.946 --> 00:36:38.106
explicitly when you need a

00:36:38.106 --> 00:36:39.096
collection with reference

00:36:39.096 --> 00:36:39.756
semantics.

00:36:40.606 --> 00:36:41.496
Don't need to write one of those

00:36:41.496 --> 00:36:42.596
for yourself, we already have

00:36:42.666 --> 00:36:43.326
many great ones.

00:36:43.326 --> 00:36:44.956
You should also use it when

00:36:44.956 --> 00:36:45.796
you're working with types that

00:36:45.796 --> 00:36:46.876
you know to be reference types.

00:36:47.076 --> 00:36:48.636
Things like NS proxies or core

00:36:48.636 --> 00:36:49.716
data managed objects.

00:36:49.956 --> 00:36:52.066
And the final time to consider

00:36:52.066 --> 00:36:53.386
using them is when you're round

00:36:53.386 --> 00:36:54.816
tripping with objective-C code,

00:36:55.216 --> 00:36:56.486
but I'd recommend strongly doing

00:36:56.486 --> 00:36:58.416
this only after you've measured

00:36:58.416 --> 00:36:59.506
and identified that bridging is

00:36:59.506 --> 00:37:00.516
indeed the culprit for whatever

00:37:00.516 --> 00:37:01.546
performance problems you may be

00:37:01.546 --> 00:37:01.906
seeing.

00:37:03.396 --> 00:37:05.076
And now, we've reached the end

00:37:05.076 --> 00:37:06.416
of today's dive into the

00:37:06.416 --> 00:37:07.906
incredible power of our world's

00:37:07.906 --> 00:37:08.786
collections in Swift.

00:37:08.836 --> 00:37:10.946
I want you to use this new-found

00:37:10.946 --> 00:37:12.356
understanding to review your

00:37:12.356 --> 00:37:13.656
existing use of collections.

00:37:14.046 --> 00:37:15.086
Look for places where you can

00:37:15.086 --> 00:37:16.316
improve your code through more

00:37:16.316 --> 00:37:17.716
effective use of indices and

00:37:17.716 --> 00:37:18.196
slices.

00:37:18.926 --> 00:37:19.756
Measure your code.

00:37:20.656 --> 00:37:21.716
And look for places where you

00:37:21.716 --> 00:37:23.586
could benefit by being lazy or

00:37:24.196 --> 00:37:25.786
by tuning how you bridge.

00:37:26.966 --> 00:37:28.526
Use the thread sanitizer to help

00:37:28.556 --> 00:37:30.766
audit your mutable state, and

00:37:30.766 --> 00:37:31.866
further hone your mastery of

00:37:31.866 --> 00:37:33.066
collections by apply all the

00:37:33.066 --> 00:37:34.256
concepts discussed today in

00:37:34.306 --> 00:37:36.646
Playgrounds and you own apps.

00:37:37.876 --> 00:37:38.986
Be sure to visit our last few

00:37:38.986 --> 00:37:39.946
labs today if you have any

00:37:39.946 --> 00:37:41.016
questions about collections.

00:37:41.166 --> 00:37:41.796
We're here to help.

00:37:42.676 --> 00:37:43.666
Thank you so much for you time.

00:37:43.836 --> 00:37:44.856
Now go out and be effective.

00:37:45.508 --> 00:37:47.508
[ Applause ]
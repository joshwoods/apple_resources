WEBVTT

00:00:07.016 --> 00:00:15.500
[ Music ]

00:00:17.516 --> 00:00:20.546
[ Applause ]

00:00:21.046 --> 00:00:21.316
>> Good morning.

00:00:23.076 --> 00:00:24.566
My name is Josh Graessley, and I

00:00:24.566 --> 00:00:25.756
am really excited to be here

00:00:25.756 --> 00:00:27.206
this morning to tell you about

00:00:27.206 --> 00:00:27.936
Network.framework.

00:00:30.236 --> 00:00:32.086
Network.framework is a modern

00:00:32.086 --> 00:00:33.406
alternative to sockets.

00:00:34.016 --> 00:00:35.756
Today, we're going to talk about

00:00:35.756 --> 00:00:37.656
modernization transport APIs.

00:00:37.656 --> 00:00:38.506
This will help give you some

00:00:38.506 --> 00:00:40.176
context to understand what

00:00:40.176 --> 00:00:42.056
Network.framework is and how it

00:00:42.056 --> 00:00:43.786
fits into the system and whether

00:00:43.786 --> 00:00:44.736
or not it's the right thing for

00:00:44.736 --> 00:00:45.956
your application to be using.

00:00:47.286 --> 00:00:48.546
We'll introduce you to the API

00:00:48.916 --> 00:00:49.966
by walking you through making

00:00:49.966 --> 00:00:51.166
your first connections.

00:00:52.206 --> 00:00:53.626
We'll talk about how you can use

00:00:53.626 --> 00:00:55.876
this API to really optimize your

00:00:55.876 --> 00:00:57.826
data transfers and go way beyond

00:00:57.826 --> 00:00:59.016
the performance of anything you

00:00:59.016 --> 00:01:00.026
can do with sockets.

00:01:01.296 --> 00:01:02.496
We'll talk about how this API

00:01:02.496 --> 00:01:04.135
can help you handle some complex

00:01:04.135 --> 00:01:05.726
mobility challenges, and we'll

00:01:05.726 --> 00:01:07.146
wrap up with information on how

00:01:07.146 --> 00:01:08.356
you can get involved and start

00:01:08.356 --> 00:01:08.846
adopting.

00:01:10.116 --> 00:01:11.906
First, I'd like to spend a

00:01:11.906 --> 00:01:13.306
little bit of time talking about

00:01:13.306 --> 00:01:15.096
modernizing transport APIs.

00:01:15.716 --> 00:01:16.916
Now when I say transport API,

00:01:16.916 --> 00:01:19.136
I'm talking about any API that

00:01:19.266 --> 00:01:20.336
lets you send and receive

00:01:20.416 --> 00:01:21.996
arbitrary data between two

00:01:21.996 --> 00:01:23.266
endpoints on a network, and

00:01:23.796 --> 00:01:24.586
that's a pretty broad

00:01:24.586 --> 00:01:25.686
definition, and there are a lot

00:01:25.686 --> 00:01:27.366
of APIs that could fall under

00:01:27.366 --> 00:01:28.036
this category.

00:01:30.096 --> 00:01:32.046
Perhaps the most ubiquitous is

00:01:32.046 --> 00:01:32.706
sockets.

00:01:32.886 --> 00:01:34.006
Sockets has been within us for

00:01:34.046 --> 00:01:36.066
over 30 years, and I don't think

00:01:36.066 --> 00:01:37.306
it's an exaggeration to say that

00:01:37.306 --> 00:01:38.696
sockets has changed the world,

00:01:39.346 --> 00:01:40.606
but the world has kept changing.

00:01:41.166 --> 00:01:43.046
And as a consequence, using

00:01:43.046 --> 00:01:44.346
sockets to write apps for

00:01:44.346 --> 00:01:46.636
today's internet is really hard.

00:01:47.396 --> 00:01:49.446
There are three primary areas in

00:01:49.446 --> 00:01:50.816
which it's very difficult to use

00:01:50.816 --> 00:01:51.526
sockets well.

00:01:52.896 --> 00:01:54.496
The first one is Connection

00:01:54.496 --> 00:01:55.156
Establishment.

00:01:55.586 --> 00:01:57.296
There's a whole host of reasons

00:01:57.626 --> 00:01:58.916
that establishing connections

00:01:59.216 --> 00:02:00.266
can be really difficult with

00:02:00.266 --> 00:02:00.806
sockets.

00:02:01.356 --> 00:02:03.186
For starters, sockets connect to

00:02:03.186 --> 00:02:05.556
addresses, so you have to, most

00:02:05.556 --> 00:02:06.436
of the time you have a host

00:02:06.436 --> 00:02:07.606
name, so you're going to have to

00:02:07.606 --> 00:02:08.866
resolve that host name to an

00:02:08.866 --> 00:02:10.455
address.

00:02:10.616 --> 00:02:11.926
When you do that, you often end

00:02:11.926 --> 00:02:13.286
up with way more than one

00:02:13.286 --> 00:02:13.826
address.

00:02:13.826 --> 00:02:15.536
You'll have some IPv4 addresses,

00:02:15.816 --> 00:02:18.396
some IPv6 addresses, and now

00:02:18.396 --> 00:02:19.476
you've got this challenge, which

00:02:19.516 --> 00:02:20.376
address should you try and

00:02:20.376 --> 00:02:21.746
connect to, in what order?

00:02:22.076 --> 00:02:23.086
How long do you wait before you

00:02:23.086 --> 00:02:23.856
try the next one?

00:02:24.336 --> 00:02:25.776
You can spend years trying to

00:02:25.776 --> 00:02:26.426
perfect this.

00:02:26.806 --> 00:02:29.606
I know because we have.

00:02:30.266 --> 00:02:31.546
Once you get past the dual stack

00:02:31.806 --> 00:02:33.536
host problems, you run into a

00:02:33.536 --> 00:02:35.016
whole bunch of other issues.

00:02:35.466 --> 00:02:36.746
There are some networks that use

00:02:36.746 --> 00:02:38.146
something called Proxy Automatic

00:02:38.146 --> 00:02:39.296
Configuration or PAC.

00:02:40.116 --> 00:02:41.266
On these networks, there's a

00:02:41.266 --> 00:02:42.946
JavaScript that you get, and you

00:02:42.946 --> 00:02:44.256
have to pass a URL into the

00:02:44.256 --> 00:02:45.846
JavaScript, and the JavaScript

00:02:45.846 --> 00:02:47.376
runs and spits out an answer

00:02:47.706 --> 00:02:49.646
that says either you can go

00:02:49.646 --> 00:02:51.226
direct or you have to use this

00:02:51.226 --> 00:02:52.876
SOCKS proxy over here or that

00:02:52.876 --> 00:02:54.466
HTTP connect proxy over there.

00:02:54.946 --> 00:02:56.196
And now your app has to support

00:02:56.196 --> 00:02:58.176
SOCKS proxies and HTTP connect

00:02:58.306 --> 00:03:00.016
proxies, and this can be really

00:03:00.016 --> 00:03:01.046
difficult to do well.

00:03:01.876 --> 00:03:03.066
And the most difficult thing is

00:03:03.286 --> 00:03:04.256
that you may not have one of

00:03:04.256 --> 00:03:05.386
these networks to test on, so

00:03:05.766 --> 00:03:06.936
you may get a bug report from

00:03:07.066 --> 00:03:08.926
one of your customers, and they

00:03:09.146 --> 00:03:10.296
may complain that it's not

00:03:10.296 --> 00:03:11.066
working well on their

00:03:11.066 --> 00:03:11.656
environment.

00:03:12.096 --> 00:03:13.236
And you may want to add code to

00:03:13.236 --> 00:03:16.016
fix the problem, but that once

00:03:16.016 --> 00:03:17.036
you've got it in there, you

00:03:17.036 --> 00:03:17.896
really don't have a good way to

00:03:17.896 --> 00:03:18.336
test it.

00:03:18.336 --> 00:03:19.266
You have to end up building the

00:03:19.266 --> 00:03:20.706
whole environment to reproduce

00:03:20.706 --> 00:03:21.856
the same environment they have.

00:03:22.616 --> 00:03:23.726
It can be a real challenge.

00:03:24.716 --> 00:03:26.436
So connecting with sockets is

00:03:26.436 --> 00:03:26.926
really hard.

00:03:28.336 --> 00:03:30.056
The second thing that becomes

00:03:30.056 --> 00:03:31.486
challenges with sockets is data

00:03:31.486 --> 00:03:32.206
transfers.

00:03:33.056 --> 00:03:34.256
There's a lot of reasons that

00:03:34.256 --> 00:03:35.486
transferring data with sockets

00:03:35.486 --> 00:03:36.416
can be really difficult.

00:03:36.936 --> 00:03:39.896
The primary problem is the read

00:03:39.896 --> 00:03:42.736
and write model itself.

00:03:42.736 --> 00:03:43.626
If you're using blocking

00:03:43.626 --> 00:03:45.846
sockets, it pretty simple, but

00:03:45.846 --> 00:03:47.306
you're tying up a thread, and

00:03:47.306 --> 00:03:48.896
it's really not a great idea to

00:03:48.896 --> 00:03:49.976
be tying up a thread while

00:03:49.976 --> 00:03:50.946
you're waiting to read or write

00:03:50.976 --> 00:03:51.196
data.

00:03:52.206 --> 00:03:53.476
You can switch to nonblocking,

00:03:53.816 --> 00:03:54.706
but then you end up with a whole

00:03:54.706 --> 00:03:55.876
lot of other challenges that you

00:03:55.876 --> 00:03:56.366
run into.

00:03:57.456 --> 00:03:58.596
When you're using nonblocking,

00:03:58.736 --> 00:03:59.916
you may tell the kernel I'd like

00:03:59.916 --> 00:04:01.346
100 bytes, and the kernel will

00:04:01.346 --> 00:04:02.966
come back and say, I've got 10

00:04:02.966 --> 00:04:03.966
bytes for you, why don't you

00:04:03.966 --> 00:04:04.596
come back later.

00:04:04.996 --> 00:04:05.606
And now you have to build a

00:04:05.606 --> 00:04:06.696
state machine to keep track of

00:04:06.696 --> 00:04:07.916
how many bytes you read versus

00:04:07.916 --> 00:04:08.916
how many bytes you want to read.

00:04:09.306 --> 00:04:10.996
This can be a lot of work, and

00:04:10.996 --> 00:04:12.126
getting it to perform well can

00:04:12.126 --> 00:04:12.986
be a real challenge.

00:04:13.556 --> 00:04:15.986
On top of all of that, you

00:04:16.026 --> 00:04:16.906
really shouldn't be reading and

00:04:16.906 --> 00:04:18.016
writing to sockets directly

00:04:18.125 --> 00:04:18.896
because you should be using

00:04:18.896 --> 00:04:19.995
something like transport layer

00:04:19.995 --> 00:04:21.236
security or TLS.

00:04:24.226 --> 00:04:25.796
Sockets don't support TLS, so

00:04:26.006 --> 00:04:27.266
you're probably using some other

00:04:27.266 --> 00:04:30.836
library that is handling TLS for

00:04:30.836 --> 00:04:31.886
you and reading and writing to

00:04:31.886 --> 00:04:33.256
the sockets on your behalf, or

00:04:33.256 --> 00:04:34.186
you're writing the glue code

00:04:34.186 --> 00:04:35.386
between that library and

00:04:35.386 --> 00:04:36.746
sockets, and you have to figure

00:04:36.746 --> 00:04:37.756
out how to get all this to work

00:04:37.756 --> 00:04:38.766
with all the crazy connection

00:04:38.766 --> 00:04:39.796
logic that you put in ahead of

00:04:39.796 --> 00:04:40.056
time.

00:04:40.386 --> 00:04:42.496
There's a lot here that can be

00:04:42.496 --> 00:04:43.146
really difficult.

00:04:45.096 --> 00:04:47.106
Finally, mobility can be really

00:04:47.106 --> 00:04:48.656
challenges with sockets for a

00:04:48.656 --> 00:04:49.626
variety of reasons.

00:04:50.166 --> 00:04:53.286
I think a lot of this boils down

00:04:53.286 --> 00:04:54.626
to the fact that when sockets

00:04:54.626 --> 00:04:56.966
came out, a lot of the devices

00:04:56.966 --> 00:04:57.876
required more than a single

00:04:57.876 --> 00:04:58.876
person to move them, and they

00:04:58.876 --> 00:04:59.906
were connected with a single

00:04:59.906 --> 00:05:01.436
wire, and they had a static IP

00:05:01.516 --> 00:05:02.486
address, and everything was

00:05:02.486 --> 00:05:03.566
stable and simple.

00:05:04.376 --> 00:05:05.506
And today, we have these

00:05:05.506 --> 00:05:07.626
incredibly powerful devices in

00:05:07.626 --> 00:05:09.666
our pocket with multiple radios

00:05:09.986 --> 00:05:11.556
that may be on at the same time,

00:05:12.076 --> 00:05:13.476
and some of them are moving from

00:05:13.476 --> 00:05:14.876
network to network, and your

00:05:14.876 --> 00:05:16.356
application has to handle all

00:05:16.356 --> 00:05:17.566
these transitions well to

00:05:17.566 --> 00:05:18.846
provide a seamless experience to

00:05:18.846 --> 00:05:19.616
your customers.

00:05:21.176 --> 00:05:24.316
Sockets does nothing to help you

00:05:24.316 --> 00:05:24.826
with this.

00:05:25.116 --> 00:05:26.376
You can use routing sockets, but

00:05:26.376 --> 00:05:27.916
it's really, really difficult.

00:05:28.586 --> 00:05:30.016
We think a transport API should

00:05:30.016 --> 00:05:30.426
do better.

00:05:32.016 --> 00:05:34.196
Fortunately, on our platform as

00:05:34.196 --> 00:05:35.606
an application developer you

00:05:35.606 --> 00:05:37.966
have a great API in URLSession.

00:05:39.156 --> 00:05:41.406
URLSession handles all of these

00:05:41.446 --> 00:05:42.256
problems for you.

00:05:43.196 --> 00:05:45.016
It's really focused on HTTP, but

00:05:45.016 --> 00:05:46.756
it also has stream task that

00:05:46.756 --> 00:05:48.666
gives you raw access to TCP and

00:05:48.666 --> 00:05:49.766
TLS connections.

00:05:50.776 --> 00:05:52.076
Now you might be looking at

00:05:52.076 --> 00:05:53.316
this, and you may not have

00:05:53.496 --> 00:05:54.566
cheated by looking at the

00:05:54.666 --> 00:05:56.426
description in the WWDC app.

00:05:56.996 --> 00:05:58.366
You might think that URLSession

00:05:58.886 --> 00:06:00.626
is built on the same primitives

00:06:00.626 --> 00:06:01.826
that you would use yourself.

00:06:03.366 --> 00:06:04.476
But it turns out that's not the

00:06:04.476 --> 00:06:06.046
case.

00:06:06.046 --> 00:06:07.786
URLSession is built on top of

00:06:07.786 --> 00:06:08.396
something we call

00:06:08.396 --> 00:06:09.126
Network.framework.

00:06:10.116 --> 00:06:11.806
URLSession really focuses on all

00:06:11.806 --> 00:06:14.186
of the HTTP bits, and it

00:06:14.186 --> 00:06:15.766
offloads a lot of the transport

00:06:15.766 --> 00:06:16.646
functionality to

00:06:16.646 --> 00:06:17.356
Network.framework.

00:06:21.056 --> 00:06:22.156
Network.framework is something

00:06:22.156 --> 00:06:23.076
we've been working on for a

00:06:23.076 --> 00:06:24.496
number of years, and in

00:06:24.496 --> 00:06:25.886
supporting URLSession, we've

00:06:25.886 --> 00:06:27.716
learned a lot, and we've taken a

00:06:27.716 --> 00:06:28.826
lot of those lessons to the

00:06:28.826 --> 00:06:29.166
IETF.

00:06:29.166 --> 00:06:30.706
A number of our engineers

00:06:30.706 --> 00:06:32.536
regularly participate in the

00:06:32.536 --> 00:06:33.966
IETF and meet with engineers

00:06:33.966 --> 00:06:35.366
from other companies, and

00:06:35.366 --> 00:06:36.376
they've been discussing a lot of

00:06:36.376 --> 00:06:37.146
what we've learned in the

00:06:37.146 --> 00:06:38.366
transport services working

00:06:38.366 --> 00:06:38.576
group.

00:06:39.116 --> 00:06:40.196
And in those discussions, we've

00:06:40.196 --> 00:06:41.636
got some great feedback, and

00:06:41.636 --> 00:06:42.766
we've brought that back in and

00:06:42.766 --> 00:06:44.086
improved Network.framework based

00:06:44.086 --> 00:06:44.396
on that.

00:06:45.556 --> 00:06:46.636
We are really excited to

00:06:46.636 --> 00:06:48.376
announce this year that your

00:06:48.376 --> 00:06:50.266
applications can take advantage

00:06:50.336 --> 00:06:51.826
of this same library directly

00:06:51.826 --> 00:06:51.976
now.

00:06:52.516 --> 00:06:58.176
[ Applause ]

00:06:58.676 --> 00:06:59.446
Now we know that one of the

00:06:59.446 --> 00:07:01.256
things people love about sockets

00:07:01.256 --> 00:07:02.446
is that it gives them very

00:07:02.446 --> 00:07:03.976
fine-grain control over just

00:07:03.976 --> 00:07:05.456
about everything, and they're

00:07:05.456 --> 00:07:06.926
really loathe to give that up.

00:07:07.166 --> 00:07:08.156
So as we developed

00:07:08.156 --> 00:07:09.386
Network.framework, we wanted to

00:07:09.386 --> 00:07:10.866
make sure that it did the right

00:07:10.926 --> 00:07:12.536
thing by default in the way that

00:07:12.536 --> 00:07:14.296
sockets doesn't, but it gave you

00:07:14.296 --> 00:07:16.186
all the knobs that sockets does.

00:07:16.506 --> 00:07:17.236
And it's kind of got this

00:07:17.276 --> 00:07:19.936
gradient, so the more knobs you

00:07:19.936 --> 00:07:20.976
turn, the more complex it

00:07:21.016 --> 00:07:21.546
becomes.

00:07:22.016 --> 00:07:23.266
It gives you all the power you

00:07:23.266 --> 00:07:24.836
need, but you don't have to pay

00:07:24.866 --> 00:07:26.146
for the complexity unless you

00:07:26.146 --> 00:07:29.506
actually need some of it.

00:07:30.406 --> 00:07:32.426
Network.framework has incredibly

00:07:32.426 --> 00:07:34.016
smart connection establishment.

00:07:34.856 --> 00:07:36.936
It handles the dual stack cases.

00:07:36.936 --> 00:07:38.916
It handles IPv6 only networks.

00:07:38.916 --> 00:07:39.726
It handles PAC.

00:07:39.876 --> 00:07:40.976
It handles proxies.

00:07:41.676 --> 00:07:43.936
It will help you connect on

00:07:43.936 --> 00:07:45.386
networks that are otherwise very

00:07:45.386 --> 00:07:46.206
difficult to deal with.

00:07:47.116 --> 00:07:48.656
It has an incredibly optimized

00:07:48.656 --> 00:07:50.706
data transfer path that lets you

00:07:50.706 --> 00:07:52.146
go way beyond the performance of

00:07:52.146 --> 00:07:52.906
anything you can do with

00:07:52.906 --> 00:07:54.086
sockets, and Tommy will cover

00:07:54.086 --> 00:07:54.746
that in a little bit.

00:07:55.906 --> 00:07:57.326
It has support for built-in

00:07:57.326 --> 00:07:57.856
security.

00:07:58.326 --> 00:08:00.796
It supports TLS and DTLS by

00:08:00.796 --> 00:08:01.226
default.

00:08:01.476 --> 00:08:03.776
It's really simple to use.

00:08:04.256 --> 00:08:05.616
It has great support for

00:08:05.616 --> 00:08:06.136
mobility.

00:08:06.336 --> 00:08:07.926
It provides notifications about

00:08:07.926 --> 00:08:08.946
network changes that are

00:08:08.976 --> 00:08:10.386
relevant to the connections that

00:08:10.386 --> 00:08:11.216
your application is

00:08:11.216 --> 00:08:11.876
establishing.

00:08:12.476 --> 00:08:17.046
It's available on iOS, macOS,

00:08:17.146 --> 00:08:19.366
and tvOS as a CAPI with

00:08:19.366 --> 00:08:20.616
automatic reference counting, so

00:08:20.616 --> 00:08:21.836
it's easy to use from Objective

00:08:21.836 --> 00:08:23.646
C, and it has an incredible

00:08:23.646 --> 00:08:24.306
Swift API.

00:08:25.066 --> 00:08:28.166
With that, I'd like to turn it

00:08:28.166 --> 00:08:29.566
over to Tommy Pauly, to walk you

00:08:29.566 --> 00:08:30.406
through making your first

00:08:30.406 --> 00:08:30.856
connection.

00:08:31.416 --> 00:08:31.756
Thank you.

00:08:32.508 --> 00:08:34.508
[ Applause ]

00:08:38.496 --> 00:08:39.866
>> All right, hello everyone.

00:08:40.126 --> 00:08:41.556
My name is Tommy Pauly, and I'm

00:08:41.556 --> 00:08:43.306
on the networking team here at

00:08:43.306 --> 00:08:43.586
Apple.

00:08:44.686 --> 00:08:46.766
And so I'm sure a lot of you are

00:08:46.766 --> 00:08:48.156
really excited to start seeing

00:08:48.156 --> 00:08:50.226
how you can start adopting

00:08:50.366 --> 00:08:52.086
Network.framework in your apps.

00:08:53.366 --> 00:08:55.386
And the best place to start and

00:08:55.386 --> 00:08:56.836
just dive right in is by making

00:08:56.836 --> 00:08:57.726
your first connection.

00:08:57.726 --> 00:08:59.266
And you're going to be making

00:08:59.266 --> 00:09:00.266
your connection from your local

00:09:00.266 --> 00:09:03.246
device, to your server, or to

00:09:03.246 --> 00:09:04.586
some other peer device that's on

00:09:04.586 --> 00:09:05.966
your local network.

00:09:06.856 --> 00:09:09.296
But you may be wondering, what

00:09:09.296 --> 00:09:10.306
kind of connections are

00:09:10.306 --> 00:09:11.526
appropriate to use with

00:09:11.526 --> 00:09:12.246
Network.framework.

00:09:12.716 --> 00:09:13.826
What are the use cases?

00:09:14.596 --> 00:09:16.716
And so let's explore first some

00:09:16.716 --> 00:09:18.836
scenarios of apps that may be

00:09:18.836 --> 00:09:21.096
using sockets today and would

00:09:21.096 --> 00:09:22.826
really benefit a lot by taking

00:09:22.826 --> 00:09:23.976
advantage of Network.framework

00:09:24.126 --> 00:09:24.926
going forward.

00:09:25.526 --> 00:09:28.066
So the first one of these I want

00:09:28.066 --> 00:09:30.296
to highlight is gaming apps.

00:09:31.076 --> 00:09:33.316
Gaming apps often use UDP to

00:09:33.886 --> 00:09:35.456
send real-time data about the

00:09:35.456 --> 00:09:37.866
game state between one device

00:09:37.866 --> 00:09:38.386
and another.

00:09:39.246 --> 00:09:40.506
And they really care about

00:09:40.506 --> 00:09:42.496
optimizing for latency and

00:09:42.496 --> 00:09:43.866
making sure there's no lag or

00:09:43.866 --> 00:09:44.906
anything being dropped there.

00:09:46.056 --> 00:09:47.626
If you have an app like this,

00:09:48.396 --> 00:09:49.276
you're going to love how

00:09:49.276 --> 00:09:50.896
Network.framework allows you to

00:09:50.996 --> 00:09:52.736
really optimize your UDP,

00:09:52.996 --> 00:09:54.756
sending and receiving to be

00:09:55.246 --> 00:09:57.336
faster than ever before with the

00:09:57.336 --> 00:09:58.546
least latency possible.

00:09:58.946 --> 00:10:02.306
Another type of app that would

00:10:02.306 --> 00:10:03.586
take a lot of advantage from

00:10:03.586 --> 00:10:05.046
Network.framework is

00:10:05.046 --> 00:10:06.396
live-streaming apps.

00:10:06.746 --> 00:10:08.616
So live streaming often will use

00:10:08.906 --> 00:10:11.776
a combination of UDP and TCP in

00:10:11.896 --> 00:10:14.286
their apps, but the key point

00:10:14.286 --> 00:10:15.986
here is that it's generating

00:10:15.986 --> 00:10:17.276
data on the fly.

00:10:17.276 --> 00:10:19.606
If you have new video frames or

00:10:19.606 --> 00:10:21.426
audio frames, you need to make

00:10:21.426 --> 00:10:22.906
sure that those are paced well

00:10:22.906 --> 00:10:24.336
and you're not incurring a lot

00:10:24.336 --> 00:10:26.866
of buffering on the device or on

00:10:26.866 --> 00:10:27.366
the network.

00:10:28.486 --> 00:10:30.786
The asynchronous model for

00:10:30.786 --> 00:10:32.166
reading and writing in

00:10:32.166 --> 00:10:33.326
Network.framework is going to be

00:10:33.326 --> 00:10:34.936
perfect for making sure you

00:10:34.936 --> 00:10:35.956
reduce that buffering.

00:10:36.476 --> 00:10:39.246
And the last case I want to

00:10:39.246 --> 00:10:41.396
highlight are mail and messaging

00:10:41.396 --> 00:10:41.876
apps.

00:10:43.086 --> 00:10:44.336
So these are going to be using a

00:10:44.336 --> 00:10:46.006
lot more traditional protocols,

00:10:46.036 --> 00:10:48.026
just TLS over TCP.

00:10:49.016 --> 00:10:50.376
However, it's really critical

00:10:50.376 --> 00:10:51.676
for apps like this to handle

00:10:51.676 --> 00:10:52.846
network transitions really

00:10:52.846 --> 00:10:53.416
gracefully.

00:10:55.446 --> 00:10:56.436
Oftentimes if you have a

00:10:56.436 --> 00:10:57.906
messaging app, your user is

00:10:57.906 --> 00:10:59.306
going to be using your app as

00:10:59.306 --> 00:11:00.066
they're walking out of the

00:11:00.066 --> 00:11:01.416
building, texting their friend

00:11:01.696 --> 00:11:02.626
to let them know that they're on

00:11:02.626 --> 00:11:03.006
their way.

00:11:03.706 --> 00:11:04.766
And you want to make sure that

00:11:04.766 --> 00:11:06.216
you're handling that transition

00:11:06.446 --> 00:11:07.466
from the WiFi network in the

00:11:07.466 --> 00:11:08.626
building to the cell network

00:11:08.656 --> 00:11:10.466
that they're going onto and that

00:11:10.466 --> 00:11:11.986
you don't hand a long time for

00:11:11.986 --> 00:11:13.306
that message to actually get to

00:11:13.306 --> 00:11:13.766
their friend.

00:11:14.246 --> 00:11:16.606
And these are just three

00:11:16.606 --> 00:11:18.286
examples of the types of apps

00:11:18.286 --> 00:11:19.766
that may use low-level

00:11:19.766 --> 00:11:20.826
networking like this.

00:11:21.576 --> 00:11:22.816
There are many other types of

00:11:22.816 --> 00:11:24.356
apps that could take advantage

00:11:24.356 --> 00:11:25.596
of this, so if you have an app

00:11:25.596 --> 00:11:27.506
like one of these or some other

00:11:27.506 --> 00:11:28.756
use case that currently uses

00:11:28.756 --> 00:11:30.696
sockets, I invite you to follow

00:11:30.696 --> 00:11:33.046
along and see how your app can

00:11:33.046 --> 00:11:33.476
benefit.

00:11:33.476 --> 00:11:36.096
So to get started, I want to

00:11:36.096 --> 00:11:37.766
focus on that last case, the

00:11:37.766 --> 00:11:39.316
simplest case of mail and

00:11:39.316 --> 00:11:41.056
messaging apps and looking at

00:11:41.056 --> 00:11:42.586
how they establish connections.

00:11:43.286 --> 00:11:46.076
So when you want to establish

00:11:46.076 --> 00:11:47.126
your connection to a server,

00:11:47.306 --> 00:11:49.226
let's say it's for a mail

00:11:49.226 --> 00:11:51.716
connection, iMap with security,

00:11:51.826 --> 00:11:54.006
with TLS, you start with your

00:11:54.006 --> 00:11:56.426
hostname, mail.example.com.

00:11:57.326 --> 00:11:58.336
You have a port you want to

00:11:58.336 --> 00:12:00.956
connect to, port 993, and you

00:12:00.956 --> 00:12:04.306
want to be using TLS as well as

00:12:04.856 --> 00:12:04.946
TCP.

00:12:05.156 --> 00:12:06.336
So how would this look in

00:12:06.336 --> 00:12:07.426
sockets traditionally?

00:12:08.466 --> 00:12:09.576
Something like this to get

00:12:09.576 --> 00:12:09.926
started.

00:12:10.526 --> 00:12:11.516
You would take your host name.

00:12:12.126 --> 00:12:13.866
You would call some DNS API to

00:12:13.866 --> 00:12:14.796
resolve that host name.

00:12:15.156 --> 00:12:16.576
Let's say this is getaddrinfo.

00:12:17.346 --> 00:12:18.256
You'll get back one or more

00:12:18.256 --> 00:12:18.876
addresses.

00:12:19.206 --> 00:12:20.386
You'll have to decide which one

00:12:20.386 --> 00:12:21.526
you want to connect to first.

00:12:22.576 --> 00:12:24.116
You'll call socket with the

00:12:24.116 --> 00:12:25.316
appropriate address family.

00:12:26.446 --> 00:12:28.066
You will set a series of socket

00:12:28.066 --> 00:12:28.726
options.

00:12:29.116 --> 00:12:30.176
Let's say you want to make your

00:12:30.176 --> 00:12:32.126
socket nonblocking like Josh

00:12:32.126 --> 00:12:32.876
mentioned before.

00:12:34.356 --> 00:12:36.296
Then you call connect to start

00:12:36.296 --> 00:12:38.216
TCP, and then you wait for a

00:12:38.216 --> 00:12:38.856
writable event.

00:12:40.056 --> 00:12:41.426
And this is before you do

00:12:41.426 --> 00:12:42.876
anything with TLS, and that's a

00:12:42.876 --> 00:12:44.426
whole host of other problems.

00:12:44.966 --> 00:12:47.726
So how does this look in

00:12:47.726 --> 00:12:48.366
Network.framework?

00:12:48.756 --> 00:12:50.066
And we hope that it looks very

00:12:50.066 --> 00:12:52.536
familiar to you but a little bit

00:12:52.536 --> 00:12:52.956
simpler.

00:12:53.716 --> 00:12:54.856
So the first thing you do is you

00:12:54.856 --> 00:12:55.986
create a connect a connection

00:12:55.986 --> 00:12:56.206
object.

00:12:56.536 --> 00:12:57.936
And a connection object is based

00:12:57.936 --> 00:12:58.606
on two things.

00:12:59.116 --> 00:13:00.286
You have an endpoint, which

00:13:00.286 --> 00:13:01.676
defines the destination you want

00:13:01.676 --> 00:13:03.636
to get to, and this could be the

00:13:03.636 --> 00:13:05.186
address, the IP address that you

00:13:05.186 --> 00:13:07.566
had before, but usually, like in

00:13:07.566 --> 00:13:09.126
this example, we have a host

00:13:09.126 --> 00:13:10.846
name and a port, and so our end

00:13:10.876 --> 00:13:12.486
point can just be that host name

00:13:12.486 --> 00:13:12.916
and port.

00:13:13.506 --> 00:13:14.756
It could also be a bonjour

00:13:14.756 --> 00:13:15.856
service that I want to connect

00:13:15.856 --> 00:13:16.016
to.

00:13:17.486 --> 00:13:19.276
And then I also have parameters.

00:13:19.576 --> 00:13:21.286
Parameters define what protocols

00:13:21.286 --> 00:13:24.206
I want to use, TLS, DTLS, UDP,

00:13:24.206 --> 00:13:24.536
TCP.

00:13:24.536 --> 00:13:27.176
It defines the protocol options

00:13:27.176 --> 00:13:29.456
that I want as well as which

00:13:29.496 --> 00:13:31.016
paths I want to use to connect

00:13:31.016 --> 00:13:31.336
over.

00:13:31.726 --> 00:13:32.586
Do I want to just connect over

00:13:32.586 --> 00:13:34.606
anything, or do I only want to

00:13:35.276 --> 00:13:36.136
use WiFi?

00:13:36.316 --> 00:13:37.816
Once you've configured your

00:13:37.816 --> 00:13:39.616
connection, you simply call

00:13:39.616 --> 00:13:41.786
start to get things going, and

00:13:41.786 --> 00:13:42.876
then you wait for the connection

00:13:42.876 --> 00:13:44.196
to move into the ready state.

00:13:44.786 --> 00:13:45.956
And that's all you need to do to

00:13:45.956 --> 00:13:47.376
bring up a full TLS connection

00:13:47.376 --> 00:13:47.906
to your server.

00:13:48.936 --> 00:13:49.746
And I think you're going to love

00:13:49.746 --> 00:13:51.746
how this looks in Swift.

00:13:52.476 --> 00:13:53.536
So here's what you do.

00:13:53.876 --> 00:13:55.636
You first import the network

00:13:55.636 --> 00:13:56.126
module.

00:13:57.496 --> 00:13:59.956
Then, you create an NWConnection

00:13:59.956 --> 00:14:00.406
object.

00:14:00.756 --> 00:14:02.966
So an NWConnection in either

00:14:02.966 --> 00:14:05.596
Swift or in C is the fundamental

00:14:05.596 --> 00:14:06.876
object for reading and writing

00:14:06.876 --> 00:14:07.126
data.

00:14:08.516 --> 00:14:09.316
In this case, we have a

00:14:09.316 --> 00:14:10.886
convenience that initializes

00:14:10.886 --> 00:14:12.526
your endpoint with a host in the

00:14:12.526 --> 00:14:14.946
port, so I give it my hostname,

00:14:14.946 --> 00:14:17.526
male.example.com, and the port.

00:14:17.526 --> 00:14:18.606
And in this case, it's a

00:14:18.606 --> 00:14:19.726
well-known port.

00:14:20.146 --> 00:14:20.906
It's imaps.

00:14:21.086 --> 00:14:22.866
So I can just put that in Swift

00:14:23.156 --> 00:14:24.866
very easy, but I could also put

00:14:24.866 --> 00:14:27.026
any other numeric literal there.

00:14:27.496 --> 00:14:29.726
And then to define what

00:14:29.766 --> 00:14:31.346
protocols I want to use, I pass

00:14:31.386 --> 00:14:33.706
parameters, and since this is a

00:14:33.736 --> 00:14:35.176
client connection, I only want

00:14:35.306 --> 00:14:36.906
default, TLS, and TCP

00:14:36.906 --> 00:14:37.476
parameters.

00:14:38.176 --> 00:14:39.176
It can be as simple as just

00:14:39.176 --> 00:14:41.466
writing dot TLS, and now I have

00:14:41.466 --> 00:14:42.846
a fully-fledged TLS connection.

00:14:44.936 --> 00:14:46.336
The next thing I do is I said

00:14:46.426 --> 00:14:48.046
estate update handler to handle

00:14:48.046 --> 00:14:49.616
all the transitions that my

00:14:49.616 --> 00:14:50.586
connection might go through.

00:14:51.686 --> 00:14:52.696
The first state and the most

00:14:52.696 --> 00:14:53.586
important one that you want to

00:14:53.586 --> 00:14:55.236
handle is the ready state.

00:14:55.916 --> 00:14:57.736
Ready means that your app is

00:14:57.736 --> 00:14:59.346
ready to read and write data on

00:14:59.346 --> 00:15:00.616
this connection, it's totally

00:15:00.616 --> 00:15:03.026
established, and if you're using

00:15:03.386 --> 00:15:05.046
TCP and TLS, this means that the

00:15:05.046 --> 00:15:06.926
TLS handshake is finished.

00:15:08.096 --> 00:15:09.806
We also though let you know

00:15:09.806 --> 00:15:11.216
about the waiting state.

00:15:11.856 --> 00:15:14.526
So last year in URLSession, we

00:15:14.526 --> 00:15:15.636
introduced waits for

00:15:15.636 --> 00:15:17.306
connectivity, and the waiting

00:15:17.306 --> 00:15:19.056
state of an NWConnection is

00:15:19.056 --> 00:15:20.166
exactly the same thing.

00:15:20.446 --> 00:15:21.996
And this is on always by

00:15:21.996 --> 00:15:22.496
default.

00:15:22.866 --> 00:15:23.636
So when you create your

00:15:23.636 --> 00:15:24.746
connection and when you start

00:15:24.746 --> 00:15:25.896
it, if there is no network

00:15:25.896 --> 00:15:28.336
available, we won't fail, we'll

00:15:28.336 --> 00:15:29.816
just tell you we're waiting for

00:15:29.816 --> 00:15:30.726
a network to be available.

00:15:30.726 --> 00:15:32.396
We'll give you a helpful reason

00:15:32.396 --> 00:15:34.246
code, but you don't have to do

00:15:34.246 --> 00:15:35.736
anything more to watch network

00:15:35.736 --> 00:15:36.766
transitions yourself.

00:15:37.516 --> 00:15:38.846
Mobility is an essential,

00:15:38.886 --> 00:15:40.216
critical part of this API.

00:15:40.906 --> 00:15:43.286
And we'll also let you know if

00:15:43.286 --> 00:15:44.196
there's a fatal error.

00:15:44.196 --> 00:15:46.076
Let's say we had to reset from

00:15:46.076 --> 00:15:47.496
the server or TLS failed, and

00:15:47.496 --> 00:15:48.846
we'll give you that as a failed

00:15:49.386 --> 00:15:49.546
event.

00:15:50.276 --> 00:15:52.426
So once you've set this up, you

00:15:52.426 --> 00:15:54.386
simply call start and provide

00:15:54.386 --> 00:15:56.636
the dispatch queue upon which

00:15:56.816 --> 00:15:58.276
you want to receive callbacks.

00:15:58.336 --> 00:16:01.616
So I want to dig into what

00:16:01.616 --> 00:16:03.166
happens when you call start.

00:16:03.166 --> 00:16:04.216
What's actually going on?

00:16:04.976 --> 00:16:06.326
So here's a little state

00:16:06.326 --> 00:16:08.356
machine, the innards of the

00:16:08.356 --> 00:16:09.016
NWConnection.

00:16:09.016 --> 00:16:10.976
When we begin at the setup state

00:16:10.976 --> 00:16:13.686
and we call start, we move into

00:16:13.686 --> 00:16:15.146
the preparing state.

00:16:16.416 --> 00:16:19.116
So the preparing state does a

00:16:19.116 --> 00:16:20.566
lot more than just calling

00:16:20.776 --> 00:16:22.626
connect on a TCP socket.

00:16:23.696 --> 00:16:25.516
For TCP socket, that would just

00:16:25.516 --> 00:16:27.896
send out a SYN packet across to

00:16:27.896 --> 00:16:29.066
the server that you're trying to

00:16:29.066 --> 00:16:29.456
reach.

00:16:30.876 --> 00:16:32.356
But when you call start on an

00:16:32.356 --> 00:16:33.456
NWConnection, it actually

00:16:33.456 --> 00:16:34.766
handles all of the things that

00:16:34.766 --> 00:16:36.226
Josh was mentioning earlier.

00:16:37.206 --> 00:16:38.786
It evaluates the network you're

00:16:38.786 --> 00:16:41.106
on and tries to make the fastest

00:16:41.106 --> 00:16:42.296
connection possible for you.

00:16:42.296 --> 00:16:44.086
I want to dig into that a little

00:16:44.086 --> 00:16:44.446
bit more.

00:16:45.086 --> 00:16:46.896
So this is what we call Smart

00:16:47.146 --> 00:16:48.296
Connection Establishment.

00:16:48.826 --> 00:16:51.286
So the very first thing that we

00:16:51.286 --> 00:16:54.086
do when you call start is that

00:16:54.086 --> 00:16:56.056
we take your endpoint, and then

00:16:56.056 --> 00:16:57.396
we evaluate what are all the

00:16:57.396 --> 00:16:58.306
networks that are currently

00:16:58.306 --> 00:16:58.966
available to me.

00:16:59.876 --> 00:17:01.866
In this case, we have WiFi and

00:17:01.866 --> 00:17:02.336
cellular.

00:17:03.146 --> 00:17:04.866
And generally we prefer the WiFi

00:17:04.866 --> 00:17:06.685
network because it has less cost

00:17:06.685 --> 00:17:07.296
to the user.

00:17:08.165 --> 00:17:09.406
So we'll look at that one first.

00:17:10.776 --> 00:17:12.685
Then we check, are there any

00:17:12.746 --> 00:17:14.136
special configurations on this

00:17:14.136 --> 00:17:14.465
network.

00:17:14.816 --> 00:17:15.425
Is there a VPN?

00:17:15.425 --> 00:17:16.616
Is there a proxy?

00:17:16.616 --> 00:17:18.195
And we'll evaluate that for you.

00:17:19.435 --> 00:17:21.185
In this case, let's say that

00:17:21.185 --> 00:17:23.175
there is a proxy configured with

00:17:23.465 --> 00:17:25.185
an automatic configuration file

00:17:25.616 --> 00:17:28.296
that also lets you go direct if

00:17:28.296 --> 00:17:29.656
the proxy doesn't apply to your

00:17:29.656 --> 00:17:30.146
connection.

00:17:30.626 --> 00:17:32.096
So we'll evaluate both of those

00:17:32.096 --> 00:17:32.536
options.

00:17:33.676 --> 00:17:34.606
We'll check if we need to use

00:17:34.606 --> 00:17:36.566
the proxy, go ahead and connect

00:17:36.566 --> 00:17:38.516
to it, create a TCP connection

00:17:38.516 --> 00:17:38.716
there.

00:17:39.976 --> 00:17:41.456
But if we don't need it, we'll

00:17:41.456 --> 00:17:44.256
do DNS on your behalf going

00:17:44.256 --> 00:17:46.446
directly, get back all of the

00:17:46.446 --> 00:17:48.946
DNS IP address answers, and

00:17:48.946 --> 00:17:51.676
connect to them one after the

00:17:51.676 --> 00:17:52.976
other, leaving them going in

00:17:52.976 --> 00:17:53.436
parallel.

00:17:53.436 --> 00:17:54.966
We're racing them to get you the

00:17:54.966 --> 00:17:56.366
fastest connection possible.

00:17:59.136 --> 00:18:00.616
And then, if something goes

00:18:00.616 --> 00:18:01.926
wrong with WiFi, let's say the

00:18:01.926 --> 00:18:03.806
WiFi radio quality goes really

00:18:03.806 --> 00:18:05.006
bad because you're walking away

00:18:05.006 --> 00:18:07.546
from the building, we can

00:18:07.546 --> 00:18:09.136
actually take advantage of the

00:18:09.136 --> 00:18:11.156
feature called WiFi assist and

00:18:11.156 --> 00:18:13.156
fall back seamlessly to the

00:18:13.156 --> 00:18:15.366
cellular network, do DNS

00:18:15.366 --> 00:18:17.836
resolution there, and try the

00:18:17.836 --> 00:18:18.906
connections one after the other.

00:18:19.146 --> 00:18:22.146
So this way your connection

00:18:22.146 --> 00:18:24.396
establishment is very resilient,

00:18:24.636 --> 00:18:26.926
handles VPNs, handles proxies

00:18:26.926 --> 00:18:29.066
for you, and gets you the best

00:18:29.066 --> 00:18:29.816
connection possible.

00:18:29.816 --> 00:18:34.026
Now, of course, you may not want

00:18:34.116 --> 00:18:35.606
to try all of these options.

00:18:35.606 --> 00:18:37.216
You may want to restrict what

00:18:37.216 --> 00:18:38.176
the connection establishment

00:18:38.176 --> 00:18:40.646
does, and so we have many

00:18:40.746 --> 00:18:42.256
different knobs and controls to

00:18:42.256 --> 00:18:43.346
let you do that, and I want to

00:18:43.346 --> 00:18:44.756
highlight just three of them

00:18:45.296 --> 00:18:45.416
today.

00:18:46.616 --> 00:18:48.986
The first is you may not want to

00:18:48.986 --> 00:18:50.646
use expensive networks, like a

00:18:50.646 --> 00:18:52.376
cellular network, because this

00:18:52.376 --> 00:18:54.106
connection is only appropriate

00:18:54.106 --> 00:18:55.226
to use over WiFi.

00:18:56.086 --> 00:18:57.586
So within the parameters for

00:18:57.586 --> 00:18:59.396
your connection, there are

00:18:59.396 --> 00:19:00.896
options to control the

00:19:00.896 --> 00:19:02.626
interfaces that you use.

00:19:03.076 --> 00:19:03.996
So if you don't want to use

00:19:03.996 --> 00:19:06.176
cellular, simply add cellular to

00:19:06.266 --> 00:19:08.466
the list of prohibited interface

00:19:08.466 --> 00:19:08.956
types.

00:19:09.496 --> 00:19:12.316
It's even better, actually to

00:19:12.316 --> 00:19:14.436
also prohibit expensive networks

00:19:14.436 --> 00:19:16.076
in general because this will

00:19:16.076 --> 00:19:18.526
also block the usage of personal

00:19:18.526 --> 00:19:22.766
hotspots on a Mac let's say.

00:19:23.016 --> 00:19:23.736
Another way that you can

00:19:23.736 --> 00:19:25.066
restrict your connection

00:19:25.066 --> 00:19:26.926
establishment is by choosing

00:19:26.926 --> 00:19:28.406
specifically the IP address

00:19:28.406 --> 00:19:29.816
family that you want to use.

00:19:30.466 --> 00:19:31.596
So let's say that you really

00:19:31.596 --> 00:19:33.376
love IPv6 because it's faster

00:19:33.376 --> 00:19:34.146
and it's the future.

00:19:34.496 --> 00:19:35.646
You don't want to use IPv4 at

00:19:35.646 --> 00:19:36.676
all on your connection.

00:19:37.346 --> 00:19:39.016
And you can do this by going to

00:19:39.016 --> 00:19:40.796
your parameters, digging down

00:19:40.796 --> 00:19:42.466
into the IP-specific options,

00:19:42.896 --> 00:19:44.286
and here you'll have options

00:19:44.286 --> 00:19:45.806
that you'll find familiar from

00:19:45.806 --> 00:19:47.846
your socket options on a socket

00:19:47.846 --> 00:19:49.586
today, and you can also define

00:19:49.656 --> 00:19:51.316
specifically which IP version

00:19:51.316 --> 00:19:52.146
you want to use.

00:19:52.576 --> 00:19:53.876
And this will impact your

00:19:53.876 --> 00:19:55.466
connection as well as your DNS

00:19:55.466 --> 00:19:56.046
resolution.

00:19:56.566 --> 00:19:59.186
And lastly, you may not want to

00:19:59.186 --> 00:20:00.976
use a proxy on your given

00:20:00.976 --> 00:20:01.396
connection.

00:20:01.396 --> 00:20:02.596
Maybe it's not appropriate for

00:20:02.836 --> 00:20:04.266
your connection to go through a

00:20:04.266 --> 00:20:05.096
SOCKS proxy.

00:20:05.766 --> 00:20:07.206
In that case, you can simply

00:20:07.416 --> 00:20:08.856
prohibit the use of proxies as

00:20:08.886 --> 00:20:09.056
well.

00:20:09.646 --> 00:20:12.676
So that's what happens in the

00:20:12.676 --> 00:20:13.386
preparing state.

00:20:14.736 --> 00:20:16.256
I mentioned before that things

00:20:16.636 --> 00:20:17.546
can go wrong.

00:20:17.546 --> 00:20:18.956
You can have no network when you

00:20:18.956 --> 00:20:20.836
try to establish, and what we'll

00:20:20.836 --> 00:20:22.456
do after going to preparing is

00:20:22.456 --> 00:20:23.646
if we find there are no good

00:20:23.646 --> 00:20:25.776
options, DNS failed, there was

00:20:25.776 --> 00:20:27.086
no network, maybe you're in

00:20:27.086 --> 00:20:28.536
airplane mode, we'll move into

00:20:28.536 --> 00:20:29.596
the waiting state and let you

00:20:29.596 --> 00:20:30.516
know the reason for that.

00:20:31.476 --> 00:20:32.766
And we'll keep going back into

00:20:32.766 --> 00:20:34.976
preparing every time the network

00:20:34.976 --> 00:20:36.396
changes and the system thinks,

00:20:36.806 --> 00:20:38.206
yeah, there's a good chance that

00:20:38.266 --> 00:20:39.396
your connection will become

00:20:39.396 --> 00:20:40.816
established now, and we'll

00:20:40.816 --> 00:20:42.586
handle all that for you and let

00:20:42.586 --> 00:20:43.956
you know every time that we're

00:20:43.956 --> 00:20:44.526
reattempting.

00:20:46.236 --> 00:20:48.146
Eventually, hopefully your

00:20:48.146 --> 00:20:49.626
connection does get established.

00:20:49.966 --> 00:20:51.136
At this point, we'll move into

00:20:51.136 --> 00:20:51.826
the ready state.

00:20:52.296 --> 00:20:54.186
And the ready state, as I

00:20:54.186 --> 00:20:56.336
mentioned before, is when your

00:20:56.336 --> 00:20:57.776
connection is fully established.

00:20:57.956 --> 00:20:59.566
So this is all of the protocols

00:20:59.646 --> 00:21:02.086
in your stack up to TLS, for

00:21:02.086 --> 00:21:02.486
example.

00:21:03.476 --> 00:21:04.646
At this point, you can read and

00:21:04.646 --> 00:21:07.066
write, and this is also where we

00:21:07.066 --> 00:21:10.036
give you callbacks about the

00:21:10.036 --> 00:21:11.476
network transitions that you're

00:21:11.476 --> 00:21:12.016
going through.

00:21:12.536 --> 00:21:14.086
So if your connection is

00:21:14.086 --> 00:21:15.236
established and then you change

00:21:15.236 --> 00:21:17.196
networks, we'll give you updates

00:21:17.196 --> 00:21:18.426
about that so you can handle the

00:21:18.426 --> 00:21:20.416
mobility gracefully, and we'll

00:21:20.416 --> 00:21:21.716
be talking about this later on

00:21:21.716 --> 00:21:21.976
in the talk.

00:21:24.536 --> 00:21:25.606
If there's an error on the

00:21:25.606 --> 00:21:27.046
connection, either during the

00:21:27.046 --> 00:21:28.716
connection establishment or

00:21:28.716 --> 00:21:29.916
after you've already connected,

00:21:30.076 --> 00:21:31.136
we'll give you the failed state

00:21:31.136 --> 00:21:33.546
with an error, and then once

00:21:33.546 --> 00:21:34.336
you're totally done with the

00:21:34.336 --> 00:21:35.396
connection, let's say you

00:21:35.396 --> 00:21:36.506
already closed it or you

00:21:36.506 --> 00:21:37.696
received a close from the other

00:21:37.696 --> 00:21:39.606
side, and you want to just

00:21:39.606 --> 00:21:40.766
invalidate the connection, you

00:21:40.766 --> 00:21:42.716
call cancel, and we move into

00:21:42.716 --> 00:21:43.536
the cancelled state.

00:21:43.636 --> 00:21:45.376
And this is guaranteed to be the

00:21:45.376 --> 00:21:47.156
very last event that we will

00:21:47.156 --> 00:21:49.506
deliver to your object so you

00:21:49.506 --> 00:21:50.656
can clean up any memory that you

00:21:50.656 --> 00:21:52.506
have associated and move on.

00:21:53.656 --> 00:21:54.456
So that's it.

00:21:54.576 --> 00:21:56.046
That's an overview of the basic

00:21:56.046 --> 00:21:58.176
lifetime of a connection object

00:21:58.176 --> 00:21:59.786
in Network.framework, and to

00:21:59.786 --> 00:22:01.306
show you how you can use this to

00:22:01.306 --> 00:22:03.286
build a simple app, I'd like to

00:22:03.286 --> 00:22:04.776
invite Eric up to the stage.

00:22:05.516 --> 00:22:10.500
[ Applause ]

00:22:13.196 --> 00:22:14.066
>> Thanks Tommy.

00:22:14.676 --> 00:22:16.216
I'm Eric Kinnear, also from the

00:22:16.216 --> 00:22:17.386
networking team here at Apple,

00:22:17.716 --> 00:22:19.156
and I'm really excited to build

00:22:19.156 --> 00:22:20.636
with you an example application

00:22:20.926 --> 00:22:21.926
using Network.framework.

00:22:23.026 --> 00:22:24.076
We're going to use the live

00:22:24.076 --> 00:22:25.696
streaming example that Tommy

00:22:25.696 --> 00:22:27.516
mentioned earlier to build an

00:22:27.516 --> 00:22:29.106
application that can take the

00:22:29.106 --> 00:22:31.216
camera input on one device and

00:22:31.216 --> 00:22:32.976
send it over a network to be

00:22:32.976 --> 00:22:34.326
displayed on another device.

00:22:35.396 --> 00:22:36.196
Because we're going to be

00:22:36.196 --> 00:22:37.806
continuously generating live

00:22:37.806 --> 00:22:40.156
video frames, we're going to use

00:22:40.376 --> 00:22:41.736
UDP to send those packets across

00:22:41.736 --> 00:22:42.126
the network.

00:22:43.186 --> 00:22:46.036
So how do we do this?

00:22:46.266 --> 00:22:48.126
Well, first, we need a capture

00:22:48.126 --> 00:22:49.566
session with the camera so that

00:22:49.566 --> 00:22:51.026
we can receive the video frames

00:22:51.106 --> 00:22:51.996
from the image sensor.

00:22:53.046 --> 00:22:54.296
For the sake of this example,

00:22:54.666 --> 00:22:55.946
we're not going to use any video

00:22:55.946 --> 00:22:57.346
codecs or other compression.

00:22:57.846 --> 00:22:58.966
We're simply going to take the

00:22:58.966 --> 00:23:00.706
raw bytes from the camera, ship

00:23:00.706 --> 00:23:01.866
them across the network, and

00:23:01.866 --> 00:23:02.936
display them on the other side.

00:23:03.456 --> 00:23:05.966
In order to make this happen, we

00:23:05.966 --> 00:23:07.206
need to divvy those frames up

00:23:07.206 --> 00:23:09.006
into smaller chunks that we can

00:23:09.006 --> 00:23:10.416
send in UDP packets.

00:23:11.986 --> 00:23:13.236
Of course, to send those UDP

00:23:13.236 --> 00:23:14.876
packets on the network, we need

00:23:15.766 --> 00:23:16.926
a connection.

00:23:16.926 --> 00:23:17.846
Switching over to the other

00:23:17.846 --> 00:23:19.906
device, we need a listener that

00:23:19.906 --> 00:23:21.036
can receive that incoming

00:23:21.036 --> 00:23:23.196
connection and read the data

00:23:23.196 --> 00:23:24.366
packets off the network.

00:23:25.156 --> 00:23:26.326
From there, we simply reverse

00:23:26.326 --> 00:23:27.336
the earlier process,

00:23:27.796 --> 00:23:29.056
reassembling the video frames

00:23:29.366 --> 00:23:30.756
and sending them to the display

00:23:30.756 --> 00:23:31.666
so that we can see them on the

00:23:31.666 --> 00:23:31.966
screen.

00:23:32.556 --> 00:23:35.536
To keep things simple, we've

00:23:35.536 --> 00:23:36.766
already abstracted out the

00:23:36.766 --> 00:23:37.846
camera and the display

00:23:37.846 --> 00:23:39.346
functionalities so that we can

00:23:39.346 --> 00:23:41.156
focus just on the parts that use

00:23:41.156 --> 00:23:41.806
Network.framework.

00:23:43.296 --> 00:23:44.856
There's one piece we haven't yet

00:23:44.856 --> 00:23:46.086
covered here, and that's the

00:23:46.086 --> 00:23:46.496
listener.

00:23:46.836 --> 00:23:47.646
So we're going to take a minute

00:23:47.646 --> 00:23:50.076
to do that now.

00:23:50.326 --> 00:23:51.726
Listener functionality is

00:23:51.726 --> 00:23:53.116
provided by the NWListener

00:23:53.116 --> 00:23:54.976
class, which you can create

00:23:54.976 --> 00:23:56.026
using the same parameters

00:23:56.026 --> 00:23:57.386
objects that you used to

00:23:57.386 --> 00:23:58.206
configure connections.

00:23:59.836 --> 00:24:01.296
It's really easy to set up a

00:24:01.296 --> 00:24:03.296
listener to advertise a bonjour

00:24:03.296 --> 00:24:03.826
service.

00:24:04.146 --> 00:24:05.316
In this case, we'll use

00:24:05.316 --> 00:24:06.076
camera.udp.

00:24:06.076 --> 00:24:10.246
When a new connection is

00:24:10.246 --> 00:24:11.946
received by a listener, it will

00:24:11.946 --> 00:24:13.286
pass that connection to a block

00:24:13.286 --> 00:24:14.566
that you provide as the

00:24:14.566 --> 00:24:15.436
newConnectionHandler.

00:24:16.496 --> 00:24:17.606
This is your opportunity to

00:24:17.666 --> 00:24:19.096
perform any configuration that

00:24:19.096 --> 00:24:20.586
you choose on that connection,

00:24:21.036 --> 00:24:22.216
and then you need to call start

00:24:22.556 --> 00:24:24.006
to let that connection know that

00:24:24.006 --> 00:24:26.716
it's time to get going.

00:24:26.936 --> 00:24:28.226
Similarly, you need to call

00:24:28.226 --> 00:24:29.576
start on your listener, and

00:24:29.576 --> 00:24:30.566
again, just like with

00:24:30.566 --> 00:24:31.696
connections, you provide a

00:24:31.696 --> 00:24:33.016
dispatch queue where you want

00:24:33.016 --> 00:24:34.136
these callbacks to be scheduled.

00:24:34.666 --> 00:24:36.706
So that's listeners.

00:24:37.106 --> 00:24:38.516
If you think about it, we just

00:24:38.516 --> 00:24:39.916
implemented the equivalent of

00:24:39.916 --> 00:24:41.806
calling listen on a UDP socket.

00:24:42.926 --> 00:24:45.236
Except listen doesn't actually

00:24:45.236 --> 00:24:47.346
work on UDP sockets.

00:24:47.476 --> 00:24:48.906
Now we're ready to build our app

00:24:48.906 --> 00:24:49.376
in Xcode.

00:24:50.646 --> 00:24:51.476
So here we've got our

00:24:51.476 --> 00:24:53.026
application, and we've got a

00:24:53.026 --> 00:24:54.596
bunch of files over here that

00:24:54.596 --> 00:24:55.976
already handle the camera and

00:24:55.976 --> 00:24:57.876
the display functionality, so

00:24:57.876 --> 00:24:59.126
we're going to focus just on the

00:24:59.126 --> 00:25:01.316
UDPClient class and the

00:25:01.316 --> 00:25:02.076
UDPServer class.

00:25:03.156 --> 00:25:05.016
The UDPClient is going to be

00:25:05.016 --> 00:25:06.306
responsible for creating the

00:25:06.306 --> 00:25:07.966
connection to the other side and

00:25:07.966 --> 00:25:09.026
sending the frames across.

00:25:10.286 --> 00:25:11.776
Likewise, the server is

00:25:11.776 --> 00:25:12.816
responsible for creating the

00:25:12.816 --> 00:25:14.736
listener, accepting incoming

00:25:14.736 --> 00:25:16.446
connections, reading the data

00:25:16.446 --> 00:25:17.746
off those connections, and

00:25:17.746 --> 00:25:18.756
sending them up to the screen.

00:25:19.736 --> 00:25:22.416
Let's start with the client.

00:25:22.526 --> 00:25:23.656
My client class has an

00:25:23.656 --> 00:25:25.656
initializer that takes a name,

00:25:25.996 --> 00:25:28.056
which is a string describing the

00:25:28.056 --> 00:25:29.766
bonjour name that we want to

00:25:30.316 --> 00:25:31.436
connect to.

00:25:31.646 --> 00:25:33.836
I'll create my connection by

00:25:33.836 --> 00:25:35.986
simply calling NWConnection and

00:25:35.986 --> 00:25:37.296
passing in a service endpoint.

00:25:38.096 --> 00:25:39.116
Using the name that I was

00:25:39.116 --> 00:25:42.826
provided and camera.udp as the

00:25:43.456 --> 00:25:43.556
type.

00:25:43.776 --> 00:25:45.336
We also passed the default UDP

00:25:45.336 --> 00:25:45.876
parameters.

00:25:46.386 --> 00:25:49.596
As Tommy mentioned, we can use a

00:25:49.596 --> 00:25:52.826
state update handler to check

00:25:53.226 --> 00:25:54.546
for the ready and the failed

00:25:54.546 --> 00:25:55.016
states.

00:25:56.066 --> 00:25:57.546
Here, when our connection is

00:25:57.546 --> 00:25:58.776
ready, we'll call

00:25:58.776 --> 00:26:00.676
sendInitialFrame, which we'll

00:26:00.676 --> 00:26:02.616
implement in a minute.

00:26:02.726 --> 00:26:04.466
Because we're using UDP and

00:26:04.466 --> 00:26:05.526
there's no other handshake,

00:26:05.996 --> 00:26:07.216
we're going to take some data

00:26:07.566 --> 00:26:08.556
and send it across to the

00:26:08.556 --> 00:26:11.066
network to the other device and

00:26:11.066 --> 00:26:12.226
wait for it to be echoed back

00:26:12.586 --> 00:26:13.926
before we start generating lots

00:26:13.926 --> 00:26:15.266
of video frames and dumping them

00:26:15.266 --> 00:26:15.766
on the network.

00:26:19.176 --> 00:26:20.886
We need to remember to call

00:26:20.886 --> 00:26:22.576
start on our connection, and we

00:26:22.576 --> 00:26:23.466
provide the queue that we

00:26:23.466 --> 00:26:26.026
created up above.

00:26:26.236 --> 00:26:27.296
Let's implement send initial

00:26:27.296 --> 00:26:27.576
frame.

00:26:32.156 --> 00:26:33.346
Here we're going to take the

00:26:33.346 --> 00:26:35.876
literal bytes hello and create a

00:26:35.876 --> 00:26:38.156
data object using them.

00:26:38.156 --> 00:26:39.746
To send content on a connection,

00:26:40.206 --> 00:26:42.216
we can call connection.send and

00:26:42.216 --> 00:26:44.056
provide that data object as the

00:26:44.056 --> 00:26:44.496
content.

00:26:45.876 --> 00:26:47.396
We provide a completion handler

00:26:47.646 --> 00:26:48.886
in which we can check for any

00:26:48.886 --> 00:26:49.986
errors that may have been

00:26:49.986 --> 00:26:50.906
encountered while sending.

00:26:51.416 --> 00:26:54.396
Since we expect this content to

00:26:54.396 --> 00:26:56.066
be immediately echoed back, we

00:26:56.066 --> 00:26:57.316
turn right around and call

00:26:57.316 --> 00:26:59.056
connection.receive to read the

00:26:59.056 --> 00:27:00.126
incoming data off of the

00:27:00.126 --> 00:27:00.576
connection.

00:27:01.536 --> 00:27:03.006
In that completion handler, we

00:27:03.006 --> 00:27:04.106
validate that the content is

00:27:04.106 --> 00:27:06.216
present, and if so, we let the

00:27:06.216 --> 00:27:07.386
rest of the application know

00:27:07.386 --> 00:27:08.836
that we're connected, and it

00:27:08.836 --> 00:27:09.776
should bring up the camera

00:27:09.776 --> 00:27:11.156
hardware and start generating

00:27:11.156 --> 00:27:11.476
frames.

00:27:12.076 --> 00:27:15.186
When those frames are generated,

00:27:15.616 --> 00:27:16.566
the rest of the application

00:27:16.566 --> 00:27:18.266
knows to call send on our

00:27:18.266 --> 00:27:22.986
UDPClient class and pass it an

00:27:23.246 --> 00:27:24.676
array of data objects

00:27:24.796 --> 00:27:26.056
representing the video frames

00:27:26.186 --> 00:27:28.906
that we're trying to send.

00:27:29.096 --> 00:27:30.006
Because we're going to be doing

00:27:30.006 --> 00:27:31.406
a lot of send operations in very

00:27:31.406 --> 00:27:32.876
quick succession, we're going to

00:27:32.876 --> 00:27:34.516
do them within a block that we

00:27:34.516 --> 00:27:37.436
passed in connection.batch.

00:27:37.646 --> 00:27:39.126
Within this block we're going to

00:27:39.126 --> 00:27:41.026
go through every frame in that

00:27:41.026 --> 00:27:43.206
array of data objects and pass

00:27:43.206 --> 00:27:45.226
each one to connection.send.

00:27:45.926 --> 00:27:47.826
Similarly to above, we use the

00:27:47.826 --> 00:27:48.976
completion handler to check for

00:27:48.976 --> 00:27:50.466
any errors that were encountered

00:27:50.466 --> 00:27:50.916
while sending.

00:27:52.056 --> 00:27:52.526
And that's it.

00:27:53.216 --> 00:27:54.546
We've got our UDPClient class,

00:27:54.826 --> 00:27:55.556
and we're ready to go.

00:27:55.556 --> 00:27:58.566
Let's look at the server.

00:27:59.896 --> 00:28:01.416
On the server side, we need a

00:28:01.416 --> 00:28:02.856
listener that can accept the

00:28:02.856 --> 00:28:03.766
incoming connections.

00:28:04.246 --> 00:28:05.236
We need to respond to that

00:28:05.236 --> 00:28:06.516
handshake that we just sent from

00:28:06.516 --> 00:28:08.066
the client, and we need to read

00:28:08.066 --> 00:28:09.456
data off the network so that we

00:28:09.456 --> 00:28:10.436
can push it up to the display.

00:28:11.496 --> 00:28:13.066
Starting with the listener, we

00:28:15.976 --> 00:28:17.836
simply create an NWListener

00:28:18.156 --> 00:28:19.126
using the default UDP

00:28:19.126 --> 00:28:19.686
parameters.

00:28:20.236 --> 00:28:22.656
If I wanted to, this is also my

00:28:22.656 --> 00:28:23.736
opportunity to use those

00:28:23.736 --> 00:28:25.236
parameters to tell the listener

00:28:25.236 --> 00:28:26.596
to listen on a specific local

00:28:26.596 --> 00:28:26.886
port.

00:28:27.376 --> 00:28:28.406
But since we're using a bonjour

00:28:28.406 --> 00:28:29.566
service, we don't need to do

00:28:29.566 --> 00:28:30.366
that.

00:28:33.316 --> 00:28:35.236
To set up that service, I'm

00:28:35.236 --> 00:28:36.166
going to set the service

00:28:36.166 --> 00:28:38.476
property on the listener to a

00:28:38.476 --> 00:28:39.516
service object of type

00:28:39.516 --> 00:28:40.426
camera.udp.

00:28:41.216 --> 00:28:42.286
Notice that I don't pass the

00:28:42.286 --> 00:28:43.826
name here because I want the

00:28:43.826 --> 00:28:45.396
system to provide the default

00:28:45.396 --> 00:28:46.236
device name for me.

00:28:47.766 --> 00:28:49.666
I also provide a block to the

00:28:49.666 --> 00:28:50.586
serviceRegistration

00:28:50.586 --> 00:28:52.806
UpdateHandler, which is going to

00:28:52.806 --> 00:28:54.466
be called anytime the set of

00:28:54.466 --> 00:28:55.786
endpoints advertised by the

00:28:55.786 --> 00:28:57.196
system changes.

00:28:57.966 --> 00:28:59.366
Here, I'm interested in the case

00:28:59.456 --> 00:29:01.206
where an endpoint is added, and

00:29:01.206 --> 00:29:03.476
if it's of service type, I tell

00:29:03.476 --> 00:29:05.006
the rest of the application the

00:29:05.006 --> 00:29:06.446
name that is being advertised,

00:29:06.586 --> 00:29:07.796
that default device name that I

00:29:07.796 --> 00:29:08.956
ask the system to provide so

00:29:08.956 --> 00:29:10.506
that I can display it in the UI

00:29:10.506 --> 00:29:11.586
and have my users type it in

00:29:11.586 --> 00:29:11.976
somewhere else.

00:29:20.046 --> 00:29:20.916
I'm going to set a new

00:29:20.916 --> 00:29:22.246
connection handler on the

00:29:22.246 --> 00:29:23.766
listener, which will be called

00:29:23.766 --> 00:29:25.046
every time the listener receives

00:29:25.046 --> 00:29:26.046
a new incoming connection.

00:29:26.116 --> 00:29:28.906
I could do some configuration on

00:29:28.906 --> 00:29:29.986
these connections, but the

00:29:29.986 --> 00:29:31.136
default settings are fine here,

00:29:31.356 --> 00:29:31.996
so I simply call

00:29:31.996 --> 00:29:34.536
connection.start and pass it to

00:29:36.176 --> 00:29:36.286
queue.

00:29:36.466 --> 00:29:38.216
Here, I notify the rest of the

00:29:38.216 --> 00:29:39.746
application that I've received

00:29:39.746 --> 00:29:41.076
an incoming connection, so it

00:29:41.076 --> 00:29:42.336
can start warming up the display

00:29:42.336 --> 00:29:43.766
pipeline and become ready to

00:29:43.766 --> 00:29:45.106
display the video frames.

00:29:46.336 --> 00:29:47.976
I'll also call receive on

00:29:47.976 --> 00:29:49.406
myself, which we'll implement in

00:29:49.406 --> 00:29:50.666
a minute, to start reading that

00:29:50.666 --> 00:29:52.016
data off of the network and

00:29:52.016 --> 00:29:52.966
shipping it up to the display

00:29:52.966 --> 00:29:53.326
pipeline.

00:29:53.326 --> 00:29:56.736
Just like with connections,

00:29:57.056 --> 00:30:01.756
listeners have state update

00:30:01.756 --> 00:30:03.086
handlers, which I'll use to

00:30:03.086 --> 00:30:04.556
check for the ready and the

00:30:04.556 --> 00:30:05.696
failed states.

00:30:07.236 --> 00:30:08.896
I need to not forget to start my

00:30:08.896 --> 00:30:10.856
listener, which I do by calling

00:30:10.856 --> 00:30:12.496
listener.start and passing it

00:30:12.496 --> 00:30:14.406
that queue we created up above.

00:30:15.436 --> 00:30:17.036
So I've got my listener ready, I

00:30:17.036 --> 00:30:18.506
just need to read data off the

00:30:18.506 --> 00:30:19.976
network and implement this

00:30:19.976 --> 00:30:20.636
receive function.

00:30:24.656 --> 00:30:26.156
Here, we start by calling

00:30:26.156 --> 00:30:28.036
connection.receive and passing

00:30:28.036 --> 00:30:28.976
it into completion handler.

00:30:29.646 --> 00:30:30.856
When data comes in off of that

00:30:30.856 --> 00:30:32.376
connection, we'll see if we're

00:30:32.376 --> 00:30:33.206
not yet connected.

00:30:33.966 --> 00:30:35.586
If we weren't connected, this is

00:30:35.586 --> 00:30:37.136
probably that handshake that the

00:30:37.136 --> 00:30:40.166
client is starting by sending.

00:30:40.306 --> 00:30:41.476
We'll simply turn right around

00:30:41.476 --> 00:30:42.716
and call connection.send,

00:30:43.246 --> 00:30:45.136
passing that same content back

00:30:45.396 --> 00:30:46.476
so it will be echoed over to the

00:30:46.476 --> 00:30:46.756
client.

00:30:47.656 --> 00:30:48.516
We then remember that we're

00:30:48.516 --> 00:30:50.516
connected, and on all subsequent

00:30:50.516 --> 00:30:52.776
received callbacks, we will

00:30:52.776 --> 00:30:53.916
simply tell the rest of the

00:30:53.916 --> 00:30:55.516
application that we received

00:30:55.836 --> 00:30:57.326
this frame, and it should send

00:30:57.326 --> 00:30:58.966
it up to the display pipeline so

00:30:58.966 --> 00:31:00.666
that we can see it on the

00:31:01.596 --> 00:31:01.756
screen.

00:31:01.926 --> 00:31:03.296
Finally, if there were no

00:31:03.296 --> 00:31:05.456
errors, we call receive again so

00:31:05.456 --> 00:31:06.496
that we receive subsequent

00:31:06.496 --> 00:31:08.026
frames and send them up to the

00:31:08.026 --> 00:31:09.826
display to book together a video

00:31:09.826 --> 00:31:11.156
from each of these individual

00:31:11.156 --> 00:31:11.526
images.

00:31:12.086 --> 00:31:13.876
So that's it.

00:31:13.966 --> 00:31:15.566
We've got our UDPClient, we've

00:31:15.566 --> 00:31:17.476
got our UDPServer, let's try it

00:31:17.476 --> 00:31:17.656
out.

00:31:20.226 --> 00:31:22.316
I'm going to run the client on

00:31:22.316 --> 00:31:24.046
my phone here, and I'm going to

00:31:24.046 --> 00:31:25.786
run the server on my Mac so we

00:31:25.786 --> 00:31:26.826
can see it on the big screen.

00:31:27.366 --> 00:31:29.626
Here, the server just came up,

00:31:30.386 --> 00:31:32.086
and we see that it's advertising

00:31:32.086 --> 00:31:34.026
as Demo Mac, which is where I

00:31:34.026 --> 00:31:36.166
told the rest of the system to

00:31:36.166 --> 00:31:37.136
just give me the name.

00:31:38.166 --> 00:31:39.206
That's on my phone.

00:31:39.206 --> 00:31:41.676
If I tap connect, all of a

00:31:41.676 --> 00:31:43.826
sudden, I can see video frames

00:31:44.276 --> 00:31:45.206
being streamed across the

00:31:45.206 --> 00:31:46.796
network over UDP Live.

00:31:48.516 --> 00:31:53.500
[ Applause ]

00:31:58.356 --> 00:32:00.276
So here we just saw how quickly

00:32:00.276 --> 00:32:01.386
I was able to bring up a

00:32:01.726 --> 00:32:03.806
UDPClient that could connect to

00:32:03.806 --> 00:32:06.616
a bonjour service, it can send a

00:32:06.616 --> 00:32:08.356
handshake, wait for that to be

00:32:08.356 --> 00:32:10.726
processed, take the video frames

00:32:10.726 --> 00:32:11.956
coming from the camera, and ship

00:32:11.956 --> 00:32:12.806
them across the network.

00:32:14.116 --> 00:32:16.716
The server side brought up a

00:32:16.716 --> 00:32:18.606
bonjour listener.

00:32:19.096 --> 00:32:20.866
It advertised a service, it

00:32:20.866 --> 00:32:22.196
received incoming connections,

00:32:22.436 --> 00:32:23.916
responded to the handshake, and

00:32:23.916 --> 00:32:25.516
sent them all to the display so

00:32:25.516 --> 00:32:26.106
that we could see them.

00:32:27.176 --> 00:32:28.426
And now to take you through

00:32:28.666 --> 00:32:29.846
optimizing that data transfer in

00:32:29.846 --> 00:32:30.896
a little more detail, I'd like

00:32:30.896 --> 00:32:32.126
to invite Tommy back up to the

00:32:32.126 --> 00:32:32.506
stage.

00:32:33.516 --> 00:32:38.416
[ Applause ]

00:32:38.916 --> 00:32:39.726
>> Thank you, Eric.

00:32:40.036 --> 00:32:42.116
It was a really cool demo.

00:32:42.116 --> 00:32:43.386
It's super easy to get this

00:32:43.386 --> 00:32:44.876
going, and so now we've covered

00:32:44.876 --> 00:32:46.406
the basics, and we know how to

00:32:46.736 --> 00:32:48.096
establish connections outbound,

00:32:48.096 --> 00:32:49.106
how to receive connections

00:32:49.106 --> 00:32:52.136
inbound, but the real key part

00:32:52.136 --> 00:32:53.556
of Network.framework that's

00:32:53.556 --> 00:32:54.526
going to be the killer feature

00:32:54.526 --> 00:32:56.346
here is the way that it can

00:32:56.346 --> 00:32:57.846
optimize your performance and

00:32:57.846 --> 00:32:58.926
that we can go beyond what

00:32:58.976 --> 00:33:00.126
sockets was able to do.

00:33:00.676 --> 00:33:03.096
And I want to start with the way

00:33:03.096 --> 00:33:04.886
that you in your application

00:33:05.126 --> 00:33:06.496
interact with your networking

00:33:06.496 --> 00:33:08.586
connections in the most basic

00:33:08.586 --> 00:33:10.846
way, which is just sending and

00:33:10.846 --> 00:33:11.506
receiving data.

00:33:12.786 --> 00:33:14.686
And these calls are very simple,

00:33:15.226 --> 00:33:17.146
but the nuances about how you

00:33:17.146 --> 00:33:18.956
handle sending and receiving and

00:33:18.956 --> 00:33:20.326
really make a huge difference

00:33:20.796 --> 00:33:22.076
for the responsiveness of your

00:33:22.076 --> 00:33:23.696
app and how much buffering there

00:33:23.696 --> 00:33:25.816
is going on on the device and

00:33:25.816 --> 00:33:26.266
the network.

00:33:26.886 --> 00:33:29.016
So the first example I want to

00:33:29.016 --> 00:33:30.516
walk through is when we're

00:33:30.516 --> 00:33:32.786
sending data, in the application

00:33:32.786 --> 00:33:34.236
very much like what Eric just

00:33:34.236 --> 00:33:35.616
showed you, something that's

00:33:35.616 --> 00:33:36.826
live streaming, something that

00:33:36.826 --> 00:33:38.586
is generating data on the fly.

00:33:39.166 --> 00:33:40.736
But in this case, let's talk

00:33:40.736 --> 00:33:42.476
about when we're sending it over

00:33:42.476 --> 00:33:44.776
a TCP stream, a TCP stream that

00:33:44.776 --> 00:33:46.676
can back up on the network, that

00:33:46.676 --> 00:33:47.926
has a certain window that it can

00:33:47.976 --> 00:33:48.336
send.

00:33:48.616 --> 00:33:50.486
So how do we handle this?

00:33:51.356 --> 00:33:53.716
So here's a function to send a

00:33:53.716 --> 00:33:54.446
single frame.

00:33:54.446 --> 00:33:56.136
This is some frame of data that

00:33:56.136 --> 00:33:57.796
your application has generated.

00:33:58.376 --> 00:34:00.656
And the way that you send it on

00:34:00.656 --> 00:34:01.706
the connection is you simply

00:34:01.706 --> 00:34:03.886
call connection.send and pass

00:34:04.196 --> 00:34:04.636
that data.

00:34:05.556 --> 00:34:06.956
Now if you're used to using

00:34:06.956 --> 00:34:09.496
sockets to send on your

00:34:09.496 --> 00:34:11.775
connections, you either are

00:34:11.775 --> 00:34:13.045
using a blocking socket, in

00:34:13.126 --> 00:34:15.676
which case if you have a hundred

00:34:15.676 --> 00:34:17.436
bytes of data to send, if

00:34:17.436 --> 00:34:18.446
there's not room in the send

00:34:18.446 --> 00:34:20.496
buffer, it'll actually block up

00:34:20.496 --> 00:34:22.226
your thread and wait for the

00:34:22.226 --> 00:34:24.815
network connection to drain out,

00:34:25.166 --> 00:34:27.126
or if you're using a nonblocking

00:34:27.126 --> 00:34:30.585
socket, that send may actually

00:34:30.585 --> 00:34:31.846
not send your complete data.

00:34:31.846 --> 00:34:33.196
It'll say, oh, I only sent 50

00:34:33.196 --> 00:34:33.696
bytes of it.

00:34:33.696 --> 00:34:34.696
Come back some other time to

00:34:34.696 --> 00:34:35.846
send the next 50 bytes.

00:34:36.536 --> 00:34:37.596
This requires you and your

00:34:37.596 --> 00:34:38.795
application to handle a lot of

00:34:38.795 --> 00:34:40.716
state about how much you have

00:34:40.716 --> 00:34:42.565
actually done of sending your

00:34:43.186 --> 00:34:43.315
data.

00:34:44.235 --> 00:34:45.466
So the great thing about a

00:34:45.466 --> 00:34:46.606
network connection is you can

00:34:46.606 --> 00:34:48.056
simply send all of your data at

00:34:48.106 --> 00:34:49.056
once, and you don't have to

00:34:49.056 --> 00:34:51.126
worry about this, and it doesn't

00:34:51.126 --> 00:34:51.826
block anything.

00:34:53.106 --> 00:34:54.286
But then, of course, you have to

00:34:54.286 --> 00:34:55.906
handle what happens if the

00:34:55.906 --> 00:34:57.226
connection is backing up,

00:34:57.226 --> 00:34:58.286
because we don't want to just

00:34:58.456 --> 00:35:00.746
send a ton of data unnecessarily

00:35:00.746 --> 00:35:02.456
into this connection if you want

00:35:02.456 --> 00:35:04.616
a really responsive, live stream

00:35:04.616 --> 00:35:04.966
of data.

00:35:06.226 --> 00:35:08.176
And the key here is that

00:35:08.176 --> 00:35:09.496
callback block that we give you.

00:35:10.336 --> 00:35:12.116
It's called contentProcessed.

00:35:12.766 --> 00:35:15.356
And we'll invoke it whenever the

00:35:15.356 --> 00:35:17.006
network stack consumes your

00:35:17.006 --> 00:35:17.246
data.

00:35:17.666 --> 00:35:18.816
So this doesn't mean that the

00:35:18.816 --> 00:35:20.046
data has necessarily been sent

00:35:20.046 --> 00:35:21.306
out or acknowledged by the other

00:35:21.306 --> 00:35:21.676
side.

00:35:22.146 --> 00:35:23.996
It's exactly equivalent to the

00:35:23.996 --> 00:35:25.696
time in which a blocking socket

00:35:25.696 --> 00:35:27.506
call would return to you, or

00:35:27.536 --> 00:35:29.256
when the nonblocking socket call

00:35:29.256 --> 00:35:30.806
was able to consume all of the

00:35:30.806 --> 00:35:31.656
bytes that you sent.

00:35:32.246 --> 00:35:34.716
And in this completion handler,

00:35:35.176 --> 00:35:36.076
there are two things you can

00:35:36.076 --> 00:35:36.496
check for.

00:35:37.566 --> 00:35:39.126
First, you can check for an

00:35:39.126 --> 00:35:39.396
error.

00:35:39.996 --> 00:35:41.176
If there is an error, that means

00:35:41.176 --> 00:35:42.176
something went wrong while we

00:35:42.176 --> 00:35:43.136
were trying to send your data,

00:35:43.676 --> 00:35:45.536
generally it indicates a overall

00:35:45.536 --> 00:35:46.316
connection failure.

00:35:47.806 --> 00:35:49.746
Then, if there wasn't and error,

00:35:49.986 --> 00:35:52.056
this is the perfect opportunity

00:35:52.236 --> 00:35:53.896
to go and see if there's more

00:35:53.896 --> 00:35:55.606
data from your application to

00:35:55.606 --> 00:35:56.016
generate.

00:35:56.016 --> 00:35:58.026
So if you're generating live

00:35:58.026 --> 00:36:00.426
data frames, go and fetch

00:36:00.426 --> 00:36:01.336
another frame from the video

00:36:01.336 --> 00:36:02.546
stream, because now is the time

00:36:02.546 --> 00:36:03.646
when you can actually enqueue

00:36:03.646 --> 00:36:04.616
the next packets.

00:36:05.046 --> 00:36:06.976
This allows you to pace all of

00:36:06.976 --> 00:36:07.596
your data out.

00:36:08.706 --> 00:36:10.116
And so as you see here, we

00:36:10.116 --> 00:36:12.586
essentially form a loop of using

00:36:12.586 --> 00:36:13.966
this asynchronous send callback

00:36:14.366 --> 00:36:17.006
to continue to drain data out of

00:36:17.006 --> 00:36:18.526
our connection and handle it

00:36:18.676 --> 00:36:19.656
really elegantly.

00:36:22.256 --> 00:36:23.816
The other thing I want to point

00:36:23.816 --> 00:36:25.816
out about sending is the trick

00:36:25.816 --> 00:36:27.156
that Eric showed earlier that's

00:36:27.216 --> 00:36:29.406
great for UDP applications that

00:36:29.406 --> 00:36:31.396
are sending multiple datagrams

00:36:31.726 --> 00:36:32.546
all at one time.

00:36:33.626 --> 00:36:35.116
So if you have a whole bunch of

00:36:35.116 --> 00:36:36.396
little tiny pieces of data that

00:36:36.396 --> 00:36:37.566
you need to send out or

00:36:37.566 --> 00:36:39.036
essentially individual packets,

00:36:40.206 --> 00:36:41.596
you can use something that we've

00:36:41.596 --> 00:36:43.276
added called connection.batch.

00:36:43.636 --> 00:36:46.046
So a UDP socket previously could

00:36:46.046 --> 00:36:47.916
only send one packet at a time,

00:36:48.606 --> 00:36:49.626
and this could be very

00:36:49.626 --> 00:36:51.006
inefficient because if I have to

00:36:51.006 --> 00:36:52.906
send a hundred UDP packets,

00:36:53.196 --> 00:36:54.506
these are each a different

00:36:54.506 --> 00:36:56.196
system call, a different copy,

00:36:56.196 --> 00:36:57.446
and a context switch down into

00:36:57.446 --> 00:36:57.886
the kernel.

00:36:59.226 --> 00:37:01.206
But if you call batch within

00:37:01.206 --> 00:37:03.706
that block, you can call send or

00:37:03.706 --> 00:37:05.016
actually receive as many times

00:37:05.016 --> 00:37:06.586
as you want, and the connection

00:37:06.586 --> 00:37:08.406
will hold off processing any of

00:37:08.406 --> 00:37:10.936
the data until you finish the

00:37:10.936 --> 00:37:12.756
batch block and will try to send

00:37:12.756 --> 00:37:14.656
all of those datagrams all as

00:37:14.806 --> 00:37:16.876
one single batch down into the

00:37:16.876 --> 00:37:19.026
system, ideally have just one

00:37:19.026 --> 00:37:20.926
context switch down into the

00:37:20.956 --> 00:37:22.026
kernel, and send out the

00:37:22.026 --> 00:37:22.666
interface.

00:37:23.126 --> 00:37:24.856
This allows you to be very, very

00:37:24.856 --> 00:37:25.286
efficient.

00:37:25.766 --> 00:37:28.196
So that's sending.

00:37:28.846 --> 00:37:31.286
Receiving, like sending, is

00:37:31.346 --> 00:37:32.586
asynchronous, and the

00:37:32.586 --> 00:37:34.466
asynchronous nature gives you

00:37:34.596 --> 00:37:35.606
the back pressure that allows

00:37:35.606 --> 00:37:37.106
you to pace your app.

00:37:38.276 --> 00:37:40.416
So in this case, I have a

00:37:40.416 --> 00:37:43.116
TCP-based protocol, and it's

00:37:43.116 --> 00:37:44.686
very common for apps when

00:37:44.686 --> 00:37:46.386
they're reading to essentially

00:37:46.386 --> 00:37:48.216
want to be reading some type of

00:37:48.216 --> 00:37:49.066
record format.

00:37:49.666 --> 00:37:52.286
Let's say that your protocol has

00:37:52.286 --> 00:37:55.186
a header of 10 bytes that tells

00:37:55.186 --> 00:37:56.316
you some information about what

00:37:56.316 --> 00:37:57.606
you're about to receive, maybe

00:37:57.606 --> 00:37:58.726
the length of the body that

00:37:58.726 --> 00:37:59.406
you're about to receive.

00:38:00.576 --> 00:38:01.486
And so you want to read that

00:38:01.486 --> 00:38:03.036
header first and then read the

00:38:03.036 --> 00:38:04.646
rest of your content, and maybe

00:38:04.646 --> 00:38:05.686
your content's quite long.

00:38:05.686 --> 00:38:07.506
It's a couple megabytes let's

00:38:07.506 --> 00:38:07.726
say.

00:38:09.066 --> 00:38:10.536
Traditionally with a socket, you

00:38:10.536 --> 00:38:11.886
may try to read 10 bytes.

00:38:12.706 --> 00:38:13.776
You may get 10 bytes, you may

00:38:13.776 --> 00:38:14.336
get less.

00:38:14.476 --> 00:38:15.426
You have to keep reading until

00:38:15.426 --> 00:38:16.836
you get exactly 10 bytes to read

00:38:16.836 --> 00:38:17.206
your header.

00:38:18.096 --> 00:38:19.046
And then you have to read a

00:38:19.206 --> 00:38:21.016
couple megabytes, and you'll

00:38:21.016 --> 00:38:21.976
read some, and you'll get a

00:38:21.976 --> 00:38:22.836
whole bunch of different read

00:38:22.836 --> 00:38:24.076
calls and essentially go back

00:38:24.076 --> 00:38:25.836
and forth between your app and

00:38:25.836 --> 00:38:26.736
the stack.

00:38:28.696 --> 00:38:30.686
With an NWConnection, when you

00:38:30.686 --> 00:38:33.686
call receive, you provide the

00:38:34.166 --> 00:38:35.316
minimum data that you want to

00:38:35.316 --> 00:38:36.806
receive and the maximum data.

00:38:37.676 --> 00:38:38.996
So you could actually specify if

00:38:38.996 --> 00:38:40.426
you want to receive exactly 10

00:38:40.426 --> 00:38:41.326
bytes because that's your

00:38:41.326 --> 00:38:43.256
protocol, you can just say, I

00:38:43.256 --> 00:38:44.646
want a minimum of 10 and a

00:38:44.646 --> 00:38:45.406
maximum of 10.

00:38:45.506 --> 00:38:46.736
Give me exactly 10 bytes.

00:38:47.236 --> 00:38:48.646
And we will only call you back

00:38:49.246 --> 00:38:50.686
when either there was an error

00:38:50.946 --> 00:38:51.856
in reading on the connection

00:38:51.856 --> 00:38:54.276
overall or we read exactly those

00:38:54.276 --> 00:38:54.946
10 bytes.

00:38:55.566 --> 00:38:57.806
Then you can easily just read

00:38:57.806 --> 00:38:59.126
out whatever content you need

00:38:59.126 --> 00:39:00.156
for your header, read out the

00:39:00.156 --> 00:39:02.126
length, and then let's say you

00:39:02.126 --> 00:39:04.526
want to read a couple megabytes,

00:39:04.646 --> 00:39:05.906
and you essentially do the same

00:39:05.906 --> 00:39:08.186
thing to read your body, and you

00:39:08.186 --> 00:39:09.546
just pass, well I want to read

00:39:09.546 --> 00:39:11.326
exactly this amount for my

00:39:11.326 --> 00:39:12.486
connection, and this allows you

00:39:12.486 --> 00:39:13.926
to not go back and forth between

00:39:13.926 --> 00:39:15.576
the stack and your app but just

00:39:15.576 --> 00:39:16.976
have a single callback of when

00:39:17.056 --> 00:39:18.516
all of your data is ready to go.

00:39:19.616 --> 00:39:21.216
So it's a really great way to

00:39:21.256 --> 00:39:22.686
optimize the interactions.

00:39:23.366 --> 00:39:25.856
Beyond sending and receiving,

00:39:26.366 --> 00:39:27.776
there are a couple of advanced

00:39:27.776 --> 00:39:28.696
options that I'd like to

00:39:28.696 --> 00:39:30.916
highlight in your network

00:39:30.916 --> 00:39:32.316
parameters that allow you to

00:39:32.346 --> 00:39:34.216
configure your connection to get

00:39:34.616 --> 00:39:37.056
very good startup time as well

00:39:37.056 --> 00:39:38.876
as behavior on the network when

00:39:38.876 --> 00:39:39.656
you're actually sending and

00:39:39.656 --> 00:39:40.046
receiving.

00:39:41.226 --> 00:39:42.746
So the first one is one that

00:39:42.746 --> 00:39:43.986
we've talked about many times

00:39:43.986 --> 00:39:46.236
here at WWDC, which is ECN.

00:39:46.306 --> 00:39:48.136
This is explicit congestion

00:39:48.136 --> 00:39:48.836
notification.

00:39:50.086 --> 00:39:52.966
It gives you a way to smooth out

00:39:52.966 --> 00:39:54.986
your connection by having the

00:39:54.986 --> 00:39:57.856
network let the end host know

00:39:58.176 --> 00:39:59.226
when there's congestion on the

00:39:59.226 --> 00:40:00.796
network so we can pace things

00:40:00.796 --> 00:40:01.406
out very well.

00:40:02.676 --> 00:40:04.536
The great thing is that ECN is

00:40:04.536 --> 00:40:06.076
enabled by default on all of

00:40:06.076 --> 00:40:07.106
your TCP connections.

00:40:07.516 --> 00:40:08.396
You don't have to do anything.

00:40:09.446 --> 00:40:10.976
But it's been very difficult in

00:40:10.976 --> 00:40:13.706
the past to use ECN with

00:40:13.706 --> 00:40:14.946
UDP-based protocols.

00:40:15.956 --> 00:40:16.946
And so I'd like to show you how

00:40:16.946 --> 00:40:19.586
you can do that here.

00:40:19.796 --> 00:40:20.816
The first thing you do is that

00:40:20.816 --> 00:40:23.466
you create an ipMetadata object.

00:40:23.746 --> 00:40:26.196
ECN is controlled by flags that

00:40:26.196 --> 00:40:28.426
go in an IP packet, and so you

00:40:28.426 --> 00:40:29.906
have this ipMmetadata object

00:40:29.906 --> 00:40:31.396
that allows you to set various

00:40:31.396 --> 00:40:34.456
flags on a per-packet basis, and

00:40:34.456 --> 00:40:35.856
you can wrap this up into a

00:40:35.856 --> 00:40:38.116
context object, which describes

00:40:38.116 --> 00:40:39.236
all of the options for the

00:40:39.236 --> 00:40:40.976
various protocols that you want

00:40:40.976 --> 00:40:42.396
to associate with a single send

00:40:43.066 --> 00:40:44.996
as well as the relative priority

00:40:45.406 --> 00:40:46.856
of that particular message.

00:40:48.196 --> 00:40:50.236
And then you use this context as

00:40:50.236 --> 00:40:52.266
an extra parameter into the send

00:40:52.266 --> 00:40:55.146
call besides just your content.

00:40:55.996 --> 00:40:57.806
So now when you send this, any

00:40:57.806 --> 00:40:58.636
packet that's going to be

00:40:58.636 --> 00:41:00.656
generated by this content will

00:41:00.656 --> 00:41:02.026
have all the flags that you

00:41:02.026 --> 00:41:02.746
wanted marked.

00:41:03.306 --> 00:41:04.126
So it's really easy.

00:41:05.256 --> 00:41:07.146
And you can also get these same

00:41:07.146 --> 00:41:08.526
flags whenever you're receiving

00:41:08.956 --> 00:41:09.586
on a connection.

00:41:09.586 --> 00:41:10.716
You'll have the same context

00:41:10.716 --> 00:41:11.836
object associated with your

00:41:11.836 --> 00:41:13.546
receives, and you'll be able to

00:41:13.546 --> 00:41:15.426
read out the specific low-level

00:41:15.496 --> 00:41:19.066
flags that you want to get out.

00:41:19.346 --> 00:41:21.576
Similar, we have service class.

00:41:22.426 --> 00:41:24.906
This is a property that is

00:41:24.906 --> 00:41:26.956
available also in URLSession

00:41:27.286 --> 00:41:28.476
that defines the relative

00:41:28.526 --> 00:41:31.676
priority of your traffic, and

00:41:31.676 --> 00:41:33.646
this affects the way that

00:41:33.646 --> 00:41:34.956
traffic is queued on the local

00:41:34.956 --> 00:41:36.886
interfaces when we're sending as

00:41:36.886 --> 00:41:38.416
well as how the traffic works on

00:41:38.416 --> 00:41:39.776
Cisco Fastlane networks.

00:41:39.776 --> 00:41:43.216
So you can mark your service

00:41:43.216 --> 00:41:44.916
class as a property on your

00:41:44.916 --> 00:41:47.166
entire connection by using the

00:41:47.166 --> 00:41:49.466
service class parameter in your

00:41:49.466 --> 00:41:50.526
parameter's object.

00:41:51.206 --> 00:41:53.516
In this case, we show how to use

00:41:53.916 --> 00:41:55.256
the background service class,

00:41:55.606 --> 00:41:57.196
and this is a great way to mark

00:41:57.246 --> 00:41:58.936
that your connection is

00:41:58.936 --> 00:41:59.976
relatively low priority.

00:42:00.066 --> 00:42:01.336
We don't want it to get in the

00:42:01.336 --> 00:42:03.456
way of user interactive data.

00:42:04.066 --> 00:42:05.126
So we really encourage you if

00:42:05.126 --> 00:42:06.506
you have background transfers,

00:42:06.866 --> 00:42:08.256
mark them as a background

00:42:08.256 --> 00:42:09.666
service class.

00:42:10.476 --> 00:42:12.646
But you can also mark service

00:42:12.646 --> 00:42:14.806
class on a per packet basis for

00:42:14.806 --> 00:42:16.026
those UDP connections.

00:42:16.996 --> 00:42:17.786
Let's say that you have a

00:42:17.786 --> 00:42:19.886
connection in which you have

00:42:20.006 --> 00:42:22.476
both voice and signaling data on

00:42:22.476 --> 00:42:23.886
the same UDP flow.

00:42:24.996 --> 00:42:26.526
In this case, you can create

00:42:26.826 --> 00:42:28.666
that same IP metadata object

00:42:28.666 --> 00:42:30.836
that we introduced before, mark

00:42:30.836 --> 00:42:32.266
your service class now instead

00:42:32.266 --> 00:42:34.846
of the ECN flags, attach it to a

00:42:34.846 --> 00:42:36.206
context, and send it out.

00:42:36.296 --> 00:42:37.476
And now you're marking the

00:42:37.476 --> 00:42:39.526
priority on a per-packet basis.

00:42:40.036 --> 00:42:43.866
The other way that you can

00:42:43.866 --> 00:42:46.306
optimize your connections is to

00:42:46.306 --> 00:42:47.746
reduce the number of round trips

00:42:47.746 --> 00:42:49.226
that it takes to establish them.

00:42:50.216 --> 00:42:51.396
So here I want to highlight two

00:42:51.396 --> 00:42:52.316
approaches to do this.

00:42:53.196 --> 00:42:55.376
One is enabling fast open on

00:42:55.376 --> 00:42:56.046
your connections.

00:42:56.756 --> 00:42:59.046
So TCP fast open allows you to

00:42:59.166 --> 00:43:02.056
send initial data in the first

00:43:02.196 --> 00:43:03.856
packet that TCP sends out, in

00:43:03.856 --> 00:43:05.386
the SYN, so that you don't have

00:43:05.386 --> 00:43:07.046
to wait for a whole handshake to

00:43:07.046 --> 00:43:08.766
start sending your application

00:43:09.406 --> 00:43:09.536
data.

00:43:10.156 --> 00:43:11.976
Now in order to do this, you

00:43:11.976 --> 00:43:13.546
need to enter into a contract

00:43:13.546 --> 00:43:15.156
from your application with the

00:43:15.156 --> 00:43:17.526
connection saying that you will

00:43:17.526 --> 00:43:19.016
be providing this initial data

00:43:19.016 --> 00:43:19.676
to send out.

00:43:20.716 --> 00:43:22.076
So to enable this, you mark

00:43:22.236 --> 00:43:23.576
allow fast open on your

00:43:23.576 --> 00:43:24.286
parameters.

00:43:24.996 --> 00:43:26.426
You then create your connection,

00:43:27.436 --> 00:43:28.806
and then before you can call

00:43:28.806 --> 00:43:30.796
start, you can actually call

00:43:30.856 --> 00:43:32.806
send and get your initial data

00:43:33.056 --> 00:43:33.676
sent out.

00:43:33.856 --> 00:43:36.536
Now I want to point out here

00:43:36.536 --> 00:43:38.116
that the completion handler here

00:43:38.226 --> 00:43:39.816
is replaced by a marker that

00:43:39.816 --> 00:43:41.886
this data is item potent, and

00:43:41.886 --> 00:43:43.226
item potent means that the data

00:43:43.226 --> 00:43:44.896
is safe to be replayed because

00:43:44.896 --> 00:43:46.966
initial data may get resent over

00:43:46.966 --> 00:43:48.256
the network, and so you don't

00:43:48.256 --> 00:43:49.756
want it to have side effects if

00:43:49.756 --> 00:43:51.086
it gets resent.

00:43:52.776 --> 00:43:55.266
Then, you simply call start, and

00:43:55.266 --> 00:43:56.656
as we're doing the connection

00:43:56.656 --> 00:43:58.106
bring up, all the attempts that

00:43:58.106 --> 00:43:59.916
we mentioned before, we will use

00:43:59.916 --> 00:44:01.826
that initial data if we can to

00:44:01.826 --> 00:44:04.226
send in TCP Fast Open.

00:44:04.936 --> 00:44:06.696
There is one other way I want to

00:44:06.696 --> 00:44:08.816
point out to use TCP Fast Open

00:44:09.166 --> 00:44:10.636
that doesn't require your

00:44:10.636 --> 00:44:12.146
application to send it's own

00:44:12.926 --> 00:44:13.056
data.

00:44:14.416 --> 00:44:16.666
If you're using TLS on top of

00:44:16.696 --> 00:44:19.926
TCP, the first message from TLS,

00:44:20.096 --> 00:44:21.716
the client hello, can actually

00:44:21.716 --> 00:44:24.216
be used as the TCP Fast Open

00:44:24.286 --> 00:44:24.926
initial data.

00:44:25.946 --> 00:44:27.376
If you want to just enable this

00:44:27.376 --> 00:44:29.316
and not provide your own Fast

00:44:29.316 --> 00:44:32.226
Open data, simply go into the

00:44:32.226 --> 00:44:34.846
TCP-specific options and mark

00:44:34.846 --> 00:44:35.896
that you want to enable Fast

00:44:35.896 --> 00:44:37.766
Open there, and it will

00:44:37.866 --> 00:44:39.886
automatically grab the first

00:44:39.886 --> 00:44:41.706
message from TLS to send out

00:44:41.866 --> 00:44:43.086
during connection establishment.

00:44:46.816 --> 00:44:47.896
There's another thing that you

00:44:47.896 --> 00:44:49.456
can do to optimize your

00:44:49.456 --> 00:44:50.586
connection establishment and

00:44:50.586 --> 00:44:52.356
save a roundtrip, and this is

00:44:52.356 --> 00:44:53.816
something that Stuart mentioned

00:44:53.916 --> 00:44:55.876
in the previous session, which

00:44:55.876 --> 00:44:57.626
we're calling Optimistic DNS.

00:44:58.736 --> 00:45:00.256
This allows you to use

00:45:00.626 --> 00:45:02.766
previously expired DNS answers

00:45:02.996 --> 00:45:04.136
that may have had a very short

00:45:04.136 --> 00:45:07.616
time to live, and try connecting

00:45:07.616 --> 00:45:10.296
to them while we do a new DNS

00:45:10.936 --> 00:45:12.506
query in parallel.

00:45:13.716 --> 00:45:16.236
So if the addresses that you had

00:45:16.236 --> 00:45:18.876
previously received that did

00:45:18.876 --> 00:45:21.346
expire are still valid, and you

00:45:21.346 --> 00:45:23.486
mark the expired DNS behavior to

00:45:23.486 --> 00:45:24.196
be allow.

00:45:24.696 --> 00:45:26.506
When you call start, we'll try

00:45:26.506 --> 00:45:27.646
connecting to those addresses

00:45:27.646 --> 00:45:29.626
first and not have to wait for

00:45:29.626 --> 00:45:31.116
the new DNS query to finish.

00:45:31.506 --> 00:45:33.006
This can shave off a lot of

00:45:33.006 --> 00:45:34.456
set-up time from your

00:45:34.456 --> 00:45:37.226
connection, but if your server

00:45:37.226 --> 00:45:39.176
has indeed moved addresses,

00:45:39.636 --> 00:45:40.896
because we're trying multiple

00:45:40.896 --> 00:45:43.156
different connection options, if

00:45:43.156 --> 00:45:44.736
that first one doesn't work, we

00:45:44.736 --> 00:45:47.006
will gracefully wait for the new

00:45:47.006 --> 00:45:48.986
DNS query to come back and try

00:45:48.986 --> 00:45:50.456
those addresses as well.

00:45:51.396 --> 00:45:52.746
So this is a very simple way

00:45:53.006 --> 00:45:54.266
that if it's appropriate for

00:45:54.266 --> 00:45:56.266
your server configuration, you

00:45:56.266 --> 00:45:57.986
can get a much faster connection

00:45:57.986 --> 00:45:58.556
establishment.

00:46:01.756 --> 00:46:03.376
The next area I want to talk

00:46:03.376 --> 00:46:04.516
about for performance is

00:46:04.516 --> 00:46:05.486
something that you don't

00:46:05.536 --> 00:46:06.896
actually need to do anything in

00:46:06.896 --> 00:46:07.676
your app to get.

00:46:08.206 --> 00:46:09.266
This is something that you get

00:46:09.266 --> 00:46:11.176
totally for free whenever you

00:46:11.656 --> 00:46:13.226
use URLSession or

00:46:13.226 --> 00:46:14.486
Network.framework connections,

00:46:14.846 --> 00:46:16.446
and this is user-space

00:46:16.506 --> 00:46:17.006
networking.

00:46:17.726 --> 00:46:18.626
So this is something that we

00:46:18.626 --> 00:46:20.456
introduced last year here at

00:46:20.456 --> 00:46:23.986
WWDC, and it's enabled on iOS

00:46:23.986 --> 00:46:24.646
and tvOS.

00:46:24.886 --> 00:46:27.446
This is where we're avoiding the

00:46:27.446 --> 00:46:28.966
socket layer entirely, and we've

00:46:28.966 --> 00:46:31.196
moved the transport stack into

00:46:31.196 --> 00:46:32.396
your app.

00:46:32.546 --> 00:46:33.656
So to give you an idea of what

00:46:33.656 --> 00:46:35.646
this is doing, I want to start

00:46:35.646 --> 00:46:37.136
with what the legacy model of

00:46:37.136 --> 00:46:39.166
the stack generally is.

00:46:39.876 --> 00:46:40.836
So let's say that you're

00:46:40.836 --> 00:46:42.226
receiving a packet off the

00:46:42.226 --> 00:46:42.546
network.

00:46:42.896 --> 00:46:44.226
It's the WiFi interface.

00:46:44.906 --> 00:46:45.896
That packet will come into the

00:46:45.896 --> 00:46:48.806
driver, will be sent into the

00:46:48.806 --> 00:46:50.926
TCP receive buffer within the

00:46:50.926 --> 00:46:53.546
kernel, and then when your

00:46:53.546 --> 00:46:55.476
application reads on a socket,

00:46:56.206 --> 00:46:57.196
that's going to do a context

00:46:57.196 --> 00:46:59.106
switch and copy the data up from

00:46:59.106 --> 00:47:01.636
the kernel into your app, and

00:47:01.636 --> 00:47:02.786
then generally if you're doing

00:47:02.786 --> 00:47:04.476
TLS, it will have to get another

00:47:04.476 --> 00:47:05.876
transformation to decrypt that

00:47:05.906 --> 00:47:07.376
data before you can actually

00:47:07.376 --> 00:47:08.776
send it up to the application.

00:47:09.366 --> 00:47:12.286
So how does this look when we do

00:47:12.376 --> 00:47:13.306
user space networking?

00:47:13.926 --> 00:47:17.646
So as you can see, the main

00:47:17.646 --> 00:47:19.186
change is that we've moved the

00:47:19.186 --> 00:47:21.836
transport stack, TCP and UDP, up

00:47:21.836 --> 00:47:22.466
into your app.

00:47:23.026 --> 00:47:24.146
So what does this give us?

00:47:25.056 --> 00:47:26.626
Now, when a packet comes in off

00:47:26.626 --> 00:47:27.956
the network, comes into the

00:47:27.956 --> 00:47:29.846
driver like before, but we move

00:47:29.846 --> 00:47:31.736
it into a memory mapped region

00:47:32.236 --> 00:47:33.726
that your application

00:47:34.436 --> 00:47:36.196
automatically can scoop packets

00:47:36.196 --> 00:47:38.096
out of without doing a copy,

00:47:38.176 --> 00:47:39.416
without doing extra contexts

00:47:39.416 --> 00:47:41.206
switch, and start processing the

00:47:41.206 --> 00:47:42.296
packets automatically.

00:47:42.816 --> 00:47:44.146
This way the only transformation

00:47:44.146 --> 00:47:45.846
we're doing is the decryption

00:47:45.846 --> 00:47:47.606
that we have to do anyway for

00:47:48.346 --> 00:47:48.466
TLS.

00:47:49.176 --> 00:47:50.886
This really can reduce the

00:47:50.886 --> 00:47:53.046
amount of CPU time that it takes

00:47:53.116 --> 00:47:54.506
to send and receive packets,

00:47:55.096 --> 00:47:56.636
especially for protocols like

00:47:56.636 --> 00:47:58.296
UDP in which you're going to be

00:47:58.296 --> 00:47:59.586
sending a lot of packets back

00:47:59.586 --> 00:48:01.046
and forth directly from your

00:48:01.046 --> 00:48:01.666
application.

00:48:02.286 --> 00:48:04.456
So to show how this works and

00:48:04.456 --> 00:48:05.996
the effect it can have, I want

00:48:05.996 --> 00:48:08.906
to show you a video that was

00:48:08.906 --> 00:48:11.166
taken using the same app that

00:48:11.166 --> 00:48:12.966
Eric showed you earlier to

00:48:12.966 --> 00:48:14.816
demonstrate UDP performance with

00:48:14.816 --> 00:48:15.816
user space networking.

00:48:16.076 --> 00:48:18.876
So in this example, we're going

00:48:18.876 --> 00:48:20.206
to have two videos running

00:48:20.206 --> 00:48:21.126
simultaneously.

00:48:21.676 --> 00:48:25.386
The device on the left is

00:48:25.386 --> 00:48:28.866
receiving a video stream from an

00:48:28.866 --> 00:48:30.066
application that was written

00:48:30.066 --> 00:48:30.976
using sockets.

00:48:32.186 --> 00:48:33.656
And the device on the right is

00:48:33.656 --> 00:48:35.006
going to be receiving exactly

00:48:35.006 --> 00:48:37.696
the same video stream from a

00:48:37.696 --> 00:48:40.576
device that has an app written

00:48:40.576 --> 00:48:42.176
using Network.framework so it

00:48:42.176 --> 00:48:43.626
can take advantage of the user

00:48:43.626 --> 00:48:44.906
space networking stack.

00:48:45.456 --> 00:48:47.716
And in this case, we're

00:48:47.716 --> 00:48:48.596
streaming the video.

00:48:49.026 --> 00:48:50.756
It's just raw frames.

00:48:50.756 --> 00:48:51.436
It's not compressed.

00:48:51.496 --> 00:48:52.526
It's not great quality or

00:48:52.526 --> 00:48:53.606
anything, but there's a lot of

00:48:53.606 --> 00:48:54.536
packets going back and forth.

00:48:55.746 --> 00:48:57.126
And we chose specifically for

00:48:57.126 --> 00:49:00.596
this demonstration to not lower

00:49:00.596 --> 00:49:01.546
the quality when we hit

00:49:01.576 --> 00:49:03.106
contention or when we couldn't

00:49:03.146 --> 00:49:04.786
send packets fast enough or to

00:49:04.786 --> 00:49:06.526
not drop anything but just to

00:49:06.526 --> 00:49:07.676
slow down if we had to.

00:49:08.236 --> 00:49:09.116
Now this is probably not what

00:49:09.116 --> 00:49:10.226
your app would do in real life,

00:49:10.226 --> 00:49:11.906
but it highlights exactly the

00:49:11.906 --> 00:49:13.916
difference in the performance

00:49:13.916 --> 00:49:15.536
between these two stacks.

00:49:16.156 --> 00:49:16.936
So let's see it right now.

00:49:22.046 --> 00:49:23.176
So there's exactly the same

00:49:23.176 --> 00:49:25.466
data, exactly the same frames

00:49:25.466 --> 00:49:26.666
being sent over as fast as they

00:49:26.666 --> 00:49:28.656
possibly can, across this

00:49:28.656 --> 00:49:32.446
network, and we see the one on

00:49:32.446 --> 00:49:33.836
the right is pretty easily

00:49:33.836 --> 00:49:35.176
outstripping the one on the

00:49:35.516 --> 00:49:35.646
left.

00:49:36.766 --> 00:49:38.436
And in fact, if you look at the

00:49:38.436 --> 00:49:40.306
difference, it's 30 percent less

00:49:40.306 --> 00:49:41.776
overhead that we're viewing on

00:49:41.776 --> 00:49:43.066
the receiver side only.

00:49:44.236 --> 00:49:45.616
And this is due to the huge

00:49:45.616 --> 00:49:47.806
difference that we see in the

00:49:47.806 --> 00:49:50.016
CPU percentage that it takes to

00:49:50.016 --> 00:49:51.746
send and receive UDP packets

00:49:52.336 --> 00:49:53.536
when you compare sockets and

00:49:53.536 --> 00:49:54.496
user space networking.

00:49:55.186 --> 00:49:56.306
Now, of course this is just one

00:49:56.306 --> 00:49:56.746
example.

00:49:56.836 --> 00:49:58.396
This is not going to be what

00:49:58.586 --> 00:49:59.666
every app is going to be like,

00:49:59.666 --> 00:50:00.276
because you're going to be

00:50:00.276 --> 00:50:01.606
compressing differently.

00:50:01.606 --> 00:50:02.566
You're going to be already

00:50:02.566 --> 00:50:03.576
trying to make your connections

00:50:03.576 --> 00:50:04.236
more efficient.

00:50:05.196 --> 00:50:06.966
But if you have an app that's

00:50:06.966 --> 00:50:08.426
generating live data, especially

00:50:08.426 --> 00:50:10.336
if you're using UDP to send and

00:50:10.336 --> 00:50:11.896
receive a lot of packets, I

00:50:11.956 --> 00:50:13.706
invite you to try using

00:50:13.706 --> 00:50:15.026
Network.framework within your

00:50:15.026 --> 00:50:16.466
app and run it through

00:50:16.466 --> 00:50:17.086
instruments.

00:50:17.636 --> 00:50:19.096
Measure the difference in CPU

00:50:19.096 --> 00:50:21.026
usage that you have when you're

00:50:21.026 --> 00:50:22.256
using Network.framework versus

00:50:22.256 --> 00:50:23.746
sockets, and I think you'll be

00:50:23.746 --> 00:50:24.796
really happy with what you see.

00:50:30.336 --> 00:50:31.986
So the last topic we want to

00:50:31.986 --> 00:50:34.156
talk about today is how we can

00:50:34.226 --> 00:50:35.416
solve the problems around

00:50:35.416 --> 00:50:37.256
network mobility, and this is a

00:50:37.256 --> 00:50:38.606
key area that we're trying to

00:50:38.606 --> 00:50:41.416
solve with Network.framework.

00:50:42.166 --> 00:50:45.566
And the first step of this is

00:50:45.566 --> 00:50:46.816
just making sure that we start

00:50:46.816 --> 00:50:47.786
connections gracefully.

00:50:48.816 --> 00:50:49.746
So we already mentioned this,

00:50:49.746 --> 00:50:50.686
but I want to recap a little

00:50:50.686 --> 00:50:50.906
bit.

00:50:51.836 --> 00:50:54.146
The waiting state is the key

00:50:54.206 --> 00:50:55.776
thing to handle network

00:50:55.776 --> 00:50:58.326
transitions when your connection

00:50:58.326 --> 00:50:59.126
is first coming up.

00:50:59.726 --> 00:51:00.836
It will indicate that there's a

00:51:00.836 --> 00:51:02.436
lack of connectivity or the

00:51:02.476 --> 00:51:04.166
connectivity changed while you

00:51:04.166 --> 00:51:05.486
were in the middle of doing DNS

00:51:05.636 --> 00:51:06.096
or TCP.

00:51:06.096 --> 00:51:08.996
We really encourage you please

00:51:08.996 --> 00:51:11.106
avoid using APIs like

00:51:11.206 --> 00:51:13.426
reachability to check the

00:51:13.426 --> 00:51:14.496
network state before you

00:51:14.496 --> 00:51:15.466
establish your connection.

00:51:16.306 --> 00:51:17.306
That will lead to race

00:51:17.376 --> 00:51:19.016
conditions and may not provide

00:51:19.016 --> 00:51:20.126
an accurate picture of what's

00:51:20.126 --> 00:51:21.566
actually happening in the

00:51:21.566 --> 00:51:21.996
connection.

00:51:22.536 --> 00:51:25.066
And if you need to make sure

00:51:25.066 --> 00:51:26.396
that your connection does not

00:51:26.396 --> 00:51:27.966
establish over a cellular

00:51:27.966 --> 00:51:31.516
network, don't check up front is

00:51:31.516 --> 00:51:32.516
the device currently on a

00:51:32.516 --> 00:51:33.976
cellular network, because that

00:51:33.976 --> 00:51:34.716
could change.

00:51:35.486 --> 00:51:36.846
Simply restrict the interface

00:51:36.846 --> 00:51:38.716
types that you want to use using

00:51:38.716 --> 00:51:40.046
the NWParameters.

00:51:41.266 --> 00:51:42.316
So once you've started your

00:51:42.316 --> 00:51:44.006
connection and you're in the

00:51:44.006 --> 00:51:45.506
ready state, there are a series

00:51:45.506 --> 00:51:47.006
of events that we will give you

00:51:47.476 --> 00:51:49.176
to let you know when the network

00:51:49.176 --> 00:51:49.976
has changed.

00:51:51.336 --> 00:51:53.006
The first one is called

00:51:53.006 --> 00:51:54.236
connection viability.

00:51:55.586 --> 00:51:58.186
So viability means that your

00:51:58.186 --> 00:51:59.646
connection is able to send and

00:51:59.646 --> 00:52:02.306
receive data out the interface

00:52:02.306 --> 00:52:04.206
it has a valid route.

00:52:04.996 --> 00:52:06.896
So to give a demonstration of

00:52:06.896 --> 00:52:08.526
this, let's say that you started

00:52:08.526 --> 00:52:10.266
your connection when the device

00:52:10.406 --> 00:52:11.806
was associated with a WiFi

00:52:11.806 --> 00:52:12.176
network.

00:52:13.456 --> 00:52:16.266
Then, your user walks into the

00:52:16.266 --> 00:52:17.796
elevator, they don't have a

00:52:17.796 --> 00:52:18.506
signal anymore.

00:52:19.216 --> 00:52:20.686
At this point, we will give you

00:52:20.686 --> 00:52:23.176
an event, letting you know that

00:52:23.176 --> 00:52:24.476
your connection is no longer

00:52:24.476 --> 00:52:24.906
viable.

00:52:25.826 --> 00:52:27.086
So what should you do at this

00:52:27.086 --> 00:52:27.356
point?

00:52:28.006 --> 00:52:29.666
Two things.

00:52:30.466 --> 00:52:31.486
We recommend that if it's

00:52:31.486 --> 00:52:32.876
appropriate for your app, you

00:52:32.876 --> 00:52:34.246
can let the user know that they

00:52:34.296 --> 00:52:35.736
currently have no connectivity.

00:52:36.306 --> 00:52:37.436
If they're trying to send and

00:52:37.436 --> 00:52:38.976
receive data, it's not going to

00:52:38.976 --> 00:52:39.726
work right now.

00:52:41.176 --> 00:52:43.156
But, don't necessarily tear down

00:52:43.156 --> 00:52:43.776
your connection.

00:52:44.706 --> 00:52:46.106
At this point, you don't have

00:52:46.106 --> 00:52:47.176
any better interface that you

00:52:47.176 --> 00:52:49.696
could use anyway, and that first

00:52:49.696 --> 00:52:51.086
WiFi interface may come back.

00:52:51.936 --> 00:52:53.466
Oftentimes, if you walk back out

00:52:53.466 --> 00:52:54.616
of an elevator onto the same

00:52:54.616 --> 00:52:56.206
WiFi network, your connection

00:52:56.206 --> 00:52:57.596
can resume right where you left

00:52:57.596 --> 00:52:57.796
off.

00:52:58.466 --> 00:53:01.686
So the other event that we give

00:53:01.686 --> 00:53:03.276
you is the better path

00:53:03.556 --> 00:53:04.296
notification.

00:53:05.596 --> 00:53:07.276
So let's take that same scenario

00:53:07.626 --> 00:53:08.886
in which you connected over the

00:53:08.886 --> 00:53:09.586
WiFi network.

00:53:10.796 --> 00:53:12.296
You walk out of a building let's

00:53:12.296 --> 00:53:14.106
say, and now you no longer have

00:53:14.106 --> 00:53:15.286
WiFi, but you do have the

00:53:15.286 --> 00:53:16.636
cellular network available to

00:53:16.636 --> 00:53:16.776
you.

00:53:17.526 --> 00:53:18.556
At this point, we'll let you

00:53:18.556 --> 00:53:19.136
know two things.

00:53:20.146 --> 00:53:21.606
First, that your connection is

00:53:21.606 --> 00:53:23.456
not viable like before, but

00:53:23.716 --> 00:53:25.136
we'll also let you know that

00:53:25.136 --> 00:53:26.306
there is now a better path

00:53:26.586 --> 00:53:27.126
available.

00:53:27.526 --> 00:53:29.236
If you connected again, you

00:53:29.236 --> 00:53:30.036
would be able to use the

00:53:30.036 --> 00:53:30.896
cellular network.

00:53:31.346 --> 00:53:35.616
And the advice here is to, if

00:53:35.616 --> 00:53:36.496
it's appropriate for your

00:53:36.496 --> 00:53:38.756
connection, attempt to migrate

00:53:38.876 --> 00:53:40.156
to a new connection, if you can

00:53:40.156 --> 00:53:42.036
resume the work that you were

00:53:42.606 --> 00:53:43.956
doing before.

00:53:44.126 --> 00:53:45.976
But only close the original

00:53:45.976 --> 00:53:47.216
connection once that new

00:53:47.216 --> 00:53:48.276
connection is fully ready.

00:53:48.756 --> 00:53:50.386
Again, the WiFi network may come

00:53:50.386 --> 00:53:52.886
back, or the connection over

00:53:52.886 --> 00:53:54.146
cellular may fail.

00:53:54.806 --> 00:53:57.386
And the last case I want to

00:53:57.386 --> 00:53:59.736
highlight here is a case in

00:53:59.736 --> 00:54:01.646
which you connect initially over

00:54:01.646 --> 00:54:02.856
the cellular network, and then

00:54:02.856 --> 00:54:04.496
the user walks into a building

00:54:04.736 --> 00:54:06.246
and now they have WiFi access.

00:54:07.126 --> 00:54:08.356
In this case, your connection,

00:54:08.596 --> 00:54:09.706
the original one, is totally

00:54:09.706 --> 00:54:10.076
fine.

00:54:10.166 --> 00:54:12.106
You're still viable, but you now

00:54:12.106 --> 00:54:13.256
also have a better path

00:54:13.256 --> 00:54:13.736
available.

00:54:14.296 --> 00:54:17.706
In this case, again, if you can

00:54:17.706 --> 00:54:19.216
migrate your connection, this is

00:54:19.216 --> 00:54:20.826
probably a good time to try to

00:54:21.216 --> 00:54:23.046
establish a new connection and

00:54:23.046 --> 00:54:23.906
move your data over.

00:54:24.536 --> 00:54:26.326
That will save the user their

00:54:26.926 --> 00:54:28.316
data bill.

00:54:28.526 --> 00:54:30.386
But, continue to use the

00:54:30.386 --> 00:54:31.876
original connection until you

00:54:31.876 --> 00:54:32.636
have the new one fully

00:54:32.636 --> 00:54:33.216
established.

00:54:34.276 --> 00:54:35.496
Just to show how this looks in

00:54:35.496 --> 00:54:37.896
code, we have the viability

00:54:37.896 --> 00:54:39.286
update handler that you can set

00:54:39.286 --> 00:54:40.366
in your connection, we'll give

00:54:40.366 --> 00:54:41.426
you a boolean back to let you

00:54:41.426 --> 00:54:42.776
know whenever you're viable or

00:54:42.776 --> 00:54:45.866
not, and a better path update

00:54:45.866 --> 00:54:47.006
handler to let you know when

00:54:47.006 --> 00:54:48.796
there's a better path available

00:54:49.176 --> 00:54:49.976
or is no longer available.

00:54:53.236 --> 00:54:55.486
And now the better solution to

00:54:55.546 --> 00:54:56.806
all of this to handle network

00:54:56.836 --> 00:54:58.296
mobility is something that we've

00:54:58.296 --> 00:54:59.816
talked about in previous years,

00:55:00.256 --> 00:55:02.306
which is multipath connections,

00:55:02.336 --> 00:55:03.386
Multipath TCP.

00:55:04.236 --> 00:55:05.956
So if you were able to on your

00:55:05.956 --> 00:55:07.636
server enable Multipath TCP and

00:55:07.636 --> 00:55:10.446
you can enable it on the client

00:55:10.446 --> 00:55:11.236
side with the

00:55:11.236 --> 00:55:13.136
multipathServiceType in your

00:55:13.136 --> 00:55:15.166
parameters, then your connection

00:55:15.166 --> 00:55:16.686
will automatically migrate

00:55:16.896 --> 00:55:18.226
between networks as they come

00:55:18.226 --> 00:55:18.606
and go.

00:55:19.096 --> 00:55:20.606
It's a great seamless experience

00:55:20.606 --> 00:55:22.556
that doesn't require any work in

00:55:22.556 --> 00:55:23.676
your application to handle.

00:55:24.616 --> 00:55:26.106
And this is also the same

00:55:26.106 --> 00:55:27.866
service type that's available in

00:55:27.866 --> 00:55:28.676
URLSession.

00:55:29.296 --> 00:55:31.716
A couple points I want to

00:55:31.716 --> 00:55:33.926
highlight here, specific to

00:55:33.926 --> 00:55:34.646
Network.framework.

00:55:35.686 --> 00:55:37.196
If you restrict the interface

00:55:37.196 --> 00:55:38.676
types that you allow to be used

00:55:39.266 --> 00:55:41.296
with your NWParameters that will

00:55:41.296 --> 00:55:43.766
apply to MPTCP, so you can still

00:55:43.896 --> 00:55:45.696
not want to use the cellular

00:55:45.696 --> 00:55:46.726
network with a multipath

00:55:46.756 --> 00:55:48.776
connection, and instead we'll

00:55:48.776 --> 00:55:50.356
just seamlessly migrate between

00:55:50.356 --> 00:55:51.596
different WiFi networks as they

00:55:51.596 --> 00:55:52.326
become available.

00:55:54.496 --> 00:55:56.586
Also, the connection viability

00:55:56.586 --> 00:55:57.986
handler that I mentioned before

00:55:58.496 --> 00:55:59.346
is slightly different from

00:55:59.346 --> 00:56:01.756
Multipath TCP because whenever

00:56:01.756 --> 00:56:02.856
we change a network, we'll

00:56:02.856 --> 00:56:05.136
automatically move for you, your

00:56:05.196 --> 00:56:06.686
connection is only not viable

00:56:06.686 --> 00:56:07.966
when you have no network

00:56:07.966 --> 00:56:13.176
available to you at all.

00:56:13.396 --> 00:56:15.856
So between waiting for

00:56:15.856 --> 00:56:19.056
connectivity, viability, better

00:56:19.566 --> 00:56:21.956
path, MPTCP, we really hope that

00:56:22.026 --> 00:56:23.356
all of the use cases in your

00:56:23.356 --> 00:56:25.996
apps for using tools like SC

00:56:25.996 --> 00:56:27.836
Network Reachability to check

00:56:28.196 --> 00:56:30.096
network changes manually have

00:56:30.136 --> 00:56:30.886
been replaced.

00:56:31.626 --> 00:56:33.606
However, we do recognize that

00:56:33.606 --> 00:56:35.386
there are some scenarios in

00:56:35.386 --> 00:56:36.656
which you still want to know

00:56:37.156 --> 00:56:38.266
what's the available network,

00:56:38.366 --> 00:56:39.406
when does it change.

00:56:40.796 --> 00:56:42.146
For that Network.framework

00:56:42.206 --> 00:56:44.766
offers a new API called the

00:56:44.766 --> 00:56:46.346
NWPathMonitor.

00:56:47.776 --> 00:56:50.136
So the Path Monitor instead of

00:56:50.136 --> 00:56:51.676
watching the reachability and

00:56:51.676 --> 00:56:52.396
trying to predict the

00:56:52.396 --> 00:56:53.996
reachability of a given host

00:56:54.506 --> 00:56:55.786
simply lets you know what is the

00:56:55.786 --> 00:56:57.326
current state of the interfaces

00:56:57.746 --> 00:56:59.226
on your device and when do they

00:56:59.226 --> 00:56:59.766
change.

00:57:01.156 --> 00:57:02.946
It allows you to iterate all of

00:57:02.946 --> 00:57:04.886
the interfaces that you can

00:57:04.886 --> 00:57:06.616
connect over in case you want to

00:57:06.646 --> 00:57:07.926
make a connection over each one,

00:57:08.846 --> 00:57:10.156
and it will let you know

00:57:10.156 --> 00:57:11.766
whenever those networks do

00:57:11.766 --> 00:57:12.196
change.

00:57:13.196 --> 00:57:14.606
So this can be very useful if

00:57:14.606 --> 00:57:16.226
you want to update your UI to

00:57:16.226 --> 00:57:17.956
let the user know, are they

00:57:17.956 --> 00:57:18.726
connected at all.

00:57:18.726 --> 00:57:21.396
And as Stuart mentioned in the

00:57:21.396 --> 00:57:22.976
previous session, there could be

00:57:22.976 --> 00:57:25.676
scenarios in which the user has

00:57:25.676 --> 00:57:27.026
a long form to fill out and they

00:57:27.026 --> 00:57:28.756
don't necessarily want to go and

00:57:28.816 --> 00:57:29.926
fill out something just to

00:57:29.926 --> 00:57:30.676
realize that there's no

00:57:30.676 --> 00:57:31.766
connectivity anyway.

00:57:32.806 --> 00:57:34.696
So use Network Path Monitor in

00:57:34.696 --> 00:57:36.886
any of these scenarios in which

00:57:37.116 --> 00:57:38.506
just having a waiting connection

00:57:38.566 --> 00:57:39.376
is not enough.

00:57:39.986 --> 00:57:41.126
So between all of these things,

00:57:41.126 --> 00:57:42.226
we'd really like to see people

00:57:42.226 --> 00:57:44.956
move off of reachability and

00:57:44.956 --> 00:57:46.936
handle network transitions more

00:57:46.936 --> 00:57:48.316
gracefully than ever before.

00:57:48.926 --> 00:57:52.036
So with that, I'd like to invite

00:57:52.086 --> 00:57:53.546
Josh back up to the state to let

00:57:53.546 --> 00:57:54.396
you know how you can get

00:57:54.396 --> 00:57:56.116
involved and start adopting

00:57:56.116 --> 00:57:56.736
Network.framework.

00:57:57.516 --> 00:58:01.636
[ Applause ]

00:58:02.136 --> 00:58:03.126
>> Thank you, Tommy.

00:58:03.916 --> 00:58:05.416
So I've got a great new API for

00:58:05.566 --> 00:58:06.996
you that we think you're going

00:58:06.996 --> 00:58:07.316
to love.

00:58:08.346 --> 00:58:09.156
We'd like to talk about the

00:58:09.156 --> 00:58:10.416
things that you can do to start

00:58:10.416 --> 00:58:12.206
using it today, but first I want

00:58:12.206 --> 00:58:13.276
to talk about a few things that

00:58:13.276 --> 00:58:14.886
we'd like you to stop doing so

00:58:14.886 --> 00:58:16.166
we can really take advantage of

00:58:16.166 --> 00:58:17.376
the new technologies like user

00:58:17.376 --> 00:58:18.216
space networking.

00:58:19.796 --> 00:58:21.206
If you're on macOS, and you have

00:58:21.206 --> 00:58:22.446
a Network Kernel Extension, and

00:58:22.446 --> 00:58:23.376
there's something you're doing

00:58:23.376 --> 00:58:24.546
in that Network Kernel Extension

00:58:24.546 --> 00:58:25.946
that you can't do any other way,

00:58:26.106 --> 00:58:27.206
please get in touch with us

00:58:27.296 --> 00:58:27.836
right away.

00:58:28.106 --> 00:58:29.226
We need to provide you a better

00:58:29.226 --> 00:58:30.636
alternative because Network

00:58:30.636 --> 00:58:31.846
Kernel Extensions are not

00:58:31.846 --> 00:58:33.176
compatible with User Space

00:58:33.176 --> 00:58:33.686
Networking.

00:58:34.656 --> 00:58:36.226
We wanted to give you a heads-up

00:58:36.276 --> 00:58:39.286
that with URLSession, FTP and

00:58:39.286 --> 00:58:40.696
file URLs are no longer going to

00:58:40.696 --> 00:58:42.166
be supported for Proxy Automatic

00:58:42.166 --> 00:58:42.936
Configuration.

00:58:43.016 --> 00:58:44.076
Going forward, the only

00:58:44.076 --> 00:58:46.006
supported URL schemes will be

00:58:46.006 --> 00:58:47.226
HTTP and HTTPS.

00:58:47.226 --> 00:58:50.826
There are a number of APIs at

00:58:50.826 --> 00:58:52.626
the CoreFoundation layer that we

00:58:52.626 --> 00:58:53.746
would like you to stop using.

00:58:54.066 --> 00:58:54.966
They will be deprecated

00:58:54.966 --> 00:58:55.456
eventually.

00:58:55.606 --> 00:58:56.916
They are not yet marked as

00:58:56.916 --> 00:58:57.466
deprecated.

00:58:58.046 --> 00:58:58.806
These are

00:58:59.126 --> 00:59:01.496
CFStreamCreatePairWith, anything

00:59:01.496 --> 00:59:03.276
related to sockets as well as

00:59:03.276 --> 00:59:03.796
CFSocket.

00:59:04.606 --> 00:59:06.146
These cannot take advantage of a

00:59:06.146 --> 00:59:07.296
lot of the connection

00:59:07.296 --> 00:59:08.316
establishment that we've put in

00:59:08.316 --> 00:59:09.486
there with the new

00:59:09.486 --> 00:59:10.766
Network.framework, and they

00:59:10.766 --> 00:59:11.776
can't take advantage of the new

00:59:11.776 --> 00:59:12.886
User Space Networking.

00:59:12.996 --> 00:59:14.006
So we really want you to move

00:59:14.006 --> 00:59:15.266
off of these to take advantage

00:59:15.546 --> 00:59:17.356
of the incredibly robust

00:59:17.356 --> 00:59:18.556
connectivity improvements that

00:59:18.556 --> 00:59:19.376
you'll get with

00:59:19.376 --> 00:59:21.046
Network.framework and URLSession

00:59:21.536 --> 00:59:22.776
and the improved performance.

00:59:23.936 --> 00:59:25.656
There are some foundation APIs

00:59:25.656 --> 00:59:26.566
as well that we'd like you to

00:59:26.566 --> 00:59:27.246
move away from.

00:59:27.526 --> 00:59:29.106
If you're using any of these

00:59:29.196 --> 00:59:31.856
NSStream, NSNetService, or

00:59:31.906 --> 00:59:34.076
NSSocket for APIs, please move

00:59:34.076 --> 00:59:35.656
to Network.framework or

00:59:35.886 --> 00:59:36.606
URLSession.

00:59:37.576 --> 00:59:38.476
Finally, if you're using

00:59:38.556 --> 00:59:40.906
SCNetworkReachability, we feel

00:59:40.906 --> 00:59:41.996
that the Wait for Connectivity

00:59:41.996 --> 00:59:43.836
model is a much better model, so

00:59:43.836 --> 00:59:45.196
we'd really like you to move to

00:59:45.196 --> 00:59:45.406
that.

00:59:46.166 --> 00:59:47.166
And for those few cases where

00:59:47.166 --> 00:59:48.526
Wait for Connectivity isn't the

00:59:48.526 --> 00:59:50.576
right answer, NWPathMonitor is a

00:59:50.576 --> 00:59:51.776
much better solution going

00:59:51.776 --> 00:59:52.146
forward.

00:59:52.956 --> 00:59:54.216
So now that we've talked about

00:59:54.216 --> 00:59:55.016
some things we'd like you to

00:59:55.016 --> 00:59:56.216
stop doing, I want to focus on

00:59:56.216 --> 00:59:57.216
the things we really want to see

00:59:57.216 --> 00:59:57.516
you do.

00:59:58.736 --> 01:00:00.056
Going forward, the preferred

01:00:00.056 --> 01:00:01.576
APIs on our platforms for

01:00:01.576 --> 01:00:03.546
networking are URLSession and

01:00:03.546 --> 01:00:04.346
Network.framework.

01:00:04.816 --> 01:00:06.836
URLSession is really focused on

01:00:06.836 --> 01:00:09.046
HTTP, but Stream Task provides

01:00:09.636 --> 01:00:11.716
pretty simple access to TCP and

01:00:11.716 --> 01:00:12.686
TLS connections.

01:00:13.586 --> 01:00:14.856
If you need something more

01:00:14.856 --> 01:00:16.516
advanced, Network.framework

01:00:16.516 --> 01:00:18.376
gives you great support for TCP,

01:00:18.726 --> 01:00:20.776
TLS, UDP, DTLS.

01:00:21.166 --> 01:00:22.696
It handles listening for inbound

01:00:22.696 --> 01:00:23.896
connections as well as outbound

01:00:23.896 --> 01:00:25.606
connections, and we've got Path

01:00:25.606 --> 01:00:26.876
Monitor to handle some of the

01:00:26.876 --> 01:00:27.666
mobility stuff.

01:00:28.006 --> 01:00:30.986
Next steps, we really want to

01:00:30.986 --> 01:00:32.806
see you adopt these, adopt

01:00:32.806 --> 01:00:33.756
Network.framework and

01:00:33.756 --> 01:00:34.516
URLSession.

01:00:35.116 --> 01:00:35.936
Your customers are going to

01:00:35.936 --> 01:00:37.016
appreciate how much better your

01:00:37.016 --> 01:00:38.676
connections, how much more

01:00:38.676 --> 01:00:39.736
reliable your connections are

01:00:39.736 --> 01:00:40.876
established, and they'll

01:00:40.876 --> 01:00:42.006
appreciate the longer battery

01:00:42.006 --> 01:00:42.606
life from the better

01:00:42.606 --> 01:00:43.216
performance.

01:00:45.156 --> 01:00:46.066
While you're working on these,

01:00:46.146 --> 01:00:48.866
focus on how you're handling

01:00:48.866 --> 01:00:50.166
your sending and receiving to

01:00:50.166 --> 01:00:50.946
really optimize that

01:00:50.946 --> 01:00:51.536
performance.

01:00:52.146 --> 01:00:53.446
And take a lot of time to get

01:00:53.446 --> 01:00:55.386
that support for the viability

01:00:55.386 --> 01:00:57.186
and better route changes in

01:00:57.186 --> 01:00:57.356
there.

01:00:57.506 --> 01:00:59.136
It can make all the difference

01:00:59.136 --> 01:01:00.016
for providing a seamless

01:01:00.016 --> 01:01:01.006
networking experience.

01:01:02.946 --> 01:01:03.346
Now we know that

01:01:03.346 --> 01:01:04.176
Network.framework doesn't

01:01:04.176 --> 01:01:06.336
support UDP Multicast yet, so if

01:01:06.336 --> 01:01:07.666
you're doing UDP Multicast, we'd

01:01:07.666 --> 01:01:08.706
really like to understand your

01:01:08.706 --> 01:01:10.146
use cases so we can take those

01:01:10.146 --> 01:01:11.206
into account going forward.

01:01:12.386 --> 01:01:13.706
In addition, if you have any

01:01:13.706 --> 01:01:14.876
other questions or enhancement

01:01:14.876 --> 01:01:16.656
requests, we'd love to hear from

01:01:16.656 --> 01:01:16.816
you.

01:01:17.126 --> 01:01:18.846
Contact developer support or

01:01:18.846 --> 01:01:20.416
better yet, meet us in one of

01:01:20.416 --> 01:01:20.846
the labs.

01:01:20.846 --> 01:01:22.166
We have a lab after lunch at 2

01:01:22.166 --> 01:01:23.466
p.m. and another one tomorrow

01:01:23.466 --> 01:01:26.176
morning at 9 a.m. For more

01:01:26.176 --> 01:01:27.486
information, see this URL.

01:01:29.046 --> 01:01:30.326
Don't forget the labs tomorrow

01:01:30.326 --> 01:01:31.786
morning and after lunch.

01:01:31.786 --> 01:01:33.066
Thank you so much and have a

01:01:33.066 --> 01:01:33.876
great WWDC.

01:01:34.508 --> 01:01:36.508
[ Applause ]
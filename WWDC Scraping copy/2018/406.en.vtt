WEBVTT

00:00:07.516 --> 00:00:15.500
[ Music ]

00:00:27.516 --> 00:00:34.116
[ Applause ]

00:00:34.616 --> 00:00:36.876
Hi, everybody, I'm Ben.

00:00:37.016 --> 00:00:37.986
I work on the Swift standard

00:00:37.986 --> 00:00:38.306
library.

00:00:38.386 --> 00:00:39.686
And together with my colleague

00:00:39.686 --> 00:00:40.816
Doug, from the compiler team.

00:00:40.946 --> 00:00:42.326
We're going to talk to you about

00:00:42.326 --> 00:00:43.136
Swift generics.

00:00:43.726 --> 00:00:46.416
So the recent releases of Swift

00:00:46.416 --> 00:00:47.536
have added some important new

00:00:47.536 --> 00:00:48.056
features.

00:00:48.826 --> 00:00:49.916
Including conditional

00:00:49.916 --> 00:00:51.506
conformance and recursive

00:00:51.506 --> 00:00:52.446
protocol constraints.

00:00:53.536 --> 00:00:55.186
And, in fact, with every release

00:00:55.186 --> 00:00:56.876
of Swift, we've been refining

00:00:56.876 --> 00:00:58.506
the generic system, making it

00:00:58.506 --> 00:00:59.266
more expressive.

00:00:59.396 --> 00:01:01.926
And we feel that the 4.2 release

00:01:01.926 --> 00:01:03.166
marks an important point.

00:01:04.296 --> 00:01:05.756
It's the point where we can

00:01:05.756 --> 00:01:08.056
finally fully implement a number

00:01:08.056 --> 00:01:09.226
of designs that have always been

00:01:09.226 --> 00:01:10.096
envisioned for the standard

00:01:10.096 --> 00:01:10.746
library.

00:01:10.936 --> 00:01:12.196
Something that's critical for us

00:01:12.626 --> 00:01:14.106
in achieving our goal of API

00:01:14.106 --> 00:01:15.176
stability for Swift.

00:01:16.696 --> 00:01:18.226
So, we've given a lot of talks

00:01:18.226 --> 00:01:19.406
about generics in the past, but

00:01:19.406 --> 00:01:20.516
we haven't taken a step back.

00:01:20.546 --> 00:01:22.016
And talked about generics as a

00:01:22.016 --> 00:01:22.756
whole for a while.

00:01:23.496 --> 00:01:24.686
So today, we're going to take

00:01:24.686 --> 00:01:26.306
you through a few different

00:01:26.306 --> 00:01:27.436
features of the generics system.

00:01:27.436 --> 00:01:29.626
Both new and old, to help

00:01:29.626 --> 00:01:30.716
understand how they fit

00:01:30.716 --> 00:01:31.026
together.

00:01:31.026 --> 00:01:34.006
I'm going to briefly recap the

00:01:34.006 --> 00:01:35.426
motivation for generics.

00:01:37.076 --> 00:01:38.186
We're going to talk about

00:01:38.186 --> 00:01:39.356
designing protocols, given a

00:01:39.356 --> 00:01:41.116
number of concrete types, using

00:01:41.116 --> 00:01:42.576
examples taken from the standard

00:01:42.576 --> 00:01:43.236
library.

00:01:44.016 --> 00:01:45.526
We're going to review protocol

00:01:45.526 --> 00:01:47.146
inheritance, and talk about the

00:01:47.146 --> 00:01:48.626
new feature of conditional

00:01:48.626 --> 00:01:49.206
conformance.

00:01:49.206 --> 00:01:50.186
And how it interacts with

00:01:50.226 --> 00:01:51.176
protocol inheritance.

00:01:51.996 --> 00:01:53.356
And finally, we're going to wrap

00:01:53.356 --> 00:01:55.486
up with a discussion of classes

00:01:55.486 --> 00:01:56.216
and generics.

00:01:58.556 --> 00:01:59.796
So why are generics such an

00:01:59.796 --> 00:02:01.026
important part of Swift?

00:02:01.836 --> 00:02:03.236
Well one way of seeing their

00:02:03.236 --> 00:02:05.486
impact is by designing a simple

00:02:05.486 --> 00:02:06.606
collection, like type.

00:02:08.205 --> 00:02:09.666
We'll call it buffer, and it's

00:02:09.666 --> 00:02:10.536
going to be similar to the

00:02:10.536 --> 00:02:11.816
standard library's array type.

00:02:12.876 --> 00:02:14.586
Now, the simplest possible API

00:02:14.586 --> 00:02:15.856
for the reading part of a buffer

00:02:15.856 --> 00:02:17.276
might include a count of the

00:02:17.276 --> 00:02:18.096
number of elements.

00:02:18.366 --> 00:02:20.046
And a way to fetch each element

00:02:20.046 --> 00:02:21.026
to the given position in the

00:02:21.026 --> 00:02:21.516
index.

00:02:22.086 --> 00:02:23.376
But, what do we make of that

00:02:23.376 --> 00:02:24.016
return type?

00:02:24.916 --> 00:02:26.336
Now, if we didn't have generics,

00:02:26.336 --> 00:02:28.136
we'd have to make it some kind

00:02:28.136 --> 00:02:29.126
of type that could represent

00:02:29.126 --> 00:02:30.556
anything that we'd want to put

00:02:30.556 --> 00:02:31.376
inside the buffer.

00:02:32.096 --> 00:02:33.966
You can call that type ID or

00:02:33.966 --> 00:02:35.226
object or void star.

00:02:35.506 --> 00:02:38.006
In Swift we call it Any, which

00:02:38.006 --> 00:02:39.566
is a type that can stand in for

00:02:39.566 --> 00:02:40.936
any different kind of type in

00:02:40.936 --> 00:02:41.306
Swift.

00:02:44.006 --> 00:02:45.106
So if you wanted to handle

00:02:45.106 --> 00:02:45.996
anything in the buffer, you

00:02:45.996 --> 00:02:47.356
could have subscript return an

00:02:47.356 --> 00:02:47.706
Any.

00:02:48.086 --> 00:02:49.496
But, of course, you probably

00:02:49.496 --> 00:02:50.466
know that that leads to a really

00:02:50.466 --> 00:02:51.906
unpleasant user experience.

00:02:52.136 --> 00:02:53.186
At some point, you've got to get

00:02:53.186 --> 00:02:55.086
out that type from inside the

00:02:55.086 --> 00:02:55.566
box.

00:02:56.076 --> 00:02:57.906
In order to actually use it.

00:03:00.576 --> 00:03:03.106
And this isn't just annoying,

00:03:03.106 --> 00:03:04.406
it's also error-prone.

00:03:04.826 --> 00:03:05.856
What if somewhere in your code,

00:03:05.856 --> 00:03:07.806
maybe by accident, you put an

00:03:07.806 --> 00:03:09.226
integer into what was supposed

00:03:09.226 --> 00:03:10.286
to be a buffer of strings?

00:03:11.226 --> 00:03:13.926
But it's not just about ease of

00:03:13.926 --> 00:03:14.246
use.

00:03:14.246 --> 00:03:15.246
We also want to solve some

00:03:15.246 --> 00:03:16.856
problems relating to how these

00:03:16.856 --> 00:03:18.506
values are represented in

00:03:18.506 --> 00:03:18.876
memory.

00:03:19.666 --> 00:03:23.106
Now, the ideal representation

00:03:23.326 --> 00:03:24.986
for a buffer of strings, would

00:03:24.986 --> 00:03:26.716
be a contiguous block of memory.

00:03:27.146 --> 00:03:28.936
With every element held in line

00:03:28.936 --> 00:03:29.626
next to each other.

00:03:30.626 --> 00:03:32.566
But with an untyped approach,

00:03:33.016 --> 00:03:34.076
this doesn't work out quite so

00:03:34.076 --> 00:03:34.336
well.

00:03:34.336 --> 00:03:35.646
Because the buffer doesn't know

00:03:35.646 --> 00:03:37.856
in advance what kind of type

00:03:37.856 --> 00:03:38.766
it's going to contain.

00:03:38.766 --> 00:03:40.696
And so it has to use a type like

00:03:40.746 --> 00:03:42.126
Any that can account for any of

00:03:42.126 --> 00:03:42.936
the possibilities.

00:03:43.236 --> 00:03:44.536
And, there's a lot of overhead

00:03:44.776 --> 00:03:46.086
in tracking, boxing, and

00:03:46.086 --> 00:03:49.146
unboxing the types in that Any.

00:03:50.296 --> 00:03:52.436
Here, I might have just wanted a

00:03:52.436 --> 00:03:54.056
buffer of integers, but I have

00:03:54.186 --> 00:03:55.686
no way of expressing that to the

00:03:55.686 --> 00:03:56.626
compiler.

00:03:56.626 --> 00:03:57.616
And so, I'm paying for

00:03:57.616 --> 00:03:59.176
flexibility, even though I'm not

00:03:59.176 --> 00:04:01.266
interested in it.

00:04:01.586 --> 00:04:02.976
What's more, because Any has to

00:04:02.976 --> 00:04:04.526
account for any different kind

00:04:04.526 --> 00:04:04.896
of type.

00:04:05.466 --> 00:04:06.566
Including types that are too

00:04:06.566 --> 00:04:08.686
large to fit inside its own

00:04:08.686 --> 00:04:10.666
internal storage, it has to

00:04:10.666 --> 00:04:11.866
sometimes use indirection.

00:04:11.866 --> 00:04:13.456
It has to hold a pointer to the

00:04:13.456 --> 00:04:14.886
values, and that value could be

00:04:14.886 --> 00:04:16.565
located all over memory.

00:04:17.886 --> 00:04:18.875
And so we really want to solve

00:04:18.875 --> 00:04:20.136
these problems, not just for

00:04:20.136 --> 00:04:21.526
ease of use and correctness, but

00:04:21.526 --> 00:04:23.556
also for performance reasons.

00:04:24.146 --> 00:04:26.126
And, we do it using a technique

00:04:26.816 --> 00:04:28.556
called parametric polymorphism.

00:04:29.376 --> 00:04:30.606
Which is just another term for

00:04:30.606 --> 00:04:32.776
what we in Swift refer to as

00:04:32.776 --> 00:04:33.446
generics.

00:04:34.716 --> 00:04:36.476
With a generic approach, we put

00:04:36.476 --> 00:04:38.346
more information on the buffer,

00:04:38.346 --> 00:04:39.466
to represent the type that the

00:04:39.466 --> 00:04:40.596
buffer is going to contain.

00:04:41.746 --> 00:04:42.836
We'll call that type Element.

00:04:44.196 --> 00:04:45.826
Element is a generic parameter

00:04:45.826 --> 00:04:47.436
of the type, hence the term of

00:04:47.436 --> 00:04:48.896
parametric polymorphism.

00:04:49.096 --> 00:04:50.726
You can think of it kind of like

00:04:50.726 --> 00:04:52.626
a compile-time argument that

00:04:52.626 --> 00:04:53.926
tells the buffer what it's going

00:04:53.926 --> 00:04:54.396
to contain.

00:04:55.716 --> 00:04:56.946
Now it has a way of referring to

00:04:56.946 --> 00:04:57.706
that element type.

00:04:57.976 --> 00:04:59.106
It can use it wherever it was

00:04:59.146 --> 00:05:00.316
previously using Any.

00:05:03.336 --> 00:05:04.216
And, that means that there's no

00:05:04.216 --> 00:05:05.476
need to do conversions when

00:05:05.476 --> 00:05:06.416
you're getting a type out of the

00:05:06.416 --> 00:05:06.746
buffer.

00:05:06.746 --> 00:05:09.106
And if you make an accidental

00:05:09.296 --> 00:05:10.456
assignment of the wrong kind of

00:05:10.456 --> 00:05:12.086
type, or some issue similar to

00:05:12.086 --> 00:05:12.306
that.

00:05:12.526 --> 00:05:13.566
The compiler will catch you.

00:05:15.216 --> 00:05:17.136
Now, now there's no such type as

00:05:17.136 --> 00:05:19.406
buffer without an associated

00:05:19.406 --> 00:05:20.116
element type.

00:05:20.836 --> 00:05:22.216
If you try to declare a type

00:05:22.216 --> 00:05:23.646
like that, you'll get a

00:05:23.646 --> 00:05:24.326
compilation error.

00:05:26.176 --> 00:05:26.956
You might find that slightly

00:05:26.956 --> 00:05:27.636
surprising.

00:05:27.636 --> 00:05:29.106
Because sometimes you'll see

00:05:29.106 --> 00:05:30.456
that you can declare types like

00:05:30.516 --> 00:05:32.386
buffer without any element type.

00:05:33.206 --> 00:05:33.926
But, that's just because the

00:05:33.926 --> 00:05:35.716
compiler is able to infer what

00:05:35.716 --> 00:05:36.896
the element type ought to be

00:05:37.206 --> 00:05:38.126
from the context.

00:05:38.546 --> 00:05:39.716
In this case, from the literals

00:05:39.716 --> 00:05:40.676
on the right-hand side here.

00:05:41.686 --> 00:05:43.846
The element is still there, it's

00:05:43.846 --> 00:05:44.576
just implicit.

00:05:46.356 --> 00:05:48.046
This knowledge of exactly what

00:05:48.126 --> 00:05:50.506
type a buff-- a type like buffer

00:05:50.506 --> 00:05:52.326
contains is carried all the way

00:05:52.326 --> 00:05:54.276
through both compile and

00:05:54.276 --> 00:05:54.886
runtime.

00:05:55.596 --> 00:05:57.926
And this means that we can

00:05:58.076 --> 00:05:59.576
achieve our goal of holding all

00:05:59.576 --> 00:06:01.266
of the elements in a contiguous

00:06:01.306 --> 00:06:02.416
block of memory, with no

00:06:02.416 --> 00:06:02.936
overhead.

00:06:03.966 --> 00:06:05.476
Even if those types are

00:06:05.476 --> 00:06:06.526
arbitrarily large.

00:06:08.196 --> 00:06:09.866
And because the compiler has

00:06:10.816 --> 00:06:12.416
direct knowledge at all times of

00:06:12.416 --> 00:06:14.546
exactly what element type the

00:06:14.546 --> 00:06:15.376
buffer contains.

00:06:15.956 --> 00:06:16.976
It has optimization

00:06:16.976 --> 00:06:18.356
opportunities available to it

00:06:18.356 --> 00:06:19.646
that it wouldn't otherwise have.

00:06:20.586 --> 00:06:21.796
So, in the case here, where I've

00:06:21.796 --> 00:06:23.436
declared a buffer of integers.

00:06:24.296 --> 00:06:25.686
A loop like this ought to be

00:06:25.686 --> 00:06:27.366
compiled down to just a handful

00:06:27.366 --> 00:06:28.766
of very efficient CPU

00:06:28.766 --> 00:06:29.436
instructions.

00:06:31.936 --> 00:06:32.876
Now, if you were writing a loop

00:06:32.876 --> 00:06:36.186
like this, on a regular basis.

00:06:36.546 --> 00:06:37.826
To sum up a buffer of integers,

00:06:38.006 --> 00:06:39.336
it might make sense to extract

00:06:39.336 --> 00:06:40.776
it out into a method.

00:06:40.876 --> 00:06:44.086
An extension on buffer that's

00:06:44.086 --> 00:06:45.526
more unit-testable, and more

00:06:45.526 --> 00:06:46.966
readable when you actually call

00:06:47.026 --> 00:06:47.206
it.

00:06:48.356 --> 00:06:49.326
But, you probably know that if

00:06:49.326 --> 00:06:50.306
you've written code like this,

00:06:50.706 --> 00:06:52.026
you'll get a compilation issue,

00:06:52.516 --> 00:06:54.466
because not all element types

00:06:54.466 --> 00:06:57.366
can be summed up like this.

00:06:57.666 --> 00:06:58.916
We need to tell the compiler

00:06:59.126 --> 00:07:01.506
more about the capabilities the

00:07:01.506 --> 00:07:03.646
element needs to have, in order

00:07:03.646 --> 00:07:05.636
to make this method available on

00:07:05.636 --> 00:07:06.356
a buffer.

00:07:07.136 --> 00:07:08.816
Now, the easiest way to do that

00:07:08.816 --> 00:07:10.626
is by constraining the element

00:07:10.626 --> 00:07:12.386
type to be a specific type like

00:07:12.386 --> 00:07:13.856
the Int from our original loop.

00:07:14.676 --> 00:07:18.366
If you take this easy approach

00:07:18.366 --> 00:07:19.396
to get up and running with your

00:07:19.396 --> 00:07:20.656
extension, it's easy to

00:07:20.656 --> 00:07:21.726
generalize it later.

00:07:22.176 --> 00:07:22.926
When you find that you need to

00:07:22.926 --> 00:07:23.676
do something different.

00:07:23.676 --> 00:07:25.296
Like sum up a buffer of doubles,

00:07:25.296 --> 00:07:25.906
or floats.

00:07:26.966 --> 00:07:28.256
Just look at the type that

00:07:28.256 --> 00:07:29.226
you've constrained to.

00:07:29.226 --> 00:07:31.006
Look at the protocols it

00:07:31.006 --> 00:07:31.656
conforms to.

00:07:31.846 --> 00:07:33.116
And follow them up until you get

00:07:33.116 --> 00:07:34.816
the most general protocol that

00:07:34.816 --> 00:07:35.736
gives you everything that you

00:07:35.736 --> 00:07:36.626
need to do your work.

00:07:37.686 --> 00:07:39.206
In this case, the numeric

00:07:39.206 --> 00:07:40.646
protocol, which gives us the two

00:07:40.646 --> 00:07:41.756
things we're relying on here.

00:07:42.486 --> 00:07:44.876
The ability to create a new

00:07:44.876 --> 00:07:46.596
element with a value of zero,

00:07:46.596 --> 00:07:48.096
and the ability to add elements

00:07:48.096 --> 00:07:48.476
to it.

00:07:49.076 --> 00:07:49.876
Which come as part of the

00:07:49.876 --> 00:07:50.676
numeric protocol.

00:07:53.696 --> 00:07:54.776
Now, let's talk about that

00:07:54.776 --> 00:07:56.156
process of factoring out

00:07:56.246 --> 00:07:58.496
protocols from various types.

00:07:59.456 --> 00:08:01.226
So we've been talking about this

00:08:01.226 --> 00:08:03.366
buffer type, and we can make it

00:08:03.366 --> 00:08:04.336
generic across different

00:08:04.336 --> 00:08:04.856
elements.

00:08:04.856 --> 00:08:06.176
But what about writing generic

00:08:06.176 --> 00:08:07.936
code that's generic in a

00:08:07.936 --> 00:08:08.596
different direction?

00:08:09.156 --> 00:08:10.356
Or writing code that works on

00:08:10.356 --> 00:08:11.236
any different kind of

00:08:11.236 --> 00:08:11.716
collection?

00:08:13.236 --> 00:08:14.946
Such as an array that's very

00:08:14.946 --> 00:08:16.136
similar to our buffer type.

00:08:16.886 --> 00:08:18.766
But also more varied types, like

00:08:18.906 --> 00:08:20.506
a dictionary that's a collection

00:08:20.506 --> 00:08:23.226
of key value pairs.

00:08:23.226 --> 00:08:24.806
Or maybe types that aren't

00:08:24.806 --> 00:08:25.766
generic or are the different

00:08:25.766 --> 00:08:27.656
element types, like data or

00:08:27.656 --> 00:08:29.086
string that returns specific

00:08:29.086 --> 00:08:29.746
element types.

00:08:30.286 --> 00:08:33.256
We want to create a protocol

00:08:33.256 --> 00:08:34.876
that captures all of their

00:08:34.876 --> 00:08:36.025
common capabilities.

00:08:36.635 --> 00:08:38.466
We're going to create a, a cut

00:08:38.525 --> 00:08:40.236
down, simplified version of the

00:08:40.236 --> 00:08:41.236
standard library's own

00:08:41.236 --> 00:08:41.976
collection protocol.

00:08:45.126 --> 00:08:46.926
So notice that we considered a

00:08:46.926 --> 00:08:49.266
varied number of concrete types

00:08:49.266 --> 00:08:49.906
first.

00:08:49.906 --> 00:08:51.806
And now, we're thinking about a

00:08:51.806 --> 00:08:53.546
kind of protocol that could join

00:08:53.546 --> 00:08:54.076
them all together.

00:08:54.196 --> 00:08:55.656
And, it's important to think of

00:08:55.656 --> 00:08:56.966
things as this way around.

00:08:57.226 --> 00:08:58.726
To start with some concrete

00:08:58.726 --> 00:09:00.566
types, and then try and unify

00:09:00.566 --> 00:09:01.816
them with a protocol.

00:09:03.336 --> 00:09:04.176
What do those types have in

00:09:04.176 --> 00:09:04.566
common?

00:09:05.186 --> 00:09:06.456
What don't they have in common?

00:09:07.356 --> 00:09:08.706
When you're designing a protocol

00:09:08.706 --> 00:09:09.886
like this, you can think of it

00:09:09.886 --> 00:09:11.246
kind of like a contract

00:09:11.246 --> 00:09:11.966
negotiation.

00:09:13.316 --> 00:09:14.686
There's a natural push and pull

00:09:14.686 --> 00:09:16.426
here, between conforming types

00:09:16.426 --> 00:09:17.086
on the one hand.

00:09:17.526 --> 00:09:19.386
That want as much flexibility as

00:09:19.386 --> 00:09:20.896
possible in fulfilling that

00:09:20.896 --> 00:09:21.376
contract.

00:09:22.636 --> 00:09:24.636
And users of the protocol, that

00:09:24.636 --> 00:09:25.856
want a really nice, tight,

00:09:26.086 --> 00:09:28.546
simple protocol in order to do

00:09:28.546 --> 00:09:29.246
their extensions.

00:09:30.306 --> 00:09:32.196
That's why it's really important

00:09:32.226 --> 00:09:33.776
to have both a variety of

00:09:33.776 --> 00:09:35.006
different possible conforming

00:09:35.006 --> 00:09:35.396
types.

00:09:35.916 --> 00:09:37.226
And a number of different use

00:09:37.226 --> 00:09:38.616
cases in mind when you're

00:09:38.616 --> 00:09:39.626
designing your protocol.

00:09:40.276 --> 00:09:42.246
Because it's a balancing act.

00:09:43.076 --> 00:09:45.716
So, let's start to flesh out the

00:09:45.716 --> 00:09:46.546
collection protocol.

00:09:46.726 --> 00:09:47.896
So, first we need to represent

00:09:47.896 --> 00:09:48.616
the element type.

00:09:49.036 --> 00:09:50.236
Now, in protocols, we use an

00:09:50.236 --> 00:09:52.556
associated type for that.

00:09:52.956 --> 00:09:54.356
Each conforming type needs to

00:09:54.356 --> 00:09:55.906
set element to be something

00:09:55.906 --> 00:09:56.476
appropriate.

00:09:56.556 --> 00:09:59.096
In the case of buffer, or array,

00:09:59.096 --> 00:10:01.726
as of Swift 4.2, this happens

00:10:01.846 --> 00:10:02.516
automatically.

00:10:03.256 --> 00:10:04.416
Because we also named their

00:10:04.416 --> 00:10:06.016
generic parameters to be element

00:10:06.016 --> 00:10:06.416
as well.

00:10:07.706 --> 00:10:09.136
This is a nice side benefit of

00:10:09.136 --> 00:10:10.356
giving your generic arguments

00:10:10.466 --> 00:10:11.856
meaningful names that follow

00:10:11.856 --> 00:10:13.816
common conventions like the word

00:10:13.816 --> 00:10:14.226
element.

00:10:15.726 --> 00:10:16.406
Rather than giving them

00:10:16.406 --> 00:10:17.856
something arbitrary like T that

00:10:17.856 --> 00:10:19.256
you'd have to separately state

00:10:19.256 --> 00:10:20.116
was the element type.

00:10:22.096 --> 00:10:23.296
For other data types, you might

00:10:23.296 --> 00:10:24.186
need to do something slightly

00:10:24.186 --> 00:10:24.816
more specific.

00:10:24.816 --> 00:10:26.186
For example, a dictionary needs

00:10:26.186 --> 00:10:27.466
to set the element type to be

00:10:27.466 --> 00:10:28.986
the pair of its key and value

00:10:29.066 --> 00:10:29.266
type.

00:10:29.746 --> 00:10:33.486
Next, let's talk about adding

00:10:33.486 --> 00:10:34.646
the subscript operation.

00:10:35.896 --> 00:10:37.026
Now, if we were talking about

00:10:37.156 --> 00:10:38.566
just a protocol for types like

00:10:38.626 --> 00:10:40.376
array, we might be tempted to

00:10:40.376 --> 00:10:42.576
have subscripts take an Int as

00:10:42.576 --> 00:10:43.146
its argument.

00:10:45.036 --> 00:10:47.256
But making subscript take an Int

00:10:47.476 --> 00:10:49.006
would imply a very strong

00:10:49.006 --> 00:10:50.456
contract.

00:10:50.936 --> 00:10:52.466
Every conforming type would have

00:10:52.586 --> 00:10:54.536
to supply the ability to fetch

00:10:54.536 --> 00:10:55.756
an element's given position that

00:10:55.756 --> 00:10:57.396
was represented by an integer.

00:10:57.916 --> 00:10:59.836
And, that works great for types

00:11:00.086 --> 00:11:00.716
like array.

00:11:01.596 --> 00:11:03.526
It's also definitely easy for

00:11:03.526 --> 00:11:04.586
users of the protocol to

00:11:04.586 --> 00:11:05.116
understand.

00:11:06.186 --> 00:11:07.296
But is it flexible enough for a

00:11:07.296 --> 00:11:08.526
slightly more complicated type,

00:11:08.626 --> 00:11:09.506
like a dictionary?

00:11:11.136 --> 00:11:13.636
Now no matter how you model it,

00:11:13.866 --> 00:11:15.256
a dictionary's probably going to

00:11:15.256 --> 00:11:16.406
be backed by some fairly

00:11:16.406 --> 00:11:17.746
complicated internal data

00:11:17.746 --> 00:11:18.176
structure.

00:11:18.666 --> 00:11:19.866
That has specific logic for

00:11:19.866 --> 00:11:21.466
moving from one element to the

00:11:21.466 --> 00:11:21.916
next.

00:11:22.586 --> 00:11:24.146
For example, it could be backed

00:11:24.276 --> 00:11:26.046
by an internal buffer of some

00:11:26.046 --> 00:11:29.096
kind, and it could use an index

00:11:29.096 --> 00:11:30.736
type that stored an offset into

00:11:30.736 --> 00:11:31.266
that buffer.

00:11:31.266 --> 00:11:33.166
That it could then take as the

00:11:33.166 --> 00:11:34.526
argument to subscript in order

00:11:34.526 --> 00:11:35.366
to fetch an element to the

00:11:35.366 --> 00:11:37.346
position, using that offset.

00:11:38.166 --> 00:11:39.776
But it would be critical that

00:11:39.776 --> 00:11:41.496
the dictionary's index type be

00:11:41.496 --> 00:11:43.116
an opaque type that only the

00:11:43.116 --> 00:11:44.416
dictionary can control.

00:11:45.206 --> 00:11:45.866
You wouldn't want somebody

00:11:45.866 --> 00:11:47.506
necessarily just adding one to

00:11:47.506 --> 00:11:48.036
your offset.

00:11:48.306 --> 00:11:49.176
That wouldn't necessarily move

00:11:49.176 --> 00:11:50.076
to the next element in the

00:11:50.076 --> 00:11:50.576
dictionary.

00:11:51.056 --> 00:11:52.466
It could move some arbitrary,

00:11:52.466 --> 00:11:54.206
maybe uninitialized part of the

00:11:54.206 --> 00:11:55.706
dictionary's internal storage.

00:11:56.826 --> 00:11:57.936
So instead we want the

00:11:57.936 --> 00:12:00.486
dictionary to control moving

00:12:00.486 --> 00:12:02.126
forward through the collection

00:12:02.126 --> 00:12:03.346
by advancing the index.

00:12:04.096 --> 00:12:05.356
And so to do that, we add

00:12:05.356 --> 00:12:05.986
another method.

00:12:06.926 --> 00:12:08.756
That given an index, gives you

00:12:08.756 --> 00:12:09.706
the index that marks the

00:12:09.706 --> 00:12:12.256
position after it.

00:12:12.506 --> 00:12:13.386
Once you take this step, you

00:12:13.386 --> 00:12:14.376
need a couple more things.

00:12:14.376 --> 00:12:15.806
You need a start index property,

00:12:16.126 --> 00:12:17.706
and an end index property.

00:12:18.226 --> 00:12:19.356
Because a simple count isn't

00:12:19.356 --> 00:12:20.356
going to work anymore in order

00:12:20.356 --> 00:12:21.346
to tell us that we've reached

00:12:21.346 --> 00:12:21.766
the end.

00:12:22.076 --> 00:12:24.056
Now that we're not using Ints as

00:12:24.056 --> 00:12:24.696
our index type.

00:12:26.376 --> 00:12:27.586
So let's bring those back to the

00:12:27.586 --> 00:12:28.466
collection protocol.

00:12:30.086 --> 00:12:31.606
So we've got a subscript that

00:12:31.606 --> 00:12:33.136
takes some index type to

00:12:33.136 --> 00:12:34.396
represent a position, and gives

00:12:34.396 --> 00:12:35.056
you an element there.

00:12:35.636 --> 00:12:36.956
And, we've got a way of moving

00:12:36.956 --> 00:12:37.916
that position forward.

00:12:39.076 --> 00:12:41.176
But we also need types to supply

00:12:41.176 --> 00:12:42.206
what kind of type they're going

00:12:42.206 --> 00:12:43.576
to use for their index.

00:12:43.816 --> 00:12:44.946
We do that with another

00:12:44.946 --> 00:12:45.916
associated type.

00:12:47.886 --> 00:12:49.436
Conforming types would supply

00:12:50.046 --> 00:12:50.736
the appropriate types.

00:12:50.736 --> 00:12:52.946
So an array or a data would give

00:12:53.156 --> 00:12:54.536
an Int as their index type.

00:12:55.206 --> 00:12:56.406
Whereas a dictionary would give

00:12:56.406 --> 00:12:58.096
its own custom implementation

00:12:58.176 --> 00:12:59.426
that handles its own internal

00:12:59.426 --> 00:12:59.756
logic.

00:13:04.306 --> 00:13:05.956
So let's go back to count that

00:13:05.956 --> 00:13:07.456
we dropped a minute ago in order

00:13:07.456 --> 00:13:09.106
to generalize our indexing

00:13:09.106 --> 00:13:09.386
model.

00:13:09.536 --> 00:13:10.636
It's still a really useful

00:13:10.636 --> 00:13:11.396
property to have.

00:13:11.396 --> 00:13:12.916
So we probably want to add it

00:13:12.916 --> 00:13:15.396
back as an extension on

00:13:15.396 --> 00:13:15.856
collection.

00:13:16.656 --> 00:13:18.816
Something that walks over the

00:13:18.816 --> 00:13:20.296
collection, moving the index

00:13:20.296 --> 00:13:22.246
forward, incrementing a counter

00:13:22.296 --> 00:13:23.376
that it then returns.

00:13:23.376 --> 00:13:27.426
Now, if we try and implement

00:13:27.426 --> 00:13:28.886
this, we hit another missing

00:13:28.886 --> 00:13:29.406
requirement.

00:13:30.346 --> 00:13:31.886
Since we moved off of Int to a

00:13:31.886 --> 00:13:33.746
general index type, we can no

00:13:33.746 --> 00:13:35.626
longer assume that the index

00:13:35.626 --> 00:13:36.596
type was equatable.

00:13:37.526 --> 00:13:39.286
Ints are, but arbitrary index

00:13:39.286 --> 00:13:40.306
types aren't necessarily.

00:13:40.306 --> 00:13:42.646
And, we need that in order to

00:13:42.646 --> 00:13:43.936
know that we've reached the end.

00:13:45.226 --> 00:13:47.216
Now, we could solve this in the

00:13:47.216 --> 00:13:48.846
same way that we did earlier, of

00:13:49.316 --> 00:13:50.636
constraining our extension.

00:13:50.706 --> 00:13:52.096
Say that it only works when the

00:13:52.096 --> 00:13:53.486
index type is equatable.

00:13:54.706 --> 00:13:55.976
But, that doesn't feel right.

00:13:57.456 --> 00:13:59.006
We want a protocol to be easy to

00:13:59.006 --> 00:13:59.456
use.

00:13:59.766 --> 00:14:01.556
And it's going to get really

00:14:01.556 --> 00:14:02.736
irritating, if we have to

00:14:02.736 --> 00:14:04.276
always, on every extension we

00:14:04.276 --> 00:14:06.696
write, put this constraint on

00:14:06.696 --> 00:14:06.886
there.

00:14:06.886 --> 00:14:07.666
Because we're nearly always

00:14:07.666 --> 00:14:08.396
going to need to be able to

00:14:08.396 --> 00:14:09.396
compare two indexes.

00:14:10.316 --> 00:14:11.296
Instead, it's probably better

00:14:11.296 --> 00:14:13.556
expressed as a requirement of

00:14:13.556 --> 00:14:14.196
the protocol.

00:14:14.196 --> 00:14:17.816
As a constraint on our

00:14:17.816 --> 00:14:19.016
index-associated type.

00:14:20.386 --> 00:14:21.406
Putting this constraint on the

00:14:21.406 --> 00:14:23.246
protocol means that all types

00:14:23.246 --> 00:14:24.226
that conform to the protocol

00:14:24.226 --> 00:14:26.266
need to supply an equatable type

00:14:26.266 --> 00:14:27.036
for their index.

00:14:28.626 --> 00:14:30.026
That way you don't have to

00:14:30.076 --> 00:14:31.426
specify it every time you write

00:14:31.426 --> 00:14:32.046
the extension.

00:14:33.476 --> 00:14:35.806
This is another example of

00:14:35.806 --> 00:14:36.936
negotiating the protocol

00:14:36.936 --> 00:14:37.386
contract.

00:14:38.806 --> 00:14:39.946
Users of the protocol had a

00:14:39.946 --> 00:14:41.306
requirement that they really

00:14:41.306 --> 00:14:42.406
needed to be able to compare

00:14:42.406 --> 00:14:42.926
indexes.

00:14:43.666 --> 00:14:45.876
And, conforming types, they did

00:14:45.876 --> 00:14:47.226
a check that they can reasonably

00:14:47.226 --> 00:14:48.186
accommodate that without giving

00:14:48.186 --> 00:14:49.566
up too much flexibility.

00:14:50.726 --> 00:14:52.116
In this case, they definitely

00:14:52.116 --> 00:14:52.506
can.

00:14:53.556 --> 00:14:54.976
Ints, the data, and array are

00:14:54.976 --> 00:14:56.236
using are already equatable.

00:14:56.296 --> 00:14:57.986
And, with Swift 4.2's new

00:14:57.986 --> 00:14:59.646
automatic synthesis of equatable

00:14:59.646 --> 00:15:00.316
conformance.

00:15:01.336 --> 00:15:02.536
It's easy for dictionary to make

00:15:02.536 --> 00:15:03.736
its index type equatable as

00:15:03.736 --> 00:15:03.976
well.

00:15:07.346 --> 00:15:08.106
Next, let's talk about

00:15:08.226 --> 00:15:10.246
optimizing this count operation

00:15:10.426 --> 00:15:12.256
with a customization point.

00:15:14.416 --> 00:15:16.456
So, we've written a version of

00:15:16.456 --> 00:15:19.126
count, that calculates the

00:15:19.126 --> 00:15:19.886
number of elements in the

00:15:19.886 --> 00:15:21.446
collection by walking over the

00:15:21.446 --> 00:15:22.356
entire collection.

00:15:22.356 --> 00:15:23.176
But, obviously a lot of

00:15:23.176 --> 00:15:24.846
collections can probably do that

00:15:24.846 --> 00:15:25.476
a lot faster.

00:15:25.476 --> 00:15:27.596
For example, supposing a

00:15:27.596 --> 00:15:29.736
dictionary kept internally a

00:15:29.736 --> 00:15:30.946
count of the number of elements

00:15:30.946 --> 00:15:32.516
it held, for its own purposes.

00:15:33.256 --> 00:15:34.946
If it has this information, it

00:15:34.946 --> 00:15:36.376
can just serve it up in its own

00:15:36.376 --> 00:15:37.416
implementation of count.

00:15:38.386 --> 00:15:40.396
That means that when people call

00:15:40.396 --> 00:15:41.806
count on a dictionary, they're

00:15:42.036 --> 00:15:43.676
getting fast constant time.

00:15:44.096 --> 00:15:45.416
Instead of the linear time that

00:15:45.416 --> 00:15:47.116
our original version that works

00:15:47.116 --> 00:15:48.256
with any collection takes.

00:15:49.116 --> 00:15:51.296
But, when adding optimizations

00:15:51.296 --> 00:15:52.196
like this, there's something you

00:15:52.196 --> 00:15:52.796
need to be aware of.

00:15:52.796 --> 00:15:54.386
Which is the difference between

00:15:54.386 --> 00:15:55.476
fulfilling protocol

00:15:55.476 --> 00:15:57.486
requirements, and just adding

00:15:57.486 --> 00:15:59.546
lots of overloads onto specific

00:15:59.546 --> 00:16:00.076
types.

00:16:00.856 --> 00:16:03.526
Up until now, this new version

00:16:03.526 --> 00:16:04.976
of count on dictionary is just

00:16:05.066 --> 00:16:05.686
an overload.

00:16:05.686 --> 00:16:07.626
That means that when you have a

00:16:07.626 --> 00:16:09.436
dictionary, and you know it's a

00:16:09.436 --> 00:16:09.866
dictionary.

00:16:10.526 --> 00:16:11.656
You'll get the newer, better

00:16:11.656 --> 00:16:12.446
version of count.

00:16:13.226 --> 00:16:14.326
But, what about calling it

00:16:14.326 --> 00:16:15.886
inside a generic algorithm?

00:16:17.816 --> 00:16:19.806
So supposing we wanted, for

00:16:19.806 --> 00:16:21.206
example, to write a version of

00:16:21.206 --> 00:16:22.486
the standard library's map?

00:16:23.116 --> 00:16:24.086
If you're not already familiar

00:16:24.086 --> 00:16:25.656
with it, it's a really useful

00:16:25.656 --> 00:16:28.186
operation that transforms each

00:16:28.226 --> 00:16:29.476
element in the collection.

00:16:29.526 --> 00:16:30.946
And gives it back to you as a

00:16:30.946 --> 00:16:31.526
new array.

00:16:32.596 --> 00:16:34.216
The implementation's pretty

00:16:34.216 --> 00:16:34.566
simple.

00:16:35.036 --> 00:16:36.686
It just creates a new array,

00:16:37.486 --> 00:16:38.466
moves over the collection,

00:16:39.056 --> 00:16:40.106
transforms each element.

00:16:40.386 --> 00:16:42.846
And then appends it to the

00:16:42.846 --> 00:16:42.913
array.

00:16:42.913 --> 00:16:44.566
Now, as you append elements to

00:16:44.566 --> 00:16:46.606
an array like this, the array

00:16:46.606 --> 00:16:47.846
automatically grows.

00:16:48.626 --> 00:16:50.466
And, as it grows, it needs

00:16:50.466 --> 00:16:52.196
sometimes to re-allocate its

00:16:52.196 --> 00:16:53.116
internal storage.

00:16:53.216 --> 00:16:54.456
In order to make more room to

00:16:54.456 --> 00:16:55.586
accommodate the new elements.

00:16:56.256 --> 00:16:57.586
In a loop like this, it might

00:16:57.586 --> 00:16:59.276
have to do that multiple times

00:16:59.276 --> 00:17:00.356
over, depending on how big it

00:17:00.356 --> 00:17:00.606
gets.

00:17:00.606 --> 00:17:02.696
And, doing that takes time.

00:17:02.926 --> 00:17:04.715
Allocating memory can be fairly

00:17:04.715 --> 00:17:05.256
expensive.

00:17:05.346 --> 00:17:07.996
There is a nice optimization

00:17:07.996 --> 00:17:09.106
trick we can do with this

00:17:09.106 --> 00:17:09.766
implementation.

00:17:10.606 --> 00:17:12.336
We already know exactly how big

00:17:12.636 --> 00:17:13.986
the final array is going to be.

00:17:14.016 --> 00:17:15.396
It's going to be exactly the

00:17:15.396 --> 00:17:16.945
same size as our original

00:17:16.945 --> 00:17:17.425
collection.

00:17:18.445 --> 00:17:20.836
So we could reserve exactly the

00:17:20.836 --> 00:17:22.766
right amount of space in the

00:17:22.766 --> 00:17:24.486
array up front, before we start

00:17:24.486 --> 00:17:26.435
appending to it, which is a nice

00:17:26.435 --> 00:17:26.816
speed-up.

00:17:26.906 --> 00:17:29.106
And to do this, we're calling

00:17:29.196 --> 00:17:29.576
count.

00:17:30.726 --> 00:17:32.466
But, we're calling count here,

00:17:32.466 --> 00:17:34.226
in what's referred to as a

00:17:34.226 --> 00:17:35.466
generic context.

00:17:35.886 --> 00:17:37.976
That is, a context where the

00:17:37.976 --> 00:17:39.266
collection type is completely

00:17:39.266 --> 00:17:40.626
generic, not specific.

00:17:40.626 --> 00:17:41.816
It could be an array, or a

00:17:41.816 --> 00:17:43.296
dictionary, or a link list, or

00:17:43.296 --> 00:17:43.686
anything.

00:17:44.486 --> 00:17:46.286
So, we can't know that it

00:17:46.286 --> 00:17:48.156
necessarily has a better

00:17:48.156 --> 00:17:49.396
implementation of count

00:17:49.396 --> 00:17:50.036
available to it.

00:17:50.236 --> 00:17:51.646
When the compiler compiles this

00:17:51.646 --> 00:17:51.976
code.

00:17:52.726 --> 00:17:55.326
And so, in this case, the

00:17:55.326 --> 00:17:56.376
version of count that's going to

00:17:56.376 --> 00:17:57.966
be called is actually the

00:17:57.966 --> 00:17:59.046
general version of count.

00:17:59.246 --> 00:18:01.086
That works on any collection and

00:18:01.086 --> 00:18:02.256
iterates over the entire

00:18:02.256 --> 00:18:02.766
collection.

00:18:03.466 --> 00:18:04.536
If you called map on a

00:18:04.536 --> 00:18:06.496
dictionary, it wouldn't call the

00:18:06.496 --> 00:18:07.436
better version of count that

00:18:07.436 --> 00:18:08.606
we've just written yet.

00:18:11.156 --> 00:18:13.316
In order for customized method

00:18:13.316 --> 00:18:15.386
or property like this to be

00:18:15.386 --> 00:18:17.526
called in a gen-- in a generic

00:18:17.526 --> 00:18:18.066
context.

00:18:18.476 --> 00:18:19.886
It needs to be declared as a

00:18:19.886 --> 00:18:21.446
requirement on the protocol

00:18:21.446 --> 00:18:22.026
itself.

00:18:22.516 --> 00:18:24.256
We've established that there's

00:18:24.256 --> 00:18:26.166
definitely a way in which

00:18:26.166 --> 00:18:27.576
certain collections could

00:18:27.576 --> 00:18:28.826
provide an optimized version of

00:18:28.826 --> 00:18:30.806
count, so it makes sense to add

00:18:30.806 --> 00:18:32.566
it as a requirement on the

00:18:32.566 --> 00:18:33.086
protocol.

00:18:34.446 --> 00:18:36.396
Now, even though we've made it a

00:18:36.396 --> 00:18:40.036
requirement to implement it, all

00:18:40.036 --> 00:18:41.346
collections don't have to

00:18:41.346 --> 00:18:42.066
provide their own

00:18:42.066 --> 00:18:42.716
implementation.

00:18:42.926 --> 00:18:44.086
Because we've already provided

00:18:44.086 --> 00:18:45.976
one via our extension that will

00:18:45.976 --> 00:18:47.076
work on any collection.

00:18:48.306 --> 00:18:49.776
Adding a requirement to the

00:18:49.776 --> 00:18:51.856
protocol, and alongside it

00:18:51.856 --> 00:18:53.516
adding a default implementation

00:18:53.736 --> 00:18:55.576
via an extension is what we

00:18:55.576 --> 00:18:57.706
refer to as a customization

00:18:57.706 --> 00:18:57.996
point.

00:18:58.666 --> 00:19:01.456
With a customization point, the

00:19:01.456 --> 00:19:03.126
compiler can know that there's

00:19:03.126 --> 00:19:04.286
potentially a better

00:19:04.286 --> 00:19:06.026
implementation of a method or

00:19:06.026 --> 00:19:07.036
property available to it.

00:19:07.296 --> 00:19:09.956
And so, in a generic context, it

00:19:09.956 --> 00:19:11.896
dynamically dispatches to that

00:19:11.896 --> 00:19:13.416
implementation through the

00:19:13.416 --> 00:19:13.926
protocol.

00:19:15.336 --> 00:19:17.406
So now, if you call map on a

00:19:17.406 --> 00:19:18.856
dictionary, even though it's a

00:19:18.856 --> 00:19:19.876
completely generic function.

00:19:20.596 --> 00:19:21.406
You will get the better

00:19:21.406 --> 00:19:22.456
implementation of count.

00:19:24.596 --> 00:19:26.086
Adding customization points like

00:19:26.086 --> 00:19:27.736
this, alongside default

00:19:27.736 --> 00:19:28.756
implementations through

00:19:28.756 --> 00:19:29.286
extensions.

00:19:30.376 --> 00:19:31.516
Is a really powerful way of

00:19:31.516 --> 00:19:32.906
getting the same kind of benefit

00:19:32.976 --> 00:19:34.396
that you can also get with

00:19:34.396 --> 00:19:35.966
classes, implementation

00:19:35.966 --> 00:19:37.086
inheritance, and method

00:19:37.086 --> 00:19:37.626
overwriting.

00:19:38.366 --> 00:19:39.676
But, this technique works on

00:19:39.676 --> 00:19:41.916
structs and enums, as well as

00:19:41.916 --> 00:19:42.326
classes.

00:19:45.356 --> 00:19:47.386
Now, not every method can be

00:19:47.386 --> 00:19:48.476
optimized like this.

00:19:49.026 --> 00:19:51.016
And, customization points have a

00:19:51.016 --> 00:19:53.146
small but non-zero impact on

00:19:53.146 --> 00:19:55.006
your binary size, your compiler

00:19:55.056 --> 00:19:55.996
runtime performance.

00:19:56.406 --> 00:19:57.656
So, it only makes sense to add

00:19:57.656 --> 00:19:59.506
customization points when

00:19:59.506 --> 00:20:00.036
there's definitely an

00:20:00.036 --> 00:20:01.306
opportunity for customization.

00:20:02.256 --> 00:20:03.596
For example, in the map

00:20:03.596 --> 00:20:05.006
operation that we just wrote.

00:20:05.446 --> 00:20:06.826
There's no reasonable way in

00:20:06.826 --> 00:20:08.026
which any different kind of

00:20:08.026 --> 00:20:09.496
collection could actually

00:20:09.496 --> 00:20:11.436
provide a better implementation.

00:20:12.046 --> 00:20:13.216
And so, it doesn't make sense to

00:20:13.216 --> 00:20:14.636
add it as a customization point.

00:20:14.996 --> 00:20:16.376
It can just stay as an

00:20:16.376 --> 00:20:16.926
extension.

00:20:18.396 --> 00:20:19.756
So, we've created this

00:20:19.756 --> 00:20:20.966
collection type, and it's

00:20:20.966 --> 00:20:21.976
actually pretty fully-featured

00:20:21.976 --> 00:20:22.166
now.

00:20:22.166 --> 00:20:23.016
It has lots of different

00:20:23.696 --> 00:20:24.926
conforming types possible.

00:20:25.236 --> 00:20:26.456
And various different useful

00:20:26.456 --> 00:20:28.356
algorithms you can write for it.

00:20:28.616 --> 00:20:30.016
But, sometimes you need more

00:20:30.016 --> 00:20:31.696
than just a single protocol in

00:20:31.696 --> 00:20:33.116
order to categorize your family

00:20:33.116 --> 00:20:33.696
of types.

00:20:34.646 --> 00:20:36.356
You need protocol inheritance.

00:20:36.656 --> 00:20:37.726
And, to talk to you more about

00:20:37.726 --> 00:20:38.936
that, here's Doug.

00:20:40.516 --> 00:20:45.586
[ Applause ]

00:20:46.086 --> 00:20:46.706
>> Thank you, Ben.

00:20:47.936 --> 00:20:49.846
So, protocol inheritance has

00:20:49.896 --> 00:20:50.976
been around since the beginning

00:20:50.976 --> 00:20:51.396
of Swift.

00:20:52.336 --> 00:20:53.766
And, to think about where we

00:20:53.766 --> 00:20:54.956
need protocol inheritance.

00:20:55.026 --> 00:20:56.446
Let's go look at this collection

00:20:56.446 --> 00:20:57.206
protocol that we've been

00:20:57.206 --> 00:20:57.596
building.

00:20:58.276 --> 00:20:59.126
It's a nice protocol.

00:20:59.126 --> 00:20:59.906
It's well-designed.

00:21:00.566 --> 00:21:02.136
It describes a set of conforming

00:21:02.136 --> 00:21:03.966
types, and gives you the ability

00:21:03.966 --> 00:21:05.136
to write interesting generic

00:21:05.136 --> 00:21:05.996
algorithms on them.

00:21:06.726 --> 00:21:07.756
But, we don't have to reach very

00:21:07.756 --> 00:21:09.316
far to find other

00:21:09.316 --> 00:21:10.906
collection-like algorithms that

00:21:10.906 --> 00:21:12.896
we cannot implement in terms of

00:21:12.896 --> 00:21:14.186
the collection protocol thus

00:21:14.186 --> 00:21:14.556
far.

00:21:15.226 --> 00:21:16.466
For example, if we want to find

00:21:16.466 --> 00:21:18.416
the index of the last element in

00:21:18.416 --> 00:21:20.026
a collection, that matches some

00:21:20.026 --> 00:21:20.626
predicate.

00:21:20.826 --> 00:21:22.136
The best way to do that would be

00:21:22.136 --> 00:21:23.736
to start at the end, and walk

00:21:23.786 --> 00:21:24.426
backwards.

00:21:25.096 --> 00:21:26.086
Collection protocol doesn't let

00:21:26.086 --> 00:21:26.636
us do that.

00:21:27.916 --> 00:21:29.256
Or say we want to build a

00:21:29.256 --> 00:21:30.616
shuffle operation to randomly

00:21:30.616 --> 00:21:31.716
shuffle around the elements in a

00:21:31.716 --> 00:21:32.246
collection.

00:21:32.856 --> 00:21:34.146
Well, that requires mutation,

00:21:34.146 --> 00:21:35.316
and collection doesn't do that.

00:21:35.716 --> 00:21:37.016
Now it's not that the collection

00:21:37.016 --> 00:21:38.426
protocol is wrong.

00:21:39.876 --> 00:21:41.206
But it's that we need something

00:21:41.206 --> 00:21:42.496
more to describe these

00:21:42.496 --> 00:21:44.246
additional generic algorithms,

00:21:44.636 --> 00:21:45.866
and that is the point of

00:21:45.866 --> 00:21:46.956
protocol inheritance.

00:21:47.376 --> 00:21:47.806
So, here the

00:21:47.806 --> 00:21:49.816
bidirectionalCollection protocol

00:21:50.056 --> 00:21:51.856
inherits from, or is a

00:21:52.426 --> 00:21:52.876
collection.

00:21:53.726 --> 00:21:55.026
What that means is that any type

00:21:55.066 --> 00:21:56.236
that conforms to the

00:21:56.236 --> 00:21:57.866
bidirectionalCollection protocol

00:21:58.376 --> 00:21:59.816
also conforms to collection, and

00:21:59.816 --> 00:22:00.776
you can use those collection

00:22:00.776 --> 00:22:01.426
algorithms.

00:22:02.186 --> 00:22:03.596
But bidirectionalCollection adds

00:22:03.596 --> 00:22:04.976
this additional requirement, of

00:22:05.016 --> 00:22:07.226
being able to step backwards in

00:22:07.226 --> 00:22:07.836
the collection.

00:22:08.276 --> 00:22:09.866
An important thing to note is

00:22:10.006 --> 00:22:11.216
not every collection can

00:22:11.216 --> 00:22:12.386
actually implement this

00:22:12.436 --> 00:22:13.636
particular requirement.

00:22:13.976 --> 00:22:15.476
Think of a singlyLinkedList,

00:22:15.476 --> 00:22:16.936
where you only have these

00:22:17.496 --> 00:22:18.826
pointers hopping from one

00:22:18.826 --> 00:22:19.856
location to the next.

00:22:20.156 --> 00:22:21.486
There's no efficient way to walk

00:22:21.486 --> 00:22:22.786
backward through this sequence,

00:22:22.926 --> 00:22:24.346
so it cannot be a

00:22:24.346 --> 00:22:25.406
bidirectionalCollection.

00:22:25.776 --> 00:22:26.566
So, once we've introduced

00:22:26.566 --> 00:22:28.046
inheritance, you've restricted

00:22:28.046 --> 00:22:29.356
the set of conforming types.

00:22:29.916 --> 00:22:32.096
But you've allowed yourself to

00:22:32.306 --> 00:22:33.346
implement more interesting

00:22:33.346 --> 00:22:34.006
algorithms.

00:22:34.246 --> 00:22:35.456
So, here's the code behind this

00:22:35.566 --> 00:22:37.136
last index where operation.

00:22:37.356 --> 00:22:37.976
It's fairly simple.

00:22:37.976 --> 00:22:39.876
We're just walking backwards

00:22:39.876 --> 00:22:41.496
through the collection, using

00:22:41.496 --> 00:22:43.276
this new requirement from the

00:22:43.276 --> 00:22:44.166
bidirectionalCollection

00:22:44.166 --> 00:22:44.576
protocol.

00:22:46.606 --> 00:22:47.996
Let's look at a more interesting

00:22:47.996 --> 00:22:48.516
algorithm.

00:22:48.826 --> 00:22:50.346
So here's a shuffle operation.

00:22:50.516 --> 00:22:51.756
So, it was introduced for, for

00:22:51.756 --> 00:22:53.526
collections in Swift 4.2.

00:22:53.666 --> 00:22:54.506
You don't have to implement it

00:22:54.506 --> 00:22:55.646
yourself, but we're going to

00:22:55.646 --> 00:22:56.816
look at the algorithm itself to

00:22:56.816 --> 00:22:58.306
see what kinds of requirements

00:22:58.306 --> 00:23:00.136
it introduces to figure out how

00:23:00.136 --> 00:23:01.566
to categorize those into

00:23:01.566 --> 00:23:02.656
protocols meaningfully.

00:23:03.396 --> 00:23:04.446
So the Fisher-Yates shuffle

00:23:04.446 --> 00:23:05.276
algorithm's a pretty old

00:23:05.276 --> 00:23:05.706
algorithm.

00:23:06.186 --> 00:23:07.216
It's also fairly simple.

00:23:07.546 --> 00:23:09.256
You start with an index to the

00:23:09.256 --> 00:23:10.666
first element in the collection.

00:23:11.586 --> 00:23:13.836
And then, you select randomly

00:23:14.186 --> 00:23:15.376
some other element in the

00:23:15.376 --> 00:23:17.196
collection, and swap those two.

00:23:18.556 --> 00:23:20.666
In the next iteration, you move

00:23:21.016 --> 00:23:22.596
the left index forward one.

00:23:23.476 --> 00:23:24.716
Randomly select between there

00:23:24.716 --> 00:23:25.996
and the end, swap those

00:23:25.996 --> 00:23:26.556
elements.

00:23:26.916 --> 00:23:28.196
And so, the algorithm is pretty

00:23:28.196 --> 00:23:28.466
simple.

00:23:28.466 --> 00:23:29.886
It's just this linear march

00:23:30.146 --> 00:23:32.446
through the collection, randomly

00:23:32.446 --> 00:23:33.636
selecting another element to

00:23:33.636 --> 00:23:34.196
swap with.

00:23:34.576 --> 00:23:36.206
And, at the end of this, you end

00:23:36.206 --> 00:23:37.516
up with a nicely shuffled

00:23:37.886 --> 00:23:38.406
collection.

00:23:39.326 --> 00:23:40.676
So, we can actually look at the

00:23:40.676 --> 00:23:41.116
code here.

00:23:41.306 --> 00:23:42.446
It's a little bit involved.

00:23:42.446 --> 00:23:43.236
Don't worry about that.

00:23:43.626 --> 00:23:44.996
And, we're going to implement it

00:23:44.996 --> 00:23:46.366
on some kind of collection.

00:23:46.896 --> 00:23:47.646
So, we'll look at the core

00:23:47.646 --> 00:23:48.576
operations in here.

00:23:48.906 --> 00:23:49.966
So, first we need to be able to

00:23:49.966 --> 00:23:51.896
grab a random number between

00:23:51.896 --> 00:23:53.156
where we are in the collection

00:23:53.156 --> 00:23:54.206
and the end of the collection,

00:23:54.396 --> 00:23:55.626
using this, this random

00:23:55.626 --> 00:23:56.086
facility.

00:23:56.446 --> 00:23:57.206
But, that's an integer.

00:23:57.366 --> 00:23:58.586
And what we need is an index

00:23:58.586 --> 00:23:59.316
into the collection.

00:23:59.316 --> 00:24:00.226
We know those are different.

00:24:00.526 --> 00:24:02.066
So we need some operation.

00:24:02.116 --> 00:24:03.706
Let's call it index offsetBy.

00:24:04.506 --> 00:24:06.106
To jump from the start index

00:24:06.516 --> 00:24:07.606
quickly over to whatever

00:24:07.606 --> 00:24:08.816
position we've selected.

00:24:10.106 --> 00:24:11.926
The other operation we need is

00:24:11.926 --> 00:24:13.276
the ability to swap two

00:24:13.276 --> 00:24:13.816
elements.

00:24:14.916 --> 00:24:17.116
Great. We have two operations

00:24:17.116 --> 00:24:18.086
that we need to add to the

00:24:18.086 --> 00:24:19.596
notion of a collection to be

00:24:19.596 --> 00:24:21.026
able to implement shuffle.

00:24:21.336 --> 00:24:22.456
Therefore, we have a new

00:24:22.456 --> 00:24:23.686
shuffleCollection protocol.

00:24:25.976 --> 00:24:27.606
Please don't do this.

00:24:28.096 --> 00:24:29.396
So this is an anti-pattern that

00:24:29.396 --> 00:24:29.836
we see.

00:24:30.466 --> 00:24:32.106
And the anti-pattern here is we

00:24:32.106 --> 00:24:33.096
had one algorithm.

00:24:33.276 --> 00:24:34.956
We found its requirements, and

00:24:34.956 --> 00:24:36.236
then we packaged it up into a

00:24:36.236 --> 00:24:38.366
protocol that is just that one--

00:24:39.316 --> 00:24:40.296
just describes that one

00:24:40.296 --> 00:24:40.856
algorithm.

00:24:41.116 --> 00:24:42.556
If you do this, you have lots

00:24:42.626 --> 00:24:44.236
and lots and lots of protocols

00:24:44.236 --> 00:24:45.756
around that don't have any

00:24:45.756 --> 00:24:46.526
interesting meaning.

00:24:46.526 --> 00:24:47.656
You're not learning anything

00:24:47.656 --> 00:24:48.526
from those protocols.

00:24:49.026 --> 00:24:51.486
So what you should do is notice

00:24:51.486 --> 00:24:52.956
that we actually have distinct

00:24:52.956 --> 00:24:53.956
capabilities here.

00:24:54.436 --> 00:24:55.536
So shuffle is using random

00:24:55.536 --> 00:24:57.496
access, and it's using mutation.

00:24:57.956 --> 00:24:58.806
But, these are, these are

00:24:58.806 --> 00:25:00.076
separate, and we can categorize

00:25:00.076 --> 00:25:01.546
them in separate protocols.

00:25:02.056 --> 00:25:02.946
So, for example, the

00:25:02.946 --> 00:25:04.576
randomAccessCollection protocol

00:25:04.976 --> 00:25:06.686
is something where it allows us

00:25:06.686 --> 00:25:08.516
to jump around the collection,

00:25:08.596 --> 00:25:09.756
moving indices quickly.

00:25:10.466 --> 00:25:11.476
And there are types like

00:25:11.476 --> 00:25:12.886
unsafeBufferPointer that can

00:25:12.886 --> 00:25:13.986
give you random access.

00:25:14.326 --> 00:25:16.616
But, do not allow any mutation.

00:25:16.736 --> 00:25:18.096
That's a separate capability.

00:25:19.036 --> 00:25:19.826
So, we also have the

00:25:19.826 --> 00:25:21.436
mutableCollection protocol here.

00:25:22.366 --> 00:25:23.536
And, we can think of types here

00:25:23.536 --> 00:25:24.976
that allow mutation, but not

00:25:24.976 --> 00:25:25.896
random access, like the

00:25:25.896 --> 00:25:27.186
singlyLinkedList that we talked

00:25:27.186 --> 00:25:27.826
about earlier.

00:25:28.556 --> 00:25:29.446
Now, you notice that we've

00:25:29.446 --> 00:25:30.686
essentially split the

00:25:30.686 --> 00:25:31.946
inheritance hierarchy here.

00:25:33.246 --> 00:25:34.616
We've got the access side for

00:25:34.616 --> 00:25:35.846
random access, bidirectional,

00:25:35.846 --> 00:25:36.356
and so on.

00:25:36.616 --> 00:25:37.446
And then, we've got this

00:25:37.446 --> 00:25:38.266
mutation side.

00:25:38.746 --> 00:25:39.816
That's perfectly fine, because

00:25:39.816 --> 00:25:41.396
clients themselves can compose

00:25:41.396 --> 00:25:43.736
multiple protocols to implement

00:25:43.736 --> 00:25:44.776
whatever generic algorithm

00:25:44.776 --> 00:25:45.246
they're doing.

00:25:45.666 --> 00:25:46.876
So, we go back to our shuffle

00:25:46.876 --> 00:25:47.406
algorithm.

00:25:47.466 --> 00:25:49.466
And it can be written as an

00:25:49.466 --> 00:25:50.396
extension on

00:25:50.396 --> 00:25:52.056
randomAccessCollection, with a

00:25:52.056 --> 00:25:52.666
self-type.

00:25:52.666 --> 00:25:53.756
So this is the type that

00:25:53.756 --> 00:25:54.246
conforms to

00:25:54.246 --> 00:25:56.096
randomAccessCollection also

00:25:56.096 --> 00:25:56.756
conforms to the

00:25:56.756 --> 00:25:58.096
mutableCollection protocol.

00:25:58.536 --> 00:25:59.516
And now, we've pulled together

00:25:59.516 --> 00:26:00.556
the capabilities of both of

00:26:00.556 --> 00:26:00.886
these.

00:26:02.416 --> 00:26:04.556
Now, when you have a bunch of

00:26:04.556 --> 00:26:06.216
conforming types, and a bunch of

00:26:06.216 --> 00:26:07.986
generic algorithms, you tend to

00:26:07.986 --> 00:26:09.806
get protocol hierarchies

00:26:09.806 --> 00:26:10.196
forming.

00:26:10.666 --> 00:26:12.156
Now, these hierarchies, they

00:26:12.156 --> 00:26:13.046
shouldn't be too big.

00:26:13.176 --> 00:26:14.026
They should not be too

00:26:14.026 --> 00:26:14.956
fine-grained.

00:26:15.926 --> 00:26:17.046
Because you really want a small

00:26:17.046 --> 00:26:18.066
number of protocols that really

00:26:18.066 --> 00:26:19.776
describe the kinds of types that

00:26:19.776 --> 00:26:21.426
show up in the domain, right?

00:26:21.876 --> 00:26:23.766
And now, there's things, things

00:26:23.766 --> 00:26:25.016
that you notice when you do

00:26:25.016 --> 00:26:25.846
build these protocol

00:26:25.846 --> 00:26:26.446
hierarchies.

00:26:26.626 --> 00:26:27.826
So, as you go from the bottom of

00:26:27.826 --> 00:26:29.646
the hierarchy to the top, you're

00:26:29.646 --> 00:26:30.956
going to protocols that have

00:26:30.956 --> 00:26:32.176
fewer requirements.

00:26:32.306 --> 00:26:33.576
And therefore, there are more

00:26:33.576 --> 00:26:35.306
conforming types that can

00:26:35.306 --> 00:26:36.626
implement those requirements.

00:26:37.566 --> 00:26:38.336
Now, on the other hand, as

00:26:38.336 --> 00:26:39.416
you're moving down the

00:26:39.466 --> 00:26:41.666
hierarchy, and combining

00:26:41.666 --> 00:26:42.646
different protocols from the

00:26:42.696 --> 00:26:43.176
hierarchy.

00:26:43.626 --> 00:26:44.746
You get to implement more

00:26:44.746 --> 00:26:46.076
intricate, more specialized

00:26:46.076 --> 00:26:47.676
algorithms that require more

00:26:47.676 --> 00:26:48.686
advanced capabilities.

00:26:48.896 --> 00:26:50.006
But naturally work with fewer

00:26:50.006 --> 00:26:50.836
conforming types.

00:26:54.556 --> 00:26:56.306
Okay. So let's talk about

00:26:56.306 --> 00:26:57.246
conditional conformance.

00:26:57.306 --> 00:26:58.376
This is, of course, a newer

00:26:58.376 --> 00:27:00.396
feature in, in Swift.

00:27:00.646 --> 00:27:02.216
And, let's start by looking at

00:27:02.216 --> 00:27:02.946
slices again.

00:27:03.516 --> 00:27:04.796
So for any collection that you

00:27:04.796 --> 00:27:07.276
have, you can form a slice of

00:27:07.276 --> 00:27:09.136
that collection by subscripting

00:27:09.356 --> 00:27:12.236
with a particular range of

00:27:12.236 --> 00:27:12.856
indices.

00:27:13.326 --> 00:27:14.696
And, that slice is essentially a

00:27:14.696 --> 00:27:16.256
view into some part of the

00:27:16.256 --> 00:27:16.796
collection.

00:27:17.986 --> 00:27:20.366
Now these are default type that

00:27:20.366 --> 00:27:21.366
you get from slicing a

00:27:21.366 --> 00:27:23.696
collection, is called slice.

00:27:24.486 --> 00:27:26.146
And slice is a generic adaptor

00:27:26.146 --> 00:27:26.376
type.

00:27:27.366 --> 00:27:30.066
So it is parameterized on a base

00:27:30.106 --> 00:27:32.016
collection type, and it is

00:27:32.016 --> 00:27:33.216
itself a collection.

00:27:33.936 --> 00:27:36.466
So our expectation on a slice is

00:27:36.466 --> 00:27:37.636
that you can do anything to a

00:27:37.636 --> 00:27:38.676
slice that you can do to the

00:27:38.676 --> 00:27:39.826
underlying collection.

00:27:40.146 --> 00:27:41.266
It's a reasonable thing to want.

00:27:41.966 --> 00:27:43.636
And so, certainly we can go and

00:27:43.636 --> 00:27:44.496
use the forward search

00:27:44.496 --> 00:27:46.376
operations like indexwhere, to

00:27:46.376 --> 00:27:47.406
go find something matching a

00:27:47.406 --> 00:27:47.786
predicate.

00:27:47.786 --> 00:27:49.226
And that works on the collection

00:27:49.326 --> 00:27:50.226
and any slice of that

00:27:50.226 --> 00:27:50.696
collection.

00:27:51.576 --> 00:27:52.676
So, we'd like to do the same

00:27:52.676 --> 00:27:54.506
thing with backwards search, but

00:27:54.506 --> 00:27:55.456
here we're going to run into a

00:27:55.456 --> 00:27:55.886
problem.

00:27:55.886 --> 00:27:57.096
So even if the buffer is a

00:27:57.276 --> 00:27:59.756
bidirectionalCollection, nothing

00:27:59.756 --> 00:28:00.946
has said that the slice is a

00:28:00.946 --> 00:28:01.976
bidirectionalCollection.

00:28:02.636 --> 00:28:05.966
We can fix that.

00:28:05.966 --> 00:28:07.606
Let's extend slice to make it

00:28:07.606 --> 00:28:08.156
conform to the

00:28:08.156 --> 00:28:09.156
bidirectionalCollection

00:28:09.156 --> 00:28:09.596
protocol.

00:28:10.536 --> 00:28:11.676
We need to implement this index

00:28:11.676 --> 00:28:13.026
before operation, which we can

00:28:13.026 --> 00:28:14.486
implement in terms of the

00:28:14.486 --> 00:28:16.176
underlying base collection.

00:28:17.146 --> 00:28:18.086
Except the compiler's going to

00:28:18.086 --> 00:28:18.666
complain here.

00:28:19.736 --> 00:28:21.016
The only thing we knew about

00:28:21.016 --> 00:28:22.676
that base collection is that

00:28:22.676 --> 00:28:23.516
it's a collection.

00:28:23.666 --> 00:28:25.366
It doesn't have an index before

00:28:25.366 --> 00:28:26.286
operation on it.

00:28:27.806 --> 00:28:28.966
We know how to fix this.

00:28:29.516 --> 00:28:31.176
All we need to do is introduce a

00:28:31.176 --> 00:28:32.646
requirement into this extension

00:28:32.646 --> 00:28:33.766
to say that well, base needs to

00:28:33.766 --> 00:28:35.016
be a bidirectionalCollection.

00:28:35.786 --> 00:28:37.186
This is conditional conformance.

00:28:38.146 --> 00:28:40.216
All it is, is extensions that

00:28:40.216 --> 00:28:41.836
declare conformance to a

00:28:41.836 --> 00:28:42.366
protocol.

00:28:42.796 --> 00:28:44.016
And then the constraints under

00:28:44.016 --> 00:28:45.416
which that conformance actually

00:28:45.416 --> 00:28:46.136
makes sense.

00:28:46.966 --> 00:28:48.006
And the wonderful thing about

00:28:48.006 --> 00:28:49.146
conditional conformance, is it

00:28:49.146 --> 00:28:50.326
stacks nicely when you have

00:28:50.326 --> 00:28:51.516
these protocol hierarchies.

00:28:51.836 --> 00:28:54.146
So we can also state that slice

00:28:54.146 --> 00:28:55.656
is a randomAccessCollection.

00:28:56.026 --> 00:28:58.056
When its underlying base type is

00:28:58.056 --> 00:28:59.286
a randomAccessCollection.

00:29:00.486 --> 00:29:01.456
Now, notice that I've written

00:29:01.556 --> 00:29:02.806
two different extensions here.

00:29:03.806 --> 00:29:05.086
Now, it's generally good Swift

00:29:05.086 --> 00:29:05.546
style.

00:29:06.066 --> 00:29:07.026
Write an extension, have it

00:29:07.026 --> 00:29:08.616
conform to one protocol, so you

00:29:08.616 --> 00:29:10.066
know what that extension is for,

00:29:10.066 --> 00:29:10.966
you know its meaning.

00:29:11.466 --> 00:29:13.546
It's particularly important with

00:29:13.796 --> 00:29:15.106
conditional requirements,

00:29:15.456 --> 00:29:17.526
conformances, because you have

00:29:17.586 --> 00:29:19.006
different requirements on these

00:29:19.006 --> 00:29:19.796
extensions.

00:29:20.376 --> 00:29:22.036
And, this allows for

00:29:22.036 --> 00:29:22.836
composability.

00:29:22.896 --> 00:29:24.436
Whatever the underlying base

00:29:24.466 --> 00:29:26.316
collection can do, the slice

00:29:26.316 --> 00:29:27.326
type can also do.

00:29:28.796 --> 00:29:31.346
So let's look at another

00:29:31.346 --> 00:29:32.326
application of conditional

00:29:32.326 --> 00:29:33.556
conformance, also in the

00:29:33.556 --> 00:29:34.866
standard library, and these are

00:29:34.866 --> 00:29:35.366
ranges.

00:29:35.526 --> 00:29:36.646
So, ranges have been around

00:29:36.856 --> 00:29:37.666
forever in Swift.

00:29:37.666 --> 00:29:38.806
And, you can form a range with,

00:29:38.896 --> 00:29:40.156
for example, these dot-dot less

00:29:40.156 --> 00:29:40.936
than operations.

00:29:41.426 --> 00:29:43.106
And so you can form ranges of

00:29:43.106 --> 00:29:44.506
doubles, you can form ranges of

00:29:44.506 --> 00:29:45.346
integers.

00:29:45.946 --> 00:29:47.086
But some ranges are more

00:29:47.086 --> 00:29:48.156
powerful than others.

00:29:48.416 --> 00:29:49.786
So, you can iterate over the

00:29:49.786 --> 00:29:52.316
elements in a range of integers.

00:29:52.926 --> 00:29:53.876
Well, why can you do that?

00:29:53.876 --> 00:29:55.066
It was because an intRange

00:29:55.576 --> 00:29:56.806
conforms to collection.

00:29:58.266 --> 00:29:59.276
Now, if you're actually look at

00:29:59.276 --> 00:30:00.606
the type, it's reduced by that

00:30:00.646 --> 00:30:01.996
dot-dot less-than operator.

00:30:02.346 --> 00:30:04.306
It is aptly named the range

00:30:04.306 --> 00:30:04.556
type.

00:30:05.346 --> 00:30:07.096
Again, it's generic over the

00:30:07.096 --> 00:30:08.126
underlying bound type.

00:30:08.126 --> 00:30:09.256
So in this case, we have a range

00:30:09.256 --> 00:30:11.126
of doubles, and it merely stores

00:30:11.126 --> 00:30:12.456
the lower and upper bounds.

00:30:12.646 --> 00:30:13.456
That's fairly simple.

00:30:14.286 --> 00:30:16.806
But, prior to Swift 4.2, you

00:30:16.806 --> 00:30:18.816
would get from an integer range,

00:30:18.876 --> 00:30:20.036
an actually different type.

00:30:20.466 --> 00:30:22.176
This is the countableRange type.

00:30:23.126 --> 00:30:24.466
Now, notice it's structurally

00:30:24.466 --> 00:30:26.056
the same as the range type.

00:30:26.056 --> 00:30:27.236
It has one type parameter.

00:30:27.236 --> 00:30:28.696
It has lower and upperBound.

00:30:29.246 --> 00:30:31.126
But it adds a couple additional

00:30:31.126 --> 00:30:32.686
requirements onto that bound

00:30:32.686 --> 00:30:32.886
type.

00:30:33.286 --> 00:30:34.876
That the bound be stridable,

00:30:35.286 --> 00:30:35.416
right?

00:30:35.416 --> 00:30:36.446
Meaning you can walk through and

00:30:36.446 --> 00:30:37.436
enumerate all the elements.

00:30:37.866 --> 00:30:39.286
Now that's the ability you need

00:30:39.446 --> 00:30:40.056
so that you can make

00:30:40.056 --> 00:30:41.316
countableRange conform to

00:30:41.316 --> 00:30:42.456
randomAccessCollection.

00:30:43.676 --> 00:30:45.136
That enables the forEach, the

00:30:45.136 --> 00:30:46.246
forEach iteration loop, and

00:30:46.246 --> 00:30:46.826
other things.

00:30:48.076 --> 00:30:48.706
But with conditional

00:30:48.706 --> 00:30:49.986
conformance, of course, we can

00:30:49.986 --> 00:30:50.736
do better.

00:30:51.516 --> 00:30:53.836
So let's turn the basic range

00:30:53.836 --> 00:30:57.306
type into a collection, when the

00:30:57.306 --> 00:30:59.086
bound type conforms this-- has

00:30:59.086 --> 00:31:00.586
these extra stridable

00:31:00.586 --> 00:31:01.376
requirements on it.

00:31:01.736 --> 00:31:02.736
It's a simple application of

00:31:02.736 --> 00:31:03.706
conditional conformance.

00:31:04.166 --> 00:31:05.746
But it makes the range type more

00:31:05.816 --> 00:31:08.186
powerful when used with better

00:31:08.236 --> 00:31:09.266
type parameters.

00:31:10.806 --> 00:31:13.206
Now, notice that I'm just

00:31:13.206 --> 00:31:13.696
conforming to

00:31:13.696 --> 00:31:14.876
randomAccessCollection.

00:31:15.496 --> 00:31:17.686
I have not actually mentioned

00:31:17.746 --> 00:31:18.236
collection or

00:31:18.236 --> 00:31:19.326
bidirectionalCollection.

00:31:20.366 --> 00:31:21.876
With unconditional performances,

00:31:21.876 --> 00:31:22.546
this is okay.

00:31:23.036 --> 00:31:24.356
Declaring conformance to

00:31:24.356 --> 00:31:26.446
randomAccessCollection implies

00:31:26.446 --> 00:31:28.276
conformances to any protocols

00:31:28.276 --> 00:31:29.526
that it inherits.

00:31:29.586 --> 00:31:30.286
In this case,

00:31:30.366 --> 00:31:31.416
bidirectionalCollection and

00:31:31.416 --> 00:31:31.946
collection.

00:31:32.626 --> 00:31:34.016
However, with conditional

00:31:34.016 --> 00:31:35.326
conformance, this is actually an

00:31:35.326 --> 00:31:35.586
error.

00:31:36.576 --> 00:31:37.636
Now, if you think back to the

00:31:37.636 --> 00:31:39.666
slice example, we needed to have

00:31:39.776 --> 00:31:41.686
different constraints for those,

00:31:41.926 --> 00:31:43.186
for those different levels of

00:31:43.186 --> 00:31:44.466
the hierarchy for collection.

00:31:44.466 --> 00:31:45.746
Versus bidirectionalCollection

00:31:45.746 --> 00:31:47.176
versus randomAccessCollection.

00:31:47.756 --> 00:31:49.416
And so, compiler's enforcing

00:31:49.416 --> 00:31:50.636
that you've thought about this,

00:31:50.636 --> 00:31:52.096
and made sure that you have the

00:31:52.146 --> 00:31:53.426
right set of constraints for

00:31:53.736 --> 00:31:54.776
conditional conformance.

00:31:55.906 --> 00:31:57.406
In this case, the constraints

00:31:57.406 --> 00:31:58.596
across the entire hierarchy are

00:31:58.596 --> 00:31:59.076
the same.

00:31:59.416 --> 00:32:00.506
So, we can just write out

00:32:00.506 --> 00:32:01.646
explicitly collection and

00:32:01.646 --> 00:32:02.756
bidirectionalCollection.

00:32:03.346 --> 00:32:05.066
To assert that this is where all

00:32:05.066 --> 00:32:06.056
these conformances are.

00:32:06.506 --> 00:32:07.936
Or we can do the stylistically

00:32:07.936 --> 00:32:09.616
better thing, and split out the

00:32:09.616 --> 00:32:10.556
different conformances.

00:32:12.486 --> 00:32:13.726
Now at this point, our range

00:32:13.726 --> 00:32:15.346
type is pretty powerful.

00:32:15.346 --> 00:32:15.946
It does everything the

00:32:15.946 --> 00:32:17.016
countableRange does.

00:32:17.296 --> 00:32:17.976
So what should we do with

00:32:17.976 --> 00:32:18.686
countableRange?

00:32:19.536 --> 00:32:20.206
We could throw it away.

00:32:20.726 --> 00:32:21.496
In this case we're talking about

00:32:21.496 --> 00:32:23.066
the standard library, and

00:32:23.066 --> 00:32:23.936
there's a lot of code that

00:32:23.936 --> 00:32:25.706
actually uses countableRange.

00:32:25.986 --> 00:32:28.176
So we can keep it around as a

00:32:28.176 --> 00:32:29.586
generic type alias.

00:32:30.886 --> 00:32:32.476
This is a really nice solution.

00:32:32.476 --> 00:32:34.466
So the generic type alias adds

00:32:34.546 --> 00:32:35.886
all of those extra requirements

00:32:35.886 --> 00:32:37.306
you need to make the range

00:32:37.306 --> 00:32:37.806
countable.

00:32:38.066 --> 00:32:39.276
The requirements you need to

00:32:39.276 --> 00:32:42.056
turn it into a collection, but

00:32:42.056 --> 00:32:43.366
it's just an alternate name for

00:32:43.366 --> 00:32:44.706
the underlying range type.

00:32:46.826 --> 00:32:47.806
Again, this is great for source

00:32:47.806 --> 00:32:49.166
compatibility, because code can

00:32:49.166 --> 00:32:50.846
still use countableRange.

00:32:51.116 --> 00:32:52.416
On the other hand, it's also

00:32:52.466 --> 00:32:54.466
really nice to give a name to

00:32:54.466 --> 00:32:56.046
those ranges that have

00:32:56.046 --> 00:32:57.856
additional capabilities of being

00:32:57.856 --> 00:32:59.286
a randomAccessCollection.

00:32:59.916 --> 00:33:01.276
In fact, we can use this to

00:33:01.276 --> 00:33:02.206
clean up other code.

00:33:02.206 --> 00:33:03.466
To say, well, we know what a

00:33:03.466 --> 00:33:04.476
countableRange is.

00:33:04.876 --> 00:33:06.876
It's a range with this extra

00:33:06.876 --> 00:33:09.106
striding capability, so we can

00:33:09.106 --> 00:33:10.616
go extend countableRanges.

00:33:10.916 --> 00:33:12.776
And that is a case in which we

00:33:12.776 --> 00:33:14.466
have randomAccessCollection

00:33:14.466 --> 00:33:14.996
conformance.

00:33:16.446 --> 00:33:17.426
So, we've introduced this in

00:33:17.426 --> 00:33:19.866
Swift 4.2 to help simplify the

00:33:19.866 --> 00:33:20.906
set of types that we're dealing

00:33:20.906 --> 00:33:21.136
with.

00:33:21.136 --> 00:33:22.706
And make the existing core types

00:33:22.706 --> 00:33:24.656
like range more composable and

00:33:24.656 --> 00:33:25.346
more flexible.

00:33:27.756 --> 00:33:28.966
>> Recursive constraints

00:33:28.966 --> 00:33:30.726
describe relationships among

00:33:30.726 --> 00:33:32.316
protocols and their associated

00:33:32.316 --> 00:33:32.756
types.

00:33:33.336 --> 00:33:34.836
This is a topic that we didn't

00:33:34.836 --> 00:33:36.616
cover in the WWDC version of

00:33:36.616 --> 00:33:37.136
this talk.

00:33:37.416 --> 00:33:38.776
But it's an important part of

00:33:38.776 --> 00:33:40.436
the standard library's use of

00:33:40.436 --> 00:33:41.666
Swift's generic system.

00:33:42.216 --> 00:33:43.006
Let's jump right in.

00:33:43.936 --> 00:33:45.556
A recursive constraint is

00:33:45.556 --> 00:33:47.046
nothing more than a constraint

00:33:47.076 --> 00:33:48.856
within a protocol that mentions

00:33:48.886 --> 00:33:50.336
that same protocol.

00:33:51.036 --> 00:33:52.616
Here, collection has an

00:33:52.616 --> 00:33:53.986
associated type named

00:33:53.986 --> 00:33:54.886
subsequence.

00:33:55.196 --> 00:33:57.136
That is itself a collection.

00:33:57.726 --> 00:33:58.786
Why would you need this?

00:33:59.316 --> 00:34:00.886
Well, let's look at a generic

00:34:00.886 --> 00:34:02.566
algorithm that relies on it.

00:34:03.086 --> 00:34:05.386
So here, given an already sorted

00:34:05.386 --> 00:34:06.006
collection.

00:34:06.316 --> 00:34:07.906
We want to find the index at

00:34:07.906 --> 00:34:09.496
which we should insert a new

00:34:09.496 --> 00:34:10.065
value.

00:34:10.335 --> 00:34:12.076
To maintain that sort order.

00:34:12.456 --> 00:34:13.255
We're going to compute the

00:34:13.255 --> 00:34:14.656
sorted insertion point for the

00:34:14.656 --> 00:34:15.585
value 11.

00:34:16.335 --> 00:34:17.985
When we go ahead and insert 11

00:34:17.985 --> 00:34:19.936
at that index, the result is

00:34:19.936 --> 00:34:21.406
still a sorted array.

00:34:22.036 --> 00:34:23.315
The sorted insertion point of

00:34:23.315 --> 00:34:25.386
function is implemented in terms

00:34:25.386 --> 00:34:26.846
of a binary search.

00:34:27.536 --> 00:34:28.806
Binary search is a classic

00:34:28.806 --> 00:34:30.716
divide-and-conquer algorithm.

00:34:31.005 --> 00:34:32.766
Meaning that at each step, it

00:34:32.766 --> 00:34:34.646
makes a decision that allows it

00:34:34.646 --> 00:34:35.985
to significantly reduce the

00:34:35.985 --> 00:34:37.056
problem size.

00:34:37.196 --> 00:34:38.876
For the next step to consider.

00:34:38.876 --> 00:34:41.476
For binary search, we first look

00:34:41.476 --> 00:34:43.216
at the middle element, 8.

00:34:43.735 --> 00:34:44.966
And compare it against the value

00:34:44.966 --> 00:34:45.755
that we want to insert.

00:34:45.976 --> 00:34:46.545
That's 11.

00:34:47.226 --> 00:34:49.085
And because 11 is greater than

00:34:49.085 --> 00:34:51.085
8, we know that 11 needs to be

00:34:51.085 --> 00:34:53.476
inserted somewhere after the 8.

00:34:53.585 --> 00:34:54.556
In the latter half of the

00:34:54.556 --> 00:34:55.136
collection.

00:34:55.626 --> 00:34:57.136
So we restrict our search space

00:34:57.236 --> 00:34:57.826
by half.

00:34:59.096 --> 00:35:00.726
In our next step, we find the

00:35:00.726 --> 00:35:02.956
new middle, 14, and compare it

00:35:02.956 --> 00:35:03.856
against the value we want to

00:35:03.856 --> 00:35:04.246
insert.

00:35:05.196 --> 00:35:07.546
Eleven is less than 14, so the

00:35:07.546 --> 00:35:09.326
insertion point has to come

00:35:09.556 --> 00:35:10.776
before the middle.

00:35:11.246 --> 00:35:12.526
Divide the remaining collection

00:35:12.526 --> 00:35:13.676
in half again.

00:35:14.586 --> 00:35:15.876
Continue dividing collection

00:35:15.876 --> 00:35:16.976
we're looking at in half.

00:35:17.096 --> 00:35:18.306
Until we're pointing at the

00:35:18.306 --> 00:35:19.626
proper insertion point.

00:35:19.966 --> 00:35:20.986
That's our solution.

00:35:22.546 --> 00:35:23.616
Divide-and-conquer algorithms

00:35:23.616 --> 00:35:25.216
like this are fantastic.

00:35:25.556 --> 00:35:27.316
Because they're extremely fast.

00:35:27.806 --> 00:35:30.056
Binary search takes logarithmic

00:35:30.056 --> 00:35:30.486
time.

00:35:30.726 --> 00:35:32.076
Which means that doubling your

00:35:32.076 --> 00:35:33.616
input size doesn't make the

00:35:33.616 --> 00:35:35.426
algorithm run twice as slowly

00:35:35.496 --> 00:35:36.436
like it would for a linear

00:35:36.436 --> 00:35:36.906
algorithm.

00:35:37.416 --> 00:35:38.716
With a logarithmic algorithm

00:35:38.716 --> 00:35:40.646
like binary search, it only has

00:35:40.646 --> 00:35:42.726
to perform one additional step

00:35:43.206 --> 00:35:44.906
to cut the problem size in half

00:35:44.906 --> 00:35:45.336
again.

00:35:45.876 --> 00:35:47.646
So let's turn that into code.

00:35:48.226 --> 00:35:50.146
The first thing we need to do is

00:35:50.146 --> 00:35:51.996
find the index of the middle

00:35:51.996 --> 00:35:52.506
element.

00:35:52.706 --> 00:35:53.566
Which we can do using

00:35:53.566 --> 00:35:55.446
randomAccessCollections index

00:35:55.446 --> 00:35:56.746
offset by a function.

00:35:57.616 --> 00:35:59.526
Next, we check whether our value

00:35:59.526 --> 00:36:01.716
comes before the middle element.

00:36:01.956 --> 00:36:03.166
So we know which half of the

00:36:03.166 --> 00:36:04.696
collection contains our

00:36:04.696 --> 00:36:05.516
insertion point.

00:36:06.516 --> 00:36:08.396
Now in our example, the value to

00:36:08.396 --> 00:36:09.626
insert is greater than the

00:36:09.626 --> 00:36:10.316
middle element.

00:36:10.656 --> 00:36:11.846
So we take a slice of the

00:36:11.846 --> 00:36:13.766
collection from the index after

00:36:13.766 --> 00:36:14.316
the middle.

00:36:14.576 --> 00:36:16.036
All the way until the end.

00:36:16.556 --> 00:36:18.106
And recursively call sort and

00:36:18.106 --> 00:36:19.616
insertion point of on that

00:36:19.616 --> 00:36:20.266
slice.

00:36:20.686 --> 00:36:21.466
This is common of

00:36:21.466 --> 00:36:22.936
divide-and-conquer algorithms.

00:36:23.126 --> 00:36:24.236
Where you reduce the problem

00:36:24.236 --> 00:36:26.036
space and then recurse.

00:36:26.036 --> 00:36:28.706
Now to make this work, we need

00:36:28.706 --> 00:36:30.116
that slicing syntax.

00:36:30.116 --> 00:36:31.636
Provide a suitable slice of a

00:36:31.636 --> 00:36:32.316
collection.

00:36:33.076 --> 00:36:34.356
We can do this for all

00:36:34.356 --> 00:36:35.966
collections by introducing a

00:36:35.966 --> 00:36:37.846
general operation that takes a

00:36:37.846 --> 00:36:40.496
range of indices and produces a

00:36:40.496 --> 00:36:40.966
slice.

00:36:41.296 --> 00:36:41.816
Like this.

00:36:42.966 --> 00:36:44.386
Now remember that the slice

00:36:44.386 --> 00:36:46.086
adapter we discussed earlier

00:36:46.126 --> 00:36:47.896
works on any collection.

00:36:48.116 --> 00:36:50.066
Providing a view of the elements

00:36:50.066 --> 00:36:51.576
of the underlying collection

00:36:51.866 --> 00:36:53.956
that is itself a collection.

00:36:54.616 --> 00:36:55.166
This makes our

00:36:55.166 --> 00:36:56.286
divide-and-conquer algorithm

00:36:56.286 --> 00:36:57.776
work for any collection.

00:36:58.196 --> 00:36:59.916
As well as providing slicing

00:36:59.916 --> 00:37:02.186
syntax to all collections.

00:37:02.766 --> 00:37:03.966
That's great, but there's just

00:37:03.966 --> 00:37:04.776
one problem.

00:37:05.536 --> 00:37:07.296
Some collections don't want this

00:37:07.296 --> 00:37:08.786
particular slice type.

00:37:09.306 --> 00:37:10.456
They really want to provide

00:37:10.456 --> 00:37:12.226
their own slicing operations

00:37:12.466 --> 00:37:14.056
that produce a different type.

00:37:14.606 --> 00:37:16.086
String is the most common

00:37:16.086 --> 00:37:16.626
example.

00:37:17.016 --> 00:37:19.106
When you slice a string, you get

00:37:19.106 --> 00:37:20.406
back a substring.

00:37:21.516 --> 00:37:22.466
And so if you apply our

00:37:22.466 --> 00:37:24.056
divide-and-conquer algorithms to

00:37:24.236 --> 00:37:25.436
the string collection.

00:37:25.666 --> 00:37:26.776
You really want those to be in

00:37:26.776 --> 00:37:27.786
terms of substring.

00:37:27.966 --> 00:37:29.196
Rather than some other type like

00:37:29.196 --> 00:37:30.086
the slice of a string.

00:37:30.836 --> 00:37:32.526
Range is another interesting

00:37:32.526 --> 00:37:33.176
example.

00:37:33.406 --> 00:37:35.146
Because its slicing operation

00:37:35.376 --> 00:37:37.436
returns an instance of the exact

00:37:37.436 --> 00:37:39.766
same range type just with the

00:37:39.766 --> 00:37:40.626
new bounds.

00:37:41.306 --> 00:37:43.126
So to capture this variation

00:37:43.246 --> 00:37:44.766
among different types that

00:37:44.766 --> 00:37:46.676
conform to collection, we can

00:37:46.676 --> 00:37:48.796
introduce new requirements into

00:37:48.796 --> 00:37:49.896
the collection protocol.

00:37:50.066 --> 00:37:51.486
Specifically for slicing.

00:37:52.396 --> 00:37:54.176
So here we've pulled the slicing

00:37:54.176 --> 00:37:55.606
subscript into the collection

00:37:55.606 --> 00:37:57.536
protocol itself as a

00:37:57.536 --> 00:37:58.316
requirement.

00:37:59.136 --> 00:38:00.686
Now note that the result type of

00:38:00.686 --> 00:38:02.846
this subscript is described by a

00:38:02.846 --> 00:38:04.216
new associated type:

00:38:04.676 --> 00:38:05.426
subsequence.

00:38:06.886 --> 00:38:09.446
Now both string and range meet

00:38:09.446 --> 00:38:10.656
these new requirements of

00:38:10.656 --> 00:38:11.296
collection.

00:38:11.976 --> 00:38:13.736
With string, the subsequence

00:38:13.736 --> 00:38:15.256
type is substring.

00:38:16.506 --> 00:38:18.606
For range, the subsequence type

00:38:18.606 --> 00:38:20.166
is going to be the range itself.

00:38:20.166 --> 00:38:22.766
Now this works well for, for

00:38:22.766 --> 00:38:23.596
string and range.

00:38:23.736 --> 00:38:25.326
But for all the other collection

00:38:25.326 --> 00:38:26.856
types that don't want to

00:38:26.856 --> 00:38:28.646
customize the actual subsequence

00:38:28.646 --> 00:38:28.926
type.

00:38:29.346 --> 00:38:30.536
We can provide default

00:38:30.536 --> 00:38:31.736
limitations of slicing.

00:38:32.396 --> 00:38:33.326
So the authors of these

00:38:33.326 --> 00:38:34.646
collection type don't actually

00:38:34.646 --> 00:38:36.536
have to do any extra work to

00:38:36.536 --> 00:38:37.666
conform to collection.

00:38:37.906 --> 00:38:38.996
They get all the slicing

00:38:38.996 --> 00:38:40.126
behavior for free.

00:38:41.056 --> 00:38:42.366
So we're going to start with

00:38:42.366 --> 00:38:43.206
subsequence.

00:38:44.006 --> 00:38:46.066
Associated types themselves can

00:38:46.066 --> 00:38:47.706
have default values.

00:38:48.176 --> 00:38:50.036
Written after the equals sign.

00:38:50.436 --> 00:38:52.576
For subsequence, the slice

00:38:52.576 --> 00:38:54.156
adaptor type is a perfect

00:38:54.156 --> 00:38:56.076
default because it works for all

00:38:56.076 --> 00:38:56.906
collections.

00:38:57.026 --> 00:38:58.806
So this default will be used for

00:38:58.806 --> 00:39:00.736
any conforming type that doesn't

00:39:00.736 --> 00:39:02.626
provide its own subsequence

00:39:02.626 --> 00:39:02.946
type.

00:39:04.106 --> 00:39:05.576
This pairs well with the

00:39:05.576 --> 00:39:06.896
implementation of the slicing

00:39:06.896 --> 00:39:08.446
subscript we started with

00:39:08.446 --> 00:39:09.066
earlier.

00:39:09.566 --> 00:39:11.246
Written in extension on the

00:39:11.246 --> 00:39:12.326
collection protocol.

00:39:12.756 --> 00:39:14.476
And it can act as a default

00:39:14.476 --> 00:39:16.336
implementation, providing the

00:39:16.336 --> 00:39:17.896
slicing subscript operation that

00:39:17.896 --> 00:39:18.946
returns a slice.

00:39:19.886 --> 00:39:21.736
We can even go one step further

00:39:21.946 --> 00:39:23.986
and limit the applicability of

00:39:23.986 --> 00:39:25.426
our default slicing subscript

00:39:25.426 --> 00:39:27.506
implementation to those cases

00:39:27.606 --> 00:39:29.046
where we picked the default

00:39:29.046 --> 00:39:30.306
subsequence type.

00:39:30.996 --> 00:39:32.706
So this pattern prevents the

00:39:32.706 --> 00:39:34.546
default implementation from

00:39:34.546 --> 00:39:36.706
showing up as an overload on

00:39:36.706 --> 00:39:38.016
collection types that have

00:39:38.016 --> 00:39:39.486
customized their subsequence.

00:39:39.486 --> 00:39:41.256
Like string and range.

00:39:41.806 --> 00:39:42.776
So this is all great for

00:39:42.776 --> 00:39:43.666
conforming types.

00:39:43.916 --> 00:39:45.766
They get slicing for free, or

00:39:45.766 --> 00:39:46.946
they can customize it if they

00:39:46.946 --> 00:39:47.446
want to.

00:39:48.606 --> 00:39:49.896
But remember our goal here.

00:39:50.256 --> 00:39:51.526
We're trying to write our

00:39:51.526 --> 00:39:52.926
divide-and-conquer algorithms

00:39:52.926 --> 00:39:54.416
against the collection protocol.

00:39:55.016 --> 00:39:57.146
So we have to answer one really

00:39:57.146 --> 00:39:58.116
important question.

00:39:58.706 --> 00:40:00.596
What does subsequence do?

00:40:01.266 --> 00:40:02.686
All we know about subsequence

00:40:02.686 --> 00:40:04.296
right now is that it's the

00:40:04.296 --> 00:40:05.456
result type of the slicing

00:40:05.456 --> 00:40:06.656
subscript operation.

00:40:07.146 --> 00:40:08.666
But we need more to actually use

00:40:08.666 --> 00:40:08.966
it.

00:40:09.286 --> 00:40:10.816
So to answer this question, we

00:40:10.816 --> 00:40:11.896
have to go back to the

00:40:11.896 --> 00:40:13.856
algorithms that we want to write

00:40:13.856 --> 00:40:15.196
in terms of subsequence.

00:40:15.776 --> 00:40:17.666
Our algorithm is recursive.

00:40:18.186 --> 00:40:20.016
It forms a slice which is now a

00:40:20.016 --> 00:40:22.186
value of the subsequence type.

00:40:22.186 --> 00:40:24.796
And then recursively calls sort

00:40:24.796 --> 00:40:26.856
insertion point of on that

00:40:26.856 --> 00:40:27.386
slice.

00:40:27.926 --> 00:40:30.236
Now this only makes sense if the

00:40:30.236 --> 00:40:32.176
subsequence type you get back is

00:40:32.176 --> 00:40:33.696
itself a collection.

00:40:34.436 --> 00:40:35.716
Now when it performs that call,

00:40:35.916 --> 00:40:37.356
we're going to pass a value of

00:40:37.356 --> 00:40:39.076
the collection's element type.

00:40:39.666 --> 00:40:41.226
But the recursive call itself is

00:40:41.226 --> 00:40:43.216
going to expect a value of this

00:40:43.216 --> 00:40:45.126
subsequence's element type.

00:40:45.816 --> 00:40:47.546
The only way this can possibly

00:40:47.546 --> 00:40:49.716
make sense is if those element

00:40:49.716 --> 00:40:51.396
types are identical.

00:40:51.396 --> 00:40:54.416
Now the same issue comes up when

00:40:54.416 --> 00:40:56.196
returning an index from the

00:40:56.196 --> 00:40:57.066
recursive call.

00:40:57.666 --> 00:40:58.766
Which is going to be computed in

00:40:58.766 --> 00:41:00.216
terms of the subsequence.

00:41:00.616 --> 00:41:02.206
But that index that's returned

00:41:02.656 --> 00:41:04.786
also needs to be a valid index

00:41:04.936 --> 00:41:06.406
for the current collection.

00:41:06.766 --> 00:41:08.276
So we can capture all of these

00:41:08.276 --> 00:41:10.246
requirements in the collection

00:41:10.246 --> 00:41:11.456
protocol itself.

00:41:11.456 --> 00:41:13.416
Now the first thing we want to

00:41:13.416 --> 00:41:15.376
do is say that the subsequence

00:41:15.376 --> 00:41:17.076
of a collection is itself a

00:41:17.076 --> 00:41:17.696
collection.

00:41:18.046 --> 00:41:19.606
This is a so-called recursive

00:41:19.606 --> 00:41:20.256
constraint.

00:41:20.446 --> 00:41:21.676
Because the associated type

00:41:21.676 --> 00:41:23.626
conforms to its own enclosing

00:41:23.626 --> 00:41:24.156
protocol.

00:41:24.996 --> 00:41:27.176
We can then use associated type

00:41:27.176 --> 00:41:29.036
where clauses to further

00:41:29.036 --> 00:41:30.736
constrain our subsequence.

00:41:31.356 --> 00:41:33.386
As we talked about earlier, it

00:41:33.386 --> 00:41:34.576
has an element type.

00:41:34.576 --> 00:41:36.086
And that element type needs to

00:41:36.086 --> 00:41:38.006
be the same as that of the

00:41:38.006 --> 00:41:39.136
original collection.

00:41:39.376 --> 00:41:40.606
So we can express that here with

00:41:40.606 --> 00:41:41.656
the same type constraint.

00:41:41.856 --> 00:41:43.416
Subsequent element is the same

00:41:43.416 --> 00:41:44.136
as element.

00:41:45.006 --> 00:41:46.436
We can do exactly the same thing

00:41:46.436 --> 00:41:47.466
for the index type.

00:41:48.266 --> 00:41:49.776
Now, these cover all the

00:41:49.776 --> 00:41:51.696
properties that we discovered by

00:41:51.696 --> 00:41:53.416
looking at the implementation of

00:41:53.416 --> 00:41:54.926
the sorted insertion point of

00:41:55.076 --> 00:41:55.776
algorithm.

00:41:57.076 --> 00:41:58.886
This leads us to an interesting

00:41:58.886 --> 00:41:59.466
question.

00:41:59.776 --> 00:42:01.666
Can you slice a subsequence?

00:42:02.416 --> 00:42:03.936
Well, every subsequence is a

00:42:03.936 --> 00:42:05.856
collection and every collection

00:42:05.856 --> 00:42:07.126
has a slice operation.

00:42:07.396 --> 00:42:08.866
So of course you can slice a

00:42:08.866 --> 00:42:09.706
subsequence.

00:42:09.986 --> 00:42:11.796
And the result is going to be a

00:42:11.796 --> 00:42:14.146
subsequence of the subsequence.

00:42:15.156 --> 00:42:17.036
Now you can do this again and

00:42:17.036 --> 00:42:18.166
get a subsequence of a

00:42:18.166 --> 00:42:19.996
subsequence of a subsequence.

00:42:20.566 --> 00:42:22.956
And keep on going on and on and

00:42:22.956 --> 00:42:23.326
on.

00:42:24.786 --> 00:42:26.466
Now interestingly, at each point

00:42:26.556 --> 00:42:28.226
we could have a brand-new type.

00:42:28.226 --> 00:42:29.746
And so we have this potentially

00:42:29.776 --> 00:42:31.376
infinite tower of types.

00:42:31.906 --> 00:42:33.156
That's actually okay.

00:42:33.896 --> 00:42:35.106
Each recursive step in our

00:42:35.106 --> 00:42:36.546
generic algorithm could

00:42:36.546 --> 00:42:38.946
conceivably create a new type.

00:42:39.666 --> 00:42:41.236
Based on the current collection

00:42:41.236 --> 00:42:41.536
type.

00:42:42.136 --> 00:42:43.246
So long as the recursion

00:42:43.246 --> 00:42:44.336
eventually terminates at

00:42:44.336 --> 00:42:46.166
runtime, there's no problem with

00:42:46.166 --> 00:42:46.566
this.

00:42:47.306 --> 00:42:49.116
However, it's often the case

00:42:49.166 --> 00:42:50.676
divide-and-conquer algorithms

00:42:50.676 --> 00:42:51.646
can be implemented more

00:42:51.646 --> 00:42:53.376
efficiently by making them

00:42:53.376 --> 00:42:54.396
nonrecursive.

00:42:55.876 --> 00:42:58.146
So here is the nonrecursive

00:42:58.146 --> 00:42:59.846
implementation of the sort and

00:42:59.846 --> 00:43:01.496
insertion point of algorithm.

00:43:02.096 --> 00:43:03.066
We're going to walk through it.

00:43:03.066 --> 00:43:04.356
Because the core algorithm is

00:43:04.356 --> 00:43:05.056
the same.

00:43:05.406 --> 00:43:07.256
But it's expressed iteratively

00:43:07.256 --> 00:43:09.086
with this while loop rather than

00:43:09.086 --> 00:43:09.816
recursively.

00:43:10.536 --> 00:43:11.626
So the first thing we're going

00:43:11.626 --> 00:43:13.366
to do is take a slice of the

00:43:13.366 --> 00:43:14.546
whole collection.

00:43:15.306 --> 00:43:17.446
This slice variable is going to

00:43:17.446 --> 00:43:18.546
represent the part of the

00:43:18.546 --> 00:43:19.846
collection that we're looking at

00:43:19.996 --> 00:43:21.196
in each iteration.

00:43:21.986 --> 00:43:23.316
And now we see the familiar

00:43:23.316 --> 00:43:24.726
divide-and-conquer pattern.

00:43:25.226 --> 00:43:26.766
Find the middle of the slice.

00:43:27.206 --> 00:43:29.066
And then compare the value to

00:43:29.066 --> 00:43:30.686
insert against the middle

00:43:30.686 --> 00:43:31.836
element in the slice.

00:43:32.616 --> 00:43:34.536
We then narrow the search base

00:43:34.846 --> 00:43:37.046
by slicing the slice before we

00:43:37.046 --> 00:43:37.986
go in loop again.

00:43:39.286 --> 00:43:41.246
However, here we have a problem.

00:43:41.556 --> 00:43:43.416
We're performing an assignment

00:43:43.696 --> 00:43:45.146
to the slice variable.

00:43:45.396 --> 00:43:46.566
Which is of the subsequence

00:43:46.566 --> 00:43:46.876
type.

00:43:47.866 --> 00:43:48.576
On the other hand, the

00:43:48.576 --> 00:43:50.526
right-hand side is a slice of a

00:43:50.526 --> 00:43:51.126
slice.

00:43:51.286 --> 00:43:52.646
And as we talked about before,

00:43:53.006 --> 00:43:54.146
this is a subsequence of the

00:43:54.146 --> 00:43:55.856
subsequence and could be a

00:43:55.856 --> 00:43:57.216
completely different type.

00:43:57.636 --> 00:43:58.556
So we're going to get a compiler

00:43:58.556 --> 00:43:59.956
error telling us that these two

00:43:59.956 --> 00:44:01.496
types are not necessarily the

00:44:01.496 --> 00:44:01.956
same.

00:44:02.566 --> 00:44:04.296
That's really inconvenient here

00:44:04.296 --> 00:44:05.356
because it prevents us from

00:44:05.356 --> 00:44:06.646
writing this nonrecursive

00:44:06.646 --> 00:44:07.116
algorithm.

00:44:07.116 --> 00:44:09.326
And it doesn't really reflect

00:44:09.386 --> 00:44:10.996
how specific collection types

00:44:10.996 --> 00:44:11.506
behave.

00:44:11.506 --> 00:44:12.706
Think about string.

00:44:13.266 --> 00:44:15.376
If you slice a string, you get a

00:44:15.376 --> 00:44:15.996
substring.

00:44:16.446 --> 00:44:18.276
If you slice a substring, you

00:44:18.276 --> 00:44:20.586
don't get a sub-substring.

00:44:21.256 --> 00:44:23.286
You just get another instance of

00:44:23.286 --> 00:44:24.296
the substring type.

00:44:25.206 --> 00:44:27.196
So let's go back to how this

00:44:27.196 --> 00:44:28.646
slice adapter works to

00:44:28.646 --> 00:44:29.816
generalize this notion.

00:44:30.306 --> 00:44:31.426
We have a collection.

00:44:31.426 --> 00:44:32.426
We're going to call it Self,

00:44:32.776 --> 00:44:34.606
that we've sliced from I to J.

00:44:35.536 --> 00:44:36.576
Now that's going to build

00:44:36.736 --> 00:44:37.996
something of the type slice of

00:44:37.996 --> 00:44:38.506
Self.

00:44:38.746 --> 00:44:40.676
Which is just a view on the

00:44:40.676 --> 00:44:42.146
underlying Self collection.

00:44:42.686 --> 00:44:45.276
If we then slice the slice, we

00:44:45.276 --> 00:44:47.676
get a slice of slice of self.

00:44:47.866 --> 00:44:50.586
Which is a view of a view on

00:44:50.586 --> 00:44:52.576
that same underlying Self

00:44:52.576 --> 00:44:53.246
collection.

00:44:53.906 --> 00:44:55.646
So this is our infinite tower of

00:44:55.646 --> 00:44:56.876
types in practice.

00:44:57.346 --> 00:44:58.956
However, it doesn't have to be

00:44:58.956 --> 00:44:59.446
this way.

00:45:00.076 --> 00:45:01.736
Remember that the slice types

00:45:01.966 --> 00:45:04.246
use the same indices as their

00:45:04.246 --> 00:45:05.576
underlying collection.

00:45:05.976 --> 00:45:07.546
And they also know about their

00:45:07.546 --> 00:45:08.846
underlying basic collection.

00:45:09.356 --> 00:45:11.686
So when we slice the slice, we

00:45:11.686 --> 00:45:13.436
can take those new indices, I2

00:45:13.436 --> 00:45:14.286
and J2.

00:45:14.286 --> 00:45:16.566
Bring them back to the original

00:45:16.566 --> 00:45:18.766
base collection and form the new

00:45:18.766 --> 00:45:19.936
slice from there.

00:45:19.936 --> 00:45:22.486
And what this does is it means

00:45:22.486 --> 00:45:23.946
that when you slice a slice, you

00:45:23.946 --> 00:45:25.436
get something back of the same

00:45:25.436 --> 00:45:26.146
slice type.

00:45:26.316 --> 00:45:28.746
Effectively tying off the

00:45:28.746 --> 00:45:29.466
recursion.

00:45:29.906 --> 00:45:31.206
This is exactly the same

00:45:31.206 --> 00:45:32.946
behavior we saw with substring.

00:45:33.246 --> 00:45:34.846
And it's completely reasonable

00:45:34.846 --> 00:45:36.616
to expect that all subsequence

00:45:36.616 --> 00:45:38.706
types behave in this way.

00:45:39.026 --> 00:45:41.246
So let's model it as an explicit

00:45:41.246 --> 00:45:42.456
part of the collection's

00:45:42.456 --> 00:45:43.746
protocol requirements.

00:45:44.416 --> 00:45:46.436
So here we're saying that the

00:45:46.436 --> 00:45:48.616
subsequence of a subsequence is

00:45:48.616 --> 00:45:49.976
the same type as the

00:45:49.976 --> 00:45:50.766
subsequence.

00:45:51.086 --> 00:45:52.326
In other words, when you slice a

00:45:52.326 --> 00:45:54.786
slice, you get back the same

00:45:54.786 --> 00:45:55.356
slice.

00:45:56.326 --> 00:45:57.976
This makes our nonrecursive

00:45:57.976 --> 00:45:59.256
divide-and-conquer algorithm

00:45:59.336 --> 00:45:59.836
work.

00:46:00.006 --> 00:46:01.286
And simplifies the use of the

00:46:01.286 --> 00:46:02.276
collection protocol.

00:46:02.566 --> 00:46:04.316
There's no more need to reason

00:46:04.356 --> 00:46:06.226
about infinite tower of types.

00:46:06.226 --> 00:46:08.736
Now there's one last issue here

00:46:08.736 --> 00:46:10.276
involving subsequence.

00:46:10.616 --> 00:46:11.906
We've said it's required to be a

00:46:11.906 --> 00:46:12.656
collection.

00:46:12.926 --> 00:46:14.546
But we need the subsequence type

00:46:14.546 --> 00:46:16.426
to be a random access collection

00:46:16.616 --> 00:46:18.826
to perform this index offset by

00:46:18.826 --> 00:46:19.676
operation.

00:46:20.806 --> 00:46:22.556
To describe this, we can use

00:46:22.766 --> 00:46:24.456
protocol where clauses.

00:46:24.846 --> 00:46:26.656
So when bidirectionalCollection

00:46:26.826 --> 00:46:28.116
inherits from collection.

00:46:28.386 --> 00:46:30.026
It can add a new constraint on

00:46:30.026 --> 00:46:32.056
subsequence, requiring it to

00:46:32.056 --> 00:46:33.246
conform to that

00:46:33.246 --> 00:46:34.346
bidirectionalCollection

00:46:34.346 --> 00:46:34.936
protocol.

00:46:35.346 --> 00:46:37.136
This again is a recursive

00:46:37.136 --> 00:46:38.496
constraint but now it's

00:46:38.496 --> 00:46:39.156
expressed on the

00:46:39.156 --> 00:46:40.156
bidirectionalCollection

00:46:40.156 --> 00:46:40.606
protocol.

00:46:40.966 --> 00:46:42.806
We can do the exact same thing

00:46:42.806 --> 00:46:44.736
for randomAccessCollections.

00:46:44.856 --> 00:46:46.146
Such as the subsequence of a

00:46:46.146 --> 00:46:47.876
random access collection, itself

00:46:47.876 --> 00:46:48.716
conforms to

00:46:48.896 --> 00:46:50.156
randomAccessCollection.

00:46:50.706 --> 00:46:52.176
Note how the constraints on

00:46:52.176 --> 00:46:54.566
subsequence follow the enclosing

00:46:54.566 --> 00:46:55.196
protocol.

00:46:55.476 --> 00:46:57.106
This might sound a little bit

00:46:57.106 --> 00:46:57.796
familiar.

00:46:58.586 --> 00:47:00.436
Both recursive constraints and

00:47:00.436 --> 00:47:02.076
conditional conformance tend to

00:47:02.076 --> 00:47:03.726
track the protocol hierarchy

00:47:03.726 --> 00:47:04.526
like this.

00:47:04.526 --> 00:47:05.646
And the features support each

00:47:05.646 --> 00:47:05.976
other.

00:47:06.236 --> 00:47:07.926
This is particularly important

00:47:07.926 --> 00:47:09.126
because we want the default

00:47:09.126 --> 00:47:10.876
associated type for subsequence,

00:47:11.186 --> 00:47:13.256
the slice of Self, to work at

00:47:13.256 --> 00:47:14.666
every level of the collection

00:47:14.666 --> 00:47:15.176
hierarchy.

00:47:15.676 --> 00:47:17.356
Slice is always a collection.

00:47:18.116 --> 00:47:19.106
When we go ahead and create the

00:47:19.106 --> 00:47:20.386
bidirectionalCollection

00:47:20.386 --> 00:47:20.966
protocol.

00:47:21.336 --> 00:47:22.676
It now requires that the

00:47:22.676 --> 00:47:25.016
subsequence type also conform to

00:47:25.016 --> 00:47:26.136
bidirectionalCollection.

00:47:26.996 --> 00:47:28.476
The slice adapter's conditional

00:47:28.476 --> 00:47:29.026
conformance to

00:47:29.026 --> 00:47:30.746
bidirectionalCollection which

00:47:30.806 --> 00:47:32.976
kicks in anytime itself is known

00:47:32.976 --> 00:47:34.296
to be a bidirectionalCollection.

00:47:34.716 --> 00:47:36.356
Satisfies that requirement.

00:47:36.986 --> 00:47:38.696
RandomAccessCollection works the

00:47:38.696 --> 00:47:39.296
same way.

00:47:39.796 --> 00:47:40.956
Subsequence gains a

00:47:40.956 --> 00:47:42.116
randomAccessCollection

00:47:42.116 --> 00:47:42.876
requirement.

00:47:43.236 --> 00:47:44.446
And slices conditional

00:47:44.446 --> 00:47:45.036
conformance to

00:47:45.036 --> 00:47:47.146
randomAccessCollection satisfies

00:47:47.146 --> 00:47:47.866
that requirement.

00:47:48.246 --> 00:47:49.916
Now itself is known to be a

00:47:49.916 --> 00:47:51.186
randomAccessCollection.

00:47:51.756 --> 00:47:53.236
This behavior where an

00:47:53.236 --> 00:47:54.836
associated type default works

00:47:54.946 --> 00:47:56.376
for every protocol within the

00:47:56.376 --> 00:47:58.726
hierarchy is a good indicator of

00:47:58.726 --> 00:47:59.906
a cohesive design.

00:48:00.726 --> 00:48:01.976
If you find yourself needing

00:48:02.076 --> 00:48:03.256
different associated type

00:48:03.256 --> 00:48:04.896
defaults at different points in

00:48:04.896 --> 00:48:05.896
the collection hierarchy.

00:48:06.216 --> 00:48:07.146
You might have a problem with

00:48:07.146 --> 00:48:07.686
your design.

00:48:08.316 --> 00:48:09.396
Recursive restraints are a

00:48:09.396 --> 00:48:10.426
powerful tool.

00:48:10.646 --> 00:48:12.286
Used with associated type and

00:48:12.286 --> 00:48:13.916
protocol where clauses, they

00:48:13.916 --> 00:48:14.996
help us write the protocol

00:48:14.996 --> 00:48:17.016
requirements we need to express

00:48:17.016 --> 00:48:18.336
divide-and-conquer algorithms

00:48:18.336 --> 00:48:20.116
naturally in generic code.

00:48:20.596 --> 00:48:22.266
And now we return to the final

00:48:22.266 --> 00:48:23.606
portion of the WWDC talk.

00:48:25.026 --> 00:48:26.506
So, Swift is a multi-paradigm

00:48:26.506 --> 00:48:26.906
language.

00:48:27.036 --> 00:48:28.426
We've been talking exclusively

00:48:28.426 --> 00:48:29.636
about generics right now.

00:48:29.636 --> 00:48:30.876
But of course, Swift also

00:48:30.876 --> 00:48:32.136
supports object-oriented

00:48:32.136 --> 00:48:32.716
programming.

00:48:33.756 --> 00:48:34.866
And so, I'd like to take a few

00:48:34.866 --> 00:48:35.906
moments to talk about the

00:48:35.906 --> 00:48:37.686
interaction between those two

00:48:37.686 --> 00:48:38.276
features.

00:48:38.376 --> 00:48:39.846
How they work together in the

00:48:39.846 --> 00:48:40.646
Swift language.

00:48:41.166 --> 00:48:43.696
So with class inheritance, we

00:48:43.696 --> 00:48:44.546
know how class inheritance

00:48:44.576 --> 00:48:44.906
works.

00:48:45.076 --> 00:48:45.866
It's fairly simple.

00:48:46.386 --> 00:48:47.716
You can declare a superclass,

00:48:47.716 --> 00:48:48.386
like Vehicle.

00:48:48.536 --> 00:48:50.156
You can declare some subclasses,

00:48:50.156 --> 00:48:51.616
like Taxi and PoliceCar that

00:48:51.616 --> 00:48:52.786
both inherit from Vehicle.

00:48:53.606 --> 00:48:55.126
And, once you do this, you have

00:48:55.126 --> 00:48:56.466
this object-oriented hierarchy.

00:48:56.956 --> 00:48:58.506
You have some expectations about

00:48:58.506 --> 00:48:59.636
where you can use those

00:48:59.636 --> 00:49:00.516
subclasses.

00:49:00.986 --> 00:49:02.926
So if I were to extend Vehicle

00:49:02.926 --> 00:49:04.376
with a new method, to go let it

00:49:04.376 --> 00:49:07.066
drive, I fully expect that I can

00:49:07.166 --> 00:49:08.736
call that method on one of my

00:49:08.736 --> 00:49:10.086
subclasses, Taxi.

00:49:11.016 --> 00:49:13.746
So, this is a fundamental aspect

00:49:13.816 --> 00:49:15.426
of object-oriented programming.

00:49:15.756 --> 00:49:17.356
And, Barbara Liskov, actually

00:49:17.356 --> 00:49:18.836
described this really well in a

00:49:18.836 --> 00:49:20.106
lecture back in the '80s.

00:49:20.846 --> 00:49:21.726
Since then, we've referred to

00:49:21.726 --> 00:49:23.656
this as the Liskov substitution

00:49:23.656 --> 00:49:24.156
principle.

00:49:24.516 --> 00:49:25.856
And, the idea's actually fairly

00:49:25.856 --> 00:49:26.286
simple.

00:49:26.886 --> 00:49:28.986
So, if you have someplace in

00:49:28.986 --> 00:49:30.906
your program that refers to a

00:49:30.906 --> 00:49:34.246
supertype, or superclass, like

00:49:34.376 --> 00:49:34.796
Vehicle.

00:49:35.956 --> 00:49:37.316
You should be able to take an

00:49:37.316 --> 00:49:39.056
instance of any of its subtypes,

00:49:39.056 --> 00:49:41.896
or subclasses, like Taxi or

00:49:41.896 --> 00:49:44.346
PoliceCar, and use that instead.

00:49:44.806 --> 00:49:45.966
And the program should still

00:49:45.966 --> 00:49:47.436
continue to type check and run

00:49:47.436 --> 00:49:47.996
correctly.

00:49:48.746 --> 00:49:50.046
So, the substitution here is an

00:49:50.046 --> 00:49:51.226
instance of a subclass should be

00:49:51.226 --> 00:49:52.356
able to go in anywhere that the

00:49:52.356 --> 00:49:53.756
superclass was expected and

00:49:53.756 --> 00:49:54.156
tested.

00:49:54.156 --> 00:49:56.476
And, this is a really simple

00:49:56.476 --> 00:49:56.896
principle.

00:49:56.896 --> 00:49:58.396
We've all internalized it, but

00:49:58.396 --> 00:50:00.026
it's also really powerful.

00:50:00.586 --> 00:50:01.646
If you think about it.

00:50:02.026 --> 00:50:03.346
And at any point in your program

00:50:03.346 --> 00:50:04.546
think well, what happens if I

00:50:04.546 --> 00:50:05.906
get a different subclass, maybe

00:50:05.906 --> 00:50:07.086
a subclass I haven't thought

00:50:07.086 --> 00:50:07.616
about here.

00:50:09.086 --> 00:50:11.786
So, getting back to generics,

00:50:12.756 --> 00:50:14.386
what are our expectations when

00:50:14.386 --> 00:50:15.906
applying Liskov substitution

00:50:15.906 --> 00:50:18.326
principle to the generic system?

00:50:18.976 --> 00:50:19.996
Well, maybe we add a new

00:50:20.066 --> 00:50:21.126
protocol, Drivable.

00:50:21.426 --> 00:50:24.296
Whatever. And extend Vehicle to

00:50:24.296 --> 00:50:25.146
make it Drivable.

00:50:25.496 --> 00:50:26.786
What do we expect to happen?

00:50:26.786 --> 00:50:29.066
Well, we expect that you can use

00:50:29.066 --> 00:50:30.286
that protocol, conformance of

00:50:30.286 --> 00:50:32.436
Vehicle to Drivable, for some of

00:50:32.436 --> 00:50:33.626
its subclasses as well.

00:50:34.616 --> 00:50:36.866
Say, you add a simple generic

00:50:36.866 --> 00:50:38.316
algorithm to the Drivable

00:50:38.316 --> 00:50:39.176
protocol to go for a

00:50:39.176 --> 00:50:39.966
sundayDrive.

00:50:40.386 --> 00:50:41.646
Well, now you should be able to

00:50:41.646 --> 00:50:44.476
use that API on a PoliceCar,

00:50:44.956 --> 00:50:46.116
even if that might not be the

00:50:46.116 --> 00:50:46.716
best idea.

00:50:48.346 --> 00:50:50.636
So, the protocol conformance

00:50:50.636 --> 00:50:52.096
here is effectively being

00:50:52.306 --> 00:50:53.846
inherited by subclasses.

00:50:54.876 --> 00:50:55.906
And this puts a constraint on

00:50:55.906 --> 00:50:56.566
the conformance.

00:50:56.826 --> 00:50:58.206
The one conformance that you

00:50:58.206 --> 00:50:59.446
write, the thing that makes

00:50:59.866 --> 00:51:00.976
Vehicle Drivable.

00:51:01.266 --> 00:51:02.956
Has to work for all of the

00:51:02.956 --> 00:51:05.146
subclasses of Vehicle now and

00:51:05.186 --> 00:51:06.416
anyone that comes up with it

00:51:06.416 --> 00:51:06.766
later.

00:51:07.886 --> 00:51:09.916
Most of the time, that just

00:51:09.916 --> 00:51:10.276
works.

00:51:11.256 --> 00:51:12.586
However, there are some cases

00:51:12.586 --> 00:51:13.976
where this actually adds new

00:51:13.976 --> 00:51:16.086
requirements on the subclasses.

00:51:16.726 --> 00:51:19.096
The most common one is when

00:51:19.096 --> 00:51:20.266
dealing with initializer

00:51:20.266 --> 00:51:20.996
requirements.

00:51:22.216 --> 00:51:22.886
So, if you've looked at the

00:51:22.886 --> 00:51:25.316
decodable protocol, it has one

00:51:25.316 --> 00:51:26.286
interesting requirement.

00:51:26.286 --> 00:51:27.606
Which is the initializer

00:51:27.606 --> 00:51:29.596
requirement to create a new

00:51:29.596 --> 00:51:31.036
instance of the conforming type

00:51:31.616 --> 00:51:32.606
from a decoder.

00:51:33.236 --> 00:51:35.156
How do we use this?

00:51:35.506 --> 00:51:36.756
Well, let's go add a convenience

00:51:36.756 --> 00:51:37.746
method to the decodable

00:51:37.746 --> 00:51:38.246
protocol.

00:51:38.716 --> 00:51:40.366
It's a static method decode that

00:51:40.516 --> 00:51:41.646
creates a new instance from a

00:51:41.646 --> 00:51:43.086
decoder, essentially a wrapper

00:51:43.086 --> 00:51:44.166
for the initializer, making it

00:51:44.166 --> 00:51:44.766
easier to use.

00:51:45.976 --> 00:51:47.606
And, there's two interesting

00:51:47.606 --> 00:51:49.376
things to notice about this

00:51:49.376 --> 00:51:50.516
particular method.

00:51:50.856 --> 00:51:52.776
First, is it returns Self with a

00:51:52.776 --> 00:51:53.456
capital S.

00:51:53.456 --> 00:51:54.736
Remember this is the conforming

00:51:54.766 --> 00:51:55.036
type.

00:51:55.436 --> 00:51:56.856
It's the same type that you're

00:51:56.856 --> 00:51:58.526
calling the static method on.

00:52:00.136 --> 00:52:01.176
Now, the second interesting

00:52:01.176 --> 00:52:03.006
thing is, how are we

00:52:03.006 --> 00:52:03.746
implementing this?

00:52:03.806 --> 00:52:04.956
Well, we're calling to that

00:52:04.956 --> 00:52:07.206
initializer above to create a

00:52:07.206 --> 00:52:10.146
brand-new instance of whatever

00:52:10.146 --> 00:52:12.516
decodable type we have, and then

00:52:12.516 --> 00:52:13.746
return it.

00:52:14.456 --> 00:52:15.326
Fair enough.

00:52:16.146 --> 00:52:17.256
We can go ahead and make our

00:52:17.256 --> 00:52:18.466
Vehicle type Decodable.

00:52:19.426 --> 00:52:21.586
And then, what we expect, when

00:52:21.586 --> 00:52:22.776
applying the Liskov substitution

00:52:22.776 --> 00:52:24.586
principle, is we can use any

00:52:24.586 --> 00:52:26.426
subclass of Vehicle.

00:52:27.146 --> 00:52:28.346
With these new API's that we've

00:52:28.346 --> 00:52:29.176
built through the protocol

00:52:29.176 --> 00:52:29.716
conformance.

00:52:29.816 --> 00:52:32.246
So, we can call Decode on a

00:52:32.246 --> 00:52:32.806
Taxi.

00:52:33.486 --> 00:52:34.726
And what we get back is not a

00:52:34.726 --> 00:52:35.726
Vehicle not some arbitrary

00:52:35.726 --> 00:52:37.366
Vehicle instance, but the Taxi,

00:52:37.456 --> 00:52:39.076
an instance of Taxi.

00:52:40.476 --> 00:52:41.846
This is great, but how does it

00:52:41.846 --> 00:52:42.016
work?

00:52:43.156 --> 00:52:45.496
So let's take a look at what

00:52:45.496 --> 00:52:46.256
Taxi might have.

00:52:46.256 --> 00:52:47.296
Maybe there's an hourly rate

00:52:47.356 --> 00:52:48.636
here, and when we call

00:52:48.636 --> 00:52:51.496
Taxi.decode from, we're going

00:52:51.496 --> 00:52:52.506
through the protocol, going

00:52:52.506 --> 00:52:53.856
through the protocol initializer

00:52:53.856 --> 00:52:54.366
requirement.

00:52:55.176 --> 00:52:56.366
There's only one initializer

00:52:56.366 --> 00:52:58.096
this can actually call, and

00:52:58.096 --> 00:52:59.806
that's the initializer that's

00:52:59.836 --> 00:53:02.266
declared inside the Vehicle

00:53:03.176 --> 00:53:04.956
class, in the superclass here.

00:53:06.476 --> 00:53:08.306
So that initializer, it knows

00:53:08.306 --> 00:53:09.746
how to decode all of the state

00:53:09.866 --> 00:53:10.636
of a Vehicle.

00:53:11.186 --> 00:53:12.366
But it knows nothing about the

00:53:12.366 --> 00:53:13.446
Taxi subclass.

00:53:14.396 --> 00:53:15.636
And so, if we were to use this

00:53:15.636 --> 00:53:16.786
initializer directly, we would

00:53:16.786 --> 00:53:18.126
actually have a problem that the

00:53:18.126 --> 00:53:19.656
hourly rate would be completely

00:53:19.656 --> 00:53:21.116
uninitialized, which could lead

00:53:21.116 --> 00:53:22.296
to some rather unfortunate

00:53:22.296 --> 00:53:23.556
misunderstandings when you get

00:53:23.556 --> 00:53:24.316
your bill at the end.

00:53:26.346 --> 00:53:27.476
So, how do we address this?

00:53:27.626 --> 00:53:28.996
Well, it turns out Swift doesn't

00:53:28.996 --> 00:53:30.626
let you get into this problem.

00:53:31.416 --> 00:53:33.006
It's going to diagnose at the

00:53:33.096 --> 00:53:34.426
point where you try to make

00:53:34.426 --> 00:53:36.016
Vehicle conform to the decodable

00:53:36.016 --> 00:53:37.466
protocol that there's actually a

00:53:37.466 --> 00:53:38.776
problem with this initializer.

00:53:38.866 --> 00:53:41.006
It needs to be marked required.

00:53:42.836 --> 00:53:44.966
Now, a required initializer has

00:53:44.966 --> 00:53:46.306
to be implemented in all

00:53:46.306 --> 00:53:47.226
subclasses.

00:53:47.516 --> 00:53:49.306
Not just the direct subclasses,

00:53:49.556 --> 00:53:52.276
but any subclasses of those, any

00:53:52.276 --> 00:53:53.916
future subclasses you don't know

00:53:53.916 --> 00:53:54.426
about now.

00:53:55.846 --> 00:53:57.196
Now by adding that requirement,

00:53:57.516 --> 00:53:59.936
it means that when Taxi inherits

00:53:59.996 --> 00:54:02.186
from Vehicle, it also needs to

00:54:02.186 --> 00:54:05.086
introduce an initializer with

00:54:05.086 --> 00:54:05.806
the same name.

00:54:06.616 --> 00:54:07.966
Now, this is important because

00:54:07.966 --> 00:54:09.566
this initializer's responsible

00:54:09.786 --> 00:54:11.556
for decoding the hourly rate.

00:54:11.556 --> 00:54:12.696
And then chaining up to the

00:54:12.696 --> 00:54:14.846
superclass initializer to decode

00:54:15.046 --> 00:54:16.886
the rest of the Vehicle type.

00:54:18.746 --> 00:54:21.006
Okay. Now, if you're reading

00:54:21.006 --> 00:54:22.756
those red boxes really quickly,

00:54:22.916 --> 00:54:23.776
you may have noticed the

00:54:23.776 --> 00:54:26.006
subphrase non-final.

00:54:26.836 --> 00:54:28.886
So, by definition, final classes

00:54:29.056 --> 00:54:30.456
have no subclasses.

00:54:30.456 --> 00:54:32.106
So, it essentially exempts them

00:54:32.106 --> 00:54:33.866
from being substituted later on.

00:54:35.046 --> 00:54:37.486
That means that there's no sense

00:54:37.486 --> 00:54:39.056
in having a required initializer

00:54:39.056 --> 00:54:40.136
because you know there are no

00:54:40.136 --> 00:54:40.886
subclasses.

00:54:41.046 --> 00:54:42.516
And so final classes are in a

00:54:42.516 --> 00:54:43.896
sense a little easier to work

00:54:43.896 --> 00:54:44.776
with when dealing with things

00:54:44.776 --> 00:54:45.806
like decodable or other

00:54:45.806 --> 00:54:47.136
initializer requirements.

00:54:47.486 --> 00:54:48.446
Because they're exempt from

00:54:48.446 --> 00:54:49.776
these rules of having required

00:54:49.776 --> 00:54:50.666
initializers.

00:54:51.406 --> 00:54:53.766
So when you're using classes,

00:54:53.766 --> 00:54:54.826
for reference semantics,

00:54:56.026 --> 00:54:57.936
consider using final when you no

00:54:57.936 --> 00:54:59.316
longer need to customize your

00:54:59.316 --> 00:55:01.236
class through the inheritance

00:55:01.236 --> 00:55:01.856
mechanism.

00:55:02.266 --> 00:55:03.866
Now, this doesn't mean that you

00:55:04.246 --> 00:55:05.336
can't customize your class

00:55:05.336 --> 00:55:05.676
later.

00:55:05.856 --> 00:55:07.046
You can still write an extension

00:55:07.046 --> 00:55:07.316
on it.

00:55:07.626 --> 00:55:08.796
The same way you can extend a

00:55:08.796 --> 00:55:09.776
struct or an enum.

00:55:10.626 --> 00:55:11.976
You can also add conformances to

00:55:11.976 --> 00:55:13.066
it, to get more dynamic

00:55:13.066 --> 00:55:13.626
dispatch.

00:55:14.996 --> 00:55:16.226
But final can simplify the

00:55:16.226 --> 00:55:17.156
interaction with the generic

00:55:17.156 --> 00:55:18.576
system, and also unlock

00:55:18.576 --> 00:55:19.886
optimization opportunities for

00:55:19.886 --> 00:55:20.836
the compiler in runtime.

00:55:24.396 --> 00:55:25.286
So we've talked a bit about

00:55:25.286 --> 00:55:26.196
Swift generics today.

00:55:26.486 --> 00:55:27.966
The idea behind Swift generics

00:55:27.966 --> 00:55:29.706
is to provide the ability to

00:55:29.706 --> 00:55:31.606
reuse code while maintaining

00:55:31.606 --> 00:55:32.856
static type information.

00:55:33.176 --> 00:55:34.256
To make it easier to write

00:55:34.296 --> 00:55:36.076
correct programs, and compile

00:55:36.076 --> 00:55:37.006
those down into efficient,

00:55:37.086 --> 00:55:38.976
efficiently executing programs.

00:55:39.726 --> 00:55:41.266
When you're designing protocols,

00:55:41.666 --> 00:55:43.826
let this push and pull between

00:55:43.826 --> 00:55:45.036
the generic algorithms you want

00:55:45.036 --> 00:55:46.246
to write against a protocol.

00:55:46.246 --> 00:55:48.046
And the conforming types that

00:55:48.046 --> 00:55:49.466
need to implement that protocol

00:55:49.736 --> 00:55:51.576
guide your design to meaningful

00:55:51.576 --> 00:55:52.506
extractions.

00:55:53.636 --> 00:55:55.266
Introduce protocol inheritance

00:55:55.516 --> 00:55:56.706
when you need some more

00:55:56.706 --> 00:55:58.256
specialized capabilities to

00:55:58.256 --> 00:55:59.996
implement new generic algorithms

00:56:00.216 --> 00:56:01.986
that are only supportable on a

00:56:01.986 --> 00:56:03.626
subset of the conforming types.

00:56:04.726 --> 00:56:06.116
And, conditional conformance

00:56:06.446 --> 00:56:07.716
when you're writing generic

00:56:07.816 --> 00:56:11.046
types, so that they can compose

00:56:11.046 --> 00:56:12.576
nicely, especially when working

00:56:12.576 --> 00:56:13.686
with protocol hierarchies.

00:56:14.456 --> 00:56:15.276
And finally, when you're

00:56:15.336 --> 00:56:16.656
reasoning about the tricky

00:56:16.656 --> 00:56:18.126
interaction between class

00:56:18.126 --> 00:56:19.506
inheritance and the generic

00:56:19.506 --> 00:56:19.976
system.

00:56:20.536 --> 00:56:21.786
Go back to the Liskov

00:56:21.786 --> 00:56:23.306
substitution principle, and

00:56:23.306 --> 00:56:26.036
think about what happens here if

00:56:26.036 --> 00:56:27.866
I introduce a subclass rather

00:56:27.866 --> 00:56:29.546
than a superclass at which I

00:56:29.546 --> 00:56:30.406
wrote the conformance.

00:56:32.576 --> 00:56:34.626
Well, thank you very much.

00:56:34.866 --> 00:56:35.776
There's a couple of related

00:56:35.776 --> 00:56:37.536
sessions on embracing algorithms

00:56:37.536 --> 00:56:38.596
and understanding how they can

00:56:38.596 --> 00:56:39.706
help you build better code.

00:56:39.976 --> 00:56:41.276
As well as using Swift

00:56:41.276 --> 00:56:43.296
collections effectively in your

00:56:43.296 --> 00:56:44.126
everyday programming.

00:56:45.026 --> 00:56:45.536
Thank you.

00:56:46.508 --> 00:56:48.508
[ Applause ]
WEBVTT

00:00:06.516 --> 00:00:15.500
[ Music ]

00:00:19.516 --> 00:00:26.386
[ Applause ]

00:00:26.886 --> 00:00:27.716
>> Good morning, ladies and

00:00:27.716 --> 00:00:28.196
gentlemen.

00:00:28.986 --> 00:00:29.986
How many of you are here for the

00:00:29.986 --> 00:00:31.706
first time at WWDC?

00:00:33.666 --> 00:00:34.806
That's fantastic.

00:00:34.806 --> 00:00:36.536
It's great to see so many new

00:00:36.536 --> 00:00:37.336
faces every year.

00:00:38.046 --> 00:00:39.146
My name is Stuart Cheshire.

00:00:39.266 --> 00:00:40.326
And we're going to be talking

00:00:40.326 --> 00:00:41.166
about networking.

00:00:42.176 --> 00:00:44.106
I'm going to start by covering

00:00:44.106 --> 00:00:45.946
some topics that affect the

00:00:45.946 --> 00:00:47.296
performance of your app.

00:00:47.886 --> 00:00:48.806
There's hardly an app that

00:00:48.806 --> 00:00:50.776
exists today that doesn't make

00:00:50.776 --> 00:00:51.766
use of networking.

00:00:52.246 --> 00:00:54.026
And getting the best performance

00:00:54.026 --> 00:00:55.176
out of the network is really

00:00:55.176 --> 00:00:55.856
important.

00:00:56.386 --> 00:00:57.236
We're going to cover some

00:00:57.236 --> 00:00:58.806
technologies here that help you

00:00:58.806 --> 00:00:59.896
get the best performance.

00:01:00.936 --> 00:01:03.116
We're also going to cover some

00:01:03.226 --> 00:01:05.296
tips and tricks and guidance

00:01:05.716 --> 00:01:07.656
about how to make the best use

00:01:07.696 --> 00:01:10.176
of Apple's APIs, a little bit of

00:01:10.176 --> 00:01:12.346
news about new technologies on

00:01:12.346 --> 00:01:14.716
the horizon, and then my

00:01:14.716 --> 00:01:16.556
colleague Jiten will go into

00:01:16.556 --> 00:01:18.106
detail on URLSession.

00:01:21.066 --> 00:01:23.956
Let's start off with a state of

00:01:23.956 --> 00:01:24.796
the Internet update.

00:01:25.416 --> 00:01:27.666
Earlier this year, we hit a

00:01:27.666 --> 00:01:30.476
total of 4 billion people using

00:01:30.476 --> 00:01:30.966
the Internet.

00:01:31.256 --> 00:01:32.466
That's more than half of the

00:01:32.526 --> 00:01:33.626
world's population.

00:01:34.166 --> 00:01:35.876
And we're used to Internet usage

00:01:35.876 --> 00:01:36.846
doubling and doubling.

00:01:37.696 --> 00:01:39.286
Clearly when we passed halfway,

00:01:39.776 --> 00:01:40.606
the number of people on the

00:01:40.606 --> 00:01:42.766
Internet can't keep doubling, so

00:01:43.096 --> 00:01:45.316
that growth is slowing down but

00:01:45.316 --> 00:01:46.306
that doesn't mean Internet

00:01:46.396 --> 00:01:47.576
growth is slowing down.

00:01:48.426 --> 00:01:49.626
There's a lot of growth in

00:01:49.626 --> 00:01:50.426
machine-to-machine

00:01:50.426 --> 00:01:51.996
communications, Internet of

00:01:51.996 --> 00:01:53.536
Things, Smart Homes.

00:01:54.256 --> 00:01:55.546
There's still a lot of growth in

00:01:55.546 --> 00:01:57.046
places like India and China.

00:01:58.276 --> 00:01:59.826
And there is a lot of people who

00:01:59.826 --> 00:02:01.256
have never owned a desktop

00:02:01.296 --> 00:02:03.646
computer who may never own a

00:02:03.646 --> 00:02:04.596
desktop computer.

00:02:05.016 --> 00:02:06.926
Their primary computing and

00:02:06.926 --> 00:02:08.675
communication device is their

00:02:08.675 --> 00:02:09.356
Smartphone.

00:02:09.895 --> 00:02:12.356
And a lot of those Smartphones

00:02:12.396 --> 00:02:14.166
are still using 2G networks.

00:02:15.066 --> 00:02:17.486
I'm sure most of us in this room

00:02:17.486 --> 00:02:20.166
are fortunate enough to live in

00:02:20.166 --> 00:02:21.916
places and work in places where

00:02:21.916 --> 00:02:23.406
we build our apps where we have

00:02:23.406 --> 00:02:24.946
fast LTE networks.

00:02:25.396 --> 00:02:27.266
And that can be a handicap

00:02:27.736 --> 00:02:31.076
because if you build your app so

00:02:31.076 --> 00:02:33.896
it works well in LTE, it may

00:02:33.896 --> 00:02:35.996
perform very, very badly on 2G.

00:02:36.916 --> 00:02:37.956
One of your competitors,

00:02:37.956 --> 00:02:39.106
somewhere else in the world, who

00:02:39.106 --> 00:02:40.476
builds an app that works great

00:02:40.476 --> 00:02:42.716
on 2G is going to be fantastic

00:02:42.716 --> 00:02:43.366
on LTE.

00:02:43.976 --> 00:02:46.436
So we have a tool to help

00:02:46.436 --> 00:02:48.946
everybody mimic some of the

00:02:48.946 --> 00:02:50.766
properties of these slower

00:02:50.766 --> 00:02:52.476
networks and that's Network Link

00:02:52.476 --> 00:02:53.056
Conditioner.

00:02:54.016 --> 00:02:55.266
You should build your app

00:02:55.446 --> 00:02:57.026
running Network Link Conditioner

00:02:57.026 --> 00:02:57.946
right from the start.

00:02:58.206 --> 00:02:59.476
Don't think you can add in

00:02:59.476 --> 00:03:02.046
performance at the end because

00:03:02.046 --> 00:03:02.716
it's too late.

00:03:03.456 --> 00:03:05.176
Always, always, always run and

00:03:05.176 --> 00:03:06.646
test your app using Network Link

00:03:06.646 --> 00:03:08.266
Conditioner and that way if you

00:03:08.266 --> 00:03:10.266
make a programming mistake that

00:03:10.266 --> 00:03:11.276
has horrible performance

00:03:11.276 --> 00:03:12.726
implications, you see it right

00:03:12.726 --> 00:03:13.916
away and you can fix it right

00:03:13.916 --> 00:03:14.186
away.

00:03:15.476 --> 00:03:16.986
Use tools like Wireshark and

00:03:16.986 --> 00:03:19.036
tcptrace to understand the

00:03:19.036 --> 00:03:20.336
network performance of your app.

00:03:20.906 --> 00:03:21.746
It's a lot like using

00:03:21.746 --> 00:03:23.046
Instruments to look at memory

00:03:23.046 --> 00:03:24.166
and CPU usage.

00:03:25.056 --> 00:03:26.866
If you haven't seen tcptrace, it

00:03:26.866 --> 00:03:28.186
is a wonderful tool that

00:03:28.186 --> 00:03:29.976
produces graphs like this that

00:03:29.976 --> 00:03:31.476
let you see at a glance what's

00:03:31.476 --> 00:03:32.486
going on, on the network.

00:03:33.356 --> 00:03:34.566
If you want to learn more about

00:03:34.566 --> 00:03:35.866
that, check out the video from

00:03:35.866 --> 00:03:38.546
three years ago.

00:03:39.456 --> 00:03:41.566
IPv6 usage continues to grow.

00:03:42.426 --> 00:03:43.816
Why is that important?

00:03:43.986 --> 00:03:46.006
It's important because IPv6 is

00:03:46.356 --> 00:03:47.946
shown to have better performance

00:03:47.946 --> 00:03:48.846
than IPv4.

00:03:48.906 --> 00:03:50.286
And if you care about

00:03:50.286 --> 00:03:51.796
performance, you want to make

00:03:51.796 --> 00:03:53.596
sure not just your app but the

00:03:53.596 --> 00:03:55.236
service your app is talking to

00:03:55.426 --> 00:03:56.836
support Native IPv6.

00:03:57.716 --> 00:03:59.156
Some places in the world are

00:03:59.156 --> 00:04:00.546
doing better in this respect

00:04:00.546 --> 00:04:01.086
than others.

00:04:01.906 --> 00:04:04.006
In the US, we're now up to 87%

00:04:04.006 --> 00:04:05.686
of mobile carriers offering

00:04:05.686 --> 00:04:05.996
IPv6.

00:04:06.036 --> 00:04:08.456
Other places like India are

00:04:08.456 --> 00:04:09.546
doing pretty well too.

00:04:10.256 --> 00:04:11.416
And let's focus a bit more on

00:04:11.416 --> 00:04:11.696
India.

00:04:12.596 --> 00:04:14.596
Here is some data that the

00:04:14.596 --> 00:04:15.766
networking team at Apple

00:04:15.766 --> 00:04:18.326
gathered earlier this year about

00:04:18.466 --> 00:04:21.086
net TCP connection setup time

00:04:21.516 --> 00:04:24.566
and ongoing round-trip delay on

00:04:25.256 --> 00:04:26.606
cellular networks in India.

00:04:27.266 --> 00:04:28.756
The blue line is IPv6.

00:04:29.486 --> 00:04:31.416
And if we, for example, look at

00:04:31.416 --> 00:04:33.946
the 75th percentile, we can say

00:04:34.226 --> 00:04:39.316
75% of TCP connections over v6

00:04:39.376 --> 00:04:40.986
are set up in less than 150

00:04:40.986 --> 00:04:41.746
milliseconds.

00:04:42.446 --> 00:04:44.576
The comparable number for IPv4

00:04:44.576 --> 00:04:46.796
is worse than 325.

00:04:47.336 --> 00:04:48.636
It's more than twice as slow.

00:04:49.036 --> 00:04:50.976
So if you want fast, responsive

00:04:50.976 --> 00:04:53.526
applications for your users, get

00:04:53.526 --> 00:04:55.166
on IPv6 if you're not already.

00:04:56.926 --> 00:04:58.516
Another technology that improves

00:04:58.566 --> 00:05:00.526
performance by reducing packet

00:05:00.526 --> 00:05:02.286
loss and retransmission is

00:05:02.286 --> 00:05:03.266
Explicit Congestion

00:05:03.266 --> 00:05:04.026
Notification.

00:05:04.836 --> 00:05:06.056
We've had this enabled by

00:05:06.056 --> 00:05:08.026
default in macOS and iOS for

00:05:08.026 --> 00:05:09.496
some years now so you don't need

00:05:09.496 --> 00:05:10.306
to do anything on your

00:05:10.306 --> 00:05:12.376
application to take advantage of

00:05:12.376 --> 00:05:12.726
this.

00:05:13.706 --> 00:05:14.936
Do make sure your service

00:05:15.016 --> 00:05:16.506
supports ECN.

00:05:17.296 --> 00:05:20.026
In a survey we did of the Alexa

00:05:20.026 --> 00:05:22.076
top million websites, we found

00:05:22.076 --> 00:05:24.276
last month we're now up to 77%

00:05:24.276 --> 00:05:25.316
of the Alexa top million

00:05:25.316 --> 00:05:27.226
services supporting ECN, which

00:05:27.226 --> 00:05:28.666
is a big improvement compared to

00:05:28.666 --> 00:05:32.206
a few years ago.

00:05:32.936 --> 00:05:34.936
Another technology that helps

00:05:34.936 --> 00:05:36.506
improve performance and

00:05:36.506 --> 00:05:37.766
resilience of your connections

00:05:37.766 --> 00:05:39.016
is Multipath TCP.

00:05:39.796 --> 00:05:41.336
Quite often, the user may make a

00:05:41.336 --> 00:05:43.426
connection in their office on

00:05:43.426 --> 00:05:45.676
Wi-Fi and then they walk outside

00:05:46.436 --> 00:05:47.896
and they lose the Wi-Fi signal.

00:05:47.896 --> 00:05:49.516
Now with traditional TCP, the

00:05:49.516 --> 00:05:50.666
connection is broken.

00:05:50.666 --> 00:05:51.506
You have to reconnect.

00:05:51.506 --> 00:05:52.516
You have to start again.

00:05:53.176 --> 00:05:55.356
Multipath TCP makes its packet

00:05:55.356 --> 00:05:56.716
routing decisions on a per

00:05:56.716 --> 00:05:58.636
packet basis not per connection,

00:05:59.236 --> 00:06:01.976
so it can switch that connection

00:06:01.976 --> 00:06:03.846
live to a different interface.

00:06:05.876 --> 00:06:08.416
We talked last year about how to

00:06:08.416 --> 00:06:09.876
enable this in your application.

00:06:10.016 --> 00:06:11.706
And, of course, check with your

00:06:11.706 --> 00:06:13.076
server operators to make sure

00:06:13.076 --> 00:06:14.106
your servers are supporting

00:06:14.106 --> 00:06:14.976
Multipath too.

00:06:16.146 --> 00:06:18.246
We recently did a survey of the

00:06:18.246 --> 00:06:20.196
mobile carriers that Apple works

00:06:20.196 --> 00:06:22.036
with around the world and right

00:06:22.036 --> 00:06:25.706
now 78% of their networks work

00:06:26.726 --> 00:06:28.226
with Multipath TCP.

00:06:28.696 --> 00:06:30.496
Only 22% of carriers are still

00:06:30.496 --> 00:06:32.016
blocking Multipath connections.

00:06:32.536 --> 00:06:37.456
TCP Fast Open is a technology

00:06:37.706 --> 00:06:39.536
that lets you avoid the normal

00:06:39.536 --> 00:06:41.446
round-trip delay of the TCP

00:06:41.446 --> 00:06:42.426
connection set up.

00:06:42.906 --> 00:06:46.216
TCP Fast Open lets you put your

00:06:46.216 --> 00:06:48.766
initial data in with the TCP

00:06:48.766 --> 00:06:50.706
connection set up packets.

00:06:52.546 --> 00:06:53.856
You can check out more details

00:06:53.856 --> 00:06:55.096
of that from our video from

00:06:55.096 --> 00:06:55.976
three years ago.

00:06:56.476 --> 00:06:57.856
And check with your server

00:06:57.856 --> 00:06:59.286
operators to make sure that your

00:06:59.286 --> 00:07:03.256
servers support TCP Fast Open.

00:07:03.476 --> 00:07:05.586
Now moving on to some new news.

00:07:06.216 --> 00:07:09.176
There is a technology that many

00:07:09.176 --> 00:07:10.776
of you will have heard of called

00:07:10.836 --> 00:07:11.106
Quick.

00:07:11.986 --> 00:07:13.326
Quick is a new transport

00:07:13.326 --> 00:07:15.856
protocol, the first serious

00:07:15.856 --> 00:07:17.516
candidate in 30 years for a

00:07:17.516 --> 00:07:19.246
successor to replace TCP.

00:07:19.796 --> 00:07:21.576
It started off as an experiment

00:07:21.676 --> 00:07:23.086
by some engineers at Google.

00:07:23.566 --> 00:07:24.716
That experiment proved

00:07:24.716 --> 00:07:25.366
successful.

00:07:25.366 --> 00:07:27.626
It has now been adopted as an

00:07:27.696 --> 00:07:29.876
IETF work in group item for

00:07:29.876 --> 00:07:30.766
standardization.

00:07:31.966 --> 00:07:33.256
Apple engineers are

00:07:33.256 --> 00:07:34.446
participating in that.

00:07:34.446 --> 00:07:35.816
In fact, we have engineers right

00:07:35.816 --> 00:07:37.786
now at the Quick meeting taking

00:07:37.786 --> 00:07:38.596
place in Sweden.

00:07:39.996 --> 00:07:41.916
This is not yet ready for prime

00:07:41.916 --> 00:07:42.286
time.

00:07:42.286 --> 00:07:43.506
The standard is not finished,

00:07:44.016 --> 00:07:45.416
but Apple is working on it.

00:07:45.416 --> 00:07:47.146
As soon as it is ready, you can

00:07:47.146 --> 00:07:48.306
expect to see Apple API

00:07:48.436 --> 00:07:50.916
supporting that.

00:07:51.266 --> 00:07:52.256
Continuing in the theme of

00:07:52.306 --> 00:07:55.406
performance, we observed some

00:07:55.406 --> 00:07:56.656
behavior that's very common.

00:07:57.356 --> 00:07:59.336
Lots and lots of websites and

00:07:59.336 --> 00:08:01.036
Internet services use pretty

00:08:01.036 --> 00:08:03.666
short lifetimes on their DNS

00:08:03.666 --> 00:08:04.266
records.

00:08:04.666 --> 00:08:06.596
And they do this because if a

00:08:06.596 --> 00:08:08.736
data center goes down, they want

00:08:08.736 --> 00:08:10.496
to be able to update the DNS and

00:08:10.496 --> 00:08:12.686
very rapidly direct traffic to a

00:08:12.686 --> 00:08:13.666
different data center.

00:08:15.266 --> 00:08:16.636
The problem with this approach

00:08:17.076 --> 00:08:19.166
is you're paying a performance

00:08:19.166 --> 00:08:20.736
cost for something that almost

00:08:20.736 --> 00:08:21.506
never happens.

00:08:21.596 --> 00:08:23.816
Data centers very rarely go

00:08:23.816 --> 00:08:24.186
down.

00:08:25.066 --> 00:08:27.316
And what this means is every

00:08:27.316 --> 00:08:29.276
time a DNS address record is

00:08:29.276 --> 00:08:31.096
expired, your client has to

00:08:31.096 --> 00:08:32.736
spend another round-trip delay

00:08:33.046 --> 00:08:35.496
waiting for the response from

00:08:35.496 --> 00:08:37.306
the DNS server, which is the

00:08:37.306 --> 00:08:38.606
same as what it knew already

00:08:38.606 --> 00:08:39.155
last time.

00:08:39.756 --> 00:08:42.736
So thinking about this, we

00:08:42.736 --> 00:08:44.826
realized and optimization we

00:08:44.826 --> 00:08:45.216
could do.

00:08:45.866 --> 00:08:47.856
If you pass the flag to opt into

00:08:47.856 --> 00:08:50.866
this new behavior, then when you

00:08:50.866 --> 00:08:52.846
do a DNS query, if we have a

00:08:52.846 --> 00:08:54.446
stale, expired answer in the

00:08:54.446 --> 00:08:56.956
cache, we will give that to you

00:08:57.056 --> 00:08:59.286
immediately while in parallel,

00:08:59.286 --> 00:09:00.876
at the same time, doing the

00:09:00.876 --> 00:09:02.816
normal DNS query we would have

00:09:02.816 --> 00:09:03.476
done anyway.

00:09:04.576 --> 00:09:05.796
If the answer comes back the

00:09:05.796 --> 00:09:07.636
same, as we predict it will

00:09:07.636 --> 00:09:09.586
almost always, everything is

00:09:09.586 --> 00:09:11.136
fine, you just saved a

00:09:11.136 --> 00:09:12.516
round-trip time and got your

00:09:12.516 --> 00:09:13.766
connection started faster.

00:09:14.426 --> 00:09:15.856
If the answer comes back as a

00:09:15.856 --> 00:09:18.156
different address, we will then

00:09:18.156 --> 00:09:19.356
give another asynchronous

00:09:19.356 --> 00:09:21.416
notification to your client that

00:09:21.416 --> 00:09:22.666
there's a new address available

00:09:22.696 --> 00:09:23.926
which it should also try.

00:09:24.706 --> 00:09:26.096
And to make use of this, you

00:09:26.096 --> 00:09:27.446
have to use it in conjunction

00:09:27.446 --> 00:09:28.946
with Happy Eyeballs algorithm.

00:09:29.436 --> 00:09:30.996
That means your racing multiple

00:09:30.996 --> 00:09:32.126
connections in parallel.

00:09:32.996 --> 00:09:33.976
You're trying IPv4, IPv6,

00:09:34.006 --> 00:09:36.886
multiple addresses, multiple

00:09:36.886 --> 00:09:37.756
interfaces.

00:09:38.566 --> 00:09:39.846
If that sounds like a lot of

00:09:39.846 --> 00:09:41.356
work and it's hard to get right,

00:09:41.516 --> 00:09:42.606
you're absolutely correct.

00:09:42.606 --> 00:09:43.496
It is a lot of work.

00:09:44.096 --> 00:09:46.246
Stay after the break and we will

00:09:46.246 --> 00:09:48.686
tell you about some new APIs

00:09:48.966 --> 00:09:50.406
that let you take advantage of

00:09:50.406 --> 00:09:51.666
this without doing all the hard

00:09:51.666 --> 00:09:52.346
work yourself.

00:09:54.526 --> 00:09:56.056
Now moving on to some guidance.

00:09:56.726 --> 00:09:58.836
We have seen a common pattern

00:09:59.246 --> 00:10:02.296
that many developers use

00:10:02.446 --> 00:10:04.426
SCNetworkReachability as a

00:10:04.556 --> 00:10:05.326
preflight check.

00:10:06.396 --> 00:10:07.686
They want to predict the future.

00:10:07.916 --> 00:10:09.076
They want to know whether the

00:10:09.076 --> 00:10:10.936
next network operation they do

00:10:10.936 --> 00:10:12.096
will succeed or fail.

00:10:12.626 --> 00:10:14.956
And, unfortunately, predicting

00:10:14.956 --> 00:10:16.116
the future is always a hard

00:10:16.116 --> 00:10:16.666
thing to do.

00:10:17.216 --> 00:10:18.786
You may have connectivity now

00:10:19.476 --> 00:10:20.966
but two seconds from now the

00:10:21.026 --> 00:10:22.366
user has walked out of the

00:10:22.366 --> 00:10:23.696
building and you've lost the

00:10:23.696 --> 00:10:24.496
Wi-Fi signal.

00:10:24.886 --> 00:10:27.656
So there is no way to guarantee

00:10:27.656 --> 00:10:29.026
whether a future operation will

00:10:29.026 --> 00:10:29.566
succeed.

00:10:30.486 --> 00:10:32.356
And we see this pattern where

00:10:32.356 --> 00:10:32.826
they check.

00:10:33.166 --> 00:10:34.326
The preflight says yes.

00:10:34.406 --> 00:10:35.006
They try it.

00:10:35.056 --> 00:10:35.686
They fail.

00:10:36.126 --> 00:10:36.836
They go back.

00:10:36.836 --> 00:10:37.716
They check again.

00:10:38.526 --> 00:10:41.016
This also is a lot of work, a

00:10:41.016 --> 00:10:42.546
lot of [inaudible], a lot of

00:10:42.546 --> 00:10:44.026
difficult things to get right

00:10:44.606 --> 00:10:46.426
including networks with proxies.

00:10:47.606 --> 00:10:48.776
We can handle that for you.

00:10:50.506 --> 00:10:53.746
The better way to do this is

00:10:53.746 --> 00:10:56.006
just make a connection using the

00:10:56.006 --> 00:10:58.616
waitsForConnectivity option.

00:10:58.816 --> 00:11:00.326
You can learn more about that

00:11:00.326 --> 00:11:01.526
watching last year's video.

00:11:01.966 --> 00:11:03.956
What this means is if you want a

00:11:03.956 --> 00:11:05.566
connection, you tell the system

00:11:05.566 --> 00:11:06.566
I want a connection.

00:11:06.806 --> 00:11:09.006
Now if you can, later if not.

00:11:09.326 --> 00:11:10.976
If the device is in airplane

00:11:10.976 --> 00:11:12.396
mode, then when it's out of

00:11:12.396 --> 00:11:13.566
airplane mode your connection

00:11:13.566 --> 00:11:14.216
will succeed.

00:11:14.686 --> 00:11:16.266
That is much easier than

00:11:16.266 --> 00:11:17.396
building the retry loop

00:11:17.396 --> 00:11:17.866
yourself.

00:11:18.876 --> 00:11:20.466
There is one case we've seen

00:11:20.466 --> 00:11:22.456
with developers which does make

00:11:22.456 --> 00:11:24.516
sense which is if you're going

00:11:24.516 --> 00:11:26.046
to have the user answer a lot of

00:11:26.046 --> 00:11:27.876
information in a form, you may

00:11:27.876 --> 00:11:29.146
not want to waste the user's

00:11:29.146 --> 00:11:31.186
time if you have good reason to

00:11:31.186 --> 00:11:33.096
believe that may later fail.

00:11:34.126 --> 00:11:35.736
If that is the use case you care

00:11:35.736 --> 00:11:37.366
about, stay after the break

00:11:37.606 --> 00:11:39.076
because we have a new way to do

00:11:39.076 --> 00:11:43.166
that that's much better.

00:11:43.356 --> 00:11:45.436
Security remains important, as

00:11:45.536 --> 00:11:46.286
always.

00:11:47.316 --> 00:11:49.696
After ten years of using TLS

00:11:49.736 --> 00:11:52.256
1.2, the Internet is now ready

00:11:52.256 --> 00:11:53.886
to move to its successor, TLS

00:11:53.886 --> 00:11:54.646
1.3.

00:11:55.286 --> 00:11:56.406
It has a number of improved

00:11:56.406 --> 00:11:57.566
security features.

00:11:58.146 --> 00:12:00.066
It has reduced connection setup

00:12:00.106 --> 00:12:02.576
time, similar to TCP Fast Open.

00:12:03.496 --> 00:12:05.536
That standard is now final.

00:12:05.716 --> 00:12:07.506
The final draft was approved for

00:12:07.506 --> 00:12:09.286
publication by the Internet

00:12:09.286 --> 00:12:10.616
Engineering Steering Group

00:12:10.906 --> 00:12:11.726
earlier this year.

00:12:12.586 --> 00:12:14.766
We are waiting for the actual

00:12:14.766 --> 00:12:16.366
published document to come out

00:12:16.366 --> 00:12:17.406
of the RFC Editor.

00:12:17.836 --> 00:12:19.416
And when that does, we'll be

00:12:19.416 --> 00:12:22.246
turning on TLS 1.3 by default.

00:12:23.326 --> 00:12:25.026
Right now in your seed, it's not

00:12:25.026 --> 00:12:25.976
turned on by default.

00:12:27.166 --> 00:12:28.426
You can use the instructions

00:12:28.426 --> 00:12:32.636
here on iOS or macOS to enable

00:12:32.896 --> 00:12:35.726
TLS 13 in your applications.

00:12:36.016 --> 00:12:37.386
And we encourage you to do this

00:12:37.386 --> 00:12:39.696
right away because later this

00:12:39.696 --> 00:12:41.926
year when TLS 1.3 is turned on

00:12:41.926 --> 00:12:43.796
by default, you don't risk

00:12:43.796 --> 00:12:45.166
problems with your service not

00:12:45.166 --> 00:12:45.936
being compatible.

00:12:46.236 --> 00:12:48.346
So test them right now to make

00:12:48.346 --> 00:12:49.896
sure everything will go smoothly

00:12:50.166 --> 00:12:51.346
when the switchover happens

00:12:51.346 --> 00:12:51.946
later this year.

00:12:56.046 --> 00:12:57.446
Another element of security

00:12:57.446 --> 00:12:58.956
that's new is certificate

00:12:58.956 --> 00:12:59.676
transparency.

00:12:59.676 --> 00:13:02.116
You've probably heard cases

00:13:02.366 --> 00:13:05.666
where certificate authorities,

00:13:06.036 --> 00:13:07.026
either through malice or

00:13:07.026 --> 00:13:08.986
incompetence, issue rogue

00:13:08.986 --> 00:13:10.646
certificates to entities that

00:13:10.646 --> 00:13:11.196
they should not.

00:13:12.556 --> 00:13:14.046
The solution to this is

00:13:14.046 --> 00:13:15.546
something called certificate

00:13:15.546 --> 00:13:16.766
transparency logs.

00:13:17.556 --> 00:13:19.426
Every legitimate certificate

00:13:19.426 --> 00:13:22.326
authority now issues a public

00:13:22.926 --> 00:13:24.766
statement of every certificate

00:13:24.766 --> 00:13:25.516
it issues.

00:13:25.596 --> 00:13:27.076
And those are recorded in public

00:13:27.076 --> 00:13:29.296
logs for anybody to inspect.

00:13:30.236 --> 00:13:31.836
And this means that if a rogue

00:13:32.406 --> 00:13:34.436
certificate authority issues a

00:13:34.436 --> 00:13:36.596
bogus certificate, if it

00:13:36.596 --> 00:13:37.786
publishes it, they'll

00:13:37.786 --> 00:13:40.656
immediately get caught.

00:13:40.656 --> 00:13:41.856
And if they don't publish it,

00:13:42.186 --> 00:13:43.486
they'll be caught by the client.

00:13:44.966 --> 00:13:46.596
This is the setup you're

00:13:46.596 --> 00:13:47.966
probably familiar with.

00:13:48.436 --> 00:13:50.356
The new entity here is the log.

00:13:51.186 --> 00:13:52.736
When a certificate authority

00:13:52.936 --> 00:13:54.786
issues a certificate to a

00:13:54.786 --> 00:13:57.616
server, it also records that

00:13:57.616 --> 00:13:59.896
with the log and the log gives

00:13:59.896 --> 00:14:01.776
the server a signed affidavit

00:14:02.146 --> 00:14:03.656
that its certificate has been

00:14:03.656 --> 00:14:04.646
publicly recorded.

00:14:04.926 --> 00:14:06.076
And then when the client

00:14:06.166 --> 00:14:08.066
connects, the server can give

00:14:08.066 --> 00:14:09.096
all that information to the

00:14:09.096 --> 00:14:11.046
client and the client can verify

00:14:11.046 --> 00:14:12.256
that not only is this a signed

00:14:12.256 --> 00:14:14.236
certificate, it is a publicly

00:14:14.236 --> 00:14:15.786
logged signed certificate.

00:14:16.916 --> 00:14:18.156
Now suppose we have a rogue

00:14:18.156 --> 00:14:20.226
certificate authority that

00:14:20.326 --> 00:14:22.286
doesn't publicly expose the

00:14:22.286 --> 00:14:23.836
rogue certificates it's issuing.

00:14:24.726 --> 00:14:26.426
The client will reject that

00:14:26.426 --> 00:14:27.916
because it doesn't have the

00:14:27.916 --> 00:14:30.386
affidavit to attest to it being

00:14:30.476 --> 00:14:31.826
recorded in a public log.

00:14:33.006 --> 00:14:34.286
Starting later this year, we

00:14:34.596 --> 00:14:35.896
will be enforcing this.

00:14:37.456 --> 00:14:39.806
All newly issued TLS

00:14:39.806 --> 00:14:41.726
certificates must include the

00:14:41.726 --> 00:14:43.236
verification that they are

00:14:43.236 --> 00:14:44.096
publicly logged.

00:14:44.486 --> 00:14:46.036
And if they're not, then the

00:14:46.036 --> 00:14:47.056
client will reject it.

00:14:47.536 --> 00:14:49.686
Your apps don't need to make any

00:14:49.686 --> 00:14:51.926
changes, but if you have

00:14:51.926 --> 00:14:53.006
tailored certificates for your

00:14:53.006 --> 00:14:54.996
servers, make sure that your

00:14:54.996 --> 00:14:56.686
certificate authority is

00:14:56.686 --> 00:14:58.186
recording them in the public

00:14:58.306 --> 00:14:59.906
certificate transparency logs.

00:15:00.486 --> 00:15:03.686
Now we have a bit of news for

00:15:04.246 --> 00:15:05.286
hardware developers.

00:15:06.286 --> 00:15:08.396
The Bonjour Conformance Test is

00:15:08.396 --> 00:15:10.776
a tool that lets you verify that

00:15:10.776 --> 00:15:12.386
your hardware devices implement

00:15:12.386 --> 00:15:13.376
Bonjour correctly.

00:15:14.466 --> 00:15:15.946
You need to run this test if you

00:15:15.946 --> 00:15:17.086
want to use the Bonjour

00:15:17.086 --> 00:15:18.796
trademark name and logo on your

00:15:18.796 --> 00:15:19.376
packaging.

00:15:20.256 --> 00:15:21.796
You need to run this test if you

00:15:21.796 --> 00:15:23.826
want to bundle the Bonjour for

00:15:23.866 --> 00:15:26.366
Windows installer with a Windows

00:15:26.366 --> 00:15:27.086
application.

00:15:27.696 --> 00:15:28.896
And if you want to use the

00:15:28.896 --> 00:15:30.736
AirPrint, AirPlay, CarPlay,

00:15:30.736 --> 00:15:32.506
HomeKit logos on your packaging,

00:15:33.046 --> 00:15:34.356
passing the Bonjour Conformance

00:15:34.356 --> 00:15:36.136
Test is a part of the logo

00:15:36.136 --> 00:15:37.976
licensing process because

00:15:37.976 --> 00:15:39.916
reliable Bonjour is an essential

00:15:39.916 --> 00:15:41.006
part of those products.

00:15:41.926 --> 00:15:44.056
But more importantly, the value

00:15:44.056 --> 00:15:44.966
of running the Bonjour

00:15:44.966 --> 00:15:46.996
Conformance Test is it helps you

00:15:46.996 --> 00:15:48.136
improve the quality of your

00:15:48.136 --> 00:15:50.096
products and that makes them

00:15:50.096 --> 00:15:51.856
more reliable which makes your

00:15:51.856 --> 00:15:53.996
customers happy which makes your

00:15:53.996 --> 00:15:55.536
customers not return the product

00:15:55.536 --> 00:15:57.026
to the store because they can't

00:15:57.026 --> 00:15:57.756
make it work.

00:15:58.226 --> 00:15:59.926
And that's what your customers

00:15:59.926 --> 00:16:00.196
want.

00:16:00.296 --> 00:16:01.066
That's what you want.

00:16:01.146 --> 00:16:01.996
And that's what we want.

00:16:02.046 --> 00:16:04.426
We want happy customers having a

00:16:04.426 --> 00:16:05.606
wonderful time with products

00:16:05.606 --> 00:16:06.436
that work reliably.

00:16:06.436 --> 00:16:11.556
Now I want to cover API choices.

00:16:12.596 --> 00:16:15.156
Thirty years ago we had BSD

00:16:15.156 --> 00:16:15.776
Sockets.

00:16:16.396 --> 00:16:18.296
And it was a great API 30 years

00:16:18.296 --> 00:16:18.616
ago.

00:16:19.046 --> 00:16:21.616
But 30 years ago we didn't have

00:16:22.426 --> 00:16:24.476
mobile computers in our pockets.

00:16:24.546 --> 00:16:25.576
We didn't have wireless

00:16:25.576 --> 00:16:26.216
networking.

00:16:26.216 --> 00:16:29.126
We didn't have IPv6.

00:16:29.326 --> 00:16:31.026
We didn't have many computers

00:16:31.026 --> 00:16:32.066
with more than one network

00:16:32.066 --> 00:16:32.746
interface.

00:16:32.896 --> 00:16:34.936
If you had an Ethernet port on

00:16:34.936 --> 00:16:36.176
your computer, that was a fancy

00:16:36.176 --> 00:16:36.716
computer.

00:16:37.376 --> 00:16:40.236
Now 4 billion people around the

00:16:40.236 --> 00:16:42.806
world have a multi-homed IPv6

00:16:43.136 --> 00:16:44.566
wireless battery-powered

00:16:44.566 --> 00:16:46.226
computing device that does power

00:16:46.226 --> 00:16:47.456
management and goes to sleep to

00:16:47.456 --> 00:16:48.116
save energy.

00:16:48.496 --> 00:16:49.716
The world has become a lot more

00:16:49.716 --> 00:16:50.376
complicated.

00:16:52.056 --> 00:16:53.246
Many of you may be using

00:16:53.246 --> 00:16:55.326
third-party libraries which are

00:16:55.376 --> 00:16:56.356
built on that Sockets

00:16:56.356 --> 00:16:57.016
foundation.

00:16:57.686 --> 00:16:59.996
Many more of you may be using

00:16:59.996 --> 00:17:00.816
URLSession.

00:17:01.306 --> 00:17:03.006
And you may have assumed that

00:17:03.006 --> 00:17:05.626
URLSession is also just a wrap

00:17:05.626 --> 00:17:06.556
around Sockets.

00:17:07.906 --> 00:17:09.526
Well, not quite.

00:17:11.006 --> 00:17:13.046
URLSession is actually built

00:17:13.326 --> 00:17:15.445
using Apple's user space

00:17:15.656 --> 00:17:17.386
networking code network

00:17:17.386 --> 00:17:17.856
framework.

00:17:18.346 --> 00:17:21.306
And starting now, in iOS 12, we

00:17:21.306 --> 00:17:23.976
are exposing that same API that

00:17:23.976 --> 00:17:26.056
URLSession uses so that your

00:17:26.056 --> 00:17:29.316
apps can directly use that for

00:17:29.486 --> 00:17:31.986
making TCP connections and other

00:17:31.986 --> 00:17:33.266
appropriate use cases.

00:17:33.526 --> 00:17:35.266
If you're doing things with URLs

00:17:35.266 --> 00:17:37.356
and HTTP GETs, URLSession is

00:17:37.356 --> 00:17:38.716
still your API of choice.

00:17:39.056 --> 00:17:41.116
But for the things URLSession

00:17:41.116 --> 00:17:43.316
doesn't cover, we now expose

00:17:43.316 --> 00:17:45.766
network framework so your apps

00:17:45.766 --> 00:17:46.896
can use that directly.

00:17:47.876 --> 00:17:49.816
And if you're the developer of

00:17:49.816 --> 00:17:50.896
one of these third-party

00:17:50.896 --> 00:17:51.866
libraries, which are very

00:17:51.866 --> 00:17:54.156
popular that are built on BSD

00:17:54.156 --> 00:17:56.606
Sockets, we encourage you to

00:17:56.606 --> 00:17:58.716
look at the network framework

00:17:58.716 --> 00:17:59.216
APIs.

00:17:59.596 --> 00:18:02.016
Move your library over to these

00:18:02.016 --> 00:18:04.326
improved high-performance APIs,

00:18:04.926 --> 00:18:07.036
and give us feedback about how

00:18:07.036 --> 00:18:07.886
that goes for you.

00:18:08.866 --> 00:18:11.086
So to summarize, we really

00:18:11.086 --> 00:18:13.786
strongly recommend here and now

00:18:14.076 --> 00:18:17.646
in 2018 that you avoid using BSD

00:18:17.646 --> 00:18:18.296
Sockets.

00:18:18.686 --> 00:18:20.756
Avoid using libraries that are

00:18:20.756 --> 00:18:22.706
nothing but wrappers around BSD

00:18:22.706 --> 00:18:23.316
Sockets.

00:18:23.766 --> 00:18:25.146
And if you are one of the

00:18:25.146 --> 00:18:27.146
authors of those libraries using

00:18:27.146 --> 00:18:29.456
these older APIs, look at

00:18:29.456 --> 00:18:30.116
switching over.

00:18:30.116 --> 00:18:32.056
Come and meet us in the labs

00:18:32.106 --> 00:18:34.106
this afternoon and tomorrow and

00:18:34.236 --> 00:18:36.246
give us your feedback about what

00:18:36.246 --> 00:18:37.816
it takes to move your libraries

00:18:38.046 --> 00:18:39.076
to new APIs.

00:18:40.076 --> 00:18:41.316
And with that, I would like to

00:18:41.316 --> 00:18:43.106
invite my colleagues Jiten to

00:18:43.106 --> 00:18:44.996
come up on stage and give you

00:18:45.166 --> 00:18:46.816
more details about URLSession.

00:18:47.516 --> 00:18:51.976
[ Applause ]

00:18:52.476 --> 00:18:53.086
>> Thank you, Stuart.

00:18:53.686 --> 00:18:55.176
Good morning everyone.

00:18:55.726 --> 00:18:57.416
My name is Jiten Mehta.

00:18:57.416 --> 00:18:58.706
And I'm an engineer on the CF

00:18:58.706 --> 00:18:59.316
network team.

00:19:00.266 --> 00:19:01.326
Today I'll be talking to you

00:19:01.326 --> 00:19:02.666
about some networking best

00:19:02.666 --> 00:19:03.956
practices for your apps.

00:19:05.396 --> 00:19:07.076
Networking is an essential part

00:19:07.076 --> 00:19:08.386
of every application.

00:19:09.346 --> 00:19:10.616
Each year, you guys do a great

00:19:10.616 --> 00:19:12.276
job of adding awesome features

00:19:12.276 --> 00:19:12.986
to your apps.

00:19:13.406 --> 00:19:14.976
And today I'll be talking to you

00:19:15.136 --> 00:19:16.706
about some simple networking

00:19:16.706 --> 00:19:19.086
details, details that can help

00:19:19.086 --> 00:19:20.236
make your apps successful.

00:19:20.796 --> 00:19:24.836
Our agenda for today is going to

00:19:24.836 --> 00:19:27.296
cover four categories: reducing

00:19:27.296 --> 00:19:29.926
latency, maximizing throughput,

00:19:31.036 --> 00:19:33.396
increasing responsiveness, and

00:19:33.396 --> 00:19:34.876
making better use of system

00:19:34.876 --> 00:19:35.596
resources.

00:19:36.806 --> 00:19:38.506
Before that, let's quickly

00:19:38.506 --> 00:19:40.386
review URLSession, the API

00:19:40.386 --> 00:19:40.976
you've been using.

00:19:45.526 --> 00:19:47.956
URLSession is the recommended

00:19:48.106 --> 00:19:50.306
high-level networking API

00:19:50.686 --> 00:19:52.216
available on all Apple

00:19:52.216 --> 00:19:52.976
platforms.

00:19:54.426 --> 00:19:56.766
URLSession has first-class

00:19:56.766 --> 00:20:00.746
support for HTTP/2 and HTTP/1.1.

00:20:02.056 --> 00:20:04.136
If your app does not use HTTP,

00:20:04.136 --> 00:20:05.966
we have support for

00:20:06.066 --> 00:20:09.226
URLSessionStreamTask, an API

00:20:09.226 --> 00:20:11.056
that allows you to make secure

00:20:11.056 --> 00:20:12.946
TCP connections to a server over

00:20:13.256 --> 00:20:14.786
which you can build your

00:20:14.786 --> 00:20:15.796
arbitrary protocol.

00:20:17.136 --> 00:20:18.656
That's URLSession.

00:20:19.716 --> 00:20:20.866
Let's move on to our first

00:20:20.866 --> 00:20:23.926
agenda item: reducing latency.

00:20:25.296 --> 00:20:26.246
Let's suppose you and your

00:20:26.246 --> 00:20:28.096
friends go to a restaurant where

00:20:28.226 --> 00:20:29.706
the waiter walks up to you and

00:20:29.706 --> 00:20:31.296
you say, "Can I get a glass of

00:20:31.296 --> 00:20:31.866
water please?"

00:20:32.746 --> 00:20:34.576
The waiter say, "Sure," walks

00:20:34.576 --> 00:20:35.896
away, fetches you a glass of

00:20:35.896 --> 00:20:36.196
water.

00:20:37.016 --> 00:20:38.366
Your friend then says, "Can I

00:20:38.366 --> 00:20:39.406
get a glass of water too?"

00:20:40.066 --> 00:20:41.386
The waiter says, "Sure," walks

00:20:41.386 --> 00:20:42.886
away, and fetches your friend a

00:20:42.886 --> 00:20:43.876
glass of water.

00:20:44.526 --> 00:20:45.576
Wouldn't it be faster if the

00:20:45.576 --> 00:20:46.836
waiter took everyone's order at

00:20:46.836 --> 00:20:48.556
the same time and reduce the

00:20:48.556 --> 00:20:49.486
number of round trips?

00:20:50.816 --> 00:20:52.286
The idea to reduce latency is

00:20:52.286 --> 00:20:52.746
simple.

00:20:53.536 --> 00:20:54.966
To reduce the number of back and

00:20:54.966 --> 00:20:56.116
forths when you fetch a

00:20:56.116 --> 00:20:56.696
resource.

00:20:57.626 --> 00:20:59.896
Let's see how your apps can do

00:21:01.836 --> 00:21:01.936
this.

00:21:02.136 --> 00:21:03.796
First, let's look at some issues

00:21:03.796 --> 00:21:05.446
with HTTP/1.1.

00:21:06.896 --> 00:21:07.846
Your app wants to fetch a

00:21:07.846 --> 00:21:10.486
resource, you can create a

00:21:10.486 --> 00:21:13.196
URLSession task and call resume.

00:21:14.146 --> 00:21:16.626
URLSession will create a new

00:21:16.626 --> 00:21:17.976
connection for you, which

00:21:17.976 --> 00:21:21.136
involves DNS, TCP and TLS.

00:21:22.626 --> 00:21:23.826
Once the connection to the

00:21:23.826 --> 00:21:25.606
server is established, we will

00:21:25.606 --> 00:21:26.656
send out your request.

00:21:27.256 --> 00:21:30.046
We will then wait to get a

00:21:30.046 --> 00:21:32.446
response from the server.

00:21:32.656 --> 00:21:34.176
This is the network idle time

00:21:34.356 --> 00:21:35.666
when your app is not doing any

00:21:35.666 --> 00:21:37.096
kind of networking, waiting to

00:21:37.096 --> 00:21:40.486
get a response from the server.

00:21:40.596 --> 00:21:42.616
Once we get a response, we will

00:21:42.616 --> 00:21:44.376
call your completion block or

00:21:44.376 --> 00:21:46.156
message your delegate indicating

00:21:46.156 --> 00:21:47.366
that the load has finished.

00:21:47.946 --> 00:21:50.446
Let's suppose in the middle of

00:21:50.446 --> 00:21:51.676
this load your app wants to

00:21:51.676 --> 00:21:53.086
fetch another resource from the

00:21:53.086 --> 00:21:53.756
same server.

00:21:54.376 --> 00:21:56.346
You can create another

00:21:56.406 --> 00:21:58.776
URLSession task called resume

00:21:59.346 --> 00:22:01.766
and URLSession will create a new

00:22:01.766 --> 00:22:03.126
connection to fetch this

00:22:03.126 --> 00:22:04.726
resource since it does not have

00:22:04.726 --> 00:22:06.006
an idle connection in its

00:22:06.006 --> 00:22:06.676
connection pool.

00:22:08.136 --> 00:22:09.336
If your app wants to fetch yet

00:22:09.336 --> 00:22:10.576
another resource from the same

00:22:10.576 --> 00:22:12.616
server, you can create another

00:22:12.616 --> 00:22:14.726
URLSession task and call resume

00:22:15.126 --> 00:22:16.196
and we will create another

00:22:16.196 --> 00:22:17.236
connection to fetch the

00:22:17.236 --> 00:22:17.856
resource.

00:22:18.376 --> 00:22:21.236
In this example, I've shown you

00:22:21.236 --> 00:22:22.616
that we've created three

00:22:22.616 --> 00:22:24.236
different connections to fetch

00:22:24.306 --> 00:22:25.866
these resources from the same

00:22:25.866 --> 00:22:26.356
server.

00:22:27.726 --> 00:22:29.246
If you notice, we've spent a lot

00:22:29.246 --> 00:22:31.076
of time opening new connections.

00:22:31.606 --> 00:22:33.466
Let's see how this would look

00:22:33.466 --> 00:22:34.926
like if you used a single

00:22:34.926 --> 00:22:35.716
connection instead.

00:22:38.416 --> 00:22:39.896
This is a single connection

00:22:39.896 --> 00:22:40.306
case.

00:22:41.006 --> 00:22:42.436
We saved a lot of time by not

00:22:42.436 --> 00:22:44.366
opening new connections, but

00:22:44.366 --> 00:22:45.456
there is another problem here.

00:22:46.636 --> 00:22:48.406
The request number two which is

00:22:48.406 --> 00:22:50.416
the green request has to wait

00:22:50.586 --> 00:22:52.316
until response number one is

00:22:52.316 --> 00:22:53.056
fully received.

00:22:54.216 --> 00:22:55.596
The same problem applies to

00:22:55.596 --> 00:22:57.196
request number three which is

00:22:57.196 --> 00:22:59.016
the orange request which has to

00:22:59.016 --> 00:23:01.116
wait until response number two

00:23:01.356 --> 00:23:02.286
is fully received.

00:23:03.436 --> 00:23:05.666
This problem is known as HTTP

00:23:05.666 --> 00:23:06.746
head-of-line blocking.

00:23:08.096 --> 00:23:10.406
Consider moving to HTTP/2.

00:23:11.676 --> 00:23:14.126
HTTP/2 uses a single connection,

00:23:14.496 --> 00:23:16.166
and it also solves the HTTP

00:23:16.166 --> 00:23:17.866
head-of-line blocking problem.

00:23:18.396 --> 00:23:21.956
HTTP/2 multiplexes multiple

00:23:21.956 --> 00:23:24.156
streams over a single connection

00:23:24.696 --> 00:23:26.756
allowing you to receive parallel

00:23:26.756 --> 00:23:28.576
responses in an [inaudible]

00:23:28.576 --> 00:23:29.136
fashion.

00:23:29.666 --> 00:23:32.456
Let's analyze this example a

00:23:32.456 --> 00:23:34.966
little more to see how HTTP/2

00:23:35.026 --> 00:23:37.166
performs better than HTTP/1.1.

00:23:39.456 --> 00:23:41.406
Pay attention to the times when

00:23:41.406 --> 00:23:42.656
your app wants to fetch a

00:23:42.656 --> 00:23:44.806
resource and the time when the

00:23:44.806 --> 00:23:45.966
request is sent out.

00:23:47.206 --> 00:23:50.156
In the HTTP/1.1 case, there is a

00:23:50.156 --> 00:23:52.306
significant delay between the

00:23:52.306 --> 00:23:53.676
time when your app desires a

00:23:53.676 --> 00:23:55.126
resource and the time the

00:23:55.126 --> 00:23:56.106
request is sent out.

00:23:57.336 --> 00:24:00.336
HTTP/2 can significantly reduce

00:24:00.336 --> 00:24:02.916
this delay and allows us to send

00:24:02.916 --> 00:24:04.636
the request almost immediately

00:24:04.636 --> 00:24:06.256
when the app desires the

00:24:06.256 --> 00:24:06.866
resource.

00:24:07.306 --> 00:24:11.976
Also pay attention to these gray

00:24:11.976 --> 00:24:12.576
boxes.

00:24:13.446 --> 00:24:14.946
If you recall, this is the

00:24:14.946 --> 00:24:17.016
network idle time when your app

00:24:17.016 --> 00:24:18.546
is not doing any networking,

00:24:18.836 --> 00:24:20.426
waiting to get a response from

00:24:20.506 --> 00:24:21.476
the server.

00:24:22.736 --> 00:24:25.606
HTTP/2 can significantly reduce

00:24:25.656 --> 00:24:27.876
this network idle time allowing

00:24:27.876 --> 00:24:29.376
you to better utilize the

00:24:29.376 --> 00:24:31.936
bandwidth and load the resources

00:24:31.936 --> 00:24:32.596
much faster.

00:24:35.476 --> 00:24:37.236
We just discussed many benefits

00:24:37.236 --> 00:24:40.186
of using HTTP/2 over HTTP/1.1,

00:24:40.636 --> 00:24:41.726
but let's quickly summarize

00:24:41.726 --> 00:24:41.926
them.

00:24:43.166 --> 00:24:45.086
HTTP/2 solves the head-of-line

00:24:45.086 --> 00:24:46.456
blocking problem at the HTTP

00:24:46.456 --> 00:24:47.146
layer.

00:24:47.476 --> 00:24:49.696
And it also allows you to better

00:24:49.696 --> 00:24:50.686
utilize the bandwidth.

00:24:52.286 --> 00:24:54.786
If your apps use URLSession, you

00:24:54.786 --> 00:24:55.826
don't need to make any

00:24:55.826 --> 00:24:57.016
client-side changes.

00:24:57.926 --> 00:25:00.556
Simply enable HTTP/2 on your

00:25:00.556 --> 00:25:01.646
servers and you will see these

00:25:01.646 --> 00:25:02.246
benefits.

00:25:03.736 --> 00:25:06.246
By adopting HTTP/2, you can also

00:25:06.246 --> 00:25:07.996
get some server-side savings

00:25:08.466 --> 00:25:10.296
because devices running your

00:25:10.296 --> 00:25:12.026
apps will now make fewer

00:25:12.026 --> 00:25:15.066
connections to the servers.

00:25:15.166 --> 00:25:17.286
This year, we have something new

00:25:17.386 --> 00:25:19.346
in URLSession that is going to

00:25:19.346 --> 00:25:23.946
add to the advantages of HTTP/2.

00:25:24.196 --> 00:25:26.496
Introducing HTTP/2 Connection

00:25:26.496 --> 00:25:28.106
Coalescing for URLSession.

00:25:28.586 --> 00:25:32.376
HTTP/2 Connection Coalescing is

00:25:32.376 --> 00:25:33.846
going to increase connection to

00:25:33.846 --> 00:25:35.036
use even more.

00:25:36.556 --> 00:25:39.226
Since your apps are not going to

00:25:39.226 --> 00:25:40.886
be opening new connections, they

00:25:40.886 --> 00:25:43.656
will become more responsive to

00:25:43.656 --> 00:25:44.276
your users.

00:25:45.636 --> 00:25:46.906
Starting with the [inaudible],

00:25:46.906 --> 00:25:50.866
HTTP/2 Connection Coalescing is

00:25:50.866 --> 00:25:52.246
going to be automatically done

00:25:52.246 --> 00:25:54.186
on for all your apps using

00:25:54.186 --> 00:25:55.026
URLSession.

00:25:56.296 --> 00:25:57.976
Now let's see how Connection

00:25:57.976 --> 00:25:59.676
Coalescing decides to reuse

00:25:59.676 --> 00:26:00.356
connections.

00:26:00.886 --> 00:26:05.516
Let's suppose you have an app

00:26:05.516 --> 00:26:06.806
and that app wants to fetch a

00:26:06.806 --> 00:26:09.586
resource from menu.example.com.

00:26:10.746 --> 00:26:12.526
We open a connection with the

00:26:12.606 --> 00:26:13.836
server, and the server presents

00:26:13.836 --> 00:26:14.806
us with the certificate.

00:26:16.076 --> 00:26:17.126
If your app wants to fetch

00:26:17.126 --> 00:26:18.206
another resource from

00:26:18.446 --> 00:26:21.026
delivery.example.com, we open

00:26:21.026 --> 00:26:22.486
another connection and the

00:26:22.486 --> 00:26:23.556
server presents us with another

00:26:23.556 --> 00:26:24.066
certificate.

00:26:25.436 --> 00:26:27.526
This is the old behavior where

00:26:27.646 --> 00:26:29.556
URLSession would create two

00:26:29.556 --> 00:26:31.366
connections to fetch these

00:26:31.366 --> 00:26:32.896
resources from the given host

00:26:32.896 --> 00:26:33.236
names.

00:26:33.726 --> 00:26:36.836
But if you look closely, the

00:26:36.936 --> 00:26:39.016
first certificate presented to

00:26:39.016 --> 00:26:41.596
us covers all the subdomains

00:26:41.796 --> 00:26:44.606
under example.com which means

00:26:44.946 --> 00:26:48.536
delivery.example.com is covered

00:26:48.566 --> 00:26:50.316
by this first certificate.

00:26:50.356 --> 00:26:51.506
Also notice that

00:26:51.716 --> 00:26:54.146
delivery.example.com, it results

00:26:54.146 --> 00:26:55.906
to the same IP address as the

00:26:55.906 --> 00:26:56.886
first connection.

00:26:57.426 --> 00:27:00.406
At this point, it's safe for us

00:27:00.406 --> 00:27:01.486
to assume we're talking to the

00:27:01.486 --> 00:27:03.796
same endpoint and reuse the

00:27:03.796 --> 00:27:05.726
connection instead of opening a

00:27:05.726 --> 00:27:07.346
new one when we want to fetch

00:27:07.346 --> 00:27:08.406
the second resource.

00:27:09.126 --> 00:27:10.506
This saves us time by not

00:27:10.506 --> 00:27:11.936
opening a new connection and

00:27:11.936 --> 00:27:13.316
makes the load much faster.

00:27:13.896 --> 00:27:16.086
HTTP/2 [inaudible] HTTP/2

00:27:16.086 --> 00:27:20.276
Connection Coalescing new in iOS

00:27:20.306 --> 00:27:22.156
12 and macOS Mojave.

00:27:23.416 --> 00:27:26.296
Now let's see how using fewer

00:27:26.386 --> 00:27:28.716
URLSession objects can help

00:27:28.716 --> 00:27:29.826
reduce latency.

00:27:30.356 --> 00:27:34.656
All the benefits of connections

00:27:34.656 --> 00:27:36.876
we use that we just discussed in

00:27:36.876 --> 00:27:38.876
the previous slides are

00:27:38.876 --> 00:27:41.306
applicable only if you use the

00:27:41.306 --> 00:27:43.546
same URLSession object to create

00:27:43.546 --> 00:27:44.916
your tasks.

00:27:47.016 --> 00:27:48.876
It's also important to know that

00:27:48.936 --> 00:27:51.586
every URLSession object has a

00:27:51.586 --> 00:27:53.206
connection pool and when you

00:27:53.206 --> 00:27:54.506
create multiple of these

00:27:54.506 --> 00:27:56.106
URLSession objects, you don't

00:27:56.106 --> 00:27:57.606
get any benefit of connection to

00:27:57.606 --> 00:27:58.026
use.

00:27:59.066 --> 00:28:01.306
It's also important to note that

00:28:01.356 --> 00:28:02.726
the URLSession objects are

00:28:02.726 --> 00:28:04.846
fairly expensive to create and

00:28:04.846 --> 00:28:06.206
have a non-trivial memory

00:28:06.206 --> 00:28:06.676
footprint.

00:28:08.036 --> 00:28:09.776
As we have in the past, we

00:28:09.816 --> 00:28:11.726
continue to advise you to use

00:28:11.726 --> 00:28:13.466
fewer URLSession objects.

00:28:13.986 --> 00:28:17.496
Let's move on to our next topic

00:28:17.496 --> 00:28:19.416
for the day: maximizing

00:28:19.416 --> 00:28:19.796
throughput.

00:28:19.796 --> 00:28:22.596
Coming back to our restaurant

00:28:22.596 --> 00:28:23.156
example.

00:28:23.986 --> 00:28:25.956
The waiter checks up on you and

00:28:25.956 --> 00:28:27.766
you say, "Can I get an order of

00:28:28.196 --> 00:28:30.206
grilled chicken tossed in creamy

00:28:30.206 --> 00:28:32.006
tomato onion gravy made with a

00:28:32.006 --> 00:28:32.646
lot of butter?"

00:28:33.906 --> 00:28:34.846
Now that's a mouthful.

00:28:35.656 --> 00:28:36.596
Wouldn't it be easier if you

00:28:36.596 --> 00:28:38.016
just said, "Can I get butter

00:28:38.016 --> 00:28:38.356
chicken?"

00:28:39.936 --> 00:28:41.556
The idea to maximize throughput

00:28:41.556 --> 00:28:43.216
is the same where you reduce the

00:28:43.216 --> 00:28:44.296
number of bytes that you

00:28:44.296 --> 00:28:45.766
transmit when you want to fetch

00:28:45.816 --> 00:28:46.536
a resource.

00:28:47.306 --> 00:28:48.686
Let's see how your apps can do

00:28:48.686 --> 00:28:49.036
this.

00:28:49.116 --> 00:28:52.796
Let's look at a couple of ways

00:28:52.796 --> 00:28:55.086
to reduce the request size.

00:28:55.956 --> 00:28:58.246
Pay attention to HTTP cookies.

00:28:59.076 --> 00:29:01.646
They are not free and have a

00:29:01.646 --> 00:29:03.216
non-trivial cost in storing and

00:29:03.216 --> 00:29:03.846
looking them up.

00:29:05.256 --> 00:29:06.836
Cookies are attached to all the

00:29:06.836 --> 00:29:08.676
requests that match the domain

00:29:08.676 --> 00:29:09.946
and path attribute.

00:29:10.506 --> 00:29:11.856
And it can quickly increase your

00:29:11.856 --> 00:29:12.636
request size.

00:29:13.996 --> 00:29:15.946
Please use the domain and path

00:29:15.946 --> 00:29:17.966
attribute wisely to make sure

00:29:17.966 --> 00:29:19.826
cookies required by the servers

00:29:19.896 --> 00:29:21.306
are attached to your requests.

00:29:22.526 --> 00:29:23.756
Use of smaller cookies when

00:29:23.756 --> 00:29:25.336
possible, and delete these

00:29:25.336 --> 00:29:26.606
cookies when you no longer need

00:29:26.606 --> 00:29:26.846
them.

00:29:28.226 --> 00:29:29.896
Try to save some state on the

00:29:29.896 --> 00:29:31.686
server so you can reduce the

00:29:31.686 --> 00:29:33.246
number of client-side cookies.

00:29:33.716 --> 00:29:36.856
Also consider moving to HTTP/2

00:29:37.326 --> 00:29:38.766
to get benefits of header

00:29:38.766 --> 00:29:39.356
compression.

00:29:39.906 --> 00:29:42.476
Let's talk a little more about

00:29:42.476 --> 00:29:43.176
compression.

00:29:43.706 --> 00:29:48.646
HTTP compression, also known as

00:29:48.646 --> 00:29:51.126
content and coding, is simply

00:29:51.176 --> 00:29:53.026
compressing the data that is

00:29:53.026 --> 00:29:54.616
shuttled between the client and

00:29:54.726 --> 00:29:56.096
the server.

00:29:56.096 --> 00:29:57.666
This allows us to better utilize

00:29:57.696 --> 00:29:58.276
the bandwidth.

00:29:59.706 --> 00:30:02.046
The algorithms that URLSession

00:30:02.246 --> 00:30:05.196
supports and recommends are Gzip

00:30:05.196 --> 00:30:05.796
and Brotli.

00:30:07.226 --> 00:30:09.756
Gzip is widely supported and is

00:30:09.756 --> 00:30:10.706
relatively fast.

00:30:11.906 --> 00:30:13.616
Brotli support was introduced

00:30:13.616 --> 00:30:16.686
last year in iOS 11 and macOS

00:30:16.686 --> 00:30:17.356
High Sierra.

00:30:18.626 --> 00:30:20.076
Brotli is optimized for

00:30:20.076 --> 00:30:22.136
structured text and HTML.

00:30:22.136 --> 00:30:24.356
And it has the best compression

00:30:24.356 --> 00:30:26.726
ratio on short data.

00:30:27.416 --> 00:30:29.196
Please enable compression on

00:30:29.196 --> 00:30:30.726
your servers if you haven't done

00:30:30.726 --> 00:30:31.476
so already.

00:30:32.016 --> 00:30:34.986
Let's move on to our next topic

00:30:34.986 --> 00:30:37.096
for the day: increasing

00:30:37.096 --> 00:30:37.926
responsiveness.

00:30:39.146 --> 00:30:40.566
Coming back to our restaurant

00:30:40.566 --> 00:30:40.926
example.

00:30:40.926 --> 00:30:42.906
Here you are here in San Jose

00:30:42.906 --> 00:30:44.656
for WWDC, and you decide to meet

00:30:44.656 --> 00:30:45.986
up with some old friends.

00:30:46.116 --> 00:30:48.086
You and your friends are sitting

00:30:48.086 --> 00:30:49.056
at the restaurant table.

00:30:49.636 --> 00:30:51.456
Your drinks are here, but you

00:30:51.456 --> 00:30:52.746
would like some more time to

00:30:52.746 --> 00:30:53.866
catch up with your friends

00:30:53.966 --> 00:30:55.216
before the food comes out.

00:30:56.216 --> 00:30:57.346
You can simply tell the waiter,

00:30:58.076 --> 00:30:58.956
"Can you please bring out our

00:30:58.956 --> 00:30:59.926
food after some time?

00:30:59.926 --> 00:31:01.216
We are in no rush."

00:31:02.226 --> 00:31:03.646
The same concept can be applied

00:31:03.646 --> 00:31:05.366
to responsiveness where you mark

00:31:05.366 --> 00:31:06.866
your tasks with priority

00:31:07.096 --> 00:31:08.456
depending on the other tasks

00:31:08.506 --> 00:31:09.166
that you're doing.

00:31:10.106 --> 00:31:11.306
Let's see how your apps can

00:31:11.306 --> 00:31:12.186
benefit from this.

00:31:12.566 --> 00:31:16.936
You might be familiar with these

00:31:16.936 --> 00:31:19.756
five QoS classes associated with

00:31:19.756 --> 00:31:22.026
dispatch queues and NSOperation

00:31:22.026 --> 00:31:22.666
objects.

00:31:23.616 --> 00:31:24.976
Data [inaudible] the CPU

00:31:24.976 --> 00:31:26.096
scheduling policy.

00:31:27.656 --> 00:31:31.156
URLSession is QoS-aware which

00:31:31.156 --> 00:31:33.356
means it will capture the QoS

00:31:33.426 --> 00:31:35.176
off the queue on which you call

00:31:35.176 --> 00:31:36.146
task.resume.

00:31:37.156 --> 00:31:38.646
And all the messages that it

00:31:38.646 --> 00:31:40.296
sends to your delegates will

00:31:40.296 --> 00:31:41.086
respect this QoS.

00:31:41.086 --> 00:31:44.196
Let's take an example.

00:31:45.246 --> 00:31:46.986
If your app wants to fetch some

00:31:46.986 --> 00:31:48.786
data which is not time critical,

00:31:49.406 --> 00:31:51.476
consider resuming that task on a

00:31:51.476 --> 00:31:53.356
queue which has background QoS

00:31:54.026 --> 00:31:56.056
to make sure this task does not

00:31:56.056 --> 00:31:58.066
contend for CPU with other

00:31:58.066 --> 00:31:59.436
higher priority work that your

00:31:59.436 --> 00:32:04.016
app might be doing.

00:32:04.186 --> 00:32:06.086
Network service type is the

00:32:06.086 --> 00:32:08.156
property on the URLSession

00:32:08.226 --> 00:32:10.946
configuration object that allows

00:32:10.946 --> 00:32:12.916
you to classify your network

00:32:12.916 --> 00:32:15.596
traffic that helps the system

00:32:15.596 --> 00:32:17.376
prioritize the data leaving the

00:32:17.376 --> 00:32:17.926
device.

00:32:19.276 --> 00:32:21.236
This year, we have a new network

00:32:21.236 --> 00:32:22.276
service type, the

00:32:22.276 --> 00:32:23.346
responsiveData.

00:32:24.656 --> 00:32:26.676
ResponsiveData is slightly

00:32:26.676 --> 00:32:28.596
higher than the default type but

00:32:28.596 --> 00:32:30.416
should be used judiciously.

00:32:31.446 --> 00:32:32.906
An example where you might want

00:32:32.906 --> 00:32:35.606
to use responsiveData is if you

00:32:35.606 --> 00:32:37.856
have a shopping app and you are

00:32:37.856 --> 00:32:38.786
on the checkout page.

00:32:39.586 --> 00:32:40.816
You might want to mark your

00:32:40.886 --> 00:32:42.346
payment request with the

00:32:42.346 --> 00:32:44.376
responsiveData to make sure you

00:32:44.376 --> 00:32:45.986
get a good response from the

00:32:46.496 --> 00:32:46.636
server.

00:32:48.096 --> 00:32:49.766
Traffic marked with the network

00:32:49.766 --> 00:32:51.676
service type property will

00:32:51.676 --> 00:32:53.986
maintain this tag across all the

00:32:53.986 --> 00:32:56.386
hops when on a Cisco Fast Lane

00:32:56.386 --> 00:32:56.886
network.

00:32:58.026 --> 00:32:59.516
For more information on this

00:32:59.516 --> 00:33:02.226
API, please view the WWDC

00:33:02.226 --> 00:33:08.086
session from the year 2016.

00:33:08.086 --> 00:33:09.736
Last year, we introduced the

00:33:09.736 --> 00:33:11.556
URLSession Adaptable

00:33:11.556 --> 00:33:12.896
Connectivity API

00:33:13.376 --> 00:33:14.596
waitsForConnectivity.

00:33:15.976 --> 00:33:18.106
waitsForConnectivity will simply

00:33:18.106 --> 00:33:20.736
wait instead of failing the load

00:33:21.176 --> 00:33:22.616
when your task does not have

00:33:22.666 --> 00:33:23.246
connectivity.

00:33:24.606 --> 00:33:26.006
In the past, you've been using

00:33:26.006 --> 00:33:28.016
STNeworkReachability to do a

00:33:28.016 --> 00:33:29.726
preflight check before you send

00:33:29.726 --> 00:33:30.426
out your request.

00:33:31.126 --> 00:33:32.486
But as Stuart pointed out a few

00:33:32.486 --> 00:33:34.296
slides ago, there is a race

00:33:34.296 --> 00:33:36.026
condition where the system might

00:33:36.026 --> 00:33:37.046
tell you that you have

00:33:37.046 --> 00:33:39.186
connectivity to a server but by

00:33:39.186 --> 00:33:40.406
the time you create and send

00:33:40.406 --> 00:33:41.946
your request, you've lost your

00:33:41.946 --> 00:33:43.336
chance and you're no longer

00:33:43.336 --> 00:33:45.826
connected to the server.

00:33:45.826 --> 00:33:46.776
We recommend using

00:33:46.776 --> 00:33:48.406
waitsForConnectivity which will

00:33:48.406 --> 00:33:50.316
simply send out your request as

00:33:50.316 --> 00:33:51.436
soon as a connection to the

00:33:51.436 --> 00:33:52.496
server is available.

00:33:53.946 --> 00:33:55.816
Optionally, you can implement

00:33:56.036 --> 00:33:58.066
the taskIsWaitigForConnectivity

00:33:58.066 --> 00:33:59.786
delegate method which gets

00:33:59.786 --> 00:34:01.116
called when your task does not

00:34:01.116 --> 00:34:01.896
have connectivity.

00:34:03.286 --> 00:34:04.876
This can be helpful to present

00:34:04.876 --> 00:34:06.426
the user with a different flow

00:34:06.686 --> 00:34:09.016
or an offline UI for better user

00:34:09.016 --> 00:34:09.766
experience.

00:34:11.376 --> 00:34:13.085
For more information on this

00:34:13.085 --> 00:34:15.396
API, please view the WWDC

00:34:15.396 --> 00:34:16.576
session from last year where

00:34:16.766 --> 00:34:18.246
this API was introduced.

00:34:18.246 --> 00:34:21.716
Now let's move on to our last

00:34:21.716 --> 00:34:23.676
topic for the day: making better

00:34:23.676 --> 00:34:25.496
use of system resources.

00:34:26.606 --> 00:34:27.596
Coming back to our restaurant

00:34:27.596 --> 00:34:28.045
example.

00:34:28.496 --> 00:34:30.896
You like the food at this place

00:34:31.036 --> 00:34:32.505
so much that you decide to come

00:34:32.505 --> 00:34:33.755
here for dinner the next day.

00:34:35.025 --> 00:34:36.366
The restaurant has a delivery

00:34:36.366 --> 00:34:38.255
service where you can place your

00:34:38.255 --> 00:34:40.166
order today and they will

00:34:40.166 --> 00:34:41.275
deliver the food to your house

00:34:41.275 --> 00:34:41.896
the next day.

00:34:42.735 --> 00:34:44.616
This not only saves you the time

00:34:44.616 --> 00:34:46.376
and effort to go and pick up

00:34:46.376 --> 00:34:48.366
your food but it also helps the

00:34:48.366 --> 00:34:50.056
restaurant prioritize their work

00:34:50.226 --> 00:34:51.295
based on your deadline.

00:34:52.496 --> 00:34:54.366
Let's see how your apps can make

00:34:54.366 --> 00:34:56.266
better use of system resources

00:34:56.266 --> 00:34:57.326
to be more efficient.

00:35:00.056 --> 00:35:02.206
Background sessions have upload

00:35:02.206 --> 00:35:03.456
and download tasks.

00:35:04.456 --> 00:35:06.156
These tasks use system

00:35:06.156 --> 00:35:08.046
intelligence to decide when to

00:35:08.046 --> 00:35:09.876
start and when to stop a

00:35:09.876 --> 00:35:11.926
download based on various

00:35:11.926 --> 00:35:14.486
factors like battery, CPU,

00:35:14.716 --> 00:35:15.726
Wi-Fi, etcetera.

00:35:17.616 --> 00:35:19.276
If your app wants to fetch a

00:35:19.276 --> 00:35:21.416
large file, consider using

00:35:21.416 --> 00:35:22.346
background sessions.

00:35:23.736 --> 00:35:26.036
These tasks run out of process

00:35:26.836 --> 00:35:28.276
which means your download will

00:35:28.276 --> 00:35:30.676
continue even when your app is

00:35:30.676 --> 00:35:31.766
in a suspended state.

00:35:33.036 --> 00:35:34.476
For more information on

00:35:34.476 --> 00:35:36.246
background sessions, please view

00:35:36.246 --> 00:35:38.096
the WWDC session from the year

00:35:38.156 --> 00:35:42.676
2014.

00:35:42.796 --> 00:35:44.216
Caching is a great way of

00:35:44.276 --> 00:35:46.576
reducing latency but it's

00:35:46.576 --> 00:35:48.526
important to note that caching

00:35:48.526 --> 00:35:50.076
might result in disk IO.

00:35:51.366 --> 00:35:52.816
In the real world, we've seen

00:35:52.816 --> 00:35:54.596
some apps write several

00:35:54.596 --> 00:35:56.746
gigabytes of data to disk each

00:35:56.746 --> 00:35:58.656
day which can cause severe flash

00:35:58.656 --> 00:35:59.706
storage degradation.

00:36:01.076 --> 00:36:02.286
Please don't cache unique

00:36:02.286 --> 00:36:02.746
content.

00:36:04.196 --> 00:36:05.166
Let's take an example.

00:36:06.096 --> 00:36:08.246
Let's suppose you have an app, a

00:36:08.246 --> 00:36:09.856
dating app, and you are

00:36:09.856 --> 00:36:11.076
responsible for the networking

00:36:11.076 --> 00:36:13.086
code of the app.

00:36:13.086 --> 00:36:15.136
This app loads user profiles

00:36:15.486 --> 00:36:17.356
with high-resolution images.

00:36:18.516 --> 00:36:20.206
It might be wasteful to cache

00:36:20.206 --> 00:36:21.826
these high-resolution images

00:36:22.346 --> 00:36:23.636
because the user might swipe

00:36:23.666 --> 00:36:25.286
left, move on to the next

00:36:25.286 --> 00:36:27.236
profile, which means that the

00:36:27.236 --> 00:36:28.786
images that you just cached are

00:36:28.846 --> 00:36:30.026
probably not going to be

00:36:30.026 --> 00:36:30.756
requested again.

00:36:32.076 --> 00:36:33.446
Please consider making

00:36:33.476 --> 00:36:35.396
client-side changes by adopting

00:36:35.396 --> 00:36:37.296
the willChacheResponse delegate

00:36:37.296 --> 00:36:39.596
method to decide what resources

00:36:39.596 --> 00:36:40.396
should be cached.

00:36:41.886 --> 00:36:43.896
If you own the servers, please

00:36:43.896 --> 00:36:45.436
consider using cache control

00:36:45.436 --> 00:36:48.016
headers to decide what resources

00:36:48.016 --> 00:36:48.826
should be cacheable.

00:36:49.346 --> 00:36:53.006
Let's quickly go over some of

00:36:53.006 --> 00:36:54.246
the key points that we discussed

00:36:54.246 --> 00:36:54.506
today.

00:36:55.346 --> 00:36:57.286
Number one, order all your food

00:36:57.286 --> 00:36:58.316
at the same time when you go to

00:36:58.316 --> 00:36:58.836
a restaurant.

00:36:59.166 --> 00:37:00.766
I'm just kidding.

00:37:01.666 --> 00:37:03.976
Move to HTTP/2 today to get wins

00:37:03.976 --> 00:37:05.326
like header compression,

00:37:05.546 --> 00:37:07.116
connection coalescing and no

00:37:07.116 --> 00:37:07.986
head-of-line blocking.

00:37:08.506 --> 00:37:12.596
Use fewer URLSession objects to

00:37:12.596 --> 00:37:14.346
reduce latency by reusing

00:37:14.346 --> 00:37:15.076
connections.

00:37:15.826 --> 00:37:17.816
This also reduces the memory

00:37:17.816 --> 00:37:19.666
footprint so it's better use of

00:37:19.666 --> 00:37:20.726
system resources.

00:37:21.176 --> 00:37:23.936
Reduce the request size to

00:37:24.236 --> 00:37:25.456
maximize throughput.

00:37:27.316 --> 00:37:29.736
Pay attention to QoS to increase

00:37:29.736 --> 00:37:31.386
the responsiveness of your apps.

00:37:32.216 --> 00:37:34.146
And finally use background

00:37:34.146 --> 00:37:35.896
sessions when you can to make

00:37:35.896 --> 00:37:37.856
better use of system resources.

00:37:39.536 --> 00:37:40.936
For more information on this

00:37:40.936 --> 00:37:42.296
session, please visit this

00:37:42.296 --> 00:37:42.726
website.

00:37:43.766 --> 00:37:45.006
Now we'll have a short break.

00:37:45.696 --> 00:37:46.796
And after the break, we'll

00:37:46.796 --> 00:37:47.856
introduce you to network

00:37:47.856 --> 00:37:49.856
framework, a modern alternative

00:37:49.856 --> 00:37:50.556
to Sockets.

00:37:51.246 --> 00:37:52.596
I would love to see you all at

00:37:52.596 --> 00:37:54.426
the networking labs which are

00:37:54.426 --> 00:37:55.366
going to be held today and

00:37:55.366 --> 00:37:55.856
tomorrow.

00:37:57.236 --> 00:37:58.546
Thank you all for being here.

00:37:58.546 --> 00:38:00.326
And I hope everyone has a great

00:38:00.326 --> 00:38:01.306
rest of the conference.

00:38:02.508 --> 00:38:04.508
[ Applause ]
WEBVTT

00:00:07.016 --> 00:00:15.500
[ Music ]

00:00:30.516 --> 00:00:35.816
[ Applause ]

00:00:36.316 --> 00:00:37.416
>> Good afternoon, everyone!

00:00:38.186 --> 00:00:39.896
Welcome to Behind the Scenes of

00:00:39.896 --> 00:00:41.176
the Xcode Build Process.

00:00:41.896 --> 00:00:43.356
My name is Jake Petroules, and

00:00:43.356 --> 00:00:44.606
I'm an engineer on the Xcode

00:00:44.606 --> 00:00:45.486
Build System Team.

00:00:45.916 --> 00:00:46.746
And today we're going to be

00:00:46.746 --> 00:00:48.666
exploring the Xcode build

00:00:48.666 --> 00:00:49.196
process.

00:00:49.196 --> 00:00:52.326
I'll start by telling you all

00:00:52.326 --> 00:00:53.666
about Xcode 10's new build

00:00:53.666 --> 00:00:54.746
system which is written from

00:00:54.746 --> 00:00:55.666
scratch in Swift.

00:00:55.886 --> 00:00:56.806
And provides improved

00:00:56.806 --> 00:00:58.246
performance and reliability.

00:00:58.986 --> 00:01:00.426
We'll answer questions like what

00:01:00.426 --> 00:01:01.686
exactly happens when you press

00:01:01.686 --> 00:01:02.236
Command B?

00:01:02.576 --> 00:01:03.566
How is the build process

00:01:03.566 --> 00:01:04.075
structured?

00:01:04.275 --> 00:01:05.336
And how does Xcode use the

00:01:05.336 --> 00:01:06.666
information in your project file

00:01:06.946 --> 00:01:08.706
to determine how to model and

00:01:08.706 --> 00:01:10.006
orchestrate the build process?

00:01:11.176 --> 00:01:12.936
Next we'll venture into the

00:01:12.936 --> 00:01:13.696
compiler realm.

00:01:14.236 --> 00:01:16.116
And find out about Clang and

00:01:16.116 --> 00:01:17.396
Swift builds your source code

00:01:17.486 --> 00:01:18.416
into object files.

00:01:19.246 --> 00:01:20.366
We'll show how headers and

00:01:20.366 --> 00:01:21.216
modules work.

00:01:21.586 --> 00:01:22.686
See how the compilers find

00:01:22.686 --> 00:01:24.496
declarations in your code, and

00:01:24.496 --> 00:01:25.826
how the Swift compilation model

00:01:25.826 --> 00:01:27.116
fundamentally differs from that

00:01:27.116 --> 00:01:29.506
of C, C++ and Objective-C.

00:01:30.126 --> 00:01:32.076
Finally, we'll land at the

00:01:32.076 --> 00:01:33.836
linker which performs one of the

00:01:33.836 --> 00:01:35.126
final steps in the build

00:01:35.126 --> 00:01:35.706
process.

00:01:36.416 --> 00:01:37.836
We'll explain what symbols are

00:01:37.836 --> 00:01:38.596
and how they relate to your

00:01:38.596 --> 00:01:39.276
source code.

00:01:39.556 --> 00:01:40.496
And how the linker takes the

00:01:40.496 --> 00:01:41.756
object files produced by the

00:01:41.756 --> 00:01:43.076
compilers and glues them

00:01:43.076 --> 00:01:44.236
together to produce the final

00:01:44.236 --> 00:01:45.786
executable for your application

00:01:45.786 --> 00:01:46.306
or framework.

00:01:47.046 --> 00:01:49.426
By the way, we're going to use a

00:01:49.426 --> 00:01:50.996
small sample app called PetWall

00:01:50.996 --> 00:01:52.256
as a running example throughout

00:01:52.256 --> 00:01:52.766
this talk.

00:01:53.066 --> 00:01:54.486
It's just a small iOS app that

00:01:54.486 --> 00:01:58.986
displays photos of our pets.

00:01:59.166 --> 00:02:00.986
So let's first understand what

00:02:00.986 --> 00:02:02.726
the build process is and how it

00:02:02.726 --> 00:02:03.916
works when building a typical

00:02:03.916 --> 00:02:05.466
app like PetWall in Xcode.

00:02:05.836 --> 00:02:07.136
You can see here we've got an

00:02:07.136 --> 00:02:08.936
app target, a framework, a bunch

00:02:08.936 --> 00:02:10.175
of different source code files

00:02:10.175 --> 00:02:11.526
in Swift and Objective-C.

00:02:11.896 --> 00:02:13.176
And maybe this looks a bit like

00:02:13.176 --> 00:02:13.786
your own project.

00:02:15.356 --> 00:02:18.036
So when you build an app,

00:02:19.166 --> 00:02:20.116
there's a number of steps

00:02:20.116 --> 00:02:21.586
involved to go from the source

00:02:21.586 --> 00:02:22.956
code and resources in your

00:02:22.956 --> 00:02:24.686
project to the package that

00:02:24.686 --> 00:02:26.086
you're shipping to customers or

00:02:26.136 --> 00:02:27.476
uploading to the App Store for

00:02:27.476 --> 00:02:28.086
distribution.

00:02:28.086 --> 00:02:30.486
You have to compile and link

00:02:30.486 --> 00:02:31.576
source code.

00:02:31.906 --> 00:02:33.916
Copy and process resources like

00:02:33.916 --> 00:02:35.756
headers, asset catalogues and

00:02:35.756 --> 00:02:36.676
storyboards.

00:02:37.276 --> 00:02:39.066
And finally code sign and maybe

00:02:39.066 --> 00:02:40.166
even do some custom work in a

00:02:40.166 --> 00:02:41.776
shell script or a make file like

00:02:41.896 --> 00:02:43.516
building API documentation for

00:02:43.516 --> 00:02:45.706
your framework or running code

00:02:45.706 --> 00:02:47.036
linting and validation tools.

00:02:48.466 --> 00:02:49.996
Now most of these tasks in the

00:02:49.996 --> 00:02:51.396
build process are performed by

00:02:51.396 --> 00:02:52.456
running command line tools.

00:02:52.456 --> 00:02:54.956
Like Clang, LD, AC tool, IB

00:02:54.956 --> 00:02:56.676
tool, Code sign, and so on.

00:02:57.446 --> 00:02:59.036
These tools have to be executed

00:02:59.196 --> 00:03:00.216
with a very specific set of

00:03:00.216 --> 00:03:02.316
arguments and in a particular

00:03:02.396 --> 00:03:03.746
order based on the configuration

00:03:03.826 --> 00:03:04.866
of your Xcode project.

00:03:05.386 --> 00:03:07.936
So what the build system does

00:03:07.936 --> 00:03:09.226
for you is to automate the

00:03:09.226 --> 00:03:10.506
orchestration and execution of

00:03:10.506 --> 00:03:11.946
these tasks each time you

00:03:11.946 --> 00:03:12.736
perform a build.

00:03:13.526 --> 00:03:14.876
And since there can be tens of

00:03:14.876 --> 00:03:16.926
thousands of tasks or even more

00:03:16.926 --> 00:03:18.436
involved in a build process with

00:03:18.436 --> 00:03:19.386
a complex graph of

00:03:19.386 --> 00:03:20.346
interdependencies.

00:03:20.616 --> 00:03:21.616
It's definitely not something

00:03:21.616 --> 00:03:22.626
you want to be manually typing

00:03:22.626 --> 00:03:23.776
into the terminal 110 times a

00:03:23.776 --> 00:03:24.056
day.

00:03:24.056 --> 00:03:27.176
Let the build system do that for

00:03:27.176 --> 00:03:27.316
you.

00:03:29.476 --> 00:03:31.276
Now I mentioned that the tasks

00:03:31.276 --> 00:03:32.446
in the build process are

00:03:32.446 --> 00:03:33.976
executed in a particular order.

00:03:34.456 --> 00:03:35.506
Let's talk about how that

00:03:35.506 --> 00:03:37.226
ordering is determined and why

00:03:37.226 --> 00:03:37.836
it's important.

00:03:38.866 --> 00:03:40.036
The order in which build tasks

00:03:40.036 --> 00:03:42.116
are executed is determined from

00:03:42.116 --> 00:03:43.456
the dependency information that

00:03:43.456 --> 00:03:45.476
is the tasks, the inputs that a

00:03:45.476 --> 00:03:47.426
task consumes, and the outputs

00:03:47.426 --> 00:03:48.096
that it produces.

00:03:49.386 --> 00:03:51.166
For example, a compilation task

00:03:51.236 --> 00:03:52.976
consumes a source code file like

00:03:52.976 --> 00:03:55.636
PetController.m as input and

00:03:55.636 --> 00:03:57.146
produces an object file like

00:03:57.146 --> 00:03:59.146
PetController.o as output.

00:04:00.176 --> 00:04:01.916
Similarly, a linker task

00:04:01.946 --> 00:04:03.536
consumes a number of object

00:04:03.536 --> 00:04:04.986
files produced by the compiler

00:04:04.986 --> 00:04:06.096
in previous tasks.

00:04:06.456 --> 00:04:07.966
And produces and executable or

00:04:07.966 --> 00:04:08.806
library output.

00:04:09.026 --> 00:04:10.426
Like the PetWall executable that

00:04:10.426 --> 00:04:11.616
will go into our .app bundle.

00:04:12.286 --> 00:04:13.306
And hopefully you're starting to

00:04:13.306 --> 00:04:14.756
see a bit of a pattern emerge

00:04:14.756 --> 00:04:14.976
here.

00:04:16.055 --> 00:04:17.046
You can see how the dependency

00:04:17.046 --> 00:04:18.736
information flows through this

00:04:18.736 --> 00:04:20.706
graph structure which ultimately

00:04:20.706 --> 00:04:22.276
informs the order of execution.

00:04:23.016 --> 00:04:24.246
Now if you look at the

00:04:24.246 --> 00:04:26.036
compilation tasks in the graph

00:04:26.036 --> 00:04:27.676
as sort of like lanes of

00:04:27.866 --> 00:04:28.316
traffic.

00:04:28.656 --> 00:04:29.836
You can see hoe the compilation

00:04:29.836 --> 00:04:31.656
tasks are totally independent in

00:04:31.656 --> 00:04:32.866
their own lanes and can

00:04:32.866 --> 00:04:34.206
therefore run in parallel.

00:04:34.256 --> 00:04:36.526
And because the linker task

00:04:36.576 --> 00:04:37.716
takes everything else's input,

00:04:38.106 --> 00:04:39.946
we know that has to come last.

00:04:41.016 --> 00:04:42.826
So the build system uses

00:04:42.826 --> 00:04:44.206
dependency information to

00:04:44.206 --> 00:04:45.266
determine the order in which

00:04:45.266 --> 00:04:47.126
tasks should be run and which

00:04:47.126 --> 00:04:49.136
tasks can be run in parallel and

00:04:49.256 --> 00:04:50.896
we call this dependency order.

00:04:51.756 --> 00:04:52.606
Now that we've covered what the

00:04:52.606 --> 00:04:54.526
build process is, let's go into

00:04:54.526 --> 00:04:56.276
a little more detail on how it

00:04:56.276 --> 00:04:56.616
works.

00:04:57.476 --> 00:04:58.966
What happens when you press

00:04:58.966 --> 00:04:59.316
build?

00:05:00.496 --> 00:05:01.826
So the first step is for the

00:05:01.826 --> 00:05:02.826
build system to take the build

00:05:02.826 --> 00:05:04.546
description, your Xcode project

00:05:04.546 --> 00:05:04.906
file.

00:05:05.316 --> 00:05:07.256
Parse it, take into account all

00:05:07.256 --> 00:05:09.096
the files in your project, your

00:05:09.156 --> 00:05:10.326
targets and the dependency

00:05:10.326 --> 00:05:11.216
relationships.

00:05:11.216 --> 00:05:13.276
Your build settings, and turn it

00:05:13.276 --> 00:05:14.326
into a tree-like structure

00:05:14.326 --> 00:05:15.646
called a directed graph.

00:05:16.306 --> 00:05:17.516
And this represents all the

00:05:17.516 --> 00:05:19.136
dependencies between the input

00:05:19.136 --> 00:05:20.536
and output files in your project

00:05:20.976 --> 00:05:22.216
and the tasks that will be

00:05:22.216 --> 00:05:23.886
executed to process them.

00:05:24.316 --> 00:05:27.856
Next the low-level execution

00:05:27.856 --> 00:05:29.356
engine processes this graph,

00:05:29.706 --> 00:05:30.946
looks at the dependency

00:05:30.946 --> 00:05:32.756
specifications and figures out

00:05:32.806 --> 00:05:34.136
which tasks to execute.

00:05:34.676 --> 00:05:35.756
The sequence or order in which

00:05:35.756 --> 00:05:37.676
they must be run and which tasks

00:05:37.756 --> 00:05:39.416
can be run in parallel.

00:05:39.416 --> 00:05:41.406
Then proceeds to execute them.

00:05:42.266 --> 00:05:43.746
And by the way, our low-level

00:05:43.746 --> 00:05:44.956
build execution engine for the

00:05:44.956 --> 00:05:45.936
new build system is called

00:05:45.936 --> 00:05:46.436
llbuild.

00:05:46.436 --> 00:05:47.566
And it's open source and

00:05:47.566 --> 00:05:48.396
developed on GitHub.

00:05:48.766 --> 00:05:49.606
If you're interested in build

00:05:49.606 --> 00:05:50.996
systems development, feel free

00:05:50.996 --> 00:05:52.086
to check it out and see how it

00:05:52.086 --> 00:05:52.446
works.

00:05:52.906 --> 00:05:53.806
We'll have a link to this and

00:05:53.806 --> 00:05:54.966
other open source components

00:05:54.966 --> 00:05:56.316
related to the build process at

00:05:56.316 --> 00:05:56.986
the end of the talk.

00:05:57.856 --> 00:05:59.856
Okay, let's talk about

00:05:59.856 --> 00:06:00.936
discovered dependencies.

00:06:01.526 --> 00:06:02.886
Now since you can never have too

00:06:02.886 --> 00:06:04.686
much dependency information, the

00:06:04.686 --> 00:06:06.026
build system might actually

00:06:06.126 --> 00:06:07.546
discover more information during

00:06:07.546 --> 00:06:08.936
the task execution process.

00:06:09.726 --> 00:06:11.466
For example, when Clang compiles

00:06:11.466 --> 00:06:13.496
an Objective-C file, it produces

00:06:13.496 --> 00:06:15.066
and object file as you'd expect.

00:06:15.616 --> 00:06:17.056
But it can also produce another

00:06:17.056 --> 00:06:19.936
file that contains a listing of

00:06:19.936 --> 00:06:21.186
which header files were included

00:06:21.186 --> 00:06:22.086
by that source file.

00:06:22.776 --> 00:06:24.446
Then the next time you build,

00:06:24.736 --> 00:06:25.696
the build system uses the

00:06:25.696 --> 00:06:27.226
information from this file to

00:06:27.226 --> 00:06:28.426
make sure that it recompiles the

00:06:28.426 --> 00:06:30.396
source file if you change any of

00:06:30.396 --> 00:06:31.706
the header files that it

00:06:31.706 --> 00:06:32.146
includes.

00:06:32.146 --> 00:06:33.676
And you can see the dependency

00:06:33.676 --> 00:06:35.746
path through PetController.h,

00:06:35.746 --> 00:06:37.916
PetController.d, .n, all the way

00:06:37.916 --> 00:06:38.786
to the .o file.

00:06:40.376 --> 00:06:42.236
Now we've been talking a lot

00:06:42.236 --> 00:06:44.326
about how the build system's

00:06:44.326 --> 00:06:47.036
main job is to execute tasks.

00:06:47.966 --> 00:06:49.086
And of course the bigger your

00:06:49.086 --> 00:06:50.646
project, the longer the build

00:06:50.646 --> 00:06:51.586
process will take.

00:06:51.586 --> 00:06:53.286
So you don't want to run all of

00:06:53.286 --> 00:06:54.886
these tasks every single time

00:06:54.926 --> 00:06:55.366
you build.

00:06:56.116 --> 00:06:57.666
Instead, the build system might

00:06:57.666 --> 00:06:59.796
only execute a subset of the

00:06:59.796 --> 00:07:02.606
tasks on the graph.

00:07:02.786 --> 00:07:03.916
Depending on the changes you've

00:07:03.916 --> 00:07:05.496
made to your project since the

00:07:05.496 --> 00:07:06.276
previous build.

00:07:07.166 --> 00:07:08.806
We refer to this as an

00:07:08.806 --> 00:07:10.306
incremental build and having

00:07:10.336 --> 00:07:11.826
accurate dependency information

00:07:12.036 --> 00:07:13.306
is very important in order for

00:07:13.306 --> 00:07:14.636
incremental builds to work

00:07:14.636 --> 00:07:15.976
correctly and efficiently.

00:07:15.976 --> 00:07:19.306
Now we talked about how changes

00:07:19.306 --> 00:07:20.476
affect the build system, and how

00:07:20.476 --> 00:07:21.356
they relate to incremental

00:07:21.356 --> 00:07:21.736
builds.

00:07:22.146 --> 00:07:23.396
So how does the build system

00:07:23.396 --> 00:07:24.576
actually detect changes?

00:07:24.946 --> 00:07:27.466
Each task in the build process

00:07:27.466 --> 00:07:29.366
has an associate signature which

00:07:29.366 --> 00:07:30.506
is the sort of hash that's

00:07:30.506 --> 00:07:31.406
computed from various

00:07:31.406 --> 00:07:32.756
information related to that

00:07:33.556 --> 00:07:33.686
task.

00:07:34.516 --> 00:07:36.086
This information includes the

00:07:36.086 --> 00:07:37.796
stat infor of the task's inputs

00:07:37.796 --> 00:07:39.416
like file paths and modification

00:07:39.416 --> 00:07:40.136
time stamps.

00:07:40.576 --> 00:07:42.066
The command line indication used

00:07:42.066 --> 00:07:43.556
to actually perform the command.

00:07:43.656 --> 00:07:45.516
And other task-specific metadata

00:07:45.516 --> 00:07:46.466
such as the version of the

00:07:46.466 --> 00:07:47.776
compiler that's being used.

00:07:49.296 --> 00:07:50.716
The build system keeps track of

00:07:50.716 --> 00:07:52.486
the signatures of tasks in both

00:07:52.486 --> 00:07:53.556
the current and the previous

00:07:53.556 --> 00:07:53.876
build.

00:07:54.126 --> 00:07:55.266
So that it knows whether to

00:07:55.266 --> 00:07:56.976
rerun a task each time a build

00:07:56.976 --> 00:07:57.696
is performed.

00:07:59.106 --> 00:08:00.236
If the signature of any given

00:08:00.236 --> 00:08:01.196
task is different than the

00:08:01.196 --> 00:08:02.136
signature that it had in the

00:08:02.256 --> 00:08:03.916
previous build, then the build

00:08:03.916 --> 00:08:05.096
system reruns that task.

00:08:06.096 --> 00:08:07.716
If they're the same, then it's

00:08:07.716 --> 00:08:08.046
skipped.

00:08:08.166 --> 00:08:10.316
That's the basic idea behind how

00:08:10.316 --> 00:08:11.336
incremental builds work.

00:08:12.596 --> 00:08:14.766
So now that we have an idea of

00:08:14.766 --> 00:08:16.346
what the build process is and

00:08:16.396 --> 00:08:18.066
how it works, how can you help

00:08:18.066 --> 00:08:19.366
the build system do its job?

00:08:19.906 --> 00:08:22.146
Let's go back to basics for a

00:08:22.146 --> 00:08:22.466
moment.

00:08:23.046 --> 00:08:24.596
A build process is a series of

00:08:24.596 --> 00:08:26.746
tasks executed in a particular

00:08:26.806 --> 00:08:27.096
order.

00:08:27.096 --> 00:08:28.826
But remember that the build is

00:08:28.826 --> 00:08:30.606
represented as a directed graph.

00:08:31.936 --> 00:08:33.155
So we don't want to think about

00:08:33.206 --> 00:08:34.366
the order in which these tasks

00:08:34.366 --> 00:08:35.666
should be executed because

00:08:35.666 --> 00:08:36.916
that's the build system's job.

00:08:37.796 --> 00:08:39.756
Instead, as developers, we need

00:08:39.756 --> 00:08:41.316
to think about dependencies

00:08:41.316 --> 00:08:43.025
between tasks and let the build

00:08:43.025 --> 00:08:44.236
system figure out how to best

00:08:44.236 --> 00:08:45.316
execute them according to the

00:08:45.316 --> 00:08:46.226
graph's structure.

00:08:46.936 --> 00:08:48.266
This lets the build system order

00:08:48.266 --> 00:08:50.146
tasks correctly and parallelize

00:08:50.146 --> 00:08:51.616
where possible in order to take

00:08:51.616 --> 00:08:53.076
full advantage of multicore

00:08:53.076 --> 00:08:53.496
hardware.

00:08:54.966 --> 00:08:56.506
So where do dependencies come

00:08:56.506 --> 00:08:56.796
from?

00:08:56.916 --> 00:08:58.726
For certain tasks, dependency

00:08:58.726 --> 00:09:00.326
information comes from knowledge

00:09:00.366 --> 00:09:01.396
built into the build system.

00:09:01.876 --> 00:09:02.836
The build system ships with

00:09:02.876 --> 00:09:04.346
rules for the compiler, the

00:09:04.346 --> 00:09:06.336
linker, the asset catalogue and

00:09:06.336 --> 00:09:08.046
story board processors and so

00:09:08.046 --> 00:09:08.186
on.

00:09:08.496 --> 00:09:09.966
And these rules define what kind

00:09:09.966 --> 00:09:11.376
of files are accepted as inputs

00:09:11.746 --> 00:09:13.016
as well as what outputs are

00:09:13.016 --> 00:09:13.576
produced.

00:09:15.176 --> 00:09:17.186
There's also target dependencies

00:09:17.256 --> 00:09:18.226
which roughly determine the

00:09:18.226 --> 00:09:19.186
order in which targets are

00:09:19.186 --> 00:09:19.466
built.

00:09:20.246 --> 00:09:21.696
And in some cases, the build

00:09:21.696 --> 00:09:23.066
system can compile sources of

00:09:23.066 --> 00:09:24.276
different targets and parallel.

00:09:24.836 --> 00:09:26.046
Previously in Xcode, when a

00:09:26.046 --> 00:09:27.626
target was built, it required

00:09:27.626 --> 00:09:28.816
the compilation of the entire

00:09:28.816 --> 00:09:30.246
dependent target to be completed

00:09:30.446 --> 00:09:31.406
before it could start.

00:09:32.136 --> 00:09:33.726
In Xcode X's new build system,

00:09:33.986 --> 00:09:34.966
targets can start building

00:09:34.966 --> 00:09:35.346
sooner.

00:09:35.876 --> 00:09:36.906
This means that your compile

00:09:36.906 --> 00:09:38.336
sources phase can start earlier

00:09:38.336 --> 00:09:39.036
providing your some

00:09:39.036 --> 00:09:40.536
parallelization for free.

00:09:41.166 --> 00:09:42.196
However, note that if you're

00:09:42.196 --> 00:09:43.416
making use of any run script

00:09:43.416 --> 00:09:45.026
phases, those script phases will

00:09:45.026 --> 00:09:46.216
need to complete before this

00:09:46.216 --> 00:09:48.446
parallelization can take effect.

00:09:49.056 --> 00:09:50.496
Somewhat related to target

00:09:50.496 --> 00:09:51.956
dependencies are implicit

00:09:51.956 --> 00:09:52.556
dependencies.

00:09:53.296 --> 00:09:54.416
For example, if you list a

00:09:54.416 --> 00:09:55.826
target in your link library with

00:09:55.826 --> 00:09:57.586
binaries build phase and

00:09:57.586 --> 00:09:58.736
implicit dependencies are

00:09:58.736 --> 00:09:59.856
enabled in the scheme editor,

00:10:00.116 --> 00:10:01.046
that's on by default, by the

00:10:01.046 --> 00:10:02.416
way, the build system will

00:10:02.416 --> 00:10:03.716
establish an implicit dependency

00:10:03.716 --> 00:10:05.326
on that target even if it's not

00:10:05.326 --> 00:10:06.626
listed in target dependencies.

00:10:08.116 --> 00:10:09.766
Next up are build phase

00:10:09.766 --> 00:10:10.376
dependencies.

00:10:10.976 --> 00:10:12.136
In the target editor, you'll

00:10:12.136 --> 00:10:13.046
notice that there's a number of

00:10:13.046 --> 00:10:13.646
build phases.

00:10:14.026 --> 00:10:16.406
Copy headers, compile sources,

00:10:16.526 --> 00:10:18.446
copy bundle resources and so on.

00:10:19.166 --> 00:10:20.466
The tasks associated with each

00:10:20.466 --> 00:10:22.056
of these phrases are usually

00:10:22.056 --> 00:10:23.156
running groups according to the

00:10:23.156 --> 00:10:24.186
order in which the phases are

00:10:24.186 --> 00:10:24.726
listed.

00:10:25.086 --> 00:10:25.996
But the build system might

00:10:26.076 --> 00:10:27.226
ignore that order if it knows

00:10:27.256 --> 00:10:27.526
better.

00:10:27.626 --> 00:10:28.916
Like if you have a link library,

00:10:29.236 --> 00:10:30.716
linked binary with library space

00:10:30.966 --> 00:10:32.456
ordered before compile sources.

00:10:32.876 --> 00:10:34.016
And note that there's cases

00:10:34.016 --> 00:10:34.866
where having the wrong build

00:10:34.866 --> 00:10:36.186
phase order can cause build

00:10:36.186 --> 00:10:37.656
issues or failures, so make sure

00:10:37.656 --> 00:10:38.796
to understand your dependencies

00:10:38.796 --> 00:10:39.956
and verify that your build

00:10:39.956 --> 00:10:40.826
phases are in the right

00:10:40.826 --> 00:10:41.386
sequence.

00:10:42.696 --> 00:10:44.166
There's also scheme order

00:10:44.166 --> 00:10:44.786
dependencies.

00:10:45.406 --> 00:10:46.436
If you have the parallelize

00:10:46.486 --> 00:10:47.666
build check box enabled in your

00:10:47.666 --> 00:10:49.236
scheme settings, you get better

00:10:49.236 --> 00:10:50.806
build performance and the order

00:10:50.806 --> 00:10:51.916
of your targets in your scheme

00:10:52.016 --> 00:10:52.546
doesn't matter.

00:10:53.026 --> 00:10:54.726
However, if you turn parallelize

00:10:54.776 --> 00:10:56.546
build off, Xcode will attempt to

00:10:56.546 --> 00:10:58.186
build their, your targets in the

00:10:58.186 --> 00:10:59.246
order you listed them in the

00:10:59.246 --> 00:11:00.876
build action of the scheme one

00:11:00.876 --> 00:11:01.406
by one.

00:11:02.026 --> 00:11:03.196
Target dependencies still have

00:11:03.196 --> 00:11:04.686
higher priority in determining

00:11:04.686 --> 00:11:05.706
which targets build first.

00:11:05.936 --> 00:11:07.086
But otherwise, Xcode will

00:11:07.086 --> 00:11:07.986
respect that ordering.

00:11:08.636 --> 00:11:10.436
Now it might be tempting to use

00:11:10.436 --> 00:11:11.256
this as it gives you a

00:11:11.256 --> 00:11:12.666
predictable build order even if

00:11:12.666 --> 00:11:13.366
you haven't set your

00:11:13.366 --> 00:11:14.336
dependencies correctly.

00:11:14.786 --> 00:11:15.856
But you're sacrificing a lot of

00:11:15.856 --> 00:11:17.406
parallelization when you do this

00:11:17.796 --> 00:11:18.766
and slowing down your build.

00:11:19.176 --> 00:11:20.186
So we recommend that you leave

00:11:20.186 --> 00:11:21.556
the parallelize builds checkbox

00:11:21.556 --> 00:11:22.886
enabled, set up your target

00:11:22.886 --> 00:11:24.126
dependencies correctly and don't

00:11:24.126 --> 00:11:24.946
rely on ordering.

00:11:27.296 --> 00:11:29.256
Lastly, dependency information

00:11:29.336 --> 00:11:30.956
comes from you, the developers.

00:11:31.586 --> 00:11:33.926
If you're creating custom shell

00:11:33.926 --> 00:11:35.256
script build phases or build

00:11:35.256 --> 00:11:36.636
rules, make sure to tell the

00:11:36.636 --> 00:11:38.016
build system what its inputs and

00:11:38.016 --> 00:11:38.546
outputs are.

00:11:39.086 --> 00:11:40.386
This lets the build system avoid

00:11:40.386 --> 00:11:41.626
rerunning the script tasks

00:11:41.626 --> 00:11:42.396
unnecessarily.

00:11:42.596 --> 00:11:43.786
And can help make sure that they

00:11:43.786 --> 00:11:45.316
are executed in the right order.

00:11:45.796 --> 00:11:46.906
You can define the inputs and

00:11:46.906 --> 00:11:48.286
outputs in the run script phase

00:11:48.286 --> 00:11:48.716
editor.

00:11:48.716 --> 00:11:50.236
And the paths of these files

00:11:50.236 --> 00:11:51.256
will be made available to your

00:11:51.256 --> 00:11:52.816
script as environment variables.

00:11:54.456 --> 00:11:56.336
Don't rely on auto-link for

00:11:56.336 --> 00:11:57.506
target dependencies in your

00:11:57.506 --> 00:11:57.976
project.

00:11:58.736 --> 00:11:59.676
The client compiler has a

00:11:59.676 --> 00:12:01.006
feature called auto-link which

00:12:01.006 --> 00:12:02.126
can be enabled using the link

00:12:02.126 --> 00:12:03.526
frameworks automatically build

00:12:03.526 --> 00:12:03.866
setting.

00:12:04.586 --> 00:12:05.826
This setting allows the compiler

00:12:05.826 --> 00:12:06.846
to automatically link to the

00:12:06.846 --> 00:12:08.206
frameworks corresponding to any

00:12:08.206 --> 00:12:09.746
modules you import without

00:12:09.746 --> 00:12:11.016
having to explicitly link them

00:12:11.366 --> 00:12:12.496
in your link library's build

00:12:12.496 --> 00:12:12.816
phase.

00:12:13.396 --> 00:12:14.616
However, it's important to note

00:12:14.616 --> 00:12:15.666
that auto-link does not

00:12:15.726 --> 00:12:17.236
establish dependency on that

00:12:17.236 --> 00:12:18.346
framework at the build system

00:12:18.346 --> 00:12:18.616
level.

00:12:18.946 --> 00:12:20.186
So it won't guarantee that the

00:12:20.186 --> 00:12:21.746
target you depend on is actually

00:12:21.746 --> 00:12:23.306
built before you try to link

00:12:23.306 --> 00:12:24.386
against it.

00:12:25.016 --> 00:12:26.716
So you should rely on this

00:12:26.716 --> 00:12:28.286
feature only for frameworks from

00:12:28.286 --> 00:12:29.436
the platform STK.

00:12:29.436 --> 00:12:31.326
Like Foundation and UIKit since

00:12:31.326 --> 00:12:32.706
we know those will already exist

00:12:32.816 --> 00:12:34.136
before the build even starts.

00:12:34.636 --> 00:12:35.546
For targets in your own

00:12:35.546 --> 00:12:36.976
projects, make sure to add

00:12:36.976 --> 00:12:38.416
explicit library dependencies.

00:12:40.196 --> 00:12:41.566
You might also need to create

00:12:41.566 --> 00:12:42.926
project references by dragging

00:12:42.926 --> 00:12:44.066
and dropping another Xcode

00:12:44.066 --> 00:12:45.506
project into your project's file

00:12:45.506 --> 00:12:47.546
navigator in order to reveal the

00:12:47.546 --> 00:12:48.926
targets of other projects you

00:12:48.926 --> 00:12:49.406
depend on.

00:12:49.996 --> 00:12:53.376
In conclusion, with accurate

00:12:53.376 --> 00:12:54.676
dependency information, the

00:12:54.676 --> 00:12:55.646
build system can better

00:12:55.646 --> 00:12:56.936
parallelize your builds, and

00:12:57.046 --> 00:12:58.136
help ensure that you get

00:12:58.136 --> 00:13:00.106
consistent results every time so

00:13:00.106 --> 00:13:01.176
that you can spend less time

00:13:01.176 --> 00:13:02.326
building and more time

00:13:02.526 --> 00:13:03.156
developing.

00:13:04.286 --> 00:13:05.386
For more information on how to

00:13:05.386 --> 00:13:06.436
speed up your builds and make

00:13:06.436 --> 00:13:07.516
the most of all those cores in

00:13:07.516 --> 00:13:09.186
your shiny new iMac Pro, we'd

00:13:09.186 --> 00:13:10.196
recommend that you check out

00:13:10.196 --> 00:13:11.536
Building Faster in Xcode

00:13:11.536 --> 00:13:11.966
Session.

00:13:12.346 --> 00:13:13.836
And with that, I'm going to hand

00:13:13.836 --> 00:13:14.966
it over to Jurgen, who's going

00:13:14.966 --> 00:13:16.246
to take you into the realm of

00:13:16.246 --> 00:13:16.806
the compiler.

00:13:17.516 --> 00:13:22.836
[ Applause ]

00:13:23.336 --> 00:13:23.776
>> Thank you, Jake.

00:13:24.726 --> 00:13:27.206
And now we're going to talk

00:13:27.206 --> 00:13:28.666
about what happens behind the

00:13:28.666 --> 00:13:31.216
scenes when Xcode build system

00:13:31.296 --> 00:13:32.466
invokes the Clang compiler.

00:13:33.976 --> 00:13:34.896
Hello, everyone.

00:13:35.286 --> 00:13:36.956
My name is Jurgen, and I'm a

00:13:36.956 --> 00:13:38.446
Compiler Engineer on a Clang

00:13:38.446 --> 00:13:39.016
Frontend Team.

00:13:40.096 --> 00:13:41.356
Today I'm going to talk about

00:13:41.356 --> 00:13:43.256
two features you might not know

00:13:43.256 --> 00:13:43.496
about.

00:13:44.366 --> 00:13:45.966
The first feature is called

00:13:46.136 --> 00:13:48.366
header maps and how we use them

00:13:48.406 --> 00:13:50.446
to communicate information from

00:13:50.446 --> 00:13:52.116
the Xcode build system to the

00:13:52.116 --> 00:13:52.756
Clang compiler.

00:13:54.146 --> 00:13:55.496
The second feature is called

00:13:55.836 --> 00:13:57.856
Clang modules and how we use

00:13:57.856 --> 00:14:00.956
them to speed up your builds.

00:14:01.126 --> 00:14:03.526
Some of you might only use Swift

00:14:03.556 --> 00:14:03.906
by now.

00:14:04.756 --> 00:14:06.656
But I want to tell you, Swift

00:14:06.656 --> 00:14:08.236
uses Clang behind the scenes.

00:14:08.936 --> 00:14:09.896
So there might be something

00:14:09.896 --> 00:14:12.086
interesting for you here, too.

00:14:14.646 --> 00:14:15.446
So what is Clang?

00:14:17.086 --> 00:14:18.906
Clang is Apple's official C

00:14:18.906 --> 00:14:22.756
compiler and all the other C

00:14:22.926 --> 00:14:25.696
language family such as C, C++,

00:14:25.956 --> 00:14:28.356
and of course Objective-C which

00:14:28.356 --> 00:14:29.906
is used for the majority of all

00:14:29.906 --> 00:14:30.536
frameworks.

00:14:31.056 --> 00:14:33.296
As Jake mentioned in the

00:14:33.296 --> 00:14:36.806
beginning, the compilers invoked

00:14:36.806 --> 00:14:38.126
[inaudible] for every input file

00:14:38.126 --> 00:14:39.536
and it creates exactly one

00:14:39.536 --> 00:14:41.166
output file which is then later

00:14:41.166 --> 00:14:42.136
consumed by the linker.

00:14:43.496 --> 00:14:45.796
If you want to access APIs from

00:14:46.546 --> 00:14:49.436
the iOS, or you want to access

00:14:49.946 --> 00:14:52.576
implementations from your own

00:14:52.666 --> 00:14:54.386
code, you usually have to

00:14:54.386 --> 00:14:55.446
include something what is called

00:14:55.446 --> 00:14:56.036
a header file.

00:14:56.686 --> 00:14:59.476
A header file is a promise.

00:15:00.506 --> 00:15:03.306
You promise somewhere else this

00:15:03.306 --> 00:15:04.536
implementation exists.

00:15:04.876 --> 00:15:05.946
And they usually match.

00:15:06.616 --> 00:15:08.586
Of course if you update only the

00:15:08.656 --> 00:15:09.506
header file-- only the

00:15:09.506 --> 00:15:11.436
implementation file and forget

00:15:11.436 --> 00:15:13.036
the header file, you broke your

00:15:13.846 --> 00:15:14.076
promise.

00:15:14.446 --> 00:15:16.716
Very often this doesn't break

00:15:16.716 --> 00:15:18.296
the compile time because the

00:15:18.296 --> 00:15:19.626
compiler trusts your promise.

00:15:20.496 --> 00:15:22.726
Usually this breaks during link

00:15:22.756 --> 00:15:23.016
time.

00:15:23.576 --> 00:15:25.986
The compiler usually does

00:15:26.286 --> 00:15:27.566
include more than one header

00:15:27.566 --> 00:15:30.586
file, and this is done for all

00:15:30.586 --> 00:15:31.566
compiler invocation.

00:15:32.376 --> 00:15:34.916
So let's have a look at our

00:15:34.916 --> 00:15:37.076
example application and see how

00:15:37.076 --> 00:15:38.166
we deal with header files.

00:15:39.806 --> 00:15:42.506
This is PetWall, it's a

00:15:42.616 --> 00:15:44.076
mixed-language application.

00:15:44.956 --> 00:15:46.736
The application itself is

00:15:46.736 --> 00:15:47.446
written in Swift.

00:15:48.656 --> 00:15:51.256
And it uses a framework that's

00:15:51.256 --> 00:15:52.706
written in Objective-C.

00:15:52.706 --> 00:15:54.286
And it has a support library

00:15:54.376 --> 00:15:56.376
aesthetic archive that use--

00:15:56.376 --> 00:16:00.056
that's written in C++.

00:16:00.246 --> 00:16:02.806
Over time, our application grew.

00:16:03.016 --> 00:16:06.266
And we start to reorganize it so

00:16:06.266 --> 00:16:07.616
we can find things easier.

00:16:08.166 --> 00:16:10.486
For example, we moved all the

00:16:10.616 --> 00:16:12.036
cat-related files into a

00:16:12.036 --> 00:16:12.606
subfolder.

00:16:13.216 --> 00:16:18.376
We didn't have to change any of

00:16:18.376 --> 00:16:19.876
our implementation files.

00:16:20.676 --> 00:16:22.246
And it still works.

00:16:23.046 --> 00:16:26.866
So it makes you wonder how does

00:16:26.866 --> 00:16:29.206
Clang find your header files?

00:16:29.206 --> 00:16:33.856
Let's look at a simple example.

00:16:34.696 --> 00:16:35.356
This is one of our

00:16:35.356 --> 00:16:38.146
implementation files we use in

00:16:38.146 --> 00:16:40.236
our code and we include our

00:16:40.236 --> 00:16:43.406
header file called cat.h. How

00:16:43.406 --> 00:16:45.836
can we figure out what Clang

00:16:45.836 --> 00:16:46.066
does?

00:16:46.946 --> 00:16:48.466
Once thing you could do is you

00:16:48.466 --> 00:16:51.076
can go into the build logs, look

00:16:51.436 --> 00:16:53.896
what the Xcode build system did

00:16:54.486 --> 00:16:55.996
to compile this particular file.

00:16:55.996 --> 00:16:57.276
And copy and paste that

00:16:57.276 --> 00:16:57.956
invocation.

00:16:59.196 --> 00:17:01.196
You drop it into a terminal and

00:17:01.546 --> 00:17:02.816
add the -v option.

00:17:03.796 --> 00:17:05.205
Dash-v is symbol for verbose.

00:17:05.935 --> 00:17:07.266
And then Clang will tell you

00:17:07.476 --> 00:17:08.576
lots of information.

00:17:09.476 --> 00:17:11.036
But let's just concentrate on

00:17:11.036 --> 00:17:12.986
the one that matter which is the

00:17:14.016 --> 00:17:15.226
search paths.

00:17:15.276 --> 00:17:17.846
I say search paths and many of

00:17:17.945 --> 00:17:19.836
you might expect to see now here

00:17:20.106 --> 00:17:22.526
search paths that point back to

00:17:22.526 --> 00:17:24.346
your source code.

00:17:24.965 --> 00:17:26.646
But it's not how this works.

00:17:27.415 --> 00:17:29.546
Instead you will see something

00:17:29.546 --> 00:17:30.476
called headermaps.

00:17:32.116 --> 00:17:34.426
Headermaps are used [inaudible]

00:17:34.806 --> 00:17:36.856
by the Xcode build system to

00:17:36.856 --> 00:17:38.656
communicate where those header

00:17:38.656 --> 00:17:39.566
files are.

00:17:40.546 --> 00:17:41.646
So let's have a look at those.

00:17:41.646 --> 00:17:42.846
Let's have a look the most

00:17:42.846 --> 00:17:44.626
important two file-- headermap

00:17:44.626 --> 00:17:46.086
files we care about.

00:17:47.656 --> 00:17:50.946
The first two entries simply

00:17:51.686 --> 00:17:55.066
append the framework name to

00:17:55.066 --> 00:17:55.586
your header.

00:17:56.286 --> 00:17:57.126
Those two headers in the

00:17:57.126 --> 00:17:58.916
beginning are public headers.

00:18:02.416 --> 00:18:04.556
I say you shouldn't rely on this

00:18:04.556 --> 00:18:04.876
feature.

00:18:05.466 --> 00:18:08.406
The reason is we keep this there

00:18:08.406 --> 00:18:10.226
to keep existing projects

00:18:10.226 --> 00:18:13.076
working but there might be

00:18:13.076 --> 00:18:14.356
issues down the road with Clang

00:18:14.356 --> 00:18:17.476
modules so we suggest that you

00:18:17.726 --> 00:18:20.396
always specify the framework

00:18:20.396 --> 00:18:22.416
name when you include a public

00:18:22.556 --> 00:18:24.336
or private header file from your

00:18:24.376 --> 00:18:25.306
own framework.

00:18:27.136 --> 00:18:29.576
Third entry is a project header.

00:18:30.196 --> 00:18:31.376
In this case, this is not

00:18:31.416 --> 00:18:31.856
required.

00:18:32.806 --> 00:18:35.006
And the whole purpose of the

00:18:35.006 --> 00:18:37.276
headermap is to point back to

00:18:37.496 --> 00:18:38.296
your source code.

00:18:38.296 --> 00:18:41.376
As you can see, we do the same

00:18:41.466 --> 00:18:42.936
thing for the public and private

00:18:42.986 --> 00:18:43.246
headers.

00:18:44.296 --> 00:18:45.986
We always point back to your

00:18:45.986 --> 00:18:47.076
source code.

00:18:47.076 --> 00:18:49.656
We do this so that Clang can

00:18:49.716 --> 00:18:52.126
produce useful error and warning

00:18:52.126 --> 00:18:54.526
messages for the files in your

00:18:54.526 --> 00:18:56.376
source directory and not a

00:18:56.376 --> 00:18:57.746
potential copy that might be

00:18:57.746 --> 00:19:00.606
somewhere else in the build

00:19:02.956 --> 00:19:03.176
directory.

00:19:03.266 --> 00:19:05.176
Since many people were not aware

00:19:05.176 --> 00:19:06.806
that we use headermaps, you run

00:19:06.906 --> 00:19:08.106
into certain issues.

00:19:08.426 --> 00:19:11.246
A very common one is that we

00:19:11.246 --> 00:19:13.536
forgot to add the header to the

00:19:13.536 --> 00:19:13.996
project.

00:19:14.786 --> 00:19:16.756
It is in the source directory,

00:19:16.916 --> 00:19:18.616
but it is not in the project

00:19:18.616 --> 00:19:19.056
itself.

00:19:19.366 --> 00:19:21.546
So always add your headers to

00:19:21.546 --> 00:19:22.036
the project.

00:19:23.046 --> 00:19:26.756
Another issue is that if you

00:19:26.756 --> 00:19:28.366
have headers with the same name,

00:19:28.646 --> 00:19:29.816
they might shadow each other.

00:19:31.216 --> 00:19:32.966
So always try to use unique

00:19:32.966 --> 00:19:33.846
names for your headers.

00:19:34.806 --> 00:19:36.876
This also applies to system

00:19:36.876 --> 00:19:37.336
headers.

00:19:37.816 --> 00:19:39.306
If you have a local header in

00:19:39.306 --> 00:19:40.816
your project that has the name

00:19:40.816 --> 00:19:42.546
as a system header, it will

00:19:42.546 --> 00:19:44.756
shadow the system header so you

00:19:44.756 --> 00:19:46.116
should try to avoid this.

00:19:47.096 --> 00:19:48.296
Talking about system headers.

00:19:48.706 --> 00:19:52.866
How do we find those?

00:19:53.066 --> 00:19:54.546
Another example from our

00:19:54.546 --> 00:19:54.836
PetWall.

00:19:55.926 --> 00:19:57.576
Here in this case we include

00:19:57.616 --> 00:19:59.536
Foundation.h header file which

00:19:59.536 --> 00:20:00.256
is in our SDK.

00:20:00.296 --> 00:20:03.086
We can do the same thing we did

00:20:03.086 --> 00:20:05.526
before when you were looking for

00:20:05.526 --> 00:20:06.296
our own header files.

00:20:06.416 --> 00:20:07.246
But now we're looking for the

00:20:07.246 --> 00:20:07.786
system header.

00:20:08.866 --> 00:20:11.386
It's just that headermaps are

00:20:11.386 --> 00:20:13.486
only for your own headers.

00:20:13.956 --> 00:20:15.076
So we can ignore them.

00:20:16.086 --> 00:20:17.976
Let's focus on the include path

00:20:18.056 --> 00:20:18.256
[inaudible] matter.

00:20:18.756 --> 00:20:21.716
So at default, we always look in

00:20:21.816 --> 00:20:23.466
two directories in the SDK.

00:20:23.966 --> 00:20:25.746
the first one is user include,

00:20:26.516 --> 00:20:28.616
the second one is system library

00:20:28.616 --> 00:20:29.176
frameworks.

00:20:29.866 --> 00:20:31.346
Let's have a look at the first

00:20:31.346 --> 00:20:31.486
one.

00:20:31.966 --> 00:20:34.276
It's a regular include

00:20:34.376 --> 00:20:35.056
directory.

00:20:35.416 --> 00:20:36.746
So the only thing we have to do

00:20:36.746 --> 00:20:38.426
is we have to append the search

00:20:38.426 --> 00:20:38.726
term.

00:20:38.816 --> 00:20:39.476
In this case,

00:20:39.476 --> 00:20:43.026
Foundation/Foundation.h. And we

00:20:43.026 --> 00:20:44.166
won't find the header because

00:20:44.166 --> 00:20:44.516
it's not there.

00:20:45.556 --> 00:20:46.076
But it's okay.

00:20:46.216 --> 00:20:47.436
Let's try the next entry.

00:20:48.616 --> 00:20:50.126
Let's look into system library

00:20:50.126 --> 00:20:50.746
frameworks.

00:20:52.196 --> 00:20:53.276
This one is a frameworks

00:20:53.326 --> 00:20:55.506
directory that means Clang has

00:20:55.536 --> 00:20:56.746
to behave a little bit

00:20:56.796 --> 00:20:57.216
different.

00:20:57.456 --> 00:21:00.026
First of all, it has to identify

00:21:00.506 --> 00:21:02.466
what is the framework and check

00:21:02.466 --> 00:21:03.676
if the framework exists.

00:21:04.146 --> 00:21:07.826
After that, it has to look in

00:21:07.826 --> 00:21:09.336
the headers directory for the

00:21:09.336 --> 00:21:09.806
header file.

00:21:10.666 --> 00:21:12.376
This case, it finds it so it's

00:21:12.376 --> 00:21:12.646
fine.

00:21:13.736 --> 00:21:16.046
But what happens if we don't

00:21:16.046 --> 00:21:16.656
find the header?

00:21:17.066 --> 00:21:18.886
For example, we have a bogus

00:21:18.886 --> 00:21:20.126
header that doesn't exist.

00:21:21.726 --> 00:21:23.366
It obviously fails to find it in

00:21:23.366 --> 00:21:24.256
the headers directory.

00:21:24.846 --> 00:21:27.306
But the next, it will also look

00:21:27.306 --> 00:21:28.296
in the private headers

00:21:28.336 --> 00:21:28.836
directory.

00:21:30.316 --> 00:21:32.676
Apple doesn't ship any private

00:21:32.676 --> 00:21:34.736
headers in its SDK.

00:21:35.046 --> 00:21:36.776
but your project, your

00:21:36.776 --> 00:21:38.586
frameworks might have public and

00:21:38.586 --> 00:21:39.206
private headers.

00:21:39.826 --> 00:21:41.046
So we always will look there

00:21:41.166 --> 00:21:41.396
too.

00:21:42.476 --> 00:21:44.696
Since it's a bogus header, it's

00:21:45.506 --> 00:21:46.666
not there either.

00:21:46.756 --> 00:21:48.786
Interesting now, we actually

00:21:48.786 --> 00:21:49.846
will abort the search now.

00:21:50.446 --> 00:21:51.886
We will not keep searching in

00:21:51.946 --> 00:21:52.996
other search directories.

00:21:53.496 --> 00:21:56.026
The reason is we already found

00:21:56.536 --> 00:21:57.716
the head-- we already found the

00:21:57.716 --> 00:21:58.176
framework.

00:21:59.076 --> 00:22:00.506
Once you find the framework, we

00:22:00.506 --> 00:22:01.906
expect to find the header in

00:22:01.906 --> 00:22:02.856
this framework directory.

00:22:03.496 --> 00:22:04.326
If you don't find it, we

00:22:04.326 --> 00:22:05.466
complete abort the search.

00:22:06.036 --> 00:22:09.656
If you're curious how your

00:22:09.656 --> 00:22:11.016
implementation file looks like,

00:22:11.016 --> 00:22:13.196
after all those headers got

00:22:13.196 --> 00:22:14.566
imported and preprocessed.

00:22:15.236 --> 00:22:18.576
You can ask Xcode to create a

00:22:18.576 --> 00:22:21.206
preprocessed file for you, for

00:22:21.206 --> 00:22:22.136
your implementation file.

00:22:22.686 --> 00:22:26.476
This will create a very large

00:22:27.566 --> 00:22:28.496
output file.

00:22:28.636 --> 00:22:32.736
So how big is that file?

00:22:32.916 --> 00:22:34.766
Let's use a very simple example.

00:22:35.606 --> 00:22:39.306
Foundation.h is a very

00:22:39.306 --> 00:22:40.806
fundamental header, fundamental

00:22:40.806 --> 00:22:42.106
header to our system.

00:22:42.696 --> 00:22:44.686
It is-- you are very likely to

00:22:44.686 --> 00:22:46.036
import this header either

00:22:46.036 --> 00:22:48.126
directly or indirectly for some

00:22:48.156 --> 00:22:48.896
other header file.

00:22:49.556 --> 00:22:51.396
That means every compiler

00:22:51.396 --> 00:22:52.746
invocation you're most likely

00:22:52.866 --> 00:22:54.156
going to have to find this

00:22:54.156 --> 00:22:54.376
header.

00:22:55.796 --> 00:22:58.386
At the end of the day, Clang has

00:22:58.436 --> 00:23:01.466
to find and process over 800

00:23:01.466 --> 00:23:03.296
header files for the single

00:23:03.296 --> 00:23:04.106
include statement.

00:23:05.576 --> 00:23:07.406
That's over 9 megabyte of source

00:23:07.406 --> 00:23:10.056
code that has to be parsed and

00:23:10.056 --> 00:23:10.596
verified.

00:23:11.666 --> 00:23:13.706
And that happens for every

00:23:13.706 --> 00:23:14.926
compiler invocation.

00:23:15.556 --> 00:23:17.176
That's a lot of work, and it's

00:23:17.376 --> 00:23:17.886
redundant.

00:23:19.076 --> 00:23:21.976
So can we do better?

00:23:24.066 --> 00:23:25.076
One of the features you might be

00:23:25.076 --> 00:23:26.936
aware of is called precompiled

00:23:26.936 --> 00:23:27.576
header files.

00:23:28.196 --> 00:23:29.816
That's one way to improve this.

00:23:30.596 --> 00:23:31.886
But we have something better.

00:23:31.996 --> 00:23:34.106
A few years back, we introduced

00:23:34.236 --> 00:23:34.866
Clang modules.

00:23:36.366 --> 00:23:38.806
Clang modules allow us to only

00:23:39.006 --> 00:23:40.626
find and parse the headers once

00:23:41.216 --> 00:23:43.306
per framework and then store

00:23:43.306 --> 00:23:45.276
that information on disk so it's

00:23:45.706 --> 00:23:47.256
cached and can be reused.

00:23:48.366 --> 00:23:50.316
This should have improved your

00:23:50.316 --> 00:23:50.776
build times.

00:23:53.946 --> 00:23:55.666
In order to do that, Clang

00:23:55.666 --> 00:23:57.136
modules must have certain

00:23:57.136 --> 00:23:57.716
properties.

00:23:58.386 --> 00:24:00.216
One of them, one of the most

00:24:00.286 --> 00:24:02.966
important one is context-free.

00:24:03.516 --> 00:24:04.846
What do I mean by context-free?

00:24:05.446 --> 00:24:08.306
You can see here two code

00:24:08.306 --> 00:24:08.896
snippets.

00:24:09.276 --> 00:24:11.626
In both cases we import the

00:24:11.706 --> 00:24:12.766
PetKit module.

00:24:13.966 --> 00:24:16.686
But we have two different macro

00:24:16.686 --> 00:24:17.826
definitions beforehand.

00:24:19.456 --> 00:24:20.976
If you would use a traditional

00:24:20.976 --> 00:24:22.536
model of importing those

00:24:22.536 --> 00:24:23.716
headers, that means they're

00:24:24.106 --> 00:24:24.696
[inaudible] included.

00:24:25.376 --> 00:24:27.496
The preprocessor would honor

00:24:27.496 --> 00:24:29.396
this definition and apply it to

00:24:29.396 --> 00:24:30.516
the header file.

00:24:31.266 --> 00:24:32.546
But if you would do that, that

00:24:32.546 --> 00:24:33.826
means the modules would be

00:24:33.826 --> 00:24:35.786
different for each header case,

00:24:35.786 --> 00:24:37.486
and we couldn't reuse it.

00:24:37.726 --> 00:24:40.136
So if you want to use modules,

00:24:40.336 --> 00:24:41.306
you cannot do that.

00:24:41.926 --> 00:24:44.016
Instead, the module will ignore

00:24:44.016 --> 00:24:45.746
all those context-related

00:24:45.886 --> 00:24:48.036
information that allows us to

00:24:48.036 --> 00:24:49.716
be, that allows it to be reused

00:24:50.186 --> 00:24:52.246
across all implementation files.

00:24:53.816 --> 00:24:57.106
Another requirement is modules

00:24:57.106 --> 00:24:58.226
have to be self-contained.

00:24:59.006 --> 00:25:01.126
That means they have to specify

00:25:01.666 --> 00:25:02.836
all the dependencies.

00:25:03.736 --> 00:25:05.496
Which also has a nice advantage

00:25:05.876 --> 00:25:08.186
for you because it means once

00:25:08.186 --> 00:25:10.846
you import a module, it will

00:25:10.846 --> 00:25:11.636
just work.

00:25:11.636 --> 00:25:12.926
You don't have to worry about

00:25:12.926 --> 00:25:14.016
adding any additional header

00:25:14.016 --> 00:25:16.346
files to make that import work.

00:25:18.956 --> 00:25:22.056
So how do we know or how does

00:25:22.056 --> 00:25:23.996
Clang know it should build a

00:25:23.996 --> 00:25:24.426
module?

00:25:26.046 --> 00:25:27.976
Let's look at a simple example

00:25:27.976 --> 00:25:31.556
here NSString.h. First Clang has

00:25:31.556 --> 00:25:33.126
to find this particular header

00:25:33.566 --> 00:25:34.456
in the framework.

00:25:35.056 --> 00:25:37.936
And we already know how to do

00:25:37.936 --> 00:25:38.116
that.

00:25:38.756 --> 00:25:39.576
And it's the

00:25:39.796 --> 00:25:41.116
Foundation.framework directory.

00:25:42.166 --> 00:25:43.666
Next the Clang compiler will

00:25:43.706 --> 00:25:46.116
look for a modules directory and

00:25:46.116 --> 00:25:47.996
a Module Map relative to the

00:25:47.996 --> 00:25:49.706
header's directory and it's

00:25:49.766 --> 00:25:49.936
there.

00:25:51.606 --> 00:25:52.926
So what is a Module Map?

00:25:53.486 --> 00:25:55.566
A Module Map describes how a

00:25:55.566 --> 00:25:57.406
certain set of header files

00:25:57.796 --> 00:25:59.556
translate onto your module.

00:26:01.026 --> 00:26:02.646
So let's have a look.

00:26:03.596 --> 00:26:05.606
The Module Map is actually very

00:26:05.606 --> 00:26:06.066
simple.

00:26:06.196 --> 00:26:07.876
This is the whole Module Map for

00:26:07.876 --> 00:26:08.426
foundation.

00:26:08.626 --> 00:26:08.966
That's it.

00:26:09.996 --> 00:26:12.256
It obviously describes what is

00:26:12.296 --> 00:26:13.446
the name of the module which is,

00:26:13.446 --> 00:26:13.936
Foundation.

00:26:14.436 --> 00:26:17.636
And then it also specifies what

00:26:17.746 --> 00:26:19.616
headers are part of this module.

00:26:20.716 --> 00:26:22.746
You'll notice there's only one

00:26:22.746 --> 00:26:24.036
header file here, only

00:26:24.036 --> 00:26:26.236
Foundation.h. But this is a

00:26:26.236 --> 00:26:27.166
special header file.

00:26:27.616 --> 00:26:28.646
This is the umbrella header

00:26:29.086 --> 00:26:30.496
which is also marked by the

00:26:30.496 --> 00:26:31.476
special keyword umbrella.

00:26:32.496 --> 00:26:34.806
That means Clang has also to

00:26:34.806 --> 00:26:36.286
look into this particular header

00:26:36.286 --> 00:26:39.816
file to figure out if NSString.h

00:26:39.816 --> 00:26:40.806
is part of the module.

00:26:42.356 --> 00:26:44.716
And yeah, it's there, okay.

00:26:45.236 --> 00:26:46.766
So now we have found out

00:26:47.096 --> 00:26:48.926
NSString.h is part of the

00:26:48.926 --> 00:26:49.876
foundation module.

00:26:50.666 --> 00:26:52.726
Now Clang, now Clang can upgrade

00:26:52.966 --> 00:26:55.036
this textual import to a module

00:26:55.036 --> 00:26:57.386
import and we know we have to

00:26:57.476 --> 00:26:58.816
build the foundation module to

00:26:59.616 --> 00:27:00.946
do that.

00:27:01.116 --> 00:27:02.086
So how do we build the

00:27:02.086 --> 00:27:02.966
foundation module?

00:27:03.916 --> 00:27:05.916
First of all, we create a

00:27:05.986 --> 00:27:07.126
separate Clang location for

00:27:07.126 --> 00:27:07.306
that.

00:27:08.186 --> 00:27:10.466
And that Clang location contains

00:27:10.646 --> 00:27:12.076
all the header files from the

00:27:12.076 --> 00:27:12.826
foundation module.

00:27:13.476 --> 00:27:17.216
We don't transfer any of the

00:27:17.216 --> 00:27:19.626
existing context from the

00:27:19.626 --> 00:27:21.136
original compiler invocation.

00:27:21.586 --> 00:27:23.256
Hence, it's context-free.

00:27:24.126 --> 00:27:25.896
The thing we actually transfer

00:27:25.896 --> 00:27:27.346
are the command line arguments

00:27:27.346 --> 00:27:28.176
you passed to Clang.

00:27:28.446 --> 00:27:31.966
Those are passed on.

00:27:32.226 --> 00:27:33.586
While we build the foundation

00:27:33.586 --> 00:27:36.496
module, we mod-- the module

00:27:36.496 --> 00:27:37.816
itself or the framework, the

00:27:37.816 --> 00:27:40.176
framework itself will include

00:27:40.316 --> 00:27:41.776
additional frameworks.

00:27:42.086 --> 00:27:43.866
That means we have to build

00:27:43.866 --> 00:27:44.836
those modules too.

00:27:45.616 --> 00:27:48.226
And we have to keep going

00:27:48.226 --> 00:27:50.156
because those might also include

00:27:50.156 --> 00:27:51.256
additional frameworks.

00:27:52.346 --> 00:27:53.536
But we already can see there is

00:27:53.536 --> 00:27:54.266
a benefit here.

00:27:55.296 --> 00:27:56.676
Some of those imports might be

00:27:56.676 --> 00:27:57.266
the same.

00:27:57.706 --> 00:27:59.586
So we can always start reusing

00:27:59.586 --> 00:28:00.256
that module.

00:28:00.896 --> 00:28:03.896
All those modules are

00:28:04.036 --> 00:28:05.566
[inaudible] to disk into

00:28:05.566 --> 00:28:06.916
something called a module cache.

00:28:07.466 --> 00:28:12.166
As I mentioned, the command line

00:28:12.166 --> 00:28:14.076
arguments are passed on when you

00:28:14.196 --> 00:28:15.006
create that module.

00:28:15.806 --> 00:28:18.536
That means, that means those

00:28:18.536 --> 00:28:21.236
arguments can affect the content

00:28:21.236 --> 00:28:21.936
of your module.

00:28:22.806 --> 00:28:25.336
As a result, we have to hash all

00:28:25.336 --> 00:28:27.816
those arguments and store the

00:28:27.816 --> 00:28:29.036
modules we created for this

00:28:29.036 --> 00:28:30.536
particular compiler invocation

00:28:30.886 --> 00:28:33.406
in a directory matching that

00:28:34.296 --> 00:28:34.456
hash.

00:28:34.616 --> 00:28:36.366
If you change the compiler

00:28:36.366 --> 00:28:37.796
arguments for different

00:28:37.796 --> 00:28:39.906
limitation file, for example

00:28:40.116 --> 00:28:43.196
you'd say enable cat, that is a

00:28:43.196 --> 00:28:45.586
different hash and that requires

00:28:45.966 --> 00:28:48.026
Clang to rebuild all the

00:28:48.026 --> 00:28:50.156
module's inputs into that

00:28:50.156 --> 00:28:52.146
directory matching that hash.

00:28:53.366 --> 00:28:55.246
So in order to get the maximum

00:28:55.246 --> 00:28:57.216
reuse out of the module cache,

00:28:57.716 --> 00:29:00.026
you should try to keep the

00:29:00.026 --> 00:29:02.086
arguments the same, if possible.

00:29:02.646 --> 00:29:07.746
So this is how we find and build

00:29:07.746 --> 00:29:09.456
modules for system frameworks

00:29:10.426 --> 00:29:12.436
but what about your frameworks?

00:29:12.876 --> 00:29:14.316
How do we build modules for

00:29:14.316 --> 00:29:14.706
those?

00:29:15.246 --> 00:29:18.106
Let's go back to our original

00:29:18.106 --> 00:29:20.156
cat example, and this time we

00:29:20.156 --> 00:29:20.986
turn on modules.

00:29:21.676 --> 00:29:24.826
If we would use a headermap

00:29:24.826 --> 00:29:27.256
again, the headermap will point

00:29:27.256 --> 00:29:29.906
us back to the source directory.

00:29:30.506 --> 00:29:32.876
But if you look at that source

00:29:32.876 --> 00:29:34.016
directory, we have a problem

00:29:34.016 --> 00:29:34.336
now.

00:29:34.906 --> 00:29:36.956
Theirs is no modules directory.

00:29:38.246 --> 00:29:39.496
It doesn't look like a framework

00:29:39.496 --> 00:29:42.946
at all and Clang doesn't know

00:29:42.946 --> 00:29:44.606
how to do this in this case.

00:29:45.526 --> 00:29:47.476
So we introduced a new concept

00:29:47.606 --> 00:29:49.846
to solve this, and it's called

00:29:50.126 --> 00:29:51.676
Clang's Virtual File System.

00:29:52.606 --> 00:29:54.556
It basically creates a virtual

00:29:54.556 --> 00:29:57.016
abstraction of a framework that

00:29:57.016 --> 00:29:58.656
allows Clang to build the

00:29:58.656 --> 00:29:59.216
module.

00:30:00.006 --> 00:30:02.356
But the abstraction basically

00:30:02.356 --> 00:30:04.076
only points to the files back in

00:30:04.076 --> 00:30:04.696
your directory.

00:30:05.406 --> 00:30:07.726
So again, Clang will be able to

00:30:07.726 --> 00:30:08.996
produce [inaudible] and errors

00:30:09.106 --> 00:30:10.036
for your source code.

00:30:10.646 --> 00:30:13.406
And that's how we build modules

00:30:13.986 --> 00:30:15.726
for, when you have frameworks.

00:30:16.256 --> 00:30:19.186
As you remember, in the

00:30:19.186 --> 00:30:20.926
beginning I mentioned there

00:30:20.926 --> 00:30:23.046
might be issues if you don't

00:30:23.046 --> 00:30:24.906
specify the framework name.

00:30:25.496 --> 00:30:27.286
So let me give you an example

00:30:27.326 --> 00:30:28.426
where this can go wrong.

00:30:28.976 --> 00:30:31.186
This is a very simple-- very

00:30:31.186 --> 00:30:31.966
simple code example.

00:30:31.966 --> 00:30:33.646
We only have two imports.

00:30:34.036 --> 00:30:36.316
The first import imports the

00:30:36.316 --> 00:30:37.456
pet, PetKit module.

00:30:38.896 --> 00:30:41.786
The second import, you and I

00:30:41.786 --> 00:30:43.586
know this is also part of the

00:30:43.586 --> 00:30:46.116
PetKit module, but Clang might

00:30:46.116 --> 00:30:47.336
now be able to figure that out

00:30:48.116 --> 00:30:49.486
because you didn't specify the

00:30:49.486 --> 00:30:50.156
framework name.

00:30:50.716 --> 00:30:53.846
In this case, it might be

00:30:53.916 --> 00:30:56.076
possible you get duplicate

00:30:56.076 --> 00:30:56.886
definition errors.

00:30:56.886 --> 00:30:58.876
That's basically, that basically

00:30:58.876 --> 00:31:00.176
happens when you import the same

00:31:00.176 --> 00:31:01.036
header twice.

00:31:03.216 --> 00:31:05.246
Clang works very hard behind the

00:31:05.246 --> 00:31:07.556
scenes to fix the most common

00:31:07.596 --> 00:31:09.176
issues that happen like this.

00:31:10.616 --> 00:31:12.116
But it cannot fix all of them.

00:31:13.286 --> 00:31:14.156
And this is just a simple

00:31:14.156 --> 00:31:14.686
example.

00:31:15.506 --> 00:31:18.396
Let's just make a little tweak.

00:31:18.606 --> 00:31:19.956
Let's change the context.

00:31:21.436 --> 00:31:24.296
Now the module import won't be

00:31:24.296 --> 00:31:26.046
affected by this at all because

00:31:26.046 --> 00:31:27.336
as I said, we ignore the

00:31:27.336 --> 00:31:27.946
context.

00:31:28.476 --> 00:31:32.086
The cat import is still a

00:31:32.086 --> 00:31:33.606
textual inclusion of the header

00:31:33.946 --> 00:31:35.596
which will observe this change.

00:31:36.386 --> 00:31:38.586
So now you might not even have

00:31:38.666 --> 00:31:39.736
duplicate definitions.

00:31:40.006 --> 00:31:40.616
You might even have

00:31:40.866 --> 00:31:42.206
contradictory definitions.

00:31:42.526 --> 00:31:43.966
Which can mean we cannot fix,

00:31:44.766 --> 00:31:46.096
Clang cannot fix this for you.

00:31:47.036 --> 00:31:48.796
So as I recommended in the

00:31:48.796 --> 00:31:51.126
beginning, always specify the

00:31:51.126 --> 00:31:53.526
framework name when you import

00:31:53.746 --> 00:31:55.316
your public or private headers.

00:31:56.676 --> 00:31:57.636
And now I'm handing it over to

00:31:57.636 --> 00:31:59.726
Devin who's going to talk about

00:31:59.726 --> 00:32:01.656
Swift and how Swift uses Clang

00:32:01.656 --> 00:32:01.976
modules.

00:32:02.516 --> 00:32:08.606
[ Applause ]

00:32:09.106 --> 00:32:09.846
>> Thanks, Jurgen.

00:32:10.406 --> 00:32:12.696
We're now going to dive into the

00:32:12.696 --> 00:32:14.746
details of how Swift and the

00:32:14.746 --> 00:32:17.216
build system work together to

00:32:17.216 --> 00:32:18.906
find declarations across your

00:32:18.966 --> 00:32:19.966
project.

00:32:21.216 --> 00:32:22.946
To recap some of what Jurgen

00:32:22.946 --> 00:32:24.936
told you, Clang compiles each

00:32:24.936 --> 00:32:26.946
Objective-C file separately.

00:32:27.856 --> 00:32:29.406
This means if you want to refer

00:32:29.406 --> 00:32:31.156
to a class to find in another

00:32:31.156 --> 00:32:33.476
file, you have to import a

00:32:33.476 --> 00:32:37.406
header that declares that class.

00:32:37.516 --> 00:32:39.396
But Swift was designed to not

00:32:39.396 --> 00:32:41.006
require you to write headers.

00:32:41.626 --> 00:32:42.606
This makes it easier for

00:32:42.606 --> 00:32:43.916
beginners to get started with

00:32:43.916 --> 00:32:44.526
the language.

00:32:44.946 --> 00:32:46.606
And avoids you having to repeat

00:32:46.686 --> 00:32:48.506
a declaration in a separate

00:32:48.506 --> 00:32:48.856
file.

00:32:50.116 --> 00:32:51.636
However this does mean that the

00:32:51.636 --> 00:32:53.156
compiler has to perform some

00:32:53.156 --> 00:32:54.196
additional bookkeeping.

00:32:55.036 --> 00:32:56.196
I'm going to tell you how that

00:32:56.236 --> 00:32:57.186
bookkeeping works.

00:32:57.646 --> 00:33:01.066
Let's return to our example,

00:33:01.136 --> 00:33:01.796
PetWall app.

00:33:02.956 --> 00:33:04.266
The app has a view in

00:33:04.266 --> 00:33:05.356
ViewCcontroller, written in

00:33:05.406 --> 00:33:05.846
Swift.

00:33:06.936 --> 00:33:08.476
An Objective-C app delegate.

00:33:09.076 --> 00:33:10.506
And Swift unit tests.

00:33:11.686 --> 00:33:13.256
In order to compile even just

00:33:13.256 --> 00:33:15.036
this top PetViewController part

00:33:15.076 --> 00:33:17.316
of the file, the compiler has to

00:33:17.316 --> 00:33:18.446
perform four different

00:33:18.446 --> 00:33:19.276
operations.

00:33:20.426 --> 00:33:21.836
First, it has to find

00:33:21.936 --> 00:33:22.576
declarations.

00:33:23.396 --> 00:33:25.806
Both within the Swift target and

00:33:25.836 --> 00:33:27.556
also coming from Objective-C.

00:33:29.016 --> 00:33:30.706
Further, it has to generate

00:33:30.706 --> 00:33:31.986
interfaces describing the

00:33:31.986 --> 00:33:33.106
contents of the file.

00:33:33.516 --> 00:33:35.096
So that its declarations can be

00:33:35.096 --> 00:33:37.326
found and used in Objective-C

00:33:37.796 --> 00:33:39.606
and in other Swift targets.

00:33:40.836 --> 00:33:41.906
In the rest of this section of

00:33:41.906 --> 00:33:43.156
the talk, I'm going to walk

00:33:43.156 --> 00:33:44.746
through this example to

00:33:44.746 --> 00:33:46.186
illustrate each of these four

00:33:46.186 --> 00:33:46.836
tasks.

00:33:47.766 --> 00:33:48.786
Let's start with finding

00:33:48.786 --> 00:33:50.386
declarations within a Swift

00:33:50.386 --> 00:33:50.776
target.

00:33:55.296 --> 00:33:56.326
When compiling

00:33:56.376 --> 00:33:58.936
PetViewController.swift, the

00:33:58.936 --> 00:34:00.616
compiler will look up the type

00:34:00.786 --> 00:34:03.046
of PetView's initializer so that

00:34:03.046 --> 00:34:03.926
it can check the call.

00:34:05.496 --> 00:34:07.526
But before it can do that, it

00:34:07.526 --> 00:34:10.426
needs to parse PetView.swift and

00:34:10.426 --> 00:34:11.106
validate it.

00:34:11.676 --> 00:34:12.356
To make sure that the

00:34:12.356 --> 00:34:13.835
declaration of the initializer

00:34:13.946 --> 00:34:14.826
is well formed.

00:34:15.835 --> 00:34:17.386
Now, the compiler's smart enough

00:34:17.386 --> 00:34:19.366
to know that it doesn't need to

00:34:19.366 --> 00:34:20.326
check the body of the

00:34:20.326 --> 00:34:21.295
initializer here.

00:34:22.156 --> 00:34:23.335
But it does still need to do

00:34:23.335 --> 00:34:24.985
some work just to process the

00:34:24.985 --> 00:34:26.556
interface parts of the file.

00:34:30.045 --> 00:34:31.926
What this means is that unlike

00:34:32.065 --> 00:34:34.416
Clang, when compiling one Swift

00:34:34.416 --> 00:34:36.815
file, the compiler will parse

00:34:36.906 --> 00:34:38.606
all the other Swift files in the

00:34:38.606 --> 00:34:39.065
target.

00:34:39.446 --> 00:34:40.666
To examine the parts of them

00:34:40.876 --> 00:34:41.886
that are relevant to the

00:34:41.886 --> 00:34:42.696
interfaces.

00:34:48.335 --> 00:34:50.255
IN Xcode 9, this resulted in

00:34:50.255 --> 00:34:52.096
some repeated work in repeated

00:34:52.096 --> 00:34:53.536
build-- in incremental debug

00:34:53.576 --> 00:34:54.045
builds.

00:34:54.096 --> 00:34:55.936
Because the compiler compiled

00:34:56.025 --> 00:34:57.416
each file separately.

00:34:58.396 --> 00:34:59.656
This enabled the files to be

00:34:59.656 --> 00:35:01.446
compiled in parallel, but it

00:35:01.446 --> 00:35:02.716
forced the compiler to

00:35:02.716 --> 00:35:04.286
repeatedly parse each file.

00:35:05.386 --> 00:35:07.006
Once as an implementation to

00:35:07.006 --> 00:35:09.536
produce a .o, and multiple times

00:35:09.736 --> 00:35:11.626
as an interface to find

00:35:11.626 --> 00:35:12.486
declarations.

00:35:13.976 --> 00:35:16.636
Xcode 10 reduces this overhead.

00:35:17.546 --> 00:35:19.296
It does so by combining the

00:35:19.296 --> 00:35:21.556
files into groups that share as

00:35:21.556 --> 00:35:23.056
much work as possible.

00:35:23.646 --> 00:35:26.206
While still allowing maximum

00:35:26.206 --> 00:35:26.996
parallelism.

00:35:27.956 --> 00:35:29.796
This reuses parsing within a

00:35:29.796 --> 00:35:32.656
group and only repeats work

00:35:32.656 --> 00:35:33.666
across groups.

00:35:34.596 --> 00:35:36.186
Since the number of groups is

00:35:36.186 --> 00:35:38.656
typically relatively low, this

00:35:38.656 --> 00:35:41.066
can significantly speed up your

00:35:41.066 --> 00:35:41.976
incremental debug builds.

00:35:45.876 --> 00:35:48.096
Now, Swift code doesn't only

00:35:48.096 --> 00:35:49.636
call other Swift code.

00:35:50.156 --> 00:35:53.406
It can also call Objective-C.

00:35:53.656 --> 00:35:55.216
Returning to our PetWall example

00:35:55.216 --> 00:35:57.586
app, we can see that, that this

00:35:57.586 --> 00:35:59.316
is crucial since the system

00:35:59.316 --> 00:36:01.496
frameworks such as UIKit are

00:36:01.496 --> 00:36:02.766
written in Objective-C.

00:36:06.696 --> 00:36:08.396
Swift takes a different approach

00:36:08.676 --> 00:36:10.126
than many other languages.

00:36:10.326 --> 00:36:11.886
And it doesn't require you to

00:36:12.186 --> 00:36:13.316
provide a foreign function

00:36:13.316 --> 00:36:14.036
interface.

00:36:15.576 --> 00:36:17.086
This is where you would have to,

00:36:17.086 --> 00:36:18.416
for example, write a Swift

00:36:18.416 --> 00:36:20.536
declaration for each Objective-C

00:36:20.536 --> 00:36:21.846
API you want to use.

00:36:23.056 --> 00:36:25.066
Instead, the compiler embeds a

00:36:25.066 --> 00:36:27.556
large part of Clang inside of it

00:36:28.316 --> 00:36:29.566
and uses it as a library.

00:36:30.556 --> 00:36:32.326
This makes it possible to import

00:36:32.326 --> 00:36:34.136
Objective-C frameworks directly.

00:36:36.896 --> 00:36:38.196
So where do Objective-C

00:36:38.196 --> 00:36:39.306
declarations come from?

00:36:40.376 --> 00:36:41.566
The compile-- the importer will

00:36:41.566 --> 00:36:43.066
look in headers depending on the

00:36:43.146 --> 00:36:44.076
type of the target.

00:36:45.596 --> 00:36:47.926
In any target, when you import

00:36:47.926 --> 00:36:50.166
an Objective-C framework, the

00:36:50.166 --> 00:36:51.796
importer finds declarations in

00:36:51.796 --> 00:36:53.726
the headers exposing Clang's

00:36:53.726 --> 00:36:55.256
module map for that framework.

00:36:56.716 --> 00:36:58.396
Within a framework that mixes

00:36:58.396 --> 00:37:00.656
Swift and Objective-C code, the

00:37:00.656 --> 00:37:02.436
importer finds declarations in

00:37:02.436 --> 00:37:03.226
the umbrella header.

00:37:04.646 --> 00:37:05.936
This is the header that defines

00:37:05.976 --> 00:37:07.176
the public interface.

00:37:08.316 --> 00:37:10.156
In this way, Swift code inside

00:37:10.186 --> 00:37:11.876
the framework can call public

00:37:11.876 --> 00:37:13.926
Objective-C code in the same

00:37:14.036 --> 00:37:14.466
framework.

00:37:16.636 --> 00:37:18.496
Finally, within your app and

00:37:18.496 --> 00:37:20.466
unit tests, you can add imports

00:37:20.466 --> 00:37:21.876
to the target's bridging header.

00:37:22.256 --> 00:37:23.766
To allow declarations from them

00:37:24.156 --> 00:37:25.486
to be called from Swift.

00:37:25.906 --> 00:37:30.786
Now when the importer brings in

00:37:30.786 --> 00:37:32.856
declarations, it often changes

00:37:32.856 --> 00:37:34.076
them to make them more

00:37:34.076 --> 00:37:34.636
idiomatic.

00:37:35.666 --> 00:37:36.906
For example, it will import

00:37:36.906 --> 00:37:38.546
Objective-C methods that use the

00:37:38.546 --> 00:37:41.146
NSError idiom as throwing

00:37:41.146 --> 00:37:43.286
methods using Swift's built-in

00:37:43.286 --> 00:37:44.596
error handling language feature.

00:37:45.256 --> 00:37:49.286
In particular, it will drop

00:37:49.436 --> 00:37:51.276
parameter type names following

00:37:51.276 --> 00:37:52.606
verbs and prepositions.

00:37:53.976 --> 00:37:56.006
For example, the drawPet atPoint

00:37:56.046 --> 00:37:57.846
method has the word pet.

00:37:58.636 --> 00:38:00.146
For a parameter of type pet

00:38:00.826 --> 00:38:02.046
following the verb draw.

00:38:03.096 --> 00:38:06.456
And similarly the word point for

00:38:06.456 --> 00:38:08.206
a parameter of type CGPoint

00:38:08.776 --> 00:38:10.606
following the preposition at.

00:38:11.736 --> 00:38:13.946
These words are omitted in Swift

00:38:14.236 --> 00:38:15.886
when the method is imported as

00:38:15.886 --> 00:38:18.326
simply draw at.

00:38:19.156 --> 00:38:20.266
So how does this work?

00:38:21.126 --> 00:38:22.806
Well, you might be surprised to

00:38:22.806 --> 00:38:24.996
know that the compiler contains

00:38:24.996 --> 00:38:26.946
a list of common English verbs

00:38:26.946 --> 00:38:27.836
and prepositions.

00:38:29.416 --> 00:38:31.346
Because it is just a hard-coded

00:38:31.346 --> 00:38:32.656
list and human language is

00:38:32.656 --> 00:38:34.416
messy, sometimes it's missing

00:38:34.416 --> 00:38:34.936
words.

00:38:35.796 --> 00:38:37.376
Furthermore, in order to match

00:38:37.376 --> 00:38:39.126
Swift's naming conventions, the

00:38:39.126 --> 00:38:40.826
importer will also rename

00:38:40.826 --> 00:38:43.116
methods to remove words based on

00:38:43.116 --> 00:38:43.996
the part of speech.

00:38:45.206 --> 00:38:47.316
For example the verb feed is not

00:38:47.366 --> 00:38:49.376
in the list, and so feedPet is

00:38:49.376 --> 00:38:51.646
not imported as feed as we might

00:38:51.646 --> 00:38:52.096
expect.

00:38:53.546 --> 00:38:55.246
When this happens, you can use

00:38:55.246 --> 00:38:57.686
the NS Swift Name annotation to

00:38:57.686 --> 00:38:59.416
have the compiler import the

00:38:59.416 --> 00:39:01.966
method exactly as you want.

00:39:06.146 --> 00:39:07.326
Now if you want to check to see

00:39:07.326 --> 00:39:08.636
how your Objective-C header will

00:39:08.636 --> 00:39:10.586
be imported into Swift, you can

00:39:10.586 --> 00:39:12.276
always go to Xcode's related

00:39:12.276 --> 00:39:13.066
items popup.

00:39:13.546 --> 00:39:14.646
This is in the upper left-hand

00:39:14.646 --> 00:39:15.906
corner of the source editor.

00:39:16.606 --> 00:39:17.756
If you select generated

00:39:17.756 --> 00:39:19.916
interfaces, it will show you how

00:39:19.916 --> 00:39:21.506
the interface will look in

00:39:21.506 --> 00:39:23.346
different versions of Swift.

00:39:25.216 --> 00:39:26.696
So that's how Swift imports

00:39:26.696 --> 00:39:27.446
Objective-C.

00:39:28.366 --> 00:39:29.056
But what about the other

00:39:29.056 --> 00:39:29.526
direction?

00:39:30.246 --> 00:39:32.146
How does Objective-C import

00:39:32.146 --> 00:39:33.486
Swift?

00:39:35.076 --> 00:39:36.626
The answer is that Swift

00:39:36.736 --> 00:39:38.426
generates a header that you can

00:39:38.426 --> 00:39:39.096
pound import.

00:39:39.986 --> 00:39:41.626
This allows you to write classes

00:39:41.626 --> 00:39:43.636
in Swift and call them from

00:39:43.636 --> 00:39:44.366
Objective-C.

00:39:45.696 --> 00:39:46.726
Let's see how this works.

00:39:47.206 --> 00:39:49.746
The compiler will generate

00:39:49.746 --> 00:39:51.536
Objective-C declarations for

00:39:51.536 --> 00:39:53.766
Swift classes extending NSObject

00:39:54.156 --> 00:39:56.566
and methods marked at obc.

00:39:57.156 --> 00:39:59.066
For apps in unit tests, the

00:39:59.066 --> 00:40:00.856
header will include both public

00:40:00.856 --> 00:40:02.476
and internal declarations.

00:40:03.056 --> 00:40:04.516
This allows you to use internal

00:40:04.516 --> 00:40:06.416
Swift from the Objective-C parts

00:40:06.456 --> 00:40:07.626
of your app.

00:40:08.416 --> 00:40:10.296
For frameworks, however, the

00:40:10.296 --> 00:40:11.846
generated header provides only

00:40:11.846 --> 00:40:13.126
public declarations.

00:40:13.456 --> 00:40:14.736
Since it's included in your

00:40:14.736 --> 00:40:16.386
build products and it's part of

00:40:16.386 --> 00:40:17.316
the framework's public

00:40:17.316 --> 00:40:17.986
interface.

00:40:18.516 --> 00:40:22.286
On the right, you can see that

00:40:22.286 --> 00:40:23.426
the compiler ties the

00:40:23.426 --> 00:40:25.646
Objective-C class to the mangled

00:40:25.646 --> 00:40:27.956
name of the Swift class which

00:40:27.956 --> 00:40:29.336
includes the name of the module,

00:40:29.806 --> 00:40:30.276
PetWall.

00:40:30.896 --> 00:40:33.066
Now I'm going to tell you about

00:40:33.066 --> 00:40:35.346
modules in a bit, and Louis will

00:40:35.346 --> 00:40:36.426
tell you about mangling.

00:40:36.966 --> 00:40:38.316
But for now, the thing to know

00:40:38.646 --> 00:40:40.296
is that this prevents a conflict

00:40:40.296 --> 00:40:41.786
in the runtime when the two

00:40:41.786 --> 00:40:43.736
modules define a class with the

00:40:43.736 --> 00:40:44.416
same name.

00:40:44.926 --> 00:40:47.646
You can tell Swift to use a

00:40:47.646 --> 00:40:49.176
different name for the class in

00:40:49.176 --> 00:40:51.066
Objective-C by passing an

00:40:51.066 --> 00:40:53.476
identifier to the obc attribute.

00:40:54.266 --> 00:40:55.746
But if you do this, you're

00:40:55.746 --> 00:40:57.436
responsible for making sure the

00:40:57.436 --> 00:40:58.586
names don't conflict.

00:40:59.966 --> 00:41:02.776
Here I've used the PWL prefix so

00:41:02.876 --> 00:41:04.286
to reduce the likelihood of a

00:41:04.286 --> 00:41:04.836
conflict.

00:41:05.696 --> 00:41:07.246
With this change, I can refer to

00:41:07.246 --> 00:41:10.436
the class as PWLPetCollar in

00:41:10.436 --> 00:41:11.196
Objective-C.

00:41:13.836 --> 00:41:15.396
The compiler takes a similar

00:41:15.396 --> 00:41:16.696
approach to generating

00:41:16.696 --> 00:41:18.456
interfaces to other Swift

00:41:18.456 --> 00:41:19.066
targets.

00:41:19.626 --> 00:41:23.496
To do this, Swift builds on

00:41:23.496 --> 00:41:25.076
Clang's concept of a module,

00:41:25.436 --> 00:41:26.596
which Jurgen told you about.

00:41:27.326 --> 00:41:28.656
And more deeply integrates it

00:41:28.656 --> 00:41:29.556
into the language.

00:41:30.756 --> 00:41:32.396
In Swift, a module is a

00:41:32.396 --> 00:41:33.656
distributable unit of

00:41:33.656 --> 00:41:34.516
declarations.

00:41:34.916 --> 00:41:36.216
And to be able to use those

00:41:36.216 --> 00:41:38.386
declarations you have to import

00:41:38.556 --> 00:41:39.146
the module.

00:41:40.406 --> 00:41:42.056
You can import Objective-C

00:41:42.056 --> 00:41:42.666
modules.

00:41:43.006 --> 00:41:44.346
XEtest, for example.

00:41:45.366 --> 00:41:47.626
And in Xcode each Swift target

00:41:47.756 --> 00:41:49.486
produces a separate module.

00:41:50.126 --> 00:41:51.226
Including your app target.

00:41:52.546 --> 00:41:53.876
This is why you have to import

00:41:53.876 --> 00:41:55.726
your app's main module in order

00:41:55.726 --> 00:42:00.536
to test it from your unit tests.

00:42:00.696 --> 00:42:02.246
When importing a module, the

00:42:02.246 --> 00:42:04.596
compiler deserializes a special

00:42:04.596 --> 00:42:06.876
Swift module file to check the

00:42:06.876 --> 00:42:07.966
types when you use them.

00:42:09.196 --> 00:42:10.896
For example, in this unit test,

00:42:10.896 --> 00:42:12.066
the compiler will load the

00:42:12.066 --> 00:42:14.426
PetViewController parts of the

00:42:14.426 --> 00:42:16.496
PetWall Swift module to make

00:42:16.496 --> 00:42:17.456
sure that you're creating the

00:42:17.456 --> 00:42:18.506
controller correctly.

00:42:19.836 --> 00:42:20.956
This is similar to how the

00:42:20.956 --> 00:42:22.716
compiler finds declarations

00:42:22.916 --> 00:42:24.516
within a target as I showed you

00:42:24.516 --> 00:42:24.936
earlier.

00:42:26.026 --> 00:42:27.816
Except that here, the compiler

00:42:27.816 --> 00:42:29.356
loads a file summarizing the

00:42:29.356 --> 00:42:31.826
module rather than parsing Swift

00:42:31.826 --> 00:42:32.976
files directly.

00:42:36.096 --> 00:42:38.006
The compiler produces this Swift

00:42:38.006 --> 00:42:40.006
module file a lot like a

00:42:40.006 --> 00:42:41.576
generated Objective-C header.

00:42:42.386 --> 00:42:43.786
But instead of text, it's a

00:42:43.786 --> 00:42:45.096
binary representation.

00:42:46.116 --> 00:42:47.266
It includes the bodies of

00:42:47.266 --> 00:42:48.976
inlineable functions much like

00:42:48.976 --> 00:42:50.206
static inline functions in

00:42:50.206 --> 00:42:51.726
Objective-C or header

00:42:51.726 --> 00:42:53.756
implementations in C++.

00:42:54.906 --> 00:42:56.756
However, one thing to be aware

00:42:56.756 --> 00:42:58.876
of is that it does include the

00:42:58.876 --> 00:43:00.546
names and types of private

00:43:00.546 --> 00:43:01.426
declarations.

00:43:02.186 --> 00:43:03.496
This allows you to refer to them

00:43:03.496 --> 00:43:05.006
in the debugger which is really

00:43:05.006 --> 00:43:05.706
handy.

00:43:06.306 --> 00:43:07.426
But it does mean that for

00:43:07.426 --> 00:43:09.376
example, you shouldn't name a

00:43:09.376 --> 00:43:10.756
private variable after your

00:43:10.756 --> 00:43:12.156
deepest, darkest secret.

00:43:15.596 --> 00:43:17.456
For incremental builds, the

00:43:17.456 --> 00:43:19.256
compiler produces partial Swift

00:43:19.256 --> 00:43:21.436
module files and then merges

00:43:21.436 --> 00:43:23.666
them into a single file that

00:43:23.666 --> 00:43:25.086
represents the contents of the

00:43:25.086 --> 00:43:25.836
entire module.

00:43:27.046 --> 00:43:28.686
This merging process also makes

00:43:28.686 --> 00:43:31.316
it possible to produce a single

00:43:31.396 --> 00:43:32.646
Objective-C header.

00:43:34.296 --> 00:43:36.366
In many ways, this is similar to

00:43:36.366 --> 00:43:37.636
what the linker does when it

00:43:37.636 --> 00:43:39.066
smooshes together your object

00:43:39.066 --> 00:43:41.526
files into a single executable.

00:43:42.306 --> 00:43:43.506
And to tell you more about that,

00:43:43.646 --> 00:43:45.726
I'll hand it off to Louis and

00:43:45.726 --> 00:43:46.186
the linker.

00:43:46.906 --> 00:43:47.766
Louis?

00:43:48.176 --> 00:43:48.976
>> Thank you, Devin.

00:43:49.516 --> 00:43:54.136
[ Applause ]

00:43:54.636 --> 00:43:56.206
Hi, I'm Louis Gerbarg.

00:43:56.206 --> 00:43:57.516
I work on the linker.

00:43:57.956 --> 00:43:59.046
Which is one of the final steps

00:43:59.046 --> 00:44:00.336
in the Xcode build process.

00:44:00.706 --> 00:44:02.906
So let's get to it.

00:44:03.166 --> 00:44:04.636
So first off I want to go over

00:44:04.636 --> 00:44:05.666
what we're going to talk about.

00:44:06.746 --> 00:44:07.996
We're going to talk about what a

00:44:07.996 --> 00:44:08.786
linker is.

00:44:09.646 --> 00:44:10.526
We're going to talk about the

00:44:10.526 --> 00:44:11.626
input that it takes which are

00:44:11.626 --> 00:44:13.236
dylibs and object files and what

00:44:13.236 --> 00:44:13.776
they are.

00:44:13.776 --> 00:44:15.476
And we're also going to talk

00:44:15.476 --> 00:44:17.276
about symbols which are what

00:44:17.276 --> 00:44:17.936
those contain.

00:44:18.996 --> 00:44:20.646
So at the end of this, I'm going

00:44:20.646 --> 00:44:21.486
to tie this together with an

00:44:21.486 --> 00:44:22.746
act-- with an example because

00:44:22.746 --> 00:44:24.716
this is pretty dense stuff.

00:44:25.206 --> 00:44:26.356
So if it seems a little

00:44:26.356 --> 00:44:27.116
confusing.

00:44:27.566 --> 00:44:28.906
Hold on, and hopefully we'll

00:44:28.906 --> 00:44:31.386
make it clearer.

00:44:31.506 --> 00:44:33.616
So what is the linker?

00:44:33.616 --> 00:44:34.636
It's like I said, it's one of

00:44:34.636 --> 00:44:36.756
the final processes in the

00:44:36.756 --> 00:44:37.076
build.

00:44:37.076 --> 00:44:39.746
And what we do is we combine all

00:44:39.746 --> 00:44:42.486
of these .o files that have been

00:44:42.486 --> 00:44:44.376
built by the two compilers into

00:44:44.376 --> 00:44:45.666
an executable.

00:44:47.146 --> 00:44:49.076
All it does is move and patch

00:44:49.156 --> 00:44:49.406
code.

00:44:49.406 --> 00:44:50.816
It cannot create code, and this

00:44:50.816 --> 00:44:52.486
is important and I will show

00:44:52.486 --> 00:44:54.486
that in the example.

00:44:55.416 --> 00:44:56.996
But we take these two kinds of

00:44:56.996 --> 00:44:57.876
input files.

00:44:58.326 --> 00:45:00.306
The first one being dylibs or

00:45:00.306 --> 00:45:01.146
being libraries.

00:45:01.556 --> 00:45:03.316
There are multiple-- the first

00:45:03.316 --> 00:45:04.616
one being object files.

00:45:04.876 --> 00:45:06.476
Which are what come out of your

00:45:06.476 --> 00:45:06.996
build process.

00:45:06.996 --> 00:45:07.756
And the second one being

00:45:07.756 --> 00:45:09.486
libraries which consist of

00:45:09.486 --> 00:45:11.026
several types including dylibs,

00:45:11.326 --> 00:45:13.746
tbd's, and .a files or static

00:45:13.746 --> 00:45:14.366
archives.

00:45:16.136 --> 00:45:17.936
So what are symbols?

00:45:18.556 --> 00:45:20.426
A symbol is just a name to refer

00:45:20.426 --> 00:45:23.746
to a fragment of code or data.

00:45:24.706 --> 00:45:26.626
These fragments may refer to

00:45:26.626 --> 00:45:28.816
other symbols which you would

00:45:28.816 --> 00:45:30.036
see if you write a function that

00:45:30.106 --> 00:45:30.986
calls another function.

00:45:33.376 --> 00:45:35.176
Symbols can have attributes on

00:45:35.176 --> 00:45:36.566
them that affect how the linker

00:45:36.566 --> 00:45:37.076
behaves.

00:45:37.076 --> 00:45:38.026
And there are a lot of these.

00:45:38.486 --> 00:45:39.546
I'm just going to give you one

00:45:39.546 --> 00:45:41.826
example which is a weak symbol.

00:45:42.336 --> 00:45:43.516
So a weak symbol is an

00:45:43.516 --> 00:45:44.896
annotation on a symbol that says

00:45:44.896 --> 00:45:48.026
it might not be there when we

00:45:48.026 --> 00:45:49.726
run the syst-- when we build

00:45:49.726 --> 00:45:51.396
the, when we run the executable

00:45:51.896 --> 00:45:52.706
on the system.

00:45:53.376 --> 00:45:54.106
This is what all the

00:45:54.106 --> 00:45:55.896
availability markup that says

00:45:56.336 --> 00:45:59.106
this API is available on iOS 12.

00:45:59.106 --> 00:46:00.606
And this API's available on the

00:46:00.606 --> 00:46:01.196
iOS 11.

00:46:01.686 --> 00:46:03.156
This, that's what it all boils

00:46:03.156 --> 00:46:04.536
down to by the time it gets to

00:46:04.536 --> 00:46:05.106
the linker.

00:46:05.376 --> 00:46:06.626
So the linker can determine what

00:46:06.626 --> 00:46:07.656
symbols are definitely going to

00:46:07.656 --> 00:46:08.856
be there versus what symbols it

00:46:08.856 --> 00:46:11.606
may have to, it may have to deal

00:46:11.606 --> 00:46:12.856
with at runtime.

00:46:14.756 --> 00:46:16.776
Languages can also encode data

00:46:16.776 --> 00:46:18.426
into the symbol by mangling it,

00:46:18.426 --> 00:46:19.786
as Devin mentioned earlier.

00:46:19.786 --> 00:46:25.066
And you'll see that in both C++

00:46:25.506 --> 00:46:27.186
and Swift.

00:46:27.326 --> 00:46:29.346
So we have symbols which are

00:46:29.346 --> 00:46:32.506
these names referring to code

00:46:32.506 --> 00:46:33.136
and data.

00:46:33.476 --> 00:46:35.866
So the compilers generate object

00:46:35.866 --> 00:46:36.076
files.

00:46:36.076 --> 00:46:37.256
And those object files are just

00:46:37.286 --> 00:46:40.996
collections of those code and

00:46:40.996 --> 00:46:41.296
data.

00:46:41.296 --> 00:46:43.956
They are not executable.

00:46:43.956 --> 00:46:45.496
While they are compiled code,

00:46:46.026 --> 00:46:47.436
they aren't finished.

00:46:47.816 --> 00:46:49.446
There are bits missing which is

00:46:49.446 --> 00:46:50.486
what the linker's going to glue

00:46:50.486 --> 00:46:53.946
together and fix up.

00:46:54.226 --> 00:46:55.986
Each fragment in one of those

00:46:55.986 --> 00:46:56.976
files is represented by a

00:46:56.976 --> 00:46:57.336
symbol.

00:46:57.336 --> 00:47:00.956
So for the printf function,

00:47:01.396 --> 00:47:02.646
there's code represented by a

00:47:02.646 --> 00:47:03.096
symbol.

00:47:03.496 --> 00:47:04.756
For any of the functions in

00:47:04.756 --> 00:47:06.176
PetKit which we're going to see

00:47:06.176 --> 00:47:09.716
in a second, the same thing.

00:47:09.936 --> 00:47:11.206
And fragments may reference

00:47:11.206 --> 00:47:12.406
undefined symbols.

00:47:12.406 --> 00:47:16.476
So if your .o file refers to a

00:47:16.476 --> 00:47:18.166
function in another .o file,

00:47:18.166 --> 00:47:20.586
that .o file's undefined.

00:47:20.626 --> 00:47:22.276
And the linker will go and find

00:47:22.276 --> 00:47:23.936
those undefined symbols and link

00:47:24.426 --> 00:47:26.146
them up.

00:47:26.406 --> 00:47:28.746
So I said that object files are

00:47:28.746 --> 00:47:30.236
the output of your compiler

00:47:30.236 --> 00:47:30.686
actions.

00:47:30.686 --> 00:47:31.726
So what are libraries?

00:47:32.576 --> 00:47:34.496
Libraries are files that define

00:47:34.496 --> 00:47:36.026
symbols that are not part of the

00:47:36.026 --> 00:47:37.426
target you are building.

00:47:38.516 --> 00:47:40.896
So we have dynamic libraries,

00:47:41.726 --> 00:47:44.316
and those are Mach-O files that

00:47:44.316 --> 00:47:46.376
expose code and data fragments

00:47:46.696 --> 00:47:48.526
for executables to use.

00:47:49.546 --> 00:47:52.336
Those are distributed as part of

00:47:52.336 --> 00:47:52.676
the system.

00:47:52.676 --> 00:47:53.636
That's what our frameworks are.

00:47:53.636 --> 00:47:54.916
And a number of you also use

00:47:54.916 --> 00:47:55.956
your own frameworks.

00:47:55.956 --> 00:48:00.256
There are also TBD files, or

00:48:00.346 --> 00:48:02.156
text-based dylib stubs.

00:48:02.156 --> 00:48:03.286
So what are those?

00:48:04.036 --> 00:48:08.286
Well, when we made the SDKs for

00:48:08.286 --> 00:48:10.256
iOS and macOS, we had all these

00:48:10.296 --> 00:48:11.336
dylibs with all these great

00:48:11.336 --> 00:48:13.146
functions like MapKit and WebKit

00:48:13.146 --> 00:48:14.296
that you may want to use.

00:48:14.816 --> 00:48:15.966
But we don't want to ship the

00:48:15.966 --> 00:48:17.326
entire copy of those with the

00:48:17.326 --> 00:48:18.856
SDK because it would be large.

00:48:18.856 --> 00:48:21.096
Ant the compiler and linker

00:48:21.096 --> 00:48:21.606
don't need.

00:48:21.606 --> 00:48:22.826
It's only needed to run the

00:48:22.826 --> 00:48:23.236
program.

00:48:23.236 --> 00:48:24.106
So instead we create what's

00:48:24.106 --> 00:48:25.356
called a stub dylib where we

00:48:25.356 --> 00:48:27.156
delete the bodies of all of the

00:48:27.156 --> 00:48:27.966
symbols and we just have the

00:48:27.966 --> 00:48:28.716
names.

00:48:29.456 --> 00:48:31.176
And then once we did that, we've

00:48:31.176 --> 00:48:32.526
made a textual representation of

00:48:32.526 --> 00:48:33.576
them that are easier for us to

00:48:33.576 --> 00:48:33.866
use.

00:48:33.866 --> 00:48:35.536
Currently, they are only used

00:48:35.766 --> 00:48:38.056
for distributing the SDKs to

00:48:38.056 --> 00:48:38.876
reduce size.

00:48:40.246 --> 00:48:41.566
So you may see them in your

00:48:41.566 --> 00:48:42.596
project, but you don't have to

00:48:42.596 --> 00:48:43.246
worry about them.

00:48:43.246 --> 00:48:45.016
And they only contain symbols.

00:48:46.226 --> 00:48:47.166
Finally, we have static

00:48:47.166 --> 00:48:48.106
archives.

00:48:48.526 --> 00:48:53.086
So static archives are just

00:48:53.086 --> 00:48:54.626
collections of .o files that

00:48:54.626 --> 00:48:56.746
have been built with the AR tool

00:48:56.746 --> 00:48:59.226
or in some cases the lib the lib

00:48:59.226 --> 00:49:00.156
tool which is a wrapper for

00:49:00.156 --> 00:49:00.396
that.

00:49:00.396 --> 00:49:02.206
And according to the AR

00:49:02.206 --> 00:49:04.556
[inaudible] page, the AR utility

00:49:04.556 --> 00:49:06.366
creates and maintains groups of

00:49:06.366 --> 00:49:08.246
files combined into an archive.

00:49:09.396 --> 00:49:10.956
Now that may sound a lot like a

00:49:10.956 --> 00:49:13.096
TAR file or a ZIP file, and

00:49:13.096 --> 00:49:14.156
that's exactly what it is.

00:49:14.156 --> 00:49:16.256
In fact, the .a format was the

00:49:16.256 --> 00:49:17.666
original archive format used by

00:49:17.776 --> 00:49:19.496
UNIX before more powerful tools

00:49:19.496 --> 00:49:20.156
came around.

00:49:20.926 --> 00:49:23.726
But the compilers of the time

00:49:23.726 --> 00:49:24.476
and the linkers of the time

00:49:24.476 --> 00:49:25.536
natively understood them, and

00:49:25.536 --> 00:49:26.536
they've just kept using them.

00:49:27.006 --> 00:49:28.456
So it really is just an archive

00:49:28.456 --> 00:49:28.806
file.

00:49:32.046 --> 00:49:33.386
One thing worth noting is they

00:49:33.386 --> 00:49:35.506
also prenate dynamic linking so

00:49:35.506 --> 00:49:36.826
back in those days, all of the

00:49:36.826 --> 00:49:38.196
code would be consid-- would be

00:49:38.196 --> 00:49:39.236
distributed as archives.

00:49:39.846 --> 00:49:41.776
Because of that, you might not

00:49:41.776 --> 00:49:43.896
want to include all of the C

00:49:43.896 --> 00:49:45.046
library if you're using one

00:49:45.046 --> 00:49:45.676
function.

00:49:46.096 --> 00:49:48.976
So the behavior is if there's a

00:49:49.096 --> 00:49:50.936
symbol in a .o file, we would

00:49:50.936 --> 00:49:52.326
pull that whole .o file out of

00:49:52.326 --> 00:49:52.846
the archive.

00:49:52.846 --> 00:49:54.616
But the other .o files would not

00:49:54.616 --> 00:49:55.246
be brought in.

00:49:55.696 --> 00:49:57.696
If you're referencing symbols

00:49:57.696 --> 00:49:58.756
between them, everything you

00:49:58.756 --> 00:49:59.946
need will be brought in.

00:49:59.946 --> 00:50:00.996
If you're using some sort of

00:50:00.996 --> 00:50:02.376
non-symbol behavior like a

00:50:02.376 --> 00:50:04.486
static initializer, or you're

00:50:04.486 --> 00:50:05.616
re-exporting them as part of

00:50:05.616 --> 00:50:06.916
your own dylib, you may need to

00:50:06.916 --> 00:50:08.286
explicitly use something like

00:50:09.096 --> 00:50:11.276
force load or all load to the

00:50:11.416 --> 00:50:12.446
linker to tell it bring in

00:50:12.446 --> 00:50:13.266
everything.

00:50:13.266 --> 00:50:14.256
Or these files, even though

00:50:14.256 --> 00:50:15.106
there's no linkage.

00:50:15.666 --> 00:50:19.786
So let's go through an example

00:50:19.786 --> 00:50:20.776
to try to tie this altogether.

00:50:23.236 --> 00:50:25.686
So up on stage we have an

00:50:25.686 --> 00:50:28.136
example of a playSound function

00:50:28.136 --> 00:50:29.186
because what fun would be

00:50:29.186 --> 00:50:29.996
looking at pets without

00:50:29.996 --> 00:50:32.076
listening to them?

00:50:32.296 --> 00:50:35.896
And you know it calls playSound.

00:50:35.896 --> 00:50:36.906
You know, there's a function on

00:50:36.906 --> 00:50:37.956
cat that calls playSound.

00:50:37.956 --> 00:50:38.926
That seems pretty simple.

00:50:38.926 --> 00:50:40.576
So let's look at the assembly

00:50:40.576 --> 00:50:41.176
that generates.

00:50:41.176 --> 00:50:45.476
So here's cat.o that comes out

00:50:45.476 --> 00:50:46.966
of it.

00:50:46.966 --> 00:50:49.766
Now if we look, we can see we

00:50:49.766 --> 00:50:53.116
have the string purr.aac which

00:50:53.116 --> 00:50:54.846
would be our AAC sound file.

00:50:54.916 --> 00:50:57.406
And that gets copied into cat.o.

00:50:57.406 --> 00:50:58.856
You'll note that the name purr

00:50:58.856 --> 00:51:00.196
file does not appear in there

00:51:00.196 --> 00:51:00.756
anywhere.

00:51:01.176 --> 00:51:02.816
The reason is, that's a static.

00:51:02.816 --> 00:51:03.836
And those of you who are

00:51:03.836 --> 00:51:04.836
familiar with C, that means it's

00:51:04.836 --> 00:51:06.166
a nonexported name.

00:51:06.166 --> 00:51:07.386
Nobody else can refer to it.

00:51:07.386 --> 00:51:08.806
Since nobody else can refer to

00:51:08.806 --> 00:51:10.016
it, we don't need it.

00:51:10.016 --> 00:51:10.856
It's not included.

00:51:14.326 --> 00:51:17.286
And then we see Cat purr becomes

00:51:17.286 --> 00:51:19.536
an actual symbol: dash, open

00:51:19.536 --> 00:51:20.976
bracket, Cat purr, close

00:51:20.976 --> 00:51:22.746
bracket.

00:51:23.596 --> 00:51:24.686
Pretty much what you'd expect.

00:51:24.686 --> 00:51:27.946
And then we see we actually have

00:51:27.946 --> 00:51:29.446
to get this variable we're going

00:51:29.446 --> 00:51:30.746
to pass into playSound.

00:51:30.746 --> 00:51:32.196
And you'll note there are two

00:51:32.196 --> 00:51:33.556
instructions referring to that.

00:51:33.556 --> 00:51:36.476
And that's because we don't know

00:51:36.476 --> 00:51:38.206
where this string is going to

00:51:38.206 --> 00:51:39.406
end up in the final executable.

00:51:39.406 --> 00:51:40.866
We don't have a concrete address

00:51:40.866 --> 00:51:41.386
for it.

00:51:41.616 --> 00:51:43.646
But we know that on RM64 which

00:51:43.646 --> 00:51:45.046
is what this assembly is, it

00:51:45.586 --> 00:51:46.386
could take at most two

00:51:46.386 --> 00:51:46.936
instructions.

00:51:46.936 --> 00:51:48.116
So the compiler leaves us with

00:51:48.116 --> 00:51:48.866
two instructions.

00:51:49.126 --> 00:51:50.426
And it leaves the symbolic

00:51:50.426 --> 00:51:52.636
offset, the symbolic values page

00:51:52.636 --> 00:51:53.986
and page off that the linker

00:51:53.986 --> 00:51:55.176
will come in and fix up later.

00:51:56.206 --> 00:51:59.406
Finally, now that we've loaded

00:51:59.406 --> 00:52:03.096
that string into x0, we can call

00:52:03.096 --> 00:52:04.886
playSound except for we're not

00:52:04.886 --> 00:52:05.836
calling playSound.

00:52:05.836 --> 00:52:07.466
We're calling underbar underbar

00:52:07.466 --> 00:52:11.606
z9playSound PKc.

00:52:11.606 --> 00:52:12.446
Now what is that?

00:52:12.746 --> 00:52:14.456
That's a mangled symbol because

00:52:14.456 --> 00:52:16.276
if you note, it says cat.mm.

00:52:16.276 --> 00:52:17.866
This is Objective-C++.

00:52:18.466 --> 00:52:20.956
And playSound is actually a C++

00:52:20.956 --> 00:52:21.336
function.

00:52:22.146 --> 00:52:23.806
So if you're not familiar with

00:52:23.806 --> 00:52:27.116
those, you can go to terminal

00:52:27.116 --> 00:52:28.606
and you can actually use tools.

00:52:28.606 --> 00:52:31.626
So if you run Swift-demangle and

00:52:31.626 --> 00:52:32.616
pass in a symbol, it will

00:52:32.616 --> 00:52:33.386
attempt to demangle it.

00:52:33.386 --> 00:52:34.606
It didn't work.

00:52:34.606 --> 00:52:35.686
It's not a Swift symbol.

00:52:35.686 --> 00:52:38.456
But C++ filts, which is the C++

00:52:38.456 --> 00:52:40.126
demangler shows us that this is

00:52:40.126 --> 00:52:42.626
in fact a symbol for playSound.

00:52:42.626 --> 00:52:44.126
But not only is it playSound, we

00:52:44.126 --> 00:52:45.136
know it takes one argument.

00:52:45.136 --> 00:52:46.736
And that one argument is a const

00:52:46.736 --> 00:52:49.456
char star because C++ encoded

00:52:49.456 --> 00:52:51.556
that extra data into the mangled

00:52:51.556 --> 00:52:51.906
symbol.

00:52:52.536 --> 00:52:55.716
Okay, so now we have a .o. In

00:52:55.716 --> 00:52:56.836
fact, we're building a project,

00:52:56.836 --> 00:52:58.956
we'll have a lot of them.

00:52:58.996 --> 00:53:00.186
So what are we going to do with

00:53:00.186 --> 00:53:00.516
that?

00:53:00.516 --> 00:53:03.496
Well, first off, the build

00:53:03.496 --> 00:53:05.166
system is going to pass all of

00:53:05.166 --> 00:53:06.366
the .o's in as inputs to the

00:53:06.366 --> 00:53:06.796
linker.

00:53:06.796 --> 00:53:07.766
And the linker's going to start

00:53:07.766 --> 00:53:08.986
by creating a file to put them

00:53:08.986 --> 00:53:09.196
in.

00:53:09.196 --> 00:53:10.656
In this case we're building

00:53:10.656 --> 00:53:11.886
PetKit which is an embedded

00:53:11.886 --> 00:53:13.066
framework inside of PetWall.

00:53:13.066 --> 00:53:15.906
And so we'll just start by

00:53:15.906 --> 00:53:16.626
copying.

00:53:16.626 --> 00:53:17.846
We'll create what's called a

00:53:17.896 --> 00:53:18.506
text segment.

00:53:19.366 --> 00:53:20.696
Which is where we keep all of

00:53:20.696 --> 00:53:21.836
the code for an application.

00:53:21.896 --> 00:53:24.226
And we'll take the cat.o and

00:53:24.226 --> 00:53:25.026
we'll copy it in.

00:53:25.026 --> 00:53:25.846
But we're going to split it into

00:53:25.846 --> 00:53:26.596
two sections.

00:53:26.966 --> 00:53:28.366
One for that string, and one for

00:53:28.366 --> 00:53:29.316
the executable code.

00:53:29.316 --> 00:53:32.176
But we now know the absolute

00:53:32.496 --> 00:53:33.816
addresses of these things so the

00:53:33.816 --> 00:53:37.406
linker can go and rewrite cat.o

00:53:37.616 --> 00:53:40.196
to load from a specific offset.

00:53:40.796 --> 00:53:42.186
You'll notice that the second

00:53:42.186 --> 00:53:43.796
instruction just went away.

00:53:43.796 --> 00:53:45.456
We replaced it with what, with a

00:53:45.456 --> 00:53:46.496
null instruction that does

00:53:46.496 --> 00:53:46.906
nothing.

00:53:47.866 --> 00:53:49.916
But we cannot remove the

00:53:49.916 --> 00:53:51.756
instruction because we can't

00:53:51.756 --> 00:53:52.816
create or remove code.

00:53:52.816 --> 00:53:55.116
It would mess up all of the

00:53:55.116 --> 00:53:56.226
sizing that we've already done.

00:53:56.586 --> 00:53:58.706
So instead it just is removed.

00:53:59.336 --> 00:54:01.556
It, it's just replaced with a no

00:54:01.556 --> 00:54:02.046
operation.

00:54:02.666 --> 00:54:03.636
Finally we branch.

00:54:04.916 --> 00:54:10.276
Okay, but we branch and what are

00:54:10.276 --> 00:54:11.366
we going to do?

00:54:11.366 --> 00:54:12.456
Because we have this undefined

00:54:12.456 --> 00:54:12.816
symbol?

00:54:12.876 --> 00:54:14.146
Well, we're going to go and keep

00:54:14.146 --> 00:54:15.696
looking through, and all of our

00:54:15.696 --> 00:54:16.616
.o's have been included at this

00:54:16.666 --> 00:54:17.326
point.

00:54:18.416 --> 00:54:19.186
So we'll start looking at the

00:54:19.186 --> 00:54:20.496
static archives [inaudible] and

00:54:20.596 --> 00:54:22.376
PetSupport.a is there.

00:54:22.376 --> 00:54:24.436
And inside of PetSupport.a, we

00:54:24.436 --> 00:54:27.286
have a couple of files including

00:54:27.286 --> 00:54:30.666
PetSounds.o. And if we look, we

00:54:30.666 --> 00:54:31.966
see that matching file-- that

00:54:31.966 --> 00:54:33.376
matching symbol for playSound.

00:54:34.806 --> 00:54:38.216
So we pull it in.

00:54:38.446 --> 00:54:39.796
We'll note that we do not pull

00:54:39.796 --> 00:54:42.496
in PetCare.o. Because that .o

00:54:42.496 --> 00:54:44.026
file did not have any symbols

00:54:44.026 --> 00:54:45.236
that were referred to by any of

00:54:45.236 --> 00:54:46.326
the other portions of the

00:54:46.326 --> 00:54:46.966
application.

00:54:47.536 --> 00:54:49.786
Okay, so we pulled that in, but

00:54:49.786 --> 00:54:52.536
now that needs, open which we

00:54:52.536 --> 00:54:53.316
didn't define.

00:54:53.316 --> 00:54:56.256
You'll see in the, in the, the

00:54:56.256 --> 00:54:57.096
conversion we copied in.

00:54:57.096 --> 00:54:57.916
We actually replaced it with

00:54:57.916 --> 00:54:59.626
something called open$stub.

00:54:59.846 --> 00:55:01.306
Now why did we do that?

00:55:01.826 --> 00:55:03.326
Well we kept looking, and we

00:55:03.326 --> 00:55:04.416
found a copy of open.

00:55:04.416 --> 00:55:07.896
And that copy of open is in the

00:55:07.896 --> 00:55:09.876
lib system TBD file.

00:55:11.256 --> 00:55:13.306
And so we said I know this is

00:55:13.306 --> 00:55:14.416
part of the system library.

00:55:14.416 --> 00:55:15.456
I'm not going to copy this into

00:55:15.456 --> 00:55:16.146
my application.

00:55:16.146 --> 00:55:18.336
But I need to put enough

00:55:18.336 --> 00:55:19.516
information in the information

00:55:19.516 --> 00:55:20.836
to make it so that it can call

00:55:20.836 --> 00:55:21.166
this.

00:55:21.506 --> 00:55:23.556
So we create a fake function

00:55:23.556 --> 00:55:25.626
that's just a template where we

00:55:25.626 --> 00:55:26.656
replaced a function with

00:55:26.656 --> 00:55:27.606
whatever we're pulling out of

00:55:27.606 --> 00:55:28.726
lib system which is open in this

00:55:28.726 --> 00:55:29.046
case.

00:55:29.216 --> 00:55:30.426
And if you look in that

00:55:30.426 --> 00:55:32.876
function, it actually loads from

00:55:32.876 --> 00:55:35.036
a pointer, open$ pointer.

00:55:36.186 --> 00:55:37.416
And jumps to it.

00:55:37.416 --> 00:55:38.686
So we just need a function

00:55:38.716 --> 00:55:39.996
pointer, just like any normal C

00:55:39.996 --> 00:55:40.636
function pointer.

00:55:41.256 --> 00:55:44.796
And we'll create that down in

00:55:44.796 --> 00:55:46.186
the data segment which is where

00:55:46.186 --> 00:55:47.636
global variables would be if you

00:55:47.636 --> 00:55:48.396
had any globals.

00:55:49.406 --> 00:55:50.966
But it's just set to zero.

00:55:51.426 --> 00:55:53.226
So if we dereference null and

00:55:53.226 --> 00:55:54.436
jump to it we're going to crash.

00:55:56.036 --> 00:55:57.536
So we then add what's called a

00:55:57.536 --> 00:55:58.606
link edit segment.

00:55:58.606 --> 00:56:01.096
And the link edit is metadata

00:56:01.096 --> 00:56:03.946
that the linker tool uses to

00:56:03.946 --> 00:56:05.966
leave information for the

00:56:05.966 --> 00:56:06.996
operating system and what's

00:56:06.996 --> 00:56:08.816
called the dynamic linker to fix

00:56:08.816 --> 00:56:09.836
this up at runtime.

00:56:09.836 --> 00:56:12.196
And for more information on that

00:56:12.196 --> 00:56:13.266
you should look at the

00:56:13.266 --> 00:56:14.546
Optimizing App Startup Time

00:56:14.546 --> 00:56:19.126
session from 2016.

00:56:19.196 --> 00:56:22.346
So I just want to go back over

00:56:22.346 --> 00:56:23.456
what we went through today.

00:56:23.456 --> 00:56:25.056
So Jake talked about the build

00:56:25.056 --> 00:56:26.376
system and how you can use

00:56:26.376 --> 00:56:29.076
dependencies to optimize your

00:56:29.076 --> 00:56:32.856
built process for multi-core.

00:56:33.086 --> 00:56:35.666
Jurgen walked through Clang and

00:56:35.666 --> 00:56:36.936
how it finds headers for you.

00:56:36.936 --> 00:56:37.986
And what you can do to optimize

00:56:37.986 --> 00:56:39.196
your build-through modules.

00:56:40.636 --> 00:56:42.926
Devin walked through how Swift

00:56:42.926 --> 00:56:45.846
expand modules and all of the

00:56:45.846 --> 00:56:47.146
things that we've implemented

00:56:47.146 --> 00:56:47.426
this year like [inaudible]

00:56:47.426 --> 00:56:48.756
processing to speed up your

00:56:48.756 --> 00:56:49.176
builds.

00:56:49.176 --> 00:56:51.006
And then finally the linker

00:56:51.006 --> 00:56:52.206
takes the outputs of both

00:56:52.206 --> 00:56:53.866
compilers and builds them into

00:56:53.866 --> 00:56:54.916
your application.

00:56:54.916 --> 00:56:56.586
At which point Xcode will go

00:56:56.586 --> 00:56:57.646
and, and code [inaudible] and

00:56:57.646 --> 00:56:59.416
package it up with other parts

00:57:00.376 --> 00:57:02.116
of your application for

00:57:02.116 --> 00:57:02.726
distribution.

00:57:04.026 --> 00:57:08.026
So most of this is open source,

00:57:08.026 --> 00:57:08.756
available if you're really

00:57:08.756 --> 00:57:09.306
curious.

00:57:09.306 --> 00:57:10.926
You can look at Swift or Clang

00:57:10.926 --> 00:57:13.646
or the llbuild execution engine

00:57:14.916 --> 00:57:15.826
at these URLs.

00:57:16.626 --> 00:57:18.046
And I just want to thank you all

00:57:18.046 --> 00:57:18.926
for coming.

00:57:19.266 --> 00:57:21.416
And I hope you've had a great

00:57:21.416 --> 00:57:21.576
WWDC.

00:57:21.576 --> 00:57:23.346
And we'll be in the labs.

00:57:23.346 --> 00:57:23.836
Thank you.

00:57:24.016 --> 00:57:26.000
[ Applause ]
WEBVTT

00:00:07.516 --> 00:00:15.500
[ Music ]

00:00:17.516 --> 00:00:23.056
[ Applause ]

00:00:23.556 --> 00:00:24.156
>> Hi, everybody.

00:00:24.876 --> 00:00:26.136
It's great to see you all here

00:00:26.136 --> 00:00:26.446
today.

00:00:27.306 --> 00:00:29.676
I'm Dave, and the next 40

00:00:29.676 --> 00:00:32.436
minutes are about understanding

00:00:32.485 --> 00:00:33.996
and honoring what makes our

00:00:34.036 --> 00:00:35.716
programs actually work.

00:00:36.766 --> 00:00:38.286
There will be practical advice,

00:00:38.636 --> 00:00:40.986
but this is not a talk about

00:00:41.056 --> 00:00:43.116
tips and techniques or any

00:00:43.116 --> 00:00:44.876
specific algorithms even, though

00:00:44.876 --> 00:00:45.816
we will look at a few.

00:00:47.026 --> 00:00:49.156
It's about revealing something

00:00:49.296 --> 00:00:50.956
fundamental, the potential of

00:00:51.036 --> 00:00:53.076
which is already present in your

00:00:53.906 --> 00:00:54.006
code.

00:00:54.936 --> 00:00:57.216
I hope that for at least a few

00:00:57.216 --> 00:00:58.796
of you it marks the beginning of

00:00:58.796 --> 00:01:00.056
a new relationship to the

00:01:00.056 --> 00:01:01.056
practice of programming.

00:01:02.236 --> 00:01:03.446
Speaking personally, when I

00:01:03.446 --> 00:01:05.116
discovered this approach, it

00:01:05.116 --> 00:01:06.446
changed the course of my life

00:01:06.756 --> 00:01:07.486
and my career.

00:01:08.446 --> 00:01:09.926
It's the reason I care so much

00:01:09.926 --> 00:01:11.966
about software libraries, but

00:01:11.966 --> 00:01:13.786
it's also the source of the

00:01:13.786 --> 00:01:15.866
liability, maintainability, and

00:01:15.866 --> 00:01:17.976
performance in every piece of

00:01:17.976 --> 00:01:19.016
concrete code I've written

00:01:19.016 --> 00:01:19.436
since.

00:01:20.836 --> 00:01:22.876
But before we get into that, let

00:01:22.876 --> 00:01:24.226
me introduce you to a friend of

00:01:24.226 --> 00:01:24.396
mine.

00:01:26.776 --> 00:01:27.506
This is Crusty.

00:01:28.516 --> 00:01:31.616
[ Applause ]

00:01:32.116 --> 00:01:34.006
Crusty is old school.

00:01:34.896 --> 00:01:37.026
He doesn't trust debuggers or or

00:01:37.026 --> 00:01:38.786
mess around with integrated

00:01:38.786 --> 00:01:40.016
development environments.

00:01:40.806 --> 00:01:43.246
No, he favors an 80 x 24

00:01:43.246 --> 00:01:45.436
terminal window in plain text,

00:01:45.506 --> 00:01:46.246
thank you very much.

00:01:47.516 --> 00:01:49.566
Now, Crusty takes a dim view of

00:01:49.566 --> 00:01:51.916
the latest programming fads, so

00:01:51.916 --> 00:01:53.476
it can sometimes be an effort to

00:01:53.476 --> 00:01:55.166
drag him into the 21st century.

00:01:56.126 --> 00:01:57.636
He just thinks different.

00:01:58.656 --> 00:02:00.866
But if you listen carefully, you

00:02:00.866 --> 00:02:03.336
can learn a thing or two.

00:02:03.576 --> 00:02:05.356
Now, sometimes his cryptic

00:02:05.356 --> 00:02:07.666
pronouncements like "programming

00:02:07.666 --> 00:02:10.156
reveals the real; border on the

00:02:10.156 --> 00:02:10.675
mystical."

00:02:11.416 --> 00:02:13.576
And to understand him, I found

00:02:13.576 --> 00:02:15.096
it helpful to actually write

00:02:15.096 --> 00:02:16.286
some code.

00:02:17.526 --> 00:02:18.796
So, lately, I've been working on

00:02:18.796 --> 00:02:20.586
a little program called Shapes.

00:02:21.656 --> 00:02:22.906
I'm hoping to make it into a

00:02:22.906 --> 00:02:24.216
full-featured vector drawing

00:02:24.216 --> 00:02:26.876
program, but so far it lets you

00:02:26.876 --> 00:02:28.336
arrange shapes on an infinite

00:02:28.336 --> 00:02:28.836
canvas.

00:02:30.416 --> 00:02:31.376
Now, I want to tell you the

00:02:31.376 --> 00:02:33.226
story of the delete selection

00:02:33.226 --> 00:02:35.526
command because I learned so

00:02:35.526 --> 00:02:37.826
much from implementing this one

00:02:37.826 --> 00:02:38.266
feature.

00:02:39.596 --> 00:02:41.216
I think we've probably all gone

00:02:41.216 --> 00:02:43.426
through part of this progression

00:02:43.426 --> 00:02:45.436
as programmers as we learn how

00:02:45.436 --> 00:02:46.856
to remove things from an array.

00:02:47.816 --> 00:02:49.106
Everybody starts out doing

00:02:49.106 --> 00:02:51.000
something like this.

00:02:53.596 --> 00:02:55.006
That's the delete selection

00:02:56.836 --> 00:02:57.026
command.

00:02:58.656 --> 00:03:02.316
We loop from 0 to count, and

00:03:02.316 --> 00:03:03.326
when we find something to

00:03:03.326 --> 00:03:05.126
delete, we [inaudible] remove

00:03:05.126 --> 00:03:07.546
that, and then we continue with

00:03:07.546 --> 00:03:11.266
our loop until, ouch, we walk

00:03:11.266 --> 00:03:11.846
off the end.

00:03:13.366 --> 00:03:14.906
The array got shorter, but we

00:03:14.906 --> 00:03:16.256
picked the number of iterations

00:03:16.256 --> 00:03:17.166
when the loop started.

00:03:17.876 --> 00:03:19.196
Fortunately, you can't miss this

00:03:19.246 --> 00:03:20.796
bug if you Swift and test your

00:03:20.826 --> 00:03:23.436
code because it'll trap.

00:03:23.946 --> 00:03:25.226
But if you had to learn this

00:03:25.266 --> 00:03:26.996
lesson as a C-programmer, like I

00:03:26.996 --> 00:03:28.966
did, you might not be so lucky.

00:03:29.926 --> 00:03:30.256
Okay.

00:03:30.626 --> 00:03:32.796
So, we can fix it by replacing

00:03:32.796 --> 00:03:34.096
the for loop with a somewhat

00:03:34.096 --> 00:03:36.346
uglier while loop, which lets us

00:03:36.346 --> 00:03:37.516
examine the count at each

00:03:37.516 --> 00:03:38.096
iteration.

00:03:38.646 --> 00:03:42.156
But there's a subtle bug in this

00:03:42.156 --> 00:03:42.736
one too.

00:03:43.956 --> 00:03:46.056
If two consecutive elements are

00:03:46.056 --> 00:03:48.706
selected, it'll remove the first

00:03:48.706 --> 00:03:51.916
one and then immediately hop

00:03:51.916 --> 00:03:54.256
over the next one.

00:03:54.466 --> 00:03:56.956
Now, this bug is a little more

00:03:56.956 --> 00:03:58.496
insidious because it hides from

00:03:58.496 --> 00:04:00.286
you unless your tests happen to

00:04:00.286 --> 00:04:02.716
exercise it.

00:04:02.946 --> 00:04:04.416
But if we're lucky enough to

00:04:04.416 --> 00:04:06.496
notice it, we press ahead and we

00:04:06.496 --> 00:04:08.826
fix the implementation again by

00:04:08.826 --> 00:04:10.026
guarding the increment in an

00:04:10.026 --> 00:04:10.586
else block.

00:04:11.226 --> 00:04:13.596
So, are we done now?

00:04:13.596 --> 00:04:16.476
Are we sure this one is correct?

00:04:17.706 --> 00:04:19.906
I think I can prove to myself

00:04:19.995 --> 00:04:20.755
that it works.

00:04:21.875 --> 00:04:24.106
Anyway, having gone through this

00:04:24.106 --> 00:04:25.356
ordeal, what do we do?

00:04:25.746 --> 00:04:27.336
Well, of course, we lock this

00:04:27.336 --> 00:04:28.696
nine-line pattern into our

00:04:28.696 --> 00:04:30.506
brains so we can trot it out

00:04:30.506 --> 00:04:32.056
whenever we have to delete

00:04:32.056 --> 00:04:32.456
something.

00:04:33.026 --> 00:04:35.666
Now, I'm sure many of you have

00:04:35.666 --> 00:04:36.676
been holding yourselves back

00:04:36.676 --> 00:04:38.566
from screaming at me because

00:04:38.656 --> 00:04:40.506
that there's a much more elegant

00:04:40.506 --> 00:04:41.906
way to do it.

00:04:41.906 --> 00:04:43.206
I still remember the day I

00:04:43.206 --> 00:04:44.686
discovered this trick for myself

00:04:45.106 --> 00:04:46.666
because once you find it, you

00:04:46.666 --> 00:04:48.126
never do this nine-line dance

00:04:48.126 --> 00:04:48.456
again.

00:04:49.406 --> 00:04:51.496
The iteration limit and the

00:04:51.556 --> 00:04:52.786
index of the next item to

00:04:52.786 --> 00:04:54.956
examine kept shifting under our

00:04:54.956 --> 00:04:56.866
feet because remove(at: i)

00:04:57.746 --> 00:04:59.426
changes parts of the array after

00:04:59.426 --> 00:04:59.696
i.

00:05:00.766 --> 00:05:06.266
But if you go backwards, you

00:05:06.266 --> 00:05:07.526
only iterate over the parts of

00:05:07.526 --> 00:05:08.376
the array that you haven't

00:05:08.376 --> 00:05:08.896
changed yet.

00:05:10.056 --> 00:05:10.776
Slick, right?

00:05:11.456 --> 00:05:12.556
And this is the pattern I've

00:05:12.606 --> 00:05:14.916
used ever since because it's

00:05:14.946 --> 00:05:19.476
clean, and it never fails, until

00:05:20.086 --> 00:05:21.736
a few months ago.

00:05:21.736 --> 00:05:24.056
One morning, I had just finished

00:05:24.056 --> 00:05:26.216
my avocado toast, and I was idly

00:05:26.306 --> 00:05:28.376
fooling with my app when I tried

00:05:28.376 --> 00:05:29.986
deleting about half the shapes

00:05:29.986 --> 00:05:31.216
from a really complicated

00:05:31.216 --> 00:05:31.686
canvas.

00:05:33.016 --> 00:05:35.166
My iPad, it froze up for like

00:05:35.526 --> 00:05:36.206
three seconds.

00:05:36.886 --> 00:05:40.586
So, I took a sip of my half caf

00:05:40.626 --> 00:05:42.746
triple shot latte in its bamboo

00:05:43.156 --> 00:05:44.716
thermal commuter cup, and I

00:05:44.716 --> 00:05:45.936
considered my options.

00:05:47.656 --> 00:05:48.526
This was disturbing.

00:05:49.136 --> 00:05:50.006
I mean, it's a pretty

00:05:50.006 --> 00:05:51.716
straightforward operation, and

00:05:51.716 --> 00:05:53.686
my code was so clean, how could

00:05:53.686 --> 00:05:54.286
it be wrong?

00:05:56.176 --> 00:05:58.256
Profiling showed me that the hot

00:05:58.256 --> 00:06:01.156
spot was right here, but beyond

00:06:01.156 --> 00:06:02.056
that, I was stumped.

00:06:02.706 --> 00:06:05.636
So, just about then, Crusty

00:06:05.636 --> 00:06:07.076
walked up behind me carrying a

00:06:07.076 --> 00:06:09.416
can of off-brand coffee grounds

00:06:09.416 --> 00:06:10.796
from the local supermarket for

00:06:10.796 --> 00:06:11.546
his daily brew.

00:06:12.936 --> 00:06:15.876
"Stuck?" he said.

00:06:16.086 --> 00:06:18.016
"Yeah," I sighed, and I

00:06:18.016 --> 00:06:19.216
explained the situation.

00:06:19.706 --> 00:06:24.556
"Well, did you even look at the

00:06:24.556 --> 00:06:25.796
documentation for that?"

00:06:27.826 --> 00:06:29.916
Well, I hadn't, so I popped up

00:06:29.916 --> 00:06:31.516
the Quick Help for Remove At,

00:06:31.806 --> 00:06:33.526
and Crusty leaned in.

00:06:34.316 --> 00:06:35.856
"There's your problem, right

00:06:35.856 --> 00:06:38.986
there," he said, leaving a

00:06:38.986 --> 00:06:40.506
smudge on my gorgeous retina

00:06:40.506 --> 00:06:41.036
display.

00:06:42.906 --> 00:06:45.506
Now, I carefully wiped off the

00:06:45.546 --> 00:06:47.216
fingerprint with a handcrafted

00:06:47.216 --> 00:06:50.596
Italian microfiber cloth, and

00:06:50.596 --> 00:06:53.386
Crusty said, "What's that tell

00:06:53.996 --> 00:06:54.856
you, son?"

00:06:55.096 --> 00:06:57.516
"Well," I said, "it means that

00:06:57.596 --> 00:06:59.056
removing an element takes a

00:06:59.056 --> 00:07:01.216
number of steps proportional to

00:07:01.216 --> 00:07:02.476
the length of the array."

00:07:02.476 --> 00:07:04.456
And it kind of makes sense,

00:07:04.456 --> 00:07:06.686
since the array has to slide all

00:07:06.686 --> 00:07:08.316
of the following elements into

00:07:08.316 --> 00:07:09.186
their new positions.

00:07:10.996 --> 00:07:12.466
"So, what's that mean about your

00:07:12.466 --> 00:07:13.806
Delete Selection command?"

00:07:14.596 --> 00:07:14.996
he asked.

00:07:16.166 --> 00:07:17.646
"Uh," I said.

00:07:18.186 --> 00:07:21.606
That's when he pulled out a pack

00:07:21.606 --> 00:07:22.976
of mentholated lozenges and

00:07:22.976 --> 00:07:24.086
lined them up on my desk.

00:07:24.756 --> 00:07:25.596
"Try it yourself."

00:07:27.246 --> 00:07:29.216
So, I went through the process

00:07:29.216 --> 00:07:30.226
as I tried to answer his

00:07:30.226 --> 00:07:30.656
question.

00:07:30.896 --> 00:07:32.096
"Well, since Delete Selection

00:07:32.096 --> 00:07:34.116
has to do order n steps, once

00:07:34.116 --> 00:07:35.486
for each selected element, and

00:07:35.486 --> 00:07:36.996
you can select up to n elements,

00:07:37.276 --> 00:07:38.396
the total number of steps is

00:07:38.396 --> 00:07:40.906
proportional to n squared."

00:07:42.276 --> 00:07:44.356
Crusty added, "That's quadratic,

00:07:44.356 --> 00:07:46.296
son, whether you do it the ugly

00:07:46.296 --> 00:07:48.186
forward way or the fancy pants

00:07:48.186 --> 00:07:50.346
backward way."

00:07:50.976 --> 00:07:54.106
I realized then that for my

00:07:54.106 --> 00:07:56.036
little 10 to 20-element test

00:07:56.036 --> 00:07:58.006
cases, we'd only been talking

00:07:58.006 --> 00:08:00.376
about a few hundred steps, and

00:08:00.376 --> 00:08:01.936
since the steps are pretty fast,

00:08:02.046 --> 00:08:02.876
it seemed great.

00:08:04.116 --> 00:08:05.396
But the problem is that it

00:08:05.396 --> 00:08:06.296
doesn't scale well.

00:08:06.796 --> 00:08:10.576
Fifty squared is 2,500 and 100

00:08:10.576 --> 00:08:11.986
squared is 10,000.

00:08:12.546 --> 00:08:15.326
So, if you do all your testing

00:08:15.326 --> 00:08:17.186
in this little region down here,

00:08:17.476 --> 00:08:18.766
you'll probably never see it,

00:08:19.336 --> 00:08:21.746
but scalability matters because

00:08:21.746 --> 00:08:23.336
people are using their phones

00:08:23.336 --> 00:08:25.626
and iPads to manage more and

00:08:25.626 --> 00:08:27.376
more data, and we keep shipping

00:08:27.376 --> 00:08:29.096
devices with more memory to help

00:08:29.096 --> 00:08:29.586
them do it.

00:08:30.606 --> 00:08:32.346
You care about this because

00:08:32.346 --> 00:08:34.476
scalability is predictability

00:08:34.476 --> 00:08:35.296
for your users.

00:08:35.826 --> 00:08:39.946
So, now, I understood the

00:08:39.946 --> 00:08:41.986
problem, but I still wasn't sure

00:08:41.986 --> 00:08:42.746
what to do about it.

00:08:43.326 --> 00:08:43.706
"Now what?"

00:08:43.706 --> 00:08:44.446
I asked Crusty.

00:08:45.526 --> 00:08:47.056
"You know, kid," he said,

00:08:47.496 --> 00:08:49.776
popping a lozenge, "there is an

00:08:49.776 --> 00:08:51.466
algorithm for that."

00:08:53.056 --> 00:08:56.236
I told him, "Listen, Crusty, I'm

00:08:56.236 --> 00:08:57.176
an app developer.

00:08:58.226 --> 00:09:00.176
You say you don't do object

00:09:00.176 --> 00:09:00.716
oriented.

00:09:00.716 --> 00:09:02.646
Well, I don't 'do' algorithms."

00:09:03.276 --> 00:09:04.406
You pay attention to your data

00:09:04.406 --> 00:09:06.066
structures in algorithms class

00:09:06.396 --> 00:09:08.036
because you know when it's time

00:09:08.036 --> 00:09:09.806
to get a job, your interviewer

00:09:09.806 --> 00:09:10.946
is going to ask you about them.

00:09:11.346 --> 00:09:12.776
But in the real programming

00:09:12.776 --> 00:09:14.766
world, what separates the elite

00:09:14.926 --> 00:09:16.946
from the newbies is the ability

00:09:16.946 --> 00:09:18.396
to wire together controllers,

00:09:18.396 --> 00:09:19.766
delegates, and responders to

00:09:19.766 --> 00:09:22.546
build a working system.

00:09:22.996 --> 00:09:24.906
"Bonkey," he said; I don't know

00:09:24.906 --> 00:09:27.276
why he calls me that, "What do

00:09:27.506 --> 00:09:28.656
computers do?"

00:09:30.096 --> 00:09:30.816
"They compute."

00:09:31.796 --> 00:09:33.086
"Now, where's the computation in

00:09:33.086 --> 00:09:34.286
all that?"

00:09:35.356 --> 00:09:37.966
"Well," I replied, "I guess I

00:09:37.966 --> 00:09:39.106
don't see anything that looks

00:09:39.106 --> 00:09:40.496
like an algorithm in my code."

00:09:41.046 --> 00:09:43.296
But Crusty wasn't having it.

00:09:43.806 --> 00:09:45.106
"Oh, your app is full of them,"

00:09:45.106 --> 00:09:46.646
he said, dropping an old dead

00:09:46.646 --> 00:09:47.956
tree dictionary on my desk,

00:09:48.526 --> 00:09:50.496
"Look it up."

00:09:51.266 --> 00:09:54.066
After I gathered my composure, I

00:09:54.066 --> 00:09:55.396
carefully slid the book to one

00:09:55.396 --> 00:09:57.226
side and typed Define Algorithm

00:09:57.226 --> 00:09:58.886
into Spotlight, which Crusty

00:09:58.886 --> 00:10:00.000
thought was a neat trick.

00:10:03.976 --> 00:10:04.976
Hmm.

00:10:05.046 --> 00:10:06.876
A process or set of rules to be

00:10:06.876 --> 00:10:08.656
followed in calculations or

00:10:08.656 --> 00:10:09.806
other problem solving

00:10:09.806 --> 00:10:10.416
operations.

00:10:11.756 --> 00:10:13.356
Well, come to think of it, that

00:10:13.806 --> 00:10:16.016
did sound like most code, but I

00:10:16.016 --> 00:10:16.906
still wasn't sure.

00:10:18.036 --> 00:10:19.446
"You ever do a long division?"

00:10:19.596 --> 00:10:20.236
asked Crusty.

00:10:20.646 --> 00:10:21.576
"That's an algorithm."

00:10:25.766 --> 00:10:27.606
I started to type into Spotlight

00:10:27.606 --> 00:10:29.266
again, but he snapped, "On

00:10:29.266 --> 00:10:29.646
paper."

00:10:30.306 --> 00:10:31.616
And not wanting to embarrass

00:10:31.616 --> 00:10:32.746
myself, I turned the subject

00:10:32.746 --> 00:10:33.476
back to my code.

00:10:35.316 --> 00:10:35.386
"Hmm."

00:10:36.256 --> 00:10:39.926
I asked, "So, what is this magic

00:10:39.926 --> 00:10:41.666
algorithm that will cure my

00:10:41.666 --> 00:10:42.856
performance problem?"

00:10:44.126 --> 00:10:45.496
"Well, if you'll just let me at

00:10:45.496 --> 00:10:46.976
your TTY there for a minute," he

00:10:46.976 --> 00:10:48.446
said, "How do you work this

00:10:48.446 --> 00:10:48.626
thing?

00:10:48.626 --> 00:10:49.816
Oh, it's a track pad.

00:10:49.816 --> 00:10:50.826
I'll try not to touch that.

00:10:51.226 --> 00:10:53.356
So, first, you do away with this

00:10:53.356 --> 00:10:54.330
foolishness.

00:10:57.046 --> 00:11:00.676
Now, shapes.removeallwhere the

00:11:00.676 --> 00:11:02.186
shape is selected.

00:11:03.146 --> 00:11:03.326
Hmm.

00:11:04.026 --> 00:11:05.236
Try that on for size."

00:11:06.216 --> 00:11:07.756
Now, Crusty headed off to wash

00:11:07.756 --> 00:11:08.856
out the pitcher of his coffee

00:11:08.856 --> 00:11:11.066
maker, leaving me to figure out

00:11:11.066 --> 00:11:12.816
what had just happened in my

00:11:13.666 --> 00:11:13.766
code.

00:11:14.736 --> 00:11:17.756
First, I checked, and I found

00:11:17.756 --> 00:11:18.936
that the performance problem was

00:11:18.996 --> 00:11:19.286
fixed.

00:11:19.856 --> 00:11:20.226
Nice.

00:11:21.536 --> 00:11:22.886
And I didn't want another earful

00:11:22.886 --> 00:11:24.226
from Crusty about looking at the

00:11:24.226 --> 00:11:26.626
documentation, so I popped up

00:11:26.626 --> 00:11:28.126
Quick Help for removeAll(where:

00:11:28.676 --> 00:11:32.856
and I saw that its complexity

00:11:32.856 --> 00:11:34.266
scales proportionally to the

00:11:34.266 --> 00:11:36.176
length of the collection just

00:11:36.176 --> 00:11:36.806
like removeAt.

00:11:37.796 --> 00:11:39.656
But since I didn't have to put

00:11:39.656 --> 00:11:41.576
it in a loop, that became the

00:11:41.576 --> 00:11:42.836
complexity of my whole

00:11:42.836 --> 00:11:43.376
operation.

00:11:44.576 --> 00:11:46.776
Now, I want to give you some

00:11:46.776 --> 00:11:48.026
intuition for the kind of

00:11:48.106 --> 00:11:50.106
difference this makes.

00:11:50.566 --> 00:11:52.476
What are n means that the time

00:11:52.476 --> 00:11:54.216
the algorithm runs scales

00:11:54.566 --> 00:11:56.166
linearly with the problem size.

00:11:56.696 --> 00:11:57.936
The graph is a straight line.

00:11:59.396 --> 00:12:00.826
Now, the orange line is the

00:12:00.826 --> 00:12:02.076
shape of order n squared.

00:12:03.356 --> 00:12:04.846
As you can see, a linear

00:12:04.846 --> 00:12:06.406
algorithm may do worse on a

00:12:06.406 --> 00:12:07.956
small problem, but it's

00:12:07.956 --> 00:12:09.596
eventually faster than a

00:12:09.596 --> 00:12:10.606
quadratic algorithm.

00:12:11.926 --> 00:12:13.716
The cool thing is though, it

00:12:13.716 --> 00:12:15.546
doesn't matter how expensive you

00:12:15.546 --> 00:12:16.856
make the steps of the linear

00:12:16.856 --> 00:12:19.226
algorithm, if you keep looking

00:12:19.226 --> 00:12:22.456
at larger problem sizes, you'll

00:12:22.566 --> 00:12:24.736
always find one where the linear

00:12:24.736 --> 00:12:27.206
algorithm wins and continues to

00:12:27.206 --> 00:12:28.206
win forever.

00:12:29.346 --> 00:12:30.506
So, we're talking about

00:12:30.506 --> 00:12:32.356
scalability, not absolute

00:12:32.406 --> 00:12:33.000
performance.

00:12:36.436 --> 00:12:40.346
Well, my scalability problem was

00:12:40.346 --> 00:12:42.316
fixed, but I really wanted to

00:12:42.316 --> 00:12:44.196
see how the standard library had

00:12:44.196 --> 00:12:46.256
improved on my backward deletion

00:12:46.256 --> 00:12:46.616
scheme.

00:12:47.886 --> 00:12:49.586
Crusty reminded me that Swift is

00:12:49.586 --> 00:12:50.986
open source, so I could pull it

00:12:50.986 --> 00:12:53.006
up on what he calls "the hipster

00:12:53.006 --> 00:12:53.426
web."

00:12:53.816 --> 00:12:54.786
But the rest of us know as

00:12:54.786 --> 00:12:55.500
GitHub.

00:12:59.266 --> 00:13:00.776
Now, the first thing I noticed

00:13:00.776 --> 00:13:03.106
was the dot comment, which was

00:13:03.136 --> 00:13:04.456
the source of all that Quick

00:13:04.456 --> 00:13:06.636
Help, describing both what the

00:13:06.636 --> 00:13:08.556
algorithm does and its

00:13:08.556 --> 00:13:09.136
complexity.

00:13:09.596 --> 00:13:14.046
Next, it turns out that

00:13:14.046 --> 00:13:15.946
removeAll(where) isn't just some

00:13:15.946 --> 00:13:18.486
method on a reg; it's a generic

00:13:18.486 --> 00:13:20.466
algorithm, which means that it

00:13:20.466 --> 00:13:22.126
works on a wide variety of

00:13:22.126 --> 00:13:22.926
different collections.

00:13:24.286 --> 00:13:25.296
It depends on a couple of

00:13:25.296 --> 00:13:28.376
things, the ability to rearrange

00:13:28.376 --> 00:13:29.556
elements, which comes from

00:13:29.556 --> 00:13:31.636
mutable collection, and the

00:13:31.966 --> 00:13:34.626
ability to change the length and

00:13:34.626 --> 00:13:36.506
structure, which comes from

00:13:36.506 --> 00:13:37.656
range-replaceable collection.

00:13:38.186 --> 00:13:41.606
And it's built from a couple of

00:13:41.606 --> 00:13:43.206
other order n algorithms.

00:13:44.016 --> 00:13:46.126
The first is a half stable

00:13:46.126 --> 00:13:48.096
partition, which moves all of

00:13:48.096 --> 00:13:49.416
the elements satisfying some

00:13:49.416 --> 00:13:53.456
predicate to the end and tells

00:13:53.456 --> 00:13:54.846
us where that suffix starts.

00:13:56.136 --> 00:13:57.786
The half stable in its name,

00:13:58.186 --> 00:14:00.196
that comes, that indicates that

00:14:00.196 --> 00:14:02.116
it preserves the order of the

00:14:02.116 --> 00:14:03.646
elements that it doesn't move,

00:14:04.486 --> 00:14:06.396
but it can scramble the elements

00:14:06.436 --> 00:14:09.026
that it moves to the end.

00:14:09.206 --> 00:14:10.426
Now, sometimes, that doesn't

00:14:10.426 --> 00:14:11.786
matter though; the second

00:14:11.786 --> 00:14:13.166
algorithm removes subrange.

00:14:13.166 --> 00:14:14.146
It's just going to delete them

00:14:14.146 --> 00:14:14.456
anyway.

00:14:16.476 --> 00:14:17.956
Have we all seen this partial

00:14:17.956 --> 00:14:18.696
range notation?

00:14:19.256 --> 00:14:21.426
It's just a really convenient

00:14:21.426 --> 00:14:22.656
way of writing a range that

00:14:22.656 --> 00:14:23.696
extends to the end of the

00:14:23.696 --> 00:14:24.000
collection.

00:14:26.896 --> 00:14:27.116
Okay.

00:14:27.846 --> 00:14:29.986
Now, remove subrange is part of

00:14:29.986 --> 00:14:31.826
the library's public API, so you

00:14:31.826 --> 00:14:33.496
can find its documentation

00:14:33.496 --> 00:14:36.276
online, but halfStablePartition

00:14:36.456 --> 00:14:37.696
is an implementation detail.

00:14:38.236 --> 00:14:42.166
Now, we're not going to step

00:14:42.166 --> 00:14:43.556
through all of it, but there are

00:14:43.556 --> 00:14:44.906
a few things worth noticing

00:14:44.906 --> 00:14:45.116
here.

00:14:46.516 --> 00:14:48.846
First, it starts by calling yet

00:14:48.846 --> 00:14:49.696
another algorithm,

00:14:50.486 --> 00:14:52.596
firstIndex(where), to find the

00:14:52.856 --> 00:14:54.716
position of the first element

00:14:54.716 --> 00:14:55.796
that belongs in the suffix.

00:14:57.176 --> 00:14:58.766
Next, it sets up a loop variable

00:14:58.766 --> 00:15:01.126
j, and there's a single loop,

00:15:01.616 --> 00:15:04.906
and the loop index j moves

00:15:05.046 --> 00:15:06.646
forward one on each iteration.

00:15:07.696 --> 00:15:09.196
So, it's a sure bet that j makes

00:15:09.196 --> 00:15:10.716
just one pass over the elements.

00:15:11.116 --> 00:15:14.086
You can almost see the order and

00:15:14.086 --> 00:15:20.306
complexity just from that.

00:15:20.516 --> 00:15:22.106
Lastly, because this method

00:15:22.106 --> 00:15:23.526
needs to rearrange elements but

00:15:23.526 --> 00:15:24.726
not change the length or

00:15:24.726 --> 00:15:26.396
structure of the collection, it

00:15:26.396 --> 00:15:27.506
only depends on mutable

00:15:27.506 --> 00:15:28.606
collection conformance.

00:15:29.146 --> 00:15:32.366
So, this is the first lesson I

00:15:32.366 --> 00:15:32.676
learned.

00:15:33.686 --> 00:15:34.966
Become familiar with what's in

00:15:34.966 --> 00:15:36.166
the Swift Standard Library.

00:15:37.176 --> 00:15:38.606
It contains a suite of

00:15:38.606 --> 00:15:40.416
algorithms with documented

00:15:40.416 --> 00:15:41.486
meanings and performance

00:15:41.486 --> 00:15:42.316
characteristics.

00:15:43.406 --> 00:15:45.526
And although we happened to peek

00:15:45.526 --> 00:15:47.416
at the implementation, and you

00:15:47.416 --> 00:15:49.126
can learn a lot that way, it's

00:15:49.156 --> 00:15:50.786
designed so that you do not have

00:15:50.836 --> 00:15:50.946
to.

00:15:52.426 --> 00:15:53.756
The official documentation

00:15:53.756 --> 00:15:55.046
should tell you everything you

00:15:55.046 --> 00:15:56.856
need to know in order to use the

00:15:56.856 --> 00:15:58.006
library effectively.

00:15:58.996 --> 00:16:00.126
You'll even find a playground

00:16:00.126 --> 00:16:00.846
tutorial there.

00:16:01.906 --> 00:16:03.856
Now, I realize there's a lot in

00:16:03.856 --> 00:16:05.436
Swift, so it can look daunting,

00:16:06.196 --> 00:16:07.306
but you don't need to remember

00:16:07.306 --> 00:16:07.706
everything.

00:16:08.696 --> 00:16:10.066
Having an idea of what's there

00:16:10.066 --> 00:16:12.156
and how to find it will take you

00:16:12.156 --> 00:16:13.326
a long way.

00:16:14.396 --> 00:16:16.466
Now, before we move on, I want

00:16:16.466 --> 00:16:18.326
to point out something else that

00:16:18.326 --> 00:16:19.576
happened in my code when Crusty

00:16:19.576 --> 00:16:20.276
made this change.

00:16:21.136 --> 00:16:22.816
Which one of these most directly

00:16:22.816 --> 00:16:23.776
describes its meaning?

00:16:24.346 --> 00:16:27.166
Now, I actually have to read and

00:16:27.226 --> 00:16:28.406
think through the first one to

00:16:28.406 --> 00:16:29.216
know what it's doing.

00:16:30.086 --> 00:16:30.376
Hmm.

00:16:30.616 --> 00:16:31.836
Maybe I'd better add a comment.

00:16:32.806 --> 00:16:33.026
Okay.

00:16:33.026 --> 00:16:33.646
How does that look?

00:16:34.196 --> 00:16:35.836
Oh, even with that comment, the

00:16:35.836 --> 00:16:37.156
reverse iteration is kind of

00:16:37.156 --> 00:16:38.356
tricky, and I don't want

00:16:38.356 --> 00:16:39.776
somebody breaking this code

00:16:39.776 --> 00:16:40.826
because they don't understand

00:16:40.826 --> 00:16:40.946
it.

00:16:41.266 --> 00:16:45.046
So, I'd better explain that.

00:16:45.256 --> 00:16:45.726
Okay.

00:16:46.126 --> 00:16:47.596
While we're clarifying things,

00:16:47.656 --> 00:16:49.866
the After code actually reads

00:16:49.866 --> 00:16:50.956
better with a trailing closure

00:16:50.956 --> 00:16:51.606
syntax.

00:16:51.966 --> 00:16:54.896
Now, take a breath and look

00:16:54.896 --> 00:16:55.196
again.

00:16:56.606 --> 00:16:57.936
Which one is more obviously

00:16:57.936 --> 00:16:58.346
correct?

00:16:59.526 --> 00:17:00.956
Even with all these comments, I

00:17:00.956 --> 00:17:02.016
still need to read through the

00:17:02.016 --> 00:17:03.936
first one just to see that it

00:17:03.936 --> 00:17:05.886
does inefficiently the same

00:17:05.955 --> 00:17:06.976
thing as the second one.

00:17:08.056 --> 00:17:09.465
Using the algorithm just made

00:17:09.465 --> 00:17:10.955
the code better in every way.

00:17:11.526 --> 00:17:15.356
So, this is a guideline, an

00:17:15.356 --> 00:17:16.955
aspiration for your code first

00:17:16.986 --> 00:17:18.486
put forward by Shawn Perin.

00:17:19.636 --> 00:17:20.836
Every time you write a loop,

00:17:21.316 --> 00:17:22.526
replace it with a call to an

00:17:22.526 --> 00:17:23.046
algorithm.

00:17:23.846 --> 00:17:25.955
If you can't find one, make that

00:17:25.955 --> 00:17:27.366
algorithm yourself and move the

00:17:27.366 --> 00:17:28.656
loop into its implementation.

00:17:30.656 --> 00:17:32.496
Actually following this might

00:17:32.496 --> 00:17:34.156
seem unrealistic to you now, but

00:17:34.196 --> 00:17:36.166
by the end of the talk, I hope

00:17:36.516 --> 00:17:37.056
it won't.

00:17:38.096 --> 00:17:39.356
For a little motivation though,

00:17:39.856 --> 00:17:42.246
think back to the last time you

00:17:42.246 --> 00:17:43.536
were looking at spaghetti code.

00:17:44.066 --> 00:17:46.296
Was it full of loops?

00:17:47.506 --> 00:17:50.276
I bet it was.

00:17:50.766 --> 00:17:51.236
All right.

00:17:51.386 --> 00:17:52.286
Done and done.

00:17:52.506 --> 00:17:53.666
I have just made the code

00:17:53.666 --> 00:17:56.066
shorter, faster, and better in

00:17:56.066 --> 00:17:56.686
every way.

00:17:56.686 --> 00:17:58.726
I was ready to call it a day.

00:17:59.376 --> 00:18:00.546
"Thanks for your help, Crusty,"

00:18:00.546 --> 00:18:02.576
I said, fastening the titanium

00:18:02.576 --> 00:18:05.036
carabiners on my bespoke leather

00:18:05.036 --> 00:18:07.336
messenger bag, but he looked at

00:18:07.336 --> 00:18:09.586
me suspiciously, and said, "You

00:18:09.586 --> 00:18:10.966
suppose you might have made that

00:18:10.966 --> 00:18:12.330
mistake anywhere else?"

00:18:14.166 --> 00:18:16.746
I sighed, put my bag down and

00:18:16.746 --> 00:18:18.156
started hunting down the loops

00:18:18.156 --> 00:18:18.746
in my code.

00:18:20.016 --> 00:18:21.786
There were lots in the file

00:18:22.106 --> 00:18:24.106
[inaudible].

00:18:24.426 --> 00:18:28.666
Bring to front, send it back,

00:18:29.596 --> 00:18:31.126
bring forward, which sort of

00:18:31.126 --> 00:18:32.686
hops the selected shape over the

00:18:32.686 --> 00:18:33.486
one in front of it.

00:18:34.746 --> 00:18:36.666
Let's do that a couple of more

00:18:38.076 --> 00:18:38.206
times.

00:18:38.406 --> 00:18:40.536
Send backward with hops, under

00:18:40.536 --> 00:18:41.756
the shape, below the selected

00:18:41.756 --> 00:18:45.486
shape, and last of all, dragging

00:18:45.486 --> 00:18:49.776
in the shape list at the left.

00:18:49.776 --> 00:18:52.196
Now, these sound really simple

00:18:52.746 --> 00:18:56.126
until you realize that they all

00:18:56.126 --> 00:18:57.566
need to operate on multiple

00:18:57.566 --> 00:18:59.096
selected shapes that might not

00:18:59.096 --> 00:19:01.316
even be contiguous in the list.

00:19:05.226 --> 00:19:06.486
So, it turns out that the

00:19:06.486 --> 00:19:07.906
behavior that makes sense is to

00:19:07.906 --> 00:19:09.166
leave all of the selected

00:19:09.166 --> 00:19:10.826
elements next to each other

00:19:10.826 --> 00:19:12.126
after the operation is finished.

00:19:13.126 --> 00:19:14.176
So, when you're bringing shapes

00:19:14.176 --> 00:19:15.596
forward, you hop the front most

00:19:15.596 --> 00:19:17.136
selected shape in front of its

00:19:17.136 --> 00:19:18.936
neighbor, and then you group all

00:19:18.936 --> 00:19:20.566
the other ones behind it.

00:19:22.386 --> 00:19:23.736
And when you send shapes

00:19:23.776 --> 00:19:25.496
backward, you hop the bottom

00:19:25.496 --> 00:19:26.926
most selected shape backward

00:19:26.926 --> 00:19:28.396
behind its neighbor and group

00:19:28.396 --> 00:19:30.366
the other ones in front of it.

00:19:33.756 --> 00:19:36.256
So, if you didn't follow that

00:19:36.256 --> 00:19:37.626
completely, don't worry.

00:19:37.626 --> 00:19:38.526
We'll come back to it.

00:19:38.856 --> 00:19:41.386
But suffice it to say that I had

00:19:41.386 --> 00:19:42.836
some pretty carefully worked out

00:19:42.836 --> 00:19:44.356
code to get all of these details

00:19:44.356 --> 00:19:44.606
right.

00:19:45.866 --> 00:19:47.996
For example, this was

00:19:47.996 --> 00:19:51.256
bringToFront, and when I looked

00:19:51.256 --> 00:19:53.656
at it, sure enough, there was an

00:19:53.656 --> 00:19:55.366
order n loop over the shapes

00:19:55.956 --> 00:19:57.716
containing two order n

00:19:57.716 --> 00:20:00.186
operations, remove(at:) and

00:20:00.186 --> 00:20:02.756
insert(at:), which makes this,

00:20:03.246 --> 00:20:04.786
you guessed it, n squared.

00:20:06.246 --> 00:20:08.526
In fact, that same problem

00:20:08.526 --> 00:20:10.076
showed up in every one of my

00:20:10.076 --> 00:20:11.076
other four commands.

00:20:12.516 --> 00:20:14.046
All of the implementations here

00:20:14.386 --> 00:20:16.196
loop over an array, performing

00:20:16.196 --> 00:20:17.936
insertions and removals, which

00:20:17.936 --> 00:20:19.126
means they're all quadratic.

00:20:19.626 --> 00:20:23.096
Now, I was kind of discouraged

00:20:23.096 --> 00:20:24.996
at this point, so I asked Crusty

00:20:24.996 --> 00:20:26.106
if he'd look at them with me.

00:20:27.406 --> 00:20:29.106
He said, "Can't stay too late,"

00:20:29.186 --> 00:20:31.156
he said, "I got my ballroom

00:20:31.156 --> 00:20:33.096
dancing tonight, but I guess we

00:20:33.226 --> 00:20:34.546
better get a move on."

00:20:35.306 --> 00:20:37.486
So, I pulled up bringToFront,

00:20:38.686 --> 00:20:40.946
and Crusty's first question was,

00:20:42.156 --> 00:20:44.546
"What does it actually do?"

00:20:45.846 --> 00:20:47.566
"Well," I said, "there's a while

00:20:47.566 --> 00:20:49.426
loop and j tracks the insertion

00:20:49.426 --> 00:20:51.266
point and i tracks the element

00:20:51.266 --> 00:20:51.906
we're looking at."

00:20:52.226 --> 00:20:54.216
"In words, not in codes," said

00:20:54.246 --> 00:20:54.666
Crusty.

00:20:55.706 --> 00:20:57.126
"Describe it."

00:20:58.146 --> 00:20:59.286
"Okay. Let's see.

00:20:59.776 --> 00:21:01.616
It moves the selected shapes to

00:21:01.616 --> 00:21:03.406
the front, maintaining their

00:21:03.406 --> 00:21:04.176
relative order."

00:21:04.706 --> 00:21:07.136
"Write that down in a dot

00:21:07.136 --> 00:21:08.376
comment and read it back to me."

00:21:10.406 --> 00:21:13.146
I'm a superfast typist.

00:21:15.236 --> 00:21:17.416
"Moves the selected shapes to

00:21:17.416 --> 00:21:18.496
the front, maintaining their

00:21:18.496 --> 00:21:19.286
relative order."

00:21:19.706 --> 00:21:21.766
"Sound familiar?"

00:21:22.186 --> 00:21:22.796
said Crusty.

00:21:24.066 --> 00:21:25.276
That's when I realized that this

00:21:25.276 --> 00:21:26.736
was a lot like half stable

00:21:26.766 --> 00:21:29.286
partition, except it's fully

00:21:29.286 --> 00:21:29.676
stable.

00:21:29.676 --> 00:21:32.046
I was starting to get excited.

00:21:32.556 --> 00:21:33.776
And what do you think this one

00:21:33.776 --> 00:21:34.226
is called?

00:21:34.906 --> 00:21:36.516
So, I had to guess, "Stable

00:21:36.516 --> 00:21:37.026
partition?"

00:21:37.566 --> 00:21:38.346
"That's right.

00:21:38.536 --> 00:21:41.126
One of my old favorites, and you

00:21:41.126 --> 00:21:42.426
can find an implementation in

00:21:42.426 --> 00:21:43.946
this here file from the Swift

00:21:43.946 --> 00:21:45.486
Open Source project."

00:21:46.356 --> 00:21:48.396
So, I pulled the file into my

00:21:48.396 --> 00:21:50.006
project, while Crusty mumbled

00:21:50.006 --> 00:21:51.266
something about how that comment

00:21:51.266 --> 00:21:52.206
we added should have been there

00:21:52.206 --> 00:21:55.756
all along, and I started coding,

00:21:56.936 --> 00:21:59.526
getting about this far before I

00:21:59.526 --> 00:22:00.196
had a problem.

00:22:01.666 --> 00:22:03.716
You see, stable partition takes

00:22:03.716 --> 00:22:06.306
a predicate that says whether to

00:22:06.306 --> 00:22:07.966
move an element into the suffix

00:22:08.416 --> 00:22:09.126
of the collection.

00:22:09.946 --> 00:22:11.326
So, I had to express bring to

00:22:11.516 --> 00:22:13.496
front in terms of moving things

00:22:13.496 --> 00:22:14.046
to the back.

00:22:15.406 --> 00:22:16.256
I looked at Crusty.

00:22:17.276 --> 00:22:19.286
"Visualize it," he said.

00:22:20.286 --> 00:22:21.986
So, I closed my eyes and watched

00:22:22.646 --> 00:22:24.176
as the unselected shapes

00:22:24.176 --> 00:22:25.936
gathered at the back, which gave

00:22:25.936 --> 00:22:26.616
me my answer.

00:22:27.226 --> 00:22:31.096
Now, I guess sendToBack was even

00:22:31.096 --> 00:22:32.436
easier because we just need to

00:22:32.436 --> 00:22:33.276
invert the predicate.

00:22:33.836 --> 00:22:34.996
We're sending the selected ones

00:22:35.056 --> 00:22:38.126
to the back.

00:22:38.346 --> 00:22:40.566
Now, I was just about to attack

00:22:40.566 --> 00:22:42.476
the bring forward command, and I

00:22:42.476 --> 00:22:43.986
figured that Crusty would be as

00:22:43.986 --> 00:22:46.346
eager to move on as I was, given

00:22:46.346 --> 00:22:47.436
his plans for the evening, but

00:22:47.756 --> 00:22:48.376
he stopped me.

00:22:49.296 --> 00:22:50.446
"Hold your horses, Snuffy.

00:22:51.616 --> 00:22:52.856
I don't want to miss the opening

00:22:52.856 --> 00:22:54.676
tango, but aren't you going to

00:22:54.676 --> 00:22:55.926
check whether it'll scale?"

00:22:57.326 --> 00:22:59.776
He had a point, so I popped up

00:22:59.776 --> 00:23:00.766
the Quick Help for stable

00:23:00.806 --> 00:23:04.196
partition, and I saw that it had

00:23:04.416 --> 00:23:06.046
(n log n) complexity.

00:23:06.606 --> 00:23:09.356
So, for a way to think about (n

00:23:09.356 --> 00:23:11.506
log n) take a look at log n.

00:23:12.096 --> 00:23:15.236
It starts to level off really

00:23:15.236 --> 00:23:17.246
quickly, and the bigger it gets,

00:23:17.496 --> 00:23:19.856
the slower it grows, and the

00:23:19.886 --> 00:23:21.246
closer it comes to being a

00:23:21.246 --> 00:23:21.716
constant.

00:23:22.526 --> 00:23:24.136
So, when you multiply that by n,

00:23:24.136 --> 00:23:27.366
you get something that doesn't

00:23:27.566 --> 00:23:29.376
scale quite as well as order n

00:23:29.876 --> 00:23:31.466
but that gets closer and closer

00:23:31.466 --> 00:23:32.946
to linear as it grows.

00:23:34.146 --> 00:23:36.696
So, order n login is rightly

00:23:36.696 --> 00:23:38.556
often treated as being almost

00:23:38.556 --> 00:23:40.066
the same as order n.

00:23:40.896 --> 00:23:42.296
I was pretty happy with that.

00:23:43.056 --> 00:23:44.326
So, we moved on to bring

00:23:44.326 --> 00:23:44.696
forward.

00:23:45.246 --> 00:23:49.646
Now, as we said earlier, bring

00:23:49.726 --> 00:23:51.626
forward bumps the front most

00:23:51.626 --> 00:23:53.006
selected shape forward by one

00:23:53.006 --> 00:23:55.296
position and gathers the other

00:23:55.296 --> 00:23:56.576
selected shapes behind it.

00:23:57.876 --> 00:24:00.156
But Crusty didn't like that way

00:24:00.156 --> 00:24:01.506
of thinking about it at all.

00:24:02.146 --> 00:24:03.396
"That little do-si-do at the

00:24:03.396 --> 00:24:05.026
beginning is making a line dance

00:24:05.026 --> 00:24:06.096
look like a Fox Trot."

00:24:06.356 --> 00:24:08.466
he said, "You don't need it."

00:24:09.096 --> 00:24:10.906
When I looked at him blankly, he

00:24:10.906 --> 00:24:12.206
broke out the lozenges again,

00:24:13.976 --> 00:24:15.616
and with five of his free

00:24:15.616 --> 00:24:17.836
digits, he executed the

00:24:17.836 --> 00:24:19.926
bringForward command.

00:24:22.556 --> 00:24:23.506
"See it again?"

00:24:23.776 --> 00:24:24.226
he asked.

00:24:25.416 --> 00:24:26.816
I felt a little like a mark in a

00:24:26.816 --> 00:24:29.666
Three-card Monte, but I played

00:24:33.826 --> 00:24:33.976
along.

00:24:34.256 --> 00:24:35.176
"Look familiar?"

00:24:36.336 --> 00:24:36.616
"No."

00:24:37.826 --> 00:24:39.296
He threw a hanky over the first

00:24:39.876 --> 00:24:40.006
few.

00:24:42.296 --> 00:24:46.366
"How about now?"

00:24:46.636 --> 00:24:48.876
That's when I realized it was

00:24:48.876 --> 00:24:50.226
just another stable partition.

00:24:51.416 --> 00:24:51.766
Okay.

00:24:52.236 --> 00:24:54.046
I got this, I thought.

00:24:55.856 --> 00:24:58.096
If we find the front most

00:24:58.096 --> 00:25:01.716
selected shape, then move to its

00:25:01.746 --> 00:25:05.326
predecessor, and isolate the

00:25:05.606 --> 00:25:07.086
section of the array that starts

00:25:07.086 --> 00:25:09.716
there, we could just partition

00:25:10.556 --> 00:25:10.666
that.

00:25:12.236 --> 00:25:14.166
"But how do you modify just part

00:25:14.166 --> 00:25:14.776
of a collection?"

00:25:14.976 --> 00:25:15.676
I asked Crusty.

00:25:16.876 --> 00:25:17.746
"Ain't you never heard of a

00:25:17.746 --> 00:25:18.296
slice?"

00:25:18.526 --> 00:25:19.516
he said, taking over the

00:25:19.516 --> 00:25:19.946
keyboard.

00:25:23.156 --> 00:25:25.106
"Shapes, starting with

00:25:25.726 --> 00:25:26.336
predecessor.

00:25:27.656 --> 00:25:28.256
There.

00:25:28.256 --> 00:25:29.596
Stick that in your algorithm and

00:25:29.596 --> 00:25:30.146
mutate it."

00:25:30.896 --> 00:25:32.000
Which I promptly did.

00:25:37.716 --> 00:25:41.456
So, human knowledge about how to

00:25:41.456 --> 00:25:43.096
compute things correctly and

00:25:43.096 --> 00:25:44.976
efficiently predates computers

00:25:44.976 --> 00:25:47.156
by thousands of years, going

00:25:47.156 --> 00:25:48.846
back at least to ancient Egypt,

00:25:49.546 --> 00:25:50.656
and since the invention of

00:25:50.656 --> 00:25:52.086
computers, there's been an

00:25:52.086 --> 00:25:53.696
explosion of work in this area.

00:25:55.186 --> 00:25:56.586
If the standard library doesn't

00:25:56.586 --> 00:25:58.386
have what you need, what you do

00:25:58.386 --> 00:26:00.556
need is probably out there with

00:26:00.556 --> 00:26:03.396
tests, with documentation, often

00:26:03.396 --> 00:26:04.786
with a proof of correctness.

00:26:05.746 --> 00:26:07.436
Learn how to search the web for

00:26:07.436 --> 00:26:08.746
research that applies to your

00:26:08.746 --> 00:26:10.086
problem domain.

00:26:12.716 --> 00:26:12.946
Okay.

00:26:12.946 --> 00:26:13.596
Back to the code.

00:26:14.076 --> 00:26:15.656
I was intrigued by this slice

00:26:15.706 --> 00:26:17.136
thing, and when I checked out

00:26:17.136 --> 00:26:19.596
its type, I saw that it wasn't

00:26:19.596 --> 00:26:20.156
an array.

00:26:20.716 --> 00:26:23.306
Since we had used stable

00:26:23.306 --> 00:26:24.876
partition on an array and

00:26:24.876 --> 00:26:27.216
bringToFront and sendToBack, and

00:26:27.216 --> 00:26:28.776
now we were using it on an array

00:26:28.776 --> 00:26:30.876
slice, I guessed out loud that

00:26:30.876 --> 00:26:32.496
it must be generic.

00:26:32.496 --> 00:26:34.636
"Of course, it is.

00:26:35.176 --> 00:26:36.446
What's stable partition got to

00:26:36.446 --> 00:26:37.846
do with the specifics of array?"

00:26:39.166 --> 00:26:40.436
"That's right, nothing.

00:26:41.336 --> 00:26:44.046
Speaking of which, Blonkey, just

00:26:44.046 --> 00:26:45.416
what does bringForward have to

00:26:45.416 --> 00:26:46.946
do with shapes and selection?"

00:26:48.616 --> 00:26:51.166
"Well," I said, "it works on

00:26:51.166 --> 00:26:52.876
shapes, and it brings forward

00:26:52.876 --> 00:26:53.796
the selected ones."

00:26:54.046 --> 00:26:55.936
"That's right, nothing," he went

00:26:55.936 --> 00:26:56.736
on without listening.

00:26:58.636 --> 00:27:00.006
"Can you run bring forward on a

00:27:00.006 --> 00:27:00.926
row of lozenges?

00:27:01.926 --> 00:27:03.106
Of course, you can.

00:27:04.086 --> 00:27:05.516
So, it's got nothing to do with

00:27:06.206 --> 00:27:06.500
shapes."

00:27:08.206 --> 00:27:08.446
Hmm.

00:27:08.896 --> 00:27:10.916
"Are you suggesting we make it

00:27:10.916 --> 00:27:11.376
generic?"

00:27:11.556 --> 00:27:12.056
I asked.

00:27:12.676 --> 00:27:13.626
"Isn't that premature

00:27:13.626 --> 00:27:14.426
generalization?"

00:27:15.416 --> 00:27:16.546
Answering a question with a

00:27:16.546 --> 00:27:20.866
question, Crusty replied, "Well,

00:27:20.866 --> 00:27:22.416
just how do you plan to test

00:27:22.416 --> 00:27:23.330
this method?"

00:27:24.946 --> 00:27:26.736
"Okay," I said, "I'll create a

00:27:26.736 --> 00:27:27.376
canvas.

00:27:27.616 --> 00:27:28.726
I'll add a bunch of random

00:27:28.726 --> 00:27:29.186
shapes.

00:27:29.186 --> 00:27:30.886
I'll select some of them, and

00:27:30.886 --> 00:27:31.676
then finally..."

00:27:32.466 --> 00:27:33.776
But I didn't even finish the

00:27:33.776 --> 00:27:35.506
sentence because I knew it was a

00:27:35.506 --> 00:27:36.216
bad idea.

00:27:37.076 --> 00:27:39.126
If I did all of that, would I

00:27:39.126 --> 00:27:40.456
really be testing my function,

00:27:40.966 --> 00:27:42.066
or would I be testing the

00:27:42.066 --> 00:27:43.646
initializers of Canvas and

00:27:43.646 --> 00:27:45.606
various shapes, the addShape

00:27:45.606 --> 00:27:47.776
method, the isSelected property

00:27:47.976 --> 00:27:49.136
of the various shapes if it's

00:27:49.136 --> 00:27:49.706
computed?

00:27:50.106 --> 00:27:52.356
I have to build test cases for

00:27:52.356 --> 00:27:54.506
sure, but ideally, that code

00:27:54.736 --> 00:27:56.266
shouldn't depend on other code

00:27:56.266 --> 00:27:57.826
that I also have to test.

00:27:59.126 --> 00:28:00.506
If I can bring the lozenges

00:28:00.506 --> 00:28:02.776
forward, it should be possible

00:28:02.776 --> 00:28:04.406
to do something casual with

00:28:04.866 --> 00:28:05.636
[inaudible] in a playground,

00:28:05.986 --> 00:28:08.226
like this, which brings forward

00:28:08.226 --> 00:28:09.796
the number divisible by 3.

00:28:13.276 --> 00:28:14.596
Now, at the other end of the

00:28:14.596 --> 00:28:16.296
spectrum, I should be able to

00:28:16.296 --> 00:28:18.116
throw vast quantities of

00:28:18.116 --> 00:28:19.856
randomly generated test data at

00:28:19.856 --> 00:28:21.256
it and make sure that the

00:28:21.256 --> 00:28:22.386
algorithm scales.

00:28:23.246 --> 00:28:24.696
Neither of those was going to be

00:28:24.696 --> 00:28:26.076
easy as long as the code was

00:28:26.116 --> 00:28:27.906
tied to Canvas and shapes.

00:28:29.146 --> 00:28:31.506
And so, I admitted to Crusty

00:28:32.296 --> 00:28:33.546
that he was right and started

00:28:33.546 --> 00:28:34.846
making this non-generic

00:28:35.616 --> 00:28:37.106
bringForward into a generic one.

00:28:38.436 --> 00:28:40.666
The first step was to decouple

00:28:40.666 --> 00:28:44.896
it from Canvas and move it to

00:28:44.896 --> 00:28:45.696
arrays of shapes.

00:28:47.216 --> 00:28:49.266
Of course, this array is the

00:28:49.266 --> 00:28:50.556
shape, so I had to replace

00:28:50.556 --> 00:28:54.366
shapes with self, and then I

00:28:54.366 --> 00:28:56.866
decoupled it from selection by

00:28:56.866 --> 00:28:58.636
passing a predicate indicating

00:28:58.736 --> 00:29:00.046
whether a given shape should be

00:29:00.046 --> 00:29:00.866
brought forward.

00:29:04.716 --> 00:29:06.156
And everything kept compiling.

00:29:07.036 --> 00:29:07.386
Awesome!

00:29:08.266 --> 00:29:10.826
At that point, I was pleased to

00:29:10.826 --> 00:29:12.086
find there were no dependencies

00:29:12.086 --> 00:29:14.266
left on shape, and I could just

00:29:14.426 --> 00:29:15.406
delete the where clause.

00:29:15.956 --> 00:29:18.106
Pretty cool, I thought.

00:29:18.106 --> 00:29:20.106
Now, I can bring forward on any

00:29:20.106 --> 00:29:20.506
array.

00:29:21.636 --> 00:29:23.386
I looked over at Crusty, who had

00:29:23.386 --> 00:29:24.636
been quietly practicing the

00:29:24.676 --> 00:29:26.876
cha-cha-cha in the corner, but

00:29:26.876 --> 00:29:28.586
he didn't seem to think I was

00:29:29.736 --> 00:29:30.000
finished.

00:29:31.316 --> 00:29:32.996
"What does bring forward have to

00:29:32.996 --> 00:29:34.026
do with arrays?"

00:29:34.916 --> 00:29:37.196
he asked.

00:29:37.436 --> 00:29:38.976
"Well, nothing," I sighed and

00:29:38.976 --> 00:29:40.046
started thinking about how to

00:29:40.046 --> 00:29:41.206
remove this dependency.

00:29:42.656 --> 00:29:43.706
Let's see, there's a stable

00:29:43.706 --> 00:29:46.066
partition here, which requires

00:29:46.066 --> 00:29:47.636
mutable collection conformance.

00:29:48.186 --> 00:29:49.416
So, maybe I'll just move it to

00:29:49.416 --> 00:29:52.676
mutable collection.

00:29:53.006 --> 00:29:53.466
Hmm.

00:29:53.896 --> 00:29:56.076
I thought, clearly the index

00:29:56.116 --> 00:29:58.536
type doesn't match Int.

00:29:59.456 --> 00:29:59.746
Okay.

00:29:59.746 --> 00:30:00.826
So, there's a simple fix for

00:30:00.826 --> 00:30:01.000
this, right?

00:30:04.216 --> 00:30:04.936
Have you done this?

00:30:06.176 --> 00:30:08.106
Don't do this.

00:30:09.546 --> 00:30:11.326
It compiled, but Crusty had

00:30:11.326 --> 00:30:12.586
suddenly stopped dancing, and I

00:30:12.586 --> 00:30:15.156
knew something was wrong.

00:30:15.366 --> 00:30:16.166
"What?" I said.

00:30:16.966 --> 00:30:18.836
"Rookies always do that," said

00:30:18.836 --> 00:30:20.036
Crusty, shaking his head.

00:30:21.566 --> 00:30:23.216
"First, you got that comparison

00:30:23.216 --> 00:30:24.736
with 0, which is going to be

00:30:24.736 --> 00:30:26.056
wrong for array slice.

00:30:26.686 --> 00:30:29.456
So, did you know that array

00:30:29.456 --> 00:30:31.596
slices, their indices don't

00:30:31.596 --> 00:30:32.216
start at 0?

00:30:32.216 --> 00:30:35.696
The indices of all slices start

00:30:35.966 --> 00:30:37.506
with the corresponding index in

00:30:37.506 --> 00:30:38.786
the underlying collection that

00:30:38.786 --> 00:30:40.246
they were sliced from.

00:30:40.796 --> 00:30:42.976
That relationship is critical if

00:30:42.976 --> 00:30:44.126
you want to be able to compose

00:30:44.126 --> 00:30:46.466
generic algorithms using slices,

00:30:47.056 --> 00:30:47.946
so it's really important."

00:30:49.156 --> 00:30:51.946
Well, this problem, I knew to

00:30:51.946 --> 00:30:52.406
fix.

00:30:53.146 --> 00:30:54.126
Just compare it with start

00:30:54.126 --> 00:30:54.516
index.

00:30:55.766 --> 00:30:58.346
But the real problem is "What

00:30:58.346 --> 00:31:00.056
does bringForward have to do

00:31:00.056 --> 00:31:01.846
with having integer indices?"

00:31:01.846 --> 00:31:02.576
I interrupted.

00:31:03.416 --> 00:31:04.416
"Yeah, I know."

00:31:05.266 --> 00:31:07.466
"Well, I do have to get the

00:31:07.466 --> 00:31:10.156
index before i, which I can do

00:31:10.156 --> 00:31:10.876
with subtraction."

00:31:12.856 --> 00:31:14.976
Crusty just sighed and broke out

00:31:14.976 --> 00:31:15.906
the lozenges again.

00:31:17.466 --> 00:31:19.376
And then, he laid two fingers

00:31:19.376 --> 00:31:22.156
down on the desk and walked them

00:31:22.566 --> 00:31:24.966
across until his right hand was

00:31:25.136 --> 00:31:26.706
pointing at the first green

00:31:26.706 --> 00:31:27.276
lozenge.

00:31:27.806 --> 00:31:31.446
"Not a backwards step in the

00:31:31.446 --> 00:31:32.506
whole dance," he said.

00:31:33.406 --> 00:31:35.286
And I realized that Crusty had

00:31:35.286 --> 00:31:37.586
just shown me a new algorithm.

00:31:38.636 --> 00:31:39.546
Let's call that one

00:31:39.696 --> 00:31:40.986
indexBeforeFirst.

00:31:42.066 --> 00:31:43.776
"Now, the trick here is to keep

00:31:43.776 --> 00:31:46.086
your focus by assuming somebody

00:31:46.086 --> 00:31:46.976
already wrote it for you."

00:31:47.826 --> 00:31:49.116
And he proceeded to hack away

00:31:49.116 --> 00:31:50.336
all the code that we didn't

00:31:50.336 --> 00:31:53.906
need, like that and that.

00:31:56.616 --> 00:32:00.866
"Predecessor is the index before

00:32:00.866 --> 00:32:02.416
the first one where the

00:32:02.416 --> 00:32:04.286
predicate is satisfied.

00:32:05.346 --> 00:32:06.656
Now, just look how pretty that

00:32:06.656 --> 00:32:07.046
reads."

00:32:08.486 --> 00:32:10.946
Now, if you look at it, you can

00:32:10.946 --> 00:32:11.706
see that he's right.

00:32:13.116 --> 00:32:15.006
Taking away all the irrelevant

00:32:15.006 --> 00:32:17.436
detail about shapes, selections,

00:32:17.546 --> 00:32:20.066
arrays, and integers had left me

00:32:20.066 --> 00:32:22.006
with clearer code because it

00:32:22.006 --> 00:32:23.626
only traffics in the essentials

00:32:23.696 --> 00:32:24.356
of the problem.

00:32:24.926 --> 00:32:27.496
"I already showed you how

00:32:27.496 --> 00:32:28.956
indexBeforeFirst works.

00:32:29.266 --> 00:32:31.986
See if you could write it," he

00:32:31.986 --> 00:32:32.236
said.

00:32:32.706 --> 00:32:34.036
So, I think I was starting to

00:32:34.036 --> 00:32:36.016
catch on now because I got it

00:32:36.016 --> 00:32:37.036
right the first time.

00:32:37.666 --> 00:32:40.646
I told you, I'm a superfast

00:32:40.646 --> 00:32:40.996
typist.

00:32:41.466 --> 00:32:41.726
All right.

00:32:42.236 --> 00:32:45.436
So, return the first index whose

00:32:45.436 --> 00:32:48.536
successor matches the predicate.

00:32:49.206 --> 00:32:51.556
I was pretty excited about how

00:32:51.556 --> 00:32:52.396
well this was going.

00:32:53.436 --> 00:32:54.456
"All right, Crusty," I said,

00:32:54.766 --> 00:32:55.726
"let's do the next one."

00:32:57.516 --> 00:32:58.946
"Ain't you forgetting something,

00:32:58.946 --> 00:32:59.296
Bonkey?"

00:33:00.116 --> 00:33:00.586
he asked.

00:33:00.586 --> 00:33:02.306
I didn't know what he was

00:33:02.306 --> 00:33:02.906
talking about.

00:33:03.466 --> 00:33:05.276
The code was clean, and it

00:33:05.276 --> 00:33:05.666
worked.

00:33:07.016 --> 00:33:08.336
"Semantics, son.

00:33:09.046 --> 00:33:10.216
How am I supposed to use these

00:33:10.216 --> 00:33:11.416
from other code if I don't know

00:33:11.416 --> 00:33:12.156
what they mean?"

00:33:12.786 --> 00:33:17.156
And that's when I realized every

00:33:17.156 --> 00:33:18.926
time we'd use the new algorithm,

00:33:19.446 --> 00:33:20.326
we had leaned on his

00:33:20.326 --> 00:33:21.936
documentation to draw

00:33:21.936 --> 00:33:23.416
conclusions about the meaning

00:33:23.726 --> 00:33:25.296
and efficiency of our own code.

00:33:26.346 --> 00:33:27.846
And because most algorithms are

00:33:27.846 --> 00:33:29.456
built out of other algorithms,

00:33:29.896 --> 00:33:32.816
they lean on the same thing.

00:33:33.026 --> 00:33:34.826
Recently, I was interviewing a

00:33:34.826 --> 00:33:36.486
perspective intern and asked him

00:33:36.486 --> 00:33:38.236
about the role of documentation,

00:33:38.636 --> 00:33:40.226
and he began with a phrase I

00:33:40.226 --> 00:33:41.156
won't forget.

00:33:41.966 --> 00:33:43.306
"Oh, it's incredibly important,"

00:33:43.776 --> 00:33:44.206
he said.

00:33:45.646 --> 00:33:46.816
"We're building these towers of

00:33:46.816 --> 00:33:48.996
abstraction," and now I'm

00:33:48.996 --> 00:33:50.946
paraphrasing, "the reason we can

00:33:50.946 --> 00:33:52.286
build without constantly

00:33:52.286 --> 00:33:54.086
inspecting the layers below us

00:33:54.706 --> 00:33:56.036
is that the parts that we build

00:33:56.036 --> 00:33:57.176
on are documented."

00:33:57.666 --> 00:34:01.966
Now, as an app developer, you

00:34:02.176 --> 00:34:03.746
are working at the very top of a

00:34:03.746 --> 00:34:05.356
tower that stretches through

00:34:05.356 --> 00:34:07.966
your system frameworks, DOS, and

00:34:07.966 --> 00:34:09.556
into the hardware, which rests

00:34:10.146 --> 00:34:11.216
on the laws of physics.

00:34:12.815 --> 00:34:14.096
But as soon as you call one of

00:34:14.096 --> 00:34:15.936
your own methods, it becomes

00:34:15.936 --> 00:34:18.146
part of your foundation; so,

00:34:18.146 --> 00:34:19.666
document your code.

00:34:20.235 --> 00:34:21.565
The intern was hired, by the

00:34:21.565 --> 00:34:23.946
way, and he's sitting right

00:34:26.295 --> 00:34:26.406
there.

00:34:26.616 --> 00:34:28.896
So, I took the hint and

00:34:28.896 --> 00:34:29.936
documented Crusty's new

00:34:29.936 --> 00:34:32.956
algorithm, which meant that we

00:34:32.956 --> 00:34:33.716
could forget about the

00:34:33.716 --> 00:34:36.956
implementation and just use it,

00:34:37.206 --> 00:34:38.306
knowing that Quick Help had

00:34:38.306 --> 00:34:39.416
everything that we needed.

00:34:41.246 --> 00:34:42.856
Now, I also documented

00:34:42.856 --> 00:34:43.496
bringForward.

00:34:45.956 --> 00:34:46.565
Cool!

00:34:48.136 --> 00:34:49.456
Now, because it seemed to be

00:34:49.456 --> 00:34:51.626
solving all of my problems, at

00:34:51.626 --> 00:34:53.496
this point, I was really curious

00:34:53.496 --> 00:34:55.786
to see what was going on inside

00:34:55.786 --> 00:34:56.596
stablePartition.

00:34:57.806 --> 00:34:59.456
It turns out I was well rewarded

00:34:59.526 --> 00:35:01.416
because it's a really beautiful

00:35:01.416 --> 00:35:02.486
and instructive algorithm.

00:35:03.766 --> 00:35:05.196
The public method gets the

00:35:05.196 --> 00:35:06.846
collections count and passes it

00:35:06.846 --> 00:35:10.506
on to this helper, which uses a

00:35:10.506 --> 00:35:11.776
divide and conquer strategy.

00:35:13.056 --> 00:35:15.136
So, first, it takes care of the

00:35:15.136 --> 00:35:17.276
base cases when the count is

00:35:17.276 --> 00:35:18.436
less than 2, we're done.

00:35:18.966 --> 00:35:19.916
We just need to figure out

00:35:20.396 --> 00:35:21.656
whether the partition point is

00:35:21.656 --> 00:35:23.046
at the beginning or at the end

00:35:23.046 --> 00:35:26.016
of the collection.

00:35:26.116 --> 00:35:28.496
Next, we divide the collection

00:35:28.546 --> 00:35:29.416
in two.

00:35:31.136 --> 00:35:33.696
Now, at this point, you have to

00:35:33.746 --> 00:35:35.136
temporarily take it on faith

00:35:35.136 --> 00:35:37.146
that the algorithm works because

00:35:37.146 --> 00:35:38.346
we're going to stable partition

00:35:38.346 --> 00:35:41.056
the left half and the right

00:35:41.056 --> 00:35:41.446
half.

00:35:42.136 --> 00:35:46.766
Now, if you take a look at these

00:35:46.766 --> 00:35:49.166
two ends, you can see that

00:35:49.166 --> 00:35:50.746
everything is exactly in the

00:35:50.746 --> 00:35:54.556
right place, but this center

00:35:54.556 --> 00:35:56.516
section has two parts that need

00:35:56.516 --> 00:35:57.316
to be exchanged.

00:35:58.806 --> 00:36:01.016
Now, they won't always have the

00:36:01.016 --> 00:36:03.126
same length as they do in this

00:36:03.126 --> 00:36:06.716
example, and fortunately there's

00:36:06.716 --> 00:36:07.986
an algorithm for that.

00:36:08.906 --> 00:36:10.636
We call it rotate.

00:36:11.176 --> 00:36:11.276
Okay.

00:36:14.466 --> 00:36:16.496
I'm not going to go into rotate

00:36:16.496 --> 00:36:18.226
here, but it's actually quite

00:36:18.256 --> 00:36:19.156
beautiful, and if you're

00:36:19.156 --> 00:36:20.686
interested, you can find its

00:36:20.686 --> 00:36:22.446
implementation in the same file

00:36:22.446 --> 00:36:23.436
as stable partitions.

00:36:24.116 --> 00:36:24.216
Okay.

00:36:25.596 --> 00:36:27.146
Back to shapes.

00:36:28.186 --> 00:36:32.486
Now, this mess implemented the

00:36:32.696 --> 00:36:34.706
dragging in the shapes list, and

00:36:34.706 --> 00:36:36.626
it had always been one of my

00:36:36.626 --> 00:36:38.706
most complicated and buggy

00:36:38.706 --> 00:36:39.326
operations.

00:36:40.336 --> 00:36:41.616
The strategy had been to

00:36:41.616 --> 00:36:43.246
allocate the temporary buffer;

00:36:44.536 --> 00:36:46.486
then, loop over the shapes

00:36:47.076 --> 00:36:48.506
before the insertion point,

00:36:48.736 --> 00:36:50.196
extracting the selected ones and

00:36:50.196 --> 00:36:51.576
adjusting the insertion point,

00:36:52.526 --> 00:36:54.086
and then separately loop over

00:36:54.086 --> 00:36:55.896
the rest of the shapes without

00:36:55.896 --> 00:36:57.236
adjusting the insertion point,

00:36:57.236 --> 00:36:58.596
extracting the selected ones.

00:36:59.126 --> 00:37:02.716
And then, finally, reinsert

00:37:02.716 --> 00:37:02.916
them.

00:37:06.536 --> 00:37:08.806
Honestly, I was a little scared

00:37:08.806 --> 00:37:10.726
to touch the code because I

00:37:10.726 --> 00:37:12.156
thought I finally had it right.

00:37:12.156 --> 00:37:14.276
It had been almost a week since

00:37:14.276 --> 00:37:15.536
the last time I discovered a new

00:37:15.536 --> 00:37:16.056
bug.

00:37:16.526 --> 00:37:21.026
But I had gotten pretty good at

00:37:21.026 --> 00:37:22.726
this process now, so I tried

00:37:23.286 --> 00:37:24.766
visualizing the operation

00:37:24.766 --> 00:37:28.976
happening all at once.

00:37:29.106 --> 00:37:31.116
Hey, that looks familiar.

00:37:31.326 --> 00:37:34.856
Let's see it again.

00:37:35.056 --> 00:37:35.486
Hmm.

00:37:36.946 --> 00:37:39.826
Suppose we do this first, and

00:37:39.826 --> 00:37:40.926
then take care of the parts

00:37:40.926 --> 00:37:41.456
separately.

00:37:43.456 --> 00:37:44.246
That's right.

00:37:44.706 --> 00:37:45.946
This is just two stable

00:37:45.946 --> 00:37:48.036
partitions with inverted

00:37:48.696 --> 00:37:48.976
predicates.

00:37:49.596 --> 00:37:51.316
So, the generic algorithm

00:37:51.736 --> 00:37:52.846
collapsed down to this

00:37:52.886 --> 00:37:56.716
two-liner, and here's what's

00:37:56.716 --> 00:37:57.636
left in canvas.

00:37:58.186 --> 00:38:01.126
Now, let's just see that next to

00:38:01.126 --> 00:38:02.426
the old code.

00:38:04.456 --> 00:38:07.886
That's not bad, but we got a

00:38:07.886 --> 00:38:10.396
reusable efficient documented

00:38:10.766 --> 00:38:12.346
general purpose algorithm out of

00:38:12.346 --> 00:38:13.846
it, which is spectacular.

00:38:14.446 --> 00:38:14.556
Okay.

00:38:17.916 --> 00:38:21.846
So, this is a learned skill to

00:38:21.846 --> 00:38:23.746
look past the details that are

00:38:23.746 --> 00:38:25.086
specific to your application

00:38:25.086 --> 00:38:27.056
domain, see what your code is

00:38:27.056 --> 00:38:29.126
doing fundamentally, and capture

00:38:29.126 --> 00:38:31.416
that in reusable generic code.

00:38:32.276 --> 00:38:33.776
It takes practice.

00:38:34.966 --> 00:38:35.636
So, why bother?

00:38:36.536 --> 00:38:38.636
Well, the practical answer is

00:38:38.636 --> 00:38:39.966
that because they're decoupled

00:38:39.966 --> 00:38:41.896
from those irrelevant details,

00:38:42.336 --> 00:38:44.126
generic algorithms are more

00:38:44.126 --> 00:38:46.296
reusable, testable, and even

00:38:46.296 --> 00:38:47.976
clearer than their non-generic

00:38:47.976 --> 00:38:48.706
counterparts.

00:38:49.676 --> 00:38:51.336
But I also think it's just

00:38:51.586 --> 00:38:53.156
deeply rewarding for anyone that

00:38:53.296 --> 00:38:54.446
really loves programming.

00:38:55.646 --> 00:38:56.996
It's a search for truth and

00:38:56.996 --> 00:38:59.406
beauty but not some abstract

00:38:59.406 --> 00:39:01.266
untouchable truth because the

00:39:01.266 --> 00:39:02.876
constraints of actual hardware

00:39:02.876 --> 00:39:03.696
keep you honest.

00:39:04.836 --> 00:39:06.066
As Crusty likes to say,

00:39:07.026 --> 00:39:10.136
"Programming reveals the real."

00:39:10.346 --> 00:39:12.296
So, treat your computation as a

00:39:12.296 --> 00:39:14.576
first class citizen with all the

00:39:14.576 --> 00:39:16.186
rights and obligations that you

00:39:16.186 --> 00:39:18.416
take seriously for types and

00:39:18.416 --> 00:39:19.856
application architecture.

00:39:20.316 --> 00:39:22.566
Identify it, give it a name,

00:39:22.846 --> 00:39:25.756
unit test it, and document its

00:39:25.756 --> 00:39:27.006
semantics and performance.

00:39:27.096 --> 00:39:30.556
Now, I want to close by putting

00:39:30.556 --> 00:39:32.366
this advice you saw from Shawn

00:39:32.366 --> 00:39:34.136
Perin in its full context.

00:39:34.676 --> 00:39:37.466
"If you want to improve the code

00:39:37.466 --> 00:39:39.146
quality in your organization,

00:39:39.606 --> 00:39:41.586
replace all of your coding

00:39:41.586 --> 00:39:44.506
standards with one goal, No Raw

00:39:44.506 --> 00:39:44.976
Loops."

00:39:46.386 --> 00:39:46.696
Thank you.

00:39:47.516 --> 00:39:52.500
[ Applause ]
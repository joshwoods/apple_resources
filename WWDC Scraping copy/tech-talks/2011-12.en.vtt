WEBVTT

00:00:22.690 --> 00:00:27.080
Hi, I'm Paul Marcos,
Application Services Evangelist at Apple.

00:00:27.170 --> 00:00:30.120
When you write iOS and
Mac OS X applications,

00:00:30.120 --> 00:00:33.480
you do so using the
Objective-C programming language.

00:00:33.570 --> 00:00:35.640
I love using Objective-C.

00:00:35.720 --> 00:00:39.280
It's a simple,
elegant language that's easy to use,

00:00:39.330 --> 00:00:41.920
and you can write great
applications with it.

00:00:42.030 --> 00:00:45.620
And we've made it even better by
adding a really cool new technology

00:00:45.670 --> 00:00:48.070
called Automatic Reference Counting.

00:00:48.440 --> 00:00:50.750
Historically,
Objective-C has used a manual

00:00:50.750 --> 00:00:54.540
reference counting mechanism for
managing the lifetime of objects.

00:00:54.540 --> 00:00:57.900
Unlike an automatic
garbage collection system,

00:00:58.070 --> 00:01:01.140
you have to be careful to avoid
mistakes that can lead to memory

00:01:01.140 --> 00:01:02.970
leaks or application crashes.

00:01:04.100 --> 00:01:08.220
Unfortunately, these are common problems,
especially for programmers

00:01:08.220 --> 00:01:09.660
new to Objective-C.

00:01:10.050 --> 00:01:15.560
Thankfully, Automatic Reference Counting,
or ARC, eliminates the manual and

00:01:15.660 --> 00:01:19.930
error-prone steps involved in
managing reference-counted objects,

00:01:20.090 --> 00:01:24.370
freeing you to focus on the design
of your object relationships and the

00:01:24.470 --> 00:01:27.010
functionality of your application.

00:01:27.280 --> 00:01:30.540
Whether you're new to
Objective-C or a veteran coder,

00:01:30.740 --> 00:01:33.600
there's plenty to learn about
this powerful new technology

00:01:33.910 --> 00:01:36.940
and how it will lead to simpler,
more robust,

00:01:37.110 --> 00:01:38.650
and more easily maintained code.

00:01:38.680 --> 00:01:42.190
Let me show you how this is going
to make your life so much better.

00:01:44.440 --> 00:01:46.820
So what exactly is ARC?

00:01:46.840 --> 00:01:50.900
Automatic Reference Counting implements
automatic memory management for

00:01:50.900 --> 00:01:56.570
Objective-C objects and blocks,
freeing the programmer from the need to

00:01:56.570 --> 00:01:59.560
explicitly insert retains and releases.

00:01:59.730 --> 00:02:04.030
That's the textbook style answer, which,
as most textbooks are, is pretty dry.

00:02:04.030 --> 00:02:06.840
It's actually a lot more
interesting than that.

00:02:06.880 --> 00:02:08.540
So let's see what makes ARC so great.

00:02:11.550 --> 00:02:15.560
On iOS, you're responsible for
managing the memory yourself.

00:02:15.670 --> 00:02:17.140
But it's hard.

00:02:17.190 --> 00:02:20.440
There's a lot of details and
you've got to get them all right.

00:02:20.520 --> 00:02:25.380
It's really easy to make a mistake
and then your app crashes or leaks.

00:02:25.460 --> 00:02:28.200
So are there any alternatives?

00:02:28.250 --> 00:02:30.160
How about Garbage Collection?

00:02:30.190 --> 00:02:33.000
Garbage Collection does all that
stuff for you automatically and

00:02:33.000 --> 00:02:35.200
all the complexity just goes away.

00:02:35.200 --> 00:02:38.620
So it's pretty obvious that Garbage
Collection is the better way,

00:02:38.620 --> 00:02:39.200
right?

00:02:40.420 --> 00:02:43.600
Well, let's put these side by side
and see how they compare.

00:02:43.690 --> 00:02:47.800
Developing in a manual memory
management environment can be a pain.

00:02:47.890 --> 00:02:52.130
Garbage collection manages memory
for you and makes it a lot easier.

00:02:52.610 --> 00:02:54.520
On the manual side,
you have to write a lot of

00:02:54.680 --> 00:02:57.740
code that really doesn't add
any functionality to your app.

00:02:57.940 --> 00:03:02.180
With GC, you don't have to do that,
so you can focus on writing code

00:03:02.260 --> 00:03:04.650
that actually does something useful.

00:03:05.600 --> 00:03:07.930
And you just need to make a
single mistake in the manual

00:03:07.950 --> 00:03:09.740
world and your app crashes.

00:03:10.000 --> 00:03:13.900
You typically don't have that problem
in a garbage collected environment.

00:03:14.000 --> 00:03:16.670
So it's pretty clear that
garbage collection wins over

00:03:16.670 --> 00:03:18.670
manual memory management,
right?

00:03:19.480 --> 00:03:21.100
Well, it's not that easy.

00:03:21.170 --> 00:03:23.800
GC also has some downsides.

00:03:23.890 --> 00:03:28.080
First, with GC, garbage can build up,
as it might take a while for the

00:03:28.190 --> 00:03:30.040
collector to kick in and clean things up.

00:03:30.130 --> 00:03:32.370
That's not good,
especially if you don't have

00:03:32.370 --> 00:03:35.230
that much memory available,
like on a mobile device.

00:03:36.810 --> 00:03:40.040
That's where Manual Reference
Counting clearly performs better.

00:03:40.160 --> 00:03:44.500
As objects are freed,
the memory used is immediately available.

00:03:44.900 --> 00:03:48.340
Second, GC is non-deterministic.

00:03:48.400 --> 00:03:51.800
You typically don't have control
over when the collector kicks in.

00:03:51.890 --> 00:03:54.240
You don't really know what
state your app might be in,

00:03:54.300 --> 00:03:57.720
nor how long it will take
before you're back in control.

00:03:57.730 --> 00:04:00.980
With manual management,
you are in control and the

00:04:00.980 --> 00:04:02.020
behavior is predictable.

00:04:03.570 --> 00:04:06.450
Back on the GC side,
because you're not in control,

00:04:06.530 --> 00:04:10.320
it's possible that collection will
be done at a crucial point in time,

00:04:10.320 --> 00:04:13.700
like when the user is scrolling
through a list or zooming a photo.

00:04:13.750 --> 00:04:17.190
This can lead to visible
UI interruptions.

00:04:17.400 --> 00:04:20.090
With manual management,
it's easy to set the priorities

00:04:20.200 --> 00:04:23.100
right and deliver smooth performance.

00:04:23.220 --> 00:04:27.640
These are just some of the reasons
that GC is not available in iOS.

00:04:27.760 --> 00:04:31.140
We feel that smooth performance
and a stutter-free user experience

00:04:31.140 --> 00:04:33.560
are what matters to our users.

00:04:33.680 --> 00:04:38.480
Regardless, out of these two options,
neither one is a slam dunk winner.

00:04:39.360 --> 00:04:42.180
What we really want is
something that looks like this.

00:04:42.230 --> 00:04:44.240
It's the best of both worlds.

00:04:44.310 --> 00:04:48.300
Automatic memory management
without the performance drawbacks.

00:04:48.310 --> 00:04:49.950
And that's exactly what we did with ARC.

00:04:50.100 --> 00:04:53.280
It's still memory management
based on reference counting,

00:04:53.280 --> 00:04:56.210
just like it used to be when
you had to do it manually.

00:04:56.210 --> 00:04:58.960
It's just done automatically for you.

00:04:59.050 --> 00:05:02.270
So if you don't have to do it,
who does it?

00:05:04.650 --> 00:05:09.080
We taught our LLVM compiler to
do the memory management for you.

00:05:09.130 --> 00:05:13.000
It magically inserts all the
necessary bookkeeping calls for

00:05:13.000 --> 00:05:15.480
you in exactly the right places.

00:05:15.580 --> 00:05:18.590
This automatic bookkeeping
is done at compile time,

00:05:18.700 --> 00:05:21.840
which means there's no
thread or process at runtime,

00:05:21.920 --> 00:05:24.750
so no impact on performance.

00:05:25.020 --> 00:05:29.700
To better understand how this all works,
let's look at the following four things.

00:05:29.760 --> 00:05:35.240
First, we'll look at what impact this
has on how you write your code.

00:05:35.280 --> 00:05:39.460
Then I'll show you how you can
migrate an existing project to ARC.

00:05:40.320 --> 00:05:44.320
Next, we'll go through some tips
and tricks for using ARC.

00:05:44.350 --> 00:05:47.340
And we'll end with a couple
notes about performance.

00:05:47.490 --> 00:05:49.280
Let's dive in.

00:05:49.530 --> 00:05:52.300
There's an old adage that
goes something like this:

00:05:52.370 --> 00:05:56.270
"The best line of code is the
line you never had to write."

00:05:56.400 --> 00:06:00.120
That sums up what writing code
with ARC is really all about.

00:06:00.300 --> 00:06:03.460
If you already know Objective-C,
it's not so much about

00:06:03.660 --> 00:06:05.500
learning how to write ARC code.

00:06:05.600 --> 00:06:08.360
It's about not writing the
code in the first place.

00:06:08.470 --> 00:06:11.850
It's really all about writing less code.

00:06:12.180 --> 00:06:14.680
Because the compiler does
all this work for you now,

00:06:14.750 --> 00:06:17.470
there's simply less
code for you to write.

00:06:17.830 --> 00:06:21.050
Let's take a look at three
key areas where ARC impacts

00:06:21.050 --> 00:06:22.810
how you write your code.

00:06:23.020 --> 00:06:28.140
The first is about our old friends,
retain, release, and auto-release.

00:06:28.690 --> 00:06:31.180
So what's the big change with retain,
release, and auto-release?

00:06:31.530 --> 00:06:32.900
Well, it's very simple.

00:06:32.990 --> 00:06:35.240
They just go away.

00:06:35.390 --> 00:06:38.030
You never have to write them again.

00:06:38.190 --> 00:06:40.500
So what happens to your code?

00:06:41.570 --> 00:06:44.890
Under Manual Memory Management,
if you allocate an object,

00:06:45.210 --> 00:06:47.820
then you own it,
and it's your responsibility

00:06:47.820 --> 00:06:48.900
to release it.

00:06:49.140 --> 00:06:53.780
But under ARC, you still allocate it,
and you still own the object,

00:06:53.950 --> 00:06:57.150
but the compiler keeps track of
things and releases it for you

00:06:57.150 --> 00:06:59.180
as soon as you're done with it.

00:06:59.850 --> 00:07:02.900
So with ARC, the release just goes away.

00:07:03.000 --> 00:07:05.240
If you're already familiar
with Objective-C and how

00:07:05.240 --> 00:07:08.990
reference counting works,
this just feels really weird.

00:07:09.160 --> 00:07:11.220
That code just looks wrong.

00:07:11.470 --> 00:07:14.020
But with ARC, it's really not.

00:07:14.150 --> 00:07:17.610
You just have to forget about
the need to call release.

00:07:18.890 --> 00:07:20.650
Of course,
you can still use the convenience

00:07:20.770 --> 00:07:23.300
class methods to create your objects.

00:07:23.380 --> 00:07:27.930
In this example with a local variable,
nothing changes using ARC.

00:07:28.450 --> 00:07:32.080
But what about using convenience
methods with instance variables?

00:07:32.160 --> 00:07:34.640
Here's part of a simple
stack implementation.

00:07:34.720 --> 00:07:37.040
If you did this under
manual reference counting,

00:07:37.090 --> 00:07:41.390
you'd be in for a rude surprise
because your app would end up crashing.

00:07:41.760 --> 00:07:44.780
The problem is the array
created here is auto-released,

00:07:44.780 --> 00:07:47.890
and because it's not been retained,
it will be deallocated after

00:07:48.020 --> 00:07:49.290
the init method is done.

00:07:49.300 --> 00:07:53.460
Any subsequent uses of that
instance variable will likely crash.

00:07:53.480 --> 00:07:56.210
There's a couple ways
you could address this.

00:07:56.260 --> 00:07:59.310
First,
you could alloc and init the array.

00:07:59.360 --> 00:08:02.550
Now you own the array,
and it won't be deallocated.

00:08:02.580 --> 00:08:07.540
Well, now your app won't crash anymore,
but you've traded a crash for a leak,

00:08:07.690 --> 00:08:09.720
because the array is
never being released.

00:08:09.720 --> 00:08:11.110
So this is no good either.

00:08:11.180 --> 00:08:15.620
Now you would need to balance out
the retain with a release in dealloc.

00:08:17.120 --> 00:08:18.160
Great.

00:08:18.240 --> 00:08:21.000
Now you're good under
Manual Reference Counting.

00:08:21.120 --> 00:08:24.420
And that's perhaps the simplest example,
but it's illustrative of how

00:08:24.420 --> 00:08:28.000
easy it is to slip up and
forget to add that release,

00:08:28.130 --> 00:08:31.780
or to use an object that has
already been deallocated.

00:08:32.010 --> 00:08:36.700
With ARC, the compiler has got your back
and remembers all of this for you.

00:08:36.790 --> 00:08:39.730
It'll keep track of your
instance variables automatically,

00:08:39.730 --> 00:08:42.770
so you don't have to
write the release in DL.

00:08:43.640 --> 00:08:45.120
Under ARC, we can just take that out.

00:08:45.340 --> 00:08:50.070
In fact, you don't even need to write the
super DLK anymore because the

00:08:50.130 --> 00:08:53.450
compiler will always automatically
invoke your superclass's

00:08:53.450 --> 00:08:55.310
DLK method if you implement one.

00:08:58.300 --> 00:09:00.520
So this is totally fine under ARC.

00:09:00.590 --> 00:09:05.080
Again, this looks really wrong if you're
familiar with manual memory management,

00:09:05.210 --> 00:09:07.990
but it's actually correct with ARC.

00:09:09.160 --> 00:09:12.740
And you can even just use the
convenience methods in this case.

00:09:12.790 --> 00:09:16.740
Under manual reference counting,
this would crash, but with ARC,

00:09:16.780 --> 00:09:19.400
the compiler does the right thing.

00:09:20.860 --> 00:09:24.300
Let's consider another aspect of this
stack class to see a different example.

00:09:24.300 --> 00:09:29.500
This pop method removes the last
object from the stack and returns it.

00:09:29.580 --> 00:09:30.520
That's pretty simple, right?

00:09:30.520 --> 00:09:35.400
Well, under manual reference counting,
this method would likely not

00:09:35.400 --> 00:09:37.590
work and may actually crash.

00:09:38.090 --> 00:09:39.000
Why?

00:09:39.040 --> 00:09:42.210
Imagine if that last object you
wanted to return was only being

00:09:42.270 --> 00:09:43.860
retained by the array itself.

00:09:43.860 --> 00:09:48.550
The act of removing it from the array
would decrement the retain count and

00:09:48.550 --> 00:09:50.340
the object would then be deallocated.

00:09:50.340 --> 00:09:53.790
So this code could very well
return a deallocated object,

00:09:53.790 --> 00:09:56.460
and your caller won't
be happy about that.

00:09:58.970 --> 00:10:02.180
So you might simply add a call to
retain the object so that it's not

00:10:02.280 --> 00:10:04.900
deallocated anymore before you return it.

00:10:05.060 --> 00:10:07.010
But now you're returning
a retained object.

00:10:07.100 --> 00:10:12.690
This would be a leak and violates the
naming conventions used in Objective-C.

00:10:12.860 --> 00:10:16.490
So you would need to auto-release
it when you return the object.

00:10:17.700 --> 00:10:20.700
Now you're good under
Manual Reference Counting.

00:10:20.830 --> 00:10:24.300
But with ARC, you don't have to remember
this whole dance at all.

00:10:24.420 --> 00:10:27.100
The compiler does all
this bookkeeping for you,

00:10:27.220 --> 00:10:30.130
and these pitfalls just go away.

00:10:31.250 --> 00:10:35.110
This actually takes us back to where we
started with that simple implementation.

00:10:35.120 --> 00:10:37.400
And that's what you'd write using ARC.

00:10:37.440 --> 00:10:40.560
You write code in a way
that just feels natural.

00:10:40.620 --> 00:10:43.650
Let's look at the object graph to better
understand what's going on with ARC.

00:10:43.800 --> 00:10:47.050
Somewhere in your code,
you have a reference to the stack.

00:10:47.070 --> 00:10:49.430
And the stack has a
reference to the array.

00:10:49.560 --> 00:10:52.280
And the array holds
references to some objects.

00:10:52.280 --> 00:10:54.260
These are strong references.

00:10:55.060 --> 00:10:59.040
The first thing happening in the
pop method is you create a reference

00:10:59.040 --> 00:11:01.060
to the last object in the array.

00:11:01.060 --> 00:11:05.580
The compiler will make sure that this
reference is actually a strong reference.

00:11:05.580 --> 00:11:08.320
And as you can see,
when you remove the last

00:11:08.320 --> 00:11:11.990
object from the array,
it'll remove the strong reference

00:11:12.060 --> 00:11:14.080
the array had to the object.

00:11:14.080 --> 00:11:18.200
But since the compiler created
a strong reference from X,

00:11:18.450 --> 00:11:20.380
the object doesn't go away.

00:11:20.380 --> 00:11:24.760
But what happens when this
code returns X to the caller?

00:11:26.930 --> 00:11:29.600
Well, the compiler is smart enough to
understand that you want to pass

00:11:29.600 --> 00:11:33.560
this reference back to whatever
code is accepting the return.

00:11:33.700 --> 00:11:37.040
So it makes sure even
when X goes out of scope,

00:11:37.140 --> 00:11:39.670
the reference is passed
over to the caller and will

00:11:39.670 --> 00:11:41.680
continue tracking it there.

00:11:41.820 --> 00:11:44.500
Once the object is
ultimately no longer needed,

00:11:44.710 --> 00:11:47.460
then it will be released automatically.

00:11:49.060 --> 00:11:53.120
So ARC does some wonderful things
with managing Objective-C objects.

00:11:53.190 --> 00:11:56.800
But let's change gears slightly
and talk about blocks for a minute.

00:11:56.880 --> 00:12:00.040
In order to manage blocks
correctly in the manual world,

00:12:00.110 --> 00:12:03.880
you sometimes have to copy them
since they're created on the stack.

00:12:03.980 --> 00:12:06.560
For example,
if you wanted to return a block,

00:12:06.620 --> 00:12:09.250
you would have to copy it first,
which would move it from

00:12:09.400 --> 00:12:11.820
the stack to the heap,
and then you would have to

00:12:11.820 --> 00:12:15.870
auto-release the copied block so that
it would be cleaned up correctly.

00:12:16.660 --> 00:12:19.600
Thankfully, under ARC,
blocks just work right.

00:12:19.600 --> 00:12:22.600
You don't even have to copy
them before you return them.

00:12:22.600 --> 00:12:24.460
The management all happens automatically.

00:12:24.600 --> 00:12:28.140
So the impact of ARC on how
you write code is that you

00:12:28.140 --> 00:12:30.470
just write what feels natural.

00:12:30.580 --> 00:12:34.350
You don't have to call retain, release,
or auto-release anymore.

00:12:34.750 --> 00:12:36.800
In fact, you're not allowed to.

00:12:36.850 --> 00:12:40.590
With ARC enabled,
these will generate compile errors.

00:12:40.940 --> 00:12:43.980
You don't need to implement
D-ALEC anymore either in order to

00:12:43.980 --> 00:12:46.000
clean up your object references.

00:12:46.200 --> 00:12:50.080
However, if you have malloced memory,
things like file descriptors

00:12:50.080 --> 00:12:53.280
or non-objective C objects,
you would still need to

00:12:53.280 --> 00:12:55.190
do that cleanup in D-ALEC.

00:12:55.770 --> 00:12:59.880
You can choose to use alloc init or
convenience methods to create objects.

00:13:00.010 --> 00:13:03.020
It doesn't matter which one you use.

00:13:03.530 --> 00:13:06.160
Block references work automatically.

00:13:06.170 --> 00:13:08.440
And finally,
ARC lets you really focus on what

00:13:08.440 --> 00:13:11.390
your object graph should look like,
not in policing the

00:13:11.390 --> 00:13:13.160
existence of those objects.

00:13:13.160 --> 00:13:16.710
So think about relationships
between your objects and not

00:13:16.710 --> 00:13:18.840
about their reference counts.

00:13:21.350 --> 00:13:24.150
Okay, the second thing I want to
cover is another old friend,

00:13:24.360 --> 00:13:26.800
NS Auto Release Pool.

00:13:27.200 --> 00:13:31.190
With ARC, the number of times you have to
explicitly use an auto-release

00:13:31.190 --> 00:13:33.250
pool has been reduced greatly.

00:13:33.390 --> 00:13:37.710
ARC generally doesn't require you to
deal with auto-release pools anymore,

00:13:37.710 --> 00:13:40.630
unless perhaps you're dealing
with a framework generating

00:13:40.630 --> 00:13:42.420
lots of auto-released objects.

00:13:42.510 --> 00:13:47.830
In this case,
you might want to use one in order

00:13:47.830 --> 00:13:47.830
to keep a lid on memory usage.

00:13:48.050 --> 00:13:51.560
The change here is that we're pulling
it directly into the language with a

00:13:51.560 --> 00:13:56.400
direct syntax for defining a block of
code wrapped with an auto-release pool.

00:13:56.460 --> 00:14:00.570
This is much easier, much more natural,
and a lot faster than using

00:14:00.570 --> 00:14:02.840
the NS Auto-Release Pool class.

00:14:02.910 --> 00:14:05.270
Let's take a look at an example.

00:14:05.660 --> 00:14:08.170
Here we have a while loop with an
auto-release pool around it which

00:14:08.240 --> 00:14:10.480
will periodically get drained.

00:14:10.660 --> 00:14:15.500
With ARC, the need to aggressively drain
auto-release pools is greatly reduced.

00:14:15.500 --> 00:14:18.570
The compiler and the runtime
will work together to make the

00:14:18.570 --> 00:14:20.380
management much more efficient.

00:14:20.500 --> 00:14:24.500
In fact, in a lot of cases,
retained and auto-released objects

00:14:24.500 --> 00:14:27.500
don't even end up in the pool at all.

00:14:28.690 --> 00:14:32.870
However, if you do need to wrap code with
an auto-release pool explicitly,

00:14:32.870 --> 00:14:36.410
you can do so with this simple syntax,
and that lets the compiler

00:14:36.410 --> 00:14:38.320
understand what's going on.

00:14:39.530 --> 00:14:43.240
The third big change is about
managing your object graph.

00:14:43.360 --> 00:14:46.180
Specifically,
about the issue of retain cycles.

00:14:46.390 --> 00:14:48.850
ARC will also help solve this problem.

00:14:48.880 --> 00:14:52.030
Let's use an example of
a hierarchy of objects.

00:14:52.030 --> 00:14:55.910
At the top, we have a collection object,
which might have a parent node,

00:14:55.910 --> 00:14:58.150
and that parent node has a child node.

00:14:58.160 --> 00:15:01.080
For convenience,
our child node wants to have a

00:15:01.080 --> 00:15:03.110
reference back to its parent.

00:15:04.020 --> 00:15:06.610
If this were implemented
with retained references,

00:15:06.610 --> 00:15:10.320
this would create a circular reference
between the parent and the child.

00:15:10.320 --> 00:15:12.200
So what's the problem with that?

00:15:12.200 --> 00:15:15.210
Well, if the parent is removed
from the collection,

00:15:15.210 --> 00:15:18.950
its retain count would drop,
and it would normally go away.

00:15:18.960 --> 00:15:23.210
But it doesn't because the child still
has a strong reference to the parent.

00:15:23.220 --> 00:15:25.260
So both objects would be leaked.

00:15:27.100 --> 00:15:29.230
Since they're mutually
referring to each other,

00:15:29.350 --> 00:15:33.240
neither retain count will drop to
zero and they'll never go away.

00:15:33.350 --> 00:15:36.210
In this simple example, you might say,
well, that's not a big deal since

00:15:36.210 --> 00:15:37.300
it's just two objects.

00:15:37.300 --> 00:15:41.200
But usually objects will have
references to other objects.

00:15:41.310 --> 00:15:44.590
And now this whole tree of
objects is being leaked.

00:15:45.890 --> 00:15:49.720
So a common solution to this problem is
to change the reference from the child

00:15:49.720 --> 00:15:52.600
to the parent to be a weak reference.

00:15:52.650 --> 00:15:55.680
This works fine,
but introduces the burden of making sure

00:15:55.680 --> 00:15:59.880
that that weak reference gets cleared
out correctly and doesn't end up as a

00:15:59.880 --> 00:16:02.750
dangling pointer to a deallocated object.

00:16:03.010 --> 00:16:05.860
While ARC doesn't directly
solve the retain cycle problem,

00:16:05.860 --> 00:16:08.410
it introduces a new feature that does.

00:16:08.410 --> 00:16:11.040
It's called zeroing weak references.

00:16:11.040 --> 00:16:14.950
Zeroing weak references are
similar to assigned properties.

00:16:14.950 --> 00:16:18.860
They do not increase the retain
count of the object they point to,

00:16:18.860 --> 00:16:21.520
which means they do not
form a retain cycle.

00:16:21.540 --> 00:16:24.800
Additionally,
zeroing weak references are safer

00:16:24.800 --> 00:16:29.620
than using assigned properties because
they automatically get set to nil if

00:16:29.880 --> 00:16:32.320
the pointed to object is deallocated.

00:16:32.900 --> 00:16:36.400
This prevents the reference from
turning into a dangling pointer.

00:16:36.600 --> 00:16:40.130
When combined with the automatic
management provided by ARC,

00:16:40.630 --> 00:16:45.890
zeroing weak pointers will help you
manage your retain cycles efficiently.

00:16:47.370 --> 00:16:50.500
So how do you use these
zeroing weak references?

00:16:50.530 --> 00:16:53.870
Two new property attributes
have been introduced with ARC.

00:16:54.000 --> 00:16:56.360
First,
the retain attribute changes to strong.

00:16:56.360 --> 00:16:58.980
Functionally, nothing changes here.

00:16:58.980 --> 00:17:02.380
Strong properties work exactly
like retain properties used to.

00:17:02.380 --> 00:17:04.980
Next, assign becomes weak.

00:17:04.980 --> 00:17:09.900
Weak properties are these
new zeroing weak references.

00:17:09.900 --> 00:17:13.820
Let's look at perhaps the most
stereotypical example where we can

00:17:14.140 --> 00:17:16.480
benefit from zeroing weak references.

00:17:17.300 --> 00:17:21.440
Delegates are an established
pattern of a reference to an

00:17:21.440 --> 00:17:23.770
object that's not retained.

00:17:24.260 --> 00:17:27.900
These are commonly specified
as properties using a sign,

00:17:27.960 --> 00:17:30.180
meaning that they don't get retained.

00:17:30.220 --> 00:17:33.210
If you've ever had to debug a
crashing bug that turned out to

00:17:33.220 --> 00:17:37.700
be a stale delegate reference,
then this change is for you.

00:17:37.880 --> 00:17:40.180
Now just set your
delegate property to weak,

00:17:40.250 --> 00:17:44.420
and when your delegate gets deallocated,
your reference will be

00:17:44.430 --> 00:17:46.500
cleared out automatically.

00:17:48.210 --> 00:17:51.900
Let's summarize what changes
when you write code using ARC.

00:17:52.020 --> 00:17:55.300
First, retain, release,
and auto-release go away.

00:17:55.390 --> 00:17:57.950
You can purge them from your memory.

00:17:58.580 --> 00:18:02.600
NS-AutoReleasePool
becomes @AutoReleasePool,

00:18:02.600 --> 00:18:06.490
with direct support in
the language syntax.

00:18:06.490 --> 00:18:12.500
Retain properties become strong,
and assign properties become weak.

00:18:13.850 --> 00:18:15.790
Next up,
let's look at how you can migrate

00:18:15.790 --> 00:18:17.520
your existing projects to ARC.

00:18:17.520 --> 00:18:21.730
ARC is available in iOS 5 and in Lion.

00:18:21.730 --> 00:18:25.210
But we want you to use ARC in
your projects starting today,

00:18:25.210 --> 00:18:29.630
which is why we made it work back
in iOS 4 and Snow Leopard as well.

00:18:29.660 --> 00:18:34.150
However, zeroing weak references are
only available in iOS 5.

00:18:34.780 --> 00:18:39.090
Keep in mind that ARC is really just
automating retain and release for you.

00:18:39.090 --> 00:18:41.750
Therefore,
it's completely compatible with

00:18:41.750 --> 00:18:43.840
existing retain release code.

00:18:43.840 --> 00:18:47.470
And you can opt in or opt out
of ARC on a file by file basis

00:18:47.470 --> 00:18:49.820
by using these compiler flags.

00:18:49.920 --> 00:18:52.910
But you really should
switch to using ARC today.

00:18:52.910 --> 00:18:55.960
For new projects,
starting with Xcode 4.2,

00:18:56.070 --> 00:18:57.980
ARC is now enabled by default.

00:18:57.980 --> 00:19:01.900
You can certainly enable ARC in
existing projects as well.

00:19:01.920 --> 00:19:04.760
For that, you need to make sure
you're using the Xcode 4.2.

00:19:04.760 --> 00:19:08.430
You can also make sure you're using
the LLVM3 compiler and that you set

00:19:08.430 --> 00:19:12.320
the Objective-C automatic reference
counting build setting to Yes.

00:19:12.320 --> 00:19:16.540
And then you just need to go
through all your code and make all

00:19:16.540 --> 00:19:19.230
those changes that we talked about.

00:19:19.310 --> 00:19:22.080
Or you can use the ARC migration tool.

00:19:22.180 --> 00:19:25.000
It's supported in an Xcode 4.2.

00:19:25.060 --> 00:19:28.500
You can find it in Xcode's
Edit menu under Refactor

00:19:28.850 --> 00:19:31.610
Convert to Objective-C ARC.

00:19:31.610 --> 00:19:34.900
And it applies the changes
for you to your code.

00:19:34.990 --> 00:19:38.980
It'll remove all the calls to retain,
release, and auto-release.

00:19:39.060 --> 00:19:44.100
It'll replace NSAutoReleasePool with
the new @AutoReleasePool syntax.

00:19:44.190 --> 00:19:46.820
And it changes assigned
properties to weak,

00:19:46.820 --> 00:19:49.690
switching them to
zeroing weak references.

00:19:49.790 --> 00:19:53.270
The ARC migration tool
works in three stages.

00:19:53.490 --> 00:19:57.620
First, you select the target to convert,
and it will check to make sure your

00:19:57.740 --> 00:20:00.500
code is using existing best practices.

00:20:00.550 --> 00:20:04.120
If it finds places where you
aren't adhering to conventions,

00:20:04.120 --> 00:20:08.600
or if it finds really tricky cases that
the tool can't convert automatically,

00:20:08.680 --> 00:20:10.990
it calls them to your attention.

00:20:11.460 --> 00:20:14.310
The next step is to apply
the changes to your code.

00:20:14.520 --> 00:20:18.240
But don't worry, it won't apply any of
the changes just yet.

00:20:18.880 --> 00:20:22.360
The last step is to present
the diffs to you for review.

00:20:22.440 --> 00:20:25.840
You can see exactly what
changed and choose which files

00:20:25.840 --> 00:20:27.690
you want to have converted.

00:20:29.480 --> 00:20:32.200
For those of you who are
still supporting iOS 4,

00:20:32.270 --> 00:20:36.040
zeroing weak references aren't available,
so the migration tool will not

00:20:36.060 --> 00:20:37.770
change assigned properties to weak.

00:20:38.570 --> 00:20:44.370
Instead, it will change them to
unsafe underbar unretained.

00:20:44.620 --> 00:20:47.940
Which gives you the same unsafe
behavior that a sign did,

00:20:48.020 --> 00:20:51.090
so beware of dangling pointers.

00:20:53.050 --> 00:20:56.140
Now let's take a look at some tips
and tricks for situations you might

00:20:56.140 --> 00:20:58.950
run into when writing ARC code.

00:20:59.470 --> 00:21:01.240
First up are singletons.

00:21:01.280 --> 00:21:03.860
Some developers implement
singletons by writing their

00:21:03.950 --> 00:21:06.360
own retain and release methods.

00:21:06.390 --> 00:21:09.340
Under ARC,
you can't call or even implement

00:21:09.390 --> 00:21:11.680
retain and release anymore.

00:21:12.230 --> 00:21:16.760
Instead, you could use a shared instance
pattern and make sure your singleton

00:21:16.760 --> 00:21:18.980
objects are only initialized once.

00:21:19.130 --> 00:21:23.100
You can have a class method that hands
out a shared instance of this object.

00:21:23.140 --> 00:21:26.160
This shared instance is
stored in a static variable,

00:21:26.220 --> 00:21:29.500
and if it hasn't been created yet,
it'll get created.

00:21:29.720 --> 00:21:34.160
If you want to make this thread safe,
you could also use DispatchOnce.

00:21:34.320 --> 00:21:39.000
DispatchOnce will make sure the block
you pass to it executes only once.

00:21:39.300 --> 00:21:42.840
Or another way to achieve a similar
effect is to simply use the fact

00:21:42.940 --> 00:21:45.730
that classes are singletons.

00:21:45.860 --> 00:21:50.310
For example, let's say you have multiple
network requests going on and want

00:21:50.310 --> 00:21:53.540
to display the network activity
indicator as long as at least one

00:21:53.540 --> 00:21:55.950
of these requests is still alive.

00:21:56.040 --> 00:21:59.220
A simple static counter
might be all you need.

00:22:00.100 --> 00:22:03.880
Ownership qualifiers allow you to tell
the compiler how it should do memory

00:22:03.880 --> 00:22:07.030
management for Objective-C types.

00:22:07.500 --> 00:22:11.090
Underbar underbar strong is the
default and will keep an object alive.

00:22:11.180 --> 00:22:17.260
Underbar underbar weak will keep a safe
reference as long as the object exists.

00:22:17.260 --> 00:22:20.270
Here's a fun example
to see ARC in action.

00:22:20.280 --> 00:22:25.020
If you were to declare a local
variable as weak and then never

00:22:25.020 --> 00:22:29.090
assign the object it points at to
something with a strong reference,

00:22:29.100 --> 00:22:31.890
it can go away immediately
after it's created.

00:22:32.180 --> 00:22:35.050
So in this example,
it will actually print

00:22:35.060 --> 00:22:39.020
null for the string because
S was only a weak reference,

00:22:39.020 --> 00:22:43.000
so the object got released and
S automatically got set to nil.

00:22:44.360 --> 00:22:49.760
There's also __unsafe_unretained,
which will be a traditional

00:22:49.760 --> 00:22:54.220
unsafe pointer reference that
is not automatically zeroed out.

00:22:54.290 --> 00:22:58.820
And lastly, there's __autoreleasing,
which can be used when

00:22:58.820 --> 00:23:01.380
passing objects by reference.

00:23:02.660 --> 00:23:06.040
Blocks can present some
difficulties with retain cycles.

00:23:06.130 --> 00:23:08.360
For example,
in Manual Reference Counting,

00:23:08.380 --> 00:23:11.470
this code has the effect
of not retaining X.

00:23:11.690 --> 00:23:16.630
In ARC, this defaults to retaining X,
just like all other objects

00:23:16.630 --> 00:23:18.850
because strong is the default.

00:23:19.540 --> 00:23:22.880
To get the manual reference
counting behavior under ARC,

00:23:22.910 --> 00:23:26.460
you could use the unsafe unretained,
but as the name implies,

00:23:26.460 --> 00:23:30.440
having a non-retained variable is
dangerous and is therefore discouraged.

00:23:30.560 --> 00:23:35.830
Two better options would be either to
use underbar underbar weak if you don't

00:23:36.170 --> 00:23:40.870
need to support iOS 4 or Snow Leopard,
or to set the block value to nil

00:23:40.870 --> 00:23:43.530
in order to break the retain cycle.

00:23:47.610 --> 00:23:50.360
Here's an advanced tip that
might not apply to you,

00:23:50.530 --> 00:23:52.860
but if it does, it's an important one.

00:23:53.020 --> 00:23:55.420
This can be pretty confusing,
but hang in there and

00:23:55.420 --> 00:23:56.900
you'll get the gist of it.

00:23:57.040 --> 00:24:01.200
ARC automates the management of
Objective-C objects and blocks.

00:24:01.320 --> 00:24:04.740
If you're using core foundation
and rely on the toll-free bridging

00:24:04.740 --> 00:24:09.470
between Objective-C and CF,
then you have to give the compiler

00:24:09.470 --> 00:24:11.810
a hand so that it knows what to do.

00:24:12.020 --> 00:24:15.420
The first case is simply to do a
cast without implying any change in

00:24:15.420 --> 00:24:18.900
ownership between CF and Objective-C.

00:24:18.970 --> 00:24:22.900
To do this, you use the underbar
underbar bridge keyword.

00:24:22.970 --> 00:24:25.900
This will just do a straight
pointer cast and nothing changes

00:24:25.900 --> 00:24:28.710
with the management of that memory.

00:24:29.650 --> 00:24:31.810
However,
there are times where you want to move

00:24:31.810 --> 00:24:36.800
an object from CF to Objective-C and
then use Objective-C conventions

00:24:36.900 --> 00:24:39.280
for managing the object's lifetime.

00:24:39.370 --> 00:24:41.760
For example,
let's say you have an object in

00:24:41.760 --> 00:24:45.980
CF that was created with one of
the various CF create functions.

00:24:46.060 --> 00:24:48.180
Ordinarily,
you might just cast this to an

00:24:48.280 --> 00:24:52.800
Objective-C object and then later
call release or auto-release on it.

00:24:52.870 --> 00:24:56.140
But with ARC,
you can't call release or auto-release,

00:24:56.200 --> 00:24:57.860
so you're kind of stuck.

00:24:58.380 --> 00:25:02.340
To satisfy the obligation,
you can use the CF bridging

00:25:02.340 --> 00:25:05.650
release function,
which will fulfill your duty on

00:25:05.650 --> 00:25:07.760
the CF side and release the object.

00:25:07.860 --> 00:25:10.840
And then at that point,
ARC will take over the

00:25:10.840 --> 00:25:12.820
ownership of that object.

00:25:13.310 --> 00:25:17.820
Conversely, you might want to take an
Objective-C object that's being managed

00:25:17.830 --> 00:25:22.720
by ARC and cast it over to a CF object,
that object managed under

00:25:22.720 --> 00:25:24.220
CF memory management rules.

00:25:24.310 --> 00:25:27.170
To do this,
you would use the corresponding

00:25:27.170 --> 00:25:31.220
CFBridgingRetain function,
which will increment the retain

00:25:31.220 --> 00:25:35.150
count of the object by one and
remove it from being managed by ARC.

00:25:35.840 --> 00:25:38.500
At this point,
the returned CF object will

00:25:38.610 --> 00:25:42.490
need to have CFRelease called
on it in order to satisfy the

00:25:42.490 --> 00:25:45.160
memory management obligations.

00:25:45.390 --> 00:25:48.690
The takeaway point here is
if you're moving objects

00:25:48.690 --> 00:25:52.000
between CF and Objective C,
you have to make sure you abide

00:25:52.000 --> 00:25:57.000
by the rules on the CF side when
moving objects back and forth.

00:25:58.120 --> 00:26:00.700
Our next tip has to do
with switch statements.

00:26:00.810 --> 00:26:03.790
Technically,
C allows you to define a variable under

00:26:03.790 --> 00:26:06.000
a case label in a switch statement.

00:26:06.270 --> 00:26:09.990
This makes it hard for the compiler to
reason about what your code is doing and

00:26:10.280 --> 00:26:12.000
when the object needs to be released.

00:26:12.000 --> 00:26:16.990
LLVM under ARC will make
you aware of this problem.

00:26:17.160 --> 00:26:20.500
A simple solution is to help the
compiler out by wrapping the body of

00:26:20.500 --> 00:26:22.860
a case statement with curly braces.

00:26:23.020 --> 00:26:27.400
This makes it clear what the expected
scope of the local variable is.

00:26:28.760 --> 00:26:32.800
Under ARC, you also can't put object
references in C structures.

00:26:32.890 --> 00:26:36.120
Instead of using a
simple C structure here,

00:26:36.290 --> 00:26:39.730
consider a full-fledged
Objective-C object.

00:26:41.350 --> 00:26:44.820
If you end up mixing and
matching ARC and non-ARC code,

00:26:45.200 --> 00:26:48.030
you need to be careful with method names.

00:26:48.190 --> 00:26:52.280
ARC expects the usual Cocoa naming
conventions to be followed.

00:26:52.440 --> 00:26:57.320
This is especially important for methods
that transfer ownership of objects.

00:26:57.510 --> 00:27:00.850
For example,
if this serial method were compiled with

00:27:00.850 --> 00:27:05.660
ARC and then called by non-ARC code,
the compiler will return

00:27:05.660 --> 00:27:07.620
an auto-released object.

00:27:07.950 --> 00:27:12.230
And this new serial method would
return a retained object because

00:27:12.230 --> 00:27:17.120
the method name begins with "new."
This is also why you can't have

00:27:17.200 --> 00:27:19.510
properties that begin with "new."

00:27:19.800 --> 00:27:23.210
The important point here is that if
you're mixing and matching worlds,

00:27:23.210 --> 00:27:25.540
you need to be careful and
play by the rules of the

00:27:25.610 --> 00:27:30.160
conventions on the non-ARC side,
because that's what the compiler

00:27:30.260 --> 00:27:31.850
will do on the ARC side.

00:27:33.010 --> 00:27:36.740
Lastly, let's talk a little
bit about performance.

00:27:36.830 --> 00:27:40.050
We've put a lot of effort into
making ARC as efficient as possible,

00:27:40.050 --> 00:27:43.250
and we've tuned up the
Objective-C runtime for ARC.

00:27:43.380 --> 00:27:49.050
First, the retain-release implementation
on NSObject now only takes 40% of

00:27:49.080 --> 00:27:53.280
the CPU cycles as it did before,
which is a major speed-up.

00:27:53.400 --> 00:27:58.240
Secondly, the new at-autorelease-pool
syntax is much faster than the

00:27:58.240 --> 00:28:00.720
old NSAutorelease-pool class.

00:28:01.180 --> 00:28:03.650
It's not actually allocating
an object anymore,

00:28:03.650 --> 00:28:07.820
and it now only takes about
20% of the CPU cycles than it

00:28:07.900 --> 00:28:09.460
did with NSAutorelease-pool.

00:28:09.480 --> 00:28:13.720
Third, it's common practice in
Cocoa to return auto-released

00:28:13.720 --> 00:28:15.840
objects from getter methods.

00:28:15.940 --> 00:28:20.300
This frequently means the returned object
stays around longer than it's needed,

00:28:20.300 --> 00:28:23.120
until the current
auto-release-pool goes away.

00:28:23.180 --> 00:28:26.470
Since the compiler and runtime
were co-designed for ARC,

00:28:26.470 --> 00:28:29.910
this enables a number of
really amazing optimizations.

00:28:31.180 --> 00:28:34.700
The runtime and compiler know
when you are in an ARC method,

00:28:34.710 --> 00:28:36.970
returning an object back to ARC code.

00:28:37.180 --> 00:28:40.120
In this case,
the runtime avoids putting that object

00:28:40.120 --> 00:28:41.980
in the auto-release-pool at all.

00:28:42.180 --> 00:28:45.280
So this is a nice performance win.

00:28:45.380 --> 00:28:49.170
The cost of doing these auto-released
getters when the optimization

00:28:49.170 --> 00:28:53.080
kicks in is now only 5% of the
CPU cycles that it used to be.

00:28:53.120 --> 00:28:56.710
And additionally,
all these objects are managed by ARC,

00:28:56.820 --> 00:28:59.600
so they go away as soon as
they're no longer needed,

00:28:59.600 --> 00:29:03.540
which also reduces the high watermark
for memory usage in your apps.

00:29:06.100 --> 00:29:08.800
Well, that's a whole lot of
information about ARC.

00:29:08.860 --> 00:29:12.540
To recap, now you know what ARC is,
how it makes your apps much

00:29:12.540 --> 00:29:16.440
more stable by reducing leaks
and eliminating crashes.

00:29:16.570 --> 00:29:19.920
You've seen how writing ARC code
means writing less code,

00:29:19.990 --> 00:29:24.130
leaving you with more natural
and more maintainable code.

00:29:24.290 --> 00:29:28.720
You've seen how you can migrate your
apps to ARC with the ARC Migration Tool.

00:29:28.850 --> 00:29:30.960
And we've talked about
a few tips and tricks,

00:29:31.070 --> 00:29:35.500
and have seen some data about ARC's
amazing performance improvements.

00:29:36.180 --> 00:29:38.810
Automatic reference counting
is one of the most exciting

00:29:38.860 --> 00:29:43.540
things to happen in Objective-C,
and I hope you embrace it starting today.

00:29:43.640 --> 00:29:45.880
By doing so,
you'll be well along the path

00:29:45.880 --> 00:29:50.980
towards more robust code that
doesn't leak and crashes a lot less.

00:29:51.070 --> 00:29:53.540
If you're already familiar
with manual reference counting,

00:29:53.640 --> 00:29:57.590
it might feel a little funny at first,
but you'll quickly shed the burdens

00:29:57.590 --> 00:30:01.140
of having to worry about retain,
release, and auto-release.

00:30:01.220 --> 00:30:03.070
If you're just starting
off with Objective-C,

00:30:03.380 --> 00:30:07.780
then definitely stick with
ARC and you'll be in great shape.

00:30:07.910 --> 00:30:10.510
Either way,
I'm positive you'll be very happy

00:30:10.510 --> 00:30:12.720
with the results ARC will give you.
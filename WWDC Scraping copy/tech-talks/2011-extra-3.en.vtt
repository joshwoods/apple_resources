WEBVTT

00:00:08.980 --> 00:00:13.240
Hi, I'm Nitin Mishrha from Apple's
Worldwide Developer Relations team.

00:00:13.250 --> 00:00:16.340
In this video,
you'll learn about two great technologies

00:00:16.360 --> 00:00:21.240
you can implement to add value and
functionality to your iOS applications.

00:00:21.270 --> 00:00:25.250
This session is designed to teach you
about the architecture and implementation

00:00:25.250 --> 00:00:29.540
steps for adding notifications
and in app purchases to your apps.

00:00:29.640 --> 00:00:32.010
You'll find this video
divided into two halves,

00:00:32.090 --> 00:00:36.340
with the first half focusing on push
and local notifications and the second

00:00:36.340 --> 00:00:38.840
half diving into in app purchases.

00:00:38.840 --> 00:00:40.920
All throughout,
we'll highlight the critical

00:00:41.120 --> 00:00:44.260
steps for feature implementation,
as well as cover best practices and

00:00:44.540 --> 00:00:48.100
some common gotchas to help simplify
your implementation experience

00:00:48.400 --> 00:00:50.940
with these two exciting features.

00:00:51.020 --> 00:00:53.710
Let's start the day
discussing notifications,

00:00:53.790 --> 00:00:58.460
which can include both push
notifications or local notifications.

00:00:58.460 --> 00:01:01.370
Both of these are ways for an
application that isn't running in

00:01:01.520 --> 00:01:05.840
the foreground to let its users
know that it has something for them.

00:01:05.840 --> 00:01:09.910
At its core, notifications are simply a
virtual tap on the shoulder,

00:01:10.130 --> 00:01:14.590
telling your users that your application
has some piece of data waiting for them.

00:01:14.660 --> 00:01:17.980
That tap could be a message,
an impending calendar event,

00:01:17.980 --> 00:01:21.280
or some new data on a remote server.

00:01:21.320 --> 00:01:25.300
Notifications allow applications that
operate in a time-sensitive environment,

00:01:25.300 --> 00:01:28.120
where events of interest to
users can occur at any time,

00:01:28.280 --> 00:01:30.970
to notify those users
when these events occur,

00:01:31.540 --> 00:01:34.080
even if the app isn't running.

00:01:37.880 --> 00:01:40.900
To get a good idea of what
notifications can be used for,

00:01:40.920 --> 00:01:43.680
let's take a look at some of the
apps on the store that are really

00:01:43.680 --> 00:01:45.880
leveraging notifications in a great way.

00:01:45.900 --> 00:01:49.020
Notifications can be used
in many different ways,

00:01:49.020 --> 00:01:52.280
and one of those most common
uses for Push is to deliver

00:01:52.280 --> 00:01:54.160
breaking events to users.

00:01:54.180 --> 00:01:58.200
This can be news, sports scores,
activities in your area,

00:01:58.200 --> 00:02:00.250
or anything of that nature.

00:02:01.400 --> 00:02:04.890
Here we see how ESPN is using
Push notifications to keep

00:02:04.890 --> 00:02:09.290
users aware of a sporting event,
and by acting on that notification,

00:02:09.600 --> 00:02:13.250
users are taken right into
the game they're following.

00:02:14.110 --> 00:02:16.850
Another use of notifications
is to keep users aware of

00:02:16.850 --> 00:02:21.110
events that might be happening,
such as game moves, instant messages,

00:02:21.300 --> 00:02:23.680
or social networking site updates.

00:02:23.800 --> 00:02:26.530
In this example,
the ng-moco team has used push

00:02:26.530 --> 00:02:29.840
notifications to let the user
know that they have a pending

00:02:29.840 --> 00:02:33.710
move to make in a game they're
playing with some friends online.

00:02:34.540 --> 00:02:37.320
In our last example,
we can see how notifications

00:02:37.320 --> 00:02:41.130
can be used to remind the user
of an action they scheduled,

00:02:41.130 --> 00:02:42.820
even if they're not in that application.

00:02:42.820 --> 00:02:46.260
Here we see that the user
is busy playing a game,

00:02:46.310 --> 00:02:49.730
but wanted to be reminded when their
favorite online radio show was set

00:02:49.730 --> 00:02:51.430
to begin so they could record it.

00:02:52.220 --> 00:02:54.690
So as you can see,
there are a number of scenarios in

00:02:54.710 --> 00:02:58.120
which notifications can be used to
really add value to your customer's

00:02:58.120 --> 00:02:59.960
experience with your application.

00:02:59.960 --> 00:03:03.190
Let's take a look in more
depth at what you can do to add

00:03:03.240 --> 00:03:05.320
notifications to your application.

00:03:07.360 --> 00:03:09.760
To begin,
let's take a look at the different

00:03:09.760 --> 00:03:11.980
features of notifications.

00:03:12.070 --> 00:03:16.550
The first feature is that you can specify
which events are important to your app

00:03:16.990 --> 00:03:21.680
and one of three types of notifications
you can associate with these events.

00:03:21.740 --> 00:03:25.200
You can specify either a badge,
which is displayed on

00:03:25.200 --> 00:03:29.860
your application icon,
an alert box, which can display a message

00:03:29.940 --> 00:03:33.920
string of your choosing,
or lastly, a sound file.

00:03:34.370 --> 00:03:36.700
When you're choosing your
types of notifications,

00:03:36.930 --> 00:03:39.700
use badges for actionable information.

00:03:39.870 --> 00:03:43.130
This is really helpful for users
and it's less disruptive than some

00:03:43.130 --> 00:03:45.200
of the other notification methods.

00:03:45.200 --> 00:03:47.690
When you want to use alerts,
only send messages

00:03:47.710 --> 00:03:49.200
that are worth knowing.

00:03:49.200 --> 00:03:53.200
Don't send non-essential
information or advertising.

00:03:53.200 --> 00:03:57.020
And lastly, when you're using sounds,
you should really use a distinct

00:03:57.020 --> 00:04:00.080
and short sound to really get
the user's attention and know

00:04:00.080 --> 00:04:02.200
which application is calling them.

00:04:03.360 --> 00:04:07.650
The second feature of notifications
is that they are delivered whether

00:04:07.650 --> 00:04:09.120
your app is running or not.

00:04:09.250 --> 00:04:13.390
So your application can be closed and
the user can be doing anything else

00:04:13.460 --> 00:04:17.450
with the device or the device can be
turned off and those notifications

00:04:17.470 --> 00:04:19.830
will still attempt to be delivered.

00:04:20.220 --> 00:04:24.020
And lastly, along those lines,
is that notifications are a great

00:04:24.020 --> 00:04:27.350
way of preserving battery life,
especially when compared to the

00:04:27.470 --> 00:04:30.780
alternative of having your app
continuously run in the background.

00:04:30.780 --> 00:04:34.530
With notifications,
you get all that functionality of

00:04:34.530 --> 00:04:38.390
a background app without having
to use any additional CPU cycles,

00:04:38.410 --> 00:04:41.530
so you're really saving
your user's battery life.

00:04:42.390 --> 00:04:45.600
When we discuss notifications,
it's important to understand

00:04:45.600 --> 00:04:49.540
that there are two different
notification methods your app can use.

00:04:49.670 --> 00:04:52.500
The first method is push notifications.

00:04:52.640 --> 00:04:56.370
Push notifications are events
that are sent from a remote server

00:04:56.510 --> 00:05:01.290
to your application through the
Apple Push Notification service.

00:05:02.100 --> 00:05:05.670
The content which you send in
a push notification originates

00:05:05.670 --> 00:05:10.120
from this content server which
is outside of your application.

00:05:10.370 --> 00:05:14.200
The other type of notification
method is local notifications.

00:05:14.350 --> 00:05:18.200
Local notifications don't require
any server infrastructure,

00:05:18.350 --> 00:05:22.740
as the events themselves originate
from within the application.

00:05:23.880 --> 00:05:27.900
Let's take a look at how these two
notification methods are similar.

00:05:28.000 --> 00:05:31.560
You'll notice that both
push notifications and local

00:05:31.560 --> 00:05:34.100
notifications look identical.

00:05:34.180 --> 00:05:39.090
Both can use any of the three
notification types we discussed earlier.

00:05:39.670 --> 00:05:42.380
The second similarity between
these two notification methods

00:05:42.680 --> 00:05:45.970
is that in both methods,
iOS will act directly

00:05:45.970 --> 00:05:48.390
on behalf of your app,
meaning your app doesn't

00:05:48.520 --> 00:05:51.540
need to be running for these
notifications to be delivered.

00:05:53.540 --> 00:05:57.630
There are some differences between
the two notification methods as well.

00:05:57.780 --> 00:06:00.390
The biggest and primary
difference between the two

00:06:00.700 --> 00:06:04.240
is that push notifications
originate from a remote server,

00:06:04.440 --> 00:06:08.630
whereas local notifications are
scheduled from within your app.

00:06:08.860 --> 00:06:12.610
Push notifications, therefore,
require some sort of connectivity

00:06:12.610 --> 00:06:15.190
in order to receive them,
and this can be either

00:06:15.400 --> 00:06:17.090
cellular or Wi-Fi connection.

00:06:17.100 --> 00:06:21.840
Local notifications, on the other hand,
don't require any network connectivity,

00:06:21.840 --> 00:06:25.410
since they're going to be scheduled and
fired from within the application itself.

00:06:25.500 --> 00:06:29.010
And lastly,
push notifications are single shot.

00:06:29.020 --> 00:06:31.500
Once they've been sent,
that's the end of them.

00:06:31.500 --> 00:06:33.860
You'll have to send a new push
notification if you want to

00:06:33.860 --> 00:06:35.440
repeat some sort of information.

00:06:36.250 --> 00:06:39.500
However, local notifications are
repeatable and schedule,

00:06:39.500 --> 00:06:43.210
meaning they can be set up to fire at
any time interval of your choosing.

00:06:45.940 --> 00:06:48.940
Whatever type of notification
method you choose to use,

00:06:48.970 --> 00:06:51.970
it's helpful to understand
that in either scenario,

00:06:51.970 --> 00:06:55.390
there are three main steps to
implementing notification technology.

00:06:55.400 --> 00:06:59.200
The first step is that you'll
have to build your notification,

00:06:59.200 --> 00:07:02.500
meaning you need to understand
the notification format and the

00:07:02.880 --> 00:07:04.360
contents you want to deliver.

00:07:04.360 --> 00:07:07.940
The second step is that you'll
need to send your notification.

00:07:08.820 --> 00:07:11.950
In the case of push notifications,
this means you'll need to understand

00:07:11.950 --> 00:07:15.190
how to configure your notification
server to communicate with the

00:07:15.190 --> 00:07:17.090
Apple push notification service.

00:07:17.100 --> 00:07:20.350
And in local notifications,
you'll need to understand how iOS

00:07:20.350 --> 00:07:22.590
schedules and handles notifications.

00:07:22.640 --> 00:07:26.670
Lastly, for both methods,
you'll need to understand how the

00:07:26.670 --> 00:07:31.940
device and your app will handle these
notifications once they're received.

00:07:32.010 --> 00:07:34.720
We'll talk through each of
these three steps for both

00:07:34.720 --> 00:07:36.600
types of notification methods.

00:07:36.600 --> 00:07:41.700
And to start with,
let's go with push notifications.

00:07:42.900 --> 00:07:46.750
Below you'll see the five steps that are
required if you wish to implement push

00:07:46.750 --> 00:07:49.400
notifications into your application.

00:07:49.490 --> 00:07:52.580
Let's walk through these steps for
setting up your development assets,

00:07:52.770 --> 00:07:55.700
creating your content provider,
constructing the push

00:07:55.700 --> 00:07:59.320
notification package,
delivering your notification through

00:07:59.380 --> 00:08:02.270
the Apple Push Notification Service,
and lastly,

00:08:02.280 --> 00:08:05.700
handling the notification on your device.

00:08:06.160 --> 00:08:08.340
Let's start with development preparation.

00:08:08.430 --> 00:08:12.370
These are the prerequisite items you'll
need to complete if you want your

00:08:12.370 --> 00:08:15.020
app to receive push notifications.

00:08:16.090 --> 00:08:18.520
The first thing you'll want to
do when getting started with push

00:08:18.520 --> 00:08:22.740
notifications is to go to the
iOS Developer Program Portal.

00:08:22.840 --> 00:08:25.780
This is the same place where
you obtain your iOS code signing

00:08:25.780 --> 00:08:30.580
certs and provisioning profiles
and add your development devices.

00:08:30.670 --> 00:08:33.380
In the App ID section
of the Program Portal,

00:08:33.560 --> 00:08:38.480
you'll want to enable the App ID for the
application you wish to use push with.

00:08:38.560 --> 00:08:42.250
Remember that only App IDs that
have a specific bundle identifier

00:08:42.260 --> 00:08:44.660
included can be used for push.

00:08:44.750 --> 00:08:47.320
Wildcard App IDs cannot be.

00:08:47.410 --> 00:08:51.850
Enabling your App ID for push ensures
that your bundle ID is registered

00:08:52.210 --> 00:08:57.020
and that no other developers can send
notifications to your application.

00:08:57.580 --> 00:09:00.730
After enabling your app ID,
you'll then create client

00:09:00.730 --> 00:09:03.500
SSL certificates for
each of those app IDs.

00:09:03.500 --> 00:09:08.500
These certificates will contain your
bundle identifier within them and

00:09:08.520 --> 00:09:13.490
can be used to send notifications
only to that specific application.

00:09:13.900 --> 00:09:17.150
You'll create two different
kinds of SSL certificates.

00:09:17.320 --> 00:09:21.310
The first is a development SSL cert,
which allows you to connect to

00:09:21.310 --> 00:09:23.180
the sandbox push environment.

00:09:23.300 --> 00:09:26.360
This is great and what you'll need
for testing your application prior

00:09:26.360 --> 00:09:27.840
to posting it to the app store.

00:09:27.840 --> 00:09:30.900
The second cert will be
the production SSL cert,

00:09:30.900 --> 00:09:34.610
and this will allow you to
connect your remote notification

00:09:34.970 --> 00:09:38.750
servers to the production
Apple Push notification service.

00:09:39.040 --> 00:09:42.310
Lastly, in the portal,
after you've enabled your app ID and

00:09:42.610 --> 00:09:45.980
obtained your SSL certificates,
you'll need to create and

00:09:45.980 --> 00:09:49.870
download a Push Notification
Configured Provisioning Profile.

00:09:49.900 --> 00:09:53.630
This provisioning profile will
have a special entitlement in it,

00:09:53.630 --> 00:09:57.900
allowing your application to receive
notifications from the service.

00:09:58.800 --> 00:10:02.450
So now that we have all the assets we
need for building our app and connecting

00:10:02.450 --> 00:10:06.970
it to the push notification service,
maybe we should take a step back and

00:10:06.970 --> 00:10:08.860
look at why we need to do all this.

00:10:08.860 --> 00:10:13.090
So in our last step,
we obtained a push notification

00:10:13.200 --> 00:10:15.380
provisioning profile.

00:10:15.380 --> 00:10:17.910
And we can see that it
has one of two values,

00:10:17.910 --> 00:10:21.860
APS environment development
or APS environment production.

00:10:21.880 --> 00:10:25.740
These are the special entitlements
which will signify to the device

00:10:25.740 --> 00:10:29.500
which environment it will be
receiving notifications from.

00:10:29.550 --> 00:10:33.450
By building your application with that,
your device will be ready

00:10:33.550 --> 00:10:35.320
to receive notifications.

00:10:37.220 --> 00:10:41.880
The second step is to take your
SSL certificates and use them to

00:10:41.880 --> 00:10:46.140
establish a trusted connection
between your server and the

00:10:46.140 --> 00:10:48.100
Apple Push Notification Service.

00:10:48.100 --> 00:10:52.970
The device has its own certificate,
which you don't need to worry about,

00:10:53.180 --> 00:10:56.090
but it allows itself to have its
own trusted connection as well.

00:10:56.150 --> 00:11:01.140
By using these two certificates,
we now have a trusted connection

00:11:01.140 --> 00:11:04.100
between your server and the iOS device.

00:11:05.120 --> 00:11:08.180
This allows us to send the
notification directly to it.

00:11:11.620 --> 00:11:14.800
Now that we have all the assets we need
for building our app and connecting

00:11:14.800 --> 00:11:18.050
to the push notification service,
we'll need to set up

00:11:18.080 --> 00:11:19.500
our content provider.

00:11:19.800 --> 00:11:24.590
Your provider can run on any
operating system that supports

00:11:24.590 --> 00:11:26.980
TCP/IP TLS connections.

00:11:27.540 --> 00:11:32.160
You'll install the appropriate
SSL certificate on this server,

00:11:32.180 --> 00:11:36.360
and again, you'll want to make sure the
certificate user ID matches

00:11:36.360 --> 00:11:38.560
your application's bundle ID.

00:11:38.710 --> 00:11:41.640
Otherwise, your notifications won't
be delivered properly.

00:11:41.640 --> 00:11:44.620
Finally,
you'll want to make sure you have

00:11:44.620 --> 00:11:48.600
firewall ports 2195 and 2196 open.

00:11:49.640 --> 00:11:52.930
With poking holes in these ports,
you'll be able to send your notifications

00:11:53.020 --> 00:11:57.280
to the push notification service,
as well as receive feedback information

00:11:57.280 --> 00:12:00.640
from the notification service,
which we'll discuss a bit later.

00:12:01.730 --> 00:12:05.980
So we've obtained our assets
and set up our content provider.

00:12:06.060 --> 00:12:09.870
Our next step in the implementation
process is to actually construct

00:12:10.000 --> 00:12:12.900
the notification package,
all the data you actually

00:12:12.900 --> 00:12:14.260
want to send to your users.

00:12:14.300 --> 00:12:18.620
Your notification package
consists of two objects.

00:12:18.620 --> 00:12:24.350
The first is the device token,
and the second is the message payload.

00:12:25.200 --> 00:12:29.430
Your payload has a maximum length
of 256 bytes and should only contain

00:12:29.510 --> 00:12:31.910
non-sensitive and non-critical data.

00:12:31.920 --> 00:12:34.500
Together,
these two pieces of information make

00:12:34.500 --> 00:12:38.660
up the notification package which
you'll be sending through the service.

00:12:40.610 --> 00:12:44.100
Let's take a look at each of
these two pieces in more detail.

00:12:44.240 --> 00:12:47.020
The first is the device token.

00:12:47.340 --> 00:12:51.250
The device token uniquely
identifies your device to the

00:12:51.250 --> 00:12:55.200
Apple Push Notification service,
and it is generated by the

00:12:55.200 --> 00:12:56.600
service for each device.

00:12:56.600 --> 00:13:00.520
One thing it's important to
remember is that this is different

00:13:00.670 --> 00:13:04.770
from the UDID you enter for your
device into the program portal.

00:13:04.780 --> 00:13:08.080
The UDID is a fixed value,
which doesn't change over

00:13:08.080 --> 00:13:10.110
the lifetime of your device.

00:13:10.120 --> 00:13:13.780
However, your device token for the
Push service actually can

00:13:13.810 --> 00:13:15.900
change in different scenarios.

00:13:17.500 --> 00:13:21.490
Some of those scenarios are that
your app is restored to a new device,

00:13:21.590 --> 00:13:25.520
or the same device is erased
and the app is reinstalled

00:13:25.530 --> 00:13:27.620
without restoring from iTunes.

00:13:27.780 --> 00:13:32.160
Therefore, it's important that you
call the registration API at

00:13:32.380 --> 00:13:36.460
each application launch,
and you send this to your server every

00:13:36.460 --> 00:13:39.150
time that your application launches.

00:13:39.560 --> 00:13:42.610
Therefore,
you always have the latest device

00:13:42.610 --> 00:13:44.990
token for your user's device.

00:13:45.170 --> 00:13:48.660
Lastly, don't store this token on
the disk as it can change.

00:13:48.760 --> 00:13:52.160
And remember,
the development device token

00:13:52.160 --> 00:13:55.630
you receive from the sandbox
push service is different than

00:13:55.630 --> 00:13:57.340
the production device token.

00:13:57.430 --> 00:14:00.040
So this will help you in
your debugging techniques.

00:14:00.230 --> 00:14:03.940
If you're encountering some errors,
you may be using the wrong device token.

00:14:05.250 --> 00:14:09.340
The last part of your notification
package is the message payload itself.

00:14:09.520 --> 00:14:12.680
This is the part of the notification
that contains the information you

00:14:12.680 --> 00:14:14.940
actually want to provide to the user.

00:14:15.080 --> 00:14:18.660
The payload format is strict JSON,
or Java Object Notation,

00:14:18.660 --> 00:14:22.160
though you don't need to know
any JavaScript to use it.

00:14:22.300 --> 00:14:26.620
We've chosen this format because
JSON is both human-readable and very

00:14:26.620 --> 00:14:29.160
compact versus an XML counterpart.

00:14:29.270 --> 00:14:32.400
It's great for Cocoa property
lists such as NSDate,

00:14:32.400 --> 00:14:35.160
NSString, NSDictionary, and NSNumbers.

00:14:35.210 --> 00:14:39.250
By being compact, we're able to keep the
payload overhead down,

00:14:39.250 --> 00:14:42.000
allowing you to have more room in
your notification for the actual

00:14:42.000 --> 00:14:44.710
message you want to display.

00:14:45.080 --> 00:14:48.360
Along with that,
the message payload will have an

00:14:48.360 --> 00:14:53.300
APS dictionary reserved for your sound,
badge, and alert keys.

00:14:53.380 --> 00:14:56.390
All three of these keys are optional,
so you can choose any

00:14:56.390 --> 00:14:57.880
type you want to use.

00:14:58.130 --> 00:15:01.490
In this instance,
we're using all three keys: the alert,

00:15:01.690 --> 00:15:05.020
the badge,
and the sound notification types.

00:15:05.080 --> 00:15:08.100
And that'll look like this to the user.

00:15:08.420 --> 00:15:11.570
The last part of the payload is
reserved for your application,

00:15:11.590 --> 00:15:13.810
and you can put anything in it,
such as an identifier

00:15:13.810 --> 00:15:18.340
for your notification,
as long as it follows the JSON format.

00:15:19.520 --> 00:15:21.590
Now that we've built our
notification package,

00:15:21.750 --> 00:15:24.650
we're ready to connect with the
Apple Push Notification service

00:15:24.750 --> 00:15:26.160
and deliver it to the user.

00:15:27.730 --> 00:15:32.050
To do this, we're first going to open the
connection between our content server

00:15:32.370 --> 00:15:34.990
and the Apple Push Notification
Service environment we

00:15:34.990 --> 00:15:35.900
want to push through.

00:15:35.900 --> 00:15:40.200
Each environment has its own unique
address that you'll connect to,

00:15:40.200 --> 00:15:43.240
with the development environment
having this address and the

00:15:43.260 --> 00:15:45.790
production removing Sandbox from that.

00:15:47.230 --> 00:15:51.940
It's important to remember that if you're
doing ad hoc or enterprise distributions,

00:15:52.210 --> 00:15:54.720
you're actually connecting to
the production environment.

00:15:54.720 --> 00:15:57.350
So if you have your
development certs configured,

00:15:57.660 --> 00:16:00.900
they won't work with these ad
hoc or enterprise in-house apps.

00:16:00.900 --> 00:16:04.260
It's important that you keep
your connection open across

00:16:04.420 --> 00:16:08.030
all of your notifications,
instead of opening and closing it

00:16:08.060 --> 00:16:10.500
between each notification you send.

00:16:10.500 --> 00:16:14.630
This is because the push notification
service may see this opening and

00:16:14.630 --> 00:16:17.000
closing as a denial of service attack.

00:16:17.100 --> 00:16:20.520
So as good practice,
you should just open the connection once

00:16:20.520 --> 00:16:22.600
and keep it open as long as you can.

00:16:22.600 --> 00:16:27.480
It is important to know that the server
can close the connection on error.

00:16:27.500 --> 00:16:32.190
And some of these errors include an
invalid payload length or token length,

00:16:32.330 --> 00:16:34.820
or a device token and server mismatch.

00:16:34.820 --> 00:16:39.660
So let's talk a little more about keeping
that connection open between your server

00:16:39.660 --> 00:16:42.350
and the Apple Push Notification Service.

00:16:42.360 --> 00:16:46.710
The Push Notification Service is designed
for high throughput and performance.

00:16:47.100 --> 00:16:50.100
And therefore it acts
as a streaming protocol,

00:16:50.100 --> 00:16:54.060
meaning you won't get a response
for every message you send.

00:16:54.120 --> 00:16:57.250
By using your cert,
you'll establish that trusted

00:16:57.250 --> 00:17:02.000
connection with the service,
and then you'll be able to send millions

00:17:02.000 --> 00:17:04.100
and millions of messages to your users.

00:17:04.240 --> 00:17:08.390
And because the notification service
is designed for high throughput,

00:17:08.480 --> 00:17:10.100
you won't see a response.

00:17:10.470 --> 00:17:15.240
However, you may send an invalid token,
which will sever the connection between

00:17:15.240 --> 00:17:16.100
your notification server and the service.

00:17:17.100 --> 00:17:24.080
And any notifications you have
remaining in the queue will be orphaned.

00:17:24.190 --> 00:17:29.100
The problem is, you may not know which
notification caused that error.

00:17:29.100 --> 00:17:32.970
So how are we able to identify
and make it easier for you to

00:17:32.970 --> 00:17:37.810
pick up where you left off and
send those orphaned notifications?

00:17:37.830 --> 00:17:41.880
The answer is to use the
enhanced binary interface.

00:17:41.900 --> 00:17:45.190
The enhanced binary interface is
the protocol that you'll use to

00:17:45.230 --> 00:17:47.880
send notifications to the service.

00:17:47.900 --> 00:17:51.660
For those of you who may have used
the push notification service before,

00:17:51.850 --> 00:17:54.280
you'll remember the
initial binary interface,

00:17:54.710 --> 00:17:58.250
which included your
notification payload and length,

00:17:58.520 --> 00:18:03.780
your device token and length,
as well as your command identifier.

00:18:03.780 --> 00:18:07.380
With the enhanced binary interface,
we've now added the ability

00:18:07.380 --> 00:18:11.410
for you to add a unique
identifier to your notification.

00:18:11.660 --> 00:18:15.300
And upon error,
the Apple Push notification service

00:18:15.300 --> 00:18:18.240
will return this identifier to you.

00:18:18.280 --> 00:18:20.890
Additionally,
we've added the ability to add an

00:18:20.890 --> 00:18:23.210
expiration period for a notification.

00:18:23.650 --> 00:18:25.850
Therefore,
you won't be sending information

00:18:25.850 --> 00:18:29.770
that may no longer be usable
or valuable to your users.

00:18:31.480 --> 00:18:35.300
The last step you'll do to implement
this enhanced binary interface is to

00:18:35.300 --> 00:18:39.010
update your command ID from 0 to 1.

00:18:40.410 --> 00:18:44.690
The Apple Push Notification Service also
comes with a Feedback Service,

00:18:44.800 --> 00:18:48.540
and this is populated when a user
removes your app from their device.

00:18:48.540 --> 00:18:53.830
The goal for you is to avoid sending
notifications to deleted apps,

00:18:53.830 --> 00:18:57.300
as the user won't receive them,
and it will reduce throughput

00:18:57.300 --> 00:18:59.130
through the Notification Service.

00:18:59.140 --> 00:19:03.860
The Feedback Service consists
of a queue of device tokens of

00:19:03.860 --> 00:19:10.190
users who have removed your app,
and this will include the device token,

00:19:10.190 --> 00:19:13.190
the token length, and a Unix timestamp.

00:19:13.720 --> 00:19:17.380
In order to access the feedback service,
you should open the connection

00:19:17.740 --> 00:19:21.430
with the Apple Push Notification
Service using the same certificates

00:19:21.430 --> 00:19:23.600
you use to send notifications.

00:19:23.740 --> 00:19:26.800
You'll read that information
until the connection closes,

00:19:27.100 --> 00:19:30.940
and ideally you'll be doing
this at least once a day.

00:19:31.350 --> 00:19:35.040
Each environment will have
its own unique connection URI,

00:19:35.050 --> 00:19:38.910
so you can access the development
and production environments and

00:19:39.000 --> 00:19:41.820
get the feedback for each of those.

00:19:41.860 --> 00:19:45.040
As soon as you've read
the queue of devices,

00:19:45.080 --> 00:19:47.700
it will be flushed from
this feedback service.

00:19:47.700 --> 00:19:50.360
And the next time you access it,
you'll have only new data.

00:19:51.930 --> 00:19:55.050
The last step in implementing
push notification is to handle

00:19:55.050 --> 00:19:57.240
the notification on the device.

00:19:57.380 --> 00:20:00.540
When you're handling notifications,
there are three different types

00:20:00.540 --> 00:20:02.940
of situations your user can be in.

00:20:03.080 --> 00:20:06.440
The first is that the
application isn't running.

00:20:06.570 --> 00:20:10.410
The second is that the application
is running in the foreground,

00:20:10.410 --> 00:20:14.130
or the application could be
running in the background.

00:20:14.770 --> 00:20:17.970
In order to handle notifications,
your application will

00:20:17.970 --> 00:20:19.800
have to do three things.

00:20:19.880 --> 00:20:23.500
The first is to register
for notifications.

00:20:23.590 --> 00:20:29.700
Then the second is to pass the device
token for the device to your server.

00:20:29.700 --> 00:20:34.920
And lastly, you'll need to display the
notification to the user.

00:20:35.860 --> 00:20:37.940
When you're registering
for notifications,

00:20:38.130 --> 00:20:41.200
you'll do this at your
application launch time.

00:20:41.330 --> 00:20:44.110
As we identified earlier,
you can choose from any

00:20:44.200 --> 00:20:49.710
combination of the alert message,
sound types, or badge icon.

00:20:49.830 --> 00:20:53.840
After you've defined the types of
notifications you'll want to use,

00:20:53.880 --> 00:20:58.010
you'll tell iOS that you want to
register a given app on a specific

00:20:58.010 --> 00:21:03.800
device with the push notification
service using the UIKit API.

00:21:03.820 --> 00:21:07.010
To do this,
you'll call UI Application Register for

00:21:07.010 --> 00:21:11.040
Remote Notification Types with
those three types of notifications

00:21:11.040 --> 00:21:12.800
you want your app to receive.

00:21:13.300 --> 00:21:17.720
Remember that just because you register
for a certain type of notification,

00:21:17.720 --> 00:21:20.790
it doesn't mean the user
can't turn them off.

00:21:21.970 --> 00:21:26.380
After registering, you'll implement the
registration callback.

00:21:26.460 --> 00:21:30.430
The first is the UI application
delegate did register for remote

00:21:30.490 --> 00:21:33.200
notifications with device token.

00:21:33.300 --> 00:21:36.860
This method may not get called
if the network is available,

00:21:36.860 --> 00:21:39.620
so don't consider it an error right away.

00:21:39.810 --> 00:21:43.060
At this point,
you'll get a token back for your device,

00:21:43.120 --> 00:21:45.440
and you'll have to choose a
method for sending this token

00:21:45.510 --> 00:21:47.150
back to your content provider.

00:21:47.150 --> 00:21:50.510
That method is completely up to you.

00:21:50.840 --> 00:21:54.900
The other callback you'll implement
is the Registration Error Callback.

00:21:55.060 --> 00:21:58.510
This is the UI application
delegate did fail to register

00:21:58.620 --> 00:22:00.500
for remote notifications.

00:22:00.600 --> 00:22:03.340
You'll get this callback if
your provisioning profile is

00:22:03.340 --> 00:22:06.660
not configured with the proper
APS environment entitlement.

00:22:06.690 --> 00:22:10.040
Or, you may be trying to run
this in the simulator,

00:22:10.330 --> 00:22:15.720
as the iOS simulator does not support
the ability to receive notifications.

00:22:16.250 --> 00:22:18.580
Now that you've registered
for notifications,

00:22:18.630 --> 00:22:21.290
you'll want to decide how your
app will behave when it actually

00:22:21.290 --> 00:22:22.840
receives the notification.

00:22:22.890 --> 00:22:25.950
And the first scenario is that
your application isn't running

00:22:26.300 --> 00:22:28.080
when the user receives it.

00:22:28.160 --> 00:22:30.910
In this case,
you'll call the UI application

00:22:30.920 --> 00:22:34.460
launch delegate,
"Did finish launching with the options."

00:22:34.540 --> 00:22:38.820
This is going to be called when
the user taps on the action button,

00:22:38.880 --> 00:22:42.540
or when the user unlocks the home
screen within a certain amount of

00:22:42.540 --> 00:22:45.890
seconds of receiving that notification.

00:22:46.860 --> 00:22:50.330
When you're using this,
you can use the launch options dictionary

00:22:50.410 --> 00:22:55.060
in order to set context so that whenever
a user clicks on an action button,

00:22:55.060 --> 00:23:00.300
you can take them directly to a
particular area of your application.

00:23:00.960 --> 00:23:03.960
The second situation is that
the application is already

00:23:03.960 --> 00:23:05.660
running in the foreground.

00:23:05.720 --> 00:23:08.680
And in this case,
you'll implement the UI application

00:23:08.680 --> 00:23:11.920
notification delegate did
receive remote notification.

00:23:11.920 --> 00:23:15.300
In this case,
we're not going to send a badge

00:23:15.300 --> 00:23:17.730
or an alert message to the app.

00:23:18.470 --> 00:23:23.460
However, you can do some sort of subtle
action in your application itself.

00:23:23.660 --> 00:23:26.960
Since we're not sending
an alert or a badge,

00:23:26.960 --> 00:23:32.100
you'll want to use the user info
dictionary to subtly notify the user

00:23:32.100 --> 00:23:34.370
of the event that has taken place.

00:23:34.790 --> 00:23:37.900
In this case,
we're subtly notifying them of a

00:23:37.900 --> 00:23:40.970
change in the score since they're
already in the application.

00:23:41.080 --> 00:23:44.230
The goal here is to avoid
changing the user context.

00:23:44.270 --> 00:23:46.920
Since they're already
in your application,

00:23:46.920 --> 00:23:49.730
you don't want to send
them somewhere else.

00:23:51.340 --> 00:23:54.800
One quick aside on user experience.

00:23:54.850 --> 00:23:59.310
As with anything,
you don't want to annoy your users.

00:24:03.170 --> 00:24:06.580
Therefore, use your alerts sparingly.

00:24:06.620 --> 00:24:11.610
And if you're going to use sounds,
keep them short but distinct.

00:24:11.650 --> 00:24:15.140
Ideally, you'll want to have a branded
sound file so that the user will

00:24:15.140 --> 00:24:18.520
know what application is actually
trying to send them a notification.

00:24:18.520 --> 00:24:23.480
And lastly, use badges when possible
for actionable items.

00:24:23.520 --> 00:24:28.410
They are the least intrusive and the most
informative of the notification methods.

00:24:30.640 --> 00:24:34.330
And as a point, you should always allow
your users to customize the

00:24:34.330 --> 00:24:38.450
notifications they want to receive,
especially if you have several

00:24:38.450 --> 00:24:42.950
different event types for which
you're sending notifications for.

00:24:44.110 --> 00:24:47.400
So now that we've talked about
implementing push notification,

00:24:47.470 --> 00:24:50.000
let's move on to local notifications.

00:24:50.120 --> 00:24:54.140
And as we talked about earlier,
the biggest difference here is

00:24:54.140 --> 00:24:57.910
that local notifications don't
require any remote server.

00:24:57.920 --> 00:25:01.480
Therefore,
your setup is literally three steps.

00:25:01.870 --> 00:25:05.020
Construct your notification,
deliver the notification,

00:25:05.260 --> 00:25:06.860
and handle it on the device.

00:25:08.370 --> 00:25:11.940
So let's move on to local notifications.

00:25:11.950 --> 00:25:16.170
And in our first step,
let's construct the notification.

00:25:16.630 --> 00:25:20.480
Just like remote notifications,
you can use local notifications

00:25:20.490 --> 00:25:23.330
to set badges for your event.

00:25:23.450 --> 00:25:27.000
After you've created an instance
of UI local notification,

00:25:27.140 --> 00:25:30.950
you'll use UI applications
application icon badge number

00:25:30.950 --> 00:25:33.500
property to set that badge value.

00:25:33.580 --> 00:25:37.290
This can be any positive
integer you want.

00:25:37.840 --> 00:25:41.950
Secondly, you can also send an alert
message or an alert string to

00:25:41.950 --> 00:25:44.920
your user via local notification.

00:25:44.920 --> 00:25:47.660
And to do so,
you'll want to set the alert

00:25:47.660 --> 00:25:50.260
body and alert action properties.

00:25:50.300 --> 00:25:53.920
In this scenario here,
we have an alert body that says

00:25:53.920 --> 00:25:56.120
baseball game starting now.

00:25:56.140 --> 00:26:00.330
As you can see, there's a button on it,
meaning we want there to be some action.

00:26:00.340 --> 00:26:05.890
So we set the alert action to yes,
and we set it to go watch the game.

00:26:06.310 --> 00:26:08.600
So in this local
notification alert message,

00:26:08.600 --> 00:26:11.000
we've notified the user
that the game has started,

00:26:11.000 --> 00:26:13.710
that if there's an action
for them to click on it,

00:26:13.710 --> 00:26:16.210
and they can go right
into the app itself.

00:26:17.970 --> 00:26:22.900
And lastly, you can use sounds as local
notifications as well.

00:26:22.980 --> 00:26:25.200
And these can be one
of two different types.

00:26:25.590 --> 00:26:30.300
The first is a custom sound
contained within your app bundle.

00:26:30.420 --> 00:26:34.530
To do so,
you'll use the sound name property.

00:26:43.100 --> 00:26:46.530
Secondly, you can use the default
notification sound.

00:26:46.550 --> 00:26:50.870
Either of these will work,
and they'll provide your users

00:26:50.880 --> 00:26:52.240
with the sound notification.

00:26:52.240 --> 00:26:54.920
Now that we've constructed
our notification,

00:26:55.070 --> 00:26:56.450
we'll want to deliver it.

00:26:56.560 --> 00:27:01.330
And when we deliver local notifications,
we're actually scheduling them,

00:27:01.350 --> 00:27:03.750
meaning we're setting a
time for them to go off.

00:27:03.920 --> 00:27:07.090
It's not based on a particular event.

00:27:07.150 --> 00:27:08.500
They're all time-based.

00:27:09.460 --> 00:27:14.420
So we can schedule and cancel
local notifications using the

00:27:14.420 --> 00:27:18.360
UI Application Class Method Schedule
Notification.

00:27:18.360 --> 00:27:21.000
The matching cancel call
will allow you to get rid of

00:27:21.000 --> 00:27:22.760
these notifications as well.

00:27:25.980 --> 00:27:28.960
Now that we've created the notification,
we need to set what time

00:27:28.960 --> 00:27:31.100
we want it to go off.

00:27:31.120 --> 00:27:34.100
To set the time when your
notification will appear,

00:27:34.160 --> 00:27:38.160
you'll use the Fire Date and
Time Zone properties.

00:27:38.160 --> 00:27:40.790
When dealing with these properties,
it's important to keep in

00:27:40.790 --> 00:27:42.420
mind the concept of time.

00:27:42.460 --> 00:27:46.080
If you want to schedule a
notification for one day from now,

00:27:46.140 --> 00:27:51.710
it's not necessarily 60 seconds
times 60 minutes times 24 hours,

00:27:51.810 --> 00:27:54.590
as the user could change time zones.

00:27:54.610 --> 00:27:58.770
So, instead of using this time-based
math to calculate when we

00:27:58.770 --> 00:28:03.320
want these events to go off,
let's use NSDate components instead.

00:28:03.320 --> 00:28:07.450
This will ensure that your users
are receiving these notifications

00:28:07.790 --> 00:28:13.250
at the appropriate time and not
necessarily some calculated time.

00:28:15.030 --> 00:28:17.830
Additionally,
you can use the repeat interval

00:28:17.830 --> 00:28:22.350
and repeat calendar properties to
schedule repeating notifications.

00:28:22.620 --> 00:28:25.590
Therefore,
this can be set up so that local

00:28:25.590 --> 00:28:30.090
notifications can be delivered at
any NS calendar unit component,

00:28:30.090 --> 00:28:32.800
such as every day, hour, or week.

00:28:35.360 --> 00:28:38.510
Now that we've decided the time we
want the notification to be delivered,

00:28:38.520 --> 00:28:41.160
we'll need to handle the
notification on the device.

00:28:41.160 --> 00:28:46.000
And just like with push notifications,
we have our three different scenarios.

00:28:46.020 --> 00:28:50.000
The application cannot be running,
it can be running in the foreground,

00:28:50.000 --> 00:28:53.340
or it can be one of the special apps
that are running in the background.

00:28:53.360 --> 00:28:58.340
When the application is not running,
we're going to handle the notifications

00:28:58.500 --> 00:29:02.700
just like a push notification,
meaning we'll use UI applications

00:29:02.780 --> 00:29:05.040
did finish launching with options.

00:29:05.200 --> 00:29:09.800
And again, we'll have our launch options,
and our only difference here will be the

00:29:09.800 --> 00:29:12.280
launch options local notification key.

00:29:13.870 --> 00:29:17.340
When the application is
running in the foreground,

00:29:17.400 --> 00:29:20.330
iOS is not going to set
any alerts or badges.

00:29:20.340 --> 00:29:24.300
Therefore,
it's up to you to use the User Info

00:29:24.310 --> 00:29:28.790
Dictionary to set the context
for the user so that they can

00:29:28.790 --> 00:29:31.230
subtly be notified of the event.

00:29:32.970 --> 00:29:35.630
And lastly,
you could be one of those special apps

00:29:35.630 --> 00:29:42.510
which are running in the background,
such as a voice over IP, audio, location,

00:29:42.630 --> 00:29:44.760
or a task completion process.

00:29:44.760 --> 00:29:48.750
In these situations,
you'll use the Present Local Notification

00:29:48.840 --> 00:29:52.350
Now to deliver the notification
as soon as that background

00:29:52.570 --> 00:29:54.420
event has been completed.

00:29:56.620 --> 00:29:59.040
So now that we've talked
through notifications,

00:29:59.090 --> 00:30:02.530
let's review some of the best
practices we've covered for both

00:30:02.990 --> 00:30:05.580
push and local notifications.

00:30:05.670 --> 00:30:10.120
The first is don't overwhelm
your users with notifications.

00:30:10.210 --> 00:30:15.050
Send them sparingly and only with
information they need to know.

00:30:15.330 --> 00:30:20.140
Secondly, allow users to determine the
notification events they want to receive.

00:30:20.220 --> 00:30:24.140
Give them the ability to customize
which events are important to them,

00:30:24.140 --> 00:30:27.010
and they're more likely to stay
engaged with your application.

00:30:28.770 --> 00:30:33.260
Third, make sure to send the device
token to your server on each

00:30:33.300 --> 00:30:34.700
of your application launches.

00:30:34.700 --> 00:30:39.030
This will ensure that you always
have the latest device token

00:30:39.030 --> 00:30:41.170
that your users are using.

00:30:41.530 --> 00:30:45.900
Fourth, make sure to keep the connection
open between your remote notification

00:30:45.900 --> 00:30:51.320
server and the Apple Push Notification
Service between notifications.

00:30:51.390 --> 00:30:53.980
And lastly,
remember to access the feedback

00:30:54.020 --> 00:30:58.370
service at least once a day to
avoid sending notifications to users

00:30:58.560 --> 00:31:01.040
who are no longer using your app.

00:31:03.100 --> 00:31:08.080
Now let's move on to the second half of
our session and cover in app purchase.

00:31:08.140 --> 00:31:10.600
We'll talk about the architecture
and implementation steps

00:31:10.670 --> 00:31:14.880
you'll need to understand
to share an easy implementation.

00:31:14.950 --> 00:31:19.090
In app purchase is a powerful new
feature that allows you to embed a

00:31:19.090 --> 00:31:25.270
store directly within your application
utilizing iOS's store kit framework.

00:31:26.130 --> 00:31:29.790
To begin, let's look at some examples of
some developers who are doing some

00:31:29.800 --> 00:31:32.690
great things with in app purchase.

00:31:32.810 --> 00:31:37.060
It can be used to access pro
features within your application.

00:31:37.230 --> 00:31:40.980
Here we have a popular camera app,
and they're using in app purchase

00:31:40.980 --> 00:31:45.520
to offer different lenses to really
expand the variety of pictures

00:31:45.520 --> 00:31:47.620
you can take with the application.

00:31:47.730 --> 00:31:50.420
And they've created a
beautiful storefront,

00:31:50.420 --> 00:31:53.830
which you can see is really
compelling for the users.

00:31:54.470 --> 00:31:59.560
Another example of how in app purchase
can be used is as in game currency.

00:31:59.660 --> 00:32:03.350
Here we have We Rule,
and they use in app purchase to

00:32:03.350 --> 00:32:08.090
offer in game currency to allow
users to build their farms faster

00:32:08.090 --> 00:32:09.790
and grow their crops faster.

00:32:12.280 --> 00:32:15.760
Another example of how in app
purchase can be used is to unlock

00:32:15.880 --> 00:32:18.160
services within the application.

00:32:18.270 --> 00:32:22.040
Here we have a popular
GPS navigation app.

00:32:22.130 --> 00:32:26.530
However, the developers have offered an
additional service via in app purchase,

00:32:26.530 --> 00:32:28.120
which is voice guidance.

00:32:28.180 --> 00:32:32.090
So upon making the purchase,
you're now going to get voice navigation

00:32:32.390 --> 00:32:34.800
instead of having to look at your device.

00:32:34.850 --> 00:32:37.790
Proceed to the highlighted route.

00:32:39.580 --> 00:32:42.360
In App Purchas can also be
used to offer new content.

00:32:42.600 --> 00:32:47.460
This is very popular in magazines
and newspaper applications and allows

00:32:47.460 --> 00:32:52.530
users to buy the latest edition as
they come out within the application.

00:32:52.640 --> 00:32:56.210
And just launched,
we now have Auto Renewing

00:32:56.210 --> 00:32:58.910
Content via In App Purchas.

00:32:58.910 --> 00:33:02.790
This allows you to set a time
duration for a subscription,

00:33:02.840 --> 00:33:06.550
so users can subscribe once and
receive updates to your application

00:33:06.980 --> 00:33:09.450
until that In App Purchas is consumed.

00:33:09.500 --> 00:33:09.730
Thank you.

00:33:12.120 --> 00:33:15.500
To begin, let's talk about some of the
features of in app purchase.

00:33:15.670 --> 00:33:19.840
And the first is that it uses
the built-in framework store kit.

00:33:19.990 --> 00:33:24.030
This is the payment
collection engine for iOS.

00:33:24.190 --> 00:33:28.640
The second great feature of in
app purchase is for the developer.

00:33:28.710 --> 00:33:30.340
There are several benefits for you.

00:33:30.340 --> 00:33:34.290
The first being that the app store
collects the payment for you.

00:33:34.340 --> 00:33:38.210
You don't need to set up any sort
of credit card processing system.

00:33:38.600 --> 00:33:42.550
You'll use the same infrastructure
you use for your app purchases.

00:33:42.570 --> 00:33:46.460
And secondly,
you'll receive the same great localized

00:33:46.690 --> 00:33:50.140
pricing and product details that you
do with your regular applications.

00:33:50.860 --> 00:33:54.080
And lastly,
you get the same great reporting in iOS.

00:33:54.100 --> 00:33:58.080
iTunes Connect as you do
for your applications.

00:34:00.040 --> 00:34:02.300
There are several
customer benefits as well.

00:34:02.510 --> 00:34:06.370
The first is that they're greeted
with a familiar purchase experience.

00:34:06.630 --> 00:34:11.080
They're using the same Apple ID and
password they use to buy everything

00:34:11.080 --> 00:34:12.930
else they do from the iTunes Store.

00:34:12.930 --> 00:34:15.600
So therefore,
they don't need to enter any

00:34:15.600 --> 00:34:19.700
payment information such as a
credit card or billing address.

00:34:19.700 --> 00:34:24.720
And lastly, they'll still get the same
App Store receipt provided via email,

00:34:24.720 --> 00:34:29.020
so they don't have to receive
anything from different vendors.

00:34:30.670 --> 00:34:33.850
Just like with notifications,
there's three primary steps

00:34:33.850 --> 00:34:36.900
to implementing in app
purchase in your applications.

00:34:36.950 --> 00:34:39.640
The first is to define your products.

00:34:39.680 --> 00:34:42.360
Secondly, you'll sell those products.

00:34:42.410 --> 00:34:47.550
And lastly, restore those products
on new devices for users.

00:34:47.760 --> 00:34:50.000
In order to implement in app purchase,
we're going to walk

00:34:50.150 --> 00:34:51.700
through these five steps.

00:34:51.760 --> 00:34:54.530
Determining product offerings,
setting up those products

00:34:54.530 --> 00:34:57.380
in iTunes Connect,
selling the products with

00:34:57.380 --> 00:35:00.900
the store kit framework,
verifying the product receipts,

00:35:00.970 --> 00:35:04.270
and lastly, restoring previous purchases.

00:35:04.670 --> 00:35:08.600
So first,
let's determine our product offerings.

00:35:08.660 --> 00:35:11.590
When we determine product offerings,
we need to figure out what

00:35:11.650 --> 00:35:15.990
we can and cannot sell within
the application itself.

00:35:16.170 --> 00:35:19.000
For example,
if we have a fitness application,

00:35:19.030 --> 00:35:22.200
we could sell videos of
different lessons and workouts.

00:35:22.200 --> 00:35:25.950
However, we couldn't sell a membership
to a gym down the street

00:35:25.950 --> 00:35:27.940
from within our application.

00:35:29.810 --> 00:35:34.190
Similarly, we could sell a digital book,
such as the Odyssey.

00:35:34.240 --> 00:35:39.560
However, our application cannot sell the
hard copy of that book itself.

00:35:39.560 --> 00:35:42.690
So, when you're thinking of the
products you want to offer,

00:35:42.690 --> 00:35:45.480
remember that they have to
be purchased and delivered

00:35:45.500 --> 00:35:47.300
within the application itself.

00:35:50.350 --> 00:35:53.580
When we talk about in app purchase,
there are four product types

00:35:53.580 --> 00:35:55.570
that you can choose from.

00:35:55.730 --> 00:35:58.050
The first is non-consumables.

00:35:58.410 --> 00:36:02.540
These are items that are purchased
once and available forever.

00:36:02.760 --> 00:36:05.130
Second, we have our consumable items.

00:36:05.500 --> 00:36:08.500
These are purchased each
time they are consumed,

00:36:08.500 --> 00:36:10.740
such as our in-game currency.

00:36:10.960 --> 00:36:13.800
Our third product type is Subscriptions.

00:36:13.900 --> 00:36:17.010
These are purchased each
time the product expires,

00:36:17.380 --> 00:36:20.800
such as our magazine each
edition buying a new one.

00:36:20.800 --> 00:36:24.780
And lastly, we have our new
Auto Renewable Subscriptions.

00:36:24.960 --> 00:36:28.790
These are purchased at the end
of each product duration period.

00:36:30.330 --> 00:36:32.760
After we've determined the
products we want to sell,

00:36:32.950 --> 00:36:36.070
we need to set them up in
iTunes Connect for sale.

00:36:36.080 --> 00:36:40.300
And when we're in iTunes Connect,
the first step you'll need is to

00:36:40.310 --> 00:36:44.130
make sure that you have a paid
applications contract in effect.

00:36:44.240 --> 00:36:49.870
Even if your initial application is free,
if you want to sell items from within it,

00:36:49.940 --> 00:36:52.040
you're going to need
a paid apps contract.

00:36:54.370 --> 00:36:57.140
After verifying that
contract is in effect,

00:36:57.180 --> 00:37:01.200
you'll need to create your products
list in the In App Purchases

00:37:01.200 --> 00:37:03.960
module within iTunes Connect.

00:37:04.270 --> 00:37:07.050
When you're setting up your product list,
you'll provide each of those

00:37:07.210 --> 00:37:12.000
products with a unique name,
a description, a price tier,

00:37:12.070 --> 00:37:14.640
and a unique product ID.

00:37:14.720 --> 00:37:18.270
It's important to remember that this
product ID must be unique across

00:37:18.270 --> 00:37:20.420
all of your applications and items.

00:37:20.500 --> 00:37:23.740
So even if you're selling
something similar within

00:37:23.830 --> 00:37:28.370
application A and application B,
it needs to be a separate product

00:37:28.370 --> 00:37:30.500
ID for each of those sales.

00:37:30.900 --> 00:37:34.770
Here we have an example of a developer
who is trying to sell additional

00:37:34.920 --> 00:37:37.440
game levels within their application.

00:37:37.510 --> 00:37:41.600
They provided the necessary metadata,
and now they'll ingest those into

00:37:41.600 --> 00:37:44.680
iTunes Connect for consumption.

00:37:44.870 --> 00:37:48.000
Once you've created that product
list within iTunes Connect,

00:37:48.390 --> 00:37:52.830
you can now create a test user within
iTunes Connect as well to test these

00:37:52.830 --> 00:37:54.940
purchases in the Sandbox environment.

00:37:54.940 --> 00:37:58.580
It's important to remember
this is not your Apple ID that

00:37:58.580 --> 00:38:00.580
you use to make purchases.

00:38:00.580 --> 00:38:02.850
This should be completely separate.

00:38:02.860 --> 00:38:06.280
And additionally,
because each of these test users

00:38:06.290 --> 00:38:09.930
is tied to a specific store,
you should create a separate

00:38:10.040 --> 00:38:13.860
user per country which you
wish to sell your items in.

00:38:14.700 --> 00:38:18.400
And lastly, as good practice,
make sure to sign out of your

00:38:18.400 --> 00:38:24.700
store settings on your iOS device,
especially when using the Sandbox.

00:38:24.730 --> 00:38:28.090
In order to do that,
you'll navigate to the settings and sign

00:38:28.300 --> 00:38:30.670
out of any account you're in entirely.

00:38:30.700 --> 00:38:36.700
You don't want to enter your in app test
user details into the store settings.

00:38:37.500 --> 00:38:40.490
Now that we've set up our
products in iTunes Connect,

00:38:40.620 --> 00:38:44.400
we're ready to sell these products
using the Store Kit framework.

00:38:45.270 --> 00:38:48.720
The first thing we'll need to do to
sell our products with StoreKit is

00:38:48.770 --> 00:38:52.260
to validate in app purchase access.

00:38:52.320 --> 00:38:56.410
We need to do this because installing
purchased items can be prevented

00:38:56.500 --> 00:38:59.540
via parental controls in iOS.

00:38:59.610 --> 00:39:02.810
Therefore,
we'll call the PaymentQueueClass method

00:39:03.150 --> 00:39:04.700
CanMakePayments.

00:39:04.760 --> 00:39:08.340
If we get back a value of yes,
that means in app purchases

00:39:08.340 --> 00:39:12.500
are accessible and the
user can make a purchase.

00:39:12.570 --> 00:39:15.200
Once we've determined that
they can make that purchase,

00:39:15.260 --> 00:39:19.360
we'll want to determine the sellable
products we can offer to them.

00:39:19.440 --> 00:39:22.460
And to do so,
we'll first load our potential

00:39:22.560 --> 00:39:25.000
product IDs from our app or server.

00:39:25.070 --> 00:39:28.750
And we'll take that potential
product ID list and check it

00:39:28.830 --> 00:39:33.800
with StoreKit to determine the
sellable subset of those IDs.

00:39:33.860 --> 00:39:38.880
And the sellable subset are those items
that are entered into iTunes Connect and

00:39:38.880 --> 00:39:41.770
that have been cleared through AppReview.

00:39:43.630 --> 00:39:47.320
StoreKit will give us
back one of two responses,

00:39:47.340 --> 00:39:50.640
either invalid product
identifiers or products.

00:39:50.800 --> 00:39:55.620
We'll want to build our store
display from only those sellable

00:39:55.630 --> 00:39:58.760
products in the response.products.

00:39:58.800 --> 00:40:02.440
This means that iTunes
Connect has validated that

00:40:02.560 --> 00:40:04.800
these products can be sold.

00:40:06.820 --> 00:40:10.530
After you've determined that
sellable subset of your products,

00:40:10.680 --> 00:40:12.890
you can display your store.

00:40:12.920 --> 00:40:14.890
And this is completely up to you.

00:40:14.890 --> 00:40:18.110
You can define how your
store looks and feels.

00:40:18.110 --> 00:40:23.460
And all you need to do is include those
response.products in your storefront.

00:40:23.500 --> 00:40:26.740
And additionally,
since you've already entered

00:40:26.740 --> 00:40:30.210
all of this localized
information into iTunes Connect,

00:40:30.330 --> 00:40:35.430
you can display products and
pricing in the language and currency

00:40:35.430 --> 00:40:37.990
that users are used to seeing.

00:40:38.550 --> 00:40:41.990
And the price is always based
on the user's iTunes store

00:40:42.150 --> 00:40:44.150
they're purchasing from.

00:40:44.770 --> 00:40:48.100
Now that we've built our
storefront and the user has decided

00:40:48.100 --> 00:40:51.580
they want to make a purchase,
we'll request payment.

00:40:51.790 --> 00:40:54.480
And to do so,
we'll use the SKPayment class to

00:40:54.480 --> 00:41:00.230
request that payment by first creating
a payment object and then adding

00:41:00.230 --> 00:41:02.600
that payment object to a queue.

00:41:02.840 --> 00:41:07.640
And lastly, we'll observe that payment
queue to know when the payment

00:41:07.780 --> 00:41:10.130
object has changed states.

00:41:11.370 --> 00:41:14.730
When the user is making a purchase,
they'll be presented with several

00:41:14.730 --> 00:41:17.340
different checkout process dialogues.

00:41:17.450 --> 00:41:21.300
These are going to be the same as
they receive for app purchases.

00:41:21.380 --> 00:41:25.060
They'll first be asked to
enter their account password.

00:41:25.140 --> 00:41:28.140
Next, they'll receive a purchase
confirmation dialogue,

00:41:28.160 --> 00:41:32.130
and this will show the product and price
of the item which they're purchasing

00:41:32.490 --> 00:41:35.930
in their localized string and currency.

00:41:36.400 --> 00:41:40.010
If the item has already been purchased,
they'll receive the

00:41:40.010 --> 00:41:42.100
Previous Purchase dialog.

00:41:42.250 --> 00:41:45.910
And lastly, when the payment has been
successfully processed,

00:41:46.090 --> 00:41:48.530
they'll receive a Thank You dialog.

00:41:48.670 --> 00:41:53.380
One important note is that when you're
testing in app purchases in the Sandbox,

00:41:53.510 --> 00:41:56.780
all of these dialogs will have
the environment listed on it.

00:41:57.120 --> 00:41:59.320
So this will help in your
debugging so that you can know

00:41:59.320 --> 00:42:03.300
exactly which environment you're
trying to make purchases from.

00:42:03.920 --> 00:42:06.820
Now that the customer has
made a payment for our item,

00:42:07.110 --> 00:42:09.580
we'll need to complete the transaction.

00:42:09.700 --> 00:42:12.890
And to do so, we'll call the updated
transactions method.

00:42:12.890 --> 00:42:17.760
We'll get back a transaction state
which will determine whether or not

00:42:17.760 --> 00:42:19.790
the transaction has been completed.

00:42:19.830 --> 00:42:23.110
If we get back a state
of purchased or restored,

00:42:23.110 --> 00:42:28.850
that means it was successful and we're
ready to unlock the product for the user.

00:42:29.880 --> 00:42:34.170
After you've unlocked that product,
you'll want to call Finish Transaction

00:42:34.170 --> 00:42:35.930
to complete the payment.

00:42:37.940 --> 00:42:41.280
After finishing the transaction,
you'll want to remember the

00:42:41.280 --> 00:42:44.820
product purchase and store those
purchased items for the user.

00:42:44.830 --> 00:42:47.450
And you can do this in one of two ways.

00:42:47.450 --> 00:42:53.340
You can use an NSUserDefaults class to
write a preferences file and save these

00:42:53.340 --> 00:42:55.900
to some application support directory.

00:42:55.900 --> 00:43:01.000
Or you can use the Keychain APIs and
save these purchases to a secure

00:43:01.070 --> 00:43:04.540
Keychain slice owned by the application.

00:43:05.040 --> 00:43:09.090
You can use either of these methods
to remember these product purchases.

00:43:11.120 --> 00:43:14.330
Now that we've sold our
products with StoreKit,

00:43:14.490 --> 00:43:17.000
we can verify the product receipts.

00:43:17.120 --> 00:43:20.570
In order to verify product purchases,
we'll need two items.

00:43:20.810 --> 00:43:25.730
The first is a server that you operate,
and secondly, we'll need the iTunes

00:43:25.830 --> 00:43:27.580
Receipt Validation Service.

00:43:28.000 --> 00:43:31.460
You may already have a server up
and running to store your product

00:43:31.480 --> 00:43:35.610
IDs or managing your user accounts,
so you can use that same server

00:43:35.840 --> 00:43:38.710
for verifying product purchases.

00:43:38.760 --> 00:43:40.740
This step is completely optional.

00:43:40.780 --> 00:43:44.940
You don't need to verify product
receipts if you're not ready to.

00:43:45.010 --> 00:43:48.870
In order to verify product purchases,
you'll first need to check

00:43:48.870 --> 00:43:50.740
the transaction receipt.

00:43:50.800 --> 00:43:56.290
Every purchase that you make will
contain a signed receipt within it.

00:43:57.040 --> 00:44:00.430
What you'll need to do is
use your application to post

00:44:00.480 --> 00:44:05.840
a Base64 encoded transaction
receipt to your remote server.

00:44:05.990 --> 00:44:09.400
Your remote server can then
verify that transaction with

00:44:09.400 --> 00:44:14.260
the iTunes service and pass the
response back to your application.

00:44:14.400 --> 00:44:18.470
Once your application has
verified a successful purchase,

00:44:18.470 --> 00:44:21.090
you can unlock the product access.

00:44:22.990 --> 00:44:26.070
Let's talk a little bit about
how you'll post that receipt

00:44:26.070 --> 00:44:28.540
to the App Store to verify it.

00:44:28.680 --> 00:44:33.000
What you'll need to do is take your
server and create a JSON object with

00:44:33.130 --> 00:44:36.040
this encoded transaction receipt.

00:44:36.160 --> 00:44:38.780
You'll post that to
the iTunes Verification

00:44:38.780 --> 00:44:40.540
Service at one of these URLs.

00:44:40.660 --> 00:44:45.610
The first is the production environment,
and the second is the sandbox.

00:44:45.950 --> 00:44:51.440
The response you'll receive back from
the iTunes Store is a JSON response.

00:44:51.590 --> 00:44:54.890
And as long as the status
of that response is zero,

00:44:54.900 --> 00:45:00.540
that means the receipt was verified
and that you can unlock the product.

00:45:00.690 --> 00:45:04.420
You can also inspect the receipt
portion of that response for

00:45:04.450 --> 00:45:08.960
additional transaction details,
such as product ID, app ID,

00:45:09.040 --> 00:45:12.420
app bundle ID, and purchase date.

00:45:13.570 --> 00:45:17.010
The last step in implementing
in app purchase is to

00:45:17.010 --> 00:45:19.400
restore previous purchases.

00:45:19.670 --> 00:45:24.330
You are required to restore subscription,
auto-renewing subscription,

00:45:24.440 --> 00:45:29.330
and non-consumable items
across all user devices.

00:45:29.980 --> 00:45:33.520
In order to restore previous purchases,
you'll first need to

00:45:33.520 --> 00:45:36.470
determine the eligible items,
such as subscription,

00:45:36.580 --> 00:45:40.500
auto-renewing subscription,
and those non-consumable items.

00:45:40.570 --> 00:45:44.100
It's recommended that you provide
a custom UI to your users,

00:45:44.170 --> 00:45:47.200
allowing them to restore all
the purchases across the device.

00:45:47.500 --> 00:45:51.590
This makes it very simple
for the user and for you.

00:45:51.820 --> 00:45:55.770
Non-consumable and auto-renewing
subscriptions can use the

00:45:55.770 --> 00:45:59.180
StoreKit Restore API to
provide these items back.

00:45:59.300 --> 00:46:02.300
And by using the restore
completed transactions,

00:46:02.300 --> 00:46:06.820
all the items a user has delivered
can be restored to a new device.

00:46:06.820 --> 00:46:09.990
All that's required is
that the customer signs in.

00:46:10.000 --> 00:46:12.690
And once they do so,
we'll process it like

00:46:12.690 --> 00:46:16.760
a successful payment,
and the user will receive the already

00:46:16.760 --> 00:46:19.200
purchased checkout dialog box.

00:46:19.650 --> 00:46:22.420
The customer will not be
charged in this instance.

00:46:22.420 --> 00:46:26.370
If you're using subscription
product types for in app purchase,

00:46:26.370 --> 00:46:30.610
you are required to provide your own
mechanism for restoring these items.

00:46:33.050 --> 00:46:37.560
Let's wrap up our discussion today with
some in app purchase best practices.

00:46:37.640 --> 00:46:42.080
The first is that the paid
applications contract is required.

00:46:42.140 --> 00:46:46.400
Even if your application is free and
you want to sell items within it,

00:46:46.470 --> 00:46:50.560
you're going to need a paid
applications contract in effect.

00:46:50.640 --> 00:46:54.180
Secondly,
your product IDs that you define must be

00:46:54.180 --> 00:46:57.480
unique across all of your applications.

00:46:57.560 --> 00:47:02.240
Thirdly, make sure to build your product
display from sellable products only,

00:47:02.290 --> 00:47:04.380
not your entire product offering.

00:47:05.700 --> 00:47:11.140
Fourth, your in app purchase test user
should not be an existing iTunes ID.

00:47:11.220 --> 00:47:16.180
You should set one up for every country
that you plan to sell your products in.

00:47:16.270 --> 00:47:19.990
And lastly,
remember to support the restoration

00:47:19.990 --> 00:47:24.600
of previous purchases across
all of your users' devices.

00:47:28.870 --> 00:47:32.560
If you need more information
on any of these topics,

00:47:32.610 --> 00:47:36.840
you can contact Bill Dudney,
the Applications Frameworks Evangelist,

00:47:36.880 --> 00:47:39.000
or consult the following documentation.

00:47:40.800 --> 00:47:43.290
In this session,
we've covered two great features

00:47:43.420 --> 00:47:46.180
that you can start incorporating
into your iOS apps today.

00:47:46.180 --> 00:47:50.360
By following the implementation steps
and best practices we've discussed,

00:47:50.450 --> 00:47:52.590
and avoiding some of
those common gotchas,

00:47:52.600 --> 00:47:56.160
you'll find your implementation
experience significantly simplified,

00:47:56.160 --> 00:47:59.680
and you'll be delivering engaging
apps to your customers in no time.
WEBVTT

00:00:22.550 --> 00:00:26.040
Hello and welcome to Adopting
iCloud Storage Part 1.

00:00:26.040 --> 00:00:29.500
I'm Michael Jurewitz,
the evangelist responsible for iCloud.

00:00:29.500 --> 00:00:33.860
iCloud Storage is a powerful
set of APIs for storing user

00:00:33.950 --> 00:00:36.490
documents and data in iCloud.

00:00:36.500 --> 00:00:39.930
By using iCloud,
you can make sure that your users' data

00:00:40.020 --> 00:00:45.450
is available on all of their devices,
providing a seamless user experience.

00:00:45.500 --> 00:00:48.110
Today,
we're going to start by taking a look at

00:00:48.110 --> 00:00:52.430
the fundamentals of working with iCloud,
so you have the information

00:00:52.430 --> 00:00:54.500
that you need to get started.

00:00:54.720 --> 00:00:58.450
Next, I'll show you how you can adopt the
Key-Value Store and UI Document in

00:00:58.450 --> 00:01:03.500
your application to start storing
settings and user documents in iCloud.

00:01:03.500 --> 00:01:05.240
So let's get started.

00:01:07.670 --> 00:01:12.430
Now today, I want to make sure that you
have the information you need to

00:01:12.430 --> 00:01:15.600
adopt iCloud in your application.

00:01:15.600 --> 00:01:17.590
So to do that,
we're going to break things

00:01:17.800 --> 00:01:19.600
up into three different parts.

00:01:19.600 --> 00:01:23.600
First, we're going to take a look at the
fundamentals of working with iCloud.

00:01:23.600 --> 00:01:27.390
Next, we'll talk about project setup
and how to actually set up your

00:01:27.480 --> 00:01:29.600
Xcode project to work with iCloud.

00:01:29.830 --> 00:01:33.590
And finally, we'll look specifically
at adopting iCloud.

00:01:33.600 --> 00:01:37.670
So let's get started first
with the fundamentals.

00:01:38.550 --> 00:01:41.330
Now today, all of us have many,
many devices,

00:01:41.330 --> 00:01:45.500
whether it's an iPhone in our pocket,
an iPad along with us,

00:01:45.550 --> 00:01:47.620
or even our Mac as well.

00:01:48.010 --> 00:01:51.490
And we all have data that
we really wish would just be

00:01:51.490 --> 00:01:55.740
available on all of those devices,
without us having to think about if

00:01:55.740 --> 00:01:58.780
we had copied that data to and fro.

00:01:58.830 --> 00:02:04.100
And that's exactly what iCloud
Storage is designed to help accomplish.

00:02:04.180 --> 00:02:08.960
iCloud Storage is a new
API available for App Store apps.

00:02:09.010 --> 00:02:12.260
It allows your application
to upload files and data,

00:02:12.300 --> 00:02:17.550
upload simple Key-Value data,
and it works continuously

00:02:17.550 --> 00:02:19.500
and in real time.

00:02:19.580 --> 00:02:21.900
So let's look at some fundamentals here.

00:02:21.980 --> 00:02:24.940
With your application,
anytime you're working with iCloud,

00:02:25.010 --> 00:02:28.440
you're going to have something
called a Ubiquity container.

00:02:28.490 --> 00:02:32.070
And this Ubiquity container is
where you store the files that you

00:02:32.070 --> 00:02:34.020
want to be able to move to iCloud.

00:02:34.120 --> 00:02:37.560
Now anytime you store a file
in this Ubiquity container,

00:02:37.560 --> 00:02:40.400
it automatically will
be sent up to iCloud.

00:02:40.490 --> 00:02:44.900
And anytime any other changes
come in from any other device,

00:02:45.050 --> 00:02:49.600
iCloud will see that updated file,
and it will make sure that your local

00:02:49.600 --> 00:02:53.240
application also receives that file.

00:02:53.720 --> 00:02:58.080
Now, how do we actually handle
sending these files up to iCloud?

00:02:58.270 --> 00:03:01.060
Well, for any document,
what we actually do is we

00:03:01.140 --> 00:03:03.360
break it into discrete chunks.

00:03:03.470 --> 00:03:07.490
And these discrete chunks are what
gets sent up to iCloud and becomes

00:03:07.550 --> 00:03:10.600
the representation of your document.

00:03:10.770 --> 00:03:14.030
Now, any time that you make
changes to this document,

00:03:14.030 --> 00:03:17.600
we pay attention to just the
pieces that have changed.

00:03:17.700 --> 00:03:20.860
And so we only send up
the differences to iCloud.

00:03:21.290 --> 00:03:24.420
And this basically becomes
version 2 of your document.

00:03:24.420 --> 00:03:26.580
So this is very, very efficient.

00:03:26.590 --> 00:03:31.420
It keeps us from having to send megabytes
or gigabytes of data repeatedly.

00:03:31.730 --> 00:03:35.250
But files can be large,
and files also have a lot of

00:03:35.250 --> 00:03:38.590
associated information about them,
things like their name,

00:03:38.800 --> 00:03:42.470
their modification date, their size,
their file type.

00:03:42.610 --> 00:03:47.350
And so one of the things that we
do is we actually aggressively push

00:03:47.350 --> 00:03:51.460
all of this metadata to iCloud,
so that even before your

00:03:51.610 --> 00:03:55.180
file is finished uploading,
you can already know things like

00:03:55.180 --> 00:03:59.230
the name and the modification date,
the file type, etc.

00:03:59.360 --> 00:04:00.590
from iCloud.

00:04:01.130 --> 00:04:04.820
Now, between OS X and iOS,
there are some differences

00:04:04.820 --> 00:04:07.000
worth paying attention to.

00:04:07.240 --> 00:04:10.090
First of all,
OS X is something that we call a

00:04:10.090 --> 00:04:15.150
"greedy peer." It makes sure that any
files that you store in iCloud are

00:04:15.150 --> 00:04:18.000
aggressively downloaded to that Mac.

00:04:18.000 --> 00:04:20.830
On iOS,
the situation is a little bit different.

00:04:21.240 --> 00:04:24.000
Typically,
an iOS device is more space-constrained,

00:04:24.000 --> 00:04:28.000
and so even though your
application knows all of the files

00:04:28.000 --> 00:04:31.700
that are available in iCloud,
your application will need to

00:04:31.800 --> 00:04:37.600
individually ask for specific files
to be brought down to the device.

00:04:38.750 --> 00:04:42.520
Now there's some interesting things that
we can do when you've got a document on,

00:04:42.520 --> 00:04:45.690
say, your iPhone and you
happen to have your iPad,

00:04:45.700 --> 00:04:49.140
say, in the same room and on
the same Wi-Fi network.

00:04:49.200 --> 00:04:53.080
Instead of taking that file and sending
it up to iCloud and then waiting for

00:04:53.160 --> 00:04:57.650
it to download back down to your iPad,
we can notice this situation

00:04:58.050 --> 00:05:03.720
and we'll simply copy this file
directly between these two devices.

00:05:04.430 --> 00:05:06.540
Now, as your application is
working with iCloud,

00:05:06.540 --> 00:05:09.700
I mentioned you've got this thing
called a Ubiquiti container.

00:05:09.850 --> 00:05:13.500
And this Ubiquiti container, again,
is where all of the files that you want

00:05:13.580 --> 00:05:16.780
to move to iCloud are going to be stored.

00:05:16.950 --> 00:05:19.720
Now, fundamentally,
your application needs some way of

00:05:19.720 --> 00:05:24.140
watching this Ubiquiti container and
knowing when changes happen to it,

00:05:24.140 --> 00:05:26.280
say new files showing up.

00:05:26.450 --> 00:05:31.460
And that's exactly what NS Metadata
Query is designed to help you do.

00:05:31.610 --> 00:05:35.800
So, NS Metadata Query will help you
watch that Ubiquiti container.

00:05:35.940 --> 00:05:39.700
And any time there are changes,
say like new files showing up,

00:05:39.810 --> 00:05:43.070
the Metadata Query will alert
your application and give you

00:05:43.070 --> 00:05:44.570
a chance to respond to that.

00:05:44.630 --> 00:05:49.220
Maybe you need to update your user
interface to show that to the user.

00:05:49.990 --> 00:05:52.240
So that's iCloud Storage.

00:05:52.300 --> 00:05:56.700
It really is primarily about
moving data between devices.

00:05:56.770 --> 00:06:00.820
It notifies your application of file
changes anytime you've got new content

00:06:00.820 --> 00:06:02.890
that's come in from the server.

00:06:03.040 --> 00:06:06.780
All of this works even if your
application isn't running.

00:06:06.930 --> 00:06:09.940
So if the user hasn't
launched your application,

00:06:10.050 --> 00:06:12.380
or if they hit the home button
really quickly and put your

00:06:12.380 --> 00:06:14.900
application in the background,
all of this still works.

00:06:14.900 --> 00:06:17.900
It's all handled by the OS for you.

00:06:18.900 --> 00:06:22.250
And the real goal here in all
of this is to create a seamless

00:06:22.370 --> 00:06:23.900
experience for the user.

00:06:23.900 --> 00:06:28.140
You want them to be able to pick
up any of their devices and simply

00:06:28.140 --> 00:06:32.900
have the data and settings from
your application available to them.

00:06:34.020 --> 00:06:37.920
So across the next two presentations,
we're going to split things

00:06:37.920 --> 00:06:39.700
up into four main units.

00:06:39.940 --> 00:06:43.790
First, we're going to take a look
at the Key-Value Store.

00:06:43.900 --> 00:06:47.840
Next, we're going to talk about
working with UI Document.

00:06:47.930 --> 00:06:50.180
We'll also take a look at
working with Core Data.

00:06:50.180 --> 00:06:54.180
You can actually use
Core Data with iCloud now as well.

00:06:54.360 --> 00:06:58.460
And we'll take a look at working
with individual files and data.

00:06:58.600 --> 00:07:01.040
But for the rest of this talk,
we're going to focus on the

00:07:01.220 --> 00:07:04.660
Key-Value Store and UI Document.

00:07:04.930 --> 00:07:06.860
All right, so that's fundamentals.

00:07:06.870 --> 00:07:10.650
Now, let's take a look at project setup.

00:07:11.380 --> 00:07:13.640
In getting your projects
set up to use iCloud,

00:07:13.640 --> 00:07:16.980
there are three main things
you're going to be working with:

00:07:17.050 --> 00:07:21.300
provisioning profiles, entitlements,
and Xcode.

00:07:21.440 --> 00:07:24.300
So let's talk about
provisioning profiles.

00:07:24.430 --> 00:07:27.030
Now, fundamentally,
a provisioning profile

00:07:27.030 --> 00:07:29.280
identifies your development team.

00:07:29.500 --> 00:07:33.300
It tells the system,
it tells us who you are.

00:07:33.300 --> 00:07:39.280
It also grants specific app
IDs the ability to use iCloud.

00:07:39.360 --> 00:07:42.300
Now, provisioning profiles also
do what they've always done.

00:07:42.420 --> 00:07:45.460
They define the devices
that your app can run on,

00:07:45.460 --> 00:07:49.220
and they also define your
iCloud Storage location.

00:07:49.300 --> 00:07:53.850
All of the storage space that your
applications use is going to be scoped

00:07:53.850 --> 00:07:56.290
by the team that you happen to be on.

00:07:56.300 --> 00:07:59.290
And we'll talk more
about that in a moment.

00:08:00.520 --> 00:08:04.200
Now, when it comes to entitlements,
entitlements are an important piece

00:08:04.200 --> 00:08:06.480
of the iOS security infrastructure.

00:08:06.650 --> 00:08:09.770
And they are going to be what
lets your application access

00:08:09.930 --> 00:08:12.280
its iCloud container at runtime.

00:08:12.280 --> 00:08:16.120
So basically what lets it
access that Ubiquiti container.

00:08:16.310 --> 00:08:19.460
But these entitlements
also do one extra thing.

00:08:19.630 --> 00:08:25.180
They allow you to specify the slice of
your total iCloud Storage that you want

00:08:25.530 --> 00:08:29.450
your particular app to be able to use.

00:08:29.680 --> 00:08:32.760
Now, when you want to get set up,
you do all of this through

00:08:32.760 --> 00:08:34.600
the iOS Provisioning Portal.

00:08:34.730 --> 00:08:39.120
So, you want to make sure that you go
to the iOS Provisioning Portal,

00:08:39.120 --> 00:08:42.600
that you go to the App IDs tab.

00:08:42.720 --> 00:08:47.190
Once there, you simply want to make sure
that you scroll on down the page,

00:08:47.190 --> 00:08:50.600
and for the App ID that you
want to enable for iCloud,

00:08:50.740 --> 00:08:53.400
just click the Configure button.

00:08:53.750 --> 00:08:58.880
Once you're configuring this app ID,
scroll down and make sure that

00:08:58.880 --> 00:09:03.880
you check "Enable for iCloud."
That's all you have to do.

00:09:04.030 --> 00:09:07.280
Once you're done,
simply hit the "Done" button.

00:09:07.420 --> 00:09:11.400
Then you want to make sure that you
regenerate an existing provisioning

00:09:11.400 --> 00:09:15.490
profile that uses that app ID,
or possibly go and create

00:09:15.490 --> 00:09:18.850
a new provisioning profile
that uses that app ID.

00:09:19.040 --> 00:09:22.630
Once you've done that,
simply click "Submit." And then

00:09:22.630 --> 00:09:26.240
you can either download that
provisioning profile from the website,

00:09:26.380 --> 00:09:30.850
or within Xcode from the organizer,
simply click "Refresh" and

00:09:30.850 --> 00:09:35.360
have Xcode download that
profile for you automatically.

00:09:35.770 --> 00:09:39.280
Now, once in Xcode,
there's one more build setting that you

00:09:39.280 --> 00:09:42.540
need to check to start using iCloud.

00:09:42.540 --> 00:09:46.140
So first,
select your project on the left,

00:09:46.140 --> 00:09:49.490
then select your specific
application target and make sure

00:09:49.550 --> 00:09:51.460
that you're on the Summary pane.

00:09:51.540 --> 00:09:55.460
If you scroll all the way to the bottom,
you'll find a build setting called

00:09:55.460 --> 00:09:59.460
"Enable Entitlements." When you
check "Enable Entitlements,"

00:09:59.470 --> 00:10:03.420
Xcode is going to automatically
populate a bunch of information

00:10:03.420 --> 00:10:05.600
into your application for you.

00:10:05.600 --> 00:10:08.080
Let's take a look at what this is.

00:10:08.240 --> 00:10:10.540
So you see that there are
two main entries here.

00:10:10.540 --> 00:10:15.580
There's the iCloud Key-Value
Store and the iCloud Containers.

00:10:15.620 --> 00:10:18.280
There's also this entry
for an entitlements file.

00:10:18.310 --> 00:10:22.780
Now what Xcode has actually done is
created an entitlements file for you.

00:10:22.810 --> 00:10:26.770
And these default values that you
see for the Key-Value Store and

00:10:26.770 --> 00:10:31.160
iCloud Containers are simply
based off your bundle identifier.

00:10:31.190 --> 00:10:35.760
In most cases, you can just keep this
exactly the way it is.

00:10:35.790 --> 00:10:39.700
Now in Xcode, you'll actually notice that
there is this entitlements file.

00:10:39.720 --> 00:10:42.990
And if you take a close look at it,
you'll see it's just an

00:10:42.990 --> 00:10:44.660
ordinary property list.

00:10:44.680 --> 00:10:48.120
In fact,
you can see the entries for the Key-Value

00:10:48.120 --> 00:10:50.550
Store and the iCloud Containers.

00:10:50.790 --> 00:10:55.950
Here, they're called
com.apple.developer.ubiquity_container_

00:10:55.950 --> 00:11:02.150
identifiers and
com.apple.developer.ubiquity_kv_store_

00:11:02.150 --> 00:11:03.380
identifier.

00:11:03.420 --> 00:11:05.520
Now for each of these,
you'll notice that they've got

00:11:05.630 --> 00:11:10.280
this variable on the front,
this team identifier prefix.

00:11:10.450 --> 00:11:14.670
What this does is basically looks
inside the provisioning profile that

00:11:14.740 --> 00:11:18.840
you're using to sign your application,
pulls out the unique

00:11:18.840 --> 00:11:21.990
identifier for your team,
and sticks that at the

00:11:22.110 --> 00:11:23.660
front of these settings.

00:11:23.810 --> 00:11:27.170
And in this way,
this is how we basically scope

00:11:27.190 --> 00:11:29.790
your team's storage in iCloud.

00:11:30.330 --> 00:11:32.750
So at runtime,
you'll find that your Ubiquiti

00:11:32.850 --> 00:11:35.200
container looks something like this.

00:11:35.340 --> 00:11:38.170
You've got your team
identifier on the front,

00:11:38.380 --> 00:11:40.590
followed by typically your bundle ID.

00:11:40.770 --> 00:11:45.080
In this case,
com.examplecorp.myicloudapp.

00:11:45.280 --> 00:11:49.020
And again,
this ID is going to be what defines where

00:11:49.020 --> 00:11:52.200
this app can store its iCloud documents.

00:11:53.000 --> 00:11:56.610
Now later, if I develop a second app,
maybe an app called BookNotes

00:11:56.610 --> 00:12:00.430
that also uses iCloud,
its Ubiquiti container identifier

00:12:00.430 --> 00:12:02.160
is going to be different.

00:12:02.290 --> 00:12:04.190
In this case,
it's going to end in BookNotes.

00:12:04.190 --> 00:12:09.200
So it's going to have its own unique
place to store its iCloud documents.

00:12:09.990 --> 00:12:12.160
Now you can actually do
something really cool.

00:12:12.190 --> 00:12:15.540
If you recall,
the iCloud container setting took

00:12:15.640 --> 00:12:18.080
an array of Ubiquiti identifiers.

00:12:19.280 --> 00:12:21.120
So you could add your second
app’s Ubiquiti identifier

00:12:21.200 --> 00:12:22.200
to your iCloud Storage.

00:12:23.350 --> 00:12:27.120
This has the effect of basically
extending your Ubiquiti

00:12:27.120 --> 00:12:31.940
container for your first app,
so it can access all of the files and

00:12:32.070 --> 00:12:35.190
data from that second application.

00:12:36.140 --> 00:12:39.310
If you've got a suite of apps that
you all want to be able to work

00:12:39.310 --> 00:12:43.200
together and share this information,
this is a great way to do that.

00:12:44.020 --> 00:12:47.440
All right, so that's all you have to do
to get started with iCloud

00:12:47.440 --> 00:12:48.720
in your Xcode project.

00:12:49.260 --> 00:12:53.640
Simply go to the iOS Provisioning Portal,
enable the application that

00:12:53.640 --> 00:12:56.900
you want to use iCloud,
download that provisioning profile,

00:12:56.900 --> 00:13:00.900
and check one setting in Xcode.

00:13:01.510 --> 00:13:03.080
All right, so that's project setup.

00:13:03.360 --> 00:13:05.940
Now let's take a look at adoption.

00:13:06.070 --> 00:13:11.510
And here, we're going to start by first
talking about the Key-Value Store.

00:13:12.100 --> 00:14:59.200
[Transcript missing]

00:14:59.370 --> 00:15:03.190
Well, today on iOS 5,
both stocks and weather take

00:15:03.360 --> 00:15:06.000
advantage of the Key-Value Store.

00:15:06.160 --> 00:15:09.580
Now, both of these apps are great
examples for the kinds of use

00:15:09.660 --> 00:15:12.140
cases you should be thinking about.

00:15:12.260 --> 00:15:15.020
In the case of stocks,
we're simply storing the ticker

00:15:15.020 --> 00:15:16.860
symbols the user cares about.

00:15:16.990 --> 00:15:19.390
In the case of weather,
we're just storing the

00:15:19.390 --> 00:15:21.160
cities that they care about.

00:15:21.280 --> 00:15:23.750
And if you really think about it,
this is the model of that

00:15:23.900 --> 00:15:28.930
infrequently changing data that's
perfect for the Key-Value Store.

00:15:29.150 --> 00:15:32.540
So let's take a look at
the Key-Value Store API.

00:15:32.600 --> 00:15:35.580
Now in iOS 5,
you have a new class to work with

00:15:35.700 --> 00:15:39.240
called the NSUbiquitousKeyValueStore.

00:15:39.380 --> 00:15:41.040
And anytime you want to
work with this store,

00:15:41.040 --> 00:15:45.040
you first need to make sure that you
ask the NSUbiquitousKeyValueStore

00:15:45.500 --> 00:15:47.970
for its default store.

00:15:48.460 --> 00:15:55.140
As your application is first launching,
you also want to make sure that

00:15:55.200 --> 00:16:01.640
you subscribe to the NS Ubiquitous
Key-Value Store "Did Change Externally"

00:16:01.640 --> 00:16:03.080
notification.

00:16:03.230 --> 00:16:06.650
This is going to be what lets you
know any time there's a change

00:16:06.650 --> 00:16:10.730
that's come down from the server
that you should pay attention to.

00:16:10.870 --> 00:16:13.660
As part of application launch,
and only here,

00:16:13.750 --> 00:16:18.100
you also want to make sure that you
call "Store Synchronize" after you've

00:16:18.200 --> 00:16:20.800
subscribed to this notification.

00:16:20.800 --> 00:16:24.880
This is going to be what basically
reaches out to iCloud and makes sure that

00:16:25.000 --> 00:16:29.760
you have the most up-to-date information
available to your application.

00:16:31.540 --> 00:16:35.800
So let's take a look at storing
data into the Key-Value Store.

00:16:35.820 --> 00:16:38.790
Now the first thing you need to
do is ask for the default store,

00:16:38.790 --> 00:16:41.100
just like you always do.

00:16:41.110 --> 00:16:43.630
Next,
you can simply use something like "set

00:16:43.630 --> 00:16:47.480
string for key." You'll notice this looks
a lot like the same API that you would

00:16:47.480 --> 00:16:50.180
use for something like NSUserDefaults.

00:16:50.210 --> 00:16:54.360
So we've got our recent player name,
we're saving it for the key

00:16:54.360 --> 00:16:58.140
"mjRecentPlayerNameKey," and that's it.

00:16:58.160 --> 00:17:01.800
That's going to handle storing that
string into the Key-Value Store,

00:17:01.830 --> 00:17:05.310
sending it to iCloud,
and then propagating that information

00:17:05.520 --> 00:17:08.680
out to all of the user's devices.

00:17:09.400 --> 00:17:12.730
When it comes to retrieving data,
that's also really straightforward.

00:17:12.840 --> 00:17:16.900
Again, we ask for the default store,
just like we always do.

00:17:17.040 --> 00:17:20.820
And then we simply call "string for
key" and pass in the key that we

00:17:20.820 --> 00:17:23.190
used to previously store this item.

00:17:23.320 --> 00:17:26.760
This is going to reach into the
Key-Value Store and grab the most

00:17:26.860 --> 00:17:29.580
up-to-date information that's available.

00:17:30.600 --> 00:17:33.040
Now, I mentioned before that when
your application launches,

00:17:33.040 --> 00:17:37.200
you want to make sure that you
subscribe to the NS Ubiquitous Key-Value

00:17:37.280 --> 00:17:40.200
Store Did Change Externally notification.

00:17:40.330 --> 00:17:44.450
So, what should you actually do
when this notification fires?

00:17:44.700 --> 00:17:48.960
So let's take a look at the
UpdateKVStoreItems method.

00:17:49.010 --> 00:17:51.940
Now the first thing you want to do
is take a look at the notification

00:17:51.940 --> 00:17:57.280
object that's passed into this method
and get its user info dictionary.

00:17:57.380 --> 00:18:01.880
Now within this user info dictionary is
going to be the reason for the change,

00:18:02.020 --> 00:18:05.400
basically the reason this
notification was fired.

00:18:05.440 --> 00:18:09.980
You can find that out by asking
for the object for key for the

00:18:10.000 --> 00:18:13.880
NSUbiquitousKeyValueStoreChangeReasonKey.

00:18:13.920 --> 00:18:17.400
Now the only reason that you want
to update your local state is if

00:18:17.400 --> 00:18:21.360
you've had a change come in from
the server or a change come in

00:18:21.360 --> 00:18:23.760
as a result of an initial sync.

00:18:23.800 --> 00:18:27.660
And you can pick up each of
these via the server change and

00:18:27.660 --> 00:18:30.000
the initial sync change keys.

00:18:30.030 --> 00:18:33.110
Now assuming that either one
of these was the reason for

00:18:33.110 --> 00:18:36.600
this notification being fired,
you then have the ability to figure

00:18:36.600 --> 00:18:39.800
out exactly which keys changed.

00:18:39.840 --> 00:18:43.160
That information is also in the user
info dictionary and you can look that up.

00:18:43.280 --> 00:18:49.280
via the
NSUbiquitousKeyValueStoreChangedKeysKey.

00:18:49.480 --> 00:18:52.470
Now once you have this state,
you simply want to make sure

00:18:52.470 --> 00:18:56.690
that you read in these new values
and update any local application

00:18:56.690 --> 00:18:59.280
state that you might have.

00:18:59.600 --> 00:19:02.990
So here are some tips for
working with the Key-Value Store.

00:19:03.240 --> 00:19:07.490
First, it's important to note that
there is no conflict resolution

00:19:07.500 --> 00:19:09.580
with the Key-Value Store.

00:19:09.630 --> 00:19:13.710
The last value that you store
into the Key-Value Store on any

00:19:13.710 --> 00:19:16.970
device is going to be what wins.

00:19:17.050 --> 00:19:20.220
Now this means that you need to be
a little bit smart about the values

00:19:20.220 --> 00:19:22.690
that you actually accept from iCloud.

00:19:23.050 --> 00:19:27.900
If you find that some stale value has
possibly come in from a different device,

00:19:27.910 --> 00:19:31.670
maybe you're a game and
the user is on level 10,

00:19:31.760 --> 00:19:35.900
but you see a value of level
2 coming in from iCloud,

00:19:35.960 --> 00:19:38.450
well,
you need to make sure that you don't roll

00:19:38.450 --> 00:19:40.890
back your user's progress in their game.

00:19:41.000 --> 00:19:44.340
Instead, you'll want to notice that
those values are different,

00:19:44.500 --> 00:19:47.520
take the value that you think is correct,
in this case the fact

00:19:47.520 --> 00:19:51.420
that they're on level 10,
and just write that value back

00:19:51.560 --> 00:19:53.890
out to the Key-Value Store.

00:19:54.250 --> 00:19:57.300
Now,
you can save related data in a single

00:19:57.300 --> 00:20:00.900
transaction using SetDictionaryForKey.

00:20:00.900 --> 00:20:04.420
So what this lets you do is
basically take all the keys and

00:20:04.450 --> 00:20:08.870
values that you want to save,
wrap them in their own dictionary,

00:20:08.910 --> 00:20:13.100
and then you set that dictionary
on the Key-Value Store.

00:20:13.100 --> 00:20:16.700
In this way, all of the new values are
either going to make their way

00:20:16.700 --> 00:20:18.500
up to the server or they won't.

00:20:18.640 --> 00:20:22.130
Say, for example,
if the user ran out of space.

00:20:22.370 --> 00:20:25.840
Now it's important to note
that preferences and settings

00:20:25.840 --> 00:20:28.060
should still be stored locally.

00:20:28.060 --> 00:20:31.190
You shouldn't be using the
Key-Value Store as a replacement

00:20:31.280 --> 00:20:34.340
for something like NSUserDefaults.

00:20:34.340 --> 00:20:36.600
So you want to make sure
that you're still writing

00:20:36.690 --> 00:20:40.280
things out to NSUserDefaults,
but the preferences and settings that

00:20:40.280 --> 00:20:43.950
are useful to share between devices,
you should also be saving

00:20:43.950 --> 00:20:45.900
to the Key-Value Store.

00:20:45.910 --> 00:20:48.130
So in this way,
you should be thinking of the

00:20:48.140 --> 00:20:52.280
Key-Value Store really as a transport
mechanism for these settings.

00:20:54.340 --> 00:20:56.270
All right,
so that was the Key-Value Store.

00:20:56.620 --> 00:21:00.200
Now, let's talk about UI Document.

00:21:00.970 --> 00:21:04.720
UIDoctument is all
about document storage.

00:21:04.840 --> 00:21:09.700
It's an abstract model class
for managing document data.

00:21:09.700 --> 00:21:13.320
As an abstract class,
all this means is that you subclass

00:21:13.320 --> 00:21:15.700
it to handle your storage needs.

00:21:15.920 --> 00:21:22.780
UIDoctument naturally supports files as
either flat data or as file wrappers.

00:21:23.030 --> 00:21:25.630
UIDocument does a lot for you.

00:21:25.980 --> 00:21:30.560
It automatically saves data whenever
it's appropriate and it guarantees

00:21:30.560 --> 00:21:32.860
the atomicity of these saves.

00:21:32.900 --> 00:21:38.980
UIDocument can also automatically track
changes that are made to your document

00:21:38.980 --> 00:21:41.900
via integration with NSUndoManager.

00:21:41.900 --> 00:21:46.020
UIDocument also provides asynchronous
reading and writing of your

00:21:46.090 --> 00:21:49.300
data on a background queue,
so you don't need to worry

00:21:49.300 --> 00:21:50.890
about blocking the user.

00:21:50.900 --> 00:21:54.890
UIDocument also provides
coordinated reading and writing.

00:21:54.890 --> 00:21:57.890
This is something that we'll
talk more about in Part 2.

00:21:57.900 --> 00:22:01.870
Essentially,
UIDocument provides the seamless

00:22:01.870 --> 00:22:04.160
integration with iCloud.

00:22:04.400 --> 00:22:08.900
So we're going to look at the four main
ways that you work with UIDoctument.

00:22:08.900 --> 00:22:11.700
We'll show you how to
subclass UI document,

00:22:11.770 --> 00:22:16.700
how to locate your Ubiquiti container,
how to start up your metadata query,

00:22:16.850 --> 00:22:21.050
and also how to handle the
general document lifecycle.

00:22:21.710 --> 00:22:26.100
When it comes to subclassing UI document,
it's actually incredibly straightforward.

00:22:26.100 --> 00:22:29.200
There are only two methods
that you need to implement:

00:22:29.390 --> 00:22:34.600
contents for type error and load
from contents of type error.

00:22:34.740 --> 00:22:40.090
Basically, just how to write your data
and how to read your data.

00:22:40.090 --> 00:22:40.090
That's it.

00:22:40.300 --> 00:22:44.770
So let's take a look at an example
implementation of contents for type.

00:22:44.890 --> 00:22:47.250
So first of all,
we simply want to prepare

00:22:47.250 --> 00:22:48.600
our data for archiving.

00:22:48.690 --> 00:22:53.440
So we create immutable data
and also a keyed archiver.

00:22:53.940 --> 00:22:58.200
Next, we simply want to archive
the state that we care about.

00:22:58.330 --> 00:23:00.750
In this case,
we're encoding a photo name as

00:23:00.750 --> 00:23:02.670
well as a photo description.

00:23:02.810 --> 00:23:06.740
And perhaps most importantly,
we're also archiving

00:23:06.740 --> 00:23:08.710
away a document version.

00:23:08.800 --> 00:23:12.610
Now, if you've never done any work
with document-based applications,

00:23:12.610 --> 00:23:15.800
I'm here today to tell you that
at some point in the future,

00:23:15.800 --> 00:23:19.600
you are going to want to change the
type of data that you're storing

00:23:19.950 --> 00:23:21.800
or the way that you're storing it.

00:23:21.800 --> 00:23:24.460
So actually saving off
a document version,

00:23:24.460 --> 00:23:28.800
basically what version of your
application wrote out this document,

00:23:28.800 --> 00:23:32.630
is a really useful way so
that when you read it back in,

00:23:32.970 --> 00:23:35.800
you know what should
and shouldn't be there.

00:23:35.810 --> 00:23:38.130
Now finally,
all you have to do is tell the

00:23:38.130 --> 00:23:41.670
archiver that you're finished
encoding and return the data.

00:23:41.790 --> 00:23:43.800
And UIDoctument takes care of the rest.

00:23:43.800 --> 00:23:48.310
It handles writing that data out to disk,
making sure that iCloud

00:23:48.310 --> 00:23:51.300
notices these changes,
and that all that information

00:23:51.300 --> 00:23:54.010
makes its way up to iCloud.

00:23:55.360 --> 00:23:59.210
Next, let's take a look at
Load from Contents of Type.

00:23:59.310 --> 00:24:02.780
This is basically just the
inverse of writing out your data.

00:24:02.970 --> 00:24:07.280
So all we need to do is create
a keyed unarchiver and simply

00:24:07.280 --> 00:24:11.110
initialize it with the contents
that are passed into this method.

00:24:11.230 --> 00:24:14.450
It's basically the data
that we want to read.

00:24:14.580 --> 00:24:19.230
Now you'll notice the first thing that
we do is read out that document version.

00:24:19.600 --> 00:24:24.330
That way we know exactly which contents
we should expect and which keys we

00:24:24.330 --> 00:24:27.100
should use to get those contents.

00:24:27.200 --> 00:24:30.700
So we read back out the photo name,
the photo description.

00:24:30.770 --> 00:24:35.260
We save these into instance variables
on this particular UI document.

00:24:35.400 --> 00:24:35.890
And that's it.

00:24:36.120 --> 00:24:39.970
That's all you had to do
to read your document.

00:24:40.940 --> 00:24:44.040
Now, locating your Ubiquiti container
is a very important thing when

00:24:44.040 --> 00:24:46.960
you're working with iCloud,
because this is where your

00:24:47.050 --> 00:24:48.800
iCloud documents are stored.

00:24:48.800 --> 00:24:53.400
Now, it's important to note that you will
only be able to reach this container

00:24:53.560 --> 00:24:55.790
if the user is signed into iCloud.

00:24:55.800 --> 00:24:59.770
This is basically also the way
that you have to know if iCloud

00:24:59.780 --> 00:25:01.800
is indeed available to you.

00:25:01.830 --> 00:25:06.170
The way that you determine that is
through NS File Manager's URL for

00:25:06.300 --> 00:25:08.520
Ubiquiti Container Identifier.

00:25:09.000 --> 00:25:11.710
Let's take a look at how that's used.

00:25:12.630 --> 00:25:16.420
You typically want to locate your
Ubiquiti container as part of your

00:25:16.420 --> 00:25:19.300
application launching and resuming.

00:25:19.410 --> 00:25:23.220
So here we're going to take a look at
some code as written in "Application

00:25:23.220 --> 00:25:27.600
did finish launching with options."
The first thing you want to make

00:25:27.600 --> 00:25:33.660
sure you do is call NSFileManager
URL for Ubiquiti Container Identifier.

00:25:33.800 --> 00:25:36.360
You'll notice we've passed in nil.

00:25:36.510 --> 00:25:39.590
When you pass in nil,
the APIs will automatically

00:25:39.920 --> 00:25:44.870
look at your entitlements,
pick out the topmost Ubiquiti container,

00:25:44.870 --> 00:25:47.440
and use that by default.

00:25:47.620 --> 00:25:51.690
So, NS File Manager will go off,
try to locate your Ubiquiti container,

00:25:52.010 --> 00:25:54.280
and it will turn back a value to you.

00:25:54.400 --> 00:25:59.180
This is going to be what lets you
know if iCloud is or is not enabled.

00:25:59.180 --> 00:26:02.540
If you get back a valid URL,
then you know that iCloud is

00:26:02.540 --> 00:26:06.980
there and you should continue
with your iCloud-specific setup.

00:26:07.130 --> 00:26:10.040
If you get back nil,
then you know that iCloud is

00:26:10.040 --> 00:26:14.620
not available and you want to
continue storing your data locally.

00:26:14.830 --> 00:26:18.060
Now, there's one small problem
with this approach.

00:26:18.310 --> 00:26:22.460
URL for Ubiquiti Container
Identifier can block.

00:26:22.670 --> 00:26:26.310
And I'm here to tell you,
also as the performance evangelist,

00:26:26.370 --> 00:26:30.620
you shouldn't put any blocking
code in "Application did finish

00:26:30.620 --> 00:26:34.890
launching with options." So,
you're actually going to end up writing

00:26:34.890 --> 00:26:37.370
code that looks a little more like this.

00:26:37.380 --> 00:26:41.980
In this case, we're taking advantage of
Grand Central Dispatch to have our

00:26:42.210 --> 00:26:44.620
calls to NS File Manager done ASAP.

00:26:44.620 --> 00:26:46.400
So, let's take a look.

00:26:46.620 --> 00:26:49.520
So,
the first thing we want to do is get a

00:26:49.620 --> 00:26:52.620
reference to the default global queue.

00:26:52.620 --> 00:26:57.120
And we do that simply by calling
dispatch get global queue and passing

00:26:57.120 --> 00:27:00.710
in the dispatch queue priority default.

00:27:00.970 --> 00:27:04.650
Next, we basically want to take this
call to NS File Manager and just

00:27:04.840 --> 00:27:06.700
have it executed asynchronously.

00:27:06.940 --> 00:27:11.500
So we call dispatch async,
pass in the global queue,

00:27:11.650 --> 00:27:14.940
and then also pass in a
block representing the work

00:27:14.940 --> 00:27:16.660
that we want to be done.

00:27:16.830 --> 00:27:21.190
Now, that call is going to go off and
be executed in a background thread.

00:27:21.310 --> 00:27:25.560
And once that call completes,
we want to do a dispatch

00:27:25.570 --> 00:27:30.090
async back to the main queue,
in this case the main thread.

00:27:30.210 --> 00:27:33.320
And we simply want to update
our own state with whatever

00:27:33.320 --> 00:27:35.130
the result of that call was.

00:27:35.240 --> 00:27:39.130
So here we call self,
update with Ubiquiti container,

00:27:39.130 --> 00:27:41.280
and pass in the container.

00:27:42.350 --> 00:27:47.080
Now, I mentioned before that NS Metadata
Query is what you use to discover changes

00:27:47.080 --> 00:27:51.260
that happen to your Ubiquiti container,
typically when, say,

00:27:51.260 --> 00:27:53.190
new files are coming in from iCloud.

00:27:53.200 --> 00:27:57.320
The important thing to remember is that
this Ubiquiti container is connected,

00:27:57.320 --> 00:28:00.200
essentially,
to all of a user’s different devices.

00:28:00.200 --> 00:28:05.010
And files may be created or even
deleted on different devices.

00:28:05.210 --> 00:28:10.200
And your app needs a way of
automatically discovering these changes.

00:28:10.330 --> 00:28:13.180
And that’s exactly what the
Metadata Query is designed to do.

00:28:13.230 --> 00:28:18.100
So, when setting up your Metadata Query,
there’s a few things you need to do.

00:28:18.190 --> 00:28:20.750
First and foremost,
you want to make sure that

00:28:21.030 --> 00:28:24.040
you allocant and init an
instance of NS Metadata Query.

00:28:24.200 --> 00:28:27.820
You also want to make sure
that you set up search scopes

00:28:27.900 --> 00:28:30.020
and a predicate for the query.

00:28:30.200 --> 00:28:33.100
In the case of search scopes,
you’re basically telling the query,

00:28:33.230 --> 00:28:38.200
"Where do you want it to search?"
within your Ubiquiti container.

00:28:38.200 --> 00:28:40.740
For the predicate,
you’re telling it what types of files

00:28:40.970 --> 00:28:42.200
would you like it to search for.

00:28:42.200 --> 00:28:46.190
In this case, we’re simply looking for
files that happen to have a

00:28:46.190 --> 00:28:48.200
file name that ends in .txt.

00:28:48.200 --> 00:28:51.190
So, we’re just looking for text files.

00:28:51.200 --> 00:28:54.880
Now, there are also some
notifications to subscribe to.

00:28:54.940 --> 00:28:57.200
So, let’s take a look at that.

00:28:57.750 --> 00:29:01.210
So you want to make sure that
you subscribe to the NS Metadata

00:29:01.210 --> 00:29:05.790
Query Did Finish Gathering
notification and the NS Metadata

00:29:05.910 --> 00:29:08.780
Query Did Update notification.

00:29:08.910 --> 00:29:12.660
Once you've subscribed to both of those,
you simply need to make sure

00:29:12.720 --> 00:29:14.970
that you start the query.

00:29:15.440 --> 00:29:18.880
Now, I mentioned before that we
had these search scopes.

00:29:19.000 --> 00:29:22.230
Now, you've got two different search
scopes that you can choose from.

00:29:22.490 --> 00:29:27.580
You can use the NS Metadata
Query Ubiquitous Document Scope.

00:29:27.690 --> 00:29:30.580
In this case,
this is only going to be searching within

00:29:30.580 --> 00:29:33.780
the Ubiquiti Containers Documents folder.

00:29:33.900 --> 00:29:37.450
This is just a folder that you can
create for yourself if you want.

00:29:37.640 --> 00:29:41.800
If you have things the user really
does think of as actual documents,

00:29:41.930 --> 00:29:44.800
you would store them in this folder.

00:29:44.890 --> 00:29:49.800
You also have access to the NS Metadata
Query Ubiquitous Data Scope.

00:29:49.810 --> 00:29:53.720
This tells the metadata query
to search everywhere within

00:29:53.720 --> 00:29:55.800
your Ubiquiti container.

00:29:56.170 --> 00:30:00.070
So let's take a look at the
document lifecycle of actually

00:30:00.070 --> 00:30:02.180
working with UI document.

00:30:02.290 --> 00:30:05.300
Specifically,
I'm going to show you how to create,

00:30:05.340 --> 00:30:09.970
edit, save and update your UI document.

00:30:10.320 --> 00:30:12.180
So let's take a look at creation.

00:30:12.390 --> 00:30:15.460
Now, creating a UI document is
really straightforward.

00:30:15.480 --> 00:30:20.780
Here, we've simply got our own
subclass called MJDocument,

00:30:20.810 --> 00:30:25.680
and we simply need to call Alec and
then "init with file URL," and we

00:30:25.750 --> 00:30:31.200
pass in the location on disk where we
want to eventually save this document.

00:30:31.210 --> 00:30:35.810
Now, once you've called that,
you just want to turn right back

00:30:35.880 --> 00:30:41.600
around and call "save to URL for save
operation completion handler." Now,

00:30:41.600 --> 00:30:45.720
you'll notice what I'm passing
into this particular method is

00:30:45.830 --> 00:30:50.180
"UIDocumentSaveForCreating." We are
telling our document subclass

00:30:50.200 --> 00:30:54.610
that this is the very first time
that we are saving this file.

00:30:54.830 --> 00:30:58.500
Now you'll also notice that this
method takes a completion handler.

00:30:58.690 --> 00:31:03.000
This gives you the ability to supply
your own block to have your own code

00:31:03.060 --> 00:31:05.610
executed once the save has finished.

00:31:05.700 --> 00:31:09.680
And what gets passed into this is
whether or not the save was successful,

00:31:09.680 --> 00:31:14.210
so you can do different things
depending on how that ended up.

00:31:14.790 --> 00:31:17.100
When it comes to editing
your UI document,

00:31:17.100 --> 00:31:19.820
this is where your
application adds its value.

00:31:19.890 --> 00:31:23.700
This is how the user is going to
be interacting with their document.

00:31:23.840 --> 00:31:26.700
UI document can keep
track of quite a bit,

00:31:26.920 --> 00:31:30.700
but it needs your help to track
the state of your document.

00:31:30.700 --> 00:31:35.460
For UI document to automatically
track these changes to your document,

00:31:35.460 --> 00:31:37.590
you need to provide some help.

00:31:37.700 --> 00:31:40.610
In this case,
you can do a couple of things.

00:31:40.740 --> 00:31:42.930
The first,
if you actually have operations on

00:31:42.970 --> 00:31:47.600
your document that should be undoable,
you can register those undo

00:31:47.600 --> 00:31:51.700
operations directly with
the document's undo manager.

00:31:51.810 --> 00:31:55.170
UI document will use this information
to notice any time there are

00:31:55.170 --> 00:31:58.770
changes and will automatically
mark the document as dirty,

00:31:59.170 --> 00:32:02.890
and thus eligible for automatic saving.

00:32:03.370 --> 00:32:05.260
Now,
if you have any changes that shouldn't

00:32:05.420 --> 00:32:09.460
be undoable or don't really have
a clean concept of being undoable,

00:32:09.580 --> 00:32:13.300
UIDocement has a method
called UpdateChangeCount,

00:32:13.310 --> 00:32:18.560
and you can simply pass into this
"UIDocumentChangeDone." This tells

00:32:18.560 --> 00:32:23.040
UIDocement that you made a change,
it's not something that's undoable,

00:32:23.040 --> 00:32:26.600
but the document should be
considered dirty so that possibly

00:32:26.900 --> 00:32:29.090
it can be automatically saved.

00:32:30.860 --> 00:32:35.200
Speaking of save,
save is done for you automatically.

00:32:35.400 --> 00:32:39.550
But let's say that for whatever reason
you really want to be able to save a

00:32:39.550 --> 00:32:42.000
document at a particular point in time.

00:32:42.210 --> 00:32:44.220
Well, the good news is you can do that.

00:32:44.680 --> 00:32:49.600
And you simply do that by calling "save
to URL for save operation completion

00:32:49.600 --> 00:32:54.700
handler"�� the exact same method we used
initially to create the UI document.

00:32:54.700 --> 00:32:58.980
In this case, though,
you pass in for the save operation "UI

00:32:59.030 --> 00:33:04.200
document save for overwriting"�� and
this simply tells the necessary machinery

00:33:04.200 --> 00:33:08.020
that this document already exists,
you're just providing

00:33:08.020 --> 00:33:09.800
a new version of it.

00:33:11.060 --> 00:33:14.700
Now, your UI document needs to
be able to handle updates

00:33:14.700 --> 00:33:16.900
that come in from the server.

00:33:17.030 --> 00:33:25.900
So the first thing that you need to
do is make sure that whatever class is

00:33:25.990 --> 00:33:29.390
presenting your UI document to the user,
that it has subscribed to the

00:33:29.390 --> 00:33:29.390
UI document state changed notification.

00:33:29.910 --> 00:33:31.800
Now,
when you subscribe to this notification,

00:33:31.800 --> 00:33:35.220
there's going to be a number of
different states that you have to handle.

00:33:35.460 --> 00:33:36.720
Let's talk about a few of them.

00:33:36.800 --> 00:33:41.910
The first is UIDoctuement
State Editing Disabled.

00:33:41.930 --> 00:33:44.570
Now, this state typically happens
whenever you've got a change

00:33:44.570 --> 00:33:46.800
that's coming in from the server.

00:33:46.800 --> 00:33:50.930
For a very brief period of time,
your application needs to stop the user

00:33:51.060 --> 00:33:55.760
from editing that document while the two
versions of the documents are compared.

00:33:55.810 --> 00:33:59.800
You also have UIDoctuement
State In Conflict.

00:33:59.800 --> 00:34:03.800
This is what you're going to see whenever
you have a change you've made to a local

00:34:03.800 --> 00:34:08.800
document combined with a change made to
the same document on a different device.

00:34:08.800 --> 00:34:11.640
And,
in the case that iCloud wasn't able to

00:34:11.650 --> 00:34:14.800
automatically rectify these differences.

00:34:14.800 --> 00:34:17.120
In this case,
you're going to get a copy of

00:34:17.120 --> 00:34:21.520
both of these files on disk,
and you have the opportunity to help the

00:34:21.630 --> 00:34:24.260
user pick which one they want to use.

00:34:24.520 --> 00:34:27.840
You also have
UI Document State Saving Error.

00:34:27.840 --> 00:34:30.180
This is something that you should
only typically run into if,

00:34:30.180 --> 00:34:33.590
say, the user has run out of
storage space in iCloud,

00:34:33.720 --> 00:34:37.400
in which case the OS will ask them
if they would like to purchase more.

00:34:37.400 --> 00:34:40.560
There's also UI Document State Normal.

00:34:40.780 --> 00:34:43.830
This is what you should see
a UI Document return to after

00:34:43.890 --> 00:34:47.400
you've been in an editing
disabled or a state in conflict,

00:34:47.400 --> 00:34:50.360
once both of those states have
basically run their course.

00:34:50.430 --> 00:34:54.400
This is the normal mode of
operation for a UI Document.

00:34:56.680 --> 00:35:00.140
So let's talk about some tips
for working with UI Document.

00:35:00.410 --> 00:35:03.300
First and foremost,
remember you need to make sure you

00:35:03.300 --> 00:35:09.140
call URL for Ubiquiti Container
Identifier via Dispatch Async.

00:35:09.280 --> 00:35:13.110
It's very important you
call that asynchronously.

00:35:13.310 --> 00:35:16.480
Now, when it comes to version conflicts,
you want to make sure you

00:35:16.610 --> 00:35:17.880
handle these discreetly.

00:35:18.270 --> 00:35:20.780
Again,
this is when you've had a new version

00:35:20.780 --> 00:35:25.480
of a document come down from iCloud
while you already have existing

00:35:25.480 --> 00:35:28.120
changes for that same document.

00:35:28.290 --> 00:35:33.160
What you don't want to do is pop up a big
dialogue in the user's face and make them

00:35:33.250 --> 00:35:36.200
deal with the conflict right this second.

00:35:36.200 --> 00:35:38.600
Instead,
you want to provide some discreet

00:35:38.610 --> 00:35:42.180
indication in the UI that that
document needs their attention,

00:35:42.190 --> 00:35:48.390
but let them choose when they actually
want to resolve that conflict.

00:35:48.900 --> 00:35:52.200
Another thing that you should
consider doing is uniquely

00:35:52.260 --> 00:35:54.560
identifying documents with a UUID.

00:35:54.560 --> 00:35:58.120
This is a universally unique identifier.

00:35:58.220 --> 00:36:02.280
So iCloud simply uses the name
of the file on disk to try to

00:36:02.280 --> 00:36:05.360
tell the difference between
two different documents.

00:36:05.460 --> 00:36:09.160
So if you create Untitled
Document on one device and Untitled

00:36:09.160 --> 00:36:14.440
Document on a second device,
these look like the same files to iCloud.

00:36:14.550 --> 00:36:20.180
So you should consider embedding your own
unique identifier into these documents.

00:36:20.290 --> 00:36:23.370
That way,
when a version conflict arises between

00:36:23.370 --> 00:36:27.440
something like these two documents,
you can actually load those

00:36:27.440 --> 00:36:31.110
documents programmatically,
look at the unique identifier

00:36:31.110 --> 00:36:33.860
that you stored in them,
and if you find that those

00:36:33.860 --> 00:36:37.060
identifiers are different,
you know they're different documents,

00:36:37.190 --> 00:36:41.450
and you can resolve the conflict
for the user automatically without

00:36:41.450 --> 00:36:43.710
actually having to bother them.

00:36:44.170 --> 00:36:46.940
And again, remember document versioning.

00:36:47.120 --> 00:36:49.040
At some point,
you're going to want to change the

00:36:49.040 --> 00:36:53.510
data you store or how you store it,
so make sure you save off what

00:36:53.520 --> 00:36:58.870
version of your application
actually wrote that document file.

00:37:00.300 --> 00:37:03.460
So, we looked at the fundamentals
of working with iCloud,

00:37:03.620 --> 00:37:06.900
showed you how to set up your
project to work with iCloud,

00:37:06.990 --> 00:37:11.570
and looked at how to actually
adopt iCloud in your application.

00:37:11.680 --> 00:37:15.360
In Part 2 of this presentation,
we're going to show you how to work with

00:37:15.360 --> 00:37:18.880
core data and individual files and data.

00:37:19.220 --> 00:37:22.510
So you learned the fundamentals
of working with iCloud,

00:37:22.760 --> 00:37:27.050
saw how you can use the Key-Value
Store to store user settings,

00:37:27.210 --> 00:37:31.210
and learned how you can use
UI Document in your application to

00:37:31.210 --> 00:37:34.100
store document-based data in iCloud.

00:37:34.100 --> 00:37:37.380
I look forward to seeing the
great apps that you'll build

00:37:37.380 --> 00:37:39.060
that use iCloud Storage.
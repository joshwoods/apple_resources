WEBVTT

00:00:20.760 --> 00:00:22.750
Hello, I'm Allan Schaffe,
the Graphics and

00:00:22.750 --> 00:00:24.940
Media Technology Evangelist at Apple.

00:00:25.130 --> 00:00:28.030
This presentation is the
first in a two-part series on

00:00:28.030 --> 00:00:30.640
mastering OpenGL ES for iPhone.

00:00:30.830 --> 00:00:32.240
There's a lot to learn.

00:00:32.410 --> 00:00:37.380
Part 1 focuses on the environment that
OpenGL ES operates in on the iPhone OS.

00:00:37.380 --> 00:00:41.480
I cover OpenGL ES versions and the
devices where they're supported.

00:00:41.690 --> 00:00:45.120
And I explain the iPhone OS display
system and walk you through

00:00:45.120 --> 00:00:50.000
optimizing the interaction between
OpenGL ES and Core Animation.

00:00:50.200 --> 00:00:53.550
Then I introduce CA DisplayLink,
which can replace your use of

00:00:53.680 --> 00:00:55.680
NS Timer to drive your rendering loop.

00:00:55.900 --> 00:00:58.610
And finally,
conclude with details about how

00:00:58.610 --> 00:01:02.880
OpenGL ES applications should take
advantage of the ARM architecture.

00:01:02.880 --> 00:01:06.740
And whereas Part 1 focuses on
the environment around OpenGL ES,

00:01:07.100 --> 00:01:10.920
Part 2 shines a spotlight onto
mastering OpenGL ES itself.

00:01:10.920 --> 00:01:15.320
I explain the common architecture and the
capabilities of the graphics processors,

00:01:15.500 --> 00:01:18.630
and then dive into specific
performance recommendations for

00:01:18.640 --> 00:01:21.240
optimizing texture and geometry.

00:01:21.340 --> 00:01:23.160
So I hope you'll learn
a lot from both parts.

00:01:23.360 --> 00:01:25.940
Now let's get started with Part 1.

00:01:26.390 --> 00:01:29.780
So OpenGL ES is the interface
for high-performance 3D

00:01:29.780 --> 00:01:31.060
graphics on the iPhone.

00:01:31.070 --> 00:01:32.600
And it goes beyond 3D.

00:01:32.660 --> 00:01:35.940
It is also the dominant
API for hardware-accelerated 2D

00:01:35.940 --> 00:01:38.150
sprite-based rendering as well.

00:01:38.430 --> 00:01:44.210
Now, OpenGL ES is the mobile variant of
the OpenGL standard from the desktop.

00:01:44.210 --> 00:01:47.450
It's defined by an industry
consortium called the Kronos Group,

00:01:47.530 --> 00:01:49.780
of which Apple is an active participant.

00:01:51.290 --> 00:01:54.300
And OpenGL ES really provides
a distillation of the scope

00:01:54.300 --> 00:01:58.330
of the desktop version of
OpenGL and is a subset of the API.

00:01:58.460 --> 00:02:03.320
It's been pared down to an interface
that's appropriate to the capabilities

00:02:03.320 --> 00:02:05.940
and feature set of embedded devices.

00:02:06.540 --> 00:02:10.670
Now, the OpenGL ES API itself
is really easy to learn,

00:02:10.670 --> 00:02:13.420
but mastering OpenGL ES can
be more difficult.

00:02:13.420 --> 00:02:15.000
There's a lot to absorb.

00:02:15.000 --> 00:02:17.470
Of course,
the first things you need to learn

00:02:17.470 --> 00:02:21.560
are the principles of 3D graphics,
things like 3D transformations

00:02:21.560 --> 00:02:24.940
and linear algebra,
and the concepts of defining vertices,

00:02:24.940 --> 00:02:27.900
normals, and colors,
and then how those ideas are

00:02:27.900 --> 00:02:31.600
expressed in the OpenGL API and
OpenGL shading language.

00:02:32.360 --> 00:02:35.930
Then you need to also understand the
architecture of the rendering system

00:02:36.240 --> 00:02:38.360
and the stages of the graphics pipeline.

00:02:38.380 --> 00:02:41.800
Because OpenGL is a state machine,
but it's implemented in

00:02:41.800 --> 00:02:45.080
a pipelined architecture,
so understanding the purpose of the

00:02:45.090 --> 00:02:49.210
various pipeline stages becomes critical
to understanding the API itself.

00:02:49.470 --> 00:02:52.000
So that's just the beginning,
but this represents just the

00:02:52.070 --> 00:02:57.570
basics of what's necessary to
become proficient with OpenGL ES.

00:02:59.170 --> 00:03:02.500
Then there's always platform-specific
behavior that you have to master as well.

00:03:02.730 --> 00:03:06.010
How OpenGL fits into the display system,
the render loop,

00:03:06.100 --> 00:03:09.370
and any CPU-specific behaviors
for the devices that your

00:03:09.370 --> 00:03:10.710
app might be running on.

00:03:10.760 --> 00:03:13.890
And the attributes of the
graphic processor as well.

00:03:14.140 --> 00:03:17.260
Its capabilities, its limits,
and any device-specific

00:03:17.260 --> 00:03:19.290
extensions or best practices.

00:03:19.300 --> 00:03:24.610
And mastering this complexity is
achieved by coding defensively,

00:03:24.830 --> 00:03:27.470
testing for the presence
of capabilities you need,

00:03:27.480 --> 00:03:31.220
and querying the extensions and limits
of the device you're running on.

00:03:31.220 --> 00:03:34.000
And either providing the full
functionality in your app

00:03:34.110 --> 00:03:37.840
if the capability is there,
or providing fallbacks if it's not.

00:03:37.900 --> 00:03:41.420
And finally, in this category,
there's a variety of optimization

00:03:41.430 --> 00:03:44.900
techniques that become critical
to mastering OpenGL ES.

00:03:44.900 --> 00:03:47.520
It's specific to each stage
of the graphics pipeline.

00:03:47.520 --> 00:03:51.540
And finally, there's many topics from
the supporting technologies,

00:03:51.630 --> 00:03:54.260
such as any software you use
for 3D modeling or texture

00:03:54.310 --> 00:03:56.060
painting or creating shaders.

00:03:56.930 --> 00:04:00.590
There's a variety of more advanced
techniques from the world of scene

00:04:00.590 --> 00:04:04.150
graphs and game engines to provide
higher-level decisions about what

00:04:04.150 --> 00:04:05.870
needs to be drawn and how to draw it.

00:04:06.480 --> 00:04:10.040
Things like making the simple
observation that certain objects in

00:04:10.040 --> 00:04:13.780
your scene might be off-screen at the
moment and don't need to be submitted

00:04:13.780 --> 00:04:17.730
to the 3D graphics hardware at all,
saving the hardware from having

00:04:17.730 --> 00:04:19.990
to do all that extra processing.

00:04:20.160 --> 00:04:23.260
And then more expert 3D
rendering techniques themselves,

00:04:23.260 --> 00:04:26.970
such as multi-pass effects
and more advanced shaders.

00:04:27.060 --> 00:04:29.470
So as you can see,
this is a really long list,

00:04:29.470 --> 00:04:33.680
but it begins to explain the background
and information you'll want to learn more

00:04:33.680 --> 00:04:38.460
about as you learn about using OpenGL ES.

00:04:39.540 --> 00:04:42.330
Now, in this presentation,
I focus on this middle section

00:04:42.420 --> 00:04:46.240
having to do with many of the
iPhone-specific optimizations and best

00:04:46.280 --> 00:04:47.920
practices you'll need to know about.

00:04:48.070 --> 00:04:50.770
In Part 1,
I focus on OpenGL versions and OpenGL's

00:04:50.780 --> 00:04:53.880
interaction with the display system,
the render loop,

00:04:53.880 --> 00:04:55.490
and the ARM architecture.

00:04:55.500 --> 00:04:58.420
In Part 2,
the focus is on platform capabilities,

00:04:58.520 --> 00:05:01.340
extensions, and limits,
and optimizations for

00:05:01.340 --> 00:05:02.860
texture and geometry.

00:05:05.310 --> 00:05:09.740
Now back in June this year at WWDC,
we introduced the first iPhone devices

00:05:09.740 --> 00:05:14.660
that supported OpenGL ES version
2.0 and the ability to use a fully

00:05:14.660 --> 00:05:16.720
programmable graphics pipeline.

00:05:16.830 --> 00:05:20.810
So I'd like to describe some of
what this change really means.

00:05:21.070 --> 00:05:25.320
OpenGL ES 1.1 is the API that
we had been using since the

00:05:25.320 --> 00:05:27.050
beginning of iPhone OS devices.

00:05:27.080 --> 00:05:30.920
This targets what's called a
fixed function graphics pipeline.

00:05:30.920 --> 00:05:34.100
And what that means is that the
various stages of the pipeline,

00:05:34.100 --> 00:05:36.540
the command processing,
3D transformations,

00:05:36.540 --> 00:05:40.440
the lighting calculations,
and rasterization, fog, depth test,

00:05:40.510 --> 00:05:44.710
and other stages, all have fixed or
predefined functionality.

00:05:44.720 --> 00:05:48.630
And you, the developer,
have the ability to enable or disable

00:05:48.660 --> 00:05:50.600
various parts of the pipeline.

00:05:51.000 --> 00:05:53.980
And you can configure various
parameters for each stage,

00:05:53.980 --> 00:05:58.380
but the calculations done are predefined
and fundamentally cannot be changed.

00:05:58.420 --> 00:06:04.350
Whereas OpenGL ES version 2.0 replaces
many of these fixed pipeline stages

00:06:04.350 --> 00:06:08.480
with fully programmable stages,
where you, the developer,

00:06:08.560 --> 00:06:12.360
write the code that will perform
the calculations for each stage.

00:06:12.360 --> 00:06:15.350
So if you want higher quality
lighting calculations,

00:06:15.350 --> 00:06:18.440
for example,
you simply implement that yourself

00:06:18.460 --> 00:06:20.320
in a C-like shading language.

00:06:20.840 --> 00:06:25.400
And either have your algorithm run on a
per vertex or per pixel basis as commands

00:06:25.530 --> 00:06:27.710
are submitted to the graphics hardware.

00:06:28.130 --> 00:06:33.390
This enables an entirely new realm of
capabilities for developers to create

00:06:33.750 --> 00:06:37.620
interactive 3D experiences and at a
performance level that's never been

00:06:37.620 --> 00:06:39.350
seen before on a mobile platform.

00:06:41.410 --> 00:06:45.890
These are some examples of the kinds of
algorithms that can now be expressed in

00:06:46.000 --> 00:06:48.120
the GPU with a programmable pipeline.

00:06:48.120 --> 00:06:50.680
Unique lighting models,
as I've just mentioned,

00:06:50.680 --> 00:06:54.800
the ability to have bump maps and
environment maps for reflection and

00:06:54.900 --> 00:06:58.450
refraction performed by the GPU,
various operations on the frame

00:06:58.560 --> 00:07:01.260
buffer for image processing,
and a lot more.

00:07:02.580 --> 00:07:06.880
So I'd like to start by actually showing
you a demo that we developed at WWDC that

00:07:06.880 --> 00:07:11.850
really shows off some of the capabilities
of the iPhone 3GS with OpenGL ES 2.0.

00:07:12.100 --> 00:07:15.200
So this demo is from a familiar genre.

00:07:15.200 --> 00:07:19.270
The ball moves from side to side,
bouncing off my bat and off the walls

00:07:19.270 --> 00:07:21.380
as I try to score against the AI.

00:07:21.380 --> 00:07:24.420
And you can see a smoke texture
being laid down in the scene at the

00:07:24.420 --> 00:07:28.310
location of the ball each frame and
then becoming part of the background.

00:07:29.330 --> 00:07:32.670
And as you can see,
there's a fluid dynamic simulation

00:07:32.970 --> 00:07:36.380
actually running in a number of shaders,
computing the density and

00:07:36.430 --> 00:07:38.240
velocity of the smoke particles.

00:07:38.260 --> 00:07:42.700
And you can see as I move my bat
up and down that it affects the

00:07:42.700 --> 00:07:44.990
smoke in the region around it.

00:07:45.610 --> 00:07:48.990
But the key is that all of the
simulation is happening on the GPU.

00:07:49.440 --> 00:07:51.950
This leaves the CPU free
to do everything else,

00:07:51.950 --> 00:07:56.170
the AI, the game dynamics,
any networking, playing audio, and so on.

00:07:56.230 --> 00:07:58.490
Now,
since all of this is implemented using

00:07:58.490 --> 00:08:01.930
shaders in the programmable pipeline,
if I want to change modes,

00:08:01.960 --> 00:08:03.960
I can actually just change shaders.

00:08:04.060 --> 00:08:06.660
So here is a bump map shader.

00:08:06.690 --> 00:08:09.990
Nine lines of GLSL,
it takes a normal map and attenuates

00:08:09.990 --> 00:08:14.390
the light based on the normal and does
the correct falloff for that light.

00:08:15.580 --> 00:08:19.600
And I hope this gives you the inspiration
to learn more about OpenGL ES 2.0

00:08:19.600 --> 00:08:21.290
and use it within your apps.

00:08:24.970 --> 00:08:28.410
So for those of you who are beginners,
I'd like to point out a few resources

00:08:28.480 --> 00:08:30.280
to help you learn OpenGL ES.

00:08:30.280 --> 00:08:34.350
The first is the OpenGL ES Programming
Guide for iPhone from Apple.

00:08:34.380 --> 00:08:38.410
This has a lot of platform-specific
information and tuning advice that

00:08:38.410 --> 00:08:40.030
you'll want to take advantage of.

00:08:40.040 --> 00:08:44.630
The next is the OpenGL ES 2.0
Programming Guide called the Gold Book.

00:08:44.760 --> 00:08:48.520
This book was actually written prior
to the introduction of the iPhone,

00:08:48.520 --> 00:08:52.080
but now this author has developed
a number of iPhone-compatible code

00:08:52.080 --> 00:08:54.220
samples on their companion website.

00:08:54.890 --> 00:08:57.180
So it's highly recommended,
especially to help you learn

00:08:57.180 --> 00:09:01.880
about shader programming and the
capabilities of the OpenGL ES 2.0 API.

00:09:03.820 --> 00:09:06.390
Then there's a number of
books that originated from

00:09:06.390 --> 00:09:08.170
the desktop version of OpenGL.

00:09:08.170 --> 00:09:11.470
And the first of these is the
OpenGL Shading Language book called the

00:09:11.500 --> 00:09:13.790
Orange Book and now in its third edition.

00:09:13.950 --> 00:09:17.870
This is a great resource for learning
how to write shaders in GLSL.

00:09:17.870 --> 00:09:21.700
And once you've learned that,
it's easy to carry that understanding

00:09:21.700 --> 00:09:23.970
over into learning GLSL ES.

00:09:24.340 --> 00:09:26.690
The next is the
OpenGL programming guide itself,

00:09:26.860 --> 00:09:29.440
the Redbook, now in the 7th edition.

00:09:29.640 --> 00:09:33.790
This is the definitive treatment
for OpenGL from the desktop and will

00:09:33.850 --> 00:09:39.110
teach you a lot of the concepts of
OpenGL that carry over into OpenGL ES.

00:09:39.510 --> 00:09:41.980
The OpenGL Super Bible,
currently in its fourth edition,

00:09:41.980 --> 00:09:44.320
another book originally
written for the desktop,

00:09:44.320 --> 00:09:47.580
but in this edition,
there's a chapter detailing the

00:09:47.620 --> 00:09:49.640
changes you make for OpenGL ES.

00:09:49.640 --> 00:09:53.080
And finally,
there are a number of resources online,

00:09:53.080 --> 00:09:56.530
such as the OpenGL.org website,
where you'll find the

00:09:56.540 --> 00:09:59.430
OpenGL ES specification
and some developer forms.

00:10:01.540 --> 00:10:03.950
And finally, for beginners,
the ideal place for you

00:10:03.970 --> 00:10:08.780
to get started is with the
OpenGL ES application template in Xcode.

00:10:08.940 --> 00:10:12.220
This will show you how to get
an OpenGL ES application up and

00:10:12.220 --> 00:10:15.980
running with an animation loop
and an OpenGL ES context and

00:10:15.980 --> 00:10:18.540
frame buffer all set up for you.

00:10:19.280 --> 00:10:23.510
Now, for those of you who are already
familiar with OpenGL ES on the iPhone,

00:10:23.510 --> 00:10:26.750
there are three key changes that
we've made in the template in the

00:10:26.750 --> 00:10:30.300
3.1 version of the SDK that you
really should go take a look at.

00:10:30.340 --> 00:10:36.390
The first is that the template now
supports both OpenGL ES 1.1 and 2.0.

00:10:36.420 --> 00:10:40.060
It makes a runtime decision of the
renderer based on whether the context

00:10:40.190 --> 00:10:42.000
creation is successful or not.

00:10:42.660 --> 00:10:46.330
The second is that the render loop
of the template is now being driven

00:10:46.340 --> 00:10:50.590
by something new we've added in
iPhone OS 3.1 called CA Display Link.

00:10:50.670 --> 00:10:54.320
Or if you're not running 3.1,
then it will fall back to an

00:10:54.410 --> 00:10:56.380
older method of using NS Timer.

00:10:56.400 --> 00:10:59.500
Now, I'll have a lot more to say about
CA Display Link in just a minute.

00:10:59.500 --> 00:11:03.640
And the third change to note is
that the OpenGL ES 2.0 path is

00:11:03.690 --> 00:11:07.830
now using a simple vertex and
fragment program for rendering.

00:11:07.860 --> 00:11:12.640
And this is really useful for developers
who are accustomed to OpenGL ES 1.1.

00:11:12.660 --> 00:11:17.500
and could use a simple example
of just how to set up a shader.

00:11:18.530 --> 00:11:23.170
So now let's dive deeper into
the specifics of OpenGL ES 1.1

00:11:23.170 --> 00:11:25.530
and 2.0 on iPhone OS.

00:11:25.540 --> 00:11:31.280
So here's a chart outlining the platform
support for OpenGL ES 1.1 and 2.0.

00:11:31.460 --> 00:11:34.820
And I'll be referring back to this
several times during the presentation.

00:11:34.820 --> 00:11:38.940
But the first thing to notice
is that OpenGL ES 1.1 is

00:11:38.950 --> 00:11:41.390
supported across all devices.

00:11:42.370 --> 00:11:46.390
So an application you wrote using
1.1 in the early days of the iPhone

00:11:46.480 --> 00:11:49.820
SDK will continue to function,
even on the latest hardware.

00:11:51.510 --> 00:11:57.400
Now, certain devices also support the
programmable pipeline of OpenGL ES 2.0.

00:11:57.410 --> 00:12:00.570
And specifically,
this is the iPhone 3GS and the

00:12:00.570 --> 00:12:06.630
32 and 64 gigabyte versions of
the third generation iPod touch.

00:12:07.700 --> 00:12:12.380
That support correlates to the
graphics processor used in each device.

00:12:12.480 --> 00:12:16.100
So the iPhone 3GS and third
generation iPod touch both

00:12:16.200 --> 00:12:20.480
use the PowerVR SGX processor
from Imagination Technologies.

00:12:20.590 --> 00:12:24.980
And all the other devices, the iPhone,
iPhone 3G, and first and second

00:12:24.980 --> 00:12:30.720
generation iPod touch use the
PowerVR MBX Lite processor as their GPU.

00:12:30.840 --> 00:12:33.560
Now in Part 2 of the presentation,
I'll be going into a lot of detail

00:12:33.560 --> 00:12:39.250
about the common architecture and the
differences between the SGX and MBX Lite.

00:12:39.370 --> 00:12:45.370
But one more point to simply note is that
both versions of OpenGL ES can coexist on

00:12:45.370 --> 00:12:48.500
the same device if the GPU supports that.

00:12:48.630 --> 00:12:54.230
And applications simply make a runtime
decision of the renderer and API.

00:12:55.410 --> 00:12:59.140
So here's how you configure
which version of OpenGL ES you'll

00:12:59.140 --> 00:13:00.280
use in your application.

00:13:00.300 --> 00:13:03.440
The code for actually choosing
the API is nothing new.

00:13:03.500 --> 00:13:08.080
It's configured by your OpenGL context,
which on iPhone OS is handled

00:13:08.090 --> 00:13:10.470
by an Eagle context object.

00:13:10.560 --> 00:13:15.030
And when you initialize that object,
you'll indicate which API version to use.

00:13:15.040 --> 00:13:18.260
In the case here,
we're configuring our Eagle context

00:13:18.260 --> 00:13:20.480
to use the OpenGL ES 1.1 API.

00:13:20.480 --> 00:13:23.380
And assuming that's successful,
we'll go on to use the fixed

00:13:23.380 --> 00:13:25.040
function pipeline normally.

00:13:27.550 --> 00:13:30.220
Now, as I said,
it's possible for one application

00:13:30.220 --> 00:13:33.790
to be written to support both
of these API versions and make a

00:13:33.790 --> 00:13:37.070
runtime decision of which one to use,
essentially based on the

00:13:37.070 --> 00:13:38.230
hardware you're running on.

00:13:38.470 --> 00:13:41.150
In such a case,
you'd first attempt to create

00:13:41.150 --> 00:13:43.250
an OpenGL ES 2.0 context.

00:13:43.350 --> 00:13:46.160
And if that's successful,
then it means you're running on a

00:13:46.220 --> 00:13:48.490
device which supports OpenGL ES 2.0.

00:13:48.560 --> 00:13:52.680
You can load shaders and go on to
use the 2.0 API and the capabilities

00:13:52.780 --> 00:13:54.600
of a programmable pipeline.

00:13:55.750 --> 00:13:58.740
However, in the same app,
if it happens to be running on a device

00:13:58.740 --> 00:14:02.670
that only supports OpenGL ES 1.1,
then the attempt to create

00:14:02.670 --> 00:14:04.660
a 2.0 context will fail.

00:14:04.820 --> 00:14:07.680
And we'll fall into this second
bit of code where we're attempting

00:14:07.680 --> 00:14:09.230
to create a 1.1 context.

00:14:09.320 --> 00:14:13.240
Presumably, that will succeed and the
app will go on to use the 1.1

00:14:13.240 --> 00:14:15.270
API and fixed function pipeline.

00:14:16.870 --> 00:14:19.300
So this is a very important capability.

00:14:19.350 --> 00:14:22.960
You're able to write a single
application that takes advantage of

00:14:22.960 --> 00:14:27.250
the programmable pipeline when running
on a device with that capability,

00:14:27.300 --> 00:14:30.780
while simultaneously supporting
the fixed function GPUs in the

00:14:30.780 --> 00:14:34.880
rest of the product line to get the
broadest possible device coverage.

00:14:36.820 --> 00:14:38.490
Now,
there's a final example to take note of.

00:14:38.490 --> 00:14:44.140
You can develop your application to
only support OpenGL ES 2.0 and use that

00:14:44.140 --> 00:14:49.410
API in the programmable pipeline without
providing any fallback to OpenGL ES 1.1,

00:14:49.410 --> 00:14:50.410
as shown here.

00:14:51.040 --> 00:14:54.550
However, if you do this,
then you should also indicate that

00:14:54.660 --> 00:14:57.150
requirement in your InfoP list.

00:14:57.160 --> 00:15:00.710
In iPhone OS 3.0 and above,
you're able to specify a list

00:15:00.790 --> 00:15:03.010
of required device capabilities.

00:15:04.060 --> 00:15:07.610
OpenGL ES 2.0 is one of the
requirements that you can set up.

00:15:07.700 --> 00:15:09.700
And actually,
this is just one from a whole

00:15:09.700 --> 00:15:11.320
list that you can choose from.

00:15:11.320 --> 00:15:15.140
If your application required, let's say,
the accelerometer and the

00:15:15.140 --> 00:15:19.260
magnetometer and OpenGL ES 2.0,
you can list these under the

00:15:19.260 --> 00:15:22.080
UI required device capabilities token.

00:15:22.100 --> 00:15:25.230
Then those requirements would
be reflected in the on-device

00:15:25.230 --> 00:15:28.450
version of the App Store when a
user goes to purchase your app.

00:15:31.010 --> 00:15:34.950
So next, I want to dive deeper into some
of the specific information about

00:15:34.950 --> 00:15:38.340
using OpenGL ES on the iPhone OS.

00:15:38.450 --> 00:15:40.870
And I'll be covering these three topics.

00:15:41.050 --> 00:15:43.480
First,
the interaction between OpenGL ES and

00:15:43.480 --> 00:15:47.690
the compositing and animation
system provided by Core Animation.

00:15:47.910 --> 00:15:52.150
Then, some of the new functionality
that's been added in iPhone OS 3.1

00:15:52.430 --> 00:15:53.990
to drive your rendering loop.

00:15:54.240 --> 00:15:57.990
And finally, a brief mention at the end
regarding optimizing for the

00:15:57.990 --> 00:15:59.560
ARM processor architecture.

00:15:59.870 --> 00:16:02.890
So, let's start with the display system.

00:16:04.150 --> 00:16:08.830
The interaction between OpenGL ES and
the display system on iPhone

00:16:08.830 --> 00:16:11.300
is handled by Core Animation.

00:16:11.390 --> 00:16:14.840
Core Animation really acts as the
display manager on the iPhone,

00:16:14.940 --> 00:16:17.740
much in the same way that a
window manager on your desktop

00:16:18.040 --> 00:16:21.120
handles multiple applications,
each with its own window.

00:16:21.240 --> 00:16:25.420
On the iPhone, Core Animation handles
typically a single application,

00:16:25.530 --> 00:16:31.550
but with a hierarchy of views that might
be animated and composited together.

00:16:31.930 --> 00:16:36.480
Now, layers are the fundamental building
blocks used by core animation.

00:16:36.620 --> 00:16:39.080
We say that views are backed by a layer.

00:16:39.450 --> 00:16:43.620
This means that UIView contents
get cached into a layer.

00:16:43.790 --> 00:16:47.440
And likewise,
OpenGL ES content is rendered into a

00:16:47.540 --> 00:16:50.860
layer subclass called CA Eagle Layer.

00:16:51.040 --> 00:16:53.610
And all that's special about
a CA Eagle Layer is that it

00:16:53.670 --> 00:16:57.990
knows how to reference the color
render buffer attachment of

00:16:58.000 --> 00:17:00.530
a frame buffer object in OpenGL.

00:17:00.770 --> 00:17:04.160
Layers may be animated and
composited as your application

00:17:04.160 --> 00:17:08.660
manipulates its view hierarchy,
and any CA Eagle layers just become

00:17:08.710 --> 00:17:11.600
another participant in all of this.

00:17:12.120 --> 00:17:14.340
So, let's look at this more conceptually.

00:17:14.520 --> 00:17:17.500
Your application has some
data in a vertex array,

00:17:17.500 --> 00:17:22.130
which it will render with OpenGL ES,
and the resulting pixels end up in the

00:17:22.130 --> 00:17:25.050
Color Render Buffer attachment to an FBO.

00:17:25.410 --> 00:17:29.970
The Eagle layer object knows how to
reference the contents of that FBO.

00:17:29.970 --> 00:17:32.410
So at this point,
we're just dealing with pixels and

00:17:32.570 --> 00:17:34.300
OpenGL can fall out of the picture.

00:17:34.300 --> 00:17:39.160
And the UI view is backed by a
layer that just happened to have

00:17:39.170 --> 00:17:42.320
its contents generated by OpenGL.

00:17:43.020 --> 00:17:46.790
That view and layer just become another
participant with other views you

00:17:46.830 --> 00:17:48.520
might also have in a view hierarchy.

00:17:48.540 --> 00:17:51.290
For example, in this case,
compositing with the

00:17:51.290 --> 00:17:52.730
UI label and UI slider.

00:17:54.670 --> 00:17:59.600
So, the task for OpenGL developers
is to optimize this interaction.

00:17:59.600 --> 00:18:03.550
And doing so means minimizing
the compositing work to be done.

00:18:03.560 --> 00:18:07.260
And it turns out there's five
things that can slow this down,

00:18:07.260 --> 00:18:10.400
listed here, and I'll go through them in
more detail in just a moment.

00:18:10.400 --> 00:18:13.670
But it involves such things
as the properties you set

00:18:13.680 --> 00:18:17.320
on your CA Eagle layer,
the color format, retained backing,

00:18:17.320 --> 00:18:21.110
any transformations and its opacity,
and any other activity that

00:18:21.110 --> 00:18:24.000
might be taking place in the
rest of the view hierarchy.

00:18:24.600 --> 00:18:27.110
And it's worth noting that
some of these have more of a

00:18:27.110 --> 00:18:29.040
performance impact than the others.

00:18:31.970 --> 00:18:33.860
The first is the color format.

00:18:33.990 --> 00:18:36.840
So this is a property
of the CA Eagle layer,

00:18:36.920 --> 00:18:40.540
and it can be set either to RGBA8,
the default,

00:18:40.670 --> 00:18:44.580
for a 32-bit deep color render
buffer format with alpha,

00:18:44.660 --> 00:18:48.770
or RGB 565, which is 16 bits deep.

00:18:48.960 --> 00:18:53.880
Now, RGB 565 provides half the
color precision of RGBA8,

00:18:53.880 --> 00:18:58.060
but it uses half the memory
bandwidth each frame.

00:18:58.210 --> 00:19:02.260
The reason why this is important,
potentially, is because, in particular,

00:19:02.260 --> 00:19:06.520
the devices that have the
PowerVR MBX Lite are also very

00:19:06.520 --> 00:19:09.160
sensitive to memory bandwidth.

00:19:09.170 --> 00:19:13.450
And the performance of your application,
in many cases, might be bottlenecked by

00:19:13.450 --> 00:19:15.100
the system memory bandwidth.

00:19:15.200 --> 00:19:18.530
So anything you can do to reduce
the pressure on memory bandwidth

00:19:18.680 --> 00:19:21.440
could have a big performance benefit.

00:19:21.790 --> 00:19:24.240
The second property to
mention is retained backing,

00:19:24.240 --> 00:19:26.660
or sometimes this is
referred to as backing store.

00:19:26.660 --> 00:19:31.100
This determines whether the contents
of your color render buffer will be

00:19:31.100 --> 00:19:32.950
preserved after it's been presented.

00:19:32.960 --> 00:19:35.750
That's somewhat unusual
in OpenGL applications,

00:19:35.750 --> 00:19:37.090
so it's off by default.

00:19:37.170 --> 00:19:40.410
But turning it on means that
a copy of your render buffer

00:19:40.410 --> 00:19:42.950
will be made each frame,
with a performance cost

00:19:42.950 --> 00:19:44.740
associated with making that copy.

00:19:46.790 --> 00:19:49.040
The third on our list
was transformations.

00:19:49.410 --> 00:19:50.560
Your CA Eagle layer.

00:19:50.760 --> 00:19:53.070
This is where your
OpenGL content is being rendered.

00:19:53.070 --> 00:19:57.640
It will be composited fastest
if no scaling transformation

00:19:57.660 --> 00:20:00.550
is applied to the layer,
no subpixel translations

00:20:00.550 --> 00:20:04.360
are applied to the layer,
and with a few limited exceptions,

00:20:04.410 --> 00:20:06.980
if no rotation is applied to the layer.

00:20:07.550 --> 00:20:11.380
The only exception that applies is
that on the iPhone 3GS and both the

00:20:11.480 --> 00:20:16.220
second and third generation iPod touch,
rotations that are a multiple of

00:20:16.220 --> 00:20:20.560
90 degrees can be done without any
compositing performance penalty.

00:20:20.560 --> 00:20:24.600
But any other rotation, 1 degree,
45 degrees, and so on,

00:20:24.600 --> 00:20:28.310
or any other devices, namely the iPhone,
the iPhone 3G,

00:20:28.310 --> 00:20:31.870
and the original iPod touch,
will cause extra compositing

00:20:31.950 --> 00:20:34.230
work if any rotation is applied.

00:20:36.490 --> 00:20:39.830
So the advice we've given to
date has been to generally avoid

00:20:39.850 --> 00:20:42.360
setting any layer.transform.

00:20:42.480 --> 00:20:45.690
And instead, for example,
to rotate your OpenGL content

00:20:45.930 --> 00:20:49.500
into landscape orientation,
you'd simply use a 3D transformation

00:20:49.550 --> 00:20:51.640
on the model view matrix in OpenGL.

00:20:51.730 --> 00:20:54.550
And also swap your viewport
width and height to handle

00:20:54.550 --> 00:20:56.230
the change in orientation.

00:20:56.440 --> 00:21:00.050
But you should also watch out for
any view controller above you in

00:21:00.050 --> 00:21:03.530
the hierarchy that may be putting
a 90-degree rotation on you.

00:21:03.620 --> 00:21:07.400
In that case, you may need to put an
inverse rotation on your

00:21:07.430 --> 00:21:09.710
CA Eagle there so they cancel out.

00:21:09.830 --> 00:21:12.980
Unless, as I had mentioned,
your app happens to be running

00:21:12.980 --> 00:21:16.410
on one of the devices that can
do a rotation without penalty.

00:21:18.640 --> 00:21:21.580
The fourth topic is blended content.

00:21:21.760 --> 00:21:23.920
And so there's several scenarios.

00:21:24.150 --> 00:21:27.930
Other views might be composited
on top of your CA Eagle layer

00:21:28.320 --> 00:21:33.300
or your CA Eagle layer might be
composited on top of other views.

00:21:33.440 --> 00:21:37.230
And in either of these two cases,
whatever's on top might be

00:21:37.320 --> 00:21:39.290
opaque or might have alpha.

00:21:39.850 --> 00:21:42.790
The first case,
where you have other views composited

00:21:42.930 --> 00:21:44.340
on top of a CA Eagle layer.

00:21:44.560 --> 00:21:45.900
This is actually okay.

00:21:46.050 --> 00:21:48.720
This is, for example,
an OpenGL scene that has some

00:21:48.790 --> 00:21:51.940
buttons or a slider or some
text overlaid on top of it.

00:21:52.120 --> 00:21:55.710
You'll see some loss of performance
if the overlaid views aren't opaque.

00:21:55.800 --> 00:21:58.740
And anytime they change their
content or are animated,

00:21:58.740 --> 00:22:00.890
there will be a performance penalty.

00:22:02.590 --> 00:22:05.950
But the other case,
where you have a semi-transparent

00:22:05.950 --> 00:22:09.480
CA Eagle layer being composited
on top of another view,

00:22:09.510 --> 00:22:13.460
this is very expensive and has
a serious performance impact.

00:22:13.590 --> 00:22:17.000
And I'll note, if you do this,
you must use pre-multiplied alpha

00:22:17.100 --> 00:22:19.080
for proper compositing results.

00:22:19.080 --> 00:22:22.840
And I've seen a number of scenarios
where developers have done this.

00:22:22.840 --> 00:22:26.430
Sometimes it's intentional,
but many other times it doesn't seem like

00:22:26.440 --> 00:22:28.480
it's being done for the right reasons.

00:22:29.420 --> 00:22:32.880
The scenario where I think it
is for the right reason is in,

00:22:32.880 --> 00:22:36.260
for example,
augmented reality types of applications,

00:22:36.670 --> 00:22:41.680
where a CA Eagle layer is being overlaid
atop the UI image picker controller.

00:22:41.780 --> 00:22:44.340
In iPhone OS 3.1,
there's a new property on the

00:22:44.340 --> 00:22:47.900
image picker called Camera Overlay
View that's made for this very purpose.

00:22:47.980 --> 00:22:51.250
So in that case,
you'll take the compositing hit

00:22:51.320 --> 00:22:55.280
for blending your CA Eagle layer,
but at least what you're

00:22:55.280 --> 00:22:57.090
doing is intentional.

00:22:57.320 --> 00:23:00.820
But the scenario where I've seen this
compositing has been unnecessary has

00:23:00.820 --> 00:23:06.290
been in applications that were actually
creating multiple CA Eagle layers and

00:23:06.610 --> 00:23:08.580
stacking them up on top of each other.

00:23:08.580 --> 00:23:10.970
And just to explain this,
the one on the bottom had

00:23:10.970 --> 00:23:14.520
the background drawn in it,
the one in the middle had various sprites

00:23:14.520 --> 00:23:17.800
being drawn and updated each frame,
and then a third one

00:23:17.800 --> 00:23:19.420
on top had an overlay.

00:23:19.420 --> 00:23:23.350
And this setup is very
inefficient and is not necessary.

00:23:24.040 --> 00:23:27.890
Instead, it would be much more preferable
to collapse all three into a

00:23:27.890 --> 00:23:29.720
single opaque CA Eagle layer.

00:23:29.760 --> 00:23:33.770
So the takeaway is to make sure
your CA Eagle layer is opaque.

00:23:33.860 --> 00:23:37.090
Set the opaque property of
the layer to yes and make sure

00:23:37.090 --> 00:23:39.430
also your view opacity is 1.0.

00:23:41.760 --> 00:23:45.630
And the final optimization relates
to other views which may be updating

00:23:45.630 --> 00:23:49.320
or being animated at the same time
that you're rendering with OpenGL ES.

00:23:49.320 --> 00:23:52.760
As I mentioned earlier,
you'll get faster performance

00:23:52.760 --> 00:23:56.880
if any views overlaid atop
your CA Eagle layer are static.

00:23:56.880 --> 00:24:00.400
Or the inverse,
you'll see best performance animating

00:24:00.400 --> 00:24:04.880
your views if the CA Eagle layer
isn't being redrawn at the same time.

00:24:05.360 --> 00:24:09.320
So the situation you should try to
avoid is when both are updating or

00:24:09.320 --> 00:24:11.940
rendering or animating simultaneously.

00:24:11.990 --> 00:24:14.830
And I've especially seen this,
for example,

00:24:14.830 --> 00:24:20.920
in OpenGL-based applications that
overlay the main CA Eagle layer with

00:24:20.920 --> 00:24:25.680
a UI label for the current score of a
game or current time or current speed.

00:24:25.680 --> 00:24:28.210
Some other value that's
being updated every frame.

00:24:28.220 --> 00:24:31.480
You have to minimize or
eliminate those updates to get

00:24:31.480 --> 00:24:33.680
the best OpenGL ES performance.

00:24:33.680 --> 00:24:35.320
Perhaps by rendering.

00:24:35.360 --> 00:24:38.370
your times and scores and
so on directly in OpenGL.

00:24:40.600 --> 00:24:42.220
Now, here's some great news, actually.

00:24:42.350 --> 00:24:45.860
In Instruments, you can bring up the
Core Animation Instrument,

00:24:45.860 --> 00:24:50.050
and this has a number of diagnostics that
you can enable from its debug options

00:24:50.100 --> 00:24:52.060
to monitor the compositor workload.

00:24:52.080 --> 00:24:55.620
And if you click these checkboxes
while your device is attached,

00:24:55.620 --> 00:24:58.070
it'll show you any
blending that's going on,

00:24:58.070 --> 00:25:00.780
any updates,
and whether your OpenGL rendering

00:25:00.780 --> 00:25:02.540
is on the fast path,
and so on.

00:25:07.100 --> 00:25:09.660
So I'd like to show you
how to do this yourself.

00:25:09.730 --> 00:25:11.860
Okay,
I'm going to bring up instruments and

00:25:11.860 --> 00:25:15.740
go into the core animation instrument.

00:25:15.820 --> 00:25:18.380
I have my iPhone attached.

00:25:19.320 --> 00:25:20.150
Great.

00:25:20.330 --> 00:25:22.380
And now I'll bring up the debug options.

00:25:22.380 --> 00:25:25.090
And you can see a number
of checkboxes here.

00:25:25.120 --> 00:25:28.310
Now I'm going to switch over to the
phone and show you what's happening on

00:25:28.310 --> 00:25:30.230
device as I make various selections.

00:25:32.010 --> 00:25:33.660
All right, so here we are on the iPhone.

00:25:33.660 --> 00:25:36.400
I'd like to show you first
from the core animation

00:25:36.400 --> 00:25:38.090
instrument color blended layers.

00:25:38.140 --> 00:25:40.500
You can see that even
here in the springboard.

00:25:40.500 --> 00:25:42.420
That'll show you the different
layers on the device.

00:25:42.440 --> 00:25:46.450
Now, green means that these pixels are
basically going through without

00:25:46.450 --> 00:25:48.130
any extra compositing work.

00:25:48.350 --> 00:25:53.660
And red is extra compositing for
layers that are being shown here.

00:25:53.660 --> 00:25:57.620
Now, this is really visible in one of the
examples that we've put up on the iPhone

00:25:57.620 --> 00:25:59.770
Dev Center called GL image processing.

00:25:59.940 --> 00:26:03.690
This is an OpenGL example that has
down at the bottom you can see a tab

00:26:03.690 --> 00:26:05.580
bar and then in the middle a slider.

00:26:05.580 --> 00:26:08.600
And also you can see up
at the top the menu bar.

00:26:08.620 --> 00:26:11.620
Now, there's a number of hotspots
here as you can tell.

00:26:11.670 --> 00:26:15.490
So, for example,
with the slider on the bottom,

00:26:15.490 --> 00:26:18.970
you can see that that is being composited
directly over the OpenGL scene.

00:26:18.980 --> 00:26:22.040
And it's colored red for that reason.

00:26:22.040 --> 00:26:25.410
Now, I'm going to turn on
flash updated regions.

00:26:25.480 --> 00:26:26.750
Great.

00:26:26.820 --> 00:26:28.910
So,
now what this is showing is as I move.

00:26:29.520 --> 00:26:35.020
As I select different items in the tab
bar or as I move the slider around.

00:26:35.020 --> 00:26:38.260
You can see the parts of the
screen that are actually being

00:26:38.260 --> 00:26:40.020
recomposited every frame.

00:26:40.060 --> 00:26:44.140
And so these would be a performance
hit in OpenGL if you were doing

00:26:44.140 --> 00:26:45.730
OpenGL rendering at the same time.

00:26:45.740 --> 00:26:49.620
And then finally,
let me turn these off and then I'll go

00:26:49.620 --> 00:26:52.250
to show color the OpenGL FastPath blue.

00:26:52.340 --> 00:26:56.500
Now, here you see actually most of the
pixels are coming through blue.

00:26:56.560 --> 00:26:57.650
And so that's very good.

00:26:57.740 --> 00:26:59.060
The only ones that aren't.

00:26:59.060 --> 00:27:01.620
Are for the tab bar at the bottom.

00:27:01.800 --> 00:27:05.430
And also, of course,
the slider that's been put on top.

00:27:05.620 --> 00:27:07.060
So, those would be some hotspots.

00:27:07.060 --> 00:27:09.920
So, you might want to look at in this
application if you were really

00:27:09.920 --> 00:27:14.310
trying to optimize core animation
and the interaction with OpenGL ES.

00:27:17.200 --> 00:27:20.210
So that's a quick look at using
the Core Animation Instrument to

00:27:20.210 --> 00:27:24.220
see if your rendering is optimal
or if it's requiring the display

00:27:24.220 --> 00:27:26.050
system to do a lot of extra work.

00:27:26.200 --> 00:27:30.110
It's a great resource and I'd actually
recommend pausing this video right

00:27:30.120 --> 00:27:32.120
now and trying it out with your app.

00:27:39.430 --> 00:27:43.480
So, to summarize,
the CA Eagle layer is a layer subclass

00:27:43.480 --> 00:27:47.660
that OpenGL ES uses to participate
in the normal view hierarchy.

00:27:47.740 --> 00:27:52.090
But OpenGL developers should try to
optimize this interaction between

00:27:52.090 --> 00:27:54.080
OpenGL ES and core animation.

00:27:54.120 --> 00:27:56.850
And the things to look
at are the color format,

00:27:56.850 --> 00:28:00.760
retain backing, and transform properties
of the CA Eagle layer.

00:28:00.760 --> 00:28:04.870
And to eliminate any cases where
the layer itself is being alpha

00:28:04.870 --> 00:28:07.360
blended over other UIKit content.

00:28:07.740 --> 00:28:11.030
And minimize any other drawing
being done at the same time.

00:28:11.100 --> 00:28:15.480
And you can use the debug options in the
core animation instrument to check out

00:28:15.480 --> 00:28:17.350
what's actually happening in your app.

00:28:17.620 --> 00:28:19.370
All right, that was a big topic.

00:28:21.300 --> 00:32:05.500
[Transcript missing]

00:32:06.790 --> 00:32:08.950
Next,
I have a few pieces of general guidance

00:32:08.950 --> 00:32:10.620
about managing your rendering loop.

00:32:10.660 --> 00:32:15.860
The first is that it's frequently a
good idea to limit your frame rate

00:32:15.870 --> 00:32:20.320
to what you can normally achieve
based on your average rendering load,

00:32:20.520 --> 00:32:22.540
rather than just running
as fast as you can.

00:32:23.560 --> 00:32:31.200
It's because an erratic frame rate,
meaning one that changes every few

00:32:31.200 --> 00:32:32.790
frames as your rendering load changes,
can be really jarring to the user and

00:32:32.790 --> 00:32:38.310
give them the impression of a very choppy
and unsteady motion in your application.

00:32:38.380 --> 00:32:41.010
It's usually a better idea
to set your frame rate to,

00:32:41.020 --> 00:32:46.240
say, 30 and always hit it than to set it
to 60 and miss it every few frames,

00:32:46.240 --> 00:32:49.160
if that's the situation
your app would be in.

00:32:49.540 --> 00:32:53.090
A second bit of guidance is that
many kinds of applications don't

00:32:53.110 --> 00:32:57.480
necessarily need to be blasting
the graphics pipeline at 30 or 60

00:32:57.480 --> 00:32:59.520
frames per second all the time.

00:32:59.630 --> 00:33:02.580
Particularly if your frame
isn't changing at the moment,

00:33:02.640 --> 00:33:05.250
you could slow down or
even pause your rendering.

00:33:05.360 --> 00:33:07.980
Certain casual games, for example,
like a chess game,

00:33:08.060 --> 00:33:11.910
might be waiting for the user
to make a move and could pull

00:33:11.910 --> 00:33:16.760
back on the workload given to the
CPU and the graphics processor.

00:33:16.960 --> 00:33:20.440
and that can have a big
savings on battery usage.

00:33:20.440 --> 00:33:25.630
Both CA DisplayLink and NSTimers
have a facility for handling this.

00:33:25.890 --> 00:33:29.750
And then a quick note about the
behavior of present render buffer.

00:33:29.760 --> 00:33:33.760
This is what you call at the
end of every frame in OpenGL ES,

00:33:33.760 --> 00:33:37.880
and the contents of the render
buffer actually become undefined

00:33:37.880 --> 00:33:38.760
after they're presented.

00:33:38.760 --> 00:33:42.530
Now,
on devices with the PowerVR MBX Lite,

00:33:42.540 --> 00:33:45.620
it just happened that the
contents would remain unchanged,

00:33:45.620 --> 00:33:48.760
even though that was
technically an undefined result.

00:33:49.080 --> 00:33:54.880
Now, that behavior is not what you'll
see on devices with the PowerVR SGX.

00:33:55.080 --> 00:33:58.220
The contents actually are
destroyed after the call to

00:33:58.220 --> 00:34:00.080
present render buffer on those.

00:34:00.080 --> 00:34:04.650
So you either need to redraw the
entire render buffer every frame,

00:34:04.660 --> 00:34:08.220
or if you do need to retain the contents,
then you can enable retain

00:34:08.330 --> 00:34:10.130
backing with a performance cost.

00:34:12.800 --> 00:34:14.460
And a final note about
the rendering loop,

00:34:14.640 --> 00:34:16.980
less significant than what I've
covered in previous slides,

00:34:16.980 --> 00:34:21.370
but still worthwhile, has to do with the
OpenGL ES template itself.

00:34:21.440 --> 00:34:24.340
The template was written
very defensively,

00:34:24.340 --> 00:34:27.850
assuming that developers
will extend it in many ways.

00:34:28.020 --> 00:34:32.250
So it's built to handle the possibility
that you are managing multiple

00:34:32.250 --> 00:34:36.750
OpenGL contexts or have multiple
render buffer attachments and so on.

00:34:37.660 --> 00:34:42.550
But if you're not doing those things,
then those calls are being made every

00:34:42.550 --> 00:34:46.200
frame to set the context and bind
the frame buffer and render buffer.

00:34:46.200 --> 00:34:47.340
Those become redundant.

00:34:47.340 --> 00:34:50.430
They're already set before you get
into the rendering loop and you

00:34:50.440 --> 00:34:52.320
don't need to reset them every frame.

00:34:54.110 --> 00:34:58.040
So you could just take them out and
save a small amount of overhead.

00:34:58.040 --> 00:35:02.240
The render or draw frame method in the
template typically set up the context,

00:35:02.350 --> 00:35:04.540
then it would bind the
default frame buffer,

00:35:04.640 --> 00:35:07.940
then issue a bunch of
OpenGL commands to draw something,

00:35:07.940 --> 00:35:12.680
then binds the color render buffer,
and finally calls present render buffer.

00:35:12.790 --> 00:35:16.080
But for the most basic applications,
all you really need to be calling

00:35:16.080 --> 00:35:20.490
each frame are your drawing
commands and present render buffer.

00:35:20.670 --> 00:35:23.120
All right,
so that's coverage of the render loop.

00:35:23.220 --> 00:35:26.630
So just remember,
make a runtime decision of how you drive

00:35:26.630 --> 00:35:29.050
your render loop based on the OS version.

00:35:29.060 --> 00:35:33.180
If you're running on 3.1 or above,
you can use CA Display Link,

00:35:33.180 --> 00:35:36.760
and otherwise you'll use timers or
another method you've developed.

00:35:36.840 --> 00:35:40.440
You should limit your frame
rate so it will remain steady

00:35:40.440 --> 00:35:43.770
as your rendering load changes,
and pause your rendering

00:35:43.770 --> 00:35:45.080
if nothing is changing.

00:35:45.120 --> 00:35:47.670
And finally,
note that a few of these calls in the

00:35:47.670 --> 00:35:52.240
template are redundant and can be removed
if you're not using multiple contexts or

00:35:52.550 --> 00:35:54.390
multiple framebuffer object attachments.

00:35:57.700 --> 00:36:01.300
And the final topic for this video
has to do with a bit of optimization

00:36:01.300 --> 00:36:03.580
that you can do for the ARM processor.

00:36:03.610 --> 00:36:08.180
So let me start with devices that
support the ARMv6 processor architecture.

00:36:08.200 --> 00:36:11.820
This is the original iPhone,
the iPhone 3G, and first and second

00:36:11.820 --> 00:36:13.380
generation iPod touch.

00:36:13.380 --> 00:36:16.280
And when the compiler is
generating code for these devices,

00:36:16.280 --> 00:36:20.210
it will use either the thumb
instruction set or ARM instruction set.

00:36:20.360 --> 00:36:21.720
And thumb is the default.

00:36:21.800 --> 00:36:26.520
Thumb instructions are 16-bit wide
instead of 32-bit wide for ARM,

00:36:26.550 --> 00:36:29.510
which means that you can pack
twice as many thumb instructions

00:36:29.570 --> 00:36:34.460
into the same code space as a
given number of ARM instructions.

00:36:34.480 --> 00:36:37.890
That reduces your overall code size
for your binary by a fair amount,

00:36:37.970 --> 00:36:42.240
potentially, and it allows twice as many
instructions to be present in the

00:36:42.370 --> 00:36:44.620
cache at any particular moment.

00:36:44.800 --> 00:36:48.660
But the thumb instruction set
does not support floating point.

00:36:48.780 --> 00:36:51.190
So when the compiler needs
to generate instructions to

00:36:51.290 --> 00:36:54.990
handle some floating point code,
it actually briefly switches over

00:36:55.100 --> 00:36:58.580
to the native ARM instruction set,
executes those instructions,

00:36:58.600 --> 00:37:00.120
and then switches back.

00:37:00.250 --> 00:37:03.720
And that switch comes with
a slight performance cost.

00:37:03.840 --> 00:37:07.460
Now, many applications never notice
this because they don't do enough

00:37:07.460 --> 00:37:10.540
floating point calculations
for it to really be an issue.

00:37:10.630 --> 00:37:13.560
And they more than make up for it
by having more instructions take

00:37:13.620 --> 00:37:16.540
advantage of the instruction cache.

00:37:17.240 --> 00:37:20.620
But many graphical applications,
and in particular many

00:37:20.620 --> 00:37:23.850
OpenGL ES-based applications,
are more floating-point

00:37:23.850 --> 00:37:24.840
heavy than average.

00:37:24.840 --> 00:37:28.300
And the overhead of this switching
back and forth becomes noticeable.

00:37:28.340 --> 00:37:32.090
So in those instances,
and only on the devices that use

00:37:32.090 --> 00:37:37.070
the ARMv6 processor architecture,
we recommend telling the compiler to

00:37:37.070 --> 00:37:39.580
generate ARM instructions all the time.

00:37:39.640 --> 00:37:44.220
You lose the advantages of the smaller
code size and the gains you would have

00:37:44.220 --> 00:37:49.020
from having more instructions in cache,
but now floating-point calculations

00:37:49.020 --> 00:37:51.590
can be handled without the
extra switching overhead,

00:37:51.600 --> 00:37:54.740
which for floating-point
heavy applications can be a

00:37:54.910 --> 00:37:57.100
significant net performance win.

00:37:57.100 --> 00:38:00.540
Now, as I said,
this optimization is specific to devices

00:38:00.540 --> 00:38:03.040
supporting the ARMv6 architecture.

00:38:03.060 --> 00:38:06.570
And again, those are the original iPhone,
iPhone 3G, and first and second

00:38:06.570 --> 00:38:07.840
generation iPod touch.

00:38:09.390 --> 00:38:12.900
Now, if on the other hand,
your application is running on a device

00:38:13.040 --> 00:38:17.970
that supports the ARMv7 architecture,
and this is specifically the iPhone 3GS

00:38:18.110 --> 00:38:21.360
and the third generation iPod touch,
then in this case,

00:38:21.360 --> 00:38:23.240
we recommend sticking with Thumb.

00:38:23.240 --> 00:38:26.060
Or for this architecture,
it's actually called Thumb 2.

00:38:26.060 --> 00:38:31.930
And Thumb 2 has a hybrid instruction set,
mostly consisting of 16-bit instructions,

00:38:31.930 --> 00:38:36.210
but also containing 32-bit
extensions for floating point.

00:38:37.090 --> 00:38:39.510
So with Thumb 2,
you get all the advantages

00:38:39.520 --> 00:38:41.880
of regular Thumb,
the smaller code size,

00:38:41.880 --> 00:38:45.450
more instructions in the cache,
while also natively supporting

00:38:45.570 --> 00:38:48.950
floating point without
needing to switch to ARM mode.

00:38:49.040 --> 00:38:53.010
And in fact, on these devices supporting
the ARMv7 architecture,

00:38:53.010 --> 00:38:56.450
using the ARM instruction
set doesn't buy you anything.

00:38:56.450 --> 00:38:59.020
You just get less advantage
from the instruction cache

00:38:59.020 --> 00:39:00.370
and a larger executable.

00:39:00.380 --> 00:39:04.460
So as a practical matter,
this means that we need to set up our

00:39:04.460 --> 00:39:06.700
build so that we create both an ARMv7.

00:39:06.700 --> 00:39:10.040
So we'll create an ARMv6 and
an ARMv7 version of our binary.

00:39:10.040 --> 00:39:14.740
Then we'll turn Thumb off for the
ARMv6 binary and leave Thumb 2

00:39:14.740 --> 00:39:17.450
turned on for the ARMv7 binary.

00:39:18.690 --> 00:39:21.840
That's a lot to keep straight,
so I'll walk you through how it's done.

00:39:21.950 --> 00:39:24.280
And some of this is actually
already baked into the

00:39:24.280 --> 00:39:27.000
OpenGL ES application template in Xcode.

00:39:27.100 --> 00:39:30.140
So in this case,
I'm going to use the view template

00:39:30.570 --> 00:39:34.660
of a view-based application,
just to have a clean start.

00:39:38.740 --> 00:39:43.100
And I start by opening up my target info.

00:39:43.190 --> 00:39:45.860
Going to the build settings.

00:39:52.900 --> 00:39:55.060
And first I'm going to go
into the architecture setting

00:39:55.060 --> 00:39:59.450
and set this to optimized,
both ARMv6 and v7.

00:39:59.460 --> 00:40:03.860
So this will instruct the compiler
to generate both an ARMv6 and

00:40:03.860 --> 00:40:07.090
ARMv7 version of my binary,
and will put both of them

00:40:07.090 --> 00:40:08.740
into my application bundle.

00:40:08.740 --> 00:40:11.640
This idea is very similar to
that of a universal binary

00:40:11.710 --> 00:40:13.400
on the Mac desktop systems.

00:40:13.400 --> 00:40:15.740
Next I'll find my thumb settings.

00:40:15.740 --> 00:40:17.980
And there it is, compile for thumb.

00:40:17.980 --> 00:40:19.480
Right now it's turned on.

00:40:20.200 --> 00:40:22.870
And if I highlight this,
see if I turn it off,

00:40:22.870 --> 00:40:25.470
it'll be off for both ARMv6 and ARMv7.

00:40:25.750 --> 00:40:29.220
And instead what I want is to set
up a conditional build setting.

00:40:29.350 --> 00:40:32.960
So I'll do that here,
add build setting condition.

00:40:33.150 --> 00:40:37.340
And if I select Arm 6, Arm v6,
I'll create another one,

00:40:37.400 --> 00:40:40.450
somewhat redundant,
but just for completeness, Arm v7.

00:40:40.510 --> 00:40:47.020
So I want thumb to be turned on for
Arm v7 and turned off for Arm v6.

00:40:47.020 --> 00:40:47.790
That's what I have.

00:40:49.420 --> 00:40:49.810
And that's it.

00:40:50.040 --> 00:40:54.630
Now my project is set up to build with
the ARM instruction set on ARMv6 and with

00:40:54.630 --> 00:40:57.320
the Thumb2 instruction set for ARMv7.

00:40:59.010 --> 00:41:03.150
All right, so that concludes Part 1 of
Mastering OpenGL ES for iPhone.

00:41:03.180 --> 00:41:06.890
I've covered OpenGL ES versions,
had a long discussion about

00:41:06.890 --> 00:41:10.260
optimizing compositing,
introduced CA DisplayLink,

00:41:10.260 --> 00:41:12.970
and ended with details
about thumb and arm.

00:41:13.020 --> 00:41:17.080
In Part 2, I dive much deeper
within OpenGL ES itself.

00:41:17.190 --> 00:41:19.740
I cover the common architecture,
the capabilities,

00:41:19.740 --> 00:41:24.800
and the differences between the
PowerVR MBX Lite and the PowerVR SGX.

00:41:25.350 --> 00:41:28.990
Then dive deep into texture
optimization and geometry optimization.

00:41:29.000 --> 00:41:30.960
So I hope you'll stay tuned for that.

00:41:30.980 --> 00:41:33.650
In the meantime,
here's my contact information and

00:41:33.650 --> 00:41:36.880
a link to the iPhone Dev Center,
where you'll find a variety

00:41:36.880 --> 00:41:39.740
of OpenGL ES-based sample
code projects and the

00:41:39.740 --> 00:41:42.150
OpenGL ES programming guide for iPhone.

00:41:42.200 --> 00:41:45.680
And you can also find me
online in the developer forums.

00:41:45.680 --> 00:41:46.750
Thank you for watching.
WEBVTT

00:00:20.480 --> 00:00:23.260
Hi, I'm Michael Jurewitz,
the Application Frameworks and

00:00:23.260 --> 00:00:28.200
Developer Tools Evangelist at Apple,
and welcome to Working with Core Data.

00:00:28.280 --> 00:00:30.260
Today,
we're going to focus on showing you

00:00:30.260 --> 00:00:34.330
how you can integrate this powerful
technology into your application to

00:00:34.330 --> 00:00:39.160
help simplify your development and
optimize how you work with data.

00:00:39.210 --> 00:00:42.710
We're going to focus on the best
practices around structuring your data,

00:00:42.840 --> 00:00:47.090
fetching that data efficiently,
and show you how Core Data integrates

00:00:47.100 --> 00:00:48.720
directly with UIKit.

00:00:48.820 --> 00:00:50.600
So let's get started.

00:00:50.900 --> 00:01:57.200
[Transcript missing]

00:01:57.520 --> 00:02:01.160
So now, why would you use
Core Data in the first place?

00:02:01.300 --> 00:02:04.680
Well, again,
it comes all back to efficiency.

00:02:04.800 --> 00:02:07.540
And it's efficiency in
terms of memory usage,

00:02:07.680 --> 00:02:11.310
being able to reduce the amount of memory
that you consume in your application

00:02:11.870 --> 00:02:15.910
so that you're not having to load in
your entire data set from the moment

00:02:15.910 --> 00:02:18.190
you start using your application.

00:02:18.390 --> 00:02:21.120
It's efficiency in terms
of writing less code.

00:02:21.520 --> 00:02:24.980
Core Data is really going to help you
get some great savings on that front,

00:02:25.150 --> 00:02:27.640
and we'll take a look
at that in a moment.

00:02:27.980 --> 00:02:32.940
And it's also efficiency in terms
of integrating directly with UIKit.

00:02:33.040 --> 00:02:35.150
So let's go ahead and take
a look at an example here.

00:02:35.350 --> 00:02:38.060
In this case,
we created a sample application

00:02:38.530 --> 00:02:42.250
that did things with SQLite in sort
of the usual way that we see third

00:02:42.380 --> 00:02:44.930
parties working with SQLite directly.

00:02:45.050 --> 00:02:49.410
And we pitted this against the exact
same application using Core Data.

00:02:49.530 --> 00:02:53.120
So let's go ahead and take a
look first at memory usage.

00:02:53.210 --> 00:02:57.260
So memory usage on iPhone,
we're loading in 10,000 records

00:02:57.260 --> 00:02:59.130
from this sample application.

00:02:59.250 --> 00:03:03.190
So now our basic SQLite application
took around 1,800 kilobytes

00:03:03.190 --> 00:03:04.570
to load in all this data.

00:03:04.840 --> 00:03:07.130
So fairly sizable.

00:03:07.700 --> 00:03:09.940
If we take a look at the
Core Data application,

00:03:09.940 --> 00:03:12.280
it also took 1800 bytes.

00:03:12.410 --> 00:03:14.360
Now in this case,
this makes sense because you're still

00:03:14.360 --> 00:03:16.240
loading the exact same amount of data.

00:03:16.280 --> 00:03:19.750
So we see these things
are on equal footing.

00:03:20.160 --> 00:03:24.000
But by simply turning on one
small feature in Core Data,

00:03:24.010 --> 00:03:28.130
a simple thing we call batching,
we're able to shave this down to

00:03:28.130 --> 00:03:30.660
just 900 kilobytes on a fresh launch.

00:03:30.660 --> 00:03:33.950
That's a lot of savings.

00:03:34.180 --> 00:03:37.200
Now let's take a look at the
actual speed of this application,

00:03:37.200 --> 00:03:40.010
in this case, the launch time.

00:03:40.390 --> 00:03:43.310
So if we take a look at
the SQLite application,

00:03:43.310 --> 00:03:47.620
we see that it takes roughly five
seconds to go grab all our data,

00:03:47.770 --> 00:03:52.260
query it from the database, populate it,
and then present it.

00:03:52.820 --> 00:03:54.860
By using Core Data,
we're able to do this in

00:03:54.860 --> 00:03:58.290
three and a half seconds,
roughly 30% faster than

00:03:58.300 --> 00:04:00.440
the SQLite implementation.

00:04:00.640 --> 00:04:03.090
And again, by using batching,
we're able to shave

00:04:03.160 --> 00:04:06.030
this down to one second,
or roughly 80% faster.

00:04:06.160 --> 00:04:07.640
Those are huge savings.

00:04:07.760 --> 00:04:10.490
Those are exactly the kinds of
things that you want to see in your

00:04:10.490 --> 00:04:15.350
application so that you can get
started ultra-fast for your user.

00:04:16.020 --> 00:04:17.300
Now let's take a look
at the lines of code,

00:04:17.300 --> 00:04:17.700
right?

00:04:17.700 --> 00:04:20.620
Because ultimately,
it's all about maintainability

00:04:20.630 --> 00:04:21.450
in your project.

00:04:21.520 --> 00:04:24.310
And you want to make sure that
you're able to just maintain

00:04:24.390 --> 00:04:25.610
the code that you care about.

00:04:25.810 --> 00:04:31.820
So SQLite, doing this basic kind of work,
took us roughly 570 lines of code.

00:04:31.820 --> 00:04:33.860
That's a lot to work with.

00:04:33.860 --> 00:04:39.060
Now for Core Data,
it was 320 lines of code, almost half.

00:04:39.800 --> 00:04:43.720
And all those great benefits we saw
from using batching in Core Data,

00:04:43.720 --> 00:04:46.780
well, that took 321 lines of code.

00:04:46.790 --> 00:04:49.460
So as you can see,
really straightforward,

00:04:49.460 --> 00:04:50.930
lots of great savings.

00:04:53.120 --> 00:04:56.440
So let's go ahead and dive into the
Core Data architecture and make sure

00:04:56.440 --> 00:05:01.250
that you understand the basic building
blocks of working with Core Data.

00:05:02.000 --> 00:05:05.780
So the whole point as we go through
and do this work is that we want you

00:05:05.780 --> 00:05:10.250
to be able to think about objects
and avoid database grunt work.

00:05:10.260 --> 00:05:14.060
We want you to think about these objects
and how they're connected to each other

00:05:14.060 --> 00:05:17.840
and the different behaviors that they
have as they interact with each other.

00:05:19.700 --> 00:05:23.320
Now, these individual data objects
that you find in your application

00:05:23.360 --> 00:05:27.600
are represented by a class in
Core Data called NSManagedObject.

00:05:27.730 --> 00:05:32.080
And so we refer to your data
objects as managed objects.

00:05:32.190 --> 00:05:36.460
Now, each instance of one of these
objects represents a row

00:05:36.460 --> 00:05:38.320
of data in your database.

00:05:38.450 --> 00:05:42.720
And it encapsulates everything
about that particular object.

00:05:42.840 --> 00:05:46.690
So it's your data, the relationships,
all the different things

00:05:46.690 --> 00:05:48.040
it might be connected to.

00:05:48.160 --> 00:05:51.030
And these also provide really
powerful capabilities like

00:05:51.060 --> 00:05:52.920
validation and error checking.

00:05:53.020 --> 00:05:55.870
So that you can make sure
that as a user actually inputs

00:05:55.870 --> 00:06:00.210
data into your application,
that you've always got a consistent

00:06:00.210 --> 00:06:02.920
view of your data and that it's valid.

00:06:04.040 --> 00:06:06.540
Now,
all of these managed objects live inside

00:06:06.540 --> 00:06:09.100
what's called a managed object context.

00:06:09.100 --> 00:06:13.300
This is represented by the NS managed
object context in Core Data.

00:06:13.460 --> 00:06:17.800
And you can basically think of this as
Core Data's scratch pad for your objects.

00:06:18.760 --> 00:06:21.900
Now, here we track all the changes
that get made to the individual

00:06:21.900 --> 00:06:23.900
model properties in your objects.

00:06:23.900 --> 00:06:28.050
And the way to think about the managed
object context is that it handles

00:06:28.050 --> 00:06:29.900
all of the verbs about your data.

00:06:29.900 --> 00:06:33.900
So, the inserts, the fetches, saves,
and deletes.

00:06:33.900 --> 00:06:37.760
So, basically creating data,
querying data, etc.

00:06:37.760 --> 00:06:41.810
The managed object context is going to
be the central point that you work with

00:06:41.810 --> 00:06:44.080
when you're doing all of these things.

00:06:44.900 --> 00:06:47.580
So,
now let's take a look at data storage.

00:06:48.760 --> 00:06:52.080
Now, Core Data stores its data using
a class called the NS Persistent

00:06:52.090 --> 00:06:55.280
Store and a couple other friends
that help out along the way.

00:06:56.280 --> 00:06:58.810
Now,
all of this data is stored in SQLite.

00:06:58.910 --> 00:07:01.920
So, fundamentally,
the storage layer is the same

00:07:01.920 --> 00:07:03.690
between SQLite and Core Data.

00:07:04.000 --> 00:07:06.360
Core Data sits on top of
this layer and handles all of

00:07:06.360 --> 00:07:08.410
these interactions for you,
though,

00:07:08.420 --> 00:07:12.280
so you never actually have to worry
about talking to the database directly.

00:07:13.060 --> 00:07:15.050
Now,
the schema and the data that we actually

00:07:15.140 --> 00:07:16.970
store in this file is considered private.

00:07:17.130 --> 00:07:17.270
Core Data is stored in the database.

00:07:17.280 --> 00:07:17.280
So, you don't have to worry about
talking to the database directly.

00:07:17.280 --> 00:07:17.280
Now,
the schema and the data that we actually

00:07:17.280 --> 00:07:17.280
store in this file is considered private.

00:07:17.280 --> 00:07:17.280
Core Data is stored in the database.

00:07:17.280 --> 00:07:17.280
So, you don't have to worry about
talking to the database directly.

00:07:17.280 --> 00:07:21.420
data is storing this in a special format
that it expects to be able to read.

00:07:21.560 --> 00:07:25.300
So don't go in there and try to
manually manipulate this data.

00:07:26.340 --> 00:07:28.680
Now, as we take a look at
actually modeling your data,

00:07:28.760 --> 00:07:32.800
Core Data does this through a class
called the NSManagedObjectModel.

00:07:32.950 --> 00:07:36.060
Now, this is something that you'll
actually graphically design in Xcode,

00:07:36.060 --> 00:07:39.100
and so you can lay out all of
your different objects and how

00:07:39.100 --> 00:07:40.800
they're connected to each other.

00:07:40.990 --> 00:07:44.620
And the ManagedObjectModel basically
describes all of these objects,

00:07:44.620 --> 00:07:48.300
or what we call entities,
and how they're related to each other.

00:07:48.520 --> 00:07:52.770
You also get a chance to define basic
behaviors with this object graph.

00:07:52.870 --> 00:07:55.700
So, how should things be deleted,
for example?

00:07:55.700 --> 00:07:57.190
Should you cascade a delete?

00:07:57.300 --> 00:08:02.310
Should you nullify back references,
etc.? And we actually use all this

00:08:02.310 --> 00:08:06.830
information in your ManagedObjectModel
to create that store file.

00:08:08.000 --> 00:08:12.270
Now, these entities I talked about are
represented by NSEntityDescription.

00:08:12.400 --> 00:08:14.280
And in this case,
they're basically just the

00:08:14.280 --> 00:08:16.140
blueprints for your managed objects.

00:08:16.280 --> 00:08:18.780
They describe the different
data that you want to store.

00:08:18.780 --> 00:08:19.740
So is it a string?

00:08:19.740 --> 00:08:20.590
Is it a data?

00:08:20.950 --> 00:08:22.880
Is it a date, et cetera?

00:08:23.010 --> 00:08:27.860
And also the different relationships
that these objects have to each other.

00:08:28.190 --> 00:08:31.800
Okay, so let's bring all this
information together.

00:08:31.930 --> 00:08:34.340
So we've got our managed object model.

00:08:34.340 --> 00:08:37.710
We've got our managed object context.

00:08:37.710 --> 00:08:41.160
And of course, living in that,
we have our different managed objects.

00:08:41.220 --> 00:08:43.930
And then we have our actual store file.

00:08:43.930 --> 00:08:47.300
And now sitting at the
center of all of this is the

00:08:47.300 --> 00:08:50.030
NS Persistence Store Coordinator.

00:08:50.050 --> 00:08:55.020
And its job is to mediate the interaction
between all of these different layers.

00:08:56.520 --> 00:08:59.500
Now, if you're coming to Core Data for
the first time and you've been doing

00:08:59.500 --> 00:09:03.380
database programming in the past,
let me do a little mapping for you that

00:09:03.390 --> 00:09:05.490
might have this make a little more sense.

00:09:05.510 --> 00:09:08.580
So in this case,
the managed object model,

00:09:08.580 --> 00:09:12.450
you can think of as basically
your database schema.

00:09:12.670 --> 00:09:15.380
The NS Persistence Store Coordinator you
can think of as basically

00:09:15.380 --> 00:09:16.640
your database connection.

00:09:16.640 --> 00:09:19.890
It's how you're going to get
at all your individual data.

00:09:20.160 --> 00:09:23.970
The Managed Object Context with all
of the individual managed objects is

00:09:23.970 --> 00:09:27.800
basically just your raw data as objects.

00:09:27.980 --> 00:09:31.380
Now finally, there's one more class
that gets used in this mix,

00:09:31.380 --> 00:09:33.460
and that's the NSFetchRequest.

00:09:33.580 --> 00:09:36.740
And we're going to talk a whole
lot about this a little bit later.

00:09:36.830 --> 00:09:39.400
But the basic way to think
about the fetch request is that

00:09:39.520 --> 00:09:42.170
it's your SELECT FROM clause.

00:09:43.090 --> 00:09:47.040
Okay, so we've laid the groundwork for
how all these things work together.

00:09:47.040 --> 00:09:51.430
Now let's jump into the individual
sections that I mentioned to you earlier.

00:09:51.570 --> 00:09:56.310
So let's start off here and take
a look at structuring your data.

00:09:57.100 --> 00:10:00.000
Now first, a simple word of warning.

00:10:00.140 --> 00:10:03.870
This is the most important
step in your development,

00:10:04.120 --> 00:10:08.880
is figuring out exactly how you want
all of this data to be structured,

00:10:09.030 --> 00:10:12.610
how it should be related to each other,
and the different behaviors and ways that

00:10:12.610 --> 00:10:14.350
you're going to be querying that data.

00:10:14.380 --> 00:10:17.350
So if anything,
this is the stage where you want

00:10:17.360 --> 00:10:19.320
to take the time to iterate.

00:10:19.320 --> 00:10:22.340
Design that model for the first time,
see how it works,

00:10:22.340 --> 00:10:26.100
but make changes as you find
different performance bottlenecks.

00:10:26.100 --> 00:10:29.810
The last thing you want to do is
start off with a rocky foundation

00:10:29.810 --> 00:10:33.100
that's going to set you up for
problems on into the future.

00:10:33.100 --> 00:10:35.540
Now as always,
Core Data is going to make it easy for

00:10:35.540 --> 00:10:38.460
you to correct some of these issues,
but again,

00:10:38.460 --> 00:10:41.090
spend the time here to do that iteration.

00:10:41.610 --> 00:10:45.100
So we're going to cover a couple rules
of thumb about designing your data.

00:10:45.100 --> 00:10:47.920
And ultimately,
they come down to these four things.

00:10:47.920 --> 00:10:52.100
So first, you need to find a balance
between speed and space.

00:10:52.100 --> 00:10:56.450
Next, you need to make sure that you're
always designing with the UI in mind.

00:10:56.490 --> 00:10:59.360
Now, this might seem a little strange
if you've come from sort of a

00:10:59.460 --> 00:11:02.570
pure database background where
you've got this idea of a perfect

00:11:02.830 --> 00:11:05.020
organization of data in your head.

00:11:05.020 --> 00:11:09.600
And while, yes, that's true, ultimately,
the way that you choose to present

00:11:09.670 --> 00:11:12.650
this data is going to have some
effect on how you store it,

00:11:12.650 --> 00:11:14.530
mostly because of performance.

00:11:14.540 --> 00:11:18.720
Next, a simple statement to
avoid entity inheritance.

00:11:18.720 --> 00:11:20.820
And I'll tell you about
that in just a moment.

00:11:20.820 --> 00:11:24.340
And finally,
don't put blobs in the database.

00:11:24.340 --> 00:11:26.040
These are binary large objects.

00:11:26.040 --> 00:11:27.800
There are better ways to work with these.

00:11:27.800 --> 00:11:32.920
So let's go ahead and jump in and
talk about this speed versus space.

00:11:34.390 --> 00:11:37.780
So in this case,
this is all about structuring your data.

00:11:37.850 --> 00:11:40.310
And ultimately,
it's a push and pull between two

00:11:40.310 --> 00:11:43.820
different ends of the spectrum,
between normalization

00:11:44.130 --> 00:11:45.270
and denormalization.

00:11:45.280 --> 00:11:48.350
Now, these are database terms that
basically have to do with

00:11:48.350 --> 00:11:49.990
how you structure your data.

00:11:50.000 --> 00:11:54.100
So normalization is the idea of
taking the different data that you

00:11:54.100 --> 00:11:58.370
want to work with and finding a
perfectly factored representation

00:11:58.370 --> 00:12:02.500
of it so that you completely
eliminate any repetition of data.

00:12:02.920 --> 00:12:06.500
Now, this is space efficient because
you've eliminated that repetition.

00:12:06.500 --> 00:12:11.000
So instead of having some table where
you repeat the artist name or the

00:12:11.000 --> 00:12:16.020
album name on a song multiple times,
you simply have one canonical reference

00:12:16.020 --> 00:12:18.530
to that artist name or that album name.

00:12:18.540 --> 00:12:23.010
Now, denormalization, in contrast,
is what you do after you've

00:12:23.260 --> 00:12:25.090
normalized your model.

00:12:25.100 --> 00:12:29.880
And it's the willful reintroduction
of some repetition of data.

00:12:29.880 --> 00:12:32.880
And usually, this is the idea that you
want to take something.

00:12:32.920 --> 00:12:35.260
You want to take some data
and make it more local,

00:12:35.260 --> 00:12:37.310
basically make it easier
for you to get at,

00:12:37.310 --> 00:12:39.930
possibly because you
display it often in your UI.

00:12:39.940 --> 00:12:44.320
So the idea here is to help give
you faster access to this data.

00:12:44.320 --> 00:12:48.060
But again, if you denormalize too much,
then it's going to be

00:12:48.060 --> 00:12:49.830
very space inefficient.

00:12:49.870 --> 00:12:52.600
You're going to have lots of
repetition of data to deal with.

00:12:52.680 --> 00:12:56.120
So ultimately, you're always going to
be in this push and pull,

00:12:56.200 --> 00:12:58.530
in this balance between these two poles.

00:12:58.550 --> 00:12:59.260
And that's OK.

00:12:59.260 --> 00:13:02.790
So if we take a look at what
normalization is in the first place,

00:13:02.900 --> 00:13:02.900
we're going to see that it's
going to be a lot more efficient.

00:13:02.920 --> 00:13:04.500
So if we take a look at what
normalization is in the first place,

00:13:04.570 --> 00:13:05.260
let's take a look at a song.

00:13:05.280 --> 00:13:09.580
So as you sit down to design
a database for storing songs,

00:13:09.580 --> 00:13:12.440
you begin to write down all the
different things you want to store.

00:13:12.440 --> 00:13:17.040
So an artist, a title, an album, genre,
et cetera.

00:13:17.040 --> 00:13:19.220
Now,
when you go and you take this and you

00:13:19.220 --> 00:13:23.070
want to actually normalize this model,
you might end up with something

00:13:23.070 --> 00:13:25.000
that looks a little more like this.

00:13:25.000 --> 00:13:28.020
In this case,
you see we still have a song entity.

00:13:28.020 --> 00:13:32.680
But now we have distinct artist, album,
lyrics, and even songs.

00:13:32.920 --> 00:13:34.510
So we've got song data stored off here.

00:13:34.520 --> 00:13:37.060
Now, the song still has a title.

00:13:37.060 --> 00:13:38.990
In this case, it also still has a genre.

00:13:39.000 --> 00:13:41.950
We could actually probably take
that genre and factor that out,

00:13:41.950 --> 00:13:42.340
too.

00:13:42.340 --> 00:13:46.840
And we see now that all these different
objects have relationships to each other.

00:13:46.840 --> 00:13:51.140
So for example, an artist has a too-many
relationship to a song.

00:13:51.160 --> 00:13:53.330
So an artist can have many songs.

00:13:53.360 --> 00:13:56.050
But a song has got a
one-to-one relationship with,

00:13:56.050 --> 00:13:57.730
say, an album, for example.

00:13:57.830 --> 00:13:59.920
Usually, it's only on a single album.

00:14:01.290 --> 00:14:04.230
Now after you've looked at this and
you've factored out all of your data

00:14:04.240 --> 00:14:08.400
and you begin writing your application,
you might find different bottlenecks

00:14:08.400 --> 00:14:11.460
that you want to try to overcome
by changing your model slightly.

00:14:11.460 --> 00:14:14.450
So say, for example,
we had an application where

00:14:14.450 --> 00:14:18.020
the whole focus was on showing
the duration of songs and also

00:14:18.020 --> 00:14:21.710
showing the lyrics for songs,
or at least showing some indication

00:14:21.830 --> 00:14:24.380
that a song has lyric text
that we might want to look at.

00:14:24.460 --> 00:14:27.680
In this case,
if we introduce some denormalization,

00:14:27.680 --> 00:14:30.260
we might end up with something like this.

00:14:31.100 --> 00:14:34.650
In this case, you see we've added a has
lyrics tag back to our song,

00:14:34.650 --> 00:14:39.980
and we've also moved this length from
the song data back into our song entity.

00:14:39.980 --> 00:14:42.400
In this case,
that way we can actually take

00:14:42.400 --> 00:14:45.620
a look at what the total length
of our song was and be able to

00:14:45.620 --> 00:14:48.680
quickly display that in our object,
in our UI.

00:14:50.900 --> 00:14:52.660
Okay,
so when it comes to speed versus space,

00:14:52.660 --> 00:14:54.480
it's all about finding that balance.

00:14:54.480 --> 00:14:59.160
It's all about normalizing our model
first and finding the best organization

00:14:59.160 --> 00:15:01.080
of data that's going to fit our needs.

00:15:01.080 --> 00:15:04.620
And then it's all about
actually using that model and

00:15:04.620 --> 00:15:06.280
discovering those bottlenecks.

00:15:06.280 --> 00:15:09.620
From there, you want to make sure that
you're carefully denormalizing.

00:15:09.620 --> 00:15:12.340
Because remember,
any duplication of information

00:15:12.340 --> 00:15:15.360
that you've got in that model is
going to require extra maintenance.

00:15:15.390 --> 00:15:18.710
It's now another place, you know,
three different places that you're

00:15:18.750 --> 00:15:21.360
going to have to potentially
change this information,

00:15:21.360 --> 00:15:23.320
depending on how many
times you duplicate it.

00:15:24.980 --> 00:15:28.140
All right, so let's look at the idea of
remembering the UI here or

00:15:28.140 --> 00:15:29.750
designing with the UI in mind.

00:15:29.780 --> 00:15:34.800
So if we started with an application
called Core Data Recipes in this case,

00:15:34.800 --> 00:15:37.120
then we might have something
that looks like this.

00:15:37.120 --> 00:15:40.240
We've got a table view where we're
listing out all the different recipes.

00:15:40.330 --> 00:15:42.740
We see we've got a title
and a description for them,

00:15:42.740 --> 00:15:44.780
roughly how long they take to prepare.

00:15:44.780 --> 00:15:48.330
As we select an individual table row,
you'll notice that we get

00:15:48.400 --> 00:15:49.860
the detail on a recipe.

00:15:49.860 --> 00:15:53.220
In this case, we get a thumbnail,
which is kind of a picture of the recipe.

00:15:54.060 --> 00:15:56.380
We see the different
categories that it's in.

00:15:56.380 --> 00:15:59.010
So in this case, it's a dessert,
and we see the different

00:15:59.010 --> 00:16:00.640
ingredients that we might use.

00:16:00.640 --> 00:16:03.060
And clicking on that
little thumbnail picture,

00:16:03.060 --> 00:16:05.390
we actually get a nice,
detailed picture of

00:16:05.390 --> 00:16:06.800
our individual recipe.

00:16:06.880 --> 00:16:09.610
Now,
if we were designing this application,

00:16:09.610 --> 00:16:13.500
we might end up with a data model
that looks something like this.

00:16:15.110 --> 00:16:18.190
In this case, you see we've got a recipe,
and a recipe has got a

00:16:18.210 --> 00:16:21.910
title and a description,
and it's also got relationships to

00:16:21.960 --> 00:16:24.000
all these other different objects.

00:16:24.000 --> 00:16:27.500
So we see, for example,
a relationship to a recipe picture.

00:16:27.500 --> 00:16:29.000
In this case, we call it a large picture.

00:16:29.000 --> 00:16:35.570
We've got a relationship to ingredients,
to categories,

00:16:35.920 --> 00:16:38.990
to the different steps that we want to
use in our recipe to actually create it.

00:16:39.500 --> 00:16:42.680
Now, this is interesting and this
would work for this application,

00:16:42.680 --> 00:16:44.960
but let's sort of turn this on its head.

00:16:45.130 --> 00:16:48.890
Now, what if instead you wanted to
create an application that was

00:16:48.890 --> 00:16:52.700
all about the pictures of food,
it was all about the photos.

00:16:52.800 --> 00:16:56.200
And so, you were really focused on
how that food was presented,

00:16:56.200 --> 00:16:58.840
what the chef had actually
put on that plate.

00:16:58.980 --> 00:17:03.280
And you wanted to categorize these things
based on how the pictures were styled,

00:17:03.280 --> 00:17:04.290
for example.

00:17:04.290 --> 00:17:04.290
Michael Jurewitz

00:17:04.530 --> 00:17:07.690
Well, you might end up with a data model
that looks a little more like this.

00:17:07.700 --> 00:17:12.330
Notice that now we have this thing called
a recipe picture that's sort of the

00:17:12.350 --> 00:17:14.000
central hub of what we're doing here.

00:17:14.020 --> 00:17:17.210
And we're displaying the picture
name and maybe the date that

00:17:17.210 --> 00:17:18.780
we actually took the picture.

00:17:18.780 --> 00:17:23.090
And maybe the actual name of the recipe
because we want to display that as well.

00:17:23.100 --> 00:17:26.170
But you'll notice now that this
recipe picture is what's related

00:17:26.170 --> 00:17:27.660
to the different category.

00:17:27.660 --> 00:17:30.550
And we still have, ultimately,
a recipe with its different

00:17:30.630 --> 00:17:32.660
ingredients and its different steps.

00:17:33.250 --> 00:17:36.500
But it's interesting to see how,
depending on the whole goal of

00:17:36.520 --> 00:17:39.680
the application and how we want
to present that information,

00:17:39.680 --> 00:17:41.470
our data model can change.

00:17:41.560 --> 00:17:43.160
And that's okay.

00:17:43.160 --> 00:17:46.270
You should feel just fine
if you find yourself making

00:17:46.270 --> 00:17:48.200
changes that reflect the UI.

00:17:50.420 --> 00:17:53.420
So really the questions that you
want to ask yourself are really

00:17:53.420 --> 00:17:55.970
what's the focus of this application?

00:17:56.110 --> 00:17:59.440
How is the user going to actually
flow through your application?

00:17:59.450 --> 00:18:02.180
So at each stage,
say as they go through that

00:18:02.180 --> 00:18:06.130
navigation style interface,
what's the data that

00:18:06.130 --> 00:18:08.210
you need at each point?

00:18:08.390 --> 00:18:11.210
The other thing to think about
is what additional information

00:18:11.210 --> 00:18:13.760
might interest the user,
because those are things that

00:18:13.760 --> 00:18:16.340
you're likely to want to display
in your UI in the future.

00:18:16.340 --> 00:18:20.100
And so you might want to make sure
that that data is easy to get at

00:18:20.100 --> 00:18:22.410
in how you design it in your model.

00:18:22.430 --> 00:18:26.070
And again, it's okay for your model
to evolve at this point.

00:18:26.080 --> 00:18:27.760
This is exactly what you want to do.

00:18:27.760 --> 00:18:29.880
You want to iterate and you
want to work with things.

00:18:30.300 --> 00:18:33.060
Now, if you go ahead and you end up
shipping something and you want

00:18:33.060 --> 00:18:35.750
to make some changes in the end,
Core Data does have some

00:18:35.750 --> 00:18:38.800
powerful migration support
to help make that easier.

00:18:41.200 --> 00:21:09.800
[Transcript missing]

00:21:10.220 --> 00:21:13.730
So if you've got small objects,
things that are about a kilobyte

00:21:13.730 --> 00:21:18.600
in size or a couple kilobytes,
say for example, a archived UI color,

00:21:18.660 --> 00:21:21.200
this is totally okay to
store in the database.

00:21:21.200 --> 00:21:22.720
It's very small.

00:21:22.720 --> 00:21:26.030
It shouldn't have that big of an impact
when you go to actually query for the

00:21:26.350 --> 00:21:27.900
things that it might be related to.

00:21:27.900 --> 00:21:28.720
So this is okay.

00:21:28.720 --> 00:21:30.340
Feel free to put this in there.

00:21:32.190 --> 00:21:35.170
Now, once you start getting up
to about 100 kilobytes,

00:21:35.170 --> 00:21:38.640
and certainly any more than that,
you start hitting a gray area where

00:21:38.640 --> 00:21:42.180
it's probably still okay for you to
store these things in the database,

00:21:42.180 --> 00:21:46.140
but you need to adopt some very
specific behaviors to make it efficient.

00:21:46.140 --> 00:21:50.170
Let's say, for example, this was, again,
a picture of one of our recipes.

00:21:50.180 --> 00:21:54.360
Now, if for whatever reason,
as we go querying for all of our recipes,

00:21:54.520 --> 00:21:57.920
we ever had a situation where
we didn't need this picture,

00:21:57.920 --> 00:22:01.500
and if we had stored that
picture in our actual recipe,

00:22:02.190 --> 00:22:05.150
then we'd end up in a situation
where we were eating hundreds of

00:22:05.320 --> 00:22:08.990
kilobytes of memory simply as part
of that query for data that we

00:22:09.090 --> 00:22:11.050
ultimately would never actually need.

00:22:11.060 --> 00:22:15.570
And so, you want to make sure that you
model these at the opposite end

00:22:15.570 --> 00:22:19.540
of a one-to-one relationship,
so that your recipe, for example,

00:22:19.540 --> 00:22:23.590
can go ask for its thumbnail data,
as opposed to always having

00:22:23.590 --> 00:22:24.940
to carry it around with it.

00:22:26.750 --> 00:22:30.040
Now, once you're up into the
megabytes in terms of size,

00:22:30.070 --> 00:22:34.130
these need to be stored on disk,
and there's just no two ways about it.

00:22:34.220 --> 00:22:37.110
Store these on disk,
put them in your documents directory,

00:22:37.210 --> 00:22:41.750
for example, and simply store a URL or a
file path to where they are,

00:22:41.760 --> 00:22:43.020
and then load them in.

00:22:43.040 --> 00:22:45.590
Now,
the good part about doing it this way

00:22:45.590 --> 00:22:50.380
is that then you can actually go and use
UI images in it with contents of file,

00:22:50.380 --> 00:22:53.100
for example, if you've got an image
that you're trying to load.

00:22:53.810 --> 00:22:57.040
Now, this is good because UI image
has got a bunch of smarts that'll

00:22:57.110 --> 00:23:00.120
basically help it decide how
it wants to load in that image.

00:23:00.140 --> 00:23:02.820
If it's large enough,
it'll try to memory map it in.

00:23:02.820 --> 00:23:06.470
This will help a lot in terms of speed
and also in terms of memory savings.

00:23:08.440 --> 00:23:11.830
So if we take a look at an example,
again, here's our recipe,

00:23:11.830 --> 00:23:13.800
and we've got this small picture.

00:23:13.800 --> 00:23:16.900
We still have a relationship
to a large picture,

00:23:16.900 --> 00:23:20.280
but again, we're carrying around that
thumbnail with us every time,

00:23:20.280 --> 00:23:21.970
and that's just really inefficient.

00:23:21.980 --> 00:23:29.540
So what we want to do is take this
data and factor it off like this.

00:23:29.540 --> 00:23:33.480
So you see we've got our small
picture now is stored out on

00:23:33.480 --> 00:23:35.700
that recipe picture entity.

00:23:35.740 --> 00:23:38.050
So we're storing our thumbnail out there.

00:23:38.470 --> 00:23:41.080
And when we have to get
to the large picture,

00:23:41.080 --> 00:23:44.400
the actual detail,
we've got this data file path,

00:23:44.480 --> 00:23:47.710
and we'll use that to
load the image off disk.

00:23:49.770 --> 00:23:52.710
So again, remember,
file systems provide fast,

00:23:52.790 --> 00:23:54.760
efficient access to large files.

00:23:54.770 --> 00:23:56.900
It's ultimately what
they were designed for.

00:23:56.920 --> 00:24:00.400
Now, by doing this,
you avoid all sorts of unneeded faulting

00:24:00.400 --> 00:24:05.290
and help reduce the duplication of data
and also the wasting of data as you pull

00:24:05.430 --> 00:24:07.880
in your objects as part of your fetches.

00:24:07.880 --> 00:24:12.070
Now, it's not necessarily the most
efficient thing for you to store lots

00:24:12.120 --> 00:24:14.250
of smaller resources off on disk.

00:24:14.300 --> 00:24:17.160
So again, this is why those are a
little more safe for you to

00:24:17.260 --> 00:24:18.960
actually store in the database.

00:24:19.640 --> 00:24:21.820
But again,
use a one-to-one relationship and feel

00:24:21.820 --> 00:24:25.660
free to benchmark either case to find the
one that's going to work best for you.

00:24:27.450 --> 00:24:29.740
All right,
so that was structuring your data.

00:24:29.770 --> 00:24:33.280
Now let's hop into fetching efficiently.

00:24:33.880 --> 00:24:38.230
So fetching your data,
it's all about using the NSFetchRequest.

00:24:38.490 --> 00:24:41.360
This is going to be how you
access all that saved data.

00:24:41.360 --> 00:24:45.200
Now, NSFetchRequest is really
flexible and really powerful,

00:24:45.320 --> 00:24:46.880
and it's really simple to use.

00:24:46.880 --> 00:24:48.980
All you have to do is
tell us what to fetch,

00:24:49.090 --> 00:24:51.710
where you want it fetched from,
and how you want it to

00:24:51.820 --> 00:24:54.020
be brought back to you,
basically.

00:24:55.760 --> 00:24:57.560
So in this case,
if we wanted to fetch all the

00:24:57.570 --> 00:25:00.840
albums beginning with B and
sort them alphabetically,

00:25:00.940 --> 00:25:04.380
we'd tell our FetchRequest, "Hey,
we want you to go talk to the album

00:25:04.380 --> 00:25:09.590
entity." We'd set a predicate that said,
"Hey, find them where the title is

00:25:09.670 --> 00:25:14.330
like B*," or we could say,
"starts with B." And for the sorting,

00:25:14.330 --> 00:25:19.040
we simply wanted to come back with
it being alphabetical by name.

00:25:19.210 --> 00:25:21.040
Now again, if you've come from a
database background,

00:25:21.040 --> 00:25:26.100
the way to think about this is that
this is sort of your select from clause.

00:25:26.180 --> 00:25:28.280
And the predicate is your where clause.

00:25:28.300 --> 00:25:30.940
This is where you're specifying all
the different conditions that have

00:25:30.940 --> 00:25:34.200
to be met to bring back this data.

00:25:34.570 --> 00:25:38.820
and the sorting here is basically
just your order by clause.

00:25:38.850 --> 00:25:41.680
So creating a fetch
request is as easy as one,

00:25:41.680 --> 00:25:42.540
two, three.

00:25:42.750 --> 00:25:46.840
The first thing you do is to set the
actual entity that you want to fetch.

00:25:46.850 --> 00:25:49.680
In this case we create
an NSEntity description,

00:25:49.680 --> 00:25:53.810
we specify the name that we want
to use and also the managed object

00:25:53.940 --> 00:25:56.570
context that we want to work with.

00:25:56.690 --> 00:26:00.830
Next,
we simply alloc and init a fetch request.

00:26:00.830 --> 00:26:04.610
And then we set the album in
as the entity to be fetched

00:26:04.630 --> 00:26:06.830
with that fetch request.

00:26:07.510 --> 00:26:09.310
Now, if we've got a predicate
that we want to set,

00:26:09.320 --> 00:26:11.290
in this case,
these are conditions that need to be

00:26:11.290 --> 00:26:15.280
met in order to bring back any objects,
we can do that.

00:26:15.340 --> 00:26:20.190
In this case, we're seeing if the release
year matches the current year.

00:26:20.700 --> 00:26:24.360
And finally,
you just need to do the actual fetch.

00:26:24.470 --> 00:26:28.230
Now, the first thing that you
always need to do is declare an

00:26:28.230 --> 00:26:30.630
NSError and simply set that to nil.

00:26:30.630 --> 00:26:35.390
Now, you do that because you're later
going to pass this error into

00:26:35.390 --> 00:26:38.100
the execute fetch request method.

00:26:38.100 --> 00:26:41.390
Now, if for whatever reason anything
goes wrong during this fetch,

00:26:41.530 --> 00:26:43.930
Core Data is going to take
care of populating this

00:26:43.930 --> 00:26:45.480
error information for you.

00:26:45.520 --> 00:26:48.390
And so this is going to be the
object that you can use to figure

00:26:48.390 --> 00:26:50.100
out what might have gone wrong.

00:26:51.220 --> 00:26:53.470
But normally,
you would just send execute fetch

00:26:53.530 --> 00:26:55.630
request to your managed object context.

00:26:55.760 --> 00:26:59.090
You'd pass in the actual fetch
that you want to have done,

00:26:59.120 --> 00:27:02.310
and you'd get back an array of results.

00:27:03.790 --> 00:27:07.240
So there's a bunch of different
ways that you can do fetching.

00:27:07.250 --> 00:27:10.150
And the most important thing in
your development when you're getting

00:27:10.250 --> 00:27:11.920
started is to know your tools.

00:27:12.010 --> 00:27:14.600
So we're going to take a look
at five different topics here.

00:27:14.750 --> 00:27:19.880
We're going to take a look at faulting,
prefetching, batching, partial faulting,

00:27:20.050 --> 00:27:20.930
and aggregates.

00:27:21.180 --> 00:27:23.020
So let's just jump right in.

00:27:23.080 --> 00:27:26.650
Now, understanding faulting is one of
the most important things as you're

00:27:26.650 --> 00:27:28.470
getting started with Core Data.

00:27:28.570 --> 00:27:31.470
So as you go and decide to
fetch against your database,

00:27:31.470 --> 00:27:35.370
perhaps you might bring back albums
that we talked about earlier.

00:27:35.600 --> 00:27:38.010
And when you do that fetch,
Core Data is going to take care

00:27:38.150 --> 00:27:41.220
of bringing those objects back
and making sure that their row

00:27:41.220 --> 00:27:43.140
information is populated for you.

00:27:43.140 --> 00:27:46.200
So that when you go to
access one of these albums,

00:27:46.320 --> 00:27:50.270
we've got all the information
there for you to be able to use.

00:27:50.510 --> 00:27:54.240
Now, it's typical, though,
for something like albums to have

00:27:54.240 --> 00:27:58.490
a bunch of relationships off to,
say, a bunch of song objects.

00:27:58.500 --> 00:28:01.830
Now, it wouldn't be very efficient
if we also went out and fetched

00:28:01.900 --> 00:28:05.240
all these song objects in,
because if you had a lot of these things,

00:28:05.240 --> 00:28:07.340
you could really quickly
exhaust your memory,

00:28:07.340 --> 00:28:08.500
for example.

00:28:08.500 --> 00:28:13.540
So what Core Data does is it maintains
an understanding that these things exist,

00:28:13.780 --> 00:28:18.720
but it waits to actually pull this
information in until you ask for it.

00:28:18.720 --> 00:28:23.830
So if, for example,
you were to ask Album 3 for Song 3,

00:28:24.170 --> 00:28:28.500
we'd go ahead and notice that,
we'd go to the database,

00:28:28.500 --> 00:28:28.500
and we'd look at the data.

00:28:28.500 --> 00:28:30.500
And we'd load that song in for you.

00:28:30.500 --> 00:28:34.500
So that's a basic idea for how
faulting works in Core Data.

00:28:35.890 --> 00:28:37.800
Now let's take a look at prefetching.

00:28:37.970 --> 00:28:41.100
Prefetching is all about
getting more information back.

00:28:41.130 --> 00:28:45.640
And this is exactly for the cases when
you know exactly what data you need.

00:28:45.730 --> 00:28:48.700
And say if there's any data
off in relationships that you

00:28:48.750 --> 00:28:52.380
know you're going to access and
so you want easy access to it.

00:28:52.450 --> 00:28:56.500
Now prefetching works for relationships,
but it also works for the

00:28:56.500 --> 00:28:58.460
attributes on those relationships.

00:28:58.460 --> 00:28:59.650
So let's take a look.

00:29:00.740 --> 00:29:01.600
So how do you use this?

00:29:01.690 --> 00:29:04.960
Well, you set up your prefetch
request like you always would.

00:29:04.960 --> 00:29:08.350
In this case, we've specified our entity,
we've specified the

00:29:08.470 --> 00:29:12.270
managed object context,
and we've set up everything else.

00:29:12.470 --> 00:29:14.820
Now,
the next thing you do is use this set

00:29:14.820 --> 00:29:18.400
relationship key pass for prefetching.

00:29:18.500 --> 00:29:23.280
And you pass in an array of key pass
that basically you want to be prefetched.

00:29:23.470 --> 00:29:27.800
Now, these key pass represent basically
the names of relationships and

00:29:27.800 --> 00:29:31.400
potentially the different properties
that you want to have preloaded.

00:29:31.530 --> 00:29:34.570
So in this case,
we're fetching against our albums,

00:29:34.570 --> 00:29:39.790
but we want these songs to go ahead
and also get fetched along with this.

00:29:40.090 --> 00:29:43.080
Now, when you do this,
you want to just go ahead and execute

00:29:43.120 --> 00:29:47.710
your fetch request like you always would,
and you'll get back a bunch of albums.

00:29:47.780 --> 00:29:51.560
Now, it's important to note, though,
that along with these albums,

00:29:51.560 --> 00:29:53.770
you'll also have any associated songs.

00:29:53.880 --> 00:29:58.460
But herein lies the problem,
because you might have

00:29:58.460 --> 00:30:01.760
gotten back a song,
or more than likely,

00:30:01.760 --> 00:30:07.420
you probably got back some songs,
or perhaps you got back songs,

00:30:07.420 --> 00:30:09.980
or you might even have
gotten back a song.

00:30:11.000 --> 00:30:12.000
So, you want to make sure that you use
this functionality judiciously.

00:30:12.000 --> 00:30:24.730
Be careful about how much data you
might actually be pulling back.

00:30:24.840 --> 00:30:27.830
This is, again,
an area where something like batching,

00:30:27.830 --> 00:30:30.070
for example,
might be able to help you out,

00:30:30.070 --> 00:30:33.830
but also just understanding your
data and how it's related can help.

00:30:35.330 --> 00:30:38.320
So speaking of batching,
let's take a look at that.

00:30:38.470 --> 00:30:41.280
Now, batching lets you work
with chunks of data.

00:30:41.280 --> 00:30:44.210
And when you think about it,
there's ultimately only so

00:30:44.210 --> 00:30:47.400
much that you can actually
fit on the screen at one time.

00:30:47.430 --> 00:30:50.570
Something like the iPhone, I mean,
you're going to be lucky

00:30:50.570 --> 00:30:52.880
if you can get more than,
say, six, seven,

00:30:52.930 --> 00:30:56.900
eight rows in a table view without
really squishing down information.

00:30:58.510 --> 00:31:01.120
Now, batching is going to let you
save memory because what you're

00:31:01.120 --> 00:31:05.290
going to do is only load the data
you need to display on screen.

00:31:05.300 --> 00:31:07.650
So you're only dealing
with what's necessary.

00:31:07.650 --> 00:31:11.570
And the best part about batching
is that it's really easy to adopt.

00:31:11.700 --> 00:31:14.450
Remember that one line of
code that I mentioned earlier?

00:31:16.730 --> 00:31:19.930
So, to use batching, again,
you set up your fetch request

00:31:19.950 --> 00:31:22.230
like you always would.

00:31:22.420 --> 00:31:26.290
And then it's this single line,
this set fetch batch size.

00:31:26.290 --> 00:31:30.660
And then you simply pass in how
many objects you want to be fetched

00:31:30.660 --> 00:31:32.170
as part of your initial request.

00:31:32.230 --> 00:31:34.040
In this case, we're just asking for 10.

00:31:34.040 --> 00:31:37.290
Now, when you actually go and
execute this fetch request,

00:31:37.290 --> 00:31:39.860
you're going to get back
an array of results.

00:31:39.940 --> 00:31:44.720
Now, this array is only going to
have 10 results in this case.

00:31:45.200 --> 00:31:48.580
But there's something really
interesting going on here.

00:31:48.580 --> 00:31:53.720
This NSArray, this results array,
still responds to the count method.

00:31:53.750 --> 00:31:57.830
And the count that it'll give you
will be the total number of objects

00:31:57.830 --> 00:32:00.450
that really came back from this query.

00:32:00.460 --> 00:32:03.370
So, for example, 5,280.

00:32:03.440 --> 00:32:08.010
But it's only going to have
10 objects actually in it.

00:32:08.100 --> 00:32:12.580
Now, to access the rest of these objects,
all you need to do is start indexing into

00:32:12.580 --> 00:32:15.070
the array or start iterating through it.

00:32:15.140 --> 00:32:16.430
Whatever you need to do.

00:32:16.440 --> 00:32:20.380
Core Data will notice this and
behind the scenes will take care

00:32:20.380 --> 00:32:24.420
of loading this data into the
array for you to be able to use.

00:32:24.420 --> 00:32:28.920
So, really tricky, really powerful,
and just really seamless for you to use.

00:32:28.940 --> 00:32:29.660
It's fantastic.

00:32:31.720 --> 00:32:34.590
So, let's take a look at
partial faulting now.

00:32:34.700 --> 00:32:38.150
Now, partial faulting lets you
just get a slice of the data.

00:32:38.450 --> 00:32:41.370
And this is for when you
know the data you need,

00:32:41.370 --> 00:32:44.460
and you know that that
data is only a subset,

00:32:44.600 --> 00:32:46.380
it's only a few things.

00:32:46.690 --> 00:32:50.600
Now this is heavily UI influenced,
so this is exactly for the situation

00:32:50.600 --> 00:32:55.070
where you're showing a listing of albums
and you know that you only need to show,

00:32:55.100 --> 00:32:58.770
say, the name of the album and
maybe how many songs it has or

00:32:58.770 --> 00:33:01.120
the name and the release date.

00:33:01.240 --> 00:33:04.360
So let's see how you actually
work with partial faulting.

00:33:04.460 --> 00:33:08.990
So again, you set up your fetch request
like you always would.

00:33:09.460 --> 00:33:12.120
And then you've got this
single method to call,

00:33:12.120 --> 00:33:13.940
the set properties to fetch.

00:33:13.940 --> 00:33:19.640
And you pass in an NSArray of
strings for the different properties

00:33:19.640 --> 00:33:20.970
that you want to be fetched.

00:33:21.080 --> 00:33:23.620
Now, if you've read the
documentation carefully,

00:33:23.740 --> 00:33:28.080
you've noticed that it actually calls
for an array of NS property descriptions.

00:33:28.080 --> 00:33:30.660
Well, as it turns out,
you can also simply pass

00:33:30.660 --> 00:33:32.080
in an array of strings.

00:33:32.080 --> 00:33:34.270
So do feel free to do that.

00:33:34.390 --> 00:33:38.390
Just make sure that your string
names you pass in exactly match

00:33:38.440 --> 00:33:40.700
what you've got in your model.

00:33:40.800 --> 00:33:44.350
So in this case, we see for the albums,
I'm prefetching their title

00:33:44.350 --> 00:33:46.410
and also their release date.

00:33:46.730 --> 00:33:49.690
After that,
we simply execute the fetch request

00:33:50.110 --> 00:33:54.400
and you'll get back an array of results
that matches just this information.

00:33:54.400 --> 00:33:57.660
All right,
so now let's take a look at aggregates.

00:33:57.660 --> 00:33:59.000
So what are aggregates?

00:33:59.080 --> 00:34:01.050
Well,
they're basically just data summaries.

00:34:01.060 --> 00:34:04.790
Now, Core Data supports two
different kinds of aggregates.

00:34:04.930 --> 00:34:08.780
You've got in-database
aggregates and custom aggregates.

00:34:08.780 --> 00:34:12.210
So now, in-database aggregates really
lets you sort of calculate

00:34:12.210 --> 00:34:13.760
to your heart's content.

00:34:14.420 --> 00:34:18.020
Now, natively supported in
Core Data are functions like sum,

00:34:18.020 --> 00:34:20.980
count, min, max, and average.

00:34:21.080 --> 00:34:23.680
And these are really pretty
straightforward to use.

00:34:23.680 --> 00:34:28.100
Now, count, among all of them,
is the most straightforward to use.

00:34:28.100 --> 00:34:30.170
So how do you actually do a count?

00:34:30.260 --> 00:34:33.740
Well, you set up your fetch request
like you always would.

00:34:33.740 --> 00:34:38.110
And then,
instead of calling executeFetchRequest,

00:34:38.110 --> 00:34:41.120
you call count for fetch request.

00:34:41.120 --> 00:34:43.920
You pass that to your
managed object context.

00:34:44.220 --> 00:34:46.510
And in there, of course,
you also pass in the fetch

00:34:46.590 --> 00:34:48.300
request and the error parameter.

00:34:48.300 --> 00:34:51.240
And now,
the managed object context will return

00:34:51.240 --> 00:34:55.740
to you the count of objects that would
have been returned by your query.

00:34:55.740 --> 00:35:02.680
Now, you could do a normal fetch and then
ask the array of results for its count.

00:35:02.680 --> 00:35:04.190
That's certainly a way to do it.

00:35:04.260 --> 00:35:08.720
But it's going to be much less
efficient if all you need is a count.

00:35:08.740 --> 00:35:13.610
If you plan on then accessing the
different attributes on these objects,

00:35:13.760 --> 00:35:16.760
well, then doing a fetch
request might make sense.

00:35:16.760 --> 00:35:20.220
But if all you need is the count,
use this API.

00:35:20.220 --> 00:35:24.140
So let's take a look at the
other in-database aggregates.

00:35:24.140 --> 00:35:25.820
In this case, taking a sum.

00:35:25.840 --> 00:35:29.920
So the first thing we need to
do is create an NS expression.

00:35:29.920 --> 00:35:33.120
And this is going to define the
actual function that we want to

00:35:33.120 --> 00:35:34.990
be evaluated against our data.

00:35:35.000 --> 00:35:40.740
So we create this NS expression with
expression for function arguments.

00:35:40.740 --> 00:35:43.840
And in this case, we pass in a array.

00:35:43.840 --> 00:35:45.780
And we pass in a array of NS expressions.

00:35:45.930 --> 00:35:48.810
Now, we've got here this
expression for key path,

00:35:48.910 --> 00:35:49.680
duration.

00:35:49.840 --> 00:35:52.380
In this case,
this duration key path is going

00:35:52.380 --> 00:35:57.570
to be the attribute on our
object that we want to sum up.

00:35:57.950 --> 00:36:01.700
The next thing we do is create
an NS expression description,

00:36:01.710 --> 00:36:05.060
and we simply alloc init
and auto-release it.

00:36:05.740 --> 00:36:08.630
Next, we want to set up some information
about that description.

00:36:08.750 --> 00:36:12.270
So first, we give it a name,
in this case, total time.

00:36:12.570 --> 00:36:16.360
Next, we want to give it the actual
expression that we want to be evaluated,

00:36:16.360 --> 00:36:20.540
so it's that NS expression
that we created up top.

00:36:20.950 --> 00:36:23.140
Finally, we want to tell the
expression description how

00:36:23.160 --> 00:36:24.800
we want the data returned.

00:36:24.800 --> 00:36:27.540
In this case,
we want the NSDecimal attribute

00:36:27.540 --> 00:36:32.120
type because we want to get back
basically a floating point number.

00:36:33.140 --> 00:36:36.530
Next, we want to tell our object exactly
what we want to have fetched.

00:36:36.680 --> 00:36:39.730
So we set up the properties
that we want to fetch,

00:36:39.730 --> 00:36:43.680
in this case, just an array that contains
our expression description.

00:36:43.750 --> 00:36:48.650
And we pass that into our fetch request
through the set properties to fetch.

00:36:48.990 --> 00:36:51.700
Finally,
we'll set the result type on our fetch

00:36:51.710 --> 00:36:54.310
request to the NSDictionary result type.

00:36:54.440 --> 00:36:58.220
This will make sure that we just get
back a single dictionary as part of

00:36:58.220 --> 00:37:03.900
our fetch request that will contain
the name total time and the value,

00:37:03.900 --> 00:37:06.600
which is basically the result
of running the summation.

00:37:06.600 --> 00:37:09.800
So as we execute that and
then get back a result,

00:37:09.800 --> 00:37:13.490
we'll get just that,
a single dictionary with a single

00:37:13.490 --> 00:37:18.610
entry that says total time and the
amount of time that those things took.

00:37:20.930 --> 00:37:24.160
Now, you can also do your own
custom aggregates in Core Data.

00:37:24.210 --> 00:37:25.710
Those are a little bit
easier to work with,

00:37:25.750 --> 00:37:27.970
so let's show you how you can do that.

00:37:28.120 --> 00:37:31.270
So, for example,
if you wanted to fetch against

00:37:31.270 --> 00:37:35.180
all the albums again and find
something to go ahead and calculate,

00:37:35.260 --> 00:37:38.940
you would set up your fetch
request like you always would.

00:37:39.460 --> 00:37:42.230
We'd go ahead and set the
result type from this fetch

00:37:42.230 --> 00:37:46.400
to the NSDictionaryResultType,
and then set the properties that

00:37:46.400 --> 00:37:48.960
we actually want to be fetched,
whatever that might be.

00:37:48.960 --> 00:37:53.690
We'd then execute our fetch request,
and we'd get back an array of

00:37:53.690 --> 00:37:58.980
dictionaries that we could simply use
key value coding to get the values from,

00:37:58.980 --> 00:38:00.800
just value for key, for example.

00:38:01.700 --> 00:38:04.840
And in this case,
we'd be able to then iterate through all

00:38:04.840 --> 00:38:09.480
those results and do whatever fancy logic
we had in calculating our aggregate.

00:38:09.480 --> 00:38:12.640
Now, this is one way to do it, but if,
for example,

00:38:12.790 --> 00:38:17.280
you were also planning on later using
these objects for display or pulling

00:38:17.280 --> 00:38:20.680
out some other information about them,
you might just feel free to do a

00:38:20.730 --> 00:38:24.540
normal fetch request and then just
iterate through those results.

00:38:24.540 --> 00:38:28.570
So you wouldn't necessarily have
to set that NSDictionaryResultType.

00:38:30.910 --> 00:38:34.290
All right, so we looked at a bunch of
different options for fetching and

00:38:34.410 --> 00:38:38.260
understanding key parts about how
fetching works in the first place.

00:38:38.490 --> 00:38:42.500
So we looked at faulting,
we talked about prefetching, batching,

00:38:42.770 --> 00:38:45.640
partial faulting, and aggregates.

00:38:45.750 --> 00:38:48.110
So that's fetching efficiently.

00:38:48.300 --> 00:38:52.680
Now, let's take a look at
integrating with UIKit.

00:38:53.710 --> 00:38:58.360
So now Core Data is a technology designed
to primarily help with the back end.

00:38:58.400 --> 00:39:02.000
You know, we're providing fast,
efficient access to your data.

00:39:02.000 --> 00:39:05.300
We're helping you validate user input,
and we're also helping you

00:39:05.300 --> 00:39:08.000
reduce your memory usage overall.

00:39:08.080 --> 00:39:11.350
But Core Data goes beyond that
and can even help you when it

00:39:11.350 --> 00:39:13.500
comes out to displaying your data.

00:39:13.590 --> 00:39:15.380
Because remember,
now you've got all this data

00:39:15.380 --> 00:39:18.580
that's come back from the database,
but you've got real objects

00:39:18.580 --> 00:39:20.290
that you can work with.

00:39:20.400 --> 00:39:23.590
And remember,
managed objects are just objects.

00:39:23.760 --> 00:39:26.730
Sure,
they're subclasses of NSManagedObject,

00:39:26.730 --> 00:39:30.000
but that's just a subclass of NSObject.

00:39:30.070 --> 00:39:34.300
And Core Data makes it easy for you
to define your own custom classes

00:39:34.300 --> 00:39:36.500
to use for these managed objects.

00:39:36.620 --> 00:39:39.890
So if, for example,
you wanted to override accessors

00:39:39.890 --> 00:39:43.130
to add some custom behavior,
or if you wanted to add some other sort

00:39:43.250 --> 00:39:47.100
of business logic to your model layer,
you can do that.

00:39:47.440 --> 00:39:49.560
Now, the other thing that you
can do is actually leverage

00:39:49.670 --> 00:39:51.040
things like change tracking.

00:39:51.040 --> 00:39:53.670
So, for example,
your different managed objects

00:39:53.710 --> 00:39:57.460
can observe each other using KVO,
or you might have a controller layer

00:39:57.460 --> 00:40:01.540
that decides that it wants to observe
some of your individual managed objects.

00:40:01.540 --> 00:40:05.670
But you can also register
for graph level changes,

00:40:05.680 --> 00:40:09.560
and this is knowing when all of your
objects at a high level have changed.

00:40:09.560 --> 00:40:13.080
So, for example,
NSManagedObjectContext has

00:40:13.120 --> 00:40:16.750
a didSave notification,
so you can know when data has

00:40:16.750 --> 00:40:19.350
been pushed down to the database,
and you can find out

00:40:19.700 --> 00:40:21.050
exactly what's changed.

00:40:21.060 --> 00:40:25.770
There's also a didUpdate notification,
so you can simply find out when

00:40:25.770 --> 00:40:28.860
any object that the context
knows about has changed.

00:40:29.000 --> 00:40:31.650
Now,
if you go and you use that notification,

00:40:31.660 --> 00:40:34.800
do be aware that it's something
that you'll want to turn off,

00:40:34.890 --> 00:40:37.780
say, as you're batch importing
a whole bunch of data,

00:40:37.850 --> 00:40:38.740
for example.

00:40:40.600 --> 00:40:44.900
Now, when it comes to displaying data,
Core Data can also help you out as well.

00:40:45.010 --> 00:40:47.200
So, if we look at something
like UI Table View,

00:40:47.200 --> 00:40:49.460
it's usually pretty
straightforward to work with,

00:40:49.590 --> 00:40:49.740
right?

00:40:49.740 --> 00:40:53.840
You've just got a list of data,
ultimately, that you want to display.

00:40:54.030 --> 00:40:57.140
Now,
that data might be divided into sections,

00:40:57.140 --> 00:41:00.760
depending on what you want to show,
but that's sort of where things

00:41:00.860 --> 00:41:02.740
begin to get complicated,
right?

00:41:02.840 --> 00:41:05.390
So, how many sections do you have?

00:41:05.550 --> 00:41:08.410
How many objects are in
each one of those sections?

00:41:08.580 --> 00:41:11.800
And what are the different sections
in the first place that you can do

00:41:11.800 --> 00:41:16.840
something like construct that index on
the right-hand side of the Table View?

00:41:16.940 --> 00:41:21.160
Well, this is exactly something that
Core Data can help you out with.

00:41:21.270 --> 00:41:25.440
And it does that through a class
called the NSFetchResultsController.

00:41:25.620 --> 00:41:28.200
Now,
the NSFetchResultsController fetches,

00:41:28.280 --> 00:41:32.440
orders, and sections your data for you,
and it really integrates

00:41:32.440 --> 00:41:34.700
seamlessly with UI Table View.

00:41:34.830 --> 00:41:38.430
Now, it also caches section information
for you for ultra-fast.

00:41:38.560 --> 00:41:41.460
So, what is this caching
that I'm talking about?

00:41:41.460 --> 00:41:44.500
Well, in order to build that
sectioning information,

00:41:44.500 --> 00:41:47.600
basically that index that you have
on the side of the Table View,

00:41:47.600 --> 00:41:49.310
that takes a lot of time.

00:41:49.320 --> 00:41:53.250
I worked with someone earlier in our
tech talks who had a SQLite database

00:41:53.620 --> 00:41:56.940
that had 10,000 different rows in it,
and they wanted to display

00:41:56.940 --> 00:41:58.200
these in a Table View.

00:41:58.200 --> 00:42:00.120
Now,
aside from the fact that that's a lot

00:42:00.240 --> 00:42:03.910
of data to display in a Table View,
it also takes a lot of time to iterate

00:42:03.960 --> 00:42:08.410
through all the different objects there,
figure out, say, what the function is,

00:42:08.420 --> 00:42:11.920
what the first letter is of the attribute
that you want to actually display,

00:42:11.920 --> 00:42:15.680
and then figure out then what are
the different sections that exist.

00:42:15.680 --> 00:42:18.480
Now, you could write all that code,
but it's kind of tedious,

00:42:18.480 --> 00:42:21.320
and it's not something that
probably you want to maintain.

00:42:21.340 --> 00:42:25.820
So, this is something that the
FetchResultsController does for you.

00:42:25.820 --> 00:42:28.580
Now,
working with the FetchResultsController

00:42:28.690 --> 00:42:30.260
is really pretty simple.

00:42:30.260 --> 00:42:33.520
You simply need to create
a FetchResultsController.

00:42:33.520 --> 00:42:36.530
Usually, you do that in something
like your ViewController,

00:42:36.640 --> 00:42:40.880
for example, the same thing that we'll be
talking to the Table View.

00:42:40.980 --> 00:42:44.710
In that FetchResultsController,
you want to set the fetch request to use,

00:42:45.060 --> 00:42:47.440
the predicate,
and then any sort descriptors,

00:42:47.440 --> 00:42:51.630
so anything that controls how
you want that information sorted.

00:42:51.860 --> 00:42:54.860
Next,
you want to set yourself as the delegate

00:42:54.860 --> 00:42:56.890
for that fetch results controller.

00:42:56.940 --> 00:43:00.990
And then you simply need to implement
the table view methods as normal.

00:43:00.990 --> 00:43:04.780
And now, whenever you're asked for data,
you'll simply consult the fetch

00:43:04.780 --> 00:43:07.960
results controller for the
individual data that you need.

00:43:07.960 --> 00:43:10.650
And it'll handle all
of the loading for you.

00:43:11.760 --> 00:43:15.400
Now, the best part about all of
this is that it's all handled

00:43:15.400 --> 00:43:16.700
for you in the templates.

00:43:16.700 --> 00:43:21.700
So if you go into Xcode and you select
the navigation style template and

00:43:21.700 --> 00:43:25.700
check that use Core Data checkbox,
all of this gets set up for you.

00:43:25.700 --> 00:43:29.900
And you can customize it
right away to your needs.

00:43:30.540 --> 00:43:33.450
Now when you want to break this
data up into different sections,

00:43:33.490 --> 00:43:36.360
the Fetch Results Controller also
helps you out with that.

00:43:36.400 --> 00:43:39.930
And you do that by simply specifying
the key path on the object

00:43:39.930 --> 00:43:44.090
you're fetching that you want
to be used as the section name.

00:43:44.360 --> 00:43:48.590
Now the Fetch Results Controller will
go ahead and compute and persistently

00:43:48.590 --> 00:43:50.910
store all of the cache information.

00:43:51.130 --> 00:43:54.950
It'll update this any time it
sees any of your objects change.

00:43:54.990 --> 00:43:58.260
It does this by observing
the managed object context.

00:43:58.260 --> 00:44:04.260
And as you edit your objects, make saves,
etc., it'll update its cache so that you

00:44:04.260 --> 00:44:06.130
never actually have to worry about it.

00:44:06.260 --> 00:44:09.290
Now it's important to note
that in order to do this,

00:44:09.290 --> 00:44:13.900
the Fetch Results Controller will load
all of your data on first start in

00:44:13.900 --> 00:44:16.390
order to compute that section cache.

00:44:16.500 --> 00:44:19.340
Once it's done that,
it'll never have to load

00:44:19.440 --> 00:44:21.010
all of it ever again.

00:44:21.020 --> 00:44:24.750
In this case, that's when it can simply
start observing your objects.

00:44:24.880 --> 00:44:28.240
So on first launch,
be prepared to have a little bit higher

00:44:28.240 --> 00:44:33.140
memory usage depending on how much
data you're initially shipping with.

00:44:33.400 --> 00:44:37.040
Now it's important to note when you're
building this sectioning information

00:44:37.400 --> 00:44:41.640
that the fetch request and the predicate
on the fetch results controller

00:44:42.050 --> 00:44:44.020
should be treated as immutable.

00:44:44.020 --> 00:44:47.270
So you shouldn't be trying to
alter these two different values

00:44:47.270 --> 00:44:50.880
really at any time as you're using
the fetch results controller.

00:44:50.880 --> 00:44:54.390
If you do that and you
have the caching turned on,

00:44:54.390 --> 00:44:57.720
which it is by default,
the fetch results controller

00:44:57.720 --> 00:45:00.890
is going to think that it needs
to refetch all of your data and

00:45:00.920 --> 00:45:03.420
rebuild that entire section cache.

00:45:03.420 --> 00:45:08.450
Now the way to avoid that is to
simply set the cache name to nil.

00:45:08.450 --> 00:45:11.140
That'll prevent it from trying to
write this information out to disk.

00:45:11.140 --> 00:45:14.920
It'll also prevent it from trying to
do the calculation in the first case.

00:45:16.490 --> 00:45:19.000
Now, if you want to do something
like support a search-style

00:45:19.000 --> 00:45:22.510
interface in your application,
generally the way to do that is to

00:45:22.580 --> 00:45:24.980
create a second fetch results controller.

00:45:24.980 --> 00:45:28.120
And if you set that cache name to nil,
then at that point,

00:45:28.120 --> 00:45:31.880
you can alter that fetch request
or that predicate and continue

00:45:31.880 --> 00:45:35.540
to refetch your data without
any sort of performance impact.

00:45:37.540 --> 00:45:40.260
Okay,
so that was working with table views.

00:45:40.330 --> 00:45:42.560
Now let's talk about threading.

00:45:42.780 --> 00:45:44.290
And first,
we're going to start off with some of

00:45:44.290 --> 00:45:46.500
the rules of the road for threading.

00:45:46.660 --> 00:45:51.110
So at a very basic and high level,
the rules are simply practicing

00:45:51.200 --> 00:45:53.140
safe object ownership.

00:45:53.140 --> 00:45:57.460
This is the case for any kind of
threading that you might try to do.

00:45:57.660 --> 00:46:02.400
Now Core Data accomplishes this
by using a policy of isolation.

00:46:02.540 --> 00:46:06.480
And it isolates based on
the managed object context.

00:46:06.630 --> 00:46:13.270
And so the idea is that you want to have
one managed object context per thread.

00:46:13.480 --> 00:46:17.050
Now, this is very key because a
managed object context is going

00:46:17.050 --> 00:46:19.400
to be talking to your database,
it's going to be managing

00:46:19.400 --> 00:46:22.300
a whole bunch of objects,
and you don't want to end up in

00:46:22.300 --> 00:46:24.150
race conditions between threads.

00:46:24.200 --> 00:46:27.310
Now,
once you have one of these managed object

00:46:27.320 --> 00:46:31.600
contexts commit its data to the database,
you'll want to do something

00:46:31.600 --> 00:46:34.710
like post a notification to the
main thread that simply says,

00:46:34.830 --> 00:46:38.790
hey, changes have been made,
go re-sync your view of the world.

00:46:40.620 --> 00:46:44.300
So if we look at isolation in practice,
really for any kind of threading,

00:46:44.300 --> 00:46:48.690
it's all about avoiding race conditions,
times where you've got multiple

00:46:48.690 --> 00:46:51.610
threads trying to write to
the same addresses in memory.

00:46:51.620 --> 00:46:53.820
So a couple rules here.

00:46:54.210 --> 00:46:58.780
First, never try to pass managed
objects between threads.

00:46:58.780 --> 00:46:59.820
Just don't do it.

00:47:00.050 --> 00:47:01.700
There are much better
ways to go about it.

00:47:02.000 --> 00:47:05.080
This is going to be an area that
really will only bring you lots

00:47:05.080 --> 00:47:08.510
of tedium and probably lots of
errors in how you go about it.

00:47:08.610 --> 00:47:09.920
So just don't do it.

00:47:10.500 --> 00:47:14.710
Now, in general, if you want to pull some
information out of a managed object,

00:47:14.710 --> 00:47:18.050
like a string, a date, some data,
etc., that's fine to

00:47:18.060 --> 00:47:19.440
pass between threads.

00:47:19.440 --> 00:47:23.290
And just the usual rules around
basic threading good practice apply.

00:47:23.300 --> 00:47:27.660
So make sure that you properly hand this
data off from thread one to thread two.

00:47:27.660 --> 00:47:31.640
Now, if you want to actually
work with managed objects,

00:47:31.640 --> 00:47:35.760
the way to pass them between
threads is with object IDs.

00:47:35.760 --> 00:47:40.460
These are unique identifiers for each
and every individual managed object.

00:47:40.460 --> 00:47:44.410
And all you need to do is basically
just pass these IDs to your second

00:47:44.410 --> 00:47:46.850
thread as you begin to work with them.

00:47:46.880 --> 00:47:49.760
So let's take a look at
how to actually do this.

00:47:49.760 --> 00:47:54.030
And we're going to start off by
taking a look at the wrong way first.

00:47:54.040 --> 00:47:58.760
So the wrong way would be to create
our second thread and to try to simply

00:47:58.760 --> 00:48:03.270
make a copy of our managed object
context and its associated data and

00:48:03.340 --> 00:48:05.600
just pass it over to thread two.

00:48:05.600 --> 00:48:08.580
Now, again, why is this the wrong way?

00:48:08.580 --> 00:48:13.000
Well, let's take a look at... ...a
particular situation that might arise.

00:48:13.230 --> 00:48:17.660
So let's say that we wanted to now set
one of our albums on thread two to the

00:48:17.660 --> 00:48:22.290
title of "First Gear." But on thread one,
we wanted to set this

00:48:22.290 --> 00:48:26.880
ultimately same album to a
title of "Cardinal Song." Well,

00:48:26.880 --> 00:48:29.550
as we set both of those
in at the same time,

00:48:29.550 --> 00:48:31.350
what actually happened?

00:48:31.460 --> 00:48:33.090
Which one of those won?

00:48:33.290 --> 00:48:35.770
We're ultimately still
talking to the same object.

00:48:35.890 --> 00:48:38.430
I'm not sure which one
that would end up as.

00:48:38.460 --> 00:48:40.340
Would it be some crazy
combination of the two?

00:48:40.380 --> 00:48:43.900
Because we forgot to put in our own
threading protection around that setter?

00:48:43.900 --> 00:48:44.890
Hard to say.

00:48:44.950 --> 00:48:49.320
Now, what happens if we decide then
on thread two that we want to

00:48:49.320 --> 00:48:51.850
actually go and delete the object?

00:48:51.900 --> 00:48:56.120
And now let's say we want to
go ahead and tell both of these

00:48:56.120 --> 00:48:57.900
managed object contexts to save.

00:48:57.900 --> 00:48:59.900
What would happen?

00:48:59.900 --> 00:49:01.900
I certainly don't know.

00:49:01.900 --> 00:49:04.190
We'd probably end up with
some sort of inconsistent or

00:49:04.240 --> 00:49:05.900
inaccurate data in our database.

00:49:05.900 --> 00:49:09.900
And this is exactly the kind of
situation that you want to avoid.

00:49:09.900 --> 00:49:11.790
to avoid.

00:49:12.040 --> 00:49:15.230
So let's take a look at
doing this the right way.

00:49:15.350 --> 00:49:21.680
So the right way on thread two is to
create that new managed object context.

00:49:21.760 --> 00:49:25.320
And then to tell that managed
object context what object

00:49:25.410 --> 00:49:28.280
IDs we'd like it to fetch.

00:49:28.450 --> 00:49:32.080
Now, once you've done that and you've
gotten a bunch of objects back,

00:49:32.150 --> 00:49:36.020
you have the opportunity to
work with them as you please.

00:49:36.020 --> 00:49:40.200
So you can create, delete, modify,
et cetera.

00:49:40.270 --> 00:49:44.440
And once you save that information out,
you'll be able to get a list of

00:49:44.440 --> 00:49:49.340
the changed object IDs that you
can either pass back to thread one,

00:49:49.410 --> 00:49:52.510
or you can simply tell thread one, hey,
go back to the database,

00:49:52.520 --> 00:49:56.660
go refresh your view of the world,
and represent that to the user.

00:49:56.760 --> 00:49:59.370
So again, create that second mock.

00:49:59.610 --> 00:50:03.880
You can do that through simply talking
to the persistence store coordinator and

00:50:03.880 --> 00:50:06.350
asking for a new managed object context.

00:50:06.590 --> 00:50:09.520
And mocks, again, are very,
very cheap and easy to create.

00:50:09.560 --> 00:50:10.200
So don't worry.

00:50:10.200 --> 00:50:13.180
about any overhead on
that side of things.

00:50:13.910 --> 00:50:16.640
All right,
so in terms of working with UIKit,

00:50:16.770 --> 00:50:19.240
we took a look at working with
the Fetch Results Controller,

00:50:19.240 --> 00:50:22.520
and again, it's fast, it's efficient,
it's easy to use.

00:50:22.520 --> 00:50:25.290
And finally,
if you remember nothing else,

00:50:25.290 --> 00:50:29.740
when you're threading,
use different mocks on different threads.

00:50:29.740 --> 00:50:31.600
You need to make sure that you do that.

00:50:33.130 --> 00:50:35.040
All right,
so we took a look at structuring

00:50:35.040 --> 00:50:37.600
your data for efficient access.

00:50:37.680 --> 00:50:41.790
We took a look at actually fetching your
data and how you can do so efficiently.

00:50:41.990 --> 00:50:46.600
And finally, we saw how you can integrate
directly with UIKit.

00:50:46.800 --> 00:50:51.540
As always, if you have any questions,
you can reach me at jurewitz@apple.com,

00:50:51.540 --> 00:50:56.410
or you can consult the iPhone
Dev Center at developer.apple.com/iphone.
WEBVTT

00:00:22.470 --> 00:00:26.370
I'm Jake Behrens,
Apple's UI Frameworks Evangelist.

00:00:26.470 --> 00:00:30.510
Adding Location Awareness to
your iOS application can make for

00:00:30.510 --> 00:00:33.210
some incredible user experiences.

00:00:33.410 --> 00:00:37.190
Today, you're going to learn how to
use region monitoring to create

00:00:37.230 --> 00:00:42.670
more personalized experiences
for your users using geofencing.

00:00:42.790 --> 00:00:45.930
Then,
you're going to learn about geocoding on

00:00:45.930 --> 00:00:51.960
iOS to display location-based information
in a meaningful way to your users.

00:00:52.160 --> 00:00:55.400
Finally,
you're going to see how to use Xcode and

00:00:55.400 --> 00:01:01.140
the iOS Simulator to make the most out of
testing your location-aware applications.

00:01:01.220 --> 00:01:03.100
Let's get started.

00:01:05.000 --> 00:01:08.260
Maybe you're displaying a map
that shows the user's location in

00:01:08.400 --> 00:01:12.420
relation to other points of interest,
or where their friends are.

00:01:12.620 --> 00:01:15.670
Or maybe you're using a set
of coordinates to display

00:01:15.670 --> 00:01:19.740
relevant information to the
user about where they are.

00:01:19.890 --> 00:01:25.210
Both of these user experiences make the
application more valuable to the user.

00:01:25.450 --> 00:01:29.090
But how do you take this
functionality farther?

00:01:30.060 --> 00:01:33.860
You make the experience more personal
and more meaningful to the user.

00:01:33.860 --> 00:01:37.820
Setting a reminder with Siri is
a great example of this.

00:01:37.820 --> 00:01:42.860
The reminder is more personal because
the user doesn't have to add an address,

00:01:43.160 --> 00:01:45.030
they just say work for the location.

00:01:45.030 --> 00:01:50.760
It's also more meaningful because work is
in a language that the user understands.

00:01:50.760 --> 00:01:53.590
If this phone's locale
was set to Germany,

00:01:53.590 --> 00:01:58.090
the text would also be in German,
meaning that the user doesn't have

00:01:58.090 --> 00:01:59.880
to guess at what this information is.

00:01:59.900 --> 00:02:02.210
represents.

00:02:04.000 --> 00:02:08.620
One more important aspect of
location-aware applications is testing.

00:02:08.730 --> 00:02:12.630
You need to test your application
to make sure that the experience

00:02:12.740 --> 00:02:16.660
is great the first time a user
launches your application.

00:02:16.950 --> 00:02:21.980
You need to test not only where you are,
though, but other places your users

00:02:21.980 --> 00:02:24.140
will use the application in.

00:02:24.220 --> 00:02:28.600
You want to ensure a great
experience for everyone.

00:02:30.080 --> 00:02:34.240
So let's start with geofencing on iOS.

00:02:34.300 --> 00:02:39.760
If you haven't used geofencing,
you may be asking, what is geofencing?

00:02:39.820 --> 00:02:43.240
Geofencing is where you take
a point and you map this

00:02:43.390 --> 00:02:47.200
point to a physical location,
maybe on a map.

00:02:47.280 --> 00:02:51.600
Then you use that point as a center
coordinate for a virtual perimeter,

00:02:51.690 --> 00:02:53.130
a geofence.

00:02:53.330 --> 00:02:56.740
Then, when a user moves in or out
of this virtual perimeter,

00:02:57.030 --> 00:03:00.240
your application responds with an action.

00:03:00.420 --> 00:03:02.240
Let's see this in action.

00:03:02.400 --> 00:03:06.110
Once the user moves,
they end up reaching the bounds

00:03:06.320 --> 00:03:11.590
of a region and are prompted by an
application to conduct an action.

00:03:12.230 --> 00:03:16.680
A great example of this on iOS
5 is with the Reminders app.

00:03:16.930 --> 00:03:20.850
You can set a location and add a
geofence around it so that you're

00:03:20.850 --> 00:03:25.400
prompted to do something when
you either leave this geofence,

00:03:25.400 --> 00:03:27.200
the virtual perimeter,
or when you enter it.

00:03:27.200 --> 00:03:33.190
You can see here I've set a reminder
for when I leave my current location.

00:03:34.120 --> 00:03:39.680
You create geofences using the
Region Monitoring API on iOS 5.

00:03:39.820 --> 00:03:43.630
This API allows you to register regions,
these virtual perimeters,

00:03:43.940 --> 00:03:45.880
using a coordinate and a radius.

00:03:45.880 --> 00:03:50.790
Then your application can receive
a callback when the user enters

00:03:51.030 --> 00:03:53.200
or exits a specific geofence.

00:03:53.780 --> 00:03:57.650
Some of you may be saying,
"We've had region monitoring

00:03:57.650 --> 00:04:00.450
on iOS 4." And you're right,
we did.

00:04:00.660 --> 00:04:03.690
But on iOS 4,
we used cell towers as our way

00:04:03.690 --> 00:04:08.340
of triangulating your position
and then firing region events.

00:04:08.750 --> 00:04:11.610
Well,
I'm happy to tell you that on iOS 5,

00:04:11.610 --> 00:04:14.960
we've added Wi-Fi and
GPS to the equation.

00:04:15.130 --> 00:04:19.450
So now we're using all available
hardware sensors to triangulate your

00:04:19.450 --> 00:04:23.660
position and provide much higher
accuracy for region monitoring.

00:04:23.890 --> 00:04:25.830
So what's new under iOS 5?

00:04:25.830 --> 00:04:27.440
Improved accuracy.

00:04:27.440 --> 00:04:30.740
Due to using all of the
sensors in your device,

00:04:30.750 --> 00:04:35.590
in some situations,
it can be up to 10 times more accurate.

00:04:35.730 --> 00:04:38.610
And I'm not talking about
newest hardware only.

00:04:38.610 --> 00:04:43.480
This is using the same hardware you've
been using region monitoring on already.

00:04:43.480 --> 00:04:47.310
We've just added more capabilities
for improved accuracy.

00:04:47.360 --> 00:04:51.190
We've also added some
more informational API.

00:04:51.240 --> 00:04:52.770
When you register regions,
we will look at the region monitoring

00:04:52.770 --> 00:04:53.720
and the region monitoring data.

00:04:53.720 --> 00:04:57.480
This will let you know what the
status is of that registration.

00:04:57.570 --> 00:05:01.520
So let's jump right into
setting up regions or geofences

00:05:01.520 --> 00:05:03.590
with region monitoring.

00:05:04.140 --> 00:05:08.240
As with other location services,
you first need to add the Core Location

00:05:08.370 --> 00:05:10.700
framework to your application.

00:05:10.770 --> 00:05:14.510
You'll also need to add a delegate
object that will receive the

00:05:14.510 --> 00:05:16.260
delegate callbacks later on.

00:05:16.320 --> 00:05:20.460
This is usually your app
delegate or a view controller.

00:05:20.500 --> 00:05:25.060
Then, you need to create a
SEAL Location Manager object.

00:05:25.130 --> 00:05:28.470
Now, I'm not going to go into too
much depth on how to set up and

00:05:28.570 --> 00:05:30.820
configure your Location Manager.

00:05:30.870 --> 00:05:34.740
This is a topic we've
discussed many times at WWDC,

00:05:34.800 --> 00:05:37.860
and if you've never used the
Core Location framework before,

00:05:37.930 --> 00:05:42.020
I highly suggest you read our
Location Awareness Programming

00:05:42.020 --> 00:05:47.820
Guide on the Developer Center or
watch previous WWDC sessions.

00:05:47.890 --> 00:05:50.780
Now, finally,
your delegate object needs to

00:05:50.780 --> 00:05:55.340
adhere to the SEAL Location
Manager delegate protocol.

00:05:55.410 --> 00:05:58.350
This makes sure that the
Location Manager can fire

00:05:58.350 --> 00:06:00.580
those delegate callbacks later.

00:06:00.660 --> 00:06:05.700
With that, you're ready to start creating
and registering regions.

00:06:06.800 --> 00:06:10.620
You also want to make sure that
you're checking to see if the device

00:06:10.620 --> 00:06:13.540
even allows for region monitoring.

00:06:13.690 --> 00:06:16.620
Some older devices don't,
so you need to check the

00:06:16.620 --> 00:06:21.420
Region Monitoring Available Boolean
on the Location Manager to make sure

00:06:21.420 --> 00:06:24.330
that you can start monitoring regions.

00:06:24.490 --> 00:06:27.810
Next,
you want to check what the authorization

00:06:27.810 --> 00:06:30.340
status is for location services.

00:06:30.550 --> 00:06:35.130
Users can set this in the Settings app,
and we'll talk later about the different

00:06:35.130 --> 00:06:37.800
values and what those can mean.

00:06:39.320 --> 00:06:43.150
You start creating a region by
creating a center coordinate.

00:06:43.270 --> 00:06:48.240
So here, you need to create a seal
location coordinate 2D with

00:06:48.240 --> 00:06:50.050
a latitude and longitude.

00:06:50.420 --> 00:06:54.130
Then,
you need to create a seal region object.

00:06:54.350 --> 00:06:58.320
You do this by calling init
circularRegionWithCenter,

00:06:58.320 --> 00:07:02.440
handing in that center
coordinate that you just created,

00:07:02.440 --> 00:07:07.200
radius, defining how big you want the
radius to be for this geofence.

00:07:07.200 --> 00:07:11.370
Now, we have some constants you can use,
but you can also just

00:07:11.370 --> 00:07:12.930
define this in meters.

00:07:13.200 --> 00:07:15.200
And finally, identifier.

00:07:15.200 --> 00:07:20.090
The identifier is a crucial
part of creating a region.

00:07:20.310 --> 00:07:23.200
It's not something that is going
to be displayed to the user,

00:07:23.200 --> 00:07:27.440
but it's a property on a region
that you can check when you

00:07:27.490 --> 00:07:31.200
get a seal region object passed
in with a delegate callback.

00:07:31.200 --> 00:07:35.200
This allows you to know which
region triggered the event,

00:07:35.200 --> 00:07:35.200
and then you can respond accordingly.

00:07:35.200 --> 00:07:37.130
So, here, we have a region with a
latitude and longitude.

00:07:37.220 --> 00:07:39.200
And here, we have a region with a
latitude and longitude.

00:07:39.200 --> 00:07:40.380
And here, we have a region with a
latitude and longitude.

00:07:41.430 --> 00:07:46.000
Finally, you can register the region
with Location Services by first

00:07:46.020 --> 00:07:51.410
creating the CLRegion object,
which you just did, and then you call

00:07:51.460 --> 00:07:55.710
startMonitoringForRegion,
handing in the region object

00:07:55.710 --> 00:07:57.140
that you just created.

00:07:57.140 --> 00:08:02.410
You call this on the Location Manager,
and it's going to talk to Location

00:08:02.420 --> 00:08:05.100
Services to register the region.

00:08:05.100 --> 00:08:07.150
So let's see that in action.

00:08:07.670 --> 00:08:10.680
When your delegate
object creates a region,

00:08:10.680 --> 00:08:14.260
that object is then handed
to the Location Manager to

00:08:14.260 --> 00:08:16.540
register with Location Services.

00:08:16.540 --> 00:08:21.090
The Location Manager then hands
that region object to Location

00:08:21.210 --> 00:08:23.500
Services to be registered.

00:08:23.500 --> 00:08:27.150
And finally,
Location Services hands the region

00:08:27.150 --> 00:08:32.450
object back to the Location Manager,
and the Location Manager hands that

00:08:32.450 --> 00:08:37.500
same region object back to the delegate
as a parameter of a delegation.

00:08:37.600 --> 00:08:38.420
get call back.

00:08:40.620 --> 00:08:43.300
If the region was
successfully registered,

00:08:43.420 --> 00:08:46.980
you will get the Location
Manager Did Start Monitoring

00:08:46.980 --> 00:08:48.410
for Region callback.

00:08:48.500 --> 00:08:54.100
You can then check that identifier
property of the region object and

00:08:54.100 --> 00:08:58.560
see which region was registered
with the OS so that you can

00:08:58.680 --> 00:09:00.430
update your UI if needed.

00:09:03.080 --> 00:09:05.840
In the event that the region
could not be registered,

00:09:05.890 --> 00:09:10.250
you're going to receive the Location
Manager "Monitoring did fail

00:09:10.260 --> 00:09:13.220
for region with error" callback.

00:09:13.270 --> 00:09:16.530
Again,
you can check the identifier of the

00:09:16.620 --> 00:09:22.940
passed-in CLRegion object to see which
region was unable to be registered.

00:09:23.170 --> 00:09:24.940
And that's it.

00:09:25.030 --> 00:09:27.660
That's all there is
to setting up regions.

00:09:27.730 --> 00:09:30.180
Now you wait for your user
to move around the world,

00:09:30.610 --> 00:09:33.260
and you'll be able to respond
to two different events.

00:09:33.260 --> 00:09:36.920
The first event is Location
Manager Did Enter Region.

00:09:37.070 --> 00:09:41.960
This means that the user has entered
the region you've registered.

00:09:41.960 --> 00:09:45.680
The second is Location
Manager Did Exit Region,

00:09:45.830 --> 00:09:49.350
meaning that the user
has left the region.

00:09:50.190 --> 00:09:54.810
Now both of these methods include the
Seal Region object so that you can,

00:09:54.950 --> 00:09:59.460
again, check the identifier of the
region and respond accordingly

00:09:59.460 --> 00:10:01.150
within your application.

00:10:03.480 --> 00:10:06.530
Now I mentioned earlier that you
need to check the authorization

00:10:06.530 --> 00:10:09.200
status when setting up regions.

00:10:09.270 --> 00:10:12.790
You can see here that the
application has prompted the user

00:10:13.040 --> 00:10:15.750
to use their current location.

00:10:15.950 --> 00:10:20.900
Now, this permission dialog will include
the name of your application.

00:10:20.960 --> 00:10:26.650
But you need to plan for the user tapping
"Don't allow." They may not know why your

00:10:26.650 --> 00:10:29.580
application wants to use their location.

00:10:29.650 --> 00:10:33.600
Maybe it's not obvious from the type
of application that they've downloaded

00:10:33.890 --> 00:10:36.860
that it needs to use location services.

00:10:36.930 --> 00:10:41.330
But this is your chance to be as
informative as you can to the user.

00:10:41.530 --> 00:10:46.860
Here what you can do is you can use the
Purpose property on the Location Manager.

00:10:46.950 --> 00:10:51.240
And the Purpose property allows
you to provide a string into the

00:10:51.240 --> 00:10:55.860
prompt and let the user know why
you need to use their location.

00:10:55.930 --> 00:10:59.630
Maybe it's because the application
isn't the type of application that would

00:10:59.630 --> 00:11:02.260
normally need to use location services.

00:11:02.340 --> 00:11:07.390
By using the Purpose property,
this allows you to give more information

00:11:07.420 --> 00:11:11.580
to the user and let them decide how
they want to respond to using their

00:11:11.580 --> 00:11:14.260
location within the application.

00:11:14.660 --> 00:11:17.330
Now,
once the user accepts to use location

00:11:17.330 --> 00:11:22.180
services within the application,
the user will see a purple arrow in

00:11:22.180 --> 00:11:28.480
the status bar when the application is
currently using their current location.

00:11:29.170 --> 00:11:34.070
The user can also go to Location
Services in the Settings app and change

00:11:34.070 --> 00:11:40.160
the location services for the device
overall or for individual applications.

00:11:40.230 --> 00:11:43.600
They have an enabled switch
for the device overall,

00:11:43.670 --> 00:11:46.970
but they can also see the
list of applications that

00:11:46.970 --> 00:11:49.060
want to use their location.

00:11:49.280 --> 00:11:52.940
Additionally,
they can turn location services

00:11:53.330 --> 00:11:55.380
on or off per application.

00:11:55.390 --> 00:11:59.740
And a location arrow lets them know
which applications have used their

00:11:59.870 --> 00:12:04.690
location information within the last
24 hours or which applications are

00:12:04.780 --> 00:12:07.020
currently using that information.

00:12:07.020 --> 00:12:12.260
If it's been used in the last 24 hours,
the location arrow will be gray.

00:12:12.260 --> 00:12:16.400
If the application is currently
using their location data,

00:12:16.400 --> 00:12:18.420
the arrow will be purple.

00:12:20.480 --> 00:12:24.390
You can check this authorization
status by checking the Authorization

00:12:24.390 --> 00:12:27.800
Status property on Location Manager.

00:12:27.890 --> 00:12:32.120
You can also respond to the Location
Manager did change authorization

00:12:32.190 --> 00:12:36.580
status delegate callback when
the user changes their options.

00:12:36.840 --> 00:12:40.360
These are the authorization
statuses available.

00:12:40.460 --> 00:12:44.980
Not determined means that the
application can use location services

00:12:45.620 --> 00:12:48.520
and the user hasn't been prompted yet.

00:12:48.620 --> 00:12:54.220
So you can try to use their location and
the user will be prompted at that time.

00:12:54.300 --> 00:12:57.120
Additionally,
authorized means that they've

00:12:57.120 --> 00:13:01.720
tapped OK and the application
can use location services.

00:13:01.890 --> 00:13:06.160
Denied means that they've either tapped
Don't Allow for your application,

00:13:06.230 --> 00:13:09.000
switched it off in
location service settings,

00:13:09.050 --> 00:13:11.790
or they've turned it off
for all applications.

00:13:11.800 --> 00:13:15.620
Now, whether they've turned it
off for just your application

00:13:15.620 --> 00:13:19.130
or for the device overall,
the end result is the same,

00:13:19.130 --> 00:13:21.970
and you should just respond accordingly.

00:13:23.450 --> 00:13:27.390
Finally, there's restricted,
which means that the user can't

00:13:27.480 --> 00:13:29.050
authorize the application.

00:13:29.050 --> 00:13:33.610
Now, this would be in a situation where
maybe due to parental controls,

00:13:33.610 --> 00:13:38.460
the user is not able to actually
change location service settings.

00:13:38.490 --> 00:13:41.620
So in this case,
you don't want to hound them to change

00:13:41.860 --> 00:13:44.010
their settings because they can't.

00:13:44.010 --> 00:13:46.390
You should just do the right thing.

00:13:48.530 --> 00:13:51.920
So as I said, you want to make sure that
you do the right thing for

00:13:51.920 --> 00:13:53.520
when users tap Don't Allow.

00:13:53.520 --> 00:13:58.880
Your app needs to continue to function
and not just sit at a blank screen if

00:13:58.880 --> 00:14:01.240
the user declines location services.

00:14:01.410 --> 00:14:06.240
You also need to make sure that the
application will degrade gracefully and

00:14:06.450 --> 00:14:10.630
still continue to work for the parts
that don't require location services.

00:14:10.640 --> 00:14:15.920
And then you want to make the user aware
of the limitations of their choice.

00:14:16.730 --> 00:14:21.680
If your application requires
location services to have any value,

00:14:21.880 --> 00:14:23.280
you need to let them know.

00:14:23.490 --> 00:14:25.360
But let them know in a subtle way.

00:14:25.470 --> 00:14:27.820
You don't want to do this
in the form of a prompt.

00:14:28.160 --> 00:14:30.970
You just want to do
this as part of your UI.

00:14:31.220 --> 00:14:35.200
Let them know in a meaningful
and non-obtrusive way.

00:14:36.700 --> 00:14:41.240
Region monitoring also gives you
background updates automatically,

00:14:41.310 --> 00:14:44.770
even if your application
is not currently running.

00:14:45.020 --> 00:14:48.700
Typically, for background updates
with location services,

00:14:48.950 --> 00:14:52.800
you need to add the location
string to the UI background

00:14:52.810 --> 00:14:55.910
mode's key in the info.p list.

00:14:56.370 --> 00:15:01.750
If you're only using region monitoring,
though, this is not required.

00:15:02.100 --> 00:15:05.160
Your application, as I said,
will be launched into the

00:15:05.160 --> 00:15:07.170
background if an event comes in.

00:15:07.240 --> 00:15:12.620
So, when your application is woken up,
Application Did Finish Launching

00:15:12.620 --> 00:15:15.820
with Options will be called,
and you'll be handed a

00:15:16.120 --> 00:15:20.920
Launch Options Location Key that
tells you that your application has

00:15:20.920 --> 00:15:22.940
been woken up by a location event.

00:15:23.020 --> 00:15:28.130
However, don't use this to solely check
whether you need to set up

00:15:28.130 --> 00:15:30.420
a location manager or not.

00:15:30.890 --> 00:15:35.350
You should always have a location
manager set up if you're using

00:15:35.370 --> 00:15:37.480
any location-aware services.

00:15:37.480 --> 00:15:42.480
A situation that you could find
yourself in is where a region

00:15:42.480 --> 00:15:47.290
event has come in and the user
has just launched the application.

00:15:47.300 --> 00:15:50.820
If that happens,
the Location Key may not come in

00:15:50.820 --> 00:15:54.920
with Application Did Finish Launching
with Options.

00:15:54.940 --> 00:15:58.380
And in that case,
you want to make sure that your

00:15:58.460 --> 00:16:03.300
location manager still gets set
up so that you can receive events.

00:16:05.030 --> 00:16:06.660
Let's see how this works.

00:16:06.840 --> 00:16:11.900
What happens here is that you have the
system layer and location services.

00:16:12.050 --> 00:16:15.400
Now when a region is triggered,
location services says,

00:16:15.560 --> 00:16:19.890
"I have a region event." Then,
if your application is no longer running,

00:16:19.890 --> 00:16:23.900
it'll wake up the application
in the background.

00:16:24.070 --> 00:16:26.830
Now this is when you need to
set up your location manager.

00:16:27.050 --> 00:16:31.250
If your application wasn't running,
this may have been due to memory

00:16:31.420 --> 00:16:35.900
pressure on the OS and your
application was jettisoned,

00:16:35.980 --> 00:16:42.080
or maybe the user restarted their device
and hasn't run your application since.

00:16:42.320 --> 00:16:44.840
So now that you have your
Location Manager set up,

00:16:44.970 --> 00:16:50.190
then Location Services can hand over the
region event to the Location Manager,

00:16:50.240 --> 00:16:54.260
and the Location Manager can
fire a delegate callback with the

00:16:54.260 --> 00:16:56.980
region that triggered the event.

00:16:57.560 --> 00:17:00.980
If you don't have the
Location Manager set up,

00:17:01.080 --> 00:17:05.400
what happens is that the region
event starts with Location Services,

00:17:05.470 --> 00:17:09.100
moves to your application,
but then the manager

00:17:09.140 --> 00:17:13.070
isn't there to respond,
and so the region event just goes away.

00:17:13.070 --> 00:17:18.460
And it seems as if your application
is no longer getting region events.

00:17:20.730 --> 00:17:25.040
Now something that I've had many people
ask about is what the battery consumption

00:17:25.040 --> 00:17:27.240
is like using region monitoring.

00:17:27.380 --> 00:17:30.050
Well, I'm happy to tell you that
battery consumption for

00:17:30.120 --> 00:17:32.520
region monitoring is minimal.

00:17:32.660 --> 00:17:37.630
This is because we use all location data
coming into the device to determine if

00:17:37.630 --> 00:17:41.030
a region has been entered or exited.

00:17:41.180 --> 00:17:44.960
Even if another application
is using Core Location,

00:17:45.070 --> 00:17:50.140
any location data will also be used
to figure out if a region event

00:17:50.140 --> 00:17:53.100
for your application has occurred.

00:17:53.580 --> 00:17:57.240
You want to create a great user
experience using region monitoring.

00:17:57.240 --> 00:18:01.020
Some ways to increase this user
experience is by monitoring

00:18:01.020 --> 00:18:03.240
regions that are appropriate.

00:18:03.240 --> 00:18:09.000
Now, maybe I own a coffee shop,
and when the user launches my app,

00:18:09.130 --> 00:18:12.190
I want to register some
regions to let users know when

00:18:12.190 --> 00:18:14.240
they're near one of my shops.

00:18:14.240 --> 00:18:17.100
The problem is,
I don't want to register all

00:18:17.100 --> 00:18:20.820
1,000 locations because that's
not meaningful to the user.

00:18:20.820 --> 00:18:24.800
What you want to do is maybe
grab their current location and

00:18:24.900 --> 00:18:28.280
then decide which regions would
be most appropriate to monitor,

00:18:28.280 --> 00:18:32.360
or even let the user decide
which locations they care about.

00:18:32.360 --> 00:18:37.110
You want to ensure that you're not
inundating the user with prompts for

00:18:37.200 --> 00:18:39.260
things that they don't care about.

00:18:39.260 --> 00:18:43.840
Now, remember that your application
has a limit to how many regions

00:18:43.840 --> 00:18:45.450
it can set up at one time.

00:18:45.770 --> 00:18:50.040
This means that you may want to
see which regions you're currently

00:18:50.040 --> 00:18:52.200
monitoring from time to time.

00:18:52.200 --> 00:18:57.600
You can do this using the monitored
regions property of the location manager.

00:18:57.850 --> 00:19:01.760
This gives you an NS set of CL region
objects that you can iterate

00:19:01.760 --> 00:19:04.030
through and check their identifiers.

00:19:04.040 --> 00:19:08.100
Additionally,
if you find a region that you

00:19:08.100 --> 00:19:13.030
don't need to monitor anymore,
you can then call stop monitoring for

00:19:13.030 --> 00:19:18.770
region on the location manager and
pass in the CL region you want removed.

00:19:18.960 --> 00:19:22.500
This will free up another spot
for another region and ensure that

00:19:22.550 --> 00:19:23.160
you're not inundating the region.

00:19:23.160 --> 00:19:28.280
Now, when monitoring large regions,
the first thing you want to

00:19:28.280 --> 00:19:32.770
do is check what the maximum
region monitoring distance is.

00:19:32.800 --> 00:19:36.520
This will ensure that you
can still monitor the large

00:19:36.520 --> 00:19:37.910
region that you want to.

00:19:38.260 --> 00:19:43.230
If your region radius is larger
than this maximum distance,

00:19:43.420 --> 00:19:46.360
then the registration will fail.

00:19:47.790 --> 00:19:52.500
So as you've seen,
region monitoring is very easy to set up.

00:19:52.570 --> 00:19:56.120
You saw that it takes very
little to get up and going.

00:19:56.270 --> 00:20:00.820
It also makes for very personal
experiences because these are locations

00:20:00.820 --> 00:20:04.330
that the user is used to moving
between within their daily life.

00:20:05.580 --> 00:20:09.940
Finally, you want to respect user choices
when it comes to authorization.

00:20:09.940 --> 00:20:13.780
You don't want to hound the
user to make certain choices,

00:20:13.780 --> 00:20:17.840
and you don't want to make your
application non-responsive if they

00:20:17.840 --> 00:20:20.470
decide not to allow location services.

00:20:20.470 --> 00:20:24.260
You want to do the best thing
that you can for your user.

00:20:25.850 --> 00:20:29.080
Next, let's talk about geocoding.

00:20:29.200 --> 00:20:33.550
We've introduced a lot of new
features for geocoding under iOS 5.

00:20:33.640 --> 00:20:38.640
Now, most people don't think about
locations in the form of coordinates.

00:20:38.740 --> 00:20:41.670
They don't say, "Oh,
I know where that coordinate is.

00:20:41.910 --> 00:20:45.160
It's two blocks to the left
and north just a bit." But an

00:20:45.630 --> 00:20:48.520
address is more meaningful,
and a lot more people

00:20:48.520 --> 00:20:50.820
understand what an address is.

00:20:51.510 --> 00:20:56.340
But if you've never been to Cupertino,
California, maybe you don't know what

00:20:56.340 --> 00:20:57.580
this address represents.

00:20:57.690 --> 00:21:00.960
So how can you make this even
more meaningful to a user?

00:21:00.960 --> 00:21:04.800
Well, maybe just by telling them
that it's a point of interest.

00:21:04.800 --> 00:21:11.170
This helps them get their bearings and
understand what this location means.

00:21:11.520 --> 00:21:13.400
So why would you geocode?

00:21:13.640 --> 00:21:17.870
Well, you want to describe a location
in a meaningful way to the user.

00:21:17.870 --> 00:21:24.060
You want to provide them more meaningful
information about a location other than

00:21:24.060 --> 00:21:26.440
just a set of coordinates or an address.

00:21:27.300 --> 00:21:30.480
You also want to make sure that
you deliver information in a

00:21:30.660 --> 00:21:32.420
way that they can understand.

00:21:32.420 --> 00:21:36.100
And this usually means in the
language of which they speak.

00:21:36.100 --> 00:21:39.880
You want to make sure that this
information is localized to

00:21:39.880 --> 00:21:42.020
match their device's locale.

00:21:42.020 --> 00:21:46.210
This is how they consume
information on their device.

00:21:46.800 --> 00:21:49.060
So what's new in iOS 5?

00:21:49.210 --> 00:21:51.360
We have reverse geocoding.

00:21:51.360 --> 00:21:55.380
And we've had reverse geocoding before,
for those of you who have used it,

00:21:55.490 --> 00:21:57.910
but we've done a whole
lot of changes to it,

00:21:57.930 --> 00:22:01.710
and we've actually moved it out of
the MapKit framework and moved it

00:22:01.710 --> 00:22:04.220
into the Core Location framework.

00:22:04.370 --> 00:22:07.450
Then, we've introduced forward geocoding.

00:22:07.560 --> 00:22:12.100
So now you can do reverse
and forward geocoding.

00:22:12.330 --> 00:22:16.110
Then, we've made the results
match your device's locale.

00:22:16.420 --> 00:22:20.250
Whatever locale your device is
set to is how the information

00:22:20.250 --> 00:22:22.260
from a geocode will return.

00:22:22.290 --> 00:22:24.970
This does a lot of work for you.

00:22:25.680 --> 00:22:29.160
Now for those of you who
haven't used geocoding before,

00:22:29.160 --> 00:22:33.600
a reverse geocode is where you
transform a coordinate into an address.

00:22:33.600 --> 00:22:39.610
Conversely, a forward geocode turns an
address into a coordinate,

00:22:39.750 --> 00:22:44.360
a latitude and longitude value that
you can use to plot on a map or

00:22:44.560 --> 00:22:46.580
use to display data to the user.

00:22:46.700 --> 00:22:51.560
We do this using the new
CL Geocoder class in iOS 5.

00:22:52.600 --> 00:22:56.840
The new CL Geocoder does both
forward and reverse geocoding.

00:22:57.000 --> 00:22:59.920
And this is a fully asynchronous API.

00:23:00.100 --> 00:23:06.740
If you need to do more than one request,
then just create additional CL Geocoders.

00:23:08.310 --> 00:23:14.780
Finally, this is a network-based service,
so it does require a network connection.

00:23:16.120 --> 00:23:19.750
Now, some great enhancements that
we've done to geocoding is that

00:23:19.750 --> 00:23:22.160
a map is no longer necessary.

00:23:22.330 --> 00:23:25.040
You can display this
data however you want.

00:23:25.190 --> 00:23:29.680
This also means that it
deprecates MK Reverse Geocoder.

00:23:29.680 --> 00:23:34.400
But for those of you who have
been using it with MK placemarks,

00:23:34.510 --> 00:23:38.980
those now inherit from the new
CL placemark so that you can still

00:23:38.980 --> 00:23:41.980
plot these results on a map with ease.

00:23:42.410 --> 00:23:45.570
The other new class we
have is CL Placemark.

00:23:45.700 --> 00:23:49.230
This is how your geocoding
request results will be returned.

00:23:49.300 --> 00:23:53.300
A CL Placemark contains
location information,

00:23:53.300 --> 00:23:58.430
region information,
address dictionaries of the location,

00:23:58.570 --> 00:24:00.300
and descriptive properties.

00:24:00.310 --> 00:24:03.100
Now these descriptive
properties are really great.

00:24:03.250 --> 00:24:07.300
They're properties such as inland water,
so if you're on a lake,

00:24:07.300 --> 00:24:09.160
it can give you the name of a lake.

00:24:09.390 --> 00:24:13.300
If you're on an ocean,
it'll give you the name of the ocean.

00:24:13.300 --> 00:24:15.240
And of course, you still need to have
a network connection,

00:24:15.360 --> 00:24:17.300
so keep that in mind.

00:24:17.300 --> 00:24:21.100
And then you can also get this
areas of interest property.

00:24:21.300 --> 00:24:24.160
Like at the beginning,
you saw that I turned one

00:24:24.160 --> 00:24:27.240
infinite loop into Apple Inc.

00:24:27.620 --> 00:24:33.270
This is the kind of information that you
can get out of your geocoding results.

00:24:33.410 --> 00:24:38.500
Now you can see here I've done a
reverse geocode on one infinite loop.

00:24:38.500 --> 00:24:42.820
And you can see that we get a lot of
information like the sub-Thoroughfare,

00:24:42.820 --> 00:24:46.930
which is the building number,
the thoroughfare, which is the street,

00:24:47.010 --> 00:24:50.290
and more additional information
such as postal code,

00:24:50.510 --> 00:24:54.350
country,
and that areas of interest property.

00:24:54.930 --> 00:24:58.240
So how do you actually use CL Geocoder?

00:24:58.410 --> 00:25:02.020
Well,
first you create a CL Geocoder object,

00:25:02.020 --> 00:25:06.990
and then you call one of the reverse
or forward geocoding methods.

00:25:07.160 --> 00:25:11.400
These methods include a completion
handler that you define so that

00:25:11.400 --> 00:25:16.750
you can execute some code once the
geocoding request has returned.

00:25:17.080 --> 00:25:20.340
The completion handler is
in the form of a block.

00:25:20.450 --> 00:25:25.400
And this handler will return an array
of sealed placemarks on success,

00:25:25.480 --> 00:25:26.990
and these are sorted by confidence.

00:25:27.000 --> 00:25:30.700
Based on the information
that our geocoder receives,

00:25:30.700 --> 00:25:35.000
we may have found several
locations that we think will work.

00:25:35.000 --> 00:25:37.650
So they will be sorted by
how confident we are that the

00:25:37.920 --> 00:25:39.960
result is what you wanted.

00:25:40.000 --> 00:25:45.000
Now, if no result could be found,
we're going to return nil.

00:25:45.630 --> 00:25:52.580
Additionally, if an error occurred,
an NSError will be returned on failure.

00:25:52.810 --> 00:25:55.660
So, why might a geocode fail?

00:25:55.810 --> 00:25:59.050
Well, if you have a way for the
user to cancel the request,

00:25:59.050 --> 00:26:00.910
maybe they've done just that.

00:26:00.980 --> 00:26:06.700
You can use the cancelGeocode
method and cancel a current request.

00:26:07.270 --> 00:26:10.520
Additionally, there could be no
results for the geocode.

00:26:10.630 --> 00:26:13.820
Geocoding also requires
a network connection,

00:26:13.820 --> 00:26:15.410
as I mentioned earlier.

00:26:15.740 --> 00:26:19.700
So, if there's a network error,
you may not get a result.

00:26:19.700 --> 00:26:22.530
In some situations,
depending on cell towers

00:26:22.530 --> 00:26:25.570
and things like that,
we may be able to give you the

00:26:25.570 --> 00:26:27.540
country in a reverse geocode.

00:26:28.190 --> 00:26:31.520
However, it's not a guarantee
and don't bank on it.

00:26:31.700 --> 00:26:35.270
To do a reverse geocode,
the first thing you need to do is

00:26:35.270 --> 00:26:37.500
create a sealed geocoder object.

00:26:37.740 --> 00:26:39.700
This will do the geocoding for you.

00:26:39.700 --> 00:26:43.660
Then you need to create a
location to reverse geocode.

00:26:43.700 --> 00:26:46.710
You can see here that I've
created a location using a

00:26:46.710 --> 00:26:48.700
latitude and longitude value.

00:26:48.700 --> 00:26:53.630
Then you call reverseGeocodeLocation,
passing in the location

00:26:53.770 --> 00:26:56.700
that you just created,
and completion handler,

00:26:56.700 --> 00:27:01.450
which is the block that will execute
when the geocoding request comes back.

00:27:01.700 --> 00:27:05.630
You can see here that I'm just grabbing
the first object from the array.

00:27:05.670 --> 00:27:09.590
But you would want to check the
whole array to make sure that you're

00:27:09.590 --> 00:27:11.490
using the best value possible.

00:27:11.720 --> 00:27:16.690
You would also want to check for the
error in case the request failed.

00:27:17.700 --> 00:27:21.900
You can also use the Address
Dictionary capabilities for geocoding.

00:27:22.040 --> 00:27:26.480
You can create your geocoder object,
and then you can create an address

00:27:26.480 --> 00:27:31.320
dictionary using the Address
Book framework's keys and values.

00:27:31.450 --> 00:27:36.220
Then, you call Geocode Address
Dictionary Completion Handler.

00:27:36.350 --> 00:27:41.470
This makes it really easy to use
the Address Book with geocoding.

00:27:41.880 --> 00:27:47.220
Now, to do forward geocoding,
you still create a CL Geocoder object,

00:27:47.220 --> 00:27:50.650
but next,
you create a string for the address.

00:27:50.780 --> 00:27:54.540
Now, if this is user input,
you might want to sanitize the

00:27:54.540 --> 00:27:58.940
data to make sure that you're not
attempting to geocode a phone number.

00:27:59.080 --> 00:28:03.470
From there,
you just call geocodeAddressString

00:28:03.640 --> 00:28:06.370
completionHandler,
again, grabbing the result from the

00:28:06.480 --> 00:28:08.930
placemarks array that get returned.

00:28:09.440 --> 00:28:12.890
Finally,
to narrow down a set of possible results,

00:28:13.040 --> 00:28:20.200
you can create a geocoder object and call
GeocodeAddressStringInRegionCompletionH

00:28:20.200 --> 00:28:21.300
andler.

00:28:21.490 --> 00:28:25.270
This allows you to define a region
that the result should be within.

00:28:25.270 --> 00:28:29.810
That way, if you're searching for a town,
there may be a town with the

00:28:29.820 --> 00:28:32.300
same name in a nearby state.

00:28:32.370 --> 00:28:36.300
This region will narrow
the results that come back.

00:28:36.440 --> 00:28:39.350
Next,
let's talk about some best practices

00:28:39.650 --> 00:28:42.300
when using the sealed geocoder.

00:28:42.470 --> 00:28:46.250
First, I told you that the completion
handler is asynchronous.

00:28:46.290 --> 00:28:51.300
So, which thread is this run on
when a request comes back?

00:28:51.300 --> 00:28:53.300
It's the main thread.

00:28:53.330 --> 00:28:57.290
So, make sure that you account
for this in your application.

00:28:58.050 --> 00:29:03.290
Additionally, you only want to send one
request per user action.

00:29:03.300 --> 00:29:08.480
It's not a good idea to:
kick off the request and kick off a

00:29:08.480 --> 00:29:09.300
bunch of different requests at one time.

00:29:09.940 --> 00:29:14.890
Next, you want to reuse results
when at all possible.

00:29:15.440 --> 00:29:20.790
You can also use significant location
changes so that as the user moves,

00:29:20.790 --> 00:29:25.470
then you decide you need to do a sealed
geocode instead of doing constant

00:29:25.480 --> 00:29:28.740
geocoding as the user moves around.

00:29:28.960 --> 00:29:31.970
Finally, don't geocode in the background.

00:29:32.110 --> 00:29:35.280
Since the completion handler
runs on the main thread,

00:29:35.340 --> 00:29:38.240
this is definitely not a good idea.

00:29:39.210 --> 00:29:41.520
Now,
you want to make sure that the user can

00:29:41.520 --> 00:29:44.060
read the results in their own language.

00:29:44.260 --> 00:29:47.520
What may look like a word in
one language could differ by

00:29:47.520 --> 00:29:49.660
a lot in another language.

00:29:49.880 --> 00:29:52.610
And with geocoding,
we have built-in support

00:29:52.610 --> 00:29:56.330
for over 30 languages,
meaning that whichever locale

00:29:56.330 --> 00:30:00.120
the user's device is set to,
we're going to try our best to make

00:30:00.210 --> 00:30:05.080
sure that the data coming back is
in a language that they understand.

00:30:05.470 --> 00:30:08.970
We also have added global
coverage for geocoding.

00:30:09.100 --> 00:30:14.900
We currently support over 47 different
regions and territories worldwide.

00:30:14.990 --> 00:30:17.790
You can also look for
a tech note on Apple's

00:30:17.790 --> 00:30:20.690
Developer Center for an updated list.

00:30:21.090 --> 00:30:24.130
Now with geocoding results,
we will try to match the

00:30:24.130 --> 00:30:26.840
user's locale from locality up.

00:30:27.100 --> 00:30:31.190
Here, you can see a reverse geocode
that has been done in English.

00:30:31.440 --> 00:30:36.380
Notice how small the differences
are when switching to Polish.

00:30:36.510 --> 00:30:40.150
But if we switch to Russian,
you can see that almost all of

00:30:40.150 --> 00:30:42.020
the information has changed.

00:30:42.110 --> 00:30:47.650
So we return locale matching
results for locality values on up.

00:30:47.770 --> 00:30:51.730
With iOS 5,
geocoding is easier than ever.

00:30:51.890 --> 00:30:54.940
You can now do forward
and reverse geocoding,

00:30:55.020 --> 00:30:59.740
and we give you additional information
like the areas of interest property.

00:30:59.840 --> 00:31:02.940
We match results to the device's locale.

00:31:03.020 --> 00:31:06.520
There's a lot of parsing work going on,
and you don't have to

00:31:06.520 --> 00:31:08.350
provide a service for it.

00:31:09.400 --> 00:31:12.500
Finally, let's talk about testing.

00:31:12.530 --> 00:31:18.300
Testing is one of the most important and
often overlooked aspects of development.

00:31:18.350 --> 00:31:22.110
When your application goes on sale,
you start to receive feedback from

00:31:22.110 --> 00:31:24.340
users that have bought your application.

00:31:24.400 --> 00:31:28.500
And usually, this feedback is in the
form of app store reviews.

00:31:28.560 --> 00:31:32.100
Well, the last thing you want is to
start getting feedback that says,

00:31:32.160 --> 00:31:35.660
"The app hangs if I deny
location services," or,

00:31:35.700 --> 00:31:38.240
"It says it works in Europe,
but it really doesn't

00:31:38.340 --> 00:31:41.660
work in Europe." So,
how can you take care of this before

00:31:41.660 --> 00:31:44.810
you start getting this type of feedback?

00:31:45.300 --> 00:31:48.880
Testing location awareness in the
past has been a bit difficult.

00:31:49.080 --> 00:31:52.190
You had to drive around with
your computer and device,

00:31:52.190 --> 00:31:55.100
testing different areas,
and you can't always get on a

00:31:55.100 --> 00:31:57.240
flight and test other countries.

00:31:57.340 --> 00:32:02.050
So we've made some great additions to
Xcode and the iOS Simulator to make

00:32:02.050 --> 00:32:04.870
testing location apps easier for you.

00:32:04.990 --> 00:32:07.400
Let's start with Xcode.

00:32:07.600 --> 00:32:12.150
In Xcode, we've added location
support in multiple areas,

00:32:12.150 --> 00:32:14.480
like schemes and the debugger.

00:32:14.720 --> 00:32:19.740
We also allow you to simulate various
scenarios like specific locations,

00:32:19.830 --> 00:32:23.620
a list of major cities,
and you can also use a

00:32:23.620 --> 00:32:26.690
GPX file to simulate routes.

00:32:27.040 --> 00:32:28.740
So what does a scheme do?

00:32:28.940 --> 00:32:33.540
Well, like any good plan,
Xcode 4's schemes have three phases.

00:32:33.700 --> 00:32:36.280
Each phase has its own kind of result.

00:32:36.420 --> 00:32:38.740
The build phase is
where targets are built,

00:32:38.900 --> 00:32:42.120
the test phase is where
testing targets are run,

00:32:42.120 --> 00:32:45.580
and then launch phase
launches an executable.

00:32:45.740 --> 00:32:49.100
So here you can see if you
go in to edit a scheme,

00:32:49.140 --> 00:32:52.960
you can go to the Options tab
and allow location simulation.

00:32:52.960 --> 00:32:55.650
From here,
you can set the default location

00:32:55.750 --> 00:32:59.680
for testing with this scheme,
you can choose a major city,

00:32:59.680 --> 00:33:02.900
or you can define a GPX file to use.

00:33:02.900 --> 00:33:06.840
Schemes are really easy to get
to from the toolbar in Xcode.

00:33:06.840 --> 00:33:10.200
What you can do is you can
create multiple scenarios and

00:33:10.200 --> 00:33:12.140
easily switch between them.

00:33:12.760 --> 00:33:15.830
So here I have Sydney,
and if I click on that,

00:33:15.850 --> 00:33:19.550
you can see that I have these
other options to quickly

00:33:19.550 --> 00:33:21.660
and easily get between.

00:33:21.900 --> 00:33:24.920
Additionally, in the debugger,
we've also added the ability

00:33:24.920 --> 00:33:28.560
to change the location on the
fly as you test with a device.

00:33:28.560 --> 00:33:34.040
You can switch between major cities,
turn simulation off,

00:33:34.040 --> 00:33:36.390
and also use GPX files.

00:33:36.920 --> 00:33:40.210
So, we've added a lot to Xcode.

00:33:40.210 --> 00:33:42.930
And next,
let's look at the iOS Simulator.

00:33:43.060 --> 00:33:46.400
This has been a sore spot for
some location testing in the past,

00:33:46.580 --> 00:33:50.460
but with the new SDK,
we've added a lot for you.

00:33:51.150 --> 00:33:54.840
The simulator is now a
fully-fledged location simulator.

00:33:55.070 --> 00:33:59.560
You get location prompts,
status bar icons,

00:33:59.700 --> 00:34:05.080
location services menus,
and the authorization states to check.

00:34:05.290 --> 00:34:09.720
And you can also reset the location
warnings just like on a device.

00:34:09.870 --> 00:34:15.950
This makes it really easy to test a
specific scenario over and over again.

00:34:16.200 --> 00:34:18.890
Additionally,
we've added background location

00:34:18.890 --> 00:34:21.060
services into the simulator.

00:34:21.220 --> 00:34:24.040
You can also do significant
location changes,

00:34:24.180 --> 00:34:28.380
and most importantly,
you can do region monitoring now.

00:34:28.850 --> 00:34:31.820
A really great feature that
we've added is the ability to set

00:34:31.820 --> 00:34:36.300
the location to be any latitude
and longitude value you want.

00:34:36.550 --> 00:34:39.300
From the menu bar,
you can do this easily.

00:34:39.470 --> 00:34:42.660
You can also test locations
and routes with some predefined

00:34:42.660 --> 00:34:46.930
values that we've added,
such as all of the Apple stores,

00:34:47.010 --> 00:34:51.130
a bike ride, a city run,
or a freeway drive.

00:34:51.480 --> 00:34:56.640
In talking about the simulator though,
keep in mind, the simulator is just that,

00:34:56.700 --> 00:34:57.480
a simulation.

00:34:57.480 --> 00:35:01.470
It's similar to a device,
it does its best to

00:35:01.530 --> 00:35:05.850
imitate a device situation,
but it should be used, in your case,

00:35:05.850 --> 00:35:07.880
for development purposes.

00:35:07.880 --> 00:35:11.080
This should not be your
final testing scenario.

00:35:13.380 --> 00:35:17.810
Now, earlier I mentioned that you can
simulate routes with GPX files.

00:35:17.940 --> 00:35:20.590
But what is a GPX file?

00:35:20.820 --> 00:35:25.200
GPX stands for GPS Exchange Format.

00:35:25.350 --> 00:35:29.700
And this is an open standard
and it's an XML-based file

00:35:29.700 --> 00:35:34.700
that represents a collection of
locations known as waypoints.

00:35:34.760 --> 00:35:37.490
This collection of locations,
or waypoints,

00:35:37.620 --> 00:35:41.680
can create a route that you can
simulate in Xcode and the simulator.

00:35:41.680 --> 00:35:44.690
Let's look at an example.

00:35:44.870 --> 00:35:48.980
You can see here that it is XML based,
so if you've worked with

00:35:48.980 --> 00:35:51.580
XML data in the past,
this will look very familiar.

00:35:51.580 --> 00:35:57.660
Then you set up a track or a route,
and each location is a track point.

00:35:57.660 --> 00:36:03.030
These include latitude, longitude,
and you can add however many

00:36:03.030 --> 00:36:05.650
you want for testing your route.

00:36:05.650 --> 00:36:10.010
When we simulate these routes,
we iterate over each point

00:36:10.320 --> 00:36:14.380
at about one per second,
so you can see the change quickly

00:36:14.380 --> 00:36:18.160
and know that your application
is responding appropriately.

00:36:18.160 --> 00:36:21.670
You'll also see that if you
have waypoints that are farther

00:36:21.670 --> 00:36:25.570
than one kilometer apart,
we will create points in between to

00:36:25.610 --> 00:36:30.510
create a realistic set of results
and iterate over those waypoints

00:36:30.510 --> 00:36:32.940
at the rate of one per second.

00:36:33.840 --> 00:36:36.490
Finally,
one thing that you can do to best

00:36:36.490 --> 00:36:40.700
prepare yourself for any crashes
that may occur within your app once

00:36:40.700 --> 00:36:45.160
it's on the App Store is to create an
Xcode archive with your final build.

00:36:45.260 --> 00:36:49.520
This includes the binary and
DSIM file that maps addresses

00:36:49.520 --> 00:36:51.830
to code within your binary.

00:36:52.340 --> 00:36:56.180
By submitting to the App Store with
the same binary that's in this archive,

00:36:56.180 --> 00:37:01.230
you can ensure that any and all crash
logs you receive will be able to be

00:37:01.230 --> 00:37:04.080
symbolicated within the Xcode organizer.

00:37:04.080 --> 00:37:08.390
This is a very helpful tip to
follow so that you can narrow down

00:37:08.390 --> 00:37:10.740
issues as soon as they happen.

00:37:13.160 --> 00:37:17.650
As you've seen,
by using region monitoring on iOS,

00:37:17.650 --> 00:37:21.250
you can create very personal
experiences for your users.

00:37:21.260 --> 00:37:25.750
And with the Geocoder,
you can make sure that the user gets

00:37:25.810 --> 00:37:30.760
the full benefit from any location
information you have to share with them.

00:37:30.860 --> 00:37:34.760
You can also be sure that it's
in a language they understand.

00:37:34.800 --> 00:37:39.340
You've also learned how to use the
tools available to create a first

00:37:39.340 --> 00:37:43.690
launch experience for your users,
that is a great one.

00:37:44.160 --> 00:37:48.320
I'm excited to see how you use
this information to create fun and

00:37:48.350 --> 00:37:51.110
interesting location-aware applications.
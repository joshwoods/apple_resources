WEBVTT

00:00:08.710 --> 00:00:11.670
Hi, I'm Michael Jurewitz,
Apple's Developer Tools and

00:00:11.750 --> 00:00:13.300
Performance Evangelist.

00:00:13.300 --> 00:00:15.440
And today,
we're here to talk about performance.

00:00:15.440 --> 00:00:18.770
Now,
great apps have terrific performance.

00:00:18.770 --> 00:00:22.890
They delight users by being fast,
being responsive to user input,

00:00:22.890 --> 00:00:25.850
and they use system
resources efficiently.

00:00:25.850 --> 00:00:29.650
So today, we're going to look at some
tips and best practices for

00:00:29.650 --> 00:00:31.740
helping your app perform great.

00:00:31.810 --> 00:00:33.220
So let's get started.

00:00:33.300 --> 00:00:36.930
So as I mentioned, we're here today to
talk about performance.

00:00:37.040 --> 00:00:40.960
Now, performance is perhaps the most
important thing for you to pay

00:00:41.070 --> 00:00:43.220
attention to in your application.

00:00:43.220 --> 00:00:45.730
So you might be wondering,
what is performance?

00:00:45.740 --> 00:00:47.970
Well, performance is about being fast.

00:00:48.230 --> 00:00:50.850
It's about responding
to your users quickly.

00:00:50.880 --> 00:00:54.240
It's also about being responsive,
making sure that as they

00:00:54.240 --> 00:00:56.890
interact with the screen,
your application is

00:00:56.960 --> 00:00:58.920
responding to their touch.

00:00:58.920 --> 00:01:02.680
And it's also about being efficient,
making sure that your app is

00:01:02.780 --> 00:01:03.280
responsive to your user input.

00:01:03.280 --> 00:01:06.340
And it's also about being efficient,
making sure that you're using

00:01:06.710 --> 00:01:08.620
system resources wisely,
so that as you go to use

00:01:08.620 --> 00:01:11.560
something like memory,
you're just using the memory you need,

00:01:11.560 --> 00:01:15.020
and you're not spiking all over place
and causing the system to thrash.

00:01:15.020 --> 00:01:18.030
But beyond even that,
it's about having a great

00:01:18.230 --> 00:01:22.560
impression with your users,
because they notice these things.

00:01:22.600 --> 00:01:25.950
So you want to make sure that
you put your best foot forward,

00:01:25.950 --> 00:01:28.940
so that you don't end up
with reviews like this.

00:01:28.940 --> 00:01:32.350
People saying that your
app is slow and buggy,

00:01:32.350 --> 00:01:37.430
or that... It crashes all the time,
or even worse, one star.

00:01:37.560 --> 00:01:41.350
So today,
we're going to focus on teaching

00:01:41.350 --> 00:01:44.910
you what you need to know to have
a great performing application.

00:01:44.960 --> 00:01:48.470
We're going to take a look at how
to test and measure performance,

00:01:48.550 --> 00:01:52.090
show you how to launch faster,
and also show you how you can

00:01:52.110 --> 00:01:53.830
reduce your memory footprint.

00:01:53.890 --> 00:01:57.900
So first, let's take a look at
measuring performance.

00:01:58.110 --> 00:02:00.680
Now, the first question that
probably comes to mind is,

00:02:00.680 --> 00:02:03.190
what are the things that
you should be measuring?

00:02:03.240 --> 00:02:06.210
Well, in short,
you need to be looking at everything.

00:02:06.420 --> 00:02:08.920
You need to be looking
at processing time,

00:02:08.920 --> 00:02:12.140
how much time you're actually
spending on the processor

00:02:12.560 --> 00:02:13.810
trying to get your work done.

00:02:14.000 --> 00:02:18.320
You want to look at your memory usage to
make sure that you're not using too much,

00:02:18.420 --> 00:02:19.910
that you aren't leaking memory.

00:02:19.920 --> 00:02:23.370
You want to look at your graphics
performance and the correctness for

00:02:23.500 --> 00:02:25.620
how you're actually doing your drawing.

00:02:25.920 --> 00:02:28.710
And there are some important
points to pay attention to here.

00:02:28.720 --> 00:02:31.580
You want to be looking at disk I/O,
so you know how you're

00:02:31.580 --> 00:02:33.180
interacting with the disk.

00:02:33.450 --> 00:02:37.080
And you want to look at battery life,
because your user wants to be able

00:02:37.080 --> 00:02:41.660
to continue to use their iPhone
or iPad throughout the entire day.

00:02:41.890 --> 00:02:44.590
But to look at all this,
you need some help.

00:02:44.830 --> 00:02:49.280
And we've got an app to help
you do that called Instruments.

00:02:49.490 --> 00:02:53.690
Now, Instruments is your one-stop shop
for all your performance needs.

00:02:53.880 --> 00:02:56.300
And it gives you a holistic
view of everything that's

00:02:56.380 --> 00:03:00.050
going on in your application,
from where you're spending that

00:03:00.050 --> 00:03:03.200
processing time to how much memory you're
using and your graphics performance.

00:03:03.200 --> 00:03:05.860
and battery life performance.

00:03:06.670 --> 00:03:10.680
Now Instruments comes with a
ton of templates by default.

00:03:10.680 --> 00:03:13.310
So let's take a look at a few of those.

00:03:13.770 --> 00:03:17.460
First,
you've got the Time Profiler template.

00:03:17.490 --> 00:03:21.980
This provides you low-level statistical
sampling of your application so you

00:03:22.290 --> 00:03:27.070
know exactly where you're spending time
and what algorithms you need to tune.

00:03:28.870 --> 00:03:31.640
Next, you have the allocations template.

00:03:31.730 --> 00:03:34.600
The allocations template lets you
look at the memory usage in your

00:03:34.600 --> 00:03:38.300
application to understand how
many objects you're allocating,

00:03:38.400 --> 00:03:41.320
when you allocated them,
and look at detailed information,

00:03:41.320 --> 00:03:42.800
like even their retain counts.

00:03:42.800 --> 00:03:46.340
The core animation instrument
lets you look at that valuable

00:03:46.340 --> 00:03:49.510
graphics correctness that
I talked to you about before.

00:03:49.790 --> 00:03:51.800
It's a really,
really powerful instrument.

00:03:53.090 --> 00:03:56.800
Finally, new in Xcode 4, you have the
OpenGL ES Analyzer instrument,

00:03:56.800 --> 00:04:00.320
which gives you an in-depth look
at how you're using OpenGL and can

00:04:00.320 --> 00:04:02.710
really help you tune that performance.

00:04:02.840 --> 00:04:06.800
It's really vital,
especially if you're a game developer.

00:04:08.000 --> 00:04:10.920
You also have the system activity
template so you can see how you're

00:04:10.920 --> 00:04:14.440
interacting with the disk and exactly
what's going on on the device.

00:04:14.440 --> 00:04:17.160
And finally,
the power and battery life template

00:04:17.260 --> 00:04:22.320
lets you look at the power consumption
of your application and overall see

00:04:22.320 --> 00:04:26.090
how it was draining power from the
device so you can better fine tune

00:04:26.090 --> 00:04:28.680
things to reduce battery consumption.

00:04:28.680 --> 00:04:32.810
Now, when you start looking at what
you need to do in measuring,

00:04:33.020 --> 00:04:35.660
the most important thing is don't guess.

00:04:36.470 --> 00:04:37.690
Now, I'm going to say that again.

00:04:37.690 --> 00:04:39.440
Don't guess.

00:04:39.440 --> 00:04:43.650
You've got a powerful set of
instruments at your fingertips to

00:04:43.650 --> 00:04:46.480
figure out exactly what you're doing.

00:04:46.500 --> 00:04:50.990
So even though you architected the
code and you've got a great idea for

00:04:51.000 --> 00:04:54.550
what you think needs to be tuned,
measure first.

00:04:54.600 --> 00:04:56.850
It's absolutely important
that you measure.

00:04:56.860 --> 00:05:01.750
And most importantly,
you want to focus on simple, repeatable,

00:05:01.750 --> 00:05:03.600
real-world actions.

00:05:03.620 --> 00:05:05.980
Does your app have a table view?

00:05:06.400 --> 00:05:07.930
Does the user scrolls through?

00:05:07.950 --> 00:05:09.940
Tests scrolling through that?

00:05:10.090 --> 00:05:12.750
When they tap on an entry,
do you load up additional

00:05:12.750 --> 00:05:14.180
data or go out to the network?

00:05:14.990 --> 00:05:17.240
Measure that experience specifically.

00:05:17.440 --> 00:05:22.350
Focus on these small,
repeatable actions that you can fine tune

00:05:22.350 --> 00:05:25.460
to make sure that they perform great.

00:05:25.700 --> 00:05:27.990
And when you make a change,
make sure that you go

00:05:28.000 --> 00:05:31.030
ahead and you retest,
that you verify that you actually

00:05:31.030 --> 00:05:32.040
have made an improvement.

00:05:32.040 --> 00:05:34.700
Because the last thing you want
to do is make a change that

00:05:34.730 --> 00:05:36.560
causes things to perform worse.

00:05:36.560 --> 00:05:40.480
And you want to keep iterating
until it just feels right,

00:05:40.480 --> 00:05:43.960
until it feels great for
you to use in your hand.

00:05:45.780 --> 00:05:47.470
Now when you're looking at
something like Instruments,

00:05:47.550 --> 00:05:49.510
there's a few things that
you want to look for in

00:05:49.510 --> 00:05:52.300
particular in your application.

00:05:52.460 --> 00:05:54.700
With something like the
Allocations Instrument,

00:05:54.790 --> 00:05:58.330
you want to make sure that
you're not using tons of memory,

00:05:58.330 --> 00:06:02.000
and that it's not growing
monotonically over time.

00:06:02.120 --> 00:06:04.940
Your app should ebb and
flow as it uses memory,

00:06:04.970 --> 00:06:08.600
and it shouldn't just be
marching upward constantly.

00:06:09.390 --> 00:06:11.370
Using something like
the leaks instrument,

00:06:11.480 --> 00:06:14.840
you should absolutely not
have leaks in your app.

00:06:14.950 --> 00:06:17.300
You need to make sure
that these get eliminated.

00:06:17.370 --> 00:06:19.680
And we'll talk about how to
do that a little bit later.

00:06:22.200 --> 00:06:24.980
And when you're using something
like the Time Profiler instrument,

00:06:25.090 --> 00:06:29.120
you want to make sure that you're not
pegging the CPU and using all of the

00:06:29.130 --> 00:06:31.720
available resources as much as possible.

00:06:31.720 --> 00:06:35.140
You want to make sure that you're
tuning your algorithms to get

00:06:35.140 --> 00:06:38.500
their work done and then stop,
so that you can do things like make

00:06:38.500 --> 00:06:40.420
sure that battery life lasts longer.

00:06:40.420 --> 00:06:43.820
Now when you're measuring performance,
you want to make sure that you

00:06:43.820 --> 00:06:45.930
choose the right tuning environment.

00:06:46.540 --> 00:06:50.310
And it's important to remember that the
simulator is a perfectly valid place

00:06:50.310 --> 00:06:52.350
to do a lot of performance testing.

00:06:52.360 --> 00:06:55.240
The simulator is fast,
it's got rapid turnaround,

00:06:55.290 --> 00:06:59.110
and in this case of some instruments,
it even has additional options

00:06:59.110 --> 00:07:01.980
that you can use to actually
improve your analysis.

00:07:01.980 --> 00:07:06.900
So in the simulator, for example,
you can use things like Activity

00:07:06.900 --> 00:07:09.570
Monitor or Leaks or Allocations.

00:07:09.580 --> 00:07:13.060
Generally speaking,
the memory performance doesn't change

00:07:13.060 --> 00:07:15.420
between the simulator and the device.

00:07:15.420 --> 00:07:19.120
And so this is a perfect place
to test that kind of correctness.

00:07:19.120 --> 00:07:22.060
But at the end of the day,
the device is where you need

00:07:22.060 --> 00:07:24.070
to be doing your final testing.

00:07:24.080 --> 00:07:28.530
And it's also where you need to be doing
the kind of testing like Time Profiler,

00:07:28.820 --> 00:07:31.420
Core Animation,
or the OpenGL ES Analyzer.

00:07:31.420 --> 00:07:35.930
Because those instruments and that
performance really depends on the

00:07:35.930 --> 00:07:38.820
underlying device that you're running on.

00:07:38.920 --> 00:07:41.480
You need to know how the
processor is going to behave,

00:07:41.480 --> 00:07:43.910
how the graphics processor
is going to behave.

00:07:44.480 --> 00:07:47.480
And so you want to make sure that
you're measuring where it matters.

00:07:47.480 --> 00:07:51.020
So the simulator is great
for rapid turnaround.

00:07:51.200 --> 00:07:53.310
You've got additional
memory debugging features.

00:07:53.520 --> 00:07:56.960
But generally speaking,
it's unrealistic for things like timing.

00:07:56.980 --> 00:07:59.200
Because of course,
the simulator is running

00:07:59.330 --> 00:08:01.530
on your laptop or desktop,
which has got a really

00:08:01.530 --> 00:08:02.990
powerful Intel processor in it.

00:08:03.060 --> 00:08:06.410
And the device needs to
be the final arbiter.

00:08:06.610 --> 00:08:09.010
So use it for all speed-related testing.

00:08:09.220 --> 00:08:12.730
And make sure that any memory fixes
that you make in the simulator also

00:08:12.730 --> 00:08:13.540
bear out when you test on the simulator.

00:08:13.590 --> 00:08:17.290
All right,
so let's talk about launching quickly.

00:08:17.430 --> 00:08:20.830
So now launching quickly is so
important because it's the user's

00:08:21.070 --> 00:08:23.280
first impression of your application.

00:08:23.300 --> 00:08:28.360
From the moment they touch your app on
the home screen and it begins to launch,

00:08:28.700 --> 00:08:32.300
they're immediately forming
opinions about your application.

00:08:32.570 --> 00:08:36.200
This is your vital opportunity to
communicate things about speed and

00:08:36.200 --> 00:08:38.300
the quality of your application.

00:08:38.300 --> 00:08:42.300
And you want to make sure that you're
putting that best foot forward.

00:08:42.600 --> 00:08:44.850
So the common scenarios that
we're going to take a look at

00:08:44.910 --> 00:08:48.600
in this section are both the
non-multitasking launch of your app.

00:08:48.600 --> 00:08:52.470
So this is just when the user is
launching your app from the first time.

00:08:52.650 --> 00:08:56.530
And we're also going to talk a little
bit about the multitasking resume.

00:08:56.630 --> 00:08:59.600
This is when the user
double taps the home button,

00:08:59.690 --> 00:09:01.910
presses your app,
and you get reanimated from

00:09:01.910 --> 00:09:03.450
having been in the background.

00:09:03.600 --> 00:09:07.600
So when it comes to launching quickly,
timing is everything.

00:09:07.600 --> 00:09:11.650
The OS is watching your app constantly.

00:09:11.660 --> 00:09:16.660
And slow performance will cause
iOS to quit your application.

00:09:16.660 --> 00:09:21.640
Now this seems kind of drastic,
so why do we do something like this?

00:09:21.670 --> 00:09:25.050
Well, it's very important that if
someone's using their iPhone or

00:09:25.050 --> 00:09:29.610
their iPad or their iPod Touch that
the system remain responsive.

00:09:29.760 --> 00:09:32.240
We want to make sure that they
can continue to use the device

00:09:32.240 --> 00:09:33.660
for what it's intended for.

00:09:33.660 --> 00:09:37.660
And if your application hangs
and stops being responsive,

00:09:37.660 --> 00:09:40.710
then for all we know,
the application may never recover.

00:09:40.720 --> 00:09:44.720
And so we need to make sure that the
user can continue to use that device.

00:09:44.720 --> 00:09:47.720
So the timings we give
you are rather generous,

00:09:47.720 --> 00:09:50.720
but you need to be aware of them so
that you don't run up against them.

00:09:50.720 --> 00:09:55.460
So for example, for launch time,
you have 20 seconds from the time

00:09:55.460 --> 00:10:00.330
your app launches to the time you've
done executing application did finish

00:10:00.330 --> 00:10:04.260
launching with options and loaded your
first view to be able to start turning

00:10:04.260 --> 00:10:06.640
the run loop and accepting user input.

00:10:06.740 --> 00:10:08.840
If you take longer than 20 seconds,
your application is

00:10:08.840 --> 00:10:09.780
going to stop running.

00:10:09.780 --> 00:10:12.780
If you take longer than 20 seconds,
your application is going to get killed.

00:10:12.780 --> 00:10:16.780
When you're resuming from the background,
you've got 10 seconds to come back.

00:10:16.780 --> 00:10:19.510
When you're being suspended
into the background,

00:10:19.510 --> 00:10:22.670
you have 10 seconds to do
any cleanup that you want.

00:10:22.870 --> 00:10:25.400
And finally, of course,
if you're just being quit by the user,

00:10:25.400 --> 00:10:27.460
you've got six seconds
to clean everything up.

00:10:27.580 --> 00:10:31.520
And we also have Task Completion
API as part of the new

00:10:31.520 --> 00:10:35.430
multitasking API in iOS 4,
so that if you have a long-running task,

00:10:35.430 --> 00:10:38.970
like an upload that you need to finish,
you can get up to 10 minutes to

00:10:39.000 --> 00:10:42.570
run in the background to be able
to finish that kind of activity.

00:10:42.580 --> 00:10:46.630
Now, when you're measuring launch,
you need to test with

00:10:46.630 --> 00:10:48.400
realistic data sets.

00:10:48.400 --> 00:10:50.350
This is absolutely important.

00:10:51.020 --> 00:10:52.830
Now,
when all of us are doing development,

00:10:52.830 --> 00:10:57.480
it's really common for us to just have
a blank set of data that we're working

00:10:57.490 --> 00:11:00.540
with because you've just built the
app and pushed it off to the device.

00:11:00.540 --> 00:11:05.370
But if you've got the kind of app
that expects to be collecting tens,

00:11:05.720 --> 00:11:09.740
hundreds, thousands,
tens of thousands of pieces of data,

00:11:09.740 --> 00:11:13.540
and you've got algorithms that
load all this stuff on startup,

00:11:13.540 --> 00:11:16.850
well, then you're going to go from
having launch quickly to possibly

00:11:16.880 --> 00:11:20.540
having your app being killed on
startup for your higher-end users.

00:11:21.150 --> 00:11:24.640
So make sure you're testing
for those real-world scenarios.

00:11:24.700 --> 00:11:29.870
And you can do that by using
the Time Profiler instrument.

00:11:30.000 --> 00:14:08.400
[Transcript missing]

00:14:08.620 --> 00:14:12.790
So, let's take a look at a demo for
launching quickly with the Time Profiler

00:14:12.790 --> 00:14:17.000
instrument so I can show you how
to find this kind of activity.

00:14:17.140 --> 00:14:19.990
Okay,
so let's take a look at helping your app

00:14:20.030 --> 00:14:22.840
launch even faster using instruments.

00:14:22.990 --> 00:14:26.560
So first, we're going to open up
our project here in Xcode.

00:14:26.680 --> 00:14:31.020
And I'm going to go to Build and Run so
we can take a look at what it looks like.

00:14:31.710 --> 00:14:35.760
We're building our application,
it's being moved out to the device,

00:14:35.850 --> 00:14:38.370
and we can see it's taking
a long time to launch.

00:14:38.540 --> 00:14:42.220
We're waiting, we're waiting.

00:14:42.730 --> 00:14:44.390
Still waiting.

00:14:44.570 --> 00:14:46.500
And finally the content has come in.

00:14:46.600 --> 00:14:50.370
And as you see as we scroll through,
we've just got a ton of content.

00:14:50.480 --> 00:14:52.090
If you look at the
scroller on the right side,

00:14:52.100 --> 00:14:54.370
you can get an idea for
just how much we have.

00:14:54.490 --> 00:14:59.090
So clearly this took a long time,
and we'd really like this to be faster.

00:14:59.110 --> 00:15:02.600
So let's look at how we can
optimize this performance.

00:15:02.600 --> 00:15:06.080
So we'll go back to Xcode.

00:15:06.540 --> 00:15:09.860
And now,
we're going to launch Instruments.

00:15:09.930 --> 00:15:12.190
When we launch Instruments,
we're greeted with this series of

00:15:12.250 --> 00:15:13.790
templates for us to choose from.

00:15:13.800 --> 00:15:17.500
So we can take a look at the
memory usage of our application,

00:15:17.650 --> 00:15:21.100
use the time profile of our instrument
to understand where we're spending time,

00:15:21.100 --> 00:15:24.300
and even use things like
UI automation or look at the energy

00:15:24.440 --> 00:15:26.430
diagnostics for our application.

00:15:27.920 --> 00:15:30.070
In this case,
we're concerned about speed.

00:15:30.420 --> 00:15:34.320
So let's take a look at the
Time Profiler application.

00:15:36.130 --> 00:15:39.100
Now I'm going to go ahead and
choose Target and select our

00:15:39.100 --> 00:15:44.090
Launch Performance application
and hit Record.

00:15:45.400 --> 00:16:54.700
[Transcript missing]

00:16:55.280 --> 00:16:57.540
Now if we go and we look at the
left side of the screen here,

00:16:57.540 --> 00:17:00.140
there are a bunch of different
options for filtering the

00:17:00.140 --> 00:17:02.000
data that you're looking at.

00:17:02.150 --> 00:17:06.600
By default, the time profiler comes
with the call tree inverted.

00:17:06.760 --> 00:17:08.800
When I'm looking at
information like this though,

00:17:08.800 --> 00:17:14.520
I like to un-invert the call tree and
start at main and work my way down.

00:17:14.950 --> 00:17:18.800
Now a really useful option if you're just
using Objective-C in your application

00:17:18.800 --> 00:17:22.790
is to check this Show Objective-C Only.

00:17:22.880 --> 00:17:26.390
You can also check flatten recursion
in case you have any recursive

00:17:26.400 --> 00:17:29.800
algorithms and you just want to
flatten them into a single frame.

00:17:31.450 --> 00:17:35.840
Now over here in the table view we've
got the actual data from the run.

00:17:35.960 --> 00:17:39.140
And there's a few different things
you can look at in this data as well.

00:17:39.180 --> 00:17:42.410
So if I control click on this menu,
you see there's a lot of different

00:17:42.410 --> 00:17:44.150
stuff we can pay attention to.

00:17:44.500 --> 00:17:48.220
In particular,
I want to look at self percentage.

00:17:48.260 --> 00:17:50.850
Now we've got running time,
which shows a percentage,

00:17:51.020 --> 00:17:52.940
and self percentage.

00:17:53.020 --> 00:17:55.840
So what's the difference here?

00:17:56.050 --> 00:17:59.020
Well, in the case of running time,
running time is going to show you

00:17:59.090 --> 00:18:03.980
the total percentage of time that was
spent in this method and everything

00:18:03.980 --> 00:18:06.120
else that it called through to.

00:18:07.340 --> 00:18:11.960
In the case of self percentage,
what you're looking at was the time that

00:18:11.960 --> 00:18:16.770
was spent just in that method itself,
so not the things that

00:18:16.770 --> 00:18:21.180
it called through to,
like frameworks or other methods.

00:18:21.540 --> 00:18:24.080
Now this is particularly important
because you're going to be able

00:18:24.080 --> 00:18:27.540
to use this information to know,
do you need to optimize how

00:18:27.540 --> 00:18:30.750
you're using the frameworks and
perhaps use them better or use

00:18:30.750 --> 00:18:32.800
different ones to get better speed?

00:18:32.800 --> 00:18:37.900
Or do you need to tune that method
itself to help it go faster?

00:18:39.340 --> 00:18:41.600
Now from here,
the important part is just to

00:18:41.600 --> 00:18:44.400
start stepping down the call tree.

00:18:44.410 --> 00:18:48.880
And you kind of want to be a detective
and just follow this large percentage.

00:18:49.050 --> 00:18:50.330
So we keep going down.

00:18:50.790 --> 00:18:55.910
We see we're still at 96.3%.
We're in UI Application,

00:18:55.910 --> 00:18:58.390
Handle Event with New Event.

00:18:58.780 --> 00:19:02.500
We keep going, we've got more framework
code that we're working with.

00:19:02.630 --> 00:19:05.460
We're continuing to
follow this percentage.

00:19:05.560 --> 00:19:09.020
And finally, we've hit the
Launch Performance App Delegate,

00:19:09.110 --> 00:19:12.810
Application did finish
launching with options.

00:19:12.980 --> 00:19:15.250
Now,
if you ever do a trace and you see this

00:19:15.250 --> 00:19:19.740
amount of time spent in Application did
finish launching with options,

00:19:19.840 --> 00:19:22.360
again, this should be a big red flag.

00:19:22.520 --> 00:19:26.520
You absolutely don't want to be
spending this amount of time in

00:19:26.520 --> 00:19:29.480
your own code in that method.

00:19:29.580 --> 00:19:33.240
Your whole goal at this stage should
be to kick off your application,

00:19:33.240 --> 00:19:37.140
to get it running,
to do bookkeeping and take notes

00:19:37.160 --> 00:19:40.640
for yourself about different
state that you need to set up,

00:19:40.740 --> 00:19:44.580
but you shouldn't be blocking
while you do all this state

00:19:44.580 --> 00:19:47.170
loading at this point in time.

00:19:47.280 --> 00:19:50.790
So let's see exactly where
we're spending time here.

00:19:51.120 --> 00:19:54.550
If I turn this down, we see we've got our
Sans View Controller calling

00:19:54.550 --> 00:19:55.800
a method called parse.

00:19:55.800 --> 00:19:58.550
If I didn't know this code,
this would already be

00:19:58.550 --> 00:20:00.630
another red flag saying,
uh-oh,

00:20:00.630 --> 00:20:05.380
am I parsing and loading data on the
main thread as part of launching my app?

00:20:05.790 --> 00:20:08.940
Sure enough,
we've got this RSS parser here,

00:20:08.940 --> 00:20:11.760
and we're telling it to start,
and it looks like it's

00:20:11.760 --> 00:20:13.420
just parsing through XML.

00:20:13.420 --> 00:20:16.890
Worse yet,
we've got this download and parse method,

00:20:16.900 --> 00:20:19.360
so it sounds like we may actually
even be doing some network

00:20:19.360 --> 00:20:20.580
activity as part of that.

00:20:21.000 --> 00:20:25.280
And sure enough, we get into framework
code with NSXML parser,

00:20:25.280 --> 00:20:29.330
where we're actually parsing this
XML from this feed that's come in.

00:20:29.380 --> 00:20:32.410
Now, if you're looking at your
code and trying to figure out

00:20:32.410 --> 00:20:35.800
exactly where you're doing this,
it's actually really easy

00:20:35.800 --> 00:20:37.530
in Instruments to see that.

00:20:37.710 --> 00:20:40.650
We can just double-click
on the method itself,

00:20:40.920 --> 00:20:44.810
and we actually jump to the source,
so you can see exactly where

00:20:44.810 --> 00:20:46.470
you are doing this work.

00:20:46.480 --> 00:20:50.940
And if you want to go to Xcode
and be able to make a fix,

00:20:51.070 --> 00:20:54.700
perhaps change how you're doing this,
you just press the little Xcode button,

00:20:54.870 --> 00:20:56.530
and now you're back in your project.

00:20:56.660 --> 00:20:58.760
And so at this point,
you want to be paying

00:20:58.760 --> 00:21:01.180
attention to this method,
or even just how you've

00:21:01.180 --> 00:21:04.360
architected this loading,
and try to make changes so that you're

00:21:04.360 --> 00:21:07.780
not loading this data on the main thread,
and really that you're just

00:21:07.790 --> 00:21:09.540
avoiding this parsing in general.

00:21:11.410 --> 00:21:13.980
Alright, so remember,
the system will terminate

00:21:14.020 --> 00:21:15.120
slow applications.

00:21:15.480 --> 00:21:18.730
You want to make sure that you
collect data with Time Profiler.

00:21:19.120 --> 00:21:22.580
You want to make sure that you defer
and otherwise just try to do less work.

00:21:22.660 --> 00:21:26.230
Avoid blocking the main
thread at all costs.

00:21:26.280 --> 00:21:29.720
And finally, optimize, optimize,
optimize.

00:21:29.720 --> 00:21:33.540
Be using Time Profiler to figure
out exactly what you need to

00:21:33.580 --> 00:21:35.740
improve in your application.

00:21:36.600 --> 00:21:38.640
Okay, so that's launching quickly.

00:21:38.640 --> 00:21:41.540
Now let's take a look at
reducing memory footprint.

00:21:41.540 --> 00:21:46.350
Now, there's a lot of things going
on in the device at one time.

00:21:46.350 --> 00:21:49.480
For instance,
you've got 12 megabytes of memory

00:21:49.480 --> 00:21:51.550
that's going to the graphics processor.

00:21:51.580 --> 00:21:55.110
You've got a good 36 megabytes
that are used by the kernel,

00:21:55.150 --> 00:21:56.410
it's wired memory.

00:21:56.410 --> 00:21:59.250
Approximately another 10
or so that are used by the

00:21:59.250 --> 00:22:01.150
different daemons on the phone.

00:22:02.000 --> 00:22:04.130
You've got the springboard,
the actual home screen

00:22:04.170 --> 00:22:05.130
takes up another 8.

00:22:05.300 --> 00:22:07.660
And then you have the processes
that actually make iPhone

00:22:07.660 --> 00:22:08.900
and iPod touch what it is.

00:22:08.900 --> 00:22:14.080
You've got the phone process,
the mail process, iPod, Safari,

00:22:14.220 --> 00:22:17.190
all of those have a memory impact.

00:22:17.200 --> 00:22:20.770
So it's important to understand that
there are other things happening

00:22:20.770 --> 00:22:24.740
on the device at the same time
that your application is executing.

00:22:24.900 --> 00:22:30.430
Now, iOS is a powerful operating system,
but it's not a desktop OS.

00:22:31.740 --> 00:22:33.740
It's a very limited memory to work with.

00:22:33.740 --> 00:22:35.570
At the end of the day,
this is an embedded device

00:22:35.600 --> 00:22:36.740
that you're working with.

00:22:36.740 --> 00:22:40.370
There's virtual memory,
but there's no swap file.

00:22:40.580 --> 00:22:43.510
So while you're not sharing
memory with different processes,

00:22:43.590 --> 00:22:47.670
all of the memory that you're
using has to stay physically

00:22:47.750 --> 00:22:50.480
resident in the RAM on the device.

00:22:51.880 --> 00:22:56.030
Now to help you work in these situations,
we also have low memory notifications

00:22:56.040 --> 00:23:00.140
that are sent to every process on
the device to make sure that you

00:23:00.140 --> 00:23:03.740
can work together to try to free
up resources as they're needed.

00:23:03.740 --> 00:23:07.130
So as you can see in the chart,
there is a steady upward march in terms

00:23:07.470 --> 00:23:11.660
of the amount of memory that's available,
but the system is going to be using

00:23:11.660 --> 00:23:13.940
some of this memory for itself as well.

00:23:13.940 --> 00:23:16.980
So you need to make sure that
you're architecting your apps

00:23:17.100 --> 00:23:18.800
to use as little as possible.

00:23:19.900 --> 00:23:22.220
And again, iOS has no swap file.

00:23:22.330 --> 00:23:25.030
All of that memory has to stay resident.

00:23:25.040 --> 00:23:27.970
And under sufficient
amounts of memory pressure,

00:23:27.970 --> 00:23:31.350
the OS will actually begin
terminating applications.

00:23:31.360 --> 00:23:33.740
Let's take a look at how that happens.

00:23:33.740 --> 00:23:37.250
So we have this system
of low memory warnings.

00:23:37.300 --> 00:23:40.060
And as we look at memory
increasing over time,

00:23:40.060 --> 00:23:42.260
there's a few things that happen.

00:23:43.500 --> 00:30:39.800
[Transcript missing]

00:30:40.010 --> 00:30:43.250
Finally,
the last category is abandoned memory.

00:30:43.250 --> 00:30:46.910
Now abandoned memory is sort
of a special kind of leak.

00:30:46.970 --> 00:30:51.360
This is memory that is accessible,
but just in the own usage

00:30:51.360 --> 00:30:55.490
of your application,
you never actually end up using it again.

00:30:55.740 --> 00:30:59.290
So the classic example might be a
cache that you're keeping around,

00:30:59.290 --> 00:31:03.590
that you only are putting objects into,
and you're not actually referencing it

00:31:03.590 --> 00:31:06.120
for the information that you're caching.

00:31:06.120 --> 00:31:10.580
And so you end up just sort of slowly
accumulating this memory over time,

00:31:10.730 --> 00:31:15.420
and again, just like with a leak,
you're slowly suffocating yourself.

00:31:15.420 --> 00:31:19.430
And so you can use the allocations
instrument with this brand new

00:31:19.430 --> 00:31:23.230
heap shot feature to be able to
use your application and try to

00:31:23.230 --> 00:31:26.590
spot this kind of heap growth,
so that you can go ahead and

00:31:26.680 --> 00:31:29.730
reduce that and make sure that
you're not using too much memory.

00:31:29.740 --> 00:31:33.080
Now as you're going along,
you want to make sure that you

00:31:33.120 --> 00:31:35.510
don't ignore low memory warnings.

00:31:35.560 --> 00:31:38.300
These are really,
really key to making sure that

00:31:38.370 --> 00:31:41.900
your app and the rest of the
system continues to run great.

00:31:42.060 --> 00:31:45.000
So what should you do if
you get a memory warning?

00:31:45.000 --> 00:31:47.610
Well, first of all,
you want to make sure that

00:31:47.610 --> 00:31:51.140
you release any objects that
can be easily reconstructed.

00:31:51.330 --> 00:31:55.120
You want to release any cached objects,
things that you can read off disk.

00:31:55.120 --> 00:31:58.530
Again, or that you really don't need,
you were just keeping

00:31:58.530 --> 00:31:59.520
around in your caches.

00:31:59.520 --> 00:32:03.800
And you want to make sure that
you unload cached resource files.

00:32:03.840 --> 00:32:08.360
So say an image that you can just
go and read off disk again easily,

00:32:08.360 --> 00:32:11.660
especially if that image
is not currently on screen.

00:32:11.660 --> 00:32:14.440
So when you receive these
low memory warnings,

00:32:14.440 --> 00:32:16.740
you want to make sure
that you take action.

00:32:16.740 --> 00:32:21.500
But most importantly,
don't ask the user to do anything.

00:32:21.500 --> 00:32:23.580
There's nothing they can do.

00:32:23.580 --> 00:32:24.860
This is something that
you as a developer,

00:32:24.860 --> 00:32:27.540
need to deal with in your application.

00:32:27.670 --> 00:32:31.900
It's not like they can use your
application more conservatively or

00:32:31.900 --> 00:32:34.300
somehow change what they're trying to do.

00:32:34.350 --> 00:32:37.790
Now, when it comes to responding
to low memory warnings,

00:32:37.880 --> 00:32:40.100
there's a bunch of different
places where you can do it.

00:32:40.140 --> 00:32:45.380
First of all, UIViewController subclasses
can implement viewDidUnload.

00:32:45.470 --> 00:32:48.250
And as we'll see in a minute,
this is actually very necessary.

00:32:48.280 --> 00:32:53.370
In your app delegate, you can implement
applicationDidReceiveMemoryWarning

00:32:53.710 --> 00:32:54.600
so that you can unload
any resources that you need.

00:32:54.600 --> 00:33:01.360
And if you have any other objects
throughout your application that want to

00:33:01.360 --> 00:33:04.380
know when a memory warning has come in,
so they can do things

00:33:04.380 --> 00:33:07.780
like clean up caches,
then they can register for

00:33:07.780 --> 00:33:12.010
UIApplicationDidReceiveMemoryWarningNot
ification and trigger

00:33:12.060 --> 00:33:13.530
that behavior that way.

00:33:13.560 --> 00:33:18.390
Now, UIViewControllers will try to
unload any off-screen views

00:33:18.410 --> 00:33:20.060
when a memory warning comes in.

00:33:20.060 --> 00:33:23.240
And they do this through
calling viewDidUnload.

00:33:23.300 --> 00:33:24.340
But they need to know that the
memory warning is not coming in.

00:33:24.340 --> 00:33:26.620
So they need some help
releasing views that you've

00:33:26.620 --> 00:33:28.340
retained in instance variables.

00:33:28.340 --> 00:33:31.420
So let's take a look at an
example of what's going on.

00:33:31.420 --> 00:33:34.600
So let's say we've got our
application here that's got

00:33:34.720 --> 00:33:38.300
this ComposeViewController
currently on the navigation stack.

00:33:38.380 --> 00:33:42.020
We tap on the photo,
and now we've got this

00:33:42.210 --> 00:33:45.600
PhotoViewController on the stack
as we're looking at this photo.

00:33:45.600 --> 00:33:49.830
And at this point,
a low memory notification comes in.

00:33:49.840 --> 00:33:54.030
So what's going to happen is,
is that the ComposeViewController

00:33:54.080 --> 00:33:54.080
is going to notice that
the view is not coming in.

00:33:54.100 --> 00:33:56.090
So it's going to notice
that it's off-screen,

00:33:56.240 --> 00:34:01.080
and it's going to release its
reference to the UIView that it has.

00:34:01.080 --> 00:34:06.700
But if you've got IBoutlets pointing
to other views in that hierarchy,

00:34:07.150 --> 00:34:09.860
those are going to
keep those views alive.

00:34:09.860 --> 00:34:12.490
So typically in your header,
you might have something

00:34:12.520 --> 00:34:13.730
that looks like this.

00:34:13.760 --> 00:34:15.760
You've got a property declaration.

00:34:15.760 --> 00:34:19.760
You'll notice that property
declaration is declared retain,

00:34:19.760 --> 00:34:21.630
which is how you declare IBoutlets.

00:34:22.660 --> 00:34:26.660
And all of these are essentially going
to have those views then retained,

00:34:26.660 --> 00:34:27.650
and they're not going to go away.

00:34:27.660 --> 00:34:31.730
So what you want to make sure that
you implement is viewDidUnload,

00:34:31.730 --> 00:34:34.170
so that you're going through,
you're setting each of

00:34:34.300 --> 00:34:38.660
these outlets to nil,
and then calling super viewDidUnload.

00:34:38.660 --> 00:34:43.110
And this is going to help that
ComposeViewController to be able to get

00:34:43.110 --> 00:34:45.660
rid of that off-screen view hierarchy.

00:34:45.680 --> 00:34:50.640
So that now, it releases its view,
viewDidUnload gets called,

00:34:50.670 --> 00:34:51.660
and you release your outlets.

00:34:51.660 --> 00:34:52.380
And then you can see that
the view did not go away.

00:34:52.380 --> 00:34:55.380
and that memory goes away.

00:34:55.380 --> 00:34:58.360
Now the best thing about memory
warnings is that you can actually

00:34:58.380 --> 00:35:01.300
simulate them yourself in the simulator.

00:35:01.500 --> 00:35:04.500
So if you go to the hardware menu
you will notice there is an item

00:35:04.500 --> 00:35:06.360
called simulate memory warning.

00:35:06.380 --> 00:35:10.580
This is a great way for you to verify
that the classes that you have in your

00:35:10.580 --> 00:35:16.380
application are responding just the way
you think they should to memory warnings.

00:35:16.390 --> 00:35:20.230
Now when it comes to multitasking
again the key is to make sure that

00:35:20.230 --> 00:35:22.380
you are surviving in the background.

00:35:22.630 --> 00:35:26.940
And it is also important to know
that low memory notifications are

00:35:26.940 --> 00:35:29.380
not sent to backgrounded apps.

00:35:29.540 --> 00:35:33.380
Once your app is in the background and it
has kind of been hibernated that is it.

00:35:33.380 --> 00:35:37.150
The memory that you have already managed
to get rid of as you were going into

00:35:37.220 --> 00:35:40.380
the background is your only opportunity.

00:35:40.380 --> 00:35:44.790
And so you need to make sure that
you release as many reconstructable

00:35:44.790 --> 00:35:46.380
resources as possible.

00:35:46.540 --> 00:35:51.480
So when your app delegates application
did enter background gets called or

00:35:51.600 --> 00:35:56.380
after you receive the UI application
did enter background notification.

00:35:56.380 --> 00:35:59.980
Use that short period of time
that you have to reduce your

00:36:00.010 --> 00:36:02.370
memory usage as much as possible.

00:36:02.380 --> 00:36:06.930
Apps that use less memory in the
background have a lower chance

00:36:06.930 --> 00:36:09.380
of being killed by the system.

00:36:10.090 --> 00:36:15.370
Okay, so now let's take a look at memory
footprint and the allocations instrument

00:36:15.410 --> 00:36:19.480
to help you figure out how to improve
the memory usage in your application.

00:36:19.500 --> 00:36:22.250
Okay,
so let's see how we can get to the bottom

00:36:22.250 --> 00:36:27.140
of tough memory problems that you might
run into when you're in development.

00:36:27.140 --> 00:36:31.260
So first, let's open up Xcode and
take a look at our project.

00:36:31.370 --> 00:36:34.340
In this case,
it's a project called Breadcrumbs.

00:36:34.340 --> 00:36:36.370
I'm going to go ahead
and click Build and Run,

00:36:36.370 --> 00:36:38.490
and let's take a look
at what this looks like.

00:36:39.170 --> 00:36:43.590
So we've built the app,
it's being pushed out to the device,

00:36:44.290 --> 00:36:46.670
And as we can see,
it's a pretty simple application.

00:36:46.990 --> 00:36:48.400
We can go scrolling through it.

00:36:48.450 --> 00:36:51.840
Notice we've got a bunch
of table view data here.

00:36:52.000 --> 00:36:53.990
Pretty straightforward.

00:36:54.550 --> 00:36:59.980
So let's go back to Xcode now and see
how we can use Instruments to look at the

00:36:59.980 --> 00:37:03.230
memory being used in this application.

00:37:03.320 --> 00:37:05.940
So we're going to bring up
instruments and we're going to

00:37:05.940 --> 00:37:08.400
start off with the leaks template.

00:37:08.530 --> 00:37:10.920
Now as you recall,
leaks are something that you

00:37:10.920 --> 00:37:14.920
absolutely need to make sure
that your app is not doing.

00:37:15.010 --> 00:37:18.790
So you want to make sure that you use
this instrument to get rid of anything

00:37:18.790 --> 00:37:21.880
you see that involves leaked memory.

00:37:22.450 --> 00:37:28.120
So we're going to go to Choose Target and
select our breadcrumbs application.

00:37:28.790 --> 00:37:32.640
And now we're going to
go ahead and hit record.

00:37:32.730 --> 00:37:34.800
And on the device,
we're now recording all of the

00:37:34.840 --> 00:37:38.190
allocation information from the device.

00:37:38.520 --> 00:37:41.820
As we scroll through the table view,
we see we can see all these

00:37:41.820 --> 00:37:44.120
allocations happening.

00:37:44.400 --> 00:37:48.390
And what Leaks is doing is
counting down to evaluating our

00:37:48.390 --> 00:37:50.120
process and looking for leaks.

00:37:51.910 --> 00:37:55.100
We can see it's analyzed it,
and sure enough, we found a bunch.

00:37:55.140 --> 00:37:58.290
We actually see we've found 50
different leaks just through

00:37:58.290 --> 00:38:00.150
scrolling through the table view.

00:38:00.160 --> 00:38:03.600
So obviously, this is a big issue because
we've just scrolled,

00:38:03.730 --> 00:38:06.900
we've already leaked well
over 2 kilobytes of data.

00:38:06.900 --> 00:38:10.190
If somebody's going to be using
your app for a long period of time,

00:38:10.190 --> 00:38:11.390
that can really add up.

00:38:11.680 --> 00:38:14.460
And all of that is going to add
up against your app and slowly

00:38:14.460 --> 00:38:17.880
suffocate you in the amount of
memory that you have to work with.

00:38:19.110 --> 00:38:21.990
So let's dig into this and
see if we can figure out where

00:38:21.990 --> 00:38:23.860
these leaks are coming from.

00:38:25.400 --> 00:38:27.340
Now most importantly,
you'll notice the leaks instrument

00:38:27.340 --> 00:38:29.000
is actually two instruments.

00:38:29.010 --> 00:38:33.560
It's leaks plus its allocations,
so you can see all the different

00:38:33.560 --> 00:38:35.980
objects that are actually allocated.

00:38:36.270 --> 00:38:39.430
Now the allocations instrument has
got a couple interesting switches

00:38:39.540 --> 00:38:41.700
that you'll want to know about.

00:38:41.740 --> 00:38:45.200
So the first is record reference counts.

00:38:45.260 --> 00:38:48.900
Now what this is going to do is pay
attention to every single object

00:38:49.060 --> 00:38:52.440
in your application and look at
its reference count as it gets sent

00:38:52.460 --> 00:38:56.300
different messages like retain,
release, malloc, free,

00:38:56.370 --> 00:38:59.900
and it's going to record
all of this data for you.

00:38:59.950 --> 00:39:05.200
Now another one you should know
about is called identify C++ objects.

00:39:05.220 --> 00:39:09.350
Now this can be important if you're an
application that uses C++ because this is

00:39:09.350 --> 00:39:13.540
going to allow the allocations instrument
to gain a whole lot more information

00:39:13.870 --> 00:39:16.700
about your objects in your application.

00:39:17.490 --> 00:39:21.640
So let's go back to leaks and actually
take a look at what was leaked.

00:39:21.730 --> 00:39:24.980
You'll notice it looks like it
was a bunch of NSCF strings,

00:39:24.980 --> 00:39:28.680
which probably means it was just
you using a bunch of NSStrings that

00:39:28.680 --> 00:39:30.700
ended up getting leaked.

00:39:30.870 --> 00:39:34.230
If we press this turndown,
we can see all of the 50 different

00:39:34.230 --> 00:39:36.240
objects that were actually leaked.

00:39:36.330 --> 00:39:39.780
And in this case,
we can see the responsible library

00:39:39.780 --> 00:39:44.080
as well as the actual responsible
call that led to that leak.

00:39:44.450 --> 00:39:48.460
If we bring in the extended detail view,
we can also see where the

00:39:48.460 --> 00:39:49.990
allocation actually happened.

00:39:49.990 --> 00:39:52.560
We get to see a back
trace for the allocation.

00:39:52.600 --> 00:39:55.490
So let's just pick one of these
objects and see if we can get

00:39:55.570 --> 00:39:57.430
a little bit more information.

00:39:57.440 --> 00:40:03.050
So we'll click this little arrow here,
and this will actually jump into detailed

00:40:03.130 --> 00:40:05.950
history for this particular pointer.

00:40:06.000 --> 00:40:09.680
We can see the point in time when
the object was actually created,

00:40:09.680 --> 00:40:12.360
and we see it's got a
reference count of one.

00:40:12.980 --> 00:40:16.300
We see that it got retained
with a reference count of two,

00:40:16.300 --> 00:40:19.110
and then it got released,
and that went back down to

00:40:19.190 --> 00:40:20.530
a reference count of one.

00:40:20.540 --> 00:40:24.090
Now at this point,
apparently the leak happened.

00:40:24.100 --> 00:40:27.450
We lost a reference to this object,
but it's still around,

00:40:27.450 --> 00:40:29.370
it still has a retained count.

00:40:29.570 --> 00:40:32.680
So let's see if we can
figure out why that is.

00:40:34.040 --> 00:40:37.710
Now we notice from this first entry
where this object was actually created,

00:40:37.710 --> 00:40:39.690
that this happened in
our root view controller.

00:40:39.700 --> 00:40:43.360
So if we double click,
we can actually see the code

00:40:43.360 --> 00:40:46.090
where the allocation took place.

00:40:46.640 --> 00:40:51.940
We see that sure enough it's an
NSString called SubtitleText.

00:40:52.000 --> 00:40:56.770
And we just want to kind of scan
through here and see how we're using it.

00:40:56.990 --> 00:41:00.280
We notice that we're using it
as part of another call here for

00:41:00.360 --> 00:41:02.900
creating this breadcrumb cell.

00:41:03.040 --> 00:41:05.200
It all looks pretty ordinary.

00:41:05.280 --> 00:41:07.480
And later we do in fact release it.

00:41:07.550 --> 00:41:11.800
So it looks like we're pretty
balanced with our usage of allocating

00:41:11.800 --> 00:41:13.300
and releasing it in this method.

00:41:13.390 --> 00:41:16.730
So there must be something
else going on here.

00:41:17.100 --> 00:41:19.670
So let's go back to the pointer history.

00:41:19.790 --> 00:41:23.840
Now we notice here at some point
this object gets retained again.

00:41:23.940 --> 00:41:26.500
And interestingly,
our table view method is

00:41:26.500 --> 00:41:29.100
still on the back trace,
but now we've got this setter,

00:41:29.100 --> 00:41:30.990
this set location string.

00:41:31.330 --> 00:41:33.970
So let's look at what's going on there.

00:41:34.360 --> 00:41:36.700
Looks like when we
call setLocationString,

00:41:36.700 --> 00:41:38.800
we pass in a string.

00:41:38.870 --> 00:41:42.090
It makes a copy of what gets
passed in and just assigns

00:41:42.090 --> 00:41:45.160
that to our instance variable.

00:41:45.220 --> 00:41:47.850
Now,
the only problem here is that we're not

00:41:47.850 --> 00:41:51.700
actually doing any bookkeeping to make
sure that the old value that was in that

00:41:51.700 --> 00:41:54.800
instance variable is getting cleaned up.

00:41:54.870 --> 00:41:58.160
So this looks pretty sure like
this is probably our leak.

00:41:58.250 --> 00:42:02.710
So let's click the Xcode button
so we can jump to our editor.

00:42:02.930 --> 00:42:06.370
And now we can go ahead
and select this text.

00:42:06.370 --> 00:42:09.640
Let's paste in a new version here.

00:42:09.790 --> 00:42:11.900
And in this case,
what we're doing is we're checking

00:42:11.900 --> 00:42:15.760
to see if the instance variable and
the input are different objects.

00:42:15.760 --> 00:42:21.180
If they are, we release the old value,
we make a copy of the new value,

00:42:21.190 --> 00:42:24.400
and we update the instance variable.

00:42:26.010 --> 00:42:30.540
So now let's hit Build and Run to
get this pushed out to our device.

00:42:30.540 --> 00:42:32.700
We're building the app now.

00:42:32.700 --> 00:42:36.710
There's a bunch of assets,
so it takes a few moments.

00:42:38.740 --> 00:42:40.060
Our app is running.

00:42:40.130 --> 00:42:42.710
We're actually going to stop it for
a moment just so we can go back and

00:42:42.780 --> 00:42:45.640
verify the leaks have gone away.

00:42:45.740 --> 00:42:48.810
So we hit record in instruments.

00:42:49.100 --> 00:42:52.000
And now we're taking a
bunch of measurements.

00:42:52.100 --> 00:42:56.400
And if we go back to the
device and start scrolling,

00:42:56.520 --> 00:43:00.710
we see that we've got a
bunch of table view cells.

00:43:01.640 --> 00:43:06.740
And if we look back at Instruments,
it's about to analyze our process.

00:43:08.050 --> 00:43:10.780
And sure enough, the leaks are gone.

00:43:10.910 --> 00:43:14.550
So this is how you can use the
leaks instrument to get rid of

00:43:14.600 --> 00:43:18.520
those pesky leaks in your app and
reduce your memory usage overall.

00:43:20.120 --> 00:43:22.380
So today,
you learned how to use instruments

00:43:22.380 --> 00:43:26.480
to track down hotspots in your code,
identify memory leaks,

00:43:26.560 --> 00:43:28.700
and use system resources efficiently.

00:43:28.700 --> 00:43:31.670
I hope you'll be able to use
the information here to make

00:43:31.670 --> 00:43:33.550
your apps perform even better.

00:43:33.560 --> 00:43:36.140
I look forward to seeing
what you have in store.
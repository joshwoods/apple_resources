WEBVTT

00:00:20.580 --> 00:00:23.450
Hi, I'm Michael Jurewitz,
the Application Frameworks and

00:00:23.450 --> 00:00:27.240
Developer Tools Evangelist at Apple,
and welcome to Maximizing

00:00:27.250 --> 00:00:29.000
iPhone App Performance.

00:00:29.070 --> 00:00:33.450
Today, we're going to focus on helping
your application perform its best,

00:00:33.500 --> 00:00:35.620
and we're going to take a look
at everything from drawing and

00:00:35.620 --> 00:00:39.830
scrolling performance to minimizing
power consumption and optimizing

00:00:39.830 --> 00:00:42.060
memory usage in your application.

00:00:42.130 --> 00:00:44.660
Now, whether you're an application
or game developer,

00:00:44.670 --> 00:00:47.460
you'll find something to help
improve your development.

00:00:47.510 --> 00:00:49.360
So let's take a look.

00:00:49.960 --> 00:00:53.710
So today we're going to talk
about a whole bunch of topics.

00:00:53.790 --> 00:00:56.030
We're going to talk about
drawing and scrolling,

00:00:56.070 --> 00:00:59.970
application launch, memory usage,
files and data,

00:00:59.980 --> 00:01:01.270
and power and battery life.

00:01:01.340 --> 00:01:04.500
So to properly do performance
analysis on the iPhone,

00:01:04.500 --> 00:01:08.360
it's important to actually be familiar
with the tools in the first place.

00:01:08.360 --> 00:01:09.900
So let's take a look at those.

00:01:11.400 --> 00:02:14.500
[Transcript missing]

00:02:14.690 --> 00:02:16.960
Now when it comes to actually
choosing the right environment,

00:02:16.960 --> 00:02:19.840
there's a couple things to be aware of.

00:02:20.110 --> 00:02:24.540
The first is that the simulator is
an entirely valid place for you to

00:02:24.540 --> 00:02:26.390
do quite a bit of performance work.

00:02:26.460 --> 00:02:29.410
Really anything that
involves looking at memory,

00:02:29.410 --> 00:02:32.700
for example,
or the overall activity on the device.

00:02:32.700 --> 00:02:35.900
So whether you want to look
at leaks or object aleck,

00:02:36.220 --> 00:02:38.480
you can do that all in the simulator.

00:02:38.480 --> 00:02:42.070
And in fact, it's a lot more efficient
to do so for speed reasons.

00:02:42.070 --> 00:02:46.290
When you use something like object aleck,
we're having to record every

00:02:46.290 --> 00:02:49.790
single object event that
happens in your application.

00:02:50.000 --> 00:02:52.000
That can take a decent amount of time.

00:02:52.000 --> 00:02:55.140
And so doing that in the simulator
is nice because then you're

00:02:55.240 --> 00:02:58.500
operating on the fast Intel processor
on your desktop or laptop.

00:03:00.440 --> 00:03:02.460
Now, obviously,
you can also use the device,

00:03:02.610 --> 00:03:05.020
and for the wide range of
other types of profiling,

00:03:05.030 --> 00:03:06.580
this is what you want to use.

00:03:06.580 --> 00:03:10.200
So anytime you're looking at graphics,
or the precise timing

00:03:10.200 --> 00:03:13.060
of your application,
or when you want to use Shark,

00:03:13.160 --> 00:03:15.660
you want to be doing this on the device.

00:03:15.660 --> 00:03:19.700
So again, just make sure you're choosing
the right tuning environment.

00:03:21.540 --> 00:03:23.490
Alright, so let's hop right in.

00:03:23.500 --> 00:03:26.040
It's time to take a look
at drawing and scrolling.

00:03:27.700 --> 00:03:31.000
So now the various drawing technologies
on iPhone OS are pretty diverse.

00:03:31.000 --> 00:03:35.920
You've got Quartz, Core Animation,
OpenGL, built-in UIKit drawing,

00:03:35.920 --> 00:03:38.370
really just a lot of
options to choose from.

00:03:38.370 --> 00:03:43.350
And you want to make sure that you use
the built-in drawing whenever possible.

00:03:43.350 --> 00:03:48.800
Now, UIKit views are usually very
optimized at accomplishing their job.

00:03:48.800 --> 00:03:52.620
So UI Image View, UI Label,
they both know how to draw

00:03:52.620 --> 00:03:55.030
to screen very efficiently.

00:03:55.030 --> 00:03:57.460
So please use them whenever possible.

00:03:58.150 --> 00:04:00.800
Now, when you want to take advantage
of things like animation,

00:04:00.800 --> 00:04:03.250
you should also look at
the built-in controls,

00:04:03.250 --> 00:04:06.020
because in many cases,
they handle animation for you

00:04:06.020 --> 00:04:09.030
as you begin to change the
different properties on them.

00:04:09.030 --> 00:04:12.220
So try to prefer using those as
opposed to immediately rolling

00:04:12.220 --> 00:04:13.890
your own hand animations.

00:04:15.900 --> 00:04:19.910
When it comes to drawing optimizations,
and once you get down to custom drawing,

00:04:19.920 --> 00:04:23.430
you need to make sure that
you follow a couple key steps.

00:04:23.430 --> 00:04:27.190
The first is to make sure you
mark your views as opaque.

00:04:27.200 --> 00:04:29.720
This is absolutely critical.

00:04:29.720 --> 00:04:33.550
Now when you create a view by default,
it comes back as opaque,

00:04:33.550 --> 00:04:36.730
but there are some situations
where you might be tempted

00:04:36.950 --> 00:04:38.890
to set it to be translucent.

00:04:38.930 --> 00:04:41.230
You don't want that in most cases.

00:04:41.260 --> 00:04:44.660
When you make a view translucent,
there's a lot of complicated

00:04:44.660 --> 00:04:45.780
compositing work that has to be done.

00:04:45.800 --> 00:04:46.790
The second step is to make
sure you draw minimally.

00:04:47.010 --> 00:04:57.010
This means calling set needs display
in rect and passing in just the

00:04:57.010 --> 00:05:06.650
rectangle in your view that is
dirty and needs to be redrawn.

00:05:06.650 --> 00:05:09.670
Now when you do that,
you also need to make sure that

00:05:09.670 --> 00:05:13.590
in draw rect you actually check
the rectangle that gets passed in,

00:05:13.610 --> 00:05:15.780
so that you do only draw the
section that's in the rectangle.

00:05:15.800 --> 00:05:20.100
Obviously, it doesn't do much good if you
pass in the right rectangle

00:05:20.100 --> 00:05:23.590
into set needs display in rect,
and then in draw rect you

00:05:23.590 --> 00:05:25.420
just redraw everything.

00:05:28.650 --> 00:05:31.290
When it comes to custom drawing, again,
you want to make sure that you

00:05:31.290 --> 00:05:34.890
cache static drawing objects,
things like images, for example.

00:05:34.960 --> 00:05:38.330
You don't want to be constantly
loading these things from disk,

00:05:38.520 --> 00:05:41.680
but again, once you cache them,
you do still need to be prepared

00:05:41.680 --> 00:05:45.700
to respond to low memory warnings,
so do be prepared to release these.

00:05:47.670 --> 00:05:51.580
A really common bug that we see
with drawing involves timers.

00:05:51.600 --> 00:05:54.220
So when the user is using your
application and you're using

00:05:54.260 --> 00:05:57.480
a timer to draw to the screen,
and something like a text message

00:05:57.480 --> 00:06:00.920
comes in or a push notification,
your app gets suspended.

00:06:00.920 --> 00:06:03.990
A lot of times people forget
to invalidate the timer

00:06:03.990 --> 00:06:05.880
that's doing that drawing.

00:06:05.890 --> 00:06:08.650
And when they come back
from being suspended,

00:06:08.760 --> 00:06:10.530
they create a second timer.

00:06:10.550 --> 00:06:14.510
And now they're drawing 60 times a
second or 120 times a second or more,

00:06:14.550 --> 00:06:17.130
depending on how many
times they got interrupted.

00:06:17.800 --> 00:06:20.360
That'll burn through
your battery really fast.

00:06:20.360 --> 00:06:24.940
So do make sure that you invalidate those
old timers before you create new ones.

00:06:27.320 --> 00:06:31.590
You also want to make sure that you use
ping files for any of your image assets.

00:06:31.640 --> 00:06:34.900
Now we take these ping files and
we optimize them at build time.

00:06:34.910 --> 00:06:38.800
In this case,
we convert them from an unmultiplied

00:06:38.800 --> 00:06:42.380
RGBA to a pre-multiplied BGRA.

00:06:42.380 --> 00:06:46.510
If you're not sure what that means,
basically all that we're doing is taking

00:06:46.510 --> 00:06:50.240
the image and converting it to a format
that is most easily displayed fast

00:06:50.550 --> 00:06:52.900
and efficiently by iPhone's hardware.

00:06:52.900 --> 00:06:57.180
Now along the way,
we'll also remove some unnecessary data.

00:06:58.240 --> 00:06:59.860
And the compression rate
may actually increase,

00:06:59.950 --> 00:07:03.670
but in general, you'll still find that
your images look good.

00:07:03.670 --> 00:07:06.490
Next,
let's look at scrolling performance.

00:07:06.490 --> 00:07:09.530
Now scrolling performance is
one area where we see people

00:07:09.530 --> 00:07:12.790
tend to have a lot of trouble,
but there are some really simple

00:07:12.790 --> 00:07:16.300
rules that you can follow to
help increase this performance.

00:07:16.300 --> 00:07:19.050
So first and foremost, use opaque views.

00:07:19.050 --> 00:07:22.250
Again, anytime that you don't
use an opaque view,

00:07:22.250 --> 00:07:26.150
we're going to have to do a
bunch of expensive compositing.

00:07:26.160 --> 00:07:27.180
That takes time, but it's a lot of work.

00:07:28.200 --> 00:07:30.320
And the reason why you want to use opaque
views is because it's a lot of time,

00:07:30.340 --> 00:07:31.200
it slows down your scrolling,
and really it's pretty easy to avoid.

00:07:31.200 --> 00:07:34.070
So make sure your views
are marked as opaque.

00:07:34.100 --> 00:07:39.200
You also want to make sure that you avoid
allocating views while you're scrolling.

00:07:39.200 --> 00:07:42.560
Now when you think about it,
allocation in general can be very,

00:07:42.560 --> 00:07:43.500
very expensive.

00:07:43.580 --> 00:07:46.670
In sort of the worst case,
you actually have to go down to the

00:07:46.670 --> 00:07:50.720
kernel and wait for it to do a bunch of
bookkeeping to actually give you back the

00:07:50.720 --> 00:07:53.010
region of memory for you to work with.

00:07:53.070 --> 00:07:56.000
If you're doing this time and
time and time again while you're

00:07:56.000 --> 00:07:57.180
trying to scroll in new images,
you're going to have to do a bunch of

00:07:57.180 --> 00:07:57.180
bookkeeping to actually give you back the
region of memory for you to work with.

00:08:27.160 --> 00:08:27.160
And if you're dealing with a movie
cell that looks something like this,

00:08:27.160 --> 00:08:27.160
in this case we've got a table view cell,
we're showing a movie poster,

00:08:27.160 --> 00:08:27.160
we've got a title, a description,
who actually was in the movie,

00:08:27.160 --> 00:08:27.160
a rating image.

00:08:27.160 --> 00:08:27.160
Well, there's a lot of different
views that are made up here.

00:08:27.160 --> 00:08:27.160
You've got an image view for the poster,
you've got a UI label for the

00:08:27.160 --> 00:08:27.160
text for the title of the movie,
another UI label for

00:08:27.160 --> 00:08:27.160
who was actually in it,
another UI label for

00:08:27.160 --> 00:08:27.160
the title of the movie,
and then you've got a table view

00:08:27.160 --> 00:08:27.160
cell that looks something like this.

00:08:36.490 --> 00:08:57.140
And then you've got a table
view cell for the description,

00:08:57.140 --> 00:08:57.140
and then another UI image view
for the actual movie rating image.

00:08:57.140 --> 00:08:57.140
So already in that relatively
simple movie summary cell,

00:08:57.140 --> 00:08:57.140
we've got a ton of
different stuff going on.

00:08:57.140 --> 00:08:57.140
So the way to avoid having all that
allocation is to reuse your table cells.

00:08:57.140 --> 00:08:57.140
You do that by tagging your table
cells with a reuse identifier.

00:08:57.140 --> 00:08:57.140
And then when you actually go into
cell for row at index path and

00:08:57.140 --> 00:08:57.140
you're actually trying to do that,
you're going to have to do

00:08:57.140 --> 00:08:57.140
a lot of different things.

00:09:00.290 --> 00:09:05.150
And then when you actually go into
cell for row at index path and

00:09:05.150 --> 00:09:05.150
you're actually trying to do that,
you're going to have to do

00:09:05.150 --> 00:09:05.150
a lot of different things.

00:09:05.510 --> 00:09:09.230
So now let's look at how
scrolling usually works if

00:09:09.230 --> 00:09:11.600
you don't reuse your cells.

00:09:12.150 --> 00:09:15.950
So you've got a table view and
you go to scroll in some content,

00:09:16.000 --> 00:09:19.340
it comes in from the bottom,
it goes through the top,

00:09:19.450 --> 00:09:21.540
and ends up going off screen.

00:09:21.690 --> 00:09:24.900
And then the cells go away,
they get deallocated,

00:09:25.080 --> 00:09:27.300
the memory gets reclaimed by the system.

00:09:27.300 --> 00:09:31.660
And then you have to reallocate
to get new views on screen.

00:09:31.830 --> 00:09:36.660
Now once you go and actually add in
the use of this reuse identifier,

00:09:36.670 --> 00:09:38.940
it looks something like this.

00:09:39.350 --> 00:09:41.300
You've got a bunch of cells.

00:09:41.300 --> 00:09:43.000
You scroll them in.

00:09:43.070 --> 00:09:44.560
They go on screen.

00:09:44.630 --> 00:09:45.580
They go off screen.

00:09:45.580 --> 00:09:50.780
And then when you have new content
that needs to come back on screen,

00:09:50.780 --> 00:09:54.770
we take those existing cells,
bring them right back around,

00:09:54.870 --> 00:09:58.020
and feed them right
back into the interface.

00:09:59.530 --> 00:10:01.930
So basically,
we're just keeping a ring buffer of cells

00:10:01.930 --> 00:10:04.340
and reusing these things over and over.

00:10:04.340 --> 00:10:08.610
This helps you avoid allocating all
those views and lets you basically just

00:10:08.610 --> 00:10:11.240
stuff in the new information to display.

00:10:11.240 --> 00:10:15.260
Now, this will take you a long way,
but to get the best scrolling

00:10:15.260 --> 00:10:18.300
performance possible,
you'll need to collapse

00:10:18.450 --> 00:10:20.160
your cell view hierarchy.

00:10:20.260 --> 00:10:22.130
Now, what does that mean exactly?

00:10:22.220 --> 00:10:26.370
Well, we've got our cell here,
in this case, this movie summary cell.

00:10:27.040 --> 00:10:28.260
And we've got all these individual views.

00:10:29.500 --> 00:10:29.820
And we've got all these
individual views that we're

00:10:29.820 --> 00:10:30.630
actually displaying in the cell.

00:10:31.590 --> 00:10:34.240
If we wanted to collapse
the cell view hierarchy,

00:10:34.240 --> 00:10:37.450
we would end up with a cell that
looks something more like this,

00:10:38.440 --> 00:10:42.300
where we just had a single view,
in this case, this movie view,

00:10:42.310 --> 00:10:45.470
that knows how to draw
all of its contents.

00:10:46.480 --> 00:10:49.610
By moving to this model,
we're able to just have one view

00:10:49.610 --> 00:10:53.090
do the drawing and just composite
all that information once,

00:10:53.090 --> 00:10:57.940
as opposed to having to ask each and
every individual view to do its drawing,

00:10:57.940 --> 00:11:00.700
Michael Jurewitz and then
stitch that all together.

00:11:00.940 --> 00:11:03.410
Now,
if it's not clear what's happened here,

00:11:03.410 --> 00:11:07.700
conceptually we've gone from our
table view cell with its content view,

00:11:07.700 --> 00:11:10.900
and that content view of course
has pointers to all the different

00:11:10.900 --> 00:11:12.680
sub views that it's displaying.

00:11:12.680 --> 00:11:17.120
So we've gone from this
to just a single view,

00:11:17.130 --> 00:11:19.100
this movie view.

00:11:19.320 --> 00:11:22.390
So let's go ahead and
hop into a demo here.

00:11:22.580 --> 00:11:25.170
And I'm going to start off with
an application that doesn't

00:11:25.270 --> 00:11:30.200
scroll too well and show you how
you can help it scroll faster.

00:11:32.880 --> 00:11:35.970
So let's take a look at a
really simple demo application.

00:11:36.130 --> 00:11:38.050
In this case here,
we're just going to take a look at an

00:11:38.050 --> 00:11:39.810
application that shows a list of movies.

00:11:39.830 --> 00:11:42.470
So I'm just going to
select Build and Run,

00:11:42.510 --> 00:11:45.340
and let's take a look
at this on the iPhone.

00:11:45.480 --> 00:11:49.400
Okay, our application is launched and
we've got our user interface here.

00:11:49.450 --> 00:11:52.060
Now we can go scrolling
through the data that's here,

00:11:52.060 --> 00:11:55.840
and we see that this scrolls fairly well,
but it's a little clunky in places.

00:11:55.840 --> 00:11:59.920
We see a couple little jerks as we
go scrolling through this content.

00:11:59.920 --> 00:12:03.800
So we can actually take this
behavior and make it even better.

00:12:03.800 --> 00:12:07.090
So let's go back to instruments and
try to figure out what's going on.

00:12:08.100 --> 00:12:11.160
So we're going to take our
application that we've already built,

00:12:11.160 --> 00:12:14.890
go to the Run menu,
and select Run with Performance Tool.

00:12:15.180 --> 00:12:18.730
Now we're going to take a
look at object allocations.

00:12:19.440 --> 00:12:21.970
This will go ahead and
start up instruments,

00:12:21.970 --> 00:12:25.240
and in this case it's going to start
the application on our iPhone again,

00:12:25.240 --> 00:12:29.560
and we're going to get a chance to see
our memory usage live on the device.

00:12:29.560 --> 00:12:34.710
So now if I go to the iPhone and just
start scrolling through the content,

00:12:34.710 --> 00:12:37.880
things are going to be
a little bit slower,

00:12:37.880 --> 00:12:40.250
but in this case it's because
we're recording a lot of

00:12:40.330 --> 00:12:42.900
information from the iPhone itself,
so this is okay.

00:12:42.900 --> 00:12:46.850
What we want to pay attention to
is what's actually happening to our

00:12:46.850 --> 00:12:49.080
graph of objects in instruments.

00:12:49.400 --> 00:12:53.600
We see that this graph is
slowly growing over time.

00:12:53.600 --> 00:12:57.600
That's not the kind of thing that you
want to see as you're just scrolling

00:12:57.600 --> 00:12:59.700
through a static list of content.

00:13:01.120 --> 00:13:03.720
So I'm going to go ahead and
stop this and see if we can

00:13:03.720 --> 00:13:05.310
figure out what's going on.

00:13:06.900 --> 00:13:09.260
Now, as you begin to tackle
these kind of problems,

00:13:09.260 --> 00:13:12.420
you want to think to yourself, well,
self, what sort of classes am

00:13:12.420 --> 00:13:14.000
I working with at this point?

00:13:14.010 --> 00:13:16.630
Well, obviously, we've got a table view.

00:13:16.760 --> 00:13:18.330
It's got table view cells.

00:13:18.450 --> 00:13:20.940
So let's go ahead and search for cell.

00:13:22.610 --> 00:13:27.340
Now we see all the different allocations
that we have for this movie summary cell,

00:13:27.340 --> 00:13:30.750
which is the cell subclass that
we're using in our application.

00:13:30.760 --> 00:13:34.270
In this case,
you'll notice that we have 127

00:13:34.480 --> 00:13:40.460
objects that are still living and 127
objects overall that we've allocated.

00:13:40.500 --> 00:13:43.030
This is not the kind of
thing that you want to see,

00:13:43.050 --> 00:13:46.880
especially when your table view
only has 20 or 30 items in it.

00:13:46.960 --> 00:13:49.730
This is our first indication
that there's probably a leak

00:13:49.730 --> 00:13:51.280
that we need to take care of.

00:13:52.320 --> 00:13:55.510
So let's go ahead and take a look at
this movie summary cell and see if

00:13:55.510 --> 00:13:57.410
we can figure out what's going on.

00:13:58.760 --> 00:14:02.280
I'm going to click this arrow right
here and this will jump to all of

00:14:02.460 --> 00:14:06.330
the individual allocations that I've
made of this movie summary cell.

00:14:06.330 --> 00:14:09.570
And you'll notice that all along
the way I see which ones are

00:14:09.570 --> 00:14:11.480
still alive with this black dot.

00:14:11.480 --> 00:14:14.720
Now I'm just going to select
any one of these things because

00:14:14.720 --> 00:14:16.360
they all look to be the same.

00:14:16.360 --> 00:14:19.920
And if I click the button for the
extended detail view down here,

00:14:19.920 --> 00:14:23.870
I'll get a chance to see a back trace
for each one of these allocations.

00:14:23.870 --> 00:14:28.680
And this is going to be the same as the
back trace for the movie summary cell.

00:14:28.700 --> 00:14:33.300
In this case, I can see exactly where
this allocation came from.

00:14:33.300 --> 00:14:35.390
And we see this line
in my code right here,

00:14:35.390 --> 00:14:39.020
this movies view controller table
view cell for row at index path.

00:14:39.070 --> 00:14:40.160
That makes sense.

00:14:40.160 --> 00:14:41.830
So let's double click that.

00:14:42.090 --> 00:14:45.360
And in instruments,
we actually get a chance to see the

00:14:45.360 --> 00:14:47.610
actual allocation that took place.

00:14:47.820 --> 00:14:51.210
We see that I've allocated
and knitted with a style.

00:14:51.210 --> 00:14:54.690
In this case,
I've just passed in the default style.

00:14:54.690 --> 00:14:57.220
I'm not using a reuse identifier.

00:14:57.220 --> 00:15:00.680
And moreover,
I've not actually releasing this cell.

00:15:00.680 --> 00:15:01.980
So let's see here.

00:15:01.980 --> 00:15:03.680
Do we ever release it?

00:15:03.900 --> 00:15:04.110
Nope.

00:15:04.520 --> 00:15:05.680
Well, that's a problem right there.

00:15:05.680 --> 00:15:09.670
The table view expects to be
receiving an auto-release object.

00:15:09.670 --> 00:15:13.100
And since we haven't auto-released it,
this is getting leaked as we go

00:15:13.200 --> 00:15:15.030
scrolling through our application.

00:15:15.030 --> 00:15:19.800
So let's click the Xcode
button here to jump to Xcode.

00:15:19.800 --> 00:15:27.680
We jump directly to the source
file that we want to work with.

00:15:27.920 --> 00:15:28.660
And I'm going to go ahead and just
add auto-release to this method.

00:15:28.660 --> 00:15:29.700
And I'm going to Thank you.

00:15:29.870 --> 00:15:33.040
We see Xcode adds the bracket for me.

00:15:33.040 --> 00:15:36.300
I'll hit save, and now I'm just going
to build my application.

00:15:36.300 --> 00:15:40.100
Go into the build menu
and selecting build.

00:15:40.260 --> 00:15:42.350
We see it succeeds.

00:15:42.350 --> 00:15:44.800
And now I'm going to go back
to Run with Performance tool

00:15:44.800 --> 00:15:47.680
and go to Object Allocations.

00:15:48.320 --> 00:15:52.090
We'll reinstall the application
onto our iPhone and we'll

00:15:52.090 --> 00:15:53.320
launch back into Instruments.

00:15:53.320 --> 00:15:56.400
All right, we see that we've been
recording some data here.

00:15:56.510 --> 00:15:59.840
We've got some information
about our application.

00:15:59.840 --> 00:16:03.780
And now what I'm going to do is go ahead
and scroll through this data again and

00:16:03.780 --> 00:16:06.690
let's see what happens in Instruments.

00:16:06.870 --> 00:16:08.000
So I go scrolling through.

00:16:08.000 --> 00:16:09.720
Again,
things are kind of slow because we're

00:16:09.720 --> 00:16:14.100
collecting a bunch of information about
these individual allocation events.

00:16:14.100 --> 00:16:17.600
And as I look back at instruments,
I can see that the

00:16:17.600 --> 00:16:19.480
graph is flat over time.

00:16:19.500 --> 00:16:21.420
This is exactly what you want to see.

00:16:21.420 --> 00:16:24.760
If I hide this extended detail view,
you notice that we've

00:16:24.760 --> 00:16:29.320
allocated 60 cells overall,
which is less efficient than we could be,

00:16:29.870 --> 00:16:32.690
but we only have six
that are still living,

00:16:32.700 --> 00:16:36.060
which is exactly what makes sense
based on about how much content

00:16:36.060 --> 00:16:37.600
we're able to fit on the screen.

00:16:38.970 --> 00:16:41.980
Okay, so we've tracked down this
leak and we've fixed that.

00:16:42.020 --> 00:16:44.930
But we're still not reusing
our table view cells.

00:16:44.950 --> 00:16:48.740
So let's go back to that
same code and make that fix.

00:16:48.740 --> 00:16:52.330
So I'm going to go back
to my Xcode project.

00:16:52.710 --> 00:16:56.520
And in this case,
I want to change this reuse identifier.

00:16:56.590 --> 00:17:01.280
So I'm going to go ahead and just
insert some new code here and get rid

00:17:01.330 --> 00:17:04.240
of the old code that we previously had.

00:17:04.880 --> 00:17:08.180
So we see now we're declaring
an NSString with this

00:17:08.180 --> 00:17:12.600
movie summary identifier,
and we simply pass this in to

00:17:12.600 --> 00:17:15.800
DQ reusable cell with identifier.

00:17:15.990 --> 00:17:19.020
Now if there are any cells to reuse,
we'll go ahead and have

00:17:19.020 --> 00:17:20.360
one handed back to us.

00:17:20.360 --> 00:17:23.170
If we get back nil,
it's our indication that we

00:17:23.170 --> 00:17:26.370
need to go ahead and create
a new movie summary cell,

00:17:26.370 --> 00:17:27.720
which we do here.

00:17:29.670 --> 00:17:33.760
After that, we go ahead and set the new
content into our particular cell.

00:17:33.760 --> 00:17:36.560
Here we're just updating the
information that it's going to display,

00:17:36.560 --> 00:17:39.120
and then we return
that to the table view.

00:17:39.140 --> 00:17:44.310
So now I'm going to go ahead
and build this project again.

00:17:45.340 --> 00:17:50.140
And then go to the Run menu and again
select Run with Performance Tool and

00:17:50.140 --> 00:17:52.470
take a look at Object Allocations.

00:17:52.470 --> 00:17:57.420
And we'll go ahead and install
this application on our iPhone.

00:18:03.920 --> 00:18:07.160
We launch into instruments and
immediately begin collecting

00:18:07.160 --> 00:18:08.820
data about our application.

00:18:08.940 --> 00:18:12.200
We can see our movie summary
cell is now showing up.

00:18:12.300 --> 00:18:15.780
And as I begin to scroll
through my application,

00:18:15.910 --> 00:18:20.900
we'll see that the number of overall
cells that have been created is seven,

00:18:20.980 --> 00:18:23.790
and the number living is also seven.

00:18:23.890 --> 00:18:27.730
That's exactly what you want to
see with table view cell reuse.

00:18:27.830 --> 00:18:30.120
As you go scrolling
through your application,

00:18:30.220 --> 00:18:32.930
if you're properly reusing
your table view cells,

00:18:33.070 --> 00:18:36.820
they should stay pretty much stationary
right around a reasonable number

00:18:36.820 --> 00:18:39.980
of cells to be displayed on screen.

00:18:39.980 --> 00:18:40.640
So that's great.

00:18:40.640 --> 00:18:42.770
We fixed that bug.

00:18:44.790 --> 00:18:48.760
Now if I go ahead and just launch this
application one more time on the phone,

00:18:48.760 --> 00:18:51.450
you'll get a chance to see some of the
difference that this actually made.

00:18:51.480 --> 00:18:56.820
So we'll go back to the iPhone,
launch our application.

00:18:58.990 --> 00:19:02.440
And as I go scrolling through here,
you'll notice this is already scrolling

00:19:02.770 --> 00:19:04.900
much faster than it was before.

00:19:04.980 --> 00:19:08.860
It's much more responsive with my finger,
and you see we can go through a

00:19:08.930 --> 00:19:10.890
lot of content without any skips.

00:19:10.900 --> 00:19:14.900
Now as it turns out,
we can actually do even better than this.

00:19:14.900 --> 00:19:15.870
So let's go back to instruments.

00:19:15.900 --> 00:19:19.550
The next thing we want to look at in
our application is make sure that we're

00:19:19.660 --> 00:19:21.720
not doing any unnecessary compositing.

00:19:21.900 --> 00:19:26.160
So I'm going to go ahead and close
this document window in instruments.

00:19:27.100 --> 00:19:29.130
Now we're going to bring up a new one.

00:19:29.130 --> 00:19:32.000
And in this case, I'm going to go to the
Core Animation instrument.

00:19:32.000 --> 00:19:35.990
Now the Core Animation instrument
lets you see lots of really

00:19:36.110 --> 00:19:38.840
detailed information about
how you're doing your drawing.

00:19:38.870 --> 00:19:41.880
You'll see we have the
instrument selected up here.

00:19:41.880 --> 00:19:45.590
And if I go and bring in the individual
information on this instrument,

00:19:45.590 --> 00:19:48.880
there's a bunch of different
options for me to choose from.

00:19:48.910 --> 00:19:52.860
The one that we're going to be using
primarily is Color Blended Layers.

00:19:52.860 --> 00:19:56.980
Color Blended Layers is going to
change the color of any user interface.

00:19:57.000 --> 00:20:00.160
It's going to change the color
of any user interface element

00:20:00.160 --> 00:20:03.640
in our actual interface that
happens to be getting composited.

00:20:03.640 --> 00:20:07.930
Now some other really useful ones to use
are things like Flash Updated Regions.

00:20:07.930 --> 00:20:10.760
This is going to flash a
region of the screen yellow any

00:20:10.760 --> 00:20:14.040
time you update that content,
usually through redrawing.

00:20:14.060 --> 00:20:17.210
This is a great way to check
that rectangle that you pass into

00:20:17.210 --> 00:20:21.520
DrawRect and make sure that you're
only drawing the minimal amount.

00:20:21.750 --> 00:20:26.340
So now what I'm going to do is go ahead
and click this color blended layers.

00:20:26.340 --> 00:20:30.910
And I'm going to do this with my
application already active on the phone.

00:20:30.910 --> 00:20:33.390
So let's take a look at the phone first.

00:20:33.390 --> 00:20:36.060
So I've got my application
up on the phone,

00:20:36.060 --> 00:20:40.620
and I'm going to go ahead and click
color blended layers and instruments,

00:20:40.620 --> 00:20:44.840
and boom, you see the color changes
in my interface immediately.

00:20:44.840 --> 00:20:49.390
And I get a chance to see all the
different places where I'm compositing.

00:20:49.390 --> 00:20:54.620
Now the key here is that green
means good and red means bad.

00:20:54.720 --> 00:20:56.990
So all of these different
places where we've got text,

00:20:57.060 --> 00:21:00.400
you can see we're compositing
all this information,

00:21:00.400 --> 00:21:02.530
and that's slower than it could be.

00:21:02.610 --> 00:21:06.720
So let's go back to our code and see if
we can figure out why this is the case.

00:21:06.770 --> 00:21:09.760
So we'll go back to Xcode.

00:21:10.400 --> 00:21:12.360
And in this case,
I'm lucky enough to have been

00:21:12.360 --> 00:21:14.900
the author of this project,
so I know a little bit about

00:21:14.900 --> 00:21:16.540
how this actually works.

00:21:16.640 --> 00:21:21.880
So I'm going to go ahead and
go into my movie summary cell.

00:21:22.250 --> 00:21:27.130
And I've got a method here
for creating a new label.

00:21:27.130 --> 00:21:30.940
And we see, sure enough,
here I set clear color as the

00:21:30.940 --> 00:21:33.810
background color for the label.

00:21:34.010 --> 00:21:36.030
Now, if you're clever,
you've probably thought to yourself,

00:21:36.100 --> 00:21:36.720
well, wait a second.

00:21:36.720 --> 00:21:39.770
If I've got a table view,
of course I want the background

00:21:39.880 --> 00:21:41.160
on the label to be clear.

00:21:41.160 --> 00:21:45.240
Because when a user taps on a row,
I want it to properly highlight.

00:21:45.240 --> 00:21:47.200
Well, yes, you're right.

00:21:47.300 --> 00:21:48.220
You do want that.

00:21:48.260 --> 00:21:51.100
But as it turns out,
the UIKit engineers have already

00:21:51.210 --> 00:21:52.800
thought about this for you.

00:21:52.920 --> 00:21:56.140
And so all you need to do is
actually specify whatever color

00:21:56.140 --> 00:22:00.050
you want as the background for
your cell to avoid compositing.

00:22:00.060 --> 00:22:01.420
Say something like white color.

00:22:02.310 --> 00:22:04.330
And when the user
actually selects the row,

00:22:04.390 --> 00:22:08.260
we will go through the view hierarchy
and properly take that label and

00:22:08.260 --> 00:22:12.380
turn its background to clear so the
background gradient can shine through.

00:22:12.380 --> 00:22:15.810
And if the user deselects that row,
we take care of setting

00:22:15.810 --> 00:22:17.250
it back to what it was.

00:22:17.260 --> 00:22:20.060
So again,
the proper thing to do in this case

00:22:20.060 --> 00:22:25.280
is to take out this clear color and
go ahead and use white color instead.

00:22:26.960 --> 00:22:32.000
I'll go ahead and save and
hit build and run to redeploy

00:22:32.000 --> 00:22:33.710
the application to my phone.

00:22:33.710 --> 00:22:36.520
And with the application launched,
we can see we've got a

00:22:36.520 --> 00:22:37.980
nice green interface.

00:22:37.980 --> 00:22:40.840
This is what you want to see,
just the sea of green.

00:22:40.840 --> 00:22:45.280
This is your way of knowing that you're
not doing any unnecessary compositing.

00:22:45.280 --> 00:22:47.310
All right, so that's great.

00:22:47.340 --> 00:22:49.340
Let's go back to Xcode.

00:22:49.340 --> 00:22:52.850
So it turns out you can actually get
one step better than any of this.

00:22:52.850 --> 00:22:55.680
So let's look at a different
version of our project.

00:22:56.600 --> 00:22:59.760
In this case, we're going to look at what
happens when you go ahead and

00:22:59.760 --> 00:23:01.560
collapse the cell view hierarchy.

00:23:01.560 --> 00:23:05.500
Now, for our application,
we've gone ahead and we've done a

00:23:05.600 --> 00:23:09.000
bunch of laying out of different views,
and all these views are doing their

00:23:09.040 --> 00:23:12.300
own drawing and then compositing
their information together.

00:23:12.310 --> 00:23:15.300
But that has some associated expense.

00:23:15.420 --> 00:23:18.470
Now, if you want to get the
smoothest possible scrolling,

00:23:18.590 --> 00:23:21.220
you need to collapse
your cell view hierarchy.

00:23:21.220 --> 00:23:24.200
And basically,
all that means is you're implementing

00:23:24.200 --> 00:23:26.300
a single view that knows how to do
all of the things that you're doing.

00:23:26.320 --> 00:23:27.780
all of the drawing.

00:23:27.820 --> 00:23:30.960
So let's take a look at what
that drawing code looks like.

00:23:31.480 --> 00:23:36.100
In this case we just look at the
Draw Rect for our Movie Summary view.

00:23:36.200 --> 00:23:38.690
And we can see that it's
really pretty straight forward.

00:23:38.690 --> 00:23:42.540
You know, first we set up the title
font that we want to use,

00:23:42.550 --> 00:23:45.120
we set up the color we
want to use for this font,

00:23:45.120 --> 00:23:48.020
we go and grab the rating
image that we want to use,

00:23:48.080 --> 00:23:51.660
and then it turns into a bunch of,
basically, just math to figure out where

00:23:51.660 --> 00:23:53.430
we want to draw all this stuff.

00:23:53.600 --> 00:23:54.710
So what's the title point?

00:23:54.720 --> 00:23:57.320
Where do we actually want
to be drawing the title?

00:23:57.430 --> 00:24:00.820
How do we want the text
to either break or not?

00:24:00.820 --> 00:24:03.100
We take care of drawing that text.

00:24:03.100 --> 00:24:07.460
We take care of drawing the
image into our particular view.

00:24:07.460 --> 00:24:10.640
We go ahead and we check to see, hey,
does this movie have a cast that

00:24:10.640 --> 00:24:12.960
we want to list out and show?

00:24:12.960 --> 00:24:16.280
Does this movie have a synopsis
that we want to list out and show?

00:24:16.480 --> 00:24:21.180
And how about a thumbnail image to show
for the actual movie itself as well?

00:24:21.180 --> 00:24:23.630
So as we can see,
it's quite a bit of code to get

00:24:23.630 --> 00:24:25.200
done all this different drawing.

00:24:25.210 --> 00:24:28.410
So it's not without some effort
that you'll have to get this done.

00:24:28.520 --> 00:24:33.340
But let's take a view at our application,
and see just how fast it really scrolls.

00:24:33.400 --> 00:24:36.080
So we'll build and run
with this application,

00:24:36.080 --> 00:24:37.680
and go to our iPhone.

00:24:37.680 --> 00:24:39.460
And now when we go
scrolling through this,

00:24:39.460 --> 00:24:41.620
we see this is just silky smooth.

00:24:41.620 --> 00:24:45.220
This is ultra-fast scrolling performance.

00:24:45.220 --> 00:24:47.080
Really incredible.

00:24:47.080 --> 00:24:49.320
Now,
you get this fast scrolling performance,

00:24:49.320 --> 00:24:53.320
but the one downside is that all
of these individual rows here are

00:24:53.520 --> 00:24:55.860
now just flat bitmap graphics.

00:24:55.860 --> 00:24:58.980
And so you won't get things like
cell row highlights by default.

00:24:59.060 --> 00:25:02.140
You're going to have to handle
that logic for yourself.

00:25:02.140 --> 00:25:04.650
You also won't get things
like copy and paste support.

00:25:04.650 --> 00:25:07.640
So if you want to implement
in that in your application,

00:25:07.640 --> 00:25:10.320
you're going to have
to handle that custom.

00:25:10.320 --> 00:25:12.470
The other thing you don't
get is accessibility,

00:25:12.470 --> 00:25:14.910
which is a big downside,
especially if you've got

00:25:14.910 --> 00:25:16.300
users with special needs.

00:25:16.300 --> 00:25:19.900
So you need to make sure that you weigh
the considerations here before you

00:25:19.900 --> 00:25:22.560
necessarily dive down to this method.

00:25:22.560 --> 00:25:25.340
But in any event,
this is how you're going to get the

00:25:25.340 --> 00:25:27.940
best scrolling performance possible.

00:25:27.940 --> 00:25:30.590
Now, if you were to do something
like this on a 3GS,

00:25:30.640 --> 00:25:33.360
you might not notice the
difference between the different

00:25:33.360 --> 00:25:34.880
optimizations that I showed you.

00:25:35.060 --> 00:25:37.930
But remember,
we still sell the iPhone 3G.

00:25:38.010 --> 00:25:40.540
In fact, it's a very popular device.

00:25:40.540 --> 00:25:43.750
And so you want to make sure that
you're eking out all of these different

00:25:43.750 --> 00:25:46.060
performance improvements that you can.

00:25:46.060 --> 00:25:48.670
All right, let's head back to the slides.

00:25:49.870 --> 00:25:52.140
Alright,
so you've had a chance to see just how

00:25:52.140 --> 00:25:56.480
easy it is to help your application
scroll faster and perform at its best.

00:25:56.510 --> 00:26:01.670
And you also saw how powerful Instruments
is and how you can get lots of detailed

00:26:01.740 --> 00:26:05.280
information about it to understand
how your application is performing.

00:26:05.280 --> 00:26:09.050
Alright, so in summary,
we've taken a look at marking your

00:26:09.050 --> 00:26:12.810
views as opaque so you can avoid
all that unnecessary compositing.

00:26:12.810 --> 00:26:17.400
We've talked about drawing minimally,
so using set needs display and rect,

00:26:17.530 --> 00:26:19.780
and actually checking the
rectangle that gets passed in.

00:26:19.800 --> 00:26:25.110
We've talked about reusing table cells,
and also using ping files and

00:26:25.110 --> 00:26:28.390
making optimal use of the hardware.

00:26:28.630 --> 00:26:31.000
Alright, so we've talked about
drawing and scrolling,

00:26:31.240 --> 00:26:34.190
let's go into application launch.

00:26:34.740 --> 00:26:37.510
Now when it comes to application launch,
you want to make sure that

00:26:37.510 --> 00:26:41.800
you're designing your application
for fast launch and short use.

00:26:41.800 --> 00:26:46.090
When you think about iPhone in general,
this is a device where people are pulling

00:26:46.120 --> 00:26:50.270
their phone out at a moment's notice
and using your application in context.

00:26:50.320 --> 00:26:52.960
Maybe they're on a street corner
and they're trying to pull out

00:26:53.200 --> 00:26:56.050
some valuable piece of information
from your actual application.

00:26:56.080 --> 00:26:59.080
Or they just want to get one
really important thing and

00:26:59.220 --> 00:27:00.790
then get on with their life.

00:27:00.800 --> 00:27:04.680
So you need to make sure that you
consider the user's immediate need.

00:27:04.700 --> 00:27:07.920
And to do that,
you need to make sure that your

00:27:07.920 --> 00:27:10.700
app launches and quits really fast.

00:27:11.110 --> 00:27:16.740
Now the key here is to get your
UI on screen as quickly as possible.

00:27:16.910 --> 00:27:20.280
And actually,
for one of the first times in your life,

00:27:20.360 --> 00:27:23.270
this is a time when it's
OK for you to be lazy.

00:27:23.280 --> 00:27:26.590
In fact,
you want to design your apps for that

00:27:26.590 --> 00:27:31.320
fast launch and short use by being lazy,
by doing as little as

00:27:31.320 --> 00:27:33.410
possible on app launch.

00:27:33.420 --> 00:27:36.880
So this means if you've got data,
load that lazily.

00:27:36.880 --> 00:27:39.200
Wait until you actually need it.

00:27:39.300 --> 00:27:42.940
You want to make sure that you've
got a small nib file and that

00:27:42.940 --> 00:27:45.070
your initial UI is very compact.

00:27:45.640 --> 00:27:49.840
If you've got other images or assets or
different views that you need to load in

00:27:49.840 --> 00:27:53.180
but they're not on screen at the start,
be lazy.

00:27:53.180 --> 00:27:53.910
Put it off.

00:27:53.910 --> 00:27:55.980
Wait until you actually need them.

00:27:57.280 --> 00:28:02.200
You also want to make sure that you don't
perform synchronous network operations

00:28:02.200 --> 00:28:04.680
in application did finish launching.

00:28:04.680 --> 00:28:08.040
That is just a recipe for bad times.

00:28:08.040 --> 00:28:13.460
Doing that might put you in a situation,
if the user has a bad cell connection,

00:28:13.460 --> 00:28:16.640
where it'll take a long,
long time to get back data or

00:28:16.640 --> 00:28:20.840
whatever it is that you happen to
be trying to get off the network.

00:28:21.260 --> 00:28:24.050
That might take potentially
more than five seconds,

00:28:24.050 --> 00:28:27.060
in which case iPhone is going
to wonder why you haven't been

00:28:27.060 --> 00:28:30.600
servicing the user events and
your application might get quit.

00:28:30.600 --> 00:28:33.140
So please,
use the asynchronous version for

00:28:33.160 --> 00:28:37.440
networking if you must do stuff in
the application did finish launching,

00:28:37.440 --> 00:28:40.790
or kick off an operation in the
background to load in your data

00:28:40.790 --> 00:28:42.580
or do whatever else you need.

00:28:42.600 --> 00:28:46.150
So let's take a look at a
couple examples in Apple's own

00:28:46.210 --> 00:28:48.610
applications for how we do this.

00:28:48.620 --> 00:28:51.200
The first is the phone application.

00:28:51.260 --> 00:28:55.690
Now in the phone application,
we only load the visible UI that we

00:28:55.690 --> 00:28:58.930
actually need at that particular moment.

00:28:59.000 --> 00:29:03.000
So if a user launches the app and
they're on the keypad by default,

00:29:03.090 --> 00:29:07.320
we only actually end up loading all the
different image assets for the keypad.

00:29:07.350 --> 00:29:10.590
We're not, for example,
loading up all the assets for

00:29:10.590 --> 00:29:15.270
voicemail or for recents or favorites,
and we're not going through and loading

00:29:15.270 --> 00:29:17.230
up the entire contacts database.

00:29:17.260 --> 00:29:20.700
So this is an example of how you
want to structure your application.

00:29:21.260 --> 00:29:23.260
You want to make sure that
you're only bringing back

00:29:23.260 --> 00:29:25.640
what's necessary at that moment.

00:29:28.000 --> 00:29:30.150
If you take a look at
something like YouTube,

00:29:30.150 --> 00:29:34.690
for example, this is another great
example of how to be lazy.

00:29:34.770 --> 00:29:37.820
So YouTube fundamentally
is an application that is

00:29:37.820 --> 00:29:39.440
dependent on the network.

00:29:39.530 --> 00:29:42.260
You've got to be able
to bring back content,

00:29:42.260 --> 00:29:45.000
in this case the movies,
to show to the user.

00:29:45.040 --> 00:29:48.950
But it'd be a real drag if when the
user launched the application they just

00:29:48.950 --> 00:29:54.900
had to sit there and wait and wait and
wait for all this content to come in.

00:29:54.980 --> 00:29:58.760
So instead, what YouTube does is when
you launch the application,

00:29:58.860 --> 00:30:02.860
we actually give you a fully functional
UI to begin navigating around.

00:30:02.900 --> 00:30:06.960
And we simply put up this indeterminate
progress indicator and let the user know,

00:30:07.060 --> 00:30:11.020
"Hey, we're loading the data." This is
great because maybe you don't want to

00:30:11.020 --> 00:30:12.900
see what was most viewed this week.

00:30:12.900 --> 00:30:16.900
Maybe you want to see what's featured,
for example.

00:30:16.900 --> 00:30:18.900
So again, be lazy.

00:30:18.900 --> 00:30:21.090
Defer those network operations.

00:30:21.090 --> 00:30:22.900
Defer expensive loading.

00:30:22.900 --> 00:30:23.900
Save it for when the
user wants to see it.

00:30:24.900 --> 00:30:28.370
actually needs that particular data.

00:30:29.810 --> 00:30:31.700
Alright, so that's application launch.

00:30:31.860 --> 00:30:33.960
Let's go ahead and talk
about memory usage.

00:30:34.170 --> 00:30:38.700
Memory is a big topic on iPhone,
so let's hop right in.

00:30:38.700 --> 00:30:40.700
We're going to cover
a lot in this section.

00:30:40.700 --> 00:30:44.600
We're going to take a quick look at an
overview of how memory is used on iPhone.

00:30:44.690 --> 00:30:47.710
We're going to talk about static memory,
dynamic memory,

00:30:47.710 --> 00:30:50.850
your application footprint,
and also take a pretty in-depth

00:30:50.850 --> 00:30:52.340
look at memory warnings.

00:30:55.320 --> 00:30:58.840
So let's take a look at how memory
is used on iPhone in general.

00:30:58.840 --> 00:31:02.180
So just from the start, graphics.

00:31:02.180 --> 00:31:07.070
We've got 12 megabytes of memory that
get wired off for graphics usage.

00:31:08.110 --> 00:31:10.730
On top of that,
we've got 32 megabytes of memory

00:31:10.730 --> 00:31:12.440
that gets used by the kernel.

00:31:12.440 --> 00:31:13.720
It gets wired by the kernel.

00:31:13.720 --> 00:31:17.220
It needs a bunch of static
known addresses to work with.

00:31:17.370 --> 00:31:20.240
So,
another 32 megabytes right off the stack.

00:31:22.210 --> 00:31:25.860
We've got another 12 megabytes or so
that are all the different daemons

00:31:25.860 --> 00:31:26.850
that are running on the phone.

00:31:26.870 --> 00:31:29.340
So this is everything
from Media Server D,

00:31:29.340 --> 00:31:33.250
which is basically the iPod process,
to all the different things

00:31:33.250 --> 00:31:36.600
that basically make the phone a
phone and help all the different

00:31:36.600 --> 00:31:38.340
subsystems to keep running.

00:31:40.150 --> 00:31:42.090
On top of that, you've got Springboard.

00:31:42.120 --> 00:31:44.640
Springboard is the presentation
layer on the phone,

00:31:44.640 --> 00:31:47.880
and so it's always running,
whether it's showing your applications

00:31:47.880 --> 00:31:51.580
or whether it's actually taking
care of showing the different

00:31:51.580 --> 00:31:52.950
images in your application.

00:31:52.990 --> 00:31:56.290
So Springboard actually handles
all of the display on iPhone,

00:31:56.290 --> 00:31:58.380
even when your app is the front most.

00:31:59.800 --> 00:32:04.250
And now, in addition to all of that,
you've got the actual phone process.

00:32:04.290 --> 00:32:07.300
Remember that whole reason that the user
had bought the phone in the first place?

00:32:07.300 --> 00:32:10.910
Well, that's got to run in the background
because we've got to be able to make

00:32:10.920 --> 00:32:14.390
sure that we listen for incoming calls,
voicemails, texts, etc.

00:32:14.390 --> 00:32:17.310
And that's another four
megabytes on top of all of that.

00:32:17.360 --> 00:32:22.410
So really, if you look at this usage and
you've got a first generation

00:32:22.410 --> 00:32:26.770
iPhone or an iPhone 3G,
you're talking about over half of

00:32:26.770 --> 00:32:29.680
the available memory is already used.

00:32:30.700 --> 00:32:38.800
And that's a lot off the top,
but remember, this is exactly why the

00:32:38.800 --> 00:32:40.940
user bought the device,
because they want all

00:32:40.940 --> 00:32:42.190
these great features.

00:32:42.200 --> 00:32:46.010
So your application has got to deal
with basically what's left over,

00:32:46.010 --> 00:32:49.800
and you need to make sure you're
being as efficient as possible.

00:32:51.660 --> 00:32:54.200
So let's take a look at
the virtual memory system.

00:32:54.240 --> 00:32:57.980
Now it's there but
there are some caveats.

00:32:58.000 --> 00:33:01.040
There's no swap file on iPhone.

00:33:01.090 --> 00:33:04.600
So any information that's writable,
basically any of the memory that

00:33:04.600 --> 00:33:09.440
you've malloc in your application,
has to stay in memory.

00:33:09.480 --> 00:33:12.890
That means you're fundamentally
limited by the total amount

00:33:12.890 --> 00:33:15.330
of memory on the device.

00:33:15.370 --> 00:33:19.010
Now we do allow you to
evict read only pages.

00:33:19.010 --> 00:33:22.570
So if you have images or other
assets that for example you've

00:33:22.570 --> 00:33:25.450
memory mapped into your process,
we can go ahead and

00:33:25.450 --> 00:33:26.900
evict those if needed.

00:33:27.020 --> 00:33:29.810
But in general anything that's writable,
you're going to have to

00:33:29.810 --> 00:33:30.800
be very efficient with.

00:33:32.210 --> 00:33:34.840
So now, there is a virtual
memory system on iPhone.

00:33:34.840 --> 00:33:39.170
It's not like you're actually sharing
memory with other processes on the phone.

00:33:39.170 --> 00:33:42.780
But you have to do all the
management of that memory.

00:33:42.780 --> 00:33:46.340
So if you're using Objective-C,
it's your usual alloc and init,

00:33:46.340 --> 00:33:48.680
your retain, release, auto-release.

00:33:48.680 --> 00:33:51.130
There is no garbage collection for you.

00:33:51.130 --> 00:33:56.000
Now, if you're using standard C or C++,
it's everything that you would expect.

00:33:56.000 --> 00:33:59.410
It's your malloc and free,
your new and delete, etc.

00:34:01.760 --> 00:34:05.310
Now when it comes to static memory,
it's all about reducing

00:34:05.310 --> 00:34:06.920
things like code size.

00:34:06.920 --> 00:34:07.860
So what is static memory?

00:34:07.860 --> 00:34:11.930
Well, usually it's things like your
actual application binary.

00:34:11.950 --> 00:34:14.560
Remember,
we actually have to read that binary

00:34:14.560 --> 00:34:18.440
into memory to be able to execute
all the individual instructions.

00:34:18.440 --> 00:34:22.420
Now, again, this is the binary,
not the app bundle itself,

00:34:22.420 --> 00:34:24.840
so it's just the executable code.

00:34:24.840 --> 00:34:28.510
Now to reduce that code size,
you either want to build your

00:34:28.510 --> 00:34:30.660
binary for thumb or thumb 2.

00:34:30.660 --> 00:34:34.350
Now, thumb is a 16-bit instruction set.

00:34:34.350 --> 00:34:37.840
It's basically a subset of
the ARM instruction set that

00:34:38.020 --> 00:34:43.320
was present on iPhone and
iPhone 3G and the iPod Touches.

00:34:43.740 --> 00:34:49.330
Now, it's 16-bit,
and so ultimately you're saving

00:34:49.330 --> 00:34:53.610
space on each individual instruction.

00:34:53.610 --> 00:35:00.430
However, in thumb, there was no native
floating point access.

00:35:00.430 --> 00:35:01.660
And so the processor would actually
have to thunk over to a 32-bit mode in

00:35:01.660 --> 00:35:01.660
order to actually do any floating point,
which took some time.

00:35:01.660 --> 00:35:01.660
So if you were somebody
like a game developer,

00:35:01.710 --> 00:35:05.820
thumb was not something that
you generally could use.

00:35:05.960 --> 00:35:10.300
Now, on iPhone 3GS,
you've got the ability to use Thumb 2.

00:35:10.420 --> 00:35:15.470
Thumb 2 is a hybrid 16 and 32-bit
instruction set that does give

00:35:15.470 --> 00:35:17.710
you native floating point access.

00:35:17.740 --> 00:35:20.360
And this is something that
you should use all the time,

00:35:20.360 --> 00:35:23.920
whether you're a regular application
developer or a game developer.

00:35:27.500 --> 00:35:30.390
Now you also want to make sure
that you're not using compiler

00:35:30.390 --> 00:35:32.000
options that you don't need.

00:35:32.050 --> 00:35:35.490
In general,
you want to avoid C++ exceptions and

00:35:35.530 --> 00:35:37.890
avoid runtime type identification.

00:35:37.900 --> 00:35:41.940
Now if you look at how we generally
handle the exception model in

00:35:41.940 --> 00:35:45.220
Objective-C sort of as a whole,
but in our frameworks

00:35:45.340 --> 00:35:49.190
like Foundation and UIKit,
we reserve exceptions for

00:35:49.210 --> 00:35:54.970
exceptional circumstances only,
usually things like programmer error.

00:35:55.700 --> 00:35:59.000
So if you've got any code that's
built around a working model of

00:35:59.000 --> 00:36:02.570
throwing exceptions left and right
as a general mode of communication,

00:36:02.570 --> 00:36:04.710
you want to move away from that.

00:36:04.710 --> 00:36:08.480
It's going to be much less
memory efficient than you'd like.

00:36:08.560 --> 00:36:11.220
When it comes to runtime
type identification,

00:36:11.310 --> 00:36:14.550
this is usually a facility that
people use in C++ when they're

00:36:14.920 --> 00:36:19.260
loading in dynamic libraries and they
need to identify the type of a class.

00:36:19.260 --> 00:36:21.600
Well on iPhone,
you're only ever using static

00:36:21.600 --> 00:36:24.230
libraries to begin with,
so they're getting linked

00:36:24.330 --> 00:36:25.560
in as part of the compiler.

00:36:25.560 --> 00:36:26.970
But on C++, you're only ever using static
libraries to begin with,

00:36:26.970 --> 00:36:28.280
so they're getting linked
in as part of the compiler.

00:36:28.310 --> 00:36:32.820
So you should have all the information
you know to directly refer to

00:36:32.830 --> 00:36:35.020
these classes at compile time.

00:36:35.120 --> 00:36:38.590
So in general,
avoid runtime type identification

00:36:38.590 --> 00:36:40.260
if possible as well.

00:36:41.740 --> 00:36:45.150
Now when it comes to dynamic memory,
you want to make sure that you

00:36:45.150 --> 00:36:46.920
avoid auto-releasing objects.

00:36:46.920 --> 00:36:50.040
And the reason for this is that
auto-release can be expensive.

00:36:50.040 --> 00:36:53.480
And now, it's not expensive in the
way that you would expect,

00:36:53.480 --> 00:36:56.020
like it takes the call
a long time to execute.

00:36:56.030 --> 00:36:58.470
The call itself is actually quite fast.

00:36:58.800 --> 00:37:03.070
The expensive part is that when
you send auto-release to an object,

00:37:03.260 --> 00:37:06.800
what you're basically saying
is that you want this object to

00:37:06.910 --> 00:37:10.490
also be sent a release message
at some point in the future,

00:37:10.490 --> 00:37:14.180
usually once you've reached
the end of the event loop.

00:37:14.320 --> 00:37:18.440
Now, although that object is going
to get that release message,

00:37:18.440 --> 00:37:21.900
so it is going to get cleaned up,
it might not get cleaned

00:37:22.000 --> 00:37:23.360
up quickly enough.

00:37:23.440 --> 00:37:27.170
Maybe later on in some of the same code,
you're doing a lot of allocations

00:37:27.310 --> 00:37:28.780
and you run out of space.

00:37:28.780 --> 00:37:31.140
Well, if you've got a lot of
auto-released objects,

00:37:31.140 --> 00:37:33.440
there's nothing you can
do now to get rid of them.

00:37:33.520 --> 00:37:38.000
So, in general, you want to prefer direct
allocation instead of convenience

00:37:38.000 --> 00:37:39.920
methods wherever possible.

00:37:39.920 --> 00:37:44.080
So, for example, with NSString,
use alloc and init with format

00:37:44.080 --> 00:37:46.440
as opposed to string with format.

00:37:47.930 --> 00:37:51.030
And you also want to make sure
that you just allocate wisely.

00:37:51.080 --> 00:37:54.850
So it's quite a right to cache objects,
but you want to make sure that

00:37:54.900 --> 00:37:56.670
you're caching the right objects.

00:37:56.670 --> 00:37:58.910
You don't just want to go
willy-nilly and decide that,

00:37:58.910 --> 00:38:01.670
oh, hey, all these different objects
I'm definitely going to need

00:38:01.680 --> 00:38:04.060
to reference at some point,
so I'll hold on to them.

00:38:04.060 --> 00:38:07.040
That's going to be a recipe for
running into memory constraints.

00:38:07.080 --> 00:38:11.110
So you want to make sure that you
cache frequently used objects,

00:38:11.110 --> 00:38:13.790
but be prepared to
release them if you can,

00:38:13.790 --> 00:38:17.180
if needed,
usually when you get a memory warning.

00:38:17.950 --> 00:38:21.000
You also just want to make sure that you
free objects when you're done with them.

00:38:21.060 --> 00:38:24.910
If you're finished using an object and
the user has gone away from that screen,

00:38:24.910 --> 00:38:26.780
feel free to go ahead and get rid of it.

00:38:26.780 --> 00:38:30.600
And you can monitor all this information
in ObjectAlloc in Instruments.

00:38:33.800 --> 00:38:37.030
Now when it comes to properties,
in general you want to make sure that you

00:38:37.030 --> 00:38:39.440
declare your properties as non-atomic.

00:38:39.470 --> 00:38:43.000
Now properties by default are atomic.

00:38:43.000 --> 00:38:46.030
Now this means they provide a
certain degree of thread safety.

00:38:46.040 --> 00:38:50.420
Basically they're making sure that
the setting of this value as well

00:38:50.420 --> 00:38:52.840
as the getting is an atomic access.

00:38:52.940 --> 00:38:56.260
Basically if you have two different
threads that are trying to write two

00:38:56.260 --> 00:38:59.370
different values into the same property,
you're going to get one

00:38:59.370 --> 00:39:00.440
of those two values.

00:39:00.440 --> 00:39:03.500
You're not going to get some
munged combination of the two.

00:39:04.810 --> 00:39:09.710
But under the retain-release model,
this level of protection comes at a cost.

00:39:09.850 --> 00:39:14.340
And so access can be up to 10 times
faster by switching to non-atomic as

00:39:14.340 --> 00:39:16.610
the declaration on your properties.

00:39:16.640 --> 00:39:20.060
Now the one downside is that now
these properties won't necessarily

00:39:20.060 --> 00:39:23.350
be thread safe for you to use,
but if you need that thread safety,

00:39:23.430 --> 00:39:26.510
if you want that atomicity,
you simply need to remove

00:39:26.510 --> 00:39:31.180
that non-atomic keyword,
recompile, and you'll get that all back.

00:39:32.810 --> 00:39:34.940
So when it comes to
image and layer memory,

00:39:34.940 --> 00:39:37.740
it's important to remember
that the images and layers

00:39:37.740 --> 00:39:42.100
that you're working with might
be small objects by themselves,

00:39:42.190 --> 00:39:45.970
but they potentially have a very
large backing store depending on

00:39:45.970 --> 00:39:49.640
how many pixels they're actually
trying to display on the screen.

00:39:49.640 --> 00:39:52.560
And in order to display
this on the screen,

00:39:52.600 --> 00:39:54.620
it has to be uncompressed.

00:39:54.680 --> 00:39:58.710
So you've potentially got a very,
very large amount of memory dedicated

00:39:58.730 --> 00:40:00.920
towards all of this graphics work.

00:40:00.920 --> 00:40:00.920
Michael Jurewitz

00:40:01.130 --> 00:40:05.170
Now it's also important to note
that the layer backing stores,

00:40:05.170 --> 00:40:08.860
these images,
etc., that you end up actually displaying

00:40:08.860 --> 00:40:13.990
onto the screen end up being shared
memory between your app and Springboard.

00:40:15.210 --> 00:40:19.140
So anytime you go to do this drawing,
we've got this shared memory region

00:40:19.140 --> 00:40:22.660
so that Springboard can actually be
the thing that draws to the screen.

00:40:25.770 --> 00:40:30.890
Now one thing that really bears
repetition is the fact that compressed

00:40:30.890 --> 00:40:32.700
image formats are compressed.

00:40:32.700 --> 00:40:37.570
Oftentimes people think that an
image that's small on disk means

00:40:37.700 --> 00:40:42.320
that it's also small in memory,
but that's just not the case sometimes.

00:40:42.320 --> 00:40:47.360
It's all about how big the image
actually is in terms of resolution.

00:40:47.360 --> 00:40:50.790
Because remember,
it's four bits per pixel to

00:40:50.790 --> 00:40:53.020
actually draw that image.

00:40:53.020 --> 00:40:55.660
Red, green, blue, and alpha.

00:40:55.770 --> 00:41:01.440
So if you've got a 320x480 image,
you're already talking about something

00:41:01.440 --> 00:41:04.480
that's over 600 kilobytes of data.

00:41:04.730 --> 00:41:08.580
If you've got an image that's roughly
the size of a desktop background,

00:41:08.600 --> 00:41:12.580
1600 by 1200,
you're talking about over seven

00:41:12.680 --> 00:41:16.030
and a half megabytes just to
actually display that image.

00:41:16.040 --> 00:41:19.040
And now if you're talking about
an image that's come in from

00:41:19.040 --> 00:41:22.170
a high-res digital camera,
say a 10 megapixel image,

00:41:22.170 --> 00:41:24.980
well that's 40 megabytes
to display all that data.

00:41:24.980 --> 00:41:28.860
Now all of this is to say that
you need to make sure that you're

00:41:28.860 --> 00:41:33.750
properly sizing your image assets
for their use in your application.

00:41:34.440 --> 00:41:37.380
So if you've just got a small button
that you need to show on screen,

00:41:37.380 --> 00:41:40.220
for example, or some sort of badge
in your application,

00:41:40.220 --> 00:41:43.700
produce the graphic at the
resolution that you need.

00:41:43.700 --> 00:41:46.580
Don't start off with some huge
graphic and then just try to

00:41:46.580 --> 00:41:48.090
scale down for the drawing.

00:41:48.090 --> 00:41:51.260
You're going to end up wasting
a lot of memory in the process.

00:41:53.830 --> 00:41:56.730
Now speaking of images,
let's take a look at the different image

00:41:56.850 --> 00:42:00.170
API that you can use and how they behave.

00:42:00.220 --> 00:42:03.620
So first we'll take a look
at UIImagesImageNamed.

00:42:03.640 --> 00:42:09.010
Now ImageNamed caches the uncompressed
image that it loads in memory.

00:42:09.080 --> 00:42:12.000
This API is actually used
by InitWithNibName to load

00:42:12.050 --> 00:42:13.510
your different images.

00:42:13.510 --> 00:42:17.160
So if you've got large images
that you need to actually load,

00:42:17.310 --> 00:42:20.840
you should use different
initializers as part of ViewDidLoad.

00:42:20.840 --> 00:42:24.390
And I'll talk about some of those
different initializers in a moment.

00:42:24.890 --> 00:42:28.480
Now, image named is really quite useful
when you've got lots of small,

00:42:28.480 --> 00:42:30.960
frequently used images.

00:42:30.960 --> 00:42:34.770
And it's even more useful on 3.0 and
above because we're much more aggressive

00:42:34.800 --> 00:42:39.250
about clearing the cache of these images
when a memory warning is received.

00:42:39.320 --> 00:42:42.480
Now, it's important, though,
to make sure in order for

00:42:42.480 --> 00:42:45.710
this cache to be cleared,
you have to make sure that you free

00:42:45.930 --> 00:42:50.010
any references to these images that
you might have in your application.

00:42:50.790 --> 00:42:53.460
Otherwise, we're going to assume, hey,
you're using this image,

00:42:53.460 --> 00:42:54.980
you might want to display it soon.

00:42:54.980 --> 00:42:57.140
This isn't a cache
that we can get rid of.

00:42:57.240 --> 00:42:59.690
So again, though,
if you've moved away from

00:42:59.690 --> 00:43:02.960
this API back in the 2.x days,
it's time to come back.

00:43:03.060 --> 00:43:05.960
The behavior for image named is
much better in 3.0 and above.

00:43:07.700 --> 00:43:10.100
Next, there's UI image in it with data.

00:43:10.100 --> 00:43:13.970
Now here you simply pass in the
NSData that you want it to load

00:43:13.970 --> 00:43:17.800
into an image representation,
and the method just retains the

00:43:17.800 --> 00:43:19.770
actual NSData that you pass in.

00:43:19.770 --> 00:43:23.130
On a memory warning,
you should release this NSData if

00:43:23.130 --> 00:43:25.050
you can easily recreate it.

00:43:25.050 --> 00:43:27.910
The other option is for you
to use the NSData in it with

00:43:27.980 --> 00:43:29.480
contents of mapped file.

00:43:29.480 --> 00:43:32.830
This is going to let the system
be able to push that mapped file

00:43:32.830 --> 00:43:34.940
back out to the disk if possible.

00:43:37.080 --> 00:43:39.660
But using that can be
a little bit difficult,

00:43:39.660 --> 00:43:43.940
and sometimes people forget to call
initWithContents of mapped file,

00:43:43.940 --> 00:43:46.940
and instead just call
initWithContents of file,

00:43:46.940 --> 00:43:48.990
which is much less performant.

00:43:49.050 --> 00:43:51.410
So instead,
you really should probably be using

00:43:51.410 --> 00:43:53.720
something like initWithContents of file.

00:43:53.720 --> 00:43:56.760
In this case,
we only retain the path that you

00:43:56.760 --> 00:44:01.030
actually pass into this method,
and we lazily load the image.

00:44:02.500 --> 00:44:05.200
Now, on top of all that,
we will actually take a look at the path,

00:44:05.410 --> 00:44:10.220
we'll take a look at the image on disk,
and depending on how big it actually is,

00:44:10.220 --> 00:44:14.460
we'll choose to either memory map
that image into memory or not.

00:44:14.520 --> 00:44:18.430
So you really get a lot of powerful
behavior out of this single API.

00:44:18.430 --> 00:44:22.960
So really probably where you want to
spend most of your time is with this API.

00:44:25.750 --> 00:44:29.770
So again, in summary, for image named,
we cache the uncompressed

00:44:29.770 --> 00:44:30.830
image in memory.

00:44:30.840 --> 00:44:34.340
For init with data,
we cache that compressed NSData.

00:44:34.340 --> 00:44:38.330
And init with contents of file,
we don't do any caching, because again,

00:44:38.330 --> 00:44:40.870
we simply load that when needed,
and we will load that into

00:44:40.870 --> 00:44:44.220
memory in different ways,
depending on how big the actual image is.

00:44:44.220 --> 00:44:46.340
With image named,
you want to make sure that

00:44:46.340 --> 00:44:47.960
you release any references.

00:44:47.990 --> 00:44:50.470
And if you've got large images,
you really should be using

00:44:50.470 --> 00:44:53.180
something like init with data
or init with contents of file.

00:44:53.840 --> 00:44:56.360
When you get a memory warning,
make sure that you try to release

00:44:56.360 --> 00:44:59.720
the NSData that you were using if
you use the init with data method.

00:44:59.720 --> 00:45:03.780
And with init with contents of file,
simply try to release the

00:45:03.780 --> 00:45:05.780
actual image asset if you can.

00:45:08.820 --> 00:45:10.830
Alright,
let's talk about low memory warnings.

00:45:10.920 --> 00:45:15.580
Low memory warnings really are
just a fact of life on iPhone.

00:45:15.680 --> 00:45:18.200
Now you've got one
foreground application,

00:45:18.200 --> 00:45:23.170
but remember there's many processes
that are running at a given time,

00:45:23.320 --> 00:45:27.380
and each one of these
processes consumes memory.

00:45:27.590 --> 00:45:32.280
So let's take a look at a typical usage
in your application and how the system

00:45:32.340 --> 00:45:35.490
would deal with increasing memory usage.

00:45:35.820 --> 00:45:37.840
Alright,
so let's look at the typical memory

00:45:37.870 --> 00:45:40.700
consumption in an application over time.

00:45:40.700 --> 00:45:44.580
Now as total system memory grows,
you eventually reach a threshold

00:45:44.720 --> 00:45:48.680
where we send out a warning,
basically asking all the different

00:45:48.770 --> 00:45:52.690
processes on the system to
free up memory if they can.

00:45:52.700 --> 00:45:55.710
This will go to your process,
it goes to all the various

00:45:55.710 --> 00:45:59.500
background processes on the phone,
and they will take whatever steps

00:45:59.500 --> 00:46:02.700
they can to try to help alleviate
some of the memory pressure.

00:46:02.700 --> 00:46:06.950
In general though, at this point,
usually it's the foreground app or your

00:46:06.950 --> 00:46:09.700
application that's using the most memory.

00:46:09.700 --> 00:46:12.700
Now if total system
memory continues to grow,

00:46:12.700 --> 00:46:17.690
eventually we reach a threshold where
the frontmost app will get killed.

00:46:17.700 --> 00:46:22.700
And of course, the system then continues
on its merry way.

00:46:24.220 --> 00:46:26.980
Now, let's take a look at an
overview of how total memory

00:46:26.980 --> 00:46:28.700
is used on iPhone in general.

00:46:28.700 --> 00:46:33.340
Now, if we look at just sort of
the broader categories here,

00:46:33.340 --> 00:46:37.540
we can see that it mostly just breaks
down to memory that is either free,

00:46:37.540 --> 00:46:40.380
reclaimable, or already allocated.

00:46:40.380 --> 00:46:43.020
Basically,
free and reclaimable are what the

00:46:43.020 --> 00:46:46.760
system care about because as that
amount of memory gets smaller and

00:46:46.820 --> 00:46:51.240
smaller is when we're going to start
sending out those memory warnings.

00:46:51.480 --> 00:46:54.300
And eventually,
we reach that threshold where

00:46:54.300 --> 00:46:58.970
the system basically is operating
defensively to quit that frontmost

00:46:58.970 --> 00:47:03.350
app in order to keep the rest of
the device stable so that a user can

00:47:03.450 --> 00:47:07.100
continue to use their phone as a phone.

00:47:07.450 --> 00:47:10.410
And again,
since 3.0 and above were much better

00:47:10.410 --> 00:47:14.780
about quitting background processes
when a memory warning is received.

00:47:14.780 --> 00:47:19.060
So things like Safari and Mail will
get cleaned up in the background.

00:47:19.060 --> 00:47:22.910
Now you might have some situations
where you get a low memory crash

00:47:22.910 --> 00:47:26.480
report and you see that these
processes were still alive.

00:47:26.480 --> 00:47:30.520
So usually this is the case
when you've tried to allocate

00:47:30.700 --> 00:47:32.940
too much memory too quickly.

00:47:33.480 --> 00:47:37.400
In that case, the system just has to be
defensive and it simply has to say,

00:47:37.400 --> 00:47:38.880
whoa, you've asked for way too much.

00:47:38.880 --> 00:47:42.030
I'm just going to quit this process
here as opposed to trying to

00:47:42.030 --> 00:47:45.700
service this request and putting
the rest of the device in jeopardy.

00:47:48.030 --> 00:47:51.780
So when it comes to low memory warnings,
don't ignore the signs.

00:47:51.780 --> 00:47:54.960
And it's important to remember,
any app can create these

00:47:54.960 --> 00:47:56.660
low memory conditions.

00:47:56.660 --> 00:47:59.500
It might not necessarily just be you.

00:47:59.500 --> 00:48:01.710
So for example,
mail might be going out and

00:48:01.710 --> 00:48:04.420
fetching a bunch of emails,
but that's precisely the

00:48:04.700 --> 00:48:07.380
behavior that the user specified,
that they wanted.

00:48:07.380 --> 00:48:11.380
They wanted mail in the background
to go and retrieve these messages.

00:48:11.380 --> 00:48:13.740
So you need to be a good citizen.

00:48:13.740 --> 00:48:17.880
You need to basically help the
system be as efficient as possible.

00:48:18.940 --> 00:48:20.090
So expect memory warnings.

00:48:20.100 --> 00:48:23.110
They really are just a
normal mode of operation.

00:48:23.130 --> 00:48:25.450
And make sure you respond to them.

00:48:25.450 --> 00:48:30.070
A failure to respond will probably
lead to your app being terminated.

00:48:30.070 --> 00:48:31.880
Don't just ignore them.

00:48:33.850 --> 00:48:34.840
So what should you do?

00:48:35.000 --> 00:48:39.040
Well, you should release any object
that you can reconstruct.

00:48:39.040 --> 00:48:41.280
You should release cached objects.

00:48:41.310 --> 00:48:47.360
You should unload cached resource files,
sounds, data, images, etc.

00:48:47.680 --> 00:48:52.930
And above anything else,
don't ask the user to do anything.

00:48:53.020 --> 00:48:55.420
There's nothing they can do.

00:48:55.420 --> 00:48:59.160
It's not like they're going to be able to
use your application more conservatively.

00:48:59.160 --> 00:49:03.500
Your memory usage is your memory usage,
and you as a developer simply need

00:49:03.500 --> 00:49:07.350
to be as efficient as possible
and to respond to these warnings.

00:49:09.610 --> 00:49:12.470
Now luckily,
there's lots of different opportunities

00:49:12.470 --> 00:49:14.300
for you to respond to these things.

00:49:14.300 --> 00:49:18.050
You've got your app delegate,
view controller subclasses,

00:49:18.060 --> 00:49:19.470
and direct notifications.

00:49:19.490 --> 00:49:23.310
So let's take a look at the
app delegate at application

00:49:23.310 --> 00:49:25.620
did receive memory warning.

00:49:25.920 --> 00:49:29.690
So let's say on your app delegate you
have some object that you vend back.

00:49:29.760 --> 00:49:32.320
In this case,
we've got some breadcrumb store,

00:49:32.320 --> 00:49:36.010
some shared singleton that we're
handing back to people who need to

00:49:36.010 --> 00:49:38.120
get access to these breadcrumbs.

00:49:38.120 --> 00:49:41.740
So in this case,
we've defined our accessor entries

00:49:41.740 --> 00:49:46.560
to basically check to see if our
instance variable is already set.

00:49:46.620 --> 00:49:50.660
If it's not, we go ahead and we take care
of loading that shared store,

00:49:50.730 --> 00:49:54.100
setting the instance variable,
and then returning.

00:49:54.100 --> 00:49:57.680
And now subsequent requests for
this particular accessor will

00:49:57.680 --> 00:49:59.940
just return the instance variable.

00:50:01.570 --> 00:50:04.160
Now if we receive a low
memory warning though,

00:50:04.270 --> 00:50:09.950
we'll go ahead and take care of releasing
that particular instance variable and

00:50:09.950 --> 00:50:11.850
making sure that we set it to nil.

00:50:11.850 --> 00:50:15.020
Setting it to nil is particularly key.

00:50:15.020 --> 00:50:18.410
You want to make sure that you
nil out that instance variable

00:50:18.410 --> 00:50:21.890
so that if anybody else tries
to talk to that piece of memory,

00:50:21.890 --> 00:50:24.650
they don't end up
talking to a dead object.

00:50:24.650 --> 00:50:27.280
You want to make sure that
they are just messaging nil,

00:50:27.280 --> 00:50:28.680
which in this case is safe.

00:50:28.680 --> 00:50:33.790
So now you've cleaned up the memory,
next time somebody asks for the object,

00:50:33.790 --> 00:50:35.900
you'll reconstruct it just fine.

00:50:35.970 --> 00:50:39.500
So you've gone from having the
object to nicely cleaning it up

00:50:39.500 --> 00:50:41.800
when a memory warning comes in.

00:50:42.200 --> 00:53:27.800
[Transcript missing]

00:53:28.000 --> 00:53:32.120
So, we might have an accessor that looks
something like this when we want to

00:53:32.150 --> 00:53:36.410
actually design correctly to release
these resources on a memory warning.

00:53:36.410 --> 00:53:39.780
In this case, we've got this shared
instance that we're returning,

00:53:39.780 --> 00:53:41.980
and again,
all we're doing is checking to see

00:53:41.980 --> 00:53:44.130
if we have the instance variable set.

00:53:44.300 --> 00:53:47.220
If we don't,
we alloc and init the object.

00:53:47.310 --> 00:53:51.730
We then go ahead and add ourselves
as an observer for the notification

00:53:51.730 --> 00:53:56.000
for UI application did receive
memory warning notification.

00:53:57.900 --> 00:54:02.000
And then finally, we return our instance
variable to whoever called us.

00:54:02.000 --> 00:54:07.000
Now, you'll notice the selector we passed
in was this received memory warning.

00:54:07.000 --> 00:54:10.210
And so, if this notification
happens to get posted,

00:54:10.210 --> 00:54:13.000
then in our class,
we simply need to implement

00:54:13.000 --> 00:54:15.150
that received memory warning.

00:54:15.150 --> 00:54:17.230
That method will get
called and we'll know,

00:54:17.230 --> 00:54:19.330
hey, it's time for us to clean up memory.

00:54:19.330 --> 00:54:22.260
So, we will go ahead and release
that instance variable,

00:54:22.290 --> 00:54:26.100
set it to nil, and then make sure that we
remove ourselves as an observer.

00:54:26.950 --> 00:54:28.960
So,
we've got this shared instance variable

00:54:29.070 --> 00:54:33.020
that we've got to remove ourselves as an
observer from the notification center.

00:54:33.020 --> 00:54:35.690
So, again,
you must respond to low memory warnings.

00:54:35.690 --> 00:54:37.830
They really are just a
fact of life on iPhone,

00:54:37.840 --> 00:54:41.240
and you need to do your part to help
the system be as stable as possible.

00:54:41.240 --> 00:54:43.280
And also,
failure to respond to them might

00:54:43.280 --> 00:54:45.040
lead to your app being terminated.

00:54:45.040 --> 00:54:48.990
So, another good reason to make sure that
you actually try to relinquish memory.

00:54:49.030 --> 00:54:51.350
And again,
remember that other apps may actually

00:54:51.440 --> 00:54:55.200
cause these low memory conditions,
but this is what the user wants.

00:54:55.200 --> 00:54:57.200
They've asked for these other behaviors
to be happening on the device.

00:55:01.640 --> 00:55:04.500
Next,
let's talk about auto-release pools.

00:55:04.610 --> 00:55:08.220
Now, every time an event comes
into your application,

00:55:08.220 --> 00:55:11.170
we take care of creating an
auto-release pool for you.

00:55:11.210 --> 00:55:15.450
And this brackets any of the different
allocations that you do in that code so

00:55:15.570 --> 00:55:20.430
that things get properly released once
you finish processing that current event.

00:55:21.580 --> 00:55:25.010
However, as you continue to write code,
and you might have an algorithm

00:55:25.010 --> 00:55:28.590
that looks something like this,
where maybe you're loading in a bunch

00:55:28.670 --> 00:55:32.980
of text and iterating through stuff and
creating a bunch of temporary objects,

00:55:32.980 --> 00:55:37.420
you might end up in a situation where
you slowly start strangling yourself

00:55:37.420 --> 00:55:41.510
on all these temporary objects that
are sticking around and not going

00:55:41.620 --> 00:55:46.290
to go away until you've finished
processing that entire current event.

00:55:46.300 --> 00:55:50.200
Now,
in order to avoid this kind of situation,

00:55:50.200 --> 00:55:51.210
you want to take a look at the following.

00:55:51.330 --> 00:55:55.140
Take code like this and nest them
in their own auto-release pool.

00:55:55.140 --> 00:55:58.020
It turns out this is really easy to do.

00:55:58.020 --> 00:56:02.310
It's just NS auto-release pool,
alloc init, and then at some point

00:56:02.310 --> 00:56:05.100
later in your code,
you want to bracket that

00:56:05.120 --> 00:56:06.760
with the pool drain.

00:56:06.760 --> 00:56:11.190
Drain has the side effect of releasing
the pool as well as causing release

00:56:11.190 --> 00:56:14.900
to be sent to all the different
objects that happen to have been

00:56:15.250 --> 00:56:17.960
auto-released between those two methods.

00:56:17.960 --> 00:56:22.410
And now you'll go from creating a
bunch of objects... ...and then we hit

00:56:22.570 --> 00:56:25.500
the for loop and we create some more,
to we come right back

00:56:25.500 --> 00:56:28.490
around the while loop,
and they get cleaned up,

00:56:28.630 --> 00:56:30.410
which is exactly what you want.

00:56:30.440 --> 00:56:33.100
And of course, then,
next time you go through,

00:56:33.100 --> 00:56:37.070
you're creating some more objects,
but again, they get cleaned up.

00:56:37.410 --> 00:56:38.830
Exactly what you want.

00:56:40.800 --> 00:56:43.270
So in summary, for memory,
you want to make sure you use

00:56:43.270 --> 00:56:44.850
the right compiler settings.

00:56:44.850 --> 00:56:48.220
You want to minimize your object
lifetimes as best as you can.

00:56:48.220 --> 00:56:51.140
Absolutely eliminate memory leaks.

00:56:51.140 --> 00:56:53.270
Those will just kill you in the end.

00:56:53.270 --> 00:56:56.560
And make sure that you respond
to low memory notifications.

00:56:56.560 --> 00:56:59.250
All right, so we're moving along.

00:56:59.250 --> 00:57:02.010
Let's take a look at files and data.

00:57:04.600 --> 00:57:06.860
So now when it comes to
actually reading data,

00:57:06.860 --> 00:57:10.520
you want to make sure that you use
memory mapping for large files.

00:57:10.540 --> 00:57:15.000
This avoids loading the entire
file into memory at once.

00:57:15.000 --> 00:57:17.860
You can do this in a
number of different ways.

00:57:17.960 --> 00:57:22.090
You can use MMAP and of course
MUNMAP once you're done with a file,

00:57:22.090 --> 00:57:26.020
or you can use NSDATA's
In It With Contents of Mapped File.

00:57:45.160 --> 00:57:45.200
Now this is very, very important.

00:57:45.200 --> 00:57:45.200
In It With Contents of
Mapped File is cheap.

00:57:45.200 --> 00:57:45.200
That's what does the memory mapping.

00:57:45.200 --> 00:57:45.200
In It With Contents of File is expensive.

00:57:45.200 --> 00:57:45.200
That's what's going to load the entire
thing into memory as is at that moment.

00:57:45.200 --> 00:57:45.200
So make sure you use the right one.

00:57:46.010 --> 00:57:48.210
Now,
if you've got large data sets or really

00:57:48.210 --> 00:57:51.900
just about data sets of any size,
you really should be using core data.

00:57:51.900 --> 00:57:55.580
You avoid having to load the
entire data set into memory.

00:57:55.580 --> 00:57:58.570
You get the ability to only
load windows of data through

00:57:58.570 --> 00:58:00.400
a mechanism called batching.

00:58:00.400 --> 00:58:04.960
And it's really easy to create model
objects and add your own custom behavior.

00:58:08.240 --> 00:58:11.340
When it comes to download performance,
you want to make sure that you

00:58:11.450 --> 00:58:13.320
don't include unnecessary files.

00:58:13.320 --> 00:58:16.170
And this might seem kind of silly,
but we've seen this

00:58:16.300 --> 00:58:17.590
more than a few times.

00:58:17.590 --> 00:58:20.230
In this case,
we've actually seen people who have

00:58:20.230 --> 00:58:24.240
included their subversion directories
in their actual applications that

00:58:24.240 --> 00:58:26.280
they submitted to the App Store.

00:58:26.280 --> 00:58:27.170
So avoid this.

00:58:27.540 --> 00:58:30.620
This will most certainly push
you over the limit for being

00:58:30.620 --> 00:58:32.520
able to download over Wi-Fi.

00:58:32.520 --> 00:58:37.900
Make sure that you're doing a SVN export
as opposed to an SVN checkout.

00:58:38.230 --> 00:58:41.340
before you actually submit
something to the App Store.

00:58:42.740 --> 00:58:46.240
When it comes to backup performance,
you need to make sure that you're storing

00:58:46.390 --> 00:58:48.690
your data in the appropriate places.

00:58:48.730 --> 00:58:52.450
So if you have user data,
things that you want to be backed up,

00:58:52.450 --> 00:58:56.040
things that your application
is going to need to continue to

00:58:56.040 --> 00:59:00.130
get at because it contains vital
information about what is actually

00:59:00.130 --> 00:59:04.730
in your application for that user,
put it in the documents directory.

00:59:04.730 --> 00:59:07.860
We'll go ahead and take care of
backing that up any time the user

00:59:07.860 --> 00:59:09.590
syncs their phone with iTunes.

00:59:10.680 --> 00:59:13.650
However,
if you have temporary files or caches,

00:59:13.710 --> 00:59:16.540
well,
make sure the caches go into library

00:59:16.540 --> 00:59:21.360
caches and make sure the temporary
files go into the temp directory.

00:59:21.360 --> 00:59:25.680
We'll take care of cleaning those up
on regular bases and we won't sync

00:59:25.680 --> 00:59:28.200
those over as part of the iTunes sync.

00:59:28.220 --> 00:59:31.290
This is key because this way
you're shaving down the amount

00:59:31.290 --> 00:59:34.540
of time a user is going to have
to spend syncing their phone.

00:59:37.810 --> 00:59:40.140
I said this earlier,
but you also want to make sure that

00:59:40.220 --> 00:59:42.830
you take advantage of using ping files.

00:59:42.850 --> 00:59:45.220
Pings are optimized for you.

00:59:45.220 --> 00:59:47.150
But in addition to that,
there are some other files

00:59:47.150 --> 00:59:50.900
that we also optimize,
specifically, P lists.

00:59:50.900 --> 00:59:55.490
We take property lists and convert
them to a compact binary format

00:59:55.490 --> 00:59:58.200
during compilation with Xcode.

00:59:58.460 --> 01:00:01.740
Now, you can use these property lists
for storing structured data,

01:00:01.830 --> 01:00:04.300
things that you would
normally put into XML.

01:00:04.300 --> 01:00:07.540
And when they get converted
to this compact binary format,

01:00:07.600 --> 01:00:11.230
it's actually much more efficient
for the frameworks to be able to

01:00:11.330 --> 01:00:13.080
load this data in the first place.

01:00:13.080 --> 01:00:16.250
They can merely load this off
disk and they don't have to do

01:00:16.320 --> 01:00:18.070
any complicated text parsing.

01:00:18.270 --> 01:00:22.190
They just get the objects in
memory ready for you to work with.

01:00:24.710 --> 01:00:28.770
Now this goes beyond just data that
you're storing in your application.

01:00:28.830 --> 01:00:31.000
If you've got a server
that you're talking to,

01:00:31.130 --> 01:00:35.510
it might make sense for you to have
your server send down binary P lists

01:00:35.590 --> 01:00:39.920
as opposed to sending down big XML,
which is expensive to parse.

01:00:39.920 --> 01:00:44.130
If you can send down a binary P list,
it's potentially less bandwidth

01:00:44.130 --> 01:00:48.250
and it's also less processing work
that you have to do on iPhone.

01:00:50.530 --> 01:00:52.230
All right, so that's files and data.

01:00:52.230 --> 01:00:56.480
Let's go ahead and hop into
power and battery life.

01:00:57.290 --> 01:00:58.860
So we're going to cover
a few topics here.

01:00:58.860 --> 01:01:01.440
We're going to talk about the
different radios on iPhone.

01:01:01.450 --> 01:01:05.910
We're going to talk about core location
and also take a look at the CPU and

01:01:05.910 --> 01:01:08.910
the GPU for some general best practice.

01:01:09.020 --> 01:01:11.640
Now when it comes to the radios,
I'm not talking about listening to music,

01:01:11.640 --> 01:01:14.120
I'm talking about the
actual cellular radios.

01:01:14.120 --> 01:01:16.780
Now in this case,
let's start off with 3G.

01:01:16.780 --> 01:01:20.410
Sending data on 3G is very expensive.

01:01:20.410 --> 01:01:24.220
In fact, it's one of the most expensive
things that you can do on iPhone.

01:01:24.220 --> 01:01:27.900
Now the way that 3G is
actually designed and specced,

01:01:28.020 --> 01:01:32.510
the 3G networks actually require
the phone to stay in a high power

01:01:32.510 --> 01:01:37.240
state for a few seconds after that
last packet is sent or received.

01:01:37.310 --> 01:01:41.120
So you might be transmitting some
data and assuming that you're only

01:01:41.120 --> 01:01:44.540
spending a small amount of time
actually doing that transmission,

01:01:44.550 --> 01:01:49.340
but actually the radio has had to
stay up for a lot longer in order to

01:01:49.340 --> 01:01:51.680
actually complete that transmission.

01:01:51.680 --> 01:01:54.580
And again, this is just part of
the way that 3G works.

01:01:54.580 --> 01:01:58.840
Now this can be particularly
bad if you're just sending small

01:01:58.910 --> 01:02:03.770
little packets of data regularly,
because you might end up keeping

01:02:03.770 --> 01:02:08.390
the 3G radio in a high power
state for a long period of time.

01:02:38.940 --> 01:02:38.940
So you want to try to make sure that you
optimize your transmissions around 3G.

01:02:38.940 --> 01:02:38.940
You want to make sure that you're
coalescing the data that you

01:02:38.940 --> 01:02:38.940
want to send into larger chunks,
rather than just a thin stream

01:02:38.940 --> 01:02:38.940
of a few packets at a time.

01:02:38.940 --> 01:02:38.940
You also want to make sure that
you minimize the amount of data

01:02:38.940 --> 01:02:38.940
that you actually transmit,
so using compact formats, for example.

01:02:38.940 --> 01:02:38.940
What I like to recommend is that
you adopt an algorithm to help

01:02:38.940 --> 01:02:38.940
you coalesce these transmissions.

01:02:38.940 --> 01:02:38.940
Now to do that,
you probably want to develop some

01:02:38.940 --> 01:02:42.360
sort of system where basically
you input some data that needs

01:02:42.360 --> 01:02:45.640
to be sent out to the network,
and maybe you keep track of

01:02:45.650 --> 01:02:48.620
the time that you enqueued it,
for example.

01:02:48.750 --> 01:02:53.140
And then you either wait until you reach
a sufficient amount of data to send,

01:02:53.170 --> 01:02:56.510
or until a sufficiently large
period of time has passed that,

01:02:56.660 --> 01:02:58.290
you know,
it's just time to go ahead and take

01:02:58.410 --> 01:03:02.440
care of sending whatever is here,
something that might be a few seconds,

01:03:02.440 --> 01:03:04.960
five to ten seconds, for example.

01:03:05.180 --> 01:03:09.100
Now when it comes to using Wi-Fi,
Wi-Fi does use less power than 3G,

01:03:09.180 --> 01:03:11.600
but it still uses a fair bit.

01:03:11.660 --> 01:03:14.340
Now the good part is that
the Wi-Fi radios can go quiet

01:03:14.480 --> 01:03:16.560
immediately after transmission.

01:03:16.560 --> 01:03:19.390
You can detect whether
you're on Wi-Fi versus cell,

01:03:19.390 --> 01:03:21.830
and in this case,
this is when you're going to

01:03:21.850 --> 01:03:25.500
want to perhaps adapt how much
data coalescing you actually do.

01:03:25.500 --> 01:03:28.690
You can get at this through the
system configuration framework,

01:03:28.690 --> 01:03:31.820
and then use that to sort of
adapt your different behavior.

01:03:34.610 --> 01:03:39.760
Now, 2G has power consumption that is
somewhere between 3G and Wi-Fi,

01:03:39.760 --> 01:03:43.680
but 2G obviously takes
longer to send data.

01:03:43.680 --> 01:03:48.580
Now, the benefit with 2G is that the 2G
radio can actually go quiet immediately

01:03:48.580 --> 01:03:51.380
once it's done transmitting data,
but again,

01:03:51.380 --> 01:03:55.670
the actual transmission took longer,
so it's a bit of a wash in the end.

01:03:55.670 --> 01:03:59.510
Ultimately, you'll still want to make
sure that you're coalescing

01:03:59.510 --> 01:04:01.460
activity when you're on 2G.

01:04:03.850 --> 01:04:07.200
Alright, let's talk about core location.

01:04:09.870 --> 01:04:13.150
So lots of apps use Core Location,
and with good reason.

01:04:13.240 --> 01:04:15.860
It's a fantastic technology.

01:04:15.860 --> 01:04:19.620
You get the ability to help change
how your application works for your

01:04:19.620 --> 01:04:23.780
user based on where they are in
the world and provide really rich,

01:04:23.790 --> 01:04:26.610
context-sensitive information to them.

01:04:26.800 --> 01:04:31.660
Now Core Location lets you know where a
user is to varying degrees of accuracy.

01:04:31.660 --> 01:04:34.630
And it's these different
degrees of accuracy that have

01:04:34.850 --> 01:04:37.240
different power considerations.

01:04:37.240 --> 01:04:41.120
So you want to make sure you use the
least amount of accuracy necessary

01:04:41.120 --> 01:04:44.090
for what you're trying to accomplish.

01:04:44.160 --> 01:04:50.010
Now the default for Core Location is
to use this CL location accuracy best,

01:04:50.100 --> 01:04:50.660
i.e.

01:04:50.960 --> 01:04:52.030
the most expensive.

01:04:52.030 --> 01:04:56.480
So chances are you want to go ahead and
move down to something a little less

01:04:56.480 --> 01:04:59.010
precise depending on your application.

01:04:59.010 --> 01:05:01.650
If, for example,
you just care that somebody is

01:05:01.690 --> 01:05:05.200
in the city of San Francisco,
you don't want to ask what street

01:05:05.270 --> 01:05:08.780
corner in San Francisco they
happen to be standing on.

01:05:08.780 --> 01:05:13.860
So use something like CL location
accuracy kilometer or perhaps 100 meters.

01:05:16.020 --> 01:05:19.340
You also want to make sure that you
properly set the distance filter.

01:05:19.340 --> 01:05:21.530
Now,
the distance filter is going to dictate

01:05:21.700 --> 01:05:26.660
how often CoreLocation tries to go back
and reassess a user's location based on

01:05:26.740 --> 01:05:29.340
how far we think they've actually moved.

01:05:29.420 --> 01:05:30.800
So you want to set this appropriately.

01:05:30.800 --> 01:05:35.500
For example, if all you care about are
particularly large chunks of movement,

01:05:35.620 --> 01:05:38.590
then don't set the distance
filter to something like 1,

01:05:38.590 --> 01:05:40.940
which would be one meter, for example.

01:05:41.050 --> 01:05:44.530
Now, the default here is the
distance filter set to none,

01:05:44.540 --> 01:05:46.940
which receives all movement updates.

01:05:46.940 --> 01:05:49.660
So make sure you set this to
something that's reasonable.

01:05:49.770 --> 01:05:54.840
Having all the movement updates come in
takes a lot of CPU time and also just

01:05:54.840 --> 01:05:57.240
takes a lot of power from the device.

01:05:57.650 --> 01:06:01.150
Now most importantly,
if all you need is a single fix

01:06:01.150 --> 01:06:05.650
on where a user happens to be,
get that location fix and then

01:06:05.650 --> 01:06:08.190
call Stop Updating Location.

01:06:08.190 --> 01:06:13.030
CoreLocation manages all the
interaction with the GPS power for you,

01:06:13.030 --> 01:06:18.090
and so by calling Stop Updating Location,
CoreLocation now knows that you're

01:06:18.110 --> 01:06:20.380
done and can stop using the GPS.

01:06:23.910 --> 01:06:27.940
Alright,
let's talk about the CPU and the GPU.

01:06:27.960 --> 01:06:31.660
So it's important to remember
that every single increase in

01:06:31.690 --> 01:06:36.030
performance in your application,
everything that you can make faster,

01:06:36.300 --> 01:06:39.020
results in less time on the CPU.

01:06:39.020 --> 01:06:43.910
And less time on the CPU means
more time the CPU can go to sleep,

01:06:43.910 --> 01:06:47.760
which means less power
consumption overall.

01:06:47.760 --> 01:06:52.240
So you need to go in and try to
eke out every single performance

01:06:52.240 --> 01:06:53.760
improvement you can in your app.

01:06:53.830 --> 01:06:57.360
Every percentage that you shave
off translates directly into

01:06:57.470 --> 01:06:59.660
better battery life for your user.

01:07:02.670 --> 01:07:04.740
Now when it comes to
polling versus events,

01:07:04.830 --> 01:07:08.010
really polling is something you
should avoid if at all possible.

01:07:08.010 --> 01:07:11.160
iPhone OS is highly event based.

01:07:11.160 --> 01:07:14.360
We've got events for almost everything
that you'd want to listen to.

01:07:14.360 --> 01:07:17.260
So try to avoid polling
if at all possible.

01:07:17.260 --> 01:07:20.880
You want to subscribe to events
that actually have a notification

01:07:20.880 --> 01:07:24.660
and we'll make sure we deliver the
appropriate information to you.

01:07:24.790 --> 01:07:27.660
But if you must poll,
make sure you use a timer

01:07:27.660 --> 01:07:29.070
with a low frequency.

01:07:29.070 --> 01:07:32.070
So something on the order
of a few seconds or more,

01:07:32.400 --> 01:07:32.580
not so much.

01:07:32.630 --> 01:07:37.470
something that's 30 times a second,
60 times a second, etc.

01:07:37.770 --> 01:07:41.740
A great example of this in iPhone
OS 3.0 is the new Shake API.

01:07:41.740 --> 01:07:45.380
So instead of having to monitor
the accelerometer directly,

01:07:45.380 --> 01:07:48.750
you now can get specific
notifications for certain types

01:07:48.750 --> 01:07:50.500
of motion from the device.

01:07:53.100 --> 01:07:56.570
You also want to try to make sure
that you are being as bursty as

01:07:56.570 --> 01:07:58.870
possible with your actual execution.

01:07:58.930 --> 01:08:02.880
Now, this is similar to how you would
work with the network traffic

01:08:02.880 --> 01:08:04.700
that I talked about earlier.

01:08:04.700 --> 01:08:09.200
You want to try to consolidate that
CPU usage into these different bursts.

01:08:09.200 --> 01:08:11.720
This allows the CPU to
enter an idle state,

01:08:11.720 --> 01:08:16.190
and it may require some restructuring
of your code or a different algorithm,

01:08:16.500 --> 01:08:19.010
but it can have very positive impact.

01:08:19.020 --> 01:08:21.550
For example,
when we actually play back audio

01:08:21.560 --> 01:08:22.980
through something like this,
we can see that the CPU is being bursted.

01:08:23.000 --> 01:08:28.010
For example,
when we actually play back audio

01:08:28.080 --> 01:08:36.130
through something like this,
we can see that the CPU is being bursted.

01:08:36.130 --> 01:08:36.130
For example,
when we actually play back audio

01:08:36.130 --> 01:08:36.130
through something like this,
we can see that the CPU is being bursted.

01:08:37.180 --> 01:08:40.110
Now when it comes to the GPU,
you want to make sure that

01:08:40.120 --> 01:08:43.330
when you're using OpenGL that
you pick a fixed frame rate,

01:08:43.380 --> 01:08:45.280
usually something like 30 fips.

01:08:45.280 --> 01:08:48.790
And if a frame hasn't changed,
don't redraw it.

01:08:48.880 --> 01:08:52.490
So if you've got like a chess game,
for example, where the user's going to be

01:08:52.490 --> 01:08:55.790
spending most of their time looking
at the pieces and trying to figure

01:08:55.790 --> 01:08:59.220
out where they want to move,
if you don't have to redraw, don't.

01:09:01.790 --> 01:09:03.780
Alright,
so we looked at a bunch of different

01:09:03.780 --> 01:09:06.740
information about the radios
and how to coalesce your data,

01:09:07.080 --> 01:09:09.570
core location and only using
the accuracy that you need and

01:09:09.570 --> 01:09:13.480
making sure that you unsubscribe,
and for the CPU and the GPU,

01:09:13.480 --> 01:09:17.590
optimizing as much performance
as you can and being bursty.

01:09:17.620 --> 01:09:19.940
So we've looked at a lot of topics today.

01:09:19.940 --> 01:09:23.950
We talked about drawing and scrolling
to help your application perform

01:09:24.030 --> 01:09:26.150
even faster in those table views.

01:09:26.760 --> 01:09:30.430
We took a look at application
launch and how you can be lazy.

01:09:30.440 --> 01:09:34.230
We took a really in-depth look at memory
usage and talked a lot about memory

01:09:34.230 --> 01:09:38.470
warnings and how you can help relinquish
memory and help the system out.

01:09:38.540 --> 01:09:41.760
We took a look at files and data
and being as fast as possible

01:09:41.840 --> 01:09:43.740
with how you work with your data.

01:09:43.740 --> 01:09:46.040
And finally,
we looked at power and battery

01:09:46.040 --> 01:09:49.440
life and the different subsystems
and how you work with them.

01:09:49.910 --> 01:09:52.100
Again,
you can always reach me if you have

01:09:52.150 --> 01:09:56.880
any questions at jurewitz@apple.com
or feel free to consult the iPhone dev

01:09:57.060 --> 01:10:01.190
portal at developer.apple.com/iphone.
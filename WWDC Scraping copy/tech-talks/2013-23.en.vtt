WEBVTT

00:00:13.030 --> 00:00:15.830
Welcome to architecting modern iOS games.

00:00:15.980 --> 00:00:20.760
My name is Dave DeLoong and I'm one
of the app frameworks evangelists.

00:00:21.230 --> 00:00:24.050
In the previous session,
we heard a lot about the A7

00:00:24.090 --> 00:00:25.740
GPU and its capabilities.

00:00:25.740 --> 00:00:28.730
In this session,
we're going to be looking at the

00:00:28.730 --> 00:00:33.390
CPU portion of that chip and looking
at what this transition to a 64‑bit

00:00:33.530 --> 00:00:36.200
processor means for you and your games.

00:00:36.500 --> 00:00:40.640
We're also going to be taking
a look at the iOS 7 SDK,

00:00:40.640 --> 00:00:45.340
not at any single feature in particular,
but in general,

00:00:45.340 --> 00:00:51.290
how you can adopt new features available
in iOS 7 while still maintaining

00:00:51.350 --> 00:00:54.360
backwards compatibility with iOS 6.

00:00:54.360 --> 00:01:00.390
But first, let's start with building
your games for the A7.

00:01:01.920 --> 00:01:05.760
When we announced the A7 chip,
one of the things that people were

00:01:05.760 --> 00:01:10.050
most surprised to learn about this
chip is that it's the world's first

00:01:10.050 --> 00:01:13.300
64‑bit processor in a mobile device.

00:01:13.400 --> 00:01:16.700
And when we made this announcement,
there was a lot of confusion

00:01:16.700 --> 00:01:22.020
about why we would make a 64‑bit
chip in a device like an iPhone.

00:01:22.300 --> 00:02:48.800
[ Transcript missing ]

00:02:49.350 --> 00:02:53.110
All of these together mean
that recompiling your games

00:02:53.240 --> 00:02:57.300
for 64‑bit can give you a
faster experience in your game.

00:02:57.300 --> 00:03:01.670
You will get better performance
by recompiling for 64‑bit.

00:03:01.890 --> 00:03:06.400
I also want to point out that the
standard that we used for 64‑bit

00:03:06.400 --> 00:03:12.300
on iOS is the same standard,
the LP64 standard that we use on the Mac.

00:03:12.300 --> 00:03:16.640
And so by having this common
standard between iOS and Mac,

00:03:16.700 --> 00:03:22.720
it makes it much easier to port
your games from iOS to Mac as well.

00:03:22.720 --> 00:03:27.050
Having this shared standard means
that we have a solid foundation

00:03:27.390 --> 00:03:32.490
on which we can build modern games
that will last for many years.

00:03:32.500 --> 00:03:36.360
So that's just a brief overview
of some of the 64‑bit benefits.

00:03:36.410 --> 00:03:41.450
Let's see how 64‑bit actually
affects your applications bundle.

00:03:42.530 --> 00:03:48.290
When we open up an iOS app or a game
and take a look inside the bundle,

00:03:48.720 --> 00:03:52.180
one of the very first things that we'll
find is the application executable.

00:03:52.180 --> 00:03:56.000
This is the file where all
of your code is compiled.

00:03:56.000 --> 00:03:58.850
This is what gets launched.

00:03:58.850 --> 00:04:03.240
But in addition to the executable file,
there are many other files.

00:04:03.320 --> 00:04:06.100
Perhaps you might have some
interface builder files

00:04:06.190 --> 00:04:07.860
such as NIMS or storyboards.

00:04:07.860 --> 00:04:11.920
You'll probably have a bunch
of configuration files,

00:04:11.960 --> 00:04:15.030
whether they're P lists or
JSON files or something else.

00:04:15.030 --> 00:04:19.620
And of course,
you will have lots of image assets.

00:04:19.670 --> 00:04:23.900
This is how all of our apps
look today on a 32‑bit device.

00:04:23.900 --> 00:04:25.770
So how does this change for 64‑bit?

00:04:25.770 --> 00:04:28.330
It's very simple.

00:04:28.370 --> 00:04:30.010
Just like this.

00:04:31.460 --> 00:04:32.940
Nothing changes whatsoever.

00:04:32.940 --> 00:04:36.820
That was a trick question to see
if you were paying attention.

00:04:36.820 --> 00:04:39.740
From this perspective,
nothing is different.

00:04:40.120 --> 00:04:44.390
To adopt 64‑bit, you do not need to alter
any of your image resources,

00:04:44.400 --> 00:04:47.210
none of your configuration
files will change,

00:04:47.210 --> 00:04:49.890
none of your interface
will change at all.

00:04:50.050 --> 00:04:54.100
The only thing that's affected
by the 64‑bit transition is

00:04:54.100 --> 00:04:56.140
the executable file itself.

00:04:56.180 --> 00:05:01.090
Let's take a look inside this
file and see what happens.

00:05:01.400 --> 00:05:04.930
When we open up this file,
the very first thing at the

00:05:05.010 --> 00:05:09.200
very beginning of this file is
something that's called the header.

00:05:09.200 --> 00:05:13.380
Now, the header to this file describes
the contents of this file.

00:05:13.380 --> 00:05:16.980
And it will describe what code
is contained in this file,

00:05:16.980 --> 00:05:20.120
what devices it has been
compiled for and so on.

00:05:20.120 --> 00:05:23.630
And so, for example,
in a standard iOS app,

00:05:23.630 --> 00:05:29.520
this header would describe a segment
or slice of this file that contains

00:05:29.530 --> 00:05:31.270
code compiled using the ARM view.

00:05:31.300 --> 00:05:36.820
And this is code that would
run on an older iOS device,

00:05:36.820 --> 00:05:39.630
such as an iPhone 3GS.

00:05:40.180 --> 00:05:43.920
The header might also describe a slice
of this file that's been compiled

00:05:43.920 --> 00:05:47.100
using the ARMV7S instruction set.

00:05:47.120 --> 00:05:49.700
This is code that would run
on a more recent iOS device,

00:05:49.700 --> 00:05:51.020
such as an iPhone 5.

00:05:51.160 --> 00:05:56.630
And so to make an app a 64‑bit app,
all we need to do is add one

00:05:56.690 --> 00:06:01.160
more slice to this file using
the new instruction set,

00:06:01.160 --> 00:06:03.940
the ARM64 instruction set.

00:06:03.960 --> 00:06:08.530
The presence of this portion
of the executable file is what

00:06:08.830 --> 00:06:11.610
makes an app a 64‑bit app.

00:06:13.910 --> 00:06:18.820
Now, because we are adding
more code into this file,

00:06:18.840 --> 00:06:21.920
the app will be larger in size.

00:06:21.920 --> 00:06:24.950
But remember that these
changes are limited to only

00:06:25.100 --> 00:06:26.960
the executable file itself.

00:06:26.990 --> 00:06:33.000
The main bulk of an app size comes from
its assets and its other resources.

00:06:33.000 --> 00:06:36.470
So on the whole,
this shouldn't be a very large change

00:06:36.470 --> 00:06:38.740
to the application bundle size.

00:06:38.840 --> 00:06:43.510
And by having multiple architectures
in a single file like this,

00:06:43.510 --> 00:06:47.680
it means that you only need
to ship a single application

00:06:47.950 --> 00:06:50.700
to support every iOS device.

00:06:52.990 --> 00:06:58.910
So let's go through the steps of
adopting 64‑bit in your games.

00:06:59.290 --> 00:07:03.850
The very first step is to update
the architecture's build setting.

00:07:03.930 --> 00:07:05.450
This is very trivial.

00:07:05.690 --> 00:07:09.120
All we need to do to do this is to
open up Xcode and go to the build

00:07:09.500 --> 00:07:13.730
settings for our target and find
the architecture's build setting.

00:07:13.730 --> 00:07:17.740
By default, on your existing projects,
this will likely be

00:07:17.740 --> 00:07:19.550
standard architectures.

00:07:19.590 --> 00:07:23.580
All you need to do to make your
app compile for 64‑bit is to

00:07:23.580 --> 00:07:28.650
change this value to standard
architectures including 64‑bit.

00:07:29.200 --> 00:07:30.210
That's all there is to it.

00:07:30.280 --> 00:07:33.430
It takes about 10 seconds.

00:07:34.540 --> 00:07:37.960
The next thing you'll need to
do is update any third‑party

00:07:37.960 --> 00:07:40.920
libraries that you may be using.

00:07:41.530 --> 00:07:45.440
In a 64‑bit app,
all the code that executes must

00:07:45.800 --> 00:07:48.840
also be compiled for 64‑bit.

00:07:48.840 --> 00:07:54.030
So if you're using a third‑party library,
whether it's a game engine or perhaps a

00:07:54.030 --> 00:07:58.590
library to link to some synchronization
service or anything like that,

00:07:58.700 --> 00:08:04.400
that code must also be compiled for
64‑bit if you want to ship a 64‑bit app.

00:08:04.400 --> 00:08:09.810
You cannot use a 32‑bit library
in a 64‑bit app or vice versa.

00:08:10.960 --> 00:08:16.320
Going back to this model of the
contents of our executable file,

00:08:16.320 --> 00:08:20.380
if one of our libraries
were not built for 64 bits,

00:08:20.490 --> 00:08:24.130
it would be like part of
this file would be missing.

00:08:24.130 --> 00:08:29.130
And in fact, we wouldn't even be able to
compile our applications.

00:08:29.140 --> 00:08:32.820
So make sure that you update
your third‑party libraries.

00:08:32.880 --> 00:08:38.190
Now, there's a very easy way to check
to see if the libraries you already

00:08:38.220 --> 00:08:39.890
have support 64 bits or not.

00:08:40.530 --> 00:08:44.640
To do this, we just open up terminal
and use the file command.

00:08:44.640 --> 00:08:47.120
We pass in the name of the .A file.

00:08:47.170 --> 00:08:51.900
Now, the file command will inspect our
executables and it will list the

00:08:51.930 --> 00:08:54.160
contents found in that header.

00:08:54.160 --> 00:08:58.850
And so, looking at this library here,
we can see that this is a library

00:08:58.930 --> 00:09:04.000
that contains five architectures,
five slices, three for iOS devices and

00:09:04.000 --> 00:09:05.820
two for the simulators.

00:09:05.820 --> 00:09:13.420
And what we're looking for in particular
is the presence of the ARM64 slice.

00:09:13.480 --> 00:09:18.600
If your libraries have this line,
then you're ready to go.

00:09:22.090 --> 00:09:26.400
The bulk of your time in moving
to 64‑bit will likely be spent

00:09:26.400 --> 00:09:32.750
fixing any of the small issues that
arise from the new 64‑bit standard.

00:09:34.110 --> 00:09:38.000
When we talk about the
32‑ and 64‑bit standards,

00:09:38.290 --> 00:09:41.940
they center around how
we deal with primitives.

00:09:41.940 --> 00:09:45.000
So this is what we're used to seeing.

00:09:46.140 --> 00:09:49.840
This is on a 32‑bit device
where chars are a single byte,

00:09:49.840 --> 00:09:52.920
shorts are two bytes,
pointers are four bytes,

00:09:52.920 --> 00:09:54.680
longs are also four bytes.

00:09:54.680 --> 00:09:56.740
That should be very familiar to us all.

00:09:56.740 --> 00:09:59.260
This is known as the ILP32 standard.

00:09:59.260 --> 00:10:02.320
So integers, longs,
and pointers are 32 bits.

00:10:02.660 --> 00:10:08.450
Now, the standard that we've adopted for
64 bits is known as the LP64 standard.

00:10:08.450 --> 00:10:13.560
So what changes then are longs and
pointers and any type derived from those.

00:10:13.560 --> 00:10:19.510
So on a 64‑bit device now,
longs are 64 bits and pointers

00:10:19.510 --> 00:10:22.150
are also 64 bits long.

00:10:23.120 --> 00:10:25.620
This has some advantages.

00:10:25.620 --> 00:10:28.940
When we refer to data
types such as NS integer,

00:10:28.940 --> 00:10:32.710
we go from being able to represent
about 4 billion possible values on

00:10:32.840 --> 00:10:37.940
a 32‑bit device to being able to
represent over 18 quintillion values in

00:10:37.940 --> 00:10:40.780
a single NS integer on a 64‑bit device.

00:10:40.780 --> 00:10:49.360
CG float and other doubles similarly get
this massive increase in potential range.

00:10:49.870 --> 00:10:56.240
Dave DeLoong: So, for example,
in your code,

00:10:56.240 --> 00:10:59.900
you might be doing something like this,
where you're invoking a method

00:10:59.900 --> 00:11:03.750
that has an NS integer return type,
and you're taking the value that's

00:11:03.800 --> 00:11:08.680
returned from this method and
storing it into an int data type.

00:11:09.100 --> 00:11:14.050
Now, as we know,
an int is four bytes long.

00:11:14.960 --> 00:11:20.900
But on a 64‑bit device,
an NS integer is now 8 bytes long.

00:11:20.900 --> 00:11:24.200
And last I checked, you can't put 8 bytes
of data inside 4 bytes.

00:11:24.280 --> 00:11:27.360
It would revolutionize
compression if we could.

00:11:27.360 --> 00:11:32.510
So what happens then is that
we lose half of our data.

00:11:32.510 --> 00:11:36.360
The first 4 bytes of our
NS integer just disappear.

00:11:37.620 --> 00:11:41.280
And if those bytes contained
important information,

00:11:41.280 --> 00:11:43.260
we now have corrupt data.

00:11:43.260 --> 00:11:46.470
We have truncated this number,
we've lost half of it,

00:11:46.530 --> 00:11:48.720
and our data is now invalid.

00:11:48.720 --> 00:11:50.310
So how do we fix this?

00:11:50.310 --> 00:11:51.860
Very easily.

00:11:51.860 --> 00:11:55.370
We just make sure that
our data types match.

00:11:55.370 --> 00:11:59.020
If our method returns an 8‑byte value,
we should be putting it

00:11:59.020 --> 00:12:00.830
into an 8‑byte data type.

00:12:00.900 --> 00:12:04.530
If it returns a 4‑byte value,
we put it into a 4‑byte data type,

00:12:04.580 --> 00:12:05.110
and so on.

00:12:08.160 --> 00:12:10.720
Similarly,
we might be trying to copy some data

00:12:10.720 --> 00:12:12.830
out of a primitive and into a buffer.

00:12:12.830 --> 00:12:15.320
Now,
here we've made the assumption that our

00:12:15.320 --> 00:12:17.450
longs are going to be four bytes long.

00:12:17.600 --> 00:12:21.360
And that would have been true, of course,
on a 32‑bit device.

00:12:21.360 --> 00:12:25.320
But on a 64‑bit device, of course,
longs are now eight bytes.

00:12:25.320 --> 00:12:28.200
And so, again,
if we only copy four of those bytes,

00:12:28.200 --> 00:12:30.210
we'll have lost half of our number.

00:12:30.230 --> 00:12:33.400
And our buffer will end
up containing garbage.

00:12:33.880 --> 00:12:37.520
So instead of assuming that we
know the size of our data types,

00:12:37.520 --> 00:12:39.820
let's be a bit more flexible about it.

00:12:39.820 --> 00:12:42.740
And instead,
we'll use the size of operator so that

00:12:42.960 --> 00:12:46.880
we can dynamically refer to the size
of these data types and not base our

00:12:47.090 --> 00:12:49.720
code on potentially faulty assumptions.

00:12:54.990 --> 00:12:58.420
Another way that 64‑bit can
affect our code is if we're

00:12:58.420 --> 00:13:03.210
trying to print a variable,
a data type, into a string.

00:13:03.680 --> 00:13:05.600
doesn't have to be NSString.

00:13:05.600 --> 00:13:10.000
This even affects things
as low level as printf.

00:13:10.010 --> 00:13:14.320
So here we're trying to print
a long into a string and we're

00:13:14.430 --> 00:13:17.440
using the %d format specifier.

00:13:17.440 --> 00:13:23.010
Now, the %d format specifier
says take a 4‑byte value and

00:13:23.010 --> 00:13:25.990
treat it as a signed integer.

00:13:26.590 --> 00:13:30.400
Of course, as we've just learned,
longs are now 8 bytes.

00:13:30.400 --> 00:13:34.750
And so if we were to try and
print an 8‑byte long using the

00:13:34.800 --> 00:13:38.900
%d modifier into the string,
we would end up printing only

00:13:38.900 --> 00:13:42.730
four of those bytes and would end
up with garbage in our string.

00:13:43.000 --> 00:13:48.260
So again,
let's use the correct format specifier,

00:13:48.260 --> 00:13:52.680
%ld,
for a long integer so that our string

00:13:52.680 --> 00:13:52.990
will contain the correct value.

00:13:53.730 --> 00:13:56.860
There's a single rule to
deal with all of these,

00:13:56.860 --> 00:13:59.880
and it's simply the idea of consistency.

00:13:59.880 --> 00:14:02.950
Let's be consistent in how
we refer to data types.

00:14:03.030 --> 00:14:07.900
If our methods return an 8‑byte value,
let's store it into an 8‑byte variable.

00:14:07.900 --> 00:14:11.090
Let's make sure that we're not
making assumptions about the

00:14:11.140 --> 00:14:13.100
sizes of these data types either.

00:14:13.100 --> 00:14:15.480
Let's use the size of operator instead.

00:14:15.480 --> 00:14:18.960
Finally,
let's make sure that we're consistent

00:14:18.960 --> 00:14:23.240
between the format strings that
we use and the variables that

00:14:23.240 --> 00:14:25.480
we're trying to print into them.

00:14:25.500 --> 00:14:29.400
So that's how 64‑bit will
affect our code in our games.

00:14:29.400 --> 00:14:33.060
It will also affect the
data that we write to disk.

00:14:33.060 --> 00:14:35.970
If we consider sharing
data between devices,

00:14:35.970 --> 00:14:38.920
many of your users will
have 32‑bit devices,

00:14:38.920 --> 00:14:42.320
but many of them will have an
iPhone 5S or an iPad Air and thus

00:14:42.320 --> 00:14:44.680
be running on 64‑bit devices.

00:14:44.680 --> 00:14:45.460
And so we're going to
be using 64‑bit devices.

00:14:45.460 --> 00:14:49.570
So if you do any peer‑to‑peer
communication or even any communication

00:14:49.680 --> 00:14:53.380
between the device and a server,
you need to make sure that you're

00:14:53.580 --> 00:14:57.900
accurately representing the data
that is going between these devices.

00:14:57.900 --> 00:15:03.130
If you take an NS integer, for example,
and try to send it from a 64‑bit

00:15:03.130 --> 00:15:08.150
device to a 32‑bit device where
it's also treated as an NS integer,

00:15:08.150 --> 00:15:12.420
then you will deal with these
exact same problems of truncation

00:15:12.420 --> 00:15:14.640
that we just talked about.

00:15:16.960 --> 00:15:19.700
You may be thinking, well,
this doesn't affect me.

00:15:19.700 --> 00:15:24.040
My game has no server communication
and it doesn't do any sort of

00:15:24.060 --> 00:15:28.800
peer‑to‑peer or local game play,
so I don't have to worry about this.

00:15:28.940 --> 00:15:31.480
Well, that's not quite true.

00:15:31.630 --> 00:15:36.750
Because even if your game is
only writing files to disk,

00:15:36.750 --> 00:15:43.230
you still might run into this problem
when you consider the scenario of

00:15:43.230 --> 00:15:43.230
restoring a device from backup.

00:15:44.110 --> 00:15:48.070
Let's consider one of your users.

00:15:48.070 --> 00:15:51.460
This user has an iPhone 4.

00:15:51.460 --> 00:15:52.700
It's a couple of years old.

00:15:52.700 --> 00:15:55.060
They've been very happy with this device.

00:15:55.060 --> 00:15:56.560
They've been running your games on it.

00:15:56.560 --> 00:15:59.640
Your games have been
writing data out to disk.

00:15:59.640 --> 00:16:04.340
This user has been backing
this device up to iCloud.

00:16:04.340 --> 00:16:10.970
This iPhone has been taking those files
that you've been creating on a 32‑bit

00:16:11.290 --> 00:16:13.020
device and saving them to iCloud.

00:16:13.200 --> 00:16:15.340
Dave DeLoong:
Then we announced the iPhone 5S.

00:16:15.340 --> 00:16:19.550
Now this customer has decided they
want to get rid of their iPhone 4,

00:16:19.730 --> 00:16:20.960
buy an iPhone 5S.

00:16:21.000 --> 00:16:21.710
So they do this.

00:16:21.880 --> 00:16:23.890
They get a very nice white one.

00:16:24.030 --> 00:16:27.440
And to make the transition easy,
they decide to restore this

00:16:27.440 --> 00:16:29.260
device from their iCloud backup.

00:16:29.330 --> 00:16:31.100
This is a very common scenario.

00:16:31.370 --> 00:16:36.880
And so in the process of restoration,
that same file that you created on

00:16:36.920 --> 00:16:43.040
a 32‑bit device is now copied down
from iCloud onto the 64‑bit device.

00:16:43.040 --> 00:16:45.880
And so again,
we are dealing with the scenario of we

00:16:45.880 --> 00:16:51.530
have data created on a 32‑bit device,
but it's being read on a 64‑bit device.

00:16:51.680 --> 00:16:56.400
And so we need to be flexible
in how we interpret this data.

00:16:56.400 --> 00:17:00.370
Going back to the idea of consistency,
we need to read exactly what

00:17:00.380 --> 00:17:02.270
we have written from this file.

00:17:02.270 --> 00:17:06.140
If we have written a 32‑bit value,
we should read a 32‑bit

00:17:06.220 --> 00:17:07.810
value out of this file.

00:17:07.920 --> 00:17:11.650
And if we have written a
64‑bit value to this file,

00:17:11.660 --> 00:17:14.540
we need to read out a value.

00:17:16.560 --> 00:17:20.480
There are a couple of ways that
we can approach this problem.

00:17:20.640 --> 00:17:25.390
We can establish the
policy that we will always,

00:17:25.530 --> 00:17:28.740
only ever write 32-bit
values to this file,

00:17:28.860 --> 00:17:32.740
regardless of whether it's
a 32- or 64-bit device.

00:17:32.850 --> 00:17:36.130
Or we could take the opposite approach,
that on every device,

00:17:36.240 --> 00:17:38.760
we will always be writing 64-bit values.

00:17:38.980 --> 00:17:42.300
So long longs, doubles, and so on.

00:17:42.450 --> 00:17:45.040
And we will always be
reading 64-bit values,

00:17:45.100 --> 00:17:48.520
again regardless of what
kind of device we're on.

00:17:48.930 --> 00:17:50.940
A third approach that
you could take is to,

00:17:50.940 --> 00:17:53.220
again, be more dynamic about it.

00:17:53.220 --> 00:17:55.450
In addition to whatever
data you write to this file,

00:17:55.450 --> 00:17:57.720
you could also include
some metadata that,

00:17:57.720 --> 00:18:02.080
perhaps,
this file contains 32-bit values.

00:18:02.080 --> 00:18:07.110
And then as you read in this file
on either a 32- or a 64-bit device,

00:18:07.110 --> 00:18:11.560
that you correctly interpret this file
by looking at this metadata and saying,

00:18:11.560 --> 00:18:13.650
"Aha, it contains 32-bit values.

00:18:13.720 --> 00:18:18.400
I will read 32-bit values."
Or perhaps it contains 64-bit values.

00:18:18.400 --> 00:18:21.160
And you, again, you read what you write.

00:18:21.160 --> 00:18:23.930
And when you read what you write,
you avoid those same

00:18:23.930 --> 00:18:29.780
problems of truncation that
arose earlier in your code.

00:18:29.800 --> 00:18:33.290
So this is how 64-bit will affect
data that you write to disk.

00:18:35.890 --> 00:18:41.680
64‑bit will also affect the
memory usage of your games.

00:18:41.680 --> 00:18:44.470
Now,
because pointers have doubled in size,

00:18:44.500 --> 00:18:46.620
you will end up using more memory.

00:18:46.620 --> 00:18:48.640
That is unavoidable.

00:18:48.640 --> 00:18:50.770
You all use pointers.

00:18:51.080 --> 00:18:54.320
There's no escaping pointers,
whether for good or for evil.

00:18:54.320 --> 00:18:56.500
You cannot escape them.

00:18:56.710 --> 00:19:00.640
And you may think that to avoid
the penalty of doubling the

00:19:00.640 --> 00:19:04.290
size of all of those pointers,
that you're just going to

00:19:04.330 --> 00:19:06.600
keep your app as a 32‑bit app.

00:19:06.600 --> 00:19:08.220
And that sounds really nice.

00:19:08.430 --> 00:19:10.030
Except there's a problem.

00:19:10.030 --> 00:19:17.390
And the problem arises from what gets
loaded into memory when a 64‑bit device

00:19:17.390 --> 00:19:20.560
tries to launch a 32‑bit application.

00:19:21.560 --> 00:19:26.800
So let's consider the amount of
memory that we have on an iOS device.

00:19:26.880 --> 00:19:28.790
This gray box will represent our RAM.

00:19:28.790 --> 00:19:33.380
Now, loaded into memory, of course,
is the operating system itself.

00:19:33.380 --> 00:19:35.060
The device has to run.

00:19:35.080 --> 00:19:39.640
And the operating system will also
load many helper applications so that

00:19:39.640 --> 00:19:44.010
it can connect to iCloud and download
your email or connect to iMessage

00:19:44.010 --> 00:19:46.280
or any number of other services.

00:19:46.280 --> 00:19:49.640
So system applications
take up memory as well.

00:19:51.360 --> 00:19:54.780
One of the other things we load
into memory is something we call

00:19:54.780 --> 00:19:56.680
the shared frameworks cache.

00:19:56.680 --> 00:20:01.110
The shared frameworks cache is
a single copy of the standard

00:20:01.110 --> 00:20:03.300
application frameworks.

00:20:03.300 --> 00:20:07.290
So UIKit, foundation, core foundation,
CF network, so on.

00:20:07.290 --> 00:20:10.460
They're packaged up as a
single binary and when the

00:20:10.460 --> 00:20:14.700
device launches and starts up,
we load this cache into memory such

00:20:14.700 --> 00:20:18.230
that when we launch other applications,
instead of having to give

00:20:18.230 --> 00:20:21.240
them their own copy of UIKit,
we load it into memory.

00:20:21.320 --> 00:20:24.040
We can simply point them at
the shared cache and say,

00:20:24.090 --> 00:20:25.750
there's your copy over there.

00:20:25.890 --> 00:20:26.560
Use that one.

00:20:28.770 --> 00:20:33.820
I want to emphasize on a 64‑bit device,
the shared frameworks cache that

00:20:33.870 --> 00:20:39.890
gets loaded is of course the 64‑bit
version of the system frameworks.

00:20:40.440 --> 00:20:47.240
As we learned a few minutes ago,
a 32‑bit app cannot use 64‑bit libraries.

00:20:47.240 --> 00:20:51.800
So when we launch a 32‑bit
application on a 64‑bit device,

00:20:51.800 --> 00:20:56.910
we have to load a second copy
of the system frameworks.

00:20:57.560 --> 00:21:01.360
And only after we load a second copy
of the frameworks can we actually

00:21:01.360 --> 00:21:03.330
load a 32‑bit app into memory.

00:21:05.680 --> 00:21:10.930
Loading a second copy of the frameworks
means that you are now much more

00:21:10.930 --> 00:21:15.730
likely to run into a situation where
the device is running out of memory.

00:21:15.730 --> 00:21:19.290
This is not what we want to have happen.

00:21:19.290 --> 00:21:23.100
Because when we run out of memory,
apps start getting killed.

00:21:23.100 --> 00:21:27.560
And eventually, if things get bad enough,
your app might get killed as well.

00:21:27.560 --> 00:21:29.050
So let's avoid this problem.

00:21:29.440 --> 00:21:31.820
And the way that we avoid it is,
of course,

00:21:31.820 --> 00:21:35.490
by compiling our apps for 64‑bit
and therefore not incurring

00:21:35.620 --> 00:21:39.420
the penalty of loading the
32‑bit copy of the frameworks.

00:21:41.870 --> 00:21:47.780
So that's one of the ways that 64‑bit
can affect our app's memory usage.

00:21:47.780 --> 00:21:51.640
But 64‑bit can also affect our
app's memory usage in another way,

00:21:51.640 --> 00:21:54.830
and that has to do with the
alignment of primitives.

00:21:54.890 --> 00:21:59.320
So this is a very similar table
to the one we saw earlier,

00:21:59.490 --> 00:22:04.150
but this instead refers to
where data starts in memory.

00:22:04.150 --> 00:22:08.310
So on a 32‑bit device,
you could have a char start at

00:22:08.310 --> 00:22:11.130
every single byte offset in memory.

00:22:11.800 --> 00:22:16.620
But for things like longs or pointers,
they naturally only start

00:22:16.620 --> 00:22:18.920
every four bytes in memory.

00:22:18.920 --> 00:22:23.470
So, for example, at offset zero or offset
three or offset seven.

00:22:23.940 --> 00:22:29.280
And it would be very unnatural
for them to start at offset one.

00:22:30.860 --> 00:22:35.560
On a 64‑bit device,
these alignments change slightly.

00:22:35.560 --> 00:22:39.120
So, again, longs and pointers,
instead of being aligned

00:22:39.120 --> 00:22:43.940
on a 4‑byte boundary,
are now aligned on an 8‑byte boundary.

00:22:44.120 --> 00:22:48.620
Now, this might be not very easy
to intuit what this means.

00:22:49.020 --> 00:22:53.930
So let's take an example of
dealing with a custom struct.

00:22:54.580 --> 00:22:58.400
Many of you probably have structs in
your games to efficiently represent

00:22:58.400 --> 00:23:00.320
data that you're passing around.

00:23:00.340 --> 00:23:03.080
We've got a simple struct
here that contains two chars,

00:23:03.120 --> 00:23:10.080
an int, and a pointer.

00:23:10.330 --> 00:23:10.330
On a 32‑bit device with this layout,

00:23:10.550 --> 00:23:16.040
These 10 bytes of data actually
take up 16 bytes of memory.

00:23:16.040 --> 00:23:18.480
Because our first char can be
aligned on a one‑byte boundary,

00:23:18.480 --> 00:23:21.460
but our int has to be aligned
on a four‑byte boundary.

00:23:21.460 --> 00:23:26.680
So in between our char and our int,
there are three bytes of padding.

00:23:26.680 --> 00:23:29.100
And again,
after the second char and the pointer,

00:23:29.100 --> 00:23:31.160
there are again three bytes of padding.

00:23:31.160 --> 00:23:36.820
So already on a 32‑bit device,
we've got six wasted bytes of space.

00:23:38.320 --> 00:23:43.190
On a 64-bit device,
a couple of things happen.

00:23:45.560 --> 00:23:49.460
First off, of course, as we know,
our pointer will double in size

00:23:49.460 --> 00:23:52.010
because pointers are now 8 bytes long.

00:23:52.010 --> 00:23:56.240
But also, pointers are now aligned
on an 8‑byte boundary.

00:23:56.240 --> 00:23:59.880
So what this means is that instead
of having 3 bytes of padding

00:23:59.990 --> 00:24:03.340
after that second char member,
we now have 7 bytes.

00:24:03.420 --> 00:24:07.990
So this struct,
which now takes up 14 bytes of data

00:24:08.040 --> 00:24:14.530
or only contains 14 bytes of data,
is actually taking up 24 bytes of memory.

00:24:14.530 --> 00:24:20.050
So each instance of this struct
has 10 wasted bytes of space.

00:24:20.060 --> 00:24:23.890
Now, there are two approaches that
we could take to solving this.

00:24:23.890 --> 00:24:25.860
The first one is called packing.

00:24:25.860 --> 00:24:30.030
And what packing does is this
indicates to the compiler,

00:24:30.030 --> 00:24:33.400
do not insert those
extra bytes of padding.

00:24:33.400 --> 00:24:34.900
adding.

00:24:35.160 --> 00:24:42.500
So that our struct representation
in memory would look like this.

00:24:42.500 --> 00:24:45.810
But spoiler alert,
you don't want to do this.

00:24:46.090 --> 00:24:51.280
And you don't want to do this
because the CPU still has to align

00:24:51.280 --> 00:24:54.580
this data in order to read it.

00:24:54.580 --> 00:24:59.130
So, for example,
if the CPU wanted to read the

00:24:59.200 --> 00:25:03.680
pointer out of this struct,
it would still have to copy this struct's

00:25:03.780 --> 00:25:07.930
contents into a new block of memory,
realign it so that things are

00:25:08.190 --> 00:25:12.450
aligned on their natural boundaries,
and then it could read the

00:25:12.450 --> 00:25:14.610
pointer data out of the struct.

00:25:15.280 --> 00:25:19.460
That's a lot of extra work that
the CPU should not have to do.

00:25:19.460 --> 00:25:24.510
So you should really avoid packing
structs like this if you at all can.

00:25:24.510 --> 00:25:27.640
So this is the first way
you can solve this problem,

00:25:27.820 --> 00:25:30.100
and it's probably not the best way.

00:25:30.100 --> 00:25:35.300
So the other way that you can do
it is instead by rearranging the

00:25:35.300 --> 00:25:38.410
members of your struct like this.

00:25:41.240 --> 00:25:47.380
By rearranging the members of the struct,
we can efficiently pack the data

00:25:47.380 --> 00:25:50.260
in our structs in a natural way.

00:25:50.260 --> 00:25:56.910
And the secret here is to simply order
the members of our struct by size.

00:25:57.210 --> 00:25:59.840
Order them from largest to smallest.

00:25:59.840 --> 00:26:03.270
And by ordering them
from largest to smallest,

00:26:03.270 --> 00:26:08.080
the members of the struct will naturally
align to their proper boundaries

00:26:08.460 --> 00:26:10.600
with almost zero wasted space.

00:26:10.600 --> 00:26:13.880
And in many cases,
with no wasted space at all.

00:26:13.890 --> 00:26:17.940
And so on a 64‑bit device,
as we're dealing with

00:26:18.220 --> 00:26:22.430
these 14 bytes of data,
in a properly organized struct,

00:26:22.430 --> 00:26:26.200
it will take up exactly 14 bytes of data.

00:26:26.200 --> 00:26:31.490
On a 32‑bit device, it would take up only
the requisite 10 bytes.

00:26:31.580 --> 00:26:36.200
So this is another way that 64‑bit
can affect your app's memory usage.

00:26:36.530 --> 00:26:41.180
If you're dealing with custom structs,
make sure that you've organized them

00:26:41.180 --> 00:26:44.870
properly so that you are using your
memory as efficiently as possible.

00:26:46.930 --> 00:26:51.000
So that's a quick overview of some
of the issues that might arise as

00:26:51.200 --> 00:26:54.990
you adopt 64‑bit in your games.

00:26:55.990 --> 00:27:00.220
Now the final thing that you'll want to
do is of course to test these changes.

00:27:00.220 --> 00:27:04.270
By making these changes to the data
types or perhaps even to the organization

00:27:04.270 --> 00:27:08.220
of the structs in your games,
you are necessarily altering

00:27:08.300 --> 00:27:10.200
the behavior of your game.

00:27:10.200 --> 00:27:13.860
And it behooves you to test these
changes to make sure that they

00:27:13.970 --> 00:27:17.820
do exactly what you intend to,
especially when it comes to

00:27:18.050 --> 00:27:20.140
reordering those structs.

00:27:20.140 --> 00:27:24.270
If you have structs that have been
simply serialized directly to a

00:27:24.270 --> 00:27:28.640
byte stream and then saved to disk,
you need to make sure that you correctly

00:27:28.640 --> 00:27:33.450
read those back in in the old order
before transforming them into their

00:27:33.450 --> 00:27:36.320
new more efficient organization.

00:27:36.320 --> 00:27:40.710
This is where things like continuous
integration and unit testing can make it

00:27:40.710 --> 00:27:44.790
really easy to verify that the changes
that you have made to your games are

00:27:44.940 --> 00:27:48.370
correct and do exactly what you want.

00:27:49.420 --> 00:27:56.340
So that's a summary of 64‑bit on the
A7 and what it means for your games.

00:27:56.340 --> 00:27:59.630
We have a really excellent piece
of documentation called the 64‑bit

00:27:59.630 --> 00:28:01.460
transition guide for Cocoa Touch.

00:28:01.460 --> 00:28:06.330
It goes into a lot more detail than
I just did on all of the changes that

00:28:06.330 --> 00:28:09.740
64‑bit means for iOS applications.

00:28:09.740 --> 00:28:12.940
And it even deals with some of
the more esoteric corner cases,

00:28:12.940 --> 00:28:15.650
such as how you properly
deal with function pointers

00:28:15.680 --> 00:28:18.130
that take variadic arguments,
which we figured that

00:28:18.330 --> 00:28:19.280
most people wouldn't.

00:28:19.300 --> 00:28:22.830
wouldn't need to know about,
but it's still important.

00:28:23.050 --> 00:28:26.850
Now, this might sound like a lot of work,
but if you've been doing everything

00:28:26.850 --> 00:28:30.990
that you're supposed to have been doing,
if you haven't been making assumptions

00:28:30.990 --> 00:28:35.050
about the sizes of data types,
and if you've been consistent

00:28:35.240 --> 00:28:40.070
in how you refer to data,
then this transition should actually

00:28:40.110 --> 00:28:42.930
be extremely straightforward.

00:28:43.390 --> 00:28:50.290
As we've worked with many of you and
other developers in adopting 64‑bit,

00:28:50.420 --> 00:28:55.190
overwhelmingly, the reaction has been
that this is pretty easy.

00:28:55.460 --> 00:28:58.710
We've even heard some stories of
developers being able to do this full

00:28:58.710 --> 00:29:03.160
transition in as little as five minutes,
although that is kind of an ideal case.

00:29:03.200 --> 00:29:05.810
It will probably take
you a little bit more,

00:29:05.810 --> 00:29:07.680
but hopefully not too long.

00:29:08.530 --> 00:29:12.970
So that was a quick look at
the A7 and how you can take

00:29:12.970 --> 00:29:15.170
advantage of 64‑bit in your games.

00:29:15.190 --> 00:29:21.580
Let's move on now to building
your games for iOS 7.

00:29:22.230 --> 00:29:27.770
Whenever we introduce a new SDK,
one of the big questions that many

00:29:27.770 --> 00:29:31.790
developers have is how they can
use all of the great new features

00:29:32.140 --> 00:29:35.590
of this new operating system but
still support older versions.

00:29:36.310 --> 00:29:37.790
Literally this question.

00:29:38.080 --> 00:29:42.890
How do I use iOS 7 features
but still support iOS 6?

00:29:43.660 --> 00:29:49.260
And there's a lot of misinformation out
there about how you actually do this.

00:29:49.260 --> 00:29:51.930
And many developers,
but I'm sure none of you,

00:29:52.070 --> 00:29:54.440
are under the assumption that you can't.

00:29:54.720 --> 00:29:57.400
That if you want to support iOS 6,
that you still must

00:29:57.480 --> 00:29:59.170
compile with the iOS 6 SDK.

00:29:59.230 --> 00:30:02.400
And if you wanted to use things
like game controllers or the

00:30:02.500 --> 00:30:06.270
new background download API,
that you're just kind of out of luck.

00:30:06.330 --> 00:30:10.790
Or that it would be way too hard to
try and bifurcate your app's logic

00:30:10.820 --> 00:30:13.300
so that it can handle both cases.

00:30:13.600 --> 00:30:16.430
Well, in this part of the talk,
we're going to learn that

00:30:16.430 --> 00:30:20.350
it's possible and it,
in fact, is quite easy to do this.

00:30:20.470 --> 00:30:22.570
So let's answer this question.

00:30:22.740 --> 00:30:26.860
How do we support iOS 7 while
still maintaining backwards

00:30:26.860 --> 00:30:29.160
compatibility with iOS 6?

00:30:29.160 --> 00:30:31.220
There are two parts to this answer.

00:30:31.220 --> 00:30:35.920
And the first part is, of course,
we must use the iOS 7 base SDK.

00:30:35.970 --> 00:30:39.790
If you want iOS 7 features,
got to use the iOS 7 SDK.

00:30:39.890 --> 00:30:41.200
That's easy.

00:30:42.650 --> 00:30:46.300
The second part of this
answer is in your code,

00:30:46.440 --> 00:30:50.340
before you want to use new
API like perhaps game controllers

00:30:50.340 --> 00:30:53.400
or these background downloads
that I've been talking about,

00:30:53.460 --> 00:30:56.920
you first want to check to see
if they're actually present.

00:30:56.990 --> 00:30:57.760
If they are, great.

00:30:57.780 --> 00:31:01.720
If they're not, well, then, of course,
don't try to use them.

00:31:02.010 --> 00:31:07.100
So we've identified five main
categories of features that we

00:31:07.100 --> 00:31:09.500
introduce with each new SDK.

00:31:09.500 --> 00:31:12.820
They center around new frameworks
and therefore new classes,

00:31:12.860 --> 00:31:16.380
new methods on existing classes,
new capabilities to

00:31:16.380 --> 00:31:19.900
hardware and software,
new designs,

00:31:19.910 --> 00:31:22.020
and as we've just learned about,
new architectures.

00:31:22.020 --> 00:31:27.170
So how do we adopt a new framework?

00:31:28.180 --> 00:31:30.570
In iOS 7,
we've added a couple of new frameworks

00:31:30.580 --> 00:31:32.600
like SpriteKit and Game Controller.

00:31:32.630 --> 00:31:36.250
I imagine many of you would be
interested in adding support for

00:31:36.580 --> 00:31:39.010
Game Controllers to your applications.

00:31:39.250 --> 00:31:43.710
You'll hear a lot more about how you
actually do that later this afternoon.

00:31:44.310 --> 00:31:46.790
The summary, though,
is of course that we're going to

00:31:46.790 --> 00:31:49.960
end up linking the game controller
framework into our target.

00:31:49.960 --> 00:31:53.910
And when we add the game controller
framework to our link binary

00:31:53.910 --> 00:31:56.590
with libraries build phase,
by default,

00:31:56.590 --> 00:31:59.370
this is going to be a required framework.

00:31:59.380 --> 00:32:04.850
And what that means is that our
application would refuse to launch if

00:32:04.850 --> 00:32:11.110
the framework is not present on the
hosting device because it's required.

00:32:11.820 --> 00:32:15.440
So in this case,
by requiring game controller,

00:32:15.440 --> 00:32:20.090
we have effectively set our
deployment target to iOS 7.

00:32:20.580 --> 00:32:24.220
Regardless of what the actual
setting is in our build settings,

00:32:24.220 --> 00:32:28.470
if we require game controller,
our app will only ever run

00:32:28.730 --> 00:32:32.080
on iOS 7 because it would
refuse to launch on iOS 6.

00:32:32.080 --> 00:32:34.160
That's not what we want.

00:32:34.160 --> 00:32:35.740
So what do we do?

00:32:35.740 --> 00:32:40.360
Well, we simply click that little
required pop up over on the right.

00:32:41.440 --> 00:32:44.740
change the framework to be optional.

00:32:45.040 --> 00:32:47.920
Now,
by making this framework be optional,

00:32:47.920 --> 00:32:52.200
we are indicating that our app is
able to handle the game controller

00:32:52.210 --> 00:32:54.200
framework not being present.

00:32:54.200 --> 00:32:57.560
And so if it's not there,
we should still continue

00:32:57.560 --> 00:32:58.950
to launch anyway.

00:32:59.390 --> 00:33:04.900
Now, some of you perhaps are not using
Xcode to compile your games.

00:33:04.900 --> 00:33:07.050
And even if that's the case,
you can still take advantage

00:33:07.050 --> 00:33:08.340
of these optional frameworks.

00:33:08.430 --> 00:33:11.850
Instead of using the dash
framework flag to link in the

00:33:11.850 --> 00:33:15.830
framework at the linking phase,
you would simply use the dash

00:33:15.830 --> 00:33:18.240
week underscore framework flag.

00:33:18.240 --> 00:33:22.170
And that's how you indicate that
a manually compiled framework or

00:33:22.300 --> 00:33:27.590
manually compiled app should weakly link
against the game controller framework.

00:33:27.600 --> 00:33:31.290
But what does this mean for your code?

00:33:31.860 --> 00:33:35.820
Here's a line of code we would probably
be using if we were trying to use the

00:33:35.820 --> 00:33:42.120
game controller framework and we want
to support wireless game controllers.

00:33:42.220 --> 00:33:44.340
On iOS 7, this of course will work great.

00:33:44.440 --> 00:33:46.500
But what about on iOS 6?

00:33:46.500 --> 00:33:51.180
Well, when your application starts up,
one of the things that we do

00:33:51.180 --> 00:33:52.450
is called symbol resolution.

00:33:52.460 --> 00:33:55.800
And as your application loads,
we're going through and we're seeing,

00:33:55.910 --> 00:33:58.290
okay,
you're using the UI application class.

00:33:58.400 --> 00:33:59.450
That's over there.

00:33:59.460 --> 00:34:00.540
You're using UI view.

00:34:00.540 --> 00:34:01.620
That's also over there.

00:34:01.620 --> 00:34:02.860
You're using NSString.

00:34:02.860 --> 00:34:04.160
Well, that one's over there.

00:34:04.180 --> 00:34:08.400
And we go through and we match up the
symbols indicated in your executable

00:34:08.400 --> 00:34:14.090
with where they're actually living at in
memory in that shared frameworks cache.

00:34:14.840 --> 00:34:17.400
But what about when the
symbol doesn't exist?

00:34:17.530 --> 00:34:23.200
Well, since we indicated that the game
controller framework was optional,

00:34:23.200 --> 00:34:25.910
we just simply make
that symbol be nothing.

00:34:26.110 --> 00:34:27.880
It's nil.

00:34:29.850 --> 00:34:32.980
And I hope you all know
that in Objective C,

00:34:32.980 --> 00:34:36.900
it is totally safe to
send messages to nil.

00:34:36.900 --> 00:34:38.680
We will not throw an exception.

00:34:38.870 --> 00:34:41.100
Your app will not crash.

00:34:41.130 --> 00:34:42.710
This code works great.

00:34:42.750 --> 00:34:44.780
In fact, it just does nothing.

00:34:44.940 --> 00:34:49.550
So if we want to use that
line of game controller code,

00:34:49.550 --> 00:34:56.300
then we can just use it as is with no
modifications on both iOS 6 and iOS 7.

00:34:56.700 --> 00:34:58.530
Just like that.

00:34:59.170 --> 00:35:02.470
But there are times when this
conversion to nil can have

00:35:02.510 --> 00:35:04.950
some unintended side effects.

00:35:05.200 --> 00:35:06.870
So for example,
here's another part of the

00:35:07.120 --> 00:35:08.420
game controller framework.

00:35:08.420 --> 00:35:11.720
We need to listen to a notification
for when we've actually

00:35:11.720 --> 00:35:13.700
connected to a controller.

00:35:13.700 --> 00:35:16.770
This is how we would do that
on iOS 7 by registering with

00:35:16.770 --> 00:35:21.540
NS Notification Center under that
appropriate notification name.

00:35:22.530 --> 00:35:26.520
But as we just learned,
on iOS 6 when our app gets loaded,

00:35:26.520 --> 00:35:32.340
that GC controller did connect
notification symbol resolves to nil,

00:35:32.400 --> 00:35:36.180
which means on iOS 6,
our code becomes this.

00:35:36.200 --> 00:35:39.380
Where we're registering
for a nil notification name

00:35:39.380 --> 00:35:40.650
coming from a nil object.

00:35:40.680 --> 00:35:43.960
Now,
that might not sound like a bad idea,

00:35:44.230 --> 00:35:47.440
but it actually has some
unintended side effects.

00:35:47.440 --> 00:35:53.950
And what happens is when you register
for notification from NS Notification

00:35:53.980 --> 00:35:58.570
Center for any notification,
so therefore a nil notification

00:35:58.570 --> 00:36:03.850
name coming from a nil object,
we will notify you about

00:36:03.860 --> 00:36:07.000
every single notification.

00:36:07.380 --> 00:36:10.820
Any notification name
coming from any object.

00:36:10.870 --> 00:36:12.680
That's what that means.

00:36:12.680 --> 00:36:16.350
What it means in practice is
that as your app starts up and

00:36:16.350 --> 00:36:22.650
as your app continues to run,
we will spam your observer with

00:36:23.160 --> 00:36:26.400
thousands of notifications.

00:36:26.400 --> 00:36:30.140
So this is probably not what
you want to have happen.

00:36:31.050 --> 00:36:33.120
It's a bit overkill.

00:36:33.120 --> 00:36:35.660
So instead,
we need to check to see if the

00:36:35.660 --> 00:36:38.600
feature we want to use exists.

00:36:38.600 --> 00:36:42.140
We do that by checking to see
if the symbol itself is non‑nil.

00:36:42.140 --> 00:36:45.900
We do that simply by taking the
address of the notification name

00:36:45.900 --> 00:36:48.480
constant and checking it against null.

00:36:48.480 --> 00:36:51.780
If it's non‑null,
then we know that the symbol

00:36:51.830 --> 00:36:55.980
exists and we can safely use it as
the name of our NS notification.

00:36:57.260 --> 00:37:01.700
So this side effect of converting
symbols to nil is a great way

00:37:01.700 --> 00:37:05.760
to check if frameworks are
present or if new classes exist.

00:37:05.760 --> 00:37:10.350
If you're using a new class,
whether it's in a well‑established

00:37:10.660 --> 00:37:14.000
framework like UIKit or a brand
new framework like SpriteKit,

00:37:14.160 --> 00:37:17.200
if that class does not
exist on that iOS device,

00:37:17.260 --> 00:37:21.680
it will also become nil and you
can easily test for that as well.

00:37:21.700 --> 00:37:25.820
So this is how we adopt new
frameworks and new classes.

00:37:25.820 --> 00:37:26.120
Thank you.

00:37:27.260 --> 00:37:28.410
Thank you.

00:37:28.440 --> 00:37:29.600
Thank you.

00:37:29.600 --> 00:37:30.560
Thank you.

00:37:30.560 --> 00:37:32.520
Thank you.

00:37:33.450 --> 00:37:37.560
On iOS 7, we've added some API called
UI Motion Effect that allows us

00:37:37.560 --> 00:37:41.460
to add that parallax effect that
you see on the iOS 7 home screen.

00:37:41.460 --> 00:37:44.850
It's really easy to add
this to your own views.

00:37:44.940 --> 00:37:47.350
We're not going to go into
exactly how you want to do that.

00:37:47.400 --> 00:37:51.540
If you want to know that,
you can check out some videos from

00:37:51.540 --> 00:37:56.200
WWDC or perhaps some of the videos
from the Apps Day tech talks.

00:37:57.060 --> 00:38:00.380
Regardless,
the way that you add a motion effect to a

00:38:00.460 --> 00:38:05.930
particular view is using this new method
on UI View called Add Motion Effect.

00:38:06.420 --> 00:38:10.020
Now, UIView is obviously a class that
has been around for a long time,

00:38:10.130 --> 00:38:14.300
so we can't check to see
if the UIView class is nil.

00:38:14.430 --> 00:38:21.270
And so we can't check to see if the
add motion effect method is nil either.

00:38:21.540 --> 00:38:23.940
So maybe we just try
to execute this code.

00:38:24.170 --> 00:38:28.660
Well, on iOS 7 that would work,
but on iOS 6 we would crash.

00:38:28.850 --> 00:38:31.400
Not the best user experience.

00:38:31.550 --> 00:38:35.830
So instead, we need to check to see if
the method itself exists.

00:38:35.830 --> 00:38:40.160
And we do that using a special
method on every NS object

00:38:40.640 --> 00:38:43.410
called responds to selector.

00:38:43.670 --> 00:38:48.210
Response to selector is a great way
that you can check to see if any method

00:38:48.210 --> 00:38:50.390
at all exists on a particular object.

00:38:50.420 --> 00:38:55.620
So here we're going to check
to see if our UI view has a

00:38:55.640 --> 00:38:57.750
method called add motion effect.

00:38:57.780 --> 00:39:01.030
If it does, then it's safe to call it.

00:39:01.100 --> 00:39:03.770
And if it does not,
we obviously shouldn't.

00:39:03.800 --> 00:39:10.240
So using the response to selector
check is the best way to adopt new

00:39:10.240 --> 00:39:14.820
methods while still maintaining
backwards compatibility with

00:39:14.820 --> 00:39:18.670
older operating systems where
those methods may not be present.

00:39:20.430 --> 00:39:22.130
So adopting new capabilities.

00:39:22.360 --> 00:39:25.020
What do I mean by a capability?

00:39:25.030 --> 00:39:29.700
A capability is something that is not
necessarily tied to any particular

00:39:29.700 --> 00:39:32.560
version of the operating system itself.

00:39:32.810 --> 00:39:40.200
So for example, with the new M7 motion
coprocessor in the iPhone 5S,

00:39:40.480 --> 00:39:44.060
You have the ability to
know whether the user is,

00:39:44.120 --> 00:39:47.180
for example,
walking or standing still or running

00:39:47.180 --> 00:39:48.680
or perhaps even in an automobile.

00:39:48.700 --> 00:39:51.250
You can even count
their steps if you like.

00:39:51.320 --> 00:39:55.980
But this is a capability that is
only available on the iPhone 5S.

00:39:55.980 --> 00:39:59.500
It is not a feature for iOS 7 in general.

00:39:59.500 --> 00:40:03.360
And so if you were riding a
game that took advantage of this

00:40:03.360 --> 00:40:07.600
ability to track the user's motion,
then you would need to check

00:40:07.610 --> 00:40:09.390
if this capability exists.

00:40:09.590 --> 00:40:13.410
Because if you tried to use
motion tracking on an iPhone 4,

00:40:13.410 --> 00:40:17.460
it wouldn't do anything,
even though it's running iOS 7.

00:40:17.460 --> 00:40:20.800
And so when we add new
capabilities like this,

00:40:20.980 --> 00:40:23.980
we also add, via API,
a way to check to see if

00:40:23.980 --> 00:40:26.380
this capability is present.

00:40:26.380 --> 00:40:30.240
So for motion tracking,
it's the isActivityAvailable class

00:40:30.240 --> 00:40:32.900
method on CM Motion Activity Manager.

00:40:34.520 --> 00:40:38.730
There are all sorts of corresponding
checks for various other system

00:40:38.730 --> 00:40:42.770
capabilities such as whether or
not you're able to send email or

00:40:42.770 --> 00:40:47.400
whether or not certain kinds of
regions are available for monitoring.

00:40:47.400 --> 00:40:51.610
You can even check to see if you
can print or if iCloud is enabled

00:40:51.610 --> 00:40:53.790
with the NS file manager API.

00:40:53.870 --> 00:40:57.460
Most of these methods simply
return a convenient Boolean and

00:40:57.460 --> 00:41:01.080
so they're very easy to use as
the condition for an if statement.

00:41:01.080 --> 00:41:04.100
So in this example,
if we wanted to use motion

00:41:04.100 --> 00:41:07.400
tracking in our games,
we simply check is motion

00:41:07.570 --> 00:41:10.830
tracking available and if it is,
then let's create our

00:41:10.890 --> 00:41:12.090
motion activity manager.

00:41:12.270 --> 00:41:14.290
If it's not, don't try to use it.

00:41:15.630 --> 00:41:20.040
So this is how we can safely adopt new
capabilities while still maintaining

00:41:20.040 --> 00:41:23.870
backwards compatibility with iOS 6.

00:41:24.510 --> 00:41:26.920
Next up, new designs.

00:41:27.030 --> 00:41:29.300
In iOS 7,
we have added a brand‑new design

00:41:29.300 --> 00:41:33.600
language to the operating system,
emphasizing the user's

00:41:33.630 --> 00:41:35.460
content over everything else.

00:41:35.460 --> 00:41:38.910
And you may have decided
that in your games,

00:41:38.910 --> 00:41:43.580
you want to have a different look
on iOS 7 than you do on iOS 6.

00:41:43.580 --> 00:41:47.430
So what's the best way to check
to see which look you should use?

00:41:47.430 --> 00:41:53.030
We've seen some developers do things
such as take the system version

00:41:53.030 --> 00:41:54.380
string and try to interpret it.

00:41:54.400 --> 00:41:57.960
And then compare it
to something like 6.1.

00:41:57.960 --> 00:42:02.930
But there's a better way to check
the operating system version number.

00:42:02.980 --> 00:42:06.960
And that's using a constant in
the foundation framework called

00:42:06.960 --> 00:42:09.390
the NS foundation version number.

00:42:09.700 --> 00:43:10.000
[ Transcript missing ]

00:43:11.920 --> 00:43:14.950
Finally, adopting new architectures.

00:43:14.950 --> 00:43:20.430
Some of you might want to take extra
advantage of the A7 CPU and GPU and

00:43:20.450 --> 00:43:27.060
perhaps hand optimize some assembly code
or simply guard some code that's only

00:43:27.060 --> 00:43:29.910
supposed to run on a 64‑bit processor.

00:43:30.920 --> 00:43:37.710
The easiest way to do that is by actually
effecting the compilation of your games.

00:43:37.810 --> 00:43:40.850
We learned earlier about how
our code is divided up into

00:43:40.850 --> 00:43:43.460
slices in our executable file.

00:43:43.460 --> 00:43:45.810
By using these sorts
of compiler directors,

00:43:45.980 --> 00:43:50.580
we can indicate which slice
we want our code to end up in.

00:43:50.700 --> 00:43:55.910
And so by using this pound if
underscore underscore LP64 directive,

00:43:55.910 --> 00:44:00.070
we can indicate that we have code
that should only end up in the

00:44:00.230 --> 00:44:03.460
64‑bit version of our executable.

00:44:03.460 --> 00:44:06.660
And thus will only ever
run on a 64‑bit device.

00:44:06.660 --> 00:44:10.770
Of course, conversely,
we can indicate that some code

00:44:10.770 --> 00:44:13.900
can only run on a 32‑bit device.

00:44:13.900 --> 00:44:18.160
This is not perhaps the most
common thing to want to do,

00:44:18.160 --> 00:44:21.160
but if this is what you are
doing in your application,

00:44:21.160 --> 00:44:27.290
this is the best way to isolate
code to only run on a 64‑bit device.

00:44:27.720 --> 00:44:30.460
So these are the ways that
we check for new features.

00:44:30.650 --> 00:44:32.360
We can check to see if symbols are nil.

00:44:32.360 --> 00:44:34.920
We can check to see if
certain methods exist.

00:44:34.920 --> 00:44:38.860
We can look at the capabilities
APIs to see if things like printing

00:44:38.860 --> 00:44:40.990
or motion tracking are available.

00:44:41.290 --> 00:44:44.620
We can check the foundation version
number to see what version of

00:44:44.630 --> 00:44:46.400
the operating system we're on.

00:44:46.590 --> 00:44:50.340
And we can also use compiler
directives to indicate that some

00:44:50.340 --> 00:44:55.560
code should only work on a 64-bit
device or only on a 32-bit device.

00:44:55.640 --> 00:44:58.900
So there are lots of different
kinds of checks that we can use.

00:44:59.170 --> 00:45:03.340
But I now want to talk
about hiding these checks.

00:45:03.390 --> 00:45:07.380
Because we could just put these
checks anywhere in our code.

00:45:07.380 --> 00:45:11.680
But if we were to do that,
just scatter these checks everywhere,

00:45:11.680 --> 00:45:15.650
we would quickly end up with
code that is kind of messy.

00:45:15.720 --> 00:45:18.220
That as we're reading it,
we've just got branches

00:45:18.320 --> 00:45:22.030
that go everywhere of,
oh, if I'm on a 64-bit device, do this.

00:45:22.160 --> 00:45:23.750
If I'm on a 32-bit device, do that.

00:45:23.830 --> 00:45:26.590
But on 64-bit,
check to see if motion tracking

00:45:26.590 --> 00:45:28.120
is available and if it is.

00:45:28.120 --> 00:45:34.280
Just all of these permutations
that would infest our code.

00:45:34.290 --> 00:45:38.680
And code that has logic like
that is not fun to work on.

00:45:39.040 --> 00:45:44.270
It is complicated and messy,
and it is difficult to understand.

00:45:44.610 --> 00:45:48.680
So let's talk now about how we
can successfully encapsulate these

00:45:48.860 --> 00:45:54.040
feature checks and hide them from
all other parts of our application so

00:45:54.220 --> 00:45:59.560
that only the parts of our app that
have to know about it actually do.

00:45:59.560 --> 00:46:04.210
The first pattern I want to talk
about is called class clusters.

00:46:04.320 --> 00:46:08.160
If you haven't heard this term before,
it's pretty easy to understand.

00:46:08.160 --> 00:46:12.930
The idea behind a class cluster is
that we have a class that has a single

00:46:13.630 --> 00:46:17.090
interface but multiple implementations.

00:46:17.610 --> 00:46:22.840
This is not some heretofore
unknown behavior of Objective C.

00:46:23.170 --> 00:46:26.060
It's really just private subclasses.

00:46:26.060 --> 00:46:27.490
We call this pattern class clusters.

00:46:27.490 --> 00:46:29.820
And you've all used class clusters.

00:46:29.820 --> 00:46:33.730
Anytime you've used an NSString or
an NSArray or even a UIButton,

00:46:33.730 --> 00:46:36.120
you've been using a class cluster.

00:46:36.120 --> 00:46:53.010
And what we do is we look at
how you're using this object.

00:46:53.010 --> 00:46:53.010
And we change the implementation of
this object or perhaps just give you a

00:46:53.010 --> 00:46:53.010
different implementation of this object
depending on how you're going to use it.

00:46:53.690 --> 00:46:57.110
So for example,
probably most of you didn't know

00:46:57.110 --> 00:47:01.350
that there were subclasses of
NSArray that are optimized for

00:47:01.640 --> 00:47:04.280
holding enormous amounts of data.

00:47:04.480 --> 00:47:07.920
It's all just an NS mutable array to you.

00:47:08.060 --> 00:47:10.850
But under the hood,
we've got a myriad of different

00:47:10.850 --> 00:47:14.640
implementations of NSArray that are
optimized for different scenarios.

00:47:14.640 --> 00:47:16.760
That's the beauty of a class cluster.

00:47:16.760 --> 00:47:20.560
You get a single interface
that's easy to understand,

00:47:20.570 --> 00:47:25.390
but many different implementations
optimized for your use case.

00:47:25.620 --> 00:47:28.380
So let's take a look at an
example of how you can use class

00:47:28.430 --> 00:47:31.640
clusters to hide feature checks.

00:47:32.380 --> 00:47:36.860
I've been alluding to this new
background download API in iOS 7.

00:47:36.860 --> 00:47:39.900
Let's say we're writing a game where
we want to use this new background

00:47:39.900 --> 00:47:43.380
download API and if it's not present,
then we'll default to our older

00:47:43.380 --> 00:47:46.540
network communication stack,
perhaps NSURL connection.

00:47:46.540 --> 00:47:50.960
We're going to create a download
controller object and this will be an

00:47:51.120 --> 00:47:53.640
object that just performs downloads.

00:47:53.680 --> 00:47:56.930
We say download this thing, pause that,
and so on.

00:47:57.500 --> 00:47:59.390
And the other,
everything else in our code

00:47:59.390 --> 00:48:02.100
is simply going to interact
with our download controller,

00:48:02.100 --> 00:48:03.880
sending messages back and forth.

00:48:04.200 --> 00:48:07.640
Simply pause this, start that,
resume this other thing,

00:48:07.640 --> 00:48:09.840
what's the progress on that, and so on.

00:48:11.700 --> 00:48:31.000
[ Transcript missing ]

00:48:32.250 --> 00:48:33.840
It's very easy to understand.

00:48:33.840 --> 00:48:37.730
We've got a constructor function for
making a new instance and then just some

00:48:37.730 --> 00:48:39.870
methods to start and pause and so on.

00:48:40.680 --> 00:48:45.340
If we look at the implementation now,
we actually really-- here's the

00:48:45.340 --> 00:48:48.340
magic-- have two private subclasses.

00:48:48.370 --> 00:48:52.230
One of these subclasses will be
specific to the NSURLSession API.

00:48:52.310 --> 00:48:54.840
That's the new background download API.

00:48:54.870 --> 00:48:59.180
And then the other subclass will
be specific to our older logic,

00:48:59.320 --> 00:49:02.160
using NSURLConnection.

00:49:02.210 --> 00:49:07.120
So that we could perform downloads
simply there in the process itself.

00:49:07.120 --> 00:49:11.580
And then when we're asked to create a
new instance of the download controller,

00:49:11.600 --> 00:49:14.800
we will check,
is the feature we want to use available?

00:49:15.010 --> 00:49:17.660
Does NSURLSession exist?

00:49:17.670 --> 00:49:21.340
If it does,
we'll actually allocate the subclass

00:49:21.520 --> 00:49:24.560
that's specific to NSURLSession.

00:49:24.570 --> 00:49:27.900
If it doesn't exist,
then we'll default to the older

00:49:27.900 --> 00:49:32.100
API and give you the download
controller that can perform downloads

00:49:32.100 --> 00:49:35.710
using the older NSURLConnection code.

00:49:35.920 --> 00:49:38.020
That's all there is to it.

00:49:38.050 --> 00:49:43.950
Now-- So we can perform downloads
all across our games and not care how

00:49:43.950 --> 00:49:47.140
they're actually being downloaded.

00:49:47.200 --> 00:49:49.000
Could be being downloaded in process.

00:49:49.000 --> 00:49:51.260
It could be being
downloaded out of process.

00:49:51.390 --> 00:49:52.000
We don't care.

00:49:52.000 --> 00:49:56.760
We have successfully abstracted
this check to only a single

00:49:56.760 --> 00:49:58.780
part of our application.

00:49:58.800 --> 00:50:03.230
And what this means is that when we
decide to drop support for iOS 6,

00:50:03.400 --> 00:50:06.830
we don't need our
NSURLConnection code anymore.

00:50:06.840 --> 00:50:10.330
So instead of having to dig across--
every part of our application and

00:50:10.440 --> 00:50:13.740
find every place where we were
ever using an NSURLConnection,

00:50:13.930 --> 00:50:19.600
instead, we simply delete a few lines
of code and we're done.

00:50:19.890 --> 00:50:32.560
Dave DeLoong:
That's how class clusters can

00:50:32.560 --> 00:50:37.200
help hide checks related to
new frameworks and classes,

00:50:37.460 --> 00:50:41.310
new capabilities,
even new architectures and designs.

00:50:41.380 --> 00:50:53.070
Now, another approach that we could
take is to use a data source.

00:50:53.070 --> 00:50:53.070
So class clusters solve
this by using subclasses,

00:50:53.070 --> 00:50:53.070
and data sources solve
this by using composition.

00:50:53.260 --> 00:50:58.670
A data source object would then be
another object that encapsulates

00:50:58.670 --> 00:51:02.420
all of the peculiarities of
a particular API and then you

00:51:02.600 --> 00:51:05.350
simply interact with this wrapper,
so to speak.

00:51:05.420 --> 00:51:10.230
So again, now let's say that we want our
download controller to instead

00:51:10.230 --> 00:51:14.250
of being a class cluster,
use a data source to perform downloads.

00:51:14.480 --> 00:51:18.920
Again, we have the exact same interface
for our download controller.

00:51:18.950 --> 00:51:22.740
That's the beauty of these patterns is
that we can change the implementation

00:51:22.740 --> 00:51:26.620
wholesale and only one part of
our application has to change.

00:51:26.620 --> 00:51:28.690
So here's our download
controller interface,

00:51:28.690 --> 00:51:30.360
the exact same thing it was before.

00:51:30.360 --> 00:51:32.840
I literally just copied the slide.

00:51:32.840 --> 00:51:36.090
But our implementation
is a bit different.

00:51:36.090 --> 00:51:40.010
Instead of having subclasses,
now our download controller has

00:51:40.100 --> 00:51:42.010
a property to another object.

00:51:42.880 --> 00:51:46.640
In this case, I've made it conform to
a TT downloader protocol.

00:51:46.640 --> 00:51:49.760
This would be a protocol
that simply defines a start,

00:51:49.760 --> 00:51:53.120
a pause, resume method, and so on.

00:51:53.120 --> 00:51:56.420
And then in the construction
of our download controller,

00:51:56.420 --> 00:52:00.720
instead of allocating a different
subclass of our download controller,

00:52:00.720 --> 00:52:04.400
we would allocate a different
downloader data source.

00:52:06.420 --> 00:52:11.030
If we're wanting to perform
downloads with our NSURLSession API,

00:52:11.050 --> 00:52:13.790
we check to see if NSURLSession exists.

00:52:13.830 --> 00:52:19.860
If it does, we can create a data source
specific to NSURLSession.

00:52:20.150 --> 00:52:22.610
If it does not exist,
we would create a data source that

00:52:22.610 --> 00:52:25.580
performs downloads with NSURL connection.

00:52:25.580 --> 00:52:29.540
And then we would finish the allocation
of our download controller by saying

00:52:29.790 --> 00:52:32.600
here's the data source to use.

00:52:32.600 --> 00:52:38.440
Then when we ask our download controller
to pause or start or resume a download,

00:52:38.440 --> 00:52:41.540
instead of implementing
that logic itself,

00:52:41.590 --> 00:52:45.040
it simply turns around
and asks its data source,

00:52:45.040 --> 00:52:46.660
how do I actually do that?

00:52:46.660 --> 00:52:52.900
And it's the data source that implements
the peculiarities of each of those APIs.

00:52:52.900 --> 00:52:57.590
And again, like with a class cluster,
it is totally trivial to

00:52:57.590 --> 00:53:00.690
remove unnecessary code
that we don't need anymore.

00:53:00.820 --> 00:53:05.610
So when we drop support for iOS 6 and
we don't need NSURL connection anymore,

00:53:05.680 --> 00:53:08.760
we simply delete a few lines of code.

00:53:08.760 --> 00:53:10.480
That's all there is to it.

00:53:12.680 --> 00:53:17.730
So class clusters and data sources
are great ways to encapsulate

00:53:17.750 --> 00:53:21.490
feature checks for new classes,
new capabilities,

00:53:21.570 --> 00:53:23.480
new architectures and so on.

00:53:23.480 --> 00:53:27.040
But they don't work very
well for new methods.

00:53:27.060 --> 00:53:29.820
It's really hard to build a class
cluster around a new method.

00:53:29.820 --> 00:53:31.400
It's gross.

00:53:31.400 --> 00:53:32.290
Don't do that.

00:53:33.340 --> 00:53:35.780
Instead, let's use a category.

00:53:35.810 --> 00:53:39.160
Now,
if you're not familiar with a category,

00:53:39.320 --> 00:53:42.530
in Objective C,
we have the ability to add

00:53:42.530 --> 00:53:45.900
methods to other people's classes.

00:53:45.900 --> 00:53:49.390
So, for example, in your apps,
if you really wished that NSString had

00:53:49.390 --> 00:53:53.900
some extra methods that you needed that
were unique to the needs of your app,

00:53:53.950 --> 00:53:57.180
with a category,
you can add those methods

00:53:57.180 --> 00:53:59.180
to NSString directly.

00:53:59.320 --> 00:54:04.760
And this ability to add methods to other
people's classes makes it very easy

00:54:04.760 --> 00:54:08.960
to encapsulate method checks as well.

00:54:08.960 --> 00:54:12.300
So let's go back to that example that
we saw earlier with motion effects.

00:54:12.300 --> 00:54:20.290
We know that if we just invoke add motion
effect on iOS 6 that our app will crash.

00:54:20.290 --> 00:54:20.290
Not what we want, of course.

00:54:20.700 --> 00:54:25.310
And we also know that the correct way to
solve this is by using that response to

00:54:25.420 --> 00:54:27.980
selector method that we learned about.

00:54:27.980 --> 00:54:31.120
But we want to keep this
code easy to understand.

00:54:31.120 --> 00:54:34.210
We don't want to put the
check here because that adds

00:54:34.320 --> 00:54:35.980
complexity to this code.

00:54:36.090 --> 00:54:38.720
We want to abstract it
out a little bit more.

00:54:38.920 --> 00:54:43.130
So we're going to create a category
that adds a new method to UI view.

00:54:43.350 --> 00:54:48.190
This method will be named very similarly
to the actual method that we care about,

00:54:48.300 --> 00:54:50.580
just with a different name.

00:54:50.600 --> 00:54:53.980
We're going to use a little prefix
so that we know that it's our method.

00:54:53.980 --> 00:54:58.830
And then the implementation of
this performs the check for us.

00:55:01.450 --> 00:55:03.410
does response to selector.

00:55:03.410 --> 00:55:06.910
If it actually does exist,
then we can continue on.

00:55:06.910 --> 00:55:09.580
If our add motion effect
method does not exist,

00:55:09.580 --> 00:55:12.800
then we'll just drop this message
on the floor and do nothing.

00:55:12.800 --> 00:55:16.290
So now instead of having our
response to selector checks

00:55:16.510 --> 00:55:21.200
scattered throughout our code,
our code just looks like this.

00:55:21.200 --> 00:55:23.220
We have our new custom
method that we use.

00:55:23.220 --> 00:55:26.940
And now we do not have to care
whether the add motion effect

00:55:26.940 --> 00:55:29.210
method actually exists or not.

00:55:29.740 --> 00:55:31.380
That logic is abstract.

00:55:31.400 --> 00:55:34.020
It's abstracted away
from this calling code,

00:55:34.020 --> 00:55:35.810
and it is totally opaque to us.

00:55:35.830 --> 00:55:38.190
We don't have to care.

00:55:38.520 --> 00:55:40.740
Now you may be thinking, well,
instead of just scattering

00:55:40.740 --> 00:55:43.640
this if check everywhere,
we've scattered this TT underscore

00:55:43.660 --> 00:55:45.720
add motion effect method everywhere.

00:55:45.720 --> 00:55:47.400
Isn't that kind of the same thing?

00:55:47.400 --> 00:55:48.590
Well, not really.

00:55:48.610 --> 00:55:52.160
This is much easier to get rid
of when we don't need it anymore.

00:55:52.160 --> 00:55:55.570
Simply by using the refactor
rename tool in Xcode,

00:55:55.790 --> 00:56:00.500
we can, within a matter of seconds,
remove all traces of this method

00:56:00.500 --> 00:56:02.920
once we don't need it anymore.

00:56:02.920 --> 00:56:06.980
We simply rename it to the actual
method it's supposed to be,

00:56:07.060 --> 00:56:08.450
add motion effect.

00:56:08.450 --> 00:56:11.420
This takes literally about three seconds,
and when it's done,

00:56:11.420 --> 00:56:14.680
we can safely delete the category
because we won't need it anymore.

00:56:14.680 --> 00:56:18.960
So categories are a great
way to encapsulate feature

00:56:18.970 --> 00:56:21.690
checks related to new methods.

00:56:21.780 --> 00:56:27.600
I want to close by talking about
the concept of backporting features.

00:56:30.300 --> 00:56:32.790
Many of the things that we've
been talking about are things

00:56:32.840 --> 00:56:37.060
that can be easily approximated
on an older operating system.

00:56:37.060 --> 00:56:39.470
So, for example,
the concept of downloads.

00:56:39.500 --> 00:56:43.620
On iOS 7, we have this fantastic
background download API.

00:56:43.620 --> 00:56:46.950
Now, we couldn't do background
downloads on iOS 6,

00:56:46.960 --> 00:56:51.190
and it's impossible to do that yourself,
but we can get pretty close by

00:56:51.430 --> 00:56:54.110
approximating this with NSURL connection.

00:56:54.230 --> 00:56:57.490
We can still perform downloads,
just not background downloads.

00:56:57.510 --> 00:57:00.150
So, in that case,
it's worth your time to invest in this.

00:57:00.200 --> 00:57:04.160
It's best making that capability
work on an older operating system.

00:57:04.160 --> 00:57:07.540
But I do not recommend trying
to reimplement the game

00:57:07.540 --> 00:57:10.020
controller framework for iOS 6.

00:57:11.280 --> 00:57:13.690
That's just way too much work.

00:57:13.700 --> 00:57:17.720
So when it comes to
larger features like this,

00:57:17.930 --> 00:57:22.920
It's okay to leave out support for that
feature on an older operating system.

00:57:23.020 --> 00:57:26.920
Many of you do this already when it
comes to the performance of your games.

00:57:27.000 --> 00:57:31.160
You fine‑tune the performance
and what effects you add to

00:57:31.160 --> 00:57:35.870
your OpenGL views depending on
the device that you're running.

00:57:36.520 --> 00:57:40.460
We saw, for example,
in the announcement event just

00:57:40.460 --> 00:57:45.660
a couple of months ago how
Infinity Blade takes advantage of this.

00:57:45.860 --> 00:57:49.520
On an iPhone 5S,
they're able to add a lot more

00:57:49.520 --> 00:57:53.870
effects to that dragon they demoed
because the GPU can handle that.

00:57:53.970 --> 00:57:58.360
They, of course,
would not add those effects to the

00:57:58.360 --> 00:58:01.570
same game running on an iPhone 4.

00:58:01.800 --> 00:58:04.640
We can take the same approach
with the features and

00:58:04.640 --> 00:58:06.860
capabilities of our application.

00:58:06.910 --> 00:58:09.950
If it's worth our time to invest
to make that feature work on

00:58:09.950 --> 00:58:12.100
an older operating system,
great.

00:58:12.110 --> 00:58:14.590
If it's not, let's move on.

00:58:15.550 --> 00:58:19.700
Dave DeLoong So that's a look at
how we can adopt new features of the

00:58:19.730 --> 00:58:24.370
iOS 7 SDK while still maintaining
backwards compatibility with iOS 6.

00:58:24.520 --> 00:58:26.620
You need never ask that question again.

00:58:26.620 --> 00:58:29.040
How do I adopt new features?

00:58:29.040 --> 00:58:29.870
You can do it.

00:58:29.870 --> 00:58:32.440
It is easy,
and you can do it while still keeping

00:58:32.450 --> 00:58:34.490
your code absolutely beautiful.

00:58:34.500 --> 00:58:36.940
Dave DeLoong Thank you all for coming,
and I hope you have a

00:58:37.000 --> 00:58:37.820
great rest of the day.
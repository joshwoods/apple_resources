WEBVTT

00:00:22.330 --> 00:00:25.800
Hello and welcome to Adopting
iCloud Storage — Part 2.

00:00:25.810 --> 00:00:29.170
I'm Michael Jurewitz,
the evangelist responsible for iCloud.

00:00:29.200 --> 00:00:33.570
iCloud Storage is a powerful
set of APIs for storing user

00:00:33.570 --> 00:00:35.990
documents and data in iCloud.

00:00:36.200 --> 00:00:39.670
By using iCloud,
you can make sure that your users' data

00:00:39.740 --> 00:00:45.200
is available on all of their devices,
providing a seamless user experience.

00:00:45.210 --> 00:00:47.750
In Part 1,
we took a look at the fundamentals

00:00:47.750 --> 00:00:50.650
of working with iCloud,
and how you can adopt the

00:00:50.830 --> 00:00:53.150
Key Values Store and UI document.

00:00:53.200 --> 00:00:58.090
Today, we'll take a look at how you
can use Core Data with iCloud.

00:00:58.200 --> 00:01:02.760
Next, I'll show you how your
application can store and manage

00:01:02.760 --> 00:01:05.190
individual files in iCloud.

00:01:05.200 --> 00:01:07.560
And finally,
we'll talk about some tips and

00:01:07.620 --> 00:01:11.190
tricks that everyone who works
with iCloud should know about.

00:01:11.190 --> 00:01:13.100
So let's get started.

00:01:13.670 --> 00:01:15.200
Today, we're going to break
things up a little bit.

00:01:15.200 --> 00:01:21.200
First, we're going to talk about
integrating iCloud with Core Data.

00:01:21.200 --> 00:01:23.370
Next,
we're going to take a look at working

00:01:23.370 --> 00:01:25.200
with individual files and data.

00:01:25.200 --> 00:01:28.540
And finally, we're going to finish things
up with taking a look at

00:01:28.540 --> 00:01:30.200
some iCloud tips and tricks.

00:01:30.200 --> 00:01:34.190
So let's get started with Core Data.

00:01:34.790 --> 00:01:37.990
Now, just as a refresher,
let's remind ourselves

00:01:38.090 --> 00:01:40.000
about the Core Data stack.

00:01:40.100 --> 00:01:43.290
So remember, in Core Data,
you work with things called

00:01:43.290 --> 00:01:44.800
Managed Object Contexts.

00:01:44.830 --> 00:01:49.290
You can think of these as basically
like the scratch pads for all of the

00:01:49.300 --> 00:01:53.690
different managed objects that you
happen to have in your application.

00:01:53.800 --> 00:01:57.300
All these objects, of course,
have all of their relationships to

00:01:57.380 --> 00:01:59.500
each other and hold all of your data.

00:01:59.640 --> 00:02:02.860
Now, beneath all that is
the actual store file,

00:02:02.930 --> 00:02:07.080
the SQLite file where all this
information gets written out.

00:02:07.380 --> 00:02:12.490
Sitting between these two layers is
the NS Persistent Store Coordinator.

00:02:12.610 --> 00:02:16.260
And, as the name might suggest,
its basic job is to coordinate

00:02:16.260 --> 00:02:19.940
the interactions between
these two different layers.

00:02:20.100 --> 00:02:23.930
So, with that review out of the way,
let's keep going.

00:02:24.240 --> 00:02:26.340
So Core Data, what can it do for you?

00:02:26.770 --> 00:02:29.550
Well, the answer is, quite a lot.

00:02:29.710 --> 00:02:32.000
Core Data gives you
automatic persistence,

00:02:32.000 --> 00:02:34.720
so you don't need to think about
how to write your data out.

00:02:35.010 --> 00:02:37.200
Core Data does that for you.

00:02:37.370 --> 00:02:40.720
Core Data also can provide
you automatic undo management,

00:02:40.740 --> 00:02:43.600
so you don't need to
worry about undo or redo.

00:02:43.600 --> 00:02:44.140
You can just look.

00:02:44.330 --> 00:02:46.790
Core Data help you do it.

00:02:47.100 --> 00:02:50.200
Core Data also provides
validation and error checking,

00:02:50.200 --> 00:02:53.030
so you can make sure that all
of your data remains valid in

00:02:53.030 --> 00:02:55.000
exactly the way that you expect it.

00:02:55.000 --> 00:03:00.960
And Core Data also offers seamless
merging of iCloud content.

00:03:01.000 --> 00:03:04.790
In fact, on the iCloud side,
it really is a powerful option

00:03:04.890 --> 00:03:06.850
for you to take advantage of.

00:03:07.000 --> 00:03:10.200
Core Data allows you to pick
up incremental updates and

00:03:10.290 --> 00:03:13.920
changes to all the information
as it comes over from iCloud.

00:03:15.080 --> 00:03:18.000
You also have support for
external file references,

00:03:18.000 --> 00:03:22.280
so you can take things like images,
movies, sounds, and store them outside of

00:03:22.280 --> 00:03:26.000
your database while still
integrating directly with iCloud.

00:03:26.000 --> 00:03:31.000
Core Data is also a great option
for shoebox-style applications.

00:03:31.000 --> 00:03:34.350
Think of any application,
say like iPhoto or iTunes,

00:03:34.350 --> 00:03:38.000
where you're managing lots
of content or lots of media.

00:03:38.000 --> 00:03:41.960
Core Data is really well adapted
for that kind of use case.

00:03:43.000 --> 00:03:45.440
In other words,
it also provides automatic merging

00:03:45.540 --> 00:03:46.920
and updates of your content.

00:03:47.000 --> 00:03:50.000
And best of all, it's easy to adopt.

00:03:50.000 --> 00:03:54.430
But perhaps one of the most important
reasons that you'd want to consider

00:03:54.430 --> 00:03:58.960
using Core Data is how it handles
differences that come in from iCloud.

00:03:59.000 --> 00:04:02.860
And it does so using something
called a three-way merge.

00:04:03.000 --> 00:04:07.990
So let's talk a bit about exactly
what a three-way merge actually is.

00:04:08.000 --> 00:04:12.000
So if we start off with some content,
say some address book content.

00:04:12.030 --> 00:04:18.000
Here we've got John Doe with an
email address of john@apple.com.

00:04:18.650 --> 00:04:20.900
On one device,
if we go and make a change,

00:04:20.930 --> 00:04:25.150
say like making the first name Johnny,
and then on that same device

00:04:25.150 --> 00:04:28.210
make a change a little bit later,
say by changing the

00:04:28.210 --> 00:04:31.180
last name to Appleseed,
that's all well and good.

00:04:31.180 --> 00:04:33.340
We've only made one change on one device.

00:04:33.340 --> 00:04:37.380
Now, if on a second device we
had made a different change,

00:04:37.380 --> 00:04:41.730
say like changing the email
address to johnny at apple.com,

00:04:41.730 --> 00:04:45.180
we would actually have
a bit of a problem here.

00:04:46.000 --> 00:04:48.910
Because of the way that iCloud
likes to manage conflicts and

00:04:48.910 --> 00:04:51.740
fold this information together,
if you were using

00:04:51.740 --> 00:04:54.920
something like UIDocument,
you would have had several file

00:04:55.090 --> 00:04:56.860
conflicts to have to resolve.

00:04:56.900 --> 00:05:01.940
However, Core Data can look at all of
these changes and look back at

00:05:01.940 --> 00:05:05.960
the ancestor of all of these,
the original John Doe,

00:05:05.990 --> 00:05:10.480
john at apple.com entry,
and basically figure out how to fold

00:05:10.670 --> 00:05:15.260
all of these differences together to
just end up with the right result.

00:05:15.890 --> 00:05:20.610
It really is a powerful way for
you to take advantage of iCloud.

00:05:21.750 --> 00:05:24.550
Core Data also helps you write less code.

00:05:24.770 --> 00:05:28.490
It handles all of the basics
of iCloud integration for you,

00:05:28.570 --> 00:05:32.000
so you don't need to worry about
working with NS File Coordinator,

00:05:32.140 --> 00:05:36.590
NS File Presenter, NS Metadata Query,
or NS File Version.

00:05:36.600 --> 00:05:40.460
If any of these classes or
protocols are unfamiliar to you,

00:05:40.780 --> 00:05:41.600
that's okay.

00:05:41.600 --> 00:05:44.360
We're going to talk about them a
whole bunch a little bit later.

00:05:44.600 --> 00:05:49.590
So let's look at how Core Data actually
integrates with iCloud.

00:05:49.600 --> 00:05:53.500
As your application writes
to its Core Data store file,

00:05:53.660 --> 00:05:57.300
Core Data is going to automatically
create transaction logs for

00:05:57.300 --> 00:05:59.600
you in your Ubiquiti container.

00:05:59.600 --> 00:06:03.590
And this is the data that
actually moves between devices.

00:06:03.600 --> 00:06:08.520
So if we look at how this works,
if you save a document, say,

00:06:08.520 --> 00:06:13.440
on your iPhone by calling NS Managed
Object Context "save," this creates

00:06:13.480 --> 00:06:15.530
a series of transaction logs.

00:06:15.640 --> 00:06:17.600
These transaction logs go up to iCloud.

00:06:17.600 --> 00:06:23.600
And then end up getting distributed
out to all of the rest of your devices.

00:06:23.800 --> 00:06:26.530
Now, on another device,
if you also make some edits

00:06:26.530 --> 00:06:30.530
and call "save," these new
transaction logs will get created.

00:06:30.940 --> 00:06:32.600
They go back up to iCloud.

00:06:32.600 --> 00:06:36.600
And then they get redistributed
out to all of your devices,

00:06:36.720 --> 00:06:38.590
helping to keep your data up to date.

00:06:38.600 --> 00:06:39.600
So Core Data is a very useful tool.

00:06:40.420 --> 00:06:43.820
Now Core Data Transaction Logs
are great because they're simple,

00:06:44.080 --> 00:06:46.910
they're efficient,
and they allow for completely

00:06:47.060 --> 00:06:50.310
recreating your data,
because they are a complete

00:06:50.470 --> 00:06:54.880
history of every single change
you've made to your database.

00:06:55.820 --> 00:06:57.360
So how do you get started?

00:06:57.500 --> 00:06:59.500
Well, it turns out it's really easy.

00:06:59.900 --> 00:07:02.960
There are a couple persistent
store options that you need to

00:07:02.960 --> 00:07:06.160
add to your persistent store,
and basically just one

00:07:06.160 --> 00:07:09.700
notification that you need to
make sure that you subscribe to.

00:07:09.700 --> 00:07:14.210
So the two options you need to add
to your store are the NS Persistent

00:07:14.210 --> 00:07:19.260
Store Ubiquitous Content Name Key —
we'll just call this the Name Key from

00:07:19.260 --> 00:07:24.330
now on — and the NS Persistent
Store Ubiquitous Content URL Key,

00:07:24.330 --> 00:07:27.310
which we'll just call the URL Key.

00:07:27.520 --> 00:07:31.120
Now the notification that you want to
make sure that you subscribe to is the

00:07:31.210 --> 00:07:37.540
NS Persistent Store Did Import Ubiquitous
Content Changes notification.

00:07:38.440 --> 00:07:42.300
So let's talk about working
with the Name Key and URL Key.

00:07:42.300 --> 00:07:47.300
Now the Name Key is a required attribute,
and basically this is just a way for you

00:07:47.300 --> 00:07:50.300
to uniquely identify your store file.

00:07:50.300 --> 00:07:52.300
And the emphasis here is unique.

00:07:52.300 --> 00:07:55.540
If you have several store
files in your application and

00:07:55.540 --> 00:07:59.130
they all want to use iCloud,
you need to make sure they

00:07:59.130 --> 00:08:01.210
all have different Name Keys.

00:08:01.300 --> 00:08:05.080
Now the URL Key basically just
indicates where you would like

00:08:05.080 --> 00:08:09.300
these transaction logs to be
saved in your Ubiquiti container.

00:08:09.300 --> 00:08:13.300
This is not a required key,
but we do recommend setting it.

00:08:13.300 --> 00:08:15.700
So, for example,
pick a directory in your Ubiquiti

00:08:15.840 --> 00:08:21.190
container that you'd like to use,
and supply this location as the URL Key.

00:08:23.920 --> 00:08:27.800
Now, actually using these keys in
practice is pretty straightforward.

00:08:28.060 --> 00:08:30.800
Anytime you go to create
your persistent store,

00:08:30.800 --> 00:08:33.800
you pass into it an options dictionary.

00:08:33.800 --> 00:08:38.560
All that you need to do is make sure
that you supply entries for the name

00:08:38.560 --> 00:08:43.800
key and the URL key if you want to
use iCloud with your Core Data store.

00:08:43.930 --> 00:08:47.850
Here we've provided a unique name,
as well as a path to

00:08:47.850 --> 00:08:49.800
our transaction logs.

00:08:49.800 --> 00:08:53.800
Now, normally this options dictionary
also contains other options.

00:08:53.800 --> 00:08:57.960
Things like the NS Migrate Persistent
Stores Automatically option,

00:08:57.960 --> 00:09:01.780
or the NS Infer Mapping
Model Automatically option.

00:09:01.840 --> 00:09:04.800
You want to make sure that
you keep those in there.

00:09:04.800 --> 00:09:06.800
And that's really all you have to do.

00:09:06.800 --> 00:09:10.630
By just supplying those two keys,
you've told Core Data everything

00:09:10.630 --> 00:09:14.800
that it needs to know to begin
taking advantage of iCloud.

00:09:15.660 --> 00:09:18.380
So let's take a look at how this works.

00:09:18.530 --> 00:09:21.300
When you're storing these files
in your Ubiquiti container,

00:09:21.460 --> 00:09:24.250
there are a few things that we recommend.

00:09:24.450 --> 00:09:27.040
First and foremost,
we recommend that you create

00:09:27.040 --> 00:09:32.340
in your Ubiquiti container a
folder that ends in .nosync,

00:09:32.460 --> 00:09:37.180
and that this is where you
place your Core Data store file.

00:09:37.300 --> 00:09:41.440
Now it's important to place your store
file here for a number of reasons.

00:09:41.580 --> 00:09:45.940
One, if the user signs out of iCloud,
you want to make sure that that store

00:09:45.940 --> 00:09:49.340
file stays in your Ubiquiti container.

00:09:49.500 --> 00:09:53.660
The second is that you want to make sure
that this store file isn't trying to be

00:09:53.660 --> 00:09:59.300
synced directly to the iCloud servers,
and that's what the .nosync extension

00:09:59.400 --> 00:10:01.570
does at the end of that folder.

00:10:01.730 --> 00:10:04.670
You'll also notice in your Ubiquiti
container that you've got the

00:10:04.720 --> 00:10:09.320
directory where you asked Core Data to
store your transaction logs.

00:10:10.190 --> 00:10:14.540
Now, when a change comes in from iCloud,
essentially what happens

00:10:14.540 --> 00:10:18.200
is a new transaction log
is added to that directory.

00:10:18.320 --> 00:10:21.700
Core Data automatically
notices this fact,

00:10:21.860 --> 00:10:25.940
imports that content directly
into your store file,

00:10:26.040 --> 00:10:30.820
and then notifies your application
that this content was imported.

00:10:30.900 --> 00:10:35.580
This gives you a chance to react to that,
update your user interface,

00:10:35.810 --> 00:10:37.490
tell the user, etc.

00:10:38.310 --> 00:10:40.640
Now,
one of the most interesting things about

00:10:40.640 --> 00:10:45.340
setting up your Core Data storage in
this way is that when you go to set up,

00:10:45.340 --> 00:10:48.100
say, a brand new device,
when you first access

00:10:48.110 --> 00:10:51.100
your Ubiquiti container,
you'll find that there are a

00:10:51.100 --> 00:10:52.940
bunch of transaction logs there.

00:10:52.940 --> 00:10:56.400
But you won't have an
existing Core Data store file.

00:10:56.720 --> 00:11:00.000
Well, Core Data can specifically
notice this case,

00:11:00.000 --> 00:11:03.680
and when you go to create your
store file for the first time,

00:11:03.680 --> 00:11:08.610
it'll actually read in any existing
transaction logs and automatically

00:11:08.680 --> 00:11:12.660
recreate that store file for you,
complete with its content.

00:11:15.900 --> 00:11:20.700
So let's take a look at how to deal
with changes that come in from iCloud.

00:11:20.750 --> 00:11:23.300
I mentioned before that
there's this NS Persistence

00:11:23.300 --> 00:11:27.900
Store Did Import Ubiquitous
Content Changes notification.

00:11:28.030 --> 00:11:32.010
And this is going to be the notification
that Core Data calls anytime there's

00:11:32.010 --> 00:11:34.800
new content that's come in from iCloud.

00:11:34.860 --> 00:11:38.540
Your application wants to watch
for this notification and make

00:11:38.640 --> 00:11:43.600
sure that it merges any changes
into your managed object context.

00:11:43.680 --> 00:11:46.940
This is also the perfect opportunity
for you to ask any views that

00:11:46.940 --> 00:11:51.500
might be affected by these
changes to refresh their content.

00:11:52.710 --> 00:11:56.700
Now, this notification that comes in
also has a lot of information

00:11:56.700 --> 00:11:58.280
passed along with it.

00:11:58.430 --> 00:12:01.860
In particular,
the notification object will identify

00:12:01.860 --> 00:12:06.140
the specific persistent store
that was affected by this import.

00:12:06.240 --> 00:12:09.520
So if you have multiple
stores in your application,

00:12:09.520 --> 00:12:12.310
you'll know exactly which one updated.

00:12:12.760 --> 00:12:17.130
The User Info Dictionary also includes
a lot of other useful information,

00:12:17.140 --> 00:12:20.290
in case you need to make use
of that in your application.

00:12:20.710 --> 00:12:25.540
You'll get a chance to know
which objects were inserted — so

00:12:25.540 --> 00:12:27.600
basically which ones were created
— which objects were updated,

00:12:27.670 --> 00:12:30.290
and which objects were deleted.

00:12:31.970 --> 00:12:35.940
Now, when merging changes from iCloud,
you simply want to write some code

00:12:35.980 --> 00:12:39.990
that looks a little bit like this:
You've subscribed to the NS Persistent

00:12:40.060 --> 00:12:43.800
Store Did Import Ubiquitous
Content Changes notification.

00:12:43.800 --> 00:12:48.790
And when your notification gets called,
you want to turn right back around,

00:12:48.790 --> 00:12:53.350
and on your Manage Object Context,
you want to call "Merge Changes from

00:12:53.560 --> 00:12:59.800
Context Did Save Notification" and
just pass in the notification object.

00:12:59.840 --> 00:13:01.800
Core Data will take care of the rest.

00:13:01.800 --> 00:13:05.110
It'll look at what's changed,
and make sure that your Managed

00:13:05.290 --> 00:13:08.800
Object Context reflects that information.

00:13:10.080 --> 00:13:12.420
After you've done that,
you want to make sure that you

00:13:12.420 --> 00:13:16.700
give the rest of your application a
chance to respond to these changes.

00:13:16.770 --> 00:13:19.440
In this case,
we're creating our own notification,

00:13:19.440 --> 00:13:23.040
just called "Refresh
All Views," and we're posting

00:13:23.190 --> 00:13:25.240
that within our application.

00:13:25.400 --> 00:13:28.840
Any of our view controllers that
happen to be on screen would want

00:13:28.840 --> 00:13:32.420
to listen for this notification,
and then potentially go

00:13:32.420 --> 00:13:34.630
and refresh their content.

00:13:36.610 --> 00:13:38.900
Now, when it comes to merging
content from iCloud,

00:13:38.900 --> 00:13:42.300
we have some recommendations
on how you should do that.

00:13:42.420 --> 00:13:46.810
The first is to make sure that
you have a merge policy set on

00:13:46.810 --> 00:13:49.420
your Managed Object context.

00:13:49.540 --> 00:13:52.540
So, what is a merge policy?

00:13:52.660 --> 00:13:57.080
Well, as you're going and you're changing
content in your Managed Object context,

00:13:57.210 --> 00:14:00.340
when you go to save,
that context is going to

00:14:00.340 --> 00:14:03.510
look at your database,
and it's going to look at the state

00:14:03.520 --> 00:14:05.700
of the information in that database.

00:14:05.800 --> 00:14:09.810
And if it can tell that it looks
like things may have changed out from

00:14:09.850 --> 00:14:14.200
under you while you're manipulating
all the information in memory,

00:14:14.310 --> 00:14:17.530
by default,
Core Data will throw an error.

00:14:17.700 --> 00:14:20.940
Now, in the case of iCloud,
this is exactly what happens when

00:14:20.940 --> 00:14:23.020
new content comes in from iCloud.

00:14:23.150 --> 00:14:27.820
Core Data updates the database
automatically underneath you.

00:14:27.910 --> 00:14:31.560
So, you're not going to want to use
something like the default merge policy,

00:14:31.560 --> 00:14:34.460
which is the error merge policy.

00:14:34.530 --> 00:14:39.020
In this case, case, when you go to save,
you'll just get an error that comes back.

00:14:39.220 --> 00:14:43.240
Instead,
we recommend setting the NS Merge by

00:14:43.420 --> 00:14:46.700
Property Object Trump Merge Policy.

00:14:46.940 --> 00:14:50.590
Now, you might be saying, "Wait,
what does that mean again?" Well,

00:14:50.600 --> 00:14:52.880
let's kind of break this down,
because it's actually a little more

00:14:52.880 --> 00:14:54.900
straightforward than it might seem.

00:14:55.130 --> 00:14:57.600
So, Merge by Property.

00:14:57.800 --> 00:15:02.500
What this is saying is, as your Managed
Object Context goes to save,

00:15:02.640 --> 00:15:06.100
it should take a look at every
single object that is changed,

00:15:06.340 --> 00:15:09.400
and check it against its
state in the database,

00:15:09.670 --> 00:15:15.300
property by property, as opposed to, say,
only looking at the entire object.

00:15:15.630 --> 00:15:18.100
Now, Object Trump.

00:15:18.410 --> 00:15:23.530
What this means is that the state of
the object in memory is what should win.

00:15:23.730 --> 00:15:24.600
Now, this makes sense.

00:15:24.600 --> 00:15:28.150
This is usually what the user has
most recently ended up changing.

00:15:28.470 --> 00:15:32.300
So, you want that data to be
saved to your database.

00:15:32.300 --> 00:15:36.000
The opposite of this is the
Store Trump Merge Policy.

00:15:36.000 --> 00:15:42.200
So, again, we recommend setting Merge by
Property Object Trump Merge Policy.

00:15:43.950 --> 00:15:47.000
Now, when it comes to managing multiple
versions of your application,

00:15:47.000 --> 00:15:49.800
you basically do that like you
always have with Core Data.

00:15:49.800 --> 00:15:53.130
You want to make sure that you
provide version information

00:15:53.130 --> 00:15:56.800
in your Core Data model
file like you always have.

00:15:56.930 --> 00:16:01.530
So we scope your transaction logs
based on the version information

00:16:01.530 --> 00:16:03.690
in your Core Data model file.

00:16:03.870 --> 00:16:07.800
Now, the important part here is that all
this information remains scoped.

00:16:07.800 --> 00:16:12.800
So, for example, if you have an app that
updates on one device,

00:16:12.800 --> 00:16:15.410
we'll make sure that all of those
transaction logs are written into a

00:16:15.410 --> 00:16:18.800
directory specific to that app version.

00:16:18.800 --> 00:16:22.010
Now, on a second device, when the user,
say,

00:16:22.010 --> 00:16:26.800
upgrades your app at a much later time,
we'll notice this and we'll automatically

00:16:26.800 --> 00:16:32.800
migrate in any existing transaction logs
from that version of your application

00:16:32.800 --> 00:16:35.890
that happened to be on iCloud.

00:16:36.060 --> 00:16:38.630
You still, though,
want to consider some way to detect

00:16:38.630 --> 00:16:41.240
device differences in your app version.

00:16:41.360 --> 00:16:43.500
For example,
you really don't want to have

00:16:43.550 --> 00:16:46.640
your app on an iPad and your app
on the iPhone be two different

00:16:46.640 --> 00:16:48.720
versions for a long period of time.

00:16:48.730 --> 00:16:51.660
If your apps aren't able to
successfully talk to each other,

00:16:51.660 --> 00:16:53.780
that could end up being a bad situation.

00:16:54.220 --> 00:16:58.490
So, you might use something like the
Key Values Store to simply write the

00:16:58.490 --> 00:17:00.690
greatest known version of your app.

00:17:00.860 --> 00:17:04.130
And if you notice that the user's
been using an old version of your

00:17:04.130 --> 00:17:07.470
app for a long period of time,
you might want to tell them, hey,

00:17:07.470 --> 00:17:08.220
there's an update.

00:17:08.220 --> 00:17:09.490
You should probably go grab that.

00:17:09.600 --> 00:17:14.350
Now, Core Data has support for something
called External File References

00:17:14.350 --> 00:17:17.550
that's new in iOS 5,
and the upshot is basically

00:17:17.550 --> 00:17:19.660
that you want to be using them.

00:17:19.780 --> 00:17:24.020
External File References make it
easy to stop storing bindings.

00:17:24.220 --> 00:17:27.130
So, you can store your binary data
and files in your database.

00:17:27.230 --> 00:17:32.160
Best of all, Core Data handles these
seamlessly for iCloud as well.

00:17:32.320 --> 00:17:36.220
All it is is a simple checkbox
in the Core Data Modeler,

00:17:36.220 --> 00:17:39.120
and then Core Data will
automatically take any of the data

00:17:39.120 --> 00:17:42.980
you write to these attributes,
persist them to the file system,

00:17:43.120 --> 00:17:45.740
and make sure they make
their way up to iCloud.

00:17:45.800 --> 00:17:50.840
So, let's talk about some tips and tricks
for working with Core Data and iCloud.

00:17:50.920 --> 00:17:55.080
First and foremost,
make sure you place your store

00:17:55.080 --> 00:17:58.990
file in your Ubiquiti container,
but within a directory

00:17:58.990 --> 00:18:01.030
that ends in .nosync.

00:18:01.160 --> 00:18:04.850
You want to make sure that your
Core Data store file is not directly

00:18:04.850 --> 00:18:06.880
syncing with the iCloud servers.

00:18:06.940 --> 00:18:10.400
The next is to use
External File References.

00:18:10.400 --> 00:18:14.230
This is a fantastic feature,
and it's a great way for you to keep

00:18:14.230 --> 00:18:17.180
your database performance more efficient.

00:18:17.360 --> 00:18:20.880
Finally,
you want to make sure that you let

00:18:20.880 --> 00:18:23.990
iCloud content be iCloud content.

00:18:24.010 --> 00:18:24.890
So what does this mean?

00:18:24.890 --> 00:18:29.640
Well, it's tempting to want to do things
like mirror your Core Data database

00:18:29.640 --> 00:18:33.830
locally so that if a user signs out,
they still have access to it.

00:18:34.050 --> 00:18:37.280
But that really ends up only creating
more problems than it solves.

00:18:37.360 --> 00:18:40.230
What do you do when the user has
signed out for a long period of

00:18:40.230 --> 00:18:43.980
time and now has different content
than what was actually on the cloud?

00:18:43.980 --> 00:18:46.830
How do you detect this scenario,
and how do you solve it?

00:18:48.300 --> 00:18:50.050
Really,
the cleanest thing is to simply treat

00:18:50.160 --> 00:18:54.400
the user signing out of iCloud as being
just that — that they've signed out,

00:18:54.630 --> 00:18:58.300
and that all of their iCloud
content should simply stay there.

00:18:58.440 --> 00:19:01.770
Let them go ahead and
work with local content,

00:19:01.880 --> 00:19:04.400
but don't mix and match the two.

00:19:05.070 --> 00:19:07.460
Alright, so that's Core Data.

00:19:07.510 --> 00:19:12.000
Next, let's talk about working with
individual files and data.

00:19:13.620 --> 00:19:18.210
So, UI Document and Core Data do
a lot of work for you.

00:19:18.390 --> 00:19:23.000
They handle reading your data,
writing your data, updating from iCloud,

00:19:23.370 --> 00:19:25.500
and coordinating with iCloud.

00:19:25.500 --> 00:19:29.420
But perhaps you've got an app that
just needs a bit more control.

00:19:29.610 --> 00:19:33.500
Or maybe you have lots of files and data
that don't really fit a document model,

00:19:33.500 --> 00:19:35.490
or even a database model.

00:19:35.500 --> 00:19:38.250
Well, the good news is,
iCloud can still support

00:19:38.250 --> 00:19:39.490
what you want to do.

00:19:39.530 --> 00:19:41.500
Let's talk a bit more about that.

00:19:42.840 --> 00:19:45.490
So, fundamentally,
you've got your app and

00:19:45.490 --> 00:19:47.620
your Ubiquiti container,
and the files that

00:19:47.620 --> 00:19:49.040
you'd like to put there.

00:19:49.120 --> 00:19:54.080
But there's a very big problem
that you need some help in solving.

00:19:54.210 --> 00:19:59.700
So, there are going to be changes that
come in from other devices to iCloud.

00:19:59.770 --> 00:20:04.100
iCloud is going to want to update
files in your Ubiquiti container.

00:20:04.420 --> 00:20:08.530
Your app needs to be able to notice
these changes and then indicate

00:20:08.530 --> 00:20:10.730
those to the user in some way.

00:20:10.930 --> 00:20:14.990
At the same time, the user is going to be
actually using your application,

00:20:14.990 --> 00:20:17.670
making changes to these files.

00:20:17.780 --> 00:20:20.520
You're going to want to
save those files out,

00:20:20.520 --> 00:20:25.510
and have iCloud notice those,
and then send those out to other devices.

00:20:25.720 --> 00:20:28.990
But fundamentally,
now you're talking about multiple

00:20:29.120 --> 00:20:33.770
processes trying to access the
same file at the same time.

00:20:33.970 --> 00:20:39.430
One process trying to write,
while another is trying to read, is bad.

00:20:39.590 --> 00:20:44.920
How does your app know when it's safe
to either read or write to these files?

00:20:45.060 --> 00:20:47.480
iCloud is going to make
changes to these files,

00:20:47.510 --> 00:20:51.200
and then your app has to know
that it needs to go read them.

00:20:51.340 --> 00:20:55.750
How does your app know when it's
time for it to notice these changes?

00:20:56.080 --> 00:21:00.330
iCloud also needs your files
to be up-to-date on disk,

00:21:00.580 --> 00:21:03.000
so it can do conflict detection.

00:21:03.210 --> 00:21:06.280
So how does your application
know when it needs to write out

00:21:06.330 --> 00:21:07.990
the newest version of a file?

00:21:08.220 --> 00:21:11.850
Now, throughout all of this,
UIDocument and Core Data handle

00:21:11.850 --> 00:21:14.000
all of this complexity for you.

00:21:14.000 --> 00:21:18.000
So before you go and decide that these
are all problems that you want to solve,

00:21:18.000 --> 00:21:22.620
again, ask yourself,
would you just be better served working

00:21:22.620 --> 00:21:25.000
with UIDocument or with Core Data?

00:21:25.200 --> 00:21:27.950
Now, if you do want to manage
your own files and data,

00:21:27.950 --> 00:21:32.000
there are some new API as part of
iOS 5 that you can take advantage of.

00:21:32.000 --> 00:21:36.000
The first is a new class
called NSFileCoordinator.

00:21:36.000 --> 00:21:41.000
The second is a protocol
called NSFilePresenter.

00:21:41.000 --> 00:21:44.110
NSFileCoordinator helps you
handle reading and writing

00:21:44.110 --> 00:21:47.220
in a coordinated fashion,
and we'll talk a bit more about

00:21:47.220 --> 00:21:48.910
what that means in a moment.

00:21:49.000 --> 00:21:53.230
NSFilePresenter is how you can
be notified about changes to

00:21:53.230 --> 00:21:54.000
the files that you care about.

00:21:54.000 --> 00:21:58.000
So let's talk about file coordination.

00:21:58.000 --> 00:22:02.000
Fundamentally,
NSFileCoordinator is a locking mechanism.

00:22:02.000 --> 00:22:06.230
File coordination is basically
meant to prevent one process from

00:22:06.230 --> 00:22:08.820
reading while another process writes.

00:22:09.000 --> 00:22:11.840
But it's also a notification mechanism.

00:22:11.990 --> 00:22:17.040
Any writing that you might do to the
file system may cause some other process,

00:22:17.040 --> 00:22:18.640
such as iCloud, to read.

00:22:19.020 --> 00:22:21.520
Any reading that you want to
do may cause some other process

00:22:21.520 --> 00:22:23.000
to want to write out new files.

00:22:23.000 --> 00:22:27.000
want to write out new data
for you and vice versa.

00:22:27.240 --> 00:22:29.810
So when should you use File Coordinator?

00:22:30.060 --> 00:22:33.930
Well,
anytime that you're trying to do reading,

00:22:34.040 --> 00:22:41.980
creating, exporting, updating, copying,
moving and renaming,

00:22:42.140 --> 00:22:44.540
even for directories.

00:22:44.670 --> 00:22:48.790
And did I mention that UIDocument
does all of this for you?

00:22:49.130 --> 00:22:52.840
Now, when do you not need to
use NS File Coordinator?

00:22:52.860 --> 00:22:54.860
Well,
the whole point of file coordination

00:22:54.860 --> 00:22:59.830
is to use it any time you're dealing
with content in your Ubiquiti container,

00:22:59.830 --> 00:23:02.930
so that iCloud can know about
the changes that you make,

00:23:02.990 --> 00:23:04.030
and vice versa.

00:23:04.180 --> 00:23:08.190
So, for any content that isn't
in your Ubiquiti container,

00:23:08.240 --> 00:23:11.100
you don't need to use file coordinator.

00:23:11.150 --> 00:23:14.540
So this includes temporary files,
cache files,

00:23:14.540 --> 00:23:18.100
other files in your application sandbox,
etc.

00:23:18.100 --> 00:23:21.100
So what are the locking rules
that file coordinator uses?

00:23:21.100 --> 00:23:23.100
It's actually pretty straightforward.

00:23:23.100 --> 00:23:26.040
Readers don't block other readers.

00:23:26.130 --> 00:23:29.270
If you have two processors
trying to read the same file,

00:23:29.270 --> 00:23:30.750
that's totally safe.

00:23:30.900 --> 00:23:33.090
Readers do block writers.

00:23:33.200 --> 00:23:35.040
If you're in the process
of reading a file,

00:23:35.040 --> 00:23:40.330
someone else who wants to update it needs
to wait until you're finished reading.

00:23:40.830 --> 00:23:49.590
Writers block readers.

00:23:49.590 --> 00:23:49.590
Again, if you're writing to a file,
someone else needs to wait to read

00:23:49.590 --> 00:23:49.590
that file until you're finished.

00:23:49.970 --> 00:24:02.940
Writers block other writers.

00:24:04.040 --> 00:24:04.100
This is to help make sure that two
different processes don't just end up

00:24:04.100 --> 00:24:04.100
creating a bundle of random bits on disk.

00:24:04.100 --> 00:24:04.100
So writers need to wait for each other
to finish before they can write again.

00:24:04.520 --> 00:24:09.230
Now, we treat file packages atomically,
so the entire file package gets updated

00:24:09.540 --> 00:24:12.400
or read any time we read or write.

00:24:12.400 --> 00:24:17.400
And it's important to know that file
coordinators don't block themselves,

00:24:17.400 --> 00:24:20.400
so you don't have to worry about
file coordinators deadlocking.

00:24:20.400 --> 00:24:24.390
So how do you actually
create a file coordinator?

00:24:24.510 --> 00:24:28.500
Well, you do that with a method called
"initWithFilePresenters," a

00:24:28.500 --> 00:24:31.400
method on NS File Coordinator.

00:24:31.530 --> 00:24:34.920
You can pass in an
NS File Presenter to this method,

00:24:34.920 --> 00:24:36.250
or nil if you want.

00:24:36.970 --> 00:24:40.970
Typically, this is the class that is
trying to have the reading or

00:24:41.350 --> 00:24:43.400
writing done on behalf of it.

00:24:43.540 --> 00:24:48.400
This also helps us filter out
messages about your own file access.

00:24:48.400 --> 00:24:51.860
If we notice that a particular
one of your classes is trying

00:24:51.890 --> 00:24:55.560
to read or write to a file,
we won't notify it about that

00:24:55.560 --> 00:24:59.630
file changing as a result
of its own reads or writes.

00:24:59.920 --> 00:25:02.780
This also helps us break
any potential deadlocks,

00:25:02.880 --> 00:25:07.300
because now we know the different parts
of your applications and the files

00:25:07.300 --> 00:25:10.610
they may be trying to read or write to.

00:25:11.090 --> 00:25:15.040
So let's take a look at doing
some simple reading and writing

00:25:15.040 --> 00:25:17.070
with NS File Coordinator.

00:25:17.920 --> 00:25:21.240
The methods that you're going to
use the most often are these two:

00:25:21.370 --> 00:25:27.390
Coordinate Reading Item at URL and
Coordinate Writing Item at URL.

00:25:27.530 --> 00:25:30.990
Now you'll notice that both
of these methods have an end

00:25:30.990 --> 00:25:32.410
parameter that's a block.

00:25:32.520 --> 00:25:35.090
It's this "by" accessor.

00:25:35.200 --> 00:25:39.600
So what you do is you basically pass
in a block that represents the reading

00:25:39.600 --> 00:25:44.880
or the writing that you want to do,
and NS File Coordinator invokes

00:25:44.880 --> 00:25:46.180
that block.

00:25:46.520 --> 00:25:49.550
Now,
it's important to note that what gets

00:25:49.550 --> 00:25:52.280
passed into this block is a new URL.

00:25:52.670 --> 00:25:57.300
Basically, you tell us where on the file
system you want to read or write to.

00:25:57.500 --> 00:26:01.260
And between now and the time
that you actually get to

00:26:01.260 --> 00:26:05.500
do that reading or writing,
we'll try to pay attention to anything

00:26:05.500 --> 00:26:09.760
that may have caused that file or
that location to move or be renamed,

00:26:09.760 --> 00:26:15.500
and we'll pass in a new URL that
still points to a valid location.

00:26:15.610 --> 00:26:18.560
So you want to make sure that
you're using this new URL.

00:26:20.450 --> 00:26:24.080
Now, it's important to note that both
of these methods are synchronous,

00:26:24.190 --> 00:26:27.290
so you want to make sure that
you execute them as part of

00:26:27.290 --> 00:26:29.350
something like Dispatch Async.

00:26:29.570 --> 00:26:33.520
So let's take a look at a simple
example of reading a file.

00:26:33.740 --> 00:26:37.610
Here we've got a method
called ReadFromURLError.

00:26:38.080 --> 00:26:41.180
Now the first thing we do is
create a file coordinator.

00:26:41.210 --> 00:26:46.110
So NSFileCoordinator, ALEC,
"init with file presenter," and we pass

00:26:46.110 --> 00:26:51.430
in "self" because we are the object
that is trying to do this reading.

00:26:52.100 --> 00:26:56.130
Next, we simply call
coordinateReadingItemAtURL,

00:26:56.500 --> 00:27:02.300
we pass in the URL we want to read,
and we pass in the block representing

00:27:02.300 --> 00:27:05.110
the reading that we want to be done.

00:27:05.370 --> 00:27:09.240
You'll notice this block
takes that new URL parameter,

00:27:09.260 --> 00:27:13.810
and all we're doing is creating
a NSData and initing it with

00:27:13.810 --> 00:27:16.690
a contents of that new URL.

00:27:17.160 --> 00:27:20.250
This is going to go ahead
and load in that data,

00:27:20.250 --> 00:27:25.070
and then later we can simply return
that data back out to our caller.

00:27:25.360 --> 00:27:28.100
Now,
there's a very important detail here.

00:27:28.150 --> 00:27:34.690
You'll notice that we declared
this NSDataLocal with __Block.

00:27:34.810 --> 00:27:38.630
What this does is make sure that
this data local is actually passed

00:27:38.710 --> 00:27:43.010
into this block by reference,
as opposed to by copy.

00:27:43.180 --> 00:27:46.320
This way,
when we write information to this

00:27:46.320 --> 00:27:50.100
data variable as part of this block,
we still have that information

00:27:50.100 --> 00:27:54.950
available to us outside of the block,
which is why we can go ahead

00:27:55.060 --> 00:27:57.090
and just return that data.

00:27:57.430 --> 00:28:00.510
You also want to make sure along
the way that you propagate any error

00:28:00.510 --> 00:28:01.980
parameters that you might have.

00:28:02.230 --> 00:28:04.540
So you notice we took
in an error parameter,

00:28:04.700 --> 00:28:09.010
and we made sure that we
propagated that on down the stack.

00:28:09.500 --> 00:28:12.500
So what might have just happened as
we were trying to do that reading?

00:28:12.520 --> 00:28:16.510
Well, we may have had to
wait for other writers.

00:28:16.570 --> 00:28:18.840
Say, for example,
iCloud may have been trying

00:28:18.840 --> 00:28:20.100
to write to that file.

00:28:20.100 --> 00:28:22.840
We would have had to wait
for that writing to finish.

00:28:22.840 --> 00:28:26.060
The file might have
been moved or deleted,

00:28:26.060 --> 00:28:29.160
and we would have to be able
to handle that circumstance.

00:28:29.160 --> 00:28:32.780
There would have been
NS File Presenter messaging going on.

00:28:32.780 --> 00:28:34.760
We'll talk more about that in a bit.

00:28:34.760 --> 00:28:38.500
And there may have been errors
that we needed to handle.

00:28:38.500 --> 00:28:41.880
For example, a file presenter might
have had trouble updating.

00:28:42.710 --> 00:28:47.000
Let's talk about some
other file coordinator API.

00:28:47.170 --> 00:28:50.300
There's API for doing
multiple file coordination.

00:28:50.310 --> 00:28:55.200
Say, for example,
reading at a URL and writing at a URL,

00:28:55.200 --> 00:28:57.720
all as part of the same action.

00:28:57.870 --> 00:29:02.320
You would use this typically
for things like copies or moves.

00:29:02.470 --> 00:29:05.320
You'll notice that in each case,
you pass in the URL that

00:29:05.320 --> 00:29:10.630
you want to read from,
and the URL that you want to write to.

00:29:10.890 --> 00:29:14.750
As a difference,
the "by accessor" block also takes

00:29:14.800 --> 00:29:20.800
two URL parameters — basically a new
reading URL and a new writing URL.

00:29:20.800 --> 00:29:23.820
You would want to make sure
that you use those parameters as

00:29:23.820 --> 00:29:27.790
part of your block that's doing
that reading and that writing.

00:29:30.200 --> 00:29:35.100
NS File Coordinator also has a way for
you to do batched file coordination.

00:29:35.260 --> 00:29:39.070
Now, let's say that you had thousands of
files that you knew that you needed

00:29:39.090 --> 00:29:43.280
to either read from or write to,
or possibly both.

00:29:43.440 --> 00:29:47.580
Well, you can use the "Prepare
for Reading Items at URLs"

00:29:47.680 --> 00:29:51.980
method to be able to do that.

00:29:52.150 --> 00:29:57.930
In each case, you pass in an array of the
URLs that you want to work with.

00:29:58.210 --> 00:30:00.070
At the end of this,
you're going to be passed

00:30:00.120 --> 00:30:03.420
back a completion handler,
and the expectation is that you are

00:30:03.420 --> 00:30:06.100
going to invoke this completion handler.

00:30:06.330 --> 00:30:09.330
This is going to be what allows the
system to basically catch up with

00:30:09.330 --> 00:30:13.260
all the reading and the writing
that you just finished doing.

00:30:14.150 --> 00:30:18.100
Alright, so let's talk a bit
about NS File Presenter.

00:30:18.230 --> 00:30:22.330
NS File Presenter is how you can
find out what's happening with

00:30:22.330 --> 00:30:24.100
the files that you care about.

00:30:24.100 --> 00:30:28.140
Your app basically gets a chance
to say what files it happens

00:30:28.140 --> 00:30:30.100
to be showing to the user.

00:30:30.330 --> 00:30:33.900
Now, as a result,
your application also gets to participate

00:30:34.110 --> 00:30:41.100
in other processes' coordinated file
access to those particular files.

00:30:41.640 --> 00:30:44.780
Now,
when should you be an NSFile presenter?

00:30:45.000 --> 00:30:49.300
Well, anytime that you're showing an item
to the user for viewing or editing,

00:30:49.300 --> 00:30:53.500
you likely want to be a file
presenter for that file.

00:30:53.700 --> 00:30:58.470
This could be a file, a file package,
or even a directory of files.

00:30:58.470 --> 00:31:03.420
This is going to give your application
an opportunity to reload its state for a

00:31:03.420 --> 00:31:06.240
file anytime that file happens to change.

00:31:06.850 --> 00:31:11.210
It's also going to give your application
the opportunity to close that file if

00:31:11.370 --> 00:31:13.770
another process happens to delete it.

00:31:14.020 --> 00:31:17.260
And one of the things you're going
to frequently do when you're a file

00:31:17.260 --> 00:31:21.960
presenter is have to relinquish
control of that file to another

00:31:21.960 --> 00:31:24.630
process for a short period of time.

00:31:24.840 --> 00:31:28.500
Now, for all of this,
these are things that

00:31:28.500 --> 00:31:30.630
UIDocument does for you.

00:31:30.880 --> 00:31:33.670
So again,
if you can use something like UIDocument,

00:31:33.940 --> 00:31:35.570
there's a lot of value in doing so.

00:31:37.000 --> 00:31:40.900
Now, NSFilePresenter, again,
is a protocol.

00:31:40.950 --> 00:31:44.390
So you get a chance to implement
methods on your own classes,

00:31:44.420 --> 00:31:50.330
like "Presented Item Did Change,"
"Presented Item Did Move to URL," etc.

00:31:50.920 --> 00:31:54.040
And this is how your classes
will be notified when these

00:31:54.040 --> 00:31:55.890
particular events happen.

00:31:55.900 --> 00:32:00.150
You also get an opportunity to be
told when you need to do certain

00:32:00.150 --> 00:32:02.890
things in the lifecycle of your file.

00:32:02.890 --> 00:32:05.960
Save, for example,
when you really need to save that most

00:32:05.960 --> 00:32:08.810
current version of your file right now.

00:32:08.940 --> 00:32:13.280
Or perhaps that you need to
accommodate the fact that another

00:32:13.400 --> 00:32:15.870
process just deleted that file.

00:32:16.730 --> 00:32:20.840
So again, remember, it's a protocol,
not a class.

00:32:21.040 --> 00:32:24.800
And you become a file presenter
by using a couple methods on

00:32:24.800 --> 00:32:27.220
things like NSFileCoordinator.

00:32:27.380 --> 00:32:33.480
So NSFileCoordinator has a method called
AddFilePresenter and RemoveFilePresenter.

00:32:33.640 --> 00:32:38.290
There's also the InitWithFilePresenter
that we saw earlier.

00:32:38.550 --> 00:32:42.300
Now you need to make sure whenever
you add yourself as a file presenter

00:32:42.400 --> 00:32:47.400
that you also remove yourself as
a file presenter once you're done.

00:32:47.660 --> 00:32:49.400
Oftentimes, dialog is too late.

00:32:49.400 --> 00:32:51.180
You want to be doing this sooner.

00:32:51.350 --> 00:32:53.990
As an example,
UIDocument does this in close

00:32:53.990 --> 00:32:57.650
with Completion Handler,
so you should be doing the same

00:32:57.650 --> 00:33:00.390
for your own files and documents.

00:33:02.180 --> 00:33:05.600
Now, occasionally you need to be
able to relinquish your file

00:33:05.600 --> 00:33:09.500
to other readers and writers,
and there's a couple methods that'll get

00:33:09.500 --> 00:33:11.780
called when this exactly needs to happen.

00:33:11.920 --> 00:33:15.930
So you've got Relinquish Presented
Item to Reader and Relinquish

00:33:16.090 --> 00:33:17.980
Presented Item to Writer.

00:33:18.050 --> 00:33:22.340
These get called basically when
someone else wants to read or write

00:33:22.340 --> 00:33:24.690
to this file that you care about.

00:33:25.200 --> 00:33:27.260
Now,
what gets passed into this method is sort

00:33:27.260 --> 00:33:31.190
of this crazy-looking block parameter,
and we'll try to break down exactly what

00:33:31.190 --> 00:33:32.920
it is that's getting passed in here.

00:33:33.100 --> 00:33:36.520
The upshot is that what's
getting passed in is a block

00:33:36.720 --> 00:33:38.910
that you need to quickly invoke.

00:33:39.100 --> 00:33:45.360
You also get a chance to pass your
own block back into this method that

00:33:45.360 --> 00:33:49.270
represents any sort of work that you
want to be done immediately after

00:33:49.400 --> 00:33:52.100
that reading or writing takes place.

00:33:52.100 --> 00:33:54.200
So let's look at an example.

00:33:55.170 --> 00:34:00.160
So here we have a sample implementation
of relinquishPresentedItemToWriter.

00:34:00.500 --> 00:34:04.100
So the first thing you want to do
when implementing a method like this,

00:34:04.100 --> 00:34:08.210
when it gets called,
is make sure that you stop looking at

00:34:08.210 --> 00:34:10.480
the file that's about to be written to.

00:34:10.500 --> 00:34:13.440
You want to make sure that you
stop looking at any IVARs that

00:34:13.440 --> 00:34:14.900
might relate to that file.

00:34:14.900 --> 00:34:19.490
Basically, stop paying attention to
it for that moment in time.

00:34:19.860 --> 00:34:23.740
The very next thing that you need to
do is make sure that you invoke that

00:34:23.900 --> 00:34:26.480
writer block that gets passed in.

00:34:26.540 --> 00:34:31.270
Again, this is the actual unit of writing
that is about to happen to this file.

00:34:31.440 --> 00:34:34.520
This is your chance to basically
let the other process go,

00:34:34.560 --> 00:34:37.070
and you have to do this.

00:34:37.440 --> 00:34:41.220
Now, at the same time, though,
you also get a chance to pass in

00:34:41.220 --> 00:34:45.410
your own block that represents the
additional work that you want done

00:34:45.760 --> 00:34:48.290
once that writing is finished.

00:34:48.400 --> 00:34:51.780
So here we're passing in our
own block that basically is

00:34:51.800 --> 00:34:55.900
just going to tell ourselves to
stop waiting for this writer.

00:34:56.080 --> 00:34:59.720
And once that writing is finished,
that will be invoked,

00:34:59.850 --> 00:35:02.700
and we go back to normal using that file.

00:35:02.950 --> 00:35:06.720
Now, whenever you're a file presenter,
you're going to most commonly see things

00:35:06.720 --> 00:35:11.890
like "Presented item did change" or
possibly "Presented item did move to

00:35:11.890 --> 00:35:14.800
URL" get called on your file presenter.

00:35:14.980 --> 00:35:18.380
This is going to be what tells you
that a change actually happened,

00:35:18.390 --> 00:35:23.800
and it's your opportunity to catch up,
to notice this change, to update your UI.

00:35:24.030 --> 00:35:26.370
Typically,
this is going to happen while you

00:35:26.370 --> 00:35:28.800
happen to be relinquished to a writer.

00:35:28.800 --> 00:35:33.330
This is going to be your opportunity
to notice that change and make sure

00:35:33.330 --> 00:35:35.800
that all of your state is up to date.

00:35:36.380 --> 00:35:41.060
All right, so that's a bit about working
with files and data with iCloud.

00:35:41.230 --> 00:35:43.770
Finally,
let's take a look at some tips and

00:35:43.770 --> 00:35:46.500
tricks for working with iCloud.

00:35:46.710 --> 00:35:49.660
So first and foremost,
where do your files go?

00:35:49.860 --> 00:35:54.420
Where exactly should you put them
within the Ubiquiti container itself?

00:35:54.470 --> 00:35:57.420
The Ubiquiti container is
just this normal directory,

00:35:57.420 --> 00:36:00.380
and you can put things
really wherever you want.

00:36:00.430 --> 00:36:05.760
There is, however, one special directory,
and that's the Documents directory.

00:36:05.820 --> 00:36:08.500
Now,
this directory doesn't exist by default,

00:36:08.560 --> 00:36:13.700
but if you create it and you
store files into that folder,

00:36:13.770 --> 00:36:18.800
then users can actually view the file
names of the items in that directory

00:36:19.050 --> 00:36:21.880
in their iCloud Storage settings.

00:36:21.990 --> 00:36:26.330
What's more, users also have the ability
to individually delete

00:36:26.330 --> 00:36:28.180
items in that directory.

00:36:28.320 --> 00:36:31.020
So if you have items that you
don't intend for the user to

00:36:31.020 --> 00:36:33.940
be able to individually delete,
you probably don't

00:36:33.940 --> 00:36:35.220
want to put them there.

00:36:35.340 --> 00:36:38.820
You can also create any other
directories you want in your Ubiquiti

00:36:38.820 --> 00:36:40.590
container to suit your needs.

00:36:40.760 --> 00:36:44.340
These won't show up to the user,
and they only get listed

00:36:44.540 --> 00:36:46.690
basically as files and data.

00:36:47.990 --> 00:36:51.020
So how should you move a file
to your Ubiquiti container?

00:36:51.140 --> 00:36:53.470
Say you've got a file in
your application sandbox,

00:36:53.540 --> 00:36:54.280
what do you do?

00:36:54.300 --> 00:36:56.900
How do you properly move that over?

00:36:57.130 --> 00:37:02.540
Well, NS File Manager has a method
called Set Ubiquitous Item at

00:37:02.540 --> 00:37:04.900
URL Destination URL Error.

00:37:04.900 --> 00:37:09.680
So all you need to do is
basically call Set Ubiquitous Yes,

00:37:09.950 --> 00:37:12.810
pass in the URL to where
the file currently exists

00:37:12.830 --> 00:37:16.630
in your application sandbox,
and then pass in the URL in

00:37:16.630 --> 00:37:20.710
your Ubiquiti container where
you want this file to end up.

00:37:20.900 --> 00:37:24.900
NS File Manager will move this
file in a coordinated fashion,

00:37:24.900 --> 00:37:29.890
but you need to make sure that you
create any intermediary directories

00:37:29.900 --> 00:37:31.710
that you wanted ahead of time.

00:37:31.900 --> 00:37:35.890
Now it's important to note
that this method blocks,

00:37:35.890 --> 00:37:38.880
so you'll want to make sure that
you call this asynchronously,

00:37:39.020 --> 00:37:41.890
typically via something
like Dispatch Async.

00:37:41.910 --> 00:37:43.900
When you want to move files
out of your Ubiquiti container,

00:37:43.900 --> 00:37:46.900
you do something rather similar.

00:37:46.900 --> 00:37:49.900
You can think of this as basically
wanting to download an item

00:37:49.900 --> 00:37:51.830
and make a local copy of it.

00:37:51.920 --> 00:37:55.500
In this case,
you still use Set Ubiquitous

00:37:55.500 --> 00:37:59.360
Item at URL Destination URL,
but in this case,

00:37:59.420 --> 00:38:04.460
you pass in Set Ubiquitous No,
and you give the path to the item in your

00:38:04.460 --> 00:38:09.900
Ubiquiti container as the item at URL,
and as the destination URL,

00:38:09.900 --> 00:38:12.900
you give some path into
your application sandbox.

00:38:12.900 --> 00:38:13.260
sandbox.

00:38:16.250 --> 00:38:19.460
Now, as you work with iCloud,
your users are potentially going

00:38:19.460 --> 00:38:22.030
to be creating lots of files.

00:38:22.030 --> 00:38:26.780
And really, you should try to endeavor to
help them not waste disk space.

00:38:26.950 --> 00:38:29.980
You want to evict
infrequently used files.

00:38:30.460 --> 00:38:34.940
The way to think about this is that any
file that is actually in your Ubiquiti

00:38:34.940 --> 00:38:37.950
container is also being stored in iCloud.

00:38:37.950 --> 00:38:41.530
So if you see a file that
the user has not accessed in,

00:38:41.530 --> 00:38:45.740
say, a few weeks or a few months,
you can go ahead and call

00:38:45.740 --> 00:38:50.150
evict ubiquitous item at
URL on that particular file.

00:38:50.160 --> 00:38:54.910
This is a method on NS File Manager,
and what this will do is basically

00:38:54.910 --> 00:39:00.160
remove the local copy of that file,
but leave the copy on iCloud intact.

00:39:00.440 --> 00:39:04.180
hacked, so you can go and download
that the next time you need it.

00:39:05.800 --> 00:39:10.060
One of the coolest features in
iCloud is the ability to publish an

00:39:10.060 --> 00:39:12.700
item for sharing with other users.

00:39:12.920 --> 00:39:17.310
In this case,
NS File Manager has a method called

00:39:17.310 --> 00:39:23.780
URL for Publishing Ubiquitous Item at
URL . What this allows you to do is take

00:39:23.780 --> 00:39:28.700
any file in your Ubiquiti container,
publish it to the iCloud servers,

00:39:28.700 --> 00:39:32.470
and then get back a URL that
you can send to other users

00:39:32.470 --> 00:39:34.700
who want to download a copy.

00:39:34.700 --> 00:39:39.700
The important part here is that they
are downloading a copy of the file.

00:39:39.700 --> 00:39:42.760
This is not, say,
the same reference to the same

00:39:42.760 --> 00:39:44.700
file for everyone to share.

00:39:44.710 --> 00:39:47.660
This is simply the ability
for them to download a copy.

00:39:47.710 --> 00:39:47.990
The important part here is that they
are downloading a copy of the file.

00:39:47.990 --> 00:39:48.180
This is not, say,
the same reference to the same

00:39:48.180 --> 00:39:48.290
file for everyone to share.

00:39:48.310 --> 00:39:48.700
This is simply the ability
for them to download a copy.

00:39:49.650 --> 00:39:53.090
Now, when it comes to telling
the state of a file,

00:39:53.120 --> 00:39:55.820
NSURL has a lot of help to provide.

00:39:55.820 --> 00:39:58.890
You might, for example,
want to be able to show the user that

00:39:58.890 --> 00:40:03.880
a file is uploading or downloading
or what percent it may be complete.

00:40:03.880 --> 00:40:08.880
And so, NSURL has a method called
Resource Values for Keys.

00:40:08.880 --> 00:40:12.740
And there are a bunch of new keys
to find for working with iCloud.

00:40:12.740 --> 00:40:17.300
So for example, for a given item,
you can find out: Is it downloaded?

00:40:17.300 --> 00:40:18.940
Is it downloading?

00:40:18.940 --> 00:40:25.420
Is it finished going either up or down?

00:40:25.420 --> 00:40:26.740
This gives you a chance to
provide up-to-date user interfaces

00:40:27.090 --> 00:40:32.540
so your users know exactly
what's going on with their files.

00:40:34.020 --> 00:40:36.310
All right,
so we talked about working with

00:40:36.310 --> 00:40:41.190
Core Data as well as working
with individual files and data.

00:40:41.370 --> 00:40:45.140
Okay, so you saw how your Core Data app
can work with iCloud,

00:40:45.640 --> 00:40:48.960
discovered how your app can
manage individual files and

00:40:48.960 --> 00:40:53.260
data and store them to iCloud,
and you learned the tips and tricks

00:40:53.260 --> 00:40:55.180
to use iCloud to its fullest.

00:40:55.240 --> 00:40:59.150
I look forward to seeing the
great apps that you'll build

00:40:59.160 --> 00:41:01.200
that use iCloud Storage.
WEBVTT

00:00:13.260 --> 00:00:16.250
Welcome to Integrating
iOS 7 Technologies.

00:00:16.360 --> 00:00:21.450
My name is Paul Marcos, and I'm the
App Services Evangelist at Apple.

00:00:22.670 --> 00:00:26.020
Now all day we've been talking
obviously about iOS 7 and all the new

00:00:26.020 --> 00:00:30.040
technology that comes along with the
new version of the operating system.

00:00:30.080 --> 00:00:33.160
And there's a ton of
stuff that we put out.

00:00:33.240 --> 00:00:36.280
And this slide is actually pretty common.

00:00:36.290 --> 00:00:39.060
Every year we put out
a new version of iOS,

00:00:39.060 --> 00:00:41.890
and it has a whole bunch
of new technology in it.

00:00:42.030 --> 00:00:45.630
And I think one of the challenges
that app developers like you face

00:00:46.230 --> 00:00:50.020
is with every year figuring out,
how do you take this new technology

00:00:50.640 --> 00:00:52.070
and do something with it?

00:00:52.240 --> 00:00:56.040
How do you apply it in
practice in your application?

00:00:56.110 --> 00:00:58.180
Now in this session,
we're going to continue talking

00:00:58.180 --> 00:00:59.770
about some of these new technologies.

00:00:59.960 --> 00:01:01.940
I'm going to cover three new areas.

00:01:02.040 --> 00:01:07.530
And I want to do so in a way that
really helps understand how you

00:01:07.750 --> 00:01:13.380
can apply this new technology and
enhance a couple specific experiences

00:01:13.450 --> 00:01:18.270
that the people using your apps
have when they use your apps.

00:01:19.470 --> 00:01:22.540
So the three areas that I want
to talk about are first,

00:01:22.650 --> 00:01:26.140
background transfers and how
you can use that to minimize

00:01:26.140 --> 00:01:28.590
your install time of your app.

00:01:28.590 --> 00:01:31.740
Second,
I want to talk about multitasking,

00:01:31.740 --> 00:01:34.580
which John talked a little
bit about this morning,

00:01:34.580 --> 00:01:38.510
and how you can take advantage of new
APIs to make your app always be ready

00:01:38.540 --> 00:01:40.570
for when someone wants to use it.

00:01:41.910 --> 00:01:46.130
And then lastly, one of our most exciting
new technologies is iBeacon.

00:01:46.210 --> 00:01:50.480
So we'll talk about how you can use
that to really enhance the location

00:01:50.480 --> 00:01:52.970
aware app that you may be developing.

00:01:53.890 --> 00:01:57.030
So let's start off with
background transfers.

00:01:57.310 --> 00:02:02.840
And the experience that I want to focus
on here centers around this alert.

00:02:02.840 --> 00:02:05.100
I'm sure you're all
familiar with this alert,

00:02:05.130 --> 00:02:07.150
the cellular download limit alert.

00:02:07.150 --> 00:02:10.550
Your customers will see this when
they try to install your app and

00:02:10.550 --> 00:02:14.100
they're not on a Wi-Fi network if
your app is over a certain size.

00:02:14.100 --> 00:02:17.630
Now, we just raised that size from
50 megabytes to 100 megabytes,

00:02:17.630 --> 00:02:18.620
and that's great.

00:02:18.620 --> 00:02:22.500
But if you have an app that's
still over 100 megabytes,

00:02:22.530 --> 00:02:24.280
this is a problem for you.

00:02:24.310 --> 00:02:26.740
And in fact,
this is one of the most common

00:02:26.740 --> 00:02:27.180
questions that we're having.

00:02:27.200 --> 00:02:32.090
One of the questions that we get as
evangelists at Apple is how can I get my

00:02:32.090 --> 00:02:34.860
app under the cellular download limit?

00:02:34.860 --> 00:02:38.860
How can I get it under 50
megabytes or now 100 megabytes?

00:02:38.910 --> 00:02:44.090
And that's an interesting question,
but it's not really the right question.

00:02:44.100 --> 00:02:48.510
The right question that I think you
should be focusing on is how can you

00:02:48.510 --> 00:02:51.030
minimize the install time of your app?

00:02:51.680 --> 00:02:54.420
Because that's really what
matters to your users,

00:02:54.420 --> 00:02:55.080
right?

00:02:55.190 --> 00:02:58.320
From the time they tap buy or install,
in the App Store,

00:02:58.320 --> 00:02:59.930
to when they can use it.

00:03:00.060 --> 00:03:02.940
That's the important amount of time,
and that's what I want to focus on,

00:03:02.940 --> 00:03:04.670
how you can minimize that.

00:03:06.450 --> 00:03:08.800
Now in order to do that,
I have a checklist of just three

00:03:08.900 --> 00:03:11.970
simple tasks that you can perform.

00:03:12.150 --> 00:03:14.800
The first two of take
inventory and use compression,

00:03:15.120 --> 00:03:17.440
those are really actually
just best practices.

00:03:17.440 --> 00:03:20.950
So some of the things that we
hear come up time and time again

00:03:20.950 --> 00:03:22.980
when we talk with developers.

00:03:22.980 --> 00:03:25.690
And then the third one,
download things later,

00:03:25.690 --> 00:03:28.750
that's where the new
technology in iOS 7 comes in.

00:03:28.750 --> 00:03:32.440
So I'll go through all three of these,
starting with taking inventory.

00:03:32.440 --> 00:03:36.820
And what I mean by taking
inventory is I want you to perform

00:03:36.940 --> 00:03:39.440
this exercise with your app.

00:03:39.530 --> 00:03:45.080
So using iTunes,
go download your app from the iTunes,

00:03:45.080 --> 00:03:48.730
or from the App Store, excuse me.

00:03:48.730 --> 00:03:48.730
And once it's downloaded,

00:03:48.830 --> 00:03:52.200
You can go find the .IPA
file that got downloaded.

00:03:52.320 --> 00:03:55.660
And that .IPA file is really
just simply a zip file,

00:03:55.690 --> 00:04:00.700
so you can change the extension to
.zip and you can expand that archive.

00:04:00.700 --> 00:04:04.690
So now you have the files that
were delivered from the app store.

00:04:05.220 --> 00:04:08.220
In that zip archive,
you can find your actual app bundle.

00:04:08.510 --> 00:04:11.950
And using the finder show
package contents command,

00:04:12.250 --> 00:04:15.540
you can open it, and then you have access
to all your files.

00:04:15.690 --> 00:04:20.140
And what I want you to do is
review every file that's in there.

00:04:20.420 --> 00:04:23.180
Think about why is this file here?

00:04:23.530 --> 00:04:28.520
Sort this list by size, biggest first,
and go through it that way.

00:04:28.800 --> 00:04:31.200
And I think a lot of you
will be surprised by the

00:04:31.200 --> 00:04:32.890
things that you find in there.

00:04:33.000 --> 00:04:37.700
And I know that because we talk with a
lot of developers and we do exactly this,

00:04:37.860 --> 00:04:41.080
and there are a lot of really
surprising things in your applications.

00:04:41.100 --> 00:04:45.380
So we regularly will find
things like readme files.

00:04:45.380 --> 00:04:48.590
We find Photoshop documents in apps.

00:04:48.590 --> 00:04:51.300
You know,
iOS doesn't render Photoshop documents,

00:04:51.300 --> 00:04:52.340
so why is it there?

00:04:52.820 --> 00:04:56.030
We find source files,
things copied in from, you know,

00:04:56.030 --> 00:04:57.600
third party libraries.

00:04:57.600 --> 00:05:02.350
A lot of these end up in your app
bundle simply because you dragged it

00:05:02.350 --> 00:05:07.200
in Xcode and inadvertently added it
as a resource for the application.

00:05:07.200 --> 00:05:11.330
So that's really what you're trying
to identify here are files that got

00:05:11.330 --> 00:05:15.610
added as resources and now you're
shipping them through the app store.

00:05:16.330 --> 00:05:18.860
Another category of files
that we find really commonly,

00:05:18.860 --> 00:05:20.660
are just obsolete resources.

00:05:20.660 --> 00:05:23.760
So things that were there
legitimately at one point in time,

00:05:23.760 --> 00:05:26.240
but your designs have changed, right.

00:05:26.240 --> 00:05:28.350
You maybe have changed your UI.

00:05:28.450 --> 00:05:30.760
A really good example of
where this might happen,

00:05:30.760 --> 00:05:34.600
and something you should watch out for,
is you've probably all been

00:05:34.600 --> 00:05:40.060
working on an iOS 7-based design,
but you're still supporting iOS 6.

00:05:40.200 --> 00:05:44.480
But when you drop support for iOS 6,
you need to make sure that you

00:05:44.530 --> 00:05:47.420
go through your resources and
clean out all the old artwork,

00:05:47.420 --> 00:05:47.980
right.

00:05:48.040 --> 00:05:51.780
That's a really common
thing for us to see.

00:05:52.590 --> 00:05:56.180
Another place where you can get some
great space savings and just throw out

00:05:56.180 --> 00:05:58.710
some trash is in artwork like this.

00:05:58.820 --> 00:06:02.260
You might have a button
where those middle pixels,

00:06:02.320 --> 00:06:06.880
they're really just repeated
pixels stretched horizontally,

00:06:06.920 --> 00:06:10.000
and they're really just
taking up space on disk.

00:06:10.110 --> 00:06:15.450
So using Xcode 5's new slicing feature,
you can actually express that these

00:06:15.620 --> 00:06:20.530
middle pixels can be repeated,
and we can stretch that at runtime.

00:06:21.220 --> 00:06:23.680
So at build time,
what we'll do is we'll actually

00:06:23.680 --> 00:06:25.630
compress that graphic for you.

00:06:25.770 --> 00:06:28.730
And then at runtime,
we'll automatically stretch it

00:06:28.730 --> 00:06:30.820
with no performance penalties.

00:06:30.910 --> 00:06:33.850
So this first item of taking
inventory really just amounts

00:06:33.980 --> 00:06:35.880
to take out the trash,
go in your app,

00:06:35.970 --> 00:06:39.500
and get rid of all the files
that are taking up disk space

00:06:39.500 --> 00:06:41.510
that don't need to be there.

00:06:42.600 --> 00:06:45.560
Now the second one, use compression.

00:06:45.630 --> 00:06:48.340
Now more than likely
you're already doing this,

00:06:48.420 --> 00:06:50.500
but it doesn't hurt to double check.

00:06:50.580 --> 00:06:53.380
And you want to focus on the
things that take the most space,

00:06:53.550 --> 00:06:54.740
like video.

00:06:54.790 --> 00:06:58.010
You want to make sure you're
using H.264 compression.

00:06:58.090 --> 00:07:00.530
You get great compression
and space savings on disk

00:07:01.110 --> 00:07:03.680
with no sacrifice in quality.

00:07:03.930 --> 00:07:05.040
Same thing for audio.

00:07:05.230 --> 00:07:09.180
If your app has audio
tracks of any length,

00:07:09.240 --> 00:07:13.900
you want to make sure you're
using AAC or at least MP3.

00:07:13.990 --> 00:07:18.940
And for really good savings,
if you're using 44.1 kilohertz right now,

00:07:19.120 --> 00:07:23.060
consider dropping that
sample rate down to 22.05.

00:07:23.060 --> 00:07:26.150
Most users will never
even notice a difference,

00:07:26.150 --> 00:07:28.630
and you can get a good space savings.

00:07:28.940 --> 00:07:33.190
And then for images,
for photographic image content

00:07:33.200 --> 00:07:36.230
that you have in your app,
make sure that you use

00:07:36.230 --> 00:07:38.360
JPEG instead of PNGs.

00:07:38.470 --> 00:07:40.240
And let me show you an example here.

00:07:40.240 --> 00:07:41.880
So this is the Starwood app.

00:07:41.880 --> 00:07:43.100
It's a travel app.

00:07:43.150 --> 00:07:45.980
They have these beautiful
photographs of beautiful places in

00:07:46.080 --> 00:07:47.860
the world that you want to go visit.

00:07:47.860 --> 00:07:52.870
And I did a calculation on this
one where if these images were

00:07:52.870 --> 00:07:58.390
shipped as PNGs instead of JPEGs,
the app would be 20% bigger

00:07:58.390 --> 00:08:00.440
than it needed to be.

00:08:00.450 --> 00:08:01.650
That's huge.

00:08:01.650 --> 00:08:05.720
That's very easily the difference
between being over the cellular

00:08:05.720 --> 00:08:07.950
limit or under the cellular limit.

00:08:07.960 --> 00:08:11.830
And on all of our hardware now,
we can do hardware

00:08:11.830 --> 00:08:17.430
accelerated JPEG rendering,
so there's no penalty in using JPEGs.

00:08:17.840 --> 00:08:20.220
And in cases like this,
with these beautiful photographs,

00:08:20.220 --> 00:08:22.310
users aren't going to
notice a difference.

00:08:22.560 --> 00:08:25.230
Even on a retina display,
you can get great quality

00:08:25.230 --> 00:08:27.000
using JPEG and save space.

00:08:27.000 --> 00:08:30.260
So those are the first two items.

00:08:30.260 --> 00:08:34.940
And these may seem really basic,
and you may say, I'm already doing this.

00:08:35.270 --> 00:08:38.230
But we see this time and time again.

00:08:38.230 --> 00:08:40.650
So it really warrants kind
of going through it here

00:08:40.770 --> 00:08:43.640
because it is a best practice,
and I'm willing to bet that

00:08:43.640 --> 00:08:46.840
almost all of you would benefit
from these two things alone.

00:08:47.620 --> 00:08:52.620
Now, going beyond that,
this is where iOS 7 technology comes in.

00:08:52.980 --> 00:08:57.620
You could consider
downloading things later.

00:08:57.620 --> 00:09:01.780
And what I mean by that is consider
taking assets that are in your app

00:09:01.840 --> 00:09:05.280
store bundle and removing them,
separate them out,

00:09:05.280 --> 00:09:08.460
and download them at a later
point in time after the

00:09:08.460 --> 00:09:10.620
user has installed the app.

00:09:11.610 --> 00:09:14.490
Now, the important thing to note
here is that this really,

00:09:14.550 --> 00:09:16.860
this may not be right
for all applications.

00:09:16.860 --> 00:09:20.050
This is something that you
have to evaluate for your app.

00:09:20.050 --> 00:09:24.180
Simply, there's no single right
answer for how to do this.

00:09:24.180 --> 00:09:30.170
And you don't want to sacrifice a
user experience of that first install

00:09:30.170 --> 00:09:32.910
and first launch by doing this.

00:09:33.160 --> 00:09:35.470
But if you can come up with a
way to separate your assets,

00:09:35.470 --> 00:09:37.830
and I've got a couple scenarios
that we'll talk about,

00:09:37.830 --> 00:09:40.740
then this might be the right
thing for you to consider doing.

00:09:40.780 --> 00:09:42.930
And it can really
improve this experience.

00:09:42.930 --> 00:09:46.590
It does come at a cost
of complexity a bit.

00:09:46.590 --> 00:09:50.380
You may need to represent in your
UI the state of these additional

00:09:50.380 --> 00:09:52.530
files that need to be downloaded.

00:09:52.540 --> 00:09:55.980
You certainly have to handle the
case where these files are missing,

00:09:55.980 --> 00:09:56.500
right?

00:09:56.500 --> 00:10:00.520
The disk may fill up and you may have
to present to the user something that

00:10:00.520 --> 00:10:02.920
makes sense about pieces are missing.

00:10:02.920 --> 00:10:06.550
Those are scenarios that you don't
have to worry about if you include

00:10:06.550 --> 00:10:10.060
them in the app store bundle,
because from your perspective,

00:10:10.060 --> 00:10:11.860
that's an atomic operation.

00:10:11.860 --> 00:10:14.920
Either everything is there or it's not.

00:10:14.970 --> 00:10:17.660
And this certainly will
complicate your testing matrices,

00:10:17.940 --> 00:10:18.280
right?

00:10:18.280 --> 00:10:21.690
You just have more scenarios
to test to make sure that

00:10:21.690 --> 00:10:23.880
your app behaves correctly.

00:10:24.100 --> 00:11:16.300
[ Transcript missing ]

00:11:16.400 --> 00:12:36.500
[ Transcript missing ]

00:12:36.760 --> 00:12:40.280
So to accomplish this,
the new technology in iOS 7

00:12:40.280 --> 00:12:43.560
that we've introduced is the
background transfer service.

00:12:43.560 --> 00:12:46.290
So let me just give a quick
overview of what it is.

00:12:46.290 --> 00:12:53.830
Simply put, it's a service to upload and
download content in the background.

00:12:53.830 --> 00:12:57.630
And when I say background,
I don't mean like in a background

00:12:57.630 --> 00:13:00.210
thread that you create or you manage.

00:13:00.310 --> 00:13:03.880
I actually mean it's done in a
different process altogether,

00:13:03.880 --> 00:13:04.500
right?

00:13:04.500 --> 00:13:06.030
It's done in a system daemon.

00:13:06.630 --> 00:13:18.510
So it's a service to upload and
download content in the background.

00:13:18.510 --> 00:13:18.510
And the great thing about this is that
means that your app can actually be

00:13:18.510 --> 00:13:18.510
suspended or it can even be terminated,
and those background

00:13:18.510 --> 00:13:18.510
downloads will continue.

00:13:19.650 --> 00:13:23.190
Primarily, this is intended for
large amounts of data,

00:13:23.380 --> 00:13:27.140
so things that would take long
enough that you might not be

00:13:27.140 --> 00:13:32.290
able to do them in your process
before the user leaves your app.

00:13:33.730 --> 00:13:37.990
And after these transfers are done,
even if you have not been running in the

00:13:38.090 --> 00:13:41.270
foreground or your app was terminated,
your app will get relaunched in the

00:13:41.270 --> 00:13:44.080
background and then you can process
the results of these transfers.

00:13:44.080 --> 00:13:47.700
So this is just a new set of
functionality that you just

00:13:47.700 --> 00:13:50.000
simply couldn't do in iOS 6.

00:13:50.000 --> 00:13:53.120
And in order to do this,
you use a new class in

00:13:53.170 --> 00:13:55.570
iOS 7 called NSURLSession.

00:13:55.580 --> 00:13:58.210
And let me,
I can just go through a simple

00:13:58.210 --> 00:14:01.700
code example to give you an
idea of how the API works.

00:14:02.540 --> 00:14:06.210
So the first step in doing this
is you create a NSURLSession

00:14:06.420 --> 00:14:08.080
configuration object.

00:14:08.080 --> 00:14:11.360
And there's a couple different
types of these configuration

00:14:11.460 --> 00:14:13.640
objects that are available in iOS 7.

00:14:13.640 --> 00:14:17.080
I'm focusing on this one that
you get by calling the background

00:14:17.080 --> 00:14:18.900
session configuration object.

00:14:18.900 --> 00:14:21.160
Because that's the one that
will hand off work to the

00:14:21.160 --> 00:14:22.860
system daemon in the background.

00:14:22.860 --> 00:14:25.700
Now once you get this
configuration object,

00:14:25.700 --> 00:14:30.040
you're ready to set up a session object,
an NSURLSession object.

00:14:30.040 --> 00:14:32.520
So you specify the
configuration you want.

00:14:32.520 --> 00:14:36.460
And then you provide a
delegate and a delegate queue.

00:14:36.460 --> 00:14:40.230
And we use a delegate pattern,
which is very common throughout our APIs.

00:14:40.240 --> 00:14:44.270
This delegate is the object that
will be called back when we need to

00:14:44.400 --> 00:14:49.230
ask about authentication challenges,
that we want to notify about progress,

00:14:49.230 --> 00:14:51.440
or when the transfers are completed.

00:14:53.440 --> 00:14:56.340
And now you have a session object
in your hands and you're ready

00:14:56.340 --> 00:14:59.000
to begin adding tasks to it.

00:14:59.170 --> 00:15:04.210
In order to do that, you have a URL,
which is your URL to a resource,

00:15:04.340 --> 00:15:06.330
you know,
probably on your server or somewhere on

00:15:06.330 --> 00:15:08.260
the internet that you want to download.

00:15:08.580 --> 00:15:13.290
And you simply ask the session,
I'd like a download task with this URL.

00:15:13.300 --> 00:15:18.980
And you get back a task object that
represents the state of that transfer

00:15:18.980 --> 00:15:22.030
happening in a background daemon.

00:15:22.290 --> 00:15:25.590
Now these transfers are
created paused by default.

00:15:25.790 --> 00:15:30.720
So when you get this task operation back,
in order to actually start the transfer,

00:15:30.790 --> 00:15:32.100
you simply call resume on it.

00:15:32.390 --> 00:15:36.210
And now the background demon will
start downloading your content.

00:15:37.600 --> 00:15:40.870
Now these task objects support all
of the typical things that you would

00:15:40.870 --> 00:15:43.000
find in a network transfer operation.

00:15:43.090 --> 00:15:45.920
You can suspend them,
you can resume them, you can cancel them,

00:15:45.920 --> 00:15:46.300
right?

00:15:46.300 --> 00:15:47.620
Those are the typical things.

00:15:47.720 --> 00:15:51.760
And these task objects are what you
would use if you were to build a user

00:15:51.760 --> 00:15:54.260
interface around these operations,
right?

00:15:54.260 --> 00:15:57.740
So if you want to present to the
user the status of these transfers,

00:15:57.820 --> 00:16:00.660
these are the objects you
would center that around.

00:16:02.140 --> 00:16:04.740
And I mentioned when the
transfers are completed,

00:16:04.800 --> 00:16:08.150
there's a new UI application
delegate method that will

00:16:08.230 --> 00:16:10.300
be invoked that you provide.

00:16:10.300 --> 00:16:13.150
And it's a callback that basically
says you need to handle some

00:16:13.150 --> 00:16:14.970
events in this background session.

00:16:15.520 --> 00:16:18.600
And you're past a completion handler,
and I'll talk a little bit more about

00:16:18.600 --> 00:16:20.300
the completion handler in a second.

00:16:20.980 --> 00:16:24.360
When you implement these methods,
the common thing to see is you

00:16:24.360 --> 00:16:27.270
reestablish your connection
to the session object,

00:16:27.380 --> 00:16:29.800
you get the list of tasks
that have been completed,

00:16:29.800 --> 00:16:31.250
and then you handle the results.

00:16:31.960 --> 00:16:35.840
If you've downloaded something,
you unpack the contents and you save it.

00:16:35.840 --> 00:16:39.160
If you were uploading something,
maybe you just let the user know

00:16:39.160 --> 00:16:41.270
that your upload has been finished.

00:16:42.030 --> 00:16:46.530
And I should mention everywhere in this
section that I talk about downloading,

00:16:46.610 --> 00:16:49.840
you can replace that with upload,
and it's all the same.

00:16:49.980 --> 00:16:52.690
So this is up for
uploading and downloading.

00:16:53.450 --> 00:16:56.000
Now there's a couple considerations
that you need to keep in mind

00:16:56.000 --> 00:16:59.940
when you're implementing this
new UI application delegate method.

00:17:00.000 --> 00:17:03.510
And the first is that if you're
running in the background,

00:17:03.710 --> 00:17:06.730
if we're notifying you when
you're in the background,

00:17:06.730 --> 00:17:09.370
you only have a short
amount of time to run.

00:17:09.490 --> 00:17:15.340
And by short, I mean on the order of
seconds as opposed to minutes.

00:17:15.390 --> 00:17:19.050
You can see how much time you
have remaining by inspecting

00:17:19.150 --> 00:17:23.150
this background time remaining
property on UI application.

00:17:23.620 --> 00:17:27.060
And that completion handler
that I mentioned that was called

00:17:27.060 --> 00:17:31.060
into this new delegate method,
you need to call that when you're

00:17:31.060 --> 00:17:35.710
done processing the results of
this download or this transfer.

00:17:36.100 --> 00:17:40.030
If you don't call it,
then iOS will terminate your app.

00:17:40.080 --> 00:17:43.260
We need to hear back from
you when you are done.

00:17:43.320 --> 00:17:45.490
And you want to call
it as soon as possible.

00:17:45.580 --> 00:17:47.460
So you want to do as
little work as possible,

00:17:47.460 --> 00:17:50.670
be finished,
and then call the completion handler.

00:17:51.480 --> 00:17:54.130
And then this next item
is extremely important,

00:17:54.230 --> 00:17:56.550
and I'm going to repeat it
a few times throughout the

00:17:56.550 --> 00:17:58.120
remainder of this presentation.

00:17:58.180 --> 00:18:00.750
You need to be aware of data protection.

00:18:00.830 --> 00:18:04.150
And if you have not come
across data protection,

00:18:04.150 --> 00:18:07.560
or if you haven't looked into it,
or haven't had a need for it yet,

00:18:07.620 --> 00:18:10.900
as you adopt these new APIs,
it's critical that you understand

00:18:10.900 --> 00:18:15.010
how it works and what it
means to your application.

00:18:15.280 --> 00:18:18.660
Not only will your app potentially
be running in the background,

00:18:18.890 --> 00:18:21.200
where it may be the first time
you're running in the background,

00:18:21.320 --> 00:18:24.080
you may also be running
when the device is locked.

00:18:24.180 --> 00:18:26.680
And when the device is locked,
if there is a passcode,

00:18:26.770 --> 00:18:29.690
that means that data protection
is going to be enforced.

00:18:29.720 --> 00:18:34.140
And when data protection is in effect,
some things like keychain

00:18:34.320 --> 00:18:38.100
items or files on disk may
not be accessible by your app.

00:18:38.190 --> 00:18:40.960
And you need to understand
what the ramifications of that

00:18:40.980 --> 00:18:42.430
are and how to deal with it.

00:18:42.500 --> 00:18:45.800
Now, our next session on security and
privacy is going to go into more

00:18:45.800 --> 00:18:49.060
details about data protection,
so I'll leave the details to that.

00:18:49.060 --> 00:18:51.880
But just for this point,
just be aware that you need

00:18:51.880 --> 00:18:55.360
to understand data protection
and what it means to your app.

00:18:56.920 --> 00:18:59.700
So now you're done downloading stuff,
and now the question is,

00:18:59.790 --> 00:19:00.680
what do you do with it?

00:19:00.760 --> 00:19:04.190
So you're invoked in the background,
and you need to save this data somewhere.

00:19:04.200 --> 00:19:08.300
And SURL session itself is
only going to hang on to the

00:19:08.300 --> 00:19:11.320
downloaded contents temporarily,
up until the point you call

00:19:11.320 --> 00:19:12.740
that completion handler.

00:19:12.740 --> 00:19:16.460
So if you want to store this
data that you downloaded for

00:19:16.520 --> 00:19:19.690
an extended period of time,
which you probably do,

00:19:19.690 --> 00:19:23.060
at least in this example of separating
assets out of your app bundle,

00:19:23.540 --> 00:19:25.660
you need to move it somewhere,
and you would put it in

00:19:25.660 --> 00:19:27.280
your app sandbox somewhere.

00:19:28.690 --> 00:19:33.170
It's critical here that you pay attention
to the iOS data storage guidelines.

00:19:33.270 --> 00:19:34.690
Now,
if you've never read these guidelines,

00:19:34.760 --> 00:19:36.160
you definitely want to go do that.

00:19:36.160 --> 00:19:40.020
What they tell you are the places
on disk where it's appropriate

00:19:40.020 --> 00:19:42.280
for you to store things,
right?

00:19:42.320 --> 00:19:44.950
What types of files should go
in the temporary directory,

00:19:44.950 --> 00:19:48.220
in the app support directory,
in documents, and things like that.

00:19:48.310 --> 00:19:50.970
So it just kind of lays out
where you should put things.

00:19:50.970 --> 00:19:57.950
It also documents what files will be
by default included in a user's backup.

00:19:59.600 --> 00:20:01.530
Especially the user's iCloud backup.

00:20:01.530 --> 00:20:05.370
And it's really important that you
are aware of those and adhere to these

00:20:05.480 --> 00:20:09.780
guidelines because the app review team
is applying these guidelines and they're

00:20:09.780 --> 00:20:12.190
enforcing them when they review your app.

00:20:12.190 --> 00:20:16.010
And this is a really common reason
that developers get rejected is

00:20:16.010 --> 00:20:19.510
because you have files in a place
that are included in an iCloud

00:20:19.510 --> 00:20:21.770
backup that they don't need to be.

00:20:21.780 --> 00:20:24.340
So you want to read these guidelines.

00:20:24.340 --> 00:20:28.280
If you do have files that you're storing
somewhere that don't need to be included,

00:20:28.280 --> 00:20:28.500
you want to read these guidelines.

00:20:46.780 --> 00:20:46.800
So this is a very simple API on
the NSURL where you save the files.

00:20:46.800 --> 00:20:46.800
Just simply call set
resource value for key,

00:20:46.800 --> 00:20:46.800
specifying this key that
indicates this file should not

00:20:46.800 --> 00:20:46.800
be included in the background.

00:20:46.800 --> 00:20:46.800
So really easy and that will
help you get through the review

00:20:46.800 --> 00:20:46.800
process with no problems.

00:20:47.010 --> 00:20:51.090
So that's the third item in this
checklist for minimizing install time.

00:20:51.180 --> 00:20:54.640
And that's, like I said,
these first two items of just

00:20:54.990 --> 00:20:57.240
making sure you clean things up,
use compression,

00:20:57.240 --> 00:20:58.660
those are the best practices.

00:20:58.690 --> 00:21:01.560
And those apply to everybody,
no matter what kind of

00:21:01.560 --> 00:21:02.960
app you're developing.

00:21:03.070 --> 00:21:07.050
And then the third thing,
considering breaking things up.

00:21:07.340 --> 00:21:14.360
You might look at using NSURLSession to
do the background uploads and downloads.

00:21:14.710 --> 00:21:19.120
And NSURLSession really is the
future of foundation networking.

00:21:19.120 --> 00:21:23.720
This is a fundamental shift in how you
should be writing your networking code.

00:21:23.770 --> 00:21:26.250
And you want to be adopting it now.

00:21:26.450 --> 00:21:30.050
Eventually,
NSURLs connection will go away

00:21:30.160 --> 00:21:31.820
in favor of NSURL connection.

00:21:31.820 --> 00:21:37.600
So, you know, jump on the bandwagon now,
and that'll serve you well in the future.

00:21:37.630 --> 00:21:41.430
And then lastly, pay attention to the iOS
data storage guidelines for a

00:21:41.430 --> 00:21:44.460
great app review experience.

00:21:44.530 --> 00:21:48.500
So that's background transfers and
how you can use new I/O 7 technology

00:21:48.610 --> 00:21:50.520
to minimize your install time.

00:21:50.590 --> 00:21:52.600
Next up,
I want to talk about multitasking,

00:21:52.600 --> 00:21:56.400
which John talked a little
bit about this morning.

00:21:56.830 --> 00:22:00.200
And in iOS 7,
obviously you're all familiar with

00:22:00.200 --> 00:22:05.160
the new multitasking interface where
users can see a snapshot of your

00:22:05.160 --> 00:22:06.690
app even when it's not running.

00:22:06.700 --> 00:22:11.270
This gives people great insight
into the state of your app.

00:22:11.270 --> 00:22:15.070
And this is the experience that I want
to talk about how you can enhance it.

00:22:15.850 --> 00:22:20.950
And the enhancement really comes
around keeping these snapshots alive,

00:22:21.150 --> 00:22:21.400
right?

00:22:21.760 --> 00:22:25.600
Keeping them up to date
over time and giving this,

00:22:25.730 --> 00:22:29.840
your application the impression
that it is running all the time

00:22:29.840 --> 00:22:31.030
and it's always up to date.

00:22:31.220 --> 00:22:33.750
And most importantly,
like John talked about,

00:22:33.780 --> 00:22:36.000
that your app is always ready, right?

00:22:36.000 --> 00:22:38.960
That's one of the things that
will really differentiate a

00:22:38.960 --> 00:22:40.660
great app from just a good app.

00:22:40.720 --> 00:22:45.520
So a couple examples, you know,
you might have a chat or a messaging app.

00:22:45.760 --> 00:22:49.140
Where push notifications are
coming in and in response

00:22:49.140 --> 00:22:52.490
to those push notifications,
you know, yeah, the user sees them in

00:22:52.490 --> 00:22:54.740
notification center,
but maybe they're busy and

00:22:54.740 --> 00:22:57.160
they ignore them and then
kind of forget what was there.

00:22:57.240 --> 00:23:01.950
Well, with these new multitasking APIs,
you can update your snapshot

00:23:02.140 --> 00:23:04.840
and reflect the new messages,
right?

00:23:04.840 --> 00:23:08.410
Update the chat transcript so
that they see in the switcher

00:23:08.410 --> 00:23:10.610
that there's new content there.

00:23:10.760 --> 00:23:13.450
Or another example,
so many apps have social

00:23:13.450 --> 00:23:15.440
network feeds in them,
right?

00:23:15.440 --> 00:23:19.330
And over the period of a day as
the user is using their device,

00:23:19.500 --> 00:23:23.370
they may not be going into your app,
but these new APIs give you a

00:23:23.540 --> 00:23:27.840
hook where you can periodically
update that app snapshot with new

00:23:27.840 --> 00:23:30.390
content from people's social feed.

00:23:30.460 --> 00:23:34.480
So a couple really great ways
to keep these snapshots alive.

00:23:34.480 --> 00:23:38.260
So let me talk a little bit about
where these snapshots come from and

00:23:38.260 --> 00:23:40.570
then what the new opportunities are.

00:23:41.320 --> 00:23:43.780
So the typical sequence
would look like this.

00:23:43.830 --> 00:23:46.690
Someone launches your application,
and as part of your

00:23:46.690 --> 00:23:49.560
launch or your activation,
you're going to go fetch new

00:23:49.560 --> 00:23:52.400
content from your server,
from social networks.

00:23:53.180 --> 00:23:56.250
You'll update your internal state,
and then you'll update

00:23:56.250 --> 00:23:57.400
the state of the UI.

00:23:57.410 --> 00:24:00.340
You'll show the new messages
or new feed contents.

00:24:00.980 --> 00:24:03.980
Then they'll use your app,
and at some point they'll hit the

00:24:03.980 --> 00:24:06.860
home button and they'll leave the app,
at which point your

00:24:06.940 --> 00:24:08.320
app will get suspended.

00:24:09.120 --> 00:24:10.680
And that's when iOS will take a snap.

00:24:10.700 --> 00:24:12.580
of your app.

00:24:12.910 --> 00:24:15.640
Now this flow is obviously user driven,
right?

00:24:15.640 --> 00:24:18.040
It's based on user activity.

00:24:18.210 --> 00:24:22.520
And what's new in iOS 7 is we have
a couple new entry points into the

00:24:22.520 --> 00:24:28.040
same flow that ultimately lead to you
being able to update your snapshot.

00:24:28.180 --> 00:24:33.240
And these are driven by iOS and
they're actually new background modes.

00:24:33.370 --> 00:24:37.820
There's two of them,
remote notification and background fetch.

00:24:38.010 --> 00:24:42.920
Both of these can be configured
in Xcode's capabilities panel.

00:24:43.020 --> 00:24:46.230
They are, as I said,
new background modes that are shown

00:24:46.230 --> 00:24:48.360
here down at the bottom of the list.

00:24:48.440 --> 00:24:52.150
And the key thing to point out
here is that these new background

00:24:52.170 --> 00:24:54.740
modes are available to all apps.

00:24:54.810 --> 00:24:57.870
If you look at the list of
background modes we had previously,

00:24:58.040 --> 00:25:02.790
they were fairly specific
in use and purpose,

00:25:02.880 --> 00:25:04.840
just for updating location
in the background,

00:25:04.840 --> 00:25:07.460
or a voice over IP app.

00:25:07.520 --> 00:25:11.050
Or playing audio,
or using AirPlay in the background.

00:25:11.150 --> 00:25:14.720
And your app had to do that
specific function in order

00:25:14.720 --> 00:25:16.220
to use the background mode.

00:25:16.280 --> 00:25:19.900
But these new background modes
are available to all apps.

00:25:19.960 --> 00:25:23.680
And because they're driven
or initiated by iOS,

00:25:23.730 --> 00:25:26.840
we can do so in a power smart way.

00:25:26.950 --> 00:25:31.850
So we can ensure that people's
batteries aren't going to be drained.

00:25:36.680 --> 00:25:38.850
So let me go through both of these
new background modes and give

00:25:38.870 --> 00:25:42.960
just an overview of how they work
and what you can do with them.

00:25:43.020 --> 00:25:47.450
So starting with remote notifications,
really all this means is that you can

00:25:47.450 --> 00:25:52.110
send push notifications to your app and
they'll now be delivered regardless of

00:25:52.110 --> 00:25:54.540
whether the app is in the front or not.

00:25:54.540 --> 00:25:58.290
They'll be delivered to your app
even if you're in the background.

00:25:59.900 --> 00:28:54.100
[ Transcript missing ]

00:28:54.810 --> 00:28:57.600
You might want to update
your social network feed

00:28:57.600 --> 00:29:00.190
periodically throughout the day.

00:29:00.400 --> 00:29:04.130
And after doing this background fetch,
that's your opportunity for

00:29:04.200 --> 00:29:06.570
updating the app snapshot.

00:29:07.100 --> 00:29:09.510
Now, as I mentioned,
both of these new things

00:29:09.700 --> 00:29:13.290
are really initiated by iOS.

00:29:13.380 --> 00:29:18.400
And in the background fetch case,
we'll take two things into consideration.

00:29:18.580 --> 00:29:21.950
One is, we'll base it on previous
usage of your app.

00:29:22.050 --> 00:29:26.420
So we're kind of looking out for
patterns that people use your app

00:29:27.130 --> 00:29:28.960
throughout the course of a day.

00:29:28.960 --> 00:29:30.850
And let's say you have an app.

00:29:30.910 --> 00:29:33.920
There's a bunch of games that
I'll play in the morning before

00:29:34.160 --> 00:29:36.980
I go to work and then in the
evening after I'm out of work.

00:29:37.000 --> 00:29:38.000
And I'll be at home.

00:29:38.000 --> 00:29:40.730
And iOS will notice that, oh,
these apps get launched in

00:29:40.730 --> 00:29:42.340
the morning and the evening.

00:29:42.480 --> 00:29:47.000
And after a little while,
we'll start seeing that pattern.

00:29:47.000 --> 00:29:51.350
And what iOS will do is launch your app,
launch those games just a little

00:29:51.350 --> 00:29:54.980
bit before we think the user's
going to go into the game.

00:29:54.980 --> 00:29:58.720
So it gives you an opportunity to get
up to date before the user is there

00:29:58.770 --> 00:30:02.700
so that when they do launch your app,
you have the latest information and

00:30:02.700 --> 00:30:05.040
you feel like you're always up to date.

00:30:05.200 --> 00:31:49.300
[ Transcript missing ]

00:31:49.750 --> 00:31:53.860
Now when you're updating your content,
just like the background transfers,

00:31:53.910 --> 00:31:57.540
you want to call the completion
handler as soon as possible.

00:31:57.620 --> 00:32:00.400
If you don't call it soon enough
within the amount of time you

00:32:00.400 --> 00:32:04.040
have to run in the background,
iOS will terminate your app.

00:32:04.140 --> 00:32:08.720
And that's very similar to if
you don't suspend or resume

00:32:08.790 --> 00:32:13.570
or launch quickly enough,
iOS will terminate the app.

00:32:14.300 --> 00:32:16.810
So in order to avoid being terminated,
you want to keep your

00:32:16.810 --> 00:32:18.690
fetches as small as possible.

00:32:18.780 --> 00:32:22.580
Fetch just the metadata that
you need to update the UI.

00:32:23.200 --> 00:32:26.460
If you do realize that there is new
data that you do want to download,

00:32:26.460 --> 00:32:31.320
you know, maybe there's new pictures
available in someone's social feed,

00:32:31.320 --> 00:32:34.540
there's a new file available
that you want to download,

00:32:34.610 --> 00:32:37.450
that's a great use for the
background transfer service.

00:32:38.020 --> 00:32:40.310
So you can use some of these
new technologies really in

00:32:40.310 --> 00:32:41.700
conjunction with each other.

00:32:41.820 --> 00:32:46.080
So use the background fetch to know
when there's new stuff and then queue

00:32:46.080 --> 00:32:48.570
up a background download to go get it.

00:32:50.220 --> 00:32:52.950
And if your app uses OpenGL,
you may be thinking, well,

00:32:52.950 --> 00:32:57.240
I'm not allowed to draw using
OpenGL when my app is in the background.

00:32:57.360 --> 00:32:59.990
And so we've also changed
this a little bit.

00:33:00.140 --> 00:33:03.500
During the time when we call the
UI application delegate method,

00:33:03.500 --> 00:33:06.700
between that time and when you
call the completion handler,

00:33:06.710 --> 00:33:09.730
you can use OpenGL even if
you're in the background.

00:33:29.010 --> 00:33:29.150
Now,
you want to be as efficient as possible.

00:33:29.150 --> 00:33:29.150
And if you can get away with
rendering a single frame,

00:33:29.150 --> 00:33:29.150
you know, that would be great.

00:33:29.150 --> 00:33:29.150
So do that.

00:33:29.150 --> 00:33:29.150
You know, just render a single frame,
update the UI,

00:33:29.150 --> 00:33:29.150
and we'll take a snapshot of that.

00:33:29.150 --> 00:33:29.150
But you can use OpenGL in the background
during these delegate callbacks.

00:33:29.990 --> 00:33:32.940
And just like before,
be aware of data protection.

00:33:33.010 --> 00:33:37.010
Now, this is an interesting case
where you may be getting launched

00:33:37.010 --> 00:33:38.460
to do a background fetch.

00:33:38.520 --> 00:33:40.940
And just by the very
nature of fetching things,

00:33:40.990 --> 00:33:43.600
you probably are going to need
to check in with your server.

00:33:43.670 --> 00:33:46.170
And you may need credentials to do that.

00:33:46.250 --> 00:33:49.790
And by default,
credentials in the key chain are going to

00:33:49.790 --> 00:33:52.900
not be available if the device is locked.

00:33:53.020 --> 00:33:56.020
So we have seen this trip
up some developers already,

00:33:56.020 --> 00:33:58.040
where they've tried to
get the credentials.

00:33:58.100 --> 00:33:59.500
They've failed.

00:33:59.500 --> 00:34:02.760
Maybe didn't have the error checking
around that that they should have.

00:34:02.780 --> 00:34:04.960
Then went and tried to
log into their server.

00:34:04.960 --> 00:34:07.300
And that obviously failed,
because they don't have the credentials.

00:34:07.300 --> 00:34:11.940
And then they got into a kind of a
confused state where they thought,

00:34:11.940 --> 00:34:14.350
oh, the authentication failed.

00:34:14.360 --> 00:34:15.740
The password's bad.

00:34:15.740 --> 00:34:16.680
We'll log the user out.

00:34:16.730 --> 00:34:19.210
So we've just seen some
confusion around this.

00:34:19.260 --> 00:34:22.730
And that tells me that maybe people
aren't paying as much attention

00:34:22.730 --> 00:34:24.220
to data protection as they should.

00:34:24.220 --> 00:34:28.530
And that's why I'm here pleading to you
to make sure that you understand data

00:34:28.530 --> 00:34:31.060
protection and what it means to your app.

00:34:31.060 --> 00:34:34.500
So that's multitasking.

00:34:34.500 --> 00:34:37.960
It's new APIs that let you
keep your apps up to date.

00:34:37.960 --> 00:34:42.420
And most importantly,
keep these app snapshots up to date.

00:34:42.420 --> 00:34:45.460
Remote notifications let you
get your push notifications,

00:34:45.550 --> 00:34:47.200
even in the background.

00:34:47.200 --> 00:34:49.660
And now you can send
silent notifications,

00:34:49.660 --> 00:34:53.060
background fetching,
new opportunities to update your

00:34:53.060 --> 00:34:56.950
content before the user needs it,
to really let them feel like

00:34:56.950 --> 00:34:58.480
your app is always ready.

00:34:58.700 --> 00:35:02.420
And again, I promise,
I think this is the last time

00:35:02.420 --> 00:35:05.200
I'll say this this session,
be aware of using data protection

00:35:05.200 --> 00:35:09.750
when the-- or be aware of when the
device is locked using data protection.

00:35:09.800 --> 00:35:13.340
So that's some new
multitasking APIs in iOS 7.

00:35:13.340 --> 00:35:17.100
Now lastly, let me move on to iBeacon,
probably our most interesting new

00:35:17.170 --> 00:35:20.400
technology that I'm talking about here,
certainly.

00:35:20.460 --> 00:35:22.410
So what is iBeacon?

00:35:22.500 --> 00:35:27.570
So very simply put,
iBeacon is a Bluetooth low energy

00:35:27.570 --> 00:35:32.700
device that is simply emitting a signal,
a unidirectional signal

00:35:32.700 --> 00:35:33.760
that's being emitted.

00:35:33.760 --> 00:35:36.710
And in that signal is an identifier.

00:35:36.720 --> 00:35:44.020
And what that enables is it lets an iOS
device detect when it's near an iBeacon.

00:35:44.020 --> 00:35:47.360
And when it detects that,
it can actually respond to it.

00:35:47.360 --> 00:35:50.990
And most importantly,
it can notify an app that the

00:35:51.010 --> 00:35:53.830
device is now near an iBeacon.

00:35:55.010 --> 00:35:57.260
Now, there's a couple of
new APIs that we have,

00:35:57.260 --> 00:36:00.000
or a couple APIs you use
to integrate with iBeacon.

00:36:00.050 --> 00:36:01.540
The first is region monitoring.

00:36:01.790 --> 00:36:03.890
That's actually an existing API.

00:36:03.990 --> 00:36:05.710
And then the second is ranging.

00:36:05.960 --> 00:36:07.890
And that's a new set of APIs.

00:36:07.980 --> 00:36:09.980
So let me go through both of
these to explain what they are.

00:36:10.700 --> 00:36:14.720
Now, region monitoring, as I mentioned,
it uses the same core location

00:36:14.720 --> 00:36:17.940
APIs that we've had actually
for a good number of releases,

00:36:18.000 --> 00:36:19.460
I think back to iOS 4.

00:36:19.700 --> 00:36:22.420
And we use those APIs for
doing geofencing,

00:36:22.420 --> 00:36:25.710
right,
for doing notifications of when a device

00:36:25.710 --> 00:36:28.570
moves into or out of a geographic area.

00:36:29.450 --> 00:36:33.160
Now those are great APIs,
and we're using the same

00:36:33.270 --> 00:36:36.580
API for doing beacon regions,
what we call beacon regions,

00:36:36.580 --> 00:36:39.990
an area defined around an iBeacon.

00:36:40.000 --> 00:36:44.470
But iBeacons are much more flexible
because they're not tied to a

00:36:44.540 --> 00:36:46.840
specific place on the planet.

00:36:46.840 --> 00:36:50.640
They're typically battery operated,
so you can attach them to

00:36:50.720 --> 00:36:53.870
things that move around,
and that really enables some very

00:36:53.960 --> 00:36:56.040
interesting location awareness in apps.

00:36:56.700 --> 00:36:59.960
You could put them on a subway,
on a train, or a bus,

00:36:59.960 --> 00:37:03.640
or something like that,
and now an app can detect when

00:37:03.640 --> 00:37:08.210
it's near a bus or a train
has pulled into the station.

00:37:09.100 --> 00:37:10.730
You could put them on a cruise ship.

00:37:10.770 --> 00:37:12.860
Cruise ships moving around
the planet all the time.

00:37:12.930 --> 00:37:15.500
And it's also made up of levels,
which is kind of interesting.

00:37:15.500 --> 00:37:19.500
That's a challenge for geofencing because
that tends to be just a single point.

00:37:19.500 --> 00:37:22.730
So you could put iBeacons in
different places on the ship and

00:37:22.730 --> 00:37:26.500
do a lot of interesting things with
an app that users use on a ship.

00:37:26.500 --> 00:37:30.400
Or, you know,
for more accurate indoor location.

00:37:30.490 --> 00:37:34.450
We just recently rolled this out in
a lot of our Apple retail stores.

00:37:34.500 --> 00:37:39.070
So iBeacons can really enable more
accurate detection of location

00:37:39.070 --> 00:37:43.490
indoors where GPS signals have
a very hard time penetrating.

00:37:43.500 --> 00:37:48.470
So another place that we use
this in iOS is in Passbook.

00:37:48.470 --> 00:37:51.500
So to make a pass relevant
on the lock screen,

00:37:51.500 --> 00:37:54.500
you could specify a
latitude and longitude.

00:37:54.560 --> 00:37:55.500
And now in iOS 7, you can specify a pass.

00:37:55.500 --> 00:37:55.500
So iBeacons can really enable more
accurate detection of location

00:37:55.500 --> 00:37:55.500
indoors where GPS signals have
a very hard time penetrating.

00:37:55.500 --> 00:37:56.500
So another place that we use
this in iOS is in Passbook.

00:37:56.500 --> 00:37:57.500
a beacon.

00:37:57.500 --> 00:37:59.460
And we actually did that -- we're
doing that for the tech talks.

00:37:59.510 --> 00:38:02.350
This morning, we had an eye beacon on
the registration table.

00:38:02.460 --> 00:38:04.740
So, as you walked up to
the registration table,

00:38:04.740 --> 00:38:08.170
if you saw the pass on your lock screen,
that was because it detected

00:38:08.260 --> 00:38:10.890
that eye beacon sitting there.

00:38:11.410 --> 00:38:15.220
So that's the region monitoring APIs,
based on the same APIs we had before,

00:38:15.290 --> 00:38:18.800
just with a new way of
triggering the notifications.

00:38:18.800 --> 00:38:23.250
Now,
the new APIs in iOS 7 are around ranging.

00:38:23.260 --> 00:38:27.700
And what ranging is,
is it's a set of APIs that will give

00:38:27.700 --> 00:38:31.170
you an estimated proximity to a beacon.

00:38:31.180 --> 00:38:34.800
And we categorize this
proximity into three zones,

00:38:34.820 --> 00:38:35.550
right?

00:38:35.660 --> 00:38:37.360
Immediate, near, and far.

00:38:37.360 --> 00:38:40.490
And let me talk through each of
these and explain what they are.

00:38:42.320 --> 00:38:47.520
The immediate zone is reported
when a device is really

00:38:47.520 --> 00:38:51.270
right up next to an iBeacon,
measured probably on the

00:38:51.270 --> 00:38:52.280
order of centimeters.

00:38:52.280 --> 00:38:55.330
It probably represents,
if for example the corner

00:38:55.400 --> 00:38:59.380
of this table was a beacon,
it probably represents a user actually

00:38:59.380 --> 00:39:04.170
taking a very intentional action of
holding their device up to the beacon.

00:39:21.490 --> 00:39:21.490
And because we're so close to the beacon,
the signal strength from

00:39:21.490 --> 00:39:21.490
the beacon is very strong.

00:39:21.490 --> 00:39:21.490
And all the detection of iBeacons
is based on signal strength.

00:39:21.490 --> 00:39:21.490
And when we have a very
strong signal strength,

00:39:21.490 --> 00:39:21.490
we can be very confident of
the distance to that beacon.

00:39:21.760 --> 00:39:25.900
Moving further out from
there is the near zone.

00:39:25.950 --> 00:39:29.100
That's probably on the
order of a few meters.

00:39:29.100 --> 00:39:31.820
We probably still have
a good signal strength,

00:39:31.820 --> 00:39:35.810
so we have reasonable confidence
on the accuracy of that proximity.

00:39:36.070 --> 00:39:39.660
That might be here in
this immediate area,

00:39:39.660 --> 00:39:42.010
the first few rows or so.

00:39:42.320 --> 00:39:45.740
And then going beyond that
is what we call the far zone.

00:39:45.830 --> 00:39:50.170
And that's more than a few meters,
kind of on up towards the

00:39:50.170 --> 00:39:52.690
edge of the Bluetooth signal.

00:39:55.860 --> 00:40:03.600
This whole notion of signal strength
and the accuracy and the proximity

00:40:03.600 --> 00:40:07.190
is really the important part that
I want to focus on here today.

00:40:08.110 --> 00:40:11.920
In order to understand the
importance in how the signal

00:40:11.930 --> 00:40:16.680
strength affects the accuracy,
I want to draw a parallel

00:40:16.830 --> 00:40:19.500
to how GPS works in Maps.

00:40:20.070 --> 00:40:21.200
So here's the Maps app.

00:40:21.330 --> 00:40:24.620
And you're probably all familiar
with your location in the middle

00:40:24.740 --> 00:40:28.530
with this blue circle around it,
which represents the margin of

00:40:28.650 --> 00:40:34.370
error that we have around our
confidence of where you actually are.

00:40:35.460 --> 00:40:38.700
So the accuracy with iBeacons
is just like with GPS.

00:40:38.890 --> 00:40:42.460
When we have a weak signal,
when the signal from the satellites

00:40:42.590 --> 00:40:45.520
or from an iBeacon are weak,
we have a high margin of error,

00:40:45.520 --> 00:40:49.390
just meaning that we can't be confident
about specifically where you are.

00:40:49.450 --> 00:40:53.820
In maps, that's represented by, you know,
a fairly large blue circle on

00:40:53.820 --> 00:40:56.060
the order of a kilometer or so.

00:40:56.360 --> 00:40:59.310
Now, as the signal from the
satellites improves,

00:40:59.310 --> 00:41:02.320
maybe the device was indoors
in this example and now

00:41:02.320 --> 00:41:05.900
it's kind of moved outdoors,
that blue circle will shrink down

00:41:05.900 --> 00:41:07.880
because we have a stronger signal.

00:41:08.010 --> 00:41:12.420
And now we can kind of say, well,
we know we can shrink this area

00:41:12.420 --> 00:41:15.090
and say you're in a smaller circle.

00:41:15.740 --> 00:41:18.280
And then when we finally get a really
strong signal and we have a direct

00:41:18.390 --> 00:41:21.170
line of sight to the satellites,
you know, that blue circle goes away

00:41:21.190 --> 00:41:23.800
altogether and now we say,
okay, we know where you are.

00:41:24.000 --> 00:41:25.650
You're right here.

00:41:26.630 --> 00:41:30.750
Now this idea of accuracy and this
kind of concept of this blue circle

00:41:30.750 --> 00:41:33.010
is really the same for iBeacons.

00:41:33.100 --> 00:41:35.310
Now iBeacons have an accuracy.

00:41:36.270 --> 00:41:41.610
And what that is when you're looking at
this in code is it's our guess as to how

00:41:41.610 --> 00:41:44.510
far away from the iBeacon you may be.

00:41:45.490 --> 00:41:47.900
So it's our estimate of the distance.

00:41:48.000 --> 00:41:49.710
And it is just an estimate.

00:41:49.800 --> 00:41:53.240
And if you're really into statistics,
I'm going to be very

00:41:53.240 --> 00:41:57.420
specific here for a second,
it's actually a one sigma estimate.

00:41:58.040 --> 00:42:01.220
So if that means anything to the
statistics folks in the crowd.

00:42:01.840 --> 00:42:04.150
And if you take that estimate
and you were to double it,

00:42:04.300 --> 00:42:07.190
then that raises the question,
it raises our confidence to 95%.

00:42:07.230 --> 00:42:11.980
We are 95% sure that you are within
that distance from the beacon.

00:42:12.750 --> 00:42:18.310
So that's just my little side spiel
on the accuracy going into statistics.

00:42:19.080 --> 00:42:23.310
Now the thing that affects
signal strength the most is,

00:42:23.630 --> 00:42:25.400
or sorry,
the importance of the signal strength

00:42:25.470 --> 00:42:29.450
has to do with signal attenuation
and things that affect the signal

00:42:29.450 --> 00:42:32.670
strength and minimize it especially.

00:42:32.800 --> 00:42:35.590
So now Bluetooth, this is all based on
Bluetooth technology.

00:42:35.720 --> 00:42:40.400
So Bluetooth uses the 2.4 gigahertz
frequency for sending signals.

00:42:40.520 --> 00:42:44.610
And that frequency range is, you know,
it's affected by physical objects, by,

00:42:44.610 --> 00:42:47.510
you know, desks or walls or doors,
things like that.

00:42:47.620 --> 00:42:49.940
And that can affect the signal strength.

00:42:49.940 --> 00:42:52.970
It can reduce the signal strength,
which minimizes the

00:42:52.970 --> 00:42:55.550
signal that we receive,
thereby affecting our

00:42:55.550 --> 00:42:57.330
confidence in the accuracy.

00:42:59.580 --> 00:43:03.990
Now this 2.4 gigahertz frequency
is also affected by water,

00:43:04.060 --> 00:43:04.940
it turns out.

00:43:05.030 --> 00:43:08.040
And since our bodies are
mostly made up of water,

00:43:08.110 --> 00:43:11.850
this can really have an effect on the
accuracy when you're using iBeacons.

00:43:11.880 --> 00:43:16.300
And this is an important thing to keep
in mind as you're deploying iBeacons.

00:43:16.600 --> 00:43:19.260
So, you know,
if you have an app that is using

00:43:19.260 --> 00:43:22.900
iBeacons and your user actually
has their device like in their

00:43:22.900 --> 00:43:26.960
pocket or it's in a purse and it's
being held up against their body,

00:43:26.960 --> 00:43:30.190
then their body may actually be
affecting the signal strength,

00:43:30.610 --> 00:43:32.350
depending where the beacon is located.

00:43:32.360 --> 00:43:34.770
Again,
if it's on the corner of that table,

00:43:34.770 --> 00:43:38.070
if I have the signal or my phone
in my pocket and I'm facing it,

00:43:38.070 --> 00:43:39.680
that might be one thing.

00:43:39.680 --> 00:43:42.250
But if I've turned around and now it,
you know,

00:43:42.250 --> 00:43:46.340
is blocked by my leg or by my body,
that can reduce the signal strength.

00:43:46.430 --> 00:43:49.800
and that affects the
accuracy that we have.

00:43:50.200 --> 00:43:53.360
As a result,
when the signal strength is decreased,

00:43:53.360 --> 00:43:57.070
that may cause us to think that
an iBeacon is actually in the far

00:43:57.070 --> 00:43:59.170
zone when it may actually be near.

00:43:59.180 --> 00:44:02.160
So this is just an important thing
to consider as you're deploying it,

00:44:02.160 --> 00:44:05.270
and I'll talk about some deployment
considerations in a little bit.

00:44:11.710 --> 00:44:13.440
But this signal attenuation and
signal strength is probably the most

00:44:13.500 --> 00:44:14.520
important thing for you to understand.

00:44:14.530 --> 00:44:16.010
There's a couple best practices
that we've come up with for

00:44:16.010 --> 00:44:17.000
using these new ranging APIs.

00:44:17.780 --> 00:44:20.360
Now,
the first is the ranging APIs are really

00:44:20.360 --> 00:44:24.350
intended to be used interactively,
meaning not while the device is

00:44:24.350 --> 00:44:28.000
locked and in a pocket or in a
purse or something like that.

00:44:28.680 --> 00:44:31.270
You're going to get the best
results when the user has their

00:44:31.270 --> 00:44:33.960
device out and it's in their hand,
your app is front most,

00:44:33.960 --> 00:44:35.940
and they're actually interacting.

00:44:36.810 --> 00:44:40.620
Because that's where the antennas
are probably not blocked by anything,

00:44:40.620 --> 00:44:44.440
and it's your best chance for getting
a line of sight to the beacon.

00:44:45.230 --> 00:44:47.960
And that's when you
get your best results,

00:44:48.030 --> 00:44:51.990
is when a device has clear line
of sight not blocked by physical

00:44:52.000 --> 00:44:54.290
objects or other human bodies.

00:44:55.310 --> 00:44:59.710
Now when CoreLocation reports
to you what beacons it sees,

00:44:59.730 --> 00:45:02.260
you know,
if you're using just a single beacon,

00:45:02.260 --> 00:45:03.630
then things are pretty clear.

00:45:03.650 --> 00:45:08.040
You just get your proximity zone and
you determine what to do at that point.

00:45:08.070 --> 00:45:11.850
But if you're in a situation like
imagine a retail store where you

00:45:11.850 --> 00:45:15.910
may have multiple beacons for
different departments or whatnot,

00:45:15.910 --> 00:45:20.410
CoreLocation is actually going to
return these beacons sorted by our

00:45:20.440 --> 00:45:22.700
best guess as to the proximity.

00:45:23.340 --> 00:45:25.820
So we'll try to put
the closest one first.

00:45:25.860 --> 00:45:30.120
But it's really important that you
are flexible if you're ranging to

00:45:30.120 --> 00:45:34.830
multiple beacons and all of them are
reporting they're in the far zone.

00:45:34.860 --> 00:45:36.870
You want to be flexible with that.

00:45:36.920 --> 00:45:40.370
You may build a user interface
where you present to the user,

00:45:40.370 --> 00:45:44.040
well, here are the beacons that we see,
but we don't know exactly

00:45:44.040 --> 00:45:45.700
which one is closest.

00:45:45.700 --> 00:45:47.170
So we're going to let you pick.

00:45:47.180 --> 00:45:50.680
Let the user have kind of some
involvement into the interaction here.

00:45:51.320 --> 00:45:54.300
Now,
if you see immediate or maybe even near,

00:45:54.540 --> 00:45:57.480
you may want to lock in on that
because our confidence is higher.

00:45:57.480 --> 00:46:00.130
But with the beacons in the far zone,
maybe, you know,

00:46:00.130 --> 00:46:01.860
just show the user what they are.

00:46:01.860 --> 00:46:03.840
Let them kind of drive the engagement.

00:46:06.070 --> 00:46:09.450
Now,
calibration is a really important thing.

00:46:09.570 --> 00:46:14.770
And it's crucial for you to calibrate
the experience and the beacons

00:46:14.770 --> 00:46:17.880
in as close to the environment,
if not the actual environment,

00:46:18.180 --> 00:46:19.370
that you plan to deploy them.

00:46:19.370 --> 00:46:22.690
You need to consider the
placement of beacons,

00:46:22.690 --> 00:46:23.830
where they are.

00:46:24.090 --> 00:46:27.030
Are you mounting them under a table,
behind a sign?

00:46:27.030 --> 00:46:29.440
Or can you mount them
kind of in the clear?

00:46:29.440 --> 00:46:31.870
Are they above people's heads or not?

00:46:32.850 --> 00:46:36.700
And you also want to test and
calibrate with the expected number

00:46:36.880 --> 00:46:38.330
of people in the environment.

00:46:38.360 --> 00:46:41.340
Because the signals are
affected by the human body,

00:46:41.340 --> 00:46:44.390
you want to make sure that
you have the estimated number

00:46:44.580 --> 00:46:46.490
of people in the environment.

00:46:47.240 --> 00:46:50.420
And then once you've done that,
you want to see what

00:46:50.550 --> 00:46:51.920
the results are like.

00:46:51.920 --> 00:46:55.120
Are you getting immediate
and near proximities?

00:46:55.120 --> 00:46:56.780
Or do you only see far?

00:46:56.790 --> 00:46:59.240
If you only see far,
then maybe you need to consider

00:46:59.240 --> 00:47:00.570
deploying more beacons.

00:47:01.880 --> 00:47:04.430
And then you want to pull up
on the beacons that you have,

00:47:04.430 --> 00:47:08.010
just to increase the likelihood that
the device will get a strong signal.

00:47:09.050 --> 00:47:13.700
Now one thing to consider is that iOS
devices themselves can be beacons.

00:47:13.770 --> 00:47:17.940
Any Bluetooth low energy enabled iOS
device can be turned into a beacon.

00:47:17.940 --> 00:47:20.760
An app can request it begin
broadcasting a beacon signal.

00:47:20.760 --> 00:47:24.240
There's a bunch of examples
that this makes sense in,

00:47:24.240 --> 00:47:27.380
you know,
point of sale apps or really any type of

00:47:27.510 --> 00:47:32.530
app that is in a single purpose like a
kiosk mode is one way of looking at it.

00:47:32.610 --> 00:47:35.570
That's a great candidate for
using the iOS device as a beacon.

00:47:36.140 --> 00:47:37.920
But there's a big caveat
that comes with this,

00:47:37.920 --> 00:47:40.000
and this is one of the most
common questions I get.

00:47:40.020 --> 00:47:44.100
The app has to be frontmost and
the device needs to be unlocked,

00:47:44.100 --> 00:47:44.840
right?

00:47:44.840 --> 00:47:47.630
You can't be broadcasting,
an app cannot request a

00:47:47.630 --> 00:47:51.130
device broadcast as an iBeacon
when it's in the background.

00:47:51.140 --> 00:47:54.350
So if you need that,
then you might want to be

00:47:54.350 --> 00:47:59.210
looking at battery powered
iBeacons when they're available.

00:47:59.210 --> 00:48:02.940
So that's just a summary on iBeacon.

00:48:03.920 --> 00:48:07.140
New Bluetooth technology that
enables region monitoring

00:48:07.140 --> 00:48:08.780
and proximity detection.

00:48:08.780 --> 00:48:12.380
These are great for mobile
objects or indoor use cases.

00:48:12.380 --> 00:48:16.780
You need to pay attention to the
accuracy and the signal strength

00:48:16.780 --> 00:48:18.900
in real world environments.

00:48:18.900 --> 00:48:22.880
You want to calibrate and test
in these real world scenarios to

00:48:22.880 --> 00:48:25.160
ensure the best user experience.

00:48:27.290 --> 00:48:29.590
So that's the three technologies
I wanted to go through.

00:48:29.740 --> 00:48:32.400
Background transfer and
minimizing install time,

00:48:32.520 --> 00:48:35.700
multitasking and keeping your
app snapshots up to date,

00:48:35.800 --> 00:48:41.920
and then iBeacon for providing an
entire new class of location aware apps.

00:48:42.050 --> 00:48:45.440
So if you have any questions,
here's my contact information.

00:48:45.440 --> 00:48:48.320
I'll be in the labs immediately
following this session.

00:48:48.400 --> 00:48:50.160
And then at the reception
in the afternoon,

00:48:50.370 --> 00:48:52.380
we've got some documentation online.

00:48:52.560 --> 00:48:56.600
There's a very active core location
forum on our developer forum.

00:48:56.600 --> 00:48:59.700
So I encourage you to
participate in those discussions.

00:48:59.820 --> 00:49:03.200
And then in addition to that,
we talked a lot about all of these new

00:49:03.200 --> 00:49:05.790
technologies at WWDC this past year.

00:49:06.050 --> 00:49:08.980
And obviously, I've just scratched the
surface on all of these.

00:49:09.040 --> 00:49:11.320
So definitely check out these videos.

00:49:11.320 --> 00:49:15.670
What's New in Foundation Networking
went into NSURL session and all of the

00:49:15.670 --> 00:49:17.760
functionality that is offered there.

00:49:17.870 --> 00:49:21.510
What's New in Multitasking went
through the remote notifications

00:49:21.520 --> 00:49:23.200
and background fetch.

00:49:23.270 --> 00:49:26.000
And then two sessions
talked about iBeacons.

00:49:26.000 --> 00:49:29.890
One was What's New in Core Location,
which went through the new APIs.

00:49:30.000 --> 00:49:33.630
And then this last one, Harnessing iOS to
Create Magic in Your Apps,

00:49:33.750 --> 00:49:38.780
was actually a session given by the
Apple retail store engineering team,

00:49:38.780 --> 00:49:40.820
talking about how you might use iBeacon.

00:49:40.820 --> 00:49:43.580
And they had given an example
of using it in a museum for

00:49:43.670 --> 00:49:46.020
interactive exhibit information.

00:49:46.110 --> 00:49:48.540
So thank you very much.
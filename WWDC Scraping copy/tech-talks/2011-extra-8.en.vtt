WEBVTT

00:00:12.000 --> 00:00:14.870
Hello, I'm Allan Schaffe,
the Game Technologies Evangelist

00:00:14.940 --> 00:00:15.900
at Apple.

00:00:15.950 --> 00:00:18.210
In this presentation,
I'm going to cover some of the

00:00:18.310 --> 00:00:22.580
techniques that OpenGL ES based games
can use to tune their performance,

00:00:22.640 --> 00:00:25.340
with a particular focus on 2D games.

00:00:25.390 --> 00:00:27.730
And of course,
many of these same concepts will

00:00:27.730 --> 00:00:30.060
apply to tuning 3D rendering as well.

00:00:30.120 --> 00:00:33.380
And I'll be using a new
instrument included with Xcode 4,

00:00:33.490 --> 00:00:36.020
called the OpenGL ES Analyzer.

00:00:36.100 --> 00:00:40.520
This is something that many of
you saw a preview of at WWDC 2010,

00:00:40.590 --> 00:00:43.360
but it's definitely worth
taking another look at now and

00:00:43.360 --> 00:00:45.260
trying it out with your titles.

00:00:45.380 --> 00:00:47.400
So, let's get started.

00:00:47.450 --> 00:00:51.050
Now, as you probably know,
OpenGL ES is the interface for

00:00:51.050 --> 00:00:55.720
high performance rendering in iOS,
designed to let you take advantage of

00:00:55.720 --> 00:00:58.400
the 3D graphics hardware in our devices.

00:00:58.460 --> 00:01:03.240
And it's the API being used in most
of the games on the App Store today.

00:01:03.310 --> 00:01:07.240
Now, typically when we think
of OpenGL ES based games,

00:01:07.320 --> 00:01:10.520
what immediately comes to mind
are first person shooters,

00:01:10.560 --> 00:01:15.520
and out the window simulation type games,
and adventure games, and so on.

00:01:15.650 --> 00:01:19.110
Where the world is being presented in 3D,
and we're moving through it

00:01:19.120 --> 00:01:23.520
blasting bad guys with really rich,
detailed characters,

00:01:23.520 --> 00:01:25.540
and a realistic environment.

00:01:25.540 --> 00:01:28.630
But actually,
the use of OpenGL ES is quite

00:01:28.630 --> 00:01:33.540
widespread in 2D games as well,
in a number of genres.

00:01:33.540 --> 00:01:35.540
So, here's a few examples.

00:01:35.540 --> 00:01:36.910
The first is Plants vs.

00:01:36.910 --> 00:01:40.510
Zombies,
a tower defense game from PopCap.

00:01:40.620 --> 00:01:42.520
Now,
everything you see here is a 2D sprite.

00:01:42.520 --> 00:01:45.410
The backdrop, the characters, the text,
and so on.

00:01:45.630 --> 00:01:48.730
And if you're familiar with this game,
you know that the characters are

00:01:48.730 --> 00:01:51.520
articulated at their joints as well.

00:01:51.700 --> 00:01:54.520
But all this animation is
just being done with sprites.

00:01:54.520 --> 00:01:57.270
And the next is Osmos for iPad.

00:01:57.710 --> 00:02:01.520
This is a gorgeous physics
puzzler from Hemisphere Games.

00:02:01.790 --> 00:02:07.520
This game has a lot happening on screen
that gives it a really rich 3D look.

00:02:07.540 --> 00:02:10.520
But, once again, this is many layers of
alpha textured graphics.

00:02:10.520 --> 00:02:15.030
2D sprites being drawn in OpenGL ES.

00:02:16.430 --> 00:02:19.510
Then there's Fruit Ninja by
Halfbrick Studios.

00:02:19.510 --> 00:02:23.030
So here's OpenGL ES being
used in a 2D action game,

00:02:23.050 --> 00:02:25.300
but with a really interesting twist.

00:02:25.420 --> 00:02:28.730
The backdrop, the swipes,
the fruit splatters,

00:02:28.730 --> 00:02:32.420
and the text are all done
with alpha textured sprites,

00:02:32.540 --> 00:02:35.500
but each piece of fruit
is actually rendered as 3D

00:02:35.500 --> 00:02:37.450
geometry for extra realism.

00:02:37.750 --> 00:02:40.230
And the result just looks great.

00:02:41.070 --> 00:02:42.000
Here's another.

00:02:42.050 --> 00:02:48.300
We can also see OpenGL ES being used in
a lot of card games and the casino genre.

00:02:48.360 --> 00:02:51.630
This is World Series of Poker:
Hold'em Legend from Glue,

00:02:51.630 --> 00:02:54.940
where as before,
everything on screen is a 2D sprite.

00:02:55.000 --> 00:02:58.060
The backdrop, the cards,
the player avatars,

00:02:58.060 --> 00:03:03.200
and they take advantage of OpenGL for
things like chip animations and so on.

00:03:04.270 --> 00:03:05.670
Now a couple more examples.

00:03:05.840 --> 00:03:09.360
Here's Harbormaster HD by Imanji Studios.

00:03:09.420 --> 00:03:12.770
This is a line drawing
and chaos management game,

00:03:12.770 --> 00:03:15.750
where you're guiding boats
into their docks on screen,

00:03:15.750 --> 00:03:19.600
and once again,
everything on screen is being rendered

00:03:19.600 --> 00:03:22.750
in layers of 2D sprites using OpenGL ES.

00:03:23.680 --> 00:03:25.390
And then finally,
one that many of you are

00:03:25.500 --> 00:03:28.510
familiar with is Angry Birds,
with in this case,

00:03:28.540 --> 00:03:30.620
Angry Bird Seasons by Rovio.

00:03:30.640 --> 00:03:33.460
Now,
every object on screen is one of a series

00:03:33.470 --> 00:03:36.310
of different 2D alpha textured sprites.

00:03:38.860 --> 00:03:43.340
So what this is meant to illustrate
is that even though OpenGL ES is

00:03:43.340 --> 00:03:48.750
usually associated with first
person real time 3D graphics,

00:03:48.790 --> 00:03:52.420
that actually its usage is even
more widespread into all the

00:03:52.420 --> 00:03:57.700
varieties of game genres that
center around 2D scenes as well.

00:03:57.840 --> 00:03:59.490
So what about your game?

00:03:59.670 --> 00:04:03.860
If you're writing a 2D based
game and using OpenGL ES,

00:04:03.860 --> 00:04:08.610
or a game engine or a third party
framework layered on top of it,

00:04:08.700 --> 00:04:13.560
how can you make sure that your
game performs as well and looks

00:04:13.560 --> 00:04:18.250
as good as these other very,
very popular games?

00:04:18.470 --> 00:04:22.940
Well, I'll start by looking at what some
of these games can have in common,

00:04:23.020 --> 00:04:24.840
and then we'll see how to tune for that.

00:04:24.900 --> 00:04:27.580
What you see in common
among almost all of them is,

00:04:27.580 --> 00:04:33.010
of course, widespread usage of OpenGL ES,
and it's being used to render quads

00:04:33.120 --> 00:04:35.660
or sprites with alpha textures.

00:04:35.720 --> 00:04:38.660
Now, typically each quad is
being drawn separately,

00:04:38.660 --> 00:04:42.160
and quite often each quad is
carrying around with it a lot

00:04:42.160 --> 00:04:43.460
of its own graphics state.

00:04:43.520 --> 00:04:48.920
And so the amount of overhead involved in
rendering the scene is really quite high.

00:04:49.220 --> 00:04:53.310
It's also very common for these
games to have a top-down or side-on

00:04:53.310 --> 00:04:55.900
view or false perspective view.

00:04:56.010 --> 00:04:59.400
Sometimes with a really large level
that you're panning around and a

00:04:59.400 --> 00:05:01.760
lot of off-screen game elements.

00:05:01.890 --> 00:05:07.120
So the approach that we'll use
to tune for this situation breaks

00:05:07.120 --> 00:05:09.700
down into these four steps.

00:05:10.310 --> 00:05:14.880
First, we'll do a really detailed
analysis of the OpenGL ES activity

00:05:14.880 --> 00:05:16.780
happening in the game.

00:05:16.830 --> 00:05:20.910
Then we'll walk through what we
find and work on eliminating state

00:05:20.930 --> 00:05:24.880
changes and optimizing the draw calls.

00:05:24.930 --> 00:05:28.760
And there's some well understood
techniques that we'll use for doing that.

00:05:28.820 --> 00:05:31.090
Then once that's taken care of,
at the end I'll have a few

00:05:31.190 --> 00:05:35.210
pointers for some further
optimizations that you can make.

00:05:35.490 --> 00:05:39.630
So let's start with
measuring OpenGL ES activity.

00:05:40.340 --> 00:05:43.040
Now, in the past,
this has been a little bit challenging.

00:05:43.320 --> 00:05:46.470
It's actually not very easy to
just look at the source code of a

00:05:46.470 --> 00:05:51.060
game and intuitively figure out the
linear stream of OpenGL commands that

00:05:51.060 --> 00:05:52.440
it's going to send down to the GPU.

00:05:52.440 --> 00:05:55.730
Your game might end up doing a
lot more work than you thought,

00:05:55.830 --> 00:05:59.460
sending more commands that you realized,
or if you're traversing

00:05:59.510 --> 00:06:02.820
some data structure,
that might result in sending work

00:06:02.820 --> 00:06:06.860
to OpenGL in some unexpected order,
causing extra state changes.

00:06:07.440 --> 00:06:10.390
Or, you might just be doing
the wrong kind of work,

00:06:10.810 --> 00:06:14.610
either by having a lot of overhead
or going down some non-optimal path.

00:06:14.720 --> 00:06:17.840
And so,
actually measuring and analyzing the

00:06:17.840 --> 00:06:23.200
OpenGL activity coming from your game
becomes critical in knowing what's going

00:06:23.200 --> 00:06:26.200
on and understanding what you need to do.

00:06:28.000 --> 00:06:31.130
And now there's a great tool that
can help you with this called the

00:06:31.170 --> 00:06:34.200
OpenGL ES Analyzer Instrument.

00:06:34.310 --> 00:06:39.240
This is a new instrument included with
Xcode 4 that'll record and measure

00:06:39.240 --> 00:06:43.880
the OpenGL ES activity in your app,
analyze that data,

00:06:44.000 --> 00:06:48.060
and find specific correctness
and performance issues,

00:06:48.170 --> 00:06:52.020
and then provide you with
instructions on what to do about them.

00:06:52.520 --> 00:06:56.040
Now, the analyzer has three
main parts that you'll use.

00:06:56.190 --> 00:06:58.720
The first is the activity monitor.

00:06:58.810 --> 00:07:03.390
This records a trace of all the
OpenGL ES activity in your app,

00:07:03.440 --> 00:07:06.190
and provides you with statistics
about what's being called,

00:07:06.370 --> 00:07:09.000
how much time it took,
the number of calls,

00:07:09.220 --> 00:07:12.790
the stack trace that each
GL call was being made from,

00:07:12.860 --> 00:07:13.830
and so on.

00:07:14.470 --> 00:07:17.210
Then the second part are the overrides.

00:07:17.210 --> 00:07:21.740
And these are basically global
switches that will bypass specific

00:07:21.740 --> 00:07:24.740
parts of the graphics pipeline,
such as fragment processing

00:07:24.800 --> 00:07:25.930
or texture lookup.

00:07:25.980 --> 00:07:29.600
And by turning on and off
certain parts of the pipeline,

00:07:29.700 --> 00:07:34.560
you can very quickly identify where
your application is bottlenecked.

00:07:36.240 --> 00:07:39.980
And the third component
is the OpenGL ES Expert,

00:07:40.020 --> 00:07:41.800
and it's amazing.

00:07:41.840 --> 00:07:46.140
So this is an expert system
with knowledge of our hardware

00:07:46.270 --> 00:07:52.100
characteristics and the best practices
for our OpenGL ES implementation.

00:07:52.160 --> 00:07:55.240
And it watches the trace coming
into the activity monitor

00:07:55.300 --> 00:07:58.480
and looks at the statistics,
and then tells you exactly

00:07:58.480 --> 00:08:01.900
what trouble spots it sees,
and even better,

00:08:01.960 --> 00:08:04.350
exactly what you need to do to fix them.

00:08:04.380 --> 00:08:05.140
It's just incredible.

00:08:07.270 --> 00:08:11.800
So, let's take a look at a demo of
the OpenGL ES Analyzer instrument.

00:08:12.110 --> 00:08:14.230
Alright,
so first let's take a look at the

00:08:14.270 --> 00:08:16.400
demo that we're going to profile.

00:08:16.500 --> 00:08:19.190
I have it loaded on this phone here.

00:08:19.860 --> 00:08:25.460
So what you can see here is all of
this is being drawn in OpenGL ES.

00:08:25.470 --> 00:08:26.850
It's a bunch of 2D sprites.

00:08:26.900 --> 00:08:30.900
I'm drawing a quad for the background,
a quad for the spacecraft,

00:08:30.900 --> 00:08:34.060
and the fuel display,
and the lander at the bottom.

00:08:34.060 --> 00:08:38.570
And then all of these particles
floating in are quads as well.

00:08:38.960 --> 00:08:43.500
Okay, and I can move things around,
and the particles follow the spaceship.

00:08:43.500 --> 00:08:48.540
So it's a very simple demo,
not a very fun game.

00:08:48.540 --> 00:08:52.780
But it's what we'll be using to profile.

00:08:52.780 --> 00:08:58.530
So let's take a look at it now in
the OpenGL ES analyzer instrument.

00:08:58.530 --> 00:09:01.740
So I'm going to run the instrument here.

00:09:02.910 --> 00:09:06.790
And it comes up with,
and allows me to choose a template.

00:09:06.800 --> 00:09:10.090
I'm going to choose OpenGL ES Analysis.

00:09:13.370 --> 00:09:19.570
I'll choose my target,
which is this demo in its before state.

00:09:19.920 --> 00:09:22.790
Okay,
and now let me just start by running

00:09:22.790 --> 00:09:27.110
this application for just a few
seconds and collect some data,

00:09:27.120 --> 00:09:30.740
and then I'll give you a tour
around what you see being collected.

00:09:33.670 --> 00:09:38.890
So I'm capturing a few frames here,
and that's probably enough, 23,

00:09:39.060 --> 00:09:40.010
25 frames.

00:09:40.020 --> 00:09:46.440
Okay, so I start out in this view,
which is the OpenGL ES Analyzer Expert.

00:09:46.440 --> 00:09:50.680
And I'm actually going to come
back to this later in the talk,

00:09:50.830 --> 00:09:52.790
so let me skip over that for now.

00:09:52.800 --> 00:09:56.510
But by pulling down this tab,
you can see a lot of different

00:09:56.510 --> 00:10:01.020
statistics and different kinds of
data that we can get access to.

00:10:01.840 --> 00:10:05.050
And I want to start with
the frame statistics.

00:10:05.630 --> 00:10:10.540
So I ended up actually drawing 43 frames,
and you can see here the number

00:10:10.540 --> 00:10:13.080
of triangles that I've rendered,
the number of batches or

00:10:13.080 --> 00:10:16.520
draw calls that I've made,
the total number of GL calls,

00:10:16.520 --> 00:10:18.490
and redundant state changes.

00:10:18.500 --> 00:10:21.730
And actually,
I control what statistics are

00:10:21.810 --> 00:10:24.640
gathered up here by this disclosure.

00:10:24.640 --> 00:10:25.900
And so let me zoom into that.

00:10:26.050 --> 00:10:29.950
So this is a list here of the frame
statistics that I've chosen to observe,

00:10:29.990 --> 00:10:33.380
the batches, GL calls, state changes,
and triangles.

00:10:34.050 --> 00:10:37.160
And in this particular demo,
all I'm drawing are triangles.

00:10:37.160 --> 00:10:39.680
So that's why I've selected
triangles rendered here.

00:10:39.680 --> 00:10:42.650
But if I was drawing points
and lines or other objects,

00:10:42.650 --> 00:10:45.680
I'd probably want to look
at a few other statistics.

00:10:47.640 --> 00:10:50.570
But okay,
so let's take a look just first,

00:10:50.790 --> 00:10:52.180
what do we see here?

00:10:52.390 --> 00:10:56.170
Well,
down in the number of triangles rendered,

00:10:56.330 --> 00:10:59.400
each frame is only rendering
a thousand triangles,

00:10:59.430 --> 00:11:04.100
but it's taking me 500 GL draw
calls to actually render that.

00:11:04.250 --> 00:11:06.780
So that's 500 calls to GL draw arrays.

00:11:07.240 --> 00:11:10.980
And really,
it's not a very complex scene.

00:11:11.210 --> 00:11:15.040
And the next thing to look at is this,
the number of GL calls.

00:11:15.090 --> 00:11:21.040
So again, 500 objects are being
rendered on screen into quads.

00:11:21.130 --> 00:11:26.640
But it's taking nearly 8,000
OpenGL calls for me to draw that object.

00:11:26.660 --> 00:11:31.000
And so that means that there must be
a lot of state changes going on here.

00:11:31.350 --> 00:11:34.520
And then third, if I come over,
there's also a lot of redundant

00:11:34.580 --> 00:11:36.300
state changes happening.

00:11:36.370 --> 00:11:39.220
Almost a thousand per frame,
or basically two for every

00:11:39.220 --> 00:11:40.680
one of these batches.

00:11:40.720 --> 00:11:42.560
So that's something that
we'll want to take a look at.

00:11:42.740 --> 00:11:45.340
But so that's the frame statistics view.

00:11:45.340 --> 00:11:50.140
Okay,
so now let's look at the API statistics.

00:11:50.900 --> 00:11:55.330
So what this is,
is a list of all of the OpenGL calls

00:11:55.420 --> 00:11:56.800
your application is making.

00:11:56.800 --> 00:12:00.540
It tells you how many times
you're calling each routine,

00:12:00.540 --> 00:12:04.000
the total amount of time for each call,
and then the average

00:12:04.000 --> 00:12:05.080
of each call as well.

00:12:05.350 --> 00:12:10.610
So what I like to do here is to
sort this list by the total time,

00:12:10.610 --> 00:12:13.940
and look to see what calls are
really taking the most time.

00:12:14.000 --> 00:12:16.080
So let me zoom in.

00:12:16.540 --> 00:12:21.840
I would always expect for draw calls,
like GL draw arrays or GL draw elements,

00:12:21.880 --> 00:12:24.680
to dominate this graph
and to be up at the top.

00:12:24.780 --> 00:12:27.300
If they're not, that's something that
you should look into.

00:12:27.300 --> 00:12:32.380
But then the next thing to do is
to just try to see a few calls,

00:12:32.380 --> 00:12:36.940
what calls that are happening next,
that look like they're kind of expensive.

00:12:36.980 --> 00:12:38.970
And there's a few here.

00:12:38.980 --> 00:12:43.240
GL enable client state, GL bind texture,
GL disable client state.

00:12:43.240 --> 00:12:46.490
We're calling these a lot of times.

00:12:46.540 --> 00:12:50.870
And the total amount of time that
they're taking is rather significant.

00:12:50.900 --> 00:12:55.540
So now the trick for this, though,
is actually...

00:12:57.500 --> 00:12:59.980
If you don't know what you're
really looking for here,

00:12:59.980 --> 00:13:03.510
is to find the call to
Eagle Present Render Buffer,

00:13:03.670 --> 00:13:06.440
and then look at everything
that's above it in the list.

00:13:06.490 --> 00:13:10.800
And those are really the calls that
you can spend the most time on,

00:13:10.990 --> 00:13:14.340
and probably get the
most benefit from tuning.

00:13:16.050 --> 00:13:18.350
And so we have a pretty good
list here of different calls.

00:13:18.480 --> 00:13:22.860
Draw arrays, text image to load texture,
we have enable, and so on.

00:13:22.900 --> 00:13:25.040
And there's one more
thing that you can do,

00:13:25.060 --> 00:13:29.260
actually, and that's to enable
single frame navigation,

00:13:29.270 --> 00:13:31.230
and go and look at a particular frame.

00:13:31.340 --> 00:13:32.800
Say I'll just choose frame 25.

00:13:32.800 --> 00:13:37.430
And you can see which
calls here are being made,

00:13:37.430 --> 00:13:41.810
and exactly the count of how many
times they're being called per frame.

00:13:42.520 --> 00:13:47.290
And actually, this is already now telling
me about a likely problem.

00:13:47.310 --> 00:13:53.460
I'm calling GL draw arrays 500 times,
GL enable almost twice

00:13:53.600 --> 00:13:56.330
for every draw arrays,
and enable and disable client

00:13:56.450 --> 00:13:59.400
state twice for every draw arrays,
and so on.

00:13:59.510 --> 00:14:04.200
So I can see that I'm really doing a lot
of work for every call to draw arrays.

00:14:04.220 --> 00:14:08.070
And the reason why this is
important is because each of those

00:14:08.140 --> 00:14:12.400
calls to draw arrays is really
only resulting in a single call.

00:14:12.420 --> 00:14:20.660
And so this is a lot of overhead being
set up for really very little output.

00:14:20.680 --> 00:14:24.710
Okay, so that's what the
API statistics can show you.

00:14:26.580 --> 00:14:29.730
Then next,
I'll show you just the call trees.

00:14:29.860 --> 00:14:36.960
So this is a lot like the API analyzer
where you can just see the call trees

00:14:37.070 --> 00:14:41.750
for each of the rendering calls in your
app and how much time they're taking.

00:14:41.780 --> 00:14:44.480
So in this case,
I don't need to go into that,

00:14:44.480 --> 00:14:48.190
but it's there for you if you
want to take advantage of it.

00:14:48.960 --> 00:14:50.780
And then last is the trace.

00:14:50.850 --> 00:14:55.840
So really, this is where I like to
spend the most time when I'm

00:14:55.920 --> 00:15:00.870
analyzing an OpenGL application,
is to just look and see what calls

00:15:00.870 --> 00:15:03.460
are really being made every frame.

00:15:03.460 --> 00:15:08.330
And this is the best way for you to
actually see the linear trace of calls

00:15:08.330 --> 00:15:14.130
if you have really complex source code or
some intricate data structure that you're

00:15:14.130 --> 00:15:17.080
using that's resulting in all of this.

00:15:17.720 --> 00:15:21.760
And so the trick to do,
as I zoom in on this,

00:15:23.160 --> 00:15:28.340
And what you should do is try to think
of how your code is structured and try

00:15:28.340 --> 00:15:33.370
to correlate what you see in this list
to one object being drawn on screen.

00:15:33.380 --> 00:15:37.950
And here, for example,
I can see that all of this

00:15:38.450 --> 00:15:41.750
is correlating to one object.

00:15:42.200 --> 00:15:46.140
Because I know from my code that every
object starts with a call to push matrix,

00:15:46.140 --> 00:15:49.490
and then a translation,
some state gets set up,

00:15:49.790 --> 00:15:52.260
and then finally here
I call GLDrawArrays.

00:15:52.700 --> 00:15:55.650
And then I unwind all that, pop matrix,
and call getError.

00:15:55.690 --> 00:16:01.710
So these are the calls that I am making
per object for everything in the scene.

00:16:01.790 --> 00:16:06.600
So every particle, the background,
the lander, and so on.

00:16:06.660 --> 00:16:11.590
And so what we'll do is take a
look at this now and see if there's

00:16:11.590 --> 00:16:14.660
ways to optimize calls out of this.

00:16:14.820 --> 00:16:19.900
Now, if you have a lot of different
objects and kinds of objects,

00:16:19.920 --> 00:16:23.240
you might have to do,
you might have to repeat this process

00:16:23.330 --> 00:16:27.150
two or three times or multiple times
to go back and really cover all

00:16:27.150 --> 00:16:29.340
of the cases that are in your app.

00:16:29.370 --> 00:16:30.430
In mine, it's pretty simple.

00:16:30.450 --> 00:16:34.580
Everything is just being drawn as a quad,
and it's being drawn using these,

00:16:34.920 --> 00:16:39.080
generally the same routines here,
just changing the position and

00:16:39.130 --> 00:16:41.250
changing the texture for each one.

00:16:41.290 --> 00:16:43.720
But so that's the API trace.

00:16:46.550 --> 00:16:49.960
All right, again, that was the
OpenGL ES Analyzer instrument,

00:16:49.960 --> 00:16:54.580
which is going to help you measure
and analyze the OpenGL ES activity

00:16:54.580 --> 00:16:55.980
in your application.

00:16:56.090 --> 00:17:00.240
So you just saw the frame statistics,
the API stats, the command trace,

00:17:00.240 --> 00:17:01.620
and the call trees.

00:17:01.710 --> 00:17:04.720
And at the end of the talk,
I'll go into more detail

00:17:04.730 --> 00:17:07.100
about the Analyzer Expert.

00:17:07.610 --> 00:17:10.890
So now let's go back and remember
some of the problems we found.

00:17:11.040 --> 00:17:13.740
The first thing we found
was that in this demo,

00:17:13.820 --> 00:17:17.950
the number of triangles
per batch was much too low.

00:17:18.130 --> 00:17:20.780
Each frame of the demo
had 500 draw calls,

00:17:20.900 --> 00:17:24.460
and this resulted in only
1,000 triangles on screen.

00:17:24.580 --> 00:17:27.440
And what this really indicates
is that your vertex arrays

00:17:27.760 --> 00:17:29.850
are just much too short.

00:17:30.030 --> 00:17:34.420
Only sending two triangles here for
each draw call is just terrible.

00:17:34.550 --> 00:17:40.100
So you want to try to minimize the number
of batches and make that ratio much,

00:17:40.100 --> 00:17:43.720
much higher, so that each batch,
each draw call,

00:17:43.860 --> 00:17:47.300
takes care of a lot of triangles.

00:17:48.260 --> 00:17:50.000
Problem number two.

00:17:50.040 --> 00:17:52.590
The number of GL calls
for each batch was much,

00:17:52.760 --> 00:17:54.790
much too high.

00:17:54.990 --> 00:17:58.660
So this indicates that we're carrying
around a lot of overhead for every

00:17:58.660 --> 00:18:00.890
object that's being drawn on screen.

00:18:00.980 --> 00:18:03.700
And what this means is that
there's a lot of state management

00:18:03.700 --> 00:18:06.610
happening between each draw call.

00:18:06.680 --> 00:18:11.840
In this case we have 500 draw calls
and nearly 8,000 GL calls per frame,

00:18:11.840 --> 00:18:16.470
which is about 16 to 1, and that's much,
much too high.

00:18:16.590 --> 00:18:20.290
You really want to minimize the
number of GL commands that are being

00:18:20.290 --> 00:18:22.850
issued for each of your draw calls.

00:18:23.370 --> 00:18:26.190
Then third, redundant state changes.

00:18:26.300 --> 00:18:28.900
So these are just totally unnecessary.

00:18:29.000 --> 00:18:31.740
When you see these happening,
it means that you've changed

00:18:31.740 --> 00:18:35.270
the OpenGL state to the same
value that it already had,

00:18:35.310 --> 00:18:37.280
which is totally redundant.

00:18:37.400 --> 00:18:41.280
But it still causes work to
occur in the implementation.

00:18:41.470 --> 00:18:45.530
So if this is happening,
it's something that has ultimately no

00:18:45.530 --> 00:18:49.710
effect and just doesn't need to occur,
which is a perfect thing to optimize.

00:18:49.720 --> 00:18:54.340
So we'll need to make changes in our
code to avoid making redundant calls.

00:18:57.230 --> 00:19:00.940
Now fourth, on to the API Statistics view
and things to look for there.

00:19:01.110 --> 00:19:04.420
Well first, as I said,
we expect to see GLDraw arrays

00:19:04.430 --> 00:19:08.540
or GLDraw elements dominating
the total time on this graph.

00:19:08.660 --> 00:19:10.830
Of course, if it's not,
that's something to look into,

00:19:10.850 --> 00:19:12.740
but it is at the top here.

00:19:12.930 --> 00:19:16.580
So the next thing to look
at are the next few commands

00:19:16.580 --> 00:19:18.420
that are taking the most time.

00:19:18.610 --> 00:19:23.400
And see if these are things that can
be eliminated one way or the other.

00:19:23.690 --> 00:19:26.160
And specifically,
my rule of thumb is to find

00:19:26.260 --> 00:19:30.600
everything with a higher total time
than Eagle Present Render Buffer.

00:19:30.690 --> 00:19:34.470
And tuning those calls will
give you the most payoff.

00:19:35.630 --> 00:19:39.260
And then finally,
look at the command trace itself,

00:19:39.260 --> 00:19:43.400
because this is really telling you the
truth about your application's rendering.

00:19:43.400 --> 00:19:47.200
And the best way to do this is to
enable single frame navigation,

00:19:47.200 --> 00:19:49.950
then go to a frame that
you want to look at,

00:19:50.000 --> 00:19:53.320
and try to identify the calls
that correlate to the various

00:19:53.580 --> 00:19:55.520
objects being drawn on screen.

00:19:55.570 --> 00:19:59.920
Now, in my demo, it's easy to find,
because I know that every object

00:19:59.990 --> 00:20:03.140
starts with a call to GL Push Matrix,
and ends with

00:20:03.220 --> 00:20:05.510
GL Pop Matrix and GL Get Error.

00:20:05.640 --> 00:20:10.300
So now I can look at this,
and really understand what's happening

00:20:10.300 --> 00:20:12.080
in GL for every object I draw.

00:20:12.110 --> 00:20:15.640
And this is a lot,
16 GL commands per object.

00:20:15.790 --> 00:20:18.480
So you should do the same thing.

00:20:18.780 --> 00:20:21.460
Try to find the different
objects you draw,

00:20:21.460 --> 00:20:25.160
and see what work is really
being done on their behalf.

00:20:26.600 --> 00:20:29.670
So let's take this example now and
really dig into it line by line.

00:20:29.700 --> 00:20:32.570
So here it is.

00:20:32.860 --> 00:20:35.690
This is what I'm doing for
every object in my scene.

00:20:35.740 --> 00:20:40.630
The ship, the thrusters, each particle,
the background, and so on.

00:20:41.000 --> 00:20:43.610
So for each object,
I'm starting with a push matrix

00:20:43.680 --> 00:20:48.450
and applying a transformation to
position that object on screen.

00:20:49.130 --> 00:20:51.240
Then here I'm setting up my state.

00:20:51.340 --> 00:20:56.170
I'm enabling texture and binding the
appropriate texture ID for this object,

00:20:56.170 --> 00:20:59.770
and enabling blending and setting
up the blend function for something

00:20:59.830 --> 00:21:02.110
appropriate for an alpha texture.

00:21:03.120 --> 00:21:06.060
Then I enable some client
state for a vertex array and

00:21:06.060 --> 00:21:09.980
a texture coordinate array,
and set up pointers to those arrays with

00:21:10.120 --> 00:21:12.800
GL vertex pointer and text cord pointer.

00:21:12.920 --> 00:21:15.620
And then I draw the object by
calling GL draw arrays with a

00:21:15.620 --> 00:21:20.400
triangle strip with four vertices,
so that's two triangles or a quad.

00:21:22.040 --> 00:21:25.300
Now here's where I undo those
state changes that I made above.

00:21:25.300 --> 00:21:29.700
I disable the client state and set this
blend function back to the default.

00:21:29.910 --> 00:21:32.400
And then pop the matrix
transformation stack.

00:21:32.610 --> 00:21:35.260
And I call glGetError just to
make sure that I'll catch any

00:21:35.300 --> 00:21:37.570
errors that might have happened.

00:21:37.780 --> 00:21:41.760
Now remember, all of this is being
done for every object,

00:21:41.900 --> 00:21:44.990
every particle, and so on in the demo.

00:21:45.350 --> 00:21:49.640
So, the thing to understand about
this is that everything you

00:21:49.640 --> 00:21:52.520
see here is totally valid code.

00:21:52.660 --> 00:21:58.260
It's syntactically correct,
it's a valid usage of OpenGL ES 1.1

00:21:58.260 --> 00:22:01.650
in terms that there's no errors here,
and the results on screen

00:22:01.750 --> 00:22:05.290
are obviously correct,
you just saw them in the demo.

00:22:05.420 --> 00:22:09.030
But actually, everything about this
is just totally wrong,

00:22:09.240 --> 00:22:10.660
every single line.

00:22:10.660 --> 00:22:12.560
And so we'll spend the
rest of the talk fixing it.

00:22:12.580 --> 00:22:16.780
And in particular, this line.

00:22:16.780 --> 00:22:19.250
I see this a lot,
where every quad is being

00:22:19.260 --> 00:22:23.600
drawn as a separate triangle
strip with four vertices.

00:22:23.600 --> 00:22:25.880
Or I've seen some apps doing
the same thing with independent

00:22:25.920 --> 00:22:27.490
triangles and six vertices.

00:22:29.060 --> 00:22:33.320
And if you're doing this,
if this is what you're using to

00:22:33.370 --> 00:22:36.870
do the heavy lifting in your game,
and specifically,

00:22:36.950 --> 00:22:40.150
I mean that if your game does
a heavy amount of drawing,

00:22:40.280 --> 00:22:44.100
and most or all of that drawing
is through calls to GL draw

00:22:44.100 --> 00:22:48.700
arrays with only four vertices,
then let this be the alarm bell that

00:22:48.700 --> 00:22:53.290
tells you that something is seriously
wrong and needs to be changed.

00:22:54.080 --> 00:22:57.080
So, I'll show you what to do with
this in part three of the talk,

00:22:57.080 --> 00:23:00.130
but for the moment,
let's not get too far ahead of ourselves,

00:23:00.210 --> 00:23:03.130
and let's see what we need
to do to reduce the number

00:23:03.140 --> 00:23:04.950
of state changes in this app.

00:23:06.540 --> 00:23:09.340
So let me start just by
reviewing the concept.

00:23:09.420 --> 00:23:12.640
So at any given moment,
OpenGL ES defines a current

00:23:12.640 --> 00:23:15.040
state of the rendering pipeline.

00:23:15.220 --> 00:23:19.000
And this is all done atomically
by doing things like setting the

00:23:19.000 --> 00:23:23.220
current matrix transformation or
blending function in OpenGL ES 1.1,

00:23:23.220 --> 00:23:27.770
or binding a vertex program
and fragment program in ES 2.0.

00:23:27.980 --> 00:23:31.130
And in this example,
when it's time to draw something,

00:23:31.130 --> 00:23:35.510
then the current 1.1 state will
be compiled and cached away,

00:23:35.510 --> 00:23:38.140
and whatever's being drawn will
take advantage of that state.

00:23:39.660 --> 00:23:43.110
And if the next object to be
drawn can also use that state,

00:23:43.110 --> 00:23:44.360
then it's very efficient.

00:23:44.480 --> 00:23:47.760
It can go through the entire
pipeline without changing anything,

00:23:47.760 --> 00:23:48.930
and that's very fast.

00:23:48.940 --> 00:23:52.760
But if the next object to be drawn
needs to change a lot of state,

00:23:52.820 --> 00:23:58.040
maybe because it uses a different texture
or needs a different blending function,

00:23:58.040 --> 00:24:02.630
then conceptually, we need to stop,
compile, and cache that new state,

00:24:02.630 --> 00:24:04.940
and then go on to draw that object.

00:24:05.620 --> 00:24:10.470
And that little bit of time taken
to set up the new state can really

00:24:10.470 --> 00:24:14.330
add up if it's changing a lot or
changing for everything you draw.

00:24:15.770 --> 00:24:19.690
So instead, if performance is a
limiting factor for you,

00:24:20.130 --> 00:24:23.740
then you should design your
rendering code around the idea

00:24:23.890 --> 00:24:26.030
of minimizing state changes.

00:24:26.070 --> 00:24:28.520
And how you do this will be
very dependent on the drawing

00:24:28.520 --> 00:24:29.590
requirements of your game.

00:24:29.630 --> 00:24:32.730
But there's three really
simple techniques that can

00:24:33.020 --> 00:24:34.890
have a pretty dramatic effect.

00:24:37.840 --> 00:24:43.100
So the first has to do with eliminating
redundant or repetitive state changes.

00:24:43.180 --> 00:24:46.730
So the first item is something that
the OpenGL ES Analyzer instrument

00:24:46.780 --> 00:24:50.570
makes really easy to find,
and those are redundant state changes,

00:24:50.880 --> 00:24:56.320
or cases where you're setting the state
to the same value that it already has.

00:24:56.340 --> 00:25:00.470
And the way to eliminate that is
to just keep track of important

00:25:00.470 --> 00:25:02.480
state elements yourself.

00:25:02.510 --> 00:25:06.040
Like for example,
keep a variable around that holds the

00:25:06.040 --> 00:25:09.860
ID of the currently bound texture,
and keep another that tracks

00:25:09.920 --> 00:25:12.320
the current blend function,
and so on.

00:25:12.350 --> 00:25:16.040
And then before you bind a new texture,
or set a new blend function,

00:25:16.200 --> 00:25:19.240
check the value that you're
already holding in your variable.

00:25:19.270 --> 00:25:21.690
And if it's the same,
then don't bother issuing

00:25:21.690 --> 00:25:23.020
that command to OpenGL.

00:25:23.170 --> 00:25:25.440
It's already in that state.

00:25:25.470 --> 00:25:30.190
And all you'll be doing is making
OpenGL redo its validation in this

00:25:30.190 --> 00:25:33.760
new state that you're setting,
and ultimately it would just end

00:25:33.850 --> 00:25:35.680
up right back at the same place.

00:25:35.700 --> 00:25:40.000
Now the second item is something the
Analyzer won't necessarily find for you,

00:25:40.010 --> 00:25:43.440
but it's easy to spot
in the command trace.

00:25:43.450 --> 00:25:48.260
And it's to avoid the situation
where you have unnecessary symmetry

00:25:48.620 --> 00:25:52.800
in the way that you're enabling
and disabling various state.

00:25:52.860 --> 00:25:56.400
So don't fall into the trap of
setting up a bunch of state,

00:25:56.410 --> 00:25:58.740
drawing something,
and then cleaning up all

00:25:58.740 --> 00:26:01.600
the state you just said,
just in case something comes along

00:26:01.600 --> 00:26:03.960
that needs to do something different.

00:26:04.200 --> 00:26:07.990
The next object may actually
need to be drawn with the same

00:26:07.990 --> 00:26:10.840
state as the first one you did.

00:26:10.840 --> 00:26:14.000
So then you'll just have to go and make
all those same state changes again,

00:26:14.000 --> 00:26:16.800
if you had cleaned them up.

00:26:17.120 --> 00:26:18.860
And you saw this in the demo code.

00:26:18.900 --> 00:26:22.730
Every object is setting a particular
blend function and then restoring it to

00:26:22.760 --> 00:26:24.790
the default after that object is drawn.

00:26:25.300 --> 00:26:28.390
And then the next object comes along
and repeats that whole process again.

00:26:28.390 --> 00:26:32.740
And there's 500 objects doing that
same process in that particular demo.

00:26:33.460 --> 00:26:37.940
And it's easier and faster if you
just track the current state and

00:26:37.940 --> 00:26:42.430
get rid of any notion that after
you change the state that you need

00:26:42.430 --> 00:26:44.630
to put it back the way it was.

00:26:44.630 --> 00:26:47.300
Instead,
just be lazy about state changes and

00:26:47.300 --> 00:26:51.630
wait until some object comes along that
needs to be rendered with a different

00:26:51.630 --> 00:26:53.760
state than what's currently set.

00:26:53.840 --> 00:26:57.350
Only actually make the change
then when that happens.

00:26:57.380 --> 00:27:02.370
And then third is that you should try
to hoist up any repetitive changes.

00:27:03.380 --> 00:27:07.480
Meaning to bring them up out of
the per object rendering routine.

00:27:07.480 --> 00:27:11.840
Maybe there's certain states that you're
setting for every object or for many,

00:27:11.840 --> 00:27:12.700
many objects.

00:27:12.700 --> 00:27:16.530
And rather than setting that
state every time for every object,

00:27:16.530 --> 00:27:19.540
just set it once or maybe
once per frame or once for a

00:27:19.540 --> 00:27:21.440
particular group of objects.

00:27:21.530 --> 00:27:24.520
And then don't change it
on a per object basis.

00:27:26.900 --> 00:28:50.500
[Transcript missing]

00:28:51.380 --> 00:28:55.170
So to go even further and to
be a little more concrete,

00:28:55.170 --> 00:28:59.570
what I really recommend is to change
the order as I've described here.

00:28:59.590 --> 00:29:03.730
Start by separating your
rendering code to actually draw

00:29:03.800 --> 00:29:07.730
all of the opaque objects first,
and then all the non-opaque objects.

00:29:07.810 --> 00:29:11.920
Then within each of those routines,
order your rendering based on the

00:29:11.920 --> 00:29:15.710
texture that needs to be bound,
or the shader your objects use,

00:29:15.710 --> 00:29:16.440
and so on.

00:29:16.440 --> 00:29:20.300
And this can really save you from
making a lot of state changes.

00:29:20.820 --> 00:29:25.230
And a third way to eliminate state
changes that's especially relevant

00:29:25.230 --> 00:29:29.320
for most games is to combine
multiple individual textures,

00:29:29.320 --> 00:29:32.970
if you have them,
into a single larger texture atlas.

00:29:33.090 --> 00:29:37.230
So looking at this example,
here's three of the textures for my game,

00:29:37.230 --> 00:29:40.870
a starry background texture,
and two more little textures,

00:29:40.870 --> 00:29:44.380
one for my lander and the
other for the alien spaceship.

00:29:44.380 --> 00:29:47.810
And if I've just set these up
as three separate textures,

00:29:47.810 --> 00:29:51.690
then it means I have to bind texture one,
and draw a quad.

00:29:51.690 --> 00:29:55.220
Then bind texture two, and draw a quad.

00:29:55.330 --> 00:29:57.320
Bind texture three, and draw a quad.

00:29:58.160 --> 00:30:01.900
Okay, so that's three texture
binds and three draw calls.

00:30:01.900 --> 00:30:06.020
But instead,
if I were to combine these three textures

00:30:06.160 --> 00:30:11.330
together into a single texture atlas,
then I could just bind that whole atlas

00:30:11.330 --> 00:30:18.540
and use different texture coordinates
to pick out which sub-region I want,

00:30:18.590 --> 00:30:19.860
then draw, draw,
and draw to get the same result.

00:30:19.860 --> 00:30:23.300
One texture bind instead of three.

00:30:23.300 --> 00:30:26.240
And if you have a lot of
small textures in your app,

00:30:26.630 --> 00:30:30.170
then you can perhaps reduce all of
them down to just one texture atlas.

00:30:30.490 --> 00:30:36.220
All of the more recent devices support
textures sized up to 2048 by 2048,

00:30:36.710 --> 00:30:37.440
which is pretty big.

00:30:37.490 --> 00:30:40.230
And you can have more
than one texture atlas,

00:30:40.580 --> 00:30:40.880
too.

00:30:40.880 --> 00:30:44.680
So this is another really
powerful technique for reducing

00:30:44.680 --> 00:30:47.200
the number of state changes.

00:30:47.570 --> 00:30:51.440
All right, so now let's go back to our
code and apply those changes.

00:30:51.610 --> 00:30:53.340
First, this texture enable.

00:30:53.410 --> 00:30:56.700
Well, every object in our game
needs to have texture enabled,

00:30:56.780 --> 00:30:59.130
and we never disable texture.

00:30:59.290 --> 00:31:02.380
So after we've done this once,
it becomes totally redundant to

00:31:02.380 --> 00:31:04.940
do it again 500 times a frame.

00:31:05.070 --> 00:31:08.770
So we can lift this out of the loop
and just enable it once per frame

00:31:08.840 --> 00:31:12.200
or in some initialization routine.

00:31:12.650 --> 00:31:14.700
Okay, now this texture bind.

00:31:14.750 --> 00:31:18.330
This is currently binding a
different texture for every object,

00:31:18.350 --> 00:31:22.420
when we could just create a texture
atlas with all our textures,

00:31:22.430 --> 00:31:26.800
and then hoist this call up out of the
loop and just do it once per frame,

00:31:26.810 --> 00:31:29.490
or when it actually needs to change.

00:31:30.290 --> 00:31:33.480
Okay, next, this call to enable blending.

00:31:33.480 --> 00:31:35.200
It's just the same as the
call to enable texture.

00:31:35.220 --> 00:31:36.080
It's redundant.

00:31:36.080 --> 00:31:39.660
And after we've done it once,
we can just leave it enabled.

00:31:39.680 --> 00:31:43.440
So this can get lifted up to an
initialization routine somewhere.

00:31:45.350 --> 00:31:48.300
Okay, now these calls,
they're necessary too,

00:31:48.300 --> 00:31:51.670
but you'll notice that we're
also disabling them after

00:31:51.670 --> 00:31:53.010
the call to GLDrawRays.

00:31:53.060 --> 00:31:56.660
So this is one of those cases
of unnecessary symmetry.

00:31:56.800 --> 00:31:59.620
So likewise,
we could just set this at the beginning

00:31:59.620 --> 00:32:03.350
of the frame and keep track of it,
and only change it if some object

00:32:03.370 --> 00:32:05.510
needs to be drawn with it changed.

00:32:05.520 --> 00:32:08.410
But either way,
this will get hoisted out of the list

00:32:08.410 --> 00:32:10.410
of calls we need to make per object.

00:32:10.530 --> 00:32:12.810
Okay, so now let's take a look.

00:32:13.210 --> 00:32:14.730
Here's the changes so far.

00:32:16.110 --> 00:32:19.910
So we've hoisted all of the state
changes out of the per object loop,

00:32:19.910 --> 00:32:25.400
mostly by removing redundant changes and
consolidating our textures into an atlas.

00:32:25.470 --> 00:32:29.230
Now, if you had more states to manage,
your app might do these calls per

00:32:29.230 --> 00:32:31.430
frame instead of just once it started.

00:32:31.600 --> 00:32:35.040
But either way,
moving these calls out of the per

00:32:35.040 --> 00:32:37.700
object loop is really important.

00:32:37.750 --> 00:32:41.500
Okay, so now let's move on to
optimize what's left.

00:32:41.610 --> 00:32:44.940
and we'll focus next on
optimizing the draw calls.

00:32:47.010 --> 00:32:49.200
And I have a few good tips
to give for this topic.

00:32:49.200 --> 00:32:53.540
The first is to cull
any off-screen objects.

00:32:53.600 --> 00:32:57.380
The basic idea here is that
OpenGL ES is going to process

00:32:57.550 --> 00:33:01.310
every command you send to it,
even if after a particular

00:33:01.310 --> 00:33:05.270
object has been transformed,
it turns out to be off-screen someplace

00:33:05.310 --> 00:33:07.600
and doesn't contribute to the scene.

00:33:07.660 --> 00:33:09.770
Well, instead,
if you have a simple way to

00:33:09.900 --> 00:33:13.300
calculate whether an object
will wind up off-screen,

00:33:13.380 --> 00:33:16.580
then there's no need for you to
render it in the first place.

00:33:16.600 --> 00:33:19.750
All that work is something
that just can be avoided.

00:33:21.160 --> 00:33:24.500
In calculating whether an
object is on or off screen in

00:33:24.500 --> 00:33:26.840
a 2D game is generally trivial.

00:33:26.910 --> 00:33:31.590
Just a simple position check against
the bounds of the visible area,

00:33:31.590 --> 00:33:36.310
or an axis-aligned bounding box check,
which is simple addition or subtraction,

00:33:36.440 --> 00:33:40.560
and this might save you the
work of a whole series of

00:33:40.560 --> 00:33:43.300
state changes and draw calls.

00:33:43.340 --> 00:33:45.220
So you would do this
check for each object.

00:33:45.220 --> 00:33:49.370
So imagine that this is my whole level,
and I have enemy spaceships

00:33:49.380 --> 00:33:52.140
scattered around,
and perhaps this is the area

00:33:52.140 --> 00:33:53.700
that's actually visible right now.

00:33:53.770 --> 00:33:57.980
So anything entirely outside
of this imaginary boundary

00:33:57.980 --> 00:33:59.700
doesn't need to be drawn.

00:33:59.890 --> 00:34:03.210
So as I iterate through
the objects in my scene,

00:34:03.210 --> 00:34:07.890
I'm only going to issue draw calls
for the five objects that can be

00:34:07.960 --> 00:34:11.300
seen in this frame instead of all 16.

00:34:12.300 --> 00:34:14.960
And if in a later frame
I had panned around,

00:34:14.960 --> 00:34:19.080
then I'd get a different result,
and I'd only draw those objects.

00:34:20.250 --> 00:34:23.820
It's a simple concept,
but really important to apply if you have

00:34:23.820 --> 00:34:26.740
a scene with a lot of off-screen objects.

00:34:26.800 --> 00:34:29.710
Now the second thing to do,
particularly in 2D games

00:34:29.790 --> 00:34:33.440
where there's a lot of quads,
is to flatten the transformations

00:34:33.440 --> 00:34:36.920
you'd normally apply with
GeoRotate and GeoTranslate or

00:34:36.930 --> 00:34:42.420
GeoMultMatrix into the values of
the vertex positions themselves.

00:34:42.460 --> 00:34:47.440
And ultimately what this is going to do
is to let you make longer vertex arrays,

00:34:47.440 --> 00:34:49.420
which is the next recommendation.

00:34:49.500 --> 00:34:53.790
But to be more specific,
it's very typical for a 2D app

00:34:53.950 --> 00:34:57.760
to define the vertex positions
of its quads about the origin,

00:34:57.860 --> 00:35:02.180
like -0.5 to +0.5 in X and Y.

00:35:02.250 --> 00:35:07.340
And then apply transformations by
calling GeoTranslate and GeoRotate,

00:35:07.430 --> 00:35:10.090
and then issuing a draw
call just for that quad,

00:35:10.100 --> 00:35:13.690
and then going on to the next one
and repeating that whole process.

00:35:13.930 --> 00:35:16.320
Well instead,
what you can do is calculate

00:35:16.650 --> 00:35:21.690
that transformation yourself
on the CPU and put those values

00:35:21.690 --> 00:35:24.520
directly into your vertex array.

00:35:24.560 --> 00:35:27.600
Then next I'll show you how to
combine those arrays together.

00:35:27.670 --> 00:35:31.280
Now this is something that
3D games can do as well,

00:35:31.280 --> 00:35:37.100
but in 2D games it's absolutely trivial,
even with thousands of vertices.

00:35:37.130 --> 00:35:41.400
And it's because calculating 2D
transformations is such simple math.

00:35:41.460 --> 00:35:44.540
A 2D translation is just
addition and subtraction,

00:35:44.540 --> 00:35:47.610
and a rotate is just sine and cosine.

00:35:47.930 --> 00:35:50.690
Let's talk about what
we do with the result.

00:35:51.400 --> 00:35:55.460
So the reason why we flatten the
transformation into the vertex

00:35:55.460 --> 00:36:00.630
array data is so we can put multiple
objects together into the same array.

00:36:00.640 --> 00:36:04.870
And the concept behind this
stems from the fact that vertex

00:36:04.960 --> 00:36:07.480
arrays are meant to be very long.

00:36:07.580 --> 00:36:12.570
They're meant to be a way of sending a
lot of data to the GPU very efficiently.

00:36:12.580 --> 00:36:16.360
So the opposite,
using a whole bunch of really short

00:36:16.380 --> 00:36:19.330
arrays totally defeats the purpose.

00:36:19.560 --> 00:36:21.810
And we need to find ways
to join them together.

00:36:21.840 --> 00:36:25.430
And that's possible if you
have multiple vertex arrays

00:36:25.540 --> 00:36:28.680
that all share the same state,
including the transformation.

00:36:28.680 --> 00:36:33.170
And if you flatten the transformations
into the vertex data itself,

00:36:33.170 --> 00:36:35.670
then they probably have
no other transformations.

00:36:35.680 --> 00:36:39.090
Or maybe you can just have the same
overall transformation in common,

00:36:39.090 --> 00:36:40.130
which is perfect.

00:36:40.240 --> 00:36:42.480
Now,
to actually join them together depends

00:36:42.480 --> 00:36:46.040
on whether you're using independent
triangles or triangle strips.

00:36:46.040 --> 00:36:49.540
With independent triangles,
there really isn't much.

00:36:49.630 --> 00:36:50.290
There isn't much work to do at all.

00:36:50.580 --> 00:36:54.040
You just make the array big enough
and keep adding triangles to it,

00:36:54.230 --> 00:36:57.140
and make it as long as possible
for as many triangles as you

00:36:57.140 --> 00:36:59.030
have that share the same state.

00:37:00.410 --> 00:37:03.300
But the other possibility,
and what I'm showing here,

00:37:03.300 --> 00:37:04.700
is if you use triangle strips.

00:37:04.780 --> 00:37:10.220
We still want to create a single long
array that combines them all together,

00:37:10.350 --> 00:37:14.120
but how do you handle the separation
between the original arrays?

00:37:14.340 --> 00:37:19.870
Well, we use something called degenerate
triangles to join these strips together.

00:37:19.870 --> 00:37:25.210
And what we do is to repeat the
first and last vertex of each strip.

00:37:25.210 --> 00:37:29.890
The result is one longer strip,
and the repeated vertices

00:37:29.900 --> 00:37:31.480
never get rasterized.

00:37:31.480 --> 00:37:35.260
So the strips will appear to
be separately placed on screen,

00:37:35.380 --> 00:37:41.250
but they're able to be submitted to
the GPU together in a single draw call.

00:37:41.700 --> 00:37:48.060
So here we have triangles ABC, BCD,
and CDE, which get rasterized normally.

00:37:48.060 --> 00:37:56.640
And then still, in the same strip,
we have DEE, and EEF, and EFF, and FFG,

00:37:56.640 --> 00:37:59.530
which are really lines, not triangles.

00:37:59.530 --> 00:38:02.800
So they're not valid,
and nothing gets rasterized.

00:38:02.800 --> 00:38:05.910
And then finally we get
back to triangles again,

00:38:05.970 --> 00:38:07.840
with FGH, GHI, and HIJ.

00:38:08.330 --> 00:38:13.030
So in this example,
instead of two strips with two draw

00:38:13.030 --> 00:38:18.440
calls and three triangles each,
we get one strip, or one draw call,

00:38:18.440 --> 00:38:21.240
with six triangles that
actually get rasterized.

00:38:21.260 --> 00:38:25.810
And we just keep applying that for
all of the objects in the scene.

00:38:27.590 --> 00:38:31.180
Now, either of those techniques are
fantastic for the situation

00:38:31.180 --> 00:38:34.130
that hopefully we're in now,
where we've sorted all of

00:38:34.130 --> 00:38:37.220
our rendering by state,
we're using texture atlases

00:38:37.220 --> 00:38:39.960
to hold all of our textures
and cut down on state changes,

00:38:39.960 --> 00:38:43.600
and we flatten transformations
into our vertex array data.

00:38:43.840 --> 00:38:47.430
So if we can also make longer arrays,
either by switching over to

00:38:47.480 --> 00:38:51.550
independent triangles and just
throwing them all into a big array,

00:38:51.550 --> 00:38:55.390
or by taking our triangle strips
and using degenerate triangles

00:38:55.390 --> 00:38:58.740
to join them all together,
then in many cases,

00:38:58.740 --> 00:39:03.320
we could end up drawing all of
our quads in our game in one or

00:39:03.600 --> 00:39:06.380
sometimes just a few draw calls.

00:39:06.470 --> 00:39:09.570
So let's say these five
quads were defined as strips

00:39:09.570 --> 00:39:13.460
with four vertices each,
and they all share the same state.

00:39:13.840 --> 00:39:17.200
They're all sorted, texture atlased,
and flattened.

00:39:18.660 --> 00:39:23.600
Then I can combine all of these
together into one single vertex array,

00:39:23.640 --> 00:39:27.780
and I combine one texture atlas,
and I set the vertex pointer,

00:39:27.780 --> 00:39:30.060
and do the same work for my
texture coordinate array,

00:39:30.060 --> 00:39:34.580
and then draw my entire scene
in one call to GLDrawArrays.

00:39:34.760 --> 00:39:39.110
And the performance difference
between this and what we started

00:39:39.180 --> 00:39:41.460
with would just be incredible.

00:39:41.480 --> 00:39:44.150
All right,
so now let's go back to our code

00:39:44.150 --> 00:39:46.200
and apply those changes too.

00:39:46.400 --> 00:39:47.730
So for each object.

00:39:48.510 --> 00:39:49.960
Well, actually,
we're going to change this.

00:39:50.250 --> 00:39:54.960
And instead of drawing each object,
we're first going to calculate whether

00:39:54.960 --> 00:39:59.350
that object will be visible on screen,
and only proceed if it is.

00:40:01.510 --> 00:40:04.100
Okay, now here's our transformations.

00:40:04.190 --> 00:40:08.950
We'll remove these by flattening
them into our vertex array data.

00:40:09.430 --> 00:40:14.100
And here's where we set up the pointers
to our arrays and call GLDrawArrays.

00:40:14.230 --> 00:40:17.840
Well, this will change to construct
the arrays on the fly,

00:40:17.880 --> 00:40:21.560
either using independent triangles,
or by joining triangle strips

00:40:21.560 --> 00:40:24.250
together with degenerate triangles.

00:40:24.370 --> 00:40:25.860
Okay, so now let's take a look.

00:40:25.960 --> 00:40:28.300
Here's what that would become.

00:40:30.050 --> 00:40:33.360
So now there's some work I'm
doing at the initialization

00:40:33.360 --> 00:40:35.960
time at the top to set up state.

00:40:36.130 --> 00:40:39.750
Then the part that's highlighted
is what I'm doing each frame.

00:40:41.570 --> 00:40:45.440
I'll start out now and for each object,
if it's visible,

00:40:45.470 --> 00:40:50.520
then I'll flatten the transformations
and add it to a combined array.

00:40:50.690 --> 00:40:53.980
Then once I've gone through all the
objects at the end of the frame,

00:40:53.990 --> 00:40:57.350
I'll set up my array pointers
and call GLDrawArrays with

00:40:57.350 --> 00:40:59.430
the whole combined array.

00:40:59.630 --> 00:41:02.790
So, the thing to notice is
that when we started,

00:41:02.840 --> 00:41:06.300
I was making 16 GL calls
for every object.

00:41:06.450 --> 00:41:10.220
It was almost 8,000 GL calls
being made per frame.

00:41:10.300 --> 00:41:15.250
Now, there's no GL calls being
made for every object.

00:41:15.340 --> 00:41:19.850
I'm just doing calculations on the
CPU to add the objects that are

00:41:19.850 --> 00:41:22.380
visible into a big vertex array.

00:41:22.510 --> 00:41:25.250
And then I'm making a
draw call once per frame.

00:41:25.620 --> 00:41:28.930
So, the difference should be dramatic.

00:41:29.700 --> 00:41:31.300
So let me show you that difference.

00:41:31.300 --> 00:41:35.000
And at the same time,
I'll show what to look at for

00:41:35.000 --> 00:41:36.400
some further optimizations.

00:41:36.400 --> 00:41:39.890
So let's go back to the demo
and then take a look at the

00:41:39.890 --> 00:41:42.040
OpenGL ES Analyzer Expert.

00:41:42.040 --> 00:41:45.370
All right,
so let's start by taking another

00:41:45.370 --> 00:41:50.740
look at the demo as it existed
originally before we made our changes.

00:41:50.740 --> 00:41:52.490
So you can see it again here.

00:41:52.490 --> 00:41:54.370
And it's running pretty slow.

00:41:55.060 --> 00:42:01.120
We have the 500 draw calls resulting
in 1,000 triangles or 500 quads.

00:42:01.160 --> 00:42:04.560
And it's taking about 8,000
GL calls to draw this.

00:42:04.580 --> 00:42:05.660
Okay, so there it is.

00:42:05.870 --> 00:42:10.820
So now let's look at the version that
integrates the changes that we just made.

00:42:13.310 --> 00:42:16.530
You can see it's much, much faster.

00:42:16.690 --> 00:42:21.840
So, and the performance here is great,
but I can even crank up

00:42:21.840 --> 00:42:26.540
the number of particles,
and it still is able to maintain

00:42:26.540 --> 00:42:30.370
completely fluid motion and able
to maintain that performance.

00:42:30.480 --> 00:42:33.860
So, all I've done here are the things
that I've shown in this talk,

00:42:33.920 --> 00:42:36.900
where I've converted
over to texture atlases,

00:42:36.970 --> 00:42:41.080
I've removed a lot of state,
and I'm using degenerate triangles in

00:42:41.080 --> 00:42:43.540
this case to join vertex arrays together.

00:42:43.580 --> 00:42:45.610
And a few other things that,
just like I had mentioned,

00:42:45.640 --> 00:42:48.590
I'm culling off-screen objects and so on.

00:42:49.240 --> 00:42:54.430
Okay, so now let's take a look at
how this actually runs in the

00:42:54.430 --> 00:42:57.350
OpenGL ES Analyzer instrument.

00:43:01.530 --> 00:43:09.010
So I'll switch over to the new
version and record a few frames.

00:43:11.210 --> 00:43:13.800
So it's running on my phone now.

00:43:13.880 --> 00:43:17.300
And I'm just counting
up a few frames here.

00:43:18.060 --> 00:43:20.600
Now you can see even just in
this short amount of time,

00:43:20.600 --> 00:43:26.190
I've gotten what about 30 times
as many frames as I did before.

00:43:26.860 --> 00:43:30.700
But so now let's take a look at
the same things that we saw before.

00:43:30.700 --> 00:43:34.690
Frame statistics first.

00:43:35.320 --> 00:43:36.000
I'll turn this over.

00:43:36.000 --> 00:43:40.180
So here's the number of triangles
that we're rendering per frame.

00:43:40.260 --> 00:43:41.180
It's changing.

00:43:41.310 --> 00:43:45.460
838, 832, 862.

00:43:45.550 --> 00:43:49.140
The reason for that is because I'm
culling any off-screen particles.

00:43:49.240 --> 00:43:53.020
And their position is defined randomly,
so the number that actually end

00:43:53.080 --> 00:43:56.260
up on screen changes each frame.

00:43:56.300 --> 00:43:59.880
But so that's why this number
is less than a thousand,

00:43:59.880 --> 00:44:03.450
which is what I had
originally started with.

00:44:03.930 --> 00:44:09.600
But look here, the number of batches,
instead of it being 500, it's now one.

00:44:09.690 --> 00:44:16.400
Just one draw call to get all 838
or 832 triangles drawn on screen.

00:44:16.680 --> 00:44:19.560
And then over here,
the number of GL calls

00:44:19.750 --> 00:44:22.390
per frame is also really,
really low.

00:44:22.560 --> 00:44:27.320
Just four GL calls instead of 8,000.

00:44:27.410 --> 00:44:31.540
So let's take a look at the trace.

00:44:31.600 --> 00:44:34.000
So this is the trace.

00:44:34.700 --> 00:44:38.380
For all of the GL calls that were made
for the lifetime of the application,

00:44:38.430 --> 00:44:41.030
let's go to single frame navigation
and just look at one frame.

00:44:41.040 --> 00:44:45.930
And here is the trace of calls that
we're making in a single frame.

00:44:45.940 --> 00:44:48.700
All I'm doing is binding a texture.

00:44:48.720 --> 00:44:50.920
This is the ID for my texture atlas.

00:44:50.960 --> 00:44:54.420
I'm setting up my vertex pointer
and texture coordinate pointer.

00:44:54.420 --> 00:44:57.830
And in this particular frame,
I'm drawing a triangle

00:44:58.230 --> 00:45:03.500
strip with 1,050 vertices,
so 1,048 triangles.

00:45:05.270 --> 00:45:07.900
So that is just amazing.

00:45:07.960 --> 00:45:11.940
I mean,
we are able to take the entire scene.

00:45:11.940 --> 00:45:15.680
So this includes the background,
this includes the lander,

00:45:15.680 --> 00:45:20.370
all of the particles,
and the fuel display, and so on.

00:45:20.460 --> 00:45:25.280
We're taking all of those objects
and drawing everything that's on

00:45:25.280 --> 00:45:28.220
screen in just one call to GLDrawRays.

00:45:28.300 --> 00:45:33.050
And so it's obvious that's going to
be a lot more efficient than calling

00:45:33.050 --> 00:45:38.280
16 different GL calls plus a separate
call to GLDrawRays for each of 500

00:45:38.670 --> 00:45:42.230
or 1,000 different objects on screen.

00:45:44.220 --> 00:45:48.440
But okay, so that is a look at the
changes that we made.

00:45:48.440 --> 00:45:51.680
But now I want to, as I said,
I want to show you one more thing and

00:45:51.680 --> 00:45:54.580
that is the OpenGL ES Analyzer Expert.

00:45:54.770 --> 00:45:58.780
And so actually what I want to do is
go back to the original version of

00:45:59.040 --> 00:46:02.020
the app and see what it finds for us.

00:46:02.020 --> 00:46:10.910
So I'm going to run it again,
and let it store up a few frames here.

00:46:15.650 --> 00:46:18.100
Okay, that's probably far enough.

00:46:18.140 --> 00:46:21.680
And now,
this information down here is what the

00:46:21.680 --> 00:46:24.870
OpenGL ES analyzer expert will tell you.

00:46:24.890 --> 00:46:26.680
And what, let me zoom in.

00:46:26.680 --> 00:46:33.680
What you see are different categories
of problems or issues that it's found,

00:46:33.690 --> 00:46:38.140
the summary of what that issue is,
then over here also,

00:46:38.140 --> 00:46:43.540
the number of times that that issue
occurred for the life of the application,

00:46:43.540 --> 00:46:48.530
and the number of unique places in
your source code that it came from.

00:46:48.540 --> 00:46:52.830
And then there's one more
thing that I can look at also.

00:46:52.890 --> 00:46:57.790
If I click on a particular issue here,
I can open up a view which will

00:46:58.100 --> 00:47:02.990
give me extended detail about this,
with a recommendation that you can

00:47:02.990 --> 00:47:06.010
make in your code for a change to make.

00:47:06.060 --> 00:47:08.560
And then also,
it'll tell you the exact stack trace

00:47:08.730 --> 00:47:10.650
that this issue was coming from.

00:47:10.660 --> 00:47:14.110
So in this particular example,
let's open this up.

00:47:14.900 --> 00:47:18.210
I have all of these are
redundant state changes,

00:47:18.270 --> 00:47:19.360
redundant calls.

00:47:19.460 --> 00:47:24.080
And a few of them are only happening
once in the lifetime of the application,

00:47:24.080 --> 00:47:26.020
or a few times in the lifetime.

00:47:26.020 --> 00:47:27.800
So they don't really matter.

00:47:27.800 --> 00:47:32.010
But here, let's look at this one,
glenable, gltexture2d.

00:47:32.190 --> 00:47:36.420
So this is being done more
than 24,000 times so far in

00:47:36.520 --> 00:47:38.600
the life of the application.

00:47:38.600 --> 00:47:44.980
And what it's saying up here, well, okay,
this command was redundant, glenable,

00:47:44.980 --> 00:47:45.580
gltexture2d,
and this command was redundant, glenable,

00:47:45.580 --> 00:47:45.580
gltexture2d.

00:47:45.640 --> 00:47:55.430
So this is being done more
than 24,000 times so far in the

00:47:55.430 --> 00:48:08.490
lifetime of the application.

00:48:09.560 --> 00:48:09.580
And what it's saying up here, well, okay,
this command was redundant, gltexture2d,

00:48:09.580 --> 00:48:09.580
and this command was redundant,
gltexture2d.

00:48:10.040 --> 00:48:11.900
This is the routine
that it's coming from.

00:48:11.900 --> 00:48:14.440
If I double click this,
it will take me into my source code,

00:48:14.460 --> 00:48:18.580
and I can start making changes
directly at that point.

00:48:18.630 --> 00:48:23.520
So this is a really powerful tool for
finding issues in your application.

00:48:23.610 --> 00:48:25.670
So let's look at a couple more.

00:48:26.120 --> 00:48:28.500
So a few more things
that are happening here.

00:48:28.900 --> 00:48:30.940
Well, here's one.

00:48:31.400 --> 00:48:36.300
It's saying, okay,
you have many small batch draw calls.

00:48:36.720 --> 00:48:40.560
And let's drill in on some
information about that.

00:48:40.620 --> 00:48:44.460
Okay, it's saying, ah,
this call to GL draw arrays with a

00:48:44.460 --> 00:48:46.870
GL triangle strip and only four vertices.

00:48:47.210 --> 00:48:48.500
Okay, that's a problem.

00:48:48.500 --> 00:48:50.200
Here's the trace where it's coming from.

00:48:50.200 --> 00:48:54.390
But now let's go back and see
what it wants me to do about it.

00:48:56.490 --> 00:49:00.700
So it says up here,
OpenGL ES Analyzer detected a

00:49:00.700 --> 00:49:03.720
number of draw calls containing
a small number of primitives.

00:49:03.830 --> 00:49:07.150
Remember,
four vertices only in the original

00:49:07.150 --> 00:49:09.510
version of this application.

00:49:09.540 --> 00:49:14.370
So there may be an opportunity to
combine several small draw calls into

00:49:14.480 --> 00:49:18.420
a single larger draw call in order
to gain a performance improvement.

00:49:18.420 --> 00:49:21.910
So to do that,
I used degenerate triangles to

00:49:21.920 --> 00:49:24.500
fix that particular problem.

00:49:25.130 --> 00:49:30.020
But here is where it's being called
out using the OpenGL ES Analyzer.

00:49:31.410 --> 00:49:34.850
So the point of this isn't just to
go back and repeat everything that

00:49:34.940 --> 00:49:39.700
we talked about in this talk today,
but it's to show you that you

00:49:39.700 --> 00:49:44.080
actually don't have to be an
expert to know what to go tune.

00:49:44.090 --> 00:49:48.020
This expert system will actually
tell you all of the things that are

00:49:48.020 --> 00:49:52.560
happening in your application that you
should go and take another look at.

00:49:54.130 --> 00:49:56.000
Let's look at just a couple more.

00:49:56.000 --> 00:49:58.550
State query call count.

00:49:58.620 --> 00:50:01.850
You know, I didn't do anything with
this one in the slides,

00:50:02.070 --> 00:50:03.930
but let's see what it's talking about.

00:50:03.960 --> 00:50:08.670
It said that I had called
something 500 times.

00:50:08.680 --> 00:50:09.440
Let's see what it is.

00:50:09.630 --> 00:50:11.410
Ah, it says call to GL get error.

00:50:11.420 --> 00:50:13.020
Yeah, I hadn't addressed that.

00:50:13.380 --> 00:50:15.090
But here we are again.

00:50:15.100 --> 00:50:18.600
The analyzer expert is
telling me something to fix.

00:50:18.620 --> 00:50:20.760
It's saying, you know,
you really don't need to be

00:50:20.760 --> 00:50:23.040
calling GL get error so often.

00:50:23.600 --> 00:50:26.280
Really,
you should just get rid of that from

00:50:26.360 --> 00:50:30.210
the production version of your code,
and only use it for testing.

00:50:30.220 --> 00:50:33.960
But the reason why it's calling it out,
let's look at the recommendation up here.

00:50:35.640 --> 00:50:40.620
OpenGL ES Analyzer detected a number of
state query calls in the current frame.

00:50:40.750 --> 00:50:44.500
Use state query calls sparingly
from within the main rendering loop.

00:50:44.710 --> 00:50:47.980
State query calls are any
functions that begin with glGet,

00:50:47.980 --> 00:50:49.350
glIs, or glRead.

00:50:49.410 --> 00:50:50.780
So that's great advice.

00:50:50.780 --> 00:50:55.590
And it shows me exactly where in
my stack trace this is coming from.

00:50:56.600 --> 00:50:56.800
Great.

00:50:56.800 --> 00:51:00.850
So I really encourage you to download
Xcode 4 if you haven't already,

00:51:00.850 --> 00:51:04.070
and try out the new
OpenGL ES Analyzer instrument.

00:51:04.070 --> 00:51:09.370
And then let the analyzer expert tell
you where and how you can tune your app.

00:51:09.600 --> 00:51:13.320
Now probably a lot of that tuning
will mean eliminating state changes

00:51:13.320 --> 00:51:15.300
and optimizing your draw calls.

00:51:15.350 --> 00:51:19.240
And you can apply the techniques I've
shown in this talk to do those things.

00:51:19.240 --> 00:51:21.580
And finally,
here's my contact information

00:51:21.670 --> 00:51:25.010
if you have any questions about
the content presented here,

00:51:25.010 --> 00:51:28.270
and a link to the iOS
Dev Center for documentation,

00:51:28.270 --> 00:51:30.730
sample code, and our developer forums.

00:51:31.010 --> 00:51:31.930
Thanks for watching.
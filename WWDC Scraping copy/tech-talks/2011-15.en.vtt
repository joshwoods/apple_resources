WEBVTT

00:00:23.000 --> 00:00:26.740
Hello and welcome to your
iOS App Performance Hitlist.

00:00:26.780 --> 00:00:29.160
I'm Michael Jurewitz,
the evangelist responsible for

00:00:29.160 --> 00:00:30.940
developer tools and performance.

00:00:31.060 --> 00:00:35.230
The best iOS apps are not only
beautiful and well designed,

00:00:35.370 --> 00:00:40.190
they also launch quickly,
present a highly responsive interface,

00:00:40.190 --> 00:00:42.480
and use memory efficiently.

00:00:42.480 --> 00:00:45.620
Today,
we're going to focus on teaching you the

00:00:45.620 --> 00:00:51.040
skills and techniques you need to know
to make your application perform great.

00:00:51.600 --> 00:00:55.310
From working with the Time Profiler
and Core Animation instruments

00:00:55.530 --> 00:00:59.390
to taking an in-depth look at how
your application is using memory,

00:00:59.400 --> 00:01:03.900
you'll gain a better understanding of
how to use instruments to track down

00:01:03.900 --> 00:01:06.610
performance issues and ship a better app.

00:01:06.680 --> 00:01:08.090
So let's get started.

00:01:08.120 --> 00:01:13.020
So obviously, we're here today to
talk about performance.

00:01:13.020 --> 00:01:16.570
Now, I'm here to tell you that
performance is the number one most

00:01:16.570 --> 00:01:21.580
important thing that you can pay
attention to in your application.

00:01:21.580 --> 00:01:26.200
Beyond having a great design,
beyond having a great idea,

00:01:26.560 --> 00:01:29.880
your app needs to perform wonderfully.

00:01:29.880 --> 00:01:32.700
At the end of the day,
if you've got a bunch of pretty pixels

00:01:32.820 --> 00:01:36.800
but your app performance is really,
really bad, no one's going to care that

00:01:36.800 --> 00:01:38.380
your graphics look so good.

00:01:38.380 --> 00:01:41.940
They're just going to be paying attention
to the poor performance of your app.

00:01:43.730 --> 00:01:46.280
What is performance, you might be asking?

00:01:46.360 --> 00:01:48.700
Well, performance is many things.

00:01:48.810 --> 00:01:52.510
It's about being fast,
doing things before the user

00:01:52.510 --> 00:01:54.920
even expects them to be finished.

00:01:55.130 --> 00:01:58.870
It's about being responsive,
so that as you interact with the screen,

00:01:59.020 --> 00:02:02.550
you're providing that kind
of feedback immediately.

00:02:02.750 --> 00:02:05.680
And it's about being efficient.

00:02:05.740 --> 00:02:09.400
It's about making sure that you're
using only the system resources

00:02:09.420 --> 00:02:13.240
that you need to solve a task
and not going all over the place

00:02:13.240 --> 00:02:15.680
using tons and tons of resources.

00:02:17.780 --> 00:02:21.830
And more than anything,
performance matters because

00:02:22.060 --> 00:02:24.160
your customers notice.

00:02:24.160 --> 00:02:26.930
And they leave you things
like app reviews that say

00:02:26.930 --> 00:02:31.930
things like slow and buggy,
crashes all the time,

00:02:31.930 --> 00:02:35.000
and the dreaded one star.

00:02:35.000 --> 00:02:39.310
You don't want to be a one star app,
so you need to be paying attention

00:02:39.310 --> 00:02:43.110
to the performance of your
application and making sure that

00:02:43.110 --> 00:02:45.700
you fix performance related issues.

00:02:47.390 --> 00:02:50.840
And that's exactly what we're here
today to try to teach you how to do.

00:02:50.840 --> 00:02:54.390
So, in this presentation,
we're going to show you how to

00:02:54.390 --> 00:02:56.530
test and measure performance.

00:02:56.530 --> 00:02:59.490
I'm going to show you how to
help your application launch

00:02:59.490 --> 00:03:03.080
faster and figure out what may
be slowing down your launch time.

00:03:03.080 --> 00:03:07.600
I'm going to show you how to reduce your
memory footprint and understand what

00:03:07.600 --> 00:03:10.050
memory you're using in the first place.

00:03:10.050 --> 00:03:15.070
And I'm going to show you how to identify
common graphics problems and fix them.

00:03:15.100 --> 00:03:16.580
them.

00:03:16.580 --> 00:03:19.890
So let's talk a bit about
measuring performance.

00:03:19.890 --> 00:03:22.650
So first of all, what should you measure?

00:03:22.920 --> 00:03:25.020
Well, the answer really is everything.

00:03:25.030 --> 00:03:28.020
You need to be paying
attention to processing time,

00:03:28.020 --> 00:03:32.710
to memory usage,
to graphics performance and correctness,

00:03:32.890 --> 00:03:35.770
to disk IO, to battery life, all of it.

00:03:35.770 --> 00:03:39.950
And the best part about all of this
is that you've got an application

00:03:39.950 --> 00:03:42.700
to help you do that in Instruments.

00:03:42.700 --> 00:03:47.820
Instruments is your one-stop shop
for all your performance needs.

00:03:47.820 --> 00:03:52.410
It gives you a holistic view of your
application's performance so you

00:03:52.410 --> 00:03:57.320
can see things like processing time,
memory, graphics, battery life,

00:03:57.320 --> 00:04:00.650
all this information
together in one place,

00:04:00.940 --> 00:04:01.920
side by side.

00:04:02.200 --> 00:04:06.180
Now when it comes to techniques,
what kinds of techniques should you

00:04:06.180 --> 00:04:08.760
be using when you measure performance?

00:04:08.780 --> 00:04:12.660
Well, first and foremost, Don't guess.

00:04:12.660 --> 00:04:15.840
No, no, actually I'm really,
really serious about this.

00:04:16.120 --> 00:04:17.340
Don't guess.

00:04:17.340 --> 00:04:22.020
You've got a fantastic tool that's
going to help you pinpoint exactly

00:04:22.020 --> 00:04:26.140
what's slow in your application,
exactly what needs work.

00:04:26.220 --> 00:04:31.030
So even though you architected the app,
even though you wrote all this code,

00:04:31.040 --> 00:04:34.600
use the tool and make sure the
things that you're trying to fix,

00:04:34.600 --> 00:04:38.450
the things you're trying to
change are actually the problem.

00:04:38.450 --> 00:04:42.380
You don't want to waste time trying
to fix something that actually

00:04:42.380 --> 00:04:43.760
wasn't the problem all along.

00:04:46.150 --> 00:04:49.560
Okay, now beyond not guessing,
you want to make sure

00:04:49.560 --> 00:04:54.510
that you focus on simple,
repeatable, real-world actions.

00:04:54.510 --> 00:04:58.850
This is really important,
the real-world actions part.

00:04:58.860 --> 00:05:02.800
You want to focus on all of the
different workflows a user is going to

00:05:02.800 --> 00:05:05.330
be going through in your application.

00:05:05.330 --> 00:05:08.580
You want to be timing those,
measuring those,

00:05:08.580 --> 00:05:12.390
looking at how things like
memory changes over time.

00:05:13.100 --> 00:05:17.350
You want to be trying to pinpoint what
are the things that need improvement.

00:05:18.820 --> 00:05:23.430
Then you want to make some changes
and retest those same actions.

00:05:23.490 --> 00:05:25.850
Retesting is really important.

00:05:25.860 --> 00:05:28.570
You don't want to go and make
changes and actually end up

00:05:28.700 --> 00:05:30.550
accidentally making things worse.

00:05:32.320 --> 00:05:35.800
And more than anything,
you want to keep repeating

00:05:35.800 --> 00:05:37.780
this until it just feels right.

00:05:37.800 --> 00:05:41.880
You've got to make sure that
your application just feels

00:05:42.300 --> 00:05:45.510
like the greatest thing to use,
that it's fast, that it's efficient,

00:05:45.510 --> 00:05:48.450
that it doesn't stutter when you scroll,
etc.

00:05:48.450 --> 00:05:52.860
That it just feels like you've put
lots of love and care into making

00:05:52.860 --> 00:05:55.170
it a fantastic user experience.

00:05:55.870 --> 00:06:00.000
Now, with all the work that I do with
third-party applications and all the

00:06:00.080 --> 00:06:04.420
opportunities that I have to see how
apps are really performing in the wild,

00:06:04.420 --> 00:06:08.340
it really comes down to three
main areas that contribute to

00:06:08.410 --> 00:06:13.520
applications either behaving poorly
or seeming to have poor performance.

00:06:13.600 --> 00:06:17.850
It comes down to three things
that you want to make sure that

00:06:17.920 --> 00:06:20.080
you do in your development.

00:06:20.080 --> 00:06:23.690
You want to avoid blocking work.

00:06:24.770 --> 00:06:27.800
You want to make sure that
you minimize memory usage.

00:06:27.800 --> 00:06:31.740
And you want to make sure
that you draw efficiently.

00:06:33.250 --> 00:06:36.520
So let's go ahead and hop right
into the first one and talk

00:06:36.520 --> 00:06:39.590
about avoiding blocking work.

00:06:39.810 --> 00:06:42.990
Perhaps the most important
part of avoiding blocking

00:06:42.990 --> 00:06:45.700
work is to launch quickly.

00:06:45.910 --> 00:06:49.850
This is your user's first
impression of your application,

00:06:49.900 --> 00:06:54.060
and it immediately communicates
so much about the speed,

00:06:54.170 --> 00:06:57.980
the quality, the care,
and the craftsmanship that you've

00:06:58.120 --> 00:07:01.690
put into your application and
all of its user experiences.

00:07:01.700 --> 00:07:06.670
So you really need to be
hyper-focused on this scenario.

00:07:06.690 --> 00:07:09.620
From the moment that user taps your
application on the home screen,

00:07:09.720 --> 00:07:13.670
this is the very first opportunity
for you to say hello to them,

00:07:13.740 --> 00:07:16.690
for you to show them the
work that you've done.

00:07:16.700 --> 00:07:21.640
So you want to be focusing on that
first launch performance and having

00:07:21.950 --> 00:07:24.690
that be the best it can possibly be.

00:07:24.900 --> 00:07:29.180
You also want to be paying attention
to the multitasking resume as well.

00:07:29.180 --> 00:07:32.210
This is an incredibly common
way that users are going to

00:07:32.300 --> 00:07:33.620
come back to your application.

00:07:33.620 --> 00:07:38.400
You want to make sure that you don't have
performance problems hiding in resume.

00:07:38.400 --> 00:07:42.770
Now the important thing to remember
is that timing is everything.

00:07:42.900 --> 00:07:46.080
The OS is constantly
watching your application.

00:07:46.080 --> 00:07:49.300
And if you're too slow to
get certain things done,

00:07:49.300 --> 00:07:51.870
iOS may just quit your application.

00:07:52.700 --> 00:07:55.580
So, for example,
you've got 20 seconds for

00:07:55.660 --> 00:07:57.590
your application to launch.

00:07:57.590 --> 00:08:01.740
Now really what this comes down to is
this is your application launching,

00:08:01.740 --> 00:08:05.270
getting through application did
finish launching with options,

00:08:05.270 --> 00:08:07.820
and then beginning to
service the event loop.

00:08:07.900 --> 00:08:11.680
Now I'm here to tell you if your
app is taking anywhere near 20

00:08:11.680 --> 00:08:15.810
seconds to get all this done,
it's time to open up instruments and it's

00:08:15.810 --> 00:08:18.370
time to figure out what's taking so long.

00:08:18.460 --> 00:08:22.440
Great launch times should be 2-3 seconds.

00:08:22.700 --> 00:08:27.320
before the user even notices
that they've been waiting.

00:08:27.820 --> 00:08:30.350
Now at the same time,
you need to be paying attention

00:08:30.350 --> 00:08:34.700
to things like resume,
suspend, and quit.

00:08:34.950 --> 00:08:37.200
When your app resumes
back to the foreground,

00:08:37.460 --> 00:08:41.450
you only have 10 seconds to
begin servicing that event loop,

00:08:41.600 --> 00:08:45.420
so you need to make sure you're
being fast and efficient.

00:08:45.760 --> 00:08:48.200
As your application goes
into the background,

00:08:48.280 --> 00:08:52.750
you only have 10 seconds to do things
like save any files that need saving,

00:08:52.830 --> 00:08:55.610
or do any additional
cleanup that you need to do.

00:08:55.610 --> 00:08:59.950
Again, you need to make sure you're
being as efficient as possible.

00:08:59.960 --> 00:09:03.670
And when it comes to launching quickly,
you need to make sure that

00:09:03.670 --> 00:09:05.680
you're measuring correctly.

00:09:06.750 --> 00:09:09.030
Most importantly,
you need to make sure that you're

00:09:09.030 --> 00:09:10.960
measuring with realistic data sets.

00:09:10.960 --> 00:09:14.980
It doesn't do any good if any of
the performance profiling you're

00:09:14.980 --> 00:09:19.520
ever doing is on a debug version of
your application with absolutely no

00:09:19.520 --> 00:09:23.790
data for your application to load,
or with your application simply

00:09:23.860 --> 00:09:26.120
connected to the debugger in Xcode.

00:09:26.140 --> 00:09:29.850
It's actually really important to note,
anytime you're debugging

00:09:29.850 --> 00:09:33.650
your application,
Xcode specifically tells the OS not

00:09:33.650 --> 00:09:36.470
to quit your app if it takes too long.

00:09:36.620 --> 00:09:41.500
The assumption is, you're debugging,
things might take a while.

00:09:41.580 --> 00:09:46.340
So it's really important for you to put
your application on your device and take

00:09:46.340 --> 00:09:48.520
it out in the real world and use it.

00:09:48.630 --> 00:09:52.490
Now when it comes to these data sets,
you need to make sure that you're

00:09:52.490 --> 00:09:56.280
getting a good estimate of what you
think is a moderate amount of data

00:09:56.280 --> 00:09:58.300
that a user will probably have.

00:09:58.580 --> 00:10:03.850
And then up that amount of data by 10,
100, or 1,000 times.

00:10:03.940 --> 00:10:06.500
So that you can actually see,
what are the problems?

00:10:06.500 --> 00:10:08.920
What are the weak points
in your application?

00:10:08.920 --> 00:10:12.430
What's going to really take
the longest time to get done?

00:10:12.480 --> 00:10:15.910
And to do all of this,
you want to make sure that you're

00:10:15.910 --> 00:10:18.660
using the time profiler instrument.

00:10:18.660 --> 00:10:22.300
Now when it comes to launching quickly,
there are a few really

00:10:22.300 --> 00:10:24.100
important rules to live by.

00:10:24.300 --> 00:10:26.620
And really,
you want to be asking yourself

00:10:26.620 --> 00:10:30.540
these questions every time you
look at the work that you're doing,

00:10:30.540 --> 00:10:33.620
an application did finish
launching with options,

00:10:33.620 --> 00:10:35.650
or as part of application resume.

00:10:37.040 --> 00:10:40.830
The first question should be,
is this work that you're doing

00:10:40.960 --> 00:10:46.200
essential for loading the most
basic main user interface?

00:10:46.220 --> 00:10:47.580
If not, defer it.

00:10:47.580 --> 00:10:48.550
Do it later.

00:10:48.550 --> 00:10:51.200
Use something like Dispatch Async.

00:10:53.020 --> 00:10:57.660
The next question:
Does it involve parsing, loading data,

00:10:57.660 --> 00:10:59.900
or network activity?

00:11:00.160 --> 00:11:02.900
Well, first and foremost,
you should never be doing any

00:11:03.080 --> 00:11:04.840
of that work on the main thread.

00:11:04.900 --> 00:11:08.680
Second of all,
these are great candidates to defer.

00:11:09.240 --> 00:11:13.150
Take this work, wrap it in a block,
dispatch async it onto

00:11:13.150 --> 00:11:14.730
a background queue.

00:11:15.310 --> 00:11:19.710
Finally, it's important to remember that
progress indicators are your friend.

00:11:19.900 --> 00:11:24.240
Now, what I'm not suggesting here is that
you go and turn every view in your

00:11:24.240 --> 00:11:27.800
application into a progress indicator
while you wait for it to load.

00:11:27.910 --> 00:11:29.750
That would be a very bad idea.

00:11:30.000 --> 00:11:32.040
Instead,
you should consider doing something

00:11:32.050 --> 00:11:34.900
like just putting up a single
progress indicator for the user,

00:11:34.900 --> 00:11:39.340
so they know that you're doing work
if you need some additional time to,

00:11:39.340 --> 00:11:43.580
say, parse a file,
load in some web content, etc.

00:11:43.900 --> 00:11:48.900
The key is that you want your application
to already be able to be interacted with,

00:11:48.980 --> 00:11:49.900
and it's okay for you to do that.

00:11:49.960 --> 00:11:52.830
It's okay for you to tell the user, "Hey,
we're still working on things."

00:11:53.080 --> 00:11:55.900
As long as that doesn't take too long.

00:11:57.260 --> 00:12:01.850
Alright, so now let's hop into a demo and
take a look at launching quickly

00:12:01.990 --> 00:12:06.200
and how to figure out why an app
may be taking too long to launch.

00:12:06.200 --> 00:12:10.550
Okay, so we're going to start by
taking a look at our iPad first.

00:12:10.690 --> 00:12:13.860
Now, we want to be paying attention
to startup and the application

00:12:13.860 --> 00:12:18.200
we're going to be using is this
inauspiciously named Bad Startup.

00:12:18.220 --> 00:12:21.770
So, let's go ahead and tap on
this app and take a look.

00:12:22.350 --> 00:12:28.540
Now our app is launching,
and it's still launching,

00:12:28.570 --> 00:12:36.500
and it's still launching,
still launching, still launching.

00:12:37.420 --> 00:12:38.490
Who knows, will it ever finish?

00:12:38.570 --> 00:12:39.100
There we go.

00:12:39.100 --> 00:12:41.580
Okay,
so our app finally finished launching.

00:12:41.580 --> 00:12:43.750
That took a long time, right?

00:12:43.750 --> 00:12:46.610
If this was your application
and this was your customers

00:12:46.610 --> 00:12:49.910
that had to wait that long,
they'd be pretty disappointed.

00:12:49.920 --> 00:12:54.120
So, let's go ahead and switch back to
the Mac and take a look at just

00:12:54.120 --> 00:12:56.360
exactly what's taking so long.

00:12:57.040 --> 00:12:59.400
Now, over here on the Mac,
there's one thing I want to

00:12:59.400 --> 00:13:00.870
show you first and foremost.

00:13:00.890 --> 00:13:05.670
In Xcode 4.3,
Xcode is now just a single dot app.

00:13:05.730 --> 00:13:08.200
And Instruments,
the application we're going

00:13:08.200 --> 00:13:11.420
to be using for looking at all
this performance information,

00:13:11.420 --> 00:13:13.290
is now actually a part of Xcode.

00:13:13.300 --> 00:13:17.260
So, to get to Instruments,
we're going to go to the Xcode menu

00:13:17.470 --> 00:13:21.400
and select Open Developer Tool and
then select Instruments.

00:13:21.500 --> 00:13:25.340
This is going to launch Instruments
and we've got our usual interface

00:13:25.340 --> 00:13:27.020
that we're used to working with.

00:13:27.020 --> 00:13:29.600
Now,
one thing you can do in the dock is go

00:13:29.600 --> 00:13:34.550
ahead and double tap on Instruments,
go to Options and select Keep in Dock.

00:13:34.550 --> 00:13:39.400
This is a way that you can just keep a
reference to Instruments around the next

00:13:39.400 --> 00:13:42.440
time you just want to launch it directly.

00:13:44.230 --> 00:13:47.570
Now anytime you're working with
any sort of timing information,

00:13:47.570 --> 00:13:50.690
you want to be working with
the Time Profiler instrument.

00:13:51.040 --> 00:13:53.570
So let's go ahead and choose that.

00:13:55.020 --> 00:13:58.150
Now with this instrument selected,
we want to go ahead and select our

00:13:58.270 --> 00:14:02.500
Bad Startup application from our iPad.

00:14:02.500 --> 00:14:05.350
I'm going to go ahead and
make the window a little bit

00:14:05.600 --> 00:14:07.370
bigger here and click Record.

00:14:07.960 --> 00:14:11.800
Now what's happening over on our
iPad is the application is launching,

00:14:11.920 --> 00:14:15.100
it's doing a bunch of work,
and it's taken a long

00:14:15.100 --> 00:14:16.800
time to do that work.

00:14:16.800 --> 00:14:19.800
If we look back at the Mac,
and specifically at instruments,

00:14:19.800 --> 00:14:23.170
we can actually see a visual
representation of this

00:14:23.220 --> 00:14:24.540
work as it's completing.

00:14:24.810 --> 00:14:27.880
Alright,
so our app just finished launching,

00:14:27.880 --> 00:14:30.830
so I'm going to go ahead
and stop the trace.

00:14:31.310 --> 00:14:35.200
Okay, so now we have all of this
data here for us to work with.

00:14:35.350 --> 00:14:39.300
And typically for most folks,
the problem is you take a measurement,

00:14:39.430 --> 00:14:42.040
but then the problem becomes,
what do you do now that

00:14:42.040 --> 00:14:43.440
you have this data?

00:14:43.570 --> 00:14:46.740
How do you actually look
at this information?

00:14:46.870 --> 00:14:50.590
So, let me show you a bit
about how to do that.

00:14:50.750 --> 00:14:54.100
First and foremost,
anytime you're using Time Profiler,

00:14:54.120 --> 00:14:59.280
you only want to be paying attention to
specific windows of time where you are

00:14:59.280 --> 00:15:01.690
doing the things that you care about.

00:15:01.810 --> 00:15:04.850
In this case,
we really only care about the window of

00:15:04.850 --> 00:15:07.700
time where our application was launching.

00:15:07.700 --> 00:15:12.660
And so, if you hold down the Option key
and click and drag in the timeline,

00:15:12.750 --> 00:15:16.870
you can select just the window
of time that you care about,

00:15:17.030 --> 00:15:20.190
so you can focus on just that data.

00:15:20.930 --> 00:15:24.210
Next, we really want to be doing with
some work here in the table view,

00:15:24.210 --> 00:15:27.290
but there's not a lot for us
to be working with right now.

00:15:27.300 --> 00:15:31.810
So, let's try to dig in and
see what we can do here.

00:15:31.840 --> 00:15:35.840
Now,
new in instruments as part of Xcode 4.3,

00:15:35.840 --> 00:15:40.420
you'll actually have the call
tree uninverted from the start.

00:15:40.530 --> 00:15:42.800
So, if you're still using an
older version of instruments,

00:15:42.800 --> 00:15:45.190
you may see something that
looks a little bit different.

00:15:45.680 --> 00:15:50.270
The most important thing is that you
want to make sure that you have separate

00:15:50.270 --> 00:15:54.460
by thread checked here on the left,
and that you also have

00:15:54.490 --> 00:15:57.390
invert call tree unchecked.

00:15:57.570 --> 00:15:59.560
This is the key for
where you want to start.

00:16:02.070 --> 00:16:05.430
Now, looking back here at the table view,
let's go ahead and add a little

00:16:05.440 --> 00:16:07.820
bit of information for ourselves.

00:16:08.030 --> 00:16:11.130
One of the first things that
I like to do is pull out what's

00:16:11.130 --> 00:16:13.100
called the self percentage.

00:16:13.300 --> 00:16:17.180
Now, the self percentage is what's
going to tell us the amount of time

00:16:17.180 --> 00:16:22.140
that we spent in that particular
method itself in the table view,

00:16:22.310 --> 00:16:25.370
as opposed to, say,
any of the other methods

00:16:25.370 --> 00:16:27.490
that it called through to.

00:16:27.680 --> 00:16:30.350
Now when it comes to paying
attention to launch performance,

00:16:30.410 --> 00:16:34.600
what really matters is the time
that you spend in the main thread.

00:16:34.710 --> 00:16:38.960
So now at this point what you really want
to be doing is paying attention to this

00:16:38.960 --> 00:16:42.100
percentage right here under running time.

00:16:42.230 --> 00:16:46.790
This is the total percentage
of time that was spent in the

00:16:46.790 --> 00:16:52.100
main thread and everything
else that it called through to.

00:16:52.240 --> 00:16:54.870
So using just the arrow
keys and the keyboard,

00:16:55.050 --> 00:16:59.090
let's just start stepping through
here and going down the stack.

00:16:59.100 --> 00:17:02.600
You can see one of the first
places that we started was main.

00:17:02.640 --> 00:17:06.190
This is the main entry
point to your application.

00:17:06.540 --> 00:17:09.380
Now it's fairly common as you're
going through this kind of information

00:17:09.380 --> 00:17:13.500
to see a bunch of this framework
code and get kind of scared.

00:17:13.630 --> 00:17:18.320
What is this CFRunLoop run-in
mode and CFRunLoop run-specific?

00:17:18.460 --> 00:17:21.810
Well, the most important part is that
you just want to continue to

00:17:21.810 --> 00:17:25.840
follow this large percentage,
so let's just continue to do that.

00:17:25.950 --> 00:17:31.450
All of this is just the details of what
happens to be happening in the framework.

00:17:34.320 --> 00:17:36.970
Now, as we keep going here,
we're eventually going to

00:17:36.970 --> 00:17:38.490
reach some of our own code.

00:17:38.500 --> 00:17:40.680
And we can see as we kept
going down the chain,

00:17:40.680 --> 00:17:44.010
boom, here we are,
AppDelegate application did

00:17:44.110 --> 00:17:46.070
finish launching with options.

00:17:46.120 --> 00:17:52.480
And we see that it took 33.2% of
the total time as compared to 34%

00:17:52.560 --> 00:17:58.560
of the total time in our application
that was spent in the main thread.

00:17:58.580 --> 00:18:01.450
So clearly,
this is a huge percentage of the time

00:18:01.480 --> 00:18:03.960
that we're spending trying to start up.

00:18:04.200 --> 00:18:08.580
Now, as we take a look at this menu,
you can see that this is the first

00:18:08.580 --> 00:18:13.920
point that we actually delve into some
additional code in our own application.

00:18:14.150 --> 00:18:19.100
Now, we can see that our view controllers
init function was responsible for

00:18:19.100 --> 00:18:22.140
about 33% of our total startup time.

00:18:22.140 --> 00:18:26.100
That's a large percentage,
all things considered.

00:18:26.500 --> 00:18:30.740
Now, when you're looking at startup time,
it can be really useful to just hone

00:18:30.740 --> 00:18:33.060
in on the actual code that you wrote.

00:18:33.180 --> 00:18:35.820
And so,
one of the things you should know is that

00:18:35.830 --> 00:18:40.430
these arrows on the very right of the
different frames that you're looking at,

00:18:40.620 --> 00:18:42.070
you can actually click on.

00:18:42.120 --> 00:18:47.390
And what this does is takes that
particular frame and all of the things

00:18:47.390 --> 00:18:53.500
that it called through to and rebases
them at 100%. So now you're basically

00:18:53.510 --> 00:18:57.450
just looking at the relative impact
of all of the code that you wrote

00:18:57.450 --> 00:18:59.870
that was being called by that method.

00:19:01.320 --> 00:19:04.020
So once we do that,
we can see that that view controller

00:19:04.020 --> 00:19:09.100
init function was responsible
for 99.4% of the time that we're

00:19:09.100 --> 00:19:13.870
actually spending an application
did finish launching with options.

00:19:16.200 --> 00:19:19.860
So, as we look at all the information
that we called through to here,

00:19:19.860 --> 00:19:24.220
we can begin to see all of the system
APIs that were involved in this slowdown.

00:19:24.510 --> 00:19:26.580
Now,
remember all of the things that I told

00:19:26.580 --> 00:19:30.570
you that you shouldn't be doing as part
of application did finish launching.

00:19:30.580 --> 00:19:33.860
We see here, for example,
we've got an NSData,

00:19:33.860 --> 00:19:37.740
data with contents of URL,
taking 50% of our time.

00:19:37.740 --> 00:19:42.520
We've got UIImage, image with data,
taking 17% of our time.

00:19:43.130 --> 00:19:46.310
And NSJSON serialization,
JSON object with data,

00:19:46.310 --> 00:19:48.190
taking 10% of our time.

00:19:48.200 --> 00:19:53.120
So, we've got potentially network calls,
loading of large information,

00:19:53.120 --> 00:19:55.990
and parsing of data,
all happening as part

00:19:55.990 --> 00:19:57.660
of application launch.

00:19:57.660 --> 00:20:00.530
That's the last thing
that we want to be seeing.

00:20:00.540 --> 00:20:04.620
So, now, with this information,
we know what we need to go and

00:20:04.620 --> 00:20:07.210
try to improve in our application.

00:20:07.220 --> 00:20:09.860
But we can actually go one step further.

00:20:09.860 --> 00:20:13.070
If we go ahead and we
double-click on View Content,

00:20:13.150 --> 00:20:13.980
we can actually go to the
View Controller and knit.

00:20:14.160 --> 00:20:18.640
We actually can get a view where we
can see exactly what percentage of

00:20:18.640 --> 00:20:23.300
time was being spent in our actual
source code that we had written in

00:20:23.300 --> 00:20:25.650
application did finish launching.

00:20:25.660 --> 00:20:29.360
Here, you get a chance to actually see
how all of these different methods

00:20:29.360 --> 00:20:33.530
fit together and where we were
actually spending all of this time.

00:20:33.560 --> 00:20:37.980
In fact, you can see that our NSData,
data with contents of URL,

00:20:37.980 --> 00:20:41.100
was in fact going out and
grabbing a remote resource.

00:20:41.100 --> 00:20:43.100
And that was responsible for loading.

00:20:43.120 --> 00:20:45.120
And so, when you take both of those
and combine them together,

00:20:45.120 --> 00:20:53.120
that's 72% of our startup time right
there in just that single line of code.

00:20:53.120 --> 00:20:56.640
As we look up here,
we can find that actually the parsing

00:20:56.650 --> 00:21:00.120
of our JSON didn't take that long,
all things considered.

00:21:00.120 --> 00:21:02.340
But again,
this is still something that we don't

00:21:02.350 --> 00:21:04.010
want to be doing on the main thread.

00:21:04.170 --> 00:21:08.430
So, now, armed with this information,
we can go back into application

00:21:08.510 --> 00:21:10.970
did finish launching with options,
figure out what pieces

00:21:11.200 --> 00:21:12.050
that we can actually use.

00:21:12.540 --> 00:21:14.430
What pieces that we can
actually delay or pull out.

00:21:14.540 --> 00:21:17.950
All of this loading from the
network and parsing is a great

00:21:18.140 --> 00:21:22.540
candidate for doing asynchronously
with Grand Central Dispatch.

00:21:22.710 --> 00:21:25.540
And we can help our
application load a lot faster.

00:21:25.540 --> 00:21:32.540
So, we just had a great look at why an
application was taking so long to launch.

00:21:32.540 --> 00:21:35.980
So, remember,
the system will terminate apps that take

00:21:35.980 --> 00:21:41.540
too long to do basic things like launch,
resume, suspend, etc.

00:21:42.000 --> 00:21:44.960
Make sure you're collecting
data with Time Profiler.

00:21:45.090 --> 00:21:48.670
And really, the name of the game is
trying to do less work.

00:21:48.980 --> 00:21:51.960
Figure out how you can take the
work that you need to be done and

00:21:52.370 --> 00:21:55.960
either turn it into smaller tasks
or tasks that can be done later.

00:21:55.960 --> 00:21:59.960
Above all else,
don't block the main thread.

00:21:59.960 --> 00:22:04.960
And just make sure that you optimize,
optimize, optimize.

00:22:04.960 --> 00:22:09.950
All right, now let's talk about
minimizing memory usage.

00:22:11.820 --> 00:22:15.700
So it's important to remember that
iOS is not a desktop operating system.

00:22:15.700 --> 00:22:18.810
It's very, very powerful,
but you still have limited

00:22:18.810 --> 00:22:19.960
memory to work with.

00:22:20.000 --> 00:22:23.200
These are, after all,
all embedded devices.

00:22:23.280 --> 00:22:27.120
iOS has virtual memory,
but there is no swap file.

00:22:27.120 --> 00:22:31.330
Any of the memory that you
allocate has to stay physically

00:22:31.330 --> 00:22:34.180
resident in the RAM on the device.

00:22:34.980 --> 00:22:38.250
To help out with that,
we have low memory notifications so

00:22:38.250 --> 00:22:42.450
that your application can know when the
system is getting low on memory and when

00:22:42.450 --> 00:22:44.960
it needs your help to give up resources.

00:22:46.380 --> 00:22:52.180
Now reducing the memory footprint in
your application is absolutely important.

00:22:52.320 --> 00:22:56.110
Because iOS has no swap file,
all of that memory that you're

00:22:56.110 --> 00:22:59.730
using counts against you,
as well as all of the basic tasks the

00:22:59.780 --> 00:23:02.620
operating system is trying to get done.

00:23:02.770 --> 00:23:05.260
And it's important to remember
that under memory pressure,

00:23:05.360 --> 00:23:08.720
the OS is going to start
terminating applications.

00:23:08.880 --> 00:23:11.960
So let's take a quick
look at how that works.

00:23:12.200 --> 00:23:14.790
So in iOS 5,
as the amount of dirty memory

00:23:14.790 --> 00:23:18.790
on the system increases,
you first hit a warning level.

00:23:19.010 --> 00:23:23.870
This is the point where the OS begins
to exit background applications.

00:23:24.120 --> 00:23:28.180
If the total memory usage on
the device continues to go up,

00:23:28.200 --> 00:23:30.440
we finally hit an urgent level.

00:23:30.620 --> 00:23:35.110
This is when the frontmost app is warned,
and this is your opportunity

00:23:35.230 --> 00:23:39.650
to respond to this memory
warning by freeing up resources.

00:23:40.000 --> 00:23:44.970
Now if memory usage continues to grow,
then eventually we hit a critical point,

00:23:44.990 --> 00:23:49.030
and this is where the frontmost
app will be exited by the system.

00:23:49.040 --> 00:23:53.530
Now it's important to realize this
behavior is subtly different from

00:23:53.640 --> 00:23:56.210
the way that things worked on iOS 4.

00:23:56.240 --> 00:24:00.080
On iOS 4,
as memory usage got greater and greater,

00:24:00.170 --> 00:24:03.970
the frontmost app would be
notified at the same time as

00:24:03.970 --> 00:24:06.520
the background applications.

00:24:07.680 --> 00:24:10.590
Now what ended up happening is
that it became a pretty decent

00:24:10.590 --> 00:24:14.440
strategy as a frontmost app to
simply ignore the memory warnings,

00:24:14.590 --> 00:24:18.720
because you could probably count on some
poor background app being killed instead.

00:24:18.720 --> 00:24:24.100
But now on iOS 5, when background apps
have all been exited,

00:24:24.100 --> 00:24:27.620
we warn the frontmost app,
which is a way of saying

00:24:27.620 --> 00:24:30.730
that as the frontmost app,
your head is on the chopping block.

00:24:30.840 --> 00:24:34.970
You're the last one that we can
ask to help be better about memory.

00:24:35.260 --> 00:24:39.730
so you need to make sure you're
responding to memory warnings.

00:24:40.510 --> 00:24:44.560
Now, memory can also have a big
impact on responsiveness.

00:24:44.700 --> 00:24:50.000
Spikes in memory usage may cause other
delays that seem rather unlikely,

00:24:50.000 --> 00:24:52.820
but actually can have a big
impact on your application.

00:24:52.840 --> 00:24:57.110
So, as your application is moving along,
if it has a sudden spike in the

00:24:57.110 --> 00:25:00.670
amount of memory it's using,
maybe you went and parsed some

00:25:00.700 --> 00:25:05.860
large file from the internet,
the OS may choose to actually evict some

00:25:06.070 --> 00:25:10.620
of your executable code from memory,
some pieces of your actual app.

00:25:10.720 --> 00:25:15.740
Now, this is fine in the short term to
try to get back additional resources,

00:25:15.950 --> 00:25:18.300
but eventually your app
needs to keep running,

00:25:18.300 --> 00:25:20.430
and that needs to be
read back into memory.

00:25:20.480 --> 00:25:23.460
And that paging back into
memory can take time,

00:25:23.460 --> 00:25:27.610
and it can cause jitters in
scrolling and other sluggishness.

00:25:30.120 --> 00:25:33.530
Now Jetsam is the process on
iOS that watches for memory

00:25:33.530 --> 00:25:37.620
pressure and terminates apps
that have excessive memory usage.

00:25:37.720 --> 00:25:42.940
Now in a multitasking world like
we've been on for iOS 4 and iOS 5,

00:25:42.940 --> 00:25:46.330
it's even more important for you
to make sure that you're paying

00:25:46.450 --> 00:25:50.280
attention to memory and only
using the amount that you need.

00:25:50.360 --> 00:25:53.830
Most importantly,
apps that have a small memory

00:25:53.830 --> 00:25:59.140
footprint will be preserved longer
in the background than larger apps.

00:25:59.640 --> 00:26:02.030
If you think about it,
when we start quitting

00:26:02.030 --> 00:26:05.500
background processes,
we want the biggest bang for our buck.

00:26:05.600 --> 00:26:08.360
So we're going to go after
processes in the background

00:26:08.360 --> 00:26:10.130
that are using the most memory.

00:26:10.180 --> 00:26:15.570
So as your application suspends,
try to get rid of as much as you can

00:26:15.710 --> 00:26:18.600
so you can stay safe and stay low.

00:26:21.460 --> 00:26:23.980
Now when it comes to
reducing memory footprint,

00:26:23.980 --> 00:26:26.690
there really are three
areas you want to focus on.

00:26:27.290 --> 00:26:31.300
Memory spikes, memory leaks,
and abandoned memory.

00:26:31.300 --> 00:26:35.930
Memory spikes are periods of time where
you have very large allocations that

00:26:35.930 --> 00:26:38.470
you make in very short periods of time.

00:26:38.470 --> 00:26:42.140
Again, the example we gave earlier was
maybe parsing a file that you

00:26:42.140 --> 00:26:43.750
downloaded from the internet.

00:26:44.280 --> 00:26:47.800
You want to try to avoid these for
exactly what we just spoke about

00:26:47.920 --> 00:26:51.690
because that amount of allocation may
cause the system to have to get rid

00:26:51.730 --> 00:26:54.020
of other necessary things in memory.

00:26:54.020 --> 00:26:57.210
Or if you spike too much,
the system may not be able

00:26:57.210 --> 00:27:00.230
to honor your request at all,
in which case your

00:27:00.230 --> 00:27:02.180
application may get quit.

00:27:04.030 --> 00:27:06.840
For memory leaks,
this is memory that you've allocated,

00:27:06.840 --> 00:27:09.800
but at some point you
lost a reference to it.

00:27:09.990 --> 00:27:13.470
And the worst part about these
kinds of things is that because

00:27:13.470 --> 00:27:16.700
you allocated this memory,
it's currently counting against

00:27:16.810 --> 00:27:18.900
you and against your process.

00:27:19.090 --> 00:27:21.900
But because you don't have
a reference to it anymore,

00:27:22.030 --> 00:27:24.400
you have no way to clean it up.

00:27:24.400 --> 00:27:29.010
As I like to tell developers,
the right number of leaks is zero leaks.

00:27:29.190 --> 00:27:33.780
You always want to make sure you track
these down and make them go away.

00:27:34.460 --> 00:27:38.150
A third kind of thing you want to
pay attention to is abandoned memory.

00:27:38.160 --> 00:27:41.520
This is sort of similar to a leak,
but you can think of it as

00:27:41.520 --> 00:27:45.520
memory that you've allocated,
you still have a reference to it,

00:27:45.700 --> 00:27:48.240
but for whatever reason
you don't reuse it again.

00:27:48.800 --> 00:27:54.250
Maybe this might be a cache of some set
of views or other data that you create

00:27:54.250 --> 00:28:00.940
once and then just keep on recreating as
opposed to ever actually cleaning it up.

00:28:02.490 --> 00:28:07.500
So now, let's look at a demo of using the
memory instruments in action so you

00:28:07.500 --> 00:28:11.680
can figure out how your application
is using memory in the first place.

00:28:11.680 --> 00:28:14.320
Okay,
so let's take a look at the memory usage

00:28:14.320 --> 00:28:16.640
for another one of our applications.

00:28:16.660 --> 00:28:19.260
We're going to go ahead
and open up Instruments.

00:28:19.260 --> 00:28:23.670
And we're now, instead of choosing one
of our default templates,

00:28:23.670 --> 00:28:26.780
going to go down to the
user directory here.

00:28:26.780 --> 00:28:29.760
And I'm choosing a template
that I created for myself

00:28:29.990 --> 00:28:31.530
called Jury Allocations.

00:28:32.240 --> 00:28:36.290
Now, this template isn't special aside
from the fact that it contains a bunch

00:28:36.290 --> 00:28:40.130
of different instruments that I like
to work with whenever I'm looking

00:28:40.230 --> 00:28:42.380
at the memory usage of an application.

00:28:42.380 --> 00:28:46.870
So as you can see, we simply have the
Allocations instrument,

00:28:46.870 --> 00:28:50.620
the VM Tracker instrument,
the Leaks instrument,

00:28:50.620 --> 00:28:52.580
and Activity Monitor.

00:28:52.580 --> 00:28:55.280
And I'll be going through
and talking about each one of

00:28:55.280 --> 00:28:56.940
these and why they're useful.

00:28:56.940 --> 00:29:01.360
Now, I've got an application on
my iPad called The Elements.

00:29:02.080 --> 00:29:04.810
So I'm going to go ahead
and from Instruments,

00:29:04.810 --> 00:29:07.310
select that app and start profiling it.

00:29:07.410 --> 00:29:09.040
I'll hit Record.

00:29:09.040 --> 00:29:12.280
And now,
let's go take a look at it on the iPad.

00:29:14.500 --> 00:29:17.230
So as you can see, this application is
pretty straightforward.

00:29:17.230 --> 00:29:20.400
It's a table view with a
listing of all of the elements.

00:29:20.400 --> 00:29:22.830
And if we go ahead and
we pick one of these,

00:29:22.850 --> 00:29:27.400
let's say, "Firmium" here,
we slide over to the side,

00:29:27.580 --> 00:29:30.360
and the application's going to
load some additional information

00:29:30.770 --> 00:29:32.220
on that particular element.

00:29:32.480 --> 00:29:35.390
So we've got some information
being loaded in here.

00:29:35.440 --> 00:29:38.010
We'll just wait a moment
for it to show up.

00:29:40.060 --> 00:29:44.340
And we see we've got the
Wikipedia entry for Fermium.

00:29:44.390 --> 00:29:46.950
Now let's go through and do
this a couple more times.

00:29:46.980 --> 00:29:50.830
We can take a look at gold, why not?

00:29:50.990 --> 00:29:54.270
We'll load in all of this
information for gold.

00:29:57.050 --> 00:30:00.500
And we see we've got now
the Wikipedia page for gold.

00:30:00.530 --> 00:30:04.600
Now I want to focus back on
instruments and specifically in the

00:30:04.600 --> 00:30:07.140
trace that we see that's going on.

00:30:07.160 --> 00:30:10.160
I'm going to continue to use the
elements and I want you to pay

00:30:10.160 --> 00:30:14.510
specific attention to what's happening
with the allocations instrument.

00:30:14.750 --> 00:30:18.520
So I'm going to select helium,
sure why not, that's a fun one.

00:30:18.550 --> 00:30:22.460
We see the allocations shoot
up for our application.

00:30:22.490 --> 00:30:25.090
I'm going to go back and now
choose a different element,

00:30:25.130 --> 00:30:28.740
maybe we'll do something like Curium.

00:30:29.930 --> 00:30:32.350
We see again we've got
our allocations shoot up.

00:30:32.650 --> 00:30:34.210
I'm going to hit back.

00:30:34.210 --> 00:30:38.760
And we'll repeat this at
least one more time here.

00:30:43.320 --> 00:30:45.970
Now as we go back,
we'll go ahead and select, say, Carbon,

00:30:45.980 --> 00:30:46.520
why not?

00:30:46.520 --> 00:30:51.340
And we can see again that our
allocations continue to increase.

00:30:51.340 --> 00:30:54.060
I'm going to go ahead
and stop the trace now,

00:30:54.060 --> 00:30:57.580
and let's take a moment just to look
at what's going on in instruments.

00:30:58.640 --> 00:31:03.560
Now as you're using your application,
if you find yourself able to basically

00:31:03.560 --> 00:31:07.750
be doing the same thing over and
over again in your application,

00:31:07.750 --> 00:31:13.220
and you see that your memory usage,
particularly as indicated by allocations,

00:31:13.220 --> 00:31:17.730
continues to go up and up and up,
that's not exactly a good sign.

00:31:17.790 --> 00:31:20.480
Typically,
when you're repeating the same action,

00:31:20.480 --> 00:31:24.410
you might expect to see memory go up,
but then come back down once you're done,

00:31:24.460 --> 00:31:27.530
and go up again when you repeat it,
but then come back down.

00:31:28.270 --> 00:31:32.130
In this case, we can see that the memory
for our application just

00:31:32.130 --> 00:31:34.140
keeps steadily marching up.

00:31:34.190 --> 00:31:36.690
So let's go ahead and let's go
through each of the instruments

00:31:36.700 --> 00:31:41.160
that we have here and show you how
you can use them to figure out what

00:31:41.240 --> 00:31:44.210
might be causing this memory growth.

00:31:45.300 --> 00:32:59.600
[Transcript missing]

00:32:59.700 --> 00:33:01.650
Generally speaking,
you don't want to combine

00:33:01.650 --> 00:33:04.530
memory instrumentation with
something like Time Profiler.

00:33:04.640 --> 00:33:09.220
The memory instrumentation is
taking a trace of your application,

00:33:09.280 --> 00:33:11.800
and that can have a big impact
on the amount of time it

00:33:11.800 --> 00:33:13.590
takes for something to happen.

00:33:13.630 --> 00:33:16.730
Activity Monitor is a
bit more lightweight,

00:33:16.730 --> 00:33:20.590
so it's generally okay to
use with the Time Profiler.

00:33:21.020 --> 00:33:23.390
Now normally if you saw
this kind of memory growth,

00:33:23.400 --> 00:33:26.400
the first thing you'd want to
be taking a look at was leaks.

00:33:26.400 --> 00:33:30.370
However, in this case,
we don't have any information to go on.

00:33:30.420 --> 00:33:34.740
We can see that leaks didn't report
any information about any leaks.

00:33:34.740 --> 00:33:38.900
That's kind of unfortunate because
usually when we see a leaked object here,

00:33:38.900 --> 00:33:42.440
we can also find out what allocated
it and then hopefully figure out

00:33:42.440 --> 00:33:44.320
why it's not getting cleaned up.

00:33:44.520 --> 00:33:46.800
So in this case,
we're going to have to turn to a

00:33:46.800 --> 00:33:50.700
couple other instruments to try to
figure out what might be going on.

00:33:52.280 --> 00:33:56.340
So, let's now take a look at
the VM Tracker instrument.

00:33:56.470 --> 00:34:01.260
Now, the VM Tracker instrument is the
most authoritative view of how

00:34:01.290 --> 00:34:06.440
much memory your application is
using at any one point in time.

00:34:06.560 --> 00:34:11.000
Now, we've got the VM Tracker instrument
set up to do automatic snapshotting of

00:34:11.000 --> 00:34:13.770
our application every three seconds.

00:34:13.890 --> 00:34:16.360
So, this is going to help us see,
every three seconds,

00:34:16.360 --> 00:34:19.780
how that usage is changing over time.

00:34:19.990 --> 00:34:22.250
Now the number that you want
to pay attention to whenever

00:34:22.260 --> 00:34:26.060
you're looking at the memory
consumption for your application,

00:34:26.270 --> 00:34:29.600
first you want to order
the table by resident size,

00:34:29.600 --> 00:34:34.860
and then what you want to be paying
attention to is dirty resident memory.

00:34:34.860 --> 00:34:39.740
This is memory that you've allocated,
you've changed it in some way,

00:34:39.740 --> 00:34:44.400
and so it has to stay resident in
the physical RAM on the device.

00:34:45.080 --> 00:34:49.440
And this number right here really is
the authoritative view of how much

00:34:49.440 --> 00:34:51.820
memory your application is using.

00:34:53.330 --> 00:34:55.860
Now we can see as we scrub
through time here that this

00:34:55.970 --> 00:34:57.590
number does in fact change.

00:34:57.600 --> 00:35:00.320
In fact,
we can see that earlier in the app,

00:35:00.510 --> 00:35:03.810
the dirty resident was only
about 21 megabytes of memory.

00:35:03.810 --> 00:35:08.620
But by the time we actually hit closer
to the end of using the application,

00:35:08.620 --> 00:35:12.320
we're sitting closer to
45 megabytes of usage.

00:35:13.880 --> 00:35:16.120
Now again, this is good in terms of
getting an authoritative view

00:35:16.120 --> 00:35:20.600
of how much memory we're using,
but where is this memory coming from?

00:35:20.620 --> 00:35:24.230
Well, let's take a look at the
allocations instrument.

00:35:27.340 --> 00:35:29.100
Now if we look at the
allocations instrument,

00:35:29.100 --> 00:35:33.100
we can see there's really a
rich set of information here.

00:35:33.250 --> 00:35:35.640
One of the first things that will
pop out to you is the fact that

00:35:35.650 --> 00:35:39.400
we've got these colored graphs here
showing you lots of information

00:35:39.400 --> 00:35:44.770
about the types of allocations that
you are making over here on the left.

00:35:44.920 --> 00:35:48.910
Now, the heuristic being used for
coloring these graphs is actually

00:35:49.110 --> 00:35:50.610
pretty simple and straightforward.

00:35:50.620 --> 00:35:54.500
Blue, generally speaking,
is something that looks fairly normal,

00:35:54.500 --> 00:35:59.260
whereas red or pinkish is something that
you might want to be paying attention to.

00:35:59.260 --> 00:36:02.070
Now,
in terms of how we color these things,

00:36:02.140 --> 00:36:05.760
these graphs get colored
red for a number of reasons.

00:36:06.980 --> 00:36:09.860
If we see that for a
certain allocation type,

00:36:09.860 --> 00:36:14.460
say in this case a malloc of 48 bytes,
that you've made a ton of

00:36:14.510 --> 00:36:18.380
these types of allocations,
but only a very few number of

00:36:18.390 --> 00:36:22.050
objects are actually left over,
that could be a problem.

00:36:22.060 --> 00:36:24.970
Maybe you're creating too
many temporary objects.

00:36:25.030 --> 00:36:28.440
Maybe you could be just creating
a few of these and reusing them.

00:36:28.500 --> 00:36:31.220
So this might be something you
might want to take a look at,

00:36:31.590 --> 00:36:32.890
which is why we color it red.

00:36:32.900 --> 00:36:36.800
At the same time,
if you've had a certain allocation type,

00:36:36.800 --> 00:36:36.800
you've made a ton of these
types of allocations,

00:36:36.800 --> 00:36:39.410
where you've allocated
a bunch of objects,

00:36:39.410 --> 00:36:43.340
and a bunch of objects of that
particular type are still around,

00:36:43.340 --> 00:36:46.430
that's something you also
might want to take a look at,

00:36:46.470 --> 00:36:49.340
because maybe you're
leaking those objects.

00:36:49.340 --> 00:36:52.190
Maybe you're holding onto them
longer than you would like,

00:36:52.240 --> 00:36:55.240
and they're counting against
your overall memory usage.

00:36:55.350 --> 00:36:58.610
Now, here in this case,
there's nothing that really jumps

00:36:58.610 --> 00:37:00.340
out to us as being a problem.

00:37:00.340 --> 00:37:03.690
I mean, we could see, for example,
that these malloc of 48 bytes

00:37:03.770 --> 00:37:06.340
look somewhat interesting,
but they're not really a problem.

00:37:06.850 --> 00:37:10.850
But let's take a closer look just
to see if there's anything to this.

00:37:11.060 --> 00:37:15.560
Now if I go ahead and I click this
arrow here next to the malloc48 bytes,

00:37:15.600 --> 00:37:19.490
I'm going to focus on just
the allocations that were made

00:37:19.710 --> 00:37:22.000
of that particular category.

00:37:22.000 --> 00:37:25.840
And if I go ahead and pull
out the extended detail view,

00:37:25.970 --> 00:37:31.000
I can actually see the backtrace for
all of these different allocations.

00:37:31.000 --> 00:37:34.000
Now as you might imagine,
there's a lot of information here.

00:37:34.130 --> 00:37:36.690
If we scroll all the way
to the bottom of the list,

00:37:36.690 --> 00:37:40.820
you can see we've got at least a
good 700 objects here that were

00:37:40.820 --> 00:37:44.000
still alive at the end of our trace.

00:37:44.200 --> 00:37:46.000
And this is an important point.

00:37:46.010 --> 00:37:49.000
When you're working with
the allocations instrument,

00:37:49.000 --> 00:37:52.980
sometimes you want to go and
work with the allocation lifespan

00:37:53.320 --> 00:37:55.000
setting here on the left.

00:37:55.000 --> 00:37:59.670
In this case, this is set up to filter to
show us only the objects that

00:37:59.670 --> 00:38:02.000
are created and still living.

00:38:02.000 --> 00:38:03.000
But in our case,
we actually had a lot of objects

00:38:03.000 --> 00:38:03.000
that came out of the same category.

00:38:03.000 --> 00:38:03.980
So we're going to go ahead and click this
arrow here next to the malloc48 bytes.

00:38:04.000 --> 00:38:04.320
And if we go ahead and
click the add button,

00:38:04.320 --> 00:38:05.000
we can see that the objects that came
out of the same category came and went.

00:38:05.000 --> 00:38:09.000
So let's take a look at the objects
that were created and destroyed.

00:38:09.000 --> 00:38:11.360
Now when we do that,
we see we've got much more

00:38:11.360 --> 00:38:13.000
information to work with.

00:38:13.000 --> 00:38:16.380
In fact,
there were about 25,000 objects that

00:38:16.380 --> 00:38:20.910
were created and destroyed that matched
that particular allocation type.

00:38:21.030 --> 00:38:22.000
So let's go ahead and
click the add button.

00:38:23.240 --> 00:38:26.770
Now as we go through here we can see
that we've got a bunch of different

00:38:26.770 --> 00:38:28.520
kinds of allocations happening.

00:38:28.520 --> 00:38:33.220
In most cases these are happening
just as parts of system frameworks,

00:38:33.360 --> 00:38:36.940
and there's not too much that we can
glean for what exactly may be going on.

00:38:37.020 --> 00:38:40.010
We can see, for example,
that core animation was very,

00:38:40.020 --> 00:38:43.180
very busy at some point as we
were using our application.

00:38:43.180 --> 00:38:46.920
Again, probably helping us draw our
actual pixels to the screen.

00:38:47.840 --> 00:38:51.600
So let's go ahead and back out of
here for a second and look at this

00:38:52.000 --> 00:38:54.200
problem from a different viewpoint.

00:38:54.800 --> 00:40:00.700
[Transcript missing]

00:40:02.180 --> 00:40:06.380
Okay, so now we've got several different
measurements we've taken.

00:40:06.390 --> 00:40:09.380
And you'll notice that between
each of these measurements,

00:40:09.380 --> 00:40:14.940
Instruments is telling us how much heap
growth happened between each of these.

00:40:14.940 --> 00:40:19.070
So let's focus on Heap Shot 2 here,
because this seems to have a lot of

00:40:19.070 --> 00:40:23.440
information about having additional
objects that were still around.

00:40:24.380 --> 00:40:27.110
Now as we take a look at
this particular heap shot,

00:40:27.110 --> 00:40:30.020
we can see all of the
different allocation types.

00:40:30.020 --> 00:40:35.340
Non-objects, CFStrings, CF basic hashes,
etc.

00:40:37.990 --> 00:40:41.270
Now as we look at these non-object types,
we actually can get a chance

00:40:41.270 --> 00:40:46.660
to see what the backtrace was
that led to these allocations.

00:40:46.790 --> 00:40:49.440
Now, I'm just going to quickly
go through some of these,

00:40:49.450 --> 00:40:53.700
and in this case we just kind of
want to be looking for some patterns.

00:40:53.820 --> 00:40:56.230
We see, for example,
here on the right that we've

00:40:56.310 --> 00:40:59.170
got a backtrace in WebCore.

00:40:59.320 --> 00:41:02.970
And another backtrace that
goes through web core.

00:41:02.970 --> 00:41:05.440
Another one that goes through web core.

00:41:05.620 --> 00:41:07.440
There's a decent amount
of core animation drawing,

00:41:07.440 --> 00:41:10.940
but we can see that we're actually
going through some backtraces

00:41:10.940 --> 00:41:13.120
involving web core a decent amount.

00:41:13.200 --> 00:41:17.740
Now, this should be interesting to
us because we know we're using

00:41:17.740 --> 00:41:20.200
UI WebView in our application.

00:41:20.320 --> 00:41:22.200
So maybe there's something to this.

00:41:22.200 --> 00:41:25.200
Now, this is an important point
about memory analysis.

00:41:25.200 --> 00:41:30.200
Sometimes you just have to look at the
data you have and begin to form a hunch

00:41:30.200 --> 00:41:35.200
about how you had written the code and
what the data seems to be pointing at.

00:41:35.200 --> 00:41:39.190
In this case, let's go ahead and go
back to our project here.

00:41:39.190 --> 00:41:42.200
And through a bit of the
wonders of demo programming,

00:41:42.200 --> 00:41:47.200
we can actually see that here in
our view controller's load view,

00:41:47.200 --> 00:41:51.160
we were creating a UI WebView,
going off to Wikipedia to load it.

00:41:52.200 --> 00:41:56.700
Adding that WebView to our view
controller and then failing

00:41:56.870 --> 00:41:59.040
to release that WebView.

00:41:59.200 --> 00:42:02.200
So in this case,
this ends up being a one-line fix.

00:42:02.200 --> 00:42:05.580
We simply need to make sure since
we've added that WebView to a view

00:42:05.580 --> 00:42:09.140
hierarchy that we also clean it up.

00:42:09.850 --> 00:42:12.660
Now you may be wondering why
something like leaks didn't

00:42:12.840 --> 00:42:14.690
find this particular leak.

00:42:14.740 --> 00:42:16.240
And this is another important point.

00:42:16.240 --> 00:42:18.900
Leaks is a conservative collector.

00:42:18.900 --> 00:42:22.020
It tries to make sure that
anything that it tells you about,

00:42:22.430 --> 00:42:24.930
it knows for sure is a leak.

00:42:25.020 --> 00:42:28.950
In the case of views,
there's often limited information

00:42:28.950 --> 00:42:34.000
that leaks can actually use to infer
about the life cycle of that view.

00:42:34.000 --> 00:42:38.860
Views tend to have lots of other
objects that have references to them.

00:42:39.430 --> 00:42:42.180
So in this case,
although leaks was not able to actually

00:42:42.180 --> 00:42:45.550
show us that this view was leaking,
at least we were able to use the

00:42:45.550 --> 00:42:49.270
allocations instrument to understand
what was actually the type of

00:42:49.330 --> 00:42:52.470
memory that was still around,
and it pointed us in the right

00:42:52.480 --> 00:42:56.040
direction to begin to look to
clean up in our own application.

00:42:58.810 --> 00:43:02.390
Alright, so we just saw a great demo for
how to figure out where your

00:43:02.390 --> 00:43:04.490
application is using memory.

00:43:04.590 --> 00:43:06.300
So remember,
you really just want to make sure

00:43:06.300 --> 00:43:10.540
that your application uses the
least amount of memory possible.

00:43:10.680 --> 00:43:15.710
Avoid leaks, avoid abandoned memory,
avoid memory spikes,

00:43:15.960 --> 00:43:19.020
and avoid heap growth.

00:43:19.150 --> 00:43:22.950
Now,
let's talk about drawing efficiently.

00:43:23.780 --> 00:43:27.160
Drawing efficiently is one of
the most important things that

00:43:27.160 --> 00:43:29.180
you can do in your application.

00:43:29.240 --> 00:43:34.520
Inefficient drawing wastes battery life,
it's incredibly noticeable to the user,

00:43:34.600 --> 00:43:38.730
and it gives users a bad
impression of your application.

00:43:39.160 --> 00:43:43.810
Some common problems that I see with
drawing really amount to drawing

00:43:43.810 --> 00:43:47.880
too much transparent content,
drawing scaled content,

00:43:48.000 --> 00:43:53.600
and drawing pixel misaligned content,
which we'll talk a little bit more about

00:43:53.600 --> 00:43:55.480
exactly what that is in one moment.

00:43:55.600 --> 00:44:00.040
And now, let's go to a demo with the
Core Animation Instrument to show

00:44:00.040 --> 00:44:05.950
exactly how you can discover what's being
drawn inefficiently in your application.

00:44:07.830 --> 00:44:10.830
Anytime you want to take a
look at graphics performance,

00:44:10.860 --> 00:44:14.200
you want to be using the
Core Animation Instrument.

00:44:14.200 --> 00:44:18.030
So, we're going to go ahead and select
the Core Animation Template here

00:44:18.030 --> 00:44:21.070
in Instruments and hit Choose.

00:44:21.470 --> 00:44:24.850
Now the Core Animation Instrument is
fairly interesting because it's one

00:44:24.850 --> 00:44:29.460
of the few instruments where you don't
actually have to record any of its data.

00:44:30.350 --> 00:44:33.920
Instead, we're just going to select
the Core Animation Instrument,

00:44:34.010 --> 00:44:38.060
and you'll notice that we have a set
of debug options that we can work with.

00:44:38.100 --> 00:44:42.140
Now for the rest of this demo,
we're going to focus on two of

00:44:42.140 --> 00:44:44.450
these options in particular.

00:44:45.240 --> 00:44:48.900
The one at the very top,
which is Color Blended Layers,

00:44:49.020 --> 00:44:53.070
and one kind of in the middle
called Color Misaligned Images.

00:44:53.320 --> 00:44:56.010
Now we've got an application
over on our iPad,

00:44:56.010 --> 00:44:59.560
and let's go ahead and take
a look at that for a moment.

00:44:59.600 --> 00:45:04.560
Now in Instruments,
all I'm going to do is check the

00:45:04.620 --> 00:45:08.530
checkbox for Color Blended Layers.

00:45:08.680 --> 00:45:12.120
Now when I do that,
you see that immediately the

00:45:12.170 --> 00:45:14.000
data on the iPad changes.

00:45:14.000 --> 00:45:17.620
You see everything has
been colored red and green.

00:45:17.720 --> 00:45:20.760
Now the simple way to read this
anytime you're looking at your

00:45:20.760 --> 00:45:26.840
application is that basically
red is bad and green is good.

00:45:27.090 --> 00:45:30.760
Now specifically what you're
seeing for anything that's red

00:45:30.870 --> 00:45:34.580
is you're seeing content that has
been marked as being transparent.

00:45:34.580 --> 00:45:39.800
Now transparent content ends up being
particularly expensive to render.

00:45:39.800 --> 00:45:44.610
Now the reason for this is that whenever
you're rendering transparent content,

00:45:44.610 --> 00:45:49.490
you have to render what's on top,
followed by what's beneath that,

00:45:49.490 --> 00:45:52.700
and what's beneath that,
and then figure out how all that

00:45:52.700 --> 00:45:54.660
content should blend together.

00:45:55.020 --> 00:45:57.210
That can be a very expensive operation.

00:45:57.240 --> 00:46:01.220
And when you're doing something like
trying to scroll through a table view,

00:46:01.220 --> 00:46:06.180
needing to continually recompute that
kind of information can really put

00:46:06.180 --> 00:46:08.700
a strain on scrolling performance.

00:46:08.820 --> 00:46:12.440
Now in this particular app,
we see that we've got some

00:46:12.440 --> 00:46:16.900
UI labels that look like they've
been marked as transparent.

00:46:16.900 --> 00:46:21.600
They've probably been given a
background of UI color clear color.

00:46:21.600 --> 00:46:25.000
We also see that the background
for the entire app is transparent.

00:46:25.000 --> 00:46:29.610
The entire table view cell has probably
been marked as being transparent,

00:46:29.610 --> 00:46:32.590
which is why the very
back of it is red as well.

00:46:32.940 --> 00:46:35.270
Now in addition to that,
we see these thumbnails that we're

00:46:35.270 --> 00:46:37.440
working with also appear to be red.

00:46:37.480 --> 00:46:40.670
Again,
this is likely because these images were

00:46:40.720 --> 00:46:46.200
either told that they were transparent by
setting is opaque no on the image view,

00:46:46.200 --> 00:46:50.130
or the images may actually
have an alpha channel.

00:46:50.140 --> 00:46:53.660
Whenever you're trying to display
an image that has an alpha channel,

00:46:53.660 --> 00:46:56.970
the OS looks at that,
assumes the image has an

00:46:56.970 --> 00:47:01.160
alpha channel for a reason,
and will go ahead and render

00:47:01.160 --> 00:47:05.140
that as a transparent image,
even if there doesn't actually

00:47:05.140 --> 00:47:08.700
happen to be any transparency
in that particular image.

00:47:10.350 --> 00:47:13.260
Now, when you're looking at this and
thinking of ways to correct this,

00:47:13.300 --> 00:47:14.280
what might you do?

00:47:14.280 --> 00:47:17.780
Well, first and foremost,
the background for the UI table

00:47:17.780 --> 00:47:20.080
view cell could just be white color.

00:47:20.080 --> 00:47:23.780
The background for the labels
could just be white color.

00:47:23.780 --> 00:47:27.020
And when the user goes to
select a table view cell,

00:47:27.020 --> 00:47:30.040
the OS will go ahead and
take a look at the label,

00:47:30.090 --> 00:47:33.270
know that it can do
something special with that,

00:47:33.270 --> 00:47:37.770
which in particular is, on selection,
it'll change the background

00:47:37.790 --> 00:47:40.180
color of that label to white.

00:47:40.200 --> 00:47:55.810
So you don't need to worry about having
your labels be transparent just to

00:47:55.810 --> 00:48:00.640
support things like the selection color.

00:48:02.270 --> 00:48:07.240
Now really the name of the game any time
you're working with transparency is that

00:48:07.240 --> 00:48:13.390
you want to try to avoid less than about
a half screen's worth of total red area.

00:48:13.400 --> 00:48:18.680
Once you get beyond about a half screen,
you're going to start dropping

00:48:18.680 --> 00:48:20.590
frames any time you scroll.

00:48:20.600 --> 00:48:25.440
Now dropping one or two frames as
compared to 60 frames per second

00:48:25.520 --> 00:48:27.890
is not necessarily a huge deal.

00:48:27.920 --> 00:48:31.010
But as you add more
and more transparency,

00:48:31.200 --> 00:48:33.940
the problem is going to
compound and scrolling is going

00:48:34.000 --> 00:48:35.910
to become even more jerky.

00:48:36.450 --> 00:48:39.700
Alright, so that's color blended layers.

00:48:39.890 --> 00:48:42.730
Now I want to take a look
at a different setting.

00:48:42.890 --> 00:48:46.680
This is going to be
Color Misaligned Images.

00:48:46.810 --> 00:48:49.160
So again,
all I'm going to do in Instruments

00:48:49.590 --> 00:48:54.640
is check this setting for
Color Misaligned Images.

00:48:54.810 --> 00:48:59.300
Now the first thing you'll notice is that
a bunch of things have turned yellow.

00:48:59.460 --> 00:49:02.740
Now in this case,
we're doing some demos on our iPad here,

00:49:02.880 --> 00:49:05.660
and we've actually scaled
up our user interface.

00:49:05.660 --> 00:49:08.460
So if I go back to
just a 1x scale factor,

00:49:08.460 --> 00:49:11.460
you'll see some of that yellow goes away.

00:49:11.460 --> 00:49:15.260
So one of the things
Color Misaligned Images actually

00:49:15.260 --> 00:49:17.400
shows us is scaled content.

00:49:17.640 --> 00:49:21.240
You'll notice that things like the text,
images, etc.

00:49:21.270 --> 00:49:23.580
became yellow when we zoomed up.

00:49:25.030 --> 00:49:29.230
Now this can be very useful as you're
designing your application because

00:49:29.670 --> 00:49:33.340
as you go in and look at content,
it may actually matter that

00:49:33.340 --> 00:49:35.140
something turns out to be scaled.

00:49:35.200 --> 00:49:37.580
In this case,
you can see we have this map

00:49:37.580 --> 00:49:39.650
of a bunch of different photos.

00:49:39.680 --> 00:49:42.510
If all of these are scaled,
this should raise the

00:49:42.650 --> 00:49:45.430
question in our mind of,
why are they scaled?

00:49:45.440 --> 00:49:48.860
Are these actually very big
images that we've just shrunk

00:49:48.860 --> 00:49:50.880
down and rendered very small?

00:49:51.370 --> 00:49:53.850
In which case,
we're actually wasting a bunch of memory

00:49:53.850 --> 00:49:55.820
to try to display them in the first case?

00:49:55.820 --> 00:50:01.490
Or are these actually images that were
very small and we've scaled them up?

00:50:01.600 --> 00:50:03.810
In which case,
they're just not going to look good.

00:50:03.820 --> 00:50:09.360
So enabling color misaligned images and
going hunting for things that are yellow

00:50:09.360 --> 00:50:13.310
that you are responsible for drawing
is a great way to make sure that you're

00:50:13.310 --> 00:50:15.300
actually drawing things efficiently.

00:50:15.360 --> 00:50:19.360
It's also a great way to spot
things like non-retinographics.

00:50:20.210 --> 00:50:24.450
you're doing work on
iPhone 4 or iPhone 4S.

00:50:24.880 --> 00:50:28.620
Now one of the other things that
Color Misaligned Images actually

00:50:28.620 --> 00:50:31.800
shows you are misaligned images.

00:50:31.900 --> 00:50:34.400
In this case,
as we look at the Options panel

00:50:34.660 --> 00:50:39.360
in our particular app here,
you see that we've got a graphic and some

00:50:39.360 --> 00:50:44.780
text that shows up as magenta whenever
we enable Color Misaligned Images.

00:50:45.030 --> 00:50:50.450
Now what this is showing us
specifically are views that have been

00:50:50.460 --> 00:50:53.800
drawn at a non-integral location.

00:50:53.920 --> 00:50:55.790
So let's talk about this for a second.

00:50:55.800 --> 00:50:58.800
Any time you place a view
in the view hierarchy,

00:50:58.800 --> 00:51:01.590
you give it a frame,
which is basically where you

00:51:01.660 --> 00:51:03.800
want that view to draw itself.

00:51:03.800 --> 00:51:08.800
Now a frame consists of a series
of floating point coordinates.

00:51:09.030 --> 00:51:13.580
But it turns out that when you go to
draw these views to the actual screen,

00:51:14.040 --> 00:51:19.070
there are physical pixels on each
device that need to light up to actually

00:51:19.070 --> 00:51:22.790
draw that content to the screen.

00:51:22.810 --> 00:51:24.800
So you can draw something
at a fractional location.

00:51:24.800 --> 00:51:30.990
So say if you positioned
a view at 50.5 or 46.3,

00:51:31.370 --> 00:51:35.500
what ends up happening is you
end up actually straddling

00:51:35.500 --> 00:51:37.800
a set of physical pixels.

00:51:37.810 --> 00:51:42.120
And so the OS has to partially light up
one side of those pixels and partially

00:51:42.280 --> 00:51:44.740
light up another side of those pixels.

00:51:44.800 --> 00:51:48.470
So your nice,
beautiful one pixel line is now sort

00:51:48.850 --> 00:51:51.800
of one and a half to two anti-aliased.

00:51:51.800 --> 00:51:58.780
So any place in your application
where you see magenta,

00:51:58.970 --> 00:52:01.450
you want to go in and you want
to look for how you happen

00:52:01.450 --> 00:52:02.800
to be positioning that view.

00:52:02.800 --> 00:52:06.090
And you simply want to make
sure that you're positioning

00:52:06.090 --> 00:52:07.800
it at an integer location.

00:52:07.800 --> 00:52:11.040
So just lop off the decimal,
either floor or seal it so

00:52:11.040 --> 00:52:14.790
that you make sure that you
actually get an integer value.

00:52:14.800 --> 00:52:18.470
Now it's most common to see this
kind of thing when you're doing

00:52:18.470 --> 00:52:20.800
things like trying to center an
image or split an image into two.

00:52:20.840 --> 00:52:23.800
Or split an image into thirds,
for example.

00:52:23.940 --> 00:52:28.600
You can see how you might end up
at a .5 offset or a .3 offset.

00:52:28.800 --> 00:52:31.800
So any time you see
these misaligned images,

00:52:31.800 --> 00:52:35.800
you want to make sure that you
go ahead and you correct them.

00:52:35.800 --> 00:52:39.390
What's going to happen is your graphics
and your text that otherwise looked

00:52:39.390 --> 00:52:44.570
blurry are actually going to look a whole
lot better and more crisp once they're

00:52:44.570 --> 00:52:46.800
lined up with the physical pixels.

00:52:47.240 --> 00:52:49.800
Okay, so we just saw a great demo of
using the Core Animation in the OS.

00:52:49.800 --> 00:52:52.400
And we're going to go ahead and show you
how to use the Core Animation instrument

00:52:52.480 --> 00:52:54.620
to figure out exactly how you're
drawing in your application.

00:52:54.850 --> 00:52:57.800
So remember, avoid wasteful transparency.

00:52:57.800 --> 00:53:01.520
Avoid transparency with
scrolling in particular.

00:53:02.090 --> 00:53:05.800
Avoid any unnecessary scaling
of your graphics content.

00:53:05.840 --> 00:53:08.610
And ensure pixel alignment.

00:53:08.890 --> 00:53:12.600
Okay, so you learned how to use the
Time Profiler instrument to

00:53:12.600 --> 00:53:14.800
optimize startup performance.

00:53:14.930 --> 00:53:18.800
You saw how you can use everything
from Activity Monitor to Leaks,

00:53:18.800 --> 00:53:23.770
VM Tracker, and Allocations to track
down memory-related issues.

00:53:23.880 --> 00:53:27.500
And finally, you learned how to use the
Core Animation instrument to help

00:53:27.500 --> 00:53:30.800
you pinpoint graphics problems
in your app so you can fix them

00:53:30.800 --> 00:53:33.800
before they go out to customers.

00:53:33.800 --> 00:53:37.740
I look forward to seeing the
great apps that you have in store.
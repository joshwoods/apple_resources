WEBVTT

00:00:09.280 --> 00:00:11.260
Again, my name is Mark Malone.

00:00:11.260 --> 00:00:14.050
My email is down at the
bottom of this presentation,

00:00:14.060 --> 00:00:19.740
so please capture it and send me
email all about the incredibly

00:00:19.740 --> 00:00:22.590
exciting internal applications
that you guys are building,

00:00:22.600 --> 00:00:23.900
workflow apps, all sorts of things.

00:00:23.900 --> 00:00:28.200
I'm always interested in
internal implementations.

00:00:28.300 --> 00:00:29.780
The app store has got
plenty of things on it,

00:00:29.780 --> 00:00:32.480
but I think the in-house applications
are the ones that are really exciting.

00:00:32.480 --> 00:00:35.360
So let me know how we're doing
and how you're doing with how

00:00:35.360 --> 00:00:37.130
you're deploying applications.

00:00:38.280 --> 00:00:41.690
So I'm going to take a bit of
a romp through the SDK and it's

00:00:41.690 --> 00:00:45.530
basically my swag based on what
I think in-house application

00:00:45.530 --> 00:00:47.950
developers are interested in doing.

00:00:48.190 --> 00:00:51.760
I used to do a lot of development
within large organizations

00:00:51.760 --> 00:00:56.020
before I came to work at Apple,
which is a large organization as well.

00:00:56.020 --> 00:00:59.170
So I figure I kind of know my
way through here and you can

00:00:59.190 --> 00:01:01.100
always tell me that I'm wrong.

00:01:01.100 --> 00:01:04.150
Here's basically the
list that I came up with.

00:01:04.220 --> 00:01:04.560
So a little bit on architecture,
development,

00:01:04.560 --> 00:01:05.200
and then I'm going to talk a little
bit about the application itself.

00:01:05.200 --> 00:01:05.200
Here's a little bit on architecture,
development,

00:01:05.200 --> 00:01:05.200
and then I'm going to talk a little
bit about the application itself.

00:01:05.200 --> 00:01:05.220
Here's a little bit on architecture,
development,

00:01:05.220 --> 00:01:05.270
and then I'm going to talk a little
bit about the application itself.

00:01:05.310 --> 00:01:06.520
bit on architecture.

00:01:06.700 --> 00:01:09.490
Development platforms,
there are two for iPhone.

00:01:09.690 --> 00:01:12.120
Displaying web content,
in-house applications

00:01:12.410 --> 00:01:13.820
typically show web content.

00:01:13.820 --> 00:01:14.900
We love the browser.

00:01:14.900 --> 00:01:16.840
We love the deployment mechanism.

00:01:16.840 --> 00:01:19.890
We've got all these existing
assets already that we display

00:01:19.890 --> 00:01:21.920
within web browsers on the desktop.

00:01:21.950 --> 00:01:24.350
Calling a web service,
sort of stepping back from

00:01:24.490 --> 00:01:25.830
the presentation piece.

00:01:25.870 --> 00:01:28.780
Talk a little bit about web
services support on iPhone.

00:01:29.130 --> 00:01:32.730
Parsing XML, if I'm calling web services
then XML matters to me.

00:01:32.730 --> 00:01:36.820
If I've got a native application,
how do I write data locally?

00:01:36.820 --> 00:01:41.020
What are the formats that I can use
to go and write it in the classes?

00:01:41.020 --> 00:01:44.750
Security services associated with
iPhone SDK based applications,

00:01:44.840 --> 00:01:47.870
so where can I store
passwords and certificates,

00:01:47.870 --> 00:01:49.220
those kinds of things.

00:01:49.220 --> 00:01:50.350
Where do I store it?

00:01:50.350 --> 00:01:51.400
How do I write it?

00:01:51.400 --> 00:01:54.550
And then finally deploying
iPhone applications,

00:01:54.720 --> 00:01:56.320
so sort of soup to nuts.

00:01:56.400 --> 00:01:57.110
Sound good?

00:01:57.270 --> 00:01:59.080
Yay, all

00:01:59.350 --> 00:02:02.010
Let's go on,
let's begin with architecture,

00:02:02.140 --> 00:02:04.850
so I can't have a decent presentation
without talking a little bit

00:02:04.850 --> 00:02:08.130
about the architecture of iPhone,
especially since it carries over so much

00:02:08.640 --> 00:02:12.580
from the desktop environment of Mac OS X.

00:02:12.580 --> 00:02:15.550
So at the baseline,
we've got a standard Unix kernel,

00:02:15.550 --> 00:02:20.220
something that's been tuned so that
it works well on these mobile devices.

00:02:20.220 --> 00:02:22.750
And so what you get with
Unix is you get stability,

00:02:22.750 --> 00:02:26.870
something that's highly tested,
you also get a lot of POSIX compliant

00:02:26.870 --> 00:02:31.800
capability that you can actually
leverage within your application.

00:02:31.800 --> 00:02:35.100
On top of that,
we create a stack called core frameworks.

00:02:35.100 --> 00:02:38.340
The core frameworks are our
typical data types that we

00:02:38.620 --> 00:02:40.580
support in native applications.

00:02:40.580 --> 00:02:43.600
There are CF network code,
those things at a low level that

00:02:43.600 --> 00:02:48.680
you're probably familiar with already
if you've ever built anything for a

00:02:48.680 --> 00:02:51.680
machine or a device running Mac OS X.

00:02:51.680 --> 00:02:55.240
On top of that, we've provided a stack
that's great at displaying.

00:02:55.240 --> 00:03:00.460
Playing media content, rich media,
so animated graphics, OpenGL,

00:03:00.460 --> 00:03:04.490
core animation,
those kinds of things that folks

00:03:04.490 --> 00:03:10.680
are used to seeing on our desktop,
playing back video, stereo audio,

00:03:10.680 --> 00:03:15.340
recording audio as well,
nice rich media stack at that level.

00:03:15.340 --> 00:03:17.480
On top of that,
we've got the Cocoa Touch frameworks.

00:03:17.480 --> 00:03:19.960
These are the classes that you're
going to use to provide user interface,

00:03:20.070 --> 00:03:23.130
interaction between your
application logic and the user who

00:03:23.130 --> 00:03:25.210
is actually tapping on the screen.

00:03:25.280 --> 00:03:27.620
So, you're tapping around,
interacting with your application.

00:03:27.620 --> 00:03:30.940
So that's all within
the Cocoa Touch layer.

00:03:30.940 --> 00:03:34.840
And then in comes your
application and sits on top of it.

00:03:34.840 --> 00:03:38.080
So although I've presented it as
a typical stacked architecture,

00:03:38.080 --> 00:03:42.110
the reality is an application
can reach down to just about any

00:03:42.310 --> 00:03:47.170
place that it wants to within
the frameworks as long as they're

00:03:47.170 --> 00:03:49.640
publicly exposed APIs to get to those.

00:03:49.640 --> 00:03:53.230
So if you want to open a BSD socket,
go to town, you can do that.

00:03:53.300 --> 00:03:55.190
You can use the high level
networking classes as well.

00:03:55.200 --> 00:03:57.820
But if you're more comfortable
down at the Unix level,

00:03:57.820 --> 00:04:02.540
there's a lot of functionality
that you get just through the SDK.

00:04:02.540 --> 00:04:07.400
So your application sits on top
and it sits in sort of a sandbox.

00:04:07.410 --> 00:04:12.810
A lot of folks are familiar with
web-based sandboxes and the Safari on

00:04:12.890 --> 00:04:15.720
iPhone lives in its own sandbox as well.

00:04:15.720 --> 00:04:18.970
So it can pull content
from a particular domain.

00:04:19.030 --> 00:04:20.120
It can write cookies.

00:04:20.120 --> 00:04:22.760
But it doesn't have willy-nilly
access to the file system.

00:04:22.850 --> 00:04:25.180
It can't go and read and upload files.

00:04:25.180 --> 00:04:29.080
So it's a very sort of user
interaction based model.

00:04:29.080 --> 00:04:34.600
And a lot of folks are used to this when
they're doing browser-based applications.

00:04:34.600 --> 00:04:36.090
Same sort of implementation on iPhone.

00:04:36.140 --> 00:04:39.330
If you're building an application
that runs within the Safari browser,

00:04:39.350 --> 00:04:41.540
it sits in a sandbox.

00:04:41.540 --> 00:04:44.620
Now it can access the various
applications or some of the

00:04:44.670 --> 00:04:46.740
various applications on iPhone.

00:04:46.740 --> 00:04:50.440
And the way that it does
it is through web APIs.

00:04:50.440 --> 00:04:53.870
So I can go and I can launch a mail,
a blank mail message,

00:04:53.870 --> 00:04:57.440
have it pre-filled with a file,
with the to, the body, the subject,

00:04:57.650 --> 00:04:59.020
those kinds of things.

00:04:59.200 --> 00:05:02.740
Just based on within my web
content having a mail to

00:05:02.740 --> 00:05:05.050
URL within the web content.

00:05:05.120 --> 00:05:06.060
Same thing with the phone.

00:05:06.060 --> 00:05:08.990
If I want to go and present a phone
number to the user for them to dial,

00:05:08.990 --> 00:05:12.580
I can have a tell
URL within my web content.

00:05:12.580 --> 00:05:16.030
So you see we've got this sort
of web API layer there that you

00:05:16.030 --> 00:05:20.000
as a web developer need to go
through in order to access those

00:05:20.000 --> 00:05:22.420
things outside of your sandbox.

00:05:22.420 --> 00:05:24.130
And it's very much
like the desktop model.

00:05:24.140 --> 00:05:25.140
There's a lot of information.

00:05:25.140 --> 00:05:26.800
There's a lot of integration
you've got on the desktop

00:05:26.800 --> 00:05:30.170
through these same sort of APIs.

00:05:30.600 --> 00:15:42.700
[Transcript missing]

00:15:42.970 --> 00:15:44.120
So those are development platforms.

00:15:44.120 --> 00:15:46.390
Let's talk a little bit
while we're on this web rant

00:15:46.440 --> 00:15:48.120
about displaying web content.

00:15:48.120 --> 00:15:51.310
So just at the baseline,
if you've got an in-house application

00:15:51.320 --> 00:15:54.880
that looks great in Safari and iPhone,
then odds are great that

00:15:54.880 --> 00:15:57.980
it's going to look... Sorry,
looks great in Safari on the desktop,

00:15:57.980 --> 00:16:00.560
odds are great that it's going to
look great in Safari and iPhone.

00:16:00.560 --> 00:16:05.580
We've done our best to try to take
you out of the loop when it comes to

00:16:05.580 --> 00:16:07.960
making the content look good on iPhone.

00:16:07.960 --> 00:16:10.050
So without a lot of
tweaking on the back end,

00:16:10.060 --> 00:16:12.540
it should display fine.

00:16:12.640 --> 00:16:13.900
It should be interactive.

00:16:13.900 --> 00:16:16.280
It should have all the
capability that it had before.

00:16:16.280 --> 00:16:18.760
There are obviously some caveats.

00:16:18.760 --> 00:16:19.560
Gesundheit.

00:16:19.600 --> 00:16:22.700
So deploying an application
via the browser,

00:16:22.700 --> 00:16:24.420
what do you get on iPhone?

00:16:24.420 --> 00:16:28.700
You get the same sort of compatibility
that you would expect with Safari on Mac,

00:16:28.780 --> 00:16:30.300
Safari on Windows.

00:16:30.300 --> 00:16:33.870
Same sort of desktop capability,
but in a portable platform.

00:16:33.880 --> 00:16:37.920
We think we've got the best
implementation of the W3C standards.

00:16:37.920 --> 00:16:42.210
So if you care about a standards-based
implementation of DOM or CSS,

00:16:42.380 --> 00:16:45.530
or ECMAScript,
then we think we've got one of

00:16:45.530 --> 00:16:49.230
the best implementations and we
love to gather bugs about where we

00:16:49.230 --> 00:16:52.130
might be off-base in this statement
that we think we're the best.

00:16:52.140 --> 00:16:54.920
So we've got a great
implementation there for standards,

00:16:54.920 --> 00:16:57.780
but we also know that there's
a web reality out there.

00:16:57.780 --> 00:17:01.400
There's a myriad of websites that
perhaps you created within your

00:17:01.400 --> 00:17:04.440
organization or that folks get to,
your users get to,

00:17:04.440 --> 00:17:08.600
just through trolling the web that
weren't built with standards in mind.

00:17:08.700 --> 00:17:12.120
They were code-generated for IE only,
or it was code-generated for IE only,

00:17:12.170 --> 00:17:14.460
or it was code-generated for Netscape,
or it was generated out

00:17:14.460 --> 00:17:17.150
of some sort of server,
or, you know what, it was published just

00:17:17.160 --> 00:17:18.710
because it worked in IE,
and that's fine.

00:17:18.720 --> 00:17:24.250
So the browser is full of all sorts
of optimization technology that we

00:17:24.250 --> 00:17:27.890
go through in order to make sure that
we don't necessarily stumble over

00:17:27.890 --> 00:17:29.860
content that's not standards-based.

00:17:31.640 --> 00:17:35.030
So the caveat is, the biggest caveat is
there's no plug-in support.

00:17:35.100 --> 00:17:37.540
So perhaps you've got
Flash on your internal app,

00:17:37.660 --> 00:17:40.740
perhaps you've got Java applets.

00:17:40.740 --> 00:17:44.320
Maybe you've got content in some sort
of MIME type that requires a plug-in,

00:17:44.410 --> 00:17:47.020
perhaps Windows Media or
something like that.

00:17:47.040 --> 00:17:48.500
Then we're not gonna support that.

00:17:48.510 --> 00:17:52.190
So we support standards code,
we support HTML,

00:17:52.230 --> 00:17:56.790
we support pretty much the web reality
from a pretty grand perspective.

00:17:56.880 --> 00:18:00.010
But when it comes to plug-in support,
we don't have a plug-in model

00:18:00.020 --> 00:18:02.400
in the browser on iPhone
like we do on the desktop.

00:18:02.400 --> 00:18:04.720
So that's sort of the number
one thing that you need to do

00:18:04.720 --> 00:18:08.620
if you're migrating an app from
the desktop browser to iPhone,

00:18:08.620 --> 00:18:11.620
is make sure that there
aren't any plug-ins in there.

00:18:12.630 --> 00:18:15.240
So what do you get that's new and sexy?

00:18:15.240 --> 00:18:16.510
Well, CSS visual effects.

00:18:16.650 --> 00:18:20.350
I mentioned that that capability
was there on iPhone as sort of

00:18:20.350 --> 00:18:23.980
a nice partner to core animation
for a native-based application.

00:18:23.980 --> 00:18:28.280
And it's just pure CSS syntax
for doing animation on screen.

00:18:28.280 --> 00:18:31.690
So transformations,
moving objects around on a

00:18:31.690 --> 00:18:35.310
page with only using CSS,
no JavaScript necessary.

00:18:35.320 --> 00:18:38.210
A lot of folks wrote iPhone
applications based on web

00:18:38.210 --> 00:18:42.400
technology and used JavaScript in
order to be moving divs around.

00:18:42.500 --> 00:18:44.480
within a page, very clunky.

00:18:44.480 --> 00:18:48.720
The CSS stuff is just incredibly fast,
tuned for the device,

00:18:48.720 --> 00:18:51.560
and pretty darned groundbreaking as well.

00:18:51.560 --> 00:18:54.400
So transforms,
we've got support for transitions.

00:18:54.400 --> 00:18:58.650
So again, pure web interface,
but it's got the same sort of transition

00:18:58.760 --> 00:19:02.780
speed capability that you would
expect from a native application.

00:19:02.780 --> 00:19:06.670
Animation as well,
here's a web template that's in Dashcode

00:19:06.670 --> 00:19:11.480
that does that same rotation that
you would see in the stocks widget,

00:19:11.480 --> 00:19:12.620
or in the weather widget.

00:19:12.660 --> 00:19:16.260
You get that same capability
just by using CSS animation.

00:19:16.480 --> 00:19:19.130
Or you can come up with something
that's completely out of the box.

00:19:19.180 --> 00:19:21.850
You can mix and match these
technologies to create an experience

00:19:21.980 --> 00:19:25.990
that's still pure web-based,
but something that your users would never

00:19:26.180 --> 00:19:30.280
think this is a web-based application,
just by using a combination of these.

00:19:30.610 --> 00:19:32.940
So the CSS visual effects are incredible.

00:19:32.970 --> 00:19:36.160
I mentioned they're hardware accelerated
because you definitely want to

00:19:36.160 --> 00:19:39.310
use this if you've got any sort
of animation that you're providing

00:19:39.310 --> 00:19:41.300
within your web-based interface.

00:19:41.320 --> 00:19:47.470
And that the JavaScript way of sliding in
divs is definitely the clunky way to go.

00:19:48.380 --> 00:19:52.230
Public specification for the CSS visual
effects is available via webkit.org.

00:19:52.440 --> 00:19:56.670
Webkit.org is the open source repository
of the engine underneath Safari on

00:19:56.670 --> 00:20:00.340
iPhone as well as Safari on all the
other platforms that you see Safari.

00:20:00.340 --> 00:20:03.280
So you can go and check out
the specifications there.

00:20:03.280 --> 00:20:08.200
Our goal is to push CSS visual effects
to be part of the CSS3 specification.

00:20:08.200 --> 00:20:12.040
We want to make sure that other
user agent vendors besides us

00:20:12.040 --> 00:20:14.200
are pushing this technology.

00:20:14.410 --> 00:20:18.920
So we're definitely keen to make sure
Firefox as well as IE implement these.

00:20:18.920 --> 00:20:22.260
And as a result,
the specs are out there in the public.

00:20:23.700 --> 00:26:34.900
[Transcript missing]

00:26:35.100 --> 00:26:39.000
Loading code from the
application bundle just as easy.

00:26:39.150 --> 00:26:43.560
The key here is you need to find a
path down to your application bundle.

00:26:43.560 --> 00:26:47.240
Your application bundle is
basically that folder of data,

00:26:47.240 --> 00:26:51.640
your resources folder that you
added to your native application.

00:26:51.640 --> 00:26:54.690
You need to build a path to that
and then based on that path you

00:26:54.760 --> 00:26:56.820
can load it into the view as well.

00:26:56.820 --> 00:26:59.360
So here I'm grabbing the main bundle.

00:26:59.380 --> 00:27:02.240
I'm building a path to a directory.

00:27:02.240 --> 00:27:05.500
My web route that I just dragged
into my resources directory,

00:27:05.500 --> 00:27:07.120
I called it local hostess.

00:27:07.120 --> 00:27:09.440
Within local hostess
is an index.html file.

00:27:09.440 --> 00:27:13.440
That's the file I want to go
and load into my web view.

00:27:13.440 --> 00:27:15.990
So here's the full path that you
get as a result of that call.

00:27:15.990 --> 00:27:18.270
You can see that you definitely
don't want to go and hard

00:27:18.270 --> 00:27:19.480
code any of these paths.

00:27:19.480 --> 00:27:23.730
There's a unique application
signature there but you can see it

00:27:23.860 --> 00:27:27.480
all resolves down to that index.html.

00:27:27.480 --> 00:27:30.100
Throw that into an NSURL.

00:27:30.400 --> 00:27:33.300
Create a request, tell the web view to go
and load the request,

00:27:33.300 --> 00:27:33.690
boom.

00:27:33.700 --> 00:27:37.410
All that content, just like the web route
was sitting on the server,

00:27:37.540 --> 00:27:40.420
is now loaded from within my
native application bundle.

00:27:41.540 --> 00:27:43.260
I can do the same thing
from the file system,

00:27:43.330 --> 00:27:48.020
the path just points to a file system
URL instead of an application bundle.

00:27:48.160 --> 00:27:51.060
So let's talk a little bit about
that interaction between the UI web

00:27:51.060 --> 00:27:53.970
view and native back and forth.

00:27:54.150 --> 00:27:58.080
So if I want to execute
JavaScript from native code,

00:27:58.150 --> 00:27:59.970
within my native application
I want to have something

00:28:00.020 --> 00:28:02.100
happen within the UI web view.

00:28:02.100 --> 00:28:04.100
There's some JavaScript functions
that are sitting in there.

00:28:04.100 --> 00:28:06.740
All I need to do is create
a string that contains that

00:28:06.800 --> 00:28:08.920
JavaScript function that I want to call.

00:28:09.100 --> 00:28:11.100
So again, build up an NSString.

00:28:11.100 --> 00:28:14.110
Here I'm going to tell my
UI web view to display a common

00:28:14.130 --> 00:28:16.000
JavaScript alert to the user.

00:28:16.100 --> 00:28:18.520
So I'm saying window.alert,
throwing some text in there

00:28:18.600 --> 00:28:21.050
to present to the user.

00:28:21.340 --> 00:28:25.200
And then I call the UI WebView method
passing that string.

00:28:25.200 --> 00:28:27.680
And there's a long function name here,
string by evaluating

00:28:27.680 --> 00:28:29.040
JavaScript from string.

00:28:29.050 --> 00:28:30.200
Just pass in that string.

00:28:30.200 --> 00:28:34.860
And as a result, that alert's going to be
presented within the context of

00:28:34.860 --> 00:28:36.720
the web content being displayed.

00:28:36.720 --> 00:28:38.200
Really straightforward.

00:28:38.200 --> 00:28:41.060
I can have any sort of
get element by ID call.

00:28:41.060 --> 00:28:44.760
I could say window.location.href equals,
tell it to navigate.

00:28:44.760 --> 00:28:47.230
Any of that JavaScript that
you're used to calling within

00:28:47.230 --> 00:28:49.570
the context of the web page,
you can build up a string of

00:28:49.570 --> 00:28:51.120
that and call it just like that.

00:28:51.200 --> 00:28:53.640
Just by passing it through
this particular native

00:28:53.640 --> 00:28:55.230
function to the view itself.

00:28:57.010 --> 00:29:00.370
Key is to only inspect the
DOM after the web view is loaded.

00:29:00.660 --> 00:29:02.910
So I mentioned that there's
this web view did finish load

00:29:02.910 --> 00:29:07.100
delegate that's called after the
UI web view is completely loaded.

00:29:07.110 --> 00:29:09.450
Once it's completely loaded
then the DOM is fully intact.

00:29:09.450 --> 00:29:11.720
You can make any sorts of
calls that you want to the

00:29:11.830 --> 00:29:13.460
content that's sitting in there.

00:29:13.460 --> 00:29:16.030
Until this particular method is called,
you don't want to call any

00:29:16.090 --> 00:29:19.500
JavaScript because it's not fully
there yet and so you might not get

00:29:19.500 --> 00:29:21.800
the results that you were expecting.

00:29:21.820 --> 00:29:24.500
So only call it after it's been loaded.

00:29:24.500 --> 00:29:26.180
Now let's go the other way.

00:29:26.180 --> 00:29:29.680
Let's go and call into native
based on the user doing something

00:29:29.680 --> 00:29:33.920
within the context of UI web view.

00:29:33.950 --> 00:29:37.190
So the way that we do that is we take
advantage of the fact that we've got

00:29:37.190 --> 00:29:41.300
a delegate within the UI web view
that gets called every time UI web

00:29:41.300 --> 00:29:43.940
view has been asked to load content.

00:29:43.980 --> 00:29:47.070
So if I tell a UI web view to go
and load content from the web,

00:29:47.170 --> 00:29:49.700
this particular delegate
function is called and it

00:29:49.850 --> 00:29:52.720
should start load with request.

00:29:52.720 --> 00:29:53.780
So my web view is being asked
to load content from the web.

00:29:53.780 --> 00:29:53.910
So I'm going to call it every time UI web
view has been asked to load content.

00:29:53.910 --> 00:29:54.020
So if I tell a UI web view to go
and load content from the web,

00:29:54.020 --> 00:29:54.020
this particular delegate
function is called and it

00:29:54.020 --> 00:29:54.020
should start load with request.

00:29:54.020 --> 00:29:54.020
So my web view is being asked
to load content from the web.

00:29:54.020 --> 00:29:54.340
So I'm going to call it after
the user doing something within

00:29:54.340 --> 00:29:55.020
the context of UI web view has
been asked to load content.

00:29:55.020 --> 00:29:55.880
So the way that we do that is we take
advantage of the fact that this thing

00:29:55.880 --> 00:29:59.420
is being called every single time
and trick it to call our own scheme,

00:29:59.660 --> 00:30:01.020
our own destination.

00:30:01.020 --> 00:30:10.770
So instead of having content
like a link or a button within

00:30:10.770 --> 00:30:20.480
my web context that calls,
that points to HTTP colon

00:30:20.480 --> 00:30:23.540
my function up in the cloud,
I would call it every single time.

00:30:23.550 --> 00:30:28.350
So I would come up with my own scheme
and it would be like my app colon slash

00:30:28.350 --> 00:30:31.860
slash and then a whole chunk of data.

00:30:31.860 --> 00:30:35.770
So I know that my should start load
request is going to get called.

00:30:36.260 --> 00:30:39.240
Based on any sort of navigation,
so here's a little snippet.

00:30:39.240 --> 00:30:42.770
I've got a button element that's
sitting within a piece of web

00:30:42.770 --> 00:30:47.520
content and a JavaScript function
and an unclick handler there.

00:30:47.520 --> 00:30:50.900
My delegate gets called any time
that UI WebView is asked to go

00:30:50.900 --> 00:30:52.770
somewhere to load a request.

00:30:52.770 --> 00:30:56.380
So I say window.location which
tells the view to go and load

00:30:56.400 --> 00:30:59.410
some content and instead of
having it point to the public web,

00:30:59.410 --> 00:31:00.400
I use my own scheme.

00:31:00.400 --> 00:31:03.640
So I put my app colon and
then some raw data there.

00:31:03.640 --> 00:31:06.560
That's the data that I want
to pass from the web context

00:31:06.830 --> 00:31:09.590
down into the native context.

00:31:09.720 --> 00:31:13.260
So as a result of that particular
function getting called,

00:31:13.260 --> 00:31:16.560
I can look at the scheme and
if it's a scheme that I own,

00:31:16.560 --> 00:31:19.470
it's something that I wanted
to trigger from my web context,

00:31:19.630 --> 00:31:22.240
I can grab it and do
something interesting.

00:31:22.240 --> 00:31:26.250
If it's an HTTP scheme or
it's something that I know the

00:31:26.300 --> 00:31:28.660
browser just knows how to handle,
then I can just let

00:31:28.660 --> 00:31:29.990
the browser handle it.

00:31:30.000 --> 00:31:32.880
I can just let it pass
through and not grab it.

00:31:32.940 --> 00:31:36.480
So that's the mechanism for
communicating between the two.

00:31:36.490 --> 00:31:41.680
We've got a class on the desktop,
Mac OS X desktop called WebKit.

00:31:41.680 --> 00:31:45.630
UI WebView is quite a bit different
from WebKit even though there's overlap

00:31:45.820 --> 00:31:48.260
from some of the API perspectives.

00:31:48.360 --> 00:31:52.410
You definitely don't want to leave
here thinking that there's an

00:31:52.530 --> 00:31:54.930
equivalent API to WebKit on iPhone.

00:31:54.980 --> 00:31:57.180
The web views are
significantly different.

00:31:57.220 --> 00:32:00.370
So a web view is significantly
different from a UI web view.

00:32:00.440 --> 00:32:03.580
But this little mechanism,
this little trickery allows you

00:32:03.590 --> 00:32:05.270
to talk from one to the other.

00:32:07.350 --> 00:32:09.130
All right,
so that's displaying web content,

00:32:09.140 --> 00:32:10.840
all the different
document types we support,

00:32:10.870 --> 00:32:15.200
the standards-based content as
well as some manipulation between

00:32:15.200 --> 00:32:17.190
the two different architectures.

00:32:17.320 --> 00:32:20.230
Let's talk a little bit
about calling web services.

00:32:20.360 --> 00:32:22.040
There's two standards that
I certainly know about.

00:32:22.040 --> 00:32:24.260
One is SOAP and the other one is REST.

00:32:24.300 --> 00:32:27.000
So I'm gonna talk a little
bit about each one of them.

00:32:27.140 --> 00:32:30.280
I'm gonna talk less about one
and you can probably guess which

00:32:30.280 --> 00:32:31.540
one I'm gonna talk less about.

00:32:31.540 --> 00:32:32.260
Let's start with it.

00:32:32.490 --> 00:32:33.980
It's called SOAP.

00:32:34.030 --> 00:32:37.780
Folks that aren't used to seeing
any sort of SOAP APIs or even

00:32:37.780 --> 00:32:40.160
know what I'm talking about,
I've got a little diagram.

00:32:40.160 --> 00:32:42.580
It's basically a client server call,
right?

00:32:42.580 --> 00:32:44.500
You've got the client, that's the iPhone.

00:32:44.500 --> 00:32:46.130
Most SOAP calls are a post.

00:32:46.270 --> 00:32:53.680
SOAP calls are a post because of the
envelope associated with the SOAP method.

00:32:53.730 --> 00:32:58.140
So client, be it iPhone or whatever,
creates an XML envelope,

00:32:58.140 --> 00:33:00.660
makes an HTTP post to a service.

00:33:00.670 --> 00:33:03.720
The server then responds with
a SOAP envelope that's got

00:33:03.820 --> 00:33:07.140
the XML content within it.

00:33:07.140 --> 00:33:10.120
And this is what a typical
SOAP request looks like.

00:33:10.190 --> 00:33:12.500
It's got HTTP headers associated with it.

00:33:12.500 --> 00:33:14.980
It's got this thing called
the SOAP envelope that sits

00:33:14.980 --> 00:33:17.940
around the particular call.

00:33:17.940 --> 00:33:20.120
And then lo and behold,
in the middle here is this

00:33:20.120 --> 00:33:21.100
little piece of functionality.

00:33:21.100 --> 00:33:24.960
This is the actual data that we're
sending back and forth to the server.

00:33:24.970 --> 00:33:28.500
That's got basically the unique
characteristics of this call.

00:33:28.540 --> 00:33:31.840
SOAP's a really nice technology
because it allows an abstraction.

00:33:31.840 --> 00:33:33.580
It's sort of like Corba for the web.

00:33:33.680 --> 00:33:36.800
From my perspective,
it provides a nice abstraction

00:33:36.800 --> 00:33:39.390
between various interfaces.

00:33:39.560 --> 00:33:41.260
That's a SOAP request.

00:33:41.260 --> 00:33:43.220
This is what a SOAP response looks like.

00:33:43.300 --> 00:33:46.900
Again, typical HTV headers
that you would expect.

00:33:46.900 --> 00:33:48.900
Again, the SOAP envelope.

00:33:49.470 --> 00:33:52.280
And then in the middle there is
the result of that particular

00:33:52.280 --> 00:33:53.640
function call that I made.

00:33:53.640 --> 00:33:58.280
So a lot of folks think that SOAP is
something that's a little overly verbose.

00:33:58.280 --> 00:34:02.160
There is a lot of content here,
but you do get some nice

00:34:02.160 --> 00:34:06.420
retrospection capability and
other things out of using SOAP.

00:34:06.520 --> 00:34:08.870
So what do we have on the iPhone?

00:34:08.950 --> 00:34:12.490
Well, anybody that's used to building
Macintosh applications will see that

00:34:12.500 --> 00:34:17.960
we've got a huge web services star set
of frameworks and such on the desktop.

00:34:17.960 --> 00:34:20.420
None of that stuff is over on the iPhone.

00:34:20.420 --> 00:34:24.080
So from a SOAP perspective,
you can either build and

00:34:24.240 --> 00:34:28.350
parse SOAP manually using the
XML classes that we've got.

00:34:28.360 --> 00:34:31.830
But there's also some interesting
third party libraries out there

00:34:31.910 --> 00:34:34.460
that you might wanna take a look at.

00:34:34.460 --> 00:34:37.900
The first one is GSOAP out
of Florida State University,

00:34:37.910 --> 00:34:43.960
and the second one is Access2
from the Apache Foundation.

00:34:43.990 --> 00:34:47.960
So both of these are great
libraries for making SOAP calls.

00:34:47.960 --> 00:34:51.440
Access2 is particularly
useful if you love WSDL.

00:34:51.450 --> 00:34:54.280
So if you love WSDL,
then Access2 supports it.

00:34:54.280 --> 00:34:57.520
GSOAP does not,
but both of them work fine for

00:34:57.520 --> 00:34:59.280
making SOAP based calls on iPhone.

00:34:59.280 --> 00:35:01.040
Compile them into your application.

00:35:01.040 --> 00:35:05.750
Both have generous legal agreements
so that it's easy for you to

00:35:05.750 --> 00:35:09.580
distribute it without begging
for permission out of these guys.

00:35:09.590 --> 00:35:13.980
So this is the SOAP implementation
that you can use if you've got

00:35:14.020 --> 00:35:15.160
SOAP within your environment.

00:35:15.260 --> 00:35:17.960
If you're using a RESTful
type of application,

00:35:17.990 --> 00:35:19.950
you can use RESTful technology,
something on the back

00:35:19.950 --> 00:35:21.500
end that's more RESTful.

00:35:21.500 --> 00:35:24.760
Well, you've got the same sort of
client server model where you're

00:35:24.760 --> 00:35:26.580
making these web services calls.

00:35:26.580 --> 00:35:29.540
However,
RESTful calls are typically GETs, right?

00:35:29.540 --> 00:35:32.760
A little less heavy.

00:35:32.760 --> 00:35:34.520
And the responses are XML, right?

00:35:34.600 --> 00:35:37.140
There isn't a SOAP envelope
going in either direction.

00:35:37.140 --> 00:35:40.460
It's really up to the user to
define what those interfaces are.

00:35:40.460 --> 00:35:42.060
So still client server.

00:35:42.070 --> 00:35:45.160
This is a typical RESTful request, right?

00:35:45.160 --> 00:35:45.850
It's a URL.

00:35:45.960 --> 00:35:47.720
It's got the destination.

00:35:47.720 --> 00:35:49.260
It's got the object.

00:35:49.260 --> 00:35:51.060
It's got the method name.

00:35:51.060 --> 00:35:53.660
And it's got any parameters
just sitting right on it.

00:35:53.660 --> 00:35:56.140
That's why it's typically a GET request.

00:35:56.160 --> 00:36:00.210
So this is a RESTful request,
RESTful responses.

00:36:00.700 --> 00:36:01.440
Sky's the limit, right?

00:36:01.440 --> 00:36:03.590
It's up to the server to define
what kind of XML comes back

00:36:03.670 --> 00:36:04.980
so it's all sorts of content,
right?

00:36:05.040 --> 00:36:08.070
There isn't a defined DTD like
there is in the SOAP world for

00:36:08.250 --> 00:36:09.920
these kinds of transactions.

00:36:09.920 --> 00:36:12.090
So this is an HTTP response.

00:36:14.300 --> 00:36:16.870
So there's three core networking
classes that you're going to use to

00:36:16.870 --> 00:36:18.990
make these kinds of calls on iPhones.

00:36:19.090 --> 00:36:19.540
On iPhone.

00:36:19.730 --> 00:36:20.860
You're going to use
them all over the place.

00:36:20.930 --> 00:36:23.320
The first one, NSURL,
I already mentioned,

00:36:23.360 --> 00:36:25.920
you're going to use that for
loading content into a UI web view.

00:36:25.920 --> 00:36:29.300
Anytime you want to go and
access any sort of web service,

00:36:29.480 --> 00:36:33.090
you're going to use the same
high-level class to go and reference

00:36:33.090 --> 00:36:35.650
a service that's sitting in the cloud.

00:36:36.580 --> 00:36:39.880
As I showed for the UI web view example,
it supports file-based,

00:36:39.880 --> 00:36:43.920
so something sitting locally
as well as cloud-based URLs.

00:36:43.920 --> 00:36:47.980
And it's really a nice class to
use even though it just basically

00:36:47.980 --> 00:36:51.840
holds a string because you can go
and dissect the parts of a URL.

00:36:51.840 --> 00:36:54.960
So if you want to ask a URL object
for its port or for its path,

00:36:54.960 --> 00:36:59.280
its query string, all sorts of things,
you've got high-level access there.

00:36:59.380 --> 00:37:02.840
Most of our classes,
our networking classes require an

00:37:02.840 --> 00:37:05.500
NSURL object as one of the parameters.

00:37:05.500 --> 00:37:09.750
Second, one that you're going to use
most often is NSURL request.

00:37:09.760 --> 00:37:12.100
That's encapsulating the
payload of a request.

00:37:12.520 --> 00:37:17.190
Typically,
a GET request is what you would

00:37:17.200 --> 00:37:19.580
get if you're using NSURL request.

00:37:20.200 --> 00:37:22.540
If you want to do a post
to a RESTful service,

00:37:22.650 --> 00:37:25.670
then you're going to use
NSMutable URL request.

00:37:25.710 --> 00:37:28.700
When you're using the
Mutable URL request,

00:37:28.700 --> 00:37:32.210
you've got access to all
the parts of the body.

00:37:32.260 --> 00:37:34.970
So you can put in your own headers.

00:37:34.970 --> 00:37:35.960
You can set the body if you'd like.

00:37:35.990 --> 00:37:36.560
So you can set the body if you'd like.

00:37:36.590 --> 00:37:41.260
You can do multi-part uploads if
you're doing basic form completion.

00:37:41.260 --> 00:37:43.340
You can embed your own
cookies within the posts,

00:37:43.340 --> 00:37:44.080
all sorts of things.

00:37:44.080 --> 00:37:46.240
This is the class that you would use.

00:37:47.940 --> 00:37:50.430
One nice thing about it is
it gives you great control

00:37:50.430 --> 00:37:52.040
over locally cached content.

00:37:52.040 --> 00:37:55.990
So you can create an issue or a request
and you can provide arguments to it

00:37:56.000 --> 00:38:00.440
that indicate whether it's okay or
not to use content that was previously

00:38:00.440 --> 00:38:02.960
fetched from the same destination.

00:38:02.960 --> 00:38:05.590
And there's a shared cookie store.

00:38:05.590 --> 00:38:09.940
So any cookies that I may have retrieved
through a session interaction over on

00:38:09.940 --> 00:38:13.680
the Safari browser side are available
to me within a native application

00:38:13.680 --> 00:38:15.400
where I'm using these classes.

00:38:15.400 --> 00:38:18.150
So as long as the cookies
came from the same domain,

00:38:18.150 --> 00:38:22.890
once I'm over in a native application,
those cookies are going to be posted with

00:38:22.960 --> 00:38:26.590
each one of the posts to that same domain
when I'm using these native classes.

00:38:26.600 --> 00:38:30.360
So it allows you to build something
where you can share session information,

00:38:30.360 --> 00:38:33.240
all sorts of things,
just by jumping between the two.

00:38:33.240 --> 00:38:36.820
Final class that you're going
to use is NSURL connection.

00:38:36.820 --> 00:38:40.010
And this does the management of the
communication with the back end.

00:38:40.040 --> 00:38:43.270
It's that final piece when
it's time to go and send that

00:38:43.270 --> 00:38:45.040
request up to the server.

00:38:45.400 --> 00:38:49.620
So it supports synchronous as well
as asynchronous loading of content.

00:38:49.660 --> 00:38:52.840
So you could block your user interface,
you can block your thread while

00:38:52.840 --> 00:38:55.360
you're going and pulling down
data if you want to do that.

00:38:55.360 --> 00:38:56.040
You probably shouldn't.

00:38:56.120 --> 00:39:01.160
There's a slew of callbacks
associated with redirects,

00:39:01.160 --> 00:39:03.500
which is nice,
especially if you're building an

00:39:03.500 --> 00:39:05.580
application that you want to be secure.

00:39:05.580 --> 00:39:07.340
If you tell your application
to point to somewhere in the

00:39:07.470 --> 00:39:09.020
cloud and the cloud says,
no, you know what,

00:39:09.080 --> 00:39:10.700
the data's really over here.

00:39:10.700 --> 00:39:13.070
It'd be nice to know within your
application that somebody's telling

00:39:13.070 --> 00:39:16.340
you to go somewhere other than
where the data really does reside.

00:39:16.340 --> 00:39:20.280
So this particular class has a
callback associated with it where

00:39:20.280 --> 00:39:24.350
it will say to your application,
hey, you know, the server says you should

00:39:24.350 --> 00:39:25.660
go over here for the content.

00:39:25.660 --> 00:39:27.780
You've got the capability
to look at that URL and say,

00:39:27.780 --> 00:39:30.660
no, I don't want to go to this
particular site anymore.

00:39:30.660 --> 00:39:31.620
Something's been breached.

00:39:31.620 --> 00:39:34.740
There's a man in the middle
or something going on here.

00:39:34.750 --> 00:39:37.280
There's also callbacks for
authentication challenges.

00:39:37.280 --> 00:39:41.770
We'll handle all the sort of standard
authentication challenges that occur.

00:39:41.780 --> 00:39:45.580
So if there's a certificate sitting
on a server through which you're

00:39:45.580 --> 00:39:48.980
trying to talk to a particular web
servers and that certificate we have

00:39:48.980 --> 00:39:51.680
a route within our search store,
we'll take care of that

00:39:51.680 --> 00:39:52.760
authentication challenge.

00:39:52.760 --> 00:39:53.640
That's already handled.

00:39:53.760 --> 00:39:56.470
But if we hit a challenge,
there's a server up there that

00:39:56.480 --> 00:39:59.210
we can't validate or somebody
on the server side is trying to

00:39:59.410 --> 00:40:01.420
authenticate through another mechanism.

00:40:01.420 --> 00:40:02.460
We've got a callback there.

00:40:02.460 --> 00:40:04.360
We'll call back to your
application and say,

00:40:04.360 --> 00:40:05.780
okay, there's a challenge here.

00:40:05.780 --> 00:40:06.820
We don't know how to handle.

00:40:06.820 --> 00:40:08.240
How do you want to go?

00:40:08.240 --> 00:40:11.140
And so people take advantage of
those callbacks in order to go and

00:40:11.140 --> 00:40:15.100
implement their own authentication
mechanisms within their network.

00:40:15.100 --> 00:40:17.100
And so that's something that we're
trying to do in our native application.

00:40:17.100 --> 00:40:20.480
The final piece within NSURL connection
is you've got even more granular

00:40:20.480 --> 00:40:24.080
control over caching capabilities.

00:40:25.120 --> 00:40:29.490
So there's a final class that
I talk about but is not available,

00:40:29.490 --> 00:40:31.040
you shouldn't use.

00:40:31.040 --> 00:40:32.630
It's called NSURL download.

00:40:32.630 --> 00:40:34.970
It's actually in the documentation.

00:40:35.100 --> 00:40:38.610
It works in the simulator but once
you move your code over to the

00:40:38.610 --> 00:40:41.500
iPhone itself or an iPod touch,
it doesn't work.

00:40:41.500 --> 00:40:46.240
So it's fairly useful except it does
something that we don't want a lot of

00:40:46.240 --> 00:40:48.500
users doing and that's writing to disk.

00:40:48.500 --> 00:40:50.840
This particular class,
all you do is you point it

00:40:50.840 --> 00:40:53.390
to a URL in the cloud and you
get a file as a result of it.

00:40:53.500 --> 00:40:55.730
We want to try to make
it a little bit harder,

00:40:55.760 --> 00:41:00.580
a little more intentional for
people writing to flash-based

00:41:00.580 --> 00:41:02.840
memory on these devices.

00:41:02.840 --> 00:41:06.100
So those are the three primary
classes and the one not to use.

00:41:06.260 --> 00:41:10.790
A little graphic here for calling a
particular web service in the cloud.

00:41:11.060 --> 00:41:14.480
The call is going to be made
based on my native application.

00:41:14.480 --> 00:41:17.820
Within my native application,
I've created my own class

00:41:17.850 --> 00:41:19.380
called My Data Grabber.

00:41:19.380 --> 00:41:21.360
This is the guy that's going to be in
charge of talking to the data grabber

00:41:21.420 --> 00:41:23.260
and he's going to be talking to my
web service up there in the cloud.

00:41:23.260 --> 00:41:25.700
So I instantiate my data grabber.

00:41:25.760 --> 00:41:28.430
First thing I'm going to do to
go and talk to my service in the

00:41:28.430 --> 00:41:31.210
cloud is create this NSURL object,
right?

00:41:31.320 --> 00:41:34.440
It contains a string that
points to my web service.

00:41:34.480 --> 00:41:38.720
Next thing I'm going to do is
create an NSURL request passing in

00:41:38.850 --> 00:41:41.480
that URL as one of the arguments.

00:41:41.480 --> 00:41:45.590
And then the third step is to
create this NSURL connection object

00:41:45.870 --> 00:41:49.180
and pass it the request object in.

00:41:49.180 --> 00:41:52.490
And I'm going to pass in a reference
to my class because my class is going

00:41:52.560 --> 00:41:55.850
to want to hear about interesting
things that are happening with this

00:41:55.970 --> 00:41:58.420
particular communication to the server.

00:41:58.420 --> 00:42:00.920
So once I go and I call this
particular method with this

00:42:00.920 --> 00:42:05.780
NSURL connection instantiation,
a call is made up to the server pointing

00:42:05.780 --> 00:42:08.300
to that particular URL that was provided.

00:42:08.300 --> 00:42:12.430
The get goes up and then the data
comes back down from the server.

00:42:12.970 --> 00:42:15.500
Something to keep in mind is that
the data is not necessarily going

00:42:15.500 --> 00:42:17.720
to come back in one fell swoop.

00:42:17.720 --> 00:42:21.010
It might be packed up by
the server and sent in a,

00:42:21.010 --> 00:42:24.000
in a bulk.

00:42:24.000 --> 00:42:26.650
And each time we get a
chunk of data from the user,

00:42:26.760 --> 00:42:29.750
this particular method is going
to get called on the delegate,

00:42:29.750 --> 00:42:32.320
the listener that cares
about this communication.

00:42:32.320 --> 00:42:34.840
It's going to call did receive data.

00:42:34.840 --> 00:42:37.220
Data is going to be
passed as an argument.

00:42:37.220 --> 00:42:40.900
It's going to get called each time
I get a buffer of data from the server.

00:42:40.900 --> 00:42:43.660
So you're going to want to go and
concatenate that data structure

00:42:43.660 --> 00:42:48.540
up within your native application
until the transaction is complete.

00:42:48.540 --> 00:42:52.290
And the way that you know the transaction
is complete is connect to the server.

00:42:52.350 --> 00:42:55.180
And then you're going to want
to wait until the connection

00:42:55.180 --> 00:42:57.280
did finish loading is called.

00:42:57.300 --> 00:42:59.550
Now all of that data that
I received can be thrown

00:42:59.550 --> 00:43:02.430
together and maybe it's an image,
I can present it,

00:43:02.430 --> 00:43:06.300
maybe it's a chunk of XML,
I can throw it to a parser and parse it.

00:43:06.300 --> 00:43:07.550
So you want to wait until that
particular method is called,

00:43:07.550 --> 00:43:08.300
then you're good to go with the

00:43:09.310 --> 00:43:10.580
So those are the core classes.

00:43:10.870 --> 00:43:14.320
The examples that we've got that take
advantage of these are reachability,

00:43:14.430 --> 00:43:18.360
very useful to determining if
a particular URL is available.

00:43:18.360 --> 00:43:21.440
It's important to find out if a URL is
available before you make the call.

00:43:21.440 --> 00:43:24.990
And the nice thing about reachability
is you can detect whether it's going

00:43:24.990 --> 00:43:28.440
to be accessible via a Wi-Fi connection
or a cellular connection.

00:43:28.440 --> 00:43:29.460
So that's pretty useful.

00:43:30.380 --> 00:43:34.800
Ytap and Bonjour Web both take
advantage of these three core classes.

00:43:34.800 --> 00:43:38.340
And URL cache is particularly
interesting for looking at the

00:43:38.340 --> 00:43:41.530
caching mechanism associated
with the various network calls.

00:43:44.360 --> 00:43:45.560
So that's calling web services.

00:43:45.700 --> 00:43:49.730
Web services typically respond
with some sort of XML content.

00:43:50.210 --> 00:43:52.890
We've got a couple open source
libraries that we provide at

00:43:52.890 --> 00:43:54.740
the bottom layer on iPhone.

00:43:54.740 --> 00:43:55.880
They're also on the desktop.

00:43:55.900 --> 00:43:58.390
The first one is libxml2.

00:43:58.570 --> 00:44:03.180
So if you want C-based access
to parsing XML content,

00:44:03.220 --> 00:44:06.270
then you've got it just
through the libxml2 library.

00:44:06.280 --> 00:44:12.190
We've also got libxslt on
iPhone and iPod Touch as well.

00:44:12.200 --> 00:44:15.940
So if you're doing any
sort of XML transformations

00:44:16.010 --> 00:44:20.100
based on XML style sheets,
then you can leverage this library

00:44:20.100 --> 00:44:21.940
to perform those transformations.

00:44:22.070 --> 00:44:26.580
The Safari browser as well as the
UI web view will take any XML content

00:44:26.650 --> 00:44:31.120
that's being presented and transform
it on its own without you having

00:44:31.120 --> 00:44:36.330
to use this library as long as it
includes an XML style sheet within it.

00:44:36.400 --> 00:44:39.800
So you don't necessarily need to go and
use this library if you're just taking

00:44:39.800 --> 00:44:44.300
XML content and presenting it as HTML,
for example, within a UI web view

00:44:44.300 --> 00:44:46.280
or within the browser.

00:44:46.350 --> 00:44:48.320
So these are the two low level
libraries that you have access to.

00:44:48.360 --> 00:44:52.760
They're open source, so the documentation
is open source as well.

00:44:52.770 --> 00:44:54.680
So it's xmlsoft.org.

00:44:54.680 --> 00:44:56.960
There's examples up there as
well as the documentation,

00:44:56.980 --> 00:44:58.950
so take a look at that.

00:45:02.230 --> 00:45:06.730
We've got a high level XML support
class built into iPhone as well.

00:45:06.860 --> 00:45:09.380
So at a higher level
on top of that XML lib,

00:45:09.380 --> 00:45:11.230
we provide an NSXML parser.

00:45:11.300 --> 00:45:15.760
And what this is is a single pass parser,
no DOM.

00:45:15.760 --> 00:45:20.310
So you don't have access to functions
in order to query for particular nodes.

00:45:20.450 --> 00:45:21.840
It's all about sort of top down.

00:45:21.840 --> 00:45:26.320
Let me walk through all of your XML and
then provide you callbacks each time

00:45:26.320 --> 00:45:28.860
I hit elements within the XML itself.

00:45:28.860 --> 00:45:30.560
Single pass.

00:45:30.590 --> 00:45:32.780
So it's delegate based.

00:45:32.780 --> 00:45:38.820
And you basically get a callback
within your class that responds to

00:45:38.820 --> 00:45:44.150
the NSXML parser delegate methods
for each time an open element

00:45:44.470 --> 00:45:46.690
is found within the content.

00:45:46.750 --> 00:45:50.900
It calls didStartElement,
passes a dictionary of the attributes

00:45:51.000 --> 00:45:52.340
for the particular open element.

00:45:52.380 --> 00:45:57.680
There's a callback each time we
find content within an element

00:45:57.680 --> 00:45:59.760
between a begin and end tag.

00:45:59.760 --> 00:46:01.880
And that's foundCharacters.

00:46:01.880 --> 00:46:03.710
FoundCharacters is buffer based as well.

00:46:03.810 --> 00:46:07.740
So you want to buffer up any
string that's returned because that

00:46:07.820 --> 00:46:10.380
could be called multiple times.

00:46:10.380 --> 00:46:14.440
And it'll be called multiple times
until the close element is reached

00:46:14.470 --> 00:46:17.380
for any item within your XML.

00:46:17.380 --> 00:46:21.600
And when a close element is reached,
didEndElement is the method that's

00:46:22.100 --> 00:46:24.270
called in your parser delegate.

00:46:25.140 --> 00:46:30.670
Once the didElement function is called,
all your concatenated string is

00:46:30.700 --> 00:46:35.450
ready for presentation or ready
for use within your application.

00:46:36.530 --> 00:46:40.880
SDK samples, Seismic XML,
best example out there

00:46:40.880 --> 00:46:42.660
for using NSXML parser.

00:46:42.660 --> 00:46:49.020
It does it in a asynchronous mechanism,
it asynchronously loads a table as well.

00:46:49.140 --> 00:46:51.400
So it's a pretty useful example
for all sorts of things,

00:46:51.400 --> 00:46:56.010
spawning threads, parsing XML,
and presenting data in a

00:46:56.010 --> 00:46:58.730
table in a threaded manner.

00:47:02.560 --> 00:47:04.180
While we're talking
about high level support,

00:47:04.220 --> 00:47:07.980
one thing that you should think
about is P-List formatted XML.

00:47:08.020 --> 00:47:11.620
If you own the back end
and you own the structure,

00:47:11.620 --> 00:47:15.580
the DTD of the XML content that
you're pushing down to the clients,

00:47:15.580 --> 00:47:18.900
you might consider putting
it in P-List format.

00:47:18.900 --> 00:47:22.470
P-List DTD is something that we use all
over the Macintosh as well as iPhone

00:47:22.570 --> 00:47:25.150
for holding configuration information.

00:47:25.200 --> 00:47:29.680
It's basically our default text file
format for configuration information and

00:47:29.790 --> 00:47:31.600
preferences and those kinds of things.

00:47:31.600 --> 00:47:36.040
So if you own the back end and you
can create your XML in this particular

00:47:36.040 --> 00:47:40.880
format using this particular DTD,
then you get a big bang for it.

00:47:40.880 --> 00:47:45.970
So this is what P-List
formatted XML looks like.

00:47:46.040 --> 00:47:48.020
You can see it's got a
limited set of entities,

00:47:48.020 --> 00:47:51.590
so things like dict,
therefore dictionary objects,

00:47:51.590 --> 00:47:55.420
there's strings,
you also see key value pairs,

00:47:55.420 --> 00:47:58.000
there's array types in here.

00:47:58.000 --> 00:48:01.120
So it's a fixed set of entities.

00:48:01.560 --> 00:48:05.020
if you can live within this
particular environment what you get

00:48:05.180 --> 00:48:08.680
is very easily marshaled data types.

00:48:08.680 --> 00:48:12.040
Basically,
we'll parse through P list formatted

00:48:12.040 --> 00:48:17.800
XML and do the conversion for you to data
types that are native on iPhone itself.

00:48:17.840 --> 00:48:22.790
So, anytime we hit a string element
we'll convert it to an NSString.

00:48:22.790 --> 00:48:24.840
An array will become an NSArray.

00:48:25.070 --> 00:48:28.320
A dict will become an
NSDictionary along with all its

00:48:28.490 --> 00:48:30.250
keys and the values within it.

00:48:30.250 --> 00:48:33.700
Bool and its number and its
data and its date accordingly.

00:48:33.700 --> 00:48:36.820
So, it's really easy way to go
and do the marshaling for a

00:48:36.830 --> 00:48:38.240
lot of different data types.

00:48:38.350 --> 00:48:41.120
So, you don't have to do all the
string conversion on your own.

00:48:44.590 --> 00:48:47.920
So, easily loaded,
NSDictionary class can take

00:48:48.450 --> 00:48:51.600
PList formatted XML directly.

00:48:51.650 --> 00:48:56.740
So if you've made a web service call,
it's come down as PList formatted XML.

00:48:56.740 --> 00:49:01.860
You can instantiate an NSDictionary class
directly with the contents of a file,

00:49:01.860 --> 00:49:05.990
with the contents of a URL,
the contents of a data buffer

00:49:06.110 --> 00:49:09.880
and you get a dictionary
object out of it as a result.

00:49:09.940 --> 00:49:13.170
The dictionary object then you've got
very much like a DOM implementation

00:49:13.250 --> 00:49:16.240
where you can ask it for its keys,
you can ask for the objects

00:49:16.240 --> 00:49:17.540
associated with keys.

00:49:17.540 --> 00:49:21.030
It's a really nice implementation
and really easy to go and hook up to

00:49:21.070 --> 00:49:24.570
things like table views and picker
selectors and those kinds of things

00:49:24.570 --> 00:49:26.330
within the iPhone user interface.

00:49:27.790 --> 00:49:28.940
So, and they're very fast.

00:49:28.940 --> 00:49:31.180
I mean we use these file
formats all over the place.

00:49:31.180 --> 00:49:34.200
And so the code that we've
written is highly optimized for

00:49:34.200 --> 00:49:36.180
parsing this kind of content.

00:49:36.200 --> 00:49:40.940
So I've got an example where I've loaded
my entire iTunes dictionary into a,

00:49:40.940 --> 00:49:44.380
a P list into an NSDictionary.

00:49:44.380 --> 00:49:45.950
And it loads it incredibly fast.

00:49:45.960 --> 00:49:48.180
It navigates the keys incredibly fast.

00:49:48.180 --> 00:49:49.580
And it's a huge file.

00:49:49.580 --> 00:49:53.590
So it's, it's something you should
definitely take a look at.

00:49:53.650 --> 00:49:57.260
If you've never seen any of these files
or you want a high level application to

00:49:57.260 --> 00:49:59.380
create your own P list formatted XML.

00:49:59.380 --> 00:50:03.640
There's a property list editor
application that's on every Macintosh.

00:50:03.640 --> 00:50:06.420
Allows you to interactively
go and create these files,

00:50:06.420 --> 00:50:09.100
choose data types associated with fields.

00:50:09.100 --> 00:50:12.040
And then you can generate an
XML file as a result of using

00:50:12.040 --> 00:50:14.660
this app and take a look at the,
the data that it's formatted.

00:50:14.660 --> 00:50:17.320
So give that a whirl if
you haven't seen it before.

00:50:20.100 --> 00:50:22.580
That's parsing XML,
pretty straightforward.

00:50:22.600 --> 00:50:23.980
Moving on to saving data locally.

00:50:24.100 --> 00:50:28.880
I mentioned that web applications as well
as native applications live in a sandbox.

00:50:28.880 --> 00:50:32.150
Well, you've got the ability to
write files to that sandbox.

00:50:32.160 --> 00:50:34.910
You can read files from
that sandbox as well,

00:50:34.910 --> 00:50:37.180
those ones that you've written.

00:50:37.180 --> 00:50:40.040
One thing that folks want to do
is deploy multiple applications.

00:50:40.040 --> 00:50:42.280
Well, there's some restrictions there.

00:50:42.360 --> 00:50:46.030
Multiple applications can
read and write to a sandbox.

00:50:46.040 --> 00:50:51.680
However, they can't read and write
to each other's sandboxes.

00:50:51.680 --> 00:50:54.710
The goal is to provide a completely
secure environment where native

00:50:54.710 --> 00:50:59.760
applications can't just troll across
the file system and read willy-nilly.

00:50:59.760 --> 00:51:02.700
What that means is from an
application perspective,

00:51:02.700 --> 00:51:05.870
you can't read outside of
your particular area as well,

00:51:05.870 --> 00:51:09.000
even if you own both of
the applications and boy,

00:51:09.000 --> 00:51:12.880
it sure would be great to
share the data between the two.

00:51:12.920 --> 00:51:16.020
If you do own application one and you
do own application two and you want

00:51:16.020 --> 00:51:19.660
to share the data between the two,
there's other mechanisms.

00:51:19.660 --> 00:51:21.580
There's the cloud that's there.

00:51:21.580 --> 00:51:25.140
If I've got content that I want
to share between two applications,

00:51:25.140 --> 00:51:26.440
I can stick it in the cloud.

00:51:26.440 --> 00:51:29.890
My model can exist in the cloud and
both of these applications can access

00:51:29.960 --> 00:51:31.930
that same data because it's up there.

00:51:31.930 --> 00:51:33.200
It's centrally located.

00:51:33.200 --> 00:51:38.540
These are always connected devices or at
least most of the time connected devices.

00:51:38.540 --> 00:51:42.160
If I need to transfer information,
I can do it through the cloud.

00:51:42.160 --> 00:51:45.840
Another mechanism that we've got
is basically an open URL call.

00:51:46.080 --> 00:51:49.610
Where one application says, "Hey,
I've got a bunch of data and I want to

00:51:49.610 --> 00:51:54.170
send it to another application." He just
throws it up to the operating system.

00:51:54.180 --> 00:51:56.440
The operating system
catches that data and says,

00:51:56.440 --> 00:51:59.880
"I know who cares about this kind
of stuff," and then launches the

00:51:59.890 --> 00:52:03.970
second application and tells it
to go ahead and load the data.

00:52:04.000 --> 00:52:06.500
That's all through an open URL mechanism.

00:52:06.500 --> 00:52:09.810
The way that you configure your
application to receive this catch

00:52:09.810 --> 00:52:14.680
or to receive this tossed data
is by modifying your Info.plist,

00:52:14.680 --> 00:52:20.570
going to the URL types,
specifying a URL scheme within there.

00:52:20.600 --> 00:52:25.960
That scheme is the URL type that you
care about within your application.

00:52:25.960 --> 00:52:30.750
Now any time a web-based application
or a native application calls a

00:52:30.750 --> 00:52:34.730
URL that begins with that scheme,
in this example it's myapp2,

00:52:34.800 --> 00:52:38.010
your application is going to
get launched and the rest of the

00:52:38.010 --> 00:52:41.140
query string is going to be passed
to your particular application.

00:52:41.140 --> 00:52:44.480
I've got an example of what it
looks like in just a second.

00:52:44.600 --> 00:52:47.700
The key here is that you want to
make sure that your scheme is unique.

00:52:47.700 --> 00:52:51.630
There's a lot of different applications
that might want to go and implement

00:52:51.630 --> 00:52:53.560
this sort of data passing mechanism.

00:52:53.560 --> 00:52:56.080
You want to make sure that yours
is unique and the best way to

00:52:56.080 --> 00:53:00.450
do that is to define your scheme
as your application signature.

00:53:00.450 --> 00:53:02.650
Application signatures are
guaranteed to be unique for any

00:53:02.660 --> 00:53:05.160
application that's distributed.

00:53:05.230 --> 00:53:07.680
If you use the same URL scheme
as your application signature,

00:53:07.680 --> 00:53:12.140
then you're going to have
something that's inherently unique.

00:53:12.140 --> 00:53:14.460
You also want to make sure that you
don't use any of the schemes that are

00:53:14.480 --> 00:53:15.940
supported by built-in applications.

00:53:15.940 --> 00:53:20.130
Don't say that your application
can automatically handle HTTP or

00:53:20.550 --> 00:53:25.190
automatically handle FTP or SMS or
any of those other things that we

00:53:25.190 --> 00:53:28.430
do within the native applications
because it's going to be our

00:53:28.470 --> 00:53:30.350
application that's called every time.

00:53:30.470 --> 00:53:32.860
HTTP is going to launch Safari.

00:53:32.860 --> 00:53:35.320
Mailto scheme is going to
launch the mail application.

00:53:35.390 --> 00:53:38.440
SMS is going to launch
the SMS application.

00:53:38.440 --> 00:53:42.120
Those are the examples to stay away from.

00:53:42.120 --> 00:53:43.600
Come up with something of your own.

00:53:43.600 --> 00:53:45.920
Come up with something that's unique.

00:53:45.920 --> 00:53:45.920
That's key.

00:53:46.660 --> 00:53:47.400
So here's an example.

00:53:47.400 --> 00:53:50.200
I've got application one,
wants to send some data

00:53:50.200 --> 00:53:51.520
over to application two.

00:53:51.680 --> 00:53:56.600
So I create this URL string
and have the scheme in it,

00:53:56.610 --> 00:53:59.180
as well as a bucket of data,
this text data.

00:53:59.190 --> 00:54:02.580
I know that application two
responds to that particular scheme,

00:54:02.700 --> 00:54:03.400
my app two.

00:54:03.590 --> 00:54:05.920
So I build up this URL.

00:54:06.490 --> 00:54:08.050
Then I call open URL.

00:54:08.180 --> 00:54:12.920
This is a method on the application,
the shared application object.

00:54:12.920 --> 00:54:15.970
And I pass in that URL,
so I'm passing in that string

00:54:16.150 --> 00:54:18.220
myapp2 and then some data.

00:54:18.220 --> 00:54:22.750
And as a result of me calling that
particular application method,

00:54:22.750 --> 00:54:27.210
my application is dropped,
application 2 is launched,

00:54:27.210 --> 00:54:32.160
and then the handle open URL method
is called on application 2.

00:54:32.160 --> 00:54:35.380
And that URL is passed in,
so the myapp2:text data is

00:54:35.380 --> 00:54:40.100
passed to application 2 through
this particular mechanism.

00:54:40.100 --> 00:54:42.500
One thing that you want to remember when
you're implementing this in your own

00:54:42.500 --> 00:54:46.240
application is URLs can get launched
by a whole slew of different things,

00:54:46.240 --> 00:54:46.840
right?

00:54:46.840 --> 00:54:50.750
It can be any sort of native application
can decide to call your application

00:54:50.830 --> 00:54:53.400
scheme just because it wants to,
right?

00:54:53.580 --> 00:54:58.900
I could put a URL on a web page and surf
to that web page within Safari on iPhone.

00:54:58.900 --> 00:55:02.080
And if it's got a link in it
that's got your scheme on it,

00:55:02.080 --> 00:55:03.140
you can put that URL on it.

00:55:03.140 --> 00:55:04.250
If the user taps on it,
we're going to launch your

00:55:04.250 --> 00:55:05.780
application and pass it the data.

00:55:05.860 --> 00:55:09.450
So you want to be very cognizant
of the fact that this scheme

00:55:09.620 --> 00:55:12.940
can get called by other people,
other applications,

00:55:12.940 --> 00:55:14.450
random places on the web.

00:55:14.620 --> 00:55:20.410
So come up with a unique way of
securing your own data communication

00:55:20.410 --> 00:55:24.150
between your applications or your
services where you're going to

00:55:24.320 --> 00:55:25.420
go and take advantage of this.

00:55:25.420 --> 00:55:28.040
Don't just take whatever string
that you get from the wild

00:55:28.040 --> 00:55:29.870
and throw it into a database,
you know.

00:55:29.870 --> 00:55:32.120
It's a great mechanism
for doing buffer overflow.

00:55:32.120 --> 00:55:33.900
It's a great way to get the
data that you're going to be

00:55:34.050 --> 00:55:34.920
using to your application.

00:55:35.000 --> 00:55:37.690
So look at the data that comes in,
come up with a convention

00:55:37.690 --> 00:55:41.480
for how that data is going to
be passed to keep it secure.

00:55:41.480 --> 00:55:44.680
You might even encrypt the data that's
sitting there on the string when you

00:55:44.680 --> 00:55:48.560
pass it and only your native application,
the one that receives it,

00:55:48.700 --> 00:55:50.260
knows actually how to decrypt it.

00:55:50.260 --> 00:55:52.760
And then anything that it doesn't know,
your application is going to

00:55:52.770 --> 00:55:54.530
get launched but you're going
to just kick it off and say,

00:55:54.540 --> 00:55:57.050
"I don't want to talk to any
of this data." All right,

00:55:57.050 --> 00:55:58.980
so there's ways around it.

00:55:58.980 --> 00:56:02.100
So that's the mechanism for
passing data back and forth.

00:56:02.100 --> 00:56:02.100
Process the architecture.

00:56:02.100 --> 00:56:03.460
So that's the arguments
within the URL again.

00:56:03.580 --> 00:56:05.910
Just be very cautious about
how you process those arguments

00:56:05.910 --> 00:56:08.940
because they could come in from
a whole bunch of different ways.

00:56:08.940 --> 00:56:11.340
LaunchMe is probably the only
sample that we've got in the

00:56:11.340 --> 00:56:13.050
SDK that shows you how to do this.

00:56:13.380 --> 00:56:16.970
Basically, it's something that a native
application you build,

00:56:16.970 --> 00:56:19.440
you install,
tells you to go over to Safari,

00:56:19.440 --> 00:56:21.580
type launchme:/ and then some text.

00:56:21.580 --> 00:56:24.630
Once you load it in the browser,
it goes and loads the

00:56:24.630 --> 00:56:27.060
native application and says,
"Hey,

00:56:27.060 --> 00:56:30.280
it worked." So a nice thing about it
though is it shows you what you need

00:56:30.280 --> 00:56:35.640
to put within the info.p list in order
to respond to these types of URLs.

00:56:36.900 --> 00:56:40.690
So core file classes that you're going
to use in order to go read and write.

00:56:40.980 --> 00:56:43.120
First is NSFileManager.

00:56:43.120 --> 00:56:46.400
You'll use this class for all
sorts of operations associated with

00:56:46.480 --> 00:56:50.320
managing files and directories,
setting the various bits, permissions,

00:56:50.400 --> 00:56:53.810
those kinds of things on
files and directories,

00:56:53.810 --> 00:56:58.040
determining whether files exist
or not as well as creating them.

00:56:58.040 --> 00:57:01.920
You'll use an NSFileHandle class all
over the place to read and write.

00:57:01.970 --> 00:57:06.890
So anytime you've got a file sitting
in the file--within the file system,

00:57:06.890 --> 00:57:11.820
NSFileHandle is the class you'll
use to actually read and seek and

00:57:11.830 --> 00:57:14.580
flush and all sorts of things there.

00:57:14.580 --> 00:57:17.100
So these are the two primary classes.

00:57:17.100 --> 00:57:19.270
You definitely want to
avoid hard-coded paths,

00:57:19.610 --> 00:57:21.960
especially if you're going to be
talking to any of the folders that

00:57:22.040 --> 00:57:23.440
you have permissions to talk to.

00:57:23.440 --> 00:57:27.880
The way you do it is through the
NSSearchPathForDirectoriesInDomains

00:57:27.880 --> 00:57:29.510
JavaScript function.

00:57:29.620 --> 00:57:32.380
It's JavaScript function, C function.

00:57:32.410 --> 00:57:36.460
This C function allows you to
request from the OS a path to your

00:57:36.460 --> 00:57:41.760
documents directory if you pass in
the NSDocumentDirectory constant.

00:57:41.760 --> 00:57:43.930
You could also pass in
other constants as well,

00:57:43.930 --> 00:57:46.300
saying, "Oh,
I want the temp directory," or

00:57:46.300 --> 00:57:48.950
"I want the caches directory."
You can ask for those,

00:57:48.950 --> 00:57:51.650
but you have to ask through
this particular C function and

00:57:51.650 --> 00:57:55.510
we'll build up a path to that
particular resource for you,

00:57:55.510 --> 00:57:57.610
to that particular folder.

00:57:57.640 --> 00:57:59.940
So use that before you go and write.

00:57:59.970 --> 00:58:02.200
So here I've got an example
using those classes.

00:58:02.200 --> 00:58:05.800
So I'm going to write a file
called "myfile.txt." And then

00:58:05.800 --> 00:58:33.030
I get a file handled to the class,
that saved file,

00:58:33.030 --> 00:58:36.900
and then I use the file handle to
do all my writing synchronization

00:58:36.900 --> 00:58:39.840
as well as closing in the file,
reading, those kinds of things.

00:58:39.840 --> 00:58:41.420
So straightforward process.

00:58:41.440 --> 00:58:45.610
The key is that you definitely
want to use the C function for

00:58:45.610 --> 00:58:49.790
determining where to--where your
particular directories reside.

00:58:52.900 --> 00:58:55.750
All right, so while we're writing files,
we can also write out

00:58:55.750 --> 00:58:57.290
SQLite files as well.

00:58:57.300 --> 00:59:01.250
We've got a SQLite
implementation on iPhone,

00:59:01.310 --> 00:59:05.400
much like on the desktop,
and it's LibSQL version 3.

00:59:05.400 --> 00:59:08.220
So I can write files that
conform to my own file format,

00:59:08.220 --> 00:59:11.760
or I could write out database
files just using LibSQL.

00:59:11.760 --> 00:59:16.340
SQL92 with caveats,
so if you're used to writing typical SQL,

00:59:16.340 --> 00:59:21.510
then there's a good chance that you can
shoot the same sort of SQL to SQLite.

00:59:22.260 --> 00:59:26.020
It supports things like
transactions and triggers and views.

00:59:26.020 --> 00:59:29.690
Views are read-only, however,
and supports common data

00:59:29.690 --> 00:59:34.020
types including integers,
reels, texts and blobs.

00:59:34.020 --> 00:59:40.080
So there's a nice SQLite API for
writing out these various types.

00:59:40.130 --> 00:59:42.660
You could write out objects that
you've got in memory as well.

00:59:42.660 --> 00:59:46.930
You can use the blob field for holding
all sorts of content including anything

00:59:47.020 --> 00:59:49.130
that you've got sitting in memory.

00:59:49.190 --> 00:59:51.170
Things that are in memory,
classes that you've

00:59:51.170 --> 00:59:52.300
instantiated on your own.

00:59:52.300 --> 00:59:54.370
As long as you've got them in your own,
as long as they conform

00:59:54.500 --> 00:59:57.180
to the NSArchiver,
NSCoding implementations,

00:59:57.180 --> 01:00:01.340
then you can serialize those and
throw them into the database as well.

01:00:01.340 --> 01:00:05.180
So LibSQL version 3,
files that you create using the

01:00:05.310 --> 01:00:10.600
APIs in a native application on iPhone,
those same files can be opened

01:00:10.600 --> 01:00:12.950
anywhere that SQLite is used.

01:00:12.950 --> 01:00:17.670
It creates the same sort
of SQLite compliant files.

01:00:17.720 --> 01:00:22.000
It's an open source library, LibSQL,
so the documentation is open source,

01:00:22.060 --> 01:00:26.530
SQLite.org, lots of great examples there.

01:00:26.840 --> 01:00:31.110
And we've got an SDK sample called
SQLite Booklist that does reading and

01:00:31.110 --> 01:00:35.740
writing of records to a SQLite database.

01:00:35.740 --> 01:00:38.680
It's got a great implementation where
it takes the stub of the database

01:00:38.680 --> 01:00:41.860
that it's going to use for all its
transactions out of its bundle,

01:00:41.860 --> 01:00:44.830
writes it to the local file system
where it's got write capability,

01:00:44.990 --> 01:00:48.860
and then uses it for each additional
write that you might want to use.

01:00:48.860 --> 01:00:50.820
So it's a particularly good example.

01:00:50.820 --> 01:00:56.650
And the URL cache example
uses it to store data as well.

01:00:56.680 --> 01:00:59.720
So those are some good samples
if you're interested in saving

01:00:59.720 --> 01:01:01.100
data that's SQLite based.

01:01:03.760 --> 01:01:06.180
As long as your writing files out,
it's good to see the results,

01:01:06.320 --> 01:01:09.830
the fruits of your labor,
and you can do that within the Organizer.

01:01:09.830 --> 01:01:12.760
You don't necessarily need to write
something that reads all the stuff you

01:01:12.770 --> 01:01:16.980
just wrote out just to validate that
it's actually successful at writing.

01:01:16.980 --> 01:01:19.490
You can open up the Organizer
window within Xcode.

01:01:19.640 --> 01:01:23.750
You'll see all of your in-house
applications listed down here,

01:01:23.750 --> 01:01:27.400
and if you rotate the little
triangle associated with

01:01:27.400 --> 01:01:30.500
your particular application,
you'll see an application

01:01:30.500 --> 01:01:31.770
data element there.

01:01:31.780 --> 01:01:35.820
Click on the little down arrow,
and what you'll get is a prompt to

01:01:35.980 --> 01:01:39.600
save your entire documents directory
somewhere within the operating system.

01:01:39.600 --> 01:01:43.160
You'll be prompted to save this folder,
so you know, stick it on your desktop,

01:01:43.160 --> 01:01:46.120
stick it wherever you want,
and then what you get within the

01:01:46.120 --> 01:01:50.800
Organizer view is the hierarchy of
those documents that you just wrote out.

01:01:50.800 --> 01:01:53.490
So this is my image cloud sample
that goes and hits a bunch

01:01:53.500 --> 01:01:56.740
of images up in the cloud,
writes them out to the local file system.

01:01:56.740 --> 01:02:00.180
You'll see on the left-hand side
I've just selected one of the images.

01:02:00.180 --> 01:02:01.260
Xcode will present what it can.

01:02:01.260 --> 01:02:01.570
If it needs to be,
it can be sent to the local file system.

01:02:01.570 --> 01:02:02.250
If it needs to be,
it can be sent to the local file system.

01:02:02.260 --> 01:02:04.340
And then you can see what it can,
if it knows the file types.

01:02:04.390 --> 01:02:06.700
If they're text types,
it'll show it in there as well.

01:02:06.700 --> 01:02:08.710
Of course,
that directory is still sitting

01:02:08.720 --> 01:02:11.560
somewhere with my file system as well,
because I saved it there so you could

01:02:11.560 --> 01:02:14.700
romp through it manually as well,
open the directories and

01:02:14.700 --> 01:02:16.460
see what was written out.

01:02:17.300 --> 01:02:19.300
If you're doing
simulator-based developments,

01:02:19.400 --> 01:02:21.520
simulator has a documents
directory as well.

01:02:21.520 --> 01:02:24.880
It's an incredibly long URL,
but there's a documents

01:02:24.880 --> 01:02:28.430
directory there as well,
so you can see the results of all

01:02:28.430 --> 01:02:31.340
your rights within the simulator.

01:02:31.340 --> 01:02:33.340
You don't necessarily have to
have a native-based application

01:02:33.340 --> 01:02:34.310
to take a look at that.

01:02:36.590 --> 01:02:37.970
All right, so that's saving data locally.

01:02:37.980 --> 01:02:39.980
Just ripping through the
last couple ones quickly.

01:02:39.980 --> 01:02:43.370
Got some security services
available on iPhone.

01:02:43.550 --> 01:02:46.060
First one I talked about in
the initial presentation,

01:02:46.060 --> 01:02:49.480
in-house certificates,
as well as a lot of

01:02:49.480 --> 01:02:50.860
the most common routes.

01:02:51.010 --> 01:02:53.860
They're useful for
authentication and signing.

01:02:53.860 --> 01:02:58.080
We have a keychain API on iPhone,
much like on the desktop

01:02:58.080 --> 01:03:00.100
for Macintosh programmers.

01:03:00.230 --> 01:03:03.140
Common crypto APIs,
so if you wanna do any sort of

01:03:05.280 --> 01:03:08.600
unique random number grabbing,
SHA,

01:03:08.600 --> 01:03:12.230
any sort of ad hoc encryption of content,
files, those kinds of things,

01:03:12.230 --> 01:03:14.440
then you'd use the common crypto library.

01:03:14.440 --> 01:03:16.180
And then we've got the
CF network framework.

01:03:16.410 --> 01:03:22.480
It's a lower level network,
below NS network layer for TLS.

01:03:23.120 --> 01:03:26.250
If you're doing any sort of secure
networking and you wanna get down

01:03:26.360 --> 01:03:31.090
to the nuts and bolts at that level,
then CF network is the place to go.

01:03:31.860 --> 01:03:35.270
I'm going to spend a little bit
of time on digital certificates

01:03:35.270 --> 01:03:38.750
and keychain because these are
probably two of the most used by

01:03:38.810 --> 01:03:40.960
in-house applications or soon to be.

01:03:40.960 --> 01:03:44.010
So at the get-go we've got
support for routes like server

01:03:44.120 --> 01:03:45.830
and identity certificates.

01:03:45.830 --> 01:03:47.650
The most common are built-ins.

01:03:47.700 --> 01:03:51.300
We've got over 132 sitting
within the keychain on iPhone,

01:03:51.370 --> 01:03:55.060
basically the same set that you
would see on the Macintosh desktop

01:03:55.060 --> 01:03:59.490
if you opened the keychain access
application and clicked on certificates.

01:03:59.490 --> 01:04:01.780
Most common are built-ins.

01:04:01.800 --> 01:04:04.420
So if you want to use them,
they're good to go.

01:04:04.420 --> 01:04:07.380
They're stored in the keychain
so they're securely stored.

01:04:07.380 --> 01:04:10.820
You can import your own certificates
if you're your own certificate

01:04:10.820 --> 01:04:13.780
authority and you want to use
those certificates as part of

01:04:13.780 --> 01:04:16.140
authentication for back-end resources.

01:04:16.170 --> 01:04:18.410
You can import them via Safari.

01:04:18.410 --> 01:04:22.820
Going to a secure web server,
users can import an in-house cert or

01:04:22.850 --> 01:04:27.820
they can also be distributed to users
for use via an attachment in email.

01:04:27.820 --> 01:04:31.460
And in the previous presentation
I also mentioned that the iPhone

01:04:31.460 --> 01:04:35.810
configuration utility is a great way to
go and push via configuration profiles

01:04:36.340 --> 01:04:38.770
certificates out to your users as well.

01:04:38.770 --> 01:04:42.110
So we support in-house as well
as the most common routes already

01:04:42.550 --> 01:04:46.260
within the keychain and you can use
them for doing all sorts of things.

01:04:46.260 --> 01:04:49.530
So you can use them to
authenticate with the built-in app.

01:04:49.560 --> 01:04:53.120
So Safari can use your in-house
certificate to authenticate to a

01:04:53.120 --> 01:04:57.230
server sitting within your organization
that has your own certificate on

01:04:57.230 --> 01:04:59.280
it instead of using a public route.

01:04:59.280 --> 01:05:02.420
You can also,
since you have access to the keychain,

01:05:02.420 --> 01:05:07.160
use certificates that you've deployed
through whatever mechanism as a

01:05:07.170 --> 01:05:10.330
way of providing authentication
within your own application as well.

01:05:10.340 --> 01:05:13.930
You've got access to that search
store so you can use the search

01:05:13.930 --> 01:05:18.480
as part of your chain of trust
for communication to a back-end,

01:05:18.490 --> 01:05:20.210
all sorts of things.

01:05:20.420 --> 01:05:22.860
So certificate support, it's there.

01:05:22.930 --> 01:05:26.730
Keychain support, so we've got a pretty
significant keychain API on the

01:05:26.730 --> 01:05:28.420
desktop if you're used to it.

01:05:28.420 --> 01:05:30.050
We've greatly simplified it.

01:05:30.180 --> 01:05:33.160
The keychain provides support
for all sorts of storage of

01:05:33.630 --> 01:05:36.390
information that's considered secure.

01:05:36.410 --> 01:05:39.830
So things like cryptographic keys,
certificate information.

01:05:39.880 --> 01:05:43.230
If you're going to collect any
sort of passwords from a user and

01:05:43.230 --> 01:05:46.980
you want to store it for sessions,
then throw it in the keychain.

01:05:46.980 --> 01:05:48.680
It's a secure way to go and store it.

01:05:48.810 --> 01:05:49.700
It's encrypted.

01:05:49.700 --> 01:05:50.280
You don't need to worry about it.

01:05:50.300 --> 01:05:52.740
You don't need to worry about
it sitting out in the file

01:05:52.740 --> 01:05:54.300
system or anything like that.

01:05:54.300 --> 01:05:56.050
When you launch your application,
you can go and pull it

01:05:56.050 --> 01:05:57.040
out of the keychain again.

01:05:57.040 --> 01:05:59.420
It hasn't been tampered
with in any sort of way.

01:05:59.420 --> 01:06:02.100
So if you're going to store passwords,
throw it in the keychain.

01:06:03.880 --> 01:06:10.400
There's a shared keychain store,
basically one encrypted store

01:06:10.420 --> 01:06:13.150
that all the passwords for all
applications are stored in.

01:06:13.250 --> 01:06:19.140
But based on application signatures,
there's restricted access to basically

01:06:19.140 --> 01:06:21.740
little slices of the keychain.

01:06:21.740 --> 01:06:25.980
So application one has access
to applications one's keychain

01:06:25.980 --> 01:06:27.910
or slice of the keychain.

01:06:28.050 --> 01:06:31.150
Application one can only read
and write from a particular

01:06:31.150 --> 01:06:32.380
portion of the keychain.

01:06:32.380 --> 01:06:36.150
They can't necessarily read passwords,
certificates or any other

01:06:36.150 --> 01:06:39.980
information that was written there
by another application unless,

01:06:39.980 --> 01:06:42.910
of course, that other application has
the exact same signature.

01:06:42.920 --> 01:06:46.960
So there is a mechanism for deploying
applications that have a little star

01:06:46.960 --> 01:06:49.430
as part of their application signature.

01:06:49.440 --> 01:06:53.730
If you deploy that way,
they... Then those applications that

01:06:53.890 --> 01:06:58.330
conform to that signature protocol can
all share the same slice of the keychain.

01:06:58.360 --> 01:07:01.670
And the documentation for doing
that is on the...I think it's

01:07:01.670 --> 01:07:07.180
in the distribution tab of the
program portal on how to do that.

01:07:07.320 --> 01:07:09.540
The secret is protected by hardware,
not password.

01:07:09.540 --> 01:07:10.840
I mean,
this is interesting to folks that are

01:07:10.840 --> 01:07:14.000
used to unlocking the keychain on a
Macintosh based on logging in and a

01:07:14.000 --> 01:07:15.600
password associated with the keychain.

01:07:15.600 --> 01:07:19.220
There aren't any prompts in
iPhone for access to the keychain.

01:07:19.220 --> 01:07:22.000
People that are used to
the desktop experience,

01:07:22.000 --> 01:07:26.500
if Safari wants to access the password
associated with a particular website,

01:07:26.500 --> 01:07:29.400
you see a dialog that's
presented by Safari.

01:07:29.400 --> 01:07:31.640
Hey, we want to go get your password
out of here so we can use

01:07:31.640 --> 01:07:32.900
it for auto form complaint.

01:07:32.900 --> 01:07:35.440
There isn't that kind of
implementation on iPhone.

01:07:36.720 --> 01:07:38.830
The security associated with
the keychain on iPhone is all

01:07:38.890 --> 01:07:40.400
about a hardware password.

01:07:40.400 --> 01:07:43.700
There's something unique about
the hardware that's used to

01:07:43.700 --> 01:07:45.320
go and lock the keychain.

01:07:47.290 --> 01:07:50.630
Backup occurs, but it's tied to device.

01:07:50.700 --> 01:07:53.800
So if you want to recover
a keychain onto a phone,

01:07:53.800 --> 01:07:57.190
it'll only go back to the phone that
that particular keychain came from.

01:07:57.900 --> 01:08:01.000
Since it's locked with something
unique about that device,

01:08:01.000 --> 01:08:05.080
it would be useless anywhere else
anyway because it's encrypted

01:08:05.080 --> 01:08:06.910
with that device secret.

01:08:07.910 --> 01:08:11.910
So keychain APIs, there's four of them,
concise set of C functions,

01:08:12.080 --> 01:08:14.180
sec item matching,
that's all about finding

01:08:14.180 --> 01:08:16.120
something within the keychain.

01:08:16.120 --> 01:08:18.700
I've stored a password there,
I wanna go and retrieve it now,

01:08:18.730 --> 01:08:23.100
so I just ask the keychain using
this particular API to give me

01:08:23.140 --> 01:08:26.020
back that password that I wanna
use based on whatever criteria.

01:08:26.110 --> 01:08:29.470
Perhaps it's a name associated with
that particular password or a domain

01:08:29.470 --> 01:08:31.280
associated with that password.

01:08:31.320 --> 01:08:34.520
If I wanna add something to the keychain,
it's sec item add.

01:08:34.520 --> 01:08:38.520
If I wanna update something
sitting within the keychain,

01:08:38.520 --> 01:08:42.180
it's just one big array of data types.

01:08:42.180 --> 01:08:47.580
I can update just one aspect of it,
I would use this particular API call.

01:08:47.580 --> 01:08:49.190
And then finally,
if I wanna remove something

01:08:49.190 --> 01:08:51.830
from the keychain,
I would use sec item delete.

01:08:51.990 --> 01:08:54.600
The reason I've listed them here
is because it's a much smaller

01:08:54.640 --> 01:08:57.780
set than what folks might be used
to if they're using the keychain

01:08:57.780 --> 01:09:01.030
APIs on the Macintosh desktop.

01:09:01.220 --> 01:09:04.000
SDK samples you might be interested in if
you're doing anything with the keychain,

01:09:04.000 --> 01:09:07.660
generic keychain example,
throws stuff on,

01:09:07.660 --> 01:09:11.280
pulls it off based on lookups, deletes,
those kinds of things.

01:09:11.280 --> 01:09:14.900
And then the crypto exercise
example is particularly interesting,

01:09:14.900 --> 01:09:18.240
especially if you want to do
any bulk encryption of content.

01:09:18.240 --> 01:09:21.660
If you want to take a file and encrypt
it before you write it out to disk

01:09:21.660 --> 01:09:25.140
or if it's sitting on disk and you
want it encrypted or decrypted or you

01:09:25.290 --> 01:09:28.590
want to set up a secure communication
based on certificates between a

01:09:28.620 --> 01:09:31.080
client application and the server,
that's a great example.

01:09:31.100 --> 01:09:35.520
That crypto exercise application
is a great sample for getting

01:09:35.560 --> 01:09:37.820
your hands around how that's done.

01:09:40.160 --> 01:09:41.320
So that's security services.

01:09:41.390 --> 01:09:44.100
Going to wrap it up with
deploying iPhone applications.

01:09:44.160 --> 01:09:46.280
Should be pretty short.

01:09:46.330 --> 01:09:49.760
Two different application architectures,
two different ways to go and deploy,

01:09:49.760 --> 01:09:51.740
at least within these
particular architectures.

01:09:51.790 --> 01:09:53.160
First, there's a web app deployment.

01:09:53.160 --> 01:09:54.260
Everybody knows that, right?

01:09:54.300 --> 01:09:56.390
Everybody knows how to
deploy a web application.

01:09:56.560 --> 01:09:58.940
Pretty straightforward,
especially for a single one.

01:09:58.940 --> 01:10:02.630
All you need to do is find a place to
go and host your particular web app,

01:10:02.680 --> 01:10:07.120
poke a hole in the firewall,
pass out the URL to your customers,

01:10:07.120 --> 01:10:09.500
your end users who are using it.

01:10:09.500 --> 01:10:12.070
And once they've got it,
they'll create a home screen icon

01:10:12.080 --> 01:10:15.020
so it stands right next to the
rest of the native applications

01:10:15.020 --> 01:10:17.600
on their iPhone or iPod Touch.

01:10:17.690 --> 01:10:19.920
One thing that you should
consider if you're deploying

01:10:19.920 --> 01:10:24.040
multiple web-based applications is
coming up with an iPhone portal.

01:10:24.090 --> 01:10:28.910
So basically one destination where users
would go and get all of their web-based

01:10:28.910 --> 01:10:31.380
services through one particular URL.

01:10:31.380 --> 01:10:34.120
It saves you having to open up
multiple ports in the firewall

01:10:34.120 --> 01:10:38.900
or distributing multiple icons,
having multiple icons on the home screen.

01:10:38.900 --> 01:10:41.970
And it's something that we've done
within Apple for our deployment

01:10:41.970 --> 01:10:43.870
of web-based applications.

01:10:43.920 --> 01:10:48.180
So in my sample here,
I've got the little single icon.

01:10:48.180 --> 01:10:51.340
You tap on that to go to all
the Apple web-based services.

01:10:51.340 --> 01:10:54.790
Since it's all coming through a portal,
all of these apps use the

01:10:54.790 --> 01:10:57.020
same authentication mechanism.

01:10:57.020 --> 01:10:59.140
If I authenticate
successfully to the system,

01:10:59.140 --> 01:11:00.740
then I get in.

01:11:00.800 --> 01:11:02.920
If I don't, then I'm blocked.

01:11:02.920 --> 01:11:05.240
Once I get in,
then these are all just web-based

01:11:05.240 --> 01:11:08.090
icons that are sitting within
my portal web-based application.

01:11:08.300 --> 01:11:12.900
A great user experience because
basically all that session

01:11:12.900 --> 01:11:14.060
information is leveraged.

01:11:14.060 --> 01:11:16.240
Then the user goes and
taps on the various one,

01:11:16.240 --> 01:11:18.520
whether it's the directory
app or something else,

01:11:18.520 --> 01:11:21.340
launches it,
and the presentation is great.

01:11:21.370 --> 01:11:23.620
So consider using a portal if
you're going to deploy more

01:11:24.020 --> 01:11:26.360
than just one iPhone-based app.

01:11:26.370 --> 01:11:28.050
It's a great shortcut.

01:11:28.070 --> 01:11:30.360
From a native application
deployment perspective,

01:11:30.360 --> 01:11:34.300
there's three different mechanisms
for deploying a native application.

01:11:34.390 --> 01:11:36.180
The first one is enterprise.

01:11:36.180 --> 01:11:39.610
Enterprise deployment are for folks
who are members of the enterprise

01:11:39.680 --> 01:11:43.960
developer program at Apple,
so the iPhone enterprise

01:11:44.040 --> 01:11:45.130
developer program.

01:11:45.150 --> 01:11:49.300
It allows you to deploy unlimited
applications to unlimited devices.

01:11:49.300 --> 01:11:55.940
There's no tie between a device ID and
the application that you're distributing.

01:11:55.970 --> 01:11:56.460
It's unlimited.

01:11:56.460 --> 01:12:02.230
The only real caveat is that you can only
deploy to members of your own enterprise.

01:12:02.280 --> 01:12:05.620
It's not a deployment mechanism
that allows you to deploy

01:12:05.620 --> 01:12:08.060
outside of your enterprise.

01:12:08.060 --> 01:12:08.060
It's for in-house applications.

01:12:08.060 --> 01:12:10.900
It's for in-house application
distribution only to folks who are

01:12:11.040 --> 01:12:13.810
part of your enterprise organization.

01:12:13.850 --> 01:12:15.900
So that's enterprise distribution.

01:12:15.910 --> 01:12:18.330
There's ad hoc application distribution.

01:12:18.340 --> 01:12:23.160
Ad hoc is all about tying the
capability of a particular application

01:12:23.160 --> 01:12:26.580
to run on very specific known devices.

01:12:26.610 --> 01:12:31.240
So there's a set of iPod
Touches or iPhones that I want

01:12:31.240 --> 01:12:34.250
my application to run on,
and none other than I'm

01:12:34.250 --> 01:12:36.620
doing an ad hoc deployment.

01:12:36.620 --> 01:12:37.870
And then finally,
you know what you love it.

01:12:38.000 --> 01:12:39.100
It's the App Store deployment, right?

01:12:39.160 --> 01:12:41.270
It's all about pushing it up,
and this is for commercial

01:12:41.290 --> 01:12:43.120
and free applications.

01:12:43.150 --> 01:12:45.820
So these are the three
mechanisms of deployment.

01:12:45.820 --> 01:12:47.930
The ones that are most important
to in-house developers are

01:12:47.970 --> 01:12:50.840
typically the enterprise and
ad hoc distribution methods.

01:12:50.840 --> 01:12:54.060
Although there's a lot of
enterprises that are commercial

01:12:54.060 --> 01:12:57.590
application developers as well,
so typically they'll have an

01:12:57.590 --> 01:12:58.900
App Store account as well.

01:12:58.900 --> 01:13:02.740
And they'll use that for deploying
to customers that are folks

01:13:02.740 --> 01:13:05.150
outside of their organization.

01:13:05.810 --> 01:13:10.650
So enterprise and ad hoc deployment,
the process is build, authorize,

01:13:10.800 --> 01:13:11.940
deploy and install.

01:13:12.010 --> 01:13:16.460
There is no over the air capability
for deploying in-house applications

01:13:16.460 --> 01:13:20.680
for doing iPhone enterprise
application development or ad hoc.

01:13:20.750 --> 01:13:24.700
Only the app store mechanism is
the way to get it over the air.

01:13:24.700 --> 01:13:28.450
In order to go and deploy an
application that's ad hoc or enterprise,

01:13:28.530 --> 01:13:32.750
first thing I need to do is to sign,
create a signed distribution

01:13:33.250 --> 01:13:35.580
build of my native application.

01:13:35.930 --> 01:13:38.950
Then I need to interact with
the program portal at Apple,

01:13:39.030 --> 01:13:40.060
so sign in.

01:13:40.510 --> 01:13:44.720
Perhaps I'm doing an ad hoc distribution,
so I need to select the device

01:13:45.090 --> 01:13:48.740
IDs of the devices that I want
my application to run on.

01:13:48.740 --> 01:13:51.140
As a result of interacting
with the portal,

01:13:51.140 --> 01:13:53.790
I'll get back a distribution
provisioning profile.

01:13:53.790 --> 01:13:58.110
If I want to do an enterprise deployment,
I would still go through

01:13:58.210 --> 01:14:01.000
this same process,
but I would not select devices

01:14:01.000 --> 01:14:04.680
and tie that particular
distribution to those devices.

01:14:04.680 --> 01:14:06.950
I'd say, no,
I don't choose the radio box that says

01:14:07.040 --> 01:14:11.280
I want to do an enterprise deployment,
and then the need to select

01:14:11.280 --> 01:14:12.950
device IDs goes away.

01:14:12.990 --> 01:14:15.000
So as a result of
interacting with the portal,

01:14:15.010 --> 01:14:17.980
you'll get a distribution
provisioning profile.

01:14:17.980 --> 01:14:20.460
It's signed by us to make sure
that it's not monkeyed with.

01:14:21.600 --> 01:14:25.730
Once you've got that provisioning profile
and your signed application in hand,

01:14:25.730 --> 01:14:27.400
it's time to go and deploy it.

01:14:27.500 --> 01:14:30.380
And you can deploy it in any
mechanism that you want to do,

01:14:30.440 --> 01:14:34.510
as long as it gets it to the desktop of
the user that needs to have it installed.

01:14:34.510 --> 01:14:34.880
So you can use the
application to deploy it.

01:14:34.910 --> 01:14:36.190
So you can use email.

01:14:36.190 --> 01:14:38.120
You can push it through
any sort of mechanism.

01:14:38.120 --> 01:14:41.100
You can use a thumb drive,
whatever it takes to get it out there,

01:14:41.100 --> 01:14:42.800
but it's got to land on the desktop.

01:14:42.800 --> 01:14:45.640
You can't push it to the email
of a client on the iPhone.

01:14:45.640 --> 01:14:46.940
It's got to land onto a desktop.

01:14:46.940 --> 01:14:49.860
The reason it's got to land on
the desktop is because the only

01:14:49.860 --> 01:14:53.180
way to go and install in-house
applications is via iTunes.

01:14:53.180 --> 01:14:58.120
So the way you install applications
with iTunes is you drag and drop

01:14:58.280 --> 01:15:02.770
them on top of the icon for iTunes,
either on a Windows machine

01:15:02.770 --> 01:15:04.420
or on a Macintosh.

01:15:04.420 --> 01:15:08.970
If iTunes is already running,
I can drag both of them into the

01:15:08.970 --> 01:15:10.900
library section of iTunes as well.

01:15:11.290 --> 01:15:13.540
There's the iPhone Configuration
Utility which I talked about

01:15:13.550 --> 01:15:14.790
in the previous presentation.

01:15:14.800 --> 01:15:18.680
It's got the capability of adding
provision profiles as well as apps.

01:15:18.700 --> 01:15:23.140
So if you're an IT organization and
you want to prep a bunch of iPhones

01:15:23.240 --> 01:15:26.790
before you give them to developers,
you can use that tool

01:15:26.790 --> 01:15:28.470
to do the same thing.

01:15:29.540 --> 01:15:31.770
Once they're there,
once the user clicks their

01:15:31.770 --> 01:15:34.720
phone in and synchronizes,
the in-house application is

01:15:34.720 --> 01:15:36.400
pushed over to their device.

01:15:36.400 --> 01:15:36.400
They're good to go.

01:15:39.640 --> 01:15:42.330
App Store Deployment,
a lot simpler than that, right?

01:15:42.340 --> 01:15:45.030
All you need to do is still
create a distribution signed

01:15:45.030 --> 01:15:46.850
build of your application.

01:15:47.000 --> 01:15:50.700
The next step is you push it up to
the iTunes Connect portal and then

01:15:50.700 --> 01:15:54.510
we take care of the distribution to
the App Store either on iTunes on the

01:15:54.510 --> 01:15:57.930
desktop or the App Store application
on the mobile device.

01:16:00.950 --> 01:16:05.120
So that's the application
distribution mechanism.

01:16:05.120 --> 01:16:08.210
And that's it from a
presentation perspective.

01:16:08.340 --> 01:16:09.660
I've got some links here at the end.

01:16:09.850 --> 01:16:13.880
Links to the iPhone
configuration utility,

01:16:13.880 --> 01:16:14.880
developer documentation.

01:16:14.880 --> 01:16:20.880
I mentioned some CSS effect public
specification is out there at webkit.org.

01:16:20.880 --> 01:16:26.810
Interesting Ruby library that I use for
generating SVG graphics if you're into

01:16:26.850 --> 01:16:30.820
SVG and trying to figure out how you're
going to go and generate some of those,

01:16:30.820 --> 01:16:32.360
that's pretty interesting.

01:16:32.360 --> 01:16:35.300
And my email is at the top so if
you've got any sort of headaches

01:16:35.650 --> 01:16:38.540
or things that you're running
into as part of your deployment,

01:16:38.540 --> 01:16:40.770
building,
any of the process associated with

01:16:40.770 --> 01:16:43.780
in-house application development,
please keep in touch.
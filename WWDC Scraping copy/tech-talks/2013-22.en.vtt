WEBVTT

00:00:13.090 --> 00:00:14.840
So, hey, my name's Philip Iliascu.

00:00:14.840 --> 00:00:20.950
I'm the graphics and media evangelist,
and this first talk is about OpenGL 3.0

00:00:20.950 --> 00:00:24.600
and some of the advances that we've
made you can take advantage of.

00:00:24.660 --> 00:00:30.250
So, yeah, as John was saying, you know,
we recently introduced the iPhone 5S and

00:00:30.610 --> 00:00:35.120
the iPad Air and the iPad Retina Mini,
and these are our first devices

00:00:35.240 --> 00:00:38.310
ever with support for OpenGL ES 3.0.

00:00:39.620 --> 00:00:44.150
So, yeah, we're going to talk about some
of the advances that we've made.

00:00:44.250 --> 00:00:47.070
But OpenGL ES 3.0 is only
available on these devices,

00:00:47.070 --> 00:00:48.370
just to start out with.

00:00:48.460 --> 00:00:50.750
This is a major leap forward,
and there's a lot of new

00:00:50.850 --> 00:00:53.550
advances that you guys really
want to take advantage of.

00:00:53.600 --> 00:00:55.080
So we'll talk about some of that stuff.

00:00:55.100 --> 00:01:00.260
But specifically, you know, for graphics,
you should realize that,

00:01:00.260 --> 00:01:05.830
recognize that the A7 is, like,
our new baseline, our, you know, like,

00:01:05.830 --> 00:01:07.400
our next-gen GPU.

00:01:07.400 --> 00:01:09.420
So, moving forward.

00:01:09.650 --> 00:01:13.030
This is going to be really important
for you all to take advantage of.

00:01:13.060 --> 00:01:15.820
We recommend this is kind of
like what you start driving

00:01:15.820 --> 00:01:17.390
your development towards.

00:01:17.400 --> 00:01:21.410
And, you know,
still keeping in mind that there are,

00:01:21.410 --> 00:01:26.140
you know, you want to keep the A6
in mind and these things.

00:01:26.140 --> 00:01:29.020
But, you know,
you can start thinking for new features.

00:01:29.020 --> 00:01:31.120
This is a good direction to head towards.

00:01:31.120 --> 00:01:33.530
You know,
we meet with game developers a lot, and,

00:01:33.530 --> 00:01:36.700
you know, a lot of times they say, oh,
we're not ready to, you know,

00:01:36.760 --> 00:01:38.760
start working with the new stuff yet.

00:01:38.760 --> 00:01:42.060
You know, there's a... You know,
people are still on the older

00:01:42.060 --> 00:01:44.000
GPUs and this sort of thing.

00:01:44.000 --> 00:01:47.920
And, you know, but, you know,
like we said earlier, you know,

00:01:47.920 --> 00:01:50.220
we have 74% adoption of iOS 7.

00:01:50.220 --> 00:01:51.830
So that's huge.

00:01:51.860 --> 00:01:55.180
There's a huge,
huge demand for the new A7 devices.

00:01:55.220 --> 00:01:57.400
So it's a major leap forward.

00:01:57.400 --> 00:02:00.230
I highly recommend moving in
this direction if you can.

00:02:02.600 --> 00:02:05.190
And then, of course,
combining that with OpenGL ES 3.0,

00:02:05.190 --> 00:02:09.600
this has its feature set taken
directly from desktop OpenGL.

00:02:09.600 --> 00:02:13.370
It enables things that were
previously only seen in

00:02:13.570 --> 00:02:17.600
AAA games on the console before.

00:02:17.600 --> 00:02:20.400
So it's great.

00:02:20.600 --> 00:02:23.350
And, you know,
the third part of this picture,

00:02:23.350 --> 00:02:26.520
which maybe you hadn't thought
of or seen too much of yet,

00:02:26.650 --> 00:02:30.600
is how we're pairing this up with
the OpenGL ES debugger in Xcode.

00:02:30.600 --> 00:02:34.660
And there's some really amazing,
awesome advances in there for

00:02:34.890 --> 00:02:38.540
the A7 that I'm going to show you
today that we didn't actually get

00:02:38.540 --> 00:02:41.930
a chance to show at WWDC because,
well, there wasn't an A7

00:02:41.930 --> 00:02:43.630
device yet at that time.

00:02:43.650 --> 00:02:44.620
And this is great.

00:02:44.620 --> 00:02:46.660
This is actually,
I had a chance to actually work

00:02:46.660 --> 00:02:49.360
on a lot of this stuff myself
before becoming the evangelist.

00:02:49.440 --> 00:02:50.560
So I'm very excited to
actually get to show you this.

00:02:50.870 --> 00:02:52.260
Yeah, I'm excited to share some of
that stuff with you guys today.

00:02:52.790 --> 00:02:53.840
The agenda for this hour.

00:02:53.920 --> 00:02:57.340
First, I'm going to, you know,
I want to start with some of

00:02:57.340 --> 00:02:59.310
the highlights of the A7 GPU.

00:02:59.310 --> 00:03:02.340
And then we're going to talk
about what you can do to,

00:03:02.380 --> 00:03:05.560
you know,
move your ES 2 games towards ES 3.0.

00:03:06.080 --> 00:03:09.590
And then I'll take a deeper
dive into some of the new

00:03:09.630 --> 00:03:12.220
features of OpenGL ES 3.0.

00:03:13.170 --> 00:03:15.520
And then, of course,
I'll show you how you can

00:03:15.520 --> 00:03:19.270
tune your ES 2 and ES 3 games
using Xcode's OpenGL ES 5.0.

00:03:19.460 --> 00:03:19.460
And then, of course,
I'll show you how you can

00:03:19.460 --> 00:03:19.460
tune your ES 2 and ES 3 games
using Xcode's OpenGL ES 5.0.

00:03:19.460 --> 00:03:23.640
Xcode's OpenGL S5 debugger on an A7 GPU.

00:03:23.640 --> 00:03:24.290
Great.

00:03:24.430 --> 00:03:27.140
So I'm going to go ahead
and start with the A7.

00:03:27.140 --> 00:03:29.520
You know,
and just some of the facts first.

00:03:29.520 --> 00:03:32.720
You know, the A7 is still a tile-based
deferred renderer,

00:03:32.720 --> 00:03:35.940
much like the previous GPU, the A6.

00:03:35.940 --> 00:03:40.900
But the performance is up
to that of double of the A6.

00:03:40.900 --> 00:03:43.850
So that's fantastic.

00:03:44.620 --> 00:03:51.690
So A7 is the first GPU that provides
fully native support for OpenGL ES 3.0,

00:03:51.700 --> 00:03:59.770
but it still provides support
for ES 2.0 and ES 1.1 through,

00:03:59.770 --> 00:04:01.580
you know, backwards compatibility.

00:04:01.580 --> 00:04:04.310
We implement the shaders for you
if you're going to use ES 1.1.

00:04:04.330 --> 00:04:07.220
But we don't recommend taking
that route if you can avoid it,

00:04:07.220 --> 00:04:11.400
unless you really want to support older,
older devices or your game

00:04:11.400 --> 00:04:12.700
is doing that already.

00:04:12.700 --> 00:04:14.580
So... Okay.

00:04:14.620 --> 00:04:17.600
And, of course,
it's a shader-based pipeline,

00:04:17.600 --> 00:04:18.980
just like all modern GPUs.

00:04:18.980 --> 00:04:20.150
So...

00:04:21.640 --> 00:04:26.500
Here's a list of some of the
new features in OpenGL ES 3.0.

00:04:26.650 --> 00:04:27.590
There's a lot of them.

00:04:27.590 --> 00:04:30.280
Uniform buffer object,
instance rendering,

00:04:30.280 --> 00:04:31.460
multiple render targets.

00:04:31.460 --> 00:04:36.060
There's a new version of the
OpenGL ES shading language,

00:04:36.240 --> 00:04:36.780
GLSL.

00:04:36.780 --> 00:04:39.090
Frame buffer fetch.

00:04:39.090 --> 00:04:43.560
And how we're combining that with MRT so
you can do things like deferred shading.

00:04:43.560 --> 00:04:46.420
That's actually one of the
things I'll talk about later.

00:04:46.420 --> 00:04:50.310
There's a lot to look at,
but as much of this as you can sort

00:04:50.310 --> 00:04:54.310
of wrap your mind around will give
you a lot of really great tools

00:04:54.370 --> 00:04:56.100
to make really cool games with.

00:04:56.270 --> 00:04:58.050
All right.

00:05:00.020 --> 00:05:02.040
So quickly,
I want to just kind of mention

00:05:02.040 --> 00:05:05.780
the new limits on an A7 GPU.

00:05:05.780 --> 00:05:09.620
And there's a lot of
stuff on the screen here,

00:05:09.620 --> 00:05:14.600
but I think the big takeaway is
that the limits are now double

00:05:14.600 --> 00:05:16.200
of that of the previous GPU.

00:05:16.200 --> 00:05:19.070
More than double in a lot of cases.

00:05:19.080 --> 00:05:21.470
And of course,
you can have multiple render

00:05:21.470 --> 00:05:22.950
targets now on the A7.

00:05:22.960 --> 00:05:27.610
Max color attachments of four,
whereas before you could just have one.

00:05:28.540 --> 00:05:35.020
So of course, if you are still using an
OpenGL ES 2 context on the A7,

00:05:35.020 --> 00:05:37.990
not an OpenGL ES 3 context,
then you'll be capped

00:05:38.120 --> 00:05:40.920
at the previous limits,
the OpenGL ES 2 limits.

00:05:40.920 --> 00:05:44.940
So this is one reason to take
advantage of OpenGL ES 3 right away,

00:05:44.940 --> 00:05:48.620
is to get the hardware
native limits on the A7 GPU.

00:05:48.620 --> 00:05:52.180
I'll talk about a few of the key
differences between the A6 and the A7.

00:05:52.180 --> 00:05:55.180
And the first, performance.

00:05:55.180 --> 00:05:58.700
In the area of performance,
there is no longer a penalty

00:05:58.700 --> 00:05:59.890
like we had on the A6.

00:05:59.950 --> 00:06:02.920
I mean, not as much of a penalty
for dependent texture reads.

00:06:02.920 --> 00:06:07.810
But there is a higher penalty now for
logical frame buffer loads and stores.

00:06:07.820 --> 00:06:10.930
So what I mean by that,
I don't know if you all

00:06:10.930 --> 00:06:14.280
know what that means,
but in case you don't,

00:06:14.700 --> 00:06:18.320
logical buffer load would be if you
forget to clear your color attachment

00:06:18.320 --> 00:06:19.330
at the beginning of the frame.

00:06:19.340 --> 00:06:22.840
Well, if you do that,
we actually have to reload that.

00:06:22.900 --> 00:06:27.030
And so you'll incur a
performance penalty for that.

00:06:27.040 --> 00:06:28.700
That's a logical buffer load.

00:06:28.820 --> 00:06:32.370
So the way to not do that is to make
sure you clear your color attachment.

00:06:32.420 --> 00:06:37.720
And a logical buffer store is if you
forget to say invalidate or discard

00:06:37.720 --> 00:06:43.490
your depth or stencil or multi-sample
attachments at the end of the frame.

00:06:43.500 --> 00:06:48.180
In this case, you know,
we will actually make a copy of

00:06:48.180 --> 00:06:51.530
those attachments between frames.

00:06:51.550 --> 00:06:55.090
And so you'll incur a cost
performance cost for that.

00:06:55.700 --> 00:06:58.530
So that's something to keep in mind.

00:06:58.580 --> 00:06:59.650
So precision.

00:06:59.740 --> 00:07:06.340
So in the realm of precision,
we've promoted low P shader values

00:07:06.340 --> 00:07:07.740
are now promoted up to 16 bit.

00:07:08.270 --> 00:07:11.970
And any floating point
shader calculations are done

00:07:12.060 --> 00:07:13.320
with a scalar processor.

00:07:13.410 --> 00:07:16.180
So this might have some
implications in your game.

00:07:16.180 --> 00:07:18.000
And, you know,
like if you're doing in your shaders,

00:07:18.100 --> 00:07:22.930
if you're doing anything with
write masks or anything like that,

00:07:22.940 --> 00:07:25.590
you know, you might want to take a
look at some of that stuff.

00:07:25.650 --> 00:07:29.100
And make sure it still works the way
you expect it to work on the new GPU.

00:07:29.110 --> 00:07:33.620
And as far as limits goes,
like I said before, you know,

00:07:33.620 --> 00:07:36.500
apps within ES2 context will
still get the ES2 limits.

00:07:36.500 --> 00:07:39.640
But apps within ES3 context
will get the native limits.

00:07:39.660 --> 00:07:44.490
Another reason to move
forward with the ES3.

00:07:44.920 --> 00:07:47.530
All right,
so I'm just going to quickly talk about

00:07:47.530 --> 00:07:51.390
how you might move to ES 3 from ES 2.0.

00:07:51.700 --> 00:07:57.010
The big picture is that the core of
ES 3.0 is actually a superset of ES 2.0.

00:07:57.200 --> 00:08:01.990
So what that means is that if
you just want to take your ES 2.0

00:08:02.180 --> 00:08:06.410
code and move it into ES 3.0,
it will mostly just work,

00:08:06.500 --> 00:08:08.780
although the stuff that was
in core is still in core,

00:08:08.780 --> 00:08:09.440
of course.

00:08:09.440 --> 00:08:14.640
For extensions,
any extensions you were using in ES 2.0,

00:08:14.900 --> 00:08:17.080
there's a couple of different changes.

00:08:17.710 --> 00:08:20.720
Three cases, actually.

00:08:20.720 --> 00:08:24.830
The first case, some have actually moved
into the ES 3.0 core as is.

00:08:24.840 --> 00:08:28.160
There's a couple really simple things you
can do there to just get those to work,

00:08:28.240 --> 00:08:31.250
and you can pretty much do
that with a search and replace,

00:08:31.290 --> 00:08:32.340
and we'll talk about that in a second.

00:08:32.340 --> 00:08:35.920
Some have actually moved into ES 3.0
core with some semantic changes.

00:08:35.920 --> 00:08:41.760
So a little bit of API changes,
but not anything dramatic.

00:08:41.780 --> 00:08:46.600
And some are still... Some that were
extensions are still extensions.

00:08:46.620 --> 00:08:48.840
Not too much to do as far as that goes.

00:08:48.840 --> 00:08:53.160
All right, so looking at the first case,
these pretty much work identically

00:08:53.250 --> 00:08:55.400
between ES 2.0 and ES 3.0.

00:08:55.400 --> 00:09:02.610
The only difference is that we've dropped
the EXT or OES prefixes or suffixes

00:09:02.620 --> 00:09:04.800
from the functions and the tokens.

00:09:04.800 --> 00:09:10.170
So a lot of this stuff you can just do
search and replace and move it forward.

00:09:12.730 --> 00:09:17.550
And a couple of quick examples, you know,
GL text storage 2D Xt has a

00:09:17.590 --> 00:09:22.540
token GL RGB 8.8 with OES has
now become GL text storage 2D.

00:09:22.730 --> 00:09:24.400
And that's it.

00:09:24.570 --> 00:09:28.340
And another example,
map buffer range Xt just drops the Xt.

00:09:28.390 --> 00:09:30.800
And, you know, same with all the tokens.

00:09:30.800 --> 00:09:31.860
So that's great.

00:09:57.260 --> 00:09:57.260
You know, that's like the trivial case.

00:09:57.260 --> 00:09:57.260
Case number two, a little less trivial,
but still not, you know,

00:09:57.260 --> 00:09:57.260
rocket science or anything.

00:09:57.260 --> 00:09:57.260
You know,
these extensions have some API changes,

00:09:57.260 --> 00:09:57.260
map buffer, discard frame buffer,
texture flow, they all still exist, but,

00:09:57.260 --> 00:09:57.260
you know, there might be some code
changes you may have to make

00:09:57.260 --> 00:09:57.260
to get them to work in ES 3.0.

00:09:57.550 --> 00:09:59.200
So a couple examples.

00:09:59.550 --> 00:10:02.230
MapBuffer,
this is the extension that lets you map

00:10:02.350 --> 00:10:07.300
an area of some memory in the GPU onto
the CPU so you can read and write.

00:10:07.330 --> 00:10:10.100
Well, MapBuffer OES is gone.

00:10:10.490 --> 00:10:15.420
Now you would use MapBuffer range,
and just specify the max size

00:10:15.420 --> 00:10:20.000
of the buffer to get the same
functionality as MapBuffer OES.

00:10:20.010 --> 00:10:23.310
And discard frame buffer.

00:10:23.960 --> 00:10:25.100
We've renamed the function.

00:10:25.160 --> 00:10:25.960
That's all there is to it.

00:10:26.110 --> 00:10:28.190
It's now GLInvalidateFrameBuffer.

00:10:28.310 --> 00:10:31.100
And now this is the function
that you would use to avoid

00:10:31.100 --> 00:10:33.050
a logical store penalty.

00:10:33.180 --> 00:10:34.330
Just want to make this point.

00:10:34.580 --> 00:10:38.580
You know, use this to invalidate anything
you're not going to present to the

00:10:38.680 --> 00:10:40.420
screen at the end of your frame.

00:10:40.490 --> 00:10:44.500
And this will help increase the
performance of your games on the A7.

00:10:55.290 --> 00:10:55.300
And Apple FrameBufferMultisample.

00:10:55.300 --> 00:10:55.300
GLResolveMultisampleFrameBufferApple
has now become,

00:10:55.300 --> 00:10:55.300
well, you create a source and a
destination buffer and use blit.

00:10:55.580 --> 00:10:57.250
Joe Blip frame buffer.

00:10:57.540 --> 00:11:01.110
And that's great,
because you can actually specify

00:11:01.110 --> 00:11:02.500
regions and so on and so forth.

00:11:02.500 --> 00:11:04.130
Pretty simple.

00:11:06.020 --> 00:11:07.600
All right, so case number three.

00:11:07.600 --> 00:11:12.450
These extensions are actually
still extensions in ES 3.0,

00:11:12.560 --> 00:11:16.260
but some of them may have
a couple minor changes,

00:11:16.260 --> 00:11:18.400
but nothing dramatic.

00:11:18.400 --> 00:11:24.140
And copy texture levels, RGB 422,
the debug label, debug marker API that

00:11:24.140 --> 00:11:26.880
you can use with Xcode,
actually.

00:11:26.880 --> 00:11:29.830
I don't know if you know about it,
but you can use it with Xcode to create

00:11:29.830 --> 00:11:32.880
groups and label stuff so that when
you're running the OpenGL debugger,

00:11:32.880 --> 00:11:35.880
you'll actually see your draws grouped.

00:11:35.900 --> 00:11:38.070
By in folders and stuff like that.

00:11:38.130 --> 00:11:40.440
That's the extension you use that with.

00:11:40.440 --> 00:11:44.940
And then I've highlighted X shader
frame buffer fetch for two reasons.

00:11:44.940 --> 00:11:47.990
One, there are some minor
semantic changes here,

00:11:47.990 --> 00:11:50.890
mostly in the GLSL version,
and I'm going to also

00:11:50.890 --> 00:11:52.240
talk about it later.

00:11:52.240 --> 00:11:54.130
That's the other reason.

00:11:54.290 --> 00:11:57.310
So...

00:11:57.800 --> 00:16:07.600
[ Transcript missing ]

00:16:08.420 --> 00:16:11.420
Now, you don't even need to move
the ES 3.0 to get this.

00:16:11.420 --> 00:16:15.670
But in ES 3.0, it's part of core,
whereas in ES 2.0, it was an extension.

00:16:15.670 --> 00:16:18.450
So this is something you can
take advantage of now and speed

00:16:18.490 --> 00:16:22.110
up the performance of your games
if this makes sense for you.

00:16:22.490 --> 00:16:23.480
What's instancing all about?

00:16:23.480 --> 00:16:27.560
Well, it's the case where you might
want to draw many similar objects.

00:16:27.690 --> 00:16:30.980
You know,
in this scene here that I'm showing,

00:16:30.980 --> 00:16:34.360
we're drawing 18,000 asteroids.

00:16:34.730 --> 00:16:34.900
Right?

00:16:35.190 --> 00:16:36.100
18,000 asteroids.

00:16:36.120 --> 00:16:38.280
Each asteroid has 48 vertices.

00:16:39.020 --> 00:16:43.320
So if you do the math,
that's 864,000 vertices, I believe.

00:16:43.430 --> 00:16:47.590
That we're actually -- 864,000
times we're going to run the,

00:16:47.590 --> 00:16:50.490
you know,
vertex shader and so on and so forth.

00:16:51.200 --> 00:16:52.040
So -- and all the keys
are in the same place.

00:16:52.490 --> 00:16:53.120
So you can do that.

00:16:53.120 --> 00:16:54.110
You can do the calculations
you might be doing.

00:16:54.180 --> 00:16:56.080
With instancing,
you can actually do that,

00:16:56.080 --> 00:16:59.620
get rid of all of the work that you're
doing on the CPU -- not all of it,

00:16:59.620 --> 00:17:01.640
but, you know,
a big majority of the work you might

00:17:01.640 --> 00:17:03.700
have been doing on the CPU previously.

00:17:04.390 --> 00:17:07.470
And still have different positions
and different colors and,

00:17:07.470 --> 00:17:09.990
you know, all sorts of -- you know,
whatever.

00:17:10.000 --> 00:17:12.500
Each asteroid can have
its own parameters.

00:17:12.620 --> 00:17:14.990
And that's what makes it really powerful.

00:17:45.080 --> 00:17:45.080
So, you know, without instancing,
here's one way you might do this.

00:17:45.080 --> 00:17:45.080
You know,
you go ahead and draw the backdrop,

00:17:45.080 --> 00:17:45.080
draw the stars and the planets.

00:17:45.080 --> 00:17:45.080
And then you would, you know,
brute force loop through

00:17:45.080 --> 00:17:45.080
all 18,000 asteroids and set
some kind of uniform matrix,

00:17:45.080 --> 00:17:45.080
you know, like your model view projection
or whatever for each asteroid

00:17:45.080 --> 00:17:45.080
and that sort of thing.

00:17:45.080 --> 00:17:45.080
And then actually draw the asteroid.

00:17:45.080 --> 00:17:45.080
Now, when you do this, what do you do?

00:17:45.080 --> 00:17:45.080
You draw the asteroid.

00:17:45.710 --> 00:17:48.810
And what this does is it fills up
the OpenGL command buffer with,

00:17:48.930 --> 00:17:52.100
what, 18,000 times two calls here.

00:17:52.120 --> 00:17:54.020
And of course,
most people are probably doing a lot

00:17:54.020 --> 00:17:55.480
more than just setting one uniform.

00:17:55.480 --> 00:17:57.700
So, you know,
you're just filling up this command

00:17:57.700 --> 00:18:03.060
buffer and asking -- which essentially
is asking GL to do a bunch of work.

00:18:03.100 --> 00:18:08.980
That's just asking the GPU to do work.

00:18:08.980 --> 00:18:08.980
The CPU is asking the GPU to do work.

00:18:09.420 --> 00:18:11.300
This is where instance
rendering comes in.

00:18:11.460 --> 00:18:15.300
Instance rendering lets you
draw the same object many,

00:18:15.300 --> 00:18:18.250
many times from a single draw call.

00:18:48.380 --> 00:18:48.380
That's what's really powerful about it.

00:18:48.380 --> 00:18:48.380
You know, and in that draw, you know,
every single one of these

00:18:48.380 --> 00:18:48.380
can have its own position,
its own rotation,

00:18:48.380 --> 00:18:48.380
its own texture coordinates, you know,
different all sorts of stuff,

00:18:48.380 --> 00:18:48.380
whatever you need.

00:18:48.380 --> 00:18:48.380
There are two APIs,
two ways to take advantage

00:18:48.380 --> 00:18:48.380
of instance rendering.

00:18:48.380 --> 00:18:48.380
The first one, instance arrays.

00:18:48.380 --> 00:18:48.380
This is kind of similar to
how you would set up your

00:18:48.380 --> 00:18:48.380
attribute arrays for positions,
normals.

00:18:48.380 --> 00:18:48.380
You might actually, you know,
create another attribute.

00:18:48.400 --> 00:18:51.960
Or you can use one of the other ones you
have and set it up in the stride somehow.

00:18:51.960 --> 00:18:55.550
But the simplest way to think about it
is you have another attribute array.

00:18:55.550 --> 00:18:59.370
And then you'd specify a divisor
so that you could actually get

00:18:59.370 --> 00:19:03.940
at the per instance data for each
instance as you're running through.

00:19:03.940 --> 00:19:07.780
You know, if you want to see this
in a little more detail,

00:19:07.780 --> 00:19:11.780
the WWDC talk from this year
on OpenGL ES 3.0 goes into

00:19:11.780 --> 00:19:15.300
this in a lot more detail,
or advances in OpenGL goes

00:19:15.300 --> 00:19:17.580
into this in a lot more detail.

00:19:18.400 --> 00:19:20.770
And shader instance ID,
I'll talk about in a little more

00:19:20.770 --> 00:19:23.940
detail because it's the simpler,
I think, conceptually of the two.

00:19:23.940 --> 00:19:28.930
But, you know, real basically,
it basically gives you this GL instance

00:19:28.930 --> 00:19:33.200
ID built in in your shader that
increments for each instance that

00:19:33.290 --> 00:19:35.980
you can use to do anything you need.

00:19:35.980 --> 00:19:38.290
Now, as I said,
both of these are available

00:19:38.290 --> 00:19:39.580
on all iOS 7 devices.

00:19:39.620 --> 00:19:41.990
ES 3 is the core and
ES 2 is an extension.

00:19:41.990 --> 00:19:45.580
So I highly recommend you guys
start using this now if you can.

00:19:45.580 --> 00:19:46.000
All right.

00:19:46.180 --> 00:19:49.280
So taking a little bit
closer look at instance ID,

00:19:49.280 --> 00:19:53.320
you know, you get this built-in
GL instance ID in your shader,

00:19:53.320 --> 00:19:55.290
which is incremented for each instance.

00:19:55.300 --> 00:19:59.380
So for the first asteroid,
the first 48 vertices,

00:19:59.380 --> 00:20:01.230
you will have instance ID 0.

00:20:01.240 --> 00:20:04.300
And then the next 48 vertices,
instance ID 1.

00:20:04.300 --> 00:20:05.930
And so on and so forth.

00:20:06.020 --> 00:20:08.980
And what you do with it is up to you.

00:20:08.980 --> 00:20:12.550
So in our particular scene,
we were using it to, you know,

00:20:12.560 --> 00:20:16.890
do some kind of sine and cosine
calculation to put it in the orb,

00:20:17.030 --> 00:20:19.380
to put each asteroid
in the orbit somewhere.

00:20:19.390 --> 00:20:21.500
And a number of other things,
which I'll talk about

00:20:21.520 --> 00:20:22.960
in a little more detail.

00:20:22.980 --> 00:20:27.120
But you can use it to, you know,
maybe look up into a uniform

00:20:27.120 --> 00:20:30.670
buffer object with the uniform
buffer object extension.

00:20:30.720 --> 00:20:35.400
You can also use it with the new
vertex texture sampling extension,

00:20:35.430 --> 00:20:38.600
which this is great because
with this extension,

00:20:38.600 --> 00:20:42.250
you can do interesting things in
your vertex shader with a texture

00:20:42.250 --> 00:20:44.340
like bump map each instance,
for example.

00:20:44.580 --> 00:20:46.720
You can now do bump mapping
directly there because you

00:20:46.900 --> 00:20:47.920
can look up into a texture.

00:20:47.920 --> 00:20:51.190
And you can use the uniform
instance ID to do that.

00:20:51.240 --> 00:20:51.680
All right.

00:20:51.790 --> 00:20:54.560
So here's what the, you know,
basic setup on the CPU would look like.

00:20:54.640 --> 00:20:58.010
You would just, you know,
set up your vertex attrib arrays.

00:20:58.300 --> 00:21:01.600
And then, of course, you know,
depending on if you're using

00:21:01.600 --> 00:21:03.540
the divisor version or not,
you might have another one.

00:21:03.560 --> 00:21:08.230
But either way,
you would then create your uniforms,

00:21:08.240 --> 00:21:11.470
your global uniforms that will
be used across all instances.

00:21:11.510 --> 00:21:17.260
And all in one draw call,
specify how many asteroids

00:21:17.310 --> 00:21:17.760
you want to draw.

00:21:17.760 --> 00:21:19.070
raw.

00:21:26.990 --> 00:21:26.990
That's it.

00:21:26.990 --> 00:21:26.990
A lot less CPU work.

00:21:28.470 --> 00:21:30.920
And in your shader, you know,
you might have the same setup.

00:21:31.100 --> 00:21:33.160
You can choose version 300 or not.

00:21:33.200 --> 00:21:36.530
In this case,
I'm using version 300 and setting

00:21:36.530 --> 00:21:40.140
up my uniforms and my attributes
the way you normally would.

00:21:41.110 --> 00:21:46.030
And using instance ID to calculate
the position of each asteroid.

00:21:46.180 --> 00:21:49.320
This is kind of a simple canned example.

00:21:49.450 --> 00:21:51.560
We're just kind of
setting them up in a grid.

00:21:53.340 --> 00:21:55.540
It's not actually what
we're doing in the demo,

00:21:55.540 --> 00:21:57.770
but, you know,
just to illustrate the point,

00:21:58.240 --> 00:21:59.960
instance ID can be used however you want.

00:21:59.990 --> 00:22:02.060
In this case, you know,
I'm modding it by 100 and

00:22:02.060 --> 00:22:03.980
dividing it by 100 to get some XY.

00:22:04.580 --> 00:22:06.430
And then I'm outputting that position.

00:22:06.520 --> 00:22:10.290
You can have much more complex lighting
or whatever it is you do in your shader,

00:22:10.370 --> 00:22:12.760
but, you know,
that's the basic example of

00:22:12.760 --> 00:22:14.360
how you'd use instance ID.

00:22:14.940 --> 00:22:17.210
All right,
so I'm going to actually run a quick demo

00:22:17.210 --> 00:22:20.010
and show you guys how you might use this.

00:22:20.310 --> 00:22:22.650
Okay,
so here's the demo I was showing earlier.

00:22:23.350 --> 00:22:27.880
And here we are rendering, you know,
18,000 asteroids in immediate mode,

00:22:27.880 --> 00:22:30.320
the brute force method
I showed you earlier.

00:22:30.320 --> 00:22:34.460
We're getting some kind of performance,
you know, 18 frames per second.

00:22:34.460 --> 00:22:36.200
Okay, that's, you know.

00:22:36.970 --> 00:22:40.690
So, you know, if I tap the screen,
we switch to instance ID.

00:22:40.820 --> 00:22:43.530
And we're getting, you know,
about double.

00:22:43.530 --> 00:22:45.800
That's actually really fantastic.

00:22:45.800 --> 00:22:50.510
I mean, it's actually faster if I don't
have it hooked up to this projector.

00:22:51.500 --> 00:22:56.160
But, You know, either way,
that's double the performance

00:22:56.160 --> 00:22:58.270
that we were seeing before.

00:25:58.500 --> 00:26:01.740
represents one instance.

00:26:01.740 --> 00:26:07.670
So that saves-- instead of 864,000
model view projection matrix

00:26:07.750 --> 00:26:12.740
calculations and a vertex shader,
we do it 18,000 times once per instance.

00:26:12.740 --> 00:26:13.400
So that's better.

00:26:13.400 --> 00:26:17.660
And it's in a previous rendering pass
before we do any rendering at all.

00:26:17.660 --> 00:26:20.390
Next topic, I wanted to talk about
multiple render targets.

00:26:20.410 --> 00:26:23.990
The main idea behind
multiple render targets is,

00:26:24.160 --> 00:26:30.180
well, now you can render to four
attachments or four textures at once.

00:26:30.210 --> 00:26:34.050
This might look like the first pass
of a deferred shading algorithm

00:26:34.050 --> 00:26:38.720
where you have your G buffer,
your geometry buffers, your normals,

00:26:38.780 --> 00:26:41.520
your depth, your albedo.

00:26:41.540 --> 00:26:43.800
And it is, actually.

00:26:43.800 --> 00:26:48.660
We actually started playing
around with some of this stuff.

00:26:48.710 --> 00:26:56.350
And what's great is that you can now
have-- for each one of these attachments,

00:26:56.400 --> 00:26:58.800
can have a different format as well.

00:26:58.800 --> 00:27:02.200
So your color can be ARGB 8888.

00:27:02.200 --> 00:27:04.430
You might want higher
precisions for your normals,

00:27:04.590 --> 00:27:05.840
1010102.

00:27:05.850 --> 00:27:08.000
And you can mix all these in one pass.

00:27:08.080 --> 00:27:11.300
So the one thing I wanted to
mention about this before we get

00:27:11.300 --> 00:27:15.330
too far into it is that if you
want to stay on the fast path,

00:27:15.490 --> 00:27:19.490
you don't want to output
more than 128 bits per pixel.

00:27:19.510 --> 00:27:23.060
So if you have a color
attachment that's ARGB 8888,

00:27:23.060 --> 00:27:27.880
that's 32 bits that you're outputting
in just that one attachment.

00:27:27.880 --> 00:27:29.800
And if you have four
with the same format,

00:27:29.910 --> 00:27:31.660
that's going to be 128.

00:27:31.700 --> 00:27:36.170
So whatever format you use,
try and do the calculation and

00:27:36.280 --> 00:27:39.560
figure out how many bits per
pixel you're actually outputting.

00:27:39.560 --> 00:27:43.640
And that will keep your
app on the fast path.

00:27:43.640 --> 00:27:46.910
If you go over that,
you'll incur a pretty

00:27:46.980 --> 00:27:48.370
huge performance penalty.

00:27:48.390 --> 00:27:51.240
I'm not going to get too deep
into deferred shading here,

00:27:51.240 --> 00:27:53.810
because this is something
that's been around for a long

00:27:53.810 --> 00:27:56.240
time on desktops and consoles.

00:27:56.250 --> 00:27:59.670
And there's a lot of information
out there about how you

00:27:59.690 --> 00:28:01.460
might do deferred shading.

00:28:01.500 --> 00:28:07.730
But just briefly want to mention,
this is something you might

00:28:07.730 --> 00:28:11.250
use to decouple the amount
of-- like the geometry,

00:28:11.400 --> 00:28:15.270
the overall geometry from the
number of lights in your scene.

00:28:15.580 --> 00:28:19.290
So the complexity of your geometry from
the number of lights in your scene.

00:28:19.310 --> 00:28:22.280
This lets you have a lot of
really interesting lighting,

00:28:22.390 --> 00:28:22.580
lots of lights.

00:28:22.690 --> 00:28:26.870
And you can see that there's lots
of lights in your scene irrelevant

00:28:26.910 --> 00:28:28.830
of what the geometry looks like.

00:28:28.840 --> 00:28:34.600
So multiple render targets, however,
is just this one piece.

00:28:34.600 --> 00:28:39.220
So this would be the first pass
of a deferred shading algorithm.

00:28:39.220 --> 00:28:42.040
The second pass,
you would then read back from these

00:28:42.640 --> 00:28:48.030
attachments and do some lighting
computation to get your final scene.

00:28:48.090 --> 00:28:52.100
So just to clarify the pass.

00:28:52.140 --> 00:28:53.380
I don't mean draws.

00:28:53.380 --> 00:28:55.900
This is actually-- I've had
this question a couple of times,

00:28:55.950 --> 00:28:58.260
so I'm going to clarify it here.

00:28:58.270 --> 00:29:03.260
Traditionally,
we sort of think of it as the first pass,

00:29:03.270 --> 00:29:06.590
you bind a whole set of textures,
and you render to those

00:29:06.590 --> 00:29:08.180
textures as your output.

00:29:08.240 --> 00:29:10.950
And then you would unbind them and
bind a whole new set of textures in

00:29:11.000 --> 00:29:15.620
the second pass and sample from the
previous textures in that second pass.

00:29:15.640 --> 00:29:17.700
That's kind of traditionally
what we mean by passes.

00:29:17.700 --> 00:29:21.060
And I'm going to use that word a
little more in the presentation,

00:29:21.060 --> 00:29:24.520
so I just wanted to make
that clarification now.

00:29:24.520 --> 00:29:25.260
All right.

00:29:25.380 --> 00:29:32.040
So this is how you might-- what the
CPU code setup for this might look like.

00:29:32.060 --> 00:29:33.000
And it's pretty simple.

00:29:33.000 --> 00:29:39.070
You would just declare the four
attachments that you're interested in,

00:29:39.070 --> 00:29:42.040
and then attach them to the frame buffer.

00:29:42.070 --> 00:29:48.570
And enable-- tell GL that you're going
to draw into those four attachments,

00:29:48.570 --> 00:29:50.330
and then just draw.

00:29:50.600 --> 00:30:24.100
[ Transcript missing ]

00:30:24.200 --> 00:32:39.300
[ Transcript missing ]

00:32:40.200 --> 00:32:43.360
So, framebuffer fetch with
multiple render targets,

00:32:43.420 --> 00:32:46.740
this is what's new in
iOS 7 and the A7 GPU.

00:32:46.740 --> 00:32:51.030
Combining that together
gives you this ability to do

00:32:51.180 --> 00:32:53.940
deferred rendering in one pass.

00:32:54.070 --> 00:32:56.610
And what that means is now you
can actually sort of read and

00:32:56.920 --> 00:32:58.560
write from the same attachments.

00:32:58.560 --> 00:33:02.740
And of course you can read and write
from one and output to another.

00:33:02.740 --> 00:33:04.520
You can read from one
and output to another.

00:33:04.520 --> 00:33:08.680
That's one of the things that
makes this really powerful.

00:33:08.960 --> 00:33:11.750
You're not limited to just kind
of reading back from the same one.

00:33:11.940 --> 00:33:14.430
This is how you might do
deferred rendering in one pass.

00:33:14.440 --> 00:33:19.490
You would use MRTs to output your
four attachments for color normals,

00:33:19.670 --> 00:33:21.480
that sort of thing.

00:33:21.650 --> 00:33:24.740
Or in the same pass,
you would then read back using

00:33:24.740 --> 00:33:28.960
framebuffer fetch without changing any
of the attachments that you have bound,

00:33:28.960 --> 00:33:32.820
which is why I'm calling
it a single pass,

00:33:32.820 --> 00:33:38.240
and then compute your
lighting and output.

00:33:39.020 --> 00:33:43.010
to one of the attachments
that you have bound.

00:33:43.300 --> 00:35:35.600
[ Transcript missing ]

00:35:36.190 --> 00:35:40.390
You'll see that we've eliminated a
lot of the work that we were doing

00:35:40.390 --> 00:35:42.810
on the CPU and moved that to the GPU.

00:35:42.910 --> 00:35:44.380
And that's actually what we want.

00:35:44.550 --> 00:35:47.810
And you can see that the
frame rate has gone up.

00:35:48.200 --> 00:37:54.200
[ Transcript missing ]

00:37:54.470 --> 00:37:57.350
All right,
so if we go back to the FPS tray,

00:37:57.350 --> 00:38:02.270
we'll notice now, if you're using the A7
versus previous GPUs,

00:38:02.300 --> 00:38:05.070
that you'll get this program
performance graph down below

00:38:05.070 --> 00:38:06.610
after you've made a capture.

00:38:06.610 --> 00:38:10.490
And you can see right off the
bat which programs are using the

00:38:10.490 --> 00:38:12.890
most amount of time in your game.

00:38:12.890 --> 00:38:14.720
Which shaders, right?

00:38:14.720 --> 00:38:18.880
So this particular shader,
program number 12,

00:38:18.930 --> 00:38:24.280
is using 22.29 milliseconds of
the 24.5 milliseconds of the A7.

00:38:24.300 --> 00:38:44.380
So this particular shader is using 22.29
milliseconds of the 24.5 milliseconds

00:38:44.440 --> 00:38:54.280
of the 24.5 milliseconds of the A7.

00:38:54.300 --> 00:39:05.190
So this particular shader is using 22.29
milliseconds of the 24.5 milliseconds

00:39:05.240 --> 00:39:10.650
of the 24.5 milliseconds of the A7.

00:39:11.020 --> 00:39:16.660
will actually get line-by-line
performance information in the shader.

00:39:16.710 --> 00:39:19.570
And you'll see how much performance,
how much time each one of

00:39:19.570 --> 00:39:21.290
those lines of code are taking.

00:39:21.290 --> 00:39:25.420
So, okay, great.

00:39:25.620 --> 00:39:28.840
Well, this first line,
where I'm using instance ID to

00:39:28.890 --> 00:39:34.860
look up in a uniform buffer object,
is taking 28.1% of the overall

00:39:34.860 --> 00:39:38.690
20.52 milliseconds in my code.

00:39:38.700 --> 00:39:42.510
Well, I actually,
that's work I want to be doing,

00:39:42.640 --> 00:39:43.910
so that's fine.

00:39:43.920 --> 00:39:47.580
I want to actually put more of that,
I want more of the percentage to

00:39:47.580 --> 00:39:51.110
go into that particular line of
code than some of the other ones,

00:39:51.110 --> 00:39:51.770
right?

00:39:52.350 --> 00:39:55.440
So, okay, let's take a look and see
what else we can optimize.

00:39:55.440 --> 00:40:00.130
Well, you know, this line,
this for loop here is

00:40:00.130 --> 00:40:03.340
taking 11.3% to what?

00:40:03.340 --> 00:40:06.200
Well, hard code a bunch of values
into a model view matrix,

00:40:06.200 --> 00:40:07.820
and it looks like four times.

00:40:09.170 --> 00:40:13.750
Well, you can take a look at the,
if we take a look at the shader best

00:40:14.210 --> 00:40:20.060
practices guide on developer.apple.com,
you'll see that actually using a for

00:40:20.230 --> 00:40:25.080
loop to pre-calculate a value to then,
you know, kind of set that up is kind of,

00:40:25.080 --> 00:40:25.960
it's slow.

00:40:25.960 --> 00:40:28.830
So something we can do actually
is just unroll this loop

00:40:28.830 --> 00:40:30.500
and hard code these values.

00:40:30.500 --> 00:40:36.410
So I'm going to go ahead and copy this
line of code and delete the for loop.

00:40:36.540 --> 00:40:38.180
I'm going to go ahead
and unroll this loop.

00:40:39.100 --> 00:40:43.080
and just paste the values here.

00:41:08.140 --> 00:41:08.140
And then,
when I've made the change to my shader,

00:41:08.140 --> 00:41:08.140
I can then click on this kind of circular
arrow here right below the shader,

00:41:08.140 --> 00:41:08.140
and it will actually recompile -- ah,
it looks like I have an error.

00:41:08.140 --> 00:41:08.140
So it's smart enough to tell
me that I have an error.

00:41:08.140 --> 00:41:08.140
Okay.

00:41:08.140 --> 00:41:08.140
Yes, because I changed the wrong --

00:41:08.310 --> 00:41:10.630
Let's go back and do that again.

00:41:10.640 --> 00:41:11.330
All right.

00:41:11.420 --> 00:41:13.860
So I'll go ahead and recompile it again.

00:41:34.100 --> 00:41:34.100
And we'll notice that
when it's done compiling,

00:41:34.100 --> 00:41:34.100
that amount of work that we were
doing there is gone and it's moved,

00:41:34.100 --> 00:41:34.100
and the percentage that we're --
where we want to be doing more work,

00:41:34.100 --> 00:41:34.100
and that's where we're spending our time.

00:41:34.100 --> 00:41:34.100
And of course, the overall time of the
shader has decreased.

00:41:34.100 --> 00:41:34.100
It's now running at

00:41:34.810 --> 00:41:39.340
You know, 17.56 milliseconds,
where it was, you know,

00:41:39.340 --> 00:41:40.900
something like 20 milliseconds before.

00:41:40.900 --> 00:41:42.250
Well, that's great.

00:41:42.310 --> 00:41:45.010
Well, what if I want to actually see
that in my game and see what the

00:41:45.070 --> 00:41:46.500
performance looks like in my game?

00:41:46.580 --> 00:41:51.590
Well, if you click this arrow down here,
where the camera button was, you can get,

00:41:51.590 --> 00:41:53.500
you know, this arrow.

00:41:53.500 --> 00:41:56.500
It will continue--it will rerun
the game that you were running,

00:41:56.500 --> 00:41:58.380
but it will inject the
new shader in your game.

00:41:58.780 --> 00:42:03.810
And you can see that the
frame rate has gone up.

00:42:05.520 --> 00:42:08.220
So that's one way you can use the
new shader profiler to actually

00:42:08.340 --> 00:42:09.990
kind of tune your shaders.

00:42:10.090 --> 00:42:12.710
And once again,
this only works on the A7.

00:42:12.970 --> 00:42:15.600
So this is another reason to get one
of these devices and play with it.

00:42:15.600 --> 00:42:17.730
And, you know,
you can optimize code for previous

00:42:17.730 --> 00:42:21.760
devices as well using this,
but you have to have the A7 to

00:42:21.760 --> 00:42:25.050
do this kind of shader profiling.

00:42:25.060 --> 00:42:31.040
So I highly encourage you guys to
take advantage of the tools and

00:42:31.040 --> 00:42:32.960
play around with some of this stuff.

00:42:33.010 --> 00:42:37.260
We talked about the A7 GPU and
OpenGL ES 3.0 and how you can use

00:42:37.260 --> 00:42:38.590
the new technologies together.

00:42:38.590 --> 00:42:41.960
And we talked about how you can use
Xcode's OpenGL ES frame debugger

00:42:41.960 --> 00:42:47.140
and the new shader profiler to
take advantage of how you can

00:42:47.250 --> 00:42:48.960
tune your games with this stuff.

00:42:49.090 --> 00:42:52.600
So I hope you guys take advantage
of this new technology and go out

00:42:52.600 --> 00:42:54.960
and make some awesome OpenGL games.

00:42:54.960 --> 00:42:56.960
And thank you for your time.

00:42:56.970 --> 00:42:58.960
I'm Philip Iliasqueux.

00:42:58.960 --> 00:43:00.930
I'm the new graphics
and media evangelist.

00:43:00.950 --> 00:43:04.690
Just started in November on this team.

00:43:04.890 --> 00:43:09.580
And Apple Developer Forums is, you know,
you can post any questions there,

00:43:09.580 --> 00:43:13.860
and we'll try to get back to you as
much as you can -- as much as we can.

00:43:13.860 --> 00:43:17.860
And take a look at the
documentation for OpenGL.

00:43:17.860 --> 00:43:22.040
And this is the video I promised
to give you the link for earlier,

00:43:22.040 --> 00:43:24.860
migrating to the OpenGL core profile.

00:43:24.860 --> 00:43:28.720
And I'll help you get into
GLSL 300 by looking at how

00:43:28.720 --> 00:43:30.730
we did that on the desktop.

00:43:30.760 --> 00:43:32.660
So here's the link.

00:43:32.750 --> 00:43:34.600
You should write it
down if you -- you know,

00:43:34.600 --> 00:43:36.760
if you're interested in
taking a look at that.

00:43:37.570 --> 00:43:39.280
So, great.

00:43:39.810 --> 00:43:41.730
Thank you very much.
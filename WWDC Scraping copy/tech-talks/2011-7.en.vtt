WEBVTT

00:00:22.910 --> 00:00:25.800
Hello, I'm Alan Schafer,
the Game Technologies Evangelist

00:00:25.800 --> 00:00:26.200
at Apple.

00:00:26.200 --> 00:00:28.430
A lot of great games
are using Game Center,

00:00:28.510 --> 00:00:30.430
Apple's social gaming network.

00:00:30.520 --> 00:00:35.010
And in iOS 5, we're taking multiplayer
gaming a step further with new

00:00:35.010 --> 00:00:37.180
support for churn-based games.

00:00:37.180 --> 00:00:40.260
So in this video,
I'll walk you through the steps you'll

00:00:40.320 --> 00:00:44.230
take to implement a churn-based game
with an emphasis on the UI you'll

00:00:44.330 --> 00:00:48.380
present to the player and how your
game will respond to the user's actions

00:00:48.380 --> 00:00:49.890
and the actions of the other players.

00:00:50.260 --> 00:00:52.580
You'll see how to
manage multiple matches,

00:00:52.580 --> 00:00:57.030
how to allow players to take churns,
how to handle players dropping out,

00:00:57.030 --> 00:00:59.540
and how to end the match
when the game is over.

00:00:59.580 --> 00:01:00.740
So let's get started.

00:01:02.390 --> 00:01:06.230
Of course, we're all familiar with the
mechanics of a turn-based game.

00:01:06.390 --> 00:01:09.260
There are multiple players and at
any given time during the game,

00:01:09.260 --> 00:01:10.750
it's somebody's turn.

00:01:10.880 --> 00:01:13.920
That person makes their move or
takes their turn and the turn

00:01:14.020 --> 00:01:17.670
passes to the next player and this
is repeated until the game is over.

00:01:18.400 --> 00:01:22.560
How it works in Game Center is
that at any particular moment,

00:01:22.580 --> 00:01:25.420
it's somebody's turn,
that player makes their

00:01:25.420 --> 00:01:28.590
move and in doing so,
they update the game data for

00:01:28.590 --> 00:01:30.160
the match they're playing.

00:01:30.530 --> 00:01:34.070
They send that data to
Game Center and tell Game Center to

00:01:34.080 --> 00:01:36.600
pass the turn to the next player.

00:01:36.780 --> 00:01:40.180
The next person then receives a
notification that it's their turn.

00:01:40.280 --> 00:01:41.810
They'll take their phone
out of their pocket,

00:01:41.920 --> 00:01:45.700
run your app, and the app downloads
the latest game data.

00:01:45.730 --> 00:01:47.640
Then that player repeats the process.

00:01:47.960 --> 00:01:50.250
They take their turn,
update the game data,

00:01:50.250 --> 00:01:53.480
and tell Game Center to pass
the turn to the next player.

00:01:53.950 --> 00:01:58.700
That person gets a notification,
downloads the new data, and so on.

00:01:58.830 --> 00:02:02.080
Now, a really great feature of
Game Center is the ability to

00:02:02.080 --> 00:02:04.550
auto-match players to fill empty seats.

00:02:04.770 --> 00:02:08.810
So, when the turn reaches an empty seat,
Game Center can auto-match a new

00:02:08.940 --> 00:02:10.720
player who is waiting to join the game.

00:02:10.720 --> 00:02:12.680
It's immediately that person's turn.

00:02:12.680 --> 00:02:16.630
They make their move and play continues.

00:02:16.840 --> 00:02:19.900
You, the developer,
have total control over how the

00:02:19.980 --> 00:02:23.980
turn is passed and you'll code this
based on the rules of your game.

00:02:24.080 --> 00:02:27.790
So your code just tells
Game Center whose turn it is next

00:02:27.910 --> 00:02:31.380
and you can pass the turn forward,
backwards, you can skip players,

00:02:31.380 --> 00:02:33.220
you have complete flexibility.

00:02:33.250 --> 00:02:33.810
It's up to you.

00:02:35.720 --> 00:02:39.200
And finally,
each player can participate in up to 30

00:02:39.200 --> 00:02:42.480
instances of your game simultaneously.

00:02:42.480 --> 00:02:46.410
Where in some it's their turn,
some it's someone else's turn.

00:02:46.470 --> 00:02:49.550
Up on the top of the screen you
see they're starting a new game and

00:02:50.050 --> 00:02:52.480
waiting to have players auto-matched.

00:02:52.480 --> 00:02:55.880
And on the right side you see
one where the game is over.

00:02:56.830 --> 00:02:59.340
So let's recap these capabilities.

00:02:59.440 --> 00:03:04.460
Each player can participate in up to
30 simultaneous matches in your game.

00:03:04.600 --> 00:03:07.560
And each match can have up to 16 players.

00:03:07.750 --> 00:03:11.930
The gameplay is asynchronous and
communication with Game Center uses

00:03:11.930 --> 00:03:14.080
either Wi-Fi or the cellular network.

00:03:14.140 --> 00:03:20.040
The game data for each match can be up to
64K and I'll discuss various strategies

00:03:20.040 --> 00:03:22.220
for handling this later in the talk.

00:03:22.330 --> 00:03:26.140
And you, the developer,
determine how the turns are passed.

00:03:26.140 --> 00:03:29.670
And finally,
players join the games either by

00:03:29.670 --> 00:03:32.730
accepting invites or by auto-matching.

00:03:32.990 --> 00:03:36.640
So those are the capabilities
from the Game Center perspective.

00:03:36.640 --> 00:03:40.280
But now let's think about how
a turn-based game needs to be

00:03:40.440 --> 00:03:44.850
architected because it's different
than a single player arcade style game

00:03:44.900 --> 00:03:46.840
or a synchronous multiplayer game.

00:03:46.840 --> 00:03:50.940
The first thing to understand is
that your app needs to be able to

00:03:50.940 --> 00:03:56.900
manage multiple matches being played
simultaneously by each player up to 30.

00:03:57.510 --> 00:04:01.020
And each match is in a different
state with different game data,

00:04:01.400 --> 00:04:04.810
different opponents,
and ultimately each will

00:04:04.810 --> 00:04:06.810
have a unique outcome.

00:04:07.360 --> 00:04:10.240
The second difference
is that in each match,

00:04:10.290 --> 00:04:13.170
it's only one player's turn at a time.

00:04:13.260 --> 00:04:16.930
The other players can observe,
but they can't play

00:04:17.000 --> 00:04:18.180
until it's their turn.

00:04:18.740 --> 00:04:20.420
Think about a game of chess.

00:04:20.490 --> 00:04:23.200
While it's your turn,
I can look at the board

00:04:23.230 --> 00:04:26.380
and plan my next move,
but I can't move any pieces

00:04:26.380 --> 00:04:28.280
until it becomes my turn.

00:04:28.340 --> 00:04:32.730
So your app has to be coded to
enforce rules like that one.

00:04:33.400 --> 00:04:37.900
The third thing to understand is that
turn-based games are asynchronous.

00:04:37.900 --> 00:04:42.890
So your app is not always running
for the entire duration of the game.

00:04:42.930 --> 00:04:46.700
Instead, the expectation is that the
player will run your app,

00:04:46.700 --> 00:04:49.570
choose one of the matches
that they're playing,

00:04:49.570 --> 00:04:53.700
and then your app will download the
latest game data from Game Center so

00:04:53.700 --> 00:04:55.610
it can know what's happened.

00:04:55.620 --> 00:05:00.540
And last is to realize that
because turn-based games are

00:05:00.540 --> 00:05:03.250
asynchronous and because you can
have multiple turn-based games,

00:05:03.250 --> 00:05:03.380
you can't run them.

00:05:03.380 --> 00:05:03.380
So you have to be careful.

00:05:03.400 --> 00:05:05.200
If you have multiple matches
running simultaneously,

00:05:05.240 --> 00:05:10.650
that your players could be anywhere
in the app when various events occur.

00:05:10.660 --> 00:05:13.540
Maybe they're looking at
a match or making a move,

00:05:13.640 --> 00:05:18.140
or maybe they're tapping around on the
main menu when someone else makes their

00:05:18.200 --> 00:05:20.650
move and it becomes that player's turn.

00:05:20.650 --> 00:05:22.730
You need to handle this thoughtfully.

00:05:22.730 --> 00:05:25.510
You shouldn't just yank them
out of what they were doing

00:05:25.510 --> 00:05:27.380
and switch to that other match.

00:05:27.380 --> 00:05:29.850
You need to think about
putting up a notification,

00:05:29.880 --> 00:05:33.120
saying what's happening,
or just let them act accordingly.

00:05:33.120 --> 00:05:34.590
accordingly.

00:05:35.250 --> 00:05:37.900
Okay,
so with that conceptual introduction,

00:05:37.900 --> 00:05:42.900
now let's get started and look at the
API for implementing a turn-based game.

00:05:43.260 --> 00:05:46.680
So there's four main classes
you'll use for turn-based games.

00:05:46.750 --> 00:05:49.700
The first is the GK turn-based match.

00:05:49.750 --> 00:05:53.420
This is the main entry point for
the API and essentially the central

00:05:53.420 --> 00:05:55.070
nervous system for each match.

00:05:55.080 --> 00:05:59.270
Each match is an instance of the
game with a list of participants,

00:05:59.380 --> 00:06:02.720
a pointer to the game state,
and the ID of the player

00:06:02.720 --> 00:06:04.650
whose turn it is right now.

00:06:04.880 --> 00:06:09.810
The way the match works is that the
player selects a match they want to play.

00:06:10.100 --> 00:06:14.850
You use the match API to retrieve the
latest game data from Game Center.

00:06:14.890 --> 00:06:18.750
The player takes their turn and
this updates the game state.

00:06:18.910 --> 00:06:22.110
And then your app passes
the turn to the next player.

00:06:22.660 --> 00:06:26.530
This continues until we break out
of this loop when the match ends,

00:06:26.530 --> 00:06:28.310
meaning the game is over.

00:06:29.180 --> 00:06:32.780
The second class is the
GK turn-based participant.

00:06:32.860 --> 00:06:36.420
This is either a person or an
empty slot and there can be up

00:06:36.420 --> 00:06:38.940
to 16 participants in a match.

00:06:39.030 --> 00:06:43.420
Each participant contains a player ID,
a status, and an outcome.

00:06:43.460 --> 00:06:46.480
There's an interesting
detail about the player ID.

00:06:46.480 --> 00:06:49.990
It has the player's Game Center ID or
it can be nil if we're waiting

00:06:50.060 --> 00:06:52.090
for someone to be auto-matched.

00:06:52.480 --> 00:06:55.330
The status will tell you
the state of the player:

00:06:55.330 --> 00:06:59.890
invited or matching before we start,
active while the match is running,

00:07:00.180 --> 00:07:04.420
and done after the match ends
or if that person drops out.

00:07:04.420 --> 00:07:08.200
The outcome is something you
fill in when the game ends to

00:07:08.200 --> 00:07:10.370
tell the player how they did.

00:07:12.240 --> 00:07:15.960
The third class is the
GK turn-based event handler.

00:07:16.020 --> 00:07:18.990
The delegate object you set up
for this class receives all of

00:07:18.990 --> 00:07:21.440
the external events for your game.

00:07:21.580 --> 00:07:24.020
For example,
when the player receives an invite

00:07:24.330 --> 00:07:28.320
or the invite sequence has been
initiated from the Game Center app.

00:07:28.450 --> 00:07:32.530
You'll also receive events each
time someone takes their turn

00:07:32.530 --> 00:07:34.790
and when the match has ended.

00:07:35.630 --> 00:07:40.300
The fourth class is the GK Turn-Based
Matchmaker View Controller.

00:07:40.480 --> 00:07:44.300
This is the hub of all the
user activity in your game.

00:07:44.480 --> 00:07:48.930
Its main purpose is to manage the
matches the player is participating in.

00:07:49.080 --> 00:07:52.420
It lets them pick a match to
play or to quit or to remove

00:07:52.420 --> 00:07:54.170
the match from the list.

00:07:54.520 --> 00:07:58.980
And it also allows the users to
start a new match either by inviting

00:07:59.020 --> 00:08:01.350
friends or by auto matching.

00:08:04.050 --> 00:08:07.600
But now let me take you on a tour
through the UI of the view controller.

00:08:07.650 --> 00:08:10.800
And then we'll use this to branch
out into different topics that

00:08:10.800 --> 00:08:13.500
you'll need to handle in your code.

00:08:13.590 --> 00:08:17.540
First, starting with this button at the
top for invites and matchmaking.

00:08:17.590 --> 00:08:21.340
This is how the user starts a new
match by inviting their friends

00:08:21.340 --> 00:08:23.160
or asking to be auto-matched.

00:08:23.200 --> 00:08:26.470
And once they're in the match,
it'll immediately become their

00:08:26.470 --> 00:08:30.300
turn and that match will show
up on the list down below.

00:08:30.830 --> 00:08:36.500
This next area here shows the matches
where it's this player's turn right now.

00:08:36.620 --> 00:08:39.530
We see the profile photo
of their opponent and when

00:08:39.530 --> 00:08:41.600
that person took their turn.

00:08:41.700 --> 00:08:45.850
And if we tap one of these matches,
it's expected that you'll

00:08:45.850 --> 00:08:49.940
dismiss the view controller,
take the player into the game,

00:08:50.000 --> 00:08:53.180
and allow them to play their turn.

00:08:53.280 --> 00:08:55.180
Scrolling down.

00:08:56.710 --> 00:09:00.600
This next part shows the matches where
it's someone else's turn right now.

00:09:00.600 --> 00:09:05.120
So we're waiting for Jessica and
Eunice to take their turns and in

00:09:05.120 --> 00:09:07.990
this third one we're waiting for
a new player to be auto-matched

00:09:08.000 --> 00:09:09.590
against us and take their turn.

00:09:09.890 --> 00:09:14.300
And if we tap one of these matches
it's expected that you'll take the

00:09:14.400 --> 00:09:18.270
player into the game and download the
latest game state from Game Center but

00:09:18.410 --> 00:09:23.190
it's not our turn so you wouldn't
allow the player to make any moves.

00:09:23.480 --> 00:09:25.880
They can only observe
or maybe they can quit.

00:09:28.820 --> 00:09:31.720
Speaking of quitting a match,
the player can swipe one of the

00:09:31.720 --> 00:09:33.510
matches to bring up a button to quit.

00:09:33.720 --> 00:09:35.880
In this case,
they're quitting out of turn.

00:09:35.890 --> 00:09:37.800
I'll show you how we
handle that a bit later.

00:09:37.800 --> 00:09:41.520
And finally, this section at the bottom
showing matches that have

00:09:41.520 --> 00:09:43.110
ended and their outcome.

00:09:43.110 --> 00:09:46.120
I can swipe these to
remove them from the list,

00:09:46.340 --> 00:09:49.150
or if I tap one, again,
I expect the app to

00:09:49.320 --> 00:09:52.560
take me into the game,
download the final game

00:09:52.560 --> 00:09:55.090
data from Game Center,
and show me the final

00:09:55.310 --> 00:09:56.700
state of this match.

00:09:56.700 --> 00:09:58.580
For example, the checkmate move.

00:09:58.700 --> 00:10:04.150
So, now let's look at the implementation.

00:10:05.700 --> 00:10:09.040
And we'll use the view controller
as the jumping off point.

00:10:09.040 --> 00:10:15.010
So we need code that will set up the view
controller and then code that handles all

00:10:15.010 --> 00:10:17.300
the possible actions the user might take.

00:10:17.410 --> 00:10:19.790
There's four of those possible actions.

00:10:19.790 --> 00:10:22.380
They can go to the invite
screen and start a new match

00:10:22.380 --> 00:10:23.900
or ask to be auto-matched.

00:10:24.440 --> 00:10:28.360
They can select one of the matches and
it might be one where it's their turn,

00:10:28.360 --> 00:10:30.920
someone else's turn,
or one where the match has ended.

00:10:30.920 --> 00:10:34.440
They can remove a match from the list,
one where it's their turn,

00:10:34.520 --> 00:10:37.720
someone else's turn,
or one where the match has ended.

00:10:37.720 --> 00:10:41.390
And last, they can cancel out to
dismiss the view controller.

00:10:43.410 --> 00:10:46.300
So let's start with setting
up the view controller.

00:10:46.470 --> 00:10:50.340
First, I actually need to create a match
request in case the user taps the

00:10:50.440 --> 00:10:51.940
plus button to create a new match.

00:10:52.120 --> 00:10:56.370
So we create a GK match request,
set the minimum and maximum

00:10:56.370 --> 00:11:00.060
number of players and any
other attributes for the match.

00:11:00.160 --> 00:11:04.690
Next, we create and initialize the view
controller and pass in the match

00:11:04.690 --> 00:11:06.590
request that we just created.

00:11:07.100 --> 00:11:08.300
Next, we set some options.

00:11:08.300 --> 00:11:11.170
For example,
it's possible to create your own

00:11:11.170 --> 00:11:13.160
UI to show the list of matches.

00:11:13.290 --> 00:11:17.180
But here, we're just saying that we
want to use the built-in UI.

00:11:17.180 --> 00:11:19.240
And we set a delegate.

00:11:19.350 --> 00:11:21.570
And finally,
we present the view controller

00:11:21.570 --> 00:11:23.120
and we're off and running.

00:11:23.660 --> 00:11:27.320
Now the view controller is up and
if the user taps any of the matches

00:11:27.370 --> 00:11:31.360
the delegate method "turn-based
matchmaker view controller did

00:11:31.490 --> 00:11:32.940
find match" will be called.

00:11:33.240 --> 00:11:36.770
And as I said earlier,
what's expected is that you'll

00:11:36.770 --> 00:11:40.300
dismiss the view controller and
take the player into the game.

00:11:40.300 --> 00:11:45.160
Then you'll download the game data
for the match that they selected,

00:11:45.160 --> 00:11:48.000
unpack it and show the state
of the match to the player.

00:11:48.000 --> 00:11:50.860
If it were a chess game for
example you'd show them the board.

00:11:51.960 --> 00:11:55.560
And what to do from there depends
on whether it's this player's

00:11:55.660 --> 00:11:57.590
turn now or someone else's.

00:11:57.670 --> 00:12:01.420
If it is their turn you'll
let them take their action.

00:12:01.420 --> 00:12:03.660
So let's look at how that's implemented.

00:12:04.830 --> 00:12:07.410
Here's that delegate method
turn-based matchmaker view

00:12:07.500 --> 00:12:09.530
controller did find match.

00:12:09.620 --> 00:12:12.540
We're being passed the view controller
and the match they selected,

00:12:12.660 --> 00:12:16.040
so we dismiss the view
controller and go into the game.

00:12:16.150 --> 00:12:20.580
And start by downloading the
game data for this match.

00:12:20.730 --> 00:12:23.220
And then we have a block
where once it's downloaded,

00:12:23.350 --> 00:12:27.560
we'll unpack it into our
own internal representation.

00:12:27.690 --> 00:12:30.720
We use that to display
the game to the user,

00:12:30.840 --> 00:12:34.390
and then if it's this player's turn,
we'll let them take their

00:12:34.390 --> 00:12:35.620
action in the match.

00:12:35.720 --> 00:12:39.300
And take note of how we find out
whether it's this player's turn.

00:12:39.410 --> 00:12:42.840
One of the properties of the
match is the current participant.

00:12:42.930 --> 00:12:45.560
That's the participant
whose turn it is right now.

00:12:45.680 --> 00:12:50.940
So we compare the player ID of the
current participant with our player ID.

00:12:51.040 --> 00:12:53.860
If they're equal, then it's our turn.

00:12:53.980 --> 00:12:59.800
Okay, now let me go back for a moment
and talk more about the match data.

00:13:00.290 --> 00:13:04.460
The match data contains all of the
game state for a specific match.

00:13:04.600 --> 00:13:09.340
This has to contain all of the data
that you need to fully represent the

00:13:09.340 --> 00:13:12.640
current state of the game to each player.

00:13:12.740 --> 00:13:14.050
It's an NSData object.

00:13:14.220 --> 00:13:18.080
You define its contents and you
pack the game state into it before

00:13:18.080 --> 00:13:22.790
you upload it to Game Center and
unpack it when you download it.

00:13:22.960 --> 00:13:26.940
Game Center stores this data for all
of your matches and it's visible by all

00:13:27.090 --> 00:13:29.660
of the participants in those matches.

00:13:29.780 --> 00:13:32.970
But note that only the current
participant can modify it,

00:13:33.100 --> 00:13:35.910
the player whose turn it is right now.

00:13:36.370 --> 00:13:39.800
and it has a limited size 64K.

00:13:39.920 --> 00:13:43.980
So you have to be very wise
about how the data is stored.

00:13:44.090 --> 00:13:47.500
If you have a lot of different elements,
you will certainly want to tightly

00:13:47.500 --> 00:13:51.730
pack them together yourself,
probably into a C struct instead of,

00:13:51.800 --> 00:13:55.180
for example,
using an NSDictionary and assuming

00:13:55.180 --> 00:13:58.070
that it will be packed up efficiently.

00:13:58.070 --> 00:14:02.720
And if 64K isn't enough space,
then another alternative would be to

00:14:02.720 --> 00:14:08.060
use the match data to index into data
that you maintain on your own server.

00:14:09.210 --> 00:14:12.500
So we've shown the view controller,
let the user create

00:14:12.500 --> 00:14:14.400
matches and select a match.

00:14:14.540 --> 00:14:17.640
We talked about downloading the
game data and we check to see

00:14:17.640 --> 00:14:19.440
whether it's our turn or not.

00:14:19.570 --> 00:14:23.370
So next, let me show you how
you can take your turn.

00:14:24.640 --> 00:14:28.300
Now every game has its own logic
and implementation for letting

00:14:28.300 --> 00:14:30.080
the player take their turn.

00:14:30.120 --> 00:14:33.360
If it were chess, for example,
the player moves a piece.

00:14:33.400 --> 00:14:36.920
In a card game, they play their hand,
all according to the rules of the game.

00:14:36.960 --> 00:14:42.040
The point at which Game Center applies
to this is when it becomes time to

00:14:42.110 --> 00:14:44.620
pass the turn to the next player.

00:14:44.640 --> 00:14:49.430
And there's a subtle distinction
here between taking your

00:14:49.510 --> 00:14:51.910
turn and passing the turn.

00:14:52.240 --> 00:14:55.720
In chess, for example,
after you've moved a piece,

00:14:55.740 --> 00:14:58.620
it implicitly becomes
your opponent's turn.

00:14:59.000 --> 00:15:03.920
But other games might let you take
multiple actions before passing the turn.

00:15:04.060 --> 00:15:08.120
In a trivia game, for example,
perhaps you get to keep answering

00:15:08.120 --> 00:15:11.740
questions and playing your turn
until you answer incorrectly,

00:15:11.790 --> 00:15:15.090
and then the turn
passes to your opponent.

00:15:15.450 --> 00:15:19.950
So when it is time to pass the turn,
what you'll do is to update the match

00:15:20.040 --> 00:15:21.990
data with the latest game state.

00:15:22.200 --> 00:15:25.300
Your code will choose
which player goes next.

00:15:25.610 --> 00:15:28.980
There's an optional message that can
be displayed to the other players.

00:15:29.180 --> 00:15:32.270
And then you'll call the
Game Center API to pass the turn.

00:15:32.440 --> 00:15:34.070
So let's take a look at that.

00:15:34.520 --> 00:15:35.400
So here it is.

00:15:35.400 --> 00:15:38.290
It was our turn and
we've taken our action.

00:15:38.290 --> 00:15:41.790
So we update the state of the
match based on the action we

00:15:41.790 --> 00:15:43.950
took and the rules of the game.

00:15:43.950 --> 00:15:45.960
Then we choose who goes next.

00:15:45.960 --> 00:15:48.570
And I'll come back to this in a moment.

00:15:48.570 --> 00:15:53.620
We can set an optional message that
will be shown to the other participants.

00:15:53.620 --> 00:15:56.580
And then here is where the work is done.

00:15:56.580 --> 00:16:00.830
We tell the match to end our turn
and we pass in who goes next,

00:16:00.930 --> 00:16:04.500
the updated match data,
and there's a completion handler.

00:16:04.520 --> 00:16:06.760
For when this is finished
to check for errors.

00:16:06.760 --> 00:16:10.560
So this uploads the new match
data to Game Center and triggers

00:16:10.560 --> 00:16:14.830
a notification to the next
participant that it's now their turn.

00:16:16.280 --> 00:16:17.040
But let's go back.

00:16:17.200 --> 00:16:19.760
How do we choose who goes next?

00:16:19.830 --> 00:16:23.190
Well, it's up to you, the developer,
to code this logic into your app

00:16:23.540 --> 00:16:24.570
based on the rules of the game.

00:16:24.640 --> 00:16:28.580
Some games only have two players,
so the turn just passes back and forth.

00:16:28.940 --> 00:16:32.170
Other games with more players have
different logic for passing the turn.

00:16:32.200 --> 00:16:36.320
But the bottom line is,
each match has an array of participants,

00:16:36.400 --> 00:16:39.610
and your app tells
Game Center which one's next.

00:16:39.660 --> 00:16:41.990
But there's one thing
you have to be aware of,

00:16:41.990 --> 00:16:45.660
and it's that a player might quit
the match before the game is over.

00:16:46.200 --> 00:16:50.610
And it's important that you do not
pass the turn to a player who has quit.

00:16:50.800 --> 00:16:54.860
So let's look at an example of
how you might implement this.

00:16:54.860 --> 00:16:58.980
The match has an array of participants,
and I'm starting out just by

00:16:58.980 --> 00:17:02.530
getting the index of the player
whose turn it is right now.

00:17:02.540 --> 00:17:06.370
My plan is to pass the turn to
whoever is next in the array,

00:17:06.470 --> 00:17:10.440
and go back to index zero if
I'm at the last participant.

00:17:10.440 --> 00:17:12.730
So that's what I'm doing here.

00:17:12.850 --> 00:17:17.740
I get the object at I plus one,
modulo the count of the participants.

00:17:17.810 --> 00:17:22.100
However, I need to make sure that this
next player has not quit,

00:17:22.600 --> 00:17:23.940
so I check their status.

00:17:24.040 --> 00:17:27.400
If it's not done,
it means they're still in the game,

00:17:27.400 --> 00:17:28.590
and they go next.

00:17:28.700 --> 00:17:32.500
But if it is done,
then I increment the index,

00:17:32.770 --> 00:17:34.950
and go to the next person,
and repeat the process.

00:17:35.030 --> 00:17:39.140
And I keep iterating until I find
a player who is still in the game.

00:17:39.200 --> 00:17:42.770
Or in this case,
if I come back around to myself,

00:17:42.920 --> 00:17:45.900
it means that everyone else has quit,
and I need to handle that.

00:17:45.900 --> 00:17:48.690
Now, it was my turn,
I've taken my action,

00:17:48.770 --> 00:17:51.690
and I've told Game Center to
pass the turn.

00:17:51.700 --> 00:17:53.660
So what happens on the other side?

00:17:53.660 --> 00:17:55.500
What do the other players see?

00:17:55.500 --> 00:17:59.540
Well, the information about me taking
my turn will come to them through

00:17:59.540 --> 00:18:01.800
their GK Turn-Based Event Handler.

00:18:01.800 --> 00:18:04.220
If they have the app running,
the delegate method

00:18:04.220 --> 00:18:07.290
"handleTurnEventForMatch"
will be called on their side.

00:18:07.300 --> 00:18:10.010
And note,
it'll actually be called each time

00:18:10.270 --> 00:18:14.760
anybody makes a turn in any match
that they're participating in.

00:18:14.830 --> 00:18:17.900
So anyways,
somebody took a turn in some match.

00:18:17.900 --> 00:18:21.260
It's not necessarily
that person's turn now.

00:18:21.400 --> 00:18:22.460
What should they do?

00:18:22.600 --> 00:18:25.850
Well, remember,
that player could be anywhere in

00:18:25.850 --> 00:18:28.020
the app when all of this happens.

00:18:28.110 --> 00:18:31.530
So you probably just want to
inform them that I took my turn.

00:18:31.600 --> 00:18:35.570
If they happen to be looking
at the match that I'm in,

00:18:35.580 --> 00:18:37.090
then update its UI.

00:18:37.300 --> 00:18:41.180
And if it's now become their turn,
then tell them.

00:18:41.300 --> 00:18:43.520
So let's take a look at all of this.

00:18:45.380 --> 00:18:48.900
So someone in some match
has taken their turn,

00:18:48.930 --> 00:18:54.180
so handleTurnEventForMatch is called
and we're past the match object.

00:18:54.360 --> 00:18:57.750
What you do next is up to you,
but in this example,

00:18:57.750 --> 00:19:00.640
I'm looking to see if it's now my turn.

00:19:00.810 --> 00:19:04.230
If it is,
I use the new GK notification banner

00:19:04.230 --> 00:19:08.750
feature to display a banner to the
user saying it's your turn along

00:19:08.750 --> 00:19:11.410
with an optional match message.

00:19:11.880 --> 00:19:15.000
And if the user happened to
be looking at the match that

00:19:15.000 --> 00:19:18.180
someone just took a turn in,
I should update its UI.

00:19:18.240 --> 00:19:23.190
But notice that I'm not doing
anything here to immediately take

00:19:23.350 --> 00:19:28.220
the player into making their turn or
pull them into a particular match.

00:19:28.220 --> 00:19:33.300
Because this event could happen any time
and you want to allow the user to just

00:19:33.300 --> 00:19:35.750
keep doing what they were doing before.

00:19:35.760 --> 00:19:39.140
They can navigate back to the
view controller themselves to take

00:19:39.150 --> 00:19:40.970
their turn when they're ready.

00:19:42.810 --> 00:19:44.720
So let's recap taking turns.

00:19:44.850 --> 00:19:46.180
Some things to remember.

00:19:46.330 --> 00:19:48.790
First,
remember that only the current player,

00:19:49.090 --> 00:19:51.200
meaning the person whose
turn it is right now,

00:19:51.230 --> 00:19:55.250
only that player has the ability
to update the match data and they

00:19:55.280 --> 00:19:57.500
update it when they pass the turn.

00:19:57.500 --> 00:20:01.430
Everyone else can only retrieve
the current match data.

00:20:02.510 --> 00:20:06.600
Likewise, only the person whose turn it
is right now has the ability to

00:20:06.600 --> 00:20:08.460
pass the turn to the next player.

00:20:08.460 --> 00:20:12.510
Third, when you're passing the turn,
be aware that players might quit

00:20:12.510 --> 00:20:16.690
or might be eliminated and so on,
and you need to make sure you don't pass

00:20:16.850 --> 00:20:19.300
the turn to someone who has already quit.

00:20:19.560 --> 00:20:22.550
And finally,
understand that everybody in the

00:20:22.550 --> 00:20:26.800
match will receive turn events
every time anyone takes a turn,

00:20:26.800 --> 00:20:30.640
and you should just include
some unobtrusive UI to inform

00:20:30.640 --> 00:20:32.200
the player what's happening.

00:20:32.220 --> 00:20:33.570
happened.

00:20:34.740 --> 00:20:37.220
Next, I mentioned that players
can quit the match anytime.

00:20:37.400 --> 00:20:41.380
So let's talk more about
what you do to handle that.

00:20:42.000 --> 00:20:45.640
The scenario is that the player
is actively in a match but decides

00:20:45.740 --> 00:20:48.140
to resign before the game is over.

00:20:48.290 --> 00:20:52.420
They can do this from our view controller
or you might have some other UI in

00:20:52.420 --> 00:20:54.200
the game that allows them to quit.

00:20:54.440 --> 00:21:00.600
How you handle this depends on whether
they quit while it's their turn or if

00:21:00.600 --> 00:21:03.340
they quit while it's someone else's turn.

00:21:03.390 --> 00:21:08.270
If they quit while it's their turn,
your code needs to update the

00:21:08.280 --> 00:21:12.240
game state and set that player's
outcome and most importantly,

00:21:12.240 --> 00:21:15.700
it needs to tell
Game Center who should go next.

00:21:15.760 --> 00:21:18.430
Now, if it's not their turn,
it's much easier.

00:21:18.520 --> 00:21:22.330
You just tell Game Center that
they've quit and we handle the rest.

00:21:22.330 --> 00:21:24.340
So, let's see how this is done.

00:21:26.190 --> 00:21:29.630
Let's say it's this player's turn
right now and they've swiped a match

00:21:29.630 --> 00:21:31.620
in the view controller and quit.

00:21:31.800 --> 00:21:35.380
The view controller delegate method
turn-based matchmaker view controller

00:21:35.380 --> 00:21:39.090
player quit for match will be called,
passing the view controller

00:21:39.100 --> 00:21:40.640
and the match they've selected.

00:21:41.380 --> 00:21:44.920
Next, you'll update the game data
if it's appropriate to do so.

00:21:44.920 --> 00:21:48.320
You'll choose who goes next,
just as you normally would.

00:21:48.320 --> 00:21:51.590
And then you tell the match,
this participant quit in

00:21:51.750 --> 00:21:55.100
turn with outcome quit,
passing the next participant,

00:21:55.100 --> 00:21:58.130
the updated match data,
and a block that's called

00:21:58.140 --> 00:21:59.640
after this is sent.

00:21:59.900 --> 00:22:00.690
And that's it.

00:22:00.850 --> 00:22:05.060
Now, this player's quit and the turn
gets passed to the next person.

00:22:05.080 --> 00:22:08.520
And one quick side note,
this code is how you handle

00:22:08.520 --> 00:22:11.360
the player quitting in turn
from our view controller.

00:22:11.360 --> 00:22:15.380
But if you had your own UI to quit,
you would just call this same method,

00:22:15.380 --> 00:22:17.760
participant quit in turn with outcome.

00:22:19.660 --> 00:22:24.200
Likewise, if the player quits while
it's someone else's turn,

00:22:24.320 --> 00:22:26.470
the only thing we need to
do is inform Game Center.

00:22:26.900 --> 00:22:29.000
Now, if the player does it
from the view controller,

00:22:29.000 --> 00:22:30.240
we handle it internally.

00:22:30.240 --> 00:22:34.510
But if you have your own UI for
managing matches and want to allow this,

00:22:34.510 --> 00:22:38.210
then you just tell the match
participant quit out of turn with

00:22:38.210 --> 00:22:42.940
outcome quit and give a completion
handler block for when it's finished.

00:22:45.640 --> 00:22:47.740
All right,
we've discussed the view controller,

00:22:47.800 --> 00:22:52.940
selecting a match, taking turns,
receiving turn events, and resigning.

00:22:53.040 --> 00:22:57.310
And the next topic is how we end
the match when the game is over.

00:22:57.810 --> 00:23:00.360
So this is about when
a match ends naturally.

00:23:00.570 --> 00:23:03.080
The game is over because
of the rules of the game.

00:23:03.080 --> 00:23:05.660
In chess, for example, it's checkmate.

00:23:05.820 --> 00:23:08.570
So when a match ends,
we need to set an outcome

00:23:08.730 --> 00:23:10.320
for all the participants.

00:23:10.320 --> 00:23:11.980
And I've listed them here.

00:23:12.100 --> 00:23:16.290
That the player won, lost, tied,
or came in first place, second, third,

00:23:16.290 --> 00:23:17.580
fourth, and so on.

00:23:17.680 --> 00:23:20.530
Or if these outcomes aren't
the ones that you need,

00:23:20.660 --> 00:23:24.140
then there's 255 custom
outcomes that you can use.

00:23:24.230 --> 00:23:27.460
You'll also set an optional
message and then inform

00:23:27.460 --> 00:23:29.930
Game Center that the match has ended.

00:23:30.160 --> 00:23:33.010
A notification will then be sent
to all the other participants

00:23:33.570 --> 00:23:35.300
and the game will be over.

00:23:35.410 --> 00:23:40.380
Note, only the player whose turn it
is right now can end the match.

00:23:40.660 --> 00:23:42.090
So here's an example.

00:23:42.170 --> 00:23:45.600
I start out by setting the
outcome for each participant.

00:23:45.600 --> 00:23:47.140
In this case, everybody's tied.

00:23:47.140 --> 00:23:51.720
I update the match data with
the final state of the game and

00:23:51.760 --> 00:23:54.990
then set a message that will be
shown to all the other players.

00:23:54.990 --> 00:23:58.520
And then finally,
here's where I inform Game Center.

00:23:58.520 --> 00:24:03.340
I tell the match and match in turn
with match data and pass the final game

00:24:03.340 --> 00:24:06.040
state and a completion handler block.

00:24:06.400 --> 00:24:07.060
And that's it.

00:24:07.100 --> 00:24:08.230
The game is now over.

00:24:09.130 --> 00:24:12.170
On the other side,
what the other players receive

00:24:12.170 --> 00:24:15.610
is a notification that gets
handled by their event handler.

00:24:15.610 --> 00:24:19.390
So on their side,
the delegate method handle match

00:24:19.390 --> 00:24:22.850
ended gets called and they're
past the match that's just ended.

00:24:22.850 --> 00:24:27.340
And just like receiving a turn event,
what you'll do is very game dependent.

00:24:27.340 --> 00:24:29.950
In this case,
I'm just displaying a banner to

00:24:29.960 --> 00:24:31.990
inform the user the match has ended.

00:24:32.370 --> 00:24:35.810
And if the user happened to be
looking at the match when it ended,

00:24:35.940 --> 00:24:40.360
I'll download the final match data
and update the UI to show the outcome.

00:24:42.270 --> 00:24:43.200
That's almost everything.

00:24:43.200 --> 00:24:45.870
Just two loose ends I want to
mention before we're finished.

00:24:45.920 --> 00:24:51.680
The first is about handling being
launched from the Game Center app itself.

00:24:51.680 --> 00:24:55.420
So within the Game Center app,
the user can go look at

00:24:55.420 --> 00:24:58.360
one of their friends,
look at the games they have

00:24:58.360 --> 00:25:02.420
in common with that friend,
and if it's a turn-based game,

00:25:02.420 --> 00:25:05.850
they can start the invite
sequence and then press play.

00:25:05.880 --> 00:25:09.980
This launches your app to
actually send the invite.

00:25:10.700 --> 00:25:14.040
Now that's handled by the
GK turn-based event handler.

00:25:14.060 --> 00:25:19.020
There's a delegate method handle invite
from Game Center that gets called

00:25:19.020 --> 00:25:21.070
and it's passed an array of players.

00:25:21.100 --> 00:25:25.290
And what you're expected to do is
to create a match request with the

00:25:25.470 --> 00:25:29.400
players to invite property set to
this array that was passed to you.

00:25:29.400 --> 00:25:33.380
And then present the view controller
so the user can send the invite.

00:25:33.440 --> 00:25:36.460
Now this is something many
applications overlook,

00:25:36.490 --> 00:25:38.780
but it's important to
implement and handle correctly.

00:25:40.830 --> 00:25:44.030
The other loose end is about
customizing the view controller.

00:25:44.230 --> 00:25:48.300
You're able to replace our default
match list with your own UI.

00:25:48.510 --> 00:25:52.270
And the GK turn-based
match has a class method,

00:25:52.270 --> 00:25:54.620
load matches with completion handler.

00:25:54.790 --> 00:25:57.740
And that will give you an array
containing all the matches.

00:25:57.900 --> 00:26:00.120
And you can step through
these and display their data

00:26:00.120 --> 00:26:01.590
in your own custom interface.

00:26:01.660 --> 00:26:05.840
Now, if you do that,
then you need to decide how you're

00:26:05.840 --> 00:26:08.140
going to handle invites and matchmaking.

00:26:08.360 --> 00:26:11.870
Because invites can only be
sent from our built-in UI.

00:26:11.900 --> 00:26:17.020
So if you want to support invites,
you'll use the built-in UI,

00:26:17.200 --> 00:26:19.500
but tell it not to show the match list.

00:26:19.600 --> 00:26:20.750
You'll handle that yourself.

00:26:20.950 --> 00:26:25.580
If you don't want to support invites
and just want to do auto-matching,

00:26:25.770 --> 00:26:29.130
you can do that programmatically
using find match for request

00:26:29.280 --> 00:26:30.860
with completion handler.

00:26:31.910 --> 00:26:35.640
All right, so I've covered a lot,
all wrapped up in those four classes.

00:26:35.730 --> 00:26:40.040
The view controller handles invites
and matchmaking and lets a user select

00:26:40.040 --> 00:26:42.800
a match to play or quit from a match.

00:26:42.970 --> 00:26:46.680
The turn-based match is the main
class managing the state of the match,

00:26:46.770 --> 00:26:49.760
letting players take
turns and end the game.

00:26:49.870 --> 00:26:52.820
Each player is represented
by a turn-based participant,

00:26:52.910 --> 00:26:55.480
which you'll watch for status changes.

00:26:55.480 --> 00:26:59.450
And external events arrive through
the turn-based event handler.

00:26:59.550 --> 00:27:01.610
So if you have questions
about Game Center or the

00:27:01.740 --> 00:27:04.850
content I've presented here,
please contact me at

00:27:04.890 --> 00:27:06.860
ashaffe at apple.com.

00:27:06.940 --> 00:27:10.590
We also have some great documentation
available in the iOS Dev Center,

00:27:10.590 --> 00:27:13.130
and you can find me in the
developer forums as well.

00:27:13.240 --> 00:27:14.400
Thanks for watching.
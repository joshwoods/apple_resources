WEBVTT

00:00:21.390 --> 00:00:25.480
Hi, I'm Vicki Murley,
the Safari Technologies Evangelist.

00:00:25.560 --> 00:00:27.880
In this video,
you'll learn how to integrate web

00:00:27.880 --> 00:00:31.860
content into your native iPhone
application using UIWebView.

00:00:32.060 --> 00:00:35.640
And I'll show you how to optimize
that web content to fine-tune

00:00:35.640 --> 00:00:38.740
your web-based animations,
improve responsiveness,

00:00:38.930 --> 00:00:42.080
and reduce the total memory
footprint for your application.

00:00:42.190 --> 00:00:44.210
So let's get started.

00:00:44.900 --> 00:00:48.600
So we're talking today about how
to integrate web content into

00:00:48.600 --> 00:00:51.100
a native iPhone application.

00:00:51.150 --> 00:00:54.680
Many people call this type of
application a hybrid application,

00:00:54.730 --> 00:00:59.920
one that combines native APIs from
the iPhone SDK with HTML,

00:00:59.920 --> 00:01:02.140
CSS, and JavaScript.

00:01:03.810 --> 00:01:07.500
So there are quite a few advantages
to developing a hybrid application.

00:01:07.650 --> 00:01:11.700
And the first comes if web is
sort of your primary business.

00:01:11.870 --> 00:01:17.120
If you are an Amazon.com, a Fandango.com,
or a Yelp.com,

00:01:17.160 --> 00:01:20.200
you can leverage the existing
assets that you use to develop your

00:01:20.200 --> 00:01:22.110
website in your iPhone application.

00:01:22.370 --> 00:01:27.130
And by assets, I mean the code that you
use for your website,

00:01:27.130 --> 00:01:30.320
the images,
and also the skills that people

00:01:30.320 --> 00:01:31.470
have used to develop your website.

00:01:32.490 --> 00:01:34.860
With a hybrid application,
you can also update the

00:01:34.860 --> 00:01:36.400
user interface remotely.

00:01:36.560 --> 00:01:39.630
The iTunes Music Store is
a great example of this.

00:01:39.930 --> 00:01:43.980
The iTunes Music Store uses WebKit,
and we update the user interface here

00:01:44.080 --> 00:01:49.110
multiple times each day without having
to ship a new version of iTunes.

00:01:49.270 --> 00:01:51.520
GarageBand is another example of this.

00:01:51.520 --> 00:01:55.160
We sell these lessons in
line in the application,

00:01:55.160 --> 00:01:58.190
again updating the content remotely.

00:01:59.270 --> 00:02:02.650
The final advantage of a hybrid
application is being able to list

00:02:02.650 --> 00:02:04.600
your application on the App Store.

00:02:04.750 --> 00:02:06.920
You may have a great web
application out there,

00:02:07.190 --> 00:02:11.340
but currently the App Store is
native iPhone SDK applications only.

00:02:11.490 --> 00:02:14.900
So if you want to list your
application on the App Store,

00:02:14.900 --> 00:02:17.140
you have to move to a native app.

00:02:17.530 --> 00:02:21.760
So the primary class that hybrid
applications are built around

00:02:21.760 --> 00:02:23.900
on iPhone SDK is UIWebView.

00:02:23.970 --> 00:02:28.370
Now UIWebView is just a simple class
intended to display web content.

00:02:28.390 --> 00:02:33.380
I want to take this opportunity to point
out that UIWebView and Safari on iPhone

00:02:33.840 --> 00:02:35.250
are not designed to be equivalent.

00:02:35.400 --> 00:02:40.510
While UIWebView is a simple class,
Safari on iPhone is an application that

00:02:40.510 --> 00:02:44.680
includes a lot of extra functionality
to handle multiple windows,

00:02:45.020 --> 00:02:48.400
multiple tabs, authentication, etc.

00:02:48.420 --> 00:02:52.020
So these two are not
designed to be equal.

00:02:53.460 --> 00:02:55.750
For today's discussion,
we're going to split our

00:02:55.750 --> 00:02:57.580
lecture into two parts.

00:02:57.670 --> 00:03:01.850
For the first part of the talk,
we're going to focus on how to use

00:03:01.850 --> 00:03:04.390
UIWebView within the iPhone SDK.

00:03:04.460 --> 00:03:12.320
Since it's a relatively small
class with not a lot of methods,

00:03:12.320 --> 00:03:13.680
I'm going to cover some of the most
commonly asked questions about UIWebView.

00:03:14.080 --> 00:03:16.850
For the second half of the talk,
we're going to talk about

00:03:16.850 --> 00:03:20.780
the content inside the view,
namely how to optimize that

00:03:20.820 --> 00:03:26.280
content for a reduced memory
footprint and optimal performance.

00:03:26.360 --> 00:03:30.450
So let's get started addressing some
of the most commonly asked questions

00:03:30.450 --> 00:03:33.900
about UIWebView in the iPhone SDK.

00:03:35.580 --> 00:03:40.390
So the first most commonly asked question
I hear about UIWebView is how to load

00:03:40.390 --> 00:03:43.540
resources from the application bundle.

00:03:43.590 --> 00:03:47.100
We all know that you can
load a URL into UIWebView,

00:03:47.160 --> 00:03:50.920
but sometimes you want to load a
file locally to avoid having to

00:03:51.090 --> 00:03:53.700
fetch resources over the network.

00:03:53.810 --> 00:03:56.040
So this is really easy to do.

00:03:56.130 --> 00:04:00.670
Basically, in the load view method,
you just want to create a path based

00:04:00.670 --> 00:04:03.220
off the main bundle of NSBundle.

00:04:03.260 --> 00:04:08.900
And here I'm looking for a file
named index with the extension HTML.

00:04:09.380 --> 00:04:15.760
We're going to create an NSData object
with the contents of that file path.

00:04:15.910 --> 00:04:18.420
And then finally,
we're going to load that

00:04:18.420 --> 00:04:21.190
data into the WebView,
and here we have a

00:04:21.190 --> 00:04:23.500
MIME type of text HTML set.

00:04:23.520 --> 00:04:27.970
The encoding is UTF-8,
and we've set a base URL that

00:04:27.970 --> 00:04:30.680
is equal to our initial path.

00:04:31.320 --> 00:04:36.630
This base URL is very important to
ensure that any locally stored images

00:04:36.720 --> 00:04:43.420
or other resources also load along
with your local index.html file.

00:04:46.790 --> 00:04:51.830
So we just talked about how to load
a local index.html file from our

00:04:51.910 --> 00:04:55.300
application bundle into UIWebView.

00:04:55.360 --> 00:04:59.880
But you can actually load a mixture
of local and remote resources.

00:04:59.980 --> 00:05:05.300
So for example, you could use local or
remote images in local HTML,

00:05:05.300 --> 00:05:07.120
CSS, and JavaScript.

00:05:07.150 --> 00:05:12.790
Just use either a relative URL to
reference local images or a absolute

00:05:12.790 --> 00:05:15.810
URL to reference remote images.

00:05:16.270 --> 00:05:21.800
However, you can only use remote
images from remote HTML,

00:05:21.800 --> 00:05:23.700
CSS, and JavaScript.

00:05:23.760 --> 00:05:26.870
In other words,
remote resources cannot load

00:05:26.870 --> 00:05:29.200
files from the application bundle.

00:05:29.400 --> 00:05:31.200
So here's an example.

00:05:31.290 --> 00:05:35.640
I've loaded my index.html file,
and that file links to

00:05:35.640 --> 00:05:39.120
this external style sheet,
main.css.

00:05:39.250 --> 00:05:43.200
And in main.css,
I have a style declaration

00:05:43.200 --> 00:05:45.200
for a title box.

00:05:45.200 --> 00:05:49.450
In this declaration,
I'm referencing an image here,

00:05:49.450 --> 00:05:51.010
background.jpg.

00:05:51.260 --> 00:05:56.260
Now since main.css is a remote file,
background.jpg has to be

00:05:56.260 --> 00:05:58.780
stored on the remote server.

00:05:58.970 --> 00:06:04.410
What if I want to load background.jpg
from the application bundle?

00:06:04.710 --> 00:06:10.390
Well, this is possible if I move the
background image style into an

00:06:10.390 --> 00:06:14.040
inline style in my index.html file.

00:06:14.100 --> 00:06:18.080
I can leave the height, width,
and border properties in the remote file,

00:06:18.250 --> 00:06:21.680
but by moving the background
image property to a local

00:06:21.740 --> 00:06:25.830
inline style within my HTML,
this background.jpg will now

00:06:25.830 --> 00:06:28.340
load from the application bundle.

00:06:31.280 --> 00:06:34.170
The second set of questions
that I commonly hear about

00:06:34.170 --> 00:06:37.060
UIWebView center around memory use.

00:06:37.280 --> 00:06:41.320
The first is, how can I decrease overall
memory usage in my hybrid

00:06:41.320 --> 00:06:43.720
application that uses UIWebView?

00:06:43.870 --> 00:06:47.360
The first thing that you can do is
a design decision made up front,

00:06:47.390 --> 00:06:51.710
and that's minimizing the
total number of UIWebViews.

00:06:51.870 --> 00:06:55.300
Instead of having multiple
UIWebViews on a screen,

00:06:55.350 --> 00:06:59.930
you can have a single UIWebView and
then use XMLHttpRequest to

00:06:59.930 --> 00:07:02.620
update parts of that page.

00:07:03.190 --> 00:07:07.680
Another technique is to build views
off-screen and then animate them in.

00:07:07.810 --> 00:07:12.450
We see this everywhere on iPhone and
many popular applications where a panel

00:07:12.450 --> 00:07:15.120
slides in to replace the current panel.

00:07:15.340 --> 00:07:19.340
You can use the same technique
in your web code to minimize

00:07:19.340 --> 00:07:22.040
the total number of UIWebViews.

00:07:22.690 --> 00:07:26.050
Dashcode has some really great
built-in templates if you're

00:07:26.130 --> 00:07:28.900
looking to explore this technique.

00:07:30.930 --> 00:07:35.220
The next memory-centric question that
I typically hear is what can I do

00:07:35.220 --> 00:07:37.780
when I get a low memory notification?

00:07:37.880 --> 00:07:41.020
So as you may have noticed,
UI WebView does not have any

00:07:41.020 --> 00:07:45.740
methods that enable sort of
fine-grained cache control.

00:07:45.740 --> 00:07:49.530
But there is one thing that you
can do in your web code when you

00:07:49.530 --> 00:07:52.880
get a low memory notification,
and that is set your

00:07:52.880 --> 00:07:55.360
JavaScript objects to null.

00:07:55.450 --> 00:07:58.440
Of course, structure your code so that
these can be reinitialized,

00:07:58.440 --> 00:08:01.470
and what's going to happen
when you do this is the garbage

00:08:01.530 --> 00:08:05.540
collector will come along,
clean up all of these nulled objects,

00:08:05.710 --> 00:08:08.190
and free up some memory
for your application.

00:08:13.200 --> 00:08:16.820
question that I commonly
hear about UI WebView is what

00:08:16.820 --> 00:08:18.700
to do about authentication.

00:08:18.740 --> 00:08:23.200
So there's two ways to handle
authentication scenarios.

00:08:23.370 --> 00:08:28.250
The first is to embed the authorization
information in the URL that you

00:08:28.250 --> 00:08:30.680
fetch and load into the UI WebView.

00:08:30.950 --> 00:08:32.940
And here we're loading a URL.

00:08:32.940 --> 00:08:34.840
It has an HTTPS prefix.

00:08:34.970 --> 00:08:39.540
We're setting a username and a
password separated by a colon,

00:08:39.890 --> 00:08:44.750
and we're loading the web
page myprotectedsite.com.

00:08:45.010 --> 00:08:51.780
So this will just load the web page
into the UIWebView without prompting

00:08:51.780 --> 00:08:53.500
the user for any credentials.

00:08:55.800 --> 00:08:58.940
If you do want to present
a UI for authentication,

00:08:59.070 --> 00:09:02.720
what you're going to do is
open a separate URL connection

00:09:02.720 --> 00:09:04.340
using the NSURL APIs.

00:09:04.540 --> 00:09:09.580
This is separate from the load that
you would do into the UIWebView.

00:09:09.860 --> 00:09:14.690
When your delegate is notified
"Connection did receive authentication

00:09:14.690 --> 00:09:18.340
challenge," you're going to
store the credentials using

00:09:18.660 --> 00:09:21.800
NSURLCredential Persistence for Session.

00:09:21.800 --> 00:09:25.300
And this is going to store
your credentials for the

00:09:25.380 --> 00:09:27.780
lifetime of your application.

00:09:29.390 --> 00:09:33.500
So the next set of questions
focuses on cross-code communication,

00:09:33.540 --> 00:09:38.350
namely how to execute JavaScript from
Objective-C and how to execute

00:09:38.350 --> 00:09:40.500
Objective-C from JavaScript.

00:09:40.600 --> 00:09:42.500
So let's take a look
at the first direction,

00:09:42.550 --> 00:09:45.870
executing JavaScript from Objective-C.

00:09:46.280 --> 00:09:47.880
This is really simple to do.

00:09:48.010 --> 00:09:50.970
It's just a method on UIWebView,
string by evaluating

00:09:50.970 --> 00:09:52.470
JavaScript from string.

00:09:52.750 --> 00:09:57.100
And here I'm passing in a function name,
myJSFunction.

00:09:57.520 --> 00:10:00.670
This is actually a great best
practice to pass in a function

00:10:00.670 --> 00:10:06.200
name instead of a very long,
hard-to-maintain string of JavaScript.

00:10:06.310 --> 00:10:10.710
Also, you should always put your
JavaScript in a separate file.

00:10:10.890 --> 00:10:14.800
Now when you're doing that,
make sure that the JavaScript files

00:10:14.800 --> 00:10:18.000
in your application are copied,
not compiled.

00:10:18.110 --> 00:10:22.200
This is just a matter of taking a look
at your application target and dragging

00:10:22.200 --> 00:10:29.030
the appropriate resources from compile
sources up to copy bundle resources.

00:10:30.300 --> 00:10:34.700
Lastly, don't try to execute
JavaScript before the view has loaded.

00:10:34.830 --> 00:10:38.580
Your delegate will receive a
callback once the view has loaded

00:10:38.610 --> 00:10:43.190
and it's safe to execute JavaScript,
"WebView did finish load."

00:10:45.860 --> 00:10:50.300
The next scenario involves executing
Objective-C from JavaScript,

00:10:50.360 --> 00:10:55.710
essentially hooking into native
functionality from a web user interface.

00:10:55.930 --> 00:10:58.450
Now there's a couple
parts of this scenario.

00:10:58.680 --> 00:11:02.730
You basically want to use
JavaScript to change the current

00:11:02.730 --> 00:11:07.130
location to a custom URL,
use a delegate method to intercept the

00:11:07.250 --> 00:11:11.820
page request and execute native code,
and then finally return no

00:11:11.830 --> 00:11:14.360
to abandon the page request.

00:11:14.390 --> 00:11:17.430
So let's take a look
at this in more detail.

00:11:18.280 --> 00:11:21.760
The first step is to define
a sort of custom URL,

00:11:21.960 --> 00:11:27.990
and here the URL is
http://vicki.com/capturephoto.

00:11:30.090 --> 00:11:34.480
The next step is to use
JavaScript to initiate a page load.

00:11:34.620 --> 00:11:38.490
Here in our Capture Photo function,
we're setting window.location

00:11:38.660 --> 00:11:43.310
to our custom URL,
vickizap/capturephoto.

00:11:46.200 --> 00:11:49.580
The final piece comes with
the UIWebView delegate should

00:11:49.580 --> 00:11:51.340
start load with request.

00:11:51.480 --> 00:11:53.890
In this method,
we're going to look at the

00:11:54.000 --> 00:11:58.340
request that has been passed in,
and if host is equal to our string

00:11:58.400 --> 00:12:03.740
"vickeysApp", we're going to look at the
last path component for that request,

00:12:03.860 --> 00:12:09.050
and if it's equal to capturePhoto,
I'm going to execute native code to

00:12:09.280 --> 00:12:12.530
initiate that sequence capturing a photo.

00:12:12.750 --> 00:12:15.440
And then finally,
we're going to return no from this

00:12:15.440 --> 00:12:19.640
method because we don't want to
actually load anything from this method.

00:12:23.030 --> 00:12:25.220
So that covers the
first half of our talk:

00:12:25.380 --> 00:12:29.940
Integrating Web Content into
Your Hybrid Application Using UIWebView

00:12:29.940 --> 00:12:31.140
in the iPhone SDK.

00:12:32.940 --> 00:12:35.200
Now let's move on to the
second part of our talk,

00:12:35.260 --> 00:12:39.040
optimizing the web content
inside of that view.

00:12:41.180 --> 00:12:43.860
So in this section,
we're primarily going to focus on

00:12:43.970 --> 00:12:48.340
how to decrease memory footprint
and increase performance of the

00:12:48.340 --> 00:12:51.590
web content inside of UIWebView.

00:12:51.690 --> 00:12:54.740
To do that,
we're going to focus on three areas:

00:12:54.840 --> 00:12:59.740
reducing the total number of images,
using CSS transforms, transitions,

00:12:59.860 --> 00:13:03.100
and animations, and finally,
we're going to talk about

00:13:03.100 --> 00:13:08.170
caching data locally to improve
responsiveness in your application.

00:13:08.700 --> 00:13:11.610
So let's get started talking
about how to decrease the memory

00:13:11.610 --> 00:13:17.040
footprint in your application by
reducing the total number of images.

00:13:19.200 --> 00:13:22.920
So you might be thinking,
what's so bad about images in an

00:13:22.920 --> 00:13:25.840
iPhone application that uses UIWebView?

00:13:25.840 --> 00:13:31.160
Well, if we look at this image here,
we can see that its size on disk is 53K.

00:13:31.230 --> 00:13:34.370
But that's actually the
encoded size on disk.

00:13:34.380 --> 00:13:37.830
Once this image is decoded
and loaded into memory,

00:13:37.830 --> 00:13:39.540
it becomes much bigger.

00:13:39.570 --> 00:13:44.890
If we take the height, which is 320,
by the width, which is 480,

00:13:44.890 --> 00:13:49.060
multiply it by 4 because this
image has RGB components,

00:13:49.100 --> 00:13:53.090
this image is now taking
up over 600K in memory.

00:13:53.100 --> 00:13:55.070
So this is pretty significant.

00:13:55.110 --> 00:13:59.550
Anything that we can do to reduce
the total number of images in our

00:13:59.580 --> 00:14:05.240
hybrid application is going to
reduce the overall memory footprint.

00:14:07.560 --> 00:14:12.700
So one way to cut back on images
in your web interfaces is to use

00:14:12.700 --> 00:14:15.500
what's called a generated image.

00:14:15.570 --> 00:14:20.560
A generated image is one where
you specify the appearance in CSS,

00:14:20.560 --> 00:14:22.950
and then WebKit,
the framework that does all

00:14:22.950 --> 00:14:27.170
the layout and rendering for
Safari on iPhone and for UIWebView,

00:14:27.340 --> 00:14:28.710
generates an image for you.

00:14:28.840 --> 00:14:32.580
The result is seamlessly
displayed in the web page,

00:14:32.580 --> 00:14:36.510
and by that I mean no additional
elements are added to the DOM,

00:14:36.750 --> 00:14:40.480
and the computed style
is what you would expect.

00:14:42.100 --> 00:14:47.350
So the first type of generated image that
I'd like to describe is a CSS gradient.

00:14:47.470 --> 00:14:53.260
So we see gradients in multiple places
both on web pages and in user interfaces

00:14:53.390 --> 00:14:55.740
in native applications on iPhone.

00:14:55.870 --> 00:15:01.040
So here on the left we have the main web
page for the WebKit open source project,

00:15:01.070 --> 00:15:04.120
and there's a gradient
background on this page.

00:15:04.170 --> 00:15:07.160
And on the right we have
the stopwatch application.

00:15:07.180 --> 00:15:10.020
And you can see gradients
on each of the buttons,

00:15:10.170 --> 00:15:13.890
on each of the rows,
and on the main background

00:15:13.890 --> 00:15:16.300
area that shows the time.

00:15:17.820 --> 00:15:20.430
So to achieve a gradient
in a web interface,

00:15:20.610 --> 00:15:24.150
what people typically do is
use the background property,

00:15:24.230 --> 00:15:27.810
specify a background image,
and then repeat it in the

00:15:27.870 --> 00:15:32.350
X direction to achieve a tiling
effect across the background.

00:15:33.720 --> 00:15:38.840
If we use a CSS gradient instead,
the syntax looks like this.

00:15:38.990 --> 00:15:41.830
We set the background
to a WebKit gradient.

00:15:41.960 --> 00:15:45.210
The first parameter is the
type of gradient that this is.

00:15:45.220 --> 00:15:49.470
We can have either a linear
or a radial gradient.

00:15:49.710 --> 00:15:54.040
The next two parameters specify where
the gradient begins and where it ends.

00:15:54.320 --> 00:15:58.300
So this gradient begins in the
upper left-hand corner and goes

00:15:58.300 --> 00:16:03.540
down about 45% down the page,
almost halfway down the page.

00:16:03.660 --> 00:16:06.900
And the last two parameters
tell us what color values we

00:16:06.900 --> 00:16:09.580
interpolate between for the gradient.

00:16:09.720 --> 00:16:13.450
So here we're starting with a
kind of green color and we're

00:16:13.450 --> 00:16:15.960
fading our gradient out to white.

00:16:16.390 --> 00:16:20.740
So here we've eliminated an
image in our web interface that

00:16:20.740 --> 00:16:23.530
we're loading into UIWebView.

00:16:25.950 --> 00:16:29.040
Here's one more example
of a radial gradient.

00:16:29.040 --> 00:16:33.810
We see radial gradients in lots of
places in native iPhone applications.

00:16:33.960 --> 00:16:37.140
So here on the startup screen
for E-Trade Mobile Pro,

00:16:37.140 --> 00:16:39.620
we have this sort of spotlight effect.

00:16:39.680 --> 00:16:44.610
And also for the Things application,
when items move to the logbook,

00:16:44.610 --> 00:16:49.410
we see a similar spotlight effect
behind the prompt that comes up.

00:16:49.530 --> 00:16:55.400
So now you can achieve the same sort of
effects in your web-based interfaces.

00:16:56.640 --> 00:17:00.570
So you might be thinking, well,
just one small background

00:17:00.580 --> 00:17:04.320
image on a gradient,
you know, how much can that really reduce

00:17:04.320 --> 00:17:06.100
my overall memory footprint?

00:17:06.260 --> 00:17:09.580
Well, CSS gradients can actually be
used in a number of places.

00:17:09.860 --> 00:17:15.240
They can be used for background images,
border images, list style images,

00:17:15.380 --> 00:17:18.760
for the content property,
and as you're going to see

00:17:18.830 --> 00:17:23.300
over the next few slides,
CSS gradients can be used in conjunction

00:17:23.300 --> 00:17:26.130
with many other types of CSS effects.

00:17:26.920 --> 00:17:28.610
So one more note about gradients.

00:17:28.810 --> 00:17:32.960
Sometimes it can be difficult to imagine
exactly what a gradient is going to

00:17:32.960 --> 00:17:36.730
look like just by writing the code,
and sometimes the syntax can

00:17:36.910 --> 00:17:38.760
be difficult to remember.

00:17:38.890 --> 00:17:43.270
There's a great GUI tool online
at wessiv.com that you can use

00:17:43.270 --> 00:17:47.790
to configure your gradients
and generate the code for you.

00:17:49.450 --> 00:17:54.180
The next type of generated image that
I want to describe is a CSS mask.

00:17:54.320 --> 00:17:58.530
Now, a mask allows you to overlay
the content with a pattern,

00:17:58.840 --> 00:18:02.510
and then basically that content
is only going to show through

00:18:02.510 --> 00:18:04.800
the opaque parts of that pattern.

00:18:04.960 --> 00:18:08.890
So here I have this flower image,
and I could overlay it with a

00:18:09.000 --> 00:18:11.100
pattern of an opaque circle.

00:18:11.260 --> 00:18:14.800
And once that content is masked,
it's going to look like this.

00:18:14.880 --> 00:18:18.760
The flower image is only going to show
through the opaque parts of the circle.

00:18:20.820 --> 00:18:25.590
CSS masks have quite an involved syntax,
but the basic idea is that

00:18:25.930 --> 00:18:30.950
CSS mask properties are analogous
to CSS background properties.

00:18:31.090 --> 00:18:35.940
So where you have a background origin,
you could also have a WebKit mask origin.

00:18:36.270 --> 00:18:41.300
Where you have a background image,
you could also have a WebKit mask image.

00:18:42.080 --> 00:18:46.960
So let's take a look at some specific
syntax for our earlier example.

00:18:47.100 --> 00:18:50.680
To add a mask to this
image programmatically,

00:18:50.800 --> 00:18:54.600
we would just specify WebKitMaskBoxImage.

00:18:54.650 --> 00:18:59.680
We have a URL that points
to our circleMask.png,

00:18:59.800 --> 00:19:02.500
and then we have an X and
Y coordinate that tells us

00:19:02.590 --> 00:19:04.500
how to position that circle.

00:19:04.620 --> 00:19:08.110
And that's going to give
us an effect such as this.

00:19:09.150 --> 00:19:13.990
Now this section is all about reducing
images in your web content within

00:19:13.990 --> 00:19:19.570
UIWebView for your iPhone application,
but here we're still using an image,

00:19:19.670 --> 00:19:21.220
circleMask.png.

00:19:21.360 --> 00:19:25.240
Well we can eliminate that
image in one of two ways.

00:19:25.570 --> 00:19:29.080
We can either use a
WebKit gradient as our mask image,

00:19:29.320 --> 00:19:32.710
or we can use an SVG image.

00:19:36.100 --> 00:19:40.330
The last type of generated
image is a CSS reflection.

00:19:40.480 --> 00:19:42.930
And of course,
a reflection is just a replica

00:19:42.930 --> 00:19:46.880
of the original object with its
own specific transform and mask.

00:19:49.810 --> 00:19:54.960
A CSS reflection is specified through
the WebKit box reflect property.

00:19:55.150 --> 00:19:58.200
The first parameter is the
direction of the reflection,

00:19:58.240 --> 00:20:02.620
the second parameter is an offset,
and the third parameter is optional.

00:20:02.670 --> 00:20:05.240
It's the mask box image.

00:20:05.330 --> 00:20:09.750
So if we wanted to reflect this
image of the bumblebee below the

00:20:09.750 --> 00:20:15.180
image and offset by 5 pixels,
we would just specify WebKit box

00:20:15.180 --> 00:20:17.890
reflect below 5 pixels.

00:20:18.270 --> 00:20:22.210
Now what we have here is a full
reflection of the original image.

00:20:22.210 --> 00:20:25.240
And when people typically
add reflection to an object,

00:20:25.420 --> 00:20:29.650
they want it to kind of fade
out to the background color,

00:20:29.740 --> 00:20:32.040
or fade out in transparency.

00:20:32.140 --> 00:20:36.200
So to do that, we're going to use that
last optional parameter,

00:20:36.200 --> 00:20:37.960
WebKit Mask Box Image.

00:20:38.070 --> 00:20:41.880
And for that parameter,
we're going to specify a gradient.

00:20:41.980 --> 00:20:45.720
So here we have
WebKit Box Reflect below 5 pixels.

00:20:45.820 --> 00:20:48.160
And then our final
parameter is a gradient,

00:20:48.300 --> 00:20:51.090
a linear gradient,
that goes from the left

00:20:51.090 --> 00:20:52.760
top to the left bottom.

00:20:52.850 --> 00:20:56.590
And we fade from transparent to white.

00:20:57.070 --> 00:21:01.770
So since this gradient is reflected,
it's going to be flipped and then applied

00:21:01.910 --> 00:21:06.900
to the reflection to give you exactly
the effect that you're looking for.

00:21:08.970 --> 00:21:13.390
So let's take a look at the real-world
impact of using generated images instead

00:21:13.430 --> 00:21:16.400
of static images in our application.

00:21:16.480 --> 00:21:19.540
So let's say I have a
slideshow application,

00:21:19.540 --> 00:21:23.080
and in one mode I show this
sort of grid of images,

00:21:23.080 --> 00:21:27.770
but in the slideshow mode I want
to show an image with a reflection.

00:21:27.960 --> 00:21:34.020
One option is to create each image
with a reflection in an image editor,

00:21:34.020 --> 00:21:37.590
and another is to use CSS Reflections.

00:21:39.460 --> 00:21:42.370
Now if I have a grid
of let's say 12 images,

00:21:42.370 --> 00:21:45.530
I did this test myself
in a real world scenario,

00:21:45.530 --> 00:21:49.520
and if I generated an additional
image in an image editor that showed

00:21:49.520 --> 00:21:54.350
a reflection for a slideshow mode,
each additional image generated

00:21:54.380 --> 00:21:57.950
about 300K of additional memory.

00:21:58.230 --> 00:22:03.100
So if I eliminate those extra images
and use CSS Reflections instead,

00:22:03.190 --> 00:22:08.400
that will save over 3.5 megabytes
in my application memory footprint.

00:22:08.690 --> 00:22:11.680
So another place where people
typically use an image when they

00:22:11.680 --> 00:22:14.240
don't have to is for drawing buttons.

00:22:14.300 --> 00:22:17.930
Let's take a look at what
it takes to build a really

00:22:17.930 --> 00:22:20.310
great button in HTML and CSS.

00:22:20.750 --> 00:22:23.500
There are two classes of
CSS properties that we're going to

00:22:23.500 --> 00:22:25.900
look at for building this button.

00:22:26.060 --> 00:22:31.320
The first has to do with appearance,
and the second deals with behavior.

00:22:32.490 --> 00:22:35.310
So I decided that the button
that I wanted to create today

00:22:35.610 --> 00:22:38.760
was this Delete Note button
inside the Notes application.

00:22:39.080 --> 00:22:42.660
And this is just a screenshot
of that application with the

00:22:42.770 --> 00:22:44.870
Delete Note button showing.

00:22:45.750 --> 00:22:49.930
I started out by mocking this
up inside of Safari on iPhone.

00:22:50.030 --> 00:22:53.180
And I started with all of the
CSS properties that you would

00:22:53.220 --> 00:22:55.430
typically associate with a button.

00:22:55.570 --> 00:22:57.500
We have the color and
the background color,

00:22:57.500 --> 00:23:00.860
which is red,
a border and a border color.

00:23:01.040 --> 00:23:02.930
We have the button sizing.

00:23:02.930 --> 00:23:07.260
We've centered the text both
horizontally and vertically.

00:23:07.460 --> 00:23:09.650
And also we've set some
text attributes here.

00:23:09.810 --> 00:23:13.700
The font size, the font family on
iPhone is Helvetica Noi,

00:23:13.760 --> 00:23:16.290
and the font weight is bold.

00:23:18.200 --> 00:23:22.780
So how do we take this button from a
plain looking button to a button that

00:23:22.780 --> 00:23:26.090
looks really great and native on iPhone?

00:23:26.330 --> 00:23:29.830
The first thing that we're going to do
is round the corners on this button.

00:23:29.850 --> 00:23:34.200
And we do that using a CSS property,
WebKitBorderRadius.

00:23:34.470 --> 00:23:38.400
Here we're specifying a border
radius of 10 pixels to round

00:23:38.630 --> 00:23:40.400
the corners on our button.

00:23:41.630 --> 00:23:44.260
The next two properties
have to do with shadow.

00:23:44.380 --> 00:23:46.950
These are a little bit subtle,
but if you look closely,

00:23:47.150 --> 00:23:50.600
you can see a slight shadow
behind the text on the button,

00:23:50.780 --> 00:23:55.700
and then also you see a gray
shadow beneath the button.

00:23:55.910 --> 00:23:58.240
So the first shadow,
the one beneath the button,

00:23:58.290 --> 00:24:00.800
is specified with WebKit box shadow.

00:24:00.870 --> 00:24:04.200
The first two parameters
are an X and Y offset.

00:24:04.260 --> 00:24:07.910
We want this shadow offset zero
pixels in the X direction and

00:24:07.980 --> 00:24:10.000
two pixels in the Y direction.

00:24:10.140 --> 00:24:13.590
And we want the color of this
shadow to be a solid gray.

00:24:13.690 --> 00:24:18.190
So that gives us that kind of
gray line beneath the button.

00:24:19.010 --> 00:24:22.900
To add the shading behind the text,
we use the text shadow property.

00:24:23.040 --> 00:24:26.130
Again, the first two parameters
are an X and Y offset,

00:24:26.340 --> 00:24:29.980
and I've set both of those to zero
here because I want just a general

00:24:29.980 --> 00:24:31.900
shadow behind all of the text.

00:24:31.900 --> 00:24:36.680
I'm setting a blur radius of 8 pixels,
and I'm setting the color of

00:24:36.740 --> 00:24:38.860
this text shadow to black.

00:24:42.100 --> 00:24:45.380
The last step is to add a
gradient to this button.

00:24:45.470 --> 00:24:50.520
So here we're specifying a white
gradient that changes transparency as

00:24:50.520 --> 00:24:54.880
it interpolates from the top of the
button down to the bottom of the button.

00:24:54.980 --> 00:25:00.100
So this is a linear gradient that
travels the height of the button,

00:25:00.100 --> 00:25:05.390
and it goes from 50%
transparency to 30% transparency,

00:25:05.390 --> 00:25:09.960
and then from full transparency
to 20% transparency.

00:25:10.050 --> 00:25:14.170
So this gives us a white overlay
on the button that allows the red

00:25:14.220 --> 00:25:16.490
color beneath to show through.

00:25:18.810 --> 00:25:20.400
And this is the final result.

00:25:20.490 --> 00:25:23.210
Again, mocked up in Safari on iPhone.

00:25:24.920 --> 00:25:28.330
So this is a really great looking button,
but we also want it to behave

00:25:28.410 --> 00:25:31.130
like a button on iPhone.

00:25:31.170 --> 00:25:34.140
To do that, we're going to set a few
additional properties.

00:25:34.220 --> 00:25:36.810
If you touch this button,
the first thing that you're

00:25:36.810 --> 00:25:40.100
going to see is this sort of
background color on the text.

00:25:40.200 --> 00:25:41.750
And we want to get rid of that.

00:25:42.060 --> 00:25:47.100
And we can do that by setting WebKit tap
highlight color to transparent.

00:25:47.170 --> 00:25:52.410
That will make that gray background
color around the text disappear.

00:25:52.880 --> 00:25:56.450
The next thing that you'll see if
you continue touching and holding on

00:25:56.450 --> 00:25:59.690
this button is the open copy panel.

00:25:59.830 --> 00:26:02.520
And we want to disable this as well.

00:26:02.590 --> 00:26:06.810
So we're going to set
WebKit touch call out to none.

00:26:07.490 --> 00:26:10.680
Once you disable the touch callout,
the last thing that you're going

00:26:10.680 --> 00:26:12.470
to see is the copy/paste bubble.

00:26:12.800 --> 00:26:14.970
And we want to disable that
for our button as well,

00:26:15.070 --> 00:26:19.060
because we don't want people to be able
to copy the text off of this button.

00:26:19.230 --> 00:26:22.150
To do that,
we're going to set WebKit user

00:26:22.410 --> 00:26:26.590
select to none to disable
the cut/copy/paste dialog.

00:26:27.640 --> 00:26:30.310
The last thing that we want to
do to this button is give it

00:26:30.390 --> 00:26:32.600
an enabled and disabled state.

00:26:32.630 --> 00:26:34.980
Typically,
when you touch a button on iPhone,

00:26:35.020 --> 00:26:36.400
they change color.

00:26:36.440 --> 00:26:38.700
So here,
we're going to listen for two events,

00:26:38.990 --> 00:26:44.260
onTouchStart and onTouchEnd,
and we're going to call two functions,

00:26:44.270 --> 00:26:47.180
enable or disable, for the button.

00:26:48.090 --> 00:26:51.160
The enable and disable
functions are really simple.

00:26:51.330 --> 00:26:54.160
We're just going to change the
background color of the button

00:26:54.200 --> 00:26:56.600
when those functions are called.

00:26:56.690 --> 00:26:59.430
So here I'm setting the background
color to blue so that you can

00:26:59.430 --> 00:27:01.600
see the difference very clearly.

00:27:01.680 --> 00:27:04.840
So when I touch this button,
it's going to look like this.

00:27:04.900 --> 00:27:07.180
And when I lift my
finger off this button,

00:27:07.260 --> 00:27:09.950
the color will return to red.

00:27:12.300 --> 00:27:16.230
So what's the real-world impact
of getting rid of images for

00:27:16.230 --> 00:27:20.960
your buttons and replacing
them with CSS-based buttons?

00:27:21.090 --> 00:27:25.100
Well, I did some measurements,
and if I had 10 buttons

00:27:25.100 --> 00:27:28.180
in my application,
and I had two versions

00:27:28.280 --> 00:27:30.640
of each of those buttons,
an enabled version and

00:27:30.680 --> 00:27:35.940
a disabled version,
that added up to about 100K per button.

00:27:36.230 --> 00:27:41.820
Replacing these images with buttons
that are made of HTML and CSS saves

00:27:41.820 --> 00:27:46.080
me almost 2 megabytes in the overall
memory footprint for my application.

00:27:49.970 --> 00:27:54.240
We went over the HTML and CSS that
you would use to generate a delete

00:27:54.240 --> 00:27:58.130
note button in the Notes application,
but Dashcode also has some

00:27:58.140 --> 00:28:02.180
built-in templates that show some
great examples of how to make

00:28:02.200 --> 00:28:05.030
additional HTML and CSS buttons.

00:28:05.120 --> 00:28:08.570
So you could just load one of these
up in Safari on the desktop and

00:28:08.570 --> 00:28:12.800
inspect the element to see what
CSS is used for a particular button

00:28:13.040 --> 00:28:15.750
in one of these built-in templates.

00:28:18.450 --> 00:28:23.150
So far we've talked primarily about
reducing the number of images in your

00:28:23.150 --> 00:28:28.300
web content to decrease the overall
memory footprint for your application.

00:28:28.420 --> 00:28:33.340
But I want to point out that reducing
the number of images in your app

00:28:33.400 --> 00:28:36.170
will also improve responsiveness.

00:28:36.420 --> 00:28:39.300
So when images are
fetched over the network,

00:28:39.370 --> 00:28:43.940
there's very high latency involved
when your device is fetching

00:28:43.940 --> 00:28:46.300
data over the cellular network.

00:28:46.330 --> 00:28:49.640
Latency on a cellular network
is much higher than Wi-Fi.

00:28:49.860 --> 00:28:54.300
It's about 500 milliseconds as
opposed to 100 milliseconds.

00:28:54.300 --> 00:28:58.300
So as you fetch more and
more additional resources,

00:28:58.310 --> 00:29:02.460
these little snippets of latency
can really add up and add to

00:29:02.460 --> 00:29:04.630
the overall page load time.

00:29:05.680 --> 00:29:10.290
We did a real-world example where we
loaded two websites in Safari on iPhone.

00:29:10.460 --> 00:29:14.100
We looked at Apple.com
versus Microsoft.com.

00:29:14.240 --> 00:29:19.330
Now, Apple.com had an overall larger
sort of memory footprint,

00:29:19.530 --> 00:29:24.970
610K versus 494K for Microsoft.com.

00:29:25.010 --> 00:29:29.800
However, Apple.com had a smaller
number of resources,

00:29:29.800 --> 00:29:33.650
31 versus 55 for Microsoft.com.

00:29:33.750 --> 00:29:38.940
So this meant that Apple.com had fewer,
larger resources.

00:29:39.640 --> 00:29:44.710
When we loaded these two pages over
Edge on iPhone and over 3G on iPhone,

00:29:44.810 --> 00:29:49.250
we found that Apple.com,
with a smaller number of resources

00:29:49.420 --> 00:29:53.310
but higher overall memory footprint,
actually loaded two to three

00:29:53.310 --> 00:29:56.510
times faster than Microsoft.com.

00:29:57.310 --> 00:30:00.120
So as you can see,
reducing the number of images in

00:30:00.240 --> 00:30:04.650
your application not only will have a
positive impact on memory footprint,

00:30:05.030 --> 00:30:07.880
but also on page load time.

00:30:11.470 --> 00:30:13.960
Now let's talk about
using CSS transforms,

00:30:13.960 --> 00:30:17.080
transitions,
and animations for decreasing the

00:30:17.080 --> 00:30:20.400
memory footprint in your application
and increasing performance.

00:30:22.720 --> 00:30:26.460
So if you're a website developer,
your website has to work and

00:30:26.720 --> 00:30:30.380
be compatible with a number
of different web browsers.

00:30:30.400 --> 00:30:34.960
Your website has to work with Safari,
Safari on iPhone, Firefox,

00:30:34.960 --> 00:30:38.370
and maybe even Internet Explorer 6.

00:30:39.440 --> 00:30:43.070
So the way that many web developers
deal with compatibility issues

00:30:43.540 --> 00:30:46.580
is to use a JavaScript framework.

00:30:46.860 --> 00:30:52.070
Frameworks often kind of abstract
away browser incompatibilities and

00:30:52.070 --> 00:30:54.890
allow you to focus on development.

00:30:55.070 --> 00:30:58.840
However, if you're developing
content for UIWebView,

00:30:58.870 --> 00:31:03.200
the only browser that you really
need to be compatible with is Safari,

00:31:03.220 --> 00:31:06.800
and the only layout engine that you
need to be compatible with is WebKit.

00:31:08.440 --> 00:31:14.150
Again, the iTunes Music Store is a great
example of a native application that uses

00:31:14.150 --> 00:31:17.400
WebKit to layout most of its content.

00:31:17.470 --> 00:31:21.180
Here in this main view,
we're using many advanced techniques

00:31:21.180 --> 00:31:23.880
to optimize this content for WebKit.

00:31:24.460 --> 00:31:26.860
So if you're developing
content for UIWebView,

00:31:26.910 --> 00:31:28.570
you can do the same thing.

00:31:28.660 --> 00:31:32.080
Since you don't have to be compatible
with other browser engines,

00:31:32.130 --> 00:31:36.180
you can use whatever tools are at
your disposal to deliver the best

00:31:36.460 --> 00:31:38.940
experience possible to your users.

00:31:40.750 --> 00:31:47.190
So one way that you can do this is to
use CSS transitions and animations.

00:31:47.960 --> 00:31:51.210
So let's benchmark the performance
of a JavaScript library

00:31:51.410 --> 00:31:53.970
versus a CSS transition.

00:31:54.050 --> 00:31:57.240
So the animation that we're
going to look at is basically

00:31:57.270 --> 00:32:00.850
clicking on this paragraph and
watching the text just fade away.

00:32:01.060 --> 00:32:03.320
So something like this.

00:32:05.680 --> 00:32:10.410
Now the JavaScript library that we used
to achieve this animation was jQuery.

00:32:10.410 --> 00:32:13.230
And there's nothing at all
inherently wrong with jQuery.

00:32:13.390 --> 00:32:17.870
In fact, it's a very useful tool
for many web developers.

00:32:18.510 --> 00:32:22.520
The high memory overhead comes
in loading and parsing this file,

00:32:22.520 --> 00:32:24.540
which is 120K.

00:32:24.720 --> 00:32:28.180
Reading and parsing and
building the function map for

00:32:28.550 --> 00:32:30.620
this file all takes memory.

00:32:30.800 --> 00:32:35.360
If we use a CSS transition instead,
we're basically adding one line

00:32:35.360 --> 00:32:37.820
of CSS and one line of JavaScript.

00:32:38.020 --> 00:32:41.890
And this is going to
save us over 3 megabytes.

00:32:42.230 --> 00:32:45.720
So let's take a look at what it takes
to build some of these animations

00:32:46.030 --> 00:32:49.580
with CSS transitions and animations.

00:32:51.200 --> 00:32:54.320
So one of the building blocks
for CSS transitions and

00:32:54.320 --> 00:32:57.060
animations is CSS transforms.

00:32:57.090 --> 00:33:04.210
And CSS transforms allow us to translate,
rotate, scale, or skew any HTML element.

00:33:04.650 --> 00:33:08.640
So if I wanted to take
this photo and flip it,

00:33:08.750 --> 00:33:13.170
I would apply the CSS property
WebKitTransform with the

00:33:13.170 --> 00:33:16.330
value rotate of 180 degrees.

00:33:16.980 --> 00:33:23.610
I could also scale this photograph
up by 25% and move it 100 pixels

00:33:23.700 --> 00:33:28.500
in the X direction by adding two
additional values to WebKit Transform:

00:33:28.570 --> 00:33:34.400
scale by 1.25 and
translate X by 100 pixels.

00:33:34.490 --> 00:33:37.680
So this is a basic
example of 2D transforms,

00:33:37.830 --> 00:33:41.720
but there's also 3D transforms available.

00:33:42.040 --> 00:33:44.660
We use the same property,
WebKit Transform,

00:33:44.840 --> 00:33:50.460
but there are additional values:
Translate 3D, Rotate X, Rotate Y,

00:33:50.460 --> 00:33:57.190
and Rotate 3D, Scale 3D, or Matrix 3D,
which allows you to define your

00:33:57.190 --> 00:34:00.200
own 3D matrix for transformation.

00:34:00.990 --> 00:34:04.900
We're not going to go too
in-depth on CSS 3D transforms,

00:34:04.980 --> 00:34:08.900
but you can find some great
examples at the Safari Dev Center.

00:34:09.020 --> 00:34:14.110
The first is called Poster Circle,
and it's sort of three rings of rotating

00:34:14.300 --> 00:34:17.280
posters stacked one on top of another.

00:34:17.460 --> 00:34:22.720
And the second is called Fingertips,
which provides a sort of wheel navigation

00:34:22.720 --> 00:34:25.280
for looking at different videos.

00:34:25.760 --> 00:34:30.610
As I said, both of these are available as
sample code at the Safari Dev Center,

00:34:30.760 --> 00:34:33.910
which is developer.apple.com/safari.

00:34:33.990 --> 00:34:36.200
The first example is
called Poster Circle,

00:34:36.270 --> 00:34:39.330
and the second one is called Fingertips.

00:34:40.800 --> 00:34:44.060
So let's move on to CSS transitions.

00:34:44.210 --> 00:34:48.140
CSS transitions are sort
of an automatic animation,

00:34:48.200 --> 00:34:53.620
meaning that you specify the initial
and final value of the animation,

00:34:53.640 --> 00:34:57.610
and WebKit takes care of rendering
all of the frames between

00:34:57.690 --> 00:34:59.830
that initial and final value.

00:35:00.090 --> 00:35:03.380
The animation executes
when the values change,

00:35:03.500 --> 00:35:07.640
and the way that you change those
values is through JavaScript.

00:35:07.810 --> 00:35:10.620
So let's take a look at an example.

00:35:11.190 --> 00:35:16.010
So here we have our mini image again,
and we have some CSS properties

00:35:16.010 --> 00:35:17.940
defined for this image.

00:35:18.070 --> 00:35:21.780
We're starting with a border of 6 pixels,
solid white.

00:35:21.850 --> 00:35:25.650
And for the WebKit transform property,
we're specifying an initial

00:35:25.900 --> 00:35:30.740
state where the scale is 1.0
and the rotation is 0 degrees.

00:35:31.470 --> 00:35:37.410
So if we want to scale this image
up by 25% and rotate it by 180

00:35:37.490 --> 00:35:41.820
degrees showing an animation,
our final state is going to

00:35:41.940 --> 00:35:48.020
be WebKit transform scale
1.25 and rotate 180 degrees.

00:35:48.130 --> 00:35:52.580
So here we're going from an
initial state to a final state.

00:35:53.350 --> 00:35:57.420
Also in the mini class declaration,
you'll notice that we have

00:35:57.420 --> 00:36:01.540
WebKitTransitionProperty
equal to WebKitTransform.

00:36:01.570 --> 00:36:07.890
This tells WebKit that WebKitTransform
is the property that you want to animate.

00:36:08.310 --> 00:36:11.740
We also have WebKit transition
duration to tell WebKit that we

00:36:11.740 --> 00:36:16.580
want the animation to take place
over a period of two seconds.

00:36:17.520 --> 00:36:21.160
So to trigger this animation from the
beginning state to the final state,

00:36:21.330 --> 00:36:23.990
we're going to use JavaScript.

00:36:24.150 --> 00:36:27.700
And basically,
all we're going to do is get the element,

00:36:27.750 --> 00:36:30.880
look at the class name,
and if it's equal to "mini", we're

00:36:30.880 --> 00:36:34.340
going to change it to "mini move".
If it's equal to "mini move", we're

00:36:34.340 --> 00:36:38.730
going to change it back to "mini".
Doing so is going to trigger an

00:36:38.730 --> 00:36:42.080
animation that looks something like this.

00:36:45.270 --> 00:36:49.970
So here we're just kind of flipping the
image and scaling it up by 25%, but we

00:36:49.970 --> 00:36:52.870
can make this a little more complicated.

00:36:53.660 --> 00:36:57.760
Here in our mini class declaration,
again we have the border,

00:36:57.800 --> 00:37:00.680
and here we've added opacity of 0.0.

00:37:01.080 --> 00:37:04.820
So this image is going
to start out invisible.

00:37:05.200 --> 00:37:09.840
Our initial value for WebKit transform
is scaled down by 50% and

00:37:09.880 --> 00:37:12.600
again rotated by 0 degrees.

00:37:12.770 --> 00:37:16.360
And here for WebKit transition property,
we're telling WebKit that we

00:37:16.360 --> 00:37:18.090
want to animate two properties.

00:37:18.400 --> 00:37:23.460
We want to animate opacity and
also the WebKit transform property.

00:37:24.130 --> 00:37:27.630
For the duration,
we want the opacity animation

00:37:27.630 --> 00:37:32.160
to happen over 1.3 seconds,
and we want the animation of

00:37:32.160 --> 00:37:36.960
the WebKit transform property
to happen over 1.5 seconds.

00:37:37.870 --> 00:37:42.100
In our Move class,
we're setting the opacity to 1.0,

00:37:42.180 --> 00:37:47.140
and our WebKit transform value
scales the image up by 25%

00:37:47.350 --> 00:37:51.170
and rotates it by 360 degrees.

00:37:52.200 --> 00:37:56.620
Again, we're going to interpolate between
these two states and trigger the

00:37:56.620 --> 00:37:59.100
animation through JavaScript.

00:37:59.220 --> 00:38:03.170
And this animation is going
to look something like this.

00:38:07.580 --> 00:38:11.900
So I mentioned that you specify an
initial state and a final state,

00:38:11.910 --> 00:38:15.980
and WebKit takes care of rendering
all of the frames in between.

00:38:16.020 --> 00:38:20.290
But you do have some control over
the acceleration curve for your

00:38:20.290 --> 00:38:25.700
animation via the CSS property
WebKitTransitionTimingFunction.

00:38:25.750 --> 00:38:29.100
So there are several values that
you can supply to this property.

00:38:29.140 --> 00:38:38.080
They're basically ease, linear, ease in,
ease out, ease in out,

00:38:38.100 --> 00:38:41.800
or you can supply your
own cubic Bezier curve.

00:38:43.160 --> 00:38:46.900
Finally, if you want to delay the
start of a CSS transition,

00:38:47.280 --> 00:38:51.160
you can use the
WebKitTransitionDelay property.

00:38:51.350 --> 00:38:55.200
If you specify one second, for example,
for this property,

00:38:55.360 --> 00:39:00.790
you'll have a delay of one second after
you change the values using JavaScript.

00:39:02.890 --> 00:39:07.040
So just to circle back to our original
example where we looked at the real-world

00:39:07.040 --> 00:39:11.800
impact of using a CSS transition
versus a JavaScript library,

00:39:12.000 --> 00:39:17.390
here was the code that we used in
JavaScript to trigger this animation.

00:39:19.570 --> 00:39:22.660
And here is the code
for the CSS transition.

00:39:22.710 --> 00:39:25.490
We're basically setting the
WebKit transition property

00:39:25.490 --> 00:39:27.300
we're using shorthand here.

00:39:27.360 --> 00:39:30.400
We're saying that opacity is
the property that we want to

00:39:30.400 --> 00:39:35.340
animate over 600 milliseconds
with a linear acceleration curve.

00:39:35.340 --> 00:39:40.910
Then our JavaScript just sets the
opacity of the paragraph to zero,

00:39:41.120 --> 00:39:43.490
triggering the animation.

00:39:45.310 --> 00:39:50.470
CSS keyframe animations give you all
of the advantages of CSS transitions

00:39:50.470 --> 00:39:53.940
and they give you fine-grained
control over the keyframes,

00:39:54.020 --> 00:39:57.390
control over the repeat
count and behavior,

00:39:57.390 --> 00:40:02.700
and also there are DOM events
associated with CSS animations.

00:40:02.790 --> 00:40:05.930
So let's dive right into an example.

00:40:06.680 --> 00:40:10.600
If we pretend that the entire
screen here is a web page,

00:40:10.600 --> 00:40:16.340
and we have a leaf kind of falling down
the right-hand side of this web page,

00:40:16.440 --> 00:40:20.480
how would we define this
using a CSS animation?

00:40:20.640 --> 00:40:24.260
Well, the first thing that we would
do is define the animation

00:40:24.610 --> 00:40:27.710
using the @WebKitKeyframes rule.

00:40:27.830 --> 00:40:31.520
Here we've named our animation
"fall," and we're saying that

00:40:31.520 --> 00:40:36.550
the animation starts 50 pixels
off-screen in the Y direction.

00:40:37.060 --> 00:40:42.640
and goes all the way down to 600 pixels
down the screen in the Y direction.

00:40:42.690 --> 00:40:46.100
So we're starting off screen
and moving the leaf down the

00:40:46.100 --> 00:40:48.450
right-hand side of the page.

00:40:50.570 --> 00:40:54.730
To apply this animation,
we just set fall as the value for

00:40:54.790 --> 00:41:00.000
the CSS property WebKitAnimationName
on our leaf class here.

00:41:00.060 --> 00:41:04.430
We're going to specify an
animation duration of 10 seconds.

00:41:04.580 --> 00:41:06.850
We want this animation
to iterate forever,

00:41:06.910 --> 00:41:09.810
so we're going to set
WebKitAnimationIterationCount

00:41:09.960 --> 00:41:11.500
to infinite.

00:41:11.560 --> 00:41:16.220
And finally, we want this animation to
follow a linear timing function.

00:41:16.310 --> 00:41:20.590
So we're going to set
WebKitAnimationTimingFunction to linear.

00:41:20.710 --> 00:41:25.540
And here we have the leaf kind of falling
down the right side of the screen and

00:41:25.540 --> 00:41:28.380
disappearing at the end of its path.

00:41:30.900 --> 00:41:35.160
So what if we want to add an animation
here so that instead of disappearing,

00:41:35.470 --> 00:41:40.140
the leaf kind of fades out as
it nears the end of its path?

00:41:40.950 --> 00:41:44.540
Well, we can do this by defining
an additional animation,

00:41:44.540 --> 00:41:47.300
again using the @WebKitKeyframes rule.

00:41:47.510 --> 00:41:51.890
This animation is named Fade,
and we're saying that we want

00:41:52.040 --> 00:41:57.050
the opacity to be 1 for the
first 75% of the animation.

00:41:57.270 --> 00:41:59.950
And then for the last
25% of the animation,

00:42:00.090 --> 00:42:05.710
we want the opacity to fade from 1 to 0,
so we want the leaf to disappear.

00:42:07.450 --> 00:42:11.760
Again on our Leaf class,
we're going to specify two animations

00:42:11.760 --> 00:42:15.260
here for WebKit animation name,
Fall and Fade.

00:42:15.390 --> 00:42:19.400
We want them both to take 10
seconds and iterate forever.

00:42:19.400 --> 00:42:25.100
And we want the Fall animation to follow
a linear timing function where we want

00:42:25.100 --> 00:42:28.130
the Fade animation to kind of ease in.

00:42:28.630 --> 00:42:31.180
So as you can see,
the leaf kind of falls down

00:42:31.180 --> 00:42:36.140
the right side of the page,
and for the last 25% of its path,

00:42:36.190 --> 00:42:40.910
the opacity fades from 1 to 0,
and the leaf disappears.

00:42:43.300 --> 00:42:47.290
I mentioned that there were DOM events
associated with CSS animations,

00:42:47.460 --> 00:42:51.540
and these are WebKitAnimationStart,
WebKitAnimationIteration,

00:42:51.540 --> 00:42:53.110
and WebKitAnimationEnd.

00:42:53.460 --> 00:42:57.310
And these allow you to know
when an animation starts,

00:42:57.380 --> 00:42:59.170
iterates, or ended.

00:42:59.580 --> 00:43:03.330
You can listen for these events just
like you would any other DOM event.

00:43:03.480 --> 00:43:08.440
Here we're listening for an animation
end event directly on the element.

00:43:08.510 --> 00:43:13.510
And when that animation ends,
we're going to set the display to none.

00:43:17.320 --> 00:43:21.840
There's one more important thing to note
about CSS transitions and animations,

00:43:22.010 --> 00:43:25.440
and that is that they
are hardware-accelerated.

00:43:25.530 --> 00:43:28.520
Since they're hardware-accelerated,
you will never, ever,

00:43:28.570 --> 00:43:32.130
ever achieve the same performance
with a JavaScript animation

00:43:32.600 --> 00:43:37.290
that you could achieve with
a CSS transition or animation.

00:43:39.010 --> 00:43:42.150
I actually have a demo to
show you the difference in the

00:43:42.150 --> 00:43:45.990
performance of JavaScript animation
versus a CSS animation.

00:43:46.070 --> 00:43:50.390
Let's take a look at the differences
between these two approaches.

00:43:52.240 --> 00:43:55.920
Let's take a look at a leaf
animation in a web page.

00:43:55.970 --> 00:43:58.000
In the first case,
we'll be using JavaScript to

00:43:58.110 --> 00:44:00.990
animate the leaves,
and in the second case,

00:44:01.120 --> 00:44:03.590
we'll be using CSS animations.

00:44:07.950 --> 00:44:11.740
So here's the first case,
animating with JavaScript.

00:44:11.740 --> 00:44:15.540
This is the best performance that we
could get animating with JavaScript,

00:44:15.550 --> 00:44:18.820
but if you look closely,
you can see that the leaves are

00:44:18.820 --> 00:44:24.140
kind of falling down the page with
a little bit of a jagged motion.

00:44:24.300 --> 00:44:28.700
Also, the leaf animation that we
see here is really simple.

00:44:28.730 --> 00:44:32.870
The leaves are just appearing at the top
of the page and falling straight down,

00:44:32.870 --> 00:44:40.780
disappearing off the
bottom edge of the screen.

00:44:40.780 --> 00:44:44.570
Now let's take a look at
the CSS animation example.

00:44:50.600 --> 00:44:53.670
Here we see we have a number
of leaves on screen at once and

00:44:53.710 --> 00:44:56.600
the animation is totally smooth.

00:44:56.690 --> 00:45:02.640
Also, the animation on each leaf is much
more complicated than the animation we

00:45:02.640 --> 00:45:05.140
were able to achieve with JavaScript.

00:45:05.190 --> 00:45:10.060
Each leaf as it falls kind
of arcs back and forth,

00:45:10.060 --> 00:45:15.460
and as each leaf approaches
the bottom of the screen,

00:45:15.460 --> 00:45:15.810
the opacity fades out
and each leaf disappears.

00:45:16.750 --> 00:45:19.830
So as you can see,
the performance and functionality

00:45:20.100 --> 00:45:24.830
that we were able to achieve using
CSS animations was far superior to

00:45:24.830 --> 00:45:30.530
what we were able to do animating these
leaves conventionally with JavaScript.

00:45:32.290 --> 00:45:35.500
So let's take a look at one
final piece of functionality,

00:45:35.590 --> 00:45:40.640
how to improve responsiveness in your
application by caching data locally.

00:45:40.800 --> 00:45:46.160
So often I've used web applications,
for instance, a to-do list application.

00:45:46.270 --> 00:45:50.880
And when I commit that to-do item,
it takes several seconds for the

00:45:50.880 --> 00:45:54.880
data to be stored up in the cloud,
and then for the packet to

00:45:54.880 --> 00:45:58.960
make the round trip and for the
user interface to be updated.

00:45:59.010 --> 00:46:03.240
That user interface could be much
more responsive if we eliminated the

00:46:03.240 --> 00:46:05.790
network and stored that data locally.

00:46:06.850 --> 00:46:10.600
So you can enable this
functionality using the HTML 5

00:46:10.600 --> 00:46:12.820
database storage feature.

00:46:13.020 --> 00:46:17.040
Now this is a standards-based
approach to local database storage,

00:46:17.210 --> 00:46:21.800
meaning that it's part of HTML 5
and will probably be adopted by

00:46:21.830 --> 00:46:24.290
other browsers in the future.

00:46:24.470 --> 00:46:28.780
It's based off of real-world SQL,
so all of the SQL conventions that you're

00:46:28.780 --> 00:46:32.650
used to are here and part of this API.

00:46:34.260 --> 00:46:37.440
This API is asynchronous
and callback-based,

00:46:37.520 --> 00:46:39.930
meaning that your UI will
never be locked up,

00:46:40.140 --> 00:46:42.960
waiting for a transition to complete.

00:46:44.910 --> 00:46:48.160
And finally,
HTML 5 database storage operates

00:46:48.230 --> 00:46:52.150
on origin-based security,
meaning that other websites

00:46:52.520 --> 00:46:56.800
cannot access your website's data,
and your website cannot access

00:46:56.800 --> 00:46:58.790
the data of a different website.

00:47:02.420 --> 00:47:04.940
Other advantages are reduced complexity.

00:47:05.010 --> 00:47:08.420
You can store your data directly
in the database instead of

00:47:08.420 --> 00:47:10.840
having to sync it to the cloud.

00:47:11.070 --> 00:47:13.740
We've already talked about
improved performance,

00:47:13.740 --> 00:47:17.070
but reducing the number of
network operations on iPhone

00:47:17.100 --> 00:47:22.260
improves overall battery life,
and of course, improves responsiveness.

00:47:22.790 --> 00:47:25.120
And finally,
if you're storing the data locally,

00:47:25.410 --> 00:47:31.380
you can have access to that data even if
there's no network connection available.

00:47:32.950 --> 00:47:37.590
We're going to discuss three
aspects of the HTML5 SQL API for

00:47:37.590 --> 00:47:39.800
client-side databases.

00:47:40.160 --> 00:47:44.320
First, we're going to talk about what
it takes to create a database.

00:47:44.410 --> 00:47:48.840
After that, we'll talk about executing
transactions and finally,

00:47:48.840 --> 00:47:50.520
handling callbacks.

00:47:52.840 --> 00:47:56.750
So creating or opening a
database is actually very simple.

00:47:56.900 --> 00:48:00.670
The first thing that you're going
to do is test to see if the current

00:48:00.670 --> 00:48:03.800
browser supports database functionality.

00:48:03.850 --> 00:48:07.960
And we do this by checking
window.opendatabase.

00:48:08.570 --> 00:48:12.190
If this functionality exists,
we're going to go ahead

00:48:12.190 --> 00:48:13.930
and set up a few variables.

00:48:14.720 --> 00:48:19.620
So here we've passed a name, a version,
a display name, and an expected size to

00:48:19.760 --> 00:48:21.660
the Open Database method.

00:48:21.790 --> 00:48:25.450
But really the only parameter that
is strictly required is the name.

00:48:25.770 --> 00:48:29.060
You can just set the
other parameters to null.

00:48:30.500 --> 00:48:33.650
So once you have opened a database,
the next thing that you're

00:48:33.650 --> 00:48:38.330
going to want to do is execute
transactions on this database.

00:48:39.070 --> 00:48:41.600
For those of you familiar
with database programming,

00:48:41.600 --> 00:48:44.740
this is probably very familiar to you.

00:48:44.910 --> 00:48:48.990
But for those of you who aren't,
a transaction is basically an atomic unit

00:48:49.120 --> 00:48:51.660
of work that cannot partially succeed.

00:48:52.320 --> 00:48:56.670
Basically, any changes made during a
transaction are rolled back if any

00:48:56.670 --> 00:48:59.080
part of that transaction fails.

00:48:59.260 --> 00:49:02.820
When you start to think about
deeply rooted relational databases,

00:49:03.150 --> 00:49:04.820
this model makes a lot of sense.

00:49:04.940 --> 00:49:07.890
You wouldn't want half of
your data to be modified.

00:49:09.470 --> 00:49:15.790
All queries that are part of the HTML5
SQL API must be part of a transaction.

00:49:17.440 --> 00:49:20.100
So here's what a transaction looks like.

00:49:20.210 --> 00:49:26.140
I basically create a string of SQL and
then pass that string of SQL to the

00:49:26.230 --> 00:49:29.710
execute SQL method on the transaction.

00:49:33.920 --> 00:49:37.560
There are two types of callbacks
that are part of this API:

00:49:37.730 --> 00:49:40.800
transaction callbacks
and query callbacks.

00:49:41.160 --> 00:49:44.690
Transaction callbacks are related
to the entire transaction.

00:49:44.780 --> 00:49:47.750
There are two types of
transaction callbacks:

00:49:48.200 --> 00:49:51.620
completion callbacks and error callbacks.

00:49:51.750 --> 00:49:56.480
Completion callbacks allow you to
detect when a transaction has completed,

00:49:56.670 --> 00:50:01.150
and the error callbacks allow you to
handle error messages and codes that

00:50:01.150 --> 00:50:03.800
you might want to display to the user.

00:50:06.800 --> 00:50:09.940
The second type of callback
is a query callback.

00:50:10.020 --> 00:50:13.890
A query callback is related
to the individual queries

00:50:13.890 --> 00:50:16.000
within the transaction.

00:50:16.150 --> 00:50:19.440
There are two types of query callbacks:
data callbacks,

00:50:19.660 --> 00:50:23.700
which allow you to manipulate the
data that was returned from a query,

00:50:23.940 --> 00:50:27.350
and error callbacks,
which allow for optional

00:50:27.350 --> 00:50:29.820
queries within a transaction.

00:50:29.950 --> 00:50:33.570
Basically,
if a query within a transaction fails,

00:50:33.630 --> 00:50:37.730
you can choose to proceed
with the transaction anyway.

00:50:37.940 --> 00:50:41.380
If no error callback is
specified for each query,

00:50:41.430 --> 00:50:44.720
all errors are assumed fatal
and the entire transaction is

00:50:44.720 --> 00:50:46.190
rolled back to the beginning.

00:50:49.740 --> 00:50:53.180
So there's a great example
available online at webkit.org

00:50:53.530 --> 00:50:58.970
that you can take a look at to get
started with the HTML5 SQL API.

00:50:59.210 --> 00:51:01.800
This is a basic sticky notes application.

00:51:01.910 --> 00:51:05.260
When you click the New Note button,
a new sticky note appears,

00:51:05.300 --> 00:51:10.360
and then you can edit the contents of
that note or move it around on screen.

00:51:12.000 --> 00:51:16.500
The contents and the position of the
note are stored in a local database.

00:51:16.690 --> 00:51:20.930
Here we've opened up the Web Inspector in
Safari on the Desktop to examine

00:51:20.930 --> 00:51:22.700
the contents of this database.

00:51:23.050 --> 00:51:28.600
Here we see the content of each note,
a timestamp, and its position on screen.

00:51:31.400 --> 00:51:35.730
The integrated tools in Safari on the
Desktop provide a great environment for

00:51:35.730 --> 00:51:38.400
building and debugging your application.

00:51:38.410 --> 00:51:42.640
So if I select the database
name in the left-hand panel,

00:51:42.640 --> 00:51:44.900
this prompt appears.

00:51:45.820 --> 00:51:49.030
From here,
I can execute arbitrary SQL statements

00:51:49.030 --> 00:51:53.700
on the selected database to build
or even debug my application.

00:51:55.600 --> 00:51:59.850
This view also includes tab completion,
which is useful in any debugging

00:51:59.990 --> 00:52:01.500
or development scenario.

00:52:05.720 --> 00:52:08.600
So that covers the second
half of our presentation:

00:52:08.750 --> 00:52:13.760
Optimizing the Web Content Inside of
UIWebView for a Reduced Memory Footprint

00:52:14.040 --> 00:52:15.440
and Improved Performance.

00:52:19.560 --> 00:52:23.660
To recap what we've covered today,
we started out by talking about some of

00:52:23.660 --> 00:52:27.110
the advantages of hybrid applications.

00:52:27.870 --> 00:52:30.210
After that,
we addressed some of the commonly

00:52:30.250 --> 00:52:32.250
asked questions around UIWebView.

00:52:35.400 --> 00:52:38.440
And finally,
we went in-depth on optimizing

00:52:38.440 --> 00:52:43.430
the content inside of UIWebView,
using CSS to decrease the overall

00:52:43.660 --> 00:52:47.840
image count in our web interfaces,
replacing JavaScript animations

00:52:47.930 --> 00:52:51.920
with CSS transforms,
transitions, and animations,

00:52:51.950 --> 00:52:55.970
and using local data storage
to improve responsiveness in

00:52:55.970 --> 00:52:58.560
the UI of your web interface.

00:53:00.620 --> 00:53:04.260
You can find documentation
and sample code for Safari at

00:53:04.330 --> 00:53:09.200
the Safari Dev Center at
developer.apple.com/safari.

00:53:09.230 --> 00:53:12.120
And of course,
documentation for the iPhone SDK,

00:53:12.350 --> 00:53:16.290
including UIWebView,
is available at the iPhone Dev Center,

00:53:16.290 --> 00:53:18.900
developer.apple.com/iphone.

00:53:19.030 --> 00:53:22.190
If you have any additional questions,
feel free to email me

00:53:22.190 --> 00:53:24.250
directly at vicki@apple.com.

00:53:24.390 --> 00:53:27.680
Thanks for watching today,
and I can't wait to see how you integrate

00:53:27.680 --> 00:53:31.060
web content into your iPhone application.
WEBVTT

00:00:14.850 --> 00:00:18.500
In this session of
architecting modern iOS apps,

00:00:18.670 --> 00:00:24.070
Part 2, we're going to be looking at
components of new hardware,

00:00:24.070 --> 00:00:26.840
in particular the A7 chip.

00:00:27.020 --> 00:00:31.490
And then we're going to take a
look at adopting the iOS 7 SDK,

00:00:31.490 --> 00:00:37.610
but in a way that maintains
backwards compatibility with iOS 6.

00:00:38.280 --> 00:00:41.770
Let's start off with building
your apps for the A7.

00:00:41.950 --> 00:00:45.310
Now, of course,
the big news about the A7 chip is

00:00:45.330 --> 00:00:50.150
that it's the world's first 64‑bit
processor in a mobile device.

00:00:50.470 --> 00:00:54.560
Now, there was a lot of confusion
when we announced the A7.

00:00:54.560 --> 00:00:58.800
A lot of people were wondering, well,
why on earth would I need

00:00:58.800 --> 00:01:01.210
a 64‑bit chip in an iPhone?

00:01:01.210 --> 00:01:06.540
Am I really going to need to address
more than 4 gigabytes of memory?

00:01:07.100 --> 00:01:10.450
Well, truth be told,
there are a lot more benefits to

00:01:10.450 --> 00:01:13.430
64‑bit than just a large address space.

00:01:13.430 --> 00:01:18.780
This move to a new architecture has
allowed us to make many changes.

00:01:18.780 --> 00:01:22.480
For example, we've doubled the number of
integer and floating point

00:01:22.480 --> 00:01:24.420
registers available on the CPU.

00:01:24.420 --> 00:01:28.610
These registers are where the
CPU performs its calculations.

00:01:28.610 --> 00:01:33.100
So having more registers means that
it can spend more time performing

00:01:33.100 --> 00:01:35.980
calculations and less time moving
data in and out of the CPU.

00:01:36.000 --> 00:01:39.800
So ultimately, faster computation.

00:01:39.800 --> 00:01:44.560
We've also used this opportunity
to adopt a new assembly language,

00:01:44.560 --> 00:01:47.860
one that is more efficient and up
to the task of modern computation

00:01:47.980 --> 00:01:51.400
than previous assembly languages
that we were using before.

00:01:51.400 --> 00:01:55.520
So again, a more efficient assembly code
can mean faster performance.

00:01:55.520 --> 00:01:58.900
The 64‑bit architecture of the A7 also
has allowed us to make optimizations

00:01:58.900 --> 00:02:01.620
to the Objective C runtime so that
things like object allocation and

00:02:01.730 --> 00:02:04.900
even the ability to run the A7 in a
single run can be done in a single run.

00:02:04.900 --> 00:02:07.960
allocation,
and even basic memory management,

00:02:07.960 --> 00:02:09.740
are now much faster.

00:02:09.740 --> 00:02:14.760
All of these together means that simply
by recompiling your app for 64-bit

00:02:14.760 --> 00:02:18.620
means that you can see some pretty
significant performance improvements.

00:02:18.620 --> 00:02:22.300
I also want to mention that the
64-bit standard that we have adopted

00:02:22.300 --> 00:02:26.780
on iOS is the same 64-bit standard
that we're using on the Mac.

00:02:26.820 --> 00:02:31.650
So by having the same standard
for both 32-bit and 64-bit code,

00:02:31.660 --> 00:02:36.360
it means that all of the code that
you write for your iOS apps is now

00:02:36.360 --> 00:02:39.420
easily portable to the Mac as well.

00:02:39.420 --> 00:02:44.240
This allows you to build apps that
will last on both iOS and Mac.

00:02:44.500 --> 00:02:47.580
So that's a brief overview of
some of the benefits of 64-bit.

00:02:47.610 --> 00:02:51.210
But let's take a look at how
64-bit will actually affect the

00:02:51.270 --> 00:02:54.190
app that you ship on the store.

00:02:54.990 --> 00:02:59.180
If we crack open your application bundle,
one of the very first things that we

00:02:59.180 --> 00:03:01.680
will find is your executable file.

00:03:01.680 --> 00:03:04.430
This is, of course,
where all of your code has

00:03:04.430 --> 00:03:08.200
been compiled and will live,
and it contains all of the instructions

00:03:08.200 --> 00:03:10.400
and all of your app's custom logic.

00:03:10.400 --> 00:03:14.990
In addition to this file,
you'll have many resource files,

00:03:14.990 --> 00:03:19.890
such as perhaps some nib files
or storyboards or perhaps both.

00:03:20.010 --> 00:03:24.180
You'll have configuration files,
maybe some JSON files, P list, databases,

00:03:24.180 --> 00:03:24.900
and so on.

00:03:24.900 --> 00:03:27.340
And, of course, you'll have image assets.

00:03:27.400 --> 00:03:33.390
So this is what your app looks like
right now running on a 32‑bit device.

00:03:33.460 --> 00:03:35.390
But how does this change
for a 64‑bit device?

00:03:35.390 --> 00:03:38.730
Watch closely.

00:03:39.700 --> 00:06:00.700
[ Transcript missing ]

00:06:00.880 --> 00:06:04.800
All you need to do to update your
architecture's build setting is to

00:06:04.800 --> 00:06:09.360
find the build settings for your
particular target and in particular

00:06:09.490 --> 00:06:11.590
find the architecture's line.

00:06:11.590 --> 00:06:15.520
Now, by default, this value will be
standard architectures.

00:06:15.770 --> 00:06:18.380
And so ARMv7 and ARMv7S.

00:06:18.380 --> 00:06:22.320
All you need to do is change this
to be standard architectures,

00:06:22.320 --> 00:06:24.120
including 64‑bit.

00:06:24.160 --> 00:06:27.900
By changing this value,
you are indicating that when

00:06:27.900 --> 00:06:32.390
we compile your app for release
build that we should be compiling

00:06:32.390 --> 00:06:35.350
it a version as well for 64‑bit.

00:06:35.390 --> 00:06:38.360
So, easy.

00:06:39.140 --> 00:06:44.500
The second step is to update any
third‑party libraries that you're using.

00:06:44.740 --> 00:06:50.600
All code that you run in a 64‑bit
app must be compiled for 64‑bit.

00:06:50.600 --> 00:06:53.930
You cannot use a 32‑bit
library inside a 64‑bit app,

00:06:53.930 --> 00:06:57.660
nor can you use a 64‑bit
library inside a 32‑bit app.

00:06:57.810 --> 00:07:00.440
The architecture values must match.

00:07:00.580 --> 00:07:03.700
And so if you're using
any third‑party libraries,

00:07:03.700 --> 00:07:06.510
such as, you know,
connecting to somebody's

00:07:06.900 --> 00:07:09.180
service or whatever,
then those must also

00:07:09.180 --> 00:07:11.350
be updated for 64‑bit.

00:07:11.400 --> 00:08:26.500
[ Transcript missing ]

00:08:26.900 --> 00:09:27.800
[ Transcript missing ]

00:09:28.040 --> 00:09:32.870
However, these changes to the data
type sizes can cause some very

00:09:32.870 --> 00:09:35.140
subtle errors in our code.

00:09:35.140 --> 00:09:38.170
And also in the files that we create
on disk and also in the memory

00:09:38.170 --> 00:09:39.890
that we use in an application.

00:09:39.940 --> 00:09:42.640
So first up, 64‑bit in our code.

00:09:43.000 --> 00:09:49.570
Now, one problem we might have is
if we have code like this,

00:09:49.590 --> 00:09:56.840
where we're invoking a method that
returns an NS integer and we're

00:09:56.910 --> 00:10:05.010
restoring the result of that method
invocation into an int data type.

00:10:05.010 --> 00:10:05.010
Let's look at what's going on here.

00:10:05.010 --> 00:10:05.010
Well, an int, as we know,
on both 32‑bit and 64‑bit

00:10:05.010 --> 00:10:05.010
devices is four bytes long.

00:10:05.150 --> 00:10:09.500
But as we just learned,
an NS integer on a 64-bit

00:10:09.500 --> 00:10:11.970
device is eight bytes long.

00:10:12.180 --> 00:10:15.000
And the last that I checked,
you cannot put eight bytes

00:10:15.000 --> 00:10:17.710
of data inside four bytes.

00:10:17.840 --> 00:10:19.450
And so something has to give.

00:10:19.650 --> 00:10:24.010
And what gives are the top
four bytes of this number.

00:10:24.270 --> 00:10:26.450
They're simply lost.

00:10:26.530 --> 00:10:32.480
We never get them,
never can get that data back.

00:10:32.620 --> 00:10:34.340
So that data is gone.

00:10:34.370 --> 00:10:37.520
And if there was important
information in those bytes,

00:10:37.540 --> 00:10:41.890
we now have corrupted
data in our program.

00:10:42.260 --> 00:10:45.320
So the easiest way to fix this is,
of course,

00:10:45.320 --> 00:10:48.240
to make sure that our data types match.

00:10:48.240 --> 00:10:51.170
So the primitives that we're using
to store the results of method

00:10:51.170 --> 00:10:54.800
invocations should match the return
types of those method invocations.

00:10:54.800 --> 00:10:56.980
And similarly,
the types that we're passing in

00:10:56.980 --> 00:10:58.700
parameters should match as well.

00:10:58.800 --> 00:11:01.750
Dave DeLoong So we might be
doing something like this,

00:11:01.780 --> 00:11:04.800
where we're copying a value
from a long into a buffer.

00:11:04.800 --> 00:11:08.230
And here we've made the assumption
that a long is four bytes long.

00:11:08.230 --> 00:11:10.700
And that would have been
true on a 32‑bit device.

00:11:10.700 --> 00:11:13.260
But, of course,
it's false on a 64‑bit device

00:11:13.260 --> 00:11:14.980
where longs are now eight bytes.

00:11:15.060 --> 00:11:19.440
And so we are only copying half
of this number into our buffer.

00:11:19.440 --> 00:11:21.600
And so, of course,
our buffer is going to end

00:11:21.600 --> 00:11:23.260
up containing garbage data.

00:11:23.260 --> 00:11:28.460
Dave DeLoong So the correct way to fix
this is to use the size of operator.

00:11:28.980 --> 00:11:33.300
which will return the correct size of
this data type on that architecture.

00:11:33.300 --> 00:11:38.570
So on a 32-bit device, it would return 4,
and on a 64-bit device for a long,

00:11:38.570 --> 00:11:39.930
it would return 8.

00:11:40.020 --> 00:11:42.870
By using the size of operator,
we can make sure that we're

00:11:42.870 --> 00:11:46.470
correctly referring to the
sizes of these primitives.

00:11:46.480 --> 00:11:49.700
Now, another way that 64-bit affects
us in code is if we're trying

00:11:49.700 --> 00:11:51.110
to print a value into a string.

00:11:51.120 --> 00:11:53.440
I expect this can be somewhat common.

00:11:53.440 --> 00:11:59.740
And so if we're using a format specifier
like %d to print a long into a string,

00:11:59.740 --> 00:12:03.000
whether it's via printf or something
higher level like NSString,

00:12:03.000 --> 00:12:08.650
then that would have worked on a
32-bit device because %d indicates

00:12:08.770 --> 00:12:11.780
copy 4 bytes of data into this string.

00:12:11.780 --> 00:12:15.450
But of course,
that will fail on a 64-bit device because

00:12:15.450 --> 00:12:17.800
4 bytes is only half of the number.

00:12:17.800 --> 00:12:22.450
So what we need to instead do is
make sure that our format specifier

00:12:22.450 --> 00:12:27.070
matches the data type and use,
in this particular example, %ld,

00:12:27.260 --> 00:12:29.330
to indicate the long integer type.

00:12:29.400 --> 00:12:31.480
And then our string will
contain the correct value.

00:12:31.480 --> 00:12:34.080
Now, for many of these,
Xcode will warn you.

00:12:34.180 --> 00:12:38.700
It will warn you that you are trying to,
or that you have mismatched data types.

00:12:38.700 --> 00:12:42.930
It will warn you about format
string specifiers not matching

00:12:42.930 --> 00:12:44.140
variable types and so on.

00:12:44.160 --> 00:12:48.710
So simply by setting your architecture's
build setting to include the 64-bit

00:12:48.710 --> 00:12:52.950
architecture and recompiling your app,
Xcode should be giving

00:12:52.950 --> 00:12:54.660
you several new warnings.

00:12:54.680 --> 00:12:57.200
Well,
hopefully none if we've been doing this,

00:12:57.270 --> 00:12:58.760
correctly, all along.

00:12:58.780 --> 00:13:02.720
But it might give you some to go and fix.

00:13:02.750 --> 00:13:06.700
But it won't give you all of them,
which is why we are covering them today.

00:13:06.710 --> 00:13:10.500
And the underlying rule with all
of these is to simply be consistent

00:13:10.500 --> 00:13:12.120
in our usage of data types.

00:13:12.120 --> 00:13:15.980
If we are asked for an 8-byte value,
then we will give an 8-byte value.

00:13:15.980 --> 00:13:19.260
And if we're asked for a 4-byte value,
we will give a 4-byte value.

00:13:19.350 --> 00:13:22.500
We should be consistent in how we
refer to the sizes of these primitives

00:13:22.500 --> 00:13:26.060
and not assume that we know the size,
but simply ask,

00:13:27.020 --> 00:13:31.000
"What is the size of this system?"
And it will give it to us.

00:13:31.110 --> 00:13:34.020
So that's how 64-bit will
affect our app in code.

00:13:34.020 --> 00:13:36.020
What about on disk?

00:13:36.020 --> 00:13:39.430
Well, just as the problems as we saw
with transferring data between

00:13:39.430 --> 00:13:43.020
stack frames could lead to
issues of truncation of data,

00:13:43.020 --> 00:13:47.020
we can have that same issue with
passing data between devices.

00:13:47.020 --> 00:13:53.500
If I write out an 8-byte value on a
64-bit device and give it to another copy

00:13:53.500 --> 00:13:59.780
of my app but running on a 32-bit device,
if I haven't written my app correctly,

00:13:59.780 --> 00:14:02.670
may end up only reading 4 bytes of data.

00:14:02.780 --> 00:14:04.780
Now, you may be thinking, "Well,
this doesn't affect me.

00:14:04.780 --> 00:14:07.130
"Like, I don't have any sharing
capabilities in my app "or,

00:14:07.130 --> 00:14:11.000
you know, I'm not connecting "to any sort
of synchronization service or

00:14:11.050 --> 00:14:14.780
anything." And for the most part,
you're right.

00:14:14.780 --> 00:14:18.940
But we still need to be aware of this
because in addition to the scenario of

00:14:18.940 --> 00:14:24.320
sharing data directly between devices,
there's also the scenario of the user

00:14:24.430 --> 00:14:26.540
restoring their device from backup.

00:14:26.540 --> 00:14:27.540
What do I mean about this?

00:14:27.540 --> 00:14:33.540
Let's say one of your users has your
app installed on her iPhone 3GS.

00:14:33.540 --> 00:14:38.000
And she's been using your app,
and your app has been writing files

00:14:38.030 --> 00:14:42.060
out to disk and has been saving them,
and she has been performing

00:14:42.060 --> 00:14:43.450
backups to iCloud.

00:14:43.540 --> 00:14:47.540
What's been going on is that the
system has been taking those files

00:14:47.540 --> 00:14:52.540
that you created on a 32-bit device
and sending them up to iCloud.

00:14:52.570 --> 00:14:56.520
But then we announce the iPhone 5S,
and your customer has decided that

00:14:56.520 --> 00:14:58.300
she doesn't want her 3GS anymore.

00:14:58.300 --> 00:15:01.300
She's going to buy an iPhone 5S.

00:15:01.420 --> 00:15:02.180
So she does.

00:15:02.410 --> 00:15:05.670
And now to make the transition easy,
she's going to restore

00:15:05.680 --> 00:15:07.300
her phone from backup.

00:15:07.480 --> 00:15:10.960
And what this means is that the
files that you created and were

00:15:11.000 --> 00:15:16.250
saved to iCloud will now be
copied down onto a 64-bit device.

00:15:16.300 --> 00:15:19.950
So the files that you create
on a 32-bit device can still

00:15:20.020 --> 00:15:23.710
be opened on a 64-bit device,
even if your app has no

00:15:23.710 --> 00:15:25.850
direct sharing capabilities.

00:15:26.180 --> 00:15:30.060
So again, like we saw earlier,
the key to fixing this and

00:15:30.060 --> 00:15:33.050
making sure that we don't run
into problems is consistency.

00:15:33.060 --> 00:15:36.060
We'll read what we wrote.

00:15:36.060 --> 00:15:38.060
If we wrote a 32-bit
value out to this file,

00:15:38.060 --> 00:15:41.060
then we should be reading
in a 32-bit value.

00:15:41.060 --> 00:15:44.510
If we wrote out a 64-bit value,
then we should be reading

00:15:44.510 --> 00:15:46.000
in a 64-bit value.

00:15:46.390 --> 00:15:49.580
There are a couple of approaches
that you might take to this.

00:15:49.580 --> 00:15:52.760
You could decide, for example,
that your app will always only ever

00:15:52.760 --> 00:15:56.580
write 32‑bit values out to the file,
regardless of what

00:15:56.580 --> 00:15:58.300
kind of device it's on.

00:15:58.300 --> 00:16:02.420
Or it could take the opposite approach of
always deciding to write 64‑bit values,

00:16:02.420 --> 00:16:04.700
again,
regardless of the device you're on.

00:16:04.850 --> 00:16:08.390
The third approach is that you could
be a bit more dynamic about it,

00:16:08.390 --> 00:16:11.350
where when you create a file,
you would include some extra

00:16:11.690 --> 00:16:16.090
metadata to indicate that the values
in this file are 32‑bit values,

00:16:16.090 --> 00:16:18.660
and so they should be
read in as 32‑bit values.

00:16:18.680 --> 00:16:21.970
Or perhaps that the values
are instead 64‑bit values,

00:16:21.970 --> 00:16:25.320
and therefore that you
should read in 64‑bit values.

00:16:25.360 --> 00:16:28.700
These are all great approaches,
and you should pick the best one that

00:16:28.770 --> 00:16:30.700
is appropriate for your scenario.

00:16:30.700 --> 00:16:34.400
So that's how 64‑bit affects
your app on the disk.

00:16:35.260 --> 00:16:38.060
Finally, 64‑bit in memory.

00:16:38.060 --> 00:16:41.780
Now, because pointers are twice
as large as they used to be,

00:16:41.960 --> 00:16:43.390
you will use more memory.

00:16:43.400 --> 00:16:44.480
That is unavoidable.

00:16:44.480 --> 00:16:46.520
You cannot escape pointers.

00:16:46.520 --> 00:16:51.420
And you may think that to avoid this
overhead of all of your pointers

00:16:51.420 --> 00:16:57.340
doubling in size that you will decide
to leave your app as a 32‑bit app.

00:16:57.410 --> 00:17:00.180
And this sounds nice at first.

00:17:00.200 --> 00:17:03.650
But there's actually a very ‑‑

00:17:05.110 --> 00:17:09.080
Interesting gotcha with this scenario.

00:17:09.330 --> 00:17:14.300
And it has to do with how the
operating system is implemented.

00:17:14.320 --> 00:17:18.270
So let's consider this gray box
to represent how much memory we

00:17:18.270 --> 00:17:20.580
have available on an iOS device.

00:17:20.800 --> 00:17:23.230
Now, obviously,
some of this memory is going to be

00:17:23.290 --> 00:17:26.840
taken up by the operating system
itself in order for the device to run.

00:17:26.840 --> 00:17:30.310
And as part of the operating
system's execution,

00:17:30.310 --> 00:17:35.260
it will be launching other applications,
such as checking for email,

00:17:35.260 --> 00:17:38.160
connecting to iMessage, et cetera.

00:17:38.160 --> 00:17:43.010
So these all take up
resources in RAM as well.

00:17:43.200 --> 00:17:45.270
One of the other things
that we load into this,

00:17:45.300 --> 00:17:48.800
into memory, is something that we call
the shared frameworks cache.

00:17:48.800 --> 00:17:55.500
The shared frameworks cache is a single
copy of the standard system frameworks.

00:17:55.500 --> 00:18:00.580
UI kit, foundation, core foundation,
CF network, and so on.

00:18:00.630 --> 00:18:04.650
And the purpose of the shared
frameworks cache is to provide a

00:18:04.650 --> 00:18:09.950
single location where any app that
we launch can just be pointed to use

00:18:09.950 --> 00:18:13.080
that particular copy of the frameworks
instead of just using the app itself.

00:18:13.100 --> 00:18:16.150
So we have each copy of the app,
or each app needing its

00:18:16.410 --> 00:18:18.230
own copy of the framework.

00:18:18.230 --> 00:18:21.670
But I want to point out
that on a 64‑bit device,

00:18:21.670 --> 00:18:27.300
the shared frameworks cache by default
is the 64‑bit copy of the frameworks.

00:18:27.330 --> 00:18:31.660
Which means that when we load
a 32‑bit app into memory,

00:18:31.660 --> 00:18:36.580
we first have to load a second copy
of the shared frameworks cache.

00:18:36.580 --> 00:18:41.850
A second copy of UI kit,
a second copy of foundation, and so on.

00:18:42.180 --> 00:18:43.080
Just for this one thing.

00:18:43.110 --> 00:18:45.100
So we load a 32‑bit app.

00:18:45.100 --> 00:18:49.610
And only after we load the second copy
of the shared frameworks can we actually

00:18:49.920 --> 00:18:52.700
load this 32‑bit app into memory.

00:18:52.720 --> 00:18:56.300
Loading a second copy of the
frameworks means that your app

00:18:56.380 --> 00:19:00.590
is much more likely to run into a
scenario of constrained memory and

00:19:00.590 --> 00:19:02.840
getting a memory pressure warning.

00:19:02.850 --> 00:19:03.820
So how do we avoid this?

00:19:03.820 --> 00:19:06.220
The answer is simple, of course.

00:19:06.220 --> 00:19:08.910
Recompile your app for 64‑bit.

00:19:09.000 --> 00:19:11.220
And then don't incur the overhead.

00:19:11.860 --> 00:19:25.620
: That's 64‑bit in memory.

00:19:25.620 --> 00:19:25.620
That covers a large part of the
issues that will arise in 64‑bit,

00:19:25.620 --> 00:19:25.620
the ones that we feel
will be the most common.

00:19:25.650 --> 00:19:28.970
Of course,
the final step of adopting 64‑bit

00:19:28.970 --> 00:19:31.200
is to test all of these changes.

00:19:31.200 --> 00:19:33.750
By making these changes, you are,
however slightly,

00:19:33.760 --> 00:19:36.240
altering the functionality
of your application.

00:19:36.240 --> 00:19:38.840
And so you should be
testing these changes,

00:19:38.900 --> 00:19:42.960
both in the simulator and on a device,
to make sure that your app still

00:19:43.010 --> 00:19:44.900
behaves as you expect it to.

00:19:45.280 --> 00:19:50.510
This is a great place to use the new
continuous integration feature of

00:19:50.610 --> 00:19:56.010
Xcode 5 and OS X Server for Mavericks
so that you can have your server run

00:19:56.010 --> 00:20:02.010
your unit tests and make sure that the
changes that you have made are valid.

00:20:02.420 --> 00:20:07.720
So there are a lot more nitty-gritty
details to the 64-bit transition.

00:20:07.720 --> 00:20:10.940
There's a really fantastic
guide in the documentation

00:20:10.940 --> 00:20:12.640
that I encourage you to read.

00:20:12.650 --> 00:20:18.020
It goes into some of the much more
edge cases of the 64-bit transition,

00:20:18.020 --> 00:20:20.260
ones that we feel most
people won't run into,

00:20:20.280 --> 00:20:27.150
such as having to use function pointers
that take variadic arguments and so on.

00:20:27.360 --> 00:20:31.950
But we feel that this covers
the majority of cases.

00:20:32.130 --> 00:20:35.560
We also believe that this will
be a relatively straightforward

00:20:35.560 --> 00:20:36.940
transition for you.

00:20:36.960 --> 00:20:40.490
Many of the developers that we've
talked to so far who have performed

00:20:40.610 --> 00:20:45.080
this transition have reported back that
this is a relatively painless process.

00:20:45.090 --> 00:20:49.580
One developer even reported that the
whole thing took only about five minutes.

00:20:49.870 --> 00:20:54.720
This is probably on
the best possible case.

00:20:54.720 --> 00:20:58.470
Might take a little bit longer for you,
maybe 15, no.

00:20:58.660 --> 00:21:01.940
Hopefully you've been following
all of these patterns all along,

00:21:02.070 --> 00:21:03.300
just as you should have been.

00:21:03.440 --> 00:21:07.020
Now there's one other aspect of the
new hardware that I wanna talk about,

00:21:07.020 --> 00:21:08.600
and that's the M7.

00:21:08.740 --> 00:21:13.200
The M7, as you're probably aware,
is a brand new chip in the iPhone 5S

00:21:13.250 --> 00:21:17.700
that is dedicated to monitoring motion.

00:21:17.830 --> 00:21:20.560
So we have taken the accelerometer,
gyroscope,

00:21:20.560 --> 00:21:25.880
and compass sensors and embedded them
in a single chip that we can keep

00:21:25.880 --> 00:21:28.670
running for very cheaply all the time.

00:21:28.850 --> 00:21:33.720
We can use this data to now infer
things about how the user is moving.

00:21:33.840 --> 00:21:39.240
So for example, an iPhone 5S in my pocket
would say that I am walking,

00:21:39.240 --> 00:21:42.100
right,
'cause I keep on walking back and forth,

00:21:42.100 --> 00:21:44.220
as opposed to standing still.

00:21:44.310 --> 00:21:48.160
It's very easy to use the
capabilities of the M7.

00:21:48.260 --> 00:21:51.850
You just keep on using the accelerometer
and gyroscope and compass like you

00:21:51.850 --> 00:21:54.190
have been for the past couple of years.

00:21:54.460 --> 00:21:57.200
But there are a couple new features
that you can take advantage of.

00:21:57.210 --> 00:22:00.180
Like I said,
we can now track the user's motion,

00:22:00.190 --> 00:22:04.370
and for that you would use the
CM Motion Activity Manager.

00:22:04.580 --> 00:22:07.860
Through the Motion Activity Manager,
you can request for updates

00:22:08.100 --> 00:22:10.880
on the user's motion,
so you can be notified when they stop

00:22:10.880 --> 00:22:14.780
walking and are now standing still,
when they start driving the car,

00:22:14.780 --> 00:22:18.820
or at least are in an automobile,
when they're running, and so on.

00:22:18.830 --> 00:22:20.900
And you can also request historical data.

00:22:21.020 --> 00:22:25.020
We keep up to seven days of
historical data on the device.

00:22:25.020 --> 00:22:30.400
And we saw how this can be really
awesome for a first launch experience.

00:22:30.420 --> 00:22:33.800
Like, if you've got a device that
relies on this sort of data,

00:22:33.820 --> 00:22:37.500
you can, the very first time the
user launches your app,

00:22:37.520 --> 00:22:42.090
request up to seven days' worth of data
and immediately start presenting the user

00:22:42.420 --> 00:22:45.120
with useful and relevant information.

00:22:45.150 --> 00:22:47.590
The Motion Activity
Manager is simple to use.

00:22:47.700 --> 00:22:52.000
You simply allocate a new
instance and ask it for updates.

00:22:52.000 --> 00:22:54.410
You provide a block,
and it is through this block that

00:22:54.410 --> 00:22:58.140
we give you a motion activity
object that contains information

00:22:58.140 --> 00:23:00.120
about the user's current motion.

00:23:00.130 --> 00:23:04.650
Now, the other thing that we've got
thanks to the M7 is step counting.

00:23:04.740 --> 00:23:08.240
Like the Motion Activity Manager,
it is also extremely simple to use.

00:23:08.280 --> 00:23:10.800
It's almost the exact same code,
except instead of a

00:23:10.800 --> 00:23:13.280
Motion Activity Manager,
it is called a step counter.

00:23:13.470 --> 00:23:17.480
But again,
you can start asking for updates,

00:23:17.480 --> 00:23:19.420
provide a block,
and we will invoke this block

00:23:19.810 --> 00:23:22.320
as the user takes steps.

00:23:22.320 --> 00:23:27.460
So that was a brief look at the M7,
and of course, the A7,

00:23:27.460 --> 00:23:30.660
and what it takes to
adopt 64-bit for your app.

00:23:30.660 --> 00:23:31.040
Let's talk now about the M7.

00:23:31.040 --> 00:23:34.080
We're now about building
an app for iOS 7.

00:23:34.080 --> 00:23:37.820
We learned about some of the
great new features of iOS 7,

00:23:37.830 --> 00:23:41.680
such as custom transitions,
or UIKit dynamics, or TextKit.

00:23:41.680 --> 00:23:45.360
And we've heard in the
past that many developers,

00:23:45.360 --> 00:23:47.920
they can adopt these new
technologies while still

00:23:47.920 --> 00:23:49.920
maintaining backwards compatibility.

00:23:49.920 --> 00:23:51.960
We get this question a lot.

00:23:51.980 --> 00:23:54.950
How do I use these features,
but still support an

00:23:54.960 --> 00:23:56.330
older operating system?

00:23:56.800 --> 00:24:00.860
And many developers,
of course none of you,

00:24:00.860 --> 00:24:03.540
but many developers are under
the impression that you can't,

00:24:03.540 --> 00:24:08.330
that if you want to use new features,
that you must only support

00:24:08.410 --> 00:24:09.980
that operating system.

00:24:09.980 --> 00:24:14.300
We saw this very significantly
with the introduction of iOS

00:24:14.390 --> 00:24:20.270
6 and UI Collection View,
where many developers refused to

00:24:20.270 --> 00:24:25.590
use UI Collection View because
they still had to support iOS 5.

00:24:25.720 --> 00:24:27.950
In this session,
in this part of the talk,

00:24:27.950 --> 00:24:31.600
we're going to learn how you can
use all of these great new features,

00:24:31.600 --> 00:24:34.480
but still support iOS 6.

00:24:34.570 --> 00:24:36.040
It's totally possible.

00:24:36.040 --> 00:24:36.940
I promise you can do it.

00:24:37.030 --> 00:24:39.350
There are two parts to this answer.

00:24:39.350 --> 00:24:43.460
First, of course,
you must use the iOS 7 base SDK.

00:24:43.580 --> 00:24:47.340
If you want iOS 7 features,
you have to use the iOS 7 SDK.

00:24:47.340 --> 00:24:48.410
That's easy.

00:24:48.900 --> 00:24:52.130
The second part of this answer
is before you use a feature,

00:24:52.130 --> 00:24:53.630
check to see if it exists.

00:24:53.640 --> 00:24:56.740
If it does exist, of course,
you're welcome to use it.

00:24:56.880 --> 00:25:00.370
If it does not, you shouldn't use it
because it's not there.

00:25:00.380 --> 00:25:04.480
We feel that part of this
misunderstanding about using new

00:25:04.480 --> 00:25:10.180
features comes from not understanding
the relationship between the base SDK and

00:25:10.180 --> 00:25:13.460
the deployment target of an application.

00:25:13.460 --> 00:25:15.120
So we're going to review
these really quickly.

00:25:15.120 --> 00:25:18.010
The base SDK is the foundation.

00:25:18.780 --> 00:25:21.060
The technological foundation of your app.

00:25:21.140 --> 00:25:25.820
When your app runs on a device
that corresponds to your base SDK,

00:25:25.830 --> 00:25:30.880
it should be the full feature experience,
the best that you can possibly do.

00:25:30.880 --> 00:25:34.540
This value is actually encoded
into your application binary.

00:25:34.540 --> 00:25:37.950
It's in the header of your
executable that we saw earlier.

00:25:37.960 --> 00:25:42.700
And we encode the value that you
use for your base SDK so that

00:25:42.700 --> 00:25:48.460
devices that run your app can
intelligently choose how they behave.

00:25:48.660 --> 00:25:49.750
Amen.

00:25:49.850 --> 00:25:53.340
If you think about it,
an app that's compiled with the iOS

00:25:53.340 --> 00:26:01.280
6 SDK is not expecting the iOS 7 look
and feel when run on an iOS 7 device.

00:26:01.280 --> 00:26:03.930
And if you run an iOS 6
app on an iOS 7 device,

00:26:03.930 --> 00:26:06.040
that's, of course, what you see.

00:26:06.040 --> 00:26:10.400
You see it still looking and
behaving like an iOS 6 app.

00:26:10.400 --> 00:26:16.600
And that's because the framework inspects
this value that's encoded in the header,

00:26:16.610 --> 00:26:21.920
what value you used or what
SDK you used to compile the app.

00:26:22.020 --> 00:26:24.000
And it conditionally alters its behavior.

00:26:24.000 --> 00:26:29.180
It says, if this app was built
for iOS 6 but not iOS 7,

00:26:29.270 --> 00:26:34.560
then I'm still going to take the old code
paths and behave like an iOS 6 framework.

00:26:34.580 --> 00:26:37.100
Now, for your apps, this, of course,
should be set,

00:26:37.160 --> 00:26:40.900
the base SDK should be set to use
the latest iOS SDK so that you can

00:26:41.190 --> 00:26:47.010
take advantage of all of the great
new features in the iOS 7 SDK.

00:26:47.230 --> 00:26:51.070
But that does not mean you
give up support for iOS 6.

00:26:51.110 --> 00:26:52.840
That's what your deployment target is.

00:26:52.970 --> 00:26:56.370
You should be setting your
deployment target to iOS 6.

00:26:56.480 --> 00:27:00.660
As we saw this morning,
96% of iOS users are

00:27:01.020 --> 00:27:03.660
running on iOS 6 or iOS 7.

00:27:03.660 --> 00:27:08.180
It's not really worth your time to
focus on the 4%. Dave DeLoong The way

00:27:08.240 --> 00:27:11.220
to look at this visually is we've got
this history of iOS releases here.

00:27:11.220 --> 00:27:15.460
If we wanted to build an app
that supports iOS 6 and iOS 7,

00:27:15.860 --> 00:27:23.480
then we would set our base SDK to be iOS
7 and our deployment target to be iOS 6.

00:27:23.480 --> 00:27:26.030
They represent a minimum
and maximum value.

00:27:26.030 --> 00:27:31.080
So that's just a quick reminder as to
what the SDK and deployment target are.

00:27:31.100 --> 00:27:34.190
Dave DeLoong Going back now to how
do we adopt these new features?

00:27:34.190 --> 00:27:37.440
How do we check to see if a feature
exists before we try to use it?

00:27:37.440 --> 00:27:40.080
Dave DeLoong Well,
there are a couple of different kinds

00:27:40.080 --> 00:27:42.880
of features that you might check for.

00:27:42.890 --> 00:27:45.710
New frameworks and new classes,
new methods,

00:27:45.710 --> 00:27:51.090
new device and system capabilities,
whole lot of new designs, and of course,

00:27:51.090 --> 00:27:53.330
new device architectures.

00:27:53.380 --> 00:27:56.960
First up, how do we adopt a new
framework or a new class?

00:27:56.960 --> 00:27:59.350
In iOS 7,
we have a brand‑new framework called

00:27:59.390 --> 00:28:03.700
Game Controller that allows your games
to interact with external hardware,

00:28:04.130 --> 00:28:09.300
such as, you know,
a game controller that contains a D‑pad,

00:28:09.350 --> 00:28:12.770
so that users can play your
games with physical devices,

00:28:12.830 --> 00:28:14.460
with physical buttons.

00:28:14.480 --> 00:28:18.620
Now, in order to use this, you,
of course, would need to link against

00:28:18.700 --> 00:28:21.240
the Game Controller framework.

00:28:21.240 --> 00:28:23.740
And by default,
the Game Controller framework

00:28:23.810 --> 00:28:27.620
will be a required framework,
which means that your app will refuse to

00:28:27.780 --> 00:28:30.210
launch if Game Controller is not present.

00:28:30.220 --> 00:28:33.370
Now, that's not what we want,
because we still want our

00:28:33.370 --> 00:28:37.220
app to launch on iOS 6,
where Game Controller did not exist.

00:28:37.220 --> 00:28:41.510
So in order to do that,
we need to go to our link binary

00:28:41.510 --> 00:28:44.110
with libraries build phase.

00:28:44.160 --> 00:28:48.030
And change Game Controller from
being a required framework to

00:28:48.130 --> 00:28:50.100
being an optional framework.

00:28:51.720 --> 00:28:54.560
By changing this
framework to be optional,

00:28:54.560 --> 00:28:58.080
we are allowing our app to
continue launching even if

00:28:58.080 --> 00:29:00.480
game controller is not present.

00:29:00.560 --> 00:29:02.760
So this is how we can
adopt a new framework.

00:29:02.820 --> 00:29:05.800
We make the framework optional.

00:29:06.230 --> 00:29:08.100
What about in code?

00:29:08.100 --> 00:29:11.000
What about all those game controller
classes that we'll need to use?

00:29:11.000 --> 00:29:11.900
What happens to those?

00:29:12.200 --> 00:29:16.150
Here's a snippet of one way that
we might use the game controller

00:29:16.150 --> 00:29:20.490
framework to start listening
for wireless game controllers.

00:29:20.670 --> 00:29:22.670
Now, of course,
this will work fine on iOS 7

00:29:22.670 --> 00:29:24.420
because game controller exists.

00:29:24.580 --> 00:29:26.510
But what about iOS 6?

00:29:26.510 --> 00:29:30.410
What happens with that
GC controller class?

00:29:30.690 --> 00:29:34.490
When you specify that a
framework is optional,

00:29:34.650 --> 00:29:38.160
what happens is when your
app is loaded into memory,

00:29:38.160 --> 00:29:42.590
part of that loading process is
that the system will go through

00:29:42.590 --> 00:29:46.010
and find all of these symbols,
these class names and

00:29:46.070 --> 00:29:48.930
constants that you're using,
and it will resolve them.

00:29:48.970 --> 00:29:54.090
It will either point them at the
correct place to wherever they exist

00:29:54.190 --> 00:30:00.100
in whatever framework they're from,
or if they're not there, they become nil.

00:30:00.490 --> 00:30:03.350
And I hope you all know that
it is totally safe to send

00:30:03.350 --> 00:30:05.200
messages to nil in Objective-C.

00:30:05.200 --> 00:30:08.720
We're not like other languages where
we might crash your application.

00:30:08.720 --> 00:30:11.200
On iOS 6,
this is no problem at all because

00:30:11.200 --> 00:30:13.610
this line of code simply does nothing.

00:30:13.620 --> 00:30:17.400
So this code, as is,
without any modification,

00:30:17.670 --> 00:30:20.440
will work fine on iOS 6 and iOS 7.

00:30:20.440 --> 00:30:26.100
But this behavior of things becoming nil
can have some unintended side effects.

00:30:27.130 --> 00:30:29.960
For example, another part of the game
controller framework is to listen

00:30:29.960 --> 00:30:31.460
for a particular notification.

00:30:31.480 --> 00:30:34.320
The GC controller did
connect notification.

00:30:34.320 --> 00:30:38.410
This notification is posted, obviously,
when a controller is actually

00:30:38.410 --> 00:30:39.990
connected to the device.

00:30:40.000 --> 00:30:42.980
Now, on iOS 7, this works.

00:30:42.980 --> 00:30:47.390
And as we saw on iOS 6,
this GC controller did connect

00:30:47.390 --> 00:30:50.810
notification symbol would become nil.

00:30:52.180 --> 00:30:56.340
And that might sound nice,
but this particular code

00:30:56.650 --> 00:30:59.130
has unintended side effects.

00:30:59.340 --> 00:31:03.850
As it so happens,
if you listen for a nil notification

00:31:03.850 --> 00:31:08.650
name coming from a nil object,
you will actually be notified

00:31:08.650 --> 00:31:13.450
about every single notification
for any name posted by any object.

00:31:13.520 --> 00:31:17.290
And that is a lot of notifications.

00:31:17.610 --> 00:31:19.870
This is probably not what you want.

00:31:21.780 --> 00:31:25.380
Dave DeLoong If we want to use
this particular notification,

00:31:25.380 --> 00:31:27.690
we need to check to see
if the symbol exists.

00:31:27.830 --> 00:31:32.260
And we do that by checking to see
if the address of the notification

00:31:32.260 --> 00:31:34.260
symbol itself is not nil.

00:31:34.260 --> 00:31:39.860
If the address is not zero or is not nil,
then it is safe to use it.

00:31:39.920 --> 00:31:43.180
If it is nil,
then obviously don't try to use it.

00:31:43.240 --> 00:31:47.260
Dave DeLoong So these are how we can
adopt new classes and new frameworks.

00:31:47.330 --> 00:31:49.060
We make new frameworks be optional.

00:31:49.060 --> 00:31:51.760
Dave DeLoong And for new
class names or new classes,

00:31:51.760 --> 00:31:51.760
we make them optional.

00:31:51.760 --> 00:31:54.400
Dave DeLoong And for new symbols,
we simply check to see

00:31:54.650 --> 00:31:56.080
if they're nil or not.

00:31:56.130 --> 00:31:57.680
Dave DeLoong Adopting new methods.

00:31:57.730 --> 00:32:00.240
So earlier,
we learned about UI motion effect and

00:32:00.350 --> 00:32:05.990
how we can use UI motion effect to add
that hint of depth to our user interface.

00:32:06.050 --> 00:32:10.270
We do that using this method on UIView,
add motion effect.

00:32:10.330 --> 00:32:13.970
This of course is a new method in iOS 7,
works great.

00:32:14.040 --> 00:32:19.460
But on iOS 6 this will crash your app,
because UIView knows nothing about

00:32:19.500 --> 00:32:22.160
the addMotionEffect method on iOS 6.

00:32:22.420 --> 00:32:25.960
Now we can't do a nil check here
because of course UIView exists.

00:32:25.960 --> 00:32:28.120
It's just this method that doesn't.

00:32:28.310 --> 00:32:32.880
So what we do here is we use a
method that's on all NSObjects

00:32:32.880 --> 00:32:35.620
called respondsToSelector.

00:32:35.650 --> 00:32:39.860
This is a method where you pass
in the name of another method,

00:32:39.880 --> 00:32:44.320
and it will return yes or no to indicate
if that particular method exists.

00:32:44.320 --> 00:32:48.840
So if our view responds to
the addMotionEffect selector,

00:32:48.840 --> 00:32:50.280
then of course it's safe to use.

00:32:50.280 --> 00:32:53.300
And if it doesn't, we shouldn't.

00:32:53.450 --> 00:32:56.380
We like it when our apps do not crash.

00:32:56.480 --> 00:32:58.990
So this is how we can
safely adopt new methods.

00:32:59.130 --> 00:33:02.300
Just check to see if they exist,
using response to selector.

00:33:02.350 --> 00:33:04.760
There are times when we
add new capabilities,

00:33:04.830 --> 00:33:08.000
both to the operating
system and the hardware.

00:33:08.040 --> 00:33:11.790
We just learned about the
CM Motion Activity Manager.

00:33:11.900 --> 00:33:18.050
And while this is a new class in iOS 7,
it's really only useful on a

00:33:18.050 --> 00:33:21.400
device that contains the M7 chip.

00:33:21.680 --> 00:33:25.820
And so if we wanted to use
the Motion Activity Manager,

00:33:25.870 --> 00:33:28.820
checking to see if
CM Motion Activity Manager is nil

00:33:28.820 --> 00:33:32.560
or not is an insufficient check,
because it could be non-nil,

00:33:32.560 --> 00:33:35.560
but still not be able to
track the user's motion.

00:33:35.630 --> 00:33:39.140
And so when we add new
capabilities to the hardware or

00:33:39.140 --> 00:33:43.670
new capabilities to the software,
we also provide a corresponding check

00:33:43.790 --> 00:33:45.570
to see if those features are available.

00:33:45.710 --> 00:33:48.970
So we can check to see if we
can track the user's motion.

00:33:49.190 --> 00:33:52.800
We can check to see if they can send
email or if they're able to print,

00:33:52.940 --> 00:33:56.700
if they can monitor for certain
kinds of location regions.

00:33:56.750 --> 00:34:01.710
We can even check to see if iCloud is
enabled using the NS File Manager API.

00:34:01.970 --> 00:34:05.570
In general,
these methods usually return a Boolean,

00:34:05.570 --> 00:34:08.630
which means they're very easy
to use as the condition to

00:34:08.630 --> 00:34:12.860
an if statement like this,
where if this motion tracking

00:34:12.940 --> 00:34:15.430
activity is available,
then of course it's safe to

00:34:15.540 --> 00:34:17.480
create a Motion Activity Manager.

00:34:17.540 --> 00:34:21.160
This is how we can safely adopt
new capabilities while still

00:34:21.160 --> 00:34:22.970
maintaining backwards compatibility.

00:34:23.170 --> 00:34:26.680
Now in iOS 7,
we have adopted a brand new design

00:34:26.680 --> 00:34:28.570
language in our applications.

00:34:28.610 --> 00:34:31.700
And you may be wondering,
what's the best way to check for that?

00:34:31.700 --> 00:34:35.460
That's not something that's really
tied to a capability of the hardware,

00:34:35.530 --> 00:34:38.300
and it's not really something
that's tied to any particular

00:34:38.420 --> 00:34:40.420
new class or new method.

00:34:40.650 --> 00:34:44.900
And the way we've seen some developers
try to figure this out in the past is

00:34:44.900 --> 00:34:49.440
doing something like taking the system
version string and trying to parse it

00:34:49.440 --> 00:34:53.680
as a number and comparing it to see
if it's larger than 6.1 or something.

00:34:53.680 --> 00:34:56.250
And that'll probably work.

00:34:56.350 --> 00:34:57.630
It's a little gross.

00:34:57.750 --> 00:35:00.210
But there's a much better way to do it.

00:35:00.290 --> 00:35:02.960
And that is using the
NS Foundation version number

00:35:02.960 --> 00:35:06.230
constant in the Foundation framework.

00:35:06.350 --> 00:35:09.540
This is a constant that's
been in the framework since,

00:35:09.560 --> 00:35:13.710
well, Mac OS 10.0 and thus iOS 1, really.

00:35:13.790 --> 00:35:16.920
And for every major release
of the operating system,

00:35:17.030 --> 00:35:20.680
pretty much, we've been updating this
Foundation version number.

00:35:20.820 --> 00:35:25.960
And we've also been providing known
or well-defined version numbers for

00:35:25.960 --> 00:35:31.580
what the particular version was of the
framework for a particular release.

00:35:31.860 --> 00:35:35.350
And so you can use this
Foundation version number to compare

00:35:35.350 --> 00:35:39.060
it to these well-known values,
like this.

00:35:39.280 --> 00:35:41.870
You get the Foundation version number,
and you check to see,

00:35:41.870 --> 00:35:45.910
is it less than or equal to an iOS
6 style appearance for your app?

00:35:45.920 --> 00:35:48.940
If it's greater than this value,
then you would default to

00:35:48.940 --> 00:35:50.440
an iOS 7 style appearance.

00:35:50.440 --> 00:35:54.310
So this is the safest and best way
to check to see what version of the

00:35:54.320 --> 00:35:58.540
operating system you're on when that
particular check is appropriate.

00:35:58.540 --> 00:36:00.700
Finally, adopting new architectures.

00:36:00.700 --> 00:36:03.200
So we learned about a few minutes ago.

00:36:03.200 --> 00:36:07.200
We have the brand new
64-bit chip in some devices.

00:36:07.200 --> 00:36:10.560
And it's possible that you might
want to write code that is specially

00:36:10.560 --> 00:36:15.180
optimized to only run on 64-bit devices.

00:36:15.200 --> 00:36:20.360
And the easiest way to do that
is to authorize the system to

00:36:20.530 --> 00:36:23.660
affect how your app is compiled.

00:36:23.660 --> 00:36:26.550
We learned about these
different slices of your app,

00:36:26.570 --> 00:36:30.990
where your code will be compiled
one way for a 32-bit app and

00:36:30.990 --> 00:36:33.380
another way for a 64-bit app.

00:36:33.380 --> 00:36:40.000
Using this compiler directive,
this __LP64 directive,

00:36:40.000 --> 00:36:43.480
we can safely segment our code
such that only portions of it

00:36:43.480 --> 00:36:47.540
will be compiled for 64-bit,
and other portions would

00:36:47.540 --> 00:36:49.960
only be compiled for 32-bit.

00:36:49.960 --> 00:36:54.080
This is somewhat uncommon to use,
but we are seeing some developers

00:36:54.180 --> 00:36:59.550
who are wanting to take advantage of
the significant horsepower available

00:36:59.550 --> 00:37:05.560
via the A7 CPU and GPU to optimize
for those particular scenarios.

00:37:05.580 --> 00:37:08.100
And this is the best way to do that.

00:37:08.100 --> 00:37:11.180
So those are the main ways that
we would check for new features.

00:37:11.230 --> 00:37:13.490
But we're not done yet.

00:37:13.720 --> 00:37:19.320
: We could put these if checks
wherever we wanted in our code,

00:37:19.320 --> 00:37:24.270
but I want to talk now about how
we can successfully encapsulate and

00:37:24.270 --> 00:37:30.050
hide these checks in a way such that
only the people who really have to

00:37:30.050 --> 00:37:33.060
care about them know about them.

00:37:33.060 --> 00:37:39.170
Because if we were to scatter these
checks everywhere throughout our code,

00:37:39.170 --> 00:37:39.170
we would quickly

00:37:39.300 --> 00:37:43.250
We've come to a state in our
code base where our code is messy

00:37:43.250 --> 00:37:45.540
and unmaintainable and ugly.

00:37:45.580 --> 00:37:48.900
And code like that is
just not fun to work on.

00:37:48.900 --> 00:37:53.710
So we're going to learn about three
different ways that we can encapsulate

00:37:53.710 --> 00:37:58.640
these feature checks in a way that
makes them easy to use and beautiful.

00:37:58.730 --> 00:38:00.600
The first way is using a class cluster.

00:38:00.600 --> 00:38:04.920
If you're not familiar with this term,
it's a pretty straightforward concept.

00:38:05.040 --> 00:38:09.150
A class cluster is a class
that has a single interface

00:38:09.300 --> 00:38:11.290
that is not a single interface,
but multiple implementations.

00:38:11.290 --> 00:38:13.060
Now, this isn't magic.

00:38:13.060 --> 00:38:16.300
It's really just using
private subclasses.

00:38:16.390 --> 00:38:22.300
And this is actually a really
common pattern in our frameworks.

00:38:22.370 --> 00:38:27.190
Anytime you use almost any object
from the foundation framework or many

00:38:27.190 --> 00:38:31.500
objects even from the UI kit framework,
you are likely dealing

00:38:31.500 --> 00:38:33.300
with a class cluster.

00:38:33.450 --> 00:38:38.300
This allows us as framework
implementers to optimize what

00:38:38.300 --> 00:38:38.300
version of the framework we're using.

00:38:38.300 --> 00:38:40.300
Dave DeLoong So the common example,
of course, is for NSArray.

00:38:40.300 --> 00:38:46.430
If you have an array that is
never going to be changed,

00:38:46.430 --> 00:38:52.250
we will give you one
implementation of NSArray.

00:38:52.250 --> 00:38:55.650
But if you have one that will
be changed and is thus mutable,

00:38:55.650 --> 00:38:57.300
we will give you a
different implementation.

00:38:57.300 --> 00:39:00.300
But we even go beyond that.

00:39:00.300 --> 00:39:04.700
We can look to see if you're going
to be putting hundreds of thousands

00:39:04.700 --> 00:39:08.350
of objects into a mutable array,
we might even give you a

00:39:08.350 --> 00:39:09.300
different implementation.

00:39:09.300 --> 00:39:14.300
One that is optimized for
much larger data sets.

00:39:14.300 --> 00:39:17.660
And the beautiful thing about
class clusters is that none

00:39:17.660 --> 00:39:19.120
of this is exposed to you.

00:39:19.300 --> 00:39:21.800
You don't have to worry about
whether you're putting three objects

00:39:21.850 --> 00:39:23.300
into this array or three million.

00:39:23.300 --> 00:39:27.190
All of that is hidden from you.

00:39:27.460 --> 00:39:29.960
Class clusters make this easy to do.

00:39:29.960 --> 00:39:33.560
Class clusters are a great
way to encapsulate feature

00:39:33.560 --> 00:39:38.280
checks related to new classes,
version checks, and capabilities,

00:39:38.280 --> 00:39:40.030
or even architectures.

00:39:40.050 --> 00:39:43.240
And as we'll see,
it is extremely easy to remove

00:39:43.240 --> 00:39:45.780
obsolete code with class clusters.

00:39:45.880 --> 00:39:48.040
So let's go through an example.

00:39:48.040 --> 00:39:51.880
Let's say I'm writing an app
that downloads something.

00:39:51.880 --> 00:39:56.900
Maybe it's levels for a game or it's
movies for displaying to the user.

00:39:57.430 --> 00:40:00.070
In order to perform these downloads,
I'm going to create a

00:40:00.070 --> 00:40:01.300
download controller.

00:40:01.300 --> 00:40:05.400
And this is an object that I'm just
simply going to say here is a download.

00:40:05.400 --> 00:40:08.390
I want you to begin it
or pause it or resume it.

00:40:08.400 --> 00:40:10.900
And our other code will do just that.

00:40:11.050 --> 00:40:15.230
We'll interact with this download
controller and say begin this,

00:40:15.230 --> 00:40:17.890
pause that, resume this, and so on.

00:40:18.370 --> 00:40:22.830
We want to use a class cluster to
implement our download controller.

00:40:22.830 --> 00:40:27.490
In iOS 7, we have this great new API with
NSURL session for being able to

00:40:27.490 --> 00:40:30.110
perform downloads in the background.

00:40:30.110 --> 00:40:32.860
So even after the user
stops using our app,

00:40:32.860 --> 00:40:35.550
we can still continue their downloads.

00:40:35.550 --> 00:40:37.610
We could not do this on iOS 6.

00:40:37.610 --> 00:40:40.920
We could kind of approximate
downloads like that,

00:40:40.920 --> 00:40:43.280
of course, with NSURL connection.

00:40:43.370 --> 00:40:48.280
And so we want to fall back to that
API if the newer one is not working.

00:40:48.300 --> 00:40:52.620
So we're going to make download
controller actually a class cluster.

00:40:52.620 --> 00:40:56.170
We will have two private subclasses,
one for the new API and

00:40:56.170 --> 00:40:57.660
one for the old API.

00:40:57.660 --> 00:40:58.930
Dave DeLoong

00:40:59.430 --> 00:41:02.940
Now, the interface for our download
controller is really simple.

00:41:02.970 --> 00:41:06.070
We have a convenience constructor
for creating a new instance,

00:41:06.270 --> 00:41:11.170
and then we have just simple methods
to start or pause or resume a download.

00:41:11.700 --> 00:41:14.360
The implementation is
where it gets interesting.

00:41:14.420 --> 00:41:17.980
As I said,
we have these two private subclasses.

00:41:17.980 --> 00:41:22.400
One is a download controller that's
specific to the NSURL session API.

00:41:22.560 --> 00:41:26.780
And then the other is a download
controller that's specific

00:41:26.780 --> 00:41:28.910
to the NSURL connection API.

00:41:29.000 --> 00:41:32.080
Then when we're asked to
create a download controller,

00:41:32.080 --> 00:41:33.960
we perform our feature check.

00:41:34.090 --> 00:41:38.920
We see does NSURL session exist?

00:41:39.140 --> 00:41:43.320
If it does, then I know that the new
API is available to me.

00:41:43.320 --> 00:41:46.900
And so I will create the
download controller that

00:41:46.900 --> 00:41:48.990
is able to use the new API.

00:41:48.990 --> 00:41:51.940
If it doesn't exist,
then of course I will default

00:41:52.030 --> 00:41:54.160
back to supporting the older API.

00:41:54.160 --> 00:41:57.740
I don't get as many features,
but I can still perform downloads.

00:41:57.920 --> 00:42:00.130
That's the basic idea of a class cluster.

00:42:00.460 --> 00:42:02.980
Nobody who's using the
download controller actually

00:42:02.980 --> 00:42:04.630
knows that this is going on.

00:42:04.630 --> 00:42:07.220
They just see download controller.

00:42:07.220 --> 00:42:10.260
They don't see the specifics
of how it's being performed.

00:42:10.260 --> 00:42:12.990
And maybe next year,
we decide to drop support

00:42:12.990 --> 00:42:15.950
for iOS 6 in our app,
which means we don't need the

00:42:16.020 --> 00:42:21.020
NSURL connection code anymore because
NSURL session will always be available.

00:42:21.020 --> 00:42:26.290
In this case, it is trivial to remove the
code that we don't need anymore.

00:42:26.300 --> 00:42:27.900
We simply delete a few.

00:42:27.920 --> 00:42:32.700
We don't have to go wandering all
around in our code base finding every

00:42:32.700 --> 00:42:38.280
single place where we were performing if
NSURL session class does not equal nil,

00:42:38.280 --> 00:42:42.620
then use an NSURL session,
else use an NSURL connection.

00:42:42.620 --> 00:42:47.910
We don't have to do that because we
successfully encapsulated this feature

00:42:48.340 --> 00:42:53.180
check in a way that only one person
or one object had to know about it.

00:42:53.300 --> 00:42:57.600
And so when we decide to make changes,
we only have to make it in one place.

00:42:57.870 --> 00:43:01.200
Another pattern is data sources,
or if you like the more technical term,

00:43:01.200 --> 00:43:02.880
this is the strategy pattern.

00:43:03.180 --> 00:43:06.690
Whereas class clusters solve
this problem through subclassing,

00:43:06.690 --> 00:43:10.100
data sources solve this
problem through composition.

00:43:10.100 --> 00:43:14.050
We have a data source object
that encapsulates the logic,

00:43:14.050 --> 00:43:18.420
and we can swap data sources in
and out to get different logic.

00:43:18.440 --> 00:43:22.310
And again, like class clusters,
this makes it very easy to

00:43:22.310 --> 00:43:26.220
encapsulate feature checks
related to new capabilities,

00:43:26.220 --> 00:43:27.420
new classes.

00:43:27.640 --> 00:43:32.040
And so let's decide now that we
want our download controller to

00:43:32.040 --> 00:43:35.080
actually use this data source pattern.

00:43:35.080 --> 00:43:37.960
Well, again,
we have the exact same interface

00:43:38.080 --> 00:43:40.080
for our download controller.

00:43:40.080 --> 00:43:41.980
It's the beauty of these patterns.

00:43:41.980 --> 00:43:45.030
We can change the
implementations wholesale,

00:43:45.270 --> 00:43:47.360
and the interface never changes.

00:43:47.360 --> 00:43:51.310
So what would this look
like in the M file?

00:43:51.320 --> 00:43:54.090
Well,
instead of having two private subclasses,

00:43:54.090 --> 00:43:57.340
we would actually have a
concrete download controller.

00:43:57.640 --> 00:44:02.910
But it would have a property for another
object that performs the downloads.

00:44:02.940 --> 00:44:05.040
In this case,
I've made it conform to a protocol,

00:44:05.140 --> 00:44:06.330
a downloader protocol.

00:44:06.360 --> 00:44:10.350
You can imagine that this is a
protocol that would define a start,

00:44:10.410 --> 00:44:12.810
a pause, a resume method, and so on.

00:44:12.880 --> 00:44:17.780
Then the download controller constructor
would again perform our feature check.

00:44:17.840 --> 00:44:24.200
If the NSURL session class is available,
then we will create a downloader data

00:44:24.200 --> 00:44:27.470
source that knows how to use the NSURL.

00:44:27.520 --> 00:44:27.620
So we can create a downloader data
source that knows how to use the NSURL.

00:44:27.620 --> 00:44:29.490
session API.

00:44:29.640 --> 00:44:33.860
If NSURL session is not available,
we will create a data source that knows

00:44:33.860 --> 00:44:37.260
how to use the NSURL connection API.

00:44:37.260 --> 00:44:42.980
And then we will finish the allocation of
an actual download controller by passing

00:44:43.110 --> 00:44:47.400
it a handle to this data source object,
this strategy object.

00:44:47.400 --> 00:44:53.350
And then when we ask the download
controller to pause or resume a download,

00:44:53.510 --> 00:44:58.630
all it really does is it turns
around and asks its downloader data

00:44:58.630 --> 00:45:01.480
source how to actually do that.

00:45:01.480 --> 00:45:04.000
And that way the download
controller doesn't have to

00:45:04.000 --> 00:45:05.480
worry about the specifics.

00:45:05.520 --> 00:45:09.470
It can leave those up to the downloader.

00:45:09.710 --> 00:45:12.290
Like class clusters,
when we no longer need

00:45:12.290 --> 00:45:15.840
our NSURL connection code,
it is trivial to remove it.

00:45:16.020 --> 00:45:19.740
Again, we just delete a few lines,
and now we've removed all traces

00:45:19.870 --> 00:45:23.370
of our NSURL connection code,
and nobody is the wiser for it

00:45:23.380 --> 00:45:25.280
in the entire rest of our app.

00:45:25.360 --> 00:45:28.120
We only had to modify code in one place.

00:45:28.120 --> 00:45:31.690
So, class clusters and data sources,
as I've been saying,

00:45:31.690 --> 00:45:35.960
make it very easy to encapsulate
feature checks related to new classes,

00:45:36.140 --> 00:45:39.630
new capabilities, new designs,
and new architectures.

00:45:39.810 --> 00:45:48.120
But they don't work very
well for new methods.

00:45:48.120 --> 00:45:48.120
For that, let's use a category.

00:45:49.030 --> 00:45:52.740
If you're unfamiliar with a category,
the basic idea is that you can

00:45:52.740 --> 00:45:58.890
use categories to add new methods
to classes that are not yours.

00:45:58.960 --> 00:46:01.560
So, for example,
if you really wanted a new

00:46:01.560 --> 00:46:05.030
method on NSString that,
you know, did something that's very

00:46:05.030 --> 00:46:08.800
specific to your application,
you could add that method to

00:46:08.800 --> 00:46:11.410
NSString itself using a category.

00:46:11.420 --> 00:46:15.300
Categories are an excellent
way to encapsulate feature

00:46:15.300 --> 00:46:17.690
checks related to new methods.

00:46:17.730 --> 00:46:22.940
So, we saw this example earlier that
trying to create a motion effect

00:46:22.940 --> 00:46:26.620
on iOS 6 and add it to a view
would cause a crash because the add

00:46:26.620 --> 00:46:28.720
motion effect method doesn't exist.

00:46:28.720 --> 00:46:33.370
Now, we could put the response
to selector check here.

00:46:33.370 --> 00:46:37.430
But we want to keep this code
very linear and easy to read.

00:46:37.440 --> 00:46:41.740
So, instead of putting the check here,
we're going to create a new method on

00:46:41.740 --> 00:46:46.540
UIView that will perform the check for us
and then forward on to the next method.

00:46:46.540 --> 00:46:54.800
So, we're going to create this category
to define a new method called

00:46:54.800 --> 00:46:59.170
TT underscore add motion effect.

00:46:59.580 --> 00:47:04.740
We've named this method such that
it's obvious what its purpose is.

00:47:04.740 --> 00:47:08.150
And we've given it a prefix to
make sure that we're never going to

00:47:08.150 --> 00:47:10.770
interfere with another method on UIView.

00:47:11.110 --> 00:47:14.020
The implementation of this
method is extremely simple.

00:47:14.160 --> 00:47:17.860
Here in this method,
we simply check to see does the view,

00:47:17.860 --> 00:47:22.630
or in this case self, respond to the add
motion effect selector.

00:47:22.700 --> 00:47:24.900
And of course, if it does,
then it is safe to

00:47:24.900 --> 00:47:26.320
invoke add motion effect.

00:47:26.530 --> 00:47:28.560
And if it doesn't,
then we'll just drop the message

00:47:28.700 --> 00:47:30.100
on the floor and not do anything.

00:47:30.150 --> 00:47:34.440
Now, everywhere else in our app,
all we have to do is use

00:47:34.440 --> 00:47:36.430
tt_add_motion_effect.

00:47:36.750 --> 00:47:40.110
And then we can safely
construct motion effects,

00:47:40.340 --> 00:47:47.450
which may or may not return nil,
and pass them to our new add

00:47:47.450 --> 00:47:52.000
motion effect method without
any worry of our app crashing.

00:47:52.060 --> 00:47:52.520
And we have kept our app running.

00:47:52.520 --> 00:47:56.780
And we have kept all the rest of
our code in our app simple and

00:47:56.780 --> 00:47:59.530
easy to read and understandable.

00:47:59.680 --> 00:48:03.080
Now you may be thinking, well,
I've still scattered

00:48:03.080 --> 00:48:04.680
this all over my app.

00:48:04.680 --> 00:48:07.830
Once I drop support for iOS 6,
is it difficult to remove this

00:48:07.830 --> 00:48:10.100
category when I don't need it anymore?

00:48:10.100 --> 00:48:12.360
No, it's actually quite easy.

00:48:12.360 --> 00:48:14.350
Xcode has some refactoring tools.

00:48:14.370 --> 00:48:20.120
And so the way that you would remove this
category when you don't need it anymore

00:48:20.130 --> 00:48:25.890
is to simply rename this category method
to the actual method name in UIKit.

00:48:25.920 --> 00:48:30.080
What this will do is it will go
through your entire code base and

00:48:30.080 --> 00:48:34.720
find everywhere where you're using
this custom method and replace it

00:48:34.720 --> 00:48:37.430
with the actual selector from UIKit.

00:48:37.430 --> 00:48:40.200
Once this is done and it
takes about three seconds,

00:48:40.260 --> 00:48:44.300
you're safe to delete your category
because you don't need it anymore.

00:48:45.580 --> 00:48:48.780
This is how you can safely adopt
new methods while still maintaining

00:48:48.780 --> 00:48:51.820
backwards compatibility with iOS 6.

00:48:51.820 --> 00:48:55.470
I want to end by talking about the
concept of backporting features.

00:48:55.490 --> 00:48:58.550
As I talked about earlier,
there were some developers who were

00:48:58.550 --> 00:49:02.760
resistant to adopting UI collection
view because their justification

00:49:02.760 --> 00:49:05.400
was that it does not exist on iOS 5.

00:49:05.730 --> 00:49:06.600
That's okay.

00:49:07.380 --> 00:49:11.650
For many of you,
your app already worked fine on iOS 5,

00:49:11.900 --> 00:49:16.000
or for this year,
it already works great on iOS 6.

00:49:16.000 --> 00:49:20.990
You can still adopt these features,
but just make them conditional

00:49:20.990 --> 00:49:22.800
to only run on iOS 7.

00:49:22.820 --> 00:49:25.240
What then would you do on iOS 6?

00:49:25.240 --> 00:49:27.320
Just leave your app as it is.

00:49:27.320 --> 00:49:32.500
Some features are simple enough
to approximate on older devices.

00:49:32.500 --> 00:49:36.500
As we saw with downloads,
we can perform backporting.

00:49:37.380 --> 00:49:40.550
We can do background downloads on iOS 6,
but we can get pretty close

00:49:40.550 --> 00:49:41.600
with NSURL connection.

00:49:41.850 --> 00:49:45.780
That's a feature that's easy to
approximate on an older iOS device.

00:49:45.780 --> 00:49:49.840
And so it's probably worth our time
to invest in that development cost.

00:49:49.840 --> 00:49:53.640
But if you wanted to use
game controllers on iOS 6,

00:49:53.640 --> 00:49:56.440
you would have to rewrite that
entire framework yourself.

00:49:56.490 --> 00:49:58.260
I don't recommend that you do that.

00:49:58.260 --> 00:50:00.310
That would be a lot of work.

00:50:00.610 --> 00:50:03.680
So in those cases,
it's all right to scale back the

00:50:03.680 --> 00:50:08.200
experience of your application if
certain features are not available.

00:50:08.200 --> 00:50:10.500
We see game developers do this.

00:50:10.650 --> 00:50:13.900
For example, when we had the introduction
of the iPad Air,

00:50:13.960 --> 00:50:17.600
one of the things that we
showed was Infinity Blade 3.

00:50:17.600 --> 00:50:21.740
And the Infinity Blade developers
talked about how for the new device,

00:50:22.070 --> 00:50:25.250
they were able to ramp up the
effects in Infinity Blade.

00:50:25.250 --> 00:50:27.720
But they only did that
for the new device,

00:50:27.720 --> 00:50:30.260
where the capabilities were present.

00:50:30.690 --> 00:50:34.450
They didn't try to put all
of that texture in detail on

00:50:34.450 --> 00:50:38.840
the dragon on an iPhone 4,
because an iPhone 4 can't handle that.

00:50:38.910 --> 00:50:44.010
It does not have the capabilities.

00:50:44.010 --> 00:50:44.010
We can learn from their wisdom.

00:50:44.310 --> 00:50:47.790
Just as they apply this rule
to the graphics of their game,

00:50:48.070 --> 00:50:51.190
we can apply this rule to the
features of our app as well.

00:50:51.670 --> 00:51:00.190
Let's make the best possible app that
we can for the latest possible system.

00:51:00.190 --> 00:51:00.190
And for older versions
of the operating system,

00:51:00.410 --> 00:51:05.700
We can leave our app as is,
maybe backport some things

00:51:05.700 --> 00:51:05.990
if it's worth our time.

00:51:06.670 --> 00:51:12.220
So that is a look at how we can adopt
new features of the iOS 7 SDK while still

00:51:12.220 --> 00:51:14.600
maintaining backwards compatibility.

00:51:14.600 --> 00:51:16.440
I want to thank you all for coming today.

00:51:16.750 --> 00:51:18.580
Remind you that the labs are still open.

00:51:18.580 --> 00:51:20.890
You're welcome to come and ask
us all the questions you have.

00:51:20.890 --> 00:51:22.920
I hope you have a great
rest of the afternoon.

00:51:22.920 --> 00:51:25.220
Thank you.
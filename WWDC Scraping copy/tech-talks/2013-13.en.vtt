WEBVTT

00:00:23.250 --> 00:00:26.910
Welcome to Architecting Modern iOS Apps,
Part 1.

00:00:27.020 --> 00:00:28.820
My name is Dave DeLong,
and I am one of the

00:00:28.820 --> 00:00:31.720
App Frameworks evangelists.

00:00:31.880 --> 00:00:33.560
In this session,
we're going to be taking a look

00:00:33.610 --> 00:00:37.880
at some of the great new features
of the iOS 7 SDK and peeling back

00:00:38.030 --> 00:00:41.660
the hood and looking at how some
of these features actually work.

00:00:42.070 --> 00:00:44.760
We're going to be focusing
on three main areas.

00:00:44.830 --> 00:00:48.130
The topic of motion, which we've already
heard a little bit about.

00:00:48.230 --> 00:00:50.500
The changes to UI view controller.

00:00:50.590 --> 00:00:54.560
And then we're going to
finish up looking at Text Kit.

00:00:54.670 --> 00:00:57.010
So first up, motion.

00:00:57.580 --> 00:00:59.740
The first part of motion,
as we've already heard a little

00:00:59.740 --> 00:01:04.470
bit about already from Mike,
has to do with motion effects.

00:01:06.430 --> 00:01:14.300
Motion effects are a great way to add
subtle depth to your user interface.

00:01:14.540 --> 00:01:17.050
Let's take a look at an example.

00:01:18.800 --> 00:01:25.030
On this screen, you can see an alert view
being shown in the Safari app.

00:01:25.780 --> 00:01:30.240
And we can tell simply by
watching this that there is depth,

00:01:30.250 --> 00:01:34.970
that the alert view is
floating on top of the tabs.

00:01:35.300 --> 00:01:38.200
And it's kind of hard to see
how this is actually happening.

00:01:38.290 --> 00:01:40.890
But for emphasis,
I want to show what this UI would

00:01:40.890 --> 00:01:45.430
look like if we didn't have
any motion effects applied.

00:01:45.580 --> 00:01:46.970
So...

00:01:47.640 --> 00:01:51.820
Here's that same screen again,
except on the right,

00:01:51.840 --> 00:01:54.040
we have removed the motion effects.

00:01:54.080 --> 00:01:57.640
You can tell that on the right,
the interface feels much flatter.

00:01:57.690 --> 00:01:59.540
There is no depth to it.

00:01:59.670 --> 00:02:05.260
Whereas the normal interface on
the left feels much more natural.

00:02:06.430 --> 00:02:09.340
But as you're watching this,
it's hard to intuit what

00:02:09.340 --> 00:02:11.380
is actually going on.

00:02:11.470 --> 00:02:15.060
So here it is again.

00:02:15.370 --> 00:02:19.090
Except this time,
I've removed the perspective

00:02:19.120 --> 00:02:21.780
as the screen moves around.

00:02:21.780 --> 00:02:25.620
So what we can actually see is
happening is that we're simply

00:02:25.620 --> 00:02:30.240
repositioning the alert view
as the user tilts their device.

00:02:30.280 --> 00:02:35.100
That's all we need to do to
add that motion effect to this

00:02:35.100 --> 00:02:41.470
alert view to get this wonderful
feeling of depth to our interface.

00:02:42.030 --> 00:02:43.900
is a very good example of this.

00:02:44.010 --> 00:02:48.180
It is very trivial to do this in iOS 7
using the new UI Motion Effect class.

00:02:48.180 --> 00:02:50.100
This is an abstract class.

00:02:50.140 --> 00:02:52.120
It is extremely easy for you to subclass.

00:02:52.120 --> 00:02:56.520
There is simply one method, I believe,
you have to override.

00:02:56.520 --> 00:02:59.450
And through this method,
you receive processed updates

00:02:59.530 --> 00:03:01.540
from the accelerometer.

00:03:01.560 --> 00:03:08.760
These updates give you a value that you
can use to represent some sort of change.

00:03:08.770 --> 00:03:10.700
Now, this is all very abstract.

00:03:10.700 --> 00:03:13.540
And so to make it easier for you,
we have created a concrete

00:03:13.680 --> 00:03:16.650
subclass of this called
UI Interpolating Motion Effect.

00:03:16.650 --> 00:03:19.460
And it is probably this class
that you are going to be using

00:03:19.460 --> 00:03:21.620
the most in your applications.

00:03:21.710 --> 00:03:23.660
Here is how it works.

00:03:24.360 --> 00:03:26.700
First up,
we're going to create an interpolating

00:03:26.700 --> 00:03:32.490
motion effect to say that we want to
alter the center.x property of our view.

00:03:32.660 --> 00:03:35.940
So we want to alter its
horizontal position.

00:03:35.970 --> 00:03:40.560
And we want to change the view's
horizontal position as they tilt their

00:03:40.560 --> 00:03:43.300
device along the horizontal axis.

00:03:43.670 --> 00:03:47.760
Next, we need to specify a
relative range of values.

00:03:47.890 --> 00:03:50.940
And so here we're going to say that
we're allowed to shift our view up

00:03:50.980 --> 00:03:54.160
to 40 points in either direction.

00:03:54.290 --> 00:03:58.100
I want to point out here that
these values are not primitives.

00:03:58.230 --> 00:04:01.720
They're not a float or an
integer that you're passing in.

00:04:01.800 --> 00:04:03.420
It's an actual object.

00:04:03.520 --> 00:04:06.990
And that's because interpolating
motion effect can operate on

00:04:06.990 --> 00:04:08.980
much more than scalar values.

00:04:09.200 --> 00:04:13.160
You can interpolate between
arbitrary affine transforms,

00:04:13.280 --> 00:04:15.020
for example.

00:04:16.220 --> 00:04:19.210
Next, we're going to create
another emotion effect,

00:04:19.330 --> 00:04:22.750
but this time alter the
view's center.y property,

00:04:22.750 --> 00:04:25.480
so it will shift along its vertical axis.

00:04:25.660 --> 00:04:28.930
And again, like before,
we specify a range of values,

00:04:29.020 --> 00:04:33.310
so again allowing it to shift up
to 40 points in either direction.

00:04:33.690 --> 00:04:36.080
Now, at this point,
we could take these two motion effects

00:04:36.400 --> 00:04:39.210
and apply them to our single view.

00:04:39.400 --> 00:04:42.940
But for the sake of efficiency,
we're going to group them.

00:04:42.990 --> 00:04:45.850
We're going to do that with
another UI Motion Effects subclass

00:04:46.150 --> 00:04:48.540
called UI Motion Effect Group.

00:04:48.840 --> 00:04:53.590
Now, the advantage of grouping motion
effects means that we can take the

00:04:53.590 --> 00:04:58.420
updates provided by these two motion
effects and apply all of their changes

00:04:58.590 --> 00:05:01.270
to our view in a single operation.

00:05:01.370 --> 00:05:06.020
If we did not group them, then first,
as the motion effects receive

00:05:06.080 --> 00:05:09.930
values from the accelerometer,
the first motion effect would

00:05:10.120 --> 00:05:12.560
alter the view's center.x property.

00:05:12.630 --> 00:05:17.220
And then the second motion effect would
alter the view's center.y property.

00:05:17.500 --> 00:05:20.600
But by grouping them into a
single motion effect group,

00:05:20.860 --> 00:05:25.750
we can alter both the x and
the y values simultaneously.

00:05:26.400 --> 00:05:30.570
So with the group created,
we simply use the new method on UIView,

00:05:30.660 --> 00:05:31.940
addMotionEffect.

00:05:31.970 --> 00:05:36.920
And that's all we need to do to
add a motion effect to our views.

00:05:38.240 --> 00:05:39.840
So that was motion effects.

00:05:39.910 --> 00:05:42.050
Very easy.

00:05:42.140 --> 00:05:46.800
The next thing I want to talk about
in the topic of motion is dynamics.

00:05:47.790 --> 00:05:51.560
If you haven't heard about this already,
Dynamics is a very easy way

00:05:51.560 --> 00:05:55.920
to add realistic physics-like
interactions to your views.

00:05:56.080 --> 00:06:00.640
We have a physics-like engine
under the hood that performs at

00:06:01.250 --> 00:06:04.760
frame rate calculations to move
your views around and see if

00:06:04.760 --> 00:06:06.520
they're colliding with each other.

00:06:06.580 --> 00:06:09.090
We can have your views
attached to springs.

00:06:09.210 --> 00:06:14.020
We can affect them by gravity or
even attach them to arbitrary points.

00:06:14.130 --> 00:06:17.130
The possibilities here are endless.

00:06:17.360 --> 00:06:19.490
One thing I want to do
point out about Dynamics,

00:06:19.500 --> 00:06:23.420
however, is that this is not meant
to be a game engine.

00:06:23.520 --> 00:06:28.260
Dynamics exists to
enhance your interface,

00:06:28.260 --> 00:06:29.500
as it already is.

00:06:29.640 --> 00:06:32.910
It's not meant to create some new game.

00:06:33.150 --> 00:06:35.210
For that,
you would want to look at SpriteKit.

00:06:35.350 --> 00:06:38.530
As Mike has shown us already,
we're using Dynamics on the

00:06:38.570 --> 00:06:45.140
lock screen to give a lifelike
feel to this lock screen view.

00:06:45.280 --> 00:06:48.750
So we can see that there's
elasticity to the view that

00:06:48.840 --> 00:06:51.120
affects how high it bounces.

00:06:51.200 --> 00:06:54.540
It reacts according to how
hard you throw it down.

00:06:54.900 --> 00:06:57.670
If you drag the view up and
then slam your finger down,

00:06:57.910 --> 00:06:59.260
the view reacts accordingly.

00:06:59.260 --> 00:07:03.180
It is very lifelike in its interaction.

00:07:03.550 --> 00:07:06.780
So we're not going to get too in-depth
into Dynamics in this session,

00:07:06.820 --> 00:07:12.400
but we had three sessions at WWDC this
year that went in-depth into all of the

00:07:12.400 --> 00:07:14.000
things that you can do with Dynamics.

00:07:14.000 --> 00:07:17.030
We're going to take a little bit
of a look at them in a few minutes

00:07:17.170 --> 00:07:20.380
as we look at custom transitions,
but I highly encourage you to

00:07:20.380 --> 00:07:22.140
check out these three sessions.

00:07:22.140 --> 00:07:25.240
Next,
let's talk about custom transitions.

00:07:25.240 --> 00:07:28.980
The motion effects that we saw,
you can use to add subtle

00:07:29.030 --> 00:07:31.240
movement to your interface.

00:07:32.300 --> 00:07:35.300
And with Dynamics,
you can add realistic movement.

00:07:35.300 --> 00:07:39.790
With custom transitions,
as we saw in Mike's presentation earlier,

00:07:39.840 --> 00:07:44.970
you can model movement between entire
different areas of your application,

00:07:45.270 --> 00:07:47.860
like we saw in the photos example.

00:07:48.190 --> 00:07:51.500
These are transitions that can
be contextually relevant and very

00:07:51.500 --> 00:07:55.740
engaging and provide a lot of
information to the user simply in

00:07:55.740 --> 00:07:58.340
how views move around the screen.

00:07:58.780 --> 00:08:02.090
Now, if you've taken a look at the API,
it might be a little bit complex,

00:08:02.100 --> 00:08:05.200
because everything in this
API is defined by protocols.

00:08:05.330 --> 00:08:07.130
It's very abstract.

00:08:07.260 --> 00:08:10.020
However,
having a protocol-based API allows

00:08:10.050 --> 00:08:13.900
us to have an extremely flexible API.

00:08:14.000 --> 00:08:16.460
And we're going to see how
these protocols play with each

00:08:16.460 --> 00:08:21.800
other to give you the power of
implementing custom transitions.

00:08:22.190 --> 00:08:25.250
Now, two key things to know
about custom transitions is,

00:08:25.290 --> 00:08:28.750
first,
that the animations happen in a sandbox.

00:08:29.340 --> 00:08:34.250
UI Kit really likes it when your
app stays in a consistent state.

00:08:34.530 --> 00:08:36.560
And when you're in the
middle of a transition,

00:08:36.560 --> 00:08:38.860
you're not always in a consistent state.

00:08:39.000 --> 00:08:41.800
Some view controller might
be partially on the screen,

00:08:41.810 --> 00:08:44.500
another might be
partially off the screen,

00:08:44.500 --> 00:08:45.280
and so on.

00:08:45.280 --> 00:08:49.590
And so to keep UIKit happy,
we'd perform these

00:08:49.590 --> 00:08:51.940
transitions in a sandbox.

00:08:52.080 --> 00:08:57.860
And then it's up to you to
tell the framework when your

00:08:57.860 --> 00:08:59.990
transition has completed.

00:09:00.570 --> 00:09:05.280
But with custom transitions,
you can implement, for example,

00:09:05.280 --> 00:09:09.900
your own crossfade transition,
where you can easily crossfade between,

00:09:10.070 --> 00:09:14.200
for example, this beautiful orange
view and a green view.

00:09:14.340 --> 00:09:16.740
This is about the extent
of my design skills.

00:09:16.840 --> 00:09:20.000
So what are the objects involved?

00:09:20.090 --> 00:09:23.860
Well, the very first thing is called
the transitioning delegate.

00:09:23.970 --> 00:09:27.790
This is a new property
on UIViewController.

00:09:28.150 --> 00:09:31.460
When a view controller
is presented in iOS 7,

00:09:31.460 --> 00:09:33.980
it will first ask its
transitioning delegate,

00:09:34.030 --> 00:09:36.630
"Do I have a custom transition?"

00:09:36.820 --> 00:09:42.990
will provide an object.

00:09:43.060 --> 00:09:45.390
By providing an object,
the delegate is saying, yes,

00:09:45.500 --> 00:09:47.420
there is a custom transition involved.

00:09:47.530 --> 00:09:50.540
If it returns nil,
then there is no custom transition,

00:09:50.540 --> 00:09:53.530
and it should go with
whatever the default is.

00:09:53.760 --> 00:09:57.580
Now, the transitioning delegate will
differentiate between the presentation

00:09:57.600 --> 00:10:00.430
of a view controller and the
dismissal of a view controller,

00:10:00.550 --> 00:10:04.220
and we'll see in a few minutes
why that can be extremely useful.

00:10:04.920 --> 00:10:09.750
So the object that the transitioning
delegate returns conforms to the

00:10:09.750 --> 00:10:12.920
animated transitioning protocol.

00:10:13.420 --> 00:10:17.860
This animated transitioning protocol
defines two key pieces of information.

00:10:17.990 --> 00:10:22.040
The first is how long
the transition takes.

00:10:22.040 --> 00:10:25.880
And the second is what
the actual transition is.

00:10:25.880 --> 00:10:29.920
The other thing that this transitioning
object needs to do in its implementation

00:10:29.920 --> 00:10:35.940
of these methods is report when the
transition has actually completed.

00:10:35.940 --> 00:10:39.320
It reports that via an object
that's passed in as a parameter

00:10:39.320 --> 00:10:43.280
to one of these methods,
that is the transition context.

00:10:43.280 --> 00:10:49.130
An object that performs to the protocol
UI view controller context transitioning.

00:10:49.410 --> 00:10:51.990
You'll almost never need to create
one of these objects yourselves.

00:10:52.070 --> 00:10:55.050
They are provided by
the framework for you.

00:10:55.540 --> 00:10:58.710
And as its name implies,
this object contains metadata

00:10:58.740 --> 00:11:00.000
about the transition.

00:11:00.040 --> 00:11:03.710
It includes information as
to which view controllers are

00:11:03.930 --> 00:11:06.880
participating in the transition,
what the sandbox is,

00:11:06.940 --> 00:11:09.120
what their initial and
final frames might be,

00:11:09.120 --> 00:11:10.000
and so on.

00:11:10.050 --> 00:11:15.650
And it is through this context that you
report that the transition has completed.

00:11:15.800 --> 00:11:19.720
So let's see how these
objects all play together.

00:11:19.770 --> 00:11:22.760
Let's start by presenting
a view controller.

00:11:23.420 --> 00:11:27.310
As we learned just a minute ago,
the ViewController is going to

00:11:27.310 --> 00:11:33.570
ask its transitioning delegate
if it has a custom transition.

00:11:34.400 --> 00:11:36.730
In our case,
we do have a custom transition,

00:11:36.740 --> 00:11:40.690
so the transitioning delegate will create
one of these animated transitioning

00:11:40.750 --> 00:11:46.010
objects and return it to indicate that,
yes, we do have a custom transition.

00:11:46.310 --> 00:11:50.310
This object is passed back through
the view controller to the framework,

00:11:50.540 --> 00:11:52.870
which keeps a reference to it.

00:11:53.010 --> 00:11:55.290
Next,
the framework will tell the animated

00:11:55.290 --> 00:12:00.780
transitioning object to animate,
to perform the transition.

00:12:00.990 --> 00:12:04.750
And along with this message,
it provides the context for

00:12:04.920 --> 00:12:08.410
the transition that indicates
the view controllers involved,

00:12:08.410 --> 00:12:09.790
and so on.

00:12:10.520 --> 00:12:13.480
Now,
when the animated transitioning object

00:12:13.600 --> 00:12:17.180
receives this perform transition method,

00:12:17.300 --> 00:12:23.690
It can now do whatever animation it wants
to to actually perform the transition.

00:12:24.670 --> 00:12:28.900
When that animation has completed,
the animated transitioning object then

00:12:28.900 --> 00:12:31.950
tells the context that it is finished.

00:12:32.530 --> 00:12:36.480
And the context passes that
information back to the framework.

00:12:36.510 --> 00:12:41.480
The extra objects are cleaned up,
and that's a custom transition.

00:12:43.100 --> 00:12:45.560
But this is a very
simple custom transition.

00:12:45.630 --> 00:12:49.840
This is one that would have
a predefined animation.

00:12:50.340 --> 00:12:52.760
But there are times when we want to
have a transition that's actually

00:12:52.760 --> 00:12:57.380
defined by the user interacting,
perhaps, with some objects on the screen.

00:12:57.380 --> 00:13:00.870
So for that,
we need to do an interactive transition.

00:13:03.290 --> 00:13:06.660
An important thing to realize about
an interactive transition is that the

00:13:06.660 --> 00:13:14.360
interactive portion of the transition
actually happens before the animation.

00:13:14.470 --> 00:13:18.760
If you're familiar with the drag
from the left edge of the screen to

00:13:18.760 --> 00:13:22.970
go back gesture that's new in iOS 7,

00:13:23.430 --> 00:13:25.660
You don't actually have to
drag your finger all the way

00:13:25.660 --> 00:13:27.020
across the screen to go back.

00:13:27.100 --> 00:13:29.750
You can just drag it part of the way.

00:13:29.750 --> 00:13:34.120
And when you release your finger,
there's still some animation that

00:13:34.220 --> 00:13:38.940
needs to be performed to return the
views to a wholly consistent state.

00:13:39.160 --> 00:13:41.730
Dave DeLoong And so the
first part of that gesture,

00:13:41.800 --> 00:13:45.160
or the first part of that transition,
as you're dragging your thumb

00:13:45.160 --> 00:13:48.250
or finger across the string,
is the interactive portion.

00:13:48.250 --> 00:13:52.680
And then when interactive ends,
the interactive portion ends,

00:13:52.690 --> 00:13:55.760
there is still animation to be performed.

00:13:55.760 --> 00:13:58.390
Dave DeLoong And so that is
why the interactive portion

00:13:58.390 --> 00:13:59.990
comes before the animation.

00:13:59.990 --> 00:14:02.600
Like we saw before,
these methods are defined on

00:14:02.740 --> 00:14:04.440
the transitioning delegate.

00:14:06.390 --> 00:14:11.320
So going back to the lock screen example,
this is an interactive transition.

00:14:11.350 --> 00:14:15.430
We are transitioning between
the slide to unlock screen and

00:14:15.500 --> 00:14:18.390
the camera view that's behind.

00:14:18.920 --> 00:14:21.580
It's interactive because
it's defined by a gesture.

00:14:21.610 --> 00:14:23.420
We have no idea how long it will take.

00:14:23.420 --> 00:14:27.050
The user could place their
finger on the screen and just

00:14:27.380 --> 00:14:29.020
move it up and down for hours.

00:14:29.130 --> 00:14:33.320
We really have no idea
what they're going to do.

00:14:33.960 --> 00:14:35.640
and the framework needs
to accommodate this.

00:14:35.860 --> 00:14:38.820
So we do.

00:14:38.900 --> 00:14:42.280
We do this with an interactive
transitioning object.

00:14:42.440 --> 00:14:46.940
This is another object that's returned
by the transitioning delegate.

00:14:47.050 --> 00:14:51.830
And it is an object that watches
for interaction and notifies,

00:14:52.080 --> 00:14:57.150
via the context,
how the interaction is happening.

00:14:57.280 --> 00:15:00.680
It will notify when it is canceled,
or it will notify when it

00:15:00.680 --> 00:15:02.050
is successfully completed.

00:15:02.330 --> 00:15:06.400
Now, to make this a little bit easier for
you-- it's not all protocols-- we have

00:15:06.400 --> 00:15:10.540
implemented the interactive transitioning
object protocol for you on a

00:15:10.540 --> 00:15:13.920
UI percent-driven interactive transition.

00:15:13.980 --> 00:15:18.420
This is a concrete implementation of
the interactive transitioning protocol.

00:15:18.700 --> 00:15:25.400
And it will work out of the box
with any UIView animation API.

00:15:25.410 --> 00:15:30.490
You can simply wrap up
your UIView animations

00:15:30.880 --> 00:15:35.140
inside an animated transitioning object,
then supply one of these

00:15:35.290 --> 00:15:39.250
percent-driven interactive transitions,
and just like that,

00:15:39.510 --> 00:15:43.260
your UIView animation calls
will become interactive.

00:15:43.310 --> 00:15:47.590
It is easily subclassable,
so you can tweak things.

00:15:47.650 --> 00:15:49.880
Very easy to use.

00:15:50.000 --> 00:15:52.120
So let's see how this fits in.

00:15:52.170 --> 00:15:55.690
Again, with the ViewController
that we want to present.

00:15:56.370 --> 00:16:00.460
Like before, the View Controller has
its transition delegate,

00:16:00.470 --> 00:16:02.500
except now,

00:16:02.880 --> 00:16:06.750
Well, it will first again ask if
there's a custom transition.

00:16:06.880 --> 00:16:09.000
And like before,
we have a custom transition.

00:16:09.000 --> 00:16:12.260
And so we're going to create that
same animated transitioning object

00:16:13.010 --> 00:16:16.800
and return it back to the frameworks.

00:16:16.870 --> 00:16:18.920
Except now--

00:16:19.490 --> 00:16:23.020
The View Controller is also going
to ask its transitioning delegate,

00:16:23.080 --> 00:16:27.110
"Do you have an interactive
transition for me?" Or in other words,

00:16:27.190 --> 00:16:30.320
"Is this animated transitioning
object that you just gave me part

00:16:30.320 --> 00:16:33.150
of an interactive transition?"

00:16:33.620 --> 00:16:37.990
And the transitioning delegate will
return an object that conforms to the

00:16:38.110 --> 00:16:40.020
interactive transitioning protocol.

00:16:40.020 --> 00:16:42.700
Might be the same object,
might be a different one.

00:16:42.700 --> 00:16:43.820
That's why they're protocols.

00:16:43.820 --> 00:16:47.400
And by returning this
interactive transitioning object,

00:16:47.400 --> 00:16:50.310
we indicate that this will
be an interactive transition.

00:16:50.320 --> 00:16:55.530
And that object, as well,
is given to the framework.

00:16:55.580 --> 00:16:58.400
Except now,
since the framework has both the

00:16:58.410 --> 00:17:03.120
interactive transitioning object and
the animated transitioning object,

00:17:03.630 --> 00:17:07.160
it first starts with the interactive
portion of the transition.

00:17:07.180 --> 00:17:11.120
And it does that by telling the
interactive transitioning object

00:17:11.120 --> 00:17:13.450
to start watching for interaction.

00:17:13.500 --> 00:17:17.130
And with that message,
provides that same context

00:17:17.250 --> 00:17:18.940
that we saw earlier.

00:17:18.940 --> 00:17:21.670
Now,
this interactive transitioning object can

00:17:21.670 --> 00:17:23.950
be watching for any sort of interaction.

00:17:24.100 --> 00:17:27.200
Most commonly,
it's going to be a gesture on the screen.

00:17:27.200 --> 00:17:31.420
And as the user moves their
fingers across the screen,

00:17:31.420 --> 00:17:33.100
you're going to be performing something.

00:17:33.530 --> 00:17:37.060
You're going to be doing some calculation
to figure out approximately how much

00:17:37.060 --> 00:17:38.740
of this transition has completed.

00:17:38.760 --> 00:17:44.060
And you're going to be notifying,
via this context, how much has occurred.

00:17:44.470 --> 00:17:48.680
Maybe 20%, then 42%, then 60%, and so on.

00:17:48.680 --> 00:17:54.260
And you're going to send this update
message as many times as you want.

00:17:55.320 --> 00:17:57.830
At some point, however,
the user will lift their

00:17:57.950 --> 00:17:59.350
finger off the screen.

00:17:59.670 --> 00:18:01.060
That is inevitable.

00:18:01.070 --> 00:18:04.740
And when they do,
it's up to you to decide if they

00:18:04.740 --> 00:18:10.360
have moved the views involved far
enough for the transition to complete,

00:18:10.360 --> 00:18:14.330
or if things should be reverted
back to their initial state.

00:18:15.450 --> 00:18:16.670
We do this.

00:18:16.820 --> 00:18:20.710
We make this decision and indicate
to the context whether we should

00:18:20.710 --> 00:18:25.830
finish the interactive portion or
cancel the interactive portion.

00:18:25.980 --> 00:18:29.900
The context stores this information
and relays on to the framework that

00:18:29.900 --> 00:18:34.080
we are done with the interactive
portion of our transition.

00:18:34.080 --> 00:18:38.250
But remember, we're not done yet,
because we still might need to

00:18:38.650 --> 00:18:40.960
perform some cleanup animations.

00:18:40.960 --> 00:18:46.060
And so, this is where the animated
transitioning object comes in.

00:18:46.060 --> 00:18:51.330
And like before, it is told to animate,
and is again given that same context.

00:18:51.360 --> 00:18:54.870
It again will perform
whatever animations it wants.

00:18:56.430 --> 00:19:00.240
perhaps it doesn't need to perform any,
and it will notify it through

00:19:00.240 --> 00:19:03.180
the context that it is finished.

00:19:03.760 --> 00:19:07.490
When the context gets this final
message that the animated transitioning

00:19:07.490 --> 00:19:11.220
object has finished its animations,
then all of these extra

00:19:11.350 --> 00:19:12.810
objects are cleaned up.

00:19:13.520 --> 00:19:17.170
and the animation and
transition complete.

00:19:17.290 --> 00:19:19.300
So this is a lot of information.

00:19:19.300 --> 00:19:22.800
So what I want to do now is I want
to switch to the demo machine.

00:19:23.040 --> 00:19:29.940
and show you how we actually build
an interactive custom transition.

00:19:29.990 --> 00:19:32.900
So again, I have employed my
wonderful design skills.

00:19:32.970 --> 00:19:37.370
I have a lovely orange view here with
a single button that says Present.

00:19:37.480 --> 00:19:43.180
And when we tap this button,
it is going to present my green view.

00:19:44.190 --> 00:19:47.180
So let's see how we're going to do this.

00:19:47.180 --> 00:19:49.600
In my first view controller, I'm going

00:19:52.370 --> 00:19:54.680
When we tap the button,
we're going to create our second

00:19:54.680 --> 00:19:59.140
view controller and set the second
view controller's transitioning

00:19:59.140 --> 00:20:03.200
delegate to be the first view
controller so that as the second

00:20:03.200 --> 00:20:07.920
view controller is being presented,
it will ask the first one if it should

00:20:07.920 --> 00:20:11.110
be done using a custom transition.

00:20:11.840 --> 00:20:15.450
And here, it will ask us through
this wonderful method,

00:20:15.450 --> 00:20:21.460
animation controller for presenting
controller source controller.

00:20:21.560 --> 00:20:23.790
We love long names.

00:20:24.190 --> 00:20:31.190
And here, we're simply going to create a
crossfade transition and return that.

00:20:31.480 --> 00:20:32.600
It's all we're going to do.

00:20:32.600 --> 00:20:35.160
This crossfade transition
is very trivial.

00:20:35.160 --> 00:20:37.570
We're going to define that
this is a transition that will

00:20:37.570 --> 00:20:39.160
take approximately two seconds.

00:20:39.160 --> 00:20:43.980
This is so that it's easy for you to see
the effect that it's going to perform.

00:20:44.000 --> 00:20:47.070
And then in the actual animation,

00:20:47.320 --> 00:20:49.870
will retrieve some
information from the context,

00:20:49.880 --> 00:20:54.460
such as the view controllers involved,
the frames that they're coming from,

00:20:54.460 --> 00:21:01.720
and going to the sandbox view in
which these animations take place.

00:21:02.340 --> 00:21:07.040
And then all we're going to do
is simply change the alphas of

00:21:07.040 --> 00:21:12.500
these views to fade out one as we
simultaneously fade in another.

00:21:12.800 --> 00:21:15.800
And this is how we're
going to do our crossfade.

00:21:16.330 --> 00:21:21.280
Now, when this animation completes,
like we learned just a few minutes ago,

00:21:21.280 --> 00:21:25.330
we need to notify to the
context that we finished.

00:21:25.430 --> 00:21:28.970
So that's how we do this here,
using this complete transition method.

00:21:29.060 --> 00:21:31.560
And by passing in yes,
we are indicating that this

00:21:31.560 --> 00:21:34.970
is a successful transition.

00:21:35.070 --> 00:21:37.570
So let's run this.

00:21:40.340 --> 00:21:44.560
And I can tap here on
this Present button,

00:21:44.650 --> 00:21:48.520
and I get a nice,
wonderful two-second crossfade.

00:21:48.660 --> 00:21:52.900
So what about this drag down to dismiss?

00:21:54.710 --> 00:22:00.440
Well, on the second view controller,
things get a little bit more complicated.

00:22:00.450 --> 00:22:05.810
So here, as the view loads,
I'm going to create a drag

00:22:05.810 --> 00:22:10.070
to dismiss transition object
and give it a source view.

00:22:10.120 --> 00:22:13.740
Now, by doing this,
the drag to dismiss transition

00:22:14.230 --> 00:22:20.000
is going to create the gesture
recognizer to detect the drag.

00:22:20.610 --> 00:22:24.280
And by assigning this dismiss
transition a delegate,

00:22:24.300 --> 00:22:30.670
it can notify to us when the user
starts dragging on the screen.

00:22:31.150 --> 00:22:37.060
So when we first notice the
user dragging on the screen,

00:22:37.060 --> 00:22:41.810
we'll set our transitioning
delegate to be ourselves.

00:22:42.240 --> 00:22:46.420
Now, this is kind of curious,
because if we didn't do this,

00:22:46.460 --> 00:22:50.800
then as we started dragging to
dismiss their second view controller,

00:22:50.800 --> 00:22:56.120
it would still be trying to ask the
first one how it should dismiss.

00:22:56.120 --> 00:23:00.650
But the first view controller doesn't
know anything about the gesture

00:23:00.650 --> 00:23:03.570
recognizer involved in this transition.

00:23:04.940 --> 00:23:08.120
And so we're going to set
this view controller to be its

00:23:08.120 --> 00:23:11.870
own transitioning delegate,
such that when we are asked for

00:23:12.020 --> 00:23:15.990
the animated transitioning and
interactive transitioning objects,

00:23:16.060 --> 00:23:19.220
we have an actual object
that we can return.

00:23:19.220 --> 00:23:22.640
And this is where the power
of this API comes into play,

00:23:22.640 --> 00:23:26.740
because we are going to return the
same object as both the animated

00:23:26.740 --> 00:23:31.260
transitioning object and the
interactive transitioning object.

00:23:31.260 --> 00:23:34.220
So this is a single object
that has a dual purpose.

00:23:34.720 --> 00:23:36.220
This is why protocols are so wonderful.

00:23:36.220 --> 00:23:40.140
So let's take a look at this
drag to dismiss transition.

00:23:41.920 --> 00:23:46.000
So like I said, when we create one,
we're going to create a pan gesture

00:23:46.000 --> 00:23:51.070
recognizer and add it to the view so that
we know when the user starts dragging.

00:23:52.930 --> 00:23:58.680
And when the user starts dragging
and gesture recognizer state began,

00:23:58.740 --> 00:24:02.630
all we're going to do is notify
to the delegate that the drag to

00:24:02.630 --> 00:24:05.740
dismiss transition did begin dragging.

00:24:05.790 --> 00:24:10.780
As we saw a second ago,
this will dismiss the view controller.

00:24:11.270 --> 00:24:16.630
And since we are returning this object
as the interactive transitioning object,

00:24:17.570 --> 00:24:19.870
We will get this message
from the framework:

00:24:19.990 --> 00:24:22.870
Start interactive transition.

00:24:23.680 --> 00:24:27.860
So like the crossfade animation,
we still need to set up the sandbox.

00:24:27.890 --> 00:24:31.370
So this is very similar code to
what we saw just a few minutes ago,

00:24:31.630 --> 00:24:33.880
where we're going to retrieve
the view controllers involved,

00:24:33.990 --> 00:24:38.510
get their frames,
add them to that transition container.

00:24:38.880 --> 00:24:42.840
And we're going to remember some
information about where the user was

00:24:42.840 --> 00:24:46.340
touching on the screen so that it
can be moving relative to the finger.

00:24:46.340 --> 00:24:48.910
But that's all we're going to do.

00:24:50.060 --> 00:24:57.420
Now, as the user continues to drag and
the gesture recognizer state changes,

00:24:57.530 --> 00:25:02.070
we're going to simply update the
center property of this view so

00:25:02.310 --> 00:25:06.790
that it will move with our finger.

00:25:07.740 --> 00:25:11.740
And as we do so,
we're going to tell the context

00:25:12.210 --> 00:25:15.850
to update and give it an
approximate percentage completed,

00:25:15.850 --> 00:25:19.730
so a number between 0 and 1,
indicating how much of this

00:25:19.790 --> 00:25:21.810
transition we have approximately done.

00:25:21.820 --> 00:25:25.960
And all we're doing here is we're
simply estimating this based on how

00:25:26.300 --> 00:25:28.280
far down the screen the view has moved.

00:25:28.320 --> 00:25:30.850
Now, at some point, though,
the user is going to lift

00:25:30.850 --> 00:25:32.360
their finger off the screen.

00:25:32.360 --> 00:25:35.380
And when they do,
we need to figure out if we

00:25:35.550 --> 00:25:38.530
should finish the interaction
or if we should cancel it.

00:25:38.560 --> 00:25:42.580
So here I have decided that if
they move the view at least a

00:25:42.640 --> 00:25:46.900
third of the way down the screen,
then we should consider that good enough

00:25:46.900 --> 00:25:49.220
and we'll finish the transition for them.

00:25:49.320 --> 00:25:51.280
And if they're still in the
top third of the screen,

00:25:51.390 --> 00:25:53.810
then we will cancel it and
go back to the beginning.

00:25:53.820 --> 00:25:56.780
Let's look at the success case.

00:25:56.950 --> 00:25:59.260
Here, we're going to get a little fancy.

00:25:59.300 --> 00:26:00.510
We're going to use Dynamics.

00:26:00.680 --> 00:26:03.310
So Dynamics, with Dynamics here,
we're going to set up

00:26:03.400 --> 00:26:06.750
our dynamic animator,
which is kind of like the physics engine.

00:26:06.830 --> 00:26:09.900
And we're going to give it the
reference view of the container so

00:26:09.900 --> 00:26:14.720
all of the physical interactions
will happen within this container.

00:26:14.720 --> 00:26:17.840
And all we're going to do is we're
going to create some gravity.

00:26:17.960 --> 00:26:21.820
And we want the view to fall
off the bottom of the screen.

00:26:22.090 --> 00:26:24.440
And so we're going to give it a
large gravity so that we're not

00:26:24.540 --> 00:26:26.630
waiting it to slowly accelerate down.

00:26:26.640 --> 00:26:31.590
So we're going to give
it a vector down of 4.

00:26:32.610 --> 00:26:36.200
And then we're going to use
this property of a dynamic

00:26:36.350 --> 00:26:38.970
behavior called the action block.

00:26:39.070 --> 00:26:44.850
And the action block is an
arbitrary block of a UI dynamic

00:26:44.850 --> 00:26:52.590
behavior that gets executed on
every tick of the physics engine.

00:26:53.300 --> 00:26:57.470
And we're going to use this block
to determine if the view has

00:26:57.690 --> 00:26:59.580
totally fallen off the screen.

00:26:59.660 --> 00:27:02.340
So the action block is a great
place to perform this check,

00:27:02.340 --> 00:27:05.460
because it's going to be
updated every single frame,

00:27:05.540 --> 00:27:06.530
every time the view moves.

00:27:06.560 --> 00:27:09.020
And since it's falling,
it's always moving.

00:27:09.140 --> 00:27:11.880
And so we're simply going to look

00:27:12.220 --> 00:27:15.260
is the percentage
completed greater than one,

00:27:15.260 --> 00:27:17.620
which would mean that it's
all the way off the screen.

00:27:17.820 --> 00:27:22.680
And if it is,
then we will turn off our dynamic

00:27:22.680 --> 00:27:26.580
animator by removing all of the
behaviors and tell ourselves

00:27:26.710 --> 00:27:29.450
to complete the transition.

00:27:29.530 --> 00:27:33.640
So that's what the action
block is going to do.

00:27:33.680 --> 00:27:36.780
But then to finish this up,
we just add the gravity behavior

00:27:36.780 --> 00:27:41.050
to our dynamic animator and then
tell our context that we are now

00:27:41.110 --> 00:27:45.090
done with the interactive portion.

00:27:45.150 --> 00:27:46.980
is the first person to use the Gain app.

00:27:47.020 --> 00:27:48.980
He's the first person
to use the Gain app.

00:27:48.980 --> 00:27:50.980
And he's the first person
to use the Gain app.

00:27:51.030 --> 00:27:52.980
So he's the first person
to use the Gain app.

00:27:52.980 --> 00:27:54.980
And he's the first person
to use the Gain app.

00:27:56.130 --> 00:27:59.100
And here we're going to do something,
again, kind of similar, again,

00:27:59.100 --> 00:27:59.880
with Dynamics.

00:27:59.880 --> 00:28:02.800
So that same sort of setup,
except here we're just going

00:28:02.800 --> 00:28:06.660
to snap the view back into
place using a snap behavior.

00:28:06.660 --> 00:28:11.520
So we give it a view to snap into
place and give it a point to snap to.

00:28:11.520 --> 00:28:16.880
And we're going to
give it a load damping,

00:28:16.880 --> 00:28:19.900
which means that it's going to
oscillate a lot so we can see

00:28:19.900 --> 00:28:21.540
that it's actually snapping.

00:28:22.540 --> 00:28:26.190
And again, we're going to use the action
block to know when this is

00:28:26.190 --> 00:28:27.960
approximately completed.

00:28:27.960 --> 00:28:32.790
And we're going to do that by looking
to see if our frame is within one

00:28:32.790 --> 00:28:35.400
point of its original location.

00:28:37.500 --> 00:28:50.500
[ Transcript missing ]

00:28:50.800 --> 00:28:54.230
We will make sure the view is
actually in its original location.

00:28:54.250 --> 00:28:58.550
Again, remove all the behaviors to
turn off the physics engine and

00:28:58.550 --> 00:29:01.060
then complete the transition.

00:29:01.230 --> 00:29:05.180
So we add that snap
behavior to our animator,

00:29:05.200 --> 00:29:08.040
and then say,
because the user didn't drag far enough,

00:29:08.060 --> 00:29:12.290
that we are going to cancel
the interactive transition.

00:29:12.830 --> 00:29:15.460
So the user lifts their
finger off the screen.

00:29:15.460 --> 00:29:18.410
We're either going to drop the view
off the bottom of the screen or it

00:29:18.470 --> 00:29:21.590
will snap back to its original place.

00:29:22.180 --> 00:29:25.080
When either the view has totally
fallen off the screen or has

00:29:25.090 --> 00:29:29.120
finished snapping back into place,
we're going to complete this transition.

00:29:29.120 --> 00:29:31.940
And here,
all we really need to do is tell

00:29:31.940 --> 00:29:34.440
the context that we are done.

00:29:34.540 --> 00:29:37.900
And when the context
receives this message,

00:29:38.080 --> 00:29:42.910
complete transition,
then the entire transition is totally

00:29:42.920 --> 00:29:47.990
complete and everything will go back
to being in a wholly consistent state.

00:29:48.060 --> 00:29:50.150
So let's run this again.

00:29:50.540 --> 00:29:52.700
Like we saw before,
we can tap to present and get this

00:29:52.740 --> 00:29:54.700
nice little two-second crossfade.

00:29:54.700 --> 00:29:59.360
Now I can tap on the screen, drag down,
and if I only drag down part of the way,

00:29:59.360 --> 00:30:03.380
when I release my finger,
it's going to snap back into place,

00:30:03.380 --> 00:30:04.380
like this.

00:30:06.480 --> 00:30:08.680
And we could see that
by having a low damping,

00:30:08.680 --> 00:30:11.920
we saw that oscillation going on.

00:30:11.920 --> 00:30:14.520
But if I drag down further,
so more than a third of

00:30:14.520 --> 00:30:16.520
the way down the screen,
when I release my finger,

00:30:16.520 --> 00:30:20.030
it's going to fall off
the bottom like that.

00:30:20.400 --> 00:30:24.720
So these are some of the neat things
that you can do with custom transitions.

00:30:24.820 --> 00:30:27.970
The possibilities are endless.

00:30:28.050 --> 00:30:33.260
That was a brief look at
custom interactive transitions.

00:30:33.600 --> 00:30:36.680
Now this is great for
defining your own transitions.

00:30:36.680 --> 00:30:38.860
But what about built-in transitions?

00:30:38.880 --> 00:30:41.420
What if you want to
participate along with those?

00:30:41.560 --> 00:30:45.440
Many of you have been requesting
throughout the years that you want

00:30:45.440 --> 00:30:49.540
to know-- you want to participate
with the built-in transitions.

00:30:49.800 --> 00:30:52.280
Maybe you want things to animate
alongside everything else.

00:30:52.300 --> 00:30:54.760
Well,
I'm happy to announce that in iOS 7,

00:30:54.760 --> 00:30:57.530
you can totally do that.

00:30:57.770 --> 00:31:02.010
There is yet another protocol
involving coordinating transitions.

00:31:02.100 --> 00:31:05.000
You can receive this
transition coordinator while

00:31:05.010 --> 00:31:06.900
a transition is in flight.

00:31:07.040 --> 00:31:10.800
And via this transition coordinator,
you can attach extra

00:31:10.910 --> 00:31:12.630
things to animate along.

00:31:12.790 --> 00:31:16.590
You can receive updates about
when the transition completes.

00:31:16.650 --> 00:31:19.220
You can get that same context, and so on.

00:31:19.340 --> 00:31:23.260
You can now participate
in built-in transitions.

00:31:23.260 --> 00:31:27.880
And that is a look at Motion in iOS 7.

00:31:29.110 --> 00:31:33.480
So let's move on to UIViewController,
the heart and soul of every iOS app.

00:31:33.600 --> 00:31:37.220
You should all be familiar
with UIViewController.

00:31:37.300 --> 00:31:40.960
So we made some changes to
ViewControllers in iOS 7.

00:31:40.960 --> 00:31:46.080
The first one has to do with a
concept that we call extended layout.

00:31:46.550 --> 00:31:50.550
In iOS 6,
the content of a view controller lived

00:31:50.760 --> 00:31:55.970
below the navigation bar in this area.

00:31:56.530 --> 00:32:01.290
In iOS 7, we are putting the emphasis
on the user's content,

00:32:01.290 --> 00:32:03.740
which means we want their
content to fill the screen.

00:32:03.740 --> 00:32:09.910
And so now the content extends--
hence extended layout-- to fill the

00:32:09.990 --> 00:32:12.640
screen and takes up the entire screen.

00:32:12.640 --> 00:32:17.000
And so the content
underlaps the status bar.

00:32:17.550 --> 00:32:20.740
This behavior is controlled by a
new property on UIViewController

00:32:20.740 --> 00:32:22.520
called the edges for extended layout.

00:32:22.540 --> 00:32:26.640
And by default,
it is rect edge all to indicate

00:32:26.640 --> 00:32:31.000
that all edges of your view
should extend to fill the screen.

00:32:31.000 --> 00:32:34.580
However, if you like,
you may change this.

00:32:34.670 --> 00:32:37.550
Maybe you have content that
doesn't need to go behind the

00:32:37.550 --> 00:32:39.460
status bar or is not large enough.

00:32:39.540 --> 00:32:42.300
You can change this property,
for example,

00:32:42.340 --> 00:32:47.300
to UIREctEdgeNone to indicate that your
content should still live below the

00:32:47.300 --> 00:32:50.760
navigation bar and above a tab bar,
for example.

00:32:50.760 --> 00:32:54.470
This behavior of having content
move behind the status bar,

00:32:54.470 --> 00:33:00.250
though, means that we need to change a
little bit how scroll views work.

00:33:00.430 --> 00:33:04.720
Because we still want scroll views
to scroll behind the status bar,

00:33:04.720 --> 00:33:08.380
but we don't want them to
start behind the status bar.

00:33:08.380 --> 00:33:09.420
That would be very awkward.

00:33:09.540 --> 00:33:13.920
We would be chopping off the top
approximately 64 points of our content.

00:33:13.980 --> 00:33:17.110
And so we have another property.

00:33:17.510 --> 00:33:21.510
on UI View Controller to automatically
adjust the content insets of

00:33:21.530 --> 00:33:26.350
your scroll bars to account for
navigation bars and tab bars.

00:33:27.010 --> 00:33:30.250
We call this property automatically
adjusts scroll view insets.

00:33:30.320 --> 00:33:36.510
And the default for this property is yes,
which means that the scroll view itself

00:33:36.520 --> 00:33:40.240
will still extend to fill the screen,
as the edges for extended

00:33:40.240 --> 00:33:42.060
layout property defines.

00:33:42.100 --> 00:33:48.190
However, the content will come to rest
below the navigation bar,

00:33:48.260 --> 00:33:49.780
or above the tab bar.

00:33:49.800 --> 00:33:55.590
We adjust both the content inset
and the scroll view indicator inset,

00:33:55.700 --> 00:34:00.500
so it still looks like your scroll
view is still positioned between

00:34:00.500 --> 00:34:03.960
the navigation and tab bars,
but will scroll behind them.

00:34:03.960 --> 00:34:07.990
I should mention, however,
that if you are performing any sort

00:34:07.990 --> 00:34:12.820
of manipulations to the content
insets of your scroll views yourself,

00:34:12.840 --> 00:34:17.450
you should really turn this off,
because we can't anticipate how

00:34:17.560 --> 00:34:19.290
your content insets will change.

00:34:19.300 --> 00:34:24.670
And so if you leave this on
while changing the content inset,

00:34:24.680 --> 00:34:26.460
you can really confuse your scroll views.

00:34:26.480 --> 00:34:33.070
So turn this off if you're
changing those yourselves.

00:34:34.770 --> 00:34:38.730
Now, because content scrolls
behind the status bar,

00:34:38.930 --> 00:34:43.480
we also need to change how
we refer to the status bar.

00:34:43.480 --> 00:34:45.720
So on iOS 6,
we had a solid color background,

00:34:45.720 --> 00:34:46.960
a tinted background.

00:34:46.960 --> 00:34:50.000
You could even define your
own custom color for it.

00:34:50.060 --> 00:34:54.540
But now in iOS 7, the status bar actually
doesn't have a background.

00:34:54.540 --> 00:34:59.370
It is transparent and simply takes on
the appearance of whatever is behind it.

00:35:01.040 --> 00:35:05.650
This means that we need a new way
to refer to how a status bar looks.

00:35:05.660 --> 00:35:10.190
So we're going to take the status
bar style that we're used to

00:35:10.190 --> 00:35:12.000
and change its meaning slightly.

00:35:13.600 --> 00:35:16.360
So we're still going to have
UI status bar style default.

00:35:16.360 --> 00:35:22.700
And what this means is that the default
style of the status bar's content,

00:35:22.700 --> 00:35:27.060
so the signal strength indicator dots,
the time string, the battery percentage,

00:35:27.060 --> 00:35:30.900
all of that should be darkly
colored because the status bar

00:35:30.900 --> 00:35:33.910
itself is on top of light views.

00:35:33.960 --> 00:35:35.960
In this case, a white one.

00:35:35.980 --> 00:35:39.010
Then there is the other style,
which is UI status bar

00:35:39.110 --> 00:35:42.120
style light content,
which means that the contents of

00:35:42.300 --> 00:35:46.250
the status bar themselves should
be lightly colored because the view

00:35:46.510 --> 00:35:48.780
behind it is a dark colored view.

00:35:48.780 --> 00:35:53.280
Now the other big change that we've
made to view controllers is that you

00:35:53.390 --> 00:35:59.880
can now specify the style of the status
bar on a per-view controller basis.

00:35:59.880 --> 00:36:04.210
Prior to iOS 7,
you had to manually manage the state

00:36:04.210 --> 00:36:09.730
of and style of the status bar through
these methods on UI application.

00:36:10.460 --> 00:36:12.450
Fortunately,
you don't need to worry about that

00:36:12.450 --> 00:36:16.120
anymore because we have new methods
on UI view controller to do this.

00:36:16.180 --> 00:36:20.580
So there's a method you can override on
your view controller called preferred

00:36:20.580 --> 00:36:24.960
status bar style to indicate how
the status bar should look when this

00:36:24.960 --> 00:36:27.100
view controller's view is behind it.

00:36:27.120 --> 00:36:30.820
So the default is, of course,
status bar style default,

00:36:30.820 --> 00:36:34.430
but you can override this to return
the light content style instead.

00:36:36.120 --> 00:36:40.100
or maybe you want the status
bar to be hidden entirely.

00:36:40.140 --> 00:36:42.560
So you should override.

00:36:42.880 --> 00:36:46.830
The prefersStatusBarHidden
method to return yes,

00:36:46.880 --> 00:36:48.720
so that you want the status bar hidden.

00:36:48.720 --> 00:36:52.360
Or you can leave it as no to say that
the status bar should be present.

00:36:52.360 --> 00:36:54.950
Now,
there are situations where we want the

00:36:55.310 --> 00:36:57.470
status bar to come and go dynamically.

00:36:57.600 --> 00:37:03.240
And so if you want to change the
visibility or style of the status bar,

00:37:03.240 --> 00:37:07.460
you can do that now by this new
method on UIViewController called

00:37:07.520 --> 00:37:09.460
setNeedStatusBarAppearanceUpdate.

00:37:09.900 --> 00:37:13.340
When you invoke this method,
we will re-ask the view controller

00:37:13.340 --> 00:37:16.350
what the preferred style for
the status bar should be,

00:37:16.360 --> 00:37:19.890
and we will apply those
styles to the status bar.

00:37:19.900 --> 00:37:23.180
And when you invoke
it like this directly,

00:37:23.180 --> 00:37:27.790
the changes are applied
instantaneously like this.

00:37:30.700 --> 00:37:32.450
As we learned about in
the previous session,

00:37:32.580 --> 00:37:35.440
this can be a bit of a jarring
transition for the user.

00:37:35.590 --> 00:37:42.740
We want more animation to indicate that
the status bar has actually disappeared.

00:37:42.740 --> 00:37:45.240
Maybe it's faded or
slid out or something.

00:37:45.370 --> 00:37:49.780
And so it's really easy to control
that now simply by wrapping that call

00:37:49.780 --> 00:37:54.500
to setNeedStatusBarAppearanceUpdate
inside a UIView animation block.

00:37:54.650 --> 00:37:56.920
I hope you're realizing
the implications of this.

00:37:57.030 --> 00:38:00.160
In iOS 7,
you can now have explicit control

00:38:00.410 --> 00:38:02.910
over the animation of the status bar.

00:38:03.030 --> 00:38:06.950
You can control the timing duration,
the animation curve.

00:38:06.960 --> 00:38:11.720
You can make it appear and disappear
as part of a keyframe animation.

00:38:11.860 --> 00:38:13.660
The possibilities are endless.

00:38:13.780 --> 00:38:19.280
So by putting this call
inside this animation block,

00:38:19.380 --> 00:38:23.330
the status bar will now nicely fade out.

00:38:24.770 --> 00:38:25.630
Like that.

00:38:25.630 --> 00:38:29.230
But as I said,
maybe you don't want it to fade out.

00:38:29.230 --> 00:38:31.250
Maybe you want it to slide.

00:38:31.250 --> 00:38:35.220
So you can override yet
another method called Preferred

00:38:35.220 --> 00:38:40.310
Status Bar Update Animation and return
the slide animation style to indicate

00:38:40.860 --> 00:38:46.390
that the status bar should instead slide
off the top of the screen like this.

00:38:47.320 --> 00:38:50.260
So those are some of the
changes to the status bar.

00:38:50.260 --> 00:38:53.380
You can now customize it on
a per-view controller basis.

00:38:53.450 --> 00:38:56.420
Because content now moves
behind the status bar,

00:38:56.450 --> 00:38:59.440
we have this concept of extended
layout and automatically

00:38:59.440 --> 00:39:01.750
adjusting scroll view insets.

00:39:01.840 --> 00:39:03.700
With the changes to
the status bar as well,

00:39:03.700 --> 00:39:07.340
you can have explicit control over
the animation of the status bar.

00:39:07.350 --> 00:39:10.310
A lot of things that were very,
very difficult to do in

00:39:10.380 --> 00:39:12.560
previous versions of iOS.

00:39:12.580 --> 00:39:15.870
Those are some of the changes
of UI View Controller.

00:39:18.650 --> 00:39:21.520
I want to finish by
talking about Text Kit.

00:39:21.580 --> 00:39:26.140
Text Kit is not a framework whose
headers you've been unable to find.

00:39:26.140 --> 00:39:30.230
There is no textkit.h hiding
anywhere inside the SDK.

00:39:30.290 --> 00:39:32.570
It is part of UI Kit.

00:39:32.700 --> 00:39:36.010
However,
we felt that the changes involved

00:39:36.670 --> 00:39:43.320
to text layout and text rendering
were so significant that it warranted

00:39:43.410 --> 00:39:45.970
its own name and its own icon.

00:39:46.030 --> 00:39:48.570
And so we created this name of Text Kit.

00:39:48.720 --> 00:39:52.920
But it really is just part of UI Kit.

00:39:52.970 --> 00:39:56.760
But with Text Kit,
your apps can do beautiful

00:39:57.380 --> 00:40:00.930
page layout like this,
where you have your

00:40:00.930 --> 00:40:03.540
content divided into pages.

00:40:03.550 --> 00:40:06.280
And within each page
divided into columns,

00:40:06.340 --> 00:40:09.880
you can have your text
wrap around objects,

00:40:09.880 --> 00:40:12.690
such as this text that is
wrapping around a trophy.

00:40:12.850 --> 00:40:16.780
You can have rich text attachments,
like this ornate T at the

00:40:16.780 --> 00:40:18.790
beginning of a paragraph.

00:40:19.110 --> 00:40:23.170
All sorts of beautiful
things that you can do.

00:40:23.320 --> 00:40:28.910
Now, chances are most of you are
not writing an app like Pages.

00:40:28.920 --> 00:40:33.290
And so most of you probably won't
need to build something like this.

00:40:33.620 --> 00:40:37.200
However, that does not mean that
Text Kit is not for you.

00:40:37.200 --> 00:40:40.990
We're going to talk about three key
features of Text Kit that you all should

00:40:40.990 --> 00:40:43.480
be starting to use in your apps today.

00:40:43.480 --> 00:40:47.760
But if you really want to know more
about the pagination and page layout

00:40:47.760 --> 00:40:51.650
and so on that you can do with Text Kit,
we again had three sessions from

00:40:51.650 --> 00:40:55.270
this year's WWDC that I would
highly encourage you to go watch.

00:40:55.380 --> 00:40:57.870
But the three features that we're
going to focus on in our few

00:40:57.970 --> 00:41:02.860
remaining minutes are text styles,
dynamic type, and font descriptors.

00:41:02.950 --> 00:41:05.260
So text styles are pretty simple.

00:41:05.270 --> 00:41:10.850
It's simply a way to refer
to a font by its purpose.

00:41:11.310 --> 00:41:16.420
And so we've defined these constants
in UI Kit to refer to a font that

00:41:16.420 --> 00:41:20.610
might be used for headline content,
or a font that might be

00:41:20.610 --> 00:41:24.240
used to stylize your body,
your primary content,

00:41:24.240 --> 00:41:28.700
or a font that might be used
to stylize text that appears

00:41:28.700 --> 00:41:30.160
underneath an image as a caption.

00:41:30.160 --> 00:41:51.000
Dave DeLoong So this is text styles.

00:41:51.000 --> 00:41:51.000
By simply invoking a class method
on UI font called preferred

00:41:51.000 --> 00:41:51.000
font for text style and passing
in one of these constants,

00:41:51.000 --> 00:41:51.000
you will get back a UI font that
is customized for that scenario.

00:41:51.000 --> 00:41:51.000
So this is a very easy way
to not have to worry about...

00:41:51.200 --> 00:42:45.500
[ Transcript missing ]

00:42:45.970 --> 00:42:48.150
or a large font size.

00:42:48.240 --> 00:42:50.650
We should be respecting
the user's preferences.

00:42:50.930 --> 00:42:52.020
Now, how do we do this?

00:42:52.020 --> 00:42:53.880
Well, it's very simple.

00:42:53.880 --> 00:42:56.500
We use these text styles
that I just talked about.

00:42:56.620 --> 00:43:01.000
When you ask for the preferred
font for one of these text styles,

00:43:01.170 --> 00:43:07.000
we will give you back a font object
that takes into account the user's

00:43:07.570 --> 00:43:12.570
chosen content size in the Settings app.

00:43:13.770 --> 00:43:18.570
But like other parts of the Settings app,
this content size can change

00:43:18.570 --> 00:43:21.140
while your app is running.

00:43:21.280 --> 00:43:24.750
And so to react appropriately to that,
you would need to listen to

00:43:24.750 --> 00:43:28.530
this new notification called
UI Content Size Category

00:43:28.530 --> 00:43:30.970
to Change Notification.

00:43:31.590 --> 00:43:35.290
When you receive this notification,
this would be the appropriate time

00:43:35.540 --> 00:43:39.000
to get new preferred fonts and
reapply them to your interface.

00:43:39.040 --> 00:43:41.290
Going back to this slide.

00:43:41.690 --> 00:43:46.510
As you watch the text size
of these cells change,

00:43:46.510 --> 00:43:49.720
what I want you to notice
is what does not change.

00:43:49.760 --> 00:43:53.690
And that is the text
in the navigation bar.

00:43:53.840 --> 00:43:58.430
Because this slider in the
Settings app is affecting the

00:43:58.430 --> 00:44:01.280
content size of the content.

00:44:01.330 --> 00:44:04.430
And the text in the navigation bar
is not part of the user's content.

00:44:04.440 --> 00:44:06.910
That's simply part of the
navigation of the app.

00:44:06.960 --> 00:44:10.390
Again, this goes back to the principle
of putting the emphasis

00:44:10.390 --> 00:44:12.360
on the user's content.

00:44:12.500 --> 00:44:15.230
So that's dynamic type.

00:44:15.390 --> 00:44:18.920
The third feature of Text Kit that
you all can start using today

00:44:18.930 --> 00:44:21.470
is called font descriptors.

00:44:21.970 --> 00:44:28.020
If we think about where fonts fall
in the model view controller pattern,

00:44:28.020 --> 00:44:32.170
they really are actually kind of
objects at the view level because

00:44:32.190 --> 00:44:34.210
they describe how things look.

00:44:34.340 --> 00:44:36.490
They're really only ever used with views.

00:44:36.490 --> 00:44:38.740
They're kind of view level objects.

00:44:38.940 --> 00:44:43.850
So we can think then of font descriptors
as the model that backs a font.

00:44:43.940 --> 00:44:49.260
A font descriptor will contain all
of the information about the font,

00:44:49.260 --> 00:44:54.490
what font family it is, its face,
its point size, its attributes,

00:44:54.490 --> 00:44:55.520
and so on.

00:44:55.520 --> 00:44:58.520
It is very,
very cheap to create these objects.

00:44:58.610 --> 00:45:03.190
You can create loads of them and
not be adversely affected by that,

00:45:03.190 --> 00:45:07.710
whereas that would have been very
difficult to do with UI font.

00:45:07.760 --> 00:45:11.620
One of the other neat advantages
of font descriptors is that it

00:45:11.620 --> 00:45:13.590
makes it easy to compose fonts.

00:45:13.940 --> 00:45:16.470
So you can say,
give me the font descriptor

00:45:16.470 --> 00:45:19.650
for this one font,
but apply in this point size of

00:45:19.650 --> 00:45:25.100
another font and the attributes
or the traits of a third font.

00:45:25.180 --> 00:45:28.960
And using font descriptors,
you can build up combinations of

00:45:28.960 --> 00:45:33.300
fonts in ways that would have been
somewhat difficult to do before.

00:45:35.070 --> 00:45:36.660
These fonts, as I said,
are extremely cheap.

00:45:36.760 --> 00:45:40.030
They're easy to archive,
so you can include them in whatever

00:45:40.040 --> 00:45:42.620
objects you're writing out to disk.

00:45:42.640 --> 00:45:46.520
And these should be the primary ways
that you refer to fonts in your code.

00:45:46.700 --> 00:45:49.980
And then only convert these
font descriptors to actual font

00:45:49.980 --> 00:45:53.290
objects as you are about to place
them in your user interface.

00:45:53.500 --> 00:45:57.390
But where font descriptors come in
is that they make it really easy

00:45:57.600 --> 00:46:02.660
to emulate dynamic type if you're
using custom fonts in your app.

00:46:02.740 --> 00:46:04.760
So let's see how that would look.

00:46:04.760 --> 00:46:06.720
Like I mentioned,
we need to listen to this content

00:46:06.720 --> 00:46:11.110
size category to change notification
so that we know when the user changes

00:46:11.190 --> 00:46:13.580
that slider in the Settings app.

00:46:13.760 --> 00:46:15.750
And when they do--

00:46:16.450 --> 00:46:20.290
We will ask the UI application
object for the preferred content

00:46:20.300 --> 00:46:23.890
size category and get back a
constant that indicates whether

00:46:23.890 --> 00:46:26.860
they want their content to be small,
medium, large, extra,

00:46:26.860 --> 00:46:29.130
extra large if they have
accessibility turned on,

00:46:29.140 --> 00:46:29.640
and so on.

00:46:29.660 --> 00:46:33.850
And here, in each one of these cases,
we would create the font

00:46:33.970 --> 00:46:38.170
descriptors that are appropriate
for a headline font style,

00:46:38.240 --> 00:46:40.440
a body text style, and so on.

00:46:40.960 --> 00:46:43.960
And like I said,
we can compose these font descriptors

00:46:43.960 --> 00:46:48.530
by taking attributes of various fonts,
combining them together, and so on.

00:46:48.580 --> 00:46:52.720
So, using font descriptors,
you can still take advantage of the

00:46:52.850 --> 00:46:58.180
dynamic type feature while still using
custom fonts in your application.

00:46:58.180 --> 00:47:01.830
So, those are just some of the ways
that you can adopt Text Kit,

00:47:01.900 --> 00:47:04.830
even if you don't have an
app that's complicated,

00:47:04.830 --> 00:47:09.680
like Pages, because there is a lot in
it that everybody can use.

00:47:09.680 --> 00:47:11.950
So, you can use... Text styles.

00:47:11.980 --> 00:47:15.600
Use UI font descriptors for
referring to your fonts in

00:47:15.600 --> 00:47:17.760
a cheap and easy-to-use way.

00:47:17.760 --> 00:47:20.120
And, of course,
listen to the dynamic type

00:47:20.160 --> 00:47:24.410
notification so that we can react
intelligently to the user's decisions.

00:47:24.420 --> 00:47:29.190
And that's a brief look at Text Kit,
and it completes our tour of

00:47:29.190 --> 00:47:31.900
new features in UI Kit in iOS 7.
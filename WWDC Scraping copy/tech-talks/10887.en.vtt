WEBVTT

00:00:01.001 --> 00:00:02.536
David Wendland: Hi everyone,
I'm David Wendland,

00:00:02.536 --> 00:00:05.606
a commerce technical advocate
for the App Store.

00:00:05.606 --> 00:00:07.674
I'm excited to be
here today, virtually,

00:00:07.674 --> 00:00:10.244
to share what our whole team
has been working on.

00:00:10.244 --> 00:00:12.880
Before I begin, I'd like my
Cupertino-based colleagues

00:00:12.880 --> 00:00:15.682
to introduce themselves.

00:00:15.682 --> 00:00:17.517
Manjeet Chawla: Hi, my name
is Manjeet Chawla,

00:00:17.517 --> 00:00:21.922
and I'm a technical program
manager for the App Store.

00:00:21.922 --> 00:00:23.523
Joe Mani: Hi, I'm Joe.

00:00:23.523 --> 00:00:26.493
I'm a program manager
for the App Store.

00:00:26.493 --> 00:00:28.562
David: The three of us today
are presenting you

00:00:28.562 --> 00:00:30.264
a three-part series titled

00:00:30.264 --> 00:00:34.868
"Support Customers with StoreKit
2 and App Store Server API."

00:00:34.868 --> 00:00:37.070
We will focus on how
the StoreKit 2 framework

00:00:37.070 --> 00:00:39.539
and the abilities of
the App Store Server API

00:00:39.539 --> 00:00:42.576
can improve in-app purchase,
customer support,

00:00:42.576 --> 00:00:44.344
and handling refunds.

00:00:44.344 --> 00:00:46.780
These three parts we hope
will give you insights,

00:00:46.780 --> 00:00:49.182
approaches, and benefits
to consider when planning

00:00:49.182 --> 00:00:52.286
your app and customer experience
enhancements.

00:00:52.286 --> 00:00:53.954
I'll get going with
in-app purchases

00:00:53.954 --> 00:00:56.356
by starting with an overview
of our Fall launch,

00:00:56.356 --> 00:00:59.893
and what's new from client
to server to sandbox.

00:00:59.893 --> 00:01:01.762
And then I'll cover some
implementation approaches

00:01:01.762 --> 00:01:04.298
to consider to help you
strategize and prioritize

00:01:04.298 --> 00:01:07.968
your roadmap when looking
to integrate these updates.

00:01:07.968 --> 00:01:09.836
Let's get started
with what's new.

00:01:09.836 --> 00:01:12.706
With iOS 15,
we went back to the start

00:01:12.706 --> 00:01:15.309
and created an all-new
and improved framework

00:01:15.309 --> 00:01:18.912
to simplify the client
implementation with StoreKit 2.

00:01:18.912 --> 00:01:21.348
This brought more
on-device functionality,

00:01:21.348 --> 00:01:24.484
improved status information,
and now transactions

00:01:24.484 --> 00:01:27.721
use the JWS format
for added security.

00:01:27.721 --> 00:01:30.791
In addition, we introduced
three standalone features

00:01:30.791 --> 00:01:32.926
to provide more services
to the customers

00:01:32.926 --> 00:01:35.095
directly within your app.

00:01:35.095 --> 00:01:37.931
From the server side,
we made a significant update

00:01:37.931 --> 00:01:40.634
to the existing App Store
Server Notifications

00:01:40.634 --> 00:01:42.836
with the launch of Version 2.

00:01:42.836 --> 00:01:45.973
This greatly expanded the number
of supported purchase events

00:01:45.973 --> 00:01:49.076
and also uses
the new JWS format.

00:01:49.076 --> 00:01:51.578
Lastly, we released
a suite of features

00:01:51.578 --> 00:01:53.547
with our App Store Server API.

00:01:53.547 --> 00:01:56.917
It has an array of endpoints
to support different abilities,

00:01:56.917 --> 00:01:59.186
from retrieving a customer's
purchase history

00:01:59.186 --> 00:02:02.956
or providing you a subscriber's
current subscription status.

00:02:02.956 --> 00:02:04.725
The other abilities cover
a variety of

00:02:04.725 --> 00:02:07.294
customer management scenarios
which my colleagues,

00:02:07.294 --> 00:02:10.163
Manjeet and Joe,
will be covering shortly.

00:02:10.163 --> 00:02:12.366
This year's extensive
list of updates illustrates

00:02:12.366 --> 00:02:15.869
our continued investment in
in-app purchase with StoreKit.

00:02:15.869 --> 00:02:19.072
Overall, these improve security,
reduce complexity,

00:02:19.072 --> 00:02:21.508
and make it easier
to test in-app purchases

00:02:21.508 --> 00:02:24.244
in Sandbox and Xcode.

00:02:24.244 --> 00:02:25.712
When we look at our platform,

00:02:25.712 --> 00:02:28.281
with features like
Touch ID and Face ID,

00:02:28.281 --> 00:02:31.985
we use secure biometrics
and frictionless authentication

00:02:31.985 --> 00:02:35.422
to allow customers to purchase
securely and conveniently

00:02:35.422 --> 00:02:37.924
on more than
1.5 billion devices.

00:02:37.924 --> 00:02:40.861
The App Store now has
600 million weekly visitors

00:02:40.861 --> 00:02:44.998
across 175 storefronts,
in over 40 languages.

00:02:44.998 --> 00:02:47.167
You can adjust
price tiers per territory

00:02:47.167 --> 00:02:48.468
and next year we'll be expanding

00:02:48.468 --> 00:02:51.505
the number of supported
price tiers to over 500,

00:02:51.505 --> 00:02:53.206
giving you more pricing options

00:02:53.206 --> 00:02:54.875
and providing tailored
price points

00:02:54.875 --> 00:02:57.778
for each currency and market.

00:02:57.778 --> 00:03:02.482
With 45 supported currencies
across 195 payment methods,

00:03:02.482 --> 00:03:04.785
we work to make it more
convenient for our customers

00:03:04.785 --> 00:03:06.453
to use their preferred
payment method

00:03:06.453 --> 00:03:08.455
and the ability to stack them.

00:03:08.455 --> 00:03:10.924
While we continue
these platform improvements,

00:03:10.924 --> 00:03:12.926
I'd now like to dig in
to StoreKit 2

00:03:12.926 --> 00:03:15.395
and highlight its benefits
and key enhancements

00:03:15.395 --> 00:03:18.865
over original StoreKit
for you to consider.

00:03:18.865 --> 00:03:21.334
When we look at
a key feature of StoreKit 2,

00:03:21.334 --> 00:03:24.304
it synchronizes new
in-app purchase transactions

00:03:24.304 --> 00:03:27.340
automatically across
all the customer's devices.

00:03:27.340 --> 00:03:29.843
This enables you to provide
a consistent and reliable

00:03:29.843 --> 00:03:31.378
experience in your app.

00:03:31.378 --> 00:03:33.980
This framework supports
on-device purchase validation

00:03:33.980 --> 00:03:36.450
and is streamlined compared
to the earlier framework,

00:03:36.450 --> 00:03:38.351
so you do not have
to entirely depend on

00:03:38.351 --> 00:03:40.420
server-side purchase validation.

00:03:40.420 --> 00:03:42.856
All transactions are signed
using JWS,

00:03:42.856 --> 00:03:43.924
so that you can verify

00:03:43.924 --> 00:03:46.359
the authenticity
of each transaction.

00:03:46.359 --> 00:03:49.429
And the framework provides
entitlement status information

00:03:49.429 --> 00:03:52.265
on-device,
which reduces complexity

00:03:52.265 --> 00:03:55.168
so you can ensure proper
entitlement access.

00:03:55.168 --> 00:03:57.637
And new with iOS 15
is appAccountToken,

00:03:57.637 --> 00:03:58.705
which allows you to set

00:03:58.705 --> 00:04:01.508
the in-app account
that initiated the purchase

00:04:01.508 --> 00:04:04.344
and have it returned
with completed transactions.

00:04:04.344 --> 00:04:06.546
Additionally, there are
some unique standalone

00:04:06.546 --> 00:04:09.015
StoreKit 2 features
that can work alongside

00:04:09.015 --> 00:04:10.717
the original StoreKit
framework.

00:04:10.717 --> 00:04:13.820
So your app today using
original StoreKit with iOS 15

00:04:13.820 --> 00:04:16.723
could also add these
independent StoreKit 2 features

00:04:16.723 --> 00:04:19.593
to offer in-app experiences
that typically would occur

00:04:19.593 --> 00:04:21.328
outside of your app.

00:04:21.328 --> 00:04:23.663
The first is
showManageSubscriptions.

00:04:23.663 --> 00:04:26.133
This allows subscribers
to manage their subscription

00:04:26.133 --> 00:04:27.567
without leaving your app.

00:04:27.567 --> 00:04:29.936
Then we have
beginRefundRequest,

00:04:29.936 --> 00:04:32.405
where you can present
transactions to a customer

00:04:32.405 --> 00:04:34.574
for which they can
initiate a refund request

00:04:34.574 --> 00:04:36.143
from within your app.

00:04:36.143 --> 00:04:38.945
And with this, in Sandbox,
this allows you to test

00:04:38.945 --> 00:04:42.816
and simulate a refund from
pending to approved or declined.

00:04:42.816 --> 00:04:45.185
We've also introduced
an ability to make it easier

00:04:45.185 --> 00:04:48.555
to check a customer's
introductory offer eligibility.

00:04:48.555 --> 00:04:50.190
This is important
as you want to ensure

00:04:50.190 --> 00:04:52.759
when merchandising an offer,
like a free trial,

00:04:52.759 --> 00:04:54.161
that when they complete
the purchase,

00:04:54.161 --> 00:04:56.663
they are in fact
given the offer.

00:04:56.663 --> 00:04:59.299
With StoreKit 2, this check
can quickly be done

00:04:59.299 --> 00:05:02.135
with isEligibleForIntroOffer
method,

00:05:02.135 --> 00:05:04.538
and passing in
a subscription group ID.

00:05:04.538 --> 00:05:07.007
This checks if they have ever
consumed any type

00:05:07.007 --> 00:05:09.309
of introductory offer
for any subscription

00:05:09.309 --> 00:05:11.578
within that subscription group.

00:05:11.578 --> 00:05:13.580
In addition, you should
also be merchandising

00:05:13.580 --> 00:05:17.184
the introductory offer only
if it was returned by StoreKit.

00:05:17.184 --> 00:05:19.352
That would come from
Product.SubscriptionOffer,

00:05:19.352 --> 00:05:22.055
where it will return
the introductory offer details

00:05:22.055 --> 00:05:23.223
if available.

00:05:23.223 --> 00:05:25.792
If it is not, then it will not
be returned by StoreKit,

00:05:25.792 --> 00:05:28.528
thus preventing you
from merchandising an offer

00:05:28.528 --> 00:05:29.629
that isn't available.

00:05:29.629 --> 00:05:31.598
So it's important that
this is not hardcoded

00:05:31.598 --> 00:05:34.034
and instead, your app
leverages StoreKit,

00:05:34.034 --> 00:05:35.602
which uses
the start and end dates

00:05:35.602 --> 00:05:38.138
configured in App Store Connect.

00:05:38.138 --> 00:05:39.539
Now I want to move server side

00:05:39.539 --> 00:05:42.108
and discuss features
of the App Store Server API,

00:05:42.108 --> 00:05:44.244
where requests
are made server-to-server

00:05:44.244 --> 00:05:47.013
without any customer
interaction.

00:05:47.013 --> 00:05:48.748
We'll start with
subscription status.

00:05:48.748 --> 00:05:51.017
This provides the state
of the customer's subscription

00:05:51.017 --> 00:05:52.085
with your app.

00:05:52.085 --> 00:05:54.254
And if you have multiple
subscription offerings,

00:05:54.254 --> 00:05:55.922
then you will have
an entitlement state

00:05:55.922 --> 00:05:58.425
per subscription,
each represented by

00:05:58.425 --> 00:06:01.361
a unique original
transaction ID.

00:06:01.361 --> 00:06:03.129
A great part
of subscription status

00:06:03.129 --> 00:06:07.133
is it only returns the current
JWS signed transaction

00:06:07.133 --> 00:06:08.702
for each subscription,

00:06:08.702 --> 00:06:10.503
so no need for logic
on your server

00:06:10.503 --> 00:06:12.839
to parse through a customer's
transaction history,

00:06:12.839 --> 00:06:15.108
trying to determine
their current transaction

00:06:15.108 --> 00:06:17.244
or which product to entitle.

00:06:17.244 --> 00:06:19.679
Now if you are a multiplatform
service provider,

00:06:19.679 --> 00:06:22.182
you can use this service
to get the current status

00:06:22.182 --> 00:06:24.084
at any time,
server-to-server,

00:06:24.084 --> 00:06:26.086
without your app running,
and all you need

00:06:26.086 --> 00:06:28.555
is the customer's
original transaction ID;

00:06:28.555 --> 00:06:30.557
no more app receipt.

00:06:30.557 --> 00:06:33.260
Here are some best practices
we recommend.

00:06:33.260 --> 00:06:34.694
It is important you always store

00:06:34.694 --> 00:06:37.664
the unique original transaction
IDs in your database

00:06:37.664 --> 00:06:40.567
after every purchase
or restored transaction.

00:06:40.567 --> 00:06:43.169
This value represents
each subscription offering,

00:06:43.169 --> 00:06:45.672
which is critical to track
the subscription lifecycle

00:06:45.672 --> 00:06:47.507
from initial purchase
to renewals,

00:06:47.507 --> 00:06:49.209
to a billing issue
and recovery,

00:06:49.209 --> 00:06:50.977
or upgrades and downgrades.

00:06:50.977 --> 00:06:53.947
This ID is used with the client
and the server API,

00:06:53.947 --> 00:06:56.182
along with server notifications.

00:06:56.182 --> 00:06:58.885
Lastly, subscription status
should only be used

00:06:58.885 --> 00:07:01.788
server-to-server
as a security best practice.

00:07:01.788 --> 00:07:04.024
If you need to check the status
directly from your app,

00:07:04.024 --> 00:07:07.761
then the StoreKit 2 framework
has your solution.

00:07:07.761 --> 00:07:09.229
The next feature
with the server API

00:07:09.229 --> 00:07:11.031
is in-app purchase history,

00:07:11.031 --> 00:07:13.166
where you can retrieve,
server-to-server,

00:07:13.166 --> 00:07:16.936
the complete and latest history
of transactions for a customer.

00:07:16.936 --> 00:07:19.472
The history will include
all nonconsumables,

00:07:19.472 --> 00:07:22.342
nonrenewing subscriptions,
autorenewable subscriptions,

00:07:22.342 --> 00:07:25.245
and any unfinished
consumable purchases,

00:07:25.245 --> 00:07:29.816
and all will be secure,
JWS signed transactions.

00:07:29.816 --> 00:07:31.584
Now, having a history
of transactions

00:07:31.584 --> 00:07:34.120
and all original transaction IDs
will help

00:07:34.120 --> 00:07:37.157
when implementing
the beginRefundRequest API,

00:07:37.157 --> 00:07:39.059
as you will need
to surface transactions

00:07:39.059 --> 00:07:40.527
for the customer
to choose from

00:07:40.527 --> 00:07:43.096
in order to initiate
the refund request.

00:07:43.096 --> 00:07:45.231
For nonsubscription
in-app purchases

00:07:45.231 --> 00:07:47.067
in apps using
the original StoreKit,

00:07:47.067 --> 00:07:49.035
you can move away
from verifyReceipt

00:07:49.035 --> 00:07:52.172
and use this API to validate
successful purchases

00:07:52.172 --> 00:07:54.674
or check for updates
in case of an outage.

00:07:54.674 --> 00:07:56.376
For its best practices,

00:07:56.376 --> 00:07:58.445
some customers may have
many purchases,

00:07:58.445 --> 00:08:02.282
so the response will contain
up to 20 transactions at a time.

00:08:02.282 --> 00:08:04.184
When there are additional
transactions,

00:08:04.184 --> 00:08:06.119
be sure to use
the hasMore field.

00:08:06.119 --> 00:08:08.054
When true,
use the revision token

00:08:08.054 --> 00:08:10.457
in that response
and your subsequent request

00:08:10.457 --> 00:08:12.659
to get that next page
of transactions.

00:08:12.659 --> 00:08:15.095
Repeat until the hasMore field
returns false

00:08:15.095 --> 00:08:17.430
and save that revision token
for the future.

00:08:17.430 --> 00:08:18.865
That will help you
quickly retrieve

00:08:18.865 --> 00:08:20.800
the latest transactions
of a customer,

00:08:20.800 --> 00:08:22.669
using that recorded
revision token

00:08:22.669 --> 00:08:26.039
so that you do not
have to paginate again.

00:08:26.039 --> 00:08:29.409
Another important best practice
is using finishTransaction

00:08:29.409 --> 00:08:32.112
after products or services
have been delivered.

00:08:32.112 --> 00:08:34.114
Unfinished transactions
will remain in the queue

00:08:34.114 --> 00:08:36.249
and help your app
to keep track of purchases

00:08:36.249 --> 00:08:38.618
that need to be delivered
to your customers.

00:08:38.618 --> 00:08:42.856
This is critical in case there
was any interruption on-device.

00:08:42.856 --> 00:08:45.091
A final recommendation
regarding refunded

00:08:45.091 --> 00:08:46.659
or revoked transactions

00:08:46.659 --> 00:08:48.495
is if you want to receive
updates on these

00:08:48.495 --> 00:08:50.897
as quickly and efficiently
as possible,

00:08:50.897 --> 00:08:53.266
then look to Version 2
server notifications.

00:08:53.266 --> 00:08:57.303
These are much more efficient
than polling any of our APIs.

00:08:57.303 --> 00:08:59.339
Now look at our server
notifications.

00:08:59.339 --> 00:09:03.043
These are sent in near real-time
directly to your server

00:09:03.043 --> 00:09:05.879
for key purchase events
and status changes.

00:09:05.879 --> 00:09:08.515
This year we dramatically
refined this feature

00:09:08.515 --> 00:09:10.750
with Version 2
to make them more effective,

00:09:10.750 --> 00:09:14.020
easier to use,
and provide more granularity.

00:09:14.020 --> 00:09:15.922
We doubled the number
of supported events,

00:09:15.922 --> 00:09:18.925
bringing that total
to 28 unique events!

00:09:18.925 --> 00:09:22.896
With Version 2 we only send
a single notification per event,

00:09:22.896 --> 00:09:25.899
so you can take specific actions
when received.

00:09:25.899 --> 00:09:28.401
And these notifications
also apply to family members

00:09:28.401 --> 00:09:30.236
who have access
through Family Sharing

00:09:30.236 --> 00:09:31.604
for in-app purchases.

00:09:31.604 --> 00:09:34.274
And for any failed notification
deliveries,

00:09:34.274 --> 00:09:38.278
we will retry up to five times
over a period of seven days,

00:09:38.278 --> 00:09:40.280
to account for any outages.

00:09:40.280 --> 00:09:42.816
And of course, Version 2
is available in Sandbox,

00:09:42.816 --> 00:09:46.019
so you can develop safely
in our test environment.

00:09:46.019 --> 00:09:47.253
For some best practices,

00:09:47.253 --> 00:09:49.022
when receiving
these notifications,

00:09:49.022 --> 00:09:53.460
it is important to respond with
an HTTP 200 Response Code

00:09:53.460 --> 00:09:55.295
when it was
successfully received.

00:09:55.295 --> 00:09:58.364
This indicates to us that you
have received the notification

00:09:58.364 --> 00:10:01.101
and that you do not
need us to resend.

00:10:01.101 --> 00:10:03.837
If your servers return an error
or don't respond,

00:10:03.837 --> 00:10:07.073
the App Store will resend
the same notification payload.

00:10:07.073 --> 00:10:10.043
Within each notification
is the signedDate;

00:10:10.043 --> 00:10:13.279
you can know exactly when that
original notification was sent.

00:10:13.279 --> 00:10:15.281
And you can validate
the authenticity

00:10:15.281 --> 00:10:19.619
of received notifications using
the JWS signed transaction info,

00:10:19.619 --> 00:10:20.653
so you can have confidence

00:10:20.653 --> 00:10:23.256
that these were signed
by the App Store.

00:10:23.256 --> 00:10:25.125
And be sure to take advantage
of the new ability

00:10:25.125 --> 00:10:27.093
to provide unique server URLs

00:10:27.093 --> 00:10:29.596
for sandbox and production
events.

00:10:29.596 --> 00:10:31.431
And as a final best practice,

00:10:31.431 --> 00:10:33.967
apply the notification updates
immediately.

00:10:33.967 --> 00:10:37.904
Some events are time-sensitive,
such as upgrades or refunds.

00:10:37.904 --> 00:10:39.806
Therefore, processing these
in near real-time

00:10:39.806 --> 00:10:41.975
can be beneficial.

00:10:41.975 --> 00:10:43.510
And our last update
to brief you on

00:10:43.510 --> 00:10:45.178
is our updates
in App Store Connect

00:10:45.178 --> 00:10:47.780
to help with testing in-app
purchases in Sandbox.

00:10:47.780 --> 00:10:49.315
You will find these features
accessible

00:10:49.315 --> 00:10:52.519
in the Users & Access tab
under Sandbox testers.

00:10:52.519 --> 00:10:54.687
As you may know already,
in Sandbox today,

00:10:54.687 --> 00:10:57.290
subscriptions renew
at an accelerated rate

00:10:57.290 --> 00:10:58.691
to support testing.

00:10:58.691 --> 00:11:01.794
Now we've added the ability
to slow down or accelerate

00:11:01.794 --> 00:11:04.531
that renewal rate
per Sandbox Apple ID,

00:11:04.531 --> 00:11:06.933
just like you can with StoreKit
testing in Xcode.

00:11:06.933 --> 00:11:08.468
This should be helpful
for scenarios

00:11:08.468 --> 00:11:10.870
when you need more time
to perform actions

00:11:10.870 --> 00:11:12.839
between the renewals.

00:11:12.839 --> 00:11:14.807
To help with testing across
different storefronts,

00:11:14.807 --> 00:11:16.209
now you can
change the storefront

00:11:16.209 --> 00:11:18.645
for a Sandbox Apple ID
at any time.

00:11:18.645 --> 00:11:22.282
And to further expand the use
of a single Sandbox Apple ID,

00:11:22.282 --> 00:11:24.083
you can now clear
its purchase history

00:11:24.083 --> 00:11:27.287
of autorenewable subscriptions
and nonconsumables,

00:11:27.287 --> 00:11:29.656
allowing you, for example,
to purchase content

00:11:29.656 --> 00:11:33.426
or redeem introductory offers
repeatedly.

00:11:33.426 --> 00:11:34.961
Now that we've covered
some of the benefits

00:11:34.961 --> 00:11:38.097
and best practices of StoreKit 2
and the Server API,

00:11:38.097 --> 00:11:39.832
let's review some approaches
for you to consider

00:11:39.832 --> 00:11:42.368
when preparing to integrate
these features and abilities

00:11:42.368 --> 00:11:44.904
into your app or server.

00:11:44.904 --> 00:11:46.272
When we think about
in-app purchases,

00:11:46.272 --> 00:11:48.541
we primarily think about
entitling customers

00:11:48.541 --> 00:11:51.211
with their purchases
and handling status changes.

00:11:51.211 --> 00:11:52.812
To do this, you have to choose

00:11:52.812 --> 00:11:54.380
to go with an on-device
approach --

00:11:54.380 --> 00:11:57.116
where you do it all locally
without any server backend --

00:11:57.116 --> 00:11:59.218
or you leverage
serve-to-server APIs,

00:11:59.218 --> 00:12:02.255
where your server
is the source of truth.

00:12:02.255 --> 00:12:03.590
Let's start with on-device.

00:12:03.590 --> 00:12:05.992
This is where the StoreKit 2
framework provides your app

00:12:05.992 --> 00:12:08.962
the ability to fully manage
in-app purchases

00:12:08.962 --> 00:12:11.264
and status changes
all on-device,

00:12:11.264 --> 00:12:12.799
without requiring a server.

00:12:12.799 --> 00:12:14.734
This can be very helpful
for small businesses

00:12:14.734 --> 00:12:17.470
and those without
an existing server backend.

00:12:17.470 --> 00:12:20.573
To do this, you start with these
three core functional pieces

00:12:20.573 --> 00:12:23.776
of StoreKit 2
to support the purchase flow.

00:12:23.776 --> 00:12:24.877
Your app will use Products

00:12:24.877 --> 00:12:27.814
to retrieve your available
products and its details

00:12:27.814 --> 00:12:30.149
to drive the merchandising
within your app.

00:12:30.149 --> 00:12:32.652
This ensures its always
accurate and in sync

00:12:32.652 --> 00:12:34.220
with the App Store.

00:12:34.220 --> 00:12:36.990
And now with StoreKit 2,
you will have VerificationResult

00:12:36.990 --> 00:12:39.225
and PurchaseResult,
which together are used

00:12:39.225 --> 00:12:41.928
to validate the authenticity
of the transaction

00:12:41.928 --> 00:12:45.832
after a successful purchase
or restored transaction.

00:12:45.832 --> 00:12:48.201
Another key benefit
of the StoreKit 2 framework

00:12:48.201 --> 00:12:52.305
is its ability to keep your app
up-to-date for any transaction.

00:12:52.305 --> 00:12:53.973
Customers may have
multiple devices,

00:12:53.973 --> 00:12:57.243
and with Transaction.updates,
your app will be kept in sync

00:12:57.243 --> 00:13:00.880
no matter what device
the transaction originated on.

00:13:00.880 --> 00:13:02.315
With currentEntitlement method,

00:13:02.315 --> 00:13:04.717
your app can quickly
get the immediate status

00:13:04.717 --> 00:13:06.986
for your customer's purchases,
so you can immediately

00:13:06.986 --> 00:13:08.888
grant those products
to the customers --

00:13:08.888 --> 00:13:11.090
all without requiring them
to login

00:13:11.090 --> 00:13:12.892
or perform a Restore Purchases,

00:13:12.892 --> 00:13:16.029
as you have the latest
transaction details.

00:13:16.029 --> 00:13:18.298
Lastly, we understand
how important it is to get

00:13:18.298 --> 00:13:21.234
the autorenewable subscription
information on-device,

00:13:21.234 --> 00:13:22.735
not just about
the product itself

00:13:22.735 --> 00:13:24.804
but about the current
subscriber's status

00:13:24.804 --> 00:13:26.606
and their upcoming
renewal period.

00:13:26.606 --> 00:13:29.075
For that we have
Product.SubscriptionInfo.

00:13:29.075 --> 00:13:31.544
So with these six core functions
that I just covered,

00:13:31.544 --> 00:13:34.347
you can take advantage
of StoreKit 2 on iOS 15

00:13:34.347 --> 00:13:37.317
and reduce or eliminate
your dependency on a server

00:13:37.317 --> 00:13:40.053
to deliver the best
customer experience.

00:13:40.053 --> 00:13:42.689
Now, when we think about
a server-to-server architecture,

00:13:42.689 --> 00:13:44.557
this is critical
for multiplatform

00:13:44.557 --> 00:13:46.092
or multiapp services

00:13:46.092 --> 00:13:49.395
where customers expect to access
their services reliably,

00:13:49.395 --> 00:13:50.797
and your systems are required

00:13:50.797 --> 00:13:53.366
to keep updated on the status
of their purchases

00:13:53.366 --> 00:13:55.501
at any time in real time.

00:13:55.501 --> 00:13:56.602
Typically in this setup,

00:13:56.602 --> 00:13:58.738
you have your server
as the source of truth,

00:13:58.738 --> 00:14:01.174
where it is online 24/7
to receive

00:14:01.174 --> 00:14:04.077
and check for updates
with the App Store at any time.

00:14:04.077 --> 00:14:07.346
But let's look at this flow
from your app's perspective.

00:14:07.346 --> 00:14:08.881
Here we have
the customer's device,

00:14:08.881 --> 00:14:10.316
and let's assume
your app is running

00:14:10.316 --> 00:14:13.720
using the original StoreKit
framework to initiate purchases

00:14:13.720 --> 00:14:15.922
and using App Store
verifyReceipt server

00:14:15.922 --> 00:14:17.957
for purchase validation.

00:14:17.957 --> 00:14:21.594
This means your app sends
the Base64-encoded app receipt

00:14:21.594 --> 00:14:24.630
to your server after a purchase
or restore event,

00:14:24.630 --> 00:14:26.532
and then it's sent
to the verifyReceipt server.

00:14:26.532 --> 00:14:29.602
The App Store will respond with
the customer's transactions,

00:14:29.602 --> 00:14:30.937
where now your server will need

00:14:30.937 --> 00:14:32.638
to parse through
those transactions

00:14:32.638 --> 00:14:35.074
to evaluate
and determine the status

00:14:35.074 --> 00:14:37.310
and what actions
need to be taken server-side

00:14:37.310 --> 00:14:39.278
or within your app.

00:14:39.278 --> 00:14:41.180
Now, you may have asked
yourself this question.

00:14:41.180 --> 00:14:43.516
The good news is no,
the App Store Server API

00:14:43.516 --> 00:14:45.318
has no dependency on your app

00:14:45.318 --> 00:14:48.287
adopting the entire
StoreKit 2 framework.

00:14:48.287 --> 00:14:49.489
This means you can
take advantage

00:14:49.489 --> 00:14:51.324
of the new functionality
available

00:14:51.324 --> 00:14:53.426
with the App Store Server API
right away,

00:14:53.426 --> 00:14:56.729
all while your app continues
using original StoreKit.

00:14:56.729 --> 00:14:59.532
Let's walk through
how you can do this.

00:14:59.532 --> 00:15:00.433
With that same design,

00:15:00.433 --> 00:15:02.835
you would need to make
two primary changes.

00:15:02.835 --> 00:15:04.237
First, we'll update your app

00:15:04.237 --> 00:15:06.773
to retrieve the original
transaction ID.

00:15:06.773 --> 00:15:08.040
Second, you'll update
your server

00:15:08.040 --> 00:15:10.076
to use the App Store Server API.

00:15:10.076 --> 00:15:13.012
These two changes allow your app
to use original StoreKit

00:15:13.012 --> 00:15:14.614
or StoreKit 2,
making it easy

00:15:14.614 --> 00:15:18.351
to support the latest app
version on any iOS version.

00:15:18.351 --> 00:15:19.852
To do that first change
and start using

00:15:19.852 --> 00:15:22.221
the original_transaction_ID
going forward,

00:15:22.221 --> 00:15:23.890
you will replace your logic

00:15:23.890 --> 00:15:26.692
that retrieves the Base64
app receipt.

00:15:26.692 --> 00:15:28.327
To do this, you may have
been using

00:15:28.327 --> 00:15:30.863
the app receipt URL method.

00:15:30.863 --> 00:15:33.232
Go ahead and replace it
with this property

00:15:33.232 --> 00:15:35.434
for autorenewable
subscriptions.

00:15:35.434 --> 00:15:37.003
And for other in-app
purchase types,

00:15:37.003 --> 00:15:39.472
you'll use this similar
property.

00:15:39.472 --> 00:15:43.176
Now let's update your server
to use the App Store Server API.

00:15:43.176 --> 00:15:44.744
You'll change from
/verifyReceipt

00:15:44.744 --> 00:15:47.580
to the /History or
/SubscriptionStatus URL.

00:15:47.580 --> 00:15:50.316
Requests will use JWT
for authorization,

00:15:50.316 --> 00:15:53.820
and you'll use the original
transaction ID going forward.

00:15:53.820 --> 00:15:55.221
With these completed
changes,

00:15:55.221 --> 00:15:58.591
you no longer have entitlement
logic to maintain on your server

00:15:58.591 --> 00:16:01.761
and you now can use
secure JWS signed transactions

00:16:01.761 --> 00:16:04.697
and have eliminated the need
to store app receipts.

00:16:04.697 --> 00:16:07.300
So if your app supports
older versions of iOS,

00:16:07.300 --> 00:16:09.335
this gives you a path
to take advantage

00:16:09.335 --> 00:16:12.672
of what App Store Server API
has to offer.

00:16:12.672 --> 00:16:16.142
Now earlier, we mentioned how
StoreKit 2 and the server API

00:16:16.142 --> 00:16:18.911
handle determining subscription
state for you.

00:16:18.911 --> 00:16:21.247
Now as a best practice,
your app should always

00:16:21.247 --> 00:16:24.150
determine the subscriber state
upon app launch.

00:16:24.150 --> 00:16:25.618
Once the state is determined,

00:16:25.618 --> 00:16:28.554
it can be stored locally
and updated as needed.

00:16:28.554 --> 00:16:31.290
I want to briefly review
these five states we return

00:16:31.290 --> 00:16:33.359
and the actions you need
to take for each,

00:16:33.359 --> 00:16:35.595
along with some opportunities
to consider.

00:16:35.595 --> 00:16:36.662
Now it should be noted,

00:16:36.662 --> 00:16:39.065
a new customer would not
have any of these states,

00:16:39.065 --> 00:16:42.702
and that is a state your app
needs to manage as well.

00:16:42.702 --> 00:16:43.936
Starting with Active state,

00:16:43.936 --> 00:16:46.405
this means service should
be provided to the customer

00:16:46.405 --> 00:16:48.074
until their expires date.

00:16:48.074 --> 00:16:50.142
Now If you provide
multiple levels of service,

00:16:50.142 --> 00:16:52.111
one opportunity
could be to surface

00:16:52.111 --> 00:16:55.248
an upgrade offer in-app
using promotional offers.

00:16:55.248 --> 00:16:57.583
Note that such offers should be
tailored to the customer

00:16:57.583 --> 00:17:00.920
based on their past
subscription history.

00:17:00.920 --> 00:17:02.922
Now when a subscription
has fully churned,

00:17:02.922 --> 00:17:04.757
you will have
the state of Expired.

00:17:04.757 --> 00:17:07.260
No service needs to be provided
and you can merchandise

00:17:07.260 --> 00:17:09.729
your current
subscription offering.

00:17:09.729 --> 00:17:11.898
Optionally, you can leverage
promotional offers

00:17:11.898 --> 00:17:15.134
or subscription offer codes
to present a win-back offer.

00:17:15.134 --> 00:17:18.337
If they resubscribe within
60 days of their expires date,

00:17:18.337 --> 00:17:20.673
their existing accrued
paid days of service

00:17:20.673 --> 00:17:24.377
will resume towards
the 85 percent proceeds rate.

00:17:24.377 --> 00:17:26.445
Next is billing retry period.

00:17:26.445 --> 00:17:29.048
We all experience billing issues
from time to time;

00:17:29.048 --> 00:17:32.218
credit cards can expire
or store credit can be consumed.

00:17:32.218 --> 00:17:34.654
These subscriptions
were expected to autorenew,

00:17:34.654 --> 00:17:36.355
but due to their
payment method issue,

00:17:36.355 --> 00:17:39.659
they fell into what we call
the billing retry period.

00:17:39.659 --> 00:17:41.193
While the subscription
is expired

00:17:41.193 --> 00:17:42.695
and no service
needs to be rendered,

00:17:42.695 --> 00:17:45.031
the customer also doesn't need
to resubscribe;

00:17:45.031 --> 00:17:47.433
they simply need to resolve
their billing issue.

00:17:47.433 --> 00:17:49.568
We will automatically
reattempt to retry

00:17:49.568 --> 00:17:51.904
and recover the subscription
for up to 60 days

00:17:51.904 --> 00:17:53.873
through various
customer communications

00:17:53.873 --> 00:17:55.441
without any developer action.

00:17:55.441 --> 00:17:56.609
But with in-app messaging,

00:17:56.609 --> 00:17:59.245
you could directly alert the
customer to their billing issue

00:17:59.245 --> 00:18:01.180
and provide a valuable
call to action

00:18:01.180 --> 00:18:02.515
that can deep link the customer

00:18:02.515 --> 00:18:05.584
to their payment info page
to resolve.

00:18:05.584 --> 00:18:08.654
Next is grace period, which is
related to billing retry

00:18:08.654 --> 00:18:10.356
but only applies
to your subscribers

00:18:10.356 --> 00:18:13.125
if you have opted in to
App Store Billing Grace Period

00:18:13.125 --> 00:18:14.226
in App Store Connect.

00:18:14.226 --> 00:18:16.495
For this state, you will
continue providing service

00:18:16.495 --> 00:18:20.132
with no disruption until
the grace period expires date.

00:18:20.132 --> 00:18:22.601
If we recover the subscriber
during their grace period,

00:18:22.601 --> 00:18:25.204
they will retain
their original billing cycle.

00:18:25.204 --> 00:18:27.473
Therefore, they have
no disruption in service

00:18:27.473 --> 00:18:31.043
and the provider avoids
any lost billable days.

00:18:31.043 --> 00:18:32.445
Now just like billing retry,

00:18:32.445 --> 00:18:35.214
you also want to provide
that same in-app messaging

00:18:35.214 --> 00:18:37.883
to alert them
to their billing issue.

00:18:37.883 --> 00:18:39.619
Lastly, when you see
the Revoked state,

00:18:39.619 --> 00:18:42.355
this applies to a subscription
that is family shareable.

00:18:42.355 --> 00:18:44.523
These family members
are no longer entitled

00:18:44.523 --> 00:18:47.293
to that service or content,
so access can be revoked

00:18:47.293 --> 00:18:51.530
and you can merchandise offers
to reacquire these customers.

00:18:51.530 --> 00:18:53.733
In my final portion,
I want to dive into

00:18:53.733 --> 00:18:55.901
some implementation approaches
for you to consider

00:18:55.901 --> 00:18:59.572
when using App Store
Server Notifications.

00:18:59.572 --> 00:19:01.273
When you look at
all these events supported,

00:19:01.273 --> 00:19:02.708
you can see
there are quite a few,

00:19:02.708 --> 00:19:05.011
and some may or not apply
to your business.

00:19:05.011 --> 00:19:07.079
Many are part of
the subscription lifecycle,

00:19:07.079 --> 00:19:09.649
while others apply to all
in-app purchase types.

00:19:09.649 --> 00:19:11.217
If you are not offering
a subscription,

00:19:11.217 --> 00:19:12.685
then your implementation
approach

00:19:12.685 --> 00:19:15.121
is more straightforward, as
subscriptions are more complex

00:19:15.121 --> 00:19:18.624
and you can avoid many of those
events that simply don't apply.

00:19:18.624 --> 00:19:20.092
But let's review
these different phases

00:19:20.092 --> 00:19:22.695
of implementation
for you to consider.

00:19:22.695 --> 00:19:24.964
We broke it into three:
getting started,

00:19:24.964 --> 00:19:28.768
supporting the lifecycle,
and taking action on insights.

00:19:28.768 --> 00:19:30.136
When adopting Version 2,

00:19:30.136 --> 00:19:32.271
this getting started phase
applies to everyone,

00:19:32.271 --> 00:19:34.807
no matter your business model
or if you have or have not

00:19:34.807 --> 00:19:37.910
already adopted Version 1
notifications.

00:19:37.910 --> 00:19:39.745
The first step will be
getting Version 2

00:19:39.745 --> 00:19:41.647
enabled in App Store Connect.

00:19:41.647 --> 00:19:43.849
You'll find this feature
under App Information,

00:19:43.849 --> 00:19:45.851
titled "App Store
Server Notifications."

00:19:45.851 --> 00:19:48.320
And with the Fall updates,
now you can choose the URLs

00:19:48.320 --> 00:19:50.990
specifically for Sandbox
and production.

00:19:50.990 --> 00:19:54.193
You can add that URL and choose
which version to receive.

00:19:54.193 --> 00:19:56.095
And if you are receiving
Version 1 already,

00:19:56.095 --> 00:19:59.331
we suggest to only enable
Version 2 in Sandbox

00:19:59.331 --> 00:20:03.169
to allow for development
before enabling in production.

00:20:03.169 --> 00:20:04.837
Now that we've enabled
Version 2,

00:20:04.837 --> 00:20:06.338
we want to look
at the prioritization,

00:20:06.338 --> 00:20:09.475
so evaluate which notifications
to support first

00:20:09.475 --> 00:20:11.610
based on your business model
and usage.

00:20:11.610 --> 00:20:14.547
To help, you should focus
on key, high-volume events

00:20:14.547 --> 00:20:18.084
that apply the most to your
business and roadmap.

00:20:18.084 --> 00:20:20.653
One event that applies
to all in-app purchase types

00:20:20.653 --> 00:20:21.754
are refunds.

00:20:21.754 --> 00:20:23.789
You receive a single
REFUND notification

00:20:23.789 --> 00:20:27.026
for each transaction that is
refunded to the customer.

00:20:27.026 --> 00:20:29.528
How you process those events
will be up to your policies

00:20:29.528 --> 00:20:31.063
and business model.

00:20:31.063 --> 00:20:32.898
Now, for subscription-based
businesses,

00:20:32.898 --> 00:20:36.001
these four notifications
apply to the primary events

00:20:36.001 --> 00:20:37.136
in a subscription journey,

00:20:37.136 --> 00:20:39.205
from initial purchase
or resubscribe

00:20:39.205 --> 00:20:43.309
to a successful renewal,
or failure, into expiration.

00:20:43.309 --> 00:20:44.677
By prioritizing to take action

00:20:44.677 --> 00:20:46.712
on these five notification
types,

00:20:46.712 --> 00:20:49.115
means you will have support
for the majority of the events

00:20:49.115 --> 00:20:51.117
that you could receive.

00:20:51.117 --> 00:20:54.053
That first phase provides
a solid foundation

00:20:54.053 --> 00:20:56.122
and allowed you
to maximize your return.

00:20:56.122 --> 00:20:57.890
Now you can look to complete
your support

00:20:57.890 --> 00:21:01.093
of all notification types
in this next phase.

00:21:01.093 --> 00:21:02.661
There are just a few remaining

00:21:02.661 --> 00:21:04.363
subscription-based
notifications,

00:21:04.363 --> 00:21:07.399
while the others are dependent
upon feature adoption.

00:21:07.399 --> 00:21:08.334
Let's review.

00:21:08.334 --> 00:21:10.803
These two types apply
to all subscription-based apps,

00:21:10.803 --> 00:21:13.105
DID_CHANGE_RENEWAL_STATUS
and preference.

00:21:13.105 --> 00:21:15.074
These are critical
for identifying a customer

00:21:15.074 --> 00:21:17.743
cancelling or changing
their level of service.

00:21:17.743 --> 00:21:20.012
When considering
these remaining types,

00:21:20.012 --> 00:21:21.881
these are dependent
upon your usage.

00:21:21.881 --> 00:21:24.216
So GRACE_PERIOD_EXPIRED
applied if you have enabled

00:21:24.216 --> 00:21:26.886
Billing Grace Period
in App Store Connect.

00:21:26.886 --> 00:21:29.188
RENEWAL_EXTENDED
is sent if you have extended

00:21:29.188 --> 00:21:32.992
a subscriber's renewal
with the App Store Server API.

00:21:32.992 --> 00:21:35.427
And REVOKE applies
if products have been enabled

00:21:35.427 --> 00:21:38.831
for Family Sharing
for in-app purchases.

00:21:38.831 --> 00:21:40.299
OFFER REDEEMED applies
when using

00:21:40.299 --> 00:21:44.270
subscription offer codes
or promotional offers.

00:21:44.270 --> 00:21:45.604
And PRICE_INCREASE is sent

00:21:45.604 --> 00:21:49.675
if the price of an autorenewable
subscription has been raised.

00:21:49.675 --> 00:21:51.243
And then we have
REFUND_DECLINED

00:21:51.243 --> 00:21:52.845
and CONSUMPTION_REQUEST.

00:21:52.845 --> 00:21:54.313
Joe will be covering these
in-depth

00:21:54.313 --> 00:21:57.483
in his part on handling refunds.

00:21:57.483 --> 00:22:01.554
Lastly, we can move on
to the action on insights phase.

00:22:01.554 --> 00:22:04.523
By this point, you are now
receiving and taking action

00:22:04.523 --> 00:22:06.892
on all relevant events
for your business.

00:22:06.892 --> 00:22:09.428
This ensures your service
knows the current status

00:22:09.428 --> 00:22:10.996
of all customer subscriptions,

00:22:10.996 --> 00:22:13.866
or any access changes
to purchased consumables,

00:22:13.866 --> 00:22:17.269
nonconsumables,
or nonrenewing subscriptions.

00:22:17.269 --> 00:22:19.338
With subscriptions,
the following notifications

00:22:19.338 --> 00:22:22.174
identify customers
in a very specific state,

00:22:22.174 --> 00:22:25.578
thus enabling your business to
take specific proactive actions

00:22:25.578 --> 00:22:28.681
where you can identify
and intelligently engage,

00:22:28.681 --> 00:22:32.117
retain, and win back
subscribers.

00:22:32.117 --> 00:22:33.786
Here are some example
notification types

00:22:33.786 --> 00:22:35.688
where you can identify
key events

00:22:35.688 --> 00:22:38.991
in a window of opportunity
to engage with your customers,

00:22:38.991 --> 00:22:41.060
provide proactive
in-app messaging,

00:22:41.060 --> 00:22:44.263
or present tailored
subscription offers.

00:22:44.263 --> 00:22:45.631
Let's look at one example:

00:22:45.631 --> 00:22:48.667
a customer cancelling
their subscription.

00:22:48.667 --> 00:22:51.303
In this scenario, let's say
the subscriber purchased

00:22:51.303 --> 00:22:54.206
a monthly subscription
on November 25.

00:22:54.206 --> 00:22:55.407
Then on December 5,

00:22:55.407 --> 00:22:57.042
the subscriber
has chosen to cancel

00:22:57.042 --> 00:22:59.445
with 20 days remaining
in their current period.

00:22:59.445 --> 00:23:00.512
This is our save period,

00:23:00.512 --> 00:23:02.181
from the time
the subscriber cancelled

00:23:02.181 --> 00:23:04.250
to the time the subscription
will expire

00:23:04.250 --> 00:23:06.819
and voluntarily churn.

00:23:06.819 --> 00:23:08.687
Now when that cancel
action occurs,

00:23:08.687 --> 00:23:10.689
the autorenew state
is set to false,

00:23:10.689 --> 00:23:12.758
immediately triggering
the App Store to send

00:23:12.758 --> 00:23:15.361
a DID_CHANGE_RENEWAL_STATUS
notification

00:23:15.361 --> 00:23:17.596
with a subtype of
AUTO_RENEW_DISABLED,

00:23:17.596 --> 00:23:21.033
alerting you in real-time to
the beginning of a save period.

00:23:21.033 --> 00:23:23.302
This window of opportunity
allows your service

00:23:23.302 --> 00:23:25.204
to present tailored
in-app messaging

00:23:25.204 --> 00:23:28.741
or merchandise save offers
before their expiration.

00:23:28.741 --> 00:23:30.542
It's important such offers
are tailored

00:23:30.542 --> 00:23:34.580
and have eligibility criteria
for each customer cohort.

00:23:34.580 --> 00:23:36.248
This concludes my portion.

00:23:36.248 --> 00:23:39.885
Now I'd like to introduce
my colleague, Manjeet.

00:23:39.885 --> 00:23:42.254
Manjeet: Thanks, Dave!
My name is Manjeet Chawla,

00:23:42.254 --> 00:23:45.791
and I am a technical program
manager at the App Store.

00:23:45.791 --> 00:23:49.228
Now, Dave talked about
how you can use StoreKit 2

00:23:49.228 --> 00:23:53.499
and App Store Server API
to improve in-app purchases.

00:23:53.499 --> 00:23:55.567
Now, let's review
those exact same APIs

00:23:55.567 --> 00:23:58.203
from a customer
support perspective.

00:23:58.203 --> 00:24:00.706
I will talk about some
common support scenarios

00:24:00.706 --> 00:24:03.375
that customers face today
with in-app purchases

00:24:03.375 --> 00:24:08.180
and best practices to leverage
these APIs for those scenarios.

00:24:08.180 --> 00:24:10.582
But before I talk about
customer support,

00:24:10.582 --> 00:24:12.818
let's understand
how providing support

00:24:12.818 --> 00:24:16.255
impacts your overall
customer management.

00:24:16.255 --> 00:24:18.757
You may be relying
on various CRM tools

00:24:18.757 --> 00:24:22.961
and systems like acquisition,
analysis, customer support,

00:24:22.961 --> 00:24:25.864
and various marketing
communication channels.

00:24:25.864 --> 00:24:28.634
And providing support
keeps your customers happy

00:24:28.634 --> 00:24:30.035
and engaged with the product

00:24:30.035 --> 00:24:32.705
and improving your overall
customer relationships

00:24:32.705 --> 00:24:34.540
and satisfaction.

00:24:34.540 --> 00:24:36.975
Now we know customers
reach out to you for help

00:24:36.975 --> 00:24:40.245
and the App Store has created
tools for you to provide support

00:24:40.245 --> 00:24:43.248
and resolve issues efficiently.

00:24:43.248 --> 00:24:46.618
And today, I will talk about
five new customer support tools

00:24:46.618 --> 00:24:50.389
to assist you with inquiries
across all your support channels

00:24:50.389 --> 00:24:53.258
starting with
the Look up Order ID.

00:24:53.258 --> 00:24:55.861
Today, when customers make
an in-app purchase,

00:24:55.861 --> 00:24:58.297
they get a receipt sent
to their Apple ID

00:24:58.297 --> 00:25:01.467
and they also can also
access this receipt at any time

00:25:01.467 --> 00:25:04.503
by looking at the purchase
history under Account Settings.

00:25:04.503 --> 00:25:06.505
And now,
when a customer contacts you,

00:25:06.505 --> 00:25:08.807
your support team
can ask the customer

00:25:08.807 --> 00:25:11.043
for the Order ID on this receipt

00:25:11.043 --> 00:25:13.612
and call a new
App Store Server API

00:25:13.612 --> 00:25:16.582
to lookup customer's in-app
purchases for that receipt

00:25:16.582 --> 00:25:18.684
by using the order ID.

00:25:18.684 --> 00:25:20.586
You can also use this API

00:25:20.586 --> 00:25:23.122
to validate the authenticity
of the receipt

00:25:23.122 --> 00:25:25.657
and to associate transactions
within that receipt

00:25:25.657 --> 00:25:27.593
to a customer.

00:25:27.593 --> 00:25:29.595
Additionally,
you can use this API

00:25:29.595 --> 00:25:32.831
to identify any issues
within the purchase.

00:25:32.831 --> 00:25:35.934
For example, if the transaction
contains any purchases

00:25:35.934 --> 00:25:39.238
that have already been refunded
or revoked by the App Store,

00:25:39.238 --> 00:25:41.173
you can look at
the revocationDate

00:25:41.173 --> 00:25:43.509
and revocationReason
in the response

00:25:43.509 --> 00:25:46.211
to get more details
about the refund.

00:25:46.211 --> 00:25:48.080
And once you implement
this API,

00:25:48.080 --> 00:25:50.949
you will be able to look up
historical purchases

00:25:50.949 --> 00:25:54.987
for an order ID when a customer
contacts you for support.

00:25:54.987 --> 00:25:58.290
For best practices, store
the original_transaction_id

00:25:58.290 --> 00:26:01.460
for all in-app purchases
in a customer account database.

00:26:01.460 --> 00:26:03.729
And when a customer contacts you
for support,

00:26:03.729 --> 00:26:07.166
you can easily use this API
to look up and associate

00:26:07.166 --> 00:26:10.769
a customer's purchases
within your account database.

00:26:10.769 --> 00:26:12.571
You can even integrate this API

00:26:12.571 --> 00:26:14.807
with your existing
customer support channels

00:26:14.807 --> 00:26:17.109
like phone, email, or web

00:26:17.109 --> 00:26:21.747
to provide a consistent support
experience for your customers.

00:26:21.747 --> 00:26:25.117
Next, let's talk about
Refund Lookup.

00:26:25.117 --> 00:26:29.488
In WWDC20, the App Store
introduced refund notifications

00:26:29.488 --> 00:26:31.590
to notify your server each time

00:26:31.590 --> 00:26:35.828
a customer has been successfully
refunded for an in-app purchase.

00:26:35.828 --> 00:26:39.264
The Refund Lookup is
a brand-new App Store Server API

00:26:39.264 --> 00:26:41.733
that lets you lookup
all the refunded transactions

00:26:41.733 --> 00:26:43.602
for a customer.

00:26:43.602 --> 00:26:46.605
This API enables you
to handle server outages

00:26:46.605 --> 00:26:50.275
or schedule maintenance by
looking up refunds at any time

00:26:50.275 --> 00:26:52.711
in a quick and easy manner.

00:26:52.711 --> 00:26:56.415
Additionally, you can identify a
customer's entire refund history

00:26:56.415 --> 00:26:59.284
across all their in-app
purchase types.

00:26:59.284 --> 00:27:01.854
You can also use
this API to monitor

00:27:01.854 --> 00:27:05.524
any spikes in the refund
or suspicious activity,

00:27:05.524 --> 00:27:08.193
and it can respond
to content delivery issues

00:27:08.193 --> 00:27:11.230
that might be leading
to refunds.

00:27:11.230 --> 00:27:12.764
For best practices,

00:27:12.764 --> 00:27:14.800
if you are storing
the original_transaction_id

00:27:14.800 --> 00:27:17.903
for each in-app purchase in
a customer account database,

00:27:17.903 --> 00:27:20.572
you can use any of their
original_transaction_ids

00:27:20.572 --> 00:27:23.041
to look up their past refunds.

00:27:23.041 --> 00:27:25.878
And you can troubleshoot
any content delivery issues

00:27:25.878 --> 00:27:28.447
for a customer that might be
leading to refunds

00:27:28.447 --> 00:27:31.550
by using the Refund Lookup API.

00:27:31.550 --> 00:27:34.386
Now let's shift gears
to talk specifically about

00:27:34.386 --> 00:27:36.388
autorenewable subscriptions.

00:27:36.388 --> 00:27:39.157
For example, a scenario
where there was an outage

00:27:39.157 --> 00:27:40.659
or an event was canceled

00:27:40.659 --> 00:27:43.362
which might be more common
for streaming-based apps

00:27:43.362 --> 00:27:46.431
such as sports, live TV,
or video.

00:27:46.431 --> 00:27:48.967
For these outages
or canceled events,

00:27:48.967 --> 00:27:51.637
how can you appease customers?

00:27:51.637 --> 00:27:55.274
You can now use a new
Renewal Extension Server API

00:27:55.274 --> 00:27:58.343
to extend the renewal date
for a paid active subscription

00:27:58.343 --> 00:28:02.147
and give customers free service
for an additional time.

00:28:02.147 --> 00:28:05.884
You can use this API
to handle temporary outages

00:28:05.884 --> 00:28:08.387
and also to provide appeasement;
for example,

00:28:08.387 --> 00:28:11.790
when the customer had a bad
experience with the service.

00:28:11.790 --> 00:28:13.592
Note that you can
extend the renewal date

00:28:13.592 --> 00:28:17.162
for a customer's subscription
twice within a year --

00:28:17.162 --> 00:28:19.097
each time, up to 90 days --

00:28:19.097 --> 00:28:22.167
regardless of the actual
subscription duration.

00:28:22.167 --> 00:28:25.370
Also note, this extension period
does not count towards

00:28:25.370 --> 00:28:27.940
the one year of paid service
needed to receive

00:28:27.940 --> 00:28:31.143
an 85 percent proceeds rate.

00:28:31.143 --> 00:28:34.313
For best practices, store
the original_transaction_id

00:28:34.313 --> 00:28:36.848
to identify the subscriptions
you wish to extend

00:28:36.848 --> 00:28:38.750
the renewal date for.

00:28:38.750 --> 00:28:40.085
Identify the extension period

00:28:40.085 --> 00:28:42.487
that works best for
your business model

00:28:42.487 --> 00:28:44.056
and show in-app messaging

00:28:44.056 --> 00:28:46.892
when you extend
a customer's subscription.

00:28:46.892 --> 00:28:49.061
And because there can only be
two extensions

00:28:49.061 --> 00:28:50.762
per customer in a year,

00:28:50.762 --> 00:28:53.665
you may want to maintain
an eligibility criteria

00:28:53.665 --> 00:28:57.436
for your customers who are
eligible for an extension.

00:28:57.436 --> 00:29:00.238
And always align with your
business and marketing teams

00:29:00.238 --> 00:29:02.240
to provide a consistent
messaging

00:29:02.240 --> 00:29:05.444
across all your communication
channels.

00:29:05.444 --> 00:29:07.679
Now let's discuss
a different scenario

00:29:07.679 --> 00:29:09.948
where you may want
to compensate a customer

00:29:09.948 --> 00:29:14.052
by providing a one-time discount
for their subscription.

00:29:14.052 --> 00:29:16.722
In iOS 14,
the App Store introduced

00:29:16.722 --> 00:29:20.158
subscription offer codes
to help you acquire, retain,

00:29:20.158 --> 00:29:22.995
and win back subscribers
by providing a subscription

00:29:22.995 --> 00:29:26.264
at a discount or free
for a limited time.

00:29:26.264 --> 00:29:29.034
You can distribute these
one-time, unique codes

00:29:29.034 --> 00:29:32.204
either using online
or offline channels.

00:29:32.204 --> 00:29:34.006
And for customer service issues,

00:29:34.006 --> 00:29:36.975
you can provide these
one-time codes as compensation

00:29:36.975 --> 00:29:38.744
for the service issue.

00:29:38.744 --> 00:29:41.179
You might also use this
as an opportunity

00:29:41.179 --> 00:29:43.782
to suggest an alternative
subscription option;

00:29:43.782 --> 00:29:45.984
for example,
a longer duration plan

00:29:45.984 --> 00:29:49.321
that provides more value
at a lower price.

00:29:49.321 --> 00:29:53.058
Customers on iOS 14
and iPadOS 14 and later

00:29:53.058 --> 00:29:55.160
can redeem offer codes
on the App Store

00:29:55.160 --> 00:29:57.295
through a one-time code
redemption URL,

00:29:57.295 --> 00:29:59.364
or within the app
if you've implemented

00:29:59.364 --> 00:30:03.568
the presentCodeRedemptionSheet
API in StoreKit.

00:30:03.568 --> 00:30:07.272
Now, for best practices, provide
a redemption flow inside the app

00:30:07.272 --> 00:30:09.174
for customers to redeem the code

00:30:09.174 --> 00:30:11.376
along with customized
in-app messaging

00:30:11.376 --> 00:30:13.245
and description
for the offer code

00:30:13.245 --> 00:30:16.381
to help customers
make an informed decision.

00:30:16.381 --> 00:30:18.250
And use this
within your existing

00:30:18.250 --> 00:30:22.254
customer support channels
such as phone, email, web,

00:30:22.254 --> 00:30:24.556
or even within your app,
for example,

00:30:24.556 --> 00:30:26.992
when the customer is chatting
with your support team

00:30:26.992 --> 00:30:29.327
in a live chat session.

00:30:29.327 --> 00:30:31.163
Now, if you're distributing
these codes

00:30:31.163 --> 00:30:33.632
on digital marketing channels
such as email,

00:30:33.632 --> 00:30:36.601
each code will have
an associated redemption URL

00:30:36.601 --> 00:30:38.837
with the code prepopulated.

00:30:38.837 --> 00:30:41.173
You will be able to use
a unique URL

00:30:41.173 --> 00:30:44.376
to seamlessly deep link
the customer from your email

00:30:44.376 --> 00:30:47.913
into the redemption flow
which occurs on the App Store.

00:30:47.913 --> 00:30:51.049
This URL is comprised
of two values:

00:30:51.049 --> 00:30:53.752
the ID, which represents
your application's ID,

00:30:53.752 --> 00:30:57.155
so it will be static
for each of your applications;

00:30:57.155 --> 00:30:58.890
and the second value
is the code,

00:30:58.890 --> 00:31:01.259
where you will dynamically
populate the URL

00:31:01.259 --> 00:31:05.230
with the subscribers unique
alphanumeric value.

00:31:05.230 --> 00:31:07.899
Now, if that URL were
embedded in an email,

00:31:07.899 --> 00:31:10.802
then tapping it would take
the user into the App Store

00:31:10.802 --> 00:31:12.771
to complete the transaction.

00:31:12.771 --> 00:31:14.072
Some things to note:

00:31:14.072 --> 00:31:17.409
the subscriber here never sees
the code during this flow,

00:31:17.409 --> 00:31:18.543
and when completed,

00:31:18.543 --> 00:31:20.746
it would be another
external transaction

00:31:20.746 --> 00:31:22.514
that your app
will need to fulfill

00:31:22.514 --> 00:31:25.784
when the customer launches
the application again.

00:31:25.784 --> 00:31:27.352
Next, let's cover a scenario

00:31:27.352 --> 00:31:31.022
where the customer wants
to manage their subscription.

00:31:31.022 --> 00:31:34.760
In StoreKit 2, we launched
a new manage subscriptions API

00:31:34.760 --> 00:31:38.230
that enables you to display the
existing manage subscriptions

00:31:38.230 --> 00:31:40.132
right within the app.

00:31:40.132 --> 00:31:42.267
Supporting subscription
management in-app

00:31:42.267 --> 00:31:44.803
means customers
can upgrade, downgrade,

00:31:44.803 --> 00:31:48.774
or cancel a subscription
without ever leaving your app.

00:31:48.774 --> 00:31:51.810
This also gives you
a natural place to provide help

00:31:51.810 --> 00:31:55.514
for common subscriber issues
and present alternative offers

00:31:55.514 --> 00:31:57.682
for customers to consider.

00:31:57.682 --> 00:31:59.251
And you can use this opportunity

00:31:59.251 --> 00:32:01.753
to present a personalized
save offer

00:32:01.753 --> 00:32:04.222
before they see
the manage subscriptions page;

00:32:04.222 --> 00:32:07.692
for example, if their engagement
has been low.

00:32:07.692 --> 00:32:11.062
Or you can even present
an exit survey if they cancel

00:32:11.062 --> 00:32:14.166
to get more details
about the cancellation.

00:32:14.166 --> 00:32:15.734
Now for best practices.

00:32:15.734 --> 00:32:18.069
Using StoreKit APIs enables you

00:32:18.069 --> 00:32:20.172
to present
a consistent experience

00:32:20.172 --> 00:32:22.941
that helps people manage
or cancel their subscription

00:32:22.941 --> 00:32:24.976
without ever leaving your app.

00:32:24.976 --> 00:32:27.679
Consider creating a branded
contextual experience

00:32:27.679 --> 00:32:30.715
to complement the
system-provided management UI.

00:32:30.715 --> 00:32:34.219
For example, you might offer
a popular premium tier

00:32:34.219 --> 00:32:36.254
to provide personalized
suggestions

00:32:36.254 --> 00:32:37.823
or alternative plans

00:32:37.823 --> 00:32:41.259
based on customer's
preferences or usage.

00:32:41.259 --> 00:32:42.627
And review your overall

00:32:42.627 --> 00:32:44.429
subscription management
experience

00:32:44.429 --> 00:32:46.898
as it relates to the customer
support journey

00:32:46.898 --> 00:32:49.901
across all your different
channels.

00:32:49.901 --> 00:32:53.071
Now, let's take a look at
a sample Manage Subscriptions UI

00:32:53.071 --> 00:32:53.939
in your app.

00:32:53.939 --> 00:32:56.341
Under Account Settings,
we can add an option

00:32:56.341 --> 00:32:59.244
for the user to manage
their subscription.

00:32:59.244 --> 00:33:01.513
And once the customer
taps this button,

00:33:01.513 --> 00:33:02.681
the App Store will display

00:33:02.681 --> 00:33:04.549
the existing
Manage Subscriptions page

00:33:04.549 --> 00:33:06.218
with the currently active
subscription

00:33:06.218 --> 00:33:08.053
and the renewal options.

00:33:08.053 --> 00:33:10.722
This is the same view
customers are familiar with

00:33:10.722 --> 00:33:12.424
when they visit
Manage Subscriptions

00:33:12.424 --> 00:33:14.292
under Account Settings
in the App Store

00:33:14.292 --> 00:33:16.728
where they can view,
upgrade, downgrade

00:33:16.728 --> 00:33:19.130
or cancel their subscription.

00:33:19.130 --> 00:33:21.999
Now, if the customer selects
to cancel their subscription,

00:33:21.999 --> 00:33:23.802
they will see
a confirmation screen

00:33:23.802 --> 00:33:27.439
with the cancellation details
and the service expiration date.

00:33:27.439 --> 00:33:30.408
And for any action
the user may take on this page,

00:33:30.408 --> 00:33:33.178
you will receive
an App Store Server Notification

00:33:33.178 --> 00:33:34.746
and your app will be notified

00:33:34.746 --> 00:33:38.183
if you've implemented
the StoreKit 2 framework.

00:33:38.183 --> 00:33:41.019
So with the new customer support
tools I covered today,

00:33:41.019 --> 00:33:43.955
let's talk about the benefits
of providing support

00:33:43.955 --> 00:33:46.091
by using these APIs.

00:33:46.091 --> 00:33:49.127
You can now improve
your overall customer experience

00:33:49.127 --> 00:33:51.830
by providing contextual
and seamless support

00:33:51.830 --> 00:33:54.799
for in-app purchases
right within the app.

00:33:54.799 --> 00:33:56.668
This increases overall retention

00:33:56.668 --> 00:33:58.803
and improves
customer satisfaction

00:33:58.803 --> 00:34:01.606
which leads to higher
engagement, and ultimately,

00:34:01.606 --> 00:34:05.610
more positive ratings
and reviews for your app.

00:34:05.610 --> 00:34:07.812
Now, I would like
to invite my colleague Joe

00:34:07.812 --> 00:34:11.616
to talk about handling refunds.

00:34:11.616 --> 00:34:12.484
Joe: Thanks, Manjeet,

00:34:12.484 --> 00:34:15.053
for providing best practices
and use cases

00:34:15.053 --> 00:34:18.657
for the new customer support
tools that have been launched.

00:34:18.657 --> 00:34:20.659
Hi, everyone,
my name is Joe Mani,

00:34:20.659 --> 00:34:23.595
and I'm a program manager
at the App Store.

00:34:23.595 --> 00:34:25.430
Refunds are a sensitive topic,

00:34:25.430 --> 00:34:27.332
and the App Store
has created tools for you

00:34:27.332 --> 00:34:30.368
to understand the impact
of refunds on your apps

00:34:30.368 --> 00:34:32.237
and how you can
leverage these tools

00:34:32.237 --> 00:34:34.940
to improve
your customer experience.

00:34:34.940 --> 00:34:37.609
I would like to highlight the
benefits of using these tools

00:34:37.609 --> 00:34:41.980
and provide a comprehensive
message around handling refunds.

00:34:41.980 --> 00:34:44.649
This past year,
we have launched two new tools

00:34:44.649 --> 00:34:46.885
that have an impact to refunds.

00:34:46.885 --> 00:34:51.690
First, let us discuss
the beginRefundRequest API.

00:34:51.690 --> 00:34:53.558
The App Store has
Report a Problem

00:34:53.558 --> 00:34:56.161
and Apple Support
has established paths

00:34:56.161 --> 00:34:58.463
for customers
to request a refund.

00:34:58.463 --> 00:35:01.199
Now in iOS 15,
the App Store introduced

00:35:01.199 --> 00:35:05.470
a new beginRefundRequest API
in the StoreKit 2 framework

00:35:05.470 --> 00:35:09.040
for customers to request
a refund for in-app purchases.

00:35:09.040 --> 00:35:11.242
There are multiple benefits
for you to implement

00:35:11.242 --> 00:35:13.812
the beginRefundRequest API.

00:35:13.812 --> 00:35:15.880
Most of you listening
have had a customer

00:35:15.880 --> 00:35:19.250
who has requested a refund
for your in-app purchase.

00:35:19.250 --> 00:35:21.653
The new beginRefundRequest API

00:35:21.653 --> 00:35:24.189
allows you to provide
the same functionality

00:35:24.189 --> 00:35:26.257
without having
to redirect customers

00:35:26.257 --> 00:35:28.960
and provide assistance
within the app.

00:35:28.960 --> 00:35:32.664
If you are aware of a potential
issue with your in-app purchase,

00:35:32.664 --> 00:35:36.401
you can use this API to help
customers troubleshoot the issue

00:35:36.401 --> 00:35:38.870
and get a faster resolution.

00:35:38.870 --> 00:35:42.907
In iOS 15, App Store has created
two additional notifications

00:35:42.907 --> 00:35:44.776
specifically so you can be aware

00:35:44.776 --> 00:35:47.679
if the refund has been
approved or denied.

00:35:47.679 --> 00:35:50.415
If the refund is approved,
your app will be notified

00:35:50.415 --> 00:35:52.884
and your server receives
a REFUND notification

00:35:52.884 --> 00:35:54.252
from the App Store.

00:35:54.252 --> 00:35:56.054
If the refund is denied,

00:35:56.054 --> 00:35:59.891
your server receives a new
REFUND_DECLINED notification.

00:35:59.891 --> 00:36:03.728
Note that customers will have
to be on iOS 15 or above

00:36:03.728 --> 00:36:06.331
to use this functionality.

00:36:06.331 --> 00:36:08.900
Let's discuss best practices.

00:36:08.900 --> 00:36:10.735
Store the original
transaction ID

00:36:10.735 --> 00:36:12.837
and note that most
refund requests

00:36:12.837 --> 00:36:16.007
occur within 30 days
of the purchase.

00:36:16.007 --> 00:36:18.943
You can provide custom-built
in-app messaging

00:36:18.943 --> 00:36:21.346
which creates a tailored
customer experience

00:36:21.346 --> 00:36:23.648
even when you may have
situations

00:36:23.648 --> 00:36:27.485
where a customer is frustrated
and requesting a refund.

00:36:27.485 --> 00:36:30.688
You have flexibility to display
contextual information

00:36:30.688 --> 00:36:33.058
about past purchases
to the customer.

00:36:33.058 --> 00:36:36.227
Once the customer selects
a transaction to be refunded,

00:36:36.227 --> 00:36:40.098
you can call the API which
displays a refund request sheet

00:36:40.098 --> 00:36:43.034
where a customer can select
from a list of reason codes,

00:36:43.034 --> 00:36:44.869
which is consistent
with what they would see

00:36:44.869 --> 00:36:47.272
in Apple's Report a Problem.

00:36:47.272 --> 00:36:48.973
For autorenewable
subscriptions,

00:36:48.973 --> 00:36:50.975
you can identify
retention strategies

00:36:50.975 --> 00:36:53.411
to keep your customer
engaged within your app

00:36:53.411 --> 00:36:57.782
as a successful refund
will cancel the subscription.

00:36:57.782 --> 00:37:00.552
Now that we looked at
the beginRefundRequest,

00:37:00.552 --> 00:37:03.021
let's talk about
what occurs after

00:37:03.021 --> 00:37:05.590
and how you can be
more involved.

00:37:05.590 --> 00:37:08.293
The App Store introduced
a new server API

00:37:08.293 --> 00:37:11.563
which gives you the opportunity
to help inform and improve

00:37:11.563 --> 00:37:15.333
the refund process by sending
consumption information to Apple

00:37:15.333 --> 00:37:18.470
about a customer's consumable
in-app purchase,

00:37:18.470 --> 00:37:20.672
such as whether
they consumed an item

00:37:20.672 --> 00:37:23.641
before requesting a refund.

00:37:23.641 --> 00:37:25.610
At a high level,
each refund request

00:37:25.610 --> 00:37:28.179
will go through our
refund decisioning system

00:37:28.179 --> 00:37:30.148
to render a decision.

00:37:30.148 --> 00:37:32.884
The refund decisioning system
includes information

00:37:32.884 --> 00:37:35.887
about the transaction at issue
and other factors

00:37:35.887 --> 00:37:39.324
such as the customer's
purchase and refund history.

00:37:39.324 --> 00:37:41.526
Prior to Apple
rendering a decision,

00:37:41.526 --> 00:37:43.294
the App Store
will send your server

00:37:43.294 --> 00:37:45.630
a CONSUMPTION_REQUEST
notification.

00:37:45.630 --> 00:37:47.465
Your server sends
the consumption data

00:37:47.465 --> 00:37:50.635
back to the App Store in
response to this notification,

00:37:50.635 --> 00:37:53.771
which can influence
the refund decision.

00:37:53.771 --> 00:37:57.008
The consumption payload
consists of a handful of fields

00:37:57.008 --> 00:38:01.012
and I would like to discuss
three of the key fields today.

00:38:01.012 --> 00:38:04.516
With Consumption, you can easily
tell us if an in-app purchase

00:38:04.516 --> 00:38:07.986
has been fully, partially,
or not at all consumed.

00:38:07.986 --> 00:38:09.287
For example, if your app

00:38:09.287 --> 00:38:11.823
has an exchange platform
that has bartering

00:38:11.823 --> 00:38:13.925
or if an in-app
that has been transferred

00:38:13.925 --> 00:38:16.094
from one account
to another's account,

00:38:16.094 --> 00:38:18.263
it is considered consumed.

00:38:18.263 --> 00:38:21.699
With delivering content,
you may have experienced outages

00:38:21.699 --> 00:38:24.202
or unable to deliver
in-app purchases

00:38:24.202 --> 00:38:26.571
and you may want
to refund the customer.

00:38:26.571 --> 00:38:29.841
Now you can simply provide
item not delivered.

00:38:29.841 --> 00:38:32.443
With appAccountToken,
launched in StoreKit 2,

00:38:32.443 --> 00:38:35.513
we are using
a standard UUID format

00:38:35.513 --> 00:38:38.950
associated with your app's
user account that you create

00:38:38.950 --> 00:38:42.287
that is initiating the purchase
and consuming the content

00:38:42.287 --> 00:38:43.488
for the purchase,

00:38:43.488 --> 00:38:46.291
which can help
identify resellers.

00:38:46.291 --> 00:38:50.528
For best practices, most refund
requests occur within 30 days

00:38:50.528 --> 00:38:54.966
so store consumption data for
your transactions accordingly.

00:38:54.966 --> 00:38:56.901
Store the
original_transaction_ID

00:38:56.901 --> 00:38:59.137
for each consumable
in-app purchase

00:38:59.137 --> 00:39:00.872
so you can find the transaction

00:39:00.872 --> 00:39:03.808
for which Apple
is requesting the data for.

00:39:03.808 --> 00:39:07.045
To ensure Apple incorporates
your data for decisioning,

00:39:07.045 --> 00:39:08.713
respond within 12 hours

00:39:08.713 --> 00:39:12.317
of receiving the consumption
request notification.

00:39:12.317 --> 00:39:16.087
Feel free to send an updated
payload within those 12 hours

00:39:16.087 --> 00:39:19.524
if anything has changed
after the initial request.

00:39:19.524 --> 00:39:21.659
Ensure you have obtained
customer consent

00:39:21.659 --> 00:39:24.429
prior to sending the requested
consumption data

00:39:24.429 --> 00:39:26.164
to the App Store.

00:39:26.164 --> 00:39:28.600
And lastly, within the
consumption payload,

00:39:28.600 --> 00:39:30.401
all fields are not required,

00:39:30.401 --> 00:39:32.337
and please review
Apple documentation

00:39:32.337 --> 00:39:35.807
for which fields
can be marked as undeclared.

00:39:35.807 --> 00:39:37.375
To summarize today's session,

00:39:37.375 --> 00:39:40.245
I want to provide
a checklist of key actions.

00:39:40.245 --> 00:39:43.114
For next steps to adopt
and implement these features,

00:39:43.114 --> 00:39:45.617
you can start configuring
and enabling your servers

00:39:45.617 --> 00:39:47.919
to receive App Store
Server Notifications

00:39:47.919 --> 00:39:50.188
by entering the URL
in App Store Connect

00:39:50.188 --> 00:39:53.391
and enabling Version 2
in Sandbox.

00:39:53.391 --> 00:39:54.993
For your customer support tools,

00:39:54.993 --> 00:39:57.629
integrate within your existing
support channels,

00:39:57.629 --> 00:40:02.300
either it be phone, email,
web, or in-app support.

00:40:02.300 --> 00:40:04.302
For your app,
identify the client changes

00:40:04.302 --> 00:40:06.504
in iOS 15 with StoreKit 2

00:40:06.504 --> 00:40:09.440
needed to support the new
beginRefundRequest,

00:40:09.440 --> 00:40:14.112
isEligibleforIntroOffer,
and showManageSubcriptions API.

00:40:14.112 --> 00:40:16.247
Lastly, be sure
to take advantage

00:40:16.247 --> 00:40:18.082
of the Sandbox testing updates

00:40:18.082 --> 00:40:21.119
to make the most
of your Sandbox Apple IDs,

00:40:21.119 --> 00:40:24.155
like storefront change,
clearing purchase history,

00:40:24.155 --> 00:40:28.493
testing refunds, and adjusting
the subscription renewal rate.

00:40:28.493 --> 00:40:30.128
This concludes the presentation,

00:40:30.128 --> 00:40:32.063
and thank you so much
for joining us today

00:40:32.063 --> 00:40:34.265
and learning more about
supporting customers

00:40:34.265 --> 00:40:37.268
with StoreKit 2
and App Store Server API.
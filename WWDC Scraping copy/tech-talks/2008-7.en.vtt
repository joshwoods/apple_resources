WEBVTT

00:00:09.150 --> 00:00:16.240
Okay, so this is the session on using
advanced web technologies on iPhone,

00:00:16.290 --> 00:00:22.340
and my name is Vicki Murley.

00:00:22.340 --> 00:00:22.340
I'm the Safari Technologies Evangelist
at Apple.

00:00:23.000 --> 00:00:28.890
Okay, so when the SDK was released-- that
was obviously a big deal to a lot

00:00:28.890 --> 00:00:31.480
of native-application developers.

00:00:31.480 --> 00:00:35.180
But at the same time,
a lot of features specific to web

00:00:35.180 --> 00:00:37.840
applications were released as well.

00:00:37.900 --> 00:00:41.510
And that is great for you guys,
because you're able, now,

00:00:41.590 --> 00:00:47.230
to develop some really rich and
interesting iPhone web applications.

00:00:47.370 --> 00:00:50.500
At the same time, you get to leverage
your existing skillset,

00:00:50.540 --> 00:00:53.380
you don't have to go learn
Objective-C or anything like that to

00:00:53.500 --> 00:00:56.230
create a great experience on iPhone.

00:00:56.610 --> 00:00:59.810
Many of the features and technologies
that we're gonna talk about today

00:01:00.160 --> 00:01:02.240
are based on open web standards.

00:01:02.330 --> 00:01:08.800
So even if a feature is only implemented
in Safari on iPhone right now,

00:01:08.800 --> 00:01:11.630
it's very likely that it will
be implemented in other browsers

00:01:11.730 --> 00:01:14.920
in the future by virtue of
being part of a standard.

00:01:14.960 --> 00:01:19.890
And so you're going to be kind of
ahead of the curve by adopting early.

00:01:20.170 --> 00:01:27.540
And also with web technologies
and web applications,

00:01:27.540 --> 00:01:31.910
you have instant deployment.

00:01:31.910 --> 00:01:34.620
So if you need to make a change to your
app or want to put out a new version,

00:01:34.620 --> 00:01:34.620
that can happen instantly.

00:01:34.620 --> 00:01:34.620
No third party to go through.

00:01:35.650 --> 00:01:37.000
Okay.

00:01:37.200 --> 00:01:41.950
So let's do a quick comparison
of native applications versus web

00:01:41.950 --> 00:01:44.890
applications in four main categories.

00:01:45.060 --> 00:01:49.240
So the first one to think about
is kind of feeling built-in.

00:01:49.350 --> 00:01:52.760
And when I think about feeling
built-in for native applications,

00:01:52.830 --> 00:01:57.610
I think about things like launching
an app via a home screen icon.

00:01:57.790 --> 00:02:00.520
Of course,
native apps run in full-screen mode.

00:02:00.520 --> 00:02:02.820
They don't run within
another application.

00:02:02.820 --> 00:02:07.320
You don't have to type in a
URL to get to a native app.

00:02:07.320 --> 00:02:10.060
And native apps can detect
orientation changes as well,

00:02:10.060 --> 00:02:13.800
so you can do different things
in your UI based on that change.

00:02:13.920 --> 00:02:18.920
Well, all of those features are available
in web applications as well.

00:02:19.610 --> 00:02:24.030
If I wanted to implement
something to do with multi-touch

00:02:24.030 --> 00:02:28.200
in my native application,
like detect a rotation or

00:02:28.200 --> 00:02:32.150
implement a custom gesture,
I would use a class in

00:02:32.150 --> 00:02:34.510
iPhone SDK called UI touch.

00:02:34.510 --> 00:02:39.990
Well, for iPhone web applications,
you can do the same sort of thing

00:02:39.990 --> 00:02:42.280
through JavaScript using this
technology that we call DOM touch.

00:02:42.280 --> 00:02:42.280
So that's also possible
in web applications.

00:02:42.740 --> 00:02:43.850
Advanced graphics.

00:02:43.870 --> 00:02:47.620
If I were looking to integrate
some really cool graphics

00:02:47.620 --> 00:02:51.780
into my UI on iPhone,
I might use something like Core Graphics

00:02:51.780 --> 00:02:54.010
or Core Animation or OpenGL ES.

00:02:54.010 --> 00:02:58.450
Well, in web applications now,
we have a technology - we call this

00:02:58.530 --> 00:03:03.540
family of effects CSS visual effects,
and this includes CSS transforms,

00:03:03.540 --> 00:03:07.780
transitions, and animations,
and these are really hardware

00:03:07.780 --> 00:03:12.390
accelerated animations and graphics
that you design through CSS.

00:03:13.450 --> 00:03:16.690
And lastly, local storage.

00:03:16.760 --> 00:03:21.170
In native applications,
you can store data in an SQLite

00:03:21.270 --> 00:03:23.840
database or write files to disk.

00:03:23.860 --> 00:03:29.880
Well, in web applications,
you can't write files to disk on the fly.

00:03:29.880 --> 00:03:31.260
You can store files locally.

00:03:31.260 --> 00:03:33.510
We're gonna talk about that later on.

00:03:33.550 --> 00:03:37.950
But you can also store data on the
fly in an SQLite database locally for

00:03:37.950 --> 00:03:42.190
offline access or whatever you like.

00:03:42.880 --> 00:03:47.620
So we're gonna talk about those
four key areas that we just

00:03:48.080 --> 00:03:50.170
looked at on the graph there.

00:03:50.290 --> 00:03:53.180
Feeling built in,
making your web app feel integrated,

00:03:53.310 --> 00:03:55.970
feel like a built-in app on the system.

00:03:56.110 --> 00:04:00.250
Touch and gesture events,
multi-touch through JavaScript,

00:04:00.250 --> 00:04:01.120
basically.

00:04:01.190 --> 00:04:04.950
CSS visual effects,
which includes those hardware accelerated

00:04:05.160 --> 00:04:07.200
animations that I talked about.

00:04:07.200 --> 00:04:09.260
And also, storing data locally.

00:04:09.260 --> 00:04:13.620
We're gonna talk about storing data
on the fly in an SQLite database,

00:04:13.620 --> 00:04:17.800
and also how to create a locally
cached version of your application,

00:04:17.800 --> 00:04:22.180
where you can cache all the
resource files for your app.

00:04:22.760 --> 00:04:29.050
Okay,
so getting started with feeling built-in.

00:04:29.050 --> 00:04:34.960
There are three things
we're going to cover here:

00:04:34.960 --> 00:04:40.110
home screen icons,
running your web application

00:04:40.990 --> 00:04:41.190
in full-screen mode,
and how to detect orientation changes

00:04:41.190 --> 00:04:41.190
from within a web application.

00:04:44.390 --> 00:04:46.500
So here's a picture of an iPhone.

00:04:46.500 --> 00:04:50.740
I'm sure that you're all familiar
with what an iPhone looks like.

00:04:50.880 --> 00:04:55.180
And when I want to launch an application,
as I mentioned earlier,

00:04:55.230 --> 00:04:57.640
I just touch one of these
icons on the home screen.

00:04:57.640 --> 00:05:02.990
I don't have to launch another app and
then type in a URL or retrieve a URL from

00:05:02.990 --> 00:05:04.720
my bookmarks or something like that.

00:05:04.780 --> 00:05:06.820
I just touch an icon on the home screen.

00:05:06.920 --> 00:05:13.090
And we want you guys to have that same
functionality for web applications.

00:05:13.220 --> 00:05:17.300
So we've added a way-- or a way
has been-- existed for a while now,

00:05:17.430 --> 00:05:21.440
that you can have an application icon
for your site-- or for your web app.

00:05:21.440 --> 00:05:22.530
Excuse me.

00:05:22.700 --> 00:05:27.600
So the way to do this is to just
create an image and give it this name--

00:05:27.780 --> 00:05:34.940
"AppleTouchIcon.png." And you store this
in the root directory of your web server,

00:05:35.060 --> 00:05:41.450
and then when a user surfs over to your
site and they click on the "+" button

00:05:41.650 --> 00:05:45.380
at the bottom of the Safari screen,
they'll see this panel slide up,

00:05:45.490 --> 00:05:49.630
and this button "Add to Home Screen."
And if they touch this button,

00:05:49.780 --> 00:05:53.860
then the image that you've created
then pops up on the home screen,

00:05:53.950 --> 00:05:59.750
and they can launch your app from this
home screen icon from that point forward.

00:06:00.410 --> 00:06:05.940
So using this named image is one
way to have a home screen icon,

00:06:05.940 --> 00:06:10.110
and that's using a single image for
all of the pages of your web app.

00:06:10.440 --> 00:06:15.040
If you wanted to have different icons
for different pages of your web app,

00:06:15.080 --> 00:06:18.690
you could do that by adding a link
tag to those pages specifically.

00:06:19.000 --> 00:06:21.880
And the relationship
here is AppleTouchIcon,

00:06:21.930 --> 00:06:24.500
and I'm linking to an image here.

00:06:24.610 --> 00:06:27.260
In this case,
the name of the image doesn't matter.

00:06:27.260 --> 00:06:30.110
In the first example,
it had to be named AppleTouchIcon,

00:06:30.260 --> 00:06:33.830
but with the link tag you can
name it whatever you like.

00:06:36.180 --> 00:06:39.940
So there are some guidelines
for creating a home screen

00:06:39.940 --> 00:06:43.340
icon that we advise people on.

00:06:43.340 --> 00:06:49.890
The first is that your image
should be 57 pixels square.

00:06:49.920 --> 00:06:58.450
We add the rounded corners later on,
so a hard 90-degree angle on the corners

00:06:58.450 --> 00:06:59.970
is the best way to start so that that
rounding effect is what you want.

00:07:00.330 --> 00:07:04.840
We recommend no shine or gloss on this
image because we actually add a shine

00:07:04.840 --> 00:07:08.400
to the top of the image on the fly,
just like we add the rounded corners.

00:07:08.400 --> 00:07:10.740
And sometimes,
if you add shading to your own icon,

00:07:10.740 --> 00:07:12.840
that can kind of conflict
with the shading that we add,

00:07:12.840 --> 00:07:13.840
and it looks kind of odd.

00:07:13.970 --> 00:07:16.900
So it's often best to
have just a flat image.

00:07:17.160 --> 00:07:21.150
So going from the image that
I just had on screen with the

00:07:21.150 --> 00:07:24.420
hard edges and totally flat,
in Safari on iPhone,

00:07:24.420 --> 00:07:28.280
that image gets transformed
to what you see here.

00:07:28.400 --> 00:07:34.140
This icon that has rounded corners and
a shine across the top of the icon.

00:07:34.240 --> 00:07:39.490
So if you do want to have custom
shading on your icon and you don't

00:07:39.600 --> 00:07:43.520
want to have the shading that we add,
there's a way to do that, too.

00:07:43.560 --> 00:07:48.960
And instead of naming your icon
"AppleTouchIcon.png," you would name

00:07:49.040 --> 00:07:54.590
it "AppleTouchIcon-Precompose.png."
And that's a signal to Safari on

00:07:54.590 --> 00:08:00.430
iPhone and to the home screen to
not add any shading to your icon.

00:08:00.440 --> 00:08:04.320
You'll still get the rounded corners,
but no shading.

00:08:04.590 --> 00:08:13.820
So if I were to name my icon
"appletouchicon-precompose.png," I would

00:08:13.910 --> 00:08:20.750
go from an effect that looks like this,
what we see here, to this, just,

00:08:20.750 --> 00:08:20.750
you know, totally flat,
no shading on top,

00:08:20.750 --> 00:08:20.750
but still having the rounded corners.

00:08:23.080 --> 00:08:25.820
Okay, so now you have a home screen icon.

00:08:26.100 --> 00:08:28.370
Here it is, it's looking pretty great.

00:08:28.480 --> 00:08:31.440
And your user touches it
to launch your application,

00:08:31.440 --> 00:08:35.140
and now,
it's obvious to them again that they

00:08:35.140 --> 00:08:40.020
are running a web application because
you can see the Safari Chrome at

00:08:40.020 --> 00:08:44.020
the top and bottom of the screen,
the URL field and then the Back/Forward

00:08:44.020 --> 00:08:47.960
buttons and Bookmark buttons,
et cetera, at the bottom.

00:08:48.070 --> 00:08:50.920
So, you know, step one,
we're looking good.

00:08:51.000 --> 00:08:54.330
But step two here,
the user is queued that you're

00:08:54.330 --> 00:08:56.340
running in a web browser.

00:08:56.410 --> 00:08:58.380
And that kind of takes
away from the built-in,

00:08:58.380 --> 00:09:00.700
native look and feel of your app.

00:09:00.840 --> 00:09:05.260
So luckily, in iPhone OS 2.1,
which is the release prior to

00:09:05.260 --> 00:09:09.090
the release that just came out,
there's a way to hide

00:09:09.100 --> 00:09:11.470
the Safari UI components.

00:09:11.550 --> 00:09:15.960
So we call this "full screen
mode," and the Safari UI is

00:09:15.960 --> 00:09:20.970
hidden when your application is
launched from its home screen icon.

00:09:21.000 --> 00:09:25.640
So you can imagine,
if you enabled this feature and a user

00:09:25.670 --> 00:09:30.060
were just surfing around in Safari on
iPhone and they went to your site,

00:09:30.180 --> 00:09:34.150
and all of the UI elements disappeared,
like no URL field anymore,

00:09:34.150 --> 00:09:37.820
no Back/Forward buttons,
that would be pretty jarring,

00:09:37.820 --> 00:09:40.470
and users would also be wondering, "Well,
how do I get to another site

00:09:40.470 --> 00:09:44.040
from here "or go backwards or go
forward?" So the UI components

00:09:44.050 --> 00:09:48.790
are only hidden when your app is
launched from its home screen icon.

00:09:48.950 --> 00:09:51.000
So this feature is easy to enable.

00:09:51.000 --> 00:09:52.140
It's just a meta tag.

00:09:52.440 --> 00:09:59.310
Meta name equals "Apple mobile web
app capable." Content equals "Yes."

00:10:00.630 --> 00:10:05.770
The appearance of the status
bar when you're in full-screen

00:10:05.790 --> 00:10:07.140
mode is customizable.

00:10:07.180 --> 00:10:13.130
So the status bar is just that small
bar at the top of every screen that

00:10:13.130 --> 00:10:18.360
you see that has battery strength,
Wi-Fi signal strength, time, et cetera.

00:10:18.370 --> 00:10:19.760
That's the status bar.

00:10:19.760 --> 00:10:23.180
So, just like in native applications,
you can customize the way

00:10:23.310 --> 00:10:25.100
that status bar looks.

00:10:25.120 --> 00:10:29.660
So gray is the default,
and other options are black,

00:10:29.660 --> 00:10:31.320
and black translucent.

00:10:31.320 --> 00:10:35.400
An example of black translucent
is in the Photos app on iPhone.

00:10:35.450 --> 00:10:38.880
So you scroll the photos,
and you can see them scrolling

00:10:38.910 --> 00:10:40.310
by underneath the status bar.

00:10:40.440 --> 00:10:44.380
So that's an example
of black translucent.

00:10:44.380 --> 00:10:47.960
One important thing to know-- if
you use one of the opaque options,

00:10:48.100 --> 00:10:50.910
gray or black,
your content is going to be shifted

00:10:50.910 --> 00:10:54.620
down by 30 pixels and rendered as such.

00:10:54.630 --> 00:10:57.020
But if you use black translucent,
you're gonna get-- I'm sorry,

00:10:57.020 --> 00:10:58.560
it's 20 pixels, actually.

00:10:58.560 --> 00:11:02.360
You're gonna get that extra 20
pixels of vertical screen space

00:11:02.390 --> 00:11:06.990
because your content will be
displayed behind the status bar.

00:11:07.410 --> 00:11:09.540
So this customization is easy to enable.

00:11:09.540 --> 00:11:11.300
It's just another meta tag.

00:11:11.320 --> 00:11:18.810
Meta name equals Apple mobile
web app status bar style,

00:11:18.810 --> 00:11:18.810
and here I've set the color to black.

00:11:23.080 --> 00:11:26.730
The last useful piece of information
about full-screen mode is that

00:11:26.810 --> 00:11:29.240
you can actually query this mode.

00:11:29.280 --> 00:11:34.700
So, we were talking in an earlier session
in the Q&A about maybe you want to

00:11:34.700 --> 00:11:39.040
lay out your UI differently if the
user is running in full-screen mode,

00:11:39.080 --> 00:11:42.230
or maybe you want to add
a note on your-- you know,

00:11:42.230 --> 00:11:45.400
on the front page of your web
app to cue users to launch

00:11:45.400 --> 00:11:48.910
from the home screen icon,
et cetera.

00:11:48.940 --> 00:11:53.040
You can query this property,
just with the line of JavaScript,

00:11:53.110 --> 00:11:58.510
"window.navigator.standalone,"
looking at the standalone property.

00:12:01.230 --> 00:12:03.540
So this feature is really easy to adopt.

00:12:03.570 --> 00:12:06.750
And lots of people have picked it up.

00:12:07.010 --> 00:12:12.150
Here's one example of a cool
full-screen web app that I used

00:12:12.150 --> 00:12:14.440
a lot a couple months ago.

00:12:14.440 --> 00:12:17.320
Now, this slide is a little out of date,
I admit.

00:12:17.350 --> 00:12:22.220
But this was just an app that
showed me some poll data.

00:12:22.310 --> 00:12:24.650
And then,
when I would click the "i" button

00:12:24.670 --> 00:12:28.450
in the lower right-hand corner,
a panel slid in to show me where

00:12:28.450 --> 00:12:32.200
the poll data-- about where
the poll data was coming from.

00:12:32.430 --> 00:12:38.980
So this is a pretty simple
full-screen application,

00:12:39.130 --> 00:12:47.770
but if you have a large, you know,
complicated, multiple pages,

00:12:47.770 --> 00:12:48.230
many screens kind of web app,
there are a couple tips that

00:12:48.230 --> 00:12:48.230
you need to keep in mind if
you're using this feature.

00:12:48.900 --> 00:12:53.650
The first is that any external
links are going to open in Safari.

00:12:53.880 --> 00:12:57.230
So basically,
this means that you need to use AJAX to

00:12:57.230 --> 00:13:01.630
keep your application to a single page.

00:13:01.770 --> 00:13:07.920
Some great examples of how to do that
are built into the Dashcode templates.

00:13:08.030 --> 00:13:12.940
So there's a template that has
a browser view where you have

00:13:12.940 --> 00:13:15.310
sliding panels of different menus.

00:13:15.560 --> 00:13:19.740
And there's another one that has a flip
transition to settings on the back.

00:13:19.750 --> 00:13:25.150
These are great examples of how to
have a web application that's one page,

00:13:25.150 --> 00:13:28.770
updated with AJAX,
and a great approach to

00:13:28.770 --> 00:13:30.880
using full-screen mode.

00:13:30.930 --> 00:13:35.780
The debugger in Dashcode is a great
way to kind of take a look at the code,

00:13:35.810 --> 00:13:38.480
how the template is
achieving a certain effect,

00:13:38.530 --> 00:13:43.000
and replicate the same piece of
functionality in your web app.

00:13:46.900 --> 00:13:50.100
So that covers full-screen mode,
all that you need to know.

00:13:50.100 --> 00:13:54.350
Now we're going to talk about
detecting orientation changes

00:13:54.350 --> 00:13:56.620
from within iPhone web apps.

00:13:56.720 --> 00:14:00.410
So this is just an event on the body.

00:14:00.410 --> 00:14:05.680
So here I'm listening for
the orientation change,

00:14:05.680 --> 00:14:09.810
and when I receive that event,
I'm going to call this function that

00:14:09.810 --> 00:14:09.810
I've defined "update_orientation."

00:14:10.560 --> 00:14:14.760
In my updateorientation function,
I'm just going to look at the

00:14:14.760 --> 00:14:17.870
orientation property on the window.

00:14:17.880 --> 00:14:21.680
And if the case is zero,
I'm in portrait mode.

00:14:21.680 --> 00:14:23.740
I haven't turned the phone at all.

00:14:23.740 --> 00:14:29.070
If the case is -90,
I have turned the phone clockwise,

00:14:29.140 --> 00:14:31.460
and I'm in landscape-right mode.

00:14:31.530 --> 00:14:36.560
And if the orientation value is 90,
I've turned the phone counterclockwise,

00:14:36.640 --> 00:14:41.660
and the phone is in
landscape-left orientation.

00:14:45.660 --> 00:14:48.850
So that covers, you know,
three main points for

00:14:48.980 --> 00:14:53.400
kind of feeling built-in:
home screen icon, full-screen mode,

00:14:53.400 --> 00:14:56.100
and detecting orientation changes.

00:14:56.140 --> 00:15:00.040
For the next three sections,
we're going to, you know,

00:15:00.120 --> 00:15:05.090
get into the nuts and bolts of how to
make the contents of that application

00:15:05.160 --> 00:15:09.660
really just super optimized for iPhone,
how to take advantage of

00:15:09.660 --> 00:15:11.420
all of our new features.

00:15:11.530 --> 00:15:14.740
So getting started with
touch and gesture events.

00:15:15.910 --> 00:15:21.280
So when we first introduced this feature
around the time that iPhone SDK came out,

00:15:21.280 --> 00:15:23.700
we got some questions from
the developer community.

00:15:23.700 --> 00:15:28.480
You know, "Why can't I just use
Mouse Events "to do kind of rotation,

00:15:28.480 --> 00:15:30.300
scale, et cetera?

00:15:30.320 --> 00:15:34.200
"I click on-- I touch an element,
that's an on-click, right?" Well,

00:15:34.520 --> 00:15:38.690
this all really boils down to the
fact that a mouse is not equivalent

00:15:38.690 --> 00:15:42.920
to this disembodied hand that you see
on the right-hand side of the screen,

00:15:42.960 --> 00:15:45.800
and that, you know, a mouse,
you have continuous input.

00:15:45.910 --> 00:15:49.630
On the screen, so, you know,
you move your cursor across a web page,

00:15:49.740 --> 00:15:56.080
on-mouse over events fire,
CSS colon hover styles are applied as you

00:15:56.080 --> 00:15:58.260
move that cursor around the home screen.

00:15:58.400 --> 00:16:02.180
If you put your finger
down on a touch screen,

00:16:02.510 --> 00:16:04.820
you know, you might receive an
on-click mouse event,

00:16:04.820 --> 00:16:07.550
but then, as you move your finger around,
you're really just dragging the

00:16:07.600 --> 00:16:09.980
screen or panning the screen.

00:16:10.180 --> 00:16:12.830
The paradigm is totally
different on iPhone,

00:16:12.940 --> 00:16:15.760
so we needed to create something new.

00:16:16.110 --> 00:16:19.240
Another great reason why mouse
events aren't really appropriate

00:16:19.240 --> 00:16:24.050
for this sort of thing is that
Safari on iPhone is really the first

00:16:24.050 --> 00:16:29.680
browser to render desktop-quality
web content on a mobile device.

00:16:29.680 --> 00:16:32.940
And so we need to remain
compatible with all of that

00:16:32.960 --> 00:16:34.750
existing web content out there.

00:16:34.940 --> 00:16:39.220
And mouse events need to fire as
expected for those existing sites.

00:16:39.410 --> 00:16:42.920
But we want to be able to give you
guys the opportunity to provide

00:16:42.920 --> 00:16:46.470
the same kind of rich experience
that you see in native applications

00:16:46.570 --> 00:16:50.300
in your iPhone web applications.

00:16:51.210 --> 00:16:54.950
All right, so enough overview.

00:16:55.160 --> 00:17:01.740
Let's talk about what happens
when I put a finger down on the

00:17:01.800 --> 00:17:05.800
screen in terms of touch events.

00:17:05.840 --> 00:17:10.360
So when the first finger
touches the screen,

00:17:10.360 --> 00:17:10.360
a touch start event is sent.

00:17:10.360 --> 00:17:10.360
When that finger moves,
touch move events are sent.

00:17:10.960 --> 00:17:17.790
When that finger is
lifted from the screen,

00:17:17.930 --> 00:17:22.950
a touch-end event is sent, and of course,
if I don't move my finger in between,

00:17:22.950 --> 00:17:22.950
I just get a touch-start event
followed by a touch-end event.

00:17:23.420 --> 00:17:27.030
If a user clicks the home
screen button while a sequence

00:17:27.200 --> 00:17:31.710
of touch events is happening,
then a touch cancel event is sent.

00:17:31.710 --> 00:17:37.590
So you can handle that case gracefully
if a user clicks the home screen button.

00:17:37.590 --> 00:17:42.980
So you can listen for these events just
like you would any other mouse event,

00:17:42.980 --> 00:17:47.970
either via directly on the element
- here I'm listening for touch start

00:17:47.970 --> 00:17:51.770
on this div - or you can add them
to elements via add event listener.

00:17:52.100 --> 00:18:01.170
So here, I'm listening for a touch start,
and when that event fires,

00:18:01.170 --> 00:18:01.170
I'm going to call this function
that I've defined "track touches."

00:18:03.070 --> 00:18:05.030
Okay, so I've received an event.

00:18:05.330 --> 00:18:07.140
Now what can I do with it?

00:18:07.190 --> 00:18:09.780
Well,
the first thing you want to do is prevent

00:18:09.890 --> 00:18:12.180
the default behavior for that event.

00:18:12.180 --> 00:18:16.030
So I mentioned earlier, you know,
you put your finger down on the

00:18:16.030 --> 00:18:19.940
screen and you drag it around while
you start panning the content.

00:18:20.020 --> 00:18:22.800
If you want to work with
touch events directly,

00:18:22.830 --> 00:18:26.600
you want to disable that panning
behavior or scrolling behavior

00:18:26.640 --> 00:18:28.270
or whatever's happening.

00:18:28.270 --> 00:18:29.430
So you want to prevent the
default behavior for that event,

00:18:29.430 --> 00:18:29.430
first thing.

00:18:31.310 --> 00:18:36.700
After that,
the important thing to know is

00:18:36.700 --> 00:18:44.350
that a touch event maintains
three lists of touch objects.

00:18:44.350 --> 00:18:48.890
So the first is all touches on the page,
event.touches.

00:18:48.890 --> 00:18:48.890
The second is all
touches for this target,

00:18:48.890 --> 00:18:48.890
event.target_touches.

00:18:49.160 --> 00:18:53.100
And the third is any new
touches for this event,

00:18:53.100 --> 00:18:55.370
event.change_touches.

00:18:56.180 --> 00:19:00.880
So you have these three
lists of touch objects,

00:19:00.880 --> 00:19:08.230
and within each of those lists,
each object has certain properties.

00:19:08.230 --> 00:19:13.500
So the basics of properties
of touch objects are the

00:19:13.500 --> 00:19:17.110
target node of this touch,
which is the target,

00:19:17.110 --> 00:19:17.110
and the identifier property,
which is the unique ID for the object.

00:19:19.520 --> 00:19:25.330
Just like mouse events,
there are also many different coordinates

00:19:25.330 --> 00:19:29.120
that you can look at for that touch.

00:19:29.220 --> 00:19:32.500
So we have client X and client Y.

00:19:32.580 --> 00:19:38.530
Those are coordinates that
are relative to the viewport.

00:19:38.530 --> 00:19:38.530
Screen X,
screen Y are relative to the screen.

00:19:38.530 --> 00:19:38.530
And page X,
page Y are relative to the entire page.

00:19:38.880 --> 00:19:42.350
So the important thing to
remember with these properties is

00:19:42.350 --> 00:19:48.280
that when you receive an event,
remember that you are receiving

00:19:48.280 --> 00:19:52.700
a list of touch objects,
so you have to index into

00:19:52.810 --> 00:19:58.160
that list before you can look
at any of these properties.

00:19:58.160 --> 00:19:58.510
So here I'm looking at the first
touch in my target touches array.

00:19:58.510 --> 00:19:58.510
I'm looking at the page
X value for that touch.

00:20:02.580 --> 00:20:05.040
So you may be thinking, "Well,
touch events sound really cool,

00:20:05.040 --> 00:20:07.040
"but if I want to do
something complicated,

00:20:07.040 --> 00:20:11.880
"like detect whether a user has zoomed
in or rotated "or something like that,

00:20:11.880 --> 00:20:14.840
that's gonna be a lot to
track "in those arrays,

00:20:15.040 --> 00:20:19.050
and that could get complicated." Well,
luckily, there's kind of a high-level

00:20:19.050 --> 00:20:22.170
way to look at touch events,
and these are gesture events.

00:20:22.450 --> 00:20:25.350
These are kind of multi-touch
through JavaScript.

00:20:25.530 --> 00:20:27.860
So if we go through this
same exercise again,

00:20:27.880 --> 00:20:32.200
if I put one finger down on the screen,
a touch start event is sent.

00:20:32.260 --> 00:20:35.960
But once I have two fingers down,
gesture start events are sent,

00:20:36.040 --> 00:20:39.860
in addition to the touch events
that we've already covered.

00:20:39.860 --> 00:20:42.650
Just because gesture events are
being sent doesn't mean that

00:20:42.730 --> 00:20:44.860
touch events stop being sent.

00:20:45.200 --> 00:20:51.620
So now I have two fingers on the screen,
and as I move those fingers,

00:20:51.620 --> 00:20:51.620
gesture change events are sent.

00:20:51.860 --> 00:20:57.390
And if I lift those two
fingers off the screen,

00:20:57.390 --> 00:20:57.390
a gesture end event is sent.

00:20:58.770 --> 00:21:02.270
Of course, if I don't move my two
fingers in between,

00:21:02.330 --> 00:21:05.960
I just go directly from
gesture start to gesture end,

00:21:05.960 --> 00:21:08.930
and if I lift fingers
off the-- or I'm sorry,

00:21:08.930 --> 00:21:14.190
if the user clicks the home screen button
in the middle of a gesture sequence,

00:21:14.190 --> 00:21:16.600
then a touch cancel event is sent.

00:21:16.600 --> 00:21:19.980
And just like touch elements
or any mouse events,

00:21:19.980 --> 00:21:23.240
for that matter,
you can listen for these events

00:21:23.620 --> 00:21:27.560
directly on the element or add them
to elements via add event listener.

00:21:33.190 --> 00:21:38.340
So just like touch events,
gestures also have properties.

00:21:38.340 --> 00:21:42.700
The most basic is the
target node for the gesture.

00:21:42.700 --> 00:21:46.980
But then there are some
properties that are sort of

00:21:46.980 --> 00:21:49.840
what makes a gesture a gesture.

00:21:49.840 --> 00:21:54.610
And when I think about gestures,
I think about things like

00:21:55.100 --> 00:21:56.970
scaling and rotation.

00:21:56.970 --> 00:21:57.480
So those are two of the kind of
definitive properties on a gesture.

00:21:57.740 --> 00:22:01.160
So the first one that we'll
talk about here is scale.

00:22:01.270 --> 00:22:04.820
And scale is defined as the
distance between two fingers

00:22:04.820 --> 00:22:09.440
since the start of an event as a
multiplier of the initial distance.

00:22:09.440 --> 00:22:13.100
So that's kind of a mouthful,
a lot to remember.

00:22:13.100 --> 00:22:18.670
A good rule of thumb to keep in mind is
that if the scale value is less than one,

00:22:18.670 --> 00:22:24.330
the user has pinch closed to zoom out,
and if the scale value is more than one,

00:22:24.330 --> 00:22:24.790
the user has pinched open to zoom in.

00:22:27.630 --> 00:22:32.330
The second definitive property
of gestures is rotation.

00:22:32.340 --> 00:22:38.500
Rotation is defined as the delta rotation
since the start of an event in degrees.

00:22:38.500 --> 00:22:42.000
Again,
a good rule of thumb to keep in mind

00:22:42.000 --> 00:22:46.930
is if the rotation value is positive,
a user has rotated in

00:22:46.930 --> 00:22:52.570
the clockwise direction,
and if the rotation value is negative,

00:22:52.570 --> 00:22:53.930
they have turned in the
counterclockwise direction.

00:22:57.200 --> 00:23:07.690
Okay, so that is a quick overview
of touch and gesture events.

00:23:07.690 --> 00:23:07.690
How to implement custom gesture
detection or touch detection

00:23:07.690 --> 00:23:07.690
in your web applications.

00:23:08.500 --> 00:23:15.430
Now let's move on to this
family of technologies that

00:23:15.430 --> 00:23:15.430
we call CSS visual effects.

00:23:18.630 --> 00:23:21.940
So on iPhone OS and also on Mac OS X,
for that matter,

00:23:22.000 --> 00:23:25.950
you are used to seeing these
kind of innovative pieces of UI.

00:23:26.100 --> 00:23:29.080
So one example here is
the Weather application.

00:23:29.230 --> 00:23:31.520
To see the settings,
you get this kind of 3D

00:23:31.700 --> 00:23:34.080
flip to the other side.

00:23:34.420 --> 00:23:37.960
In Cover Flow mode in
the iPod application,

00:23:37.960 --> 00:23:41.900
you have like a 3D view of your
albums here that you can look

00:23:41.900 --> 00:23:43.750
through all your album covers.

00:23:43.890 --> 00:23:49.990
And also there's another kind of
animation that's directly in the UI,

00:23:49.990 --> 00:23:52.510
and they're a little more subtle,
but this type of animation is

00:23:52.610 --> 00:23:57.680
really providing kind of a cue to
the user as to what's going on.

00:23:57.750 --> 00:24:01.580
So I want to move this
message to another folder.

00:24:01.610 --> 00:24:04.680
It doesn't just, you know, disappear.

00:24:04.710 --> 00:24:08.390
There's this little animation,
this little jump down from, you know,

00:24:08.390 --> 00:24:10.320
the source spot to the destination spot.

00:24:10.320 --> 00:24:12.850
And now I know exactly what
has happened to that message,

00:24:12.930 --> 00:24:14.850
where it ended up.

00:24:14.860 --> 00:24:19.400
Another good example-- on Mac OS X is
minimizing a window to the dock,

00:24:19.400 --> 00:24:20.100
you know?

00:24:20.100 --> 00:24:24.010
It doesn't just disappear and
then reappear down in the dock.

00:24:24.140 --> 00:24:27.560
There's an animation that is
either the scale or the Genie

00:24:27.560 --> 00:24:30.680
effect that tells the user,
"Here was the window.

00:24:30.700 --> 00:24:31.680
"Here's where it's going.

00:24:31.680 --> 00:24:35.280
"Here's where you can find
it later on." So this kind of

00:24:35.280 --> 00:24:38.000
subtle animation is really,
you know,

00:24:38.040 --> 00:24:42.620
one of the ways that people are able
to learn to use operating systems

00:24:42.620 --> 00:24:46.400
like Mac OS X and iPhone OS so easily,
because they're being cued,

00:24:46.480 --> 00:24:49.530
as to what is actually going on.

00:24:49.540 --> 00:24:55.000
So now, there's a great way to add these
kinds of animations and unique kind of

00:24:55.000 --> 00:24:58.380
positioning to your web applications.

00:24:58.380 --> 00:25:03.120
And that's this family of technologies
that we call "CSS visual effects."

00:25:03.120 --> 00:25:06.760
So there's three aspects that
we're going to talk about today.

00:25:06.760 --> 00:25:09.650
They are transforms,
which are-- which is all about

00:25:09.710 --> 00:25:12.210
positioning content in unique ways.

00:25:12.260 --> 00:25:16.920
Transitions, which are simple animations,
sort of a-- you might think of

00:25:17.010 --> 00:25:19.750
it as a two-keyframe animation,
where you specify the first

00:25:19.880 --> 00:25:22.680
frame and the last frame,
and WebKit takes care of rendering

00:25:22.680 --> 00:25:24.980
all the frames in between.

00:25:24.980 --> 00:25:28.880
And then, we have keyframe animations,
where you have explicit control over

00:25:28.880 --> 00:25:32.960
the keyframes within an animation,
not, you know, WebKit taking care of

00:25:32.960 --> 00:25:35.010
everything in between.

00:25:35.820 --> 00:25:37.250
Okay.

00:25:37.410 --> 00:25:43.730
Oh, so this is a technology that was
pioneered by the engineers at Apple,

00:25:43.730 --> 00:25:49.290
and we have since submitted this
as part of inclusion to CSS3,

00:25:49.290 --> 00:25:53.850
and we're getting some adoption,
so that's great.

00:25:53.970 --> 00:25:59.380
If you want to see the specs that
we have written and submitted,

00:25:59.380 --> 00:26:00.590
those are available at
webkit.org/specs/cssvisualeffects.

00:26:03.850 --> 00:26:08.940
So going back to my mail example here,
if I-- you know, this is a native app,

00:26:08.940 --> 00:26:11.700
but if I wanted to do
this in a web application,

00:26:11.760 --> 00:26:14.580
I might, you know,
divide up this cell like so.

00:26:14.580 --> 00:26:18.840
You know, the name is one cell,
and the subtitle is another cell,

00:26:18.840 --> 00:26:22.030
and that envelope is a cell,
and maybe I was really

00:26:22.540 --> 00:26:26.260
lazy in my image editor,
and I just made this envelope,

00:26:26.260 --> 00:26:29.960
and I had a background color on it.

00:26:30.310 --> 00:26:33.380
So then, when I go to "Animated," it
looks really ugly because you

00:26:33.500 --> 00:26:35.300
can see this background on it.

00:26:35.420 --> 00:26:41.260
Well, a great way to position elements
like that is to use CSS transforms.

00:26:41.360 --> 00:26:45.990
So this is a way to translate, rotate,
scale, or skew any HTML element.

00:26:46.160 --> 00:26:49.510
So if we look at this
envelope example again,

00:26:49.570 --> 00:26:52.360
if I want to, you know,
turn this a little bit,

00:26:52.540 --> 00:26:58.090
I can do that in just one line of CSS,
and that is "-webkit transform

00:26:58.090 --> 00:27:01.760
rotate by 20 degrees." So one
thing I want to mention,

00:27:01.820 --> 00:27:06.360
this "-webkit" prefix here,
that's a common convention that

00:27:06.360 --> 00:27:10.200
all web browsers follow for
CSS properties that are not yet

00:27:10.200 --> 00:27:11.890
part of a final specification.

00:27:11.900 --> 00:27:16.360
So in Mozilla-based browsers,
you would see "-moz" at the beginning.

00:27:16.530 --> 00:27:19.850
So it doesn't mean that this
is non-standard and will

00:27:19.850 --> 00:27:20.980
never be part of a standard.

00:27:20.980 --> 00:27:24.720
It just means it's kind of
pre-standard at the moment.

00:27:24.960 --> 00:27:29.600
So anyway,
I've rotated my envelope by 20 degrees,

00:27:29.600 --> 00:27:36.200
and I want to mention here that you can
also chain together these transforms.

00:27:36.200 --> 00:27:42.200
So I rotated by 20 degrees,
now I've also scaled up by 25%, and

00:27:42.270 --> 00:27:48.750
I've translated in the Y direction
by 30%. And that 30% is calculated

00:27:48.900 --> 00:27:50.520
off of the size of the element,
so it's 30% of the element size.

00:27:52.470 --> 00:27:58.480
Here I've translated in the Y direction,
but you can really perform any

00:27:58.480 --> 00:28:06.200
of the transform operations
in a single direction.

00:28:06.200 --> 00:28:06.280
So you can scale only in the
X direction or only in the Y direction,

00:28:06.280 --> 00:28:06.280
or translate only in the X direction,
etc.

00:28:10.650 --> 00:28:15.090
A piece of additional control that's
available with CSS transforms is

00:28:15.090 --> 00:28:17.440
controlling the transform origin.

00:28:17.530 --> 00:28:19.420
So I have this example here.

00:28:19.420 --> 00:28:23.030
It's a, you know,
I have this sale banner on my website,

00:28:23.100 --> 00:28:26.660
and I want to rotate it, you know,
by -20 degrees.

00:28:26.660 --> 00:28:29.910
So when I do that,
there's actually an origin in the

00:28:29.910 --> 00:28:33.300
center of the element by default,
and your element is

00:28:33.300 --> 00:28:35.300
rotated around that origin.

00:28:35.300 --> 00:28:39.590
So in this case, my banner is kind of,
you know, going off the page here.

00:28:39.890 --> 00:28:44.670
So I could choose to find some
additional CSS to kind of slide

00:28:44.840 --> 00:28:48.540
that banner down a little bit,
use some CSS positioning so that

00:28:48.540 --> 00:28:51.640
it's not going off the page,
but then I've altered my site,

00:28:51.640 --> 00:28:54.980
and it might not degrade
gracefully in other browsers.

00:28:55.060 --> 00:28:58.710
A better approach is to use
WebKit Transform Origin.

00:28:58.850 --> 00:29:00.870
You know,
what I really want is to be able to set

00:29:00.870 --> 00:29:06.260
the origin in that upper left corner,
and then have my rotation applied.

00:29:06.330 --> 00:29:09.860
So I can do that with
WebKit Transform Origin here

00:29:10.050 --> 00:29:13.600
I've specified "top left,"
then my rotation is applied,

00:29:13.750 --> 00:29:17.930
and my banner is no longer
going off the screen.

00:29:18.090 --> 00:29:21.630
The added bonus here is that any
browser that doesn't understand

00:29:21.820 --> 00:29:25.680
CSS transforms will just ignore
both of these properties,

00:29:25.770 --> 00:29:28.220
and you'll just have the
straight banner across the page,

00:29:28.340 --> 00:29:32.840
but then you haven't modified
your existing CSS in a way that

00:29:32.840 --> 00:29:36.970
your site would not degrade
gracefully in other browsers.

00:29:38.750 --> 00:29:43.170
WebKit Transform Origin has the
same syntax as background position,

00:29:43.230 --> 00:29:46.790
meaning that you specify just
a pair of keywords from top

00:29:46.960 --> 00:29:48.840
left bottom center right.

00:29:48.840 --> 00:29:57.530
If you don't specify the second keyword,
then center is the default.

00:29:57.530 --> 00:29:58.690
So if I just said "webkit
transform origin top" that

00:29:58.690 --> 00:29:58.690
would really mean "top center."

00:30:01.890 --> 00:30:08.960
Okay, so that is a quick
overview of CSS transforms.

00:30:08.960 --> 00:30:08.960
Now let's move on to CSS transitions.

00:30:12.130 --> 00:30:17.000
I said in the beginning that a transition
is really a kind of simple animation.

00:30:17.000 --> 00:30:21.240
You specify the beginning
state and the end state,

00:30:21.610 --> 00:30:25.270
and WebKit,
the engine that powers Safari,

00:30:25.300 --> 00:30:30.270
is taking care of rendering
all of the frames in between.

00:30:30.270 --> 00:30:35.260
So you go from one state to another by
changing those values through JavaScript.

00:30:35.260 --> 00:30:35.260
So that's when your animation
is going to execute.

00:30:36.130 --> 00:30:39.400
So let's take a look at an example.

00:30:39.400 --> 00:30:48.470
So let's pretend that this slide
is also a web browser view,

00:30:48.470 --> 00:30:48.470
and I have this picture
in the bottom left corner.

00:30:49.120 --> 00:30:53.150
So the CSS that I would define for that
picture might look something like this.

00:30:53.290 --> 00:30:58.080
So for the WebKit transform value,
my rotation and scale

00:30:58.080 --> 00:31:00.780
are 0 and 1 respectively.

00:31:00.880 --> 00:31:06.380
Those are the default values,
but I'm just writing them out here

00:31:06.380 --> 00:31:09.450
for the purposes of this example.

00:31:09.450 --> 00:31:11.330
And I've translated in the
X direction by 20 pixels and in

00:31:11.330 --> 00:31:11.330
the Y direction by 300 pixels.

00:31:11.330 --> 00:31:11.330
Okay?

00:31:11.830 --> 00:31:14.060
So the animation that
I want to happen is,

00:31:14.110 --> 00:31:18.640
I want it to kind of flip,
rotate up to the upper right-hand

00:31:18.640 --> 00:31:23.320
corner and scale down a little bit,
and land in this upper right-hand

00:31:23.320 --> 00:31:27.320
corner of my "slide/browser" window.

00:31:27.420 --> 00:31:30.530
So if I were to write, you know,
a CSS declaration that looked

00:31:30.530 --> 00:31:33.330
like-- for this end state,
it might look like this.

00:31:33.470 --> 00:31:35.910
I rotated by 360 degrees.

00:31:36.190 --> 00:31:42.420
I've scaled it down by 50%. And now,
the element has been translated 600

00:31:42.420 --> 00:31:47.150
pixels in the X direction and 50 pixels,
let's say, in the Y direction.

00:31:47.680 --> 00:31:50.990
So to get from the first
state to the end state,

00:31:51.210 --> 00:31:55.560
I'm really just going to change these
values of the style through JavaScript.

00:31:55.690 --> 00:31:59.440
So I'm going to, you know,
get my element by its ID,

00:31:59.440 --> 00:32:03.530
which is "my_flower," and set
the style of "webkit_transform"

00:32:03.630 --> 00:32:10.350
to rotate 360 degrees,
scale by 0.5, which is 50%, and set the

00:32:10.350 --> 00:32:14.200
translation to 600 by 50 pixels.

00:32:14.200 --> 00:32:16.160
And when I change those
values through JavaScript,

00:32:16.200 --> 00:32:18.950
That's when the animation
is going to fire.

00:32:19.860 --> 00:32:23.460
So in this example,
the property that I've changed is

00:32:23.460 --> 00:32:28.220
the WebKit transform CSS property,
but really many CSS properties

00:32:28.220 --> 00:32:29.700
can be animated.

00:32:29.700 --> 00:32:35.010
The majority of CSS properties
can be animated.

00:32:35.170 --> 00:32:42.200
So things like opacity, color, et cetera,
you can alter all of those

00:32:42.520 --> 00:32:43.310
and animate state changes
for all of those properties.

00:32:43.310 --> 00:32:43.310
Okay.

00:32:44.200 --> 00:32:47.600
So, there are, you know,
we talked about how

00:32:47.600 --> 00:32:51.550
you have two keyframes,
and WebKit is taking care of rendering

00:32:51.550 --> 00:32:55.140
all of the frames in between your
beginning state and ending state.

00:32:55.170 --> 00:32:58.780
Well, there-- even though you can't
modify those keyframes directly,

00:32:58.830 --> 00:33:02.620
there is some control that
you have over that curve.

00:33:02.670 --> 00:33:06.310
So you can define the way
that curve accelerates using

00:33:06.310 --> 00:33:09.510
WebKit transition timing function.

00:33:09.660 --> 00:33:12.670
So, there are a bunch of different
curve definitions that you

00:33:12.850 --> 00:33:15.260
can specify for this property.

00:33:15.420 --> 00:33:20.650
"Ease" is one,
"linear" for uniform acceleration,

00:33:20.740 --> 00:33:27.630
"ease in," going slow and speeding up,
"ease out," going fast and slowing down,

00:33:27.740 --> 00:33:30.200
"ease in/out," slow/fast/slow.

00:33:30.260 --> 00:33:35.910
And you can also specify your own curve
definition using this cubic Bezier

00:33:36.230 --> 00:33:40.090
value and supplying X and Y coordinates.

00:33:43.330 --> 00:33:47.960
The last piece of control that you
need to know about for CSS transitions

00:33:48.000 --> 00:33:51.730
is WebKit - that you can delay
the start of a transition by

00:33:51.780 --> 00:33:54.590
specifying a WebKit transition delay.

00:33:54.590 --> 00:33:58.440
And this is basically, you know,
maybe a user clicks on a

00:33:58.440 --> 00:34:03.010
button or something like that,
and you know that a second has to pass

00:34:03.010 --> 00:34:05.900
before you want your animation to start.

00:34:05.900 --> 00:34:09.980
Well, you can, you know,
have that kind of control by using

00:34:09.980 --> 00:34:10.200
the WebKit transition delay property.

00:34:13.350 --> 00:34:19.820
Okay, so that covers CSS transitions.

00:34:19.820 --> 00:34:19.820
Let's move on to keyframe animations.

00:34:20.040 --> 00:34:24.180
So keyframe animations have all of
the advantages of CSS transitions.

00:34:24.180 --> 00:34:30.010
You know, they're easy to define,
simple to execute, et cetera,

00:34:30.160 --> 00:34:32.730
plus a few other key features.

00:34:33.260 --> 00:34:38.520
First of all, you have fine-grained
control over the keyframes,

00:34:38.520 --> 00:34:42.930
so you can, you know,
specify the behavior for the

00:34:42.930 --> 00:34:44.920
first half of an animation or
the first 25% of an animation,

00:34:44.920 --> 00:34:44.920
et cetera.

00:34:45.180 --> 00:34:48.860
You also can control the repeat
count and repeat behavior.

00:34:48.860 --> 00:34:51.780
So with transitions,
they happen only once when

00:34:51.860 --> 00:34:56.250
you change the values of a
CSS property through JavaScript,

00:34:56.500 --> 00:35:00.130
whereas animations,
you can set them to iterate forever,

00:35:00.140 --> 00:35:01.380
for instance.

00:35:01.470 --> 00:35:04.270
And also,
keyframe animations have DOM events

00:35:04.350 --> 00:35:07.780
associated with them so that you can
know when an animation has started,

00:35:07.780 --> 00:35:08.910
ended, or iterated.

00:35:09.250 --> 00:35:14.320
So we're gonna cover all of these
things by looking at an example.

00:35:14.550 --> 00:35:20.740
So CSS animations introduce a new rule,
and that is @WebKitKeyframes.

00:35:20.880 --> 00:35:23.980
And this is the way that
you define your animation.

00:35:24.320 --> 00:35:28.430
So I'm saying,
"I want an animation to happen "from

00:35:28.550 --> 00:35:34.500
WebKit transform in the Y direction,
"-50 pixels," so that's

00:35:34.500 --> 00:35:38.360
gonna be off-screen,
"down to 600 pixels," so near

00:35:38.360 --> 00:35:40.390
the bottom of the screen.

00:35:41.410 --> 00:35:43.660
So that's my definition for my animation.

00:35:43.660 --> 00:35:46.610
My animation is named "Fall."

00:35:46.990 --> 00:35:54.980
To associate that
animation with an element,

00:35:54.980 --> 00:35:57.010
I'm just going to use a
WebKit animation name and then add

00:35:57.010 --> 00:35:57.010
the name of my animation right there,
which in this case is "Fall."

00:35:57.960 --> 00:36:01.640
I've set the webkit animation
duration to be 10 seconds,

00:36:01.780 --> 00:36:05.300
so the animation is
happening over 10 seconds.

00:36:05.330 --> 00:36:10.890
I've set the iteration count to infinite,
so this leaf is going to fall forever.

00:36:11.130 --> 00:36:13.240
And I've set the timing
function to be linear,

00:36:13.240 --> 00:36:18.800
so it's falling with uniform
acceleration throughout the animation.

00:36:23.040 --> 00:36:25.400
So,
the interesting part comes when you begin

00:36:25.400 --> 00:36:29.010
to define animations over-- you know,
that change over the

00:36:29.010 --> 00:36:30.080
course of an animation.

00:36:30.220 --> 00:36:33.900
So, before,
our leaf was reaching the bottom of its

00:36:33.900 --> 00:36:37.520
path there and just kind of disappearing,
which looked kind of bad.

00:36:37.660 --> 00:36:40.600
What we really want is for that
leaf to kind of fade out as it

00:36:40.600 --> 00:36:43.220
reaches the end of its path.

00:36:43.330 --> 00:36:49.900
So here, I want the opacity to be one for
the first 3/4 of the animation,

00:36:49.970 --> 00:36:56.040
and then, for the last 25%, I want
it to fade from 1 to 0.

00:36:56.160 --> 00:36:58.610
So here,
I've defined a second animation named

00:36:58.790 --> 00:37:02.620
"fade" using the @WebKitKeyframes rule,
and then,

00:37:02.620 --> 00:37:06.220
down here in my leaf definition,
I've just chained together those

00:37:06.370 --> 00:37:12.160
two animations-- "fall" and
"fade" for WebKit animation name.

00:37:12.210 --> 00:37:15.410
I want them both to take 10 seconds,
'cause I want them to

00:37:15.410 --> 00:37:17.230
happen concurrently.

00:37:17.370 --> 00:37:20.800
I'm going to set the iteration
count to infinite for both of them.

00:37:20.800 --> 00:37:27.840
I want them both to happen forever.

00:37:27.840 --> 00:37:30.610
And I've set the timing
function for fall to linear,

00:37:30.610 --> 00:37:30.610
but I want the fade
animation to kind of ease in.

00:37:31.180 --> 00:37:36.830
So when we chain these two
animations together and set

00:37:37.190 --> 00:37:44.350
these properties like so,
we get this effect where, you know,

00:37:44.470 --> 00:37:47.830
the leaf is falling down
the side of the page,

00:37:47.830 --> 00:37:47.830
and then for the last 25% of its path,
it fades in opacity from 1 to 0.

00:37:47.830 --> 00:37:47.830
Perfectly clear.

00:37:54.680 --> 00:37:57.940
So as I mentioned earlier,
there are animation events

00:37:57.940 --> 00:38:02.500
associated with animations,
and these are pretty straightforward.

00:38:02.500 --> 00:38:07.560
You can listen for when
an animation starts,

00:38:07.610 --> 00:38:14.240
when an animation iterates,
or when an animation ends.

00:38:14.240 --> 00:38:15.390
The WebKit animation start,
WebKit animation iteration,

00:38:15.390 --> 00:38:15.390
and WebKit animation end.

00:38:17.340 --> 00:38:27.290
And you can listen for these
events just like you would

00:38:27.290 --> 00:38:28.910
listen for any other event.

00:38:28.910 --> 00:38:28.910
Here I'm listening directly on this
element for the animation end event.

00:38:31.730 --> 00:38:36.470
A couple more points of need-to-know
information-- your animation

00:38:36.520 --> 00:38:40.180
will run if WebKit animation name
specifies a known set of key frames,

00:38:40.240 --> 00:38:46.080
so be careful when you're defining
your animation using the rule

00:38:46.310 --> 00:38:49.420
that we talked about earlier.

00:38:49.420 --> 00:38:52.930
Also, the duration for this animation
has to be greater than zero.

00:38:52.990 --> 00:38:55.360
And this is true for transitions,
as well.

00:38:55.360 --> 00:38:58.560
You may have noticed there was
a property-- "WebKit transition

00:38:58.560 --> 00:39:03.340
duration" on our earlier flower site,
and that was set to two seconds.

00:39:03.380 --> 00:39:07.220
The duration for both animations and
transitions has to be greater than zero,

00:39:07.220 --> 00:39:09.260
because otherwise,
you're just going from one state

00:39:09.390 --> 00:39:13.180
to another with no time in between,
and so you don't have

00:39:13.240 --> 00:39:15.200
time to see the animation.

00:39:15.430 --> 00:39:19.120
So the duration has to
be greater than zero.

00:39:19.150 --> 00:39:23.980
You can also disable animations
with "WebKit animation name = none."

00:39:29.750 --> 00:39:37.420
So that was an overview
of CSS visual effects,

00:39:37.530 --> 00:39:43.770
a way to add hardware accelerated
graphics and animations

00:39:43.770 --> 00:39:43.770
to your web applications.

00:39:43.770 --> 00:39:43.770
Now let's talk about
storing data locally.

00:39:48.710 --> 00:39:54.180
So there are two aspects to local
storage in iPhone web applications.

00:39:54.180 --> 00:39:58.300
The first is the HTML5 SQL API,
and this has been

00:39:58.680 --> 00:40:00.630
around since before 2.2.

00:40:00.720 --> 00:40:05.460
And this is all about storing structured
data of your application on the fly.

00:40:05.480 --> 00:40:13.450
The second part of this feature
is creating an instance of your

00:40:13.450 --> 00:40:17.380
site where all the resource files
are cached locally on the device.

00:40:17.400 --> 00:40:21.940
so you don't have to load resource
files over the wire anymore.

00:40:22.970 --> 00:40:26.610
So let's get started by
talking about the SQL API,

00:40:26.610 --> 00:40:28.550
which is part of HTML5.

00:40:30.090 --> 00:40:34.000
So here's an application
that I use from time to time.

00:40:34.000 --> 00:40:37.080
It's a to-do list app,
and it's a web app,

00:40:37.080 --> 00:40:39.340
and it's really great--
I use it all the time.

00:40:39.340 --> 00:40:44.060
But when I touch that "+" button
there to add a new to-do list item,

00:40:44.270 --> 00:40:47.200
and then I type in the to-do
and I hit "Save," you know,

00:40:47.350 --> 00:40:51.720
I've noticed that it can take
anywhere from two to five seconds

00:40:51.720 --> 00:40:55.490
after I hit "Save" to the point
where my UI is updated again.

00:40:55.760 --> 00:40:58.820
And that's happening because we're
sending that information over

00:40:58.820 --> 00:41:03.340
the wire and waiting to get a
response before we update our UI.

00:41:04.000 --> 00:41:09.910
A big issue that people face when
creating web applications for

00:41:09.910 --> 00:41:12.380
mobile devices is network latency.

00:41:12.430 --> 00:41:16.760
So if you were in this morning session,
you're familiar with this slide already.

00:41:16.870 --> 00:41:20.450
But network latency is
defined as the time it takes,

00:41:20.540 --> 00:41:23.800
the round-trip time that it takes
for a packet to go from your

00:41:23.800 --> 00:41:25.410
device to the server and back.

00:41:25.570 --> 00:41:29.800
Whereas, bandwidth is defined as
the throughput amount.

00:41:29.860 --> 00:41:32.750
So latency on Wi-Fi networks
is pretty low,

00:41:32.860 --> 00:41:35.510
It's about 100 milliseconds.

00:41:35.830 --> 00:41:39.330
Latency on cellular networks
is just inherently high.

00:41:39.330 --> 00:41:41.680
It's about 500 milliseconds.

00:41:41.700 --> 00:41:44.900
So, you know,
that tacks on quite a bit of time

00:41:45.210 --> 00:41:48.360
to any information that you're,
you know,

00:41:48.360 --> 00:41:53.730
sending over the wire and then waiting
for a response to update your UI.

00:41:53.730 --> 00:41:56.720
You know,
if you tapped on a menu item in a

00:41:56.720 --> 00:42:02.530
native application and the users had to
wait two seconds for that UI to update,

00:42:02.530 --> 00:42:04.830
that would be unacceptable.

00:42:04.830 --> 00:42:05.260
So,

00:42:06.160 --> 00:42:09.190
The application that
I was just talking about,

00:42:09.240 --> 00:42:12.890
that to-do list application,
would really benefit from

00:42:12.920 --> 00:42:17.070
storing that data locally,
especially when I first enter it.

00:42:17.070 --> 00:42:19.980
So this is part of HTML5, as I mentioned.

00:42:19.980 --> 00:42:22.100
It's HTML5 database storage.

00:42:22.210 --> 00:42:25.980
And this is great because it's
a standards-based approach

00:42:25.980 --> 00:42:27.910
to local database storage.

00:42:27.910 --> 00:42:33.020
So part of HTML5 in Safari on iPhone
right now and eventually everywhere else

00:42:33.020 --> 00:42:33.360
by virtue of being part of a standard.

00:42:34.480 --> 00:42:43.900
Secondly, you know,
we're dealing with real-world SQL here.

00:42:43.900 --> 00:42:47.770
If you're a big SQL programmer,
you're going to see all of the same

00:42:47.770 --> 00:42:47.770
coding conventions and features
that you're used to seeing in SQL.

00:42:48.850 --> 00:42:52.290
This API is asynchronous
and callback-based,

00:42:52.290 --> 00:42:57.740
meaning that your application is never
going to be kind of locked up waiting

00:42:57.790 --> 00:43:00.550
for a database operation to finish.

00:43:00.590 --> 00:43:03.760
You begin a transaction,
like a write to the

00:43:03.970 --> 00:43:08.060
database for instance,
and then you're free to go execute

00:43:08.060 --> 00:43:13.120
other JavaScript in the meantime,
and your code gets a callback when

00:43:13.120 --> 00:43:13.880
that write or transaction or whatever
you've executed has finished.

00:43:15.780 --> 00:43:24.230
And lastly, origin-based security is
built-in as part of this API,

00:43:24.230 --> 00:43:31.030
meaning that your application
can only - or I'm sorry,

00:43:31.030 --> 00:43:32.530
your website can only access the
databases that it has created,

00:43:32.530 --> 00:43:32.530
and no other websites can
access your databases.

00:43:35.330 --> 00:43:38.240
So when I begin talking
about this feature,

00:43:38.240 --> 00:43:41.140
lots of people who have web
applications are just like,

00:43:41.140 --> 00:43:43.900
oh my gosh,
I cannot live without the cloud.

00:43:43.910 --> 00:43:45.720
All of my data has to
be synced to the cloud.

00:43:45.810 --> 00:43:47.180
I can't live without the cloud.

00:43:47.180 --> 00:43:49.150
I can't have just this
data on this one device.

00:43:49.300 --> 00:43:53.060
Well, we're not talking about getting
rid of the cloud altogether.

00:43:53.060 --> 00:43:57.440
We're just talking about cutting down
a lot of those network operations.

00:43:57.440 --> 00:44:00.770
You could just choose to only
store your data on the device.

00:44:00.970 --> 00:44:03.820
But lots of people want to also
store their data in the cloud.

00:44:03.890 --> 00:44:07.890
So using this SQL API is going to give
you a way to cut down that number of

00:44:07.900 --> 00:44:11.420
network operations and even do those
network operations during idle time,

00:44:11.470 --> 00:44:13.270
for instance.

00:44:13.610 --> 00:44:16.840
So this is great because it reduces
the complexity of your application.

00:44:16.840 --> 00:44:19.650
You know, you don't have to send up
every little piece of data as

00:44:19.660 --> 00:44:22.680
it's entered or as it changes,
and then piece it together

00:44:22.820 --> 00:44:23.940
on the other side.

00:44:24.060 --> 00:44:27.780
And also, you're going to have two
aspects of improved performance.

00:44:27.900 --> 00:44:29.920
The first is battery life.

00:44:29.920 --> 00:44:32.380
You know, network operations are
expensive on iPhone,

00:44:32.380 --> 00:44:37.240
so if your web app is sending
data over the wire frequently,

00:44:37.610 --> 00:44:41.420
that's gonna drain the battery
more quickly than normal.

00:44:41.500 --> 00:44:43.750
And also, you know,
going back to our to-do

00:44:43.750 --> 00:44:46.900
list application example,
your application is going to be,

00:44:47.050 --> 00:44:52.390
you know, more responsive if you're not
waiting for a response over

00:44:52.390 --> 00:44:55.540
the network to update your UI.

00:44:58.400 --> 00:45:07.160
And if this data is stored locally,
you're going to be able to access it even

00:45:07.160 --> 00:45:07.160
if your phone is totally off the network.

00:45:08.880 --> 00:45:17.300
Okay, so let's get into the
details of this API.

00:45:17.300 --> 00:45:20.630
We're going to go through
three main parts of it:

00:45:20.630 --> 00:45:20.630
creating a database,
executing transactions,

00:45:20.630 --> 00:45:20.630
and handling callbacks.

00:45:22.050 --> 00:45:25.230
So the first aspect here,
creating a database.

00:45:25.310 --> 00:45:29.470
So if you try to create - I'm sorry,
if you try to open a database

00:45:29.470 --> 00:45:33.860
and one does not exist,
then that database will be created.

00:45:33.860 --> 00:45:38.210
So the best approach here is to first,
you know,

00:45:38.230 --> 00:45:44.790
test for that database functionality
using window.opendatabase.

00:45:44.790 --> 00:45:45.380
If the functionality doesn't exist,
you can fall back to some other code.

00:45:45.980 --> 00:45:48.130
Here I'm setting up a few parameters.

00:45:48.250 --> 00:45:52.900
To do is the name of my
database stored on disk.

00:45:52.930 --> 00:45:56.130
I've set a version number to 1.0.

00:45:56.890 --> 00:46:04.350
I've set this variable display
name to a string that's going to

00:46:04.350 --> 00:46:04.350
be displayed in any UI prompts.

00:46:05.870 --> 00:46:11.400
And also I've set an
expected size here in bytes.

00:46:11.440 --> 00:46:19.680
And I pass all of these
parameters to open database,

00:46:19.680 --> 00:46:19.680
and I'm returned a handle to a new
database if one doesn't exist already.

00:46:20.150 --> 00:46:26.330
One important thing to know is
that it's really only the first

00:46:26.380 --> 00:46:30.530
parameter that's strictly required.

00:46:30.530 --> 00:46:36.480
So if you know that you're opening
a database that already exists,

00:46:36.480 --> 00:46:36.480
you can just provide the name
and pass null for the last three

00:46:36.480 --> 00:46:36.480
parameters and you'll still
get a handle to your database.

00:46:40.490 --> 00:46:43.490
Okay, so once you have a
handle to your database,

00:46:43.540 --> 00:46:47.200
you can start doing stuff with it,
and the way to do stuff with that

00:46:47.210 --> 00:46:49.520
database is through transactions.

00:46:49.560 --> 00:46:53.220
So anyone who isn't familiar
with database programming,

00:46:53.330 --> 00:46:57.350
a transaction is really just
an atomic unit of work that

00:46:57.350 --> 00:46:58.910
cannot partially succeed.

00:46:59.190 --> 00:47:03.400
So when you start thinking
about relational databases and

00:47:03.470 --> 00:47:05.830
how that data's integrated,
this is really important.

00:47:05.920 --> 00:47:10.160
Like,
you don't want to go halfway through,

00:47:10.160 --> 00:47:11.940
you know,
a transaction and have something fail,

00:47:11.940 --> 00:47:16.310
and then only half of your tightly
integrated relational data is modified.

00:47:16.450 --> 00:47:18.440
That would be bad.

00:47:18.510 --> 00:47:22.340
So with transactions,
if something fails along the way,

00:47:22.370 --> 00:47:25.710
the entire transaction is
rolled back to the beginning.

00:47:26.380 --> 00:47:33.300
So all queries in this HTML5
SQL API have to be part of a transaction.

00:47:34.850 --> 00:47:37.600
And a transaction looks like this.

00:47:37.730 --> 00:47:44.030
Here I've opened my Todo database
and then I just set a transaction on

00:47:44.160 --> 00:47:52.180
that Todo database handle and I am
creating a string of SQL and I'm

00:47:52.250 --> 00:47:57.070
passing that string to the execute
SQL function on my transaction.

00:47:57.070 --> 00:47:57.070
And that executes the SQL.

00:48:02.200 --> 00:48:05.750
As I mentioned earlier,
this API is asynchronous

00:48:05.820 --> 00:48:07.320
and callback-based.

00:48:07.420 --> 00:48:12.730
So in order to know when things happen,
you have to listen for these callbacks.

00:48:12.840 --> 00:48:15.300
So there's two types of callbacks.

00:48:15.310 --> 00:48:19.400
The first is a transaction callback,
and this is related to the

00:48:19.920 --> 00:48:21.760
entire transaction as a whole.

00:48:21.870 --> 00:48:25.330
And the second type of
callback is a query callback,

00:48:25.330 --> 00:48:28.530
and those types of callbacks
are related to the individual

00:48:28.530 --> 00:48:28.530
queries within the transactions.

00:48:28.920 --> 00:48:31.430
So let's talk about
transition callbacks first.

00:48:31.550 --> 00:48:34.390
As I said, these are related to
the entire transaction,

00:48:34.530 --> 00:48:36.310
and there's two types of callbacks.

00:48:36.490 --> 00:48:43.440
There's the completion callback to
detect when a transaction has completed,

00:48:43.580 --> 00:48:49.380
and there's also an error callback,
so if there is an error within

00:48:49.380 --> 00:48:50.940
your transaction and it's going to
be rolled back to the beginning,

00:48:50.940 --> 00:48:50.940
you can know about that as well.

00:48:54.200 --> 00:48:58.800
Query callbacks, as I mentioned earlier,
are related to the individual

00:48:58.800 --> 00:49:00.840
queries within the transaction,
okay?

00:49:00.840 --> 00:49:04.600
So again, there's two types of
callbacks here for queries.

00:49:04.600 --> 00:49:08.800
The first is the data callback,
which you can use to manipulate the data

00:49:08.800 --> 00:49:11.280
that you've received back from a query.

00:49:11.280 --> 00:49:13.840
And the second is an error callback.

00:49:13.920 --> 00:49:15.650
So, you know,
we mentioned that all queries

00:49:15.650 --> 00:49:16.870
are part of a transaction.

00:49:16.880 --> 00:49:20.530
And if a transaction fails in the middle,
it is automatically rolled

00:49:20.530 --> 00:49:21.930
back to the beginning.

00:49:22.470 --> 00:49:26.320
Well, there's a callback,
a query callback that you can use to say,

00:49:26.320 --> 00:49:29.100
well, this query that I've executed
is actually optional.

00:49:29.100 --> 00:49:31.800
Please don't let the whole, you know,
transaction fail and roll

00:49:31.800 --> 00:49:32.890
back to the beginning.

00:49:32.900 --> 00:49:36.220
So you can use this error callback,
error query callback,

00:49:36.340 --> 00:49:40.240
to specify that queries within
your transaction are optional.

00:49:40.240 --> 00:49:43.630
If you haven't specified an
error callback for a query,

00:49:43.630 --> 00:49:47.210
then an error on that query is
assumed fatal and your transaction

00:49:47.210 --> 00:49:48.580
is rolled back to the beginning.

00:49:53.390 --> 00:49:57.300
So if you want to get started
developing with this feature,

00:49:57.300 --> 00:50:01.260
it's actually also implemented
in Safari on the desktop.

00:50:01.520 --> 00:50:05.740
And that is really valuable because
there's some great tools available

00:50:06.180 --> 00:50:10.420
in Safari on the desktop that
you can use if you're developing.

00:50:10.420 --> 00:50:11.860
So here's an example.

00:50:11.860 --> 00:50:16.020
It's at webkit.org,
and it's just a set of sticky notes,

00:50:16.020 --> 00:50:20.660
and it's storing both the position
of the notes and the contents of the

00:50:20.660 --> 00:50:21.970
notes in a database on the back end.

00:50:22.810 --> 00:50:30.120
So if I open up the web inspector and
click on this databases tab at the top,

00:50:30.250 --> 00:50:35.940
I can actually inspect all of
the data that is being stored

00:50:35.940 --> 00:50:40.520
in this particular table,
which is great.

00:50:40.520 --> 00:50:41.190
You can inspect your data as you're
developing and make sure that you're

00:50:41.190 --> 00:50:41.190
getting the results that you anticipated.

00:50:42.420 --> 00:50:46.220
This view is also great because if
you click on the database name or

00:50:46.220 --> 00:50:50.320
this little prompt at the bottom,
you get a prompt in the main view.

00:50:50.320 --> 00:50:53.960
And from here,
you can execute arbitrary SQL statements.

00:50:53.960 --> 00:50:57.920
Again,
a great way to kind of test as you go,

00:50:58.000 --> 00:50:59.920
to make sure you're getting
the results that you want.

00:50:59.960 --> 00:51:03.630
Also, I love it,
there's tab completion in this view,

00:51:03.730 --> 00:51:07.860
so I can just type the letter s
and tab to fill in the word select.

00:51:07.860 --> 00:51:10.980
And it speeds me up tremendously.

00:51:10.980 --> 00:51:15.840
And that auto completion is
also true for table names,

00:51:15.840 --> 00:51:16.210
etc.

00:51:18.650 --> 00:51:27.880
Okay, so that covers the SQL API storing
structured data locally.

00:51:27.950 --> 00:51:32.310
Now let's talk about a feature.

00:51:32.370 --> 00:51:33.950
It's called HTML5 Offline Applications,
and this is new in iPhone OS 2.2,

00:51:33.950 --> 00:51:33.950
so the update that just came out.

00:51:34.870 --> 00:51:43.230
So your web application has many
resources that kind of come together

00:51:43.280 --> 00:51:47.040
to make it a web application.

00:51:47.040 --> 00:51:51.400
You know, you have CSS files,
JavaScript files,

00:51:51.400 --> 00:51:51.400
you might have some video, HTML, etc.

00:51:51.400 --> 00:51:51.400
All of these come together
to make your web app.

00:51:52.860 --> 00:52:00.820
Well, there's a way that you can cache
all of those files locally,

00:52:00.820 --> 00:52:00.820
and there's really three aspects
that you need to know about

00:52:00.820 --> 00:52:00.820
to sort of make this work.

00:52:00.950 --> 00:52:05.340
The first aspect of this
feature is the cache manifest.

00:52:05.460 --> 00:52:13.180
This is just a text file of
URLs that specify which resources

00:52:13.180 --> 00:52:13.180
you want to store locally.

00:52:14.560 --> 00:52:23.030
The next thing you need to know
about is the update mechanism.

00:52:23.030 --> 00:52:23.030
How do new files get into the
cache and old files are kicked out?

00:52:23.520 --> 00:52:31.560
And lastly, what events can you listen
for to know what kind of state

00:52:31.560 --> 00:52:31.560
your app or the cache is in?

00:52:33.200 --> 00:52:38.100
Okay, so let's take a closer
look at the cache manifest.

00:52:38.130 --> 00:52:41.380
So as I mentioned earlier,
this is just a text file,

00:52:41.380 --> 00:52:46.120
and it's really just a list of URLs,
and I've saved mine in a file that

00:52:46.120 --> 00:52:52.050
I've named "mymanifest.manifest."
And that file would look like this.

00:52:52.080 --> 00:52:57.220
So a required value here is you
have to have "cache manifest"

00:52:57.220 --> 00:52:59.500
as the first line of this file.

00:52:59.500 --> 00:53:03.300
But from there, you know,
comments are any lines that

00:53:03.300 --> 00:53:07.500
begin with the pound sign,
and you're really just listing

00:53:07.500 --> 00:53:12.280
the URL resources that you
want to store locally on disk.

00:53:12.300 --> 00:53:16.010
And they can be absolute
URLs or relative URLs.

00:53:17.540 --> 00:53:21.260
So within this cache manifest,
there are two different types

00:53:21.340 --> 00:53:23.510
of entries that you can define.

00:53:23.510 --> 00:53:27.930
There's explicit entries,
and this is the default, but these say,

00:53:28.030 --> 00:53:32.390
"Go to the cache first for this
resource always." And then there's

00:53:32.390 --> 00:53:36.090
also a way to specify what's
called an online whitelist,

00:53:36.090 --> 00:53:39.040
and you use that with
this network keyword.

00:53:39.040 --> 00:53:43.070
And this indicates to the browser
that you want to always fetch

00:53:43.070 --> 00:53:45.110
these resources from the network,
never from the cache.

00:53:47.920 --> 00:53:50.880
So here I'm creating this
weather application that

00:53:50.880 --> 00:53:52.880
I want to function offline.

00:53:52.900 --> 00:53:58.940
I always want to get the
forecast dynamically.

00:53:58.940 --> 00:54:03.990
I never want to show
a stale forecast here,

00:54:03.990 --> 00:54:03.990
so I always want to fetch
that over the network.

00:54:03.990 --> 00:54:03.990
So I'm going to use the network
keyword to indicate that.

00:54:08.930 --> 00:54:12.720
So once you've defined your manifest,
you add this as an

00:54:12.720 --> 00:54:14.600
attribute to the HTML tag.

00:54:14.610 --> 00:54:21.610
And that looks something like this.

00:54:21.630 --> 00:54:25.090
So I have HTML manifest equals
offline weather dot manifest is

00:54:25.090 --> 00:54:25.090
the name of my manifest file.

00:54:26.690 --> 00:54:28.280
To make this work,
you actually have to make a

00:54:28.360 --> 00:54:32.840
tweak to your server settings
to serve this type of file with

00:54:32.840 --> 00:54:36.180
a text/cache manifest MIME type.

00:54:36.270 --> 00:54:38.920
So that's easy to do.

00:54:38.970 --> 00:54:42.920
On Mac OS X,
you just add a line to this file--

00:54:43.000 --> 00:54:46.560
private @c.apache2.mimetypes.

00:54:46.590 --> 00:54:50.740
Just add a line to that file
indicating-- in this case,

00:54:50.820 --> 00:54:55.510
I would wanna serve all files that
have a manifest extension with

00:54:55.510 --> 00:54:58.910
the text/cache manifest mime type.

00:55:05.200 --> 00:55:11.290
So now you're using a - you
have a manifest defined,

00:55:11.290 --> 00:55:19.980
and when Safari on iPhone goes to,
you know, your application's URL,

00:55:19.980 --> 00:55:21.540
your resources are going to be initially
loaded from the cache if they're there

00:55:21.540 --> 00:55:21.540
- if they've been previously downloaded.

00:55:22.270 --> 00:55:30.960
If your manifest file has changed,
a new manifest file and the

00:55:30.960 --> 00:55:30.960
resources within that manifest
file will be fetched as necessary.

00:55:34.170 --> 00:55:39.740
So this fetching happens automatically
if your manifest file has changed.

00:55:40.080 --> 00:55:43.890
But the part that is manual is
you have to actually swap in

00:55:43.890 --> 00:55:48.380
the new version of the cache
files and swap the old files out.

00:55:48.430 --> 00:55:52.940
So the time to do this is when
this updateReady event fires.

00:55:52.980 --> 00:55:58.760
So here, when onUpdateReady fires,
I'm going to call this

00:55:58.830 --> 00:56:02.280
function yourReadyHandler,
which is a function I've defined.

00:56:02.280 --> 00:56:06.280
And when that happens,
I'm going to call swapCache

00:56:06.280 --> 00:56:08.040
on the application cache.

00:56:08.040 --> 00:56:10.370
And as I said,
that kind of swaps out your

00:56:10.440 --> 00:56:15.310
old resources and swaps in
the newly downloaded version.

00:56:19.580 --> 00:56:24.470
So one event that we mentioned
there was on Update Ready,

00:56:24.570 --> 00:56:30.570
but there are a couple other events
that you can listen for as well with

00:56:30.570 --> 00:56:33.820
respect to the application cache.

00:56:33.820 --> 00:56:39.930
We're not going to go into them in
too much detail here for lack of time,

00:56:39.930 --> 00:56:40.930
but you can check for things
like if there was an error,

00:56:40.930 --> 00:56:40.930
if the files are currently downloading,
etc.

00:56:46.410 --> 00:56:52.690
So that is today's talk on
advanced web technologies.

00:56:52.690 --> 00:56:58.520
We talked about, you know,
feeling built-in with

00:56:58.520 --> 00:57:04.280
the rest of the system,
feeling like a native built-in app.

00:57:04.280 --> 00:57:04.280
We talked about how to define
touch and gesture events through

00:57:04.280 --> 00:57:04.280
JavaScript with DOM touch.

00:57:04.660 --> 00:57:10.840
We talked about how to position
your content in unique ways and

00:57:10.840 --> 00:57:18.160
add hardware accelerated graphics
to your UI with CSS visual effects.

00:57:18.160 --> 00:57:23.440
And lastly,
we talked about storing data locally,

00:57:23.440 --> 00:57:27.060
so storing structured data in an
SQLite database and also creating a

00:57:27.060 --> 00:57:27.060
fully offline version of your web app.

00:57:27.350 --> 00:57:31.550
So usually when I give this talk,
at the end of it people are just like,

00:57:31.610 --> 00:57:34.600
"Oh my gosh,
I never knew you could do all of this

00:57:34.600 --> 00:57:38.880
stuff in a web application before."
And I have to agree that some of

00:57:39.090 --> 00:57:41.060
this technology is pretty cool.

00:57:41.060 --> 00:57:44.840
So I have been just issuing an
open challenge to the attendees

00:57:44.920 --> 00:57:49.170
here of the Tech Talks to really
take these technologies and really,

00:57:49.250 --> 00:57:53.990
you know, make something great,
make something that people never expected

00:57:54.130 --> 00:57:54.710
could function in a web application.

00:57:54.780 --> 00:57:56.700
And then email me about it.

00:57:56.700 --> 00:58:01.480
Here is my contact info.

00:58:01.480 --> 00:58:01.480
I'm vicki@apple.com.

00:58:02.260 --> 00:58:10.990
All of your iPhone web application
resources are basically linked

00:58:10.990 --> 00:58:10.990
from developer.apple.com/webapps.

00:58:11.670 --> 00:58:15.730
And I've also linked
to the HTML5 spec here,

00:58:15.730 --> 00:58:23.560
and also I've added a link
to our CSS visual effects

00:58:23.560 --> 00:58:23.560
proposal at webkit.org.
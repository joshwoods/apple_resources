WEBVTT

00:00:20.650 --> 00:00:23.360
Hi, I'm Larry Coope at Apple Engineer.

00:00:23.420 --> 00:00:25.300
In this video,
you'll learn about structuring

00:00:25.300 --> 00:00:27.860
your application and data
to support a dynamic,

00:00:27.980 --> 00:00:29.540
flexible architecture.

00:00:29.610 --> 00:00:33.020
We'll also talk about reusability
and communication throughout

00:00:33.060 --> 00:00:34.380
your application flow.

00:00:34.440 --> 00:00:37.660
You'll learn how to be ready to adopt
new features and technologies as

00:00:37.660 --> 00:00:40.680
they become available in iPhone OS.

00:00:41.000 --> 00:00:44.400
Welcome to Effective iPhone
Application Architecture,

00:00:44.510 --> 00:00:47.220
or as I like to say,
doing things right every day.

00:00:48.920 --> 00:00:53.730
We're all here today because you want,
and Apple wants, the same thing.

00:00:53.740 --> 00:00:58.280
The best possible application
for your users in the App Store.

00:00:58.280 --> 00:01:01.980
And we feel over the years
we've learned a thing or two

00:01:01.980 --> 00:01:05.830
about building applications
for the Mac and for the iPhone.

00:01:05.840 --> 00:01:10.530
Starting in 2001 with the
initial release of Mac OS X,

00:01:10.740 --> 00:01:13.530
all the way up to iPhone OS 3.0.

00:01:14.060 --> 00:01:20.500
We've learned the paradigms, the models,
the design patterns that work every day

00:01:20.500 --> 00:01:25.020
to build an effective architecture and
that allows you to build a flexible,

00:01:25.090 --> 00:01:28.920
dynamic application that you can
move forward into the future.

00:01:28.920 --> 00:01:32.140
But we understand the realities as well.

00:01:33.710 --> 00:01:36.840
You start with a simple idea,
and you start building your application,

00:01:36.840 --> 00:01:39.070
and pretty soon you've got
something that you like.

00:01:39.160 --> 00:01:42.160
You start showing it to friends,
and you take it into work,

00:01:42.160 --> 00:01:45.600
and pretty soon, before you know it,
you start adding features.

00:01:45.600 --> 00:01:48.960
The designers come and talk to you,
start adding new screens, new data.

00:01:48.960 --> 00:01:54.440
And what happens is things slowly
build and can get out of hand quickly.

00:01:54.440 --> 00:01:58.680
You start with a prototype,
and pretty soon you've got

00:01:58.720 --> 00:02:03.080
a system that is working,
but has not been built from the ground

00:02:03.080 --> 00:02:05.170
up to do the right things every day.

00:02:05.180 --> 00:02:07.790
And that's all about what
we're talking about here today,

00:02:07.790 --> 00:02:11.020
is extending your application
architecture to make sure that you

00:02:11.020 --> 00:02:14.680
can benefit from all the tools and
frameworks that Apple provides.

00:02:18.040 --> 00:02:21.020
So I want to talk about
four things in this session.

00:02:21.090 --> 00:02:23.010
And the first one,

00:02:23.480 --> 00:02:33.360
Data Persistence Design Decisions
Memory Management Application Lifecycle

00:02:33.550 --> 00:02:36.630
People ask me why we would talk
about data persistence first before

00:02:36.630 --> 00:02:38.400
we talk about design decisions.

00:02:38.430 --> 00:02:41.240
And that's because if you don't
understand your own data and your

00:02:41.240 --> 00:02:44.280
own model underlying that data,
it's tough to make design decisions

00:02:44.280 --> 00:02:46.400
about your application and the workflow.

00:02:46.400 --> 00:02:54.350
So let's talk about data persistence.

00:02:54.390 --> 00:02:54.400
First of all,
we've got to talk about the kinds

00:02:54.400 --> 00:02:54.400
of data that you're going to
use in your iPhone application.

00:02:55.690 --> 00:02:58.590
First of all, we've got user data,
your media and your documents,

00:02:58.610 --> 00:03:02.540
your audio files,
things that the user has control over.

00:03:02.580 --> 00:03:07.880
You've got user preferences, state,
navigation state, application state,

00:03:07.880 --> 00:03:09.820
when they close.

00:03:09.850 --> 00:03:13.840
You have sensitive data, usernames,
passwords.

00:03:13.860 --> 00:03:15.440
And of course, you have cached data.

00:03:15.660 --> 00:03:19.110
And by cached data, I mean data that can
be rebuilt dynamically,

00:03:19.110 --> 00:03:23.180
but you want available for
quick access to your data set.

00:03:23.900 --> 00:03:26.700
So when you talk about user data,
we've got multiple options.

00:03:26.700 --> 00:03:29.740
I'd like to point out some
of the data sets we see and

00:03:29.740 --> 00:03:31.550
things to do and not to do.

00:03:31.560 --> 00:03:35.830
The first thing is not to
use unstructured text files.

00:03:35.830 --> 00:03:39.680
This is not a proper data
set and a proper model.

00:03:39.680 --> 00:03:42.800
Unstructured data is unstructured
data and it's difficult to

00:03:42.800 --> 00:03:44.620
maintain and manage and extend.

00:03:44.620 --> 00:03:46.360
But we do have property lists.

00:03:46.390 --> 00:03:48.550
You've all been familiar with this.

00:03:48.730 --> 00:03:49.720
NSDictionary.

00:03:50.730 --> 00:03:51.580
Straight XML.

00:03:51.580 --> 00:03:53.300
Fantastic use on the phone.

00:03:53.300 --> 00:03:55.090
We've got archiving.

00:03:55.090 --> 00:03:58.560
If you're not familiar with NSCoding,
it's a very powerful technology for

00:03:58.690 --> 00:04:03.750
freeze-drawing objects on the phone
and restoring them later on the fly.

00:04:03.760 --> 00:04:05.870
We've got SQLite.

00:04:05.930 --> 00:04:09.360
And now in iPhone OS 3.0,
we've got Core Data.

00:04:09.360 --> 00:04:11.320
So let's talk about
choosing your storage,

00:04:11.320 --> 00:04:13.400
your data storage,
from the multiple options

00:04:13.400 --> 00:04:14.760
that you have available.

00:04:14.760 --> 00:04:17.520
The first question you
have to ask yourself is,

00:04:17.520 --> 00:04:20.020
is this a user-controlled data set?

00:04:20.670 --> 00:04:25.110
And by user-controlled data set,
I mean that it's a data set that can

00:04:25.110 --> 00:04:28.560
grow from potentially zero to infinity.

00:04:28.560 --> 00:04:34.180
That the user maintains and is not under
direct control of your application.

00:04:34.180 --> 00:04:39.160
If the answer to that is yes,
then you should be looking at Core Data.

00:04:39.160 --> 00:04:42.760
Core Data is a powerful technology
that's been available on the desktop

00:04:42.760 --> 00:04:45.120
and is now available in iPhone OS 3.0.

00:04:46.560 --> 00:04:49.400
If the answer to that is no,
that this is not a

00:04:49.420 --> 00:04:52.810
user-controlled data set,
the next question is,

00:04:52.940 --> 00:04:54.710
is it a small data set?

00:04:54.720 --> 00:04:59.190
And if the answer to that is yes,
then you can look at things like

00:04:59.600 --> 00:05:02.980
XML and NSDictionary to store your data.

00:05:02.980 --> 00:05:06.220
However, if the answer is no,
that it's a large data set,

00:05:06.310 --> 00:05:09.460
even though it's under
your programmatic control,

00:05:09.460 --> 00:05:12.320
you still need to be
looking at core data.

00:05:13.590 --> 00:05:15.840
All right, now that we've talked about
choosing your storage,

00:05:15.890 --> 00:05:17.720
I want to talk about
implementing your storage.

00:05:17.750 --> 00:05:20.640
And first, we need to talk about
proper data objects.

00:05:20.640 --> 00:05:25.200
As you build your data store,
it's easy to start saying, well,

00:05:25.200 --> 00:05:27.860
I've got all these separate
objects I need to store,

00:05:27.860 --> 00:05:31.360
and I want to put them all
aggregated in one place.

00:05:31.360 --> 00:05:36.090
So we can see NSDictionary as
a nice repository of storage.

00:05:36.180 --> 00:05:39.540
And that can be very interesting
for simple data types.

00:05:40.300 --> 00:05:44.660
But what happens is as we build these,

00:05:45.050 --> 00:05:49.080
Each key value pair
requires a key string.

00:05:49.160 --> 00:05:51.360
And what can happen is you
start to spread these strings

00:05:51.480 --> 00:05:53.180
all throughout your code.

00:05:53.250 --> 00:05:56.980
And there's no contract between
the object and the dictionary and

00:05:56.980 --> 00:05:58.820
the clients of that dictionary.

00:05:58.870 --> 00:06:00.800
In the sense of,

00:06:01.020 --> 00:06:02.960
Value for key just returns an ID.

00:06:03.240 --> 00:06:04.430
It's not strongly typed.

00:06:04.510 --> 00:06:09.550
So pretty soon, you see these APIs spread
throughout your code.

00:06:09.550 --> 00:06:12.870
You're accessing the dictionary,
but you don't even know what type

00:06:13.120 --> 00:06:15.130
of value you're going to get back.

00:06:15.200 --> 00:06:18.490
So you define constants and
strings to make sure that you can

00:06:18.500 --> 00:06:21.240
separate out the code a little bit,
but quickly,

00:06:21.310 --> 00:06:25.530
this spins out of control because,
like I said, there's no contract between

00:06:25.530 --> 00:06:29.070
the clients of that dictionary
and the dictionary itself.

00:06:29.110 --> 00:06:32.820
These are just opaque types,
and so you don't have any idea

00:06:32.820 --> 00:06:35.580
what's happening underneath the hood.

00:06:35.930 --> 00:06:41.590
So we recommend that you don't store
these type of objects in dictionaries.

00:06:41.590 --> 00:06:45.240
You want real, proper data objects.

00:06:45.240 --> 00:06:47.840
And that means in an
object-oriented world,

00:06:47.840 --> 00:06:52.830
we have an object that has the
properties and the attributes on that

00:06:52.840 --> 00:06:56.500
property to make that contract complete.

00:06:56.720 --> 00:07:00.890
So when you use those APIs,
there is this implicit contract

00:07:00.890 --> 00:07:03.540
between the object and the client.

00:07:03.610 --> 00:07:07.170
So for instance, in this case,
if I want to change the name

00:07:07.170 --> 00:07:10.800
of my session from a simple
string to an array of strings,

00:07:10.800 --> 00:07:13.820
the compiler is going to help
me when I choose that storage

00:07:13.820 --> 00:07:17.180
and I change that property type
from a string to an NSArray.

00:07:17.180 --> 00:07:20.380
So let the tools help
you do that every day.

00:07:21.920 --> 00:07:24.370
So this is how you want to
structure your data objects

00:07:24.700 --> 00:07:28.650
as true objects in the system,
high-level objects that have

00:07:28.650 --> 00:07:31.670
this implicit contract between
the clients and themselves.

00:07:33.210 --> 00:07:35.600
Next, let's talk about user preferences.

00:07:35.600 --> 00:07:40.340
And these are handled by a single class
inside the iPhone called NSUserDefaults.

00:07:40.490 --> 00:07:42.540
And these are really just
for lightweight settings,

00:07:42.540 --> 00:07:43.820
things like navigation state.

00:07:43.900 --> 00:07:47.290
Certainly in our own apps,
in the iPhone app,

00:07:47.450 --> 00:07:51.290
the list of cities is stored
in the NSUserDefaults.

00:07:51.950 --> 00:07:54.930
And, in fact,
those navigation states are a

00:07:54.930 --> 00:07:57.480
simple index stored in the phone.

00:07:57.480 --> 00:08:01.210
So when you quit the
application and launch back in,

00:08:01.210 --> 00:08:05.290
that index is retrieved,
and it's just an index into that

00:08:05.290 --> 00:08:07.920
array inside NSUserDefaults.

00:08:08.160 --> 00:08:12.500
Now, it should be important to point out
here that this NSUserDefaults is

00:08:12.600 --> 00:08:14.200
not for heavyweight data.

00:08:14.350 --> 00:08:17.120
No large images, no archived objects.

00:08:17.200 --> 00:08:21.380
You do not want to use NSCoding here
and store these inside NSUserDefaults.

00:08:21.460 --> 00:08:24.390
And it's certainly not for
sensitive data like passwords.

00:08:24.400 --> 00:08:28.210
For that case, we have the keychain.

00:08:28.660 --> 00:08:31.760
This is where you want to
store all your sensitive data

00:08:31.760 --> 00:08:34.020
pertinent to your application.

00:08:34.410 --> 00:08:38.470
And what people forget is not
only can you store your sensitive

00:08:38.470 --> 00:08:43.370
data on a per-application basis,
we also have the ability to

00:08:43.370 --> 00:08:48.280
store the sensitive data for a
company-wide set of applications.

00:08:48.280 --> 00:08:53.260
So what you can do is if you have, say,
a multiple set of social

00:08:53.290 --> 00:08:58.200
networking applications,
you can store your keychain data such

00:08:58.200 --> 00:09:02.940
that when the user logs in for the
first time with their application,

00:09:02.940 --> 00:09:05.550
one of your applications,
then the next time they

00:09:05.630 --> 00:09:09.160
launch the other application,
they're not required to log in

00:09:09.160 --> 00:09:12.000
again because you've stored that
in the company-wide keychain.

00:09:12.000 --> 00:09:15.480
And this gives the user a very nice
user experience because they don't

00:09:15.480 --> 00:09:19.080
have to log in every single time
to all your different applications.

00:09:21.720 --> 00:09:24.240
Next,
we'll go back and talk about cached data.

00:09:24.710 --> 00:09:28.420
And why do we talk about
here faster iTunes backups?

00:09:28.780 --> 00:09:32.160
Because it's important where you
store that cached data to give the

00:09:32.160 --> 00:09:34.700
user the best possible experience,
even when they're not

00:09:34.700 --> 00:09:35.920
using your application.

00:09:37.900 --> 00:09:42.960
So this is all about storing your
data in the proper locations.

00:09:43.040 --> 00:09:46.240
And these locations are
in NSPathUtilities.h,

00:09:46.290 --> 00:09:48.320
and it's a single line of code to use.

00:09:48.650 --> 00:09:51.710
What's important to point out here is
you do not want to use hard-coded paths.

00:09:51.720 --> 00:09:55.580
You should never have a hard-coded
path anywhere in your application.

00:09:55.700 --> 00:10:01.880
It's trivial to get the path to
any arbitrary folder on the system.

00:10:02.010 --> 00:10:04.040
And let's look at some of those folders.

00:10:04.110 --> 00:10:06.850
We have NSTemporaryDirectory.

00:10:07.900 --> 00:10:12.360
The NS Caches Directory and
the NS Documents Directory.

00:10:12.380 --> 00:10:15.090
And what's important to point out here,
as you see on the slide,

00:10:15.100 --> 00:10:19.420
that during backup,
the NS Temporary Directory may

00:10:19.590 --> 00:10:23.120
be cleared by the system,
but it is not backed up.

00:10:23.180 --> 00:10:28.750
The NS Caches Directory is
left alone on the device,

00:10:29.010 --> 00:10:32.020
but it is also not backed up.

00:10:32.180 --> 00:10:37.880
Remember, cache data is data that you can
restore at any time or regenerate.

00:10:37.980 --> 00:10:42.210
Certainly, your NS Document Directory and
almost everything else inside

00:10:42.210 --> 00:10:43.620
the phone is backed up.

00:10:43.820 --> 00:10:48.020
So the point here is that even when
the user is not using your application,

00:10:48.020 --> 00:10:50.120
not even thinking about
using your application,

00:10:50.120 --> 00:10:53.210
if you store your data
in the proper locations,

00:10:53.210 --> 00:10:57.560
you give the user the best possible
experience because we don't want to

00:10:57.560 --> 00:11:01.720
have them backing up unnecessary data
and slowing down that backup process.

00:11:04.900 --> 00:11:06.140
All right.

00:11:06.270 --> 00:11:07.030
Design decisions.

00:11:07.050 --> 00:11:08.680
We've talked about data.

00:11:08.780 --> 00:11:13.740
Now we need to talk about how to
decompose your app workflow to make

00:11:13.740 --> 00:11:18.180
changes easier so you can move your
application forward from a feature basis.

00:11:18.180 --> 00:11:20.200
What are we going to cover?

00:11:20.200 --> 00:11:23.650
Well, first we're going to talk
about targeting the iPhone OS,

00:11:23.650 --> 00:11:26.290
application flow,
and the information flow

00:11:26.290 --> 00:11:28.010
within your application.

00:11:28.020 --> 00:11:29.180
What are we going to cover?

00:11:30.640 --> 00:11:33.000
So targeting iPhone OS.

00:11:33.060 --> 00:11:36.290
This is about choosing
your application's reach.

00:11:36.670 --> 00:11:41.530
Obviously, iPhone comes out,
we have a base SDK and

00:11:41.530 --> 00:11:44.730
a large feature set,
and all the users are

00:11:44.730 --> 00:11:49.100
available on that base SDK,
and they're using that,

00:11:49.290 --> 00:11:51.030
and your application
is going to cover that.

00:11:52.860 --> 00:11:56.150
But pretty soon,
Apple puts out a new release of the OS.

00:11:56.150 --> 00:11:57.630
It's got some new tools.

00:11:57.630 --> 00:12:01.090
And then it's not as
quickly adopted initially,

00:12:01.090 --> 00:12:04.260
so you feel safe that
I can stay on that SDK.

00:12:04.280 --> 00:12:06.820
But pretty soon, iPhone OS 3 comes out.

00:12:08.600 --> 00:12:10.570
And we've got massive adoption of that.

00:12:10.650 --> 00:12:16.150
And you need to broaden your
reach and get those customers and

00:12:16.150 --> 00:12:17.530
take advantage of those features.

00:12:17.550 --> 00:12:21.080
But how do I do that without
leaving my customers behind?

00:12:21.100 --> 00:12:22.630
It's very, very simple.

00:12:22.630 --> 00:12:24.940
It's all about the deployment target.

00:12:27.010 --> 00:12:30.240
And that will give you the
broadest coverage for all your

00:12:30.240 --> 00:12:33.840
users and all the SDKs and OSs.

00:12:33.940 --> 00:12:36.380
But how do you stay current and do that?

00:12:36.470 --> 00:12:38.390
Well,
it's all about maximizing your exposure,

00:12:38.390 --> 00:12:40.330
and it's very, very simple.

00:12:40.460 --> 00:12:42.980
You always link against the latest SDK.

00:12:43.370 --> 00:12:47.080
There's really no reason for
you to stay on an older SDK.

00:12:47.180 --> 00:12:51.620
And all you do is once you've linked
against that latest SDK is you simply

00:12:51.620 --> 00:12:54.990
set your iPhone OS deployment target.

00:12:55.510 --> 00:12:57.600
And this is how you adopt
new features dynamically.

00:12:57.600 --> 00:12:59.280
And what will this do for me?

00:12:59.280 --> 00:13:01.840
Well,
what it does is it allows me to weak

00:13:01.840 --> 00:13:05.500
link against the newest frameworks,
and then at runtime,

00:13:05.500 --> 00:13:08.540
I can test for the presence
of those new API sets,

00:13:08.540 --> 00:13:12.560
and I don't have to base any of
my behavior off the OS version.

00:13:12.580 --> 00:13:14.180
This is very, very important.

00:13:14.180 --> 00:13:17.960
You should never base any specific
functionality off the version of the OS.

00:13:17.960 --> 00:13:19.920
You should do dynamic lookup.

00:13:20.000 --> 00:13:23.020
And so to do that,
you need to know how to understand

00:13:23.020 --> 00:13:25.380
how to read the availability macros.

00:13:25.400 --> 00:13:28.290
So let's look at those real quick.

00:13:28.720 --> 00:13:33.070
In this particular case,
what this macro says is that if the

00:13:33.070 --> 00:13:37.540
current OS version of the Mac is
greater than or equal to 10.4,

00:13:37.540 --> 00:13:40.100
then this code is going to be compiled.

00:13:40.100 --> 00:13:43.900
Or in our case, what's more important,
if it's greater than or

00:13:43.900 --> 00:13:45.940
equal to iPhone OS 3.0.

00:13:46.080 --> 00:13:48.620
So that means if it's
iPhone OS 3.0 or better,

00:13:48.720 --> 00:13:52.300
then this framework code is going
to be included in my compilation.

00:13:53.340 --> 00:13:56.410
But what's more important,
as you can see, this is taken from the

00:13:56.410 --> 00:14:01.000
UI image picker controller,
is the other availability macros.

00:14:01.000 --> 00:14:03.910
In this case,
we see OS X available starting,

00:14:03.910 --> 00:14:07.660
and this tells me that it's
never been available on the Mac,

00:14:07.720 --> 00:14:11.460
and it is available
starting in iPhone OS 3.1.

00:14:12.960 --> 00:14:16.040
In the next case,
the secondary macro says

00:14:16.110 --> 00:14:17.800
OS X available but deprecated.

00:14:17.800 --> 00:14:19.440
So this is a pair of values.

00:14:19.440 --> 00:14:22.560
In this case, we're looking at the
allows image editing,

00:14:22.560 --> 00:14:24.600
which is also in the
UI image picker controller.

00:14:24.600 --> 00:14:27.760
And this says that it's never
been available on the Mac.

00:14:27.760 --> 00:14:30.080
It's never been deprecated on the Mac.

00:14:30.080 --> 00:14:34.990
It started to be available in
iPhone OS 2.0 and now has been

00:14:34.990 --> 00:14:38.020
deprecated in iPhone OS 3.1.

00:14:38.030 --> 00:14:42.510
So it's an easy pairing to see how you
read that to tell me what's available.

00:14:42.800 --> 00:14:48.160
So how do we take advantage of
these features at runtime without

00:14:48.160 --> 00:14:50.940
leaving our older customers behind?

00:14:51.020 --> 00:14:51.870
It's very simple.

00:14:51.870 --> 00:14:52.740
Runtime checking.

00:14:53.010 --> 00:14:55.420
And it couldn't be easier.

00:14:55.590 --> 00:14:59.490
In this case, this sample code,
not only I can check

00:14:59.490 --> 00:15:02.940
not only for the class,
but specific implementations

00:15:02.940 --> 00:15:04.000
inside the class.

00:15:04.000 --> 00:15:07.860
So in this example,
I'm checking to see if MF Mail Compose

00:15:07.860 --> 00:15:10.240
View Controller is available.

00:15:10.240 --> 00:15:13.220
And NSClass from String does that for me.

00:15:13.220 --> 00:15:17.210
And the really interesting thing
about weak linking and dynamic loading

00:15:17.210 --> 00:15:20.560
is if that class is not available,
NSClass from String

00:15:20.560 --> 00:15:22.340
will simply return nil.

00:15:22.340 --> 00:15:23.840
So it's very powerful.

00:15:24.170 --> 00:15:28.160
I can check at runtime on the fly
to see if this class is available.

00:15:28.570 --> 00:15:31.000
And if it is not nil,
then the class is available.

00:15:31.220 --> 00:15:34.980
I can use our old friend
response to selector to see if

00:15:34.980 --> 00:15:37.250
specific methods are available.

00:15:37.460 --> 00:15:41.290
And in this case,
I'm checking to see if I can send mail.

00:15:41.580 --> 00:15:44.770
And then, of course, in this example,
if that's not available,

00:15:44.840 --> 00:15:50.280
I'll fall back to just calling this
a traditional mail client with a URL.

00:15:51.000 --> 00:15:55.720
Also, it's important to note
that for C functions,

00:15:55.750 --> 00:15:59.530
because the dynamic loader at runtime,
if you weak link,

00:15:59.530 --> 00:16:03.490
resolves symbols that are not
available on this version of the OS,

00:16:03.490 --> 00:16:05.570
it resolves them to null.

00:16:05.580 --> 00:16:08.650
So the important thing is this
is called a T vector test.

00:16:08.690 --> 00:16:12.070
And so in this case,
the UI save video at path to save

00:16:12.210 --> 00:16:14.440
photos album is a C function.

00:16:14.440 --> 00:16:18.930
And I can simply test for the presence
of that function by testing against null.

00:16:19.980 --> 00:16:22.980
Because like I said,
weak linking tells the system

00:16:22.980 --> 00:16:26.130
if that method or if that
function is not available,

00:16:26.150 --> 00:16:28.190
just mark its address as null.

00:16:28.200 --> 00:16:30.930
So this is really,
really powerful technology,

00:16:30.930 --> 00:16:35.620
one of the most interesting things that's
available at the low level in the system.

00:16:35.620 --> 00:16:39.330
So weak linking and runtime checking
are very important so that you get the

00:16:39.340 --> 00:16:41.580
broadest coverage for your application.

00:16:43.820 --> 00:16:49.020
Now, let's talk about application flow
and how to design your application

00:16:49.340 --> 00:16:52.540
with some of the constructs that
we've talked about previously.

00:16:52.690 --> 00:16:56.690
The important thing is
organizing your content.

00:16:56.970 --> 00:17:00.930
On these smaller devices,
it's really important to stay focused,

00:17:00.930 --> 00:17:02.820
not only on UI,
but on the data that you're

00:17:02.820 --> 00:17:03.790
presenting to the user.

00:17:03.800 --> 00:17:09.120
So, as you see in our own apps,
it's important to focus on one thing at a

00:17:09.120 --> 00:17:12.470
time and drill down into greater detail.

00:17:14.010 --> 00:17:18.600
So I want to talk about one of
our examples called recipes.

00:17:18.740 --> 00:17:21.500
And what's interesting about
the recipes application,

00:17:21.500 --> 00:17:24.580
even though it's relatively
straightforward and simple,

00:17:24.580 --> 00:17:29.380
it's a good example of how to structure
any application and get the best possible

00:17:29.380 --> 00:17:31.880
use of the architectures we provide.

00:17:33.600 --> 00:17:37.780
In this case, as you saw,
the recipes application

00:17:37.790 --> 00:17:39.390
has three screens.

00:17:39.740 --> 00:17:42.750
A list of recipes,
so we have a list controller.

00:17:43.120 --> 00:17:45.620
We have a detail screen,
which shows an individual recipe,

00:17:45.760 --> 00:17:47.340
so we have a detail controller.

00:17:47.340 --> 00:17:50.370
And we show a photo of
the finished product,

00:17:50.390 --> 00:17:52.690
so we have a photo controller.

00:17:53.180 --> 00:17:55.560
And this is important to talk about.

00:17:55.610 --> 00:17:58.690
UI View Controller is one of
the basic building blocks for

00:17:58.990 --> 00:18:01.920
almost every iPhone application.

00:18:02.270 --> 00:18:05.660
And the idea here is one screen,
one view controller.

00:18:05.680 --> 00:18:07.520
As I said, this is a small device.

00:18:07.580 --> 00:18:08.710
You need to stay focused.

00:18:08.820 --> 00:18:13.060
The best applications stay focused
on their data for the user.

00:18:13.260 --> 00:18:16.820
And what you do is you simply
subclass UI view controller to

00:18:16.820 --> 00:18:18.560
add your own application logic.

00:18:18.560 --> 00:18:21.750
And this slide is important to
look at because the view controller

00:18:22.060 --> 00:18:25.480
encapsulates the three most
important parts of your application.

00:18:25.480 --> 00:18:29.880
The view system, what the user sees,
the data, your model,

00:18:29.880 --> 00:18:33.920
and of course the logic that
binds all those together.

00:18:35.580 --> 00:18:39.000
And I said, this is the basic building
block for every application,

00:18:39.000 --> 00:18:41.830
and you'll see this time and time again.

00:18:43.010 --> 00:18:44.900
So what is the role of
the view controller?

00:18:45.190 --> 00:18:49.400
Well, at Apple, we talk a lot about MVC,
Model View Controller.

00:18:49.400 --> 00:18:53.680
And this is a great design pattern
that you should use in every

00:18:53.850 --> 00:18:55.300
application that you're building.

00:18:55.300 --> 00:19:00.520
The point of the view controller
is it is that controller that

00:19:00.520 --> 00:19:03.320
we talk about in the MVC model.

00:19:03.320 --> 00:19:06.390
But in this case,
the view controller is very interesting

00:19:06.390 --> 00:19:09.640
because it also is responsible
for loading the view system,

00:19:09.640 --> 00:19:12.360
typically from your nib
or programmatically.

00:19:12.660 --> 00:19:16.570
But the important part is here
it acts as the arbiter between

00:19:16.860 --> 00:19:19.000
your model and the view system.

00:19:19.020 --> 00:19:22.530
And in this diagram, I want to point out
something very important,

00:19:22.530 --> 00:19:24.470
which is what you don't see.

00:19:24.480 --> 00:19:28.330
You should never have that
direct connection between the

00:19:28.330 --> 00:19:30.230
model and the view system.

00:19:30.410 --> 00:19:33.980
If you do,
you've got a problematic architecture.

00:19:33.980 --> 00:19:36.430
It's not going to be flexible,
it's not going to be dynamic,

00:19:36.430 --> 00:19:38.110
and it's not going to be changeable.

00:19:38.120 --> 00:19:42.420
So the idea is that this view controller,
like I said, acts as a model.

00:19:42.420 --> 00:19:47.170
It acts as the arbitrator of these
objects and handles that flow in between.

00:19:47.310 --> 00:19:51.570
So make sure you don't tightly couple
your model to your view system ever.

00:19:51.760 --> 00:19:55.970
And in this example, we're going to use
UI Navigation Controller,

00:19:56.060 --> 00:20:00.050
which just implements a stack
of view controllers and lets you

00:20:00.100 --> 00:20:04.560
build up a nice drill down UI,
as we say, into your application.

00:20:05.930 --> 00:20:09.800
So, we've talked about the
flow of the application.

00:20:09.800 --> 00:20:13.270
How do we make the information
work within that flow?

00:20:13.270 --> 00:20:15.940
Well, we need to talk about the model.

00:20:15.940 --> 00:20:17.370
This is your data.

00:20:17.370 --> 00:20:20.920
And in this case,
we're looking at a recipe application.

00:20:20.920 --> 00:20:25.210
So, we've got a database
with a set of recipes.

00:20:25.220 --> 00:20:27.560
And in this case,
we're going to be using core data.

00:20:27.560 --> 00:20:29.800
As I said,
it's a great way to store your data.

00:20:30.420 --> 00:20:33.860
And then, inside each recipe,
we've got other data objects,

00:20:33.950 --> 00:20:36.950
ingredients, instructions,
and a small image.

00:20:36.950 --> 00:20:40.100
And, as well,
we have a large image attached to each

00:20:40.130 --> 00:20:42.710
recipe that shows us a finished product.

00:20:46.040 --> 00:20:51.170
So one thing that we see people
doing is they have many screens,

00:20:51.170 --> 00:20:55.120
one model, and so they just think, well,
why not?

00:20:55.390 --> 00:20:56.740
Why don't I just do this?

00:20:56.740 --> 00:21:01.080
Why don't I just make my model,
since I only have one model object,

00:21:01.680 --> 00:21:04.940
accessible to every screen,
every view in my system?

00:21:06.140 --> 00:21:09.260
Well, that gets very problematic as we
talk about a dynamic application

00:21:09.320 --> 00:21:11.760
architecture and as you want
to add features down the road.

00:21:12.030 --> 00:21:17.650
So what we like to see is a more
unique coupling between the screens

00:21:17.650 --> 00:21:19.720
and the data they represent.

00:21:19.720 --> 00:21:23.540
Again, we're focusing on
UI and focusing on data.

00:21:25.870 --> 00:21:30.480
So let's talk about the flow of
that data in our application.

00:21:30.580 --> 00:21:34.240
Since this is a recipes application,
we're going to have our

00:21:34.370 --> 00:21:36.930
application delegate,
and it's going to be responsible

00:21:37.600 --> 00:21:40.580
for loading that recipe database.

00:21:40.700 --> 00:21:43.280
It's also, however,
going to be responsible for

00:21:43.280 --> 00:21:48.440
instantiating that first view controller,
that first list-based view controller,

00:21:48.440 --> 00:21:52.450
and handing it that database,
that list of objects

00:21:52.460 --> 00:21:53.860
that it needs to display.

00:21:53.860 --> 00:21:59.360
Then that view controller is going to
be responsible for the detail view.

00:21:59.360 --> 00:22:05.690
And the important thing here is that
that detail view is going to be given

00:22:05.690 --> 00:22:09.050
the recipe that it's going to show.

00:22:09.430 --> 00:22:11.820
It is not going to take the recipe.

00:22:11.820 --> 00:22:13.350
It's going to be passed that data.

00:22:13.360 --> 00:22:16.940
And this is a common theme that's
very important as part of your

00:22:17.110 --> 00:22:19.320
data flow through your application.

00:22:19.320 --> 00:22:22.000
You need to make sure that
you're not sharing data.

00:22:22.000 --> 00:22:25.890
You're passing that data or
you're transferring ownership

00:22:26.530 --> 00:22:28.410
to that view controller.

00:22:28.420 --> 00:22:31.490
So it only needs to know about a recipe.

00:22:31.490 --> 00:22:34.580
It doesn't have to know about
the list of recipes or anything.

00:22:34.580 --> 00:22:37.510
It just knows about the one
model object it's concerned with.

00:22:37.980 --> 00:22:41.850
And of course, in the same case,
that detail view is then responsible for

00:22:41.900 --> 00:22:48.800
instantiating and putting that photo view
on screen as well and passing the photo,

00:22:48.800 --> 00:22:53.240
again, transferring ownership of that
data object to that view controller

00:22:53.240 --> 00:22:54.830
so that it can display that.

00:22:56.170 --> 00:22:59.040
So let's go back and talk about
that application delegate.

00:22:59.040 --> 00:23:01.880
It's going to load our model,
and it's going to hand it off

00:23:01.880 --> 00:23:02.940
to the first view controller.

00:23:02.940 --> 00:23:06.040
So here you see in our application
to finish launching method,

00:23:06.040 --> 00:23:10.140
we're going to instantiate our
list table view controller,

00:23:10.140 --> 00:23:14.620
and we're going to pass it the
core data manage object context.

00:23:15.720 --> 00:23:18.380
Manage object contexts are,
think of them as a

00:23:18.380 --> 00:23:20.130
scratch pad for core data.

00:23:20.250 --> 00:23:24.690
And each controller may or may not
have to know about this manage object

00:23:24.690 --> 00:23:28.120
context depending on its context
and what it's going to do with that.

00:23:28.200 --> 00:23:31.480
But this is what core data passes
around so you can access the

00:23:31.810 --> 00:23:33.760
data inside your core data model.

00:23:33.790 --> 00:23:36.700
And then we're going to push
that navigation controller on,

00:23:36.700 --> 00:23:38.530
and we're going to see it on screen.

00:23:40.560 --> 00:23:42.160
So what happens next?

00:23:42.260 --> 00:23:45.710
Well, like all things iPhone,
it all starts with a user action.

00:23:45.710 --> 00:23:49.600
So I'm going to make a selection,
and when that happens,

00:23:49.600 --> 00:23:54.260
I'm going to get my table view did
select row at index path method call.

00:23:54.260 --> 00:23:57.620
And the important thing here is
we want to determine the minimal

00:23:57.620 --> 00:24:01.110
amount of required data to pass
to that next view controller.

00:24:01.110 --> 00:24:04.200
Again,
transferring ownership of that data set.

00:24:04.730 --> 00:24:07.150
So we're going to ask the
fetch results controller,

00:24:07.290 --> 00:24:10.680
which again is a core data object,
that I want it to give me

00:24:10.680 --> 00:24:13.020
that object at index path.

00:24:13.050 --> 00:24:15.110
And it's going to return
me my recipe object.

00:24:15.160 --> 00:24:19.620
And then I'm going to instantiate
my detail view controller,

00:24:19.920 --> 00:24:24.200
and I'm going to give it the
recipe that it needs to display.

00:24:24.200 --> 00:24:27.970
And then I'm going to push it
on to the navigation stack,

00:24:27.970 --> 00:24:30.210
and then I'm going to forget it.

00:24:31.680 --> 00:24:34.600
Very nice, very simple,
very straightforward, right?

00:24:34.650 --> 00:24:37.540
Well, we forget until something happens.

00:24:37.580 --> 00:24:40.580
Like, I would like to edit my recipe.

00:24:40.760 --> 00:24:43.590
What if I want to edit the contents
or the instructions or just

00:24:43.590 --> 00:24:46.630
simply the name of the recipe?

00:24:47.120 --> 00:24:50.770
Well, right now,
we know that the ListViewController

00:24:50.870 --> 00:24:54.580
knows about the DetailViewController,
that it's presented to the user.

00:24:54.600 --> 00:24:58.900
Well, if I want to change that
data in that recipe,

00:24:58.900 --> 00:25:01.380
the parent will need to know.

00:25:03.730 --> 00:25:07.500
And what's important here is that
the list view might have to update

00:25:07.530 --> 00:25:11.820
if I change the name or some
other data inside my detail view.

00:25:11.820 --> 00:25:15.260
That list view is going to have to
reflect that when I display that.

00:25:15.330 --> 00:25:19.720
So it needs to know about
changes in individual recipes.

00:25:20.140 --> 00:25:22.330
And you say, well, the parent,
the ListView,

00:25:22.330 --> 00:25:27.100
the parent already knows about the
child because it's put that on screen.

00:25:27.100 --> 00:25:31.440
So maybe I'll just do this and
have a back pointer to the parent.

00:25:31.460 --> 00:25:34.780
Well,
in an effective application architecture,

00:25:34.780 --> 00:25:36.790
this is typically a bad idea.

00:25:36.810 --> 00:25:41.660
What we want to use is delegation,
which you're probably already

00:25:41.660 --> 00:25:44.740
familiar with if you've done
application development for the iPhone.

00:25:45.760 --> 00:25:49.690
Delegation is, again,
a very powerful application architectural

00:25:49.720 --> 00:25:52.600
strategy and design pattern that
you should be using every day.

00:25:54.030 --> 00:25:57.080
And the interesting thing
about delegation is you get

00:25:57.080 --> 00:25:58.920
to declare the protocol.

00:25:58.920 --> 00:26:01.880
You get to declare the API set.

00:26:01.950 --> 00:26:05.630
And that's really,
really powerful to me because then

00:26:05.920 --> 00:26:10.550
I have control what these delegates,
what kind of data they send off,

00:26:10.550 --> 00:26:15.020
and what that means to the someone
who's listening to that delegate.

00:26:16.790 --> 00:26:22.050
So when I declare a protocol, again,
it's very straightforward, simple syntax.

00:26:22.110 --> 00:26:25.590
And in this case,
I'm going to declare a protocol that

00:26:25.590 --> 00:26:27.980
says that the recipe did change.

00:26:28.920 --> 00:26:32.770
So for the recipe detail view controller,
recipe did change colon.

00:26:33.190 --> 00:26:34.030
This is my method.

00:26:34.070 --> 00:26:38.690
It's a single method that I'm going to
declare for my delegates to support.

00:26:39.240 --> 00:26:41.190
I simply create a delegate property.

00:26:41.200 --> 00:26:44.090
What's important to remember here
is the delegate property is on the

00:26:44.090 --> 00:26:45.720
object that needs to be declared.

00:26:45.730 --> 00:26:45.780
So I'm going to declare a protocol
that says that the recipe did change.

00:26:45.780 --> 00:26:45.820
And that's really,
really powerful to me because then

00:26:45.820 --> 00:26:45.860
I have control what these delegates,
what kind of data they send off,

00:26:45.860 --> 00:26:46.150
and what that means to me.

00:26:46.940 --> 00:26:50.000
So think of it as I'm going from the
object that knows that something's

00:26:50.000 --> 00:26:53.370
changed to someone that might want
to know that something's changed.

00:26:53.470 --> 00:26:56.400
My delegate is the object that
is listening to these changes,

00:26:56.400 --> 00:26:58.270
if you want to think of it that way.

00:26:59.430 --> 00:26:59.430
So I'm going to declare a protocol
that says that the recipe did change.

00:26:59.430 --> 00:26:59.430
What's important to remember here
is the delegate property is on the

00:26:59.430 --> 00:26:59.430
object that needs to be declared.

00:27:00.000 --> 00:27:04.420
So in my Detail View Controller,
I'm going to create a

00:27:04.420 --> 00:27:06.770
recipe detail delegate.

00:27:06.910 --> 00:27:10.680
And, like most delegates in the system,
they are simply assigned.

00:27:10.680 --> 00:27:14.280
You typically do not retain a delegate.

00:27:15.320 --> 00:27:18.170
And that's why it's important
about being a good delegate.

00:27:18.390 --> 00:27:21.100
First of all, you implement the protocol.

00:27:21.180 --> 00:27:25.630
As part of my interface for my
recipe list table view controller,

00:27:25.630 --> 00:27:27.390
you'll notice here,

00:27:27.810 --> 00:27:32.250
That I declare that I support the
Recipe Detail View Controller Delegate.

00:27:32.330 --> 00:27:35.640
I support that protocol.

00:27:36.160 --> 00:27:39.190
And indeed, I will implement that method.

00:27:39.670 --> 00:27:41.670
And in this case,
since I'm the list view,

00:27:41.950 --> 00:27:44.860
all I'm going to tell myself
is to reload the data,

00:27:45.050 --> 00:27:46.700
because something in
that recipe has changed.

00:27:46.700 --> 00:27:50.820
So I want to reload my list to
reflect any of those changes.

00:27:51.140 --> 00:27:52.780
Don't forget to set the delegate.

00:27:53.000 --> 00:27:54.770
And this, again, couldn't be easier.

00:27:54.770 --> 00:27:57.900
Going back to our code
snippet from before,

00:27:57.900 --> 00:27:59.420
I'm creating my detail view controller.

00:27:59.420 --> 00:28:00.280
I give it the recipe.

00:28:00.280 --> 00:28:03.110
Then I set myself,
the list view controller,

00:28:03.110 --> 00:28:04.750
as the detail delegate.

00:28:06.230 --> 00:28:09.140
But it's important to be
a responsible delegate.

00:28:09.290 --> 00:28:13.140
And what's important here is
to be aware that the delegating

00:28:13.140 --> 00:28:14.970
object may outlive you.

00:28:14.980 --> 00:28:16.450
So what do we mean?

00:28:16.450 --> 00:28:20.550
Well, in this case, say the list view
controller was to go away,

00:28:20.550 --> 00:28:22.780
and we're going to take that off screen.

00:28:22.780 --> 00:28:27.920
Well, it's important since the list
view controller put the detail

00:28:27.920 --> 00:28:32.450
view controller on screen and
gave it itself as the delegate,

00:28:32.600 --> 00:28:35.420
we need to make sure that if we go away,
if we are dialect,

00:28:35.420 --> 00:28:39.170
that we tell that detail view
controller that we have gone away.

00:28:39.190 --> 00:28:42.940
And we do this simply by sending
its recipe detail delegate to nil.

00:28:42.940 --> 00:28:45.850
Remember, like I said,
delegates are typically not retained,

00:28:45.850 --> 00:28:49.750
so you must notify that object
and set its delegate to nil.

00:28:49.750 --> 00:28:52.610
This is a standard design
pattern throughout the system.

00:28:52.620 --> 00:28:55.460
So it's important to be a good,
responsible delegate.

00:28:57.120 --> 00:28:59.900
But let's talk about
alternatives to delegation.

00:29:00.030 --> 00:29:02.000
And the number one is notifications.

00:29:02.070 --> 00:29:06.460
Delegation being a one-to-one
mapping is very powerful,

00:29:06.620 --> 00:29:11.240
but what if I have multiple clients that
need to know about the recipe changes?

00:29:11.390 --> 00:29:12.760
Well, then you would use notifications.

00:29:12.820 --> 00:29:14.960
NS notifications vary again, very simple.

00:29:14.960 --> 00:29:20.070
You simply add yourself as an observer to
those notifications and listen for them.

00:29:21.560 --> 00:29:24.880
But like delegation, it's important,
and we see this time and time again,

00:29:24.880 --> 00:29:28.590
to make sure that you tell the
notification center if you're going away.

00:29:28.600 --> 00:29:32.120
So in this case, if we are listening to
a certain notification,

00:29:32.220 --> 00:29:35.730
we need to tell the notification
center that we are going away.

00:29:35.760 --> 00:29:38.530
Sending messages to nil
is not a problem in Cocoa,

00:29:38.530 --> 00:29:41.620
but sending messages to a
garbage pointer is a problem,

00:29:41.860 --> 00:29:43.720
and you're going to get a crash.

00:29:43.720 --> 00:29:47.980
So again,
be a responsible notification handler.

00:29:48.000 --> 00:29:50.390
There's also key value observing.

00:29:50.820 --> 00:29:52.680
We don't have time to go
into it in this session,

00:29:52.680 --> 00:29:57.470
but key value observing lets you
watch and listen in to particular

00:29:57.530 --> 00:30:00.180
methods and objects inside your system.

00:30:00.180 --> 00:30:03.620
It's very powerful,
and core data uses that quite heavily.

00:30:05.120 --> 00:30:07.780
And how does that pertain
to our example today?

00:30:07.890 --> 00:30:09.580
Recipes and core data.

00:30:09.650 --> 00:30:14.770
Well, in this case, all those systems,
notifications, delegation, and KVO,

00:30:14.910 --> 00:30:15.540
are in play.

00:30:15.540 --> 00:30:20.720
We have our NSManaged object context,
which as part of core data,

00:30:20.720 --> 00:30:25.350
registers for every property
in your core data schema.

00:30:25.360 --> 00:30:27.740
This is very, very powerful.

00:30:29.240 --> 00:30:34.650
Then we have NSFetch Results Controller,
and that talks to the NSManage

00:30:34.650 --> 00:30:38.820
object context to get and
retrieve your recipe data.

00:30:38.820 --> 00:30:44.580
So what happens when
that recipe data changes?

00:30:45.020 --> 00:30:50.850
Well, I'm going to be notified via
KVO to my NSManageObject context

00:30:50.850 --> 00:30:52.270
that the recipe has changed.

00:30:52.280 --> 00:30:55.140
Like I said,
Core Data automatically registers for

00:30:55.140 --> 00:30:57.620
every property in your Core Data schema.

00:30:57.620 --> 00:31:01.170
So if you change a recipe or
any attributes on that recipe,

00:31:01.170 --> 00:31:04.240
the NSManageObject
context will be notified.

00:31:06.000 --> 00:31:11.370
Then, notification is sent out from the
managed object context because there

00:31:11.420 --> 00:31:17.940
might be multiple fetch results
controllers listening for those changes.

00:31:18.570 --> 00:31:22.720
And then your list view, in this case,
is a delegate of the

00:31:22.900 --> 00:31:26.630
NSFetchResults controller,
and that's going to let your list

00:31:26.630 --> 00:31:28.730
know that it needs to reload the data.

00:31:28.740 --> 00:31:33.900
So all these notification systems, KVO,
notification, delegation, are in play.

00:31:33.900 --> 00:31:37.060
And this is, again,
a very typical design pattern that we

00:31:37.360 --> 00:31:40.850
use in our own applications and you
should take advantage of to structure

00:31:40.850 --> 00:31:42.520
your application architecture.

00:31:43.320 --> 00:31:47.660
So we've done all this
separation of model,

00:31:47.660 --> 00:31:49.640
data, UI views.

00:31:49.640 --> 00:31:51.290
Why are we doing this?

00:31:51.300 --> 00:31:54.340
Well, the most important reason is reuse.

00:31:56.340 --> 00:32:00.940
And you see this every day inside
our own frameworks and applications.

00:32:01.240 --> 00:32:04.420
Think of the people picker,
UI image picker.

00:32:04.470 --> 00:32:10.370
All I have to do is instantiate
one of those objects,

00:32:10.590 --> 00:32:13.600
And I have them,
I simply declare myself as a

00:32:13.610 --> 00:32:15.940
delegate and present them on screen.

00:32:15.940 --> 00:32:19.760
And I immediately have that built-in
functionality with very little code,

00:32:19.760 --> 00:32:21.660
and I don't have to write
these objects myself.

00:32:21.660 --> 00:32:24.580
So I can absolutely
reuse these every day.

00:32:24.600 --> 00:32:27.570
And in our case,
the recipe detail view controller,

00:32:27.570 --> 00:32:30.740
if I was going to stick it in a
cookbook instead of a recipes,

00:32:31.030 --> 00:32:33.100
maybe I had a cookbook application.

00:32:33.100 --> 00:32:38.140
I could reuse that same recipe detail
view in my cookbook application.

00:32:38.140 --> 00:32:42.520
And simply by setting the delegate,
I would again notify whoever's listening,

00:32:42.520 --> 00:32:46.070
whoever that delegate object is,
that the recipe has changed and

00:32:46.070 --> 00:32:48.340
update my any data or UI accordingly.

00:32:48.340 --> 00:32:51.610
And of course,
this allows me to reorganize my views.

00:32:51.630 --> 00:32:54.410
Since I don't have a tight
coupling to a parent,

00:32:54.910 --> 00:32:59.710
that is, that I have to know exactly
what its class and structure is,

00:32:59.710 --> 00:33:04.610
I can easily reorganize my
views in my application to take

00:33:04.610 --> 00:33:06.720
advantage of that flexibility.

00:33:08.640 --> 00:33:13.100
So we've talked about
application workflow and UI flow.

00:33:13.100 --> 00:33:16.170
So let's talk about...

00:33:16.340 --> 00:33:20.510
Memory Management No one wants
to talk about memory management.

00:33:20.730 --> 00:33:24.370
It's not that sexy,
but we have to do it every day.

00:33:24.450 --> 00:33:29.050
So first is understanding,
do we even have a memory problem?

00:33:29.230 --> 00:33:32.820
And it's surprising how many
application developers don't even

00:33:32.970 --> 00:33:35.820
know if they do have memory problems.

00:33:35.940 --> 00:33:40.130
So we first need to identify the
problem and look at the tools we

00:33:40.130 --> 00:33:43.460
have to analyze those problems,
and look at models, views,

00:33:43.460 --> 00:33:46.690
and controllers,
and how they can help us debug our

00:33:46.690 --> 00:33:49.380
application if we have memory problems.

00:33:49.900 --> 00:33:54.000
So the first step is understanding
that you do have a problem.

00:33:54.170 --> 00:33:56.790
So how do we know that
we've got memory issues?

00:33:56.790 --> 00:33:59.600
Well, obviously,
you've got intermittent crashes.

00:33:59.600 --> 00:34:02.480
You see crash logs without a backtrace.

00:34:02.480 --> 00:34:05.390
Or surprisingly enough,
lots of developers never

00:34:05.390 --> 00:34:08.680
even check the console,
and you'll see low memory warnings

00:34:08.820 --> 00:34:12.610
in the console from your application
in low memory situations.

00:34:12.610 --> 00:34:14.160
So it's important to look at these.

00:34:14.900 --> 00:34:18.130
So given that we think
we have a memory problem,

00:34:18.350 --> 00:34:22.800
what tools are available for me
to help me debug my memory issues?

00:34:22.800 --> 00:34:25.980
Well, first and most important,
we have instruments.

00:34:25.980 --> 00:34:31.000
And we have two tools inside instruments,
Leaks and Object Alloc.

00:34:31.070 --> 00:34:33.630
And we're not going to
talk at length about this.

00:34:33.630 --> 00:34:37.150
That is talked about in one of the
other optimizing your application

00:34:37.150 --> 00:34:39.610
performance in one of the other sessions.

00:34:40.210 --> 00:34:43.780
But what I want to talk about is
that Leaks will help me find focused

00:34:44.010 --> 00:34:46.230
memory leaks inside my application.

00:34:46.240 --> 00:34:47.850
It's a very powerful tool for doing that.

00:34:47.980 --> 00:34:50.910
And Object Alloc,
which I really like because

00:34:51.230 --> 00:34:55.250
it gives me kind of a memory
footprint of my application.

00:34:55.330 --> 00:34:58.810
It gives you a life cycle
of the memory usage.

00:34:58.840 --> 00:35:03.040
As you're building your application,
you typically know where you're

00:35:03.040 --> 00:35:05.150
using memory very heavily or not.

00:35:05.150 --> 00:35:08.460
And Object Alloc will
show me that footprint.

00:35:09.080 --> 00:35:12.320
And when I see things
going away inside my code,

00:35:12.330 --> 00:35:15.440
I should see that Object Alloc
footprint decreasing.

00:35:15.530 --> 00:35:20.690
So I recommend that users or
developers use these tools at

00:35:20.690 --> 00:35:25.280
least once a week to maintain that

00:35:25.470 --> 00:35:29.400
"We want to make sure that the user
is able to access the interface

00:35:29.400 --> 00:35:31.990
to their application and make
sure that they're not letting

00:35:31.990 --> 00:35:31.990
the memory system get out of hand."

00:35:32.150 --> 00:35:34.220
Secondly, we've got the simulator.

00:35:34.280 --> 00:35:38.780
And it's important to remember that the
simulator can simulate a memory warning.

00:35:38.850 --> 00:35:42.760
And what's powerful about this is
that it's very tough to simulate a

00:35:42.760 --> 00:35:44.890
memory warning on the device itself.

00:35:45.080 --> 00:35:48.340
You don't want to write debug
code that's going to go off and

00:35:48.340 --> 00:35:52.620
allocate memory just to force the
system into a low memory situation.

00:35:52.690 --> 00:35:57.520
Use the simulator to simulate those
low memory conditions and help

00:35:57.520 --> 00:36:00.640
you debug your memory problems.

00:36:00.800 --> 00:36:03.320
And it's important also to
point out that you can use

00:36:03.320 --> 00:36:05.130
instruments with the simulator.

00:36:05.470 --> 00:36:07.410
It's not just bound to the device.

00:36:07.570 --> 00:36:10.870
So you can use instruments, leaks,
and object alloc on the

00:36:10.870 --> 00:36:12.860
simulator as well as the device.

00:36:15.250 --> 00:36:21.160
Also, we now in Snow Leopard, in Xcode,
we have Xcode Static Analysis.

00:36:21.160 --> 00:36:25.760
I really, really want to push you guys
to be using these tools.

00:36:25.760 --> 00:36:29.820
It's only available in Snow Leopard,
but it really helps you resolve

00:36:29.820 --> 00:36:34.060
these retain-release problems that
we see in lots of applications.

00:36:34.580 --> 00:36:38.830
And what's important to point out
here is Xcode Static Analysis.

00:36:38.830 --> 00:36:41.300
You do not have to run your code.

00:36:41.310 --> 00:36:43.320
It simply analyzes your code.

00:36:43.320 --> 00:36:44.780
It doesn't build it.

00:36:44.890 --> 00:36:47.000
It doesn't have to do anything.

00:36:47.000 --> 00:36:48.360
It statically analyzes.

00:36:48.360 --> 00:36:50.440
It's based on the Clang tool.

00:36:50.440 --> 00:36:52.020
It's very powerful.

00:36:52.020 --> 00:36:56.710
But what's important to point out here as
well is that you should trust the tool,

00:36:56.920 --> 00:36:58.710
but you can get false positives.

00:36:58.730 --> 00:37:00.450
You know your code better.

00:37:00.460 --> 00:37:04.400
So you need to verify the
results of the static analysis.

00:37:04.420 --> 00:37:06.840
output.

00:37:06.840 --> 00:37:09.210
Very, very powerful tool.

00:37:10.650 --> 00:37:12.480
Next, we talked about models
of view controllers.

00:37:12.590 --> 00:37:16.530
Well,
how can they help my memory problems?

00:37:16.890 --> 00:37:21.680
First off, view controllers are very
important basic building block,

00:37:21.720 --> 00:37:22.770
as we said, of the application.

00:37:22.920 --> 00:37:25.000
Every application is using these.

00:37:25.120 --> 00:37:29.100
And it's important to remember
that you don't have to cache them.

00:37:29.180 --> 00:37:31.730
They're typically very lightweight,
loaded from a nib,

00:37:31.930 --> 00:37:35.700
and so there's no need to
cache a view controller,

00:37:35.890 --> 00:37:38.690
especially when it's not on screen.

00:37:39.830 --> 00:37:43.650
And the important thing is,
remember that view controllers

00:37:43.880 --> 00:37:45.940
automatically know how to
respond to memory warnings.

00:37:45.940 --> 00:37:50.740
When you instantiate a view controller
from the template inside Xcode,

00:37:50.740 --> 00:37:52.820
you will see this did
receive memory warning.

00:37:52.820 --> 00:37:54.900
This is where you put your code.

00:37:55.160 --> 00:37:59.380
Now, what's important to remember
is that now in iPhone OS 3.0,

00:37:59.380 --> 00:38:03.810
the default behavior for did receive
memory warning is to unload the view

00:38:03.810 --> 00:38:06.640
attached to that view controller.

00:38:07.000 --> 00:38:11.200
And then your view did unload method will
be called automatically by the system.

00:38:11.200 --> 00:38:12.580
This is very important.

00:38:14.020 --> 00:38:17.000
First, it's important to call
superviewDidUnload,

00:38:17.000 --> 00:38:20.520
and then you need to release
any objects that you have

00:38:20.990 --> 00:38:23.210
persistent properties attached to.

00:38:23.220 --> 00:38:26.690
So in this case,
I have a view that I'm holding on to.

00:38:26.700 --> 00:38:30.780
Well, remember that by the time
viewDidUnload is called,

00:38:30.940 --> 00:38:34.060
the context of any subviews is gone,
right?

00:38:34.170 --> 00:38:35.500
Your view has been unloaded.

00:38:35.630 --> 00:38:38.500
So you've just got these little
objects floating out in space.

00:38:38.500 --> 00:38:42.900
You need to make sure that you release
them so that the system can then

00:38:42.900 --> 00:38:45.540
take advantage of that freed memory.

00:38:45.560 --> 00:38:49.440
And what's interesting, again,
is that when memories are covered,

00:38:49.440 --> 00:38:53.650
your viewDidLoad will be called again,
just like the first time you

00:38:53.700 --> 00:38:56.940
call your view controller,
instantiate your view controller,

00:38:56.940 --> 00:38:59.820
and your viewDidLoad code
will be called again,

00:38:59.820 --> 00:39:02.940
and you'll have a chance
to set all these things up,

00:39:03.280 --> 00:39:06.670
and your outlets from
the nib will be restored.

00:39:06.680 --> 00:39:07.960
So you don't have to do anything.

00:39:08.340 --> 00:39:11.520
But you are responsible at
unload time to make sure you

00:39:11.520 --> 00:39:13.510
release any of those outlets.

00:39:16.480 --> 00:39:20.840
Now, how can our model object help
us with memory situations?

00:39:20.840 --> 00:39:26.690
Well, as we pointed out earlier,
it's important to spread that model thin,

00:39:26.800 --> 00:39:27.540
right?

00:39:27.540 --> 00:39:31.670
You want to transfer ownership
of the minimal required data set

00:39:31.670 --> 00:39:33.720
to each of your view systems.

00:39:33.780 --> 00:39:37.220
And core data can really,
really help you with this.

00:39:37.220 --> 00:39:39.660
Because, first of all,
it knows how to load a

00:39:39.660 --> 00:39:41.100
partial object graph.

00:39:41.100 --> 00:39:45.070
Very important in a
tight memory situation.

00:39:46.330 --> 00:39:47.760
Also, it has automatic faulting.

00:39:47.800 --> 00:39:53.260
So it can fault objects in or out
of memory in low memory situations.

00:39:53.260 --> 00:39:56.580
And, of course, it already knows how to
respond to memory warnings.

00:39:56.580 --> 00:40:00.460
So it does the right thing on
its cache and all its data set.

00:40:00.590 --> 00:40:04.790
So, again, you can really take advantage
of core data and simplify your

00:40:04.790 --> 00:40:06.590
application by using that.

00:40:07.820 --> 00:40:11.650
So the takeaway here is
that memory is important,

00:40:11.790 --> 00:40:15.490
and you should be using the tools
frequently to make sure that what

00:40:15.490 --> 00:40:19.110
you are expecting out of your
application is truly happening when

00:40:19.110 --> 00:40:21.630
you're running your application,
that you're seeing the memory

00:40:21.630 --> 00:40:23.070
footprint that you expect.

00:40:23.180 --> 00:40:25.570
And we have the tools
that help you do this,

00:40:25.570 --> 00:40:29.890
but it's also important to make sure
that your architecture takes advantage

00:40:29.890 --> 00:40:35.420
of that and helps you maintain the proper
memory footprint for your application.

00:40:36.200 --> 00:40:38.780
And especially as you go
forward and add features,

00:40:38.780 --> 00:40:42.450
it's definitely important to take
advantage of those situations,

00:40:42.450 --> 00:40:43.690
those frameworks.

00:40:43.700 --> 00:40:49.100
Okay, lastly, we want to talk about
application lifecycle.

00:40:52.930 --> 00:40:54.560
And what do we mean by
application lifecycle?

00:40:54.560 --> 00:40:57.070
Well, we're going to talk about
four important points here.

00:40:57.380 --> 00:41:00.320
Compatibility,
implementation versus calling,

00:41:00.390 --> 00:41:04.570
handling interruptions,
and just a brief bit about concurrency.

00:41:06.990 --> 00:41:07.520
Padability.

00:41:07.650 --> 00:41:12.610
One big issue we see with developers
is that they have namespace collisions.

00:41:12.690 --> 00:41:15.300
Remember in Objective-C,
there is no name mangling

00:41:15.300 --> 00:41:16.430
like there is in C++.

00:41:16.470 --> 00:41:21.870
So it can be easy to bump
into duplicate names and have

00:41:22.280 --> 00:41:26.820
inappropriate behaviors based on that.

00:41:26.990 --> 00:41:29.610
So in this case,
we have our WWDC session object,

00:41:29.610 --> 00:41:32.820
and we have another framework
that's built into the system

00:41:32.910 --> 00:41:34.540
that has a session object.

00:41:35.220 --> 00:41:38.120
We're going to call it
a WWDC session object.

00:41:38.500 --> 00:41:52.090
And in our own application frameworks,
you'll say that GameKit has a GK session,

00:41:52.490 --> 00:42:00.520
and so there's less chance
of a name collision.

00:42:00.540 --> 00:42:02.310
You should definitely take
advantage of that simple

00:42:02.310 --> 00:42:03.500
paradigm as you build your app.

00:42:03.750 --> 00:42:07.180
paradigm as you build your architecture.

00:42:07.710 --> 00:42:11.640
To avoid those namespace collisions.

00:42:11.670 --> 00:42:15.600
Also, for method names,
make sure you avoid underscores.

00:42:17.530 --> 00:42:21.940
Apple reserves the right to have
all private methods use underscores.

00:42:21.940 --> 00:42:23.640
So here's what can happen.

00:42:23.840 --> 00:42:29.780
Say I have this can have cheeseburger
method in my WWDC table view cell,

00:42:29.950 --> 00:42:31.020
this class I'm implementing.

00:42:31.020 --> 00:42:36.560
Well, what happens if there's a private
method in UI table view cell

00:42:36.610 --> 00:42:38.530
called can have cheeseburger?

00:42:38.530 --> 00:42:42.310
Well, you can see that there's an
immediate namespace collision.

00:42:42.310 --> 00:42:45.660
So what happens is if we're running

00:42:46.870 --> 00:42:52.690
That code at runtime in the internal
UI kit is talking to your TableView cell,

00:42:52.720 --> 00:42:57.080
and it says, "Okay, TableView cell,
can I have a cheeseburger?"

00:42:57.810 --> 00:43:03.340
It's going to call our
WWDC table view cells method.

00:43:03.340 --> 00:43:06.530
And of course, this is not what we want,
and this is not what the

00:43:06.790 --> 00:43:08.280
internal frameworks expect.

00:43:08.310 --> 00:43:11.560
So avoid underscores
on your base methods,

00:43:11.600 --> 00:43:15.070
because there might be an
identical private method that

00:43:15.130 --> 00:43:17.420
Apple is using internally.

00:43:17.420 --> 00:43:19.710
And to help you do that,
remember that Xcode has a

00:43:19.710 --> 00:43:23.680
wonderful refactoring tool that
lets you change your IVARs,

00:43:23.680 --> 00:43:26.240
your method names,
your entire class names,

00:43:26.300 --> 00:43:27.380
and will do it automatically.

00:43:27.400 --> 00:43:30.970
No more searching through your
code and textually searching

00:43:30.970 --> 00:43:33.760
and replacing and worrying that
you're going to break something.

00:43:33.760 --> 00:43:37.910
The refactoring tool takes all that into
consideration and will refactor your code

00:43:37.910 --> 00:43:40.990
and your names automatically for you.

00:43:41.650 --> 00:43:44.310
Also,
as part of your application lifecycle,

00:43:44.510 --> 00:43:47.540
it's important to understand
proper code paths.

00:43:47.540 --> 00:43:51.220
I see this time and time again,
that people don't always understand

00:43:51.680 --> 00:43:57.530
that there's a fundamental difference
between implementation versus calling.

00:43:57.550 --> 00:43:59.740
And these are totally different usages.

00:44:00.430 --> 00:44:04.410
Remember, in specific cases,
you implement DrawRect.

00:44:04.410 --> 00:44:06.210
You do not call DrawRect.

00:44:06.410 --> 00:44:08.740
You call SetNeedsDisplay.

00:44:08.740 --> 00:44:10.930
You implement LayoutSubviews.

00:44:11.200 --> 00:44:12.830
You call SetNeedsLayout.

00:44:12.920 --> 00:44:18.790
And remember that things like
LoadView are there not for you to call,

00:44:18.790 --> 00:44:24.230
but for the system to call when
you access the view property.

00:44:24.240 --> 00:44:25.690
You implement LoadView.

00:44:25.690 --> 00:44:27.840
You simply access the view property.

00:44:27.840 --> 00:44:29.130
And by doing that,
your LoadView method is going to

00:44:29.170 --> 00:44:30.040
be able to call the view property.

00:44:30.040 --> 00:44:30.670
And by doing that,
your LoadView method will be called.

00:44:30.680 --> 00:44:34.280
This is very, very important,
especially things like DrawRect.

00:44:34.370 --> 00:44:38.460
When you do call DrawRect directly,
if you try and do that,

00:44:38.460 --> 00:44:42.590
not only will it probably not
give you the desired results,

00:44:42.590 --> 00:44:45.200
it's actually a performance hit.

00:44:45.200 --> 00:44:48.060
I hear people saying, well,
I want the best possible performance,

00:44:48.150 --> 00:44:50.240
so I'm just going to
call DrawRect directly.

00:44:50.240 --> 00:44:55.200
We have a fully composited system,
so you must call SetNeedsDisplay

00:44:55.200 --> 00:44:59.360
to invalidate your UI and
not call DrawRect directly.

00:44:59.720 --> 00:45:02.010
If you call SetNeedsDisplay
a million times,

00:45:02.010 --> 00:45:04.860
that's going to only end
up calling DrawRect once.

00:45:04.860 --> 00:45:06.890
But if you call DrawRect
directly a million times,

00:45:06.890 --> 00:45:08.630
then it's going to
call DrawRect directly,

00:45:08.630 --> 00:45:10.550
and you're going to
have a performance hit.

00:45:10.620 --> 00:45:13.980
Again, we have a modern UI system.

00:45:13.980 --> 00:45:15.850
You'll always prefer invalidation.

00:45:15.860 --> 00:45:17.840
And the same thing for SetNeedsLayout.

00:45:18.080 --> 00:45:22.980
If that just sets a bit that your
subviews need to be laid out,

00:45:22.980 --> 00:45:25.500
and at some point the system
will call you to do the right

00:45:25.500 --> 00:45:27.240
thing with your layout subviews.

00:45:27.340 --> 00:45:30.420
And this is how the...
This is how the phone works,

00:45:30.420 --> 00:45:31.720
and it's a true object-oriented system.

00:45:31.720 --> 00:45:35.300
So you need to be aware about what
you're responsible for implementing for

00:45:35.370 --> 00:45:37.460
what you're responsible for calling.

00:45:40.060 --> 00:45:43.900
Next in the application lifecycle,
we want to talk about interruptions.

00:45:44.110 --> 00:45:48.130
Handling interruptions is very important
on the phone because you don't know

00:45:48.210 --> 00:45:51.590
how you're going to be interrupted
and where they're going to come from.

00:45:51.670 --> 00:45:58.910
Obviously, we have text messages,
phone calls, iCal alerts, clock alarms,

00:45:58.940 --> 00:46:00.780
and now push notifications.

00:46:00.850 --> 00:46:03.880
So it's important that you
know how to handle these,

00:46:03.880 --> 00:46:05.790
and it's very, very simple.

00:46:06.130 --> 00:46:11.110
There's basically three delegate messages
that you need to be responsible for.

00:46:12.190 --> 00:46:14.160
When an interruption occurs,
and in this case,

00:46:14.330 --> 00:46:17.270
I'm getting a phone call,
you need to implement

00:46:17.930 --> 00:46:19.340
Application Will Resign Active.

00:46:19.400 --> 00:46:21.940
Again, you implement
Application Will Resign Active,

00:46:21.940 --> 00:46:24.560
and the system will
call you automatically.

00:46:24.680 --> 00:46:29.650
And this is important for you to pause
and save the state of your application,

00:46:29.650 --> 00:46:32.840
because at this point,
you don't know what's going to happen.

00:46:33.030 --> 00:46:36.530
You've resigned to active status,
but you don't know what

00:46:36.530 --> 00:46:37.980
the user's going to do.

00:46:38.800 --> 00:46:41.360
And let's say in this case,
the user dismisses.

00:46:41.640 --> 00:46:46.740
Then you're responsible for implementing
the application didResumeActive.

00:46:46.860 --> 00:46:50.920
And this will happen if they
dismiss that interruption.

00:46:51.390 --> 00:46:55.670
Now, it's important at this point,
depending on the context

00:46:55.670 --> 00:46:58.340
of your application,
what you want to do.

00:46:58.360 --> 00:47:02.670
We recommend for most applications
that they stay in their pause state.

00:47:02.720 --> 00:47:05.620
Certainly for a game,
you don't want to come back from

00:47:05.620 --> 00:47:08.710
a phone call and automatically,
when you get that application

00:47:08.710 --> 00:47:11.160
did resume active,
start your car again going 90

00:47:11.160 --> 00:47:13.780
miles an hour down the road
and run into a brick wall.

00:47:13.800 --> 00:47:16.830
So it's important to understand,
based on your application,

00:47:16.830 --> 00:47:20.140
what its needs are, what you do when you
get that resume active.

00:47:20.580 --> 00:47:23.880
The iPod application, obviously,
when it gets the did resume active,

00:47:23.880 --> 00:47:27.040
just starts playing the music
again because there's no need for

00:47:27.350 --> 00:47:28.890
the user to interact with that.

00:47:28.980 --> 00:47:30.130
It will just start playing again.

00:47:33.570 --> 00:47:35.730
So we talked about if the user dismisses.

00:47:35.730 --> 00:47:37.580
Now what happens if the user accepts?

00:47:37.580 --> 00:47:41.460
Well, we're going to get our old friend,
application will terminate.

00:47:41.510 --> 00:47:45.570
You're already doing this in your
iPhone application code because this is

00:47:45.570 --> 00:47:47.830
the same as pressing the home button.

00:47:47.830 --> 00:47:50.940
And that's where you can
also save state if you like,

00:47:50.940 --> 00:47:54.260
if you haven't updated your
data on disk at that point.

00:47:54.310 --> 00:47:57.970
But like I said,
this is the same as pressing home button.

00:47:58.030 --> 00:48:02.560
It's important to point out, though,
that this is application will terminate.

00:48:02.570 --> 00:48:03.480
It's not application will terminate.

00:48:03.500 --> 00:48:06.220
Application might terminate
or may I terminate.

00:48:06.560 --> 00:48:08.450
This is application will terminate.

00:48:08.450 --> 00:48:10.440
You must shut down at this point.

00:48:12.750 --> 00:48:15.830
And lastly, I want to just talk
briefly about concurrency.

00:48:15.930 --> 00:48:17.780
I'm going to talk more
about this in Part 2,

00:48:17.780 --> 00:48:21.150
but I just want to touch on it,
what's important here as part of my

00:48:21.150 --> 00:48:23.240
overall application architecture.

00:48:23.240 --> 00:48:28.060
Obviously,
concurrency means performing side tasks.

00:48:28.060 --> 00:48:31.900
And the number one thing that people
want to do is networking tasks.

00:48:31.900 --> 00:48:35.750
But what I want to point out here
is it's really important to use

00:48:35.880 --> 00:48:41.620
asynchronous APIs when they're available,
especially, as I said, for networking.

00:48:43.050 --> 00:48:44.720
Things like NSURL connection.

00:48:44.760 --> 00:48:52.340
You do not want to use a blocking API for
a high latency operation like networking,

00:48:52.360 --> 00:48:53.320
right?

00:48:53.410 --> 00:48:55.920
You don't want to say,
go off and make this

00:48:55.920 --> 00:48:57.840
connection to a web server.

00:48:57.840 --> 00:49:00.650
You don't know if you're
on an edge connection,

00:49:00.650 --> 00:49:01.760
a 3G, Wi-Fi.

00:49:01.760 --> 00:49:04.500
So you want to keep your
application responsive.

00:49:04.500 --> 00:49:08.500
So by using the asynchronous APIs with
these high latency operations,

00:49:08.510 --> 00:49:11.140
we give the best
possible user experience.

00:49:11.140 --> 00:49:15.640
So always prefer those
asynchronous APIs when they're

00:49:15.640 --> 00:49:17.980
available in the system.

00:49:19.940 --> 00:49:23.640
Also, NSOperation,
I'm going to talk about this much,

00:49:23.640 --> 00:49:25.260
much more in Part 2.

00:49:25.260 --> 00:49:27.930
But it's very powerful
for doing side tasks,

00:49:27.930 --> 00:49:32.060
but it should be used for low latency,
high demand operations,

00:49:32.060 --> 00:49:35.340
side tasks that you want
to take advantage of.

00:49:35.400 --> 00:49:38.770
But it's important to remember as
part of the application lifecycle,

00:49:38.770 --> 00:49:41.860
if you're going to do these side tasks,
make sure you illustrate

00:49:41.860 --> 00:49:43.360
any activity to the user.

00:49:44.280 --> 00:49:46.920
Inside UI application,
we have network activity

00:49:46.920 --> 00:49:50.060
indicator visible,
we've got a UI indicator view,

00:49:50.060 --> 00:49:52.200
and we've got UI progress view.

00:49:52.200 --> 00:49:55.740
So just make sure if you're going
to go off and do these side tasks,

00:49:55.740 --> 00:49:59.360
that if you need to,
especially if you're waiting for results,

00:49:59.360 --> 00:50:02.610
you're blocking your application,
that you show that to the user.

00:50:04.500 --> 00:50:07.480
So in summary,
we want to manage our data carefully,

00:50:07.480 --> 00:50:09.820
and it impacts our architecture.

00:50:09.820 --> 00:50:12.940
We want to separate
those responsibilities,

00:50:12.940 --> 00:50:17.300
stay focused one thing at a time,
transfer ownership of data and

00:50:17.300 --> 00:50:22.400
objects so that we can break our
application apart and reuse components.

00:50:23.200 --> 00:50:25.850
We want to conserve memory
by doing those same things,

00:50:25.850 --> 00:50:29.200
breaking apart our application
into smaller and smaller chunks,

00:50:29.200 --> 00:50:32.460
and we want to maintain
that user experience.

00:50:32.460 --> 00:50:35.430
Whether we're focusing on
data or doing side tasks,

00:50:35.430 --> 00:50:38.600
we want to maintain the user
experience and be as dynamic

00:50:38.600 --> 00:50:40.390
and flexible as possible.

00:50:45.620 --> 00:50:47.000
Thanks for watching.

00:50:47.120 --> 00:50:50.140
If you're looking for more
demos or code examples,

00:50:50.280 --> 00:50:53.730
make sure you check out Effective
iPhone Application Architecture,

00:50:53.980 --> 00:50:54.420
Part 2.
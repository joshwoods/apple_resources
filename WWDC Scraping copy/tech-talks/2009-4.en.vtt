WEBVTT

00:00:20.740 --> 00:00:23.540
Hi, I'm Larry Coope, Apple engineer.

00:00:23.540 --> 00:00:27.060
This video builds on Part 1 and
focuses on leveraging system

00:00:27.060 --> 00:00:31.700
technologies to make your application
faster and more responsive.

00:00:31.910 --> 00:00:34.340
Today we're going to talk about
taking the best advantage of

00:00:34.360 --> 00:00:38.600
the OS and the frameworks that
are built into the iPhone OS.

00:00:38.670 --> 00:00:42.960
I want to contrast Part 2 versus
what we talked about in Part 1.

00:00:43.290 --> 00:00:48.600
In Part 1, we talked about code flow and
data in a sort of abstract sense.

00:00:48.660 --> 00:00:51.480
In Part 2 today,
we're going to talk about the

00:00:51.480 --> 00:00:56.300
implementation realities of building
an application and extending

00:00:56.300 --> 00:00:59.510
its functionality day to day.

00:00:59.590 --> 00:01:03.220
So implementation realities.

00:01:03.960 --> 00:01:07.400
And how are they relevant to
an effective architecture?

00:01:07.550 --> 00:01:10.710
Well, we want to talk about specific
areas like UI table view,

00:01:10.960 --> 00:01:14.680
UI image,
adding concurrency with NS operation,

00:01:14.790 --> 00:01:16.840
and working with system view hierarchies.

00:01:16.950 --> 00:01:20.920
And we're going to hopefully
see lots of code along the way.

00:01:22.250 --> 00:01:24.680
If we talk about the title
of this presentation,

00:01:24.680 --> 00:01:27.200
Effective iPhone
Application Architecture,

00:01:27.280 --> 00:01:30.560
what does it mean to have
an effective architecture?

00:01:30.920 --> 00:01:31.880
What makes it effective?

00:01:31.880 --> 00:01:34.850
And for me as an engineer,
I think the number one

00:01:34.850 --> 00:01:36.560
thing is it's flexible.

00:01:36.560 --> 00:01:39.750
It's easy to update and add features to.

00:01:41.480 --> 00:01:47.340
Good architecture leverages the OS,
and that helps it be

00:01:47.520 --> 00:01:49.350
robust and efficient.

00:01:49.410 --> 00:01:52.990
And that ability to leverage
the OS to the fullest is very

00:01:53.130 --> 00:01:56.890
important because it lets you,
as a developer, be lazy.

00:01:56.920 --> 00:02:01.390
Take advantage of the hundreds or
thousands of man-years of code that's

00:02:01.470 --> 00:02:05.480
been built by Apple that's there
for you to take advantage of and do

00:02:05.480 --> 00:02:08.220
your bidding inside your application.

00:02:09.010 --> 00:02:11.400
And to do that,
you really have to have a knowledge

00:02:11.400 --> 00:02:13.100
of the available technologies.

00:02:13.200 --> 00:02:16.870
And this means going deeper every day.

00:02:16.890 --> 00:02:19.820
As you extend your app's functionality
or you build another app,

00:02:20.000 --> 00:02:25.260
you need to make sure that you spend
time understanding these APIs and

00:02:25.450 --> 00:02:30.060
get the proper usage of those
APIs so that you can benefit and

00:02:30.190 --> 00:02:34.450
not have to reinvent the wheel every
time you write your application.

00:02:34.860 --> 00:02:37.970
These things are there for you to use.

00:02:38.610 --> 00:02:43.100
Historically,
I've seen developers spend days or

00:02:43.100 --> 00:02:49.880
even weeks taking time to write code,
and I sit down with them, and I say,

00:02:49.880 --> 00:02:52.980
by the way, do you know that there's a
single function that does that?

00:02:53.040 --> 00:02:56.880
And they can get very upset.

00:02:56.880 --> 00:03:00.390
And we're going to talk about that today,
about understanding the OS and

00:03:00.390 --> 00:03:03.960
making sure that you don't waste
time reworking system plumbing and

00:03:04.010 --> 00:03:07.970
taking advantage of those frameworks
to get the best possible benefit.

00:03:09.330 --> 00:03:10.570
So let's get right to it.

00:03:10.800 --> 00:03:15.360
I want to talk about specific examples
and how they affect your application no

00:03:15.360 --> 00:03:17.930
matter what kind of app you're building.

00:03:18.370 --> 00:03:21.000
So let's talk about UI table view.

00:03:21.050 --> 00:03:24.300
Nearly every app has
at least one of these,

00:03:24.340 --> 00:03:28.080
and they convey a lot of
information to the user.

00:03:28.250 --> 00:03:31.020
But we see some symptoms and
we see some problems with other

00:03:31.020 --> 00:03:32.490
applications in the App Store.

00:03:32.870 --> 00:03:36.800
And the number one being that
their UI table views have some

00:03:36.800 --> 00:03:38.240
scrolling or performance issues.

00:03:38.240 --> 00:03:42.110
So before we can talk about that,
I want to review the

00:03:42.110 --> 00:03:44.260
UI table view structure.

00:03:45.350 --> 00:03:49.260
So as you can see,
there's quite a bit going on inside

00:03:49.260 --> 00:03:51.120
the UI Table View cell structure.

00:03:51.120 --> 00:03:54.860
And of course,
it already starts pretty complex.

00:03:54.920 --> 00:03:58.590
But then when I go into
accessory mode or edit mode,

00:03:58.590 --> 00:04:02.620
I start to see even more
views built into that system.

00:04:04.200 --> 00:04:06.680
And then when we select something,
in fact,

00:04:06.860 --> 00:04:11.140
we insert another background view in
there to show that highlighted state.

00:04:11.150 --> 00:04:13.530
And then, of course,
you as the user of the

00:04:13.530 --> 00:04:16.350
cell in your client app,
you may want to show quite a

00:04:16.350 --> 00:04:18.210
bit of information in there.

00:04:18.220 --> 00:04:19.790
So why does this matter?

00:04:19.790 --> 00:04:24.920
And how is this related to an effective,
performant, efficient architecture?

00:04:24.920 --> 00:04:29.220
Well, it matters because composited
drawing performance.

00:04:30.000 --> 00:04:35.800
It's important to remember that UIKit is
fully and pervasively composited.

00:04:35.800 --> 00:04:40.520
And I want to emphasize that this is
not an opt-in or an opt-out strategy.

00:04:40.520 --> 00:04:43.120
It is a composited system.

00:04:43.120 --> 00:04:46.980
And this significantly impacts how
you write your code because you

00:04:47.060 --> 00:04:49.240
might be in unfamiliar territory.

00:04:49.240 --> 00:04:52.560
If you're coming from other platforms,
this may not be something

00:04:52.810 --> 00:04:54.070
that you're used to.

00:04:54.120 --> 00:04:57.430
And it can have a dramatic ripple
effect throughout the system because

00:04:57.950 --> 00:04:59.860
there is a lot of information in there.

00:04:59.990 --> 00:05:03.590
So what we want to do is that
potential extra step for compositing

00:05:03.610 --> 00:05:05.360
your view into the hierarchy.

00:05:05.550 --> 00:05:10.090
So let's go back to the
UITableView cell as our example.

00:05:10.700 --> 00:05:13.680
And you can see what can
happen is in a complex system,

00:05:13.680 --> 00:05:16.520
a complex view,
not only is the UI complicated,

00:05:16.520 --> 00:05:20.540
but I've actually dramatically
decreased my performance if I'm not

00:05:20.590 --> 00:05:23.160
careful how these things are built.

00:05:23.240 --> 00:05:28.470
So we see in this example that there's
a potential extra composite per

00:05:28.470 --> 00:05:31.500
view in that little table view cell.

00:05:31.500 --> 00:05:35.020
So this, as I talked about,
has a ripple effect because

00:05:35.020 --> 00:05:39.040
composited drawing performance
is important everywhere.

00:05:39.670 --> 00:05:42.080
Even though we're talking
about UI table view cell,

00:05:42.080 --> 00:05:44.580
I want to emphasize we're
talking about general issues.

00:05:44.580 --> 00:05:48.470
And that composite drawing
performance can affect other

00:05:48.470 --> 00:05:50.560
parts of your application.

00:05:50.560 --> 00:05:54.070
I see developers who have
serious performance problems

00:05:54.070 --> 00:05:57.940
in their UI table view cells,
but they don't understand that they

00:05:58.060 --> 00:06:01.460
could get a lot more performance
even in their more static UIs by

00:06:01.460 --> 00:06:03.370
understanding compositing.

00:06:05.330 --> 00:06:10.000
So UI complexity now not only
impacts your user's experience,

00:06:10.000 --> 00:06:13.100
but it impacts performance as well.

00:06:13.100 --> 00:06:17.240
And it's important to remember
that opacity does matter.

00:06:17.280 --> 00:06:22.920
The system can optimize fully opaque
views through a separate drawing path.

00:06:22.980 --> 00:06:26.550
If you're not fully opaque,
then the system will have to

00:06:26.550 --> 00:06:31.280
composite you with your views and may
cause some performance degradation.

00:06:32.700 --> 00:06:34.430
So how do we get around this?

00:06:34.590 --> 00:06:35.390
What do we recommend?

00:06:35.400 --> 00:06:38.480
How do we increase drawing
performance everywhere in the system

00:06:38.480 --> 00:06:40.040
and not just in UI table view cells?

00:06:40.160 --> 00:06:42.160
Well, obviously, simplify.

00:06:42.180 --> 00:06:46.480
We talk about in Part 1 about
staying focused and drill

00:06:46.480 --> 00:06:48.520
down on your UI and data.

00:06:48.760 --> 00:06:52.910
So it's important to do that
here as a performance benefit

00:06:52.910 --> 00:06:55.500
as well as a usability benefit.

00:06:55.800 --> 00:06:58.700
And you can flatten your
drawing with custom views.

00:06:58.700 --> 00:07:00.410
This is something
developers forget about.

00:07:00.420 --> 00:07:03.400
If I have a relatively
flat view hierarchy,

00:07:03.520 --> 00:07:06.500
and in our example,
for my table view cell,

00:07:06.500 --> 00:07:09.320
I've got my little image and
I've got a label underneath it.

00:07:09.390 --> 00:07:13.360
If I know that that is always
going to be presented that way,

00:07:13.430 --> 00:07:15.910
I can put the,
instead of having a UI image

00:07:16.410 --> 00:07:19.670
view and a UI label,
I can put the UI image and the

00:07:19.670 --> 00:07:24.760
NSString in a single custom view
and always draw them in that order,

00:07:25.040 --> 00:07:28.250
and I will encapsulate
not only my UI items,

00:07:28.250 --> 00:07:30.780
but I have one less view to composite.

00:07:30.780 --> 00:07:34.740
And so that will definitely
help me with performance.

00:07:37.500 --> 00:07:41.300
So besides simplifying to
increase drawing performance,

00:07:41.300 --> 00:07:45.080
it may sound trite, but minimize drawing.

00:07:45.140 --> 00:07:48.990
It's important, if you can,
to use things like set needs display

00:07:48.990 --> 00:07:51.200
and rect versus set needs display.

00:07:51.200 --> 00:07:55.090
For complicated view hierarchies,
I can use set needs display

00:07:55.090 --> 00:07:58.640
and rect to tell the system,
oh, I'm just updating this corner.

00:07:58.640 --> 00:08:00.540
I'm only updating this widget.

00:08:00.540 --> 00:08:03.290
So use that judiciously where you can.

00:08:04.310 --> 00:08:06.310
And of course,
you need to respect the rect

00:08:06.670 --> 00:08:09.720
and draw rect where it makes
sense for your application.

00:08:09.720 --> 00:08:13.020
If you know that you can
draw parts of your view,

00:08:13.020 --> 00:08:17.860
then absolutely, you should use set needs
display and rect and draw rect.

00:08:17.960 --> 00:08:20.870
Make sure that you look at that
draw rect because that is going

00:08:20.870 --> 00:08:23.730
to be the dirty rect of your
region that needs to be drawn.

00:08:25.510 --> 00:08:28.770
And also, as we're talking about today,
this is all about understanding the

00:08:28.770 --> 00:08:30.690
OS drawing and updating policies.

00:08:30.700 --> 00:08:35.760
When I see developers
setting view.opaque is no,

00:08:35.760 --> 00:08:38.380
and then I ask them why
are they doing that,

00:08:38.550 --> 00:08:40.240
and they're not sure, that's a problem.

00:08:40.240 --> 00:08:43.010
View.opaque is yes by
default for a reason.

00:08:43.040 --> 00:08:47.600
That makes sure that the system can
take that optimized drawing path

00:08:47.600 --> 00:08:50.360
through the code where it makes sense.

00:08:50.360 --> 00:08:54.560
And as I talked about in Part 1,
never call draw rec directly.

00:08:54.560 --> 00:08:58.930
It's important that this, in this system,
which is a true

00:08:58.930 --> 00:09:02.100
Windows Server-based system,
that you understand that you

00:09:02.350 --> 00:09:03.560
should never call draw rec.

00:09:03.600 --> 00:09:06.910
You should call set needs display
or set needs display in rec.

00:09:06.990 --> 00:09:08.690
That simply sets a bit.

00:09:08.760 --> 00:09:11.660
As I said earlier,
if you call draw rec directly,

00:09:11.660 --> 00:09:14.710
not only will you probably
not draw properly because

00:09:14.710 --> 00:09:17.680
the context isn't set up,
but you're actually taking a

00:09:17.710 --> 00:09:21.550
performance hit because by setting needs
display or set needs display in rec,

00:09:21.600 --> 00:09:23.890
you're simply telling
the system that this,

00:09:24.570 --> 00:09:28.800
this object needs to be invalidated
and drawn at some later time.

00:09:29.020 --> 00:09:32.400
So never call draw rec directly.

00:09:32.920 --> 00:09:35.600
One of the other symptoms we
see in a UI table view cell

00:09:35.670 --> 00:09:36.800
is highlighting problems.

00:09:36.800 --> 00:09:41.850
And again, let's review highlighting and
selection briefly before we go on.

00:09:41.880 --> 00:09:44.340
When we select something
in a UI table view cell,

00:09:44.340 --> 00:09:46.370
there's several things that happen.

00:09:46.380 --> 00:09:52.380
First, we save off the highlighted,
opaque, and background color properties

00:09:52.460 --> 00:09:55.020
of all the views in that system.

00:09:55.020 --> 00:09:59.490
And this is interesting because
highlighted and the set highlighted

00:09:59.490 --> 00:10:02.360
methods are not required by all UI views.

00:10:02.800 --> 00:10:05.250
But if you support it,
we check for that using

00:10:05.250 --> 00:10:08.860
response to selector,
and we save off that state.

00:10:08.900 --> 00:10:12.100
Then we insert that background view.

00:10:12.100 --> 00:10:19.700
Then we set all the views opaque property
and background color and highlight it.

00:10:19.850 --> 00:10:23.440
Opaque is set to no,
background color is set to clear color,

00:10:23.440 --> 00:10:25.840
and the highlighted
state is now set to yes,

00:10:25.840 --> 00:10:28.230
if your view supports
that highlighted method.

00:10:29.500 --> 00:10:33.620
Now, when we deselect,
we start the fade of that selected

00:10:33.620 --> 00:10:36.180
background view that we inserted earlier.

00:10:36.290 --> 00:10:40.980
At the halfway point,
we reset the highlighted state,

00:10:41.560 --> 00:10:45.280
And at the end of the animation,
we reset the opaque and

00:10:45.280 --> 00:10:47.870
background color properties.

00:10:48.030 --> 00:10:50.960
So now that we've reviewed that,
why does this matter?

00:10:51.450 --> 00:10:55.770
It's simply because these highlighting
problems come about because people

00:10:55.770 --> 00:10:58.880
don't understand API compliance.

00:10:59.150 --> 00:11:01.640
Your derived objects should
be aware of what they're

00:11:01.640 --> 00:11:03.380
responsible for implementing.

00:11:03.500 --> 00:11:06.900
And in this particular
case of UITableViewCell,

00:11:07.070 --> 00:11:11.220
you're responsible if you want to
respond to those states to implement set

00:11:11.240 --> 00:11:16.210
highlighted and the highlighted methods
on your objects in your view hierarchy.

00:11:16.490 --> 00:11:20.640
And it's also important to remember
that we're in an object-oriented system.

00:11:20.750 --> 00:11:23.780
So you need to trust
UIKit to do the right thing.

00:11:23.930 --> 00:11:27.130
And for UI table view cells,
I see developers polling

00:11:27.130 --> 00:11:31.110
for the highlighted state,
but there's no need to do that.

00:11:31.430 --> 00:11:35.060
Especially as you saw in our example,
when I'm deselecting the view,

00:11:35.060 --> 00:11:36.910
it's actually an animation state.

00:11:36.950 --> 00:11:39.790
So polling can be highly problematic.

00:11:39.820 --> 00:11:44.550
So you need to understand and trust
UIKit to do the right thing for you

00:11:44.550 --> 00:11:49.370
and tell you what your state is,
and then when you are asked to draw,

00:11:49.370 --> 00:11:51.220
you draw on that state.

00:11:51.280 --> 00:11:55.870
So API compliance is critical to
get the best possible experience

00:11:55.940 --> 00:11:58.140
for your users and your code.

00:11:59.770 --> 00:12:04.140
So we've talked about UI TableViewCell
as an implementation reality

00:12:04.140 --> 00:12:06.300
in building our architecture.

00:12:06.370 --> 00:12:09.190
Now I want to talk about UIImage.

00:12:09.280 --> 00:12:14.240
And unlike UITableViews,
every application uses these.

00:12:14.420 --> 00:12:18.930
Lots of applications use TableViews,
but every application uses UIImage.

00:12:19.100 --> 00:12:25.870
So I want to look at two of the
primary loading APIs inside UIImage.

00:12:26.250 --> 00:12:28.370
Image Named and Image with
Contents of File.

00:12:28.370 --> 00:12:32.200
And what's interesting here
is we're looking at our table,

00:12:32.200 --> 00:12:35.020
is that there's some small
differences and some very big

00:12:35.020 --> 00:12:36.700
differences between the two.

00:12:36.700 --> 00:12:40.240
In Image Named, it takes a simple name
inside your bundle.

00:12:40.280 --> 00:12:44.870
Image with Contents of File takes a full
path to a file that you want to load.

00:12:44.870 --> 00:12:47.740
But here's where the
big differences come in.

00:12:48.500 --> 00:12:49.580
Decompression.

00:12:49.580 --> 00:12:51.540
Image Named is an immediate load.

00:12:51.590 --> 00:12:55.530
That means when you call Image Named,
it goes out to disk, loads that,

00:12:55.740 --> 00:12:58.520
decompresses,
and that image is ready to use right

00:12:58.520 --> 00:13:01.070
now on the return from that function.

00:13:01.080 --> 00:13:04.980
Image with Contents of File, as we say,
is lazily loaded.

00:13:05.230 --> 00:13:09.140
The data is memory mapped in,
but no decompression happens

00:13:09.180 --> 00:13:13.000
unless you actually try and
put that image on screen.

00:13:13.000 --> 00:13:17.220
Also, Image Named is cached by the OS.

00:13:17.820 --> 00:13:19.320
Image with Contents of File is not.

00:13:19.410 --> 00:13:23.600
So every instance of Image with Contents
of File gives me a fresh instance.

00:13:23.600 --> 00:13:29.720
If I call Image Named with
myimage.png a thousand times,

00:13:29.720 --> 00:13:32.660
I'm going to always
get that cached image.

00:13:32.660 --> 00:13:36.880
So there's a big performance win
there by having it in the cache.

00:13:36.880 --> 00:13:43.410
Now under iPhone OS 3.0,
these are both purgeable by the system,

00:13:43.410 --> 00:13:48.380
which means that not the object,
but the backing store,

00:13:48.380 --> 00:13:53.510
the data behind that object,
can be flushed and recovered

00:13:53.530 --> 00:13:54.760
in low memory situations.

00:13:54.760 --> 00:13:58.260
And when memory is recovered,
the system knows how to automatically

00:13:58.260 --> 00:14:00.020
go out and reload that image for me.

00:14:00.020 --> 00:14:03.630
So this is really powerful technology.

00:14:03.920 --> 00:14:09.290
So how is this relevant
to our session today?

00:14:09.440 --> 00:14:13.140
Well,
simply by choosing the appropriate API,

00:14:13.200 --> 00:14:16.240
I can get dramatic behavior
changes in my application.

00:14:16.240 --> 00:14:21.990
So based on the application context,
it's important to understand the behavior

00:14:22.400 --> 00:14:25.300
of these very frequently used APIs.

00:14:26.840 --> 00:14:30.420
So let's talk about how we
use image name properly,

00:14:30.440 --> 00:14:35.100
given the differences between image
named and image with contents of file.

00:14:35.140 --> 00:14:38.200
Certainly,
we want to use it for UI components that

00:14:38.200 --> 00:14:41.830
we're using frequently inside the system.

00:14:41.990 --> 00:14:44.430
Button backgrounds,
in our table view cells,

00:14:44.430 --> 00:14:47.290
any edit accessory views,
anything like that that you're

00:14:47.290 --> 00:14:48.540
going to use frequently.

00:14:48.540 --> 00:14:52.010
But also it's important to
remember what not to do,

00:14:52.280 --> 00:14:56.010
and that means try to avoid
too many of these in one spot.

00:14:56.060 --> 00:15:00.720
Especially in inside application did
finish launching or view did load,

00:15:01.020 --> 00:15:04.080
or can it dramatically
affect the load times.

00:15:04.080 --> 00:15:06.310
Remember, these are blocking loads.

00:15:06.320 --> 00:15:08.370
Everything has to be prepared every time.

00:15:08.380 --> 00:15:12.800
So this can dramatically slow down your
app or view loading if you're trying to

00:15:12.800 --> 00:15:16.330
load these in a loop or as a large set.

00:15:16.560 --> 00:15:18.110
So just be aware of that.

00:15:19.740 --> 00:15:23.980
And it's important to point out
that iPhone OS itself uses image

00:15:23.980 --> 00:15:25.720
name to load nib-referenced images.

00:15:25.720 --> 00:15:27.290
Just be aware of that.

00:15:27.520 --> 00:15:31.500
If you've got, you know,
lots of complicated UI with

00:15:31.500 --> 00:15:34.700
lots of image backgrounds,
you may want to break that up into

00:15:34.700 --> 00:15:36.540
separate nibs to speed up loading.

00:15:39.850 --> 00:15:42.000
Using image with contents of file.

00:15:42.110 --> 00:15:45.810
Well, obviously, this,
since it's not cached,

00:15:45.860 --> 00:15:51.090
this should be used for any images
that will not be needed immediately.

00:15:51.600 --> 00:15:53.660
Obviously, you know,
used infrequently or rarely.

00:15:53.680 --> 00:15:58.810
So the important point to point out here
is if you're going to put up an image

00:15:58.810 --> 00:16:03.520
in a view that comes up infrequently,
you absolutely want to use image

00:16:03.520 --> 00:16:07.670
with contents of file because I don't
want to use image name in that case

00:16:07.670 --> 00:16:11.860
because I want to avoid putting
image pressure on the image cache.

00:16:12.880 --> 00:16:16.560
Lawrence Coope I have the image cache
dump out a frequently used image

00:16:16.640 --> 00:16:18.350
for one that's almost never used.

00:16:18.350 --> 00:16:21.910
So it's important to use image
with contents of file to make

00:16:21.910 --> 00:16:25.940
sure you do not put unnecessary
cache pressure on the system.

00:16:27.490 --> 00:16:32.720
Obviously, since this image with contents
of file takes a full path,

00:16:32.730 --> 00:16:36.390
this is used for all
non-resource bundle images,

00:16:36.510 --> 00:16:39.040
anything outside your bundle.

00:16:39.250 --> 00:16:42.950
But remember that I can use
it for bundle resources.

00:16:43.250 --> 00:16:44.120
It's pretty trivial.

00:16:44.120 --> 00:16:48.490
You can see in one line of code
here how I can get a resource path,

00:16:48.570 --> 00:16:53.150
a full path,
to any image inside my bundle so I can

00:16:53.230 --> 00:16:58.150
put my rarely used images inside my
bundle and have direct access to them,

00:16:58.210 --> 00:17:00.970
but I can load them
lazily anytime I want.

00:17:01.050 --> 00:17:05.260
So you are free to use image with
contents file for your resource-based

00:17:05.260 --> 00:17:07.270
images as well as image named.

00:17:08.990 --> 00:17:12.300
So let's not forget what
UI image is wrapping.

00:17:12.340 --> 00:17:14.140
Under the hood, it's CG image.

00:17:14.210 --> 00:17:17.780
And CG image is part of the
core graphics framework.

00:17:17.920 --> 00:17:22.160
And CG, core graphics in general,
provides a very deep,

00:17:22.440 --> 00:17:25.090
wide set of functionality.

00:17:25.270 --> 00:17:27.200
Remember I said earlier
that there's hundreds,

00:17:27.200 --> 00:17:30.540
if not thousands,
of manures inside these frameworks,

00:17:30.610 --> 00:17:34.280
and we want you to take the
best advantage of these.

00:17:34.300 --> 00:17:36.740
And this is a common iPhone OS theme.

00:17:36.880 --> 00:17:40.790
We provide these very powerful,
lightweight wrappers that

00:17:40.790 --> 00:17:44.660
encapsulate this incredible
technology under the hood.

00:17:45.880 --> 00:17:51.640
And those wrappers provide trivial access
to and from the underlying components.

00:17:51.700 --> 00:17:53.670
In this case,

00:17:54.240 --> 00:17:57.900
It's one line to get the
CG image out of that UI image.

00:17:57.960 --> 00:18:01.380
Then it's available to you to drop
down into the core graphics layer

00:18:01.380 --> 00:18:05.730
and do all sorts of interesting
things with those images.

00:18:06.420 --> 00:18:10.480
And inversely, it's also trivial,
one line again,

00:18:10.690 --> 00:18:14.320
to go from the CG image to a UI image,
which is expected

00:18:14.320 --> 00:18:15.760
everywhere inside UIKit.

00:18:15.980 --> 00:18:17.730
That's the component,
that's the object that

00:18:17.730 --> 00:18:18.870
you need to pass around.

00:18:18.880 --> 00:18:22.200
So it's easy, given that you've
manipulated your CG image,

00:18:22.430 --> 00:18:24.440
to go back and generate a UI image.

00:18:29.130 --> 00:18:32.340
So looking back at our agenda,
we've talked about UI image.

00:18:32.380 --> 00:18:34.840
Now we want to talk about
my favorite subject,

00:18:34.930 --> 00:18:37.900
adding concurrency with NSOperation.

00:18:38.290 --> 00:18:41.090
But first, what, why, where, how?

00:18:41.100 --> 00:18:42.220
What is concurrency?

00:18:42.220 --> 00:18:45.790
Obviously, this is doing more than
one thing at a time.

00:18:48.810 --> 00:18:51.460
We call it multi-threading
or simply threading.

00:18:51.510 --> 00:18:54.660
But I get a lot of questions
about why do I need to even

00:18:54.660 --> 00:18:56.630
bother with this technology?

00:18:56.820 --> 00:19:02.410
It's important because we want to keep
the UI as responsive as we can and

00:19:02.410 --> 00:19:07.090
to leverage idle system resources,
especially the CPU.

00:19:07.630 --> 00:19:13.100
And this is important even on
single core processor machines.

00:19:13.110 --> 00:19:15.840
You can definitely get a
dramatic performance win,

00:19:15.840 --> 00:19:19.040
as you'll see in my demo later,
even on a single core by using

00:19:19.040 --> 00:19:21.400
multithreading and NS operation.

00:19:24.290 --> 00:19:27.670
But we often have to talk about
where can I take advantage

00:19:28.220 --> 00:19:29.360
of concurrency and threading?

00:19:29.400 --> 00:19:33.400
Well, obviously,
any intensive computation.

00:19:33.400 --> 00:19:38.820
You don't want to block the user
experience in the UI because you need

00:19:38.820 --> 00:19:44.840
to go off and calculate some data set,
or you need to parse some incoming XML,

00:19:44.840 --> 00:19:48.520
or you're going to do some image
manipulations on the phone.

00:19:48.520 --> 00:19:52.480
You don't want to block those
operations in a synchronous way.

00:19:53.540 --> 00:19:55.640
Also, any sort of significant disk I.O.

00:19:55.640 --> 00:19:57.630
can really benefit from threading.

00:19:59.250 --> 00:20:01.700
And accessing large data sets, of course.

00:20:01.740 --> 00:20:03.650
And I want to point out non-uniform data.

00:20:03.650 --> 00:20:09.530
Non-uniform data like image data,
where I don't know the compression rate,

00:20:09.590 --> 00:20:16.370
the size of the images, I don't have,
you know, an order N computation here.

00:20:16.380 --> 00:20:19.140
I don't know how long each
operation is going to take.

00:20:19.140 --> 00:20:21.920
So this is really where you
can benefit from threading.

00:20:21.980 --> 00:20:25.780
Of course, importing data as well,
which is another significant

00:20:25.780 --> 00:20:27.130
disk IO operation.

00:20:28.760 --> 00:20:30.840
But when I talk about
where to take advantage,

00:20:30.930 --> 00:20:34.130
it's important to point out that
you instrument your code before you

00:20:34.130 --> 00:20:36.210
decide if threading is right for you.

00:20:36.220 --> 00:20:39.220
Concurrency isn't always a win.

00:20:39.220 --> 00:20:43.120
You must make sure that you give
the system enough work to do.

00:20:43.120 --> 00:20:46.870
I don't want to instantiate a
thread and incur all that overhead

00:20:46.870 --> 00:20:48.820
just to add A plus B together.

00:20:48.820 --> 00:20:52.460
So you need to make sure first that the
granularity of your problem is correct,

00:20:52.540 --> 00:20:56.020
that you have enough work for
that NS operation to do that

00:20:56.320 --> 00:20:58.330
task to make it beneficial.

00:20:58.600 --> 00:20:59.620
Thank you.

00:21:00.810 --> 00:21:03.770
So just as important about
talking where to take advantage,

00:21:03.960 --> 00:21:06.070
we need to talk about
where to avoid concurrency.

00:21:06.070 --> 00:21:08.880
And the number one problem
area is networking.

00:21:08.880 --> 00:21:12.660
Remember, these networking operations
are very high latency.

00:21:12.660 --> 00:21:17.270
We don't want to use the full power of
the CPU to spend time waiting for our

00:21:17.270 --> 00:21:19.750
data to come down from the network.

00:21:19.820 --> 00:21:25.240
And for those networking situations,
we have built-in asynchronous APIs where

00:21:25.240 --> 00:21:30.090
the system will handle that concurrency
for you as part of its run loop.

00:21:31.700 --> 00:21:34.070
And it's important when
you're doing these networking

00:21:34.070 --> 00:21:36.270
operations to avoid blocking.

00:21:36.300 --> 00:21:40.940
You want to avoid these synchronous
API calls that will leave your users

00:21:40.940 --> 00:21:43.960
waiting for their data to be downloaded.

00:21:45.380 --> 00:21:47.970
Example,
NSData has a knit with contents of URL.

00:21:47.970 --> 00:21:50.980
If you call that directly,
the system is going to block while

00:21:51.040 --> 00:21:53.320
it's waiting for that data to download.

00:21:53.320 --> 00:21:56.500
The asynchronous APIs will let
you get around that and avoid

00:21:56.650 --> 00:21:58.350
those blocking situations.

00:22:01.050 --> 00:22:02.390
reachability.

00:22:02.610 --> 00:22:06.320
It also has asynchronous APIs that
you should use that prevent you

00:22:06.320 --> 00:22:09.280
from blocking the user's experience.

00:22:09.740 --> 00:22:15.200
And one of my favorite areas,
don't use concurrency and threading

00:22:15.200 --> 00:22:18.880
for idle behaviors or idle operations.

00:22:19.070 --> 00:22:21.960
We have much better
constructs that can be used.

00:22:22.470 --> 00:22:23.560
Like NS-Timer.

00:22:23.760 --> 00:22:26.730
Don't use threading for idle behaviors.

00:22:27.140 --> 00:22:31.240
Remember, NS-Timer gives you this nice
regular heartbeat into the

00:22:31.240 --> 00:22:33.800
system and it's very easy to use.

00:22:33.920 --> 00:22:37.920
And there's no reason to use threading
in that particular situation.

00:22:40.240 --> 00:22:43.090
So historically,
the challenge has been with

00:22:43.090 --> 00:22:47.180
threading that threading has
always been kind of hard.

00:22:47.340 --> 00:22:52.800
And as I say, I think it's really hard,
especially when you talk about

00:22:52.800 --> 00:22:58.850
managing your state of your
application and its data across

00:22:58.850 --> 00:23:00.950
multiple threads in a shared way.

00:23:00.950 --> 00:23:04.450
This becomes very difficult.

00:23:04.930 --> 00:23:09.800
And the interesting thing is iPhone
OS and NS Operation make it a lot easier.

00:23:09.800 --> 00:23:11.360
And you're going to see how in a minute.

00:23:12.850 --> 00:23:16.850
How do we simplify
concurrency using NSOperation?

00:23:17.230 --> 00:23:23.420
The most important thing is keep
object access confined to one thread.

00:23:23.500 --> 00:23:25.760
One object, one thread.

00:23:25.830 --> 00:23:31.420
This is absolutely the safest pattern
for implementing concurrency in your app.

00:23:31.700 --> 00:23:35.690
Then you can forget about locking,
signaling, sync points, mutexes,

00:23:35.690 --> 00:23:36.580
semaphores.

00:23:36.580 --> 00:23:40.480
All these things that are highly
problematic for a traditional

00:23:40.480 --> 00:23:42.160
threading model go away.

00:23:43.670 --> 00:23:49.270
An NSOperation and NSOperationQ provide
this one-to-one mapping,

00:23:49.270 --> 00:23:54.580
one object, one thread,
this very safe pattern for concurrency.

00:23:57.110 --> 00:24:00.500
So let's talk about NSOperation.

00:24:00.510 --> 00:24:04.980
And I feel it's compelling
object-oriented encapsulation.

00:24:04.990 --> 00:24:11.110
NSOperation provides everything you
need for implementing that task.

00:24:11.820 --> 00:24:15.440
It encapsulates your code and your data,
your state.

00:24:15.500 --> 00:24:20.600
You can query for if it's executing,
it's finished, has it been canceled.

00:24:20.600 --> 00:24:25.390
And it allows you to set up
dependencies between operations.

00:24:25.400 --> 00:24:30.500
I can tell the system in a single
operation queue I want this operation

00:24:31.110 --> 00:24:34.060
to depend on this other operation.

00:24:34.060 --> 00:24:38.720
That means that this other operation
must finish first before the previous

00:24:39.110 --> 00:24:41.570
operation will even begin to execute.

00:24:41.990 --> 00:24:43.480
very, very powerful stuff.

00:24:44.840 --> 00:24:47.990
And I can set priority in my queue.

00:24:47.990 --> 00:24:51.480
So I can put arbitrary
operations on the queue and say,

00:24:51.480 --> 00:24:54.520
I want this one to have a high priority
and this one to have a low priority.

00:24:54.520 --> 00:24:57.480
And the system handles all this for me.

00:24:59.120 --> 00:25:03.750
And the thing I love about NSOperation
and NSOperationQ is it's really

00:25:03.750 --> 00:25:05.740
easy to add to existing code.

00:25:05.760 --> 00:25:09.550
Sure, you have to refactor your
existing functionality,

00:25:09.550 --> 00:25:11.790
but that's always a good thing.

00:25:11.800 --> 00:25:15.970
I always talk about factoring your code
to make it more flexible and reusable.

00:25:15.980 --> 00:25:19.750
And by using NSOperation,
it kind of pushes you in that

00:25:19.750 --> 00:25:22.440
direction of factoring your code.

00:25:22.880 --> 00:25:26.420
And again,
the heavy lifting is all done for me,

00:25:26.420 --> 00:25:29.550
and you'll see in the demo how
easy it is to use NSOperation.

00:25:31.620 --> 00:25:35.040
Also, for NSOperation Queue
and its encapsulation,

00:25:35.190 --> 00:25:39.570
it provides all the things that you
would want in a queue-based system.

00:25:39.650 --> 00:25:42.500
I can suspend or resume the queue.

00:25:42.640 --> 00:25:46.820
And I can trivially change the number
of concurrent active operations,

00:25:46.850 --> 00:25:51.350
so I can throttle up or throttle down how
much load I want to put on the system.

00:25:51.350 --> 00:25:52.960
Very, very interesting.

00:25:56.700 --> 00:25:59.200
So NSOperation and NSOperationQ.

00:25:59.250 --> 00:26:03.600
They're very easy, but yes,
you still have to write code.

00:26:03.650 --> 00:26:07.050
You subclass NSOperation
and override one method,

00:26:07.370 --> 00:26:07.690
main.

00:26:07.690 --> 00:26:11.280
Now typically, of course,
you'll override, you'll have a designated

00:26:11.280 --> 00:26:15.130
initializer that you'll provide,
and you'll typically override DLAC.

00:26:15.130 --> 00:26:17.440
But main is really the workhorse.

00:26:17.440 --> 00:26:19.260
That's all you have to do.

00:26:20.830 --> 00:26:24.760
You create the operation and you give
it the data it needs to do its work.

00:26:24.760 --> 00:26:28.520
Again, we're talking about transferring
ownership of the data.

00:26:28.520 --> 00:26:31.890
Do not share data.

00:26:31.890 --> 00:26:34.390
You transfer the ownership of that.

00:26:34.600 --> 00:26:36.700
You pass the array it's going to work on.

00:26:36.700 --> 00:26:39.130
You pass that XML data
into the operation.

00:26:39.130 --> 00:26:41.380
You do not share it between objects.

00:26:43.330 --> 00:26:46.450
You create an NSOperationQueue
and add your operations to it.

00:26:46.610 --> 00:26:50.590
You never, ever have to over or
subclass NSOperationQueue.

00:26:50.590 --> 00:26:52.400
Only NSOperation.

00:26:52.400 --> 00:26:55.860
When the operation finishes,
you simply use the result.

00:26:56.030 --> 00:26:58.000
So I have a slide here,
which will show us

00:26:58.180 --> 00:26:59.760
concurrency illustrated.

00:27:00.760 --> 00:27:03.670
First, we're going to create,
here's some code, we're going to create

00:27:03.670 --> 00:27:04.960
our NSOperationQueue.

00:27:04.960 --> 00:27:07.500
I have my alloc and init.

00:27:07.500 --> 00:27:09.170
And in this case,
I'm going to set the queue

00:27:09.260 --> 00:27:10.440
immediately to suspended.

00:27:10.500 --> 00:27:13.310
By default, queues are always running.

00:27:13.380 --> 00:27:15.430
But for this example,
I want to show you that

00:27:15.430 --> 00:27:18.000
we can suspend the queue,
and then we're going to start

00:27:18.000 --> 00:27:19.470
building our operations.

00:27:19.470 --> 00:27:23.900
And this is code pretty much right out
of my demo code that's going to try

00:27:23.900 --> 00:27:26.500
and load and scale an image on the fly.

00:27:27.800 --> 00:27:31.650
So my load operation is my
subclassed operation object,

00:27:31.780 --> 00:27:33.080
that subclassed from NSOperation.

00:27:33.080 --> 00:27:37.260
I have my own designated initializer
called init with path colon.

00:27:37.260 --> 00:27:39.100
I'm going to create that operation.

00:27:39.100 --> 00:27:43.780
I'm going to set myself as the delegate,
and we'll see why that's important later.

00:27:43.780 --> 00:27:46.660
And then I'm going to
add myself to the queue,

00:27:46.660 --> 00:27:49.670
and I'm going to release
my operation because,

00:27:49.810 --> 00:27:53.090
of course, the queue,
like all good Cocoa objects,

00:27:53.090 --> 00:27:57.210
is going to retain that object
since it needs to hold onto it.

00:27:58.870 --> 00:28:03.160
And you can see that the objects
start to pile up in the queue,

00:28:03.160 --> 00:28:06.810
and then I'm going to set that
queue to set suspended to no.

00:28:06.820 --> 00:28:09.550
So now I'm going to see,
I see my animation go,

00:28:09.550 --> 00:28:13.320
and I see my objects,
my operations moving through the queue,

00:28:13.320 --> 00:28:16.100
being allocated to a thread,
and being executed.

00:28:16.100 --> 00:28:19.030
Now again, this is the code.

00:28:19.040 --> 00:28:22.550
I do not have to do any of
that plumbing work myself.

00:28:22.560 --> 00:28:25.070
This is all handled for me by the system.

00:28:25.130 --> 00:28:26.350
Very fantastic.

00:28:30.540 --> 00:28:32.300
So, the next step.

00:28:32.530 --> 00:28:34.580
You say, great, Larry,
I've done all this work.

00:28:34.580 --> 00:28:36.620
I've created a subclass
in this operation.

00:28:36.620 --> 00:28:39.510
How do I know when the operation's done?

00:28:39.510 --> 00:28:41.440
Well, the beauty is that's up to you.

00:28:41.490 --> 00:28:43.340
But I like to use delegation.

00:28:43.340 --> 00:28:45.870
Again, delegation,
which we see pervasively

00:28:45.870 --> 00:28:47.580
used throughout the system.

00:28:47.580 --> 00:28:53.160
And I like delegation, again,
because I get to define the protocol.

00:28:53.160 --> 00:28:57.330
I get to define my delegate protocol
that I'm asking my delegates to

00:28:57.330 --> 00:28:59.790
implement so I can call them easily.

00:29:01.660 --> 00:29:03.300
I can also use notification.

00:29:03.450 --> 00:29:05.480
Again,
delegation is great for one-to-one,

00:29:05.480 --> 00:29:07.870
and notification is
great for one-to-many.

00:29:07.870 --> 00:29:09.170
But that's up to me.

00:29:09.170 --> 00:29:10.440
That's my choice.

00:29:10.440 --> 00:29:13.520
In this example, in the demo,
in the code you're seeing today,

00:29:13.520 --> 00:29:14.880
I'm using delegation.

00:29:18.480 --> 00:29:21.670
And it's important to point out that
you're going to see the usage of perform

00:29:21.670 --> 00:29:25.680
selector on main thread colon with
object colon wait until done colon.

00:29:25.680 --> 00:29:32.220
This is used because typically
most operations perform some tasks,

00:29:32.220 --> 00:29:35.490
calculate some values that are
going to be used inside your UI.

00:29:35.500 --> 00:29:39.700
And UIKit can only be safely
used on the main thread.

00:29:39.720 --> 00:29:44.060
Perform selector on main thread is
used to move execution to that main

00:29:44.060 --> 00:29:46.140
thread so I can do UI updating.

00:29:46.140 --> 00:29:50.930
And you'll see how that's used
very simply in the demo code.

00:29:53.300 --> 00:29:56.160
Again,
we're going to move execution to the

00:29:56.160 --> 00:29:58.600
main UI kit thread to do UI updating.

00:29:58.600 --> 00:30:01.190
It's very important to remember that.

00:30:01.680 --> 00:30:06.110
So, we've talked about that concurrency,
but why is this in a discussion

00:30:06.110 --> 00:30:08.320
about architectural relevance?

00:30:08.420 --> 00:30:12.410
I think it's very important
because as we move forward with

00:30:12.420 --> 00:30:17.490
these very modern OSs and devices,
it's important that we remove the

00:30:17.490 --> 00:30:20.440
traditional sequential code flow.

00:30:20.870 --> 00:30:23.340
You see it already with
your application delegates.

00:30:23.340 --> 00:30:25.080
Application did finish launching.

00:30:25.080 --> 00:30:26.580
Application will terminate.

00:30:26.670 --> 00:30:27.670
You don't call those.

00:30:27.670 --> 00:30:28.950
The system is calling you.

00:30:28.950 --> 00:30:33.150
So, you already are starting to
break up your code flow based

00:30:33.200 --> 00:30:35.630
on someone might or may call me.

00:30:35.640 --> 00:30:39.760
And the idea that we remove these
dependencies on sequential code flow

00:30:39.760 --> 00:30:44.260
and break our code up using NSOperation
is a very powerful design pattern.

00:30:44.260 --> 00:30:48.240
We get a much more modern,
much more flexible, much more dynamic

00:30:48.240 --> 00:30:52.360
architecture that lets me,
again, reuse these components day to day.

00:30:52.360 --> 00:30:57.580
And as I talked about,
since you're forced to refactor

00:30:57.580 --> 00:31:01.550
your code into this new paradigm,
you get automatic code factoring,

00:31:01.550 --> 00:31:03.810
which I said,
we want to break those things down

00:31:03.810 --> 00:31:09.430
into smaller and smaller chunks of code
that makes our code much more reusable.

00:31:09.680 --> 00:31:12.690
So now I'm going to show you
a demo on concurrency using

00:31:12.690 --> 00:31:14.830
NSOperation and NSOperationQ.

00:31:16.620 --> 00:31:19.700
Let's look at NSOperation and
NSOperation Queue in Action.

00:31:19.830 --> 00:31:23.580
What I've got is a simple little
app here that displays a table view.

00:31:23.700 --> 00:31:26.070
And in the table view is a set of images.

00:31:26.190 --> 00:31:29.420
Now these images are a bit different
because they're quite large.

00:31:29.560 --> 00:31:35.080
1024x768, some are 1600x1200, 900x600.

00:31:35.210 --> 00:31:39.370
And you can see if I try and scroll that,
that it's not really scrolling.

00:31:39.600 --> 00:31:42.900
If I flick, I don't really scroll,
I jump.

00:31:43.010 --> 00:31:47.600
And the user experience
is not very interesting.

00:31:47.790 --> 00:31:50.490
So I have a little button here
that's just going to turn on a

00:31:50.490 --> 00:31:53.260
switch that's going to let me
use NS Operations internally.

00:31:53.260 --> 00:31:58.060
And all of a sudden you see this
very different user experience.

00:31:58.060 --> 00:32:03.030
I can go up and down,
and since I'm seeing my text dynamically,

00:32:03.080 --> 00:32:04.900
I can move very fast.

00:32:04.920 --> 00:32:07.530
And you see those images load lazily.

00:32:07.540 --> 00:32:09.370
And in fact,
you saw there that they don't

00:32:09.370 --> 00:32:12.340
even come in sequence because
I don't care about the sequence.

00:32:12.340 --> 00:32:14.260
They're just loaded on demand.

00:32:15.960 --> 00:32:18.950
And so, and in fact,
I can scroll and just wait here,

00:32:18.950 --> 00:32:22.920
and you can see that while scrolling,
those are being loaded

00:32:23.280 --> 00:32:24.830
and indeed coming in.

00:32:24.830 --> 00:32:27.060
And so I have a very
nice user experience.

00:32:27.060 --> 00:32:29.940
Now, in a normal app,
you'd probably cache these once

00:32:29.940 --> 00:32:32.100
these were built to the proper size.

00:32:32.100 --> 00:32:36.730
But what I can do here is I can show
you that I can do really interesting

00:32:36.730 --> 00:32:41.590
behaviors now in my app since I'm
not restricted by UI constraints.

00:32:41.620 --> 00:32:43.540
I don't have to worry about those.

00:32:43.540 --> 00:32:45.400
So these are all being
done in the background.

00:32:45.800 --> 00:32:47.650
And I get a great experience.

00:32:47.650 --> 00:32:50.550
And in fact,
I can turn on the clear background,

00:32:50.550 --> 00:32:54.400
and you can see that compositing
performance is still excellent

00:32:54.400 --> 00:32:58.700
because all my real work is done
in the background on NS operation.

00:32:58.700 --> 00:33:01.380
And you can see those come in,
and I get really,

00:33:01.380 --> 00:33:04.260
and you can see they just
jump in right there for me,

00:33:04.260 --> 00:33:06.940
and I don't have to stop doing anything.

00:33:06.940 --> 00:33:10.140
And if I want,
I can even put a gradient in there

00:33:10.140 --> 00:33:12.860
and change the size again on the fly.

00:33:12.860 --> 00:33:15.560
And you can see I still
have excellent performance.

00:33:15.560 --> 00:33:17.540
There's a lot of
compositing going on there.

00:33:17.550 --> 00:33:22.010
But since I'm doing all my heavy work on
a background thread inside NS operation,

00:33:22.010 --> 00:33:23.780
it's really, really great.

00:33:26.300 --> 00:33:27.280
See those load lazily.

00:33:27.280 --> 00:33:29.630
Let's go to the code.

00:33:29.700 --> 00:33:30.750
See how we do that.

00:33:33.720 --> 00:33:37.160
All right, let's look at the code
for NSOperationTest.

00:33:37.190 --> 00:33:39.630
And you see,
it looks like there's a lot of code.

00:33:39.640 --> 00:33:41.080
There really is not.

00:33:41.090 --> 00:33:46.310
This ImageHelper class is just for
doing some of the scaling operations.

00:33:46.480 --> 00:33:48.660
And we can look at that real quick.

00:33:48.680 --> 00:33:53.660
And this creates a CG image
from our UI image scaled.

00:33:53.840 --> 00:33:55.850
It's very,
very straightforward code here.

00:33:55.890 --> 00:33:57.740
It's very simplistic.

00:33:57.810 --> 00:34:00.360
But the important thing we
want to look at is our table

00:34:00.360 --> 00:34:02.220
view and our NSOperationTest.

00:34:02.220 --> 00:34:04.960
So here's my test view controller.

00:34:05.020 --> 00:34:08.980
And what that does is it's
a table view controller.

00:34:08.980 --> 00:34:12.980
It's the data source and the
delegate for the table view.

00:34:13.140 --> 00:34:15.940
So in our standard
self-heroid index path,

00:34:15.990 --> 00:34:17.580
we're being a good citizen.

00:34:17.580 --> 00:34:20.990
We're always trying to recycle
existing table view cells.

00:34:21.190 --> 00:34:22.920
So I try to dequeue one here.

00:34:23.250 --> 00:34:25.340
And if I don't, I create a new one.

00:34:25.380 --> 00:34:28.710
And this setup cell simply handles
the case where I'm using a clear

00:34:28.710 --> 00:34:30.290
background or a gradient view.

00:34:30.420 --> 00:34:31.350
That's all it does.

00:34:31.490 --> 00:34:33.550
It's not pertinent to the example.

00:34:33.710 --> 00:34:38.580
And all I do is I say I request
image for index and text for index.

00:34:38.860 --> 00:34:42.750
And this simply goes into my
data model code and pulls out the

00:34:42.830 --> 00:34:44.250
text for the name of the image.

00:34:44.380 --> 00:34:49.280
So let's look at the important guy here,
request image for index.

00:34:49.510 --> 00:34:52.730
So if we look at that,
here's my image state object.

00:34:52.760 --> 00:34:54.750
This is my model object.

00:34:54.840 --> 00:34:56.920
It's a very trivial object.

00:34:56.980 --> 00:34:58.270
And here it is.

00:34:58.270 --> 00:35:01.940
It has a path, a boolean,
whether it has an image or not,

00:35:01.940 --> 00:35:05.060
and whether the operation
is queued or not.

00:35:05.090 --> 00:35:06.560
These two are booleans.

00:35:06.560 --> 00:35:07.600
This is a string.

00:35:07.600 --> 00:35:10.160
That's the path to the
image I want to load.

00:35:10.160 --> 00:35:14.160
And you can see my implementation,
I literally only have a DL method.

00:35:14.240 --> 00:35:19.380
So the rest is done by using
properties on the image.

00:35:19.400 --> 00:35:21.820
And that's my model object.

00:35:21.820 --> 00:35:26.400
It holds the path and whether
I have a queued operation and

00:35:26.570 --> 00:35:29.730
whether the image has been loaded.

00:35:29.730 --> 00:35:35.060
So if I'm not using operations,
I simply call my little helper function,

00:35:35.060 --> 00:35:39.740
which says go out and load that
image and scale it right there.

00:35:39.740 --> 00:35:40.740
That's it.

00:35:40.740 --> 00:35:42.470
That's all the code.

00:35:42.470 --> 00:35:45.860
It loads it and scales
it on one function.

00:35:46.320 --> 00:35:52.340
If I am using operations,
I look at my model object and I say,

00:35:52.660 --> 00:35:54.520
do I have an image?

00:35:54.870 --> 00:36:00.460
And is there an active queued
operation for this cell?

00:36:00.480 --> 00:36:03.780
If there is not,
then I'm going to go out and

00:36:03.780 --> 00:36:06.540
create my load scale operation.

00:36:06.580 --> 00:36:09.610
I have my designated
initializer in it with path,

00:36:09.610 --> 00:36:12.060
which is right out of the slide code.

00:36:12.320 --> 00:36:15.350
And I also pass the index,
which tells me which row

00:36:15.350 --> 00:36:19.110
this image belongs to,
obviously which table view cell row,

00:36:19.110 --> 00:36:21.940
and the target size that
I want for that image,

00:36:21.940 --> 00:36:24.750
which I'm acquiring here,
which is just based

00:36:24.750 --> 00:36:26.930
completely on the row height.

00:36:28.480 --> 00:36:32.300
I simply set myself as the delegate,
and then I add that

00:36:32.300 --> 00:36:35.730
operation to my queue,
which I've already created

00:36:35.730 --> 00:36:37.340
when the view did load.

00:36:37.670 --> 00:36:41.120
Then I release it,
and then I keep my model object in sync,

00:36:41.120 --> 00:36:45.260
very simply by saying, yes,
I have a queued operation.

00:36:45.280 --> 00:36:48.580
This model object, remember,
holds the state.

00:36:48.720 --> 00:36:50.980
So this tells me I have
a queued operation.

00:36:50.980 --> 00:36:54.450
And then I simply return
my placeholder image,

00:36:54.450 --> 00:36:56.540
which you see initially.

00:36:57.580 --> 00:36:59.120
That's all I have to do.

00:36:59.120 --> 00:37:01.920
Now,
let's look at the load scale operation.

00:37:03.290 --> 00:37:07.180
If we look at that,
it's pretty straightforward.

00:37:07.500 --> 00:37:09.230
Here's my declaration.

00:37:09.490 --> 00:37:11.780
I have the string,
which is the path to the

00:37:11.780 --> 00:37:13.240
image that I want to load.

00:37:13.240 --> 00:37:16.720
I have my resultant scaled image,
my UI image.

00:37:16.720 --> 00:37:21.420
I have the index,
which tells me which row in the

00:37:21.420 --> 00:37:27.800
table view that this belongs to,
the target size for that image,

00:37:27.950 --> 00:37:29.770
and my delegate.

00:37:29.770 --> 00:37:31.790
So very, very simple.

00:37:33.280 --> 00:37:35.740
I have my designated initializer.

00:37:35.790 --> 00:37:36.150
And that's it.

00:37:36.240 --> 00:37:39.390
If we go back to the code,
here's my designated initializer.

00:37:39.480 --> 00:37:41.410
I just retain that path.

00:37:41.600 --> 00:37:43.800
I store the index and the target size.

00:37:43.990 --> 00:37:46.720
And the dealloc simply
just release those things,

00:37:46.790 --> 00:37:48.860
release the scaled image if there is one.

00:37:48.940 --> 00:37:50.770
So here's the important part.

00:37:50.940 --> 00:37:52.130
Here's my main.

00:37:52.320 --> 00:37:54.800
Now here's where you're going
to see something interesting.

00:37:54.870 --> 00:37:55.960
I broke out this code.

00:37:55.960 --> 00:37:58.820
I could have used that same
helper function that does the

00:37:59.120 --> 00:38:00.520
image loading and scaling.

00:38:00.570 --> 00:38:03.550
But to be a good operation,
we want to test frequently

00:38:03.550 --> 00:38:04.890
if we've been canceled.

00:38:05.210 --> 00:38:09.820
And this is extremely pertinent in this
demo because the table view is scrolling.

00:38:09.960 --> 00:38:13.880
It's creating these operations on
the fly and then canceling them as

00:38:13.880 --> 00:38:17.130
soon as that operation scrolls off
since we don't know if the user

00:38:17.210 --> 00:38:18.840
is going to stop scrolling or not.

00:38:18.900 --> 00:38:23.640
So as soon as it scrolls off the screen,
you're going to cancel this operation.

00:38:23.640 --> 00:38:27.200
So we want to be a good citizen
and check frequently to see

00:38:27.200 --> 00:38:28.980
if we have been canceled.

00:38:29.100 --> 00:38:32.820
So like all threading,
I create my own auto release pool

00:38:32.920 --> 00:38:35.050
and then I just start doing my work.

00:38:35.130 --> 00:38:39.690
I call initWithContentsOfFile, UIImage.

00:38:39.900 --> 00:38:43.060
And then I test to see
if I've got the image.

00:38:43.060 --> 00:38:46.530
And then all this does is
calculate a scale factor so

00:38:46.530 --> 00:38:48.560
I get a proportional size.

00:38:48.560 --> 00:38:49.400
It's just some math.

00:38:49.540 --> 00:38:50.530
There's no big deal here.

00:38:50.530 --> 00:38:56.190
I get that scale factor, and then I say,
all right, what is my new image size,

00:38:56.190 --> 00:38:57.730
width and height?

00:38:57.790 --> 00:38:59.890
I'm simply multiplying
by the scale factor.

00:38:59.890 --> 00:39:01.660
And again, I'm checking to see.

00:39:01.780 --> 00:39:03.350
I've done a little bit of work.

00:39:03.660 --> 00:39:04.560
Have I been canceled?

00:39:04.770 --> 00:39:04.970
No.

00:39:04.970 --> 00:39:05.870
Keep going.

00:39:07.160 --> 00:39:11.910
So then I create my CG bitmap context,
and I set a few parameters on that.

00:39:11.910 --> 00:39:15.240
And again, I say, hey,
have I been canceled?

00:39:15.240 --> 00:39:17.050
Then let's keep going.

00:39:18.600 --> 00:39:21.860
And then all I do is tell the
CG context to draw the image

00:39:21.860 --> 00:39:24.690
into the new bitmap context,
because that's going to

00:39:24.690 --> 00:39:25.720
give me my scaled image.

00:39:25.720 --> 00:39:27.630
And then I release and clean up.

00:39:27.710 --> 00:39:31.070
And even here, I say one more time,
have I been canceled?

00:39:31.370 --> 00:39:31.680
No.

00:39:31.680 --> 00:39:35.580
Then let's go ahead and
acquire the CG image that is

00:39:35.580 --> 00:39:38.100
inside that bitmap context.

00:39:38.100 --> 00:39:39.420
Then I release everything.

00:39:39.420 --> 00:39:44.620
And down again, I look here and say,
all right, do I have my CG image?

00:39:44.620 --> 00:39:45.860
Yes.

00:39:45.860 --> 00:39:47.460
Have I been canceled again?

00:39:47.460 --> 00:39:51.150
Then let's construct a new
UI image from that CG image,

00:39:51.150 --> 00:39:53.390
release the original CG image.

00:39:53.390 --> 00:39:56.800
And then at the end,
I drain my auto-release pool.

00:39:56.880 --> 00:40:00.900
And again, I first test to say,
have I been canceled?

00:40:00.900 --> 00:40:04.840
And if I have a delegate,
let's send that message to the delegate.

00:40:04.840 --> 00:40:09.570
And here in my operation,

00:40:10.120 --> 00:40:13.190
We're going to look at the delegate,
which simply says,

00:40:13.190 --> 00:40:17.120
here I declare my delegate protocol,
operation finished scale.

00:40:17.120 --> 00:40:18.930
It's actually finished load and scale.

00:40:18.940 --> 00:40:20.980
But that's my delegate protocol.

00:40:20.980 --> 00:40:22.820
So let's close that.

00:40:22.900 --> 00:40:24.060
I've looked at my operation.

00:40:24.090 --> 00:40:27.780
And indeed,
in my NS operation test view controller,

00:40:27.780 --> 00:40:31.060
you'll see that not only
am I UI view controller,

00:40:31.060 --> 00:40:34.980
I also subscribe to the
UI scroll view delegate protocol,

00:40:34.980 --> 00:40:39.720
the table view data source protocol,
the table view delegate protocol,

00:40:39.720 --> 00:40:39.980
and the table view data source protocol.

00:40:40.000 --> 00:40:44.000
And the load scale operation
results delegate protocol.

00:40:44.000 --> 00:40:47.820
So I simply declare that
I implement those protocols.

00:40:47.820 --> 00:40:51.720
If I go back to the code,
once I do my load scale operation,

00:40:51.720 --> 00:40:53.830
you see it's very simple here.

00:40:53.910 --> 00:40:55.910
Let's look at the delegate.

00:40:58.630 --> 00:41:04.190
So when that operation finishes,
it calls my operation finish scale.

00:41:04.190 --> 00:41:07.910
And in fact,
I'm going to check one more time.

00:41:07.910 --> 00:41:11.800
If the operation has been canceled,
I just immediately return, right?

00:41:11.810 --> 00:41:12.490
I'm done.

00:41:12.530 --> 00:41:14.510
And here's the important part.

00:41:14.550 --> 00:41:18.670
Now, I test, am I on the main thread?

00:41:18.680 --> 00:41:19.920
NSThread is main thread.

00:41:19.920 --> 00:41:22.580
If we are on the main thread,
because there's no guarantee what

00:41:22.710 --> 00:41:25.870
thread you're going to be called from,
you could be called from the main

00:41:25.870 --> 00:41:28.580
thread or you could be called from the
thread which your operation finishes.

00:41:58.580 --> 00:41:58.580
That's the beauty of this is that
I don't and I shouldn't care.

00:41:58.580 --> 00:41:58.580
And so I ask, am I on the main thread?

00:41:58.580 --> 00:41:58.580
If I am,
I go ahead and acquire the table of

00:41:58.580 --> 00:41:58.580
the cell for the row at index path.

00:41:58.580 --> 00:41:58.580
Remember,
I store my index in the operation

00:41:58.580 --> 00:41:58.580
itself so I can recover that cell.

00:41:58.580 --> 00:41:58.580
And the really cool thing about this
method is if that cell is off screen,

00:41:58.580 --> 00:41:58.580
it returns null.

00:41:58.580 --> 00:41:58.580
It returns a nil pointer.

00:41:58.580 --> 00:41:59.000
So I know if that cell is on
screen simply by trying to

00:41:59.000 --> 00:42:00.450
acquire it and see if it's nil.

00:42:00.500 --> 00:42:04.260
So if it's not nil and I have
a scaled image in my operation,

00:42:04.330 --> 00:42:06.560
I just go ahead and set that.

00:42:06.700 --> 00:42:09.870
And then I tell it I need the
cell to relay out because the

00:42:09.870 --> 00:42:11.940
image can be an arbitrary size,
right?

00:42:13.600 --> 00:46:21.700
[Transcript missing]

00:46:22.150 --> 00:46:27.480
So we've seen the demo and how
NSOperation and NSOperationQ can

00:46:27.760 --> 00:46:31.590
dramatically change the
behavior of our application.

00:46:31.950 --> 00:46:34.340
But it's important to
reiterate a few points.

00:46:34.340 --> 00:46:37.220
NS operation and thread safety.

00:46:37.220 --> 00:46:40.820
As I said in the demo,
UIKit can only be safely

00:46:40.830 --> 00:46:42.510
used on the main thread.

00:46:42.520 --> 00:46:45.850
That's why we have
PerformSelector on main thread,

00:46:45.860 --> 00:46:51.060
so that we can move the execution from
an arbitrary thread to the main thread,

00:46:51.060 --> 00:46:53.460
so you can do all your UI updating.

00:46:53.530 --> 00:46:57.870
And you saw how easy that
was to do inside the code.

00:46:57.920 --> 00:46:59.200
Very trivial.

00:46:59.920 --> 00:47:03.780
And it's important to remember to
never modify UI state directly from

00:47:03.780 --> 00:47:05.940
inside your operation or any thread.

00:47:05.960 --> 00:47:11.740
UIKit is not thread safe, so remember,
don't modify any sort of UI state

00:47:11.740 --> 00:47:14.070
from inside a secondary thread.

00:47:15.920 --> 00:47:20.030
And as we saw in the demo,
we want to transfer data ownership.

00:47:20.150 --> 00:47:22.640
We never want to share
data between threads.

00:47:22.670 --> 00:47:26.610
It's almost always a bad, bad idea.

00:47:26.620 --> 00:47:31.810
We want to maintain that one object,
one thread relationship.

00:47:31.810 --> 00:47:37.070
So you need to be wary of things like
NSThread Detach New Thread Selector,

00:47:37.250 --> 00:47:38.960
where the target is self.

00:47:39.730 --> 00:47:42.990
That means you're probably
trying to share that object and

00:47:43.080 --> 00:47:45.090
its data on a secondary thread.

00:47:45.100 --> 00:47:48.930
Also, I see developers using
NSInvocationOperation

00:47:48.930 --> 00:47:51.190
initWithTarget self again.

00:47:51.200 --> 00:47:54.210
When I see that,
that points out to me that you might

00:47:54.210 --> 00:47:58.840
have an architectural problem and that
you could run into thread collisions

00:47:58.840 --> 00:48:03.840
because you're trying to share your
data and your objects between threads.

00:48:03.840 --> 00:48:05.860
So be careful.

00:48:09.570 --> 00:48:14.610
So now I want to talk about working
with system-owned view hierarchies.

00:48:16.730 --> 00:48:18.940
System-Owned Views, what are they?

00:48:18.960 --> 00:48:23.160
Well,
all the SDK-provided high-level views,

00:48:23.160 --> 00:48:29.380
things like the Map View, UI Web View,
UI Image Picker Controller,

00:48:29.380 --> 00:48:33.900
the Music Player Controller,
these are built view controllers

00:48:34.590 --> 00:48:36.940
that are there for you to use.

00:48:37.120 --> 00:48:40.920
But remember,
these views are considered private,

00:48:40.920 --> 00:48:45.420
and the hierarchy is not
documented and can and will change.

00:48:45.420 --> 00:48:50.540
But we understand that you may want to
involve yourself with that functionality,

00:48:50.540 --> 00:48:56.360
and we have a supported way to do
that without modifying or changing the

00:48:56.360 --> 00:49:00.110
view hierarchy underneath the system.

00:49:02.190 --> 00:49:06.100
You can do that by overriding
UI Windows Send Event.

00:49:06.160 --> 00:49:11.660
This allows you to insert yourself
into the event chain and watch

00:49:11.710 --> 00:49:15.710
specific events as they come
through and change the behavior of

00:49:16.000 --> 00:49:18.160
that view based on those events.

00:49:19.010 --> 00:49:22.520
But I want to stress that we want to
use an event-independent mechanism

00:49:22.520 --> 00:49:25.970
to tie in on UI Windows Send Event.

00:49:25.980 --> 00:49:30.570
You do not want to take the event
that's dispatched via Send Event and

00:49:30.620 --> 00:49:32.790
pass it through your system.

00:49:32.800 --> 00:49:34.410
Events have a timeliness.

00:49:34.430 --> 00:49:37.860
They have a lifespan.

00:49:38.040 --> 00:49:41.720
So you do not want to send these
things out throughout your code.

00:49:41.720 --> 00:49:45.750
So I like to recommend that you use,
again, delegation.

00:49:45.750 --> 00:49:47.560
Delegation, delegation, delegation.

00:49:48.780 --> 00:49:53.540
Remember, you can then look at the event
and pass it to a delegate without

00:49:53.540 --> 00:49:55.920
necessarily passing the event itself.

00:49:55.940 --> 00:49:58.320
There are some rules if
you're going to do this.

00:50:00.540 --> 00:50:04.780
One,
you must call super send event first.

00:50:04.780 --> 00:50:07.820
If you do not do that first,
you have stepped into

00:50:07.820 --> 00:50:09.570
unsupported territory.

00:50:09.570 --> 00:50:13.530
You can look at the event,
but you can't touch it.

00:50:13.600 --> 00:50:15.240
This is important.

00:50:15.240 --> 00:50:19.310
That's why I talk about delegating and
not dispatching the event directly.

00:50:19.310 --> 00:50:20.520
Look at the fields.

00:50:20.520 --> 00:50:22.180
You can look at the location.

00:50:22.460 --> 00:50:24.930
You can look at the view
that it's targeted for,

00:50:24.970 --> 00:50:28.420
but you should never modify
those fields inside the event.

00:50:28.480 --> 00:50:30.310
It will not work the
way you expect it to.

00:50:30.400 --> 00:50:33.200
And it's important to be quick about it.

00:50:33.200 --> 00:50:36.640
UI Windows Send event is
called quite frequently,

00:50:36.640 --> 00:50:41.440
so you do not want to do long blocking
operations inside your delegate if

00:50:41.440 --> 00:50:44.330
you're going to support this behavior.

00:50:45.680 --> 00:50:50.040
I want to step into a quick demo and
show you how easy it is to do this.

00:50:51.860 --> 00:50:54.740
So let's look at overriding
UI Windows Send Event.

00:50:54.800 --> 00:50:58.900
What I've got here is a very simple
test application that's watching all

00:50:58.900 --> 00:51:02.020
the events that come into this window.

00:51:02.190 --> 00:51:08.690
So if I triple tap, in the background,
I get one alert.

00:51:10.120 --> 00:51:14.110
And if I triple tap in the button,
I get a different alert.

00:51:14.340 --> 00:51:19.340
So all I want to show here is that
I'm differentiating between taps

00:51:19.430 --> 00:51:21.680
in the window in different views.

00:51:21.680 --> 00:51:26.380
So let's look at the code for that.

00:51:28.670 --> 00:51:31.980
All right, so let's look at how we're
overriding UI Window Send Event.

00:51:32.500 --> 00:51:35.770
What I've got is my tap observing window,
I'll call it.

00:51:35.770 --> 00:51:39.890
And you can see that it
subclasses from UI Window.

00:51:39.910 --> 00:51:44.870
And all I've got is a few IVARs in
here that tell me what view I want to

00:51:44.900 --> 00:51:48.190
observe and the delegate that observes.

00:51:48.260 --> 00:51:55.060
And these are just some housekeeping
IVARs for tracking our multiple clicks.

00:51:55.970 --> 00:51:59.880
Again, there's my protocol that
I'm going to declare,

00:51:59.880 --> 00:52:04.020
tap observer protocol,
which says user tapped observe

00:52:04.020 --> 00:52:06.350
view with taps at location.

00:52:09.370 --> 00:52:12.670
So if we go to the
implementation of that,

00:52:12.670 --> 00:52:15.780
we can easily see what's happening.

00:52:15.960 --> 00:52:19.770
So here I'm overriding
UI Windows Send Event.

00:52:20.360 --> 00:52:26.260
And all this code is really just to
pass on based on the number of clicks.

00:52:26.260 --> 00:52:29.040
But first, the important thing,
remember our first rule?

00:52:29.040 --> 00:52:31.550
I have to call super send event.

00:52:31.580 --> 00:52:34.440
Then I'm just doing some
housekeeping to make sure that

00:52:34.440 --> 00:52:37.530
I actually have work to do,
that there's a view to observe,

00:52:37.530 --> 00:52:39.180
and that I have a delegate.

00:52:39.620 --> 00:52:44.750
And then the rest of this code here,
all this is doing is making sure that

00:52:44.750 --> 00:52:47.620
we only care about multiple clicks.

00:52:47.620 --> 00:52:51.420
And all that's doing,
so we're going to perform a

00:52:51.420 --> 00:52:55.980
selector with the forward tap,
which is going to actually

00:52:55.980 --> 00:53:00.940
call our delegate based on if
I have more than one tap count.

00:53:02.630 --> 00:53:04.440
And that's really all the code is.

00:53:04.470 --> 00:53:05.420
That's all it's going to do.

00:53:05.420 --> 00:53:08.020
This is just handling multiple taps.

00:53:08.020 --> 00:53:09.040
That's all it's doing.

00:53:09.040 --> 00:53:11.030
And let's look how it's used.

00:53:11.030 --> 00:53:15.850
So in my application,
did finish launching,

00:53:16.040 --> 00:53:18.510
what I'm going to do is
for my window that I load,

00:53:18.510 --> 00:53:21.070
this is standard code
you see in every app.

00:53:21.170 --> 00:53:23.400
It's going to add the view
controller view to the window.

00:53:23.400 --> 00:53:31.060
And then I've declared this as a tap
observing window in my interface.

00:53:31.970 --> 00:53:35.240
And so when I go back to that,
I know that I have these properties,

00:53:35.240 --> 00:53:38.020
delegate that observes,
and I'm going to set my view

00:53:38.020 --> 00:53:40.020
controller to be the delegate.

00:53:40.020 --> 00:53:42.630
And the view to observe,
I'm just going to set to be

00:53:42.630 --> 00:53:47.280
basically the whole view hierarchy,
the view controller.view.superview.

00:53:47.280 --> 00:53:48.840
Very, very simple.

00:53:48.840 --> 00:53:54.320
And we'll look where this is being
forwarded on in our test view controller.

00:53:56.160 --> 00:54:00.320
And this is standard stuff,
except for here's my delegate method.

00:54:00.320 --> 00:54:03.280
User tapped observe view
with taps at location.

00:54:03.280 --> 00:54:06.030
And all I'm doing is if the
tap count is greater than two,

00:54:06.150 --> 00:54:09.470
right, with triple clicking,
that's all we're concerned with

00:54:09.470 --> 00:54:13.790
in this simple little demo,
then I determine if I'm

00:54:13.790 --> 00:54:16.990
in the button view or not.

00:54:17.050 --> 00:54:19.900
And if I'm in the button view,
then I put up one alert.

00:54:19.900 --> 00:54:22.110
If I'm not in the button view,
in other words,

00:54:22.120 --> 00:54:24.640
if I know where I'm tapping
is in the button view.

00:54:24.640 --> 00:54:27.410
If it's not in the button view,
it's just in any of the background views,

00:54:27.410 --> 00:54:28.860
I put up a secondary alert.

00:54:28.860 --> 00:54:32.600
So very simple to override the
behavior of an existing view hierarchy.

00:54:35.470 --> 00:54:35.900
That's good.

00:54:35.900 --> 00:54:38.940
Let's go back to the slides.

00:54:39.060 --> 00:54:44.190
So we've seen how easy it is to override
UI Windows Send Event and insert

00:54:44.190 --> 00:54:47.200
myself into that event behavior chain.

00:54:47.380 --> 00:54:50.880
Next,
I want to talk about UI Image Picker

00:54:50.880 --> 00:54:53.700
Controller in iPhone OS 3.1.

00:54:53.700 --> 00:56:20.900
[Transcript missing]

00:56:21.650 --> 00:56:25.820
So let's look at UI Image Picker
Controller in iPhone OS 3.1.

00:56:25.840 --> 00:56:28.370
What I've got is a very simple demo here.

00:56:28.380 --> 00:56:33.200
It puts up a toolbar,
and we're going to go and pull up

00:56:33.290 --> 00:56:35.560
the UI Image Picker in the camera.

00:56:35.560 --> 00:56:37.400
You can see I'm live here.

00:56:37.400 --> 00:56:41.320
And what I can do,
and what's important here is that this,

00:56:41.320 --> 00:56:43.180
you'll notice, is my UI.

00:56:43.200 --> 00:56:45.420
It's not the standard UI.

00:56:45.420 --> 00:56:48.600
And in fact, if I want it,
I can have a view hierarchy that

00:56:48.600 --> 00:56:50.640
covers the whole camera region.

00:56:50.940 --> 00:56:54.770
If I liked, with transparency,
it will be compositive for you.

00:56:54.780 --> 00:56:57.570
It will work exactly as you expect,
especially if you're doing

00:56:57.570 --> 00:56:58.880
an augmented reality app.

00:56:58.950 --> 00:57:01.760
In this case,
I'm just going to start taking

00:57:01.820 --> 00:57:03.950
pictures every five seconds.

00:57:03.960 --> 00:57:07.380
And you can see that
there's my picture taken.

00:57:07.380 --> 00:57:09.120
And we'll do another one.

00:57:12.160 --> 00:57:18.380
And when I say I'm stop,
it's going to take me back to my

00:57:18.380 --> 00:57:20.750
app and just go through those.

00:57:20.750 --> 00:57:23.480
It's UI image view just
cycling through those images.

00:57:23.480 --> 00:57:29.800
So I have total control over what appears
on top of that camera overlay and also

00:57:29.800 --> 00:57:33.080
control of the full functionality.

00:57:33.080 --> 00:57:34.680
I can take my own pictures.

00:57:34.680 --> 00:57:36.670
I can time it, do whatever I want.

00:57:36.760 --> 00:57:39.570
So let's look at how you
would do that in code.

00:57:43.080 --> 00:57:44.000
All right.

00:57:44.040 --> 00:57:47.640
So let's look at taking advantage
of those new features in the

00:57:47.640 --> 00:57:49.860
UI image picker controller.

00:57:49.860 --> 00:57:52.340
And it's very straightforward again.

00:57:52.340 --> 00:57:56.920
And here's my method,
show image picker for the source type.

00:57:56.990 --> 00:57:59.180
So when I tap on that
button in the corner,

00:57:59.180 --> 00:58:00.760
this is what it's called.

00:58:00.760 --> 00:58:04.720
And the important thing here is
there's some logic to determine if

00:58:04.720 --> 00:58:08.300
I'm animating those existing views,
if I'm currently in my

00:58:08.300 --> 00:58:09.920
baseline image view.

00:58:09.920 --> 00:58:11.970
But here's the important point.

00:58:12.460 --> 00:58:17.520
I go out and I acquire my image picker.

00:58:17.990 --> 00:58:21.010
So if we look at that real quick.

00:58:21.300 --> 00:58:22.680
Let's expand this code.

00:58:22.720 --> 00:58:25.680
I'm just asking for the generic
UI image picker controller.

00:58:25.680 --> 00:58:27.520
I set myself as the delegate.

00:58:27.520 --> 00:58:29.840
But here's where it gets important.

00:58:29.840 --> 00:58:31.520
I load my overlay view.

00:58:31.530 --> 00:58:34.530
So I'm actually loading my
overlay view from a nib.

00:58:34.530 --> 00:58:38.380
And in fact, this is another little
tiny view controller,

00:58:38.380 --> 00:58:39.040
right?

00:58:39.040 --> 00:58:43.300
It's going to control that toolbar that
we put in at the bottom of the screen.

00:58:43.300 --> 00:58:48.300
And this is a very nice architectural
workflow where since I don't

00:58:48.300 --> 00:58:53.450
control the image picker controller,
I'm going to put another controller

00:58:53.450 --> 00:58:55.370
on the views that I do control.

00:58:55.480 --> 00:58:57.630
So again, a very important point here.

00:58:57.730 --> 00:59:00.980
So I can actually have two view
controllers on screen at once.

00:59:00.980 --> 00:59:04.850
The view controllers, remember,
manage views and the logic within there.

00:59:04.850 --> 00:59:06.390
It's not managing screens.

00:59:06.400 --> 00:59:09.100
But again,
I set myself as the delegate of

00:59:09.100 --> 00:59:13.360
that overlay view because I have
some behaviors I want to listen to.

00:59:13.360 --> 00:59:17.070
And so when I go down and look
here again in my show image picker,

00:59:17.070 --> 00:59:19.520
once I've got that
image picker controller,

00:59:19.520 --> 00:59:21.280
then I go down and look here again
in my show image picker controller.

00:59:21.280 --> 00:59:21.280
And so when I go down and look here
again in my show image picker controller,

00:59:21.320 --> 00:59:24.600
go ahead and say, hey,
is the camera type available?

00:59:24.600 --> 00:59:29.950
And then I'm going to say,
let's instantiate, let's put that Overlay

00:59:30.190 --> 00:59:31.520
View into the Camera View.

00:59:31.790 --> 00:59:33.870
And I just do a simple,
quick test to say,

00:59:33.910 --> 00:59:37.920
am I already in the Image Picker
Controller's Overlay View?

00:59:37.930 --> 00:59:40.240
And here's the important line right here.

00:59:40.240 --> 00:59:44.160
I simply say Image Picker Controller,
Camera Overlay View is

00:59:44.160 --> 00:59:45.960
self overlay view dot view.

00:59:46.040 --> 00:59:46.480
That's it.

00:59:46.610 --> 00:59:49.750
I do some logic here to make sure
I put my little Overlay View,

00:59:49.750 --> 00:59:52.340
my little toolbar view,
at the bottom of the screen.

00:59:52.380 --> 00:59:54.110
And that's it.

00:59:54.220 --> 00:59:56.690
Then I present that
view controller modally.

00:59:56.800 --> 01:00:01.880
Now, if we look at the code for
the Overlay View Controller,

01:00:01.880 --> 01:00:03.710
I have some very simple things.

01:00:03.890 --> 01:00:06.920
Take Photo,
when I press that Take Photo button,

01:00:06.940 --> 01:00:08.280
it calls this method.

01:00:08.290 --> 01:00:12.320
And I ask the delegate
to take the snapshot.

01:00:12.360 --> 01:00:16.580
Because you'll see what's
important here is that if I'm

01:00:16.760 --> 01:00:21.630
already waiting for a snapshot,
then I have to delay that.

01:00:21.700 --> 01:00:23.900
But otherwise,
I just tell the Image Picker Controller,

01:00:23.990 --> 01:00:25.060
go ahead and take a picture.

01:00:25.060 --> 01:00:28.160
Again, programmatic use of that new API.

01:00:28.340 --> 01:00:29.900
And that's really basically it.

01:00:30.130 --> 01:00:34.810
And here you'll see my Image Picker
did finish picking media with info,

01:00:34.810 --> 01:00:38.070
which is what gets called
when that image is available.

01:00:38.280 --> 01:00:39.740
And this is standard stuff.

01:00:39.740 --> 01:00:41.780
And you'll see some
interesting things here,

01:00:41.780 --> 01:00:46.420
which is I still-- here's my code that
I'm reusing again that gets the image,

01:00:46.650 --> 01:00:48.180
scales it.

01:00:48.230 --> 01:00:49.030
And-- Yeah.

01:00:49.330 --> 01:00:53.480
--puts it into the captured images
array that's going to be presented once

01:00:53.480 --> 01:00:55.300
I close this Image Picker Controller.

01:00:55.410 --> 01:00:59.800
So I have total programmatic
control over the overlay views and

01:00:59.800 --> 01:01:01.960
how they interact with the camera.

01:01:02.020 --> 01:01:06.110
And of course,
I am taking advantage of not having

01:01:06.110 --> 01:01:08.520
to hack any view hierarchies.

01:01:08.520 --> 01:01:11.410
And I still get the behaviors I want.

01:01:12.390 --> 01:01:15.060
Let's go back to the slides.

01:01:15.110 --> 01:01:19.180
So you've seen how easy it is to use
UI Image Picker Controller in iPhone

01:01:19.180 --> 01:01:24.580
OS 3.1 and overlay your own views and
take control of that view hierarchy.

01:01:26.530 --> 01:01:29.890
Why are we talking about
this in a session dedicated

01:01:29.890 --> 01:01:32.150
to architectural relevance?

01:01:32.790 --> 01:01:36.720
Apple has a huge investment
in the frameworks and the

01:01:36.760 --> 01:01:37.970
APIs that you're using.

01:01:37.980 --> 01:01:40.970
So it's important to not
only be a smart OS client,

01:01:40.970 --> 01:01:43.040
it's important to be a good OS client.

01:01:43.090 --> 01:01:46.980
And you want to avoid unsupported
territory within the system.

01:01:48.530 --> 01:01:52.230
Also,
it's very important that you plan ahead.

01:01:52.350 --> 01:01:56.200
If things change underneath you,
how will it affect your code?

01:01:56.380 --> 01:02:01.400
Will you crash or will you just elegantly
drop that feature as you should?

01:02:01.510 --> 01:02:04.980
So you need to spend time with
the documentation and understand

01:02:04.980 --> 01:02:08.270
if there's any other way that
you can achieve your goals.

01:02:08.500 --> 01:02:11.930
Is there a supported delegate
or notification mechanism within

01:02:11.930 --> 01:02:13.990
the system to do what you like?

01:02:15.120 --> 01:02:18.150
And what I'd like you to take away
from today's session is that it's

01:02:18.150 --> 01:02:22.430
important to know the system and
the OS that you're working on.

01:02:22.580 --> 01:02:24.080
Read the documentation.

01:02:24.160 --> 01:02:29.080
Understand that you have API choices that
can dramatically affect the functionality

01:02:29.080 --> 01:02:31.720
and the behavior of your application.

01:02:31.860 --> 01:02:37.710
And those choices can affect how
you design your architecture.

01:02:38.110 --> 01:02:42.780
Make sure you try to take advantage
of the high-level APIs first because

01:02:42.780 --> 01:02:44.710
they're so simple and easy to use.

01:02:44.940 --> 01:02:48.750
But make sure that when you want to,
that you know that you can go

01:02:48.750 --> 01:02:52.780
deeper within the system and
there'll still be a fantastic,

01:02:52.780 --> 01:02:56.680
rich API set to help you
build your application.

01:02:56.780 --> 01:02:58.200
And experiment.

01:02:58.250 --> 01:03:04.360
Branch your code and look at alternate
APIs and functionality and experiment

01:03:04.360 --> 01:03:08.200
and play with things within the system
and figure out if they will benefit

01:03:08.510 --> 01:03:10.370
your application in a better way.

01:03:12.180 --> 01:03:13.540
Thanks for watching.

01:03:13.610 --> 01:03:17.140
We're looking forward to seeing your
new and improved apps in the App Store.
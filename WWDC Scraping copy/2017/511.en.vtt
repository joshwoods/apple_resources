WEBVTT

00:00:20.126 --> 00:00:21.106
>> Good morning, everyone, and

00:00:21.106 --> 00:00:23.326
welcome to Friday of WWDC.

00:00:24.016 --> 00:00:24.536
[applause] Thank you.

00:00:26.346 --> 00:00:27.816
My name is Erik Turnquist and

00:00:27.816 --> 00:00:28.936
today Brad and I are going to

00:00:28.936 --> 00:00:30.566
talk about working with HEIF and

00:00:30.566 --> 00:00:31.146
HEVC.

00:00:32.516 --> 00:00:34.616
So, first off, what is HEVC?

00:00:35.106 --> 00:00:37.136
HEVC stands for High Efficiency

00:00:37.136 --> 00:00:38.596
Video Coding and it is the

00:00:38.596 --> 00:00:40.036
industry standard next

00:00:40.036 --> 00:00:41.216
generation video encoding

00:00:41.326 --> 00:00:42.036
technology.

00:00:42.476 --> 00:00:44.416
It's the successor to H.264.

00:00:45.056 --> 00:00:47.216
Now for the more important

00:00:47.216 --> 00:00:48.786
question, is why?

00:00:49.366 --> 00:00:50.636
Why is Apple going through all

00:00:50.636 --> 00:00:51.696
of the effort to deliver a new

00:00:51.696 --> 00:00:52.126
codec?

00:00:52.126 --> 00:00:54.566
H.264 has been really good to us

00:00:54.566 --> 00:00:55.636
for over ten years.

00:00:56.486 --> 00:00:57.606
Now we thought about this a lot,

00:00:57.726 --> 00:00:58.776
and we really want to enable new

00:00:58.776 --> 00:00:59.886
features and unfortunately,

00:00:59.886 --> 00:01:01.826
H.264 has reached the limits of

00:01:01.826 --> 00:01:02.696
its capabilities.

00:01:03.056 --> 00:01:04.796
We want to enable new features

00:01:04.796 --> 00:01:06.916
like 4K and larger frame sizes,

00:01:07.246 --> 00:01:09.256
high bit depths like 10-bit and

00:01:09.256 --> 00:01:10.416
wider color spaces like Rec.

00:01:10.416 --> 00:01:12.686
2020. Now, we want to do all of

00:01:12.686 --> 00:01:13.866
this while lowering the bit

00:01:13.866 --> 00:01:15.156
rate, not raising that.

00:01:15.566 --> 00:01:16.376
So, how do we do that?

00:01:17.616 --> 00:01:19.106
Well, we do that with HEVC.

00:01:19.676 --> 00:01:21.066
So, now how much lower are the

00:01:21.066 --> 00:01:22.116
bit rates we're actually seeing?

00:01:22.736 --> 00:01:24.516
Well, for generally encoded

00:01:24.516 --> 00:01:25.906
content we're seeing up to a 40

00:01:25.906 --> 00:01:27.236
percent bit rate reduction for

00:01:27.236 --> 00:01:28.406
H.264.

00:01:28.406 --> 00:01:29.496
So, this is a really big deal.

00:01:30.236 --> 00:01:31.536
And for camera capture, we're

00:01:31.536 --> 00:01:33.076
seeing up to a 2 times better

00:01:33.076 --> 00:01:35.816
compression compared to H.264

00:01:35.896 --> 00:01:36.556
and JPEG.

00:01:37.156 --> 00:01:38.546
So, another really big deal

00:01:38.546 --> 00:01:38.816
here.

00:01:39.756 --> 00:01:40.866
And we're making all of these

00:01:40.866 --> 00:01:42.076
changes today.

00:01:42.616 --> 00:01:43.886
So, if you've installed the iOS,

00:01:43.886 --> 00:01:46.456
iOS 11 seeds, we've enabled HEVC

00:01:46.456 --> 00:01:48.286
Movie and HEIF Image Capture by

00:01:48.286 --> 00:01:48.676
default.

00:01:48.676 --> 00:01:50.326
So, that means, many of you have

00:01:50.326 --> 00:01:51.856
already captured HEIF images or

00:01:51.856 --> 00:01:53.586
HEVC movies without even knowing

00:01:53.586 --> 00:01:53.653
it.

00:01:53.653 --> 00:01:54.866
And it just works on our

00:01:54.866 --> 00:01:55.476
platforms.

00:01:56.016 --> 00:01:57.696
Let's go over what we're going

00:01:57.696 --> 00:01:58.586
to talk about today.

00:01:58.826 --> 00:01:59.976
I'm going to cover the HEVC

00:01:59.976 --> 00:02:01.466
Movie side of things, and Brad's

00:02:01.466 --> 00:02:02.546
going to cover the HEIF Image

00:02:02.546 --> 00:02:03.236
side of things.

00:02:03.496 --> 00:02:04.736
We're going to cover accessing

00:02:04.736 --> 00:02:06.606
this content, playing it back

00:02:06.606 --> 00:02:09.026
and displaying it, capturing and

00:02:09.026 --> 00:02:10.816
creating HEIF and HEVC Movies,

00:02:10.916 --> 00:02:12.296
and then export and transcode.

00:02:13.276 --> 00:02:14.786
So, first let's cover access.

00:02:16.476 --> 00:02:17.786
So, many of you are using

00:02:17.786 --> 00:02:19.146
PhotoKit and PhotoKit will

00:02:19.146 --> 00:02:20.496
deliver HEVC assets for

00:02:20.496 --> 00:02:21.016
playback.

00:02:21.466 --> 00:02:22.496
So, if you're using

00:02:22.496 --> 00:02:23.986
requestPlayerItem or

00:02:23.986 --> 00:02:25.586
requestLivePhoto they will

00:02:25.586 --> 00:02:26.766
deliver, or they will give you

00:02:26.766 --> 00:02:28.576
automatic playback with adopting

00:02:28.576 --> 00:02:30.576
new, any new APIs, so this

00:02:30.576 --> 00:02:31.136
should just work.

00:02:33.516 --> 00:02:35.626
PhotoKit can also deliver you

00:02:35.626 --> 00:02:36.616
HEVC assets.

00:02:36.616 --> 00:02:37.506
So, if you're calling it

00:02:37.506 --> 00:02:39.106
requestExportSession, it will

00:02:39.106 --> 00:02:41.166
transcode to the existing preset

00:02:41.166 --> 00:02:42.176
you're already using.

00:02:42.696 --> 00:02:43.536
So, if you're using one of the

00:02:43.536 --> 00:02:44.816
dimension presets that used to

00:02:44.816 --> 00:02:47.166
give you H.264, it will still do

00:02:47.166 --> 00:02:47.416
that.

00:02:47.596 --> 00:02:48.846
But we'll cover new presets

00:02:48.846 --> 00:02:49.856
we've added for HEVC.

00:02:49.896 --> 00:02:51.106
If you're calling

00:02:51.106 --> 00:02:52.556
requestAVAsset, it will give you

00:02:52.556 --> 00:02:54.656
access to the HEVC media file

00:02:54.656 --> 00:02:56.246
and this will have an HEVC video

00:02:56.246 --> 00:02:57.976
track inside of it.

00:02:58.976 --> 00:02:59.906
Now, if you're to backup the

00:02:59.906 --> 00:03:01.346
application, you want access to

00:03:01.346 --> 00:03:02.986
the raw bits, so you're probably

00:03:02.986 --> 00:03:04.546
calling it requestData, so I

00:03:04.546 --> 00:03:05.706
want to make note that this will

00:03:05.706 --> 00:03:07.606
actually contain the HEVC video

00:03:07.606 --> 00:03:08.966
track inside the movie file that

00:03:08.966 --> 00:03:09.996
you've receive, so you need to

00:03:09.996 --> 00:03:10.886
be able to handle this.

00:03:12.226 --> 00:03:14.196
Now that you have this content,

00:03:14.196 --> 00:03:15.226
let's call about playback and

00:03:15.226 --> 00:03:15.566
display.

00:03:17.546 --> 00:03:19.326
HEVC playback is supported in

00:03:19.326 --> 00:03:21.216
our modern media frameworks like

00:03:21.216 --> 00:03:22.706
AVKit, AVFoundation, and

00:03:22.706 --> 00:03:23.586
VideoToolbox.

00:03:23.936 --> 00:03:25.796
We support HTTP live streaming,

00:03:26.186 --> 00:03:27.676
play-while-download, and local

00:03:27.676 --> 00:03:29.376
file back or local file

00:03:29.376 --> 00:03:29.806
playback.

00:03:30.506 --> 00:03:31.896
And we support MPEG-4 and

00:03:31.896 --> 00:03:33.106
QuickTime file formats as the

00:03:33.106 --> 00:03:34.726
source, and here there's no API

00:03:34.726 --> 00:03:35.586
opt-in required.

00:03:35.856 --> 00:03:36.626
Things should just work.

00:03:38.376 --> 00:03:40.516
We support Decode on macOS and

00:03:40.626 --> 00:03:42.206
iOS and now let's go over where

00:03:42.206 --> 00:03:43.466
we have Hardware Decode support.

00:03:44.206 --> 00:03:45.656
So, we have 8- and 10-bit

00:03:45.656 --> 00:03:47.376
decoders on our A9 chip, so

00:03:47.376 --> 00:03:49.646
that's the iPhone 6s and we have

00:03:49.646 --> 00:03:51.236
8-bit Hardware Decode on our 6th

00:03:51.236 --> 00:03:52.916
generation Intel Cores, that's

00:03:52.916 --> 00:03:54.196
Skylake and that's the MacBook

00:03:54.226 --> 00:03:55.176
Pro with Touch Bar.

00:03:55.636 --> 00:03:57.376
We also have 10-bit Decode on

00:03:57.376 --> 00:03:58.686
the 7th Generation Intel Core

00:03:58.686 --> 00:04:00.416
processors and that's Kaby Lake

00:04:00.416 --> 00:04:01.536
and that's the brand-new MacBook

00:04:01.576 --> 00:04:02.266
Pro with Touch Bar.

00:04:02.896 --> 00:04:04.236
We also have 8- and 10-bit

00:04:04.656 --> 00:04:06.336
Software Decode fallbacks on

00:04:06.336 --> 00:04:08.106
macOS and iOS.

00:04:08.446 --> 00:04:09.496
So, now let's go over some code

00:04:09.496 --> 00:04:10.736
you might have and let's convert

00:04:10.736 --> 00:04:11.806
it to HEVC playback.

00:04:12.416 --> 00:04:13.366
So, here we're playing "My

00:04:13.366 --> 00:04:15.416
Awesome Movie" making a URL,

00:04:15.586 --> 00:04:17.086
then a player and playing it.

00:04:17.086 --> 00:04:19.156
So, this is the H.264 version.

00:04:19.886 --> 00:04:21.435
And now here's the HEVC version.

00:04:21.796 --> 00:04:23.146
There's no changes.

00:04:23.426 --> 00:04:25.306
So, to play an HEVC movie file,

00:04:25.486 --> 00:04:26.466
you don't need to change any of

00:04:26.466 --> 00:04:26.936
your code.

00:04:27.266 --> 00:04:28.716
We want to have you think about

00:04:28.716 --> 00:04:29.376
a couple things.

00:04:30.666 --> 00:04:32.026
So, the first is about Decode

00:04:32.026 --> 00:04:32.746
capability.

00:04:33.056 --> 00:04:33.696
And if you're asking the

00:04:33.696 --> 00:04:35.356
question is there a decoder on

00:04:35.356 --> 00:04:36.536
the system that can handle this

00:04:36.536 --> 00:04:38.566
content, this API is for you.

00:04:39.106 --> 00:04:40.626
This is useful for non-realtime

00:04:40.626 --> 00:04:42.086
operations, like sharing or

00:04:42.086 --> 00:04:42.876
image generation.

00:04:42.876 --> 00:04:44.166
And it can be limited by

00:04:44.166 --> 00:04:44.966
hardware support.

00:04:45.246 --> 00:04:46.206
So, not all of our hardware

00:04:46.206 --> 00:04:47.526
decoders support every frame

00:04:47.526 --> 00:04:48.006
size.

00:04:49.656 --> 00:04:51.086
Now, for the more important

00:04:51.086 --> 00:04:52.236
question is about playback

00:04:52.236 --> 00:04:52.866
capability.

00:04:53.096 --> 00:04:54.286
If you're asking, how do I have

00:04:54.286 --> 00:04:55.576
the best playback experience for

00:04:55.576 --> 00:04:57.426
my customer, this API is for

00:04:57.426 --> 00:04:57.696
you.

00:04:57.826 --> 00:04:59.196
And many of you are already

00:04:59.196 --> 00:04:59.986
using this API.

00:05:01.016 --> 00:05:02.356
So, not all content can be

00:05:02.356 --> 00:05:04.026
played back in realtime and we

00:05:04.026 --> 00:05:05.286
have differing capabilities on

00:05:05.286 --> 00:05:05.976
different devices.

00:05:05.976 --> 00:05:07.556
So, if you want to have a one

00:05:07.556 --> 00:05:09.196
stop shop for the best user

00:05:09.196 --> 00:05:10.566
experience for playback, whether

00:05:10.566 --> 00:05:12.636
that's 1x or 2x playback,

00:05:12.636 --> 00:05:13.816
rewind, scrubbing, or fast

00:05:13.816 --> 00:05:15.496
forward, this is the API for

00:05:15.496 --> 00:05:15.696
you.

00:05:15.696 --> 00:05:19.056
Now, let's go on to Hardware

00:05:19.056 --> 00:05:20.286
Decode availability.

00:05:20.456 --> 00:05:21.616
If you want to get the best

00:05:21.616 --> 00:05:22.976
battery life during playback,

00:05:23.266 --> 00:05:24.666
you want to playback on systems

00:05:24.666 --> 00:05:25.726
that have Hardware Decode

00:05:25.726 --> 00:05:26.136
support.

00:05:26.666 --> 00:05:28.406
This will also get you the best

00:05:28.406 --> 00:05:29.256
Decode performance.

00:05:29.256 --> 00:05:31.286
So, we have new VideoToolbox API

00:05:31.286 --> 00:05:33.256
that you can query, is there a

00:05:33.256 --> 00:05:34.726
Hardware Decoder Supported for

00:05:34.726 --> 00:05:35.296
this codec?

00:05:35.496 --> 00:05:36.686
Here I'm showing you HEVC, but

00:05:36.686 --> 00:05:37.976
you can also use it for any

00:05:37.976 --> 00:05:40.666
other codec.

00:05:40.746 --> 00:05:42.006
Now, for the final question for

00:05:42.006 --> 00:05:43.896
playback, which codec do I use

00:05:43.896 --> 00:05:44.526
for playback?

00:05:45.116 --> 00:05:48.856
Do I choose H.264 or HEVC?

00:05:49.606 --> 00:05:51.106
Well, if you're concerned about

00:05:51.186 --> 00:05:52.386
delivering the most compatible

00:05:52.386 --> 00:05:54.176
content or want to deliver one

00:05:54.176 --> 00:05:55.256
asset that just works

00:05:55.256 --> 00:05:58.136
everywhere, choose H.264.

00:05:58.546 --> 00:05:59.936
Our platforms have supported

00:05:59.936 --> 00:06:01.276
this format for over 10 years

00:06:01.276 --> 00:06:03.206
and there's broad adoption in

00:06:03.206 --> 00:06:04.896
the third-party ecosystem.

00:06:05.656 --> 00:06:06.426
However, if you want the

00:06:06.426 --> 00:06:08.826
smallest file size and latest

00:06:08.826 --> 00:06:09.546
and greatest encoding

00:06:09.546 --> 00:06:11.486
technology, like 10-bit choose

00:06:11.486 --> 00:06:12.016
HEVC.

00:06:12.456 --> 00:06:14.186
You'll have to decide what works

00:06:14.186 --> 00:06:15.006
in your application.

00:06:15.326 --> 00:06:17.906
And with that, let's move on to

00:06:19.296 --> 00:06:19.546
capture.

00:06:19.826 --> 00:06:22.166
So, capturing HEVC is supported

00:06:22.276 --> 00:06:24.006
with AVFoundation and we support

00:06:24.006 --> 00:06:25.356
MPEG-4 and QuickTime file

00:06:25.356 --> 00:06:26.756
formats as the destination.

00:06:27.336 --> 00:06:31.676
We support HEVC capture on our

00:06:31.836 --> 00:06:33.566
A10 chip, so that's iPhone 7,

00:06:33.976 --> 00:06:35.306
and now let's go over the A, the

00:06:35.306 --> 00:06:37.096
capture graph that many of you

00:06:37.096 --> 00:06:41.186
are already familiar with.

00:06:41.616 --> 00:06:42.286
This starts with an

00:06:42.286 --> 00:06:44.206
AVCaptureSession, this needs to

00:06:44.206 --> 00:06:45.286
get data from somewhere.

00:06:47.116 --> 00:06:49.556
You create an AVCaptureDevice,

00:06:49.636 --> 00:06:51.936
you add it as the input, then

00:06:51.936 --> 00:06:53.146
data needs to go somewhere.

00:06:53.146 --> 00:06:54.136
In this case you're using movie

00:06:54.136 --> 00:06:55.266
file to compress and write the

00:06:55.266 --> 00:06:55.826
output file.

00:06:57.536 --> 00:06:58.576
These are all connected with an

00:06:58.576 --> 00:07:01.046
AVCaptureConnection and this

00:07:01.046 --> 00:07:01.916
creates your movie file.

00:07:02.426 --> 00:07:03.396
So, let's convert this into

00:07:03.396 --> 00:07:03.816
code.

00:07:03.816 --> 00:07:06.086
And many of you probably have

00:07:06.086 --> 00:07:06.626
this in your app.

00:07:06.966 --> 00:07:07.696
First, create an

00:07:07.696 --> 00:07:08.686
AVCaptureConnect -- or

00:07:08.686 --> 00:07:09.816
AVCaptureSession.

00:07:09.816 --> 00:07:11.666
Here we're making a 4k capture

00:07:11.666 --> 00:07:12.396
session.

00:07:13.886 --> 00:07:14.446
Then you create the

00:07:14.446 --> 00:07:16.196
AVCaptureDevice, add it as the

00:07:16.196 --> 00:07:16.586
input.

00:07:18.466 --> 00:07:20.266
Create your MovieFileOutput and

00:07:20.266 --> 00:07:21.486
this does the compression file

00:07:21.486 --> 00:07:22.776
writing, add it as the output.

00:07:22.776 --> 00:07:25.016
And then startRunning and

00:07:25.016 --> 00:07:25.656
startRecording.

00:07:25.716 --> 00:07:27.106
And then we're capturing.

00:07:27.446 --> 00:07:29.586
So, how do we opt in to HEVC?

00:07:30.236 --> 00:07:32.036
Well, with iOS 10 we added an

00:07:32.036 --> 00:07:33.806
API to check for the available

00:07:33.806 --> 00:07:35.376
video codecs during capture.

00:07:35.646 --> 00:07:37.256
And new with iOS 11 is you can

00:07:37.256 --> 00:07:38.936
check, does it contain HEVC.

00:07:39.606 --> 00:07:41.046
On supported devices, it will

00:07:41.046 --> 00:07:42.956
return true and you can go ahead

00:07:43.276 --> 00:07:45.896
and use that in your output

00:07:45.896 --> 00:07:46.326
settings.

00:07:46.576 --> 00:07:48.596
And if it doesn't support it you

00:07:48.596 --> 00:07:49.656
can go ahead and fall back to

00:07:49.656 --> 00:07:51.876
another codec like H.264.

00:07:51.876 --> 00:07:53.386
Now I want to make an important

00:07:53.386 --> 00:07:54.246
point here, is that order

00:07:54.246 --> 00:07:54.876
matters with the

00:07:54.876 --> 00:07:56.316
availableVideoCodecTypes and for

00:07:56.316 --> 00:07:58.056
this seed we made HEVC the first

00:07:58.056 --> 00:07:58.486
option.

00:07:58.926 --> 00:07:59.916
So, that means, if you do

00:07:59.916 --> 00:08:01.236
nothing else, you'll be

00:08:01.236 --> 00:08:02.736
capturing HEVC content.

00:08:03.196 --> 00:08:04.426
We really want to get you used

00:08:04.426 --> 00:08:05.476
to handling this content.

00:08:06.776 --> 00:08:07.626
Now, let's move on to Live

00:08:07.626 --> 00:08:08.136
Photos.

00:08:09.646 --> 00:08:10.716
So, we have the same capture

00:08:10.716 --> 00:08:12.546
graph here, but we use our

00:08:12.546 --> 00:08:14.086
AVCapturePhotoOutput, and that

00:08:14.086 --> 00:08:15.296
makes all the Live Photos we

00:08:15.296 --> 00:08:15.866
love and enjoy.

00:08:16.596 --> 00:08:17.906
So, first let's go over couple

00:08:18.206 --> 00:08:19.416
new Live Photo enhancements

00:08:19.416 --> 00:08:20.316
we've done in the past year.

00:08:21.696 --> 00:08:22.536
We now support video

00:08:22.536 --> 00:08:24.246
stabilization, so no more shaky

00:08:24.246 --> 00:08:25.646
playback during Live Photos.

00:08:25.946 --> 00:08:27.556
We also no longer pause music

00:08:27.556 --> 00:08:28.736
playback during Live Photo

00:08:28.736 --> 00:08:30.346
capture, and we support much

00:08:30.346 --> 00:08:32.416
smoother Live Photos up to 30

00:08:32.416 --> 00:08:33.046
frames per second.

00:08:33.466 --> 00:08:36.236
So, let's go over capturing HEVC

00:08:36.236 --> 00:08:37.006
with Live Photos.

00:08:38.226 --> 00:08:40.106
So, we have new API in iOS 11

00:08:40.106 --> 00:08:40.765
where you can create

00:08:40.765 --> 00:08:42.106
availableLivePhotoVideo

00:08:42.106 --> 00:08:44.786
CodecTypes, see if it contains

00:08:44.786 --> 00:08:47.096
HEVC, and it will return true on

00:08:47.096 --> 00:08:48.146
supported devices.

00:08:49.746 --> 00:08:50.916
Then if it does go ahead and use

00:08:50.916 --> 00:08:51.876
it, if it does not you can fall

00:08:51.876 --> 00:08:52.916
back to another existing codec

00:08:52.916 --> 00:08:54.556
like H.264.

00:08:54.816 --> 00:08:56.576
I also want to make note that

00:08:56.576 --> 00:08:57.736
there's the same considerations

00:08:57.736 --> 00:08:59.206
here, is that order matters with

00:08:59.206 --> 00:09:00.596
the availableVideoCodecTypes and

00:09:00.596 --> 00:09:02.046
for this seed we made HEVC the

00:09:02.046 --> 00:09:02.746
first option.

00:09:03.676 --> 00:09:05.066
So, again, if you do nothing

00:09:05.066 --> 00:09:06.856
else, you will capture HEVC Live

00:09:06.856 --> 00:09:07.476
Photos.

00:09:08.316 --> 00:09:09.426
You might be sensing a pattern

00:09:09.426 --> 00:09:09.716
here.

00:09:09.856 --> 00:09:11.176
We really want to get you used

00:09:11.176 --> 00:09:11.936
to handling this kind of

00:09:11.936 --> 00:09:12.346
content.

00:09:12.476 --> 00:09:15.946
Now, let's go over the most

00:09:15.946 --> 00:09:17.996
customizable capture graph, and

00:09:17.996 --> 00:09:18.506
that's with

00:09:18.506 --> 00:09:20.616
AVCaptureVideoDataOutput, and

00:09:20.616 --> 00:09:21.426
AVAssetWriter.

00:09:21.996 --> 00:09:23.146
So, you use this if you want to

00:09:23.146 --> 00:09:24.476
modify the sample buffers in

00:09:24.476 --> 00:09:24.886
some way.

00:09:24.886 --> 00:09:26.146
So, you might be performing some

00:09:26.146 --> 00:09:27.236
cool filtering operation.

00:09:27.876 --> 00:09:30.546
With configuring AssetWriter for

00:09:30.546 --> 00:09:32.406
HEVC, you have two options.

00:09:32.716 --> 00:09:34.256
So, you can either configure

00:09:34.256 --> 00:09:35.666
custom output settings where you

00:09:35.826 --> 00:09:38.066
explicitly specify HEVC, or the

00:09:38.066 --> 00:09:39.186
video data output can actually

00:09:39.186 --> 00:09:40.256
recommend those settings for

00:09:40.256 --> 00:09:40.516
you.

00:09:40.516 --> 00:09:41.926
And we recommend this API.

00:09:42.736 --> 00:09:44.116
In iOS 7 we added

00:09:44.116 --> 00:09:45.076
recommendedVideoSettings

00:09:45.076 --> 00:09:45.856
ForAssetWriter.

00:09:46.216 --> 00:09:47.266
Now this always recommends

00:09:47.266 --> 00:09:48.256
H.264.

00:09:48.336 --> 00:09:49.386
So, if you want to stick with

00:09:49.386 --> 00:09:50.346
that, that's fine.

00:09:50.856 --> 00:09:52.136
However, in iOS 11 we've added

00:09:52.136 --> 00:09:53.586
new API where you can actually

00:09:54.066 --> 00:09:55.626
pass in the codec type and we

00:09:55.626 --> 00:09:56.606
will give you recommended

00:09:56.606 --> 00:09:58.196
settings for that codec type on

00:09:58.196 --> 00:09:59.106
supported devices.

00:10:00.206 --> 00:10:01.306
And with that let's move onto

00:10:01.306 --> 00:10:02.626
the Export and transcode side of

00:10:02.626 --> 00:10:02.976
things.

00:10:07.286 --> 00:10:09.376
So you can transcode to HEVC

00:10:09.376 --> 00:10:10.716
with AVFoundation and

00:10:10.716 --> 00:10:11.606
VideoToolbox.

00:10:11.726 --> 00:10:13.386
And we support MPEG-4 and

00:10:13.386 --> 00:10:14.716
QuickTime file formats as the

00:10:14.716 --> 00:10:15.306
destination.

00:10:15.756 --> 00:10:17.586
And here API opt-in is required.

00:10:20.016 --> 00:10:22.486
We support HEVC Encode on macOS

00:10:22.486 --> 00:10:23.926
and iOS and now let's go over

00:10:23.926 --> 00:10:25.466
where we support HEVC Hardware

00:10:25.466 --> 00:10:25.786
Encode.

00:10:27.106 --> 00:10:28.386
So, we have an 8-bit Hardware

00:10:28.386 --> 00:10:30.176
Encoder on our A10 Fusion chip,

00:10:30.396 --> 00:10:32.666
that's iPhone 7, and we support

00:10:32.666 --> 00:10:33.896
8-bit Hardware Encode on our

00:10:33.896 --> 00:10:35.236
macOS on our 6th generation

00:10:35.236 --> 00:10:37.086
Intel Core processors, that's

00:10:37.086 --> 00:10:38.556
the Skylake family, and that's

00:10:38.556 --> 00:10:39.936
the MacBook Pro with Touch Bar.

00:10:40.556 --> 00:10:42.946
And on macOS we have a special

00:10:42.946 --> 00:10:44.436
10-bit non-realtime, high

00:10:44.436 --> 00:10:45.686
quality software encoder that

00:10:45.686 --> 00:10:47.006
you can use and we'll talk about

00:10:47.006 --> 00:10:48.836
that in a little bit.

00:10:49.076 --> 00:10:49.906
Now, let's start with the

00:10:49.906 --> 00:10:51.936
highest-level export APIs, and

00:10:52.796 --> 00:10:53.996
that's transcoding with

00:10:53.996 --> 00:10:54.986
AVAssetExportSession.

00:10:56.326 --> 00:10:57.416
So, with this, you give us an

00:10:57.416 --> 00:10:58.976
asset, then you pick a preset

00:10:58.976 --> 00:11:00.906
and we do all the operations for

00:11:00.906 --> 00:11:02.226
you including compression and we

00:11:02.226 --> 00:11:03.256
produce an output movie.

00:11:05.016 --> 00:11:06.396
So, there's no change in

00:11:06.396 --> 00:11:08.066
behavior for existing presets.

00:11:08.066 --> 00:11:08.946
If you're using one of the

00:11:08.946 --> 00:11:10.216
existing dimension-based

00:11:10.216 --> 00:11:11.506
presets, and it used to give you

00:11:11.506 --> 00:11:13.936
H.264, it will still do that.

00:11:14.466 --> 00:11:15.996
We've added new presets here.

00:11:16.496 --> 00:11:17.626
And those will convert from

00:11:17.626 --> 00:11:19.936
H.264 or any other codec to

00:11:19.936 --> 00:11:21.966
HEVC, and these will produce

00:11:21.966 --> 00:11:23.906
smaller AVAssets, up to 40

00:11:23.906 --> 00:11:25.506
percent in some cases, with the

00:11:25.506 --> 00:11:26.176
same quality.

00:11:27.506 --> 00:11:29.136
Now, let's move one level down

00:11:29.136 --> 00:11:30.936
the stack, to compressing with

00:11:30.936 --> 00:11:31.596
AVAssetWriter.

00:11:32.146 --> 00:11:35.506
So, AVAssetWriter, you're either

00:11:35.716 --> 00:11:36.806
generating the sample buffers

00:11:36.806 --> 00:11:38.136
yourself, or getting them from

00:11:38.136 --> 00:11:39.806
another one of our APIs like

00:11:39.806 --> 00:11:40.916
VideoDataOutput or

00:11:40.916 --> 00:11:41.656
AVAssetWriter.

00:11:41.736 --> 00:11:43.216
And AVAssetWriter's responsible

00:11:43.216 --> 00:11:44.406
for compression and file

00:11:44.406 --> 00:11:44.646
writing.

00:11:46.056 --> 00:11:47.176
Again, like I discussed

00:11:47.176 --> 00:11:48.406
previously, there's two options

00:11:48.406 --> 00:11:49.266
for AVAssetWriter.

00:11:49.566 --> 00:11:51.076
You can either explicitly set

00:11:51.076 --> 00:11:52.556
custom output settings, in this

00:11:52.556 --> 00:11:54.976
case we're specifying use HEVC.

00:11:55.036 --> 00:11:56.506
You can also specify your bit

00:11:56.506 --> 00:11:58.286
rate and dimensions, or you can

00:11:58.286 --> 00:11:59.456
use one of our convenience

00:11:59.566 --> 00:12:01.236
settings in capture, you can use

00:12:01.236 --> 00:12:02.546
the VideoDataOutput and for

00:12:02.546 --> 00:12:03.646
general encode you can use the

00:12:03.646 --> 00:12:05.006
AVOutputSettingsAssistant.

00:12:05.196 --> 00:12:06.656
We've added two new presets here

00:12:06.656 --> 00:12:08.196
that on supported devices will

00:12:08.196 --> 00:12:09.936
return HEVC output settings.

00:12:11.076 --> 00:12:12.136
Now, if you're in the business

00:12:12.136 --> 00:12:13.176
of creating your own custom

00:12:13.176 --> 00:12:14.696
output settings, it can be a

00:12:14.696 --> 00:12:15.466
little tricky.

00:12:15.856 --> 00:12:17.216
So, not all encoders support all

00:12:17.216 --> 00:12:17.976
output settings.

00:12:19.006 --> 00:12:20.216
We've fixed that problem in iOS

00:12:20.216 --> 00:12:21.826
11 and macOS High Sierra so you

00:12:21.826 --> 00:12:23.016
can now query the encoder for

00:12:23.016 --> 00:12:24.336
supported properties to use in

00:12:24.336 --> 00:12:25.226
your output settings.

00:12:25.546 --> 00:12:27.606
To do that you pass in HEVC

00:12:27.606 --> 00:12:29.336
here, and it will return the

00:12:29.336 --> 00:12:30.636
encoder ID and a list of

00:12:30.636 --> 00:12:31.616
supported properties.

00:12:32.166 --> 00:12:33.446
The encoder ID is the unique

00:12:33.446 --> 00:12:35.206
identifier for that specific

00:12:35.206 --> 00:12:36.906
encoder, and with that the

00:12:36.906 --> 00:12:38.446
properties and the encoder ID

00:12:38.446 --> 00:12:40.196
can be specified in the output

00:12:40.196 --> 00:12:41.186
settings and you can be sure

00:12:41.186 --> 00:12:42.176
that it actually works for

00:12:42.176 --> 00:12:42.656
compression.

00:12:43.396 --> 00:12:44.526
Now, let's move to the lowest

00:12:44.526 --> 00:12:45.906
level compression interface and

00:12:46.476 --> 00:12:47.786
that's compressing samples with

00:12:47.786 --> 00:12:48.816
VTCompressionSession.

00:12:49.306 --> 00:12:50.896
So, just like with AssetWriter

00:12:50.896 --> 00:12:51.856
you might be generating the

00:12:51.856 --> 00:12:53.206
samples yourself or getting them

00:12:53.206 --> 00:12:55.446
from another one of our APIs.

00:12:55.446 --> 00:12:56.756
VTCompressionsSession compresses

00:12:56.756 --> 00:12:59.076
them and produces our compressed

00:12:59.076 --> 00:13:01.536
media data.

00:13:01.696 --> 00:13:03.196
So, to create a compression

00:13:03.196 --> 00:13:04.926
session with an HEVC encoder,

00:13:04.926 --> 00:13:05.816
it's very simple.

00:13:05.856 --> 00:13:07.256
In this case we're creating one

00:13:07.676 --> 00:13:09.806
that's compressing to H.264.

00:13:09.806 --> 00:13:11.366
Let's go ahead and convert it to

00:13:11.366 --> 00:13:11.496
HEVC.

00:13:12.656 --> 00:13:13.466
There we go, and now we're

00:13:13.466 --> 00:13:14.826
compressing with HEVC with

00:13:14.826 --> 00:13:15.756
VideoToolbox.

00:13:15.756 --> 00:13:16.736
So, that was pretty easy.

00:13:17.196 --> 00:13:18.486
Now, let's go over a couple of

00:13:18.486 --> 00:13:19.956
considerations on macOS.

00:13:21.356 --> 00:13:22.756
So, for optimal encoding

00:13:22.756 --> 00:13:24.136
performance on macOS you want to

00:13:24.136 --> 00:13:25.086
opt-in to hardware.

00:13:25.516 --> 00:13:26.606
This will use hardware when

00:13:26.606 --> 00:13:27.976
available and when it's not

00:13:28.036 --> 00:13:29.026
fallback to software.

00:13:29.776 --> 00:13:32.166
So, to do that, set the

00:13:32.166 --> 00:13:33.506
EnableHardwareAccelerated

00:13:33.506 --> 00:13:36.246
VideoEncoder property to true in

00:13:36.246 --> 00:13:38.926
your encoderSpecification and

00:13:38.926 --> 00:13:39.696
then pass it into

00:13:39.696 --> 00:13:41.136
VTCompressionSessionCreate.

00:13:41.936 --> 00:13:44.926
Now, if you're do realtime

00:13:44.926 --> 00:13:46.366
encode, you'll want to often

00:13:46.366 --> 00:13:47.896
require hardware and never

00:13:47.896 --> 00:13:48.896
fallback to software.

00:13:49.396 --> 00:13:51.186
So, to do that, you set in your

00:13:51.186 --> 00:13:52.206
encoderSpecification

00:13:52.276 --> 00:13:53.626
RequireHardwareAccelarated

00:13:53.626 --> 00:13:56.156
VideoEncoder to true and then

00:13:56.356 --> 00:13:57.366
pass it into your

00:13:57.366 --> 00:13:58.386
encoderSpecification.

00:13:58.386 --> 00:13:59.896
Again, on systems where hardware

00:13:59.896 --> 00:14:01.346
supported, this will succeed,

00:14:01.456 --> 00:14:02.766
but hardware on systems where

00:14:02.766 --> 00:14:03.676
there's only software encode,

00:14:04.036 --> 00:14:04.656
this will fail.

00:14:05.926 --> 00:14:06.906
All right, now let's go onto a

00:14:06.906 --> 00:14:08.616
couple advanced encoding topics.

00:14:09.106 --> 00:14:10.486
And the first is bit depth.

00:14:11.226 --> 00:14:12.316
So, if you've ever seen a nice

00:14:12.366 --> 00:14:14.056
gradient in a user interface or

00:14:14.056 --> 00:14:15.866
a nice sunrise or sunset, you

00:14:15.866 --> 00:14:16.866
notice what it looks like in

00:14:16.946 --> 00:14:18.466
real life versus what it looks

00:14:18.466 --> 00:14:20.206
like in a movie isn't exactly

00:14:20.206 --> 00:14:20.676
the same.

00:14:21.266 --> 00:14:22.366
So, you might see these color

00:14:22.366 --> 00:14:23.856
banning effects in the video

00:14:23.856 --> 00:14:25.976
version of your, of your movie.

00:14:26.546 --> 00:14:27.726
And that's because with 8-bits

00:14:27.726 --> 00:14:28.836
we don't have enough precision

00:14:28.836 --> 00:14:29.826
to represent the subtle

00:14:29.826 --> 00:14:31.066
differences between colors.

00:14:31.546 --> 00:14:32.386
Now, the great thing about

00:14:32.386 --> 00:14:33.836
10-bit is we actually do.

00:14:33.836 --> 00:14:34.716
So, you get these really

00:14:34.716 --> 00:14:35.616
beautiful gradients.

00:14:36.766 --> 00:14:38.116
Now, with our macOS software

00:14:38.116 --> 00:14:39.246
encoder, we actually support

00:14:39.286 --> 00:14:40.206
10-bit encode.

00:14:40.946 --> 00:14:41.806
So, first check that the

00:14:41.806 --> 00:14:43.606
property is supported, and if it

00:14:43.606 --> 00:14:45.236
is go ahead and use our HEVC

00:14:45.236 --> 00:14:47.206
Main10 profile for our software

00:14:47.206 --> 00:14:47.516
encoder.

00:14:48.386 --> 00:14:49.296
And we want to make sure your

00:14:49.296 --> 00:14:50.726
entire pipeline is 10-bit.

00:14:50.856 --> 00:14:51.926
We don't want you going from

00:14:51.926 --> 00:14:53.646
8-bit to 10-bit and then back to

00:14:53.646 --> 00:14:54.726
8-bit, because that loses

00:14:54.766 --> 00:14:55.226
precision.

00:14:55.566 --> 00:14:56.756
So, we've added new CoreVideo

00:14:56.756 --> 00:14:58.156
pixel buffer formats to ensure

00:14:58.156 --> 00:14:59.896
that you can stay in 10-bit.

00:14:59.896 --> 00:15:00.786
One is listed here.

00:15:01.266 --> 00:15:02.336
So, now for the first time you

00:15:02.336 --> 00:15:04.096
can render in 10-bit, encode in

00:15:04.096 --> 00:15:06.016
10-bit, decode in 10-bit, and

00:15:06.016 --> 00:15:07.436
for the first time ever on iOS

00:15:07.436 --> 00:15:08.846
and macOS our display pipeline

00:15:08.846 --> 00:15:10.536
also supports 10-bit, so we get

00:15:10.536 --> 00:15:11.336
it across everything.

00:15:12.516 --> 00:15:15.556
[ Applause ]

00:15:16.056 --> 00:15:17.116
Now, let's go over our second

00:15:17.116 --> 00:15:18.066
advanced topic and that's

00:15:18.066 --> 00:15:19.286
Hierarchical Encoding.

00:15:19.546 --> 00:15:20.986
And so to understand a little

00:15:20.986 --> 00:15:22.176
bit about this we need to go

00:15:22.176 --> 00:15:23.236
over a little bit of video

00:15:23.236 --> 00:15:25.046
encoding 101.

00:15:25.196 --> 00:15:26.426
There's three major frame types

00:15:26.426 --> 00:15:27.486
that compress video, and the

00:15:27.486 --> 00:15:28.736
first is an I Frame.

00:15:29.236 --> 00:15:30.216
You can think of I Frames like

00:15:30.216 --> 00:15:31.586
an image file and they can be

00:15:31.586 --> 00:15:32.686
decoded independently.

00:15:33.996 --> 00:15:35.846
Then we have a P Frame, and P

00:15:35.846 --> 00:15:37.606
Frames refer to previous frames,

00:15:37.746 --> 00:15:38.916
so think of them like a 1-way

00:15:38.916 --> 00:15:39.956
diff and they only contain

00:15:39.956 --> 00:15:41.116
information that isn't in the

00:15:41.116 --> 00:15:41.786
previous frame.

00:15:42.426 --> 00:15:43.906
Now we have their cousin, the B

00:15:43.906 --> 00:15:44.276
Frame.

00:15:44.746 --> 00:15:46.296
B Frames refer to previous and

00:15:46.296 --> 00:15:47.496
future frames and they're like a

00:15:47.496 --> 00:15:49.336
fancy multidirectional diff.

00:15:49.446 --> 00:15:50.266
So, they only contain

00:15:50.266 --> 00:15:51.996
information that isn't in either

00:15:51.996 --> 00:15:52.786
frame they're referencing.

00:15:53.506 --> 00:15:54.416
Now let's pretend we have a

00:15:54.416 --> 00:15:55.896
decoder that can only handle 30

00:15:55.896 --> 00:15:57.746
frames a second, and let's say

00:15:57.746 --> 00:15:59.416
we have content that is 240

00:15:59.416 --> 00:16:00.116
frames a second.

00:16:00.556 --> 00:16:01.706
Well that means we need to drop

00:16:01.706 --> 00:16:02.846
some frames before we can

00:16:02.846 --> 00:16:04.026
decode, because it can't keep

00:16:04.026 --> 00:16:04.226
up.

00:16:04.756 --> 00:16:06.076
So, when can we drop frames?

00:16:07.016 --> 00:16:08.196
We can drop frames when another

00:16:08.196 --> 00:16:09.506
frame doesn't depend on it.

00:16:10.146 --> 00:16:11.236
So, in this case we can drop the

00:16:11.236 --> 00:16:13.106
last P Frame, because it refers

00:16:13.106 --> 00:16:14.896
to another frame, but no frames

00:16:14.896 --> 00:16:15.466
refer to it.

00:16:15.606 --> 00:16:16.686
So, let's go ahead and drop it.

00:16:17.186 --> 00:16:18.916
We can also drop the B frame

00:16:18.916 --> 00:16:20.086
because it refers to other

00:16:20.086 --> 00:16:21.906
frames, but no frames refer to

00:16:21.906 --> 00:16:22.036
it.

00:16:22.386 --> 00:16:24.216
So, let's go ahead and drop it.

00:16:24.466 --> 00:16:25.806
Now, let's move to a real-world

00:16:25.806 --> 00:16:27.806
case of encoding 240 frames per

00:16:27.806 --> 00:16:28.506
second content.

00:16:29.826 --> 00:16:31.076
So, this is a typical encoding

00:16:31.076 --> 00:16:32.196
scheme used when creating

00:16:32.196 --> 00:16:33.676
content compatible with low end

00:16:33.676 --> 00:16:34.386
devices.

00:16:35.246 --> 00:16:36.436
So, for example, when encoding

00:16:36.436 --> 00:16:37.866
240 frames a second content,

00:16:37.866 --> 00:16:39.126
we'll have one non-droppable

00:16:39.126 --> 00:16:41.056
frame for every seven droppable.

00:16:41.416 --> 00:16:42.386
So, this gives us a lot of

00:16:42.386 --> 00:16:43.666
flexibility during playback.

00:16:44.036 --> 00:16:46.256
On devices that support 120

00:16:46.256 --> 00:16:47.406
frames per second decode we can

00:16:47.406 --> 00:16:48.436
handle that, on devices that

00:16:48.436 --> 00:16:49.966
only support 30, we can also

00:16:49.966 --> 00:16:50.616
playback there.

00:16:51.346 --> 00:16:52.546
Now, let's throw in our frame

00:16:52.546 --> 00:16:53.286
references.

00:16:53.756 --> 00:16:54.496
Because these frames are

00:16:54.496 --> 00:16:55.836
droppable, they can't refer to

00:16:55.836 --> 00:16:57.016
each other and they all refer to

00:16:57.016 --> 00:16:58.106
the non-droppable frame.

00:16:58.746 --> 00:16:59.546
Now, those of you with

00:16:59.546 --> 00:17:00.926
compression experience, are all

00:17:00.976 --> 00:17:02.886
already seeing one problem, is

00:17:02.886 --> 00:17:04.165
that compression suffers because

00:17:04.165 --> 00:17:05.576
we can't refer to the nearby

00:17:05.576 --> 00:17:06.136
frames.

00:17:06.346 --> 00:17:07.356
So, they're all referring to the

00:17:07.356 --> 00:17:08.695
non-droppable frame and a lot

00:17:08.695 --> 00:17:09.715
might have changed between the

00:17:09.715 --> 00:17:11.185
non-droppable and the droppable

00:17:11.185 --> 00:17:11.476
frame.

00:17:11.586 --> 00:17:13.236
All right, so that's problem

00:17:13.236 --> 00:17:14.006
number one that we're going to

00:17:14.006 --> 00:17:14.316
fix.

00:17:14.646 --> 00:17:15.935
Now, let's step through and

00:17:15.935 --> 00:17:17.236
decode down to 30 frames a

00:17:17.236 --> 00:17:17.506
second.

00:17:17.996 --> 00:17:19.376
So, first let's say we can't

00:17:19.376 --> 00:17:20.945
handle 240 frames a second,

00:17:21.616 --> 00:17:22.465
let's go ahead and drop some

00:17:22.465 --> 00:17:23.046
frames.

00:17:23.215 --> 00:17:24.226
So here we're dropping down to

00:17:24.226 --> 00:17:25.836
240 frames a second, and let's

00:17:25.836 --> 00:17:27.046
say we still can't keep up.

00:17:27.316 --> 00:17:28.626
We need to go down to 60 frames

00:17:28.626 --> 00:17:30.526
a second, let's say we have our

00:17:30.526 --> 00:17:32.046
decoder that can only handle 30

00:17:32.046 --> 00:17:33.126
frames a second, we can't even

00:17:33.126 --> 00:17:34.286
handle 60 frames a second.

00:17:34.616 --> 00:17:35.876
So, we go ahead and drop this

00:17:35.876 --> 00:17:36.396
last frame.

00:17:37.436 --> 00:17:39.226
Now, I was really guessing about

00:17:39.226 --> 00:17:40.196
what frames to drop.

00:17:40.336 --> 00:17:41.836
So, there's no indication at all

00:17:41.836 --> 00:17:42.866
about whether I should drop

00:17:42.866 --> 00:17:44.146
every other frame, or just the

00:17:44.146 --> 00:17:45.446
first half, or just the second

00:17:45.446 --> 00:17:46.196
half.

00:17:46.376 --> 00:17:47.806
So, let's fix this problem too.

00:17:47.806 --> 00:17:50.516
We can fix that with a concept

00:17:50.516 --> 00:17:52.186
known as temporal levels, and

00:17:52.186 --> 00:17:53.606
this allows us to organize

00:17:53.606 --> 00:17:55.366
frames about which ones to drop

00:17:55.366 --> 00:17:55.846
first.

00:17:56.146 --> 00:17:57.296
So, let's go ahead and re-encode

00:17:57.296 --> 00:17:57.886
our content.

00:17:57.956 --> 00:18:01.776
And you can already see that

00:18:01.776 --> 00:18:03.346
this is way more organized.

00:18:03.516 --> 00:18:05.196
So, first we drop temporal level

00:18:05.196 --> 00:18:06.666
three, and then two, and then

00:18:06.666 --> 00:18:07.736
one, and there's no guessing

00:18:07.736 --> 00:18:08.136
involved.

00:18:08.226 --> 00:18:09.156
So, this really helps.

00:18:09.656 --> 00:18:10.576
Now, let's throw in our frame

00:18:10.576 --> 00:18:11.196
references.

00:18:12.466 --> 00:18:13.626
And you can already see there's

00:18:13.626 --> 00:18:15.206
a big difference here, is that

00:18:15.206 --> 00:18:16.426
the reference frames are much

00:18:16.426 --> 00:18:17.416
closer together and they're

00:18:17.416 --> 00:18:18.596
often referring to frames that

00:18:18.596 --> 00:18:19.836
are just before, or just

00:18:19.836 --> 00:18:20.426
afterwards.

00:18:20.516 --> 00:18:21.496
So, this really improves

00:18:21.496 --> 00:18:21.936
compression.

00:18:22.946 --> 00:18:24.156
Now, let's go through and let's

00:18:24.156 --> 00:18:25.266
say we have our same decoder

00:18:25.266 --> 00:18:26.746
that can only handle 30 frames a

00:18:26.746 --> 00:18:27.026
second.

00:18:27.186 --> 00:18:28.426
We need to drop some frames.

00:18:29.116 --> 00:18:29.856
Well, there's no guessing

00:18:29.856 --> 00:18:30.246
involved.

00:18:30.796 --> 00:18:32.046
We dropped temporal level three.

00:18:32.286 --> 00:18:35.156
Now we're down to 120 frames a

00:18:35.156 --> 00:18:35.416
second.

00:18:35.416 --> 00:18:37.406
Let's drop down to level one.

00:18:37.456 --> 00:18:40.436
Now we're down to 60, and now we

00:18:40.436 --> 00:18:42.156
have a level that our decoder

00:18:42.156 --> 00:18:42.986
can actually handle.

00:18:43.396 --> 00:18:45.756
So, this reduces guessing with

00:18:45.756 --> 00:18:46.256
frame dropping.

00:18:47.616 --> 00:18:48.416
Let's go over what we've

00:18:48.416 --> 00:18:48.826
learned.

00:18:49.066 --> 00:18:50.626
So, with HEVC hierarchical

00:18:50.626 --> 00:18:51.786
encoding, we have improved

00:18:51.786 --> 00:18:52.966
temporal scalability.

00:18:53.416 --> 00:18:54.406
There's a much more obvious

00:18:54.406 --> 00:18:55.506
frame dropping pattern and it

00:18:55.506 --> 00:18:57.546
removes frame drop guessing

00:18:57.546 --> 00:18:58.266
during playback.

00:18:58.786 --> 00:19:00.306
We also have improved motion

00:19:00.306 --> 00:19:01.986
compensation, the reference

00:19:01.986 --> 00:19:03.296
frames are much closer to each

00:19:03.296 --> 00:19:04.796
other, so we can use more parts

00:19:04.796 --> 00:19:05.996
of other frames and it also

00:19:05.996 --> 00:19:06.806
improves compression.

00:19:07.286 --> 00:19:08.376
We're also using file

00:19:08.376 --> 00:19:09.806
annotations and for those of you

00:19:09.806 --> 00:19:11.426
who like to read specs, check

00:19:11.426 --> 00:19:14.146
out MPEG-4, Part 15 section 8.4

00:19:14.466 --> 00:19:15.826
and basically we're using sample

00:19:15.826 --> 00:19:16.996
groups, so no bitstream is

00:19:17.026 --> 00:19:18.156
parsing -- no, sorry.

00:19:18.716 --> 00:19:20.236
We're using sample groups so no

00:19:20.236 --> 00:19:21.776
bitstream parsing is necessary

00:19:21.776 --> 00:19:22.986
to get at this information.

00:19:23.126 --> 00:19:24.056
So, that really helps.

00:19:24.546 --> 00:19:25.086
All right.

00:19:25.086 --> 00:19:26.396
How do we opt-in to this?

00:19:27.276 --> 00:19:28.446
So you want to opt-in to this if

00:19:28.446 --> 00:19:29.526
you want to create compatible

00:19:29.526 --> 00:19:31.016
high frame rate content and

00:19:31.016 --> 00:19:32.316
there's two properties you

00:19:32.316 --> 00:19:32.846
should set.

00:19:33.136 --> 00:19:34.546
You set the base layer and

00:19:34.546 --> 00:19:35.376
capture frame rate.

00:19:36.006 --> 00:19:36.826
First check that they're

00:19:36.826 --> 00:19:38.086
supported on the encoder you're

00:19:38.086 --> 00:19:39.526
using, then set the

00:19:39.526 --> 00:19:41.166
BaseLayerFrameRate, this is the

00:19:41.166 --> 00:19:43.066
temporal level 0 frame rate, in

00:19:43.066 --> 00:19:44.226
our previous example this was

00:19:44.226 --> 00:19:45.846
the 30 frames a second, and then

00:19:45.846 --> 00:19:47.386
set the ExpectedFrameRate, in

00:19:47.386 --> 00:19:48.916
our previous example this was

00:19:48.916 --> 00:19:50.256
240 frames a second.

00:19:50.876 --> 00:19:52.446
The base layer must be decoded,

00:19:52.566 --> 00:19:53.786
and we can decode or drop other

00:19:53.786 --> 00:19:54.246
levels.

00:19:54.936 --> 00:19:56.226
So, now that you're all experts

00:19:56.226 --> 00:19:58.006
in hierarchical encoding, let's

00:19:58.006 --> 00:19:59.376
move it over to Brad for the

00:19:59.376 --> 00:20:00.356
image side of things.

00:20:00.456 --> 00:20:00.936
Thank you.

00:20:01.516 --> 00:20:06.726
[ Applause ]

00:20:07.226 --> 00:20:07.826
>> Thanks, Erik.

00:20:08.146 --> 00:20:09.416
I'm Brad Ford from the camera

00:20:09.416 --> 00:20:11.576
software team, and I get to talk

00:20:11.576 --> 00:20:12.566
to you about the other

00:20:12.566 --> 00:20:14.046
four-letter acronym that begins

00:20:14.046 --> 00:20:18.416
with HE, Here's the agenda for

00:20:18.416 --> 00:20:19.356
the rest of the session.

00:20:19.716 --> 00:20:20.806
First, we're going to cover what

00:20:20.806 --> 00:20:22.726
is HEIF at high level.

00:20:22.856 --> 00:20:24.566
We'll start at the very lowest

00:20:24.566 --> 00:20:25.906
level when we talk about reading

00:20:25.906 --> 00:20:27.936
and writing files with HEIF.

00:20:28.456 --> 00:20:29.676
Then we'll go up to the top of

00:20:29.676 --> 00:20:31.086
the stack and talk about how to

00:20:31.086 --> 00:20:33.126
use general use cases and common

00:20:33.126 --> 00:20:34.986
scenarios with HEIF, and we'll

00:20:34.986 --> 00:20:36.276
end with a topic that's most

00:20:36.276 --> 00:20:37.626
dear, near and dear to me, which

00:20:37.626 --> 00:20:38.536
is capturing HEIF.

00:20:39.546 --> 00:20:41.046
So, first off, what is HEIF?

00:20:42.336 --> 00:20:44.256
HEIF is the High Efficiency

00:20:44.256 --> 00:20:46.466
Image File Format.

00:20:46.936 --> 00:20:48.806
The second F is implied and

00:20:48.806 --> 00:20:49.216
silent.

00:20:49.436 --> 00:20:50.786
You don't need to call it HEIF

00:20:50.786 --> 00:20:51.556
[extra F sound].

00:20:51.556 --> 00:20:53.336
You'll just embarrass yourself

00:20:53.336 --> 00:20:54.356
in front of your compressionist

00:20:54.356 --> 00:20:55.136
friends if you do that.

00:20:55.706 --> 00:20:57.436
It's a modern container format

00:20:57.436 --> 00:20:58.866
for still images, and image

00:20:58.866 --> 00:20:59.546
sequences.

00:21:00.136 --> 00:21:02.156
It's part of the MPEG H Part 12

00:21:02.156 --> 00:21:04.216
specification, and by way of

00:21:04.216 --> 00:21:05.846
curiosity it was proposed in

00:21:05.846 --> 00:21:08.306
2013 and it was ratified in

00:21:08.306 --> 00:21:11.156
summer of 2015, just 1.5 years

00:21:11.156 --> 00:21:11.526
later.

00:21:12.346 --> 00:21:13.296
If any of you know anything

00:21:13.296 --> 00:21:15.276
about standards organizations, a

00:21:15.276 --> 00:21:16.516
year and a half is kind of like

00:21:16.636 --> 00:21:18.216
two days in real people time.

00:21:18.216 --> 00:21:19.016
So, you know it must be an

00:21:19.066 --> 00:21:21.856
awesome spec. The technical

00:21:21.856 --> 00:21:22.936
detail I'm sure your most

00:21:22.936 --> 00:21:24.206
interested in and the reasons

00:21:24.206 --> 00:21:26.056
that you came today is how to

00:21:26.056 --> 00:21:26.676
pronounce it.

00:21:27.716 --> 00:21:27.976
So-- .

00:21:28.516 --> 00:21:32.616
[ Laughter and Applause ]

00:21:33.116 --> 00:21:34.416
I use the scientific method, I

00:21:34.566 --> 00:21:35.886
pulled all the engineers on my

00:21:35.886 --> 00:21:37.766
floor and the voting was largely

00:21:37.766 --> 00:21:38.986
along party lines.

00:21:39.456 --> 00:21:41.586
The German speaker said "hife",

00:21:42.026 --> 00:21:44.166
the French said "eff", and the

00:21:44.166 --> 00:21:45.846
Russian said "heef".

00:21:45.846 --> 00:21:47.906
And "heef" was the runaway

00:21:47.906 --> 00:21:48.416
winner though.

00:21:48.836 --> 00:21:50.486
That's "heef" as in I can't

00:21:50.486 --> 00:21:52.576
belief how big, or how small the

00:21:52.576 --> 00:21:53.066
files are.

00:21:53.986 --> 00:21:55.946
Now, my Finnish office-mate was

00:21:55.946 --> 00:21:57.546
quick to point out that Nokia

00:21:57.546 --> 00:21:58.686
researchers were the ones that

00:21:58.686 --> 00:22:00.186
came up with the spec, so the

00:22:00.186 --> 00:22:01.666
Finnish pronunciation should

00:22:01.666 --> 00:22:03.846
win, that would be the 1 percent

00:22:03.976 --> 00:22:04.536
"hafe".

00:22:07.496 --> 00:22:08.806
Well, as for me and my floor

00:22:08.806 --> 00:22:09.776
we're going to call it "heef".

00:22:10.176 --> 00:22:12.546
It can use HEVC intra-encoding,

00:22:12.636 --> 00:22:14.326
which unsurprisingly compresses

00:22:14.326 --> 00:22:15.856
much better than the 20-year-old

00:22:16.036 --> 00:22:18.746
JPEG, two times as well as a

00:22:18.746 --> 00:22:19.366
matter of fact.

00:22:19.726 --> 00:22:21.406
That's an average of two times

00:22:21.406 --> 00:22:22.906
smaller, not up to two times

00:22:22.906 --> 00:22:23.316
smaller.

00:22:23.836 --> 00:22:25.876
We used qualitative analysis on

00:22:25.876 --> 00:22:27.496
a large data set of images to

00:22:27.496 --> 00:22:29.576
arrive at this number, ensuring

00:22:29.576 --> 00:22:32.126
visually equal quality to JPEG.

00:22:33.216 --> 00:22:35.276
It supports chopping up an image

00:22:35.276 --> 00:22:36.886
and compressing it individual

00:22:36.886 --> 00:22:37.536
tiles.

00:22:38.056 --> 00:22:39.336
This allows for more efficient

00:22:39.336 --> 00:22:41.456
decompression of large images in

00:22:41.456 --> 00:22:42.126
sections.

00:22:43.356 --> 00:22:45.106
HEIF also has first class

00:22:45.106 --> 00:22:47.036
support for auxiliary images,

00:22:47.286 --> 00:22:49.366
such as alpha, disparity, or

00:22:49.366 --> 00:22:50.166
depth maps.

00:22:51.576 --> 00:22:52.446
Here's a gray scale

00:22:52.446 --> 00:22:54.126
visualization of the depth map

00:22:54.166 --> 00:22:55.326
that's embedded in this HEIF

00:22:55.326 --> 00:22:55.706
file.

00:22:56.626 --> 00:22:58.116
Having depth information opens

00:22:58.116 --> 00:22:59.486
up a world of possibilities for

00:22:59.486 --> 00:23:01.386
image editing, such as applying

00:23:01.386 --> 00:23:02.166
different effects to the

00:23:02.166 --> 00:23:03.996
background and foreground like

00:23:03.996 --> 00:23:04.376
this.

00:23:05.686 --> 00:23:07.226
Here I've applied the Noir black

00:23:07.226 --> 00:23:08.646
and white filter to background,

00:23:08.976 --> 00:23:10.066
and the fade filter to the

00:23:10.066 --> 00:23:10.606
foreground.

00:23:10.606 --> 00:23:11.456
So, notice that the little

00:23:11.456 --> 00:23:13.126
girl's tights are still in pink,

00:23:13.126 --> 00:23:14.606
while everything behind is in

00:23:14.606 --> 00:23:15.026
Noir.

00:23:15.956 --> 00:23:17.336
Knowing the gradations of depth,

00:23:17.336 --> 00:23:19.006
I can even move the switch-over

00:23:19.006 --> 00:23:21.276
point of the filters like this,

00:23:21.506 --> 00:23:22.766
keep an eye on her flower.

00:23:24.126 --> 00:23:25.156
Now, just her hand and the

00:23:25.156 --> 00:23:26.246
flower are in color, while

00:23:26.246 --> 00:23:27.276
everything else is black and

00:23:27.276 --> 00:23:27.556
white.

00:23:28.806 --> 00:23:30.026
You can even control foreground

00:23:30.026 --> 00:23:31.086
and background lighting

00:23:31.186 --> 00:23:32.756
separately, exposure, such as

00:23:33.036 --> 00:23:33.476
this.

00:23:34.916 --> 00:23:35.876
Now, she looks like you

00:23:35.876 --> 00:23:37.266
Photoshopped her into her very

00:23:37.266 --> 00:23:37.806
own photo.

00:23:38.546 --> 00:23:39.556
I'm not saying you should do it,

00:23:39.556 --> 00:23:40.486
I'm saying you could do it.

00:23:41.826 --> 00:23:43.496
That was just a teaser for a

00:23:43.496 --> 00:23:45.876
two-part session that we had on

00:23:45.876 --> 00:23:47.506
depth, and that's sessions 507

00:23:47.506 --> 00:23:48.216
and 508.

00:23:48.216 --> 00:23:49.156
I hope you'll make some time to

00:23:49.156 --> 00:23:50.066
look at those videos.

00:23:51.246 --> 00:23:53.046
When it comes to metadata, HEIF

00:23:53.316 --> 00:23:55.236
has a great compatibility story.

00:23:55.376 --> 00:23:56.836
It supports industry standard

00:23:56.836 --> 00:23:59.316
Exif and xmp as first-class

00:23:59.316 --> 00:23:59.836
citizens.

00:24:01.056 --> 00:24:02.676
HEIF isn't just for single

00:24:02.676 --> 00:24:05.756
images, it also supports image

00:24:05.756 --> 00:24:07.796
sequences such as bursts,

00:24:08.106 --> 00:24:10.576
exposure brackets, focus stacks.

00:24:11.256 --> 00:24:12.556
It also has affordances for

00:24:12.556 --> 00:24:14.686
mixed media, such as audio and

00:24:14.686 --> 00:24:15.496
video tracks.

00:24:17.306 --> 00:24:18.346
Let's do a demo, shall we?

00:24:19.626 --> 00:24:21.536
Okay, this is a showcase that

00:24:21.536 --> 00:24:22.966
takes place in Apple's very own

00:24:22.966 --> 00:24:23.566
Photos app.

00:24:30.576 --> 00:24:31.326
All right, I'm going to start

00:24:31.326 --> 00:24:34.016
with a pano and this is a nice

00:24:34.016 --> 00:24:36.156
looking pano, this one is from

00:24:36.156 --> 00:24:37.766
Pothole Dome in Yosemite.

00:24:38.256 --> 00:24:40.136
It looks great, it's sort of

00:24:40.416 --> 00:24:41.776
what you'd expect from a pano

00:24:41.776 --> 00:24:43.596
until you start zooming in.

00:24:44.276 --> 00:24:45.566
So, let's do that.

00:24:46.366 --> 00:24:47.496
Zoom in a bit.

00:24:48.316 --> 00:24:49.716
Looks nice, let's zoom in a

00:24:49.716 --> 00:24:50.336
little more.

00:24:51.176 --> 00:24:52.636
And then zoom in a little more.

00:24:53.776 --> 00:24:55.246
And zoom in a little more.

00:24:56.226 --> 00:24:57.456
And keep zooming.

00:24:58.136 --> 00:25:00.256
And keep zooming, oh my gosh I

00:25:00.256 --> 00:25:01.726
can see what the speed limit is,

00:25:02.426 --> 00:25:03.976
and wow.

00:25:04.516 --> 00:25:09.546
[ Applause ]

00:25:10.046 --> 00:25:11.546
There are cars there, and there

00:25:11.546 --> 00:25:13.306
are Porta Potties.

00:25:13.366 --> 00:25:14.686
I can even go and take a look at

00:25:14.686 --> 00:25:15.816
the peaks in the background.

00:25:18.376 --> 00:25:20.366
Notice how it snaps into clarity

00:25:20.366 --> 00:25:20.896
as I go.

00:25:21.466 --> 00:25:24.806
This is actually a 2.9 gigapixel

00:25:24.956 --> 00:25:25.356
pano.

00:25:25.826 --> 00:25:28.136
It's 91,000 pixels by about

00:25:28.206 --> 00:25:29.856
32,000 pixels.

00:25:30.476 --> 00:25:32.376
The RGB TIFF file for this is

00:25:32.376 --> 00:25:33.816
well over 2 gigabytes and I

00:25:33.816 --> 00:25:35.786
assured it brings any fast Mac

00:25:35.836 --> 00:25:38.566
to its knees, whereas the HEIF

00:25:38.566 --> 00:25:41.206
file is 160 megabytes, you

00:25:41.206 --> 00:25:42.866
literally cannot do this with

00:25:42.866 --> 00:25:45.026
JPEG, since JPEG maxes out at

00:25:45.106 --> 00:25:47.396
64k by 64k pixels.

00:25:47.986 --> 00:25:49.376
HEIF does not max out.

00:25:49.896 --> 00:25:52.056
It supports arbitrarily large

00:25:52.476 --> 00:25:55.206
files and it keeps the memory in

00:25:55.206 --> 00:25:56.926
check by efficiently loading and

00:25:56.926 --> 00:25:58.016
unloading tiles.

00:25:58.376 --> 00:25:59.566
So, while I have this enormous

00:25:59.596 --> 00:26:01.116
data sitting in front of me, I'm

00:26:01.116 --> 00:26:02.386
never using more than 70

00:26:02.386 --> 00:26:04.386
megabytes of memory at a time in

00:26:04.386 --> 00:26:05.006
the Photos app.

00:26:05.336 --> 00:26:07.316
So, it's responsive and I can

00:26:07.316 --> 00:26:08.146
zoom in and zoom out.

00:26:08.146 --> 00:26:09.196
I could do this all day long,

00:26:09.296 --> 00:26:10.236
but I should probably go back to

00:26:10.236 --> 00:26:10.626
slides.

00:26:12.516 --> 00:26:15.500
[ Applause ]

00:26:19.226 --> 00:26:23.136
On all iOS 11 and macOS 10.13

00:26:23.136 --> 00:26:24.856
supported hardware, we read and

00:26:24.856 --> 00:26:26.816
decode three different flavors

00:26:26.816 --> 00:26:28.046
of HEIF.

00:26:28.136 --> 00:26:29.256
The three different extensions

00:26:29.256 --> 00:26:30.466
you see here relate to how the

00:26:30.466 --> 00:26:32.196
main image in the file is

00:26:32.196 --> 00:26:32.676
encoded.

00:26:34.416 --> 00:26:37.936
For HEIC, .HEIC also the UTI of

00:26:37.936 --> 00:26:39.886
public.heic that refers to HEIF

00:26:39.886 --> 00:26:41.826
files in which the main image is

00:26:41.826 --> 00:26:43.396
compressed with HEVC.

00:26:44.156 --> 00:26:46.746
The second flavor is AVCI, in

00:26:46.746 --> 00:26:47.956
which the main images is

00:26:47.956 --> 00:26:51.016
compressed with H.264, and then

00:26:51.016 --> 00:26:52.576
the .HEIF extension is reserved

00:26:52.576 --> 00:26:55.106
for anything else, could be JPEG

00:26:55.106 --> 00:26:56.246
inside, could be any of the

00:26:56.246 --> 00:26:57.226
supported codecs.

00:26:59.166 --> 00:27:01.046
We only support one form of HEIF

00:27:01.046 --> 00:27:03.006
for encode and writing, and

00:27:03.006 --> 00:27:04.956
that's the HEIC format, in other

00:27:04.956 --> 00:27:06.496
words the ones in which you use

00:27:06.496 --> 00:27:06.806
HEVC.

00:27:06.806 --> 00:27:08.686
We figure if you've gone far

00:27:08.686 --> 00:27:09.976
enough to adopt the new file

00:27:09.976 --> 00:27:11.326
container, you might as well

00:27:11.326 --> 00:27:12.646
adopt the greatest compression

00:27:12.646 --> 00:27:13.506
standard as well.

00:27:14.166 --> 00:27:15.606
Support is currently limited to

00:27:15.736 --> 00:27:17.836
iOS 11 devices with the A10

00:27:17.836 --> 00:27:19.636
Fusion chip.

00:27:19.876 --> 00:27:21.036
All right, let's go over to

00:27:21.036 --> 00:27:22.506
low-level access to HEIF.

00:27:23.136 --> 00:27:25.036
The lowest level interface on

00:27:25.036 --> 00:27:26.436
our platform for reading and

00:27:26.436 --> 00:27:28.606
writing images is ImageIO.

00:27:29.126 --> 00:27:30.736
It encapsulates reading from

00:27:30.736 --> 00:27:32.706
either a file or in-memory data

00:27:32.706 --> 00:27:34.396
source using an object called

00:27:34.526 --> 00:27:35.696
CGImageSource.

00:27:36.606 --> 00:27:38.096
It also supports writing to

00:27:38.096 --> 00:27:40.556
files or to immutable data using

00:27:40.746 --> 00:27:42.226
CGImageDestination.

00:27:42.896 --> 00:27:44.036
These objects have been around

00:27:44.216 --> 00:27:45.226
for a long time.

00:27:45.286 --> 00:27:46.326
You've probably used them.

00:27:47.236 --> 00:27:48.806
To open a JPEG image file on

00:27:48.806 --> 00:27:50.296
disk, this is how you would do

00:27:50.296 --> 00:27:51.356
it using ImageIO.

00:27:51.516 --> 00:27:53.836
First you create the URL, then

00:27:53.836 --> 00:27:54.276
you call

00:27:54.276 --> 00:27:56.886
CGImageSourceCreateWithURL to

00:27:56.886 --> 00:27:57.826
create your source.

00:27:58.276 --> 00:27:59.616
The last argument is an options

00:27:59.616 --> 00:28:00.736
dictionary where you can

00:28:00.736 --> 00:28:02.266
optionally pass the UTI of the

00:28:02.266 --> 00:28:02.776
input.

00:28:03.206 --> 00:28:04.266
It's not needed when you're

00:28:04.266 --> 00:28:06.106
opening a file on disk, because

00:28:06.106 --> 00:28:07.646
the UTI can be inferred from the

00:28:07.646 --> 00:28:09.386
file path extension.

00:28:10.286 --> 00:28:11.876
Once you've got a CGImageSource,

00:28:12.276 --> 00:28:13.986
you can do several things with

00:28:14.326 --> 00:28:17.016
it, such as copy the properties

00:28:17.016 --> 00:28:19.066
at any index, that's getting

00:28:19.166 --> 00:28:21.666
metadata out of it such as Exif.

00:28:21.666 --> 00:28:23.556
You can also create a CGImage

00:28:23.626 --> 00:28:24.826
from any of the images in the

00:28:24.826 --> 00:28:25.216
file.

00:28:25.326 --> 00:28:27.106
For JPEG there's typically only

00:28:27.106 --> 00:28:28.306
one image in the file.

00:28:29.016 --> 00:28:30.426
CGImage is of course like a

00:28:30.426 --> 00:28:32.796
promise, a rendering promise.

00:28:33.126 --> 00:28:34.776
The JPEG data can be lazily

00:28:34.776 --> 00:28:36.776
decoded when necessary using

00:28:36.776 --> 00:28:38.386
CGImage such as when you're

00:28:38.386 --> 00:28:40.396
rendering it to a CG bitmap

00:28:40.396 --> 00:28:40.996
context.

00:28:41.676 --> 00:28:43.106
You can also get a thumbnail

00:28:43.106 --> 00:28:45.176
image using a variety of

00:28:45.176 --> 00:28:45.836
options.

00:28:46.276 --> 00:28:47.856
For instance, the maximum size

00:28:47.856 --> 00:28:49.116
that you would like, what to do

00:28:49.116 --> 00:28:50.206
if there's none available in the

00:28:50.206 --> 00:28:51.986
file, and when you call

00:28:51.986 --> 00:28:52.736
CGImageSource

00:28:52.736 --> 00:28:54.556
CreateThumbnailAtIndex it does

00:28:54.856 --> 00:28:55.976
decode right away.

00:28:57.896 --> 00:28:59.426
Now, here's the analogous code

00:28:59.426 --> 00:29:01.386
for opening a .HEIC file.

00:29:02.506 --> 00:29:03.816
Can anyone spot the differences?

00:29:05.206 --> 00:29:06.236
Here, I'll make it easy for you.

00:29:06.796 --> 00:29:08.166
That's it.

00:29:09.076 --> 00:29:12.656
It's a comment and it's a file

00:29:12.656 --> 00:29:13.666
path, that's it.

00:29:14.146 --> 00:29:15.456
In other words, CGImageSource

00:29:15.506 --> 00:29:16.196
just works.

00:29:16.326 --> 00:29:17.806
The one difference you don't see

00:29:17.806 --> 00:29:19.396
is how the HEVC is being

00:29:19.396 --> 00:29:19.956
decoded.

00:29:20.696 --> 00:29:22.606
On recent iOS devices and Macs

00:29:22.606 --> 00:29:23.996
the decode is hardware

00:29:23.996 --> 00:29:26.056
accelerated, whereas on older

00:29:26.056 --> 00:29:27.656
devices it's done in software

00:29:27.656 --> 00:29:28.876
and with thus be slower.

00:29:30.106 --> 00:29:31.516
A quick word on the tiling

00:29:31.516 --> 00:29:32.846
support that we just saw in the

00:29:32.846 --> 00:29:35.516
demo, CGImageSource can provide

00:29:35.516 --> 00:29:37.586
a dictionary of properties about

00:29:37.586 --> 00:29:38.616
the image by calling

00:29:38.766 --> 00:29:39.816
CGImageSourceCopy

00:29:39.816 --> 00:29:41.496
PropertiesAtIndex and the

00:29:41.496 --> 00:29:43.426
properties dictionary is a

00:29:43.426 --> 00:29:46.666
synonym for metadata, Exif,

00:29:46.866 --> 00:29:48.256
Apple Maker Note, et cetera.

00:29:48.966 --> 00:29:50.126
There's also a subdictionary

00:29:50.126 --> 00:29:51.856
called the TIFF subdictionary,

00:29:52.196 --> 00:29:53.886
in which you'll find the size of

00:29:53.886 --> 00:29:55.496
the encoded tiles as the tile

00:29:55.496 --> 00:29:56.956
length and tile width.

00:29:57.236 --> 00:29:58.576
By default they are encoded as

00:29:58.576 --> 00:30:00.836
512 by 512 pixels.

00:30:03.076 --> 00:30:04.956
CGImageSource provides you with

00:30:05.006 --> 00:30:07.336
CG Images as we saw, and CGImage

00:30:07.336 --> 00:30:08.866
has a nifty method called

00:30:08.976 --> 00:30:10.746
cropping(to: that takes

00:30:10.746 --> 00:30:11.806
advantage of the tiling.

00:30:12.556 --> 00:30:14.536
This call creates a new CGImage

00:30:14.536 --> 00:30:16.736
containing just a subsection of

00:30:16.736 --> 00:30:17.546
another image.

00:30:18.286 --> 00:30:20.056
This isn't a new API, but it

00:30:20.056 --> 00:30:21.536
works really well with HEIF

00:30:21.876 --> 00:30:23.236
where the tiles are encoded

00:30:23.276 --> 00:30:23.986
individually.

00:30:24.536 --> 00:30:25.496
You don't need to worry about

00:30:25.696 --> 00:30:27.896
the underlying encoded tile

00:30:27.896 --> 00:30:29.396
size, you can simply ask for the

00:30:29.396 --> 00:30:30.476
subregion that you want to

00:30:30.476 --> 00:30:33.046
display or render, and know that

00:30:33.346 --> 00:30:34.296
under the hood you're getting

00:30:34.296 --> 00:30:35.676
all of the tile-y goodness.

00:30:35.676 --> 00:30:38.076
It's only decoding the tiles

00:30:38.076 --> 00:30:39.086
that are necessary for that

00:30:39.146 --> 00:30:39.716
subregion.

00:30:40.326 --> 00:30:41.906
Now, let's talk about the

00:30:41.906 --> 00:30:42.616
writing side.

00:30:43.496 --> 00:30:45.096
Here's how you write a JPEG with

00:30:45.096 --> 00:30:45.676
ImageIO.

00:30:46.496 --> 00:30:47.796
You, after creating a

00:30:47.796 --> 00:30:49.326
CGImageDestination calling

00:30:49.326 --> 00:30:51.366
CGImageDestinationCreateWithURL,

00:30:53.956 --> 00:30:56.266
where I should point out you do

00:30:56.266 --> 00:30:58.116
need to specify what the UTI is.

00:30:58.686 --> 00:31:00.806
Here I'm using AVFileType.jpg

00:31:00.806 --> 00:31:03.136
which is the same as the UT type

00:31:03.276 --> 00:31:04.316
public.jpg.

00:31:05.356 --> 00:31:07.086
I'm being careful with the

00:31:07.086 --> 00:31:10.156
result, I'm using guard let just

00:31:10.156 --> 00:31:11.576
in case destination is nil.

00:31:12.126 --> 00:31:14.016
Now, in the, with the current

00:31:14.016 --> 00:31:15.226
JPEG, the only reason it would

00:31:15.226 --> 00:31:17.336
be nil is if you asked to write

00:31:17.336 --> 00:31:18.456
to a file that's outside your

00:31:18.456 --> 00:31:20.206
sandbox, but to be defensive you

00:31:20.206 --> 00:31:21.896
should really write code in this

00:31:21.896 --> 00:31:22.286
manner.

00:31:23.126 --> 00:31:25.056
Next, you add your CG image or

00:31:25.056 --> 00:31:27.276
images, one at a time with

00:31:27.276 --> 00:31:28.326
accompanying metadata if you

00:31:28.576 --> 00:31:29.076
would like.

00:31:29.076 --> 00:31:30.846
And then when you're done, you

00:31:30.846 --> 00:31:32.896
call CGImageDestinationFinalize

00:31:33.376 --> 00:31:34.756
which closes the container for

00:31:34.756 --> 00:31:36.206
editing and then writes it to

00:31:36.206 --> 00:31:36.496
disc.

00:31:37.956 --> 00:31:39.286
Now, let's look at the HEIC

00:31:39.486 --> 00:31:39.896
writing.

00:31:40.056 --> 00:31:41.266
Again, differences are very

00:31:41.266 --> 00:31:41.696
small.

00:31:42.186 --> 00:31:45.456
Just the file path extension,

00:31:45.566 --> 00:31:47.166
the UTI, the comment.

00:31:47.746 --> 00:31:48.856
One important difference here

00:31:48.856 --> 00:31:50.656
though between JPEG and HEIF is

00:31:50.656 --> 00:31:51.516
that creating a

00:31:51.516 --> 00:31:54.806
CGImageDestination will fail on

00:31:54.806 --> 00:31:57.006
devices with no HEVC hardware

00:31:57.006 --> 00:31:57.596
encoder.

00:31:58.126 --> 00:31:59.776
And when it fails, destination

00:31:59.776 --> 00:32:00.276
is nil.

00:32:00.696 --> 00:32:02.056
So, the good defensive code that

00:32:02.056 --> 00:32:03.316
I wrote on the previous slide,

00:32:03.706 --> 00:32:05.446
is even more important to do

00:32:05.516 --> 00:32:07.606
with HEVC where there is now a

00:32:07.606 --> 00:32:09.036
new reason that the destination

00:32:09.036 --> 00:32:09.686
might be nil.

00:32:10.616 --> 00:32:11.836
Please always make sure that you

00:32:11.836 --> 00:32:13.656
check this is the one and only

00:32:13.656 --> 00:32:15.496
way to know whether writing to

00:32:15.496 --> 00:32:16.616
HEIC is supported on your

00:32:16.616 --> 00:32:17.366
current platform.

00:32:19.056 --> 00:32:20.206
Also worth noting is that

00:32:20.206 --> 00:32:21.986
ImageIO has added support for

00:32:21.986 --> 00:32:23.666
reading and writing depth maps

00:32:23.666 --> 00:32:25.086
as I talked about earlier.

00:32:25.436 --> 00:32:26.746
We've done that for both HEIC

00:32:26.746 --> 00:32:28.856
and we manipulated JPEG in

00:32:28.856 --> 00:32:30.626
strange sorcery ways that we

00:32:31.036 --> 00:32:32.026
probably shouldn't talk about,

00:32:32.406 --> 00:32:34.216
I'm not going to delve deeply

00:32:34.216 --> 00:32:35.636
into that though because it's

00:32:35.636 --> 00:32:37.066
covered in the dedicated session

00:32:37.066 --> 00:32:39.536
507 and 508 where we talk about

00:32:39.606 --> 00:32:39.946
depth.

00:32:39.946 --> 00:32:41.226
And I hope you'll go look at

00:32:41.226 --> 00:32:42.686
those session because they're

00:32:43.056 --> 00:32:45.296
many segues to the auxiliary

00:32:45.296 --> 00:32:48.146
image format in HEIF.

00:32:48.146 --> 00:32:49.216
All right, it's time to move on

00:32:49.216 --> 00:32:50.486
to our next major topic which is

00:32:50.616 --> 00:32:52.106
high level access to HEIF.

00:32:52.986 --> 00:32:55.936
But before we do that, I feel

00:32:55.936 --> 00:32:57.806
that WWDC should be a cultural

00:32:57.806 --> 00:32:58.866
experience, culturally

00:32:58.866 --> 00:33:00.316
enriching, not just an

00:33:00.316 --> 00:33:01.106
educational one.

00:33:01.106 --> 00:33:02.266
And that's why I want you to

00:33:02.266 --> 00:33:03.286
rest your brains for a moment

00:33:03.286 --> 00:33:04.926
with some compression poetry.

00:33:06.226 --> 00:33:06.516
All right.

00:33:07.396 --> 00:33:09.176
Wait for it.

00:33:09.386 --> 00:33:13.046
JPEG is yay big, but HEIF is

00:33:13.046 --> 00:33:13.456
brief.

00:33:15.066 --> 00:33:15.396
[laughter] Thank you.

00:33:16.041 --> 00:33:18.041
[ Applause ]

00:33:18.066 --> 00:33:19.436
See it's compression poetry, so

00:33:19.436 --> 00:33:20.106
it's small.

00:33:20.526 --> 00:33:21.446
Did you like that?

00:33:21.446 --> 00:33:22.916
Do you want to hear some more?

00:33:24.066 --> 00:33:24.946
Okay, let's do another one.

00:33:25.566 --> 00:33:26.696
Here's a compression haiku.

00:33:29.186 --> 00:33:33.606
HEVC has twice as many syllables

00:33:34.836 --> 00:33:37.176
as JPEG progress.

00:33:38.166 --> 00:33:38.476
Thank you.

00:33:38.756 --> 00:33:39.916
All right let's move on.

00:33:41.746 --> 00:33:42.576
[applause] I'm sure they'll edit

00:33:42.576 --> 00:33:43.306
that out later.

00:33:44.226 --> 00:33:45.316
Okay, we're going to talk about

00:33:45.316 --> 00:33:46.166
HEIF and PhotoKit.

00:33:46.866 --> 00:33:48.006
PhotoKit is actually two

00:33:48.006 --> 00:33:49.456
frameworks, it's Photos

00:33:49.456 --> 00:33:51.106
framework and PhotosUI and it's

00:33:51.106 --> 00:33:52.576
very high level, it's even above

00:33:52.576 --> 00:33:53.156
UIKit.

00:33:54.276 --> 00:33:56.816
The way that you work with HEIF

00:33:56.816 --> 00:33:58.436
in PhotoKit when applying

00:33:58.436 --> 00:34:00.056
adjustments we're going to cover

00:34:00.116 --> 00:34:01.516
just briefly and we're going to

00:34:01.516 --> 00:34:02.506
talk about how you apply

00:34:02.506 --> 00:34:03.756
adjustments in three different

00:34:03.756 --> 00:34:05.496
scenarios, photos, videos, and

00:34:05.496 --> 00:34:06.206
Live Photos.

00:34:06.496 --> 00:34:07.706
And then we'll talk about common

00:34:07.706 --> 00:34:09.016
workflows that you would use

00:34:09.016 --> 00:34:10.516
with PHPhotoLibrary.

00:34:11.775 --> 00:34:12.956
Let's briefly outline the steps

00:34:12.956 --> 00:34:14.866
involved in applying an edit or

00:34:14.866 --> 00:34:16.726
an adjustment to an asset using

00:34:16.726 --> 00:34:17.346
PhotoLibrary.

00:34:18.216 --> 00:34:19.746
You ask the PHPhotoLibrary to

00:34:19.746 --> 00:34:21.626
performChanges and in that

00:34:21.626 --> 00:34:23.556
change request you start with a

00:34:23.556 --> 00:34:25.045
PHAsset that you want to edit,

00:34:25.496 --> 00:34:26.525
such as a photo.

00:34:27.266 --> 00:34:28.946
And you call request content

00:34:28.946 --> 00:34:30.876
editing input on the asset to

00:34:30.876 --> 00:34:33.306
get a PHContentEditingInput.

00:34:33.426 --> 00:34:35.626
This is the guy that gives you

00:34:35.626 --> 00:34:36.755
access to all the media

00:34:36.755 --> 00:34:38.446
associated with your asset such

00:34:38.446 --> 00:34:42.025
as a UIImage, a URL, an AVAsset,

00:34:42.466 --> 00:34:43.536
or a Live Photo.

00:34:44.406 --> 00:34:45.536
Next you create a

00:34:45.536 --> 00:34:47.906
PHContentEditingOutput by

00:34:47.906 --> 00:34:49.176
calling in it with content

00:34:49.176 --> 00:34:49.956
editing input.

00:34:50.716 --> 00:34:52.556
The editing output tells you

00:34:52.556 --> 00:34:53.906
where to place all of your

00:34:53.906 --> 00:34:55.746
rendered files on disc by

00:34:55.746 --> 00:34:57.096
providing you with a

00:34:57.096 --> 00:34:58.586
renderContentURL.

00:34:59.076 --> 00:35:00.906
You then perform your edits to

00:35:00.906 --> 00:35:02.896
the media that's provided you

00:35:02.896 --> 00:35:04.936
from the editing input, and then

00:35:04.936 --> 00:35:06.356
you write them to the specified

00:35:06.356 --> 00:35:06.966
location.

00:35:07.336 --> 00:35:10.546
Finally, the PHPhotoLibrary

00:35:10.546 --> 00:35:12.376
validates your changes and

00:35:12.376 --> 00:35:13.606
accepts them as a whole or

00:35:13.606 --> 00:35:14.596
rejects the change.

00:35:16.066 --> 00:35:18.186
So, the rules with respect to

00:35:18.186 --> 00:35:19.446
renderedOutputImages are

00:35:19.446 --> 00:35:21.316
unchanged, but you may not been

00:35:21.316 --> 00:35:23.036
aware that they were in force.

00:35:23.516 --> 00:35:26.026
In iOS 10 your output images

00:35:26.196 --> 00:35:29.016
must be rendered as JPEG with an

00:35:29.016 --> 00:35:31.286
Exif orientation of 1, that is

00:35:31.286 --> 00:35:33.126
if there's any rotation to be

00:35:33.126 --> 00:35:34.926
done, it is baked into the image

00:35:35.436 --> 00:35:37.036
in the outputRendered file.

00:35:37.506 --> 00:35:38.456
You may have overlooked this

00:35:38.456 --> 00:35:40.136
detail since probably 99 percent

00:35:40.136 --> 00:35:41.096
of the content that you are

00:35:41.096 --> 00:35:43.196
editing was provided as JPEG and

00:35:43.346 --> 00:35:44.746
then you just outputted it to

00:35:44.746 --> 00:35:45.536
the same format.

00:35:45.916 --> 00:35:46.646
But now you will see a

00:35:46.646 --> 00:35:48.606
proliferation of input content

00:35:48.606 --> 00:35:50.316
that is HEIC, so you should be

00:35:50.316 --> 00:35:51.766
well aware that you must still

00:35:51.896 --> 00:35:53.336
render all of your output

00:35:53.336 --> 00:35:55.386
content to JPEG with Exif

00:35:55.386 --> 00:35:56.376
orientation 1.

00:35:57.256 --> 00:35:59.726
Here's the code for it.

00:35:59.886 --> 00:36:01.626
Make, first you make a CIImage,

00:36:01.846 --> 00:36:03.116
this would be one way of doing

00:36:03.116 --> 00:36:03.256
it.

00:36:03.706 --> 00:36:05.316
You could make a CIImage from

00:36:05.376 --> 00:36:07.106
the content editing inputs file

00:36:07.146 --> 00:36:10.006
URL, and then apply your edits.

00:36:10.106 --> 00:36:12.116
Here I'm doing both an

00:36:12.116 --> 00:36:14.286
application of a filter and

00:36:14.406 --> 00:36:15.816
baking in the orientation.

00:36:16.336 --> 00:36:18.756
And then when I'm done, I call

00:36:18.756 --> 00:36:20.776
ciContext's handy dandy

00:36:20.776 --> 00:36:23.706
writeJPEGRepresentation, which

00:36:23.806 --> 00:36:25.096
if you've used this boilerplate

00:36:25.096 --> 00:36:26.626
code in the past, it still works

00:36:26.686 --> 00:36:27.856
correctly because it's

00:36:28.066 --> 00:36:29.996
outputting to a JPEG regardless

00:36:29.996 --> 00:36:30.976
of what the input was.

00:36:32.856 --> 00:36:34.286
Our second applying adjustments

00:36:34.286 --> 00:36:36.326
use case relates to videos, and

00:36:36.326 --> 00:36:39.556
the rule again same as iOS 10 is

00:36:39.556 --> 00:36:40.796
that no matter what the format

00:36:40.796 --> 00:36:42.826
of your input movie content, you

00:36:42.826 --> 00:36:44.926
must produce a movie compressed

00:36:44.926 --> 00:36:47.136
with H.264 as your output.

00:36:48.076 --> 00:36:49.496
Yes, even if the source movie is

00:36:49.496 --> 00:36:51.226
HEVC, you still need to render

00:36:51.376 --> 00:36:56.806
to H.264 for output.

00:36:57.636 --> 00:36:58.996
Here's some boilerplate code to

00:36:58.996 --> 00:37:00.516
edit video content that looks

00:37:00.516 --> 00:37:01.056
like this.

00:37:01.176 --> 00:37:03.686
First you get an AVAsset from

00:37:03.726 --> 00:37:06.816
the PHContentEditingInput, then

00:37:06.816 --> 00:37:07.776
you can create an

00:37:07.776 --> 00:37:09.826
AVVideoComposition in which you

00:37:09.826 --> 00:37:11.786
are handed each frame one at a

00:37:12.396 --> 00:37:13.976
time and you can get them as

00:37:13.976 --> 00:37:15.926
CIImages and then request an

00:37:15.926 --> 00:37:18.476
object that has a mouthful of a

00:37:18.476 --> 00:37:19.816
name, AVAsynchronous

00:37:19.816 --> 00:37:21.786
CoreImageFilteringRequest.

00:37:22.636 --> 00:37:24.416
You get a CIImage and then you

00:37:24.416 --> 00:37:26.756
produce a CIImage, when you're

00:37:26.756 --> 00:37:27.986
done rendering it you call

00:37:27.986 --> 00:37:30.386
request.finish and then as a

00:37:30.386 --> 00:37:32.516
final step, you export your

00:37:32.516 --> 00:37:34.816
AVAsset to a file on disc at the

00:37:34.816 --> 00:37:36.436
URL told to you by the

00:37:36.436 --> 00:37:38.316
PHContentEditingOutput.

00:37:38.916 --> 00:37:39.996
Now here's the important part.

00:37:40.506 --> 00:37:41.946
The preset to use is

00:37:41.946 --> 00:37:43.636
AVAssetExportPreset

00:37:43.636 --> 00:37:45.796
HighestQuality or any of the

00:37:45.796 --> 00:37:47.346
existing ones as Erik said,

00:37:47.586 --> 00:37:49.956
still compressed to H.264.

00:37:50.196 --> 00:37:51.636
Don't use the similarly named

00:37:51.636 --> 00:37:53.496
new ones which have HEVC in the

00:37:53.496 --> 00:37:55.116
name because you're change

00:37:55.116 --> 00:37:56.726
request will fail with an error.

00:37:58.066 --> 00:38:00.956
Finally, applying adjustments

00:38:01.066 --> 00:38:03.516
using Live Photos, the video

00:38:03.516 --> 00:38:04.656
content of Live Photos.

00:38:05.506 --> 00:38:06.916
What I'm talking about here is

00:38:06.916 --> 00:38:09.466
the moving aspect of a picture

00:38:09.466 --> 00:38:11.356
when you either swipe between

00:38:11.356 --> 00:38:12.686
photos that were Live Photos or

00:38:12.686 --> 00:38:14.656
when you Force Touch on a

00:38:14.656 --> 00:38:15.986
picture or swipe between

00:38:16.206 --> 00:38:16.756
pictures.

00:38:17.316 --> 00:38:19.206
This is the simplest use case as

00:38:19.256 --> 00:38:20.486
you never get to deal directly

00:38:20.486 --> 00:38:22.266
with the input or output files.

00:38:22.656 --> 00:38:24.506
You're passed CIImages and you

00:38:24.506 --> 00:38:25.636
produce CIImages.

00:38:26.036 --> 00:38:27.216
The encoding is done on your

00:38:27.216 --> 00:38:27.736
behalf.

00:38:28.786 --> 00:38:30.186
There's a lot of good code to

00:38:30.186 --> 00:38:31.476
look at here, but I'm not going

00:38:31.476 --> 00:38:32.546
to spend a lot of time on it.

00:38:32.656 --> 00:38:33.756
You can pause the video later

00:38:33.756 --> 00:38:35.366
and take a good long look at it.

00:38:35.866 --> 00:38:37.346
The one take home point is that

00:38:37.596 --> 00:38:38.676
after you've filtered each

00:38:38.676 --> 00:38:41.196
frame, in a Live Photo movie you

00:38:41.196 --> 00:38:42.576
can tell the Live Photo content

00:38:42.626 --> 00:38:44.456
to save your Live Photo to a

00:38:44.456 --> 00:38:46.156
given URL and that's it.

00:38:46.636 --> 00:38:48.046
The Live Photos will be saved

00:38:48.046 --> 00:38:50.556
out using H.264 on your behalf

00:38:50.866 --> 00:38:52.806
just as the stills will be

00:38:52.886 --> 00:38:55.176
encoded as JPEG.

00:38:55.656 --> 00:38:56.806
Okay, let's move over to the

00:38:56.806 --> 00:38:58.756
common workflows with PhotoKit.

00:38:59.436 --> 00:39:01.296
When displaying content from

00:39:01.296 --> 00:39:02.906
your photo library, you use an

00:39:02.906 --> 00:39:04.876
object called the PHImageManager

00:39:05.286 --> 00:39:08.346
and this provides you with one

00:39:08.346 --> 00:39:09.146
of three things.

00:39:09.836 --> 00:39:11.776
You could get a UIImage if it's

00:39:11.776 --> 00:39:13.826
an image, a PlayerItem if it's a

00:39:13.826 --> 00:39:16.346
video, or a PHLivePhoto if it's

00:39:16.346 --> 00:39:17.676
Live Photo content.

00:39:18.176 --> 00:39:19.386
Here you don't need to make any

00:39:19.386 --> 00:39:21.616
changes because all of these are

00:39:21.616 --> 00:39:23.466
high level abstractions in which

00:39:23.466 --> 00:39:24.786
you don't care where the sources

00:39:24.786 --> 00:39:25.966
came from, all you're doing is

00:39:25.966 --> 00:39:26.626
displaying them.

00:39:26.956 --> 00:39:28.216
No code changes needed here.

00:39:29.466 --> 00:39:31.676
The next is backup.

00:39:32.026 --> 00:39:33.556
When using PhotoKit for backup

00:39:33.626 --> 00:39:35.476
purposes, you probably want to

00:39:35.476 --> 00:39:37.746
access the raw assets such as

00:39:37.786 --> 00:39:39.096
the HEIC files and the QuickTime

00:39:39.096 --> 00:39:39.486
movies.

00:39:39.786 --> 00:39:41.156
And you do that using

00:39:41.156 --> 00:39:42.606
PHAssetResourceManager.

00:39:42.976 --> 00:39:44.286
It will give them to you in the

00:39:44.286 --> 00:39:45.086
native format.

00:39:45.406 --> 00:39:46.426
The only thing to be aware of

00:39:46.426 --> 00:39:48.206
here is that you might get

00:39:48.206 --> 00:39:49.596
different file types coming than

00:39:49.596 --> 00:39:50.736
you're used to, so make sure

00:39:50.736 --> 00:39:52.776
that you're ready for it.

00:39:53.626 --> 00:39:54.896
The third and most complicated

00:39:54.896 --> 00:39:55.756
case is sharing.

00:39:56.716 --> 00:39:58.226
Here you're sort of leaving

00:39:58.226 --> 00:39:59.886
Apple's nice walled garden.

00:40:00.336 --> 00:40:01.366
You have to think about your

00:40:01.366 --> 00:40:02.756
compatibility requirements.

00:40:03.116 --> 00:40:04.486
Are native assets okay?

00:40:04.636 --> 00:40:06.526
You might be doing your clients

00:40:06.526 --> 00:40:07.576
a favor or you might be doing

00:40:07.576 --> 00:40:08.956
them a disservice by giving them

00:40:08.956 --> 00:40:10.536
HEIC content depending on

00:40:10.536 --> 00:40:11.546
whether they're ready for it.

00:40:11.936 --> 00:40:12.906
So, here you must weigh

00:40:12.906 --> 00:40:14.506
compatibility versus the

00:40:14.506 --> 00:40:16.106
features that HEIC affords.

00:40:17.216 --> 00:40:19.236
If you do choose compatibility

00:40:19.236 --> 00:40:21.006
over features, you can ensure

00:40:21.006 --> 00:40:22.346
format compatibility by

00:40:22.346 --> 00:40:24.496
specifying the output format

00:40:24.496 --> 00:40:25.226
explicitly.

00:40:25.366 --> 00:40:27.796
For images, you can just check

00:40:27.796 --> 00:40:29.776
the UTType that you get, and see

00:40:29.776 --> 00:40:31.876
that it conforms to say JPEG,

00:40:31.876 --> 00:40:33.756
and if it doesn't, explicitly

00:40:33.756 --> 00:40:34.276
convert it.

00:40:34.796 --> 00:40:36.446
With videos, you can always

00:40:36.446 --> 00:40:37.686
force compatibility by

00:40:37.686 --> 00:40:39.376
requesting an export session

00:40:39.656 --> 00:40:41.146
with a preset that you know will

00:40:41.146 --> 00:40:43.526
deliver H.264 such as

00:40:43.736 --> 00:40:44.976
PresetHighestQuality.

00:40:46.236 --> 00:40:48.636
All right, onto our last topic

00:40:48.636 --> 00:40:50.156
of the day, capturing HEIF.

00:40:50.476 --> 00:40:51.786
Finally, one that I know what

00:40:51.786 --> 00:40:52.486
I'm talking about.

00:40:53.906 --> 00:40:55.116
But let's do compression haiku

00:40:55.116 --> 00:40:56.336
number two, please would you let

00:40:56.336 --> 00:40:56.486
me?

00:40:57.296 --> 00:40:57.976
It's fun for me.

00:40:58.736 --> 00:40:59.106
Here we go.

00:41:00.116 --> 00:41:03.886
HEIF a container, compresses

00:41:03.926 --> 00:41:08.046
four times better than HEVC.

00:41:09.576 --> 00:41:10.656
Think about that.

00:41:10.766 --> 00:41:12.686
Okay, so, why are we wasting our

00:41:12.686 --> 00:41:14.376
lives saying HEVC, it's supposed

00:41:14.376 --> 00:41:15.306
to be a good codec right?

00:41:15.306 --> 00:41:15.986
Why aren't we calling it

00:41:15.986 --> 00:41:16.376
"hevick".

00:41:17.976 --> 00:41:18.786
All right.

00:41:19.456 --> 00:41:20.726
So, Erik mentioned that

00:41:21.016 --> 00:41:23.256
AVCapturePhotoOutput added

00:41:23.256 --> 00:41:25.156
support for Live Photo movies

00:41:25.236 --> 00:41:26.446
encoded with HEVC.

00:41:27.456 --> 00:41:28.796
This class was introduced last

00:41:28.796 --> 00:41:30.426
year as the successor to

00:41:30.426 --> 00:41:31.716
AVCaptureStillImageOutput.

00:41:32.166 --> 00:41:33.716
It excels at handling complex

00:41:33.716 --> 00:41:35.076
still image capture requests

00:41:35.076 --> 00:41:36.796
where you need multiple assets

00:41:36.796 --> 00:41:38.036
delivered over time.

00:41:38.846 --> 00:41:40.126
It is currently the only way on

00:41:40.126 --> 00:41:42.076
our platform to capture Live

00:41:42.076 --> 00:41:45.966
Photos, Bayer RAW images, Apple

00:41:46.046 --> 00:41:49.226
P3 Wide Color Images, and new in

00:41:49.326 --> 00:41:50.976
iOS 11 it is the only interface

00:41:50.976 --> 00:41:52.506
on our platform for capturing

00:41:52.686 --> 00:41:53.786
HEIF content.

00:41:56.236 --> 00:41:58.116
HEIF capture is supported on the

00:41:58.416 --> 00:42:01.486
A10 chip devices which are

00:42:01.486 --> 00:42:03.726
iPhone 7 Plus, iPhone 7, and the

00:42:03.726 --> 00:42:05.596
newly announced iPad Pros.

00:42:05.696 --> 00:42:08.966
We'll do a brief refresher on

00:42:08.966 --> 00:42:10.426
how to request and receive

00:42:10.426 --> 00:42:12.136
images with the photo output.

00:42:12.496 --> 00:42:15.296
First, you fill out an object

00:42:15.296 --> 00:42:17.026
called an AVCapturePhotoSettings

00:42:17.026 --> 00:42:18.226
this is sort of like a request

00:42:18.226 --> 00:42:19.866
object where you specify the

00:42:19.866 --> 00:42:21.406
features that you want in your

00:42:21.636 --> 00:42:22.396
photo capture.

00:42:22.746 --> 00:42:24.356
Here it's the orange box.

00:42:25.066 --> 00:42:26.316
Here, I've indicated that I want

00:42:26.496 --> 00:42:29.166
auto flash, meaning photo output

00:42:29.166 --> 00:42:30.526
only use the flash if it's

00:42:30.526 --> 00:42:32.066
necessary, only if the light is

00:42:32.246 --> 00:42:33.506
low enough to warrant it.

00:42:34.386 --> 00:42:35.746
I've also asked for a preview

00:42:35.746 --> 00:42:37.136
sized image to accompany the

00:42:37.136 --> 00:42:38.976
full-sized image so that I can

00:42:38.976 --> 00:42:40.306
have a quick preview to put on

00:42:40.306 --> 00:42:40.806
screen.

00:42:41.366 --> 00:42:42.376
I don't know exactly what the

00:42:42.376 --> 00:42:43.996
final aspect ratio of it will be

00:42:43.996 --> 00:42:46.146
so I just ask for a box that's

00:42:46.146 --> 00:42:48.026
1440 by 1440.

00:42:48.876 --> 00:42:50.706
I then pass this settings object

00:42:50.706 --> 00:42:52.796
with a delegate that I provide

00:42:53.336 --> 00:42:56.346
to the photo output to start or

00:42:56.346 --> 00:42:57.846
kick off a capture request.

00:43:00.256 --> 00:43:02.596
Now the arrow on top shows when

00:43:02.596 --> 00:43:04.816
the request was made, and now

00:43:05.346 --> 00:43:07.136
I'm sort of tracking this

00:43:07.136 --> 00:43:09.426
package delivery, PhotoOutput

00:43:09.506 --> 00:43:11.426
calls my delegate back with one

00:43:11.426 --> 00:43:12.776
method call at a time.

00:43:13.356 --> 00:43:14.606
Very soon after I make the

00:43:14.606 --> 00:43:16.256
request the PhotoOutput calls

00:43:16.256 --> 00:43:17.606
the delegates first callback

00:43:17.606 --> 00:43:19.976
which is willBeginCaptureFor

00:43:20.346 --> 00:43:22.246
resolved settings and it passes

00:43:22.246 --> 00:43:24.096
you this blue box which is a

00:43:24.096 --> 00:43:25.746
ResolvedPhotoSettings.

00:43:26.726 --> 00:43:27.826
This is sort of like the

00:43:27.826 --> 00:43:29.046
courtesy email that you get

00:43:29.046 --> 00:43:30.056
saying we've received your

00:43:30.056 --> 00:43:32.196
order, here's what we'll be

00:43:32.196 --> 00:43:32.896
sending you.

00:43:33.586 --> 00:43:35.876
And this ResolvedPhotoSetting

00:43:35.876 --> 00:43:37.576
sort of clears up any ambiguity

00:43:37.576 --> 00:43:39.286
that you had in your settings

00:43:39.286 --> 00:43:40.316
that you provided at the

00:43:40.316 --> 00:43:40.826
beginning.

00:43:41.176 --> 00:43:42.306
In this case, we can now see

00:43:42.306 --> 00:43:44.086
that flash is not auto, it's

00:43:44.136 --> 00:43:44.916
true or false.

00:43:45.286 --> 00:43:47.086
So, it's become true, we know

00:43:47.086 --> 00:43:48.346
that the flash is going to fire.

00:43:48.836 --> 00:43:50.946
Also, we now know what the final

00:43:50.946 --> 00:43:52.486
preview image resolution is

00:43:52.486 --> 00:43:53.116
going to be.

00:43:55.446 --> 00:43:57.016
Finally, after we get the

00:43:57.016 --> 00:43:59.066
willBeginCaptureFor, we, our

00:43:59.066 --> 00:44:00.416
second call back that we receive

00:44:00.416 --> 00:44:02.296
is willCapturePhotoFor

00:44:02.296 --> 00:44:03.206
ResolvedSettings.

00:44:03.796 --> 00:44:05.046
This is delivered coincident

00:44:05.046 --> 00:44:06.956
with the shutter sound being

00:44:06.956 --> 00:44:07.436
played.

00:44:08.776 --> 00:44:10.356
And then shortly thereafter

00:44:10.586 --> 00:44:12.546
comes didCapturePhotoFor

00:44:12.546 --> 00:44:14.246
ResolvedSettings just after the

00:44:14.246 --> 00:44:16.006
image has been fully exposed and

00:44:16.006 --> 00:44:16.496
read out.

00:44:17.816 --> 00:44:19.786
Then some time typically passes

00:44:19.786 --> 00:44:21.856
while the image or images are

00:44:21.856 --> 00:44:23.476
processed, applying all the

00:44:23.476 --> 00:44:24.686
features that you asked for.

00:44:25.366 --> 00:44:26.646
When the photo is ready, you

00:44:26.646 --> 00:44:27.496
receive the

00:44:27.496 --> 00:44:29.546
didFinishProcessingPhoto sample

00:44:29.546 --> 00:44:31.776
buffer call back and the image

00:44:31.776 --> 00:44:33.496
or images are delivered to you.

00:44:33.946 --> 00:44:35.866
Here I got the main image, and

00:44:35.866 --> 00:44:36.686
the preview image.

00:44:37.076 --> 00:44:38.146
They're delivered together in

00:44:38.146 --> 00:44:38.896
the same call back.

00:44:39.966 --> 00:44:42.186
Finally, you always always

00:44:42.186 --> 00:44:43.256
always get the

00:44:43.256 --> 00:44:45.006
DidFinishCaptureFor

00:44:45.006 --> 00:44:46.906
ResolvedSettings callback.

00:44:47.356 --> 00:44:48.886
And that is guaranteed to be

00:44:48.886 --> 00:44:49.656
delivered last.

00:44:49.656 --> 00:44:50.946
It's the PhotoOutput's way of

00:44:51.146 --> 00:44:52.836
saying we're done with this

00:44:52.836 --> 00:44:54.606
transaction, pleasure doing

00:44:54.606 --> 00:44:56.466
business with you, you can clean

00:44:56.466 --> 00:44:57.316
up your delegate now.

00:45:00.076 --> 00:45:02.066
This programming model has

00:45:02.066 --> 00:45:03.966
proved to be very flexible.

00:45:04.066 --> 00:45:05.336
We've had a lot of success with

00:45:05.336 --> 00:45:06.586
it because we've been able to

00:45:06.586 --> 00:45:08.646
add new methods to the delegate

00:45:08.876 --> 00:45:10.446
as needed when we add new

00:45:10.446 --> 00:45:10.996
features.

00:45:11.736 --> 00:45:13.396
For instance, we added support

00:45:13.396 --> 00:45:14.356
for RAW images.

00:45:14.866 --> 00:45:16.166
There's a call back for that.

00:45:16.926 --> 00:45:17.906
We added support for Live

00:45:17.946 --> 00:45:19.756
Photos, there's a separate call

00:45:19.756 --> 00:45:21.276
back for that, for getting the

00:45:21.276 --> 00:45:21.646
movie.

00:45:22.366 --> 00:45:23.756
So, it would seem like HEIF

00:45:23.756 --> 00:45:25.026
would be an easy addition to

00:45:25.026 --> 00:45:26.516
this very flexible programming

00:45:26.516 --> 00:45:27.046
paradigm.

00:45:27.576 --> 00:45:28.946
Unfortunately, it's not.

00:45:30.116 --> 00:45:32.366
The incompatibility lies in the

00:45:32.366 --> 00:45:34.886
CoreMedia SampleBuffer which is

00:45:35.006 --> 00:45:36.416
and has been the coin of the

00:45:36.416 --> 00:45:38.086
realm in AVFoundation for many

00:45:38.086 --> 00:45:38.696
many years.

00:45:39.226 --> 00:45:41.446
We have used it for still images

00:45:41.766 --> 00:45:42.816
since iOS 4.

00:45:44.436 --> 00:45:45.886
It's a thin container for media

00:45:45.886 --> 00:45:47.496
data such as video samples,

00:45:47.676 --> 00:45:49.376
audio samples, text, closed

00:45:49.376 --> 00:45:50.066
captions.

00:45:51.356 --> 00:45:53.606
HEIF on the other hand is a file

00:45:53.606 --> 00:45:55.136
format, not a media format.

00:45:55.526 --> 00:45:57.026
It can hold many media types.

00:45:58.106 --> 00:46:00.256
Also, CMSampleBuffers can of

00:46:00.296 --> 00:46:02.546
course carry HEVC compressed

00:46:02.546 --> 00:46:05.286
video, but that HEV compressed,

00:46:05.286 --> 00:46:06.736
HEVC compressed video doesn't

00:46:06.736 --> 00:46:09.146
look like the HEIF containerized

00:46:09.146 --> 00:46:09.526
HEVC.

00:46:09.926 --> 00:46:11.366
Remember, HEIF likes to chop

00:46:11.366 --> 00:46:13.176
things up into individual tiles

00:46:13.536 --> 00:46:14.776
for quick decode.

00:46:15.236 --> 00:46:17.506
You can't store that kind of

00:46:17.506 --> 00:46:20.366
HEVC compression in a frame in a

00:46:20.366 --> 00:46:21.526
QuickTime movie, it would just

00:46:21.526 --> 00:46:22.646
confuse the decoder.

00:46:23.356 --> 00:46:24.236
So, at this point, you might be

00:46:24.236 --> 00:46:25.886
asking yourself, if we have this

00:46:25.886 --> 00:46:27.826
fundamental tension between file

00:46:27.826 --> 00:46:30.086
container and media container,

00:46:30.286 --> 00:46:31.796
how would we be able to use

00:46:31.866 --> 00:46:33.686
CMSampleBuffer for so many years

00:46:33.926 --> 00:46:35.926
with photo output and still

00:46:35.926 --> 00:46:36.496
image output?

00:46:37.236 --> 00:46:39.356
Well the answer is JPEG.

00:46:40.516 --> 00:46:42.016
We got away with this because of

00:46:42.016 --> 00:46:43.676
the happy coincidence that JPEG,

00:46:44.336 --> 00:46:46.516
the image codec, and JFIF the

00:46:46.516 --> 00:46:48.436
file format are virtually

00:46:48.436 --> 00:46:49.406
indistinguishable from one

00:46:49.406 --> 00:46:49.736
another.

00:46:50.206 --> 00:46:51.786
Both are acceptable as images,

00:46:52.366 --> 00:46:53.946
in another container such as a

00:46:53.946 --> 00:46:54.646
QuickTime movie.

00:46:56.026 --> 00:46:58.056
So, the answer to our quandary

00:46:58.056 --> 00:46:59.936
is to come up with a new purpose

00:46:59.936 --> 00:47:01.826
built in-memory wrapper for

00:47:01.826 --> 00:47:03.486
image results and we call that

00:47:03.486 --> 00:47:04.666
the AVCapturePhoto.

00:47:05.366 --> 00:47:06.746
It's our drop-in replacement for

00:47:06.746 --> 00:47:07.766
CMSampleBuffer.

00:47:08.596 --> 00:47:10.856
It is in fact faster than

00:47:10.856 --> 00:47:12.286
CMSampleBuffer because we are

00:47:12.286 --> 00:47:13.936
able to optimize delivery of it

00:47:13.936 --> 00:47:15.696
across the process boundary from

00:47:15.696 --> 00:47:17.156
the media server, so you get

00:47:17.156 --> 00:47:18.436
even better performance than you

00:47:18.436 --> 00:47:19.486
did in iOS 10.

00:47:20.766 --> 00:47:22.946
It's 100 percent immutable like

00:47:22.976 --> 00:47:24.836
the, unlike the CMSampleBuffer

00:47:24.836 --> 00:47:26.906
so that it's easier to share

00:47:26.906 --> 00:47:28.096
between code modules.

00:47:29.206 --> 00:47:30.346
It's also backed by

00:47:30.346 --> 00:47:31.606
containerized data.

00:47:31.606 --> 00:47:32.756
I'm going to talk more about

00:47:32.756 --> 00:47:34.386
that in a minute.

00:47:34.576 --> 00:47:35.546
Let's talk about some of its

00:47:35.546 --> 00:47:36.306
attributes.

00:47:36.896 --> 00:47:38.266
It has access to critical

00:47:38.266 --> 00:47:39.676
information about the photo such

00:47:39.676 --> 00:47:41.166
as the time at which it was

00:47:41.166 --> 00:47:43.786
captured, whether or not it's a

00:47:43.786 --> 00:47:46.486
RAW, Bayer RAW photo, and for

00:47:46.486 --> 00:47:48.016
uncompressed or RAW photos, you

00:47:48.016 --> 00:47:49.426
get access to the pixel buffer

00:47:49.426 --> 00:47:49.736
data.

00:47:50.746 --> 00:47:52.286
Also, side band information

00:47:52.286 --> 00:47:53.836
travels with the AVCapturePhoto

00:47:53.836 --> 00:47:56.706
too, such as the second smaller

00:47:56.706 --> 00:47:58.376
preview image that you can ask

00:47:58.376 --> 00:47:58.646
for.

00:47:59.476 --> 00:48:01.666
You can also now request a third

00:48:01.906 --> 00:48:04.316
image that's even smaller to be

00:48:04.316 --> 00:48:06.246
in embedded as a thumbnail in

00:48:06.246 --> 00:48:06.876
the container.

00:48:08.706 --> 00:48:10.076
An ImageIO property style

00:48:10.076 --> 00:48:11.566
metadata dictionary is provided

00:48:11.566 --> 00:48:13.666
that can contain Exif, or other

00:48:13.666 --> 00:48:14.796
metadata that you've come to

00:48:14.796 --> 00:48:15.206
expect.

00:48:16.176 --> 00:48:18.186
And with the iPhone 7 Plus dual

00:48:18.186 --> 00:48:20.386
camera, you can request that a

00:48:20.386 --> 00:48:22.196
depth data map be delivered with

00:48:22.196 --> 00:48:23.676
the AVCapturePhoto results as

00:48:23.676 --> 00:48:23.976
well.

00:48:25.456 --> 00:48:27.286
AVCapturePhoto also provides a

00:48:27.286 --> 00:48:28.876
number of convenience accessors

00:48:28.976 --> 00:48:31.036
such as a reference to the

00:48:31.036 --> 00:48:32.556
resolvedSettings object that we

00:48:32.556 --> 00:48:34.016
saw in previous slides.

00:48:34.516 --> 00:48:37.026
Also, it gives you easy access

00:48:37.026 --> 00:48:38.776
to bookkeeping about the photos.

00:48:38.876 --> 00:48:40.746
For instance, if you've fired

00:48:40.746 --> 00:48:42.836
off a request for a RAW plus

00:48:42.916 --> 00:48:44.396
HEIC, you would expect to get

00:48:44.436 --> 00:48:45.186
two photos.

00:48:45.536 --> 00:48:47.196
So, the photo count accessor

00:48:47.196 --> 00:48:48.736
will tell is this photo one or

00:48:48.736 --> 00:48:49.336
photo two?

00:48:50.706 --> 00:48:51.866
If this photo is part of a

00:48:51.866 --> 00:48:53.896
bracketed capture, such as an

00:48:53.896 --> 00:48:55.436
auto exposure bracket of three

00:48:55.436 --> 00:48:57.936
or four different EV values, it

00:48:57.936 --> 00:48:59.616
can tell you which bracket

00:48:59.616 --> 00:49:00.766
settings were applied to this

00:49:00.766 --> 00:49:02.906
particular result as well as its

00:49:03.076 --> 00:49:05.406
sequence number and whether lens

00:49:05.406 --> 00:49:07.116
stabilization was engaged.

00:49:09.156 --> 00:49:11.116
AVCapturePhoto also supports

00:49:11.196 --> 00:49:12.336
conversions to different

00:49:12.336 --> 00:49:14.386
formats, so it's friendly and

00:49:14.386 --> 00:49:16.616
able to move to other frameworks

00:49:16.616 --> 00:49:17.746
that you would use with image

00:49:17.746 --> 00:49:18.416
processing.

00:49:18.906 --> 00:49:20.306
First and foremost, it supports

00:49:20.306 --> 00:49:22.036
conversions to data

00:49:22.036 --> 00:49:23.546
representations if you just want

00:49:23.546 --> 00:49:24.336
to write to file.

00:49:24.896 --> 00:49:26.636
And it can produce a CGImage of

00:49:26.636 --> 00:49:28.426
either the full-size preview or

00:49:28.426 --> 00:49:31.076
the -- sorry the full-size photo

00:49:31.076 --> 00:49:31.976
or the preview photo.

00:49:32.006 --> 00:49:35.446
Now the mechanism for opting in

00:49:35.446 --> 00:49:37.176
to get an AVCapturePhoto instead

00:49:37.176 --> 00:49:38.826
of a CMSampleBuffer is just that

00:49:38.826 --> 00:49:40.166
you need to implement one new

00:49:40.166 --> 00:49:41.816
delegate method in your

00:49:41.816 --> 00:49:44.106
AVCapture PhotoCapture delegate,

00:49:44.106 --> 00:49:45.096
and that's this one here.

00:49:45.506 --> 00:49:46.846
It's very simple it just has

00:49:46.846 --> 00:49:47.786
three parameters.

00:49:48.146 --> 00:49:49.806
It gives you the AVCapturePhoto

00:49:50.306 --> 00:49:51.766
and optionally an error.

00:49:52.456 --> 00:49:54.686
Now, error or not, you always

00:49:54.686 --> 00:49:56.726
get an AVCapturePhoto with as

00:49:56.726 --> 00:49:58.026
much information about it as

00:49:58.026 --> 00:49:59.616
possible, even if there's no

00:49:59.616 --> 00:50:02.486
backing pixel data.

00:50:03.156 --> 00:50:05.296
The following two really lengthy

00:50:05.626 --> 00:50:06.906
delegate methods have been

00:50:06.906 --> 00:50:09.256
deprecated to help steer you

00:50:09.256 --> 00:50:10.526
towards the new and better.

00:50:11.396 --> 00:50:14.166
We used to have separate call

00:50:14.166 --> 00:50:16.186
backs for getting the RAW or the

00:50:16.216 --> 00:50:18.096
uncompressed or compressed,

00:50:18.206 --> 00:50:20.266
didFinishProcessingPhoto which

00:50:20.266 --> 00:50:21.756
would give you a CMSampleBuffer

00:50:21.756 --> 00:50:24.096
or didFinishProcessingRawPhoto

00:50:24.096 --> 00:50:24.866
which would give you a

00:50:24.866 --> 00:50:25.526
SampleBuffer.

00:50:26.246 --> 00:50:28.586
You needn't, you needn't use

00:50:28.586 --> 00:50:29.136
these anymore.

00:50:29.136 --> 00:50:31.086
You can just use the new single

00:50:31.516 --> 00:50:33.036
which subsumes both of them into

00:50:33.036 --> 00:50:33.366
one.

00:50:33.916 --> 00:50:37.026
All right, in iOS 10 we

00:50:37.026 --> 00:50:38.916
supported the following formats.

00:50:39.526 --> 00:50:40.856
For compression, all you could

00:50:40.856 --> 00:50:41.656
get was JPEG.

00:50:42.216 --> 00:50:43.366
For uncompressed you had your

00:50:43.366 --> 00:50:45.636
choice of two flavors of 420 or

00:50:45.636 --> 00:50:47.846
BGRA, and of course we supported

00:50:47.896 --> 00:50:48.546
Bayer RAW.

00:50:49.406 --> 00:50:52.186
Now, in iOS 11, in addition to

00:50:52.186 --> 00:50:54.496
adding HEVC support, we're

00:50:54.496 --> 00:50:55.736
adding a new dimension to this

00:50:55.736 --> 00:50:56.186
as well.

00:50:56.746 --> 00:50:58.226
Every image format that you,

00:50:58.536 --> 00:51:01.436
that you request is also backed

00:51:01.436 --> 00:51:03.926
by a file container format.

00:51:04.136 --> 00:51:06.106
In other words, implicitly,

00:51:06.406 --> 00:51:07.976
every image that you capture is

00:51:07.976 --> 00:51:09.086
being containerized.

00:51:09.686 --> 00:51:11.746
For HEVC the implicit container

00:51:11.746 --> 00:51:16.206
is HEIC, for JPEG it's JFIF, for

00:51:16.206 --> 00:51:17.536
the uncompressed formats it's

00:51:17.666 --> 00:51:20.066
TIFF, and for RAW formats as

00:51:20.066 --> 00:51:21.236
before it's DNG.

00:51:21.766 --> 00:51:22.986
Now, why would file

00:51:22.986 --> 00:51:24.246
containerization be a good

00:51:24.246 --> 00:51:24.616
thing?

00:51:25.456 --> 00:51:26.676
The answer is performance.

00:51:26.726 --> 00:51:28.336
Let me explain using a case

00:51:28.336 --> 00:51:28.626
study.

00:51:29.246 --> 00:51:31.176
So, here's the old way you would

00:51:31.176 --> 00:51:32.716
get a JPEG and write it to disc.

00:51:33.726 --> 00:51:35.456
PhotoOutput would deliver you a

00:51:35.456 --> 00:51:37.306
SampleBuffer with a full-sized

00:51:37.306 --> 00:51:40.326
image and a preview image and it

00:51:40.326 --> 00:51:41.776
would attach some metadata to it

00:51:41.776 --> 00:51:42.866
such as Exif.

00:51:42.966 --> 00:51:44.466
If you wanted to mutate that in

00:51:44.466 --> 00:51:45.756
any way, you would have to wait

00:51:45.756 --> 00:51:46.946
until it delivered the call back

00:51:47.286 --> 00:51:48.486
and then you would get the

00:51:48.486 --> 00:51:50.336
attachment that had the Exif,

00:51:50.766 --> 00:51:53.406
manipulate it, and re-add it to

00:51:53.406 --> 00:51:54.196
the SampleBuffer.

00:51:54.776 --> 00:51:56.026
Then when it came time for

00:51:56.026 --> 00:51:57.376
writing it to disc, you would

00:51:57.376 --> 00:51:58.646
call PhotoOutput's

00:51:59.106 --> 00:52:02.286
JPEGDataPhotoRepresentation and

00:52:02.286 --> 00:52:03.416
pass it the two buffers.

00:52:04.336 --> 00:52:06.586
Outcomes a JPEG data, ready to

00:52:06.586 --> 00:52:07.266
write to disc.

00:52:07.846 --> 00:52:09.966
While in code it looks simple, a

00:52:09.966 --> 00:52:11.386
lot is happening under the hood.

00:52:12.046 --> 00:52:13.616
Because we conflated preview

00:52:13.616 --> 00:52:15.266
image with embedded thumbnail

00:52:15.266 --> 00:52:16.776
image, we had to take something

00:52:16.776 --> 00:52:18.156
that was sized for the screen

00:52:18.526 --> 00:52:21.596
and scale it down, compress it

00:52:21.596 --> 00:52:23.846
to JPEG, incorporate all of your

00:52:23.846 --> 00:52:25.986
Exif changes, and rewrite the

00:52:25.986 --> 00:52:26.916
full-size image.

00:52:26.976 --> 00:52:29.816
So, a lot of scaling and

00:52:29.816 --> 00:52:32.006
compression done just because

00:52:32.006 --> 00:52:33.176
you wanted to include a

00:52:33.176 --> 00:52:35.366
thumbnail with your image and

00:52:35.486 --> 00:52:36.446
manipulate a little bit of

00:52:36.446 --> 00:52:37.026
metadata.

00:52:37.366 --> 00:52:38.426
Not efficient at all.

00:52:38.996 --> 00:52:40.926
Now in the new way,

00:52:40.926 --> 00:52:43.676
AVCapturePhoto lets you specify

00:52:43.676 --> 00:52:45.596
up front what you want in the

00:52:45.596 --> 00:52:46.136
container.

00:52:47.106 --> 00:52:48.376
If it has enough information to

00:52:48.376 --> 00:52:50.136
prepare the file container right

00:52:50.286 --> 00:52:52.266
the first time, then it's done

00:52:52.266 --> 00:52:53.426
before you ever get the first

00:52:53.426 --> 00:52:53.906
call back.

00:52:55.096 --> 00:52:56.166
The way you do this is you fill

00:52:56.166 --> 00:52:58.006
out some extra features in the

00:52:58.006 --> 00:52:59.106
AvCapturePhotoSettings.

00:52:59.576 --> 00:53:00.786
This time you can specify in

00:53:00.786 --> 00:53:02.566
advance the codec that you want,

00:53:02.566 --> 00:53:04.536
and optionally the file type.

00:53:05.526 --> 00:53:07.196
You specify metadata that you

00:53:07.196 --> 00:53:08.806
would like to add such as GPS

00:53:08.806 --> 00:53:10.036
location, you can now do this

00:53:10.066 --> 00:53:11.786
before you've even issued the

00:53:11.786 --> 00:53:12.406
request.

00:53:12.906 --> 00:53:14.096
You can also tell it I would

00:53:14.096 --> 00:53:15.376
like an embedded thumbnail and I

00:53:15.376 --> 00:53:19.066
would like it using these, these

00:53:19.066 --> 00:53:19.606
dimensions.

00:53:21.026 --> 00:53:22.516
You then submit your request to

00:53:22.516 --> 00:53:23.836
the AVCapturePhotoOutput and

00:53:23.836 --> 00:53:25.546
eventually it gives your

00:53:25.546 --> 00:53:28.246
delegate an AVCapturePhoto as

00:53:28.616 --> 00:53:29.526
its result.

00:53:30.166 --> 00:53:31.906
This AVCapturePhoto is backed by

00:53:31.906 --> 00:53:33.146
something that's already in a

00:53:33.226 --> 00:53:34.276
HEIC container.

00:53:34.776 --> 00:53:36.266
It's already been compressed in

00:53:36.266 --> 00:53:36.876
tiles.

00:53:37.456 --> 00:53:39.366
It's already embedded that

00:53:39.366 --> 00:53:40.636
thumbnail image that you asked

00:53:40.636 --> 00:53:41.066
it to.

00:53:41.066 --> 00:53:42.956
It's already put the metadata in

00:53:42.956 --> 00:53:43.946
the correct place.

00:53:44.856 --> 00:53:46.206
So, the final call that you

00:53:46.206 --> 00:53:47.926
would do to write it to disc

00:53:48.606 --> 00:53:51.646
photo.fileDataRepresentation is

00:53:51.646 --> 00:53:52.616
much simpler than in the

00:53:52.616 --> 00:53:53.596
previous example.

00:53:54.156 --> 00:53:56.246
All it's doing is a simple byte

00:53:56.246 --> 00:53:58.846
copy to NSData of the backing

00:53:58.846 --> 00:53:59.186
store.

00:53:59.816 --> 00:54:01.876
No additional compression, or

00:54:01.876 --> 00:54:02.976
scaling, or anything.

00:54:03.096 --> 00:54:04.826
It's all done in advance.

00:54:05.106 --> 00:54:06.496
This is much more efficient and

00:54:06.496 --> 00:54:07.496
especially when we're dealing

00:54:07.496 --> 00:54:10.026
with HEIF, it's necessary to get

00:54:10.236 --> 00:54:12.026
all of the performance of that

00:54:12.026 --> 00:54:13.286
great tiling format that I

00:54:13.456 --> 00:54:14.216
talked about earlier.

00:54:15.286 --> 00:54:16.986
Now, let's switch over to a few

00:54:16.986 --> 00:54:18.556
performance considerations with

00:54:18.556 --> 00:54:19.706
HEVC and HEIF.

00:54:20.386 --> 00:54:22.346
The first is what to do about

00:54:22.346 --> 00:54:24.026
photos that are taken during

00:54:24.026 --> 00:54:24.926
still capture.

00:54:26.406 --> 00:54:28.246
When you take a HEIC photo while

00:54:28.246 --> 00:54:30.016
capturing a movie, you should be

00:54:30.016 --> 00:54:31.736
aware that the same hardware

00:54:31.736 --> 00:54:33.336
block that's compressing video,

00:54:33.336 --> 00:54:35.596
that is the one that does H.264

00:54:35.596 --> 00:54:38.456
or HEVC compression, is also

00:54:38.456 --> 00:54:40.416
being asked to do double duty if

00:54:40.416 --> 00:54:43.156
you want to encode a HEIC file

00:54:43.366 --> 00:54:45.056
where HEVC is the compression

00:54:45.056 --> 00:54:45.476
format.

00:54:46.376 --> 00:54:48.636
That hardware block may be very

00:54:48.636 --> 00:54:50.486
busy indeed if you are capturing

00:54:50.486 --> 00:54:52.346
high-bandwidth video such as 4k

00:54:52.346 --> 00:54:54.216
30 or 1080p 60.

00:54:55.366 --> 00:54:56.726
Video is on a real-time

00:54:56.726 --> 00:54:58.706
deadline, so it gets priority

00:54:58.906 --> 00:54:59.546
over stills.

00:55:00.096 --> 00:55:01.196
This means that it may take

00:55:01.196 --> 00:55:02.756
longer to get your still results

00:55:02.756 --> 00:55:05.426
back and it also may mean that

00:55:05.426 --> 00:55:06.626
there are up to 20 percent

00:55:06.626 --> 00:55:07.896
larger than they would be

00:55:07.896 --> 00:55:09.766
otherwise because the encoder is

00:55:09.766 --> 00:55:11.096
too busy to use all of the

00:55:11.096 --> 00:55:12.536
features that it would if it

00:55:12.536 --> 00:55:13.586
didn't have to meet that

00:55:13.586 --> 00:55:15.366
real-time deadline for 30 or 60

00:55:15.366 --> 00:55:16.116
frames a second.

00:55:16.646 --> 00:55:18.566
So, our recommendation is if

00:55:18.566 --> 00:55:20.186
you're capturing video, and

00:55:20.186 --> 00:55:22.776
taking stills at the same time,

00:55:22.776 --> 00:55:23.926
you should use JPEG for the

00:55:23.926 --> 00:55:26.676
photos to leave the encoder for

00:55:26.676 --> 00:55:29.046
HEVC as available as possible

00:55:29.046 --> 00:55:29.656
for the video.

00:55:32.296 --> 00:55:34.946
Another concern is HEVC and HEIF

00:55:35.026 --> 00:55:35.766
bursts.

00:55:36.096 --> 00:55:37.726
This is where you mash on the

00:55:37.726 --> 00:55:40.506
button and you're trying to get

00:55:40.506 --> 00:55:41.986
a constant frame rate maybe 10

00:55:41.986 --> 00:55:44.826
frames a second of capture

00:55:44.826 --> 00:55:45.326
images.

00:55:46.236 --> 00:55:47.976
HEVC encode obviously is doing a

00:55:47.976 --> 00:55:49.416
lot more work than JPEG did,

00:55:49.916 --> 00:55:51.416
it's delivering a file that's

00:55:51.856 --> 00:55:53.856
less half the size of JPEG.

00:55:54.276 --> 00:55:56.086
Therefore, HEVC encode does take

00:55:56.086 --> 00:55:56.556
longer.

00:55:57.366 --> 00:55:59.286
Now we've benchmarked and we're

00:55:59.286 --> 00:56:03.266
comfortable that HEVC HEIF can

00:56:03.266 --> 00:56:07.666
meet the 10 fps minimum

00:56:07.666 --> 00:56:09.806
requirement for bursts, but if

00:56:09.806 --> 00:56:11.356
you need to capture at a higher

00:56:11.356 --> 00:56:12.636
frame rate than that, our

00:56:12.636 --> 00:56:14.346
recommendation is to go back to

00:56:14.346 --> 00:56:15.406
JPEG for bursts.

00:56:15.936 --> 00:56:18.766
And we've heard a lot about

00:56:18.766 --> 00:56:20.346
compression today and I feel I

00:56:20.346 --> 00:56:21.716
would remiss if I didn't give

00:56:21.716 --> 00:56:24.386
you my thoughts on WWDC.

00:56:24.446 --> 00:56:26.946
It is after all a compression

00:56:26.946 --> 00:56:27.296
talk.

00:56:28.006 --> 00:56:29.936
So, I can't just leave this

00:56:30.116 --> 00:56:30.866
dangling there.

00:56:31.846 --> 00:56:33.806
World Wide Developer Conference,

00:56:34.636 --> 00:56:35.666
nine syllables.

00:56:36.796 --> 00:56:40.466
W-W-D-C, eight syllables.

00:56:41.086 --> 00:56:42.776
That is like the worst

00:56:42.776 --> 00:56:44.026
compression format ever.

00:56:44.086 --> 00:56:47.916
It's lossy, it's like .1 to 1

00:56:47.916 --> 00:56:49.186
compression ratio, which is even

00:56:49.186 --> 00:56:50.296
worse than lossless JPEG.

00:56:51.026 --> 00:56:53.236
So, please as a service to me,

00:56:53.626 --> 00:56:55.256
for the rest of the conference,

00:56:55.296 --> 00:56:56.706
which you please only refer to

00:56:56.706 --> 00:56:59.386
conference as WWDC or

00:56:59.576 --> 00:57:00.356
Wuh-Duck.

00:57:00.356 --> 00:57:03.916
[laughter] All right.

00:57:04.036 --> 00:57:05.106
Let's summarize what we learned

00:57:05.106 --> 00:57:05.356
today.

00:57:06.796 --> 00:57:09.116
HEVC movies are up to 40 percent

00:57:09.116 --> 00:57:10.726
smaller for general content than

00:57:10.726 --> 00:57:13.226
H.264 and for camera content on

00:57:13.226 --> 00:57:15.456
iOS they are 2x smaller.

00:57:16.166 --> 00:57:18.106
Also, HEVC playback is supported

00:57:18.106 --> 00:57:20.226
everywhere on iOS 11 and High

00:57:20.226 --> 00:57:22.276
Sierra, sometimes with software

00:57:22.436 --> 00:57:23.516
sometimes with hardware.

00:57:24.186 --> 00:57:26.366
And to create HEVC content you

00:57:26.366 --> 00:57:28.496
need to opt in to new capture

00:57:28.496 --> 00:57:30.396
APIs or new export APIs.

00:57:30.876 --> 00:57:32.266
Also, we learned about HEIC

00:57:32.266 --> 00:57:34.606
files that they are twice as

00:57:34.606 --> 00:57:37.836
small as JPEGs and that decode

00:57:37.836 --> 00:57:39.616
is supported everywhere on iOS

00:57:39.616 --> 00:57:42.246
11 and macOS where capture is

00:57:42.246 --> 00:57:45.396
supported iOS only and where we

00:57:45.396 --> 00:57:47.066
have an A10 chip, and you do

00:57:47.066 --> 00:57:47.786
that using the new

00:57:47.786 --> 00:57:49.526
AVCapturePhoto interface.

00:57:50.046 --> 00:57:52.856
For more information, here is

00:57:52.996 --> 00:57:54.526
the URL for today's session.

00:57:55.836 --> 00:57:57.496
I also wanted to point you to

00:57:57.496 --> 00:57:58.876
some sister sessions to this

00:57:58.876 --> 00:58:00.686
one, the first one in the list

00:58:00.886 --> 00:58:02.266
High Efficiency Image File

00:58:02.266 --> 00:58:03.866
Format is one that went straight

00:58:03.866 --> 00:58:04.456
to video.

00:58:04.996 --> 00:58:06.256
This is where we really delve

00:58:06.256 --> 00:58:09.596
deeply into the bits in the HEIF

00:58:09.596 --> 00:58:09.986
file.

00:58:10.436 --> 00:58:11.726
It's a great, great

00:58:12.206 --> 00:58:13.006
presentation.

00:58:13.006 --> 00:58:14.136
You should definitely listen to

00:58:14.136 --> 00:58:14.286
it.

00:58:14.636 --> 00:58:16.086
It's performed by Davide so you

00:58:16.086 --> 00:58:17.336
get the nice Italian accent

00:58:17.336 --> 00:58:18.456
going at the same time.

00:58:19.456 --> 00:58:21.366
Also, the Introducing HEIF and

00:58:21.366 --> 00:58:23.016
HEVC which was one Tuesday,

00:58:23.286 --> 00:58:25.136
which gave a higher-level

00:58:25.306 --> 00:58:26.776
introduction to what we talked

00:58:26.776 --> 00:58:27.346
about today.

00:58:27.716 --> 00:58:29.246
And finally, the depth sessions

00:58:29.246 --> 00:58:30.206
that I've made several

00:58:30.206 --> 00:58:31.926
references to, they have several

00:58:31.926 --> 00:58:33.466
segues to the auxiliary image

00:58:33.466 --> 00:58:34.856
format that we use to store

00:58:35.516 --> 00:58:36.756
depth in HEIF.

00:58:37.996 --> 00:58:39.446
Thank you and enjoy the rest of

00:58:39.446 --> 00:58:39.746
the show.

00:58:40.516 --> 00:58:44.500
[ Applause ]
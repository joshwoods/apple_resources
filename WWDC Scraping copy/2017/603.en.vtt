WEBVTT

00:00:07.516 --> 00:00:16.500
[ Crowd Sounds ]

00:00:24.516 --> 00:00:26.736
[ Applause ]

00:00:27.236 --> 00:00:28.126
>> Good morning, everyone.

00:00:28.746 --> 00:00:30.476
Welcome to VR with Metal 2.

00:00:31.156 --> 00:00:32.646
My name is Rav Dhiraj, and I'm a

00:00:32.646 --> 00:00:34.466
member of the GPU Software Team

00:00:34.716 --> 00:00:35.226
at Apple.

00:00:35.676 --> 00:00:37.446
So, as you saw in our

00:00:37.446 --> 00:00:39.006
Introducing Metal 2 Session,

00:00:39.416 --> 00:00:40.726
we've enabled some great new

00:00:40.726 --> 00:00:41.626
features this year.

00:00:42.436 --> 00:00:43.546
And in this session, I'll be

00:00:43.606 --> 00:00:45.476
focusing specifically on the

00:00:45.476 --> 00:00:46.986
support for VR that we're adding

00:00:46.986 --> 00:00:47.666
with Metal 2.

00:00:48.226 --> 00:00:51.426
So, I'll start with a brief

00:00:51.506 --> 00:00:53.396
summary of what we've enabled in

00:00:53.396 --> 00:00:54.626
macOS High Sierra.

00:00:54.626 --> 00:00:57.106
And then, take a deep dive into

00:00:57.106 --> 00:00:58.386
what's required to build a VR

00:00:58.386 --> 00:00:58.866
app.

00:00:59.186 --> 00:01:00.976
And then, end by providing some

00:01:00.976 --> 00:01:02.576
details on how you can take

00:01:02.576 --> 00:01:04.046
advantage of the new external

00:01:04.046 --> 00:01:05.906
GPU support that we've added to

00:01:05.906 --> 00:01:06.436
the OS.

00:01:09.256 --> 00:01:09.516
All right.

00:01:09.516 --> 00:01:11.166
I hope everyone here knows what

00:01:11.216 --> 00:01:12.276
virtual reality is.

00:01:12.786 --> 00:01:14.706
But just in case, it's am

00:01:14.706 --> 00:01:17.526
immersive 360-degree 3D

00:01:17.606 --> 00:01:20.246
experience, with direct object

00:01:20.246 --> 00:01:21.726
manipulation using controllera.

00:01:22.366 --> 00:01:24.476
And an interactive room sized

00:01:24.476 --> 00:01:25.676
environment that you can

00:01:25.676 --> 00:01:27.476
explore, thanks to highly

00:01:27.476 --> 00:01:28.826
accurate motion tracking.

00:01:30.036 --> 00:01:31.306
Now, we at Apple think that this

00:01:31.306 --> 00:01:32.716
is a great new medium for

00:01:32.716 --> 00:01:34.786
developers like you to create

00:01:34.786 --> 00:01:36.646
new experiences for our users.

00:01:37.276 --> 00:01:40.956
And Metal 2 enables this support

00:01:40.956 --> 00:01:41.846
in three ways.

00:01:42.516 --> 00:01:46.766
First, by providing a fast path

00:01:46.846 --> 00:01:48.316
to present the frame directly to

00:01:48.316 --> 00:01:49.776
the VR headset with our new

00:01:50.296 --> 00:01:52.006
Direct to Display capability.

00:01:53.616 --> 00:01:56.136
Second, by enabling new features

00:01:56.136 --> 00:01:57.696
like Viewport Array that are

00:01:57.756 --> 00:02:00.026
specifically targeting VR.

00:02:01.506 --> 00:02:03.006
And finally, by providing that

00:02:03.076 --> 00:02:04.366
foundational support for

00:02:04.366 --> 00:02:06.096
external GPUs, so that

00:02:06.096 --> 00:02:07.796
developers have a broader range

00:02:07.796 --> 00:02:08.705
of Mac hardware.

00:02:08.946 --> 00:02:10.616
Of VR capable Mac hardware to

00:02:10.616 --> 00:02:11.066
work on.

00:02:11.606 --> 00:02:13.566
So, let's get right into what

00:02:13.566 --> 00:02:15.566
we've enabled with macOS High

00:02:15.696 --> 00:02:16.036
Sierra.

00:02:17.056 --> 00:02:18.726
So, we've added built-in plug

00:02:18.726 --> 00:02:20.186
and play support for the HTC

00:02:20.396 --> 00:02:21.616
Vive VR headset.

00:02:21.616 --> 00:02:24.286
And this headset works in

00:02:24.286 --> 00:02:26.346
conjunction with Valve SteamVR

00:02:26.346 --> 00:02:28.436
runtime, which provides a number

00:02:28.436 --> 00:02:30.206
of services, including the VR

00:02:30.206 --> 00:02:31.086
compositor.

00:02:32.556 --> 00:02:33.946
Valve is also bringing their

00:02:34.006 --> 00:02:36.796
open VR APIs to macOS, so that

00:02:36.796 --> 00:02:39.136
you guys can create VR apps that

00:02:39.136 --> 00:02:40.136
work with SteamVR.

00:02:40.416 --> 00:02:41.466
We've been working really

00:02:41.466 --> 00:02:43.006
closely with Valve over the last

00:02:43.106 --> 00:02:45.216
year to align our releases, and

00:02:45.216 --> 00:02:47.256
both SteamVR and OpenVR are

00:02:47.726 --> 00:02:49.566
available to download in beta

00:02:49.636 --> 00:02:50.746
form, this week.

00:02:51.386 --> 00:02:55.376
So, before I go on, I'd like to

00:02:55.406 --> 00:02:57.156
describe what the VR compositor

00:02:57.156 --> 00:02:57.856
actually does.

00:02:59.056 --> 00:03:00.616
So, in a nutshell, it distorts

00:03:00.716 --> 00:03:02.766
the image that your app renders

00:03:02.816 --> 00:03:05.106
to account for the lens optics

00:03:05.106 --> 00:03:06.156
in the VR headset.

00:03:07.186 --> 00:03:08.526
In this example, you can see the

00:03:08.686 --> 00:03:10.296
barrel distortion that the

00:03:10.296 --> 00:03:12.106
compositor is applying to

00:03:12.106 --> 00:03:13.516
account for the pincushion

00:03:13.516 --> 00:03:14.676
effect of the lenses.

00:03:15.676 --> 00:03:16.696
Now, in practice, there's

00:03:16.696 --> 00:03:18.306
actually a lot more complexity

00:03:18.306 --> 00:03:19.056
under the covers.

00:03:19.356 --> 00:03:20.746
And the compositor had to handle

00:03:20.746 --> 00:03:21.916
things like chromatic

00:03:21.916 --> 00:03:24.316
aberration, and also presenting

00:03:24.316 --> 00:03:26.176
a Chaperone UI, so that

00:03:26.206 --> 00:03:28.146
developers know the bounds of

00:03:28.286 --> 00:03:31.256
their VR space.

00:03:31.466 --> 00:03:32.316
All right.

00:03:32.316 --> 00:03:33.436
Now, that you have built-in

00:03:33.486 --> 00:03:36.386
support for a VR headset, a VR

00:03:36.896 --> 00:03:39.066
compositor with SteamVR, and an

00:03:39.066 --> 00:03:41.296
API to write to, let's dive

00:03:41.396 --> 00:03:42.976
right into how you build a VR

00:03:42.976 --> 00:03:43.286
app.

00:03:44.756 --> 00:03:46.096
Well, we have two options.

00:03:46.866 --> 00:03:49.156
You first, is to use an existing

00:03:49.156 --> 00:03:50.996
game engine that has VR support.

00:03:51.786 --> 00:03:53.426
This is a great option that many

00:03:53.426 --> 00:03:55.126
developers prefer, because it

00:03:55.126 --> 00:03:56.566
hides some of the complexities

00:03:56.566 --> 00:03:57.726
of the VR compositor.

00:03:58.456 --> 00:04:00.356
It also provides a familiar

00:04:00.356 --> 00:04:01.786
content creation tool chain.

00:04:03.156 --> 00:04:04.916
Now, your second option, is to

00:04:04.916 --> 00:04:06.906
write a native VR app that calls

00:04:06.906 --> 00:04:08.106
open VR, directly.

00:04:08.926 --> 00:04:10.766
This gives your app full control

00:04:11.086 --> 00:04:12.716
of rendering and synchronization

00:04:12.716 --> 00:04:13.756
with the VR compositor.

00:04:14.236 --> 00:04:15.236
But at the cost of some

00:04:15.236 --> 00:04:16.366
additional complexity.

00:04:16.935 --> 00:04:19.906
Which path you take depends on

00:04:19.906 --> 00:04:20.875
the goals of your app.

00:04:21.486 --> 00:04:23.346
Let's start by talking a bit

00:04:23.846 --> 00:04:24.946
about the game engines.

00:04:26.796 --> 00:04:29.306
So, you saw Epic's Unreal Engine

00:04:29.426 --> 00:04:31.316
4 in action in the keynote, and

00:04:31.316 --> 00:04:32.976
it's a powerful platform on

00:04:32.976 --> 00:04:34.066
which to build your VR

00:04:34.066 --> 00:04:34.966
experiences.

00:04:36.246 --> 00:04:38.416
VR support will be coming later,

00:04:38.416 --> 00:04:40.676
this year, and you can find

00:04:40.676 --> 00:04:42.646
tutorials and other information

00:04:42.646 --> 00:04:43.586
on Epic's website.

00:04:44.966 --> 00:04:46.656
We're also really excited that

00:04:46.696 --> 00:04:48.936
Unity is bringing VR support to

00:04:48.936 --> 00:04:50.596
macOS in a future release of

00:04:50.626 --> 00:04:51.216
their engine.

00:04:51.896 --> 00:04:53.116
We've been working closely with

00:04:53.116 --> 00:04:54.296
them to ensure that the engine

00:04:54.296 --> 00:04:56.266
is optimized for both VR

00:04:56.266 --> 00:04:58.586
playback and development using

00:04:58.586 --> 00:04:58.876
Metal.

00:05:02.076 --> 00:05:03.396
So, I'd like to take a moment,

00:05:03.396 --> 00:05:04.636
at this point, to talk about a

00:05:04.766 --> 00:05:06.936
specific Unity title called

00:05:06.936 --> 00:05:08.336
Space Pirate Trainer.

00:05:08.806 --> 00:05:10.396
So, we've been collaborating

00:05:10.396 --> 00:05:12.556
with Unity and I-Illusions to

00:05:12.556 --> 00:05:14.596
bring an early preview of Space

00:05:14.666 --> 00:05:16.196
Pirate Trainer to macOS.

00:05:16.916 --> 00:05:19.836
And the speed at with I-Illusion

00:05:20.066 --> 00:05:21.916
was able to bring their app to

00:05:21.916 --> 00:05:23.176
our platform was truly

00:05:23.236 --> 00:05:23.716
astounding.

00:05:23.716 --> 00:05:25.916
They had a working build in just

00:05:25.916 --> 00:05:28.536
a few hours, then a stable fully

00:05:28.536 --> 00:05:30.386
playable game in just a handful

00:05:30.386 --> 00:05:30.786
of days.

00:05:31.926 --> 00:05:33.476
We've been having tremendous fun

00:05:33.566 --> 00:05:35.166
playing with this game, and

00:05:35.206 --> 00:05:36.336
think that it's a great

00:05:36.336 --> 00:05:38.516
representation of the type of VR

00:05:38.516 --> 00:05:39.886
experience that you can build

00:05:40.146 --> 00:05:40.766
with unity.

00:05:42.176 --> 00:05:43.166
We hope you get a chance to

00:05:43.166 --> 00:05:44.136
check it out at WWDC.

00:05:44.136 --> 00:05:45.936
We think you'll love it, as

00:05:45.936 --> 00:05:46.226
well.

00:05:47.556 --> 00:05:50.636
So, Unity and Unreal Engine 4

00:05:50.636 --> 00:05:52.376
are two great options for VR

00:05:52.376 --> 00:05:53.136
development.

00:05:54.536 --> 00:05:56.536
But you can, of course, choose

00:05:56.536 --> 00:05:58.136
to write a native SteamVR app,

00:05:58.496 --> 00:05:59.756
that calls the open VR

00:05:59.846 --> 00:06:00.766
framework, directly.

00:06:01.566 --> 00:06:02.906
Now, we'll have details on how

00:06:02.906 --> 00:06:03.996
you can add the framework to

00:06:03.996 --> 00:06:05.756
your app, later in the session.

00:06:06.006 --> 00:06:07.436
But you can download binaries

00:06:07.476 --> 00:06:09.386
and API documentation at the

00:06:09.386 --> 00:06:10.366
OpenVR GitHub.

00:06:12.776 --> 00:06:14.286
There'll also be a Metal

00:06:14.346 --> 00:06:16.416
specific sample app available to

00:06:16.416 --> 00:06:17.786
download in the near future.

00:06:18.626 --> 00:06:19.676
But to give you a taste of

00:06:19.676 --> 00:06:21.556
what's involved, I'd like to

00:06:21.556 --> 00:06:23.616
now, provide a primer on VR app

00:06:23.616 --> 00:06:25.316
development in a segment that I

00:06:25.316 --> 00:06:27.026
like to call VR App Building

00:06:27.026 --> 00:06:27.526
101.

00:06:28.666 --> 00:06:29.856
So, we're going to cover a few

00:06:29.856 --> 00:06:30.356
things, here.

00:06:31.106 --> 00:06:32.706
We'll start with an overview of

00:06:32.766 --> 00:06:34.176
some of the challenges involved

00:06:34.176 --> 00:06:35.246
in VR development.

00:06:36.496 --> 00:06:38.376
And then, talk a bit about some

00:06:38.376 --> 00:06:40.206
unique considerations on our

00:06:40.206 --> 00:06:40.836
platform.

00:06:40.916 --> 00:06:43.096
And then, take a deep dive into

00:06:43.096 --> 00:06:45.306
the anatomy of a VR frame.

00:06:46.156 --> 00:06:47.136
And then, end with some best

00:06:47.226 --> 00:06:48.826
practices specific to VR apps.

00:06:50.326 --> 00:06:51.246
So, we've got a lot to cover,

00:06:51.246 --> 00:06:51.446
here.

00:06:51.636 --> 00:06:53.066
So, let's get started with the

00:06:53.066 --> 00:06:53.536
overview.

00:06:54.106 --> 00:06:57.586
So, a traditional non-VR work

00:06:57.586 --> 00:07:00.166
load targeting a 60Hz display

00:07:00.706 --> 00:07:03.696
has around 16.7 milliseconds to

00:07:03.696 --> 00:07:06.986
do work for the frame.

00:07:07.166 --> 00:07:09.986
And in many cases, the app has

00:07:10.396 --> 00:07:12.856
the entire frame budget to do

00:07:12.856 --> 00:07:14.016
work on the GPU.

00:07:14.566 --> 00:07:17.266
A VR workload, on the other

00:07:17.326 --> 00:07:19.656
hand, has to target a 90 frame

00:07:19.656 --> 00:07:20.676
per second display.

00:07:20.676 --> 00:07:22.766
And it needs to hit this target

00:07:22.806 --> 00:07:24.686
to achieve a smooth stutter-free

00:07:24.686 --> 00:07:26.446
experience on a headset like the

00:07:26.446 --> 00:07:26.806
Vive.

00:07:27.756 --> 00:07:29.186
So, this reduces the available

00:07:29.186 --> 00:07:31.116
frame budget to around 11

00:07:31.116 --> 00:07:31.886
milliseconds.

00:07:33.276 --> 00:07:35.186
Additionally, the VR compositor

00:07:35.186 --> 00:07:37.296
has to do work on the GPU to

00:07:37.296 --> 00:07:39.136
prepare the frame for the VR

00:07:39.136 --> 00:07:39.616
headset.

00:07:40.716 --> 00:07:42.136
This can take up to 1

00:07:42.136 --> 00:07:44.266
millisecond, leaving you app an

00:07:44.266 --> 00:07:46.446
effective frame time budget of

00:07:46.446 --> 00:07:48.026
around 10 milliseconds.

00:07:48.796 --> 00:07:51.726
Which is about 60% of the non-VR

00:07:51.726 --> 00:07:52.036
case.

00:07:52.776 --> 00:07:55.636
And if that wasn't enough, your

00:07:55.636 --> 00:07:57.656
app also has to do more work

00:07:57.656 --> 00:07:58.276
every frame.

00:07:59.306 --> 00:08:01.256
This includes stereo rendering

00:08:01.556 --> 00:08:03.106
for the left and right eye.

00:08:04.096 --> 00:08:05.786
And also, rendering to a higher

00:08:05.786 --> 00:08:07.416
resolution, in many cases.

00:08:08.476 --> 00:08:10.086
The Vive headset has a

00:08:10.086 --> 00:08:12.836
resolution of 2160 x 1200.

00:08:13.186 --> 00:08:15.476
That's 25% more pixels than a

00:08:15.476 --> 00:08:16.586
1080 display.

00:08:17.576 --> 00:08:19.676
Additionally, many VR apps

00:08:19.676 --> 00:08:22.696
render at a 1.2 to 1.4 X scale

00:08:22.746 --> 00:08:24.216
factor to further improve

00:08:24.216 --> 00:08:24.776
quality.

00:08:25.366 --> 00:08:28.316
So, in summary, your app has a

00:08:28.316 --> 00:08:30.246
lot more work to do in less

00:08:30.336 --> 00:08:30.626
time.

00:08:31.526 --> 00:08:32.645
Welcome to VR development.

00:08:34.596 --> 00:08:35.186
All right.

00:08:35.186 --> 00:08:36.535
Let's talk about some platform

00:08:36.535 --> 00:08:37.336
specifics.

00:08:38.336 --> 00:08:40.535
So, Metal 2 introduces a new

00:08:40.535 --> 00:08:42.806
Direct to Display capability for

00:08:42.806 --> 00:08:44.166
supported headsets like the

00:08:44.166 --> 00:08:44.596
Vive.

00:08:45.476 --> 00:08:47.886
This is a low latency path that

00:08:47.926 --> 00:08:49.446
bypasses the OS window

00:08:49.446 --> 00:08:51.376
compositor, and gives the VR

00:08:51.376 --> 00:08:54.256
compositor, like SteamVR, the

00:08:54.256 --> 00:08:55.896
direct ability to present a

00:08:55.896 --> 00:08:57.646
surface onto the VR headset.

00:08:58.326 --> 00:09:00.146
This avoids any pixel processing

00:09:00.146 --> 00:09:03.546
or additional copies by the OS.

00:09:03.806 --> 00:09:05.276
Now, it's worth noting that in

00:09:05.346 --> 00:09:06.926
order to guarantee this fast

00:09:06.996 --> 00:09:09.846
path, that macOS does not treat

00:09:09.896 --> 00:09:11.366
VR headsets as displays.

00:09:11.956 --> 00:09:13.146
They're hidden from the system

00:09:13.286 --> 00:09:15.376
and offer no extended desktop

00:09:15.376 --> 00:09:16.056
capabilities.

00:09:16.746 --> 00:09:20.676
So, to summarize, we move from a

00:09:20.676 --> 00:09:22.976
model where you can present or

00:09:23.516 --> 00:09:25.276
an app presents to a display

00:09:25.366 --> 00:09:26.336
through the OS window

00:09:26.336 --> 00:09:27.026
compositor.

00:09:28.316 --> 00:09:30.086
To one where a VR app can

00:09:30.136 --> 00:09:32.456
present to a headset directly

00:09:32.496 --> 00:09:33.756
through the VR compositor.

00:09:34.566 --> 00:09:36.446
And that's our Direct to Display

00:09:36.516 --> 00:09:39.716
capability for VR with Metal 2.

00:09:41.416 --> 00:09:41.976
All right.

00:09:42.206 --> 00:09:43.556
Keeping with the theme of macOS

00:09:43.616 --> 00:09:46.126
platform specifics, let's talk a

00:09:46.126 --> 00:09:48.026
bit about how your app selects a

00:09:48.026 --> 00:09:49.296
Metal device to use.

00:09:50.276 --> 00:09:52.266
So, in macOS, the VR compositor

00:09:52.316 --> 00:09:54.546
can query the OS to find the

00:09:54.546 --> 00:09:57.006
Metal device for the GPU that

00:09:57.006 --> 00:09:58.346
the headset is attached to.

00:09:59.556 --> 00:10:00.786
And for performance reasons,

00:10:01.356 --> 00:10:02.776
your app will want to select the

00:10:02.776 --> 00:10:04.766
same device that the compositor

00:10:04.766 --> 00:10:04.976
is using.

00:10:06.266 --> 00:10:07.226
So, we've worked with Valve to

00:10:07.226 --> 00:10:08.476
make sure that there's an API to

00:10:08.476 --> 00:10:10.566
do this, simply called

00:10:10.856 --> 00:10:13.186
GetOutputDevice to get the Metal

00:10:13.186 --> 00:10:14.266
device that you should render

00:10:14.266 --> 00:10:14.506
to.

00:10:14.876 --> 00:10:15.486
It's that simple.

00:10:18.486 --> 00:10:20.416
Now, let's talk about managing

00:10:20.416 --> 00:10:22.236
drawable surfaces on macOS.

00:10:23.576 --> 00:10:25.376
So, the VR compositor and your

00:10:25.376 --> 00:10:28.126
app each maintain separate pools

00:10:28.396 --> 00:10:29.576
of drawable surfaces.

00:10:30.196 --> 00:10:32.276
And in a typical frame your app

00:10:32.556 --> 00:10:34.176
will render to textures that it

00:10:34.176 --> 00:10:36.926
owns, submit these to the VR

00:10:36.926 --> 00:10:37.736
compositor.

00:10:38.806 --> 00:10:40.666
These will get composited onto a

00:10:40.666 --> 00:10:42.186
surface that the compositor

00:10:42.186 --> 00:10:44.076
owns, and that's the surface

00:10:44.076 --> 00:10:45.246
that'll get presented to the

00:10:45.246 --> 00:10:45.766
headset.

00:10:47.006 --> 00:10:49.716
And on macOS, IO surfaces are

00:10:49.716 --> 00:10:51.376
ideal for transferring this

00:10:51.556 --> 00:10:53.496
rendered data from your app to

00:10:53.496 --> 00:10:54.286
the compositor.

00:10:54.816 --> 00:10:56.346
So, make sure that you create

00:10:56.346 --> 00:10:58.066
Metal textures that are backed

00:10:58.416 --> 00:10:59.566
by IO surfaces.

00:11:01.076 --> 00:11:02.596
As a refresher, let's take a

00:11:02.656 --> 00:11:03.926
quick look at how you create

00:11:03.926 --> 00:11:04.606
those textures.

00:11:06.616 --> 00:11:08.046
So, you'll want to build a

00:11:08.156 --> 00:11:09.766
texture descriptor that

00:11:09.766 --> 00:11:11.436
specifies the Render Target

00:11:11.476 --> 00:11:13.266
Usage flag, since your app will

00:11:13.266 --> 00:11:14.406
be rendering into it.

00:11:15.276 --> 00:11:17.416
But also, the Shader Read Usage

00:11:17.416 --> 00:11:17.766
flag.

00:11:18.146 --> 00:11:19.336
Since the compositor will be

00:11:19.426 --> 00:11:20.926
sourcing it as an input.

00:11:21.406 --> 00:11:24.726
And then, to create your left

00:11:24.946 --> 00:11:26.976
and right eye Textures, you

00:11:27.066 --> 00:11:29.966
simply pass IO surfaces that you

00:11:29.966 --> 00:11:31.586
previously allocated and this

00:11:31.626 --> 00:11:33.096
Texture descriptor to

00:11:33.096 --> 00:11:34.696
newTextureWithDescriptor.

00:11:35.366 --> 00:11:35.596
All right.

00:11:35.716 --> 00:11:36.786
I'd like to now, take a few

00:11:36.786 --> 00:11:39.266
minutes to talk or to describe a

00:11:39.266 --> 00:11:40.676
typical frame in a VR app.

00:11:41.576 --> 00:11:43.076
This is important, because your

00:11:43.076 --> 00:11:45.086
app and the VR compositor need

00:11:45.086 --> 00:11:46.376
to work in lock step.

00:11:47.436 --> 00:11:49.186
As I noted before, the rendered

00:11:49.186 --> 00:11:50.826
output of your app will be

00:11:50.826 --> 00:11:53.096
passed to the VR compositor for

00:11:53.096 --> 00:11:54.336
additional processing on the

00:11:54.336 --> 00:11:54.926
GPU.

00:11:55.726 --> 00:11:57.756
And since the GPU is a shared

00:11:57.806 --> 00:12:00.596
resource, synchronization and

00:12:00.596 --> 00:12:02.486
when work is scheduled matters.

00:12:03.086 --> 00:12:05.436
So, let's start at the beginning

00:12:05.436 --> 00:12:06.026
of the frame.

00:12:06.946 --> 00:12:08.706
Your app will need to query the

00:12:08.706 --> 00:12:10.506
VR system to get the headset

00:12:10.506 --> 00:12:12.196
poses that it needs to render

00:12:12.196 --> 00:12:12.746
the frame.

00:12:13.936 --> 00:12:15.766
For SteamVr, this is done by the

00:12:15.866 --> 00:12:17.316
WaitGetPoses call.

00:12:18.366 --> 00:12:20.406
And then, your app can encode

00:12:20.406 --> 00:12:22.116
the rendered commands for that

00:12:22.246 --> 00:12:24.246
frame immediately after getting

00:12:24.246 --> 00:12:24.946
those inputs.

00:12:25.536 --> 00:12:28.406
And then, once you've encoded

00:12:28.406 --> 00:12:30.136
your command buffer, you can

00:12:30.176 --> 00:12:31.836
commit it to Metal to queue onto

00:12:31.836 --> 00:12:32.576
the GPU.

00:12:33.146 --> 00:12:35.296
And then, submit your left and

00:12:35.296 --> 00:12:37.956
right eye textures to SteamVR.

00:12:38.946 --> 00:12:40.666
This'll wake the compositor so

00:12:40.666 --> 00:12:42.606
it can start encoding its GPU

00:12:42.606 --> 00:12:43.896
work for the frame.

00:12:44.476 --> 00:12:46.976
And then, since ordered

00:12:46.976 --> 00:12:49.286
execution matters, your app will

00:12:49.286 --> 00:12:50.816
also need to signal the VR

00:12:50.816 --> 00:12:53.526
compositor when work that is

00:12:53.596 --> 00:12:54.896
sent to the GPU has been

00:12:54.896 --> 00:12:55.436
scheduled.

00:12:56.656 --> 00:12:58.566
So, for a Metal SteamVR app, you

00:12:58.646 --> 00:13:00.706
simply wait until your command

00:13:00.706 --> 00:13:02.746
buffer has been scheduled, and

00:13:02.746 --> 00:13:04.496
then, you can call the SteamVR

00:13:04.496 --> 00:13:06.406
PostPresentHandoff function.

00:13:07.136 --> 00:13:08.886
This'll signal the VR compositor

00:13:09.136 --> 00:13:10.726
that it can commit its work to

00:13:10.726 --> 00:13:13.026
the GPU and it'll get queued up

00:13:13.476 --> 00:13:14.366
in the right order.

00:13:14.366 --> 00:13:16.886
So, let's see what that would

00:13:16.886 --> 00:13:18.346
look like in your draw loop.

00:13:18.706 --> 00:13:20.276
So, at the top of your loop

00:13:20.686 --> 00:13:22.006
you'd have your WaitGetPoses

00:13:22.006 --> 00:13:23.876
call, to gather the inputs from

00:13:23.876 --> 00:13:24.396
the headset.

00:13:25.656 --> 00:13:27.196
You then, build your command

00:13:27.196 --> 00:13:29.536
buffer to render your scene and

00:13:29.536 --> 00:13:30.706
commit it to the GPU.

00:13:31.826 --> 00:13:33.146
And then, at this point, you'll

00:13:33.236 --> 00:13:35.086
submit your left and right eye

00:13:35.186 --> 00:13:36.576
textures to SteamVR.

00:13:37.906 --> 00:13:39.876
And then, once you've waited for

00:13:39.876 --> 00:13:40.796
that command buffer to be

00:13:40.836 --> 00:13:43.466
scheduled, you can call

00:13:43.466 --> 00:13:45.086
PostPresentHandoff to tell the

00:13:45.086 --> 00:13:47.226
VR compositor that it's now free

00:13:47.456 --> 00:13:49.966
to commit work to the GPU, as

00:13:50.856 --> 00:13:51.016
well.

00:13:51.926 --> 00:13:53.496
So, one more note before I move

00:13:53.496 --> 00:13:53.726
on.

00:13:55.056 --> 00:13:57.046
It's worth noting that as we

00:13:57.046 --> 00:13:58.486
extend this diagram to include

00:13:58.486 --> 00:14:00.676
the next frame, it's

00:14:00.986 --> 00:14:04.086
WaitGetPoses and not the

00:14:04.196 --> 00:14:06.556
vertical blank that defines the

00:14:06.556 --> 00:14:08.046
start of the frame for your app.

00:14:08.896 --> 00:14:09.956
This is an important thing to

00:14:09.956 --> 00:14:11.026
keep in mind, and we'll be

00:14:11.026 --> 00:14:12.116
coming back to this, very

00:14:12.116 --> 00:14:12.556
shortly.

00:14:13.136 --> 00:14:15.016
All right.

00:14:15.986 --> 00:14:17.396
Let's move on to talk about some

00:14:17.396 --> 00:14:18.416
best practices.

00:14:19.026 --> 00:14:22.626
So, the first is to avoid

00:14:22.626 --> 00:14:24.596
introducing a GPU bubble at the

00:14:24.596 --> 00:14:26.146
start of your frame, while

00:14:26.146 --> 00:14:27.836
encoding commands on the CPU.

00:14:29.036 --> 00:14:31.646
So, helpfully, SteamVR offers a

00:14:31.646 --> 00:14:33.216
useful mechanism to let you

00:14:33.216 --> 00:14:35.206
start work for that frame early,

00:14:35.626 --> 00:14:37.216
by giving your app a two to

00:14:37.276 --> 00:14:38.856
three millisecond running start.

00:14:40.286 --> 00:14:41.226
So, his should look very

00:14:41.276 --> 00:14:41.786
familiar.

00:14:42.456 --> 00:14:43.836
By aligning the start of your

00:14:43.836 --> 00:14:46.126
frame with WaitGetPoses, you'll

00:14:46.126 --> 00:14:47.416
ensure that you're taking

00:14:47.416 --> 00:14:48.966
advantage of this optimization

00:14:49.226 --> 00:14:50.576
and getting that running start.

00:14:54.076 --> 00:14:54.636
All right.

00:14:54.716 --> 00:14:57.076
Next, make sure that your app is

00:14:57.076 --> 00:14:59.146
not building large monolithic

00:14:59.196 --> 00:15:00.396
command buffers before

00:15:00.396 --> 00:15:02.146
committing them to the GPU, as

00:15:02.146 --> 00:15:03.936
this can also introduce GPU

00:15:03.936 --> 00:15:04.456
bubbles.

00:15:05.496 --> 00:15:07.966
Instead, you want to split your

00:15:07.966 --> 00:15:09.416
command buffers where possible

00:15:09.656 --> 00:15:11.206
and commit them as you go, to

00:15:11.206 --> 00:15:13.466
maximize GPU utilization in the

00:15:13.466 --> 00:15:13.866
frame.

00:15:14.406 --> 00:15:18.246
So, the next optimization that

00:15:18.246 --> 00:15:19.886
we recommend is to try and

00:15:19.956 --> 00:15:22.046
coalesce your left and right eye

00:15:22.046 --> 00:15:22.846
draws, together.

00:15:25.036 --> 00:15:26.836
The Metal 2 Viewport Array

00:15:26.836 --> 00:15:28.296
feature provides a great

00:15:28.296 --> 00:15:30.296
mechanism for you to do this, by

00:15:30.296 --> 00:15:32.036
letting your app select a per

00:15:32.096 --> 00:15:34.176
primitive destination viewport

00:15:34.596 --> 00:15:35.546
in the vertex shader.

00:15:36.326 --> 00:15:37.796
This can substantially reduce

00:15:37.796 --> 00:15:39.666
your draw call overhead, as you

00:15:39.666 --> 00:15:41.256
can now render to both the left

00:15:41.916 --> 00:15:43.626
and the right eye with a single

00:15:43.626 --> 00:15:44.186
draw call.

00:15:45.386 --> 00:15:46.726
So, let's take a look at an

00:15:46.726 --> 00:15:48.296
example of how you can adopt

00:15:48.676 --> 00:15:50.236
Viewport Array for your Metal

00:15:50.236 --> 00:15:51.746
app using instancing.

00:15:53.136 --> 00:15:54.016
So, the first thing I want to

00:15:54.016 --> 00:15:55.616
point out is that you'll need to

00:15:55.616 --> 00:15:57.446
create a texture that's twice as

00:15:57.446 --> 00:15:58.956
wide, because you'll now be

00:15:58.956 --> 00:16:00.356
rendering both the left and

00:16:00.356 --> 00:16:02.266
right eye scene to the same

00:16:02.436 --> 00:16:02.906
texture.

00:16:03.836 --> 00:16:05.766
And then, you simply create your

00:16:05.766 --> 00:16:07.386
Viewpoint array that defines the

00:16:07.386 --> 00:16:10.026
bounds for your left and your

00:16:10.026 --> 00:16:11.596
right eye viewports.

00:16:12.786 --> 00:16:13.906
And then, you can pass this

00:16:13.946 --> 00:16:15.216
Viewport array to your render

00:16:15.216 --> 00:16:16.976
commanding coder using the new

00:16:17.416 --> 00:16:18.426
setViewports API.

00:16:19.586 --> 00:16:20.586
And then, at this point, you'll

00:16:20.586 --> 00:16:21.826
want to make an instance to

00:16:21.976 --> 00:16:23.706
DrawPrimitives call with an

00:16:23.766 --> 00:16:26.286
instance count of 2 to issue the

00:16:26.286 --> 00:16:27.366
draw to your left and right

00:16:27.416 --> 00:16:28.066
Viewports.

00:16:29.286 --> 00:16:31.046
We'll be using the instance ID

00:16:31.366 --> 00:16:33.836
as our eye index in the vertex

00:16:33.836 --> 00:16:34.146
shader.

00:16:35.286 --> 00:16:36.136
So, let's take a look at that

00:16:36.136 --> 00:16:36.786
vertex shader.

00:16:37.406 --> 00:16:39.536
So, the first thing I want to

00:16:39.536 --> 00:16:42.126
point out is that the viewport

00:16:42.456 --> 00:16:44.096
is selected by the new viewport

00:16:44.316 --> 00:16:45.436
underscore array underscore

00:16:45.436 --> 00:16:46.276
index attribute.

00:16:47.756 --> 00:16:49.276
And then, as I previously noted,

00:16:49.406 --> 00:16:50.166
we're using the instance

00:16:50.166 --> 00:16:52.486
underscore id as our eye index.

00:16:52.826 --> 00:16:54.186
And we'll be able to use it to

00:16:54.186 --> 00:16:56.416
access our viewport dependent

00:16:56.416 --> 00:16:57.936
data like this model view

00:16:57.966 --> 00:16:59.646
projection matrix in this

00:16:59.646 --> 00:17:00.176
example.

00:17:00.716 --> 00:17:03.166
And then, finally, you do want

00:17:03.166 --> 00:17:05.006
to associate your viewport index

00:17:05.476 --> 00:17:06.705
with the instance underscore id

00:17:06.746 --> 00:17:08.006
so that the right viewport is

00:17:08.066 --> 00:17:10.056
selected when rasterizing your

00:17:10.056 --> 00:17:10.435
image.

00:17:11.465 --> 00:17:13.465
And that's how you use the new

00:17:13.465 --> 00:17:15.286
Viewport Array feature to reduce

00:17:15.346 --> 00:17:17.906
the draw call cost in your VR

00:17:18.856 --> 00:17:18.976
apps.

00:17:20.296 --> 00:17:20.846
All right.

00:17:21.006 --> 00:17:22.386
The final optimization that I

00:17:22.386 --> 00:17:24.006
want to talk about, today, is

00:17:24.066 --> 00:17:25.465
really a general best practice.

00:17:25.465 --> 00:17:27.406
You want to try and reduce the

00:17:27.406 --> 00:17:29.716
number of pixels that you're

00:17:29.716 --> 00:17:30.876
shading every frame.

00:17:31.406 --> 00:17:33.236
So, due to the nature of the

00:17:33.236 --> 00:17:35.816
lens warp, about 15% of your

00:17:35.816 --> 00:17:37.876
rendered scene is not actually

00:17:37.876 --> 00:17:39.386
visible on the VR headset.

00:17:40.136 --> 00:17:41.626
This is represented by the blue

00:17:41.626 --> 00:17:42.586
regions in this image.

00:17:43.536 --> 00:17:45.976
Luckily, SteamVR offers a mesh

00:17:46.056 --> 00:17:47.786
based stencil mask that is

00:17:47.866 --> 00:17:49.466
specific to the Vive headset

00:17:49.626 --> 00:17:51.006
that you can use to cull these

00:17:51.066 --> 00:17:51.576
pixels.

00:17:52.096 --> 00:17:54.296
It's really easy to use and

00:17:54.326 --> 00:17:55.996
provides a substantial benefit.

00:17:55.996 --> 00:17:56.866
All right.

00:17:57.876 --> 00:18:00.586
That brings us to the end of our

00:18:00.666 --> 00:18:01.976
brief journey into building a VR

00:18:01.976 --> 00:18:02.306
app.

00:18:02.766 --> 00:18:03.716
So, with that background

00:18:03.716 --> 00:18:05.256
covered, I'd like to now

00:18:05.256 --> 00:18:06.916
introduce Nat Brown from Valve

00:18:06.996 --> 00:18:08.836
Software, to come onstage and

00:18:08.836 --> 00:18:10.886
talk a bit more about SteamVR on

00:18:10.886 --> 00:18:11.386
macOS.

00:18:12.016 --> 00:18:13.726
[ Applause ]

00:18:13.726 --> 00:18:14.126
Thanks, Nat.

00:18:14.356 --> 00:18:14.746
>> Thanks, Rav.

00:18:16.146 --> 00:18:17.516
Hi, everybody.

00:18:17.566 --> 00:18:20.486
I'm Nat. I work on VR at Valve.

00:18:20.786 --> 00:18:22.546
So, if you don't know Valve,

00:18:22.546 --> 00:18:24.076
we're a game company.

00:18:24.076 --> 00:18:25.186
We distribute games and we have

00:18:25.186 --> 00:18:28.636
a community of gamers that play

00:18:28.636 --> 00:18:29.276
on Steam.

00:18:29.636 --> 00:18:30.896
It turns out, games are actually

00:18:30.896 --> 00:18:33.266
a super-interesting crucible for

00:18:33.266 --> 00:18:34.186
user interface and

00:18:34.186 --> 00:18:35.226
human/computer interaction.

00:18:35.676 --> 00:18:36.766
And at Valve, we do a lot of

00:18:36.766 --> 00:18:39.006
experiments around games and

00:18:39.006 --> 00:18:39.306
input.

00:18:40.156 --> 00:18:42.356
So, years of VR prototypes

00:18:42.886 --> 00:18:44.186
really didn't click, for us, for

00:18:44.186 --> 00:18:45.346
making games or any other kind

00:18:45.346 --> 00:18:45.826
of content.

00:18:46.366 --> 00:18:47.866
Until we found this sweet

00:18:47.866 --> 00:18:50.106
combination of 90 hertz low

00:18:50.106 --> 00:18:52.096
persistence displays, accurate

00:18:52.096 --> 00:18:53.716
room scale tracking, with two

00:18:53.716 --> 00:18:54.536
track controllers.

00:18:55.276 --> 00:18:57.056
We consider this a magical

00:18:57.056 --> 00:18:58.076
threshold for VR.

00:18:58.726 --> 00:19:00.826
I like to think of it as kind of

00:19:00.826 --> 00:19:02.776
similar to how when you first

00:19:03.246 --> 00:19:04.546
used a smartphone with low

00:19:04.546 --> 00:19:06.216
latency accurate touch, it

00:19:06.216 --> 00:19:07.066
really felt magical.

00:19:07.396 --> 00:19:08.536
That's what this magical

00:19:08.536 --> 00:19:11.526
threshold is, for VR.

00:19:11.746 --> 00:19:12.916
Once room scale VR really

00:19:12.916 --> 00:19:14.216
clicked for us, we knew that we

00:19:14.216 --> 00:19:16.166
could build VR games and VR

00:19:16.166 --> 00:19:16.496
content.

00:19:17.516 --> 00:19:19.366
We license aspects of our VR

00:19:19.366 --> 00:19:22.296
technology like base stations,

00:19:22.466 --> 00:19:24.686
headset lens designs, and so

00:19:24.686 --> 00:19:26.686
forth, non-exclusively to

00:19:26.686 --> 00:19:28.156
partners like HTC and LG.

00:19:28.156 --> 00:19:30.016
And we have a big program that

00:19:30.016 --> 00:19:31.486
licenses Lighthouse tracking

00:19:31.486 --> 00:19:32.816
technology to lots of different

00:19:32.816 --> 00:19:33.216
partners.

00:19:33.756 --> 00:19:37.196
Our approach to the software

00:19:37.196 --> 00:19:38.336
stack you've heard a little bit

00:19:38.336 --> 00:19:39.906
about, already, is called the

00:19:39.906 --> 00:19:42.186
SteamVr runtime.

00:19:42.416 --> 00:19:43.936
SteamVr has an application

00:19:43.936 --> 00:19:45.506
model, up above, and a hardware

00:19:45.506 --> 00:19:46.876
and driver model, down below.

00:19:47.016 --> 00:19:49.266
Our goal here, is to promote

00:19:49.266 --> 00:19:50.606
experiments in VR, because we're

00:19:50.606 --> 00:19:52.096
really in the early days of what

00:19:52.096 --> 00:19:53.546
VR is and what the content's

00:19:53.546 --> 00:19:55.006
going to be like.

00:19:55.546 --> 00:19:57.236
We wanted to make this model so

00:19:57.236 --> 00:19:58.746
that people could experiment in

00:19:58.746 --> 00:19:59.576
VR hardware and content and

00:19:59.576 --> 00:19:59.976
reduce risk.

00:20:00.046 --> 00:20:03.036
So, you can go out, maybe not

00:20:03.036 --> 00:20:04.246
you, but some of you can go out

00:20:04.536 --> 00:20:06.186
and design a new headset or a

00:20:06.186 --> 00:20:08.346
new tracking system, or new

00:20:08.346 --> 00:20:08.896
controllers.

00:20:09.066 --> 00:20:10.526
And then, you can come to an

00:20:10.526 --> 00:20:12.146
Open VR platform, and you can

00:20:12.146 --> 00:20:13.526
write a driver that plugs right

00:20:13.526 --> 00:20:13.726
in.

00:20:14.036 --> 00:20:15.116
And you'll have access to all

00:20:15.116 --> 00:20:16.606
the existing content that's

00:20:16.606 --> 00:20:17.336
already running.

00:20:18.056 --> 00:20:19.596
That will give you real world

00:20:19.596 --> 00:20:21.666
tests that make your hardware

00:20:21.666 --> 00:20:21.966
better.

00:20:21.966 --> 00:20:23.266
Because you and your customers

00:20:23.496 --> 00:20:25.426
can compare your new idea

00:20:25.426 --> 00:20:26.566
directly with other hardware

00:20:26.566 --> 00:20:27.326
that's already out there.

00:20:27.826 --> 00:20:29.246
So, hardware developers don't

00:20:29.246 --> 00:20:30.566
have to develop custom content

00:20:30.916 --> 00:20:32.206
and content developers don't

00:20:32.206 --> 00:20:33.926
have to bet on which hardware

00:20:33.926 --> 00:20:34.486
will win.

00:20:34.486 --> 00:20:36.476
They can just focus on making

00:20:37.236 --> 00:20:38.906
great content.

00:20:38.906 --> 00:20:41.486
So, applications link to the

00:20:41.486 --> 00:20:42.336
Open VR framework.

00:20:42.336 --> 00:20:44.286
It's a really tiny library, and

00:20:44.286 --> 00:20:45.786
all it knows how to do is define

00:20:46.106 --> 00:20:47.166
the runtime that's currently

00:20:47.166 --> 00:20:47.576
installed.

00:20:47.576 --> 00:20:49.336
So, it finds this VR client

00:20:49.336 --> 00:20:50.546
library, that's a shared

00:20:50.546 --> 00:20:51.816
library, and that either

00:20:51.816 --> 00:20:53.556
connects to or launches the

00:20:53.556 --> 00:20:55.006
other runtime processes of

00:20:55.006 --> 00:20:55.596
SteamVr.

00:20:55.996 --> 00:20:57.156
The vrmonitor process.

00:20:57.156 --> 00:20:58.516
You're going to see a lot of

00:20:58.516 --> 00:21:00.066
that little window.

00:21:00.066 --> 00:21:01.486
It's a UI and a setting

00:21:01.486 --> 00:21:02.066
application.

00:21:02.066 --> 00:21:03.586
It shows you the state of any

00:21:03.586 --> 00:21:04.536
attached headsets and

00:21:04.536 --> 00:21:05.886
controllers, and the tracking

00:21:05.886 --> 00:21:06.326
sensors.

00:21:06.836 --> 00:21:11.896
The vrserver is in charge of

00:21:12.006 --> 00:21:13.656
keeping track of drivers,

00:21:13.836 --> 00:21:14.976
loading alternate drivers.

00:21:14.976 --> 00:21:16.806
And it puts poses and other

00:21:16.806 --> 00:21:19.076
information into shared memory.

00:21:19.076 --> 00:21:21.136
So, that your application and

00:21:21.136 --> 00:21:22.656
the rest of the SteamVR runtime

00:21:22.706 --> 00:21:24.836
have access to it.

00:21:25.106 --> 00:21:26.336
The vrcompositor, you just heard

00:21:26.336 --> 00:21:28.066
a little bit about, this process

00:21:28.276 --> 00:21:30.696
is sort of like the Windows

00:21:30.696 --> 00:21:31.086
server.

00:21:31.326 --> 00:21:33.026
It draws scenes and overlays to

00:21:33.026 --> 00:21:33.636
the headset.

00:21:33.636 --> 00:21:35.506
And it corrects images for lens

00:21:35.536 --> 00:21:36.666
distortion, color.

00:21:36.886 --> 00:21:37.716
And one of the things that's

00:21:37.716 --> 00:21:39.526
sort of under the hood, that you

00:21:39.526 --> 00:21:42.656
may not understand, is it

00:21:42.656 --> 00:21:43.746
corrects for smearing and

00:21:43.746 --> 00:21:44.726
ghosting under motion.

00:21:45.086 --> 00:21:48.506
And it also, fades into a stable

00:21:48.506 --> 00:21:50.216
tracking area when applications

00:21:50.216 --> 00:21:51.446
fail to meet frame rate.

00:21:51.716 --> 00:21:52.846
Because we don't want people to

00:21:52.846 --> 00:21:53.846
fall over or bump into

00:21:53.846 --> 00:21:54.186
something.

00:21:54.526 --> 00:21:55.926
So, the vrcompositor

00:21:55.926 --> 00:21:56.946
communicates with Metal, like

00:21:56.946 --> 00:21:57.386
you heard.

00:21:57.596 --> 00:21:59.066
It presents directly to the

00:21:59.066 --> 00:22:00.026
headset through the Direct to

00:22:00.026 --> 00:22:01.546
Display Metal 2 API.

00:22:03.146 --> 00:22:03.526
Let's see.

00:22:03.526 --> 00:22:05.216
Last, but not least, the mighty

00:22:05.496 --> 00:22:06.266
vrdashboard.

00:22:06.486 --> 00:22:09.216
That is a piece of UI that lets

00:22:09.216 --> 00:22:10.606
you select applications.

00:22:10.936 --> 00:22:12.176
It lets you control volume,

00:22:12.576 --> 00:22:13.636
other system settings.

00:22:14.486 --> 00:22:16.256
We provide a default one that

00:22:16.256 --> 00:22:17.586
shows you your Steam library,

00:22:17.586 --> 00:22:18.606
unless you choose applications.

00:22:18.956 --> 00:22:20.096
But there's actually an API.

00:22:20.096 --> 00:22:21.206
So, you can write your own

00:22:21.446 --> 00:22:22.736
dashboard application, as well.

00:22:22.966 --> 00:22:24.646
So, Valve and Apple, we started

00:22:24.646 --> 00:22:25.886
working together more closely,

00:22:26.086 --> 00:22:27.336
about a year ago.

00:22:27.646 --> 00:22:28.776
And our port to Metal from

00:22:28.776 --> 00:22:30.286
OpenGL, it didn't cost us very

00:22:30.286 --> 00:22:30.566
much.

00:22:30.686 --> 00:22:31.856
Metal is a really cool API.

00:22:31.856 --> 00:22:34.116
And it was critical for us to

00:22:34.116 --> 00:22:35.716
get VR up and performing.

00:22:35.876 --> 00:22:38.166
Our biggest request to Apple, a

00:22:38.166 --> 00:22:39.836
year ago, was for this Direct to

00:22:39.836 --> 00:22:40.536
Display feature.

00:22:40.986 --> 00:22:42.126
Because it's critical to ensure

00:22:42.126 --> 00:22:43.476
that the VR compositor has the

00:22:43.476 --> 00:22:45.846
fastest time predictable path to

00:22:45.846 --> 00:22:46.966
the headset display panels.

00:22:47.906 --> 00:22:50.046
We also, really needed super

00:22:50.046 --> 00:22:52.166
accurate low variance VBL,

00:22:52.276 --> 00:22:53.606
vertical blank, events.

00:22:53.956 --> 00:22:54.726
So, that we could set the

00:22:54.726 --> 00:22:56.216
cadence of the VR frame

00:22:56.216 --> 00:22:57.856
presentation timing, and we

00:22:57.856 --> 00:22:58.936
could predict those poses

00:22:58.936 --> 00:23:00.086
accurately.

00:23:00.316 --> 00:23:01.736
Predicting the pose accurately

00:23:01.966 --> 00:23:04.156
is actually more important than

00:23:04.156 --> 00:23:06.016
the time between motion happens

00:23:06.316 --> 00:23:07.366
and when the display happens.

00:23:07.366 --> 00:23:08.496
If we know when it's going to

00:23:08.496 --> 00:23:09.436
be, that's actually more

00:23:09.436 --> 00:23:09.886
important.

00:23:10.656 --> 00:23:12.816
Finally, we hit some speed bumps

00:23:12.816 --> 00:23:13.836
around inter-process and

00:23:13.836 --> 00:23:15.456
inter-thread synchronization.

00:23:15.816 --> 00:23:17.196
Once everything else was working

00:23:17.196 --> 00:23:18.516
really well, Metal was blazing

00:23:18.516 --> 00:23:21.596
fast, we had really tight VBL,

00:23:21.596 --> 00:23:22.816
but we still were having some

00:23:22.816 --> 00:23:24.116
synchronization problems.

00:23:24.316 --> 00:23:25.906
But Apple helped us find better

00:23:25.906 --> 00:23:28.066
ways to signal and synchronize

00:23:28.066 --> 00:23:29.446
with low scheduling variance

00:23:29.446 --> 00:23:30.716
between all the processes and

00:23:30.716 --> 00:23:31.376
thread involved.

00:23:33.286 --> 00:23:37.416
Okay. So, my diagram of a VR

00:23:37.496 --> 00:23:38.306
frame is a little more

00:23:38.306 --> 00:23:39.236
complicated.

00:23:39.466 --> 00:23:40.686
Most of you are never going to

00:23:40.686 --> 00:23:41.776
look under the hood, this far.

00:23:41.776 --> 00:23:42.686
But I thought I'd show it to

00:23:42.686 --> 00:23:43.066
you, anyway.

00:23:43.556 --> 00:23:46.746
So, the low persistence OLED of

00:23:46.746 --> 00:23:48.646
the HTC Vibe uses global

00:23:48.646 --> 00:23:49.126
illumination.

00:23:49.996 --> 00:23:52.146
All of the pixels of the display

00:23:52.146 --> 00:23:54.226
flash for a tiny period, all at

00:23:54.226 --> 00:23:54.726
once.

00:23:54.726 --> 00:23:56.276
And this is common in VR,

00:23:56.276 --> 00:23:57.556
because heads move really

00:23:57.556 --> 00:23:57.936
quickly.

00:23:58.426 --> 00:24:00.676
And we want to make sure that

00:24:00.676 --> 00:24:02.506
the image doesn't smear or tear

00:24:02.506 --> 00:24:03.526
in front of the user.

00:24:03.886 --> 00:24:05.566
So, the panel illuminates for

00:24:05.566 --> 00:24:07.776
about two milliseconds, one

00:24:07.776 --> 00:24:09.266
frame after it is presented by

00:24:09.266 --> 00:24:10.966
the GPU, because the panel takes

00:24:11.036 --> 00:24:12.326
time to charge before it can do

00:24:12.326 --> 00:24:14.096
that global illumination pulse.

00:24:14.916 --> 00:24:16.266
So, over here, that's the

00:24:16.266 --> 00:24:17.076
photons coming out.

00:24:17.076 --> 00:24:18.046
We're going to follow this red

00:24:18.106 --> 00:24:19.246
frame through this sequence.

00:24:19.636 --> 00:24:23.436
So, way out here is the photons

00:24:23.436 --> 00:24:24.236
coming out.

00:24:24.836 --> 00:24:25.916
Because of this timing,

00:24:26.316 --> 00:24:27.706
applications typically pick up a

00:24:27.756 --> 00:24:28.926
pose, like you heard before,

00:24:28.986 --> 00:24:30.986
from IVR compositor wakeup

00:24:30.986 --> 00:24:31.406
poses.

00:24:31.646 --> 00:24:33.946
So, wakeup poses stalls and

00:24:33.946 --> 00:24:36.096
returns with a pose for that

00:24:36.096 --> 00:24:37.356
future firing of photons.

00:24:37.616 --> 00:24:39.526
So, the rendering is happening

00:24:39.526 --> 00:24:41.146
here, and you present it there,

00:24:41.366 --> 00:24:42.386
here in the middle.

00:24:42.516 --> 00:24:43.796
But the photons don't go out

00:24:43.796 --> 00:24:44.056
there.

00:24:44.056 --> 00:24:46.916
So, we've had to predict a pose

00:24:46.916 --> 00:24:49.426
about 25 milliseconds out.

00:24:50.076 --> 00:24:54.206
So, 25 milliseconds is two

00:24:54.206 --> 00:24:56.206
frames plus the little tiny bit

00:24:56.366 --> 00:24:57.186
of running start.

00:24:57.236 --> 00:24:58.036
And you heard how running

00:24:58.036 --> 00:25:00.516
start's very important, because

00:25:00.516 --> 00:25:01.706
we want to give you as much of

00:25:01.706 --> 00:25:04.146
that 11 milliseconds of GPU to

00:25:04.146 --> 00:25:05.826
get the most excellent pixels up

00:25:05.826 --> 00:25:07.376
in front of the users, that you

00:25:08.216 --> 00:25:08.306
can.

00:25:08.396 --> 00:25:11.006
So, one last thing that's

00:25:11.006 --> 00:25:11.656
happening, here.

00:25:11.726 --> 00:25:12.736
You see this frame actually

00:25:12.736 --> 00:25:14.156
stretches back all the way to

00:25:14.156 --> 00:25:14.926
the beginning of the slide.

00:25:15.416 --> 00:25:16.906
And that's because this

00:25:16.906 --> 00:25:19.486
application, and your game

00:25:19.486 --> 00:25:20.526
engine might be doing this under

00:25:20.526 --> 00:25:22.566
the covers, is kind of more

00:25:22.566 --> 00:25:23.136
complicated.

00:25:23.356 --> 00:25:24.726
It has some physics and input

00:25:24.726 --> 00:25:26.586
event processing, that it needs

00:25:26.586 --> 00:25:27.116
to do.

00:25:27.146 --> 00:25:28.386
And that's costly work that's

00:25:28.386 --> 00:25:29.526
going to take some CPU time,

00:25:29.526 --> 00:25:29.916
over here.

00:25:30.496 --> 00:25:32.046
But that code actually needs

00:25:32.106 --> 00:25:33.286
pose information, also.

00:25:33.936 --> 00:25:35.346
It needs to know when the

00:25:35.346 --> 00:25:36.526
buttons were pressed and where

00:25:36.526 --> 00:25:37.366
the controllers were.

00:25:37.366 --> 00:25:38.456
Maybe it's interpolating

00:25:38.746 --> 00:25:39.576
something having to do with

00:25:39.576 --> 00:25:41.546
motion, or you're blocking

00:25:41.796 --> 00:25:42.796
something, or you're firing

00:25:42.796 --> 00:25:43.136
something.

00:25:43.556 --> 00:25:47.026
So, this thread actually, it's

00:25:47.026 --> 00:25:48.146
going to wake up at around the

00:25:48.146 --> 00:25:49.626
same time, because wakeup poses

00:25:49.626 --> 00:25:51.476
gives it this important kind of

00:25:51.586 --> 00:25:52.126
synch point.

00:25:52.466 --> 00:25:53.866
But it's going to be calling a

00:25:53.866 --> 00:25:55.346
different API, because it's

00:25:55.346 --> 00:25:56.756
trying to get a pose much

00:25:56.756 --> 00:25:57.346
further out.

00:25:57.536 --> 00:25:59.106
It's looking 36 milliseconds

00:25:59.106 --> 00:26:00.776
out, and so, it's going to be

00:26:00.776 --> 00:26:02.746
calling the getDevice to

00:26:02.746 --> 00:26:04.026
absolute tracking poses.

00:26:04.406 --> 00:26:06.946
So, I tell you this just so you

00:26:06.946 --> 00:26:09.636
know, Open VR has some pretty

00:26:09.636 --> 00:26:12.706
deep APIs for you to tune your

00:26:12.706 --> 00:26:13.746
applications so that you're

00:26:13.746 --> 00:26:15.856
predicting where the headset and

00:26:15.856 --> 00:26:16.806
where the controllers are going

00:26:16.806 --> 00:26:18.806
to be very accurately, based on

00:26:19.236 --> 00:26:21.696
where you need them to be, where

00:26:21.696 --> 00:26:23.106
your code needs them to be.

00:26:23.106 --> 00:26:24.946
So, the point of wakeup poses is

00:26:24.946 --> 00:26:26.526
it gives you a predictable point

00:26:26.526 --> 00:26:28.176
in time at running start, so you

00:26:28.176 --> 00:26:29.376
always know when those photons

00:26:29.376 --> 00:26:30.506
are going to come out.

00:26:31.536 --> 00:26:35.316
So, last but not least, let's

00:26:35.316 --> 00:26:36.276
talk about what you need to do

00:26:36.276 --> 00:26:37.426
to get up and running with

00:26:37.426 --> 00:26:38.366
SteamVr and macOS.

00:26:38.366 --> 00:26:39.656
So, first of all, it's a tool in

00:26:39.656 --> 00:26:41.816
Steam, as a developer gets

00:26:41.816 --> 00:26:43.546
started by installing Steam and

00:26:43.546 --> 00:26:44.906
registering for a free account.

00:26:45.696 --> 00:26:47.626
And if you don't use Steam, you

00:26:47.626 --> 00:26:47.996
should.

00:26:49.336 --> 00:26:51.086
Next, install SteamVR itself.

00:26:51.166 --> 00:26:53.066
SteamVR is under the Library

00:26:53.066 --> 00:26:53.946
menu in Tools.

00:26:54.296 --> 00:26:56.046
Search for SteamVR, right click

00:26:56.046 --> 00:26:58.366
on it, choose the Properties,

00:26:58.366 --> 00:27:00.246
choose the Beta tab, and opt

00:27:00.246 --> 00:27:00.776
into the Beta.

00:27:01.246 --> 00:27:02.006
For now, it's a beta.

00:27:02.316 --> 00:27:03.206
Then, install it.

00:27:03.206 --> 00:27:04.566
We'll be keeping SteamVr up to

00:27:04.566 --> 00:27:05.946
date as we fix any bugs that you

00:27:05.946 --> 00:27:06.246
find.

00:27:07.166 --> 00:27:08.346
Finally, you want to download

00:27:08.346 --> 00:27:09.896
the Open VR headers and the

00:27:09.896 --> 00:27:11.686
framework from GitHub.

00:27:11.686 --> 00:27:12.796
And I've put a link, right up

00:27:12.846 --> 00:27:15.406
there, for you in the slides.

00:27:15.556 --> 00:27:17.096
So, here's the funky part.

00:27:17.656 --> 00:27:18.886
You need to include that Open VR

00:27:18.886 --> 00:27:20.766
bootstrapping framework inside

00:27:20.766 --> 00:27:21.526
of your application.

00:27:22.106 --> 00:27:24.166
The Open VR framework that you

00:27:24.166 --> 00:27:25.756
link to, that conveys the

00:27:25.756 --> 00:27:27.216
version of the interfaces of the

00:27:27.216 --> 00:27:28.436
runtime you've built and tested

00:27:28.436 --> 00:27:28.866
against.

00:27:29.146 --> 00:27:30.866
And that allows us to upgrade

00:27:30.946 --> 00:27:32.736
the runtime and to version

00:27:32.736 --> 00:27:33.616
forward, gracefully.

00:27:33.616 --> 00:27:35.306
Because we move this forward

00:27:35.536 --> 00:27:36.196
quite actively.

00:27:36.386 --> 00:27:38.376
In XCode, instead of just adding

00:27:38.376 --> 00:27:39.146
the framework to your link

00:27:39.146 --> 00:27:40.796
phase, go into General Settings

00:27:40.986 --> 00:27:42.216
and make it an embedded binary.

00:27:42.216 --> 00:27:43.786
So, it will be installed into

00:27:43.786 --> 00:27:45.136
the contents frameworks portion

00:27:45.136 --> 00:27:46.086
of your application bundle.

00:27:46.896 --> 00:27:50.506
Okay. Finally, we really want

00:27:50.506 --> 00:27:51.296
your feedback.

00:27:51.476 --> 00:27:53.016
So, we put some things right

00:27:53.016 --> 00:27:54.426
into the UI of vrmonitor.

00:27:54.426 --> 00:27:56.266
There's a pointer to SteamVR's

00:27:56.266 --> 00:27:57.756
support site and the community

00:27:57.756 --> 00:27:58.756
hardware discussions.

00:27:59.046 --> 00:28:00.646
And you can report a bug, create

00:28:00.646 --> 00:28:01.976
a system report, and send it to

00:28:01.976 --> 00:28:03.306
us or probably send it to me.

00:28:03.306 --> 00:28:05.476
You can reach me at

00:28:05.476 --> 00:28:07.736
natb@valvesoftware.com, but I'd

00:28:07.736 --> 00:28:08.586
rather you use the tool.

00:28:09.196 --> 00:28:12.396
And with that, thanks very much.

00:28:12.396 --> 00:28:13.826
I'm really looking forward to

00:28:13.826 --> 00:28:15.306
what you guys make with VR.

00:28:15.376 --> 00:28:16.616
And thanks, to everybody at

00:28:16.616 --> 00:28:18.246
Apple for making VR shine on

00:28:18.246 --> 00:28:18.756
macOS.

00:28:19.336 --> 00:28:19.716
Thank you.

00:28:20.516 --> 00:28:22.636
[ Applause ]

00:28:23.136 --> 00:28:23.576
>> Thanks, Nat.

00:28:24.886 --> 00:28:25.926
It's been great working with

00:28:25.926 --> 00:28:27.376
Valve, and I'm still astounded

00:28:27.376 --> 00:28:28.236
about what we've been able to

00:28:28.236 --> 00:28:29.636
achieve, over the last year.

00:28:31.206 --> 00:28:31.816
All right.

00:28:31.816 --> 00:28:33.506
Let's move on to talk about the

00:28:33.506 --> 00:28:35.466
external GPU support that we've

00:28:35.466 --> 00:28:37.296
added with macOS High Sierra.

00:28:37.986 --> 00:28:40.816
So, an external GPU is a

00:28:40.816 --> 00:28:42.196
standalone chassis with a

00:28:42.306 --> 00:28:44.436
desktop class GPU in it, that

00:28:44.436 --> 00:28:47.146
you can plug directly to your

00:28:47.146 --> 00:28:48.926
host system via Thunderbolt.

00:28:49.856 --> 00:28:52.186
And as noted previously, the

00:28:52.466 --> 00:28:54.216
primary motivation here, was to

00:28:54.216 --> 00:28:55.876
enable developers like you to

00:28:55.876 --> 00:28:58.166
build great VR apps using a

00:28:58.256 --> 00:28:59.936
broader range of Mac hardware.

00:29:00.686 --> 00:29:02.196
There's a great workflow story,

00:29:02.196 --> 00:29:03.436
here, where you can use your

00:29:03.436 --> 00:29:05.996
MacBook Pro with an external GPU

00:29:06.236 --> 00:29:07.946
to get the rendering horsepower

00:29:07.946 --> 00:29:08.696
that you need for VR.

00:29:08.696 --> 00:29:11.466
But of course, there's also

00:29:11.466 --> 00:29:12.896
additional performance benefit

00:29:12.936 --> 00:29:15.086
to be had for other GPU bound

00:29:15.086 --> 00:29:17.506
cases, like games and pro apps,

00:29:17.506 --> 00:29:17.976
as well.

00:29:18.576 --> 00:29:22.706
And as you saw on Monday, we've

00:29:22.706 --> 00:29:24.246
been partnering with Sonnet and

00:29:24.246 --> 00:29:26.426
AMD to offer you an external

00:29:26.426 --> 00:29:28.666
graphics developer kit with an

00:29:28.706 --> 00:29:32.226
AMD Radeon RX-580 GPU in it.

00:29:32.556 --> 00:29:34.616
This kit is optimized for use

00:29:34.616 --> 00:29:36.106
with all our Thunderbolt 3

00:29:36.106 --> 00:29:37.966
capable Macs, and is available

00:29:37.966 --> 00:29:38.906
for purchase through our

00:29:38.906 --> 00:29:40.626
developer program, today.

00:29:41.236 --> 00:29:41.966
All right.

00:29:42.246 --> 00:29:44.066
Let's dive right into how you

00:29:44.066 --> 00:29:45.846
identify the external GPU.

00:29:46.556 --> 00:29:48.116
This device enumeration code

00:29:48.116 --> 00:29:49.196
should look very familiar to

00:29:49.246 --> 00:29:49.476
you.

00:29:50.616 --> 00:29:52.646
CopyAllDevices will give you all

00:29:52.646 --> 00:29:54.166
the Metal devices in the system.

00:29:54.906 --> 00:29:56.336
And then, you can identify the

00:29:56.336 --> 00:29:58.626
external GPU by simply looking

00:29:58.626 --> 00:30:00.576
for the removable property in

00:30:00.576 --> 00:30:00.976
the device.

00:30:01.976 --> 00:30:03.466
This is very similar to how you

00:30:03.546 --> 00:30:04.936
previously identified the low

00:30:04.936 --> 00:30:06.646
power devices on our platforms.

00:30:06.646 --> 00:30:10.336
Now, let's talk a bit about

00:30:10.336 --> 00:30:11.246
Thunderbolt bandwidth

00:30:11.276 --> 00:30:12.066
capabilities.

00:30:12.816 --> 00:30:15.086
So, Thunderbolt 3 offers twice

00:30:15.146 --> 00:30:16.386
the theoretical bandwidth of

00:30:16.436 --> 00:30:18.326
Thunderbolt 2, which is great.

00:30:19.166 --> 00:30:20.406
But you have to keep in mind

00:30:20.406 --> 00:30:21.806
that this is still a quarter the

00:30:21.806 --> 00:30:24.056
bandwidth of the PCI bus

00:30:24.306 --> 00:30:25.956
available to the internal GPUs

00:30:25.956 --> 00:30:27.116
in our platforms.

00:30:28.356 --> 00:30:29.286
So, this is important.

00:30:29.906 --> 00:30:31.586
You have a choice, now, between

00:30:31.586 --> 00:30:33.896
using the internal GPU with a

00:30:34.006 --> 00:30:36.426
high bandwidth link, or a high

00:30:36.516 --> 00:30:38.656
performance external GPU with a

00:30:38.656 --> 00:30:39.926
link at about a quarter the

00:30:39.926 --> 00:30:40.466
bandwidth.

00:30:41.126 --> 00:30:43.536
So, you need to treat the link

00:30:43.536 --> 00:30:45.056
and the GPU as a pair when

00:30:45.056 --> 00:30:47.486
deciding which GPU you use.

00:30:48.816 --> 00:30:50.606
Additionally, users can now

00:30:50.606 --> 00:30:52.706
attach displays to different

00:30:52.706 --> 00:30:52.896
GPUs.

00:30:52.896 --> 00:30:55.746
And in this environment, there's

00:30:55.746 --> 00:30:57.746
a penalty to render on one GPU

00:30:58.006 --> 00:30:59.576
and then, display on another, as

00:30:59.576 --> 00:31:00.516
that date needs to be

00:31:00.516 --> 00:31:02.226
transferred across the link.

00:31:03.736 --> 00:31:05.046
So, where your content is

00:31:05.106 --> 00:31:08.946
displayed clearly is a huge

00:31:08.946 --> 00:31:10.526
consideration when you decide

00:31:10.646 --> 00:31:12.176
which GPU you want to use, as

00:31:12.176 --> 00:31:12.406
well.

00:31:13.606 --> 00:31:14.206
So, there's additional

00:31:14.206 --> 00:31:15.106
complexity, here.

00:31:15.856 --> 00:31:16.806
But fortunately, there's a

00:31:16.866 --> 00:31:18.566
couple simple things that you

00:31:18.566 --> 00:31:20.156
can do to make your app a good

00:31:20.216 --> 00:31:21.656
citizen in a multi-GPU

00:31:21.656 --> 00:31:22.196
environment.

00:31:23.136 --> 00:31:24.116
So, let's start with GPU

00:31:24.166 --> 00:31:24.746
selection.

00:31:25.646 --> 00:31:27.066
The best advice that we can give

00:31:27.066 --> 00:31:29.836
you is to render on the same GPU

00:31:29.836 --> 00:31:31.516
that's driving the display your

00:31:31.516 --> 00:31:31.916
app is on.

00:31:32.506 --> 00:31:34.306
I call this the golden rule of

00:31:34.306 --> 00:31:35.116
GPU selection.

00:31:36.216 --> 00:31:37.356
So, let's extend this and build

00:31:37.356 --> 00:31:38.306
a decision tree.

00:31:39.756 --> 00:31:41.186
So, if the content your app is

00:31:41.226 --> 00:31:43.226
rendering will be presented to a

00:31:43.226 --> 00:31:46.006
display, you want to select the

00:31:46.656 --> 00:31:48.436
GPU that's driving that display.

00:31:48.656 --> 00:31:49.596
This is our golden rule.

00:31:50.776 --> 00:31:51.936
However, if your app is doing

00:31:51.976 --> 00:31:53.986
compute or other offline

00:31:53.986 --> 00:31:55.956
rendering operations, then you

00:31:55.956 --> 00:31:57.616
need to decide if you prefer to

00:31:57.616 --> 00:31:59.526
use the low power GPU is it's

00:31:59.526 --> 00:32:00.116
available.

00:32:01.126 --> 00:32:02.646
This can be particularly useful

00:32:02.646 --> 00:32:04.006
on our portables, where

00:32:04.276 --> 00:32:05.596
selecting this device can have a

00:32:05.666 --> 00:32:07.136
substantial battery savings.

00:32:07.916 --> 00:32:09.066
But of course, if you need the

00:32:09.066 --> 00:32:11.186
GPU horsepower for things like

00:32:11.186 --> 00:32:12.546
VR, you're going to want to

00:32:12.546 --> 00:32:14.216
select the external GPU.

00:32:14.216 --> 00:32:17.126
So, let's get back to our golden

00:32:17.126 --> 00:32:19.256
rule and find out how you

00:32:19.256 --> 00:32:21.196
identify the Metal device that's

00:32:21.196 --> 00:32:22.556
driving a particular display.

00:32:23.866 --> 00:32:24.806
Well, it turns out that this is

00:32:24.876 --> 00:32:25.766
really easy to do.

00:32:26.496 --> 00:32:27.576
There's an existing core

00:32:27.576 --> 00:32:29.416
graphics API that will give you

00:32:29.416 --> 00:32:30.176
this device.

00:32:30.996 --> 00:32:32.646
You simply have to get the ID

00:32:33.216 --> 00:32:34.586
for the display that your window

00:32:34.586 --> 00:32:36.026
is on, by querying the

00:32:36.026 --> 00:32:36.906
NSScreenNumber.

00:32:37.636 --> 00:32:39.516
And then, call

00:32:39.576 --> 00:32:42.116
CGDirectDisplayCopyCurrentMetal

00:32:42.116 --> 00:32:44.076
Device to get the Metal device

00:32:44.146 --> 00:32:45.346
that's driving that display.

00:32:46.036 --> 00:32:46.606
It's that simple.

00:32:46.606 --> 00:32:47.306
All right.

00:32:49.236 --> 00:32:51.586
Now, that we've established that

00:32:51.586 --> 00:32:53.056
each display can be attached to

00:32:53.056 --> 00:32:55.346
a different GPU, your app will

00:32:55.346 --> 00:32:57.656
need to handle GPU migration as

00:32:57.656 --> 00:32:58.706
your displays are moved.

00:32:59.116 --> 00:33:00.566
Sorry, as your window is moved

00:33:00.566 --> 00:33:01.706
across those displays.

00:33:03.776 --> 00:33:05.586
So, you can do that by

00:33:05.656 --> 00:33:07.646
registering for the new, well,

00:33:07.646 --> 00:33:08.946
it's not new, our existing

00:33:09.376 --> 00:33:10.926
notification handler called

00:33:11.206 --> 00:33:12.896
WindowDidChangeScreen.

00:33:12.896 --> 00:33:14.416
So, let's take a look at what

00:33:14.416 --> 00:33:15.826
you do with this notification

00:33:15.826 --> 00:33:16.146
handler.

00:33:16.406 --> 00:33:18.506
So, you'll want to start by

00:33:18.596 --> 00:33:21.406
finding the Metal device for the

00:33:21.406 --> 00:33:23.286
display your app is now on, by

00:33:23.286 --> 00:33:24.626
calling the core graphics API

00:33:24.626 --> 00:33:26.196
that we previously discussed.

00:33:27.476 --> 00:33:28.586
You can early out if it's the

00:33:28.586 --> 00:33:29.646
same device that you're

00:33:29.686 --> 00:33:31.106
currently rendering to, since no

00:33:31.106 --> 00:33:33.036
GPU migration will be required.

00:33:33.036 --> 00:33:35.336
And then, you'll want to perform

00:33:35.566 --> 00:33:37.606
your device migration and switch

00:33:37.606 --> 00:33:39.316
to using the new device for all

00:33:39.316 --> 00:33:39.966
your rendering.

00:33:41.016 --> 00:33:43.236
So, that's how you use a display

00:33:43.236 --> 00:33:45.246
change notification to handle

00:33:45.246 --> 00:33:46.376
GPU migration.

00:33:46.376 --> 00:33:48.166
But what about the case where

00:33:48.166 --> 00:33:50.076
the external GPU is plugged in,

00:33:50.366 --> 00:33:51.756
or unplugged from your system?

00:33:53.116 --> 00:33:54.786
Well, Metal 2 introduces three

00:33:54.786 --> 00:33:56.526
new notifications to help you

00:33:56.526 --> 00:33:57.146
with this case.

00:33:58.316 --> 00:34:01.016
These are DeviceWasAdded when an

00:34:01.016 --> 00:34:02.616
external GPU was plugged in,

00:34:03.726 --> 00:34:05.076
DeviceWasRemoved when it's

00:34:05.116 --> 00:34:06.336
unplugged, and

00:34:06.336 --> 00:34:08.735
DeviceRemovalRequested when the

00:34:08.735 --> 00:34:10.896
OS signals an intent to remove a

00:34:10.896 --> 00:34:12.795
GPU at some point in the future.

00:34:14.235 --> 00:34:15.406
So, let's take a look at how you

00:34:15.406 --> 00:34:16.716
would register for, and then,

00:34:16.716 --> 00:34:18.706
respond to these notifications.

00:34:19.815 --> 00:34:21.315
So, you'll want to use the new

00:34:21.416 --> 00:34:24.016
CopyAllDevicesWithObserver API

00:34:24.686 --> 00:34:25.786
that we've introduced with Metal

00:34:25.786 --> 00:34:26.085
2.

00:34:26.846 --> 00:34:27.936
This will let you register a

00:34:28.045 --> 00:34:30.416
handler for these new device

00:34:30.416 --> 00:34:31.686
change notifications.

00:34:32.686 --> 00:34:34.136
In this case, we're simply

00:34:34.136 --> 00:34:35.536
invoking a function called

00:34:35.896 --> 00:34:37.266
handleGPUHotPlug.

00:34:37.976 --> 00:34:38.876
So, let's take a look at it.

00:34:39.666 --> 00:34:41.126
It's really straightforward.

00:34:41.616 --> 00:34:43.446
All you have to do is check for

00:34:43.446 --> 00:34:45.216
and directly respond to each

00:34:45.216 --> 00:34:45.946
notification.

00:34:46.686 --> 00:34:47.676
But I want to point out a couple

00:34:47.676 --> 00:34:48.275
of things, here.

00:34:49.315 --> 00:34:50.966
The first is that your app

00:34:50.966 --> 00:34:51.896
should treat the

00:34:51.946 --> 00:34:53.436
DeviceRemovalRequested

00:34:53.436 --> 00:34:55.696
notification as a hint to start

00:34:55.795 --> 00:34:57.966
migrating off the external GPU.

00:34:58.446 --> 00:35:02.216
And second, if your app did not

00:35:02.216 --> 00:35:02.796
receive the

00:35:02.796 --> 00:35:04.116
DeviceRemovalRequested

00:35:04.116 --> 00:35:06.016
notification, then it should

00:35:06.016 --> 00:35:08.186
treat DeviceWasRemoved as an

00:35:08.286 --> 00:35:10.246
unexpected GPU removal.

00:35:10.826 --> 00:35:13.646
So, an unexpected GPU removal is

00:35:13.646 --> 00:35:15.316
when your external GPU is

00:35:15.436 --> 00:35:17.036
disconnected or powered down

00:35:17.156 --> 00:35:18.566
without the OS being aware.

00:35:19.926 --> 00:35:20.986
So, this is the equivalent of

00:35:20.986 --> 00:35:22.196
somebody reaching into your

00:35:22.196 --> 00:35:24.116
system and yanking out that GPU.

00:35:24.896 --> 00:35:26.126
And since the hardware is no

00:35:26.126 --> 00:35:28.286
longer there, some Metal API

00:35:28.286 --> 00:35:30.086
calls will start returning

00:35:30.086 --> 00:35:30.496
errors.

00:35:30.646 --> 00:35:32.486
So, you'll want to add defensive

00:35:32.536 --> 00:35:33.986
code to your app to protect

00:35:33.986 --> 00:35:34.556
against this.

00:35:35.146 --> 00:35:36.516
So, it can survive until it

00:35:36.616 --> 00:35:37.786
receives a migration

00:35:37.786 --> 00:35:39.236
notification and it can

00:35:39.236 --> 00:35:41.076
gracefully switch to another GPU

00:35:41.076 --> 00:35:41.696
in the system.

00:35:42.876 --> 00:35:44.116
It's also worth pointing out

00:35:44.296 --> 00:35:45.756
that if you had any transient

00:35:45.756 --> 00:35:47.916
data on the external GPU's local

00:35:47.916 --> 00:35:49.646
memory, your app may need to

00:35:49.646 --> 00:35:50.926
regenerate this, as it's no

00:35:50.926 --> 00:35:51.386
longer there.

00:35:51.386 --> 00:35:52.066
All right.

00:35:53.346 --> 00:35:55.666
Now, on to some best practices.

00:35:56.456 --> 00:35:57.916
So, we recommend that you don't

00:35:57.916 --> 00:35:59.716
immediately release devices

00:35:59.966 --> 00:36:02.466
after you migrate, as users tend

00:36:02.466 --> 00:36:04.106
to move windows back and forth

00:36:04.106 --> 00:36:05.066
across displays.

00:36:05.946 --> 00:36:08.356
Instead, employ a lazy teardown

00:36:08.426 --> 00:36:10.126
policy with some reasonable

00:36:10.276 --> 00:36:10.636
timeout.

00:36:12.136 --> 00:36:14.566
Additionally, if your app has a

00:36:14.566 --> 00:36:16.936
complex UI with a number of

00:36:16.936 --> 00:36:19.366
windows, you may, may, need to

00:36:19.366 --> 00:36:21.476
handle GPU migrations separately

00:36:21.526 --> 00:36:22.306
for each window.

00:36:23.426 --> 00:36:25.526
And then, finally, we recommend

00:36:25.526 --> 00:36:27.086
that you profile your app in

00:36:27.086 --> 00:36:29.516
multi-GPU situations, to ensure

00:36:29.516 --> 00:36:30.736
that you're not needlessly

00:36:30.736 --> 00:36:32.356
transferring data back and

00:36:32.426 --> 00:36:35.986
forth, across the GPUs.

00:36:36.186 --> 00:36:36.446
All right.

00:36:36.696 --> 00:36:38.196
Let's tie it back to VR with

00:36:38.196 --> 00:36:39.816
some best practices specific to

00:36:39.816 --> 00:36:40.676
this use case.

00:36:41.816 --> 00:36:44.156
First and most obvious, make

00:36:44.156 --> 00:36:45.616
sure you attach the VR headset

00:36:45.736 --> 00:36:47.536
directly to the external GPU.

00:36:48.836 --> 00:36:50.076
Less obvious, but equally

00:36:50.076 --> 00:36:51.766
important, you want to make sure

00:36:51.766 --> 00:36:53.256
that your app is presenting its

00:36:53.256 --> 00:36:56.256
UI or the mirrored VR content to

00:36:56.256 --> 00:36:57.746
a display that's also being

00:36:57.746 --> 00:36:59.336
driven by the external GPU.

00:37:00.036 --> 00:37:01.206
This will ensure that both the

00:37:01.206 --> 00:37:03.626
VR compositor and your app are

00:37:03.626 --> 00:37:05.316
rendering with the external GPU.

00:37:05.906 --> 00:37:08.396
And finally, make sure you cache

00:37:08.396 --> 00:37:10.846
as many resources as possible on

00:37:10.846 --> 00:37:12.556
the external GPU's local memory,

00:37:12.906 --> 00:37:14.226
so that you're not streaming

00:37:14.226 --> 00:37:15.416
data across the Thunderbolt

00:37:15.416 --> 00:37:17.016
link, unless absolutely

00:37:17.016 --> 00:37:17.596
required.

00:37:18.216 --> 00:37:19.236
All right.

00:37:20.376 --> 00:37:22.096
So, this brings us to the end of

00:37:22.096 --> 00:37:22.826
our session.

00:37:23.046 --> 00:37:24.386
So, let's quickly review what

00:37:24.386 --> 00:37:25.196
we've covered, today.

00:37:25.476 --> 00:37:27.676
So, the big news is that you can

00:37:27.676 --> 00:37:29.526
now, develop VR content on

00:37:29.526 --> 00:37:30.316
macOS.

00:37:31.376 --> 00:37:32.886
We've added built-in support for

00:37:33.126 --> 00:37:34.716
the HTC Vibe headset.

00:37:35.336 --> 00:37:37.366
And we've partnered with Valve

00:37:37.366 --> 00:37:39.296
to enable an optimized version,

00:37:39.546 --> 00:37:41.046
an optimized Metal version of

00:37:41.046 --> 00:37:43.106
the SteamVR runtime on our

00:37:43.106 --> 00:37:43.576
platform.

00:37:44.966 --> 00:37:46.216
Additionally, two of the most

00:37:46.306 --> 00:37:48.486
popular game engines, Unity and

00:37:48.486 --> 00:37:50.566
Unreal Engine 4 will be bringing

00:37:50.636 --> 00:37:52.596
VR support to the Mac, in the

00:37:52.596 --> 00:37:53.276
near future.

00:37:53.766 --> 00:37:55.406
But of course, we also encourage

00:37:55.406 --> 00:37:56.806
you to build your own native VR

00:37:56.806 --> 00:37:57.296
app.

00:37:58.126 --> 00:37:59.726
And finally, we added support

00:37:59.726 --> 00:38:00.626
for external GPUs.

00:38:00.626 --> 00:38:02.846
And we hope that this motivates

00:38:02.846 --> 00:38:04.606
you to ensure that your app is a

00:38:04.746 --> 00:38:06.946
good citizen in a multi-GPU

00:38:06.946 --> 00:38:08.326
environment, so that you can

00:38:08.376 --> 00:38:09.376
take advantage of that

00:38:09.376 --> 00:38:10.706
additional GPU horsepower.

00:38:12.696 --> 00:38:14.746
We're really excited to see what

00:38:14.746 --> 00:38:15.696
you guys are going to be able to

00:38:15.696 --> 00:38:17.206
build with this new technology.

00:38:18.436 --> 00:38:19.396
So, be sure to check out the

00:38:19.396 --> 00:38:20.406
other sessions on the Metal

00:38:20.406 --> 00:38:20.756
Track.

00:38:21.086 --> 00:38:22.666
We had a great Introducing Metal

00:38:22.666 --> 00:38:23.706
2 session, yesterday.

00:38:23.706 --> 00:38:24.826
If you didn't get a chance to

00:38:24.926 --> 00:38:26.126
see it, I encourage you to watch

00:38:26.176 --> 00:38:27.186
the video online.

00:38:28.076 --> 00:38:29.466
We have two additional sessions

00:38:29.466 --> 00:38:30.766
in the afternoon, tomorrow,

00:38:31.336 --> 00:38:32.726
Metal 2 Optimization and

00:38:32.726 --> 00:38:34.696
Debugging, and Using Metal 2 for

00:38:34.696 --> 00:38:35.136
Compute.

00:38:35.326 --> 00:38:36.636
We hope to see you, there.

00:38:37.516 --> 00:38:38.196
I'll see you, there.

00:38:38.196 --> 00:38:39.286
Thank you, very much, and have a

00:38:39.336 --> 00:38:40.476
great WWDC.

00:38:41.016 --> 00:38:43.000
[ Applause ]
WEBVTT

00:00:21.516 --> 00:00:27.956
[ Applause ]

00:00:28.456 --> 00:00:28.916
>> Welcome.

00:00:29.436 --> 00:00:30.996
We introduced the host of new

00:00:30.996 --> 00:00:32.576
technologies with Metal 2 to

00:00:32.856 --> 00:00:34.846
allow you to make better,

00:00:35.116 --> 00:00:36.896
faster, and more efficient

00:00:36.896 --> 00:00:37.706
applications.

00:00:38.206 --> 00:00:39.396
My name is Michal and together

00:00:39.396 --> 00:00:40.856
with my colleague Richard we'll

00:00:40.856 --> 00:00:42.756
explore three main themes today.

00:00:44.546 --> 00:00:46.546
With Metal 2 we are continuing

00:00:46.756 --> 00:00:48.656
our direction of moving the

00:00:48.656 --> 00:00:50.526
expensive things to happen less

00:00:50.526 --> 00:00:52.266
frequently and making sure that

00:00:52.266 --> 00:00:54.376
the frequent things are really,

00:00:54.376 --> 00:00:55.176
really cheap.

00:00:55.656 --> 00:00:57.356
Over the years we introduced

00:00:57.646 --> 00:01:00.226
precompiled shaders, render

00:01:00.226 --> 00:01:02.286
state objects, Metal Heap last

00:01:02.286 --> 00:01:04.566
year all to make sure that you

00:01:04.566 --> 00:01:06.416
can move the costly operations

00:01:06.576 --> 00:01:08.796
outside of your main application

00:01:09.346 --> 00:01:09.446
loop.

00:01:10.096 --> 00:01:13.836
We gave you 10 times more draw

00:01:13.836 --> 00:01:15.886
calls by switching from open GL

00:01:16.206 --> 00:01:16.696
to Metal.

00:01:17.616 --> 00:01:18.996
And this year we are introducing

00:01:18.996 --> 00:01:21.496
our new binding API that gives

00:01:21.496 --> 00:01:22.866
you some more.

00:01:22.866 --> 00:01:24.426
And so we will talk about it a

00:01:24.426 --> 00:01:24.946
bit further.

00:01:26.446 --> 00:01:29.006
We are also putting GPU more in

00:01:29.006 --> 00:01:32.016
a driving seat with GPU driven

00:01:32.016 --> 00:01:32.856
pipelines.

00:01:33.426 --> 00:01:35.326
And you will be able to create

00:01:35.326 --> 00:01:37.966
new, novel algorithms, new

00:01:37.966 --> 00:01:40.316
rendering techniques, and whole

00:01:40.926 --> 00:01:43.276
unique experiences utilizing

00:01:43.276 --> 00:01:45.176
Metal 2 on modern GPUs.

00:01:45.546 --> 00:01:46.366
Well, speaking of the

00:01:46.366 --> 00:01:49.096
experiences, we have a lot of

00:01:49.096 --> 00:01:50.306
new features in Metal and we

00:01:50.306 --> 00:01:51.726
have three other sessions that I

00:01:51.726 --> 00:01:52.746
would love you to attend.

00:01:53.586 --> 00:01:56.786
VR is coming to Mac this year

00:01:56.786 --> 00:01:58.986
and with the new iMacs we are

00:01:58.986 --> 00:02:01.486
giving you really powerful GPUs.

00:02:01.976 --> 00:02:04.056
The external GPU is coming to

00:02:04.106 --> 00:02:05.646
MacBook Pro to give you the same

00:02:05.646 --> 00:02:06.006
power.

00:02:06.726 --> 00:02:09.166
And this all enables your users

00:02:09.515 --> 00:02:11.566
and your content creators to

00:02:11.566 --> 00:02:14.156
experience VR in ways not

00:02:14.156 --> 00:02:14.936
possible before.

00:02:15.576 --> 00:02:17.746
Tomorrow's session will show you

00:02:18.486 --> 00:02:22.136
how to use our display -- direct

00:02:22.136 --> 00:02:23.876
display technology -- to get

00:02:23.876 --> 00:02:25.996
your content to HMD quick and

00:02:25.996 --> 00:02:26.846
with low latency.

00:02:28.176 --> 00:02:29.906
You'll learn about the new Metal

00:02:29.906 --> 00:02:32.066
API editions for VR and our new

00:02:32.066 --> 00:02:33.066
Tools editions.

00:02:35.856 --> 00:02:38.266
Machine learning is quickly

00:02:38.266 --> 00:02:40.296
becoming a key feature of our

00:02:40.296 --> 00:02:42.076
devices in many, many

00:02:42.076 --> 00:02:42.976
applications.

00:02:42.976 --> 00:02:45.056
And with Metal 2 you can use

00:02:45.056 --> 00:02:47.786
Metal performance shaders to

00:02:47.876 --> 00:02:49.726
utilize the power of the GPU for

00:02:49.726 --> 00:02:53.446
machine learning on both test up

00:02:53.546 --> 00:02:54.536
and mobile devices.

00:02:55.376 --> 00:02:56.786
And you're probably staring at

00:02:56.916 --> 00:02:58.256
that picture behind me and

00:02:58.256 --> 00:02:59.486
thinking, "How's that done?"

00:02:59.776 --> 00:03:01.316
Well, we have a session for you

00:03:01.316 --> 00:03:03.776
on Thursday where you will learn

00:03:03.776 --> 00:03:05.416
about this and about the machine

00:03:05.416 --> 00:03:07.256
learning primitives -- the image

00:03:07.256 --> 00:03:08.796
processing primitives -- we have

00:03:09.036 --> 00:03:10.966
in our Metal performance

00:03:10.966 --> 00:03:11.506
shaders.

00:03:13.036 --> 00:03:15.576
Lastly, our tools have seen the

00:03:15.576 --> 00:03:17.566
biggest advancement yet with

00:03:17.566 --> 00:03:18.146
Metal 2.

00:03:18.256 --> 00:03:19.856
You'll be able to debug your

00:03:19.856 --> 00:03:21.006
applications quicker.

00:03:21.556 --> 00:03:23.266
You can drill down to problems

00:03:23.686 --> 00:03:26.796
easier and we are exposing, for

00:03:26.796 --> 00:03:28.226
example GPU performance

00:03:28.226 --> 00:03:29.866
counters, to make sure that you

00:03:29.866 --> 00:03:33.566
can find your hotspots and your

00:03:33.566 --> 00:03:36.126
application fast pass quicker.

00:03:37.416 --> 00:03:39.786
So I hope I got you excited

00:03:40.056 --> 00:03:41.946
about the few days ahead and

00:03:41.946 --> 00:03:44.076
let's get back to the present

00:03:44.076 --> 00:03:45.336
with the content of today's

00:03:45.336 --> 00:03:45.866
session.

00:03:51.426 --> 00:03:53.576
So we'll start with argument

00:03:53.576 --> 00:03:55.946
buffers, probably our biggest

00:03:55.996 --> 00:03:57.686
core framework addition this

00:03:57.686 --> 00:03:57.916
year.

00:03:58.716 --> 00:04:00.756
argument buffers provide an

00:04:00.756 --> 00:04:03.426
efficient new way of configuring

00:04:03.426 --> 00:04:05.946
which buffers, textures, and

00:04:06.416 --> 00:04:07.986
samplers your application can

00:04:07.986 --> 00:04:11.356
use freeing up considerable

00:04:11.356 --> 00:04:13.246
amount of CPU resources and

00:04:13.246 --> 00:04:15.026
actually enabling completely new

00:04:15.026 --> 00:04:16.366
schedules for the GPU at the

00:04:16.366 --> 00:04:17.086
same time.

00:04:18.196 --> 00:04:20.726
Then we'll talk about Raster

00:04:20.726 --> 00:04:22.966
Order Groups, a new fragment

00:04:22.966 --> 00:04:24.516
shader synchronization primitive

00:04:25.006 --> 00:04:26.856
that allows you to precisely

00:04:26.856 --> 00:04:28.566
control the order in which

00:04:28.786 --> 00:04:30.426
fragment shaders access common

00:04:30.426 --> 00:04:33.026
memory, enabling you new use

00:04:33.026 --> 00:04:34.726
cases for example of

00:04:35.286 --> 00:04:37.186
programmable blending on MacOS

00:04:37.246 --> 00:04:41.466
or voxelization [phonetic] order

00:04:41.516 --> 00:04:42.626
independent transparency.

00:04:43.466 --> 00:04:44.866
And then we'll switch to the

00:04:44.866 --> 00:04:46.656
topic of display and we talk

00:04:46.656 --> 00:04:48.396
about the new ProMotion Displays

00:04:48.396 --> 00:04:50.496
on iPads and how to best drive

00:04:50.496 --> 00:04:51.526
them using Metal.

00:04:51.526 --> 00:04:54.396
And we'll also give you a recap

00:04:54.446 --> 00:04:57.376
of our best practices of getting

00:04:57.376 --> 00:04:58.876
your content from your render

00:04:58.876 --> 00:05:02.606
targets to the glass as quickly

00:05:02.606 --> 00:05:04.046
as possible and with the least

00:05:04.046 --> 00:05:04.996
amount of latency.

00:05:05.576 --> 00:05:07.686
And finally we'll finish with a

00:05:08.106 --> 00:05:10.036
survey of all the other Metal

00:05:10.036 --> 00:05:12.316
features that we added to align

00:05:12.566 --> 00:05:15.436
iOS and macOS platforms into one

00:05:15.786 --> 00:05:16.976
big, common Metal ecosystem.

00:05:22.336 --> 00:05:26.186
So the argument buffers.

00:05:26.536 --> 00:05:28.556
Let's look at what they are and

00:05:28.716 --> 00:05:29.266
how they work.

00:05:29.316 --> 00:05:30.806
And I will need an example for

00:05:30.806 --> 00:05:33.776
that so let's think of a simple

00:05:33.776 --> 00:05:36.166
material that those who actually

00:05:36.166 --> 00:05:39.456
wrote any sort of 3D render

00:05:39.456 --> 00:05:40.046
program would know.

00:05:40.466 --> 00:05:42.326
In your material you have a

00:05:42.326 --> 00:05:44.936
bunch of numerical constants, a

00:05:45.106 --> 00:05:46.236
bunch of textures -- probably

00:05:46.236 --> 00:05:47.416
more than two now a days --

00:05:47.466 --> 00:05:48.016
assembler.

00:05:48.686 --> 00:05:53.196
And this is what you need to

00:05:53.196 --> 00:05:54.726
send to the GPU to be able to

00:05:54.726 --> 00:05:56.056
render your primitive.

00:05:56.516 --> 00:05:58.566
Now the texture objects are

00:05:59.456 --> 00:06:01.026
interesting because they contain

00:06:01.166 --> 00:06:03.506
both texture properties such as

00:06:03.506 --> 00:06:06.626
width, height, pixel format

00:06:06.626 --> 00:06:08.866
perhaps, and then a pointer to a

00:06:08.866 --> 00:06:10.176
blob of memory which contains

00:06:10.176 --> 00:06:11.196
all the pretty pixels.

00:06:11.196 --> 00:06:13.896
Well, unfortunately we are not

00:06:13.896 --> 00:06:14.766
really interested in those

00:06:14.766 --> 00:06:15.926
pixels in this presentation.

00:06:15.926 --> 00:06:18.636
So off it goes and we'll only be

00:06:18.636 --> 00:06:20.426
talking about boring texture

00:06:20.426 --> 00:06:20.916
states.

00:06:22.156 --> 00:06:24.456
So with traditional argument

00:06:24.456 --> 00:06:26.566
model we allow you to put all

00:06:26.566 --> 00:06:29.106
the constants into a Metal

00:06:29.106 --> 00:06:30.216
buffer and we created this

00:06:30.216 --> 00:06:32.126
indirection so that it's easy

00:06:32.126 --> 00:06:33.846
for you to use and also it gives

00:06:33.846 --> 00:06:36.136
GPU the unfiltered, direct

00:06:36.136 --> 00:06:37.926
access to all the data.

00:06:39.136 --> 00:06:41.166
However, when it comes to things

00:06:41.166 --> 00:06:43.386
like textures or samplers you

00:06:43.386 --> 00:06:44.446
still need to go through quite

00:06:44.446 --> 00:06:46.266
about of an API and in your

00:06:46.266 --> 00:06:47.686
rendering loop you'll set the

00:06:47.686 --> 00:06:50.066
buffer, set all the textures,

00:06:50.676 --> 00:06:52.146
samplers, and only after that

00:06:52.146 --> 00:06:53.396
you can finally draw.

00:06:53.446 --> 00:06:55.676
And even though Metal is really

00:06:55.676 --> 00:06:57.676
optimized this is quite a few

00:06:57.676 --> 00:06:59.336
API codes and if you multiply it

00:06:59.336 --> 00:07:00.286
with the number of objects you

00:07:00.286 --> 00:07:02.766
need to render, every frame, and

00:07:02.766 --> 00:07:04.046
the fact that you need to do all

00:07:04.046 --> 00:07:06.156
this work every frame, it

00:07:06.156 --> 00:07:09.026
actually at some point limits

00:07:09.026 --> 00:07:10.136
the amount of objects that you

00:07:10.136 --> 00:07:13.826
can put on the screen.

00:07:13.826 --> 00:07:17.126
With argument buffers we decided

00:07:17.126 --> 00:07:19.076
that we would like to extend

00:07:19.486 --> 00:07:21.476
this very convenient indirection

00:07:21.786 --> 00:07:23.026
that we have for constants to

00:07:23.026 --> 00:07:23.626
everything.

00:07:23.626 --> 00:07:26.046
So you can actually put texture

00:07:26.046 --> 00:07:28.226
state, samplers, pointers to

00:07:28.226 --> 00:07:29.696
another buffer into an argument

00:07:29.696 --> 00:07:31.456
buffer and this really

00:07:31.456 --> 00:07:34.036
simplifies your rendering

00:07:34.036 --> 00:07:35.656
pipeline because -- well,

00:07:35.656 --> 00:07:37.956
suddenly the only thing you need

00:07:37.956 --> 00:07:40.386
to do is set the buffer and

00:07:41.426 --> 00:07:41.806
draw.

00:07:42.016 --> 00:07:43.316
And you probably figured out

00:07:43.316 --> 00:07:46.196
that with this few API calls you

00:07:46.196 --> 00:07:47.126
can put more objects on the

00:07:47.126 --> 00:07:49.996
screen, and as you'll see later,

00:07:50.236 --> 00:07:51.726
you can do actually even better

00:07:51.726 --> 00:07:54.006
with argument buffers.

00:07:54.656 --> 00:07:55.536
So we've done a bunch of

00:07:55.536 --> 00:07:58.746
benchmarks and run argument

00:07:58.746 --> 00:07:59.976
buffers on our devices.

00:08:04.426 --> 00:08:05.886
And this is for example what you

00:08:05.886 --> 00:08:07.616
get on iPhone 7.

00:08:08.196 --> 00:08:10.196
While with traditional model,

00:08:10.526 --> 00:08:13.546
quite unsurprisingly, the cost

00:08:13.646 --> 00:08:16.366
of your draw call scales, with

00:08:16.366 --> 00:08:17.756
the amount of resources you use

00:08:18.246 --> 00:08:22.016
in a draw call, with argument

00:08:22.016 --> 00:08:25.096
buffers the cost stays pretty

00:08:25.096 --> 00:08:26.736
low and almost flat.

00:08:26.736 --> 00:08:29.976
So this already shows that for

00:08:29.976 --> 00:08:31.436
example with a very simple

00:08:31.436 --> 00:08:33.496
shader, with just two resources,

00:08:33.496 --> 00:08:35.956
with texture and a buffer, or

00:08:36.126 --> 00:08:37.785
two textures, you're getting

00:08:37.785 --> 00:08:39.535
seven times the performance

00:08:39.535 --> 00:08:40.135
improvement.

00:08:40.135 --> 00:08:42.186
With eight textures or eight

00:08:42.186 --> 00:08:45.146
resources, however you want to

00:08:45.146 --> 00:08:47.286
mix it up, you are getting 18

00:08:47.286 --> 00:08:48.996
times performance improvement on

00:08:48.996 --> 00:08:50.966
iPhone 7 and it goes even better

00:08:50.966 --> 00:08:52.696
with 16 resources, obviously.

00:08:55.106 --> 00:08:58.116
So I already talked about the

00:08:58.116 --> 00:08:58.896
performance.

00:08:58.986 --> 00:09:01.316
I hinted toward a new use -- new

00:09:01.316 --> 00:09:01.906
use schedules.

00:09:01.906 --> 00:09:04.486
And we'll talk about this in a

00:09:04.486 --> 00:09:04.866
minute.

00:09:05.066 --> 00:09:06.456
And the last point -- the last

00:09:06.456 --> 00:09:08.166
benefit of argument buffers I

00:09:08.166 --> 00:09:09.616
would like to bring up is the

00:09:09.616 --> 00:09:10.376
ease of use.

00:09:10.976 --> 00:09:13.856
And it comes from the fact that

00:09:13.856 --> 00:09:15.546
argument buffers are ultimately

00:09:15.716 --> 00:09:16.686
an extension of buffers.

00:09:16.686 --> 00:09:17.966
So you can, for example go ahead

00:09:17.966 --> 00:09:19.406
and prepare them ahead of the

00:09:19.406 --> 00:09:21.116
time, let's say when your game

00:09:21.116 --> 00:09:23.426
is loading, and then don't have

00:09:23.476 --> 00:09:25.216
to worry about it anymore during

00:09:25.216 --> 00:09:26.386
your rendering loop, further

00:09:26.556 --> 00:09:27.836
improving your performance.

00:09:28.786 --> 00:09:30.356
Or you can mix them with a

00:09:30.356 --> 00:09:31.606
traditional binding model, for

00:09:31.606 --> 00:09:33.866
example even within a single

00:09:34.066 --> 00:09:36.376
draw call, which means that your

00:09:36.376 --> 00:09:38.186
adoption can be as simple as

00:09:38.366 --> 00:09:39.746
using our new tools to figure

00:09:39.746 --> 00:09:40.986
out what is your most expensive

00:09:41.256 --> 00:09:43.626
loop in our application and

00:09:43.626 --> 00:09:44.946
optimizing that and then maybe

00:09:44.946 --> 00:09:46.526
return to the rest in a year

00:09:46.526 --> 00:09:49.626
when you have time.

00:09:49.746 --> 00:09:52.936
And lastly, the argument buffers

00:09:52.936 --> 00:09:55.246
are supported across all Metal

00:09:55.246 --> 00:09:55.786
devices.

00:09:55.786 --> 00:09:57.986
So once you take this adoption

00:09:57.986 --> 00:09:59.356
step and you get all the

00:09:59.356 --> 00:10:00.956
performance you can keep using

00:10:00.956 --> 00:10:02.556
it on all Metal devices.

00:10:02.986 --> 00:10:04.076
The ease of use actually

00:10:04.076 --> 00:10:05.796
translates really well to the

00:10:05.796 --> 00:10:06.426
shaders.

00:10:06.426 --> 00:10:07.836
And since we will be looking at

00:10:07.836 --> 00:10:10.666
the shaders quite a bit during

00:10:10.666 --> 00:10:12.576
this section -- this is an

00:10:12.576 --> 00:10:14.806
example of the material I gave

00:10:14.806 --> 00:10:15.676
you in the beginning.

00:10:16.666 --> 00:10:19.266
And as you can see, the textures

00:10:19.266 --> 00:10:21.596
in the sampler are part of the

00:10:21.596 --> 00:10:23.366
structure, and that's the main

00:10:23.366 --> 00:10:24.746
thing to take away from this is

00:10:25.296 --> 00:10:28.616
that your argument buffer is

00:10:28.616 --> 00:10:29.976
just a structure in a shader and

00:10:29.976 --> 00:10:31.316
you can use all the language

00:10:31.686 --> 00:10:33.066
that you have at your disposal

00:10:33.066 --> 00:10:35.266
to make embedded structures, to

00:10:35.266 --> 00:10:38.856
organize your data, or use erase

00:10:38.856 --> 00:10:39.576
or pointers.

00:10:39.766 --> 00:10:40.976
It just really works.

00:10:42.216 --> 00:10:44.486
So let's now look at the three

00:10:44.766 --> 00:10:46.216
main new features of argument

00:10:46.216 --> 00:10:47.586
buffers, the first one being

00:10:47.676 --> 00:10:48.946
dynamic indexing.

00:10:50.276 --> 00:10:53.346
And great example of it is crowd

00:10:53.346 --> 00:10:53.826
rendering.

00:10:53.826 --> 00:10:56.056
If you played some of the recent

00:10:56.056 --> 00:10:57.436
Open World games you've seen

00:10:57.436 --> 00:11:00.686
that games try to render large

00:11:00.686 --> 00:11:02.506
crowds full of unique, varying

00:11:02.986 --> 00:11:05.036
characters in order to make

00:11:05.036 --> 00:11:07.546
these beautiful, immersive

00:11:07.606 --> 00:11:08.166
worlds.

00:11:08.696 --> 00:11:10.116
Well, actually that's quite a

00:11:10.116 --> 00:11:12.246
costly thing to do if you need

00:11:12.246 --> 00:11:13.706
to create so many draw calls.

00:11:15.076 --> 00:11:16.936
With argument buffers we already

00:11:16.936 --> 00:11:19.416
said that we could put all the

00:11:19.416 --> 00:11:20.876
properties required for let's

00:11:20.876 --> 00:11:22.096
say a character into a single

00:11:22.096 --> 00:11:24.006
argument buffer, bind it, and

00:11:24.006 --> 00:11:25.566
save all that performance on the

00:11:25.566 --> 00:11:27.686
CPU, but actually we can do

00:11:27.686 --> 00:11:27.966
better.

00:11:27.966 --> 00:11:30.246
We can for example create an

00:11:30.416 --> 00:11:32.236
array of argument buffers where

00:11:32.546 --> 00:11:35.266
each element represents single

00:11:35.266 --> 00:11:35.726
character.

00:11:36.306 --> 00:11:37.476
And then it suddenly becomes

00:11:37.476 --> 00:11:38.696
very, very simple because what

00:11:38.696 --> 00:11:40.856
you need to do is set this big

00:11:40.856 --> 00:11:44.016
buffer, this one API call, issue

00:11:44.126 --> 00:11:46.046
single instance draw call, let's

00:11:46.046 --> 00:11:47.646
say with 1,000 instances because

00:11:47.646 --> 00:11:49.126
I would like 1,000 characters on

00:11:49.126 --> 00:11:49.496
screen.

00:11:50.096 --> 00:11:51.186
That's second API call.

00:11:51.256 --> 00:11:53.626
And after that it's all on the

00:11:53.626 --> 00:11:54.176
GPU.

00:11:54.176 --> 00:11:55.576
In a vertex shader you use

00:11:55.576 --> 00:11:57.426
instance ID to pick the right

00:11:57.426 --> 00:12:00.926
element from the array, get the

00:12:00.926 --> 00:12:02.266
character, put it somewhere

00:12:02.266 --> 00:12:03.036
where it needs to be in the

00:12:03.036 --> 00:12:04.496
world, give it the right pose,

00:12:04.496 --> 00:12:05.646
if it's for example mid-walk

00:12:05.646 --> 00:12:07.766
cycle, and then in the fragment

00:12:07.766 --> 00:12:10.176
shader again you use the

00:12:10.176 --> 00:12:12.146
instance ID and pick the right

00:12:12.146 --> 00:12:13.516
materials, the right hair color

00:12:13.516 --> 00:12:14.446
to finalize the look.

00:12:14.716 --> 00:12:17.056
So we are suddenly getting from

00:12:17.576 --> 00:12:19.916
tens, hundreds, maybe thousands

00:12:19.916 --> 00:12:22.316
of draw calls to a single one.

00:12:22.636 --> 00:12:24.156
And it's faster on the CPU.

00:12:24.246 --> 00:12:25.386
It's faster on the GPU.

00:12:26.036 --> 00:12:29.466
And this is how simple it looks

00:12:29.466 --> 00:12:30.036
in a shader.

00:12:31.166 --> 00:12:33.066
Pretty much your argument buffer

00:12:33.066 --> 00:12:35.516
becomes an array of structures.

00:12:36.966 --> 00:12:40.156
You pick the right element using

00:12:40.156 --> 00:12:41.506
instance ID referenced within

00:12:41.506 --> 00:12:42.856
and you can, for example take

00:12:42.856 --> 00:12:44.526
the pointer and pass it to your

00:12:44.526 --> 00:12:46.176
helper methods or whatever you

00:12:46.226 --> 00:12:49.176
need to do to process data.

00:12:49.256 --> 00:12:51.496
The second great feature of

00:12:51.536 --> 00:12:53.206
argument buffers is the ability

00:12:53.806 --> 00:12:56.436
of the GPU to set resources.

00:12:56.436 --> 00:12:57.656
And we actually created an

00:12:57.656 --> 00:12:58.546
example for this.

00:12:59.486 --> 00:13:01.586
We created a particle simulation

00:13:01.586 --> 00:13:03.876
running completely on the GPU.

00:13:04.466 --> 00:13:06.036
And I'll tell you how we done

00:13:06.036 --> 00:13:08.216
that and we'll see the -- we'll

00:13:08.216 --> 00:13:09.506
see it in action later.

00:13:10.256 --> 00:13:11.836
So we created an array of

00:13:12.086 --> 00:13:13.316
argument buffers where each

00:13:13.366 --> 00:13:16.296
element is single particle --

00:13:16.296 --> 00:13:17.756
and I guess you already spotted

00:13:17.756 --> 00:13:19.196
a trend here.

00:13:19.766 --> 00:13:23.716
Our simulation kernel then

00:13:24.596 --> 00:13:26.696
treats and simulates one

00:13:26.696 --> 00:13:28.796
particle per thread, but we want

00:13:28.796 --> 00:13:29.966
to actually go further and we

00:13:29.966 --> 00:13:32.906
want it to be able to create the

00:13:32.906 --> 00:13:36.416
particles in the kernel as well,

00:13:36.416 --> 00:13:37.006
on the GPU.

00:13:37.006 --> 00:13:39.106
So in order to do that, and to

00:13:39.106 --> 00:13:41.316
give it the right materials, we

00:13:41.316 --> 00:13:43.016
also have argument buffer with

00:13:43.076 --> 00:13:44.686
all the different materials that

00:13:44.686 --> 00:13:45.806
we would like our particles to

00:13:45.806 --> 00:13:46.176
have.

00:13:46.906 --> 00:13:48.896
And our simulation kernel then,

00:13:49.386 --> 00:13:50.866
every time you do an action in

00:13:51.186 --> 00:13:53.826
our little demo, the simulation

00:13:53.826 --> 00:13:54.776
kernel looks into the

00:13:54.776 --> 00:13:57.066
environment and sees what's the

00:13:57.806 --> 00:13:59.446
correct, most appropriate

00:13:59.446 --> 00:13:59.906
material.

00:14:00.056 --> 00:14:01.596
And let's say if you are in the

00:14:01.596 --> 00:14:04.126
forest, we pick moss as the

00:14:04.286 --> 00:14:05.786
right, appropriate material for

00:14:05.786 --> 00:14:08.696
a rock and copy it to the

00:14:09.126 --> 00:14:10.126
particle itself.

00:14:11.366 --> 00:14:13.226
If you're on the rocks we pick

00:14:13.226 --> 00:14:14.106
the rock material.

00:14:14.106 --> 00:14:15.946
On the hill we pick grass.

00:14:16.826 --> 00:14:18.506
So this way everything stays on

00:14:18.506 --> 00:14:22.796
the GPU and it actually looks in

00:14:22.796 --> 00:14:24.206
the shader just as simple as I

00:14:24.206 --> 00:14:24.946
describe it.

00:14:25.336 --> 00:14:26.756
If you want to modify data on

00:14:26.756 --> 00:14:30.156
your GPU you bind it as a device

00:14:30.156 --> 00:14:31.486
buffer and start assigning

00:14:31.486 --> 00:14:33.866
values as you are used to, but

00:14:33.866 --> 00:14:34.986
also this time around you can

00:14:34.986 --> 00:14:37.146
copy textures or copy the whole

00:14:37.146 --> 00:14:38.676
structure and it's really this

00:14:38.676 --> 00:14:38.966
simple.

00:14:40.106 --> 00:14:42.346
And the last great feature I

00:14:42.346 --> 00:14:44.576
would like to mention is ability

00:14:44.576 --> 00:14:47.116
of argument buffers to reference

00:14:47.116 --> 00:14:48.116
another argument buffer.

00:14:48.116 --> 00:14:50.106
So this way you can actually go

00:14:50.106 --> 00:14:52.936
ahead and create a reusable and

00:14:53.026 --> 00:14:55.816
complex object hierarchy just as

00:14:55.816 --> 00:14:59.076
you are used to from C++ Swift,

00:14:59.296 --> 00:15:00.046
Objective-C.

00:15:00.566 --> 00:15:03.676
Let's say in the example of our

00:15:04.376 --> 00:15:06.496
renderer, if you have a ton of

00:15:06.536 --> 00:15:09.076
objects, but you probably have

00:15:09.726 --> 00:15:11.046
very few materials, so what you

00:15:11.046 --> 00:15:14.556
can do is reference the material

00:15:14.556 --> 00:15:15.866
from each object and save some

00:15:15.866 --> 00:15:18.336
memory or you can build your

00:15:18.336 --> 00:15:19.716
scene graph as a binary tree

00:15:19.716 --> 00:15:21.566
where actually you point to the

00:15:21.566 --> 00:15:25.186
objects and the tree nodes as

00:15:25.186 --> 00:15:26.436
you need them, as you would be

00:15:26.436 --> 00:15:27.526
used to from the CPU.

00:15:27.906 --> 00:15:29.396
And you can share this data with

00:15:29.396 --> 00:15:30.086
the CPU as well.

00:15:31.536 --> 00:15:32.846
So these are the main features.

00:15:32.846 --> 00:15:34.526
And let's look at the support

00:15:34.526 --> 00:15:35.026
matrix.

00:15:35.596 --> 00:15:37.036
We have two tiers.

00:15:37.266 --> 00:15:39.796
The tier one is supported across

00:15:39.796 --> 00:15:42.466
all Metal devices and you get

00:15:42.466 --> 00:15:43.386
the CPU performance

00:15:43.386 --> 00:15:43.926
improvements.

00:15:43.926 --> 00:15:44.866
You get the new schedule

00:15:44.866 --> 00:15:45.276
language.

00:15:45.766 --> 00:15:49.096
But because of the limitations

00:15:49.096 --> 00:15:52.296
of the GPUs this tier does not

00:15:52.896 --> 00:15:54.526
-- is not able to utilize the

00:15:55.016 --> 00:15:56.486
GPU driven use cases that I

00:15:56.486 --> 00:15:57.346
mentioned earlier.

00:15:57.776 --> 00:15:58.916
With tier two however you are

00:15:58.916 --> 00:16:00.586
getting all of this -- so you

00:16:00.586 --> 00:16:02.396
get all the new use cases -- and

00:16:02.396 --> 00:16:04.126
we are also really increasing

00:16:04.126 --> 00:16:05.736
the amount of resources you can

00:16:05.736 --> 00:16:06.176
access.

00:16:06.176 --> 00:16:07.416
Your shaders can access half a

00:16:07.466 --> 00:16:10.406
million textures and buffers to

00:16:10.406 --> 00:16:11.676
-- for you to do this -- do

00:16:11.676 --> 00:16:12.806
these new algorithms.

00:16:13.696 --> 00:16:15.696
While tier one is supported on

00:16:15.986 --> 00:16:18.526
all Metal devices, tier two is

00:16:18.526 --> 00:16:19.826
something you need to query for.

00:16:20.306 --> 00:16:22.216
But don't worry, the support is

00:16:22.216 --> 00:16:22.846
really wide.

00:16:23.556 --> 00:16:25.016
All the Macs with discrete

00:16:25.016 --> 00:16:26.166
GPUs are tier two.

00:16:26.626 --> 00:16:28.436
All the new MacBook Pros, the

00:16:28.436 --> 00:16:29.676
latest MacBook, the last tier

00:16:29.676 --> 00:16:31.586
MacBooks Pros are tier two.

00:16:31.586 --> 00:16:33.316
So you can go ahead and have

00:16:33.416 --> 00:16:33.586
fun.

00:16:34.106 --> 00:16:35.546
Now let's look at the demo I

00:16:35.546 --> 00:16:36.136
promised you.

00:16:36.226 --> 00:16:39.116
We will be showing three videos

00:16:39.426 --> 00:16:41.416
with three different features.

00:16:41.986 --> 00:16:43.936
The real time rendered terrain,

00:16:44.136 --> 00:16:45.846
with material that changes

00:16:45.846 --> 00:16:48.346
dynamically, we place some

00:16:48.346 --> 00:16:50.616
vegetation by the GPU on the

00:16:50.616 --> 00:16:51.716
terrain to make it interesting,

00:16:52.116 --> 00:16:53.326
and we have all these nice

00:16:53.326 --> 00:16:56.076
particles that I mentioned

00:16:56.076 --> 00:16:56.436
before.

00:16:56.656 --> 00:16:59.516
So, as you see, we are painting

00:17:00.006 --> 00:17:01.246
high on the terrain.

00:17:01.246 --> 00:17:02.496
We can changing sculpting the

00:17:02.496 --> 00:17:03.466
terrain and the material

00:17:03.466 --> 00:17:04.326
actually follows.

00:17:04.626 --> 00:17:05.796
And this is a great thing about

00:17:05.796 --> 00:17:08.425
argument buffers because they

00:17:08.425 --> 00:17:10.965
allowed us to create a one big

00:17:11.665 --> 00:17:13.506
argument buffer with all the

00:17:13.506 --> 00:17:16.406
possible materials as layers in

00:17:16.406 --> 00:17:18.455
there and when we are rendering

00:17:18.455 --> 00:17:20.576
the terrain in a pixel shader we

00:17:20.576 --> 00:17:21.736
are looking at things like

00:17:22.076 --> 00:17:24.846
terrain height, slope, the

00:17:25.116 --> 00:17:27.406
amount of sun that reaches

00:17:27.606 --> 00:17:29.166
certain pixels, and based on

00:17:29.166 --> 00:17:30.976
these properties and some others

00:17:30.976 --> 00:17:33.866
we do decide what are the best

00:17:34.026 --> 00:17:35.446
and most appropriate materials

00:17:35.446 --> 00:17:36.466
for that given pixel.

00:17:36.896 --> 00:17:38.046
And this is all happening in

00:17:38.046 --> 00:17:40.746
real time, whereas previously we

00:17:40.746 --> 00:17:42.436
would have to go ahead and split

00:17:42.436 --> 00:17:44.316
the terrain in small pieces

00:17:44.766 --> 00:17:47.466
offline, analyze which pieces

00:17:47.466 --> 00:17:49.206
need which textures in order to

00:17:49.206 --> 00:17:50.676
make it as optimal as possible,

00:17:51.236 --> 00:17:53.166
and only then render it.

00:17:53.166 --> 00:17:55.386
So we are going from a

00:17:55.456 --> 00:17:56.546
pre-processing step, which is

00:17:56.546 --> 00:17:58.366
heavy and prevents real time

00:17:58.366 --> 00:18:00.496
modification, to something that

00:18:00.496 --> 00:18:02.226
is real time, without -- sorry

00:18:02.286 --> 00:18:04.716
-- without preprocessing and

00:18:04.716 --> 00:18:05.626
completely dynamic.

00:18:08.976 --> 00:18:11.986
And we added vegetation on it

00:18:12.296 --> 00:18:14.086
and as you see the vegetation is

00:18:14.086 --> 00:18:16.196
also context sensitive.

00:18:17.026 --> 00:18:18.766
You see the palm trees on the

00:18:18.766 --> 00:18:19.136
sand.

00:18:19.136 --> 00:18:20.826
You see the little tiny apple

00:18:20.826 --> 00:18:21.816
trees on the hills.

00:18:23.446 --> 00:18:25.536
And while the vegetation itself

00:18:25.536 --> 00:18:28.176
is fairly traditional instance

00:18:28.176 --> 00:18:29.776
rendering, the power of the

00:18:29.776 --> 00:18:32.396
argument buffers here is that it

00:18:32.396 --> 00:18:34.086
allows us to share the same

00:18:34.416 --> 00:18:36.006
terrain material with all the

00:18:36.006 --> 00:18:37.846
same properties and the same

00:18:37.846 --> 00:18:39.646
terrain analysis function

00:18:40.126 --> 00:18:41.486
between two completely separate

00:18:41.486 --> 00:18:43.446
pieces of code.

00:18:43.676 --> 00:18:45.246
While terrain rendering uses all

00:18:45.246 --> 00:18:47.326
this data to render pixels, the

00:18:47.326 --> 00:18:48.796
computer that places the

00:18:48.796 --> 00:18:50.316
geometry, the vegetation,

00:18:50.686 --> 00:18:51.956
actually analyzes the same

00:18:51.956 --> 00:18:53.786
materials to figure out what is

00:18:53.786 --> 00:18:56.266
the best type of tree to place

00:18:56.266 --> 00:18:57.026
in the given spot.

00:18:57.486 --> 00:18:58.616
And this is very easy because

00:18:58.616 --> 00:18:59.836
every time we make a change

00:19:00.166 --> 00:19:01.566
nothing actually changes in our

00:19:01.566 --> 00:19:02.686
code because we just add new

00:19:02.686 --> 00:19:04.516
layers or change our analysis

00:19:04.516 --> 00:19:06.806
function, whereas previously we

00:19:06.806 --> 00:19:08.526
would have to maybe juggle 70

00:19:08.526 --> 00:19:10.226
textures between two completely

00:19:10.226 --> 00:19:11.776
separate code basis in order to

00:19:11.816 --> 00:19:17.036
make them run in sync.

00:19:17.216 --> 00:19:19.406
Lastly, we have the particles.

00:19:19.406 --> 00:19:22.226
I hope you can see that they

00:19:22.226 --> 00:19:25.146
nicely get the material of the

00:19:25.146 --> 00:19:25.916
terrain there.

00:19:26.876 --> 00:19:28.606
Now what I did not mention is

00:19:28.606 --> 00:19:30.866
that this all is rendered with

00:19:31.126 --> 00:19:32.816
again a single draw call.

00:19:32.816 --> 00:19:34.756
We are rendering 16,000

00:19:35.086 --> 00:19:38.006
particles here with single draw

00:19:38.006 --> 00:19:39.776
call, with absolutely no

00:19:39.816 --> 00:19:41.586
involvement on the CPU.

00:19:42.406 --> 00:19:44.486
And not only do particles have

00:19:44.826 --> 00:19:46.316
unique materials, they actually

00:19:46.316 --> 00:19:47.486
have unique shapes because

00:19:47.766 --> 00:19:48.876
argument buffers allow --

00:19:48.936 --> 00:19:50.176
actually allow you to change

00:19:50.176 --> 00:19:52.166
your vertex buffer per draw

00:19:52.166 --> 00:19:52.466
call.

00:19:53.526 --> 00:19:56.076
This is something where if you

00:19:56.076 --> 00:19:58.466
try to do that without argument

00:19:58.466 --> 00:20:01.956
buffers, we had to create a

00:20:01.956 --> 00:20:04.496
complicated control hand over

00:20:04.496 --> 00:20:06.856
between GPU that simulates and

00:20:06.856 --> 00:20:08.036
the CPU that tries to come up

00:20:08.036 --> 00:20:09.866
with the best set of draw calls

00:20:09.866 --> 00:20:11.356
to represent all this variety.

00:20:11.776 --> 00:20:13.396
So with argument buffers this

00:20:13.396 --> 00:20:17.116
became just very, very simple.

00:20:18.346 --> 00:20:21.706
Okay, so enough pretty pictures.

00:20:22.296 --> 00:20:25.226
And let's wrap my portion of the

00:20:25.226 --> 00:20:28.406
session with a look at some APIs

00:20:28.406 --> 00:20:29.716
and some best practices.

00:20:29.986 --> 00:20:33.426
As I mentioned before, argument

00:20:33.426 --> 00:20:34.926
buffers are an extension of

00:20:34.926 --> 00:20:37.426
Metal buffers and that means all

00:20:37.426 --> 00:20:39.286
of our API related to buffers

00:20:39.286 --> 00:20:39.776
just works.

00:20:39.776 --> 00:20:40.946
You can go ahead and take

00:20:40.946 --> 00:20:42.196
argument buffer, copy it

00:20:42.196 --> 00:20:43.456
somewhere else; you can blitz it

00:20:43.456 --> 00:20:44.976
between CPU and GPU.

00:20:45.826 --> 00:20:48.106
And while argument buffers look

00:20:48.106 --> 00:20:51.266
like structures on the GPU for

00:20:51.266 --> 00:20:54.796
shaders, on the CPU you will use

00:20:54.796 --> 00:20:56.816
MTLArgumentEncoder objects to

00:20:56.816 --> 00:20:57.716
fill up the content.

00:20:58.676 --> 00:21:02.196
This abstraction allows Metal to

00:21:02.196 --> 00:21:04.696
create the most optimal memory

00:21:05.186 --> 00:21:06.686
representation for any given

00:21:06.686 --> 00:21:08.316
argument buffer on that specific

00:21:08.316 --> 00:21:09.376
GPU that you are actually

00:21:09.376 --> 00:21:09.716
running.

00:21:10.206 --> 00:21:11.506
So you get the best performance.

00:21:11.896 --> 00:21:13.266
It also frees you, as the

00:21:13.266 --> 00:21:14.686
developer, from all these

00:21:15.646 --> 00:21:19.956
details and worries about, for

00:21:19.956 --> 00:21:21.956
example how each GPU represents

00:21:22.096 --> 00:21:22.966
what the texture is.

00:21:22.966 --> 00:21:23.986
Where does it live in memory?

00:21:24.616 --> 00:21:26.746
All of this changes from

00:21:26.886 --> 00:21:28.776
platform to platform and we hide

00:21:28.776 --> 00:21:31.356
it between a simple interface so

00:21:31.356 --> 00:21:32.616
that you can write very simple

00:21:32.616 --> 00:21:33.826
and effective applications.

00:21:34.506 --> 00:21:37.106
So I hope you're not worried

00:21:37.106 --> 00:21:38.006
about the encoder that I

00:21:38.006 --> 00:21:38.376
mentioned.

00:21:38.376 --> 00:21:39.886
It's really, really simple to

00:21:39.886 --> 00:21:40.286
use.

00:21:41.346 --> 00:21:42.396
For example, if you want to

00:21:42.396 --> 00:21:43.856
create an argument encoder for

00:21:43.856 --> 00:21:46.386
this argument buffer all you

00:21:46.386 --> 00:21:49.886
need to do is get your Metal

00:21:49.886 --> 00:21:51.386
function that uses the argument

00:21:51.386 --> 00:21:53.736
buffer and ask the Metal

00:21:53.736 --> 00:21:55.386
function for the encoder and

00:21:55.386 --> 00:21:56.116
that's about this.

00:21:56.116 --> 00:21:57.386
This is all you needed to do.

00:21:57.386 --> 00:21:59.526
You get an object and you start

00:21:59.526 --> 00:22:02.066
using a familiar set texture or

00:22:02.486 --> 00:22:04.586
filling constant API that is

00:22:04.586 --> 00:22:05.906
very, very similar to how you've

00:22:05.906 --> 00:22:08.666
been using Metal with command

00:22:08.666 --> 00:22:09.016
encoder.

00:22:09.016 --> 00:22:11.916
So this also plays into what I

00:22:11.916 --> 00:22:15.116
said about ease of use and

00:22:15.116 --> 00:22:15.846
transition.

00:22:16.866 --> 00:22:18.736
There are multiple other ways of

00:22:18.736 --> 00:22:20.546
creating the encoder.

00:22:20.546 --> 00:22:21.786
You can go more explicit with

00:22:21.786 --> 00:22:22.686
the descriptor, but that's

00:22:22.686 --> 00:22:24.706
something you should look into

00:22:24.876 --> 00:22:26.036
in documentation if you need

00:22:26.036 --> 00:22:27.326
such thing.

00:22:27.326 --> 00:22:28.956
We advise you to actually go and

00:22:29.566 --> 00:22:30.866
get argument encoders from the

00:22:30.866 --> 00:22:31.386
shaders.

00:22:33.846 --> 00:22:36.706
Now with all those interactions,

00:22:36.706 --> 00:22:38.396
GPU being able to step in and

00:22:38.396 --> 00:22:40.436
modify the argument buffers or

00:22:41.036 --> 00:22:42.286
you know dynamic indexing and

00:22:42.286 --> 00:22:44.356
half a million textures, all

00:22:44.356 --> 00:22:47.526
that in a mix, it's not really

00:22:47.906 --> 00:22:49.366
possible for Metal to figure out

00:22:49.366 --> 00:22:50.466
what -- for example what

00:22:50.466 --> 00:22:52.226
textures or buffers do actually

00:22:52.226 --> 00:22:55.396
intend to use in your rendering,

00:22:55.396 --> 00:22:57.006
but luckily you as a developer

00:22:57.006 --> 00:22:58.916
have pretty good idea about

00:22:58.916 --> 00:22:59.126
that.

00:22:59.126 --> 00:23:01.276
So we ask you with argument

00:23:01.276 --> 00:23:02.716
buffers to be quite explicit

00:23:02.716 --> 00:23:03.066
about it.

00:23:04.266 --> 00:23:05.776
If you are using Heaps, and

00:23:06.646 --> 00:23:08.336
absolutely you should use Heaps

00:23:08.336 --> 00:23:09.896
to get the best performance out

00:23:09.896 --> 00:23:12.506
of your platform and the best

00:23:12.506 --> 00:23:13.766
way of organizing your data, the

00:23:14.366 --> 00:23:15.586
only thing you need to do is

00:23:15.586 --> 00:23:16.936
tell Metal that you intend to

00:23:16.936 --> 00:23:18.886
use a Heap , or multiple Heaps,

00:23:18.886 --> 00:23:19.816
it's up to you.

00:23:19.816 --> 00:23:22.356
And -- this is -- this makes

00:23:22.356 --> 00:23:24.196
sure that the textures are

00:23:24.196 --> 00:23:25.546
available for you in the

00:23:25.546 --> 00:23:27.696
rendering loop.

00:23:27.696 --> 00:23:29.066
If you want to do something more

00:23:29.066 --> 00:23:30.076
specific, let's say you would

00:23:30.076 --> 00:23:32.586
like to write to a render target

00:23:32.586 --> 00:23:34.556
from inside a shader, or you

00:23:34.556 --> 00:23:35.626
would like to read from a dev

00:23:35.626 --> 00:23:38.466
buffer, you use a more specific

00:23:38.466 --> 00:23:40.466
API and tell Metal that you

00:23:40.466 --> 00:23:42.476
intend to change resource and --

00:23:43.476 --> 00:23:44.516
with a specific way.

00:23:44.516 --> 00:23:46.076
And again, it's as simple as

00:23:46.076 --> 00:23:46.166
this.

00:23:46.166 --> 00:23:46.836
You don't need to do anything

00:23:46.836 --> 00:23:46.976
else.

00:23:50.506 --> 00:23:52.196
So let's start out with a couple

00:23:52.196 --> 00:23:53.116
of best practices.

00:23:53.116 --> 00:23:55.986
I think if you know Metal they

00:23:55.986 --> 00:23:58.076
are very, very similar to what

00:23:58.076 --> 00:24:00.076
we are telling you about using

00:24:00.076 --> 00:24:00.716
Metal buffers.

00:24:01.156 --> 00:24:02.586
The best way to organize your

00:24:02.586 --> 00:24:04.706
data is by usage pattern.

00:24:04.706 --> 00:24:05.856
And you probably have a ton of

00:24:05.856 --> 00:24:08.406
properties that do not change

00:24:08.686 --> 00:24:09.306
per frame.

00:24:09.396 --> 00:24:10.536
So put them into an argument

00:24:10.536 --> 00:24:11.956
buffer and share it with all the

00:24:11.956 --> 00:24:13.166
objects so you will save memory

00:24:13.166 --> 00:24:13.536
this way.

00:24:14.286 --> 00:24:16.076
The same -- on the same -- on

00:24:16.076 --> 00:24:17.756
the other hand you will probably

00:24:17.756 --> 00:24:19.566
have a lot of properties that

00:24:19.566 --> 00:24:21.106
actually do change for every

00:24:21.106 --> 00:24:23.496
object and you need to manage

00:24:23.496 --> 00:24:24.346
them every frame.

00:24:24.346 --> 00:24:26.946
And for these I think the best

00:24:26.946 --> 00:24:28.066
way is to put those into

00:24:28.066 --> 00:24:29.226
separate argument buffers so

00:24:29.226 --> 00:24:30.396
that you can double buffer it or

00:24:30.396 --> 00:24:32.056
whatever is your management

00:24:32.056 --> 00:24:34.786
scheme and you don't need to do

00:24:34.786 --> 00:24:36.576
all the other copies to keep all

00:24:36.576 --> 00:24:37.266
the data in there.

00:24:37.706 --> 00:24:39.186
And then you will likely have a

00:24:39.186 --> 00:24:41.326
ton of argument buffers that

00:24:41.786 --> 00:24:43.286
just don't change at all.

00:24:43.286 --> 00:24:44.456
Let's say the materials, or

00:24:45.026 --> 00:24:46.816
maybe some other properties, and

00:24:46.966 --> 00:24:49.296
for these just create them at

00:24:49.296 --> 00:24:50.296
the initialization of your

00:24:50.296 --> 00:24:53.826
application and keep using them.

00:24:54.026 --> 00:24:57.576
Similar to Metal buffers, think

00:24:57.576 --> 00:24:59.816
about your data locality and how

00:24:59.816 --> 00:25:01.566
you actually use your argument

00:25:01.566 --> 00:25:01.916
buffers.

00:25:02.246 --> 00:25:03.816
If, for example you have three

00:25:03.816 --> 00:25:06.076
textures that are accessed in a

00:25:06.076 --> 00:25:08.776
shader, one after another, then

00:25:09.316 --> 00:25:10.836
the best thing you can do is

00:25:10.836 --> 00:25:12.046
actually put those textures

00:25:12.046 --> 00:25:13.216
close to each other in argument

00:25:13.216 --> 00:25:14.566
buffers so that you maximize the

00:25:14.566 --> 00:25:16.466
use of GPU caches.

00:25:17.376 --> 00:25:18.146
And as I mentioned at the

00:25:18.146 --> 00:25:20.736
beginning, traditional argument

00:25:20.736 --> 00:25:23.716
model is not going anywhere and

00:25:23.716 --> 00:25:25.576
you should take advantage of it

00:25:25.576 --> 00:25:26.776
and mix it with the argument

00:25:26.776 --> 00:25:28.116
buffers whenever it's more

00:25:28.116 --> 00:25:28.786
convenient.

00:25:29.296 --> 00:25:30.626
So let's say if you need to

00:25:30.626 --> 00:25:32.256
change a single texture for

00:25:33.376 --> 00:25:35.786
every object, for example a cube

00:25:35.786 --> 00:25:37.606
reflection, it probably would be

00:25:37.606 --> 00:25:38.786
an overhead to create argument

00:25:38.786 --> 00:25:40.096
buffer just for that and upload

00:25:40.096 --> 00:25:40.896
it every frame.

00:25:40.896 --> 00:25:42.826
So just use the traditional

00:25:42.826 --> 00:25:43.526
model for this.

00:25:43.656 --> 00:25:46.216
That's it about argument

00:25:46.216 --> 00:25:46.576
buffers.

00:25:46.576 --> 00:25:50.256
I really hope you will adopt our

00:25:50.256 --> 00:25:52.516
new API and get some creative

00:25:52.806 --> 00:25:53.596
use cases out of it.

00:25:54.136 --> 00:25:57.456
And please welcome Richard, who

00:25:57.546 --> 00:25:59.156
will talk about the Raster Order

00:25:59.156 --> 00:25:59.506
Groups.

00:26:00.556 --> 00:26:02.556
[ Applause ]

00:26:02.596 --> 00:26:03.016
>> Thank you.

00:26:05.046 --> 00:26:06.686
Hello. So thank you Michal.

00:26:06.826 --> 00:26:07.776
So I'm going to take you through

00:26:07.776 --> 00:26:08.436
the rest of the day's

00:26:08.436 --> 00:26:10.006
presentation, starting with

00:26:10.046 --> 00:26:10.936
Raster Order Groups.

00:26:12.476 --> 00:26:14.196
So this is a new feature that

00:26:14.196 --> 00:26:16.636
gives you control over the GPU's

00:26:16.726 --> 00:26:17.866
thread scheduling to run

00:26:18.196 --> 00:26:19.686
fragment shooter threads, in

00:26:19.746 --> 00:26:20.086
order.

00:26:20.686 --> 00:26:22.096
This allows overlapping fragment

00:26:22.096 --> 00:26:23.266
shooter threads to communicate

00:26:23.266 --> 00:26:24.876
through memory, where before it

00:26:24.876 --> 00:26:27.366
wasn't always really possible to

00:26:27.366 --> 00:26:28.286
do in most cases.

00:26:28.646 --> 00:26:30.246
So this opens up a whole new set

00:26:30.246 --> 00:26:31.266
of graphics algorithms that were

00:26:31.266 --> 00:26:32.956
not practically achievable with

00:26:33.156 --> 00:26:34.206
just write only access to your

00:26:34.206 --> 00:26:36.196
frame buffers or onward access

00:26:36.196 --> 00:26:37.216
memory to device memory.

00:26:38.476 --> 00:26:40.986
For example, one of our key --

00:26:40.986 --> 00:26:42.226
one of the key applications for

00:26:42.306 --> 00:26:43.156
this is Order-independent

00:26:43.156 --> 00:26:43.926
transparency.

00:26:44.746 --> 00:26:46.106
We've been -- already talked a

00:26:46.106 --> 00:26:47.476
lot today about how to reduce

00:26:47.476 --> 00:26:48.596
the CP usage of your Metal

00:26:48.596 --> 00:26:50.356
application and this feature

00:26:50.356 --> 00:26:52.006
lets you build or an algorithm

00:26:52.476 --> 00:26:54.456
to include blending back to

00:26:54.456 --> 00:26:56.116
front without having to pay the

00:26:56.116 --> 00:26:57.526
CPU cost of triangle level

00:26:57.526 --> 00:26:57.896
sorting.

00:26:59.536 --> 00:27:00.736
There's also been lots of

00:27:00.736 --> 00:27:01.836
investigations into advanced

00:27:01.836 --> 00:27:03.176
techniques such as dual layer

00:27:03.396 --> 00:27:04.236
G-buffers, which can

00:27:04.236 --> 00:27:05.946
substantially improve post

00:27:05.946 --> 00:27:07.596
processing results, or using the

00:27:07.596 --> 00:27:08.846
GPU rasterizer to sort of

00:27:08.846 --> 00:27:10.196
voxelize triangle meshes.

00:27:11.056 --> 00:27:12.716
For both of these onward

00:27:12.716 --> 00:27:13.826
accesses to memory has been a

00:27:13.826 --> 00:27:15.336
really large barrier to

00:27:15.336 --> 00:27:16.516
efficient implementations.

00:27:17.296 --> 00:27:18.976
But probably the simplest and

00:27:18.976 --> 00:27:20.566
most common application for this

00:27:20.566 --> 00:27:21.836
feature is just implementing

00:27:21.836 --> 00:27:22.776
custom blend equations.

00:27:23.656 --> 00:27:25.076
iOS hardware could always do

00:27:25.076 --> 00:27:27.336
this pretty natively, but this

00:27:27.336 --> 00:27:29.406
is not something that desktop

00:27:29.406 --> 00:27:31.066
hardware has traditionally been

00:27:31.066 --> 00:27:31.686
able to do.

00:27:32.656 --> 00:27:33.906
So I'm going to use custom

00:27:33.906 --> 00:27:34.986
blending as an example

00:27:34.986 --> 00:27:36.076
application to introduce this

00:27:36.076 --> 00:27:36.346
feature.

00:27:38.076 --> 00:27:40.086
Okay, so pretty typical case of

00:27:40.126 --> 00:27:41.316
triangle blending; one triangle

00:27:41.316 --> 00:27:41.836
over another.

00:27:42.776 --> 00:27:45.036
Pretty much all modern GPU APIs

00:27:45.036 --> 00:27:46.386
guarantee that blending happens

00:27:46.386 --> 00:27:47.426
in draw call order.

00:27:47.566 --> 00:27:48.856
It provides this nice,

00:27:48.926 --> 00:27:50.416
convenient illusion of serial

00:27:50.416 --> 00:27:50.946
execution.

00:27:51.796 --> 00:27:53.376
But of course what's really

00:27:53.376 --> 00:27:54.586
going on behind the scenes is

00:27:54.676 --> 00:27:56.026
GPU hardware's highly parallel.

00:27:56.026 --> 00:27:57.056
It's going to be running

00:27:57.056 --> 00:27:58.256
multiple threads concurrently.

00:27:58.836 --> 00:28:00.296
And only this fixed-function

00:28:00.296 --> 00:28:01.786
blend step at the end is going

00:28:01.786 --> 00:28:03.046
to be delayed until everything

00:28:03.046 --> 00:28:05.776
gets put back in order again.

00:28:05.776 --> 00:28:06.876
There's this implicit wait that

00:28:06.876 --> 00:28:08.906
happens before that blend step.

00:28:10.476 --> 00:28:12.686
Things change however if the

00:28:12.686 --> 00:28:13.616
ordering -- if we need to put

00:28:13.616 --> 00:28:14.766
things in order not at the end

00:28:14.766 --> 00:28:16.326
of our fragment shooter, but

00:28:16.416 --> 00:28:18.066
right in the middle because in

00:28:18.066 --> 00:28:20.156
this case triangle one wants to

00:28:20.156 --> 00:28:21.316
write something to memory that

00:28:21.316 --> 00:28:22.596
triangle two's threads want to

00:28:22.596 --> 00:28:23.026
read from.

00:28:23.306 --> 00:28:25.016
If we want triangle two to be

00:28:25.016 --> 00:28:26.236
able to build upon and consume

00:28:26.236 --> 00:28:28.026
triangle one's data we need to

00:28:28.026 --> 00:28:28.906
get that ordering back.

00:28:29.646 --> 00:28:32.366
And so that's pretty much what

00:28:32.366 --> 00:28:33.576
Raster Order Groups provides.

00:28:34.706 --> 00:28:37.116
So I'm going to jump over to a

00:28:37.206 --> 00:28:38.156
shader code example.

00:28:39.806 --> 00:28:41.116
So if I want to implement custom

00:28:41.116 --> 00:28:42.466
blending, an initial attempt

00:28:42.636 --> 00:28:44.456
that does not work is going to

00:28:44.456 --> 00:28:45.726
be to replace my classic

00:28:45.726 --> 00:28:46.696
graphics frame buffer with a

00:28:46.696 --> 00:28:47.996
read to write texture and

00:28:47.996 --> 00:28:49.696
perform all of my rendering and

00:28:49.696 --> 00:28:50.636
blending directly to this

00:28:50.636 --> 00:28:50.956
texture.

00:28:51.776 --> 00:28:53.976
But of course if the threads

00:28:53.976 --> 00:28:55.206
that I'm blending over have yet

00:28:55.206 --> 00:28:56.416
to execute, or concurrently

00:28:56.416 --> 00:28:59.066
executing, this is -- this whole

00:28:59.166 --> 00:29:00.596
remodify/write sequence is going

00:29:00.596 --> 00:29:01.546
to create a race condition.

00:29:02.076 --> 00:29:03.876
So how do we use Raster Order

00:29:03.876 --> 00:29:05.146
Groups to fix this?

00:29:05.316 --> 00:29:07.416
It's really, really easy.

00:29:08.626 --> 00:29:10.146
All I have to do is add a new

00:29:10.276 --> 00:29:12.996
attribute to the memory that has

00:29:12.996 --> 00:29:14.086
conflicting accesses.

00:29:14.866 --> 00:29:16.906
At this point the compiler and

00:29:16.906 --> 00:29:17.636
the hardware are going to

00:29:17.636 --> 00:29:18.876
cooperate to be able to

00:29:18.876 --> 00:29:20.616
implicitly take the entire range

00:29:20.866 --> 00:29:21.806
of [inaudible] shader that

00:29:21.806 --> 00:29:22.996
accesses that memory from the

00:29:22.996 --> 00:29:24.176
very first to the very last

00:29:24.176 --> 00:29:25.386
access and turn it into a

00:29:25.386 --> 00:29:26.366
critical section behind the

00:29:26.366 --> 00:29:26.836
scenes.

00:29:28.806 --> 00:29:29.826
You can also apply this

00:29:29.826 --> 00:29:31.296
attribute to normal device

00:29:31.296 --> 00:29:33.846
memory pointers, not just

00:29:34.536 --> 00:29:34.886
textures.

00:29:34.886 --> 00:29:37.606
So with that we get the thread

00:29:37.606 --> 00:29:38.536
schedule that we want.

00:29:39.216 --> 00:29:40.406
Thread one will proceed and

00:29:40.406 --> 00:29:42.116
write to memory and thread two

00:29:42.116 --> 00:29:43.526
is going to stop and wait until

00:29:43.526 --> 00:29:46.046
thread one's write's complete

00:29:46.046 --> 00:29:47.916
giving us basically race free

00:29:47.916 --> 00:29:51.576
access to this memory.

00:29:51.926 --> 00:29:53.096
Oh, there's one other really

00:29:53.096 --> 00:29:54.106
important topic and that's

00:29:54.106 --> 00:29:56.016
talking about which threads are

00:29:56.016 --> 00:29:57.266
synchronizing with each other.

00:29:57.706 --> 00:29:59.656
So of course GPU hardware's

00:29:59.656 --> 00:30:00.486
going to be running not just

00:30:00.486 --> 00:30:02.296
two, but tens of thousands of

00:30:02.296 --> 00:30:05.146
threads at the same time and in

00:30:05.246 --> 00:30:06.396
fact it's probably executing

00:30:06.436 --> 00:30:07.746
every single thread from both of

00:30:07.746 --> 00:30:09.136
these triangles simultaneously.

00:30:09.616 --> 00:30:12.056
So of all of these thousands --

00:30:12.056 --> 00:30:12.816
tens of thousands -- of threads,

00:30:12.816 --> 00:30:13.966
which one synchronizes with each

00:30:13.966 --> 00:30:14.176
other?

00:30:15.836 --> 00:30:17.786
So I've highlighted one pixel

00:30:17.786 --> 00:30:18.986
here because that's the answer

00:30:18.986 --> 00:30:19.586
to this question.

00:30:20.356 --> 00:30:21.876
You -- this feature only

00:30:21.876 --> 00:30:22.846
synchronizes against other

00:30:22.846 --> 00:30:23.986
threads that your current

00:30:23.986 --> 00:30:25.526
fragment shooter thread overlaps

00:30:25.526 --> 00:30:27.516
with, those other threads that

00:30:27.596 --> 00:30:29.106
are targeting the same frame

00:30:29.106 --> 00:30:31.146
buffer xy location, targeting

00:30:31.146 --> 00:30:32.886
the same multi-sample location,

00:30:33.196 --> 00:30:34.306
targeting the same render target

00:30:34.306 --> 00:30:34.786
index.

00:30:36.726 --> 00:30:37.776
If I wanted -- and it

00:30:37.776 --> 00:30:39.096
specifically does not provide

00:30:39.136 --> 00:30:40.756
any guarantees at all against --

00:30:40.756 --> 00:30:41.836
that you can safely access

00:30:41.836 --> 00:30:43.376
memory that are written by any

00:30:43.376 --> 00:30:44.276
neighboring pixels.

00:30:45.366 --> 00:30:46.816
If you do need to have these

00:30:46.816 --> 00:30:48.496
kind of area -- or region of

00:30:48.496 --> 00:30:49.726
influence -- kind of algorithms

00:30:50.096 --> 00:30:51.156
then you will need to go back to

00:30:51.156 --> 00:30:52.326
using full memory barriers

00:30:52.356 --> 00:30:53.736
between draw call -- or full API

00:30:53.736 --> 00:30:54.916
barriers between draw calls or

00:30:54.916 --> 00:30:55.666
render passes.

00:30:56.376 --> 00:30:57.846
But this comes at a much higher

00:30:57.846 --> 00:30:59.656
performance cost and it does not

00:30:59.656 --> 00:31:00.876
work in the case where you have

00:31:00.876 --> 00:31:02.236
triangle overlap within a single

00:31:02.236 --> 00:31:02.696
draw call.

00:31:03.336 --> 00:31:05.256
But for these common algorithms

00:31:05.256 --> 00:31:06.806
that you do have only need

00:31:06.806 --> 00:31:08.206
overlap only synchronization,

00:31:08.836 --> 00:31:09.976
Raster Order Groups can get the

00:31:09.976 --> 00:31:11.286
job done at a substantially

00:31:11.286 --> 00:31:13.866
lower performance cost.

00:31:13.866 --> 00:31:15.486
So this is a pretty actually

00:31:15.676 --> 00:31:16.716
easy one and that's really all

00:31:16.716 --> 00:31:17.356
I've got to say about it.

00:31:17.396 --> 00:31:19.546
Raster Order Groups lets you

00:31:19.546 --> 00:31:21.246
efficiently wait for overlapping

00:31:21.516 --> 00:31:24.046
and only overlapping threads to

00:31:24.046 --> 00:31:25.136
finish their access to memory,

00:31:25.806 --> 00:31:27.586
which enables a collection of GP

00:31:27.586 --> 00:31:28.736
algorithms that were previously

00:31:28.736 --> 00:31:30.026
just too inefficient to use

00:31:30.026 --> 00:31:31.296
practically in GPU hardware.

00:31:33.516 --> 00:31:35.766
This middle of shader thread

00:31:35.766 --> 00:31:37.076
summarization is a feature of

00:31:37.076 --> 00:31:38.556
the latest GPU hardware, so it

00:31:38.556 --> 00:31:39.286
is something you do need to

00:31:39.286 --> 00:31:40.426
check for at run time.

00:31:41.106 --> 00:31:42.446
In particular it's supported on

00:31:42.446 --> 00:31:43.896
the newest AMD Vega GPUs

00:31:43.896 --> 00:31:45.256
announced this week as well as

00:31:45.256 --> 00:31:46.356
the past couple years' worth of

00:31:46.356 --> 00:31:47.216
Intel GPUs.

00:31:49.136 --> 00:31:50.196
And that brings us on to our

00:31:50.196 --> 00:31:51.286
second feature and that is the

00:31:51.286 --> 00:31:52.616
new iPad Pro's ProMotion

00:31:52.616 --> 00:31:52.966
Display.

00:32:01.056 --> 00:32:02.486
So ProMotion, this is a

00:32:02.616 --> 00:32:04.006
particularly great feature for

00:32:04.006 --> 00:32:05.186
graphics and game developers and

00:32:05.186 --> 00:32:06.226
so I really want to show you

00:32:06.226 --> 00:32:07.626
what you can do with it.

00:32:07.946 --> 00:32:10.466
This is the first of a sequence

00:32:10.466 --> 00:32:11.606
of timeline diagrams I'm going

00:32:11.606 --> 00:32:13.946
to show you, showing us when the

00:32:13.946 --> 00:32:15.606
GPU starts and finishes

00:32:15.606 --> 00:32:16.916
producing a frame, and then when

00:32:16.916 --> 00:32:18.056
that same frame finally gets

00:32:18.056 --> 00:32:19.256
onto the glass for the user to

00:32:19.256 --> 00:32:19.526
see.

00:32:20.646 --> 00:32:22.116
The first and most obvious thing

00:32:22.116 --> 00:32:23.356
that ProMotion does is we can

00:32:23.356 --> 00:32:25.146
now render at 120 frames per

00:32:25.146 --> 00:32:25.556
second.

00:32:27.316 --> 00:32:28.896
This feels absolutely fantastic

00:32:28.896 --> 00:32:29.896
for anything that has really

00:32:29.896 --> 00:32:31.616
high speed animations, for

00:32:31.616 --> 00:32:32.796
anything that's latency critical

00:32:32.796 --> 00:32:34.096
such as tracking user touch or

00:32:34.096 --> 00:32:34.756
pencil input.

00:32:35.576 --> 00:32:37.876
And it does have some catches.

00:32:37.876 --> 00:32:40.336
You of course only get half as

00:32:40.336 --> 00:32:42.146
much CPU and GPU time available

00:32:42.146 --> 00:32:43.596
per frame so you really have to

00:32:43.596 --> 00:32:44.356
pay a lot of attention to

00:32:44.356 --> 00:32:46.196
optimization and it does

00:32:46.196 --> 00:32:47.276
increase overall system power

00:32:47.276 --> 00:32:47.836
consumption.

00:32:48.816 --> 00:32:49.546
But if you've got the right

00:32:49.546 --> 00:32:51.506
content, where this matters, it

00:32:51.506 --> 00:32:52.686
gets a really payoff for the

00:32:52.686 --> 00:32:53.576
user experience.

00:32:55.006 --> 00:32:56.566
But ProMotion goes a lot farther

00:32:56.566 --> 00:32:58.096
than 120 frames per second

00:32:58.096 --> 00:32:58.436
rendering.

00:32:59.176 --> 00:33:01.626
It also provides much more

00:33:01.626 --> 00:33:03.496
flexibility regarding when to

00:33:03.496 --> 00:33:04.546
swap the next image onto the

00:33:04.546 --> 00:33:05.016
glass.

00:33:05.726 --> 00:33:07.776
We're not limited to just 120 or

00:33:07.776 --> 00:33:09.906
30 or 60 frames per second.

00:33:10.486 --> 00:33:12.816
ProMotion behaves much more

00:33:12.816 --> 00:33:14.056
gracefully as your application's

00:33:14.056 --> 00:33:15.446
performance moves up and down

00:33:15.716 --> 00:33:16.756
compared to a fixed frame rate

00:33:16.756 --> 00:33:17.166
display.

00:33:18.376 --> 00:33:21.186
For example, here I have a

00:33:21.226 --> 00:33:22.586
timeline diagram of a title

00:33:22.586 --> 00:33:23.926
that, you know just -- is just

00:33:23.926 --> 00:33:24.986
doing too much GPU work to

00:33:24.986 --> 00:33:26.356
target 60 frames per second.

00:33:26.516 --> 00:33:27.226
You know they're producing

00:33:27.226 --> 00:33:28.906
frames every about 21

00:33:28.906 --> 00:33:30.366
milliseconds or about 48 frames

00:33:30.366 --> 00:33:30.836
per second.

00:33:31.576 --> 00:33:33.466
The GPU is perfectly happy to do

00:33:33.466 --> 00:33:35.526
that, but on the display side we

00:33:35.526 --> 00:33:37.076
can only refresh once every 16

00:33:37.076 --> 00:33:38.176
milliseconds and so we end up

00:33:38.176 --> 00:33:38.976
with this beating pattern.

00:33:39.046 --> 00:33:40.126
There's this stuttering that the

00:33:40.126 --> 00:33:41.866
user feels where some frames are

00:33:41.866 --> 00:33:42.916
on the glass a lot longer than

00:33:42.916 --> 00:33:43.356
others.

00:33:44.056 --> 00:33:47.006
And it's not nice at all.

00:33:47.306 --> 00:33:48.866
And so pretty much universally

00:33:48.866 --> 00:33:49.846
what applications do in this

00:33:49.846 --> 00:33:50.586
case is they all have to

00:33:50.586 --> 00:33:51.976
artificially constrain the frame

00:33:51.976 --> 00:33:53.776
rate all the way down to 30

00:33:53.776 --> 00:33:56.336
frames per second.

00:33:56.336 --> 00:33:57.686
They're basically trading away

00:33:57.686 --> 00:33:59.036
their peak frame rate in order

00:33:59.036 --> 00:33:59.926
to get some level of

00:33:59.926 --> 00:34:00.556
consistency.

00:34:02.176 --> 00:34:04.146
ProMotion does much better here.

00:34:04.616 --> 00:34:05.636
So if I just take the same

00:34:05.636 --> 00:34:06.596
application, move it to a

00:34:06.596 --> 00:34:09.126
ProMotion display, it does this

00:34:09.126 --> 00:34:09.755
to our timeline.

00:34:10.826 --> 00:34:12.036
We now have a refresh point

00:34:12.036 --> 00:34:13.596
every four milliseconds rather

00:34:13.596 --> 00:34:14.356
than every 16.

00:34:15.266 --> 00:34:16.646
Our timeline gets pulled in,

00:34:16.866 --> 00:34:18.286
even with the GPU doing exactly

00:34:18.286 --> 00:34:19.286
the same work as before.

00:34:19.906 --> 00:34:21.976
The display can now present at

00:34:21.976 --> 00:34:23.626
an entirely consistent 48 frames

00:34:23.626 --> 00:34:24.136
per second.

00:34:24.985 --> 00:34:26.466
The user is now getting both the

00:34:26.466 --> 00:34:28.176
best possible frame rate and

00:34:28.176 --> 00:34:30.156
perfect consistency from frame

00:34:30.156 --> 00:34:30.545
to frame.

00:34:31.186 --> 00:34:32.116
This tradeoff that we had to

00:34:32.116 --> 00:34:33.056
make is completely gone.

00:34:34.246 --> 00:34:37.096
Furthermore -- so a second

00:34:37.096 --> 00:34:38.996
example is that this time in

00:34:38.996 --> 00:34:41.295
application that wanted to make

00:34:41.295 --> 00:34:42.936
60 frames per second, but one

00:34:42.936 --> 00:34:44.666
frame just ran a bit long and we

00:34:44.666 --> 00:34:48.295
missed our deadline.

00:34:48.295 --> 00:34:49.886
On a fixed frame rate display we

00:34:49.886 --> 00:34:50.826
end up on the display side with

00:34:50.826 --> 00:34:51.856
a pattern that looks very

00:34:51.856 --> 00:34:53.126
similar to what we saw before.

00:34:54.585 --> 00:34:56.416
ProMotion can fix this too.

00:34:57.576 --> 00:34:58.626
So frame one's time on the

00:34:58.626 --> 00:34:59.866
glass, rather than it being

00:34:59.866 --> 00:35:01.336
extended by 16 milliseconds, is

00:35:01.336 --> 00:35:02.666
now only extended by four.

00:35:03.126 --> 00:35:04.526
The degree of stutter that the

00:35:04.526 --> 00:35:06.446
user experiences is tremendously

00:35:06.446 --> 00:35:09.066
reduced and then frame two and

00:35:09.066 --> 00:35:11.336
three, their latency gets pulled

00:35:11.336 --> 00:35:12.286
right back into where they were

00:35:12.286 --> 00:35:12.796
before.

00:35:13.426 --> 00:35:14.736
The system recovers right back

00:35:14.736 --> 00:35:15.886
onto the timeline right away,

00:35:16.336 --> 00:35:19.136
latency is improved, and your

00:35:19.136 --> 00:35:20.446
application can proceed on.

00:35:20.516 --> 00:35:21.306
We've just gotten right back to

00:35:21.306 --> 00:35:22.756
where we wanted to be.

00:35:23.416 --> 00:35:26.126
So put it all together, it just

00:35:26.126 --> 00:35:27.816
makes animation just feel that

00:35:27.816 --> 00:35:29.136
much more robust and solid no

00:35:29.136 --> 00:35:30.786
matter what's going on.

00:35:31.906 --> 00:35:33.816
So how do you actually go about

00:35:33.816 --> 00:35:35.116
taking advantage of this?

00:35:35.756 --> 00:35:38.576
For normal UIKit animation, such

00:35:38.576 --> 00:35:39.546
as scrolling through lists or

00:35:39.546 --> 00:35:41.506
views, iOS will do this entirely

00:35:41.506 --> 00:35:42.516
for you out of the box.

00:35:43.016 --> 00:35:44.506
It will render it 120 frames per

00:35:44.506 --> 00:35:45.456
second when appropriate.

00:35:45.526 --> 00:35:47.606
It will use the flexible display

00:35:47.696 --> 00:35:48.466
times when appropriate.

00:35:50.206 --> 00:35:51.256
Metal applications though tend

00:35:51.256 --> 00:35:52.286
to be much more aware of their

00:35:52.286 --> 00:35:53.466
timing and so for those we've

00:35:53.466 --> 00:35:54.446
made this an opt in feature.

00:35:55.766 --> 00:35:57.886
Opting in is done really easily

00:35:57.886 --> 00:35:59.186
just by adding a new entry to

00:35:59.186 --> 00:36:00.106
your application bundles

00:36:00.106 --> 00:36:00.866
info.plist.

00:36:01.596 --> 00:36:03.206
Once you do this the timing

00:36:03.206 --> 00:36:04.616
behavior of our three Metal

00:36:04.616 --> 00:36:06.266
presentation API changes a

00:36:06.266 --> 00:36:06.536
little bit.

00:36:06.536 --> 00:36:07.536
And so I'm going to walk you

00:36:07.536 --> 00:36:08.846
through those three APIs and how

00:36:08.846 --> 00:36:09.456
they change now.

00:36:10.226 --> 00:36:12.066
So the first of our Metal

00:36:12.066 --> 00:36:14.046
presentation APIs is just

00:36:14.466 --> 00:36:14.966
present.

00:36:15.616 --> 00:36:18.216
It's -- it says present

00:36:18.216 --> 00:36:20.156
immediately; schedule my image

00:36:20.156 --> 00:36:21.206
to be put on the glass at the

00:36:21.206 --> 00:36:22.676
very next available refresh

00:36:22.726 --> 00:36:24.306
point after the GPU finishes.

00:36:25.376 --> 00:36:26.596
On fixed frame rate hardware

00:36:26.596 --> 00:36:28.566
that's 16 milliseconds and on

00:36:28.566 --> 00:36:29.956
iPad Pro that's now four

00:36:29.956 --> 00:36:30.626
milliseconds.

00:36:31.296 --> 00:36:32.866
This is the easiest API to use

00:36:32.866 --> 00:36:33.726
because it takes no runs.

00:36:33.726 --> 00:36:35.046
So it's the API that most of the

00:36:35.046 --> 00:36:35.966
people in this room are already

00:36:35.966 --> 00:36:36.296
using.

00:36:37.416 --> 00:36:38.476
It's also the API that gives you

00:36:38.476 --> 00:36:40.056
the lowest latency access to the

00:36:40.056 --> 00:36:40.466
display.

00:36:41.296 --> 00:36:43.236
It works identically on both our

00:36:43.236 --> 00:36:44.596
fixed frame rate and ProMotion

00:36:44.596 --> 00:36:46.636
hardware, but once you opt in it

00:36:46.636 --> 00:36:47.486
starts working with much, much

00:36:47.486 --> 00:36:47.976
better granularity.

00:36:51.646 --> 00:36:53.116
The second of our Metal

00:36:53.116 --> 00:36:54.996
presentation APIs is present

00:36:54.996 --> 00:36:56.036
with minimum duration.

00:36:56.806 --> 00:36:59.236
So this one says, whenever this

00:36:59.236 --> 00:37:00.766
image lands on the glass, keep

00:37:00.766 --> 00:37:01.836
it there for a certain fixed

00:37:01.836 --> 00:37:02.486
amount of time.

00:37:03.046 --> 00:37:03.956
So if my image lands on the

00:37:03.956 --> 00:37:04.966
glass here, it's going to stay

00:37:04.966 --> 00:37:06.076
for 33 milliseconds.

00:37:06.076 --> 00:37:08.176
And if my start time shifts so

00:37:08.176 --> 00:37:08.896
does the end time.

00:37:09.576 --> 00:37:11.116
This is the API you'd use if you

00:37:11.116 --> 00:37:12.386
want perfect consistency in

00:37:12.386 --> 00:37:13.796
frame rate from frame to frame.

00:37:14.416 --> 00:37:16.146
This is particularly useful in

00:37:16.146 --> 00:37:17.616
30 frames per seconds -- on 60

00:37:17.856 --> 00:37:19.406
rate per seconds displays,

00:37:19.406 --> 00:37:20.316
although it's also sometimes

00:37:20.316 --> 00:37:21.446
useful on ProMotion as well.

00:37:22.416 --> 00:37:24.706
But our third presentation

00:37:24.706 --> 00:37:25.916
varying is the most interesting

00:37:25.916 --> 00:37:26.386
by far.

00:37:26.596 --> 00:37:28.406
It's present at a specific time

00:37:28.736 --> 00:37:30.486
and it does exactly what it

00:37:30.486 --> 00:37:30.996
sounds like.

00:37:31.736 --> 00:37:33.106
If the GPU's done well before

00:37:33.106 --> 00:37:34.436
the designated time, the display

00:37:34.436 --> 00:37:34.836
will wait.

00:37:35.196 --> 00:37:36.556
If the GPU runs over your

00:37:36.556 --> 00:37:37.966
deadline the display will pick

00:37:37.966 --> 00:37:39.606
it up at the very next available

00:37:39.606 --> 00:37:40.536
point afterwards.

00:37:41.666 --> 00:37:44.256
This is the key API to use if

00:37:44.256 --> 00:37:45.376
you want to build fully custom

00:37:45.376 --> 00:37:46.596
animation and timing loops.

00:37:47.286 --> 00:37:49.036
This API to present and time,

00:37:49.116 --> 00:37:50.656
combined with ProMotion display

00:37:51.096 --> 00:37:52.286
basically lets you leave behind

00:37:52.286 --> 00:37:53.446
the concept of a fixed frame

00:37:53.446 --> 00:37:54.696
rate entirely and render your

00:37:54.696 --> 00:37:56.206
content exactly for the time the

00:37:56.206 --> 00:37:57.196
user is going to see it.

00:37:58.006 --> 00:37:59.296
If you want to keep your Metal

00:37:59.296 --> 00:38:00.516
view perfectly in synch with

00:38:00.516 --> 00:38:01.416
something else happening on the

00:38:01.416 --> 00:38:03.386
system, such as audio, or if you

00:38:03.386 --> 00:38:04.236
want to basically provide the

00:38:04.236 --> 00:38:05.476
appearance of zero latency at

00:38:05.476 --> 00:38:06.606
all and be able to forward

00:38:06.606 --> 00:38:07.766
project your animation for

00:38:07.766 --> 00:38:09.176
exactly when the user's going to

00:38:09.176 --> 00:38:11.036
see your content this is what

00:38:11.036 --> 00:38:11.846
lets you do that.

00:38:13.266 --> 00:38:14.116
Now of course the trick is

00:38:14.116 --> 00:38:15.326
implementing that project next

00:38:15.326 --> 00:38:15.896
display time.

00:38:15.896 --> 00:38:16.596
That's your function.

00:38:17.616 --> 00:38:18.776
To make that work you do need

00:38:18.776 --> 00:38:19.986
some feedback from the system to

00:38:19.986 --> 00:38:21.146
help you determine what your

00:38:21.146 --> 00:38:22.166
actual performance is.

00:38:22.196 --> 00:38:23.356
And so we've added that as well.

00:38:24.646 --> 00:38:26.966
So a Metal drawable object is a

00:38:26.966 --> 00:38:28.156
transient object that tracks the

00:38:28.156 --> 00:38:29.496
lifetime of one image you've

00:38:29.496 --> 00:38:30.746
rendered all the way through the

00:38:30.746 --> 00:38:31.516
display system.

00:38:31.736 --> 00:38:34.896
It can now be queried for the

00:38:34.896 --> 00:38:36.426
specific time that frame lands

00:38:36.426 --> 00:38:37.606
on the glass and you can also

00:38:37.606 --> 00:38:38.346
get a call back when that

00:38:38.346 --> 00:38:38.866
happens.

00:38:39.906 --> 00:38:41.466
So now you can know when your

00:38:41.466 --> 00:38:42.696
image is landing on the glass,

00:38:43.076 --> 00:38:44.656
when they're being removed, and

00:38:44.656 --> 00:38:45.696
you have the key signal to know

00:38:45.696 --> 00:38:47.356
when you are or are not making

00:38:47.356 --> 00:38:48.436
the designated timing that you

00:38:48.436 --> 00:38:49.876
intended and are giving you the

00:38:49.876 --> 00:38:51.156
signal to adjust for future

00:38:51.156 --> 00:38:51.706
frames.

00:38:54.176 --> 00:38:56.146
So that's the story of ProMotion

00:38:56.146 --> 00:38:57.276
and what you need to do to make

00:38:57.276 --> 00:38:58.296
use of it on the future -- on

00:38:58.296 --> 00:38:59.326
these new iPad Pros.

00:38:59.936 --> 00:39:01.566
It's incredibly easy to get more

00:39:01.566 --> 00:39:02.706
consistent and higher frame

00:39:02.706 --> 00:39:05.256
rates with almost no code

00:39:05.256 --> 00:39:06.496
changing at all in most

00:39:06.496 --> 00:39:07.246
applications.

00:39:07.646 --> 00:39:10.306
From there it gives you a menu

00:39:10.306 --> 00:39:11.606
of options to decide what

00:39:11.606 --> 00:39:12.766
display time model is going to

00:39:12.766 --> 00:39:13.906
best benefit your particular

00:39:13.906 --> 00:39:14.126
app.

00:39:14.976 --> 00:39:16.356
A really, really fast paced

00:39:16.406 --> 00:39:18.216
Twitch arcade game or something

00:39:18.216 --> 00:39:19.986
tracking touch or pencil input

00:39:19.986 --> 00:39:21.286
probably wants to go for 120

00:39:21.286 --> 00:39:22.036
frames per second.

00:39:22.646 --> 00:39:24.386
A really high end rendering

00:39:24.386 --> 00:39:25.766
title might want to stick with

00:39:25.836 --> 00:39:27.156
30 or 60 frames per second or

00:39:27.156 --> 00:39:28.176
somewhere in between and just

00:39:28.176 --> 00:39:30.456
enjoy the consistency benefits.

00:39:31.136 --> 00:39:32.266
And applications that want to

00:39:32.266 --> 00:39:33.166
really take control of their

00:39:33.166 --> 00:39:34.506
timing loop have entirely new

00:39:34.506 --> 00:39:35.546
capabilities here as well.

00:39:36.776 --> 00:39:37.956
But regardless of what your app

00:39:37.956 --> 00:39:39.966
actually is, ProMotion gives you

00:39:39.966 --> 00:39:41.186
this powerful new tool to

00:39:41.186 --> 00:39:42.446
support its specific animation

00:39:42.446 --> 00:39:42.726
needs.

00:39:42.726 --> 00:39:45.306
So that's ProMotion.

00:39:46.016 --> 00:39:48.846
So moving on, I have a different

00:39:48.936 --> 00:39:50.346
display topic to talk about and

00:39:50.346 --> 00:39:51.256
that is a feature we're calling

00:39:51.256 --> 00:39:52.326
Direct 2 Display.

00:39:54.236 --> 00:39:56.206
So the story of what happens

00:39:56.206 --> 00:39:58.036
after your GPU finishes

00:39:58.036 --> 00:39:59.306
rendering your content and the

00:39:59.306 --> 00:40:00.426
display is actually a little bit

00:40:00.426 --> 00:40:01.066
more complicated.

00:40:01.116 --> 00:40:02.886
And then your image can take two

00:40:02.886 --> 00:40:04.836
paths to the display; GPU

00:40:04.836 --> 00:40:07.016
composition and direct to

00:40:08.116 --> 00:40:08.306
display.

00:40:08.426 --> 00:40:10.256
The first of those is a -- your

00:40:10.256 --> 00:40:11.956
typical user interface scenario

00:40:12.486 --> 00:40:13.446
where I've got a collection of

00:40:13.446 --> 00:40:15.086
views or layers or windows and

00:40:15.086 --> 00:40:17.426
the like and at this point the

00:40:17.426 --> 00:40:18.376
system is going to take all of

00:40:18.376 --> 00:40:19.136
these and composite them

00:40:19.136 --> 00:40:19.496
together.

00:40:19.636 --> 00:40:20.776
It's going to scale any content

00:40:20.776 --> 00:40:21.396
to fit the display.

00:40:21.396 --> 00:40:21.906
It's going to perform

00:40:21.906 --> 00:40:22.796
color/space conversion.

00:40:22.796 --> 00:40:23.746
It's going to perform -- apply

00:40:23.746 --> 00:40:24.776
any core image filters or

00:40:24.776 --> 00:40:26.056
blending and it's going to

00:40:26.056 --> 00:40:27.516
produce the one, final combined

00:40:27.516 --> 00:40:28.636
image that the user sees.

00:40:30.776 --> 00:40:32.436
This is really, really critical

00:40:32.436 --> 00:40:33.676
abstraction for full-featured

00:40:33.676 --> 00:40:34.586
user interfaces.

00:40:35.106 --> 00:40:38.136
But it's also all done on the

00:40:38.136 --> 00:40:39.186
GPU and it takes some time and

00:40:39.186 --> 00:40:39.706
memory there.

00:40:40.436 --> 00:40:41.746
And if we're basically building,

00:40:41.746 --> 00:40:42.646
you know a full-screen

00:40:42.646 --> 00:40:44.046
application, you know it's a

00:40:44.046 --> 00:40:45.136
little bit overkill for that.

00:40:45.136 --> 00:40:46.316
And so that's where direct

00:40:46.316 --> 00:40:48.106
display mode comes in.

00:40:48.256 --> 00:40:49.236
If none of these operations are

00:40:49.236 --> 00:40:51.496
actually required, we can point

00:40:51.496 --> 00:40:52.936
the display hardware directly at

00:40:52.976 --> 00:40:54.216
the memory you just rendered to

00:40:54.586 --> 00:40:55.856
and so without any middleman at

00:40:55.856 --> 00:40:55.986
all.

00:40:57.646 --> 00:40:59.026
So how do you enable this?

00:40:59.406 --> 00:41:01.196
It turns out there is no single

00:41:01.196 --> 00:41:02.716
turn it on API for direct to

00:41:02.716 --> 00:41:03.146
display.

00:41:03.916 --> 00:41:05.566
This mode is really an omission

00:41:05.566 --> 00:41:06.796
of anything that requires the

00:41:06.796 --> 00:41:08.166
GPU compositer to intervene.

00:41:08.836 --> 00:41:10.386
When the compositer takes a look

00:41:10.386 --> 00:41:11.596
at the set-up of your scene and

00:41:11.596 --> 00:41:13.026
says there's nothing it needs to

00:41:13.026 --> 00:41:14.686
do here it will just step out of

00:41:14.686 --> 00:41:15.626
the way.

00:41:16.426 --> 00:41:18.176
So how can you set up your scene

00:41:18.176 --> 00:41:20.726
to get the compositer to step

00:41:20.726 --> 00:41:22.756
out of the way?

00:41:23.216 --> 00:41:23.706
So this is pretty

00:41:23.706 --> 00:41:24.916
straightforward, an intuitive

00:41:24.966 --> 00:41:26.166
feel of, does my content need

00:41:26.166 --> 00:41:27.106
any kind of nontrurial

00:41:27.106 --> 00:41:27.846
[phonetic] processing is a

00:41:27.846 --> 00:41:29.336
pretty good intuitive start.

00:41:30.066 --> 00:41:31.146
But more specifically you do

00:41:31.146 --> 00:41:32.166
want your layer to be opaque.

00:41:32.726 --> 00:41:33.756
I don't want to be blending over

00:41:33.756 --> 00:41:34.096
anything.

00:41:34.716 --> 00:41:36.616
We don't want to apply anything

00:41:36.616 --> 00:41:37.716
that requires that core

00:41:37.716 --> 00:41:38.666
animation or the window server

00:41:38.916 --> 00:41:39.946
modify our pixels.

00:41:39.946 --> 00:41:40.836
We don't want to put on rounded

00:41:40.836 --> 00:41:42.406
corners in our view or masking

00:41:42.406 --> 00:41:44.326
or filters or the like.

00:41:45.656 --> 00:41:46.896
We do want to be full-screen.

00:41:47.226 --> 00:41:49.496
If your content does not

00:41:49.496 --> 00:41:51.256
actually match the aspect ratio

00:41:51.256 --> 00:41:52.436
of the display it is okay to put

00:41:52.436 --> 00:41:53.896
a full-screen, opaque, black

00:41:53.896 --> 00:41:55.016
background layer to sort of give

00:41:55.016 --> 00:41:56.396
a black bar kind of effect.

00:41:56.396 --> 00:41:57.216
But in the end we want to

00:41:57.216 --> 00:41:58.516
basically obscure everything.

00:42:01.456 --> 00:42:02.656
We do want to pick render

00:42:02.656 --> 00:42:03.636
resolutions that match the

00:42:03.636 --> 00:42:04.306
native panel.

00:42:05.176 --> 00:42:06.416
So this is actually a little bit

00:42:06.416 --> 00:42:07.616
tricky because all of our --

00:42:07.616 --> 00:42:09.056
both on macOS and iOS we ship

00:42:09.056 --> 00:42:10.556
hardware that has a virtual

00:42:10.556 --> 00:42:12.446
desktop modes or resolution

00:42:12.446 --> 00:42:13.696
modes that are larger than the

00:42:13.696 --> 00:42:14.676
actual physical panel.

00:42:14.766 --> 00:42:16.216
And the last thing we want to do

00:42:16.216 --> 00:42:17.356
is spend time rendering too many

00:42:17.356 --> 00:42:18.256
pixels only to have to spend

00:42:18.286 --> 00:42:19.456
time on the GPU to scale it all

00:42:19.456 --> 00:42:19.976
back down again.

00:42:24.466 --> 00:42:25.846
And finally, you want to pick a

00:42:25.846 --> 00:42:26.976
color, space, and pixel format

00:42:26.976 --> 00:42:28.046
that the display hardware is

00:42:28.046 --> 00:42:29.186
happy to read from directly.

00:42:30.116 --> 00:42:31.126
And so this one, there's any

00:42:31.126 --> 00:42:32.216
infinite number of combinations

00:42:32.216 --> 00:42:33.986
here so I want to help out by

00:42:33.986 --> 00:42:34.656
giving you a little bit of a

00:42:34.656 --> 00:42:35.986
white list of some particularly

00:42:35.986 --> 00:42:36.916
common and efficient

00:42:36.916 --> 00:42:37.576
combinations.

00:42:39.926 --> 00:42:41.596
So right on the top is our good

00:42:41.596 --> 00:42:44.556
old friend; SRGB8888.

00:42:44.556 --> 00:42:45.496
This is pretty much the

00:42:45.496 --> 00:42:46.986
universal pixel format that most

00:42:46.986 --> 00:42:48.806
applications use and all

00:42:48.806 --> 00:42:50.626
hardware is happy to read.

00:42:50.626 --> 00:42:51.776
And so for most people that's

00:42:51.776 --> 00:42:52.196
all they need.

00:42:53.666 --> 00:42:55.876
But we've been shipping wide

00:42:55.876 --> 00:42:58.096
color gamut P3 displays on both

00:42:58.096 --> 00:43:00.806
our macOS and iOS hardware and

00:43:01.106 --> 00:43:02.246
if your application does want to

00:43:02.246 --> 00:43:03.766
start making use of this ability

00:43:03.766 --> 00:43:04.926
to represent more colors, you

00:43:04.926 --> 00:43:06.016
need to pay a bit more

00:43:06.016 --> 00:43:06.396
attention.

00:43:06.396 --> 00:43:09.676
In both the -- the concepts are

00:43:09.676 --> 00:43:11.086
the same between iOS and macOS,

00:43:11.086 --> 00:43:11.996
although the details differ a

00:43:11.996 --> 00:43:13.316
little bit.

00:43:13.316 --> 00:43:14.686
In both cases we do want to

00:43:14.686 --> 00:43:15.846
render to attend the pixel

00:43:17.266 --> 00:43:20.106
format, but note that if you

00:43:20.106 --> 00:43:21.566
render P3 content onto a P3

00:43:21.566 --> 00:43:23.286
display that's fine, but if you

00:43:23.286 --> 00:43:25.686
render P3 content onto an SRGB

00:43:25.686 --> 00:43:28.166
display the system -- the GP

00:43:28.166 --> 00:43:29.266
compositer might have to get

00:43:29.266 --> 00:43:30.326
involved to crush the color

00:43:30.326 --> 00:43:31.426
space back down to fit the

00:43:31.426 --> 00:43:31.796
display.

00:43:32.706 --> 00:43:34.206
And so this is -- P3 is not

00:43:34.206 --> 00:43:34.816
something you want to do

00:43:34.816 --> 00:43:35.996
universally, all the time.

00:43:36.106 --> 00:43:37.166
you do want to take a look at

00:43:37.226 --> 00:43:39.466
the current display and make

00:43:39.466 --> 00:43:40.616
this a conditional thing.

00:43:40.986 --> 00:43:43.356
So finally, for completeness I'm

00:43:43.356 --> 00:43:44.726
also going to list RGBA float

00:43:44.726 --> 00:43:45.866
16, which is sort of the

00:43:45.866 --> 00:43:48.116
universal, wide gamut, high

00:43:48.116 --> 00:43:49.406
dynamic range pixel format.

00:43:49.956 --> 00:43:52.086
Although, in -- I do -- it's

00:43:52.086 --> 00:43:53.266
also necessary for MacOS's

00:43:53.266 --> 00:43:54.466
extended data range feature.

00:43:55.196 --> 00:43:56.076
Although it is worth noting that

00:43:56.076 --> 00:43:57.476
it does require GPU compositing

00:43:57.476 --> 00:43:57.976
in all cases.

00:44:01.646 --> 00:44:02.566
So I mentioned, you do want to

00:44:02.566 --> 00:44:03.776
be a little bit conditional if

00:44:03.776 --> 00:44:04.716
you write an application that's

00:44:04.716 --> 00:44:05.586
wide color aware.

00:44:06.376 --> 00:44:07.776
Fortunately, both UIKit and

00:44:07.776 --> 00:44:08.596
AppKit provide really convenient

00:44:08.596 --> 00:44:08.976
APIs to check that.

00:44:13.256 --> 00:44:14.786
So the last step is, how do you

00:44:14.786 --> 00:44:16.056
know if you're actually on the

00:44:16.056 --> 00:44:17.646
directed display path?

00:44:17.646 --> 00:44:18.676
So this is a screen shot of our

00:44:18.676 --> 00:44:19.966
Metal system trace tool and

00:44:19.966 --> 00:44:20.566
instruments.

00:44:20.676 --> 00:44:23.376
And Metal system trace is pretty

00:44:23.426 --> 00:44:25.006
much a developer tool that will

00:44:25.006 --> 00:44:26.656
give you a live timeline of the

00:44:26.656 --> 00:44:27.886
CPU and the GPU in the display.

00:44:28.216 --> 00:44:30.106
Pretty much a real-world version

00:44:30.106 --> 00:44:30.996
of the diagrams I've been

00:44:30.996 --> 00:44:31.636
showing you in this

00:44:31.636 --> 00:44:32.236
presentation.

00:44:33.396 --> 00:44:35.216
So in this case, I want to

00:44:35.216 --> 00:44:36.596
highlight my three frames that

00:44:36.596 --> 00:44:37.016
I've rendered.

00:44:37.546 --> 00:44:39.106
The color-time intervals are my

00:44:39.106 --> 00:44:40.126
own application's rendering.

00:44:41.296 --> 00:44:42.716
And the gray time intervals are

00:44:42.716 --> 00:44:44.446
some other processes in the GPU.

00:44:44.496 --> 00:44:46.806
I can get more details down at

00:44:46.806 --> 00:44:47.666
the bottom of the window or I

00:44:47.666 --> 00:44:48.306
can see it's coming from

00:44:48.306 --> 00:44:50.836
backboard D, our iOS composition

00:44:50.836 --> 00:44:51.406
process.

00:44:51.596 --> 00:44:52.606
So this is the case where my

00:44:52.606 --> 00:44:53.676
application is going down the

00:44:53.676 --> 00:44:55.946
GPU compositing path.

00:44:55.946 --> 00:44:56.896
Going back and revisiting some

00:44:56.896 --> 00:44:59.166
of our best practices can remove

00:44:59.166 --> 00:45:00.486
that from the picture and now I

00:45:00.486 --> 00:45:02.116
can rerun my Metal system trace

00:45:02.556 --> 00:45:04.026
and see that I have a timeline

00:45:04.026 --> 00:45:05.626
where, you know I've got the GPU

00:45:05.716 --> 00:45:06.616
completely and entirely to

00:45:06.616 --> 00:45:06.976
myself.

00:45:10.046 --> 00:45:12.006
So that's it for direct to

00:45:12.146 --> 00:45:12.756
display.

00:45:12.756 --> 00:45:14.086
Our system compositors can make

00:45:14.086 --> 00:45:15.406
a lot of magic happen behind the

00:45:15.406 --> 00:45:16.746
scenes to make full-featured

00:45:16.746 --> 00:45:18.626
user interfaces possible, but

00:45:18.626 --> 00:45:19.706
that can come at a performance

00:45:19.706 --> 00:45:20.976
cost because they use the GPU to

00:45:20.976 --> 00:45:21.426
do it.

00:45:22.396 --> 00:45:23.456
By being a little bit aware of

00:45:23.456 --> 00:45:24.036
what you're asking the

00:45:24.036 --> 00:45:25.536
compositer to do, or more

00:45:25.536 --> 00:45:26.896
importantly by not asking what

00:45:26.896 --> 00:45:28.186
you're not asking the compositer

00:45:28.186 --> 00:45:30.046
to do, it can get out of the way

00:45:30.046 --> 00:45:31.816
without using the GPU, returning

00:45:31.816 --> 00:45:32.766
some of that time to you.

00:45:33.496 --> 00:45:35.536
Direct to display is supported

00:45:35.536 --> 00:45:37.046
on iOS and Tos and always has

00:45:37.046 --> 00:45:39.056
been and its support is new to

00:45:39.056 --> 00:45:40.356
macOS High Sierra for Metal

00:45:40.356 --> 00:45:40.976
applications.

00:45:45.366 --> 00:45:46.536
So with that I want to touch on

00:45:46.536 --> 00:45:48.136
our last topic of the day and

00:45:48.136 --> 00:45:50.576
that's everything else.

00:45:50.616 --> 00:45:51.716
There's a lot more that we've

00:45:51.716 --> 00:45:52.826
added to the core frameworks and

00:45:52.826 --> 00:45:54.056
sheeting language for Metal 2.

00:45:54.056 --> 00:45:55.306
And so I'm not going to dive

00:45:55.306 --> 00:45:56.226
deep into any of these things,

00:45:56.226 --> 00:45:56.896
but I do want to give you a

00:45:56.896 --> 00:45:57.236
survey.

00:45:57.716 --> 00:46:01.036
So right off the bat we've added

00:46:01.036 --> 00:46:02.026
some new APIs to be able to

00:46:02.026 --> 00:46:03.916
query how much GPU memory's

00:46:03.916 --> 00:46:05.316
being allocated for each buffer,

00:46:05.316 --> 00:46:06.446
for each texture, for each Heap.

00:46:06.736 --> 00:46:08.996
This actually takes into account

00:46:08.996 --> 00:46:09.576
things that just generally

00:46:09.576 --> 00:46:10.666
happen behind the scenes, like

00:46:10.666 --> 00:46:12.496
alignment and various padding.

00:46:13.156 --> 00:46:13.996
So this can give you a more

00:46:13.996 --> 00:46:15.356
accurate view of how much GPU

00:46:15.356 --> 00:46:16.586
memory you're actually using.

00:46:16.586 --> 00:46:19.466
We also have a roll-up query on

00:46:19.466 --> 00:46:22.006
the Metal device, which is the

00:46:22.006 --> 00:46:23.766
entire GPU memory usage for your

00:46:23.766 --> 00:46:24.786
entire process.

00:46:25.106 --> 00:46:26.716
And this is particularly notable

00:46:26.716 --> 00:46:28.616
because that also counts all of

00:46:28.616 --> 00:46:29.616
the memory that the driver needs

00:46:29.616 --> 00:46:30.966
to allocate that's not otherwise

00:46:30.966 --> 00:46:33.156
visible to you; things like

00:46:33.156 --> 00:46:34.676
memory to put shader code in or

00:46:34.676 --> 00:46:35.686
command buffers or anything

00:46:35.686 --> 00:46:36.076
else.

00:46:36.576 --> 00:46:37.516
So this can give you where

00:46:37.516 --> 00:46:38.216
you're at relative -- you know

00:46:38.216 --> 00:46:38.946
everything all in compared to

00:46:38.946 --> 00:46:39.976
your memory usage target.

00:46:43.736 --> 00:46:44.666
We have a couple compute

00:46:44.666 --> 00:46:45.586
oriented additions.

00:46:46.026 --> 00:46:47.246
The first of those is that we've

00:46:47.246 --> 00:46:48.276
added a set of shading language

00:46:48.276 --> 00:46:49.636
functions to help -- to allow

00:46:49.636 --> 00:46:50.826
you to transfer data directly

00:46:50.826 --> 00:46:51.976
between threads in a SIMD group.

00:46:52.176 --> 00:46:54.306
If you're not familiar; GPU

00:46:54.306 --> 00:46:55.526
hardware typically gains an

00:46:55.746 --> 00:46:57.606
individual vertex fragment and

00:46:57.606 --> 00:46:59.586
compute shader thread into SIMD

00:46:59.586 --> 00:47:00.756
groups and executes them

00:47:00.756 --> 00:47:01.986
together for greater efficiency.

00:47:02.536 --> 00:47:04.266
This are also called wayfrencer

00:47:04.266 --> 00:47:04.726
[phonetic] warps.

00:47:05.766 --> 00:47:07.386
Within a group these threads do

00:47:07.386 --> 00:47:08.506
have some ability to directly

00:47:08.506 --> 00:47:09.756
communicate without having to

00:47:09.756 --> 00:47:10.796
load and store through memory.

00:47:11.386 --> 00:47:13.126
They can read values directly

00:47:13.126 --> 00:47:14.226
out of one thread's register and

00:47:14.226 --> 00:47:15.096
write them to another thread's

00:47:15.096 --> 00:47:15.666
register.

00:47:15.796 --> 00:47:16.516
And that's what these new

00:47:16.516 --> 00:47:17.506
standard library functions

00:47:17.506 --> 00:47:17.816
allow.

00:47:18.916 --> 00:47:21.516
So in this case broadcast means

00:47:21.516 --> 00:47:22.756
I can read a data directly --

00:47:22.856 --> 00:47:24.226
read a field directly out of

00:47:24.226 --> 00:47:25.526
thread zero's registers and

00:47:25.526 --> 00:47:26.406
write it directly into the

00:47:26.406 --> 00:47:27.866
registers of 16 other threads

00:47:27.866 --> 00:47:28.796
that happen to be part of this

00:47:28.796 --> 00:47:28.976
group.

00:47:33.146 --> 00:47:34.606
Our second compute addition is

00:47:34.606 --> 00:47:35.776
to give you more flexibility in

00:47:35.776 --> 00:47:37.086
how big your thread groups are.

00:47:37.936 --> 00:47:39.576
So for example if I have a pixel

00:47:39.576 --> 00:47:40.556
bird here that I want to run

00:47:40.556 --> 00:47:41.916
some pretty classic image

00:47:41.916 --> 00:47:44.866
processing kernel over, but then

00:47:44.866 --> 00:47:45.936
I've written my compute kernel

00:47:45.936 --> 00:47:47.666
such that I'm using four by four

00:47:47.716 --> 00:47:48.516
thread groups everywhere.

00:47:49.906 --> 00:47:50.936
Well, this leads to some

00:47:50.936 --> 00:47:52.246
problems because I've got -- if

00:47:52.246 --> 00:47:53.716
my image is not a nice multiple

00:47:53.716 --> 00:47:55.056
of my thread group size I've got

00:47:55.056 --> 00:47:56.066
a bunch of stray threads on the

00:47:56.066 --> 00:47:56.396
side.

00:47:57.056 --> 00:47:59.766
I mean this means that I've got

00:47:59.766 --> 00:48:01.726
to dive into those and say when

00:48:01.726 --> 00:48:02.546
I actually write my code.

00:48:02.546 --> 00:48:03.466
I have to be defensive.

00:48:03.466 --> 00:48:04.326
Am I out of bounds?

00:48:04.326 --> 00:48:05.146
I have to handle it in some

00:48:05.146 --> 00:48:05.736
special way.

00:48:05.736 --> 00:48:07.136
It's doable but annoying.

00:48:07.976 --> 00:48:09.006
It also means that we're just

00:48:09.006 --> 00:48:10.126
wasting GPU cycles.

00:48:10.646 --> 00:48:12.926
So non-uniform thread group

00:48:12.926 --> 00:48:14.536
sizes, unless you declare what

00:48:14.536 --> 00:48:15.476
dimensions you want to run your

00:48:15.476 --> 00:48:16.896
kernel over, without being

00:48:16.896 --> 00:48:18.136
multiple thread group sizes.

00:48:18.736 --> 00:48:20.156
So the hard working, smaller

00:48:20.156 --> 00:48:21.766
thread groups along the edges of

00:48:21.766 --> 00:48:23.536
my grid, in order to say -- in

00:48:23.536 --> 00:48:24.466
order to just shave off that

00:48:24.466 --> 00:48:26.006
unnecessary work it both

00:48:26.096 --> 00:48:28.456
improves GPU performance and

00:48:28.456 --> 00:48:29.556
just makes your kernels easier

00:48:29.556 --> 00:48:29.976
to write.

00:48:34.236 --> 00:48:35.206
We've added support for a view

00:48:35.206 --> 00:48:35.896
port arrays.

00:48:36.206 --> 00:48:37.736
You can now configure up to 16

00:48:37.736 --> 00:48:39.396
simultaneous view ports and your

00:48:39.396 --> 00:48:41.146
vertex shader can select, per

00:48:41.146 --> 00:48:42.776
triangle, which view port that

00:48:42.776 --> 00:48:43.916
triangle gets presented into.

00:48:44.626 --> 00:48:45.596
I'm not going to go further into

00:48:45.596 --> 00:48:46.256
this because it will be

00:48:46.256 --> 00:48:48.026
discussed in detail tomorrow in

00:48:48.026 --> 00:48:49.176
the VR with Metal 2 session.

00:48:49.546 --> 00:48:50.546
It is particularly valuable for

00:48:50.546 --> 00:48:51.346
efficiently rendering to the

00:48:51.346 --> 00:48:51.976
left and right eyes.

00:48:56.666 --> 00:48:57.476
We've added the ability to

00:48:57.476 --> 00:48:59.126
choose where in each pixel your

00:48:59.126 --> 00:49:00.076
multi-sample locations are

00:49:00.076 --> 00:49:00.606
supported.

00:49:01.566 --> 00:49:02.776
This lets you do a few

00:49:02.776 --> 00:49:04.356
interesting things including

00:49:04.356 --> 00:49:05.366
maybe toggling your sample

00:49:05.366 --> 00:49:07.256
positions every other frame and

00:49:07.256 --> 00:49:08.396
giving you some new -- you know

00:49:08.396 --> 00:49:09.376
valuable input into some

00:49:09.376 --> 00:49:10.386
temporal anti-aliasing

00:49:10.386 --> 00:49:11.066
algorithms.

00:49:15.716 --> 00:49:17.206
In the vein of trying to keep --

00:49:17.266 --> 00:49:18.726
of working to bring our

00:49:18.726 --> 00:49:19.756
platforms up to date to have

00:49:19.806 --> 00:49:20.816
them have the same feature set

00:49:20.816 --> 00:49:21.856
wherever possible, we've brought

00:49:21.856 --> 00:49:23.356
resource Heaps, shipped last

00:49:23.356 --> 00:49:25.586
year in iOS 10 to macOS High

00:49:25.586 --> 00:49:26.366
Sierra this year.

00:49:26.616 --> 00:49:28.826
So I'm going to actually do a

00:49:28.826 --> 00:49:29.926
little bit of a refresher on

00:49:29.926 --> 00:49:32.196
this because good use of your

00:49:32.196 --> 00:49:33.906
Heaps is really important to

00:49:33.906 --> 00:49:34.816
getting the most out of argument

00:49:34.816 --> 00:49:35.246
buffers.

00:49:36.606 --> 00:49:37.986
So Heaps are of course where I

00:49:37.986 --> 00:49:38.896
can allocate a big slab of

00:49:38.896 --> 00:49:40.786
memory up front rather than

00:49:40.786 --> 00:49:42.416
going to the kernel to -- I want

00:49:42.506 --> 00:49:43.926
memory for texture a, and I want

00:49:43.926 --> 00:49:45.046
memory for texture b and so

00:49:45.046 --> 00:49:45.416
forth.

00:49:45.826 --> 00:49:46.896
I can go to the kernel and get

00:49:46.896 --> 00:49:49.036
memory right up front and of

00:49:49.036 --> 00:49:50.626
course put textures -- you know

00:49:50.626 --> 00:49:51.556
add and remove textures and

00:49:51.556 --> 00:49:52.906
buffers to -- without having to

00:49:52.976 --> 00:49:55.396
go back to the system.

00:49:55.466 --> 00:49:56.766
This has a few advantages.

00:49:56.946 --> 00:49:58.206
It means that I can bind

00:49:58.206 --> 00:49:59.116
everything in that Heap much

00:49:59.116 --> 00:49:59.726
more efficiently.

00:49:59.916 --> 00:50:00.666
There's much less software

00:50:00.666 --> 00:50:01.026
overhead.

00:50:01.786 --> 00:50:02.966
It means that we can oftentimes

00:50:02.966 --> 00:50:03.936
pack that memory a little bit

00:50:03.936 --> 00:50:04.466
closer together.

00:50:04.466 --> 00:50:05.536
We can save some padding and

00:50:05.536 --> 00:50:06.686
alignment, save you a little bit

00:50:06.686 --> 00:50:07.056
of memory.

00:50:08.096 --> 00:50:10.116
It means when we delete memory

00:50:10.426 --> 00:50:11.816
we don't give memory back to the

00:50:11.816 --> 00:50:12.236
system.

00:50:12.576 --> 00:50:13.296
That could be good or bad.

00:50:13.996 --> 00:50:15.666
It means when we allocate new

00:50:15.666 --> 00:50:16.526
memory -- when we allocate a new

00:50:16.526 --> 00:50:17.676
texture it means we don't have

00:50:17.676 --> 00:50:18.656
to go back to the system and get

00:50:18.656 --> 00:50:18.976
new memory.

00:50:22.476 --> 00:50:23.386
It also means that you can

00:50:23.386 --> 00:50:24.916
choose to alias these textures

00:50:24.916 --> 00:50:25.476
with each other.

00:50:26.256 --> 00:50:27.606
If I have -- you typically

00:50:27.606 --> 00:50:29.456
render targets or intermediate

00:50:29.456 --> 00:50:31.126
render targets between different

00:50:31.126 --> 00:50:32.666
passes in my render graph.

00:50:33.076 --> 00:50:34.176
It means that if I have two

00:50:34.176 --> 00:50:34.886
different intermediates that

00:50:34.886 --> 00:50:36.616
just don't have to exist at the

00:50:36.616 --> 00:50:37.966
same point in time I can alias

00:50:37.966 --> 00:50:38.926
them over each other and I can

00:50:38.926 --> 00:50:43.416
save tons of memory like this.

00:50:44.096 --> 00:50:46.066
So that's it for a quick survey

00:50:46.866 --> 00:50:47.906
of Heaps.

00:50:47.996 --> 00:50:50.196
We've added linear textures from

00:50:50.386 --> 00:50:52.056
iOS to macOS.

00:50:52.296 --> 00:50:53.366
Linear textures allows you to

00:50:53.366 --> 00:50:55.146
create a texture directly from a

00:50:55.146 --> 00:50:56.736
Metal buffer without any copies

00:50:56.786 --> 00:50:57.216
at all.

00:50:59.306 --> 00:51:00.266
We've extended our function

00:51:00.266 --> 00:51:01.736
constant feature a little bit.

00:51:01.736 --> 00:51:02.766
A quick refresher, function

00:51:02.766 --> 00:51:03.656
constants allow you to

00:51:03.656 --> 00:51:04.886
specialize by codes.

00:51:05.026 --> 00:51:05.926
When you've done all your front

00:51:05.926 --> 00:51:07.466
end compilation offline you can

00:51:07.466 --> 00:51:08.636
then tweak and customize your

00:51:08.636 --> 00:51:09.886
uber shader bi-code a little bit

00:51:10.106 --> 00:51:11.296
before actual generating final

00:51:11.296 --> 00:51:11.856
machine code.

00:51:12.716 --> 00:51:14.046
If you have a classic uber

00:51:14.046 --> 00:51:15.156
shader this can save you the

00:51:15.156 --> 00:51:16.206
cost of having to re-run the

00:51:16.206 --> 00:51:17.836
compiler front end for every

00:51:17.836 --> 00:51:18.726
single permutation.

00:51:19.806 --> 00:51:21.016
So we've made this a bit more

00:51:21.016 --> 00:51:22.546
flexible and added a few more

00:51:22.546 --> 00:51:25.136
cases where you can use these

00:51:25.246 --> 00:51:26.286
specialized arguments.

00:51:28.046 --> 00:51:29.106
We've added some extra vertex

00:51:29.106 --> 00:51:29.796
array formats.

00:51:29.826 --> 00:51:31.196
We had some missing one and two

00:51:31.196 --> 00:51:32.396
component vertex formats.

00:51:32.546 --> 00:51:34.366
And we've also added BGRA vertex

00:51:34.366 --> 00:51:34.916
formats.

00:51:37.576 --> 00:51:38.616
We've brought iOS surface

00:51:38.616 --> 00:51:40.306
texture support from macOS to

00:51:40.436 --> 00:51:40.846
iOS.

00:51:40.846 --> 00:51:42.716
And we've also brought dual

00:51:42.716 --> 00:51:44.156
sourced blending to iOS as well,

00:51:44.446 --> 00:51:46.666
also particularly useful in some

00:51:46.666 --> 00:51:47.926
deferred shading scenarios.

00:51:50.706 --> 00:51:52.756
So that's -- brings us to the

00:51:52.756 --> 00:51:56.086
end of introducing Metal 2.

00:51:56.166 --> 00:51:57.586
My colleague, Michal, started

00:51:57.586 --> 00:51:58.976
with giving you a little bit of

00:51:58.976 --> 00:52:00.266
an overview of the overall scope

00:52:00.266 --> 00:52:00.806
of Metal 2.

00:52:01.126 --> 00:52:03.686
From VR to external GPUs, to

00:52:04.056 --> 00:52:05.206
machine learning, and to new

00:52:05.206 --> 00:52:06.886
developer tools and performance

00:52:07.306 --> 00:52:08.026
analysis.

00:52:08.026 --> 00:52:08.986
Of that, the pieces that we

00:52:08.986 --> 00:52:10.936
really covered today are our

00:52:10.936 --> 00:52:12.456
next big push toward reducing

00:52:12.576 --> 00:52:13.926
CPU overhead using argument

00:52:13.926 --> 00:52:14.386
buffers.

00:52:15.006 --> 00:52:16.506
Argument buffers also unlock the

00:52:16.506 --> 00:52:17.856
ability for the GPU to start

00:52:17.886 --> 00:52:18.956
taking a little bit of its own

00:52:18.956 --> 00:52:19.866
destiny when it comes to

00:52:19.866 --> 00:52:21.126
configuring shader arguments,

00:52:21.126 --> 00:52:22.536
which is one less reason to take

00:52:22.536 --> 00:52:24.676
back to the CPU.

00:52:25.586 --> 00:52:27.356
Raster Order Groups let us start

00:52:27.356 --> 00:52:28.666
using the rasterizer for things

00:52:28.666 --> 00:52:30.186
beyond basic in order blending.

00:52:31.356 --> 00:52:32.476
We can now start taking

00:52:32.476 --> 00:52:34.056
advantage of the latest hardware

00:52:34.056 --> 00:52:36.566
capabilities to do, you know,

00:52:36.566 --> 00:52:38.386
vox slice triangle meshes or set

00:52:38.616 --> 00:52:40.316
transparency blending either in

00:52:40.316 --> 00:52:41.226
order or independent.

00:52:41.296 --> 00:52:42.216
They're both -- it makes them

00:52:42.216 --> 00:52:42.816
both possible.

00:52:44.016 --> 00:52:46.656
For the new iPad Pros, ProMotion

00:52:46.656 --> 00:52:47.726
gives you very fine grained

00:52:47.726 --> 00:52:49.126
control over exactly how your

00:52:49.126 --> 00:52:50.226
animations are presented to the

00:52:50.226 --> 00:52:51.886
user, giving you the ability to

00:52:51.886 --> 00:52:53.656
get both peak frame rates and

00:52:53.656 --> 00:52:54.736
the lowest possible latency.

00:52:55.136 --> 00:52:57.736
Direct to display provides you a

00:52:57.736 --> 00:52:59.116
path to reclaim a little bit of

00:52:59.116 --> 00:53:00.436
GPU performance from the system

00:53:00.526 --> 00:53:01.706
by being aware of what our

00:53:01.706 --> 00:53:02.956
compositors do on your behalf.

00:53:06.336 --> 00:53:07.536
So you'll be able to find the

00:53:07.536 --> 00:53:08.426
video and the slides for this

00:53:08.426 --> 00:53:11.216
session on the WWDC2017 website.

00:53:11.876 --> 00:53:15.096
We have three other sessions on

00:53:15.096 --> 00:53:15.996
Metal 2 this year.

00:53:16.596 --> 00:53:18.536
In particular, tomorrow

00:53:18.536 --> 00:53:19.456
afternoon we're going to have a

00:53:19.456 --> 00:53:20.696
session dedicated to VR and

00:53:20.696 --> 00:53:21.136
Metal 2.

00:53:21.326 --> 00:53:22.886
This is going to go deep into

00:53:22.886 --> 00:53:24.706
what your application needs to

00:53:24.706 --> 00:53:26.456
do and a conceptual overview of

00:53:26.456 --> 00:53:28.426
how to do VR rendering, dive

00:53:28.426 --> 00:53:30.056
into specifically how to do VR

00:53:30.056 --> 00:53:32.106
with the combination of Metal 2

00:53:32.106 --> 00:53:34.076
and the Steam VR toolkit.

00:53:34.076 --> 00:53:36.086
It's also going to go into using

00:53:36.086 --> 00:53:37.326
Metal with external GPU

00:53:37.326 --> 00:53:37.736
hardware.

00:53:39.666 --> 00:53:40.376
On Thursday we have a

00:53:40.376 --> 00:53:42.286
doubleheader starting with Metal

00:53:42.286 --> 00:53:43.676
2 optimization and debugging.

00:53:43.996 --> 00:53:45.716
This is going to go into what's

00:53:45.716 --> 00:53:46.726
new in our developer and

00:53:46.726 --> 00:53:48.106
performance tools and all the

00:53:48.106 --> 00:53:49.376
new workflows that enables to

00:53:49.376 --> 00:53:50.086
help you build the best

00:53:50.086 --> 00:53:51.076
applications possible.

00:53:51.286 --> 00:53:52.826
And it's going to be followed up

00:53:52.826 --> 00:53:54.336
right after that with using

00:53:54.336 --> 00:53:55.276
Metal 2 for compute.

00:53:55.656 --> 00:53:57.126
And that's going to really have

00:53:57.126 --> 00:53:58.896
a big focus this year on using

00:53:58.896 --> 00:54:00.206
the GPU for machine learning

00:54:00.206 --> 00:54:00.916
applications.

00:54:00.916 --> 00:54:01.946
We've added a whole lot this

00:54:01.946 --> 00:54:03.806
year and we want to show you

00:54:03.806 --> 00:54:05.166
everything we've done.

00:54:07.206 --> 00:54:08.386
I want to point you to a couple

00:54:08.426 --> 00:54:10.206
of last year's WWDC sessions.

00:54:11.286 --> 00:54:12.626
The first, What's New in Metal

00:54:12.626 --> 00:54:14.186
Part One is where we did a deep

00:54:14.186 --> 00:54:15.786
dive on resource Heaps.

00:54:16.196 --> 00:54:17.146
And instead if you're looking to

00:54:17.146 --> 00:54:18.026
get the best performance out of

00:54:18.026 --> 00:54:19.836
argument buffers, argument

00:54:19.836 --> 00:54:20.936
buffers and Heaps were built to

00:54:20.936 --> 00:54:22.716
go together and so I highly

00:54:22.716 --> 00:54:23.836
encourage you to go check out

00:54:23.836 --> 00:54:26.336
the video and really -- and, you

00:54:26.436 --> 00:54:28.416
know basically plan your

00:54:28.416 --> 00:54:29.326
application around both of those

00:54:29.326 --> 00:54:29.686
together.

00:54:29.756 --> 00:54:31.196
They cover that in a lot more

00:54:31.196 --> 00:54:32.516
detail than we did here today.

00:54:34.056 --> 00:54:36.016
Second, if the conversation

00:54:36.016 --> 00:54:38.076
about direct to display and wide

00:54:38.076 --> 00:54:39.436
gamut and wide color interested

00:54:39.436 --> 00:54:40.996
you we have a whole session that

00:54:40.996 --> 00:54:41.916
really goes deep into the

00:54:41.916 --> 00:54:43.066
concepts and the specifics

00:54:43.066 --> 00:54:44.066
behind that, we also talked

00:54:44.066 --> 00:54:44.656
about last year.

00:54:45.706 --> 00:54:47.676
With that I think we'll wrap it

00:54:47.676 --> 00:54:47.796
up.

00:54:47.796 --> 00:54:48.886
I thank you for all attending

00:54:48.886 --> 00:54:49.596
and I hope you enjoy the

00:54:49.596 --> 00:54:50.266
remainder of your week.

00:54:50.266 --> 00:54:50.906
So thank you.

00:54:51.516 --> 00:54:55.500
[ Applause ]
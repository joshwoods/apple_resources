WEBVTT

00:00:07.516 --> 00:00:21.516
[ Background Conversations ]

00:00:22.516 --> 00:00:27.556
[ Applause ]

00:00:28.056 --> 00:00:29.076
>> Good afternoon, everyone.

00:00:29.076 --> 00:00:30.446
And welcome to Metal 2

00:00:30.446 --> 00:00:31.796
Optimization and Debugging.

00:00:31.796 --> 00:00:34.716
As you know, we're talking a lot

00:00:34.716 --> 00:00:35.856
about Metal 2 this year, with

00:00:35.856 --> 00:00:37.116
some great new enhancements to

00:00:37.116 --> 00:00:39.106
the platform including GP driven

00:00:39.106 --> 00:00:40.966
rendering, machine learning

00:00:40.966 --> 00:00:43.936
acceleration, and a macOS VR,

00:00:43.936 --> 00:00:45.716
and external GPU support.

00:00:47.106 --> 00:00:48.466
And not forgetting Advanced

00:00:48.466 --> 00:00:49.636
Optimization Tools.

00:00:50.186 --> 00:00:52.886
So, this afternoon, we're going

00:00:52.886 --> 00:00:54.536
to talk about the current Metal

00:00:54.666 --> 00:00:56.076
tools, give you a recap of

00:00:56.376 --> 00:00:57.906
those, talk about some great new

00:00:57.906 --> 00:00:59.536
enhancements to the Metal frame

00:00:59.536 --> 00:01:01.356
debugger, and then finally cover

00:01:01.356 --> 00:01:03.136
some major enhancements in terms

00:01:03.136 --> 00:01:04.016
of GPU profiling.

00:01:04.676 --> 00:01:08.016
But first, the frame debugger.

00:01:10.226 --> 00:01:12.056
So hopefully you're all familiar

00:01:12.056 --> 00:01:12.776
with this tool.

00:01:14.076 --> 00:01:15.376
It is our fully-featured frame

00:01:15.376 --> 00:01:17.246
debugger integrated into Xcode,

00:01:17.246 --> 00:01:20.106
that lets you capture your Metal

00:01:20.106 --> 00:01:22.586
2 work, be it computer graphics,

00:01:22.966 --> 00:01:24.126
and then step through it into

00:01:24.126 --> 00:01:25.086
the debugger, to inspect state

00:01:25.086 --> 00:01:27.086
and resources, letting you debug

00:01:27.476 --> 00:01:28.186
and optimize.

00:01:29.076 --> 00:01:33.216
One of our focuses this year has

00:01:33.216 --> 00:01:34.006
been on improving the

00:01:34.006 --> 00:01:34.886
performance to the frame

00:01:34.886 --> 00:01:36.676
debugger, and in particular, we

00:01:36.676 --> 00:01:38.316
paid particular regard to

00:01:38.316 --> 00:01:39.386
improving the speed with which

00:01:39.676 --> 00:01:40.346
captures happen.

00:01:40.346 --> 00:01:43.096
And I'm happy to say that

00:01:43.096 --> 00:01:46.436
compared to Xcode 8, Xcode 9 now

00:01:46.436 --> 00:01:48.586
captures up to 10 times as fast,

00:01:49.106 --> 00:01:50.116
getting you from clicking the

00:01:50.116 --> 00:01:51.556
Capture button to into the

00:01:51.556 --> 00:01:52.946
debugger much, much more

00:01:52.946 --> 00:01:53.256
quickly.

00:01:56.036 --> 00:01:58.466
As you'd expect, we have full

00:01:58.466 --> 00:02:00.036
support for all the new Metal 2

00:02:00.036 --> 00:02:02.006
API, including Raster order

00:02:02.006 --> 00:02:04.346
groups, sampler arrays, viewport

00:02:04.346 --> 00:02:06.146
arrays, and the new pixel and

00:02:06.146 --> 00:02:07.356
vertex array formats.

00:02:07.876 --> 00:02:10.856
One particular part of Metal 2

00:02:10.856 --> 00:02:12.406
that we've paid a lot of

00:02:12.406 --> 00:02:14.116
attention to is the support for

00:02:14.116 --> 00:02:15.296
the new argument buffers.

00:02:15.936 --> 00:02:17.376
With this, in the buffer viewer,

00:02:17.626 --> 00:02:19.386
you can now see all the

00:02:19.386 --> 00:02:20.546
argument, buffer arguments,

00:02:20.646 --> 00:02:22.196
displayed in line, and you can

00:02:22.196 --> 00:02:23.856
click through whether it be to

00:02:23.856 --> 00:02:26.516
attach your sampler, buffer, or

00:02:26.516 --> 00:02:32.686
another argument buffer itself.

00:02:32.686 --> 00:02:33.956
We've also added support for VR

00:02:33.956 --> 00:02:35.196
captures this year, with

00:02:35.196 --> 00:02:36.456
automatic support for SteamVR.

00:02:36.456 --> 00:02:38.316
And we've added support for you

00:02:38.316 --> 00:02:40.216
to view your submitted surfaces

00:02:40.216 --> 00:02:40.966
in stereo.

00:02:41.446 --> 00:02:43.526
So when you get to the Submit

00:02:43.526 --> 00:02:44.576
call, you're sending your

00:02:44.576 --> 00:02:46.116
surfaces to the VR compositer,

00:02:46.406 --> 00:02:47.786
you will see left eye and right

00:02:47.786 --> 00:02:49.556
eye alongside each other, to

00:02:49.556 --> 00:02:51.106
quickly spot any discrepancies.

00:02:51.676 --> 00:02:56.496
Another area of focus this year

00:02:56.716 --> 00:02:58.006
has been on improving the

00:02:58.006 --> 00:02:59.456
workflow for capturing more

00:02:59.456 --> 00:03:00.416
complex workloads.

00:03:00.826 --> 00:03:01.836
So now if you're doing

00:03:01.896 --> 00:03:04.036
compute-only work in Metal, or

00:03:04.036 --> 00:03:05.396
perhaps you're using multiple

00:03:05.396 --> 00:03:07.516
Metal cues, it's much easier to

00:03:07.516 --> 00:03:08.846
capture exactly the work that

00:03:08.846 --> 00:03:09.396
you want.

00:03:10.446 --> 00:03:11.526
We've added the lightweight

00:03:11.526 --> 00:03:13.576
capture API, with some new Metal

00:03:13.576 --> 00:03:15.406
capture scope objects, that you

00:03:15.406 --> 00:03:17.416
create at startup and then reuse

00:03:17.416 --> 00:03:19.276
every frame to surround the work

00:03:19.276 --> 00:03:20.136
that you want to capture.

00:03:20.546 --> 00:03:21.656
You'll see a demo of this later,

00:03:21.656 --> 00:03:22.746
but it's great for being able to

00:03:22.746 --> 00:03:25.346
say, group all your regular

00:03:25.626 --> 00:03:28.006
rendering work in one scope, and

00:03:28.006 --> 00:03:29.666
some asynchronous work like

00:03:29.916 --> 00:03:31.126
regenerating your tessellation

00:03:31.126 --> 00:03:32.866
factor buffers, in another

00:03:32.866 --> 00:03:33.956
scope, and when you come to

00:03:33.956 --> 00:03:35.456
capture, you get exactly what

00:03:35.456 --> 00:03:35.866
you want.

00:03:37.416 --> 00:03:38.576
We also have support for

00:03:38.576 --> 00:03:39.266
triggering captures

00:03:39.266 --> 00:03:40.766
programmatically from your app.

00:03:41.316 --> 00:03:43.026
We use this a lot within our

00:03:43.026 --> 00:03:44.256
test apps ourselves, so that we

00:03:44.256 --> 00:03:45.436
can quickly do a gesture on the

00:03:45.436 --> 00:03:46.826
device, and trigger a frame

00:03:47.216 --> 00:03:48.476
capture, without having to

00:03:48.476 --> 00:03:53.046
switch our focus back to Xcode.

00:03:53.546 --> 00:03:55.076
Another new feature this year is

00:03:55.076 --> 00:03:56.676
support for Xcode's Quick Looks

00:03:57.046 --> 00:03:57.606
support.

00:03:58.826 --> 00:04:00.766
So now, you have lightweight

00:04:00.766 --> 00:04:02.286
Metal debugging in the CPU

00:04:02.286 --> 00:04:02.856
debugger.

00:04:03.116 --> 00:04:05.276
So if you hit a breakpoint, and

00:04:05.276 --> 00:04:07.316
there is a Metal texture there,

00:04:07.796 --> 00:04:09.206
we'll pull back the data from

00:04:09.206 --> 00:04:11.426
the metal texture on the GPU and

00:04:11.426 --> 00:04:12.716
let you view it there and then.

00:04:12.916 --> 00:04:14.106
Similarly, with buffers and

00:04:14.106 --> 00:04:14.586
samplers.

00:04:15.486 --> 00:04:17.375
This is great for those cases

00:04:17.375 --> 00:04:19.796
where a full frame capture might

00:04:19.796 --> 00:04:21.736
be too invasive, for instance,

00:04:21.736 --> 00:04:22.786
if you're debugging your

00:04:22.786 --> 00:04:24.156
resource loading or some of the

00:04:24.156 --> 00:04:24.546
setup code.

00:04:24.546 --> 00:04:27.506
It is also great in cases where

00:04:27.506 --> 00:04:28.916
you're debugging some compute

00:04:28.916 --> 00:04:32.606
workloads as well.

00:04:33.026 --> 00:04:35.156
So last year we introduced

00:04:35.416 --> 00:04:37.056
support for rich filtering

00:04:37.266 --> 00:04:38.606
throughout the frame debugger,

00:04:38.686 --> 00:04:41.526
so that you could filter both on

00:04:41.526 --> 00:04:42.946
things like resource properties,

00:04:43.426 --> 00:04:44.356
but also within the frame

00:04:44.356 --> 00:04:47.156
navigator, you can filter based

00:04:47.156 --> 00:04:49.606
on contextual data, so what

00:04:49.936 --> 00:04:51.146
resources you're using at a

00:04:51.146 --> 00:04:52.506
given draw call will let that

00:04:52.506 --> 00:04:53.566
draw call show up.

00:04:53.756 --> 00:04:55.196
Well we've taken this to the

00:04:55.196 --> 00:04:56.626
next level this year, with

00:04:56.626 --> 00:04:58.136
support for data mining

00:04:58.136 --> 00:04:59.476
throughout your capture tray.

00:05:00.156 --> 00:05:01.716
So now, when you type, we'll

00:05:01.716 --> 00:05:03.626
give you context aware, or

00:05:03.626 --> 00:05:04.866
complete suggestions.

00:05:05.706 --> 00:05:07.886
And we now allow compound terms.

00:05:08.326 --> 00:05:10.236
So now if you search for a given

00:05:10.236 --> 00:05:12.506
encoder, and then you search for

00:05:12.506 --> 00:05:14.696
a texture, we'll only show you

00:05:14.696 --> 00:05:15.806
auto-complete suggestions for

00:05:15.806 --> 00:05:17.026
the textures that are actually

00:05:17.026 --> 00:05:22.346
used within that encoder.

00:05:22.946 --> 00:05:24.386
One of our most requested

00:05:24.386 --> 00:05:25.806
features over the years has been

00:05:25.806 --> 00:05:27.106
support for pixel inspection.

00:05:28.386 --> 00:05:29.496
And we've finally caught up with

00:05:29.496 --> 00:05:29.766
that.

00:05:30.386 --> 00:05:32.186
So now you can do detailed

00:05:32.186 --> 00:05:34.886
inspection of individual pixels

00:05:35.196 --> 00:05:36.706
within your textures and your

00:05:36.706 --> 00:05:37.486
render targets.

00:05:38.046 --> 00:05:39.366
And if you have multiple

00:05:39.366 --> 00:05:40.196
attachments to your render

00:05:40.196 --> 00:05:41.606
targets, we'll show you the

00:05:41.656 --> 00:05:43.366
pixel values for the same

00:05:43.366 --> 00:05:45.206
location in each attachment at

00:05:45.206 --> 00:05:45.866
the same time.

00:05:45.976 --> 00:05:47.146
So it's really good if you're

00:05:47.146 --> 00:05:48.836
trying to debug what the color

00:05:48.836 --> 00:05:50.136
value is alongside that and

00:05:50.136 --> 00:05:51.036
stencil and such like.

00:05:51.346 --> 00:05:52.916
It's also very valuable for

00:05:52.916 --> 00:05:54.516
debugging compute workloads if

00:05:54.516 --> 00:05:55.746
you're working with images there

00:05:55.746 --> 00:05:56.996
and you are, for instance,

00:05:56.996 --> 00:05:58.236
halfway through your CNN and you

00:05:58.236 --> 00:05:59.686
want to test watch to see what

00:05:59.686 --> 00:06:01.036
the exact values in the buffers

00:06:01.036 --> 00:06:01.306
are.

00:06:03.516 --> 00:06:07.546
[ Applause ]

00:06:08.046 --> 00:06:09.026
>> Another new feature we

00:06:09.026 --> 00:06:10.556
introduced last year was our

00:06:10.556 --> 00:06:12.436
vertex attribute viewer, where

00:06:12.436 --> 00:06:14.336
you can see all the vertex data

00:06:14.486 --> 00:06:16.376
as it goes into your vertex

00:06:16.376 --> 00:06:18.246
shader, you know, shown on a per

00:06:18.246 --> 00:06:19.856
vertex basis.

00:06:20.496 --> 00:06:21.446
Well, this year, we've added

00:06:21.446 --> 00:06:23.626
support for viewing the outputs

00:06:23.626 --> 00:06:25.556
from your vertex shader as well,

00:06:25.696 --> 00:06:27.766
and we will display this inline

00:06:28.076 --> 00:06:29.776
with all the other input data,

00:06:30.146 --> 00:06:31.476
so in this case, you can see

00:06:31.476 --> 00:06:33.306
your position inputs, and your

00:06:33.306 --> 00:06:34.596
position outputs, at the same

00:06:34.596 --> 00:06:35.000
time.

00:06:38.046 --> 00:06:38.866
Well, to show you all these

00:06:38.866 --> 00:06:40.076
great new features in action,

00:06:40.076 --> 00:06:41.256
I'd like to invite my colleague,

00:06:41.486 --> 00:06:42.686
Max, to the stage, who is going

00:06:42.686 --> 00:06:44.106
to give you a demo of all this

00:06:44.106 --> 00:06:45.076
new stuff.

00:06:46.516 --> 00:06:49.556
[ Applause ]

00:06:50.056 --> 00:06:51.956
>> Hello. Great to see you here

00:06:51.956 --> 00:06:52.386
today.

00:06:52.526 --> 00:06:57.706
I hope you are doing fine and

00:06:57.706 --> 00:06:59.776
you are as hyped about Metal as

00:06:59.776 --> 00:07:00.236
we are.

00:07:00.636 --> 00:07:02.616
Xcode GPU debugger helps you

00:07:02.616 --> 00:07:04.456
debugging your GPU and the Metal

00:07:04.456 --> 00:07:05.146
usage.

00:07:05.616 --> 00:07:07.356
I am Max, and I am going to

00:07:07.356 --> 00:07:08.496
maximize your debugging

00:07:08.496 --> 00:07:09.886
experience, showing our new

00:07:09.886 --> 00:07:10.246
features.

00:07:11.516 --> 00:07:14.696
[ Applause ]

00:07:15.196 --> 00:07:17.106
>> Yeah, let me run my demo app.

00:07:19.576 --> 00:07:21.676
It is rendering a beautiful

00:07:21.676 --> 00:07:24.056
scenery, reflects snowy

00:07:24.056 --> 00:07:26.266
mountains, grass that is waving

00:07:26.266 --> 00:07:27.936
in the wind, and to make it even

00:07:27.936 --> 00:07:29.986
look nicer, I added some

00:07:29.986 --> 00:07:31.846
particles that are glowing in

00:07:32.606 --> 00:07:33.176
the air.

00:07:33.216 --> 00:07:35.636
But as you can see, the

00:07:35.636 --> 00:07:37.826
particles of the grass, there is

00:07:37.826 --> 00:07:39.316
some kind of a problem.

00:07:39.546 --> 00:07:41.196
So let's figure this out.

00:07:41.756 --> 00:07:46.296
As a first step, let's check if

00:07:46.296 --> 00:07:47.336
the texture is correct.

00:07:47.906 --> 00:07:49.436
Let me set a breakpoint in the

00:07:49.436 --> 00:07:50.656
rendering loop, where this

00:07:50.716 --> 00:07:52.116
texture is being used.

00:07:53.216 --> 00:07:54.846
Hovering over a variable gives

00:07:54.846 --> 00:07:57.226
you access to Xcode's data tips,

00:07:57.566 --> 00:07:59.446
and you can quick look into the

00:07:59.446 --> 00:08:00.196
texture data.

00:08:00.726 --> 00:08:02.296
This data is fetched live from

00:08:02.296 --> 00:08:03.996
the GPU, and it helps you to

00:08:03.996 --> 00:08:05.576
verify the resources you are

00:08:05.576 --> 00:08:07.466
binding, and, of course, it

00:08:07.466 --> 00:08:09.136
works with all Metal resources.

00:08:09.856 --> 00:08:12.196
The texture in this case looks

00:08:12.196 --> 00:08:12.916
correct.

00:08:13.406 --> 00:08:20.006
So what else can we check?

00:08:20.276 --> 00:08:21.786
Our next step is to capture a

00:08:21.786 --> 00:08:22.226
frame.

00:08:22.686 --> 00:08:25.336
Using the little camera icon in

00:08:25.336 --> 00:08:27.366
the debug bar, let's you capture

00:08:27.366 --> 00:08:29.866
a frame, but using a long press

00:08:30.146 --> 00:08:31.556
gives you access to capture

00:08:31.556 --> 00:08:33.596
scopes and command cues.

00:08:33.876 --> 00:08:36.106
A capture scope is one path

00:08:36.306 --> 00:08:37.596
through your rendering pipeline.

00:08:37.846 --> 00:08:39.035
Like my environment map, I'm

00:08:39.035 --> 00:08:40.395
only updating every couple of

00:08:40.395 --> 00:08:41.066
frames.

00:08:41.826 --> 00:08:43.366
In this case, however, we want

00:08:43.366 --> 00:08:44.596
to capture rendering, this is

00:08:44.596 --> 00:08:45.636
where the particles are being

00:08:45.636 --> 00:08:45.936
drawn.

00:08:46.866 --> 00:08:49.836
So let's capture this.

00:08:50.046 --> 00:08:50.946
And already done.

00:08:51.476 --> 00:08:54.096
For those who are not familiar

00:08:54.096 --> 00:08:55.956
with our tool, I will give you a

00:08:55.956 --> 00:08:56.986
quick run through of all the

00:08:56.986 --> 00:08:58.186
views you are seeing here.

00:08:58.186 --> 00:09:01.726
On the left side, we have the

00:09:01.726 --> 00:09:02.716
debug navigator.

00:09:03.186 --> 00:09:04.276
It is in [inaudible]

00:09:04.276 --> 00:09:06.396
presentation of your frame, and

00:09:06.396 --> 00:09:08.016
to help you, we automatically

00:09:08.016 --> 00:09:10.316
group by command buffers and

00:09:10.316 --> 00:09:11.376
command encoders.

00:09:12.346 --> 00:09:13.926
But also your debugging groups

00:09:13.926 --> 00:09:15.936
are shown here, giving you fine

00:09:15.936 --> 00:09:17.566
grain control over the grouping.

00:09:17.906 --> 00:09:19.856
You can select the draw call or

00:09:19.856 --> 00:09:21.526
any other Metal call to inspect

00:09:21.526 --> 00:09:22.346
further details.

00:09:23.136 --> 00:09:27.406
The editor in the center is

00:09:27.406 --> 00:09:29.106
showing the bound resources.

00:09:29.496 --> 00:09:30.846
All the Metal objects you are

00:09:30.846 --> 00:09:32.986
using in the selected API call.

00:09:33.986 --> 00:09:35.976
Again, you can see labeling your

00:09:35.976 --> 00:09:37.726
objects will greatly increase

00:09:37.726 --> 00:09:38.536
readability.

00:09:38.926 --> 00:09:41.306
So I suggest to do that.

00:09:42.956 --> 00:09:45.026
The editor on the right side is

00:09:45.026 --> 00:09:46.556
showing the attachments, the

00:09:46.556 --> 00:09:48.556
output of the last issued draw

00:09:48.556 --> 00:09:48.936
call.

00:09:49.136 --> 00:09:50.066
So whenever you are, like,

00:09:50.066 --> 00:09:51.416
navigating through your frame,

00:09:51.606 --> 00:09:53.106
you instantly see where you are.

00:09:53.936 --> 00:09:56.346
On the bottom, we have our

00:09:56.346 --> 00:09:58.166
variables view, where you can

00:09:58.166 --> 00:10:00.156
access all the states of each

00:10:00.156 --> 00:10:01.026
Metal object.

00:10:01.506 --> 00:10:03.296
Back to our problem with the

00:10:03.296 --> 00:10:04.366
particles.

00:10:04.786 --> 00:10:06.216
Here, we can make use of our new

00:10:06.216 --> 00:10:07.756
super powerful filtering.

00:10:08.496 --> 00:10:11.226
So I know the particles are

00:10:11.226 --> 00:10:12.666
drawn somewhere in my forward

00:10:12.666 --> 00:10:12.976
rendering.

00:10:13.316 --> 00:10:15.556
So let me filter for this.

00:10:15.866 --> 00:10:17.576
Filtering for command encoder

00:10:17.976 --> 00:10:20.786
will only show API calls inside

00:10:20.786 --> 00:10:21.926
this command encoder.

00:10:21.926 --> 00:10:22.846
Like this.

00:10:23.446 --> 00:10:25.486
But it is still a lot.

00:10:26.646 --> 00:10:28.386
So let me add an additional

00:10:28.386 --> 00:10:28.736
filter.

00:10:29.086 --> 00:10:30.616
We know it is using our particle

00:10:30.616 --> 00:10:31.066
texture.

00:10:34.556 --> 00:10:37.186
Filtering for texture will only

00:10:37.186 --> 00:10:39.476
show draw calls using this

00:10:39.476 --> 00:10:39.896
texture.

00:10:40.576 --> 00:10:43.656
And boom, this combination of

00:10:43.656 --> 00:10:46.046
filters results in a single API

00:10:46.046 --> 00:10:47.986
call we want to inspect further.

00:10:48.726 --> 00:10:49.536
So let's go here.

00:10:50.016 --> 00:10:53.296
Let's take a look at the bound

00:10:53.296 --> 00:10:54.166
resources.

00:10:55.046 --> 00:10:57.026
The vertex attributes combines

00:10:57.026 --> 00:10:58.456
the data that is going into your

00:10:58.456 --> 00:11:01.026
vertex function and leaving it.

00:11:01.296 --> 00:11:02.616
Maybe we are doing something

00:11:02.616 --> 00:11:05.106
wrong with our geometry here, so

00:11:05.106 --> 00:11:06.196
let's open this by double

00:11:06.196 --> 00:11:06.616
clicking.

00:11:07.626 --> 00:11:09.696
Let me also hide the attachments

00:11:09.696 --> 00:11:10.406
for a moment.

00:11:11.626 --> 00:11:13.036
Last year, we started to show

00:11:13.036 --> 00:11:14.436
you a nice layout for all the

00:11:14.436 --> 00:11:14.976
buffers.

00:11:16.516 --> 00:11:17.836
And this year we added something

00:11:17.836 --> 00:11:18.186
more.

00:11:18.986 --> 00:11:20.316
In the header, you can see the

00:11:20.316 --> 00:11:21.746
direction where the data is

00:11:21.746 --> 00:11:22.306
flowing.

00:11:23.266 --> 00:11:28.336
And if we take a look, this is

00:11:28.336 --> 00:11:29.626
the output data, the data that

00:11:29.626 --> 00:11:31.106
is leaving the vertex function.

00:11:31.376 --> 00:11:32.966
This is the output position of

00:11:33.106 --> 00:11:35.776
every particle vertex, and as we

00:11:35.776 --> 00:11:37.336
can see here, there is no

00:11:37.376 --> 00:11:39.286
obvious error, like big numbers

00:11:39.286 --> 00:11:41.166
or something like this, so I

00:11:41.166 --> 00:11:42.706
assume this data is correct.

00:11:43.446 --> 00:11:45.336
So what else can we check?

00:11:46.036 --> 00:11:50.386
The debug navigator now gives

00:11:50.386 --> 00:11:51.836
you quick access to all the

00:11:51.836 --> 00:11:53.596
views related to this draw call.

00:11:53.926 --> 00:11:54.846
Let's switch back to the

00:11:54.846 --> 00:11:55.746
attachments again.

00:11:56.256 --> 00:12:01.306
We are using two render targets

00:12:01.306 --> 00:12:01.506
here.

00:12:02.436 --> 00:12:04.566
Color, and depth.

00:12:05.076 --> 00:12:06.796
Let's inspect some more pixel

00:12:06.796 --> 00:12:07.376
values.

00:12:07.876 --> 00:12:11.586
Using the inspect pixels button

00:12:11.586 --> 00:12:13.156
in the lower right corner, we

00:12:13.226 --> 00:12:16.456
will present a new tool.

00:12:16.556 --> 00:12:20.386
A loop. This loop displays the

00:12:20.386 --> 00:12:22.106
value like they are outputted by

00:12:22.106 --> 00:12:23.296
the fragment function.

00:12:24.246 --> 00:12:26.256
And you can move the loop around

00:12:26.256 --> 00:12:27.506
all the render targets.

00:12:28.386 --> 00:12:29.796
But you can also use your arrow

00:12:29.796 --> 00:12:31.796
keys for pixel precise control,

00:12:31.796 --> 00:12:33.186
even if you are not zoomed in.

00:12:34.396 --> 00:12:36.566
Also, you notice, all the loops

00:12:36.566 --> 00:12:37.806
are being synchronized between

00:12:37.806 --> 00:12:38.956
all the render targets.

00:12:39.246 --> 00:12:40.976
That helps you to relate values.

00:12:41.256 --> 00:12:43.306
Let me find an interesting pixel

00:12:45.056 --> 00:12:45.136
now.

00:12:45.356 --> 00:12:46.426
Using a long press will

00:12:46.426 --> 00:12:47.666
instantly move the cursor.

00:12:48.286 --> 00:12:51.686
And here we can see something

00:12:51.686 --> 00:12:52.576
strange.

00:12:53.466 --> 00:12:55.676
The depth value inside and

00:12:55.676 --> 00:12:57.586
outside a particle is different,

00:12:58.076 --> 00:12:59.796
and let's opt, our particles

00:12:59.796 --> 00:13:00.946
shouldn't write into the depths

00:13:00.946 --> 00:13:01.896
buffer, of course.

00:13:02.526 --> 00:13:03.896
That will be an easy fix.

00:13:04.316 --> 00:13:05.976
And I'm also sure our new GPU

00:13:05.976 --> 00:13:07.536
debugger will help you fixing

00:13:07.536 --> 00:13:08.886
your issues with the GPU.

00:13:09.906 --> 00:13:11.346
I hope we see each other in the

00:13:11.346 --> 00:13:13.326
labs tomorrow morning, or at the

00:13:13.326 --> 00:13:14.226
[inaudible] later today.

00:13:14.936 --> 00:13:16.296
Back to my colleague, Seth.

00:13:17.516 --> 00:13:23.256
[ Applause ]

00:13:23.756 --> 00:13:26.276
>> So now, onto GPU profiling.

00:13:27.896 --> 00:13:29.796
As you know, performance is

00:13:29.796 --> 00:13:30.896
crucial to games and other

00:13:30.896 --> 00:13:32.596
graphical applications, and

00:13:32.596 --> 00:13:33.966
achieving a consistent, fast

00:13:33.966 --> 00:13:35.316
framework is always necessary.

00:13:36.106 --> 00:13:37.216
But on the flip side, you want

00:13:37.216 --> 00:13:38.616
to get the most of the GPU for

00:13:38.616 --> 00:13:40.066
the best looking game as well,

00:13:40.066 --> 00:13:41.756
and at the same time, increase

00:13:41.756 --> 00:13:43.106
efficiency for a longer game

00:13:43.106 --> 00:13:43.846
experience.

00:13:44.556 --> 00:13:45.726
Well, for all this, you need to

00:13:45.726 --> 00:13:47.206
use the GPU Profiling tools.

00:13:47.656 --> 00:13:53.046
The first tool I want to talk

00:13:53.046 --> 00:13:54.546
about is Metal System Trace.

00:13:55.396 --> 00:13:56.236
This is our tool for

00:13:56.236 --> 00:13:58.446
investigating timing issues, by

00:13:58.446 --> 00:14:00.136
which I mean investigating cases

00:14:00.136 --> 00:14:02.446
where the CPU and the GPU might

00:14:02.446 --> 00:14:04.656
not be running in parallel,

00:14:04.656 --> 00:14:06.286
because you have some synching

00:14:06.286 --> 00:14:07.836
operations by mistake, and

00:14:07.836 --> 00:14:08.726
you're forcing them to work in

00:14:08.726 --> 00:14:09.116
serial.

00:14:09.796 --> 00:14:10.586
It's also great for

00:14:10.586 --> 00:14:12.166
investigating those cases where

00:14:12.396 --> 00:14:13.586
you're mostly achieving the

00:14:13.586 --> 00:14:14.676
framework you want, but

00:14:14.676 --> 00:14:15.976
occasionally you get a stutter,

00:14:16.246 --> 00:14:17.126
and you need to figure out,

00:14:17.126 --> 00:14:18.306
okay, what is going wrong in

00:14:18.306 --> 00:14:19.226
that particular frame?

00:14:20.106 --> 00:14:21.676
It lets you trace your Metal

00:14:21.676 --> 00:14:22.966
workloads through the system,

00:14:23.046 --> 00:14:25.436
from CPU to GPU to display.

00:14:27.436 --> 00:14:29.606
This year, we've added support

00:14:29.606 --> 00:14:31.296
for VR applications, with

00:14:31.296 --> 00:14:33.056
specific VR trace points for

00:14:33.056 --> 00:14:35.836
activities like when you query

00:14:35.836 --> 00:14:38.916
the head set for post-data, when

00:14:38.916 --> 00:14:40.516
you submit your surfaces to the

00:14:40.516 --> 00:14:43.086
VR compositor, when it does its

00:14:43.086 --> 00:14:45.196
work to do the compositing, and

00:14:45.196 --> 00:14:46.946
finally, when it hits the glass

00:14:47.106 --> 00:14:48.506
on the headset.

00:14:49.576 --> 00:14:51.406
In effect, it lets you trace

00:14:51.406 --> 00:14:53.366
from motion to photon.

00:14:55.976 --> 00:14:58.266
We've also added support this

00:14:58.266 --> 00:14:59.566
year for the new ProMotion

00:14:59.566 --> 00:15:02.076
displays, as you'll find in the

00:15:02.076 --> 00:15:04.096
new iPads, iPad Pros released

00:15:04.096 --> 00:15:06.066
early this week, and also

00:15:06.066 --> 00:15:08.046
support for external GPUs on

00:15:08.046 --> 00:15:08.666
macOS.

00:15:09.476 --> 00:15:10.776
It is also worth noting there

00:15:10.776 --> 00:15:11.906
are some great improvements in

00:15:11.906 --> 00:15:13.846
the instruments, to make it much

00:15:13.846 --> 00:15:15.616
easier to view other instruments

00:15:15.786 --> 00:15:17.646
alongside Metal System Trace in

00:15:17.646 --> 00:15:20.386
a more integrated fashion.

00:15:20.816 --> 00:15:22.776
Our next profiling tool is the

00:15:22.776 --> 00:15:23.806
GPU Shader Profiler.

00:15:24.306 --> 00:15:25.726
The tool for probing shader

00:15:25.726 --> 00:15:26.326
performance.

00:15:27.076 --> 00:15:28.316
It is integrated into the frame

00:15:28.316 --> 00:15:29.626
debugger, and lets you view

00:15:29.626 --> 00:15:31.466
shader time on a per draw call

00:15:31.466 --> 00:15:33.116
and per pipeline basis.

00:15:33.686 --> 00:15:37.416
And if you're on iOS or tvOS, it

00:15:37.416 --> 00:15:39.236
also lets you view it on a per

00:15:39.236 --> 00:15:39.956
line basis.

00:15:41.696 --> 00:15:43.136
Well, our first new tool this

00:15:43.136 --> 00:15:44.816
year is designed to work hand in

00:15:44.816 --> 00:15:46.006
hand with the GPU Shader

00:15:46.006 --> 00:15:46.496
Profiler.

00:15:48.636 --> 00:15:50.296
We call that Metal Pipeline

00:15:50.296 --> 00:15:51.046
Statistics.

00:15:53.036 --> 00:15:55.436
Metal Pipeline Statistics gives

00:15:55.436 --> 00:15:57.456
you a direct line to the GPU

00:15:57.456 --> 00:15:59.306
compiler to find out about the

00:15:59.306 --> 00:16:00.916
quality of the machine code the

00:16:00.916 --> 00:16:02.946
compiler is generating from your

00:16:03.016 --> 00:16:03.316
shader.

00:16:04.066 --> 00:16:05.176
It gives you a rich set of

00:16:05.176 --> 00:16:06.606
statistics with things such as

00:16:06.756 --> 00:16:08.366
instruction count, instruction

00:16:08.366 --> 00:16:10.236
mix, by which I mean the

00:16:10.236 --> 00:16:11.796
relative ratio of operations

00:16:11.796 --> 00:16:13.396
such as ALU or memory or control

00:16:13.396 --> 00:16:15.826
flow, and on GPUs where it is

00:16:15.826 --> 00:16:17.216
relevant, it will also show you

00:16:17.216 --> 00:16:18.866
register usage and occupancy.

00:16:19.306 --> 00:16:21.986
For GPUs such as that, these

00:16:22.016 --> 00:16:23.436
measures are crucial in

00:16:23.436 --> 00:16:25.306
understanding what is the

00:16:25.306 --> 00:16:27.766
limitations on how many shaders

00:16:27.766 --> 00:16:29.496
can be scheduled simultaneously,

00:16:30.176 --> 00:16:32.486
by which shader instances can be

00:16:32.646 --> 00:16:33.646
scheduled simultaneously.

00:16:34.876 --> 00:16:37.976
But even better are the new

00:16:37.976 --> 00:16:39.066
compiler remarks.

00:16:39.736 --> 00:16:41.636
With this, the GPU compiler will

00:16:41.636 --> 00:16:43.446
give you direct actual guidance

00:16:43.666 --> 00:16:44.786
on the performance of your

00:16:44.786 --> 00:16:46.506
shader, and things you can do to

00:16:46.506 --> 00:16:48.556
avoid performance hits, from

00:16:48.556 --> 00:16:49.956
things such as slow math usage,

00:16:50.256 --> 00:16:51.776
register spills, and stack

00:16:51.776 --> 00:16:52.216
usage.

00:16:52.796 --> 00:16:56.906
It's like having a GPU compiler

00:16:56.906 --> 00:16:59.636
engineer built into every Xcode.

00:17:00.736 --> 00:17:02.806
For each remark, it will explain

00:17:02.946 --> 00:17:06.246
what it means, what you can do

00:17:06.316 --> 00:17:08.796
to reduce it, and give you a

00:17:08.796 --> 00:17:11.006
link to where you need to go to

00:17:11.076 --> 00:17:11.536
fix it.

00:17:12.695 --> 00:17:13.955
Well, to demo this new feature,

00:17:13.955 --> 00:17:15.036
I'd like to invite my colleague

00:17:15.256 --> 00:17:16.935
Jose to the stage, to give you a

00:17:16.935 --> 00:17:18.465
tour of Metal Pipeline

00:17:18.465 --> 00:17:19.086
Statistics.

00:17:20.516 --> 00:17:22.546
[ Applause ]

00:17:23.046 --> 00:17:23.536
>> Hello everyone.

00:17:23.685 --> 00:17:24.526
My name is Jose Enrique

00:17:24.526 --> 00:17:24.606
[inaudible].

00:17:24.606 --> 00:17:26.006
I am going to present you a new

00:17:26.006 --> 00:17:27.556
feature of our GPU friendly

00:17:27.556 --> 00:17:28.946
debugger that will have you

00:17:29.296 --> 00:17:30.466
produce good quality.

00:17:30.836 --> 00:17:32.416
As you can see, we are replaying

00:17:32.526 --> 00:17:33.786
a capture of Metal [inaudible]

00:17:33.976 --> 00:17:35.166
demo for iOS.

00:17:35.996 --> 00:17:37.956
The first thing I'm going to do,

00:17:37.956 --> 00:17:39.286
I'm going to change my debug

00:17:39.286 --> 00:17:41.196
navigator view from view frame

00:17:41.196 --> 00:17:42.766
by call to view frame by

00:17:42.766 --> 00:17:43.496
performance.

00:17:44.026 --> 00:17:46.916
What this gives, what this view

00:17:46.916 --> 00:17:50.216
gives is all these pipelines you

00:17:50.216 --> 00:17:53.956
capture, sorted by time.

00:17:54.146 --> 00:17:56.066
Remember, in Metal, a shader is

00:17:56.066 --> 00:17:57.156
always linked to a pipeline,

00:17:57.556 --> 00:17:59.556
therefore, this is a list of all

00:17:59.556 --> 00:18:00.656
initiator combinations that are

00:18:00.656 --> 00:18:01.126
available in [inaudible]

00:18:01.126 --> 00:18:01.466
capture.

00:18:02.486 --> 00:18:04.506
I am going to go to a

00:18:04.506 --> 00:18:05.296
[inaudible] view of the most

00:18:05.296 --> 00:18:06.836
expensive pipeline, to see if we

00:18:06.836 --> 00:18:07.866
can improve the shaders.

00:18:08.436 --> 00:18:12.726
As you can see, this view has

00:18:12.726 --> 00:18:13.586
three sections.

00:18:13.956 --> 00:18:15.686
On top, we have remarks.

00:18:16.296 --> 00:18:17.626
Remarks are a unique approach to

00:18:17.626 --> 00:18:19.246
the compiler shader quality.

00:18:19.616 --> 00:18:21.576
As the report, final compiler

00:18:22.116 --> 00:18:23.486
co-generation issues.

00:18:24.646 --> 00:18:26.326
Remember, the GPU will execute

00:18:26.326 --> 00:18:28.206
your shader millions of times

00:18:28.206 --> 00:18:30.046
per frame, therefore, the

00:18:30.046 --> 00:18:31.446
[inaudible] you can get, the

00:18:31.446 --> 00:18:33.746
better the performance it will

00:18:33.746 --> 00:18:34.016
have.

00:18:35.096 --> 00:18:36.406
Remarks also are sorted by

00:18:36.406 --> 00:18:38.766
relevance, and if expanded, they

00:18:38.766 --> 00:18:41.106
offer you reason on why we're

00:18:41.106 --> 00:18:42.986
reporting it, and our

00:18:42.986 --> 00:18:44.556
recommendation on how to prevent

00:18:45.456 --> 00:18:45.523
it.

00:18:46.226 --> 00:18:47.836
Below remarks, we have an

00:18:47.836 --> 00:18:49.336
overview for each shader, where

00:18:49.336 --> 00:18:50.496
you can see how the compiler

00:18:50.576 --> 00:18:52.986
final assemblies compose

00:18:52.986 --> 00:18:54.096
[inaudible] of instruction

00:18:54.166 --> 00:18:54.876
ratios.

00:18:56.186 --> 00:18:58.046
And finally, we have a list of

00:18:58.106 --> 00:18:59.306
all the recalls using this

00:18:59.306 --> 00:18:59.756
pipeline.

00:19:00.396 --> 00:19:01.626
This will become very handy

00:19:01.626 --> 00:19:02.776
whenever we are iterating over

00:19:02.776 --> 00:19:03.396
our shaders.

00:19:04.426 --> 00:19:06.946
So let me showcase an example of

00:19:06.946 --> 00:19:08.506
workflow profiler statistics.

00:19:09.376 --> 00:19:10.976
We go to our top remark,

00:19:11.186 --> 00:19:13.036
Register Spill, we can see the

00:19:13.036 --> 00:19:14.846
compiler is reporting a big

00:19:14.846 --> 00:19:16.946
spill, 1,040 bytes.

00:19:17.786 --> 00:19:19.246
Spills will cause the GPU to

00:19:19.246 --> 00:19:21.546
access memory, which can stall

00:19:21.546 --> 00:19:22.486
your shade execution.

00:19:23.856 --> 00:19:24.806
Knowing that a compiler is

00:19:24.806 --> 00:19:26.326
spilling and fixing it can

00:19:26.326 --> 00:19:27.376
drastically improve your shader

00:19:27.376 --> 00:19:29.636
performance, yet finding where

00:19:29.636 --> 00:19:30.886
and why the compiler is spilling

00:19:31.296 --> 00:19:32.566
tends to be a time consuming

00:19:32.566 --> 00:19:32.876
manual [inaudible].

00:19:33.936 --> 00:19:36.596
But notice the second and fourth

00:19:36.596 --> 00:19:37.106
remarks.

00:19:37.586 --> 00:19:39.156
Dynamic Stack Store, and Dynamic

00:19:39.156 --> 00:19:39.766
Stack Load.

00:19:40.776 --> 00:19:43.056
If expanded, they offer a reason

00:19:43.226 --> 00:19:45.046
an expensive stack load is

00:19:45.046 --> 00:19:46.716
emitted to a dynamic offset in a

00:19:46.716 --> 00:19:47.416
local array.

00:19:48.256 --> 00:19:51.096
As well as a recommendation, to

00:19:51.096 --> 00:19:52.256
reduce the stack access,

00:19:52.336 --> 00:19:53.786
eliminate dynamic access to

00:19:53.786 --> 00:19:54.476
local arrays.

00:19:55.236 --> 00:19:57.026
This is basically saying that we

00:19:57.026 --> 00:19:58.586
have an array variable in our

00:19:58.586 --> 00:20:00.116
shader code that is storing the

00:20:00.116 --> 00:20:01.936
stack and where accessing it

00:20:01.936 --> 00:20:03.416
using some other index variable.

00:20:04.296 --> 00:20:05.996
This is a very common pattern

00:20:05.996 --> 00:20:07.816
when providing for the CPU, but

00:20:07.816 --> 00:20:09.286
GPUs are different, they suffer

00:20:09.286 --> 00:20:11.346
when we rely on stack usage.

00:20:11.966 --> 00:20:14.726
But note the languages below the

00:20:14.726 --> 00:20:15.376
recommendation.

00:20:15.426 --> 00:20:16.916
It has an exact line number.

00:20:17.436 --> 00:20:18.676
This means that we option click

00:20:18.776 --> 00:20:22.086
to it, we'll jump directly to

00:20:22.086 --> 00:20:23.426
the [inaudible] line where the

00:20:23.426 --> 00:20:25.146
compiler is actually loading

00:20:25.146 --> 00:20:26.286
data from the stack array.

00:20:26.776 --> 00:20:27.896
We just found the compiler

00:20:27.896 --> 00:20:28.296
spill.

00:20:29.366 --> 00:20:30.656
Also these align very well with

00:20:30.656 --> 00:20:31.676
our shared performing data,

00:20:31.676 --> 00:20:33.116
informing us of the high cost of

00:20:33.116 --> 00:20:34.986
this line, which now we know

00:20:34.986 --> 00:20:35.666
exactly why.

00:20:37.396 --> 00:20:40.326
The shader is doing two passes.

00:20:41.056 --> 00:20:42.836
The first pass, doing some light

00:20:42.836 --> 00:20:43.586
computation.

00:20:44.166 --> 00:20:46.956
And a second pass, doing the

00:20:46.956 --> 00:20:47.776
light accumulation.

00:20:48.766 --> 00:20:49.766
This speaks to the issue by

00:20:49.766 --> 00:20:51.076
working with the compiler but

00:20:51.076 --> 00:20:52.186
from a GPU perspective.

00:20:52.856 --> 00:20:55.056
The first thing I'm going to do,

00:20:55.176 --> 00:20:56.686
I'm going to remove the stack

00:20:56.686 --> 00:20:59.756
array, I am going to remove it

00:20:59.756 --> 00:21:02.366
in relation, and then I'm going

00:21:02.366 --> 00:21:03.536
to compute the light

00:21:03.536 --> 00:21:04.896
accommodation directly into the

00:21:04.896 --> 00:21:06.166
first loop.

00:21:09.116 --> 00:21:10.736
Then I am going to remove the

00:21:10.736 --> 00:21:12.976
second loop, and just not do

00:21:13.996 --> 00:21:14.316
that anymore.

00:21:14.316 --> 00:21:15.916
Now, I click my update shader

00:21:15.916 --> 00:21:17.396
button, and wait for the

00:21:17.396 --> 00:21:17.916
results.

00:21:18.516 --> 00:21:19.646
What this is going to do, it's

00:21:19.646 --> 00:21:20.966
going to have the compiler

00:21:20.966 --> 00:21:21.776
perform a whole loop

00:21:21.776 --> 00:21:24.376
optimization and reuse the same

00:21:24.376 --> 00:21:26.636
reducer over and over, instead

00:21:26.636 --> 00:21:27.596
of relying on the stack.

00:21:28.906 --> 00:21:30.356
Once the results are back, we

00:21:30.356 --> 00:21:31.786
can see the instruction ratio

00:21:31.786 --> 00:21:33.356
between the previous and current

00:21:33.356 --> 00:21:35.416
[inaudible] has been reduced, as

00:21:35.416 --> 00:21:36.486
well as the impact of this

00:21:36.486 --> 00:21:38.006
change on every single draw call

00:21:38.006 --> 00:21:39.726
used in the pipeline, giving us

00:21:39.726 --> 00:21:41.296
also whole space performance

00:21:41.296 --> 00:21:41.896
improvements.

00:21:43.046 --> 00:21:44.226
And with this, I conclude my

00:21:44.226 --> 00:21:44.986
example of [inaudible]

00:21:44.986 --> 00:21:46.246
statistics.

00:21:46.466 --> 00:21:47.656
I hand it back to my colleague,

00:21:47.656 --> 00:21:47.926
Seth.

00:21:49.516 --> 00:21:54.756
[ Applause ]

00:21:55.256 --> 00:21:56.866
>> Thank you, Jose.

00:21:56.966 --> 00:21:59.766
And finally, onto our last new

00:21:59.766 --> 00:22:00.296
tool today.

00:22:00.726 --> 00:22:02.286
GPU Counter Profiling.

00:22:02.806 --> 00:22:06.196
As you know, GPU architecture is

00:22:06.196 --> 00:22:08.056
complex, with a pipeline

00:22:08.056 --> 00:22:08.986
consisting of multiple

00:22:08.986 --> 00:22:10.366
programmable and fixed function

00:22:10.366 --> 00:22:12.196
blocks, bottlenecks can occur at

00:22:12.196 --> 00:22:13.396
any point within the pipeline,

00:22:14.216 --> 00:22:15.476
and often, at multiple

00:22:15.546 --> 00:22:16.936
simultaneous points.

00:22:18.386 --> 00:22:20.986
Your job as Metal programmers is

00:22:20.986 --> 00:22:23.026
to minimize fixed function

00:22:23.026 --> 00:22:24.366
bottlenecks while efficiently

00:22:24.366 --> 00:22:25.966
harnessing programmable blocks.

00:22:28.776 --> 00:22:30.586
Well, to do that, our new GPU

00:22:30.586 --> 00:22:33.166
Counter Profiling is the tool.

00:22:33.546 --> 00:22:36.106
Instead of going directly into

00:22:36.106 --> 00:22:38.236
the GPU Frame Debugger, it gives

00:22:38.236 --> 00:22:40.286
you detailed GPU hardware

00:22:40.286 --> 00:22:42.866
performance statistics on a per

00:22:42.866 --> 00:22:46.496
draw call, on macOS and per

00:22:46.496 --> 00:22:49.066
encoder on iOS and tvOS basis.

00:22:50.036 --> 00:22:51.986
And instead of giving you an

00:22:51.986 --> 00:22:54.336
arcane list of counters that

00:22:54.336 --> 00:22:55.906
change for every GPU and are

00:22:55.906 --> 00:22:57.676
hard to understand, and often

00:22:58.206 --> 00:22:59.216
don't tell you what you need to

00:22:59.216 --> 00:23:01.576
know, we've defined a high level

00:23:01.576 --> 00:23:03.236
set of characters that mean the

00:23:03.236 --> 00:23:04.936
same across each GPU.

00:23:05.286 --> 00:23:07.296
So you don't have a per GPU

00:23:07.296 --> 00:23:08.666
learning curve.

00:23:10.156 --> 00:23:12.606
So here is the Counter

00:23:12.606 --> 00:23:13.146
Profiling.

00:23:13.146 --> 00:23:16.726
On the left, we have a graph

00:23:16.726 --> 00:23:19.506
view, showing you detailed GPU

00:23:19.546 --> 00:23:21.156
counter graphs, and on the

00:23:21.156 --> 00:23:22.886
right, the detail window.

00:23:23.606 --> 00:23:25.246
Let's talk about those in order.

00:23:26.036 --> 00:23:29.866
In the graph view, we show you

00:23:30.276 --> 00:23:33.306
counters across your frame,

00:23:33.936 --> 00:23:35.706
where the x axis represents draw

00:23:35.706 --> 00:23:37.836
calls, or encoders across time.

00:23:39.036 --> 00:23:40.506
At the top, we show you GPU

00:23:40.506 --> 00:23:40.826
time.

00:23:40.826 --> 00:23:43.206
As that is inherent to all GPU

00:23:43.206 --> 00:23:43.996
counter profiling.

00:23:44.746 --> 00:23:45.886
And then below that, a set of

00:23:45.886 --> 00:23:47.106
top level counters that

00:23:47.106 --> 00:23:48.706
correspond to the stages in the

00:23:48.706 --> 00:23:50.986
GPU pipeline, along with some

00:23:50.986 --> 00:23:52.386
other top level counters that

00:23:52.386 --> 00:23:53.996
correspond to shared execution

00:23:53.996 --> 00:23:55.816
units, such as the shader core

00:23:55.816 --> 00:23:56.836
and test units.

00:23:58.616 --> 00:24:00.796
For each group, you can drill

00:24:00.796 --> 00:24:02.686
down to more detailed counters,

00:24:02.686 --> 00:24:04.726
exploring a lot more data for

00:24:04.726 --> 00:24:06.966
each stage, and this is great

00:24:06.966 --> 00:24:08.926
for work flow where you identify

00:24:08.926 --> 00:24:10.616
it as your first cut, where you

00:24:10.616 --> 00:24:11.816
think the performance issue is,

00:24:11.976 --> 00:24:13.746
and then drill down to see why

00:24:13.746 --> 00:24:14.286
it's going on.

00:24:14.976 --> 00:24:19.586
In the detail view, we'll show

00:24:19.586 --> 00:24:20.976
you all the same counters from

00:24:20.976 --> 00:24:22.306
the counter graph view, but

00:24:22.306 --> 00:24:23.706
displayed in full detail

00:24:23.706 --> 00:24:24.226
numerically.

00:24:25.096 --> 00:24:26.546
And to give it context, we will

00:24:26.546 --> 00:24:28.656
show it alongside the median,

00:24:28.656 --> 00:24:29.996
max, and total values for the

00:24:29.996 --> 00:24:30.786
frame as well.

00:24:31.016 --> 00:24:34.546
Now, both the graph view and the

00:24:34.546 --> 00:24:35.856
detail views support the same

00:24:35.856 --> 00:24:38.136
full, rich filtering options

00:24:38.426 --> 00:24:40.036
that we support elsewhere in the

00:24:40.036 --> 00:24:42.226
frame debugger, so if you want

00:24:42.226 --> 00:24:44.086
to just view certain pixel stats

00:24:44.216 --> 00:24:45.426
and certain memory stats at the

00:24:45.426 --> 00:24:47.336
same time, you can put together

00:24:47.336 --> 00:24:48.776
the search term, and view

00:24:48.776 --> 00:24:49.876
everything you want alongside

00:24:49.876 --> 00:24:50.726
each other.

00:24:51.406 --> 00:24:54.696
But I'll highlight the GPU

00:24:54.696 --> 00:24:56.756
counter profiling is our advance

00:24:56.756 --> 00:24:58.026
to bottleneck analysis.

00:24:59.016 --> 00:25:00.516
With this, we take all the

00:25:00.516 --> 00:25:01.896
counters that have been pulled

00:25:01.896 --> 00:25:03.706
for each draw call, or each

00:25:03.706 --> 00:25:05.536
encoder, and perform rich

00:25:05.536 --> 00:25:07.696
analysis on it, both on a cross

00:25:07.696 --> 00:25:10.446
platform basis, and on a per GPU

00:25:10.446 --> 00:25:12.716
specific basis to identify

00:25:12.716 --> 00:25:14.506
potential bottlenecks at each

00:25:14.506 --> 00:25:14.866
call.

00:25:16.446 --> 00:25:19.546
Alongside this, we will give you

00:25:19.546 --> 00:25:21.416
lots of data about, okay, what

00:25:21.416 --> 00:25:22.636
is going on here?

00:25:23.006 --> 00:25:24.306
What could cause it?

00:25:24.306 --> 00:25:26.266
And then intuitive workflow to

00:25:26.266 --> 00:25:28.716
navigate direct to the affected

00:25:28.716 --> 00:25:29.016
area.

00:25:30.346 --> 00:25:32.136
Now, both the, all the

00:25:32.136 --> 00:25:34.356
bottlenecks and all the counters

00:25:34.486 --> 00:25:36.606
will have rich detailed

00:25:36.866 --> 00:25:38.826
documentation within Xcode docs,

00:25:39.166 --> 00:25:40.716
explaining what each counter

00:25:40.716 --> 00:25:43.276
means in detail, why it might be

00:25:43.276 --> 00:25:44.636
particularly high or

00:25:44.636 --> 00:25:46.626
particularly low, and what you

00:25:46.626 --> 00:25:47.846
can do about it.

00:25:47.846 --> 00:25:49.306
To give a demo of this great new

00:25:49.516 --> 00:25:51.086
GPU Counter Profiling feature,

00:25:51.086 --> 00:25:52.556
I'd like to invite my colleague,

00:25:52.556 --> 00:25:54.476
Jose, back to the stage to give

00:25:54.476 --> 00:25:56.336
you a demo of it in action.

00:25:57.516 --> 00:25:59.676
[ Applause ]

00:26:00.176 --> 00:26:00.576
>> Thank you, Seth.

00:26:01.176 --> 00:26:02.116
And hello again everyone.

00:26:02.806 --> 00:26:06.066
This time, I will demonstrate

00:26:06.426 --> 00:26:10.266
GPU counters, a tool that will

00:26:10.266 --> 00:26:11.396
help you analyze your GPU

00:26:11.396 --> 00:26:11.996
performance.

00:26:13.036 --> 00:26:14.066
First, I'm going to replay the

00:26:14.066 --> 00:26:15.286
same demo that [inaudible] was

00:26:15.286 --> 00:26:17.496
on, but this time, we'll focus

00:26:17.496 --> 00:26:18.636
from a performance perspective.

00:26:19.766 --> 00:26:21.596
The first thing to note is, the

00:26:21.596 --> 00:26:23.656
new GPU gauge, just under the

00:26:23.656 --> 00:26:24.336
FPS gauge.

00:26:25.366 --> 00:26:26.356
By clicking on it, we'll

00:26:26.356 --> 00:26:28.796
navigate to our GP counter view.

00:26:29.436 --> 00:26:31.316
As you can see, there is a

00:26:31.316 --> 00:26:32.486
wealth of data here.

00:26:33.106 --> 00:26:34.306
Available for the first time.

00:26:34.476 --> 00:26:36.286
With this view, you can now

00:26:36.356 --> 00:26:38.216
deliver file any GPU performance

00:26:38.216 --> 00:26:39.316
issue that you have in any of

00:26:39.316 --> 00:26:40.296
your capture frames.

00:26:41.326 --> 00:26:42.796
So let me demonstrate how to

00:26:42.796 --> 00:26:43.776
find performance issues.

00:26:45.326 --> 00:26:46.696
First, let's focus on the graph

00:26:46.696 --> 00:26:47.016
view.

00:26:47.016 --> 00:26:47.083
'

00:26:50.206 --> 00:26:51.566
As you can see, there is a main

00:26:51.566 --> 00:26:53.076
spike in GPU time at the very

00:26:53.076 --> 00:26:54.016
beginning of a capture.

00:26:54.526 --> 00:26:56.356
The first thing you want to do

00:26:56.356 --> 00:26:58.746
is to zoom in to see a single

00:26:58.826 --> 00:26:59.876
recall, there are more

00:26:59.876 --> 00:27:00.436
offenders.

00:27:00.946 --> 00:27:01.926
In order to do that, I can

00:27:01.926 --> 00:27:04.596
simply pinch and zoom, just like

00:27:04.596 --> 00:27:04.846
that.

00:27:05.556 --> 00:27:07.216
Any default system behaviors

00:27:07.216 --> 00:27:08.356
will work just as you expect

00:27:08.356 --> 00:27:08.696
them to.

00:27:09.406 --> 00:27:11.546
Now I will see that there is a

00:27:11.546 --> 00:27:12.266
main spike.

00:27:12.456 --> 00:27:14.106
You can click on this draw call

00:27:14.106 --> 00:27:15.306
to highlight this impact across

00:27:15.436 --> 00:27:17.856
all the pipeline, and hovering

00:27:17.856 --> 00:27:19.856
over each row will give us

00:27:19.856 --> 00:27:21.396
detailed information on how

00:27:21.396 --> 00:27:23.016
relevant that stage is for this

00:27:23.016 --> 00:27:23.936
particular draw call.

00:27:24.856 --> 00:27:26.896
In this case, Vertex Omission,

00:27:27.026 --> 00:27:28.506
Vertex Shader, and Primitives

00:27:28.936 --> 00:27:30.546
did not seem to have relevant

00:27:30.676 --> 00:27:30.876
impact.

00:27:31.406 --> 00:27:33.096
On the contrary, Fragment Shader

00:27:33.716 --> 00:27:35.236
and Pixels [inaudible] seemed to

00:27:35.436 --> 00:27:36.316
be quite high.

00:27:37.106 --> 00:27:38.836
Let's focus on the Fragment

00:27:38.836 --> 00:27:39.436
Shader first.

00:27:40.396 --> 00:27:42.326
If we expand this group we now

00:27:42.326 --> 00:27:43.796
get access to a massive amount

00:27:43.796 --> 00:27:45.596
of counter data that gives us

00:27:45.656 --> 00:27:47.336
detailed information what is

00:27:47.336 --> 00:27:48.806
going on with the Shader stage.

00:27:49.636 --> 00:27:50.646
The last thing that this

00:27:50.646 --> 00:27:52.366
counted, we can quickly see that

00:27:52.616 --> 00:27:54.476
the stall time is unusually

00:27:54.476 --> 00:27:56.786
high, over 76%.

00:27:57.486 --> 00:27:58.936
This means that most of the time

00:27:58.936 --> 00:28:00.116
we are spending on the Fragment

00:28:00.116 --> 00:28:01.586
Shader is actually waiting for

00:28:01.586 --> 00:28:03.366
some memory or data to be

00:28:03.366 --> 00:28:03.816
available.

00:28:04.526 --> 00:28:06.776
This is caused because you are

00:28:06.776 --> 00:28:08.176
fetching from a buffer or from a

00:28:08.176 --> 00:28:10.596
texture, but texture captures

00:28:10.596 --> 00:28:11.806
should be here in this latency,

00:28:12.406 --> 00:28:14.556
so let's go down to our Texture

00:28:14.556 --> 00:28:16.736
Unit, to see what is the cache

00:28:16.736 --> 00:28:16.956
rate.

00:28:18.746 --> 00:28:20.526
And we can immediately see that

00:28:20.526 --> 00:28:22.256
the textures cache rate is also

00:28:22.256 --> 00:28:24.586
unusually high, almost at 60%.

00:28:25.326 --> 00:28:27.246
This means that more than half

00:28:27.246 --> 00:28:28.396
of the texture samples we are

00:28:28.396 --> 00:28:29.636
doing are coming from video

00:28:29.636 --> 00:28:30.766
memory and not from the texture

00:28:30.766 --> 00:28:31.236
caches.

00:28:31.966 --> 00:28:33.956
Now that we have a better

00:28:33.956 --> 00:28:34.946
understanding of the issue at

00:28:34.946 --> 00:28:36.966
hand, let's focus on the

00:28:36.966 --> 00:28:37.636
assistant editor.

00:28:38.196 --> 00:28:41.686
As you can see, the assistant

00:28:41.686 --> 00:28:43.406
editors offer the same graph

00:28:43.506 --> 00:28:45.006
inform-- counter information as

00:28:45.006 --> 00:28:46.156
the graph view was offering, but

00:28:46.356 --> 00:28:48.106
this time, displayed as a table

00:28:48.106 --> 00:28:48.516
view.

00:28:48.806 --> 00:28:51.376
But more important, look at the

00:28:51.376 --> 00:28:51.826
top.

00:28:51.826 --> 00:28:53.286
This is our bottleneck access

00:28:53.286 --> 00:28:53.566
tool.

00:28:53.566 --> 00:28:56.406
It will point out two relevant

00:28:56.406 --> 00:28:58.106
issues that we consider when we

00:28:58.106 --> 00:29:00.276
analyze all the counters within

00:29:00.276 --> 00:29:01.736
the selected draw call, and

00:29:01.736 --> 00:29:03.076
point out any relevant issues

00:29:03.076 --> 00:29:04.976
that we cconsider important for

00:29:04.976 --> 00:29:05.926
you to pay attention to.

00:29:06.266 --> 00:29:07.356
In this case, highlighting the

00:29:07.356 --> 00:29:09.446
same as we just found manually

00:29:09.446 --> 00:29:12.776
by checking the graph, that the

00:29:12.776 --> 00:29:15.646
texture cache miss rate is high.

00:29:15.876 --> 00:29:17.686
When expanded, it also offers

00:29:17.686 --> 00:29:18.586
recommendations on what to

00:29:18.586 --> 00:29:18.866
check.

00:29:19.636 --> 00:29:21.436
In this case, check if sampled

00:29:21.436 --> 00:29:23.446
textures have [inaudible], and a

00:29:23.486 --> 00:29:25.406
quick navigational name to

00:29:25.436 --> 00:29:26.786
relevant views for this issue.

00:29:28.066 --> 00:29:29.656
For example, boundary sources,

00:29:30.006 --> 00:29:31.266
where we can immediately see

00:29:31.266 --> 00:29:32.886
what's the issue at hand, we're

00:29:32.886 --> 00:29:35.866
fetching a 4K by 4K RGBA32

00:29:35.926 --> 00:29:37.126
Floating Point Texture with

00:29:37.126 --> 00:29:38.576
[inaudible] in both our vertex

00:29:39.226 --> 00:29:40.126
and our Fragment Shader.

00:29:40.476 --> 00:29:43.336
This is a 256-megabyte texture

00:29:43.336 --> 00:29:44.866
that is fetched all over the

00:29:44.866 --> 00:29:45.296
pipeline.

00:29:45.846 --> 00:29:47.816
No wonder we are trashing our

00:29:48.496 --> 00:29:48.786
cache.

00:29:48.826 --> 00:29:50.156
Just think for a moment what we

00:29:50.156 --> 00:29:50.826
just did.

00:29:51.426 --> 00:29:52.486
This was an incredibly detailed

00:29:52.486 --> 00:29:54.656
view of how GPU internals work.

00:29:55.616 --> 00:29:56.926
You finally have the data to

00:29:56.926 --> 00:29:58.216
prove what [inaudible] telling

00:29:58.216 --> 00:29:59.746
you, that fetching from the

00:29:59.746 --> 00:30:01.226
textures is expensive, but now

00:30:01.226 --> 00:30:02.176
you know exactly why.

00:30:03.296 --> 00:30:05.076
Accessing this texture was a

00:30:05.076 --> 00:30:06.216
star on the Fragment Shader,

00:30:06.216 --> 00:30:08.136
because it had to fetch some

00:30:08.136 --> 00:30:09.196
data from [inaudible] memory

00:30:09.196 --> 00:30:11.426
that was not available in the

00:30:12.376 --> 00:30:12.576
caches.

00:30:12.706 --> 00:30:13.656
This level of detail is

00:30:13.656 --> 00:30:14.716
typically not seen outside

00:30:14.716 --> 00:30:15.606
consult tools.

00:30:16.706 --> 00:30:17.896
Solving this issue now is a

00:30:17.896 --> 00:30:20.566
matter of balancing performance,

00:30:21.006 --> 00:30:22.736
quality, and correctness, but

00:30:22.736 --> 00:30:23.926
you have demonstrated how you

00:30:23.926 --> 00:30:25.036
can use GPU counters [inaudible]

00:30:25.036 --> 00:30:27.376
the GPU Frame Debugger, to help

00:30:27.376 --> 00:30:30.196
you investigate, analyze, and

00:30:30.196 --> 00:30:32.016
verify any capture information

00:30:32.016 --> 00:30:34.246
-- any performance information

00:30:34.246 --> 00:30:35.256
that you have in your captures.

00:30:35.676 --> 00:30:37.056
And now, I hand it back to my

00:30:37.056 --> 00:30:37.586
colleague, Seth.

00:30:38.516 --> 00:30:43.500
[ Applause ]

00:30:48.386 --> 00:30:48.976
>> Thank you, Jose.

00:30:50.696 --> 00:30:52.756
So that is GPU Counter

00:30:52.756 --> 00:30:53.346
Profiling.

00:30:53.966 --> 00:30:54.926
Like all the new features we

00:30:54.926 --> 00:30:56.456
talked about today, it's the

00:30:56.456 --> 00:30:58.676
ultimate joy in Xcode Beta 9,

00:30:59.166 --> 00:31:00.716
and it's available for all Metal

00:31:00.716 --> 00:31:01.906
capable GPUs.

00:31:02.656 --> 00:31:04.356
You will find that more recent

00:31:04.356 --> 00:31:05.586
GPUs have more counters

00:31:05.586 --> 00:31:07.676
available due to the more modern

00:31:07.986 --> 00:31:10.086
nature of the GPU, but there's

00:31:10.086 --> 00:31:11.976
still a rich and very usable set

00:31:11.976 --> 00:31:13.616
available for all GPUs.

00:31:14.026 --> 00:31:16.616
However, we would love to hear

00:31:16.616 --> 00:31:17.936
feedback from you if you feel

00:31:17.936 --> 00:31:18.946
there's particular counters that

00:31:18.946 --> 00:31:19.696
were unexposed that would be

00:31:19.696 --> 00:31:22.156
particularly valuable, you know,

00:31:22.426 --> 00:31:24.606
please drop by the lab, or

00:31:24.606 --> 00:31:26.046
[inaudible] and we'll be happy

00:31:26.046 --> 00:31:26.956
to investigate.

00:31:27.386 --> 00:31:28.986
So what have we talked about

00:31:28.986 --> 00:31:29.226
today?

00:31:29.486 --> 00:31:30.586
We've talked about some great

00:31:30.586 --> 00:31:31.906
enhancements to the Metal Frame

00:31:31.906 --> 00:31:33.676
Debugger, with support for pixel

00:31:33.676 --> 00:31:35.846
inspection, inspecting Vertex

00:31:36.246 --> 00:31:39.256
Shader outputs, rich filtering,

00:31:39.776 --> 00:31:42.186
better capture support, better

00:31:42.186 --> 00:31:44.196
capture performance, and Xcode

00:31:44.196 --> 00:31:45.696
Metal Quick Looks.

00:31:46.216 --> 00:31:49.206
We've talked about support for

00:31:49.206 --> 00:31:50.586
debugging and profiling VR

00:31:50.586 --> 00:31:53.506
applications in Metal Tray

00:31:53.506 --> 00:31:54.876
Debugger, and Metal System

00:31:54.876 --> 00:31:55.186
Trays.

00:31:57.356 --> 00:31:59.986
We've talked about Metal

00:32:00.056 --> 00:32:01.726
Pipeline Statistics, giving you

00:32:01.726 --> 00:32:03.236
a direct line to the GPU

00:32:03.236 --> 00:32:04.316
compiler for performance

00:32:04.316 --> 00:32:04.916
information.

00:32:06.696 --> 00:32:08.516
And we've introduced GPU Counter

00:32:08.516 --> 00:32:11.586
Profiling, giving you unheralded

00:32:11.586 --> 00:32:13.626
access to GPU Performance

00:32:13.626 --> 00:32:17.346
Counter Data in Metal.

00:32:17.626 --> 00:32:19.866
For more information, check out

00:32:19.866 --> 00:32:20.486
the website.

00:32:22.166 --> 00:32:23.846
Code is 607.

00:32:23.846 --> 00:32:28.276
I did want to call out a couple

00:32:28.276 --> 00:32:29.956
of other sessions.

00:32:30.316 --> 00:32:31.756
If you didn't catch either the

00:32:31.756 --> 00:32:33.946
Introducing Metal 2, or VR With

00:32:33.946 --> 00:32:35.716
Metal 2 sessions earlier on this

00:32:35.716 --> 00:32:38.186
week, it's highly worth going

00:32:38.186 --> 00:32:39.896
and checking out the video, even

00:32:39.896 --> 00:32:41.606
if you did see them, it's still

00:32:41.606 --> 00:32:42.736
worth checking out the videos.

00:32:43.066 --> 00:32:45.246
And coming up later this

00:32:45.246 --> 00:32:46.446
afternoon, there is a great

00:32:46.446 --> 00:32:47.706
session on using Metal 2 for

00:32:47.706 --> 00:32:49.856
Compute, in Grand Ballroom A, at

00:32:49.926 --> 00:32:50.866
10 past 4.

00:32:51.386 --> 00:32:52.996
And that's it.

00:32:52.996 --> 00:32:54.216
Thanks for coming.

00:32:54.556 --> 00:32:56.086
Have a great remainder of your

00:32:56.146 --> 00:32:58.436
WWDC 17 and enjoy the bash.

00:32:58.436 --> 00:32:58.776
Thank you.

00:32:59.016 --> 00:33:00.000
[ Applause ]
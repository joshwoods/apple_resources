WEBVTT

00:00:22.736 --> 00:00:23.106
>> All right.

00:00:25.106 --> 00:00:27.386
Now -- thank you very much and

00:00:27.546 --> 00:00:27.986
welcome.

00:00:28.066 --> 00:00:29.446
And my name is David Hayward,

00:00:29.446 --> 00:00:30.736
and I'm really excited to talk

00:00:30.736 --> 00:00:32.046
to you today about all the great

00:00:32.046 --> 00:00:33.826
new features and functionality

00:00:33.826 --> 00:00:35.556
we've added to Core Image on

00:00:35.756 --> 00:00:37.786
iOS, macOS, and tvOS.

00:00:39.926 --> 00:00:41.936
We have a great agenda today.

00:00:42.036 --> 00:00:43.496
I'll be giving a brief overview

00:00:43.496 --> 00:00:45.546
of Core Image and a summary of

00:00:45.546 --> 00:00:46.906
the highlights of what we've

00:00:46.906 --> 00:00:47.586
added this year.

00:00:48.376 --> 00:00:49.496
Then after that we'll spend the

00:00:49.496 --> 00:00:51.266
rest of the hour going into deep

00:00:51.266 --> 00:00:53.286
details on all our new APIs and

00:00:53.496 --> 00:00:54.096
new features.

00:00:54.986 --> 00:00:56.196
So, with that in mind, let's

00:00:56.466 --> 00:00:57.086
start going in.

00:00:58.986 --> 00:01:00.336
So a brief overview of Core

00:01:00.336 --> 00:01:00.666
Image.

00:01:01.546 --> 00:01:02.886
In a nutshell, Core Image

00:01:02.886 --> 00:01:03.966
provides a simple

00:01:03.966 --> 00:01:05.926
high-performance API to apply

00:01:06.006 --> 00:01:06.986
filters to images.

00:01:07.436 --> 00:01:09.026
These images can be used to

00:01:09.526 --> 00:01:10.906
adjust the color, adjust the

00:01:10.906 --> 00:01:12.916
geometry, or perform complex

00:01:12.996 --> 00:01:14.516
reductions or convolutions.

00:01:16.116 --> 00:01:18.406
There are several tricks that

00:01:18.546 --> 00:01:19.916
Core Image uses to get the best

00:01:19.956 --> 00:01:21.876
performance out of this because

00:01:21.876 --> 00:01:24.696
these filters can be combined in

00:01:24.696 --> 00:01:25.966
either simple chains like this

00:01:25.966 --> 00:01:27.696
example here or in complex

00:01:27.696 --> 00:01:28.176
graphs.

00:01:28.716 --> 00:01:32.476
One of the tricks Core Image

00:01:32.556 --> 00:01:34.106
does to get great performance is

00:01:34.106 --> 00:01:36.186
to support automatic tiling, and

00:01:36.416 --> 00:01:38.646
this allows us to -- if an image

00:01:38.646 --> 00:01:40.356
is too big or there's too much

00:01:40.356 --> 00:01:41.136
memory that's going to be

00:01:41.136 --> 00:01:42.406
required to render a render

00:01:42.406 --> 00:01:44.556
graph, we can reduce our memory

00:01:44.616 --> 00:01:44.976
footprint.

00:01:48.846 --> 00:01:50.326
Another feature of this tiling,

00:01:50.356 --> 00:01:51.976
which it means that if we're

00:01:51.976 --> 00:01:53.336
only rendering part of an image

00:01:53.776 --> 00:01:54.996
we can be very efficient and

00:01:54.996 --> 00:01:56.926
only load the portion of the

00:01:56.926 --> 00:01:58.046
input image that's needed.

00:01:58.946 --> 00:02:00.216
So these are great performance

00:02:00.216 --> 00:02:01.506
things that you get for free by

00:02:01.506 --> 00:02:02.336
using Core Image.

00:02:02.896 --> 00:02:03.866
Also when you're writing your

00:02:03.866 --> 00:02:06.286
own kernels in Core Image, our

00:02:06.286 --> 00:02:08.086
language extensions provide you

00:02:08.086 --> 00:02:09.136
the ability to get this

00:02:09.136 --> 00:02:10.455
functionality for free with very

00:02:10.455 --> 00:02:12.146
little difficulty.

00:02:12.646 --> 00:02:15.976
Another thing to keep in mind is

00:02:15.976 --> 00:02:17.136
that all the filters in Core

00:02:17.136 --> 00:02:19.566
Image may be based on one or

00:02:20.456 --> 00:02:21.546
more kernels, either our

00:02:21.546 --> 00:02:22.826
built-in kernels or custom

00:02:22.826 --> 00:02:23.326
kernels.

00:02:23.956 --> 00:02:25.166
And another trick Core Image

00:02:25.166 --> 00:02:27.356
uses to get great performance is

00:02:27.356 --> 00:02:29.656
to concatenate these kernels

00:02:29.686 --> 00:02:30.516
into programs.

00:02:30.916 --> 00:02:32.316
This allows Core Image to reduce

00:02:32.356 --> 00:02:33.286
the number of intermediate

00:02:33.286 --> 00:02:35.066
buffers, which allows us to

00:02:35.066 --> 00:02:36.526
reduce our memory requirements

00:02:36.526 --> 00:02:37.966
and also improves image quality.

00:02:41.216 --> 00:02:42.426
So with that introduction

00:02:42.426 --> 00:02:43.826
underway, I'm going to give a

00:02:43.826 --> 00:02:45.106
brief description of what we've

00:02:45.106 --> 00:02:46.366
added to Core Image this year.

00:02:46.626 --> 00:02:47.566
It falls into three main

00:02:47.566 --> 00:02:48.216
categories.

00:02:48.626 --> 00:02:49.506
First, of course, is

00:02:49.506 --> 00:02:50.096
performance.

00:02:50.146 --> 00:02:51.136
As always, this is something

00:02:51.136 --> 00:02:52.116
that's very important to Core

00:02:52.116 --> 00:02:53.446
Image, and we've added some

00:02:53.576 --> 00:02:55.756
enhancements in this area to

00:02:55.756 --> 00:02:57.086
give your application the best

00:02:57.086 --> 00:02:57.626
performance.

00:02:58.196 --> 00:03:00.926
Specifically -- the next thing

00:03:00.926 --> 00:03:01.766
I'd like to mention is that

00:03:01.766 --> 00:03:04.146
we've also spent a lot of time

00:03:04.146 --> 00:03:06.976
this year enhancing Core Image

00:03:06.976 --> 00:03:08.026
to give you, the developer,

00:03:08.026 --> 00:03:09.396
better information about how

00:03:09.396 --> 00:03:10.636
Core Image works internally.

00:03:11.166 --> 00:03:13.086
All of these optimizations we do

00:03:13.086 --> 00:03:14.336
internally that I alluded to in

00:03:14.336 --> 00:03:15.896
the previous slides, you can now

00:03:15.896 --> 00:03:17.996
see what we're doing to achieve

00:03:17.996 --> 00:03:18.306
these.

00:03:20.156 --> 00:03:21.676
Thirdly, we've added a lot of

00:03:21.676 --> 00:03:23.186
functionality, and this is to

00:03:23.186 --> 00:03:24.686
allow your applications to get

00:03:24.856 --> 00:03:26.016
the best access to all the new

00:03:26.016 --> 00:03:27.116
features on our platform.

00:03:28.856 --> 00:03:30.386
So a little bit more detail on

00:03:30.386 --> 00:03:30.616
these.

00:03:30.616 --> 00:03:32.336
In the area of performance, Core

00:03:32.336 --> 00:03:33.856
Image now allows you to write CI

00:03:33.966 --> 00:03:35.116
kernels directly in Metal.

00:03:35.116 --> 00:03:38.086
And we also have a new API to

00:03:38.086 --> 00:03:39.696
allow you to better render to

00:03:39.696 --> 00:03:40.516
destinations.

00:03:40.596 --> 00:03:41.616
We'll be talking about this in

00:03:41.616 --> 00:03:42.886
much more detail later on in the

00:03:42.886 --> 00:03:43.566
presentation.

00:03:44.596 --> 00:03:46.856
In the area of information, we

00:03:46.856 --> 00:03:48.086
have a new API that allows you

00:03:48.086 --> 00:03:50.116
to get information about what

00:03:50.116 --> 00:03:51.196
Core Image did for a given

00:03:51.196 --> 00:03:51.556
render.

00:03:52.106 --> 00:03:53.556
And also, we have some great new

00:03:53.556 --> 00:03:54.956
Xcode Quick Look support, which

00:03:54.956 --> 00:03:55.496
we'll show you.

00:03:56.866 --> 00:03:57.606
And in the area of

00:03:57.606 --> 00:03:58.676
functionality, we have some

00:03:58.676 --> 00:03:59.676
great new stuff as well.

00:03:59.676 --> 00:04:00.766
We have a new collection of

00:04:00.816 --> 00:04:02.766
filters, new barcode support,

00:04:03.066 --> 00:04:05.746
and also support for editing

00:04:05.746 --> 00:04:05.966
depth.

00:04:06.606 --> 00:04:08.576
I want to call out the session

00:04:08.576 --> 00:04:10.286
that occurred earlier today on

00:04:10.426 --> 00:04:11.496
image editing with depth.

00:04:11.496 --> 00:04:12.886
If you didn't see it, you should

00:04:12.886 --> 00:04:14.006
definitely go back and watch it.

00:04:14.006 --> 00:04:15.846
It goes into great detail about

00:04:15.846 --> 00:04:16.856
how to use Core Image to edit

00:04:16.856 --> 00:04:16.976
depth.

00:04:20.726 --> 00:04:22.116
So now let me talk in more

00:04:22.116 --> 00:04:23.306
detail about the new filters

00:04:23.306 --> 00:04:24.476
that we've added this release.

00:04:25.236 --> 00:04:27.686
We now have 196 built-in

00:04:27.686 --> 00:04:30.456
filters, and we've added some

00:04:30.456 --> 00:04:32.606
that have been -- are great new

00:04:32.606 --> 00:04:33.196
additions.

00:04:33.626 --> 00:04:34.816
For example, some of these are

00:04:34.816 --> 00:04:36.586
very useful when you're working

00:04:36.586 --> 00:04:37.256
with depth data.

00:04:37.736 --> 00:04:39.036
For example, we have convenience

00:04:39.036 --> 00:04:40.366
filters for converting between

00:04:40.366 --> 00:04:41.356
depth and disparity.

00:04:41.946 --> 00:04:43.366
We also have morphological

00:04:43.366 --> 00:04:44.966
operations, which allows you to

00:04:45.306 --> 00:04:46.986
erode and dilate an image, which

00:04:46.986 --> 00:04:48.936
is useful for manipulating depth

00:04:48.936 --> 00:04:49.606
masks.

00:04:50.266 --> 00:04:52.116
We also have convenience filters

00:04:52.116 --> 00:04:53.376
that allow you to combine an

00:04:53.376 --> 00:04:54.806
image with two different color

00:04:54.806 --> 00:04:56.186
cubes based on the depth of an

00:04:56.186 --> 00:04:56.526
image.

00:04:58.036 --> 00:04:59.396
I also want to call out a great

00:04:59.396 --> 00:05:00.706
new filter which we talk about

00:05:00.706 --> 00:05:01.876
in the previous -- in the

00:05:01.876 --> 00:05:03.166
editing session called

00:05:03.166 --> 00:05:04.846
CIDepthBlurEffect, which allows

00:05:04.846 --> 00:05:06.436
your application to get access

00:05:06.436 --> 00:05:08.516
to the great depth blur effect

00:05:08.566 --> 00:05:10.286
that we have in our camera and

00:05:10.286 --> 00:05:11.176
photos application.

00:05:13.016 --> 00:05:14.976
Again, I highly recommend you

00:05:14.976 --> 00:05:16.836
watch the image editing and

00:05:16.836 --> 00:05:18.416
depth session that was recorded

00:05:18.416 --> 00:05:19.696
earlier today.

00:05:21.336 --> 00:05:23.226
We also have several other new

00:05:23.226 --> 00:05:24.736
filters based on popular

00:05:24.736 --> 00:05:25.286
requests.

00:05:25.506 --> 00:05:26.826
We have a filter now that allows

00:05:26.826 --> 00:05:28.026
you to generate an image from

00:05:28.026 --> 00:05:29.016
text, which is great for

00:05:29.016 --> 00:05:30.506
allowing you to add watermarks

00:05:30.506 --> 00:05:32.446
to video or other textual

00:05:32.446 --> 00:05:32.906
overlays.

00:05:33.546 --> 00:05:34.886
We have a filter that allows you

00:05:34.886 --> 00:05:36.136
to compare two images in

00:05:36.136 --> 00:05:37.946
LabDeltaE space, which is great

00:05:38.006 --> 00:05:39.666
for seeing if your results are

00:05:39.666 --> 00:05:41.146
what you expect or to give a

00:05:41.146 --> 00:05:42.486
user information about how much

00:05:42.486 --> 00:05:43.536
an image might have changed.

00:05:44.666 --> 00:05:47.576
We also have a new bicubic

00:05:47.576 --> 00:05:49.216
upsample, or downsample filter,

00:05:49.646 --> 00:05:51.666
which is great for a variety of

00:05:51.666 --> 00:05:52.196
purposes.

00:05:53.006 --> 00:05:54.126
We also have a new way of

00:05:54.126 --> 00:05:55.306
generating barcodes, which we'll

00:05:55.306 --> 00:05:56.586
talk about in more detail later

00:05:56.586 --> 00:05:57.336
in the presentation.

00:05:59.416 --> 00:06:00.676
Lastly, in the area of filters,

00:06:00.676 --> 00:06:01.716
we have some filters that have

00:06:02.196 --> 00:06:03.376
been improved since our last

00:06:03.376 --> 00:06:03.696
release.

00:06:03.696 --> 00:06:04.756
We have several of the blend

00:06:04.876 --> 00:06:06.396
mode filters -- now behave more

00:06:06.836 --> 00:06:07.946
like expectations.

00:06:07.946 --> 00:06:10.166
And we've also improved greatly

00:06:10.346 --> 00:06:11.876
the quality of our demosaic and

00:06:11.876 --> 00:06:12.986
noise reduction filters that are

00:06:12.986 --> 00:06:14.276
part of our RAW pipeline.

00:06:14.686 --> 00:06:17.056
So, as we release new cameras,

00:06:17.056 --> 00:06:17.926
we'll be getting -- or support

00:06:17.926 --> 00:06:18.816
for new cameras, you'll see the

00:06:18.816 --> 00:06:19.976
improvements of that.

00:06:24.506 --> 00:06:26.446
So that's new filters.

00:06:26.516 --> 00:06:28.836
I'd like to bring Tony up to the

00:06:28.836 --> 00:06:29.976
stage who'll be talking in

00:06:29.976 --> 00:06:32.156
detail about how to write

00:06:32.336 --> 00:06:33.456
kernels directly in Metal, which

00:06:33.456 --> 00:06:33.976
is a great new feature.

00:06:34.516 --> 00:06:39.416
[ Applause ]

00:06:39.916 --> 00:06:40.246
>> All right.

00:06:40.246 --> 00:06:41.506
Thank you David.

00:06:42.036 --> 00:06:42.856
Good afternoon everyone.

00:06:43.006 --> 00:06:44.446
My name is Tony, and I'm really

00:06:44.446 --> 00:06:45.636
excited to tell you about this

00:06:45.636 --> 00:06:46.936
great new feature we've added to

00:06:46.936 --> 00:06:47.436
Core Image.

00:06:48.036 --> 00:06:49.426
So let's get right to it.

00:06:50.036 --> 00:06:51.176
So first, let's put this in a

00:06:51.176 --> 00:06:52.316
little bit of context.

00:06:52.456 --> 00:06:54.006
If you refer back to this simple

00:06:54.006 --> 00:06:55.106
filter graph that you saw

00:06:55.106 --> 00:06:55.556
earlier.

00:06:55.556 --> 00:06:57.226
What we're talking about now are

00:06:57.226 --> 00:06:58.636
these kernels that you see here

00:06:58.636 --> 00:07:00.356
at the bottom, which allow you

00:07:00.356 --> 00:07:01.566
to implement your very own

00:07:01.566 --> 00:07:03.116
custom code that will describe

00:07:03.116 --> 00:07:04.536
exactly how you want the pixel

00:07:04.536 --> 00:07:06.006
to be processed on the GPU.

00:07:06.606 --> 00:07:09.546
So previously these kernels were

00:07:09.546 --> 00:07:10.566
written in the CIKernel

00:07:10.566 --> 00:07:12.496
Language, which was the shading

00:07:12.496 --> 00:07:14.946
language based on GLSL, but it

00:07:14.946 --> 00:07:16.586
also provided some extensions

00:07:16.906 --> 00:07:18.466
that allows Core Image to enable

00:07:18.466 --> 00:07:20.206
automatic tiling and subregion

00:07:20.206 --> 00:07:20.586
rendering.

00:07:22.046 --> 00:07:23.176
For example, we had a function

00:07:23.176 --> 00:07:24.286
called destCoord that lets you

00:07:24.286 --> 00:07:25.456
access the coordinate of the

00:07:25.526 --> 00:07:26.486
destination that you are about

00:07:26.486 --> 00:07:28.066
to render to regardless of

00:07:28.066 --> 00:07:28.986
whether you're just rendering a

00:07:28.986 --> 00:07:30.486
subportion of the output or if

00:07:30.486 --> 00:07:31.566
the output image is tiled.

00:07:33.026 --> 00:07:34.276
We also have a couple of

00:07:34.276 --> 00:07:34.866
functions called

00:07:34.866 --> 00:07:37.196
samplerTransform and sample that

00:07:37.196 --> 00:07:38.346
let you sample from an input

00:07:38.346 --> 00:07:40.036
image regardless of whether the

00:07:40.036 --> 00:07:41.066
input image is tiled.

00:07:41.536 --> 00:07:43.436
So again, as David mentioned

00:07:43.436 --> 00:07:44.556
earlier, this provides a nice

00:07:44.556 --> 00:07:46.086
abstraction to tiling so that

00:07:46.086 --> 00:07:46.926
you don't have to worry about

00:07:46.926 --> 00:07:48.346
that when writing your kernels.

00:07:50.696 --> 00:07:52.056
So once these kernels are

00:07:52.056 --> 00:07:53.006
written, they are then

00:07:53.006 --> 00:07:54.786
translated, concatenated

00:07:54.786 --> 00:07:55.946
together as much as possible

00:07:55.946 --> 00:07:57.476
with other kernels, and then

00:07:57.476 --> 00:07:59.216
compiled at runtime to either

00:07:59.216 --> 00:08:00.456
Metal or GLSL.

00:08:01.686 --> 00:08:03.576
Now for a rich language like

00:08:03.576 --> 00:08:05.786
Metal, the compilation phase can

00:08:05.786 --> 00:08:07.146
actually take quite a long time

00:08:07.146 --> 00:08:07.576
at runtime.

00:08:07.576 --> 00:08:09.356
And, in fact, in the worst case,

00:08:09.356 --> 00:08:10.446
if you're just rendering a very

00:08:10.446 --> 00:08:12.086
small input image - sorry,

00:08:12.086 --> 00:08:13.456
rendering a very small image or

00:08:13.456 --> 00:08:14.546
a relatively simple filter

00:08:14.546 --> 00:08:16.236
graph, most of that time could

00:08:16.236 --> 00:08:17.656
actually be spent compiling

00:08:17.656 --> 00:08:18.776
versus the actual rendering.

00:08:19.386 --> 00:08:21.646
So to show you an example of

00:08:21.646 --> 00:08:23.786
that, here's a case where on the

00:08:23.786 --> 00:08:25.206
very first render before any of

00:08:25.206 --> 00:08:26.606
the compilation has been cached,

00:08:27.146 --> 00:08:28.116
you can see there's a lot of

00:08:28.116 --> 00:08:29.376
time spent compiling versus

00:08:29.376 --> 00:08:29.796
rendering.

00:08:29.946 --> 00:08:31.606
So if we step through these

00:08:32.155 --> 00:08:33.706
stage by stage, the first step

00:08:33.706 --> 00:08:35.126
is to translate the CIKernels

00:08:35.126 --> 00:08:35.996
shown in blue.

00:08:36.535 --> 00:08:37.476
And the second stage is to

00:08:37.476 --> 00:08:38.726
concatenate the CIKernels.

00:08:39.035 --> 00:08:40.796
And then we go through a phase

00:08:40.796 --> 00:08:42.346
to compile the CIKernels to an

00:08:42.346 --> 00:08:43.616
intermediate representation,

00:08:43.756 --> 00:08:45.046
which is independent of the

00:08:45.046 --> 00:08:45.416
device.

00:08:45.486 --> 00:08:47.026
And then there's a final stage

00:08:47.026 --> 00:08:50.956
to actually compile that IR to

00:08:50.956 --> 00:08:53.386
GPU code to be executed on the

00:08:53.386 --> 00:08:53.906
GPU.

00:08:55.216 --> 00:08:56.646
So the problem here is that

00:08:56.646 --> 00:08:59.246
concatenating CIKernels is

00:08:59.246 --> 00:09:00.276
something that has been done

00:09:00.276 --> 00:09:04.366
dynamically at runtime, so what

00:09:04.366 --> 00:09:06.166
if we were to allow that stage

00:09:06.166 --> 00:09:07.936
to happen after the compilation?

00:09:08.876 --> 00:09:10.686
So what that allows us to do is

00:09:10.686 --> 00:09:12.076
hoist up that really expensive

00:09:12.076 --> 00:09:14.196
compilation at build-time and

00:09:14.196 --> 00:09:15.676
therefore leaving behind only

00:09:15.676 --> 00:09:17.136
the work that needs to be done

00:09:17.486 --> 00:09:18.176
at runtime.

00:09:18.806 --> 00:09:20.166
So, as you can see, this is now

00:09:20.166 --> 00:09:21.666
a much more efficient use of the

00:09:21.666 --> 00:09:23.876
CPU, not to mention lower power

00:09:23.876 --> 00:09:24.426
consumption.

00:09:24.996 --> 00:09:27.216
So I'm pleased to say that this

00:09:27.216 --> 00:09:29.256
is now possible in Core Image

00:09:29.256 --> 00:09:30.536
and that's by writing CIKernels

00:09:30.536 --> 00:09:31.416
directly in Metal.

00:09:31.916 --> 00:09:34.146
And to make this happen required

00:09:34.146 --> 00:09:35.496
some really close collaboration

00:09:35.496 --> 00:09:36.656
with both the Metal Framework

00:09:36.656 --> 00:09:37.866
Team and the Metal Compiler

00:09:37.866 --> 00:09:38.026
Team.

00:09:38.026 --> 00:09:39.386
And we think this is going to

00:09:39.386 --> 00:09:40.696
open up doors to some really

00:09:40.696 --> 00:09:41.716
exciting new opportunities.

00:09:43.326 --> 00:09:44.256
But first, let me just highlight

00:09:44.256 --> 00:09:45.546
some of the key benefits that

00:09:45.546 --> 00:09:47.176
you're already getting today.

00:09:48.276 --> 00:09:51.056
So, as you saw earlier, now the

00:09:51.056 --> 00:09:52.466
CIKernels can be precompiled

00:09:52.466 --> 00:09:54.526
offline at build-time.

00:09:54.666 --> 00:09:55.956
And along with that, you can get

00:09:55.956 --> 00:09:57.056
some really nice error

00:09:57.056 --> 00:09:57.836
diagnostics.

00:09:58.156 --> 00:09:59.266
So if you had some typo or a

00:09:59.266 --> 00:10:00.376
mistake in your kernel, you can

00:10:00.376 --> 00:10:01.816
see that directly in Xcode,

00:10:02.236 --> 00:10:03.636
without having to wait for the

00:10:03.636 --> 00:10:05.336
runtime to detect them.

00:10:06.316 --> 00:10:08.236
Second is now you have access to

00:10:08.236 --> 00:10:09.596
much more modern language

00:10:09.596 --> 00:10:11.456
features since Metal is a

00:10:11.456 --> 00:10:12.796
relatively new language that was

00:10:12.796 --> 00:10:13.766
based on C++.

00:10:13.836 --> 00:10:17.536
And I want to stress that with

00:10:17.736 --> 00:10:19.106
writing CIKernels in Metal, you

00:10:19.316 --> 00:10:20.976
still get all the benefits such

00:10:20.976 --> 00:10:22.496
as concatenation and tiling,

00:10:22.596 --> 00:10:23.646
which has been the cornerstone

00:10:23.646 --> 00:10:24.836
of our Core Image framework for

00:10:24.836 --> 00:10:25.246
many years.

00:10:25.586 --> 00:10:26.776
So nothing is compromised by

00:10:26.776 --> 00:10:28.356
writing CIKernels in this new

00:10:28.356 --> 00:10:28.606
way.

00:10:29.166 --> 00:10:31.346
And furthermore, these new

00:10:31.346 --> 00:10:33.796
CIKernels in Metal can also be

00:10:33.796 --> 00:10:34.756
mixed with traditional

00:10:34.756 --> 00:10:35.386
CIKernels.

00:10:35.686 --> 00:10:37.496
So [inaudible] can contain

00:10:37.496 --> 00:10:39.656
either traditional kernels or

00:10:39.656 --> 00:10:40.616
kernels written in Metal.

00:10:40.876 --> 00:10:42.466
And that allows this feature to

00:10:42.766 --> 00:10:45.436
be maximally compatible with

00:10:45.566 --> 00:10:46.766
your existing application.

00:10:47.336 --> 00:10:50.036
And, as you would expect, this

00:10:50.196 --> 00:10:51.316
feature is supported in a wide

00:10:51.316 --> 00:10:52.896
variety of platforms, namely iOS

00:10:52.896 --> 00:10:56.066
for A8 or newer devices, as well

00:10:56.066 --> 00:10:59.506
as macOS and tvOS.

00:10:59.686 --> 00:11:01.136
So now let's take a look at how

00:11:01.136 --> 00:11:02.516
we go about creating these Metal

00:11:02.516 --> 00:11:03.136
CIKernels.

00:11:03.656 --> 00:11:05.886
The first step is to write your

00:11:05.886 --> 00:11:07.466
CIKernel in a Metal shader file.

00:11:09.316 --> 00:11:11.366
Then once you have that CIKernel

00:11:11.366 --> 00:11:12.946
implemented, the second step is

00:11:12.976 --> 00:11:14.236
to compile and link the Metal

00:11:14.236 --> 00:11:16.296
shader file in order to generate

00:11:16.296 --> 00:11:17.616
a Metal library that can then be

00:11:17.616 --> 00:11:18.656
loaded at runtime.

00:11:19.236 --> 00:11:21.696
And then a final step is to just

00:11:22.266 --> 00:11:23.996
initialize the CIKernel with any

00:11:23.996 --> 00:11:25.066
function from that Metal

00:11:25.066 --> 00:11:25.446
library.

00:11:25.446 --> 00:11:28.926
So let's take a closer look at

00:11:28.926 --> 00:11:29.916
the first step, writing a

00:11:29.916 --> 00:11:32.466
CIKernel in Metal.

00:11:33.216 --> 00:11:34.286
So to do that, I'd like to

00:11:34.286 --> 00:11:35.266
introduce you to our new

00:11:35.266 --> 00:11:36.586
CIKernal Metal library.

00:11:37.086 --> 00:11:38.346
And what that is is basically a

00:11:38.346 --> 00:11:40.046
header file that contains our

00:11:40.046 --> 00:11:41.806
CIKernel extensions to the Metal

00:11:41.806 --> 00:11:42.616
shading language.

00:11:42.936 --> 00:11:44.876
So namely we have some new data

00:11:44.876 --> 00:11:47.536
types, such as destination,

00:11:47.636 --> 00:11:48.906
sampler, and sample.

00:11:49.536 --> 00:11:51.216
Destination lets you access all

00:11:51.216 --> 00:11:52.386
the information that you need

00:11:52.706 --> 00:11:54.506
that pertains to the output.

00:11:55.046 --> 00:11:56.506
And sampler lets you access all

00:11:56.506 --> 00:11:57.846
the information that pertains to

00:11:57.846 --> 00:11:58.556
the input image.

00:11:59.136 --> 00:12:00.916
And sample is a representation

00:12:00.916 --> 00:12:02.866
of a single-color sample from an

00:12:02.866 --> 00:12:03.476
input image.

00:12:04.766 --> 00:12:05.856
And along with these types we

00:12:05.856 --> 00:12:07.136
also have some convenience

00:12:07.136 --> 00:12:08.336
functions that are very useful

00:12:08.336 --> 00:12:09.256
for image processing.

00:12:10.666 --> 00:12:11.776
For example, you can do

00:12:11.776 --> 00:12:13.846
premulitply and unpremultiply,

00:12:13.926 --> 00:12:14.986
as well as some color

00:12:14.986 --> 00:12:16.316
conversions between different

00:12:16.466 --> 00:12:17.196
color spaces.

00:12:17.616 --> 00:12:19.816
So these new extensions are

00:12:20.196 --> 00:12:21.366
semantically the same as they

00:12:21.366 --> 00:12:22.586
used to be in the CIKernel

00:12:22.586 --> 00:12:23.056
language.

00:12:23.536 --> 00:12:25.686
There's just some slight syntax

00:12:25.876 --> 00:12:27.496
differences that pertains to the

00:12:27.496 --> 00:12:29.116
destination and sampler types,

00:12:29.836 --> 00:12:30.566
so let me show you that in a

00:12:30.566 --> 00:12:31.346
little bit more detail.

00:12:32.096 --> 00:12:34.426
So here's a snippet of what our

00:12:34.556 --> 00:12:35.786
CIKernel Metal library looks

00:12:35.786 --> 00:12:35.976
like.

00:12:36.596 --> 00:12:38.706
It is called CIKernelMetalLib.h,

00:12:39.276 --> 00:12:40.686
and all our extensions are

00:12:40.806 --> 00:12:42.316
declared inside a namespace

00:12:42.316 --> 00:12:43.906
called coreimage to avoid any

00:12:43.906 --> 00:12:44.746
conflicts with Metal.

00:12:45.326 --> 00:12:47.386
So the first step that we have

00:12:47.386 --> 00:12:48.796
defined is called a destination

00:12:48.916 --> 00:12:50.196
and it has a method that lets

00:12:50.196 --> 00:12:51.456
you access the coordinate of the

00:12:51.456 --> 00:12:52.106
destination.

00:12:53.076 --> 00:12:54.126
Previously, if you were writing

00:12:54.176 --> 00:12:55.676
CIKernels in the CIKernel

00:12:55.676 --> 00:12:57.776
language, you would have done

00:12:57.776 --> 00:12:59.496
that via a global function

00:12:59.496 --> 00:13:00.276
called destCoord.

00:13:00.606 --> 00:13:01.346
But now, if you're writing

00:13:01.346 --> 00:13:02.926
kernels in Metal, you need to

00:13:02.926 --> 00:13:04.616
declare this type as an argument

00:13:04.616 --> 00:13:05.646
to your kernel in order to

00:13:05.646 --> 00:13:06.506
access that method.

00:13:07.046 --> 00:13:09.396
And then the second type we have

00:13:09.396 --> 00:13:10.636
to find is the sampler.

00:13:11.136 --> 00:13:12.226
And this has all the same

00:13:12.226 --> 00:13:13.866
methods that used to exist as

00:13:13.866 --> 00:13:15.326
global functions, but they are

00:13:15.326 --> 00:13:17.326
now implemented as member

00:13:17.326 --> 00:13:18.656
functions on the sampler type.

00:13:19.226 --> 00:13:22.436
So to give you a nice summary of

00:13:22.436 --> 00:13:23.986
all that, here's a table that

00:13:23.986 --> 00:13:25.496
shows you the syntax that used

00:13:25.496 --> 00:13:28.166
to exist in CIKernel language

00:13:28.166 --> 00:13:29.796
versus the syntax that is now

00:13:29.796 --> 00:13:30.996
available in Metal.

00:13:31.596 --> 00:13:32.416
And, as you can see, in the

00:13:32.416 --> 00:13:34.446
CIKernel language, those are all

00:13:34.446 --> 00:13:35.636
implemented as global functions,

00:13:35.756 --> 00:13:37.176
but now with Metal, those are

00:13:37.176 --> 00:13:38.616
all member functions on their

00:13:38.616 --> 00:13:39.466
appropriate types.

00:13:40.046 --> 00:13:40.886
So we think that with the new

00:13:40.886 --> 00:13:41.846
syntax they'll allow you to

00:13:41.846 --> 00:13:43.326
write your code to be more

00:13:43.476 --> 00:13:44.816
concise and easier to read.

00:13:46.766 --> 00:13:47.996
But for sake of portability, we

00:13:47.996 --> 00:13:49.546
did include the global sampler

00:13:49.546 --> 00:13:51.336
functions in our header, which

00:13:51.336 --> 00:13:52.886
are merely just wrappers to the

00:13:52.886 --> 00:13:53.506
new syntax.

00:13:53.586 --> 00:13:54.746
So that'll help minimize the

00:13:54.746 --> 00:13:55.856
amount of code changes that you

00:13:55.856 --> 00:13:57.016
need to make if you're importing

00:13:57.016 --> 00:13:58.326
from existing kernels to Metal.

00:13:58.926 --> 00:14:01.786
So now let's take a look at some

00:14:01.786 --> 00:14:03.226
examples of CIKernels in Metal.

00:14:03.316 --> 00:14:04.896
The first one we're going to

00:14:04.966 --> 00:14:06.456
look at is a warp kernel.

00:14:06.626 --> 00:14:08.456
And as with all Metal shaders,

00:14:08.456 --> 00:14:09.156
the first thing you need to

00:14:09.156 --> 00:14:10.756
include is the metal underscore

00:14:10.756 --> 00:14:12.776
stdlib, but for CIKernels you

00:14:12.776 --> 00:14:14.266
need to include our Metal kernel

00:14:14.266 --> 00:14:15.896
library, and that can be done by

00:14:15.896 --> 00:14:17.046
just including an umbrella

00:14:17.096 --> 00:14:20.166
header CoreImage.h. Then the

00:14:20.406 --> 00:14:22.686
next step is to implement all

00:14:22.686 --> 00:14:25.076
your kernels inside the extern C

00:14:25.076 --> 00:14:29.226
enclosure, and what that allows

00:14:29.226 --> 00:14:30.276
is for the kernel to be

00:14:30.276 --> 00:14:31.886
accessible at runtime by name.

00:14:32.956 --> 00:14:35.326
So here we have a simple kernel

00:14:35.326 --> 00:14:36.396
called myWarp.

00:14:36.616 --> 00:14:37.966
And all it takes is a single

00:14:37.966 --> 00:14:39.606
argument, a destination type,

00:14:40.086 --> 00:14:41.246
and from that destination you

00:14:41.246 --> 00:14:42.436
can access the coordinate that

00:14:42.436 --> 00:14:43.936
you're about to render to and

00:14:43.936 --> 00:14:45.206
apply various geometric

00:14:45.206 --> 00:14:46.346
transformations that you want to

00:14:46.346 --> 00:14:46.496
it.

00:14:46.756 --> 00:14:47.906
And then return the result.

00:14:47.906 --> 00:14:50.036
And for sake of comparison,

00:14:50.166 --> 00:14:51.456
here's that same warp kernel

00:14:51.456 --> 00:14:52.586
that was implemented in the

00:14:52.586 --> 00:14:53.546
CIKernel language.

00:14:54.126 --> 00:14:56.276
So you can see they're almost

00:14:56.276 --> 00:14:58.166
identical minus some minor

00:14:58.526 --> 00:14:59.506
syntax differences.

00:14:59.896 --> 00:15:00.886
But semantically they are the

00:15:00.886 --> 00:15:02.306
same, and at the end of the day

00:15:02.306 --> 00:15:04.156
compiled to the exact same GPU

00:15:04.746 --> 00:15:04.846
code.

00:15:06.036 --> 00:15:07.586
The second example here is a

00:15:07.586 --> 00:15:08.246
color kernel.

00:15:08.696 --> 00:15:09.926
And for the most part it looks

00:15:09.926 --> 00:15:11.376
very similar, the only

00:15:11.376 --> 00:15:12.396
difference is now we have a

00:15:12.396 --> 00:15:14.616
kernel called myColor, and what

00:15:14.616 --> 00:15:16.066
it takes is a single sample as

00:15:16.066 --> 00:15:16.436
input.

00:15:16.546 --> 00:15:18.406
From that sample, you can apply

00:15:18.406 --> 00:15:19.836
various color transformations

00:15:19.836 --> 00:15:21.286
that you want on it and again

00:15:21.286 --> 00:15:22.076
return the result.

00:15:23.616 --> 00:15:25.336
Here again is that same color

00:15:25.336 --> 00:15:26.636
kernel implemented in the

00:15:26.696 --> 00:15:27.686
CIKernel language.

00:15:28.226 --> 00:15:31.146
And then the last example I want

00:15:31.146 --> 00:15:32.916
to show you is a general kernel,

00:15:33.466 --> 00:15:35.026
which you can do if you can't

00:15:35.026 --> 00:15:36.286
implement your kernel as either

00:15:36.286 --> 00:15:37.246
a warp or a color.

00:15:37.936 --> 00:15:39.096
And so here we have a kernel

00:15:39.096 --> 00:15:39.906
called myKernel.

00:15:39.906 --> 00:15:41.756
And it takes a single input,

00:15:42.046 --> 00:15:44.006
which is a sampler type, and

00:15:44.006 --> 00:15:44.996
from that sampler, you can

00:15:44.996 --> 00:15:46.516
sample anywhere in the input

00:15:46.516 --> 00:15:48.176
image and take as many samples

00:15:48.176 --> 00:15:48.696
as you need.

00:15:49.256 --> 00:15:50.016
And again, do something

00:15:50.016 --> 00:15:51.306
interesting with it and return

00:15:51.306 --> 00:15:51.776
the result.

00:15:52.946 --> 00:15:54.256
And one more time, here is that

00:15:54.296 --> 00:15:56.686
same CIKernel written in the old

00:15:56.686 --> 00:15:57.636
CIKernal language.

00:15:58.226 --> 00:16:01.776
So now that you have a CIKernel

00:16:01.776 --> 00:16:02.736
implemented in Metal shader

00:16:02.736 --> 00:16:04.306
file, the next step is to

00:16:04.306 --> 00:16:05.556
compile and link the Metal

00:16:05.556 --> 00:16:05.876
shader.

00:16:07.856 --> 00:16:08.726
So, for those who have

00:16:08.726 --> 00:16:10.076
experience writing Metal

00:16:10.076 --> 00:16:11.416
shaders, this build pipeline

00:16:11.416 --> 00:16:13.296
should look very familiar.

00:16:13.726 --> 00:16:14.776
It's basically a two-stage

00:16:14.776 --> 00:16:15.206
process.

00:16:15.536 --> 00:16:17.646
The first one is compiling a

00:16:17.646 --> 00:16:20.086
.metal to a .air file, and then

00:16:20.086 --> 00:16:21.796
the second stage is to link the

00:16:21.796 --> 00:16:23.446
.air file, and package it up in

00:16:23.446 --> 00:16:24.486
a .metallib file.

00:16:25.946 --> 00:16:27.506
The only additional thing you

00:16:27.506 --> 00:16:29.086
need to do here for CIKernels is

00:16:29.086 --> 00:16:30.256
specify some new options.

00:16:31.306 --> 00:16:32.626
The first option you need to

00:16:32.626 --> 00:16:33.926
specify is for the compiler.

00:16:34.116 --> 00:16:35.746
It is called -fcikernel.

00:16:35.776 --> 00:16:38.346
And then the second option is

00:16:38.346 --> 00:16:39.796
for the linker and it's called

00:16:40.366 --> 00:16:40.946
-cikernel.

00:16:40.946 --> 00:16:42.496
Note that there's no f on that

00:16:42.496 --> 00:16:42.876
option.

00:16:43.736 --> 00:16:44.946
And you can do that directly in

00:16:44.986 --> 00:16:47.446
Xcode, and let me show you that

00:16:47.446 --> 00:16:48.836
with a short little video clip

00:16:48.836 --> 00:16:50.086
that illustrates how that can be

00:16:50.086 --> 00:16:50.346
done.

00:16:51.536 --> 00:16:53.876
So for the compiler option, you

00:16:53.876 --> 00:16:54.886
could just look up the Metal

00:16:54.886 --> 00:16:56.386
compiler build options and

00:16:56.386 --> 00:16:59.656
specify -fcikernel directly in

00:16:59.656 --> 00:17:00.976
the other Metal compiler flags.

00:17:01.556 --> 00:17:03.346
And because we don't have a UI

00:17:03.346 --> 00:17:05.326
for linker options to specify

00:17:05.326 --> 00:17:06.246
that, you have to add a

00:17:06.246 --> 00:17:07.336
user-to-find setting.

00:17:08.036 --> 00:17:09.726
And give that setting a key

00:17:09.776 --> 00:17:12.576
called MTLLINKER underscore

00:17:12.576 --> 00:17:15.086
FLAGS and then the value that

00:17:15.086 --> 00:17:16.955
you specify is -cikernel.

00:17:17.036 --> 00:17:19.096
So you just need to set this up

00:17:19.096 --> 00:17:20.126
once for your project.

00:17:20.126 --> 00:17:21.306
And then all the Metal shaders

00:17:21.306 --> 00:17:22.536
that you have in there will be

00:17:22.756 --> 00:17:23.906
automatically compiled with

00:17:23.906 --> 00:17:24.506
these options.

00:17:25.156 --> 00:17:27.226
But if you prefer to do things

00:17:27.306 --> 00:17:28.256
on [inaudible] or in a custom

00:17:28.256 --> 00:17:30.196
scrip, you can also invoke those

00:17:30.226 --> 00:17:32.696
two compiler and linker tools,

00:17:32.796 --> 00:17:32.956
like so.

00:17:36.496 --> 00:17:38.216
So now the last and probably the

00:17:38.216 --> 00:17:40.246
easiest step is to initialize a

00:17:40.326 --> 00:17:42.166
CIKernel with a given function

00:17:42.166 --> 00:17:43.036
from the Metal library.

00:17:43.596 --> 00:17:46.046
And so to do that we have some

00:17:46.046 --> 00:17:47.876
new API on our CIKernel class,

00:17:48.006 --> 00:17:50.416
and they allow you to initialize

00:17:50.416 --> 00:17:51.906
the CIKernel with a given

00:17:51.906 --> 00:17:53.876
function by name as well as a

00:17:53.876 --> 00:17:55.306
Metal library that you can load

00:17:55.526 --> 00:17:56.536
at runtime.

00:17:57.046 --> 00:17:58.156
There's also a variant on this

00:17:58.156 --> 00:17:59.826
API that lets you specify an

00:17:59.826 --> 00:18:01.696
output pixel format for your

00:18:01.696 --> 00:18:02.146
kernel.

00:18:02.206 --> 00:18:04.146
So if your kernel is just going

00:18:04.176 --> 00:18:05.566
to output some single shadow

00:18:05.566 --> 00:18:07.296
data, you can specify a single

00:18:07.296 --> 00:18:08.916
shadow format for that kernel.

00:18:09.646 --> 00:18:13.166
So here's an example of how to

00:18:13.166 --> 00:18:14.356
initialize the CIKernel.

00:18:14.806 --> 00:18:15.786
All it takes is those three

00:18:15.786 --> 00:18:16.406
simple lines.

00:18:17.396 --> 00:18:19.356
The first two is for loading the

00:18:19.356 --> 00:18:21.706
Metal library, which, by

00:18:21.706 --> 00:18:22.736
default, if it was built in

00:18:22.736 --> 00:18:23.776
Xcode, will be called

00:18:23.776 --> 00:18:24.646
default.metallib.

00:18:24.816 --> 00:18:26.796
And then once you have that data

00:18:26.796 --> 00:18:28.116
loaded, you can initialize the

00:18:28.116 --> 00:18:30.566
CIKernel with a given function

00:18:30.566 --> 00:18:31.516
name from that library.

00:18:33.336 --> 00:18:35.096
Similarly, for warp and color

00:18:35.096 --> 00:18:36.756
kernels they can be initialized

00:18:36.756 --> 00:18:38.066
with the exactly the same API.

00:18:39.746 --> 00:18:40.816
So once you have that kernel

00:18:41.146 --> 00:18:42.466
initialized you can apply that

00:18:42.466 --> 00:18:43.886
however you like to produce the

00:18:43.886 --> 00:18:45.156
filter graph that you desire.

00:18:46.246 --> 00:18:47.136
So that's all there is to

00:18:47.136 --> 00:18:49.326
writing CIKernels in Metal and

00:18:49.326 --> 00:18:50.186
we think this is going to be a

00:18:50.186 --> 00:18:51.226
great new workflow for

00:18:51.226 --> 00:18:53.876
developers so we look forward to

00:18:54.396 --> 00:18:55.496
seeing some amazing things that

00:18:55.496 --> 00:18:56.376
you can do with this new

00:18:56.376 --> 00:18:57.036
capability.

00:18:59.296 --> 00:18:59.906
All right.

00:19:00.176 --> 00:19:01.346
So now the next topic I'd like

00:19:01.346 --> 00:19:03.496
to talk about is a new API that

00:19:03.496 --> 00:19:05.106
we have for rendering to

00:19:05.106 --> 00:19:05.786
destinations.

00:19:06.456 --> 00:19:10.016
And this is a new consistent API

00:19:10.286 --> 00:19:11.676
across all the different

00:19:11.846 --> 00:19:12.876
destination types that we

00:19:12.876 --> 00:19:13.336
support.

00:19:13.856 --> 00:19:15.776
Namely IOSurfaces, which, by the

00:19:15.776 --> 00:19:17.306
way, is now public API on iOS.

00:19:18.226 --> 00:19:19.906
And we also support rendering to

00:19:19.906 --> 00:19:21.976
CVPixelBuffers, as well as Metal

00:19:21.976 --> 00:19:22.926
and OpenGL Textures.

00:19:23.896 --> 00:19:25.066
Or even just some raw bitmap

00:19:25.066 --> 00:19:26.176
data that you have in memory.

00:19:26.736 --> 00:19:29.136
And one of the first things

00:19:29.136 --> 00:19:30.256
you'll notice with this new API

00:19:30.676 --> 00:19:32.386
is that it will now return

00:19:32.386 --> 00:19:33.616
immediately, if it detects a

00:19:33.616 --> 00:19:35.136
render failure, and give you

00:19:35.136 --> 00:19:36.626
back an error indicating why it

00:19:36.626 --> 00:19:37.006
failed.

00:19:37.496 --> 00:19:39.156
So now you can actually detect

00:19:39.156 --> 00:19:40.236
that programmatically in the

00:19:40.236 --> 00:19:41.916
application and fails gracefully

00:19:42.196 --> 00:19:43.386
if an error is detected.

00:19:43.906 --> 00:19:47.706
With this API, you can also set

00:19:47.766 --> 00:19:49.376
some common properties for the

00:19:49.376 --> 00:19:51.426
destination object, such as an

00:19:51.426 --> 00:19:52.776
alpha mode or a clamping mode

00:19:52.776 --> 00:19:54.736
behavior, or even a colorspace

00:19:54.776 --> 00:19:55.656
that you want to render the

00:19:55.656 --> 00:19:56.246
output to.

00:19:57.266 --> 00:19:58.936
Previously, with our existing

00:19:58.936 --> 00:20:00.756
API, the alpha mode and clamping

00:20:00.756 --> 00:20:02.126
mode was something that would be

00:20:02.126 --> 00:20:03.686
determined implicitly, based on

00:20:03.686 --> 00:20:05.076
the format of your destination.

00:20:05.626 --> 00:20:06.866
But now, you can actually

00:20:06.866 --> 00:20:08.526
explicitly override that with

00:20:08.526 --> 00:20:09.586
the behavior that you want.

00:20:11.986 --> 00:20:12.956
In addition to these common

00:20:12.956 --> 00:20:14.226
properties, we have some new

00:20:14.226 --> 00:20:15.416
advanced properties that you can

00:20:15.466 --> 00:20:16.976
set on the destination, such as

00:20:17.036 --> 00:20:18.016
dithering and blending.

00:20:18.736 --> 00:20:19.866
So, for example, if you have an

00:20:19.866 --> 00:20:22.126
8-bit output buffer that you

00:20:22.126 --> 00:20:23.476
want to render to, you can just

00:20:23.476 --> 00:20:25.176
simply enable dithering to get

00:20:25.336 --> 00:20:26.586
some -- a greater perceived

00:20:26.586 --> 00:20:28.426
color depth in order to reduce

00:20:28.426 --> 00:20:30.806
some banding artifacts that you

00:20:30.806 --> 00:20:31.866
may see in certain parts of the

00:20:31.866 --> 00:20:32.336
image.

00:20:32.866 --> 00:20:36.546
And a nice thing about these

00:20:36.546 --> 00:20:38.226
properties is now they

00:20:38.336 --> 00:20:40.016
effectively reduce the need for

00:20:40.016 --> 00:20:41.766
having to create multiple

00:20:41.766 --> 00:20:42.546
CIContexts.

00:20:42.546 --> 00:20:44.746
And that's because some of these

00:20:44.746 --> 00:20:46.546
properties used to be tied to

00:20:46.546 --> 00:20:47.456
the CIContexts.

00:20:47.456 --> 00:20:48.566
So, if you had multiple

00:20:48.566 --> 00:20:49.676
configuration of different

00:20:49.676 --> 00:20:51.356
destinations, you would have had

00:20:51.356 --> 00:20:52.946
to create a CIContext for every

00:20:52.946 --> 00:20:53.486
single one.

00:20:54.096 --> 00:20:55.346
So now that these properties are

00:20:55.346 --> 00:20:57.716
nicely decoupled, you can, for

00:20:57.716 --> 00:20:58.966
the most part, just have one

00:20:58.966 --> 00:21:00.876
CIContext that can render to

00:21:00.876 --> 00:21:02.336
various different destinations.

00:21:03.836 --> 00:21:06.096
But along with all these

00:21:06.166 --> 00:21:07.396
functionality that this API

00:21:07.396 --> 00:21:09.206
provides, there are some really

00:21:09.206 --> 00:21:11.376
great performance enhancements

00:21:11.616 --> 00:21:13.296
that can be realized with this

00:21:13.296 --> 00:21:13.686
new API.

00:21:14.946 --> 00:21:16.866
For example, our CIContext API

00:21:16.976 --> 00:21:18.816
for rendering to IOSurfaces or

00:21:18.816 --> 00:21:19.726
CVPixelBuffers.

00:21:20.426 --> 00:21:22.486
They used to return after all

00:21:22.486 --> 00:21:24.656
the render on the GPU is

00:21:24.736 --> 00:21:25.286
completed.

00:21:26.236 --> 00:21:28.866
But now with this new API, it

00:21:28.866 --> 00:21:30.746
will return as soon as the CPU

00:21:30.746 --> 00:21:32.016
has finished issuing all the

00:21:32.016 --> 00:21:33.026
work for the GPU.

00:21:33.556 --> 00:21:34.886
And without having to wait for

00:21:34.886 --> 00:21:36.026
the GPU work to finish.

00:21:37.166 --> 00:21:38.666
So we think this new flexibility

00:21:38.666 --> 00:21:40.406
will now allow you to pipeline

00:21:40.466 --> 00:21:42.136
all your CPU and GPU work much

00:21:42.136 --> 00:21:42.786
more efficiently.

00:21:44.116 --> 00:21:45.646
So let me show you an example of

00:21:46.346 --> 00:21:46.906
that use case.

00:21:47.736 --> 00:21:49.266
So here we have a simple render

00:21:49.266 --> 00:21:52.236
routine that is going to clear a

00:21:52.236 --> 00:21:53.866
destination surface and then

00:21:53.866 --> 00:21:55.986
render a foreground image over

00:21:55.986 --> 00:21:57.206
top of a background image.

00:21:58.326 --> 00:21:59.856
So the first thing we do is

00:21:59.856 --> 00:22:01.936
initialize a CIRenderDestination

00:22:01.936 --> 00:22:03.816
object given in ioSurface.

00:22:04.406 --> 00:22:07.076
And then the first thing we want

00:22:07.496 --> 00:22:09.866
is to get a CIContext and start

00:22:09.866 --> 00:22:11.426
a render task to clear the

00:22:11.426 --> 00:22:12.086
destination.

00:22:13.606 --> 00:22:15.466
But before waiting for that task

00:22:15.466 --> 00:22:16.786
to actually finish, we can now

00:22:16.786 --> 00:22:18.756
start another task to render the

00:22:18.756 --> 00:22:19.506
background image to the

00:22:19.506 --> 00:22:19.966
destination.

00:22:23.176 --> 00:22:24.806
And then, now before we start

00:22:24.806 --> 00:22:26.136
the final task, we can set a

00:22:26.136 --> 00:22:27.776
blend kernel on this destination

00:22:27.776 --> 00:22:29.866
object, which can be anyone of

00:22:29.866 --> 00:22:32.086
our 37 built-in blend kernels.

00:22:32.606 --> 00:22:33.786
In this case, we've chosen a

00:22:33.786 --> 00:22:34.686
sourceOver blend.

00:22:35.196 --> 00:22:37.176
But you can even create your own

00:22:37.176 --> 00:22:39.066
custom blend kernel by using our

00:22:39.066 --> 00:22:40.616
new CIBlendKernel API.

00:22:40.616 --> 00:22:44.376
So once we have the blend kernel

00:22:44.526 --> 00:22:47.476
that we want, we then call

00:22:47.476 --> 00:22:49.056
CIContext to start the final

00:22:49.056 --> 00:22:50.346
render task to render the

00:22:50.346 --> 00:22:52.086
foreground image over top of

00:22:52.406 --> 00:22:53.566
whatever is already in that

00:22:53.566 --> 00:22:54.216
destination.

00:22:54.936 --> 00:22:56.276
And only then do you need to

00:22:56.276 --> 00:22:58.456
call waitUntilCompleted, if you

00:22:58.456 --> 00:23:00.446
need to access the contents on

00:23:00.446 --> 00:23:01.066
the CPU.

00:23:01.706 --> 00:23:03.506
So with this new setup, this

00:23:03.506 --> 00:23:05.266
will now minimize the latency of

00:23:05.266 --> 00:23:06.856
getting your results without

00:23:06.856 --> 00:23:08.746
having to do any unnecessary

00:23:08.746 --> 00:23:09.956
synchronization with the GPU.

00:23:13.456 --> 00:23:14.696
The next use case I'd like to

00:23:14.856 --> 00:23:16.716
illustrate is one that will

00:23:17.256 --> 00:23:18.656
highlight a much more subtle

00:23:18.656 --> 00:23:21.066
performance benefit, but it can

00:23:21.066 --> 00:23:22.046
have a huge impact in your

00:23:22.046 --> 00:23:22.586
application.

00:23:22.636 --> 00:23:23.966
And that's rendering to Metal

00:23:23.966 --> 00:23:24.906
drawable textures.

00:23:25.156 --> 00:23:27.356
So you can do that very simply

00:23:27.356 --> 00:23:29.746
by getting a currentDrawable

00:23:29.746 --> 00:23:30.536
from, let's say Metal

00:23:30.616 --> 00:23:30.966
[inaudible] view.

00:23:31.226 --> 00:23:32.776
And then from that, you can

00:23:32.776 --> 00:23:34.806
initialize a CIRenderDestination

00:23:35.196 --> 00:23:36.346
with the texture from that

00:23:36.346 --> 00:23:36.786
drawable.

00:23:36.786 --> 00:23:40.556
So this will work just fine, but

00:23:40.626 --> 00:23:41.876
if you were to do this in a

00:23:41.876 --> 00:23:44.476
per-frame render loop, there's a

00:23:44.866 --> 00:23:46.066
potential for a performance

00:23:46.066 --> 00:23:47.236
bottleneck here that may not be

00:23:47.236 --> 00:23:48.026
so obvious.

00:23:48.376 --> 00:23:51.036
So let me try to describe that

00:23:51.686 --> 00:23:52.896
or explain that in a little bit

00:23:52.896 --> 00:23:54.436
more detail with a timeline view

00:23:54.436 --> 00:23:54.706
here.

00:23:55.646 --> 00:23:56.786
And please bear with me because

00:23:56.786 --> 00:23:58.316
there could be a lot of steps

00:23:58.316 --> 00:23:58.676
involved.

00:23:59.376 --> 00:24:01.606
So here we have a timeline that

00:24:01.606 --> 00:24:03.296
has two tracks, the CPU at the

00:24:03.296 --> 00:24:04.736
top and the GPU at the bottom.

00:24:05.506 --> 00:24:06.466
Technically there's actually a

00:24:06.466 --> 00:24:07.346
third component in play here,

00:24:07.346 --> 00:24:08.406
which is to display.

00:24:08.406 --> 00:24:10.436
But for the sake of simplicity,

00:24:10.686 --> 00:24:11.696
we'll just treat that as part of

00:24:11.696 --> 00:24:12.096
the GPU.

00:24:12.756 --> 00:24:14.746
So in the very first frame, your

00:24:14.746 --> 00:24:16.496
app will try to get a drawable

00:24:16.496 --> 00:24:17.046
from the view.

00:24:17.576 --> 00:24:19.926
And then from that drawable you

00:24:19.926 --> 00:24:22.386
can get a texture and then start

00:24:22.386 --> 00:24:24.736
a task to render to that

00:24:24.906 --> 00:24:25.386
texture.

00:24:26.796 --> 00:24:28.566
So once the CI gets that call,

00:24:28.566 --> 00:24:29.656
we will start encoding the

00:24:29.656 --> 00:24:32.336
commands on the CPU for the work

00:24:32.336 --> 00:24:33.576
to be done on the GPU.

00:24:34.286 --> 00:24:35.616
And in this particular case,

00:24:35.616 --> 00:24:37.576
we're illustrating a filter

00:24:37.576 --> 00:24:38.866
graph that actually has multiple

00:24:38.866 --> 00:24:40.126
render passes, namely two

00:24:40.126 --> 00:24:41.866
intermediate passes and a final

00:24:41.866 --> 00:24:43.506
destination pass.

00:24:44.756 --> 00:24:45.796
Once Core Image has finished

00:24:45.796 --> 00:24:47.236
encoding all the work, the call

00:24:47.236 --> 00:24:48.326
to startTask will return.

00:24:48.756 --> 00:24:50.876
And then from then, that point

00:24:50.876 --> 00:24:52.446
on the GPU will happily schedule

00:24:52.446 --> 00:24:53.816
that work to be done at some

00:24:53.816 --> 00:24:55.966
appropriate time.

00:24:56.176 --> 00:24:58.756
But, if the work on the GPU is

00:24:58.756 --> 00:25:01.026
going to take a long time, your

00:25:01.026 --> 00:25:02.946
app could get called to render

00:25:02.946 --> 00:25:05.666
another frame before the work is

00:25:05.666 --> 00:25:06.036
done.

00:25:06.906 --> 00:25:08.136
And at that point, if you try to

00:25:08.136 --> 00:25:10.596
get a drawable, that call to get

00:25:10.596 --> 00:25:12.746
drawable will stall until it is

00:25:12.746 --> 00:25:14.166
ready to be vended back to your

00:25:14.166 --> 00:25:14.816
application.

00:25:15.066 --> 00:25:18.096
And then only then can you get

00:25:18.096 --> 00:25:19.756
the texture from it and start

00:25:19.756 --> 00:25:21.796
another task to render to it and

00:25:22.586 --> 00:25:24.176
then so on for all subsequent

00:25:24.176 --> 00:25:24.506
frames.

00:25:24.506 --> 00:25:27.096
So, as you can see here, this is

00:25:27.096 --> 00:25:28.496
not a very efficient use of both

00:25:28.496 --> 00:25:29.996
the CPU and the GPU because

00:25:29.996 --> 00:25:31.436
there's a lot of idle times on

00:25:31.436 --> 00:25:32.206
both processors.

00:25:32.776 --> 00:25:35.286
But, if you look closely here,

00:25:35.286 --> 00:25:37.676
the drawable texture that we're

00:25:37.676 --> 00:25:39.456
about to render to is actually

00:25:39.456 --> 00:25:41.336
not needed until the very last

00:25:41.336 --> 00:25:41.956
render pass.

00:25:43.016 --> 00:25:44.276
So let's look at how we can

00:25:44.276 --> 00:25:45.816
actually improve this scenario.

00:25:48.716 --> 00:25:49.646
So, with our new

00:25:49.646 --> 00:25:52.346
CIRenderDestination API, you can

00:25:52.346 --> 00:25:54.416
now initialize it, not with the

00:25:54.416 --> 00:25:56.936
texture, per se, but rather, all

00:25:56.936 --> 00:25:58.306
the properties of the textures,

00:25:58.536 --> 00:26:00.716
such as the width and height and

00:26:00.716 --> 00:26:02.156
the pixel format of the texture.

00:26:02.676 --> 00:26:04.666
And then you can provide that

00:26:04.666 --> 00:26:06.626
texture via call back, which

00:26:06.626 --> 00:26:08.496
will be called lazily at the

00:26:08.496 --> 00:26:10.196
latest possible time for when

00:26:10.196 --> 00:26:11.726
that texture is actually needed.

00:26:12.356 --> 00:26:15.216
And so now, with the destination

00:26:15.216 --> 00:26:17.126
object initialized immediately,

00:26:17.126 --> 00:26:18.506
you can start a task and render

00:26:18.506 --> 00:26:20.496
to it much sooner, and this will

00:26:20.496 --> 00:26:22.006
effectively defer that

00:26:22.136 --> 00:26:23.316
potentially blocking call to

00:26:23.316 --> 00:26:24.866
currentDrawable to a much later

00:26:24.866 --> 00:26:25.506
point in time.

00:26:25.546 --> 00:26:28.306
So now, if we look at this

00:26:28.306 --> 00:26:32.096
example, the work now on the CPU

00:26:32.096 --> 00:26:33.706
and GPU can be pipelined much

00:26:33.706 --> 00:26:34.346
more efficiently.

00:26:35.476 --> 00:26:36.806
So if you're rendering to Metal

00:26:36.806 --> 00:26:38.386
drawable textures, we strongly

00:26:38.386 --> 00:26:39.696
encourage you to use this new

00:26:39.696 --> 00:26:39.876
API.

00:26:39.876 --> 00:26:41.726
Because this could greatly

00:26:41.726 --> 00:26:43.056
improve the frame rate of your

00:26:43.056 --> 00:26:43.586
application.

00:26:44.116 --> 00:26:45.336
In fact, we have seen cases

00:26:45.336 --> 00:26:46.616
where the frame rate literally

00:26:46.616 --> 00:26:48.426
doubled just by simply employing

00:26:48.426 --> 00:26:48.996
this technique.

00:26:48.996 --> 00:26:49.626
All right.

00:26:51.856 --> 00:26:55.676
So now I'd like to hand it back

00:26:55.676 --> 00:26:57.126
to David who will tell you about

00:26:57.126 --> 00:26:58.426
some really cool stuff that lets

00:26:58.426 --> 00:26:59.866
you look under the hood inside

00:26:59.866 --> 00:27:00.586
the Core Image framework.

00:27:00.796 --> 00:27:00.976
Thank you.

00:27:01.516 --> 00:27:05.956
[ Applause ]

00:27:06.456 --> 00:27:07.396
>> Thank you so much Tony.

00:27:07.396 --> 00:27:08.206
That's great stuff.

00:27:09.376 --> 00:27:10.146
As I mentioned in my

00:27:10.146 --> 00:27:11.876
introduction, Core Image has a

00:27:11.876 --> 00:27:13.286
lot of great tricks it uses to

00:27:13.286 --> 00:27:14.456
get the best performance.

00:27:14.986 --> 00:27:16.286
And one of our goals this year

00:27:16.286 --> 00:27:17.576
was to make it clearer to you,

00:27:17.576 --> 00:27:19.376
the developer, how those tricks

00:27:19.376 --> 00:27:20.616
are occurring so that you can

00:27:20.616 --> 00:27:22.686
get a better understanding of

00:27:22.686 --> 00:27:23.716
how to use Core Image

00:27:23.716 --> 00:27:24.256
efficiently.

00:27:25.546 --> 00:27:27.076
And we've done that in a couple

00:27:27.076 --> 00:27:27.876
of interesting ways.

00:27:28.216 --> 00:27:29.766
First of all, in our new APIs,

00:27:29.866 --> 00:27:30.776
we have some new ways of

00:27:30.776 --> 00:27:32.606
returning you information about

00:27:32.646 --> 00:27:33.076
the render.

00:27:34.216 --> 00:27:36.046
After you've issued a task to

00:27:36.046 --> 00:27:37.976
render, you can now, after when

00:27:37.976 --> 00:27:39.026
you wait for that task to

00:27:39.026 --> 00:27:40.266
complete, it will return a

00:27:40.266 --> 00:27:42.476
CIRenderInfo object.

00:27:42.856 --> 00:27:44.346
And this object will return to

00:27:44.346 --> 00:27:45.276
you an object with a few

00:27:45.276 --> 00:27:46.866
properties on it, including the

00:27:46.866 --> 00:27:48.396
number of passes that Core Image

00:27:48.616 --> 00:27:50.056
needed to use to perform that

00:27:50.186 --> 00:27:50.576
render.

00:27:50.916 --> 00:27:52.236
As well as the total amount of

00:27:52.236 --> 00:27:54.016
time spent executing kernels on

00:27:54.016 --> 00:27:55.706
the device and also the total

00:27:55.706 --> 00:27:57.086
number of pixels processed.

00:27:57.426 --> 00:27:58.936
So that's just a great piece of

00:27:58.936 --> 00:28:00.076
information that you can get

00:28:00.246 --> 00:28:01.536
when we return information to

00:28:01.536 --> 00:28:01.666
you.

00:28:02.766 --> 00:28:04.766
But perhaps what is even cooler

00:28:05.066 --> 00:28:06.716
is the awesome new editions

00:28:06.716 --> 00:28:07.986
we've made to Core Image to

00:28:07.986 --> 00:28:09.446
provide better Quick Looks in

00:28:09.506 --> 00:28:09.896
Xcode.

00:28:11.856 --> 00:28:14.636
Notably, we now have a great

00:28:14.766 --> 00:28:16.566
Quick Look support for CIImages.

00:28:16.836 --> 00:28:17.946
In addition to just showing the

00:28:17.986 --> 00:28:19.216
pixels, we now show you the

00:28:19.246 --> 00:28:20.606
image graph that you constructed

00:28:20.606 --> 00:28:21.536
to produce that image.

00:28:22.686 --> 00:28:23.766
If you do a Quick Look on a

00:28:23.766 --> 00:28:26.416
CIRenderTask, it'll show you the

00:28:26.416 --> 00:28:28.036
optimized graph that Core Image

00:28:28.196 --> 00:28:29.626
converted your image graph into.

00:28:30.516 --> 00:28:31.886
And, if you wait for the render

00:28:31.886 --> 00:28:33.486
info to be returned to you, if

00:28:33.486 --> 00:28:34.496
you do a Quick Look on that,

00:28:34.776 --> 00:28:35.936
it'll show you all the

00:28:35.936 --> 00:28:37.536
concatenation, timing, and

00:28:37.536 --> 00:28:38.766
caching information that Core

00:28:38.766 --> 00:28:39.686
Image did internally.

00:28:40.056 --> 00:28:41.616
So to give you an idea, we're

00:28:41.616 --> 00:28:42.426
going to show you this in a very

00:28:42.426 --> 00:28:43.036
visual way.

00:28:43.466 --> 00:28:44.206
Here's some code.

00:28:44.266 --> 00:28:45.476
Let's pretend we're stepping

00:28:45.476 --> 00:28:46.366
through this in Xcode.

00:28:47.116 --> 00:28:49.456
Here's an example of a image

00:28:49.456 --> 00:28:50.116
graph that we're going to

00:28:50.116 --> 00:28:50.706
construct.

00:28:51.026 --> 00:28:52.106
In this case, we're creating a

00:28:52.106 --> 00:28:54.456
CIImage from a URL, and we have

00:28:54.456 --> 00:28:55.236
a new option that we're

00:28:55.236 --> 00:28:57.346
specifying on this image, which

00:28:57.346 --> 00:28:57.516
is

00:28:57.696 --> 00:29:01.286
kCIApplyImageOrientationProperty

00:29:02.256 --> 00:29:03.686
to true.

00:29:03.896 --> 00:29:05.266
And what this will do is

00:29:05.266 --> 00:29:06.596
automatically make the image

00:29:06.596 --> 00:29:08.656
upright for you, which is a nice

00:29:08.656 --> 00:29:09.176
convenience.

00:29:10.066 --> 00:29:11.056
The next thing we're going to do

00:29:11.056 --> 00:29:12.216
is we're going to add onto that

00:29:12.216 --> 00:29:13.226
image an additional

00:29:13.226 --> 00:29:14.616
AffineTransform which scales it

00:29:14.616 --> 00:29:16.896
down by .5.

00:29:16.896 --> 00:29:18.606
Now imagine we're in Xcode, and

00:29:18.606 --> 00:29:20.186
we hover over the image object.

00:29:20.576 --> 00:29:22.346
And, if you click on the little

00:29:22.346 --> 00:29:24.516
eye icon, it'll now pick up an

00:29:24.516 --> 00:29:25.336
image like this.

00:29:25.746 --> 00:29:27.046
In addition to the image showing

00:29:27.046 --> 00:29:28.116
you what the image looks like

00:29:28.116 --> 00:29:29.486
and it's nice and upright, it

00:29:29.486 --> 00:29:31.426
also shows you the graph to

00:29:31.426 --> 00:29:32.806
create that image below it.

00:29:33.246 --> 00:29:35.346
If we zoom in, we can see all

00:29:35.346 --> 00:29:36.086
sorts of interesting

00:29:36.086 --> 00:29:36.716
information.

00:29:37.266 --> 00:29:39.426
We can see, at the input of the

00:29:39.426 --> 00:29:41.036
image graph, we have our

00:29:41.036 --> 00:29:41.846
IOSurface.

00:29:41.976 --> 00:29:43.536
This is, I can tell by looking

00:29:43.536 --> 00:29:44.726
at it it's a YCC image.

00:29:44.726 --> 00:29:45.706
It means it probably came from a

00:29:45.706 --> 00:29:47.666
JPEG, and you can see the size

00:29:48.606 --> 00:29:51.366
of that surface, as well as that

00:29:51.366 --> 00:29:51.876
it's opaque.

00:29:52.476 --> 00:29:54.986
You can then see the next step

00:29:54.986 --> 00:29:56.586
above that in the graph is a

00:29:56.586 --> 00:29:57.846
color-matching operation.

00:29:57.846 --> 00:29:59.066
So we were able to determine

00:29:59.066 --> 00:29:59.996
automatically what the

00:30:00.226 --> 00:30:01.416
colorspace of the input image

00:30:01.416 --> 00:30:01.756
was.

00:30:02.026 --> 00:30:03.316
And we've inserted it in the

00:30:03.316 --> 00:30:05.266
render graph and operation to

00:30:05.466 --> 00:30:06.816
convert from the display P3

00:30:06.816 --> 00:30:08.256
colorspace to Core Image's

00:30:08.256 --> 00:30:08.956
workingspace.

00:30:10.986 --> 00:30:12.896
And lastly, you can see three

00:30:12.896 --> 00:30:13.946
affine matrices.

00:30:14.076 --> 00:30:15.366
The first one, as we're counting

00:30:15.366 --> 00:30:16.886
from the bottom, is the matrix

00:30:16.886 --> 00:30:17.856
that converts from the image

00:30:17.856 --> 00:30:18.976
coordinate system to the

00:30:18.976 --> 00:30:20.256
Cartesian coordinate system that

00:30:20.256 --> 00:30:21.086
Core Image uses.

00:30:21.946 --> 00:30:23.416
Then we have the affine to make

00:30:23.416 --> 00:30:24.826
the image upright, and then the

00:30:24.826 --> 00:30:27.116
image affine to scale it down by

00:30:27.116 --> 00:30:27.706
.5.

00:30:28.466 --> 00:30:29.656
So now you can really look at an

00:30:29.656 --> 00:30:30.706
image and see everything that's

00:30:30.746 --> 00:30:33.486
being asked of it.

00:30:33.766 --> 00:30:35.276
Now let's do something slightly

00:30:35.276 --> 00:30:35.986
different this time.

00:30:35.986 --> 00:30:37.716
Now we're going to ask for an

00:30:37.716 --> 00:30:38.686
image, but we're going to ask

00:30:38.686 --> 00:30:40.766
for the auxiliary disparity

00:30:40.766 --> 00:30:41.126
image.

00:30:41.266 --> 00:30:42.466
And this is a new option that we

00:30:42.466 --> 00:30:44.396
have as well, and this, if your

00:30:44.396 --> 00:30:46.176
image has depth information in

00:30:46.176 --> 00:30:49.156
it, it will return that as a

00:30:49.156 --> 00:30:50.176
monochrome image.

00:30:51.816 --> 00:30:53.276
After we ask for that image,

00:30:53.666 --> 00:30:55.086
we're going to apply a filter on

00:30:55.086 --> 00:30:55.196
it.

00:30:55.306 --> 00:30:56.266
In this case, we're going to

00:30:56.266 --> 00:30:58.176
apply a bicubic scale transform

00:30:58.456 --> 00:30:59.526
to adjust its size.

00:31:01.206 --> 00:31:03.206
Now, if we were to hover over

00:31:03.206 --> 00:31:04.246
this object while we're

00:31:04.246 --> 00:31:06.226
debugging in Xcode, we will now

00:31:06.736 --> 00:31:07.816
be able to get this image.

00:31:08.246 --> 00:31:09.266
And now you can actually see the

00:31:09.266 --> 00:31:11.726
disparity image where white is

00:31:11.726 --> 00:31:13.756
in the foreground and darker is

00:31:14.146 --> 00:31:15.146
further in the background, but

00:31:15.456 --> 00:31:17.716
we can also see the graph that

00:31:17.716 --> 00:31:19.066
was used to generate this image.

00:31:19.796 --> 00:31:21.596
Here we see that the leaf or

00:31:21.596 --> 00:31:23.926
input image is an IOSurface that

00:31:23.926 --> 00:31:25.576
is a format luminance half

00:31:25.576 --> 00:31:27.976
float, and you can also see that

00:31:27.976 --> 00:31:29.016
the dimensions of the image are

00:31:29.016 --> 00:31:30.456
smaller than the original image.

00:31:31.916 --> 00:31:33.306
You can also see at the top of

00:31:33.306 --> 00:31:36.456
this graph the cubic upsampling

00:31:36.456 --> 00:31:37.386
filter that we've applied.

00:31:38.816 --> 00:31:40.016
There's actually some method to

00:31:40.016 --> 00:31:41.286
our colors that we chose here.

00:31:41.556 --> 00:31:42.726
One thing you'll notice is all

00:31:42.726 --> 00:31:44.296
of the inputs to our graphs are

00:31:44.336 --> 00:31:44.666
purple.

00:31:45.256 --> 00:31:46.556
Anything that affects the color

00:31:46.556 --> 00:31:48.646
of an image, i.e., CIColorKernel

00:31:49.036 --> 00:31:49.536
is red.

00:31:49.626 --> 00:31:50.876
Anything that affects the

00:31:50.876 --> 00:31:52.176
geometry, in other words, a

00:31:52.176 --> 00:31:53.676
CIWarpKernel, is green.

00:31:54.076 --> 00:31:55.646
And the rest of the kernels are

00:31:55.646 --> 00:31:56.976
in a blue color.

00:32:00.846 --> 00:32:02.586
So now let's get even more

00:32:02.586 --> 00:32:03.026
interesting.

00:32:03.026 --> 00:32:04.786
We're going to take the primary

00:32:04.786 --> 00:32:05.796
image and we're going to apply

00:32:05.796 --> 00:32:07.906
two different color cubes to it.

00:32:08.256 --> 00:32:09.716
We're going to take those two

00:32:09.716 --> 00:32:10.966
resulting images and then we're

00:32:10.966 --> 00:32:12.216
going to combine them with the

00:32:12.276 --> 00:32:13.766
CIBlendWithMask filter.

00:32:14.416 --> 00:32:16.476
And, if we look at this in Quick

00:32:16.476 --> 00:32:18.356
Looks, we now see the final

00:32:18.356 --> 00:32:19.796
image where it's been

00:32:19.956 --> 00:32:21.206
beautifully filtered with two

00:32:21.206 --> 00:32:22.276
different effects, based on

00:32:22.316 --> 00:32:23.246
foreground and background.

00:32:23.536 --> 00:32:25.986
But also, we see detailed

00:32:25.986 --> 00:32:27.516
information about the graph that

00:32:27.516 --> 00:32:28.476
was used to produce it.

00:32:29.286 --> 00:32:30.726
You can see here, on the

00:32:30.776 --> 00:32:32.286
left-hand side, the portion of

00:32:32.286 --> 00:32:33.656
the subgraph where we took the

00:32:33.656 --> 00:32:36.346
input image, got the color cube

00:32:36.346 --> 00:32:40.056
data, which is a 32 by 24 image,

00:32:40.486 --> 00:32:41.906
and then apply that color cube

00:32:41.906 --> 00:32:42.186
to it.

00:32:42.806 --> 00:32:44.986
On the middle graph, we're doing

00:32:44.986 --> 00:32:45.786
the same thing for the

00:32:45.786 --> 00:32:46.666
background image.

00:32:47.416 --> 00:32:49.076
All of these, plus the mask

00:32:49.076 --> 00:32:50.556
image, are used to combine with

00:32:50.556 --> 00:32:51.586
the blendWithMask kernel.

00:32:52.186 --> 00:32:55.206
So we're hoping that gives you

00:32:55.206 --> 00:32:57.196
great insight on how your

00:32:57.196 --> 00:32:58.806
application creates CIImages.

00:32:59.076 --> 00:33:00.406
But what happens when it comes

00:33:00.406 --> 00:33:00.946
time to render?

00:33:00.946 --> 00:33:01.766
And this is where things get

00:33:01.766 --> 00:33:02.496
really interesting.

00:33:03.296 --> 00:33:04.926
Once you tell a CIContext to

00:33:04.926 --> 00:33:06.566
start a task, that'll return a

00:33:06.566 --> 00:33:07.916
CIRenderedTask object.

00:33:08.186 --> 00:33:10.066
This also supports Quick Looks.

00:33:10.606 --> 00:33:12.156
And, if we look at this, we see

00:33:12.156 --> 00:33:13.286
now an even more elaborate

00:33:13.286 --> 00:33:13.676
graph.

00:33:14.156 --> 00:33:16.996
Again, the color coding is the

00:33:16.996 --> 00:33:18.596
same and we can see some of the

00:33:18.596 --> 00:33:21.726
same operations but now, what we

00:33:21.726 --> 00:33:23.126
saw before as a color matching

00:33:23.126 --> 00:33:24.466
operation has been converted

00:33:24.466 --> 00:33:25.426
into the primitives that are

00:33:25.426 --> 00:33:26.596
needed to do the color

00:33:26.596 --> 00:33:27.046
management.

00:33:27.276 --> 00:33:28.416
So we can see that we needed to

00:33:28.416 --> 00:33:30.506
apply this gamma function and

00:33:30.506 --> 00:33:31.856
this color matrix to convert

00:33:31.856 --> 00:33:33.566
from P3 to our workingspace.

00:33:34.726 --> 00:33:35.936
Another thing you can see is,

00:33:35.936 --> 00:33:37.226
while the original image had

00:33:37.226 --> 00:33:39.136
three affine transforms, Core

00:33:39.136 --> 00:33:41.086
Image has concatenated those all

00:33:41.086 --> 00:33:41.516
into one.

00:33:42.046 --> 00:33:45.636
Another thing you can notice is

00:33:45.696 --> 00:33:47.376
at the end of the graph, we now

00:33:47.376 --> 00:33:48.456
know what the destination

00:33:48.456 --> 00:33:49.286
colorspace is.

00:33:49.396 --> 00:33:50.986
So those operations have been

00:33:50.986 --> 00:33:52.236
applied to the image as well,

00:33:53.416 --> 00:33:57.236
both applying the colorspace as

00:33:57.236 --> 00:33:58.366
well as the coordinate system

00:33:58.366 --> 00:33:59.396
transform for the final

00:33:59.396 --> 00:33:59.976
destination.

00:33:59.976 --> 00:34:01.996
You can also see it associated

00:34:01.996 --> 00:34:03.056
with all these objects or all

00:34:03.056 --> 00:34:04.326
the dimensions of all the images

00:34:04.326 --> 00:34:05.506
that are involved at each stage

00:34:05.506 --> 00:34:09.206
of the render graph.

00:34:09.275 --> 00:34:10.606
Now, if you wait for your task

00:34:10.606 --> 00:34:12.456
to be completed, now there's a

00:34:12.456 --> 00:34:13.156
new object.

00:34:13.156 --> 00:34:14.746
And associated with this object

00:34:15.835 --> 00:34:17.596
is detailed information about

00:34:17.596 --> 00:34:18.906
how Core Image was able to

00:34:18.906 --> 00:34:20.235
concatenate and what the

00:34:20.235 --> 00:34:21.735
performance of that render was.

00:34:22.386 --> 00:34:23.286
You'll see now there's much

00:34:23.286 --> 00:34:25.025
fewer objects in the tree

00:34:25.025 --> 00:34:26.186
because of concatenation.

00:34:26.525 --> 00:34:27.525
If we look at one of the lower

00:34:27.525 --> 00:34:29.636
ones here, we can see that this

00:34:29.696 --> 00:34:31.676
particular program is the result

00:34:31.676 --> 00:34:33.565
of concatenating a few steps

00:34:33.565 --> 00:34:36.815
into one program, and we can

00:34:36.815 --> 00:34:38.326
also see associated with this

00:34:38.556 --> 00:34:39.496
the amount of time that was

00:34:39.496 --> 00:34:41.126
spent on that program in

00:34:41.126 --> 00:34:41.815
milliseconds.

00:34:42.556 --> 00:34:43.835
One great feature of Core Image

00:34:43.835 --> 00:34:44.795
is, if you then render this

00:34:44.795 --> 00:34:47.085
image again later and a portion

00:34:47.085 --> 00:34:48.545
of the graph is the same, then

00:34:48.545 --> 00:34:50.516
Core Image may be able to obtain

00:34:50.516 --> 00:34:51.656
the previous results from a

00:34:51.656 --> 00:34:52.146
cache.

00:34:52.676 --> 00:34:54.016
If that happens, then you'll see

00:34:54.016 --> 00:34:55.266
the time go to zero in those

00:34:55.266 --> 00:34:55.735
cases.

00:34:56.216 --> 00:34:57.816
So this also provides a way for

00:34:57.816 --> 00:34:59.566
your application to know how

00:34:59.566 --> 00:35:00.906
efficiently Core Image is able

00:35:00.906 --> 00:35:02.776
to render and cache your

00:35:02.776 --> 00:35:05.416
results, given memory limits.

00:35:05.986 --> 00:35:09.136
So we hope you find this really

00:35:09.136 --> 00:35:10.886
informative and instructional on

00:35:10.886 --> 00:35:12.226
how Core Image works internally.

00:35:13.896 --> 00:35:14.846
The next subject I'd like to

00:35:14.846 --> 00:35:17.006
talk a little bit about today is

00:35:17.536 --> 00:35:18.926
barcodes, specifically the

00:35:18.926 --> 00:35:20.446
CIBarcodeDescriptor API.

00:35:21.696 --> 00:35:23.376
We now have great broad support

00:35:23.416 --> 00:35:24.886
for barcodes on our platform.

00:35:25.336 --> 00:35:26.796
Barcodes of various different

00:35:26.796 --> 00:35:29.006
types from Aztec to Code128 to

00:35:29.006 --> 00:35:31.036
QRCode and PDF417.

00:35:32.466 --> 00:35:33.816
We also have support for

00:35:33.816 --> 00:35:35.726
barcodes across a broad variety

00:35:35.726 --> 00:35:37.406
of frameworks, and those

00:35:37.406 --> 00:35:38.596
frameworks use barcodes in

00:35:38.596 --> 00:35:39.976
different ways for good reasons.

00:35:40.596 --> 00:35:43.316
For example, oops, sorry.

00:35:43.316 --> 00:35:46.046
AVFoundation is the framework to

00:35:46.046 --> 00:35:47.496
use if you want to detect

00:35:47.576 --> 00:35:49.046
barcodes when you're capturing

00:35:49.296 --> 00:35:50.406
video from the camera.

00:35:51.506 --> 00:35:53.636
If you want to detect barcodes

00:35:53.896 --> 00:35:55.656
from either still images or from

00:35:55.656 --> 00:35:57.756
a video post-capture, the Vision

00:35:57.756 --> 00:35:58.936
framework is a great way of

00:35:59.036 --> 00:36:00.066
using it.

00:36:00.256 --> 00:36:01.516
And lastly, you can use Core

00:36:01.516 --> 00:36:04.176
Image to render barcodes into

00:36:04.176 --> 00:36:05.256
actual image files.

00:36:06.596 --> 00:36:08.116
Given this broad support across

00:36:08.116 --> 00:36:09.816
frameworks, we wanted to have a

00:36:09.816 --> 00:36:11.216
new data type that would allow

00:36:11.826 --> 00:36:14.016
the barcode information to be

00:36:14.016 --> 00:36:15.206
transported between these

00:36:15.246 --> 00:36:17.206
frameworks in a lossless way.

00:36:19.106 --> 00:36:21.136
And that is the reason for the

00:36:21.136 --> 00:36:23.786
new CIBarcodeDescription API.

00:36:25.036 --> 00:36:27.546
There's one key property of this

00:36:27.546 --> 00:36:28.926
object, and that is the

00:36:28.926 --> 00:36:30.096
errorCorrectedPayload.

00:36:30.856 --> 00:36:32.756
This is not just the textural

00:36:32.756 --> 00:36:34.786
message of a barcode.

00:36:34.786 --> 00:36:36.036
It's actually the raw data,

00:36:36.346 --> 00:36:38.366
which allows you to use barcodes

00:36:38.366 --> 00:36:39.896
and get information out of them

00:36:40.096 --> 00:36:41.716
in ways that are more than just

00:36:41.716 --> 00:36:42.676
textural information.

00:36:43.016 --> 00:36:45.046
So, with this raw

00:36:45.796 --> 00:36:47.246
errorCorrectedPayload and

00:36:47.246 --> 00:36:48.876
understanding of each barcode's

00:36:49.046 --> 00:36:50.416
formatting, you can do

00:36:50.896 --> 00:36:53.036
interesting properties and build

00:36:53.036 --> 00:36:53.806
interesting vertical

00:36:53.806 --> 00:36:55.306
applications based on barcodes.

00:36:56.296 --> 00:36:58.056
Also there are properties that

00:36:58.056 --> 00:36:59.426
are unique to each particular

00:36:59.426 --> 00:36:59.936
barcode.

00:37:00.426 --> 00:37:01.746
For example, in the case of the

00:37:01.746 --> 00:37:04.266
Aztec barcode, you can know how

00:37:04.536 --> 00:37:06.446
many layers were involved in

00:37:06.446 --> 00:37:06.896
that code.

00:37:07.296 --> 00:37:08.966
Or, in the case of the QRCode

00:37:09.216 --> 00:37:10.766
barcode, what the maskPattern

00:37:10.766 --> 00:37:11.756
that was used on this.

00:37:12.876 --> 00:37:14.926
So let me give you an example of

00:37:14.926 --> 00:37:16.606
how this type can be used across

00:37:16.646 --> 00:37:17.776
these three frameworks.

00:37:18.236 --> 00:37:20.506
So firstly, in the area of

00:37:20.566 --> 00:37:23.426
AVFoundation, it is possible to

00:37:23.666 --> 00:37:24.466
register for a

00:37:24.466 --> 00:37:26.606
metadataOutputObjectDelegate

00:37:26.916 --> 00:37:29.126
that will see barcodes, as they

00:37:29.126 --> 00:37:31.846
are appeared in a video feed.

00:37:33.066 --> 00:37:35.446
In your code, all you have to do

00:37:35.446 --> 00:37:36.446
is setup this object.

00:37:36.746 --> 00:37:38.696
And, in your response for when

00:37:38.696 --> 00:37:41.246
that object is detected, you can

00:37:41.426 --> 00:37:44.106
ask for the object as a

00:37:44.106 --> 00:37:45.816
AVMetadataMachine

00:37:45.816 --> 00:37:47.276
ReadableCodeObject.

00:37:47.906 --> 00:37:49.366
From that object, you can get

00:37:49.456 --> 00:37:51.006
the descriptor property, and

00:37:51.006 --> 00:37:52.116
that will return one of the

00:37:52.116 --> 00:37:53.976
CIBarcodeDescriptor objects.

00:37:57.156 --> 00:37:58.606
Second if you want to use the

00:37:58.606 --> 00:37:59.776
Vision framework to detect

00:37:59.846 --> 00:38:00.996
barcodes, the code is really

00:38:00.996 --> 00:38:01.766
simple as well.

00:38:02.256 --> 00:38:03.346
Basically, we're going to use

00:38:03.346 --> 00:38:05.216
Vision to both create a request

00:38:05.216 --> 00:38:06.956
handler as well as a request.

00:38:07.626 --> 00:38:09.216
Then we're going to issue that

00:38:09.216 --> 00:38:10.836
request to the handler to detect

00:38:10.886 --> 00:38:11.436
the barcode.

00:38:11.996 --> 00:38:13.936
Once we get the request results

00:38:13.936 --> 00:38:15.776
back, we can then get the

00:38:15.776 --> 00:38:17.456
barcodeDescriptor object from

00:38:17.456 --> 00:38:18.216
that result.

00:38:19.006 --> 00:38:19.556
Very simple.

00:38:20.666 --> 00:38:23.086
And lastly, simplest of all, is

00:38:23.086 --> 00:38:24.526
using Core Image to generate a

00:38:24.526 --> 00:38:26.336
barcode image from a descriptor.

00:38:26.976 --> 00:38:28.056
So, in this case, it's very

00:38:28.056 --> 00:38:28.426
easy.

00:38:28.426 --> 00:38:29.556
We just create an instance of a

00:38:29.556 --> 00:38:31.416
CIFilter of type

00:38:31.476 --> 00:38:32.386
BarcodeGenerator.

00:38:33.166 --> 00:38:34.966
We then give that filter the

00:38:34.966 --> 00:38:36.726
input of the descriptor object

00:38:36.786 --> 00:38:38.466
for the inputBarcodeDescriptor.

00:38:39.136 --> 00:38:40.146
And then we're going ask for the

00:38:40.146 --> 00:38:40.816
output image.

00:38:42.176 --> 00:38:43.946
And these combined allow us to

00:38:43.946 --> 00:38:45.716
do some interesting stuff with

00:38:46.096 --> 00:38:47.636
both detection and generation of

00:38:47.636 --> 00:38:48.226
barcodes.

00:38:48.626 --> 00:38:50.626
And so, as a brief prerecorded

00:38:50.626 --> 00:38:52.056
demo of this, let me show you a

00:38:52.056 --> 00:38:53.056
sample app that we wrote.

00:38:53.816 --> 00:38:55.856
And what this does is look for

00:38:56.096 --> 00:38:57.626
frames of video, pulls the

00:38:57.626 --> 00:38:59.306
barcode, and actually renders

00:38:59.536 --> 00:39:01.076
the barcode back over the

00:39:01.246 --> 00:39:03.976
barcode as a -- kind of a

00:39:03.976 --> 00:39:05.336
augmented image over it.

00:39:05.836 --> 00:39:06.696
And you can see that we were

00:39:06.696 --> 00:39:08.606
able to perfectly reproduce the

00:39:08.606 --> 00:39:10.116
detected barcode and re-render

00:39:10.116 --> 00:39:10.726
it on top of it.

00:39:11.206 --> 00:39:12.496
If we just see that again real

00:39:12.496 --> 00:39:13.986
quickly, we can actually even

00:39:13.986 --> 00:39:15.156
see that it's being render

00:39:15.156 --> 00:39:17.526
because overlapping my thumb in

00:39:17.526 --> 00:39:18.016
the image.

00:39:19.456 --> 00:39:19.746
So --

00:39:20.516 --> 00:39:25.856
[ Applause ]

00:39:26.356 --> 00:39:26.726
All right.

00:39:26.726 --> 00:39:28.596
So for our last section of our

00:39:28.596 --> 00:39:30.416
talk today, I'm really excited

00:39:30.416 --> 00:39:32.036
to talk about how to use Core

00:39:32.036 --> 00:39:33.466
Image and Vision together.

00:39:33.976 --> 00:39:35.416
These are two great frameworks.

00:39:35.596 --> 00:39:36.926
Core Image is a great easy to

00:39:36.926 --> 00:39:38.196
use framework for applying image

00:39:38.256 --> 00:39:39.366
processing to images.

00:39:39.686 --> 00:39:41.296
Vision is a great framework for

00:39:41.486 --> 00:39:42.736
finding information about

00:39:42.736 --> 00:39:43.166
images.

00:39:43.166 --> 00:39:44.926
And you can use those together

00:39:44.926 --> 00:39:46.616
in great and novel ways.

00:39:48.346 --> 00:39:50.636
For example, you can use Core

00:39:50.636 --> 00:39:52.136
Image as a way of preparing

00:39:52.136 --> 00:39:53.866
images before passing them to

00:39:53.866 --> 00:39:54.256
Vision.

00:39:54.746 --> 00:39:56.096
For example, you might want to

00:39:56.096 --> 00:39:57.626
crop the image to an area of

00:39:57.626 --> 00:39:58.146
interest.

00:39:58.146 --> 00:39:59.936
Or correctly make the image

00:39:59.936 --> 00:40:00.466
upright.

00:40:00.746 --> 00:40:02.326
Or convert to grayscale before

00:40:02.356 --> 00:40:03.166
passing division.

00:40:04.976 --> 00:40:06.396
Also, once you've called Vision,

00:40:06.666 --> 00:40:07.936
once you have information about

00:40:07.936 --> 00:40:09.276
the image, you might be able to

00:40:09.276 --> 00:40:10.716
use that as a way of guiding how

00:40:10.716 --> 00:40:12.446
you want to adjust the look of

00:40:12.446 --> 00:40:12.976
your image.

00:40:13.256 --> 00:40:14.566
So, for example, if a feature is

00:40:14.566 --> 00:40:16.156
detected in an image, you might

00:40:16.156 --> 00:40:17.896
choose different ways to apply

00:40:18.396 --> 00:40:19.636
image processing to it.

00:40:20.986 --> 00:40:22.276
And, of course, these two can be

00:40:22.276 --> 00:40:23.026
combined together.

00:40:23.906 --> 00:40:25.426
But to go into a little bit more

00:40:25.496 --> 00:40:26.526
detail about this.

00:40:26.526 --> 00:40:28.026
We have a interesting demo we'd

00:40:28.026 --> 00:40:29.756
like to talk about today, where

00:40:29.756 --> 00:40:31.526
we're going to try to generate a

00:40:31.526 --> 00:40:34.066
photo from several frames of the

00:40:34.066 --> 00:40:34.516
video.

00:40:34.786 --> 00:40:36.676
Where the unwanted objects have

00:40:36.676 --> 00:40:38.446
been removed from that.

00:40:38.846 --> 00:40:39.896
And this demo is going to

00:40:39.896 --> 00:40:41.506
involve using three frameworks

00:40:41.506 --> 00:40:42.346
and four steps.

00:40:42.826 --> 00:40:44.156
The first step is going to be

00:40:44.156 --> 00:40:45.526
using AVFoundation to get the

00:40:45.526 --> 00:40:46.556
frames out of the video.

00:40:47.506 --> 00:40:49.216
And that's very simple to do.

00:40:50.056 --> 00:40:51.376
Then we're going to use Vision

00:40:51.546 --> 00:40:53.206
to determine what the homography

00:40:53.206 --> 00:40:55.286
matrices are needed to align

00:40:55.286 --> 00:40:57.026
each of these frames to a common

00:40:57.026 --> 00:40:57.546
reference.

00:40:58.666 --> 00:40:59.806
Inevitably there's some camera

00:40:59.806 --> 00:41:00.596
shake, so a little bit of

00:41:00.596 --> 00:41:01.836
correction goes a long way.

00:41:02.956 --> 00:41:04.446
So that will allow us to get

00:41:04.446 --> 00:41:06.486
these homography matrices

00:41:06.486 --> 00:41:07.486
represented here as these

00:41:07.696 --> 00:41:09.636
slightly moving arrows for each

00:41:09.636 --> 00:41:10.436
frame in the image.

00:41:11.896 --> 00:41:13.736
The third step is to use Core

00:41:13.736 --> 00:41:15.486
Image to align all these frames

00:41:15.486 --> 00:41:15.966
to each other.

00:41:16.746 --> 00:41:17.936
And that's very easy to do, as

00:41:17.936 --> 00:41:18.106
well.

00:41:19.106 --> 00:41:20.796
And lastly, we're going to use a

00:41:20.796 --> 00:41:22.566
median technique to create a

00:41:22.566 --> 00:41:24.496
single photo from all the frames

00:41:24.496 --> 00:41:26.926
in the video in a way that

00:41:27.046 --> 00:41:29.106
produces an optimal image.

00:41:29.886 --> 00:41:31.416
The technique here is to produce

00:41:31.416 --> 00:41:33.166
an output image where, at each

00:41:33.166 --> 00:41:34.316
location of the output, we're

00:41:34.496 --> 00:41:36.266
going to look at locations in

00:41:36.266 --> 00:41:37.066
the input frames.

00:41:37.456 --> 00:41:38.776
And we're going to use the

00:41:38.776 --> 00:41:41.236
median value at each location.

00:41:41.486 --> 00:41:42.856
If you look in this example

00:41:42.856 --> 00:41:44.966
here, the first four images are

00:41:45.736 --> 00:41:47.496
that little spot is over the

00:41:47.496 --> 00:41:49.206
concrete pavement, but the fifth

00:41:49.206 --> 00:41:52.046
one is over the legs.

00:41:52.666 --> 00:41:54.016
Now, if we take the median of

00:41:54.126 --> 00:41:55.656
these five values, we're going

00:41:55.656 --> 00:41:56.726
to get a value that looks like

00:41:56.876 --> 00:41:57.676
just the concrete.

00:41:58.236 --> 00:41:59.066
If we do the same thing at

00:41:59.066 --> 00:42:00.436
another portion of the image,

00:42:00.626 --> 00:42:02.276
again, we're here underneath the

00:42:02.276 --> 00:42:02.706
tree.

00:42:02.946 --> 00:42:04.876
Three of the five frames are

00:42:04.876 --> 00:42:05.216
good.

00:42:05.266 --> 00:42:07.716
The other two are less good.

00:42:07.916 --> 00:42:08.926
So we're going to use the median

00:42:08.926 --> 00:42:10.426
of those, and if you do that for

00:42:10.426 --> 00:42:12.336
every pixel of an image, you get

00:42:12.516 --> 00:42:13.296
a great result.

00:42:13.296 --> 00:42:14.536
Where objects that are

00:42:14.536 --> 00:42:16.176
transitory in the video are

00:42:16.176 --> 00:42:17.066
magically removed.

00:42:17.526 --> 00:42:20.006
Let me talk a little bit about

00:42:20.006 --> 00:42:21.336
the code, and I promise we'll

00:42:21.336 --> 00:42:22.226
get to the demo at the end.

00:42:22.986 --> 00:42:24.576
The first step here is we're

00:42:24.576 --> 00:42:26.086
going to use Vision to determine

00:42:26.086 --> 00:42:27.866
the homographic registration for

00:42:27.866 --> 00:42:28.356
each frame.

00:42:28.716 --> 00:42:29.906
Again, this is quite easy.

00:42:30.096 --> 00:42:31.066
We're going to use Vision to

00:42:31.066 --> 00:42:32.836
create a request and a request

00:42:32.836 --> 00:42:35.386
handler to produce that

00:42:35.386 --> 00:42:36.086
information.

00:42:36.536 --> 00:42:38.226
We're going to tell Vision to

00:42:38.226 --> 00:42:39.276
perform that request.

00:42:40.416 --> 00:42:41.826
And then once we get the result,

00:42:41.826 --> 00:42:43.326
we'll ask for the result and

00:42:43.696 --> 00:42:45.076
make sure it is an object of

00:42:45.126 --> 00:42:47.836
type VNImageHomographic

00:42:48.776 --> 00:42:49.896
AlignmentObservation.

00:42:49.896 --> 00:42:50.606
Wow, that's a mouthful.

00:42:51.046 --> 00:42:52.556
And then we'll return that.

00:42:52.616 --> 00:42:54.906
That object is basically a 3 by

00:42:54.906 --> 00:42:55.616
3 matrix.

00:42:56.136 --> 00:42:59.156
Once we've returned that, we can

00:42:59.156 --> 00:43:01.076
then use Core Image to align the

00:43:01.076 --> 00:43:02.786
images based on this 3 by 3

00:43:02.786 --> 00:43:03.276
matrix.

00:43:03.586 --> 00:43:04.576
This is a little tricky, but

00:43:04.576 --> 00:43:05.956
it's actually very easy to do

00:43:06.216 --> 00:43:07.946
using a custom warp kernel

00:43:07.946 --> 00:43:08.576
written in Metal.

00:43:09.866 --> 00:43:11.356
You can see here in this kernel

00:43:11.686 --> 00:43:13.026
we now have a parameter which is

00:43:13.026 --> 00:43:14.056
a float3 by 3.

00:43:14.056 --> 00:43:15.026
This is something that's new to

00:43:15.026 --> 00:43:15.916
Core Image this year.

00:43:16.656 --> 00:43:17.696
And what we're going to do is

00:43:17.696 --> 00:43:18.746
we're going to get destCoord,

00:43:18.966 --> 00:43:20.396
convert that to a homogenous

00:43:20.396 --> 00:43:21.926
destCoord by adding a 1 to the

00:43:21.926 --> 00:43:22.096
end.

00:43:22.846 --> 00:43:24.096
We're then going to multiply

00:43:24.096 --> 00:43:26.956
that vector by the matrix and

00:43:26.956 --> 00:43:27.856
that gives us our

00:43:27.856 --> 00:43:29.696
homogenousSrcCoord.

00:43:29.696 --> 00:43:31.246
Then we're going to do a

00:43:31.246 --> 00:43:33.326
perspective divide to get us the

00:43:33.326 --> 00:43:34.356
source coordinate that we're

00:43:34.356 --> 00:43:35.076
going to sample from.

00:43:35.986 --> 00:43:37.246
And that's all there is to it.

00:43:39.086 --> 00:43:40.566
The last step is to apply the

00:43:40.566 --> 00:43:41.936
median filter in Core Image,

00:43:41.976 --> 00:43:43.896
and, in this example here, I'm

00:43:43.896 --> 00:43:45.196
illustrating the code that we

00:43:45.256 --> 00:43:47.406
use for a 5-image median.

00:43:48.046 --> 00:43:49.446
In fact, sometimes you have many

00:43:49.446 --> 00:43:50.516
more and we'll go into that

00:43:50.516 --> 00:43:51.126
during the demo.

00:43:51.636 --> 00:43:52.636
But, in this case, we're going

00:43:52.636 --> 00:43:54.506
to use a sorting network to

00:43:55.076 --> 00:43:56.716
determine what the median value

00:43:56.716 --> 00:43:58.366
of the five pixel samples are.

00:43:59.166 --> 00:44:00.336
Again, if we look here, this is

00:44:00.336 --> 00:44:02.076
a great example where writing

00:44:02.076 --> 00:44:03.616
this kernel in Metal was

00:44:03.616 --> 00:44:05.596
actually very convenient and

00:44:05.596 --> 00:44:07.116
easy, because now we can

00:44:07.116 --> 00:44:08.526
actually pass the values into

00:44:08.526 --> 00:44:11.076
this swap function by reference

00:44:11.136 --> 00:44:11.856
rather than value.

00:44:12.566 --> 00:44:15.016
So now for the fun part.

00:44:15.016 --> 00:44:16.956
I'm going to invite Sky up to

00:44:16.956 --> 00:44:17.416
the stage.

00:44:17.416 --> 00:44:18.326
He'll be showing you more about

00:44:18.326 --> 00:44:19.826
this and showing how this filter

00:44:19.826 --> 00:44:19.966
works.

00:44:22.516 --> 00:44:26.966
[ Applause ]

00:44:27.466 --> 00:44:27.736
>> All right.

00:44:27.736 --> 00:44:28.256
Thank you, David.

00:44:28.806 --> 00:44:30.566
Hi, my name is Sky and it's a

00:44:30.566 --> 00:44:31.586
pleasure for me to bring to you

00:44:31.586 --> 00:44:33.356
today this demo.

00:44:33.356 --> 00:44:34.716
As we can see here on the top,

00:44:34.716 --> 00:44:36.276
this is our input in video.

00:44:36.476 --> 00:44:38.446
And, if I scrub around on the

00:44:38.446 --> 00:44:40.506
slider, we can see that there's

00:44:40.506 --> 00:44:41.686
no point in time during the

00:44:41.686 --> 00:44:43.286
whole duration of the video that

00:44:43.286 --> 00:44:44.906
there's a clear image that we

00:44:44.906 --> 00:44:46.196
can take of the landmark.

00:44:46.766 --> 00:44:48.146
So, for example, at the

00:44:48.146 --> 00:44:49.376
beginning, we're obstructed by

00:44:49.376 --> 00:44:50.466
the shadow here.

00:44:50.506 --> 00:44:52.026
And then we have people passing

00:44:52.026 --> 00:44:52.376
by.

00:44:52.996 --> 00:44:54.186
So there's really just no point

00:44:54.186 --> 00:44:55.536
during the entire video where we

00:44:55.536 --> 00:44:56.446
can get a clean shot.

00:44:57.206 --> 00:45:00.576
And actually, if we zoom in on

00:45:00.576 --> 00:45:01.836
one of the corners, we can see

00:45:01.836 --> 00:45:03.056
that it's constantly shifting

00:45:03.286 --> 00:45:04.876
across the entire duration.

00:45:05.606 --> 00:45:06.806
So before we run the reduction

00:45:06.806 --> 00:45:08.386
kernel, we need to first align

00:45:08.386 --> 00:45:09.136
these frames.

00:45:09.246 --> 00:45:10.526
And the way we do that is using

00:45:10.526 --> 00:45:11.746
Vision, as David just mentioned.

00:45:12.546 --> 00:45:14.516
Now Vision offers two

00:45:14.546 --> 00:45:17.346
registration APIs, as shown here

00:45:17.346 --> 00:45:17.976
in the slider.

00:45:18.526 --> 00:45:20.736
We have a homographic line, and

00:45:20.736 --> 00:45:21.666
which David just mentioned, but

00:45:21.666 --> 00:45:22.776
Vision also offers a

00:45:22.776 --> 00:45:24.466
translational alignment which,

00:45:24.466 --> 00:45:25.556
in this case, doesn't work

00:45:25.556 --> 00:45:26.366
extremely well.

00:45:26.366 --> 00:45:27.666
It's because our camera movement

00:45:27.666 --> 00:45:29.376
is not restricted to one plane

00:45:29.376 --> 00:45:30.446
that is parallel to the image

00:45:31.346 --> 00:45:31.736
plane.

00:45:31.986 --> 00:45:33.356
So the way we're doing the

00:45:33.356 --> 00:45:34.406
stabilization is we're

00:45:34.406 --> 00:45:35.896
registering every frame during

00:45:35.896 --> 00:45:37.686
the video onto the middle frame.

00:45:38.076 --> 00:45:39.316
And so you can expect a pretty

00:45:39.316 --> 00:45:41.306
dramatic camera movement between

00:45:41.306 --> 00:45:42.566
the first frame and middle

00:45:42.566 --> 00:45:43.716
frame, which is why the

00:45:43.716 --> 00:45:45.226
homographic registration is

00:45:45.226 --> 00:45:46.156
going to work better for us in

00:45:46.156 --> 00:45:46.526
this case.

00:45:46.526 --> 00:45:48.886
So let's just go with that.

00:45:48.886 --> 00:45:50.486
So with that turned on, if I

00:45:50.486 --> 00:45:52.306
zoom in on this corner here

00:45:52.306 --> 00:45:54.586
again and scrub through, you can

00:45:54.636 --> 00:45:56.396
see that the point is barely

00:45:56.396 --> 00:45:58.806
moving across the entire frame.

00:45:59.496 --> 00:46:01.276
And if we go back and scrub

00:46:01.276 --> 00:46:02.936
through, the video becomes

00:46:02.936 --> 00:46:04.206
extremely stabilized.

00:46:05.266 --> 00:46:06.716
And so this gives you an idea,

00:46:06.756 --> 00:46:08.376
if you're like writing an image

00:46:08.376 --> 00:46:10.856
stabilization application, then

00:46:10.996 --> 00:46:12.136
you could easily do that with

00:46:12.136 --> 00:46:13.216
Core Image and Vision.

00:46:14.326 --> 00:46:15.786
So now let me jump into the

00:46:15.786 --> 00:46:16.566
reduction part.

00:46:17.146 --> 00:46:18.326
And the first thing I'd like to

00:46:18.326 --> 00:46:20.566
point out is doing a median

00:46:20.566 --> 00:46:23.286
reduction over what we have here

00:46:23.286 --> 00:46:24.866
is 148 frames.

00:46:25.046 --> 00:46:26.316
It's not really that practical

00:46:26.316 --> 00:46:27.416
because we need to hold all

00:46:27.416 --> 00:46:28.376
those frames in memory when

00:46:28.376 --> 00:46:29.116
we're sorting them.

00:46:29.786 --> 00:46:31.306
So what we do here instead is we

00:46:31.306 --> 00:46:33.276
take the median of median as an

00:46:33.276 --> 00:46:34.046
approximation.

00:46:34.466 --> 00:46:35.586
So the first thing we do is

00:46:35.586 --> 00:46:37.376
we're dividing entire frames,

00:46:37.516 --> 00:46:39.986
the 148 frames, into several

00:46:39.986 --> 00:46:40.356
groups.

00:46:40.896 --> 00:46:41.806
And for each one of those

00:46:41.806 --> 00:46:43.386
groups, we compute a local group

00:46:43.386 --> 00:46:43.796
median.

00:46:44.276 --> 00:46:45.626
And on the second pass, we run

00:46:45.626 --> 00:46:46.936
our reduction kernel again on

00:46:46.936 --> 00:46:48.306
the local medians to compute the

00:46:48.306 --> 00:46:50.196
final approximation results.

00:46:50.696 --> 00:46:51.766
Which is why we have this

00:46:51.766 --> 00:46:53.986
control here on the bottom, and

00:46:54.236 --> 00:46:56.526
these ticks here that shows you

00:46:56.526 --> 00:46:58.806
how the frames are grouped.

00:46:59.526 --> 00:47:01.476
And so, if I change this group

00:47:01.476 --> 00:47:03.466
count here, we can see that the

00:47:03.466 --> 00:47:04.486
indicators are changing.

00:47:04.486 --> 00:47:05.876
So, if we have a group count of

00:47:05.876 --> 00:47:07.136
three, that means we're dividing

00:47:07.136 --> 00:47:08.306
the entire video range into

00:47:08.306 --> 00:47:08.866
three groups.

00:47:09.416 --> 00:47:10.606
And for each one of those

00:47:10.606 --> 00:47:11.606
groups, I can change the group

00:47:11.606 --> 00:47:14.236
size, which indicates how many

00:47:14.236 --> 00:47:15.736
evenly distributed tasks we're

00:47:15.916 --> 00:47:17.716
taking out of the frames to use

00:47:17.716 --> 00:47:18.426
for our group median

00:47:18.426 --> 00:47:18.996
computation.

00:47:19.826 --> 00:47:21.066
So, with that in mind, let's try

00:47:21.066 --> 00:47:23.376
something with a group count of

00:47:23.616 --> 00:47:26.456
five and group size of seven,

00:47:26.606 --> 00:47:27.196
let's say.

00:47:28.166 --> 00:47:29.116
And let's just see what that

00:47:29.116 --> 00:47:29.646
gets us.

00:47:30.176 --> 00:47:32.596
It's going to take a little bit

00:47:32.596 --> 00:47:33.876
of time to run because Vision

00:47:33.876 --> 00:47:35.206
needs to do all the registration

00:47:35.206 --> 00:47:37.056
and we need to warp the images.

00:47:37.546 --> 00:47:39.226
And so, as we see here in the

00:47:39.226 --> 00:47:41.256
output, none of the moving

00:47:41.256 --> 00:47:42.726
transient objects were actually

00:47:42.726 --> 00:47:45.446
in our final reduced image, and

00:47:45.446 --> 00:47:47.326
we have a very clean shot of our

00:47:47.326 --> 00:47:48.946
landmark, which is exactly what

00:47:48.946 --> 00:47:49.256
we wanted.

00:47:49.726 --> 00:47:51.826
And, if we switch back between

00:47:51.906 --> 00:47:53.816
the input and the output, we can

00:47:53.816 --> 00:47:55.346
see that all textual details are

00:47:55.346 --> 00:47:57.146
very well preserved, which gives

00:47:57.146 --> 00:47:58.656
you an idea of how well Vision

00:47:58.656 --> 00:47:59.546
is doing the alignment.

00:48:00.176 --> 00:48:02.236
And so I hope this gives you a

00:48:02.236 --> 00:48:03.546
sense of like the interesting

00:48:03.546 --> 00:48:04.806
applications you can build with

00:48:04.806 --> 00:48:06.056
this nice synergy between Core

00:48:06.056 --> 00:48:07.146
Image and Vision.

00:48:08.026 --> 00:48:09.666
And with that, I'd like to

00:48:09.816 --> 00:48:11.516
invite David back onstage and to

00:48:11.516 --> 00:48:11.976
give you a recap.

00:48:12.516 --> 00:48:18.176
[ Applause ]

00:48:18.676 --> 00:48:19.046
>> All right.

00:48:19.046 --> 00:48:20.276
Well, thank you all so much.

00:48:20.806 --> 00:48:22.286
Let me just give just a summary

00:48:22.286 --> 00:48:23.536
of what we talked about today.

00:48:23.606 --> 00:48:25.046
Again, our primary goals for

00:48:25.046 --> 00:48:26.446
this release was to give your

00:48:26.446 --> 00:48:27.936
applications better performance,

00:48:28.596 --> 00:48:29.776
better information about how

00:48:29.826 --> 00:48:32.196
Core Image works, and great new

00:48:32.196 --> 00:48:32.986
functionality.

00:48:33.326 --> 00:48:34.626
And we really look forward to

00:48:34.626 --> 00:48:36.226
seeing how your applications can

00:48:36.776 --> 00:48:39.196
grow this year based on this new

00:48:39.426 --> 00:48:40.196
functionality.

00:48:40.696 --> 00:48:43.266
So we look forward to you coming

00:48:43.516 --> 00:48:45.316
to some of our related sessions.

00:48:45.616 --> 00:48:46.986
If you look -- need more

00:48:46.986 --> 00:48:48.036
information, please go to

00:48:48.036 --> 00:48:50.346
developer.apple.com website.

00:48:50.986 --> 00:48:52.246
There are some related sessions

00:48:52.246 --> 00:48:53.326
that are definitely worth

00:48:53.326 --> 00:48:53.776
watching.

00:48:53.776 --> 00:48:54.886
There was a session earlier

00:48:54.886 --> 00:48:57.196
today called image editing with

00:48:57.276 --> 00:48:59.646
depth, as well as sessions on

00:48:59.646 --> 00:49:02.576
Vision framework and sessions on

00:49:02.576 --> 00:49:04.816
capturing data with depth.

00:49:05.026 --> 00:49:06.266
Thank you so much for coming and

00:49:06.266 --> 00:49:07.716
have a great rest of your show.

00:49:07.716 --> 00:49:07.966
Thanks.

00:49:08.508 --> 00:49:10.508
[ Applause ]
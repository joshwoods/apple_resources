WEBVTT

00:00:07.516 --> 00:00:17.500
[ Music ]

00:00:21.516 --> 00:00:28.466
[ Applause ]

00:00:28.966 --> 00:00:31.946
>> Good afternoon and welcome
to debugging tips and tricks.

00:00:32.665 --> 00:00:34.926
It warms my heart to see
this many people turn

00:00:34.926 --> 00:00:36.416
out for this topic.

00:00:36.726 --> 00:00:37.966
It's near and dear to my heart.

00:00:38.526 --> 00:00:39.446
My name is Kate Stone

00:00:39.446 --> 00:00:41.386
and I manage the core
team that's responsible

00:00:41.386 --> 00:00:43.266
for debugging technology
here at Apple.

00:00:43.796 --> 00:00:45.236
So again it's really exciting.

00:00:45.476 --> 00:00:47.876
I hope we'll be able to bring
up a number of engineers

00:00:47.876 --> 00:00:51.176
from my team to tell you
things that might be novel

00:00:51.176 --> 00:00:54.596
if you're just starting but
also tips that might be new

00:00:54.596 --> 00:00:56.846
to you even if you've been
debugging on our platforms

00:00:56.846 --> 00:00:58.406
for the last ten years.

00:00:58.736 --> 00:01:02.126
It really is a deep area and
we've got a lot of great content

00:01:02.126 --> 00:01:03.256
for you so let's get started.

00:01:05.006 --> 00:01:08.406
Specifically we should note
that LLDB is the technology

00:01:08.406 --> 00:01:09.296
that I'm talking about.

00:01:09.536 --> 00:01:11.616
If you've used Xcode for
debugging, you may not be aware

00:01:11.616 --> 00:01:14.966
that behind the scenes there's
this technology called LLDB,

00:01:14.966 --> 00:01:16.876
the low level debugger,
providing all

00:01:16.876 --> 00:01:19.476
of the core technology,
and it's not just

00:01:19.476 --> 00:01:21.466
in Xcode it's everywhere
you need it.

00:01:21.786 --> 00:01:24.346
But of course one of the more
common places you'll encounter

00:01:24.686 --> 00:01:27.126
it is in Xcode in
the debug console.

00:01:27.916 --> 00:01:30.846
Xcode hosts that console as
part of your debugging area,

00:01:32.006 --> 00:01:33.636
and you'll see of course
the variables viewed

00:01:33.636 --> 00:01:37.186
but also this LLDB console and
that's a lot of what we're going

00:01:37.186 --> 00:01:38.466
to be talking about here today.

00:01:38.976 --> 00:01:40.746
That prompted and
the wonderful things

00:01:40.746 --> 00:01:42.276
that you can do from
that prompt.

00:01:44.966 --> 00:01:48.786
Of course that area contains
normally not just LLDB's prompt

00:01:48.786 --> 00:01:50.436
and allow to interact
with the debugger

00:01:50.756 --> 00:01:52.786
but it also contains
your application's output

00:01:52.926 --> 00:01:54.336
and allows you to
type input to it

00:01:54.616 --> 00:01:56.076
for console based applications.

00:01:56.906 --> 00:01:58.726
That may not be the
most convenient way

00:01:58.726 --> 00:02:00.396
in case your application
takes advantage

00:02:00.396 --> 00:02:03.816
of other console features like
moving the cursor or colors,

00:02:03.816 --> 00:02:05.846
other ANSI cursor
manipulation features.

00:02:05.846 --> 00:02:09.346
So there's a new option
in Xcode 8 that allows you

00:02:09.346 --> 00:02:10.996
to use a standalone terminal

00:02:11.156 --> 00:02:13.856
for your application
while LLDB remains

00:02:14.016 --> 00:02:15.416
in Xcode and it's simple.

00:02:16.036 --> 00:02:18.976
Bring up the scheme options
and in the options tab

00:02:18.976 --> 00:02:21.666
at the very bottom you'll see
this new console that allows you

00:02:21.666 --> 00:02:23.906
to switch from the
default to use Xcode

00:02:24.676 --> 00:02:25.866
to use terminal instead.

00:02:25.866 --> 00:02:28.476
And then when you run you'll
get a separate terminal

00:02:28.536 --> 00:02:30.906
for your application's input
and output separate from Xcode.

00:02:31.516 --> 00:02:37.546
[ Applause ]

00:02:38.046 --> 00:02:40.536
For the remainder of the talk
we'll be really focused on LLDB.

00:02:40.586 --> 00:02:43.196
So if you're interested in
other Xcode specific features,

00:02:43.596 --> 00:02:45.416
definitely check out the
two talks noted here.

00:02:45.576 --> 00:02:46.866
Of course they've past by now

00:02:47.136 --> 00:02:48.916
but the videos are there
and waiting for you.

00:02:50.786 --> 00:02:53.456
You should also note that
LLDB is not just part of Xcode

00:02:53.746 --> 00:02:57.126
but the Swift REPL
is in fact LLDB.

00:02:57.566 --> 00:03:00.006
When you bring up the Swift REPL
and start interacting with it,

00:03:00.246 --> 00:03:02.756
you're interacting inside a
debugging environment already

00:03:02.986 --> 00:03:03.646
so that the power

00:03:03.646 --> 00:03:05.726
of the debugger is there
any time you need it.

00:03:06.076 --> 00:03:07.796
In fact every command
that we tell you

00:03:07.796 --> 00:03:10.416
about here you can use directly
from within the REPL just

00:03:10.416 --> 00:03:12.766
by prefixing it with a
colon from the REPL prompt.

00:03:13.226 --> 00:03:16.016
So colon followed by command
will issue the command directly

00:03:16.046 --> 00:03:16.926
to LLDB.

00:03:17.766 --> 00:03:19.686
So let's say I'm at
the Swift REPL prompt.

00:03:20.216 --> 00:03:22.866
At this point I'm interested
in looking up some information

00:03:22.866 --> 00:03:25.656
on a type and of course I
could bring up Xcode and look

00:03:25.656 --> 00:03:28.766
at the help, but right from the
prompt here I could go ahead

00:03:28.766 --> 00:03:31.416
and simply say colon
type lookup comparable.

00:03:31.556 --> 00:03:33.966
And I'll have looked up this
protocol and found out that

00:03:33.966 --> 00:03:35.976
in fact it derives
from another protocol

00:03:35.976 --> 00:03:37.546
and adds the following
four functions.

00:03:38.366 --> 00:03:39.826
If you're familiar
with type lookup,

00:03:39.826 --> 00:03:42.086
it's a great feature
you use it all the time

00:03:42.086 --> 00:03:43.896
but you may not be
aware of the fact

00:03:43.946 --> 00:03:46.416
that despite the name type
lookup it can actually be used

00:03:46.416 --> 00:03:48.016
to lookup a wider
range of things.

00:03:48.046 --> 00:03:50.846
I can actually lookup functions
to get the complete signature

00:03:51.356 --> 00:03:55.166
or even lookup entire modules,
and of course this a lot

00:03:55.166 --> 00:03:57.246
of content as it will
be the full declaration

00:03:57.246 --> 00:03:58.876
of every type in that module.

00:03:59.166 --> 00:04:00.216
We've abbreviated it here.

00:04:02.136 --> 00:04:04.386
So the REPL is fantastic
for these kinds

00:04:04.386 --> 00:04:08.896
of additional commands but
it's also useful if you want

00:04:08.896 --> 00:04:11.546
to interact with the code
you're writing in the REPL.

00:04:11.906 --> 00:04:13.426
Let's say I write a
simple function here.

00:04:14.296 --> 00:04:16.786
I've written a function,
I'd like to stop when I'm

00:04:16.826 --> 00:04:19.375
in the function and find out
what's going on at a given line,

00:04:19.646 --> 00:04:22.416
so I can issue the breakpoint
command by prefixing it

00:04:22.416 --> 00:04:25.406
with a colon, colon b 2, I
set a breakpoint at line two

00:04:25.406 --> 00:04:28.606
and when I call this function,
execution stops as I'd expect.

00:04:29.226 --> 00:04:32.376
And because execution has
stopped it switches immediately

00:04:32.376 --> 00:04:35.506
to the LLDB prompt and from the
LLDB prompt I can issue other

00:04:35.576 --> 00:04:39.156
LLDB commands to interact with
and explore my application.

00:04:39.456 --> 00:04:42.116
And the REPL will also do
this automatically if you run

00:04:42.116 --> 00:04:43.776
into an overflow
condition or other things

00:04:43.776 --> 00:04:45.476
that would normally
terminate your application

00:04:45.586 --> 00:04:47.226
so that you can take
advantage of the full power

00:04:47.226 --> 00:04:49.146
of the debugger directly
from the Swift REPL.

00:04:49.546 --> 00:04:51.816
You should also note
that you can switch

00:04:51.866 --> 00:04:53.526
between the two prompts
at any time.

00:04:53.836 --> 00:04:57.056
If you're at the REPL prompt
a colon on its own followed

00:04:57.056 --> 00:04:59.536
by enter will bring
up the LLDB prompt,

00:04:59.996 --> 00:05:02.566
and the command REPL will
switch back to the REPL prompt

00:05:02.786 --> 00:05:05.016
so you can use the two
interchangeably at any time.

00:05:05.546 --> 00:05:07.226
The REPL has slightly
different characteristics

00:05:07.316 --> 00:05:09.506
and may even be desirable
within a debugging session

00:05:09.506 --> 00:05:10.726
where you're debugging
Swift code.

00:05:12.636 --> 00:05:13.536
So that's great.

00:05:14.086 --> 00:05:17.156
It's a couple of the key ways a
lot of people interact with LLDB

00:05:17.216 --> 00:05:20.206
but LLDB is also a
standalone command line tool

00:05:20.606 --> 00:05:23.716
and that's fantastic if I'm a
remote shell into a machine,

00:05:23.716 --> 00:05:25.856
I have a very slow
connection, I really want

00:05:25.906 --> 00:05:28.736
to use typical benefits
of a command line tool.

00:05:29.086 --> 00:05:31.196
But it's also useful
under other circumstances.

00:05:31.286 --> 00:05:33.306
You might want to use it
for example if you're going

00:05:33.306 --> 00:05:34.826
to automate debugging tasks.

00:05:35.146 --> 00:05:38.276
I want to setup my debugger the
same way every time I start it,

00:05:38.616 --> 00:05:42.516
so I might go ahead and provide
a file containing a whole bunch

00:05:42.546 --> 00:05:44.216
of LLDB commands to
configure things.

00:05:44.536 --> 00:05:49.606
LLDB -- source followed by
a file name will invoke LLDB

00:05:49.746 --> 00:05:51.276
and source all of those commands

00:05:51.276 --> 00:05:53.336
to setup my debug session
just the way I want it.

00:05:53.336 --> 00:05:56.246
If you don't want to go
through the trouble of setting

00:05:56.246 --> 00:05:59.846
up a file, you can invoke LLDB
and provide commands directly

00:05:59.846 --> 00:06:04.566
on the command line; -- one-line
will be followed by command

00:06:04.566 --> 00:06:06.656
and that will be issued
as soon as I start LLDB,

00:06:06.656 --> 00:06:09.166
and if I want additional
commands,

00:06:09.436 --> 00:06:11.076
I can just repeat
the option here

00:06:11.076 --> 00:06:14.106
in its abbreviated form -o
followed by another command

00:06:14.346 --> 00:06:15.406
as many times as I like.

00:06:16.116 --> 00:06:17.266
So it can be really trivial

00:06:17.266 --> 00:06:20.476
to setup LLDB just the way I
want it in an automated script.

00:06:20.986 --> 00:06:24.056
And of course this is especially
valuable in a situation

00:06:24.326 --> 00:06:27.406
where I have an application
that fails only one

00:06:27.406 --> 00:06:28.636
out of a hundred times.

00:06:28.636 --> 00:06:30.226
It's a race condition, I'd

00:06:30.226 --> 00:06:32.906
like to run the same debugging
sequence over and over again

00:06:33.146 --> 00:06:34.706
and we have a special
option for that as well.

00:06:35.756 --> 00:06:38.836
LLDB -- batch starts
a batch mode.

00:06:39.086 --> 00:06:41.676
It will execute the instructions
that I provided either

00:06:41.676 --> 00:06:43.806
from one line or
sourced from file

00:06:44.446 --> 00:06:47.286
and presuming my application
completes normally it will

00:06:47.286 --> 00:06:48.036
then exit.

00:06:49.026 --> 00:06:51.436
If my application
crashes, it will stop right

00:06:51.436 --> 00:06:53.836
at the LLDB prompt where I
can investigate the problem.

00:06:54.616 --> 00:06:56.366
And of course just
by wrapping this

00:06:56.726 --> 00:06:59.376
with a few other shell commands
I can repeat that series

00:06:59.376 --> 00:07:01.706
of actions ad infinitum
or at least

00:07:01.856 --> 00:07:03.756
until my application
crashes and I'm ready

00:07:03.756 --> 00:07:04.926
to investigate the problem.

00:07:07.146 --> 00:07:09.376
LLDB has a wide range
of options.

00:07:09.656 --> 00:07:10.706
If you haven't looked at LLDB --

00:07:10.706 --> 00:07:13.106
help before, I'd encourage
you to have a look.

00:07:13.156 --> 00:07:15.036
It describes these
options and many more.

00:07:16.956 --> 00:07:20.686
I'm going to introduce one
really interesting concept here

00:07:20.686 --> 00:07:24.276
for us as a team that's actually
probably the least important

00:07:24.276 --> 00:07:25.536
thing in this entire talk.

00:07:25.536 --> 00:07:27.786
So if you've going to forget
one slide, please start

00:07:27.786 --> 00:07:31.326
with this one because
it's largely transparent.

00:07:31.516 --> 00:07:32.986
You shouldn't really
notice the effects

00:07:33.046 --> 00:07:34.736
but there are some
subtle aspects of it

00:07:34.736 --> 00:07:35.866
that I want to introduce.

00:07:36.156 --> 00:07:38.496
Starting with Xcode 8, LLDB runs

00:07:38.496 --> 00:07:40.916
in a completely separate
process from Xcode.

00:07:41.226 --> 00:07:42.516
It's totally transparent to you.

00:07:42.616 --> 00:07:45.406
You start debugging the way
you normally did and what

00:07:45.406 --> 00:07:48.346
that allows us to do is support
multiple different versions

00:07:48.696 --> 00:07:49.416
of the debugger.

00:07:50.316 --> 00:07:51.746
It's selected for
you automatically,

00:07:52.066 --> 00:07:55.566
so if I go to debug Swift 3
I get the latest debugger,

00:07:55.566 --> 00:07:56.906
I get all of the
features that we're going

00:07:56.906 --> 00:07:58.166
to introduce in this session.

00:07:58.416 --> 00:08:01.736
And in fact if I'm using
pure C++ or Objective C,

00:08:02.036 --> 00:08:03.036
the same thing is true.

00:08:03.036 --> 00:08:04.916
I get the latest
debugger with all

00:08:04.916 --> 00:08:06.196
of the features we'll
talk about here.

00:08:07.276 --> 00:08:09.516
On the other hand, if
I'm debugging Swift 2.3,

00:08:09.716 --> 00:08:12.326
I'm going to wind up with the
debugger that's essentially what

00:08:12.326 --> 00:08:16.276
we shipped earlier this
year with Xcode 7.3.1.

00:08:16.786 --> 00:08:18.706
That means some of the newer
commands won't be available,

00:08:18.916 --> 00:08:22.056
but we have the full support
of the debugger from the era

00:08:22.056 --> 00:08:23.866
of the Swift compiler.

00:08:24.916 --> 00:08:27.876
But most importantly
perhaps if you're part

00:08:27.876 --> 00:08:30.136
of our open source
community, you'll be able

00:08:30.136 --> 00:08:32.456
to debug using the
version of the debugger

00:08:32.456 --> 00:08:35.246
that matches the open source
Swift that you're using.

00:08:35.525 --> 00:08:38.566
So if you download a snapshot of
our work in progress or indeed

00:08:38.566 --> 00:08:40.186
if your start adding
to it yourself,

00:08:40.596 --> 00:08:42.706
you will have a debugger
that's immediately available

00:08:42.916 --> 00:08:44.496
and you can actually
use that concurrently

00:08:44.606 --> 00:08:48.516
with debugging other programs
written in Swift 3 or Swift 2.3

00:08:48.796 --> 00:08:50.636
and everything is
completely transparent.

00:08:52.156 --> 00:08:55.886
There is one additional benefit
here which is that if LLDB gets

00:08:55.886 --> 00:08:58.906
into a situation where it cannot
proceed and it needs to shut

00:08:58.906 --> 00:09:00.036
down the debugging session,

00:09:00.306 --> 00:09:01.686
the debug session
will be terminated,

00:09:01.886 --> 00:09:05.086
LLDB can exit gracefully,
and Xcode will stay running.

00:09:09.166 --> 00:09:12.726
To talk about what you can
do with LLDB a powerful tool

00:09:12.726 --> 00:09:15.406
that it is and how you can
customize your experience,

00:09:15.406 --> 00:09:18.266
I'm going to invite up one of
my engineers Enrico Granata.

00:09:19.516 --> 00:09:24.866
[ Applause ]

00:09:25.366 --> 00:09:26.046
>> Thank you, Kate.

00:09:26.046 --> 00:09:26.586
Hi, everyone.

00:09:27.366 --> 00:09:28.576
One of my favorite things

00:09:28.576 --> 00:09:32.146
about LLDB is how customizable
of a debugger it is.

00:09:32.666 --> 00:09:35.486
It's not only great fun
to work in the technology

00:09:35.486 --> 00:09:38.836
that enables this, but it's
also an amazing way for you

00:09:38.836 --> 00:09:41.356
to be more productive in
debugging your applications,

00:09:41.716 --> 00:09:45.366
and LLDB offers a
great many entry points

00:09:45.366 --> 00:09:46.246
for you to customize it.

00:09:46.876 --> 00:09:49.776
You can start with command
aliases and then work your way

00:09:49.776 --> 00:09:52.976
to custom commands or
custom data formatters

00:09:53.296 --> 00:09:56.226
and in Xcode 8 we have
one new extension point

00:09:56.226 --> 00:09:58.486
for you; stepping actions.

00:09:59.106 --> 00:10:02.676
The way to think about
stepping actions is do you

00:10:02.676 --> 00:10:04.366
like what the next command does?

00:10:04.516 --> 00:10:06.106
Do you like what the
step command does?

00:10:06.356 --> 00:10:09.376
But do you find yourself
wanting to tweak its behavior

00:10:09.376 --> 00:10:11.566
in just one or two little
ways here and there?

00:10:11.996 --> 00:10:14.566
With stepping actions
you can actually do that.

00:10:15.756 --> 00:10:20.016
But the simplest way to
get LLDB, to customize LLDB

00:10:20.016 --> 00:10:23.876
to suit your needs is to create
a command alias which is a way

00:10:24.096 --> 00:10:26.026
to take a piece of
debugger syntax

00:10:26.066 --> 00:10:27.606
for something you frequently do

00:10:27.836 --> 00:10:30.536
and attach a shorter
piece of syntax to it.

00:10:31.086 --> 00:10:36.386
And now in Xcode 8 we also
let you attach help text to it

00:10:36.716 --> 00:10:38.956
so that for your own purposes

00:10:39.136 --> 00:10:41.566
or for whoever you
share those aliases

00:10:41.566 --> 00:10:44.096
with you can remember
what the alias is up to.

00:10:44.776 --> 00:10:45.706
Let's see an example.

00:10:46.576 --> 00:10:48.846
First of all, to create
an alias you start

00:10:48.846 --> 00:10:50.376
with the command alias command.

00:10:50.906 --> 00:10:55.456
Then as I said you can pass
help text to it, you provide us

00:10:55.496 --> 00:10:59.376
with a short syntax, and then
you give us the full debugger

00:10:59.376 --> 00:11:00.676
command you want to replace.

00:11:01.176 --> 00:11:05.646
And now shell is just as normal
a debugger command as any

00:11:05.646 --> 00:11:07.326
of the ones we built into it.

00:11:07.626 --> 00:11:10.196
You can for instance say
help shell and it will

00:11:10.196 --> 00:11:13.596
so you help text including
that which you provided to us.

00:11:14.316 --> 00:11:16.356
And for those situations

00:11:16.356 --> 00:11:20.396
where debugging becomes a little
gnarly and you tend to forget

00:11:20.436 --> 00:11:23.816
who you are as you pursue your
bugs, you can ask the debugger

00:11:23.816 --> 00:11:26.806
to remind you your identity
and it will tell you

00:11:26.806 --> 00:11:28.656
that it looks like I'm Enrico.

00:11:28.916 --> 00:11:33.146
And that's great but if you want
to do something more advanced

00:11:33.206 --> 00:11:35.486
than simply attach a new
name to an existing command,

00:11:35.926 --> 00:11:37.966
we also vend you a Python API.

00:11:38.596 --> 00:11:40.436
It's a fairly extensive
option model

00:11:40.436 --> 00:11:43.006
that lets you band the
debugger to your will.

00:11:43.946 --> 00:11:46.346
Getting started is
easier than ever.

00:11:46.766 --> 00:11:50.266
We've talked about this at great
length in previous WWDC sessions

00:11:50.336 --> 00:11:51.686
which you can find online.

00:11:52.296 --> 00:11:54.826
We have a website with
documentation and examples

00:11:54.826 --> 00:11:59.366
to look at and if you
just search for it online,

00:11:59.646 --> 00:12:01.746
there's a community that's
doing wonderful things

00:12:01.746 --> 00:12:03.056
around scripting LLDB.

00:12:03.266 --> 00:12:05.406
Let me give you a quick example.

00:12:06.086 --> 00:12:07.766
Let's say that I want a command

00:12:07.896 --> 00:12:11.676
that lets me retrieve the return
value for the last function

00:12:11.676 --> 00:12:13.676
that I exited out
of while debugging.

00:12:14.616 --> 00:12:15.746
Couple caveats here.

00:12:16.286 --> 00:12:19.526
This command will work
only if you finish your way

00:12:19.526 --> 00:12:23.196
out of a function and don't
execute any stepping actions

00:12:23.196 --> 00:12:23.876
right after.

00:12:24.176 --> 00:12:26.386
You can type expressions,
you can look at variables,

00:12:26.826 --> 00:12:28.656
just don't step around
and this will work.

00:12:29.016 --> 00:12:30.416
Let's look at an
example real quick.

00:12:31.076 --> 00:12:34.776
First of all, you import a
file that contains that command

00:12:35.266 --> 00:12:37.766
and then as I said
finish out of the function

00:12:38.066 --> 00:12:40.456
and the return values is
right there for you to see.

00:12:40.716 --> 00:12:41.836
Okay, that's great.

00:12:41.836 --> 00:12:44.446
That happens by default, no
need for customization here.

00:12:44.776 --> 00:12:48.196
But what if I type
backtrace for example

00:12:48.556 --> 00:12:51.226
and that's quite a
verbose backtrace

00:12:51.366 --> 00:12:53.696
and now I don't remember
where the return value is.

00:12:54.056 --> 00:12:56.616
Okay, I could go up in the
terminal and try to dig it up

00:12:56.996 --> 00:13:01.046
but luckily enough we actually
made a command that will tell us

00:13:01.046 --> 00:13:05.486
about it, and here that return
value is again for us to see.

00:13:06.816 --> 00:13:09.616
This is all it takes
to make that happen.

00:13:09.926 --> 00:13:12.126
And by the way don't
really worry about reading

00:13:12.126 --> 00:13:15.146
that slide now, it will just be
online waiting for you later.

00:13:16.266 --> 00:13:19.576
On the other hand, you see
that it is slide of text

00:13:19.916 --> 00:13:23.376
and now you can type your shell
alias, you can type the text,

00:13:23.756 --> 00:13:25.676
and you'll find yourself
typing this

00:13:25.676 --> 00:13:27.746
because they're awesome every
time you start debugging

00:13:27.926 --> 00:13:29.746
and you'll type them
again and again and again

00:13:29.946 --> 00:13:31.366
until you're a literal
typing monkey

00:13:31.366 --> 00:13:32.936
and all you're actually
doing is typing these

00:13:32.936 --> 00:13:34.286
debugger customizations.

00:13:34.956 --> 00:13:36.886
Nope. I say no to that.

00:13:37.226 --> 00:13:40.446
I say save yourselves
from repetitive typing.

00:13:41.006 --> 00:13:41.976
There's no need to do that.

00:13:42.146 --> 00:13:44.166
LLDB has an initialization file.

00:13:44.646 --> 00:13:48.526
It's called .llbdinit and
it sits in your home folder.

00:13:49.476 --> 00:13:50.496
And if you need LLDB

00:13:50.496 --> 00:13:53.236
to do something special
something different

00:13:53.236 --> 00:13:56.506
when launched under Xcode
versus under the terminal,

00:13:57.736 --> 00:14:01.776
there's a .llbdinit -Xcode
file that will be preferred

00:14:02.126 --> 00:14:04.516
when launched in the
debugger under Xcode.

00:14:05.356 --> 00:14:06.156
One more trick.

00:14:06.756 --> 00:14:09.736
If you have Python commands that
you need at debugger start up,

00:14:10.096 --> 00:14:12.856
don't try to type
them in .llbdinit.

00:14:13.196 --> 00:14:17.206
Put them in a .py file and
then source the .py file

00:14:17.576 --> 00:14:21.106
that in LLDB init with
command script import.

00:14:23.276 --> 00:14:26.176
Those of you that have used LLDB

00:14:26.176 --> 00:14:28.926
for a while are probably
fairly familiar

00:14:28.926 --> 00:14:30.616
with the p and po commands.

00:14:31.316 --> 00:14:34.396
These are great commands,
they're great ways to look

00:14:34.396 --> 00:14:37.626
at data because they
are full expressions.

00:14:38.156 --> 00:14:39.626
They have the entire power

00:14:39.626 --> 00:14:42.556
of the language you're writing
your application in available

00:14:42.556 --> 00:14:44.056
for you at the debugger console.

00:14:44.146 --> 00:14:47.146
On the other hand,
with great power comes

00:14:47.176 --> 00:14:48.296
great responsibility.

00:14:49.236 --> 00:14:52.576
These commands run coding
your target process.

00:14:52.796 --> 00:14:55.336
They have potential
to cause side effects

00:14:55.746 --> 00:14:59.006
and also sometimes
it's just not possible

00:14:59.006 --> 00:15:00.566
to run the code you
want at the point

00:15:00.566 --> 00:15:01.756
where you're currently stopped.

00:15:01.986 --> 00:15:07.536
And if p runs code once, po
will actually run code twice

00:15:07.966 --> 00:15:10.606
because not only does it
evaluate the expression you

00:15:10.606 --> 00:15:14.506
provide it also uses
it also evaluates code

00:15:14.626 --> 00:15:17.256
to print the customization
to show your type

00:15:17.546 --> 00:15:21.746
in a way that's customizable
by type authors which is great

00:15:22.206 --> 00:15:25.206
if the type author customized
the display for their type

00:15:25.506 --> 00:15:27.076
in exactly the way you want it.

00:15:27.746 --> 00:15:28.996
If you're not that lucky,

00:15:29.336 --> 00:15:31.526
the p command provides
an alternative viewpoint

00:15:31.526 --> 00:15:33.776
of variables that may be
closer to what you want.

00:15:34.516 --> 00:15:36.706
And also po is also a command

00:15:36.706 --> 00:15:39.486
that runs again twice
coding your target process

00:15:39.666 --> 00:15:41.606
with all the potential
for side effects.

00:15:42.716 --> 00:15:45.716
If that scares you, we have
another command to look

00:15:45.716 --> 00:15:48.086
at variables; frame variable.

00:15:48.566 --> 00:15:50.376
This is a very predictable
command,

00:15:50.586 --> 00:15:52.366
it will not run any code.

00:15:53.016 --> 00:15:55.176
On the other hand,
because it doesn't have

00:15:55.176 --> 00:15:56.416
that code running ability,

00:15:56.786 --> 00:15:59.856
the syntax it offers is
also extremely limited.

00:16:00.526 --> 00:16:04.026
And that's quite a few ways
to look at data already

00:16:04.516 --> 00:16:08.886
but spoiler alert, in
Xcode 8 we have more.

00:16:09.586 --> 00:16:15.876
Two new ones parray and
poarray, and yes you're right.

00:16:16.016 --> 00:16:17.656
They sound a lot like p and po

00:16:17.956 --> 00:16:20.336
but they do something
special for arrays.

00:16:21.496 --> 00:16:23.286
What do they do especially
for arrays?

00:16:24.056 --> 00:16:29.316
Well, if you have used
NS array in Objective C

00:16:29.586 --> 00:16:33.196
or Swift arrays you're
used to the safe container

00:16:33.196 --> 00:16:35.766
that knows how many
things it contains.

00:16:36.366 --> 00:16:38.076
C pointers don't do that.

00:16:38.376 --> 00:16:40.856
C pointers don't come with a
kind of batteries included.

00:16:41.086 --> 00:16:44.426
They don't know how many
elements they point to and so

00:16:44.606 --> 00:16:49.326
when we print a C pointer like
this example in the debugger all

00:16:49.326 --> 00:16:51.596
that we're told is
the pointer value.

00:16:52.526 --> 00:16:54.576
But now we know that this
points to a bunch of elements

00:16:54.776 --> 00:16:56.726
so we can start printing
the first one,

00:16:57.196 --> 00:17:00.446
printing the second one and we
keep going and now we're back

00:17:00.446 --> 00:17:03.236
to the little typing monkey
situation which we don't like.

00:17:04.925 --> 00:17:10.296
Well, in Xcode 8 you can say
parray, number of elements,

00:17:10.586 --> 00:17:13.846
pointer and it will
expand for you that pointer

00:17:13.886 --> 00:17:16.976
as if it was an array of the
element count you specified.

00:17:17.516 --> 00:17:19.675
[ Applause ]

00:17:20.175 --> 00:17:21.056
Thank you.

00:17:22.465 --> 00:17:25.175
That's already nice
but why do I have

00:17:25.226 --> 00:17:26.796
to guess at the element count?

00:17:27.566 --> 00:17:28.616
It's right there.

00:17:28.766 --> 00:17:29.966
We have the count right there.

00:17:30.296 --> 00:17:35.066
What I really want is being able
to type parray count dataset.

00:17:36.546 --> 00:17:37.716
I almost can.

00:17:37.716 --> 00:17:40.906
All I have to do is
put count in backticks.

00:17:41.506 --> 00:17:45.186
That backtick is a general
LLDB syntax facility

00:17:45.516 --> 00:17:48.106
which lets you take an
expression, evaluate it

00:17:48.336 --> 00:17:50.086
and replace the value
of that expression

00:17:50.086 --> 00:17:52.006
in the command before
executing it.

00:17:52.736 --> 00:17:55.316
And now I've got my
full array shown.

00:17:57.516 --> 00:18:01.226
[ Applause ]

00:18:01.726 --> 00:18:02.206
Thank you.

00:18:02.236 --> 00:18:04.556
Pretty much the same
thing works for po.

00:18:04.556 --> 00:18:08.016
poarray, number of
elements, pointer

00:18:08.016 --> 00:18:10.876
and I get po style
descriptions of objects.

00:18:11.926 --> 00:18:15.356
On that same topic of po,
I'm sure that those of you

00:18:15.356 --> 00:18:19.066
that could write Objective C
code, quite a few I'm sure,

00:18:19.066 --> 00:18:22.266
have actually done something
just like that probably

00:18:22.266 --> 00:18:24.006
without even thinking about it.

00:18:24.346 --> 00:18:27.646
You take po, you say po followed
by a number that you happen

00:18:27.646 --> 00:18:29.046
to know is a pointer value

00:18:29.266 --> 00:18:30.956
and you get a pretty
description back.

00:18:31.816 --> 00:18:34.146
And you try doing the
same thing in Swift

00:18:34.696 --> 00:18:35.906
and all you get back
is a number.

00:18:36.256 --> 00:18:37.796
Why? What's going on?

00:18:38.786 --> 00:18:42.176
Well, I'm sure you've heard
this quite a few times

00:18:42.176 --> 00:18:43.836
but I'll say it one more time.

00:18:44.186 --> 00:18:46.826
Swift is a type safer
language than Objective C.

00:18:47.266 --> 00:18:50.236
We can't assume that numbers
are arbitrarily objects

00:18:50.236 --> 00:18:53.306
because not all Swift objects
have a pointer value connected

00:18:53.306 --> 00:18:53.646
to them.

00:18:54.056 --> 00:18:57.456
So when we say po a number
we'll show you the number.

00:18:58.506 --> 00:19:00.226
Okay, that's great but come

00:19:00.226 --> 00:19:02.146
on I know there's an
object there just show it

00:19:02.146 --> 00:19:02.876
to me already.

00:19:03.406 --> 00:19:04.806
There's a way to do that.

00:19:06.686 --> 00:19:07.956
There it is.

00:19:08.156 --> 00:19:10.456
It looks like a lot of words,
I know it looks like a lot

00:19:10.456 --> 00:19:13.026
of words but it's actually
just follow me for a second.

00:19:13.356 --> 00:19:15.296
Expr -O just means po.

00:19:15.586 --> 00:19:20.156
If you're at the LLDB
console and you say help po,

00:19:20.156 --> 00:19:24.486
what it will tell you is that
it's an alias for expr -O.

00:19:25.166 --> 00:19:28.826
So all we're actually
saying here is po this thing

00:19:28.916 --> 00:19:31.876
as if we were in
Objective C code and with

00:19:31.876 --> 00:19:35.076
that we actually get the
pretty description we wanted.

00:19:35.576 --> 00:19:37.436
And that's great.

00:19:38.406 --> 00:19:42.486
On a topic related to actually
inspecting memory addresses

00:19:42.486 --> 00:19:46.506
and trying to make sense of
them, low level debugging.

00:19:47.576 --> 00:19:50.186
If you remember one
thing and only one thing

00:19:50.186 --> 00:19:54.396
about low level debugging is
to stay very far away from it.

00:19:54.546 --> 00:19:54.976
Don't do it.

00:19:55.516 --> 00:19:58.996
[ Laughter ]

00:19:59.496 --> 00:20:03.166
Unfortunately, sometimes
you just really have to.

00:20:03.996 --> 00:20:06.216
Maybe you're debugging
something that only happens

00:20:06.336 --> 00:20:08.816
in optimized code in the
release build of your app.

00:20:08.996 --> 00:20:10.286
That happens to me sometimes.

00:20:11.346 --> 00:20:13.846
Or you're debugging
third party code

00:20:13.846 --> 00:20:15.706
for which you have
no debug information.

00:20:16.656 --> 00:20:18.126
If any of that applies to you,

00:20:18.936 --> 00:20:21.226
follow me as we sail
past the Pillars

00:20:21.226 --> 00:20:23.006
of Hercules on this journey.

00:20:24.176 --> 00:20:27.956
But please know that on
this journey you proceed

00:20:27.956 --> 00:20:28.966
at your own risk.

00:20:30.196 --> 00:20:36.086
It starts just like this; I
had a gentleman last year walk

00:20:36.086 --> 00:20:39.486
up to me in the lab with his
laptop showing me Xcode just

00:20:39.486 --> 00:20:43.206
in that state, crashed in
Objc msgSend of all places.

00:20:43.876 --> 00:20:45.096
And he tells me a story.

00:20:45.486 --> 00:20:48.906
I have my app and it's
under store and it's great

00:20:49.326 --> 00:20:52.036
but then my framework vendor
says, hey I have a new version

00:20:52.036 --> 00:20:54.576
of my frame, just
update, it will be okay.

00:20:54.916 --> 00:20:56.746
And I did update,
I listened to him,

00:20:56.746 --> 00:20:58.236
and now my app crashes
on launch.

00:20:58.296 --> 00:20:59.786
What do I do, please help me.

00:21:00.486 --> 00:21:02.956
And so we sat down
and I told him well,

00:21:03.146 --> 00:21:04.896
we know pretty much nothing here

00:21:04.896 --> 00:21:07.736
but one thing we can
do is let's start

00:21:07.736 --> 00:21:09.676
by reading machine registers.

00:21:10.686 --> 00:21:14.116
LLDB offers a facility to
do that and it lets you look

00:21:14.116 --> 00:21:16.826
at all the registers, only
a few of the registers

00:21:17.176 --> 00:21:19.296
and it even lets you
play custom formatting.

00:21:20.026 --> 00:21:20.886
What does it look like?

00:21:21.886 --> 00:21:25.536
You say register read and
you get your register values,

00:21:26.236 --> 00:21:28.056
and that's a lot of registers.

00:21:28.056 --> 00:21:30.166
And why do I even care about
all those weird numbers

00:21:30.166 --> 00:21:32.236
and the words on the screen?

00:21:32.686 --> 00:21:36.756
Well, you do care because
often arguments are passed

00:21:37.026 --> 00:21:37.946
in registers.

00:21:38.896 --> 00:21:41.386
Okay, that's fun, but that
was a lot of registers.

00:21:41.456 --> 00:21:43.646
How do I know which ones
actually matter to me?

00:21:44.266 --> 00:21:48.006
That is a question for your
platform's application binary

00:21:48.006 --> 00:21:51.066
interface ABI, the colon
convention gives you

00:21:51.066 --> 00:21:51.696
those rules.

00:21:52.556 --> 00:21:54.186
But LLDB also exposes

00:21:54.186 --> 00:21:58.816
to you convenient pseudo
registers named $arg1, $arg2,

00:21:58.816 --> 00:22:01.356
and so on which in the case

00:22:01.356 --> 00:22:03.946
in which your arguments are
actually of simple scaler

00:22:04.196 --> 00:22:07.306
or pointer types
actually mapped one to one

00:22:07.306 --> 00:22:09.256
between the registers
and the arguments.

00:22:10.096 --> 00:22:13.706
Similar convenience is available
in the C family expression.

00:22:14.476 --> 00:22:17.406
So for example, if
I have a function

00:22:17.406 --> 00:22:20.196
that takes these three
arguments and I call it,

00:22:20.906 --> 00:22:23.576
those arguments will
actually map one to one

00:22:23.846 --> 00:22:26.326
to $arg1, $arg2, and $arg3.

00:22:27.716 --> 00:22:30.206
Okay, so that applies
to our example.

00:22:30.346 --> 00:22:33.996
We're in Objc msgSend, we
start by reading arguments.

00:22:34.606 --> 00:22:37.636
The first argument is
the pointer 0 X 4 D 2,

00:22:37.786 --> 00:22:39.766
the second argument
is the selector string

00:22:39.766 --> 00:22:40.716
by appending string.

00:22:41.446 --> 00:22:45.036
We happen to know that Objc
msgSends first argument is the

00:22:45.036 --> 00:22:46.506
object we're trying to message

00:22:46.756 --> 00:22:49.176
and the second argument is the
selector we're trying to send,

00:22:50.206 --> 00:22:53.466
and we can also use the memory
read command to check what's

00:22:53.466 --> 00:22:55.386
up with the object
that we're messaging.

00:22:55.836 --> 00:22:57.696
It turns out that's
a bad object.

00:22:58.826 --> 00:23:04.396
What is happening is that
we're calling this selector

00:23:04.466 --> 00:23:05.396
on a bad object.

00:23:06.156 --> 00:23:09.046
How did we get there?

00:23:09.266 --> 00:23:12.526
Well, we're in Objc
msgSend, we're crashed,

00:23:13.056 --> 00:23:16.246
something called Objc msgSend,
something called the thing

00:23:16.246 --> 00:23:19.986
that called it and so on and so
forth until we get all the way

00:23:19.986 --> 00:23:21.776
to the entry point
of our application.

00:23:22.666 --> 00:23:28.106
In LLDB we call the frames from
frame 0 the youngest all the way

00:23:28.106 --> 00:23:32.806
to frame N the oldest and if
you want to move around frames,

00:23:33.176 --> 00:23:36.466
you can use the up command
to go back to an older frame

00:23:36.516 --> 00:23:38.666
on the stack and
the down command

00:23:38.956 --> 00:23:40.556
to go back to a younger frame.

00:23:42.056 --> 00:23:45.936
Another thing worth knowing
is the disassemble command

00:23:46.266 --> 00:23:48.866
which lets you look at the
disassembly for a function.

00:23:49.346 --> 00:23:50.856
You can do that for
the current function,

00:23:50.856 --> 00:23:54.896
for an arbitrary frame, for an
address, for a function by name,

00:23:55.196 --> 00:23:57.346
you can customize the way
that disassembly shows

00:23:57.816 --> 00:24:00.176
and in some cases
it makes debugging

00:24:00.486 --> 00:24:03.066
where you do have source code
and debug info but you want

00:24:03.066 --> 00:24:04.636
to compare those instructions

00:24:04.636 --> 00:24:07.226
to machine instructions
you can also ask LLDB

00:24:07.226 --> 00:24:10.676
to always show you always
show you disassembly along

00:24:10.676 --> 00:24:11.396
with source code.

00:24:12.136 --> 00:24:17.126
So in our case, we crashed there
and we can see that the thing

00:24:17.126 --> 00:24:18.896
that called our function
is an application

00:24:18.896 --> 00:24:19.716
that did finish launching.

00:24:20.106 --> 00:24:22.116
So let's go there real quick
and take a look at what

00:24:22.226 --> 00:24:26.256
that function is doing.

00:24:26.766 --> 00:24:29.196
That function is
calling this initializer

00:24:29.196 --> 00:24:31.526
that our framework vendor
told us, yes totally code

00:24:31.526 --> 00:24:33.246
that initializer,
getGlobalToken.

00:24:33.696 --> 00:24:36.756
It's moving some stuff around
and then it's making the call

00:24:36.756 --> 00:24:39.486
to Objc msgSend that
will crash us.

00:24:40.586 --> 00:24:42.476
So we can step around
machine code

00:24:42.476 --> 00:24:44.946
and see what these calls
are actually doing.

00:24:45.296 --> 00:24:48.676
First of all we step over
the getGlobalToken call

00:24:48.676 --> 00:24:52.126
and then I'm going to
cheat for a second here.

00:24:52.466 --> 00:24:56.926
I happen to know that the
register called rax contains the

00:24:56.926 --> 00:25:00.576
return value of that
function and if I read it,

00:25:01.636 --> 00:25:03.466
that's just the bad
pointer value.

00:25:03.986 --> 00:25:05.126
Interesting.

00:25:05.546 --> 00:25:07.596
Let's step around a
couple more times.

00:25:08.276 --> 00:25:10.686
No, that isn't changing
it, that isn't changing it.

00:25:11.296 --> 00:25:14.686
All we're doing is taking
that pointer value as is

00:25:14.976 --> 00:25:19.596
and moving it into rdi and
then calling into Objc msgSend.

00:25:20.186 --> 00:25:21.736
I wonder if that's connected?

00:25:22.386 --> 00:25:27.416
If I reg read $arg1 at this
point right before entering Objc

00:25:27.416 --> 00:25:32.376
msgSend, rdi the
bad pointer value.

00:25:33.686 --> 00:25:35.246
What have we proven
to ourselves?

00:25:35.496 --> 00:25:38.536
We've proven to ourselves that
the getGlobalToken function

00:25:38.846 --> 00:25:40.576
that our framework
vendor was so excited

00:25:40.576 --> 00:25:43.746
to get us calling actually
returned to us a bad object

00:25:44.126 --> 00:25:47.066
and upon trying to send a
message to that bad object,

00:25:47.426 --> 00:25:50.406
big surprise, our
application ended up crashing.

00:25:51.396 --> 00:25:53.886
And on that note of patting
ourselves on the back

00:25:53.886 --> 00:25:56.896
for conclusively proving
our case, I want to hand it

00:25:56.896 --> 00:25:59.026
over to Sean Callanan
to tell you all

00:25:59.026 --> 00:26:01.046
about the great new features
in the expression parser.

00:26:01.316 --> 00:26:01.846
Thank you.

00:26:02.516 --> 00:26:07.546
[ Applause ]

00:26:08.046 --> 00:26:08.726
>> Isn't that magic?

00:26:09.276 --> 00:26:10.236
It feels like magic.

00:26:10.376 --> 00:26:13.616
Your program is just
storing its data as numbers,

00:26:14.116 --> 00:26:19.026
arrays of numbers and yet you
can use LLDB this powerful tool

00:26:19.536 --> 00:26:24.436
to represent that data in
the way you think about it.

00:26:25.306 --> 00:26:30.106
Sometimes though it's not
quite as easy as just looking

00:26:30.106 --> 00:26:32.766
at a number and figuring
out what the data is.

00:26:33.936 --> 00:26:36.336
Sometimes you need
the expression parser.

00:26:36.906 --> 00:26:38.726
Now, Enrico has already
shown you

00:26:38.816 --> 00:26:40.516
where the expression parser fits

00:26:40.516 --> 00:26:42.246
in in the general
command syntax,

00:26:42.686 --> 00:26:44.226
but there's a lot
that it can do.

00:26:45.656 --> 00:26:49.706
The expression parse's job is to
work together with your program

00:26:49.796 --> 00:26:54.896
and the SDK and get from
where you're currently stopped

00:26:55.946 --> 00:27:02.186
through some contortions to get
at the data you want to the data

00:27:02.186 --> 00:27:03.996
that you're actually
trying to inspect.

00:27:05.636 --> 00:27:09.066
Now, I said we work
with your program

00:27:09.066 --> 00:27:10.566
and we work with the SDK.

00:27:11.826 --> 00:27:15.696
Working with the SDK hasn't
always been easy in LLDB

00:27:15.786 --> 00:27:17.586
if you remember from
previous years.

00:27:18.816 --> 00:27:20.566
So for example if
you were stopped

00:27:20.566 --> 00:27:23.356
in an Objective C
program and you tried

00:27:23.356 --> 00:27:28.146
to get the program's undo
manager, you probably

00:27:28.856 --> 00:27:31.866
at least once or twice
got an annoying error.

00:27:33.056 --> 00:27:36.776
It wasn't at all relevant to
what you were trying to do

00:27:36.776 --> 00:27:39.086
and it was really puzzling.

00:27:39.736 --> 00:27:41.366
But last year we told
you there's a way

00:27:41.366 --> 00:27:42.166
to get out of this.

00:27:44.416 --> 00:27:51.456
If you just manually
import AppKit then you're

00:27:51.456 --> 00:27:52.596
expression works.

00:27:53.406 --> 00:27:55.766
All right, but why
did I have to do that?

00:27:55.946 --> 00:27:57.126
It's already there.

00:27:58.546 --> 00:27:59.476
I hear you cry.

00:28:00.516 --> 00:28:02.596
[ Laughter ]

00:28:03.096 --> 00:28:05.196
You're not the only ones.

00:28:05.196 --> 00:28:09.336
So this year we thought what
can we do to make this better,

00:28:10.326 --> 00:28:11.496
and it was pretty obvious.

00:28:12.346 --> 00:28:15.886
We looked at which modules the
current source file imports

00:28:16.226 --> 00:28:18.346
and we import them
for you automatically.

00:28:18.626 --> 00:28:20.866
No more of that manual
importing business.

00:28:21.516 --> 00:28:26.546
[ Applause ]

00:28:27.046 --> 00:28:30.546
Cool. So we're getting out
of your way more efficiently.

00:28:30.946 --> 00:28:34.346
That's great, but this is
supposed to be a powerful tool.

00:28:34.886 --> 00:28:38.176
Let me tell you about
some of the great things

00:28:38.406 --> 00:28:40.286
that you can do with it.

00:28:40.756 --> 00:28:44.046
Now, sometimes these
conveniences might get

00:28:44.046 --> 00:28:44.556
in your way.

00:28:44.586 --> 00:28:45.916
You're actually trying

00:28:46.016 --> 00:28:48.316
to manually import
the things you want.

00:28:49.336 --> 00:28:52.216
There's a feature, a
setting that you can use

00:28:52.256 --> 00:28:54.976
to disable this automatic
importing

00:28:55.096 --> 00:28:58.066
and get back the feature
the way it was last year.

00:28:59.046 --> 00:29:02.396
We think you're going to like
it though so it's by default on.

00:29:02.796 --> 00:29:05.656
Great. Now let's
talk more generally

00:29:05.656 --> 00:29:07.866
about using the expression
parser effectively

00:29:08.526 --> 00:29:10.026
by reusing code.

00:29:10.626 --> 00:29:14.536
Now, the most simple case

00:29:14.536 --> 00:29:16.776
of reusing code is
reusing variables.

00:29:17.836 --> 00:29:22.146
Now remember I said you might
need to do multistep expressions

00:29:22.676 --> 00:29:25.466
to get to the data that you
actually want from the place

00:29:25.466 --> 00:29:26.446
where you currently are.

00:29:27.786 --> 00:29:30.116
In Swift you can do
something as simple

00:29:30.806 --> 00:29:33.696
as defining a temporary
variable and using it.

00:29:35.196 --> 00:29:36.096
This just works.

00:29:36.226 --> 00:29:37.976
It's as if you typed
it in your own program.

00:29:39.396 --> 00:29:42.396
Now what might be
counterintuitive is what happens

00:29:42.636 --> 00:29:43.696
if you try to use it again.

00:29:44.896 --> 00:29:47.236
Then we say, what's
that variable name?

00:29:49.216 --> 00:29:52.446
Well, actually we intended
it to work this way.

00:29:53.096 --> 00:29:57.056
The reason is you might
step around, you might stop

00:29:57.056 --> 00:30:00.326
in different places, maybe
later you're in a place

00:30:00.326 --> 00:30:02.596
where you're program
actually defined an A.

00:30:02.936 --> 00:30:04.386
Do we want the A you used

00:30:04.386 --> 00:30:06.286
as a temporary valuable
to get in your way?

00:30:07.256 --> 00:30:14.626
Probably not, but there
is a way out of this.

00:30:14.706 --> 00:30:17.936
The affordance we
setup to make sure

00:30:17.936 --> 00:30:19.736
that your variables don't escape

00:30:19.736 --> 00:30:22.366
in that way is we actually
setup a local context.

00:30:22.366 --> 00:30:25.626
It's as if you actually put a
set of braces in your program,

00:30:26.046 --> 00:30:30.376
put the let A in there and the
print, but if you want the A

00:30:30.376 --> 00:30:34.356
to break out, all you have to
do is give it a special name,

00:30:34.876 --> 00:30:36.346
a name with a dollar sign.

00:30:37.176 --> 00:30:39.206
That means that it
will never collide

00:30:39.246 --> 00:30:43.656
with your own program's names
and it means that it will live

00:30:44.236 --> 00:30:45.856
as long as your debug
session does.

00:30:47.176 --> 00:30:49.716
Awesome. What else can
you do with this tool?

00:30:49.716 --> 00:30:51.746
It turns out quite a lot.

00:30:52.386 --> 00:30:55.616
Now in Swift ever
since day one with LLDB

00:30:55.616 --> 00:30:58.546
and Swift you've been able to do
the same trick with functions.

00:30:59.696 --> 00:31:02.886
Now when you did that
you probably wanted

00:31:02.886 --> 00:31:05.756
to use multiline
expression modes and in fact

00:31:05.756 --> 00:31:07.956
if you typed the expression
command and pressed enter,

00:31:08.276 --> 00:31:10.386
you're immediately going
to get a multiline editor

00:31:10.646 --> 00:31:12.866
where you can type
in your function.

00:31:13.726 --> 00:31:19.446
If you define your function then
you can simply reuse it again

00:31:19.446 --> 00:31:20.526
remembering the dollar sign.

00:31:22.106 --> 00:31:24.876
Now, those of you who
tried this in Swift

00:31:24.876 --> 00:31:27.976
and said that's awesome might
have tried it in Objective C

00:31:29.746 --> 00:31:32.406
and it wasn't so great.

00:31:34.156 --> 00:31:36.286
Function definition
isn't allowed here.

00:31:36.716 --> 00:31:38.986
Come on these LLDB guys
always get in my way.

00:31:39.486 --> 00:31:39.886
All right.

00:31:40.146 --> 00:31:43.896
Well, turns out we
like this feature too,

00:31:43.896 --> 00:31:45.566
we think it's awesome,
we want it to be better.

00:31:46.786 --> 00:31:49.936
But we can't just make
it magically work.

00:31:50.436 --> 00:31:54.246
The reason is remember
we're stopped in your code.

00:31:54.706 --> 00:31:57.736
We want to act like we're
inside your function.

00:31:58.726 --> 00:32:01.746
If you're in Swift you can
define nested functions,

00:32:01.746 --> 00:32:03.886
it's no big deal, the
compiler will love it.

00:32:03.886 --> 00:32:06.256
It won't love the dollar
sign you can take that out

00:32:06.626 --> 00:32:08.156
but the rest it's fine with.

00:32:09.056 --> 00:32:09.926
This is totally legal.

00:32:11.746 --> 00:32:16.356
In C, C++ and Objective C though
trying to make a nested function

00:32:16.356 --> 00:32:18.986
like that, that's no good
the compiler is going

00:32:18.986 --> 00:32:22.136
to yell at you.

00:32:22.356 --> 00:32:23.936
Well, the way you get

00:32:23.936 --> 00:32:28.716
around that is using the
top level expression mode.

00:32:29.506 --> 00:32:31.496
That's an extension of
the expression command

00:32:31.926 --> 00:32:33.986
that makes it break completely

00:32:33.986 --> 00:32:36.166
out of the current
function you're stopped in

00:32:36.206 --> 00:32:39.566
and just define global
code whether it's functions

00:32:39.566 --> 00:32:41.306
or variables or what you will.

00:32:42.206 --> 00:32:43.606
Now you can define your function

00:32:43.606 --> 00:32:45.306
and use it just the
way you would expect.

00:32:46.416 --> 00:32:47.116
All right.

00:32:48.586 --> 00:32:51.746
Now the functions aren't
the only reusable things you

00:32:51.746 --> 00:32:52.326
can define.

00:32:52.326 --> 00:32:53.696
I've already talked
about variables.

00:32:54.066 --> 00:32:56.806
You can define closures too,
they're kind of a merger

00:32:56.806 --> 00:32:58.126
of variables and code.

00:32:59.236 --> 00:33:01.506
In Swift you can define
a closure and use it.

00:33:03.006 --> 00:33:06.236
New in Xcode this year
you can do the same thing

00:33:06.236 --> 00:33:07.026
in Objective C.

00:33:07.636 --> 00:33:12.236
Blocks can be defined and
reused and for those of you

00:33:12.236 --> 00:33:14.116
who are diehard C++ fans,

00:33:14.546 --> 00:33:16.716
you can do the exact
same thing with lambdas.

00:33:17.286 --> 00:33:22.006
Now, what can you do
with these blocks?

00:33:22.006 --> 00:33:23.156
What's special about them.

00:33:23.456 --> 00:33:25.926
Well, you can pass them off
to functions for example.

00:33:26.846 --> 00:33:27.906
Sometimes you might need

00:33:27.906 --> 00:33:30.596
to manually run something
on a certain queue.

00:33:31.906 --> 00:33:32.636
That works.

00:33:33.086 --> 00:33:35.436
You can send stuff for
example to a global queue

00:33:35.806 --> 00:33:37.156
and the block will simply run.

00:33:38.656 --> 00:33:43.096
Now, sometimes it
gets a little annoying

00:33:43.526 --> 00:33:46.636
because these complex
expressions result

00:33:46.636 --> 00:33:49.346
in much more likelihood
of typos.

00:33:50.646 --> 00:33:54.456
Now, what's the difference
quickly without looking back

00:33:54.536 --> 00:33:57.636
to the previous slide between
this expression and the one

00:33:57.636 --> 00:33:58.666
from the previous slide?

00:33:59.556 --> 00:34:00.336
You probably missed it.

00:34:00.776 --> 00:34:02.156
The compiler sure didn't.

00:34:03.046 --> 00:34:06.256
It will yell at you about
the missing semicolon

00:34:06.866 --> 00:34:09.206
but there's a better way.

00:34:09.656 --> 00:34:11.556
If you were to type this
into the source editor,

00:34:12.406 --> 00:34:14.576
we would have told you,
hey you probably missed a

00:34:14.576 --> 00:34:15.386
semicolon here.

00:34:15.386 --> 00:34:18.306
Did you mean to put it in?

00:34:18.306 --> 00:34:21.726
Well, it turns out LLDB
can do the same thing,

00:34:22.056 --> 00:34:25.436
and we can do one better by
just automatically putting

00:34:25.436 --> 00:34:26.956
in the semicolon
that was missing,

00:34:27.335 --> 00:34:28.386
running your expression.

00:34:28.976 --> 00:34:30.266
This is called fixit.

00:34:30.266 --> 00:34:32.436
It's been in clang for a while

00:34:32.726 --> 00:34:34.806
and LLDB now applies
the same thing.

00:34:36.886 --> 00:34:38.496
Swift has fixit too.

00:34:39.716 --> 00:34:42.826
In Swift you're less likely
to run into semicolon problems

00:34:43.166 --> 00:34:45.426
but boy those exclamation
points are annoying.

00:34:46.516 --> 00:34:48.656
[ Laughter ]

00:34:49.156 --> 00:34:54.025
Yeah. Well, they are as valuable
as they are in your own code

00:34:54.025 --> 00:34:55.176
for you to understand it,

00:34:55.306 --> 00:34:57.306
when you're debugging you
just want them the heck

00:34:57.306 --> 00:35:00.786
out of your way, and
believe me we do too.

00:35:01.756 --> 00:35:04.876
So if you try to use something
without unwrapping it,

00:35:06.126 --> 00:35:08.076
we just apply the fixit
and unwrap it for you.

00:35:09.306 --> 00:35:12.016
Now, there may be
one or two people

00:35:12.186 --> 00:35:14.556
who say I don't want
debugger touching my code.

00:35:15.146 --> 00:35:20.986
Now, for those people I
have had those evenings too,

00:35:21.776 --> 00:35:26.136
and we have settings that will
turn off the entire autoapply

00:35:26.136 --> 00:35:28.716
fixit feature and
if you just don't

00:35:28.716 --> 00:35:31.116
like the debugger
acting smug and pointing

00:35:31.116 --> 00:35:33.736
out every little thing in your
code that it's fixing for you,

00:35:34.176 --> 00:35:36.226
then you can turn just
that part off too.

00:35:37.956 --> 00:35:38.376
All right.

00:35:39.516 --> 00:35:44.156
[ Applause ]

00:35:44.656 --> 00:35:45.176
Thanks. All right.

00:35:45.916 --> 00:35:49.246
Great. That's a nice convenience
feature but let me finish

00:35:49.246 --> 00:35:53.696
up with just one more thing that
you can define that's reusable.

00:35:53.696 --> 00:35:56.866
You can define your own types.

00:35:57.966 --> 00:36:00.726
In Swift for example you can
enter a multiline expression

00:36:00.926 --> 00:36:05.146
that defines a class and
when you try to instantiate

00:36:05.146 --> 00:36:08.196
that class indeed it
shows up just the way

00:36:08.576 --> 00:36:11.006
as if you had defined the
class in your own program.

00:36:12.336 --> 00:36:18.026
In the same way in C++, you can
define a class and reuse it.

00:36:18.916 --> 00:36:24.256
Now let me show you an example
of taking all these concepts

00:36:24.306 --> 00:36:28.336
and using them in
your own program.

00:36:28.496 --> 00:36:31.666
Often especially in your
programs that interact

00:36:31.666 --> 00:36:34.566
with web APIs you get a lot
of data back and you want

00:36:34.566 --> 00:36:36.446
to filter it especially
when you're debugging.

00:36:37.736 --> 00:36:41.826
The way you filter data
especially say in NS array is

00:36:41.826 --> 00:36:43.076
by defining a predicate.

00:36:44.526 --> 00:36:48.356
Now in the expression parser you
can define custom predicates.

00:36:49.176 --> 00:36:52.266
In this case we're
taking writing a block

00:36:52.726 --> 00:36:56.266
that takes the result
strings from the web server

00:36:56.996 --> 00:36:59.146
and filters them to find strings

00:36:59.176 --> 00:37:01.046
that have the text
error in them.

00:37:01.836 --> 00:37:02.986
Probably useful for debugging.

00:37:04.256 --> 00:37:08.526
Now if you simply take
an array full of data

00:37:08.526 --> 00:37:12.416
from your web server and you
apply the predicate to it,

00:37:12.666 --> 00:37:14.696
you can get right
down to the message

00:37:14.696 --> 00:37:17.356
that you actually cared about.

00:37:18.426 --> 00:37:18.816
All right.

00:37:19.186 --> 00:37:22.166
Now you've hopefully seen how
powerful the expression parser

00:37:22.166 --> 00:37:24.806
can be for you, I'd like to
turn things over to Jim Ingham

00:37:25.136 --> 00:37:26.816
to show you more
powerful features of LLDB.

00:37:27.516 --> 00:37:31.886
[ Applause ]

00:37:32.386 --> 00:37:32.936
>> Thank you, Sean.

00:37:33.416 --> 00:37:36.416
So, so far we've sort of
inverted the natural order

00:37:36.416 --> 00:37:39.586
of things and told you
how to look at the state

00:37:39.586 --> 00:37:42.116
of your program when you're
stopped but we haven't

00:37:42.116 --> 00:37:43.886
yet told you how you
would actually get

00:37:43.886 --> 00:37:44.996
to such interesting points.

00:37:44.996 --> 00:37:46.666
So that's with what I'm going
to tell you a little bit about.

00:37:46.926 --> 00:37:49.646
Of course breakpoints
are the natural way

00:37:49.876 --> 00:37:51.956
that you would stop
your program.

00:37:51.956 --> 00:37:54.896
So I want to talk a little
bit about how you might think

00:37:54.896 --> 00:37:59.586
about breakpoints naively as the
place where I stop my program

00:37:59.806 --> 00:38:01.886
but that's actually not
how they're implemented

00:38:01.886 --> 00:38:04.356
or how LLDB thinks about them.

00:38:04.356 --> 00:38:07.196
To LLDB a breakpoint
is really is search

00:38:07.466 --> 00:38:10.936
through your program space
for interesting places to stop

00:38:10.936 --> 00:38:13.366
or many different kinds of
searches as it turns out.

00:38:13.706 --> 00:38:16.496
So breakpoints are
really search criteria

00:38:16.866 --> 00:38:20.896
and what the individual
locations where your stop,

00:38:20.896 --> 00:38:22.876
what you thought of
naively a breakpoint,

00:38:23.186 --> 00:38:25.136
we call breakpoint locations.

00:38:25.466 --> 00:38:27.616
So to make this a little more
concrete, let me tie this

00:38:27.666 --> 00:38:31.966
to Xcode's breakpoints because
after all Xcode under the covers

00:38:31.966 --> 00:38:33.596
when it debugs is LLDB

00:38:33.596 --> 00:38:37.176
so all the Xcode breakpoints
must be LLDB breakpoints.

00:38:37.416 --> 00:38:41.576
So for instance when you click
in the source gutter in Xcode,

00:38:41.756 --> 00:38:45.016
what you're really doing is
running this command in LLDB,

00:38:45.016 --> 00:38:46.496
some breakpoint setting command.

00:38:46.976 --> 00:38:49.606
Similarly when you make a
symbolic breakpoint you're

00:38:49.606 --> 00:38:52.286
running a by name
breakpoint setting.

00:38:52.506 --> 00:38:55.136
So I want to give
you a little sense

00:38:55.136 --> 00:38:58.726
that these are really
searches by showing you cases

00:38:58.726 --> 00:39:02.906
in which you would end up
naturally with multiple results

00:39:02.906 --> 00:39:05.786
from what you thought of as
a simple unitary breakpoint

00:39:05.786 --> 00:39:08.446
setting, so the first example

00:39:08.446 --> 00:39:10.656
that I'll show you is
symbolic breakpoints.

00:39:10.926 --> 00:39:12.846
So here's an example
where you want

00:39:12.846 --> 00:39:14.356
to just set a breakpoint
on main.

00:39:14.356 --> 00:39:15.896
That should be a simple
thing to do, right?

00:39:16.236 --> 00:39:18.866
But then it says, no
I have 19 locations.

00:39:18.866 --> 00:39:20.546
Well, while did you
end up with 19?

00:39:20.926 --> 00:39:23.376
Do the break list
command to see the results

00:39:23.376 --> 00:39:25.406
of your breakpoint
setting and what you see is

00:39:25.406 --> 00:39:30.226
that the breakpoint name
search is actually a loose name

00:39:30.226 --> 00:39:34.436
matching search, so for instance
it picked up the selector names

00:39:34.436 --> 00:39:36.486
within a class and
that's actually convenient

00:39:36.486 --> 00:39:39.386
in many cases because like
if you're debugging in C++

00:39:39.386 --> 00:39:42.836
and you have a name space, and a
name space inside, and a class,

00:39:42.836 --> 00:39:45.076
and a method, you don't
want to have to type all

00:39:45.076 --> 00:39:49.036
of the full path to that but
on the other hand it does mean

00:39:49.036 --> 00:39:52.006
that the search is perhaps wider
than you intended it to be.

00:39:52.616 --> 00:39:54.976
We provide many different
kinds of searches

00:39:54.976 --> 00:39:57.746
so of course we provide a
slightly more strict search

00:39:57.966 --> 00:40:01.486
which is the full name
search that forces the name

00:40:01.486 --> 00:40:05.306
to match the entire name of the
symbol that you're specifying.

00:40:05.726 --> 00:40:07.866
We tried that but even
that didn't work right.

00:40:08.156 --> 00:40:10.806
Well, for some reason somebody
decided their library has

00:40:10.806 --> 00:40:13.516
to have a function called main
in it, no idea why but it does.

00:40:13.916 --> 00:40:17.816
So you can even specify
further by limiting your search

00:40:17.816 --> 00:40:21.976
to a particular shared
library with the shlib option.

00:40:21.976 --> 00:40:24.276
So then finally then you
get the breakpoint you want.

00:40:24.716 --> 00:40:26.286
I'm going to give you
one other instance not

00:40:26.286 --> 00:40:27.616
because I don't think
you believe me

00:40:27.616 --> 00:40:30.206
but because this one actually
comes up in Swift fairly often

00:40:30.416 --> 00:40:32.116
with file and line breakpoints

00:40:32.406 --> 00:40:34.156
because Swift has
this nice feature

00:40:34.306 --> 00:40:38.436
that you can call a
function that uses a closure

00:40:38.566 --> 00:40:42.806
and define the closure simply by
continuing with a curly bracket

00:40:42.806 --> 00:40:45.016
and then on with the
body of the closure.

00:40:45.206 --> 00:40:47.526
But then if you try to set
a breakpoint on that line,

00:40:47.696 --> 00:40:50.756
what you're going to find out
is you have two stop points.

00:40:50.756 --> 00:40:51.656
Why do you have that?

00:40:52.106 --> 00:40:54.696
When you look it's actually
fairly straightforward, right?

00:40:54.886 --> 00:40:58.676
That source line actually
contributed a little bit of code

00:40:58.676 --> 00:41:01.796
to the closure function and
you see we have a breakpoint

00:41:01.796 --> 00:41:03.666
location on the closure
function,

00:41:03.906 --> 00:41:07.486
but it also was the invoking
site for that function

00:41:07.776 --> 00:41:11.726
and so you also have a
location for that invoking site.

00:41:12.226 --> 00:41:16.836
So anyway that's for that so now
having given you a few examples,

00:41:17.056 --> 00:41:19.806
let me give you the general
form of the command and then go

00:41:19.806 --> 00:41:22.846
on to some more interesting
uses of it.

00:41:23.416 --> 00:41:25.746
So the breakpoint set
command works as follows:

00:41:25.746 --> 00:41:28.686
You say break set and then
there are some options

00:41:28.686 --> 00:41:31.076
which specify the type

00:41:31.076 --> 00:41:33.846
and that's really
specifying the kind

00:41:33.846 --> 00:41:34.826
of search that you're doing.

00:41:34.826 --> 00:41:37.086
Is it a file and line
search, a symbol name search

00:41:37.086 --> 00:41:37.986
or so on and so forth?

00:41:38.286 --> 00:41:41.436
And the values for that
type option will be the data

00:41:41.546 --> 00:41:45.336
for the search and then there
are other kinds of options

00:41:45.636 --> 00:41:48.046
like ignore count,
condition and so on.

00:41:48.246 --> 00:41:51.026
The way to think about those
options is they don't specify

00:41:51.286 --> 00:41:54.306
where to break, they
specify whether to break.

00:41:54.576 --> 00:41:59.876
So that's the whether can be
modified after the fact but the

00:41:59.876 --> 00:42:02.026
where can't because we've
already done the search

00:42:02.026 --> 00:42:03.586
and you would just
set a new breakpoint

00:42:03.586 --> 00:42:04.466
if you wanted to do that.

00:42:04.836 --> 00:42:07.556
So let's talk a little bit about
these breakpoint location things

00:42:07.556 --> 00:42:09.736
which are the places where
you're going to stop.

00:42:09.736 --> 00:42:11.766
They are the individual
search results,

00:42:12.036 --> 00:42:14.416
they always have some
address which is the address

00:42:14.416 --> 00:42:16.746
at which your program
is going to halt.

00:42:17.116 --> 00:42:19.576
When you look at them
they're specified

00:42:19.576 --> 00:42:21.546
by the generating
breakpoint's number

00:42:21.716 --> 00:42:24.416
and a location number
written separated by a dot.

00:42:24.416 --> 00:42:27.666
So if you actually notice
when you're debugging in Xcode

00:42:27.666 --> 00:42:30.126
and you stop at one of your
breakpoints and you look

00:42:30.126 --> 00:42:33.746
at the little PC ribbon, the PC
ribbon will have the stop reason

00:42:33.746 --> 00:42:36.186
on the far right and
it will say breakpoint,

00:42:36.186 --> 00:42:37.766
but it always says 2.1.

00:42:37.766 --> 00:42:39.416
It never said breakpoint 2

00:42:39.596 --> 00:42:42.066
because you only ever
really stop at locations

00:42:42.366 --> 00:42:44.316
so 1.1, 1.2 or whatever.

00:42:44.636 --> 00:42:48.686
By the way, the locations
and breakpoints are sort

00:42:48.686 --> 00:42:50.366
of symmetrical with
respect to all

00:42:50.366 --> 00:42:52.606
of these other options
that I talked about.

00:42:52.826 --> 00:42:55.836
They all take the same sort of
generic options like commands

00:42:55.836 --> 00:42:57.076
and conditions and so forth,

00:42:57.396 --> 00:43:00.766
and you can specify a
command condition whatever

00:43:00.766 --> 00:43:03.486
on a breakpoint and then it
will work for all the locations

00:43:03.696 --> 00:43:06.936
but you can also override
for a particular location one

00:43:06.936 --> 00:43:08.906
of the commands or
conditions just by setting it

00:43:08.906 --> 00:43:10.826
on the location instead.

00:43:11.206 --> 00:43:13.556
One other little convenience,

00:43:14.076 --> 00:43:17.116
oftentimes if you have a
breakpoint that's generated a

00:43:17.116 --> 00:43:18.966
bunch of locations,
you want five of them,

00:43:18.966 --> 00:43:21.226
you don't want five of
them so you disable them

00:43:21.416 --> 00:43:22.946
which you can do independently,

00:43:23.266 --> 00:43:26.216
but then if you you don't want
any of them to hit you want

00:43:26.216 --> 00:43:28.316
to be able to disable the whole
breakpoint which you can do

00:43:28.316 --> 00:43:29.616
by disabling the breakpoint.

00:43:29.796 --> 00:43:32.766
But it turns out that doesn't
change the enable disable state

00:43:32.766 --> 00:43:35.906
of it locations so then you
can just turn it back on again

00:43:36.126 --> 00:43:39.206
and all of the location state
will be as you would expect.

00:43:39.666 --> 00:43:40.666
So that's just a little thing.

00:43:40.906 --> 00:43:42.416
So now that you've
seen a little bit,

00:43:42.586 --> 00:43:45.356
the notion of how breakpoints
are thought of in LLDB,

00:43:45.356 --> 00:43:48.736
let me show you a couple
of more powerful types

00:43:48.736 --> 00:43:50.476
of breakpoints that
LLDB provides.

00:43:50.726 --> 00:43:53.046
So again these are
searches for places to stop.

00:43:53.156 --> 00:43:55.586
What kinds of searches
are we going to do?

00:43:55.686 --> 00:43:57.406
It's just what name spaces

00:43:57.406 --> 00:43:59.366
in your program might
be interesting.

00:43:59.576 --> 00:44:02.276
It turns out all of the
name spaces are name spaces

00:44:02.276 --> 00:44:04.336
of stringy things because
they're all like names

00:44:04.336 --> 00:44:08.486
of functions or whatever, so we
always use regular expressions

00:44:08.656 --> 00:44:10.976
as the way to express
the search patterns.

00:44:11.196 --> 00:44:12.686
So if you know regular
expressions,

00:44:12.686 --> 00:44:13.916
this will make you feel lovely,

00:44:14.196 --> 00:44:16.056
and if you don't
regular expressions,

00:44:16.376 --> 00:44:19.096
I would have said a couple
years ago look for somebody

00:44:19.126 --> 00:44:21.536
in your office that
has books with animals

00:44:21.536 --> 00:44:23.506
on them although
nowadays if you're looking

00:44:23.506 --> 00:44:25.326
for somebody old you
probably should just look

00:44:25.326 --> 00:44:26.876
for somebody who
has books at all.

00:44:27.516 --> 00:44:29.516
[ Laughter ]

00:44:30.516 --> 00:44:32.546
[ Applause ]

00:44:33.046 --> 00:44:35.476
So anyway, so we provide
two kinds of searches,

00:44:35.476 --> 00:44:38.886
one is fairly obvious which
is a search over the names

00:44:38.886 --> 00:44:42.106
of functions in your program
so this is the option for that,

00:44:42.366 --> 00:44:44.116
and one that might be
slightly less obvious

00:44:44.116 --> 00:44:45.996
but I'll convince you
is interesting I hope

00:44:45.996 --> 00:44:49.576
as we go along, are sourced
text search breakpoints.

00:44:49.966 --> 00:44:51.456
And this is the option
for those.

00:44:51.946 --> 00:44:54.826
Okay, so let's give you the
first one this is function name

00:44:54.826 --> 00:44:55.996
pattern matching breakpoints

00:44:55.996 --> 00:44:57.496
and I'll just show
you some examples.

00:44:57.806 --> 00:44:59.636
So suppose somebody has
given you a new class

00:45:00.216 --> 00:45:02.706
and you don't know what it does,
you want to see how it works,

00:45:02.926 --> 00:45:04.326
so what you want to
do really is break

00:45:04.326 --> 00:45:07.636
on all the methods implemented
by that class which you could do

00:45:07.636 --> 00:45:10.266
by going through the source
file in Xcode and clicking

00:45:10.266 --> 00:45:11.296
on the beginning of all of them

00:45:11.296 --> 00:45:13.086
but that would quickly
get tedious.

00:45:13.456 --> 00:45:15.236
And by the way, you
don't want to stop

00:45:15.236 --> 00:45:16.476
on the parent or
subclass whatever.

00:45:16.806 --> 00:45:18.956
What would be better
would be to try to cons

00:45:18.956 --> 00:45:20.116
up a regular expression

00:45:20.116 --> 00:45:23.796
which matches all the
functions in a given class.

00:45:24.046 --> 00:45:26.756
So in Swift this is an
appropriate regular expression

00:45:27.066 --> 00:45:29.546
or in Objective C this is an
appropriate regular expression.

00:45:29.726 --> 00:45:32.406
So then you would have
breakpoints on all

00:45:32.406 --> 00:45:34.456
of those then you could run your
program and then you could go

00:45:34.456 --> 00:45:35.526
through and see what's going on.

00:45:35.526 --> 00:45:38.066
And remember because you can
disable individual locations,

00:45:38.336 --> 00:45:40.726
when you do this
kind of experiment,

00:45:40.846 --> 00:45:43.606
you find that you hit one of
them, you know what it does,

00:45:43.606 --> 00:45:45.456
you're uninterested in that
one so you just disable

00:45:45.456 --> 00:45:47.366
that location then
you keep going.

00:45:47.366 --> 00:45:49.666
The second one you figure out
disable so on and so forth.

00:45:50.006 --> 00:45:52.126
So that's kind of a nice
way to explore new code.

00:45:52.286 --> 00:45:54.556
An even more radical version

00:45:54.556 --> 00:45:56.306
of the same thing is somebody
is giving you a whole shared

00:45:56.306 --> 00:45:57.876
library that does some stuff.

00:45:57.936 --> 00:45:59.676
You want to just see
what stuff it does

00:45:59.676 --> 00:46:03.016
when it's running then set a
regular expression breakpoint,

00:46:03.016 --> 00:46:04.926
I'm using the short
- r form here

00:46:05.246 --> 00:46:07.876
and the regular expression
matches everything,

00:46:07.876 --> 00:46:10.216
that's what .star
does, and then limit it

00:46:10.216 --> 00:46:12.516
to the library you're
interested in.

00:46:12.516 --> 00:46:15.706
Combining this with breakpoint
commands can often be a really

00:46:15.706 --> 00:46:18.526
nice way just to sort of
get a quick and dirty trace

00:46:18.526 --> 00:46:21.786
of execution through this
library, you could backtrace

00:46:21.786 --> 00:46:24.376
and maybe print the
locals and then continue

00:46:24.376 --> 00:46:27.436
and you'll just run your
program and get a tape output

00:46:27.436 --> 00:46:29.686
of the execution
through that library.

00:46:30.316 --> 00:46:31.846
Of course it slows
down execution

00:46:31.846 --> 00:46:33.446
but you know whatever
sometimes you pay.

00:46:33.956 --> 00:46:37.626
And then the other trick
again is as you find ones

00:46:37.626 --> 00:46:39.336
that you don't care about,
you can disable them.

00:46:39.676 --> 00:46:41.636
So let me talk about
the other kind

00:46:41.826 --> 00:46:43.966
of pattern matching in source.

00:46:44.386 --> 00:46:47.946
So the point here is that
there are some constructs

00:46:47.946 --> 00:46:49.596
that are really obvious
when you're looking

00:46:49.596 --> 00:46:52.466
at your source text but
figuring out how to get to them

00:46:52.466 --> 00:46:55.166
in the generated code
is really not obvious.

00:46:55.406 --> 00:46:57.436
So an example of this is macros

00:46:57.696 --> 00:47:00.086
which generally just
get substituted as text

00:47:00.086 --> 00:47:02.996
into your program and then
sort of vanish, but you know

00:47:02.996 --> 00:47:04.516
where they're inserted
in your code

00:47:04.516 --> 00:47:06.176
because they're the things
with capital letters.

00:47:06.446 --> 00:47:09.356
So you want to do a search
maybe for all capital letters

00:47:09.356 --> 00:47:11.236
or for the particular
macros you care about.

00:47:11.536 --> 00:47:13.886
But you can even be
more creative than that

00:47:13.886 --> 00:47:16.426
so for instance I
want to know anywhere

00:47:16.426 --> 00:47:19.496
that a particular field
is gotten from a pointer

00:47:19.836 --> 00:47:22.406
which is something that in
source text I can see obviously

00:47:22.406 --> 00:47:23.956
because it's going
to look like that

00:47:24.246 --> 00:47:27.006
but in generated code
finding those places would be

00:47:27.006 --> 00:47:27.736
quite difficult.

00:47:27.736 --> 00:47:31.416
So that's another instance
where using the pattern matching

00:47:31.416 --> 00:47:34.276
in your source can allow
you to find constructs

00:47:34.276 --> 00:47:36.576
that you might not be
able to find otherwise.

00:47:36.926 --> 00:47:42.696
Then another use of this is to
sort of make topic groupings

00:47:42.806 --> 00:47:45.046
that you can set
breakpoints on just

00:47:45.206 --> 00:47:47.556
by inserting patterns
artificially

00:47:47.556 --> 00:47:50.816
into your source code like
as comments saying break here

00:47:50.816 --> 00:47:53.016
or break here when
you're interested

00:47:53.016 --> 00:47:55.596
in inspecting this
particular subsection

00:47:55.596 --> 00:47:57.226
of my program's functionality

00:47:57.526 --> 00:48:00.126
and then using these source
regular expression breakpoints

00:48:00.216 --> 00:48:01.066
to catch it.

00:48:01.476 --> 00:48:05.416
So here's how the source
breakpoint matching

00:48:05.416 --> 00:48:06.126
command works.

00:48:06.406 --> 00:48:09.236
There's source regular
expression is the option,

00:48:09.456 --> 00:48:12.136
the data you're providing for
this search is the pattern,

00:48:12.366 --> 00:48:16.256
and then you can limit it to
one file, you can limit it

00:48:16.256 --> 00:48:19.956
to multiple files by just
providing the -f option multiple

00:48:19.956 --> 00:48:23.296
times and there's also a flag
to search all your source files.

00:48:24.106 --> 00:48:27.716
So let me just give you an
example to whet your appetite.

00:48:27.996 --> 00:48:30.966
Suppose I had like a complex
function like a state machine

00:48:31.136 --> 00:48:33.346
which is computing stuff
and then it's running

00:48:33.346 --> 00:48:34.616
from many different places

00:48:34.616 --> 00:48:36.756
in some horrible huge case
statement or something

00:48:36.756 --> 00:48:40.526
like that, and I'm interested
in finding out when it's going

00:48:40.526 --> 00:48:43.356
to return null but I'd like
to know what was the case

00:48:43.666 --> 00:48:47.586
in this particular run through
at which it returned null,

00:48:47.816 --> 00:48:49.666
and that's a hard thing
to figure out to do

00:48:49.666 --> 00:48:51.556
because you can stop
after the function returns

00:48:51.556 --> 00:48:52.656
and check whether it's null.

00:48:52.856 --> 00:48:55.936
You can go click on all the
places where it returns null

00:48:55.936 --> 00:48:59.726
but you might miss one or you
can just look for the pattern.

00:49:00.176 --> 00:49:02.546
There's one other
convenience that we offer you

00:49:02.546 --> 00:49:05.136
in the source regular
expression breakpoint type

00:49:05.136 --> 00:49:08.206
which is you can specify not
only a file but you can limit it

00:49:08.206 --> 00:49:09.866
to a particular function so in

00:49:09.866 --> 00:49:11.326
that case I'd do
something like this.

00:49:11.546 --> 00:49:14.796
I'd break my pattern
would be return

00:49:14.796 --> 00:49:17.556
and then I'm doing showing
that I know regular expressions

00:49:17.556 --> 00:49:20.946
because I'm showing off, space
star is any number of spaces

00:49:21.126 --> 00:49:24.246
and then my null pointer I limit
it to a function and I limit it

00:49:24.246 --> 00:49:27.466
to a file I'm interested in and
then I can find out as I run

00:49:27.466 --> 00:49:29.896
through exactly where
I've returned null

00:49:29.896 --> 00:49:31.036
in this particular usage.

00:49:32.286 --> 00:49:34.296
So it's worthwhile
talking about a couple

00:49:34.296 --> 00:49:37.646
of extra breakpoint options that
you might not have heard about.

00:49:37.846 --> 00:49:41.116
One of them is along
the lines of the where

00:49:41.116 --> 00:49:44.906
or the filter kind that's
useful now that we have Swift

00:49:44.906 --> 00:49:49.216
and Objective C together in
programs which is the ability

00:49:49.216 --> 00:49:51.186
to specify a language
for a breakpoint.

00:49:51.186 --> 00:49:54.176
So for instance, there are a
lot of count methods everywhere

00:49:54.176 --> 00:49:55.796
in the world and if
you set a breakpoint

00:49:55.796 --> 00:49:58.306
on the name count you're
going to set it on a bunch

00:49:58.306 --> 00:50:00.546
of Swift code but you're also
going to set it on a bunch

00:50:00.546 --> 00:50:02.356
of Objective C methods
and you don't care

00:50:02.356 --> 00:50:05.136
about the Objective C methods,
you only want the Swift ones,

00:50:05.476 --> 00:50:08.126
then you can just
specify the language Swift

00:50:08.126 --> 00:50:09.826
and it won't set a
breakpoint on any

00:50:09.826 --> 00:50:11.716
of the Objective C names
that happen to match.

00:50:11.786 --> 00:50:15.426
So that's just a useful little
convenience and yeah, right.

00:50:15.656 --> 00:50:19.516
And one other option that's
sometimes useful is being able

00:50:19.626 --> 00:50:22.716
to narrow your search
to a particular thread.

00:50:22.966 --> 00:50:25.836
So you've got some code that's
being called and a bunch

00:50:25.836 --> 00:50:27.856
of different threads, it's like
a kernel or something like that

00:50:27.996 --> 00:50:31.126
but you've starting working
on the execution in one thread

00:50:31.126 --> 00:50:33.756
and you don't want your
breakpoints that you're using

00:50:33.756 --> 00:50:35.526
for the investigation
to take you off

00:50:35.526 --> 00:50:37.696
onto other threads,
it's fairly simple.

00:50:37.946 --> 00:50:41.926
There's a thread ID option and
there's one that you can do

00:50:41.926 --> 00:50:43.406
by thread name which you set

00:50:43.406 --> 00:50:45.986
with this pthread
set name np call.

00:50:45.986 --> 00:50:48.966
That one is convenient because
if you name a thread then

00:50:48.966 --> 00:50:51.246
that persists over
many debugging sessions

00:50:51.246 --> 00:50:53.616
where of course the thread ID
is going to change every time,

00:50:54.036 --> 00:50:57.976
and you can even restrict it
to code that's being serviced

00:50:57.976 --> 00:50:59.596
on a particular queue by name.

00:51:01.076 --> 00:51:02.846
One other thing that
you might note is

00:51:02.846 --> 00:51:06.116
that you can add all these
options to existing breakpoints

00:51:06.286 --> 00:51:08.976
and particularly that's
useful if you've set file

00:51:08.976 --> 00:51:11.726
and line breakpoint
in Xcode in the gutter

00:51:11.726 --> 00:51:14.526
but then you decide you want to
like for instance limit that one

00:51:14.526 --> 00:51:16.716
to a particular thread and
you can change all these

00:51:16.716 --> 00:51:18.786
after the fact, the
command is break modify,

00:51:19.096 --> 00:51:20.076
and the other useful thing

00:51:20.076 --> 00:51:22.846
in this slide is showing
you how you specify them

00:51:23.136 --> 00:51:26.606
because you can specify
either by breakpoint,

00:51:26.996 --> 00:51:28.616
by breakpoint location number

00:51:28.696 --> 00:51:31.316
and there's also a little
syntax to specify ranges.

00:51:33.296 --> 00:51:35.106
That's that.

00:51:35.316 --> 00:51:38.436
So now you've come up with
all these clever breakpoints

00:51:38.636 --> 00:51:41.626
that you want but you run into
a little road block which is

00:51:41.626 --> 00:51:42.926
that it turns out Xcode

00:51:42.926 --> 00:51:45.066
at present only persists
breakpoints

00:51:45.066 --> 00:51:48.686
that it knows you set and so
the ones that you've managed

00:51:48.686 --> 00:51:51.206
to write in by hand
it won't know about.

00:51:51.446 --> 00:51:53.016
So how do you make them persist?

00:51:53.316 --> 00:51:56.556
The first way is what Enrico
told you about if you want it

00:51:56.556 --> 00:51:58.786
to hold for all projects,
you just put it

00:51:58.786 --> 00:52:01.046
in your LLDB init file
and then you're done.

00:52:01.336 --> 00:52:03.506
But if you want to make
project specific ones,

00:52:03.506 --> 00:52:05.326
here's a cute little
trick that you can use

00:52:05.546 --> 00:52:08.656
to get the breakpoints
loaded every time you debug

00:52:08.656 --> 00:52:09.866
that particular project.

00:52:10.186 --> 00:52:13.216
What you do is make an
Xcode stored breakpoint,

00:52:13.466 --> 00:52:15.406
preferably something that's
going to get hit early

00:52:15.406 --> 00:52:16.966
on in your program execution,

00:52:17.186 --> 00:52:18.466
and then you put
your breakpoints

00:52:18.466 --> 00:52:19.706
as commands in that one.

00:52:19.706 --> 00:52:23.326
So you know if you're a main
executable for instance,

00:52:23.326 --> 00:52:25.116
main is a very convenient place

00:52:25.116 --> 00:52:26.786
so you would make a
symbolic breakpoint

00:52:27.156 --> 00:52:29.626
and then you would put main in

00:52:29.836 --> 00:52:32.906
and then you would remember
the slide a while ago now

00:52:32.906 --> 00:52:34.776
where I told you about our
little trouble with main,

00:52:34.976 --> 00:52:37.086
so you would specify
the shared library,

00:52:37.476 --> 00:52:39.466
then you would add an action

00:52:39.466 --> 00:52:42.016
which is a debugger command
action and then don't type

00:52:42.016 --> 00:52:44.466
in all of the breakpoints
in one in one in one here

00:52:44.466 --> 00:52:45.906
because that's just
going to get tedious.

00:52:46.156 --> 00:52:48.806
It's much easier to put
the commands in a file

00:52:48.946 --> 00:52:51.276
and then use LLDB's
command source command

00:52:51.276 --> 00:52:54.166
to load those commands in,
load those breakpoints in

00:52:54.436 --> 00:52:55.236
and then finally

00:52:55.236 --> 00:52:57.556
if you autocontinue then just
every time you run you will

00:52:57.556 --> 00:53:00.396
automatically have all of
those breakpoints set for you.

00:53:01.106 --> 00:53:05.416
So I want to show you one other
little convenience we've added

00:53:05.826 --> 00:53:09.076
to overcome one particularly
annoying problem that you get

00:53:09.386 --> 00:53:13.896
in modern languages which
is when you're trying

00:53:13.896 --> 00:53:16.276
to step you're trying
to step into something

00:53:16.496 --> 00:53:19.906
but the problem is that in
most modern languages most

00:53:19.906 --> 00:53:23.146
of the variable access is
now done either as properties

00:53:23.146 --> 00:53:25.956
or through accessor
functions or whatever so that

00:53:26.166 --> 00:53:29.906
and they're generally that's not
the code you're trying to debug.

00:53:30.286 --> 00:53:32.246
So you end up in a scenario

00:53:32.246 --> 00:53:34.826
like this you know I'm
here I'm trying to get

00:53:34.826 --> 00:53:35.916
into this function,
do something.

00:53:35.916 --> 00:53:36.906
I want to step in there.

00:53:37.106 --> 00:53:41.136
So I try that I step and I
don't end up there because one

00:53:41.136 --> 00:53:43.826
of the arguments that I was
passing was an accessor function

00:53:43.826 --> 00:53:44.956
so I ended up in the accessor.

00:53:44.996 --> 00:53:47.356
I don't want to be there because
it's not very interesting

00:53:47.576 --> 00:53:49.146
so what I'm going end
up doing is finishing

00:53:49.146 --> 00:53:50.296
out and stepping back.

00:53:50.436 --> 00:53:52.956
So is there any way that we can
make that slightly more easy?

00:53:53.146 --> 00:53:55.816
And it turns out that we've
added something called targeted

00:53:55.816 --> 00:53:59.136
stepping so the option
is the step in target

00:53:59.136 --> 00:54:01.806
that you would say by
saying step and what I want

00:54:01.806 --> 00:54:04.346
to do is I want you to step
but I only want you to stop

00:54:04.346 --> 00:54:05.636
in this particular place,

00:54:05.636 --> 00:54:07.276
that's what you're
expressing with this.

00:54:07.676 --> 00:54:10.356
So let's try that in this
case and what we'll find is

00:54:10.356 --> 00:54:12.246
that it almost but
doesn't quite work

00:54:12.376 --> 00:54:13.946
and the reason it
doesn't quite work is

00:54:13.946 --> 00:54:16.286
because though we didn't
end up in the accessor,

00:54:16.436 --> 00:54:19.966
we ended up on the next source
line instead of in our function.

00:54:19.966 --> 00:54:21.406
And that makes sense
when you think about it

00:54:21.406 --> 00:54:24.156
because actually stepping is
source line by source line

00:54:24.306 --> 00:54:25.976
and that was the multiline call.

00:54:26.046 --> 00:54:29.786
So we've also added the
ability to specify the end range

00:54:29.786 --> 00:54:31.186
of the stepping operation

00:54:31.386 --> 00:54:33.056
by saying what the
end line number is

00:54:33.216 --> 00:54:35.566
or even more conveniently
you can say just step

00:54:35.566 --> 00:54:38.756
through this block and get me
in to do something I don't care.

00:54:38.996 --> 00:54:40.596
And there's even
an alias for that

00:54:40.596 --> 00:54:43.376
which is sif step in function.

00:54:43.676 --> 00:54:46.406
So then what you would do
is you would be sitting here

00:54:46.406 --> 00:54:49.256
and you would say step in
function and then you'd land

00:54:49.256 --> 00:54:51.006
in the right place or if you
didn't I wouldn't have put it

00:54:51.006 --> 00:54:51.526
on the slide.

00:54:52.386 --> 00:54:54.616
So that I want to conclude
with a couple little bits

00:54:54.616 --> 00:54:56.036
of troubleshooting information.

00:54:56.346 --> 00:54:58.926
One piece of information
you often need

00:54:58.926 --> 00:55:02.446
to know is what is actually
in my running program.

00:55:02.636 --> 00:55:05.366
For instance maybe I built
the release and debug versions

00:55:05.546 --> 00:55:07.716
and I want to know which
one I'm actually using

00:55:07.976 --> 00:55:10.116
or somebody gave me a
library with a dSYM.

00:55:10.116 --> 00:55:11.556
Did the dSYM get read in?

00:55:11.876 --> 00:55:13.356
So the command that inquiries

00:55:13.566 --> 00:55:15.956
about that information is
the image list command.

00:55:15.956 --> 00:55:18.016
You can either give
it a module name

00:55:18.016 --> 00:55:19.356
in which case it will
tell you information

00:55:19.356 --> 00:55:21.636
about just one module
loaded into your program

00:55:21.636 --> 00:55:26.656
or for amusement's sake you can
give no options you'll show all

00:55:26.656 --> 00:55:28.256
of them which is
sometimes eye opening.

00:55:28.536 --> 00:55:32.216
So here's an example just
to see how it's used.

00:55:32.536 --> 00:55:37.466
I say image list example
and I see here is the path

00:55:37.466 --> 00:55:39.096
to the binary so for
instance if I wanted

00:55:39.096 --> 00:55:41.476
to check whether I was
using the debug build, yeah,

00:55:41.476 --> 00:55:43.436
okay it does look like
I'm using the debug build

00:55:43.706 --> 00:55:45.706
and if there is a
dSYM available,

00:55:45.706 --> 00:55:47.636
it will always be
listed after the binary

00:55:47.636 --> 00:55:49.686
so in this case I see
I did get my binary.

00:55:50.066 --> 00:55:53.376
I want to tell you one thing
about Swift debug information.

00:55:53.486 --> 00:55:56.306
I put on this slide the why
but I'm not actually going

00:55:56.306 --> 00:55:57.966
to tell you the why because
we're running a little short

00:55:57.966 --> 00:56:01.956
of time, but I'll tell you
the TLDR because I'm going

00:56:01.956 --> 00:56:03.416
through too fast
for you to read.

00:56:03.416 --> 00:56:06.986
The TLDR is that because of
the way Swift and LLDB work

00:56:06.986 --> 00:56:09.956
with one another all the
Swift code that you have

00:56:09.956 --> 00:56:13.236
that has debug information
has to have been built locally

00:56:13.446 --> 00:56:16.726
so copying binaries from other
people doesn't currently work

00:56:16.726 --> 00:56:17.426
and stuff like that.

00:56:17.426 --> 00:56:18.386
You have to have made sure

00:56:18.386 --> 00:56:21.626
that everything has been built
locally and with the compiler

00:56:21.816 --> 00:56:23.426
that goes along with
the debugger

00:56:23.426 --> 00:56:24.586
that you're currently using.

00:56:25.436 --> 00:56:29.216
I want to say this is one
little convenience we've offered

00:56:29.216 --> 00:56:31.896
and so Enrico's rule of
optimized code debugging

00:56:31.896 --> 00:56:35.186
as we saw earlier is don't do
it if you don't have to and then

00:56:35.336 --> 00:56:40.416
since most software developers
are rational actors you can

00:56:40.416 --> 00:56:42.936
write a corollary to that
which is that most people

00:56:42.936 --> 00:56:45.866
who debug optimized code
actually do it by accident.

00:56:46.206 --> 00:56:48.576
So now LLDB will tell you

00:56:48.736 --> 00:56:51.966
that a file was compiled
optimized when you stop in it.

00:56:51.966 --> 00:56:54.436
It will only tell
you once per library

00:56:54.606 --> 00:56:56.006
and you'll get a little
message like this.

00:56:56.006 --> 00:56:58.346
And then you run quickly
to your build settings

00:56:58.556 --> 00:57:00.826
and change them back.

00:57:00.956 --> 00:57:03.266
One other new feature
that was added

00:57:03.266 --> 00:57:05.836
to clang a while ago was
this notion of modules.

00:57:06.076 --> 00:57:09.536
So modules are a way to
allow the compiler to look

00:57:09.536 --> 00:57:11.946
at all the headers that
are the header environment

00:57:11.946 --> 00:57:16.766
for your program, compile
them, parse them up once

00:57:17.036 --> 00:57:19.646
and then reuse that
for all the compiles.

00:57:19.906 --> 00:57:22.426
So then we thought well why
can't we also do the same thing

00:57:22.426 --> 00:57:24.116
for the debug information?

00:57:24.116 --> 00:57:28.366
Why don't we allow that parsed
form of the type information

00:57:28.366 --> 00:57:34.136
to be also done once and then
shared amongst all the .o files

00:57:34.136 --> 00:57:35.386
that you have debug information?

00:57:35.386 --> 00:57:38.086
So that's called clang
module debug feature.

00:57:38.086 --> 00:57:40.786
We can also use PCH
files by the way.

00:57:40.966 --> 00:57:44.756
The setting in Xcode is
clang module debugging

00:57:44.756 --> 00:57:46.906
and here's the flag for
some reason I put that in.

00:57:47.176 --> 00:57:51.086
This is great because again like
with the compiler this speeds

00:57:51.086 --> 00:57:53.816
up the generation of the debug
information, it will speed

00:57:53.816 --> 00:57:58.266
up your compile times but it has
one caveat, and that caveat is

00:57:58.266 --> 00:58:00.326
that or actually one major one.

00:58:00.326 --> 00:58:03.696
So that caveat is that now
your debugging is depending

00:58:03.696 --> 00:58:06.226
on your .o files but also
on something that's sitting

00:58:06.226 --> 00:58:07.706
in some cache somewhere.

00:58:08.096 --> 00:58:11.526
So normally that's not a
problem everything is in place

00:58:11.686 --> 00:58:15.296
but when you go to ship
your library or application

00:58:15.296 --> 00:58:17.536
to somebody else, how
is that going to work?

00:58:17.536 --> 00:58:19.356
Well, if it's an application

00:58:19.356 --> 00:58:23.426
or a framework then you just
run dsymutil like you already do

00:58:23.426 --> 00:58:24.436
and it does the right job,

00:58:24.436 --> 00:58:26.506
it gathers everything
together and that all works.

00:58:26.806 --> 00:58:30.326
But remember that dsymutil
only works on linked products,

00:58:30.326 --> 00:58:32.086
it doesn't work on .o files.

00:58:32.306 --> 00:58:35.836
So if you are shipping static
archives with debug information,

00:58:36.076 --> 00:58:38.676
then you must turn off
this G module's feature

00:58:38.676 --> 00:58:42.026
or you will ship broken debug
information to your clients.

00:58:42.076 --> 00:58:44.616
And also by the way, if you're
running out of disk space

00:58:44.616 --> 00:58:47.076
and you delete your module
cache, now you're not going

00:58:47.076 --> 00:58:48.186
to be able to debug anymore.

00:58:48.786 --> 00:58:51.356
So that's the only down
side to that feature.

00:58:52.056 --> 00:58:55.406
So with that let me tell
you what you've seen.

00:58:56.006 --> 00:58:59.196
We hope that you see that LLDB
is an extremely customizable

00:58:59.196 --> 00:59:03.136
debugger providing you many
ways to look at your data

00:59:03.136 --> 00:59:06.246
that expressions actually
give you much more power

00:59:06.246 --> 00:59:08.966
for investigation and I
thought Sean's example was great

00:59:08.966 --> 00:59:11.396
of how you actually
live go through

00:59:11.396 --> 00:59:14.236
and find what you're interested
in in a complex array,

00:59:14.656 --> 00:59:17.416
that we have more
breakpoint types than you know

00:59:17.416 --> 00:59:21.506
of in your Xcode and that
you can actually get yourself

00:59:21.506 --> 00:59:23.346
into super deep trouble
with more

00:59:23.346 --> 00:59:24.586
than source level debugging,

00:59:24.586 --> 00:59:27.716
and in general we hope we
provide you a rich set of tools

00:59:27.716 --> 00:59:28.786
for exploring your code.

00:59:29.086 --> 00:59:32.036
And here are a couple
of the previous sessions

00:59:32.036 --> 00:59:33.426
that might have interesting
information.

00:59:33.586 --> 00:59:36.246
There were a couple of sessions
earlier on which you didn't see

00:59:36.476 --> 00:59:39.326
or did see but anyway they
are available on slides.

00:59:39.416 --> 00:59:40.786
And with that thank
you and I hope

00:59:40.786 --> 00:59:42.976
that you enjoy the little tiny
bit that remains of your WWDC.

00:59:43.016 --> 00:59:45.000
[ Applause ]
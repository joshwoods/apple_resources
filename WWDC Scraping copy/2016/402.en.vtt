WEBVTT

00:00:06.516 --> 00:00:17.500
[ Music ]

00:00:24.456 --> 00:00:24.976
>> Good morning.

00:00:25.516 --> 00:00:29.356
[ Applause ]

00:00:29.856 --> 00:00:33.356
Welcome to What's New in Swift.

00:00:33.356 --> 00:00:35.626
Let's start out by
talking about the goals

00:00:35.626 --> 00:00:37.206
for the Swift 3 release.

00:00:37.366 --> 00:00:41.456
Swift was released as an open
source project just six months

00:00:41.456 --> 00:00:44.826
ago, and a big part of doing
that was not just to shove

00:00:44.826 --> 00:00:46.526
out a bunch of sources
to GitHub,

00:00:46.526 --> 00:00:49.766
but to create a fully
open community

00:00:50.316 --> 00:00:53.286
that drives the evolution
of Swift going forward.

00:00:54.126 --> 00:00:58.136
Swift 3 is the first major
update to Swift that is intended

00:00:58.136 --> 00:01:02.006
to be a product of that
community, and so we'll talk

00:01:02.006 --> 00:01:05.016
about how that community has
evolved and the language,

00:01:05.096 --> 00:01:06.476
the evolution process

00:01:06.806 --> 00:01:09.416
that crafts the language going
forward, and Chris will talk

00:01:09.416 --> 00:01:14.556
about what that community
has produced for Swift 3.

00:01:14.766 --> 00:01:18.686
Another big aspect for this
release was bringing Swift

00:01:18.686 --> 00:01:19.696
to more people.

00:01:20.526 --> 00:01:23.556
Today's software
ecosystems are really diverse

00:01:23.596 --> 00:01:25.576
and people are doing a
lot of different things

00:01:25.996 --> 00:01:28.086
in different contexts,
whether they are building it

00:01:28.086 --> 00:01:31.086
for the server, they are
building apps, and others.

00:01:31.136 --> 00:01:34.436
We want Swift to be available
for everybody, and so we'll talk

00:01:34.436 --> 00:01:38.526
about some great things that
have happened on the Linux side.

00:01:38.526 --> 00:01:41.446
And this is really the
first major update to Swift

00:01:41.626 --> 00:01:43.626
since Swift was ported to Linux.

00:01:44.776 --> 00:01:49.346
Now, looking inward at the
release, Swift has been going

00:01:49.346 --> 00:01:51.466
through some iterate
refinement and sculpting

00:01:51.606 --> 00:01:55.156
over the last two releases,
based a lot from feedback

00:01:55.156 --> 00:01:58.926
from developers who are using
it, and also, as you'll see

00:01:58.926 --> 00:02:01.486
from the Swift community
since it was open sourced.

00:02:02.186 --> 00:02:04.226
A big thing about Swift
3 is we really want

00:02:04.226 --> 00:02:07.396
to get those core fundamentals
into shape, all right,

00:02:07.396 --> 00:02:10.205
so we can really build on
top of them going forward.

00:02:11.416 --> 00:02:15.176
And last, and probably the most
broadest goal, is we really want

00:02:15.176 --> 00:02:17.796
to awesomize Swift
for awesomeness.

00:02:17.796 --> 00:02:18.246
All right?

00:02:19.156 --> 00:02:22.566
Swift is really intended to
be a powerful tool in the hand

00:02:22.596 --> 00:02:25.816
of developers, and in their
hands they can do really

00:02:25.816 --> 00:02:26.756
amazing things.

00:02:27.296 --> 00:02:28.536
That's what we intended
it to be.

00:02:29.496 --> 00:02:31.796
Now, this is a really
kind of broad goal,

00:02:32.066 --> 00:02:35.306
and the way we've been directing
our efforts here is listening

00:02:35.306 --> 00:02:38.096
to feedback from those
using Swift, app developers,

00:02:38.636 --> 00:02:41.456
but also how we're
using it within Apple.

00:02:42.186 --> 00:02:43.416
And so I want to
talk a few minutes

00:02:43.416 --> 00:02:45.196
about how we've been
using Swift, particularly

00:02:45.276 --> 00:02:48.556
in the last year in our
OS releases and the tools.

00:02:49.856 --> 00:02:52.506
Now, the big thing here is it's
not just increased adoption

00:02:52.506 --> 00:02:54.936
at Apple; it's just we're
using Swift in a variety

00:02:54.936 --> 00:02:57.886
of different ways, whether
it's in writing apps,

00:02:57.996 --> 00:03:00.386
we have internal frameworks
that are now using Swift,

00:03:00.386 --> 00:03:02.146
Agents and Daemons,
things that just kind

00:03:02.146 --> 00:03:04.516
of power the underlying
experiences

00:03:04.846 --> 00:03:06.156
in the operating system.

00:03:06.756 --> 00:03:09.986
And so if you can look, you
know, to Sierra, iOS 10,

00:03:09.986 --> 00:03:13.796
you can see things like the New
Music app using a significant

00:03:13.796 --> 00:03:14.996
amount of Swift.

00:03:14.996 --> 00:03:18.676
The Console app in Sierra
which is very much tied

00:03:18.676 --> 00:03:25.396
to the new logging initiatives,
also has a lot of use of Swift.

00:03:25.396 --> 00:03:27.156
Also with the Agents and
Daemons, the new picture

00:03:27.156 --> 00:03:31.616
in picture feature in Sierra is
100 percent written in Swift.

00:03:32.666 --> 00:03:35.826
Now, looking to the Tools,
Xcode, if you look inside,

00:03:36.066 --> 00:03:37.336
it's using Swift as well.

00:03:37.496 --> 00:03:39.496
For example, the new
documentation viewer

00:03:39.496 --> 00:03:41.936
in Xcode 8 is 100
percent written in Swift.

00:03:42.526 --> 00:03:45.406
And the new beautiful
Swift Playgrounds for iOS,

00:03:45.896 --> 00:03:47.766
that's 100 percent
written in Swift as well.

00:03:48.636 --> 00:03:52.286
So we are really using Swift
in many different ways.

00:03:52.346 --> 00:03:56.306
And this is really focusing our
efforts to solve different kinds

00:03:56.306 --> 00:03:58.266
of problems, whether
it's performance issues,

00:03:58.266 --> 00:04:01.886
such as memory usage, getting
the calling conventions right,

00:04:02.066 --> 00:04:03.356
and so forth, and
just making sure

00:04:03.356 --> 00:04:06.726
that Swift is the right
tool in different contexts.

00:04:07.046 --> 00:04:09.806
I want to talk about a
particular case study,

00:04:09.926 --> 00:04:11.376
and that's the Dock.

00:04:12.326 --> 00:04:15.056
And the Dock is interesting
for two reasons.

00:04:16.406 --> 00:04:19.296
The first reason is it's a
lot more than people think.

00:04:19.296 --> 00:04:23.086
It's not just the bar at
the bottom of your desktop.

00:04:23.526 --> 00:04:26.746
It's actually a large amount
of the macOS Windows, you know,

00:04:26.746 --> 00:04:27.966
management experience.

00:04:28.456 --> 00:04:31.976
So things like Mission
Control, LaunchPad, Spaces,

00:04:31.976 --> 00:04:34.816
this is all what we
consider part of the Dock.

00:04:36.166 --> 00:04:38.906
The second reason why Dock is
interesting is it's actually

00:04:38.906 --> 00:04:40.556
been a Swift adopter
for two releases.

00:04:40.556 --> 00:04:43.176
It started adopting
Swift in El Capitan.

00:04:43.176 --> 00:04:45.586
So we have two releases
to look at and to compare

00:04:45.586 --> 00:04:46.696
in how it was using Swift.

00:04:47.606 --> 00:04:51.396
So a lot of changes happened
to the Dock in Sierra.

00:04:52.506 --> 00:04:56.576
First, almost all of Mission
Control was rewritten in Swift,

00:04:56.576 --> 00:04:58.956
and the accessibility engine
was rewritten in Swift.

00:04:59.516 --> 00:05:00.306
Why did we do this?

00:05:00.306 --> 00:05:03.186
We just didn't rewrite code just
for the sake of rewriting code.

00:05:03.756 --> 00:05:06.206
The code had kind of grown
organically over time

00:05:06.206 --> 00:05:09.146
as features had been added and
it was time to refactor it.

00:05:09.616 --> 00:05:12.256
But also some new functionality
needed to be implemented,

00:05:12.256 --> 00:05:15.606
and so it was the
appropriate time to make this,

00:05:15.606 --> 00:05:16.836
you know, to do this rewrite.

00:05:18.116 --> 00:05:20.626
Now, what does this look
like at the project level?

00:05:21.486 --> 00:05:25.296
So to give you an idea, Dock
is about 200,000 lines of code

00:05:26.186 --> 00:05:29.966
with tens of thousands of
lines written in Swift.

00:05:29.966 --> 00:05:34.676
And between El Capitan and
Sierra, the amount of Swift code

00:05:34.676 --> 00:05:36.286
in the project more
than doubled.

00:05:37.596 --> 00:05:39.616
And this actually, because
this is part of a rewrite,

00:05:40.176 --> 00:05:42.236
this replaced a significant
amount

00:05:42.236 --> 00:05:43.716
of C and Objective-C code.

00:05:45.456 --> 00:05:47.726
And the effects here
are somewhat non-linear,

00:05:48.146 --> 00:05:49.346
because there's some refactoring

00:05:49.346 --> 00:05:52.036
and some new features being
added, but we saw there was

00:05:52.036 --> 00:05:55.166
about 15 percent less code
to replace the existing C

00:05:55.166 --> 00:05:57.766
and Objective-C code in Swift,

00:05:57.766 --> 00:06:00.786
and this is with new features
being added at the same time.

00:06:01.686 --> 00:06:05.286
And the net result is this
project is actually slightly

00:06:05.286 --> 00:06:08.786
smaller in Sierra than
it was in El Capitan.

00:06:10.136 --> 00:06:13.186
Now, there's a lot you
can read into statistics.

00:06:13.646 --> 00:06:16.526
I think the most important thing
here is the engineers working

00:06:16.526 --> 00:06:18.826
on the Dock love using Swift.

00:06:19.416 --> 00:06:20.796
They are not mandated to use it.

00:06:21.166 --> 00:06:21.866
They volunteered.

00:06:22.106 --> 00:06:25.506
They really just
wanted to use Swift.

00:06:25.506 --> 00:06:27.656
And their experience
is that they feel

00:06:28.066 --> 00:06:30.036
that they can more
easily articulate the code

00:06:30.036 --> 00:06:32.576
that they want to write and
they love the safety features

00:06:32.576 --> 00:06:34.366
from Swift that gives
them more assurance

00:06:34.366 --> 00:06:35.806
that the code they
write is great.

00:06:36.406 --> 00:06:39.786
Let's move on to
Swift Open Source.

00:06:40.356 --> 00:06:42.426
If you haven't already,
the place to go

00:06:42.426 --> 00:06:44.466
on the web is swift.org.

00:06:45.196 --> 00:06:48.106
And there you can find a variety
of ways that you can contribute

00:06:48.106 --> 00:06:50.056
to the project, such
as if you want

00:06:50.056 --> 00:06:52.016
to do the most awesome
profession in the world

00:06:52.016 --> 00:06:54.656
and be a compiler hacker, you
can check out the source code

00:06:54.656 --> 00:06:56.186
and find ways to contribute.

00:06:56.486 --> 00:06:58.676
And there's other ways.

00:06:58.976 --> 00:07:01.026
You know, you can contribute
ideas, where do we want

00:07:01.026 --> 00:07:02.516
to take the Swift language?

00:07:04.476 --> 00:07:07.716
Now, how we run the
project is really important.

00:07:08.426 --> 00:07:10.536
It's meant to be
very egalitarian.

00:07:11.116 --> 00:07:14.916
We want it to be a very
open process and transparent

00:07:15.106 --> 00:07:18.786
and free, and everyone
can really participate

00:07:19.066 --> 00:07:20.376
in driving the language forward.

00:07:20.626 --> 00:07:23.686
And they can see the rationale
of why changes were made.

00:07:24.286 --> 00:07:25.236
This is really important.

00:07:25.646 --> 00:07:28.196
And so all changes to language,
whether you are somebody

00:07:28.196 --> 00:07:31.096
who works at Apple or
you're someone out there

00:07:31.096 --> 00:07:33.706
who is writing apps and you have
an idea of how to contribute

00:07:33.816 --> 00:07:36.316
to change Swift, it works
exactly the same way.

00:07:36.316 --> 00:07:38.586
And I think this is
really, really important.

00:07:39.116 --> 00:07:43.026
And it also means that non-Apple
engineers do have direct access,

00:07:43.026 --> 00:07:45.036
you know, to commit
to the compiler

00:07:45.036 --> 00:07:46.346
and all those repositories.

00:07:46.716 --> 00:07:48.996
And so we really wanted
to empower the community

00:07:49.336 --> 00:07:50.426
to drive Swift forward.

00:07:50.906 --> 00:07:53.506
Third, and I think this
is just as important,

00:07:53.886 --> 00:07:56.186
we have a very strong code
of conduct for the project,

00:07:56.466 --> 00:07:59.576
and we think it's very important
that everyone can contribute

00:07:59.576 --> 00:08:02.546
without feeling that they are
discriminated against or treated

00:08:02.546 --> 00:08:05.626
in an unprofessional manner, and
we enforce this very strongly.

00:08:06.956 --> 00:08:11.836
And last, the project is under a
Permissive Open Source License.

00:08:12.326 --> 00:08:14.286
This is really important,
because we want Swift to be used

00:08:14.286 --> 00:08:17.066
in ways that Apple
didn't conceive.

00:08:17.296 --> 00:08:20.166
This is one of the goals
of open sourcing Swift.

00:08:20.166 --> 00:08:23.886
We really want everyone to be
able to use it in a lot of ways.

00:08:24.456 --> 00:08:26.466
And there's strong
patent protection

00:08:26.636 --> 00:08:27.896
for the community as well.

00:08:28.146 --> 00:08:29.726
So that's why we
chose this license.

00:08:31.196 --> 00:08:35.126
Now, you can follow along
with top of, you know,

00:08:35.686 --> 00:08:37.666
Trunk Development for
Swift in a variety of ways.

00:08:37.666 --> 00:08:38.706
You can check out the sources.

00:08:38.706 --> 00:08:39.606
You can build the compiler.

00:08:40.635 --> 00:08:43.206
We also provide downloadable
snapshots regularly,

00:08:43.206 --> 00:08:46.186
that you can download from
Swift or you can use directly

00:08:46.186 --> 00:08:48.476
in Xcode, or you can
use them on Linux.

00:08:48.476 --> 00:08:50.386
And as other platforms
are supported,

00:08:50.386 --> 00:08:52.786
we will provide those
snapshots as well.

00:08:53.686 --> 00:08:54.476
What's really awesome

00:08:54.476 --> 00:08:57.076
in an Xcode 8 is we now have
full support for Playgrounds

00:08:57.076 --> 00:08:58.836
with these downloadable
snapshots,

00:08:59.186 --> 00:09:01.656
which is a really
awesome way to experiment

00:09:01.656 --> 00:09:03.356
with the language as it evolves.

00:09:03.726 --> 00:09:06.066
Also, you no longer have to
restart Xcode if you want

00:09:06.066 --> 00:09:07.226
to use one of these tool chains,

00:09:07.226 --> 00:09:10.976
so this really creates a really
clean experience with trying

00:09:10.976 --> 00:09:12.886
out the latest version of Swift.

00:09:13.436 --> 00:09:17.266
Now, all the development
is happening now on GitHub,

00:09:17.916 --> 00:09:20.036
and it's not just one project.

00:09:20.036 --> 00:09:22.616
It's actually a family
of repositories,

00:09:22.616 --> 00:09:25.176
and you can find a description
of all of them on swift.org,

00:09:25.176 --> 00:09:27.816
but they can roughly
be categorized

00:09:27.816 --> 00:09:31.816
into these three
sections, the Language

00:09:31.816 --> 00:09:34.956
and its evolution
process, a Package Manager,

00:09:35.496 --> 00:09:36.786
and a set of Core Libraries.

00:09:37.116 --> 00:09:38.216
Let me talk about each.

00:09:39.816 --> 00:09:41.966
Now, the Package
Manager was announced

00:09:42.126 --> 00:09:43.716
when Swift went Open Source.

00:09:44.356 --> 00:09:47.286
It's still very early but
active in development.

00:09:47.286 --> 00:09:50.906
There's over 1,000
repositories on GitHub

00:09:51.156 --> 00:09:52.626
that use the Package Manager.

00:09:52.966 --> 00:09:54.406
So what is this?

00:09:55.446 --> 00:09:58.836
It's a cross-platform, Package
Manager, for building, you know,

00:09:58.836 --> 00:10:00.846
packages for Linux, for 0S 10.

00:10:01.216 --> 00:10:04.436
The idea is that we want to
build, enable the community

00:10:04.436 --> 00:10:07.216
to build, a software
ecosystem for Swift.

00:10:07.216 --> 00:10:09.196
And we think this is really
vital for bringing Swift

00:10:09.196 --> 00:10:11.656
to other contexts, like
Swift on the server.

00:10:13.526 --> 00:10:15.866
It's designed for very
frictionless development.

00:10:15.866 --> 00:10:19.216
It's like easy to get
started, minimal configuration,

00:10:19.626 --> 00:10:21.436
easy to articulate
your dependencies.

00:10:21.606 --> 00:10:24.196
It's just -- the idea is
just write your code and go.

00:10:24.246 --> 00:10:30.276
And we think the Package Manager
is so fundamental to Swift

00:10:30.326 --> 00:10:33.166
and its long-term success
that we are committed

00:10:33.166 --> 00:10:34.916
to delivering fantastic
integration

00:10:34.916 --> 00:10:37.646
of the Package Manager
in Xcode as it matures.

00:10:38.186 --> 00:10:43.286
Let's talk about
the Core Libraries.

00:10:43.606 --> 00:10:44.236
So what are these?

00:10:45.666 --> 00:10:48.656
There's a lot of
great APIs in iOS,

00:10:48.656 --> 00:10:51.646
in macOS, TD OS, and WatchOS.

00:10:52.236 --> 00:10:55.336
A lot of these are like part
of the base substrate of APIs

00:10:55.336 --> 00:10:56.576
that we think should
be available

00:10:56.576 --> 00:10:58.356
for everyone to get work done.

00:10:59.226 --> 00:11:02.076
And so the Core Libraries
represent alternate

00:11:02.196 --> 00:11:05.236
implementations that aren't
tied to the Objective-C run time

00:11:05.706 --> 00:11:09.546
of some of these core APIs on
Linux, and also other platforms

00:11:09.546 --> 00:11:13.836
that Swift will be ported to, so
notable examples include things

00:11:13.836 --> 00:11:16.406
like XE tests, so you
can write unit tests,

00:11:17.076 --> 00:11:20.236
a subset of foundation that
really is quite portable

00:11:20.236 --> 00:11:23.756
and not really tied to Cocoa,
and a work in progress port

00:11:23.756 --> 00:11:26.766
of libdispatch so you can use
all those concurrency APIs.

00:11:27.206 --> 00:11:29.896
Now, the work here is
still fairly early.

00:11:29.896 --> 00:11:31.216
It launched with
Swift Open Source,

00:11:31.366 --> 00:11:32.666
but there's a lot
there right now.

00:11:33.016 --> 00:11:36.456
So for foundation on Linux,
it supports a lot a great APIs

00:11:36.456 --> 00:11:41.736
like manipulating URLs, dates,
there's data, UID, and so forth.

00:11:41.956 --> 00:11:45.936
And we expect this to mature
and possibly grow in the future

00:11:45.936 --> 00:11:49.686
over time as the community
wants more functionality.

00:11:50.266 --> 00:11:55.036
Now, let's talk about
the Language.

00:11:55.886 --> 00:11:56.756
Now, Chris will talk a lot

00:11:56.756 --> 00:11:58.496
about specific changes
in the language.

00:11:58.796 --> 00:12:00.486
I want to talk about
the evolution process

00:12:00.716 --> 00:12:01.976
that creates those changes.

00:12:02.616 --> 00:12:05.376
This happens out on the
Swift-evolution repository.

00:12:06.396 --> 00:12:10.156
So let's say you have an idea
of how you want to change Swift.

00:12:10.156 --> 00:12:11.996
Like you think there's
something in there that sucks

00:12:11.996 --> 00:12:14.896
and some problem there
that really gets in the way

00:12:15.256 --> 00:12:16.186
of doing core development.

00:12:16.186 --> 00:12:18.346
Maybe it was a good design
decision two years ago,

00:12:18.346 --> 00:12:19.846
but it should be revisited.

00:12:20.406 --> 00:12:23.876
Or maybe there's something
great that we should add

00:12:24.256 --> 00:12:25.996
that would enable
a whole new set

00:12:25.996 --> 00:12:27.876
of opportunities for developers.

00:12:28.246 --> 00:12:28.826
Doesn't matter.

00:12:29.326 --> 00:12:31.356
You start the idea
by socializing it

00:12:31.456 --> 00:12:34.626
on a mailing list, kicking it
around with other developers

00:12:34.676 --> 00:12:37.096
who have similar
interests, and see,

00:12:37.126 --> 00:12:38.846
you know, is this a good idea?

00:12:39.286 --> 00:12:40.736
What are the pros and cons here?

00:12:41.006 --> 00:12:43.436
And once there's
enough critical mass,

00:12:44.256 --> 00:12:46.096
it gets turned into a proposal.

00:12:46.726 --> 00:12:48.626
This is just essentially
like a white paper,

00:12:49.116 --> 00:12:52.356
written in markdown, which
can be viewed, you know,

00:12:52.356 --> 00:12:54.196
right in a web browser
on GitHub.

00:12:54.896 --> 00:12:57.896
And here's an example of
actually one of the proposals,

00:12:58.786 --> 00:13:01.926
and it gets submitted for
review via pull request.

00:13:02.776 --> 00:13:05.626
Now, you notice in the bottom
left corner here this badge

00:13:05.626 --> 00:13:07.766
number, it says SE0046.

00:13:08.766 --> 00:13:11.496
Each proposal is numbered,
and this is how we refer to,

00:13:11.496 --> 00:13:13.376
you know, the actual
specific proposals

00:13:13.376 --> 00:13:15.456
that created change in Swift.

00:13:15.826 --> 00:13:19.086
Chris will refer to these
proposals throughout his part

00:13:19.086 --> 00:13:21.316
of the talk when he talks about
the changes to the language.

00:13:22.356 --> 00:13:26.896
And these proposals are the way
that everybody proposes changes

00:13:26.896 --> 00:13:29.146
to the language,
proposes the rationale

00:13:29.146 --> 00:13:31.746
of why we're doing
the change, you know,

00:13:32.836 --> 00:13:36.656
what the specific change
would be, the pros and cons,

00:13:37.056 --> 00:13:38.816
and once the proposal
is accepted,

00:13:39.006 --> 00:13:40.826
the rationale for accepting it.

00:13:41.916 --> 00:13:45.356
So a formal review for
a proposal starts just

00:13:45.356 --> 00:13:47.556
by accepting it into
the repository,

00:13:47.856 --> 00:13:51.356
and the review is really just
-- it's open discussion again.

00:13:51.356 --> 00:13:53.686
It's on the mailing list,
but this time it's focused

00:13:53.976 --> 00:13:55.476
to the specific proposal
as written,

00:13:55.476 --> 00:13:56.886
not just some abstract idea.

00:13:56.966 --> 00:14:01.126
And after some period of
time, the Swift core team,

00:14:01.126 --> 00:14:03.186
which is a small set of
individuals, whose role is just

00:14:03.186 --> 00:14:05.546
to shepherd the project going
forward, looks at the feedback

00:14:05.546 --> 00:14:08.926
of the community, sees, you
know, the pros and the cons,

00:14:09.376 --> 00:14:13.456
and arbitrates a decision based
on what the community wants.

00:14:13.836 --> 00:14:15.016
And they look at a
variety of things.

00:14:15.016 --> 00:14:17.926
How does the current
proposal fit into Swift?

00:14:18.346 --> 00:14:19.136
So does it make sense?

00:14:19.136 --> 00:14:21.166
So sometimes proposals are
sent back, hey, you know,

00:14:21.166 --> 00:14:24.376
the way it currently is, this
just doesn't work, you know,

00:14:24.376 --> 00:14:27.246
so go back and consider
some refinements here.

00:14:27.606 --> 00:14:29.426
Or this will just never
fit in Swift at all.

00:14:29.426 --> 00:14:32.916
But also the proposals
are often accepted,

00:14:33.406 --> 00:14:34.616
sometimes with refinements.

00:14:34.896 --> 00:14:37.046
And any time it's
sent back or accepted,

00:14:37.806 --> 00:14:39.156
a rationale is documented.

00:14:39.156 --> 00:14:41.036
So everyone can look
back at the history

00:14:41.276 --> 00:14:44.076
of the language evolution and
understand what was proposed

00:14:44.076 --> 00:14:47.796
and why it was proposed and why
it was accepted or rejected.

00:14:47.796 --> 00:14:52.186
And you can go and see all
the proposals just by going

00:14:52.186 --> 00:14:54.336
to the Swift-evolution
repository.

00:14:54.646 --> 00:14:57.116
And this is the process
that created Swift 3,

00:14:57.116 --> 00:14:59.446
a process driven by everyone.

00:14:59.896 --> 00:15:02.316
And to talk more about
what that has produced,

00:15:02.316 --> 00:15:03.976
I'm going to hand
it over to Chris.

00:15:04.516 --> 00:15:09.556
[ Applause ]

00:15:10.056 --> 00:15:12.276
>> Thank you, Ted.

00:15:12.276 --> 00:15:13.836
Well, with everything
else going on,

00:15:13.836 --> 00:15:15.286
unfortunately I didn't have time

00:15:15.286 --> 00:15:17.166
to prepare notes
and slides for you.

00:15:17.166 --> 00:15:19.086
But I printed out
all the proposals

00:15:19.086 --> 00:15:20.166
and I thought I'd
read them to you now.

00:15:20.916 --> 00:15:21.506
Sound good?

00:15:23.466 --> 00:15:23.956
[Laughter] Maybe not.

00:15:25.406 --> 00:15:26.556
So what are we trying
to do here?

00:15:27.476 --> 00:15:29.026
We said before that we want

00:15:29.026 --> 00:15:30.526
to make the core
experience of Swift great.

00:15:30.526 --> 00:15:32.246
And that isn't just
about the language.

00:15:32.366 --> 00:15:34.946
That's also the standard
library, the experience

00:15:34.946 --> 00:15:37.066
of working with major
APIs like Cocoa,

00:15:37.446 --> 00:15:39.096
and also working with our tools.

00:15:39.096 --> 00:15:41.156
And so we'll go through and talk
about each of these in turn.

00:15:42.216 --> 00:15:44.936
Now, our number one goal for
Swift 3 is source compatibility.

00:15:45.216 --> 00:15:46.646
And that's a big goal.

00:15:46.706 --> 00:15:49.496
That means we want to look at
what kind of code you write

00:15:49.496 --> 00:15:51.396
in your applications
and make sure

00:15:51.396 --> 00:15:52.866
that when Swift 3 comes out,

00:15:52.866 --> 00:15:54.906
that's the right
way going forward.

00:15:55.466 --> 00:15:57.616
And this is actually
a really hard problem,

00:15:57.616 --> 00:16:01.296
because this isn't just a
matter of do we use commas

00:16:01.296 --> 00:16:03.796
or do we use colons,
that kind of stuff.

00:16:04.106 --> 00:16:07.276
It's also about real key APIs
and doing everything possible

00:16:07.276 --> 00:16:09.416
to get Swift 3 into that
shape so that we can live

00:16:09.416 --> 00:16:11.356
with it forever and
get the churn

00:16:11.356 --> 00:16:12.606
out from underneath
you over with.

00:16:13.666 --> 00:16:16.246
Now, there's a number of
different aspects of this,

00:16:16.246 --> 00:16:17.746
one of which is that we're
going to incorporate this

00:16:17.746 --> 00:16:19.506
into the Swift-evolution
proposal process

00:16:19.506 --> 00:16:22.146
that Ted discussed before, so
that any proposals that come

00:16:22.146 --> 00:16:25.876
in after Swift 3 really think
about source compatibility.

00:16:26.856 --> 00:16:30.236
Now, I think the biggest aspect,
the biggest change in Swift 3

00:16:30.236 --> 00:16:31.536
that affects the
code that we write

00:16:31.536 --> 00:16:33.386
on a daily basis is the APIs.

00:16:33.386 --> 00:16:36.316
And so let's dive
into API naming

00:16:36.316 --> 00:16:38.066
and just get a quick
taste of what's going on.

00:16:39.166 --> 00:16:43.386
So APIs are an essential
part of how Apple thinks

00:16:43.386 --> 00:16:46.916
about building its platform in
building out the key components

00:16:46.916 --> 00:16:48.526
that you all work
with and you build

00:16:48.526 --> 00:16:49.936
on to make great applications.

00:16:50.476 --> 00:16:53.146
And the naming rules, and
the design approaches that go

00:16:53.146 --> 00:16:55.596
into that shape them in
a really fundamental way.

00:16:56.446 --> 00:16:57.826
And so with Swift 3, we looked

00:16:57.826 --> 00:17:00.676
at what is the best way
to write these APIs?

00:17:00.866 --> 00:17:02.736
Do we want full verbosity?

00:17:02.826 --> 00:17:06.146
Do we want full terseness and
like the smallest code possible?

00:17:06.756 --> 00:17:08.506
And what we found
is that the thing

00:17:08.506 --> 00:17:10.226
that really matters is clarity.

00:17:10.396 --> 00:17:11.955
And clarity at the point of use.

00:17:12.286 --> 00:17:13.695
And so we've really optimized

00:17:13.695 --> 00:17:15.996
for capturing the essential
important information

00:17:16.175 --> 00:17:18.616
without encoding lots of
boilerplate into APIs.

00:17:19.406 --> 00:17:22.276
Now, let's dive into a couple of
examples, and I'll show you some

00:17:22.276 --> 00:17:23.806
of the thought process
and rationale

00:17:23.806 --> 00:17:25.236
for what this means in practice.

00:17:26.026 --> 00:17:28.656
So here are a couple
of APIs in Swift 2.

00:17:29.576 --> 00:17:31.956
We will start with array
and append contents of.

00:17:32.406 --> 00:17:34.746
With Swift 3, this
gets chopped in half.

00:17:35.406 --> 00:17:38.896
The verb append, the
operation is now the operation.

00:17:39.386 --> 00:17:42.126
Contents of is something
that describes the role

00:17:42.126 --> 00:17:43.286
of the parameter you pass in.

00:17:43.536 --> 00:17:45.706
Now it's an argument
label that gets passed

00:17:46.086 --> 00:17:47.756
or gets used at the call site.

00:17:48.066 --> 00:17:49.626
This makes it a lot more
clear what's happening.

00:17:50.506 --> 00:17:54.016
Inserted index, this was
already in the proper verb form,

00:17:54.276 --> 00:17:57.706
but that index didn't add
any extra information.

00:17:57.896 --> 00:17:59.806
It was just repeating
type information

00:17:59.806 --> 00:18:01.126
that would be better
to be left off.

00:18:02.276 --> 00:18:05.266
In foundation, let's
look at NSURL.

00:18:05.646 --> 00:18:09.236
It has a file URL method or
property, and just from looking

00:18:09.236 --> 00:18:11.056
at it, it's not clear
that it returns e-Bullion

00:18:11.296 --> 00:18:13.946
and so now it starts with
is making it really clear.

00:18:14.726 --> 00:18:17.886
Another simple example is URL
by pending path component,

00:18:18.366 --> 00:18:20.736
it just drops the
redundantly encoded return type

00:18:21.046 --> 00:18:22.066
because it's not necessary.

00:18:22.796 --> 00:18:24.956
And so there's a ton of
different improvements like this

00:18:25.436 --> 00:18:27.456
that all kind of
add up together,

00:18:27.786 --> 00:18:29.616
and there's a lot more
detail and talk coming

00:18:29.616 --> 00:18:31.056
up right after this at 10:00.

00:18:31.946 --> 00:18:35.136
Now, let's talk about
Objective-C and CAPIs

00:18:35.136 --> 00:18:36.566
and how they work in Swift.

00:18:36.566 --> 00:18:40.416
Because again, that's a key
piece of how the APIs you work

00:18:40.416 --> 00:18:42.646
with look and how you
experience them in Swift.

00:18:43.576 --> 00:18:45.106
We've done a number of
great improvements here,

00:18:45.106 --> 00:18:46.946
so one we call import is member.

00:18:47.576 --> 00:18:49.926
Here's a typical core
graphics API written in C.

00:18:50.796 --> 00:18:53.156
In Swift 2 it would come in as
this global function, right?

00:18:53.996 --> 00:18:57.026
Well, this works, but this isn't
the kind of API we want to work

00:18:57.026 --> 00:18:59.796
with as Swift developers, and so
we've introduced a new feature

00:18:59.796 --> 00:19:04.136
that allows the API author to
tag their API with this macro

00:19:04.136 --> 00:19:06.506
that wraps an attribute
and now gets imported

00:19:06.506 --> 00:19:08.836
as a method providing the
beautiful object-oriented APIs

00:19:08.836 --> 00:19:10.856
that you have seen in core
graphics and dispatch.

00:19:11.326 --> 00:19:13.276
This is something you
can use in your code too.

00:19:15.026 --> 00:19:17.046
Another is generics.

00:19:17.136 --> 00:19:19.616
We introduced lightweight
generics last year with Swift 2,

00:19:19.616 --> 00:19:23.046
and we used them to import
typed collections into Swift.

00:19:23.216 --> 00:19:25.086
But a number of frameworks

00:19:25.086 --> 00:19:27.436
at Apple adopted lightweight
generics in other ways;

00:19:27.436 --> 00:19:29.636
for example, auto
layout and core data.

00:19:29.756 --> 00:19:31.996
With Swift 3 we are now able

00:19:31.996 --> 00:19:37.126
to import the fully general
generics right into Swift 3

00:19:37.126 --> 00:19:40.166
as generic types, which
means that a lot of cast

00:19:40.166 --> 00:19:42.766
and redundant coding of that
type information now can just

00:19:42.766 --> 00:19:43.166
go away.

00:19:44.376 --> 00:19:45.316
Let's talk --

00:19:46.516 --> 00:19:51.616
[ Applause ]

00:19:52.116 --> 00:19:53.286
Let's talk about constants.

00:19:53.796 --> 00:19:55.236
A common pattern
that we see in a lot

00:19:55.236 --> 00:19:58.706
of Cocoa APIs are
using strings as enums.

00:19:59.276 --> 00:20:02.226
And we do this because
that's in C the best way

00:20:02.226 --> 00:20:06.456
that we could find to encode an
openly extensible enum concept,

00:20:06.456 --> 00:20:07.956
but there are a lot of
disadvantages with this.

00:20:08.836 --> 00:20:12.126
These "enums," in quotes,
become these global constants

00:20:12.556 --> 00:20:14.936
which then get imported
directly into Swift as globals

00:20:15.166 --> 00:20:16.826
and they get used with
these big long names.

00:20:17.156 --> 00:20:18.906
This is really unfortunate
for a lot of reasons,

00:20:18.906 --> 00:20:21.456
one of which is it's
completely not type safe

00:20:21.556 --> 00:20:23.086
because you can pass
an arbitrary string

00:20:23.086 --> 00:20:23.846
and it won't work.

00:20:23.936 --> 00:20:27.426
It's also not great because
it pollutes code completion

00:20:27.426 --> 00:20:31.126
and it just doesn't feel
like a very Swift API,

00:20:31.396 --> 00:20:34.186
very good direction
for Swift APIs.

00:20:35.026 --> 00:20:36.636
With Swift 3 we solved this.

00:20:37.016 --> 00:20:40.196
So now an API author can
add a simple attribute

00:20:40.276 --> 00:20:42.786
to their type def and now
all of the different uses

00:20:42.786 --> 00:20:44.746
of this become strongly
typed in Swift.

00:20:45.116 --> 00:20:46.906
So you'll find with
NS notification names,

00:20:46.906 --> 00:20:50.706
a commonly used one, that these
now become scoped underneath

00:20:50.966 --> 00:20:53.826
user defaults in this
case, and now they get used

00:20:53.826 --> 00:20:55.146
with proper dot syntax.

00:20:56.086 --> 00:20:58.786
And the great thing about this
is it's actually type checked.

00:20:59.516 --> 00:21:04.586
[ Applause ]

00:21:05.086 --> 00:21:05.586
So there are a ton

00:21:05.586 --> 00:21:07.816
of improvements throughout
the SDK adopting these

00:21:07.816 --> 00:21:09.836
and other features that you
can learn about all week long.

00:21:10.156 --> 00:21:11.786
There are a number of
great talks this week.

00:21:12.766 --> 00:21:14.756
Let's dive into the
core language.

00:21:15.996 --> 00:21:19.496
So with these changes
as context, we went back

00:21:19.496 --> 00:21:20.836
and looked at parameter labels.

00:21:20.986 --> 00:21:24.246
And as a quick refresher, if you
had this function in Swift 2,

00:21:24.666 --> 00:21:27.496
you'd call it and
you'd use labels on two

00:21:27.496 --> 00:21:28.956
out of the three parameters.

00:21:28.956 --> 00:21:29.546
Why is that?

00:21:30.186 --> 00:21:34.176
Well, the answer is that we were
following the Objective-C naming

00:21:34.176 --> 00:21:36.656
and design patterns and
we wanted to be consistent

00:21:36.656 --> 00:21:38.666
with Cocoa and the Cocoa
experience in Swift.

00:21:39.236 --> 00:21:41.666
But of course we've just
radically changed how Cocoa

00:21:41.666 --> 00:21:44.786
works in Swift, and so now we're
able to bring argument labels

00:21:44.786 --> 00:21:45.686
to all the parameters,

00:21:46.016 --> 00:21:48.626
which makes the language a lot
more consistent and predictable.

00:21:49.516 --> 00:21:54.266
[ Applause ]

00:21:54.766 --> 00:21:55.896
Let's talk about generics.

00:21:56.306 --> 00:21:58.656
So the Swift generic
syntax, I think,

00:21:58.656 --> 00:22:00.086
is really beautiful
and expressive.

00:22:00.086 --> 00:22:04.086
It allows you to capture the key
essence of what a function does

00:22:04.366 --> 00:22:06.366
in a very concise
and very nice way.

00:22:07.506 --> 00:22:08.736
Unfortunately, though,
when you get

00:22:08.736 --> 00:22:10.286
into more advanced use cases,

00:22:10.286 --> 00:22:11.866
you start adding
generic constraints,

00:22:12.206 --> 00:22:14.926
and the generic constraints are
almost secondary to the behavior

00:22:14.926 --> 00:22:17.616
of the function in this
case, but they push

00:22:17.616 --> 00:22:20.676
down the primary signature
way down into the code

00:22:20.676 --> 00:22:22.066
and it makes it a lot
more difficult to read.

00:22:22.636 --> 00:22:25.116
With Swift 3, we've extended
the syntax and improved this,

00:22:25.446 --> 00:22:27.646
so now your signature is
right up front where you want

00:22:27.646 --> 00:22:29.976
to see it and the constraints
are now secondary to that.

00:22:30.516 --> 00:22:34.586
[ Applause ]

00:22:35.086 --> 00:22:36.406
Let's talk about unused results.

00:22:36.986 --> 00:22:38.056
So here's a simple function.

00:22:38.056 --> 00:22:39.716
It just adds one to a
number and returns it.

00:22:40.346 --> 00:22:42.136
With Swift 2, you
wouldn't get a warning

00:22:42.136 --> 00:22:44.376
about this code even though
it's almost certainly a bug.

00:22:44.866 --> 00:22:46.636
Maybe you forgot to
assign it to a variable.

00:22:46.636 --> 00:22:48.936
Maybe you're just calling it
the completely wrong function.

00:22:49.346 --> 00:22:53.746
Right? So with Swift 3 you
get a warning by default.

00:22:53.746 --> 00:22:54.326
It's safe.

00:22:54.366 --> 00:22:54.896
This is great.

00:22:55.676 --> 00:22:59.226
And this is also really good
because it composes well

00:22:59.226 --> 00:23:00.896
for more complicated
cases as well.

00:23:01.486 --> 00:23:03.476
So not all functions
are pure like this

00:23:03.476 --> 00:23:04.476
in the functional sense.

00:23:04.516 --> 00:23:06.326
Some of them actually
do have side effects.

00:23:06.326 --> 00:23:07.306
We live in the real world.

00:23:08.186 --> 00:23:10.816
And so you may be wondering,
well, if I have a side effect,

00:23:10.816 --> 00:23:12.946
maybe I'm calling this
just for that side effect.

00:23:13.736 --> 00:23:16.416
Well, that's okay, because you
can assign to the underbar,

00:23:16.826 --> 00:23:19.946
which tells the compiler
and humans who have

00:23:19.946 --> 00:23:22.556
to maintain your code that
you thought about the fact

00:23:22.556 --> 00:23:23.686
that this returned something

00:23:23.896 --> 00:23:26.856
and you explicitly don't
care about it, right?

00:23:27.296 --> 00:23:30.076
Now, not all functions
have this property.

00:23:30.076 --> 00:23:32.186
Some functions, which are
kind of the exceptions,

00:23:32.696 --> 00:23:35.156
have a side effect as
their primary behavior,

00:23:35.296 --> 00:23:37.276
and so the return value
is a secondary thing

00:23:37.276 --> 00:23:38.566
that often you don't care about.

00:23:38.826 --> 00:23:40.236
And so in those exceptional
cases,

00:23:40.236 --> 00:23:42.226
you can actually use an
attribute to say, hey,

00:23:42.576 --> 00:23:44.686
I know that this return
value is a secondary thing,

00:23:44.806 --> 00:23:47.216
never produce a warning
if it goes unused,

00:23:47.516 --> 00:23:48.456
which is a nice system.

00:23:49.546 --> 00:23:55.586
So let's talk about the most
exciting piece of Swift 3,

00:23:56.046 --> 00:23:57.416
features that go away.

00:23:57.416 --> 00:23:59.996
And you may be saying why
would you do this, right?

00:24:00.556 --> 00:24:03.026
But we really want Swift
3 to be great, right?

00:24:03.376 --> 00:24:06.256
And Swift 3 is the sum
of all of its pieces,

00:24:06.256 --> 00:24:07.796
and many of the pieces were put

00:24:08.156 --> 00:24:11.196
into Swift before we really knew
what the language would build

00:24:11.196 --> 00:24:13.126
into and where we
wanted it to go.

00:24:13.426 --> 00:24:16.036
And so what we did was we went
back and thought about all

00:24:16.036 --> 00:24:17.086
of the features in the language,

00:24:17.086 --> 00:24:18.286
no matter when they
were introduced,

00:24:18.286 --> 00:24:19.566
and asked a basic question.

00:24:20.526 --> 00:24:24.186
If this feature were not already
in Swift, would we add it now?

00:24:25.626 --> 00:24:27.136
And for some features,
the answer was no,

00:24:27.246 --> 00:24:28.276
and so we're taking them away.

00:24:29.016 --> 00:24:31.266
And this is a great way,
this is a great thing to do,

00:24:31.266 --> 00:24:33.116
because it simplifies the
language for everybody.

00:24:34.006 --> 00:24:38.776
Now, some of these I realize may
be polarizing or controversial.

00:24:39.676 --> 00:24:41.656
The great thing about
Swift-evolution is

00:24:41.656 --> 00:24:43.216
that we debated these
all as a community.

00:24:43.636 --> 00:24:47.226
Each of these has a proposal
with extensive rationale,

00:24:47.576 --> 00:24:49.906
and if you really want to go
back and read the hundreds

00:24:49.906 --> 00:24:52.186
of emails on each of these,
you can totally go back

00:24:52.226 --> 00:24:54.386
to the mailing list archive
and see what happened.

00:24:54.896 --> 00:24:56.686
I think that pretty
much every side

00:24:56.686 --> 00:24:58.836
of every perspective was
very well represented

00:24:58.836 --> 00:24:59.946
on these issues.

00:25:01.106 --> 00:25:04.076
So now there are a bunch
of other small enhancements

00:25:04.076 --> 00:25:06.266
to language as well, and I
don't have time to go into all

00:25:06.266 --> 00:25:08.516
of them, but we have things
like generic type aliases.

00:25:08.826 --> 00:25:12.726
We have type safe selector
and key path references.

00:25:13.126 --> 00:25:15.426
We have new build
configurations, improvements

00:25:15.426 --> 00:25:17.256
to power matching, a
ton of great stuff,

00:25:17.446 --> 00:25:19.306
and you can read them about
them either in the proposals

00:25:19.306 --> 00:25:21.686
or in the extra release notes.

00:25:22.036 --> 00:25:24.676
Now another aspect of the
core language is talking

00:25:24.676 --> 00:25:26.726
about syntax, right?

00:25:27.196 --> 00:25:30.386
And I think we all love,
and I hope you love,

00:25:30.386 --> 00:25:33.186
the basic syntactic
structure of Swift.

00:25:33.316 --> 00:25:35.276
I think it's one of the things
that draws a lot of people in,

00:25:35.276 --> 00:25:37.896
because it feels familiar and
it works really well together.

00:25:38.526 --> 00:25:40.146
But unfortunately,
not all of the pieces

00:25:40.146 --> 00:25:45.766
in Swift were considered
with the care of the hot path

00:25:45.766 --> 00:25:47.826
of the syntactic
structures we use every day,

00:25:48.426 --> 00:25:49.176
and so we went back,

00:25:49.176 --> 00:25:51.586
and repainted everything
a nice consistent shade

00:25:51.586 --> 00:25:55.506
of your favorite color
here, and we looked at a lot

00:25:55.506 --> 00:25:58.626
of the weird corner cases,
because those corner cases,

00:25:58.626 --> 00:26:01.116
if they are inconsistent with
the rest of the language,

00:26:01.116 --> 00:26:04.466
it makes them even harder to
use, and these are included

00:26:04.466 --> 00:26:06.036
in the Swift because
they are important.

00:26:06.566 --> 00:26:09.076
And so we went back and
standardized everything,

00:26:09.076 --> 00:26:10.486
and we really want
to get it right,

00:26:10.486 --> 00:26:11.686
so it's right for the long time.

00:26:12.666 --> 00:26:15.176
So that's a brief overview
of the core language.

00:26:15.176 --> 00:26:16.646
I want to dive a little
bit deeper now and talk

00:26:16.646 --> 00:26:17.546
about the type system.

00:26:18.676 --> 00:26:20.556
First of all, what
is the type system?

00:26:21.126 --> 00:26:23.926
The type system in Swift works
together with the type checker

00:26:24.526 --> 00:26:27.116
to define how types work,
and the type checker

00:26:27.116 --> 00:26:28.886
and the compiler
uses the type system

00:26:28.886 --> 00:26:33.416
to prove your code is correct
or validate that it's correct,

00:26:33.676 --> 00:26:36.336
as well as infer things that
you leave out of your code

00:26:36.336 --> 00:26:37.606
because it's supposed
to be implicit.

00:26:37.666 --> 00:26:40.586
For example, what
is a type of A?

00:26:40.586 --> 00:26:42.706
Swift 3, we wanted to
simplify the type system,

00:26:42.706 --> 00:26:44.626
make it more consistent,
and we also wanted

00:26:44.626 --> 00:26:47.636
to define away common types
of problems that people run

00:26:47.636 --> 00:26:49.646
into that were surprising
and led to bugs.

00:26:50.276 --> 00:26:53.126
So let's talk about a
few examples of this.

00:26:53.126 --> 00:26:54.986
First is unsafe pointer, right?

00:26:56.096 --> 00:26:58.936
So I don't know if you realize
this but you can actually

00:26:59.116 --> 00:27:01.836
in Swift 2 assign nil
to an unsafe pointer.

00:27:02.026 --> 00:27:03.946
You can test it directly
for nil,

00:27:04.206 --> 00:27:06.006
and you can actually
use unsafe pointers

00:27:06.006 --> 00:27:08.316
without having any idea
whether they hold a nil or not.

00:27:08.966 --> 00:27:11.416
This is really inconsistent
with the rest of the language

00:27:11.416 --> 00:27:13.886
and it makes unsafe
pointers even more unsafe.

00:27:13.886 --> 00:27:17.726
Well, with Swift 3, now
unsafe pointers cannot be nil,

00:27:17.726 --> 00:27:20.416
so you use optionals, just like
everything else in the language.

00:27:20.816 --> 00:27:24.206
You get to use if let to safely
test them and unwrap them,

00:27:24.526 --> 00:27:27.566
and you even get all the
syntactic affordances we provide

00:27:27.566 --> 00:27:30.636
optionals, which makes
everything just work a lot

00:27:31.796 --> 00:27:33.486
more predictably.

00:27:33.486 --> 00:27:35.576
Speaking of optionals,
another interesting part

00:27:35.576 --> 00:27:37.966
of the language is
implicitly unwrapped optionals.

00:27:38.966 --> 00:27:41.066
Implicitly unwrapped optionals
are a really important part

00:27:41.066 --> 00:27:42.926
of the language, particularly
when you are working

00:27:42.926 --> 00:27:45.236
with two-phase initialization
or you are calling an API

00:27:45.236 --> 00:27:47.206
that hasn't been
audited for nullability.

00:27:47.716 --> 00:27:50.196
Now, here's an overly simplified
example where I have an int,

00:27:50.356 --> 00:27:52.406
implicitly unwrapped
optional that I'm getting in,

00:27:52.726 --> 00:27:54.286
but this applies more
generally to lots

00:27:54.286 --> 00:27:55.276
of different types of things.

00:27:56.176 --> 00:27:57.246
Now, the basic way

00:27:57.246 --> 00:27:59.186
that implicitly unwrapped
optionals worked in Swift 2,

00:27:59.186 --> 00:28:01.306
I think, was understandable
for most people.

00:28:02.166 --> 00:28:06.026
In the case of X, for
example, well, the compiler has

00:28:06.026 --> 00:28:08.646
to force unwrap that implicitly
unwrapped optional in order

00:28:08.646 --> 00:28:10.016
to do the addition,
and so it does.

00:28:10.516 --> 00:28:12.716
In the case of Y, well,
it didn't have to,

00:28:12.716 --> 00:28:14.106
and so if just kind
of propagated it

00:28:14.106 --> 00:28:14.976
down through the code.

00:28:15.616 --> 00:28:17.996
Well, this propagation was
surprising for a lot of reasons.

00:28:18.636 --> 00:28:22.996
It also was surprising because
more complicated cases often led

00:28:22.996 --> 00:28:25.466
us to scratch our heads about
what the code actually does.

00:28:25.836 --> 00:28:28.136
Because you don't even know you
have an implicitly unwrapped

00:28:28.136 --> 00:28:29.286
optional in many cases.

00:28:30.086 --> 00:28:33.296
So here, I have an int and an
implicitly unwrapped optional.

00:28:33.386 --> 00:28:35.426
Does that implicitly
unwrapped optional get forced?

00:28:35.926 --> 00:28:36.836
Do I get an array of any?

00:28:36.836 --> 00:28:37.786
Do I get an array of optional?

00:28:37.786 --> 00:28:38.626
What is going on?

00:28:38.626 --> 00:28:40.496
Well, you never really
know until you go

00:28:40.496 --> 00:28:42.576
to compile your code and you
get some weird compiler error,

00:28:42.926 --> 00:28:45.496
and this is not the effect
that we're going for.

00:28:46.846 --> 00:28:49.696
So implicitly unwrapped
optional is really important

00:28:49.846 --> 00:28:54.196
as a concept, so we kept it,
but we changed how it works,

00:28:54.196 --> 00:28:55.896
to have a new, simpler model.

00:28:56.756 --> 00:28:58.196
The model is now very local.

00:28:58.336 --> 00:29:00.976
For any use of an
implicitly unwrapped optional,

00:29:01.756 --> 00:29:04.766
if the value can be used
as an optional, it is.

00:29:05.176 --> 00:29:06.176
That's the safe thing.

00:29:06.176 --> 00:29:08.016
We don't want to be
unwrapping values

00:29:08.346 --> 00:29:09.276
where you don't expect it.

00:29:10.006 --> 00:29:12.486
However, if the compiler
is required to unwrap it

00:29:12.556 --> 00:29:14.386
for type checking
to succeed, it does.

00:29:15.206 --> 00:29:17.126
So let's go through
some examples again.

00:29:17.826 --> 00:29:20.486
Here, we have X, the
compiler has to unwrap it

00:29:20.486 --> 00:29:22.036
to do the addition,
and so it does.

00:29:22.036 --> 00:29:24.406
This is the key aspect of what
makes implicitly unwrapped

00:29:24.406 --> 00:29:26.176
optionals different
than strong ones.

00:29:27.396 --> 00:29:30.856
Why? Well, here the compiler
can type check the expression

00:29:31.746 --> 00:29:33.936
as an optional, and
so now instead

00:29:33.936 --> 00:29:35.986
of propagating the
implicitly unwrapped optional,

00:29:35.986 --> 00:29:38.966
maybe deep down through your
code and many different levels,

00:29:39.356 --> 00:29:41.606
it turns into a strong optional,
which allows you to think

00:29:41.606 --> 00:29:44.876
about it and know
that that's there.

00:29:45.066 --> 00:29:46.326
This also leads to more
predictable behavior

00:29:46.326 --> 00:29:48.786
with the array, because now, of
course, this can be type checked

00:29:48.786 --> 00:29:50.826
as a strong optional,
and so it does.

00:29:50.936 --> 00:29:54.006
And if you actually
want it to be unwrapped,

00:29:54.206 --> 00:29:55.096
well, that's okay too.

00:29:55.096 --> 00:29:56.906
You can explicitly
wrap this in your code

00:29:56.906 --> 00:30:00.126
with the exclamation mark, and
now people who read it can know

00:30:00.126 --> 00:30:02.526
about that, and your
code is a lot better.

00:30:03.516 --> 00:30:07.196
So that's my quick tour of some
of the interesting things going

00:30:07.196 --> 00:30:07.966
on with the type system.

00:30:08.216 --> 00:30:09.836
Let's talk about the
standard library.

00:30:11.046 --> 00:30:13.756
The big news in the standard
library is a whole new

00:30:13.756 --> 00:30:15.026
collection indexing model.

00:30:16.206 --> 00:30:17.076
And what does that mean?

00:30:17.196 --> 00:30:18.766
Well, maybe you've
worked with indexes.

00:30:18.766 --> 00:30:19.376
Maybe not.

00:30:19.576 --> 00:30:21.356
There are a lot of great
ways to get indexes.

00:30:21.796 --> 00:30:23.416
The difference here
is in how they move.

00:30:24.106 --> 00:30:26.746
And previously in Swift 2, you'd
call them method on the index,

00:30:26.856 --> 00:30:28.386
like Successor, to
move it forward.

00:30:29.156 --> 00:30:32.196
In Swift 3, the model is
basically the same except now

00:30:32.196 --> 00:30:34.256
instead of the index
moving itself,

00:30:34.656 --> 00:30:38.136
the collection moves
the index with itself.

00:30:39.226 --> 00:30:40.546
And why would we do this?

00:30:40.746 --> 00:30:42.666
Well, there's a number of
great things at the Springs.

00:30:42.666 --> 00:30:44.566
First of all, we get to
simplify the standard library.

00:30:44.566 --> 00:30:46.546
A bunch of types just
go away, which is great.

00:30:47.116 --> 00:30:50.886
Even better, common kinds of
problems get defined away.

00:30:51.356 --> 00:30:52.906
You can now have an
inclusive range all the way

00:30:52.906 --> 00:30:56.136
up to the maximum element, which
previously would trigger a trap

00:30:56.136 --> 00:30:57.536
which nobody expected.

00:30:58.096 --> 00:30:59.916
We also think this is going
to bring better performance,

00:30:59.916 --> 00:31:01.666
because we can get rid
of our tandem releases

00:31:01.666 --> 00:31:02.866
with many common collections.

00:31:02.866 --> 00:31:04.526
So we are pretty
excited about this.

00:31:05.456 --> 00:31:07.466
Let's talk about numerics.

00:31:07.996 --> 00:31:10.776
We have a new floating point
protocol or family of protocols

00:31:10.776 --> 00:31:13.096
which help define
operations to allow you

00:31:13.096 --> 00:31:15.326
to write generic algorithms
across a broad range

00:31:15.326 --> 00:31:16.356
of FloatingPoint types.

00:31:17.266 --> 00:31:20.566
Even better, if you are a
numerical analysis type person

00:31:20.696 --> 00:31:23.356
and you understand IEEE
FloatingPoint, which is not me

00:31:23.756 --> 00:31:26.866
and not most people,
but it has a lot

00:31:26.866 --> 00:31:30.096
of great low level operations,
like getting the number of ULPS

00:31:30.096 --> 00:31:33.546
out of the whatever, some really
important smart stuff here.

00:31:35.566 --> 00:31:37.116
[Laughter] So I don't really
understand all that stuff.

00:31:37.116 --> 00:31:38.346
I think it's really
important, though,

00:31:38.346 --> 00:31:40.156
and people who do
really value it.

00:31:40.576 --> 00:31:44.226
I do understand things like
Pi, because everybody loves Pi.

00:31:44.966 --> 00:31:48.126
And in Swift 2 we always
got stuck using MPi,

00:31:48.126 --> 00:31:49.826
and it really irritated me

00:31:49.826 --> 00:31:51.906
because it was always the
wrong type, and you also had

00:31:51.906 --> 00:31:54.526
to cast it, and it always
led to huge frustration.

00:31:55.196 --> 00:31:58.236
Well, now, despite all
that IEEE stuff, you know,

00:31:58.236 --> 00:32:00.496
in addition to all that IEEE
stuff, we even get great things

00:32:00.496 --> 00:32:02.616
like Pi on all the
FloatingPoint types.

00:32:03.436 --> 00:32:05.376
And Swift often has
types available.

00:32:05.596 --> 00:32:07.426
And the other great
thing about this is

00:32:08.206 --> 00:32:11.176
that if you have typed
context, for example,

00:32:11.176 --> 00:32:14.566
here we're returning a CGFloat,
instead of doing a cast,

00:32:14.566 --> 00:32:17.836
you can use CGFloat.Pi, but
even better you can allow the

00:32:17.836 --> 00:32:20.196
compiler to infer that
completely for you.

00:32:20.566 --> 00:32:21.826
It leads to a really
nice result.

00:32:22.516 --> 00:32:27.166
[ Applause ]

00:32:27.666 --> 00:32:29.156
So as with the language,
there's a ton

00:32:29.156 --> 00:32:30.986
of great improvements
throughout the standard library.

00:32:31.376 --> 00:32:33.196
Some of these can really effect

00:32:33.196 --> 00:32:35.336
and really improve the
code you write in Swift,

00:32:35.336 --> 00:32:39.246
so I highly recommend sticking
around for the other Swift talks

00:32:39.246 --> 00:32:40.576
which will dive into
more information.

00:32:40.576 --> 00:32:44.316
So this was a quick tour of the
language, the standard library,

00:32:44.316 --> 00:32:48.436
how Cocoa works in Swift, but
the next big piece is how Swift

00:32:48.596 --> 00:32:49.916
and the tools work together.

00:32:50.186 --> 00:32:53.846
So to talk about that, I'd
like to invite up Ewa Matejska.

00:32:54.636 --> 00:32:54.846
Ewa?

00:32:55.516 --> 00:32:57.806
[ Applause ]

00:32:58.306 --> 00:32:59.026
>> Thank you, Chris.

00:33:01.556 --> 00:33:02.686
Good morning, everybody.

00:33:03.556 --> 00:33:06.896
Let's talk about Tools, and
what better place to start

00:33:06.896 --> 00:33:09.356
than what the tools can
do for your performance.

00:33:09.956 --> 00:33:12.856
As you can see, we've been
really busy this year,

00:33:13.606 --> 00:33:15.776
but let's talk about
a couple of these.

00:33:17.536 --> 00:33:20.646
We revamped the dictionary
implementation,

00:33:21.166 --> 00:33:22.756
and we also really focused

00:33:22.756 --> 00:33:27.256
on optimizing the string hashing
algorithms for ASCII strings,

00:33:27.756 --> 00:33:30.006
and we see some really
nice improvements

00:33:30.626 --> 00:33:33.216
in our micro benchmarks
for dictionaries

00:33:33.216 --> 00:33:35.326
that use strings
since last year.

00:33:36.736 --> 00:33:38.676
We also added stack promotion

00:33:39.236 --> 00:33:42.966
for class instances array
literals, where we promote

00:33:42.966 --> 00:33:46.676
from the heap, which is really
expensive, to the stack,

00:33:47.246 --> 00:33:49.016
and we see some really
nice improvements

00:33:49.016 --> 00:33:52.126
when our tests take
advantage of that.

00:33:53.416 --> 00:33:55.986
Also, as I already
described, we really focused

00:33:55.986 --> 00:33:59.246
on our string hashing
algorithms, and we see this

00:33:59.246 --> 00:34:04.176
in a dramatic way in our tests
that compared the prefixes

00:34:04.176 --> 00:34:08.446
and suffixes of strings, like
we get 86 times improvement.

00:34:10.295 --> 00:34:14.266
Next, I want to talk to you
about whole module optimization.

00:34:14.716 --> 00:34:17.025
This is a feature we
introduced last year,

00:34:17.166 --> 00:34:20.996
but I want to just remind you
a little bit about what it is.

00:34:21.556 --> 00:34:23.076
When you look at this diagram,

00:34:23.596 --> 00:34:26.585
you can see a really
parallel compilation flow,

00:34:27.295 --> 00:34:29.726
one file in, one file out.

00:34:30.366 --> 00:34:34.565
With whole module optimization,
we expand the scope

00:34:34.565 --> 00:34:37.795
of compilation from one
file to multiple files.

00:34:38.386 --> 00:34:41.456
And this is really great because
the compiler has a lot more

00:34:41.456 --> 00:34:45.416
information to write new,
innovative optimizations

00:34:45.766 --> 00:34:47.696
and to make your
code run faster.

00:34:48.716 --> 00:34:50.636
So we think this
has so much promise

00:34:50.835 --> 00:34:54.926
from our internal benchmarking,
that this year we are turning it

00:34:54.926 --> 00:34:57.696
on by default for
all new projects.

00:34:58.326 --> 00:35:02.826
And existing projects will get
a modernization suggestion and,

00:35:03.306 --> 00:35:07.426
as it suggests, we think you
should modernize and adopt it.

00:35:08.336 --> 00:35:11.376
There's a big caveat,
which is compilation time.

00:35:12.226 --> 00:35:14.776
As you look in this
diagram, you probably noticed

00:35:14.946 --> 00:35:17.686
that the compiler is
a bit of a bottleneck.

00:35:18.346 --> 00:35:22.066
And as you would expect, your
compilation time increases.

00:35:22.846 --> 00:35:26.766
To offset this cost, we have
made the compiler a lot smarter

00:35:27.126 --> 00:35:29.536
and it's caching
as much as it can

00:35:30.216 --> 00:35:33.236
to avoid reoptimization
and recompilation.

00:35:34.116 --> 00:35:35.756
So the result of all this is

00:35:35.806 --> 00:35:39.376
that although the first time
you compile, it will be --

00:35:39.586 --> 00:35:41.986
it will take a longer
time, follow-up,

00:35:41.986 --> 00:35:44.646
incremental compilations
should be faster.

00:35:46.906 --> 00:35:51.866
Moving on to code size,
this is an area that got --

00:35:51.866 --> 00:35:55.666
we did a lot of work
in since Swift 2.2,

00:35:56.106 --> 00:35:57.846
and we have some nice results.

00:35:58.536 --> 00:36:02.446
DemoBots is a sample app that
you can download from Developer

00:36:02.446 --> 00:36:05.646
at Apple.com, and
it saw a decrease

00:36:05.646 --> 00:36:09.186
in its application binary
size of almost 25 percent

00:36:09.926 --> 00:36:14.456
since Swift 2.2, so that's
some really nice ones here.

00:36:15.756 --> 00:36:17.906
Well, that's all I have
to say about performance,

00:36:18.716 --> 00:36:21.496
but there's lots more
to talk about in Xcode.

00:36:23.326 --> 00:36:26.966
So my favorite feature in
Xcode this year is the improved

00:36:27.486 --> 00:36:31.726
navigation of Swift code because
it really makes a difference

00:36:31.726 --> 00:36:33.506
every day in development.

00:36:34.166 --> 00:36:36.206
Let's take a look at an example.

00:36:36.916 --> 00:36:41.486
So here's an example where we
create an array of integers

00:36:41.486 --> 00:36:43.216
and then just go Sort.

00:36:43.736 --> 00:36:46.756
What do you think happens
when you right click on Sort

00:36:47.296 --> 00:36:49.276
and jump to a declaration?

00:36:49.856 --> 00:36:54.106
In Xcode 7.1, you take

00:36:54.106 --> 00:36:56.406
in a synthesized header
that looks like this.

00:36:57.056 --> 00:36:58.376
Like what is this?

00:36:58.516 --> 00:37:02.206
It's an extension to
mutable collection type,

00:37:02.426 --> 00:37:05.126
the sort here return self
that generated that element,

00:37:05.126 --> 00:37:08.936
and the only reference
to array is in a comment.

00:37:09.606 --> 00:37:13.276
So it doesn't make very much
sense and it's not very logical.

00:37:13.936 --> 00:37:16.436
So in Xcode 8, we're
doing a lot better,

00:37:17.026 --> 00:37:20.196
and now you see there's
an extension to an array

00:37:20.446 --> 00:37:25.376
like you would expect and
sorted, because sort was renamed

00:37:25.376 --> 00:37:30.136
to sorted in Xcode 8, now
returns an array of elements.

00:37:30.896 --> 00:37:35.336
So this really improves how
you can navigate the code

00:37:35.336 --> 00:37:37.716
in Xcode and its readability.

00:37:37.716 --> 00:37:38.836
It's much more logical.

00:37:40.426 --> 00:37:42.606
Also, in the standard library,

00:37:43.116 --> 00:37:45.526
we added groupings
by logical areas.

00:37:46.026 --> 00:37:49.846
For example, array is
grouped under collection.

00:37:50.756 --> 00:37:54.636
And speaking of the standard
library, we have all kinds

00:37:54.636 --> 00:37:56.256
of new documentation for you.

00:37:56.986 --> 00:38:02.146
And again, the protocols
are locked into the APIs,

00:38:02.276 --> 00:38:06.146
so you can logically
navigate like you would

00:38:06.146 --> 00:38:07.716
in the synthesized interfaces.

00:38:08.016 --> 00:38:09.306
[ Applause ]

00:38:09.306 --> 00:38:09.736
Thank you.

00:38:10.516 --> 00:38:13.016
[ Applause ]

00:38:13.516 --> 00:38:15.616
I think you're going to
really love this part.

00:38:15.916 --> 00:38:20.276
Yeah. So how many people
have Swift 2.2 code?

00:38:20.876 --> 00:38:21.936
Probably lots of people.

00:38:22.496 --> 00:38:25.556
So, of course, we have the
migrator for you like always,

00:38:26.276 --> 00:38:28.626
but this year you get to choose.

00:38:28.626 --> 00:38:33.626
You get to choose
Swift 2.3 or Swift 3.

00:38:34.516 --> 00:38:36.916
[ Applause ]

00:38:37.416 --> 00:38:40.206
If you're not quite
ready to jump to Swift 3,

00:38:41.126 --> 00:38:46.506
Swift 2.3 is just Swift 2.2 that
works with the new SDKs, okay,

00:38:47.076 --> 00:38:50.346
and we will be accepting
submissions to the app store,

00:38:50.716 --> 00:38:55.116
both with Swift 3 and 2.3,
but you should be aware

00:38:55.116 --> 00:38:57.846
that there are some very key
features in Xcode that depend

00:38:57.846 --> 00:39:00.976
on Swift 3, like
Playgrounds and Documentation

00:39:01.646 --> 00:39:04.136
and the new features as
well, like Thread Sanitizer.

00:39:05.246 --> 00:39:08.726
Swift 2.3 is a really
an interim solution

00:39:09.156 --> 00:39:10.586
to allow you the flexibility

00:39:10.586 --> 00:39:13.026
to schedule time to
update to Swift 3.

00:39:13.476 --> 00:39:14.786
So please schedule it today.

00:39:16.026 --> 00:39:20.956
Yeah. If you are
using Swift 2.3,

00:39:21.146 --> 00:39:22.516
I have a little tip for you.

00:39:23.306 --> 00:39:24.566
Here is a sample.

00:39:24.566 --> 00:39:28.966
It's a little code snippet from
the lister sample that's in 2.2.

00:39:29.696 --> 00:39:33.826
And when you run the
Swift migrator to 2.3,

00:39:33.826 --> 00:39:37.376
it will suggest you add an
exclamation mark after frame,

00:39:37.706 --> 00:39:41.106
because the core
graphics API have improved

00:39:41.276 --> 00:39:43.626
with additional ability editing.

00:39:44.906 --> 00:39:50.016
Now this code compiles both
with Swift 2.2 and Swift 2.3,

00:39:50.016 --> 00:39:52.736
but if you have a little
more complicated scenario,

00:39:53.116 --> 00:39:55.086
you could conditionally
compile your code

00:39:55.476 --> 00:39:58.786
with a pound FL statement here.

00:39:59.166 --> 00:40:01.046
So that's just a little tip.

00:40:02.146 --> 00:40:05.626
And when you are ready, when you
are ready to upgrade to Swift 3,

00:40:06.736 --> 00:40:08.426
the migrator is there for you.

00:40:08.866 --> 00:40:12.256
Just go to Edit, Convert
to Current Swift Syntax,

00:40:12.666 --> 00:40:15.296
and you are taken through the
migration experience again.

00:40:16.376 --> 00:40:17.836
So it's easy.

00:40:18.006 --> 00:40:19.976
Convert to Swift 3
and schedule it today.

00:40:21.026 --> 00:40:23.596
So that's all I have
to say about tools.

00:40:24.706 --> 00:40:29.286
And just to recap,
recap, Chris talked

00:40:29.286 --> 00:40:32.256
about how Swift 3
really focuses on nailing

00:40:32.256 --> 00:40:33.276
down the fundamentals.

00:40:33.956 --> 00:40:37.156
And we're doing all this
in the open on Swift.org,

00:40:37.246 --> 00:40:40.776
as Ted described, and you can
just go there and get involved

00:40:40.776 --> 00:40:41.926
in the evolution process.

00:40:42.376 --> 00:40:45.436
And you can see we've got
awesome Xcode integration

00:40:45.436 --> 00:40:45.846
as well.

00:40:46.906 --> 00:40:49.396
So there's lots more
information this week.

00:40:49.396 --> 00:40:50.476
There is just the beginning.

00:40:50.886 --> 00:40:52.646
And we have lots of
sessions throughout the week.

00:40:53.386 --> 00:40:54.636
I want to highlight one,

00:40:55.196 --> 00:40:57.606
which is the Swift
API Design Guidelines.

00:40:58.006 --> 00:41:00.016
It's in this room right
after this session.

00:41:00.476 --> 00:41:01.626
And have an awesome
week with us.

00:41:01.626 --> 00:41:01.976
Thank you.

00:41:02.516 --> 00:41:13.160
[ Applause ]
WEBVTT

00:00:07.516 --> 00:00:19.500
[ Music ]

00:00:27.516 --> 00:00:31.756
[ Applause ]

00:00:32.256 --> 00:00:32.496
>> Thank you.

00:00:34.746 --> 00:00:35.416
Hello, and welcome.

00:00:35.936 --> 00:00:36.936
My name is Tony Parker.

00:00:36.936 --> 00:00:38.666
I am the manager of the
Foundation team at Apple,

00:00:38.816 --> 00:00:40.956
and I'm here with my
colleague Michael LeHew to talk

00:00:40.956 --> 00:00:42.836
about what's new in
Foundation for Swift.

00:00:44.636 --> 00:00:46.846
This year the Foundation
team has put a lot of effort

00:00:46.846 --> 00:00:49.096
into improving the way
that you use the Cocoa

00:00:49.096 --> 00:00:51.186
and Cocoa Touch APIs in Swift.

00:00:51.856 --> 00:00:54.326
We started by working on the
Swift API Design Guidelines.

00:00:55.106 --> 00:00:57.546
After that, we looked at how
all of the Objective-C code

00:00:57.546 --> 00:01:01.316
that the Cocoa SDK uses and your
own code is imported into Swift,

00:01:02.536 --> 00:01:04.066
but we knew that we
could go further.

00:01:04.236 --> 00:01:06.926
So, we have introduced a
brand new set of value types

00:01:06.926 --> 00:01:09.686
in Foundation, and
along with that a ton

00:01:09.686 --> 00:01:12.316
of new Swift-specific API.

00:01:13.056 --> 00:01:15.196
So, let's go ahead and jump
into design guidelines.

00:01:17.186 --> 00:01:19.316
Now, this year we're
working on Swift 3, and yet,

00:01:19.516 --> 00:01:21.886
from the beginning our goals for
Swift have remained the same.

00:01:22.476 --> 00:01:25.856
We want you to write code that's
fast, safe, and expressive.

00:01:26.946 --> 00:01:28.876
We've built the libraries,
the standard library,

00:01:28.876 --> 00:01:30.726
and the language
around these core ideas.

00:01:30.726 --> 00:01:33.576
And many of you have also
internalized those same

00:01:33.576 --> 00:01:36.066
principals and built your
application around that.

00:01:36.886 --> 00:01:39.426
However, we all know that there
is another part to that story,

00:01:39.556 --> 00:01:41.006
and that it the Cocoa SDK.

00:01:41.956 --> 00:01:45.526
Your app depends on this just as
much, or maybe even more than,

00:01:45.526 --> 00:01:46.626
the Swift standard library.

00:01:47.086 --> 00:01:49.516
It needs to feel like it's
part of the same ecosystem.

00:01:50.486 --> 00:01:52.996
Because the SDK is a
critical part of that story

00:01:53.166 --> 00:01:56.186
about how we develop apps on our
platforms, it's really important

00:01:56.186 --> 00:01:59.026
that the language and the
libraries work together.

00:02:01.086 --> 00:02:03.826
So this year we focused on
this idea of expressiveness.

00:02:04.386 --> 00:02:05.826
When I say expressive,
I actually mean it

00:02:05.826 --> 00:02:06.626
in two different ways.

00:02:07.016 --> 00:02:10.256
First is your ability as app
authors to write Swift code

00:02:10.256 --> 00:02:13.596
that expresses your intent to
the compiler and the libraries,

00:02:14.206 --> 00:02:15.416
but it goes the other way too.

00:02:15.836 --> 00:02:18.096
The libraries need to be
able to express their intent,

00:02:18.246 --> 00:02:20.976
their design patterns and
their ideas about how best

00:02:20.976 --> 00:02:23.636
to use the API to
you as an app author.

00:02:25.596 --> 00:02:27.486
And so, while working
on the guidelines,

00:02:27.486 --> 00:02:29.966
we focused on this idea of
a consistent experience.

00:02:30.316 --> 00:02:32.916
Every decision made about those
guidelines was done in support

00:02:32.916 --> 00:02:34.006
of the idea that the language

00:02:34.006 --> 00:02:35.386
and the libraries
don't stand alone.

00:02:35.566 --> 00:02:36.596
They have to work together.

00:02:37.266 --> 00:02:38.876
So, for example,
from the libraries,

00:02:39.226 --> 00:02:40.936
they bring a huge
number of features.

00:02:41.336 --> 00:02:43.166
Many of the features that
you see in the new versions

00:02:43.166 --> 00:02:45.846
of our platforms this year
are based on new features

00:02:45.846 --> 00:02:48.486
in the libraries that you
can also adopt in your apps

00:02:48.656 --> 00:02:50.286
to improve your experience.

00:02:51.176 --> 00:02:53.476
These libraries have a
widespread adoption across all

00:02:53.476 --> 00:02:56.736
of our platforms, including
this year new, Swift Auto ARC

00:02:56.736 --> 00:02:57.676
and Swift Open Source.

00:02:58.266 --> 00:03:00.186
So, we have Swift
core libs foundation

00:03:00.416 --> 00:03:02.836
which is bringing the
Foundation API, much of it,

00:03:03.136 --> 00:03:04.686
to other platforms like Linux.

00:03:05.846 --> 00:03:07.886
These libraries have a
battle-tested implementation.

00:03:08.486 --> 00:03:10.176
Many of them have been
around since the beginning

00:03:10.176 --> 00:03:12.646
of OS X or even further back.

00:03:13.576 --> 00:03:14.786
They also bring with them,

00:03:14.786 --> 00:03:16.346
thanks to the Cocoa
naming guidelines,

00:03:16.456 --> 00:03:17.976
a consistent set of conventions.

00:03:18.336 --> 00:03:20.286
This means that when you
see a new piece of API,

00:03:20.286 --> 00:03:22.326
you can understand how it works

00:03:22.326 --> 00:03:24.086
and what it does
almost immediately.

00:03:24.816 --> 00:03:27.076
And finally and importantly,
these libraries are

00:03:27.076 --> 00:03:29.036
under continuous and
active development.

00:03:29.466 --> 00:03:31.176
Not only are we adding
those new features,

00:03:31.446 --> 00:03:34.226
but we're making enhancements,
fixing bugs, and more,

00:03:34.226 --> 00:03:37.186
and we're going to continue
to do that every year

00:03:37.356 --> 00:03:38.316
as we release new OSs.

00:03:38.316 --> 00:03:42.576
Now, on the other hand,
the language, Swift,

00:03:42.726 --> 00:03:45.416
brings with it things that we
just didn't have in Objective-C.

00:03:45.806 --> 00:03:47.876
For example, first class
abort for generics,

00:03:48.536 --> 00:03:51.266
and built in support for
mutation, which is a key part

00:03:51.266 --> 00:03:52.646
of Swift's story about safety.

00:03:53.936 --> 00:03:55.806
There's also things like
protocol extensions,

00:03:55.806 --> 00:03:58.006
function overloading, and
default argument values,

00:03:58.476 --> 00:03:59.876
all of which make
a dramatic impact

00:03:59.876 --> 00:04:01.796
on how you design
your API in Swift.

00:04:03.096 --> 00:04:04.556
This isn't a complete
list on either side,

00:04:04.556 --> 00:04:05.726
by the way I just
ran out of space.

00:04:05.986 --> 00:04:07.166
There's plenty more
to go around.

00:04:07.846 --> 00:04:12.176
So, we came up with
three key documents.

00:04:12.666 --> 00:04:16.156
The first was SE-0023,
the API Design Guidelines.

00:04:16.216 --> 00:04:17.986
Now, all these documents
were sent

00:04:18.086 --> 00:04:21.106
to the Swift Evolution
mailing list, which gives you

00:04:21.106 --> 00:04:22.756
and the rest of the
Swift community a chance

00:04:22.756 --> 00:04:25.646
to participate in the design
and evolution of the language.

00:04:26.246 --> 00:04:29.376
Now, we see these guidelines as
a unifying document for current

00:04:29.376 --> 00:04:30.766
and future Swift libraries.

00:04:31.186 --> 00:04:32.846
Along with that we have SE-0006,

00:04:32.906 --> 00:04:35.426
which applied those design
guidelines to Standard Library,

00:04:35.796 --> 00:04:38.286
giving us a consistent and
predicable set of primitives

00:04:38.286 --> 00:04:41.296
that we can build on
top of, and SE-0005,

00:04:41.696 --> 00:04:44.756
which dramatically improved the
expressivity of the Cocoa SDK,

00:04:45.126 --> 00:04:47.036
by doing things like
adding default arguments,

00:04:47.286 --> 00:04:49.206
improving option sets
and building properties,

00:04:49.506 --> 00:04:51.776
even automatically adopting
protocols in some cases.

00:04:51.956 --> 00:04:56.846
We had a whole talk about this
that I definitely recommend

00:04:56.846 --> 00:04:59.986
that you check out if you missed
it, Swift API Design Guidelines.

00:05:02.136 --> 00:05:04.206
Now, all these were
tremendous advances,

00:05:04.816 --> 00:05:06.606
but we knew that we
could go even further.

00:05:07.226 --> 00:05:09.756
That's because Swift goals
go beyond just the names.

00:05:11.366 --> 00:05:14.856
Mutability in particular is
a key part of the language,

00:05:15.616 --> 00:05:18.466
and so, we turned our
attention to Foundation.

00:05:19.956 --> 00:05:21.836
Now, if you're wondering
why Foundation?

00:05:22.626 --> 00:05:24.416
The answer is because
it's kind of special,

00:05:24.756 --> 00:05:26.546
and I'm not just saying
that because I work on it.

00:05:27.486 --> 00:05:30.976
Foundation occupies a
unique spot in the SDK.

00:05:31.056 --> 00:05:33.006
What's interesting about it
is that it's low enough level

00:05:33.006 --> 00:05:35.576
to be used everywhere, on all
those platforms I mentioned.

00:05:36.276 --> 00:05:38.496
Yet, at the same time,
it's also high enough level

00:05:38.906 --> 00:05:42.646
to establish a whole new set of
common types and design patterns

00:05:42.646 --> 00:05:44.966
that again you see reflected
throughout the entire SDK.

00:05:44.966 --> 00:05:48.296
If we go back to our picture
from earlier and sort of zoom

00:05:48.296 --> 00:05:52.456
in on the Cocoa SDK, you'll see
lots of frameworks that you use

00:05:52.456 --> 00:05:56.226
in your apps every day, from
UIKit to SpriteKit, and WatchKit

00:05:56.226 --> 00:05:58.256
to CoreData, and many
other cores and kits

00:05:58.346 --> 00:05:59.516
that don't fit here either.

00:06:00.376 --> 00:06:02.646
Now, what's interesting
here is that almost all

00:06:02.646 --> 00:06:04.646
of these are built
on top of Foundation.

00:06:05.616 --> 00:06:07.676
So, we see Foundation
as a leverage point.

00:06:08.696 --> 00:06:10.876
What that means is that we can
make a small set of changes

00:06:10.876 --> 00:06:14.976
in Foundation, and that can have
a big impact on the entire SDK.

00:06:16.476 --> 00:06:18.486
Partly, that's because
Foundation is the home

00:06:18.486 --> 00:06:20.526
of many value types.

00:06:21.456 --> 00:06:25.436
So, we focused on this idea
of evolution over revolution.

00:06:25.926 --> 00:06:27.856
We've seen everything
that those libraries bring

00:06:27.856 --> 00:06:29.136
to the development of your apps.

00:06:29.606 --> 00:06:31.166
We're not going to
throw all that away

00:06:31.466 --> 00:06:32.656
because we have a new language.

00:06:32.996 --> 00:06:35.146
Instead what we're doing is
we're bringing the language

00:06:35.146 --> 00:06:37.106
and the libraries
closer together

00:06:37.176 --> 00:06:39.136
by making incremental
improvements to both.

00:06:39.756 --> 00:06:40.656
The changes that we're talking

00:06:40.656 --> 00:06:43.676
about today are a
continuation of that process.

00:06:44.166 --> 00:06:46.716
And so with that in mind,

00:06:46.716 --> 00:06:49.306
the Foundation team put forth
two additional proposals

00:06:49.306 --> 00:06:50.696
to the Swift Evolution
mailing list.

00:06:51.246 --> 00:06:53.776
The first was mutability
in Foundation value types,

00:06:54.186 --> 00:06:56.706
which is about embracing
that Swift mutability model

00:06:56.706 --> 00:06:57.816
in the Foundation framework.

00:06:59.766 --> 00:07:02.876
And also, dropping the NS
prefix in Swift Foundation,

00:07:03.256 --> 00:07:05.316
which is about establishing
those common types

00:07:05.316 --> 00:07:06.816
and design patterns for Swift,

00:07:07.156 --> 00:07:08.686
no matter which platform
you're using.

00:07:09.306 --> 00:07:13.846
So here is an overview of some

00:07:13.846 --> 00:07:15.496
of the API improvements
we've made this year.

00:07:15.876 --> 00:07:18.416
First and foremost, value
semantics, a brand new set

00:07:18.416 --> 00:07:20.616
of value types that you're
going to see across the SDK.

00:07:21.436 --> 00:07:23.076
Beyond that, we did
an additional set

00:07:23.076 --> 00:07:23.946
of naming improvements,

00:07:24.016 --> 00:07:26.946
beyond what the Objective-C
translation into Swift can do.

00:07:27.656 --> 00:07:29.516
We've adopted many
standard library protocols

00:07:29.516 --> 00:07:30.886
on these types, which means

00:07:30.886 --> 00:07:32.506
that your generic
algorithms can now work

00:07:32.506 --> 00:07:33.896
on Foundation types as well.

00:07:34.746 --> 00:07:36.846
We've added additional
type safety and a lot

00:07:36.846 --> 00:07:38.366
of new Swift-specific features.

00:07:38.366 --> 00:07:42.986
So, let's do a quick
overview of value types.

00:07:43.546 --> 00:07:45.656
Now, value types
are distinguished

00:07:45.656 --> 00:07:49.196
from reference types, primarily
based on their behavior

00:07:49.196 --> 00:07:53.266
around copying, so value types
copy their content on assignment

00:07:53.266 --> 00:07:54.426
or passed as a parameter.

00:07:54.596 --> 00:07:55.486
Here's a quick example.

00:07:55.796 --> 00:07:56.436
I've got a point.

00:07:57.046 --> 00:07:59.306
I use the equals operator
to assign that point

00:07:59.346 --> 00:08:01.966
to another point, and when
I mutate that second point,

00:08:02.166 --> 00:08:03.856
you see that only
the copy is mutated.

00:08:03.856 --> 00:08:05.346
I didn't affect the
content of both.

00:08:05.686 --> 00:08:08.106
That's because CGPoint
is a value type.

00:08:09.226 --> 00:08:10.016
Now, on the other hand,

00:08:10.016 --> 00:08:12.096
reference types share
their content by default.

00:08:12.816 --> 00:08:14.906
Here I'm going to create some
data using the reference type

00:08:14.906 --> 00:08:15.816
and its mutable data.

00:08:16.776 --> 00:08:19.486
Then I use that same
equal operator to assign

00:08:19.486 --> 00:08:20.526
that data to otherData.

00:08:21.126 --> 00:08:23.686
However, this time, when
I mutate that second data,

00:08:24.106 --> 00:08:25.966
you can see that it
affects the content of both.

00:08:26.066 --> 00:08:28.706
Now, it's important to
understand that neither

00:08:28.706 --> 00:08:30.216
of these is better
than the other.

00:08:30.866 --> 00:08:32.186
You just use them
in different ways.

00:08:33.265 --> 00:08:35.285
I like to think of it as a
couple of tools in the tool box

00:08:35.285 --> 00:08:38.876
that you can reach for when
you have a particular problem

00:08:39.525 --> 00:08:40.635
to solve.

00:08:41.326 --> 00:08:43.216
So, when you're trying
to decide for yourself

00:08:43.996 --> 00:08:46.166
if your type is a value
type or a reference type,

00:08:46.906 --> 00:08:49.796
you should think about object
identity and stored contents.

00:08:49.796 --> 00:08:52.326
Let me explain by way
of a couple of examples.

00:08:52.906 --> 00:08:56.626
So, in Foundation, we
have a class called.

00:08:57.376 --> 00:09:00.276
OperationQueue has a singleton,
called the main operation queue.

00:09:01.386 --> 00:09:03.416
That operation queue,
the main operation queue,

00:09:03.416 --> 00:09:04.596
is where you put
work that you want

00:09:04.596 --> 00:09:05.666
to happen on the main thread.

00:09:06.056 --> 00:09:07.596
And so, there's only
one of them.

00:09:07.856 --> 00:09:09.076
It has a kind of identity.

00:09:09.436 --> 00:09:11.996
If I were to copy the main
OperationQueue then it would no

00:09:11.996 --> 00:09:13.416
longer be the main
operation queue.

00:09:13.986 --> 00:09:15.076
So, we believe

00:09:15.146 --> 00:09:17.646
that OperationQueue
is a reference type.

00:09:18.646 --> 00:09:19.776
Another example, a pattern

00:09:19.776 --> 00:09:22.366
that you see throughout the
Cocoa SDKs is a delegation.

00:09:23.146 --> 00:09:25.106
So here is the delegate,
or one of the delegates

00:09:25.106 --> 00:09:27.506
for URL session,
and you'll notice

00:09:27.666 --> 00:09:30.156
that the delegate protocol
has an argument, right there,

00:09:30.306 --> 00:09:33.826
called Session, and that
tells the object that's being

00:09:33.826 --> 00:09:37.336
delegated to which URLSession
it's doing work on behalf of,

00:09:37.906 --> 00:09:41.796
and that idea of which
URLSession it is implies,

00:09:41.906 --> 00:09:42.786
again, identity.

00:09:43.186 --> 00:09:45.036
So, we believe that types

00:09:45.036 --> 00:09:47.006
with delegates are
usually reference types.

00:09:47.566 --> 00:09:50.776
On the other hand,
many types are more

00:09:50.776 --> 00:09:52.196
about their store contents.

00:09:52.256 --> 00:09:53.506
For example, Date.

00:09:53.506 --> 00:09:55.306
This is one of our new
Foundation value types.

00:09:56.376 --> 00:09:57.866
Date is an absolute
point in time.

00:09:58.596 --> 00:10:01.276
We can have two Dates
that have the same value,

00:10:01.406 --> 00:10:03.016
the same absolute point in time,

00:10:03.336 --> 00:10:04.656
and be talking about
the same Date.

00:10:04.656 --> 00:10:07.086
We don't need to talk about the
reference to that point in time.

00:10:07.626 --> 00:10:09.536
In fact, if we look inside
the implementation of Date,

00:10:09.776 --> 00:10:11.856
as you see here, it's
actually just a double,

00:10:12.346 --> 00:10:13.716
and a double is something
that we sort

00:10:13.716 --> 00:10:15.876
of already intuitively
understand as a value type.

00:10:17.106 --> 00:10:18.476
Another example is Data.

00:10:19.006 --> 00:10:21.536
Data is another one of our
new Foundation value types.

00:10:22.126 --> 00:10:24.966
Data, normally you care about
the contents of that Data,

00:10:25.206 --> 00:10:28.376
the bytes that are there, not
the actual NSData instance.

00:10:28.546 --> 00:10:33.976
So, Foundation has made
Data into a value type.

00:10:34.146 --> 00:10:36.626
Now, copying the data
every time that we pass it

00:10:36.626 --> 00:10:38.476
as a parameter would
quickly get very expensive.

00:10:39.026 --> 00:10:41.626
So, we performed an optimization
called Copy on Write.

00:10:42.496 --> 00:10:44.136
So, here I'm going
to create some data,

00:10:44.896 --> 00:10:47.596
and you see I've got a
struct, but inside that struct,

00:10:47.596 --> 00:10:48.856
I also have a reference.

00:10:48.886 --> 00:10:50.816
So, another example of
things working better

00:10:50.816 --> 00:10:51.636
when they work together.

00:10:51.976 --> 00:10:53.866
Here I'm using both a
reference and a value

00:10:54.266 --> 00:10:55.976
to get the performance
characteristics

00:10:56.276 --> 00:10:58.946
that I want along with the value
semantics that are important.

00:11:00.026 --> 00:11:02.756
Now, if I use that equal
operator to assign that data

00:11:02.756 --> 00:11:05.116
to another data,
then you can see

00:11:05.116 --> 00:11:07.616
that I've got another
struct, but it points

00:11:07.616 --> 00:11:09.446
at the same class
under the hood.

00:11:10.146 --> 00:11:14.006
However, if I mutate that Data,
then we will copy the Data,

00:11:14.486 --> 00:11:17.506
mutate the copy, and now we've
got two independent Datas.

00:11:18.876 --> 00:11:20.456
If I continue to
mutate the second Data,

00:11:20.986 --> 00:11:23.616
we can tell that that Data
is uniquely referenced,

00:11:23.616 --> 00:11:25.066
and we don't need to
copy it each time.

00:11:25.996 --> 00:11:28.556
So, this is an extension, or
actually, just another use

00:11:28.556 --> 00:11:31.256
of the same technique that
we've talked about in the past,

00:11:31.256 --> 00:11:33.366
including last year,
with building better apps

00:11:33.366 --> 00:11:34.396
and value types in Swift.

00:11:34.396 --> 00:11:36.046
So, check that out if you
want some more information

00:11:36.046 --> 00:11:38.486
on how this works.

00:11:38.656 --> 00:11:41.386
So, we did a survey of
every API in Foundation,

00:11:41.656 --> 00:11:43.476
and we came up with
this list of things

00:11:43.476 --> 00:11:45.196
that we think would
make great value types,

00:11:45.656 --> 00:11:47.566
and I think you'll be happy
to see many of the types

00:11:47.566 --> 00:11:49.566
that you use every
day on this list.

00:11:49.976 --> 00:11:51.976
That includes Data and
Date, as I mentioned,

00:11:52.326 --> 00:11:54.766
but also other types that
are really popular like URL,

00:11:55.166 --> 00:11:57.986
IndexPath, CharacterSet,
and a lot more.

00:11:58.286 --> 00:12:00.426
And many of these types not
only became value types,

00:12:00.726 --> 00:12:03.186
but gained a lot of
great new API as well.

00:12:03.716 --> 00:12:06.946
Now, to give you an idea
of what that looks like,

00:12:07.036 --> 00:12:08.406
I'd like to invite
Michael on stage.

00:12:09.516 --> 00:12:13.796
[ Applause ]

00:12:14.296 --> 00:12:14.846
>> Thank you, Tony.

00:12:15.616 --> 00:12:17.626
Let's start by visiting
the new homes of many

00:12:17.626 --> 00:12:19.046
of Foundation's enumerations.

00:12:19.696 --> 00:12:22.176
Now, as you know,
Objective-C enumerations

00:12:22.176 --> 00:12:24.166
and option sets live in
the global namespace,

00:12:24.226 --> 00:12:25.896
alongside the types
that consume them.

00:12:26.166 --> 00:12:30.066
For example, NSNumberFormatter
alone defines four enumerations

00:12:30.226 --> 00:12:33.676
for the style, behavior, pad
position, and rounding mode.

00:12:34.476 --> 00:12:37.106
And each of these are implicitly
associated with NumberFormatter

00:12:37.466 --> 00:12:39.346
through careful and
consistent naming convention.

00:12:39.996 --> 00:12:42.226
In Swift 2 as you
know, these important

00:12:42.226 --> 00:12:43.576
to the global namespace as well.

00:12:43.576 --> 00:12:46.896
But that doesn't feel
like native Swift.

00:12:47.426 --> 00:12:49.286
Swift supports nested types,

00:12:49.886 --> 00:12:53.126
and so in Swift 3 we made the
decision to relocate these types

00:12:53.876 --> 00:12:56.496
to be declared inside,
where they're destined to.

00:12:56.496 --> 00:12:59.026
So NumberFormatter now has
internal types of style,

00:12:59.066 --> 00:13:00.526
behavior, pad position,
and rounding mode.

00:13:00.886 --> 00:13:02.816
And their names are
no longer redundant,

00:13:03.716 --> 00:13:05.856
and this greatly reduces
the number of types

00:13:05.856 --> 00:13:08.066
that Foundation declares
in the top-level namespace,

00:13:08.506 --> 00:13:10.486
and now the relationship
is explicit,

00:13:10.526 --> 00:13:12.946
our APIs more expressive
and more discoverable.

00:13:14.476 --> 00:13:16.806
Sticking with the
theme of enumerations,

00:13:17.196 --> 00:13:20.836
many Foundation APIs also use
families of streamed constants.

00:13:20.986 --> 00:13:24.626
Examples include notification
names, URL resource keys.

00:13:25.066 --> 00:13:29.136
Now of course, Swift has support
for enumerations that rely

00:13:29.136 --> 00:13:31.496
on raw representations
that are other

00:13:31.496 --> 00:13:33.396
than integers, including string.

00:13:33.816 --> 00:13:35.486
Wouldn't it be great if
we could do the same thing

00:13:35.486 --> 00:13:36.326
in Objective-C?

00:13:37.336 --> 00:13:40.346
Well, new this year we can, and
the constants are now defined

00:13:40.346 --> 00:13:42.806
in terms of very specific
kinds of string constants,

00:13:43.026 --> 00:13:46.286
like notification name
and URL resource key,

00:13:46.596 --> 00:13:47.746
and many, many more.

00:13:49.706 --> 00:13:53.846
And these constants remain
extensible, in Objective-C

00:13:54.556 --> 00:14:00.966
and also in Swift, where we can
also see that we nest them just

00:14:00.966 --> 00:14:04.036
like their integral
cousins, so that using them

00:14:04.036 --> 00:14:06.166
in Swift 3 is both
natural and expressive.

00:14:06.896 --> 00:14:10.036
Now another common Foundation
design pattern is associating

00:14:10.036 --> 00:14:10.876
state with a type.

00:14:11.226 --> 00:14:14.066
For instance, the
standardUserDefaults.

00:14:14.886 --> 00:14:16.106
Now, of course, Swift support

00:14:16.106 --> 00:14:19.516
for class properties are
a great fit for this idea,

00:14:20.126 --> 00:14:22.956
and new in this year, we
have brought class properties

00:14:22.956 --> 00:14:25.266
to Objective-C, and
they're declared just

00:14:25.266 --> 00:14:26.476
like instance properties,

00:14:26.786 --> 00:14:29.446
except we now accept
this fancy class keyword,

00:14:29.796 --> 00:14:33.536
and because we know that
it's a class property,

00:14:33.536 --> 00:14:35.286
we no longer need to
import it as a func

00:14:35.286 --> 00:14:36.506
as we did in Swift 2.2.

00:14:36.696 --> 00:14:40.316
It can now appear as a class
property, just as you would

00:14:40.316 --> 00:14:41.946
if you were defining
this natively in Swift.

00:14:43.036 --> 00:14:44.836
But we didn't stop there.

00:14:44.836 --> 00:14:48.266
There's some redundant
words here, and in Swift 3,

00:14:48.266 --> 00:14:50.976
we overhauled the way that
Swift code is manifested,

00:14:50.976 --> 00:14:53.066
or Objective-C code
is manifest in Swift,

00:14:53.366 --> 00:14:56.556
so that our final API could
look a little more like this.

00:14:57.106 --> 00:15:00.166
We know it's our user defaults,
and by helping Foundation grow

00:15:00.166 --> 00:15:02.346
to be more Swift-like, we've
achieved great benefits

00:15:02.346 --> 00:15:04.026
for both Objective-C and Swift.

00:15:04.516 --> 00:15:08.896
Now Tony mentioned many
Foundation types deserve

00:15:08.896 --> 00:15:11.316
to be value types, and so I'm
going to talk about a few.

00:15:11.526 --> 00:15:13.986
We'll start with Date.

00:15:14.356 --> 00:15:16.396
Now let's suppose we want
to schedule a reminder

00:15:16.396 --> 00:15:17.766
for when we should go home.

00:15:17.816 --> 00:15:21.336
We'll start with Swift 2.2,
just to motivate our example.

00:15:21.616 --> 00:15:23.486
Let's suppose that we have
a function that can answer

00:15:23.486 --> 00:15:28.486
when we need to go home, and we
call it, and five minutes seems

00:15:28.486 --> 00:15:30.776
like a good time for our
reminder, so we'll go ahead and,

00:15:31.106 --> 00:15:32.456
you know, offset
that a little bit.

00:15:33.236 --> 00:15:35.636
Now, it's worth pointing
out, NSDate is

00:15:35.636 --> 00:15:38.746
and remains a reference type,
and so there's actually two,

00:15:39.156 --> 00:15:41.356
potentially two dynamic
allocations going on here.

00:15:41.796 --> 00:15:43.756
One here, and another here.

00:15:44.346 --> 00:15:48.186
Now in Swift 3, we gain
access to the Date value type.

00:15:49.206 --> 00:15:50.516
So, let's go ahead and use it,

00:15:51.746 --> 00:15:53.106
and consuming it
is very similar,

00:15:53.166 --> 00:15:56.446
however now this var takes on
a whole new kind of behavior.

00:15:56.946 --> 00:15:59.456
We specifically, we now
allow inline mutation.

00:16:00.326 --> 00:16:01.536
And so, we've done zero,

00:16:02.056 --> 00:16:04.556
these two examples here are
doing the exact same thing,

00:16:04.556 --> 00:16:08.076
except with the value
type we've done no extra

00:16:08.076 --> 00:16:09.166
dynamic allocations.

00:16:09.466 --> 00:16:10.556
Let's continue our example.

00:16:10.886 --> 00:16:12.836
Now, of course, we can
do this inline as well.

00:16:12.836 --> 00:16:17.336
Now, with reminders, it's
only really meaningful

00:16:17.336 --> 00:16:19.486
to schedule them if
they haven't happened,

00:16:20.076 --> 00:16:21.986
and one of the great
things that Swift brings

00:16:21.986 --> 00:16:25.156
to the table is automatic
conformance to protocols

00:16:25.156 --> 00:16:29.066
when you satisfy certain
criteria, and so in this case,

00:16:29.066 --> 00:16:31.606
Date Auto has conforms
to comparable,

00:16:31.756 --> 00:16:33.486
which gives us access
to the less

00:16:33.536 --> 00:16:35.816
than operator, which we use now.

00:16:36.336 --> 00:16:38.276
And we can go ahead
and schedule our timer,

00:16:38.276 --> 00:16:39.426
but first we need to create it.

00:16:39.486 --> 00:16:41.996
And so we'll use another new
Foundation API this year,

00:16:42.356 --> 00:16:45.666
which is this fancy
closure-based timer API,

00:16:46.286 --> 00:16:48.356
where we initialize the
timer with a closure.

00:16:48.356 --> 00:16:50.556
So no more selectors
and targets there,

00:16:50.556 --> 00:16:53.236
and we'll schedule it
on our main run loop.

00:16:54.516 --> 00:16:58.606
[ Applause ]

00:16:59.106 --> 00:17:00.566
I'll also call out thread

00:17:00.566 --> 00:17:03.106
and run loop have those
as well I believe.

00:17:03.106 --> 00:17:06.046
And we schedule them on our
main run loop and we're done.

00:17:06.476 --> 00:17:08.066
And this is a great
example of how all

00:17:08.066 --> 00:17:10.546
of these familiar Foundation
APIs really can come

00:17:10.546 --> 00:17:12.215
across so beautifully
in Swift 3.

00:17:12.856 --> 00:17:14.965
This is some of the most
Foundationy code I could

00:17:14.965 --> 00:17:16.106
possibly have in a demo.

00:17:16.106 --> 00:17:18.056
I have a run loop, I have
a timer and some dates.

00:17:18.236 --> 00:17:19.986
I just, there's only
a few other things,

00:17:19.986 --> 00:17:21.425
and this is pretty
much all of Foundation.

00:17:21.566 --> 00:17:23.606
And there isn't a
square bracket in sight.

00:17:25.606 --> 00:17:27.756
So, another new example,
or another new type

00:17:27.846 --> 00:17:30.226
in Foundation is the
measurement value type.

00:17:31.156 --> 00:17:33.456
And let's suppose with
a new example here,

00:17:33.456 --> 00:17:34.956
we care about how
long our commute is,

00:17:34.956 --> 00:17:37.876
and we're lucky enough to
live two short streets away

00:17:37.876 --> 00:17:38.646
from where we work.

00:17:39.386 --> 00:17:40.656
Now, measurements
are value types,

00:17:40.656 --> 00:17:43.046
and Swift supports
operator overloading,

00:17:43.376 --> 00:17:44.806
and not only are they
value types, though.

00:17:45.036 --> 00:17:47.306
They're mathematical in
nature, and so it makes sense

00:17:47.306 --> 00:17:50.796
to specify operators on them.

00:17:50.796 --> 00:17:54.646
No one will look the other
way, or make a sour face

00:17:54.646 --> 00:17:57.116
if we contemplate
adding them together,

00:17:57.116 --> 00:18:00.636
and so we can compute their sum,
and we can even convert them

00:18:00.636 --> 00:18:01.786
to a different kind of unit.

00:18:01.786 --> 00:18:04.376
And let's suppose we were
curious how long it took

00:18:04.376 --> 00:18:05.256
for us to get to work.

00:18:05.256 --> 00:18:08.506
Well, we could do that as
well, except in Swift 3,

00:18:08.506 --> 00:18:10.996
if we were to try to build
this code, it would fail,

00:18:10.996 --> 00:18:13.516
and it would fail at
compile time because,

00:18:13.656 --> 00:18:16.526
thanks to the power of Swift 3's
generics in type constraints,

00:18:16.916 --> 00:18:19.976
we actually have designed this
in a way that the difference

00:18:19.976 --> 00:18:21.826
in units is knowable
at compile time,

00:18:22.046 --> 00:18:24.106
and so the Swift compiler
can detect us and tell us

00:18:24.146 --> 00:18:25.796
that we're trying to do
an invalid conversion.

00:18:26.746 --> 00:18:28.526
To learn more about
measurement and units

00:18:28.526 --> 00:18:30.136
and the whole new
ecosystem of types

00:18:30.136 --> 00:18:33.346
that we've introduced this year,
be sure to check out this talk

00:18:33.346 --> 00:18:35.776
on Friday afternoon
to learn more

00:18:35.776 --> 00:18:36.986
about measurements and units.

00:18:38.076 --> 00:18:39.926
I'm going to switch
to another example.

00:18:40.886 --> 00:18:43.096
I did say this was going
to be an adventure.

00:18:43.326 --> 00:18:45.656
Suppose we want to
buy some MacBooks.

00:18:45.846 --> 00:18:48.116
We'll use the new URL
Component's value type

00:18:48.916 --> 00:18:50.446
and we can do this
very expressively.

00:18:51.166 --> 00:18:53.476
We'll begin by describing
mutable components,

00:18:53.476 --> 00:18:55.526
which we'll use as
a template below.

00:18:55.826 --> 00:18:57.656
And we iterate through
the products that we want

00:18:57.696 --> 00:19:02.856
to purchase, make a copy of
our template, and then mutate

00:19:02.856 --> 00:19:06.176
that copy, specifying the
product that we wish to buy.

00:19:07.046 --> 00:19:07.766
Note that we're safe

00:19:07.766 --> 00:19:09.756
to explicitly unwrap
this optional here,

00:19:10.146 --> 00:19:13.256
because we specified that it was
non-nill in our template above.

00:19:14.466 --> 00:19:16.956
We can go ahead and
print our URLs and we see

00:19:16.956 --> 00:19:21.136
that we have been able to build,
you know, the URLs that we'd

00:19:21.136 --> 00:19:26.606
like to purchase with no
memory management whatsoever.

00:19:26.926 --> 00:19:29.276
All we had to do was
declare our intent, whether

00:19:29.276 --> 00:19:31.576
or not something was mutable or
not, and the language took care

00:19:31.576 --> 00:19:33.766
of the rest of the
details for us.

00:19:34.676 --> 00:19:37.106
Now, another thing
that Swift 3 brings,

00:19:37.216 --> 00:19:38.286
or Swift in general brings

00:19:38.286 --> 00:19:40.126
to the table is protocol
components.

00:19:40.126 --> 00:19:42.506
In many Foundation
types, like Date,

00:19:42.706 --> 00:19:46.516
getting useful new capabilities
thanks to new conformances.

00:19:46.716 --> 00:19:48.136
For instance, CharacterSet

00:19:48.136 --> 00:19:51.236
and IndexSet are now
conformed to SetAlgebra.

00:19:51.496 --> 00:19:54.206
So you can union, intersect, and
symmetric difference these guys

00:19:54.206 --> 00:19:55.106
to your hearts' content.

00:19:56.356 --> 00:19:59.006
Data is also now a
MutableCollection,

00:19:59.296 --> 00:20:02.776
MutableRandomAccessCollection
of unsigned eight-bit integers,

00:20:03.466 --> 00:20:06.526
but, like you always
thought it was.

00:20:06.806 --> 00:20:08.546
Let's look at some of the
things we can do with some

00:20:08.546 --> 00:20:09.926
of Data's new conformances.

00:20:11.016 --> 00:20:13.236
First we're going to need
some data, and I happen

00:20:13.236 --> 00:20:15.456
to have some base64
data lying around,

00:20:15.616 --> 00:20:17.656
which we'll parse using
the normal initializer.

00:20:18.476 --> 00:20:23.796
In the explicit unwrap here
is, I know it's safe to do this

00:20:23.826 --> 00:20:25.126
because this is a demo,

00:20:25.126 --> 00:20:26.546
and I know that that's
valid base64 [laughter].

00:20:26.546 --> 00:20:31.446
You should probably use a
try there if you do this

00:20:31.446 --> 00:20:35.376
for yourself, but let's say,
you know, I like statistics

00:20:35.376 --> 00:20:36.826
and the nice thing to look

00:20:36.826 --> 00:20:38.546
at when you have
statistics is a histogram.

00:20:38.546 --> 00:20:39.416
That's always a good
thing to start.

00:20:39.416 --> 00:20:40.426
So we're going to
build a histogram.

00:20:40.646 --> 00:20:42.126
We'll use as our
backing storage,

00:20:42.126 --> 00:20:44.806
we'll use a native Swift array,
which will initialize to zero,

00:20:44.996 --> 00:20:48.466
and we'll just use the byte
value of each byte in the data

00:20:48.466 --> 00:20:51.216
as the index and maintain
a frequency count.

00:20:52.046 --> 00:20:54.696
So let's, because Data
is a collection iterating

00:20:54.696 --> 00:20:58.026
through its bytes, is natural
and expressive, which we can do

00:20:58.026 --> 00:21:01.066
with a four N loop, and so
we'll produce our histogram.

00:21:01.066 --> 00:21:01.856
And let's take a look.

00:21:01.856 --> 00:21:04.636
Well that definitely
looks like a histogram,

00:21:04.896 --> 00:21:07.076
and like all histograms,
there's signal and noise,

00:21:07.076 --> 00:21:09.216
and I'm seeing a lot of high
frequency data in there,

00:21:09.856 --> 00:21:11.436
and I'd like to filter that out,

00:21:11.726 --> 00:21:14.536
and luckily Data's a collection
now, and so we gain access

00:21:14.536 --> 00:21:16.396
to things like Map,
Reduce, and Filter,

00:21:16.396 --> 00:21:19.106
and all of your other
favorite collection functions.

00:21:19.656 --> 00:21:21.606
And so, let's say we wanted
to remove all the data

00:21:21.606 --> 00:21:23.486
that was greater than three.

00:21:23.786 --> 00:21:25.996
It's as simple as
specifying a predicate now,

00:21:26.436 --> 00:21:29.666
and we can generate
our new filtered data.

00:21:30.666 --> 00:21:33.306
And also as a collection,
Data is sliceable,

00:21:33.816 --> 00:21:37.156
and these slices work just
like the mutable collections,

00:21:37.326 --> 00:21:38.256
or value type collections

00:21:38.256 --> 00:21:40.306
that you're already
accustomed to in Swift.

00:21:41.456 --> 00:21:44.456
Mutating them invokes the
same copy on write machinery

00:21:44.456 --> 00:21:48.166
that Tony described earlier and
they work just the same way.

00:21:49.826 --> 00:21:53.426
Now, Data also remains
extensible through inheritance

00:21:53.426 --> 00:21:54.946
of the underlying
reference type,

00:21:55.176 --> 00:21:57.866
and that's a very big sentence,
so I'll walk through an example

00:21:57.866 --> 00:21:59.636
to show what I mean by that.

00:22:00.056 --> 00:22:01.346
As an example, let's go ahead

00:22:01.346 --> 00:22:04.106
and create a custom
NSData subclass

00:22:04.426 --> 00:22:05.676
that allocates no storage,

00:22:05.906 --> 00:22:08.446
but represents a virtual
collection of all ones.

00:22:09.116 --> 00:22:10.556
We'll call it an AllOnesData.

00:22:10.806 --> 00:22:11.556
Very descriptive.

00:22:11.556 --> 00:22:14.006
And I'm only going to show the
implementation a single method

00:22:14.006 --> 00:22:17.916
here, specifically
getBytes, wherein the promise

00:22:17.916 --> 00:22:20.596
of this class is more
or less fulfilled.

00:22:20.736 --> 00:22:21.976
We set all the bytes to one.

00:22:22.436 --> 00:22:26.016
So we don't need to store
anything, and let's go ahead

00:22:26.016 --> 00:22:27.936
and create a read-only
instance of this.

00:22:28.496 --> 00:22:30.116
But we won't just
use the reference.

00:22:30.116 --> 00:22:33.906
We're actually going
to create a value type

00:22:33.906 --> 00:22:35.636
that wraps the reference
type here.

00:22:35.926 --> 00:22:39.546
And using that, we just use
the new initializer for Data,

00:22:39.546 --> 00:22:41.786
and it works exactly the
way you would expect.

00:22:42.536 --> 00:22:46.226
We have a ones value type that's
now pointing to the reference

00:22:46.226 --> 00:22:47.946
of all ones, and those
ones are virtual.

00:22:47.946 --> 00:22:50.306
They don't actually consume
bytes in memory currently.

00:22:50.626 --> 00:22:53.106
Let's go ahead and create
a mutable copy, and again,

00:22:53.236 --> 00:22:56.156
we've not done any mutation,
so we don't need to allocate

00:22:56.156 --> 00:22:58.266
or manifest any of those
bytes in memory currently.

00:22:59.096 --> 00:23:01.646
But let's get ready to mutate
those bytes, and to do that,

00:23:01.646 --> 00:23:04.146
we're going to actually use
another new Foundation API this

00:23:04.146 --> 00:23:07.646
year, which is the
Scoped Pointer Accessor,

00:23:08.626 --> 00:23:10.856
called withUnsafe MutableBytes.

00:23:11.046 --> 00:23:13.456
And this is much better than
just calling mutable bytes

00:23:13.456 --> 00:23:18.646
on the data itself, because
we're scoping the access

00:23:18.646 --> 00:23:20.886
to those bytes within the
closure that we're specifying,

00:23:21.236 --> 00:23:23.956
which it makes it very easy to
reason about where, you know,

00:23:23.956 --> 00:23:25.446
you don't have pointers
just flying around.

00:23:25.446 --> 00:23:27.536
Pointers are only going to
be in these little accessors.

00:23:28.596 --> 00:23:31.916
And so we actually perform our
mutation, invoking the copy

00:23:31.916 --> 00:23:34.066
on right machinery, and
those bytes are now,

00:23:34.176 --> 00:23:38.966
the copies bytes are now
manifested memory for reals.

00:23:39.066 --> 00:23:40.036
Let's move on to
another example.

00:23:40.036 --> 00:23:41.296
I'm tired of talking about Data.

00:23:42.006 --> 00:23:47.216
Let's talk about, URLs
and URL properties.

00:23:47.546 --> 00:23:49.866
Now to motivate this
example, I want to talk first

00:23:49.866 --> 00:23:53.146
about how we did
this in Swift 2.2.

00:23:53.146 --> 00:23:56.456
So in Swift 2.2, we would
ask for a NSURL file URL,

00:23:56.456 --> 00:23:58.626
we're going to talk about by
special file, and this file is

00:23:58.626 --> 00:24:01.336
so special, I keep it at
the root of my file system.

00:24:02.086 --> 00:24:03.676
And I'm curious about
three properties.

00:24:03.676 --> 00:24:06.966
I care about the creation date,
whether or not it's regular,

00:24:07.306 --> 00:24:10.016
and for some reason, the
maximum file size for the volume

00:24:10.016 --> 00:24:11.186
that this file's located on.

00:24:11.866 --> 00:24:14.116
And these are just strings
in Swift 2.2 and you just,

00:24:14.116 --> 00:24:15.646
this is just an array
of strings.

00:24:16.036 --> 00:24:18.426
And when I ask my URL
for its resource values,

00:24:18.426 --> 00:24:21.516
I just get a regular dictionary,
and there's no type information.

00:24:21.516 --> 00:24:25.016
It's just a string to an
object, which means consuming

00:24:25.016 --> 00:24:29.676
that result requires a lot of
as is typing, and so I have to,

00:24:29.676 --> 00:24:31.086
you know, suggest
that it's a Boolean,

00:24:31.086 --> 00:24:32.376
and suggest that
it's an integer,

00:24:32.376 --> 00:24:35.246
and I'm constantly consulting
the references to make sure

00:24:35.246 --> 00:24:38.696
that I'm getting it right, and
further, mutation is also just

00:24:38.696 --> 00:24:39.826
in terms of the dictionary.

00:24:40.336 --> 00:24:45.236
And so you can do
absurd things like this,

00:24:45.366 --> 00:24:48.206
and it's every failure is
going to a runtime failure.

00:24:49.166 --> 00:24:51.126
So, let's see how this
gets better in Swift 3.

00:24:51.796 --> 00:24:55.416
In Swift 3, creating
the URL is similar,

00:24:55.416 --> 00:24:59.006
but we no longer use a
class factory method.

00:24:59.006 --> 00:25:02.626
This is moved into a
regular initializer syntax.

00:25:03.456 --> 00:25:05.036
We're still talking
about my special file,

00:25:05.996 --> 00:25:09.656
and instead of asking with an
array of strings we're going

00:25:09.656 --> 00:25:11.966
to use those new strongly
typed string enumerations

00:25:11.966 --> 00:25:14.566
that I mentioned earlier, and
we'll produce a set of them,

00:25:14.566 --> 00:25:17.546
and when we ask the URL
for the resource values,

00:25:17.546 --> 00:25:19.296
no longer are we going
to get a dictionary,

00:25:19.606 --> 00:25:21.876
but instead we're
going to get a value,

00:25:21.966 --> 00:25:24.326
a new Foundation value
type, and let's see what

00:25:24.326 --> 00:25:26.746
that Foundation value type
is for the three properties

00:25:26.776 --> 00:25:28.296
that we're asking
about right now.

00:25:29.346 --> 00:25:31.476
As you can see, creation
date is a Date,

00:25:31.846 --> 00:25:33.176
its regular file is a Bool,

00:25:33.176 --> 00:25:35.366
and volume maximum file
size is an integer.

00:25:35.796 --> 00:25:38.686
And it's also worth pointing

00:25:38.686 --> 00:25:42.396
out that the URLResourceValue
struct itself is lazy.

00:25:42.396 --> 00:25:45.626
It's still implemented in terms
of the dictionary that was done

00:25:45.626 --> 00:25:48.606
in the Swift 2 API, so we're not
necessarily this giant struct

00:25:48.746 --> 00:25:51.176
of things that are
going to consume memory.

00:25:51.176 --> 00:25:52.926
It's still going to be,
I asked for three things,

00:25:52.926 --> 00:25:54.356
I get potentially
three things back.

00:25:54.746 --> 00:25:56.246
And further, if you
have custom keys,

00:25:56.246 --> 00:25:58.356
the dictionary is still here,
but no longer are you going

00:25:58.356 --> 00:25:59.676
to ask for a string,
you're going to ask

00:25:59.676 --> 00:26:01.576
for the URL resource key
that you're interested in.

00:26:02.656 --> 00:26:04.836
Now, you might be noticing
there's a lot of question marks

00:26:04.836 --> 00:26:07.276
and the reason why is, well,
there's two reasons why.

00:26:07.276 --> 00:26:09.056
The first is that you
didn't ask for it.

00:26:09.366 --> 00:26:11.616
So, if you didn't ask for the
creation date it won't be there,

00:26:11.616 --> 00:26:13.776
and that again, goes back to
that sparseness of the data.

00:26:14.256 --> 00:26:16.246
The second reason why
it might not be there is

00:26:16.246 --> 00:26:20.526
that the property itself might
be failable, and as an example

00:26:20.526 --> 00:26:21.796
of VolumeMaximumFileSize.

00:26:22.066 --> 00:26:24.266
Let's look at two
examples of how that works.

00:26:25.536 --> 00:26:28.916
So because we asked for regular
file, we're entirely justified

00:26:28.916 --> 00:26:30.686
to explicitly unwrap
our optional here.

00:26:30.686 --> 00:26:31.576
It will be there.

00:26:31.576 --> 00:26:32.586
We asked for it.

00:26:32.696 --> 00:26:35.696
However, the documentation
for VolumeMaximumFileSize says

00:26:35.696 --> 00:26:38.676
that not all volumes and not all
file systems support a maximum

00:26:38.676 --> 00:26:41.206
file system size, and so
it might not be there.

00:26:41.416 --> 00:26:45.336
And as a perfect example of a
time to use the if let construct

00:26:45.336 --> 00:26:47.686
in Swift, to conditionally
set that local variable.

00:26:47.686 --> 00:26:51.226
Now, let's talk about mutation.

00:26:51.396 --> 00:26:54.446
Of course, the mutation
API now for the URLs

00:26:54.446 --> 00:26:57.176
in URLResourceValues is in
terms of its new value type,

00:26:57.516 --> 00:26:58.776
and so when you try
to, you know,

00:26:58.776 --> 00:27:00.986
even though this is my special
file, and I'm trying very hard

00:27:00.986 --> 00:27:04.236
to say that it's not regular,
the compiler will catch me

00:27:04.236 --> 00:27:06.246
at compile time instead
of letting me discover

00:27:06.246 --> 00:27:07.286
that problem at run time.

00:27:07.856 --> 00:27:12.386
And further, the creation date
is strongly typed as a Date,

00:27:12.386 --> 00:27:14.676
and so something absurd
like this might work

00:27:14.676 --> 00:27:16.856
with Siri, can't work with code.

00:27:17.466 --> 00:27:20.396
Now the last thing
I want to talk

00:27:20.396 --> 00:27:23.076
about on this Foundation
adventure is I want to talk

00:27:23.076 --> 00:27:24.746
about Swift's native
enumerations.

00:27:24.956 --> 00:27:27.576
And we're going to talk about
data again one more time,

00:27:27.576 --> 00:27:29.136
because there's a
really good example.

00:27:30.256 --> 00:27:32.686
When data takes ownership
of an UnsafeMutablePointer,

00:27:32.856 --> 00:27:35.116
you have the option of
specifying a deallocator.

00:27:36.636 --> 00:27:38.456
Data supports many
of these by default,

00:27:38.456 --> 00:27:43.426
and including the option to
specify a custom deallocator.

00:27:44.256 --> 00:27:49.106
Now, Swift supports
associated values with enums

00:27:49.106 --> 00:27:50.616
and oftentimes you'll
see these with, you know,

00:27:50.616 --> 00:27:52.996
integers where you can do case
expressions and stuff like that

00:27:52.996 --> 00:27:56.206
to be able to, you know, do
really cool pattern matching

00:27:56.206 --> 00:27:57.586
with it, but here
we're taking a closure,

00:27:57.966 --> 00:28:00.526
because we actually want
to wrap the behavior

00:28:00.526 --> 00:28:01.486
that you want to provide.

00:28:01.746 --> 00:28:03.066
Let's see this in action.

00:28:03.216 --> 00:28:04.966
We'll start simple
with a malloc case.

00:28:05.296 --> 00:28:07.256
Of course, you can
still malloc in Swift,

00:28:07.256 --> 00:28:10.316
although you probably don't
see it in a slide very often.

00:28:10.536 --> 00:28:14.986
So, you malloc, and when you
hand this pointer off to Data,

00:28:15.216 --> 00:28:17.036
you can, you'll deallocate
it with free,

00:28:17.116 --> 00:28:20.796
and the syntax there
is just simple

00:28:20.856 --> 00:28:23.156
as using the integration
values themselves.

00:28:23.526 --> 00:28:24.826
Let's look at a custom example.

00:28:24.936 --> 00:28:27.026
Let's suppose we have a
function that allows us

00:28:27.026 --> 00:28:30.156
to create glorious pointers,
which we want to make sure we

00:28:30.156 --> 00:28:32.446
that we free gloriously,
lest they be offended,

00:28:32.826 --> 00:28:35.606
and so we can specify the custom
deallocator, it's as simple

00:28:35.606 --> 00:28:38.596
as providing a closure
and making sure

00:28:38.596 --> 00:28:40.186
that you do the custom
thing that you like to do.

00:28:40.186 --> 00:28:45.656
And this is really powerful, and
really powerful concept or idea

00:28:45.656 --> 00:28:46.976
for framework developers,

00:28:47.246 --> 00:28:50.836
because in other languages
we would have needed

00:28:50.836 --> 00:28:52.886
to provide a second
function pointer-based API,

00:28:53.256 --> 00:28:57.566
but now in Swift 3, we can
provide a single enum-based API

00:28:57.566 --> 00:29:00.096
that expresses all of
these ideas very cleanly,

00:29:00.476 --> 00:29:01.166
and expressively.

00:29:02.386 --> 00:29:04.276
And so that concludes our
API adventure for now.

00:29:04.586 --> 00:29:06.416
Hopefully we saw a great
many wonders, and I'm going

00:29:06.416 --> 00:29:07.376
to hand things back to Tony

00:29:07.376 --> 00:29:08.646
to talk a little
more about adoption.

00:29:09.516 --> 00:29:15.746
[ Applause ]

00:29:16.246 --> 00:29:16.686
>> Thanks Michael.

00:29:17.216 --> 00:29:21.026
All right, now you've seen just
a little bit of what's possible.

00:29:21.676 --> 00:29:23.616
Let's talk about how you
can use it in your app.

00:29:24.986 --> 00:29:26.656
First, let's talk
about bridging.

00:29:27.046 --> 00:29:29.066
So, keeping with this theme
of iterative improvement,

00:29:29.486 --> 00:29:31.036
we've extended the
exact same concept

00:29:31.036 --> 00:29:33.716
that you're already familiar
with from Swift 2 for bridging

00:29:33.716 --> 00:29:36.976
between Objective-C and Swift,
so if you understand how String

00:29:36.976 --> 00:29:38.726
and NSString are
bridged, we've extended

00:29:38.726 --> 00:29:40.786
that exact same concepts
for Data and NSData

00:29:40.786 --> 00:29:42.666
and all the other value
types that you see here.

00:29:43.916 --> 00:29:47.466
That means that all
of the imported API

00:29:47.506 --> 00:29:50.696
from Cocoa SDK is going to
use these new value types,

00:29:51.136 --> 00:29:54.586
and that's a key part of how we
achieve this idea of leverage.

00:29:55.126 --> 00:29:59.346
So for example, in
AppKit in Swift 2.2,

00:29:59.556 --> 00:30:02.246
you'll see this class called
NSDatePicker, which let's,

00:30:02.746 --> 00:30:06.466
presents a UI to allow your
user to pick a date and it has,

00:30:06.536 --> 00:30:09.176
among others, two properties
for controlling those dates

00:30:09.476 --> 00:30:11.406
and you see here their
marked as @NSCopying,

00:30:11.676 --> 00:30:13.616
and also NSDate reference types.

00:30:15.016 --> 00:30:17.146
In Swift 3, with no
change to AppKit,

00:30:17.536 --> 00:30:19.306
just by making these
changes in Foundation,

00:30:19.666 --> 00:30:20.766
this class looks like this.

00:30:20.926 --> 00:30:23.746
You see we've got the struct
date type, and we no longer need

00:30:23.746 --> 00:30:27.126
to mark this as @NSCopying
because they're value types,

00:30:27.186 --> 00:30:28.756
and we handle the
copying for you.

00:30:29.366 --> 00:30:34.666
Now there can be a performance
cost for crossing this bridge

00:30:34.846 --> 00:30:37.916
and to explain what that is, I'd
like to dive into some details

00:30:37.916 --> 00:30:39.546
on how the bridging
actually works.

00:30:39.856 --> 00:30:42.796
We have two major strategies for
bridging, one for large types,

00:30:42.886 --> 00:30:45.416
which hold a reference, and
a second for small types,

00:30:45.556 --> 00:30:46.646
which create a reference.

00:30:47.356 --> 00:30:51.106
So, for example, we're
going back to data.

00:30:51.186 --> 00:30:53.496
Here I've created data
again, and you see a struct

00:30:53.536 --> 00:30:54.716
that wraps a reference type.

00:30:55.246 --> 00:30:58.326
Now, if I call some
Objective-C API, what happens is

00:30:58.326 --> 00:31:01.106
that we hand the reference
over to the Objective-C side.

00:31:01.486 --> 00:31:02.216
That's because, of course,

00:31:02.216 --> 00:31:03.866
Objective-C doesn't
deal with struct Data.

00:31:03.866 --> 00:31:05.466
It only understands NSData.

00:31:05.966 --> 00:31:07.996
Now, in this case perhaps
a synchronous method call,

00:31:08.326 --> 00:31:10.616
that Objective-C code isn't
going to hold onto that data

00:31:10.616 --> 00:31:11.636
for any period of time.

00:31:11.636 --> 00:31:13.266
It may access it, and
then forget about it.

00:31:13.436 --> 00:31:15.206
So, just holding the reference

00:31:15.206 --> 00:31:16.476
for a short period
of time is enough.

00:31:17.066 --> 00:31:20.106
On the other hand, you'll see
many APIs that, for example,

00:31:20.106 --> 00:31:23.436
take a data for longer period
of time, usually marked

00:31:23.436 --> 00:31:25.926
as properties that have
the copying attribute.

00:31:26.916 --> 00:31:28.766
In that case, in Objective-C,

00:31:29.126 --> 00:31:31.646
this Objective-C code will
call copy on that data,

00:31:32.106 --> 00:31:33.876
and that's because it
needs to protect itself

00:31:33.876 --> 00:31:36.066
from any potential mutation
that happens to that data

00:31:36.066 --> 00:31:38.286
that it just received from
a totally unknown source.

00:31:39.236 --> 00:31:42.436
So that means that when crossing
this bridge, a copy can occur.

00:31:43.296 --> 00:31:44.336
Let's flip that around
the other way.

00:31:44.526 --> 00:31:45.706
Let's say I've got
some Swift code

00:31:45.706 --> 00:31:48.326
that is calling an Objective-C
method that returns some data.

00:31:48.846 --> 00:31:50.766
Here, the Objective-C
code has, of course,

00:31:50.766 --> 00:31:53.996
created the class NSData and
when it's returned to Swift,

00:31:54.746 --> 00:31:57.036
we create the struct Data,
which wraps the reference

00:31:57.106 --> 00:31:59.596
and it calls copy, for exactly
the same reason as we saw

00:31:59.596 --> 00:32:00.336
in the previous slide.

00:32:00.846 --> 00:32:03.206
The struct needs to maintain
its control over this copy

00:32:03.206 --> 00:32:06.386
so that it can provide the
proper value semantics for you.

00:32:07.776 --> 00:32:10.426
Fortunately, almost all data
that you receive this way

00:32:10.426 --> 00:32:11.986
from the SDK is immutable,

00:32:12.276 --> 00:32:14.416
which means that the copy
is actually just a retain.

00:32:14.606 --> 00:32:16.236
However, it is important
to understand

00:32:16.526 --> 00:32:18.846
that when crossing this
bridge, a copy may occur.

00:32:19.966 --> 00:32:23.456
For small types, like Date, you
can see there is no reference.

00:32:23.516 --> 00:32:24.866
We saw earlier the
implementation,

00:32:24.866 --> 00:32:25.486
just had a double.

00:32:25.996 --> 00:32:30.366
So, in Swift, if we call an
Objective-C function, or method,

00:32:30.906 --> 00:32:34.766
which takes a date, then we
have to allocate an NSDate

00:32:34.766 --> 00:32:37.296
on the bridging, and
that's again, of course,

00:32:37.296 --> 00:32:38.836
because the Objective-C
code only knows how

00:32:38.836 --> 00:32:39.726
to deal with references.

00:32:40.236 --> 00:32:42.886
Now, we do a lot of tricks in
Objective-C to make allocation

00:32:42.886 --> 00:32:44.786
of things like NSDates
really cheap.

00:32:45.156 --> 00:32:46.906
However, it is important
to understand

00:32:46.906 --> 00:32:48.976
that an allocation can
occur on that bridge.

00:32:53.516 --> 00:32:56.016
So, we optimize these
sites for use within Swift.

00:32:56.976 --> 00:32:58.916
In your code, you should
avoid crossing back and forth

00:32:58.916 --> 00:33:00.776
over that bridge repeatedly.

00:33:01.826 --> 00:33:04.206
This is because we wanted our
code to be safe by default,

00:33:04.656 --> 00:33:07.186
but it does mean that there
is a potential copy there.

00:33:07.186 --> 00:33:08.846
So, something to be aware
of when you're looking

00:33:08.846 --> 00:33:10.216
at adopting these
new value types.

00:33:10.666 --> 00:33:13.326
Next, let's talk
about migration.

00:33:14.296 --> 00:33:15.296
So, first, some good news.

00:33:16.166 --> 00:33:18.086
These new types we're
talking about today exist

00:33:18.086 --> 00:33:19.816
for all Swift deployment
targets.

00:33:20.496 --> 00:33:22.026
They're part of the
Swift Standard Library,

00:33:22.496 --> 00:33:24.266
which means you don't need
to wait for your customers

00:33:24.266 --> 00:33:26.376
to upgrade to the newest
versions of our platforms.

00:33:26.826 --> 00:33:29.016
As soon as Swift 3 and
S Creator are released,

00:33:29.016 --> 00:33:30.386
you can begin using
them immediately.

00:33:31.216 --> 00:33:34.936
Now, to help you, we've of
course upgraded the Migrator,

00:33:35.416 --> 00:33:38.706
and that means that when you
open your project in Xcode 8,

00:33:38.706 --> 00:33:41.346
you'll see a dialog box like
this one, and I recommend

00:33:41.346 --> 00:33:42.156
that you click convert.

00:33:42.526 --> 00:33:43.766
So, let me show you a few things

00:33:43.986 --> 00:33:45.676
that the Migrator
will do for you.

00:33:46.676 --> 00:33:49.616
So here we have in
Swift 2.2 some NSDates,

00:33:49.826 --> 00:33:52.886
and we're calling a method on
that, dateByAddingtimeInterval.

00:33:53.456 --> 00:33:56.616
The Migrator will fix up
the reference type NSDate

00:33:56.616 --> 00:33:58.486
into the value type
of struct Date,

00:33:59.206 --> 00:34:00.996
and it will change the methods

00:34:01.216 --> 00:34:02.746
because they've changed
according

00:34:02.746 --> 00:34:04.606
to our new Swift 3
API Design Guidelines,

00:34:05.016 --> 00:34:07.566
both for the reference types
and for the value types.

00:34:08.335 --> 00:34:09.376
Here's another example.

00:34:10.085 --> 00:34:12.606
Here, I'm creating an
NSDateComponents in Swift 2,

00:34:12.956 --> 00:34:16.496
and then setting some of its
properties, and I can do this

00:34:16.496 --> 00:34:19.866
because NSDateComponents is an
always mutable reference type.

00:34:20.656 --> 00:34:21.366
Now, in Swift 3,

00:34:21.366 --> 00:34:23.235
we've introduced a
struct DateComponents.

00:34:23.636 --> 00:34:25.775
So the Migrator will change
the reference to the struct,

00:34:26.416 --> 00:34:29.216
but also it notices that you're
mutating it, and changes the let

00:34:29.216 --> 00:34:30.446
to a var for you as well.

00:34:31.466 --> 00:34:33.505
Now the Migrator can
do quite a bit for you,

00:34:33.896 --> 00:34:35.956
but there are some places
where if you go back and look

00:34:35.956 --> 00:34:38.596
at what it's done, you can do
even better by taking advantage

00:34:38.596 --> 00:34:40.315
of some additional things
that we've added for you.

00:34:40.726 --> 00:34:43.536
In this case, DateComponents
has a new initializer,

00:34:43.536 --> 00:34:45.186
and this is something
we can only do in Swift.

00:34:45.186 --> 00:34:48.545
The initializer has
arguments for every property

00:34:48.545 --> 00:34:50.295
in the DateComponents,
and they're all optional,

00:34:50.406 --> 00:34:51.505
and they all have
default values,

00:34:51.835 --> 00:34:53.966
which means that you can create
a DataComponents using only the

00:34:53.966 --> 00:34:56.426
values you care about, your
month and day in this case.

00:34:56.696 --> 00:34:58.066
And you can change
the var back to a let

00:34:58.176 --> 00:34:59.826
because now you don't
need to mutate it

00:34:59.826 --> 00:35:01.386
after you've initialized it.

00:35:02.986 --> 00:35:04.656
And finally, our
friend data again.

00:35:05.156 --> 00:35:08.036
Here in Swift 2, see that I'm
creating an NSMutableData,

00:35:08.206 --> 00:35:10.556
the reference type, and
appending some data to it.

00:35:11.846 --> 00:35:14.556
In Swift 3, the Migrator
will fix up the method names,

00:35:14.826 --> 00:35:18.196
like contentsOf URL,
and appendData,

00:35:19.376 --> 00:35:21.796
and it will change NSData
into the struct Data.

00:35:22.246 --> 00:35:24.536
However, it's left the
NSMutableData reference

00:35:24.536 --> 00:35:25.006
type alone.

00:35:25.526 --> 00:35:28.046
In some cases like this, there's
just not enough information

00:35:28.046 --> 00:35:29.066
for the Migrator in order

00:35:29.066 --> 00:35:31.236
to do what we think is the
best option, so we're going

00:35:31.236 --> 00:35:33.036
to leave it as is and
it should still work.

00:35:33.726 --> 00:35:36.176
However, if you go back and
do some additional fix ups

00:35:36.176 --> 00:35:38.676
on your own, you can
do something cool here.

00:35:38.736 --> 00:35:41.056
We can change the
MutableData into a struct Data,

00:35:41.636 --> 00:35:43.516
which means that we
change it from let to var.

00:35:43.866 --> 00:35:46.046
And we can remove
the options argument

00:35:46.046 --> 00:35:47.426
because it has a
default value now.

00:35:48.006 --> 00:35:51.596
So, we've talked
about a lot today,

00:35:51.596 --> 00:35:53.316
and I'd like to just
briefly recap what we saw.

00:35:54.496 --> 00:35:55.826
We believe that these
improvements

00:35:55.826 --> 00:35:58.316
to Foundation are going
to benefit the entire SDK

00:35:58.316 --> 00:36:00.486
and your whole development
experience in Swift.

00:36:01.366 --> 00:36:03.496
Partly that was due
to the API renaming,

00:36:03.966 --> 00:36:06.406
but we also took the
opportunity to go farther,

00:36:06.596 --> 00:36:08.446
and add a brand new
set of value types,

00:36:08.566 --> 00:36:10.426
and a lot of new
Swift-specific API.

00:36:11.626 --> 00:36:14.846
We see this as the start
of a journey, and we intend

00:36:14.846 --> 00:36:16.886
to continue to be this
leverage point in the future.

00:36:16.886 --> 00:36:19.006
We're going to make many
improvements over time

00:36:19.006 --> 00:36:22.056
to make your Swift apps safer,
faster, and more expressive.

00:36:23.296 --> 00:36:25.406
So for more information,
check out this struct URL,

00:36:26.556 --> 00:36:30.186
and these related sessions,
including, Going Server-side

00:36:30.186 --> 00:36:31.976
with Swift Open Source,
Measurements and Units.

00:36:32.111 --> 00:36:34.111
[ Applause ]

00:36:34.206 --> 00:36:34.446
Thank you.

00:36:35.508 --> 00:36:37.508
[ Applause ]
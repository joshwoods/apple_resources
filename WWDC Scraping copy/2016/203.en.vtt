WEBVTT

00:00:07.516 --> 00:00:25.926
[ Music ]

00:00:26.426 --> 00:00:26.946
>> Good morning.

00:00:28.006 --> 00:00:29.016
My name is Ali Ozer.

00:00:29.396 --> 00:00:30.506
I and my colleagues [applause].

00:00:31.496 --> 00:00:31.786
Thank you.

00:00:35.336 --> 00:00:37.926
I and my colleagues Raleigh
Ledet and Taylor Kelly

00:00:37.926 --> 00:00:40.206
from the Cocoa Frameworks
team will be talking

00:00:40.206 --> 00:00:41.866
about what's new
in Cocoa this year.

00:00:42.856 --> 00:00:44.006
Our agenda is pretty simple.

00:00:44.006 --> 00:00:47.016
First, API updates
followed by new features

00:00:47.016 --> 00:00:48.246
in AppKit and Foundation.

00:00:49.776 --> 00:00:54.116
And in the area of API updates,
we have two main categories

00:00:54.116 --> 00:00:55.726
of API updates I
want to talk about.

00:00:55.726 --> 00:00:59.046
One, the API changes due to
the new Swift API guidelines

00:00:59.476 --> 00:01:01.866
and secondly, the general API
refinements we've been doing.

00:01:02.296 --> 00:01:03.306
So let's get started.

00:01:04.436 --> 00:01:07.746
Now as you heard probably
yesterday or if not,

00:01:07.786 --> 00:01:11.636
this morning, we have new API
design guidelines in Swift.

00:01:11.636 --> 00:01:13.936
And these guidelines still
embrace Cocoa conventions

00:01:13.936 --> 00:01:16.176
and practices and
I'll just remind you

00:01:16.176 --> 00:01:17.356
of what some of these are.

00:01:18.176 --> 00:01:20.346
Using clear and consistent
naming,

00:01:20.936 --> 00:01:24.486
striving for fluent usage, you
know, where a call site reads

00:01:24.486 --> 00:01:27.016
as an English phrase,
naming mutating

00:01:27.016 --> 00:01:30.406
and non-muting method pairs
consistently, sort and sorted,

00:01:30.626 --> 00:01:33.876
append and appending, and
avoiding abbreviations.

00:01:33.876 --> 00:01:36.606
These are just of the
main guidelines we've had

00:01:36.636 --> 00:01:39.236
for many years and
we've documented these

00:01:39.236 --> 00:01:41.296
and we've talked about
them in previous WWDCs,

00:01:41.296 --> 00:01:42.796
as you see in this session here.

00:01:43.496 --> 00:01:45.566
And now we updated
the guidelines

00:01:45.956 --> 00:01:48.956
to utilize Swift features
such as strong typing,

00:01:49.216 --> 00:01:51.526
type inference, and overloading,

00:01:51.776 --> 00:01:54.756
and to make sure our APIs
shine through in Swift.

00:01:54.756 --> 00:01:57.146
And let me talk about some of
the key differences in our APIs

00:01:57.146 --> 00:01:58.626
as a result of these changes.

00:01:59.096 --> 00:02:02.466
For one thing, we're eliminating
repeated and needless words,

00:02:02.666 --> 00:02:05.636
which of course makes
our APIs more swifty,

00:02:05.666 --> 00:02:06.906
as you might have
heard yesterday.

00:02:06.906 --> 00:02:09.545
You saw an example yesterday in
Chris Lattner's section of state

00:02:09.545 --> 00:02:11.256
of the union with an example.

00:02:11.256 --> 00:02:14.526
Here's another example,
contacts.arrayByAddingObject.

00:02:14.896 --> 00:02:19.056
In a method call like this, both
the words "array" and the words

00:02:19.056 --> 00:02:21.426
"object" don't really
add much to that call.

00:02:21.766 --> 00:02:25.176
So such a name now comes across
as contacts.adding(person).

00:02:26.486 --> 00:02:30.046
Here's another example
on the NSColor class.

00:02:30.046 --> 00:02:33.616
NSColor.blueColor, now
we're on the NSColor class.

00:02:33.616 --> 00:02:35.076
Blue is already a color,

00:02:35.076 --> 00:02:37.516
so the word color really
doesn't add much to this call.

00:02:37.876 --> 00:02:39.496
So in the new guidelines,
it actually comes

00:02:39.496 --> 00:02:41.056
across as NSColor.blue.

00:02:41.836 --> 00:02:44.386
But note that we're still
striving for clarity.

00:02:44.576 --> 00:02:47.986
Here's another method from
NSColor, NSColor.textColor.

00:02:49.016 --> 00:02:51.756
Text is not inherently
a color and, in fact,

00:02:51.756 --> 00:02:55.086
talking about the text of
a color could be confusing.

00:02:55.506 --> 00:02:59.006
Is it the text that represents
the color's RGB values or what?

00:02:59.516 --> 00:03:01.866
So in a case like this, we've
actually left the method alone

00:03:01.866 --> 00:03:04.136
and it comes across
as NSColor.textColor,

00:03:04.266 --> 00:03:06.676
like it used to be.

00:03:08.506 --> 00:03:13.616
Now some of the other key
changes to making use of types,

00:03:13.756 --> 00:03:18.376
here's an example,
document.readFromURL ofType,

00:03:18.606 --> 00:03:22.506
now this API comes across
as document.readFrom ofType.

00:03:22.856 --> 00:03:26.636
You'll note that we've
dropped the word URL

00:03:26.736 --> 00:03:27.886
from our method signature.

00:03:28.076 --> 00:03:31.376
It's because the type of
the first argument is URL

00:03:31.656 --> 00:03:34.146
and with type inference, Swift
knows enough to handle that.

00:03:34.346 --> 00:03:35.496
And by dropping that word,

00:03:35.496 --> 00:03:38.246
we actually now have three
read methods on an NSDocument

00:03:38.916 --> 00:03:42.256
that are all named exactly the
same thing read from ofType

00:03:42.256 --> 00:03:45.626
and it's that first argument,
the type of that first argument,

00:03:45.626 --> 00:03:48.036
URL data or FileWrapper

00:03:48.036 --> 00:03:50.406
that distinguishes
these from each other.

00:03:51.706 --> 00:03:54.576
Now another thing to note
here is making use of label

00:03:54.576 --> 00:03:56.556
on the first argument.

00:03:57.066 --> 00:04:00.526
From here has now been
pulled into the parens.

00:04:00.526 --> 00:04:02.066
We do this in a number of cases.

00:04:02.066 --> 00:04:03.896
For instance, when the
first argument performs part

00:04:03.896 --> 00:04:05.066
of a prepositional phrase,

00:04:05.376 --> 00:04:08.706
we pull that phrase inside the
parens, as you can see here.

00:04:08.706 --> 00:04:10.306
And you'll probably
see a lot more examples

00:04:10.306 --> 00:04:12.366
of this throughout out APIs.

00:04:12.766 --> 00:04:15.616
Now you'll also notice that
second argument ofType.

00:04:16.076 --> 00:04:18.305
Here we haven't dropped
the word type from the API

00:04:18.856 --> 00:04:20.786
because that argument
is a string

00:04:21.065 --> 00:04:22.446
and strings are weakly typed.

00:04:22.516 --> 00:04:24.806
So we really need a word
to describe their role

00:04:24.806 --> 00:04:26.746
and the role here is
that this is the type

00:04:26.746 --> 00:04:27.846
of file we're opening.

00:04:28.076 --> 00:04:32.036
So there, we keep the
word type in the API.

00:04:35.116 --> 00:04:38.406
Now many framework and standard
library APIs have changed

00:04:38.406 --> 00:04:39.936
as a result of these
new guidelines

00:04:40.376 --> 00:04:43.756
and the importer whose job
is to map Objective-C APIs

00:04:43.756 --> 00:04:46.716
into Swift now does it
using these new guidelines,

00:04:47.036 --> 00:04:49.726
but you'll note that some
APIs may need further tuning.

00:04:49.996 --> 00:04:53.056
We've done that in our APIs,
such as the API textColor,

00:04:53.056 --> 00:04:54.956
which I showed earlier,
which is an exception.

00:04:55.146 --> 00:04:57.776
And if you yourself have
Objective-C APIs you're exposing

00:04:57.776 --> 00:05:00.726
in Swift, you may need to do
so as well by using something

00:05:00.726 --> 00:05:04.526
like NS Swift Name, which lets
you override the default choice

00:05:04.526 --> 00:05:05.326
the importer is doing.

00:05:06.136 --> 00:05:08.376
You also know that the
migrator converts your --

00:05:08.376 --> 00:05:10.696
There's a migrator that converts
your existing Swift 2 code

00:05:10.696 --> 00:05:14.666
to Swift 3 and it will help
you with all this new naming

00:05:14.666 --> 00:05:16.086
in your existing
code, of course.

00:05:16.416 --> 00:05:18.886
And the Swift API
Design Guidelines talk,

00:05:18.886 --> 00:05:21.286
which took place just before
this one, you can catch this

00:05:21.286 --> 00:05:22.716
on video for a lot more details

00:05:22.766 --> 00:05:25.916
on these guidelines
and their impact.

00:05:26.046 --> 00:05:29.086
Now we have a number of
general APIs refinements,

00:05:29.366 --> 00:05:31.206
that some of which
we've done for a while

00:05:31.206 --> 00:05:32.536
and others we're
continuing to do.

00:05:32.536 --> 00:05:33.726
Let me quickly go through these.

00:05:34.246 --> 00:05:35.816
Nullability is something

00:05:35.816 --> 00:05:38.696
that we've already
done much of last year.

00:05:38.926 --> 00:05:42.006
It's basically declaring whether
arguments, return values,

00:05:42.006 --> 00:05:44.666
properties can be nil or
can be optional or not

00:05:45.006 --> 00:05:47.136
and we've continued to
refine this, this year.

00:05:47.466 --> 00:05:51.236
For instance, here's a method
which in 10.11 was marked

00:05:51.236 --> 00:05:52.766
as returning an optional value.

00:05:52.816 --> 00:05:56.736
This is addItem on NSMenu
but in 10.12 it's not marked

00:05:56.736 --> 00:05:59.746
as returning a non-optional
value because we determined

00:05:59.746 --> 00:06:01.926
that this can never really
return nil and it's better

00:06:01.926 --> 00:06:03.756
to reflect that properly
which makes your code,

00:06:03.756 --> 00:06:06.476
of course, a little simpler.

00:06:06.476 --> 00:06:09.636
We've been doing properties,
converting getter, setter pairs

00:06:09.636 --> 00:06:11.426
into formal properties all along

00:06:11.836 --> 00:06:14.736
and this year we're also
actually using Swift's ability

00:06:14.736 --> 00:06:16.146
to declare properties
on classes.

00:06:16.146 --> 00:06:19.326
For instance, here is a
new property on NSWindow.

00:06:19.386 --> 00:06:20.896
You'll hear about this
later in the talk,

00:06:20.896 --> 00:06:22.576
allowsAutomaticWindowTabbing.

00:06:23.216 --> 00:06:26.026
This is reflected as an actual
class property in Swift.

00:06:27.236 --> 00:06:28.836
You'll also note that
we have an ability now

00:06:28.836 --> 00:06:30.006
to do this in Objective-C.

00:06:30.296 --> 00:06:32.446
You can actually declare class
properties in Objective-C

00:06:32.446 --> 00:06:34.446
with this syntax
@property class.

00:06:34.786 --> 00:06:37.216
So the same feature comes
across in Objective-C

00:06:37.216 --> 00:06:38.286
as well, which is pretty cool.

00:06:38.736 --> 00:06:42.856
Here's a Core Data example
NSPersistentStoreCoordinator.

00:06:43.106 --> 00:06:45.936
It had this method,
registeredStoreTypes in 10.11.

00:06:46.176 --> 00:06:48.006
It's now declared
as a class property.

00:06:48.006 --> 00:06:49.176
It's a read-only property,

00:06:49.176 --> 00:06:51.226
so it only has a get,
as you can see here.

00:06:51.526 --> 00:06:53.196
And in Objective-C,
it also comes

00:06:53.196 --> 00:06:57.486
across as property
class, as you can see.

00:06:58.186 --> 00:07:00.016
Now generics, we've
been applying them

00:07:00.016 --> 00:07:02.476
to our collections' classes
but they're really, you know,

00:07:02.476 --> 00:07:03.576
not just for collections

00:07:03.576 --> 00:07:05.486
but they have many
other uses everywhere,

00:07:05.486 --> 00:07:07.036
I'm sure as you're aware.

00:07:07.436 --> 00:07:10.326
Here's an example from
Core Data, NSFetchRequest.

00:07:11.686 --> 00:07:14.376
Here's the way it's declared
in 10.11, pretty simple.

00:07:14.456 --> 00:07:16.606
In 10.12, we just went ahead

00:07:16.606 --> 00:07:19.016
and added a parameterized
type ResultType.

00:07:19.376 --> 00:07:23.436
We also touched a few other
APIs and we added some,

00:07:23.436 --> 00:07:24.786
such as this execute method

00:07:24.786 --> 00:07:27.686
which returns an array
of that result type.

00:07:28.076 --> 00:07:30.986
As a result of this, the use
case now becomes something

00:07:30.986 --> 00:07:31.556
like this.

00:07:31.916 --> 00:07:34.906
You have a request which you
get from a managed object,

00:07:34.906 --> 00:07:38.016
such as employee, and then when
you go ahead and execute that,

00:07:38.236 --> 00:07:40.176
your return now is
automatically inferred

00:07:40.176 --> 00:07:42.096
to be an array of employee.

00:07:42.716 --> 00:07:45.086
Now this is the case
right now but we're hoping

00:07:45.086 --> 00:07:47.816
that in upcoming seeds we'll
actually reflect this a little

00:07:47.816 --> 00:07:50.476
cleaner like so, which
is actually pretty cool.

00:07:50.476 --> 00:07:53.986
So from those two lines, the
compiler is able to infer

00:07:53.986 --> 00:07:56.126
that the return type is an
array of that managed object.

00:07:56.616 --> 00:07:59.966
We've been improving
our enumeration names.

00:08:00.366 --> 00:08:03.936
An example that we've done this
time around is NSColorPanelMode.

00:08:04.366 --> 00:08:07.266
The change -- And here's a
use case for it in Swift.

00:08:07.446 --> 00:08:08.966
You'll see that's
not very swifty

00:08:09.806 --> 00:08:12.836
because .NSCrayonModeColorPanel
is fairly wordy.

00:08:13.646 --> 00:08:17.396
The change we've done is to take
the common suffix and pull it

00:08:17.396 --> 00:08:19.306
in as a prefix, which
allows the Swift names

00:08:19.306 --> 00:08:20.716
to come across a lot cleaner.

00:08:20.786 --> 00:08:22.676
You know, where the
point just comes through,

00:08:23.036 --> 00:08:25.026
and the use case is .crayon.

00:08:25.076 --> 00:08:27.006
Again, this is what
it looked like before

00:08:27.516 --> 00:08:30.786
and this is what it looks
like now, fairly clean.

00:08:31.506 --> 00:08:34.895
Now in the enumerations area,
we've also now taking advantage

00:08:34.895 --> 00:08:35.895
of string enumerations.

00:08:35.895 --> 00:08:37.895
Swift supports string-valued
enumerations

00:08:38.206 --> 00:08:41.275
and in many cases Cocoa APIs
expose groups of strings

00:08:41.275 --> 00:08:44.526
as opened or closed sets of
APIs that we use in our APIs.

00:08:44.526 --> 00:08:47.756
And let's look at an example
using string transforms.

00:08:48.946 --> 00:08:51.476
In Swift 2 we had a bunch
of global constants.

00:08:52.026 --> 00:08:54.486
NSStringTransformLatinToGreek
and so on.

00:08:54.626 --> 00:08:57.066
And then we have an API,
stringByApplyingTransform

00:08:57.066 --> 00:08:59.356
that took those strings
as its first argument.

00:08:59.876 --> 00:09:02.116
In Swift 3 we've actually
added a new type called

00:09:02.116 --> 00:09:05.526
StringTransform and then an
extension we declared various

00:09:05.526 --> 00:09:07.766
values for that,
such as LatinToGreek.

00:09:08.056 --> 00:09:10.916
And the API that takes
that is applyingTransform,

00:09:10.916 --> 00:09:15.456
where the first argument is now
an official StringTransform.

00:09:15.586 --> 00:09:19.256
So the string argument has
now become StringTransform,

00:09:19.256 --> 00:09:20.586
a little more type safe.

00:09:21.126 --> 00:09:24.876
Now note that this is an
open-ended enumeration

00:09:25.066 --> 00:09:26.866
in that you can declare
your own values.

00:09:27.406 --> 00:09:31.906
Let me show you how you do that.

00:09:32.086 --> 00:09:33.406
You can go ahead
and add an extension

00:09:33.406 --> 00:09:35.866
to StringTransform yourself
and define your own type.

00:09:36.216 --> 00:09:39.896
Now the values here are the
values ICU Library accepts

00:09:39.896 --> 00:09:41.266
for doing transforms.

00:09:41.266 --> 00:09:44.496
So you can use any valid
ID that ICU provides.

00:09:44.856 --> 00:09:47.316
It turns out Any to
Publishing is one ICU has

00:09:47.316 --> 00:09:49.456
that we don't expose
on our APIs.

00:09:49.456 --> 00:09:52.826
So again, go ahead and define
your own publishing transform

00:09:53.106 --> 00:09:55.706
and pass it to the APIs just
as if it's a built-in one.

00:09:57.916 --> 00:10:00.686
And string enumerations are
also available in Objective-C

00:10:00.686 --> 00:10:03.916
by using of these two macros
for open or close-ended sets.

00:10:04.376 --> 00:10:06.796
And here's the way the string
transform declaration was

00:10:06.796 --> 00:10:07.456
in fact added.

00:10:07.456 --> 00:10:09.046
In 10.11, this is what we had.

00:10:09.046 --> 00:10:11.436
And in 10.12, we have a
new type string transform

00:10:11.436 --> 00:10:16.096
which is decorated as NS
Extensible String Enum.

00:10:17.066 --> 00:10:19.776
And we're also taking
advantage of Swift's ability

00:10:19.776 --> 00:10:24.246
to nest declarations related
about a type, into that type.

00:10:24.726 --> 00:10:26.996
An example here from NSData.

00:10:26.996 --> 00:10:29.756
We had a option set,
NSDataWritingOptions

00:10:30.266 --> 00:10:34.396
and class NSData with an API
writeToURL that used that value.

00:10:34.896 --> 00:10:37.926
In Swift 3, this comes
across as class NSData

00:10:38.266 --> 00:10:40.796
with a nested WritingOptions,
as you can see here.

00:10:42.056 --> 00:10:45.346
And the API that uses
it actually just refers

00:10:45.346 --> 00:10:46.226
to WritingOptions, which is

00:10:46.226 --> 00:10:48.226
of course much more
cleaner, much better scoped.

00:10:48.816 --> 00:10:51.056
Now unrelated to
this nesting change,

00:10:51.056 --> 00:10:52.196
you'll note a few more things.

00:10:53.436 --> 00:10:55.766
So that's the change
in the type.

00:10:56.056 --> 00:11:00.426
You'll also you might note that
we now provide default values

00:11:00.426 --> 00:11:03.636
of an empty set most cases
where we pass options in,

00:11:03.636 --> 00:11:04.716
which means you actually
don't have

00:11:04.776 --> 00:11:06.366
to pass the options
argument anymore.

00:11:07.116 --> 00:11:10.006
You might've also noticed that
NSURL has become URL here.

00:11:10.066 --> 00:11:11.716
You might've already heard
about this but we'll talk

00:11:11.716 --> 00:11:13.386
about this more later
in the talk.

00:11:15.016 --> 00:11:17.296
Now my last topic
before I escape the stage

00:11:17.296 --> 00:11:20.396
for now is noescape.

00:11:20.896 --> 00:11:24.136
Okay. So noescape indicates

00:11:24.186 --> 00:11:27.496
that a closure's execution will
not escape the function call.

00:11:28.006 --> 00:11:28.966
What do I mean by that?

00:11:29.076 --> 00:11:29.656
Here's a method

00:11:29.656 --> 00:11:31.976
from NSCollection view
performBatchUpdates.

00:11:32.186 --> 00:11:33.836
It takes two closure arguments.

00:11:34.856 --> 00:11:37.466
You'll note that the first
one is marked with noescape.

00:11:37.526 --> 00:11:38.756
This means that the execution

00:11:38.756 --> 00:11:42.596
of this closure will
finish before this API

00:11:42.796 --> 00:11:44.256
performBatchUpdates returns.

00:11:44.566 --> 00:11:46.906
The second argument is
not labeled noescape,

00:11:46.936 --> 00:11:50.866
which means that the execution
of this closure might happen

00:11:51.166 --> 00:11:52.606
after this function returns.

00:11:52.826 --> 00:11:54.626
So it's a good hint to
you and so a good hint

00:11:54.626 --> 00:11:55.646
for the compiler as well.

00:11:56.006 --> 00:11:58.096
This facility is also
available in Objective-C

00:11:58.316 --> 00:12:00.706
where we can decorate
closures with NS NOESCAPE

00:12:00.796 --> 00:12:01.686
to get the same effect.

00:12:02.616 --> 00:12:05.506
So that's it for our quick
overview of general API changes.

00:12:05.826 --> 00:12:07.466
Now note in the seed you have,

00:12:07.746 --> 00:12:09.296
we haven't done everything
we want to do yet,

00:12:09.296 --> 00:12:11.636
so there will be some
string enumeration changes,

00:12:11.636 --> 00:12:14.026
class property changes coming
in other seeds as well.

00:12:14.396 --> 00:12:16.646
So we're going to
apply to more APIs.

00:12:20.046 --> 00:12:22.026
So with that, let's talk
about AppKit and I'm going

00:12:22.026 --> 00:12:24.936
to invite Raleigh Ledet
on stage to kick that off.

00:12:25.206 --> 00:12:25.456
Thank you.

00:12:26.516 --> 00:12:30.036
[ Applause ]

00:12:30.536 --> 00:12:31.046
>> Thank you, Ali.

00:12:31.046 --> 00:12:32.226
Good morning, everyone.

00:12:33.336 --> 00:12:36.326
As you can see, we've been very
busy this past year in AppKit.

00:12:36.826 --> 00:12:40.076
So let's dive right on in and
talk about window snapping.

00:12:41.526 --> 00:12:45.116
So when you're dragging
a window in macOS Sierra,

00:12:45.266 --> 00:12:47.556
as you bump up against the
edges will stick at the edges

00:12:47.746 --> 00:12:49.786
and as you get along the
top edge of another window

00:12:49.786 --> 00:12:51.046
and even during resizing.

00:12:51.406 --> 00:12:55.046
So it's now much easier for
you to align windows together

00:12:55.216 --> 00:12:57.926
and resize them just the
way you really want to do.

00:12:58.516 --> 00:13:01.616
And we spent a lot of effort
here in providing heuristics

00:13:01.616 --> 00:13:03.906
to make sure that we only
provide the snapping behavior

00:13:04.276 --> 00:13:06.006
when that is what
you are trying to do

00:13:06.006 --> 00:13:07.366
with your windows
in the first place.

00:13:08.366 --> 00:13:10.956
The way you get snapping
behavior in your application is

00:13:10.956 --> 00:13:14.036
to just let the system do the
dragging of the window for you.

00:13:14.916 --> 00:13:16.746
If you track the mouse yourself

00:13:16.746 --> 00:13:19.156
and manually position
the window, you're going

00:13:19.156 --> 00:13:21.816
to bypass window snapping and
we will put the window exactly

00:13:21.816 --> 00:13:24.596
where you ask us to put it, just
as we have in previous releases.

00:13:25.156 --> 00:13:29.416
As you've seen in the keynote,
we now have window tabbing.

00:13:29.416 --> 00:13:34.006
This is an example of TextEdit
with three document tabs open.

00:13:34.606 --> 00:13:37.366
And the thing about
window tabbing is they are

00:13:37.366 --> 00:13:38.296
just windows.

00:13:38.876 --> 00:13:42.916
So this example of TextEdit with
three tabs is actually backed

00:13:42.976 --> 00:13:44.676
by three different NS windows.

00:13:46.146 --> 00:13:50.586
So what we do is every one of
these windows, as long as one

00:13:50.586 --> 00:13:52.386
of the tabs is visible,
is considered visible.

00:13:52.996 --> 00:13:55.306
So if you check the
NSWindow's .visible property,

00:13:55.366 --> 00:13:56.586
it's going to return true.

00:13:57.446 --> 00:13:59.906
But only the visible tab
is actually being rendered

00:13:59.906 --> 00:14:00.636
to the screen.

00:14:00.866 --> 00:14:03.666
We hide all the other windows
at the windows server level

00:14:04.056 --> 00:14:05.316
so they aren't rendered
and aren't taking

00:14:05.316 --> 00:14:06.216
up resources that way.

00:14:06.816 --> 00:14:10.486
And we handle this
all automatically.

00:14:11.436 --> 00:14:13.726
So how do you add a
new tab to your window?

00:14:14.736 --> 00:14:17.076
You create a new window
and you just order it front

00:14:17.076 --> 00:14:19.886
and we will go ahead and create
a tab appropriately for you

00:14:20.196 --> 00:14:21.676
and place it in the window.

00:14:22.216 --> 00:14:25.546
If you want to remove a tab,
you order your window out

00:14:25.876 --> 00:14:27.406
and we'll go ahead
and remove the tab.

00:14:27.666 --> 00:14:29.006
This is all done automatically.

00:14:29.496 --> 00:14:33.086
Now if the user resizes the
window, we're only going

00:14:33.086 --> 00:14:35.126
to resize the window
associated with the active tab.

00:14:36.236 --> 00:14:38.046
We don't want to take
the processing time

00:14:38.046 --> 00:14:39.666
to manage the other windows

00:14:39.666 --> 00:14:41.276
when the users might
not switch to them.

00:14:41.596 --> 00:14:43.826
But when the user does switch
to one of the other tabs,

00:14:43.876 --> 00:14:45.686
at that point AppKit goes ahead

00:14:45.686 --> 00:14:48.616
and resizes the windows
appropriately, re-renders it,

00:14:48.836 --> 00:14:50.806
and then changes the
hidden properties

00:14:50.806 --> 00:14:51.956
at the window server level,

00:14:52.016 --> 00:14:54.566
and so the user gets
the seamless experience

00:14:54.566 --> 00:14:57.946
of one window with multiple tabs
even though behind the scenes

00:14:57.946 --> 00:14:59.766
we're just dealing
with three windows.

00:15:02.286 --> 00:15:05.236
So I want to cover some
areas of what you need to do

00:15:05.236 --> 00:15:07.206
in your applications
to adopt tabs

00:15:07.486 --> 00:15:09.706
into your applications
depending on what style

00:15:09.706 --> 00:15:10.626
of application you have.

00:15:11.216 --> 00:15:14.216
If you have for example an
NSDocument based application

00:15:14.656 --> 00:15:17.316
or a non-NSDocument
based application.

00:15:17.746 --> 00:15:18.646
What you might want to do

00:15:18.646 --> 00:15:21.026
if you already have an
existing tab implementation,

00:15:21.336 --> 00:15:24.886
and I'll round the section out
with some API that you can use

00:15:25.096 --> 00:15:27.276
to customize tabs
in your application.

00:15:28.366 --> 00:15:30.406
If you're in an NSDocument
based app,

00:15:30.526 --> 00:15:31.466
there's nothing for you to do.

00:15:31.516 --> 00:15:34.966
This is fully automatic and,
in fact, in TextEdit here,

00:15:34.966 --> 00:15:38.206
we made exactly zero lines
of code changes in TextEdit.

00:15:38.446 --> 00:15:41.426
It fully supports tabs and it
just works right out the box.

00:15:42.596 --> 00:15:46.106
If you're a non-NSDocument
based app, it's mostly automatic

00:15:46.106 --> 00:15:48.366
but what you'll probably
need to do is enable

00:15:48.366 --> 00:15:51.776
to New Tab button
in your application.

00:15:52.236 --> 00:15:54.816
The New Tab button is
this plus button over here

00:15:55.056 --> 00:15:56.216
to the right of all the tabs.

00:15:57.546 --> 00:15:59.096
To enable that button, you need

00:15:59.096 --> 00:16:02.266
to implement this
newWindowForTab NSResponder

00:16:02.266 --> 00:16:05.856
override in your NSWindow
subclass or somewhere higher

00:16:05.856 --> 00:16:06.746
up the responder chain.

00:16:06.816 --> 00:16:08.786
For example, your
NSWindow delegate

00:16:09.136 --> 00:16:12.176
or your NSWindow controller
or your NSWindow document.

00:16:12.306 --> 00:16:14.986
If you implement this override
in any one of those places,

00:16:14.986 --> 00:16:17.066
AppKit will see it
and will go ahead

00:16:17.066 --> 00:16:19.506
and enable the New Tab
button for you automatically.

00:16:20.146 --> 00:16:24.756
If you have your own
existing tab implementation,

00:16:25.046 --> 00:16:25.736
then you probably want

00:16:25.736 --> 00:16:28.746
to disable AppKit's automatic
window tabbing behavior.

00:16:29.626 --> 00:16:30.986
There's this class property

00:16:30.986 --> 00:16:33.296
on NSWindow
allowsAutomaticWindowTabbing.

00:16:34.196 --> 00:16:36.556
This is a class property
early in the bring-up

00:16:36.556 --> 00:16:38.106
of your application
called NSWindow.

00:16:38.106 --> 00:16:42.026
allowsAutomaticWindowTabbing
equal false

00:16:42.196 --> 00:16:44.586
and this will turn off
AppKit's tabbing behavior

00:16:44.896 --> 00:16:48.006
and then you can continue using
your own tabbing implementation.

00:16:48.416 --> 00:16:50.646
It's important that you call
this early in the bring-up

00:16:50.646 --> 00:16:55.116
of your application before you
start ordering windows front.

00:16:56.126 --> 00:16:57.576
That's all you really need to do

00:16:57.576 --> 00:16:59.666
to adopt tabs in
your application.

00:16:59.666 --> 00:17:00.776
It works mostly automatically.

00:17:00.776 --> 00:17:03.516
But here's some of the API that
you can use to customize things.

00:17:04.146 --> 00:17:07.205
First off, the user can
define some of the behavior

00:17:07.205 --> 00:17:10.086
on how they want tabbing
to work on their system

00:17:10.215 --> 00:17:11.915
and they can do this in
the System Preferences

00:17:11.915 --> 00:17:13.906
and you can find out what
the user preference is

00:17:13.935 --> 00:17:17.826
by the class property user
tabbing preferences on NSWindow

00:17:17.886 --> 00:17:21.445
and they can set it to manual,
always or to only do tabbing

00:17:21.445 --> 00:17:23.165
when they're in full screen.

00:17:25.056 --> 00:17:27.146
The rest of these properties
and functions from here

00:17:27.146 --> 00:17:29.726
on out I'm going to discuss
are instance properties

00:17:29.726 --> 00:17:30.896
and functions on NSWindow.

00:17:31.626 --> 00:17:33.836
So once you have an
instance of an NSWindow,

00:17:34.066 --> 00:17:35.346
you can set it to tabbing mode.

00:17:35.776 --> 00:17:37.666
By default, this tabbing
mode is automatic,

00:17:37.666 --> 00:17:38.506
which means we're just going

00:17:38.506 --> 00:17:40.546
to follow what the user
tabbing preferences are,

00:17:40.546 --> 00:17:43.396
but you can set it to
preferred or disallowed,

00:17:43.396 --> 00:17:44.996
depending on your window
type and your needs.

00:17:45.876 --> 00:17:50.516
When we group windows together
into a set of tabs, we only want

00:17:50.516 --> 00:17:52.796
to group windows that are
similar and the way we do

00:17:52.796 --> 00:17:54.676
that is by looking at
the tabbing identifier.

00:17:54.956 --> 00:17:57.266
So windows that have the same
tabbing identifier can be

00:17:57.266 --> 00:17:58.596
grouped together into tabs.

00:17:59.296 --> 00:18:01.926
By default, AppKit will use
a heuristic and try and come

00:18:01.926 --> 00:18:03.816
up with a tabbing
identifier on your behalf.

00:18:04.106 --> 00:18:07.436
We look at things such as
the windows subclass name,

00:18:07.806 --> 00:18:11.046
the properties of the
window, the document,

00:18:11.046 --> 00:18:13.336
and various few other
properties to try and come

00:18:13.336 --> 00:18:15.906
up with the appropriate
tabbing identifier.

00:18:16.516 --> 00:18:17.576
This works really well,

00:18:17.986 --> 00:18:20.606
but if it doesn't quite work
well enough for your application

00:18:20.606 --> 00:18:23.696
or if you want to have
more control over it,

00:18:23.696 --> 00:18:25.596
you can set the tabbing
identifier manually

00:18:25.826 --> 00:18:27.346
and AppKit will respect that.

00:18:28.556 --> 00:18:31.086
You can find out what are the
windows are grouped together

00:18:31.086 --> 00:18:34.386
with some instance of a
window together in tabs

00:18:34.386 --> 00:18:35.896
by asking for the tab windows.

00:18:36.506 --> 00:18:38.586
Note this returns
an optional array.

00:18:38.976 --> 00:18:41.326
It can return nil and
it will return nil

00:18:41.326 --> 00:18:42.736
if the tab bar isn't even shown

00:18:42.736 --> 00:18:44.946
and there are no tabs
associated at all.

00:18:46.106 --> 00:18:50.516
And you can manually add
another tab window together

00:18:50.516 --> 00:18:51.116
to the group.

00:18:51.236 --> 00:18:53.836
Since these are just windows
that explains the API name

00:18:53.836 --> 00:18:56.746
where you add a tab window,
instead of adding a tab itself,

00:18:56.746 --> 00:18:58.946
you add the tab window
and you order it using

00:18:58.946 --> 00:19:01.456
NSWindowOrderingMode and
that will order the tab

00:19:01.916 --> 00:19:03.316
in relation to the other tabs.

00:19:05.446 --> 00:19:08.686
AppKit will add a few
new items to your menu.

00:19:09.136 --> 00:19:12.306
Namely in the windows menu,
we add some items to go ahead

00:19:12.306 --> 00:19:15.016
and help the user
navigate the tabs,

00:19:15.196 --> 00:19:17.216
such as selecting the
next or previous tab.

00:19:17.696 --> 00:19:20.876
These are just IB actions on
NSWindow and you can wire them

00:19:20.876 --> 00:19:23.266
up to your own user
interface items as well.

00:19:23.266 --> 00:19:25.396
For example, you might
want to have a button

00:19:25.396 --> 00:19:26.576
that toggles the tab bar.

00:19:26.876 --> 00:19:28.866
You just wire that
button up to the window,

00:19:30.196 --> 00:19:31.986
toggleTabBar IBAction

00:19:32.556 --> 00:19:35.766
and NSWindow will handle
toggling the tab bar for you.

00:19:36.896 --> 00:19:39.606
So that's everything about
window snapping and tabbing.

00:19:40.196 --> 00:19:42.926
Let's move ahead and talk
about right-to-left support.

00:19:42.926 --> 00:19:44.656
We've done a lot
of work in AppKit

00:19:44.656 --> 00:19:47.156
to enhance our already
existing right-to-left support.

00:19:47.766 --> 00:19:50.956
In the screenshot you can
see here's TextEdit running

00:19:50.956 --> 00:19:51.516
in Arabic.

00:19:51.956 --> 00:19:54.166
The title bar is flipped.

00:19:54.386 --> 00:19:56.336
The scrollers are
flipped to the other side.

00:19:56.336 --> 00:19:58.156
Even the new tab button is
flipped to the other side.

00:19:58.416 --> 00:20:00.016
And all the little attributes

00:20:00.016 --> 00:20:02.176
and the various title bar
buttons are all flipped

00:20:02.176 --> 00:20:04.586
appropriately as a
right-to-left user would expect.

00:20:06.046 --> 00:20:08.146
I want to talk about
right-to-left support

00:20:08.146 --> 00:20:09.166
at three different levels.

00:20:09.476 --> 00:20:10.926
What's going on at
the system level,

00:20:10.926 --> 00:20:13.166
where the user sets
their localization

00:20:13.166 --> 00:20:14.286
in the system preference pane,

00:20:15.196 --> 00:20:17.266
how that impacts your
application, and what goes

00:20:17.266 --> 00:20:18.486
on in your application depending

00:20:18.486 --> 00:20:20.306
on the localizations
that you support.

00:20:20.836 --> 00:20:22.536
And then finally down
to the content level,

00:20:22.536 --> 00:20:23.916
which is at the NSView level

00:20:24.256 --> 00:20:26.666
where you can override
things further if needed

00:20:26.666 --> 00:20:28.326
with the user interface
layout direction.

00:20:28.906 --> 00:20:30.566
And then I'm going
wrap this whole section

00:20:30.566 --> 00:20:33.696
up with a really nice
development tip to help you work

00:20:34.006 --> 00:20:36.376
on right-to-left support
in your application.

00:20:37.576 --> 00:20:39.886
To start off with, let's
talk about the system level.

00:20:41.206 --> 00:20:42.916
The key here is consistency.

00:20:43.156 --> 00:20:45.356
We want to have a
consistent appearance

00:20:45.356 --> 00:20:47.466
to the user who's running
in a right-to-left system.

00:20:47.986 --> 00:20:51.056
So regardless of what
localization you may support

00:20:51.056 --> 00:20:53.866
in your application,
we want all menu bars

00:20:54.136 --> 00:20:57.746
on a right-to-left system
to start off with the apple

00:20:57.746 --> 00:21:00.276
over here on the right
side followed with the rest

00:21:00.276 --> 00:21:03.716
of the menu items
and this likewise

00:21:03.716 --> 00:21:05.076
for the windows title bar.

00:21:06.076 --> 00:21:07.556
So the traffic lights
are going to be flipped

00:21:07.556 --> 00:21:09.126
over to the other side
and anything that's not

00:21:09.126 --> 00:21:10.446
in the content area
is going to be flipped

00:21:10.446 --> 00:21:11.336
over to the other side,

00:21:11.746 --> 00:21:14.076
regardless of what localization
you have in your application,

00:21:14.296 --> 00:21:16.526
providing a consistent
experience to the user.

00:21:17.376 --> 00:21:18.896
Now we can't automatically
do this

00:21:18.896 --> 00:21:22.166
down into the application
level, because we don't want

00:21:22.166 --> 00:21:23.006
to break any assumptions

00:21:23.006 --> 00:21:24.356
that your application
might be having.

00:21:24.846 --> 00:21:28.616
So it's highly recommended that
you add right-to-left support

00:21:28.616 --> 00:21:31.996
in your application, add Hebrew
and Arabic localizations.

00:21:32.646 --> 00:21:35.896
And once you have those
localizations in place

00:21:36.316 --> 00:21:37.826
at an application level,

00:21:37.826 --> 00:21:40.196
all your scroll views will
automatically flip the vertical

00:21:40.196 --> 00:21:41.196
scroller and rulers

00:21:41.456 --> 00:21:43.736
and NSBrowser will automatically
be flipped as well.

00:21:44.096 --> 00:21:47.116
At this level, again we want
consistency so regardless

00:21:47.116 --> 00:21:50.816
of what content views user
interface layout direction may

00:21:50.816 --> 00:21:53.576
be, we want the scroll
bars to always be

00:21:53.576 --> 00:21:55.686
on the same side
for consistency.

00:21:55.686 --> 00:21:58.766
Moving down to the
content level,

00:21:59.286 --> 00:22:01.366
by default the user interface
layout direction is going

00:22:01.366 --> 00:22:04.116
to match what your
application is set to.

00:22:05.416 --> 00:22:08.616
This is exactly what you
want for almost all cases

00:22:08.616 --> 00:22:10.986
but there are a few exceptions,
namely if you have something

00:22:10.986 --> 00:22:15.126
like media controls or spatial
controls or time controls

00:22:15.126 --> 00:22:19.696
where it is always laid out
the same way left to right

00:22:19.696 --> 00:22:22.396
for both left-to-right users
and right-to-left users.

00:22:23.086 --> 00:22:25.836
So you can modify the user
interface layout direction.

00:22:26.556 --> 00:22:29.016
And the following controls
in AppKit support that.

00:22:29.406 --> 00:22:31.986
So auto layout will
not in this seed

00:22:31.986 --> 00:22:37.516
but in the upcoming seed two
we'll start using the parent

00:22:37.686 --> 00:22:44.776
container to determine what is
the trailing and leading edges.

00:22:46.036 --> 00:22:47.656
And already in the
seed, table view

00:22:47.656 --> 00:22:50.246
and outline view will flip
their columns appropriately.

00:22:50.246 --> 00:22:54.746
NSPageController switches its
animations and the list goes on.

00:22:54.746 --> 00:22:57.996
We have a lot of support in
AppKit for right-to-left.

00:22:57.996 --> 00:23:00.016
Let AppKit do the heavy
lifting where you can

00:23:00.476 --> 00:23:04.486
and provide your right-to-left
users a great experience.

00:23:05.086 --> 00:23:08.596
I promised you a
development tip.

00:23:08.596 --> 00:23:10.076
I've been using this
tip all year.

00:23:10.156 --> 00:23:11.876
I found it incredibly useful.

00:23:12.246 --> 00:23:14.786
In Xcode, you can modify
the scheme of your projects

00:23:14.986 --> 00:23:17.606
in the Options section, change
your application language

00:23:17.606 --> 00:23:19.046
to right-to-left pseudolanguage.

00:23:19.626 --> 00:23:21.526
This allows you to
run your application

00:23:21.526 --> 00:23:24.086
in your development language,
and for me that's English,

00:23:24.436 --> 00:23:26.216
and so you can see
TextEdit running in English,

00:23:26.706 --> 00:23:30.916
but it is all using
right-to-left flipped controls

00:23:30.916 --> 00:23:31.116
in it.

00:23:31.336 --> 00:23:34.326
So the window title
bar is flipped.

00:23:34.576 --> 00:23:36.386
The scroller for the
scroll view is flipped

00:23:36.486 --> 00:23:39.386
and you can see all the little
subitems and all the buttons

00:23:39.386 --> 00:23:40.356
of the title bar are flipped.

00:23:40.536 --> 00:23:44.066
So it's a much easier
way for you to work

00:23:44.066 --> 00:23:44.936
on right-to-left support

00:23:44.936 --> 00:23:46.646
and make sure everything
is working properly

00:23:46.886 --> 00:23:47.856
in your native language.

00:23:48.596 --> 00:23:52.076
Now I've just covered what
we're doing in AppKit here.

00:23:53.126 --> 00:23:55.966
There's a lot more to
talk about in the What New

00:23:55.966 --> 00:23:58.626
in International User Interfaces
talk in Nob Hill on Friday

00:23:58.626 --> 00:24:01.326
at 9:00 a.m. They cover
more things on the desktop

00:24:01.326 --> 00:24:06.096
such as WebKit, text
layout, asset management,

00:24:06.096 --> 00:24:09.056
and they also cover
right-to-left support in iOS.

00:24:09.056 --> 00:24:11.176
So I highly recommend that you
check out this talk as well.

00:24:14.176 --> 00:24:15.936
Let's now talk about
promise drags.

00:24:16.296 --> 00:24:18.336
If you're not familiar,
a promise drag is

00:24:18.336 --> 00:24:21.376
when the user is dragging a
file from your application

00:24:22.306 --> 00:24:25.826
but you don't have this
file on disc anywhere yet.

00:24:26.216 --> 00:24:27.436
But you're just going to promise

00:24:27.436 --> 00:24:29.496
that you'll write it wherever
the user wants to drop it.

00:24:29.966 --> 00:24:31.086
That's a file promise drag.

00:24:31.086 --> 00:24:32.756
We've supported file
promise drags

00:24:33.186 --> 00:24:34.616
in OS X since the beginning.

00:24:35.876 --> 00:24:38.746
In macOS Sierra, we're
updating our file promise drag

00:24:38.806 --> 00:24:41.976
to be more modern with the
new NSFilePromiseProvider

00:24:41.976 --> 00:24:44.226
and NSFilePromiseReciever
objects.

00:24:45.006 --> 00:24:47.456
Now these objects allow
file promise drags

00:24:47.456 --> 00:24:48.826
to support drag flocking.

00:24:49.256 --> 00:24:50.596
If you're not familiar
with drag flocking,

00:24:50.596 --> 00:24:52.136
it's when you're
dragging number of items

00:24:52.386 --> 00:24:54.466
and they can change
their formation mid-drag,

00:24:54.466 --> 00:24:56.606
depending on the
destination application

00:24:56.606 --> 00:24:57.466
and what's going on there.

00:24:59.376 --> 00:25:02.316
So file promise drags with
these two new classes support

00:25:02.486 --> 00:25:03.216
drag flocking.

00:25:03.286 --> 00:25:04.246
They're UTI based.

00:25:04.596 --> 00:25:07.086
They're completely pasteboard
writer and reader compliant,

00:25:07.086 --> 00:25:10.916
which means you can use the
item-based API on NSPasteboard

00:25:10.916 --> 00:25:12.476
to work with these objects,

00:25:13.366 --> 00:25:15.096
and they're file
coordinated when possible.

00:25:15.096 --> 00:25:16.976
So you don't need to worry
about file coordination.

00:25:16.976 --> 00:25:19.366
We'll automatically wrap
up a file coordinated read

00:25:19.366 --> 00:25:21.526
or write on your behalf.

00:25:21.776 --> 00:25:23.376
And they're backwards
compatible.

00:25:24.226 --> 00:25:25.036
They're backwards compatible

00:25:25.036 --> 00:25:27.696
with the non-item
based file promise API.

00:25:28.426 --> 00:25:30.846
And what this means is you only
need to worry about one API.

00:25:31.276 --> 00:25:33.776
If you implement an
NSFilePromiseProvider,

00:25:33.826 --> 00:25:35.376
you can now provide
a file promise

00:25:35.646 --> 00:25:38.996
to anybody that's using the
new NSFilePromiseReciever API

00:25:39.516 --> 00:25:42.206
or somebody that an existing
application that's using the

00:25:42.206 --> 00:25:43.286
non-item-based API.

00:25:43.736 --> 00:25:45.686
They will still be able to
accept your promised file

00:25:46.106 --> 00:25:49.336
and likewise with
NSFilePromiseReciever.

00:25:49.386 --> 00:25:51.356
You will be able to
accept file promises

00:25:51.386 --> 00:25:54.396
from anybody using an
NSFilePromiseProvider

00:25:54.586 --> 00:25:56.926
or using the non-item-based
API as well.

00:25:57.906 --> 00:26:03.646
So you want to provide a
file promise in your drag,

00:26:03.646 --> 00:26:06.016
so as the user starts to drag,
you need to create your promises

00:26:06.306 --> 00:26:08.246
and you do that by
creating an instance

00:26:08.246 --> 00:26:09.746
of NSFilePromiseProvider.

00:26:10.096 --> 00:26:13.306
You want to create an instance
for each one of the files

00:26:13.306 --> 00:26:15.116
that you are going to
promise and you need

00:26:15.116 --> 00:26:17.266
to provide an
NSFilePromiseProvider delegate.

00:26:17.706 --> 00:26:19.696
This delegate is what's
going to do the heavy lifting

00:26:19.696 --> 00:26:21.226
of writing the files to disc.

00:26:22.066 --> 00:26:24.646
At some point the destination
is going to call in this promise

00:26:24.776 --> 00:26:26.846
and you'll be asked to
provide the file name

00:26:26.846 --> 00:26:27.676
for the destination.

00:26:27.676 --> 00:26:29.386
Now you know where the
destination is, you can figure

00:26:29.386 --> 00:26:31.836
out the appropriate file name,
but do not write the file

00:26:31.836 --> 00:26:33.376
at this point because
it's not wrapped

00:26:33.376 --> 00:26:35.736
up with file coordination
yet and we're still figuring

00:26:35.736 --> 00:26:37.636
out some of the remaining
items of the drag.

00:26:38.316 --> 00:26:39.256
When the drag is completed

00:26:39.256 --> 00:26:40.826
and we know all the
information we need to know,

00:26:40.826 --> 00:26:43.386
we'll call your delegate back
and ask you to write the promise

00:26:43.386 --> 00:26:46.436
to URL and provide a
completion handler.

00:26:46.436 --> 00:26:50.606
At this point, it's all wrapped
up with file coordination write.

00:26:51.046 --> 00:26:53.526
So just write the file
out to the supplied URL

00:26:53.526 --> 00:26:56.056
and call the completion handler
to let file coordination know

00:26:56.056 --> 00:26:56.906
that you're finished writing.

00:26:58.136 --> 00:27:00.606
If you want to receive
a file promise,

00:27:00.916 --> 00:27:02.806
the first thing you need to
do is register with the view

00:27:02.806 --> 00:27:04.736
that you want to allow
the job to occur on.

00:27:04.736 --> 00:27:07.746
And this is normally done with
view.register forDraggedTypes

00:27:08.016 --> 00:27:08.856
and the drag types you need

00:27:08.856 --> 00:27:11.366
to add are the
NSFilePromiseReceiver.

00:27:11.366 --> 00:27:12.526
readableDrappedTypes.

00:27:12.636 --> 00:27:13.996
It's fairly straightforward.

00:27:15.156 --> 00:27:17.926
Now once the user is dragging
a file promise over that view,

00:27:17.926 --> 00:27:19.786
you'll start getting dragging
messages and you'll want

00:27:19.786 --> 00:27:21.376
to get the promise objects.

00:27:22.346 --> 00:27:26.186
So you can use the pasteboard
item-based API and just ask it

00:27:26.186 --> 00:27:29.626
to read the objects forClasses
NSFilePromiseReceiver.self

00:27:29.626 --> 00:27:32.386
and you'll get an array of
NSFilePromiseReceiver objects.

00:27:33.436 --> 00:27:35.456
Once you have an
NSFilePromiseReceiver object,

00:27:35.806 --> 00:27:37.006
you can call in the promise

00:27:37.236 --> 00:27:40.316
by calling receivePromisedFiles
atDestination options

00:27:40.406 --> 00:27:41.396
operationQueue reader.

00:27:41.396 --> 00:27:44.426
And it will return pretty
quickly from this function

00:27:44.626 --> 00:27:46.496
and your reader block will
not have been called yet.

00:27:46.496 --> 00:27:47.736
We're going to call
that back later.

00:27:48.976 --> 00:27:51.036
Once the source file has
finished writing all the

00:27:51.036 --> 00:27:54.466
promises, now we go ahead and
we call your reader block back

00:27:54.466 --> 00:27:56.356
on the operation queue
that you specified.

00:27:56.986 --> 00:28:01.786
Now it's important that you do
not specify NSMainOperationQueue

00:28:01.786 --> 00:28:03.696
for the operation queue
or else you're going

00:28:03.696 --> 00:28:07.596
to block your application while
waiting for the source process

00:28:07.696 --> 00:28:08.706
to finish writing the files.

00:28:08.896 --> 00:28:10.626
And this can take some
time and you don't want

00:28:10.626 --> 00:28:12.436
to block your application
during that whole time.

00:28:14.916 --> 00:28:18.256
And that's all there is to
do with file promise drags.

00:28:18.296 --> 00:28:22.356
It's much simpler API to use
and it works with drag flocking

00:28:22.356 --> 00:28:24.776
and supports the item-based
API with pasteboard.

00:28:25.556 --> 00:28:27.876
So let's move on and talk
about some improvements we made

00:28:27.876 --> 00:28:29.256
to our various container views.

00:28:29.576 --> 00:28:30.926
We'll start off with
collection view.

00:28:31.896 --> 00:28:34.796
With collection view, previously
when you would scroll,

00:28:35.266 --> 00:28:38.526
your contents would scroll
on top of any background view

00:28:38.526 --> 00:28:39.346
that you might've had.

00:28:39.686 --> 00:28:41.476
Well, now you can tell the
background view to scroll

00:28:41.476 --> 00:28:43.276
with your contexts by
setting backgroundViews

00:28:43.276 --> 00:28:45.936
ScrollsWithContent to true
and they scroll together.

00:28:47.126 --> 00:28:48.056
We also have support

00:28:48.056 --> 00:28:50.276
for optional floating
headers and footers.

00:28:50.276 --> 00:28:52.796
So you can see the documents
header here becomes floating

00:28:52.796 --> 00:28:54.296
and the content scrolls
underneath it.

00:28:56.036 --> 00:28:58.826
This is real easy to do with the
NSCollectionView float layout.

00:28:59.106 --> 00:29:01.256
Just set the
sectionHeadersPinToVisible true

00:29:01.256 --> 00:29:04.206
or the
sectionFootersPinToVisibleBounds

00:29:04.206 --> 00:29:05.876
true if you want
the footers to float

00:29:06.166 --> 00:29:07.796
and NSCollectionView
will then take care

00:29:07.796 --> 00:29:09.996
of doing everything
appropriately on your behalf.

00:29:11.236 --> 00:29:13.526
You can also optionally
collapse any section

00:29:13.916 --> 00:29:16.176
into a single horizontally
scrollable row,

00:29:16.176 --> 00:29:19.106
as you can see here, and you get
this nice little carousel effect

00:29:19.106 --> 00:29:20.416
whenever you scroll
horizontally.

00:29:21.346 --> 00:29:25.816
This is real easy to do with the
toggleSectionCollapse IBAction

00:29:25.906 --> 00:29:27.116
on NSCollectionView.

00:29:27.726 --> 00:29:31.976
Now the sender of this message
needs to be a view that is

00:29:31.976 --> 00:29:34.206
at your section header
or a descendent

00:29:34.206 --> 00:29:35.246
of your section header view

00:29:35.516 --> 00:29:38.616
and that is how NSCollectionView
can determine exactly

00:29:38.616 --> 00:29:41.226
which section needs to toggle
the collapse state for.

00:29:42.556 --> 00:29:47.246
Since you have your button in
your header view or descendent,

00:29:47.676 --> 00:29:49.466
you should have your
section header

00:29:49.616 --> 00:29:51.056
implement NSCollectionView

00:29:51.056 --> 00:29:53.956
SectionHeaderView protocol
and that's just to wire

00:29:53.956 --> 00:29:56.646
up your button to the
sectionCollapseButton outlet.

00:29:57.206 --> 00:29:59.596
Then NSCollectionView will now
be able to find your button

00:29:59.596 --> 00:30:01.056
and automatically
hide and show it,

00:30:01.276 --> 00:30:05.206
depending on if there
is enough data inside

00:30:05.206 --> 00:30:08.686
that section to collapse.

00:30:09.046 --> 00:30:11.786
NSTableView will now
reload full width cells

00:30:12.336 --> 00:30:13.976
when the column index
is negative 1.

00:30:13.976 --> 00:30:17.326
Negative 1 is our magic
number to say a column

00:30:17.746 --> 00:30:22.576
that expands all the way across
your table, across all columns.

00:30:22.936 --> 00:30:24.096
So when you call reloadData

00:30:24.096 --> 00:30:26.386
and columnIndexes includes
the negative 1 in there,

00:30:26.386 --> 00:30:27.786
we will automatically reload

00:30:27.786 --> 00:30:29.496
that full width cell
on your behalf.

00:30:29.976 --> 00:30:33.666
This only works for 10.12 and
later linked applications.

00:30:34.606 --> 00:30:37.186
Likewise on 10.12 linked
applications or later,

00:30:37.186 --> 00:30:40.546
NSOutlineView will also
automatically reload its cell

00:30:40.546 --> 00:30:44.416
views associated with the item
you pass in to reload item.

00:30:44.646 --> 00:30:48.526
Additionally, OutlineView now
strongly references the items

00:30:48.526 --> 00:30:50.696
you return to it
via the data source.

00:30:51.796 --> 00:30:56.736
This is really useful but if
your application really wants

00:30:56.736 --> 00:30:59.996
to maintain the original
assigned behavior

00:30:59.996 --> 00:31:03.216
that we had previously, you
can set stronglyReferencesItems

00:31:03.216 --> 00:31:07.416
to false and return to
the pre-10.12 behavior.

00:31:07.986 --> 00:31:13.896
And with that, I'd like to bring
up Taylor Kelly to go ahead

00:31:13.896 --> 00:31:15.726
and talk to you about
grid views.

00:31:16.516 --> 00:31:22.126
[ Applause ]

00:31:22.626 --> 00:31:23.106
>> Thanks, Raleigh.

00:31:24.026 --> 00:31:26.636
So the first thing I'd like to
tell you about is NSGridView.

00:31:27.166 --> 00:31:30.246
This is a new container view
class, similar to NSStackView

00:31:30.276 --> 00:31:31.396
where we completely create

00:31:31.396 --> 00:31:33.906
and manage the constraints
necessary to build your layout.

00:31:33.966 --> 00:31:37.446
But where StackView creates
a linear distribution of use,

00:31:37.706 --> 00:31:40.576
NSGridView creates these
intersecting rows and columns.

00:31:41.116 --> 00:31:42.576
You very commonly
see this in something

00:31:42.576 --> 00:31:43.536
like a preference pane UI.

00:31:43.536 --> 00:31:46.606
Right, there are these
distinct columns and rows

00:31:46.606 --> 00:31:48.916
of aligned content
that are self-sizing

00:31:49.136 --> 00:31:50.566
and pretty statically defined.

00:31:51.376 --> 00:31:55.616
It supports alignment such as
baseline, leading, and trailing.

00:31:55.616 --> 00:31:59.686
It supports spacing of the
GridView as a whole as well

00:31:59.686 --> 00:32:02.766
as its padding on an
individual row and column basis.

00:32:04.126 --> 00:32:05.496
Similar to a spreadsheet
application,

00:32:05.496 --> 00:32:06.646
it supports cell merging.

00:32:06.896 --> 00:32:09.116
So a single view can
span multiple rows

00:32:09.116 --> 00:32:10.186
or multiple columns.

00:32:11.186 --> 00:32:13.786
So for instance these
separators do just that.

00:32:15.226 --> 00:32:18.016
It also supports dynamic hiding
and showing of rows and columns

00:32:18.126 --> 00:32:19.996
without changing the
GridView's own structure.

00:32:20.556 --> 00:32:23.386
So for instance, when we click
on this checkbox, we might want

00:32:23.386 --> 00:32:24.926
to hide the Display
Preference button.

00:32:25.726 --> 00:32:28.376
And we can do that by getting
the row containing that button

00:32:28.376 --> 00:32:30.266
and just setting its
hidden property to true.

00:32:30.876 --> 00:32:32.396
GridView will take
care of the rest.

00:32:34.066 --> 00:32:35.746
There are several other
improvements we've made

00:32:35.746 --> 00:32:36.416
to Auto Layout.

00:32:37.126 --> 00:32:40.676
One is a cleanup of overall
AppKit layout cycle meaning

00:32:40.676 --> 00:32:42.876
that a view no longer needs
to be using auto layout

00:32:42.876 --> 00:32:44.746
or layer backing in
order to participate.

00:32:45.496 --> 00:32:47.646
Just by setting needsLayout
to true on that view,

00:32:47.936 --> 00:32:50.776
during the next display pass
it'll receive a call to layout.

00:32:52.136 --> 00:32:53.086
One implication of this is

00:32:53.086 --> 00:32:55.616
that layout is no longer
called twice per display pass

00:32:55.616 --> 00:32:59.246
for layer-backed views and we
have less implicit dirtying

00:32:59.246 --> 00:33:02.646
of that layout and less
layout passes because of that,

00:33:02.926 --> 00:33:04.206
which is great for performance.

00:33:04.676 --> 00:33:06.506
But if you notice that
layout isn't getting called

00:33:06.506 --> 00:33:07.696
on your view when you expect,

00:33:07.976 --> 00:33:10.166
make sure you're explicitly
setting needsLayout.

00:33:11.356 --> 00:33:12.586
All of this makes it easier

00:33:12.586 --> 00:33:14.246
to do manual layout
of your subviews.

00:33:14.246 --> 00:33:17.276
So you can overwrite
layout without calling super

00:33:17.576 --> 00:33:19.086
and instead just
calculate the frames

00:33:19.086 --> 00:33:21.326
of your subviews,
set them, and return.

00:33:22.626 --> 00:33:24.816
You do want to be sure
that you don't dirty

00:33:24.816 --> 00:33:26.386
that view's layout
or other views.

00:33:26.736 --> 00:33:29.256
This can happen if during a
view's layout it sets its own

00:33:29.256 --> 00:33:30.926
frame or the frame
of an ancestor.

00:33:31.396 --> 00:33:32.666
This will dirty that
view's layout

00:33:32.666 --> 00:33:36.226
and cause an additional
layout pass.

00:33:36.616 --> 00:33:39.836
If this continues, this is
what we call a layout loop

00:33:40.326 --> 00:33:41.846
and these are pretty
difficult to debug.

00:33:42.316 --> 00:33:44.176
So on macOS and iOS,

00:33:44.176 --> 00:33:46.356
we've introduced new layout
loop debugging support

00:33:46.356 --> 00:33:49.006
so you can better understand
what view is dirtying layout

00:33:49.006 --> 00:33:49.686
and why.

00:33:51.266 --> 00:33:54.366
There's changes to the layout
constraint API adding anchor

00:33:54.366 --> 00:33:55.846
properties so you
know what anchors

00:33:55.846 --> 00:33:57.086
that constraint refers to.

00:33:57.646 --> 00:34:00.216
These apply even when you're
not using the anchor-based API.

00:34:02.536 --> 00:34:04.576
In addition with that first
time it is now nullable,

00:34:04.576 --> 00:34:05.756
so if you are reading
that property,

00:34:05.806 --> 00:34:07.166
be sure to handle the nil case.

00:34:08.186 --> 00:34:10.275
In addition, Interface
Builder has new support

00:34:10.275 --> 00:34:12.146
for incremental adoption
of auto layout.

00:34:12.505 --> 00:34:14.096
So within a single
document or even

00:34:14.096 --> 00:34:16.496
within a single view hierarchy
you can partially adopt

00:34:16.496 --> 00:34:19.846
constants, which
is pretty great.

00:34:19.846 --> 00:34:22.196
NSGridView, the layout
loop debugging and more,

00:34:22.196 --> 00:34:24.686
is talked about in Friday's,
What's New in Auto Layout talk.

00:34:25.545 --> 00:34:27.946
At this point I'd like
to talk about colors,

00:34:27.946 --> 00:34:30.246
specifically wide gamut colors.

00:34:30.886 --> 00:34:33.636
So sRGB is a pretty
popular color space.

00:34:33.636 --> 00:34:37.856
Usually it's the implied color
space of otherwise unspecified

00:34:38.146 --> 00:34:40.676
and most of our displays
have an sRGB color gamut.

00:34:41.585 --> 00:34:44.686
The new 5K iMac and
iPad Pro 9.7 inch,

00:34:45.025 --> 00:34:46.806
both contain these
updated displays

00:34:46.906 --> 00:34:48.815
that can display
more vivid colors.

00:34:49.436 --> 00:34:51.966
Specifically, they're
using the P3 color gamut

00:34:52.596 --> 00:34:55.166
and this is what we call a wide
color gamut because compared

00:34:55.166 --> 00:34:58.656
to sRGB, it can display much
more vibrant greens and reds.

00:34:59.536 --> 00:35:02.726
So your applications can display
photos much more accurately

00:35:02.726 --> 00:35:05.866
to their original color and they
can display these more vibrant

00:35:05.866 --> 00:35:08.086
colors to make UI
elements really pop.

00:35:09.046 --> 00:35:11.856
An example of such a color
would be this emerald green,

00:35:11.856 --> 00:35:14.946
which happens to be Pantone's
2013 color of the year.

00:35:14.946 --> 00:35:18.166
It's outside of sRGB.

00:35:18.166 --> 00:35:19.916
So previous displays
couldn't represent this

00:35:19.966 --> 00:35:23.236
but it is fully representable
using P3.

00:35:24.136 --> 00:35:27.326
Your photos also contain
these more vibrant colors,

00:35:27.326 --> 00:35:29.206
especially these
reds and oranges.

00:35:29.786 --> 00:35:33.236
A note of irony here is that
the projector and even the video

00:35:33.236 --> 00:35:35.686
at home are not actually going
to reproduce these colors,

00:35:35.686 --> 00:35:38.636
so you'll kind of have to take
my word that they're special.

00:35:40.646 --> 00:35:41.896
If you want to work
with these colors,

00:35:41.896 --> 00:35:44.366
there's a new color
space displayP3,

00:35:44.506 --> 00:35:45.376
which lets you work with this.

00:35:45.376 --> 00:35:47.766
This joins sRGB and
other color spaces.

00:35:48.516 --> 00:35:49.696
There's also a new constructor

00:35:49.696 --> 00:35:53.786
on NSColor displayP3 red green
blue alpha which allows you

00:35:53.786 --> 00:35:55.516
to create a color
in that color space.

00:35:55.896 --> 00:35:58.786
UIColor has the same constructor
with the same semantics.

00:35:59.846 --> 00:36:02.486
Another way of working with wide
colors is using something we're

00:36:02.486 --> 00:36:05.086
calling extended range sRGB.

00:36:06.516 --> 00:36:08.906
And so when working
with a color space,

00:36:08.986 --> 00:36:10.016
you're typically constrained

00:36:10.016 --> 00:36:11.976
with component values
from 0 to 1.

00:36:12.496 --> 00:36:14.446
And you can pick any color
within that color gamut,

00:36:14.446 --> 00:36:16.796
such as this blue,
with those values.

00:36:17.356 --> 00:36:19.276
But you can't represent
a color that's outside

00:36:19.276 --> 00:36:20.076
of that color gamut.

00:36:20.286 --> 00:36:22.576
So sRGB cannot represent
this green color.

00:36:23.676 --> 00:36:26.526
Well extended range sRGB
uses the same color primaries

00:36:26.526 --> 00:36:29.566
and the same white point as
sRGB but allows the components

00:36:29.566 --> 00:36:32.156
to take on values less
than 0 or greater than 1.

00:36:32.856 --> 00:36:35.466
So it can represent this
green with a negative red

00:36:35.466 --> 00:36:38.066
and blue value and a
greater than 1 green value.

00:36:39.166 --> 00:36:42.246
It happens to also be the P3
green primary, so you can see

00:36:42.246 --> 00:36:45.266
that with extended range sRGB,
you can represent the full range

00:36:45.266 --> 00:36:47.296
of colors necessary
for these displays.

00:36:48.646 --> 00:36:51.396
This also has a color
space extendedSRGB

00:36:51.976 --> 00:36:53.546
and the existing NSColor

00:36:53.546 --> 00:36:55.726
and UIColor constructors
you're already using

00:36:55.896 --> 00:36:58.036
that previously gave
you colors using sRGB.

00:36:58.326 --> 00:37:01.446
Will now accept values less
than 0 or greater than 1

00:37:01.446 --> 00:37:04.006
and give you back an
extended range sRGB color,

00:37:04.506 --> 00:37:05.326
which is pretty convenient.

00:37:07.566 --> 00:37:08.816
One important thing to consider

00:37:08.816 --> 00:37:11.376
with these wider color
gamuts is color depth.

00:37:12.236 --> 00:37:14.636
So sRGB can theoretically
represent any color

00:37:14.636 --> 00:37:17.316
within its gamut, but
with 8 bits per component,

00:37:17.316 --> 00:37:20.426
you can only address a finite
number of those, right.

00:37:20.566 --> 00:37:23.286
The black space here are simply
un-addressable colors using

00:37:23.286 --> 00:37:24.436
those 8 bits per component.

00:37:25.826 --> 00:37:28.606
When you widen the color gamut,
right, increase the volume

00:37:28.606 --> 00:37:30.756
of that gamut but keep
the same bit depth,

00:37:31.246 --> 00:37:33.616
you're addressable
color density goes down.

00:37:34.206 --> 00:37:37.436
Your ability to specify
a color loses precision.

00:37:37.436 --> 00:37:39.776
So this is why we
recommend when working

00:37:39.776 --> 00:37:41.876
with these wider color
spaces, such as P3,

00:37:41.876 --> 00:37:45.256
that you use 16 bits
per component instead.

00:37:46.326 --> 00:37:48.276
It doubles the amount
of memory and storage

00:37:48.276 --> 00:37:50.936
but gives you exponentially
more addressable colors.

00:37:50.936 --> 00:37:52.696
So we think that
tradeoff is worth it.

00:37:54.466 --> 00:37:56.236
What API do you need
to use in order

00:37:56.236 --> 00:37:58.036
to consider these deeper colors?

00:37:58.516 --> 00:38:00.796
Well, the great news is that
most of it is automatic.

00:38:01.086 --> 00:38:04.236
So NSWindow will automatically
use deeper backing stores

00:38:04.356 --> 00:38:07.266
with these higher bit depths
on wide gamut displays,

00:38:07.486 --> 00:38:09.186
even as you drag
it across screens.

00:38:10.086 --> 00:38:12.126
If there's a reason you need
to explicitly control that,

00:38:12.126 --> 00:38:13.566
you can set the depth
limit property

00:38:13.656 --> 00:38:15.136
to some value of your choice.

00:38:16.096 --> 00:38:19.136
Views and layers within that
window will automatically

00:38:19.136 --> 00:38:22.286
inherit that bit depth with the
exception being OpenGL view.

00:38:22.726 --> 00:38:24.826
There you should use the
associated pixel format API.

00:38:26.616 --> 00:38:30.796
CALayer on both macOS and iOS
has a new contents format API

00:38:31.136 --> 00:38:32.856
property that allows you

00:38:32.856 --> 00:38:35.446
to again explicitly control
the bit depth it uses.

00:38:36.336 --> 00:38:37.756
So this is how you
can take advantage

00:38:37.756 --> 00:38:39.116
of wide color in
your application.

00:38:39.436 --> 00:38:42.296
We've also enhanced part of the
system to better take advantage

00:38:42.296 --> 00:38:43.256
of these wider colors.

00:38:43.896 --> 00:38:45.166
One example is the color panel.

00:38:45.816 --> 00:38:47.036
So on the iMac on the left here,

00:38:47.486 --> 00:38:51.846
the color wheel will
actually display, there we go.

00:38:51.846 --> 00:38:53.746
It will actually
display and allow picking

00:38:53.746 --> 00:38:58.556
from the full range of
P3 colors beyond the sRGB

00:38:58.556 --> 00:38:59.786
that normal color wheels allow.

00:39:00.486 --> 00:39:03.706
However, you can also
right click the color wheel

00:39:03.836 --> 00:39:06.246
and explicitly choose
the working color space.

00:39:06.776 --> 00:39:08.156
So even on these
previous displays

00:39:08.156 --> 00:39:09.736
that can't render P3 colors,

00:39:09.936 --> 00:39:11.756
you can still allow
picking from them.

00:39:14.046 --> 00:39:16.146
The RGB color picker
has always allowed you

00:39:16.146 --> 00:39:17.776
to choose the color
space you're working in,

00:39:18.036 --> 00:39:20.046
but it also allows you to
change the representation

00:39:20.046 --> 00:39:24.136
from 8-bit values from 0
to 255 to floating point.

00:39:24.616 --> 00:39:26.566
So again you can get this
higher precision when working

00:39:26.566 --> 00:39:28.016
with these wider color spaces.

00:39:28.806 --> 00:39:30.826
These color panel changes comes

00:39:30.826 --> 00:39:32.826
to all applications
completely for free.

00:39:32.826 --> 00:39:34.546
No API is needed for those.

00:39:36.396 --> 00:39:38.976
The Working with Wide Color
talk on Thursday covers this

00:39:38.976 --> 00:39:41.746
and more, such as asset catalog
support and WebKit support.

00:39:41.906 --> 00:39:44.766
I'd recommend checking that out
if this stuff interests you.

00:39:45.426 --> 00:39:49.226
So the next topic is
status item enhancements.

00:39:49.226 --> 00:39:50.866
So status items are
the things that live

00:39:50.866 --> 00:39:52.596
in the upper trailing
corner of the menu bar

00:39:52.976 --> 00:39:54.966
and these are things that
previously required the use

00:39:54.966 --> 00:39:57.966
of private API to achieve
but now come mostly for free.

00:39:59.016 --> 00:40:00.456
First is reordering.

00:40:00.536 --> 00:40:03.856
You can now command click and
drag on any item and reorder it

00:40:03.856 --> 00:40:05.716
within and beyond
the system items.

00:40:06.556 --> 00:40:09.356
You can also use keyboard
focus to navigate to your item

00:40:09.546 --> 00:40:11.646
and even activate
menu items within.

00:40:12.866 --> 00:40:14.106
The best part of all of this is

00:40:14.106 --> 00:40:16.026
that this comes completely
automatically

00:40:16.026 --> 00:40:17.896
with no API opt-in
or link check.

00:40:18.596 --> 00:40:20.906
So all items are command-click
and drag to reorderable,

00:40:21.306 --> 00:40:23.816
and any items with a
menu set will participate

00:40:23.816 --> 00:40:24.826
in keyboard navigation.

00:40:25.306 --> 00:40:26.666
If they have a custom
target action,

00:40:26.666 --> 00:40:27.746
they'll just be skipped over.

00:40:28.996 --> 00:40:31.166
The next is hiding and removal.

00:40:31.746 --> 00:40:33.326
You can now command-click
and drag an item

00:40:33.326 --> 00:40:36.516
out of the status bar, remove
it, get notified of that change,

00:40:36.516 --> 00:40:38.136
and even programmatically
restore it.

00:40:39.396 --> 00:40:41.806
Unlike reordering, this
does require opt-in.

00:40:41.806 --> 00:40:44.426
No status items will be
automatically removable

00:40:44.996 --> 00:40:47.446
and you can do that by setting
the behavior of the status item

00:40:47.446 --> 00:40:48.686
to include removalAllowed.

00:40:49.796 --> 00:40:51.436
You can programmatically
read/set

00:40:51.436 --> 00:40:52.866
and even get KVO notified

00:40:52.866 --> 00:40:55.046
of this change using
the isVisible property.

00:40:55.686 --> 00:40:57.586
And if your application
is a status bar app,

00:40:57.656 --> 00:41:00.286
meaning its only representation
is that icon in the status bar,

00:41:00.286 --> 00:41:03.766
there's no doc icon or other
way to quit it, you can set it

00:41:03.766 --> 00:41:05.556
to automatically quit on removal

00:41:05.736 --> 00:41:07.636
by setting the
terminationOnRemoval behavior.

00:41:09.456 --> 00:41:11.906
All of this gets autosaved
for you, the location

00:41:11.906 --> 00:41:13.966
and the visible state so you
don't have to worry about trying

00:41:13.966 --> 00:41:16.306
to preserve that using
the autosave name.

00:41:16.966 --> 00:41:19.516
We automatically generate
this based on the item index

00:41:19.516 --> 00:41:20.906
that you created in
your application,

00:41:21.566 --> 00:41:23.876
but if you create them in
some non-deterministic order

00:41:23.876 --> 00:41:25.466
or just want to have
more explicit control,

00:41:25.806 --> 00:41:27.046
you can set that autosave name

00:41:27.046 --> 00:41:28.886
to some identifier
of your choice.

00:41:29.796 --> 00:41:31.716
So that's status
item enhancements.

00:41:31.716 --> 00:41:33.796
A lot of it comes for free, and
with a little bit of tweaking,

00:41:34.046 --> 00:41:35.916
you can really make them
great in your application.

00:41:37.206 --> 00:41:39.216
Next are control constructors.

00:41:39.636 --> 00:41:42.796
So these are new constructors
on existing NS Controls

00:41:42.796 --> 00:41:45.896
that make it really easy to
get standard look and feels.

00:41:46.596 --> 00:41:50.376
Examples are different types
of buttons, segmented controls,

00:41:51.036 --> 00:41:55.416
image views, sliders, and
labels, and text fields.

00:41:56.226 --> 00:41:57.896
So these are the types of
things you're already working

00:41:57.896 --> 00:41:59.696
with in the Interface
Builder object library

00:41:59.816 --> 00:42:01.226
and it makes it just as easily

00:42:01.226 --> 00:42:03.096
to use these right
out of the box.

00:42:03.726 --> 00:42:05.306
They come with the
standard system setup,

00:42:05.306 --> 00:42:07.066
the right font size,
and text color,

00:42:07.386 --> 00:42:08.836
and they support
different contexts.

00:42:09.336 --> 00:42:13.016
So the label here looks
great in aqua, vibrant light

00:42:13.016 --> 00:42:15.446
and even a vibrant dark
all right out of the box.

00:42:15.566 --> 00:42:16.826
There's no additional
setup needed.

00:42:17.576 --> 00:42:19.936
I'd love to show you an example
of what this does to your code.

00:42:19.936 --> 00:42:22.686
So this is creating
a checkbox before.

00:42:22.766 --> 00:42:24.266
There's quite a few
properties to set

00:42:24.266 --> 00:42:26.456
and the unfortunate thing is
we really only care about three

00:42:26.456 --> 00:42:28.536
of those; the title,
target, and action.

00:42:28.996 --> 00:42:32.426
Well with checkbox, title,
target, action, it's distilled

00:42:32.426 --> 00:42:34.436
down to just that,
which is pretty great.

00:42:35.716 --> 00:42:39.536
A bit more of a --
Oh [applause].

00:42:42.306 --> 00:42:42.896
Just wait.

00:42:43.636 --> 00:42:45.756
So this is creating just
a static label, right,

00:42:45.756 --> 00:42:47.386
just some text on the screen.

00:42:47.536 --> 00:42:50.186
And here, we care about
just the string value.

00:42:51.056 --> 00:42:54.026
Well, with labelWithString,
it again is just that.

00:42:54.906 --> 00:42:57.056
So, this is pretty great.

00:42:57.056 --> 00:42:58.536
It comes out of the box --

00:42:59.516 --> 00:43:03.016
[ Applause ]

00:43:03.516 --> 00:43:05.596
It comes out of the box
ready to be used with

00:43:05.596 --> 00:43:06.716
or without auto layout.

00:43:06.846 --> 00:43:08.866
So if you are going to be
positioning with constraints,

00:43:09.056 --> 00:43:11.186
you still need to set
translatesAutoresizingMask

00:43:11.186 --> 00:43:14.316
IntoConstaints to false,
like all of your other views.

00:43:14.806 --> 00:43:16.826
And so if you already have
categories doing these kinds

00:43:16.826 --> 00:43:18.166
of things, we still
recommend moving

00:43:18.166 --> 00:43:20.256
over to these new system
ones because you'll ensure

00:43:20.466 --> 00:43:21.876
that your controls
have the standard look

00:43:21.876 --> 00:43:23.906
and feel both now
and in the future.

00:43:24.096 --> 00:43:28.116
The last thing I'd like to
talk about are API refinements.

00:43:28.116 --> 00:43:29.906
I only covered a number of
these that applied to all

00:43:29.906 --> 00:43:31.946
of our frameworks and these
apply to AppKit as well

00:43:31.946 --> 00:43:34.026
but there's two more that I
want to talk about that apply

00:43:34.026 --> 00:43:35.046
to AppKit specifically.

00:43:36.116 --> 00:43:37.766
The first is weak delegates.

00:43:38.436 --> 00:43:40.756
So we've added new zeroing
weak delegate support

00:43:40.756 --> 00:43:44.066
for various delegates and data
sources for different classes,

00:43:44.806 --> 00:43:47.396
so you no longer need to clear
these properties once the

00:43:47.396 --> 00:43:48.466
delegates is deallocated.

00:43:49.786 --> 00:43:52.136
It still supports non-weak
referenceable objects

00:43:52.326 --> 00:43:54.676
in which case it'll fall
back to the existing assign

00:43:54.676 --> 00:43:56.626
or unsafe, unretained semantics.

00:43:57.886 --> 00:43:59.456
We've also gone through
and made sure that all

00:43:59.456 --> 00:44:01.446
of our classes explicitly
did declare their

00:44:01.446 --> 00:44:02.886
designated initializers.

00:44:03.466 --> 00:44:05.626
These are the same as what they
effectively were previously

00:44:05.786 --> 00:44:07.866
but now are just
declared in the actual API

00:44:08.696 --> 00:44:10.386
with the one exception
being NSCursor.

00:44:10.756 --> 00:44:12.286
So if you are subclassing
NSCursor,

00:44:12.286 --> 00:44:13.266
please see the release notes

00:44:13.266 --> 00:44:16.136
for how you should
properly deal with that.

00:44:16.416 --> 00:44:18.736
As with all newly declared
designated initializers,

00:44:19.156 --> 00:44:21.906
you should make sure that
you're properly dealing

00:44:21.906 --> 00:44:23.186
with that in your subclass.

00:44:24.286 --> 00:44:25.846
And so if you weren't
previously,

00:44:25.846 --> 00:44:27.726
you potentially had these
incorrectness issues

00:44:27.726 --> 00:44:29.226
that maybe were subtle bugs.

00:44:29.546 --> 00:44:31.676
In Objective-C, you'll now
see build warnings for this.

00:44:31.866 --> 00:44:33.676
And in Swift, you're going
to get build failures.

00:44:33.676 --> 00:44:35.026
So you want to make sure

00:44:35.026 --> 00:44:37.026
that you're properly handling
these different cases.

00:44:37.366 --> 00:44:39.386
So that's it for
what's new in AppKit.

00:44:39.386 --> 00:44:41.886
At this point, I'd like to turn
it back over to Ali to tell you

00:44:41.886 --> 00:44:43.056
about what's new in Foundation.

00:44:44.516 --> 00:44:50.076
[ Applause ]

00:44:50.576 --> 00:44:51.196
>> Thank you, Taylor.

00:44:53.946 --> 00:44:56.166
So here are some of the things
that are new in Foundation

00:44:56.636 --> 00:44:58.536
and let me just dive right in.

00:44:59.396 --> 00:45:02.486
Now earlier you saw
NSURL becoming URL

00:45:02.486 --> 00:45:04.706
and I think we also talked
about it a bit yesterday.

00:45:05.026 --> 00:45:10.226
We are dropping NS prefix in
key Foundation types in Swift.

00:45:10.506 --> 00:45:12.316
Now, as you might
know, large subset

00:45:12.316 --> 00:45:16.586
of Foundation actually ships
with the Swift Core Libraries

00:45:16.586 --> 00:45:19.026
as a part of Swift Core
Libraries and is available

00:45:19.026 --> 00:45:20.576
in other platforms,
such as Linux.

00:45:21.436 --> 00:45:25.506
And we want to match the naming
style of this part of Foundation

00:45:25.686 --> 00:45:28.206
with the convention established
by the Swift Standard Library

00:45:28.206 --> 00:45:29.736
which does not use prefixes.

00:45:30.756 --> 00:45:35.126
As a result, a lot of our
types drop their NS prefixes

00:45:35.166 --> 00:45:37.136
in Foundation and
Swift, as you can see.

00:45:37.136 --> 00:45:39.076
NSFormatter becomes
Formatter and so on.

00:45:39.136 --> 00:45:41.906
Now the last two here,
NSData and NSURL are part

00:45:41.906 --> 00:45:45.906
of a special category and I'll
mention these in a little bit.

00:45:46.016 --> 00:45:48.356
Now, this is happening
in Foundation only.

00:45:48.356 --> 00:45:49.516
It's not something
we're applying

00:45:49.516 --> 00:45:52.036
to our other frameworks,
and even in Foundation,

00:45:52.276 --> 00:45:53.676
it's only applying to some APIs.

00:45:53.676 --> 00:45:56.926
We do not apply this
NS dropping to APIs

00:45:56.926 --> 00:45:59.176
that are inherently
tied to Objective-C.

00:45:59.466 --> 00:46:03.206
Examples are NSObject,
NSProxy, NSAutoreleasePool.

00:46:03.546 --> 00:46:06.816
We also do not apply it to
APIs that at platform specific

00:46:06.816 --> 00:46:09.466
and are, in fact, not
available on other platforms

00:46:09.466 --> 00:46:12.976
such as NSUserNotification,
NSXPCConnection.

00:46:14.036 --> 00:46:17.176
And in one other case is classes

00:46:17.176 --> 00:46:18.976
which are also exposed
as value types.

00:46:19.416 --> 00:46:22.386
So here we are exposing
data, URL, et cetera,

00:46:22.386 --> 00:46:26.866
but we're also exposing NSData,
NSURL, and so on and let me talk

00:46:26.866 --> 00:46:27.756
about what I mean there.

00:46:28.216 --> 00:46:30.876
Now first let me explain
a bit about value types.

00:46:32.006 --> 00:46:34.016
You might already be
familiar with value types.

00:46:34.406 --> 00:46:36.526
We've had this concept in
Foundation for a long time.

00:46:36.846 --> 00:46:39.936
These are types where value is
important, not the identity.

00:46:40.586 --> 00:46:44.396
Examples are NSString,
NSData, URL, Array, et cetera.

00:46:45.496 --> 00:46:46.656
Now, since a number

00:46:46.656 --> 00:46:49.786
of Foundation APIs already have
these value type semantics,

00:46:49.826 --> 00:46:52.496
we've gone ahead and added
them as value types in Swift.

00:46:53.056 --> 00:46:55.766
And here is the full set of
APIs where we've done this.

00:46:55.966 --> 00:47:00.066
This is in addition of course
to string, array, dictionary,

00:47:00.066 --> 00:47:02.496
and set which are already
exposed as values types

00:47:02.496 --> 00:47:03.726
in Swift, since they're
available

00:47:03.726 --> 00:47:04.816
in the standard library.

00:47:05.516 --> 00:47:09.536
So now these types here are
exposed as structs in Swift

00:47:09.746 --> 00:47:11.386
and they have value
type semantics,

00:47:11.386 --> 00:47:13.486
meaning they can be
directly mutated,

00:47:13.686 --> 00:47:15.086
if mutability makes
sense for them.

00:47:15.476 --> 00:47:19.096
You can use let or var on these
to distinguished mutability

00:47:19.626 --> 00:47:20.656
at the time you declare them.

00:47:21.206 --> 00:47:24.176
These also conform to the
expected Swift protocols

00:47:24.176 --> 00:47:28.136
as well, as you might expect.

00:47:28.286 --> 00:47:31.136
Now existing class APIs
still remain in cases

00:47:31.136 --> 00:47:32.826
where we've created
these value types

00:47:33.026 --> 00:47:35.666
and let me look at
a case study here.

00:47:36.186 --> 00:47:38.576
An example is data, the
one I already mentioned.

00:47:38.846 --> 00:47:40.806
So now we have the
struct data type.

00:47:40.866 --> 00:47:42.196
This is the value type for data.

00:47:42.536 --> 00:47:44.476
This is the data
type we expect you

00:47:44.476 --> 00:47:48.206
to use most often
in your programming.

00:47:48.236 --> 00:47:52.086
This is the type moving forward;
however, we also have NSData

00:47:52.116 --> 00:47:54.756
which is a subclass of
NSObject and NSMutableData

00:47:54.756 --> 00:47:57.426
which is a subclass
of NSData itself.

00:47:57.846 --> 00:48:00.256
Now NS types remain
because something

00:48:00.256 --> 00:48:03.236
like NSMutableData is not
migratable very easily,

00:48:03.236 --> 00:48:05.146
so the migrator will
not migrate it.

00:48:05.556 --> 00:48:08.306
Another reason we have NS types
is sometimes you actually do

00:48:08.306 --> 00:48:09.606
want to subclass these types.

00:48:09.606 --> 00:48:11.266
You know, you might
be subclassing NSData

00:48:11.266 --> 00:48:14.326
or NSMutableData to provide
some specialized implementation

00:48:14.636 --> 00:48:16.056
and you can do that
with, of course,

00:48:16.056 --> 00:48:18.226
the class types,
as you see here.

00:48:18.226 --> 00:48:20.696
So these are some of the reasons
why the NS types still remain.

00:48:22.186 --> 00:48:24.456
Now, let's look at
some differences here.

00:48:25.256 --> 00:48:29.256
The NSData class has
a length property.

00:48:29.546 --> 00:48:31.916
This has been named count
in the struct version

00:48:31.916 --> 00:48:33.716
because it's more
consistent with the rest

00:48:33.716 --> 00:48:34.986
of the Swift Standard Library.

00:48:35.576 --> 00:48:38.026
Methods such as write
to, range of and many

00:48:38.026 --> 00:48:40.036
of these other methods
remain pretty much intact.

00:48:40.036 --> 00:48:42.346
They come across the same
way except you'll notice

00:48:42.346 --> 00:48:45.796
that the NSRange and NSData
has become range of index

00:48:46.776 --> 00:48:48.956
in the struct data version,
which is more consistent

00:48:48.956 --> 00:48:50.656
with the Swift Library.

00:48:51.036 --> 00:48:54.196
And finally you'll note that a
mutating function, like append,

00:48:54.196 --> 00:48:57.416
is not available on this
value type data directly while

00:48:57.416 --> 00:49:00.336
in the case of NSData, it's
on the NSMutableData class.

00:49:00.736 --> 00:49:02.486
So these are some of the
differences you'll see

00:49:02.486 --> 00:49:04.946
between the value types
and the class types.

00:49:05.516 --> 00:49:08.066
Now I'm not going to say
much more about this.

00:49:08.566 --> 00:49:10.926
There is a talk this afternoon,
What's New in Foundation

00:49:10.926 --> 00:49:12.996
for Swift in the Mission room.

00:49:13.206 --> 00:49:17.696
I encourage you to attend that
and hear more about these.

00:49:17.916 --> 00:49:20.096
Now we have several
new types in Foundation

00:49:20.326 --> 00:49:21.746
to represent measured amounts.

00:49:22.276 --> 00:49:24.406
The main class here
is the unit class.

00:49:24.446 --> 00:49:27.826
This is an abstract type to
represent units, such as miles,

00:49:27.986 --> 00:49:30.406
degrees Celsius, kilometers
per hour, and so on.

00:49:30.596 --> 00:49:32.446
And then we have
a class dimension,

00:49:32.446 --> 00:49:33.606
which is a subclass of unit.

00:49:33.976 --> 00:49:36.046
This represents unit
families such as length,

00:49:36.156 --> 00:49:38.236
temperature, and
speed and so on.

00:49:38.716 --> 00:49:40.146
So here we have the unit class.

00:49:40.446 --> 00:49:43.486
We have the subclass dimension
and then we have subclasses

00:49:44.206 --> 00:49:46.696
such as unit length,
unit temperature,

00:49:46.696 --> 00:49:48.326
unit speed, and a bunch more.

00:49:49.586 --> 00:49:53.036
There's a helper class unit
converter that allows conversion

00:49:53.036 --> 00:49:55.276
between units within
the same unit family

00:49:56.246 --> 00:49:59.576
and there is a struct
measurement, it's a class,

00:49:59.576 --> 00:50:02.596
of course, in Objective-C but
across as a value type in Swift,

00:50:03.036 --> 00:50:05.716
struct measurement which
combines a value such as 10

00:50:06.026 --> 00:50:07.606
with a unit such as miles,

00:50:07.996 --> 00:50:09.776
so this basically is
now a measurement,

00:50:09.986 --> 00:50:11.466
and finally the icing
on the cake,

00:50:11.896 --> 00:50:13.536
we have the measurement
formatter class

00:50:13.776 --> 00:50:16.076
which will take one of these
measurements and show it

00:50:16.076 --> 00:50:17.906
to the user in the
user's locale.

00:50:18.416 --> 00:50:23.246
So it'll show 10 miles to a
user here in the United States

00:50:23.526 --> 00:50:26.496
but will show 16 kilometers, for
instance, to a user in Europe,

00:50:26.726 --> 00:50:27.896
who's using the European system.

00:50:27.896 --> 00:50:29.466
So it will do the
conversions for you

00:50:29.596 --> 00:50:31.076
and show the user
the right thing.

00:50:32.516 --> 00:50:37.186
[ Applause ]

00:50:37.686 --> 00:50:40.506
Now out of the box, we have
plenty of unit families defined.

00:50:40.866 --> 00:50:41.706
Here's the whole set.

00:50:42.236 --> 00:50:45.286
So these are subclasses of
dimension, and within each one

00:50:45.286 --> 00:50:46.406
of these unit families,

00:50:46.406 --> 00:50:49.486
we actually have multiple units
defined out of the box as well.

00:50:49.736 --> 00:50:52.016
Let me take a look at unit
temperature for instance.

00:50:52.446 --> 00:50:54.916
You'll see that unit temperature
has three standards units;

00:50:54.916 --> 00:50:57.276
kelvin, Celsius, and Fahrenheit.

00:50:57.596 --> 00:50:59.596
And these are defined
as class properties

00:50:59.656 --> 00:51:02.646
on the UnitTemperature
class and many

00:51:02.646 --> 00:51:06.126
of the other dimensions also
have a number of units defined

00:51:06.126 --> 00:51:07.836
that know how to convert
between each other.

00:51:08.306 --> 00:51:13.346
And even better news, you can
actually add your own units

00:51:13.386 --> 00:51:15.276
on top of what we
provided and they'll play

00:51:15.276 --> 00:51:16.426
with what's already there

00:51:16.426 --> 00:51:18.896
and you can also add your
own unit families as well.

00:51:19.526 --> 00:51:22.426
So you can hear much more
about this Friday afternoon

00:51:22.426 --> 00:51:25.816
at 4:00 o'clock,
Measurement and Units.

00:51:26.886 --> 00:51:29.166
DateInterval is a new type
we've added to Foundation.

00:51:29.536 --> 00:51:31.906
It represents a date interval.

00:51:32.386 --> 00:51:36.766
It's got three properties;
start, end, and duration.

00:51:36.766 --> 00:51:38.526
Fairly straightforward, so
these are not, of course,

00:51:38.526 --> 00:51:40.026
fully independent
but they're reflected

00:51:40.026 --> 00:51:41.306
as three separate properties.

00:51:41.546 --> 00:51:43.846
In addition to these properties,
DateInterval knows how

00:51:43.846 --> 00:51:46.476
to do things like check if a
date is within a date interval

00:51:46.706 --> 00:51:48.976
or whether two date
intervals overlap and so on.

00:51:49.616 --> 00:51:54.296
Date intervals are of course
also very useful to be formatted

00:51:54.346 --> 00:51:55.836
with the DateIntervalFormatter
class.

00:51:55.836 --> 00:51:58.806
That's something we -- That's an
API we introduced last release.

00:51:59.646 --> 00:52:01.766
We had an API string from to.

00:52:01.916 --> 00:52:03.406
Now we have the string from API

00:52:03.566 --> 00:52:05.176
which simply takes
a date interval,

00:52:05.766 --> 00:52:06.766
so fairly straightforward.

00:52:07.816 --> 00:52:10.696
Now at this point let me
give you a public service

00:52:10.696 --> 00:52:13.396
announcement about
handling dates and times.

00:52:14.716 --> 00:52:16.486
So handling dates can be tricky.

00:52:17.306 --> 00:52:19.296
Now this is not relationship
advice here.

00:52:19.506 --> 00:52:22.236
Okay? I'm not a doctor.

00:52:24.086 --> 00:52:26.406
Let's say you want to
represent a ten second period.

00:52:26.866 --> 00:52:28.996
You might go ahead and create
a DateInterval like this,

00:52:29.096 --> 00:52:31.426
start date and a
ten second period.

00:52:31.836 --> 00:52:35.066
This is likely correct for
whatever you might try to,

00:52:35.066 --> 00:52:37.366
whatever you're trying to
do with a ten second period,

00:52:37.906 --> 00:52:39.636
but let's say you're
trying to represent a day.

00:52:40.326 --> 00:52:42.106
You might go ahead and
write code like this,

00:52:43.276 --> 00:52:46.436
24 times 60 by 60 which is the
number of seconds in a day.

00:52:47.016 --> 00:52:49.326
Well this is the number of
seconds in a 24-hour period

00:52:49.836 --> 00:52:52.986
and it's often not
going to be correct.

00:52:53.346 --> 00:52:55.956
The reason is because days
are not always 24 hours long.

00:52:56.056 --> 00:52:57.836
Months aren't always 31 days.

00:52:57.836 --> 00:53:00.456
Years aren't always
365 days and so on.

00:53:00.456 --> 00:53:02.946
We always keep those in
mind but there are also days

00:53:02.946 --> 00:53:07.786
which are 23 hours or sometimes
24 hours, 25 hours, as you know.

00:53:08.316 --> 00:53:10.016
So depending on what
you want to do

00:53:10.016 --> 00:53:12.476
with a DateInterval representing
a date, are you trying

00:53:12.476 --> 00:53:14.476
to set an alarm exactly
24 hours from now?

00:53:14.746 --> 00:53:17.606
Are you trying to send an alarm
at the same time the next day?

00:53:17.606 --> 00:53:18.896
You have to be careful.

00:53:19.326 --> 00:53:22.746
Typically the correct solutions
here involve using the calendar

00:53:22.746 --> 00:53:25.306
class and you can hear
about these problems

00:53:25.306 --> 00:53:28.696
and also luckily their solutions
in this talk from 2013,

00:53:28.696 --> 00:53:30.666
Solutions to Common Date
and Time Challenges,

00:53:30.666 --> 00:53:33.316
which I encourage you
to go back and watch.

00:53:35.336 --> 00:53:38.906
ISO8601 DateFormatter is
another new API in Foundation.

00:53:38.906 --> 00:53:40.226
It's a formatter for dates.

00:53:40.896 --> 00:53:41.286
Thank you.

00:53:42.516 --> 00:53:45.006
[ Applause ]

00:53:45.506 --> 00:53:47.176
So clearly some of you have had

00:53:47.236 --> 00:53:50.486
to use 8601 before;
8601 is a standard.

00:53:50.486 --> 00:53:52.666
It's an interchange
format for specifying dates

00:53:52.666 --> 00:53:53.956
in an unambiguous manner.

00:53:54.446 --> 00:53:56.786
So this is a separate
class than DateFormatter

00:53:56.786 --> 00:53:58.646
because unlike DateFormatter,
which is meant

00:53:58.646 --> 00:54:02.916
for user-localized dates, 8601
formatting is non-localized.

00:54:03.426 --> 00:54:04.666
It's, you know, interchange
format.

00:54:04.666 --> 00:54:06.236
So it's a separate type.

00:54:06.426 --> 00:54:08.076
We decided to keep
things simple.

00:54:08.546 --> 00:54:09.706
Using it is very simple.

00:54:10.596 --> 00:54:11.786
So create a formatter.

00:54:12.726 --> 00:54:16.486
Get yourself a date, again
not relationship advice.

00:54:18.086 --> 00:54:20.616
And simply ask the formatter
for the string for that date

00:54:20.616 --> 00:54:22.006
and it will return
you the format.

00:54:22.256 --> 00:54:24.276
Now this DateFormatter
can actually go both ways,

00:54:24.836 --> 00:54:26.656
so you can actually -- Oh,
by the way, here's the output

00:54:26.686 --> 00:54:28.416
from that call, and
as you can see,

00:54:28.416 --> 00:54:29.816
it's getting close to lunchtime.

00:54:30.476 --> 00:54:33.266
And here is -- This formatter
also goes the other ways,

00:54:33.586 --> 00:54:34.596
also does parsing.

00:54:34.786 --> 00:54:37.696
So you can get yourself a
formatter and ask for the date

00:54:37.696 --> 00:54:40.116
from a string and it'll
return the date for you.

00:54:40.216 --> 00:54:41.276
So it goes both ways.

00:54:42.626 --> 00:54:46.146
Now by default, this will do
RFC 3339, which is one format;

00:54:46.466 --> 00:54:48.956
however, there are options
that let you specify some

00:54:48.956 --> 00:54:51.926
of the behaviors,
if you need to.

00:54:52.276 --> 00:54:55.096
Now quickly let me cover
some other Foundation updates

00:54:55.096 --> 00:54:56.676
we have.

00:54:56.676 --> 00:55:00.236
URL has a bunch of
new properties,

00:55:00.646 --> 00:55:04.276
such as canonical path of
a file and a bunch more,

00:55:04.276 --> 00:55:06.566
like whether a volume
is encrypted and so on.

00:55:06.566 --> 00:55:08.746
You can read all about
these in the release notes.

00:55:09.046 --> 00:55:11.206
There's a new class
URLSessionTaskMetrics.

00:55:11.606 --> 00:55:15.486
This class helps you gather
network resource loading

00:55:15.486 --> 00:55:18.406
performance information
so you can actually look

00:55:18.406 --> 00:55:20.936
at the network performance
of your applications.

00:55:21.956 --> 00:55:25.456
PersonNameComponentsFormatter
is an API we added last release.

00:55:26.006 --> 00:55:28.866
As you know, it takes a
person's name and it formats it

00:55:28.916 --> 00:55:30.696
in a locale-appropriate manner.

00:55:31.176 --> 00:55:33.456
Well in this release, it
actually can now parse names.

00:55:33.456 --> 00:55:35.216
So you give it a name
and it will return

00:55:35.216 --> 00:55:37.386
to you the first name,
last name, et cetera

00:55:37.626 --> 00:55:38.796
and it does a pretty good job

00:55:38.796 --> 00:55:42.886
since it uses a statistical
model based on real-world data.

00:55:43.506 --> 00:55:47.986
And finally -- But there are
some tricky names out there.

00:55:47.986 --> 00:55:52.126
So don't get your
hopes up fully.

00:55:52.956 --> 00:55:54.966
And DateComponentsFormatter,

00:55:55.296 --> 00:55:58.426
again this is API we
added last release.

00:55:58.656 --> 00:56:01.386
In addition to the full
style and the short style,

00:56:01.386 --> 00:56:03.976
we now have a brief style
of date that you can format.

00:56:04.236 --> 00:56:06.946
And next release, maybe we'll
add the boxer style as well.

00:56:07.646 --> 00:56:09.336
Okay, so that's it
for Foundation.

00:56:11.406 --> 00:56:13.676
Core data, just a quick
mention of core data.

00:56:13.716 --> 00:56:15.736
You already saw some
API improvements

00:56:15.736 --> 00:56:16.996
in core data with generics.

00:56:16.996 --> 00:56:19.876
There's a bunch more
new APIs in core data,

00:56:19.876 --> 00:56:22.456
such as generational querying,
persistent store description,

00:56:22.786 --> 00:56:26.516
the NSFetchedResultsController
class is now available in OS X

00:56:26.516 --> 00:56:28.776
as well, I'm sorry,
macOS as well.

00:56:29.086 --> 00:56:30.706
You can hear all
about this Friday

00:56:30.706 --> 00:56:32.346
at 10:00 a.m. What's
New in Core Data.

00:56:33.116 --> 00:56:35.526
And one more talk I want
to give a shout out to,

00:56:36.516 --> 00:56:40.016
every year we get up here
and tell you about new APIs,

00:56:40.016 --> 00:56:42.676
new technologies were introduced
and you might not always be

00:56:42.676 --> 00:56:44.776
in a position to adopt
these APIs because you're

00:56:44.776 --> 00:56:46.396
in the middle of something else

00:56:46.466 --> 00:56:48.016
or maybe you wait a
release and so on.

00:56:48.426 --> 00:56:49.896
Well, if you want
to get an overview

00:56:49.896 --> 00:56:53.086
of recent APIs we've
added, APIs are important

00:56:53.176 --> 00:56:55.116
to create modern
applications for the Mac.

00:56:55.236 --> 00:56:56.296
This is talk for you.

00:56:56.556 --> 00:56:59.796
It will cover a lot of topics
and they'll have pointers

00:56:59.796 --> 00:57:01.966
to other sessions of
interest, not just in this WWDC

00:57:01.966 --> 00:57:04.096
but also prior WWDCs as well.

00:57:04.476 --> 00:57:06.506
It's also appropriate
for everyone, all ages,

00:57:06.506 --> 00:57:07.676
all experience levels.

00:57:07.986 --> 00:57:09.456
It's also Friday
at 5:00 o'clock.

00:57:09.456 --> 00:57:11.136
So I hope you're here.

00:57:13.146 --> 00:57:16.476
Okay, so and here is
the webpage you can go

00:57:16.476 --> 00:57:17.466
to for more information.

00:57:17.826 --> 00:57:20.596
Please read the AppKit and
Foundation release notes,

00:57:20.596 --> 00:57:22.586
which you can find in
our developer tool site.

00:57:22.586 --> 00:57:24.816
It's there, just raw
information about a lot

00:57:24.816 --> 00:57:25.886
of the stuff I talked about.

00:57:26.256 --> 00:57:27.926
Here are the related
sessions we mentioned.

00:57:27.926 --> 00:57:29.076
There are of course many more.

00:57:29.506 --> 00:57:30.186
Thank you very much.
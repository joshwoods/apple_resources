WEBVTT

00:00:07.516 --> 00:00:18.500
[ Music ]

00:00:27.016 --> 00:00:27.236
[ Applause ]

00:00:27.236 --> 00:00:30.866
>> Good afternoon, everyone.

00:00:31.776 --> 00:00:34.206
And welcome to Visual
Debugging with Xcode.

00:00:35.226 --> 00:00:38.106
I'm Chris, and I work
on Xcode's debugger UI.

00:00:39.426 --> 00:00:43.136
You know, debugging tools
have come a long way.

00:00:44.676 --> 00:00:46.076
It wasn't all that long ago

00:00:46.306 --> 00:00:48.766
when our debugging tools
looked something like this.

00:00:50.436 --> 00:00:53.356
A little while later,
with advancements in UI,

00:00:53.356 --> 00:00:56.826
our debugging tools began
to look more like this.

00:00:58.976 --> 00:01:00.386
But fast-forward to today,

00:01:00.386 --> 00:01:03.866
and our debugging tools have
become much more powerful while

00:01:03.866 --> 00:01:06.136
at the same time becoming
much easier to use.

00:01:06.626 --> 00:01:08.876
A big part of this is because
the tools are becoming more

00:01:08.876 --> 00:01:11.626
visual, which helps us
to solve problems faster

00:01:11.976 --> 00:01:12.936
and more intuitively.

00:01:13.966 --> 00:01:16.196
Today, my colleagues and
I are going to tell you

00:01:16.196 --> 00:01:18.866
about the latest in Xcode's
visual debugging tools.

00:01:21.496 --> 00:01:24.156
First, a quick overview
of what we'll cover.

00:01:24.926 --> 00:01:27.746
We're going to tell you about a
new feature of Xcode to be able

00:01:27.746 --> 00:01:31.396
to report on issues detected
by the tools at runtime.

00:01:32.226 --> 00:01:35.356
We're going to tell you
about the latest enhancements

00:01:35.356 --> 00:01:36.926
that we've made to
Xcode's view debugger

00:01:37.256 --> 00:01:39.746
and how we've made auto
layout debugging easier

00:01:39.746 --> 00:01:40.486
than ever before.

00:01:41.366 --> 00:01:43.706
We're going to tell you about
a new feature to be able

00:01:43.706 --> 00:01:47.816
to visually debug state machines
and enhancements we've made

00:01:47.816 --> 00:01:51.896
to the FPS performance gauge to
help with debugging SpriteKit

00:01:51.956 --> 00:01:53.586
and SceneKit frame rate issues.

00:01:54.606 --> 00:01:58.076
Finally, we're going to tell you
about a new feature of Xcode --

00:01:58.306 --> 00:01:59.826
a visual memory graph debugger.

00:02:03.916 --> 00:02:05.936
Let's get started by
talking about issues.

00:02:08.936 --> 00:02:10.765
We all know that
build time issues

00:02:10.765 --> 00:02:12.456
such as compiler
warnings, errors,

00:02:12.456 --> 00:02:15.456
and static analysis
issues are well-supported

00:02:15.606 --> 00:02:18.086
by Xcode's user interface
similarly

00:02:18.246 --> 00:02:20.286
for our issues detected
while testing.

00:02:21.466 --> 00:02:24.216
However, the same can't be
said for issues detected

00:02:24.216 --> 00:02:25.596
by our expanding suite

00:02:25.596 --> 00:02:27.756
of runtime debugging
and analysis tools.

00:02:28.406 --> 00:02:32.256
These tools have
been left behind

00:02:32.596 --> 00:02:36.836
with their best option being to
log their output to the console.

00:02:37.176 --> 00:02:38.346
Not the best experience.

00:02:38.856 --> 00:02:40.506
We thought we could
do much better.

00:02:42.446 --> 00:02:45.126
In Xcode 8, we're
introducing runtime issues.

00:02:46.516 --> 00:02:51.796
[ Applause ]

00:02:52.296 --> 00:02:55.316
Runtime issues elevates the
issues detected by the tools

00:02:55.316 --> 00:02:58.276
at runtime to the
same status in the UI

00:02:58.276 --> 00:03:00.576
as traditional build
time issues.

00:03:03.016 --> 00:03:05.346
The Activity Viewer will
display this indicator

00:03:05.346 --> 00:03:07.356
when any runtime
issues are detected,

00:03:07.686 --> 00:03:09.586
along with the number
of issues reported.

00:03:10.836 --> 00:03:13.496
We've enhanced the
Issue Navigator

00:03:13.496 --> 00:03:15.146
with a new runtime scope.

00:03:15.426 --> 00:03:17.726
This separates the
issues detected at runtime

00:03:17.786 --> 00:03:19.546
from the traditional
build time issues

00:03:19.676 --> 00:03:21.216
such as compiler
warnings, errors,

00:03:21.216 --> 00:03:22.696
and static analysis issues.

00:03:26.496 --> 00:03:29.876
So what issues will you expect
to see reported at runtime?

00:03:30.546 --> 00:03:33.026
In Xcode 8, we're
tackling three areas.

00:03:33.656 --> 00:03:36.396
The first -- threading issues.

00:03:37.096 --> 00:03:39.466
Our brand-new Thread
Sanitizer is able

00:03:39.466 --> 00:03:43.316
to detect threading issues in
your application at runtime.

00:03:45.756 --> 00:03:46.946
UI layout issues.

00:03:47.046 --> 00:03:49.516
We've expanded Xcode's
view debugger to be able

00:03:49.516 --> 00:03:52.166
to automatically detect
ambiguous layout issues

00:03:52.346 --> 00:03:53.606
in your app at runtime.

00:03:55.966 --> 00:03:56.616
And memory.

00:03:57.316 --> 00:03:59.256
Our brand-new memory
graph debugger,

00:03:59.256 --> 00:04:01.146
which we'll talk a lot more
about in a few moments,

00:04:01.146 --> 00:04:03.916
is able to automatically
detect leaked memory

00:04:04.126 --> 00:04:05.446
in your application at runtime.

00:04:10.046 --> 00:04:11.286
So, as you heard
about on Monday,

00:04:11.286 --> 00:04:14.486
Xcode's latest runtime sanitizer
is the Thread Sanitizer.

00:04:15.486 --> 00:04:17.906
Thread Sanitizer
helps us to detect

00:04:17.906 --> 00:04:19.986
and better understand
threading issues

00:04:20.026 --> 00:04:21.676
in your applications at runtime.

00:04:22.696 --> 00:04:24.776
It can detect such
issues as data races,

00:04:25.176 --> 00:04:28.426
uses of uninitialized mutexes,
unlocks from the wrong thread,

00:04:28.896 --> 00:04:31.286
thread leaks, and unsafe
calls in signal handlers.

00:04:32.226 --> 00:04:33.736
If any of these issues
are detected,

00:04:33.966 --> 00:04:36.076
they'll be reported
as runtime issues.

00:04:37.336 --> 00:04:39.906
Thread Sanitizer is a powerful
new runtime analysis tool.

00:04:40.316 --> 00:04:43.096
You can learn all about it by
watching the Thread Sanitizer

00:04:43.186 --> 00:04:44.606
and Static Analysis session.

00:04:51.056 --> 00:04:52.686
View debugging is
a great example

00:04:52.686 --> 00:04:55.476
of Xcode's debugging tools
becoming more visual.

00:04:56.146 --> 00:05:01.046
Only in the last couple of
years for debugging UI issues,

00:05:01.046 --> 00:05:04.196
we've gone from having
to read debug output

00:05:04.196 --> 00:05:07.676
in a console like this to this.

00:05:08.086 --> 00:05:11.296
Xcode's visual view debugger
is a much better experience

00:05:11.526 --> 00:05:14.496
for debugging and
understanding visual UI issues.

00:05:15.506 --> 00:05:16.866
If you haven't used it before,

00:05:17.546 --> 00:05:19.176
while Xcode is running
your application,

00:05:20.106 --> 00:05:22.616
just tap the Debug
View Hierarchy button

00:05:22.946 --> 00:05:24.466
down in the Debug Bar.

00:05:25.486 --> 00:05:27.506
Xcode will snapshot
your application,

00:05:28.356 --> 00:05:30.676
snapshot your view
hierarchy, and explode it

00:05:30.676 --> 00:05:32.826
out in an interactive 3D scene.

00:05:33.656 --> 00:05:36.926
From there, you can inspect the
structure of the view hierarchy

00:05:36.986 --> 00:05:40.556
in the 3D canvas and
in the outline view.

00:05:40.906 --> 00:05:43.506
And you can inspect the
properties of all of the views

00:05:43.506 --> 00:05:45.746
and constraints using
the inspectors.

00:05:48.966 --> 00:05:54.316
In Xcode 8, we've made view
debugging -- can you guess?

00:05:54.316 --> 00:05:54.756
Better than ever.

00:05:55.516 --> 00:06:02.546
[ Applause ]

00:06:03.046 --> 00:06:05.226
Snapshots are now
up to 70% faster.

00:06:05.226 --> 00:06:07.086
So you can go from
running your application

00:06:07.376 --> 00:06:08.976
to debugging UI issues
quicker than ever before.

00:06:09.516 --> 00:06:14.656
[ Applause ]

00:06:15.156 --> 00:06:17.246
The rendering of complex layouts

00:06:17.246 --> 00:06:20.256
and transformed views is much
more accurate in Xcode 8.

00:06:20.256 --> 00:06:24.316
And speaking of accuracy, Xcode
can now render blurred view,

00:06:24.316 --> 00:06:27.066
such as visual effect views with
high fidelity in the canvas.

00:06:27.696 --> 00:06:30.506
So what you see in Xcode's
view debugger more accurately

00:06:30.506 --> 00:06:32.786
reflects what you see on device.

00:06:33.106 --> 00:06:35.206
You'll see the blur rendering
improvement land in beta 2.

00:06:36.986 --> 00:06:39.266
We've added conveniences, such
as being able to jump directly

00:06:39.266 --> 00:06:40.906
to the source code
from a view class.

00:06:40.906 --> 00:06:43.576
Just tap the Jump button
in the Object Inspector.

00:06:44.496 --> 00:06:48.506
And navigator filtering is
much more powerful, too.

00:06:48.916 --> 00:06:50.936
You can filter by
any text in a label

00:06:51.336 --> 00:06:53.586
or text in a button's title.

00:06:54.506 --> 00:06:56.656
Or you can filter
by class names,

00:06:56.656 --> 00:06:58.786
and that will include
super class names.

00:06:58.916 --> 00:07:02.796
For example, if you filter by
UI label, you'll get back all

00:07:02.796 --> 00:07:05.616
of the subclasses of UI
label in your view hierarchy.

00:07:06.296 --> 00:07:07.856
You can even filter
by memory address.

00:07:08.146 --> 00:07:10.576
So you can quickly find
that particular view just

00:07:10.576 --> 00:07:11.936
by knowing its address
and memory.

00:07:17.316 --> 00:07:18.586
We've got some great
improvements

00:07:18.586 --> 00:07:20.236
for auto layout debugging
as well.

00:07:20.806 --> 00:07:23.486
We show many more properties
related to auto layout

00:07:23.486 --> 00:07:24.366
in the inspectors,

00:07:25.146 --> 00:07:27.906
and constraints are better
represented in the canvas.

00:07:28.656 --> 00:07:30.596
We now render badges
on constraints

00:07:30.626 --> 00:07:33.716
to represent inequality or
aspect ratio relationships.

00:07:34.096 --> 00:07:36.936
And we render non-required
constraints with dash lines

00:07:36.936 --> 00:07:39.246
so you can easily
differentiate between required

00:07:39.406 --> 00:07:41.256
and non-required
constraints in the canvas.

00:07:42.776 --> 00:07:45.716
But my favorite new feature
for auto layout debugging is

00:07:45.716 --> 00:07:47.546
in conjunction with
runtime issues.

00:07:49.506 --> 00:07:50.556
Xcode is now able

00:07:50.556 --> 00:07:52.916
to automatically detect
ambiguous layout issues

00:07:52.916 --> 00:07:54.876
in your view hierarchy
at runtime.

00:07:57.516 --> 00:08:01.636
[ Applause ]

00:08:02.136 --> 00:08:03.266
So how does this work?

00:08:03.266 --> 00:08:05.156
While snapshotting
your view hierarchy,

00:08:05.156 --> 00:08:07.576
Xcode will inspect every
single view and is able

00:08:07.576 --> 00:08:09.846
to accurately determine if any

00:08:09.846 --> 00:08:11.736
of those views have
ambiguous layouts,

00:08:11.896 --> 00:08:13.816
along with the reason
for the ambiguity.

00:08:14.666 --> 00:08:16.846
If any layout issues
are detected,

00:08:16.846 --> 00:08:20.496
they'll be reported
as runtime issues.

00:08:21.186 --> 00:08:23.056
So you'll see them indicated
in the Activity Viewer,

00:08:23.186 --> 00:08:24.636
and you'll see them listed

00:08:24.636 --> 00:08:26.436
in the Issue Navigator
under runtime.

00:08:28.156 --> 00:08:31.716
Furthermore, the view hierarchy
outline will badge any views

00:08:31.766 --> 00:08:34.926
that have layout issues,
so you can easily spot them

00:08:34.966 --> 00:08:36.996
in the context of the
whole view hierarchy.

00:08:39.376 --> 00:08:43.096
For a selected view, the Size
Inspector will contain details

00:08:43.096 --> 00:08:46.456
of any layout issues, along
with all of the constraints

00:08:46.456 --> 00:08:48.586
that participated in the
layout for that view.

00:08:49.906 --> 00:08:52.126
We're really excited about
Xcode's new ability to be able

00:08:52.126 --> 00:08:54.366
to automatically detect
ambiguous layout issues

00:08:54.366 --> 00:08:54.776
at runtime.

00:08:54.776 --> 00:08:56.266
And I'd love to give you a demo.

00:08:59.416 --> 00:09:00.636
So I have an iPhone here,

00:09:00.876 --> 00:09:02.386
and I've got it connected
to this Mac.

00:09:02.386 --> 00:09:05.736
We've got Xcode up and running
a project called DemoBots.

00:09:06.176 --> 00:09:07.816
That's one of our
sample code projects

00:09:07.816 --> 00:09:10.456
that we've updated
to Swift 3 this year.

00:09:11.456 --> 00:09:13.186
On the right, I'm just
using QuickTime Player

00:09:13.436 --> 00:09:14.946
to stream the device's
screen back

00:09:14.946 --> 00:09:16.246
to the desktop so
we can all see it.

00:09:16.246 --> 00:09:20.146
Our team was tasked with adding
an in-game instruction manual

00:09:20.146 --> 00:09:22.696
to DemoBots, so we implemented
a How To Play screen.

00:09:23.276 --> 00:09:26.366
However, we had some issues that
we found before the session.

00:09:26.456 --> 00:09:28.926
So now is a great opportunity
to debug those issues.

00:09:29.686 --> 00:09:30.456
I'll tap How To Play.

00:09:30.496 --> 00:09:32.246
And this is our How
To Play screen.

00:09:32.886 --> 00:09:33.686
Not so great is it?

00:09:34.426 --> 00:09:36.726
Obviously, we have some
issues, so let's take a look.

00:09:36.726 --> 00:09:40.196
We can see the DemoBots logo at
the back, and there's some sort

00:09:40.196 --> 00:09:41.666
of mangled text rendered on top.

00:09:42.056 --> 00:09:43.616
So we need to debug this.

00:09:43.616 --> 00:09:44.246
Where do we start?

00:09:44.246 --> 00:09:46.196
I'll give you some clues.

00:09:46.936 --> 00:09:49.806
DemoBots is a little arcade
game written in SpriteKit,

00:09:49.806 --> 00:09:53.326
but this screen has been laid
out using UIKit and auto layout.

00:09:53.726 --> 00:09:56.226
So a good place to start
is to look under the hood

00:09:56.226 --> 00:09:59.896
at the structure of the view
hierarchy and all the layouts.

00:09:59.986 --> 00:10:00.826
So let's do that now.

00:10:01.916 --> 00:10:05.226
If I return to Xcode,
down on the bottom,

00:10:05.476 --> 00:10:08.056
we can use the Debug
View Hierarchy button,

00:10:08.626 --> 00:10:10.446
which I'll click now.

00:10:10.526 --> 00:10:12.116
And that pauses the application

00:10:12.236 --> 00:10:13.916
and snapshots the
entire view hierarchy.

00:10:15.006 --> 00:10:18.556
In the editor, we now get back
an accurate representation

00:10:18.556 --> 00:10:19.716
of what we were seeing
on screen.

00:10:20.776 --> 00:10:23.016
And then to look under
the hood at the structure,

00:10:23.076 --> 00:10:24.776
all we need to do is
drag in the canvas

00:10:24.776 --> 00:10:27.046
and we get the whole
view hierarchy exploited

00:10:27.046 --> 00:10:28.796
out for us in the 3D view.

00:10:29.516 --> 00:10:33.546
[ Applause ]

00:10:34.046 --> 00:10:35.886
Here, we can see all
of the views that make

00:10:35.886 --> 00:10:38.776
up this particular screen
-- the window at the back,

00:10:38.776 --> 00:10:41.566
container views, visual
effects view, and then the views

00:10:41.566 --> 00:10:43.536
that make up the How
To Play instructions.

00:10:44.016 --> 00:10:44.966
Let's zoom in on those.

00:10:45.736 --> 00:10:47.396
We see the DemoBots
logo at the back,

00:10:47.396 --> 00:10:49.256
and then a bunch of
labels and images.

00:10:49.786 --> 00:10:53.226
And we quickly get some insight
by panning around the reason

00:10:53.266 --> 00:10:55.036
for the mess we see on screen.

00:10:55.436 --> 00:10:56.466
All of these views
have been laid

00:10:56.466 --> 00:10:58.026
out one on top of the other.

00:10:58.336 --> 00:10:59.296
So we've got a layout issue.

00:10:59.796 --> 00:11:03.106
Now our traditional workflow
would be to inspect each

00:11:03.106 --> 00:11:05.006
of these views and their
constraints and try

00:11:05.006 --> 00:11:06.836
and determine the reason
for the layout issue.

00:11:06.836 --> 00:11:09.226
But in Xcode 8, we
have some additional

00:11:09.226 --> 00:11:10.166
information available.

00:11:10.976 --> 00:11:14.046
Notice up here in the Activity
Viewer Xcode is reporting

00:11:14.046 --> 00:11:15.656
that we have some
runtime issues.

00:11:16.666 --> 00:11:20.396
We could click on that
one, and that would take us

00:11:20.426 --> 00:11:21.396
to the issue navigator.

00:11:22.076 --> 00:11:25.126
But you may also notice
that over here on the left

00:11:25.126 --> 00:11:27.606
in the Debug Navigator,

00:11:27.606 --> 00:11:29.466
Xcode has badged some
of the views for us.

00:11:29.736 --> 00:11:31.966
And that's telling us that
these views have layout issues.

00:11:31.966 --> 00:11:32.996
So let's go straight to here.

00:11:34.296 --> 00:11:35.736
If I select the first view,

00:11:36.316 --> 00:11:38.356
that highlights the view
in the canvas for us.

00:11:38.356 --> 00:11:40.776
And let's open the Size
Inspector for that view

00:11:40.776 --> 00:11:41.586
over here on the right.

00:11:43.066 --> 00:11:43.756
Here, we can see

00:11:43.756 --> 00:11:46.136
under constraints the
reason for the layout issue.

00:11:46.546 --> 00:11:49.396
This view has an
ambiguous vertical position.

00:11:50.136 --> 00:11:52.526
Now that means that auto layout
doesn't have enough information

00:11:52.716 --> 00:11:54.746
to be able to unambiguously
position this view

00:11:54.906 --> 00:11:56.136
in the vertical dimension.

00:11:57.036 --> 00:11:58.566
Typically, constraints
are missing.

00:11:59.456 --> 00:12:01.496
Let's have a look
at the next view.

00:12:02.306 --> 00:12:04.656
That has the same issue --
vertical position is ambiguous.

00:12:05.356 --> 00:12:06.966
And so does the next one.

00:12:06.966 --> 00:12:08.226
If I randomly click
on a few more,

00:12:08.226 --> 00:12:09.626
it looks like they all
have the same problem.

00:12:10.396 --> 00:12:12.556
What I find curious is
the very first sub-view

00:12:12.826 --> 00:12:15.066
in this list is not
badged with an issue.

00:12:15.246 --> 00:12:17.206
So that could be a clue when
we get to the layout code.

00:12:17.966 --> 00:12:18.746
Let's go to that now.

00:12:19.306 --> 00:12:22.316
If I select the Parent
View, which has a class name

00:12:22.316 --> 00:12:25.006
of InstructionsLayoutView,
this is the view responsible

00:12:25.006 --> 00:12:26.636
for laying out this
How To Play screen.

00:12:27.696 --> 00:12:29.676
So let's jump to the
source code for that.

00:12:29.936 --> 00:12:32.816
An easy way to do that
is to select the view.

00:12:32.816 --> 00:12:34.936
And over here on the
right, we will find

00:12:35.026 --> 00:12:38.246
in the Object Inspector a button
where we can jump directly

00:12:38.246 --> 00:12:39.996
to the source code
for that view.

00:12:40.686 --> 00:12:41.396
So we'll do that now.

00:12:41.546 --> 00:12:43.546
We'll close the Inspector
to give us some room.

00:12:44.096 --> 00:12:45.246
And let's take a
look at the source

00:12:45.246 --> 00:12:46.456
for InstructionsLayoutView.

00:12:48.256 --> 00:12:50.976
It starts by iterating
over each of the parts

00:12:50.976 --> 00:12:53.156
of the instructions, which
are just model objects

00:12:53.276 --> 00:12:57.746
which describe section headers,
section paragraphs, and images.

00:12:58.286 --> 00:13:00.996
And the code lays these
out top-to-bottom.

00:13:01.576 --> 00:13:03.896
So for each part, we fix
the view and we add it

00:13:03.896 --> 00:13:04.716
to the view hierarchy.

00:13:05.256 --> 00:13:07.066
Then we have some code
for the horizontal layout.

00:13:07.096 --> 00:13:09.446
But we didn't notice any
issues with horizontal layout,

00:13:09.446 --> 00:13:11.716
so let's skip over that
to the vertical layout.

00:13:12.606 --> 00:13:13.566
Here, we have two paths.

00:13:13.566 --> 00:13:17.276
The first is for the very
first sub-view to constrain it

00:13:17.276 --> 00:13:18.276
to the top of the container.

00:13:18.926 --> 00:13:22.866
Well, we already noted that the
first sub-view wasn't reported

00:13:22.866 --> 00:13:23.816
as having any issues.

00:13:24.156 --> 00:13:26.566
So, that constraint we
assume is set up correctly.

00:13:26.566 --> 00:13:28.456
So let's jump to the other
side of the conditional.

00:13:28.956 --> 00:13:32.616
Here, we're evaluating an
optional previousPartView.

00:13:32.656 --> 00:13:35.906
And if we have it, we assign it
to the local variable above you.

00:13:36.476 --> 00:13:39.966
And then we can constrain each
view to the view above it.

00:13:40.106 --> 00:13:41.736
It looks like this is the
constraint that's missing.

00:13:42.486 --> 00:13:44.556
So let's have a look at
why this conditional is not

00:13:44.966 --> 00:13:46.986
becoming true.

00:13:47.556 --> 00:13:50.596
If we select previousPartView
-- we'll start with that one --

00:13:50.596 --> 00:13:53.356
I'll use Command-A to
select it for search

00:13:53.646 --> 00:13:55.286
and Command-F to
get the Find Bar.

00:13:56.156 --> 00:13:57.706
Let's look for instances
of this variable.

00:13:58.366 --> 00:13:59.996
We see it's defined at the top.

00:14:00.206 --> 00:14:02.606
It's set to "nil" before
answering the fore loop.

00:14:02.956 --> 00:14:04.186
We evaluate it down here,

00:14:04.756 --> 00:14:06.826
and then we evaluate it
again outside of the loop

00:14:06.876 --> 00:14:08.596
to handle the bottom constraint.

00:14:08.636 --> 00:14:10.836
But it looks like we're
never assigning to it.

00:14:11.026 --> 00:14:11.836
So let's quickly fix that.

00:14:11.836 --> 00:14:15.356
So at the end of the loop,
we can set previousPartView

00:14:16.136 --> 00:14:16.986
to the current partView.

00:14:17.066 --> 00:14:18.976
And then on each iteration,

00:14:19.426 --> 00:14:21.206
we'll have the previous
view available,

00:14:21.206 --> 00:14:23.676
which will be assigned
to above you.

00:14:23.676 --> 00:14:27.036
And we'll set up the constraint
from a view to the one above it.

00:14:27.336 --> 00:14:29.016
Let's stop and rerun
it and check our work.

00:14:29.016 --> 00:14:31.286
And I'll bring QuickTime
to the front.

00:14:32.206 --> 00:14:34.416
Just note how much
information Xcode was able

00:14:34.416 --> 00:14:36.476
to give us before
we even got to code.

00:14:37.066 --> 00:14:39.436
We use view debugger to look
under the hood at the structure

00:14:39.436 --> 00:14:40.876
and get some insight
into the problem.

00:14:41.266 --> 00:14:43.526
But more than that,
Xcode proactively told us

00:14:43.526 --> 00:14:46.466
about some layout issues
in our application,

00:14:46.916 --> 00:14:47.946
which views had issues,

00:14:47.946 --> 00:14:50.116
and specifically what
those issues were.

00:14:50.586 --> 00:14:53.186
So that gave us a lot of insight
before we even got to the code,

00:14:53.186 --> 00:14:55.406
so we could quickly
zero-in on the part

00:14:55.406 --> 00:14:56.386
of the code that we needed to.

00:14:57.796 --> 00:14:59.916
Now that our application is
running, I can tap How To Play.

00:15:00.006 --> 00:15:02.076
And there, it looks much better.

00:15:02.386 --> 00:15:03.806
We have a nice-looking
instructions screen.

00:15:05.516 --> 00:15:10.796
[ Applause ]

00:15:11.296 --> 00:15:15.256
So Xcode is now able to
report on issues detected

00:15:15.256 --> 00:15:19.366
at runtime using the same UI as
we did for build time issues.

00:15:20.636 --> 00:15:23.376
Xcode's view debugger has
great enhancements this year,

00:15:23.876 --> 00:15:27.636
including faster snapshotting
and more accurate rendering

00:15:27.676 --> 00:15:30.296
of complex layouts
and blurred views.

00:15:31.696 --> 00:15:32.946
We've got some great enhancement

00:15:32.946 --> 00:15:34.396
for auto layout debugging
as well.

00:15:34.676 --> 00:15:36.536
In particular, Xcode is now able

00:15:36.536 --> 00:15:39.046
to automatically detect
ambiguous layout issues

00:15:39.276 --> 00:15:39.956
at runtime.

00:15:40.716 --> 00:15:43.146
Xcode's view debugger
supports debugging UIs

00:15:43.146 --> 00:15:45.486
on Mac OS, iOS, and tvOS.

00:15:46.186 --> 00:15:47.816
Give it a try with your
projects, and we'd love

00:15:47.816 --> 00:15:49.286
to hear feedback
on how it helps you

00:15:49.286 --> 00:15:50.836
with your debugging workflow.

00:15:51.866 --> 00:15:55.476
And with that, I'd like to
hand over to Tyler who's going

00:15:55.476 --> 00:15:58.676
to tell us about debugging state
machines and frame rate issues.

00:15:59.006 --> 00:15:59.256
Thanks.

00:16:00.516 --> 00:16:04.546
[ Applause ]

00:16:05.046 --> 00:16:05.696
>> Thanks, Chris.

00:16:06.566 --> 00:16:08.356
Today, I'll be showing you a
new way you can enhance your

00:16:08.356 --> 00:16:10.636
debugging experience with
the State Machine Quick Look,

00:16:10.886 --> 00:16:13.476
as well as some additions made
inside the FPS performance gauge

00:16:13.566 --> 00:16:14.326
for Xcode 8.

00:16:15.976 --> 00:16:16.716
Today, we have a number

00:16:16.716 --> 00:16:19.436
of useful Quick Looks already
available inside of Xcode 7,

00:16:19.436 --> 00:16:22.246
and these provide you the
ability to view a wide variety

00:16:22.246 --> 00:16:24.116
of objects live during
your debugging.

00:16:24.116 --> 00:16:26.746
And you can even provide
your own custom Quick Look

00:16:27.146 --> 00:16:28.946
to view objects within your app.

00:16:29.736 --> 00:16:30.856
And now in Xcode 8,

00:16:31.136 --> 00:16:32.876
we're extending our
built-in Quick Looks

00:16:32.876 --> 00:16:34.196
to include state machines.

00:16:34.646 --> 00:16:37.536
So let's first dive into what
exactly a state machine is

00:16:37.536 --> 00:16:40.246
and how you could use
it within your app.

00:16:41.246 --> 00:16:43.886
So, many of you may already be
familiar with GKStateMachine,

00:16:43.886 --> 00:16:46.106
which was part of our release
of GameplayKit last year.

00:16:46.246 --> 00:16:49.066
And it's available on
Mac OS, iOS, and tvOS.

00:16:50.376 --> 00:16:53.276
State machines allow you to more
easily define complex behavior

00:16:53.276 --> 00:16:55.966
by structuring it
as a directed graph.

00:16:55.966 --> 00:16:57.146
And within a state machine,

00:16:57.146 --> 00:16:59.566
you provide discrete
behavior for each state.

00:17:00.276 --> 00:17:02.866
This could be something
as simple as an animation

00:17:02.866 --> 00:17:05.406
that will play, or something
more complex like an AI.

00:17:06.536 --> 00:17:09.046
And then for each state,
you define the conditions

00:17:09.046 --> 00:17:10.886
by which the state
machine will transition

00:17:10.886 --> 00:17:12.276
from one state to another.

00:17:13.915 --> 00:17:16.336
Once assembled, state
machines can produce remarkably

00:17:16.336 --> 00:17:17.556
sophisticated behavior.

00:17:17.806 --> 00:17:21.205
However, they can quickly become
difficult to visualize in code

00:17:21.455 --> 00:17:22.996
as they expand in complexity.

00:17:23.455 --> 00:17:25.546
And simple state machines
can quickly evolve

00:17:25.546 --> 00:17:26.986
into far more elaborate ones.

00:17:27.546 --> 00:17:30.036
In Xcode 7.3, our support

00:17:30.036 --> 00:17:32.706
for debugging state machines was
limited to the current state,

00:17:32.706 --> 00:17:34.096
as well as its transitions.

00:17:34.506 --> 00:17:36.086
However, now in Xcode 8,

00:17:36.256 --> 00:17:38.546
we're able to visualize
the entire state machine

00:17:38.546 --> 00:17:40.476
so that you can see
exactly what's going on.

00:17:41.506 --> 00:17:43.906
This is incredibly useful
whether you're operating

00:17:43.906 --> 00:17:46.896
with very simple state machines
or whether you're working

00:17:46.896 --> 00:17:49.436
with much more complex
state machines.

00:17:50.056 --> 00:17:53.176
With Quick Look, you're able to
quickly debug potential issues

00:17:53.446 --> 00:17:55.116
and evaluate exactly
what's happening

00:17:55.206 --> 00:17:56.356
within your state machines.

00:17:56.926 --> 00:18:01.446
So, now, let's shift our
focus over to performance.

00:18:02.336 --> 00:18:04.806
Any time you're creating any
sort of game or visual app,

00:18:04.936 --> 00:18:06.546
maintaining good
performance is key.

00:18:07.056 --> 00:18:09.836
And in Xcode 8, we've expanded
the FPS performance gauge

00:18:09.836 --> 00:18:12.356
to help you with this.

00:18:12.586 --> 00:18:14.156
Many of you may already
be familiar with parts

00:18:14.156 --> 00:18:16.596
of the FPS performance
gauge from Xcode 7.

00:18:16.906 --> 00:18:19.216
And at the top of the report,
you're provided a number

00:18:19.216 --> 00:18:20.566
of real-time statistics.

00:18:21.586 --> 00:18:23.726
This includes your frame rate,
which is the current number

00:18:23.726 --> 00:18:25.146
of frames being rendered
per second,

00:18:26.076 --> 00:18:28.496
as well as your GPU
utilization to see which parts

00:18:28.496 --> 00:18:31.626
of your GPU are being used
the most, and your frame time

00:18:31.626 --> 00:18:33.486
for both the CPU and the GPU.

00:18:34.226 --> 00:18:35.026
This helps indicate

00:18:35.026 --> 00:18:37.586
to you whether you may be
CPU-bound or GPU-bound.

00:18:40.016 --> 00:18:41.976
Now, in addition to
real-time statistics,

00:18:42.056 --> 00:18:44.676
Xcode 8 now provides
you a timeline history

00:18:44.936 --> 00:18:47.326
of your SpriteKit and
SceneKit's frame time

00:18:47.416 --> 00:18:49.076
for both the CPU and the GPU.

00:18:49.076 --> 00:18:51.586
This is available
on iOS and watchOS.

00:18:52.216 --> 00:18:53.276
And what's great about this is

00:18:53.276 --> 00:18:56.496
that we breakdown your CPU frame
time and its individual parts

00:18:56.496 --> 00:18:59.086
so you're able to see
exactly how much time is spent

00:18:59.086 --> 00:19:01.276
rendering, or running
your update loop,

00:19:01.276 --> 00:19:02.926
or evaluating actions
and physics,

00:19:03.076 --> 00:19:04.576
and even how much
time is spent idle.

00:19:05.126 --> 00:19:08.576
And when your app is
paused, you're able to scroll

00:19:08.576 --> 00:19:10.316
through the history of
your app's performance

00:19:10.316 --> 00:19:11.766
so that you can see
how it evolves

00:19:11.766 --> 00:19:13.006
as you progress through
your app.

00:19:13.006 --> 00:19:15.976
And if there's a particular
sample you're interested in,

00:19:16.256 --> 00:19:18.916
you can dive deeper to
examine finer details on it

00:19:19.486 --> 00:19:21.256
and get some exact timings.

00:19:21.446 --> 00:19:25.976
So let's take a look at how we
can use these within our app.

00:19:43.186 --> 00:19:45.906
So now that we've addressed the
layout issues that we've got.

00:19:46.026 --> 00:19:47.626
In our How To Play
menu, let's go ahead

00:19:47.626 --> 00:19:48.946
and dive into the game itself.

00:19:51.136 --> 00:19:53.246
The objective of our
game is to convert all

00:19:53.246 --> 00:19:56.916
of the corrupted robots within
our computer into good robots.

00:19:57.136 --> 00:19:59.616
And to do this, I have
a beam that can zap them

00:19:59.616 --> 00:20:02.096
and reconfigure them
into good robots.

00:20:02.266 --> 00:20:04.906
Now we see here I've already
got a bad robot trying to come

00:20:04.906 --> 00:20:06.976
after me, so I'll use
my beam to zap him.

00:20:11.236 --> 00:20:12.756
So you see he's been converted

00:20:12.756 --> 00:20:14.686
to a good robot --
indicated with green.

00:20:15.496 --> 00:20:18.346
But I see that we still have
a part of our beam present

00:20:18.346 --> 00:20:20.726
above our character, and
this shouldn't be the case.

00:20:21.466 --> 00:20:23.986
Now since we're using a state
machine to manage the behavior

00:20:23.986 --> 00:20:26.766
of our beam, this
is a good candidate

00:20:26.766 --> 00:20:28.666
to use the State Machine
Quick Look to figure

00:20:28.666 --> 00:20:29.606
out what's going on here.

00:20:30.476 --> 00:20:34.176
So I'll go ahead and pause
our app while I navigate

00:20:34.176 --> 00:20:35.226
to our BeamComponent.

00:20:36.276 --> 00:20:38.186
Now our BeamComponent
is where we create

00:20:38.186 --> 00:20:39.616
and update our state machine

00:20:39.616 --> 00:20:41.586
that manages the
behavior of our beam.

00:20:42.036 --> 00:20:44.156
And I'll add a breakpoint
here on our update loop

00:20:44.406 --> 00:20:45.746
and resume our game
so that we hit

00:20:45.746 --> 00:20:46.906
that break point immediately.

00:20:47.446 --> 00:20:50.596
So now that we're paused,
I can go into debug area

00:20:50.596 --> 00:20:52.626
and find our instance
of the state machine,

00:20:53.026 --> 00:20:53.986
and we can Quick Look it.

00:20:54.196 --> 00:20:57.396
And from here, we can see
the entire state machine.

00:20:58.126 --> 00:21:00.416
In blue, we see the
current state that we're in,

00:21:00.466 --> 00:21:01.956
which is the BeamFiringState.

00:21:02.016 --> 00:21:04.436
And in gray, we see all
of the additional states

00:21:04.436 --> 00:21:05.916
that comprise our state machine.

00:21:06.836 --> 00:21:09.486
Now we also see the transitions
between each of the states.

00:21:09.646 --> 00:21:11.346
And one thing that I've
immediately noticed is

00:21:11.346 --> 00:21:12.876
that we have a number
of transitions

00:21:12.876 --> 00:21:16.206
into our BeamFiringState but we
have no transitions out of it.

00:21:16.206 --> 00:21:18.736
So this means, as soon as we
get into our firing state,

00:21:18.736 --> 00:21:19.886
we have no way of leaving it.

00:21:20.186 --> 00:21:22.856
So let's go ahead and take a
look at our BeamFiringState

00:21:22.856 --> 00:21:23.876
to see what's going on here.

00:21:24.406 --> 00:21:27.766
So I'll remove our breakpoint
and close our debug area

00:21:27.866 --> 00:21:29.506
and switch to our
BeamFiringState.

00:21:30.246 --> 00:21:33.256
Now we'll take a look
at the update loop.

00:21:33.256 --> 00:21:36.246
And I see here we have some
logic to transition both

00:21:36.246 --> 00:21:38.666
into the CoolingState as
well as the IdleState.

00:21:39.586 --> 00:21:40.806
But down here in our method

00:21:40.806 --> 00:21:42.896
where we're checking whether the
state we're trying to transition

00:21:42.896 --> 00:21:45.806
to is valid, we're
always returning false,

00:21:45.946 --> 00:21:48.056
which shouldn't be the case
because we want to transition

00:21:48.056 --> 00:21:49.256
to either cooling or idle.

00:21:50.256 --> 00:21:52.656
So I'll go ahead and fix that by
checking whether the state we're

00:21:52.656 --> 00:21:55.466
trying to transition to is
either of the two valid ones.

00:21:55.886 --> 00:21:57.296
And we'll go ahead
and rerun our game

00:21:57.336 --> 00:21:58.876
and check whether this
has addressed the issue

00:21:58.876 --> 00:21:59.556
that we were seeing.

00:22:00.816 --> 00:22:02.866
Now when we transition
to the FiringState

00:22:02.866 --> 00:22:05.856
and meet the conditions to exit
it, we should properly be able

00:22:05.856 --> 00:22:07.886
to transition back
into our IdleState.

00:22:09.236 --> 00:22:12.566
So I'll jump back into the
game and go ahead and fire

00:22:12.566 --> 00:22:15.776
at the corrupted robot to
convert him into a good one.

00:22:16.186 --> 00:22:19.996
And we'll see the beam is no
longer present above our player,

00:22:20.116 --> 00:22:21.706
so it looks like we've
addressed the issue.

00:22:22.526 --> 00:22:24.936
So now we've also noticed
a performance issue

00:22:24.936 --> 00:22:26.086
within our game.

00:22:26.086 --> 00:22:28.686
We have a number of ground
robots here on the bottom.

00:22:28.686 --> 00:22:30.836
And I notice that when
we get attacked by them,

00:22:31.096 --> 00:22:32.906
our performance drops
dramatically.

00:22:33.966 --> 00:22:35.896
So I'll switch to our
FPS performance gauge

00:22:35.896 --> 00:22:38.426
so that we can see our
performance live while

00:22:38.426 --> 00:22:39.116
we're running.

00:22:39.746 --> 00:22:41.406
And you can see on the
right here we indicate

00:22:41.406 --> 00:22:43.016
to you your target frame time.

00:22:43.346 --> 00:22:47.006
And in our case, it's 16.6
milliseconds, which corresponds

00:22:47.006 --> 00:22:49.376
to maintaining a frame rate
of 60 frames per second.

00:22:50.306 --> 00:22:52.226
We can also see that
a good amount

00:22:52.226 --> 00:22:53.796
of our time is spent rendering,

00:22:53.796 --> 00:22:55.506
as well as running
our client update,

00:22:55.856 --> 00:22:58.426
and we've got a good amount of
wiggle room of CPU idle time.

00:22:58.986 --> 00:23:02.236
So I'll go into our game
and move to the right here

00:23:02.236 --> 00:23:04.996
where we have an enemy robot,
and I'll let him hit me

00:23:04.996 --> 00:23:07.036
so that we can try to reproduce
this performance issue.

00:23:07.286 --> 00:23:09.996
So now I'll switch back
to our performance gauge

00:23:09.996 --> 00:23:11.806
to see what's going on
within our update loop.

00:23:12.386 --> 00:23:13.706
And I'm noticing
that quite a bit

00:23:13.706 --> 00:23:15.536
of time is spent
evaluating actions.

00:23:15.536 --> 00:23:18.196
In fact, now our frame rate is
dropping quite dramatically.

00:23:18.976 --> 00:23:20.516
So I'll go ahead
and pause our app

00:23:20.516 --> 00:23:22.616
so that we can take a closer
look at what's going on.

00:23:23.306 --> 00:23:26.446
Now that we're paused, I
can scroll back in time

00:23:26.446 --> 00:23:27.956
within our frame breakdown

00:23:27.956 --> 00:23:30.316
to see our frame time
previously within our app.

00:23:30.776 --> 00:23:32.356
In fact, here we can see
the time that we were

00:23:32.356 --> 00:23:35.246
in the main menu where we spent
a little bit of time rendering

00:23:35.246 --> 00:23:36.566
but most of it was spent idle,

00:23:36.596 --> 00:23:39.056
as well as the breakdown we
were seeing within our game.

00:23:39.666 --> 00:23:42.406
And now when we are seeing
performance issues, I can click

00:23:42.406 --> 00:23:44.246
and hold to examine details

00:23:44.246 --> 00:23:46.676
for the performance
issue we were seeing.

00:23:47.306 --> 00:23:51.286
Here, I see we're getting
36.2 millisecond frame time,

00:23:51.286 --> 00:23:54.676
and 71% of that is spent
evaluating actions.

00:23:54.676 --> 00:23:57.196
So what that tells me
is there may be one

00:23:57.196 --> 00:23:58.906
of two issues present
within our game.

00:23:59.526 --> 00:24:00.746
We could have a single action

00:24:00.746 --> 00:24:03.426
within our scene that's taking
an exceedingly large amount

00:24:03.426 --> 00:24:05.926
of time to evaluate, or we
could have a large number

00:24:05.926 --> 00:24:08.026
of actions that's
bottlenecking our update loop.

00:24:08.226 --> 00:24:12.306
So now I know where within our
update loop we're having issues.

00:24:15.816 --> 00:24:18.276
So we've seen how we can use
the State Machine Quick Look

00:24:18.336 --> 00:24:20.696
to debug an issue we were
seeing within our game,

00:24:21.046 --> 00:24:23.206
as well as how the FPS
performance gauge can show us

00:24:23.206 --> 00:24:25.936
where exactly within our update
loop we're having issues.

00:24:26.856 --> 00:24:28.756
I'd like to now invite
up Daniel Delwood

00:24:28.756 --> 00:24:31.686
who will show you a new memory
graph debugger that we can use

00:24:31.686 --> 00:24:34.336
to determine where our issue
with actions originates

00:24:34.336 --> 00:24:35.866
from so we can fix it.

00:24:36.516 --> 00:24:42.966
[ Applause ]

00:24:43.466 --> 00:24:43.986
>> Thank you, Tyler.

00:24:45.066 --> 00:24:46.216
So I'm very excited to tell you

00:24:46.216 --> 00:24:48.536
about the new memory
graph debugger in Xcode 8.

00:24:48.846 --> 00:24:51.466
And like the view debugger,

00:24:51.696 --> 00:24:54.036
it's a tool for understanding
your applications better.

00:24:54.186 --> 00:24:57.216
So just as the view debugger
understands your view hierarchy,

00:24:57.216 --> 00:25:00.496
the memory graph debugger helps
you understand your memory

00:25:00.496 --> 00:25:02.006
and how it's referencing
each other.

00:25:02.576 --> 00:25:05.976
The core question though that
it's trying to answer is -

00:25:06.396 --> 00:25:09.126
why does a certain object
still exist on your heap?

00:25:10.096 --> 00:25:12.296
Now objects reference
each other.

00:25:12.296 --> 00:25:16.726
And, you know, this is more and
more a question of references

00:25:16.726 --> 00:25:17.956
and annotation these days

00:25:18.306 --> 00:25:19.896
in an automatic
reference-guiding world.

00:25:20.686 --> 00:25:24.936
So where can we go from
having this problem of objects

00:25:24.936 --> 00:25:27.356
that we don't want, objects
that are leaked, or abandoned?

00:25:28.266 --> 00:25:29.346
Well, there's some
command-line tools

00:25:29.346 --> 00:25:31.466
that can help, such as Heap.

00:25:32.146 --> 00:25:34.916
And what Heap does is it
snapshots your process,

00:25:35.256 --> 00:25:37.876
looks through it for a
summary of the different types

00:25:37.946 --> 00:25:41.256
and the counts of objects
that are in your process.

00:25:41.256 --> 00:25:43.816
And you can even use the
"addresses" flag to look

00:25:43.816 --> 00:25:45.706
for a specific type of object

00:25:45.706 --> 00:25:47.806
and get a list of
those instances.

00:25:48.366 --> 00:25:50.736
Once you have an instance
you're interested in,

00:25:51.316 --> 00:25:53.366
leaks is where you go
for the connectivity kind

00:25:53.366 --> 00:25:55.746
of information of, well,
is it unreferenced?

00:25:55.746 --> 00:25:56.346
Is it leaked?

00:25:56.846 --> 00:25:59.956
Or is there some path
from a global location

00:25:59.996 --> 00:26:03.906
in your application that goes
all the way down to your object?

00:26:05.136 --> 00:26:07.156
Now, at any point in
this investigation,

00:26:07.156 --> 00:26:08.946
you might need some
further detail,

00:26:08.946 --> 00:26:10.496
such as the allocation
stack trace.

00:26:10.856 --> 00:26:12.176
And, that, you can get
with malloc-history.

00:26:12.986 --> 00:26:15.586
And this is all not a
very visual experience,

00:26:15.586 --> 00:26:18.006
and that's why we pulled all of
these three tools into the IDE

00:26:18.006 --> 00:26:20.066
for the memory graph debugger.

00:26:20.066 --> 00:26:24.146
And so just a quick overview of,
you know, how this is laid out.

00:26:24.646 --> 00:26:26.986
On the left, the Navigator is
where you get that heap-type

00:26:26.986 --> 00:26:29.306
of information to
start your analysis.

00:26:30.036 --> 00:26:31.476
The center editor area is

00:26:31.476 --> 00:26:33.786
where the connectivity
information gets presented.

00:26:34.406 --> 00:26:37.526
And on the right -- that's
what we're showing you now --

00:26:37.606 --> 00:26:40.446
the allocation stack
trace via the Inspector.

00:26:40.976 --> 00:26:43.396
So with that, I'd just like to
jump right back into the demo

00:26:44.156 --> 00:26:46.646
where Tyler left off and
see if we can take a look

00:26:46.646 --> 00:26:48.466
at those action problems
that he was seeing.

00:26:48.916 --> 00:26:49.306
All right.

00:26:49.506 --> 00:26:55.456
So here we are with the FPS
performance gauge, looking at,

00:26:55.696 --> 00:26:57.236
you know, actions
that are probably

00:26:57.236 --> 00:26:59.576
at fault here in
our application.

00:27:00.036 --> 00:27:01.446
So I'm just going to jump right

00:27:01.446 --> 00:27:04.646
in by choosing the Memory
Graph Debugger button

00:27:05.136 --> 00:27:07.506
in the Debug Menu Bar.

00:27:08.136 --> 00:27:09.806
And on the left here,

00:27:10.006 --> 00:27:14.386
the Navigator shows me
my application with all

00:27:14.386 --> 00:27:17.086
of the different types
that are allocated in it.

00:27:17.316 --> 00:27:20.206
And so they're broken
down by a hierarchy

00:27:20.206 --> 00:27:21.896
of module and then type.

00:27:21.896 --> 00:27:24.256
And then under each of
these, there's an instance.

00:27:25.136 --> 00:27:28.266
And so, in this case, I'm kind

00:27:28.266 --> 00:27:30.056
of interested in
searching my heap.

00:27:30.256 --> 00:27:31.386
And it's very easy to do.

00:27:31.386 --> 00:27:34.616
I can just type into the filter,
and I'll look for actions.

00:27:35.906 --> 00:27:36.976
So here we are.

00:27:37.036 --> 00:27:38.946
We've got types in SpriteKit.

00:27:38.946 --> 00:27:42.846
And we see that, yeah, we
have a lot of actions -- 559.

00:27:43.336 --> 00:27:46.296
So it's probably that we
have too many actions and not

00:27:46.296 --> 00:27:49.086
that we have some
long-running single actions.

00:27:50.776 --> 00:27:52.666
So let me select one
of these objects.

00:27:53.116 --> 00:27:57.566
And the editor changes to show
me the answer to the question

00:27:57.566 --> 00:27:59.696
of why this object
is still around.

00:28:00.116 --> 00:28:02.296
In this case, it's showing
me a root analysis graph

00:28:02.296 --> 00:28:07.146
which allows me to trace the
object I've selected back

00:28:07.186 --> 00:28:09.416
to the left, back to the
roots of my application.

00:28:09.946 --> 00:28:11.316
So I can see that
it's referenced

00:28:11.316 --> 00:28:14.136
by an SKC sequence by repeat.

00:28:14.196 --> 00:28:15.776
There's an array
holding onto this.

00:28:15.876 --> 00:28:19.346
And I can even disclose
further to see

00:28:19.346 --> 00:28:22.046
that here we've got an
SKNode with some actions.

00:28:22.356 --> 00:28:25.086
So, OK, it's part of
this SKNode actions list.

00:28:25.516 --> 00:28:29.346
I can click on this and
try Quick Looking it.

00:28:29.346 --> 00:28:33.886
If I want to take some
more looks at this action,

00:28:34.316 --> 00:28:37.056
I can select it and
pull in the Inspector.

00:28:38.186 --> 00:28:41.036
Now the Inspector shows
me some memory details,

00:28:41.036 --> 00:28:44.746
such as the class name,
the address, the hierarchy

00:28:44.746 --> 00:28:47.786
if it is a sub-class
of some other objects.

00:28:48.306 --> 00:28:50.736
What I'm interested in is
where this action was created

00:28:50.736 --> 00:28:51.976
so I can jump to there.

00:28:52.446 --> 00:28:57.876
I can go ahead and collapse this
stack trace and jump to my code.

00:28:58.016 --> 00:29:02.036
And here, we see I've got this
function -- refreshHurtAction.

00:29:03.066 --> 00:29:06.166
All right, so it's
running a HurtAction.

00:29:06.346 --> 00:29:11.696
I can use the Quick Help to
see that this action is added

00:29:11.696 --> 00:29:13.986
to the list of actions
on the node.

00:29:14.816 --> 00:29:18.616
But I actually wanted to only
have a single-player action

00:29:18.616 --> 00:29:20.916
and make sure that this was
replacing my previous actions.

00:29:21.376 --> 00:29:22.676
So it's a pretty simple fix.

00:29:22.676 --> 00:29:25.406
I'm just going to use
the withKey variant here

00:29:25.506 --> 00:29:27.886
and replace the player action.

00:29:28.526 --> 00:29:33.206
And the Quick Help
will show me that, yes,

00:29:33.286 --> 00:29:35.036
this is actually the
one I was wanting.

00:29:35.166 --> 00:29:37.296
If an action using the same
key is already running,

00:29:37.296 --> 00:29:38.766
it is removed before
the action is added.

00:29:39.066 --> 00:29:44.926
Great. So that's a pretty simple
way to jump to an investigation

00:29:44.926 --> 00:29:46.286
about a specific type.

00:29:46.346 --> 00:29:48.006
But one of the other
things I noticed

00:29:48.006 --> 00:29:51.106
when I hit the Memory
Graph Debugging button is

00:29:51.106 --> 00:29:54.416
that the Runtime Issues
Navigator alerted me

00:29:54.416 --> 00:29:55.116
to some issues.

00:29:55.376 --> 00:29:56.606
So I can click on that.

00:29:56.606 --> 00:30:00.336
And now I'm taken to the
new Runtime Issues Navigator

00:30:00.926 --> 00:30:04.226
which has a bunch of leaks that
were reported in my application.

00:30:05.256 --> 00:30:09.226
So I'll start out with a type
that is defined in my module --

00:30:09.336 --> 00:30:11.266
say, this LoadSceneOperation.

00:30:12.626 --> 00:30:15.096
If I select it, now the
graph isn't showing me

00:30:15.096 --> 00:30:16.166
that same style.

00:30:16.396 --> 00:30:18.666
It's showing me a
reference cycle,

00:30:19.296 --> 00:30:22.006
which is because this
is a leaked object.

00:30:22.006 --> 00:30:25.166
It's not reachable from those
locations in my application.

00:30:25.426 --> 00:30:28.116
And I need to find
out what objects

00:30:28.186 --> 00:30:30.806
in the leaked set are
referencing each other.

00:30:31.846 --> 00:30:35.546
So looking at this
quickly, I have an operation

00:30:35.546 --> 00:30:36.876
with some internal state.

00:30:37.156 --> 00:30:39.186
It's referencing a
completion block.

00:30:39.676 --> 00:30:44.026
And then this has some
captures as part of that block

00:30:44.086 --> 00:30:46.196
that strongly referenced
my LoadSceneOperation.

00:30:46.746 --> 00:30:47.086
Interesting.

00:30:48.366 --> 00:30:51.546
So if I click on the block,
I can see the back trace

00:30:51.546 --> 00:30:54.686
and go immediately there.

00:30:54.916 --> 00:30:56.706
And here we are --

00:30:56.706 --> 00:30:58.596
my LoadSceneOperation
completion block.

00:30:58.596 --> 00:31:01.516
I'm even using a capture
list for "unowned self".

00:31:02.096 --> 00:31:04.756
But the graph showed me that
"self" wasn't the problem.

00:31:04.756 --> 00:31:08.806
It was the LoadSceneOperation
capturing itself right there

00:31:09.036 --> 00:31:09.836
within the block.

00:31:11.536 --> 00:31:13.486
So it's a pretty
easy fix to make.

00:31:13.736 --> 00:31:17.466
I just need to capture
it unowned

00:31:18.296 --> 00:31:21.826
and I can get going again.

00:31:23.296 --> 00:31:26.626
But, unfortunately, that's
not quite the solution here.

00:31:27.056 --> 00:31:28.756
Because, since it's
a completion block,

00:31:28.756 --> 00:31:31.166
my LoadSceneOperation
is just about done.

00:31:31.616 --> 00:31:33.836
And so once it executes
this block here,

00:31:34.266 --> 00:31:36.816
the LoadSceneOperation is
going to end its lifecycle

00:31:36.956 --> 00:31:38.556
and it won't be around
for much longer.

00:31:39.036 --> 00:31:41.366
This means that when I dispatch
async back to the main queue,

00:31:42.616 --> 00:31:45.106
this LoadSceneOperation
may no longer be valid

00:31:45.106 --> 00:31:46.066
and I'm going to get a crash.

00:31:46.876 --> 00:31:50.466
So it just goes to show that
these captures can be tricky

00:31:50.466 --> 00:31:54.266
at times and require a
little bit of investigation.

00:31:54.636 --> 00:31:57.166
And hopefully the memory
graph debugger will help you

00:31:57.736 --> 00:31:58.836
in your investigations as well.

00:31:59.516 --> 00:32:05.996
[ Applause ]

00:32:06.496 --> 00:32:08.436
So, let's talk a little bit more

00:32:08.436 --> 00:32:10.936
about leaked and
abandoned memory.

00:32:11.146 --> 00:32:15.606
The memory graph debugger is a
debugger mode, and so it pauses

00:32:15.606 --> 00:32:17.466
to inspect your target
application.

00:32:17.826 --> 00:32:19.526
This is so your application
doesn't keep going

00:32:19.526 --> 00:32:22.026
and changing its state, and
you can get a consistent view

00:32:22.026 --> 00:32:22.586
of the world.

00:32:22.986 --> 00:32:24.696
It also lets you do
things like Quick Look

00:32:24.696 --> 00:32:27.686
or PO different objects as you
go through your investigation,

00:32:27.776 --> 00:32:30.226
and it's available on
all of our platforms.

00:32:31.146 --> 00:32:32.516
Now, as I showed in the demo,

00:32:32.516 --> 00:32:33.596
there's two different
graph styles.

00:32:34.136 --> 00:32:37.266
And the first one is that
root paths graph style

00:32:37.646 --> 00:32:39.276
which shows you for
referenced memory --

00:32:39.566 --> 00:32:40.496
maybe you've abandoned it --

00:32:41.116 --> 00:32:45.416
how are different roots in
your application like globals

00:32:45.456 --> 00:32:47.806
and currently-running threads
referencing that memory.

00:32:48.606 --> 00:32:50.286
Now with the progressive
disclosure model,

00:32:50.286 --> 00:32:52.506
it lets you work back
from your objecst

00:32:52.636 --> 00:32:55.846
to different intermediate
objects and find the reference

00:32:55.926 --> 00:32:57.356
that should no longer be there.

00:32:58.466 --> 00:33:00.806
For unreferenced
memory or leaked memory,

00:33:01.196 --> 00:33:02.586
that's when you see
the cycles view.

00:33:02.896 --> 00:33:07.716
And the goal there is to help
show you what is strongly

00:33:07.716 --> 00:33:09.146
referencing itself.

00:33:09.146 --> 00:33:11.986
And it'll let you figure out,
again, a reference problem.

00:33:13.826 --> 00:33:17.156
So, for stack logging
integration that you saw

00:33:17.156 --> 00:33:22.486
in the Inspector, it's not
quite free to record all

00:33:22.486 --> 00:33:24.356
of the mallocs and frees
in your application.

00:33:24.606 --> 00:33:26.916
And so this is a diagnostic
that you'll need to opt into.

00:33:27.706 --> 00:33:32.036
Just going to the Scheme Editor
and selecting MallocStackLogging

00:33:32.036 --> 00:33:34.906
in the Diagnostics Tab
is enough to enable it.

00:33:34.906 --> 00:33:38.006
And it will record, again, all
of the mallocs and frees to disk

00:33:38.286 --> 00:33:39.596
so you can look them up later.

00:33:40.626 --> 00:33:43.576
But for memory graph debugging,
you don't really need all

00:33:43.576 --> 00:33:44.766
of the malloc and frees.

00:33:44.766 --> 00:33:46.306
And previous lifetimes

00:33:46.306 --> 00:33:49.336
of a malloc block just
aren't usually that useful.

00:33:49.886 --> 00:33:56.206
So, new in our current OSs is
a Live Allocations Only Mode.

00:33:56.246 --> 00:34:00.986
And so this has a lower
overhead, and it also allows you

00:34:01.056 --> 00:34:03.616
to get this rich information
while you're memory

00:34:03.616 --> 00:34:04.226
graph debugging.

00:34:04.736 --> 00:34:09.116
So this will set the "lite"
flag to MallocStackLogging

00:34:09.525 --> 00:34:10.985
in target environment.

00:34:13.436 --> 00:34:17.005
So one other thing
that you may enjoy

00:34:17.005 --> 00:34:18.906
about memory graph debugging is

00:34:18.956 --> 00:34:21.386
that we've introduced a
.memgraph file format.

00:34:21.876 --> 00:34:24.005
Now, sometimes you'll
be debugging an issue

00:34:24.005 --> 00:34:26.956
and you won't have the time
to really dive into it.

00:34:27.326 --> 00:34:30.056
And so you may want to save
this off or have other engineers

00:34:30.056 --> 00:34:31.545
on your team take
a look as well.

00:34:31.826 --> 00:34:35.116
So, from Xcode, you can
actually go to the File menu

00:34:35.286 --> 00:34:37.376
and select Export Memory Graph.

00:34:37.806 --> 00:34:39.406
And what it'll do
is save out all

00:34:39.406 --> 00:34:41.786
of the connectivity information
and heap information,

00:34:42.005 --> 00:34:43.496
as well as some VM statistics

00:34:43.496 --> 00:34:45.686
about your application
to a file.

00:34:45.956 --> 00:34:47.976
Then at some later time,
you can just double-click,

00:34:48.116 --> 00:34:52.366
load that file in the Xcode, and
take a look at the memory graph.

00:34:53.056 --> 00:34:55.216
Now this does mean that there's
no process in the debugger.

00:34:55.216 --> 00:34:59.326
So you can't get back traces,
or Quick Look or PO the objects.

00:34:59.326 --> 00:35:00.996
But it's still a very
powerful technique

00:35:00.996 --> 00:35:03.506
for an app analyzing
after the fact.

00:35:04.736 --> 00:35:06.466
Now if you want to build this

00:35:06.466 --> 00:35:08.576
into your continuous
integration,

00:35:09.546 --> 00:35:11.656
we've actually got some
options from the command line.

00:35:12.366 --> 00:35:16.216
So you can just run
leaks-outputGraph, pick a path,

00:35:16.516 --> 00:35:18.826
and save out a .memgraph
file for later.

00:35:20.106 --> 00:35:23.896
So leaks, vmmap, and heap have
all been enhanced to read this.

00:35:24.516 --> 00:35:31.006
[ Applause ]

00:35:31.506 --> 00:35:33.346
All right, now the fun part.

00:35:33.346 --> 00:35:36.006
Let's talk about some usage tips
here because this is all built

00:35:36.006 --> 00:35:37.786
on the leaks infrastructure.

00:35:38.446 --> 00:35:40.526
Now what this means is
the graph is conservative.

00:35:41.286 --> 00:35:45.356
We're trying very, very
hard not to report things

00:35:45.356 --> 00:35:46.366
as leaked when they're not.

00:35:46.366 --> 00:35:50.266
And so in that attempt
to avoid false positives,

00:35:51.026 --> 00:35:52.566
there may be some
extraneous references

00:35:52.606 --> 00:35:53.476
that you see in the graph.

00:35:54.486 --> 00:35:59.136
Now these references will show
up gray for being unknown.

00:35:59.206 --> 00:36:01.156
They may be valid
references, they may not.

00:36:01.476 --> 00:36:04.456
We may not just have metadata
available to the tool.

00:36:04.846 --> 00:36:08.986
And so take them
with a grain of salt

00:36:08.986 --> 00:36:10.276
as you're reading these graphs.

00:36:10.786 --> 00:36:13.486
Now one thing you can do
to improve the accuracy is

00:36:13.486 --> 00:36:14.456
to enable Malloc Scribble,

00:36:14.586 --> 00:36:16.926
which is another
diagnostic in this scheme.

00:36:17.406 --> 00:36:20.456
And this will mean that
when allocation are free,

00:36:20.816 --> 00:36:23.716
it will write over the
memory so that you don't have

00:36:23.976 --> 00:36:27.766
that uninitialized
memory in that new block.

00:36:29.156 --> 00:36:32.146
So for references that are known
to be strong, these will show

00:36:32.146 --> 00:36:33.526
up as bold in the graph.

00:36:33.626 --> 00:36:37.736
And Swift 3 actually has
a lot more reflection

00:36:37.736 --> 00:36:39.206
metadata available.

00:36:39.686 --> 00:36:43.896
And so I encourage
you to use this

00:36:43.996 --> 00:36:47.436
because it definitely is a
lot more accurate in terms

00:36:47.436 --> 00:36:49.566
of understanding
captures and references.

00:36:50.616 --> 00:36:51.986
And finally, I should put

00:36:51.986 --> 00:36:53.636
out that the memory
graph debugger requires

00:36:53.636 --> 00:36:55.736
that you temporarily
turn off sanitizers

00:36:55.886 --> 00:36:58.426
like Address Sanitizer
or Thread Sanitizer.

00:36:59.716 --> 00:37:01.516
So this is a lot of information.

00:37:02.316 --> 00:37:04.386
Where is a great place to get
started with your application?

00:37:05.186 --> 00:37:07.146
Well, validate your
expectations.

00:37:07.326 --> 00:37:10.676
Are there more objects of a
certain type than you expect?

00:37:11.266 --> 00:37:13.896
Are objects being
deallocated when you expect?

00:37:14.506 --> 00:37:18.016
Are there any leaks
in your types as well?

00:37:18.766 --> 00:37:20.546
Once you find an object
that you're interested

00:37:20.546 --> 00:37:23.176
in investigating, then
the goal is to find a path

00:37:23.506 --> 00:37:25.646
that shouldn't be there
holding onto your object.

00:37:26.166 --> 00:37:29.076
And two very common patterns

00:37:29.076 --> 00:37:32.036
that you'll find are
strong captures from blocks

00:37:32.036 --> 00:37:37.396
and closures, or potentially
even references upward

00:37:37.436 --> 00:37:41.246
in your graph that need to be
marked as "weak" or "unowned".

00:37:42.496 --> 00:37:45.426
So, that's a lot of information.

00:37:46.056 --> 00:37:50.886
But I just want to thank
you very much for listening

00:37:50.886 --> 00:37:52.266
to our information about new

00:37:52.266 --> 00:37:54.746
and improved visual
tools in Xcode 8.

00:37:54.926 --> 00:37:56.256
We're really excited
about things

00:37:56.306 --> 00:38:00.146
like the better visual debugging
with the view debugger,

00:38:00.416 --> 00:38:03.746
with FPS gauge, and
memory graph debugging.

00:38:04.126 --> 00:38:06.736
So go out, try them
out in your app today,

00:38:06.736 --> 00:38:08.396
and solve a lot of issues.

00:38:09.516 --> 00:38:12.500
[ Applause ]
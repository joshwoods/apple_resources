WEBVTT

00:00:10.430 --> 00:00:11.300
Welcome.

00:00:11.350 --> 00:00:14.470
This is Cocoa Interprocess
Communication with XPC.

00:00:14.580 --> 00:00:16.490
My name is Tony Parker and
I am a software engineer on

00:00:16.490 --> 00:00:17.300
the Cocoa Frameworks team.

00:00:17.300 --> 00:00:21.200
So, first we're going to start
with a brief history lesson.

00:00:21.290 --> 00:00:25.700
So, back when dinosaurs roamed the
earth programming computers,

00:00:25.760 --> 00:00:28.150
they worked on machines that
looked a lot like this one.

00:00:28.540 --> 00:00:31.300
They had a single core and a single CPU.

00:00:31.300 --> 00:00:33.570
So,
we made our software have architecture

00:00:33.570 --> 00:00:35.300
to match with a single thread.

00:00:35.300 --> 00:00:37.810
Now,
this architecture worked well for a long

00:00:37.810 --> 00:00:40.230
time until something started happening.

00:00:40.300 --> 00:00:44.290
CPUs started multiplying
instead of just getting faster.

00:00:44.290 --> 00:00:47.160
And at that point,
our architecture of a single thread

00:00:47.300 --> 00:00:51.300
for a single CPU started to break
down and we needed to make a change.

00:00:51.300 --> 00:00:53.510
And that change, of course,
was a move from

00:00:53.630 --> 00:00:57.300
single-threaded applications
to multi-threaded applications.

00:00:57.300 --> 00:00:59.860
And this was a challenge,
but technologies like

00:00:59.920 --> 00:01:01.300
GCD were there to help.

00:01:01.300 --> 00:01:04.580
And it wasn't something that our
users could immediately see just

00:01:04.580 --> 00:01:08.300
by looking at the application
that had made this transition.

00:01:08.300 --> 00:01:10.300
But it was still something
that they appreciated.

00:01:10.300 --> 00:01:13.560
Their applications were more responsive
and they took better advantage

00:01:13.570 --> 00:01:15.300
of the hardware that they bought.

00:01:17.240 --> 00:01:20.780
So today we're facing a
similar challenging transition.

00:01:20.870 --> 00:01:25.620
And that is from a status quo like this,
where we have a multi-user system.

00:01:25.690 --> 00:01:30.180
Now, you see that we have had for a long
time barriers between these users.

00:01:30.320 --> 00:01:34.800
So somebody else can't get to my data,
and I can't get to Roots data.

00:01:35.230 --> 00:01:39.810
But, we're finding that today's systems
are really used by one person.

00:01:39.890 --> 00:01:43.120
And, although they're protected
from somebody else,

00:01:43.180 --> 00:01:46.700
all of their critical files,
their contacts, their photos,

00:01:46.800 --> 00:01:49.270
their personal data,
is all accessible by any

00:01:49.270 --> 00:01:52.420
application that runs as their user.

00:01:53.980 --> 00:01:57.800
To understand why this is a problem,
let's imagine an OS where every task

00:01:57.800 --> 00:02:00.190
shares just one chunk of memory.

00:02:00.230 --> 00:02:03.530
In fact, some OSs have behaved
this way in the past.

00:02:03.650 --> 00:02:05.280
So what we'll do is
we'll just split it up.

00:02:05.480 --> 00:02:08.830
So this part here is
for writing my diary.

00:02:08.830 --> 00:02:11.840
And this part over here is for
displaying my vacation photos.

00:02:11.880 --> 00:02:15.090
And then the part in the middle will just
leave for executing some JavaScript that

00:02:15.090 --> 00:02:17.040
we downloaded from the Internet just now.

00:02:17.070 --> 00:02:20.340
And we'll have each task just pinky
swear that they're not going to

00:02:20.340 --> 00:02:24.040
touch each other's memory or any
data that the other task is using.

00:02:24.060 --> 00:02:25.710
Because they're all executing
in the same memory space,

00:02:25.710 --> 00:02:27.080
of course, that's completely possible.

00:02:27.080 --> 00:02:29.440
We'll just, you know,
take them at their word.

00:02:29.490 --> 00:02:31.290
Well, clearly that's a bad idea.

00:02:31.370 --> 00:02:36.080
What we really want is those barriers
back and have each of these tasks

00:02:36.250 --> 00:02:39.620
to have just the level of permission
that it needs to do its job.

00:02:39.760 --> 00:02:44.600
So we have barriers like this,
and they are process boundaries.

00:02:44.710 --> 00:02:46.990
So another example,
the preview application.

00:02:47.040 --> 00:02:48.100
Thank you.

00:02:48.630 --> 00:02:50.660
It's split into multiple processes.

00:02:50.850 --> 00:02:54.000
And these processes have
different levels of permission.

00:02:54.020 --> 00:02:58.100
So the one on the left here has access to
the hard drive and access to the network,

00:02:58.280 --> 00:03:01.240
and the one on the right has
access only to the contacts.

00:03:01.360 --> 00:03:03.550
So this provides two really key benefits.

00:03:03.600 --> 00:03:06.100
The first is one of security,
which I just mentioned.

00:03:06.100 --> 00:03:09.090
So the process on the right,
if it's compromised in some way,

00:03:09.200 --> 00:03:13.500
either the application or any frameworks
or libraries that that application uses,

00:03:13.690 --> 00:03:16.640
maybe it can access contacts,
but it can't access the hard drive

00:03:16.800 --> 00:03:18.900
and it can't access the network,
so the amount of damage

00:03:18.980 --> 00:03:21.030
it can do in terms of,
like, shipping that information off to

00:03:21.030 --> 00:03:23.650
somebody else is really limited.

00:03:23.700 --> 00:03:26.020
The second benefit is crash protection.

00:03:26.050 --> 00:03:30.090
So if this helper process crashes in
the course of accessing the contact

00:03:30.090 --> 00:03:33.980
information or processing it in some way,
then the main GUI application

00:03:34.060 --> 00:03:36.280
can continue to run,
and the user doesn't have to

00:03:36.280 --> 00:03:40.840
be interrupted with some minor
task running into a snafu.

00:03:41.050 --> 00:03:47.420
So once we split up these applications
into multiprocess applications,

00:03:47.420 --> 00:03:49.620
we need some way to
communicate between them,

00:03:49.620 --> 00:03:51.950
and this is called
interprocess communication,

00:03:51.990 --> 00:03:53.080
or IPC.

00:03:53.090 --> 00:03:56.560
Those dinosaurs we talked about earlier,
we're using things called Mach messages.

00:03:56.560 --> 00:03:57.760
Actually, they're still around.

00:03:57.760 --> 00:03:59.980
They're the fundamental
form of IPC in our system,

00:03:59.980 --> 00:04:03.050
but you may have also heard of
other IPC mechanisms like sockets or

00:04:03.100 --> 00:04:07.920
distributed objects or new and lying XPC.

00:04:08.840 --> 00:04:13.690
So XPC was, its job was to simplify the
low-level details of this IPC.

00:04:13.750 --> 00:04:18.810
It's a C API with custom objects,
containers like XPC dictionaries

00:04:18.820 --> 00:04:21.890
and XPC arrays and data
types like XPC string,

00:04:21.890 --> 00:04:25.590
XPC date, XPC data and so forth.

00:04:26.950 --> 00:04:30.270
When we introduced XPC,
we put it at a low level

00:04:30.270 --> 00:04:34.290
in the OSÂ X technology
stack at the Core OS level.

00:04:34.490 --> 00:04:38.040
And if you had an application
that uses Cocoa-level

00:04:38.040 --> 00:04:41.880
APIs like Foundation or AppKit,
then you may find yourself in

00:04:41.950 --> 00:04:45.290
a situation that we sometimes
call impedance mismatch.

00:04:45.420 --> 00:04:48.650
So you have an NSArray and you
want to send it over to XPC.

00:04:48.920 --> 00:04:53.320
So you pack it up into an XPC array
T and any objects it contains,

00:04:53.630 --> 00:04:56.340
send it over your connection,
and on the other side you have to

00:04:56.410 --> 00:04:58.220
unpack it and recreate your objects.

00:04:58.400 --> 00:05:01.500
So to solve this problem and
to introduce some new features,

00:05:01.500 --> 00:05:05.300
in Mountain Lion we have a new
technology called NSXPCConnection.

00:05:05.300 --> 00:05:08.910
It allows you to use your own
objects and interfaces with

00:05:08.910 --> 00:05:11.590
XPC and interprocess communication.

00:05:13.580 --> 00:05:16.540
Let's go over a few of the
design goals of NSXPCConnection.

00:05:16.670 --> 00:05:17.920
So again, it's Cocoa.

00:05:18.090 --> 00:05:20.430
In fact,
the NSXPCConnection header doesn't

00:05:20.450 --> 00:05:22.380
import even the XPC header itself.

00:05:22.380 --> 00:05:25.200
So XPC is abstracted away.

00:05:25.300 --> 00:05:26.390
It's designed to be simple.

00:05:26.480 --> 00:05:28.760
I think this talk will be
enough to get you started.

00:05:28.890 --> 00:05:31.480
Because we're crossing privilege
and process boundaries,

00:05:31.500 --> 00:05:33.860
it needed to be secure,
and we designed it that

00:05:33.950 --> 00:05:34.980
way from the start.

00:05:35.040 --> 00:05:38.100
It's very opinionated
about being asynchronous.

00:05:38.180 --> 00:05:41.000
Just because we've moved from
single process to multiprocess

00:05:41.030 --> 00:05:45.110
doesn't mean we need to revert to
a single-threaded kind of behavior.

00:05:45.350 --> 00:05:47.880
And all of the above,
plus some other features like

00:05:47.880 --> 00:05:50.590
not being tied to CFRunLoop,
being exception-free,

00:05:50.650 --> 00:05:54.160
except in case of program error,
as is the normal Cocoa pattern,

00:05:54.280 --> 00:05:55.660
and also Arc-friendly.

00:05:55.730 --> 00:05:59.560
In fact, all of the examples and demos
you see today will be using Arc,

00:05:59.570 --> 00:06:02.330
combined to make
NSXPCConnection a very modern,

00:06:02.330 --> 00:06:03.480
friendly API.

00:06:04.500 --> 00:06:05.520
So let's look at a quick demo.

00:06:05.730 --> 00:06:08.560
I want to show you what one of these
multiprocess applications looks like

00:06:08.780 --> 00:06:12.200
and then we're going to use it as
a basis for the rest of the talk.

00:06:12.760 --> 00:06:12.950
Okay.

00:06:13.050 --> 00:06:16.260
So here I have an application
called Flight Finder.

00:06:16.400 --> 00:06:19.100
And its job is to allow you
to put in a destination,

00:06:19.100 --> 00:06:23.100
pick a date and approximate price,
and search for available

00:06:23.100 --> 00:06:24.600
flights on that date.

00:06:24.600 --> 00:06:27.580
So this application is split
up into multiple pieces.

00:06:27.790 --> 00:06:31.370
And one reason might be that let's
imagine that this Flight Finder has

00:06:31.370 --> 00:06:35.590
access to my calendar data to find the
next available date on my calendar.

00:06:35.600 --> 00:06:38.870
That doesn't sound like something
that we necessarily want mixed with

00:06:38.900 --> 00:06:40.600
access to the general Internet.

00:06:40.600 --> 00:06:43.540
So that would be a good thing to
put off in its own little process.

00:06:43.600 --> 00:06:46.680
So here is the structure of
the application on disk in

00:06:46.680 --> 00:06:49.420
my build products folder,
the Flight Finder.

00:06:49.550 --> 00:06:52.530
Now, if I show its contents,

00:06:53.090 --> 00:06:57.430
You see some of the familiar things here,
including your

00:06:57.430 --> 00:07:00.020
Mac OS directory and resources,
but there's this new

00:07:00.020 --> 00:07:01.840
directory called xpcservices.

00:07:01.950 --> 00:07:04.510
So an xpcservice is one of
these helper processes that

00:07:04.510 --> 00:07:06.340
we'll be talking about today.

00:07:06.460 --> 00:07:09.350
If I look at the contents of that,
there is another bundle

00:07:09.670 --> 00:07:13.040
called ticketagentservice.xpc,
which is a bundle itself,

00:07:13.160 --> 00:07:16.870
so I can find it's executable if
I drill down a little bit further.

00:07:18.870 --> 00:07:27.050
So now I'm going to pick a date, price,
that much, and search.

00:07:27.260 --> 00:07:31.670
And what we'll see is in the background,
our ticket agent service has started up.

00:07:31.730 --> 00:07:32.290
You see it's here.

00:07:32.370 --> 00:07:34.860
It's also sandboxed like
the main application is.

00:07:34.960 --> 00:07:39.200
And we found our ticket
for a price of $181.

00:07:39.230 --> 00:07:41.360
So that's a basic
operation of the example.

00:07:41.360 --> 00:07:45.310
So let's go back to our slides
and see how we might build this.

00:07:45.850 --> 00:07:47.800
Here's a preview of where
we're going to end up.

00:07:47.990 --> 00:07:51.690
You see we have two processes, again,
a Flight Finder, the GUI part,

00:07:51.880 --> 00:07:54.640
and the Ticket Agent,
which is the part that actually did the

00:07:54.640 --> 00:07:56.560
searching for us and returned a result.

00:07:56.660 --> 00:07:58.330
We're going to need four major pieces.

00:07:58.460 --> 00:08:00.140
The first is an interface.

00:08:00.220 --> 00:08:01.860
The second is a connection.

00:08:01.980 --> 00:08:03.130
The third is a listener.

00:08:03.320 --> 00:08:07.040
And the fourth is a way to communicate,
and that's messages.

00:08:07.530 --> 00:08:09.900
First up is interfaces.

00:08:09.900 --> 00:08:13.900
The job of an interface is to
abstract away implementation details.

00:08:13.900 --> 00:08:17.400
And that's not just the details of how
that ticket agent service or the flight

00:08:17.400 --> 00:08:20.400
finder are implemented themselves,
but also how the IPC is

00:08:20.410 --> 00:08:22.500
actually happening between them.

00:08:22.840 --> 00:08:26.060
Interfaces provide a clear
division of responsibilities.

00:08:26.200 --> 00:08:28.330
And in Objective-C,
we have a really handy way of

00:08:28.370 --> 00:08:30.560
describing interfaces called protocols.

00:08:30.710 --> 00:08:34.960
You'll find that protocols
form a fundamental piece of

00:08:34.960 --> 00:08:35.970
how NSXPCConnection works.

00:08:36.910 --> 00:08:39.900
So here's the division of
responsibilities of our two processes

00:08:39.910 --> 00:08:41.800
in our multiprocess application.

00:08:41.800 --> 00:08:44.640
On the Flight Finder,
it can get search input from the user,

00:08:44.770 --> 00:08:48.800
it can talk to the agent,
it can show found tickets,

00:08:48.800 --> 00:08:51.800
and as we mentioned earlier,
it has access to my calendar data.

00:08:51.950 --> 00:08:55.300
The ticket agent, on the other hand,
its job is simply to find flights

00:08:55.810 --> 00:08:58.540
and perhaps to buy tickets
and return the result back

00:08:58.630 --> 00:09:00.790
to the Flight Finder application.

00:09:03.100 --> 00:09:05.680
So we're going to describe the
Ticket Agent interface with

00:09:05.850 --> 00:09:08.310
this protocol called Agent.

00:09:08.500 --> 00:09:10.510
In this protocol,
you'll have a set of methods,

00:09:10.820 --> 00:09:12.160
like this one, CheckIn.

00:09:12.250 --> 00:09:14.900
It takes no arguments
and has no return value.

00:09:15.010 --> 00:09:17.000
But of course,
often you're going to want to send

00:09:17.000 --> 00:09:20.010
data to your helper processes,
so there'll be arguments.

00:09:20.140 --> 00:09:23.400
This method, BuyTicketOnDateMaxCost,
has two object arguments,

00:09:23.400 --> 00:09:27.210
a string and a date,
and also an integer argument.

00:09:27.980 --> 00:09:30.330
Once we've bought a ticket,
we're going to need to receive

00:09:30.330 --> 00:09:33.000
it back in the Flight Finder
application in some way.

00:09:33.240 --> 00:09:36.670
So one way you might do that is
by creating another protocol to

00:09:36.670 --> 00:09:38.660
describe the Flight Finder interface.

00:09:38.750 --> 00:09:40.820
Here you see I've got a
method called setTicket,

00:09:40.820 --> 00:09:42.900
and it takes a ticket as an argument.

00:09:42.960 --> 00:09:48.480
But this request-response pattern
is so common with these XPC services

00:09:48.970 --> 00:09:52.020
that instead we're going to
let you build it right into the

00:09:52.020 --> 00:09:54.600
agent protocol via a reply block.

00:09:54.690 --> 00:09:58.970
So you see I've just added an
argument that has a ticket argument

00:09:59.020 --> 00:10:01.600
as its single return value.

00:10:01.700 --> 00:10:05.970
And this reply block will be invoked
asynchronously when the reply comes back.

00:10:08.200 --> 00:10:12.270
Now we're going to wrap up this protocol
in an object called an NSXPCInterface.

00:10:12.310 --> 00:10:15.100
And to create one,
use this simple constructor method,

00:10:15.250 --> 00:10:18.780
interface with protocol
and pass in your protocol.

00:10:21.040 --> 00:10:23.560
A few more details about
these protocol methods.

00:10:23.560 --> 00:10:24.860
The methods must return void.

00:10:25.120 --> 00:10:28.300
Again, that's because we're very
opinionated about being asynchronous.

00:10:28.300 --> 00:10:31.700
Methods that return a value directly
are very hard to make work in a

00:10:31.980 --> 00:10:33.850
pure asynchronous kind of fashion.

00:10:33.850 --> 00:10:36.180
So instead if you have return
values or reply values,

00:10:36.180 --> 00:10:38.880
you just put them as one of the
arguments to your reply block.

00:10:38.880 --> 00:10:42.790
The arguments of the method and
the reply block can be one or more

00:10:43.070 --> 00:10:44.730
or none of the following types.

00:10:44.840 --> 00:10:47.540
Arithmetic types, like int, float, char,
long, long,

00:10:47.540 --> 00:10:49.160
and NS secure coding protocol.

00:10:49.160 --> 00:10:51.880
The objective C Boolean type,
null terminated C strings,

00:10:51.880 --> 00:10:55.770
C arrays that contain those types and
C structures that contain those types,

00:10:55.770 --> 00:10:56.950
including C arrays.

00:10:57.030 --> 00:10:59.080
And finally and most importantly,
objects.

00:10:59.150 --> 00:11:01.990
And those objects must implement
the NS secure coding protocol,

00:11:01.990 --> 00:11:03.720
which we'll talk about
a little bit later.

00:11:07.140 --> 00:11:09.000
Here is our preview again.

00:11:09.000 --> 00:11:12.370
What we're going to do is create
one of these NSXPC interface

00:11:12.410 --> 00:11:15.000
objects in the ticket agent.

00:11:15.070 --> 00:11:18.010
You see it describes the agent
protocol and we're going to

00:11:18.180 --> 00:11:20.000
call it our exported interface.

00:11:20.000 --> 00:11:22.170
That is,
this is the interface we expect this

00:11:22.170 --> 00:11:24.000
ticket agent to implement for us.

00:11:24.000 --> 00:11:26.900
The Flight Finder also gets
an NSXPC interface that

00:11:26.900 --> 00:11:30.150
describes the agent protocol,
but there it's called the

00:11:30.150 --> 00:11:31.990
remote object interface.

00:11:32.120 --> 00:11:35.320
So this is saying that the
Flight Finder expects its remote side,

00:11:35.510 --> 00:11:38.000
the ticket agent,
to implement the agent protocol.

00:11:38.040 --> 00:11:42.190
So both sides have a clear idea of
what the other side is supposed to do.

00:11:44.130 --> 00:11:45.090
Okay, that's interfaces.

00:11:45.380 --> 00:11:48.760
Let's move on to connections.

00:11:48.760 --> 00:11:51.000
So I promised you earlier
there was an arrow there.

00:11:51.230 --> 00:11:52.000
There it is.

00:11:52.180 --> 00:11:55.760
And there are two objects, again,
one on each side,

00:11:56.060 --> 00:11:58.430
called NSXPCConnections.

00:11:58.600 --> 00:12:03.310
This connection represents an endpoint
in a bidirectional communication channel.

00:12:04.800 --> 00:12:07.370
On the ticket agent,
there's one key property.

00:12:07.520 --> 00:12:10.930
This is an object that you implement
and it's called the exported object.

00:12:10.950 --> 00:12:13.950
And as you might imagine from the name,
its job is to implement

00:12:13.950 --> 00:12:15.500
the exported interface.

00:12:15.560 --> 00:12:19.500
You see here I've declared an object
that implements the agent protocol.

00:12:19.500 --> 00:12:21.970
So let's look at how you would do that.

00:12:23.790 --> 00:12:26.610
Here again is our agent
protocol that we just saw.

00:12:26.610 --> 00:12:29.070
And I'm going to create an
object called a TicketAgent.

00:12:29.090 --> 00:12:32.970
It's a subclass of NSObject and
it implements the agent protocol.

00:12:33.510 --> 00:12:36.240
In its implementation,
we just implement those methods.

00:12:36.480 --> 00:12:38.010
So here's my check-in method.

00:12:38.090 --> 00:12:39.930
It took no arguments,
so I can just get away with

00:12:40.060 --> 00:12:41.200
putting a comment there.

00:12:41.380 --> 00:12:45.140
But this method, as you remember,
took two object arguments and an integer

00:12:45.140 --> 00:12:47.200
argument and has this reply block.

00:12:47.340 --> 00:12:49.700
And this one's actually pretty
easy to implement as well.

00:12:49.840 --> 00:12:53.630
We take those values as we've
received them and do whatever we

00:12:53.630 --> 00:12:56.170
need to do to create a ticket object.

00:12:56.170 --> 00:12:58.900
And then we invoke the reply
block with our reply value.

00:12:59.040 --> 00:13:01.880
And the way you invoke a reply
block is just like any other block,

00:13:01.920 --> 00:13:03.210
which is like a function.

00:13:03.410 --> 00:13:05.390
So this one has one argument, our ticket.

00:13:05.560 --> 00:13:06.990
And we're done.

00:13:11.010 --> 00:13:14.280
So the NSXPCConnection
instance in the Flight Finder,

00:13:14.280 --> 00:13:17.350
you can create in three simple steps.

00:13:17.470 --> 00:13:20.600
The first is you call Alec
an init with service name.

00:13:20.660 --> 00:13:23.070
The argument there is going to
be the bundle identifier of the

00:13:23.070 --> 00:13:25.480
XPC service bundle that we saw.

00:13:25.570 --> 00:13:28.150
The second step is to set up
its remote object interface.

00:13:28.470 --> 00:13:31.200
Here again is the same method,
interface with protocol.

00:13:31.240 --> 00:13:33.600
And the third step is to
resume the connection.

00:13:33.670 --> 00:13:36.900
Connections start suspended so that you
have an opportunity to configure them,

00:13:36.940 --> 00:13:40.210
but you must resume them
before they can be used.

00:13:42.760 --> 00:13:45.460
The XPC connection in the
ticket agent is handed to us,

00:13:45.610 --> 00:13:48.170
and we'll see how in a second,
but it also has just three

00:13:48.320 --> 00:13:49.590
simple steps to configure.

00:13:49.980 --> 00:13:52.100
We're going to set its
exported interface,

00:13:52.150 --> 00:13:54.840
again,
using the interface with protocol method,

00:13:54.840 --> 00:13:58.190
and set its exported object to
be the ticket agent that we just

00:13:58.200 --> 00:14:01.190
created and resume it as well.

00:14:03.400 --> 00:14:05.700
A few more details about connections.

00:14:05.700 --> 00:14:09.300
So here in our example,
we have one side has an exported object

00:14:09.300 --> 00:14:11.900
and the other side has a remote object.

00:14:12.050 --> 00:14:15.130
But connections are bidirectional,
so you can actually have both

00:14:15.220 --> 00:14:17.180
on both sides if you choose.

00:14:17.180 --> 00:14:22.160
The lifetime of your XPC service is
managed for you by XPC and by launchd.

00:14:22.160 --> 00:14:24.580
So they're launched automatically
when you need them and they

00:14:24.580 --> 00:14:27.480
will go away automatically when
the system needs resources,

00:14:27.520 --> 00:14:30.400
assuming they're not in the
middle of doing some work.

00:14:30.400 --> 00:14:33.680
And finally, in this example,
in this architecture of having

00:14:33.680 --> 00:14:37.030
an application and a service,
you should invalidate the connection

00:14:37.130 --> 00:14:40.910
in the application when you're done
to clean up any appropriate resources.

00:14:40.980 --> 00:14:43.840
And we'll see exactly how
to do that in a demo later.

00:14:45.460 --> 00:14:47.810
So in the world of IPC,
it's not always the case that

00:14:47.810 --> 00:14:51.010
everything goes perfectly,
so we have some error handling

00:14:51.050 --> 00:14:52.780
opportunities for you.

00:14:52.980 --> 00:14:56.100
There's two blocks that are properties
of the connection that you can set.

00:14:56.100 --> 00:14:59.080
The first is called an
interruption handler.

00:14:59.080 --> 00:15:02.140
Interruption handler is called
when the remote side crashes

00:15:02.140 --> 00:15:03.600
or closes the connection.

00:15:03.600 --> 00:15:08.210
In this case, the NSXPC connection
instance is still valid.

00:15:08.280 --> 00:15:11.200
But because the other side crashed,
you may need to restore some state

00:15:11.200 --> 00:15:13.160
to get back to what you were doing.

00:15:13.160 --> 00:15:16.080
So the reason that it's an
interruption handler in this case

00:15:16.080 --> 00:15:19.330
is because this connection was
created with a name or some other

00:15:19.330 --> 00:15:21.860
way to look up the connection again,
so we can just recreate

00:15:21.860 --> 00:15:22.820
it for you on demand.

00:15:22.940 --> 00:15:26.240
So you don't need to recreate
the NSXPC connection instance.

00:15:26.240 --> 00:15:29.100
On the other hand,
you may get an invalidation error,

00:15:29.100 --> 00:15:32.690
and in that case, the remote side crashed
or invalidate was called,

00:15:32.810 --> 00:15:35.060
but we have no way to
recreate the connection.

00:15:35.060 --> 00:15:38.780
And in that case, the NSXPC connection
instance is no longer valid.

00:15:38.780 --> 00:15:40.360
So generally,
you're going to see interruption

00:15:40.450 --> 00:15:43.140
handlers in your application because
your application looked up the service.

00:15:43.140 --> 00:15:44.680
And we know how to reconnect to it.

00:15:44.680 --> 00:15:48.080
But you're going to get invalidation
handlers in your service because

00:15:48.080 --> 00:15:50.990
the service received the connection.

00:15:51.410 --> 00:15:55.190
So let's talk about listeners,
which is how those connections

00:15:55.190 --> 00:15:57.050
are created in the service.

00:15:59.090 --> 00:16:01.680
That's the last object
in the ticket agent,

00:16:01.800 --> 00:16:05.880
and the listener's job is to await
new incoming connections and allow

00:16:05.880 --> 00:16:07.950
a delegate to configure them.

00:16:10.930 --> 00:16:11.950
Here's how you do it.

00:16:12.060 --> 00:16:14.610
This will be in the main
function of your service.

00:16:14.610 --> 00:16:17.320
We're going to get the
singleton service listener,

00:16:17.320 --> 00:16:20.270
set up its delegate,
which is an object which implements

00:16:20.270 --> 00:16:22.430
the NSXPC listener delegate protocol.

00:16:22.460 --> 00:16:25.100
And like connections,
listeners start suspended

00:16:25.100 --> 00:16:26.700
so you must resume them.

00:16:26.880 --> 00:16:29.250
Now for service listeners,
when you call resume,

00:16:29.340 --> 00:16:31.550
we take over execution
of the application.

00:16:31.630 --> 00:16:34.890
And from that point on, as I mentioned,
we're going to manage the lifecycle.

00:16:34.970 --> 00:16:38.660
This is equivalent to calling
NS application main or dispatch

00:16:38.660 --> 00:16:42.990
main or CFO on loop run or XPC main
or any of those kinds of functions.

00:16:45.640 --> 00:16:47.470
The delegate just has one method.

00:16:47.580 --> 00:16:49.500
It's called
listenerShouldAcceptNewConnection.

00:16:49.500 --> 00:16:51.500
You see that it has a
connection argument.

00:16:51.500 --> 00:16:53.500
That's where the connection is
handed to us in the service,

00:16:53.500 --> 00:16:55.490
as I promised.

00:16:55.500 --> 00:16:59.390
And here's the exact same code we just
saw where we configured the connection

00:16:59.500 --> 00:17:03.490
by setting up its exported interface,
exported object, and resuming it.

00:17:03.500 --> 00:17:05.500
And then we decide to return
yes to accept the connection.

00:17:05.500 --> 00:17:09.500
If you choose to reject the connection,
you can return no.

00:17:09.500 --> 00:17:13.500
A connection has a few properties you
can check like effective user identifier

00:17:13.500 --> 00:17:15.740
and effective group identifier to see
if you want to accept the connection.

00:17:19.310 --> 00:17:23.260
Today we're talking about XPC services,
which are part of your application

00:17:23.260 --> 00:17:25.940
bundle and are for the exclusive
use of your application.

00:17:26.180 --> 00:17:29.660
But the same NSXPCConnection
APIs can be used to talk to launch

00:17:29.730 --> 00:17:32.000
agents and launch daemons as well.

00:17:32.110 --> 00:17:35.140
You just need to use the
Mach variant of the init methods,

00:17:35.210 --> 00:17:37.240
as you see on this.

00:17:37.360 --> 00:17:38.960
And one more detail.

00:17:39.010 --> 00:17:41.060
Mach service listeners do
not take control of your

00:17:41.060 --> 00:17:44.240
application when you call resume,
unlike the service listener.

00:17:44.310 --> 00:17:46.010
That's because in this
more advanced use case,

00:17:46.110 --> 00:17:48.640
we expect that you may have additional
requirements for how you need to

00:17:48.640 --> 00:17:51.070
run your launch agent or daemon.

00:17:53.710 --> 00:17:58.210
All right, now we just need a way to
communicate between these two pieces,

00:17:58.210 --> 00:18:00.040
and that's messages.

00:18:00.040 --> 00:18:03.760
So we saw earlier an exported object
in the ticket agent that implements

00:18:03.810 --> 00:18:07.040
the exported interface and is
responsible for receiving messages

00:18:07.050 --> 00:18:08.620
that are sent to the ticket agent.

00:18:08.700 --> 00:18:12.500
To send messages to the ticket
agent from the flight finder,

00:18:12.530 --> 00:18:16.110
we have an object there
called the RemoteObjectProxy.

00:18:16.200 --> 00:18:20.550
And you see it implements or appears
to implement the agent protocol as

00:18:20.550 --> 00:18:22.810
described by the RemoteObjectInterface.

00:18:25.810 --> 00:18:28.280
To get one, you just ask the connection
for it like this,

00:18:28.490 --> 00:18:30.660
Remote Object Proxy,
an unsurprising name,

00:18:30.840 --> 00:18:34.100
and then send it your
messages like Check In.

00:18:34.230 --> 00:18:35.500
That's it.

00:18:35.630 --> 00:18:38.990
Or this one,
Buy Ticket On Date Max Cost Reply.

00:18:39.400 --> 00:18:42.400
You see I've passed in my object
arguments and also that integer.

00:18:42.510 --> 00:18:45.230
And the reply block goes right
there in line with the message sent.

00:18:45.470 --> 00:18:49.300
So that means that it's really easy
to correlate any requests with any

00:18:49.300 --> 00:18:53.590
response action that you need to take,
like updating your user interface.

00:18:56.410 --> 00:18:59.800
Earlier we saw that you could do error
handling at the connection level.

00:18:59.800 --> 00:19:02.620
You can also set up error
handling on a per message basis.

00:19:02.780 --> 00:19:05.720
And the way you do that is by
creating a remote object proxy

00:19:05.720 --> 00:19:07.610
that has an error handler block.

00:19:07.610 --> 00:19:11.860
And using the method called remote
object proxy with error handler.

00:19:11.860 --> 00:19:15.210
And in that block,
you can take whatever action is

00:19:15.210 --> 00:19:17.220
appropriate for handling that error.

00:19:17.320 --> 00:19:21.060
I hope you don't do something
like logging oops to the console.

00:19:21.060 --> 00:19:22.930
Users don't look at the console.

00:19:22.930 --> 00:19:25.960
A better idea might be to
display placeholder or perhaps

00:19:26.260 --> 00:19:29.860
retry the operation if you
have an algorithm to do that.

00:19:29.860 --> 00:19:33.010
Now this remote object proxy,
you see I've just nested the call

00:19:33.120 --> 00:19:37.330
to get this remote object proxy with
the exact same by ticket on date max

00:19:37.330 --> 00:19:39.810
cost reply message that we just saw.

00:19:41.600 --> 00:19:45.420
So it's important to note that
what we guarantee for you is that

00:19:45.420 --> 00:19:49.700
exactly one of those two blocks
will be called per message sent.

00:19:49.700 --> 00:19:54.920
So if you need to, for example,
take a lock before you send this message,

00:19:54.920 --> 00:20:01.680
you can release the lock in both
blocks and know that you're not

00:20:01.680 --> 00:20:02.740
going to over-release your lock.

00:20:02.740 --> 00:20:02.740
So that's a pretty handy
thing to take advantage of.

00:20:05.140 --> 00:20:08.140
Let's look a little more detail
about how this message sending works.

00:20:08.220 --> 00:20:10.680
So on the flight finder,
I send a message to the proxy called

00:20:10.740 --> 00:20:14.750
Buy Ticket-On-Date-Max-Cost-Reply,
and you see I specified a reply

00:20:14.780 --> 00:20:16.580
block as one of the arguments.

00:20:16.660 --> 00:20:18.050
What we're going to do
is under the covers,

00:20:18.090 --> 00:20:22.140
NSXPC connection will gather up all of
the appropriate information it needs,

00:20:22.190 --> 00:20:26.400
and then we're gonna hang on to the
reply block until the reply comes back.

00:20:26.430 --> 00:20:30.440
The appropriate stuff is sent over
the connection to the ticket agent,

00:20:30.510 --> 00:20:36.120
where we will unpack it and create a
stand-in reply block proxy per message,

00:20:36.190 --> 00:20:38.880
and pass it all off to
your exported object.

00:20:38.930 --> 00:20:42.880
And there we saw the implementation where
we implemented it by calling the reply

00:20:43.040 --> 00:20:46.880
block with a reply value like ticket,
and we just do the exact same

00:20:46.880 --> 00:20:49.710
operation but in reverse,
and send it back to the flight

00:20:49.710 --> 00:20:52.520
finder and invoke your reply block.

00:20:55.110 --> 00:20:57.160
These proxies are lightweight objects.

00:20:57.180 --> 00:20:59.570
They're basically just an
integer and a reference to the

00:20:59.640 --> 00:21:01.000
connection that you're using.

00:21:01.090 --> 00:21:04.400
They're immutable in the sense that
you can't change their error handling

00:21:04.440 --> 00:21:06.240
blocks after you've created them.

00:21:06.350 --> 00:21:08.910
So if you need a different
error handling behavior,

00:21:09.120 --> 00:21:13.040
just create another proxy
using these two messages,

00:21:13.130 --> 00:21:14.400
these two methods.

00:21:14.470 --> 00:21:17.550
And these,
you can send these to the NSXPCConnection

00:21:17.550 --> 00:21:21.540
itself or any proxies that you
get from the NSXPCConnection,

00:21:21.600 --> 00:21:24.180
depending on whatever is
most convenient for you.

00:21:26.180 --> 00:21:29.410
And an important detail,
all the messages we're talking about,

00:21:29.410 --> 00:21:32.300
that is the ones delivered to
your exported object and the

00:21:32.300 --> 00:21:36.090
invocations of your reply blocks in
the application are delivered on a

00:21:36.090 --> 00:21:38.350
per connection private serial queue.

00:21:38.470 --> 00:21:42.000
It's not the main thread and it's not
the thread that you sent the message on.

00:21:42.060 --> 00:21:44.880
The reason is because, again,
we are trying to promote

00:21:45.320 --> 00:21:46.680
asynchronous behavior.

00:21:46.800 --> 00:21:48.850
So if you need work
done on the main thread,

00:21:48.850 --> 00:21:52.070
then you should figure out what
the minimum amount that you need to

00:21:52.070 --> 00:21:55.440
do is and then just move it there
using NSOperationQueue or Dispatch,

00:21:55.570 --> 00:21:57.580
whatever is appropriate.

00:21:59.890 --> 00:22:03.910
So now we have all four pieces we
needed to build NSXPCConnection.

00:22:03.960 --> 00:22:10.030
Let's go back to our demo and look
at it in a little bit more detail.

00:22:10.730 --> 00:22:13.580
Here I have the Flight Finder project.

00:22:13.580 --> 00:22:17.750
And you can see it has two targets,
a Flight Finder and a

00:22:17.750 --> 00:22:19.590
Ticket Agent Service.

00:22:19.760 --> 00:22:22.310
And in the build phases,
I've configured it so that the

00:22:22.310 --> 00:22:25.840
main application is depending
on the Ticket Agent Service.

00:22:26.010 --> 00:22:30.340
And I have an additional copy files
phase to move that XPC service into

00:22:30.340 --> 00:22:35.430
the directory that we saw earlier,
content/xpc-services.

00:22:35.860 --> 00:22:38.460
In the project itself,
I have three groups of sources.

00:22:38.700 --> 00:22:40.760
The first is a set of shared sources.

00:22:40.760 --> 00:22:44.680
You'll find that model objects and
interfaces described in headers are

00:22:44.950 --> 00:22:48.700
very common to share between both
your application and a service.

00:22:48.760 --> 00:22:54.350
We also have the Flight Finder sources
themselves and the Ticket Agent service.

00:22:54.500 --> 00:22:55.670
So we started with interfaces.

00:22:55.850 --> 00:22:56.820
Let's look at that.

00:22:56.950 --> 00:23:02.290
Here is the protocol for the agent
with buy ticket on date max cost reply.

00:23:04.710 --> 00:23:07.640
In the application delegate
for this demonstration,

00:23:07.740 --> 00:23:09.550
I've chosen to create
the connection in the

00:23:09.550 --> 00:23:11.680
application-did-finish-launching method.

00:23:11.840 --> 00:23:13.000
Here I create the connection.

00:23:13.100 --> 00:23:16.550
You see I'm using the bundle
identifier for my ticket agent service.

00:23:16.610 --> 00:23:20.460
I set its remote object interface
to use the agent protocol,

00:23:20.460 --> 00:23:22.580
and I resume the connection.

00:23:24.460 --> 00:23:29.540
I'm storing my remote object
proxy as an IVAR in this object,

00:23:29.540 --> 00:23:33.110
and I create it,
and here is the error handler where,

00:23:33.340 --> 00:23:35.980
again, on the main queue,
I'm going to update the UI to

00:23:35.980 --> 00:23:38.030
show that something went wrong.

00:23:40.350 --> 00:23:44.800
For the listener, in the main function of
the ticket agent service,

00:23:44.800 --> 00:23:48.130
you see this is where
I create my service listener,

00:23:48.130 --> 00:23:51.490
set up its delegate and
resume the connection.

00:23:52.140 --> 00:23:56.450
The TicketAgent object implements
the listener should accept new

00:23:56.450 --> 00:23:57.990
connection delegate method.

00:23:58.140 --> 00:24:01.710
Here I set up the exported interface,
the exported object and

00:24:01.710 --> 00:24:03.450
resume the connection.

00:24:03.850 --> 00:24:07.950
When the application chooses to
ask the ticket agent for something,

00:24:07.950 --> 00:24:12.110
we just send our buy ticket on date
max cost reply message to the agent

00:24:12.110 --> 00:24:15.830
and when the reply comes back,
we're going to execute this on

00:24:15.830 --> 00:24:18.940
the main queue which updated
the UI as we saw earlier.

00:24:19.180 --> 00:24:22.580
And in the ticket agent,
that implementation is just right

00:24:23.010 --> 00:24:26.600
here where we create our ticket,
make sure that nobody's trying

00:24:26.600 --> 00:24:29.540
to get us a really cheap ticket
so we make sure it's over $100.

00:24:29.700 --> 00:24:33.320
Pretend that we're actually doing
some real work by sleeping and

00:24:33.320 --> 00:24:35.500
then reply with the ticket value.

00:24:36.380 --> 00:24:40.000
So I want to show you how easy
it is to add new functionality to

00:24:40.000 --> 00:24:41.980
this as your requirements change.

00:24:42.080 --> 00:24:44.560
So as you saw earlier,
we have -- or as you saw,

00:24:44.640 --> 00:24:47.300
we have this today's special
button which is doing nothing.

00:24:47.400 --> 00:24:49.300
So I'm going to go ahead
and implement that.

00:24:49.300 --> 00:24:54.380
So we're going to start
again with interfaces.

00:24:54.790 --> 00:24:58.370
So I'm going to add a new
method to our protocol.

00:25:02.850 --> 00:25:05.890
It's called getSpecialFlight.

00:25:05.890 --> 00:25:10.500
It takes no arguments
besides the reply block.

00:25:10.500 --> 00:25:10.500
And when the reply comes back,
we'll have a ticket.

00:25:13.200 --> 00:25:16.700
Excuse me.

00:25:16.770 --> 00:25:21.030
So then in the Ticket Agent,
we're going to implement that new method

00:25:21.170 --> 00:25:23.630
because we added it to our protocol.

00:25:26.470 --> 00:25:28.160
There we go.

00:25:28.160 --> 00:25:29.790
You see I'm just going to,
like we saw on the slides,

00:25:29.800 --> 00:25:32.560
create our new ticket,
set its destination and price

00:25:32.720 --> 00:25:36.890
to New York City and $4.99 and
then reply with the return value.

00:25:37.010 --> 00:25:39.760
And in the application,
we need to just hook up our button.

00:25:40.010 --> 00:25:41.210
Here it is.

00:25:41.210 --> 00:25:43.550
It was empty before.

00:25:44.590 --> 00:25:45.500
There we go.

00:25:45.500 --> 00:25:47.450
So I'm sending a message
to my remote object proxy,

00:25:47.680 --> 00:25:49.950
get special flight,
and on the main queue,

00:25:50.030 --> 00:25:54.010
when the reply comes back,
we set up some string values in the UI.

00:25:54.170 --> 00:25:58.130
So let's go ahead and rerun this
and make sure that it works.

00:26:01.650 --> 00:26:04.740
I'll bring up Activity Monitor again
so we can see if our process starts.

00:26:04.780 --> 00:26:09.060
I click Today's Special and you see there
our ticket agent service was started

00:26:09.060 --> 00:26:13.630
on demand when we asked for a value
and we got back our reply of $4.99.

00:26:14.030 --> 00:26:16.440
Okay, let's go back to our slides.

00:26:16.600 --> 00:26:19.400
All right, now we're going to talk about
how those objects are actually

00:26:19.400 --> 00:26:20.630
moving between processes.

00:26:20.740 --> 00:26:22.630
That's the heart of the matter,
the most important feature

00:26:22.640 --> 00:26:26.250
of NSXPCConnection,
and that's using coding.

00:26:26.420 --> 00:26:29.120
So if you've used keyed archiver,
then you're familiar

00:26:29.120 --> 00:26:30.260
with NSCoding already.

00:26:30.570 --> 00:26:34.040
If not, pay attention because I'm
going to do a quick review.

00:26:34.160 --> 00:26:36.300
NSCoding is made up of two parts.

00:26:36.300 --> 00:26:39.500
There's the NSCoder subclass,
like NSKeyedArchiver

00:26:39.640 --> 00:26:41.300
or NSKeyedUnarchiver.

00:26:41.300 --> 00:26:46.440
The NSCoding conforming
class and this -- excuse me.

00:26:46.440 --> 00:26:48.170
And then this is made up
of two activities as well.

00:26:48.310 --> 00:26:53.930
There's encoding in which the coder
takes an in-memory graph of NSCoding

00:26:54.120 --> 00:26:59.230
objects and turns them into an archive
that is suitable for storage on disk

00:26:59.390 --> 00:27:01.600
or for sending between processes maybe.

00:27:01.760 --> 00:27:05.090
And then there's decoding where
we take that archive and convert

00:27:05.160 --> 00:27:08.600
it back into an in-memory
representation of those objects.

00:27:09.700 --> 00:27:10.550
So here's encoding.

00:27:10.630 --> 00:27:13.820
You see I've got a graph of objects,
an itinerary that holds a

00:27:13.820 --> 00:27:16.200
ticket that has a string.

00:27:16.300 --> 00:27:19.400
So the most important method in
encoding is called encodeWithCoder.

00:27:19.490 --> 00:27:22.260
And in there,
the job of this method is to tell the

00:27:22.260 --> 00:27:25.540
coder what data is needed to be stored,
so that we can effectively

00:27:25.640 --> 00:27:26.720
restore ourselves later.

00:27:26.890 --> 00:27:31.160
Using methods like encodeBoolForKey
and encodeObjectForKey.

00:27:31.300 --> 00:27:34.370
So when I call encodeObjectForKey,
of course the coder will then call

00:27:34.470 --> 00:27:35.880
encodeWithCoder on the ticket.

00:27:36.230 --> 00:27:38.660
And there we're going to
encode the string object.

00:27:38.720 --> 00:27:41.730
Now you don't need to worry about
how NSString encodes itself,

00:27:41.730 --> 00:27:44.580
because as long as
NSString conforms with NSCoding,

00:27:44.920 --> 00:27:47.670
we know it can be
included in the archive.

00:27:49.020 --> 00:27:50.760
on the flip side is decoding.

00:27:50.760 --> 00:27:53.170
So here the most important
method is initWithCoder.

00:27:53.210 --> 00:27:57.100
Here the job of this method is to
get back that data from the coder and

00:27:57.100 --> 00:28:02.420
initialize the object using methods like
decodeBoolForKey and decodeObjectForKey.

00:28:02.700 --> 00:28:05.460
And of course when we call
decodeObjectForKey we're going to

00:28:05.460 --> 00:28:09.110
alloc and initWithCoder on the ticket
object which will decode the string

00:28:09.240 --> 00:28:12.530
object and you don't need to worry
about how a string inits itself as

00:28:12.540 --> 00:28:16.890
long as it conforms with NS coding we
know it can be included in the archive.

00:28:18.030 --> 00:28:21.900
NSXPCConnection uses the exact
same NSCoding design pattern.

00:28:21.900 --> 00:28:24.670
On message send,
all the argument values are

00:28:24.670 --> 00:28:28.880
encoded and on the message receive,
all the arguments are decoded.

00:28:28.900 --> 00:28:32.900
NSXPCConnection uses a
new NSCoder subclass.

00:28:32.960 --> 00:28:37.290
It's not NSKeyedArchiver,
but it does implement keyed coding.

00:28:39.320 --> 00:28:42.270
So here's the method that
you might be sick of by now,

00:28:42.270 --> 00:28:44.440
buy ticket on date max cost reply.

00:28:44.440 --> 00:28:45.960
So let's use it as an example.

00:28:46.090 --> 00:28:49.290
When this message is sent,
the coder will do something like

00:28:49.340 --> 00:28:53.260
encode object for key argument one
and argument two because those are

00:28:53.260 --> 00:28:57.960
objects and encode integer for key
argument three because it's an integer.

00:28:58.080 --> 00:29:00.560
As I mentioned earlier,
the reply block is held on to

00:29:00.690 --> 00:29:02.050
until the reply comes back.

00:29:02.340 --> 00:29:04.680
So if you capture a lot of
memory in your reply block,

00:29:04.980 --> 00:29:09.200
just be aware that we have to keep
that alive until the reply comes back.

00:29:10.820 --> 00:29:13.340
And then on receive,
we decode those objects

00:29:13.350 --> 00:29:17.460
using decode object for key
and decode integer for key.

00:29:17.600 --> 00:29:21.280
Then we create that reply block
proxy and stuff them all into the

00:29:21.370 --> 00:29:26.630
arguments to that message that you've
implemented on your exported object.

00:29:28.950 --> 00:29:33.380
You may be wondering how the coder
knows what kind of object to alloc

00:29:33.380 --> 00:29:38.240
here because it's not specified in the
method and the return type is just ID.

00:29:38.330 --> 00:29:41.490
The answer is that the
class came from the archive.

00:29:41.800 --> 00:29:47.630
However, the archive came from the remote
process and because we're talking

00:29:47.630 --> 00:29:53.530
about privilege and process boundaries,
we shouldn't just trust the remote

00:29:53.530 --> 00:29:53.530
process's opinion about what kind
of class should be allocated.

00:29:55.120 --> 00:29:57.760
So we need some way to
specify the expected class.

00:29:57.930 --> 00:30:00.430
The reason is because that class
could have been any kind of

00:30:00.510 --> 00:30:04.000
class in your application or any
frameworks or libraries that it uses.

00:30:04.160 --> 00:30:07.500
And that's a huge surface area to
find a security vulnerability in.

00:30:07.500 --> 00:30:10.420
It would be much better to just
specify up front a very limited set

00:30:10.420 --> 00:30:13.000
of classes that this object can be.

00:30:13.010 --> 00:30:15.540
So here's one way we can do it.

00:30:16.490 --> 00:30:20.760
In the protocol that we saw earlier,
we specified some class information.

00:30:20.760 --> 00:30:23.000
We said the first argument is a string,
the second one is a date,

00:30:23.090 --> 00:30:25.830
the first argument of the
reply block is a ticket.

00:30:25.960 --> 00:30:30.100
So this information we can actually get
now using some new metadata provided

00:30:30.100 --> 00:30:32.330
by the Clang compiler in Mountain Lion.

00:30:32.380 --> 00:30:35.960
So it's important -- oh, good.

00:30:36.090 --> 00:30:39.460
So the use of the Clang compiler
is required for this feature,

00:30:39.460 --> 00:30:41.300
so that's important to note.

00:30:41.440 --> 00:30:44.260
But as we saw earlier,
objects don't travel by themselves.

00:30:44.360 --> 00:30:45.640
They come in graphs.

00:30:45.760 --> 00:30:49.580
So we need some more information about
this object beyond just the top level

00:30:49.580 --> 00:30:51.170
that was specified in the protocol.

00:30:51.330 --> 00:30:55.830
And to do that, we have a new protocol
called NSSecureCoding and

00:30:55.830 --> 00:30:58.060
three new NSCoder methods.

00:30:59.560 --> 00:31:03.260
So in the past, in your init with Coder,
you may have done something like this.

00:31:03.260 --> 00:31:06.710
Decode object for key and then
check the result to see if it's a

00:31:06.710 --> 00:31:10.740
kind of ticket class or that means
a ticket or a subclass of ticket.

00:31:10.780 --> 00:31:14.330
Now,
this is useful from some points of view.

00:31:14.500 --> 00:31:17.120
If we accidentally send
that ticket object a message

00:31:17.230 --> 00:31:19.940
that it doesn't implement,
we would prevent an

00:31:19.940 --> 00:31:21.160
exception in this case.

00:31:21.210 --> 00:31:23.760
But in terms of security,
it's already too late.

00:31:23.970 --> 00:31:26.160
And as I mentioned,
that's because we already called Alec

00:31:26.180 --> 00:31:27.970
and we already called init with Coder.

00:31:28.090 --> 00:31:30.330
So it's not good enough.

00:31:30.720 --> 00:31:33.370
Instead,
what we need to do is specify it up

00:31:33.560 --> 00:31:36.320
front using these new NSCoder methods.

00:31:36.380 --> 00:31:40.140
The first is called decode
object of class for key.

00:31:40.220 --> 00:31:43.650
And so if the expected object is
of one kind of class or a subclass,

00:31:43.760 --> 00:31:45.240
then you can use this method.

00:31:45.250 --> 00:31:49.080
Now, what will happen is if -- when
using NSXPCConnection is that

00:31:49.090 --> 00:31:52.100
if the class doesn't match,
then we're just going to drop

00:31:52.100 --> 00:31:53.110
the message on the floor.

00:31:53.360 --> 00:31:55.940
Your application or service
doesn't need to worry about it.

00:31:56.010 --> 00:31:56.440
It doesn't even have to know that
something came in that was unanswered.

00:31:56.530 --> 00:31:59.980
Under the hood,
what's happening is that the

00:31:59.980 --> 00:32:04.840
coder throws an exception and
NSXPCConnection catches it.

00:32:04.840 --> 00:32:07.750
So if you want to,
you can catch the exception yourself and

00:32:07.810 --> 00:32:09.890
take some kind of alternate behavior.

00:32:10.200 --> 00:32:13.020
Now, if the class is not
just one kind of class,

00:32:13.160 --> 00:32:16.060
but a property list type,
one of our property list types,

00:32:16.130 --> 00:32:19.920
then you can use this method,
decode property list for key.

00:32:19.920 --> 00:32:23.450
And if it's one of several kinds
of classes that aren't property

00:32:23.760 --> 00:32:26.890
list types or it's a collection,
then you can use this method,

00:32:26.980 --> 00:32:28.820
decode object of classes for key.

00:32:28.820 --> 00:32:31.680
The reason we use this for
collections is because a collection,

00:32:31.680 --> 00:32:35.420
by design, doesn't know a lot of details
about the content that it holds.

00:32:35.420 --> 00:32:37.990
So we just need a little bit of extra
help from you to tell us what kind

00:32:38.080 --> 00:32:40.260
of objects are expected to be in it.

00:32:40.310 --> 00:32:41.260
Here's how you do it.

00:32:41.380 --> 00:32:43.840
Create a set that contains
the expected classes,

00:32:43.870 --> 00:32:47.200
like that method looked like it
contained an array of tickets,

00:32:47.200 --> 00:32:49.420
so I have ticket class and array class.

00:32:49.420 --> 00:32:53.100
And then I use decode object
of classes and for key.

00:32:55.460 --> 00:32:58.410
So in order to send your
objects over NSXPCConnection,

00:32:58.410 --> 00:33:00.620
they are required to
adopt NSSecureCoding.

00:33:00.620 --> 00:33:03.640
By the way, NSSecureCoding is a
subprotocol of NSCoding.

00:33:03.760 --> 00:33:07.760
So here I've got my ticket object,
and you see it's got one property,

00:33:07.920 --> 00:33:10.180
a string, called destination.

00:33:11.230 --> 00:33:15.210
In its implementation,
the EncodeWithCoder looks exactly

00:33:15.210 --> 00:33:19.760
the same as it has been in the past,
where I use EncodeObjectForKey.

00:33:20.230 --> 00:33:23.340
Where things look a little bit
different is in the EnitWithCoder.

00:33:23.540 --> 00:33:29.140
There you're going to use those new
methods that I just talked about,

00:33:29.140 --> 00:33:29.140
DecodeObjectOfClassForKey.

00:33:29.580 --> 00:33:33.030
Now there's one more method to implement,
this is the method in NS Secure Coding,

00:33:33.030 --> 00:33:34.510
called Support Secure Coding.

00:33:34.680 --> 00:33:37.280
It's a class method,
and what you need to do is

00:33:37.340 --> 00:33:39.290
override it and return yes.

00:33:39.590 --> 00:33:42.700
There's one main reason for this.

00:33:42.840 --> 00:33:46.520
So NSSecureCoding protects a
very specific security issue,

00:33:46.650 --> 00:33:50.440
that arbitrary code execution
exploit that I mentioned.

00:33:50.560 --> 00:33:53.720
What it doesn't do is protect you
against things like buffer overruns or

00:33:53.720 --> 00:33:56.700
a false trust in the remote process.

00:33:56.760 --> 00:34:00.200
By that, I mean -- imagine that we
take a string argument,

00:34:00.300 --> 00:34:04.280
and then we just take its contents
and run it as a Perl script as root.

00:34:04.380 --> 00:34:07.410
Well, clearly that's going to be an
insecure kind of -- just the

00:34:07.480 --> 00:34:08.600
whole nature of it is insecure.

00:34:08.600 --> 00:34:10.100
We can't protect against that.

00:34:10.270 --> 00:34:14.500
So what we want you to do is,
when you adopt

00:34:14.500 --> 00:34:18.600
NSSecureCoding in your class,
review the code in your initWithCoder,

00:34:18.810 --> 00:34:21.770
put on your security hat,
and look for these kinds of

00:34:21.770 --> 00:34:23.560
security vulnerabilities.

00:34:23.650 --> 00:34:25.810
Or, you know,
maybe the class isn't suitable for

00:34:25.810 --> 00:34:27.760
crossing a privilege boundary at all.

00:34:27.910 --> 00:34:31.660
So put on your hat, review the code,
and then implement that method right next

00:34:31.660 --> 00:34:34.530
to your initWithCoder and return yes.

00:34:34.710 --> 00:34:38.090
To help you with this,
we implemented a rule that is that if you

00:34:38.100 --> 00:34:42.080
override init with coder in your class,
you must also override support

00:34:42.200 --> 00:34:44.290
secure coding and return yes.

00:34:44.420 --> 00:34:48.020
So if your superclass implements
NS secure coding and you

00:34:48.420 --> 00:34:51.490
override init with coder,
your superclass' implementation of

00:34:51.490 --> 00:34:53.100
support secure coding isn't enough.

00:34:53.400 --> 00:34:56.090
We want you to look at your init
with coder and make sure that

00:34:56.090 --> 00:34:59.360
it's secure and to indicate that,
you just implement that

00:34:59.360 --> 00:35:01.220
one method and return yes.

00:35:03.920 --> 00:35:07.440
So we talked a little bit
about collections earlier.

00:35:07.440 --> 00:35:10.490
Here we have a top-level collection
that's one in the protocol.

00:35:10.620 --> 00:35:14.260
So again, the collection doesn't know any
details about the content and

00:35:14.260 --> 00:35:18.000
because the protocol just says array,
we can't know from the protocol.

00:35:18.340 --> 00:35:21.220
So again, we're going to need a little
help to understand what kind of

00:35:21.340 --> 00:35:22.800
objects we expect to be in here.

00:35:22.800 --> 00:35:25.010
If it's a property list type,
one of these,

00:35:25.020 --> 00:35:28.140
then we're going to automatically
whitelist it for you and you

00:35:28.140 --> 00:35:29.660
have no additional work to do.

00:35:29.800 --> 00:35:32.590
If, on the other hand,
it's one of your objects,

00:35:32.590 --> 00:35:35.790
like this one appears to be
an array of ticket objects,

00:35:36.030 --> 00:35:39.800
then we need to set that information
up in the NSXPC interface.

00:35:39.800 --> 00:35:42.130
Here's how you do it.

00:35:42.300 --> 00:35:44.310
So there at the top
is our protocol again.

00:35:44.530 --> 00:35:46.780
So we're going to create our interface.

00:35:47.040 --> 00:35:49.060
Set its -- create a set
of expected classes.

00:35:49.190 --> 00:35:52.100
In this case,
I already know the top level is an array,

00:35:52.100 --> 00:35:56.520
so you just need to specify the
stuff that's in it -- tickets.

00:35:56.520 --> 00:35:59.050
And then use this method
on the interface object.

00:35:59.230 --> 00:36:01.990
Set classes for selector
argument index of reply.

00:36:02.080 --> 00:36:04.650
I want to go through it
argument by argument.

00:36:04.650 --> 00:36:06.950
The first one is the
set of expected classes.

00:36:07.170 --> 00:36:10.300
The second is the selector in the
protocol that we're modifying.

00:36:10.370 --> 00:36:14.050
The third argument is the index of
the argument that we're modifying.

00:36:14.050 --> 00:36:15.900
Here it's argument index zero.

00:36:15.900 --> 00:36:17.910
And the last argument
in this case will be no,

00:36:18.070 --> 00:36:20.170
because this method
doesn't have a reply block.

00:36:20.280 --> 00:36:23.380
We're modifying the argument
to the method itself.

00:36:23.480 --> 00:36:27.360
If instead it has a reply block,
like this one, get lots of tickets,

00:36:27.540 --> 00:36:31.420
it's a getter, you see the selector is
going to be that method.

00:36:31.420 --> 00:36:33.830
The argument -- sorry,
the last argument is yes,

00:36:33.830 --> 00:36:36.270
because we're talking
about the reply block,

00:36:36.270 --> 00:36:37.590
not the method itself.

00:36:37.620 --> 00:36:40.570
And then the argument index
refers to the argument of the

00:36:42.570 --> 00:36:48.960
So again, use this method to tell the
interface what the contents of

00:36:48.960 --> 00:36:48.960
your top-level collections are.

00:36:50.330 --> 00:36:55.190
Next, let's talk about a few design
patterns that you'll see as you

00:36:56.400 --> 00:36:56.400
start to adopt NSXPCConnection.

00:36:57.690 --> 00:36:59.980
In your service,
there are two key patterns.

00:37:00.050 --> 00:37:03.450
The first is one of having little state,
mostly functional and

00:37:03.720 --> 00:37:05.600
short-lived kind of state.

00:37:05.600 --> 00:37:08.110
In that case,
it's very common to have one singleton

00:37:08.110 --> 00:37:12.330
thread-safe object that implements both
the NSXPC listener delegate protocol

00:37:12.690 --> 00:37:15.830
and your exported object protocol.

00:37:16.390 --> 00:37:19.440
The other kind of pattern is one
where you have lots of state and you

00:37:19.450 --> 00:37:21.300
have long-lived kind of behavior.

00:37:21.340 --> 00:37:31.400
In that case, you'll typically have one
NSXPCListenerDelegate and

00:37:31.400 --> 00:37:31.400
in its delegate method,
will create one new exported

00:37:31.400 --> 00:37:31.400
object per connection.

00:37:32.990 --> 00:37:35.200
In the application,
you'll see a pattern of,

00:37:35.200 --> 00:37:38.960
as we saw a little bit earlier,
asynchronous UI updates

00:37:38.960 --> 00:37:43.070
and further separation of
interface and implementation.

00:37:43.910 --> 00:37:45.500
So I'm going to do one more demo.

00:37:45.540 --> 00:37:48.600
I want to show you how to add
an XPC service to a project.

00:37:48.600 --> 00:37:51.700
We're going to move some code
from the main application to that

00:37:52.120 --> 00:37:55.150
service and I'm going to show you
briefly how you might debug it.

00:37:55.270 --> 00:37:58.320
So let's go ahead and
quit the Flight Finder.

00:37:58.320 --> 00:37:58.320
We don't need that.

00:37:59.660 --> 00:38:02.540
Here I want to use a slightly
more complicated example.

00:38:02.550 --> 00:38:04.500
It's called Sandboxed Fetch.

00:38:04.530 --> 00:38:07.750
Now this is a public sample code
that I've actually taken and

00:38:07.840 --> 00:38:10.100
modified to use NSXPCConnection.

00:38:10.160 --> 00:38:14.100
And what it does is you just give it a
URL and it will download that from the

00:38:14.100 --> 00:38:18.180
Internet and then if this box is checked,
it will compress that file before

00:38:18.280 --> 00:38:20.460
saving it to a user-specified location.

00:38:20.610 --> 00:38:24.020
So here I've picked a URL that
has a fairly large image so

00:38:24.020 --> 00:38:26.220
that we can see some progress.

00:38:26.420 --> 00:38:28.610
And you see we've been
presented with our save panel,

00:38:28.640 --> 00:38:31.030
so I'm just going to go ahead
and save it on the desktop.

00:38:31.180 --> 00:38:33.900
And there is our file.

00:38:34.020 --> 00:38:37.050
So let's look at the
implementation of this project.

00:38:39.180 --> 00:38:40.820
So as you can see here,
we just have one target.

00:38:40.910 --> 00:38:43.140
So this is a single process application.

00:38:43.260 --> 00:38:46.860
It's code signed and it has
the entitlements to allow it

00:38:46.860 --> 00:38:50.850
to have an outgoing network
connection and also read/write

00:38:50.940 --> 00:38:53.490
access to my user-selected file.

00:38:53.610 --> 00:38:56.470
So if your application
deals with file formats,

00:38:56.590 --> 00:39:00.590
especially compression formats,
image formats, movie formats,

00:39:00.710 --> 00:39:05.050
audio formats, those kinds of things,
those are notorious for having security

00:39:05.050 --> 00:39:07.640
issues and problems that cause crashes.

00:39:07.720 --> 00:39:11.340
So those are prime candidates for
moving into a separate helper process

00:39:11.340 --> 00:39:13.480
that has a limited set of permissions.

00:39:13.620 --> 00:39:15.060
So that's what we're going to do.

00:39:15.100 --> 00:39:18.280
We're going to move the compression
stuff into an XPC service.

00:39:18.310 --> 00:39:22.230
So to do that,
I'm going to add a new target.

00:39:22.560 --> 00:39:24.910
Here in the framework
and library section,

00:39:24.950 --> 00:39:27.440
you see there's our XPC service template.

00:39:27.440 --> 00:39:31.200
You should give your XPC service a name
that reflects what it's going to do,

00:39:31.230 --> 00:39:32.980
like Zip Service.

00:39:33.080 --> 00:39:36.930
And I also suggest that you make
the company identifier have your

00:39:36.930 --> 00:39:41.440
application name so that the full
bundle identifier is a qualified bundle

00:39:41.440 --> 00:39:43.640
identifier so it's easy to identify.

00:39:44.060 --> 00:39:48.540
Again, this bundle identifier is what
we're going to use to connect to it.

00:39:48.540 --> 00:39:50.560
And go ahead and click finish.

00:39:50.570 --> 00:39:54.240
So we're going to add a
file to this zip service.

00:39:55.140 --> 00:40:00.690
A property list type called
ZipService.entitlements

00:40:01.210 --> 00:40:05.430
And the purpose of this file is to
enable sandboxing in our XPC service

00:40:05.510 --> 00:40:07.260
like our main application has.

00:40:07.380 --> 00:40:10.470
So the easiest way to do this is
we're just going to crib something

00:40:10.560 --> 00:40:12.290
from the main application here.

00:40:12.500 --> 00:40:15.880
Here's the same set of entitlements
we saw in that GUI earlier,

00:40:15.910 --> 00:40:18.100
but this is the real source of them.

00:40:18.170 --> 00:40:22.400
So I copy the app sandbox entitlement
and I'm just going to paste it here.

00:40:22.530 --> 00:40:25.720
So we're going to have no
permissions for this helper process

00:40:25.720 --> 00:40:27.880
besides just enabling the sandbox.

00:40:28.600 --> 00:40:32.370
Go back to our configuration.

00:40:32.510 --> 00:40:35.800
So in the build phases,
I'm going to add a dependency

00:40:35.800 --> 00:40:37.580
on a library called libz.

00:40:37.910 --> 00:40:40.400
That's what's actually
doing the compression.

00:40:42.050 --> 00:40:44.940
And in the build settings,
I'm going to turn on sandboxing

00:40:45.000 --> 00:40:47.880
by code signing my application.

00:40:55.680 --> 00:40:58.050
Drag it over from here so
I don't make any typos on stage.

00:40:58.140 --> 00:41:01.190
There we go.

00:41:01.270 --> 00:41:03.540
And we're done configuring
our ZIP service.

00:41:03.580 --> 00:41:05.950
Now we just need to
configure our application.

00:41:06.030 --> 00:41:08.160
This is in the same way
that we saw earlier.

00:41:08.260 --> 00:41:13.460
We're going to add a dependency on the
-- from the Sandbox Fetch application

00:41:13.460 --> 00:41:15.500
on the new service that we just created.

00:41:15.560 --> 00:41:19.100
That ensures that it's built correctly
and up-to-date when we need it to be.

00:41:19.180 --> 00:41:24.010
And add a new copy files build phase.

00:41:25.240 --> 00:41:31.310
And into the wrapper we're going
to put it in contents/XPC services,

00:41:31.310 --> 00:41:34.850
the same path that we saw earlier.

00:41:34.960 --> 00:41:42.180
And the file we're going to put
there is our XPC build product.

00:41:43.290 --> 00:41:46.050
So let's just go ahead and build
this application right now to see

00:41:46.050 --> 00:41:47.480
if everything worked correctly.

00:41:47.740 --> 00:41:49.310
So no build errors.

00:41:49.440 --> 00:41:55.670
And I'm going to show this project,
this build product in Finder.

00:41:58.400 --> 00:42:02.920
And there's our XPC service
in the XPC services directory.

00:42:03.080 --> 00:42:05.060
So it's been put in the right place.

00:42:05.120 --> 00:42:07.060
Okay, so that was step one.

00:42:07.170 --> 00:42:10.020
Now we're going to move some
code from the main application

00:42:10.120 --> 00:42:11.670
into this helper service.

00:42:13.620 --> 00:42:17.410
Here is the header file that
describes the zip interface.

00:42:17.480 --> 00:42:20.330
It's a singleton object where
you get this shared zipper and

00:42:20.410 --> 00:42:23.920
then you send it this message,
"Compress file to file with

00:42:24.060 --> 00:42:26.500
reply." It uses NSFileHandle.

00:42:26.700 --> 00:42:30.180
This is a good time to mention
that NSFileHandle has been enhanced

00:42:30.180 --> 00:42:33.370
in Mountain Lion to allow it
to be sent between processes

00:42:33.370 --> 00:42:35.090
using this NSXPCConnection.

00:42:35.550 --> 00:42:38.690
So that means that, as you notice,
we didn't give the helper service any

00:42:38.690 --> 00:42:40.500
permission to open files on its own.

00:42:40.500 --> 00:42:41.500
The main application has it.

00:42:41.570 --> 00:42:44.490
And when we send this file
to it over NSXPCConnection,

00:42:44.490 --> 00:42:48.690
the other process will have
permission to access it automatically.

00:42:49.410 --> 00:42:52.380
So if you remember,
one of my patterns was

00:42:52.380 --> 00:42:56.940
a further separation of
interface and implementation.

00:42:56.940 --> 00:43:01.760
So what we're going to do is split
out this compressed file logic

00:43:01.760 --> 00:43:04.590
into a new interface called ZIP.

00:43:05.440 --> 00:43:09.910
And this zipper object will conform to
that and it will also be a singleton

00:43:09.910 --> 00:43:14.300
object because it's got very little
state to hold and it's short-lived.

00:43:14.370 --> 00:43:17.820
So we're going to implement both
the exported object protocol and the

00:43:17.820 --> 00:43:20.650
NSXPC listener delegate protocol.

00:43:21.840 --> 00:43:23.800
Let's go ahead and do that now.

00:43:23.810 --> 00:43:30.180
Here is the implementation
of that zipper functionality.

00:43:30.180 --> 00:43:30.180
This is the compressed file method.

00:43:31.290 --> 00:43:36.800
What I want to do here is put
in the implementation of the

00:43:37.610 --> 00:43:39.130
NSXPCListenerDelegate protocol.

00:43:39.790 --> 00:43:41.700
Listener should accept new connection.

00:43:41.700 --> 00:43:43.440
And again,
we're going to set our exported

00:43:43.640 --> 00:43:45.300
interface to be the zip protocol.

00:43:45.470 --> 00:43:47.970
Set our exported object to be
self because it's a singleton

00:43:48.270 --> 00:43:49.700
and resume the connection.

00:43:50.070 --> 00:43:55.310
Now pay attention because
this is the hardest part.

00:43:55.310 --> 00:43:55.310
I'm going to move --

00:43:55.520 --> 00:44:01.790
This logic from this file from
sandbox fetch to the zip service.

00:44:01.790 --> 00:44:01.790
There we go.

00:44:03.810 --> 00:44:04.700
Okay.

00:44:04.700 --> 00:44:06.690
So that was the interface.

00:44:06.750 --> 00:44:09.700
Next, let's look at the listener.

00:44:09.940 --> 00:44:14.700
So we can add an import of our

00:44:15.800 --> 00:44:33.400
[Transcript missing]

00:44:33.820 --> 00:44:40.510
set its delegate to be one of these
zipper objects and resume the connection.

00:44:41.710 --> 00:44:44.900
So finally, we just need to,
in the main application,

00:44:45.020 --> 00:44:49.110
instead of creating the zipper itself,
we're just going to instead send

00:44:49.330 --> 00:44:51.300
that request to our XPC service.

00:44:51.420 --> 00:44:53.820
So this method is called

00:44:54.170 --> 00:44:55.800
: Save file.

00:44:56.630 --> 00:45:07.240
And its job is to present that UI where
we displayed the panel and then also

00:45:07.240 --> 00:45:12.680
once the user has decided to compress it,
create a file handle

00:45:12.680 --> 00:45:12.680
and then zip the file.

00:45:12.680 --> 00:45:12.680
So what we'll do here is

00:45:14.550 --> 00:45:15.790
Create the connection.

00:45:15.790 --> 00:45:18.840
These are the exact same
lines of code we saw earlier.

00:45:18.880 --> 00:45:28.250
In it with service name, there is our
com.demo.SandboxedFetch.ZipServiceBundle

00:45:28.250 --> 00:45:29.980
Identifier.

00:45:29.980 --> 00:45:29.980
Set the remote object interface to be the
zip protocol and resume the connection.

00:45:30.810 --> 00:45:33.030
As I mentioned earlier,
we need to invalidate the

00:45:33.030 --> 00:45:34.900
connection when we're done with it.

00:45:34.900 --> 00:45:38.660
So this reply block will be called
after the compression is done.

00:45:38.860 --> 00:45:41.920
That seems like a good time to invalidate
the connection because we're no longer

00:45:42.070 --> 00:45:44.700
going to need it after that point.

00:45:44.850 --> 00:45:46.950
And finally,
instead of using the singleton

00:45:47.020 --> 00:45:51.300
shared zipper that was in process,
we're going to use the remote object

00:45:51.440 --> 00:45:56.100
proxy that comes from the connection
that implements the zip protocol.

00:45:57.480 --> 00:46:03.130
So let's run it again and see
if everything behaves correctly.

00:46:03.360 --> 00:46:05.780
I'll bring up Activity Monitor again.

00:46:09.060 --> 00:46:14.110
: We're going to filter
it for zip service.

00:46:14.120 --> 00:46:16.510
I'll click fetch.

00:46:16.520 --> 00:46:19.590
The file is downloaded.

00:46:19.590 --> 00:46:21.260
Click save.

00:46:21.260 --> 00:46:26.020
Replace the one we already downloaded.

00:46:26.020 --> 00:46:26.020
You see that as the
compression started to happen,

00:46:26.020 --> 00:46:26.020
our zip service started and
it's correctly sandboxed.

00:46:27.320 --> 00:46:30.290
So, I mentioned earlier that
NSXPCConnection has a feature

00:46:30.290 --> 00:46:32.050
of providing crash protection.

00:46:32.050 --> 00:46:35.200
So, to demonstrate that,
I'm just going to go ahead and

00:46:35.390 --> 00:46:37.630
kill this background process.

00:46:37.920 --> 00:46:40.950
And you see that the main
application just continued to run.

00:46:40.960 --> 00:46:44.100
In fact, the user didn't even need to
know that that process went away.

00:46:44.180 --> 00:46:49.050
So I'll take this opportunity to show you
some debugging tips about how to actually

00:46:49.060 --> 00:46:51.460
go ahead and debug these XPC services.

00:46:51.530 --> 00:46:52.790
There's a couple of ways.

00:46:52.910 --> 00:46:56.560
One way is you notice that we
have a new zip service here,

00:46:56.620 --> 00:46:59.300
and we can edit this scheme.

00:47:01.620 --> 00:47:08.920
and choose our new executable in
the same place that we saw earlier.

00:47:10.300 --> 00:47:26.900
[Transcript missing]

00:47:30.000 --> 00:47:32.500
You notice that -- oh,
maybe it would be a good idea

00:47:32.500 --> 00:47:33.900
to actually set a breakpoint.

00:47:33.900 --> 00:47:39.490
Let's do that.

00:47:39.490 --> 00:47:39.490
In the compressed file.

00:48:01.010 --> 00:48:02.430
Through all that,
our main application is still running,

00:48:02.460 --> 00:48:05.860
so that's the crash protection for you.

00:48:05.890 --> 00:48:09.230
And let's see, I'm going to go ahead and
rerun our zip service.

00:48:09.290 --> 00:48:12.410
And it's waiting with
a breakpoint this time.

00:48:12.460 --> 00:48:16.380
Download and save.

00:48:17.530 --> 00:48:19.860
And the main application is
just waiting for the reply here.

00:48:20.110 --> 00:48:23.140
You notice asynchronously,
because I can still, you know,

00:48:23.570 --> 00:48:27.510
although it's just playing a sheet,
I can still -- wow, that's interesting.

00:48:28.640 --> 00:48:30.180
: Okay.

00:48:30.310 --> 00:48:31.930
Somebody report that one.

00:48:32.260 --> 00:48:35.120
Anyway, so in Xcode --

00:48:35.270 --> 00:48:42.040
In Xcode, we stopped on our breakpoint in
the sandbox fetch helper process.

00:48:42.070 --> 00:48:45.360
And you see that we are allowed
to both debug the service and

00:48:45.360 --> 00:48:48.000
the application at the same time.

00:48:48.080 --> 00:48:52.750
So here I can, you know,
view the values of various, you know,

00:48:52.750 --> 00:48:57.410
values or step through my process
and then when I continue it,

00:48:57.450 --> 00:49:01.880
our main application has received
its response and hidden the

00:49:02.180 --> 00:49:04.500
panel and everything is finished.

00:49:04.500 --> 00:49:08.260
So it's actually pretty easy to
split up your process and debug

00:49:08.260 --> 00:49:10.440
it at the same time in Xcode.

00:49:10.440 --> 00:49:11.440
Okay.

00:49:11.440 --> 00:49:12.720
Let's go back to our slides.

00:49:12.720 --> 00:49:16.650
So just like we moved from single
threaded to multi-threaded applications,

00:49:16.730 --> 00:49:20.820
today we're moving from single
process to multi-process applications.

00:49:20.830 --> 00:49:22.420
It provides two key benefits.

00:49:22.420 --> 00:49:25.620
The first is security by
allowing these helper processes

00:49:25.620 --> 00:49:29.160
to have only the permissions
that they need to do their job.

00:49:29.160 --> 00:49:32.270
The second is crash protection,
so if something goes wrong,

00:49:32.380 --> 00:49:35.740
then the user doesn't have to interrupt
it and lose all of their work.

00:49:35.740 --> 00:49:38.650
NSXPC connection is designed
to help you connect them.

00:49:38.800 --> 00:49:42.160
Again, it works with your own
objects and interfaces.

00:49:42.160 --> 00:49:44.760
And it's designed to be
both secure and modern.

00:49:44.760 --> 00:49:45.960
There are three main pieces.

00:49:45.960 --> 00:49:48.690
The interfaces,
which provide a clear division

00:49:48.690 --> 00:49:52.720
of responsibility and abstract
away implementation details.

00:49:52.810 --> 00:49:54.730
Connections,
which provide the bidirectional

00:49:54.740 --> 00:49:56.440
communication channel between them.

00:49:56.440 --> 00:49:58.710
And finally, listeners,
whose job it is to await new

00:49:58.710 --> 00:50:01.700
incoming connections and allow
a delegate to configure them.

00:50:03.850 --> 00:50:07.040
For more information,
here are some links for you.

00:50:07.070 --> 00:50:11.800
The sandbox fetch 2 example that I showed
is available as part of this session.

00:50:11.830 --> 00:50:15.790
In the sample that you see online,
I've split it up into three processes

00:50:15.940 --> 00:50:17.800
because three is better than two.

00:50:17.800 --> 00:50:20.040
And the third process
actually does the downloading.

00:50:20.040 --> 00:50:22.800
So we've even separated out
the permissions further.

00:50:22.970 --> 00:50:26.080
And for those of you watching on video,
we hope to get this promoted to a

00:50:26.160 --> 00:50:27.610
public sample code as well soon.

00:50:27.800 --> 00:50:31.740
XPCConnection,
NSXPCConnection is based on top of XPC,

00:50:31.810 --> 00:50:32.620
of course.

00:50:32.710 --> 00:50:35.210
So you'll find a lot
of helpful information,

00:50:35.240 --> 00:50:38.870
especially about the error handling
stuff in the XPC man pages.

00:50:40.180 --> 00:50:43.210
We have one more related session,
that's tomorrow morning,

00:50:43.210 --> 00:50:46.500
and that's Asynchronous
Design Patterns with Blocks,

00:50:46.500 --> 00:50:47.520
GCD, and XPC.

00:50:47.650 --> 00:50:51.860
So this session is about the
underlying parts of NSXPCConnection,

00:50:51.940 --> 00:50:54.370
but the design patterns that they're
going to go through are really

00:50:54.370 --> 00:50:57.260
helpful to help understand how you
might segregate your application.

00:50:57.260 --> 00:51:01.830
I gave you some simple examples,
and they'll show you

00:51:01.830 --> 00:51:03.950
some more advanced ones.

00:51:04.180 --> 00:51:05.120
So that's it.

00:51:05.120 --> 00:51:05.120
I hope you go out and make
some great applications.
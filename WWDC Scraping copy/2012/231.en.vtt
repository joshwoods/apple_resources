WEBVTT

00:00:11.280 --> 00:00:13.020
Welcome to session 231.

00:00:13.200 --> 00:00:15.700
I'm your host, Raleiigh Ledet.

00:00:15.820 --> 00:00:18.320
Today we're going to talk
about what's new with gestures.

00:00:18.400 --> 00:00:19.640
And quite a bit, actually.

00:00:19.640 --> 00:00:22.090
As you can see,
we have a lot to go through.

00:00:22.200 --> 00:00:24.380
We've got some scrolling improvements
that we're going to talk about,

00:00:24.380 --> 00:00:25.600
some great things going on there.

00:00:25.600 --> 00:00:30.470
We have the smart magnification gesture,
which was actually released in line.

00:00:30.470 --> 00:00:34.550
We now have public API for you to
be able to take advantage of that.

00:00:34.650 --> 00:00:37.740
In a scroll view has done
some gesture adoption itself,

00:00:37.830 --> 00:00:38.860
so you can take advantage of that.

00:00:38.860 --> 00:00:40.230
We'll cover that.

00:00:40.300 --> 00:00:42.230
We have a brand new NS page controller.

00:00:42.300 --> 00:00:47.200
This controller makes swiping easy,
and we'll cover that.

00:00:47.410 --> 00:00:50.000
We have the Quick Look gesture,
which has been around for a while.

00:00:50.160 --> 00:00:53.510
We have public API for that,
so you can catch a Quick Look gesture

00:00:53.930 --> 00:00:56.040
API and take advantage of that.

00:00:56.170 --> 00:00:59.280
And we'll wrap everything up with
some best practices and how you can

00:00:59.280 --> 00:01:03.090
future proof your application with
regards to gestures as we continue

00:01:03.090 --> 00:01:05.860
to evolve gestures on the desktop.

00:01:05.990 --> 00:01:08.770
So let's get right into
scrolling improvements.

00:01:09.910 --> 00:01:14.400
One of the things you'll notice
right away with scrollers now is

00:01:14.400 --> 00:01:19.140
when you roll over a visible track,
they automatically expand.

00:01:19.200 --> 00:01:21.890
And so this gives you a little bit wider
thumb and a little bit wider track,

00:01:21.980 --> 00:01:23.070
and it's easier to grab.

00:01:23.120 --> 00:01:24.960
It's been working out really great.

00:01:25.030 --> 00:01:29.800
But one of the interesting things about
this is that the track metrics are a

00:01:29.800 --> 00:01:32.660
little bit wider than they were in Lion.

00:01:32.710 --> 00:01:36.020
In Lion, we made sure the overlay track
metrics were actually the same

00:01:36.020 --> 00:01:37.390
metrics as the legacy track.

00:01:37.600 --> 00:01:40.190
And the legacy metrics haven't changed,
but the overlay scroller

00:01:40.200 --> 00:01:41.230
metrics have changed.

00:01:41.300 --> 00:01:44.090
And if you depend on that,
you need to be sure that you're calling

00:01:44.130 --> 00:01:48.140
this API that was introduced in Lion,
scroller width for control size,

00:01:48.370 --> 00:01:50.450
scroller style, and set the right style.

00:01:50.580 --> 00:01:52.270
And you'll get the appropriate metrics.

00:01:52.510 --> 00:01:55.270
And that way you can
adjust appropriately,

00:01:55.270 --> 00:01:58.840
and the metrics can change in the future,
and you will just

00:01:58.840 --> 00:02:02.360
automatically adapt for that,
and life will be grand.

00:02:02.410 --> 00:02:06.530
I'm sure you've noticed right away
the other interesting thing is that

00:02:06.530 --> 00:02:07.490
scrollers are not just a matter
of how many scrollers you have.

00:02:07.830 --> 00:02:10.790
Overlay scrollers have a
new look in Mountain Lion.

00:02:10.950 --> 00:02:12.770
We no longer have the
rounded caps in the track.

00:02:12.860 --> 00:02:13.730
They're squared off.

00:02:13.760 --> 00:02:16.340
The thumbs have a little
bit different look,

00:02:16.400 --> 00:02:19.940
and they actually overlap
in the corners now.

00:02:20.000 --> 00:02:23.010
And this means we also have a new
look for the other knob styles.

00:02:23.180 --> 00:02:24.940
This is the dark knob style.

00:02:25.240 --> 00:02:29.300
And along with changing
the knob style look,

00:02:29.550 --> 00:02:32.680
the track now looks at the knob style
and adjusts accordingly as well.

00:02:32.780 --> 00:02:36.360
So this is the expanded track
for the dark knob style,

00:02:36.420 --> 00:02:37.490
and this is the overlay scroller.

00:02:37.590 --> 00:02:41.100
And this is the light knob style and the
expanded track for the light knob style.

00:02:41.160 --> 00:02:43.640
So you see how it works a little
bit better with your content.

00:02:43.950 --> 00:02:47.700
So this is handled automatically for
you just by looking at the knob style.

00:02:47.770 --> 00:02:49.540
So there's a new look.

00:02:50.550 --> 00:02:53.380
Another really interesting thing
that we have in Mountain Lion,

00:02:53.410 --> 00:02:58.400
and this only works on the Magic Trackpad
or the trackpad built into the MacBooks,

00:02:58.400 --> 00:03:02.790
it doesn't work on the Magic Mouse,
but when you place two

00:03:02.790 --> 00:03:06.320
fingers on a trackpad,
the scrollers will automatically appear.

00:03:06.320 --> 00:03:10.020
They automatically appear
over wherever the cursor is.

00:03:10.140 --> 00:03:12.170
The view that's under the cursor,
if that's a scroll view,

00:03:12.170 --> 00:03:14.620
the scrollers will automatically appear.

00:03:14.620 --> 00:03:18.300
This makes it really nice and much easier
to see where you are in your content and

00:03:18.330 --> 00:03:20.100
get them to pop up when you need them.

00:03:20.100 --> 00:03:22.000
Otherwise,
they're away and out of the way,

00:03:22.000 --> 00:03:24.880
and you have complete
access to your content,

00:03:24.880 --> 00:03:27.720
and you can focus just on your content.

00:03:29.300 --> 00:05:04.600
[Transcript missing]

00:05:05.680 --> 00:05:08.020
We have added accelerated
scrolling in Mountain Lion.

00:05:08.230 --> 00:05:11.830
This is an iOS style scrolling
where if you continue to scroll on

00:05:11.950 --> 00:05:15.290
the trackpad or the Magic Mouse,
in this case it works for both,

00:05:15.420 --> 00:05:17.940
that the scrolling will become
accelerated and it will zip

00:05:17.940 --> 00:05:19.650
through your content a lot faster.

00:05:19.800 --> 00:05:21.950
The great thing is there's
nothing for you to do.

00:05:22.050 --> 00:05:24.060
Scrolling delta is
automatically accelerated,

00:05:24.060 --> 00:05:26.210
so this should just work
in your applications now.

00:05:26.380 --> 00:05:29.910
You should give it a
try and check it out.

00:05:30.060 --> 00:05:34.620
Apple takes care of the problem
of noticing when and recognizing

00:05:34.620 --> 00:05:38.640
when the user has performed three
consecutive scroll gestures.

00:05:38.690 --> 00:05:40.520
And at that point,
acceleration starts to kick in.

00:05:40.520 --> 00:05:43.270
And as long as the user
continues swiping quickly,

00:05:43.440 --> 00:05:45.400
the acceleration will increase.

00:05:45.570 --> 00:05:49.900
If the user starts scrolling slowly
once they're in accelerated mode,

00:05:50.050 --> 00:05:53.990
the system will automatically kick
out of accelerated mode and go

00:05:53.990 --> 00:05:55.780
back to normal scrolling speed.

00:05:55.780 --> 00:06:00.090
Or if the user waits too long
between physically scroll gestures,

00:06:00.160 --> 00:06:03.230
between when they lifted their fingers
and when they touched their fingers

00:06:03.310 --> 00:06:06.330
back on the trackpad or the Magic Mouse,
will automatically get out of

00:06:06.380 --> 00:06:08.350
accelerated scrolling for you.

00:06:08.620 --> 00:06:10.590
So again, there's nothing for you to do.

00:06:10.600 --> 00:06:12.260
You should try it out
in your application.

00:06:12.280 --> 00:06:12.880
It just works.

00:06:12.880 --> 00:06:14.720
In fact,
let's go ahead and give you a demo

00:06:14.720 --> 00:06:16.800
of the scrolling improvements.

00:06:16.800 --> 00:06:20.300
So I have my Magic Trackpad here.

00:06:20.570 --> 00:06:25.300
And we'll notice as soon as I put
two fingers to the trackpad,

00:06:25.530 --> 00:06:26.340
the scroller appears.

00:06:26.340 --> 00:06:27.100
We've got a little thumb there.

00:06:27.100 --> 00:06:28.330
This is a very long document.

00:06:28.330 --> 00:06:29.620
It's over 10,000 lines long.

00:06:29.620 --> 00:06:31.900
It's a log file that I generated.

00:06:31.900 --> 00:06:37.120
And you can see as I normally scroll that
that thumb doesn't move very much at all.

00:06:37.180 --> 00:06:40.150
But on the third consecutive scroll,
you'll see the thumb starts to really

00:06:40.150 --> 00:06:42.020
accelerate as I zoom through the content.

00:06:42.020 --> 00:06:44.790
So we go one, two, three,
and you see that scroller.

00:06:44.880 --> 00:06:47.600
That thumb really goes as I can
get all the way through my

00:06:47.600 --> 00:06:49.290
content very quickly that way.

00:06:51.270 --> 00:06:53.690
You notice I put two fingers
down as I go into the track.

00:06:53.880 --> 00:06:56.740
It automatically expands out,
a nice little animation,

00:06:56.870 --> 00:07:00.440
and it stays out until I roll back over.

00:07:00.520 --> 00:07:04.870
And if your cursor is already
where the track should be

00:07:04.940 --> 00:07:08.660
when you put two fingers down,
it shows up and goes away.

00:07:08.800 --> 00:07:11.740
So that is scrolling.

00:07:13.290 --> 00:07:16.600
So let's move away from the
scrolling gesture and talk

00:07:16.820 --> 00:07:18.890
about smart magnification.

00:07:19.760 --> 00:07:24.480
You might have seen this in Lion,
particularly in Safari,

00:07:24.480 --> 00:07:29.420
if you did a two-finger double
tap over content in Safari,

00:07:29.420 --> 00:07:34.010
that content would automatically
magnify at the appropriate level.

00:07:34.020 --> 00:07:35.700
So let's take a look at that gesture.

00:07:35.700 --> 00:07:37.230
It's a two-finger double tap.

00:07:37.380 --> 00:07:38.340
Let's take a look at it again.

00:07:38.550 --> 00:07:39.650
Two-finger double tap.

00:07:39.670 --> 00:07:42.340
It's really easy, it's really great,
and it performs a smart magnification.

00:07:43.440 --> 00:07:46.240
So we have a public way for you to
access this now in Mountain Lion with

00:07:46.310 --> 00:07:48.560
a new responder method,
smart magnify with event.

00:07:48.600 --> 00:07:51.500
And this suggests that
we have a new event type,

00:07:51.500 --> 00:07:52.740
and indeed we do.

00:07:52.740 --> 00:07:55.360
There's NS event type smart magnify.

00:07:57.590 --> 00:08:00.730
The only properties that are
really valid for a Smart Magnify

00:08:00.730 --> 00:08:02.740
event are location and window.

00:08:02.760 --> 00:08:04.730
So you can find out exactly
where the Smart Magnify

00:08:04.730 --> 00:08:06.120
gesture occurred and modifiers.

00:08:06.310 --> 00:08:08.870
So you can find out what modifiers,
if any, were pressed on the keyboard

00:08:08.870 --> 00:08:09.920
when the event occurred.

00:08:09.940 --> 00:08:13.200
Along with the new event type,
we have a new event mask,

00:08:13.270 --> 00:08:15.460
and it's Event Mask Smart Magnify.

00:08:15.460 --> 00:08:19.620
And you can use this in your
local event observers or if you're

00:08:19.820 --> 00:08:22.200
doing next event matching mask.

00:08:22.810 --> 00:08:24.800
Though these are
generally one-shot events,

00:08:24.800 --> 00:08:27.690
so it's probably not all that
useful for next event matching mask,

00:08:27.810 --> 00:08:30.600
but for a local event monitor,
it might be interesting.

00:08:30.600 --> 00:08:35.320
However, there's one rather large caveat
with these new event type,

00:08:35.320 --> 00:08:37.920
and that they're 64-bit only.

00:08:37.920 --> 00:08:42.300
It turns out on 32-bit,
we have a 32-bit mask for our events,

00:08:42.330 --> 00:08:44.020
and we've run out of bits.

00:08:44.020 --> 00:08:48.210
So we've had to restrict
this to 64-bit only.

00:08:48.220 --> 00:08:50.080
What does it mean to Smart Magnify?

00:08:50.080 --> 00:08:54.060
And to do this individually... Well,
the simple case,

00:08:54.060 --> 00:08:56.860
we have some human interface
guidelines for this,

00:08:56.860 --> 00:09:00.860
and the simple case is you just zoom
in 150%, you magnify back out to

00:09:00.860 --> 00:09:03.660
100%, and you toggle between the two.

00:09:03.660 --> 00:09:06.110
If the user has,
through the user interface,

00:09:06.110 --> 00:09:08.680
or perhaps a two-finger
pinch magnify gesture,

00:09:08.730 --> 00:09:13.270
have changed the magnification level so
you're not at 100%, if you're at anything

00:09:13.610 --> 00:09:19.490
other than 100%, go back to 100%.
If you're at 100%, then you can zoom,

00:09:19.490 --> 00:09:21.910
you can magnify to 150%.

00:09:22.460 --> 00:09:23.300
But you can do better than that.

00:09:23.300 --> 00:09:29.310
In Safari, you double tap on some div
content and that whole section

00:09:29.840 --> 00:09:31.350
grows to fill the screen.

00:09:31.430 --> 00:09:33.660
And so we have the more complex
version of the rules from

00:09:33.660 --> 00:09:35.910
Human Interface Guidelines,
which works out well

00:09:35.920 --> 00:09:37.860
depending on your content.

00:09:37.930 --> 00:09:42.230
Magnify such that the width of the target
grouping fits inside the scroll view,

00:09:42.270 --> 00:09:46.230
centering the target point
vertically if possible.

00:09:46.300 --> 00:09:49.590
Magnify to 100% if the mouse
hasn't moved and already

00:09:49.600 --> 00:09:51.960
magnified to the deepest grouping.

00:09:52.880 --> 00:09:55.550
That's quite a lot to say,
even just reading it off the slide.

00:09:55.560 --> 00:09:58.520
Let me sum it up for you.

00:09:58.570 --> 00:10:00.600
Use in a scroll view.

00:10:02.070 --> 00:10:04.130
Speaking of NSScrollView,
let's talk about

00:10:04.280 --> 00:10:05.840
ScrollView gesture adoption.

00:10:05.840 --> 00:10:08.650
As you might have guessed,
it's adopted magnification

00:10:08.740 --> 00:10:10.190
and smart magnification.

00:10:10.320 --> 00:10:12.450
So you have magnification and
smart magnification built right

00:10:12.450 --> 00:10:13.640
into NSScrollView for you.

00:10:13.640 --> 00:10:16.160
You no longer have to
implement it yourself.

00:10:16.170 --> 00:10:19.270
And let me give you a quick demo of that.

00:10:20.090 --> 00:10:24.200
So here we have a lovely
dinner recipe in TextEdit.

00:10:24.420 --> 00:10:27.680
And just use a basic scroll view.

00:10:27.680 --> 00:10:30.750
You can see the TextEdit source code.

00:10:30.880 --> 00:10:34.480
And I'll do a two-finger
double tap on this table.

00:10:34.500 --> 00:10:35.880
And you see it goes into Table.

00:10:35.990 --> 00:10:39.980
And what's interesting here is not
only has ScrollView implemented

00:10:39.980 --> 00:10:43.880
Smart Magnify and Magnify,
in this case, in its TextView also has a

00:10:43.980 --> 00:10:47.920
little bit more intelligence to
work with ScrollView and will

00:10:47.920 --> 00:10:49.620
automatically magnify the tables,
for example.

00:10:49.690 --> 00:10:53.960
And I can even go another level deep
and zoom all the way into one cell.

00:10:54.100 --> 00:10:57.180
So we can Smart Magnify again,
and we come back out.

00:10:57.360 --> 00:11:00.840
So of course,
we also have regular pinch zooming.

00:11:00.840 --> 00:11:03.420
So you could just use a
two-finger pinch zoom,

00:11:03.470 --> 00:11:07.990
and it's nice and centered with where
you're pinching and will automatically...

00:11:08.350 --> 00:11:11.300
moved the content around and it
automatically rubber bands at

00:11:11.730 --> 00:11:14.040
the 1.0 scale factor for you,
which is great.

00:11:14.400 --> 00:11:17.890
TextEdit has gone a little
bit further than just what

00:11:17.990 --> 00:11:22.980
TextView provides and has added some
more magnification help for ScrollView.

00:11:23.040 --> 00:11:27.630
And that if I smart magnify here,
it's zoomed in all the way into

00:11:27.630 --> 00:11:29.860
the content past the margins.

00:11:29.960 --> 00:11:33.760
So you could just look directly at
your content and manipulate that.

00:11:33.800 --> 00:11:36.450
I'll give you another quick example.

00:11:37.240 --> 00:11:39.170
Here's this little app.

00:11:39.530 --> 00:11:42.200
This is just a little
sample app I put together.

00:11:42.200 --> 00:11:44.110
And you can zoom in there.

00:11:44.200 --> 00:11:47.340
And of course,
you can also smart magnify.

00:11:47.660 --> 00:11:50.540
And it fills the content for there.

00:11:50.540 --> 00:11:57.100
Or you can smart magnify, perhaps,
on the image of the dog.

00:11:57.100 --> 00:11:58.790
And it'll smart magnify to the dog.

00:11:58.790 --> 00:11:58.790
And that works out quite
nicely with very little code.

00:11:59.570 --> 00:12:05.190
So let's focus on magnification first,
because smart magnification is built

00:12:05.190 --> 00:12:07.480
on top of magnification in ScrollView.

00:12:07.600 --> 00:12:09.460
There's a new property
on in a ScrollView,

00:12:09.460 --> 00:12:10.700
allows magnification.

00:12:10.760 --> 00:12:13.640
There's also a checkbox in
Interface Builder inside Xcode.

00:12:13.640 --> 00:12:14.640
You can just turn that on.

00:12:14.640 --> 00:12:18.190
You have to, as defaults to no,
you have to set allows magnification

00:12:18.290 --> 00:12:21.320
to yes for ScrollView to
start doing magnification.

00:12:21.600 --> 00:12:25.230
We can't just turn it on by default
because then lots of content and UI all

00:12:25.230 --> 00:12:29.480
over the place would start magnifying
that really shouldn't perhaps magnify.

00:12:29.480 --> 00:12:30.950
But it's really easy to adopt.

00:12:31.020 --> 00:12:34.620
Along with allows magnification,
there's max magnification

00:12:34.620 --> 00:12:36.070
and min magnification.

00:12:36.120 --> 00:12:39.270
By default,
the maximum is set to 400%, or 4,

00:12:39.270 --> 00:12:44.220
and the min magnification is set
to 25%, the actual value of 0.25.

00:12:44.220 --> 00:12:49.440
So along with your min and max,
you have the actual magnification value.

00:12:49.440 --> 00:12:51.570
And all four of these magnification
values are set to 0.25.

00:12:51.580 --> 00:12:53.680
So all of these properties
are actually KVO compliant,

00:12:53.680 --> 00:12:54.600
so you can observe them.

00:12:54.650 --> 00:12:57.050
The most interesting one
being magnification generally.

00:12:57.250 --> 00:13:01.080
And you can just set the magnification
and the ScrollView will magnify.

00:13:01.080 --> 00:13:04.740
But it happens immediately whenever
you change the magnification.

00:13:04.940 --> 00:13:07.680
And that's not necessarily
always what you want.

00:13:07.860 --> 00:13:12.220
If you want to animate the magnification,
you should use the ScrollView's

00:13:12.220 --> 00:13:15.650
animator and then call set
magnification and it will animate

00:13:15.920 --> 00:13:18.470
the change in magnification for you.

00:13:18.630 --> 00:13:21.350
And it will center that with
what the content already is,

00:13:21.350 --> 00:13:26.080
which isn't necessarily
always what you want.

00:13:26.570 --> 00:13:27.980
Particularly if you're looking
at a magnified gesture,

00:13:28.000 --> 00:13:30.500
you have a particular point that you
want to center the magnification around,

00:13:30.500 --> 00:13:31.660
and I showed you that in the demo.

00:13:31.660 --> 00:13:34.500
And we have a nice method on In a
Scroll View to help you do that,

00:13:34.500 --> 00:13:36.320
setMagnificationCenterAtPoint.

00:13:36.320 --> 00:13:39.320
So perhaps the user is doing
a magnification gesture that's

00:13:39.320 --> 00:13:41.400
centered around the dog's nose here.

00:13:41.400 --> 00:13:43.870
We can call
setMagnificationCenterAtPoint,

00:13:44.010 --> 00:13:47.670
and when magnification occurs,
we keep the nose at the exact same spot,

00:13:47.830 --> 00:13:50.330
and that's exactly what the user expects.

00:13:51.160 --> 00:13:54.000
We also have another method,
MagnifyToFitRect.

00:13:54.260 --> 00:14:01.160
Perhaps you have a UI option for the
user where they can select a portion

00:14:01.160 --> 00:14:05.220
of the image that they want to magnify,
and perhaps they select this portion.

00:14:05.220 --> 00:14:08.280
You just pass the rect,
and we will fit that rect as best

00:14:08.430 --> 00:14:10.180
as possible when we magnify it.

00:14:10.180 --> 00:14:12.560
And of course,
In a Scroll View will respect the

00:14:12.560 --> 00:14:15.750
minimum and maximum magnification,
so it will stop at the maximum

00:14:15.750 --> 00:14:18.850
magnification levels if needed
in these examples as well.

00:14:20.280 --> 00:14:24.810
Just like the magnification property,
however, when you call these methods,

00:14:24.810 --> 00:14:27.440
the magnification occurs immediately.

00:14:27.580 --> 00:14:31.340
So again, if you want them animated,
you just use the scroll view

00:14:31.830 --> 00:14:36.370
animator and then use the appropriate
method on the animator and the

00:14:36.660 --> 00:14:39.560
magnification will be animated for you.

00:14:39.690 --> 00:14:43.400
So what's going to be really interesting
to know here is exactly how in a

00:14:43.560 --> 00:14:45.930
scroll view performs its magnification.

00:14:46.050 --> 00:14:50.820
Well, let's say you have a clip view here
and its frame is 0 by 90 by 90.

00:14:50.820 --> 00:14:52.080
We get a nice square.

00:14:52.140 --> 00:14:55.480
And in this case,
the content fits in there perfectly.

00:14:55.590 --> 00:14:58.720
So its frame is 90 by 90 as well.

00:14:58.810 --> 00:15:01.560
Then we want to magnify this image.

00:15:01.760 --> 00:15:04.480
Well, your document is still
going to be 90 by 90.

00:15:04.480 --> 00:15:05.590
That's what it is.

00:15:05.700 --> 00:15:08.500
And the clip view frame is
also going to be 90 by 90.

00:15:08.550 --> 00:15:11.980
What we do is change
the clip view bounds.

00:15:12.120 --> 00:15:15.680
Normally the bounds are a one-to-one
relation with the size of the

00:15:15.690 --> 00:15:17.500
view that's associated with.

00:15:17.720 --> 00:15:19.640
But in this case,
we changed the clip view

00:15:19.640 --> 00:15:21.750
bounds to 60-60 in this case.

00:15:21.750 --> 00:15:28.660
And so we're trying to expand
60 points of document data into

00:15:28.780 --> 00:15:28.780
60 points of document data.

00:15:28.800 --> 00:15:29.940
And so we're trying to expand
60 points of document data

00:15:30.030 --> 00:15:30.720
into 90 points of view space.

00:15:30.720 --> 00:15:34.340
And this will apply the appropriate
transforms to the view automatically.

00:15:34.340 --> 00:15:40.310
And you can look for this in your
document by converting to the

00:15:40.310 --> 00:15:43.960
rect or size to the backing store.

00:15:43.960 --> 00:15:47.510
And you can find out exactly how
many pixels you have to work with

00:15:47.510 --> 00:15:51.370
so you can get pixel-accurate line
drawing or more higher resolution

00:15:51.370 --> 00:15:53.560
drawing when you're magnified in.

00:15:53.560 --> 00:15:54.720
And you can take advantage of that.

00:15:55.240 --> 00:15:57.100
For those of you that already
did the math in this example,

00:15:58.310 --> 00:16:02.940
it's magnifying out to 1.5,
which is 150%. Now that

00:16:02.940 --> 00:16:06.190
we've covered magnification,
we can get back into smart magnification.

00:16:06.440 --> 00:16:08.800
And the great thing is that
smart magnification handles those

00:16:08.800 --> 00:16:10.390
HI guidelines we already talked about.

00:16:10.490 --> 00:16:15.460
If you don't do anything and you've
told scroll view to allow magnification,

00:16:15.520 --> 00:16:21.180
it will do the automatic simple zoom in
to 150%, magnify back out to 100%, and it

00:16:21.180 --> 00:16:24.000
will handle that for you automatically.

00:16:24.060 --> 00:16:25.710
However,

00:16:26.060 --> 00:16:27.620
Your content,
you might want to do something

00:16:27.620 --> 00:16:31.700
more intelligent like Safari does,
where it magnifies to the div content.

00:16:31.700 --> 00:16:35.450
But ScrollView doesn't know anything
about the layout of your document view.

00:16:35.460 --> 00:16:38.040
So you need to give
ScrollView a little bit of help,

00:16:38.100 --> 00:16:41.760
and you do that by implementing
this method in your document view.

00:16:41.760 --> 00:16:43.500
So you don't have to
override anything else.

00:16:43.500 --> 00:16:45.370
You don't have to have a
custom ScrollView class or

00:16:45.370 --> 00:16:46.720
delegate or anything like that.

00:16:46.810 --> 00:16:49.340
Just in your document view,
implement rect for smart

00:16:49.340 --> 00:16:52.380
magnification at point in rect,
return the appropriate rect,

00:16:52.460 --> 00:16:54.780
and ScrollView will magnify accordingly.

00:16:55.020 --> 00:16:56.960
And it gets a little bit better.

00:16:57.020 --> 00:17:00.000
Let's walk through
exactly how this works.

00:17:00.360 --> 00:17:03.890
Here we have some document view,
a couple of columns of text, for example.

00:17:04.000 --> 00:17:05.500
And of course,
this is sitting in a scroll view.

00:17:05.500 --> 00:17:07.720
We're not showing the
whole thing at one time.

00:17:07.840 --> 00:17:10.500
And so this is the portion
that was currently visible.

00:17:10.550 --> 00:17:13.490
And the user does a smart
magnification gesture at this point.

00:17:13.600 --> 00:17:15.350
So we want to smart
magnify the left column.

00:17:16.240 --> 00:17:19.880
A scroll view will call REC for
smart magnification at point.

00:17:20.050 --> 00:17:23.800
That would be the dot on the screen
translated into the coordinate

00:17:23.800 --> 00:17:25.780
system of your document view.

00:17:25.780 --> 00:17:29.410
In REC, this is the visible REC,
which is what the scroll

00:17:29.440 --> 00:17:31.480
view is currently showing.

00:17:31.480 --> 00:17:36.620
And again, translated into the coordinate
system of your view.

00:17:36.620 --> 00:17:39.200
And what you return,
which is really interesting,

00:17:39.320 --> 00:17:41.580
is you return the REC for
this entire column.

00:17:41.580 --> 00:17:43.890
Return the REC for the entire column.

00:17:43.900 --> 00:17:46.210
And in a scroll view,
we'll take a look at the whole thing.

00:17:46.270 --> 00:17:48.710
And we'll take a look at that and
look at the visible REC and we'll

00:17:48.710 --> 00:17:51.940
figure out the appropriate thing
according to the current HI guidelines.

00:17:51.940 --> 00:17:54.420
And in this case,
we'll magnify just like that.

00:17:54.480 --> 00:17:56.960
As you saw in the example
with the table and text edit,

00:17:57.060 --> 00:18:00.210
you can continue to go further
and further and deeper and deeper.

00:18:00.280 --> 00:18:02.470
This is where you look at
the visible REC to see what

00:18:02.470 --> 00:18:05.200
depth you're currently at,
where the gesture occurred.

00:18:05.230 --> 00:18:08.380
And you can return a different
REC for some other portion of content

00:18:08.470 --> 00:18:10.130
and keep going deeper and deeper.

00:18:10.200 --> 00:18:12.750
Once you get to the deepest level,
and we only have one

00:18:12.750 --> 00:18:16.220
level in this example,
the user performs.

00:18:16.240 --> 00:18:18.240
And you can see that the user
performs a smart magnify gesture.

00:18:18.240 --> 00:18:20.520
You're going to get called
back with the method.

00:18:20.520 --> 00:18:23.600
And what you return that time
is the exact same REC that

00:18:23.720 --> 00:18:26.930
you returned the first time,
this entire column.

00:18:26.980 --> 00:18:30.740
And a scroll view will see that we're
already magnified to that column,

00:18:31.000 --> 00:18:33.970
that we've already magnified
to that REC as best we can.

00:18:34.090 --> 00:18:37.580
So we'll go ahead and zoom back
out to 100% for you automatically.

00:18:37.670 --> 00:18:38.870
And that's how that works.

00:18:38.980 --> 00:18:43.070
So you can let NS Scroll View handle
all the logic and HI guidelines that

00:18:43.280 --> 00:18:46.120
are associated with smart magnification.

00:18:46.240 --> 00:18:51.440
And it makes life so much easier
than trying to write a whole

00:18:51.450 --> 00:18:53.570
bunch of code to do it yourself.

00:18:59.340 --> 00:19:02.830
Along with the actual magnification
methods and responding to the gestures,

00:19:02.830 --> 00:19:06.280
there's a couple of new notifications,
which may be interesting to some of you.

00:19:06.590 --> 00:19:09.340
In a scroll view,
we'll start live magnification,

00:19:09.410 --> 00:19:11.860
magnify notification,
and in a scroll view,

00:19:11.860 --> 00:19:13.920
did in live magnify notification.

00:19:14.040 --> 00:19:17.510
This occurs for both the smart
magnification gesture and

00:19:17.620 --> 00:19:19.500
the pinch magnify gesture.

00:19:20.800 --> 00:19:24.460
These are interesting because if your
content can't keep up with being redrawn

00:19:24.460 --> 00:19:27.700
appropriately as the scale changes,
you might want to catch the

00:19:27.700 --> 00:19:30.920
start notification and switch to
a static image or switch to some

00:19:31.010 --> 00:19:32.900
lower resolution drawing model.

00:19:32.900 --> 00:19:34.780
That way you can stay
responsive to the user.

00:19:34.780 --> 00:19:36.880
It's real important to always
remain responsive to the user

00:19:36.880 --> 00:19:38.200
and you don't want to lag behind.

00:19:38.200 --> 00:19:41.190
And as soon as you get the did
in live magnify notification,

00:19:41.200 --> 00:19:44.460
you can go back to drawing at
the best resolution that you can.

00:19:47.510 --> 00:19:49.430
So that was Magnify and Smart Magnify.

00:19:49.650 --> 00:19:51.840
Let's switch gears and talk
about NSPageController.

00:19:51.840 --> 00:19:54.600
We'll talk about swiping,
two-finger swiping.

00:19:54.610 --> 00:19:57.820
And NSPageController makes swiping easy.

00:19:58.080 --> 00:20:02.760
Let me show you exactly
how easy that it is.

00:20:02.820 --> 00:20:04.670
Last year,

00:20:04.960 --> 00:20:09.220
I showed off this demo
application called Picture Swiper.

00:20:09.280 --> 00:20:12.140
And it showed off how to use
track swipe with options,

00:20:12.140 --> 00:20:13.900
dampen amount threshold.

00:20:13.900 --> 00:20:15.070
It's a big, long method.

00:20:15.280 --> 00:20:18.410
And this method allowed you to track
a two-finger scroll as a swipe.

00:20:18.450 --> 00:20:20.740
It was really interesting.

00:20:20.740 --> 00:20:26.610
And this project, as you can see,
has got 300 lines of code there and

00:20:26.610 --> 00:20:33.040
another almost 300 lines of code there,
another 50 lines of code.

00:20:33.040 --> 00:20:37.800
And there's some more code
there and another 75 here.

00:20:37.800 --> 00:20:39.870
It's about 900 lines of code.

00:20:39.940 --> 00:20:41.320
But it was really cool
because you could do this.

00:20:41.320 --> 00:20:44.970
You have this nice little picture of
the dog and you could swipe through

00:20:44.970 --> 00:20:48.480
the dog and swipe back through
your images and even magnify in and

00:20:48.480 --> 00:20:52.320
you get a nice little bounce that
first time and then switch images.

00:20:52.320 --> 00:20:54.440
So it's a really, really cool little app.

00:20:54.440 --> 00:20:56.280
But this is 900 lines of code.

00:20:56.280 --> 00:20:57.810
We can do better than that.

00:20:57.810 --> 00:21:02.360
And with the new NSPage controller,
we do do better with that.

00:21:03.260 --> 00:21:06.890
As hopefully you can see,
we have now a lot less files here.

00:21:06.890 --> 00:21:11.050
And this is practically nothing
just to do some auto-sizing for us.

00:21:11.050 --> 00:21:16.280
So there's 24 lines of code and another
94 lines of code here in the delegate.

00:21:16.280 --> 00:21:20.490
And most of this is just pulling
in the application to finish.

00:21:21.100 --> 00:21:23.370
And I want to point out that
I had taken out the big list,

00:21:23.460 --> 00:21:26.300
if you've ever seen sample code, the big,
long disclaimer list that

00:21:26.300 --> 00:21:27.230
Apple has at the top.

00:21:27.300 --> 00:21:29.500
When I counted those 900
lines of code before,

00:21:29.500 --> 00:21:30.730
that wasn't counting that.

00:21:30.760 --> 00:21:31.690
I stripped them out.

00:21:32.800 --> 00:21:39.640
So what we really have is the page
controller delegate starts at line 60

00:21:39.640 --> 00:21:42.550
here and ends over here at line 94.

00:21:42.710 --> 00:21:48.320
So a little over 30 lines of
code now to do the swiping.

00:21:48.320 --> 00:21:48.320
And if we run this.

00:21:49.210 --> 00:21:50.960
We see that it looks
pretty much the same.

00:21:50.960 --> 00:21:54.380
You can magnify in, you get that bounce,
and you can go on to the next one,

00:21:54.380 --> 00:21:56.070
and you're back just like we were before.

00:21:56.290 --> 00:21:58.820
So we've gone from 900 lines
of code to the new code is a

00:21:58.820 --> 00:22:00.560
little over 100 lines of code.

00:22:00.770 --> 00:22:03.980
You know, that's a tremendous savings
right there for you in code,

00:22:04.030 --> 00:22:09.100
and NSPageController makes this
so much easier and nicer to do.

00:22:09.800 --> 00:22:11.640
Thank you.

00:22:11.790 --> 00:22:14.940
So, NSPageController has two modes,
and we'll talk about

00:22:14.940 --> 00:22:16.660
them a little bit more,
but there's a history

00:22:16.660 --> 00:22:17.500
mode and a custom mode.

00:22:17.740 --> 00:22:21.290
So, you can work NSPageController
in a couple of different ways

00:22:21.400 --> 00:22:23.100
to make some different UIs.

00:22:23.250 --> 00:22:27.990
Of course, you can make a history UI,
and you can do this in both

00:22:28.050 --> 00:22:33.680
custom mode and history mode,
but history makes it a little bit easier,

00:22:33.680 --> 00:22:34.180
as you've seen in Safari,
as you navigate through

00:22:34.180 --> 00:22:34.180
your history in Safari.

00:22:34.460 --> 00:22:36.620
App Store has adopted
NS Page Controller and is now

00:22:36.620 --> 00:22:39.640
swiping in the App Store to
look through your history.

00:22:39.670 --> 00:22:41.620
You also have in Dictionary.

00:22:41.660 --> 00:22:43.640
Dictionary is implemented
in NS Page Controller,

00:22:43.640 --> 00:22:46.400
and you can now swipe through
your history in Dictionary online.

00:22:46.400 --> 00:22:46.900
That's really great.

00:22:47.020 --> 00:22:49.750
They've also adopted
magnification on NS Scroll View,

00:22:49.750 --> 00:22:52.330
so you can magnify into
the content of Dictionary,

00:22:52.330 --> 00:22:54.040
which is really kind of cool.

00:22:55.940 --> 00:22:57.430
Reminders, the new Reminders app.

00:22:57.430 --> 00:22:58.710
This is a little bit different.

00:22:58.790 --> 00:23:00.690
You're not navigating
through history here.

00:23:00.690 --> 00:23:02.850
You're navigating through
a list of reminder cards,

00:23:02.850 --> 00:23:05.260
but Reminders in this case also
is using NS Page Controller,

00:23:05.260 --> 00:23:07.180
and they've adopted that as well.

00:23:07.180 --> 00:23:08.540
Game Center has adopted it.

00:23:08.630 --> 00:23:11.470
As you've seen, the cards,
the images slide.

00:23:11.470 --> 00:23:15.970
You have similar slide animations like
this when you're changing screens,

00:23:15.970 --> 00:23:20.790
for example, or as you're swiping through
application pages in Launchpad.

00:23:20.800 --> 00:23:24.400
Some different interfaces
that you can apply.

00:23:25.280 --> 00:23:27.210
The first thing to know
about NS Page Controller,

00:23:27.230 --> 00:23:29.590
we're going to talk a little
bit about how it's constructed,

00:23:29.590 --> 00:23:31.690
and then we'll get into each
of the modes and how each of

00:23:31.690 --> 00:23:33.080
the modes works a little bit.

00:23:33.240 --> 00:23:35.500
NS Page Controller is
an NS View Controller.

00:23:35.660 --> 00:23:38.090
That's what it subclasses from,
so it starts off as

00:23:38.100 --> 00:23:39.520
an NS View Controller.

00:23:39.520 --> 00:23:42.050
This is something new in the kit.

00:23:42.050 --> 00:23:45.940
We normally don't have
custom view controllers.

00:23:45.940 --> 00:23:48.060
We have views, but in this case,
Page Controller is a

00:23:48.060 --> 00:23:49.620
controller for a view,
and of course,

00:23:49.690 --> 00:23:51.000
there's going to be a view.

00:23:54.620 --> 00:23:58.060
You need to wire this view up
in your interface in Interface

00:23:58.060 --> 00:24:00.260
Builder and provide the content.

00:24:01.880 --> 00:24:03.880
But NSPageController will
then be responsible for

00:24:03.930 --> 00:24:05.560
controlling things in that view.

00:24:05.640 --> 00:24:09.380
Unlike NSViewController,
NSPageController automatically inserts

00:24:09.460 --> 00:24:12.600
itself into the responder chain for you,
so you just wire it up to your

00:24:12.600 --> 00:24:15.360
view and you don't have to
worry about the responder chain.

00:24:19.280 --> 00:24:21.860
In addition to what
NSViewController provides,

00:24:21.920 --> 00:24:25.340
NSPageController also has a
concept of a transition style.

00:24:25.640 --> 00:24:27.590
We have three different
transition styles.

00:24:27.720 --> 00:24:30.180
There's StackHistory, StackBook,
and HorizontalStrip.

00:24:30.330 --> 00:24:33.210
I want to explain them a
little bit more in detail.

00:24:34.440 --> 00:24:36.950
When you're looking at a
history type of interface,

00:24:37.000 --> 00:24:42.840
like an app store or in Safari,
you start off showing page one content.

00:24:43.020 --> 00:24:45.260
Then the user is going to navigate
somewhere and all of a sudden

00:24:45.460 --> 00:24:47.090
there's going to be page two content.

00:24:47.100 --> 00:24:51.650
Well,
where sort of logically is page one?

00:24:51.670 --> 00:24:53.440
It's now behind page two.

00:24:53.440 --> 00:24:56.400
As the user continues to go
forward and adding new content,

00:24:56.400 --> 00:24:59.990
those pages get added on top of the
current pages that are already there.

00:25:00.680 --> 00:25:02.790
So,
if you want to swipe back to page one,

00:25:02.890 --> 00:25:04.600
the animation works that way.

00:25:04.600 --> 00:25:08.760
If you want to bring page two back in,
if you want to move forward to page two,

00:25:08.760 --> 00:25:11.180
you bring page two on top of page one.

00:25:11.220 --> 00:25:14.600
So, that is how history works and
that's the animation for history.

00:25:16.280 --> 00:25:20.400
But perhaps you have something
that's more like a book.

00:25:20.400 --> 00:25:23.130
Reminders uses this transition style,
for example,

00:25:23.200 --> 00:25:24.690
because they have a list of cards.

00:25:24.840 --> 00:25:28.420
But for an example,
it would be multi-page PDF.

00:25:28.710 --> 00:25:31.690
So you're seeing page one.

00:25:31.690 --> 00:25:32.940
Where is page two?

00:25:32.940 --> 00:25:36.270
Well, logically, just like a book,
page two is going to be

00:25:36.270 --> 00:25:37.880
already behind page one.

00:25:37.890 --> 00:25:41.440
So we want to move page one off
to the side and reveal page two.

00:25:41.440 --> 00:25:45.120
If we want to bring page one back on,
we of course want to slide

00:25:45.430 --> 00:25:47.280
page one back over page two.

00:25:47.740 --> 00:25:50.150
So the animation is a
little bit different,

00:25:50.150 --> 00:25:54.030
but it really works quite naturally
when you use it in practice.

00:25:54.270 --> 00:25:56.900
There's also the strip,
which I'll cover briefly.

00:25:56.900 --> 00:26:00.580
And this just lays your pages out
horizontally next to each other.

00:26:00.580 --> 00:26:03.150
So they slide in like that,
and you can move back

00:26:03.150 --> 00:26:04.510
to page one that way.

00:26:05.170 --> 00:26:09.140
I want to make a real important note
here that these transition styles

00:26:09.270 --> 00:26:11.600
are actually independent of the mode.

00:26:11.600 --> 00:26:14.440
We've talked about those two modes,
and we have three transition styles.

00:26:14.570 --> 00:26:16.220
They're completely
independent from each other.

00:26:16.290 --> 00:26:19.830
I'll talk about that a little bit more,
but you choose which

00:26:19.830 --> 00:26:23.160
mode you want to use,
and then you need to choose

00:26:23.160 --> 00:26:27.430
the appropriate transition
style for your user interface.

00:26:27.840 --> 00:26:30.480
In this page control,
we also have the concept of

00:26:30.700 --> 00:26:32.500
an array of arranged objects.

00:26:32.680 --> 00:26:36.270
These are just references to
however you want to organize your

00:26:36.270 --> 00:26:39.940
pages and a selected index so
we know what the current page is.

00:26:40.360 --> 00:26:43.270
And using the count of arranged
objects and the selected index,

00:26:43.340 --> 00:26:46.180
it's easy to tell how many pages
you can go forward and how many

00:26:46.320 --> 00:26:48.110
pages the user can go backwards.

00:26:49.600 --> 00:26:53.840
There's three interesting IBAction
methods that NSPageController

00:26:53.840 --> 00:26:55.120
implements and exposes.

00:26:55.370 --> 00:26:58.620
Navigate back, navigate forward,
and take selected index from.

00:26:58.620 --> 00:27:01.880
These are really interesting because
they're designed for you to wire

00:27:01.880 --> 00:27:04.980
up your button in Interface Builder
right to the page controller,

00:27:04.980 --> 00:27:07.150
and now you can navigate
forward and backward,

00:27:07.290 --> 00:27:10.260
and it's animated for you,
and it works out really nicely.

00:27:10.740 --> 00:27:14.170
Quick aside,
if you wire up take selected from index,

00:27:14.170 --> 00:27:18.380
the sender of that message needs to
respond to integer value so we can

00:27:18.460 --> 00:27:21.050
get the appropriate selected index.

00:27:22.520 --> 00:27:24.960
Programmatically,
you can set the selected index by

00:27:24.960 --> 00:27:28.540
calling setSelectedIndex new index.

00:27:28.540 --> 00:27:29.630
And this happens immediately.

00:27:29.720 --> 00:27:33.160
If you want to animate it,
you of course need to use the animator.

00:27:33.250 --> 00:27:37.230
But Page Controller works a little bit
differently when you're animating content

00:27:37.300 --> 00:27:41.860
than you would think of a normal animator
because we're bringing in a completely

00:27:42.660 --> 00:27:43.980
new content here that is not there.

00:27:43.980 --> 00:27:45.710
We're not just magnifying the content.

00:27:45.720 --> 00:27:47.530
We're bringing in
something completely new.

00:27:47.610 --> 00:27:50.320
And sometimes this takes
a little bit of time.

00:27:50.320 --> 00:27:53.020
So one of the concepts
that Page Controller has is

00:27:53.190 --> 00:27:56.790
when it does an animation,
you must inform it when to complete

00:27:56.860 --> 00:28:01.840
the transition so that it can hide the
animation that's going on and reveal your

00:28:01.840 --> 00:28:04.060
view once your view is ready to draw.

00:28:04.060 --> 00:28:06.460
And that way it's seamless to the user.

00:28:07.220 --> 00:28:09.980
And when you call the animator
setSelectedIndex in this example,

00:28:09.980 --> 00:28:13.460
you are still responsible for
calling complete transition.

00:28:13.580 --> 00:28:15.620
And so you need to do that
in a completion handler.

00:28:15.910 --> 00:28:19.620
And we made that real easy with
an API on NSAnimationContext.

00:28:19.880 --> 00:28:20.680
Run animation group.

00:28:20.730 --> 00:28:23.530
Inside your group,
you ask page controller's animator

00:28:23.530 --> 00:28:25.060
to set the selected index.

00:28:25.060 --> 00:28:27.740
And then in the completion handler,
you call complete transition.

00:28:38.270 --> 00:28:38.650
I'm going to cover complete
transition more in the next section

00:28:38.650 --> 00:28:38.650
at the end of the next little
section about page controller.

00:28:38.650 --> 00:28:38.650
So if it's a little bit confusing,
don't worry about it.

00:28:38.650 --> 00:28:38.650
We're going to get to it shortly.

00:28:40.030 --> 00:28:44.400
So if you're in -- once you use
Page Controller in History Mode,

00:28:44.470 --> 00:28:46.960
what we were looking at when we
designed History Mode is we wanted

00:28:46.960 --> 00:28:49.930
to manage the history for you,
and we wanted to be responsive

00:28:50.050 --> 00:28:53.560
to what the user is doing at all
times and make it as simple as

00:28:53.680 --> 00:28:55.770
possible for you to implement.

00:28:57.270 --> 00:28:58.470
And so it works like this.

00:28:58.620 --> 00:29:02.830
So you have-- NSPageController
has an NSPageController delegate.

00:29:03.790 --> 00:29:07.160
Your view that you attach to
Page Controller is the content.

00:29:07.260 --> 00:29:09.780
You draw whatever content
you want in this view.

00:29:09.860 --> 00:29:11.120
You don't need to worry
about the arranged objects.

00:29:11.190 --> 00:29:13.300
You don't need to worry
about the selected index.

00:29:13.360 --> 00:29:15.520
Generally,
they don't even access those properties.

00:29:15.650 --> 00:29:18.290
Whenever the user
navigates to some new page,

00:29:18.290 --> 00:29:22.320
you simply call Navigate Forward to
Object on NSPageController.

00:29:22.320 --> 00:29:24.560
In this case,
you set what the new object is, page two.

00:29:26.680 --> 00:29:29.490
Something really interesting
happens here when that happens is

00:29:29.490 --> 00:29:32.790
NSPageController takes a snapshot
of page one and hangs on to it.

00:29:32.790 --> 00:29:37.580
And then once your code gets back from
calling Navigate Forward to Object,

00:29:37.660 --> 00:29:40.140
you can show the contents of page two.

00:29:40.140 --> 00:29:44.260
Just like history, and when you're doing
history in a web browser,

00:29:44.270 --> 00:29:48.640
if you navigate three or four levels
deep and then you go back a few pages,

00:29:48.760 --> 00:29:51.980
then you start navigating
in some new direction,

00:29:51.980 --> 00:29:54.790
those pages that you came back
from that were on the forward

00:29:55.090 --> 00:29:56.180
history stack have a new direction.

00:29:56.250 --> 00:29:57.260
gone away.

00:29:57.470 --> 00:29:59.850
Navigate Forward to Object does
that as well for you.

00:29:59.880 --> 00:30:02.660
So it will add page two,
the next index on the Page Controller,

00:30:02.680 --> 00:30:06.240
and it will automatically drop any
forward history that needs to be dropped.

00:30:06.320 --> 00:30:08.770
And then finally,
when we get your return,

00:30:08.930 --> 00:30:11.940
you can draw your content
for page two and continue to

00:30:11.940 --> 00:30:14.630
respond to the user events.

00:30:14.680 --> 00:30:18.210
At some point,
let's say the user now navigates and

00:30:18.210 --> 00:30:20.880
they want to swipe back to page one.

00:30:21.700 --> 00:30:24.400
Your delegate will be called
with Page Controller will

00:30:24.400 --> 00:30:25.550
start live transition.

00:30:25.800 --> 00:30:29.020
This is an optional delegate method.

00:30:29.580 --> 00:30:34.180
It's useful, however,
for you to stash away state

00:30:34.180 --> 00:30:35.340
that you might want to restore.

00:30:35.340 --> 00:30:38.990
For example,
you might want to store the scroller

00:30:39.010 --> 00:30:41.710
position and navigate back to it.

00:30:41.750 --> 00:30:45.040
So when you navigate back to page one,
you can reset that scroller position.

00:30:45.160 --> 00:30:48.120
So there's Page Controller will
start live transition.

00:30:50.290 --> 00:30:53.520
We take a snapshot of page
two immediately at that point,

00:30:53.520 --> 00:30:57.920
and then something really interesting
happens is we hide your view.

00:30:58.040 --> 00:31:01.980
And Page Controller puts in its place
a custom animation view hierarchy,

00:31:02.130 --> 00:31:03.960
and we bring back those snapshots in.

00:31:04.070 --> 00:31:08.480
And this way we can remain immediately
responsive to what the user is doing,

00:31:08.480 --> 00:31:14.960
and it provides a real smooth and
real nice interaction for them.

00:31:15.830 --> 00:31:20.010
The user continues the swipe gesture and
releases their fingers from the trackpad.

00:31:20.240 --> 00:31:22.920
And at this point,
they've swiped far enough with enough

00:31:23.110 --> 00:31:26.270
speed that we've decided that this
gesture has completed successfully.

00:31:26.470 --> 00:31:28.640
The animation hasn't completed,
but the user has performed

00:31:28.640 --> 00:31:29.810
the gesture successfully.

00:31:29.820 --> 00:31:33.230
Your delegate is called with page
controller did transition to object.

00:31:33.310 --> 00:31:35.430
Again,
this is an optional delegate method,

00:31:35.470 --> 00:31:38.580
but in history mode,
it's one that you're likely to implement.

00:31:39.910 --> 00:31:43.000
You're given the page that
we're transitioning to right

00:31:43.000 --> 00:31:44.740
there in this method call.

00:31:44.740 --> 00:31:46.480
So again,
you don't have to look up the selected

00:31:46.730 --> 00:31:48.080
index from the arranged objects.

00:31:48.140 --> 00:31:48.880
You just handed it.

00:31:49.050 --> 00:31:50.060
It's real easy.

00:31:50.060 --> 00:31:52.690
You now just start getting
set up to display page one.

00:31:52.880 --> 00:31:54.460
Your view is still hidden,
so you can start setting

00:31:54.810 --> 00:31:55.820
properties on your view.

00:31:57.180 --> 00:32:00.400
If you need to start loading something,
perhaps some network access,

00:32:00.510 --> 00:32:02.980
you can start doing that here as well.

00:32:04.000 --> 00:32:08.210
The animation then continues,
and the delegate is called with a page

00:32:08.440 --> 00:32:11.360
control it did in live transition.

00:32:11.880 --> 00:32:13.740
This is the delegate
method that you really,

00:32:13.740 --> 00:32:16.310
really, really, really need to implement.

00:32:16.790 --> 00:32:20.190
And what you do when you get
notified that the live transition

00:32:20.200 --> 00:32:23.580
has ended is this is where we
need to inform Page Controller to

00:32:23.580 --> 00:32:24.530
complete the transition.

00:32:24.670 --> 00:32:26.940
Because at this point,
Page Controller still has up

00:32:27.000 --> 00:32:28.730
its custom animation thing.

00:32:28.840 --> 00:32:31.180
Normally, if you draw fast enough
and everything is fine,

00:32:31.180 --> 00:32:34.020
if you're not doing any network loading,
you can just call complete

00:32:34.030 --> 00:32:35.220
transition right here.

00:32:35.300 --> 00:32:39.340
Other times, you need to note that the
live transition has completed.

00:32:39.470 --> 00:32:41.880
And once your network
access has finished,

00:32:41.880 --> 00:32:46.680
you can call complete transition when
your view is completely ready to go.

00:32:46.710 --> 00:32:51.310
That way, when we drop the snapshot
that we had taken earlier,

00:32:51.310 --> 00:32:53.850
it will exactly match the view.

00:32:53.850 --> 00:32:55.720
If you call complete
transition too early,

00:32:55.720 --> 00:32:58.270
you'll have perhaps a blank view
or perhaps white in there and

00:32:58.270 --> 00:33:00.940
you'll get this flash and it
won't be a good user experience.

00:33:00.970 --> 00:33:04.170
So that is why complete
transition is vitally important.

00:33:04.180 --> 00:33:06.340
And that's history mode in a nutshell.

00:33:06.410 --> 00:33:07.390
Real easy to use.

00:33:07.500 --> 00:33:10.170
Again, in history mode,
you will have to set up the

00:33:10.170 --> 00:33:13.880
transition style when you're
setting up in as Page Controller.

00:33:13.880 --> 00:33:15.700
It's real easy to do
in Interface Builder.

00:33:15.700 --> 00:33:17.910
You just set which
transition style you want.

00:33:17.910 --> 00:33:22.050
And you're likely to want to use the
stack history style in that case.

00:33:22.280 --> 00:33:26.870
Custom mode is all about continuing
to be responsive to the user,

00:33:27.120 --> 00:33:30.920
but giving you, the developer,
more control over how NSPageController

00:33:30.920 --> 00:33:34.170
works and taking snapshots.

00:33:34.300 --> 00:33:36.470
If you're performing a
book-style user interface,

00:33:36.590 --> 00:33:40.360
you'll probably need to use custom mode,
and that'll be a little bit

00:33:40.360 --> 00:33:42.540
more apparent as I continue.

00:33:42.660 --> 00:33:46.490
You can also do a history-style
user interface if you need more

00:33:46.490 --> 00:33:48.870
control over exactly how it's done.

00:33:49.070 --> 00:33:52.530
That's another reason why the transitions
are independent from the mode.

00:33:52.650 --> 00:33:55.530
You could set up the appropriate
transition style and page controller

00:33:56.130 --> 00:33:59.280
for custom mode for the type of
user interface you're building.

00:33:59.470 --> 00:34:02.510
If you build a custom mode,
the way you trigger NSPageController

00:34:02.510 --> 00:34:05.560
to use custom mode is you implement
PageController identifier for

00:34:05.640 --> 00:34:08.660
object and PageController view
controller for identifier.

00:34:08.740 --> 00:34:12.260
This is very similar to what
View-based table views does,

00:34:12.260 --> 00:34:16.660
except that in returning views,
we ask for a view controller.

00:34:16.820 --> 00:34:19.820
We will also cache the view
controller for the identifier,

00:34:19.820 --> 00:34:22.640
and we will cache as many as we
need and only ask you to vend

00:34:22.640 --> 00:34:24.340
view controllers as needed.

00:34:24.510 --> 00:34:28.410
We'll go through an example
of exactly how that works.

00:34:29.760 --> 00:34:33.300
Another major difference between custom
mode and history mode is that your

00:34:33.360 --> 00:34:36.100
view in this case is not your content.

00:34:36.210 --> 00:34:38.360
This view is just a
container for the content.

00:34:38.480 --> 00:34:41.700
Remember, you're going to be vending view
controllers which have views and

00:34:41.700 --> 00:34:43.370
we're going to be using those views.

00:34:43.490 --> 00:34:47.930
What's really interesting to do in the
view that you wire up to page controller

00:34:48.230 --> 00:34:50.710
is to draw a background there.

00:34:50.710 --> 00:34:54.790
Treat this view as a
containing background view.

00:34:55.060 --> 00:34:57.350
As the user is swiping,
particularly at the beginning

00:34:57.430 --> 00:35:00.130
or the end of the content,
if they're trying to swipe further

00:35:00.140 --> 00:35:02.790
backwards and there's no more to go,
or further forward and

00:35:02.790 --> 00:35:05.540
there's no more forward to go,
we get a rubber banding

00:35:05.770 --> 00:35:07.210
animation that occurs.

00:35:07.280 --> 00:35:14.750
And you'll see through to the
background of your window.

00:35:14.750 --> 00:35:15.150
So you'll need to draw the appropriate
background here for when that occurs.

00:35:17.700 --> 00:35:18.830
This is custom mode.

00:35:18.840 --> 00:35:20.560
It's a little bit more manual,
so you need to go ahead and set

00:35:20.690 --> 00:35:22.400
the arranged objects yourself.

00:35:22.490 --> 00:35:24.430
If it's multi-page PDF,
you know exactly what

00:35:24.430 --> 00:35:25.760
the arranged objects are.

00:35:25.760 --> 00:35:28.470
If it's a set of reminder file cards,
you know exactly what that set is.

00:35:28.490 --> 00:35:30.380
And then you set the
appropriate selected index.

00:35:30.450 --> 00:35:33.330
And at this point,
NSPageController has enough

00:35:33.330 --> 00:35:37.260
information that it can call
PageController identifier for object

00:35:37.330 --> 00:35:41.400
on the PageController delegate,
in this case asking for page one.

00:35:42.200 --> 00:35:44.760
Then you're just going to return,
you don't even need

00:35:44.760 --> 00:35:47.540
to inspect the object,
you can just return the same string

00:35:47.540 --> 00:35:49.070
over and over as an identifier.

00:35:49.580 --> 00:35:53.630
However, if you want to put up different
views based on your objects,

00:35:53.630 --> 00:35:57.270
you can do that by returning
a different identifier here.

00:35:57.840 --> 00:36:00.580
If we look in the cache and if
we don't have a view controller

00:36:00.580 --> 00:36:03.090
for that identifier in the cache,
which of course we don't

00:36:03.160 --> 00:36:05.450
yet in this example,
your delegate will be asked

00:36:05.450 --> 00:36:08.420
for a page controller,
view controller for identifier,

00:36:08.420 --> 00:36:10.960
and you create the
appropriate view controller,

00:36:10.960 --> 00:36:12.760
load the nib, and return that.

00:36:12.890 --> 00:36:14.880
At this point,
this view controller that you

00:36:14.880 --> 00:36:17.720
return does need to vend a view,
and we will go ahead and ask the

00:36:17.720 --> 00:36:19.440
view controller for that view.

00:36:19.440 --> 00:36:22.500
Then your delegate will be asked,
page controller,

00:36:22.520 --> 00:36:24.960
prepare view controller with object.

00:36:24.960 --> 00:36:26.440
Now, this is an optional method.

00:36:26.440 --> 00:36:29.020
View controller has a
represented object property,

00:36:29.020 --> 00:36:32.040
and you can bind things to it,
which works out really well.

00:36:32.040 --> 00:36:34.960
If you do not implement this method,
then page controller will

00:36:34.960 --> 00:36:37.830
automatically assign the object,
page one in this example,

00:36:37.830 --> 00:36:40.270
to the represented object
of view controller.

00:36:40.280 --> 00:36:43.130
However, if you have more preparation
that you need to do,

00:36:43.130 --> 00:36:46.030
you can do this and prepare
view controller with object.

00:36:46.140 --> 00:36:48.570
And as page controller
takes a hands-off approach,

00:36:48.580 --> 00:36:50.970
and you are responsible
for preparing your view,

00:36:50.980 --> 00:36:53.620
setting the represented object,
if you still need to do that,

00:36:53.960 --> 00:36:54.890
whatever you need to do to prepare it.

00:36:54.960 --> 00:36:58.000
And finally, your view can draw page one.

00:36:58.080 --> 00:37:02.040
I want to put out something very
interesting as a little aside here about

00:37:02.040 --> 00:37:04.620
preparing a view controller with object.

00:37:04.640 --> 00:37:08.530
You will actually be asked to prepare
a view controller with a nil object.

00:37:08.620 --> 00:37:13.160
And this is so that we can draw
a blank version of your content,

00:37:13.160 --> 00:37:18.400
but still have the appropriate look
of the table in the background,

00:37:18.400 --> 00:37:20.850
whatever is appropriate for
this view without any specific

00:37:20.920 --> 00:37:22.190
object associated with it.

00:37:22.280 --> 00:37:23.950
And you will see why that is
important in a little bit.

00:37:24.960 --> 00:37:26.220
At this point,
I just want you to realize if you

00:37:26.300 --> 00:37:29.830
are implementing page controller,
prepare view controller with object,

00:37:30.020 --> 00:37:31.980
you may be asked to
prepare with a nil object.

00:37:32.020 --> 00:37:36.720
We can now take this view and add it
as a subview to the container view.

00:37:36.760 --> 00:37:39.130
And the user can now interact with it.

00:37:39.180 --> 00:37:41.620
At some point,
the user is going to want to navigate,

00:37:41.660 --> 00:37:42.740
perhaps to page two.

00:37:42.740 --> 00:37:45.340
The delegate will be called
with page controller.

00:37:45.340 --> 00:37:46.400
We will start live transition.

00:37:46.420 --> 00:37:48.370
Again,
this is an optional delegate method,

00:37:48.370 --> 00:37:50.500
even in custom mode,
but it may be interesting.

00:37:52.500 --> 00:37:57.610
And then we take a snapshot of page one,
and we want to start swiping to page two.

00:37:57.720 --> 00:38:00.990
We've never seen page two before.

00:38:01.150 --> 00:38:05.990
And so we need to grab
some page two content.

00:38:06.190 --> 00:38:11.080
And what we do is we ask for
the identifier for page two.

00:38:11.390 --> 00:38:15.060
And if we don't have a view
controller in the cache yet,

00:38:15.060 --> 00:38:17.300
we ask you for a view controller.

00:38:17.300 --> 00:38:18.510
And then we can grab a view.

00:38:18.710 --> 00:38:21.610
And we will go ahead and ask you to
prepare that view controller with

00:38:21.740 --> 00:38:23.270
the page two object in this case.

00:38:23.270 --> 00:38:25.780
And then we're going to need
to draw page two content.

00:38:25.780 --> 00:38:28.560
It can sometimes take a little
bit of time to draw content.

00:38:28.560 --> 00:38:30.970
So we ask you to draw this
content on a background thread.

00:38:30.980 --> 00:38:33.560
So it's important that you realize
that your content will be drawing

00:38:33.560 --> 00:38:35.000
on a background thread in this case.

00:38:35.000 --> 00:38:36.540
And you need to be prepared for that.

00:38:37.320 --> 00:38:38.540
But what do we do in the meantime?

00:38:38.540 --> 00:38:41.950
Well, a little bit earlier,
I'd had that aside about being

00:38:42.320 --> 00:38:45.680
prepared for a nil object
with your view controller.

00:38:45.680 --> 00:38:49.900
So we'll have already stashed away
a blank version of a snapshot.

00:38:50.060 --> 00:38:53.300
We might have already navigated
to page two at some point in time.

00:38:53.300 --> 00:38:55.740
So we might already have
a page two snapshot.

00:38:55.860 --> 00:38:58.480
But we'll still ask you to draw an
updated one on a background thread.

00:38:58.480 --> 00:39:00.870
And we'll go ahead and take
what snapshots we do have.

00:39:00.950 --> 00:39:04.920
We will remove the current
view from the container view.

00:39:04.920 --> 00:39:07.130
And we will add in our page two content.

00:39:07.160 --> 00:39:10.740
controllers custom
transition view hierarchy.

00:39:10.820 --> 00:39:13.490
We'll put the snapshots we do have
there and when you complete your

00:39:13.490 --> 00:39:17.720
drawing on the background thread we will
replace that page two image whatever

00:39:17.720 --> 00:39:21.980
snapshot we're using with the most
the most up-to-date image that we have.

00:39:22.240 --> 00:39:26.060
Often this happens right away the user
doesn't even notice it at all by the

00:39:26.060 --> 00:39:28.140
time you start to see page two content.

00:39:28.580 --> 00:39:31.850
Other times that if it takes a little
while for you to prepare and to draw

00:39:31.850 --> 00:39:37.370
your content it'll fade in on the
user and it provides a much more

00:39:37.370 --> 00:39:41.820
fluid interface for the user and
it seems that swiping is much more

00:39:41.820 --> 00:39:44.010
responsive to them because it is.

00:39:44.180 --> 00:39:48.700
So the user swipes to page two and
that has been completed and you get

00:39:48.700 --> 00:39:51.380
the just like before you get the page
controller did in live transition

00:39:51.380 --> 00:39:55.780
and once again you need to tell page
controller to complete the transition.

00:39:55.780 --> 00:40:00.610
Often you can just do this immediately
in this method and everything

00:40:01.220 --> 00:40:02.080
transitions to the next page.

00:40:02.080 --> 00:40:02.080
So you can see that the user is
swiping to page two and that has

00:40:02.080 --> 00:40:02.080
been completed and you get the
just like before you get the page

00:40:02.080 --> 00:40:02.080
controller did in live transition
and once again you need to tell page

00:40:02.080 --> 00:40:02.080
controller to complete the transition.

00:40:02.080 --> 00:40:02.080
Often you can just do this immediately
in this method and everything

00:40:02.080 --> 00:40:02.080
transitions to the next page.

00:40:02.170 --> 00:40:06.720
to a live view and it's
immediate and it's seamless.

00:40:06.740 --> 00:40:09.810
Other times if you're loading content
that takes a little while just inform

00:40:09.810 --> 00:40:13.760
page controller the appropriate time to
complete the transition and we remove

00:40:14.370 --> 00:40:18.660
our custom transition hierarchy view,
view hierarchy and we replace

00:40:18.780 --> 00:40:22.940
it with a new prepared view
controller with page two content.

00:40:23.110 --> 00:40:26.450
And that's all there really is
to page controller and I want

00:40:26.460 --> 00:40:29.140
to show you another demo.

00:40:29.140 --> 00:40:35.170
This code is actually sample code
that you can find off the WWDC site.

00:40:36.810 --> 00:40:39.450
And this is the wrong project.

00:40:39.510 --> 00:40:41.460
We'll open up file cards here.

00:40:41.590 --> 00:40:44.940
There's not very much to this project.

00:40:45.060 --> 00:40:46.660
You know,
there's 90 lines of code in here.

00:40:46.660 --> 00:40:50.590
Most of this is reading again,
reading the contents from disk.

00:40:50.750 --> 00:40:54.420
It iterates over the objects
in your documents folder.

00:40:54.420 --> 00:40:58.880
And this is just to do some binding
stuff with URL because you can't

00:40:58.890 --> 00:41:01.500
just ask a name off of NSURLObject.

00:41:01.590 --> 00:41:03.100
And this draws the background.

00:41:03.100 --> 00:41:06.410
So that's all there really is to
this project and what this does.

00:41:06.700 --> 00:41:13.320
It has a nice little view of the files
that are in your documents folder.

00:41:13.750 --> 00:41:16.320
And we can go in here and we can swipe.

00:41:16.320 --> 00:41:19.660
And we notice here that this looks
a lot different than this one

00:41:19.890 --> 00:41:21.770
because the second file is an image.

00:41:21.770 --> 00:41:27.210
So we can see the image and I use
a different identifier here and

00:41:27.490 --> 00:41:30.880
I use a different view controller.

00:41:30.880 --> 00:41:32.120
So we can swipe between them.

00:41:32.220 --> 00:41:35.680
Of course, it's really easy to change
your transition styles.

00:41:35.820 --> 00:41:36.680
So they change in the back.

00:41:36.700 --> 00:41:40.230
The buttons are just wired right up
and you can even click in the table and

00:41:40.230 --> 00:41:42.410
all the animations occur automatically.

00:41:44.070 --> 00:41:49.750
It's hardly any lines of code,
and you get a nice user interface.

00:41:50.400 --> 00:41:53.330
Some notes about NSPageController,
though,

00:41:53.330 --> 00:41:57.610
is if you want to have your view that
is swiping inside of a split view,

00:41:57.830 --> 00:42:00.730
you can do that,
but if you're in history mode,

00:42:00.730 --> 00:42:05.490
you need to be careful because split
view looks at how many subviews it has,

00:42:05.520 --> 00:42:09.240
and that's how it decides
how many dividers it needs.

00:42:09.280 --> 00:42:12.390
And as soon as NSPageController
tries to put its private view

00:42:12.390 --> 00:42:15.610
hierarchy to do the transitioning,
NSPageController will see

00:42:15.700 --> 00:42:19.000
that and add a third divider,
and that's not what you want.

00:42:19.410 --> 00:42:20.320
It's easy enough to get around.

00:42:20.320 --> 00:42:25.020
You just put a blank custom NSView there,
and then you apply the view that you

00:42:25.090 --> 00:42:28.950
do want to have your content as a
subview of that exactly the same size,

00:42:29.130 --> 00:42:31.350
and that's what you wire
up to NSPageController,

00:42:31.390 --> 00:42:33.140
and a split view is none the wiser.

00:42:35.160 --> 00:42:38.830
I want to remind you again that
Snapshots in custom mode are

00:42:38.830 --> 00:42:41.810
drawn on the background thread,
so you need to either be thread

00:42:41.960 --> 00:42:43.160
safe or take precautions.

00:42:43.230 --> 00:42:47.130
As an example,
in a stable view isn't exactly

00:42:47.310 --> 00:42:49.620
thread safe when it comes to drawing.

00:42:52.030 --> 00:42:54.780
But there's an easy way
of working around this,

00:42:54.810 --> 00:42:58.340
in that once you've prepared for
your view that has a table in

00:42:58.430 --> 00:43:02.530
there and you've loaded your data,
don't ask in a stable view for that

00:43:02.530 --> 00:43:06.290
view to reload its data while drawing
is going on and you'll be fine.

00:43:06.300 --> 00:43:08.150
If the table view does
start to reload data,

00:43:08.150 --> 00:43:10.560
you ask it to reload data
while the drawing is occurring,

00:43:10.560 --> 00:43:12.450
I will guarantee you that it will crash.

00:43:12.460 --> 00:43:15.750
A really interesting note,
if you have the view that's

00:43:15.840 --> 00:43:19.600
attached to NSPageController,
if that is set to once layers and

00:43:19.600 --> 00:43:23.760
it's layer backed or one of its
parent views are set to once layers,

00:43:23.760 --> 00:43:27.870
so it's therefore layer backed,
instead of taking snapshots,

00:43:27.870 --> 00:43:33.040
we still use our custom transition
hierarchy to do all the animation,

00:43:33.190 --> 00:43:37.450
but we actually use live layers instead
of taking snapshots because the layers

00:43:37.750 --> 00:43:41.210
aren't asked to redraw as much as
they're coming in and out and we can

00:43:41.210 --> 00:43:43.960
still get good performance that way.

00:43:45.720 --> 00:43:49.410
Let's switch gears from talking about
swiping and we'll talk about Quick Look.

00:43:49.540 --> 00:43:51.270
Quick Look's been around for a while.

00:43:51.420 --> 00:43:55.830
It was a three-finger double tap and
it would pull up a dictionary panel

00:43:55.830 --> 00:43:57.700
over what word you double tapped on.

00:43:57.820 --> 00:44:00.510
It is now a three-finger single tap.

00:44:00.680 --> 00:44:05.630
It's a lot easier to use now.

00:44:06.140 --> 00:44:08.710
might not realize it,
but you could also trigger

00:44:08.710 --> 00:44:11.840
Quick Look previously with a hotkey,
Command Control D.

00:44:11.880 --> 00:44:15.620
Of course, this is user customizable,
so the user might change it.

00:44:15.620 --> 00:44:18.490
But Command Control D will
perform the same gesture as

00:44:18.490 --> 00:44:20.370
a three-finger single tap.

00:44:21.650 --> 00:44:24.920
We have a new responder method so that
you can catch the Quick Look event.

00:44:25.130 --> 00:44:28.030
It's a Quick Look with event,
which implies, of course, again,

00:44:28.030 --> 00:44:31.410
that we have a new event type, and we do,
and it's event type Quick Look.

00:44:33.450 --> 00:44:43.090
The only valid property of a
Quick Look event is location and window.

00:44:43.090 --> 00:44:43.090
So you can find out exactly
where this gesture occurred.

00:44:43.090 --> 00:44:43.090
Where's the cursor?

00:44:43.350 --> 00:44:45.390
technically modifiers
is a valid property,

00:44:45.540 --> 00:44:48.100
but remember,
this can be triggered with a hot key,

00:44:48.100 --> 00:44:50.840
which is likely to use a modifier,
and the user can change

00:44:50.990 --> 00:44:52.360
this to something else.

00:44:52.480 --> 00:44:58.440
So modifiers isn't really useful,
so only particularly look at location

00:44:58.440 --> 00:45:01.790
and window for the Quick Look gesture.

00:45:03.210 --> 00:45:06.330
There is no corresponding
event mask for this event.

00:45:06.550 --> 00:45:10.300
So you cannot add a local
event monitor to catch it.

00:45:10.300 --> 00:45:13.700
You can't catch it in an override
of NS application send event.

00:45:13.700 --> 00:45:18.600
You can't catch it with next
event matching mask because there

00:45:18.760 --> 00:45:20.290
is no corresponding event mask.

00:45:20.330 --> 00:45:24.110
And this is just due to the
way Quick Look works in that it

00:45:24.190 --> 00:45:27.920
can come in from a three-finger
single tap or a hot key.

00:45:27.920 --> 00:45:31.340
And so to get things to be
massaged into an appropriate event,

00:45:31.340 --> 00:45:33.040
there's no corresponding event mask.

00:45:33.100 --> 00:45:37.010
bit mass for you, so that may or may not
be important to you.

00:45:38.560 --> 00:45:41.930
We also have this other IB action method,
which is interesting,

00:45:41.930 --> 00:45:44.250
Quick Look Preview Items.

00:45:45.080 --> 00:45:49.920
If the user performs the hot key
gesture and the cursor is not visible,

00:45:50.040 --> 00:45:52.160
we don't know where the gesture occurred.

00:45:52.250 --> 00:45:54.890
And in that case,
we'll actually call this action method.

00:45:54.970 --> 00:45:58.120
We'll find the first
responder of the window,

00:45:58.280 --> 00:45:59.980
and we will go through the
responder chain as normal

00:46:00.120 --> 00:46:02.460
using this IBAction method,
Quick Look Preview Items.

00:46:02.490 --> 00:46:04.420
And it's great that
it's an IBAction method,

00:46:04.440 --> 00:46:06.770
because if you also have a
Quick Look button somewhere

00:46:06.770 --> 00:46:09.340
in your user interface,
you can just wire that up to the first

00:46:09.710 --> 00:46:12.030
responder for Quick Look Preview Items,
and you don't have to

00:46:12.030 --> 00:46:13.370
do any additional work.

00:46:13.470 --> 00:46:14.980
You can rely on what's already there.

00:46:15.000 --> 00:46:16.480
there.

00:46:16.710 --> 00:46:20.640
So if you want to do override Quick Look,
you have both of these

00:46:20.640 --> 00:46:23.440
responder methods to override.

00:46:23.440 --> 00:46:26.370
If you don't implement them
or you forward them up the

00:46:26.370 --> 00:46:29.440
responder chain normally,
they'll eventually get to NSApp,

00:46:29.440 --> 00:46:32.410
and NSApp will route that
to dictionary lookup,

00:46:32.430 --> 00:46:35.660
and the panel will come up if
it's on overtext and show you

00:46:35.810 --> 00:46:40.220
the dictionary information that
it's associated with that area.

00:46:40.220 --> 00:46:45.450
There is a bug that I want to point out
that once the event gets to NSWindow,

00:46:45.620 --> 00:46:48.840
it automatically gets
directed over to NSApp,

00:46:48.840 --> 00:46:53.740
which means NSWindowController
doesn't get a chance to see this.

00:46:53.740 --> 00:46:57.980
So you can't catch Quick Look events
in NSWindowController right now,

00:46:57.980 --> 00:47:00.620
and that's important for you to know.

00:47:04.930 --> 00:47:08.530
We'll bring back up this little demo app.

00:47:08.830 --> 00:47:10.560
And I've got a lot of text here.

00:47:10.560 --> 00:47:13.840
And we can, for example,
do a three-finger single tap and let

00:47:13.980 --> 00:47:16.240
it bubble up to the dictionary lookup.

00:47:16.320 --> 00:47:19.930
And we find out that gray wolf is
just another term for a timber wolf.

00:47:20.050 --> 00:47:20.760
Oh, well, that's great.

00:47:21.160 --> 00:47:26.570
Now, dictionary has no concept about what
to do with this image that I have here.

00:47:26.570 --> 00:47:27.720
It can't do a lookup.

00:47:27.770 --> 00:47:31.660
But now I can override the public API,
get a Quick Look,

00:47:31.660 --> 00:47:40.670
capture the Quick Look gesture,
and actually use the Quick Look API and

00:47:40.750 --> 00:47:46.070
get a Quick Look at the image.

00:47:47.730 --> 00:47:48.530
So that was a lot.

00:47:48.730 --> 00:47:51.680
Let's talk a little bit about
future proofing your application

00:47:52.000 --> 00:47:56.110
when it comes to gestures and
talk about some best practices.

00:47:56.500 --> 00:47:58.940
The first thing and the most important
thing you can do to future proof your

00:47:59.060 --> 00:48:02.400
application is to use the built-in
implementations where possible.

00:48:02.550 --> 00:48:06.380
And as ScrollView now adopts Magnify
and Smart Magnify gestures and can do

00:48:06.400 --> 00:48:10.940
a lot of the heavy lifting for you,
and particularly with smart magnification

00:48:11.350 --> 00:48:14.990
and handling the human interface
guidelines associated with that.

00:48:15.130 --> 00:48:18.220
So use the built-in
implementations where possible.

00:48:18.590 --> 00:48:23.940
When it comes to scrolling,
you want to observe NS Clip View bounds.

00:48:24.010 --> 00:48:29.560
I've seen a lot of code where
people override scroll wheel to find

00:48:29.560 --> 00:48:32.060
out how the content is scrolling.

00:48:32.250 --> 00:48:33.900
And the content can be scrolled
a lot of different ways

00:48:33.900 --> 00:48:34.940
than just the scroll wheel.

00:48:34.940 --> 00:48:38.460
It might be a keyboard action or
you might do it programmatically.

00:48:38.460 --> 00:48:41.370
And so they have all these
catches to try and find out how

00:48:41.610 --> 00:48:43.290
the scroll view is scrolling.

00:48:43.410 --> 00:48:47.780
You can simply observe NS view Clip
View bounds changes with NS view

00:48:47.780 --> 00:48:50.180
bounds did change notification.

00:48:50.270 --> 00:48:52.740
And this is really very easy to set up.

00:48:52.810 --> 00:48:55.340
You just get the default
notification center.

00:48:55.670 --> 00:48:59.040
You add observer,
whatever selector you want for the name

00:48:59.130 --> 00:49:01.500
NS view bounds did change notification.

00:49:01.550 --> 00:49:05.530
And the object you want to observe is
the content view of the scroll view.

00:49:05.540 --> 00:49:07.200
So scroll view content view.

00:49:07.270 --> 00:49:10.110
Now you'll be informed of the
bounds changes for Clip View.

00:49:10.320 --> 00:49:11.800
And so this makes it a
lot easier to handle,

00:49:11.800 --> 00:49:14.190
for example,
keeping two scroll views in sync so you

00:49:14.210 --> 00:49:17.460
can watch as the Clip View bounds change.

00:49:17.540 --> 00:49:20.150
End gestures are really interesting.

00:49:20.400 --> 00:49:24.030
As a gesture starts to occur,
whether it's a magnify or

00:49:24.030 --> 00:49:28.110
rotate or whatever gesture,
it might have passed through a

00:49:28.190 --> 00:49:30.720
couple of different layers in the
responder chain before somebody

00:49:30.720 --> 00:49:33.290
is really taking advantage of it.

00:49:33.410 --> 00:49:36.760
But everybody in the responder chain
might need to know when the gesture

00:49:36.760 --> 00:49:41.950
actually ended so that it can clean up.

00:49:42.090 --> 00:49:43.220
So it's real important that if you
get a Clip View balance change,

00:49:43.220 --> 00:49:43.220
you can see that it's
not just a single change.

00:49:43.220 --> 00:49:46.980
You get an end gesture with event
or you get an event with an end

00:49:47.080 --> 00:49:51.020
phase that you go ahead and forward
those through the responder chain.

00:49:51.020 --> 00:49:54.970
This is particularly important
for scroll wheel events,

00:49:55.160 --> 00:49:57.410
particularly if you have
nested scroll views,

00:49:57.530 --> 00:49:58.620
for example.

00:49:58.620 --> 00:50:02.620
The scroll events will start getting
bubbled up the responder chain

00:50:02.620 --> 00:50:04.820
and up to the parent scroll views.

00:50:04.840 --> 00:50:08.650
And it's real important that if you
get a scroll wheel event with an end

00:50:08.770 --> 00:50:13.180
phase or a cancel phase that you,
if it's a local event observer,

00:50:13.180 --> 00:50:13.180
that you return that event.

00:50:13.180 --> 00:50:17.180
Instead of returning nil,
you call super and you let it continue

00:50:17.180 --> 00:50:21.720
to go through the responder chain
so that everybody that was watching

00:50:21.720 --> 00:50:27.580
this gesture sees that it ends or
cancels and can clean up their state.

00:50:28.710 --> 00:50:30.490
So that's it.

00:50:30.640 --> 00:50:32.540
I want to leave you with a quick summary.

00:50:32.760 --> 00:50:34.950
There was a lot that we
covered in this talk.

00:50:35.120 --> 00:50:38.160
So the most important thing to
know is we have API hooks for

00:50:38.160 --> 00:50:40.370
Smart Magnify and Quick Look gestures.

00:50:40.620 --> 00:50:43.730
Please use them,
implement them in your application,

00:50:43.730 --> 00:50:45.300
take advantage of them.

00:50:46.090 --> 00:50:49.270
has built-in support for magnification,
particularly when it

00:50:49.270 --> 00:50:50.380
comes to smart magnify.

00:50:50.590 --> 00:50:53.050
Let NSScrollView do the
heavy lifting for you.

00:50:53.200 --> 00:50:55.630
Let it worry about the HI guidelines.

00:50:55.750 --> 00:51:01.080
As our HI guidelines evolve over time,
NSScrollView will automatically

00:51:01.080 --> 00:51:02.850
pick those changes up.

00:51:03.040 --> 00:51:04.000
You won't have to do anything.

00:51:04.000 --> 00:51:07.170
The appropriate change will
automatically happen for you.

00:51:07.170 --> 00:51:09.970
So again,
that's gesture proofing your code,

00:51:09.990 --> 00:51:12.620
future proofing your code with gestures.

00:51:13.120 --> 00:51:15.580
We have NSPageController,
swiping made easy.

00:51:15.710 --> 00:51:19.010
It's dramatically easier to do
swiping now than it was in Lion.

00:51:19.010 --> 00:51:20.000
It's a great class.

00:51:20.110 --> 00:51:24.400
I suggest you check it out and where
you can add swiping to your application.

00:51:26.850 --> 00:51:30.460
For more information, you can contact our
UI Frameworks evangelist,

00:51:30.460 --> 00:51:30.970
Jake.

00:51:31.150 --> 00:51:32.330
And we have his email up there.

00:51:32.340 --> 00:51:34.700
Of course, see the documentation.

00:51:34.700 --> 00:51:36.390
We have the release notes.

00:51:36.470 --> 00:51:37.520
I've checked them this morning.

00:51:37.520 --> 00:51:40.380
The updated release notes,
particularly for NSPageController,

00:51:40.380 --> 00:51:40.930
are there.

00:51:40.930 --> 00:51:42.280
It's got a nice big section.

00:51:42.280 --> 00:51:44.500
And we have the developer forums.

00:51:44.510 --> 00:51:46.580
So you can ask questions there.

00:51:46.580 --> 00:51:49.120
And I will reply to those as I see them.

00:51:51.450 --> 00:51:52.820
We have some interesting
related sessions.

00:51:52.820 --> 00:51:54.260
I talked a little bit
about layer backing,

00:51:54.260 --> 00:51:55.640
particularly with Page Controller.

00:51:55.640 --> 00:51:57.860
And where you can,
go ahead and go layer back.

00:51:57.980 --> 00:52:02.800
We've got some nice improvements to layer
back views in AppKit and Core Animation.

00:52:02.980 --> 00:52:04.860
Corbin already did
this talk on Wednesday.

00:52:04.860 --> 00:52:10.210
If you missed it, I highly recommend that
you rewatch it on video.

00:52:10.890 --> 00:52:13.440
If you're interested in
how gestures work on iOS,

00:52:13.530 --> 00:52:16.680
coming up next in this room is
building advanced gesture recognizers.

00:52:16.960 --> 00:52:18.940
This is a really great talk.

00:52:19.130 --> 00:52:21.100
So if you're interested in
how gestures work on iOS,

00:52:21.100 --> 00:52:21.960
please stick around.

00:52:22.260 --> 00:52:22.540
That's it.

00:52:22.780 --> 00:52:23.840
Thank you very much.

00:52:23.850 --> 00:52:25.660
Have a good evening.
WEBVTT

00:00:10.370 --> 00:00:12.000
Good morning.

00:00:12.120 --> 00:00:15.050
So just before we begin,
a quick show of hands.

00:00:15.390 --> 00:00:19.630
Who either saw the App Sandbox
talk at last year's WWDC or

00:00:19.630 --> 00:00:21.940
watched the video online?

00:00:22.520 --> 00:00:23.260
Okay, that's great.

00:00:23.260 --> 00:00:23.990
That's a lot of you.

00:00:24.110 --> 00:00:27.060
Who has tried App Sandbox
with their app thus far?

00:00:27.210 --> 00:00:28.500
Show of hands.

00:00:28.510 --> 00:00:29.570
Okay, that's also a lot of you.

00:00:29.720 --> 00:00:32.930
Who has brought a pitchfork to this talk?

00:00:33.690 --> 00:00:34.940
That's also a lot of you.

00:00:34.940 --> 00:00:35.340
Okay.

00:00:35.340 --> 00:00:36.030
All right.

00:00:36.170 --> 00:00:36.840
Excellent.

00:00:36.840 --> 00:00:41.660
So one thing,
this talk stands on its own.

00:00:41.660 --> 00:00:44.400
You don't have to have seen
the last years to be able to

00:00:44.400 --> 00:00:46.050
follow along with this one.

00:00:46.150 --> 00:00:50.190
But a lot of the introductory
material that was discussed in last

00:00:50.300 --> 00:00:52.880
year's talk is shortened this year.

00:00:52.880 --> 00:00:55.200
And this talk is actually
being repeated on Friday.

00:00:55.200 --> 00:00:59.730
So for those of you who want sort of
more of an introduction to all of this,

00:00:59.730 --> 00:01:03.540
you could actually come back for
Friday's talk and until then actually

00:01:03.540 --> 00:01:05.280
watch last year's presentation online.

00:01:05.300 --> 00:01:06.310
But you don't have to.

00:01:06.310 --> 00:01:08.520
And if you're here,
you should definitely stay.

00:01:08.520 --> 00:01:10.060
And let's talk about fSandbox.

00:01:11.780 --> 00:01:15.660
So, App Sandbox, you know,
we're going to be talking

00:01:15.660 --> 00:01:16.980
about safety engineering.

00:01:16.980 --> 00:01:18.840
That's what App Sandbox is all about.

00:01:19.000 --> 00:01:24.700
And I thought we'd start with
an example of safety engineering

00:01:25.130 --> 00:01:29.510
that all of you are familiar with,
which are cars.

00:01:30.030 --> 00:01:37.810
So, last year, the American NHTSA, the
Highway Safety Traffic Administration,

00:01:37.810 --> 00:01:42.250
announced that accident-related,
car accident-related fatalities have

00:01:42.250 --> 00:01:44.700
been at their lowest level since 1949.

00:01:44.770 --> 00:01:48.500
Big milestone because people are driving
more and there are more cars on the road,

00:01:48.680 --> 00:01:51.140
but the number of
accidents keeps dropping.

00:01:51.180 --> 00:01:54.320
And there are a lot of reasons for that.

00:01:54.630 --> 00:01:57.170
Primarily,
there's been a ton of innovation in the

00:01:57.170 --> 00:02:01.400
space of making sure that you never wind
up in an accident in the first place.

00:02:01.610 --> 00:02:05.160
So, everything from things
that we take for granted,

00:02:05.250 --> 00:02:08.930
like anti-lock brakes now,
to very new systems,

00:02:09.000 --> 00:02:12.060
like I think this year is the first
year that some cars are shipping with

00:02:12.060 --> 00:02:15.920
a system that can detect when you're
drowsy because you're drifting between

00:02:15.920 --> 00:02:18.620
lanes and can actually warn you,
you probably shouldn't be driving,

00:02:18.620 --> 00:02:20.550
you're drifting, don't do that.

00:02:20.680 --> 00:02:24.120
So, traction control, stability control.

00:02:24.370 --> 00:02:27.860
A lot of these systems that try
really hard at blind spot detection,

00:02:27.930 --> 00:02:31.220
they try really hard for you to
never wind up in an accident.

00:02:31.220 --> 00:02:35.860
But, at the same time,
sometimes accidents happen.

00:02:36.210 --> 00:02:40.280
And when they do,
you want something to contain the

00:02:40.290 --> 00:02:43.650
damage and the injury to the accident.

00:02:43.810 --> 00:02:49.850
And for this, another set of innovations,
like the seat belt and airbags,

00:02:49.850 --> 00:02:54.080
which are now mandatory,
have been invaluable.

00:02:54.080 --> 00:02:59.110
So, you can really see how much
you can do with these things.

00:02:59.820 --> 00:03:03.930
And this is very different than how
computer security has traditionally

00:03:03.930 --> 00:03:07.130
worked on desktop operating systems.

00:03:07.250 --> 00:03:10.140
There,
almost all the effort and all the work

00:03:10.140 --> 00:03:15.540
has gone into making sure that an attack
never succeeds in the first place.

00:03:15.700 --> 00:03:18.520
But if it does,
there's never been an analog to

00:03:18.690 --> 00:03:22.710
seatbelts and airbags that try to
contain the damage from that attack.

00:03:22.840 --> 00:03:26.640
And that set up this really bad dynamic
between attackers and defenders,

00:03:26.640 --> 00:03:29.220
where defenders,
in order to keep your system safe,

00:03:29.310 --> 00:03:32.090
have to defend everything
100% of the time,

00:03:32.250 --> 00:03:35.700
whereas an attacker only
needs to find one hole,

00:03:35.720 --> 00:03:38.820
one place to take over, and if they do,
it's game over.

00:03:38.820 --> 00:03:39.590
They've succeeded.

00:03:39.670 --> 00:03:40.730
The attack has been launched.

00:03:40.740 --> 00:03:43.250
There is no containment of
damage to what they can do.

00:03:43.570 --> 00:03:46.020
They can just do anything they want.

00:03:47.450 --> 00:03:49.200
Why is that?

00:03:49.270 --> 00:03:53.050
Well, it turns out that the assumption in
computing that's led to this state

00:03:53.150 --> 00:03:55.800
of affairs is now 40 years old.

00:03:56.050 --> 00:03:57.400
That's 4-0.

00:03:57.520 --> 00:04:00.150
And the assumption is this:
every program you run should run

00:04:00.150 --> 00:04:03.790
with all the privileges that you,
the user, possess.

00:04:03.900 --> 00:04:05.990
In other words,
security should be something

00:04:05.990 --> 00:04:08.390
that we erect between
different users of a system,

00:04:08.390 --> 00:04:11.070
but not between different
programs of the same user.

00:04:11.500 --> 00:04:15.890
And it should be pretty clear
that that assumption isn't really

00:04:15.890 --> 00:04:17.130
a good assumption these days.

00:04:17.230 --> 00:04:22.190
For one, most computing devices that
we use today are actually

00:04:22.340 --> 00:04:24.520
single user computing devices.

00:04:24.630 --> 00:04:27.470
It seems pretty obvious that not
every app you run should be able

00:04:27.490 --> 00:04:29.120
to access all the data you have.

00:04:29.120 --> 00:04:31.000
In fact,
an even stronger statement is that

00:04:31.000 --> 00:04:33.850
every app you run should really
only be able to access the data

00:04:34.220 --> 00:04:36.670
that it needs to get its job done.

00:04:36.950 --> 00:04:42.170
But instead, we were in this situation
where here is my favorite app.

00:04:42.280 --> 00:04:45.020
This is Watch Grass Grow app.

00:04:45.050 --> 00:04:49.140
It's an app that lets
you watch grass grow.

00:04:49.290 --> 00:04:51.410
You know,
if you exploit watchgrassgrow.app,

00:04:51.550 --> 00:04:55.800
you get to read the user's email
and steal all their files and try

00:04:55.900 --> 00:04:59.200
and attack their passwords and
get their full browsing history.

00:04:59.200 --> 00:05:02.230
There's just,
there's absolutely no limit on what

00:05:02.540 --> 00:05:07.430
exploiting this app that should never
have access to any user data can do.

00:05:07.630 --> 00:05:12.680
So in response to this, you might say,
well, why don't we come up with a way

00:05:12.680 --> 00:05:16.090
to ask the user what data do they
want to make available to this app?

00:05:16.310 --> 00:05:18.780
What should this app be able to do?

00:05:18.810 --> 00:05:22.170
And it turns out that
that doesn't work either.

00:05:22.300 --> 00:05:25.150
This is what your users see
any time you put up a dialogue

00:05:25.230 --> 00:05:27.500
that asks security questions.

00:05:27.660 --> 00:05:31.960
So there's this fantastic
saying in Washington politics,

00:05:31.960 --> 00:05:34.630
which is, if you're explaining,
you're losing.

00:05:34.630 --> 00:05:37.240
And this is true for security UI.

00:05:37.240 --> 00:05:39.230
It effectively does not work.

00:05:39.380 --> 00:05:43.540
Every time you put up a piece of user
interface where the user has to make

00:05:43.540 --> 00:05:49.310
an informed decision about security,
they're overwhelmingly likely to just

00:05:49.310 --> 00:05:54.240
click the button that they think will let
them keep going as quickly as possible.

00:05:54.240 --> 00:05:58.030
And we've basically been -- the
whole industry has been using

00:05:58.030 --> 00:06:01.900
Pavlovian conditioning to get
users to just dismiss security

00:06:01.900 --> 00:06:04.150
dialogues as quickly as they can.

00:06:04.190 --> 00:06:06.980
So this is not a good approach.

00:06:08.770 --> 00:06:12.120
All the while, the computing landscape
itself has changed a lot.

00:06:12.240 --> 00:06:16.380
There has never been this many apps
or this many developers writing apps.

00:06:16.620 --> 00:06:20.730
It's never been this easy to find new
apps and download them and run them.

00:06:21.050 --> 00:06:23.820
Computers have never been more connected.

00:06:23.880 --> 00:06:27.440
And the security challenge has very
much unambiguously moved to how

00:06:27.440 --> 00:06:32.740
do we isolate different programs
instead of just different users.́

00:06:32.820 --> 00:06:36.420
Another landscape change that you
can see is that ones and zeros have

00:06:36.420 --> 00:06:38.660
started appearing all over the world.

00:06:38.660 --> 00:06:39.970
Actually, you know what?

00:06:40.100 --> 00:06:41.230
I love stock photos.

00:06:41.320 --> 00:06:44.570
I'm just going to take a moment
to reflect on this because if you

00:06:45.060 --> 00:06:49.180
look for stock photos of like a
toaster and you find a toaster

00:06:49.180 --> 00:06:51.790
and it's a picture of a toaster,
it's just a toaster, right?

00:06:51.880 --> 00:06:54.230
But if you take ones and zeros
and you put ones and zeros

00:06:54.230 --> 00:06:56.850
over the image of a toaster,
now it's a hacker toaster.

00:06:56.850 --> 00:06:59.220
I love ones and zeros.

00:06:59.300 --> 00:07:00.090
Anyway, sorry.

00:07:00.250 --> 00:07:01.980
Back to your regular schedule program.

00:07:01.980 --> 00:07:05.210
Okay, so...

00:07:05.970 --> 00:07:09.590
The number one enemy of
security is complexity.

00:07:09.590 --> 00:07:12.320
And the software we're
building is ever more complex.

00:07:12.460 --> 00:07:16.230
This is, I think,
the biggest challenge for

00:07:16.230 --> 00:07:21.190
the entire software industry
as a whole is complexity.

00:07:21.630 --> 00:07:25.740
Complexity is rising,
complex systems have vulnerabilities,

00:07:25.880 --> 00:07:31.350
they have problems,
and the current set of affairs is

00:07:31.350 --> 00:07:36.190
that all you need is this one buffer
overflow somewhere in the enormous

00:07:36.190 --> 00:07:40.090
amount of code that's powering your
app and everything underneath it,

00:07:40.190 --> 00:07:45.180
and it's game over,
the attacker wins and your user loses.

00:07:45.340 --> 00:07:50.520
And, you know, the reason that this is an
important point to stress is because

00:07:50.970 --> 00:07:53.900
I've heard this question a lot,
actually, from you guys.

00:07:53.920 --> 00:07:56.310
Well,
why would anyone bother attacking my app?

00:07:56.470 --> 00:08:00.260
Like, I have a small app, it's, you know,
maybe it's not even super

00:08:00.300 --> 00:08:03.480
well known outside of its,
like, niche of users.

00:08:03.610 --> 00:08:04.920
Why would anyone bother attacking it?

00:08:05.120 --> 00:08:06.100
Well, they might not.

00:08:06.210 --> 00:08:10.530
They might not bother attacking your app,
but what you should remember is that your

00:08:10.530 --> 00:08:15.240
app probably accounts for a very small
number of lines of the actual total code.

00:08:15.240 --> 00:08:17.560
That's being run when your app runs.

00:08:17.700 --> 00:08:20.990
So there are all these frameworks and
libraries whose code you don't control.

00:08:21.050 --> 00:08:25.400
And my favorite example, I mean,
if you're showing a web page anywhere,

00:08:25.490 --> 00:08:28.010
if you have a web view
anywhere in your app,

00:08:28.490 --> 00:08:31.360
that's millions of lines of
code that you didn't write.

00:08:31.540 --> 00:08:36.270
Enormous complexity,
including a just-in-time compiler and

00:08:36.370 --> 00:08:42.390
a full-blown JavaScript engine that's
emitting native code in real time.

00:08:42.890 --> 00:08:47.960
A successful attack on any of that
is enough to take over your app,

00:08:48.100 --> 00:08:50.690
which if not limited,
means that the entire

00:08:50.700 --> 00:08:52.460
system has been taken over.

00:08:53.170 --> 00:08:56.470
So that's the backdrop.

00:08:56.860 --> 00:09:00.020
That was not a good state of affairs.

00:09:00.120 --> 00:09:04.100
So it's against that backdrop that
in Lion we introduced App Sandbox,

00:09:04.170 --> 00:09:08.590
which was an approach for more secure
applications that tried to drive security

00:09:08.690 --> 00:09:12.570
policy by looking at user intent,
which was a very different

00:09:12.570 --> 00:09:16.620
way of approaching security,
one that does not rely on asking

00:09:16.620 --> 00:09:20.810
the user with dialogues what to do,
and that focused strongly on

00:09:20.810 --> 00:09:21.380
containing exploit damage.

00:09:21.720 --> 00:09:27.240
If things ended up going wrong,
can we contain the fallout?

00:09:27.240 --> 00:09:29.430
So specifically in the
case of applications,

00:09:29.610 --> 00:09:34.180
we wanted with App Sandbox to
make it hard for benign but

00:09:34.200 --> 00:09:39.450
exploited applications to steal
or corrupt or destroy user data.

00:09:40.600 --> 00:09:44.740
And the basic premise here,
and I know that this is familiar to

00:09:44.740 --> 00:09:48.380
most of you because it sounds like
most of you have tried App Sandbox,

00:09:48.470 --> 00:09:53.200
is that you as developers know what
your app is supposed to be able to do

00:09:53.200 --> 00:09:56.720
during its normal course of operation,
you know, when it's just doing its job

00:09:56.720 --> 00:09:58.420
and it hasn't been taken over.

00:09:58.420 --> 00:10:02.380
So, you can express that now
to the operating system.

00:10:02.440 --> 00:10:05.120
The operating system takes
each application and puts

00:10:05.120 --> 00:10:07.510
it in its own container,
basically giving it its

00:10:07.510 --> 00:10:08.810
own little home directory.

00:10:08.860 --> 00:10:12.100
And access to documents is
actually controlled by the user

00:10:12.100 --> 00:10:15.920
but through implicit interactions
that they're already used to.

00:10:15.950 --> 00:10:18.000
So, I'll show you what that looks like.

00:10:18.100 --> 00:10:21.470
And mind you, all of this,
even though there's tight control

00:10:21.470 --> 00:10:25.200
on the user choosing what documents
your application can access,

00:10:25.270 --> 00:10:28.110
all the sort of common special
cases like the recent menu items

00:10:28.230 --> 00:10:29.800
or drag and drop or the pasteboard.

00:10:29.800 --> 00:10:30.800
They just all work.

00:10:32.810 --> 00:10:35.550
So here is how app sandbox is built.

00:10:35.860 --> 00:10:37.600
There are basically four key elements.

00:10:37.660 --> 00:10:40.140
We're going to run
through them very briefly.

00:10:40.200 --> 00:10:43.940
Entitlements are the list of those
permissions that specify to the

00:10:43.940 --> 00:10:47.620
operating system what it is your app,
what kind of permissions does your app

00:10:47.620 --> 00:10:49.100
want to be able to get its job done.

00:10:49.100 --> 00:10:52.220
There are things like my app needs
access to the address book or my

00:10:52.220 --> 00:10:54.140
app needs access to the network.

00:10:54.400 --> 00:10:56.240
And entitlements are very simple.

00:10:56.390 --> 00:10:59.380
They're basically a single property list,
one level deep.

00:10:59.380 --> 00:11:02.420
You can edit it directly in Xcode,
but there's also a very nice

00:11:02.560 --> 00:11:06.400
user interface in Xcode itself
that we'll show you in a moment.

00:11:06.400 --> 00:11:10.060
And these are meant to be very
straightforward to understand.

00:11:10.250 --> 00:11:13.420
There's only about 20
entitlements in Mountain Lion.

00:11:13.520 --> 00:11:15.690
Some of them have read only
and read write flavors,

00:11:15.780 --> 00:11:18.280
but there's basically 20 base
entitlements in Mountain Lion.

00:11:18.280 --> 00:11:22.510
So the number is
intentionally very small.

00:11:22.550 --> 00:11:26.710
In fact, here is the complete
list in Mountain Lion.

00:11:30.170 --> 00:11:33.260
I mentioned containers and
giving each app its own.

00:11:33.400 --> 00:11:35.600
So the way this works
is also very simple.

00:11:35.600 --> 00:11:38.500
There's no kernel magic,
there's no remapping of file access.

00:11:38.590 --> 00:11:41.380
All we do is export these
two environment variables,

00:11:41.380 --> 00:11:44.720
home and cfx-user-home,
that basically tells all the

00:11:44.720 --> 00:11:48.910
Cocoa APIs that an application
directory that's been assigned to your

00:11:49.000 --> 00:11:51.100
particular app is the home directory.

00:11:51.230 --> 00:11:54.840
So what that means is here's your app,
we'll just put it in a sandbox,

00:11:54.890 --> 00:11:58.550
and if the app was to use a low-level
call to try and access a documented

00:11:58.550 --> 00:12:01.540
user home directory directly,
the sandbox would

00:12:01.540 --> 00:12:03.490
actually deny this access.

00:12:03.630 --> 00:12:06.310
But if you use a
Cocoa API like NSHomeDirectory,

00:12:06.430 --> 00:12:09.920
that's actually within the
container and the sandbox would

00:12:09.920 --> 00:12:12.200
allow it and everything's happy.

00:12:16.300 --> 00:12:19.340
Powerbox is another key
element of the overall design.

00:12:19.340 --> 00:12:24.750
So if you think about Cocoa open
and save panels for a moment,

00:12:24.750 --> 00:12:29.060
they're this incredibly unambiguous
declaration of user intent.

00:12:29.060 --> 00:12:31.990
When there's an open panel
on the screen that an app put

00:12:31.990 --> 00:12:34.500
up and the user picks a file,
it's very clear what

00:12:34.500 --> 00:12:35.510
they want to have happen.

00:12:35.590 --> 00:12:38.300
They want the app to open the
file that they just picked.

00:12:38.300 --> 00:12:41.900
And we use that user intent declaration,
which is implicit,

00:12:42.000 --> 00:12:45.470
to drive security policy,
which means in a sandboxed app,

00:12:45.630 --> 00:12:48.590
when an open panel comes up,
it's actually run through a

00:12:48.590 --> 00:12:51.120
trusted mediator called Powerbox.

00:12:51.120 --> 00:12:53.060
And then when the user selects
some files and folders,

00:12:53.060 --> 00:12:56.880
only those that are selected are actually
made available within the sandbox

00:12:56.960 --> 00:12:59.490
of the app that's put up the panel.

00:12:59.850 --> 00:13:05.340
And the important thing to point out
here is that having this trusted mediator

00:13:05.360 --> 00:13:11.000
process and informing security policy by
user intent means that it's of paramount

00:13:11.060 --> 00:13:15.140
importance for App Sandbox to know that
the panel that the trusted mediator is

00:13:15.180 --> 00:13:20.140
putting up is actually being driven by
the user and not by the app that might

00:13:20.140 --> 00:13:23.560
have gotten exploited and is trying to,
you know, trying to use PowerBox to

00:13:23.560 --> 00:13:24.850
get access to everything.

00:13:25.110 --> 00:13:28.860
And what this means is
that sandboxed applications

00:13:28.860 --> 00:13:31.100
cannot synthesize user input.

00:13:31.500 --> 00:13:35.300
They can't fake mouse movement,
they can't fake keystrokes,

00:13:35.460 --> 00:13:38.260
and the reason for that is
simply that if they could,

00:13:38.260 --> 00:13:41.500
then the whole premise of driving
security policy by user intent

00:13:41.500 --> 00:13:44.590
breaks down and suddenly the
app is not sandboxed anymore.

00:13:46.200 --> 00:14:44.500
[Transcript missing]

00:14:46.290 --> 00:14:52.680
Finally,
because AppSandbox relies on this idea

00:14:52.720 --> 00:14:56.560
of the principle of least privilege,
which is that applications should have

00:14:56.560 --> 00:15:00.610
only the amount of privilege they need
to get their job done and no more,

00:15:00.770 --> 00:15:05.220
the idea of taking applications
and breaking them up into different

00:15:05.330 --> 00:15:09.170
pieces that have different privilege
requirements -- for instance,

00:15:09.170 --> 00:15:12.580
a piece of the app that just needs
to be able to talk to the network,

00:15:12.580 --> 00:15:15.450
but not look at any user files,
and then a main part of the app

00:15:15.540 --> 00:15:18.250
that needs to be able to deal with
files but not talk to the network

00:15:18.300 --> 00:15:20.380
-- it's a very important idea.

00:15:20.380 --> 00:15:27.340
And because of this, XPC services,
which are a new mechanism since Lion,

00:15:27.340 --> 00:15:30.020
have allowed you to
take your applications,

00:15:30.090 --> 00:15:32.270
break them up into functional pieces,
assign different

00:15:32.270 --> 00:15:36.780
entitlements to every piece,
and do this faster and easier than

00:15:36.780 --> 00:15:39.630
has ever been possible in Mac OS X.

00:15:39.860 --> 00:15:42.800
So each of these XTC services
gets their own entitlements.

00:15:42.800 --> 00:15:45.600
Life cycle management is
completely taken care of for you.

00:15:45.600 --> 00:15:49.240
You don't have to fork and
exec these helpers or services.

00:15:49.370 --> 00:15:51.800
They just come up when you need them,
they go away when you don't,

00:15:51.950 --> 00:15:54.730
and they're only available to the
app that actually started them.

00:15:54.790 --> 00:15:59.060
So if you ship them in your bundle,
they're only available to your app.

00:16:00.920 --> 00:16:03.650
So what does this look like
when it's all put together?

00:16:03.660 --> 00:16:07.590
Well, I used the example of Adium,
which is an app I like a lot.

00:16:07.720 --> 00:16:10.260
It's a popular open source
system messaging client.

00:16:10.360 --> 00:16:12.160
I'm sure most of you have heard of it.

00:16:12.230 --> 00:16:14.800
Very full-featured,
makes really great use of a

00:16:14.800 --> 00:16:16.840
lot of OS X functionality.

00:16:16.980 --> 00:16:20.950
The app itself, so ignoring frameworks,
is about 250 source files,

00:16:20.950 --> 00:16:25.030
about 75,000 lines of code,
and then another 65,000 lines of

00:16:25.110 --> 00:16:26.910
code just in the app's framework.

00:16:27.030 --> 00:16:29.370
So not system frameworks,
but actually just the frameworks

00:16:29.370 --> 00:16:31.870
that Adium itself provides.

00:16:32.180 --> 00:16:37.350
And if we were to try and sandbox Adium,
our process would basically be the

00:16:37.490 --> 00:16:40.760
same as for trying to sandbox any app,
which is we're going to try and

00:16:40.760 --> 00:16:44.530
pick some entitlements that seem
reasonable for this app for,

00:16:44.530 --> 00:16:46.840
you know,
when it's doing its normal operation.

00:16:46.910 --> 00:16:50.000
We're going to sign the application,
add those entitlements,

00:16:50.110 --> 00:16:52.460
we're going to run the program,
make sure that it's actually sandboxed,

00:16:52.580 --> 00:16:56.940
and then we'll see if any
sandbox violations come up.

00:16:57.080 --> 00:16:59.150
So let's see what that looks like.

00:17:06.400 --> 00:17:09.360
Okay, here is ADM.

00:17:09.360 --> 00:17:13.360
And what we'll do is
here's the main ADM target.

00:17:13.360 --> 00:17:15.900
We'll say that we want
the code signed this.

00:17:15.930 --> 00:17:17.710
We'll scroll down.

00:17:18.020 --> 00:17:20.620
And down here,
we'll say we want to enable entitlements.

00:17:20.740 --> 00:17:23.120
App Sandbox comes up automatically.

00:17:23.120 --> 00:17:26.140
And ADM needs to be able to
receive files from our buddies,

00:17:26.140 --> 00:17:27.290
so we'll enable that.

00:17:27.400 --> 00:17:31.070
It needs to be able to access
user-selected files if we're sending

00:17:31.170 --> 00:17:35.370
files to buddies or receiving them,
so we'll enable that.

00:17:35.370 --> 00:17:35.370
And...

00:17:35.540 --> 00:17:37.350
For our buddy list,
we want this to be able to

00:17:37.370 --> 00:17:39.450
access our address book,
so we'll enable that too,

00:17:39.530 --> 00:17:41.860
and we'll run it.

00:17:41.860 --> 00:17:45.860
And we'll run it.

00:17:48.750 --> 00:17:49.700
So here's Adium.

00:17:49.700 --> 00:17:50.510
It came up.

00:17:50.580 --> 00:17:53.300
So the first thing we'll do is
we'll switch to Activity Monitor,

00:17:53.340 --> 00:17:57.690
and in the View menu in the columns,
we'll enable the Sandbox column.

00:17:57.790 --> 00:18:03.410
And so we'll see here that the
Sandbox is enabled for Adium.

00:18:05.940 --> 00:18:09.690
Unfortunately,
it's not connecting to the internet.

00:18:09.740 --> 00:18:12.340
I'm not seeing my buddy list,
and in fact, if I look into my accounts,

00:18:12.440 --> 00:18:14.940
I can see that there's an error.

00:18:15.000 --> 00:18:15.640
Connection failed.

00:18:15.710 --> 00:18:16.550
It's going to try and reconnect.

00:18:16.710 --> 00:18:17.450
So I don't know what happened.

00:18:17.450 --> 00:18:20.480
Let's look at console.

00:18:22.710 --> 00:18:27.000
So here I've just filtered by SandboxD,
which is the sandbox logging daemon.

00:18:27.070 --> 00:18:31.600
And I'll notice that there's a bunch of
sandbox denials that took place for ADM.

00:18:31.720 --> 00:18:35.570
And most interesting to me are these
ones down here that say that sandbox

00:18:35.700 --> 00:18:40.940
denied a network outbound operation
to these IP addresses and these ports.

00:18:41.060 --> 00:18:43.640
So that sounds like
something that's important.

00:18:43.710 --> 00:18:46.740
And, you know, why is that?

00:18:46.940 --> 00:18:48.270
I don't know.

00:18:48.400 --> 00:18:49.350
Let's look back here in the target.

00:18:51.730 --> 00:18:55.500
Right, because I allowed ADM to receive
inbound network connections but

00:18:55.570 --> 00:18:57.850
not to make any outgoing ones.

00:18:58.060 --> 00:19:01.290
So we'll just enable that and rerun it.

00:19:05.610 --> 00:19:06.490
Okay?

00:19:06.730 --> 00:19:09.300
How about now?

00:19:09.350 --> 00:19:10.860
All right.

00:19:10.970 --> 00:19:12.500
That worked great.

00:19:12.600 --> 00:19:15.960
So, one thing I want to point out,
when we were debugging this and trying

00:19:16.060 --> 00:19:21.380
to figure out what's actually happening,
you notice these one-line

00:19:21.380 --> 00:19:26.490
summaries of what happened,
but actually if you expand

00:19:26.490 --> 00:19:26.490
the little disclosure triangle
and click full report,

00:19:27.090 --> 00:19:30.460
What you'll get is a nice,
symbolicated backtrace of exactly

00:19:30.460 --> 00:19:32.390
where the violation occurred.

00:19:32.560 --> 00:19:36.400
So, in here I can see that, you know,
ADM was calling into AppKit,

00:19:36.550 --> 00:19:39.830
Core Foundation, CF Network,
that eventually made it into libpurple,

00:19:39.830 --> 00:19:42.880
which is its networking library,
and that tried to connect and make

00:19:42.880 --> 00:19:45.650
this network outbound connection,
and because it didn't have the

00:19:45.730 --> 00:19:47.900
entitlement that enabled that,
App Sandbox denied it.

00:19:47.960 --> 00:19:51.100
And as soon as I enabled the entitlement,
everything was good again.

00:19:51.230 --> 00:19:51.960
So that's it.

00:19:51.960 --> 00:19:55.900
We now have ADM running in a sandbox,
and it's able to make a connection,

00:19:55.900 --> 00:19:56.660
it's online.

00:19:57.020 --> 00:19:57.820
That was it.

00:19:57.820 --> 00:20:01.090
That was the whole process
for sandboxing ADM.

00:20:01.810 --> 00:20:02.110
So why?

00:20:02.310 --> 00:20:03.700
Why did we just do that?

00:20:03.820 --> 00:20:06.700
What was the point of that exercise?

00:20:07.020 --> 00:20:12.690
The point was that once we sandboxed ADM,
an attacker who can take advantage

00:20:12.950 --> 00:20:15.960
of a vulnerability in ADM,
or any of its frameworks,

00:20:15.960 --> 00:20:18.700
or any of its libraries,
or anything underneath it,

00:20:18.820 --> 00:20:20.900
previously can take over
basically the whole machine,

00:20:20.900 --> 00:20:23.040
has access to all of your data,
all of your documents,

00:20:23.040 --> 00:20:24.280
everything that's there.

00:20:24.280 --> 00:20:28.040
But now, when sandboxed,
if an attacker was to exploit

00:20:28.040 --> 00:20:32.120
a vulnerability in ADM,
all they would have access to are the

00:20:32.120 --> 00:20:37.720
files that you sent or received from your
buddies during that one runtime of ADM.

00:20:38.150 --> 00:20:40.400
Meaning, only that one session.

00:20:40.400 --> 00:20:43.470
If you quit it and turn it back on,
the file access is basically gone and

00:20:43.500 --> 00:20:45.260
the attacker has access to nothing.

00:20:45.260 --> 00:20:49.390
So if you didn't send and receive files,
the attacker has almost nothing that they

00:20:49.410 --> 00:20:53.380
can do on the machine unless they have
a second vulnerability on the system,

00:20:53.790 --> 00:20:56.540
and the second exploit for that,
and can basically chain these

00:20:56.540 --> 00:20:59.280
vulnerabilities together to
try and escape the sandbox.

00:20:59.430 --> 00:21:02.180
But basically,
the bar has just gotten immensely

00:21:02.180 --> 00:21:09.280
higher for any successful attack
against ADM once we put it in a sandbox.

00:21:09.360 --> 00:21:13.190
App Sandbox came out in Lion,
and since then we've put in a lot

00:21:13.210 --> 00:21:17.340
of work to add some really great
stuff to make it support even

00:21:17.340 --> 00:21:20.370
more apps and even more features.

00:21:20.450 --> 00:21:23.500
Let me tell you about what we did.

00:21:23.820 --> 00:21:29.070
There are four key new features
that I'm going to be talking about.

00:21:29.070 --> 00:21:35.130
And you'll notice that two of them are
actually available already in Lion.

00:21:35.260 --> 00:21:38.090
So let's talk about security
scope bookmarks first.

00:21:39.370 --> 00:21:42.670
When, as I just mentioned, for ADM,
when you quit it,

00:21:42.920 --> 00:21:46.180
any files that the user had selected
during the previous run are,

00:21:46.180 --> 00:21:48.780
you know, the app no longer has access
to the next time it starts.

00:21:48.890 --> 00:21:52.620
And that's,
that default behavior where the app loses

00:21:52.620 --> 00:21:56.860
access to user-selected files when it's
quit should make total sense to you.

00:21:56.860 --> 00:22:00.630
You don't want the app to just
forever accumulate access to every

00:22:00.630 --> 00:22:02.300
file that the user has ever selected.

00:22:02.300 --> 00:22:06.040
So the idea that by default it
loses access is the right default.

00:22:06.170 --> 00:22:09.120
But there are times when that
default is simply not appropriate.

00:22:09.400 --> 00:22:13.770
So most commonly, applications want to be
able to allow the user to,

00:22:13.770 --> 00:22:17.640
in the configuration, pick, like,
a commonly accessed set of

00:22:17.640 --> 00:22:21.450
files or a directory for either,
you know, input or output that's really

00:22:21.510 --> 00:22:22.840
part of the app's configuration.

00:22:22.840 --> 00:22:25.620
Like, you know,
write out all my files to this directory.

00:22:25.620 --> 00:22:26.800
I configured the app to do this.

00:22:26.890 --> 00:22:29.340
I wanted to do it every single
time it writes out a file.

00:22:29.340 --> 00:22:32.150
Well, if the user did that
and picked a directory,

00:22:32.230 --> 00:22:36.110
the app needs to be able to preserve
access to it across relaunch.

00:22:36.110 --> 00:22:39.280
And the default of losing
access is not there.

00:22:39.300 --> 00:22:41.060
So that's not correct there.

00:22:41.060 --> 00:22:44.210
Another common case where this is a
problem are applications whose document

00:22:44.350 --> 00:22:48.190
formats rely on being able to reference
files that are elsewhere on disk that

00:22:48.240 --> 00:22:51.540
are not stored in the document itself,
which means once the user

00:22:51.690 --> 00:22:54.500
goes through PowerBox and
selects the document to open,

00:22:54.500 --> 00:22:58.300
the app gets access to the document,
but it can't follow those references

00:22:58.300 --> 00:23:01.830
elsewhere to the file system
to pick up the reference files.

00:23:01.850 --> 00:23:06.610
So security scope bookmarks
address both of these use cases.

00:23:06.610 --> 00:23:09.070
And I'll show you how.

00:23:09.300 --> 00:23:13.690
For the first case I mentioned,
basically per app configuration,

00:23:13.720 --> 00:23:16.980
we have something we
call app scope bookmarks.

00:23:17.070 --> 00:23:18.870
And these are available.

00:23:19.140 --> 00:23:27.770
They don't have new entitlements on them.

00:23:27.770 --> 00:23:27.770
They are simply available already
if you have the user-selected

00:23:27.770 --> 00:23:27.770
files access entitlement.

00:23:28.180 --> 00:23:30.360
And an example here is Mail.

00:23:30.730 --> 00:23:33.890
Mail is sandboxed in Mountain Lion,
and Mail lets you pick

00:23:34.070 --> 00:23:36.280
a downloads folder,
where do you want all of your

00:23:36.350 --> 00:23:38.100
attachments to get downloaded to.

00:23:38.270 --> 00:23:42.340
So Mail does this by using
an AppScope bookmark.

00:23:42.480 --> 00:23:45.720
And AppScope bookmarks, as I'll show you,
are locked to both the user

00:23:45.720 --> 00:23:47.430
and the app that created them.

00:23:47.490 --> 00:23:49.410
So here's what I mean.

00:23:50.270 --> 00:23:53.560
A user picks a file or a folder,
in this case, let's say, in mail,

00:23:53.560 --> 00:23:55.540
that I picked an alternative
downloads folder.

00:23:55.700 --> 00:23:59.710
And through doing this through PowerBox,
the user provides access to

00:23:59.790 --> 00:24:01.540
the file or folder to the app.

00:24:01.710 --> 00:24:05.980
The app can take this file or folder that
it now has access to and send it into

00:24:05.980 --> 00:24:10.230
the NSURL Bookmark Data with Options API.

00:24:10.400 --> 00:24:15.070
Which is going to return
this cryptographic ticket,

00:24:15.070 --> 00:24:19.290
essentially, just an NSData object,
just bytes, to the app and say,

00:24:19.390 --> 00:24:22.750
here it is, this is your bookmark,
your AppScope bookmark for

00:24:22.920 --> 00:24:25.330
access to this file or folder.

00:24:25.400 --> 00:24:28.910
And the app, once it has this NSData,
can actually store it anywhere it wants.

00:24:28.980 --> 00:24:31.660
It can put it in its container
somewhere in the file system,

00:24:31.660 --> 00:24:34.300
or it can put it into user
defaults or preferences,

00:24:34.390 --> 00:24:35.540
or it can put it in core data.

00:24:35.540 --> 00:24:36.270
It doesn't matter.

00:24:36.460 --> 00:24:39.610
The app can just put it somewhere
where it'll have access to it

00:24:39.610 --> 00:24:42.010
immediately after it's launched.

00:24:42.020 --> 00:24:46.910
Later, when the app is relaunched,
it can pick up that NSData that

00:24:46.910 --> 00:24:51.010
it received previously,
send it into the NSURL API called

00:24:51.100 --> 00:24:53.280
URLByResolvingBookmarkData.

00:24:53.440 --> 00:24:57.000
That will check the cryptographic ticket,
and if it checks out,

00:24:57.000 --> 00:25:01.360
it'll send back the file or folder,
basically make it available

00:25:01.460 --> 00:25:04.910
within the sandbox that the
Apps.co bookmark was created for.

00:25:05.760 --> 00:25:09.890
And since I mentioned that these
are locked to the app and the user,

00:25:09.900 --> 00:25:13.810
if another app was somehow to
get access to this cryptographic

00:25:13.810 --> 00:25:19.090
ticket and try and resolve it,
that would actually fail because, again,

00:25:19.220 --> 00:25:21.850
we're locked to the app and the user.

00:25:22.270 --> 00:25:24.350
Of course,
if this other app made its own Apps.co

00:25:24.350 --> 00:25:27.890
bookmark and the user gave it access,
that would work just fine.

00:25:29.800 --> 00:25:32.610
For the second use case,
which are document formats that

00:25:32.730 --> 00:25:37.700
themselves allow file references
to be placed in the document,

00:25:37.820 --> 00:25:40.830
we have a different feature
of Security Scope Bookmarks

00:25:40.990 --> 00:25:42.750
called Document Scope Bookmarks.

00:25:42.880 --> 00:25:49.280
These actually have a new entitlement,
the Document Scope Bookmarks entitlement.

00:25:49.540 --> 00:25:52.830
And they basically allow you to
solve exactly this problem where

00:25:52.960 --> 00:25:57.830
you have a document and you want it
to embed references to other files.

00:25:58.000 --> 00:26:00.840
Now, there are a few differences.

00:26:01.120 --> 00:26:04.090
Unlike AppScope bookmarks,
DocumentScope bookmarks can

00:26:04.090 --> 00:26:07.640
only embed references to files,
not folders.

00:26:07.750 --> 00:26:12.310
And they cannot embed references to
files in certain system locations or

00:26:12.310 --> 00:26:14.990
hidden locations like Tilda Library.

00:26:16.820 --> 00:26:18.830
Let me show you what this looks like.

00:26:18.940 --> 00:26:21.960
The user creates a
document within their app,

00:26:21.990 --> 00:26:24.000
and let's say the user
also picks a really,

00:26:24.000 --> 00:26:26.840
really big movie that they want
to insert into the document,

00:26:26.950 --> 00:26:30.240
so the app doesn't want to take
this multi-gigabyte movie and

00:26:30.240 --> 00:26:32.000
write it into the document.

00:26:32.000 --> 00:26:35.360
It wants to just maintain a reference
within the document to the movie.

00:26:35.560 --> 00:26:40.150
So what it would do now is
actually take both of these and

00:26:40.260 --> 00:26:43.900
send them into the same API,
Bookmark Data with Options,

00:26:44.050 --> 00:26:48.650
and it's important that unlike in
AppScope where we just were saying,

00:26:48.650 --> 00:26:50.440
"What do we want to
bookmark?" With DocumentScope,

00:26:50.500 --> 00:26:53.280
the app is actually indicating
both what it wants to bookmark,

00:26:53.280 --> 00:26:56.520
in this case the movie,
and what document it plans

00:26:56.620 --> 00:27:00.260
to put the bookmark into,
in this case the document

00:27:00.270 --> 00:27:01.810
that the user created.

00:27:02.780 --> 00:27:08.000
Out comes a cryptographic ticket that is
no longer locked to the app or the user,

00:27:08.120 --> 00:27:12.290
but is locked to the document
that the app specified.

00:27:14.090 --> 00:27:17.290
So, the presence of this
bookmark in the document,

00:27:17.290 --> 00:27:20.000
you can think of it as later redeemable.

00:27:20.000 --> 00:27:23.420
It's a cryptographic ticket that
can later be redeemed for access

00:27:23.480 --> 00:27:25.390
to the movie that it references.

00:27:25.790 --> 00:27:28.560
What this means is that when the
app later comes along and the

00:27:28.640 --> 00:27:31.210
user just opens that document,
normally the app right now,

00:27:31.380 --> 00:27:33.740
it has access to the document
but not to the referenced movie.

00:27:33.740 --> 00:27:38.140
But what it can do is take the
NSData that it got previously,

00:27:38.360 --> 00:27:41.740
send that and the document
it got it from to the API.

00:27:41.740 --> 00:27:44.360
The API will check that
the bookmark is valid,

00:27:44.360 --> 00:27:48.740
that it's locked to the right document,
and if these checks pass,

00:27:48.740 --> 00:27:52.460
it'll send back access to the
movie and the app can now show

00:27:52.460 --> 00:27:54.720
it as part of the document.

00:27:54.740 --> 00:27:55.760
Thank you.

00:27:56.310 --> 00:28:00.080
As I mentioned,
if another app was to get its

00:28:00.080 --> 00:28:03.350
hands on the same document,
this works just fine because

00:28:03.430 --> 00:28:06.830
documents code bookmarks are meant
to be interoperable between users,

00:28:06.900 --> 00:28:09.780
between machines,
and between apps that know

00:28:09.840 --> 00:28:11.870
how to handle this API.

00:28:18.440 --> 00:28:23.160
So we build security scope
bookmarks with basically no new

00:28:23.160 --> 00:28:25.200
API for the bookmarks themselves.

00:28:25.200 --> 00:28:28.220
Mind you, bookmarks,
I guess I should mention,

00:28:28.490 --> 00:28:31.300
since Snow Leopard bookmarks
are the canonical way on OS X of

00:28:31.300 --> 00:28:34.300
locating files persistently,
meaning even if they change

00:28:34.300 --> 00:28:37.420
names or they move to a different
location in the file system,

00:28:37.420 --> 00:28:38.760
bookmarks can do this.

00:28:38.860 --> 00:28:41.930
So they're a replacement for some
of you that have been doing this

00:28:41.930 --> 00:28:44.910
for a long time for things like
aliases and FSRFs and so forth.

00:28:45.010 --> 00:28:49.470
They're the modern way of doing
persistent file references.

00:28:49.560 --> 00:28:52.970
So all we did was to provide
some new flags on the existing

00:28:52.970 --> 00:28:56.450
APIs at the NSVRL level,
and we also actually do have core

00:28:56.450 --> 00:29:00.310
foundational level APIs for this,
and that's all you need to be

00:29:00.310 --> 00:29:02.720
able to use this functionality.

00:29:02.720 --> 00:29:09.020
But there is one key difference,
which is that when you resolve... So if

00:29:09.050 --> 00:29:12.400
you have a security scope bookmark,
even though all you get back,

00:29:12.420 --> 00:29:16.600
like in the normal case,
is a URL telling you, you know,

00:29:16.600 --> 00:29:16.600
here's the movie.

00:29:16.770 --> 00:29:18.680
It behaves differently.

00:29:18.770 --> 00:29:19.940
You have this URL now.

00:29:20.200 --> 00:29:20.910
It got resolved.

00:29:20.980 --> 00:29:21.660
Everything is great.

00:29:21.830 --> 00:29:24.330
But if you try accessing the movie,
it'll fail.

00:29:24.510 --> 00:29:27.280
It'll say,
"I don't have permission." Because the

00:29:27.280 --> 00:29:31.680
URL you got back from the security
scoped bookmark resolution API is

00:29:31.680 --> 00:29:36.530
something we call a security scoped URL,
which means you have to call a method

00:29:36.690 --> 00:29:42.090
called start accessing security scoped
resource on that URL before it's actually

00:29:42.090 --> 00:29:44.240
made available within your sandbox.

00:29:44.340 --> 00:29:47.340
So the flow is you resolve the bookmark,
you get back a URL,

00:29:47.550 --> 00:29:51.200
you indicate to the operating system
that you plan to make use of this URL by

00:29:51.330 --> 00:29:55.580
saying start accessing the resource,
and it's now available in your sandbox.

00:29:55.740 --> 00:29:56.360
You use it.

00:29:56.360 --> 00:30:00.040
When you're done, because the user,
let's say, closes the document,

00:30:00.120 --> 00:30:03.440
you have to indicate to the operating
system that you have no further

00:30:03.510 --> 00:30:05.350
use for that resource at this time.

00:30:05.670 --> 00:30:08.930
And you do that by calling another
new method on that URL called stop

00:30:09.010 --> 00:30:11.040
accessing security scoped resource.

00:30:11.070 --> 00:30:11.380
This is really important
because if you don't do that,

00:30:11.380 --> 00:30:11.720
you're not going to get the same results.

00:30:11.820 --> 00:30:15.400
balance the calls.

00:30:15.540 --> 00:30:18.610
Well, obviously, if you don't call start,
you simply can't use the resource,

00:30:18.690 --> 00:30:20.120
so you have to call start.

00:30:20.230 --> 00:30:22.780
But if you don't balance
the calls with stop,

00:30:22.860 --> 00:30:27.190
what's going to happen is the kernel
will eventually refuse to let you do any

00:30:27.190 --> 00:30:31.270
other new interactions with user files,
which means if you don't call stop

00:30:31.370 --> 00:30:35.100
and you call start enough times,
the power box will

00:30:35.130 --> 00:30:36.520
basically not work anymore.

00:30:36.570 --> 00:30:39.130
You will not be able to access
any new files selected through it.

00:30:39.250 --> 00:30:41.240
Drag and drop will not work anymore.

00:30:41.240 --> 00:30:44.240
Bookmark resolution
will not work anymore.

00:30:44.310 --> 00:30:46.880
So, you know,
the kernel is basically only willing

00:30:46.880 --> 00:30:50.450
to let you call start so many times
without balancing it out with stop,

00:30:50.600 --> 00:30:54.080
which is why it's important
to make sure that you're

00:30:54.080 --> 00:30:56.210
reasonably balancing these calls.

00:30:57.430 --> 00:31:01.350
Another new feature added since Lion,
but also available in Lion,

00:31:01.350 --> 00:31:04.670
just like Better Way Security Scope
bookmarks,

00:31:04.750 --> 00:31:07.280
are something we call application groups.

00:31:08.020 --> 00:31:11.820
So App Sandbox strives for
strong isolation between

00:31:11.890 --> 00:31:14.020
applications by default.

00:31:14.400 --> 00:31:17.180
Well, sometimes, again,
that default is not the right default,

00:31:17.180 --> 00:31:19.960
especially when we're talking
about groups of applications

00:31:20.120 --> 00:31:22.780
from the same developer,
either app suites or

00:31:22.780 --> 00:31:26.050
apps and their helpers,
where being able to share data on

00:31:26.140 --> 00:31:30.260
the file system or being able to
do direct IPC is really important.

00:31:30.480 --> 00:31:33.670
So we now have a special
affordance for just this.

00:31:33.750 --> 00:31:36.570
There's a new entitlement
called Application Groups.

00:31:36.770 --> 00:31:40.500
This is either a single group for
each app or an array of groups.

00:31:40.550 --> 00:31:43.720
The only requirement is that
every group name must begin with

00:31:43.720 --> 00:31:45.500
your Apple-assigned Team ID.

00:31:46.070 --> 00:31:51.380
And applications that are in the same
application group get to engage in direct

00:31:51.380 --> 00:31:57.030
IPC and get a dedicated file system
location where they can share data.

00:31:58.180 --> 00:31:59.620
Here's what that looks like.

00:31:59.700 --> 00:32:01.320
Here's our application.

00:32:01.320 --> 00:32:03.620
If it calls in its home directory,
it gets its container.

00:32:03.660 --> 00:32:04.860
The container is within the sandbox.

00:32:04.860 --> 00:32:05.810
Everything's happy.

00:32:05.940 --> 00:32:09.830
But if the app happens to have a helper,
the main app can't look

00:32:09.850 --> 00:32:11.350
at the helper's container.

00:32:11.510 --> 00:32:13.220
This is denied by the sandbox.

00:32:13.400 --> 00:32:15.690
So if the app and the helper
want to share some data,

00:32:15.760 --> 00:32:17.210
this was previously difficult.

00:32:17.210 --> 00:32:19.280
It required some temporary
exception entitlements.

00:32:19.400 --> 00:32:22.360
But now what we can do is
take this new entitlement,

00:32:22.360 --> 00:32:23.960
application groups.

00:32:23.980 --> 00:32:27.640
And here we're going to pick our team ID,
put it in, put a dot there.

00:32:27.650 --> 00:32:30.320
And let's say that because
this is an app and a helper,

00:32:30.380 --> 00:32:33.620
the application group name can
just be my app for both of them.

00:32:33.770 --> 00:32:35.340
So we're going to take this entitlement.

00:32:35.350 --> 00:32:37.080
We're going to apply it to our app.

00:32:37.100 --> 00:32:39.520
We're going to apply the same
entitlement to our helper.

00:32:39.530 --> 00:32:43.520
And what's going to happen is now there
is a file system location named exactly

00:32:43.520 --> 00:32:48.900
after the application group that both of
these can access and read and write to.

00:32:49.720 --> 00:32:54.260
Moreover, because they're in the
same application group,

00:32:54.270 --> 00:32:58.810
they can do direct Mach communication,
they can do direct post-ex communication.

00:32:59.440 --> 00:33:04.410
And in fact, we have this API called
SMLoginItemSetEnabled.

00:33:04.660 --> 00:33:08.740
If your helper is a login item helper,
so it has a lifecycle that's

00:33:08.740 --> 00:33:10.620
different from the main app,

00:33:10.940 --> 00:33:15.240
Now, when the main app comes online,
you can actually establish

00:33:15.240 --> 00:33:18.160
XPC communication to your helper.

00:33:18.290 --> 00:33:20.630
So, by the way,
we have sample code showing

00:33:20.630 --> 00:33:22.260
you how to do all of this.

00:33:22.350 --> 00:33:24.200
In fact,
this exact example with a main app and

00:33:24.200 --> 00:33:27.170
a helper and SM login items set enabled
and the application group's entitlement,

00:33:27.190 --> 00:33:28.290
you should check it out.

00:33:28.290 --> 00:33:31.460
It's great and shows you
exactly how to do this.

00:33:33.250 --> 00:33:35.540
Another feature,
and this one in Mountain Lion only,

00:33:35.830 --> 00:33:38.530
is something we call related items.

00:33:41.320 --> 00:33:48.140
When a user selects a file or a folder,
sometimes the application really

00:33:48.250 --> 00:33:52.790
needs access to something that
constitutes a related item,

00:33:52.790 --> 00:33:54.570
usually in the same location.

00:33:54.620 --> 00:33:59.240
So one example is a movie player
where the user opens a movie file,

00:33:59.240 --> 00:34:02.520
and by convention,
subtitles are usually in the exact

00:34:02.650 --> 00:34:04.900
same directory as the movie file,
but they just have a

00:34:04.900 --> 00:34:06.240
different file extension.

00:34:06.370 --> 00:34:08.800
And previously,
if the movie player was sandboxed,

00:34:08.800 --> 00:34:11.720
this would be difficult because
the user gave access to the

00:34:11.720 --> 00:34:14.860
movie but not the subtitle file,
so now the movie player can't even

00:34:14.860 --> 00:34:18.200
look if the subtitle file exists
without popping open a new open panel.

00:34:18.490 --> 00:34:20.280
Not a great user experience.

00:34:20.280 --> 00:34:23.160
Well now, in Mountain Lion,
through related items, we can do better.

00:34:23.470 --> 00:34:28.350
The movie player can specify that it
supports playback of movie files and that

00:34:28.350 --> 00:34:33.100
movie files have a related file type,
basically subtitle files,

00:34:33.420 --> 00:34:37.320
which will make it so that if
the user picks a movie file,

00:34:37.320 --> 00:34:41.000
the application will be granted access to
the related subtitle files automatically.

00:34:41.000 --> 00:34:45.000
automatically with no need
for another open panel.

00:34:46.040 --> 00:34:48.440
A similar case,
although slightly different,

00:34:48.510 --> 00:34:52.000
is an application like TextEdit,
where if you open a new document,

00:34:52.000 --> 00:34:54.550
it's a rich text format document,
and you type some stuff in,

00:34:54.600 --> 00:34:56.590
it gets saved as a .rtf, that's great.

00:34:56.700 --> 00:35:00.360
But as soon as you drag in a file,
an attachment,

00:35:00.360 --> 00:35:04.500
an image into this document,
TextEdit undercovers,

00:35:04.500 --> 00:35:09.650
will actually want to replace the
file with a directory that's called

00:35:09.720 --> 00:35:12.850
the same thing as the file was,
but the extension changes

00:35:12.850 --> 00:35:15.320
to .rtfd for .rtf directory,
and wants to put the

00:35:15.440 --> 00:35:16.660
attachments in there.

00:35:16.680 --> 00:35:20.080
So through the Related Items API,
TextEdit can now do just this.

00:35:20.180 --> 00:35:23.680
It can basically say that
.rtf and .rtfd are related,

00:35:23.680 --> 00:35:28.040
which means even though the user only
gave it access... ...to the .rtf,

00:35:28.040 --> 00:35:31.390
it can transparently,
without popping open a new save panel,

00:35:31.410 --> 00:35:34.580
upgrade the file type to be a
directory and append the D to the

00:35:34.580 --> 00:35:38.230
extension and call it an .rtfd,
and this can all happen without

00:35:38.230 --> 00:35:39.800
further user interaction.

00:35:39.800 --> 00:35:42.480
So the way we do this,
this functionality,

00:35:42.480 --> 00:35:46.450
both of the use cases are
implemented through NSFilePresenter,

00:35:46.500 --> 00:35:51.290
and the declaration of patterns that are
allowed to be related are basically go

00:35:51.290 --> 00:35:55.930
through your application's Info.plist,
not your entitlements.

00:35:55.940 --> 00:35:56.620
And then you can do this.

00:35:56.740 --> 00:36:01.060
And we'll have some more documentation
and an explanation for how to

00:36:01.060 --> 00:36:03.240
best use this as we go forward.

00:36:06.380 --> 00:36:09.790
So last but not least,
let's talk about automation.

00:36:10.060 --> 00:36:14.100
The Mac has been the best
automation platform in the world,

00:36:14.160 --> 00:36:18.950
and OS X has been the best
automation platform in the world,

00:36:19.070 --> 00:36:20.500
and still is.

00:36:20.570 --> 00:36:23.510
And when we introduced App Sandbox,

00:36:24.180 --> 00:36:27.290
We have to introduce some restrictions
on how automation can work.

00:36:27.510 --> 00:36:31.050
Specifically, even though we put no
restrictions on whether a

00:36:31.090 --> 00:36:34.560
sandboxed app could be scripted,
meaning if you have script editor,

00:36:34.560 --> 00:36:38.840
you can still control a sandboxed
app any way you could before,

00:36:38.940 --> 00:36:43.610
what we did have to do is restrict
how a sandboxed application can

00:36:43.690 --> 00:36:46.110
script the rest of the system.

00:36:47.090 --> 00:36:49.350
And the restriction was pretty strong.

00:36:49.360 --> 00:36:51.700
By default,
applications could simply not script

00:36:51.860 --> 00:36:53.440
the rest of the system at all.

00:36:53.560 --> 00:36:55.590
But in Mountain Lion,
we have two brand new mechanisms

00:36:55.740 --> 00:36:59.580
that address the most common
use cases for safe scripting

00:36:59.930 --> 00:37:02.350
from sandboxed applications.

00:37:02.760 --> 00:37:04.940
This, by the way, has been,
I've received a lot of

00:37:04.940 --> 00:37:08.440
questions about why is it,
why aren't there entitlements,

00:37:08.560 --> 00:37:11.650
why isn't there some way to let my
app script the rest of the system?

00:37:11.790 --> 00:37:14.680
And the answer is very simple,
because the way scripting is

00:37:14.810 --> 00:37:17.820
built on OS X is on top of a
mechanism called Apple Events,

00:37:18.000 --> 00:37:19.700
and by default,
if you can send Apple Events,

00:37:19.700 --> 00:37:21.700
then you are not sandboxed.

00:37:21.800 --> 00:37:22.690
Why?

00:37:22.700 --> 00:37:25.440
Well, because if you can script Finder,
you can escape any file

00:37:25.530 --> 00:37:26.670
system restriction.

00:37:26.730 --> 00:37:28.700
If you can script Safari,
you can escape any network restriction.

00:37:28.700 --> 00:37:32.900
And if you can script terminal,
you can escape any restriction.

00:37:33.370 --> 00:37:37.080
Which is why, by default,
Sandbox applications were not

00:37:37.080 --> 00:37:38.900
allowed to send any Apple events.

00:37:38.970 --> 00:37:42.610
And in Lion, in order to get a Sandbox
app to send any Apple events,

00:37:42.720 --> 00:37:45.840
you have to use a temporary
exception entitlement.

00:37:46.270 --> 00:37:49.740
So this is what sending
Apple events to mail,

00:37:50.050 --> 00:37:52.730
for instance, to compose a new message
looked like in Lion.

00:37:53.090 --> 00:37:56.190
There was this entitlement,
temporary exception Apple event,

00:37:56.300 --> 00:37:58.310
and you would say,
I want to be able to send this to mail,

00:37:58.310 --> 00:37:59.430
and that's how that worked.

00:37:59.480 --> 00:38:03.250
And actually, I want to take just a
moment to point out,

00:38:03.480 --> 00:38:09.040
there was a lot of consternation
about the name temporary exception.

00:38:09.040 --> 00:38:10.180
What does this mean?

00:38:10.180 --> 00:38:12.670
Does it mean that
Apple events are going away?

00:38:12.670 --> 00:38:15.440
Are Apple events now
a temporary mechanism?

00:38:15.440 --> 00:38:16.180
No, it doesn't mean that.

00:38:16.200 --> 00:38:19.540
It means that App Sandbox
had no permanent,

00:38:19.540 --> 00:38:24.200
supportable, safe mechanism yet for
doing Apple events,

00:38:24.200 --> 00:38:27.200
which is why the only one made
available was a temporary exception.

00:38:27.200 --> 00:38:30.410
But now in Mountain Lion,
you get to see what the

00:38:30.410 --> 00:38:33.290
non-temporary mechanism looks like.

00:38:34.730 --> 00:38:39.740
New in Mountain Lion is a
mechanism we call access groups.

00:38:39.850 --> 00:38:42.990
An application that defines
a scripting interface,

00:38:43.010 --> 00:38:46.700
this is what we call an SDef,
can now take certain commands

00:38:46.840 --> 00:38:51.690
and classes and properties in its
scripting dictionary and mark them

00:38:51.690 --> 00:38:57.180
up into access groups that will be
accessible by sandboxed applications.

00:38:57.300 --> 00:38:59.860
We did this in Mountain Lion already
for a few applications,

00:38:59.860 --> 00:39:03.860
so Mail exposes an access
group called mail.compose.

00:39:04.050 --> 00:39:07.090
iTunes exposes access
groups called playback,

00:39:07.090 --> 00:39:09.290
library read, library write.

00:39:09.700 --> 00:39:12.520
Access groups can be defined in any
application scripting dictionary.

00:39:12.560 --> 00:39:15.840
The application itself
doesn't have to be sandboxed.

00:39:16.130 --> 00:39:20.400
And once an access group is defined,
so actually let's look at Mail here.

00:39:20.450 --> 00:39:23.260
Mail has the scripting dictionary.

00:39:23.430 --> 00:39:25.800
It can do outgoing messages.

00:39:25.910 --> 00:39:30.340
So what we did was we added an access
group identifier called mail.compose

00:39:30.340 --> 00:39:32.350
that names the access group.

00:39:33.290 --> 00:39:36.140
And we did the same for
this outgoing message.

00:39:36.240 --> 00:39:40.170
But then actually for the send command,
we did not put it in an access group.

00:39:41.170 --> 00:39:44.980
What this means is that an application,
that sandbox,

00:39:45.030 --> 00:39:47.210
can now use a new entitlement
in Mountain Lion called

00:39:47.520 --> 00:39:54.030
Apple Security Scripting Targets to
indicate that it wants access to specific

00:39:54.030 --> 00:39:57.290
access groups in specific applications.

00:39:57.900 --> 00:40:00.050
In Mountain Lion,
here's how you would safely,

00:40:00.150 --> 00:40:04.710
with no temporary exception,
be able to pop open Mail Compose windows

00:40:05.090 --> 00:40:07.240
through Apple Events and Apple Scripting.

00:40:07.340 --> 00:40:09.630
You would say,
"I am going to declare a scripting

00:40:09.710 --> 00:40:11.240
target in my entitlements.

00:40:11.350 --> 00:40:14.740
The target is 'Mail,' and the
name of the access group I want

00:40:14.830 --> 00:40:18.020
to target is 'Mail.compose.'"

00:40:20.350 --> 00:40:26.060
So this is great for application
authors being able to carve up

00:40:26.090 --> 00:40:29.240
their scripting definition and say,
you know, these things are safe for

00:40:29.240 --> 00:40:30.540
sandbox staffs to be able to do.

00:40:30.540 --> 00:40:31.820
I'm just going to expose it to them.

00:40:31.820 --> 00:40:35.030
And then you get to adopt and say I'm
going to use this as a scripting target.

00:40:35.040 --> 00:40:35.690
That's great.

00:40:35.740 --> 00:40:40.120
But there are use cases where
any kind of restriction on what

00:40:40.120 --> 00:40:42.880
a script can do is inappropriate.

00:40:42.880 --> 00:40:45.940
And generally that use
case are attached scripts.

00:40:46.810 --> 00:40:50.120
So if you imagine the general
idea of an event handler,

00:40:50.120 --> 00:40:52.500
like a mail rule,
that wants to be able to,

00:40:52.560 --> 00:40:54.740
you want to say when I get a
message that matches this rule,

00:40:54.740 --> 00:40:55.800
I want to run this script.

00:40:55.900 --> 00:40:59.590
Well, if you wrote the script, right?

00:40:59.810 --> 00:41:03.780
You shouldn't be bound by what
mail within its sandbox can do.

00:41:03.780 --> 00:41:06.570
I mean, maybe you want the script
to take the message,

00:41:06.640 --> 00:41:08.780
take the attachments,
put them anywhere on the file system,

00:41:08.920 --> 00:41:09.700
open Safari.

00:41:09.700 --> 00:41:13.690
There's really no reasonable restriction
that can be imposed upon that.

00:41:13.700 --> 00:41:19.070
So the scripting definition
markup with access groups doesn't

00:41:19.160 --> 00:41:20.670
really address that use case.

00:41:20.700 --> 00:41:25.470
So we introduced another
automation security feature called

00:41:25.650 --> 00:41:31.880
Application Run User Scripts,
and here's how it works.

00:41:33.610 --> 00:41:36.340
Under the user's library directory,
there is now a new directory

00:41:36.870 --> 00:41:38.940
called application scripts.

00:41:39.060 --> 00:41:42.470
And under that directory,
there's a new directory named

00:41:42.470 --> 00:41:46.380
after each sandbox application
that uses this functionality's

00:41:46.500 --> 00:41:49.500
code signing identifier that's
normally the same as the bundle ID.

00:41:49.600 --> 00:41:52.140
So basically,
we assign a special new directory

00:41:52.450 --> 00:41:55.870
for every sandboxed app that the
app itself can only read from.

00:41:55.970 --> 00:41:59.220
It cannot write to it.

00:41:59.220 --> 00:41:59.220
But

00:41:59.570 --> 00:42:03.900
Through a new API called NSUserScriptask
that is available in Foundation,

00:42:04.010 --> 00:42:09.000
the app can say,
"I want to execute this script that's

00:42:09.000 --> 00:42:13.570
in my per-application scripting
directory with no restrictions."

00:42:13.960 --> 00:42:16.660
This can be an Automator script,
it can be Apple script,

00:42:16.770 --> 00:42:21.220
it can be a Unix script or a binary,
and there is no restriction placed

00:42:21.220 --> 00:42:22.980
upon what the script can do.

00:42:23.320 --> 00:42:25.560
The script runs entirely
outside of the sandbox.

00:42:25.590 --> 00:42:28.130
And the idea is that once again,
we're basically driving

00:42:28.140 --> 00:42:29.760
security policy by user intent.

00:42:29.890 --> 00:42:32.700
Because the application cannot
write to that directory,

00:42:32.750 --> 00:42:36.260
the only way for a script to appear there
is if the user actually put it there.

00:42:36.400 --> 00:42:39.740
So mind you,
the app can reveal the application

00:42:39.740 --> 00:42:42.700
script directory in Finder,
and the user can put a script there.

00:42:42.700 --> 00:42:46.560
And by the act of the user indicating
that they want to put a script there

00:42:46.630 --> 00:42:50.290
and make it available to the app,
the app is now able to invoke it.

00:42:50.410 --> 00:42:53.280
The system will run the
script on the app's behalf.

00:42:53.300 --> 00:42:55.290
With no sandbox restrictions.

00:42:55.300 --> 00:42:59.390
And using this functionality
requires no entitlements.

00:42:59.680 --> 00:43:03.000
App Sandbox is the most advanced
desktop security system in the world,

00:43:03.000 --> 00:43:05.590
but it is not perfect and
is not meant to be perfect.

00:43:05.720 --> 00:43:11.020
Its purpose is to be another
strong barrier against exploitation

00:43:11.260 --> 00:43:13.550
and against coding errors.

00:43:13.960 --> 00:43:17.020
It does this by driving
security policy by user intent,

00:43:17.020 --> 00:43:21.890
and it's a technology that's
really complementary to Gatekeeper.

00:43:22.370 --> 00:43:24.610
We'll be talking about Gatekeeper more,
I think, actually,

00:43:24.690 --> 00:43:29.330
in this very room immediately
after this presentation.

00:43:29.570 --> 00:43:32.710
Another very frequent question is, "Well,
why Gatekeeper if there's

00:43:32.710 --> 00:43:34.690
already App Sandbox,
and why App Sandbox if there's

00:43:34.690 --> 00:43:38.260
already Gatekeeper?" And the
reason is because they solve

00:43:38.520 --> 00:43:41.210
fundamentally different problems.

00:43:41.610 --> 00:43:45.300
Gatekeeper is a mechanism
designed to prevent inadvertent

00:43:45.450 --> 00:43:48.680
installation of malware,
of applications that were

00:43:48.680 --> 00:43:50.620
intentionally malicious.

00:43:50.720 --> 00:43:55.040
App Sandbox is a mechanism that
tries to make it so that coding

00:43:55.040 --> 00:43:58.650
errors and vulnerabilities in benign
applications and applications that are

00:43:58.660 --> 00:44:03.520
not malware do not ruin the user's day.

00:44:03.650 --> 00:44:06.710
So these technologies are
very much complementary.

00:44:07.700 --> 00:44:10.910
We have some great documentation for you
guys in the App Sandbox Design Guide.

00:44:11.040 --> 00:44:14.020
We have some phenomenal sample codes
showing how to use the new features

00:44:14.130 --> 00:44:16.100
like the application groups entitlement.

00:44:16.230 --> 00:44:23.000
And obviously we will be here all week to
answer any other questions that you have.

00:44:23.110 --> 00:44:25.340
But here's the thing:
30 billion downloads on

00:44:25.460 --> 00:44:26.600
iOS from the App Store.

00:44:26.730 --> 00:44:30.500
Every single one of those apps,
every app you've ever run on your phone,

00:44:30.500 --> 00:44:33.500
every third-party app has run
in a sandbox from day one.

00:44:33.590 --> 00:44:37.170
And it's given users this remarkable
carefree experience where they

00:44:37.170 --> 00:44:40.300
can go into the App Store,
they don't worry about, "Oh,

00:44:40.300 --> 00:44:43.700
is downloading this app going to do
something really bad to my phone?

00:44:43.700 --> 00:44:46.410
Like, what's going to happen if it
gets exploited when it's browsing

00:44:46.410 --> 00:44:50.690
the internet?" This is just not
even in their mental vocabulary.

00:44:50.780 --> 00:44:54.950
And we want to bring that same
delightful carefree experience

00:44:55.280 --> 00:44:57.130
to OS X with App Sandbox.

00:44:58.510 --> 00:45:01.130
To help you do this,
we'll be talking a lot

00:45:01.180 --> 00:45:02.770
about related technologies.

00:45:02.840 --> 00:45:04.680
I already mentioned
Gatekeeper and Developer ID,

00:45:04.680 --> 00:45:08.070
which is happening here
immediately after this session.

00:45:08.140 --> 00:45:12.640
I mentioned two great new automation
security features in Mountain Lion,

00:45:12.640 --> 00:45:16.310
and actually there will be a
session covering those in depth.

00:45:16.890 --> 00:45:20.220
And finally, for XPC,
there is a session that's

00:45:20.220 --> 00:45:23.500
sort of a deeper session,
deep dive on XPC and GCD and

00:45:23.500 --> 00:45:25.480
asynchronous technologies.

00:45:25.590 --> 00:45:28.550
But actually, not mentioned on this list,
on Thursday,

00:45:28.670 --> 00:45:31.140
there is a session at 4:30 p.m.

00:45:31.230 --> 00:45:33.600
about Cocoa-level XPC.

00:45:33.800 --> 00:45:39.350
So we have some really great new
Cocoa wrappers for XPC in Mountain Lion.

00:45:39.500 --> 00:45:42.860
And I really encourage you to visit
that session and see just how easy it

00:45:42.950 --> 00:45:46.800
can be to establish XPC communication
between you and your helper apps.

00:45:47.380 --> 00:45:49.160
Come by, say hello,
we'd love to work with you

00:45:49.160 --> 00:45:51.600
and we'd love to help you
make your applications secure.

00:45:51.640 --> 00:45:53.120
Thank you.
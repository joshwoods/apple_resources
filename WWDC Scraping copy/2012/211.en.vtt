WEBVTT

00:00:11.100 --> 00:00:12.660
Ladies and gentlemen, good morning.

00:00:12.800 --> 00:00:17.260
Today we're going to talk about building
concurrent user interfaces on iOS.

00:00:17.300 --> 00:00:20.980
And you've read the title,
but let me tell you what I mean

00:00:21.160 --> 00:00:24.010
by concurrent user interfaces.

00:00:24.350 --> 00:00:27.540
In particular,
what I'm going to teach you today

00:00:27.620 --> 00:00:32.450
is how to keep your applications
responsive and reactive to user input

00:00:32.550 --> 00:00:36.150
even while they're doing a lot of work.

00:00:36.510 --> 00:00:39.180
Now, if you've never done any
concurrent programming before,

00:00:39.210 --> 00:00:40.940
this is a deep and complicated field.

00:00:41.000 --> 00:00:42.700
It's full of trap doors.

00:00:42.820 --> 00:00:46.810
But I'm hoping that I can give you enough
of the fundamentals today to get you

00:00:46.860 --> 00:00:53.030
on your way and enough understanding to
avoid some of the pitfalls that are here.

00:00:53.260 --> 00:00:55.200
If you've done concurrent
programming before,

00:00:55.200 --> 00:00:58.840
on the other hand, you may feel like,
"Well, I must still be in bed.

00:00:58.840 --> 00:01:02.250
I must still be dreaming because
I thought that you can't do any

00:01:02.310 --> 00:01:04.200
concurrent anything with UIKit.

00:01:04.200 --> 00:01:05.070
It doesn't support it.

00:01:05.300 --> 00:01:08.490
Somebody on the Internet told me so."

00:01:08.710 --> 00:01:11.300
But somebody on the Internet was wrong.

00:01:11.440 --> 00:01:15.990
And today I'm going to teach you a number
of techniques where you can leverage that

00:01:15.990 --> 00:01:21.240
existing concurrent programming knowledge
that you have and some best practices for

00:01:21.240 --> 00:01:24.840
how to do that in particular with UIKit.

00:01:24.970 --> 00:01:28.310
So all that out of the way,
let's dive in.

00:01:28.810 --> 00:01:33.020
Say that you've got an app that downloads
a bunch of JSON from the internet,

00:01:33.080 --> 00:01:35.140
like about half of them do.

00:01:35.210 --> 00:01:38.120
But maybe it's a particularly
large blob of JSON,

00:01:38.120 --> 00:01:40.200
so you need to parse it.

00:01:40.300 --> 00:01:43.700
And then maybe you're going to massage
that data in order to get exactly

00:01:43.700 --> 00:01:45.730
what you need for your application.

00:01:45.890 --> 00:01:48.610
That can take a while,
and depending on how your

00:01:48.610 --> 00:01:51.390
application is designed,
you don't necessarily need to block

00:01:51.390 --> 00:01:56.150
your user from interacting with
your application during that time.

00:01:56.210 --> 00:02:00.320
So I'm going to teach you how to
process that data concurrently with

00:02:00.410 --> 00:02:04.640
respect to handling touch events,
handling accelerometer events,

00:02:04.700 --> 00:02:08.450
all of that, so your application
will feel really fluid.

00:02:08.810 --> 00:02:11.670
Next up,
once you've got that data processed,

00:02:11.720 --> 00:02:15.040
you may need to make some
very fancy rendering of it.

00:02:15.370 --> 00:02:17.880
You're gonna draw a pretty
plot or something like that,

00:02:17.880 --> 00:02:22.040
and maybe your draw rect
takes 100 milliseconds.

00:02:22.210 --> 00:02:25.030
Well, again, depending on the design
of your application,

00:02:25.040 --> 00:02:30.040
that doesn't necessarily need to block
your user from doing things with it.

00:02:30.140 --> 00:02:32.310
You don't want it to feel
laggy just because you're

00:02:32.500 --> 00:02:33.700
making some complex drawing.

00:02:33.700 --> 00:02:36.040
You don't want to punish
your user for that.

00:02:36.050 --> 00:02:40.500
So I'm going to show you how to move
drawing to the background as well.

00:02:40.710 --> 00:02:44.930
And then, once you've got all of these
concurrent operations happening,

00:02:44.930 --> 00:02:47.250
you're juggling all these things at once.

00:02:47.490 --> 00:02:51.360
You don't want more balls in
the air than you have to have.

00:02:51.560 --> 00:02:54.760
And so if the user has done
something like navigated away

00:02:54.760 --> 00:02:58.040
from a part of your application,
which means that one of the things

00:02:58.530 --> 00:03:01.840
you've started up is no longer relevant,
I'm going to show you how to

00:03:01.990 --> 00:03:06.140
cancel it early so that you
don't perform unneeded work,

00:03:06.400 --> 00:03:09.640
wasting your user's battery life
and slowing him down from getting

00:03:09.640 --> 00:03:11.640
to what he actually wants to do.

00:03:11.640 --> 00:03:13.380
This is the app we're going
to be looking at today.

00:03:13.380 --> 00:03:15.900
It's part of my Get Rich Quick scheme.

00:03:16.010 --> 00:03:19.800
It does some fancy analysis
of the stock charts and tells

00:03:19.800 --> 00:03:21.710
me where to put my dollars.

00:03:21.930 --> 00:03:27.460
It's basically a big gambling helper,
and I'd like to show you what

00:03:27.460 --> 00:03:30.350
we're going to start with.

00:03:30.400 --> 00:03:34.160
We're going to be working
on this app all morning.

00:03:35.020 --> 00:03:36.040
So I've got Xcode here.

00:03:36.290 --> 00:03:37.820
Let's build and run.

00:03:37.870 --> 00:03:39.140
Let's see where we are.

00:03:39.240 --> 00:03:41.290
So as I click in here--

00:03:42.090 --> 00:03:44.840
Nothing is responding at all.

00:03:44.920 --> 00:03:47.320
And this is even worse.

00:03:47.430 --> 00:03:48.640
But by the end of the day,
we're going to have the

00:03:48.640 --> 00:03:49.900
situation much better.

00:03:50.180 --> 00:03:52.010
You'll notice even like
if I'd changed my mind,

00:03:52.010 --> 00:03:54.410
I clicked on the wrong category.

00:03:54.990 --> 00:03:58.600
I can't even back out
until all that data loads.

00:03:58.740 --> 00:04:00.650
That's pretty nasty.

00:04:01.580 --> 00:04:04.400
So we're going to spend the
day fixing this application up.

00:04:04.400 --> 00:04:07.990
And whenever you have performance issues,
the first thing you

00:04:08.070 --> 00:04:11.070
should do is get data,
because you don't want to fix

00:04:11.160 --> 00:04:15.620
potential performance problems
without actually knowing what's wrong.

00:04:15.640 --> 00:04:19.680
And to get data about your performance,
we like to use instruments.

00:04:19.720 --> 00:04:24.240
So I'm just going to go back to Xcode,
choose product profile,

00:04:24.300 --> 00:04:27.740
so run this application in instruments.

00:04:27.740 --> 00:04:31.600
And when instruments ask me, well,
what kind of instrumentation am I doing,

00:04:31.610 --> 00:04:34.670
I'm going to choose the time profiler,
because what I care about

00:04:34.670 --> 00:04:35.860
is where is my time going?

00:04:36.160 --> 00:04:38.810
Why is it taking so long?

00:04:39.980 --> 00:04:41.660
So now the application runs again.

00:04:41.700 --> 00:04:45.280
And as I click into this category here,
we see this big purple plot

00:04:45.280 --> 00:04:49.780
indicating that the computer
is thinking really hard.

00:04:49.840 --> 00:04:52.840
And we go back here,
and we see another big purple plot.

00:04:53.020 --> 00:04:55.540
So we're wondering about
these big purple plots.

00:04:55.590 --> 00:04:57.400
What's hidden there?

00:04:57.510 --> 00:05:00.320
If I hold down the Option key
and drag over one of them,

00:05:00.370 --> 00:05:02.870
I can filter to just that.

00:05:03.510 --> 00:05:07.950
And down here in this call tree area,
I can see what's taking so much time

00:05:08.460 --> 00:05:12.450
quickly by holding down the Option key
and clicking on this disclosure triangle.

00:05:12.660 --> 00:05:17.000
And as I scroll down, I see, okay,
it's all of that fancy stock

00:05:17.000 --> 00:05:19.960
smoothing that's supposed to be
predicting the future for me.

00:05:20.040 --> 00:05:22.400
That's what's slowing me down here.

00:05:22.490 --> 00:05:25.270
And it's all happening in response
to some network data being received.

00:05:25.380 --> 00:05:28.270
CR request connection did finish loading.

00:05:28.790 --> 00:05:35.090
And so this is the section that we're
really going to want to try to speed up.

00:05:36.020 --> 00:05:40.500
If we go back to slides for a second,
I will give you an overview

00:05:40.500 --> 00:05:42.810
of how we're going to do that.

00:05:44.310 --> 00:05:49.490
Let's start with some nice
schematics before we get to code.

00:05:49.570 --> 00:05:54.210
The model that we like
to use is one of queues.

00:05:55.300 --> 00:05:56.630
They're a little bit like
lines at the grocery store.

00:05:56.880 --> 00:05:59.100
You got a bunch of people in that line.

00:05:59.180 --> 00:06:00.700
We're going to deal
with the one in front.

00:06:00.780 --> 00:06:03.060
When he's done, we're going to deal
with the one behind him.

00:06:03.270 --> 00:06:06.300
Somebody comes in at the end of the line,
it's not his turn for a while.

00:06:06.300 --> 00:06:10.520
So processing computational
work on our system,

00:06:10.520 --> 00:06:13.300
we use much the same metaphor.

00:06:13.300 --> 00:06:15.300
By default,
there's this thing called the main queue,

00:06:15.300 --> 00:06:18.270
and all of the system events
come in on that queue.

00:06:18.330 --> 00:06:21.300
So that's touches,
that's accelerometer events.

00:06:21.340 --> 00:06:25.720
And because all of the work that
you're doing in general is happening

00:06:25.720 --> 00:06:29.210
in response to these system events,
you are doing things

00:06:29.210 --> 00:06:32.140
when the user touches,
that means that your work,

00:06:32.140 --> 00:06:35.160
i.e., this expensive
work that we just saw,

00:06:35.160 --> 00:06:38.710
is also happening on the main queue.

00:06:39.290 --> 00:06:42.720
So the user touches,
and then we queue off

00:06:42.830 --> 00:06:43.610
some network requests.

00:06:43.670 --> 00:06:47.390
We say, hey,
give us some data about these stocks.

00:06:47.590 --> 00:06:51.060
That network data comes in,
also on the main queue,

00:06:51.160 --> 00:06:54.010
but now we have some work to
do because we got a bunch of

00:06:54.010 --> 00:06:56.000
data and we need to process it.

00:06:56.130 --> 00:06:59.970
So all of that processing work
appears on the main queue as well.

00:07:00.190 --> 00:07:01.290
Now this queue's pretty backed up.

00:07:01.360 --> 00:07:02.900
This line's getting long.

00:07:03.010 --> 00:07:06.880
So if a touch event comes in
now at the end of the queue,

00:07:07.220 --> 00:07:11.440
And these processing events take a few
seconds for us to get through them.

00:07:11.580 --> 00:07:15.650
And that touch event will end up
getting processed like 15 seconds

00:07:15.660 --> 00:07:19.760
after the user actually touched
or something very terrible.

00:07:19.950 --> 00:07:22.660
Intuitively,
we would like that touch event to be

00:07:22.660 --> 00:07:25.140
able to jump to the head of the line.

00:07:25.320 --> 00:07:27.060
Touches are important.

00:07:28.170 --> 00:07:31.260
So,
the way that we're going to do that is

00:07:31.270 --> 00:07:34.170
effectively by opening another line.

00:07:34.430 --> 00:07:39.800
We can have a data processing queue
in addition to our main queue.

00:07:39.850 --> 00:07:44.200
And what that'll mean is that
when that network data comes in,

00:07:44.230 --> 00:07:47.020
rather than enqueuing a bunch
of work to be performed,

00:07:47.210 --> 00:07:51.810
smoothing that data on the main queue,
we're going to put that data

00:07:51.810 --> 00:07:53.640
on the data processing queue.

00:07:53.700 --> 00:07:56.550
And so now when a touch
comes in on the main queue,

00:07:57.070 --> 00:07:59.630
If we have a dual core device,
we can even work on the touch event

00:07:59.710 --> 00:08:02.460
and the data processing simultaneously.

00:08:02.510 --> 00:08:05.820
But even if we have a single core device,
the system will slice things up

00:08:05.940 --> 00:08:07.900
so that it gives time to both.

00:08:07.970 --> 00:08:10.400
And it'll actually give more
to the main queue because,

00:08:10.450 --> 00:08:13.190
like I said a moment ago,
touches are important.

00:08:13.260 --> 00:08:18.230
So this way, you can handle touches,
you can handle accelerometer events,

00:08:18.290 --> 00:08:22.080
you can handle even incoming
network data and timers while

00:08:22.080 --> 00:08:25.260
you're doing this extra work,
this smoothing work.

00:08:25.300 --> 00:08:28.450
Now, there's this one last little
square here at the bottom.

00:08:28.540 --> 00:08:29.060
This one's new.

00:08:29.060 --> 00:08:30.690
It's a box within a box.

00:08:30.770 --> 00:08:33.400
It wasn't in the last schematic.

00:08:33.440 --> 00:08:40.360
And it signifies a new idiom that
you need to be aware of when you're

00:08:40.460 --> 00:08:41.980
doing concurrent programming.

00:08:42.160 --> 00:08:46.100
It has to do with the age-old
adage that also applies here,

00:08:46.140 --> 00:08:50.200
namely, "Don't cross the streams."

00:08:51.010 --> 00:08:54.800
Consider what might happen if,
like I said,

00:08:54.800 --> 00:08:58.900
a touch event comes in on the main
queue and UIKit is trying to figure out

00:08:58.970 --> 00:09:05.300
which table view cell did that user just
touch while you are modifying the data

00:09:05.300 --> 00:09:11.470
source which backs that table view cell,
potentially even on another processor.

00:09:11.790 --> 00:09:14.190
Calamity will result.

00:09:14.790 --> 00:09:18.680
And this is really one of the
biggest problems in concurrency,

00:09:18.680 --> 00:09:20.670
and it's a very deep
and complicated problem.

00:09:20.870 --> 00:09:23.700
But I'm going to show you
a guideline today which,

00:09:23.700 --> 00:09:27.200
if you follow it,
should take care of basically

00:09:27.200 --> 00:09:31.700
all of the cases that you care
about when working with UIKit.

00:09:31.920 --> 00:09:33.680
And it goes like this.

00:09:33.700 --> 00:09:35.540
The main queue is UIKit's queue.

00:09:35.770 --> 00:09:37.700
It's where UIKit does its stuff.

00:09:37.700 --> 00:09:40.690
It handles touches,
does rendering for the most part,

00:09:40.690 --> 00:09:43.700
all of these things that
I've been telling you about.

00:09:43.700 --> 00:09:48.280
And so if you want to ensure that
you don't touch anything that

00:09:48.320 --> 00:09:53.700
UIKit might touch at the same time,
then all you have to do is,

00:09:53.700 --> 00:09:56.700
when you've finished
processing that data,

00:09:56.840 --> 00:10:02.740
you send it back over to the main
queue and actually update your

00:10:02.740 --> 00:10:05.660
user interface on the main queue.

00:10:05.710 --> 00:10:07.700
So if you have a lot of
expensive work to do,

00:10:07.700 --> 00:10:12.700
you can do all of your expensive
work on whatever queue you like.

00:10:12.700 --> 00:10:15.700
And then you can just send it back to
the main queue and update your UIKit.

00:10:15.760 --> 00:10:17.700
And then you can just send it back to
the main queue and update your UIKit.

00:10:17.700 --> 00:10:19.710
And then when you finish
all that expensive work,

00:10:19.800 --> 00:10:22.570
you perform that one little extra step
of sending the results of that work

00:10:23.240 --> 00:10:28.300
back over to the main queue and updating
your user interface there so that

00:10:28.480 --> 00:10:31.700
you don't end up fighting with UIKit.

00:10:32.220 --> 00:10:36.600
That's a very small amount of extra time
compared to all of the time you save by

00:10:36.600 --> 00:10:42.340
doing that extra processing on a separate
queue compared to your actual work.

00:10:42.480 --> 00:10:47.330
Now that we've talked through schematics,
let's talk about code.

00:10:47.760 --> 00:10:51.540
On our platform,
this queue idea that I've been

00:10:51.540 --> 00:10:56.580
talking about is modeled by a
class called NSOperationQueue.

00:10:56.630 --> 00:10:58.250
You can make one of them like this.

00:10:58.360 --> 00:11:01.710
So now you've got that little queue
figure that I've been showing you.

00:11:01.820 --> 00:11:03.760
You can even give it a name,
which is useful if you have

00:11:03.760 --> 00:11:07.390
a lot of them flying around,
because it'll show up in the debugger.

00:11:07.470 --> 00:11:09.390
And you can query it.

00:11:09.600 --> 00:11:13.390
And you give that cue work
by a number of approaches.

00:11:13.650 --> 00:11:15.000
This is one of them.

00:11:15.000 --> 00:11:16.500
We'll start using this one first.

00:11:16.550 --> 00:11:19.350
AddOperationWithBlock.

00:11:19.490 --> 00:11:22.940
You give a block to the queue,
and you give it some work.

00:11:23.030 --> 00:11:25.350
So now the queue has something to do.

00:11:25.520 --> 00:11:29.830
And let me show you what it looks like
to do that box within a box situation.

00:11:30.340 --> 00:11:36.270
Just like we had a box within a box,
we now have a block within a block.

00:11:39.700 --> 00:11:41.250
And you'll notice the way that
I shipped work off to the main

00:11:41.250 --> 00:11:45.700
queue was by actually getting
a reference to the main queue,

00:11:45.760 --> 00:11:49.970
NSOperationQueue, main queue,
and then we gave it work the same

00:11:49.970 --> 00:11:54.710
way that we gave our own queue work,
addOperationWithBlock.

00:11:54.860 --> 00:11:59.230
So when we get around to actually
playing through that last operation,

00:11:59.290 --> 00:12:03.340
we end up seeing the nice same schematic
effect that we had in the last slide.

00:12:03.340 --> 00:12:05.420
We're giving the main queue work.

00:12:05.500 --> 00:12:08.440
We're sending that data,
the resulting data from our processing,

00:12:08.540 --> 00:12:09.800
over to the main queue.

00:12:09.950 --> 00:12:13.410
Now that we've talked
through the principles,

00:12:13.920 --> 00:12:16.000
Let's put it to practice.

00:12:16.080 --> 00:12:19.580
Try to fix up our
application a little bit.

00:12:19.680 --> 00:12:23.040
So looking at this instruments profile,

00:12:23.960 --> 00:12:25.100
We see where the heavy work is.

00:12:25.130 --> 00:12:27.900
We see that it's in
smoothing these stock points,

00:12:27.920 --> 00:12:33.000
and we see that it's happening in
result-- in response to finishing

00:12:33.440 --> 00:12:34.980
receiving some network data.

00:12:35.130 --> 00:12:39.060
We've got some network data,
and so now we're gonna process it.

00:12:39.070 --> 00:12:42.270
In fact,
even initializing a stock is expensive.

00:12:42.940 --> 00:12:47.470
So, we're going to initialize
those stocks concurrently,

00:12:47.660 --> 00:12:50.760
which means that we need to go
to CRStocksTableViewController,

00:12:50.790 --> 00:12:53.600
requestDidFinishWithObject,
to do our work.

00:12:53.700 --> 00:12:59.240
This is the CRStocksTableViewController,
and if we scroll down a little bit,

00:12:59.370 --> 00:13:03.740
we can find the relevant method,
requestDidFinishWithObject.

00:13:03.820 --> 00:13:07.780
All it does is pull all of the
objects out of the received data and

00:13:07.780 --> 00:13:12.580
create a stock for each one of them,
save it in an instance variable,

00:13:12.800 --> 00:13:15.880
and then ask the table view to reload.

00:13:16.350 --> 00:13:18.900
We're going to move this
work to the background.

00:13:18.930 --> 00:13:21.660
In order to do that,
I first need to create one of those

00:13:21.680 --> 00:13:23.490
operation queues I was talking about.

00:13:23.630 --> 00:13:27.810
So I'll add the instance variable to my
list of instance variables and initialize

00:13:27.810 --> 00:13:31.590
it in this Table View Controller's
designated initializer.

00:13:33.020 --> 00:13:35.820
Once I've done that,
I can start moving this

00:13:35.820 --> 00:13:38.430
work to the background.

00:13:38.710 --> 00:13:42.980
So here,
I'm gonna add a block onto my queue.

00:13:44.320 --> 00:13:49.490
And now all of this work will
happen not on the main queue,

00:13:49.490 --> 00:13:51.720
but on the queue I just created.

00:13:52.670 --> 00:13:55.560
We're not done yet, though,
because you have to remember

00:13:55.560 --> 00:13:58.540
that box within a box situation
that I was telling you about.

00:13:58.590 --> 00:14:02.960
You do the work in the background,
and once you've got the result,

00:14:03.020 --> 00:14:07.200
you send the result over to the main
queue and update your user interface

00:14:07.490 --> 00:14:10.710
with the result on the main queue.

00:14:11.480 --> 00:14:17.100
And just like in the schematic,
we can do that by saying NSOperationQueue

00:14:17.100 --> 00:14:20.600
main queue add operation with block.

00:14:20.720 --> 00:14:25.820
So now this is an operation which
initializes all of my stocks and which,

00:14:26.010 --> 00:14:29.920
once all of the stocks are initialized,
ships them back over to the main

00:14:30.360 --> 00:14:32.790
queue to update my user interface.

00:14:32.890 --> 00:14:36.810
You may be wondering, okay,
I understand why table view reload

00:14:36.810 --> 00:14:38.590
data needs to be on the main queue.

00:14:38.700 --> 00:14:40.390
I mean, that's touching the UI.

00:14:40.590 --> 00:14:43.160
But what about this
stocks instance variable?

00:14:43.410 --> 00:14:47.030
Why does this need to be updated
on the main queue as well?

00:14:47.630 --> 00:14:51.150
Well, if we scroll down a little bit,
we see our implementation of

00:14:51.150 --> 00:14:55.200
UITableView's data source method,
number of rows and section.

00:14:55.270 --> 00:14:59.200
We see that it returns the number
of elements in the stocks array.

00:14:59.250 --> 00:15:03.000
And so if UIKit is asking,
"How many rows are in this table view?"

00:15:03.070 --> 00:15:07.800
while we are changing around the number
of rows that are in that table view,

00:15:07.890 --> 00:15:09.960
very bad things will happen.

00:15:10.220 --> 00:15:15.920
Consequently, we update not only the user
interface on the main queue using

00:15:15.920 --> 00:15:19.200
that shipping over technique,
but also anything which the user

00:15:19.200 --> 00:15:20.440
interface might be touching.

00:15:20.440 --> 00:15:23.130
So now that we've done this,
let's take a look at what

00:15:23.340 --> 00:15:24.680
our project looks like.

00:15:24.780 --> 00:15:27.570
If I click in the mid-cap,
you'll see that it's letting

00:15:27.570 --> 00:15:31.150
me scroll at least a little bit
until it tries to start rendering.

00:15:31.160 --> 00:15:35.740
And the other nice thing we've bought for
ourselves is that I can change my mind,

00:15:35.740 --> 00:15:39.280
even though it's doing all
this expensive data processing.

00:15:41.580 --> 00:15:46.200
But we still see that that
scrolling performance was no good.

00:15:46.290 --> 00:15:49.110
So let's use instruments
again to figure out why.

00:15:50.290 --> 00:15:52.600
Let me call your attention
to a couple things.

00:15:52.750 --> 00:15:54.900
Here you see a line for main thread.

00:15:54.970 --> 00:15:57.390
Main thread is basically like main queue.

00:15:57.550 --> 00:16:02.590
And as I click here into this category,
we see the thing that is accruing

00:16:02.600 --> 00:16:05.200
all of this running time,
the thing that's doing all of this work,

00:16:05.310 --> 00:16:07.610
is not the main thread, i.e.

00:16:07.610 --> 00:16:11.600
main queue,
but rather this dispatch worker thread,

00:16:11.600 --> 00:16:12.280
i.e.

00:16:12.280 --> 00:16:13.510
worker queue.

00:16:14.580 --> 00:16:15.040
So that's great.

00:16:15.240 --> 00:16:17.920
That means we move that
work off the main queue.

00:16:18.220 --> 00:16:21.020
But now as I start scrolling around,
it's the main queue that

00:16:21.030 --> 00:16:24.170
starts accruing time again.

00:16:24.600 --> 00:16:26.700
So let's figure out what's going on.

00:16:26.760 --> 00:16:30.800
Again, I'll filter to just this region.

00:16:30.870 --> 00:16:35.420
And I'll see that
CRStockCellDrawRect is the culprit.

00:16:37.170 --> 00:16:39.380
So we've got our data
processing out of the way,

00:16:39.410 --> 00:16:41.030
and now it's our drawing
that we have to worry about.

00:16:41.060 --> 00:16:45.190
So next I'm going to show you
how to move your drawing to the

00:16:45.200 --> 00:16:48.200
background just like we moved that
data processing to the background.

00:16:48.200 --> 00:16:51.460
Before we do that, though,
I'd like to review what we just covered.

00:16:51.460 --> 00:16:57.260
Everything on the system that comes in,
touch events, accelerometer events,

00:16:57.270 --> 00:16:59.530
network data by default,
all of these system events,

00:16:59.530 --> 00:17:01.230
they're all delivered on the main queue.

00:17:01.240 --> 00:17:05.680
And because you're doing all of your
work in response to those events,

00:17:06.330 --> 00:17:08.390
you're basically just
implementing a whole series

00:17:08.470 --> 00:17:09.860
of callbacks to system events.

00:17:09.860 --> 00:17:13.110
All of your work happens
on the main queue as well.

00:17:14.700 --> 00:17:16.650
which means that when
you're doing a lot of work,

00:17:16.650 --> 00:17:20.270
you are blocking all of those things
that arrive on the main queue.

00:17:20.360 --> 00:17:24.820
You can fix this situation by doing
that expensive work on a non-main queue,

00:17:24.820 --> 00:17:26.840
one of your own creation.

00:17:26.940 --> 00:17:30.270
NSOperationQueue is the one
way that you can do that.

00:17:30.730 --> 00:17:33.590
And then we covered this one
additional tricky subject,

00:17:33.590 --> 00:17:37.140
which is that if you are touching
anything which UIKit might touch,

00:17:37.140 --> 00:17:41.640
we don't want a kind of siblings
fighting over the toy situation here.

00:17:41.640 --> 00:17:44.740
So when you're done doing
that expensive work,

00:17:44.740 --> 00:17:49.200
ship the results back over to the
main queue and update it there.

00:17:51.410 --> 00:17:52.940
Excellent.

00:17:52.960 --> 00:17:54.480
Let's talk about drawing.

00:17:54.770 --> 00:17:57.560
Schematically, this is our situation.

00:17:57.740 --> 00:18:01.500
A touch comes in,
which causes a scroll to happen.

00:18:01.690 --> 00:18:04.560
And now we've got a new
table view cell on screen.

00:18:04.840 --> 00:18:06.180
So we've got this draw rect.

00:18:06.430 --> 00:18:10.520
And you can see I've drawn
it large to indicate just how

00:18:10.520 --> 00:18:13.030
expensive this draw rect is.

00:18:13.590 --> 00:18:15.570
So as we're sitting around
waiting for this draw rect,

00:18:15.720 --> 00:18:18.700
touch events are enqueuing behind it,
just as they started enqueuing

00:18:18.700 --> 00:18:21.930
behind the data processing
work that we were doing before.

00:18:22.020 --> 00:18:25.040
And it's not until we finish
the draw rect operation that

00:18:25.070 --> 00:18:27.190
we handle those touch events.

00:18:28.600 --> 00:18:31.940
So just like with the data processing,
what we're going to do is try to put

00:18:32.010 --> 00:18:37.350
the rendering on a queue of its own
rather than putting it on the main queue,

00:18:37.420 --> 00:18:39.830
blocking all of that incoming work.

00:18:39.890 --> 00:18:43.580
So now when a touch event comes down,
we'll put the rendering

00:18:43.580 --> 00:18:45.160
on a background queue.

00:18:45.180 --> 00:18:49.000
And just as before,
we've got that situation where

00:18:49.090 --> 00:18:52.440
we can process touches that are
occurring on the main queue even

00:18:52.440 --> 00:18:54.300
while the rendering is happening.

00:18:54.330 --> 00:18:58.180
And just as before,
we have the box within a box,

00:18:58.180 --> 00:19:01.360
which sends the result of that
rendering operation over to the

00:19:01.480 --> 00:19:05.990
main queue to actually do the work
of updating our user interface.

00:19:08.470 --> 00:19:11.480
In order to show you the
code teaching you how to make

00:19:11.570 --> 00:19:14.360
this happen for yourselves,
I first need to make sure that

00:19:14.370 --> 00:19:17.710
we're all on the same page
as far as how UIKit actually

00:19:17.910 --> 00:19:19.910
gets pixels onto the screen.

00:19:20.070 --> 00:19:22.910
That has to not be magic first.

00:19:23.140 --> 00:19:24.970
'Cause right now,
it may be magic for some of you.

00:19:25.100 --> 00:19:27.080
So you have UIViews.

00:19:27.150 --> 00:19:28.100
You're familiar with this class.

00:19:28.240 --> 00:19:32.100
There is this method,
UIViewSetNeedsDisplay.

00:19:32.100 --> 00:19:36.100
That is the method that you call to say,
"UIKit, I would like to draw something.

00:19:36.100 --> 00:19:39.090
"I've implemented DrawRect,
and I want you to call it."

00:19:39.300 --> 00:19:43.240
Behind the scenes,
what UIKit is doing is turning around and

00:19:43.240 --> 00:19:49.950
calling caLayer setNeedsDisplay because
every view is backed by a caLayer.

00:19:50.570 --> 00:19:52.780
And then sometime later,
when it's convenient for

00:19:52.780 --> 00:19:56.710
the rendering system,
that layer will be asked to display.

00:19:57.010 --> 00:20:00.000
And when it's asked to display,
it will create a region of

00:20:00.000 --> 00:20:02.500
memory called a backing store.

00:20:02.550 --> 00:20:05.220
It's basically just a bitmap
that stores the result of all

00:20:05.220 --> 00:20:06.480
of those rendering operations.

00:20:06.590 --> 00:20:10.790
It's an image that's going to be
painted on screen repeatedly until

00:20:10.790 --> 00:20:14.240
you call set needs display again,
thus invalidating it.

00:20:14.290 --> 00:20:16.800
So it's that backing store
we're concerned with.

00:20:16.860 --> 00:20:20.880
And in your drawRect implementation,
you're going to use core graphics

00:20:21.280 --> 00:20:23.600
to draw into that backing store.

00:20:23.650 --> 00:20:27.990
And so we tell core graphics that
this is the place we want to put the

00:20:27.990 --> 00:20:34.010
result of those drawing operations
by creating a CG context and pointing

00:20:34.010 --> 00:20:36.430
that CG context at the backing store.

00:20:36.560 --> 00:20:41.570
Then all of your lines and shapes
and things will go into that bitmap.

00:20:42.210 --> 00:20:44.740
Now, you've never accessed this directly,
probably.

00:20:44.740 --> 00:20:50.600
UIKit surfaces that context to you
via UIGraphics.getCurrentContext,

00:20:50.720 --> 00:20:53.370
which you've probably used if
you've ever done any CG drawing

00:20:53.370 --> 00:20:55.540
calls of your own in DrawRect.

00:20:55.660 --> 00:20:57.930
But even if you haven't,
the methods that you're

00:20:57.930 --> 00:21:01.020
maybe more familiar with,
like UIImageDrawAtPoint and

00:21:01.020 --> 00:21:04.050
the BezierPath methods,
the UIGraphics methods,

00:21:04.160 --> 00:21:05.660
they all use this function, too.

00:21:05.660 --> 00:21:08.770
So we're all pointing
at this backing store.

00:21:08.930 --> 00:21:12.690
This is where we're gonna put the
results of our drawing operations.

00:21:13.610 --> 00:21:18.150
So now, our strategy is going to be,
instead of doing our drawing

00:21:18.480 --> 00:21:22.970
into this region of memory that
Core Animation is managing for us,

00:21:23.300 --> 00:21:27.890
We're going to replace our
UI view with a UI image view,

00:21:27.970 --> 00:21:34.160
make our own image, and draw that image
on our background cue.

00:21:34.220 --> 00:21:36.130
We're going to take
this into our own hands.

00:21:36.180 --> 00:21:37.580
We're not going to let
Core Animation make a

00:21:37.580 --> 00:21:38.860
backing store for us.

00:21:39.070 --> 00:21:42.190
We're going to make the
equivalent ourselves.

00:21:43.060 --> 00:21:47.120
The nice thing is you can actually
use basically all of the same code.

00:21:47.270 --> 00:21:52.250
This is a typical, albeit useless,
draw-rect implementation.

00:21:52.310 --> 00:21:55.630
And we're going to keep it
essentially the same as we create

00:21:55.830 --> 00:21:59.530
a draw-rect implementation,
which doesn't just draw into

00:21:59.530 --> 00:22:03.100
the existing context that
Core Animation has set up for us,

00:22:03.150 --> 00:22:06.420
but which rather creates one
of its own and draws into that

00:22:06.750 --> 00:22:08.600
and then pulls an image out.

00:22:08.790 --> 00:22:10.900
So instead of draw-rect,

00:22:11.220 --> 00:22:15.100
will make some function
which returns a UI image.

00:22:15.160 --> 00:22:19.610
It's gonna need to take a size to know
how big that image is going to be.

00:22:20.480 --> 00:22:25.300
We make the UI image using
UIGraphicsBeginImageContextWithOptions.

00:22:25.380 --> 00:22:27.000
The first argument is the size.

00:22:27.170 --> 00:22:29.270
How big of a region of memory do we need?

00:22:29.400 --> 00:22:32.060
This is specified in pixels.

00:22:32.280 --> 00:22:36.490
Except there's a couple other options
that can affect how that works.

00:22:36.630 --> 00:22:40.840
The second one is whether or not
what we're going to draw is opaque.

00:22:41.160 --> 00:22:44.070
If what we're drawing is opaque,
then we don't need to bother

00:22:44.130 --> 00:22:45.800
making an alpha channel.

00:22:45.880 --> 00:22:48.230
We can save a bunch of memory that way.

00:22:48.500 --> 00:22:52.620
The third option affects a
pixels-to-points conversion.

00:22:52.750 --> 00:22:54.340
It's the scale factor.

00:22:54.460 --> 00:22:58.200
So I said the first
argument was in pixels.

00:22:58.200 --> 00:22:59.460
That's only sort of correct.

00:22:59.570 --> 00:23:01.400
The third option,
you might pass two if you

00:23:01.400 --> 00:23:02.700
have a retina display.

00:23:02.810 --> 00:23:05.430
And that would mean that it
creates an image that's twice as

00:23:05.490 --> 00:23:08.540
large as that first size argument.

00:23:08.540 --> 00:23:12.240
But here I've passed zero because
that indicates just use whatever

00:23:12.280 --> 00:23:14.900
scale factor the main screen has.

00:23:14.980 --> 00:23:17.580
That's usually a sane thing to do.

00:23:17.950 --> 00:23:19.880
So once we've done our
drawing operations,

00:23:19.960 --> 00:23:22.530
we can get the image back
out of this context using

00:23:22.680 --> 00:23:27.480
UIGraphics.GetImageFromCurrentContext,
end the image context,

00:23:27.730 --> 00:23:31.900
thus cleaning up after ourselves,
and give that image back to the caller.

00:23:31.900 --> 00:23:34.690
That's exactly what
we're going to do now.

00:23:34.940 --> 00:23:38.920
I'm going to take this application
and make the drawing of those very

00:23:39.040 --> 00:23:41.890
fancy plots happen in the background.

00:23:42.080 --> 00:23:44.760
Here is CRStockCellDrawRect.

00:23:44.900 --> 00:23:46.900
As you can see, it does many things.

00:23:46.900 --> 00:23:51.900
It's creating that very beautiful
drawing of a graph for you.

00:23:51.900 --> 00:23:56.290
But what I've created is CRStockRenderer.

00:23:56.780 --> 00:23:59.350
Which,
as you'll be able to see in a moment,

00:23:59.350 --> 00:24:02.460
has the exact same implementation.

00:24:02.490 --> 00:24:05.050
Let me line them up here for you.

00:24:05.350 --> 00:24:09.320
Except instead of, as I said,
drawing into a context which core

00:24:09.400 --> 00:24:12.490
animation creates and manages,
it's going to draw into a

00:24:12.490 --> 00:24:15.990
context which we control,
which we manage,

00:24:16.070 --> 00:24:19.640
and it's going to return that UI image,
just like I showed you on

00:24:19.640 --> 00:24:21.510
a slide a few moments ago.

00:24:21.680 --> 00:24:23.770
So all this code is the same.

00:24:26.700 --> 00:24:26.940
I migrated it wholesale.

00:24:27.070 --> 00:24:29.940
What's different is
these first few lines.

00:24:29.940 --> 00:24:34.260
Here we're saying,
if we've already drawn this graph,

00:24:34.350 --> 00:24:35.450
let's not bother doing it again.

00:24:35.640 --> 00:24:40.590
Let's return that value over again,
thus caching the result.

00:24:40.730 --> 00:24:41.830
Easy enough.

00:24:43.110 --> 00:24:45.810
The second line is exactly that
begin image context with options

00:24:45.810 --> 00:24:47.490
call that I showed you in the slides.

00:24:47.600 --> 00:24:50.240
We're saying we're going to make
one that's desired size big.

00:24:50.480 --> 00:24:52.890
We're going to make it at
whatever the main screen scale is.

00:24:52.900 --> 00:24:55.180
I'm not thinking too hard about opacity.

00:24:55.230 --> 00:24:57.270
No is always safe.

00:24:57.430 --> 00:24:59.440
And then all of this is the same.

00:24:59.480 --> 00:25:01.700
We scroll down to the bottom.

00:25:01.760 --> 00:25:04.220
And as you can see,
it's matching up nicely.

00:25:04.270 --> 00:25:08.260
So all of this is lined up.

00:25:08.720 --> 00:25:12.080
And we have just three
extra lines at the bottom.

00:25:12.620 --> 00:25:15.000
First,
we pull the image out of the context

00:25:15.360 --> 00:25:20.110
and save it in an instance variable so
that we can use it later as a cache.

00:25:20.430 --> 00:25:24.140
Then we end the image context,
cleaning up after ourselves.

00:25:24.320 --> 00:25:26.690
And finally, we return that result.

00:25:27.700 --> 00:25:32.690
So now we need to make the code
which creates our cells use this

00:25:32.690 --> 00:25:37.440
renderer instead of using the
stock_cells_draw_rect implementation.

00:25:37.470 --> 00:25:42.100
Now you'll notice that cr_stock_cell,
it doesn't do anything else.

00:25:42.170 --> 00:25:44.620
So we're just going to get rid
of these two files wholesale

00:25:46.260 --> 00:25:48.590
because they're useless to us now.

00:25:50.340 --> 00:25:53.300
And so if we go back to
the TableViewController,

00:25:53.300 --> 00:25:57.160
first off, I'm gonna remove the pound
import for CRStockCell.

00:25:57.340 --> 00:25:59.350
It's no longer relevant.

00:25:59.600 --> 00:26:03.740
and scroll down to
TableViewCellForRowAtIndexPath.

00:26:03.940 --> 00:26:07.590
Here, where we were going to
make a CR stock cell,

00:26:07.680 --> 00:26:10.950
I'm instead just gonna
make a UITableView cell.

00:26:11.730 --> 00:26:16.440
And I'm going to set that image from
our renderer as the image of the

00:26:16.440 --> 00:26:19.540
image view of our table view cell.

00:26:19.620 --> 00:26:21.170
We don't need to give our
cell the stock anymore.

00:26:21.410 --> 00:26:24.200
We're going to give the
renderer the stock instead.

00:26:25.290 --> 00:26:28.820
In order to take advantage of the
caching behavior I was talking about,

00:26:28.820 --> 00:26:34.100
which will allow us to reuse the same
renderer's result over and over again,

00:26:34.180 --> 00:26:39.260
we're going to have to keep track
of which renderer is which stocks.

00:26:39.360 --> 00:26:43.820
So scrolling up again to the top of the
file where I have my instance variables,

00:26:43.860 --> 00:26:50.230
I'm going to add an NSMutable dictionary
that maps names of stocks to renderers.

00:26:50.350 --> 00:26:53.970
And I'm going to go ahead and
initialize it here in a knit with group.

00:26:54.790 --> 00:26:59.540
And now, returning to my self-errored
index path method,

00:26:59.610 --> 00:27:01.480
I'm going to start using it.

00:27:02.040 --> 00:27:05.210
First, I'll try to pull a
renderer out of that map.

00:27:05.520 --> 00:27:09.890
Say, "Do we already have a
renderer for this stock name?"

00:27:10.810 --> 00:27:12.900
If we do and it's already
finished rendering,

00:27:13.050 --> 00:27:13.530
then we're done.

00:27:13.540 --> 00:27:18.820
We just give our cells image
view that rendered graph.

00:27:19.070 --> 00:27:21.150
And it's just like before.

00:27:21.310 --> 00:27:24.090
But if the renderer
hasn't already rendered,

00:27:24.250 --> 00:27:26.480
we have a little more work to do.

00:27:27.290 --> 00:27:31.280
First, there's the question of,
have we already made a renderer?

00:27:31.330 --> 00:27:32.780
There's two possible states.

00:27:32.850 --> 00:27:36.780
We could have made a renderer
which hasn't finished yet,

00:27:36.830 --> 00:27:41.020
or we could have not already
made a renderer for the stock.

00:27:41.740 --> 00:27:44.040
First, we're going to consider the
case where we haven't already

00:27:44.040 --> 00:27:45.140
made a renderer for this stock.

00:27:45.260 --> 00:27:47.070
This stock is new.

00:27:47.650 --> 00:27:53.100
So we're just gonna allocate one of these
CRStockRenderers and give it our stock.

00:27:53.100 --> 00:27:56.770
We'll store that renderer in this map.

00:27:57.060 --> 00:28:01.110
And then we're going to ask it
to give us that rendered graph,

00:28:01.110 --> 00:28:06.540
but we'll ask it to do that
on our own NSOperation queue,

00:28:06.560 --> 00:28:08.580
not the main queue.

00:28:08.880 --> 00:28:10.840
So as we're executing code here,
we're just going to breeze

00:28:10.840 --> 00:28:12.500
right by these lines.

00:28:12.730 --> 00:28:14.200
Keep on going.

00:28:14.260 --> 00:28:18.710
Because this work, the expensive work,
is going to happen on our own queue.

00:28:18.920 --> 00:28:22.770
And just like before,
once we've got that rendered image,

00:28:22.790 --> 00:28:26.990
we don't update the cell's image
view on that background queue.

00:28:27.260 --> 00:28:32.430
We update the cell's image view on the
main queue so as not to fight with UIKit.

00:28:32.630 --> 00:28:35.540
We say cell, image view, set image,
rendered image,

00:28:35.540 --> 00:28:37.930
and we do that on the main queue.

00:28:38.770 --> 00:28:42.090
Now, regardless of whether we already
have a renderer starting for

00:28:42.090 --> 00:28:47.720
this particular stock or not,
we can set a placeholder image

00:28:48.090 --> 00:28:52.700
on our cell's image view while
that stock renderer is happening.

00:28:52.780 --> 00:28:56.460
What exactly makes sense for your
application will differ by purpose.

00:28:56.610 --> 00:29:00.460
Here I've just done a much simpler,
faster implementation of the same

00:29:00.460 --> 00:29:04.830
rendering path that can complete
very quickly so that it'll give a

00:29:04.860 --> 00:29:09.300
smooth scrolling while that rendering
is happening in the background.

00:29:10.090 --> 00:29:11.690
So here,
I'm getting the placeholder image

00:29:11.700 --> 00:29:14.470
of a particular size and putting
that on our cells image view

00:29:14.790 --> 00:29:18.320
while on our background queue,
we're performing the

00:29:18.380 --> 00:29:19.460
more complex rendering.

00:29:19.670 --> 00:29:23.760
So now if I run,
we see that I can scroll smoothly

00:29:24.010 --> 00:29:25.930
while stuff is rendering.

00:29:27.400 --> 00:29:32.340
And we're at 60 frames a second,
which is fantastic.

00:29:32.370 --> 00:29:34.970
There's just one other thing
that I want to show you.

00:29:35.500 --> 00:29:38.940
which is that now if we go
to profile this application,

00:29:38.940 --> 00:29:43.430
and I click into mid cap
and immediately click out,

00:29:43.460 --> 00:29:46.590
this purple plot continues.

00:29:47.640 --> 00:29:51.450
It's still doing all that work
because we started up this work

00:29:51.850 --> 00:29:55.840
on our background operation queue,
but we didn't tell it to stop.

00:29:55.910 --> 00:29:58.340
We didn't tell it, "Hey,
the user's not looking at this anymore.

00:29:58.340 --> 00:29:59.800
Don't waste your time.

00:29:59.840 --> 00:30:01.800
Don't waste power."

00:30:01.940 --> 00:30:04.370
So we're going to look
at how to do that next.

00:30:04.690 --> 00:30:07.120
But before we do,
I'd like to review the concepts

00:30:07.140 --> 00:30:09.990
about rendering that we just covered.

00:30:10.200 --> 00:30:15.360
Like everything else, by default,
the rendering happens on the main queue.

00:30:16.030 --> 00:30:18.660
Your draw-rect implementation
is called on the main queue.

00:30:18.800 --> 00:30:21.400
So if your draw-rect
implementation is slow,

00:30:21.570 --> 00:30:25.150
you're slowing down the main queue
and all of the events that are

00:30:25.150 --> 00:30:29.400
processed on it-- touch events,
accelerometer events, et cetera.

00:30:29.480 --> 00:30:32.610
So just like with the data processing,
rendering can be moved out

00:30:32.610 --> 00:30:34.160
to your own queue as well.

00:30:34.310 --> 00:30:36.570
You just draw an image there.

00:30:36.980 --> 00:30:39.460
And when you're done,
you ship it back over.

00:30:39.530 --> 00:30:42.440
You can use any of the
UI graphics functions.

00:30:42.490 --> 00:30:44.160
You can use UI image methods.

00:30:44.160 --> 00:30:47.200
You can use UI Bezier path methods.

00:30:47.270 --> 00:30:50.760
But you do have to make
sure that if you say,

00:30:50.760 --> 00:30:53.550
"UI graphics begin image
context," like I was showing you,

00:30:53.700 --> 00:30:58.660
you call UI graphics end image
context in the same operation.

00:30:58.720 --> 00:31:00.650
Otherwise, the results are undefined.

00:31:00.720 --> 00:31:02.810
That's one thing to keep in mind.

00:31:03.940 --> 00:31:07.840
Finally, as before,
UI ImageView setImage is no more

00:31:07.840 --> 00:31:11.580
safe to call from a background
queue than any of the other things

00:31:11.640 --> 00:31:15.100
we've been talking about where you
could potentially fight with UIKit.

00:31:15.200 --> 00:31:19.000
So even though what you've created here
on your background queue is an image,

00:31:19.120 --> 00:31:21.700
not some data, not a string,
when you're done with it,

00:31:21.700 --> 00:31:24.750
you ship it back over to the main queue,
and you say, "Hey, main queue,

00:31:24.890 --> 00:31:29.710
I want you to be the one to
update my image view for me."

00:31:30.890 --> 00:31:32.800
Now let's talk about cancellation.

00:31:32.820 --> 00:31:35.980
Not keeping more balls in
the air than we have to.

00:31:37.210 --> 00:31:41.070
If we have a situation like this
and the user navigates away from the

00:31:41.070 --> 00:31:45.860
set of stocks that we're looking at,
we would like to not do any of this work.

00:31:46.460 --> 00:31:50.600
There's a method that we can call
that will do something like just that,

00:31:50.640 --> 00:31:55.160
called
NSOperationQueueCancelAllOperations.

00:31:55.350 --> 00:31:59.480
And that will blow away not all
of the operations on the queue,

00:31:59.520 --> 00:32:02.970
but all of the ones that
haven't started yet.

00:32:03.340 --> 00:32:05.300
So that first one is still there.

00:32:05.300 --> 00:32:09.090
And the reason for that is that
we can't possibly know if at any

00:32:09.240 --> 00:32:13.400
given point during your operation,
it's safe to just cut it off.

00:32:13.480 --> 00:32:15.610
Because most of the time it isn't.

00:32:15.810 --> 00:32:19.840
So that operation keeps
running until it completes,

00:32:19.840 --> 00:32:22.600
which might be fine
for a small operation.

00:32:22.720 --> 00:32:26.040
But if it was more convenient for you
to set up your operations like this,

00:32:26.110 --> 00:32:29.200
where you've got one really big one,

00:32:29.670 --> 00:32:33.500
Then now you're in trouble because
you say cancel all operations.

00:32:33.550 --> 00:32:36.340
And what you ended up
canceling was the useless,

00:32:36.340 --> 00:32:41.560
tiny, incredibly fast operation,
not the one you actually care about.

00:32:42.220 --> 00:32:44.820
So we have a solution for that, too.

00:32:45.070 --> 00:32:51.180
We can say in our operation
when it's safe to cancel me.

00:32:51.710 --> 00:32:56.060
There's a piece of API that you're going
to use called NSOperationIsCancelled.

00:32:56.300 --> 00:32:59.100
But first I need to introduce
what NSOperation is,

00:32:59.400 --> 00:33:02.600
because right now we've just been
talking about NSOperationQueues.

00:33:02.600 --> 00:33:05.100
So far we've been doing
work that looks like this.

00:33:05.250 --> 00:33:09.390
We've been saying,
"Queue add operation with block."

00:33:09.660 --> 00:33:12.360
But that's actually just
a convenience method.

00:33:12.610 --> 00:33:16.150
It's a shorthand for this longhand.

00:33:16.590 --> 00:33:20.680
You can actually explicitly
create an NSBlock operation,

00:33:20.680 --> 00:33:24.250
which is a kind of operation,
and give it some work to do.

00:33:24.260 --> 00:33:28.150
And then put that block
operation on your queue.

00:33:28.260 --> 00:33:33.140
So now, if we have something like this,
where we're going to loop over and over

00:33:33.140 --> 00:33:36.510
and over again a bunch of pieces of data,
and process each of them,

00:33:36.510 --> 00:33:39.260
because maybe it was convenient
to set things up this way,

00:33:39.530 --> 00:33:43.260
then in the middle of our loop,
whenever we know it's safe to break out,

00:33:43.260 --> 00:33:47.090
we can see, hey, have we been canceled?

00:33:47.420 --> 00:33:50.640
If we have, we can break out,
potentially doing some

00:33:50.700 --> 00:33:51.860
cleanup if we need to.

00:33:51.860 --> 00:33:54.780
We can close any transactions
that might need to be closed.

00:33:54.910 --> 00:33:59.780
We can make everything happy
and avoid unneeded work.

00:33:59.800 --> 00:34:01.990
There's just one catch here.

00:34:02.260 --> 00:34:05.640
Which is that we've just
created a reference cycle.

00:34:05.710 --> 00:34:09.010
And I want to review what this means
for those of you who aren't familiar,

00:34:09.040 --> 00:34:14.580
because this issue will come up a
lot when using the NSOperation APIs.

00:34:14.720 --> 00:34:18.310
So our queue,
because our operation is on the queue,

00:34:18.490 --> 00:34:22.480
has a strong reference to that operation.

00:34:23.070 --> 00:34:26.070
And the operation, of course,
has a strong reference to the block which

00:34:26.070 --> 00:34:28.930
contains the work for that operation.

00:34:29.010 --> 00:34:32.800
But in that block,
we've referenced the operation.

00:34:32.890 --> 00:34:35.360
And in Objective-C,
when you create a block

00:34:35.700 --> 00:34:38.160
which references an object,

00:34:38.290 --> 00:34:42.540
The block gains a strong reference
to the referenced object,

00:34:42.650 --> 00:34:45.890
which means the operation
references the block,

00:34:45.890 --> 00:34:48.580
and the block references the operation.

00:34:49.160 --> 00:34:52.000
This creates an object cycle
that will never be cleaned up

00:34:52.080 --> 00:34:53.850
without external intervention.

00:34:54.150 --> 00:34:58.890
And the easiest way to deal with it
is just to create a weak reference

00:34:59.160 --> 00:35:03.910
to the operation instead and to use
that inside of your operations block

00:35:04.390 --> 00:35:08.040
rather than the strong reference,
which would create that cycle.

00:35:08.070 --> 00:35:11.040
Now you see we've got a dotted line
from the block to the operation,

00:35:11.110 --> 00:35:14.050
so we don't have that
reference cycle anymore.

00:35:14.980 --> 00:35:16.950
We've talked through the theory.

00:35:17.140 --> 00:35:19.440
Let's put it into practice.

00:35:19.520 --> 00:35:22.890
Here we've got an implementation
of viewWillAppear.

00:35:23.780 --> 00:35:27.300
Intuitively, what we want to have happen
is cancel everything,

00:35:27.300 --> 00:35:31.700
stop doing all of that wasted
work when the view disappears,

00:35:31.770 --> 00:35:36.450
when the user navigates back
to the list of stock groups.

00:35:36.640 --> 00:35:41.230
So we can just do that by
implementing viewDidDisappear.

00:35:41.800 --> 00:35:43.340
And it's a one-line implementation.

00:35:43.360 --> 00:35:48.540
After calling "super," we just say, "Hey,
Operation Queue, stop doing all that."

00:35:49.430 --> 00:35:53.380
Unfortunately, we're not quite done,
because for the sake of

00:35:53.380 --> 00:35:56.540
expediency and for the sake of
having something to demo to you,

00:35:56.660 --> 00:35:59.790
this operation is extremely long-running.

00:36:00.340 --> 00:36:03.520
: The one which we created
in the very first demo.

00:36:03.810 --> 00:36:09.570
So in every step of this operation,
we would like to be able to bail

00:36:09.990 --> 00:36:13.240
If this operation has been canceled,
if the user has navigated

00:36:13.240 --> 00:36:16.390
away from that stock listing,
we'd like to be able to say, "Hey,

00:36:16.500 --> 00:36:18.740
stop smoothing the data
for the stock listing.

00:36:18.800 --> 00:36:26.400
It doesn't matter anymore." So we know
it's safe to cancel operations here.

00:36:26.510 --> 00:36:29.700
In order to do that,
I'm going to make an explicit

00:36:29.700 --> 00:36:33.520
NSOperation rather than this
implicit one that I've made here.

00:36:33.650 --> 00:36:37.220
So I'll just alloc init
an NSBlockOperation.

00:36:38.160 --> 00:36:47.570
And I will put this same execution block,
unchanged, into this block operation.

00:36:48.360 --> 00:36:52.890
Then I will put the block
operation onto my operation queue.

00:36:52.940 --> 00:36:54.600
It's just the longhand version.

00:36:54.640 --> 00:36:57.060
It'll give us a little more power.

00:36:57.110 --> 00:36:59.620
Now from within the operation,

00:36:59.870 --> 00:37:05.870
I can say, "If the operation's canceled,
I know it's safe to return here."

00:37:06.930 --> 00:37:09.040
You might have to do some fancy cleanup.

00:37:09.140 --> 00:37:12.040
You might have to do some
special work in your own code.

00:37:12.410 --> 00:37:16.190
Here, we're just moving stocks,
and we're going to throw them all out.

00:37:16.300 --> 00:37:16.750
So it's OK.

00:37:16.760 --> 00:37:19.620
We can return here.

00:37:19.690 --> 00:37:23.300
Clang is warning us of the
same thing that I warned you.

00:37:24.420 --> 00:37:26.900
Capturing operations strongly
in this block is likely

00:37:26.900 --> 00:37:30.900
to lead to a retain cycle.

00:37:31.000 --> 00:37:32.980
Right you are, Clang.

00:37:33.100 --> 00:37:34.980
To get around that,

00:37:36.100 --> 00:37:40.600
We create a weak operation
reference and refer to that instead

00:37:41.100 --> 00:37:43.880
inside of our operation block.

00:37:44.110 --> 00:37:46.500
Now, Clang is no longer upset with us.

00:37:46.580 --> 00:37:48.340
That's always good.

00:37:49.010 --> 00:37:52.400
If we now run our application-- ah,
I should run it in the

00:37:52.520 --> 00:37:54.600
profiler so I can show you.

00:37:54.600 --> 00:37:55.390
Excellent.

00:37:55.620 --> 00:37:59.010
So here I'm going to click into mid-cap,
and then I'm going to back

00:37:59.010 --> 00:38:00.580
right out immediately.

00:38:01.850 --> 00:38:07.040
And you see that it cuts off much
more quickly than it did last time.

00:38:07.110 --> 00:38:08.590
It's just a little spike.

00:38:08.660 --> 00:38:11.500
It doesn't go on and on and on,
wasting our user's battery,

00:38:11.580 --> 00:38:14.190
wasting our user's time.

00:38:14.360 --> 00:38:15.560
And that's great.

00:38:15.640 --> 00:38:17.660
But there's one more issue.

00:38:18.910 --> 00:38:21.410
which is that if I scroll
this list really fast,

00:38:21.470 --> 00:38:22.900
you see these jump.

00:38:22.980 --> 00:38:25.980
They appear and then they change.

00:38:26.050 --> 00:38:28.280
That's a fun bug.

00:38:28.340 --> 00:38:30.890
It also has to do with cancellation.

00:38:32.010 --> 00:38:38.140
If we scroll down here to our
implementation of TableView cell

00:38:38.140 --> 00:38:38.140
for road index path,

00:38:38.670 --> 00:38:42.240
We see that the work that's happening
in the background looks like this.

00:38:42.290 --> 00:38:45.800
We're going to ask our renderer
to give us an image representing

00:38:45.800 --> 00:38:48.360
the plot for that stock.

00:38:48.400 --> 00:38:50.600
And then once we've got it,
we're going to ship that image over

00:38:50.600 --> 00:38:54.430
to the main queue and set it on
the cell which we were configuring

00:38:54.560 --> 00:38:56.960
when this method was first called.

00:38:57.550 --> 00:39:03.710
The issue here is that this method
may have been called a while ago,

00:39:03.710 --> 00:39:09.400
and this cell thing that I have selected
may not be the cell that I think it is.

00:39:09.450 --> 00:39:13.880
In particular,
if TableView cells scroll off screen,

00:39:14.100 --> 00:39:19.430
"Then they are reused
for new on-screen cells.

00:39:19.570 --> 00:39:24.460
So we may actually be setting
the plot for a stock which we

00:39:24.520 --> 00:39:25.920
don't mean to be setting it for.

00:39:25.920 --> 00:39:29.870
That is unfortunate."

00:39:31.000 --> 00:39:33.100
We're going to fix this in
two ways to be thorough,

00:39:33.100 --> 00:39:36.730
and I'm going to explain why
specifically I'm fixing it in two ways.

00:39:36.980 --> 00:39:39.950
Way number one is a
useful one to know about,

00:39:39.970 --> 00:39:46.060
and it refers to a new piece of
API in iOS 6 that I want to show you.

00:39:46.310 --> 00:39:49.710
And that is that when a table
view cell goes off screen,

00:39:49.710 --> 00:39:52.460
we want to cancel these operations.

00:39:52.960 --> 00:39:57.100
We don't need for our system to
be wasting time computing plots

00:39:57.450 --> 00:39:59.480
for a stock that's offscreen.

00:40:00.310 --> 00:40:02.320
So we're going to
cancel those operations.

00:40:02.400 --> 00:40:08.290
But we can't say
NSOperationQ cancel all operations,

00:40:08.310 --> 00:40:09.660
because we don't want to cancel them all.

00:40:09.760 --> 00:40:14.360
We want to cancel the one for the
cell which just went off screen.

00:40:14.430 --> 00:40:17.280
We want the ones for the cells
that are on screen to continue,

00:40:17.280 --> 00:40:18.800
please.

00:40:19.560 --> 00:40:22.370
In order to do that,
I need to keep track of each

00:40:22.680 --> 00:40:26.210
stock's operation separately.

00:40:27.310 --> 00:40:30.290
So I'm going to scroll back up here
to my list of instance variables

00:40:31.370 --> 00:40:33.200
and make another mutable dictionary.

00:40:33.400 --> 00:40:36.200
At this point,
you got two mutable dictionaries

00:40:36.200 --> 00:40:37.660
mapping stock names to something.

00:40:37.710 --> 00:40:40.100
If this were a real project,
you would probably create

00:40:40.150 --> 00:40:41.200
a real structure for this.

00:40:41.200 --> 00:40:44.700
But this is a demo,
and so we have two mutable dictionaries.

00:40:44.820 --> 00:40:46.690
Each of them map stock names to a thing.

00:40:46.700 --> 00:40:50.200
This one maps stock names
to rendering operations.

00:40:50.310 --> 00:40:53.950
And I'm going to instantiate it
in my designated initializer.

00:40:55.510 --> 00:41:00.860
Now, if I scroll back down here,
instead of saying, "Hey, Q,

00:41:01.040 --> 00:41:05.380
add operation with
block," I'm going to say,

00:41:05.760 --> 00:41:09.000
NSBlockOperation block
operation with block,

00:41:09.030 --> 00:41:14.000
thus making an NSBlockOperation
I can refer to.

00:41:14.000 --> 00:41:15.800
I'm going to put it on my queue.

00:41:15.970 --> 00:41:19.030
This is a little bit of a longhand form.

00:41:19.730 --> 00:41:23.850
And then I'm going to store it
in my dictionary so that I can

00:41:23.850 --> 00:41:29.580
get to it when my table view cell
goes off screen and cancel it.

00:41:31.770 --> 00:41:37.520
Before I do that,
there's one other tricky situation here.

00:41:37.760 --> 00:41:41.920
Which is that even if
I cancel my operation,

00:41:41.960 --> 00:41:45.440
this code may end up executing anyway.

00:41:45.500 --> 00:41:49.360
Like I said,
canceling an operation doesn't

00:41:49.440 --> 00:41:52.460
guarantee that that operation won't run.

00:41:52.460 --> 00:41:55.500
Because if it's already running,
we can't stop it.

00:41:55.740 --> 00:42:00.600
And furthermore, simply saying,
if not operation is canceled here,

00:42:00.600 --> 00:42:01.500
is not safe enough either.

00:42:01.500 --> 00:42:05.080
Because it could be canceled
right after we check that.

00:42:05.780 --> 00:42:09.240
So we're going to do something slightly
safer within our operation as well.

00:42:09.270 --> 00:42:13.020
Rather than saying cell image view,
where this cell could be referring

00:42:13.320 --> 00:42:19.390
to a table view cell that has now
been repurposed for some other use,

00:42:19.660 --> 00:42:24.030
I'm going to say table view cell
for row at index path with the index

00:42:24.030 --> 00:42:26.570
path that was originally passed in.

00:42:26.840 --> 00:42:29.530
So if that cell is still the
same one that I think it is,

00:42:29.530 --> 00:42:32.690
it's going to return the cell
I was initially pointing to.

00:42:32.710 --> 00:42:36.830
And if my cell is now off-screen,
it's going to return nil,

00:42:36.910 --> 00:42:39.960
which is lovely for this purpose,
because when I try to get its image view,

00:42:39.960 --> 00:42:41.600
that will return nil,
and when I try to set

00:42:41.950 --> 00:42:45.690
image on a nil variable,
nothing will happen.

00:42:48.250 --> 00:42:53.060
Now that we've done all this,
we can cancel our

00:42:53.060 --> 00:42:55.360
TableView cells operation.

00:42:55.680 --> 00:43:03.300
using a new piece of NSTableViewDelegate
API called TableViewDidEndDisplayingCell

00:43:03.420 --> 00:43:05.830
for row at index path.

00:43:06.540 --> 00:43:09.640
Whenever a TableView cell
scrolls offscreen,

00:43:09.900 --> 00:43:12.730
this method will be called,
and this is your opportunity to

00:43:12.730 --> 00:43:16.660
do any kind of cleanup that you
may-- for operations which you may

00:43:16.660 --> 00:43:18.840
have started related to that cell.

00:43:18.890 --> 00:43:22.260
If you've allocated a bunch of
side table resources for that cell,

00:43:22.310 --> 00:43:24.700
this would be a good
place to tear them down.

00:43:24.750 --> 00:43:28.980
And in this example,
if you have started up some

00:43:28.980 --> 00:43:32.160
long-running concurrent operation
associated with the cell,

00:43:32.200 --> 00:43:35.040
this would be a good place to cancel it.

00:43:35.560 --> 00:43:37.960
So here's the code to do that.

00:43:38.050 --> 00:43:42.040
First, we fetch the name of
the stock in question,

00:43:42.180 --> 00:43:46.760
and then we pull the operation for that
stock out of that dictionary I created.

00:43:46.860 --> 00:43:48.670
So we have a reference
to an NS operation.

00:43:48.710 --> 00:43:52.400
This is the task that is running,
or hopefully hasn't run yet,

00:43:52.500 --> 00:43:55.490
because if it hasn't run yet,
we can still stop it.

00:43:56.060 --> 00:43:59.350
If there is such an operation,
we're going to ask it to cancel,

00:43:59.400 --> 00:44:04.570
and then we're going to remove
that stock from this map.

00:44:06.330 --> 00:44:08.440
And that's it.

00:44:08.540 --> 00:44:13.420
So if we run our application,
and now scroll really fast

00:44:13.430 --> 00:44:15.790
once everything is here,

00:44:16.790 --> 00:44:19.820
We'll see that it doesn't
pop around anymore.

00:44:19.930 --> 00:44:22.130
Everything is happy.

00:44:22.480 --> 00:44:25.360
in the land of our application,
and that means that I'm going

00:44:25.360 --> 00:44:29.310
to get rich very quick as
soon as I get off the stage.

00:44:29.970 --> 00:44:32.880
So, we just learned some
things about cancellation.

00:44:33.100 --> 00:44:39.060
Namely, that there is a method called
NSOperationQueueCancelAllOperations.

00:44:39.110 --> 00:44:42.400
You can call that to throw out
any operations that are running--

00:44:42.420 --> 00:44:46.600
or that have not yet run on
a particular operation queue.

00:44:46.850 --> 00:44:50.600
You can also cancel a specific
NS operation by sending that

00:44:50.600 --> 00:44:53.390
operation a cancel method.

00:44:54.160 --> 00:44:57.770
But remember, if it's already started,
that's not good enough.

00:44:57.870 --> 00:44:59.620
That's not going to cut it off.

00:44:59.780 --> 00:45:04.400
So you can check within
your operations to see,

00:45:04.470 --> 00:45:07.340
has this operation been canceled already?

00:45:07.400 --> 00:45:10.350
There's that isCanceled
method that I showed you.

00:45:10.700 --> 00:45:13.760
You want to check that periodically
when you know it's safe.

00:45:13.820 --> 00:45:15.880
Before I go on and wrap up,
give you some more

00:45:16.000 --> 00:45:17.600
parting words of wisdom.

00:45:17.670 --> 00:45:19.920
For those of you leaving,
I do actually have some

00:45:19.920 --> 00:45:21.670
more new things to say.

00:45:30.000 --> 00:45:32.400
I want to point you to
some excellent resources.

00:45:32.400 --> 00:45:35.190
There's a gentleman named
Jake Behrens who wears plaid and

00:45:35.190 --> 00:45:36.740
who can answer your questions.

00:45:37.060 --> 00:45:38.000
He's great.

00:45:38.000 --> 00:45:41.000
There's this concurrency programming
guide that you might want to check out.

00:45:41.130 --> 00:45:44.430
It's got even more details about
some of the pitfalls that you can

00:45:44.430 --> 00:45:47.920
really run into once you start
leveraging this stuff heavily.

00:45:48.020 --> 00:45:51.000
And finally,
there's the Apple Developer Forums,

00:45:51.000 --> 00:45:52.880
which is the place where
you can help each other.

00:45:53.400 --> 00:45:59.000
There was one particular piece of
parting wisdom that I wanted to give you,

00:45:59.000 --> 00:46:03.090
which is that I've taught you
how to make these own queues,

00:46:03.090 --> 00:46:06.990
these queues of your own,
to get out of the way of the main queue.

00:46:07.110 --> 00:46:08.000
And that's great.

00:46:08.120 --> 00:46:12.000
But once your application
gets sufficiently complicated,

00:46:12.000 --> 00:46:15.000
you might want to get out of
the way not of your main queue,

00:46:15.000 --> 00:46:17.000
but of your own queues.

00:46:17.140 --> 00:46:18.990
So you can make more of these.

00:46:19.000 --> 00:46:21.060
You can make queues
and queues and queues,

00:46:21.060 --> 00:46:22.000
and they can point to each other.

00:46:22.000 --> 00:46:24.000
They can have dependencies on each other.

00:46:24.160 --> 00:46:27.990
This whole thing can get
very gnarly very fast.

00:46:28.030 --> 00:46:32.000
And in UIKit land, we've dealt with some
nasty consequences of that.

00:46:32.000 --> 00:46:37.000
So a parting word of wisdom that I wanted
you all to take with you had to do with

00:46:37.000 --> 00:46:41.000
that scheme that we had for shipping
data back over to the main queue.

00:46:41.000 --> 00:46:44.940
That is a useful philosophy,
and it can be applied to your

00:46:44.940 --> 00:46:47.000
own sets of queues as well.

00:46:47.000 --> 00:46:50.000
It's typically called the
share nothing philosophy.

00:46:50.190 --> 00:46:53.010
And so if you've got your
own sets of queues which are

00:46:53.010 --> 00:46:56.060
competing over a piece of data,
like they're both going

00:46:56.060 --> 00:46:58.260
to be modifying it,
they're both going to be

00:46:58.520 --> 00:47:02.190
reading it and writing it,
then you might want to use that same

00:47:02.350 --> 00:47:07.660
strategy that we used for UIKit's
queue versus your queue and say,

00:47:07.660 --> 00:47:11.830
"Hey, this one queue I've made,
this is the canonical owner

00:47:11.830 --> 00:47:14.000
of this piece of data.

00:47:14.000 --> 00:47:18.000
And so on this other queue I've made,
and maybe this third queue I've made,

00:47:18.000 --> 00:47:22.000
when I want to modify that piece of data,
when I've got some new value for it,

00:47:22.080 --> 00:47:26.000
I'm not going to just modify it
on that second or third queue,

00:47:26.010 --> 00:47:29.000
but I'm going to have to
update it on the first queue.

00:47:29.000 --> 00:47:32.000
And so I'm going to have to
modify it on the second queue,

00:47:32.000 --> 00:47:35.920
and then I'm going to have to
update it on the third queue.

00:47:36.220 --> 00:47:40.140
And so that's just as much crossing
the streams as it was for you to

00:47:40.140 --> 00:47:44.000
update your image view on a secondary
queue and then fighting with UIKit.

00:47:44.000 --> 00:47:46.990
So you could say on your
second and third queue,

00:47:47.000 --> 00:47:49.460
"Hey, first queue,
I want you to do the work

00:47:49.460 --> 00:47:51.000
of updating this data.

00:47:51.000 --> 00:47:55.000
Ship the data over to the first
queue and have it do that."

00:47:55.000 --> 00:47:57.190
Have a great week at WWDC.
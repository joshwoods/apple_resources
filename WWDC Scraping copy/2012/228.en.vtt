WEBVTT

00:00:11.080 --> 00:00:12.300
Good morning.

00:00:12.340 --> 00:00:15.000
Welcome to Best Practices
for Mastering Auto Layout.

00:00:15.020 --> 00:00:22.900
I haven't even done anything yet.

00:00:22.900 --> 00:00:24.350
It's for OS X and iOS.

00:00:24.460 --> 00:00:25.810
My name is Peter Ammon.

00:00:25.970 --> 00:00:28.790
I'm an engineer on the AppKit team.

00:00:29.630 --> 00:00:32.400
will be showing you Auto Layout,
which is a way to make your

00:00:32.400 --> 00:00:35.030
layouts simpler to write,
simpler to modify,

00:00:35.110 --> 00:00:36.830
and easier to understand.

00:00:36.980 --> 00:00:39.820
The point of this session is to
raise you from the level of someone

00:00:39.820 --> 00:00:44.410
with some Auto Layout familiarity
to a true Auto Layout master.

00:00:46.990 --> 00:00:51.170
As you know, Auto Layout was a feature we
introduced in Mac OS X Lion.

00:00:51.390 --> 00:00:55.020
We're very happy that we could
bring it to you in iOS 6.

00:00:55.480 --> 00:00:58.560
: This session will cover both,
and the reason it can cover both,

00:00:58.560 --> 00:01:03.200
AppKit and iOS,
is because they have identical APIs.

00:01:05.750 --> 00:01:08.390
Almost identical APIs.

00:01:08.460 --> 00:01:10.930
The most significant difference,
of course, is view.

00:01:11.360 --> 00:01:15.660
So when I say "view," you should think
NSView if you're working on AppKit and

00:01:15.660 --> 00:01:17.600
UIView if you're working on iOS 6.

00:01:17.650 --> 00:01:21.570
And any other differences I'll
call out when we reach those parts.

00:01:22.750 --> 00:01:24.090
So we'll just do a brief review.

00:01:24.210 --> 00:01:27.060
Hopefully this is stuff you already know.

00:01:27.060 --> 00:01:29.570
Auto Layout introduces
just one new class,

00:01:29.570 --> 00:01:31.460
and it's layout constraint.

00:01:32.260 --> 00:01:34.990
A constraint expresses a
geometric property of a view.

00:01:35.300 --> 00:01:38.700
For example,
this view's width is 120 points.

00:01:38.770 --> 00:01:42.090
It could also express
relationships between views.

00:01:42.280 --> 00:01:46.150
For example, foo's width is 120,
bar's width is equal to foo's width.

00:01:46.370 --> 00:01:49.220
Now bar has a width of 120 as well.

00:01:50.120 --> 00:01:52.830
and relationships have a
coefficient and a constant.

00:01:52.940 --> 00:01:56.290
So we could say that foo's width
is twice bar's width minus 20,

00:01:56.350 --> 00:01:59.230
but we could not, for example,
say that foo's width is the

00:01:59.310 --> 00:02:01.000
square root of bar's width.

00:02:02.260 --> 00:02:08.980
Now, constraints can be
equalities or inequalities,

00:02:08.980 --> 00:02:08.980
so we can say foo's
width is at least 120.

00:02:09.140 --> 00:02:11.700
and constraints have priorities.

00:02:11.720 --> 00:02:17.340
So, foo's width is 120 with a low
priority and 75 with a high priority.

00:02:17.360 --> 00:02:19.240
The 75 priority will dominate.

00:02:19.240 --> 00:02:20.660
It doesn't try to average between them.

00:02:20.660 --> 00:02:21.920
It just wins out entirely.

00:02:22.230 --> 00:02:24.900
And foo will have a width of 75.

00:02:27.120 --> 00:02:30.870
So you can create constraints in
Interface Builder with the visual format

00:02:30.870 --> 00:02:33.570
language and with the primitive API.

00:02:33.770 --> 00:02:36.090
And when you're deciding
how to create a constraint,

00:02:36.220 --> 00:02:39.340
prefer to create them in that order
because that's the easiest order.

00:02:39.340 --> 00:02:42.930
It takes the least work and
it's the least error prone.

00:02:44.010 --> 00:02:46.660
So that concludes the background review.

00:02:46.710 --> 00:02:48.820
In this session, we're going to cover
thinking and constraints.

00:02:48.950 --> 00:02:51.660
How do you adjust your thinking
for an Auto Layout world?

00:02:51.760 --> 00:02:54.240
We'll talk about debugging
constraint-based layouts.

00:02:54.310 --> 00:02:55.900
What happens when something goes wrong?

00:02:56.160 --> 00:03:01.940
And lastly,
we'll really start to leverage

00:03:01.940 --> 00:03:01.940
constraints in Auto Layout and get
some mileage out of this new feature.

00:03:03.450 --> 00:03:06.250
So thinking and constraints.

00:03:06.300 --> 00:03:09.110
Now, you can use Auto Layout just like
you've been using springs and

00:03:09.110 --> 00:03:12.850
struts by specifying constraints
for the offset and width.

00:03:13.000 --> 00:03:16.800
But if you are able to shift your
thinking to a declarative type of layout,

00:03:16.840 --> 00:03:17.910
it will be far easier.

00:03:18.110 --> 00:03:20.990
And we'll see an example
of that right now.

00:03:22.560 --> 00:03:24.960
Let's say you have like
a keyboard type view.

00:03:24.960 --> 00:03:28.550
You have a bunch of keys that are
all the same width and height,

00:03:28.550 --> 00:03:31.770
and they're in this container view,
and there's some padding

00:03:31.770 --> 00:03:34.320
between the keys,
and the container view

00:03:34.320 --> 00:03:35.800
has an overall width.

00:03:35.930 --> 00:03:39.840
So how would you implement this
layout with springs and struts?

00:03:40.320 --> 00:03:43.740
Well, you would start by computing some
sort of expression for the width.

00:03:43.950 --> 00:03:50.850
So you'd say that the width of a
key is equal to the total width

00:03:50.850 --> 00:03:50.850
divided by the number of keys
minus some fix-up for the padding.

00:03:51.370 --> 00:03:53.800
And then for each key,
you might compute an offset,

00:03:53.830 --> 00:03:56.400
which is going to be the key index
times the key width plus some

00:03:56.550 --> 00:03:58.140
sort of fix-up for the padding.

00:03:58.250 --> 00:04:00.540
And I've written plenty
of code like this.

00:04:00.540 --> 00:04:01.940
You probably have as well.

00:04:02.040 --> 00:04:04.740
And it works,
but it's not easy to tell by looking

00:04:04.850 --> 00:04:06.540
at the code what it's actually doing.

00:04:06.540 --> 00:04:10.450
It's hard to revisit this and say, "Oh,
this is laying out a keyboard-type

00:04:10.450 --> 00:04:16.960
view." So how might you
address this with Auto Layout?

00:04:18.710 --> 00:04:23.300
You can start by establishing
width constraints for every key.

00:04:23.300 --> 00:04:25.520
And we could use the same expression.

00:04:25.620 --> 00:04:28.480
So you'd say that the key width is
the overall container width divided by

00:04:28.480 --> 00:04:30.860
the number of keys minus some padding.

00:04:30.860 --> 00:04:34.660
Now, for the offset,
instead of calculating the offset,

00:04:34.660 --> 00:04:36.070
you could just string the views together.

00:04:36.170 --> 00:04:39.430
So you could say, "Oh,
Q's offset is equal to its

00:04:39.430 --> 00:04:42.200
container's left edge plus padding.

00:04:42.200 --> 00:04:47.960
W's offset is equal to Q's max
X edge plus padding," and et cetera.

00:04:47.960 --> 00:04:49.500
And you string all the views together.

00:04:49.570 --> 00:04:53.090
So this is better because
these are relationships.

00:04:53.190 --> 00:04:56.160
So if the container width changes,
you don't have to do this work again.

00:04:56.160 --> 00:04:58.100
It will do it for you automatically.

00:04:58.100 --> 00:05:01.700
The width of the key is related
to the width of the container.

00:05:02.180 --> 00:05:04.060
But this is still not great, right?

00:05:04.060 --> 00:05:06.100
There's still this sort of
confusing expression there.

00:05:06.100 --> 00:05:09.060
It's hard to tell what that's doing.

00:05:09.180 --> 00:05:12.780
So here's how an Auto Layout master
would approach the same problem.

00:05:13.520 --> 00:05:15.700
If you listen carefully,
I told you at the beginning

00:05:15.920 --> 00:05:17.270
exactly what constraints we need.

00:05:17.600 --> 00:05:19.200
Every key has the same width.

00:05:19.340 --> 00:05:23.350
So let's just establish constraints that
say Q's width is equal to W's width,

00:05:23.480 --> 00:05:26.710
W's width is equal to E's width, etc.

00:05:26.990 --> 00:05:30.260
And the last step is to add a
constraint at the right edge,

00:05:30.260 --> 00:05:34.380
binding the rightmost key to
the right edge of the container.

00:05:34.590 --> 00:05:37.360
When you add that last constraint,
it's going to unfold all

00:05:37.360 --> 00:05:41.200
the views like an accordion,
and you'll get exactly this layout.

00:05:41.300 --> 00:05:44.100
And notice that there's
no real calculation here.

00:05:44.100 --> 00:05:47.900
It's just very simple relationships,
which I think is a hallmark.

00:05:47.920 --> 00:05:51.520
When you reach that state,
you know you found a good layout.

00:05:51.770 --> 00:05:53.030
Also notice there's no rounding.

00:05:53.100 --> 00:05:56.510
We didn't talk about what happens
if the number of keys doesn't evenly

00:05:56.880 --> 00:05:59.240
divide the amount of space available.

00:05:59.320 --> 00:06:02.190
But with Auto Layout,
it will handle that for you.

00:06:03.590 --> 00:06:07.570
So I'm going to give you an example,
or a demo rather, of a layout very much

00:06:07.570 --> 00:06:09.890
like this in a real app.

00:06:12.060 --> 00:06:14.280
This is an app called Opposite Subtract.

00:06:14.350 --> 00:06:16.500
It's just a very simple game.

00:06:16.500 --> 00:06:18.800
The point is you have a bunch
of letters that -- by the way,

00:06:18.800 --> 00:06:21.590
everything you see here is
done entirely with Auto Layout,

00:06:21.650 --> 00:06:22.500
naturally.

00:06:22.500 --> 00:06:25.990
And the idea of the game is to
find the word which is the opposite

00:06:26.070 --> 00:06:28.920
of the word in the upper left
in as little time as possible.

00:06:29.150 --> 00:06:31.600
And every time -- every few seconds,
your score goes up.

00:06:31.820 --> 00:06:35.030
And when you get the correct word,
your score goes down, you know,

00:06:35.030 --> 00:06:36.340
because opposites.

00:06:36.340 --> 00:06:38.640
So the opposite of warm is cool.

00:06:38.680 --> 00:06:40.200
So I got that right.

00:06:40.250 --> 00:06:41.350
Explodes.

00:06:41.350 --> 00:06:43.940
The opposite of big is little.

00:06:44.260 --> 00:06:44.620
T, T.

00:06:45.040 --> 00:06:47.590
You can drag these around a little.

00:06:47.680 --> 00:06:48.260
Little.

00:06:48.260 --> 00:06:50.400
I got that right and it explodes.

00:06:50.530 --> 00:06:56.530
So you see that the view at the bottom
here -- I'm calling it the rack view

00:06:56.700 --> 00:07:02.490
-- has a layout very similar to the
key view we saw before in the slides.

00:07:02.880 --> 00:07:05.270
Notice that when I start adding views,
it's going to start shrinking

00:07:05.600 --> 00:07:08.850
to accommodate the extra space,
but eventually it's going

00:07:08.970 --> 00:07:11.720
to not let it get too small,
and it's just going to start

00:07:11.860 --> 00:07:13.460
clipping off the right side.

00:07:13.630 --> 00:07:15.270
Like that.

00:07:15.830 --> 00:07:16.800
You can add them back.

00:07:16.800 --> 00:07:20.910
You'll also notice that they
will try to grow with the view--

00:07:20.910 --> 00:07:20.910
let me get rid of some more.

00:07:21.620 --> 00:07:24.000
The keys will try to grow with
the view and shrink with it,

00:07:24.000 --> 00:07:26.260
but they also have a minimum size,
and they start clipping,

00:07:26.530 --> 00:07:27.740
and a maximum size.

00:07:27.870 --> 00:07:30.300
And when they reach the maximum size,
they stay centered.

00:07:30.390 --> 00:07:33.060
So it looks like a very simple view,
but there's actually a lot of sort

00:07:33.060 --> 00:07:37.560
of sophisticated edge cases and
aspects of the layout going on here.

00:07:37.740 --> 00:07:41.400
So allow me to show you
how I implemented that.

00:07:41.920 --> 00:07:50.090
The pile up here,
I'm calling it the pile,

00:07:50.090 --> 00:07:50.090
and the rack down here are
both subclasses of a view

00:07:50.090 --> 00:07:50.090
called LetterContainer.

00:07:50.660 --> 00:07:54.240
: Letter container has a method,
add letter view.

00:07:54.340 --> 00:07:56.960
And when you add a letter view to it,
the top or the bottom,

00:07:57.020 --> 00:08:02.060
it's going to add it as a sub view,
add an object to its own internal store.

00:08:02.130 --> 00:08:04.410
And then it's going to remove all
the constraints it's established

00:08:04.940 --> 00:08:07.260
for all of its letter views,
get rid of them,

00:08:07.340 --> 00:08:10.240
and call set these update constraints.

00:08:10.930 --> 00:08:14.470
Now, the next turn of the run loop,
constraints will be updated.

00:08:14.470 --> 00:08:17.190
I'll show you the
constraints we actually add.

00:08:17.720 --> 00:08:19.830
So we pinned the first
view to the left edge.

00:08:20.040 --> 00:08:22.650
That's why the P is over on the left.

00:08:23.330 --> 00:08:26.550
We pin the last view to
the right edge weakly,

00:08:26.550 --> 00:08:31.350
so we add objects from array with
constraints that say the last view

00:08:31.350 --> 00:08:35.620
is pinned to the right edge of a
super view with a padding of at

00:08:35.620 --> 00:08:40.890
least 20 and a priority of 450,
which is a low priority.

00:08:42.450 --> 00:08:44.080
We make a constraint that says
the first letter view is the

00:08:44.170 --> 00:08:45.870
same height as the container,
but weakly so.

00:08:46.070 --> 00:08:50.520
So that's why it tries to be
the same height as the rack.

00:08:51.170 --> 00:08:54.760
We do that by saying that the
height is equal to the height of

00:08:54.760 --> 00:08:58.450
the container times 1 plus 20.

00:08:58.550 --> 00:09:01.210
We do that with a weak priority as well.

00:09:01.890 --> 00:09:05.430
Here we center the letter
vertically in the container.

00:09:05.430 --> 00:09:11.070
So we say that center Y is equal to
the center Y of the container view.

00:09:11.360 --> 00:09:15.000
And here's where we establish constraints
that make all the views equal width,

00:09:15.000 --> 00:09:17.180
like we saw in the slides.

00:09:17.470 --> 00:09:20.570
The other thing I wanted to show you,
we didn't say everything

00:09:20.570 --> 00:09:23.990
about the height of the views,
but in the letter view itself,

00:09:24.100 --> 00:09:27.700
when it instantiates itself,
it establishes a constraint that says,

00:09:27.840 --> 00:09:34.380
"My width is equal to my
height," and also establishes

00:09:34.380 --> 00:09:34.380
the min width and the max width.

00:09:35.000 --> 00:09:38.630
So this idea that different aspects
of the program can be responsible

00:09:38.630 --> 00:09:41.490
for the layout is something
we're going to be revisiting.

00:09:46.920 --> 00:09:49.290
So the layout became
distributed in this app.

00:09:49.300 --> 00:09:53.000
Another component of the app responsible
for the layout of these views is the

00:09:53.580 --> 00:09:55.860
component that does the animation.

00:09:56.050 --> 00:09:58.360
I think of it -- if you can
decompose your layouts into

00:09:58.440 --> 00:10:02.370
components where each component
can own an aspect of the layout,

00:10:02.520 --> 00:10:06.190
that's how you can get
a really clean layout.

00:10:06.550 --> 00:10:08.980
I think of it kind of like retain,
release, or arc,

00:10:09.010 --> 00:10:12.100
where the lifetime of an object
is sort of a global problem.

00:10:12.100 --> 00:10:15.500
It's kind of a hard problem,
but each owner of an object can

00:10:15.500 --> 00:10:23.770
contribute to that lifetime,
and the overall lifetime is established

00:10:23.770 --> 00:10:23.770
by looking at all the interested parties.

00:10:24.880 --> 00:10:27.400
So we saw that the Q view said,
"I'm square,

00:10:27.400 --> 00:10:31.390
my width is equal to my height,"
and its super view said,

00:10:31.600 --> 00:10:34.620
"You're the same height as me,
and also you're

00:10:34.620 --> 00:10:37.360
vertically centered in me,
and that's sufficient to

00:10:37.460 --> 00:10:39.020
establish the layout."

00:10:41.190 --> 00:10:43.210
So let's say you've figured
out the layout you want,

00:10:43.240 --> 00:10:46.290
but now you want to convert from
springs and struts to this new layout.

00:10:46.490 --> 00:10:49.860
So how do you go about
converting an existing app?

00:10:50.530 --> 00:10:52.150
Well, the first step is you
want to plan your attack.

00:10:52.300 --> 00:10:55.540
Do you want to just convert
part of a view or one view?

00:10:55.540 --> 00:10:58.230
Well, you can use Auto Layout just
in the part you need it,

00:10:58.400 --> 00:11:02.210
which is convenient, but you can also,
if you do a full conversion,

00:11:02.210 --> 00:11:03.770
it will pay off later.

00:11:05.320 --> 00:11:08.360
The next step is to turn on
Auto Layout in your NIBs.

00:11:08.430 --> 00:11:09.280
That's easy to do.

00:11:09.280 --> 00:11:11.500
It's in the leftmost tab,
the NIB inspector.

00:11:11.500 --> 00:11:14.600
There's a check box, use Auto Layout.

00:11:15.410 --> 00:11:16.300
There it is.

00:11:16.300 --> 00:11:20.610
It's a per nib property,
not a per window or per view property.

00:11:22.080 --> 00:11:24.250
When you check the checkbox,
Interface Builder will

00:11:24.250 --> 00:11:26.950
create the constraints that
reflect your existing layout.

00:11:27.030 --> 00:11:30.200
But what it will not know how
to do is how that layout should

00:11:30.200 --> 00:11:33.700
change if your screen rotates
or if you resize the window.

00:11:33.840 --> 00:11:37.600
So you might want to inspect the
constraints Interface Builder has

00:11:37.600 --> 00:11:39.790
made and then add to or modify them.

00:11:40.800 --> 00:11:44.040
The next step is to find every place
where you create a view and turn

00:11:44.040 --> 00:11:46.160
off auto resizing mask translation.

00:11:46.160 --> 00:11:48.880
This is something you heard
about in the first session.

00:11:49.080 --> 00:11:51.220
You have to call
setTranslatesAutoResizingMask and the

00:11:51.220 --> 00:11:55.650
constraints "no," and that means I want
to use only Auto Layout for this view.

00:11:55.740 --> 00:11:58.060
And if you forget to do this,
you'll figure it out pretty quickly

00:11:58.110 --> 00:12:01.770
because you are likely to get
unsatisfiable constraint errors.

00:12:01.860 --> 00:12:04.180
We'll see some of those later.

00:12:07.080 --> 00:12:10.410
Now you want to identify places where
your existing code performs layout.

00:12:10.570 --> 00:12:13.700
So layout subviews and
iOS is a good candidate,

00:12:13.750 --> 00:12:18.340
or any sort of call to set frame or
set frame size or set frame origin.

00:12:18.720 --> 00:12:22.230
These are all places where your
existing code is doing layout,

00:12:22.230 --> 00:12:23.760
and they all have to go.

00:12:23.890 --> 00:12:26.190
But what do you put there instead?

00:12:27.550 --> 00:12:30.360
Well, what you don't want to do is
just take the code and try

00:12:30.370 --> 00:12:33.500
to replicate what it does.

00:12:33.840 --> 00:12:36.920
Instead, you want to try to understand
the layout that the existing

00:12:36.920 --> 00:12:40.340
code is an implementation of and
recreate that with Auto Layout.

00:12:40.440 --> 00:12:42.030
And the hope is that
by using Auto Layout,

00:12:42.130 --> 00:12:43.340
this will become simpler.

00:12:43.410 --> 00:12:47.910
The idea of Auto Layout is to
simplify making sophisticated layouts.

00:12:48.230 --> 00:12:51.500
So it's great if you can
replace it with nothing.

00:12:51.570 --> 00:12:54.000
If you're working around a
limitation of springs and struts,

00:12:54.240 --> 00:12:56.000
maybe Auto Layout can
handle that directly.

00:12:56.100 --> 00:13:04.220
Or if the existing code is
implementing a relationship that

00:13:04.220 --> 00:13:04.220
Auto Layout can express directly,
then you can just use

00:13:04.220 --> 00:13:04.220
Auto Layout to express that.

00:13:04.990 --> 00:13:10.330
But if you have to add some constraints,
well, then naturally you should do so.

00:13:12.690 --> 00:13:15.490
So you want to think about which
component should own each constraint.

00:13:15.520 --> 00:13:18.800
As we saw,
the letter view owns its aspect ratio,

00:13:18.870 --> 00:13:22.190
but its super view owns its
positioning and its height.

00:13:23.410 --> 00:13:26.910
And you want to consider centralizing
all this work in update constraints.

00:13:27.040 --> 00:13:30.020
That will keep your code focused,
all your Auto Layout stuff

00:13:30.020 --> 00:13:31.170
will be in one place.

00:13:31.230 --> 00:13:34.340
We saw that with the
letter rack view before.

00:13:36.510 --> 00:13:38.400
And of course,
the last step is to test it.

00:13:38.400 --> 00:13:40.600
Make sure you have the layout you want.

00:13:40.680 --> 00:13:44.170
If you see log messages,
you may have unsatisfiability.

00:13:44.170 --> 00:13:48.290
If you see views that jump or disappear,
you may have ambiguity.

00:13:48.400 --> 00:13:51.050
When you see those issues,
you just need to fix them.

00:13:51.630 --> 00:13:53.800
So how do you fix them?

00:13:53.920 --> 00:13:56.870
That brings me to debugging.

00:13:57.070 --> 00:14:00.000
So what can go wrong
in an Auto Layout app?

00:14:00.170 --> 00:14:01.720
Well,
one problem is that you have constraints

00:14:01.720 --> 00:14:05.640
that don't provide enough information,
and that's called ambiguity.

00:14:05.700 --> 00:14:07.990
Sort of the opposite problem is
that you have constraints that

00:14:08.100 --> 00:14:11.890
provide conflicting information,
and that's unsatisfiability.

00:14:12.040 --> 00:14:15.400
And a third type of problem is
that constraints that are not

00:14:15.430 --> 00:14:19.190
ambiguous and are satisfiable,
but that are satisfied in

00:14:19.190 --> 00:14:20.990
ways you may not expect.

00:14:21.080 --> 00:14:23.490
We'll see examples of all of these.

00:14:24.110 --> 00:14:26.350
And keep in mind that when
you use Interface Builder,

00:14:26.350 --> 00:14:28.300
it will address these problems for you.

00:14:28.300 --> 00:14:30.700
It will not let you create
unsatisfiable constraints,

00:14:30.770 --> 00:14:33.390
and it will not let you
create an ambiguous layout.

00:14:33.530 --> 00:14:36.500
So this is just one of many reasons
why you should prefer Interface

00:14:36.500 --> 00:14:38.700
Builder when doing Auto Layout.

00:14:38.750 --> 00:14:41.600
And keep in mind that you might think,
"I can't use Interface Builder

00:14:41.600 --> 00:14:43.590
because I'm going to need to
add or remove a constraint,

00:14:43.600 --> 00:14:46.960
or I need to adjust the constraints
constant." But you still can.

00:14:46.960 --> 00:14:50.800
You can reference the
constraint with an outlet.

00:14:50.930 --> 00:14:53.940
So, ambiguity.

00:14:56.110 --> 00:14:59.630
Ambiguity happens when there's
multiple layouts that all satisfy

00:14:59.640 --> 00:15:01.760
the constraints equally well.

00:15:01.920 --> 00:15:06.830
So, for example,
in our key view in the slides,

00:15:06.960 --> 00:15:09.770
maybe the layout was this
or maybe the layout is that.

00:15:09.930 --> 00:15:15.510
We didn't say anything about
the vertical positioning or the

00:15:15.510 --> 00:15:15.510
vertical size of any of the views.

00:15:17.440 --> 00:15:20.620
And a common symptom is that your views
will seem to jump between different

00:15:20.620 --> 00:15:24.170
layouts that all satisfy the constraints,
or they'll just disappear entirely,

00:15:24.310 --> 00:15:27.920
which usually means they've
jumped to size zero.

00:15:30.700 --> 00:15:33.000
When this happens,
it usually means you need

00:15:33.160 --> 00:15:34.510
to add more constraints.

00:15:34.590 --> 00:15:39.500
Just like a rect has four properties,
X origin, Y origin, width, and height,

00:15:39.500 --> 00:15:41.940
you need to specify four
properties of every view.

00:15:41.940 --> 00:15:44.290
But they don't have to be
those same four properties.

00:15:44.290 --> 00:15:47.000
You could specify the center
X and the width or the min

00:15:47.000 --> 00:15:49.680
X or max X or max X and width.

00:15:49.930 --> 00:15:52.580
Any combination will work.

00:15:53.620 --> 00:15:55.800
And inequalities are usually not enough.

00:15:55.920 --> 00:15:59.040
So just because I said that this
view's width is at least 20,

00:15:59.040 --> 00:16:02.000
that doesn't mean it's going
to try to be exactly 20.

00:16:02.000 --> 00:16:06.230
It's just as happy being 20
as it is 40 or a million.

00:16:06.410 --> 00:16:11.160
So inequalities cannot fully
specify the layout in most cases.

00:16:13.400 --> 00:16:16.520
Now, sometimes ambiguity can
come about because you have

00:16:16.520 --> 00:16:19.480
priorities that are equal,
and it does not know which

00:16:19.480 --> 00:16:21.290
constraint should satisfy.

00:16:21.500 --> 00:16:26.030
For example, if we say that Views Width
is 24 with a priority of 500,

00:16:26.030 --> 00:16:29.300
and Views Width is at least
30 with the same priority,

00:16:29.300 --> 00:16:33.300
well, it can't satisfy both because
24 is not at least 30.

00:16:33.300 --> 00:16:35.290
And they have equal priorities,
so it doesn't know which

00:16:35.450 --> 00:16:36.300
constraint to prefer.

00:16:36.300 --> 00:16:39.210
This is a case where you have ambiguity.

00:16:40.700 --> 00:16:44.140
So if we were to raise the
priority of the inequality to,

00:16:44.140 --> 00:16:49.180
say, 525, it still can't satisfy both,
but now it knows which one to prefer,

00:16:49.180 --> 00:16:52.120
so it's going to satisfy
the inequality first.

00:16:52.240 --> 00:16:54.970
After that,
it's going to try to satisfy the

00:16:54.970 --> 00:16:57.300
equality as close as possible.

00:16:58.110 --> 00:17:02.110
So there is no ambiguity here,
and the resulting width

00:17:02.220 --> 00:17:06.890
is going to be 30,
because 30 is the number which

00:17:06.910 --> 00:17:10.280
is at least 30 and closer
to 24 than any other number.

00:17:12.870 --> 00:17:14.790
So if you want to know if
you have ambiguous layout,

00:17:14.850 --> 00:17:18.490
you can just ask your view,
"has ambiguous layout?"

00:17:18.760 --> 00:17:20.690
And if you want to know
what's ambiguous about it,

00:17:20.690 --> 00:17:22.650
you can call
Exercise Ambiguity in Layout,

00:17:22.650 --> 00:17:24.740
and what that will do,
will change the frame to

00:17:24.880 --> 00:17:27.700
another layout that satisfies
the constraints equally well.

00:17:27.820 --> 00:17:31.160
You can also call Visualize
Constraints on OS X only.

00:17:31.330 --> 00:17:33.770
This will give you sort of
a purple overlay window,

00:17:33.850 --> 00:17:38.700
which will tell you if you have ambiguity
and allow you to exercise it in that way.

00:17:38.700 --> 00:17:40.370
And by the way,
these functions are really

00:17:40.370 --> 00:17:42.700
useful for debugging,
but they're only for debugging.

00:17:42.700 --> 00:17:45.700
You should never have a need to
call them in production code.

00:17:48.610 --> 00:17:50.660
So that covers ambiguity.

00:17:50.710 --> 00:17:54.250
Let's talk about the other problem,
unsatisfiability.

00:17:56.860 --> 00:18:00.060
A layout is unsatisfiable when
there's no layout that can satisfy

00:18:00.150 --> 00:18:03.480
all the required constraints,
and the keyword there is "required."

00:18:03.830 --> 00:18:07.500
Only required constraints can
contribute to unsatisfiability.

00:18:07.620 --> 00:18:09.870
And keep in mind that constraints
are required by default,

00:18:09.870 --> 00:18:13.320
so if you create a constraint with the
base API or the visual format language

00:18:13.400 --> 00:18:17.850
and you don't specify a priority,
it's going to be required.

00:18:20.760 --> 00:18:24.120
And keep in mind that sizes are
required to be at least zero,

00:18:24.120 --> 00:18:25.680
even if you never establish a constraint.

00:18:25.700 --> 00:18:30.160
So if it's possible that the layout could
be satisfied with a width of negative 10,

00:18:30.240 --> 00:18:34.900
that's not something that will allow --
that will be an unsatisfiability case.

00:18:36.490 --> 00:18:38.770
Now,
when you get an unsatisfiable layout,

00:18:38.770 --> 00:18:40.960
you'll get an exception immediately.

00:18:40.960 --> 00:18:45.160
It reports it in the very same call where
you call add constraint to the view.

00:18:45.320 --> 00:18:47.820
But ambiguity is not reported.

00:18:47.930 --> 00:18:50.150
It's just something which happens.

00:18:50.290 --> 00:18:52.150
So we can use it to our advantage.

00:18:52.150 --> 00:18:54.360
We can temporarily tolerate ambiguity.

00:18:54.610 --> 00:18:58.890
You saw in the letter rack view
that when we added a new view,

00:18:58.990 --> 00:19:00.580
we removed the existing constraints.

00:19:00.780 --> 00:19:04.500
That forced the layout ambiguous,
but that's okay because we were about

00:19:04.810 --> 00:19:08.290
to reestablish those constraints
the next turn of the run loop.

00:19:08.340 --> 00:19:11.710
The reason we removed the
constraints is to avoid any risk

00:19:11.710 --> 00:19:14.220
of even transient unsatisfiability.

00:19:16.770 --> 00:19:19.270
Now, what do you do when
you don't see anything?

00:19:19.440 --> 00:19:21.600
This is a common problem
with Auto Layout.

00:19:21.710 --> 00:19:24.590
So it's possible your views are
hidden or they don't exist at all,

00:19:24.790 --> 00:19:27.050
and it's also possible
that they do exist,

00:19:27.260 --> 00:19:30.030
but they have a zero width
or zero height or both.

00:19:30.160 --> 00:19:32.600
So you should never call
set frame in Auto Layout,

00:19:32.600 --> 00:19:34.600
but you can ask a view for its frame.

00:19:34.630 --> 00:19:35.230
You know, where is it?

00:19:35.240 --> 00:19:36.150
What's its width and height?

00:19:36.260 --> 00:19:38.200
What's its offset?

00:19:38.590 --> 00:19:42.160
You can also ask what constraints
are making the view that size.

00:19:42.280 --> 00:19:45.890
So this is view constraints
affecting layout for orientation

00:19:46.340 --> 00:19:50.380
on OS X and constraints
affecting layout for axis on iOS.

00:19:50.430 --> 00:19:52.630
And you pass horizontal or vertical.

00:19:52.730 --> 00:19:56.020
And if you call this in the debugger,
keep in mind that horizontal

00:19:56.020 --> 00:19:58.950
is zero and vertical is one,
so you don't have to type

00:19:58.950 --> 00:20:00.570
out those long constants.

00:20:01.820 --> 00:20:04.720
And it's also possible that
the layout is ambiguous,

00:20:04.720 --> 00:20:06.520
and you want to check if
it has ambiguous layout,

00:20:06.550 --> 00:20:09.280
and you can exercise it to see.

00:20:12.020 --> 00:20:16.180
And keep in mind that some layouts
are only satisfiable at zero size.

00:20:16.310 --> 00:20:18.760
So you might say that foo's
width is twice bar's width,

00:20:18.760 --> 00:20:20.860
and bar's width is
three times foo's width.

00:20:20.990 --> 00:20:22.750
You might be thinking, "Oh,
there's no way that can be

00:20:22.750 --> 00:20:25.370
satisfied." But in fact,
it can be satisfied with

00:20:25.370 --> 00:20:26.890
everything equal to zero.

00:20:27.120 --> 00:20:32.000
So this is another reason why you might
have views that just don't appear.

00:20:32.150 --> 00:20:36.360
So let's see a demo
of all of these cases.

00:20:36.450 --> 00:20:38.200
So let's say we're working
on this app for a while.

00:20:38.410 --> 00:20:40.820
I'm going to switch
to a different branch.

00:20:46.980 --> 00:20:54.510
Then when I run this,
it's going to tell me,

00:20:54.600 --> 00:21:06.500
[Transcript missing]

00:21:07.360 --> 00:21:09.760
What it's going to do is it's
going to take the first view.

00:21:09.960 --> 00:21:12.130
Here we're using the new
Objective-C array syntax to

00:21:12.130 --> 00:21:13.500
get our first letter view.

00:21:13.500 --> 00:21:15.600
And we're just going
to log out its frame.

00:21:15.620 --> 00:21:18.810
And then for every view in our pile,

00:21:18.990 --> 00:21:20.820
We're going to ask if
it has ambiguous layout,

00:21:20.820 --> 00:21:24.720
and if it does, we're going to call it
Exercise Ambiguity in Layout.

00:21:25.080 --> 00:21:26.280
So let's try that.

00:21:26.310 --> 00:21:27.340
Choose debug.

00:21:27.480 --> 00:21:28.660
Oh, my views appear.

00:21:28.660 --> 00:21:31.800
They have stupidly tall frames.

00:21:31.800 --> 00:21:35.230
And I see that, oh,
the initial frame height was zero.

00:21:35.340 --> 00:21:42.380
So this tells me that
the height is ambiguous,

00:21:42.380 --> 00:21:43.360
and we need to think about who should
be responsible for setting the height.

00:21:45.050 --> 00:21:48.590
I could have done something very similar
by calling visualize constraints,

00:21:48.720 --> 00:21:51.780
and here we could pass an array
of constraints to visualize,

00:21:51.780 --> 00:21:53.900
but I'm just passing an empty array.

00:21:53.990 --> 00:21:57.410
The reason to do that is because it will

00:21:58.870 --> 00:22:03.320
Show me this purple overlay window,
which tells me layout is ambiguous here,

00:22:03.530 --> 00:22:06.400
and I can click this button
to exercise ambiguity,

00:22:06.520 --> 00:22:07.860
which doesn't actually
seem to do anything.

00:22:07.860 --> 00:22:11.990
Sometimes multiple layouts
all have the same visual look,

00:22:12.070 --> 00:22:14.640
so this would be a case like that,
which is why I called exercise

00:22:14.640 --> 00:22:19.290
ambiguity on every view,
every one of my letter tiles.

00:22:22.200 --> 00:22:24.940
So in this case,
who's responsible for setting the height?

00:22:24.950 --> 00:22:28.850
Well, the height should be equal
to the width of every letter.

00:22:28.910 --> 00:22:31.100
So I'm going to try to
remember where I set that.

00:22:31.100 --> 00:22:35.220
Oh, I set that on the letter
view itself in init.

00:22:35.680 --> 00:22:39.550
That's part of the aspect ratio,
and someone had commented that out.

00:22:39.670 --> 00:22:42.060
So I remove the comments.

00:22:43.080 --> 00:22:45.560
I run that and I'm back in business.

00:22:45.730 --> 00:22:48.240
So that's an example of ambiguity.

00:22:51.060 --> 00:22:55.000
I'm going to switch
to a different branch.

00:22:55.000 --> 00:22:58.350
So this time, when I run it,
I do see my views,

00:22:58.410 --> 00:23:01.200
but they're all pinned to the top,
and they don't have the layout I want.

00:23:01.340 --> 00:23:04.740
And in addition,
there is this enormous amount of text

00:23:04.740 --> 00:23:06.990
which has been output to the log.

00:23:08.250 --> 00:23:13.090
So this is a case of unsatisfiability.

00:23:13.100 --> 00:23:16.600
You can tell because it says "unable
to simultaneously satisfy constraints."

00:23:16.630 --> 00:23:19.790
And we'll go into these log messages in
detail because it's very important that

00:23:19.810 --> 00:23:21.970
we be able to read and understand these.

00:23:22.040 --> 00:23:24.100
But for now,
we can just look at what they're saying.

00:23:24.100 --> 00:23:30.080
We see that letter view A, so the A tile,
its center is equal to

00:23:30.230 --> 00:23:32.900
the pile's center plus 56.

00:23:33.370 --> 00:23:38.200
We see it's also equal to
the pile center plus 172.

00:23:38.260 --> 00:23:41.740
So clearly we cannot satisfy
both of these constraints.

00:23:42.130 --> 00:23:43.840
So we have unsatisfiability.

00:23:43.910 --> 00:23:47.500
So I suspect that the--

00:23:47.660 --> 00:23:51.180
The positioning here is due
to the letter pile setting the

00:23:51.180 --> 00:23:53.200
offsets of the letter views.

00:23:53.340 --> 00:23:55.660
So I go to the letter pile.

00:23:56.540 --> 00:24:02.060
And I say, "Okay, here's the center
X equal to my center X."

00:24:02.770 --> 00:24:04.890
Here we have the center x
again equal to my center x.

00:24:04.940 --> 00:24:07.690
Oh, but this time we're using
the constant y instead of x.

00:24:07.810 --> 00:24:09.800
So this looks like a
copy and paste error.

00:24:09.900 --> 00:24:13.220
So this is another illustration
of why using Interface Builder or

00:24:13.220 --> 00:24:16.700
the visual format language would
have avoided this error entirely.

00:24:16.800 --> 00:24:20.600
So I'm going to say the center
y is equal to my center y

00:24:20.720 --> 00:24:23.170
plus the location and pile.

00:24:24.350 --> 00:24:35.620
: I still have some ambiguity,
which I'm not going to

00:24:35.620 --> 00:24:35.620
try to debug right now,
but we can see we certainly

00:24:35.620 --> 00:24:35.620
have an improvement.

00:24:35.620 --> 00:24:35.620
Letters are no longer
positioned in crazy places.

00:24:36.970 --> 00:24:39.240
Okay, in the last case,
I'm going to start up the app,

00:24:39.610 --> 00:24:43.400
and everything seems fine at first,
but when I click a view, uh-oh,

00:24:43.400 --> 00:24:46.500
my window suddenly shrunk
to some crazy width.

00:24:46.580 --> 00:24:47.500
What happened here?

00:24:47.500 --> 00:24:51.160
And if I add more views,
it's going to change along with it.

00:24:51.660 --> 00:24:54.140
I can resize it,
but I can't resize it very much.

00:24:54.230 --> 00:24:55.850
So this is a case where
we have constraints.

00:24:55.930 --> 00:24:58.330
It's not unsatisfiable,
and it's not ambiguous,

00:24:58.460 --> 00:25:01.000
but it's layout satisfied
in a way we don't want.

00:25:01.130 --> 00:25:07.040
So when you see something like this,
a good thought is that some constraint

00:25:07.040 --> 00:25:08.680
has a higher priority than it should.

00:25:08.700 --> 00:25:10.260
And in this case,
it has a higher priority

00:25:10.260 --> 00:25:13.240
than the priority with which
the window holds its width,

00:25:13.330 --> 00:25:15.860
which is why it can shrink the window.

00:25:16.000 --> 00:25:18.370
So in this case,
because it only happened when

00:25:18.400 --> 00:25:21.480
I added the view to the letter rack,
I can --

00:25:22.460 --> 00:25:24.810
is the reason that is
probably related to one of the

00:25:24.810 --> 00:25:29.180
constraints the letter rack adds,
and I see that

00:25:30.330 --> 00:25:35.440
Oh, the constraint pinning the last view
to the right edge has a padding of 20,

00:25:35.440 --> 00:25:37.300
but it doesn't have a priority.

00:25:37.410 --> 00:25:39.960
So that means it's required,
which is a much higher priority,

00:25:40.100 --> 00:25:43.140
of course,
than what the window holds its width.

00:25:43.270 --> 00:25:45.690
So I'm going to first
make this an inequality,

00:25:45.720 --> 00:25:48.490
and I'm going to make it
a lower priority than 500,

00:25:48.610 --> 00:25:51.340
which is the window holding priority.

00:25:51.440 --> 00:25:54.870
And this time when I run that,
the views start out and they

00:25:55.110 --> 00:25:57.230
no longer shrink the window.

00:25:57.360 --> 00:26:00.470
So those are some examples of
how you would debug problems you

00:26:00.470 --> 00:26:02.390
can encounter with Auto Layout.

00:26:05.630 --> 00:26:13.750
We saw with the unsatisfiability
case a very long log message,

00:26:13.750 --> 00:26:13.750
and you'll probably
encounter this at some point.

00:26:14.070 --> 00:26:15.430
and it's intimidating at first, right?

00:26:15.470 --> 00:26:18.600
It's like a wall of
text that comes at you.

00:26:18.600 --> 00:26:21.290
And when you see this,
you don't want to panic and we'll

00:26:21.290 --> 00:26:23.040
break it down for you right now.

00:26:23.040 --> 00:26:26.110
So the first thing to notice
is this set the user default,

00:26:26.110 --> 00:26:30.520
NS constraint based layout visualize
mutually exclusive constraints,

00:26:30.750 --> 00:26:33.390
you set this to yes,
the instant constraints

00:26:33.500 --> 00:26:36.880
become unsatisfiable,
it will open up that purple overlay

00:26:36.880 --> 00:26:40.090
window and it will call visualize
constraints and you can actually

00:26:40.240 --> 00:26:41.840
inspect the constraints visually.

00:26:41.840 --> 00:26:44.070
So this is a good thing to have
set on your application all

00:26:44.070 --> 00:26:46.380
the time when you're debugging.

00:26:47.500 --> 00:26:49.760
Also notice obc exception throw.

00:26:49.760 --> 00:26:53.540
When an exception is thrown,
the second layout becomes unsatisfiable.

00:26:53.680 --> 00:26:56.430
Now, the exception is immediately caught,
so it does not propagate

00:26:56.530 --> 00:27:00.830
through your code,
but this is still a very useful

00:27:00.830 --> 00:27:06.530
fact to know because it allows
you to put a breakpoint there

00:27:06.530 --> 00:27:06.530
and see the backtrace of,
"Oh, here's where I added that

00:27:06.530 --> 00:27:06.530
first bad constraint."

00:27:07.580 --> 00:27:10.900
Now, this is telling you what it's
doing to resolve the conflict,

00:27:10.900 --> 00:27:14.970
which constraint it's allowing to win,
and this is usually not that interesting.

00:27:15.130 --> 00:27:18.850
The real important information
is the array of unsatisfiable

00:27:18.850 --> 00:27:21.340
constraints at the top,
unable to simultaneously

00:27:21.340 --> 00:27:22.250
satisfy constraints.

00:27:22.390 --> 00:27:25.940
So let's zoom in on one of these.

00:27:26.080 --> 00:27:29.000
And there's three parts
to a constraint message.

00:27:30.230 --> 00:27:37.710
At the top,
we have the address of the constraint.

00:27:37.710 --> 00:27:37.710
So if you reference constraints,
you create them, you can ask,

00:27:37.710 --> 00:27:37.710
"Is this my constraint
or someone else's?"

00:27:38.320 --> 00:27:42.520
At the bottom, we have a mapping from
identifier to view.

00:27:42.660 --> 00:27:44.580
So if you set an
identifier for your view,

00:27:44.780 --> 00:27:47.540
it will make your log
messages easier to read.

00:27:47.650 --> 00:27:50.550
You set the identifier in
Interface Builder right here

00:27:50.550 --> 00:27:52.660
under the View Inspector.

00:27:52.950 --> 00:27:54.590
There it is.

00:27:54.670 --> 00:27:56.260
So this is a good thing
to do for all your views.

00:27:56.260 --> 00:28:01.850
Instead of seeing a long hex address,
you can just see the name of the view.

00:28:02.960 --> 00:28:06.530
The most important part, of course,
is the meat of the constraint itself,

00:28:06.530 --> 00:28:08.400
what relationship it expresses.

00:28:08.620 --> 00:28:12.950
This has the view's identifier,
and it has the property of the view,

00:28:12.950 --> 00:28:19.430
the attribute, the relation,
the view it's related to,

00:28:19.430 --> 00:28:19.430
and then the constant.

00:28:20.000 --> 00:28:23.740
So it was very useful to translate
this from sort of code into English.

00:28:23.900 --> 00:28:27.300
So we would say, "Oh,
the letter views center should be 11

00:28:27.300 --> 00:28:30.520
points to the left of the pile center."

00:28:33.300 --> 00:28:40.430
Now,
for constraints that can be expressed

00:28:40.430 --> 00:28:40.430
with a visual format syntax,
it will show that syntax

00:28:40.430 --> 00:28:40.430
in the log messages.

00:28:41.170 --> 00:28:45.620
So for example, in this case,
we say that Views Width is 250.

00:28:45.620 --> 00:28:48.970
And again, it's really useful to
translate this into English.

00:28:49.720 --> 00:28:51.100
Here's another case.

00:28:51.160 --> 00:28:56.280
We say that the view's left or
right edge is at least 50 points

00:28:56.280 --> 00:28:59.320
from another view's left edge.

00:29:02.500 --> 00:29:04.730
And here's a very important
log message you'll see.

00:29:04.810 --> 00:29:05.430
It looks like this.

00:29:05.490 --> 00:29:06.630
It's a little different.

00:29:06.690 --> 00:29:09.850
The first thing to notice is
that it's not NSLayoutConstraint,

00:29:09.900 --> 00:29:12.400
it's NSAutoResizingMaskLayoutConstraint.

00:29:12.560 --> 00:29:14.630
And this tells you right
away that Translate's

00:29:14.640 --> 00:29:17.440
AutoResizingMaskIndicConstraints
is on for this view.

00:29:17.760 --> 00:29:21.480
So if you didn't mean to leave that on,
you know right away how to fix this,

00:29:21.480 --> 00:29:24.150
locate the view,
and turn that property off.

00:29:24.750 --> 00:29:27.550
Next,
you'll see the auto resizing mask itself.

00:29:27.750 --> 00:29:31.250
So one auto resizing mask actually
generates multiple constraints.

00:29:31.390 --> 00:29:35.770
So this tells you which of the
many constraints from this mask

00:29:35.770 --> 00:29:37.940
this particular constraint is.

00:29:38.030 --> 00:29:41.000
And lastly, we have the familiar
visual format language.

00:29:41.250 --> 00:29:43.770
This view's height is 50.

00:29:45.770 --> 00:29:50.810
So here's a longest example and
the last example we'll look at.

00:29:50.870 --> 00:29:53.300
What can we tell from this constraint?

00:29:53.420 --> 00:29:56.900
Well, we see that it's an auto
resizing mask constraint.

00:29:56.970 --> 00:29:59.490
Here's this auto resizing mask.

00:30:00.930 --> 00:30:03.870
We see that it's a horizontal constraint,
because H means horizontal,

00:30:03.900 --> 00:30:05.900
V means vertical.

00:30:06.040 --> 00:30:11.900
And we see that there's 200 points
between this view on the right and what?

00:30:11.900 --> 00:30:14.900
Well, the vertical bar means super view.

00:30:14.900 --> 00:30:16.900
So 200 points between the
view and the super view.

00:30:16.990 --> 00:30:20.890
And the super view we see below
is an instance of flip view.

00:30:21.000 --> 00:30:21.810
That's its description.

00:30:21.900 --> 00:30:24.890
So to put it all into English,

00:30:25.110 --> 00:30:28.140
This view's left edge is 200
points from that of a super view,

00:30:28.140 --> 00:30:29.300
which is a flip view.

00:30:29.370 --> 00:30:32.430
And by saying it in English,
it's often very obvious

00:30:32.430 --> 00:30:36.190
why the constraints are not
simultaneously satisfiable.

00:30:38.080 --> 00:30:39.090
So that concludes debugging.

00:30:39.150 --> 00:30:42.270
Hopefully by now you've got a fully
debugged layout and you're ready to

00:30:42.350 --> 00:30:45.800
start really leveraging it and getting
some mileage out of the feature.

00:30:47.470 --> 00:30:50.770
So one very common task in
OS X and iOS is animation.

00:30:50.940 --> 00:30:53.920
How do you animate layout changes?

00:30:55.980 --> 00:30:58.080
Well,
one approach is to apply the new layout

00:30:58.080 --> 00:30:59.890
and let Core Animation handle it.

00:30:59.900 --> 00:31:02.400
Just like you might call Set Frame,
you can just apply the layout and

00:31:02.550 --> 00:31:04.390
it will animate to the new position.

00:31:04.460 --> 00:31:07.850
And this is very fast,
but it has the disadvantage of perhaps

00:31:08.060 --> 00:31:10.930
transiently violating constraints
because it just interpolates from

00:31:10.930 --> 00:31:14.900
the old position to the new position
without regard for constraints.

00:31:14.910 --> 00:31:17.900
You can also animate the
constraints directly.

00:31:17.900 --> 00:31:20.980
And this is pretty fast,
and it produces the correct

00:31:20.980 --> 00:31:22.460
layout at every frame.

00:31:22.590 --> 00:31:26.810
So what do I mean by this transient
violation or correct layout?

00:31:27.690 --> 00:31:30.570
So say you have a view like
this with a purple view inside

00:31:30.570 --> 00:31:32.200
and a blue view on the outside.

00:31:32.230 --> 00:31:35.400
And the purple view wants
to have a width of 100,

00:31:35.400 --> 00:31:38.500
but weakly so,
and it wants to have a padding of at

00:31:38.500 --> 00:31:42.390
least 20 on its left and right side,
and that's required.

00:31:42.530 --> 00:31:46.010
So as the view shrinks,
initially the purple view is

00:31:46.010 --> 00:31:48.700
going to maintain its width,
but as its outer view shrinks,

00:31:48.720 --> 00:31:52.110
eventually the purple view is going
to start shrinking with it as well.

00:31:53.520 --> 00:31:56.220
So if you were to animate
this change using Auto Layout,

00:31:56.220 --> 00:31:57.790
that's exactly what you'd see.

00:31:57.840 --> 00:32:01.240
Every step of the animation
would be as if you had resized

00:32:01.320 --> 00:32:03.180
the window point by point.

00:32:03.290 --> 00:32:05.620
But with core animation,
you'll see something like this,

00:32:05.770 --> 00:32:08.710
where the purple view will have
interpolated from the start

00:32:08.790 --> 00:32:12.910
position to the end position at
the same time as the blue view,

00:32:12.910 --> 00:32:14.760
and it will not be exactly the same.

00:32:14.870 --> 00:32:16.820
So when you're considering
how to animate,

00:32:16.920 --> 00:32:20.500
consider whether you care about this
sort of transient violation or not,

00:32:20.530 --> 00:32:23.790
and then choose the API appropriately.

00:32:25.310 --> 00:32:27.720
So let's say you're satisfied
with core animation,

00:32:27.740 --> 00:32:30.290
you find it's easy to use,
you're familiar with it.

00:32:30.290 --> 00:32:32.620
How do you do animation with Auto Layout?

00:32:33.390 --> 00:32:35.430
Well,
you want to set up your new constraints,

00:32:35.500 --> 00:32:38.610
and then within an animation block,
you call layout if needed

00:32:38.800 --> 00:32:41.810
or layout subtree if needed,
depending on your OS.

00:32:42.900 --> 00:32:44.240
So here it is with NSView.

00:32:44.440 --> 00:32:45.860
You call runAnimationGroup.

00:32:45.860 --> 00:32:47.130
You'll set the duration.

00:32:47.310 --> 00:32:50.860
You'll set allowsImplicitAnimation,
and you call layoutSubtree if needed.

00:32:51.130 --> 00:32:53.360
In UIView, it's a little simpler.

00:32:53.410 --> 00:32:56.940
You animate with duration,
and you call layout if needed.

00:33:02.080 --> 00:33:05.480
Now, maybe you do care about the transit
violation or you want to use

00:33:05.480 --> 00:33:07.830
Auto Layout for your animation as well.

00:33:07.970 --> 00:33:10.190
How do you go about doing that?

00:33:11.530 --> 00:33:14.830
Well,
most of NSLayout constraint is immutable.

00:33:15.000 --> 00:33:17.200
You cannot change it
once it's been created.

00:33:17.290 --> 00:33:21.490
Except for one property,
which is called constant, ironically.

00:33:21.580 --> 00:33:24.740
The constant can be
modified after creation.

00:33:26.610 --> 00:33:30.570
And when you modify the constant,
it is very efficient because it doesn't

00:33:30.600 --> 00:33:32.100
have to recompute a whole new layout.

00:33:32.100 --> 00:33:35.680
It can just use the work that's
already done and just tweak it a little

00:33:35.680 --> 00:33:37.450
bit to reflect the constant change.

00:33:37.610 --> 00:33:39.420
So this is efficient.

00:33:40.770 --> 00:33:42.940
So you could modify this on an NS timer.

00:33:43.010 --> 00:33:45.650
For example, every tick of a timer,
you add 10 to the

00:33:45.780 --> 00:33:47.640
constant of a constraint.

00:33:47.750 --> 00:33:51.440
Or you could use the
animator proxy on OS X only.

00:33:51.440 --> 00:33:55.340
So you could say, for example,
constraint.animator.constant = 10,

00:33:55.340 --> 00:33:59.280
and it's going to step from
its current value to the new

00:33:59.670 --> 00:34:02.070
value using the animator proxy.

00:34:02.740 --> 00:34:10.180
: So let's see a demo of these
different animation approaches.

00:34:13.340 --> 00:34:16.610
So there's two separate
animations in this app.

00:34:16.720 --> 00:34:18.810
Well, there's a couple,
but one of them is when

00:34:18.890 --> 00:34:21.040
you click a letter,
it flies off to the right,

00:34:21.040 --> 00:34:22.740
and then it flies into the rack.

00:34:22.870 --> 00:34:24.820
And those are separate animations.

00:34:24.970 --> 00:34:27.600
So let me show you how
I implemented those.

00:34:27.600 --> 00:34:32.780
In the application delegate animation,

00:34:34.800 --> 00:34:36.940
We're going to move letter
from pile to the rack.

00:34:37.080 --> 00:34:42.060
So the motion out of the pile view is
done by animating an NSLayout constraint,

00:34:42.060 --> 00:34:43.540
not using core animation.

00:34:43.680 --> 00:34:49.290
So we start by computing a constraint
that expresses its existing layout.

00:34:49.790 --> 00:34:50.890
Here's that constraint.

00:34:51.000 --> 00:34:55.010
So we say that it's actually
flush against the right side.

00:34:56.400 --> 00:35:15.100
[Transcript missing]

00:35:16.270 --> 00:35:19.340
So then we add the constraint
to the letter pile.

00:35:19.340 --> 00:35:20.490
We run the animation group.

00:35:20.630 --> 00:35:22.640
We set the duration to
something that we like.

00:35:22.810 --> 00:35:25.200
We set the timing function
to something we like.

00:35:25.370 --> 00:35:28.200
And then we call the
animation constraint animator.

00:35:28.200 --> 00:35:29.200
We set the constant to zero.

00:35:29.200 --> 00:35:32.350
So initially the constant is
something large and negative,

00:35:32.350 --> 00:35:35.200
so the view is a negative
distance from the right side.

00:35:35.200 --> 00:35:36.390
It's inside the view.

00:35:36.530 --> 00:35:40.190
And then it's going to be pushed
towards the right side of the view.

00:35:41.760 --> 00:35:44.510
So once that's done in
the completion handler,

00:35:44.590 --> 00:35:47.610
this is the animation where
all the letter flies in.

00:35:47.960 --> 00:35:50.780
And by the way,
you might have other views

00:35:50.810 --> 00:35:52.760
animating in there as well.

00:35:54.320 --> 00:35:55.800
You see that if I start
adding more views,

00:35:55.800 --> 00:35:59.640
all the views are going
to animate together.

00:35:59.640 --> 00:36:02.680
So we're going to remove the constraint
that pushes outside of the pile,

00:36:02.860 --> 00:36:05.490
remove the letter view from the pile.

00:36:05.640 --> 00:36:09.880
: We're going to run an
animation where all we do is

00:36:09.970 --> 00:36:13.200
call layout subtree if needed.

00:36:13.200 --> 00:36:16.130
And this will apply the new layout
and it will animate from its

00:36:16.130 --> 00:36:17.990
current layout to the new layout.

00:36:18.140 --> 00:36:21.910
So this is very little
work to do an animation.

00:36:25.800 --> 00:36:26.800
That covers animation.

00:36:26.850 --> 00:36:30.110
Let's shift gears to talk about
writing a custom control that you

00:36:30.190 --> 00:36:31.910
want to integrate with Auto Layout.

00:36:32.190 --> 00:36:34.500
How do you go about doing that?

00:36:35.690 --> 00:36:38.090
Well, there's a couple concepts
you should be familiar with

00:36:38.710 --> 00:36:39.650
because they're very important.

00:36:39.650 --> 00:36:41.700
And the first is alignment wrecks.

00:36:41.840 --> 00:36:44.830
So we've been talking about
constraints like they've been

00:36:44.870 --> 00:36:47.640
operating on the view's frames,
but that's actually not quite true.

00:36:47.640 --> 00:36:49.580
They operate on the alignment wreck.

00:36:49.680 --> 00:36:52.790
And you can think of the alignment
wreck as the content area.

00:36:52.940 --> 00:36:56.750
So if the user sees a button, you know,
"push me," that's good,

00:36:56.760 --> 00:36:57.960
but we don't know what the frame is,
right?

00:36:57.960 --> 00:37:02.620
The frame could have a very small padding
or no padding or a lot of padding.

00:37:02.760 --> 00:37:05.400
But in a sense,
you don't really care as Auto Layout.

00:37:05.400 --> 00:37:09.470
You want to position the content,
not its logical frame.

00:37:10.130 --> 00:37:15.740
So again, the frame is that logical rect,
and the alignment rect is the rect within

00:37:16.130 --> 00:37:19.080
that which contains the actual content.

00:37:21.500 --> 00:37:23.400
Here's another example of alignment, Rex.

00:37:23.460 --> 00:37:27.390
Say you have a text and you have an
image and you want to align the tops

00:37:27.390 --> 00:37:29.910
and bottoms of the text and the image.

00:37:30.820 --> 00:37:32.740
Now let's say you want to
apply a badge to the image,

00:37:32.880 --> 00:37:34.460
like that.

00:37:34.590 --> 00:37:36.460
That badge isn't really
part of the image.

00:37:36.460 --> 00:37:39.660
It should maybe overhang outside of it,
but it should not contribute

00:37:39.660 --> 00:37:41.040
to the alignment at all.

00:37:41.150 --> 00:37:44.230
So in that case,
the alignment rect is still the gear that

00:37:44.330 --> 00:37:47.850
we saw before and excludes the badge.

00:37:51.180 --> 00:37:53.170
So you can convert between
alignment rects and frames.

00:37:53.320 --> 00:37:56.040
There's a method,
alignment rect for frame and

00:37:56.090 --> 00:37:58.600
frame for alignment rect.

00:37:58.720 --> 00:38:00.300
And that's all.

00:38:03.150 --> 00:38:06.340
The other important concept to
know is the intrinsic content size.

00:38:06.340 --> 00:38:10.770
This is something you encountered a
little bit in the introductory session.

00:38:10.990 --> 00:38:13.300
Now,
many of you are very happy at any size.

00:38:13.300 --> 00:38:16.300
If you just make an arbitrary view,
it doesn't really care what size it is.

00:38:16.420 --> 00:38:19.710
But some views have a preferred size,
and you may know this as size

00:38:19.710 --> 00:38:21.500
to fit or size that fits.

00:38:21.670 --> 00:38:25.170
In an Auto Layout,
this is the intrinsic content size.

00:38:26.190 --> 00:38:28.570
Now, you may have an intrinsic
content size in two dimensions,

00:38:28.570 --> 00:38:32.320
like this button has a preferred
width based on its label,

00:38:32.320 --> 00:38:35.120
and also a preferred height
based on its bezel artwork.

00:38:35.340 --> 00:38:38.270
This progress indicator doesn't
really care what its width is,

00:38:38.350 --> 00:38:40.380
but it has a preferred height.

00:38:40.380 --> 00:38:42.800
And this is just a base class view.

00:38:42.800 --> 00:38:45.790
It has no preferred width
or preferred height.

00:38:47.780 --> 00:38:50.920
When you have an intrinsic content
size in one or both dimensions,

00:38:51.070 --> 00:38:55.090
Auto Layout will generate constraints
for you in the dimensions where it

00:38:55.090 --> 00:38:56.620
has that intrinsic content size.

00:38:56.870 --> 00:38:59.270
And there's two
constraints per dimension.

00:38:59.450 --> 00:39:02.800
So here we see the button's
width is at least 120.

00:39:02.930 --> 00:39:06.390
And that's called the compression
resistance because it tries to prevent

00:39:06.640 --> 00:39:08.700
it from getting smaller than 120.

00:39:08.810 --> 00:39:12.700
And it also has a width
of no more than 120.

00:39:12.810 --> 00:39:17.690
And this is called the content hugging
because it tries to hug its content

00:39:17.700 --> 00:39:19.750
and prevent itself from getting bigger.

00:39:20.800 --> 00:39:23.880
Notice that this is sufficient
to unambiguously size the view.

00:39:24.210 --> 00:39:29.200
Before I told you that inequalities
are not sufficient to avoid ambiguity,

00:39:29.390 --> 00:39:32.520
but in this case they are because
there's only one number which

00:39:32.760 --> 00:39:37.200
is at most 120 and at least 120,
which is of course 120.

00:39:38.810 --> 00:39:41.460
You might be thinking, "Well,
why didn't we just set the width at 120?

00:39:41.460 --> 00:39:44.550
Why do we have two constraints?"
And the answer is because they

00:39:44.550 --> 00:39:46.060
can have different priorities.

00:39:46.120 --> 00:39:50.000
This is a very powerful tool
you can use in Auto Layout.

00:39:50.100 --> 00:39:54.160
For example, if you have a text label,
maybe you're okay if the text label

00:39:54.160 --> 00:39:58.790
grows as the window grows or if the
screen rotates because it looks fine.

00:39:58.880 --> 00:40:02.480
But what you really want to avoid
is the text label clipping because

00:40:02.480 --> 00:40:04.130
then you're losing content.

00:40:04.320 --> 00:40:07.820
You would implement this by setting
a low content hugging priority

00:40:08.340 --> 00:40:10.750
so it allows itself to grow,
but a high compression

00:40:10.750 --> 00:40:14.280
resistance priority so it does
not allow itself to shrink.

00:40:15.210 --> 00:40:18.100
For the button case,
you would have a high compression

00:40:18.240 --> 00:40:21.550
resistance and a high content
hugging because it wants to be

00:40:21.570 --> 00:40:23.930
its preferred width very strongly.

00:40:25.710 --> 00:40:27.960
Now, the intrinsic content
size is not settable.

00:40:27.960 --> 00:40:30.370
You can't tell a button
what its width should be,

00:40:30.370 --> 00:40:32.330
except by setting a constraint on it.

00:40:32.460 --> 00:40:35.500
It's size which is
intrinsic to the content.

00:40:35.530 --> 00:40:37.040
But the priorities are settable.

00:40:37.120 --> 00:40:38.800
This is a very powerful
tool in your arsenal.

00:40:38.950 --> 00:40:41.850
You can set them directly
in Interface Builder.

00:40:42.880 --> 00:40:44.200
It's right there under the sizing tab.

00:40:44.200 --> 00:40:49.000
You see that there's sliders
for vertical and horizontal.

00:40:50.060 --> 00:40:51.500
You can also set them in code.

00:40:51.760 --> 00:40:54.190
You say set content hugging
priority for dimension,

00:40:54.440 --> 00:40:58.500
and you pass a priority and a dimension,
and the compression resistance priority.

00:40:58.710 --> 00:41:02.900
And in UIKit, dimension is axis.

00:41:02.940 --> 00:41:05.100
Otherwise, it's very similar.

00:41:11.650 --> 00:41:14.430
Let's say we have a text label like this,
and it starts out and it's

00:41:14.490 --> 00:41:17.330
exactly the right size,
but the content changes.

00:41:17.420 --> 00:41:19.460
So now it's clipping because
it still has that constraint

00:41:19.630 --> 00:41:20.850
setting it to the old size.

00:41:21.000 --> 00:41:22.960
How do we resolve this?

00:41:23.040 --> 00:41:26.960
Well, any time the content changes
such that its intrinsic content

00:41:26.960 --> 00:41:29.930
size should also change,
the view will call invalidate

00:41:29.930 --> 00:41:31.940
intrinsic content size on itself.

00:41:32.030 --> 00:41:35.220
And this tells Auto Layout, "Oh,
I need to get the intrinsic

00:41:35.220 --> 00:41:39.500
content size again and establish
constraints reflecting it."

00:41:39.700 --> 00:41:41.440
And if you're implementing
a custom control,

00:41:41.500 --> 00:41:44.200
this is a great method that you want to
-- you don't want to ever override it,

00:41:44.200 --> 00:41:47.700
but you want to call it on yourself
whenever your intrinsic content

00:41:47.700 --> 00:41:51.390
size might change because some
property of your view has changed.

00:41:51.530 --> 00:41:55.400
For example, the text or image content.

00:41:55.620 --> 00:42:01.380
So in this case, by calling invalid
intrinsic content size,

00:42:01.380 --> 00:42:02.570
it will establish new sizing constraints
and the view will be at its correct size.

00:42:06.260 --> 00:42:10.680
Now, intrinsic content size also
works with springs and struts,

00:42:10.680 --> 00:42:14.940
and you can use this to your
advantage as a better size to fit.

00:42:15.050 --> 00:42:16.840
What do I mean by better?

00:42:16.920 --> 00:42:18.690
Well, size to fit cannot change.

00:42:18.720 --> 00:42:22.060
It has to stay the same to
preserve binary compatibility.

00:42:22.200 --> 00:42:24.900
You'll recall in OS X,
we used to have pop-up buttons with

00:42:25.000 --> 00:42:28.890
this large blue sort of blob on
the right side with the indicator,

00:42:28.960 --> 00:42:31.460
and that's gone now,
but the pop-up button is still

00:42:31.460 --> 00:42:34.460
sizing itself as if it's there
for binary compatibility reasons.

00:42:34.590 --> 00:42:39.110
So as the artwork changes,
size to fit can sometimes lag behind.

00:42:39.220 --> 00:42:41.180
But intrinsic content size can change,
and in fact,

00:42:41.260 --> 00:42:44.240
it has changed in Mountain Lion to
reflect artwork changes and

00:42:44.240 --> 00:42:45.660
also just to fix some bugs.

00:42:45.840 --> 00:42:49.910
So you can use intrinsic content
size as a better size to fit.

00:42:50.480 --> 00:42:51.980
Doing so is very easy.

00:42:52.070 --> 00:42:57.180
First, you make a rectangle,
which represents the

00:42:57.180 --> 00:42:57.180
intrinsic content size.

00:42:57.480 --> 00:43:00.540
Then you want to convert from
the alignment rect to the frame,

00:43:00.540 --> 00:43:03.190
and then you can set
that frame on the view.

00:43:03.290 --> 00:43:05.270
So by doing this,
you'll often get a better layout,

00:43:05.360 --> 00:43:08.530
even in springs and struts.

00:43:11.320 --> 00:43:15.170
So when you're running a custom control,
rather than establishing width and

00:43:15.170 --> 00:43:18.800
height constraints on yourself,
it's often very nice to just

00:43:18.970 --> 00:43:21.430
override intrinsic content size.

00:43:21.530 --> 00:43:24.320
And if you do that,
it's a good idea to measure your text

00:43:24.450 --> 00:43:28.030
or your image or your other content,
and you can also just hard code values.

00:43:28.270 --> 00:43:31.440
So if you have artwork which
is exactly 22 points tall,

00:43:31.440 --> 00:43:35.540
you can just return a height of 22
for your intrinsic content size.

00:43:35.610 --> 00:43:39.280
What you don't want to ever do is
inspect your current position or size.

00:43:39.340 --> 00:43:41.720
It's supposed to be
intrinsic to your content.

00:43:41.940 --> 00:43:44.440
It should have nothing to do
with where you're currently at.

00:43:44.510 --> 00:43:46.880
You don't want to call super
and just tweak its value.

00:43:46.880 --> 00:43:50.470
So you don't want to say, "Oh,
my intrinsic content size is super

00:43:50.510 --> 00:43:54.330
class's intrinsic content size plus
3." And you don't want to use it as a

00:43:54.330 --> 00:43:56.110
substitute for explicit constraints.

00:43:56.250 --> 00:43:59.510
So if you're just making an empty view
which should have a particular width,

00:43:59.730 --> 00:44:01.100
just set a constraint on that view.

00:44:01.100 --> 00:44:04.310
Don't override intrinsic content size.

00:44:05.280 --> 00:44:07.500
And for indicating your alignment rect,
for example,

00:44:07.500 --> 00:44:12.900
you have a shadow or the image badge,
the dos are similar,

00:44:13.080 --> 00:44:15.420
but you want to consider using
the default implementation,

00:44:15.420 --> 00:44:19.540
which is just -- returns
the same thing as the frame.

00:44:19.600 --> 00:44:21.860
You can also override
alignment rect insets,

00:44:21.920 --> 00:44:25.330
which is just a set of four values
which can be used to convert to and

00:44:25.330 --> 00:44:27.090
from frames and alignment rects.

00:44:27.270 --> 00:44:31.260
This will save you from having to
override frame for alignment rect,

00:44:31.260 --> 00:44:32.270
for example.

00:44:33.410 --> 00:44:34.950
And the don'ts are the same.

00:44:35.080 --> 00:44:37.540
You don't want to inspect your
position size or your constraints

00:44:37.540 --> 00:44:39.390
because those should be irrelevant.

00:44:39.510 --> 00:44:41.500
You don't want to call
super and tweak its value.

00:44:41.500 --> 00:44:43.800
You just want to set your own value.

00:44:43.900 --> 00:44:46.750
And you don't want to use it as
a substitute where you should

00:44:46.750 --> 00:44:48.590
be using explicit constraints.

00:44:51.460 --> 00:44:55.460
So the most sophisticated thing
you can do as an Auto Layout custom

00:44:55.550 --> 00:44:59.360
control is to override layout or
layout subviews in the UI kit.

00:44:59.450 --> 00:45:04.630
And this is how you do most of the
sort of fancy frame-dependent layouts.

00:45:04.750 --> 00:45:08.060
So all layout does is set the
receiver's frame to the values

00:45:08.060 --> 00:45:10.760
determined by the constraints,
and on UI kit,

00:45:10.760 --> 00:45:13.890
it sets the receiver's center
and bounds to the values

00:45:13.900 --> 00:45:16.100
determined by the constraints.

00:45:17.080 --> 00:45:20.000
And afterwards,
the constraints and the frames agree.

00:45:20.100 --> 00:45:23.890
And as long as you ensure that's
still true in your override,

00:45:24.000 --> 00:45:26.080
you can do anything you want.

00:45:28.600 --> 00:45:29.500
So here's an example.

00:45:29.500 --> 00:45:30.620
Say you have a view like this.

00:45:30.700 --> 00:45:34.500
Imagine like a toolbar view,
and it's got some views within it,

00:45:34.630 --> 00:45:36.350
and it's all strung
together with constraints,

00:45:36.660 --> 00:45:38.260
like we saw in our keyboard view.

00:45:38.390 --> 00:45:42.970
But let's say if the super view shrinks,
you want that rightmost

00:45:42.970 --> 00:45:44.810
view to just go away.

00:45:45.960 --> 00:45:49.900
: How would you do this with Auto Layout?

00:45:49.900 --> 00:45:53.270
You do this by overriding
layout or layout subviews.

00:45:53.280 --> 00:45:57.500
You call super and inspect
the frames of all your views.

00:45:57.500 --> 00:46:01.800
You say, oh, this rightmost view is
actually outside my bounds.

00:46:02.010 --> 00:46:06.090
I'm going to get rid of it,
remove the view, remove its constraints,

00:46:06.090 --> 00:46:08.190
and then you can call super again.

00:46:08.190 --> 00:46:11.550
And you can do this over and
over again until you've found the

00:46:11.590 --> 00:46:13.560
layout that you're happy with.

00:46:13.730 --> 00:46:15.900
So I'll show you an example of that.

00:46:20.320 --> 00:46:23.450
So you recall that in my
letter rack view at the bottom,

00:46:23.450 --> 00:46:27.330
as I start adding views,
eventually it's going to reach a minimum

00:46:27.330 --> 00:46:29.690
size and then just start clipping.

00:46:29.780 --> 00:46:31.890
And let's say I think, "Oh,
that clipping looks kind of

00:46:31.920 --> 00:46:34.890
dumb." Instead of a clipping,
I want to just hide the views,

00:46:34.940 --> 00:46:35.960
get rid of them.

00:46:36.080 --> 00:46:38.370
So I'll show you how we could do that.

00:46:43.040 --> 00:46:44.080
I have this code here.

00:46:44.370 --> 00:46:48.060
So the first step is to override
layout in the super view.

00:46:48.120 --> 00:46:50.780
We call super layout.

00:46:50.890 --> 00:46:55.410
For any view that we threw out before,
we're going to add it back.

00:46:56.150 --> 00:46:59.590
will go into our view and call update
constraints for subtree if needed.

00:46:59.680 --> 00:47:03.770
So this reestablishes all the constraints
for all these views that we added back.

00:47:05.690 --> 00:47:09.300
We'll call layout in an animation block
with a zero duration so you don't see

00:47:09.300 --> 00:47:11.990
this kind of transient work being done.

00:47:12.360 --> 00:47:17.900
And then afterwards, in a loop,
we're going to get our last view,

00:47:17.910 --> 00:47:23.240
last object, and if it's max X is less
than or equal to our max X,

00:47:23.240 --> 00:47:24.240
well, we're done.

00:47:24.240 --> 00:47:24.770
It fits.

00:47:25.090 --> 00:47:26.760
But if it's not,
that means it's overhanging

00:47:26.760 --> 00:47:27.910
and we want to get rid of it.

00:47:28.060 --> 00:47:29.780
So we call remove letter view.

00:47:29.890 --> 00:47:32.400
We add it to our overflow array.

00:47:32.440 --> 00:47:34.900
We call update constraints
for subtree if needed.

00:47:34.940 --> 00:47:38.480
And then we call layout, again,
in an animation block with zero duration.

00:47:38.580 --> 00:47:43.940
And we're going to keep doing this
until the rightmost last view is

00:47:43.940 --> 00:47:47.300
either nil or it fits within our view.

00:47:47.400 --> 00:47:51.970
So I've added this code,
and this time when I run it...

00:47:52.590 --> 00:47:55.090
I'm going to add a bunch of views.

00:47:55.190 --> 00:47:58.040
And then when I start shrinking it,
it's going to shrink until

00:47:58.040 --> 00:48:00.530
it reaches the minimum size,
and then it's going to

00:48:00.530 --> 00:48:03.800
-- instead of clipping,
it's just going to throw the view out.

00:48:03.920 --> 00:48:07.530
So here we have a
layout-dependent view hierarchy.

00:48:12.250 --> 00:48:17.300
So let's go to the last topic,
which is internationalization.

00:48:17.320 --> 00:48:19.800
How do you localize an Auto Layout app?

00:48:19.940 --> 00:48:22.700
Well, Auto Layout makes it a lot
easier because controls know

00:48:22.700 --> 00:48:24.290
what their content should be.

00:48:24.420 --> 00:48:27.040
You don't have to go into the
nib anymore and adjust things

00:48:27.040 --> 00:48:28.800
by hand for every localization.

00:48:28.970 --> 00:48:34.210
And in particular,
the same constraints all work

00:48:34.210 --> 00:48:34.210
across different localizations.

00:48:34.660 --> 00:48:37.680
So, for example, if we have buttons,
cancel, save,

00:48:37.700 --> 00:48:42.640
and then the edge of the window,
under German, the content is going to

00:48:42.660 --> 00:48:45.840
get a lot longer because
German typically has longer words,

00:48:45.970 --> 00:48:52.710
but the constraints are the same,
so you'll get the layout

00:48:52.710 --> 00:48:52.710
appropriate for the content.

00:48:52.710 --> 00:48:52.710
It's pretty cool.

00:48:53.800 --> 00:48:56.630
Hopefully you saw in the developer
kickoff that one nib can now

00:48:56.870 --> 00:48:59.900
service multiple localizations,
and the control content comes

00:49:00.050 --> 00:49:05.520
not from the nib anymore,
but from a strings file which is

00:49:05.640 --> 00:49:10.930
associated for every localization.

00:49:10.930 --> 00:49:11.710
And you can still use
separate nibs when necessary.

00:49:11.710 --> 00:49:11.710
And this even works for right to left.

00:49:13.750 --> 00:49:16.930
Auto Layout is cast not in
terms of left and right so

00:49:17.100 --> 00:49:19.440
much as leading and trailing.

00:49:19.600 --> 00:49:22.300
And leading and trailing
flip under right to left.

00:49:22.450 --> 00:49:27.320
So this exact same constraints will
give you a layout that flips under

00:49:27.320 --> 00:49:31.560
RTL languages like Arabic or Hebrew.

00:49:31.690 --> 00:49:35.100
So I'm going to show you what
happens when I use this in my app.

00:49:42.510 --> 00:49:47.300
So my app is using this
new localization mechanism.

00:49:47.390 --> 00:49:49.540
You can see we have a base localization.

00:49:49.630 --> 00:49:51.540
Then we have English and German.

00:49:51.680 --> 00:49:54.160
So it will create
strings files for these.

00:49:54.160 --> 00:49:58.640
So here's the base localization,
and here's English and German.

00:49:58.730 --> 00:50:01.690
And this is all the control
content just laid out for me.

00:50:01.830 --> 00:50:05.370
So let's say that I want to
change the title of my initial

00:50:05.370 --> 00:50:08.250
window to something longer.

00:50:11.620 --> 00:50:14.420
So now when I run it, oh,
the window's sized to reflect

00:50:14.530 --> 00:50:17.870
this new string without even
having to recompile the nib.

00:50:18.250 --> 00:50:20.950
And this works, of course,
because I had constraints that

00:50:21.070 --> 00:50:24.440
say that the text field needs
to push out the window if it's

00:50:24.440 --> 00:50:26.770
below its intrinsic content size.

00:50:28.160 --> 00:50:30.540
What I can also do is
turn on right to left,

00:50:30.540 --> 00:50:33.100
and you can do that
with some user defaults.

00:50:33.150 --> 00:50:34.810
Apple text direction, yes.

00:50:35.300 --> 00:50:38.500
Force right to left writing direction,
yes.

00:50:38.580 --> 00:50:40.570
And when I run this,

00:50:40.960 --> 00:50:42.360
It may look the same.

00:50:42.430 --> 00:50:43.460
Well, it shouldn't look the same.

00:50:43.460 --> 00:50:46.760
What's different is that, you know,
the buttons that used to be on

00:50:46.760 --> 00:50:51.070
the right are now on the left,
and the buttons that were on

00:50:51.070 --> 00:50:51.070
the left are now on the right.

00:50:51.390 --> 00:50:55.240
When I start the game,
the words have flipped sides,

00:50:55.300 --> 00:50:58.000
and in particular, when I click a letter,
it's going to fly off to

00:50:58.000 --> 00:50:59.170
the left and not the right.

00:50:59.300 --> 00:51:01.280
So I did absolutely nothing
to support right to left,

00:51:01.450 --> 00:51:04.300
but I still get a pretty awesome
right to left experience.

00:51:04.340 --> 00:51:07.970
See how the views are appearing
on the right and not the left.

00:51:08.090 --> 00:51:10.880
And everything else about it is the same.

00:51:14.100 --> 00:51:20.390
So we think this is a way easier and more
powerful way to localize applications.

00:51:23.340 --> 00:51:26.560
So in summary,
Auto Layout allows for sophisticated

00:51:26.620 --> 00:51:30.090
and powerful layout with less
code or no code in some cases

00:51:30.170 --> 00:51:31.900
compared to springs and struts.

00:51:32.040 --> 00:51:34.630
And you can take maximum advantage
of it if you're able to think

00:51:34.630 --> 00:51:37.910
declaratively about your layout,
not imperatively.

00:51:38.190 --> 00:51:41.800
Be wary of issues like
ambiguity or unsatisfiability.

00:51:41.930 --> 00:51:44.620
The log messages are there to help,
so when you get one,

00:51:44.630 --> 00:51:47.510
you want to take the time to
read it and understand it.

00:51:47.890 --> 00:51:50.320
By overriding methods like
intrinsic content size,

00:51:50.320 --> 00:51:53.000
you can integrate your custom
control with Auto Layout,

00:51:53.040 --> 00:51:54.800
and it will save you a lot of work.

00:51:54.910 --> 00:51:59.760
And now you can localize with a single
nib file and multiple strings files.

00:52:00.160 --> 00:52:03.740
So for more information,
contact our evangelist, Paul Marcos.

00:52:03.800 --> 00:52:05.100
See the Cocoa Auto Layout Guide.

00:52:05.100 --> 00:52:06.090
It's really great.

00:52:06.130 --> 00:52:08.800
It's got a ton of complete information.

00:52:08.850 --> 00:52:09.850
You don't have to write down the address.

00:52:09.920 --> 00:52:15.520
You can just Google "Coco
Auto Layout Guide."

00:52:15.520 --> 00:52:15.520
The developer forums as well,
of course.
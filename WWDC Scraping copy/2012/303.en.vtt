WEBVTT

00:00:10.100 --> 00:03:49.600
[Transcript missing]

00:03:49.940 --> 00:03:52.740
And then all you have to do,
user decides, hey,

00:03:52.740 --> 00:03:54.500
I'm ready to use location.

00:03:54.500 --> 00:03:56.490
And you go ahead and
start updating locations.

00:03:56.490 --> 00:03:58.910
And then with that,
we go ahead and give you a callback

00:03:59.080 --> 00:04:00.510
that says your user moved here.

00:04:00.610 --> 00:04:03.850
And then you can take appropriate
actions such as updating your view.

00:04:04.010 --> 00:04:07.640
If you're a fitness app,
maybe you store it to some data model.

00:04:07.770 --> 00:04:12.940
And basically, that's kind of the quick
overview of how location works.

00:04:12.940 --> 00:04:17.770
So with that, I'd like to move on to what
we've done in the last year to

00:04:17.770 --> 00:04:20.030
really kind of improve location.

00:04:20.030 --> 00:04:22.520
So there's three main
things that we've done.

00:04:22.670 --> 00:04:27.160
The first is we've improved
accuracy significantly.

00:04:27.160 --> 00:04:31.020
The next thing we've done is we've
also improved the availability

00:04:31.020 --> 00:04:33.070
of location services in general.

00:04:33.270 --> 00:04:35.680
And then lastly,
we've also helped to lower

00:04:35.680 --> 00:04:39.290
power consumption of location
on your user's devices.

00:04:39.290 --> 00:04:43.970
So their battery can last longer
than ever when using your apps.

00:04:44.170 --> 00:04:46.340
So let's look at a
couple of these things.

00:04:46.340 --> 00:04:48.330
What do I mean by improved accuracy?

00:04:48.330 --> 00:04:51.390
So let's consider our lovely
city of San Francisco here.

00:04:51.390 --> 00:04:53.900
San Francisco,
if you're in kind of the eastern

00:04:53.900 --> 00:04:56.630
side in the downtown area,
it looks a lot like this,

00:04:56.630 --> 00:04:58.640
like your major metropolitan area.

00:04:58.640 --> 00:05:01.140
You get these big,
tall skyscrapers that block

00:05:01.140 --> 00:05:02.630
the GPS satellite signal.

00:05:02.660 --> 00:05:04.950
So with that,
it's called an urban canyon,

00:05:04.950 --> 00:05:07.590
and it's a really,
really difficult environment

00:05:07.590 --> 00:05:09.200
for GPSs to work in.

00:05:10.470 --> 00:05:16.340
And so we actually take devices and
we drive around San Francisco a lot.

00:05:16.340 --> 00:05:18.640
And we particularly pick on this
one block that's got those nice

00:05:18.780 --> 00:05:20.460
buildings that you saw right there.

00:05:20.460 --> 00:05:24.600
And the result is that we drive around
and we look at our GPS performance.

00:05:24.670 --> 00:05:28.140
And we get something that
looks something like this.

00:05:28.140 --> 00:05:31.090
Now, this looks a little bit sloppy,
but quite frankly,

00:05:31.090 --> 00:05:34.350
most vendors would love to have
a location solution that looks as

00:05:34.350 --> 00:05:36.220
good as this does with just GPS.

00:05:36.220 --> 00:05:40.220
But we're Apple,
and we also have iPhones.

00:05:40.220 --> 00:05:44.490
We have iPhones that have Wi-Fi radios
and cellular radios and a whole bunch of

00:05:44.490 --> 00:05:46.940
other technologies baked into the phone.

00:05:46.940 --> 00:05:48.580
So we don't just stop at GPS.

00:05:48.580 --> 00:05:52.520
If your user has Wi-Fi, now in iOS 6,
they'll get something that's an

00:05:52.530 --> 00:05:55.070
experience that's a bit more like this.

00:05:55.410 --> 00:05:57.000
But that's not all.

00:05:57.000 --> 00:06:00.900
As you know, Maps just launched with some
beautiful new vector data,

00:06:00.900 --> 00:06:03.550
which actually is useful
for location as well.

00:06:03.660 --> 00:06:07.310
So now your experience if you're
driving in downtown San Francisco will

00:06:07.400 --> 00:06:08.900
be something more like this.

00:06:16.380 --> 00:06:17.640
There's two main parts.

00:06:17.640 --> 00:06:20.420
Let's start with what I mean
by Wi-Fi aided location.

00:06:20.420 --> 00:06:22.620
So like I suggested,
basically we take the

00:06:22.630 --> 00:06:26.110
horizontal outliers,
say you're driving through San Francisco,

00:06:26.110 --> 00:06:28.870
and you see these peaks in
uncertainty where we really

00:06:28.870 --> 00:06:30.380
don't know what's going on.

00:06:30.380 --> 00:06:32.880
You've got signals
reflecting through windows,

00:06:32.950 --> 00:06:34.980
you've got buildings blocking others.

00:06:35.050 --> 00:06:38.010
So if we add in Wi-Fi information,
we can actually reduce

00:06:38.010 --> 00:06:39.340
the location accuracy.

00:06:39.400 --> 00:06:41.290
So we look something more like this.

00:06:41.290 --> 00:06:44.410
So basically we just take those really,
really bad peaks and

00:06:44.410 --> 00:06:46.280
we drop them back in.

00:06:46.300 --> 00:06:48.690
And it looks a lot,
basically it's an incremental

00:06:48.690 --> 00:06:52.840
improvement that really helps as a good
stepping point for other technologies.

00:06:52.840 --> 00:06:56.980
So that brings us to map aided location.

00:06:56.980 --> 00:07:02.810
So what map aided location does is we
basically take the raw GPS and course,

00:07:02.810 --> 00:07:07.540
the location and course
information from GPS and Wi-Fi.

00:07:07.540 --> 00:07:09.980
And then we look at the,
consider the question

00:07:09.990 --> 00:07:11.450
of is your user driving?

00:07:11.450 --> 00:07:14.140
Now if your user's driving, A,
they're much more likely to be

00:07:14.200 --> 00:07:16.280
on a road because most people
don't drive through golf course.

00:07:16.300 --> 00:07:20.200
And the other reason why it's
important is because there's a lot

00:07:20.470 --> 00:07:22.920
more sensor information from driving.

00:07:22.920 --> 00:07:24.440
So your course is much more reliable.

00:07:24.440 --> 00:07:27.180
So with that,
if we have vector data available

00:07:27.190 --> 00:07:31.150
to us or we decide to download it,
the result is that we can consider

00:07:31.150 --> 00:07:34.760
all of these things and decide
if bringing you closer to a road

00:07:34.760 --> 00:07:36.940
is more accurate for your user.

00:07:36.960 --> 00:07:40.180
And so we will improve location
if it's possible for us to do so.

00:07:40.180 --> 00:07:45.640
So the reason we do this is for, say,
improving turns.

00:07:46.340 --> 00:07:50.080
A different part of a drive test,
this is the Transamerica pyramid.

00:07:50.340 --> 00:07:52.820
We have data that looks
something like this.

00:07:52.890 --> 00:07:56.250
Now it's clear that the user probably
didn't go through that plaza.

00:07:56.400 --> 00:08:00.460
And in fact, if we add Wi-Fi in,
you start looking more like this.

00:08:00.710 --> 00:08:03.920
But again, if map aiding is available
because you're driving,

00:08:03.980 --> 00:08:06.180
the result is this.

00:08:06.450 --> 00:08:10.540
So this helps a lot if you're trying
to understand where your user actually

00:08:10.540 --> 00:08:12.980
is and you're trying to provide
directions or just generally keep

00:08:13.060 --> 00:08:16.280
track of any sort of location accuracy.

00:08:16.890 --> 00:08:18.870
But like I mentioned,
we only do it if it's possible.

00:08:18.990 --> 00:08:22.640
So one of the key tenets of when
we turn this on is the question of

00:08:22.640 --> 00:08:24.460
can we do this without any harm?

00:08:24.560 --> 00:08:27.300
And so with that,
we actually added another

00:08:27.310 --> 00:08:28.940
spot on our drive test.

00:08:28.940 --> 00:08:30.380
And we stopped for donuts.

00:08:30.500 --> 00:08:31.910
And I don't mean the manly donut shop.

00:08:31.980 --> 00:08:35.870
I actually mean we go into the
parking lot and we do donuts.

00:08:38.400 --> 00:08:41.400
So this is not an urban environment.

00:08:41.400 --> 00:08:43.700
As you can see,
we actually are doing very,

00:08:43.700 --> 00:08:46.500
very well with just GPS and Wi-Fi.

00:08:46.630 --> 00:08:50.330
But we can still do it-- so
when we turn on map aiding,

00:08:50.360 --> 00:08:52.100
we actually don't do much.

00:08:52.190 --> 00:08:54.600
You're a little bit closer to the roads,
but when you get to the parking lot,

00:08:54.720 --> 00:08:56.900
your user's track is left alone.

00:08:56.970 --> 00:08:59.310
And so we don't really
have any road data there,

00:08:59.350 --> 00:09:01.930
and so we leave the user
right as they're driving,

00:09:01.930 --> 00:09:02.810
having fun.

00:09:03.170 --> 00:09:08.450
So this is really cool that we can
selectively apply map aiding when it's

00:09:08.460 --> 00:09:11.440
really beneficial to users and not
when it's going to change their data

00:09:11.540 --> 00:09:14.190
to ways that don't make sense for you.

00:09:14.800 --> 00:11:29.400
[Transcript missing]

00:11:29.810 --> 00:11:33.480
By bringing these to OS X,
we've enabled the ability to bring

00:11:33.480 --> 00:11:36.700
the Reminders application to OS X.

00:11:36.810 --> 00:11:40.140
Reminders now works
great on your desktop,

00:11:40.140 --> 00:11:42.280
home work notifications, they're great.

00:11:42.410 --> 00:11:46.410
As long as your computer stays running,
so if it's slept and not shut down,

00:11:46.430 --> 00:11:47.750
it'll work just fine.

00:11:47.830 --> 00:11:52.230
A quick example of how geocoding
and region monitoring play together.

00:11:52.330 --> 00:11:55.470
If you were going to install
a reminder for something that

00:11:55.550 --> 00:11:59.690
was interesting to the user,
like where I work, and then what you do

00:11:59.690 --> 00:12:03.300
is you take an address,
you create a geocoder object,

00:12:03.440 --> 00:12:08.090
and then you make a geocode request,
which you pass a block,

00:12:08.220 --> 00:12:10.530
will go hit a server,
asynchronously call you back,

00:12:10.690 --> 00:12:13.870
and then you can decide that you want
to start monitoring for that region.

00:12:14.060 --> 00:12:16.170
And so you just pick the best
place mark of your choice,

00:12:16.240 --> 00:12:19.620
start monitoring for it, and again,
we give you this callback saying

00:12:19.620 --> 00:12:23.300
location manager did enter region,
and we have a similar one for exit,

00:12:23.300 --> 00:12:25.810
and you can just, since this is OS X,
you can display an

00:12:25.810 --> 00:12:27.220
NS alert to tell your user,
hey, look, you're back.

00:12:27.220 --> 00:12:27.220
Great.

00:12:27.220 --> 00:12:27.220
So you can just go ahead and
start monitoring for that region.

00:12:27.220 --> 00:12:27.220
And then you can just pick the
best place mark of your choice,

00:12:27.220 --> 00:12:27.220
start monitoring for it, and again,
we give you this callback saying

00:12:27.220 --> 00:12:28.140
location manager did enter region,
Hey, look, you're back.

00:12:28.330 --> 00:12:29.730
Great.

00:12:30.530 --> 00:12:34.470
So with that, let's talk about some other
forms of availability,

00:12:34.470 --> 00:12:37.270
specifically Wi-Fi availability.

00:12:37.280 --> 00:12:41.930
So as many of you already know,
if you're sitting somewhere and you've

00:12:41.930 --> 00:12:47.510
got a location and you do a Wi-Fi scan,
what we do is we take those results

00:12:47.510 --> 00:12:48.940
and we send them up to the server.

00:12:48.940 --> 00:12:51.820
And the server says, hey, look,
we know about all these

00:12:51.820 --> 00:12:53.640
Wi-Fi hotspots in this whole area.

00:12:53.670 --> 00:12:54.380
Here you go.

00:12:54.820 --> 00:12:57.880
And so now your device,
without any more talking to the server,

00:12:57.880 --> 00:13:00.440
can wander around for some
finite distance and figure

00:13:00.440 --> 00:13:01.740
out where the user is.

00:13:01.740 --> 00:13:03.800
But the problem is,
as you're driving around

00:13:03.800 --> 00:13:06.660
San Francisco and you're hanging
out taking photos of people,

00:13:06.740 --> 00:13:09.730
you know, you take one picture here,
you take one picture there,

00:13:09.730 --> 00:13:11.910
you're not necessarily in the same spot.

00:13:11.920 --> 00:13:14.070
We don't hit the cache on the device.

00:13:14.070 --> 00:13:17.020
So the result is that we go to
the network and we download yet

00:13:17.020 --> 00:13:20.110
another piece of information
and you get a new little area.

00:13:20.110 --> 00:13:21.540
So now you can move
around inside of this,

00:13:21.540 --> 00:13:23.480
but if you move somewhere further,
then we have to go talk

00:13:23.480 --> 00:13:24.440
to the network again.

00:13:24.820 --> 00:13:30.020
So with iOS 6, we decided,
can we maybe do something better here?

00:13:30.020 --> 00:13:31.980
Can we maybe compress the data?

00:13:31.980 --> 00:13:34.140
And so what we did is we actually
took all the Wi-Fis and we

00:13:34.250 --> 00:13:35.550
mapped them into these tiles.

00:13:35.640 --> 00:13:38.490
So now in the same size as one
of those data downloads that

00:13:38.530 --> 00:13:41.150
you saw on the screen before,
you saw six of them,

00:13:41.190 --> 00:13:42.990
you get one of these instead.

00:13:43.050 --> 00:13:43.910
Same amount of data.

00:13:43.910 --> 00:13:47.900
That's five kilometers
by five kilometers.

00:13:52.910 --> 00:13:56.300
And the cool part is, if you're on Wi-Fi,
we don't just download one tile.

00:13:56.300 --> 00:13:59.110
We'll actually download a whole bunch
of tiles in that area so that your user

00:13:59.170 --> 00:14:00.780
can travel even further around the city.

00:14:00.780 --> 00:14:03.690
So if you pay for data at a
coffee shop and then you use it,

00:14:03.710 --> 00:14:04.920
you can keep going.

00:14:04.920 --> 00:14:07.790
We have 10 times the access
points in one piece of data.

00:14:07.790 --> 00:14:10.050
And actually,
because we're smarter about the

00:14:10.100 --> 00:14:13.020
way that we choose the access
points that we put into the tile,

00:14:13.020 --> 00:14:15.600
we actually get 60
times the coverage area.

00:14:15.620 --> 00:14:19.260
So it's just being a little bit
smarter about it overall and you

00:14:19.260 --> 00:14:21.550
would get this better performance.

00:14:22.560 --> 00:14:24.720
So with that,
the advantages of Wi-Fi tiles

00:14:24.800 --> 00:14:26.160
are a handful of things.

00:14:26.670 --> 00:14:29.470
First off,
it's basically instantaneous location.

00:14:29.630 --> 00:14:32.720
If we know about the Wi-Fi's
that are near you and we see one,

00:14:32.720 --> 00:14:33.450
we know where you are.

00:14:33.620 --> 00:14:33.810
Done.

00:14:34.000 --> 00:14:34.210
Fast.

00:14:34.220 --> 00:14:37.660
So passbook and weather,
everything works instantly.

00:14:37.660 --> 00:14:42.570
Another cool thing is that we sell
devices that don't have cellular radios,

00:14:42.570 --> 00:14:44.410
which means that if we
can't download data,

00:14:44.420 --> 00:14:45.680
we can't know where you are.

00:14:45.740 --> 00:14:49.300
So now that we've got Wi-Fi tiles,
we can bring things like region

00:14:49.300 --> 00:14:51.160
monitoring over to the device.

00:14:51.190 --> 00:14:54.790
Or you could even say tag
photos with information.

00:14:55.000 --> 00:14:58.850
So an iPod touch,
which doesn't have a GPS in it,

00:14:58.850 --> 00:15:00.960
can now take a picture and know
where you are and you can say,

00:15:00.960 --> 00:15:03.390
hey, look, this was at this place.

00:15:03.620 --> 00:15:05.300
But it's not just Wi-Fi-only
devices that benefit.

00:15:05.300 --> 00:15:08.320
Users travel abroad, and they don't like
paying for expensive data.

00:15:08.350 --> 00:15:11.090
And even if they're not abroad,
they don't want to take

00:15:11.090 --> 00:15:12.660
data against their data cap.

00:15:12.810 --> 00:15:16.520
So by saving some space and giving
them a whole bunch more information,

00:15:16.520 --> 00:15:21.010
we've made Wi-Fi location much,
much more available to all users.

00:15:21.060 --> 00:15:24.110
With that,
I'd like to move on to some API changes.

00:15:24.120 --> 00:15:28.120
So I mentioned that we
lowered power consumption.

00:15:28.660 --> 00:15:31.670
And specifically,
we were noticing a problem with

00:15:31.670 --> 00:15:35.200
a lot of applications in the
store that wanted to run in the

00:15:35.270 --> 00:15:38.070
background for one reason or another,
like fitness applications

00:15:38.070 --> 00:15:39.340
and driving applications.

00:15:39.340 --> 00:15:43.030
Let's say that a user is driving
down to L.A., and they get hungry.

00:15:43.040 --> 00:15:44.580
So they stop for dinner.

00:15:44.580 --> 00:15:45.230
Okay, great.

00:15:45.430 --> 00:15:45.910
What do they do?

00:15:46.020 --> 00:15:48.260
They unplug their cord,
they put their phone in their pocket.

00:15:49.700 --> 00:17:30.600
[Transcript missing]

00:17:30.630 --> 00:17:31.360
Are we fixing?

00:17:31.520 --> 00:17:33.530
Can we get a location for this user?

00:17:33.690 --> 00:17:36.400
And similarly, we actually can do some
activity detection to say,

00:17:36.400 --> 00:17:38.370
hey, look,
if you're a running application

00:17:38.730 --> 00:17:41.270
and you get in the car,
the motion's completely different.

00:17:41.270 --> 00:17:43.830
We can kind of detect the
two and we can pause you just

00:17:43.950 --> 00:17:45.810
proactively based on activity type.

00:17:47.550 --> 00:17:49.980
So what does this API look like?

00:17:50.090 --> 00:17:53.660
Well, for starters,
you need to know whether it's on.

00:17:53.660 --> 00:17:57.140
And the answer is basically if it's on,
if you're compiled against --

00:17:57.180 --> 00:17:59.940
if you're linked against iOS 6,
we're going to turn it

00:17:59.940 --> 00:18:01.080
on for you by default.

00:18:01.080 --> 00:18:03.440
All your old applications
will work as before,

00:18:03.460 --> 00:18:06.620
but we're going to turn it on by default.

00:18:06.620 --> 00:18:09.480
But we're going to give you a
property that you can control to say

00:18:09.480 --> 00:18:11.800
whether or not this is a good idea.

00:18:12.230 --> 00:18:16.050
Similarly, you're going to need to know,
you need to tell us what type

00:18:16.050 --> 00:18:17.730
of activity your user is doing.

00:18:17.820 --> 00:18:21.300
So we've got a property on the location
manager now called activity type,

00:18:21.480 --> 00:18:24.110
which is going to allow you to set us,
tell us the activity

00:18:24.130 --> 00:18:25.500
type your user is doing.

00:18:25.500 --> 00:18:29.200
And so we've come up with three basic
activity types that you can choose from.

00:18:29.200 --> 00:18:31.490
The first is vehicular navigation.

00:18:31.510 --> 00:18:35.720
So your maps application that's
giving navigation or your

00:18:35.720 --> 00:18:38.180
TomTom or Navigon or somebody.

00:18:39.620 --> 00:18:40.620
Fitness applications.

00:18:40.700 --> 00:18:42.840
If the user is running,
if the user is cycling,

00:18:42.980 --> 00:18:45.900
that's a good indication that
you're a fitness application.

00:18:45.960 --> 00:18:47.830
And then lastly, everything else.

00:18:47.960 --> 00:18:50.240
Basically, those are the two most common
types of applications that

00:18:50.240 --> 00:18:51.380
want to run in the background.

00:18:51.510 --> 00:18:53.540
So everyone else is kind
of lumped into other,

00:18:53.540 --> 00:18:57.280
which just has some basic
characteristics from both of them.

00:18:58.230 --> 00:19:01.330
The next thing you want to do is what
are we going to do when we pause you?

00:19:01.340 --> 00:19:04.500
Well, what we're actually going to do is
we're actually going to tell you that,

00:19:04.500 --> 00:19:07.270
hey, we've paused you so that you
can respond appropriately.

00:19:07.270 --> 00:19:08.460
You could flush some data to disk.

00:19:08.550 --> 00:19:09.670
You could go ahead and tell the user.

00:19:09.670 --> 00:19:10.410
You can do whatever.

00:19:10.460 --> 00:19:14.800
Similarly,
if your application is suspended

00:19:14.800 --> 00:19:17.830
because of a pause event and then
later your user launches your

00:19:17.830 --> 00:19:20.890
application to the foreground,
we'll put you back where you were.

00:19:20.900 --> 00:19:23.540
Or we'll send you a resume
notification and we'll reconnect

00:19:23.540 --> 00:19:26.520
all of your location and you'll
start receiving location updates

00:19:26.660 --> 00:19:28.210
just by the user launching your app.

00:19:28.340 --> 00:19:30.200
Because, again,
you're not in the background anymore.

00:19:30.240 --> 00:19:32.980
Your user's actively telling us, hey,
look, we're trying to use this app.

00:19:33.050 --> 00:19:34.390
So we'll put you back where you were.

00:19:34.420 --> 00:19:36.780
So with that,
I'd like to invite up Mike Dal Santo,

00:19:36.780 --> 00:19:39.700
who's going to give you a quick
demo of how to use Autopause.

00:19:43.110 --> 00:19:44.610
Thanks, Jay.

00:19:44.610 --> 00:19:46.760
How are you all doing?

00:19:46.900 --> 00:19:52.100
I'm going to tell you about Autopause,
our new power saving optimization.

00:19:52.200 --> 00:19:55.200
And our goal for this feature is going
to reduce the number of backgrounded

00:19:55.200 --> 00:19:58.270
applications that are unnecessarily
requesting location updates.

00:19:58.310 --> 00:20:01.690
So what I've got here is your
boilerplate fitness application.

00:20:01.750 --> 00:20:03.330
It's called Autopause Demo.

00:20:03.360 --> 00:20:06.380
And as you can see,
it's nothing more than a start button,

00:20:06.380 --> 00:20:06.870
right?

00:20:06.870 --> 00:20:11.100
And that will actually underneath the
hood call start updating location.

00:20:11.100 --> 00:20:15.100
I've got a table view which will list
the location updates as they come in.

00:20:15.100 --> 00:20:18.070
And then I have a map view which
will plot the location updates.

00:20:18.150 --> 00:20:21.810
So for this demo,
you can see that I'm actually simulating

00:20:21.810 --> 00:20:23.990
a location in our iOS simulator.

00:20:24.120 --> 00:20:26.020
This is considered our city run.

00:20:26.120 --> 00:20:30.800
So being that it's a fitness application,
I thought it would be nice

00:20:30.800 --> 00:20:35.100
to actually see these being
mapped as if you were running.

00:20:35.100 --> 00:20:38.010
So the main point of this feature is
that if you are in the foreground,

00:20:38.010 --> 00:20:39.100
Core Location will have a lot of
information about your location.

00:20:39.100 --> 00:20:42.010
So if you are in the foreground,
Core Location will stay hands off.

00:20:42.100 --> 00:20:45.240
We kind of say that it's up
to the user to determine that

00:20:45.240 --> 00:20:46.100
they are actually tracking.

00:20:46.100 --> 00:20:47.100
So they know best.

00:20:47.100 --> 00:20:50.100
We'll remain uninvolved.

00:20:50.140 --> 00:20:52.100
As soon as the application
goes in the background,

00:20:52.100 --> 00:20:55.560
that's when we start determining,
are these location updates

00:20:55.560 --> 00:20:57.100
benefiting the end user?

00:20:57.110 --> 00:20:59.900
If I were to actually background the
application while I'm running right now,

00:20:59.900 --> 00:21:02.090
we would say, yes,
these are benefiting the end user.

00:21:02.100 --> 00:21:06.100
He's registered as his
activity type is fitness.

00:21:06.100 --> 00:21:07.100
And ultimately,
he's probably using these.

00:21:07.100 --> 00:21:10.100
But let's just say that you
were using my application here.

00:21:10.100 --> 00:21:12.050
And after your run,
you got home and you were

00:21:12.050 --> 00:21:13.100
completely exhausted.

00:21:13.100 --> 00:21:15.010
And you're like,
thank God I'm finally finished

00:21:15.010 --> 00:21:16.100
with that horrible run.

00:21:16.100 --> 00:21:19.300
So instead of actually actively
stopping the location updates,

00:21:19.300 --> 00:21:22.440
which would be the wise thing to do,
you just put it in your pocket or you put

00:21:22.440 --> 00:21:26.100
it on your dresser and you take a shower
and you completely forget about that.

00:21:26.370 --> 00:21:30.100
Meanwhile, we are continuing to
determine position estimates.

00:21:30.100 --> 00:21:33.010
And those are not going to
be benefiting you if you are

00:21:33.010 --> 00:21:35.100
registered as a fitness activity.

00:21:35.100 --> 00:21:37.990
So to showcase this,
we throw this into the background.

00:21:38.100 --> 00:21:41.210
And during this time,
CoreLocation tries to determine,

00:21:41.310 --> 00:21:44.100
are these updates actually
benefiting the user?

00:21:44.100 --> 00:21:45.620
And in our case where
we've stopped running,

00:21:45.620 --> 00:21:47.080
they are no longer benefiting the user.

00:21:47.130 --> 00:21:50.250
So after quite a bit of time,
CoreLocation will issue

00:21:50.250 --> 00:21:52.100
you the pause notification.

00:21:52.100 --> 00:21:56.100
And what that is is it's the
CL location manager's delegate callback.

00:21:56.100 --> 00:21:59.100
Location manager did
pause location updates.

00:21:59.150 --> 00:22:02.230
So when we actually pause you,

00:22:02.400 --> 00:25:38.900
[Transcript missing]

00:25:40.000 --> 00:25:42.800
So we've also got the did
resume location updates.

00:25:42.950 --> 00:25:45.200
When your application is
brought back to the foreground,

00:25:45.200 --> 00:25:47.250
this is when we actually will,
under the hood,

00:25:47.320 --> 00:25:52.140
call start updating for you and then
inform you via this delegate callback.

00:25:52.270 --> 00:25:55.460
So I want to clear out some
internal state that I've kept

00:25:55.460 --> 00:25:57.430
for my location controller.

00:25:58.080 --> 00:26:01.410
Remove any local notifications so that
there's no lingering notifications

00:26:01.410 --> 00:26:03.040
in the notification center.

00:26:03.160 --> 00:26:05.360
Obviously that would be a confusing
state for the user if they saw

00:26:05.360 --> 00:26:08.890
it running and the notification
center still had some lingering.

00:26:08.900 --> 00:26:11.240
Please resume my activity.

00:26:11.370 --> 00:26:14.040
And last but not least,
for this demo purpose,

00:26:14.040 --> 00:26:18.240
I actually post a UI alert view down
here just so you guys can actually see

00:26:18.240 --> 00:26:20.590
underneath the hood what's going on.

00:26:20.950 --> 00:26:25.300
So to run through this one more time,
we are still in a tracking state now,

00:26:25.300 --> 00:26:27.200
so I'm going to push the
application to the background.

00:26:27.200 --> 00:26:32.000
So CoreLocation is actually churning
on every position estimate that we

00:26:32.000 --> 00:26:35.300
actually are going to give your delegate.

00:26:35.300 --> 00:26:37.720
And we're going to determine,
is this benefiting the user?

00:26:37.720 --> 00:26:40.060
After some time,
if you're no longer moving or

00:26:40.060 --> 00:26:42.760
if you're indoors and you're
not able to get a GPS fix,

00:26:42.760 --> 00:26:45.580
we'll say, obviously,
he's just draining battery.

00:26:45.580 --> 00:26:47.840
He's wasting the user's precious power.

00:26:47.840 --> 00:26:49.080
So let's go ahead and pause them.

00:26:49.240 --> 00:26:52.880
So you can see that we were
issued the pause notification.

00:26:52.880 --> 00:26:56.170
And I kind of missed it,
but I wanted to actually note

00:26:56.310 --> 00:27:00.070
on the fact that under settings
now and in the status bar icon,

00:27:00.160 --> 00:27:04.020
we've increased the delay
timer from the status bar icon.

00:27:04.020 --> 00:27:07.910
We've left it in the status
bar there for 10 seconds.

00:27:07.950 --> 00:27:11.050
And under privacy,
we've left it next to your application

00:27:11.050 --> 00:27:13.260
right here for an additional minute.

00:27:13.260 --> 00:27:16.490
And this is because we don't want it
to be any mystery for your users that

00:27:16.490 --> 00:27:18.460
your application was using location.

00:27:18.700 --> 00:27:21.420
So now you have a clear indication
that within the last minute or so,

00:27:21.420 --> 00:27:24.410
this guy was actually using location.

00:27:24.700 --> 00:27:26.770
So as I mentioned before,
if the application were

00:27:26.770 --> 00:27:30.650
to take the foreground,
we would resume location updates for you.

00:27:30.780 --> 00:27:33.940
But if the application is killed
via by the user actually killing

00:27:34.070 --> 00:27:37.180
it manually or if the system is
under load and needs your resources

00:27:37.180 --> 00:27:39.660
and has to actually kill your app,
we will not resume

00:27:39.660 --> 00:27:41.000
location updates for you.

00:27:41.000 --> 00:27:42.740
So that's what I'm going
to do this turn around.

00:27:42.950 --> 00:27:46.750
I'm going to kill the app.

00:27:46.750 --> 00:27:47.830
And you'll see the next
time we launch the app,

00:27:48.060 --> 00:27:52.300
The app is launched with options,
or did finish launching with options,

00:27:52.300 --> 00:27:53.840
as if it was the first
time it was ever launched.

00:27:53.870 --> 00:27:57.120
So the user can actually go back
and look at his last run and

00:27:57.130 --> 00:28:01.530
marvel at not being resumed when
he wasn't hoping to be resumed,

00:28:01.530 --> 00:28:04.410
essentially.

00:28:04.720 --> 00:28:06.140
That's pretty much all
there is for Autopause.

00:28:06.140 --> 00:28:08.520
A key reminder is please
set your activity type.

00:28:08.560 --> 00:28:09.460
Help us help you.

00:28:09.460 --> 00:28:12.860
Let us stay completely informed
of what you're trying to do.

00:28:12.860 --> 00:28:14.860
And other than that,
we look forward to saving some

00:28:14.960 --> 00:28:16.150
battery life with you guys.

00:28:22.620 --> 00:28:23.480
Thanks, Mike.

00:28:23.480 --> 00:28:26.500
So Mike gave you a quick
example of how you might respond

00:28:26.510 --> 00:28:27.930
to a pause event from us.

00:28:27.930 --> 00:28:30.680
And so I wanted to go over
a couple of other ideas.

00:28:30.680 --> 00:28:34.120
So the first idea is that we're
only going to pause you when we're

00:28:34.550 --> 00:28:37.970
actually sure that the user is not
interested in your location data.

00:28:38.040 --> 00:28:41.890
So if you receive a pause event for us,
it probably means you shouldn't

00:28:41.890 --> 00:28:45.390
be running because your user
doesn't expect you to be running.

00:28:45.430 --> 00:28:47.990
So with that,
the easiest thing you can do when

00:28:47.990 --> 00:28:51.620
we send you a pause notification,
don't do anything.

00:28:52.500 --> 00:28:54.350
You can log into disk maybe
if you want to keep a note for

00:28:54.450 --> 00:28:55.660
yourself while you're debugging.

00:28:55.830 --> 00:28:59.980
But what it comes down to is
there's usually no action required.

00:28:59.990 --> 00:29:03.870
Your user is just not expecting
any more activity from you.

00:29:04.140 --> 00:29:06.330
The next thing you might want
to do on an event is to do

00:29:06.330 --> 00:29:07.840
exactly what Mike described.

00:29:07.880 --> 00:29:10.380
If you're a fitness application
and you're expecting to be

00:29:10.380 --> 00:29:13.130
in the background a lot,
maybe you send a notification

00:29:13.130 --> 00:29:15.150
to the user or maybe if you've
got their headphones in,

00:29:15.150 --> 00:29:16.630
you send them a quick
little audible saying,

00:29:16.640 --> 00:29:18.110
hey, by the way,
I'm stopping your activity

00:29:18.220 --> 00:29:19.330
because you're stretching now.

00:29:21.810 --> 00:29:25.330
Another thing that you might want to do,
especially in the fitness app example,

00:29:25.430 --> 00:29:26.910
is just stop updating locations.

00:29:26.910 --> 00:29:30.460
You can go from pause to stop
just by calling stop again.

00:29:30.460 --> 00:29:34.040
And if you agree with us that you
agree that the user is no longer doing

00:29:34.040 --> 00:29:37.990
what you thought the user was doing,
there's no reason to be running.

00:29:38.000 --> 00:29:42.230
If you're a fitness app and you're
paused and you then stop yourself,

00:29:42.230 --> 00:29:45.800
the result is that when you
come back into the foreground,

00:29:45.800 --> 00:29:49.760
the user can now view your old
track and maybe start a new one.

00:29:50.260 --> 00:29:54.160
You don't randomly have data from like
a couple days later being added to

00:29:54.170 --> 00:29:56.420
a really old track in the user's UI.

00:29:56.420 --> 00:30:00.690
It's not a good experience to necessarily
just be paused and then resumed.

00:30:00.710 --> 00:30:02.630
Sometimes you do actually want to stop.

00:30:02.710 --> 00:30:05.060
But this is not going to
be enough for everybody.

00:30:05.060 --> 00:30:07.210
So I'd like to talk about
a couple of other responses

00:30:07.210 --> 00:30:08.460
that you might want to have.

00:30:08.540 --> 00:30:11.420
For 95% of you in the room,
this is not the slide you're looking for.

00:30:11.420 --> 00:30:14.640
Please just ignore me, go to sleep,
do whatever, it's after lunch anyway.

00:30:14.640 --> 00:30:19.160
So one thing you could do is you could
actually just disable auto pause.

00:30:19.500 --> 00:30:20.830
As I mentioned, it's a property.

00:30:20.880 --> 00:30:22.180
You can just go ahead and set it to no.

00:30:22.280 --> 00:30:23.840
And we will just turn it off.

00:30:24.060 --> 00:30:27.450
You will be fully responsible for
the user's battery and the user's

00:30:27.460 --> 00:30:28.890
location and that's all up to you.

00:30:29.330 --> 00:30:31.360
Maybe you want to do that.

00:30:31.440 --> 00:30:34.090
This is tempting to you.

00:30:34.190 --> 00:30:37.250
I'd like to suggest maybe
two other approaches that are

00:30:37.250 --> 00:30:38.720
kind of a compromise on power.

00:30:38.720 --> 00:30:42.640
The first is consider the case
where you're driving and the user's

00:30:42.640 --> 00:30:46.840
followed every single one of your
turns as you're going down the street

00:30:47.010 --> 00:30:49.150
and you get a pause event from us.

00:30:49.280 --> 00:30:51.160
The second is consider the
case where you're driving and

00:30:51.160 --> 00:30:52.140
the user's stopped moving.

00:30:52.240 --> 00:30:54.760
Well, if you know they're still on the
freeway and you know that they're still

00:30:54.800 --> 00:30:56.770
doing what you've told them to do,
there's a good chance they

00:30:56.850 --> 00:30:58.000
just got caught up in traffic.

00:30:58.040 --> 00:31:00.780
So it's entirely possible that
there's some cases where you

00:31:00.850 --> 00:31:02.380
might want to restart location.

00:31:02.460 --> 00:31:03.910
And we make this possible to do.

00:31:04.040 --> 00:31:06.140
You just call start updating location.

00:31:06.160 --> 00:31:08.040
And even if your app is
still in the background,

00:31:08.040 --> 00:31:10.860
we'll give you a little bit more time
to run and we'll think about whether

00:31:10.860 --> 00:31:12.280
or not you should be paused again.

00:31:12.280 --> 00:31:14.730
And so if your user starts moving again,
we won't pause you.

00:31:14.730 --> 00:31:16.810
If the user still stays there,
then maybe we'll send

00:31:16.810 --> 00:31:18.190
you another pause event.

00:31:18.660 --> 00:31:20.210
So it's kind of a way
as a compromise to say,

00:31:20.300 --> 00:31:22.590
hey, look, I actually in this case
know better than you.

00:31:22.660 --> 00:31:23.650
But here's a hint.

00:31:23.700 --> 00:31:27.200
If you've been telling the user to
make U-turns for the past two minutes,

00:31:27.200 --> 00:31:30.260
maybe they're actually sitting in a
restaurant and they're no longer driving.

00:31:30.260 --> 00:31:32.830
And maybe we're right and
you don't actually know what

00:31:32.830 --> 00:31:34.280
the user's doing anymore.

00:31:34.280 --> 00:31:39.680
One other idea is if you had an app that
was just generically kind of wanting

00:31:39.680 --> 00:31:44.960
to log the user's activity as kind of
a path or like some sort of activity,

00:31:45.120 --> 00:31:48.460
just generic, not necessarily fitness.

00:31:48.460 --> 00:31:49.970
But just kind of, hey,
where have you been in the world?

00:31:50.000 --> 00:31:53.560
It might be possible that the
user's gone home for the night.

00:31:53.650 --> 00:31:56.490
You'd like to kind of pause temporarily
and then start again in the morning.

00:31:56.490 --> 00:31:59.010
And it's actually easy to do this.

00:31:59.010 --> 00:32:00.140
But it's always been possible.

00:32:00.140 --> 00:32:02.480
You could have just stopped
yourself and then installed a fence.

00:32:02.480 --> 00:32:07.480
So geofencing would allow you the
ability to resume yourself if you paused.

00:32:07.480 --> 00:32:09.940
Now, again, I really strongly suggest
that you guys don't do this.

00:32:10.010 --> 00:32:12.300
I think that most users are not
going to expect this behavior.

00:32:12.300 --> 00:32:14.730
If your app runs almost indefinitely
as far as a user's concerned and

00:32:14.730 --> 00:32:17.750
every other app runs indefinitely,
then you're going to have to do this.

00:32:17.780 --> 00:32:23.270
So I would strongly consider
trying out auto pause as it is.

00:32:23.600 --> 00:32:24.970
Just tell us your activity type.

00:32:25.100 --> 00:32:26.000
See what it feels like.

00:32:26.090 --> 00:32:29.010
And then if you have problems or
you want to tweak performance,

00:32:29.010 --> 00:32:30.500
you can go and kind of do this.

00:32:30.500 --> 00:32:33.290
So for the rest of you,
most of you can just forget this slide.

00:32:34.990 --> 00:32:41.530
So with that, we have a couple of other
API changes that we've made in iOS 6.

00:32:41.670 --> 00:32:47.050
So the first off is sometimes
it's useful to us to notice that,

00:32:47.150 --> 00:32:48.560
hey, look,
you're not necessarily handling

00:32:48.560 --> 00:32:50.680
location updates as quickly
as we're sending them to you.

00:32:50.920 --> 00:32:54.620
So rather than waste CPU cycles
sending you messages,

00:32:54.620 --> 00:32:57.810
what we might actually do is
we might want to coalesce a

00:32:57.850 --> 00:33:00.690
handful of messages into one,
just give you an array

00:33:00.690 --> 00:33:02.230
of location objects.

00:33:02.300 --> 00:33:04.440
So with that,
we've actually got a new delegate

00:33:04.490 --> 00:33:06.490
callback method that just takes an array.

00:33:06.680 --> 00:33:07.990
They're just chronologically ordered.

00:33:08.100 --> 00:33:09.650
The last one is the newest one.

00:33:09.800 --> 00:33:12.410
So if you fall behind and we
actually send you a couple,

00:33:12.410 --> 00:33:15.110
then what you want to just do
is look at the last element,

00:33:15.220 --> 00:33:17.280
plot that on the map,
and then just throw away the rest

00:33:17.450 --> 00:33:20.080
because your user's not there anymore.

00:33:20.400 --> 00:33:23.960
So with that,
we've actually deprecated the old API.

00:33:23.960 --> 00:33:27.940
If you're targeting 5.1,
obviously you need to still use this API.

00:33:28.060 --> 00:33:32.060
But on 6, we actually, if we see both,
we'll only call the new API.

00:33:32.140 --> 00:33:33.340
So your new delegate.

00:33:33.340 --> 00:33:36.790
So the way that you want to handle
this if you're trying to do 5.1 and

00:33:36.790 --> 00:33:39.690
6 is just implement the old delegate,
pack up the object we

00:33:39.700 --> 00:33:42.250
give you into an array,
send it to your new delegate,

00:33:42.250 --> 00:33:44.660
and implement everything
in your new delegate.

00:33:44.660 --> 00:33:47.300
And that'll allow you to
run on both platforms.

00:33:47.650 --> 00:33:52.020
The next thing I want to
talk about is kind of a quick

00:33:52.100 --> 00:33:54.210
overview of privacy on iOS.

00:33:54.320 --> 00:33:56.870
So as you know, iOS 6,
we're doing a whole bunch of

00:33:56.940 --> 00:33:59.590
privacy controls for all of the
user's personal information.

00:33:59.600 --> 00:34:03.180
Now location has always been
considered personal on iOS.

00:34:03.260 --> 00:34:05.540
And so it's always been possible,
whenever you've tried to

00:34:05.610 --> 00:34:08.600
use a user's location,
we pop up a dialog that looks like this.

00:34:08.600 --> 00:34:11.610
So we tell the users, hey,
this application is trying

00:34:11.690 --> 00:34:12.800
to use location now.

00:34:12.960 --> 00:34:16.270
And then you tell the users, hey,
this is why I want access to

00:34:16.350 --> 00:34:18.600
this user's private information.

00:34:18.600 --> 00:34:20.950
And if you give them a
compelling enough reason,

00:34:20.950 --> 00:34:22.040
they'll say, okay.

00:34:22.040 --> 00:34:24.160
If you don't give them
a compelling reason,

00:34:24.160 --> 00:34:25.590
they'll say, go away.

00:34:25.680 --> 00:34:28.260
And if they do this,
you still want your application to work.

00:34:28.260 --> 00:34:31.010
So keep in mind that you might not
always have location because the

00:34:31.010 --> 00:34:32.510
user might not trust you with it.

00:34:32.690 --> 00:34:35.560
Or maybe they would just prefer
to type in an address and let you

00:34:35.640 --> 00:34:37.600
geocode it and then find something.

00:34:37.600 --> 00:34:38.600
Or maybe they just want
to keep it private.

00:34:38.600 --> 00:34:41.630
Or maybe they just want to go to a
region in a map that they're not actually

00:34:41.630 --> 00:34:43.470
physically at and use your data that way.

00:34:43.600 --> 00:34:46.850
So I guess one thing to keep in
mind is that it's entirely possible

00:34:47.300 --> 00:34:50.760
that the user will prevent you
from using their actual location.

00:34:51.400 --> 00:36:54.400
[Transcript missing]

00:36:54.650 --> 00:36:58.950
Similarly,
5.1 still uses the purpose string,

00:36:59.020 --> 00:37:02.040
so 6 will still support it as well.

00:37:02.040 --> 00:37:05.000
But if we see both,
we'll prefer the Info.plist string

00:37:05.000 --> 00:37:06.600
over the purpose string.

00:37:06.600 --> 00:37:09.250
You might actually want to
read the Info.plist string out

00:37:09.250 --> 00:37:12.600
yourself and set it to the purpose
string if you're targeting 5.1.

00:37:12.600 --> 00:37:17.600
With that, I'd like to move on to talking
about basically performance tuning.

00:37:17.600 --> 00:37:20.490
I'd like to start off with two
myths that I'd hope to dispel.

00:37:20.600 --> 00:37:26.450
I saw an app in the App Store recently
that actually told its users that

00:37:26.500 --> 00:37:29.340
if you want to get a location
fix in this application quickly,

00:37:29.520 --> 00:37:32.030
you should launch Maps first
and then launch my app because

00:37:32.030 --> 00:37:33.600
Maps gets location faster.

00:37:33.600 --> 00:37:37.600
Maps uses the same API that
you guys have access to.

00:37:37.600 --> 00:37:40.150
So if Maps is loading it faster,
it's a function of what Maps is

00:37:40.150 --> 00:37:43.600
doing versus what you're doing,
not what we're doing under the covers.

00:37:43.600 --> 00:37:47.370
And the reason why Maps loads
location faster is because they're

00:37:47.430 --> 00:37:49.600
constantly engaged with the user.

00:37:49.760 --> 00:37:50.600
They start off with a location fix.

00:37:50.680 --> 00:37:52.600
They take a high-level cell
fix that looks like this.

00:37:52.600 --> 00:37:54.520
They know you're in the Bay Area,
so they just start

00:37:54.520 --> 00:37:55.450
bringing the map there.

00:37:55.610 --> 00:37:57.520
You get a better cell fix,
and they start bringing

00:37:57.530 --> 00:37:58.600
you a little bit closer.

00:37:58.600 --> 00:38:01.600
And eventually, you get a Wi-Fi,
and they zoom in a bit more.

00:38:01.600 --> 00:38:04.260
And eventually, you get GPS,
and you get this nice little

00:38:04.260 --> 00:38:07.560
pulsing dot that says,
"Hey, look, I'm out in front of aisle 1."

00:38:07.600 --> 00:38:12.270
And so if Maps is doing this,
engaging their users up front,

00:38:12.270 --> 00:38:15.560
maybe you could be doing the same thing.

00:38:15.600 --> 00:38:17.560
So consider the case where
you're just a restaurant app,

00:38:17.560 --> 00:38:19.600
and I just went ahead and
mocked one up here using Maps.

00:38:19.600 --> 00:38:21.600
You get to the Bay Area.

00:38:21.600 --> 00:38:24.600
You could say, "Hey, look,
here's some awesome restaurants.

00:38:24.600 --> 00:38:28.200
These are the four best restaurants
in the Bay Area." Any user that ever

00:38:28.200 --> 00:38:30.600
flew to San Francisco would want to
drive to one of these restaurants,

00:38:30.600 --> 00:38:32.730
and you could just make it
available on a device for them,

00:38:32.730 --> 00:38:35.560
ready to go as soon as you
get any sort of location.

00:38:35.640 --> 00:38:38.510
Or maybe you get a little bit better,
and you actually, say,

00:38:38.540 --> 00:38:41.460
have a couple of bookmarked
restaurants the user particularly

00:38:41.460 --> 00:38:42.540
likes or hasn't tried yet.

00:38:42.600 --> 00:38:45.210
Maybe then later on,
when you actually get a Wi-Fi fix,

00:38:45.210 --> 00:38:48.600
that's when you actually care, "Okay,
I'm in this neighborhood.

00:38:48.600 --> 00:38:50.590
Maybe now I should go download
some new data and say,

00:38:50.590 --> 00:38:53.580
'Hey, look, if I'm at Apple Campus,
there's BJ's and there's Cafe Max.

00:38:53.640 --> 00:38:56.450
Those are your two dining
options.'" And then lastly,

00:38:56.450 --> 00:38:59.770
GPS, maybe you could tell me how to walk
to Cafe Max if I don't know how to

00:38:59.770 --> 00:39:01.600
get there from my office already.

00:39:01.600 --> 00:39:06.520
But the point is that most of these
scenarios don't require a GPS fix.

00:39:06.610 --> 00:39:09.610
So if you're sitting around waiting
for a handful of seconds just

00:39:09.780 --> 00:39:12.590
spinning or showing a gray background,
your users are bored,

00:39:12.620 --> 00:39:14.370
and they might click out of
your app because your app's not

00:39:14.370 --> 00:39:15.560
providing them functionality.

00:39:15.600 --> 00:39:17.600
So engage your users up front.

00:39:17.600 --> 00:39:21.580
So with that,
I want to talk about another myth.

00:39:21.600 --> 00:39:27.560
Now, the myth is basically that Wi-Fi --
you should turn off Wi-Fi in order

00:39:27.560 --> 00:39:29.600
to improve location accuracy.

00:39:29.700 --> 00:39:33.240
And I think this comes about when
you've got a fitness application

00:39:33.240 --> 00:39:37.000
that's considering a user's run track,
and all of a sudden you get a

00:39:37.000 --> 00:39:40.600
Wi-Fi fix that's a very low accuracy,
and it kind of pulls you off that track.

00:39:40.600 --> 00:39:42.590
Well, the answer there is to filter it.

00:39:42.600 --> 00:39:44.700
And the reason why you want to
do that is because turning off

00:39:44.780 --> 00:39:46.600
Wi-Fi doesn't improve location accuracy.

00:39:46.600 --> 00:39:50.550
Again, this is an example of our
drive test in San Francisco.

00:39:50.680 --> 00:39:52.600
This is what you get with just GPS,
nothing else.

00:39:52.600 --> 00:39:55.460
So let's go back to our test.

00:39:55.860 --> 00:39:58.600
If you turn on Wi-Fi,
even if you're running

00:39:58.600 --> 00:40:00.700
or if you're in a car,
you get this.

00:40:00.870 --> 00:40:02.790
And if you're in a car
and you've got Wi-Fi on,

00:40:02.800 --> 00:40:04.600
you're going to get something like this.

00:40:04.730 --> 00:40:08.450
So it's really not beneficial
to your users to tell them,

00:40:08.450 --> 00:40:10.530
"Hey look, turn off Wi-Fi.

00:40:10.640 --> 00:40:13.840
Just look at the horizontal
accuracy of the position we report

00:40:13.840 --> 00:40:15.000
to you and just filter it out.

00:40:15.000 --> 00:40:16.640
Say, 'Hey look, this is not useful to me.

00:40:16.670 --> 00:40:19.500
I'm just going to ignore this one
location and wait for the next one.'"

00:40:19.880 --> 00:40:25.020
So again, user experience, no Wi-Fi,
with Wi-Fi.

00:40:25.060 --> 00:40:26.900
Leave Wi-Fi on.

00:40:27.480 --> 00:40:32.300
I went for a run in San Francisco,
just kind of generically wandered

00:40:32.300 --> 00:40:34.350
around a couple of different streets.

00:40:34.350 --> 00:40:36.360
And I ended up with a location
track that looked like this.

00:40:36.360 --> 00:40:39.380
Now, this is San Francisco, you know,
location is not necessarily the best,

00:40:39.480 --> 00:40:42.330
there's all these skyscrapers and
this and that and the other thing.

00:40:42.330 --> 00:40:45.950
Well, actually, I left my iPhone at home.

00:40:45.960 --> 00:40:48.900
I strapped an iPod Touch to
my arm and I got this track.

00:40:48.960 --> 00:40:51.560
An iPod Touch doesn't have a GPS.

00:40:51.560 --> 00:40:56.510
So this data is purely
Wi-Fi using the new tiles.

00:40:58.100 --> 00:44:51.600
[Transcript missing]

00:44:51.880 --> 00:44:53.800
Similarly, fencing.

00:44:53.820 --> 00:44:55.960
If you wanted to go ahead and
monitor a specific region,

00:44:55.960 --> 00:44:59.260
you could just tell us, hey, look,
I want to monitor this region.

00:44:59.260 --> 00:45:01.820
Or, you know,
I'm no longer interested in this region.

00:45:01.820 --> 00:45:04.940
And we'll tell you, hey, look,
the user's now gone to work or

00:45:04.940 --> 00:45:06.690
the user's now left for the day.

00:45:06.690 --> 00:45:10.500
And it's really easy to actually install
fences that are relevant to your users.

00:45:10.550 --> 00:45:13.140
You'll have the appearance
that you're running when the

00:45:13.140 --> 00:45:16.690
user needs you to be running,
but you're actually not most of the time.

00:45:17.560 --> 00:45:20.260
And then lastly,
something to keep in mind is that

00:45:20.400 --> 00:45:23.950
you can always tell UI application,
hey, I want to run longer.

00:45:23.950 --> 00:45:26.910
So why not just go ahead and
begin a background task and

00:45:26.910 --> 00:45:30.760
then start location updates,
wait for the level of fix that you want,

00:45:30.800 --> 00:45:33.080
turn it off, and then you're done.

00:45:33.100 --> 00:45:37.960
So with that, I'd like to suggest a model
for starting responsibly.

00:45:37.960 --> 00:45:41.340
So let's consider, again,
the automatic check-in app.

00:45:41.400 --> 00:45:45.030
What do you want to do when
you want to start location?

00:45:45.060 --> 00:45:48.250
Well, you want to make sure that
you can run for a little bit

00:45:48.410 --> 00:45:50.100
of time in the background.

00:45:50.110 --> 00:45:52.170
You know,
Springboard might give you 10 seconds.

00:45:52.170 --> 00:45:54.100
With this, you can grab, say,
five minutes.

00:45:54.100 --> 00:45:57.150
And then if Springboard says, hey, look,
you're out of time,

00:45:57.150 --> 00:45:58.830
you go ahead and stop location.

00:45:58.830 --> 00:46:01.200
But five minutes is
still a really long time.

00:46:01.220 --> 00:46:05.750
So what you should actually do is
you should start a timer for you.

00:46:05.750 --> 00:46:09.300
So let's say that you had a method in
your function called start location

00:46:09.300 --> 00:46:11.550
timer that just started a timer saying,
hey, look,

00:46:11.550 --> 00:46:13.020
I'm trying to get a location fix.

00:46:13.520 --> 00:46:16.240
So with that, what you could do then
is you could actually,

00:46:16.240 --> 00:46:19.460
when that timer fires, say,
after 30 seconds, maybe a minute,

00:46:19.460 --> 00:46:21.740
you could just shut
down location yourself.

00:46:21.740 --> 00:46:23.210
Say, look, for some reason,
I'm not fixing.

00:46:23.280 --> 00:46:24.560
I'm just going to turn everything off.

00:46:24.560 --> 00:46:27.920
And that's much better than waiting
for us to pause you because,

00:46:27.920 --> 00:46:30.180
again,
we're viewing it very conservatively.

00:46:30.180 --> 00:46:33.020
And so we're going to take longer
than a minute or two to be able

00:46:33.020 --> 00:46:36.500
to determine that the user's not
actually getting anything useful.

00:46:36.500 --> 00:46:39.630
So you can do it much
better with your own timer.

00:46:39.640 --> 00:46:41.240
Then once you've set up
the safety mechanisms,

00:46:41.240 --> 00:46:43.500
all you have to do is you're going
to go ahead and start the timer.

00:46:43.500 --> 00:46:45.480
You start calling the location updates
like you've already been doing.

00:46:45.480 --> 00:46:48.380
And then maybe go ahead and save a
little bit of state for yourself saying,

00:46:48.490 --> 00:46:49.940
hey, by the way, I'm running.

00:46:49.960 --> 00:46:54.390
So in that case, if you were, say,
now going to implement a

00:46:54.470 --> 00:46:58.150
significant location change handler,
again,

00:46:58.150 --> 00:47:01.240
it's just the same handler as before.

00:47:01.240 --> 00:47:02.390
So this is the new one.

00:47:02.400 --> 00:47:04.360
Location manager did update locations.

00:47:04.360 --> 00:47:07.930
And in this case, let's say you launched
due to an SLC event,

00:47:07.930 --> 00:47:10.380
a significant location change event.

00:47:10.400 --> 00:47:13.480
The result is that you
could look at that location.

00:47:13.480 --> 00:47:15.230
And you could say, hey, look,
is the location that we gave you?

00:47:15.430 --> 00:47:15.860
Take the array.

00:47:15.860 --> 00:47:16.350
Grab the last object.

00:47:16.400 --> 00:47:17.250
It's the most recent one.

00:47:17.320 --> 00:47:20.010
And you could say, hey, look,
is the accuracy of this

00:47:20.090 --> 00:47:21.550
thing good enough for me?

00:47:21.670 --> 00:47:24.330
If it's too large,
then maybe I don't really

00:47:24.360 --> 00:47:26.240
care that I'm in this city.

00:47:26.240 --> 00:47:28.140
I actually was trying to figure
out what bar I'm at so that

00:47:28.140 --> 00:47:29.210
my friends can come find me.

00:47:29.290 --> 00:47:32.640
So just go ahead and say, look,
it's not good enough.

00:47:32.900 --> 00:47:35.790
If a location's already started
because you're keeping track of that,

00:47:35.790 --> 00:47:37.060
you just sit there and wait.

00:47:37.280 --> 00:47:39.020
Eventually a better
location will come in.

00:47:39.130 --> 00:47:41.790
And you can respond with that location.

00:47:41.840 --> 00:47:43.460
Otherwise, don't worry.

00:47:43.460 --> 00:47:44.420
You can go ahead and start location.

00:47:44.420 --> 00:47:46.380
Now,
if you were launched due to an SLC event,

00:47:46.380 --> 00:47:48.440
you've got a handful of
seconds to do whatever you

00:47:48.470 --> 00:47:49.980
need before you get suspended.

00:47:49.980 --> 00:47:52.410
Since you already wrote the
start location function,

00:47:52.480 --> 00:47:55.250
now we're going to go ahead
and grab that task assertion.

00:47:55.260 --> 00:47:56.810
And we're going to get
you some more time,

00:47:56.810 --> 00:47:57.740
which is very useful.

00:47:57.760 --> 00:48:01.620
Now, eventually, sometime later,
that better accuracy came in.

00:48:01.620 --> 00:48:02.560
Wi-Fi kicked on.

00:48:02.580 --> 00:48:03.680
Or you got a GPS fix.

00:48:03.680 --> 00:48:05.620
And you now know exactly
where the user is.

00:48:05.640 --> 00:48:07.200
You're ready to tell the world about it.

00:48:07.660 --> 00:48:08.380
Update the view.

00:48:08.380 --> 00:48:09.540
Or update your data model.

00:48:09.540 --> 00:48:10.360
Or send it to the server.

00:48:10.360 --> 00:48:11.570
Do whatever you want.

00:48:11.770 --> 00:48:13.440
And then you're going to implement.

00:48:13.440 --> 00:48:14.780
Your own stop location method.

00:48:14.780 --> 00:48:16.450
I've omitted this from the sample.

00:48:16.590 --> 00:48:18.720
But your stop location event is
going to do the exact opposite

00:48:18.720 --> 00:48:20.010
of your start location event.

00:48:20.080 --> 00:48:21.880
It's going to stop the
background task assertion.

00:48:22.010 --> 00:48:25.100
It's going to turn off
the location timer.

00:48:25.220 --> 00:48:27.500
And it's just going to stop
location and set the flag to none.

00:48:27.520 --> 00:48:30.530
So it's really easy to run
in the background for short

00:48:30.630 --> 00:48:34.460
intervals of time without using
the UI background mode's key.

00:48:34.480 --> 00:48:37.750
Which is just really -- it
really will allow the user to

00:48:37.830 --> 00:48:39.760
run better in the background.

00:48:39.820 --> 00:48:42.070
Autopause is really just designed
for the apps that actually are

00:48:42.070 --> 00:48:43.400
trying to run in the background.

00:48:43.420 --> 00:48:46.660
And it's going to run a
long time in the background.

00:48:46.730 --> 00:48:49.150
I'd like to give you
guys a quick summary.

00:48:49.270 --> 00:48:53.000
So what we've done this year
is we've made horizontal

00:48:53.000 --> 00:48:55.140
accuracy better than ever.

00:48:55.310 --> 00:49:00.820
We've made location more available
than ever with both Wi-Fi on iOS

00:49:00.820 --> 00:49:06.020
devices and making APIs available
like region monitoring on OS X.

00:49:06.120 --> 00:49:08.450
And then lastly,
we've made power consumption

00:49:08.450 --> 00:49:09.540
better than ever.

00:49:09.650 --> 00:49:12.420
But in return,
I want four things from you guys.

00:49:12.550 --> 00:49:13.380
First off.

00:49:13.380 --> 00:49:15.780
I want you to run only
when you're needed.

00:49:15.910 --> 00:49:16.940
Autopause is great.

00:49:17.120 --> 00:49:19.930
But consider SLC and
consider region monitoring.

00:49:19.940 --> 00:49:24.600
They're powerful APIs that will let
you run when you actually intend to.

00:49:24.750 --> 00:49:27.280
Then I want you to tell the
user why they're using it.

00:49:27.280 --> 00:49:30.590
And I want you to use the new
NS location usage description key.

00:49:30.730 --> 00:49:32.700
And I want you to honor that contract.

00:49:32.820 --> 00:49:35.400
Don't let your users be surprised
by the arrow popping on.

00:49:35.550 --> 00:49:39.470
Actually just do what the user
expects with their location.

00:49:39.780 --> 00:49:42.340
Next, specify user's activity.

00:49:42.450 --> 00:49:45.640
If you're being a map application,
tell me your other.

00:49:45.780 --> 00:49:47.480
If all of a sudden the user
gets in a car and you start

00:49:47.550 --> 00:49:50.390
giving them driving directions,
flip your activity type

00:49:50.420 --> 00:49:52.100
to vehicular navigation.

00:49:52.270 --> 00:49:54.330
Keep me up to date about what
the user's doing and I can help

00:49:54.330 --> 00:49:56.810
make sure your app gets the best
performance out of AutoPause.

00:49:57.560 --> 00:50:00.300
And then lastly, leave Wi-Fi on.

00:50:00.320 --> 00:50:01.410
Don't tell your users to turn it off.

00:50:01.410 --> 00:50:04.100
Let your users get the best
location experience possible.

00:50:04.100 --> 00:50:08.060
I'd like you to point you to a
couple places for more information.

00:50:08.060 --> 00:50:10.160
Paul Marcos, pmarcos at apple.com.

00:50:10.160 --> 00:50:11.720
He's a great point of contact.

00:50:11.870 --> 00:50:14.760
He's definitely helped me with
these slides and he's really

00:50:14.790 --> 00:50:17.940
been a good resource for just
interacting with you guys.

00:50:17.940 --> 00:50:19.970
We've got some documentation online.

00:50:19.970 --> 00:50:21.660
We also have developer forums.

00:50:21.790 --> 00:50:23.200
Feel free to check those out.

00:50:23.300 --> 00:50:28.510
If you've got a time machine or
you just go ahead and online later,

00:50:28.510 --> 00:50:32.190
you can go ahead and watch the
using map kit app because many of

00:50:32.200 --> 00:50:36.000
you will want to use location by
presenting it to the user using maps.

00:50:36.000 --> 00:50:39.880
So I would recommend downloading that
after the sessions become available.

00:50:39.880 --> 00:50:43.350
CoreMotion is another great way
to provide context on your device.

00:50:43.370 --> 00:50:46.910
Knowing what the user's doing with
your device is almost as powerful as

00:50:46.910 --> 00:50:48.830
knowing where they are in the world.

00:50:48.830 --> 00:50:51.540
So go ahead and check out
Andy's talk on Friday.

00:50:51.540 --> 00:50:53.920
So with that,
I'd like to thank you for coming.
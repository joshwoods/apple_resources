WEBVTT

00:00:10.550 --> 00:00:11.800
Good afternoon.

00:00:11.830 --> 00:00:14.790
My name is Kevin Perry,
and I'm an engineer on

00:00:14.800 --> 00:00:16.290
the Cocoa Frameworks team.

00:00:16.520 --> 00:00:21.440
Today, we're talking about using
iCloud with NSDocument.

00:00:23.280 --> 00:00:27.840
Your users get their work done
inside of your application.

00:00:27.910 --> 00:00:31.850
And we want to eliminate as many
distractions that take them out

00:00:31.900 --> 00:00:33.880
of your application as possible.

00:00:34.800 --> 00:00:39.800
There are some cloud implementations
expose themselves as a folder or volume

00:00:39.800 --> 00:00:44.080
that requires the users to often drop
down into Finder to manage their files,

00:00:44.150 --> 00:00:48.620
organize them,
and do things like resolve conflicts.

00:00:49.540 --> 00:00:53.080
With iCloud,
we're able to remove these distractions

00:00:53.080 --> 00:00:58.990
by integrating the iCloud experience
directly into the application.

00:00:59.880 --> 00:01:02.630
This provides a seamless user experience.

00:01:02.820 --> 00:01:05.200
The user is able to resolve
conflicts right in the app.

00:01:05.430 --> 00:01:08.890
They're able to manage their
documents without having to

00:01:08.890 --> 00:01:10.540
go into Finder and so forth.

00:01:10.730 --> 00:01:15.980
This integration does put additional
responsibility on applications.

00:01:16.150 --> 00:01:19.790
However, for document-based
applications on Mountain Lion,

00:01:19.890 --> 00:01:24.140
NSDocument takes care of all
the UI and functionality that

00:01:24.140 --> 00:01:28.890
is required from document-based
applications when using iCloud.

00:01:30.220 --> 00:01:32.970
These features include file coordination,
which is required to properly

00:01:32.970 --> 00:01:37.330
communicate changes to and from iCloud.

00:01:38.060 --> 00:01:44.890
Document Management UI,
Conflict Notification and Resolution UI,

00:01:44.890 --> 00:01:47.200
and alerts for exceptional situations.

00:01:47.300 --> 00:01:50.340
For example,
when a user's document isn't being

00:01:50.340 --> 00:01:55.150
uploaded to iCloud because they're over
quota with their document storage space.

00:01:55.740 --> 00:01:59.040
So let's dive in and talk about
the first step to enabling

00:01:59.040 --> 00:02:02.440
these iCloud document features,
and that's adopting iCloud in

00:02:02.440 --> 00:02:04.360
general in your application.

00:02:06.300 --> 00:02:08.140
To do this,
you need to properly set up your

00:02:08.140 --> 00:02:10.510
application's provisioning profile.

00:02:10.670 --> 00:02:15.160
Provisioning profile is a document
that identifies your development team,

00:02:15.300 --> 00:02:18.550
defines the devices your
application can run on,

00:02:18.710 --> 00:02:22.580
And grants iCloud support
to your applications.

00:02:22.580 --> 00:02:24.980
And finally,
defines your Ubiquiti container,

00:02:25.020 --> 00:02:30.890
which is the location on the local
computer where the instance of your

00:02:30.940 --> 00:02:34.720
user's documents are saved with iCloud.

00:02:36.310 --> 00:02:40.400
The provisioning profile is
configured and downloaded

00:02:40.400 --> 00:02:43.800
from the provisioning portal,
which is on the developer website.

00:02:43.800 --> 00:02:47.760
There's lots of documentation there about
how to set that up there on the website,

00:02:47.760 --> 00:02:49.360
so I'll just refer you to that.

00:03:12.200 --> 00:03:12.200
The next step is to add proper
entitlements to your application.

00:03:12.200 --> 00:03:12.200
And this is really as simple as just a
few clicks in Xcode in the new version.

00:03:12.200 --> 00:03:12.200
So let me go ahead and switch to
a demo where I can show you this.

00:03:12.200 --> 00:03:12.200
Here we have the venerable
Sketch sample application.

00:03:12.200 --> 00:03:12.200
And first thing I want to show
you is here in the organizer.

00:03:13.090 --> 00:03:17.260
You can see in the provisioning profiles,
I've already got my provisioning

00:03:17.260 --> 00:03:20.800
profile that I've configured
for Sketch imported here.

00:03:20.950 --> 00:03:22.980
So that's really the first step.

00:03:23.630 --> 00:03:28.530
The next is to go to the project summary.

00:03:28.630 --> 00:03:30.500
And down here you see

00:03:30.710 --> 00:03:33.660
An option to enable entitlements.

00:03:33.930 --> 00:03:35.750
So let's click that.

00:03:36.580 --> 00:03:38.660
We don't need sandboxing
for this particular demo,

00:03:38.660 --> 00:03:43.780
but we do want to now add an iCloud
container for this application.

00:03:44.270 --> 00:03:45.180
Kick Plus.

00:03:45.180 --> 00:03:48.700
NX code automatically populates
this with the container name that

00:03:48.700 --> 00:03:52.640
I specified in the provisioning profile.

00:03:55.020 --> 00:03:57.760
The last step is to switch over to
build settings here and make sure

00:03:57.760 --> 00:04:01.680
that we're signing the application
with the proper identity.

00:04:02.240 --> 00:04:06.200
See here I have the one that matches
the provisioning profile for Sketch.

00:04:06.320 --> 00:04:08.190
Select that.

00:04:08.240 --> 00:04:10.090
Build and run.

00:04:13.900 --> 00:04:15.570
And here we have Sketch,
and the first thing you

00:04:15.570 --> 00:04:19.460
see is the new open panel,
which you saw during the keynote.

00:04:19.920 --> 00:04:23.100
This is built directly into the
application and provides a very

00:04:23.100 --> 00:04:28.600
simple and familiar user interface
for managing iCloud documents.

00:04:28.680 --> 00:04:32.210
It's a matter of double-clicking
to open a document.

00:04:32.820 --> 00:04:38.900
And to add or remove documents to iCloud,
the user can simply drag a document in.

00:04:39.890 --> 00:04:42.740
or drag it back out similarly.

00:04:42.780 --> 00:04:47.120
And they can even delete
documents directly from iCloud.

00:04:47.220 --> 00:04:50.840
So any of the file management that a user
would need to do with iCloud documents

00:04:50.840 --> 00:04:53.020
is handled right here in the open panel.

00:04:53.050 --> 00:04:56.110
You don't need to implement that
yourself in your application.

00:04:56.800 --> 00:05:02.610
Also, I have a document here that,
when I open it, presents me with a

00:05:02.610 --> 00:05:04.820
conflict resolution panel.

00:05:04.950 --> 00:05:08.690
And I can get additional
information about these documents,

00:05:08.710 --> 00:05:11.600
a preview,
so I can make an informed decision

00:05:11.600 --> 00:05:13.980
about which one I want to keep.

00:05:16.060 --> 00:05:19.540
Finally,
you'll notice that when I create a

00:05:19.550 --> 00:05:22.230
new document and start to edit it,

00:05:22.510 --> 00:05:25.550
The document is automatically
saved into iCloud.

00:05:25.550 --> 00:05:30.000
And this makes it really easy for users
to get their documents into iCloud and

00:05:30.000 --> 00:05:31.880
share them between other applications.

00:05:32.020 --> 00:05:35.190
It provides a really
streamlined user experience.

00:05:36.230 --> 00:05:40.840
So that's a very quick demo of all
of NSDoctument's iCloud features.

00:05:40.870 --> 00:05:44.440
As I said,
the first step to doing that is enabling,

00:05:44.500 --> 00:05:48.550
configuring your provisioning profile
and enabling those entitlements.

00:05:49.940 --> 00:05:54.730
There is one other thing that I,
one other modification I made to

00:05:54.730 --> 00:05:58.440
the sample application beforehand,
and I want to talk about this before

00:05:58.440 --> 00:06:04.500
we talk about more iCloud topics,
and that's Auto Save.

00:06:04.700 --> 00:06:07.560
Auto Save is a feature
that we added in Lion,

00:06:07.650 --> 00:06:11.760
and we really encourage all
NSDoctument-based applications

00:06:11.880 --> 00:06:14.240
to adopt this feature.

00:06:14.580 --> 00:06:17.500
There are a lot of reasons
why you'd want to do this.

00:06:17.980 --> 00:06:20.600
First and foremost,
it provides a modern document workflow

00:06:21.140 --> 00:06:25.260
so that users aren't required to think
about the difference of what's on screen

00:06:25.740 --> 00:06:28.270
and what's on disk at any given time.

00:06:28.340 --> 00:06:32.210
To the user, we give them an illusion
that they're the same,

00:06:32.260 --> 00:06:34.340
and effectively they are.

00:06:34.400 --> 00:06:36.390
Enabling Auto Save also
gives you versions,

00:06:36.460 --> 00:06:39.760
which allows you to go back in
time and revert to a previous

00:06:39.770 --> 00:06:41.380
version of the document.

00:06:43.090 --> 00:06:46.440
Adopting Auto Save also provides
a more seamless experience with

00:06:46.500 --> 00:06:51.000
auto termination and resume,
since we're not required to ask

00:06:51.110 --> 00:06:54.000
the user about unsaved changes.

00:06:55.540 --> 00:06:59.100
As I mentioned, in order to get all of
NSDoctument's iCloud features,

00:06:59.110 --> 00:07:01.570
you need to use Auto Save.

00:07:02.150 --> 00:07:06.420
One of the primary reasons is that
enabling Auto Save turns on an

00:07:06.570 --> 00:07:10.340
implementation of file coordination
that's built into NSDocument.

00:07:10.460 --> 00:07:13.170
Enabling Auto Save is very simple.

00:07:13.620 --> 00:07:16.580
In your document subclass,
override autosaves in

00:07:16.580 --> 00:07:17.670
place and return yes.

00:07:17.800 --> 00:07:20.780
But what implications does
this have for your application?

00:07:20.780 --> 00:07:25.260
In short, it causes NSDoctument to use
two new saving operations,

00:07:25.260 --> 00:07:29.440
NSAutosaveElsewhere operation
and NSAutosaveInPlace operation.

00:07:29.460 --> 00:07:33.900
Before I talk about these new saving
operations that we added in Lion,

00:07:33.900 --> 00:07:36.970
let me talk about the other
saving operations that already

00:07:36.970 --> 00:07:40.180
exist in NSDoctument and have
since the beginning of OS X.

00:07:40.760 --> 00:07:43.990
The first is a save in place,
which we show to the

00:07:44.060 --> 00:07:48.610
user in the UI as save,
and the API for that is NSSaveOperation.

00:07:48.620 --> 00:07:52.490
The way this works is a
document references a file,

00:07:52.550 --> 00:07:58.200
and as changes are made to the
document and save with NSSaveOperation,

00:07:58.200 --> 00:08:03.270
we safely replace the contents of that
referenced file with the new ones.

00:08:06.650 --> 00:08:10.810
Save elsewhere,
which we expose to the user as export,

00:08:10.820 --> 00:08:14.940
and in the API is called
NSSaveToOperation.

00:08:14.940 --> 00:08:18.360
This works by prompting
the user for a location,

00:08:18.360 --> 00:08:21.070
and then this document saves
the current contents of the

00:08:21.070 --> 00:08:24.620
document to that new location,
and then promptly forgets about it,

00:08:24.620 --> 00:08:28.950
and continues to save changes
that are made to the document

00:08:28.950 --> 00:08:30.820
to the original file.

00:08:30.820 --> 00:08:34.840
Save elsewhere and redirect is
exposed to the user as SaveAs,

00:08:35.070 --> 00:08:37.700
and in the API, NSSaveAs operation.

00:08:37.700 --> 00:08:39.520
This works very similar
to Save Elsewhere,

00:08:39.520 --> 00:08:43.990
in that we prompt the user for
a location and save the current

00:08:44.220 --> 00:08:46.020
contents of the document there.

00:08:47.950 --> 00:08:50.520
However, from that point,
the document now starts to

00:08:50.520 --> 00:08:55.330
reference this newly created file
and forgets about the old one.

00:08:55.540 --> 00:08:59.990
Users often use this as a sort
of ad hoc versioning mechanism.

00:09:02.790 --> 00:09:07.310
When enabling auto saving in place,
we add a new column to this table.

00:09:07.400 --> 00:09:11.330
All the prior three operations
are all user-initiated,

00:09:11.330 --> 00:09:13.210
but these new ones happen automatically.

00:09:13.290 --> 00:09:15.360
They happen automatically
for several reasons.

00:09:15.520 --> 00:09:17.580
For example,
when the user edits a document,

00:09:17.600 --> 00:09:20.710
and this document will start
a timer and aims to save the

00:09:20.710 --> 00:09:23.810
document when the user is idle.

00:09:24.090 --> 00:09:26.760
Also, when the user switches
away from an application,

00:09:26.760 --> 00:09:29.210
that's a good hint that
it's a good time to save,

00:09:29.270 --> 00:09:32.380
and indeed, the user might be trying
to use that document to,

00:09:32.420 --> 00:09:38.020
for example, attach the file to an email.

00:09:38.470 --> 00:09:43.150
Also, file coordination can sometimes
prompt your NSDoctument to save

00:09:43.630 --> 00:09:48.090
itself so that whatever operation
reader or writer is trying to access

00:09:48.140 --> 00:09:51.070
your document has the latest contents.

00:09:52.480 --> 00:09:54.530
Let's start with
NSAutoSaveElsewhere operation.

00:09:54.770 --> 00:09:59.520
This is similar to export in that
it uses a completely different file

00:09:59.520 --> 00:10:00.960
than the one the document references.

00:10:00.960 --> 00:10:04.870
NSDocument uses this for
untitled documents that are

00:10:04.880 --> 00:10:07.420
kept locally on the computer.

00:10:07.420 --> 00:10:11.850
Since untitled documents don't have a
user-visible file associated with them,

00:10:11.880 --> 00:10:18.000
but we still want to ensure crash
protection and resume functionality,

00:10:18.680 --> 00:10:22.540
NSDocument uses NSAutoSaveElsewhere
operation to save any changes that are

00:10:22.550 --> 00:10:26.560
made to the file in a hidden location
in the user's library directory.

00:10:26.560 --> 00:10:31.370
This file remains until the
user finally chooses to save as.

00:10:31.500 --> 00:10:37.770
A user-visible file is created,
and the autosaved document is deleted.

00:10:39.330 --> 00:10:45.140
And it's Auto Save in Place operation
acts very much like an SAVE operation

00:10:45.140 --> 00:10:49.690
in that when the user makes changes,
we save the contents directly over

00:10:49.800 --> 00:10:52.090
the existing file in a safe manner.

00:10:52.570 --> 00:10:56.050
The only difference is that this
happens automatically without

00:10:56.050 --> 00:10:58.250
any direct user interaction.

00:10:59.630 --> 00:11:02.150
Let me show you another quick demo.

00:11:02.460 --> 00:11:06.500
First, let's go back to the code
and my document subclass,

00:11:06.500 --> 00:11:07.380
SKT document.

00:11:07.420 --> 00:11:11.290
And you can see here that I have
indeed overridden auto saves in place,

00:11:11.290 --> 00:11:13.370
and I'm returning yes.

00:11:13.550 --> 00:11:20.500
And while Sketch is a simple application,
it conforms very well to NSDoctumets API.

00:11:20.560 --> 00:11:23.120
And any application,
even a more complex one,

00:11:23.120 --> 00:11:28.010
that behaves properly like Sketch,
will have an easy time

00:11:28.060 --> 00:11:30.200
of enabling Auto Save.

00:11:33.390 --> 00:11:35.780
So let's go back to the application.

00:11:35.780 --> 00:11:38.220
And you can see as I'm making
changes to the document,

00:11:38.260 --> 00:11:40.940
up here in the title bar,
you see that there's an indication

00:11:40.940 --> 00:11:42.500
that the document has been edited.

00:11:42.530 --> 00:11:46.380
This is a notification to the user
that the document has been changed in

00:11:46.530 --> 00:11:48.590
case they have made unintended edits.

00:11:48.590 --> 00:11:52.270
And right here,
convenient in the title bar,

00:11:52.360 --> 00:11:56.170
is an option to revert to
the last unsaved version,

00:11:56.170 --> 00:11:59.340
in this case, the last open version.

00:11:59.430 --> 00:12:02.090
And we convert to that very easily.

00:12:02.680 --> 00:12:05.310
Also,
if I make changes and close the window,

00:12:05.310 --> 00:12:07.840
I'm not prompted about
those changes because,

00:12:07.850 --> 00:12:11.130
again,
what we see on the screen is effectively

00:12:11.130 --> 00:12:13.280
what's on disk at any given time.

00:12:14.760 --> 00:12:18.940
Finally, we also have the option
to browse versions.

00:12:18.940 --> 00:12:23.280
We're taken into this time machine-like
interface where we can browse previous

00:12:23.280 --> 00:12:26.700
versions and choose one to restore.

00:12:26.750 --> 00:12:31.370
So that's a very quick overview
of the features that enabling

00:12:31.490 --> 00:12:33.700
Auto Save buys your users.

00:12:35.170 --> 00:12:39.910
And again, we feel that this is the
future of NSDoctument,

00:12:40.430 --> 00:12:44.680
and new features like iCloud and
those that might come in the future

00:12:44.880 --> 00:12:50.680
will very likely be reliant on
auto saving to function completely.

00:12:50.750 --> 00:12:54.580
When enabling auto save,
obviously we're going to be saving

00:12:54.660 --> 00:12:59.440
without the user's knowledge and
more frequently than the user might.

00:12:59.500 --> 00:13:02.350
Because of this,
we need to ensure that the application

00:13:02.350 --> 00:13:04.600
remains responsive while auto saving.

00:13:05.410 --> 00:13:08.590
The best approach to remaining
responsive during autosaving is to make

00:13:08.640 --> 00:13:12.930
sure that you are saving efficiently,
that your serialization of your

00:13:12.930 --> 00:13:17.480
in-memory contents is efficient,
that you're not saving

00:13:17.480 --> 00:13:20.570
unnecessary data into your file,
and so forth.

00:13:20.620 --> 00:13:23.470
However, there are some things that are
out of your control when it comes

00:13:23.470 --> 00:13:26.040
to autosaving responsiveness,
such as file system latency.

00:13:26.120 --> 00:13:32.440
In Lion, we had a couple of approaches
to help improve responsiveness.

00:13:33.420 --> 00:13:35.190
The first is asynchronous saving.

00:13:35.220 --> 00:13:38.330
The way this works is
that when saving begins,

00:13:38.420 --> 00:13:41.500
you take a snapshot of
your document's state,

00:13:41.550 --> 00:13:44.970
and then on a background thread,
NSDocument will have you serialize

00:13:44.970 --> 00:13:46.510
that and write that out to disk.

00:13:46.540 --> 00:13:49.480
And this frees the main thread so
the user can continue interacting

00:13:49.490 --> 00:13:52.070
with your application and
even the very same document.

00:13:55.720 --> 00:14:00.550
If asynchronous saving isn't feasible
for your application for whatever reason,

00:14:00.780 --> 00:14:02.220
there's also cancelable auto saves.

00:14:02.220 --> 00:14:06.480
The way this works is that
during a save operation,

00:14:06.480 --> 00:14:09.030
you can peek at the event loop
to see if the user is trying to

00:14:09.100 --> 00:14:10.760
interact with your application.

00:14:10.760 --> 00:14:14.060
And if so,
cancel the auto save if appropriate,

00:14:14.060 --> 00:14:18.580
returning control to the run loop
and allowing the user to continue

00:14:18.580 --> 00:14:21.290
interacting with the application.

00:14:22.120 --> 00:14:25.090
And then NSDocument will respond
by scheduling the auto save for

00:14:25.090 --> 00:14:28.080
some time in the near future
when hopefully the user is idle.

00:14:31.010 --> 00:14:32.550
For more information
about these techniques,

00:14:32.550 --> 00:14:36.250
you can see the talk that we gave
last year on Auto Save and versions.

00:14:36.260 --> 00:14:39.510
That's available at developer.apple.com.

00:14:39.590 --> 00:14:43.320
Another thing you need to consider
when enabling Auto Save and

00:14:43.320 --> 00:14:45.160
iCloud is serialization.

00:14:47.110 --> 00:14:50.620
There are a couple of resources
in NSDoctument that need to be

00:14:50.620 --> 00:14:54.920
serialized properly when you have
asynchronous things happening like

00:14:55.190 --> 00:14:57.960
autosaving and events from iCloud.

00:14:58.110 --> 00:15:03.450
The first is User Activities,
and the next is File Access.

00:15:03.520 --> 00:15:06.070
Let's talk about User Activities first.

00:15:06.660 --> 00:15:12.080
These include operations like Save,
Revert, Duplicate, Print,

00:15:12.110 --> 00:15:17.410
and new in Mountain Lion, Move, Rename,
and iCloud Conflict Resolution.

00:15:17.920 --> 00:15:22.590
All of these activities are started
either directly or indirectly by the

00:15:22.680 --> 00:15:25.580
user and have a few things in common.

00:15:25.600 --> 00:15:30.380
Most of them show some sort of UI that
allows the user to instruct you how

00:15:30.380 --> 00:15:32.500
the operation is to be performed.

00:15:32.770 --> 00:15:36.570
Sometimes, the performing that operation
results in errors that need

00:15:36.610 --> 00:15:40.090
to be presented to the user,
and those errors can

00:15:40.090 --> 00:15:42.150
provide paths for recovery.

00:15:43.060 --> 00:15:47.380
All of these steps are
wrapped up in an activity.

00:15:47.610 --> 00:15:50.100
Let's use printing as an example.

00:15:50.240 --> 00:15:54.290
Suppose the user is in the
middle of printing a document.

00:15:56.080 --> 00:15:59.200
And all of a sudden,
we receive a conflict from iCloud.

00:15:59.200 --> 00:16:03.300
NSDocument is going to try to show
the conflict resolution panel,

00:16:03.300 --> 00:16:07.000
which involves showing
a sheet on the window.

00:16:07.080 --> 00:16:09.370
However,
if the user is in the middle of printing,

00:16:09.480 --> 00:16:12.420
they're not really going to be
able to understand properly what

00:16:12.590 --> 00:16:14.360
it means to resolve the conflict.

00:16:14.430 --> 00:16:17.550
And indeed, if we were to attempt to
do this simultaneously,

00:16:17.670 --> 00:16:20.560
it plain wouldn't work because
both printing and conflict

00:16:20.560 --> 00:16:25.430
resolution use sheets,
modal UI on the window that requires

00:16:25.430 --> 00:16:27.040
exclusive access to that window.

00:16:27.210 --> 00:16:31.050
You can't have two sheets visible
on the same window at the same time.

00:16:32.430 --> 00:16:37.300
The solution to this is an API that
we added in line on NSDoctument called

00:16:37.300 --> 00:16:39.960
PerformActivityWithSynchronousWaiting
using Block.

00:16:39.990 --> 00:16:43.770
We wrap this entire activity
from beginning to end in the

00:16:43.770 --> 00:16:46.000
block that we passed to this API.

00:16:46.200 --> 00:16:52.340
And what NSDoctument will do once we've
done this is it will cause the subsequent

00:16:52.340 --> 00:16:56.960
activities to be deferred until all
previous activities have been completed.

00:16:57.010 --> 00:17:01.350
And we signal completion by
invoking the completion handle

00:17:01.370 --> 00:17:03.750
that's passed to this block.

00:17:04.550 --> 00:17:08.450
Now, if your application doesn't
provide any custom activities,

00:17:08.450 --> 00:17:10.730
you don't really need
to think about this API.

00:17:11.130 --> 00:17:15.040
However, for those of you who do,
I want to stress one point to make

00:17:15.040 --> 00:17:19.940
sure that in every path in your
blocks inside perform activity that

00:17:19.940 --> 00:17:24.680
you invoke the completion handler
because the results are not pleasant.

00:17:25.840 --> 00:17:29.950
If you're not invoking the completion
handler and this document doesn't

00:17:29.970 --> 00:17:34.170
realize that the activity is completed,
and all future activities get pushed

00:17:34.570 --> 00:17:39.070
off into the future and never happen
until that completion handler is invoked.

00:17:39.070 --> 00:17:41.570
This can result in
problems like deadlock,

00:17:41.570 --> 00:17:43.350
which we want to avoid.

00:17:44.190 --> 00:17:48.150
Let me show you a quick demo of a
situation that we ran into when an

00:17:48.300 --> 00:17:53.230
application was adopting iCloud,
where perform activity with synchronous

00:17:53.250 --> 00:17:56.130
waiting was required to solve a problem.

00:17:56.890 --> 00:17:59.690
We'll use Sketch again to
replicate this same scenario.

00:18:00.460 --> 00:18:02.840
I'll go to my Window Controller subclass.

00:18:03.720 --> 00:18:09.430
And here in an override of show window,
I'm going to enable some code that shows

00:18:09.430 --> 00:18:13.360
an alert that basically just tells you
how many documents are in the window.

00:18:13.610 --> 00:18:14.570
And here in the window,
I'm going to enable some code that shows

00:18:14.700 --> 00:18:15.500
how many graphics are in the document.

00:18:16.180 --> 00:18:18.650
Not a particularly useful
bit of information,

00:18:18.650 --> 00:18:21.780
but you can imagine an application
that shows an alert when,

00:18:21.820 --> 00:18:25.820
for example, there's fonts missing that
are required by that document.

00:18:26.620 --> 00:18:29.900
So let's go ahead and build and
run with these changes and open

00:18:30.030 --> 00:18:33.410
up this document that I showed
you before has conflicts on it.

00:18:35.140 --> 00:18:37.800
You see here,
the alert comes up as expected.

00:18:37.920 --> 00:18:41.500
However, when I dismiss this alert,
nothing happens.

00:18:41.560 --> 00:18:45.080
I'm not shown the
conflict resolution panel.

00:18:45.150 --> 00:18:48.080
And if I try to interact
with that document further,

00:18:48.080 --> 00:18:49.550
the application hangs.

00:18:49.670 --> 00:18:51.380
So something is definitely wrong here.

00:18:51.620 --> 00:18:55.190
What's happening is that the alert,
the sheet for this alert

00:18:55.440 --> 00:18:59.380
that I'm trying to show,
is competing with the conflict resolution

00:18:59.390 --> 00:19:02.280
panel that NSDoctument is trying to show.

00:19:02.510 --> 00:19:04.690
So as I showed you before,

00:19:04.880 --> 00:19:08.910
We can serialize these so they happen
one at a time and don't compete by using

00:19:08.970 --> 00:19:11.240
performActivityWithSynchronousWaiting.

00:19:11.300 --> 00:19:14.540
In this case, I'm passing no because
this isn't an action that's

00:19:14.540 --> 00:19:17.140
initiated directly by the user.

00:19:17.210 --> 00:19:19.710
And I'll move all of this

00:19:20.300 --> 00:19:33.300
[Transcript missing]

00:19:33.900 --> 00:19:39.900
[Transcript missing]

00:19:40.300 --> 00:19:42.840
And what I'm doing here is
I'm invoking this method,

00:19:42.860 --> 00:19:45.770
which I have up here,
that basically just invokes

00:19:45.860 --> 00:19:48.160
the block that's passed in
as the context info pointer.

00:19:48.160 --> 00:19:51.660
And here I'm passing in the
activity completion handler.

00:19:53.500 --> 00:20:08.600
[Transcript missing]

00:20:08.870 --> 00:20:11.040
So let's go ahead and build and run now.

00:20:11.070 --> 00:20:12.740
And open this document.

00:20:12.740 --> 00:20:16.600
We get the alert that I am showing.

00:20:16.830 --> 00:20:19.420
And once that's dismissed,
the conflict resolution

00:20:19.420 --> 00:20:22.560
panel properly appears,
and we can resolve the conflict.

00:20:22.760 --> 00:20:25.690
These two activities have
been properly serialized,

00:20:25.790 --> 00:20:27.520
so they're no longer competing.

00:20:27.680 --> 00:20:30.130
The next kind of serialized
resource is file access.

00:20:30.290 --> 00:20:35.370
And what I mean by file access is
anything inside of your document

00:20:35.370 --> 00:20:41.140
that needs to be synchronized with
the state of the document's file.

00:20:41.350 --> 00:20:47.120
This includes the URL, modification date,
the in-memory representation

00:20:47.120 --> 00:20:51.600
of the on-disk contents,
and the edit state of the document,

00:20:51.700 --> 00:20:52.640
among other things.

00:20:52.830 --> 00:20:58.290
So reading or writing any of this
information should be done protected

00:20:58.380 --> 00:21:02.720
by the file access serialization
APIs that NSDoctument provides,

00:21:02.730 --> 00:21:07.020
or else you could be working with
an incomplete or an inconsistent

00:21:07.020 --> 00:21:08.710
state of your document.

00:21:09.260 --> 00:21:11.650
There are two types of file access APIs.

00:21:11.810 --> 00:21:16.090
There's a synchronous API that blocks
the main thread until all previous,

00:21:16.100 --> 00:21:19.250
or the thread that it's invoked on,
until all previous file access

00:21:19.250 --> 00:21:20.940
attempts have completed.

00:21:20.940 --> 00:21:24.590
It's invoked synchronously,
and when the block that

00:21:24.700 --> 00:21:28.080
you pass to it returns,
the file access for that block

00:21:28.120 --> 00:21:30.790
is relinquished automatically.

00:21:33.440 --> 00:21:37.340
There's also an asynchronous API,
which works by enqueuing the

00:21:37.340 --> 00:21:39.100
block and returning immediately.

00:21:39.170 --> 00:21:43.790
And that block will be invoked sometime
in the near future when all previous

00:21:43.830 --> 00:21:46.450
file access attempts have completed.

00:21:46.580 --> 00:21:49.940
This asynchronous API is
required to work safely with

00:21:50.100 --> 00:21:52.240
documents on non-main threads.

00:21:53.120 --> 00:21:55.710
And when doing so,
when you need to resume work

00:21:55.770 --> 00:21:59.150
on the main thread prior to
relinquishing file access,

00:21:59.330 --> 00:22:02.430
you need to be sure to do that
using continuous synchronous

00:22:02.460 --> 00:22:05.450
work on main thread using block,
which is another API in

00:22:05.450 --> 00:22:06.960
NSDocument that we added in Lion.

00:22:06.960 --> 00:22:13.520
And it helps avoid deadlocks that can
happen in this particular scenario.

00:22:13.520 --> 00:22:16.380
And there's a lot more information
about this API in last year's

00:22:16.410 --> 00:22:18.220
Auto Save Inversions talk as well.

00:22:24.490 --> 00:22:26.060
Sometimes bugs happen.

00:22:26.330 --> 00:22:29.440
You forget to call the completion
handler for an activity or

00:22:29.440 --> 00:22:33.470
an asynchronous file access,
and the result is things like

00:22:33.950 --> 00:22:36.130
hangs and blocks never executing.

00:22:36.540 --> 00:22:40.000
Sometimes these hangs happen,
and you look at the backtrace,

00:22:40.000 --> 00:22:42.340
and you don't see any of your own code.

00:22:42.420 --> 00:22:48.200
Instead of assuming that it's
a bug with the framework,

00:22:48.500 --> 00:22:52.610
You should consider problems that
might be within your own application.

00:22:52.620 --> 00:22:55.000
However,
these were very hard to find in line

00:22:55.180 --> 00:23:00.000
because there wasn't any information
in the backtrace or so forth.

00:23:01.950 --> 00:23:04.230
In Mountain Lion,
we've made this debugging experience

00:23:04.240 --> 00:23:07.580
easier by leaving breadcrumbs,
stack traces,

00:23:07.580 --> 00:23:13.890
wherever activity and file access
APIs are used so that you can go

00:23:13.900 --> 00:23:16.380
back and trace this information.

00:23:16.590 --> 00:23:19.710
You can access this with a
debug function called underbar

00:23:19.710 --> 00:23:21.560
NSDocumentSerializationInfo.

00:23:21.630 --> 00:23:24.260
And this name could change at any time.

00:23:24.260 --> 00:23:25.670
It's not in any headers.

00:23:25.820 --> 00:23:28.560
So again, please don't use this in code.

00:23:28.610 --> 00:23:31.080
But you're welcome to
use it in the debugger.

00:23:32.430 --> 00:23:34.840
I'll show you a quick
example of a case where,

00:23:34.840 --> 00:23:36.820
how you might use this.

00:23:36.830 --> 00:23:40.540
I've got an application that's hanging,
so I look at the back trace and

00:23:40.600 --> 00:23:44.240
I see code that doesn't belong to me,
it belongs in NSDoctuMent.

00:23:44.290 --> 00:23:48.860
But near the top of the stack is perform
synchronous file access using the block.

00:23:49.040 --> 00:23:54.240
So I assume that there's a previous
file access attempt that's not finishing

00:23:54.240 --> 00:23:56.540
up and blocking this particular one.

00:23:57.270 --> 00:24:00.970
So I PO underbar NSDocument
serialization info,

00:24:00.970 --> 00:24:04.340
and this dumps a bunch of information
that helps me track down the problem.

00:24:04.440 --> 00:24:09.870
First I find the stack trace
that matches the current hang,

00:24:10.200 --> 00:24:14.500
and I see that it is indeed waiting
for previous file access to complete.

00:24:15.700 --> 00:24:21.370
By looking up earlier in this dump,
we see an active file access

00:24:22.570 --> 00:24:26.240
that was initiated by a method
called DoSomethingWithFile.

00:24:26.260 --> 00:24:30.670
While it could be possible that this
is just taking a long time to complete,

00:24:44.870 --> 00:24:44.870
I suspect that there might
actually be a bug here.

00:24:44.870 --> 00:24:44.870
So let's look at the code.

00:24:44.870 --> 00:24:44.870
Hopefully this looks
familiar to my earlier demo.

00:24:44.870 --> 00:24:44.870
We see an attempt to perform
asynchronous file access.

00:24:45.020 --> 00:24:47.590
And inside here,
when the file URL is not nil,

00:24:47.730 --> 00:24:49.660
we perform some file access.

00:24:49.670 --> 00:24:54.100
And in this completion handler,
we invoke the completion handler for the

00:24:54.460 --> 00:24:57.470
Perform Asynchronous File Access API.

00:24:58.350 --> 00:25:02.780
Those of you with a sharp eye will
notice that when the file URL is not nil,

00:25:02.810 --> 00:25:04.900
I was failing to call
the completion handler,

00:25:04.940 --> 00:25:11.090
which resulted in all future file
access attempts to block infinitely.

00:25:12.940 --> 00:25:17.610
So this debug functionality that
we've added in Mountain Lion makes

00:25:18.060 --> 00:25:21.110
pinpointing this problem a lot easier.

00:25:22.920 --> 00:25:27.300
The last topic on Auto Save is versions.

00:25:27.390 --> 00:25:30.190
Versions is how we implement
revert functionality in

00:25:30.200 --> 00:25:33.180
Auto Saving applications,
and also the versions browser.

00:25:33.330 --> 00:25:37.050
It works by NSDoctument periodically
preserving document contents

00:25:37.520 --> 00:25:39.500
when it deems appropriate.

00:25:40.320 --> 00:25:43.270
does this in a very
disk-space efficient manner,

00:25:43.270 --> 00:25:47.140
only saving the changes that
were made from previous versions.

00:25:48.510 --> 00:25:50.540
And it's important to note that
this happens automatically.

00:25:50.750 --> 00:25:55.170
Most applications don't need to
bother with anything about versions.

00:25:55.230 --> 00:26:00.680
It happens without you doing anything,
just by enabling Auto Save.

00:26:01.680 --> 00:26:03.950
However,
there were some optimizations that

00:26:03.950 --> 00:26:06.750
we made to version preservation
in Mountain Lion that some

00:26:06.820 --> 00:26:09.210
applications may need to be aware of.

00:26:09.870 --> 00:26:15.490
There are two times when NSDoctument
might decide to save a version.

00:26:15.610 --> 00:26:18.660
One happens immediately prior to saving.

00:26:19.430 --> 00:26:25.310
In Lion, when we decide to preserve
a document during saving,

00:26:26.110 --> 00:26:30.590
We would copy the document into the
version storage in a manner that happens

00:26:30.590 --> 00:26:32.970
synchronously on the main thread.

00:26:33.390 --> 00:26:36.410
Then finally,
wrote the new contents of the document.

00:26:36.550 --> 00:26:42.930
This could result in a long wait for the
user when the document is sufficiently

00:26:42.930 --> 00:26:44.960
large that the copy takes a while.

00:26:45.070 --> 00:26:48.040
In Mountain Lion,
we added an optimization that takes

00:26:48.040 --> 00:26:53.060
advantage of the backup file that
happens during NSDoctument safe saving.

00:26:53.760 --> 00:27:01.100
And NSDocument Safe Saving can
work by first moving the document,

00:27:01.100 --> 00:27:04.120
renaming it so that it
has a different name,

00:27:04.680 --> 00:27:07.260
indicating that it's a backup.

00:27:08.550 --> 00:27:13.100
Once that file is moved aside,
then we write the new contents in place.

00:27:13.350 --> 00:27:16.500
And since the backup file
contains the prior contents that

00:27:16.500 --> 00:27:21.250
we wanted to save into versions,
we can simply move that file into

00:27:21.250 --> 00:27:24.940
the version storage since the
user doesn't need it anymore since

00:27:25.020 --> 00:27:26.820
the save completed successfully.

00:27:26.860 --> 00:27:31.850
This avoids the wait for the
copy that we had in Lion.

00:27:33.170 --> 00:27:35.720
Again, most applications don't
need to think about this.

00:27:35.720 --> 00:27:37.900
It happens automatically.

00:27:37.940 --> 00:27:42.010
But those who override the method
WriteSafelyToURL of type for save

00:27:42.100 --> 00:27:47.550
operation error and don't call super need
to be aware of a contract that now exists

00:27:47.550 --> 00:27:50.180
between this method and its caller.

00:27:50.510 --> 00:27:54.210
That contract is that
before the method returns,

00:27:54.340 --> 00:27:59.330
writeSafetyURL is required to save the
original contents of the document to the

00:27:59.640 --> 00:28:05.300
URL specified by backup file URL when
that method returns a non-nil value.

00:28:06.400 --> 00:28:09.980
Some applications that override
writeSafetyURL do so to implement

00:28:10.000 --> 00:28:11.740
incremental saving in place.

00:28:11.740 --> 00:28:14.690
In these cases,
it might not be possible to

00:28:14.880 --> 00:28:19.260
efficiently save the previous
contents of the document to backup

00:28:19.370 --> 00:28:21.950
file URL in an efficient manner.

00:28:22.520 --> 00:28:25.090
In this case,
it's appropriate to override

00:28:25.200 --> 00:28:27.280
backup file URL and return nil.

00:28:27.280 --> 00:28:32.490
This is a signal to NSDoctument that
this optimization should not be used

00:28:32.490 --> 00:28:35.260
and the old version preservation.

00:28:35.400 --> 00:28:38.140
technique be used instead.

00:28:42.100 --> 00:28:44.550
And NSDoctomate also preserves
versions after saving,

00:28:44.550 --> 00:28:47.470
when the user explicitly saves,
since we use that as a hint,

00:28:47.630 --> 00:28:50.580
meaning the user is interested in
this particular version and may

00:28:50.580 --> 00:28:53.490
want to go back to it in the future.

00:28:54.380 --> 00:28:57.620
and Mountain Lion,
we did this preservation by,

00:28:57.940 --> 00:29:00.120
when we finished writing,

00:29:00.670 --> 00:29:06.300
copying the newly saved version of
the document into version storage.

00:29:06.450 --> 00:29:08.760
This happened on the main
thread in a manner that,

00:29:08.810 --> 00:29:13.020
again, when sufficiently large,
would block the user from

00:29:13.020 --> 00:29:15.830
interacting with the application.

00:29:16.710 --> 00:29:19.160
In Mountain Lion,
we simply moved this copy

00:29:19.160 --> 00:29:22.130
onto a non-main thread.

00:29:22.140 --> 00:29:29.130
And this happens for any applications
linked against the 10.8 SDK.

00:29:29.440 --> 00:29:34.100
This eliminates the
hang on the main thread.

00:29:35.100 --> 00:29:37.810
And most applications don't
need to think about this,

00:29:37.810 --> 00:29:42.440
since most file access happens
through NSDoctument's saving path.

00:29:42.530 --> 00:29:44.760
However,
if you do any additional file access,

00:29:44.940 --> 00:29:49.590
you need to make sure that that file
access does not happen during the copy.

00:29:50.530 --> 00:29:52.400
If you attempt to write
to that file example,

00:29:52.400 --> 00:29:55.640
for example, while NSDoctument is trying
to save it into versions,

00:29:55.700 --> 00:30:01.140
you could end up with a corrupt version
of the document in the version storage.

00:30:01.210 --> 00:30:04.550
So the solution is to wait until
the end of that file access by

00:30:04.700 --> 00:30:08.930
using the file access serialization
APIs that I showed you earlier.

00:30:10.900 --> 00:30:12.600
So that's it for Auto Save.

00:30:12.600 --> 00:30:16.030
There's several topics
that we discussed today,

00:30:16.070 --> 00:30:21.250
but primarily I want
you to get across that,

00:30:21.250 --> 00:30:25.640
again, we believe Auto Save is the
modern document experience that

00:30:25.640 --> 00:30:26.690
we want to provide for users.

00:30:26.690 --> 00:30:30.750
So they don't have to think about the
difference between what they see on

00:30:30.750 --> 00:30:33.130
screen and what's on disk at any time.

00:30:34.920 --> 00:30:37.460
And it's also the last step
to enabling iCloud in your

00:30:37.460 --> 00:30:39.400
NSDoctum based applications.

00:30:39.470 --> 00:30:41.740
So let's return to talking
about it and talk about the

00:30:41.740 --> 00:30:47.030
mechanics of how iCloud works,
starting with the UI.

00:30:47.100 --> 00:30:51.080
I showed you a quick demo earlier
about how to open iCloud documents.

00:30:51.200 --> 00:30:53.260
This is done primarily through
the app-centric open panel.

00:30:53.320 --> 00:30:58.140
This open panel is unique because,
unlike previous versions of Mac OS X,

00:30:58.140 --> 00:30:59.800
it is non-modal.

00:30:59.880 --> 00:31:05.130
And as such, we need new API on
NSDocumentController to support this.

00:31:05.100 --> 00:31:10.900
[Transcript missing]

00:31:11.210 --> 00:31:13.970
So we've added beginOpenPanel
with completion handler,

00:31:13.970 --> 00:31:18.070
which is a method you might invoke,
for example, in an override of

00:31:18.120 --> 00:31:22.190
NSDoctrl's open document,
and beginOpenPanel for

00:31:22.320 --> 00:31:26.630
types completion handler,
which is a method you might override

00:31:26.700 --> 00:31:29.010
to customize the open panel.

00:31:31.480 --> 00:31:34.080
Getting documents in and out of
iCloud is also done primarily

00:31:34.170 --> 00:31:36.640
through the app-centric open panel.

00:31:37.700 --> 00:31:42.170
But NSDoctoment also provides menu
items called Move To and Move to iCloud,

00:31:42.170 --> 00:31:46.740
which allow the user to move documents
anywhere on the system without

00:31:46.740 --> 00:31:50.630
having to leave the application
or very quickly directly to iCloud.

00:31:50.870 --> 00:31:54.280
These operations are implemented
with a new method on NSDoctoment,

00:31:54.280 --> 00:31:58.280
Move to URL Completion Handler,
which you can override if you need

00:31:58.280 --> 00:32:00.820
to do any customization of a move.

00:32:02.690 --> 00:32:06.420
The last way documents
get into iCloud is drafts.

00:32:06.550 --> 00:32:10.530
Drafts are a new concept
in Mountain Lion.

00:32:10.610 --> 00:32:13.390
And the way it works is that
whenever the user creates a

00:32:13.470 --> 00:32:16.590
document in an iCloud-based,
an iCloud and its

00:32:16.600 --> 00:32:20.250
document-based application,
that document is destined

00:32:20.260 --> 00:32:23.780
to be saved into your
application's Ubiquiti container.

00:32:24.500 --> 00:32:29.200
Indeed, when the user starts making
changes to that new document,

00:32:29.220 --> 00:32:33.130
NSDocument will save a user-visible
file directly into the Ubiquiti

00:32:33.190 --> 00:32:37.670
container using an a Save As operation,
which I'll discuss in a moment.

00:32:40.220 --> 00:32:42.940
When it does so,
it marks this document as a draft.

00:32:42.940 --> 00:32:46.260
And what that means is that the
user hasn't chosen an explicit

00:32:46.340 --> 00:32:47.990
name or location for this document.

00:32:48.000 --> 00:32:51.920
So when the user chooses to
explicitly save or close the document,

00:32:51.920 --> 00:32:55.720
we'll still show the Save panel to
allow them to choose an explicit

00:32:55.780 --> 00:32:58.590
name or location or delete the
document if they decide they

00:32:58.660 --> 00:33:00.150
don't want to keep it after all.

00:33:14.590 --> 00:33:14.590
This draft status remains
until the user chooses to save,

00:33:14.590 --> 00:33:14.590
rename, move,
or any other operation that tells

00:33:14.590 --> 00:33:14.590
us that the user is interested in
keeping this file around indefinitely.

00:33:15.120 --> 00:33:17.840
And that happens,
the draft status is removed,

00:33:18.090 --> 00:33:21.340
and we no longer show the
Save panel on Save or Close.

00:33:23.700 --> 00:33:28.390
There are several APIs related to
drafts available in Mountain Lion.

00:33:28.530 --> 00:33:32.550
The first is, as I said,
NSAutoSaveAs operation.

00:33:33.010 --> 00:33:37.790
This fills in the last space in the
table that I showed you earlier.

00:33:37.910 --> 00:33:42.940
It's an automatic operation that happens
when the user edits the document.

00:33:42.990 --> 00:33:47.970
And it's very similar to Save As in
that it creates a new user-visible file,

00:33:48.300 --> 00:34:03.600
[Transcript missing]

00:34:05.300 --> 00:34:09.440
There are other APIs, such as accessors,
for the draft status of a document.

00:34:09.440 --> 00:34:12.650
You have the ability to
customize the name of a draft.

00:34:12.720 --> 00:34:14.690
For example,
if your application uses templates

00:34:14.760 --> 00:34:18.350
for creating untitled documents,
you can give the user some

00:34:18.380 --> 00:34:24.120
more information about what
these draft documents are by,

00:34:24.300 --> 00:34:26.870
for example, using those template names.

00:34:26.940 --> 00:34:30.140
In a word processing application,
you could have a template

00:34:30.210 --> 00:34:32.770
for a resume or a newsletter.

00:34:33.700 --> 00:34:36.980
And when the user creates these
drafts of these templates,

00:34:37.060 --> 00:34:43.470
they can be saved as these names
in iCloud instead of untitled,

00:34:43.480 --> 00:34:45.400
untitled 2, untitled 3, so forth.

00:34:45.880 --> 00:34:49.690
Finally, if there is a special case where
you have a document subclass

00:34:49.790 --> 00:34:52.970
where drafts are not appropriate,
you can disable them by overriding

00:34:52.970 --> 00:34:55.240
Auto Save's drafts and returning no.

00:34:55.240 --> 00:35:01.380
Let's move on to how iCloud works under
the covers a little bit more in depth.

00:35:02.200 --> 00:35:06.650
Maybe we can talk later about how your
application should interact with iCloud.

00:35:06.660 --> 00:35:11.530
When your application wants to make
changes to the document's file,

00:35:11.540 --> 00:35:17.240
it starts a coordinated write
and saves the document within

00:35:17.240 --> 00:35:19.180
that coordinated write.

00:35:20.610 --> 00:35:24.530
When this coordinated write happens
within the Ubiquiti container,

00:35:24.530 --> 00:35:27.090
the system notices this,
takes those changes,

00:35:27.280 --> 00:35:29.520
and uploads them to iCloud.

00:35:29.990 --> 00:35:33.460
And those changes are made available
to all other devices connected

00:35:33.540 --> 00:35:35.970
to the same iCloud account.

00:35:38.270 --> 00:35:40.340
In the other direction,
when receiving changes

00:35:40.890 --> 00:35:44.400
from another machine,
those get uploaded to iCloud.

00:35:44.650 --> 00:35:47.260
and download it to your local machine.

00:35:47.580 --> 00:35:53.170
What the system will do is it will
itself start a coordinated write.

00:35:54.240 --> 00:35:57.670
And if that particular document
is still open in your application,

00:35:57.690 --> 00:35:59.470
it will take note of that.

00:36:00.030 --> 00:36:04.700
And when the write completes,
it will revert to show the user the

00:36:04.700 --> 00:36:08.080
current contents of that document.

00:36:09.220 --> 00:36:14.740
Finally, sometimes changes can happen
simultaneously or simultaneously

00:36:14.740 --> 00:36:16.840
in the point of view of iCloud.

00:36:16.900 --> 00:36:20.100
And when those changes
get uploaded to iCloud,

00:36:20.340 --> 00:36:23.980
it doesn't have enough information
to make a decision about which file

00:36:24.040 --> 00:36:26.050
is supposed to be the most current.

00:36:26.420 --> 00:36:31.320
So instead of attempting that,
it uploads every version of

00:36:31.320 --> 00:36:36.010
that document to every peer,
and it's the user's

00:36:36.110 --> 00:36:40.630
responsibility to decide which
version to keep going forward.

00:36:40.750 --> 00:36:44.620
And once the user makes that
decision on one machine,

00:36:44.680 --> 00:36:49.080
that decision is propagated to all of the
devices connected to the same account.

00:36:49.140 --> 00:36:52.710
Now let's talk about best practices
when enabling iCloud in your

00:36:52.710 --> 00:36:54.900
NSDoctument-based application.

00:36:55.730 --> 00:36:59.200
First, override NSDoctument
as little as possible.

00:36:59.200 --> 00:37:02.420
NSDoctument provides a lot
of functionality for you,

00:37:02.420 --> 00:37:05.570
and the less that you override,
or the lower level that you

00:37:05.570 --> 00:37:08.670
override NSDoctument's methods,
the more that you're

00:37:08.670 --> 00:37:12.380
going to get for free,
and the more consistent you're going to

00:37:12.380 --> 00:37:15.500
be with other applications on the system.

00:37:16.610 --> 00:37:23.030
Next, the open panel for iCloud
provides a simplified view of the

00:37:23.030 --> 00:37:26.480
user's iCloud document library.

00:37:27.800 --> 00:37:30.850
And as such,
it does not show the accessory view

00:37:31.180 --> 00:37:33.900
that may be attached to an open panel.

00:37:34.100 --> 00:37:39.230
So your application should look
at alternative ways to providing

00:37:39.230 --> 00:37:43.310
the same functionality as your
open panel accessory views to

00:37:43.310 --> 00:37:46.030
get the same functionality.

00:37:48.040 --> 00:37:51.170
Since NSDoctument's conflict
resolution panel uses

00:37:51.170 --> 00:37:53.880
Quick Look thumbnail and previews,

00:37:54.600 --> 00:37:58.220
Your application should provide
a quality Quick Look generator so

00:37:58.220 --> 00:38:02.610
the user has as much information as
possible when resolving conflicts.

00:38:02.620 --> 00:38:05.880
This is good advice in general,
since Quick Look is used

00:38:05.990 --> 00:38:07.600
throughout the system.

00:38:07.600 --> 00:38:12.390
Next,
you should think about file formats.

00:38:12.690 --> 00:38:17.920
First, think about forward and
backward compatibility.

00:38:19.610 --> 00:38:24.360
Sometimes users will not have the
latest version of your application

00:38:24.360 --> 00:38:26.820
on all their iCloud-enabled devices.

00:38:26.820 --> 00:38:31.180
And so you need to be prepared
to handle what happens when the

00:38:31.190 --> 00:38:35.850
user attempts to open a document
created with a new version of your

00:38:35.850 --> 00:38:38.720
application with an old version,
and vice versa.

00:38:41.240 --> 00:38:46.700
Also, if your application has both
Mac OS and iOS versions,

00:38:46.920 --> 00:38:50.710
You need to make sure that there isn't
any device-specific information saved in

00:38:50.720 --> 00:38:56.460
the file that would not be interpreted
properly on a different platform.

00:39:00.830 --> 00:39:06.470
So, on iOS devices, as you know,
the file system isn't

00:39:06.470 --> 00:39:09.160
accessible by the user.

00:39:09.160 --> 00:39:14.720
And it's possible to hide
information in files on iOS,

00:39:14.770 --> 00:39:17.200
such as an undo stack.

00:39:17.200 --> 00:39:25.630
This isn't really appropriate when using
iCloud because those files get synced,

00:39:25.630 --> 00:39:29.370
get downloaded to OS X devices.

00:39:50.350 --> 00:39:50.470
So, on iOS devices, as you know,
the file system isn't

00:39:50.470 --> 00:39:50.470
accessible by the user.

00:39:50.470 --> 00:39:50.470
And it's possible to hide
information in files on iOS.

00:39:50.470 --> 00:39:50.470
And it's possible to hide
information in files on iOS.

00:39:51.320 --> 00:39:55.340
For example, when your device receives
changes from iCloud,

00:39:55.400 --> 00:39:57.370
how does it respond?

00:39:58.140 --> 00:40:03.190
It is probably not a good idea to
respond by writing to the file.

00:40:03.310 --> 00:40:08.680
This would result in that
change being uploaded to iCloud,

00:40:08.680 --> 00:40:12.120
downloaded to another machine,
which would then react by making

00:40:12.360 --> 00:40:16.030
another change to the document,
which gets uploaded to iCloud,

00:40:16.060 --> 00:40:16.550
and so forth.

00:40:16.670 --> 00:40:23.000
You end up with a ping-pong situation,
which not only wastes network traffic,

00:40:23.070 --> 00:40:26.730
but is generally problematic.

00:40:29.010 --> 00:40:32.870
It's also possible for users, of course,
to view their documents

00:40:32.940 --> 00:40:35.100
on multiple devices.

00:40:35.100 --> 00:40:40.190
And these devices may not be connected
to the internet at every moment.

00:40:40.580 --> 00:40:43.470
So you want to make sure that all
the changes that get saved into

00:40:43.510 --> 00:40:50.790
your document are the result of
direct user edits to that document.

00:40:51.640 --> 00:40:58.550
If you save other information like
scroll position or current selection,

00:40:58.550 --> 00:41:04.200
this could result in a situation where
unintended conflicts are created,

00:41:04.200 --> 00:41:07.810
which could be confusing to the user
since they haven't actually made any

00:41:07.810 --> 00:41:10.350
significant changes to the document.

00:41:12.360 --> 00:41:14.400
Finally, be sure you test reverting.

00:41:14.400 --> 00:41:18.890
This is used extensively with
file coordination in iCloud.

00:41:19.000 --> 00:41:23.410
When changes are downloaded from iCloud,
again, NSDocument will revert to the

00:41:23.650 --> 00:41:25.560
current contents of the file.

00:41:25.560 --> 00:41:30.010
This is so the user can see the
latest state of the document

00:41:30.010 --> 00:41:32.410
as downloaded from iCloud.

00:41:32.410 --> 00:41:35.150
And you need to make sure
that your application shows

00:41:35.150 --> 00:41:36.890
those new contents properly.

00:41:50.770 --> 00:41:51.950
The same goes for conflict resolution.

00:41:51.950 --> 00:41:51.950
When a conflict is presented and the
user chooses a different version to keep,

00:41:51.950 --> 00:41:51.950
NSDocument reverts to that
version to reflect that decision.

00:41:54.090 --> 00:41:56.640
So NSDoctument provides a
lot of functionality for you,

00:41:56.640 --> 00:41:59.510
as you can see.

00:41:59.570 --> 00:42:03.000
And it's built on
several foundation APIs.

00:42:03.010 --> 00:42:05.280
The first is file coordination.

00:42:05.450 --> 00:42:08.190
Again,
NSDoctument registers itself as a file

00:42:08.190 --> 00:42:13.260
presenter and does file coordination
when reading and writing the document.

00:42:14.060 --> 00:42:19.950
There's also a URL for Ubiquity
Container Identifier on NSFileManager.

00:42:20.180 --> 00:42:26.180
This is the API used to give you the
location of the iCloud container for

00:42:26.180 --> 00:42:29.290
opening and saving documents there.

00:42:32.550 --> 00:42:39.410
NSMetaDataQuery provides API for finding
and getting updates about iCloud files.

00:42:40.820 --> 00:42:46.380
And there are some new APIs in
Foundation in Mountain Lion.

00:42:46.440 --> 00:42:48.860
The first is Ubiquity Identity Token.

00:42:48.970 --> 00:42:54.210
This is an API that gives you
an opaque token representing the

00:42:54.360 --> 00:42:57.910
currently logged in iCloud account.

00:42:58.020 --> 00:43:00.920
What's interesting about this
method is that when the user has

00:43:00.990 --> 00:43:04.210
disabled iCloud documents or has
logged out of iCloud completely,

00:43:04.210 --> 00:43:06.510
this method returns nil.

00:43:06.740 --> 00:43:09.580
And since this method is
very quick at returning,

00:43:09.590 --> 00:43:14.820
it's appropriate for invoking on the main
thread when you need to check if iCloud

00:43:14.820 --> 00:43:17.450
is even enabled in your application.

00:43:17.600 --> 00:43:26.700
[Transcript missing]

00:43:27.280 --> 00:43:31.640
There's also a notification that gets
sent out by NSNotificationCenter when

00:43:31.640 --> 00:43:34.820
this identity changes,
when the user enables or

00:43:34.820 --> 00:43:38.390
disables iCloud documents,
or when the user logs

00:43:38.390 --> 00:43:39.590
in or out of iCloud.

00:43:39.650 --> 00:43:42.890
This is NSUbiquity Identity
to Change notification.

00:43:43.040 --> 00:43:48.110
You can also use this API together
with the Ubiquity Identity

00:43:48.180 --> 00:43:53.310
token to detect changes between

00:43:53.410 --> 00:43:58.220
changes any user's iCloud account
so you can react to that properly.

00:43:58.470 --> 00:44:03.500
Finally, it is possible to disable all of
NSDoctument's iCloud features,

00:44:03.530 --> 00:44:07.740
with the exception of file coordination,
since that's not specifically iCloud.

00:44:07.740 --> 00:44:12.100
It's used for proper file coordination
with the rest of the system.

00:44:12.140 --> 00:44:15.060
But all of the UI and so forth
that NSDoctument provides,

00:44:15.060 --> 00:44:20.590
you can disable by overriding users'
ubiquitous storage and returning no.

00:44:23.780 --> 00:44:29.080
So we talked about a lot of topics today,
about Auto Save, how to adopt it,

00:44:29.080 --> 00:44:33.400
how to ensure responsiveness in
your application when auto saving,

00:44:33.440 --> 00:44:37.770
how to ensure proper serialization,
and things you may need to

00:44:37.940 --> 00:44:39.950
know about with versions.

00:44:40.260 --> 00:44:43.580
With iCloud, we showed you how to adopt
that in your application,

00:44:43.580 --> 00:44:46.990
how it works in the UI and
underneath the covers,

00:44:46.990 --> 00:44:48.080
and best practices.

00:44:48.080 --> 00:44:52.300
There are a lot of sessions related
to iCloud at the conference.

00:44:52.360 --> 00:44:55.770
Earlier today was using
iCloud with UIDocument.

00:44:55.780 --> 00:44:59.970
This, of course,
is the OS X companion to that talk.

00:44:59.980 --> 00:45:04.550
There's also a Using iCloud with
Core Data talk after

00:45:05.090 --> 00:45:08.160
this on Thursday at 4.30.

00:45:08.890 --> 00:45:11.320
And an
Advanced iCloud Document Storage talk

00:45:11.320 --> 00:45:13.060
tomorrow at 3.15.

00:45:13.060 --> 00:45:17.150
This is appropriate if
NSDoctument doesn't really apply

00:45:17.150 --> 00:45:20.920
to your particular application,
or you need to do a little

00:45:20.920 --> 00:45:22.140
bit more with iCloud.

00:45:22.140 --> 00:45:25.830
For more information,
this is a contact info for Mike Jurowicz,

00:45:25.830 --> 00:45:28.890
the Developer Tools and
Performance Evangelist.

00:45:28.940 --> 00:45:32.210
That's it.

00:45:32.240 --> 00:45:33.000
Thank you for coming.
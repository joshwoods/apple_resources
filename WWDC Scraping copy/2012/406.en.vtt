WEBVTT

00:00:10.430 --> 00:00:13.670
Welcome to Adopting Automatic
Reference Counting or ARC.

00:00:13.670 --> 00:00:14.480
I'm Malcolm Crawford.

00:00:14.480 --> 00:00:17.140
I work in developer publications.

00:00:17.710 --> 00:00:21.000
This morning, two main sections.

00:00:21.050 --> 00:00:24.000
I'm going to talk through the
first sections on manual memory

00:00:24.000 --> 00:00:25.990
management and then what is ARC.

00:00:25.990 --> 00:00:29.960
And then Dave Zed will talk in more
detail about how it works and how

00:00:29.960 --> 00:00:31.680
you switch across to using ARC.

00:00:31.790 --> 00:00:35.120
So, to turn first of all to
manual memory management,

00:00:35.120 --> 00:00:37.810
we've used a mechanism for
doing memory management for the

00:00:37.880 --> 00:00:39.520
better part of two decades now.

00:00:39.520 --> 00:00:44.080
We're looking to change that,
so clearly there has to be

00:00:44.080 --> 00:00:46.650
some sort of a problem here.

00:00:46.910 --> 00:00:48.600
Why are we addressing this?

00:00:48.720 --> 00:00:52.200
Well, it turns out that there are
problems with memory management.

00:00:52.300 --> 00:00:56.250
It turns out in particular that memory
management is the number one reason

00:00:56.250 --> 00:01:01.420
for apps crashing and that ultimately
leads then to the number one reason

00:01:01.420 --> 00:01:03.550
for apps being rejected from the store.

00:01:03.570 --> 00:01:06.810
So anything that we can do to
prevent problems with memory

00:01:06.810 --> 00:01:09.040
management is going to be welcome.

00:01:09.180 --> 00:01:11.500
At least to the question though,

00:01:11.950 --> 00:01:13.150
What were the problems?

00:01:13.390 --> 00:01:15.440
Why do people have
problems with traditional

00:01:15.440 --> 00:01:16.890
Objective-C memory management?

00:01:16.900 --> 00:01:22.200
After all, the rules, for example,
were pretty straightforward.

00:01:24.010 --> 00:01:25.900
Thank you!

00:01:25.980 --> 00:01:31.200
However, there were details,
lots of details.

00:01:31.200 --> 00:01:33.680
The simplest among these,
you had to think about the

00:01:33.680 --> 00:01:36.790
naming conventions and adhere
to those and possibly you had to

00:01:36.800 --> 00:01:39.310
think about auto release pools,
blocks came in,

00:01:39.310 --> 00:01:42.430
you had to worry about whether the
method that you used was return an

00:01:42.440 --> 00:01:45.660
auto released object and then think
about not calling it auto released,

00:01:45.660 --> 00:01:49.620
it was an object you didn't own,
and then maybe you wanted to use alloc

00:01:49.620 --> 00:01:55.000
init instead and all of these sum
together then to lead to effectively

00:01:55.000 --> 00:02:00.330
cognitive overload or at the very least
a set of things to think about that

00:02:00.330 --> 00:02:07.030
weren't directly related to your primary
goal of implementing interesting code.

00:02:07.450 --> 00:02:12.840
What made it worse was you needed
to do it right all of the time,

00:02:12.840 --> 00:02:17.650
so you never were allowed to
forget the rules or make a mistake.

00:02:17.650 --> 00:02:21.530
And it turns out that with
the best people in the world,

00:02:21.540 --> 00:02:26.020
this isn't what people are best at.

00:02:26.700 --> 00:03:58.900
[Transcript missing]

00:03:59.300 --> 00:04:04.090
The other observation that was part
of the development of the analyzer

00:04:04.200 --> 00:04:08.320
was the realization that Cocoa has
strong patterns and conventions,

00:04:08.320 --> 00:04:10.930
and in particular the naming conventions.

00:04:11.050 --> 00:04:16.540
So, stepping back again to the analyzer,
if we've got a tool that's able to figure

00:04:16.780 --> 00:04:20.360
out when you're following the rules
and if you're breaking them and so on,

00:04:20.360 --> 00:04:25.770
perhaps we can actually
invert things a little bit.

00:04:25.870 --> 00:04:27.990
So, ARC

00:04:28.870 --> 00:04:33.490
formalizes conventions for us
and then automates the rules

00:04:33.550 --> 00:04:36.300
so that you don't have to.

00:04:36.360 --> 00:04:41.270
And in particular,
this then is what compilers are best at,

00:04:41.350 --> 00:04:44.730
following and adhering to rules.

00:04:46.740 --> 00:04:48.700
It also, in general,
is a sort of big picture,

00:04:48.700 --> 00:04:51.050
a slide that you might have
seen before and probably see

00:04:51.050 --> 00:04:53.910
again during the conference,
fits in with a general

00:04:53.910 --> 00:04:55.660
evolution of Objective-C.

00:04:55.770 --> 00:04:58.580
Starting from C,
we're gradually making the language

00:04:58.580 --> 00:05:02.770
and the environment safer and simpler
through automating aspects of it,

00:05:02.770 --> 00:05:07.160
and now ARC is the
latest addition to that.

00:05:07.230 --> 00:05:10.310
So then, what is ARC?

00:05:12.060 --> 00:05:15.370
In essence,
as you should have really got already,

00:05:15.380 --> 00:05:20.610
ARC provides automatic memory management,
but I'll emphasize a second part,

00:05:20.730 --> 00:05:24.110
for Objective-C objects.

00:05:24.210 --> 00:05:26.040
So it's just for Objective-C.

00:05:26.280 --> 00:05:33.240
ARC obeys and enforces the
existing conventions for you.

00:05:33.790 --> 00:05:38.210
It's important that it obeys and adheres
to the existing conventions because

00:05:38.210 --> 00:05:44.060
this is what then makes ARC compatible
with existing code that you already

00:05:44.060 --> 00:05:49.760
have and with frameworks that we already
have that don't necessarily yet use ARC.

00:05:50.810 --> 00:05:53.560
ARC introduces a couple
of useful features,

00:05:53.560 --> 00:05:55.900
in particular, weak references.

00:05:55.900 --> 00:05:58.460
I'll talk a little bit more
about weak references later.

00:05:58.680 --> 00:06:04.870
And then takes advantage of some
performance optimizations so that you

00:06:04.870 --> 00:06:04.870
don't see any performance regressions.

00:06:05.660 --> 00:06:08.840
Conversely,
a couple of things that ARC is not,

00:06:08.840 --> 00:06:11.980
first of all,
there's a corollary of the first,

00:06:11.980 --> 00:06:14.620
it's not a new runtime memory model.

00:06:15.100 --> 00:06:19.310
It doesn't automate
C structures and so on.

00:06:19.350 --> 00:06:24.420
So you still have to use Malecon-free
and do memory management for core

00:06:24.420 --> 00:06:27.000
foundation style objects yourself.

00:06:27.110 --> 00:06:30.680
It's also not garbage collection.

00:06:30.800 --> 00:06:33.820
So it doesn't have the problems
that garbage collection

00:06:33.820 --> 00:06:38.350
does that are particularly
problematic on devices like this.

00:06:40.770 --> 00:06:45.750
Fundamentally, it works simply by adding
the appropriate retain,

00:06:45.750 --> 00:06:49.650
release, auto-release,
and so on methods for you that you would

00:06:49.710 --> 00:06:51.260
have otherwise had to have written.

00:06:51.420 --> 00:06:54.010
So, quick pop quiz.

00:06:54.860 --> 00:07:02.340
I trust everyone will instantly see the
problem with this method implementation.

00:07:02.340 --> 00:07:06.510
It doesn't adhere to the
proper naming conventions.

00:07:06.690 --> 00:07:11.560
ARC, when you compile this code,
will notice and do the

00:07:11.560 --> 00:07:13.530
right thing for you.

00:07:13.640 --> 00:07:17.200
So it'll add the code that you
should have written yourself.

00:07:17.240 --> 00:07:21.610
Conversely,
if you'd implemented Greeting this way,

00:07:21.610 --> 00:07:25.580
ARC will again realize
and not make any changes.

00:07:25.710 --> 00:07:27.950
The code's already correct.

00:07:29.210 --> 00:07:33.080
As a tangent to this,
a useful aspect of ARC is that

00:07:33.080 --> 00:07:38.540
then both of the possible ways
of implementing this method have,

00:07:38.540 --> 00:07:41.540
in effect, the same cognitive load.

00:07:41.640 --> 00:07:46.470
You no longer have to think about,
"Do I use alloc and init with format,

00:07:46.560 --> 00:07:50.990
or do I use string with format?"
You simply use the method that

00:07:51.010 --> 00:07:54.840
you are most comfortable with,
and don't worry about the

00:07:54.840 --> 00:07:56.870
memory management aspects.

00:07:58.130 --> 00:08:00.080
Hopefully now that's sufficiently
enthused you to switch it on,

00:08:00.160 --> 00:08:02.030
so how do you switch it on?

00:08:02.070 --> 00:08:03.800
There's a project setting in Xcode.

00:08:03.810 --> 00:08:07.730
That's the fundamental thing that
switches the compiler flag for you.

00:08:07.930 --> 00:08:09.390
If you've got...

00:08:09.590 --> 00:08:13.700
A new project,
all projects now default to using ARC,

00:08:13.770 --> 00:08:16.000
so there's no additional
work that you have to do.

00:08:16.100 --> 00:08:20.500
If you have an existing project
that you want to migrate to ARC,

00:08:20.980 --> 00:08:23.800
Then you do actually have
to use a migration tool.

00:08:23.800 --> 00:08:26.780
And all of these then Dave is
going to talk about in more

00:08:27.090 --> 00:08:28.700
detail in the next section.

00:08:30.130 --> 00:08:34.480
Generally, what you should see when you
switch across to ARC is a

00:08:34.480 --> 00:08:36.940
lot of code simply goes away.

00:08:37.070 --> 00:08:40.570
So, typically, for example,
a dialog method just

00:08:40.570 --> 00:08:42.940
doesn't exist anymore.

00:08:42.990 --> 00:08:45.870
Other things become simpler,
so dealing with the memory

00:08:45.910 --> 00:08:47.890
management semantics of blocks.

00:08:48.190 --> 00:08:51.740
leaves you just with the code
that you wanted to write,

00:08:51.840 --> 00:08:54.340
rather than thinking about having
to copy and then auto-release.

00:08:54.340 --> 00:08:56.290
Sorry about that slide.

00:08:57.410 --> 00:09:02.080
An issue that does
come up though is that,

00:09:02.220 --> 00:09:05.040
having talked about the
static analyzer earlier,

00:09:05.090 --> 00:09:10.340
the static analyzer depends on heuristics
to reason about the Objective-C rules of

00:09:10.340 --> 00:09:15.660
memory management conventions and so on,
and isn't necessarily deterministic.

00:09:15.780 --> 00:09:20.400
You can't have a compiler
that isn't deterministic.

00:09:21.100 --> 00:09:23.240
So,
in order to make sure we get consistent

00:09:23.310 --> 00:09:28.110
and reliable results from ARC,
from the general perspective,

00:09:28.110 --> 00:09:30.640
we had to formalize and
automate the best practice,

00:09:30.640 --> 00:09:34.690
but we're also introducing
four new rules.

00:09:35.520 --> 00:09:38.740
That might sound a little
bit like a step backwards,

00:09:38.740 --> 00:09:41.410
but an important aspect here is
because we're formalizing any

00:09:41.450 --> 00:09:45.140
particular automating the rules here,
the compiler can actually

00:09:45.210 --> 00:09:46.790
enforce the rules.

00:09:47.290 --> 00:09:50.300
So even if you forget about
something somewhere online,

00:09:50.300 --> 00:09:53.950
the compiler is there to remind you
and compile time rather than you

00:09:53.950 --> 00:09:56.790
discovering through a crash log later.

00:09:57.310 --> 00:10:00.000
So, let's look at the rules.

00:10:00.090 --> 00:10:04.130
The first one I think I would
call a feature rather than

00:10:04.130 --> 00:10:06.820
a new rule to think about.

00:10:06.920 --> 00:10:11.860
You can't now use retain, release,
auto-release, and so on.

00:10:12.100 --> 00:10:16.970
The benefit here is that you
can't write code like this.

00:10:19.920 --> 00:10:23.780
So we generally regard
this as being a benefit.

00:10:23.960 --> 00:10:26.340
Instead of having to deal about
memory management methods,

00:10:26.410 --> 00:10:28.430
the compiler takes care of it for you.

00:10:28.590 --> 00:10:32.380
It does mean that there are a couple
of other new practices to introduce,

00:10:32.450 --> 00:10:35.170
particularly, for example,
the way you deal with singletons,

00:10:35.220 --> 00:10:37.760
but we've got straightforward
new patterns for those.

00:10:37.760 --> 00:10:41.720
So, rule two.

00:10:42.480 --> 00:10:47.890
You can't use references
to objects in C structs.

00:10:47.930 --> 00:10:50.960
The compiler again has got to be
able to reason about the lifetime

00:10:51.030 --> 00:10:55.400
of objects and that's rather
more difficult in a structure.

00:10:55.440 --> 00:10:59.280
So rather than using structures now,
we're asking you to adhere to what

00:10:59.280 --> 00:11:04.320
has been common best practice anyway
and to use Objective-C objects.

00:11:04.400 --> 00:11:07.090
Not only is this best practice,
but then you get a better

00:11:07.090 --> 00:11:08.300
tool support and so on.

00:11:08.400 --> 00:11:11.150
So where you might have used a
struct before with a reference

00:11:11.150 --> 00:11:14.000
to an Objective-C object,
now simply create a new

00:11:14.000 --> 00:11:15.800
class to represent that.

00:11:15.900 --> 00:11:23.300
[Transcript missing]

00:11:23.450 --> 00:11:27.080
Objective-C objects and core
foundation style objects.

00:11:27.080 --> 00:11:32.570
We've got new casts,
new keywords to do the casting for you.

00:11:32.650 --> 00:11:37.260
A couple of new ones introduced
with Mountain Lion and the old

00:11:37.260 --> 00:11:40.400
style ones from Lion and before.

00:11:40.400 --> 00:11:44.850
Better still, actually,
is if you can possibly avoid using

00:11:44.850 --> 00:11:50.400
core foundation style objects,
avoid using them in the first place.

00:11:50.400 --> 00:11:52.400
An example here might be CFUUID.

00:11:52.400 --> 00:11:58.470
If you're currently using CFUUID,
look towards using NSUUID instead.

00:12:00.340 --> 00:12:02.850
Fourth rule, no auto-release pools.

00:12:02.860 --> 00:12:05.140
So this may not affect
that many people anyway,

00:12:05.140 --> 00:12:06.860
but if you happen to be
using auto-release pools,

00:12:06.860 --> 00:12:09.130
again, the compiler can't do
very much with those,

00:12:09.170 --> 00:12:13.360
so we now have an at
auto-release pool block instead.

00:12:13.450 --> 00:12:17.490
An advantage here is that
this works even without ARC.

00:12:17.560 --> 00:12:23.640
So you'll actually see in any new project
that you create that don't use ARC,

00:12:23.770 --> 00:12:25.400
you'll still see at auto-release pool.

00:12:25.400 --> 00:12:28.330
And it turns out this is
actually much more efficient.

00:12:31.500 --> 00:12:36.160
From your perspective as a developer,
how then do you think about ARC?

00:12:36.240 --> 00:12:37.810
What are the considerations
that you have if you're not

00:12:37.900 --> 00:12:40.100
thinking about memory management?

00:12:40.490 --> 00:12:43.190
Instead of memory management,
you now want to think

00:12:43.270 --> 00:12:45.900
about object ownership.

00:12:46.000 --> 00:12:50.190
You need to think about the references
between objects and how you define those.

00:12:50.260 --> 00:12:53.570
In particular, if you want to assure the
longevity of an object,

00:12:53.570 --> 00:12:55.880
you need to have a
strong reference to it.

00:12:55.900 --> 00:12:59.980
A strong reference to an object
will keep that object alive.

00:13:00.320 --> 00:13:03.230
As soon as there are no strong
references to an object,

00:13:03.250 --> 00:13:05.580
it'll be deallocated.

00:13:05.580 --> 00:13:08.040
So fundamentally,
you have to start thinking

00:13:08.040 --> 00:13:11.260
about your application,
your program from a higher level in

00:13:11.260 --> 00:13:16.100
terms of your object graph and the
relationships between the objects.

00:13:16.100 --> 00:13:19.820
And as a corollary,
stop thinking then about retain

00:13:19.820 --> 00:13:21.960
release and auto release.

00:13:21.960 --> 00:13:25.820
One of the aspects of thinking about
your object graph then is if strong

00:13:26.080 --> 00:13:29.040
references keep an object alive,
what happens if I want to reference to

00:13:29.040 --> 00:13:31.320
an object that doesn't keep it alive?

00:13:31.320 --> 00:13:33.750
This is where weak references come in.

00:13:33.840 --> 00:13:38.030
A weak reference is a reference to an
object that indicates non-ownership.

00:13:38.250 --> 00:13:40.780
It doesn't keep the
referenced object alive.

00:13:40.780 --> 00:13:45.140
Moreover,
unlike existing just simple pointers,

00:13:45.260 --> 00:13:49.180
a weak reference automatically
drops to nil when the object

00:13:49.180 --> 00:13:51.370
that it points to is deallocated.

00:13:51.940 --> 00:13:55.230
Week references supported in
ARC using properties with the week

00:13:55.450 --> 00:13:59.770
property attribute and underscore
underscore week as a variable keyword.

00:13:59.800 --> 00:14:04.550
Week references come into
play in particular when you're

00:14:04.680 --> 00:14:09.650
thinking about the possibility
of cycles in your object graph.

00:14:09.800 --> 00:14:13.800
Just like standard
traditional memory management,

00:14:13.800 --> 00:14:17.430
ARC doesn't give you any protection
against what we used to call retained

00:14:17.430 --> 00:14:20.800
cycles and what we're now going
to call strong reference cycles.

00:14:20.800 --> 00:14:25.590
So if you have a strong reference cycle,
you will still get leaks.

00:14:26.090 --> 00:14:30.190
The good news here at least is that the
patterns that you've used up until now to

00:14:30.280 --> 00:14:31.990
prevent these sorts of things still work.

00:14:31.990 --> 00:14:35.200
So setting property values to
nil and so on will still apply.

00:14:35.340 --> 00:14:38.240
Having a strong reference
from a parent to a child,

00:14:38.240 --> 00:14:42.970
but weak references from child to
parent and so on will all help you avoid

00:14:43.200 --> 00:14:46.200
reference cycles in your object graph.

00:14:46.290 --> 00:14:50.610
Judicious use finally then of
weak references are going to be a

00:14:50.610 --> 00:14:53.960
fundamental tool to combat these.

00:14:55.640 --> 00:14:59.400
Another question that comes to mind is
obviously how well does this perform?

00:14:59.540 --> 00:15:03.080
Am I going to see performance degradation
as a result of switching across to ARC?

00:15:03.240 --> 00:15:07.110
Good news here is, no,
you generally should not.

00:15:07.320 --> 00:15:09.780
Indeed,
what we've usually seen is that the

00:15:10.220 --> 00:15:16.440
peak high watermark of an application's
memory use actually decreases using ARC.

00:15:16.620 --> 00:15:20.340
Moreover, you don't have the sorts of
issues that you might have with

00:15:20.340 --> 00:15:22.110
a garbage collected system.

00:15:22.950 --> 00:15:27.200
So generally,
no problems with performance.

00:15:27.320 --> 00:15:30.760
So in summary,
ARC then provides you with a simplified

00:15:30.770 --> 00:15:36.400
model for memory management that should
lead to you writing less code and be

00:15:36.400 --> 00:15:41.630
able to think about the interesting code
that you actually want to write that

00:15:41.690 --> 00:15:47.260
differentiates your application rather
than the memory management semantics,

00:15:47.260 --> 00:15:49.900
which ultimately leads to more stable,
better-performance applications.

00:15:50.380 --> 00:15:53.580
So, you should use it.

00:15:53.600 --> 00:15:57.720
And with that then,
I'll hand across to Dave.

00:16:04.430 --> 00:16:05.800
Thanks, Malcolm.

00:16:05.930 --> 00:16:07.790
So how does Arc actually work?

00:16:07.880 --> 00:16:11.410
So as Malcolm showed,
memory management is hard.

00:16:11.430 --> 00:16:14.820
There are lots of rules and conventions,
and it's a high hurdle

00:16:14.820 --> 00:16:16.120
for new developers.

00:16:16.140 --> 00:16:18.580
And we really want everybody
to be able to come and write

00:16:18.580 --> 00:16:20.290
great apps for our platforms.

00:16:20.420 --> 00:16:24.700
And it's a constant attention to
detail problem that you'd rather

00:16:24.700 --> 00:16:26.250
not be spending your time on.

00:16:26.320 --> 00:16:28.900
And it requires perfection,
as Malcolm described.

00:16:29.180 --> 00:16:31.190
So let's show you why it can be hard.

00:16:31.460 --> 00:16:34.950
Let's say you were creating
a RPN calculator where you

00:16:34.950 --> 00:16:38.100
can say like five enter,
four plus, and get a result.

00:16:38.140 --> 00:16:39.600
You would need to implement a stack.

00:16:39.670 --> 00:16:40.960
So here's a stack.

00:16:40.990 --> 00:16:43.350
Now, there are lots of bugs here.

00:16:43.560 --> 00:16:45.240
Let's start going through them.

00:16:45.270 --> 00:16:51.980
This array, if we don't retain it,
it's gonna leak because class methods

00:16:51.990 --> 00:16:57.510
in our conventions return auto-released,
so we need to retain this.

00:16:57.700 --> 00:17:15.600
[Transcript missing]

00:17:16.360 --> 00:17:18.110
What else are we missing?

00:17:18.190 --> 00:17:24.070
Well, now that we've balanced this out,
we need to deal with this problem.

00:17:24.160 --> 00:17:27.300
A removeLast object
might have side effects.

00:17:27.390 --> 00:17:29.740
This might invalidate X.

00:17:29.850 --> 00:17:31.860
So how do we work around this?

00:17:32.010 --> 00:17:33.990
Well, we add a retain.

00:17:34.270 --> 00:17:35.550
And we add an auto-release.

00:17:35.710 --> 00:17:40.240
So now any side effects that removeLast
object has will not prevent this object

00:17:40.240 --> 00:17:42.620
from being prematurely deallocated.

00:17:42.750 --> 00:17:43.230
So that's it.

00:17:43.500 --> 00:17:45.090
So that's our stack.

00:17:45.220 --> 00:17:46.580
So ARC makes this easy.

00:17:46.630 --> 00:17:48.120
You can write code naturally.

00:17:48.270 --> 00:17:52.420
And you can break cycles
easily when necessary.

00:17:52.760 --> 00:17:55.640
You can stop worrying about
the individual retains.

00:17:55.690 --> 00:17:57.450
And you can write great apps.

00:17:58.110 --> 00:18:00.650
So what we're going to talk
about next is how ARC works.

00:18:00.870 --> 00:18:02.470
It'll be automating what
you're doing anyway.

00:18:02.580 --> 00:18:04.840
It applies local rules,
both to local variables

00:18:04.840 --> 00:18:08.060
and to return values,
and we'll discuss those in that order.

00:18:08.210 --> 00:18:11.700
And it guarantees local correctness,
and then we optimize after

00:18:11.710 --> 00:18:13.610
we've applied the local rules.

00:18:13.690 --> 00:18:14.690
So what does this look like?

00:18:14.890 --> 00:18:17.140
Let's talk about variables first.

00:18:17.420 --> 00:18:19.900
Let's talk about Objective-C objects
and block pointers.

00:18:19.970 --> 00:18:23.720
This includes local objects,
global objects, parameters,

00:18:23.720 --> 00:18:26.170
instance variables, all variables.

00:18:26.330 --> 00:18:28.760
There are four different
kinds of ownership.

00:18:28.920 --> 00:18:31.940
So as Malcolm talked about,
we have strong references.

00:18:32.080 --> 00:18:33.570
This is the default.

00:18:33.670 --> 00:18:36.770
In fact, if you write this,
the compiler just assumes you wrote this.

00:18:37.000 --> 00:18:39.560
That's what the desired effect is.

00:18:39.680 --> 00:18:40.800
It's the default.

00:18:40.880 --> 00:18:44.070
It is like a retained property,
where as long as this variable is set,

00:18:44.230 --> 00:18:45.140
it's retained.

00:18:45.140 --> 00:18:48.680
If it's set to nil,
then it releases the previous value.

00:18:48.680 --> 00:18:50.040
Very simple rule.

00:18:50.820 --> 00:18:53.630
Now, when you create a variable,
let's say you just

00:18:53.630 --> 00:18:55.980
typed in a string name,
what happens?

00:18:56.080 --> 00:18:58.890
Well, under ARC,
we need to have local simple rules.

00:18:59.050 --> 00:19:03.040
This variable is now initialized to nil,
so you don't have to type that anymore.

00:19:03.140 --> 00:19:08.290
It's safer, it's simpler,
it makes rules easy to implement.

00:19:08.810 --> 00:19:09.950
So, destroying a variable.

00:19:09.960 --> 00:19:13.330
Similarly, just like C,
we have local scoping rules.

00:19:13.400 --> 00:19:16.580
This if block has two curly
braces and that name variable

00:19:16.580 --> 00:19:18.570
is only valid within that scope.

00:19:18.770 --> 00:19:21.780
At the end of that scope,
it's going to be released,

00:19:21.920 --> 00:19:22.780
just like that.

00:19:22.890 --> 00:19:24.760
This is what ARC does for you.

00:19:24.870 --> 00:19:29.170
And this is true for Ivar's and the
DLX method because that's the end of

00:19:29.210 --> 00:19:31.990
the scope of your object when it's done.

00:19:32.680 --> 00:19:35.880
So reading and writing,
let's say you were to assign a variable,

00:19:35.880 --> 00:19:38.090
a new one variable to another.

00:19:38.230 --> 00:19:39.860
What does the compiler do?

00:19:40.030 --> 00:19:45.990
Well, it retains the new one,
takes the old one, assigns the object,

00:19:46.180 --> 00:19:48.840
and then it releases the previous value.

00:19:48.900 --> 00:19:54.230
Again, really simple rules that the
compiler can automate and enforce.

00:19:55.450 --> 00:19:58.260
As for auto-releasing,
let's say there's a very

00:19:58.260 --> 00:20:00.310
common idiom in Cocoa code.

00:20:00.410 --> 00:20:03.640
We have an out parameter for an NSError.

00:20:03.680 --> 00:20:07.120
We check to see whether it's valid,
and if it's valid, then we assign to it.

00:20:07.180 --> 00:20:10.560
The Cocoa convention is
that this is auto-released.

00:20:11.140 --> 00:20:14.740
And in fact, under ARC,
this is what the compiler automates.

00:20:14.820 --> 00:20:18.150
So we recognize this pattern
and we do the right thing.

00:20:18.390 --> 00:20:21.730
Having said this,
this is not a general pattern,

00:20:21.730 --> 00:20:25.810
so you probably won't run
across it much in your own code.

00:20:26.340 --> 00:20:27.820
Finally, unsafe references.

00:20:27.910 --> 00:20:30.940
They're like a traditional variable,
they're completely

00:20:30.940 --> 00:20:32.450
unmanaged by the compiler.

00:20:32.450 --> 00:20:34.990
They're not initialized,
there's no extra logic,

00:20:35.160 --> 00:20:36.490
there's no restrictions.

00:20:36.580 --> 00:20:38.250
So you can put them in C structs.

00:20:38.250 --> 00:20:41.260
And in fact, that's exactly where
you'd want to use them.

00:20:41.260 --> 00:20:43.960
So for example,
if you had a table at Global Scope that

00:20:44.120 --> 00:20:47.540
you wanted to index into with a number
and then get an NSString out of it,

00:20:47.620 --> 00:20:51.640
you would declare that NSString is unsafe
unretained and then be done with it.

00:20:51.640 --> 00:20:53.810
And as long as you
never update that table,

00:20:53.810 --> 00:20:56.090
you're going to be done with it.

00:20:56.220 --> 00:20:59.150
table, the right thing happens.

00:21:00.360 --> 00:21:02.230
Finally, weak references.

00:21:02.450 --> 00:21:05.810
This is a great new concept with ARC,
and this allows for a safe and simple

00:21:05.810 --> 00:21:08.940
way for us to model how to deal with
things that we don't want to own,

00:21:08.950 --> 00:21:11.540
but we want to be able to reach.

00:21:11.720 --> 00:21:14.500
So let's say you had an NSString.

00:21:15.700 --> 00:21:19.400
And you wanted to reference it weekly,
so you could add that variable.

00:21:19.400 --> 00:21:22.140
What the compiler will
omit is a store barrier.

00:21:22.520 --> 00:21:28.290
It'll take the object and then ask the
runtime to update the week variable.

00:21:28.440 --> 00:21:32.820
And then if we were to message it,
the compiler will omit a readweek to

00:21:32.820 --> 00:21:35.470
see if the object is available or not.

00:21:35.470 --> 00:21:40.040
And as hopefully you all know,
it's okay in Objective-C to message nil.

00:21:40.040 --> 00:21:42.450
So if readweek returns nil,
this will be fine.

00:21:42.680 --> 00:21:46.510
Similarly, if we wanted to zero it out,
we could just write nil out to the week

00:21:46.510 --> 00:21:48.160
variable and the right thing will happen.

00:21:49.720 --> 00:21:53.280
And the cool thing about Weak is,
as soon as the object starts destruction,

00:21:53.320 --> 00:21:57.330
the variable becomes nil to any
other clients trying to read it.

00:21:57.620 --> 00:21:58.380
So that's it.

00:21:58.380 --> 00:21:59.740
That's the rules for local variables.

00:21:59.910 --> 00:22:03.210
The rules for return values now
are much like you've already

00:22:03.210 --> 00:22:05.950
done with existing programming.

00:22:06.340 --> 00:22:09.900
And the questions are,
does this transfer ownership?

00:22:09.900 --> 00:22:11.040
Are they returned retained?

00:22:11.040 --> 00:22:13.570
Are we allocating new objects,
for example?

00:22:13.720 --> 00:22:19.540
And it's similar to transferring into
and out of ARC like Malcolm described.

00:22:19.690 --> 00:22:22.900
And we do this by looking
at the method family name.

00:22:23.240 --> 00:22:26.910
The Cocoa convention is that
the first word of the object

00:22:27.260 --> 00:22:29.360
tells you what the semantics are.

00:22:29.360 --> 00:22:33.350
And the first word is the lowercase
part up until the capital part.

00:22:33.440 --> 00:22:39.080
So initWith is an initializer,
initialize is your own thing.

00:22:39.080 --> 00:22:42.030
So the words that we
care about are alloc,

00:22:42.030 --> 00:22:44.980
copy, init, mutable copy, and new.

00:22:45.020 --> 00:22:47.310
These transfer ownership, i.e.

00:22:47.330 --> 00:22:51.540
they return retained or plus one,
and everything else does not.

00:22:51.630 --> 00:22:53.560
So if you have a method
named copyMachine,

00:22:53.560 --> 00:22:54.300
guess what?

00:22:54.300 --> 00:22:58.020
It returns plus one.

00:22:58.200 --> 00:23:01.850
So for normal return values,
let's say we had this basic getter

00:23:01.850 --> 00:23:03.910
to return something called serial.

00:23:04.240 --> 00:23:05.980
There's no transfer of ownership.

00:23:06.020 --> 00:23:09.400
What ARC does is it does what you
should have been doing all along,

00:23:09.400 --> 00:23:12.770
which is you retain the object
and return it auto-released.

00:23:12.840 --> 00:23:16.390
This is the Cocoa convention,
and now ARC makes the natural

00:23:16.390 --> 00:23:18.170
thing do the right thing.

00:23:19.080 --> 00:23:21.250
Similarly,
if you said new serial and now we're

00:23:21.560 --> 00:23:24.920
conforming to the Cocoa convention
for returning plus one,

00:23:24.960 --> 00:23:28.640
ARC will know that we need
to pass this back retained,

00:23:28.750 --> 00:23:32.110
so it'll generate a retain
and return the value.

00:23:34.750 --> 00:23:39.430
So similarly, if on the caller side,
we need the ARC will

00:23:39.430 --> 00:23:41.510
automate based on the name.

00:23:41.610 --> 00:23:44.490
So in this particular case,
we're calling new serial and we're

00:23:44.820 --> 00:23:49.020
just having a temporary variable
that's being passed straight to NSLog.

00:23:49.060 --> 00:23:53.120
Well, ARC's going to automate this and
actually create a temporary variable,

00:23:53.210 --> 00:23:57.720
store it, pass the value to NSLog,
and then when we're done,

00:23:57.720 --> 00:23:58.640
it'll call release.

00:23:58.640 --> 00:24:02.200
I hope you agree that this is much
simpler and a powerful automation

00:24:02.290 --> 00:24:04.140
so you can write natural code.

00:24:06.320 --> 00:24:09.550
So let's go back to that stack and
talk about how ARC applies these

00:24:09.630 --> 00:24:12.580
local rules and then optimizes.

00:24:12.690 --> 00:24:15.090
So here in our NIT,

00:24:15.550 --> 00:24:17.160
ARC is actually going to do this.

00:24:17.200 --> 00:24:21.950
It's going to create a -- it's
going to look at the old variable,

00:24:21.950 --> 00:24:27.220
cache it, retain the incoming variable,
and release the previous one.

00:24:27.320 --> 00:24:31.240
Similarly,
it's going to generate a dialog method

00:24:31.390 --> 00:24:34.980
to balance out the property in the class.

00:24:35.030 --> 00:24:37.870
And ARC will automate
the call to superdialog,

00:24:37.990 --> 00:24:40.720
which is very important so that
way our superclass can clean up its

00:24:40.720 --> 00:24:43.590
properties and instance variables.

00:24:44.650 --> 00:24:46.700
Similarly, let's look at what POP does.

00:24:46.820 --> 00:24:49.150
What does ARC do?

00:24:49.420 --> 00:24:51.140
Well, we have two things to do, in fact.

00:24:51.210 --> 00:24:54.880
We have to follow the
return value convention.

00:24:55.170 --> 00:24:57.240
We have to retain the
previous value -- or,

00:24:57.260 --> 00:25:00.940
sorry, we have to retain what we're
returning and auto-release it.

00:25:01.030 --> 00:25:01.490
So, great.

00:25:01.590 --> 00:25:03.290
We've followed this rule.

00:25:03.520 --> 00:25:11.060
We also need to deal with side effects,
so we need to retain the value X and

00:25:11.060 --> 00:25:14.130
then release it when we're done with it.

00:25:14.190 --> 00:25:18.440
Because, as we talked about earlier,
removeLastObject might have side effects.

00:25:18.550 --> 00:25:21.210
One of the side effects might
be a release of the object,

00:25:21.300 --> 00:25:23.580
so we need to retain it locally.

00:25:23.630 --> 00:25:26.830
When you combine these two,
you notice that we have a

00:25:26.830 --> 00:25:28.970
redundant retain and release.

00:25:29.170 --> 00:25:30.100
Well, guess what?

00:25:30.210 --> 00:25:34.780
We've added an ARC optimizer to the
compiler and we can delete those,

00:25:34.910 --> 00:25:37.200
thus generating the code you
would have written by hand,

00:25:37.300 --> 00:25:41.700
the optimal code, by applying local rules
and then optimizing.

00:25:43.300 --> 00:25:45.150
So in the end,
we can now write natural code.

00:25:45.350 --> 00:25:48.240
We like NSMutableArray
because it's nice and short,

00:25:48.240 --> 00:25:51.190
we only have one set of square brackets,
and ARC does the right thing.

00:25:51.200 --> 00:25:53.720
We don't need to worry
about side effects,

00:25:53.720 --> 00:25:56.710
which, to be the truth of it,
most of us forget about

00:25:56.830 --> 00:26:00.000
them a lot of the time,
and our pop method just works.

00:26:00.000 --> 00:26:04.180
And most of all,
we'd even need to write a dialog method.

00:26:04.180 --> 00:26:05.980
We're all in a rush
to get things working,

00:26:06.060 --> 00:26:08.350
sometimes we can forget to
clean things up at the end,

00:26:08.350 --> 00:26:10.320
and ARC will just automate that for you.

00:26:10.950 --> 00:26:13.580
Putting this all together,
ARC follows the convention

00:26:13.580 --> 00:26:14.860
so you don't have to.

00:26:14.860 --> 00:26:18.620
You can stop worrying about the
procedural aspect of retain and release,

00:26:18.620 --> 00:26:21.060
you know, where do I put the retain,
where do I put the release?

00:26:21.060 --> 00:26:23.280
You can actually focus
on the object graph.

00:26:23.340 --> 00:26:27.060
And you can most of all
focus on making great apps.

00:26:29.510 --> 00:26:31.320
So let's talk about migrating to ARC.

00:26:31.440 --> 00:26:32.170
What is this process?

00:26:32.270 --> 00:26:34.440
How does it work?

00:26:34.600 --> 00:26:36.310
Well, we're going to talk it through.

00:26:36.430 --> 00:26:38.160
We're going to talk about
the migration steps,

00:26:38.280 --> 00:26:41.400
the common issues you might
run into and how to fix them.

00:26:41.500 --> 00:26:44.390
We're going to talk about the deployment
of ARC and where you can use it.

00:26:44.720 --> 00:26:47.890
And then finally,
we'll do a demo of migrating to ARC.

00:26:48.770 --> 00:26:52.470
So, first of all,
you need to be using the latest compiler.

00:26:52.520 --> 00:26:55.700
ARC works as of 3.0,
but 4.0 was announced at this

00:26:55.800 --> 00:26:58.220
conference and has all the latest,
greatest optimizations,

00:26:58.250 --> 00:26:59.930
and you should use it.

00:27:00.010 --> 00:27:06.540
You use CONVERT to Objective-C ARC under
the Edit menu and refactoring of Xcode.

00:27:06.660 --> 00:27:08.970
And you just work in
an iterative process.

00:27:08.990 --> 00:27:12.080
And as you fix issues,
you just go back to Edit, say Refactor,

00:27:12.120 --> 00:27:13.080
try the CONVERT.

00:27:13.340 --> 00:27:17.530
And once all the issues are fixed,
you'll be presented with a dialog box

00:27:17.580 --> 00:27:20.340
asking for your approval for the changes.

00:27:20.380 --> 00:27:21.400
There it is under the menu.

00:27:21.400 --> 00:27:25.830
It started with Xcode 4.2,
but it's available even

00:27:25.830 --> 00:27:28.110
better with each release.

00:27:28.210 --> 00:27:34.100
Once you are done fixing the issues,
the diff you get presented with,

00:27:34.100 --> 00:27:37.570
you'll see all the calls for
retain and release are deleted.

00:27:37.710 --> 00:27:41.600
As we talked about earlier,
one of the rules of ARC is that you can't

00:27:41.600 --> 00:27:44.050
call retain and release or auto-release.

00:27:44.220 --> 00:27:47.460
During the migration,
we have to delete those from your code.

00:27:47.830 --> 00:27:52.320
Similarly,
for simple uses of auto-release pool,

00:27:52.320 --> 00:27:55.490
we will just convert those to
at auto-release pool for you.

00:27:55.850 --> 00:28:00.640
And finally, since assign is a dangling,
unsafe, unretained semantic,

00:28:00.670 --> 00:28:03.880
we will convert those to weak
and give you safe behavior

00:28:03.880 --> 00:28:05.620
for your weak properties.

00:28:05.710 --> 00:28:06.580
So there's two phases.

00:28:06.580 --> 00:28:09.780
Again, we're going to migrate and fix
problems in the iterative process,

00:28:09.780 --> 00:28:13.170
thus we're going each time
to the Edit menu and trying

00:28:13.170 --> 00:28:15.420
again as we fix issues.

00:28:15.540 --> 00:28:20.200
And then the code will be
converted and present you a diff.

00:28:20.630 --> 00:28:25.760
So one of the first issues we'll run into
that was a warning before ARC and now is

00:28:25.760 --> 00:28:29.280
an error is a missing method declaration.

00:28:29.400 --> 00:28:31.630
Because ARC needs to reason
about the memory semantics

00:28:31.750 --> 00:28:35.500
of the code you're writing,
it needs to actually have the prototype,

00:28:35.610 --> 00:28:39.210
the declaration,
so that it knows what's going on.

00:28:39.310 --> 00:28:41.730
So, for example,
if we had a missing declaration here,

00:28:41.830 --> 00:28:45.000
the compiler will emit a warning saying,
"Hey, the receiver,

00:28:45.020 --> 00:28:48.050
we don't know what this selector is.

00:28:48.100 --> 00:28:50.770
You know, hey,
tell us what's going on." Well,

00:28:50.770 --> 00:28:51.420
it's real simple.

00:28:51.420 --> 00:28:54.210
We'll go back to our
interface and fix it.

00:28:54.300 --> 00:28:57.140
Similarly,
let's say you were trying to be

00:28:57.140 --> 00:29:01.010
hyper-optimized and you wrote
an auto-release pool like this

00:29:01.150 --> 00:29:05.930
so that periodically through the
event loop of this while loop,

00:29:05.930 --> 00:29:09.420
we would drain the auto-release
pool and create a new one.

00:29:09.440 --> 00:29:14.040
Well, the great news is that under ARC,
we actually optimize auto-release pools,

00:29:14.070 --> 00:29:16.280
and they're significantly faster.

00:29:16.380 --> 00:29:17.620
So you shouldn't even need to do this.

00:29:17.640 --> 00:29:20.970
So you can just delete
this code to fix this.

00:29:21.190 --> 00:29:24.150
And of course,
this is the warning you'll get

00:29:24.270 --> 00:29:32.870
that it's unavailable this entire
class and you need to fix it.

00:29:33.480 --> 00:29:34.400
Here's an example.

00:29:34.400 --> 00:29:37.180
Because it's so fast,
we can just drop it right into the

00:29:37.350 --> 00:29:42.480
while loop and not worry about it
and just let ARC do the right thing.

00:29:46.300 --> 00:29:48.800
In fact,
it's six times faster than Snow Leopard,

00:29:48.800 --> 00:29:53.410
and it's awesome.

00:29:57.300 --> 00:29:58.620
So here's a subtle one.

00:29:58.800 --> 00:30:02.980
Let's say you have a switch statement
and you love the fact that you can

00:30:02.980 --> 00:30:04.700
declare variables anywhere you need them.

00:30:04.700 --> 00:30:06.800
So you have a right inside
of your case statement,

00:30:06.800 --> 00:30:10.450
you declare a new variable
named date and you assign to it.

00:30:10.690 --> 00:30:14.610
Well, you're going to get an error
from the compiler that the switch

00:30:14.680 --> 00:30:17.100
statement is in a protected scope.

00:30:17.180 --> 00:30:22.610
And because switch statements are
basically syntactic sugar around go to,

00:30:22.610 --> 00:30:25.100
the compiler has a difficult
time modeling what's going on.

00:30:25.610 --> 00:30:27.100
Well, there's a real simple fix.

00:30:27.100 --> 00:30:30.540
Just add two curlies,
give a bounded lifetime to that

00:30:30.540 --> 00:30:35.600
variable within that case statement,
and let the compiler know your intent.

00:30:35.780 --> 00:30:37.720
Real simple.

00:30:38.160 --> 00:30:40.480
Similarly, the Singleton pattern can
get really interesting.

00:30:40.480 --> 00:30:44.780
Let's say you were implementing some
kind of activity indicator and you

00:30:44.780 --> 00:30:47.240
only have one of them in your process.

00:30:47.320 --> 00:30:48.770
You might have said, "Well,
you know what?

00:30:48.960 --> 00:30:50.400
I want this to be really awesome.

00:30:50.400 --> 00:30:53.810
I'm going to take retain,
make it a no-op, release,

00:30:54.110 --> 00:30:57.830
make it a no-op." All these
things are basically no-ops.

00:30:57.830 --> 00:30:57.830
Well,

00:30:57.970 --> 00:31:01.700
There's a bunch of ways we can fix this,
but first you're going to get a

00:31:01.700 --> 00:31:04.290
bunch of errors from the compiler.

00:31:04.590 --> 00:31:07.230
As we talked about earlier,
in order for ARC to be able

00:31:07.350 --> 00:31:10.040
to reason about your code,
it needs to know what

00:31:10.040 --> 00:31:11.620
these methods do exactly.

00:31:11.730 --> 00:31:14.970
And if you're implementing them,
then ARC can't know because

00:31:14.970 --> 00:31:16.340
it's just unbounded.

00:31:16.510 --> 00:31:19.090
So we can't let you implement those.

00:31:19.420 --> 00:31:22.470
So one way you could do this is
you could do a simple singleton

00:31:22.470 --> 00:31:27.360
pattern where your alloc with zone
method allocates a shared instance.

00:31:27.360 --> 00:31:29.140
And once that shared
instance is allocated,

00:31:29.140 --> 00:31:32.430
it always returns that variable.

00:31:32.530 --> 00:31:35.750
Now, of course,
your init method is going to have to

00:31:35.750 --> 00:31:41.040
guard against this and make sure that we
don't reinitialize the shared instance.

00:31:41.160 --> 00:31:44.570
So that's kind of complicated.

00:31:45.590 --> 00:31:48.050
Now, of course,
you could change this so you

00:31:48.050 --> 00:31:52.150
actually had a plus method,
a class method, and allocate your shared

00:31:52.270 --> 00:31:53.360
instance that way.

00:31:53.490 --> 00:31:55.910
Now you don't need to worry about
having init protect against it.

00:31:56.010 --> 00:31:58.510
You don't need to override
this alloc with zone thing.

00:31:58.610 --> 00:32:01.560
You can just make it a much
more formal part of your design

00:32:01.560 --> 00:32:03.480
that there's a shared instance.

00:32:04.630 --> 00:32:07.030
Similarly, if you're worried about
concurrency in your code,

00:32:07.030 --> 00:32:11.420
you could wrap this up with a dispatch
once and use GCD to make sure that

00:32:11.500 --> 00:32:15.760
there are no race conditions in
this shared instance indicator,

00:32:15.760 --> 00:32:17.360
shared indicator.

00:32:18.520 --> 00:32:20.330
One of the things we'd like to point out,
though,

00:32:20.330 --> 00:32:22.000
the classes themselves are instances.

00:32:22.120 --> 00:32:25.930
So you could actually just refactor
your code into a static global variable

00:32:26.540 --> 00:32:31.700
and then change those minus signs to
plus signs for your singleton pattern.

00:32:31.800 --> 00:32:36.650
And then you can just say, hey,
square bracket activity indicator, show.

00:32:36.750 --> 00:32:43.800
And ta-da, you have a singleton pattern,
taking advantage of the fact that

00:32:43.800 --> 00:32:43.800
classes themselves are singletons.

00:32:45.500 --> 00:32:50.180
Similarly,
the delegate pattern gets a lot better.

00:32:50.180 --> 00:32:51.210
You can use week now.

00:32:51.460 --> 00:32:54.610
So in case you forget to say set
delegate nil as a part of your cleanup,

00:32:54.770 --> 00:32:58.740
week will just do the right
thing and set it to nil for you.

00:33:01.060 --> 00:33:02.940
So let's talk about deployment.

00:33:02.970 --> 00:33:06.890
All of these things we've talked about
are available as of line in iOS 5.

00:33:06.980 --> 00:33:10.230
As you saw earlier in the conference,
the adoption rates of both

00:33:10.230 --> 00:33:13.910
of these operating systems
is just very impressive,

00:33:13.910 --> 00:33:17.220
with 80% of our iOS
users already on iOS 5.

00:33:17.510 --> 00:33:22.690
And I don't remember the exact number,
so I won't make it up for Microsoft 10.

00:33:22.840 --> 00:33:27.740
But that was just really ramping up.

00:33:27.740 --> 00:33:27.750
So

00:33:29.390 --> 00:33:32.660
Lion in memory management.

00:33:32.690 --> 00:33:36.480
As you've possibly seen in other talks,
ARC has been really successful.

00:33:36.710 --> 00:33:39.830
We have no heap scans,
no whole app pauses,

00:33:40.020 --> 00:33:44.030
no non-deterministic releases.

00:33:44.150 --> 00:33:45.200
Well, what does this sound like?

00:33:45.270 --> 00:33:49.880
In fact, ARC matches our framework
conventions really well.

00:33:50.100 --> 00:33:52.970
We've really grown to design our
frameworks to rely on the exact

00:33:52.990 --> 00:33:58.360
order of the release of objects,
and ARC automates this very well.

00:33:58.510 --> 00:34:00.500
Because of all this,
we're deprecating GC.

00:34:00.680 --> 00:34:04.180
We really think that a smooth,
fluid user interface is very

00:34:04.180 --> 00:34:06.910
important to our customers,
and great battery life

00:34:06.910 --> 00:34:08.070
is just as important.

00:34:08.310 --> 00:34:11.410
So with that, GC is deprecated.

00:34:12.550 --> 00:34:15.970
With that, I'd now like to switch to the
demo and show you what this

00:34:16.050 --> 00:34:17.640
migration process looks like.

00:34:17.840 --> 00:34:25.330
Right here, I have an app called WikiHow,
which I'll just click run

00:34:25.330 --> 00:34:25.830
to show you before ARC.

00:34:26.230 --> 00:34:31.300
So it gives you basic advice on how to
solve problems that you might run into.

00:34:31.340 --> 00:34:34.530
So you can click around, obviously.

00:34:34.620 --> 00:34:35.740
There we go.

00:34:35.850 --> 00:34:37.870
So let's start the conversion process.

00:34:37.990 --> 00:34:42.510
We go to Edit, we say Refactor,
Convert to Objective-C ARC.

00:34:42.530 --> 00:34:46.230
Now, we can do this on a per-target
basis if we're not ready to

00:34:46.230 --> 00:34:48.080
switch all of our project.

00:34:48.130 --> 00:34:51.250
And if you're really advanced,
you can go through and do

00:34:51.250 --> 00:34:52.700
it on a per-file basis.

00:34:52.700 --> 00:34:56.000
But for the conversion process,
it works on a per-target basis.

00:34:56.100 --> 00:34:57.330
Thank you.

00:34:57.800 --> 00:35:00.460
So let's give it a whirl and
see what problems we run into.

00:35:00.600 --> 00:35:01.700
We ran into 12 problems.

00:35:01.700 --> 00:35:02.930
Okay.

00:35:03.130 --> 00:35:04.680
So let's start with an easy one.

00:35:04.800 --> 00:35:05.100
All right.

00:35:05.100 --> 00:35:06.400
Well, we can't do these.

00:35:06.450 --> 00:35:08.770
We can't implement, retain, release,
all these things.

00:35:08.780 --> 00:35:12.810
So let's just delete that
and let ARC do that for us.

00:35:13.090 --> 00:35:13.270
Great.

00:35:15.480 --> 00:35:16.990
So here's a basic cast.

00:35:17.090 --> 00:35:21.000
Well, we know that this is not
transferring any ownership,

00:35:21.020 --> 00:35:22.920
so we'll just do a bridge.

00:35:22.920 --> 00:35:28.600
And oh, here's one of those tables we
talked about where we have a

00:35:28.640 --> 00:35:34.220
global table of ASCII escape
maps and we have an NSString in.

00:35:34.220 --> 00:35:36.860
So here are the NSStrings that
we see that are just global.

00:35:36.860 --> 00:35:38.190
Oh, great.

00:35:38.190 --> 00:35:42.590
Let's just say unsafe, unretained, done.

00:35:46.000 --> 00:35:47.730
No visible interface.

00:35:47.760 --> 00:35:50.400
So what we're missing
here is the -- sorry,

00:35:50.400 --> 00:35:51.340
multi-line.

00:35:51.380 --> 00:35:58.560
The init with specifier is missing
from our interface declaration.

00:35:58.630 --> 00:36:09.800
So we go to the -- let's
go to the implementation.

00:36:09.800 --> 00:36:09.800
Classes.

00:36:14.900 --> 00:36:28.900
[Transcript missing]

00:36:32.100 --> 00:36:33.400
So here's another case.

00:36:33.500 --> 00:36:36.390
Now here's a case where the
compiler is issuing a fixit.

00:36:36.480 --> 00:36:39.350
Just tells us, great.

00:36:39.550 --> 00:36:41.090
I'll do another fix-it.

00:36:41.090 --> 00:36:45.380
These are, again, returning

00:36:46.350 --> 00:36:49.800
plus zero.

00:36:49.890 --> 00:36:52.110
So here's another case where
we're doing a context parameter

00:36:52.120 --> 00:36:54.490
where we need to do a fix it.

00:37:07.600 --> 00:37:25.200
[Transcript missing]

00:37:26.800 --> 00:37:27.800
Great.

00:37:27.800 --> 00:37:33.760
We've fixed all the issues and now
ARC is about to present us with a diff.

00:37:33.850 --> 00:37:37.140
It's generating the preview,
it's removing all the retains

00:37:37.180 --> 00:37:41.540
and releases and auto releases,
simplifying our dialog methods,

00:37:41.650 --> 00:37:47.850
converting our auto release pools over
to the new simpler and faster syntax.

00:37:49.300 --> 00:37:50.290
All right, great.

00:37:50.300 --> 00:37:51.060
So we get a big diff.

00:37:51.060 --> 00:37:54.340
As you can see here,
a bunch of code is being deleted.

00:37:54.340 --> 00:37:58.380
So we got an entire dialog
method deleted here.

00:37:59.020 --> 00:38:04.400
Similarly, there's that and there's...

00:38:05.910 --> 00:38:09.660
All these releases are disappearing.

00:38:09.670 --> 00:38:11.240
Autorelease disappeared.

00:38:11.240 --> 00:38:13.910
All of the right thing happens
and the code gets simpler.

00:38:14.090 --> 00:38:17.860
So with that, we can click Save.

00:38:21.270 --> 00:38:23.020
we can click run.

00:38:23.030 --> 00:38:24.710
And then ta-da.

00:38:24.710 --> 00:38:26.310
So there we go.

00:38:26.310 --> 00:38:28.920
Now we're back under ARC.

00:38:28.920 --> 00:38:30.820
We can click around.

00:38:30.820 --> 00:38:32.960
How to green your business.

00:38:32.960 --> 00:38:35.080
So ARC is really efficient.

00:38:35.080 --> 00:38:37.230
Great way to green your app.

00:38:37.310 --> 00:38:41.240
So with that,
I'll switch back to the slides.

00:38:41.240 --> 00:38:43.830
So as you've possibly
seen this slide earlier,

00:38:43.960 --> 00:38:47.680
we've been simplifying
Objective-C from the very beginning.

00:38:47.680 --> 00:38:51.970
We've added a thin but very powerful
object-oriented layer on top of C.

00:38:51.970 --> 00:38:55.160
We added retain-release to
make it easier for developers

00:38:55.160 --> 00:38:56.470
to coordinate between objects.

00:38:56.560 --> 00:39:01.180
We added properties to simplify your
getter-setter patterns and synthesis

00:39:01.180 --> 00:39:04.650
to simplify the implementation
of those getters and setters.

00:39:04.650 --> 00:39:07.980
We added blocks to make enumeration
and callbacks very easy.

00:39:07.980 --> 00:39:12.000
And now we've added ARC to delete
even more boilerplate from your code.

00:39:13.890 --> 00:39:15.720
So for more information,
I'd invite you to

00:39:15.720 --> 00:39:17.700
contact Michael Jurwitz.

00:39:17.770 --> 00:39:21.850
We also have a very extensive programming
with ARC release notes that covers all

00:39:21.950 --> 00:39:23.850
these things in great deal as well.

00:39:24.040 --> 00:39:27.940
And then there's always the developer
forums we like to hang out as well.

00:39:28.290 --> 00:39:29.520
We have some related sessions.

00:39:29.580 --> 00:39:32.120
There was a session earlier that
you'll have to catch on video now,

00:39:32.120 --> 00:39:34.440
but it's Modern Objective-C.

00:39:34.440 --> 00:39:37.640
Tomorrow we have a "What's
New in LLVM?" talk.

00:39:37.640 --> 00:39:41.290
And we also have a "Migrating to
Modern Objective-C" talk tomorrow.

00:39:41.380 --> 00:39:43.000
If you have a friend
that missed this talk,

00:39:43.000 --> 00:39:44.240
there's a rehash on Friday.

00:39:44.330 --> 00:39:46.750
And with that, thanks for coming.